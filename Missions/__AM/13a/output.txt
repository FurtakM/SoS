// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 50537 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 46907 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 52649 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 73850 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 74276 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 74734 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 75003 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 74216 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 74910 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 74276 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 74734 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 75003 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 74060 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 74216 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 19116 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 19116 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 19116 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 22525 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 19116 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 74216 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 74401 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 22525 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 19238 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 19238 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 19116 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 50772 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 20134 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 74216 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 74401 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 74564 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 74216 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 74401 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 19116 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 19116 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 19116 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 77608 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 79942 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 79010 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 79251 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 77304 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 76924 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 76520 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 76358 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 76133 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 76018 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 80203 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 80419 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 75827 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 91795 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15139
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14602
14388: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 82
14408: PUSH
14409: LD_INT 83
14411: PUSH
14412: LD_INT 84
14414: PUSH
14415: LD_INT 85
14417: PUSH
14418: LD_INT 86
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 6
14429: PUSH
14430: LD_INT 15
14432: PUSH
14433: LD_INT 16
14435: PUSH
14436: LD_INT 7
14438: PUSH
14439: LD_INT 12
14441: PUSH
14442: LD_INT 13
14444: PUSH
14445: LD_INT 10
14447: PUSH
14448: LD_INT 14
14450: PUSH
14451: LD_INT 20
14453: PUSH
14454: LD_INT 21
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 32
14465: PUSH
14466: LD_INT 27
14468: PUSH
14469: LD_INT 36
14471: PUSH
14472: LD_INT 69
14474: PUSH
14475: LD_INT 39
14477: PUSH
14478: LD_INT 34
14480: PUSH
14481: LD_INT 40
14483: PUSH
14484: LD_INT 48
14486: PUSH
14487: LD_INT 49
14489: PUSH
14490: LD_INT 50
14492: PUSH
14493: LD_INT 51
14495: PUSH
14496: LD_INT 52
14498: PUSH
14499: LD_INT 53
14501: PUSH
14502: LD_INT 54
14504: PUSH
14505: LD_INT 55
14507: PUSH
14508: LD_INT 56
14510: PUSH
14511: LD_INT 57
14513: PUSH
14514: LD_INT 58
14516: PUSH
14517: LD_INT 59
14519: PUSH
14520: LD_INT 60
14522: PUSH
14523: LD_INT 61
14525: PUSH
14526: LD_INT 62
14528: PUSH
14529: LD_INT 80
14531: PUSH
14532: LD_INT 82
14534: PUSH
14535: LD_INT 83
14537: PUSH
14538: LD_INT 84
14540: PUSH
14541: LD_INT 85
14543: PUSH
14544: LD_INT 86
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: ST_TO_ADDR
14600: GO 15063
14602: LD_INT 2
14604: DOUBLE
14605: EQUAL
14606: IFTRUE 14610
14608: GO 14832
14610: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14611: LD_ADDR_VAR 0 4
14615: PUSH
14616: LD_INT 35
14618: PUSH
14619: LD_INT 45
14621: PUSH
14622: LD_INT 46
14624: PUSH
14625: LD_INT 47
14627: PUSH
14628: LD_INT 82
14630: PUSH
14631: LD_INT 83
14633: PUSH
14634: LD_INT 84
14636: PUSH
14637: LD_INT 85
14639: PUSH
14640: LD_INT 87
14642: PUSH
14643: LD_INT 70
14645: PUSH
14646: LD_INT 1
14648: PUSH
14649: LD_INT 11
14651: PUSH
14652: LD_INT 3
14654: PUSH
14655: LD_INT 4
14657: PUSH
14658: LD_INT 5
14660: PUSH
14661: LD_INT 6
14663: PUSH
14664: LD_INT 15
14666: PUSH
14667: LD_INT 18
14669: PUSH
14670: LD_INT 7
14672: PUSH
14673: LD_INT 17
14675: PUSH
14676: LD_INT 8
14678: PUSH
14679: LD_INT 20
14681: PUSH
14682: LD_INT 21
14684: PUSH
14685: LD_INT 22
14687: PUSH
14688: LD_INT 72
14690: PUSH
14691: LD_INT 26
14693: PUSH
14694: LD_INT 69
14696: PUSH
14697: LD_INT 39
14699: PUSH
14700: LD_INT 40
14702: PUSH
14703: LD_INT 41
14705: PUSH
14706: LD_INT 42
14708: PUSH
14709: LD_INT 43
14711: PUSH
14712: LD_INT 48
14714: PUSH
14715: LD_INT 49
14717: PUSH
14718: LD_INT 50
14720: PUSH
14721: LD_INT 51
14723: PUSH
14724: LD_INT 52
14726: PUSH
14727: LD_INT 53
14729: PUSH
14730: LD_INT 54
14732: PUSH
14733: LD_INT 55
14735: PUSH
14736: LD_INT 56
14738: PUSH
14739: LD_INT 60
14741: PUSH
14742: LD_INT 61
14744: PUSH
14745: LD_INT 62
14747: PUSH
14748: LD_INT 66
14750: PUSH
14751: LD_INT 67
14753: PUSH
14754: LD_INT 68
14756: PUSH
14757: LD_INT 81
14759: PUSH
14760: LD_INT 82
14762: PUSH
14763: LD_INT 83
14765: PUSH
14766: LD_INT 84
14768: PUSH
14769: LD_INT 85
14771: PUSH
14772: LD_INT 87
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: ST_TO_ADDR
14830: GO 15063
14832: LD_INT 3
14834: DOUBLE
14835: EQUAL
14836: IFTRUE 14840
14838: GO 15062
14840: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14841: LD_ADDR_VAR 0 4
14845: PUSH
14846: LD_INT 46
14848: PUSH
14849: LD_INT 47
14851: PUSH
14852: LD_INT 1
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: LD_INT 82
14860: PUSH
14861: LD_INT 83
14863: PUSH
14864: LD_INT 84
14866: PUSH
14867: LD_INT 85
14869: PUSH
14870: LD_INT 86
14872: PUSH
14873: LD_INT 11
14875: PUSH
14876: LD_INT 9
14878: PUSH
14879: LD_INT 20
14881: PUSH
14882: LD_INT 19
14884: PUSH
14885: LD_INT 21
14887: PUSH
14888: LD_INT 24
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 25
14896: PUSH
14897: LD_INT 28
14899: PUSH
14900: LD_INT 29
14902: PUSH
14903: LD_INT 30
14905: PUSH
14906: LD_INT 31
14908: PUSH
14909: LD_INT 37
14911: PUSH
14912: LD_INT 38
14914: PUSH
14915: LD_INT 32
14917: PUSH
14918: LD_INT 27
14920: PUSH
14921: LD_INT 33
14923: PUSH
14924: LD_INT 69
14926: PUSH
14927: LD_INT 39
14929: PUSH
14930: LD_INT 34
14932: PUSH
14933: LD_INT 40
14935: PUSH
14936: LD_INT 71
14938: PUSH
14939: LD_INT 23
14941: PUSH
14942: LD_INT 44
14944: PUSH
14945: LD_INT 48
14947: PUSH
14948: LD_INT 49
14950: PUSH
14951: LD_INT 50
14953: PUSH
14954: LD_INT 51
14956: PUSH
14957: LD_INT 52
14959: PUSH
14960: LD_INT 53
14962: PUSH
14963: LD_INT 54
14965: PUSH
14966: LD_INT 55
14968: PUSH
14969: LD_INT 56
14971: PUSH
14972: LD_INT 57
14974: PUSH
14975: LD_INT 58
14977: PUSH
14978: LD_INT 59
14980: PUSH
14981: LD_INT 63
14983: PUSH
14984: LD_INT 64
14986: PUSH
14987: LD_INT 65
14989: PUSH
14990: LD_INT 82
14992: PUSH
14993: LD_INT 83
14995: PUSH
14996: LD_INT 84
14998: PUSH
14999: LD_INT 85
15001: PUSH
15002: LD_INT 86
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: ST_TO_ADDR
15060: GO 15063
15062: POP
// if state > - 1 and state < 3 then
15063: LD_VAR 0 3
15067: PUSH
15068: LD_INT 1
15070: NEG
15071: GREATER
15072: PUSH
15073: LD_VAR 0 3
15077: PUSH
15078: LD_INT 3
15080: LESS
15081: AND
15082: IFFALSE 15139
// for i in result do
15084: LD_ADDR_VAR 0 5
15088: PUSH
15089: LD_VAR 0 4
15093: PUSH
15094: FOR_IN
15095: IFFALSE 15137
// if GetTech ( i , side ) <> state then
15097: LD_VAR 0 5
15101: PPUSH
15102: LD_VAR 0 1
15106: PPUSH
15107: CALL_OW 321
15111: PUSH
15112: LD_VAR 0 3
15116: NONEQUAL
15117: IFFALSE 15135
// result := result diff i ;
15119: LD_ADDR_VAR 0 4
15123: PUSH
15124: LD_VAR 0 4
15128: PUSH
15129: LD_VAR 0 5
15133: DIFF
15134: ST_TO_ADDR
15135: GO 15094
15137: POP
15138: POP
// end ;
15139: LD_VAR 0 4
15143: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15144: LD_INT 0
15146: PPUSH
15147: PPUSH
15148: PPUSH
// result := true ;
15149: LD_ADDR_VAR 0 3
15153: PUSH
15154: LD_INT 1
15156: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15157: LD_ADDR_VAR 0 5
15161: PUSH
15162: LD_VAR 0 2
15166: PPUSH
15167: CALL_OW 480
15171: ST_TO_ADDR
// if not tmp then
15172: LD_VAR 0 5
15176: NOT
15177: IFFALSE 15181
// exit ;
15179: GO 15230
// for i in tmp do
15181: LD_ADDR_VAR 0 4
15185: PUSH
15186: LD_VAR 0 5
15190: PUSH
15191: FOR_IN
15192: IFFALSE 15228
// if GetTech ( i , side ) <> state_researched then
15194: LD_VAR 0 4
15198: PPUSH
15199: LD_VAR 0 1
15203: PPUSH
15204: CALL_OW 321
15208: PUSH
15209: LD_INT 2
15211: NONEQUAL
15212: IFFALSE 15226
// begin result := false ;
15214: LD_ADDR_VAR 0 3
15218: PUSH
15219: LD_INT 0
15221: ST_TO_ADDR
// exit ;
15222: POP
15223: POP
15224: GO 15230
// end ;
15226: GO 15191
15228: POP
15229: POP
// end ;
15230: LD_VAR 0 3
15234: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15235: LD_INT 0
15237: PPUSH
15238: PPUSH
15239: PPUSH
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
15244: PPUSH
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
15249: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15250: LD_VAR 0 1
15254: NOT
15255: PUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 257
15265: PUSH
15266: LD_INT 9
15268: NONEQUAL
15269: OR
15270: IFFALSE 15274
// exit ;
15272: GO 15847
// side := GetSide ( unit ) ;
15274: LD_ADDR_VAR 0 9
15278: PUSH
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 255
15288: ST_TO_ADDR
// tech_space := tech_spacanom ;
15289: LD_ADDR_VAR 0 12
15293: PUSH
15294: LD_INT 29
15296: ST_TO_ADDR
// tech_time := tech_taurad ;
15297: LD_ADDR_VAR 0 13
15301: PUSH
15302: LD_INT 28
15304: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15305: LD_ADDR_VAR 0 11
15309: PUSH
15310: LD_VAR 0 1
15314: PPUSH
15315: CALL_OW 310
15319: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15320: LD_VAR 0 11
15324: PPUSH
15325: CALL_OW 247
15329: PUSH
15330: LD_INT 2
15332: EQUAL
15333: IFFALSE 15337
// exit ;
15335: GO 15847
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15337: LD_ADDR_VAR 0 8
15341: PUSH
15342: LD_INT 81
15344: PUSH
15345: LD_VAR 0 9
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 3
15356: PUSH
15357: LD_INT 21
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 69
15379: ST_TO_ADDR
// if not tmp then
15380: LD_VAR 0 8
15384: NOT
15385: IFFALSE 15389
// exit ;
15387: GO 15847
// if in_unit then
15389: LD_VAR 0 11
15393: IFFALSE 15417
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15395: LD_ADDR_VAR 0 10
15399: PUSH
15400: LD_VAR 0 8
15404: PPUSH
15405: LD_VAR 0 11
15409: PPUSH
15410: CALL_OW 74
15414: ST_TO_ADDR
15415: GO 15437
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15417: LD_ADDR_VAR 0 10
15421: PUSH
15422: LD_VAR 0 8
15426: PPUSH
15427: LD_VAR 0 1
15431: PPUSH
15432: CALL_OW 74
15436: ST_TO_ADDR
// if not enemy then
15437: LD_VAR 0 10
15441: NOT
15442: IFFALSE 15446
// exit ;
15444: GO 15847
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15446: LD_VAR 0 11
15450: PUSH
15451: LD_VAR 0 11
15455: PPUSH
15456: LD_VAR 0 10
15460: PPUSH
15461: CALL_OW 296
15465: PUSH
15466: LD_INT 13
15468: GREATER
15469: AND
15470: PUSH
15471: LD_VAR 0 1
15475: PPUSH
15476: LD_VAR 0 10
15480: PPUSH
15481: CALL_OW 296
15485: PUSH
15486: LD_INT 12
15488: GREATER
15489: OR
15490: IFFALSE 15494
// exit ;
15492: GO 15847
// missile := [ 1 ] ;
15494: LD_ADDR_VAR 0 14
15498: PUSH
15499: LD_INT 1
15501: PUSH
15502: EMPTY
15503: LIST
15504: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15505: LD_VAR 0 9
15509: PPUSH
15510: LD_VAR 0 12
15514: PPUSH
15515: CALL_OW 325
15519: IFFALSE 15548
// missile := Insert ( missile , missile + 1 , 2 ) ;
15521: LD_ADDR_VAR 0 14
15525: PUSH
15526: LD_VAR 0 14
15530: PPUSH
15531: LD_VAR 0 14
15535: PUSH
15536: LD_INT 1
15538: PLUS
15539: PPUSH
15540: LD_INT 2
15542: PPUSH
15543: CALL_OW 2
15547: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15548: LD_VAR 0 9
15552: PPUSH
15553: LD_VAR 0 13
15557: PPUSH
15558: CALL_OW 325
15562: PUSH
15563: LD_VAR 0 10
15567: PPUSH
15568: CALL_OW 255
15572: PPUSH
15573: LD_VAR 0 13
15577: PPUSH
15578: CALL_OW 325
15582: NOT
15583: AND
15584: IFFALSE 15613
// missile := Insert ( missile , missile + 1 , 3 ) ;
15586: LD_ADDR_VAR 0 14
15590: PUSH
15591: LD_VAR 0 14
15595: PPUSH
15596: LD_VAR 0 14
15600: PUSH
15601: LD_INT 1
15603: PLUS
15604: PPUSH
15605: LD_INT 3
15607: PPUSH
15608: CALL_OW 2
15612: ST_TO_ADDR
// if missile < 2 then
15613: LD_VAR 0 14
15617: PUSH
15618: LD_INT 2
15620: LESS
15621: IFFALSE 15625
// exit ;
15623: GO 15847
// x := GetX ( enemy ) ;
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_VAR 0 10
15634: PPUSH
15635: CALL_OW 250
15639: ST_TO_ADDR
// y := GetY ( enemy ) ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_VAR 0 10
15649: PPUSH
15650: CALL_OW 251
15654: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_VAR 0 4
15664: PUSH
15665: LD_INT 1
15667: NEG
15668: PPUSH
15669: LD_INT 1
15671: PPUSH
15672: CALL_OW 12
15676: PLUS
15677: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15678: LD_ADDR_VAR 0 7
15682: PUSH
15683: LD_VAR 0 5
15687: PUSH
15688: LD_INT 1
15690: NEG
15691: PPUSH
15692: LD_INT 1
15694: PPUSH
15695: CALL_OW 12
15699: PLUS
15700: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15701: LD_VAR 0 6
15705: PPUSH
15706: LD_VAR 0 7
15710: PPUSH
15711: CALL_OW 488
15715: NOT
15716: IFFALSE 15738
// begin _x := x ;
15718: LD_ADDR_VAR 0 6
15722: PUSH
15723: LD_VAR 0 4
15727: ST_TO_ADDR
// _y := y ;
15728: LD_ADDR_VAR 0 7
15732: PUSH
15733: LD_VAR 0 5
15737: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15738: LD_ADDR_VAR 0 3
15742: PUSH
15743: LD_INT 1
15745: PPUSH
15746: LD_VAR 0 14
15750: PPUSH
15751: CALL_OW 12
15755: ST_TO_ADDR
// case i of 1 :
15756: LD_VAR 0 3
15760: PUSH
15761: LD_INT 1
15763: DOUBLE
15764: EQUAL
15765: IFTRUE 15769
15767: GO 15786
15769: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_VAR 0 10
15779: PPUSH
15780: CALL_OW 115
15784: GO 15847
15786: LD_INT 2
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15816
15794: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 6
15804: PPUSH
15805: LD_VAR 0 7
15809: PPUSH
15810: CALL_OW 153
15814: GO 15847
15816: LD_INT 3
15818: DOUBLE
15819: EQUAL
15820: IFTRUE 15824
15822: GO 15846
15824: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15825: LD_VAR 0 1
15829: PPUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 7
15839: PPUSH
15840: CALL_OW 154
15844: GO 15847
15846: POP
// end ;
15847: LD_VAR 0 2
15851: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// if not unit or not building then
15860: LD_VAR 0 1
15864: NOT
15865: PUSH
15866: LD_VAR 0 2
15870: NOT
15871: OR
15872: IFFALSE 15876
// exit ;
15874: GO 16034
// x := GetX ( building ) ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: LD_VAR 0 2
15885: PPUSH
15886: CALL_OW 250
15890: ST_TO_ADDR
// y := GetY ( building ) ;
15891: LD_ADDR_VAR 0 6
15895: PUSH
15896: LD_VAR 0 2
15900: PPUSH
15901: CALL_OW 251
15905: ST_TO_ADDR
// for i = 0 to 5 do
15906: LD_ADDR_VAR 0 4
15910: PUSH
15911: DOUBLE
15912: LD_INT 0
15914: DEC
15915: ST_TO_ADDR
15916: LD_INT 5
15918: PUSH
15919: FOR_TO
15920: IFFALSE 16032
// begin _x := ShiftX ( x , i , 3 ) ;
15922: LD_ADDR_VAR 0 7
15926: PUSH
15927: LD_VAR 0 5
15931: PPUSH
15932: LD_VAR 0 4
15936: PPUSH
15937: LD_INT 3
15939: PPUSH
15940: CALL_OW 272
15944: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_VAR 0 6
15954: PPUSH
15955: LD_VAR 0 4
15959: PPUSH
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 273
15967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15968: LD_VAR 0 7
15972: PPUSH
15973: LD_VAR 0 8
15977: PPUSH
15978: CALL_OW 488
15982: NOT
15983: IFFALSE 15987
// continue ;
15985: GO 15919
// if HexInfo ( _x , _y ) = 0 then
15987: LD_VAR 0 7
15991: PPUSH
15992: LD_VAR 0 8
15996: PPUSH
15997: CALL_OW 428
16001: PUSH
16002: LD_INT 0
16004: EQUAL
16005: IFFALSE 16030
// begin ComMoveXY ( unit , _x , _y ) ;
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 111
// exit ;
16026: POP
16027: POP
16028: GO 16034
// end ; end ;
16030: GO 15919
16032: POP
16033: POP
// end ;
16034: LD_VAR 0 3
16038: RET
// export function ScanBase ( side , base_area ) ; begin
16039: LD_INT 0
16041: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16042: LD_ADDR_VAR 0 3
16046: PUSH
16047: LD_VAR 0 2
16051: PPUSH
16052: LD_INT 81
16054: PUSH
16055: LD_VAR 0 1
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL_OW 70
16068: ST_TO_ADDR
// end ;
16069: LD_VAR 0 3
16073: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// result := false ;
16080: LD_ADDR_VAR 0 2
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// side := GetSide ( unit ) ;
16088: LD_ADDR_VAR 0 3
16092: PUSH
16093: LD_VAR 0 1
16097: PPUSH
16098: CALL_OW 255
16102: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16103: LD_ADDR_VAR 0 4
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 248
16117: ST_TO_ADDR
// case nat of 1 :
16118: LD_VAR 0 4
16122: PUSH
16123: LD_INT 1
16125: DOUBLE
16126: EQUAL
16127: IFTRUE 16131
16129: GO 16142
16131: POP
// tech := tech_lassight ; 2 :
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_INT 12
16139: ST_TO_ADDR
16140: GO 16181
16142: LD_INT 2
16144: DOUBLE
16145: EQUAL
16146: IFTRUE 16150
16148: GO 16161
16150: POP
// tech := tech_mortar ; 3 :
16151: LD_ADDR_VAR 0 5
16155: PUSH
16156: LD_INT 41
16158: ST_TO_ADDR
16159: GO 16181
16161: LD_INT 3
16163: DOUBLE
16164: EQUAL
16165: IFTRUE 16169
16167: GO 16180
16169: POP
// tech := tech_bazooka ; end ;
16170: LD_ADDR_VAR 0 5
16174: PUSH
16175: LD_INT 44
16177: ST_TO_ADDR
16178: GO 16181
16180: POP
// if Researched ( side , tech ) then
16181: LD_VAR 0 3
16185: PPUSH
16186: LD_VAR 0 5
16190: PPUSH
16191: CALL_OW 325
16195: IFFALSE 16222
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16197: LD_ADDR_VAR 0 2
16201: PUSH
16202: LD_INT 5
16204: PUSH
16205: LD_INT 8
16207: PUSH
16208: LD_INT 9
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: LIST
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: ST_TO_ADDR
// end ;
16222: LD_VAR 0 2
16226: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16227: LD_INT 0
16229: PPUSH
16230: PPUSH
16231: PPUSH
// if not mines then
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16241
// exit ;
16239: GO 16385
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16241: LD_ADDR_VAR 0 5
16245: PUSH
16246: LD_INT 81
16248: PUSH
16249: LD_VAR 0 1
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 3
16260: PUSH
16261: LD_INT 21
16263: PUSH
16264: LD_INT 3
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: ST_TO_ADDR
// for i in mines do
16284: LD_ADDR_VAR 0 4
16288: PUSH
16289: LD_VAR 0 2
16293: PUSH
16294: FOR_IN
16295: IFFALSE 16383
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16297: LD_VAR 0 4
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_VAR 0 4
16310: PUSH
16311: LD_INT 2
16313: ARRAY
16314: PPUSH
16315: CALL_OW 458
16319: NOT
16320: IFFALSE 16324
// continue ;
16322: GO 16294
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16324: LD_VAR 0 4
16328: PUSH
16329: LD_INT 1
16331: ARRAY
16332: PPUSH
16333: LD_VAR 0 4
16337: PUSH
16338: LD_INT 2
16340: ARRAY
16341: PPUSH
16342: CALL_OW 428
16346: PUSH
16347: LD_VAR 0 5
16351: IN
16352: IFFALSE 16381
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16354: LD_VAR 0 4
16358: PUSH
16359: LD_INT 1
16361: ARRAY
16362: PPUSH
16363: LD_VAR 0 4
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PPUSH
16372: LD_VAR 0 1
16376: PPUSH
16377: CALL_OW 456
// end ;
16381: GO 16294
16383: POP
16384: POP
// end ;
16385: LD_VAR 0 3
16389: RET
// export function Count ( array ) ; var i ; begin
16390: LD_INT 0
16392: PPUSH
16393: PPUSH
// result := 0 ;
16394: LD_ADDR_VAR 0 2
16398: PUSH
16399: LD_INT 0
16401: ST_TO_ADDR
// for i in array do
16402: LD_ADDR_VAR 0 3
16406: PUSH
16407: LD_VAR 0 1
16411: PUSH
16412: FOR_IN
16413: IFFALSE 16437
// if i then
16415: LD_VAR 0 3
16419: IFFALSE 16435
// result := result + 1 ;
16421: LD_ADDR_VAR 0 2
16425: PUSH
16426: LD_VAR 0 2
16430: PUSH
16431: LD_INT 1
16433: PLUS
16434: ST_TO_ADDR
16435: GO 16412
16437: POP
16438: POP
// end ;
16439: LD_VAR 0 2
16443: RET
// export function IsEmpty ( building ) ; begin
16444: LD_INT 0
16446: PPUSH
// if not building then
16447: LD_VAR 0 1
16451: NOT
16452: IFFALSE 16456
// exit ;
16454: GO 16499
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16456: LD_ADDR_VAR 0 2
16460: PUSH
16461: LD_VAR 0 1
16465: PUSH
16466: LD_INT 22
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 255
16478: PUSH
16479: EMPTY
16480: LIST
16481: LIST
16482: PUSH
16483: LD_INT 58
16485: PUSH
16486: EMPTY
16487: LIST
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PPUSH
16493: CALL_OW 69
16497: IN
16498: ST_TO_ADDR
// end ;
16499: LD_VAR 0 2
16503: RET
// export function IsNotFull ( building ) ; begin
16504: LD_INT 0
16506: PPUSH
// if not building then
16507: LD_VAR 0 1
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16535
// result := UnitsInside ( building ) < 6 ;
16516: LD_ADDR_VAR 0 2
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: CALL_OW 313
16530: PUSH
16531: LD_INT 6
16533: LESS
16534: ST_TO_ADDR
// end ;
16535: LD_VAR 0 2
16539: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
16544: PPUSH
16545: PPUSH
// tmp := [ ] ;
16546: LD_ADDR_VAR 0 3
16550: PUSH
16551: EMPTY
16552: ST_TO_ADDR
// list := [ ] ;
16553: LD_ADDR_VAR 0 5
16557: PUSH
16558: EMPTY
16559: ST_TO_ADDR
// for i = 16 to 25 do
16560: LD_ADDR_VAR 0 4
16564: PUSH
16565: DOUBLE
16566: LD_INT 16
16568: DEC
16569: ST_TO_ADDR
16570: LD_INT 25
16572: PUSH
16573: FOR_TO
16574: IFFALSE 16647
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16576: LD_ADDR_VAR 0 3
16580: PUSH
16581: LD_VAR 0 3
16585: PUSH
16586: LD_INT 22
16588: PUSH
16589: LD_VAR 0 1
16593: PPUSH
16594: CALL_OW 255
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PUSH
16603: LD_INT 91
16605: PUSH
16606: LD_VAR 0 1
16610: PUSH
16611: LD_INT 6
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 30
16621: PUSH
16622: LD_VAR 0 4
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: LIST
16635: PUSH
16636: EMPTY
16637: LIST
16638: PPUSH
16639: CALL_OW 69
16643: ADD
16644: ST_TO_ADDR
16645: GO 16573
16647: POP
16648: POP
// for i = 1 to tmp do
16649: LD_ADDR_VAR 0 4
16653: PUSH
16654: DOUBLE
16655: LD_INT 1
16657: DEC
16658: ST_TO_ADDR
16659: LD_VAR 0 3
16663: PUSH
16664: FOR_TO
16665: IFFALSE 16753
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16667: LD_ADDR_VAR 0 5
16671: PUSH
16672: LD_VAR 0 5
16676: PUSH
16677: LD_VAR 0 3
16681: PUSH
16682: LD_VAR 0 4
16686: ARRAY
16687: PPUSH
16688: CALL_OW 266
16692: PUSH
16693: LD_VAR 0 3
16697: PUSH
16698: LD_VAR 0 4
16702: ARRAY
16703: PPUSH
16704: CALL_OW 250
16708: PUSH
16709: LD_VAR 0 3
16713: PUSH
16714: LD_VAR 0 4
16718: ARRAY
16719: PPUSH
16720: CALL_OW 251
16724: PUSH
16725: LD_VAR 0 3
16729: PUSH
16730: LD_VAR 0 4
16734: ARRAY
16735: PPUSH
16736: CALL_OW 254
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: PUSH
16747: EMPTY
16748: LIST
16749: ADD
16750: ST_TO_ADDR
16751: GO 16664
16753: POP
16754: POP
// result := list ;
16755: LD_ADDR_VAR 0 2
16759: PUSH
16760: LD_VAR 0 5
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 2
16769: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16770: LD_INT 0
16772: PPUSH
16773: PPUSH
16774: PPUSH
16775: PPUSH
16776: PPUSH
16777: PPUSH
16778: PPUSH
// if not factory then
16779: LD_VAR 0 1
16783: NOT
16784: IFFALSE 16788
// exit ;
16786: GO 17381
// if control = control_apeman then
16788: LD_VAR 0 4
16792: PUSH
16793: LD_INT 5
16795: EQUAL
16796: IFFALSE 16905
// begin tmp := UnitsInside ( factory ) ;
16798: LD_ADDR_VAR 0 8
16802: PUSH
16803: LD_VAR 0 1
16807: PPUSH
16808: CALL_OW 313
16812: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16813: LD_VAR 0 8
16817: PPUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 12
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PPUSH
16828: CALL_OW 72
16832: NOT
16833: IFFALSE 16843
// control := control_manual ;
16835: LD_ADDR_VAR 0 4
16839: PUSH
16840: LD_INT 1
16842: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16843: LD_ADDR_VAR 0 8
16847: PUSH
16848: LD_VAR 0 1
16852: PPUSH
16853: CALL 16540 0 1
16857: ST_TO_ADDR
// if tmp then
16858: LD_VAR 0 8
16862: IFFALSE 16905
// begin for i in tmp do
16864: LD_ADDR_VAR 0 7
16868: PUSH
16869: LD_VAR 0 8
16873: PUSH
16874: FOR_IN
16875: IFFALSE 16903
// if i [ 1 ] = b_ext_radio then
16877: LD_VAR 0 7
16881: PUSH
16882: LD_INT 1
16884: ARRAY
16885: PUSH
16886: LD_INT 22
16888: EQUAL
16889: IFFALSE 16901
// begin control := control_remote ;
16891: LD_ADDR_VAR 0 4
16895: PUSH
16896: LD_INT 2
16898: ST_TO_ADDR
// break ;
16899: GO 16903
// end ;
16901: GO 16874
16903: POP
16904: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16905: LD_VAR 0 1
16909: PPUSH
16910: LD_VAR 0 2
16914: PPUSH
16915: LD_VAR 0 3
16919: PPUSH
16920: LD_VAR 0 4
16924: PPUSH
16925: LD_VAR 0 5
16929: PPUSH
16930: CALL_OW 448
16934: IFFALSE 16969
// begin result := [ chassis , engine , control , weapon ] ;
16936: LD_ADDR_VAR 0 6
16940: PUSH
16941: LD_VAR 0 2
16945: PUSH
16946: LD_VAR 0 3
16950: PUSH
16951: LD_VAR 0 4
16955: PUSH
16956: LD_VAR 0 5
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: ST_TO_ADDR
// exit ;
16967: GO 17381
// end ; _chassis := AvailableChassisList ( factory ) ;
16969: LD_ADDR_VAR 0 9
16973: PUSH
16974: LD_VAR 0 1
16978: PPUSH
16979: CALL_OW 475
16983: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16984: LD_ADDR_VAR 0 11
16988: PUSH
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 476
16998: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16999: LD_ADDR_VAR 0 12
17003: PUSH
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 477
17013: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17014: LD_ADDR_VAR 0 10
17018: PUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: CALL_OW 478
17028: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17029: LD_VAR 0 9
17033: NOT
17034: PUSH
17035: LD_VAR 0 11
17039: NOT
17040: OR
17041: PUSH
17042: LD_VAR 0 12
17046: NOT
17047: OR
17048: PUSH
17049: LD_VAR 0 10
17053: NOT
17054: OR
17055: IFFALSE 17090
// begin result := [ chassis , engine , control , weapon ] ;
17057: LD_ADDR_VAR 0 6
17061: PUSH
17062: LD_VAR 0 2
17066: PUSH
17067: LD_VAR 0 3
17071: PUSH
17072: LD_VAR 0 4
17076: PUSH
17077: LD_VAR 0 5
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: ST_TO_ADDR
// exit ;
17088: GO 17381
// end ; if not chassis in _chassis then
17090: LD_VAR 0 2
17094: PUSH
17095: LD_VAR 0 9
17099: IN
17100: NOT
17101: IFFALSE 17127
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17103: LD_ADDR_VAR 0 2
17107: PUSH
17108: LD_VAR 0 9
17112: PUSH
17113: LD_INT 1
17115: PPUSH
17116: LD_VAR 0 9
17120: PPUSH
17121: CALL_OW 12
17125: ARRAY
17126: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17127: LD_VAR 0 2
17131: PPUSH
17132: LD_VAR 0 3
17136: PPUSH
17137: CALL 17386 0 2
17141: NOT
17142: IFFALSE 17201
// repeat engine := _engine [ 1 ] ;
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_VAR 0 11
17153: PUSH
17154: LD_INT 1
17156: ARRAY
17157: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17158: LD_ADDR_VAR 0 11
17162: PUSH
17163: LD_VAR 0 11
17167: PPUSH
17168: LD_INT 1
17170: PPUSH
17171: CALL_OW 3
17175: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17176: LD_VAR 0 2
17180: PPUSH
17181: LD_VAR 0 3
17185: PPUSH
17186: CALL 17386 0 2
17190: PUSH
17191: LD_VAR 0 11
17195: PUSH
17196: EMPTY
17197: EQUAL
17198: OR
17199: IFFALSE 17144
// if not control in _control then
17201: LD_VAR 0 4
17205: PUSH
17206: LD_VAR 0 12
17210: IN
17211: NOT
17212: IFFALSE 17238
// control := _control [ rand ( 1 , _control ) ] ;
17214: LD_ADDR_VAR 0 4
17218: PUSH
17219: LD_VAR 0 12
17223: PUSH
17224: LD_INT 1
17226: PPUSH
17227: LD_VAR 0 12
17231: PPUSH
17232: CALL_OW 12
17236: ARRAY
17237: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17238: LD_VAR 0 2
17242: PPUSH
17243: LD_VAR 0 5
17247: PPUSH
17248: CALL 17606 0 2
17252: NOT
17253: IFFALSE 17312
// repeat weapon := _weapon [ 1 ] ;
17255: LD_ADDR_VAR 0 5
17259: PUSH
17260: LD_VAR 0 10
17264: PUSH
17265: LD_INT 1
17267: ARRAY
17268: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17269: LD_ADDR_VAR 0 10
17273: PUSH
17274: LD_VAR 0 10
17278: PPUSH
17279: LD_INT 1
17281: PPUSH
17282: CALL_OW 3
17286: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17287: LD_VAR 0 2
17291: PPUSH
17292: LD_VAR 0 5
17296: PPUSH
17297: CALL 17606 0 2
17301: PUSH
17302: LD_VAR 0 10
17306: PUSH
17307: EMPTY
17308: EQUAL
17309: OR
17310: IFFALSE 17255
// result := [ ] ;
17312: LD_ADDR_VAR 0 6
17316: PUSH
17317: EMPTY
17318: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17319: LD_VAR 0 1
17323: PPUSH
17324: LD_VAR 0 2
17328: PPUSH
17329: LD_VAR 0 3
17333: PPUSH
17334: LD_VAR 0 4
17338: PPUSH
17339: LD_VAR 0 5
17343: PPUSH
17344: CALL_OW 448
17348: IFFALSE 17381
// result := [ chassis , engine , control , weapon ] ;
17350: LD_ADDR_VAR 0 6
17354: PUSH
17355: LD_VAR 0 2
17359: PUSH
17360: LD_VAR 0 3
17364: PUSH
17365: LD_VAR 0 4
17369: PUSH
17370: LD_VAR 0 5
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: ST_TO_ADDR
// end ;
17381: LD_VAR 0 6
17385: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17386: LD_INT 0
17388: PPUSH
// if not chassis or not engine then
17389: LD_VAR 0 1
17393: NOT
17394: PUSH
17395: LD_VAR 0 2
17399: NOT
17400: OR
17401: IFFALSE 17405
// exit ;
17403: GO 17601
// case engine of engine_solar :
17405: LD_VAR 0 2
17409: PUSH
17410: LD_INT 2
17412: DOUBLE
17413: EQUAL
17414: IFTRUE 17418
17416: GO 17456
17418: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17419: LD_ADDR_VAR 0 3
17423: PUSH
17424: LD_INT 11
17426: PUSH
17427: LD_INT 12
17429: PUSH
17430: LD_INT 13
17432: PUSH
17433: LD_INT 14
17435: PUSH
17436: LD_INT 1
17438: PUSH
17439: LD_INT 2
17441: PUSH
17442: LD_INT 3
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: ST_TO_ADDR
17454: GO 17585
17456: LD_INT 1
17458: DOUBLE
17459: EQUAL
17460: IFTRUE 17464
17462: GO 17526
17464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17465: LD_ADDR_VAR 0 3
17469: PUSH
17470: LD_INT 11
17472: PUSH
17473: LD_INT 12
17475: PUSH
17476: LD_INT 13
17478: PUSH
17479: LD_INT 14
17481: PUSH
17482: LD_INT 1
17484: PUSH
17485: LD_INT 2
17487: PUSH
17488: LD_INT 3
17490: PUSH
17491: LD_INT 4
17493: PUSH
17494: LD_INT 5
17496: PUSH
17497: LD_INT 21
17499: PUSH
17500: LD_INT 23
17502: PUSH
17503: LD_INT 22
17505: PUSH
17506: LD_INT 24
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: LIST
17513: LIST
17514: LIST
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: ST_TO_ADDR
17524: GO 17585
17526: LD_INT 3
17528: DOUBLE
17529: EQUAL
17530: IFTRUE 17534
17532: GO 17584
17534: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17535: LD_ADDR_VAR 0 3
17539: PUSH
17540: LD_INT 13
17542: PUSH
17543: LD_INT 14
17545: PUSH
17546: LD_INT 2
17548: PUSH
17549: LD_INT 3
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: LD_INT 5
17557: PUSH
17558: LD_INT 21
17560: PUSH
17561: LD_INT 22
17563: PUSH
17564: LD_INT 23
17566: PUSH
17567: LD_INT 24
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: ST_TO_ADDR
17582: GO 17585
17584: POP
// result := ( chassis in result ) ;
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_VAR 0 1
17594: PUSH
17595: LD_VAR 0 3
17599: IN
17600: ST_TO_ADDR
// end ;
17601: LD_VAR 0 3
17605: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17606: LD_INT 0
17608: PPUSH
// if not chassis or not weapon then
17609: LD_VAR 0 1
17613: NOT
17614: PUSH
17615: LD_VAR 0 2
17619: NOT
17620: OR
17621: IFFALSE 17625
// exit ;
17623: GO 18651
// case weapon of us_machine_gun :
17625: LD_VAR 0 2
17629: PUSH
17630: LD_INT 2
17632: DOUBLE
17633: EQUAL
17634: IFTRUE 17638
17636: GO 17668
17638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17639: LD_ADDR_VAR 0 3
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: LD_INT 2
17649: PUSH
17650: LD_INT 3
17652: PUSH
17653: LD_INT 4
17655: PUSH
17656: LD_INT 5
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: LIST
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 18635
17668: LD_INT 3
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17706
17676: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 1
17684: PUSH
17685: LD_INT 2
17687: PUSH
17688: LD_INT 3
17690: PUSH
17691: LD_INT 4
17693: PUSH
17694: LD_INT 5
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: LIST
17701: LIST
17702: LIST
17703: ST_TO_ADDR
17704: GO 18635
17706: LD_INT 11
17708: DOUBLE
17709: EQUAL
17710: IFTRUE 17714
17712: GO 17744
17714: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17715: LD_ADDR_VAR 0 3
17719: PUSH
17720: LD_INT 1
17722: PUSH
17723: LD_INT 2
17725: PUSH
17726: LD_INT 3
17728: PUSH
17729: LD_INT 4
17731: PUSH
17732: LD_INT 5
17734: PUSH
17735: EMPTY
17736: LIST
17737: LIST
17738: LIST
17739: LIST
17740: LIST
17741: ST_TO_ADDR
17742: GO 18635
17744: LD_INT 4
17746: DOUBLE
17747: EQUAL
17748: IFTRUE 17752
17750: GO 17778
17752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17753: LD_ADDR_VAR 0 3
17757: PUSH
17758: LD_INT 2
17760: PUSH
17761: LD_INT 3
17763: PUSH
17764: LD_INT 4
17766: PUSH
17767: LD_INT 5
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: ST_TO_ADDR
17776: GO 18635
17778: LD_INT 5
17780: DOUBLE
17781: EQUAL
17782: IFTRUE 17786
17784: GO 17812
17786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 3
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: LD_INT 5
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: ST_TO_ADDR
17810: GO 18635
17812: LD_INT 9
17814: DOUBLE
17815: EQUAL
17816: IFTRUE 17820
17818: GO 17846
17820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17821: LD_ADDR_VAR 0 3
17825: PUSH
17826: LD_INT 2
17828: PUSH
17829: LD_INT 3
17831: PUSH
17832: LD_INT 4
17834: PUSH
17835: LD_INT 5
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: ST_TO_ADDR
17844: GO 18635
17846: LD_INT 7
17848: DOUBLE
17849: EQUAL
17850: IFTRUE 17854
17852: GO 17880
17854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17855: LD_ADDR_VAR 0 3
17859: PUSH
17860: LD_INT 2
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: LD_INT 4
17868: PUSH
17869: LD_INT 5
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: LIST
17876: LIST
17877: ST_TO_ADDR
17878: GO 18635
17880: LD_INT 12
17882: DOUBLE
17883: EQUAL
17884: IFTRUE 17888
17886: GO 17914
17888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17889: LD_ADDR_VAR 0 3
17893: PUSH
17894: LD_INT 2
17896: PUSH
17897: LD_INT 3
17899: PUSH
17900: LD_INT 4
17902: PUSH
17903: LD_INT 5
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: LIST
17910: LIST
17911: ST_TO_ADDR
17912: GO 18635
17914: LD_INT 13
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17948
17922: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17923: LD_ADDR_VAR 0 3
17927: PUSH
17928: LD_INT 2
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 4
17936: PUSH
17937: LD_INT 5
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
17946: GO 18635
17948: LD_INT 14
17950: DOUBLE
17951: EQUAL
17952: IFTRUE 17956
17954: GO 17974
17956: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17957: LD_ADDR_VAR 0 3
17961: PUSH
17962: LD_INT 4
17964: PUSH
17965: LD_INT 5
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: ST_TO_ADDR
17972: GO 18635
17974: LD_INT 6
17976: DOUBLE
17977: EQUAL
17978: IFTRUE 17982
17980: GO 18000
17982: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17983: LD_ADDR_VAR 0 3
17987: PUSH
17988: LD_INT 4
17990: PUSH
17991: LD_INT 5
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: ST_TO_ADDR
17998: GO 18635
18000: LD_INT 10
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18026
18008: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18009: LD_ADDR_VAR 0 3
18013: PUSH
18014: LD_INT 4
18016: PUSH
18017: LD_INT 5
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: ST_TO_ADDR
18024: GO 18635
18026: LD_INT 22
18028: DOUBLE
18029: EQUAL
18030: IFTRUE 18034
18032: GO 18060
18034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18035: LD_ADDR_VAR 0 3
18039: PUSH
18040: LD_INT 11
18042: PUSH
18043: LD_INT 12
18045: PUSH
18046: LD_INT 13
18048: PUSH
18049: LD_INT 14
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: ST_TO_ADDR
18058: GO 18635
18060: LD_INT 23
18062: DOUBLE
18063: EQUAL
18064: IFTRUE 18068
18066: GO 18094
18068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18069: LD_ADDR_VAR 0 3
18073: PUSH
18074: LD_INT 11
18076: PUSH
18077: LD_INT 12
18079: PUSH
18080: LD_INT 13
18082: PUSH
18083: LD_INT 14
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
18092: GO 18635
18094: LD_INT 24
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18128
18102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18103: LD_ADDR_VAR 0 3
18107: PUSH
18108: LD_INT 11
18110: PUSH
18111: LD_INT 12
18113: PUSH
18114: LD_INT 13
18116: PUSH
18117: LD_INT 14
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
18126: GO 18635
18128: LD_INT 30
18130: DOUBLE
18131: EQUAL
18132: IFTRUE 18136
18134: GO 18162
18136: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18137: LD_ADDR_VAR 0 3
18141: PUSH
18142: LD_INT 11
18144: PUSH
18145: LD_INT 12
18147: PUSH
18148: LD_INT 13
18150: PUSH
18151: LD_INT 14
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: LIST
18158: LIST
18159: ST_TO_ADDR
18160: GO 18635
18162: LD_INT 25
18164: DOUBLE
18165: EQUAL
18166: IFTRUE 18170
18168: GO 18188
18170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18171: LD_ADDR_VAR 0 3
18175: PUSH
18176: LD_INT 13
18178: PUSH
18179: LD_INT 14
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: ST_TO_ADDR
18186: GO 18635
18188: LD_INT 27
18190: DOUBLE
18191: EQUAL
18192: IFTRUE 18196
18194: GO 18214
18196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18197: LD_ADDR_VAR 0 3
18201: PUSH
18202: LD_INT 13
18204: PUSH
18205: LD_INT 14
18207: PUSH
18208: EMPTY
18209: LIST
18210: LIST
18211: ST_TO_ADDR
18212: GO 18635
18214: LD_INT 28
18216: DOUBLE
18217: EQUAL
18218: IFTRUE 18222
18220: GO 18240
18222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18223: LD_ADDR_VAR 0 3
18227: PUSH
18228: LD_INT 13
18230: PUSH
18231: LD_INT 14
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: ST_TO_ADDR
18238: GO 18635
18240: LD_INT 29
18242: DOUBLE
18243: EQUAL
18244: IFTRUE 18248
18246: GO 18266
18248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18249: LD_ADDR_VAR 0 3
18253: PUSH
18254: LD_INT 13
18256: PUSH
18257: LD_INT 14
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: ST_TO_ADDR
18264: GO 18635
18266: LD_INT 31
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18292
18274: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18275: LD_ADDR_VAR 0 3
18279: PUSH
18280: LD_INT 13
18282: PUSH
18283: LD_INT 14
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: ST_TO_ADDR
18290: GO 18635
18292: LD_INT 26
18294: DOUBLE
18295: EQUAL
18296: IFTRUE 18300
18298: GO 18318
18300: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18301: LD_ADDR_VAR 0 3
18305: PUSH
18306: LD_INT 13
18308: PUSH
18309: LD_INT 14
18311: PUSH
18312: EMPTY
18313: LIST
18314: LIST
18315: ST_TO_ADDR
18316: GO 18635
18318: LD_INT 42
18320: DOUBLE
18321: EQUAL
18322: IFTRUE 18326
18324: GO 18352
18326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18327: LD_ADDR_VAR 0 3
18331: PUSH
18332: LD_INT 21
18334: PUSH
18335: LD_INT 22
18337: PUSH
18338: LD_INT 23
18340: PUSH
18341: LD_INT 24
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: ST_TO_ADDR
18350: GO 18635
18352: LD_INT 43
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18386
18360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18361: LD_ADDR_VAR 0 3
18365: PUSH
18366: LD_INT 21
18368: PUSH
18369: LD_INT 22
18371: PUSH
18372: LD_INT 23
18374: PUSH
18375: LD_INT 24
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: ST_TO_ADDR
18384: GO 18635
18386: LD_INT 44
18388: DOUBLE
18389: EQUAL
18390: IFTRUE 18394
18392: GO 18420
18394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18395: LD_ADDR_VAR 0 3
18399: PUSH
18400: LD_INT 21
18402: PUSH
18403: LD_INT 22
18405: PUSH
18406: LD_INT 23
18408: PUSH
18409: LD_INT 24
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: ST_TO_ADDR
18418: GO 18635
18420: LD_INT 45
18422: DOUBLE
18423: EQUAL
18424: IFTRUE 18428
18426: GO 18454
18428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18429: LD_ADDR_VAR 0 3
18433: PUSH
18434: LD_INT 21
18436: PUSH
18437: LD_INT 22
18439: PUSH
18440: LD_INT 23
18442: PUSH
18443: LD_INT 24
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: ST_TO_ADDR
18452: GO 18635
18454: LD_INT 49
18456: DOUBLE
18457: EQUAL
18458: IFTRUE 18462
18460: GO 18488
18462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18463: LD_ADDR_VAR 0 3
18467: PUSH
18468: LD_INT 21
18470: PUSH
18471: LD_INT 22
18473: PUSH
18474: LD_INT 23
18476: PUSH
18477: LD_INT 24
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18635
18488: LD_INT 51
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18522
18496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 21
18504: PUSH
18505: LD_INT 22
18507: PUSH
18508: LD_INT 23
18510: PUSH
18511: LD_INT 24
18513: PUSH
18514: EMPTY
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: ST_TO_ADDR
18520: GO 18635
18522: LD_INT 52
18524: DOUBLE
18525: EQUAL
18526: IFTRUE 18530
18528: GO 18556
18530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18531: LD_ADDR_VAR 0 3
18535: PUSH
18536: LD_INT 21
18538: PUSH
18539: LD_INT 22
18541: PUSH
18542: LD_INT 23
18544: PUSH
18545: LD_INT 24
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: ST_TO_ADDR
18554: GO 18635
18556: LD_INT 53
18558: DOUBLE
18559: EQUAL
18560: IFTRUE 18564
18562: GO 18582
18564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18565: LD_ADDR_VAR 0 3
18569: PUSH
18570: LD_INT 23
18572: PUSH
18573: LD_INT 24
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: ST_TO_ADDR
18580: GO 18635
18582: LD_INT 46
18584: DOUBLE
18585: EQUAL
18586: IFTRUE 18590
18588: GO 18608
18590: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18591: LD_ADDR_VAR 0 3
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: ST_TO_ADDR
18606: GO 18635
18608: LD_INT 47
18610: DOUBLE
18611: EQUAL
18612: IFTRUE 18616
18614: GO 18634
18616: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_INT 23
18624: PUSH
18625: LD_INT 24
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: ST_TO_ADDR
18632: GO 18635
18634: POP
// result := ( chassis in result ) ;
18635: LD_ADDR_VAR 0 3
18639: PUSH
18640: LD_VAR 0 1
18644: PUSH
18645: LD_VAR 0 3
18649: IN
18650: ST_TO_ADDR
// end ;
18651: LD_VAR 0 3
18655: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18656: LD_INT 0
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
18662: PPUSH
18663: PPUSH
18664: PPUSH
// result := array ;
18665: LD_ADDR_VAR 0 5
18669: PUSH
18670: LD_VAR 0 1
18674: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18675: LD_VAR 0 1
18679: NOT
18680: PUSH
18681: LD_VAR 0 2
18685: NOT
18686: OR
18687: PUSH
18688: LD_VAR 0 3
18692: NOT
18693: OR
18694: PUSH
18695: LD_VAR 0 2
18699: PUSH
18700: LD_VAR 0 1
18704: GREATER
18705: OR
18706: PUSH
18707: LD_VAR 0 3
18711: PUSH
18712: LD_VAR 0 1
18716: GREATER
18717: OR
18718: IFFALSE 18722
// exit ;
18720: GO 19018
// if direction then
18722: LD_VAR 0 4
18726: IFFALSE 18790
// begin d := 1 ;
18728: LD_ADDR_VAR 0 9
18732: PUSH
18733: LD_INT 1
18735: ST_TO_ADDR
// if i_from > i_to then
18736: LD_VAR 0 2
18740: PUSH
18741: LD_VAR 0 3
18745: GREATER
18746: IFFALSE 18772
// length := ( array - i_from ) + i_to else
18748: LD_ADDR_VAR 0 11
18752: PUSH
18753: LD_VAR 0 1
18757: PUSH
18758: LD_VAR 0 2
18762: MINUS
18763: PUSH
18764: LD_VAR 0 3
18768: PLUS
18769: ST_TO_ADDR
18770: GO 18788
// length := i_to - i_from ;
18772: LD_ADDR_VAR 0 11
18776: PUSH
18777: LD_VAR 0 3
18781: PUSH
18782: LD_VAR 0 2
18786: MINUS
18787: ST_TO_ADDR
// end else
18788: GO 18851
// begin d := - 1 ;
18790: LD_ADDR_VAR 0 9
18794: PUSH
18795: LD_INT 1
18797: NEG
18798: ST_TO_ADDR
// if i_from > i_to then
18799: LD_VAR 0 2
18803: PUSH
18804: LD_VAR 0 3
18808: GREATER
18809: IFFALSE 18829
// length := i_from - i_to else
18811: LD_ADDR_VAR 0 11
18815: PUSH
18816: LD_VAR 0 2
18820: PUSH
18821: LD_VAR 0 3
18825: MINUS
18826: ST_TO_ADDR
18827: GO 18851
// length := ( array - i_to ) + i_from ;
18829: LD_ADDR_VAR 0 11
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: LD_VAR 0 3
18843: MINUS
18844: PUSH
18845: LD_VAR 0 2
18849: PLUS
18850: ST_TO_ADDR
// end ; if not length then
18851: LD_VAR 0 11
18855: NOT
18856: IFFALSE 18860
// exit ;
18858: GO 19018
// tmp := array ;
18860: LD_ADDR_VAR 0 10
18864: PUSH
18865: LD_VAR 0 1
18869: ST_TO_ADDR
// for i = 1 to length do
18870: LD_ADDR_VAR 0 6
18874: PUSH
18875: DOUBLE
18876: LD_INT 1
18878: DEC
18879: ST_TO_ADDR
18880: LD_VAR 0 11
18884: PUSH
18885: FOR_TO
18886: IFFALSE 19006
// begin for j = 1 to array do
18888: LD_ADDR_VAR 0 7
18892: PUSH
18893: DOUBLE
18894: LD_INT 1
18896: DEC
18897: ST_TO_ADDR
18898: LD_VAR 0 1
18902: PUSH
18903: FOR_TO
18904: IFFALSE 18992
// begin k := j + d ;
18906: LD_ADDR_VAR 0 8
18910: PUSH
18911: LD_VAR 0 7
18915: PUSH
18916: LD_VAR 0 9
18920: PLUS
18921: ST_TO_ADDR
// if k > array then
18922: LD_VAR 0 8
18926: PUSH
18927: LD_VAR 0 1
18931: GREATER
18932: IFFALSE 18942
// k := 1 ;
18934: LD_ADDR_VAR 0 8
18938: PUSH
18939: LD_INT 1
18941: ST_TO_ADDR
// if not k then
18942: LD_VAR 0 8
18946: NOT
18947: IFFALSE 18959
// k := array ;
18949: LD_ADDR_VAR 0 8
18953: PUSH
18954: LD_VAR 0 1
18958: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18959: LD_ADDR_VAR 0 10
18963: PUSH
18964: LD_VAR 0 10
18968: PPUSH
18969: LD_VAR 0 8
18973: PPUSH
18974: LD_VAR 0 1
18978: PUSH
18979: LD_VAR 0 7
18983: ARRAY
18984: PPUSH
18985: CALL_OW 1
18989: ST_TO_ADDR
// end ;
18990: GO 18903
18992: POP
18993: POP
// array := tmp ;
18994: LD_ADDR_VAR 0 1
18998: PUSH
18999: LD_VAR 0 10
19003: ST_TO_ADDR
// end ;
19004: GO 18885
19006: POP
19007: POP
// result := array ;
19008: LD_ADDR_VAR 0 5
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 5
19022: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19023: LD_INT 0
19025: PPUSH
19026: PPUSH
// result := 0 ;
19027: LD_ADDR_VAR 0 3
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
// if not array or not value in array then
19035: LD_VAR 0 1
19039: NOT
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 1
19050: IN
19051: NOT
19052: OR
19053: IFFALSE 19057
// exit ;
19055: GO 19111
// for i = 1 to array do
19057: LD_ADDR_VAR 0 4
19061: PUSH
19062: DOUBLE
19063: LD_INT 1
19065: DEC
19066: ST_TO_ADDR
19067: LD_VAR 0 1
19071: PUSH
19072: FOR_TO
19073: IFFALSE 19109
// if value = array [ i ] then
19075: LD_VAR 0 2
19079: PUSH
19080: LD_VAR 0 1
19084: PUSH
19085: LD_VAR 0 4
19089: ARRAY
19090: EQUAL
19091: IFFALSE 19107
// begin result := i ;
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_VAR 0 4
19102: ST_TO_ADDR
// exit ;
19103: POP
19104: POP
19105: GO 19111
// end ;
19107: GO 19072
19109: POP
19110: POP
// end ;
19111: LD_VAR 0 3
19115: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19116: LD_INT 0
19118: PPUSH
// vc_chassis := chassis ;
19119: LD_ADDR_OWVAR 37
19123: PUSH
19124: LD_VAR 0 1
19128: ST_TO_ADDR
// vc_engine := engine ;
19129: LD_ADDR_OWVAR 39
19133: PUSH
19134: LD_VAR 0 2
19138: ST_TO_ADDR
// vc_control := control ;
19139: LD_ADDR_OWVAR 38
19143: PUSH
19144: LD_VAR 0 3
19148: ST_TO_ADDR
// vc_weapon := weapon ;
19149: LD_ADDR_OWVAR 40
19153: PUSH
19154: LD_VAR 0 4
19158: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19159: LD_ADDR_OWVAR 41
19163: PUSH
19164: LD_VAR 0 5
19168: ST_TO_ADDR
// end ;
19169: LD_VAR 0 6
19173: RET
// export function WantPlant ( unit ) ; var task ; begin
19174: LD_INT 0
19176: PPUSH
19177: PPUSH
// result := false ;
19178: LD_ADDR_VAR 0 2
19182: PUSH
19183: LD_INT 0
19185: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 437
19200: ST_TO_ADDR
// if task then
19201: LD_VAR 0 3
19205: IFFALSE 19233
// if task [ 1 ] [ 1 ] = p then
19207: LD_VAR 0 3
19211: PUSH
19212: LD_INT 1
19214: ARRAY
19215: PUSH
19216: LD_INT 1
19218: ARRAY
19219: PUSH
19220: LD_STRING p
19222: EQUAL
19223: IFFALSE 19233
// result := true ;
19225: LD_ADDR_VAR 0 2
19229: PUSH
19230: LD_INT 1
19232: ST_TO_ADDR
// end ;
19233: LD_VAR 0 2
19237: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19238: LD_INT 0
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
// if pos < 1 then
19244: LD_VAR 0 2
19248: PUSH
19249: LD_INT 1
19251: LESS
19252: IFFALSE 19256
// exit ;
19254: GO 19559
// if pos = 1 then
19256: LD_VAR 0 2
19260: PUSH
19261: LD_INT 1
19263: EQUAL
19264: IFFALSE 19297
// result := Replace ( arr , pos [ 1 ] , value ) else
19266: LD_ADDR_VAR 0 4
19270: PUSH
19271: LD_VAR 0 1
19275: PPUSH
19276: LD_VAR 0 2
19280: PUSH
19281: LD_INT 1
19283: ARRAY
19284: PPUSH
19285: LD_VAR 0 3
19289: PPUSH
19290: CALL_OW 1
19294: ST_TO_ADDR
19295: GO 19559
// begin tmp := arr ;
19297: LD_ADDR_VAR 0 6
19301: PUSH
19302: LD_VAR 0 1
19306: ST_TO_ADDR
// s_arr := [ tmp ] ;
19307: LD_ADDR_VAR 0 7
19311: PUSH
19312: LD_VAR 0 6
19316: PUSH
19317: EMPTY
19318: LIST
19319: ST_TO_ADDR
// for i = 1 to pos - 1 do
19320: LD_ADDR_VAR 0 5
19324: PUSH
19325: DOUBLE
19326: LD_INT 1
19328: DEC
19329: ST_TO_ADDR
19330: LD_VAR 0 2
19334: PUSH
19335: LD_INT 1
19337: MINUS
19338: PUSH
19339: FOR_TO
19340: IFFALSE 19385
// begin tmp := tmp [ pos [ i ] ] ;
19342: LD_ADDR_VAR 0 6
19346: PUSH
19347: LD_VAR 0 6
19351: PUSH
19352: LD_VAR 0 2
19356: PUSH
19357: LD_VAR 0 5
19361: ARRAY
19362: ARRAY
19363: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19364: LD_ADDR_VAR 0 7
19368: PUSH
19369: LD_VAR 0 7
19373: PUSH
19374: LD_VAR 0 6
19378: PUSH
19379: EMPTY
19380: LIST
19381: ADD
19382: ST_TO_ADDR
// end ;
19383: GO 19339
19385: POP
19386: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19387: LD_ADDR_VAR 0 6
19391: PUSH
19392: LD_VAR 0 6
19396: PPUSH
19397: LD_VAR 0 2
19401: PUSH
19402: LD_VAR 0 2
19406: ARRAY
19407: PPUSH
19408: LD_VAR 0 3
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19418: LD_ADDR_VAR 0 7
19422: PUSH
19423: LD_VAR 0 7
19427: PPUSH
19428: LD_VAR 0 7
19432: PPUSH
19433: LD_VAR 0 6
19437: PPUSH
19438: CALL_OW 1
19442: ST_TO_ADDR
// for i = s_arr downto 2 do
19443: LD_ADDR_VAR 0 5
19447: PUSH
19448: DOUBLE
19449: LD_VAR 0 7
19453: INC
19454: ST_TO_ADDR
19455: LD_INT 2
19457: PUSH
19458: FOR_DOWNTO
19459: IFFALSE 19543
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19461: LD_ADDR_VAR 0 6
19465: PUSH
19466: LD_VAR 0 7
19470: PUSH
19471: LD_VAR 0 5
19475: PUSH
19476: LD_INT 1
19478: MINUS
19479: ARRAY
19480: PPUSH
19481: LD_VAR 0 2
19485: PUSH
19486: LD_VAR 0 5
19490: PUSH
19491: LD_INT 1
19493: MINUS
19494: ARRAY
19495: PPUSH
19496: LD_VAR 0 7
19500: PUSH
19501: LD_VAR 0 5
19505: ARRAY
19506: PPUSH
19507: CALL_OW 1
19511: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19512: LD_ADDR_VAR 0 7
19516: PUSH
19517: LD_VAR 0 7
19521: PPUSH
19522: LD_VAR 0 5
19526: PUSH
19527: LD_INT 1
19529: MINUS
19530: PPUSH
19531: LD_VAR 0 6
19535: PPUSH
19536: CALL_OW 1
19540: ST_TO_ADDR
// end ;
19541: GO 19458
19543: POP
19544: POP
// result := s_arr [ 1 ] ;
19545: LD_ADDR_VAR 0 4
19549: PUSH
19550: LD_VAR 0 7
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: ST_TO_ADDR
// end ; end ;
19559: LD_VAR 0 4
19563: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19564: LD_INT 0
19566: PPUSH
19567: PPUSH
// if not list then
19568: LD_VAR 0 1
19572: NOT
19573: IFFALSE 19577
// exit ;
19575: GO 19668
// i := list [ pos1 ] ;
19577: LD_ADDR_VAR 0 5
19581: PUSH
19582: LD_VAR 0 1
19586: PUSH
19587: LD_VAR 0 2
19591: ARRAY
19592: ST_TO_ADDR
// if not i then
19593: LD_VAR 0 5
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19668
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19602: LD_ADDR_VAR 0 1
19606: PUSH
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_VAR 0 2
19616: PPUSH
19617: LD_VAR 0 1
19621: PUSH
19622: LD_VAR 0 3
19626: ARRAY
19627: PPUSH
19628: CALL_OW 1
19632: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19633: LD_ADDR_VAR 0 1
19637: PUSH
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_VAR 0 3
19647: PPUSH
19648: LD_VAR 0 5
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// result := list ;
19658: LD_ADDR_VAR 0 4
19662: PUSH
19663: LD_VAR 0 1
19667: ST_TO_ADDR
// end ;
19668: LD_VAR 0 4
19672: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19673: LD_INT 0
19675: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19676: LD_ADDR_VAR 0 5
19680: PUSH
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 250
19690: PPUSH
19691: LD_VAR 0 1
19695: PPUSH
19696: CALL_OW 251
19700: PPUSH
19701: LD_VAR 0 2
19705: PPUSH
19706: LD_VAR 0 3
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: CALL 19726 0 5
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 5
19725: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// if not list then
19732: LD_VAR 0 3
19736: NOT
19737: IFFALSE 19741
// exit ;
19739: GO 20129
// result := [ ] ;
19741: LD_ADDR_VAR 0 6
19745: PUSH
19746: EMPTY
19747: ST_TO_ADDR
// for i in list do
19748: LD_ADDR_VAR 0 7
19752: PUSH
19753: LD_VAR 0 3
19757: PUSH
19758: FOR_IN
19759: IFFALSE 19961
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19761: LD_ADDR_VAR 0 9
19765: PUSH
19766: LD_VAR 0 7
19770: PPUSH
19771: LD_VAR 0 1
19775: PPUSH
19776: LD_VAR 0 2
19780: PPUSH
19781: CALL_OW 297
19785: ST_TO_ADDR
// if not result then
19786: LD_VAR 0 6
19790: NOT
19791: IFFALSE 19817
// result := [ [ i , tmp ] ] else
19793: LD_ADDR_VAR 0 6
19797: PUSH
19798: LD_VAR 0 7
19802: PUSH
19803: LD_VAR 0 9
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: ST_TO_ADDR
19815: GO 19959
// begin if result [ result ] [ 2 ] < tmp then
19817: LD_VAR 0 6
19821: PUSH
19822: LD_VAR 0 6
19826: ARRAY
19827: PUSH
19828: LD_INT 2
19830: ARRAY
19831: PUSH
19832: LD_VAR 0 9
19836: LESS
19837: IFFALSE 19879
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19839: LD_ADDR_VAR 0 6
19843: PUSH
19844: LD_VAR 0 6
19848: PPUSH
19849: LD_VAR 0 6
19853: PUSH
19854: LD_INT 1
19856: PLUS
19857: PPUSH
19858: LD_VAR 0 7
19862: PUSH
19863: LD_VAR 0 9
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PPUSH
19872: CALL_OW 2
19876: ST_TO_ADDR
19877: GO 19959
// for j = 1 to result do
19879: LD_ADDR_VAR 0 8
19883: PUSH
19884: DOUBLE
19885: LD_INT 1
19887: DEC
19888: ST_TO_ADDR
19889: LD_VAR 0 6
19893: PUSH
19894: FOR_TO
19895: IFFALSE 19957
// begin if tmp < result [ j ] [ 2 ] then
19897: LD_VAR 0 9
19901: PUSH
19902: LD_VAR 0 6
19906: PUSH
19907: LD_VAR 0 8
19911: ARRAY
19912: PUSH
19913: LD_INT 2
19915: ARRAY
19916: LESS
19917: IFFALSE 19955
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19919: LD_ADDR_VAR 0 6
19923: PUSH
19924: LD_VAR 0 6
19928: PPUSH
19929: LD_VAR 0 8
19933: PPUSH
19934: LD_VAR 0 7
19938: PUSH
19939: LD_VAR 0 9
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: PPUSH
19948: CALL_OW 2
19952: ST_TO_ADDR
// break ;
19953: GO 19957
// end ; end ;
19955: GO 19894
19957: POP
19958: POP
// end ; end ;
19959: GO 19758
19961: POP
19962: POP
// if result and not asc then
19963: LD_VAR 0 6
19967: PUSH
19968: LD_VAR 0 4
19972: NOT
19973: AND
19974: IFFALSE 20049
// begin tmp := result ;
19976: LD_ADDR_VAR 0 9
19980: PUSH
19981: LD_VAR 0 6
19985: ST_TO_ADDR
// for i = tmp downto 1 do
19986: LD_ADDR_VAR 0 7
19990: PUSH
19991: DOUBLE
19992: LD_VAR 0 9
19996: INC
19997: ST_TO_ADDR
19998: LD_INT 1
20000: PUSH
20001: FOR_DOWNTO
20002: IFFALSE 20047
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20004: LD_ADDR_VAR 0 6
20008: PUSH
20009: LD_VAR 0 6
20013: PPUSH
20014: LD_VAR 0 9
20018: PUSH
20019: LD_VAR 0 7
20023: MINUS
20024: PUSH
20025: LD_INT 1
20027: PLUS
20028: PPUSH
20029: LD_VAR 0 9
20033: PUSH
20034: LD_VAR 0 7
20038: ARRAY
20039: PPUSH
20040: CALL_OW 1
20044: ST_TO_ADDR
20045: GO 20001
20047: POP
20048: POP
// end ; tmp := [ ] ;
20049: LD_ADDR_VAR 0 9
20053: PUSH
20054: EMPTY
20055: ST_TO_ADDR
// if mode then
20056: LD_VAR 0 5
20060: IFFALSE 20129
// begin for i = 1 to result do
20062: LD_ADDR_VAR 0 7
20066: PUSH
20067: DOUBLE
20068: LD_INT 1
20070: DEC
20071: ST_TO_ADDR
20072: LD_VAR 0 6
20076: PUSH
20077: FOR_TO
20078: IFFALSE 20117
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20080: LD_ADDR_VAR 0 9
20084: PUSH
20085: LD_VAR 0 9
20089: PPUSH
20090: LD_VAR 0 7
20094: PPUSH
20095: LD_VAR 0 6
20099: PUSH
20100: LD_VAR 0 7
20104: ARRAY
20105: PUSH
20106: LD_INT 1
20108: ARRAY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
20115: GO 20077
20117: POP
20118: POP
// result := tmp ;
20119: LD_ADDR_VAR 0 6
20123: PUSH
20124: LD_VAR 0 9
20128: ST_TO_ADDR
// end ; end ;
20129: LD_VAR 0 6
20133: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20134: LD_INT 0
20136: PPUSH
20137: PPUSH
20138: PPUSH
20139: PPUSH
20140: PPUSH
20141: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20142: LD_ADDR_VAR 0 5
20146: PUSH
20147: LD_INT 0
20149: PUSH
20150: LD_INT 0
20152: PUSH
20153: LD_INT 0
20155: PUSH
20156: EMPTY
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// if not x or not y then
20164: LD_VAR 0 2
20168: NOT
20169: PUSH
20170: LD_VAR 0 3
20174: NOT
20175: OR
20176: IFFALSE 20180
// exit ;
20178: GO 21826
// if not range then
20180: LD_VAR 0 4
20184: NOT
20185: IFFALSE 20195
// range := 10 ;
20187: LD_ADDR_VAR 0 4
20191: PUSH
20192: LD_INT 10
20194: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_INT 81
20202: PUSH
20203: LD_VAR 0 1
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 92
20214: PUSH
20215: LD_VAR 0 2
20219: PUSH
20220: LD_VAR 0 3
20224: PUSH
20225: LD_VAR 0 4
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: LIST
20234: LIST
20235: PUSH
20236: LD_INT 3
20238: PUSH
20239: LD_INT 21
20241: PUSH
20242: LD_INT 3
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PPUSH
20258: CALL_OW 69
20262: ST_TO_ADDR
// if not tmp then
20263: LD_VAR 0 8
20267: NOT
20268: IFFALSE 20272
// exit ;
20270: GO 21826
// for i in tmp do
20272: LD_ADDR_VAR 0 6
20276: PUSH
20277: LD_VAR 0 8
20281: PUSH
20282: FOR_IN
20283: IFFALSE 21801
// begin points := [ 0 , 0 , 0 ] ;
20285: LD_ADDR_VAR 0 9
20289: PUSH
20290: LD_INT 0
20292: PUSH
20293: LD_INT 0
20295: PUSH
20296: LD_INT 0
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: LIST
20303: ST_TO_ADDR
// bpoints := 1 ;
20304: LD_ADDR_VAR 0 10
20308: PUSH
20309: LD_INT 1
20311: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 247
20321: PUSH
20322: LD_INT 1
20324: DOUBLE
20325: EQUAL
20326: IFTRUE 20330
20328: GO 20908
20330: POP
// begin if GetClass ( i ) = 1 then
20331: LD_VAR 0 6
20335: PPUSH
20336: CALL_OW 257
20340: PUSH
20341: LD_INT 1
20343: EQUAL
20344: IFFALSE 20365
// points := [ 10 , 5 , 3 ] ;
20346: LD_ADDR_VAR 0 9
20350: PUSH
20351: LD_INT 10
20353: PUSH
20354: LD_INT 5
20356: PUSH
20357: LD_INT 3
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20365: LD_VAR 0 6
20369: PPUSH
20370: CALL_OW 257
20374: PUSH
20375: LD_INT 2
20377: PUSH
20378: LD_INT 3
20380: PUSH
20381: LD_INT 4
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: IN
20389: IFFALSE 20410
// points := [ 3 , 2 , 1 ] ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 3
20398: PUSH
20399: LD_INT 2
20401: PUSH
20402: LD_INT 1
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: LIST
20409: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20410: LD_VAR 0 6
20414: PPUSH
20415: CALL_OW 257
20419: PUSH
20420: LD_INT 5
20422: EQUAL
20423: IFFALSE 20444
// points := [ 130 , 5 , 2 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 130
20432: PUSH
20433: LD_INT 5
20435: PUSH
20436: LD_INT 2
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 257
20453: PUSH
20454: LD_INT 8
20456: EQUAL
20457: IFFALSE 20478
// points := [ 35 , 35 , 30 ] ;
20459: LD_ADDR_VAR 0 9
20463: PUSH
20464: LD_INT 35
20466: PUSH
20467: LD_INT 35
20469: PUSH
20470: LD_INT 30
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: LIST
20477: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20478: LD_VAR 0 6
20482: PPUSH
20483: CALL_OW 257
20487: PUSH
20488: LD_INT 9
20490: EQUAL
20491: IFFALSE 20512
// points := [ 20 , 55 , 40 ] ;
20493: LD_ADDR_VAR 0 9
20497: PUSH
20498: LD_INT 20
20500: PUSH
20501: LD_INT 55
20503: PUSH
20504: LD_INT 40
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: LIST
20511: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20512: LD_VAR 0 6
20516: PPUSH
20517: CALL_OW 257
20521: PUSH
20522: LD_INT 12
20524: PUSH
20525: LD_INT 16
20527: PUSH
20528: EMPTY
20529: LIST
20530: LIST
20531: IN
20532: IFFALSE 20553
// points := [ 5 , 3 , 2 ] ;
20534: LD_ADDR_VAR 0 9
20538: PUSH
20539: LD_INT 5
20541: PUSH
20542: LD_INT 3
20544: PUSH
20545: LD_INT 2
20547: PUSH
20548: EMPTY
20549: LIST
20550: LIST
20551: LIST
20552: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20553: LD_VAR 0 6
20557: PPUSH
20558: CALL_OW 257
20562: PUSH
20563: LD_INT 17
20565: EQUAL
20566: IFFALSE 20587
// points := [ 100 , 50 , 75 ] ;
20568: LD_ADDR_VAR 0 9
20572: PUSH
20573: LD_INT 100
20575: PUSH
20576: LD_INT 50
20578: PUSH
20579: LD_INT 75
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: LIST
20586: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20587: LD_VAR 0 6
20591: PPUSH
20592: CALL_OW 257
20596: PUSH
20597: LD_INT 15
20599: EQUAL
20600: IFFALSE 20621
// points := [ 10 , 5 , 3 ] ;
20602: LD_ADDR_VAR 0 9
20606: PUSH
20607: LD_INT 10
20609: PUSH
20610: LD_INT 5
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: LIST
20620: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20621: LD_VAR 0 6
20625: PPUSH
20626: CALL_OW 257
20630: PUSH
20631: LD_INT 14
20633: EQUAL
20634: IFFALSE 20655
// points := [ 10 , 0 , 0 ] ;
20636: LD_ADDR_VAR 0 9
20640: PUSH
20641: LD_INT 10
20643: PUSH
20644: LD_INT 0
20646: PUSH
20647: LD_INT 0
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: LIST
20654: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20655: LD_VAR 0 6
20659: PPUSH
20660: CALL_OW 257
20664: PUSH
20665: LD_INT 11
20667: EQUAL
20668: IFFALSE 20689
// points := [ 30 , 10 , 5 ] ;
20670: LD_ADDR_VAR 0 9
20674: PUSH
20675: LD_INT 30
20677: PUSH
20678: LD_INT 10
20680: PUSH
20681: LD_INT 5
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20689: LD_VAR 0 1
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: CALL_OW 321
20701: PUSH
20702: LD_INT 2
20704: EQUAL
20705: IFFALSE 20722
// bpoints := bpoints * 1.8 ;
20707: LD_ADDR_VAR 0 10
20711: PUSH
20712: LD_VAR 0 10
20716: PUSH
20717: LD_REAL  1.80000000000000E+0000
20720: MUL
20721: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20722: LD_VAR 0 6
20726: PPUSH
20727: CALL_OW 257
20731: PUSH
20732: LD_INT 1
20734: PUSH
20735: LD_INT 2
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: LD_INT 4
20743: PUSH
20744: EMPTY
20745: LIST
20746: LIST
20747: LIST
20748: LIST
20749: IN
20750: PUSH
20751: LD_VAR 0 1
20755: PPUSH
20756: LD_INT 51
20758: PPUSH
20759: CALL_OW 321
20763: PUSH
20764: LD_INT 2
20766: EQUAL
20767: AND
20768: IFFALSE 20785
// bpoints := bpoints * 1.2 ;
20770: LD_ADDR_VAR 0 10
20774: PUSH
20775: LD_VAR 0 10
20779: PUSH
20780: LD_REAL  1.20000000000000E+0000
20783: MUL
20784: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20785: LD_VAR 0 6
20789: PPUSH
20790: CALL_OW 257
20794: PUSH
20795: LD_INT 5
20797: PUSH
20798: LD_INT 7
20800: PUSH
20801: LD_INT 9
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: IN
20809: PUSH
20810: LD_VAR 0 1
20814: PPUSH
20815: LD_INT 52
20817: PPUSH
20818: CALL_OW 321
20822: PUSH
20823: LD_INT 2
20825: EQUAL
20826: AND
20827: IFFALSE 20844
// bpoints := bpoints * 1.5 ;
20829: LD_ADDR_VAR 0 10
20833: PUSH
20834: LD_VAR 0 10
20838: PUSH
20839: LD_REAL  1.50000000000000E+0000
20842: MUL
20843: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20844: LD_VAR 0 1
20848: PPUSH
20849: LD_INT 66
20851: PPUSH
20852: CALL_OW 321
20856: PUSH
20857: LD_INT 2
20859: EQUAL
20860: IFFALSE 20877
// bpoints := bpoints * 1.1 ;
20862: LD_ADDR_VAR 0 10
20866: PUSH
20867: LD_VAR 0 10
20871: PUSH
20872: LD_REAL  1.10000000000000E+0000
20875: MUL
20876: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20877: LD_ADDR_VAR 0 10
20881: PUSH
20882: LD_VAR 0 10
20886: PUSH
20887: LD_VAR 0 6
20891: PPUSH
20892: LD_INT 1
20894: PPUSH
20895: CALL_OW 259
20899: PUSH
20900: LD_REAL  1.15000000000000E+0000
20903: MUL
20904: MUL
20905: ST_TO_ADDR
// end ; unit_vehicle :
20906: GO 21730
20908: LD_INT 2
20910: DOUBLE
20911: EQUAL
20912: IFTRUE 20916
20914: GO 21718
20916: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20917: LD_VAR 0 6
20921: PPUSH
20922: CALL_OW 264
20926: PUSH
20927: LD_INT 2
20929: PUSH
20930: LD_INT 42
20932: PUSH
20933: LD_INT 24
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: IN
20941: IFFALSE 20962
// points := [ 25 , 5 , 3 ] ;
20943: LD_ADDR_VAR 0 9
20947: PUSH
20948: LD_INT 25
20950: PUSH
20951: LD_INT 5
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: EMPTY
20958: LIST
20959: LIST
20960: LIST
20961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20962: LD_VAR 0 6
20966: PPUSH
20967: CALL_OW 264
20971: PUSH
20972: LD_INT 4
20974: PUSH
20975: LD_INT 43
20977: PUSH
20978: LD_INT 25
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: LIST
20985: IN
20986: IFFALSE 21007
// points := [ 40 , 15 , 5 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 40
20995: PUSH
20996: LD_INT 15
20998: PUSH
20999: LD_INT 5
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 264
21016: PUSH
21017: LD_INT 3
21019: PUSH
21020: LD_INT 23
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: IN
21027: IFFALSE 21048
// points := [ 7 , 25 , 8 ] ;
21029: LD_ADDR_VAR 0 9
21033: PUSH
21034: LD_INT 7
21036: PUSH
21037: LD_INT 25
21039: PUSH
21040: LD_INT 8
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21048: LD_VAR 0 6
21052: PPUSH
21053: CALL_OW 264
21057: PUSH
21058: LD_INT 5
21060: PUSH
21061: LD_INT 27
21063: PUSH
21064: LD_INT 44
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: LIST
21071: IN
21072: IFFALSE 21093
// points := [ 14 , 50 , 16 ] ;
21074: LD_ADDR_VAR 0 9
21078: PUSH
21079: LD_INT 14
21081: PUSH
21082: LD_INT 50
21084: PUSH
21085: LD_INT 16
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: LIST
21092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21093: LD_VAR 0 6
21097: PPUSH
21098: CALL_OW 264
21102: PUSH
21103: LD_INT 6
21105: PUSH
21106: LD_INT 46
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: IN
21113: IFFALSE 21134
// points := [ 32 , 120 , 70 ] ;
21115: LD_ADDR_VAR 0 9
21119: PUSH
21120: LD_INT 32
21122: PUSH
21123: LD_INT 120
21125: PUSH
21126: LD_INT 70
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: LIST
21133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21134: LD_VAR 0 6
21138: PPUSH
21139: CALL_OW 264
21143: PUSH
21144: LD_INT 7
21146: PUSH
21147: LD_INT 28
21149: PUSH
21150: LD_INT 45
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: LIST
21157: IN
21158: IFFALSE 21179
// points := [ 35 , 20 , 45 ] ;
21160: LD_ADDR_VAR 0 9
21164: PUSH
21165: LD_INT 35
21167: PUSH
21168: LD_INT 20
21170: PUSH
21171: LD_INT 45
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21179: LD_VAR 0 6
21183: PPUSH
21184: CALL_OW 264
21188: PUSH
21189: LD_INT 47
21191: PUSH
21192: EMPTY
21193: LIST
21194: IN
21195: IFFALSE 21216
// points := [ 67 , 45 , 75 ] ;
21197: LD_ADDR_VAR 0 9
21201: PUSH
21202: LD_INT 67
21204: PUSH
21205: LD_INT 45
21207: PUSH
21208: LD_INT 75
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: LIST
21215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21216: LD_VAR 0 6
21220: PPUSH
21221: CALL_OW 264
21225: PUSH
21226: LD_INT 26
21228: PUSH
21229: EMPTY
21230: LIST
21231: IN
21232: IFFALSE 21253
// points := [ 120 , 30 , 80 ] ;
21234: LD_ADDR_VAR 0 9
21238: PUSH
21239: LD_INT 120
21241: PUSH
21242: LD_INT 30
21244: PUSH
21245: LD_INT 80
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: LIST
21252: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21253: LD_VAR 0 6
21257: PPUSH
21258: CALL_OW 264
21262: PUSH
21263: LD_INT 22
21265: PUSH
21266: EMPTY
21267: LIST
21268: IN
21269: IFFALSE 21290
// points := [ 40 , 1 , 1 ] ;
21271: LD_ADDR_VAR 0 9
21275: PUSH
21276: LD_INT 40
21278: PUSH
21279: LD_INT 1
21281: PUSH
21282: LD_INT 1
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21290: LD_VAR 0 6
21294: PPUSH
21295: CALL_OW 264
21299: PUSH
21300: LD_INT 29
21302: PUSH
21303: EMPTY
21304: LIST
21305: IN
21306: IFFALSE 21327
// points := [ 70 , 200 , 400 ] ;
21308: LD_ADDR_VAR 0 9
21312: PUSH
21313: LD_INT 70
21315: PUSH
21316: LD_INT 200
21318: PUSH
21319: LD_INT 400
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: LIST
21326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21327: LD_VAR 0 6
21331: PPUSH
21332: CALL_OW 264
21336: PUSH
21337: LD_INT 14
21339: PUSH
21340: LD_INT 53
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: IN
21347: IFFALSE 21368
// points := [ 40 , 10 , 20 ] ;
21349: LD_ADDR_VAR 0 9
21353: PUSH
21354: LD_INT 40
21356: PUSH
21357: LD_INT 10
21359: PUSH
21360: LD_INT 20
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: LIST
21367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21368: LD_VAR 0 6
21372: PPUSH
21373: CALL_OW 264
21377: PUSH
21378: LD_INT 9
21380: PUSH
21381: EMPTY
21382: LIST
21383: IN
21384: IFFALSE 21405
// points := [ 5 , 70 , 20 ] ;
21386: LD_ADDR_VAR 0 9
21390: PUSH
21391: LD_INT 5
21393: PUSH
21394: LD_INT 70
21396: PUSH
21397: LD_INT 20
21399: PUSH
21400: EMPTY
21401: LIST
21402: LIST
21403: LIST
21404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21405: LD_VAR 0 6
21409: PPUSH
21410: CALL_OW 264
21414: PUSH
21415: LD_INT 10
21417: PUSH
21418: EMPTY
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 35 , 110 , 70 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 35
21430: PUSH
21431: LD_INT 110
21433: PUSH
21434: LD_INT 70
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 265
21451: PUSH
21452: LD_INT 25
21454: EQUAL
21455: IFFALSE 21476
// points := [ 80 , 65 , 100 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 80
21464: PUSH
21465: LD_INT 65
21467: PUSH
21468: LD_INT 100
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 263
21485: PUSH
21486: LD_INT 1
21488: EQUAL
21489: IFFALSE 21524
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21491: LD_ADDR_VAR 0 10
21495: PUSH
21496: LD_VAR 0 10
21500: PUSH
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 311
21510: PPUSH
21511: LD_INT 3
21513: PPUSH
21514: CALL_OW 259
21518: PUSH
21519: LD_INT 4
21521: MUL
21522: MUL
21523: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21524: LD_VAR 0 6
21528: PPUSH
21529: CALL_OW 263
21533: PUSH
21534: LD_INT 2
21536: EQUAL
21537: IFFALSE 21588
// begin j := IsControledBy ( i ) ;
21539: LD_ADDR_VAR 0 7
21543: PUSH
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 312
21553: ST_TO_ADDR
// if j then
21554: LD_VAR 0 7
21558: IFFALSE 21588
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21560: LD_ADDR_VAR 0 10
21564: PUSH
21565: LD_VAR 0 10
21569: PUSH
21570: LD_VAR 0 7
21574: PPUSH
21575: LD_INT 3
21577: PPUSH
21578: CALL_OW 259
21582: PUSH
21583: LD_INT 3
21585: MUL
21586: MUL
21587: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21588: LD_VAR 0 6
21592: PPUSH
21593: CALL_OW 264
21597: PUSH
21598: LD_INT 5
21600: PUSH
21601: LD_INT 6
21603: PUSH
21604: LD_INT 46
21606: PUSH
21607: LD_INT 44
21609: PUSH
21610: LD_INT 47
21612: PUSH
21613: LD_INT 45
21615: PUSH
21616: LD_INT 28
21618: PUSH
21619: LD_INT 7
21621: PUSH
21622: LD_INT 27
21624: PUSH
21625: LD_INT 29
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: LIST
21637: LIST
21638: LIST
21639: IN
21640: PUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 52
21648: PPUSH
21649: CALL_OW 321
21653: PUSH
21654: LD_INT 2
21656: EQUAL
21657: AND
21658: IFFALSE 21675
// bpoints := bpoints * 1.2 ;
21660: LD_ADDR_VAR 0 10
21664: PUSH
21665: LD_VAR 0 10
21669: PUSH
21670: LD_REAL  1.20000000000000E+0000
21673: MUL
21674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21675: LD_VAR 0 6
21679: PPUSH
21680: CALL_OW 264
21684: PUSH
21685: LD_INT 6
21687: PUSH
21688: LD_INT 46
21690: PUSH
21691: LD_INT 47
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: LIST
21698: IN
21699: IFFALSE 21716
// bpoints := bpoints * 1.2 ;
21701: LD_ADDR_VAR 0 10
21705: PUSH
21706: LD_VAR 0 10
21710: PUSH
21711: LD_REAL  1.20000000000000E+0000
21714: MUL
21715: ST_TO_ADDR
// end ; unit_building :
21716: GO 21730
21718: LD_INT 3
21720: DOUBLE
21721: EQUAL
21722: IFTRUE 21726
21724: GO 21729
21726: POP
// ; end ;
21727: GO 21730
21729: POP
// for j = 1 to 3 do
21730: LD_ADDR_VAR 0 7
21734: PUSH
21735: DOUBLE
21736: LD_INT 1
21738: DEC
21739: ST_TO_ADDR
21740: LD_INT 3
21742: PUSH
21743: FOR_TO
21744: IFFALSE 21797
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21746: LD_ADDR_VAR 0 5
21750: PUSH
21751: LD_VAR 0 5
21755: PPUSH
21756: LD_VAR 0 7
21760: PPUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 7
21770: ARRAY
21771: PUSH
21772: LD_VAR 0 9
21776: PUSH
21777: LD_VAR 0 7
21781: ARRAY
21782: PUSH
21783: LD_VAR 0 10
21787: MUL
21788: PLUS
21789: PPUSH
21790: CALL_OW 1
21794: ST_TO_ADDR
21795: GO 21743
21797: POP
21798: POP
// end ;
21799: GO 20282
21801: POP
21802: POP
// result := Replace ( result , 4 , tmp ) ;
21803: LD_ADDR_VAR 0 5
21807: PUSH
21808: LD_VAR 0 5
21812: PPUSH
21813: LD_INT 4
21815: PPUSH
21816: LD_VAR 0 8
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// end ;
21826: LD_VAR 0 5
21830: RET
// export function DangerAtRange ( unit , range ) ; begin
21831: LD_INT 0
21833: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21834: LD_ADDR_VAR 0 3
21838: PUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: CALL_OW 255
21848: PPUSH
21849: LD_VAR 0 1
21853: PPUSH
21854: CALL_OW 250
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: CALL_OW 251
21868: PPUSH
21869: LD_VAR 0 2
21873: PPUSH
21874: CALL 20134 0 4
21878: ST_TO_ADDR
// end ;
21879: LD_VAR 0 3
21883: RET
// export function DangerInArea ( side , area ) ; begin
21884: LD_INT 0
21886: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21887: LD_ADDR_VAR 0 3
21891: PUSH
21892: LD_VAR 0 2
21896: PPUSH
21897: LD_INT 81
21899: PUSH
21900: LD_VAR 0 1
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: PPUSH
21909: CALL_OW 70
21913: ST_TO_ADDR
// end ;
21914: LD_VAR 0 3
21918: RET
// export function IsExtension ( b ) ; begin
21919: LD_INT 0
21921: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21922: LD_ADDR_VAR 0 2
21926: PUSH
21927: LD_VAR 0 1
21931: PUSH
21932: LD_INT 23
21934: PUSH
21935: LD_INT 20
21937: PUSH
21938: LD_INT 22
21940: PUSH
21941: LD_INT 17
21943: PUSH
21944: LD_INT 24
21946: PUSH
21947: LD_INT 21
21949: PUSH
21950: LD_INT 19
21952: PUSH
21953: LD_INT 16
21955: PUSH
21956: LD_INT 25
21958: PUSH
21959: LD_INT 18
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: IN
21974: ST_TO_ADDR
// end ;
21975: LD_VAR 0 2
21979: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21980: LD_INT 0
21982: PPUSH
21983: PPUSH
21984: PPUSH
// result := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21992: LD_ADDR_VAR 0 4
21996: PUSH
21997: LD_VAR 0 2
22001: PPUSH
22002: LD_INT 21
22004: PUSH
22005: LD_INT 3
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PPUSH
22012: CALL_OW 70
22016: ST_TO_ADDR
// if not tmp then
22017: LD_VAR 0 4
22021: NOT
22022: IFFALSE 22026
// exit ;
22024: GO 22084
// for i in tmp do
22026: LD_ADDR_VAR 0 5
22030: PUSH
22031: LD_VAR 0 4
22035: PUSH
22036: FOR_IN
22037: IFFALSE 22072
// if GetBase ( i ) <> base then
22039: LD_VAR 0 5
22043: PPUSH
22044: CALL_OW 274
22048: PUSH
22049: LD_VAR 0 1
22053: NONEQUAL
22054: IFFALSE 22070
// ComLinkToBase ( base , i ) ;
22056: LD_VAR 0 1
22060: PPUSH
22061: LD_VAR 0 5
22065: PPUSH
22066: CALL_OW 169
22070: GO 22036
22072: POP
22073: POP
// result := tmp ;
22074: LD_ADDR_VAR 0 3
22078: PUSH
22079: LD_VAR 0 4
22083: ST_TO_ADDR
// end ;
22084: LD_VAR 0 3
22088: RET
// export function ComComplete ( unit , b ) ; var i ; begin
22089: LD_INT 0
22091: PPUSH
22092: PPUSH
// if BuildingStatus ( b ) = bs_build then
22093: LD_VAR 0 2
22097: PPUSH
22098: CALL_OW 461
22102: PUSH
22103: LD_INT 1
22105: EQUAL
22106: IFFALSE 22166
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22108: LD_VAR 0 1
22112: PPUSH
22113: LD_STRING h
22115: PUSH
22116: LD_VAR 0 2
22120: PPUSH
22121: CALL_OW 250
22125: PUSH
22126: LD_VAR 0 2
22130: PPUSH
22131: CALL_OW 251
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 0
22143: PUSH
22144: LD_INT 0
22146: PUSH
22147: LD_INT 0
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: LIST
22157: LIST
22158: PUSH
22159: EMPTY
22160: LIST
22161: PPUSH
22162: CALL_OW 446
// end ;
22166: LD_VAR 0 3
22170: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22171: LD_INT 0
22173: PPUSH
22174: PPUSH
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22179: LD_VAR 0 1
22183: NOT
22184: PUSH
22185: LD_VAR 0 1
22189: PPUSH
22190: CALL_OW 263
22194: PUSH
22195: LD_INT 2
22197: EQUAL
22198: NOT
22199: OR
22200: IFFALSE 22204
// exit ;
22202: GO 22520
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22204: LD_ADDR_VAR 0 6
22208: PUSH
22209: LD_INT 22
22211: PUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: CALL_OW 255
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 2
22228: PUSH
22229: LD_INT 30
22231: PUSH
22232: LD_INT 36
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PUSH
22239: LD_INT 34
22241: PUSH
22242: LD_INT 31
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: EMPTY
22250: LIST
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PPUSH
22258: CALL_OW 69
22262: ST_TO_ADDR
// if not tmp then
22263: LD_VAR 0 6
22267: NOT
22268: IFFALSE 22272
// exit ;
22270: GO 22520
// result := [ ] ;
22272: LD_ADDR_VAR 0 2
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// for i in tmp do
22279: LD_ADDR_VAR 0 3
22283: PUSH
22284: LD_VAR 0 6
22288: PUSH
22289: FOR_IN
22290: IFFALSE 22361
// begin t := UnitsInside ( i ) ;
22292: LD_ADDR_VAR 0 4
22296: PUSH
22297: LD_VAR 0 3
22301: PPUSH
22302: CALL_OW 313
22306: ST_TO_ADDR
// if t then
22307: LD_VAR 0 4
22311: IFFALSE 22359
// for j in t do
22313: LD_ADDR_VAR 0 7
22317: PUSH
22318: LD_VAR 0 4
22322: PUSH
22323: FOR_IN
22324: IFFALSE 22357
// result := Insert ( result , result + 1 , j ) ;
22326: LD_ADDR_VAR 0 2
22330: PUSH
22331: LD_VAR 0 2
22335: PPUSH
22336: LD_VAR 0 2
22340: PUSH
22341: LD_INT 1
22343: PLUS
22344: PPUSH
22345: LD_VAR 0 7
22349: PPUSH
22350: CALL_OW 2
22354: ST_TO_ADDR
22355: GO 22323
22357: POP
22358: POP
// end ;
22359: GO 22289
22361: POP
22362: POP
// if not result then
22363: LD_VAR 0 2
22367: NOT
22368: IFFALSE 22372
// exit ;
22370: GO 22520
// mech := result [ 1 ] ;
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 2
22381: PUSH
22382: LD_INT 1
22384: ARRAY
22385: ST_TO_ADDR
// if result > 1 then
22386: LD_VAR 0 2
22390: PUSH
22391: LD_INT 1
22393: GREATER
22394: IFFALSE 22506
// for i = 2 to result do
22396: LD_ADDR_VAR 0 3
22400: PUSH
22401: DOUBLE
22402: LD_INT 2
22404: DEC
22405: ST_TO_ADDR
22406: LD_VAR 0 2
22410: PUSH
22411: FOR_TO
22412: IFFALSE 22504
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22414: LD_ADDR_VAR 0 4
22418: PUSH
22419: LD_VAR 0 2
22423: PUSH
22424: LD_VAR 0 3
22428: ARRAY
22429: PPUSH
22430: LD_INT 3
22432: PPUSH
22433: CALL_OW 259
22437: PUSH
22438: LD_VAR 0 2
22442: PUSH
22443: LD_VAR 0 3
22447: ARRAY
22448: PPUSH
22449: CALL_OW 432
22453: MINUS
22454: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22455: LD_VAR 0 4
22459: PUSH
22460: LD_VAR 0 5
22464: PPUSH
22465: LD_INT 3
22467: PPUSH
22468: CALL_OW 259
22472: PUSH
22473: LD_VAR 0 5
22477: PPUSH
22478: CALL_OW 432
22482: MINUS
22483: GREATEREQUAL
22484: IFFALSE 22502
// mech := result [ i ] ;
22486: LD_ADDR_VAR 0 5
22490: PUSH
22491: LD_VAR 0 2
22495: PUSH
22496: LD_VAR 0 3
22500: ARRAY
22501: ST_TO_ADDR
// end ;
22502: GO 22411
22504: POP
22505: POP
// ComLinkTo ( vehicle , mech ) ;
22506: LD_VAR 0 1
22510: PPUSH
22511: LD_VAR 0 5
22515: PPUSH
22516: CALL_OW 135
// end ;
22520: LD_VAR 0 2
22524: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22525: LD_INT 0
22527: PPUSH
22528: PPUSH
22529: PPUSH
22530: PPUSH
22531: PPUSH
22532: PPUSH
22533: PPUSH
22534: PPUSH
22535: PPUSH
22536: PPUSH
22537: PPUSH
22538: PPUSH
22539: PPUSH
// result := [ ] ;
22540: LD_ADDR_VAR 0 7
22544: PUSH
22545: EMPTY
22546: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22547: LD_VAR 0 1
22551: PPUSH
22552: CALL_OW 266
22556: PUSH
22557: LD_INT 0
22559: PUSH
22560: LD_INT 1
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: IN
22567: NOT
22568: IFFALSE 22572
// exit ;
22570: GO 24203
// if name then
22572: LD_VAR 0 3
22576: IFFALSE 22592
// SetBName ( base_dep , name ) ;
22578: LD_VAR 0 1
22582: PPUSH
22583: LD_VAR 0 3
22587: PPUSH
22588: CALL_OW 500
// base := GetBase ( base_dep ) ;
22592: LD_ADDR_VAR 0 15
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL_OW 274
22606: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22607: LD_ADDR_VAR 0 16
22611: PUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 255
22621: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22622: LD_ADDR_VAR 0 17
22626: PUSH
22627: LD_VAR 0 1
22631: PPUSH
22632: CALL_OW 248
22636: ST_TO_ADDR
// if sources then
22637: LD_VAR 0 5
22641: IFFALSE 22688
// for i = 1 to 3 do
22643: LD_ADDR_VAR 0 8
22647: PUSH
22648: DOUBLE
22649: LD_INT 1
22651: DEC
22652: ST_TO_ADDR
22653: LD_INT 3
22655: PUSH
22656: FOR_TO
22657: IFFALSE 22686
// AddResourceType ( base , i , sources [ i ] ) ;
22659: LD_VAR 0 15
22663: PPUSH
22664: LD_VAR 0 8
22668: PPUSH
22669: LD_VAR 0 5
22673: PUSH
22674: LD_VAR 0 8
22678: ARRAY
22679: PPUSH
22680: CALL_OW 276
22684: GO 22656
22686: POP
22687: POP
// buildings := GetBaseBuildings ( base , area ) ;
22688: LD_ADDR_VAR 0 18
22692: PUSH
22693: LD_VAR 0 15
22697: PPUSH
22698: LD_VAR 0 2
22702: PPUSH
22703: CALL 21980 0 2
22707: ST_TO_ADDR
// InitHc ;
22708: CALL_OW 19
// InitUc ;
22712: CALL_OW 18
// uc_side := side ;
22716: LD_ADDR_OWVAR 20
22720: PUSH
22721: LD_VAR 0 16
22725: ST_TO_ADDR
// uc_nation := nation ;
22726: LD_ADDR_OWVAR 21
22730: PUSH
22731: LD_VAR 0 17
22735: ST_TO_ADDR
// if buildings then
22736: LD_VAR 0 18
22740: IFFALSE 24062
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 18
22751: PPUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 30
22757: PUSH
22758: LD_INT 29
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 30
22767: PUSH
22768: LD_INT 30
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: LIST
22779: PPUSH
22780: CALL_OW 72
22784: ST_TO_ADDR
// if tmp then
22785: LD_VAR 0 19
22789: IFFALSE 22837
// for i in tmp do
22791: LD_ADDR_VAR 0 8
22795: PUSH
22796: LD_VAR 0 19
22800: PUSH
22801: FOR_IN
22802: IFFALSE 22835
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22804: LD_VAR 0 8
22808: PPUSH
22809: CALL_OW 250
22813: PPUSH
22814: LD_VAR 0 8
22818: PPUSH
22819: CALL_OW 251
22823: PPUSH
22824: LD_VAR 0 16
22828: PPUSH
22829: CALL_OW 441
22833: GO 22801
22835: POP
22836: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22837: LD_VAR 0 18
22841: PPUSH
22842: LD_INT 2
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 32
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: LD_INT 30
22857: PUSH
22858: LD_INT 33
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 72
22874: IFFALSE 22962
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22876: LD_ADDR_VAR 0 8
22880: PUSH
22881: LD_VAR 0 18
22885: PPUSH
22886: LD_INT 2
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 32
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_INT 30
22901: PUSH
22902: LD_INT 33
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: EMPTY
22910: LIST
22911: LIST
22912: LIST
22913: PPUSH
22914: CALL_OW 72
22918: PUSH
22919: FOR_IN
22920: IFFALSE 22960
// begin if not GetBWeapon ( i ) then
22922: LD_VAR 0 8
22926: PPUSH
22927: CALL_OW 269
22931: NOT
22932: IFFALSE 22958
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22934: LD_VAR 0 8
22938: PPUSH
22939: LD_VAR 0 8
22943: PPUSH
22944: LD_VAR 0 2
22948: PPUSH
22949: CALL 24208 0 2
22953: PPUSH
22954: CALL_OW 431
// end ;
22958: GO 22919
22960: POP
22961: POP
// end ; for i = 1 to personel do
22962: LD_ADDR_VAR 0 8
22966: PUSH
22967: DOUBLE
22968: LD_INT 1
22970: DEC
22971: ST_TO_ADDR
22972: LD_VAR 0 6
22976: PUSH
22977: FOR_TO
22978: IFFALSE 24042
// begin if i > 4 then
22980: LD_VAR 0 8
22984: PUSH
22985: LD_INT 4
22987: GREATER
22988: IFFALSE 22992
// break ;
22990: GO 24042
// case i of 1 :
22992: LD_VAR 0 8
22996: PUSH
22997: LD_INT 1
22999: DOUBLE
23000: EQUAL
23001: IFTRUE 23005
23003: GO 23085
23005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23006: LD_ADDR_VAR 0 12
23010: PUSH
23011: LD_VAR 0 18
23015: PPUSH
23016: LD_INT 22
23018: PUSH
23019: LD_VAR 0 16
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 58
23030: PUSH
23031: EMPTY
23032: LIST
23033: PUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 32
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 30
23049: PUSH
23050: LD_INT 4
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: LD_INT 30
23059: PUSH
23060: LD_INT 5
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: LIST
23077: PPUSH
23078: CALL_OW 72
23082: ST_TO_ADDR
23083: GO 23307
23085: LD_INT 2
23087: DOUBLE
23088: EQUAL
23089: IFTRUE 23093
23091: GO 23155
23093: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23094: LD_ADDR_VAR 0 12
23098: PUSH
23099: LD_VAR 0 18
23103: PPUSH
23104: LD_INT 22
23106: PUSH
23107: LD_VAR 0 16
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PUSH
23116: LD_INT 2
23118: PUSH
23119: LD_INT 30
23121: PUSH
23122: LD_INT 0
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: LD_INT 30
23131: PUSH
23132: LD_INT 1
23134: PUSH
23135: EMPTY
23136: LIST
23137: LIST
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: LIST
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: PPUSH
23148: CALL_OW 72
23152: ST_TO_ADDR
23153: GO 23307
23155: LD_INT 3
23157: DOUBLE
23158: EQUAL
23159: IFTRUE 23163
23161: GO 23225
23163: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23164: LD_ADDR_VAR 0 12
23168: PUSH
23169: LD_VAR 0 18
23173: PPUSH
23174: LD_INT 22
23176: PUSH
23177: LD_VAR 0 16
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: LD_INT 2
23188: PUSH
23189: LD_INT 30
23191: PUSH
23192: LD_INT 2
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 30
23201: PUSH
23202: LD_INT 3
23204: PUSH
23205: EMPTY
23206: LIST
23207: LIST
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PPUSH
23218: CALL_OW 72
23222: ST_TO_ADDR
23223: GO 23307
23225: LD_INT 4
23227: DOUBLE
23228: EQUAL
23229: IFTRUE 23233
23231: GO 23306
23233: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23234: LD_ADDR_VAR 0 12
23238: PUSH
23239: LD_VAR 0 18
23243: PPUSH
23244: LD_INT 22
23246: PUSH
23247: LD_VAR 0 16
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: PUSH
23256: LD_INT 2
23258: PUSH
23259: LD_INT 30
23261: PUSH
23262: LD_INT 6
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PUSH
23269: LD_INT 30
23271: PUSH
23272: LD_INT 7
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 8
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: PPUSH
23299: CALL_OW 72
23303: ST_TO_ADDR
23304: GO 23307
23306: POP
// if i = 1 then
23307: LD_VAR 0 8
23311: PUSH
23312: LD_INT 1
23314: EQUAL
23315: IFFALSE 23426
// begin tmp := [ ] ;
23317: LD_ADDR_VAR 0 19
23321: PUSH
23322: EMPTY
23323: ST_TO_ADDR
// for j in f do
23324: LD_ADDR_VAR 0 9
23328: PUSH
23329: LD_VAR 0 12
23333: PUSH
23334: FOR_IN
23335: IFFALSE 23408
// if GetBType ( j ) = b_bunker then
23337: LD_VAR 0 9
23341: PPUSH
23342: CALL_OW 266
23346: PUSH
23347: LD_INT 32
23349: EQUAL
23350: IFFALSE 23377
// tmp := Insert ( tmp , 1 , j ) else
23352: LD_ADDR_VAR 0 19
23356: PUSH
23357: LD_VAR 0 19
23361: PPUSH
23362: LD_INT 1
23364: PPUSH
23365: LD_VAR 0 9
23369: PPUSH
23370: CALL_OW 2
23374: ST_TO_ADDR
23375: GO 23406
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23377: LD_ADDR_VAR 0 19
23381: PUSH
23382: LD_VAR 0 19
23386: PPUSH
23387: LD_VAR 0 19
23391: PUSH
23392: LD_INT 1
23394: PLUS
23395: PPUSH
23396: LD_VAR 0 9
23400: PPUSH
23401: CALL_OW 2
23405: ST_TO_ADDR
23406: GO 23334
23408: POP
23409: POP
// if tmp then
23410: LD_VAR 0 19
23414: IFFALSE 23426
// f := tmp ;
23416: LD_ADDR_VAR 0 12
23420: PUSH
23421: LD_VAR 0 19
23425: ST_TO_ADDR
// end ; x := personel [ i ] ;
23426: LD_ADDR_VAR 0 13
23430: PUSH
23431: LD_VAR 0 6
23435: PUSH
23436: LD_VAR 0 8
23440: ARRAY
23441: ST_TO_ADDR
// if x = - 1 then
23442: LD_VAR 0 13
23446: PUSH
23447: LD_INT 1
23449: NEG
23450: EQUAL
23451: IFFALSE 23660
// begin for j in f do
23453: LD_ADDR_VAR 0 9
23457: PUSH
23458: LD_VAR 0 12
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23656
// repeat InitHc ;
23466: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23470: LD_VAR 0 9
23474: PPUSH
23475: CALL_OW 266
23479: PUSH
23480: LD_INT 5
23482: EQUAL
23483: IFFALSE 23553
// begin if UnitsInside ( j ) < 3 then
23485: LD_VAR 0 9
23489: PPUSH
23490: CALL_OW 313
23494: PUSH
23495: LD_INT 3
23497: LESS
23498: IFFALSE 23534
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23500: LD_INT 0
23502: PPUSH
23503: LD_INT 5
23505: PUSH
23506: LD_INT 8
23508: PUSH
23509: LD_INT 9
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: PUSH
23517: LD_VAR 0 17
23521: ARRAY
23522: PPUSH
23523: LD_VAR 0 4
23527: PPUSH
23528: CALL_OW 380
23532: GO 23551
// PrepareHuman ( false , i , skill ) ;
23534: LD_INT 0
23536: PPUSH
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: CALL_OW 380
// end else
23551: GO 23570
// PrepareHuman ( false , i , skill ) ;
23553: LD_INT 0
23555: PPUSH
23556: LD_VAR 0 8
23560: PPUSH
23561: LD_VAR 0 4
23565: PPUSH
23566: CALL_OW 380
// un := CreateHuman ;
23570: LD_ADDR_VAR 0 14
23574: PUSH
23575: CALL_OW 44
23579: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23580: LD_ADDR_VAR 0 7
23584: PUSH
23585: LD_VAR 0 7
23589: PPUSH
23590: LD_INT 1
23592: PPUSH
23593: LD_VAR 0 14
23597: PPUSH
23598: CALL_OW 2
23602: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23603: LD_VAR 0 14
23607: PPUSH
23608: LD_VAR 0 9
23612: PPUSH
23613: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23617: LD_VAR 0 9
23621: PPUSH
23622: CALL_OW 313
23626: PUSH
23627: LD_INT 6
23629: EQUAL
23630: PUSH
23631: LD_VAR 0 9
23635: PPUSH
23636: CALL_OW 266
23640: PUSH
23641: LD_INT 32
23643: PUSH
23644: LD_INT 31
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: IN
23651: OR
23652: IFFALSE 23466
23654: GO 23463
23656: POP
23657: POP
// end else
23658: GO 24040
// for j = 1 to x do
23660: LD_ADDR_VAR 0 9
23664: PUSH
23665: DOUBLE
23666: LD_INT 1
23668: DEC
23669: ST_TO_ADDR
23670: LD_VAR 0 13
23674: PUSH
23675: FOR_TO
23676: IFFALSE 24038
// begin InitHc ;
23678: CALL_OW 19
// if not f then
23682: LD_VAR 0 12
23686: NOT
23687: IFFALSE 23776
// begin PrepareHuman ( false , i , skill ) ;
23689: LD_INT 0
23691: PPUSH
23692: LD_VAR 0 8
23696: PPUSH
23697: LD_VAR 0 4
23701: PPUSH
23702: CALL_OW 380
// un := CreateHuman ;
23706: LD_ADDR_VAR 0 14
23710: PUSH
23711: CALL_OW 44
23715: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23716: LD_ADDR_VAR 0 7
23720: PUSH
23721: LD_VAR 0 7
23725: PPUSH
23726: LD_INT 1
23728: PPUSH
23729: LD_VAR 0 14
23733: PPUSH
23734: CALL_OW 2
23738: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23739: LD_VAR 0 14
23743: PPUSH
23744: LD_VAR 0 1
23748: PPUSH
23749: CALL_OW 250
23753: PPUSH
23754: LD_VAR 0 1
23758: PPUSH
23759: CALL_OW 251
23763: PPUSH
23764: LD_INT 10
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL_OW 50
// continue ;
23774: GO 23675
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23776: LD_VAR 0 12
23780: PUSH
23781: LD_INT 1
23783: ARRAY
23784: PPUSH
23785: CALL_OW 313
23789: PUSH
23790: LD_VAR 0 12
23794: PUSH
23795: LD_INT 1
23797: ARRAY
23798: PPUSH
23799: CALL_OW 266
23803: PUSH
23804: LD_INT 32
23806: PUSH
23807: LD_INT 31
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: IN
23814: AND
23815: PUSH
23816: LD_VAR 0 12
23820: PUSH
23821: LD_INT 1
23823: ARRAY
23824: PPUSH
23825: CALL_OW 313
23829: PUSH
23830: LD_INT 6
23832: EQUAL
23833: OR
23834: IFFALSE 23854
// f := Delete ( f , 1 ) ;
23836: LD_ADDR_VAR 0 12
23840: PUSH
23841: LD_VAR 0 12
23845: PPUSH
23846: LD_INT 1
23848: PPUSH
23849: CALL_OW 3
23853: ST_TO_ADDR
// if not f then
23854: LD_VAR 0 12
23858: NOT
23859: IFFALSE 23877
// begin x := x + 2 ;
23861: LD_ADDR_VAR 0 13
23865: PUSH
23866: LD_VAR 0 13
23870: PUSH
23871: LD_INT 2
23873: PLUS
23874: ST_TO_ADDR
// continue ;
23875: GO 23675
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23877: LD_VAR 0 12
23881: PUSH
23882: LD_INT 1
23884: ARRAY
23885: PPUSH
23886: CALL_OW 266
23890: PUSH
23891: LD_INT 5
23893: EQUAL
23894: IFFALSE 23968
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23896: LD_VAR 0 12
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 313
23909: PUSH
23910: LD_INT 3
23912: LESS
23913: IFFALSE 23949
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23915: LD_INT 0
23917: PPUSH
23918: LD_INT 5
23920: PUSH
23921: LD_INT 8
23923: PUSH
23924: LD_INT 9
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: LIST
23931: PUSH
23932: LD_VAR 0 17
23936: ARRAY
23937: PPUSH
23938: LD_VAR 0 4
23942: PPUSH
23943: CALL_OW 380
23947: GO 23966
// PrepareHuman ( false , i , skill ) ;
23949: LD_INT 0
23951: PPUSH
23952: LD_VAR 0 8
23956: PPUSH
23957: LD_VAR 0 4
23961: PPUSH
23962: CALL_OW 380
// end else
23966: GO 23985
// PrepareHuman ( false , i , skill ) ;
23968: LD_INT 0
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 4
23980: PPUSH
23981: CALL_OW 380
// un := CreateHuman ;
23985: LD_ADDR_VAR 0 14
23989: PUSH
23990: CALL_OW 44
23994: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23995: LD_ADDR_VAR 0 7
23999: PUSH
24000: LD_VAR 0 7
24004: PPUSH
24005: LD_INT 1
24007: PPUSH
24008: LD_VAR 0 14
24012: PPUSH
24013: CALL_OW 2
24017: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24018: LD_VAR 0 14
24022: PPUSH
24023: LD_VAR 0 12
24027: PUSH
24028: LD_INT 1
24030: ARRAY
24031: PPUSH
24032: CALL_OW 52
// end ;
24036: GO 23675
24038: POP
24039: POP
// end ;
24040: GO 22977
24042: POP
24043: POP
// result := result ^ buildings ;
24044: LD_ADDR_VAR 0 7
24048: PUSH
24049: LD_VAR 0 7
24053: PUSH
24054: LD_VAR 0 18
24058: ADD
24059: ST_TO_ADDR
// end else
24060: GO 24203
// begin for i = 1 to personel do
24062: LD_ADDR_VAR 0 8
24066: PUSH
24067: DOUBLE
24068: LD_INT 1
24070: DEC
24071: ST_TO_ADDR
24072: LD_VAR 0 6
24076: PUSH
24077: FOR_TO
24078: IFFALSE 24201
// begin if i > 4 then
24080: LD_VAR 0 8
24084: PUSH
24085: LD_INT 4
24087: GREATER
24088: IFFALSE 24092
// break ;
24090: GO 24201
// x := personel [ i ] ;
24092: LD_ADDR_VAR 0 13
24096: PUSH
24097: LD_VAR 0 6
24101: PUSH
24102: LD_VAR 0 8
24106: ARRAY
24107: ST_TO_ADDR
// if x = - 1 then
24108: LD_VAR 0 13
24112: PUSH
24113: LD_INT 1
24115: NEG
24116: EQUAL
24117: IFFALSE 24121
// continue ;
24119: GO 24077
// PrepareHuman ( false , i , skill ) ;
24121: LD_INT 0
24123: PPUSH
24124: LD_VAR 0 8
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: CALL_OW 380
// un := CreateHuman ;
24138: LD_ADDR_VAR 0 14
24142: PUSH
24143: CALL_OW 44
24147: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24148: LD_VAR 0 14
24152: PPUSH
24153: LD_VAR 0 1
24157: PPUSH
24158: CALL_OW 250
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 251
24172: PPUSH
24173: LD_INT 10
24175: PPUSH
24176: LD_INT 0
24178: PPUSH
24179: CALL_OW 50
// result := result ^ un ;
24183: LD_ADDR_VAR 0 7
24187: PUSH
24188: LD_VAR 0 7
24192: PUSH
24193: LD_VAR 0 14
24197: ADD
24198: ST_TO_ADDR
// end ;
24199: GO 24077
24201: POP
24202: POP
// end ; end ;
24203: LD_VAR 0 7
24207: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24208: LD_INT 0
24210: PPUSH
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
24218: PPUSH
24219: PPUSH
24220: PPUSH
24221: PPUSH
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
// result := false ;
24226: LD_ADDR_VAR 0 3
24230: PUSH
24231: LD_INT 0
24233: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24234: LD_VAR 0 1
24238: NOT
24239: PUSH
24240: LD_VAR 0 1
24244: PPUSH
24245: CALL_OW 266
24249: PUSH
24250: LD_INT 32
24252: PUSH
24253: LD_INT 33
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: IN
24260: NOT
24261: OR
24262: IFFALSE 24266
// exit ;
24264: GO 25402
// nat := GetNation ( tower ) ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 1
24275: PPUSH
24276: CALL_OW 248
24280: ST_TO_ADDR
// side := GetSide ( tower ) ;
24281: LD_ADDR_VAR 0 16
24285: PUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 255
24295: ST_TO_ADDR
// x := GetX ( tower ) ;
24296: LD_ADDR_VAR 0 10
24300: PUSH
24301: LD_VAR 0 1
24305: PPUSH
24306: CALL_OW 250
24310: ST_TO_ADDR
// y := GetY ( tower ) ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: LD_VAR 0 1
24320: PPUSH
24321: CALL_OW 251
24325: ST_TO_ADDR
// if not x or not y then
24326: LD_VAR 0 10
24330: NOT
24331: PUSH
24332: LD_VAR 0 11
24336: NOT
24337: OR
24338: IFFALSE 24342
// exit ;
24340: GO 25402
// weapon := 0 ;
24342: LD_ADDR_VAR 0 18
24346: PUSH
24347: LD_INT 0
24349: ST_TO_ADDR
// fac_list := [ ] ;
24350: LD_ADDR_VAR 0 17
24354: PUSH
24355: EMPTY
24356: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
24357: LD_ADDR_VAR 0 6
24361: PUSH
24362: LD_VAR 0 1
24366: PPUSH
24367: CALL_OW 274
24371: PPUSH
24372: LD_VAR 0 2
24376: PPUSH
24377: CALL 21980 0 2
24381: PPUSH
24382: LD_INT 30
24384: PUSH
24385: LD_INT 3
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PPUSH
24392: CALL_OW 72
24396: ST_TO_ADDR
// if not factories then
24397: LD_VAR 0 6
24401: NOT
24402: IFFALSE 24406
// exit ;
24404: GO 25402
// for i in factories do
24406: LD_ADDR_VAR 0 8
24410: PUSH
24411: LD_VAR 0 6
24415: PUSH
24416: FOR_IN
24417: IFFALSE 24442
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24419: LD_ADDR_VAR 0 17
24423: PUSH
24424: LD_VAR 0 17
24428: PUSH
24429: LD_VAR 0 8
24433: PPUSH
24434: CALL_OW 478
24438: UNION
24439: ST_TO_ADDR
24440: GO 24416
24442: POP
24443: POP
// if not fac_list then
24444: LD_VAR 0 17
24448: NOT
24449: IFFALSE 24453
// exit ;
24451: GO 25402
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24453: LD_ADDR_VAR 0 5
24457: PUSH
24458: LD_INT 4
24460: PUSH
24461: LD_INT 5
24463: PUSH
24464: LD_INT 9
24466: PUSH
24467: LD_INT 10
24469: PUSH
24470: LD_INT 6
24472: PUSH
24473: LD_INT 7
24475: PUSH
24476: LD_INT 11
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: LIST
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: PUSH
24488: LD_INT 27
24490: PUSH
24491: LD_INT 28
24493: PUSH
24494: LD_INT 26
24496: PUSH
24497: LD_INT 30
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 43
24508: PUSH
24509: LD_INT 44
24511: PUSH
24512: LD_INT 46
24514: PUSH
24515: LD_INT 45
24517: PUSH
24518: LD_INT 47
24520: PUSH
24521: LD_INT 49
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: LIST
24536: PUSH
24537: LD_VAR 0 12
24541: ARRAY
24542: ST_TO_ADDR
// for i in list do
24543: LD_ADDR_VAR 0 8
24547: PUSH
24548: LD_VAR 0 5
24552: PUSH
24553: FOR_IN
24554: IFFALSE 24587
// if not i in fac_list then
24556: LD_VAR 0 8
24560: PUSH
24561: LD_VAR 0 17
24565: IN
24566: NOT
24567: IFFALSE 24585
// list := list diff i ;
24569: LD_ADDR_VAR 0 5
24573: PUSH
24574: LD_VAR 0 5
24578: PUSH
24579: LD_VAR 0 8
24583: DIFF
24584: ST_TO_ADDR
24585: GO 24553
24587: POP
24588: POP
// if not list then
24589: LD_VAR 0 5
24593: NOT
24594: IFFALSE 24598
// exit ;
24596: GO 25402
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24598: LD_VAR 0 12
24602: PUSH
24603: LD_INT 3
24605: EQUAL
24606: PUSH
24607: LD_INT 49
24609: PUSH
24610: LD_VAR 0 5
24614: IN
24615: AND
24616: PUSH
24617: LD_INT 31
24619: PPUSH
24620: LD_VAR 0 16
24624: PPUSH
24625: CALL_OW 321
24629: PUSH
24630: LD_INT 2
24632: EQUAL
24633: AND
24634: IFFALSE 24694
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24636: LD_INT 22
24638: PUSH
24639: LD_VAR 0 16
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 35
24650: PUSH
24651: LD_INT 49
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 91
24660: PUSH
24661: LD_VAR 0 1
24665: PUSH
24666: LD_INT 10
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: PPUSH
24679: CALL_OW 69
24683: NOT
24684: IFFALSE 24694
// weapon := ru_time_lapser ;
24686: LD_ADDR_VAR 0 18
24690: PUSH
24691: LD_INT 49
24693: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24694: LD_VAR 0 12
24698: PUSH
24699: LD_INT 1
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: IN
24709: PUSH
24710: LD_INT 11
24712: PUSH
24713: LD_VAR 0 5
24717: IN
24718: PUSH
24719: LD_INT 30
24721: PUSH
24722: LD_VAR 0 5
24726: IN
24727: OR
24728: AND
24729: PUSH
24730: LD_INT 6
24732: PPUSH
24733: LD_VAR 0 16
24737: PPUSH
24738: CALL_OW 321
24742: PUSH
24743: LD_INT 2
24745: EQUAL
24746: AND
24747: IFFALSE 24912
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24749: LD_INT 22
24751: PUSH
24752: LD_VAR 0 16
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 2
24763: PUSH
24764: LD_INT 35
24766: PUSH
24767: LD_INT 11
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 35
24776: PUSH
24777: LD_INT 30
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_INT 91
24791: PUSH
24792: LD_VAR 0 1
24796: PUSH
24797: LD_INT 18
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: PPUSH
24810: CALL_OW 69
24814: NOT
24815: PUSH
24816: LD_INT 22
24818: PUSH
24819: LD_VAR 0 16
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 2
24830: PUSH
24831: LD_INT 30
24833: PUSH
24834: LD_INT 32
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 30
24843: PUSH
24844: LD_INT 33
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 91
24858: PUSH
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 12
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: LIST
24876: PUSH
24877: EMPTY
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 2
24887: GREATER
24888: AND
24889: IFFALSE 24912
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24891: LD_ADDR_VAR 0 18
24895: PUSH
24896: LD_INT 11
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_VAR 0 12
24910: ARRAY
24911: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24912: LD_VAR 0 18
24916: NOT
24917: PUSH
24918: LD_INT 40
24920: PPUSH
24921: LD_VAR 0 16
24925: PPUSH
24926: CALL_OW 321
24930: PUSH
24931: LD_INT 2
24933: EQUAL
24934: AND
24935: PUSH
24936: LD_INT 7
24938: PUSH
24939: LD_VAR 0 5
24943: IN
24944: PUSH
24945: LD_INT 28
24947: PUSH
24948: LD_VAR 0 5
24952: IN
24953: OR
24954: PUSH
24955: LD_INT 45
24957: PUSH
24958: LD_VAR 0 5
24962: IN
24963: OR
24964: AND
24965: IFFALSE 25219
// begin hex := GetHexInfo ( x , y ) ;
24967: LD_ADDR_VAR 0 4
24971: PUSH
24972: LD_VAR 0 10
24976: PPUSH
24977: LD_VAR 0 11
24981: PPUSH
24982: CALL_OW 546
24986: ST_TO_ADDR
// if hex [ 1 ] then
24987: LD_VAR 0 4
24991: PUSH
24992: LD_INT 1
24994: ARRAY
24995: IFFALSE 24999
// exit ;
24997: GO 25402
// height := hex [ 2 ] ;
24999: LD_ADDR_VAR 0 15
25003: PUSH
25004: LD_VAR 0 4
25008: PUSH
25009: LD_INT 2
25011: ARRAY
25012: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25013: LD_ADDR_VAR 0 14
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: LD_INT 3
25026: PUSH
25027: LD_INT 5
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: ST_TO_ADDR
// for i in tmp do
25036: LD_ADDR_VAR 0 8
25040: PUSH
25041: LD_VAR 0 14
25045: PUSH
25046: FOR_IN
25047: IFFALSE 25217
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25049: LD_ADDR_VAR 0 9
25053: PUSH
25054: LD_VAR 0 10
25058: PPUSH
25059: LD_VAR 0 8
25063: PPUSH
25064: LD_INT 5
25066: PPUSH
25067: CALL_OW 272
25071: PUSH
25072: LD_VAR 0 11
25076: PPUSH
25077: LD_VAR 0 8
25081: PPUSH
25082: LD_INT 5
25084: PPUSH
25085: CALL_OW 273
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25094: LD_VAR 0 9
25098: PUSH
25099: LD_INT 1
25101: ARRAY
25102: PPUSH
25103: LD_VAR 0 9
25107: PUSH
25108: LD_INT 2
25110: ARRAY
25111: PPUSH
25112: CALL_OW 488
25116: IFFALSE 25215
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25118: LD_ADDR_VAR 0 4
25122: PUSH
25123: LD_VAR 0 9
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PPUSH
25132: LD_VAR 0 9
25136: PUSH
25137: LD_INT 2
25139: ARRAY
25140: PPUSH
25141: CALL_OW 546
25145: ST_TO_ADDR
// if hex [ 1 ] then
25146: LD_VAR 0 4
25150: PUSH
25151: LD_INT 1
25153: ARRAY
25154: IFFALSE 25158
// continue ;
25156: GO 25046
// h := hex [ 2 ] ;
25158: LD_ADDR_VAR 0 13
25162: PUSH
25163: LD_VAR 0 4
25167: PUSH
25168: LD_INT 2
25170: ARRAY
25171: ST_TO_ADDR
// if h + 7 < height then
25172: LD_VAR 0 13
25176: PUSH
25177: LD_INT 7
25179: PLUS
25180: PUSH
25181: LD_VAR 0 15
25185: LESS
25186: IFFALSE 25215
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25188: LD_ADDR_VAR 0 18
25192: PUSH
25193: LD_INT 7
25195: PUSH
25196: LD_INT 28
25198: PUSH
25199: LD_INT 45
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: PUSH
25207: LD_VAR 0 12
25211: ARRAY
25212: ST_TO_ADDR
// break ;
25213: GO 25217
// end ; end ; end ;
25215: GO 25046
25217: POP
25218: POP
// end ; if not weapon then
25219: LD_VAR 0 18
25223: NOT
25224: IFFALSE 25284
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: LD_VAR 0 5
25235: PUSH
25236: LD_INT 11
25238: PUSH
25239: LD_INT 30
25241: PUSH
25242: LD_INT 49
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: LIST
25249: DIFF
25250: ST_TO_ADDR
// if not list then
25251: LD_VAR 0 5
25255: NOT
25256: IFFALSE 25260
// exit ;
25258: GO 25402
// weapon := list [ rand ( 1 , list ) ] ;
25260: LD_ADDR_VAR 0 18
25264: PUSH
25265: LD_VAR 0 5
25269: PUSH
25270: LD_INT 1
25272: PPUSH
25273: LD_VAR 0 5
25277: PPUSH
25278: CALL_OW 12
25282: ARRAY
25283: ST_TO_ADDR
// end ; if weapon then
25284: LD_VAR 0 18
25288: IFFALSE 25402
// begin tmp := CostOfWeapon ( weapon ) ;
25290: LD_ADDR_VAR 0 14
25294: PUSH
25295: LD_VAR 0 18
25299: PPUSH
25300: CALL_OW 451
25304: ST_TO_ADDR
// j := GetBase ( tower ) ;
25305: LD_ADDR_VAR 0 9
25309: PUSH
25310: LD_VAR 0 1
25314: PPUSH
25315: CALL_OW 274
25319: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25320: LD_VAR 0 9
25324: PPUSH
25325: LD_INT 1
25327: PPUSH
25328: CALL_OW 275
25332: PUSH
25333: LD_VAR 0 14
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: GREATEREQUAL
25342: PUSH
25343: LD_VAR 0 9
25347: PPUSH
25348: LD_INT 2
25350: PPUSH
25351: CALL_OW 275
25355: PUSH
25356: LD_VAR 0 14
25360: PUSH
25361: LD_INT 2
25363: ARRAY
25364: GREATEREQUAL
25365: AND
25366: PUSH
25367: LD_VAR 0 9
25371: PPUSH
25372: LD_INT 3
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 14
25384: PUSH
25385: LD_INT 3
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: IFFALSE 25402
// result := weapon ;
25392: LD_ADDR_VAR 0 3
25396: PUSH
25397: LD_VAR 0 18
25401: ST_TO_ADDR
// end ; end ;
25402: LD_VAR 0 3
25406: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25407: LD_INT 0
25409: PPUSH
25410: PPUSH
// result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// if array1 = array2 then
25419: LD_VAR 0 1
25423: PUSH
25424: LD_VAR 0 2
25428: EQUAL
25429: IFFALSE 25489
// begin for i = 1 to array1 do
25431: LD_ADDR_VAR 0 4
25435: PUSH
25436: DOUBLE
25437: LD_INT 1
25439: DEC
25440: ST_TO_ADDR
25441: LD_VAR 0 1
25445: PUSH
25446: FOR_TO
25447: IFFALSE 25485
// if array1 [ i ] <> array2 [ i ] then
25449: LD_VAR 0 1
25453: PUSH
25454: LD_VAR 0 4
25458: ARRAY
25459: PUSH
25460: LD_VAR 0 2
25464: PUSH
25465: LD_VAR 0 4
25469: ARRAY
25470: NONEQUAL
25471: IFFALSE 25483
// begin result := false ;
25473: LD_ADDR_VAR 0 3
25477: PUSH
25478: LD_INT 0
25480: ST_TO_ADDR
// break ;
25481: GO 25485
// end ;
25483: GO 25446
25485: POP
25486: POP
// end else
25487: GO 25497
// result := false ;
25489: LD_ADDR_VAR 0 3
25493: PUSH
25494: LD_INT 0
25496: ST_TO_ADDR
// end ;
25497: LD_VAR 0 3
25501: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25502: LD_INT 0
25504: PPUSH
25505: PPUSH
25506: PPUSH
// pom := GetBase ( fac ) ;
25507: LD_ADDR_VAR 0 5
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 274
25521: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 2
25531: PUSH
25532: LD_INT 1
25534: ARRAY
25535: PPUSH
25536: LD_VAR 0 2
25540: PUSH
25541: LD_INT 2
25543: ARRAY
25544: PPUSH
25545: LD_VAR 0 2
25549: PUSH
25550: LD_INT 3
25552: ARRAY
25553: PPUSH
25554: LD_VAR 0 2
25558: PUSH
25559: LD_INT 4
25561: ARRAY
25562: PPUSH
25563: CALL_OW 449
25567: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25568: LD_ADDR_VAR 0 3
25572: PUSH
25573: LD_VAR 0 5
25577: PPUSH
25578: LD_INT 1
25580: PPUSH
25581: CALL_OW 275
25585: PUSH
25586: LD_VAR 0 4
25590: PUSH
25591: LD_INT 1
25593: ARRAY
25594: GREATEREQUAL
25595: PUSH
25596: LD_VAR 0 5
25600: PPUSH
25601: LD_INT 2
25603: PPUSH
25604: CALL_OW 275
25608: PUSH
25609: LD_VAR 0 4
25613: PUSH
25614: LD_INT 2
25616: ARRAY
25617: GREATEREQUAL
25618: AND
25619: PUSH
25620: LD_VAR 0 5
25624: PPUSH
25625: LD_INT 3
25627: PPUSH
25628: CALL_OW 275
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: LD_INT 3
25640: ARRAY
25641: GREATEREQUAL
25642: AND
25643: ST_TO_ADDR
// end ;
25644: LD_VAR 0 3
25648: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
// pom := GetBase ( building ) ;
25655: LD_ADDR_VAR 0 3
25659: PUSH
25660: LD_VAR 0 1
25664: PPUSH
25665: CALL_OW 274
25669: ST_TO_ADDR
// if not pom then
25670: LD_VAR 0 3
25674: NOT
25675: IFFALSE 25679
// exit ;
25677: GO 25849
// btype := GetBType ( building ) ;
25679: LD_ADDR_VAR 0 5
25683: PUSH
25684: LD_VAR 0 1
25688: PPUSH
25689: CALL_OW 266
25693: ST_TO_ADDR
// if btype = b_armoury then
25694: LD_VAR 0 5
25698: PUSH
25699: LD_INT 4
25701: EQUAL
25702: IFFALSE 25712
// btype := b_barracks ;
25704: LD_ADDR_VAR 0 5
25708: PUSH
25709: LD_INT 5
25711: ST_TO_ADDR
// if btype = b_depot then
25712: LD_VAR 0 5
25716: PUSH
25717: LD_INT 0
25719: EQUAL
25720: IFFALSE 25730
// btype := b_warehouse ;
25722: LD_ADDR_VAR 0 5
25726: PUSH
25727: LD_INT 1
25729: ST_TO_ADDR
// if btype = b_workshop then
25730: LD_VAR 0 5
25734: PUSH
25735: LD_INT 2
25737: EQUAL
25738: IFFALSE 25748
// btype := b_factory ;
25740: LD_ADDR_VAR 0 5
25744: PUSH
25745: LD_INT 3
25747: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25748: LD_ADDR_VAR 0 4
25752: PUSH
25753: LD_VAR 0 5
25757: PPUSH
25758: LD_VAR 0 1
25762: PPUSH
25763: CALL_OW 248
25767: PPUSH
25768: CALL_OW 450
25772: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25773: LD_ADDR_VAR 0 2
25777: PUSH
25778: LD_VAR 0 3
25782: PPUSH
25783: LD_INT 1
25785: PPUSH
25786: CALL_OW 275
25790: PUSH
25791: LD_VAR 0 4
25795: PUSH
25796: LD_INT 1
25798: ARRAY
25799: GREATEREQUAL
25800: PUSH
25801: LD_VAR 0 3
25805: PPUSH
25806: LD_INT 2
25808: PPUSH
25809: CALL_OW 275
25813: PUSH
25814: LD_VAR 0 4
25818: PUSH
25819: LD_INT 2
25821: ARRAY
25822: GREATEREQUAL
25823: AND
25824: PUSH
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 3
25832: PPUSH
25833: CALL_OW 275
25837: PUSH
25838: LD_VAR 0 4
25842: PUSH
25843: LD_INT 3
25845: ARRAY
25846: GREATEREQUAL
25847: AND
25848: ST_TO_ADDR
// end ;
25849: LD_VAR 0 2
25853: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25854: LD_INT 0
25856: PPUSH
25857: PPUSH
25858: PPUSH
// pom := GetBase ( building ) ;
25859: LD_ADDR_VAR 0 4
25863: PUSH
25864: LD_VAR 0 1
25868: PPUSH
25869: CALL_OW 274
25873: ST_TO_ADDR
// if not pom then
25874: LD_VAR 0 4
25878: NOT
25879: IFFALSE 25883
// exit ;
25881: GO 25984
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25883: LD_ADDR_VAR 0 5
25887: PUSH
25888: LD_VAR 0 2
25892: PPUSH
25893: LD_VAR 0 1
25897: PPUSH
25898: CALL_OW 248
25902: PPUSH
25903: CALL_OW 450
25907: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25908: LD_ADDR_VAR 0 3
25912: PUSH
25913: LD_VAR 0 4
25917: PPUSH
25918: LD_INT 1
25920: PPUSH
25921: CALL_OW 275
25925: PUSH
25926: LD_VAR 0 5
25930: PUSH
25931: LD_INT 1
25933: ARRAY
25934: GREATEREQUAL
25935: PUSH
25936: LD_VAR 0 4
25940: PPUSH
25941: LD_INT 2
25943: PPUSH
25944: CALL_OW 275
25948: PUSH
25949: LD_VAR 0 5
25953: PUSH
25954: LD_INT 2
25956: ARRAY
25957: GREATEREQUAL
25958: AND
25959: PUSH
25960: LD_VAR 0 4
25964: PPUSH
25965: LD_INT 3
25967: PPUSH
25968: CALL_OW 275
25972: PUSH
25973: LD_VAR 0 5
25977: PUSH
25978: LD_INT 3
25980: ARRAY
25981: GREATEREQUAL
25982: AND
25983: ST_TO_ADDR
// end ;
25984: LD_VAR 0 3
25988: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25989: LD_INT 0
25991: PPUSH
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
25996: PPUSH
25997: PPUSH
25998: PPUSH
25999: PPUSH
26000: PPUSH
// result := false ;
26001: LD_ADDR_VAR 0 6
26005: PUSH
26006: LD_INT 0
26008: ST_TO_ADDR
// if not base or not btype or not x or not y then
26009: LD_VAR 0 1
26013: NOT
26014: PUSH
26015: LD_VAR 0 2
26019: NOT
26020: OR
26021: PUSH
26022: LD_VAR 0 3
26026: NOT
26027: OR
26028: PUSH
26029: LD_VAR 0 4
26033: NOT
26034: OR
26035: IFFALSE 26039
// exit ;
26037: GO 26648
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26039: LD_ADDR_VAR 0 12
26043: PUSH
26044: LD_VAR 0 2
26048: PPUSH
26049: LD_VAR 0 3
26053: PPUSH
26054: LD_VAR 0 4
26058: PPUSH
26059: LD_VAR 0 5
26063: PPUSH
26064: LD_VAR 0 1
26068: PUSH
26069: LD_INT 1
26071: ARRAY
26072: PPUSH
26073: CALL_OW 248
26077: PPUSH
26078: LD_INT 0
26080: PPUSH
26081: CALL 27485 0 6
26085: ST_TO_ADDR
// if not hexes then
26086: LD_VAR 0 12
26090: NOT
26091: IFFALSE 26095
// exit ;
26093: GO 26648
// for i = 1 to hexes do
26095: LD_ADDR_VAR 0 7
26099: PUSH
26100: DOUBLE
26101: LD_INT 1
26103: DEC
26104: ST_TO_ADDR
26105: LD_VAR 0 12
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26646
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26113: LD_ADDR_VAR 0 11
26117: PUSH
26118: LD_VAR 0 12
26122: PUSH
26123: LD_VAR 0 7
26127: ARRAY
26128: PUSH
26129: LD_INT 1
26131: ARRAY
26132: PPUSH
26133: LD_VAR 0 12
26137: PUSH
26138: LD_VAR 0 7
26142: ARRAY
26143: PUSH
26144: LD_INT 2
26146: ARRAY
26147: PPUSH
26148: CALL_OW 428
26152: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26153: LD_VAR 0 12
26157: PUSH
26158: LD_VAR 0 7
26162: ARRAY
26163: PUSH
26164: LD_INT 1
26166: ARRAY
26167: PPUSH
26168: LD_VAR 0 12
26172: PUSH
26173: LD_VAR 0 7
26177: ARRAY
26178: PUSH
26179: LD_INT 2
26181: ARRAY
26182: PPUSH
26183: CALL_OW 351
26187: PUSH
26188: LD_VAR 0 12
26192: PUSH
26193: LD_VAR 0 7
26197: ARRAY
26198: PUSH
26199: LD_INT 1
26201: ARRAY
26202: PPUSH
26203: LD_VAR 0 12
26207: PUSH
26208: LD_VAR 0 7
26212: ARRAY
26213: PUSH
26214: LD_INT 2
26216: ARRAY
26217: PPUSH
26218: CALL_OW 488
26222: NOT
26223: OR
26224: PUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 247
26234: PUSH
26235: LD_INT 3
26237: EQUAL
26238: OR
26239: IFFALSE 26245
// exit ;
26241: POP
26242: POP
26243: GO 26648
// if not tmp or not tmp in base then
26245: LD_VAR 0 11
26249: NOT
26250: PUSH
26251: LD_VAR 0 11
26255: PUSH
26256: LD_VAR 0 1
26260: IN
26261: NOT
26262: OR
26263: IFFALSE 26267
// continue ;
26265: GO 26110
// result := true ;
26267: LD_ADDR_VAR 0 6
26271: PUSH
26272: LD_INT 1
26274: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26275: LD_ADDR_VAR 0 15
26279: PUSH
26280: LD_VAR 0 1
26284: PPUSH
26285: LD_INT 22
26287: PUSH
26288: LD_VAR 0 11
26292: PPUSH
26293: CALL_OW 255
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 2
26304: PUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 0
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: LD_INT 1
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PPUSH
26334: CALL_OW 72
26338: ST_TO_ADDR
// if dep then
26339: LD_VAR 0 15
26343: IFFALSE 26479
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26345: LD_ADDR_VAR 0 14
26349: PUSH
26350: LD_VAR 0 15
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 250
26363: PPUSH
26364: LD_VAR 0 15
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 254
26377: PPUSH
26378: LD_INT 5
26380: PPUSH
26381: CALL_OW 272
26385: PUSH
26386: LD_VAR 0 15
26390: PUSH
26391: LD_INT 1
26393: ARRAY
26394: PPUSH
26395: CALL_OW 251
26399: PPUSH
26400: LD_VAR 0 15
26404: PUSH
26405: LD_INT 1
26407: ARRAY
26408: PPUSH
26409: CALL_OW 254
26413: PPUSH
26414: LD_INT 5
26416: PPUSH
26417: CALL_OW 273
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26426: LD_VAR 0 14
26430: PUSH
26431: LD_INT 1
26433: ARRAY
26434: PPUSH
26435: LD_VAR 0 14
26439: PUSH
26440: LD_INT 2
26442: ARRAY
26443: PPUSH
26444: CALL_OW 488
26448: IFFALSE 26479
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26450: LD_VAR 0 11
26454: PPUSH
26455: LD_VAR 0 14
26459: PUSH
26460: LD_INT 1
26462: ARRAY
26463: PPUSH
26464: LD_VAR 0 14
26468: PUSH
26469: LD_INT 2
26471: ARRAY
26472: PPUSH
26473: CALL_OW 111
// continue ;
26477: GO 26110
// end ; end ; r := GetDir ( tmp ) ;
26479: LD_ADDR_VAR 0 13
26483: PUSH
26484: LD_VAR 0 11
26488: PPUSH
26489: CALL_OW 254
26493: ST_TO_ADDR
// if r = 5 then
26494: LD_VAR 0 13
26498: PUSH
26499: LD_INT 5
26501: EQUAL
26502: IFFALSE 26512
// r := 0 ;
26504: LD_ADDR_VAR 0 13
26508: PUSH
26509: LD_INT 0
26511: ST_TO_ADDR
// for j = r to 5 do
26512: LD_ADDR_VAR 0 8
26516: PUSH
26517: DOUBLE
26518: LD_VAR 0 13
26522: DEC
26523: ST_TO_ADDR
26524: LD_INT 5
26526: PUSH
26527: FOR_TO
26528: IFFALSE 26642
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26530: LD_ADDR_VAR 0 9
26534: PUSH
26535: LD_VAR 0 11
26539: PPUSH
26540: CALL_OW 250
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_INT 2
26552: PPUSH
26553: CALL_OW 272
26557: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26558: LD_ADDR_VAR 0 10
26562: PUSH
26563: LD_VAR 0 11
26567: PPUSH
26568: CALL_OW 251
26572: PPUSH
26573: LD_VAR 0 8
26577: PPUSH
26578: LD_INT 2
26580: PPUSH
26581: CALL_OW 273
26585: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26586: LD_VAR 0 9
26590: PPUSH
26591: LD_VAR 0 10
26595: PPUSH
26596: CALL_OW 488
26600: PUSH
26601: LD_VAR 0 9
26605: PPUSH
26606: LD_VAR 0 10
26610: PPUSH
26611: CALL_OW 428
26615: NOT
26616: AND
26617: IFFALSE 26640
// begin ComMoveXY ( tmp , _x , _y ) ;
26619: LD_VAR 0 11
26623: PPUSH
26624: LD_VAR 0 9
26628: PPUSH
26629: LD_VAR 0 10
26633: PPUSH
26634: CALL_OW 111
// break ;
26638: GO 26642
// end ; end ;
26640: GO 26527
26642: POP
26643: POP
// end ;
26644: GO 26110
26646: POP
26647: POP
// end ;
26648: LD_VAR 0 6
26652: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26653: LD_INT 0
26655: PPUSH
26656: PPUSH
26657: PPUSH
26658: PPUSH
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
// result := false ;
26665: LD_ADDR_VAR 0 6
26669: PUSH
26670: LD_INT 0
26672: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26673: LD_VAR 0 1
26677: NOT
26678: PUSH
26679: LD_VAR 0 1
26683: PPUSH
26684: CALL_OW 266
26688: PUSH
26689: LD_INT 0
26691: PUSH
26692: LD_INT 1
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: IN
26699: NOT
26700: OR
26701: PUSH
26702: LD_VAR 0 2
26706: NOT
26707: OR
26708: PUSH
26709: LD_VAR 0 5
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 1
26719: PUSH
26720: LD_INT 2
26722: PUSH
26723: LD_INT 3
26725: PUSH
26726: LD_INT 4
26728: PUSH
26729: LD_INT 5
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: IN
26740: NOT
26741: OR
26742: PUSH
26743: LD_VAR 0 3
26747: PPUSH
26748: LD_VAR 0 4
26752: PPUSH
26753: CALL_OW 488
26757: NOT
26758: OR
26759: IFFALSE 26763
// exit ;
26761: GO 27480
// pom := GetBase ( depot ) ;
26763: LD_ADDR_VAR 0 10
26767: PUSH
26768: LD_VAR 0 1
26772: PPUSH
26773: CALL_OW 274
26777: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26778: LD_ADDR_VAR 0 11
26782: PUSH
26783: LD_VAR 0 2
26787: PPUSH
26788: LD_VAR 0 1
26792: PPUSH
26793: CALL_OW 248
26797: PPUSH
26798: CALL_OW 450
26802: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26803: LD_VAR 0 10
26807: PPUSH
26808: LD_INT 1
26810: PPUSH
26811: CALL_OW 275
26815: PUSH
26816: LD_VAR 0 11
26820: PUSH
26821: LD_INT 1
26823: ARRAY
26824: GREATEREQUAL
26825: PUSH
26826: LD_VAR 0 10
26830: PPUSH
26831: LD_INT 2
26833: PPUSH
26834: CALL_OW 275
26838: PUSH
26839: LD_VAR 0 11
26843: PUSH
26844: LD_INT 2
26846: ARRAY
26847: GREATEREQUAL
26848: AND
26849: PUSH
26850: LD_VAR 0 10
26854: PPUSH
26855: LD_INT 3
26857: PPUSH
26858: CALL_OW 275
26862: PUSH
26863: LD_VAR 0 11
26867: PUSH
26868: LD_INT 3
26870: ARRAY
26871: GREATEREQUAL
26872: AND
26873: NOT
26874: IFFALSE 26878
// exit ;
26876: GO 27480
// if GetBType ( depot ) = b_depot then
26878: LD_VAR 0 1
26882: PPUSH
26883: CALL_OW 266
26887: PUSH
26888: LD_INT 0
26890: EQUAL
26891: IFFALSE 26903
// dist := 28 else
26893: LD_ADDR_VAR 0 14
26897: PUSH
26898: LD_INT 28
26900: ST_TO_ADDR
26901: GO 26911
// dist := 36 ;
26903: LD_ADDR_VAR 0 14
26907: PUSH
26908: LD_INT 36
26910: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26911: LD_VAR 0 1
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: LD_VAR 0 4
26925: PPUSH
26926: CALL_OW 297
26930: PUSH
26931: LD_VAR 0 14
26935: GREATER
26936: IFFALSE 26940
// exit ;
26938: GO 27480
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26940: LD_ADDR_VAR 0 12
26944: PUSH
26945: LD_VAR 0 2
26949: PPUSH
26950: LD_VAR 0 3
26954: PPUSH
26955: LD_VAR 0 4
26959: PPUSH
26960: LD_VAR 0 5
26964: PPUSH
26965: LD_VAR 0 1
26969: PPUSH
26970: CALL_OW 248
26974: PPUSH
26975: LD_INT 0
26977: PPUSH
26978: CALL 27485 0 6
26982: ST_TO_ADDR
// if not hexes then
26983: LD_VAR 0 12
26987: NOT
26988: IFFALSE 26992
// exit ;
26990: GO 27480
// hex := GetHexInfo ( x , y ) ;
26992: LD_ADDR_VAR 0 15
26996: PUSH
26997: LD_VAR 0 3
27001: PPUSH
27002: LD_VAR 0 4
27006: PPUSH
27007: CALL_OW 546
27011: ST_TO_ADDR
// if hex [ 1 ] then
27012: LD_VAR 0 15
27016: PUSH
27017: LD_INT 1
27019: ARRAY
27020: IFFALSE 27024
// exit ;
27022: GO 27480
// height := hex [ 2 ] ;
27024: LD_ADDR_VAR 0 13
27028: PUSH
27029: LD_VAR 0 15
27033: PUSH
27034: LD_INT 2
27036: ARRAY
27037: ST_TO_ADDR
// for i = 1 to hexes do
27038: LD_ADDR_VAR 0 7
27042: PUSH
27043: DOUBLE
27044: LD_INT 1
27046: DEC
27047: ST_TO_ADDR
27048: LD_VAR 0 12
27052: PUSH
27053: FOR_TO
27054: IFFALSE 27384
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27056: LD_VAR 0 12
27060: PUSH
27061: LD_VAR 0 7
27065: ARRAY
27066: PUSH
27067: LD_INT 1
27069: ARRAY
27070: PPUSH
27071: LD_VAR 0 12
27075: PUSH
27076: LD_VAR 0 7
27080: ARRAY
27081: PUSH
27082: LD_INT 2
27084: ARRAY
27085: PPUSH
27086: CALL_OW 488
27090: NOT
27091: PUSH
27092: LD_VAR 0 12
27096: PUSH
27097: LD_VAR 0 7
27101: ARRAY
27102: PUSH
27103: LD_INT 1
27105: ARRAY
27106: PPUSH
27107: LD_VAR 0 12
27111: PUSH
27112: LD_VAR 0 7
27116: ARRAY
27117: PUSH
27118: LD_INT 2
27120: ARRAY
27121: PPUSH
27122: CALL_OW 428
27126: PUSH
27127: LD_INT 0
27129: GREATER
27130: OR
27131: PUSH
27132: LD_VAR 0 12
27136: PUSH
27137: LD_VAR 0 7
27141: ARRAY
27142: PUSH
27143: LD_INT 1
27145: ARRAY
27146: PPUSH
27147: LD_VAR 0 12
27151: PUSH
27152: LD_VAR 0 7
27156: ARRAY
27157: PUSH
27158: LD_INT 2
27160: ARRAY
27161: PPUSH
27162: CALL_OW 351
27166: OR
27167: IFFALSE 27173
// exit ;
27169: POP
27170: POP
27171: GO 27480
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27173: LD_ADDR_VAR 0 8
27177: PUSH
27178: LD_VAR 0 12
27182: PUSH
27183: LD_VAR 0 7
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_VAR 0 12
27197: PUSH
27198: LD_VAR 0 7
27202: ARRAY
27203: PUSH
27204: LD_INT 2
27206: ARRAY
27207: PPUSH
27208: CALL_OW 546
27212: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27213: LD_VAR 0 8
27217: PUSH
27218: LD_INT 1
27220: ARRAY
27221: PUSH
27222: LD_VAR 0 8
27226: PUSH
27227: LD_INT 2
27229: ARRAY
27230: PUSH
27231: LD_VAR 0 13
27235: PUSH
27236: LD_INT 2
27238: PLUS
27239: GREATER
27240: OR
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_INT 2
27249: ARRAY
27250: PUSH
27251: LD_VAR 0 13
27255: PUSH
27256: LD_INT 2
27258: MINUS
27259: LESS
27260: OR
27261: PUSH
27262: LD_VAR 0 8
27266: PUSH
27267: LD_INT 3
27269: ARRAY
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: LD_INT 8
27276: PUSH
27277: LD_INT 9
27279: PUSH
27280: LD_INT 10
27282: PUSH
27283: LD_INT 11
27285: PUSH
27286: LD_INT 12
27288: PUSH
27289: LD_INT 13
27291: PUSH
27292: LD_INT 16
27294: PUSH
27295: LD_INT 17
27297: PUSH
27298: LD_INT 18
27300: PUSH
27301: LD_INT 19
27303: PUSH
27304: LD_INT 20
27306: PUSH
27307: LD_INT 21
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: IN
27325: NOT
27326: OR
27327: PUSH
27328: LD_VAR 0 8
27332: PUSH
27333: LD_INT 5
27335: ARRAY
27336: NOT
27337: OR
27338: PUSH
27339: LD_VAR 0 8
27343: PUSH
27344: LD_INT 6
27346: ARRAY
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: LD_INT 2
27353: PUSH
27354: LD_INT 7
27356: PUSH
27357: LD_INT 9
27359: PUSH
27360: LD_INT 10
27362: PUSH
27363: LD_INT 11
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: IN
27374: NOT
27375: OR
27376: IFFALSE 27382
// exit ;
27378: POP
27379: POP
27380: GO 27480
// end ;
27382: GO 27053
27384: POP
27385: POP
// side := GetSide ( depot ) ;
27386: LD_ADDR_VAR 0 9
27390: PUSH
27391: LD_VAR 0 1
27395: PPUSH
27396: CALL_OW 255
27400: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27401: LD_VAR 0 9
27405: PPUSH
27406: LD_VAR 0 3
27410: PPUSH
27411: LD_VAR 0 4
27415: PPUSH
27416: LD_INT 20
27418: PPUSH
27419: CALL 20134 0 4
27423: PUSH
27424: LD_INT 4
27426: ARRAY
27427: IFFALSE 27431
// exit ;
27429: GO 27480
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27431: LD_VAR 0 2
27435: PUSH
27436: LD_INT 29
27438: PUSH
27439: LD_INT 30
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: IN
27446: PUSH
27447: LD_VAR 0 3
27451: PPUSH
27452: LD_VAR 0 4
27456: PPUSH
27457: LD_VAR 0 9
27461: PPUSH
27462: CALL_OW 440
27466: NOT
27467: AND
27468: IFFALSE 27472
// exit ;
27470: GO 27480
// result := true ;
27472: LD_ADDR_VAR 0 6
27476: PUSH
27477: LD_INT 1
27479: ST_TO_ADDR
// end ;
27480: LD_VAR 0 6
27484: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
27485: LD_INT 0
27487: PPUSH
27488: PPUSH
27489: PPUSH
27490: PPUSH
27491: PPUSH
27492: PPUSH
27493: PPUSH
27494: PPUSH
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
27503: PPUSH
27504: PPUSH
27505: PPUSH
27506: PPUSH
27507: PPUSH
27508: PPUSH
27509: PPUSH
27510: PPUSH
27511: PPUSH
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
27532: PPUSH
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
// result = [ ] ;
27545: LD_ADDR_VAR 0 7
27549: PUSH
27550: EMPTY
27551: ST_TO_ADDR
// temp_list = [ ] ;
27552: LD_ADDR_VAR 0 9
27556: PUSH
27557: EMPTY
27558: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27559: LD_VAR 0 4
27563: PUSH
27564: LD_INT 0
27566: PUSH
27567: LD_INT 1
27569: PUSH
27570: LD_INT 2
27572: PUSH
27573: LD_INT 3
27575: PUSH
27576: LD_INT 4
27578: PUSH
27579: LD_INT 5
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: IN
27590: NOT
27591: PUSH
27592: LD_VAR 0 1
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: LD_INT 1
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: IN
27607: PUSH
27608: LD_VAR 0 5
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: LD_INT 3
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: LIST
27626: IN
27627: NOT
27628: AND
27629: OR
27630: IFFALSE 27634
// exit ;
27632: GO 46025
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27634: LD_VAR 0 1
27638: PUSH
27639: LD_INT 6
27641: PUSH
27642: LD_INT 7
27644: PUSH
27645: LD_INT 8
27647: PUSH
27648: LD_INT 13
27650: PUSH
27651: LD_INT 12
27653: PUSH
27654: LD_INT 15
27656: PUSH
27657: LD_INT 11
27659: PUSH
27660: LD_INT 14
27662: PUSH
27663: LD_INT 10
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: IN
27677: IFFALSE 27687
// btype = b_lab ;
27679: LD_ADDR_VAR 0 1
27683: PUSH
27684: LD_INT 6
27686: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27687: LD_VAR 0 6
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: LD_INT 1
27697: PUSH
27698: LD_INT 2
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: LIST
27705: IN
27706: NOT
27707: PUSH
27708: LD_VAR 0 1
27712: PUSH
27713: LD_INT 0
27715: PUSH
27716: LD_INT 1
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: LD_INT 6
27727: PUSH
27728: LD_INT 36
27730: PUSH
27731: LD_INT 4
27733: PUSH
27734: LD_INT 5
27736: PUSH
27737: LD_INT 31
27739: PUSH
27740: LD_INT 32
27742: PUSH
27743: LD_INT 33
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: IN
27759: NOT
27760: PUSH
27761: LD_VAR 0 6
27765: PUSH
27766: LD_INT 1
27768: EQUAL
27769: AND
27770: OR
27771: PUSH
27772: LD_VAR 0 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: IN
27787: NOT
27788: PUSH
27789: LD_VAR 0 6
27793: PUSH
27794: LD_INT 2
27796: EQUAL
27797: AND
27798: OR
27799: IFFALSE 27809
// mode = 0 ;
27801: LD_ADDR_VAR 0 6
27805: PUSH
27806: LD_INT 0
27808: ST_TO_ADDR
// case mode of 0 :
27809: LD_VAR 0 6
27813: PUSH
27814: LD_INT 0
27816: DOUBLE
27817: EQUAL
27818: IFTRUE 27822
27820: GO 39275
27822: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27823: LD_ADDR_VAR 0 11
27827: PUSH
27828: LD_INT 0
27830: PUSH
27831: LD_INT 0
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 1
27843: NEG
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 1
27851: PUSH
27852: LD_INT 0
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 1
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 0
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 1
27881: NEG
27882: PUSH
27883: LD_INT 0
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: PUSH
27890: LD_INT 1
27892: NEG
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 1
27904: NEG
27905: PUSH
27906: LD_INT 2
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 0
27916: PUSH
27917: LD_INT 2
27919: NEG
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: LD_INT 1
27930: NEG
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: LD_INT 2
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: LD_INT 2
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: LD_INT 1
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 3
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 3
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 2
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28016: LD_ADDR_VAR 0 12
28020: PUSH
28021: LD_INT 0
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 0
28033: PUSH
28034: LD_INT 1
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 1
28044: PUSH
28045: LD_INT 0
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 1
28054: PUSH
28055: LD_INT 1
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 0
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 1
28085: NEG
28086: PUSH
28087: LD_INT 1
28089: NEG
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 1
28097: PUSH
28098: LD_INT 1
28100: NEG
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 1
28128: NEG
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: LD_INT 1
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: LD_INT 3
28173: NEG
28174: PUSH
28175: LD_INT 0
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 3
28184: NEG
28185: PUSH
28186: LD_INT 1
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28212: LD_ADDR_VAR 0 13
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 2
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 2
28315: PUSH
28316: LD_INT 2
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: NEG
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 2
28347: NEG
28348: PUSH
28349: LD_INT 2
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 3
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 3
28371: NEG
28372: PUSH
28373: LD_INT 2
28375: NEG
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 3
28383: NEG
28384: PUSH
28385: LD_INT 3
28387: NEG
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28411: LD_ADDR_VAR 0 14
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 1
28431: NEG
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 1
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 0
28459: PUSH
28460: LD_INT 1
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: LD_INT 1
28469: NEG
28470: PUSH
28471: LD_INT 0
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: LD_INT 1
28484: NEG
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: NEG
28493: PUSH
28494: LD_INT 2
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 0
28504: PUSH
28505: LD_INT 2
28507: NEG
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 1
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: LD_INT 2
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: NEG
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: NEG
28558: PUSH
28559: LD_INT 3
28561: NEG
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: LD_INT 3
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: PUSH
28581: LD_INT 2
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28607: LD_ADDR_VAR 0 15
28611: PUSH
28612: LD_INT 0
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 0
28624: PUSH
28625: LD_INT 1
28627: NEG
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 1
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: LD_INT 1
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 1
28676: NEG
28677: PUSH
28678: LD_INT 1
28680: NEG
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 1
28688: PUSH
28689: LD_INT 1
28691: NEG
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PUSH
28697: LD_INT 2
28699: PUSH
28700: LD_INT 0
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 1
28719: NEG
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: LD_INT 0
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: LD_INT 1
28745: NEG
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 3
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28800: LD_ADDR_VAR 0 16
28804: PUSH
28805: LD_INT 0
28807: PUSH
28808: LD_INT 0
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: LD_INT 1
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 0
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 1
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 0
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 0
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: NEG
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: LD_INT 2
28885: NEG
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: PUSH
28904: LD_INT 2
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 2
28923: NEG
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 2
28935: NEG
28936: PUSH
28937: LD_INT 2
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 3
28947: PUSH
28948: LD_INT 2
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: LD_INT 3
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 2
28967: PUSH
28968: LD_INT 3
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28993: LD_ADDR_VAR 0 17
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 2
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: NEG
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: LD_INT 2
29196: NEG
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 18
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29453: LD_ADDR_VAR 0 19
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: LD_INT 2
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29683: LD_ADDR_VAR 0 20
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 0
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: NEG
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: LIST
29903: LIST
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29913: LD_ADDR_VAR 0 21
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: NEG
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: LD_INT 0
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: LD_INT 0
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 1
29982: NEG
29983: PUSH
29984: LD_INT 1
29986: NEG
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: LD_INT 2
29998: NEG
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 2
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 1
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 2
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 2
30089: NEG
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 2
30100: NEG
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: LD_INT 2
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30143: LD_ADDR_VAR 0 22
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 0
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 0
30160: PUSH
30161: LD_INT 1
30163: NEG
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 0
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 0
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: NEG
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: LD_INT 2
30228: NEG
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: NEG
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 2
30278: PUSH
30279: LD_INT 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 0
30298: PUSH
30299: LD_INT 2
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 2
30330: NEG
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 2
30342: NEG
30343: PUSH
30344: LD_INT 2
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30373: LD_ADDR_VAR 0 23
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 0
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: LD_INT 1
30393: NEG
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 0
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 1
30431: NEG
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 1
30446: NEG
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 1
30454: NEG
30455: PUSH
30456: LD_INT 2
30458: NEG
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 0
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 1
30477: PUSH
30478: LD_INT 1
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 2
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: LD_INT 2
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 2
30549: NEG
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 2
30560: NEG
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 2
30572: NEG
30573: PUSH
30574: LD_INT 2
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: NEG
30585: PUSH
30586: LD_INT 3
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 3
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 2
30611: NEG
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30653: LD_ADDR_VAR 0 24
30657: PUSH
30658: LD_INT 0
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: PUSH
30682: LD_INT 0
30684: PUSH
30685: EMPTY
30686: LIST
30687: LIST
30688: PUSH
30689: LD_INT 1
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 1
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 1
30711: NEG
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: LD_INT 1
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: LD_INT 2
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: LD_INT 2
30749: NEG
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 1
30757: PUSH
30758: LD_INT 1
30760: NEG
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 2
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 2
30778: PUSH
30779: LD_INT 1
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 2
30788: PUSH
30789: LD_INT 2
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 2
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 2
30829: NEG
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: NEG
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 2
30852: NEG
30853: PUSH
30854: LD_INT 2
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 2
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 3
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30929: LD_ADDR_VAR 0 25
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: NEG
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: LD_INT 1
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: LD_INT 1
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 2
31014: NEG
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 0
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: LD_INT 2
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: LD_INT 2
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: NEG
31129: PUSH
31130: LD_INT 2
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 3
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 3
31150: PUSH
31151: LD_INT 2
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: LD_INT 3
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 1
31170: PUSH
31171: LD_INT 3
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31203: LD_ADDR_VAR 0 26
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 1
31241: PUSH
31242: LD_INT 1
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: LD_INT 1
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: NEG
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: NEG
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 1
31284: NEG
31285: PUSH
31286: LD_INT 2
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: LD_INT 2
31299: NEG
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: LD_INT 1
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 2
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 2
31328: PUSH
31329: LD_INT 1
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 2
31338: PUSH
31339: LD_INT 2
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: LD_INT 2
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 2
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: LD_INT 1
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 2
31379: NEG
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 2
31390: NEG
31391: PUSH
31392: LD_INT 1
31394: NEG
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: LD_INT 2
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 3
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31479: LD_ADDR_VAR 0 27
31483: PUSH
31484: LD_INT 0
31486: PUSH
31487: LD_INT 0
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: NEG
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: NEG
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 1
31560: NEG
31561: PUSH
31562: LD_INT 2
31564: NEG
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: LD_INT 2
31575: NEG
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: NEG
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 2
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 2
31614: PUSH
31615: LD_INT 2
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: LD_INT 2
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 0
31634: PUSH
31635: LD_INT 2
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: LD_INT 1
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: LD_INT 1
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 2
31678: NEG
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 3
31712: NEG
31713: PUSH
31714: LD_INT 1
31716: NEG
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 3
31724: NEG
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31759: LD_ADDR_VAR 0 28
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 0
31776: PUSH
31777: LD_INT 1
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: LD_INT 0
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 1
31797: PUSH
31798: LD_INT 1
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: NEG
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 2
31844: NEG
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 0
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 2
31946: NEG
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 2
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 2
31970: NEG
31971: PUSH
31972: LD_INT 3
31974: NEG
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 3
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 3
31994: NEG
31995: PUSH
31996: LD_INT 1
31998: NEG
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 3
32006: NEG
32007: PUSH
32008: LD_INT 2
32010: NEG
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32041: LD_ADDR_VAR 0 29
32045: PUSH
32046: LD_INT 0
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: LD_INT 1
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: LD_INT 1
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 1
32122: NEG
32123: PUSH
32124: LD_INT 2
32126: NEG
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: LD_INT 2
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 0
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 1
32196: NEG
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 2
32207: NEG
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 2
32219: NEG
32220: PUSH
32221: LD_INT 2
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 2
32231: NEG
32232: PUSH
32233: LD_INT 3
32235: NEG
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 2
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: LD_INT 1
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: LD_INT 3
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 1
32274: NEG
32275: PUSH
32276: LD_INT 2
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 3
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32320: LD_ADDR_VAR 0 30
32324: PUSH
32325: LD_INT 0
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 0
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 1
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 2
32445: PUSH
32446: LD_INT 1
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 2
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 1
32465: PUSH
32466: LD_INT 2
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: LD_INT 1
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 2
32486: NEG
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 2
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 3
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 2
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 2
32552: NEG
32553: PUSH
32554: LD_INT 1
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 3
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32598: LD_ADDR_VAR 0 31
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 0
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: LD_INT 1
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 1
32679: NEG
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 2
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: LD_INT 2
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 1
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: LD_INT 2
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 2
32763: NEG
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 2
32775: NEG
32776: PUSH
32777: LD_INT 2
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 2
32787: NEG
32788: PUSH
32789: LD_INT 3
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 3
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 3
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32876: LD_ADDR_VAR 0 32
32880: PUSH
32881: LD_INT 0
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: LD_INT 0
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: LD_INT 1
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 2
33001: PUSH
33002: LD_INT 2
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: LD_INT 2
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 2
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 1
33031: NEG
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 2
33042: NEG
33043: PUSH
33044: LD_INT 0
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: NEG
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 3
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 2
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 3
33088: PUSH
33089: LD_INT 2
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: LD_INT 3
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 3
33119: NEG
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33154: LD_ADDR_VAR 0 33
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: LD_INT 1
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 1
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 2
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: LD_INT 1
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 2
33309: NEG
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 2
33320: NEG
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: LD_INT 2
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 3
33348: NEG
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 3
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 3
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: NEG
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 3
33398: NEG
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33433: LD_ADDR_VAR 0 34
33437: PUSH
33438: LD_INT 0
33440: PUSH
33441: LD_INT 0
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: LD_INT 1
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: LD_INT 0
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 1
33502: NEG
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: LD_INT 2
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 2
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 2
33558: PUSH
33559: LD_INT 2
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: LD_INT 2
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 1
33578: NEG
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 1
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: LD_INT 3
33628: NEG
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 3
33647: PUSH
33648: LD_INT 2
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 2
33657: PUSH
33658: LD_INT 3
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 2
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 3
33678: NEG
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33713: LD_ADDR_VAR 0 35
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: LD_INT 1
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 1
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: LD_INT 0
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33825: LD_ADDR_VAR 0 36
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: LD_INT 2
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 2
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33937: LD_ADDR_VAR 0 37
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 1
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: LD_INT 0
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 1
33995: NEG
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: NEG
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34049: LD_ADDR_VAR 0 38
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 1
34077: PUSH
34078: LD_INT 0
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34161: LD_ADDR_VAR 0 39
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: LD_INT 0
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 1
34234: NEG
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34273: LD_ADDR_VAR 0 40
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 1
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 1
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 1
34357: NEG
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34385: LD_ADDR_VAR 0 41
34389: PUSH
34390: LD_INT 0
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: LD_INT 1
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: LD_INT 2
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: LD_INT 2
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 2
34540: NEG
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 2
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: NEG
34576: PUSH
34577: LD_INT 3
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 3
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 3
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 3
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 3
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: LD_INT 3
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 3
34659: NEG
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 3
34682: NEG
34683: PUSH
34684: LD_INT 2
34686: NEG
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 3
34694: NEG
34695: PUSH
34696: LD_INT 3
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34735: LD_ADDR_VAR 0 42
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: NEG
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: PUSH
34861: LD_INT 2
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 2
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: LD_INT 2
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: LD_INT 1
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 2
34901: NEG
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 2
34917: NEG
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: LD_INT 3
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 1
34937: NEG
34938: PUSH
34939: LD_INT 3
34941: NEG
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 3
34952: NEG
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: LD_INT 2
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 3
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 3
34981: PUSH
34982: LD_INT 3
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: PUSH
34992: LD_INT 3
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: PUSH
35002: LD_INT 3
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 3
35032: NEG
35033: PUSH
35034: LD_INT 2
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: LD_INT 3
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35085: LD_ADDR_VAR 0 43
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 2
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 3
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: LD_INT 3
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: LD_INT 2
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 2
35308: PUSH
35309: LD_INT 1
35311: NEG
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 1
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 2
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 3
35381: NEG
35382: PUSH
35383: LD_INT 0
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 3
35392: NEG
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35433: LD_ADDR_VAR 0 44
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 1
35461: PUSH
35462: LD_INT 0
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: LD_INT 1
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 2
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 2
35557: PUSH
35558: LD_INT 2
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: LD_INT 1
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 2
35588: NEG
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 2
35599: NEG
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: LD_INT 2
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 3
35627: NEG
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 3
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 3
35656: PUSH
35657: LD_INT 1
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 3
35666: PUSH
35667: LD_INT 2
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 3
35676: PUSH
35677: LD_INT 3
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 3
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 2
35696: NEG
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 3
35707: NEG
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 3
35718: NEG
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 3
35730: NEG
35731: PUSH
35732: LD_INT 2
35734: NEG
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 3
35742: NEG
35743: PUSH
35744: LD_INT 3
35746: NEG
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35783: LD_ADDR_VAR 0 45
35787: PUSH
35788: LD_INT 0
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 1
35841: NEG
35842: PUSH
35843: LD_INT 0
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: LD_INT 2
35868: NEG
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 1
35953: NEG
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 2
35961: NEG
35962: PUSH
35963: LD_INT 2
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: NEG
35974: PUSH
35975: LD_INT 3
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 3
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: LD_INT 3
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 2
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 3
36019: PUSH
36020: LD_INT 2
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 3
36029: PUSH
36030: LD_INT 3
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: LD_INT 3
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: LD_INT 3
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 3
36080: NEG
36081: PUSH
36082: LD_INT 2
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: LD_INT 3
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36133: LD_ADDR_VAR 0 46
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 0
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: LD_INT 0
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: LD_INT 1
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 0
36181: PUSH
36182: LD_INT 1
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 1
36214: NEG
36215: PUSH
36216: LD_INT 2
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 2
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 1
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: NEG
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: LD_INT 3
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 3
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: PUSH
36378: LD_INT 1
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 0
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: NEG
36408: PUSH
36409: LD_INT 2
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 3
36429: NEG
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 3
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36481: LD_ADDR_VAR 0 47
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: NEG
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: LD_INT 1
36554: NEG
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: NEG
36563: PUSH
36564: LD_INT 2
36566: NEG
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 2
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 1
36588: NEG
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 2
36596: NEG
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 2
36608: NEG
36609: PUSH
36610: LD_INT 2
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36632: LD_ADDR_VAR 0 48
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 0
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 0
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: LD_INT 1
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: LD_INT 2
36717: NEG
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 2
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36779: LD_ADDR_VAR 0 49
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 0
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: LD_INT 1
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 2
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 2
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 2
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: LIST
36913: LIST
36914: LIST
36915: LIST
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36923: LD_ADDR_VAR 0 50
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: LD_INT 0
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 0
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 1
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 1
36961: PUSH
36962: LD_INT 1
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 0
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: NEG
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 1
36992: NEG
36993: PUSH
36994: LD_INT 1
36996: NEG
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: PUSH
37005: LD_INT 1
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: LD_INT 2
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: LD_INT 2
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37067: LD_ADDR_VAR 0 51
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 0
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 1
37136: NEG
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 1
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 0
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: NEG
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 2
37190: NEG
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37214: LD_ADDR_VAR 0 52
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 1
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 1
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 0
37262: PUSH
37263: LD_INT 1
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: NEG
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: NEG
37296: PUSH
37297: LD_INT 2
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: NEG
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 2
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: LD_INT 2
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37365: LD_ADDR_VAR 0 53
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37595: LD_ADDR_VAR 0 54
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37825: LD_ADDR_VAR 0 55
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: LD_INT 1
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 0
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 1
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 2
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38055: LD_ADDR_VAR 0 56
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 2
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: LD_INT 2
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 0
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: NEG
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 2
38242: NEG
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 2
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38285: LD_ADDR_VAR 0 57
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 1
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 0
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 0
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 1
38343: NEG
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: NEG
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: LD_INT 2
38370: NEG
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 0
38378: PUSH
38379: LD_INT 2
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 2
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: NEG
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 2
38472: NEG
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: NEG
38485: PUSH
38486: LD_INT 2
38488: NEG
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38515: LD_ADDR_VAR 0 58
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: LD_INT 0
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 0
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 1
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: PUSH
38651: LD_INT 2
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: LD_INT 2
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: LD_INT 1
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 2
38691: NEG
38692: PUSH
38693: LD_INT 0
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 2
38714: NEG
38715: PUSH
38716: LD_INT 2
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38745: LD_ADDR_VAR 0 59
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 0
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 1
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 0
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: LD_INT 0
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38833: LD_ADDR_VAR 0 60
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: LD_INT 0
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38921: LD_ADDR_VAR 0 61
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: LD_INT 0
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: LD_INT 1
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: LD_INT 1
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 1
38979: NEG
38980: PUSH
38981: LD_INT 0
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39009: LD_ADDR_VAR 0 62
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 0
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 1
39078: NEG
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39097: LD_ADDR_VAR 0 63
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: NEG
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: NEG
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39185: LD_ADDR_VAR 0 64
39189: PUSH
39190: LD_INT 0
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 1
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: PUSH
39224: LD_INT 1
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 0
39233: PUSH
39234: LD_INT 1
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: ST_TO_ADDR
// end ; 1 :
39273: GO 45170
39275: LD_INT 1
39277: DOUBLE
39278: EQUAL
39279: IFTRUE 39283
39281: GO 41906
39283: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39284: LD_ADDR_VAR 0 11
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: LD_INT 3
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: LD_INT 3
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 1
39314: PUSH
39315: LD_INT 2
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: LIST
39327: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39328: LD_ADDR_VAR 0 12
39332: PUSH
39333: LD_INT 2
39335: PUSH
39336: LD_INT 1
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 3
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 3
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: LIST
39368: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39369: LD_ADDR_VAR 0 13
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 3
39386: PUSH
39387: LD_INT 3
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: LD_INT 3
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39409: LD_ADDR_VAR 0 14
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 3
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: LD_INT 2
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: LIST
39449: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39450: LD_ADDR_VAR 0 15
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 3
39468: NEG
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 3
39479: NEG
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39494: LD_ADDR_VAR 0 16
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: LD_INT 3
39505: NEG
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 3
39513: NEG
39514: PUSH
39515: LD_INT 2
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: NEG
39526: PUSH
39527: LD_INT 3
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39540: LD_ADDR_VAR 0 17
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: LD_INT 3
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: LD_INT 2
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: LIST
39583: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39584: LD_ADDR_VAR 0 18
39588: PUSH
39589: LD_INT 2
39591: PUSH
39592: LD_INT 1
39594: NEG
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 3
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: LIST
39624: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39625: LD_ADDR_VAR 0 19
39629: PUSH
39630: LD_INT 3
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 3
39642: PUSH
39643: LD_INT 3
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: LD_INT 3
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39665: LD_ADDR_VAR 0 20
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 3
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 3
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39706: LD_ADDR_VAR 0 21
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 3
39724: NEG
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 3
39735: NEG
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: LIST
39749: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39750: LD_ADDR_VAR 0 22
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: LD_INT 3
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 3
39769: NEG
39770: PUSH
39771: LD_INT 2
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 3
39781: NEG
39782: PUSH
39783: LD_INT 3
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39796: LD_ADDR_VAR 0 23
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: LD_INT 4
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: LIST
39839: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39840: LD_ADDR_VAR 0 24
39844: PUSH
39845: LD_INT 3
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 3
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 4
39868: PUSH
39869: LD_INT 1
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39881: LD_ADDR_VAR 0 25
39885: PUSH
39886: LD_INT 3
39888: PUSH
39889: LD_INT 3
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 4
39898: PUSH
39899: LD_INT 3
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 3
39908: PUSH
39909: LD_INT 4
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39921: LD_ADDR_VAR 0 26
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: LD_INT 3
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 1
39938: PUSH
39939: LD_INT 4
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 3
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39962: LD_ADDR_VAR 0 27
39966: PUSH
39967: LD_INT 3
39969: NEG
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: NEG
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 4
39991: NEG
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: LIST
40005: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40006: LD_ADDR_VAR 0 28
40010: PUSH
40011: LD_INT 3
40013: NEG
40014: PUSH
40015: LD_INT 3
40017: NEG
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 3
40025: NEG
40026: PUSH
40027: LD_INT 4
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 4
40037: NEG
40038: PUSH
40039: LD_INT 3
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40052: LD_ADDR_VAR 0 29
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: LD_INT 3
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 3
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 1
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 4
40097: NEG
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 4
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: LD_INT 3
40119: NEG
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: LD_INT 1
40127: NEG
40128: PUSH
40129: LD_INT 5
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: LD_INT 5
40142: NEG
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 4
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: LD_INT 6
40165: NEG
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: LD_INT 6
40176: NEG
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 1
40184: PUSH
40185: LD_INT 5
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40207: LD_ADDR_VAR 0 30
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: LD_INT 1
40217: NEG
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 3
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: LD_INT 1
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 4
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 4
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 5
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 5
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 5
40307: PUSH
40308: LD_INT 1
40310: NEG
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 6
40318: PUSH
40319: LD_INT 0
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 6
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40350: LD_ADDR_VAR 0 31
40354: PUSH
40355: LD_INT 3
40357: PUSH
40358: LD_INT 2
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 3
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 2
40377: PUSH
40378: LD_INT 3
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 4
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: LD_INT 4
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: LD_INT 4
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 5
40417: PUSH
40418: LD_INT 4
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 5
40427: PUSH
40428: LD_INT 5
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 4
40437: PUSH
40438: LD_INT 5
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 6
40447: PUSH
40448: LD_INT 5
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 6
40457: PUSH
40458: LD_INT 6
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 5
40467: PUSH
40468: LD_INT 6
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40489: LD_ADDR_VAR 0 32
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: LD_INT 3
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: LD_INT 3
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 1
40516: NEG
40517: PUSH
40518: LD_INT 2
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: PUSH
40528: LD_INT 4
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: LD_INT 4
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 3
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: PUSH
40559: LD_INT 5
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 5
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 1
40578: NEG
40579: PUSH
40580: LD_INT 4
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: LD_INT 6
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: LD_INT 6
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: LD_INT 5
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40632: LD_ADDR_VAR 0 33
40636: PUSH
40637: LD_INT 2
40639: NEG
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 3
40650: NEG
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: NEG
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 3
40673: NEG
40674: PUSH
40675: LD_INT 1
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 4
40684: NEG
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 4
40695: NEG
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 4
40707: NEG
40708: PUSH
40709: LD_INT 1
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 5
40718: NEG
40719: PUSH
40720: LD_INT 0
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 5
40729: NEG
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 5
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 6
40752: NEG
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 6
40763: NEG
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40787: LD_ADDR_VAR 0 34
40791: PUSH
40792: LD_INT 2
40794: NEG
40795: PUSH
40796: LD_INT 3
40798: NEG
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: NEG
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 3
40830: NEG
40831: PUSH
40832: LD_INT 4
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 4
40842: NEG
40843: PUSH
40844: LD_INT 3
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 4
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: LD_INT 5
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 5
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 5
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 5
40902: NEG
40903: PUSH
40904: LD_INT 6
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 6
40914: NEG
40915: PUSH
40916: LD_INT 5
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 6
40926: NEG
40927: PUSH
40928: LD_INT 6
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40950: LD_ADDR_VAR 0 41
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 2
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 3
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: PUSH
40981: LD_INT 2
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: LIST
40993: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40994: LD_ADDR_VAR 0 42
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: LD_INT 0
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: LIST
41034: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41035: LD_ADDR_VAR 0 43
41039: PUSH
41040: LD_INT 2
41042: PUSH
41043: LD_INT 2
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: PUSH
41053: LD_INT 2
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 2
41062: PUSH
41063: LD_INT 3
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41075: LD_ADDR_VAR 0 44
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: LD_INT 2
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: LD_INT 3
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: LIST
41115: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41116: LD_ADDR_VAR 0 45
41120: PUSH
41121: LD_INT 2
41123: NEG
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 2
41134: NEG
41135: PUSH
41136: LD_INT 1
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 3
41145: NEG
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41160: LD_ADDR_VAR 0 46
41164: PUSH
41165: LD_INT 2
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 3
41191: NEG
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: LIST
41205: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41206: LD_ADDR_VAR 0 47
41210: PUSH
41211: LD_INT 2
41213: NEG
41214: PUSH
41215: LD_INT 3
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: NEG
41226: PUSH
41227: LD_INT 3
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41239: LD_ADDR_VAR 0 48
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: LD_INT 2
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41270: LD_ADDR_VAR 0 49
41274: PUSH
41275: LD_INT 3
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: PUSH
41288: LD_INT 2
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41299: LD_ADDR_VAR 0 50
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: PUSH
41317: LD_INT 3
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41328: LD_ADDR_VAR 0 51
41332: PUSH
41333: LD_INT 1
41335: NEG
41336: PUSH
41337: LD_INT 2
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 2
41346: NEG
41347: PUSH
41348: LD_INT 1
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41359: LD_ADDR_VAR 0 52
41363: PUSH
41364: LD_INT 3
41366: NEG
41367: PUSH
41368: LD_INT 1
41370: NEG
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 2
41382: NEG
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41392: LD_ADDR_VAR 0 53
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: LIST
41435: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41436: LD_ADDR_VAR 0 54
41440: PUSH
41441: LD_INT 2
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 3
41454: PUSH
41455: LD_INT 0
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 3
41464: PUSH
41465: LD_INT 1
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: LIST
41476: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41477: LD_ADDR_VAR 0 55
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 3
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: LIST
41516: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41517: LD_ADDR_VAR 0 56
41521: PUSH
41522: LD_INT 1
41524: PUSH
41525: LD_INT 3
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: LD_INT 3
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: LIST
41557: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41558: LD_ADDR_VAR 0 57
41562: PUSH
41563: LD_INT 2
41565: NEG
41566: PUSH
41567: LD_INT 1
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 3
41576: NEG
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 3
41587: NEG
41588: PUSH
41589: LD_INT 1
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: LIST
41601: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41602: LD_ADDR_VAR 0 58
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: LD_INT 3
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 3
41621: NEG
41622: PUSH
41623: LD_INT 2
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 3
41633: NEG
41634: PUSH
41635: LD_INT 3
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: LIST
41647: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41648: LD_ADDR_VAR 0 59
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: LD_INT 2
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 0
41667: PUSH
41668: LD_INT 2
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41692: LD_ADDR_VAR 0 60
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 1
41702: NEG
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 2
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 2
41720: PUSH
41721: LD_INT 1
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41733: LD_ADDR_VAR 0 61
41737: PUSH
41738: LD_INT 2
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 2
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: PUSH
41761: LD_INT 2
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41773: LD_ADDR_VAR 0 62
41777: PUSH
41778: LD_INT 1
41780: PUSH
41781: LD_INT 2
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 1
41800: NEG
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41814: LD_ADDR_VAR 0 63
41818: PUSH
41819: LD_INT 1
41821: NEG
41822: PUSH
41823: LD_INT 1
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 2
41832: NEG
41833: PUSH
41834: LD_INT 0
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 2
41843: NEG
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41858: LD_ADDR_VAR 0 64
41862: PUSH
41863: LD_INT 1
41865: NEG
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 2
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 2
41889: NEG
41890: PUSH
41891: LD_INT 2
41893: NEG
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: LIST
41903: ST_TO_ADDR
// end ; 2 :
41904: GO 45170
41906: LD_INT 2
41908: DOUBLE
41909: EQUAL
41910: IFTRUE 41914
41912: GO 45169
41914: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41915: LD_ADDR_VAR 0 29
41919: PUSH
41920: LD_INT 4
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 4
41932: PUSH
41933: LD_INT 1
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 5
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 5
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 4
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 3
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 3
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 5
42005: PUSH
42006: LD_INT 2
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: PUSH
42016: LD_INT 3
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 3
42025: PUSH
42026: LD_INT 2
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 4
42035: PUSH
42036: LD_INT 3
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: LD_INT 4
42045: PUSH
42046: LD_INT 4
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 3
42055: PUSH
42056: LD_INT 4
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: LD_INT 2
42065: PUSH
42066: LD_INT 3
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 2
42075: PUSH
42076: LD_INT 2
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 4
42085: PUSH
42086: LD_INT 2
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 2
42095: PUSH
42096: LD_INT 4
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 0
42105: PUSH
42106: LD_INT 4
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 0
42115: PUSH
42116: LD_INT 3
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: LD_INT 4
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 5
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: LD_INT 5
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: LD_INT 4
42159: PUSH
42160: EMPTY
42161: LIST
42162: LIST
42163: PUSH
42164: LD_INT 1
42166: NEG
42167: PUSH
42168: LD_INT 3
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 2
42177: PUSH
42178: LD_INT 5
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 2
42187: NEG
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: NEG
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 3
42209: NEG
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 2
42221: NEG
42222: PUSH
42223: LD_INT 0
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 2
42232: NEG
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: LD_INT 1
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 4
42254: NEG
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 4
42265: NEG
42266: PUSH
42267: LD_INT 1
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 4
42277: NEG
42278: PUSH
42279: LD_INT 2
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 2
42289: NEG
42290: PUSH
42291: LD_INT 2
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 4
42300: NEG
42301: PUSH
42302: LD_INT 4
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 5
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: LD_INT 4
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 3
42336: NEG
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 4
42348: NEG
42349: PUSH
42350: LD_INT 3
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 5
42360: NEG
42361: PUSH
42362: LD_INT 4
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 5
42372: NEG
42373: PUSH
42374: LD_INT 5
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 3
42384: NEG
42385: PUSH
42386: LD_INT 5
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 5
42396: NEG
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: LIST
42427: LIST
42428: LIST
42429: LIST
42430: LIST
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42453: LD_ADDR_VAR 0 30
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 4
42470: PUSH
42471: LD_INT 3
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 5
42480: PUSH
42481: LD_INT 4
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 5
42490: PUSH
42491: LD_INT 5
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 4
42500: PUSH
42501: LD_INT 5
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 3
42510: PUSH
42511: LD_INT 4
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: LD_INT 3
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 5
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 3
42540: PUSH
42541: LD_INT 5
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 0
42560: PUSH
42561: LD_INT 2
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 1
42570: PUSH
42571: LD_INT 3
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 1
42580: PUSH
42581: LD_INT 4
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 1
42600: NEG
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 1
42611: NEG
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 2
42622: PUSH
42623: LD_INT 4
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 2
42632: NEG
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 4
42643: NEG
42644: PUSH
42645: LD_INT 0
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 4
42654: NEG
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 3
42666: NEG
42667: PUSH
42668: LD_INT 0
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 3
42677: NEG
42678: PUSH
42679: LD_INT 1
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: NEG
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 5
42699: NEG
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: NEG
42711: PUSH
42712: LD_INT 1
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 5
42722: NEG
42723: PUSH
42724: LD_INT 2
42726: NEG
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: LD_INT 2
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 3
42745: NEG
42746: PUSH
42747: LD_INT 3
42749: NEG
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: NEG
42758: PUSH
42759: LD_INT 4
42761: NEG
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 2
42769: NEG
42770: PUSH
42771: LD_INT 3
42773: NEG
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 2
42781: NEG
42782: PUSH
42783: LD_INT 2
42785: NEG
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PUSH
42791: LD_INT 3
42793: NEG
42794: PUSH
42795: LD_INT 2
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 4
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 4
42817: NEG
42818: PUSH
42819: LD_INT 4
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: NEG
42830: PUSH
42831: LD_INT 4
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 4
42841: NEG
42842: PUSH
42843: LD_INT 2
42845: NEG
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: LD_INT 4
42856: NEG
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 0
42864: PUSH
42865: LD_INT 5
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 1
42875: PUSH
42876: LD_INT 4
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 1
42886: PUSH
42887: LD_INT 3
42889: NEG
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: LD_INT 3
42900: NEG
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 1
42908: NEG
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: LD_INT 5
42924: NEG
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 2
42932: PUSH
42933: LD_INT 3
42935: NEG
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 2
42943: NEG
42944: PUSH
42945: LD_INT 5
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43000: LD_ADDR_VAR 0 31
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 4
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 0
43017: PUSH
43018: LD_INT 3
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 1
43027: PUSH
43028: LD_INT 4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 1
43037: PUSH
43038: LD_INT 5
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: LD_INT 5
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: LD_INT 4
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 1
43068: NEG
43069: PUSH
43070: LD_INT 3
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 5
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: LD_INT 3
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 3
43100: NEG
43101: PUSH
43102: LD_INT 0
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: LD_INT 3
43111: NEG
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 2
43123: NEG
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 2
43134: NEG
43135: PUSH
43136: LD_INT 1
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 3
43145: NEG
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: NEG
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 4
43167: NEG
43168: PUSH
43169: LD_INT 1
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 4
43179: NEG
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: NEG
43192: PUSH
43193: LD_INT 2
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: LD_INT 4
43202: NEG
43203: PUSH
43204: LD_INT 4
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 5
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 3
43226: NEG
43227: PUSH
43228: LD_INT 4
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 3
43242: NEG
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 4
43250: NEG
43251: PUSH
43252: LD_INT 3
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 5
43262: NEG
43263: PUSH
43264: LD_INT 4
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 5
43274: NEG
43275: PUSH
43276: LD_INT 5
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 3
43286: NEG
43287: PUSH
43288: LD_INT 5
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 5
43298: NEG
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 0
43310: PUSH
43311: LD_INT 3
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 0
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 3
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: NEG
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 0
43354: PUSH
43355: LD_INT 2
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 1
43365: NEG
43366: PUSH
43367: LD_INT 3
43369: NEG
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 1
43377: NEG
43378: PUSH
43379: LD_INT 4
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: LD_INT 2
43392: NEG
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: NEG
43401: PUSH
43402: LD_INT 4
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 4
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: PUSH
43423: LD_INT 1
43425: NEG
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 5
43433: PUSH
43434: LD_INT 0
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 5
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 4
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 3
43473: PUSH
43474: LD_INT 1
43476: NEG
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: LD_INT 2
43487: NEG
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 5
43495: PUSH
43496: LD_INT 2
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: LIST
43508: LIST
43509: LIST
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43550: LD_ADDR_VAR 0 32
43554: PUSH
43555: LD_INT 4
43557: NEG
43558: PUSH
43559: LD_INT 0
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 4
43568: NEG
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 3
43580: NEG
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 3
43591: NEG
43592: PUSH
43593: LD_INT 1
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 4
43602: NEG
43603: PUSH
43604: LD_INT 1
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 5
43613: NEG
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 5
43624: NEG
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 5
43636: NEG
43637: PUSH
43638: LD_INT 2
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 3
43648: NEG
43649: PUSH
43650: LD_INT 2
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 3
43659: NEG
43660: PUSH
43661: LD_INT 3
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: LD_INT 4
43675: NEG
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 2
43683: NEG
43684: PUSH
43685: LD_INT 3
43687: NEG
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 2
43695: NEG
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 3
43707: NEG
43708: PUSH
43709: LD_INT 2
43711: NEG
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 4
43719: NEG
43720: PUSH
43721: LD_INT 3
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 4
43731: NEG
43732: PUSH
43733: LD_INT 4
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 2
43743: NEG
43744: PUSH
43745: LD_INT 4
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 4
43755: NEG
43756: PUSH
43757: LD_INT 2
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 0
43767: PUSH
43768: LD_INT 4
43770: NEG
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 0
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 1
43789: PUSH
43790: LD_INT 4
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 1
43800: PUSH
43801: LD_INT 3
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 0
43811: PUSH
43812: LD_INT 3
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 1
43822: NEG
43823: PUSH
43824: LD_INT 4
43826: NEG
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 1
43834: NEG
43835: PUSH
43836: LD_INT 5
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 2
43846: PUSH
43847: LD_INT 3
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 5
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 3
43869: PUSH
43870: LD_INT 0
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 4
43890: PUSH
43891: LD_INT 0
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 4
43900: PUSH
43901: LD_INT 1
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 3
43910: PUSH
43911: LD_INT 1
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 2
43920: PUSH
43921: LD_INT 0
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 2
43930: PUSH
43931: LD_INT 1
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 2
43941: PUSH
43942: LD_INT 2
43944: NEG
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 4
43952: PUSH
43953: LD_INT 2
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: LD_INT 4
43962: PUSH
43963: LD_INT 4
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 4
43972: PUSH
43973: LD_INT 3
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 5
43982: PUSH
43983: LD_INT 4
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 5
43992: PUSH
43993: LD_INT 5
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: LD_INT 5
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 3
44012: PUSH
44013: LD_INT 4
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 3
44022: PUSH
44023: LD_INT 3
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 5
44032: PUSH
44033: LD_INT 3
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 3
44042: PUSH
44043: LD_INT 5
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44097: LD_ADDR_VAR 0 33
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: LD_INT 4
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 5
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 3
44128: NEG
44129: PUSH
44130: LD_INT 4
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 3
44140: NEG
44141: PUSH
44142: LD_INT 3
44144: NEG
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 4
44152: NEG
44153: PUSH
44154: LD_INT 3
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 5
44164: NEG
44165: PUSH
44166: LD_INT 4
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: LD_INT 5
44180: NEG
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 3
44188: NEG
44189: PUSH
44190: LD_INT 5
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 5
44200: NEG
44201: PUSH
44202: LD_INT 3
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 3
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 0
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 1
44234: PUSH
44235: LD_INT 3
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: PUSH
44246: LD_INT 2
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 0
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 1
44267: NEG
44268: PUSH
44269: LD_INT 3
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 1
44279: NEG
44280: PUSH
44281: LD_INT 4
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: LD_INT 4
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 4
44324: PUSH
44325: LD_INT 1
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 5
44335: PUSH
44336: LD_INT 0
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 5
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 4
44355: PUSH
44356: LD_INT 1
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 3
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 3
44375: PUSH
44376: LD_INT 1
44378: NEG
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 3
44386: PUSH
44387: LD_INT 2
44389: NEG
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 5
44397: PUSH
44398: LD_INT 2
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 3
44407: PUSH
44408: LD_INT 3
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 3
44417: PUSH
44418: LD_INT 2
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: PUSH
44428: LD_INT 3
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 4
44437: PUSH
44438: LD_INT 4
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 3
44447: PUSH
44448: LD_INT 4
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 2
44457: PUSH
44458: LD_INT 3
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 2
44467: PUSH
44468: LD_INT 2
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 4
44477: PUSH
44478: LD_INT 2
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 2
44487: PUSH
44488: LD_INT 4
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 0
44497: PUSH
44498: LD_INT 4
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 0
44507: PUSH
44508: LD_INT 3
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 1
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 1
44527: PUSH
44528: LD_INT 5
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: LD_INT 5
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: LD_INT 4
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 1
44558: NEG
44559: PUSH
44560: LD_INT 3
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 2
44569: PUSH
44570: LD_INT 5
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 2
44579: NEG
44580: PUSH
44581: LD_INT 3
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44635: LD_ADDR_VAR 0 34
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 4
44645: NEG
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 0
44653: PUSH
44654: LD_INT 5
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 1
44664: PUSH
44665: LD_INT 4
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 1
44675: PUSH
44676: LD_INT 3
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: LD_INT 3
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: LD_INT 5
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 2
44721: PUSH
44722: LD_INT 3
44724: NEG
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 2
44732: NEG
44733: PUSH
44734: LD_INT 5
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 0
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 3
44754: PUSH
44755: LD_INT 1
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 4
44775: PUSH
44776: LD_INT 1
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: LD_INT 1
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 2
44795: PUSH
44796: LD_INT 0
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: LD_INT 1
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 2
44816: PUSH
44817: LD_INT 2
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 4
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 4
44837: PUSH
44838: LD_INT 4
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 4
44847: PUSH
44848: LD_INT 3
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 5
44857: PUSH
44858: LD_INT 4
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 5
44867: PUSH
44868: LD_INT 5
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: LD_INT 5
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: LD_INT 4
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 3
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: PUSH
44908: LD_INT 3
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 3
44917: PUSH
44918: LD_INT 5
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: LD_INT 3
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 2
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 1
44947: PUSH
44948: LD_INT 3
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 4
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: LD_INT 4
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 1
44977: NEG
44978: PUSH
44979: LD_INT 3
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 2
44999: PUSH
45000: LD_INT 4
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 2
45009: NEG
45010: PUSH
45011: LD_INT 2
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 4
45020: NEG
45021: PUSH
45022: LD_INT 0
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 4
45031: NEG
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 3
45043: NEG
45044: PUSH
45045: LD_INT 0
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 3
45054: NEG
45055: PUSH
45056: LD_INT 1
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 4
45065: NEG
45066: PUSH
45067: LD_INT 1
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 5
45076: NEG
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 5
45087: NEG
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 5
45099: NEG
45100: PUSH
45101: LD_INT 2
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 3
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: ST_TO_ADDR
// end ; end ;
45167: GO 45170
45169: POP
// case btype of b_depot , b_warehouse :
45170: LD_VAR 0 1
45174: PUSH
45175: LD_INT 0
45177: DOUBLE
45178: EQUAL
45179: IFTRUE 45189
45181: LD_INT 1
45183: DOUBLE
45184: EQUAL
45185: IFTRUE 45189
45187: GO 45390
45189: POP
// case nation of nation_american :
45190: LD_VAR 0 5
45194: PUSH
45195: LD_INT 1
45197: DOUBLE
45198: EQUAL
45199: IFTRUE 45203
45201: GO 45259
45203: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
45204: LD_ADDR_VAR 0 9
45208: PUSH
45209: LD_VAR 0 11
45213: PUSH
45214: LD_VAR 0 12
45218: PUSH
45219: LD_VAR 0 13
45223: PUSH
45224: LD_VAR 0 14
45228: PUSH
45229: LD_VAR 0 15
45233: PUSH
45234: LD_VAR 0 16
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: PUSH
45247: LD_VAR 0 4
45251: PUSH
45252: LD_INT 1
45254: PLUS
45255: ARRAY
45256: ST_TO_ADDR
45257: GO 45388
45259: LD_INT 2
45261: DOUBLE
45262: EQUAL
45263: IFTRUE 45267
45265: GO 45323
45267: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
45268: LD_ADDR_VAR 0 9
45272: PUSH
45273: LD_VAR 0 17
45277: PUSH
45278: LD_VAR 0 18
45282: PUSH
45283: LD_VAR 0 19
45287: PUSH
45288: LD_VAR 0 20
45292: PUSH
45293: LD_VAR 0 21
45297: PUSH
45298: LD_VAR 0 22
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: PUSH
45311: LD_VAR 0 4
45315: PUSH
45316: LD_INT 1
45318: PLUS
45319: ARRAY
45320: ST_TO_ADDR
45321: GO 45388
45323: LD_INT 3
45325: DOUBLE
45326: EQUAL
45327: IFTRUE 45331
45329: GO 45387
45331: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45332: LD_ADDR_VAR 0 9
45336: PUSH
45337: LD_VAR 0 23
45341: PUSH
45342: LD_VAR 0 24
45346: PUSH
45347: LD_VAR 0 25
45351: PUSH
45352: LD_VAR 0 26
45356: PUSH
45357: LD_VAR 0 27
45361: PUSH
45362: LD_VAR 0 28
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: PUSH
45375: LD_VAR 0 4
45379: PUSH
45380: LD_INT 1
45382: PLUS
45383: ARRAY
45384: ST_TO_ADDR
45385: GO 45388
45387: POP
45388: GO 45943
45390: LD_INT 2
45392: DOUBLE
45393: EQUAL
45394: IFTRUE 45404
45396: LD_INT 3
45398: DOUBLE
45399: EQUAL
45400: IFTRUE 45404
45402: GO 45460
45404: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45405: LD_ADDR_VAR 0 9
45409: PUSH
45410: LD_VAR 0 29
45414: PUSH
45415: LD_VAR 0 30
45419: PUSH
45420: LD_VAR 0 31
45424: PUSH
45425: LD_VAR 0 32
45429: PUSH
45430: LD_VAR 0 33
45434: PUSH
45435: LD_VAR 0 34
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: PUSH
45448: LD_VAR 0 4
45452: PUSH
45453: LD_INT 1
45455: PLUS
45456: ARRAY
45457: ST_TO_ADDR
45458: GO 45943
45460: LD_INT 16
45462: DOUBLE
45463: EQUAL
45464: IFTRUE 45522
45466: LD_INT 17
45468: DOUBLE
45469: EQUAL
45470: IFTRUE 45522
45472: LD_INT 18
45474: DOUBLE
45475: EQUAL
45476: IFTRUE 45522
45478: LD_INT 19
45480: DOUBLE
45481: EQUAL
45482: IFTRUE 45522
45484: LD_INT 22
45486: DOUBLE
45487: EQUAL
45488: IFTRUE 45522
45490: LD_INT 20
45492: DOUBLE
45493: EQUAL
45494: IFTRUE 45522
45496: LD_INT 21
45498: DOUBLE
45499: EQUAL
45500: IFTRUE 45522
45502: LD_INT 23
45504: DOUBLE
45505: EQUAL
45506: IFTRUE 45522
45508: LD_INT 24
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45522
45514: LD_INT 25
45516: DOUBLE
45517: EQUAL
45518: IFTRUE 45522
45520: GO 45578
45522: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45523: LD_ADDR_VAR 0 9
45527: PUSH
45528: LD_VAR 0 35
45532: PUSH
45533: LD_VAR 0 36
45537: PUSH
45538: LD_VAR 0 37
45542: PUSH
45543: LD_VAR 0 38
45547: PUSH
45548: LD_VAR 0 39
45552: PUSH
45553: LD_VAR 0 40
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: PUSH
45566: LD_VAR 0 4
45570: PUSH
45571: LD_INT 1
45573: PLUS
45574: ARRAY
45575: ST_TO_ADDR
45576: GO 45943
45578: LD_INT 6
45580: DOUBLE
45581: EQUAL
45582: IFTRUE 45634
45584: LD_INT 7
45586: DOUBLE
45587: EQUAL
45588: IFTRUE 45634
45590: LD_INT 8
45592: DOUBLE
45593: EQUAL
45594: IFTRUE 45634
45596: LD_INT 13
45598: DOUBLE
45599: EQUAL
45600: IFTRUE 45634
45602: LD_INT 12
45604: DOUBLE
45605: EQUAL
45606: IFTRUE 45634
45608: LD_INT 15
45610: DOUBLE
45611: EQUAL
45612: IFTRUE 45634
45614: LD_INT 11
45616: DOUBLE
45617: EQUAL
45618: IFTRUE 45634
45620: LD_INT 14
45622: DOUBLE
45623: EQUAL
45624: IFTRUE 45634
45626: LD_INT 10
45628: DOUBLE
45629: EQUAL
45630: IFTRUE 45634
45632: GO 45690
45634: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
45635: LD_ADDR_VAR 0 9
45639: PUSH
45640: LD_VAR 0 41
45644: PUSH
45645: LD_VAR 0 42
45649: PUSH
45650: LD_VAR 0 43
45654: PUSH
45655: LD_VAR 0 44
45659: PUSH
45660: LD_VAR 0 45
45664: PUSH
45665: LD_VAR 0 46
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: PUSH
45678: LD_VAR 0 4
45682: PUSH
45683: LD_INT 1
45685: PLUS
45686: ARRAY
45687: ST_TO_ADDR
45688: GO 45943
45690: LD_INT 36
45692: DOUBLE
45693: EQUAL
45694: IFTRUE 45698
45696: GO 45754
45698: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45699: LD_ADDR_VAR 0 9
45703: PUSH
45704: LD_VAR 0 47
45708: PUSH
45709: LD_VAR 0 48
45713: PUSH
45714: LD_VAR 0 49
45718: PUSH
45719: LD_VAR 0 50
45723: PUSH
45724: LD_VAR 0 51
45728: PUSH
45729: LD_VAR 0 52
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: PUSH
45742: LD_VAR 0 4
45746: PUSH
45747: LD_INT 1
45749: PLUS
45750: ARRAY
45751: ST_TO_ADDR
45752: GO 45943
45754: LD_INT 4
45756: DOUBLE
45757: EQUAL
45758: IFTRUE 45780
45760: LD_INT 5
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45780
45766: LD_INT 34
45768: DOUBLE
45769: EQUAL
45770: IFTRUE 45780
45772: LD_INT 37
45774: DOUBLE
45775: EQUAL
45776: IFTRUE 45780
45778: GO 45836
45780: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45781: LD_ADDR_VAR 0 9
45785: PUSH
45786: LD_VAR 0 53
45790: PUSH
45791: LD_VAR 0 54
45795: PUSH
45796: LD_VAR 0 55
45800: PUSH
45801: LD_VAR 0 56
45805: PUSH
45806: LD_VAR 0 57
45810: PUSH
45811: LD_VAR 0 58
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: PUSH
45824: LD_VAR 0 4
45828: PUSH
45829: LD_INT 1
45831: PLUS
45832: ARRAY
45833: ST_TO_ADDR
45834: GO 45943
45836: LD_INT 31
45838: DOUBLE
45839: EQUAL
45840: IFTRUE 45886
45842: LD_INT 32
45844: DOUBLE
45845: EQUAL
45846: IFTRUE 45886
45848: LD_INT 33
45850: DOUBLE
45851: EQUAL
45852: IFTRUE 45886
45854: LD_INT 27
45856: DOUBLE
45857: EQUAL
45858: IFTRUE 45886
45860: LD_INT 26
45862: DOUBLE
45863: EQUAL
45864: IFTRUE 45886
45866: LD_INT 28
45868: DOUBLE
45869: EQUAL
45870: IFTRUE 45886
45872: LD_INT 29
45874: DOUBLE
45875: EQUAL
45876: IFTRUE 45886
45878: LD_INT 30
45880: DOUBLE
45881: EQUAL
45882: IFTRUE 45886
45884: GO 45942
45886: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
45887: LD_ADDR_VAR 0 9
45891: PUSH
45892: LD_VAR 0 59
45896: PUSH
45897: LD_VAR 0 60
45901: PUSH
45902: LD_VAR 0 61
45906: PUSH
45907: LD_VAR 0 62
45911: PUSH
45912: LD_VAR 0 63
45916: PUSH
45917: LD_VAR 0 64
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: PUSH
45930: LD_VAR 0 4
45934: PUSH
45935: LD_INT 1
45937: PLUS
45938: ARRAY
45939: ST_TO_ADDR
45940: GO 45943
45942: POP
// temp_list2 = [ ] ;
45943: LD_ADDR_VAR 0 10
45947: PUSH
45948: EMPTY
45949: ST_TO_ADDR
// for i in temp_list do
45950: LD_ADDR_VAR 0 8
45954: PUSH
45955: LD_VAR 0 9
45959: PUSH
45960: FOR_IN
45961: IFFALSE 46013
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45963: LD_ADDR_VAR 0 10
45967: PUSH
45968: LD_VAR 0 10
45972: PUSH
45973: LD_VAR 0 8
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PUSH
45982: LD_VAR 0 2
45986: PLUS
45987: PUSH
45988: LD_VAR 0 8
45992: PUSH
45993: LD_INT 2
45995: ARRAY
45996: PUSH
45997: LD_VAR 0 3
46001: PLUS
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: EMPTY
46008: LIST
46009: ADD
46010: ST_TO_ADDR
46011: GO 45960
46013: POP
46014: POP
// result = temp_list2 ;
46015: LD_ADDR_VAR 0 7
46019: PUSH
46020: LD_VAR 0 10
46024: ST_TO_ADDR
// end ;
46025: LD_VAR 0 7
46029: RET
// export function EnemyInRange ( unit , dist ) ; begin
46030: LD_INT 0
46032: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46033: LD_ADDR_VAR 0 3
46037: PUSH
46038: LD_VAR 0 1
46042: PPUSH
46043: CALL_OW 255
46047: PPUSH
46048: LD_VAR 0 1
46052: PPUSH
46053: CALL_OW 250
46057: PPUSH
46058: LD_VAR 0 1
46062: PPUSH
46063: CALL_OW 251
46067: PPUSH
46068: LD_VAR 0 2
46072: PPUSH
46073: CALL 20134 0 4
46077: PUSH
46078: LD_INT 4
46080: ARRAY
46081: ST_TO_ADDR
// end ;
46082: LD_VAR 0 3
46086: RET
// export function PlayerSeeMe ( unit ) ; begin
46087: LD_INT 0
46089: PPUSH
// result := See ( your_side , unit ) ;
46090: LD_ADDR_VAR 0 2
46094: PUSH
46095: LD_OWVAR 2
46099: PPUSH
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 292
46109: ST_TO_ADDR
// end ;
46110: LD_VAR 0 2
46114: RET
// export function ReverseDir ( unit ) ; begin
46115: LD_INT 0
46117: PPUSH
// if not unit then
46118: LD_VAR 0 1
46122: NOT
46123: IFFALSE 46127
// exit ;
46125: GO 46150
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46127: LD_ADDR_VAR 0 2
46131: PUSH
46132: LD_VAR 0 1
46136: PPUSH
46137: CALL_OW 254
46141: PUSH
46142: LD_INT 3
46144: PLUS
46145: PUSH
46146: LD_INT 6
46148: MOD
46149: ST_TO_ADDR
// end ;
46150: LD_VAR 0 2
46154: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46155: LD_INT 0
46157: PPUSH
46158: PPUSH
46159: PPUSH
46160: PPUSH
46161: PPUSH
// if not hexes then
46162: LD_VAR 0 2
46166: NOT
46167: IFFALSE 46171
// exit ;
46169: GO 46319
// dist := 9999 ;
46171: LD_ADDR_VAR 0 5
46175: PUSH
46176: LD_INT 9999
46178: ST_TO_ADDR
// for i = 1 to hexes do
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: DOUBLE
46185: LD_INT 1
46187: DEC
46188: ST_TO_ADDR
46189: LD_VAR 0 2
46193: PUSH
46194: FOR_TO
46195: IFFALSE 46307
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46197: LD_VAR 0 1
46201: PPUSH
46202: LD_VAR 0 2
46206: PUSH
46207: LD_VAR 0 4
46211: ARRAY
46212: PUSH
46213: LD_INT 1
46215: ARRAY
46216: PPUSH
46217: LD_VAR 0 2
46221: PUSH
46222: LD_VAR 0 4
46226: ARRAY
46227: PUSH
46228: LD_INT 2
46230: ARRAY
46231: PPUSH
46232: CALL_OW 297
46236: PUSH
46237: LD_VAR 0 5
46241: LESS
46242: IFFALSE 46305
// begin hex := hexes [ i ] ;
46244: LD_ADDR_VAR 0 7
46248: PUSH
46249: LD_VAR 0 2
46253: PUSH
46254: LD_VAR 0 4
46258: ARRAY
46259: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46260: LD_ADDR_VAR 0 5
46264: PUSH
46265: LD_VAR 0 1
46269: PPUSH
46270: LD_VAR 0 2
46274: PUSH
46275: LD_VAR 0 4
46279: ARRAY
46280: PUSH
46281: LD_INT 1
46283: ARRAY
46284: PPUSH
46285: LD_VAR 0 2
46289: PUSH
46290: LD_VAR 0 4
46294: ARRAY
46295: PUSH
46296: LD_INT 2
46298: ARRAY
46299: PPUSH
46300: CALL_OW 297
46304: ST_TO_ADDR
// end ; end ;
46305: GO 46194
46307: POP
46308: POP
// result := hex ;
46309: LD_ADDR_VAR 0 3
46313: PUSH
46314: LD_VAR 0 7
46318: ST_TO_ADDR
// end ;
46319: LD_VAR 0 3
46323: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46324: LD_INT 0
46326: PPUSH
46327: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46328: LD_VAR 0 1
46332: NOT
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_INT 21
46341: PUSH
46342: LD_INT 2
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 23
46351: PUSH
46352: LD_INT 2
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PPUSH
46363: CALL_OW 69
46367: IN
46368: NOT
46369: OR
46370: IFFALSE 46374
// exit ;
46372: GO 46421
// for i = 1 to 3 do
46374: LD_ADDR_VAR 0 3
46378: PUSH
46379: DOUBLE
46380: LD_INT 1
46382: DEC
46383: ST_TO_ADDR
46384: LD_INT 3
46386: PUSH
46387: FOR_TO
46388: IFFALSE 46419
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46390: LD_VAR 0 1
46394: PPUSH
46395: CALL_OW 250
46399: PPUSH
46400: LD_VAR 0 1
46404: PPUSH
46405: CALL_OW 251
46409: PPUSH
46410: LD_INT 1
46412: PPUSH
46413: CALL_OW 453
46417: GO 46387
46419: POP
46420: POP
// end ;
46421: LD_VAR 0 2
46425: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46426: LD_INT 0
46428: PPUSH
46429: PPUSH
46430: PPUSH
46431: PPUSH
46432: PPUSH
46433: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46434: LD_VAR 0 1
46438: NOT
46439: PUSH
46440: LD_VAR 0 2
46444: NOT
46445: OR
46446: PUSH
46447: LD_VAR 0 1
46451: PPUSH
46452: CALL_OW 314
46456: OR
46457: IFFALSE 46461
// exit ;
46459: GO 46902
// x := GetX ( enemy_unit ) ;
46461: LD_ADDR_VAR 0 7
46465: PUSH
46466: LD_VAR 0 2
46470: PPUSH
46471: CALL_OW 250
46475: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46476: LD_ADDR_VAR 0 8
46480: PUSH
46481: LD_VAR 0 2
46485: PPUSH
46486: CALL_OW 251
46490: ST_TO_ADDR
// if not x or not y then
46491: LD_VAR 0 7
46495: NOT
46496: PUSH
46497: LD_VAR 0 8
46501: NOT
46502: OR
46503: IFFALSE 46507
// exit ;
46505: GO 46902
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46507: LD_ADDR_VAR 0 6
46511: PUSH
46512: LD_VAR 0 7
46516: PPUSH
46517: LD_INT 0
46519: PPUSH
46520: LD_INT 4
46522: PPUSH
46523: CALL_OW 272
46527: PUSH
46528: LD_VAR 0 8
46532: PPUSH
46533: LD_INT 0
46535: PPUSH
46536: LD_INT 4
46538: PPUSH
46539: CALL_OW 273
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_VAR 0 7
46552: PPUSH
46553: LD_INT 1
46555: PPUSH
46556: LD_INT 4
46558: PPUSH
46559: CALL_OW 272
46563: PUSH
46564: LD_VAR 0 8
46568: PPUSH
46569: LD_INT 1
46571: PPUSH
46572: LD_INT 4
46574: PPUSH
46575: CALL_OW 273
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_VAR 0 7
46588: PPUSH
46589: LD_INT 2
46591: PPUSH
46592: LD_INT 4
46594: PPUSH
46595: CALL_OW 272
46599: PUSH
46600: LD_VAR 0 8
46604: PPUSH
46605: LD_INT 2
46607: PPUSH
46608: LD_INT 4
46610: PPUSH
46611: CALL_OW 273
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_VAR 0 7
46624: PPUSH
46625: LD_INT 3
46627: PPUSH
46628: LD_INT 4
46630: PPUSH
46631: CALL_OW 272
46635: PUSH
46636: LD_VAR 0 8
46640: PPUSH
46641: LD_INT 3
46643: PPUSH
46644: LD_INT 4
46646: PPUSH
46647: CALL_OW 273
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 7
46660: PPUSH
46661: LD_INT 4
46663: PPUSH
46664: LD_INT 4
46666: PPUSH
46667: CALL_OW 272
46671: PUSH
46672: LD_VAR 0 8
46676: PPUSH
46677: LD_INT 4
46679: PPUSH
46680: LD_INT 4
46682: PPUSH
46683: CALL_OW 273
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_VAR 0 7
46696: PPUSH
46697: LD_INT 5
46699: PPUSH
46700: LD_INT 4
46702: PPUSH
46703: CALL_OW 272
46707: PUSH
46708: LD_VAR 0 8
46712: PPUSH
46713: LD_INT 5
46715: PPUSH
46716: LD_INT 4
46718: PPUSH
46719: CALL_OW 273
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: ST_TO_ADDR
// for i = tmp downto 1 do
46736: LD_ADDR_VAR 0 4
46740: PUSH
46741: DOUBLE
46742: LD_VAR 0 6
46746: INC
46747: ST_TO_ADDR
46748: LD_INT 1
46750: PUSH
46751: FOR_DOWNTO
46752: IFFALSE 46853
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46754: LD_VAR 0 6
46758: PUSH
46759: LD_VAR 0 4
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: ARRAY
46768: PPUSH
46769: LD_VAR 0 6
46773: PUSH
46774: LD_VAR 0 4
46778: ARRAY
46779: PUSH
46780: LD_INT 2
46782: ARRAY
46783: PPUSH
46784: CALL_OW 488
46788: NOT
46789: PUSH
46790: LD_VAR 0 6
46794: PUSH
46795: LD_VAR 0 4
46799: ARRAY
46800: PUSH
46801: LD_INT 1
46803: ARRAY
46804: PPUSH
46805: LD_VAR 0 6
46809: PUSH
46810: LD_VAR 0 4
46814: ARRAY
46815: PUSH
46816: LD_INT 2
46818: ARRAY
46819: PPUSH
46820: CALL_OW 428
46824: PUSH
46825: LD_INT 0
46827: NONEQUAL
46828: OR
46829: IFFALSE 46851
// tmp := Delete ( tmp , i ) ;
46831: LD_ADDR_VAR 0 6
46835: PUSH
46836: LD_VAR 0 6
46840: PPUSH
46841: LD_VAR 0 4
46845: PPUSH
46846: CALL_OW 3
46850: ST_TO_ADDR
46851: GO 46751
46853: POP
46854: POP
// j := GetClosestHex ( unit , tmp ) ;
46855: LD_ADDR_VAR 0 5
46859: PUSH
46860: LD_VAR 0 1
46864: PPUSH
46865: LD_VAR 0 6
46869: PPUSH
46870: CALL 46155 0 2
46874: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46875: LD_VAR 0 1
46879: PPUSH
46880: LD_VAR 0 5
46884: PUSH
46885: LD_INT 1
46887: ARRAY
46888: PPUSH
46889: LD_VAR 0 5
46893: PUSH
46894: LD_INT 2
46896: ARRAY
46897: PPUSH
46898: CALL_OW 111
// end ;
46902: LD_VAR 0 3
46906: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46907: LD_INT 0
46909: PPUSH
46910: PPUSH
46911: PPUSH
// uc_side = 0 ;
46912: LD_ADDR_OWVAR 20
46916: PUSH
46917: LD_INT 0
46919: ST_TO_ADDR
// uc_nation = 0 ;
46920: LD_ADDR_OWVAR 21
46924: PUSH
46925: LD_INT 0
46927: ST_TO_ADDR
// InitHc ;
46928: CALL_OW 19
// InitVc ;
46932: CALL_OW 20
// if mastodonts then
46936: LD_VAR 0 6
46940: IFFALSE 47007
// for i = 1 to mastodonts do
46942: LD_ADDR_VAR 0 11
46946: PUSH
46947: DOUBLE
46948: LD_INT 1
46950: DEC
46951: ST_TO_ADDR
46952: LD_VAR 0 6
46956: PUSH
46957: FOR_TO
46958: IFFALSE 47005
// begin vc_chassis := 31 ;
46960: LD_ADDR_OWVAR 37
46964: PUSH
46965: LD_INT 31
46967: ST_TO_ADDR
// vc_control := control_rider ;
46968: LD_ADDR_OWVAR 38
46972: PUSH
46973: LD_INT 4
46975: ST_TO_ADDR
// animal := CreateVehicle ;
46976: LD_ADDR_VAR 0 12
46980: PUSH
46981: CALL_OW 45
46985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46986: LD_VAR 0 12
46990: PPUSH
46991: LD_VAR 0 8
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL 49076 0 3
// end ;
47003: GO 46957
47005: POP
47006: POP
// if horses then
47007: LD_VAR 0 5
47011: IFFALSE 47078
// for i = 1 to horses do
47013: LD_ADDR_VAR 0 11
47017: PUSH
47018: DOUBLE
47019: LD_INT 1
47021: DEC
47022: ST_TO_ADDR
47023: LD_VAR 0 5
47027: PUSH
47028: FOR_TO
47029: IFFALSE 47076
// begin hc_class := 21 ;
47031: LD_ADDR_OWVAR 28
47035: PUSH
47036: LD_INT 21
47038: ST_TO_ADDR
// hc_gallery :=  ;
47039: LD_ADDR_OWVAR 33
47043: PUSH
47044: LD_STRING 
47046: ST_TO_ADDR
// animal := CreateHuman ;
47047: LD_ADDR_VAR 0 12
47051: PUSH
47052: CALL_OW 44
47056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47057: LD_VAR 0 12
47061: PPUSH
47062: LD_VAR 0 8
47066: PPUSH
47067: LD_INT 0
47069: PPUSH
47070: CALL 49076 0 3
// end ;
47074: GO 47028
47076: POP
47077: POP
// if birds then
47078: LD_VAR 0 1
47082: IFFALSE 47149
// for i = 1 to birds do
47084: LD_ADDR_VAR 0 11
47088: PUSH
47089: DOUBLE
47090: LD_INT 1
47092: DEC
47093: ST_TO_ADDR
47094: LD_VAR 0 1
47098: PUSH
47099: FOR_TO
47100: IFFALSE 47147
// begin hc_class = 18 ;
47102: LD_ADDR_OWVAR 28
47106: PUSH
47107: LD_INT 18
47109: ST_TO_ADDR
// hc_gallery =  ;
47110: LD_ADDR_OWVAR 33
47114: PUSH
47115: LD_STRING 
47117: ST_TO_ADDR
// animal := CreateHuman ;
47118: LD_ADDR_VAR 0 12
47122: PUSH
47123: CALL_OW 44
47127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47128: LD_VAR 0 12
47132: PPUSH
47133: LD_VAR 0 8
47137: PPUSH
47138: LD_INT 0
47140: PPUSH
47141: CALL 49076 0 3
// end ;
47145: GO 47099
47147: POP
47148: POP
// if tigers then
47149: LD_VAR 0 2
47153: IFFALSE 47237
// for i = 1 to tigers do
47155: LD_ADDR_VAR 0 11
47159: PUSH
47160: DOUBLE
47161: LD_INT 1
47163: DEC
47164: ST_TO_ADDR
47165: LD_VAR 0 2
47169: PUSH
47170: FOR_TO
47171: IFFALSE 47235
// begin hc_class = class_tiger ;
47173: LD_ADDR_OWVAR 28
47177: PUSH
47178: LD_INT 14
47180: ST_TO_ADDR
// hc_gallery =  ;
47181: LD_ADDR_OWVAR 33
47185: PUSH
47186: LD_STRING 
47188: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47189: LD_ADDR_OWVAR 35
47193: PUSH
47194: LD_INT 7
47196: NEG
47197: PPUSH
47198: LD_INT 7
47200: PPUSH
47201: CALL_OW 12
47205: ST_TO_ADDR
// animal := CreateHuman ;
47206: LD_ADDR_VAR 0 12
47210: PUSH
47211: CALL_OW 44
47215: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47216: LD_VAR 0 12
47220: PPUSH
47221: LD_VAR 0 8
47225: PPUSH
47226: LD_INT 0
47228: PPUSH
47229: CALL 49076 0 3
// end ;
47233: GO 47170
47235: POP
47236: POP
// if apemans then
47237: LD_VAR 0 3
47241: IFFALSE 47364
// for i = 1 to apemans do
47243: LD_ADDR_VAR 0 11
47247: PUSH
47248: DOUBLE
47249: LD_INT 1
47251: DEC
47252: ST_TO_ADDR
47253: LD_VAR 0 3
47257: PUSH
47258: FOR_TO
47259: IFFALSE 47362
// begin hc_class = class_apeman ;
47261: LD_ADDR_OWVAR 28
47265: PUSH
47266: LD_INT 12
47268: ST_TO_ADDR
// hc_gallery =  ;
47269: LD_ADDR_OWVAR 33
47273: PUSH
47274: LD_STRING 
47276: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47277: LD_ADDR_OWVAR 35
47281: PUSH
47282: LD_INT 5
47284: NEG
47285: PPUSH
47286: LD_INT 5
47288: PPUSH
47289: CALL_OW 12
47293: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47294: LD_ADDR_OWVAR 31
47298: PUSH
47299: LD_INT 1
47301: PPUSH
47302: LD_INT 3
47304: PPUSH
47305: CALL_OW 12
47309: PUSH
47310: LD_INT 1
47312: PPUSH
47313: LD_INT 3
47315: PPUSH
47316: CALL_OW 12
47320: PUSH
47321: LD_INT 0
47323: PUSH
47324: LD_INT 0
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: ST_TO_ADDR
// animal := CreateHuman ;
47333: LD_ADDR_VAR 0 12
47337: PUSH
47338: CALL_OW 44
47342: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47343: LD_VAR 0 12
47347: PPUSH
47348: LD_VAR 0 8
47352: PPUSH
47353: LD_INT 0
47355: PPUSH
47356: CALL 49076 0 3
// end ;
47360: GO 47258
47362: POP
47363: POP
// if enchidnas then
47364: LD_VAR 0 4
47368: IFFALSE 47435
// for i = 1 to enchidnas do
47370: LD_ADDR_VAR 0 11
47374: PUSH
47375: DOUBLE
47376: LD_INT 1
47378: DEC
47379: ST_TO_ADDR
47380: LD_VAR 0 4
47384: PUSH
47385: FOR_TO
47386: IFFALSE 47433
// begin hc_class = 13 ;
47388: LD_ADDR_OWVAR 28
47392: PUSH
47393: LD_INT 13
47395: ST_TO_ADDR
// hc_gallery =  ;
47396: LD_ADDR_OWVAR 33
47400: PUSH
47401: LD_STRING 
47403: ST_TO_ADDR
// animal := CreateHuman ;
47404: LD_ADDR_VAR 0 12
47408: PUSH
47409: CALL_OW 44
47413: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47414: LD_VAR 0 12
47418: PPUSH
47419: LD_VAR 0 8
47423: PPUSH
47424: LD_INT 0
47426: PPUSH
47427: CALL 49076 0 3
// end ;
47431: GO 47385
47433: POP
47434: POP
// if fishes then
47435: LD_VAR 0 7
47439: IFFALSE 47506
// for i = 1 to fishes do
47441: LD_ADDR_VAR 0 11
47445: PUSH
47446: DOUBLE
47447: LD_INT 1
47449: DEC
47450: ST_TO_ADDR
47451: LD_VAR 0 7
47455: PUSH
47456: FOR_TO
47457: IFFALSE 47504
// begin hc_class = 20 ;
47459: LD_ADDR_OWVAR 28
47463: PUSH
47464: LD_INT 20
47466: ST_TO_ADDR
// hc_gallery =  ;
47467: LD_ADDR_OWVAR 33
47471: PUSH
47472: LD_STRING 
47474: ST_TO_ADDR
// animal := CreateHuman ;
47475: LD_ADDR_VAR 0 12
47479: PUSH
47480: CALL_OW 44
47484: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47485: LD_VAR 0 12
47489: PPUSH
47490: LD_VAR 0 9
47494: PPUSH
47495: LD_INT 0
47497: PPUSH
47498: CALL 49076 0 3
// end ;
47502: GO 47456
47504: POP
47505: POP
// end ;
47506: LD_VAR 0 10
47510: RET
// export function WantHeal ( sci , unit ) ; begin
47511: LD_INT 0
47513: PPUSH
// if GetTaskList ( sci ) > 0 then
47514: LD_VAR 0 1
47518: PPUSH
47519: CALL_OW 437
47523: PUSH
47524: LD_INT 0
47526: GREATER
47527: IFFALSE 47597
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47529: LD_VAR 0 1
47533: PPUSH
47534: CALL_OW 437
47538: PUSH
47539: LD_INT 1
47541: ARRAY
47542: PUSH
47543: LD_INT 1
47545: ARRAY
47546: PUSH
47547: LD_STRING l
47549: EQUAL
47550: PUSH
47551: LD_VAR 0 1
47555: PPUSH
47556: CALL_OW 437
47560: PUSH
47561: LD_INT 1
47563: ARRAY
47564: PUSH
47565: LD_INT 4
47567: ARRAY
47568: PUSH
47569: LD_VAR 0 2
47573: EQUAL
47574: AND
47575: IFFALSE 47587
// result := true else
47577: LD_ADDR_VAR 0 3
47581: PUSH
47582: LD_INT 1
47584: ST_TO_ADDR
47585: GO 47595
// result := false ;
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_INT 0
47594: ST_TO_ADDR
// end else
47595: GO 47605
// result := false ;
47597: LD_ADDR_VAR 0 3
47601: PUSH
47602: LD_INT 0
47604: ST_TO_ADDR
// end ;
47605: LD_VAR 0 3
47609: RET
// export function HealTarget ( sci ) ; begin
47610: LD_INT 0
47612: PPUSH
// if not sci then
47613: LD_VAR 0 1
47617: NOT
47618: IFFALSE 47622
// exit ;
47620: GO 47687
// result := 0 ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: ST_TO_ADDR
// if GetTaskList ( sci ) then
47630: LD_VAR 0 1
47634: PPUSH
47635: CALL_OW 437
47639: IFFALSE 47687
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47641: LD_VAR 0 1
47645: PPUSH
47646: CALL_OW 437
47650: PUSH
47651: LD_INT 1
47653: ARRAY
47654: PUSH
47655: LD_INT 1
47657: ARRAY
47658: PUSH
47659: LD_STRING l
47661: EQUAL
47662: IFFALSE 47687
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47664: LD_ADDR_VAR 0 2
47668: PUSH
47669: LD_VAR 0 1
47673: PPUSH
47674: CALL_OW 437
47678: PUSH
47679: LD_INT 1
47681: ARRAY
47682: PUSH
47683: LD_INT 4
47685: ARRAY
47686: ST_TO_ADDR
// end ;
47687: LD_VAR 0 2
47691: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47692: LD_INT 0
47694: PPUSH
47695: PPUSH
47696: PPUSH
47697: PPUSH
// if not base_units then
47698: LD_VAR 0 1
47702: NOT
47703: IFFALSE 47707
// exit ;
47705: GO 47794
// result := false ;
47707: LD_ADDR_VAR 0 2
47711: PUSH
47712: LD_INT 0
47714: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47715: LD_ADDR_VAR 0 5
47719: PUSH
47720: LD_VAR 0 1
47724: PPUSH
47725: LD_INT 21
47727: PUSH
47728: LD_INT 3
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: PPUSH
47735: CALL_OW 72
47739: ST_TO_ADDR
// if not tmp then
47740: LD_VAR 0 5
47744: NOT
47745: IFFALSE 47749
// exit ;
47747: GO 47794
// for i in tmp do
47749: LD_ADDR_VAR 0 3
47753: PUSH
47754: LD_VAR 0 5
47758: PUSH
47759: FOR_IN
47760: IFFALSE 47792
// begin result := EnemyInRange ( i , 22 ) ;
47762: LD_ADDR_VAR 0 2
47766: PUSH
47767: LD_VAR 0 3
47771: PPUSH
47772: LD_INT 22
47774: PPUSH
47775: CALL 46030 0 2
47779: ST_TO_ADDR
// if result then
47780: LD_VAR 0 2
47784: IFFALSE 47790
// exit ;
47786: POP
47787: POP
47788: GO 47794
// end ;
47790: GO 47759
47792: POP
47793: POP
// end ;
47794: LD_VAR 0 2
47798: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47799: LD_INT 0
47801: PPUSH
47802: PPUSH
// if not units then
47803: LD_VAR 0 1
47807: NOT
47808: IFFALSE 47812
// exit ;
47810: GO 47882
// result := [ ] ;
47812: LD_ADDR_VAR 0 3
47816: PUSH
47817: EMPTY
47818: ST_TO_ADDR
// for i in units do
47819: LD_ADDR_VAR 0 4
47823: PUSH
47824: LD_VAR 0 1
47828: PUSH
47829: FOR_IN
47830: IFFALSE 47880
// if GetTag ( i ) = tag then
47832: LD_VAR 0 4
47836: PPUSH
47837: CALL_OW 110
47841: PUSH
47842: LD_VAR 0 2
47846: EQUAL
47847: IFFALSE 47878
// result := Insert ( result , result + 1 , i ) ;
47849: LD_ADDR_VAR 0 3
47853: PUSH
47854: LD_VAR 0 3
47858: PPUSH
47859: LD_VAR 0 3
47863: PUSH
47864: LD_INT 1
47866: PLUS
47867: PPUSH
47868: LD_VAR 0 4
47872: PPUSH
47873: CALL_OW 2
47877: ST_TO_ADDR
47878: GO 47829
47880: POP
47881: POP
// end ;
47882: LD_VAR 0 3
47886: RET
// export function IsDriver ( un ) ; begin
47887: LD_INT 0
47889: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47890: LD_ADDR_VAR 0 2
47894: PUSH
47895: LD_VAR 0 1
47899: PUSH
47900: LD_INT 55
47902: PUSH
47903: EMPTY
47904: LIST
47905: PPUSH
47906: CALL_OW 69
47910: IN
47911: ST_TO_ADDR
// end ;
47912: LD_VAR 0 2
47916: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47917: LD_INT 0
47919: PPUSH
47920: PPUSH
// list := [ ] ;
47921: LD_ADDR_VAR 0 5
47925: PUSH
47926: EMPTY
47927: ST_TO_ADDR
// case d of 0 :
47928: LD_VAR 0 3
47932: PUSH
47933: LD_INT 0
47935: DOUBLE
47936: EQUAL
47937: IFTRUE 47941
47939: GO 48074
47941: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47942: LD_ADDR_VAR 0 5
47946: PUSH
47947: LD_VAR 0 1
47951: PUSH
47952: LD_INT 4
47954: MINUS
47955: PUSH
47956: LD_VAR 0 2
47960: PUSH
47961: LD_INT 4
47963: MINUS
47964: PUSH
47965: LD_INT 2
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: LIST
47972: PUSH
47973: LD_VAR 0 1
47977: PUSH
47978: LD_INT 3
47980: MINUS
47981: PUSH
47982: LD_VAR 0 2
47986: PUSH
47987: LD_INT 1
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: LIST
47994: PUSH
47995: LD_VAR 0 1
47999: PUSH
48000: LD_INT 4
48002: PLUS
48003: PUSH
48004: LD_VAR 0 2
48008: PUSH
48009: LD_INT 4
48011: PUSH
48012: EMPTY
48013: LIST
48014: LIST
48015: LIST
48016: PUSH
48017: LD_VAR 0 1
48021: PUSH
48022: LD_INT 3
48024: PLUS
48025: PUSH
48026: LD_VAR 0 2
48030: PUSH
48031: LD_INT 3
48033: PLUS
48034: PUSH
48035: LD_INT 5
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: PUSH
48043: LD_VAR 0 1
48047: PUSH
48048: LD_VAR 0 2
48052: PUSH
48053: LD_INT 4
48055: PLUS
48056: PUSH
48057: LD_INT 0
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: LIST
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: ST_TO_ADDR
// end ; 1 :
48072: GO 48772
48074: LD_INT 1
48076: DOUBLE
48077: EQUAL
48078: IFTRUE 48082
48080: GO 48215
48082: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48083: LD_ADDR_VAR 0 5
48087: PUSH
48088: LD_VAR 0 1
48092: PUSH
48093: LD_VAR 0 2
48097: PUSH
48098: LD_INT 4
48100: MINUS
48101: PUSH
48102: LD_INT 3
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: LIST
48109: PUSH
48110: LD_VAR 0 1
48114: PUSH
48115: LD_INT 3
48117: MINUS
48118: PUSH
48119: LD_VAR 0 2
48123: PUSH
48124: LD_INT 3
48126: MINUS
48127: PUSH
48128: LD_INT 2
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: LIST
48135: PUSH
48136: LD_VAR 0 1
48140: PUSH
48141: LD_INT 4
48143: MINUS
48144: PUSH
48145: LD_VAR 0 2
48149: PUSH
48150: LD_INT 1
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: LIST
48157: PUSH
48158: LD_VAR 0 1
48162: PUSH
48163: LD_VAR 0 2
48167: PUSH
48168: LD_INT 3
48170: PLUS
48171: PUSH
48172: LD_INT 0
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: LIST
48179: PUSH
48180: LD_VAR 0 1
48184: PUSH
48185: LD_INT 4
48187: PLUS
48188: PUSH
48189: LD_VAR 0 2
48193: PUSH
48194: LD_INT 4
48196: PLUS
48197: PUSH
48198: LD_INT 5
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: ST_TO_ADDR
// end ; 2 :
48213: GO 48772
48215: LD_INT 2
48217: DOUBLE
48218: EQUAL
48219: IFTRUE 48223
48221: GO 48352
48223: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48224: LD_ADDR_VAR 0 5
48228: PUSH
48229: LD_VAR 0 1
48233: PUSH
48234: LD_VAR 0 2
48238: PUSH
48239: LD_INT 3
48241: MINUS
48242: PUSH
48243: LD_INT 3
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: PUSH
48251: LD_VAR 0 1
48255: PUSH
48256: LD_INT 4
48258: PLUS
48259: PUSH
48260: LD_VAR 0 2
48264: PUSH
48265: LD_INT 4
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: LIST
48272: PUSH
48273: LD_VAR 0 1
48277: PUSH
48278: LD_VAR 0 2
48282: PUSH
48283: LD_INT 4
48285: PLUS
48286: PUSH
48287: LD_INT 0
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: PUSH
48295: LD_VAR 0 1
48299: PUSH
48300: LD_INT 3
48302: MINUS
48303: PUSH
48304: LD_VAR 0 2
48308: PUSH
48309: LD_INT 1
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: LIST
48316: PUSH
48317: LD_VAR 0 1
48321: PUSH
48322: LD_INT 4
48324: MINUS
48325: PUSH
48326: LD_VAR 0 2
48330: PUSH
48331: LD_INT 4
48333: MINUS
48334: PUSH
48335: LD_INT 2
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: ST_TO_ADDR
// end ; 3 :
48350: GO 48772
48352: LD_INT 3
48354: DOUBLE
48355: EQUAL
48356: IFTRUE 48360
48358: GO 48493
48360: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48361: LD_ADDR_VAR 0 5
48365: PUSH
48366: LD_VAR 0 1
48370: PUSH
48371: LD_INT 3
48373: PLUS
48374: PUSH
48375: LD_VAR 0 2
48379: PUSH
48380: LD_INT 4
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PUSH
48388: LD_VAR 0 1
48392: PUSH
48393: LD_INT 4
48395: PLUS
48396: PUSH
48397: LD_VAR 0 2
48401: PUSH
48402: LD_INT 4
48404: PLUS
48405: PUSH
48406: LD_INT 5
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: LIST
48413: PUSH
48414: LD_VAR 0 1
48418: PUSH
48419: LD_INT 4
48421: MINUS
48422: PUSH
48423: LD_VAR 0 2
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: LIST
48435: PUSH
48436: LD_VAR 0 1
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 4
48448: MINUS
48449: PUSH
48450: LD_INT 3
48452: PUSH
48453: EMPTY
48454: LIST
48455: LIST
48456: LIST
48457: PUSH
48458: LD_VAR 0 1
48462: PUSH
48463: LD_INT 3
48465: MINUS
48466: PUSH
48467: LD_VAR 0 2
48471: PUSH
48472: LD_INT 3
48474: MINUS
48475: PUSH
48476: LD_INT 2
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: LIST
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: LIST
48488: LIST
48489: LIST
48490: ST_TO_ADDR
// end ; 4 :
48491: GO 48772
48493: LD_INT 4
48495: DOUBLE
48496: EQUAL
48497: IFTRUE 48501
48499: GO 48634
48501: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48502: LD_ADDR_VAR 0 5
48506: PUSH
48507: LD_VAR 0 1
48511: PUSH
48512: LD_VAR 0 2
48516: PUSH
48517: LD_INT 4
48519: PLUS
48520: PUSH
48521: LD_INT 0
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: LIST
48528: PUSH
48529: LD_VAR 0 1
48533: PUSH
48534: LD_INT 3
48536: PLUS
48537: PUSH
48538: LD_VAR 0 2
48542: PUSH
48543: LD_INT 3
48545: PLUS
48546: PUSH
48547: LD_INT 5
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: LIST
48554: PUSH
48555: LD_VAR 0 1
48559: PUSH
48560: LD_INT 4
48562: PLUS
48563: PUSH
48564: LD_VAR 0 2
48568: PUSH
48569: LD_INT 4
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: LIST
48576: PUSH
48577: LD_VAR 0 1
48581: PUSH
48582: LD_VAR 0 2
48586: PUSH
48587: LD_INT 3
48589: MINUS
48590: PUSH
48591: LD_INT 3
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: LIST
48598: PUSH
48599: LD_VAR 0 1
48603: PUSH
48604: LD_INT 4
48606: MINUS
48607: PUSH
48608: LD_VAR 0 2
48612: PUSH
48613: LD_INT 4
48615: MINUS
48616: PUSH
48617: LD_INT 2
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: LIST
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: ST_TO_ADDR
// end ; 5 :
48632: GO 48772
48634: LD_INT 5
48636: DOUBLE
48637: EQUAL
48638: IFTRUE 48642
48640: GO 48771
48642: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48643: LD_ADDR_VAR 0 5
48647: PUSH
48648: LD_VAR 0 1
48652: PUSH
48653: LD_INT 4
48655: MINUS
48656: PUSH
48657: LD_VAR 0 2
48661: PUSH
48662: LD_INT 1
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: LIST
48669: PUSH
48670: LD_VAR 0 1
48674: PUSH
48675: LD_VAR 0 2
48679: PUSH
48680: LD_INT 4
48682: MINUS
48683: PUSH
48684: LD_INT 3
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: LIST
48691: PUSH
48692: LD_VAR 0 1
48696: PUSH
48697: LD_INT 4
48699: PLUS
48700: PUSH
48701: LD_VAR 0 2
48705: PUSH
48706: LD_INT 4
48708: PLUS
48709: PUSH
48710: LD_INT 5
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: LIST
48717: PUSH
48718: LD_VAR 0 1
48722: PUSH
48723: LD_INT 3
48725: PLUS
48726: PUSH
48727: LD_VAR 0 2
48731: PUSH
48732: LD_INT 4
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: LIST
48739: PUSH
48740: LD_VAR 0 1
48744: PUSH
48745: LD_VAR 0 2
48749: PUSH
48750: LD_INT 3
48752: PLUS
48753: PUSH
48754: LD_INT 0
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: LIST
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: ST_TO_ADDR
// end ; end ;
48769: GO 48772
48771: POP
// result := list ;
48772: LD_ADDR_VAR 0 4
48776: PUSH
48777: LD_VAR 0 5
48781: ST_TO_ADDR
// end ;
48782: LD_VAR 0 4
48786: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48787: LD_INT 0
48789: PPUSH
48790: PPUSH
48791: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48792: LD_VAR 0 1
48796: NOT
48797: PUSH
48798: LD_VAR 0 2
48802: PUSH
48803: LD_INT 1
48805: PUSH
48806: LD_INT 2
48808: PUSH
48809: LD_INT 3
48811: PUSH
48812: LD_INT 4
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: IN
48821: NOT
48822: OR
48823: IFFALSE 48827
// exit ;
48825: GO 48919
// tmp := [ ] ;
48827: LD_ADDR_VAR 0 5
48831: PUSH
48832: EMPTY
48833: ST_TO_ADDR
// for i in units do
48834: LD_ADDR_VAR 0 4
48838: PUSH
48839: LD_VAR 0 1
48843: PUSH
48844: FOR_IN
48845: IFFALSE 48888
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48847: LD_ADDR_VAR 0 5
48851: PUSH
48852: LD_VAR 0 5
48856: PPUSH
48857: LD_VAR 0 5
48861: PUSH
48862: LD_INT 1
48864: PLUS
48865: PPUSH
48866: LD_VAR 0 4
48870: PPUSH
48871: LD_VAR 0 2
48875: PPUSH
48876: CALL_OW 259
48880: PPUSH
48881: CALL_OW 2
48885: ST_TO_ADDR
48886: GO 48844
48888: POP
48889: POP
// if not tmp then
48890: LD_VAR 0 5
48894: NOT
48895: IFFALSE 48899
// exit ;
48897: GO 48919
// result := SortListByListDesc ( units , tmp ) ;
48899: LD_ADDR_VAR 0 3
48903: PUSH
48904: LD_VAR 0 1
48908: PPUSH
48909: LD_VAR 0 5
48913: PPUSH
48914: CALL_OW 77
48918: ST_TO_ADDR
// end ;
48919: LD_VAR 0 3
48923: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
// x := GetX ( building ) ;
48929: LD_ADDR_VAR 0 4
48933: PUSH
48934: LD_VAR 0 2
48938: PPUSH
48939: CALL_OW 250
48943: ST_TO_ADDR
// y := GetY ( building ) ;
48944: LD_ADDR_VAR 0 5
48948: PUSH
48949: LD_VAR 0 2
48953: PPUSH
48954: CALL_OW 251
48958: ST_TO_ADDR
// if GetTaskList ( unit ) then
48959: LD_VAR 0 1
48963: PPUSH
48964: CALL_OW 437
48968: IFFALSE 49063
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48970: LD_STRING e
48972: PUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 437
48982: PUSH
48983: LD_INT 1
48985: ARRAY
48986: PUSH
48987: LD_INT 1
48989: ARRAY
48990: EQUAL
48991: PUSH
48992: LD_VAR 0 4
48996: PUSH
48997: LD_VAR 0 1
49001: PPUSH
49002: CALL_OW 437
49006: PUSH
49007: LD_INT 1
49009: ARRAY
49010: PUSH
49011: LD_INT 2
49013: ARRAY
49014: EQUAL
49015: AND
49016: PUSH
49017: LD_VAR 0 5
49021: PUSH
49022: LD_VAR 0 1
49026: PPUSH
49027: CALL_OW 437
49031: PUSH
49032: LD_INT 1
49034: ARRAY
49035: PUSH
49036: LD_INT 3
49038: ARRAY
49039: EQUAL
49040: AND
49041: IFFALSE 49053
// result := true else
49043: LD_ADDR_VAR 0 3
49047: PUSH
49048: LD_INT 1
49050: ST_TO_ADDR
49051: GO 49061
// result := false ;
49053: LD_ADDR_VAR 0 3
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// end else
49061: GO 49071
// result := false ;
49063: LD_ADDR_VAR 0 3
49067: PUSH
49068: LD_INT 0
49070: ST_TO_ADDR
// end ;
49071: LD_VAR 0 3
49075: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49076: LD_INT 0
49078: PPUSH
49079: PPUSH
49080: PPUSH
49081: PPUSH
// if not unit or not area then
49082: LD_VAR 0 1
49086: NOT
49087: PUSH
49088: LD_VAR 0 2
49092: NOT
49093: OR
49094: IFFALSE 49098
// exit ;
49096: GO 49262
// tmp := AreaToList ( area , i ) ;
49098: LD_ADDR_VAR 0 6
49102: PUSH
49103: LD_VAR 0 2
49107: PPUSH
49108: LD_VAR 0 5
49112: PPUSH
49113: CALL_OW 517
49117: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49118: LD_ADDR_VAR 0 5
49122: PUSH
49123: DOUBLE
49124: LD_INT 1
49126: DEC
49127: ST_TO_ADDR
49128: LD_VAR 0 6
49132: PUSH
49133: LD_INT 1
49135: ARRAY
49136: PUSH
49137: FOR_TO
49138: IFFALSE 49260
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49140: LD_ADDR_VAR 0 7
49144: PUSH
49145: LD_VAR 0 6
49149: PUSH
49150: LD_INT 1
49152: ARRAY
49153: PUSH
49154: LD_VAR 0 5
49158: ARRAY
49159: PUSH
49160: LD_VAR 0 6
49164: PUSH
49165: LD_INT 2
49167: ARRAY
49168: PUSH
49169: LD_VAR 0 5
49173: ARRAY
49174: PUSH
49175: EMPTY
49176: LIST
49177: LIST
49178: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49179: LD_VAR 0 7
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: PPUSH
49188: LD_VAR 0 7
49192: PUSH
49193: LD_INT 2
49195: ARRAY
49196: PPUSH
49197: CALL_OW 428
49201: PUSH
49202: LD_INT 0
49204: EQUAL
49205: IFFALSE 49258
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49207: LD_VAR 0 1
49211: PPUSH
49212: LD_VAR 0 7
49216: PUSH
49217: LD_INT 1
49219: ARRAY
49220: PPUSH
49221: LD_VAR 0 7
49225: PUSH
49226: LD_INT 2
49228: ARRAY
49229: PPUSH
49230: LD_VAR 0 3
49234: PPUSH
49235: CALL_OW 48
// result := IsPlaced ( unit ) ;
49239: LD_ADDR_VAR 0 4
49243: PUSH
49244: LD_VAR 0 1
49248: PPUSH
49249: CALL_OW 305
49253: ST_TO_ADDR
// exit ;
49254: POP
49255: POP
49256: GO 49262
// end ; end ;
49258: GO 49137
49260: POP
49261: POP
// end ;
49262: LD_VAR 0 4
49266: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49267: LD_INT 0
49269: PPUSH
49270: PPUSH
49271: PPUSH
// if not side or side > 8 then
49272: LD_VAR 0 1
49276: NOT
49277: PUSH
49278: LD_VAR 0 1
49282: PUSH
49283: LD_INT 8
49285: GREATER
49286: OR
49287: IFFALSE 49291
// exit ;
49289: GO 49478
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49291: LD_ADDR_VAR 0 4
49295: PUSH
49296: LD_INT 22
49298: PUSH
49299: LD_VAR 0 1
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: PUSH
49308: LD_INT 21
49310: PUSH
49311: LD_INT 3
49313: PUSH
49314: EMPTY
49315: LIST
49316: LIST
49317: PUSH
49318: EMPTY
49319: LIST
49320: LIST
49321: PPUSH
49322: CALL_OW 69
49326: ST_TO_ADDR
// if not tmp then
49327: LD_VAR 0 4
49331: NOT
49332: IFFALSE 49336
// exit ;
49334: GO 49478
// enable_addtolog := true ;
49336: LD_ADDR_OWVAR 81
49340: PUSH
49341: LD_INT 1
49343: ST_TO_ADDR
// AddToLog ( [ ) ;
49344: LD_STRING [
49346: PPUSH
49347: CALL_OW 561
// for i in tmp do
49351: LD_ADDR_VAR 0 3
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: FOR_IN
49362: IFFALSE 49469
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49364: LD_STRING [
49366: PUSH
49367: LD_VAR 0 3
49371: PPUSH
49372: CALL_OW 266
49376: STR
49377: PUSH
49378: LD_STRING , 
49380: STR
49381: PUSH
49382: LD_VAR 0 3
49386: PPUSH
49387: CALL_OW 250
49391: STR
49392: PUSH
49393: LD_STRING , 
49395: STR
49396: PUSH
49397: LD_VAR 0 3
49401: PPUSH
49402: CALL_OW 251
49406: STR
49407: PUSH
49408: LD_STRING , 
49410: STR
49411: PUSH
49412: LD_VAR 0 3
49416: PPUSH
49417: CALL_OW 254
49421: STR
49422: PUSH
49423: LD_STRING , 
49425: STR
49426: PUSH
49427: LD_VAR 0 3
49431: PPUSH
49432: LD_INT 1
49434: PPUSH
49435: CALL_OW 268
49439: STR
49440: PUSH
49441: LD_STRING , 
49443: STR
49444: PUSH
49445: LD_VAR 0 3
49449: PPUSH
49450: LD_INT 2
49452: PPUSH
49453: CALL_OW 268
49457: STR
49458: PUSH
49459: LD_STRING ],
49461: STR
49462: PPUSH
49463: CALL_OW 561
// end ;
49467: GO 49361
49469: POP
49470: POP
// AddToLog ( ]; ) ;
49471: LD_STRING ];
49473: PPUSH
49474: CALL_OW 561
// end ;
49478: LD_VAR 0 2
49482: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49483: LD_INT 0
49485: PPUSH
49486: PPUSH
49487: PPUSH
49488: PPUSH
49489: PPUSH
// if not area or not rate or not max then
49490: LD_VAR 0 1
49494: NOT
49495: PUSH
49496: LD_VAR 0 2
49500: NOT
49501: OR
49502: PUSH
49503: LD_VAR 0 4
49507: NOT
49508: OR
49509: IFFALSE 49513
// exit ;
49511: GO 49705
// while 1 do
49513: LD_INT 1
49515: IFFALSE 49705
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49517: LD_ADDR_VAR 0 9
49521: PUSH
49522: LD_VAR 0 1
49526: PPUSH
49527: LD_INT 1
49529: PPUSH
49530: CALL_OW 287
49534: PUSH
49535: LD_INT 10
49537: MUL
49538: ST_TO_ADDR
// r := rate / 10 ;
49539: LD_ADDR_VAR 0 7
49543: PUSH
49544: LD_VAR 0 2
49548: PUSH
49549: LD_INT 10
49551: DIVREAL
49552: ST_TO_ADDR
// time := 1 1$00 ;
49553: LD_ADDR_VAR 0 8
49557: PUSH
49558: LD_INT 2100
49560: ST_TO_ADDR
// if amount < min then
49561: LD_VAR 0 9
49565: PUSH
49566: LD_VAR 0 3
49570: LESS
49571: IFFALSE 49589
// r := r * 2 else
49573: LD_ADDR_VAR 0 7
49577: PUSH
49578: LD_VAR 0 7
49582: PUSH
49583: LD_INT 2
49585: MUL
49586: ST_TO_ADDR
49587: GO 49615
// if amount > max then
49589: LD_VAR 0 9
49593: PUSH
49594: LD_VAR 0 4
49598: GREATER
49599: IFFALSE 49615
// r := r / 2 ;
49601: LD_ADDR_VAR 0 7
49605: PUSH
49606: LD_VAR 0 7
49610: PUSH
49611: LD_INT 2
49613: DIVREAL
49614: ST_TO_ADDR
// time := time / r ;
49615: LD_ADDR_VAR 0 8
49619: PUSH
49620: LD_VAR 0 8
49624: PUSH
49625: LD_VAR 0 7
49629: DIVREAL
49630: ST_TO_ADDR
// if time < 0 then
49631: LD_VAR 0 8
49635: PUSH
49636: LD_INT 0
49638: LESS
49639: IFFALSE 49656
// time := time * - 1 ;
49641: LD_ADDR_VAR 0 8
49645: PUSH
49646: LD_VAR 0 8
49650: PUSH
49651: LD_INT 1
49653: NEG
49654: MUL
49655: ST_TO_ADDR
// wait ( time ) ;
49656: LD_VAR 0 8
49660: PPUSH
49661: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49665: LD_INT 35
49667: PPUSH
49668: LD_INT 875
49670: PPUSH
49671: CALL_OW 12
49675: PPUSH
49676: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49680: LD_INT 1
49682: PPUSH
49683: LD_INT 5
49685: PPUSH
49686: CALL_OW 12
49690: PPUSH
49691: LD_VAR 0 1
49695: PPUSH
49696: LD_INT 1
49698: PPUSH
49699: CALL_OW 55
// end ;
49703: GO 49513
// end ;
49705: LD_VAR 0 5
49709: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49710: LD_INT 0
49712: PPUSH
49713: PPUSH
49714: PPUSH
49715: PPUSH
49716: PPUSH
49717: PPUSH
49718: PPUSH
49719: PPUSH
// if not turrets or not factories then
49720: LD_VAR 0 1
49724: NOT
49725: PUSH
49726: LD_VAR 0 2
49730: NOT
49731: OR
49732: IFFALSE 49736
// exit ;
49734: GO 50043
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49736: LD_ADDR_VAR 0 10
49740: PUSH
49741: LD_INT 5
49743: PUSH
49744: LD_INT 6
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 2
49753: PUSH
49754: LD_INT 4
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 3
49763: PUSH
49764: LD_INT 5
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: LIST
49775: PUSH
49776: LD_INT 24
49778: PUSH
49779: LD_INT 25
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: PUSH
49786: LD_INT 23
49788: PUSH
49789: LD_INT 27
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PUSH
49800: LD_INT 42
49802: PUSH
49803: LD_INT 43
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 44
49812: PUSH
49813: LD_INT 46
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: PUSH
49820: LD_INT 45
49822: PUSH
49823: LD_INT 47
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: EMPTY
49831: LIST
49832: LIST
49833: LIST
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: LIST
49839: ST_TO_ADDR
// result := [ ] ;
49840: LD_ADDR_VAR 0 3
49844: PUSH
49845: EMPTY
49846: ST_TO_ADDR
// for i in turrets do
49847: LD_ADDR_VAR 0 4
49851: PUSH
49852: LD_VAR 0 1
49856: PUSH
49857: FOR_IN
49858: IFFALSE 50041
// begin nat := GetNation ( i ) ;
49860: LD_ADDR_VAR 0 7
49864: PUSH
49865: LD_VAR 0 4
49869: PPUSH
49870: CALL_OW 248
49874: ST_TO_ADDR
// weapon := 0 ;
49875: LD_ADDR_VAR 0 8
49879: PUSH
49880: LD_INT 0
49882: ST_TO_ADDR
// if not nat then
49883: LD_VAR 0 7
49887: NOT
49888: IFFALSE 49892
// continue ;
49890: GO 49857
// for j in list [ nat ] do
49892: LD_ADDR_VAR 0 5
49896: PUSH
49897: LD_VAR 0 10
49901: PUSH
49902: LD_VAR 0 7
49906: ARRAY
49907: PUSH
49908: FOR_IN
49909: IFFALSE 49950
// if GetBWeapon ( i ) = j [ 1 ] then
49911: LD_VAR 0 4
49915: PPUSH
49916: CALL_OW 269
49920: PUSH
49921: LD_VAR 0 5
49925: PUSH
49926: LD_INT 1
49928: ARRAY
49929: EQUAL
49930: IFFALSE 49948
// begin weapon := j [ 2 ] ;
49932: LD_ADDR_VAR 0 8
49936: PUSH
49937: LD_VAR 0 5
49941: PUSH
49942: LD_INT 2
49944: ARRAY
49945: ST_TO_ADDR
// break ;
49946: GO 49950
// end ;
49948: GO 49908
49950: POP
49951: POP
// if not weapon then
49952: LD_VAR 0 8
49956: NOT
49957: IFFALSE 49961
// continue ;
49959: GO 49857
// for k in factories do
49961: LD_ADDR_VAR 0 6
49965: PUSH
49966: LD_VAR 0 2
49970: PUSH
49971: FOR_IN
49972: IFFALSE 50037
// begin weapons := AvailableWeaponList ( k ) ;
49974: LD_ADDR_VAR 0 9
49978: PUSH
49979: LD_VAR 0 6
49983: PPUSH
49984: CALL_OW 478
49988: ST_TO_ADDR
// if not weapons then
49989: LD_VAR 0 9
49993: NOT
49994: IFFALSE 49998
// continue ;
49996: GO 49971
// if weapon in weapons then
49998: LD_VAR 0 8
50002: PUSH
50003: LD_VAR 0 9
50007: IN
50008: IFFALSE 50035
// begin result := [ i , weapon ] ;
50010: LD_ADDR_VAR 0 3
50014: PUSH
50015: LD_VAR 0 4
50019: PUSH
50020: LD_VAR 0 8
50024: PUSH
50025: EMPTY
50026: LIST
50027: LIST
50028: ST_TO_ADDR
// exit ;
50029: POP
50030: POP
50031: POP
50032: POP
50033: GO 50043
// end ; end ;
50035: GO 49971
50037: POP
50038: POP
// end ;
50039: GO 49857
50041: POP
50042: POP
// end ;
50043: LD_VAR 0 3
50047: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50048: LD_INT 0
50050: PPUSH
// if not side or side > 8 then
50051: LD_VAR 0 3
50055: NOT
50056: PUSH
50057: LD_VAR 0 3
50061: PUSH
50062: LD_INT 8
50064: GREATER
50065: OR
50066: IFFALSE 50070
// exit ;
50068: GO 50129
// if not range then
50070: LD_VAR 0 4
50074: NOT
50075: IFFALSE 50086
// range := - 12 ;
50077: LD_ADDR_VAR 0 4
50081: PUSH
50082: LD_INT 12
50084: NEG
50085: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50086: LD_VAR 0 1
50090: PPUSH
50091: LD_VAR 0 2
50095: PPUSH
50096: LD_VAR 0 3
50100: PPUSH
50101: LD_VAR 0 4
50105: PPUSH
50106: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50110: LD_VAR 0 1
50114: PPUSH
50115: LD_VAR 0 2
50119: PPUSH
50120: LD_VAR 0 3
50124: PPUSH
50125: CALL_OW 331
// end ;
50129: LD_VAR 0 5
50133: RET
// export function Video ( mode ) ; begin
50134: LD_INT 0
50136: PPUSH
// ingame_video = mode ;
50137: LD_ADDR_OWVAR 52
50141: PUSH
50142: LD_VAR 0 1
50146: ST_TO_ADDR
// interface_hidden = mode ;
50147: LD_ADDR_OWVAR 54
50151: PUSH
50152: LD_VAR 0 1
50156: ST_TO_ADDR
// end ;
50157: LD_VAR 0 2
50161: RET
// export function Join ( array , element ) ; begin
50162: LD_INT 0
50164: PPUSH
// result := array ^ element ;
50165: LD_ADDR_VAR 0 3
50169: PUSH
50170: LD_VAR 0 1
50174: PUSH
50175: LD_VAR 0 2
50179: ADD
50180: ST_TO_ADDR
// end ;
50181: LD_VAR 0 3
50185: RET
// export function JoinUnion ( array , element ) ; begin
50186: LD_INT 0
50188: PPUSH
// result := array union element ;
50189: LD_ADDR_VAR 0 3
50193: PUSH
50194: LD_VAR 0 1
50198: PUSH
50199: LD_VAR 0 2
50203: UNION
50204: ST_TO_ADDR
// end ;
50205: LD_VAR 0 3
50209: RET
// export function GetBehemoths ( side ) ; begin
50210: LD_INT 0
50212: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50213: LD_ADDR_VAR 0 2
50217: PUSH
50218: LD_INT 22
50220: PUSH
50221: LD_VAR 0 1
50225: PUSH
50226: EMPTY
50227: LIST
50228: LIST
50229: PUSH
50230: LD_INT 31
50232: PUSH
50233: LD_INT 25
50235: PUSH
50236: EMPTY
50237: LIST
50238: LIST
50239: PUSH
50240: EMPTY
50241: LIST
50242: LIST
50243: PPUSH
50244: CALL_OW 69
50248: ST_TO_ADDR
// end ;
50249: LD_VAR 0 2
50253: RET
// export function Shuffle ( array ) ; var i , index ; begin
50254: LD_INT 0
50256: PPUSH
50257: PPUSH
50258: PPUSH
// result := [ ] ;
50259: LD_ADDR_VAR 0 2
50263: PUSH
50264: EMPTY
50265: ST_TO_ADDR
// if not array then
50266: LD_VAR 0 1
50270: NOT
50271: IFFALSE 50275
// exit ;
50273: GO 50374
// Randomize ;
50275: CALL_OW 10
// for i = array downto 1 do
50279: LD_ADDR_VAR 0 3
50283: PUSH
50284: DOUBLE
50285: LD_VAR 0 1
50289: INC
50290: ST_TO_ADDR
50291: LD_INT 1
50293: PUSH
50294: FOR_DOWNTO
50295: IFFALSE 50372
// begin index := rand ( 1 , array ) ;
50297: LD_ADDR_VAR 0 4
50301: PUSH
50302: LD_INT 1
50304: PPUSH
50305: LD_VAR 0 1
50309: PPUSH
50310: CALL_OW 12
50314: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50315: LD_ADDR_VAR 0 2
50319: PUSH
50320: LD_VAR 0 2
50324: PPUSH
50325: LD_VAR 0 2
50329: PUSH
50330: LD_INT 1
50332: PLUS
50333: PPUSH
50334: LD_VAR 0 1
50338: PUSH
50339: LD_VAR 0 4
50343: ARRAY
50344: PPUSH
50345: CALL_OW 2
50349: ST_TO_ADDR
// array := Delete ( array , index ) ;
50350: LD_ADDR_VAR 0 1
50354: PUSH
50355: LD_VAR 0 1
50359: PPUSH
50360: LD_VAR 0 4
50364: PPUSH
50365: CALL_OW 3
50369: ST_TO_ADDR
// end ;
50370: GO 50294
50372: POP
50373: POP
// end ;
50374: LD_VAR 0 2
50378: RET
// export function GetBaseMaterials ( base ) ; begin
50379: LD_INT 0
50381: PPUSH
// result := [ 0 , 0 , 0 ] ;
50382: LD_ADDR_VAR 0 2
50386: PUSH
50387: LD_INT 0
50389: PUSH
50390: LD_INT 0
50392: PUSH
50393: LD_INT 0
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: LIST
50400: ST_TO_ADDR
// if not base then
50401: LD_VAR 0 1
50405: NOT
50406: IFFALSE 50410
// exit ;
50408: GO 50459
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50410: LD_ADDR_VAR 0 2
50414: PUSH
50415: LD_VAR 0 1
50419: PPUSH
50420: LD_INT 1
50422: PPUSH
50423: CALL_OW 275
50427: PUSH
50428: LD_VAR 0 1
50432: PPUSH
50433: LD_INT 2
50435: PPUSH
50436: CALL_OW 275
50440: PUSH
50441: LD_VAR 0 1
50445: PPUSH
50446: LD_INT 3
50448: PPUSH
50449: CALL_OW 275
50453: PUSH
50454: EMPTY
50455: LIST
50456: LIST
50457: LIST
50458: ST_TO_ADDR
// end ;
50459: LD_VAR 0 2
50463: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50464: LD_INT 0
50466: PPUSH
50467: PPUSH
// result := array ;
50468: LD_ADDR_VAR 0 3
50472: PUSH
50473: LD_VAR 0 1
50477: ST_TO_ADDR
// if size > 0 then
50478: LD_VAR 0 2
50482: PUSH
50483: LD_INT 0
50485: GREATER
50486: IFFALSE 50532
// for i := array downto size do
50488: LD_ADDR_VAR 0 4
50492: PUSH
50493: DOUBLE
50494: LD_VAR 0 1
50498: INC
50499: ST_TO_ADDR
50500: LD_VAR 0 2
50504: PUSH
50505: FOR_DOWNTO
50506: IFFALSE 50530
// result := Delete ( result , result ) ;
50508: LD_ADDR_VAR 0 3
50512: PUSH
50513: LD_VAR 0 3
50517: PPUSH
50518: LD_VAR 0 3
50522: PPUSH
50523: CALL_OW 3
50527: ST_TO_ADDR
50528: GO 50505
50530: POP
50531: POP
// end ; end_of_file
50532: LD_VAR 0 3
50536: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50537: LD_INT 0
50539: PPUSH
50540: PPUSH
// skirmish := false ;
50541: LD_ADDR_EXP 57
50545: PUSH
50546: LD_INT 0
50548: ST_TO_ADDR
// debug_mc := false ;
50549: LD_ADDR_EXP 58
50553: PUSH
50554: LD_INT 0
50556: ST_TO_ADDR
// mc_bases := [ ] ;
50557: LD_ADDR_EXP 59
50561: PUSH
50562: EMPTY
50563: ST_TO_ADDR
// mc_sides := [ ] ;
50564: LD_ADDR_EXP 85
50568: PUSH
50569: EMPTY
50570: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50571: LD_ADDR_EXP 60
50575: PUSH
50576: EMPTY
50577: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50578: LD_ADDR_EXP 61
50582: PUSH
50583: EMPTY
50584: ST_TO_ADDR
// mc_need_heal := [ ] ;
50585: LD_ADDR_EXP 62
50589: PUSH
50590: EMPTY
50591: ST_TO_ADDR
// mc_healers := [ ] ;
50592: LD_ADDR_EXP 63
50596: PUSH
50597: EMPTY
50598: ST_TO_ADDR
// mc_build_list := [ ] ;
50599: LD_ADDR_EXP 64
50603: PUSH
50604: EMPTY
50605: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50606: LD_ADDR_EXP 91
50610: PUSH
50611: EMPTY
50612: ST_TO_ADDR
// mc_builders := [ ] ;
50613: LD_ADDR_EXP 65
50617: PUSH
50618: EMPTY
50619: ST_TO_ADDR
// mc_construct_list := [ ] ;
50620: LD_ADDR_EXP 66
50624: PUSH
50625: EMPTY
50626: ST_TO_ADDR
// mc_turret_list := [ ] ;
50627: LD_ADDR_EXP 67
50631: PUSH
50632: EMPTY
50633: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50634: LD_ADDR_EXP 68
50638: PUSH
50639: EMPTY
50640: ST_TO_ADDR
// mc_miners := [ ] ;
50641: LD_ADDR_EXP 73
50645: PUSH
50646: EMPTY
50647: ST_TO_ADDR
// mc_mines := [ ] ;
50648: LD_ADDR_EXP 72
50652: PUSH
50653: EMPTY
50654: ST_TO_ADDR
// mc_minefields := [ ] ;
50655: LD_ADDR_EXP 74
50659: PUSH
50660: EMPTY
50661: ST_TO_ADDR
// mc_crates := [ ] ;
50662: LD_ADDR_EXP 75
50666: PUSH
50667: EMPTY
50668: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50669: LD_ADDR_EXP 76
50673: PUSH
50674: EMPTY
50675: ST_TO_ADDR
// mc_crates_area := [ ] ;
50676: LD_ADDR_EXP 77
50680: PUSH
50681: EMPTY
50682: ST_TO_ADDR
// mc_vehicles := [ ] ;
50683: LD_ADDR_EXP 78
50687: PUSH
50688: EMPTY
50689: ST_TO_ADDR
// mc_attack := [ ] ;
50690: LD_ADDR_EXP 79
50694: PUSH
50695: EMPTY
50696: ST_TO_ADDR
// mc_produce := [ ] ;
50697: LD_ADDR_EXP 80
50701: PUSH
50702: EMPTY
50703: ST_TO_ADDR
// mc_defender := [ ] ;
50704: LD_ADDR_EXP 81
50708: PUSH
50709: EMPTY
50710: ST_TO_ADDR
// mc_parking := [ ] ;
50711: LD_ADDR_EXP 83
50715: PUSH
50716: EMPTY
50717: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50718: LD_ADDR_EXP 69
50722: PUSH
50723: EMPTY
50724: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50725: LD_ADDR_EXP 71
50729: PUSH
50730: EMPTY
50731: ST_TO_ADDR
// mc_scan := [ ] ;
50732: LD_ADDR_EXP 82
50736: PUSH
50737: EMPTY
50738: ST_TO_ADDR
// mc_scan_area := [ ] ;
50739: LD_ADDR_EXP 84
50743: PUSH
50744: EMPTY
50745: ST_TO_ADDR
// mc_tech := [ ] ;
50746: LD_ADDR_EXP 86
50750: PUSH
50751: EMPTY
50752: ST_TO_ADDR
// mc_class := [ ] ;
50753: LD_ADDR_EXP 100
50757: PUSH
50758: EMPTY
50759: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50760: LD_ADDR_EXP 101
50764: PUSH
50765: EMPTY
50766: ST_TO_ADDR
// end ;
50767: LD_VAR 0 1
50771: RET
// export function MC_Kill ( base ) ; begin
50772: LD_INT 0
50774: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50775: LD_ADDR_EXP 59
50779: PUSH
50780: LD_EXP 59
50784: PPUSH
50785: LD_VAR 0 1
50789: PPUSH
50790: EMPTY
50791: PPUSH
50792: CALL_OW 1
50796: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50797: LD_ADDR_EXP 60
50801: PUSH
50802: LD_EXP 60
50806: PPUSH
50807: LD_VAR 0 1
50811: PPUSH
50812: EMPTY
50813: PPUSH
50814: CALL_OW 1
50818: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50819: LD_ADDR_EXP 61
50823: PUSH
50824: LD_EXP 61
50828: PPUSH
50829: LD_VAR 0 1
50833: PPUSH
50834: EMPTY
50835: PPUSH
50836: CALL_OW 1
50840: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50841: LD_ADDR_EXP 62
50845: PUSH
50846: LD_EXP 62
50850: PPUSH
50851: LD_VAR 0 1
50855: PPUSH
50856: EMPTY
50857: PPUSH
50858: CALL_OW 1
50862: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50863: LD_ADDR_EXP 63
50867: PUSH
50868: LD_EXP 63
50872: PPUSH
50873: LD_VAR 0 1
50877: PPUSH
50878: EMPTY
50879: PPUSH
50880: CALL_OW 1
50884: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
50885: LD_ADDR_EXP 64
50889: PUSH
50890: LD_EXP 64
50894: PPUSH
50895: LD_VAR 0 1
50899: PPUSH
50900: EMPTY
50901: PPUSH
50902: CALL_OW 1
50906: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
50907: LD_ADDR_EXP 65
50911: PUSH
50912: LD_EXP 65
50916: PPUSH
50917: LD_VAR 0 1
50921: PPUSH
50922: EMPTY
50923: PPUSH
50924: CALL_OW 1
50928: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
50929: LD_ADDR_EXP 66
50933: PUSH
50934: LD_EXP 66
50938: PPUSH
50939: LD_VAR 0 1
50943: PPUSH
50944: EMPTY
50945: PPUSH
50946: CALL_OW 1
50950: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
50951: LD_ADDR_EXP 67
50955: PUSH
50956: LD_EXP 67
50960: PPUSH
50961: LD_VAR 0 1
50965: PPUSH
50966: EMPTY
50967: PPUSH
50968: CALL_OW 1
50972: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
50973: LD_ADDR_EXP 68
50977: PUSH
50978: LD_EXP 68
50982: PPUSH
50983: LD_VAR 0 1
50987: PPUSH
50988: EMPTY
50989: PPUSH
50990: CALL_OW 1
50994: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
50995: LD_ADDR_EXP 69
50999: PUSH
51000: LD_EXP 69
51004: PPUSH
51005: LD_VAR 0 1
51009: PPUSH
51010: EMPTY
51011: PPUSH
51012: CALL_OW 1
51016: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51017: LD_ADDR_EXP 70
51021: PUSH
51022: LD_EXP 70
51026: PPUSH
51027: LD_VAR 0 1
51031: PPUSH
51032: LD_INT 0
51034: PPUSH
51035: CALL_OW 1
51039: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51040: LD_ADDR_EXP 71
51044: PUSH
51045: LD_EXP 71
51049: PPUSH
51050: LD_VAR 0 1
51054: PPUSH
51055: EMPTY
51056: PPUSH
51057: CALL_OW 1
51061: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51062: LD_ADDR_EXP 72
51066: PUSH
51067: LD_EXP 72
51071: PPUSH
51072: LD_VAR 0 1
51076: PPUSH
51077: EMPTY
51078: PPUSH
51079: CALL_OW 1
51083: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51084: LD_ADDR_EXP 73
51088: PUSH
51089: LD_EXP 73
51093: PPUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: EMPTY
51100: PPUSH
51101: CALL_OW 1
51105: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51106: LD_ADDR_EXP 74
51110: PUSH
51111: LD_EXP 74
51115: PPUSH
51116: LD_VAR 0 1
51120: PPUSH
51121: EMPTY
51122: PPUSH
51123: CALL_OW 1
51127: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51128: LD_ADDR_EXP 75
51132: PUSH
51133: LD_EXP 75
51137: PPUSH
51138: LD_VAR 0 1
51142: PPUSH
51143: EMPTY
51144: PPUSH
51145: CALL_OW 1
51149: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51150: LD_ADDR_EXP 76
51154: PUSH
51155: LD_EXP 76
51159: PPUSH
51160: LD_VAR 0 1
51164: PPUSH
51165: EMPTY
51166: PPUSH
51167: CALL_OW 1
51171: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51172: LD_ADDR_EXP 77
51176: PUSH
51177: LD_EXP 77
51181: PPUSH
51182: LD_VAR 0 1
51186: PPUSH
51187: EMPTY
51188: PPUSH
51189: CALL_OW 1
51193: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51194: LD_ADDR_EXP 78
51198: PUSH
51199: LD_EXP 78
51203: PPUSH
51204: LD_VAR 0 1
51208: PPUSH
51209: EMPTY
51210: PPUSH
51211: CALL_OW 1
51215: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51216: LD_ADDR_EXP 79
51220: PUSH
51221: LD_EXP 79
51225: PPUSH
51226: LD_VAR 0 1
51230: PPUSH
51231: EMPTY
51232: PPUSH
51233: CALL_OW 1
51237: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51238: LD_ADDR_EXP 80
51242: PUSH
51243: LD_EXP 80
51247: PPUSH
51248: LD_VAR 0 1
51252: PPUSH
51253: EMPTY
51254: PPUSH
51255: CALL_OW 1
51259: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51260: LD_ADDR_EXP 81
51264: PUSH
51265: LD_EXP 81
51269: PPUSH
51270: LD_VAR 0 1
51274: PPUSH
51275: EMPTY
51276: PPUSH
51277: CALL_OW 1
51281: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51282: LD_ADDR_EXP 82
51286: PUSH
51287: LD_EXP 82
51291: PPUSH
51292: LD_VAR 0 1
51296: PPUSH
51297: EMPTY
51298: PPUSH
51299: CALL_OW 1
51303: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51304: LD_ADDR_EXP 83
51308: PUSH
51309: LD_EXP 83
51313: PPUSH
51314: LD_VAR 0 1
51318: PPUSH
51319: EMPTY
51320: PPUSH
51321: CALL_OW 1
51325: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51326: LD_ADDR_EXP 84
51330: PUSH
51331: LD_EXP 84
51335: PPUSH
51336: LD_VAR 0 1
51340: PPUSH
51341: EMPTY
51342: PPUSH
51343: CALL_OW 1
51347: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51348: LD_ADDR_EXP 86
51352: PUSH
51353: LD_EXP 86
51357: PPUSH
51358: LD_VAR 0 1
51362: PPUSH
51363: EMPTY
51364: PPUSH
51365: CALL_OW 1
51369: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51370: LD_ADDR_EXP 88
51374: PUSH
51375: LD_EXP 88
51379: PPUSH
51380: LD_VAR 0 1
51384: PPUSH
51385: EMPTY
51386: PPUSH
51387: CALL_OW 1
51391: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51392: LD_ADDR_EXP 89
51396: PUSH
51397: LD_EXP 89
51401: PPUSH
51402: LD_VAR 0 1
51406: PPUSH
51407: EMPTY
51408: PPUSH
51409: CALL_OW 1
51413: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51414: LD_ADDR_EXP 90
51418: PUSH
51419: LD_EXP 90
51423: PPUSH
51424: LD_VAR 0 1
51428: PPUSH
51429: EMPTY
51430: PPUSH
51431: CALL_OW 1
51435: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51436: LD_ADDR_EXP 91
51440: PUSH
51441: LD_EXP 91
51445: PPUSH
51446: LD_VAR 0 1
51450: PPUSH
51451: EMPTY
51452: PPUSH
51453: CALL_OW 1
51457: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51458: LD_ADDR_EXP 92
51462: PUSH
51463: LD_EXP 92
51467: PPUSH
51468: LD_VAR 0 1
51472: PPUSH
51473: EMPTY
51474: PPUSH
51475: CALL_OW 1
51479: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51480: LD_ADDR_EXP 93
51484: PUSH
51485: LD_EXP 93
51489: PPUSH
51490: LD_VAR 0 1
51494: PPUSH
51495: EMPTY
51496: PPUSH
51497: CALL_OW 1
51501: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51502: LD_ADDR_EXP 94
51506: PUSH
51507: LD_EXP 94
51511: PPUSH
51512: LD_VAR 0 1
51516: PPUSH
51517: EMPTY
51518: PPUSH
51519: CALL_OW 1
51523: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51524: LD_ADDR_EXP 95
51528: PUSH
51529: LD_EXP 95
51533: PPUSH
51534: LD_VAR 0 1
51538: PPUSH
51539: EMPTY
51540: PPUSH
51541: CALL_OW 1
51545: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51546: LD_ADDR_EXP 96
51550: PUSH
51551: LD_EXP 96
51555: PPUSH
51556: LD_VAR 0 1
51560: PPUSH
51561: EMPTY
51562: PPUSH
51563: CALL_OW 1
51567: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51568: LD_ADDR_EXP 97
51572: PUSH
51573: LD_EXP 97
51577: PPUSH
51578: LD_VAR 0 1
51582: PPUSH
51583: EMPTY
51584: PPUSH
51585: CALL_OW 1
51589: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51590: LD_ADDR_EXP 98
51594: PUSH
51595: LD_EXP 98
51599: PPUSH
51600: LD_VAR 0 1
51604: PPUSH
51605: EMPTY
51606: PPUSH
51607: CALL_OW 1
51611: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51612: LD_ADDR_EXP 99
51616: PUSH
51617: LD_EXP 99
51621: PPUSH
51622: LD_VAR 0 1
51626: PPUSH
51627: EMPTY
51628: PPUSH
51629: CALL_OW 1
51633: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51634: LD_ADDR_EXP 100
51638: PUSH
51639: LD_EXP 100
51643: PPUSH
51644: LD_VAR 0 1
51648: PPUSH
51649: EMPTY
51650: PPUSH
51651: CALL_OW 1
51655: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51656: LD_ADDR_EXP 101
51660: PUSH
51661: LD_EXP 101
51665: PPUSH
51666: LD_VAR 0 1
51670: PPUSH
51671: LD_INT 0
51673: PPUSH
51674: CALL_OW 1
51678: ST_TO_ADDR
// end ;
51679: LD_VAR 0 2
51683: RET
// export function MC_Add ( side , units ) ; var base ; begin
51684: LD_INT 0
51686: PPUSH
51687: PPUSH
// base := mc_bases + 1 ;
51688: LD_ADDR_VAR 0 4
51692: PUSH
51693: LD_EXP 59
51697: PUSH
51698: LD_INT 1
51700: PLUS
51701: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51702: LD_ADDR_EXP 85
51706: PUSH
51707: LD_EXP 85
51711: PPUSH
51712: LD_VAR 0 4
51716: PPUSH
51717: LD_VAR 0 1
51721: PPUSH
51722: CALL_OW 1
51726: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51727: LD_ADDR_EXP 59
51731: PUSH
51732: LD_EXP 59
51736: PPUSH
51737: LD_VAR 0 4
51741: PPUSH
51742: LD_VAR 0 2
51746: PPUSH
51747: CALL_OW 1
51751: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51752: LD_ADDR_EXP 60
51756: PUSH
51757: LD_EXP 60
51761: PPUSH
51762: LD_VAR 0 4
51766: PPUSH
51767: EMPTY
51768: PPUSH
51769: CALL_OW 1
51773: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51774: LD_ADDR_EXP 61
51778: PUSH
51779: LD_EXP 61
51783: PPUSH
51784: LD_VAR 0 4
51788: PPUSH
51789: EMPTY
51790: PPUSH
51791: CALL_OW 1
51795: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51796: LD_ADDR_EXP 62
51800: PUSH
51801: LD_EXP 62
51805: PPUSH
51806: LD_VAR 0 4
51810: PPUSH
51811: EMPTY
51812: PPUSH
51813: CALL_OW 1
51817: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51818: LD_ADDR_EXP 63
51822: PUSH
51823: LD_EXP 63
51827: PPUSH
51828: LD_VAR 0 4
51832: PPUSH
51833: EMPTY
51834: PPUSH
51835: CALL_OW 1
51839: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51840: LD_ADDR_EXP 64
51844: PUSH
51845: LD_EXP 64
51849: PPUSH
51850: LD_VAR 0 4
51854: PPUSH
51855: EMPTY
51856: PPUSH
51857: CALL_OW 1
51861: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51862: LD_ADDR_EXP 65
51866: PUSH
51867: LD_EXP 65
51871: PPUSH
51872: LD_VAR 0 4
51876: PPUSH
51877: EMPTY
51878: PPUSH
51879: CALL_OW 1
51883: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51884: LD_ADDR_EXP 66
51888: PUSH
51889: LD_EXP 66
51893: PPUSH
51894: LD_VAR 0 4
51898: PPUSH
51899: EMPTY
51900: PPUSH
51901: CALL_OW 1
51905: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51906: LD_ADDR_EXP 67
51910: PUSH
51911: LD_EXP 67
51915: PPUSH
51916: LD_VAR 0 4
51920: PPUSH
51921: EMPTY
51922: PPUSH
51923: CALL_OW 1
51927: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51928: LD_ADDR_EXP 68
51932: PUSH
51933: LD_EXP 68
51937: PPUSH
51938: LD_VAR 0 4
51942: PPUSH
51943: EMPTY
51944: PPUSH
51945: CALL_OW 1
51949: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51950: LD_ADDR_EXP 69
51954: PUSH
51955: LD_EXP 69
51959: PPUSH
51960: LD_VAR 0 4
51964: PPUSH
51965: EMPTY
51966: PPUSH
51967: CALL_OW 1
51971: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51972: LD_ADDR_EXP 70
51976: PUSH
51977: LD_EXP 70
51981: PPUSH
51982: LD_VAR 0 4
51986: PPUSH
51987: LD_INT 0
51989: PPUSH
51990: CALL_OW 1
51994: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51995: LD_ADDR_EXP 71
51999: PUSH
52000: LD_EXP 71
52004: PPUSH
52005: LD_VAR 0 4
52009: PPUSH
52010: EMPTY
52011: PPUSH
52012: CALL_OW 1
52016: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52017: LD_ADDR_EXP 72
52021: PUSH
52022: LD_EXP 72
52026: PPUSH
52027: LD_VAR 0 4
52031: PPUSH
52032: EMPTY
52033: PPUSH
52034: CALL_OW 1
52038: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52039: LD_ADDR_EXP 73
52043: PUSH
52044: LD_EXP 73
52048: PPUSH
52049: LD_VAR 0 4
52053: PPUSH
52054: EMPTY
52055: PPUSH
52056: CALL_OW 1
52060: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52061: LD_ADDR_EXP 74
52065: PUSH
52066: LD_EXP 74
52070: PPUSH
52071: LD_VAR 0 4
52075: PPUSH
52076: EMPTY
52077: PPUSH
52078: CALL_OW 1
52082: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52083: LD_ADDR_EXP 75
52087: PUSH
52088: LD_EXP 75
52092: PPUSH
52093: LD_VAR 0 4
52097: PPUSH
52098: EMPTY
52099: PPUSH
52100: CALL_OW 1
52104: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52105: LD_ADDR_EXP 76
52109: PUSH
52110: LD_EXP 76
52114: PPUSH
52115: LD_VAR 0 4
52119: PPUSH
52120: EMPTY
52121: PPUSH
52122: CALL_OW 1
52126: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52127: LD_ADDR_EXP 77
52131: PUSH
52132: LD_EXP 77
52136: PPUSH
52137: LD_VAR 0 4
52141: PPUSH
52142: EMPTY
52143: PPUSH
52144: CALL_OW 1
52148: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52149: LD_ADDR_EXP 78
52153: PUSH
52154: LD_EXP 78
52158: PPUSH
52159: LD_VAR 0 4
52163: PPUSH
52164: EMPTY
52165: PPUSH
52166: CALL_OW 1
52170: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52171: LD_ADDR_EXP 79
52175: PUSH
52176: LD_EXP 79
52180: PPUSH
52181: LD_VAR 0 4
52185: PPUSH
52186: EMPTY
52187: PPUSH
52188: CALL_OW 1
52192: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52193: LD_ADDR_EXP 80
52197: PUSH
52198: LD_EXP 80
52202: PPUSH
52203: LD_VAR 0 4
52207: PPUSH
52208: EMPTY
52209: PPUSH
52210: CALL_OW 1
52214: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52215: LD_ADDR_EXP 81
52219: PUSH
52220: LD_EXP 81
52224: PPUSH
52225: LD_VAR 0 4
52229: PPUSH
52230: EMPTY
52231: PPUSH
52232: CALL_OW 1
52236: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52237: LD_ADDR_EXP 82
52241: PUSH
52242: LD_EXP 82
52246: PPUSH
52247: LD_VAR 0 4
52251: PPUSH
52252: EMPTY
52253: PPUSH
52254: CALL_OW 1
52258: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52259: LD_ADDR_EXP 83
52263: PUSH
52264: LD_EXP 83
52268: PPUSH
52269: LD_VAR 0 4
52273: PPUSH
52274: EMPTY
52275: PPUSH
52276: CALL_OW 1
52280: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52281: LD_ADDR_EXP 84
52285: PUSH
52286: LD_EXP 84
52290: PPUSH
52291: LD_VAR 0 4
52295: PPUSH
52296: EMPTY
52297: PPUSH
52298: CALL_OW 1
52302: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52303: LD_ADDR_EXP 86
52307: PUSH
52308: LD_EXP 86
52312: PPUSH
52313: LD_VAR 0 4
52317: PPUSH
52318: EMPTY
52319: PPUSH
52320: CALL_OW 1
52324: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52325: LD_ADDR_EXP 88
52329: PUSH
52330: LD_EXP 88
52334: PPUSH
52335: LD_VAR 0 4
52339: PPUSH
52340: EMPTY
52341: PPUSH
52342: CALL_OW 1
52346: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52347: LD_ADDR_EXP 89
52351: PUSH
52352: LD_EXP 89
52356: PPUSH
52357: LD_VAR 0 4
52361: PPUSH
52362: EMPTY
52363: PPUSH
52364: CALL_OW 1
52368: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52369: LD_ADDR_EXP 90
52373: PUSH
52374: LD_EXP 90
52378: PPUSH
52379: LD_VAR 0 4
52383: PPUSH
52384: EMPTY
52385: PPUSH
52386: CALL_OW 1
52390: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52391: LD_ADDR_EXP 91
52395: PUSH
52396: LD_EXP 91
52400: PPUSH
52401: LD_VAR 0 4
52405: PPUSH
52406: EMPTY
52407: PPUSH
52408: CALL_OW 1
52412: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52413: LD_ADDR_EXP 92
52417: PUSH
52418: LD_EXP 92
52422: PPUSH
52423: LD_VAR 0 4
52427: PPUSH
52428: EMPTY
52429: PPUSH
52430: CALL_OW 1
52434: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52435: LD_ADDR_EXP 93
52439: PUSH
52440: LD_EXP 93
52444: PPUSH
52445: LD_VAR 0 4
52449: PPUSH
52450: EMPTY
52451: PPUSH
52452: CALL_OW 1
52456: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52457: LD_ADDR_EXP 94
52461: PUSH
52462: LD_EXP 94
52466: PPUSH
52467: LD_VAR 0 4
52471: PPUSH
52472: EMPTY
52473: PPUSH
52474: CALL_OW 1
52478: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52479: LD_ADDR_EXP 95
52483: PUSH
52484: LD_EXP 95
52488: PPUSH
52489: LD_VAR 0 4
52493: PPUSH
52494: EMPTY
52495: PPUSH
52496: CALL_OW 1
52500: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52501: LD_ADDR_EXP 96
52505: PUSH
52506: LD_EXP 96
52510: PPUSH
52511: LD_VAR 0 4
52515: PPUSH
52516: EMPTY
52517: PPUSH
52518: CALL_OW 1
52522: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52523: LD_ADDR_EXP 97
52527: PUSH
52528: LD_EXP 97
52532: PPUSH
52533: LD_VAR 0 4
52537: PPUSH
52538: EMPTY
52539: PPUSH
52540: CALL_OW 1
52544: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52545: LD_ADDR_EXP 98
52549: PUSH
52550: LD_EXP 98
52554: PPUSH
52555: LD_VAR 0 4
52559: PPUSH
52560: EMPTY
52561: PPUSH
52562: CALL_OW 1
52566: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52567: LD_ADDR_EXP 99
52571: PUSH
52572: LD_EXP 99
52576: PPUSH
52577: LD_VAR 0 4
52581: PPUSH
52582: EMPTY
52583: PPUSH
52584: CALL_OW 1
52588: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52589: LD_ADDR_EXP 100
52593: PUSH
52594: LD_EXP 100
52598: PPUSH
52599: LD_VAR 0 4
52603: PPUSH
52604: EMPTY
52605: PPUSH
52606: CALL_OW 1
52610: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52611: LD_ADDR_EXP 101
52615: PUSH
52616: LD_EXP 101
52620: PPUSH
52621: LD_VAR 0 4
52625: PPUSH
52626: LD_INT 0
52628: PPUSH
52629: CALL_OW 1
52633: ST_TO_ADDR
// result := base ;
52634: LD_ADDR_VAR 0 3
52638: PUSH
52639: LD_VAR 0 4
52643: ST_TO_ADDR
// end ;
52644: LD_VAR 0 3
52648: RET
// export function MC_Start ( ) ; var i ; begin
52649: LD_INT 0
52651: PPUSH
52652: PPUSH
// for i = 1 to mc_bases do
52653: LD_ADDR_VAR 0 2
52657: PUSH
52658: DOUBLE
52659: LD_INT 1
52661: DEC
52662: ST_TO_ADDR
52663: LD_EXP 59
52667: PUSH
52668: FOR_TO
52669: IFFALSE 53746
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52671: LD_ADDR_EXP 59
52675: PUSH
52676: LD_EXP 59
52680: PPUSH
52681: LD_VAR 0 2
52685: PPUSH
52686: LD_EXP 59
52690: PUSH
52691: LD_VAR 0 2
52695: ARRAY
52696: PUSH
52697: LD_INT 0
52699: DIFF
52700: PPUSH
52701: CALL_OW 1
52705: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52706: LD_ADDR_EXP 60
52710: PUSH
52711: LD_EXP 60
52715: PPUSH
52716: LD_VAR 0 2
52720: PPUSH
52721: EMPTY
52722: PPUSH
52723: CALL_OW 1
52727: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52728: LD_ADDR_EXP 61
52732: PUSH
52733: LD_EXP 61
52737: PPUSH
52738: LD_VAR 0 2
52742: PPUSH
52743: EMPTY
52744: PPUSH
52745: CALL_OW 1
52749: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52750: LD_ADDR_EXP 62
52754: PUSH
52755: LD_EXP 62
52759: PPUSH
52760: LD_VAR 0 2
52764: PPUSH
52765: EMPTY
52766: PPUSH
52767: CALL_OW 1
52771: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52772: LD_ADDR_EXP 63
52776: PUSH
52777: LD_EXP 63
52781: PPUSH
52782: LD_VAR 0 2
52786: PPUSH
52787: EMPTY
52788: PUSH
52789: EMPTY
52790: PUSH
52791: EMPTY
52792: LIST
52793: LIST
52794: PPUSH
52795: CALL_OW 1
52799: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52800: LD_ADDR_EXP 64
52804: PUSH
52805: LD_EXP 64
52809: PPUSH
52810: LD_VAR 0 2
52814: PPUSH
52815: EMPTY
52816: PPUSH
52817: CALL_OW 1
52821: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52822: LD_ADDR_EXP 91
52826: PUSH
52827: LD_EXP 91
52831: PPUSH
52832: LD_VAR 0 2
52836: PPUSH
52837: EMPTY
52838: PPUSH
52839: CALL_OW 1
52843: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52844: LD_ADDR_EXP 65
52848: PUSH
52849: LD_EXP 65
52853: PPUSH
52854: LD_VAR 0 2
52858: PPUSH
52859: EMPTY
52860: PPUSH
52861: CALL_OW 1
52865: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52866: LD_ADDR_EXP 66
52870: PUSH
52871: LD_EXP 66
52875: PPUSH
52876: LD_VAR 0 2
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
52888: LD_ADDR_EXP 67
52892: PUSH
52893: LD_EXP 67
52897: PPUSH
52898: LD_VAR 0 2
52902: PPUSH
52903: LD_EXP 59
52907: PUSH
52908: LD_VAR 0 2
52912: ARRAY
52913: PPUSH
52914: LD_INT 2
52916: PUSH
52917: LD_INT 30
52919: PUSH
52920: LD_INT 32
52922: PUSH
52923: EMPTY
52924: LIST
52925: LIST
52926: PUSH
52927: LD_INT 30
52929: PUSH
52930: LD_INT 33
52932: PUSH
52933: EMPTY
52934: LIST
52935: LIST
52936: PUSH
52937: EMPTY
52938: LIST
52939: LIST
52940: LIST
52941: PPUSH
52942: CALL_OW 72
52946: PPUSH
52947: CALL_OW 1
52951: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
52952: LD_ADDR_EXP 68
52956: PUSH
52957: LD_EXP 68
52961: PPUSH
52962: LD_VAR 0 2
52966: PPUSH
52967: LD_EXP 59
52971: PUSH
52972: LD_VAR 0 2
52976: ARRAY
52977: PPUSH
52978: LD_INT 2
52980: PUSH
52981: LD_INT 30
52983: PUSH
52984: LD_INT 32
52986: PUSH
52987: EMPTY
52988: LIST
52989: LIST
52990: PUSH
52991: LD_INT 30
52993: PUSH
52994: LD_INT 31
52996: PUSH
52997: EMPTY
52998: LIST
52999: LIST
53000: PUSH
53001: EMPTY
53002: LIST
53003: LIST
53004: LIST
53005: PUSH
53006: LD_INT 58
53008: PUSH
53009: EMPTY
53010: LIST
53011: PUSH
53012: EMPTY
53013: LIST
53014: LIST
53015: PPUSH
53016: CALL_OW 72
53020: PPUSH
53021: CALL_OW 1
53025: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53026: LD_ADDR_EXP 69
53030: PUSH
53031: LD_EXP 69
53035: PPUSH
53036: LD_VAR 0 2
53040: PPUSH
53041: EMPTY
53042: PPUSH
53043: CALL_OW 1
53047: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53048: LD_ADDR_EXP 73
53052: PUSH
53053: LD_EXP 73
53057: PPUSH
53058: LD_VAR 0 2
53062: PPUSH
53063: EMPTY
53064: PPUSH
53065: CALL_OW 1
53069: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53070: LD_ADDR_EXP 72
53074: PUSH
53075: LD_EXP 72
53079: PPUSH
53080: LD_VAR 0 2
53084: PPUSH
53085: EMPTY
53086: PPUSH
53087: CALL_OW 1
53091: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53092: LD_ADDR_EXP 74
53096: PUSH
53097: LD_EXP 74
53101: PPUSH
53102: LD_VAR 0 2
53106: PPUSH
53107: EMPTY
53108: PPUSH
53109: CALL_OW 1
53113: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53114: LD_ADDR_EXP 75
53118: PUSH
53119: LD_EXP 75
53123: PPUSH
53124: LD_VAR 0 2
53128: PPUSH
53129: EMPTY
53130: PPUSH
53131: CALL_OW 1
53135: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53136: LD_ADDR_EXP 76
53140: PUSH
53141: LD_EXP 76
53145: PPUSH
53146: LD_VAR 0 2
53150: PPUSH
53151: EMPTY
53152: PPUSH
53153: CALL_OW 1
53157: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53158: LD_ADDR_EXP 77
53162: PUSH
53163: LD_EXP 77
53167: PPUSH
53168: LD_VAR 0 2
53172: PPUSH
53173: EMPTY
53174: PPUSH
53175: CALL_OW 1
53179: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53180: LD_ADDR_EXP 78
53184: PUSH
53185: LD_EXP 78
53189: PPUSH
53190: LD_VAR 0 2
53194: PPUSH
53195: EMPTY
53196: PPUSH
53197: CALL_OW 1
53201: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53202: LD_ADDR_EXP 79
53206: PUSH
53207: LD_EXP 79
53211: PPUSH
53212: LD_VAR 0 2
53216: PPUSH
53217: EMPTY
53218: PPUSH
53219: CALL_OW 1
53223: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53224: LD_ADDR_EXP 80
53228: PUSH
53229: LD_EXP 80
53233: PPUSH
53234: LD_VAR 0 2
53238: PPUSH
53239: EMPTY
53240: PPUSH
53241: CALL_OW 1
53245: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53246: LD_ADDR_EXP 81
53250: PUSH
53251: LD_EXP 81
53255: PPUSH
53256: LD_VAR 0 2
53260: PPUSH
53261: EMPTY
53262: PPUSH
53263: CALL_OW 1
53267: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53268: LD_ADDR_EXP 70
53272: PUSH
53273: LD_EXP 70
53277: PPUSH
53278: LD_VAR 0 2
53282: PPUSH
53283: LD_INT 0
53285: PPUSH
53286: CALL_OW 1
53290: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53291: LD_ADDR_EXP 83
53295: PUSH
53296: LD_EXP 83
53300: PPUSH
53301: LD_VAR 0 2
53305: PPUSH
53306: LD_INT 0
53308: PPUSH
53309: CALL_OW 1
53313: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53314: LD_ADDR_EXP 71
53318: PUSH
53319: LD_EXP 71
53323: PPUSH
53324: LD_VAR 0 2
53328: PPUSH
53329: EMPTY
53330: PPUSH
53331: CALL_OW 1
53335: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53336: LD_ADDR_EXP 82
53340: PUSH
53341: LD_EXP 82
53345: PPUSH
53346: LD_VAR 0 2
53350: PPUSH
53351: LD_INT 0
53353: PPUSH
53354: CALL_OW 1
53358: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53359: LD_ADDR_EXP 84
53363: PUSH
53364: LD_EXP 84
53368: PPUSH
53369: LD_VAR 0 2
53373: PPUSH
53374: EMPTY
53375: PPUSH
53376: CALL_OW 1
53380: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53381: LD_ADDR_EXP 87
53385: PUSH
53386: LD_EXP 87
53390: PPUSH
53391: LD_VAR 0 2
53395: PPUSH
53396: LD_INT 0
53398: PPUSH
53399: CALL_OW 1
53403: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53404: LD_ADDR_EXP 88
53408: PUSH
53409: LD_EXP 88
53413: PPUSH
53414: LD_VAR 0 2
53418: PPUSH
53419: EMPTY
53420: PPUSH
53421: CALL_OW 1
53425: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53426: LD_ADDR_EXP 89
53430: PUSH
53431: LD_EXP 89
53435: PPUSH
53436: LD_VAR 0 2
53440: PPUSH
53441: EMPTY
53442: PPUSH
53443: CALL_OW 1
53447: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53448: LD_ADDR_EXP 90
53452: PUSH
53453: LD_EXP 90
53457: PPUSH
53458: LD_VAR 0 2
53462: PPUSH
53463: EMPTY
53464: PPUSH
53465: CALL_OW 1
53469: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53470: LD_ADDR_EXP 92
53474: PUSH
53475: LD_EXP 92
53479: PPUSH
53480: LD_VAR 0 2
53484: PPUSH
53485: LD_EXP 59
53489: PUSH
53490: LD_VAR 0 2
53494: ARRAY
53495: PPUSH
53496: LD_INT 2
53498: PUSH
53499: LD_INT 30
53501: PUSH
53502: LD_INT 6
53504: PUSH
53505: EMPTY
53506: LIST
53507: LIST
53508: PUSH
53509: LD_INT 30
53511: PUSH
53512: LD_INT 7
53514: PUSH
53515: EMPTY
53516: LIST
53517: LIST
53518: PUSH
53519: LD_INT 30
53521: PUSH
53522: LD_INT 8
53524: PUSH
53525: EMPTY
53526: LIST
53527: LIST
53528: PUSH
53529: EMPTY
53530: LIST
53531: LIST
53532: LIST
53533: LIST
53534: PPUSH
53535: CALL_OW 72
53539: PPUSH
53540: CALL_OW 1
53544: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53545: LD_ADDR_EXP 93
53549: PUSH
53550: LD_EXP 93
53554: PPUSH
53555: LD_VAR 0 2
53559: PPUSH
53560: EMPTY
53561: PPUSH
53562: CALL_OW 1
53566: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53567: LD_ADDR_EXP 94
53571: PUSH
53572: LD_EXP 94
53576: PPUSH
53577: LD_VAR 0 2
53581: PPUSH
53582: EMPTY
53583: PPUSH
53584: CALL_OW 1
53588: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53589: LD_ADDR_EXP 95
53593: PUSH
53594: LD_EXP 95
53598: PPUSH
53599: LD_VAR 0 2
53603: PPUSH
53604: EMPTY
53605: PPUSH
53606: CALL_OW 1
53610: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53611: LD_ADDR_EXP 96
53615: PUSH
53616: LD_EXP 96
53620: PPUSH
53621: LD_VAR 0 2
53625: PPUSH
53626: EMPTY
53627: PPUSH
53628: CALL_OW 1
53632: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53633: LD_ADDR_EXP 97
53637: PUSH
53638: LD_EXP 97
53642: PPUSH
53643: LD_VAR 0 2
53647: PPUSH
53648: EMPTY
53649: PPUSH
53650: CALL_OW 1
53654: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53655: LD_ADDR_EXP 98
53659: PUSH
53660: LD_EXP 98
53664: PPUSH
53665: LD_VAR 0 2
53669: PPUSH
53670: EMPTY
53671: PPUSH
53672: CALL_OW 1
53676: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53677: LD_ADDR_EXP 99
53681: PUSH
53682: LD_EXP 99
53686: PPUSH
53687: LD_VAR 0 2
53691: PPUSH
53692: EMPTY
53693: PPUSH
53694: CALL_OW 1
53698: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53699: LD_ADDR_EXP 100
53703: PUSH
53704: LD_EXP 100
53708: PPUSH
53709: LD_VAR 0 2
53713: PPUSH
53714: EMPTY
53715: PPUSH
53716: CALL_OW 1
53720: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53721: LD_ADDR_EXP 101
53725: PUSH
53726: LD_EXP 101
53730: PPUSH
53731: LD_VAR 0 2
53735: PPUSH
53736: LD_INT 0
53738: PPUSH
53739: CALL_OW 1
53743: ST_TO_ADDR
// end ;
53744: GO 52668
53746: POP
53747: POP
// MC_InitSides ( ) ;
53748: CALL 54034 0 0
// MC_InitResearch ( ) ;
53752: CALL 53773 0 0
// CustomInitMacro ( ) ;
53756: CALL 181 0 0
// skirmish := true ;
53760: LD_ADDR_EXP 57
53764: PUSH
53765: LD_INT 1
53767: ST_TO_ADDR
// end ;
53768: LD_VAR 0 1
53772: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53773: LD_INT 0
53775: PPUSH
53776: PPUSH
53777: PPUSH
53778: PPUSH
53779: PPUSH
53780: PPUSH
// if not mc_bases then
53781: LD_EXP 59
53785: NOT
53786: IFFALSE 53790
// exit ;
53788: GO 54029
// for i = 1 to 8 do
53790: LD_ADDR_VAR 0 2
53794: PUSH
53795: DOUBLE
53796: LD_INT 1
53798: DEC
53799: ST_TO_ADDR
53800: LD_INT 8
53802: PUSH
53803: FOR_TO
53804: IFFALSE 53830
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53806: LD_ADDR_EXP 86
53810: PUSH
53811: LD_EXP 86
53815: PPUSH
53816: LD_VAR 0 2
53820: PPUSH
53821: EMPTY
53822: PPUSH
53823: CALL_OW 1
53827: ST_TO_ADDR
53828: GO 53803
53830: POP
53831: POP
// tmp := [ ] ;
53832: LD_ADDR_VAR 0 5
53836: PUSH
53837: EMPTY
53838: ST_TO_ADDR
// for i = 1 to mc_sides do
53839: LD_ADDR_VAR 0 2
53843: PUSH
53844: DOUBLE
53845: LD_INT 1
53847: DEC
53848: ST_TO_ADDR
53849: LD_EXP 85
53853: PUSH
53854: FOR_TO
53855: IFFALSE 53913
// if not mc_sides [ i ] in tmp then
53857: LD_EXP 85
53861: PUSH
53862: LD_VAR 0 2
53866: ARRAY
53867: PUSH
53868: LD_VAR 0 5
53872: IN
53873: NOT
53874: IFFALSE 53911
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53876: LD_ADDR_VAR 0 5
53880: PUSH
53881: LD_VAR 0 5
53885: PPUSH
53886: LD_VAR 0 5
53890: PUSH
53891: LD_INT 1
53893: PLUS
53894: PPUSH
53895: LD_EXP 85
53899: PUSH
53900: LD_VAR 0 2
53904: ARRAY
53905: PPUSH
53906: CALL_OW 2
53910: ST_TO_ADDR
53911: GO 53854
53913: POP
53914: POP
// if not tmp then
53915: LD_VAR 0 5
53919: NOT
53920: IFFALSE 53924
// exit ;
53922: GO 54029
// for j in tmp do
53924: LD_ADDR_VAR 0 3
53928: PUSH
53929: LD_VAR 0 5
53933: PUSH
53934: FOR_IN
53935: IFFALSE 54027
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
53937: LD_ADDR_VAR 0 6
53941: PUSH
53942: LD_INT 22
53944: PUSH
53945: LD_VAR 0 3
53949: PUSH
53950: EMPTY
53951: LIST
53952: LIST
53953: PPUSH
53954: CALL_OW 69
53958: ST_TO_ADDR
// if not un then
53959: LD_VAR 0 6
53963: NOT
53964: IFFALSE 53968
// continue ;
53966: GO 53934
// nation := GetNation ( un [ 1 ] ) ;
53968: LD_ADDR_VAR 0 4
53972: PUSH
53973: LD_VAR 0 6
53977: PUSH
53978: LD_INT 1
53980: ARRAY
53981: PPUSH
53982: CALL_OW 248
53986: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
53987: LD_ADDR_EXP 86
53991: PUSH
53992: LD_EXP 86
53996: PPUSH
53997: LD_VAR 0 3
54001: PPUSH
54002: LD_VAR 0 3
54006: PPUSH
54007: LD_VAR 0 4
54011: PPUSH
54012: LD_INT 1
54014: PPUSH
54015: CALL 14355 0 3
54019: PPUSH
54020: CALL_OW 1
54024: ST_TO_ADDR
// end ;
54025: GO 53934
54027: POP
54028: POP
// end ;
54029: LD_VAR 0 1
54033: RET
// export function MC_InitSides ( ) ; var i ; begin
54034: LD_INT 0
54036: PPUSH
54037: PPUSH
// if not mc_bases then
54038: LD_EXP 59
54042: NOT
54043: IFFALSE 54047
// exit ;
54045: GO 54121
// for i = 1 to mc_bases do
54047: LD_ADDR_VAR 0 2
54051: PUSH
54052: DOUBLE
54053: LD_INT 1
54055: DEC
54056: ST_TO_ADDR
54057: LD_EXP 59
54061: PUSH
54062: FOR_TO
54063: IFFALSE 54119
// if mc_bases [ i ] then
54065: LD_EXP 59
54069: PUSH
54070: LD_VAR 0 2
54074: ARRAY
54075: IFFALSE 54117
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54077: LD_ADDR_EXP 85
54081: PUSH
54082: LD_EXP 85
54086: PPUSH
54087: LD_VAR 0 2
54091: PPUSH
54092: LD_EXP 59
54096: PUSH
54097: LD_VAR 0 2
54101: ARRAY
54102: PUSH
54103: LD_INT 1
54105: ARRAY
54106: PPUSH
54107: CALL_OW 255
54111: PPUSH
54112: CALL_OW 1
54116: ST_TO_ADDR
54117: GO 54062
54119: POP
54120: POP
// end ;
54121: LD_VAR 0 1
54125: RET
// every 0 0$01 trigger skirmish do
54126: LD_EXP 57
54130: IFFALSE 54284
54132: GO 54134
54134: DISABLE
// begin enable ;
54135: ENABLE
// MC_CheckBuildings ( ) ;
54136: CALL 58782 0 0
// MC_CheckPeopleLife ( ) ;
54140: CALL 58907 0 0
// RaiseSailEvent ( 100 ) ;
54144: LD_INT 100
54146: PPUSH
54147: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54151: LD_INT 103
54153: PPUSH
54154: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54158: LD_INT 104
54160: PPUSH
54161: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54165: LD_INT 105
54167: PPUSH
54168: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54172: LD_INT 106
54174: PPUSH
54175: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54179: LD_INT 107
54181: PPUSH
54182: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54186: LD_INT 108
54188: PPUSH
54189: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54193: LD_INT 109
54195: PPUSH
54196: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54200: LD_INT 110
54202: PPUSH
54203: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54207: LD_INT 111
54209: PPUSH
54210: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54214: LD_INT 112
54216: PPUSH
54217: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54221: LD_INT 113
54223: PPUSH
54224: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54228: LD_INT 120
54230: PPUSH
54231: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54235: LD_INT 121
54237: PPUSH
54238: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54242: LD_INT 122
54244: PPUSH
54245: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54249: LD_INT 123
54251: PPUSH
54252: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54256: LD_INT 124
54258: PPUSH
54259: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54263: LD_INT 125
54265: PPUSH
54266: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54270: LD_INT 126
54272: PPUSH
54273: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54277: LD_INT 200
54279: PPUSH
54280: CALL_OW 427
// end ;
54284: END
// on SailEvent ( event ) do begin if event < 100 then
54285: LD_VAR 0 1
54289: PUSH
54290: LD_INT 100
54292: LESS
54293: IFFALSE 54304
// CustomEvent ( event ) ;
54295: LD_VAR 0 1
54299: PPUSH
54300: CALL 13013 0 1
// if event = 100 then
54304: LD_VAR 0 1
54308: PUSH
54309: LD_INT 100
54311: EQUAL
54312: IFFALSE 54318
// MC_ClassManager ( ) ;
54314: CALL 54710 0 0
// if event = 101 then
54318: LD_VAR 0 1
54322: PUSH
54323: LD_INT 101
54325: EQUAL
54326: IFFALSE 54332
// MC_RepairBuildings ( ) ;
54328: CALL 59492 0 0
// if event = 102 then
54332: LD_VAR 0 1
54336: PUSH
54337: LD_INT 102
54339: EQUAL
54340: IFFALSE 54346
// MC_Heal ( ) ;
54342: CALL 60351 0 0
// if event = 103 then
54346: LD_VAR 0 1
54350: PUSH
54351: LD_INT 103
54353: EQUAL
54354: IFFALSE 54360
// MC_Build ( ) ;
54356: CALL 60773 0 0
// if event = 104 then
54360: LD_VAR 0 1
54364: PUSH
54365: LD_INT 104
54367: EQUAL
54368: IFFALSE 54374
// MC_TurretWeapon ( ) ;
54370: CALL 62386 0 0
// if event = 105 then
54374: LD_VAR 0 1
54378: PUSH
54379: LD_INT 105
54381: EQUAL
54382: IFFALSE 54388
// MC_BuildUpgrade ( ) ;
54384: CALL 61937 0 0
// if event = 106 then
54388: LD_VAR 0 1
54392: PUSH
54393: LD_INT 106
54395: EQUAL
54396: IFFALSE 54402
// MC_PlantMines ( ) ;
54398: CALL 62816 0 0
// if event = 107 then
54402: LD_VAR 0 1
54406: PUSH
54407: LD_INT 107
54409: EQUAL
54410: IFFALSE 54416
// MC_CollectCrates ( ) ;
54412: CALL 63614 0 0
// if event = 108 then
54416: LD_VAR 0 1
54420: PUSH
54421: LD_INT 108
54423: EQUAL
54424: IFFALSE 54430
// MC_LinkRemoteControl ( ) ;
54426: CALL 65390 0 0
// if event = 109 then
54430: LD_VAR 0 1
54434: PUSH
54435: LD_INT 109
54437: EQUAL
54438: IFFALSE 54444
// MC_ProduceVehicle ( ) ;
54440: CALL 65571 0 0
// if event = 110 then
54444: LD_VAR 0 1
54448: PUSH
54449: LD_INT 110
54451: EQUAL
54452: IFFALSE 54458
// MC_SendAttack ( ) ;
54454: CALL 66037 0 0
// if event = 111 then
54458: LD_VAR 0 1
54462: PUSH
54463: LD_INT 111
54465: EQUAL
54466: IFFALSE 54472
// MC_Defend ( ) ;
54468: CALL 66145 0 0
// if event = 112 then
54472: LD_VAR 0 1
54476: PUSH
54477: LD_INT 112
54479: EQUAL
54480: IFFALSE 54486
// MC_Research ( ) ;
54482: CALL 66750 0 0
// if event = 113 then
54486: LD_VAR 0 1
54490: PUSH
54491: LD_INT 113
54493: EQUAL
54494: IFFALSE 54500
// MC_MinesTrigger ( ) ;
54496: CALL 67864 0 0
// if event = 120 then
54500: LD_VAR 0 1
54504: PUSH
54505: LD_INT 120
54507: EQUAL
54508: IFFALSE 54514
// MC_RepairVehicle ( ) ;
54510: CALL 67963 0 0
// if event = 121 then
54514: LD_VAR 0 1
54518: PUSH
54519: LD_INT 121
54521: EQUAL
54522: IFFALSE 54528
// MC_TameApe ( ) ;
54524: CALL 68693 0 0
// if event = 122 then
54528: LD_VAR 0 1
54532: PUSH
54533: LD_INT 122
54535: EQUAL
54536: IFFALSE 54542
// MC_ChangeApeClass ( ) ;
54538: CALL 69522 0 0
// if event = 123 then
54542: LD_VAR 0 1
54546: PUSH
54547: LD_INT 123
54549: EQUAL
54550: IFFALSE 54556
// MC_Bazooka ( ) ;
54552: CALL 70172 0 0
// if event = 124 then
54556: LD_VAR 0 1
54560: PUSH
54561: LD_INT 124
54563: EQUAL
54564: IFFALSE 54570
// MC_TeleportExit ( ) ;
54566: CALL 70370 0 0
// if event = 125 then
54570: LD_VAR 0 1
54574: PUSH
54575: LD_INT 125
54577: EQUAL
54578: IFFALSE 54584
// MC_Deposits ( ) ;
54580: CALL 71017 0 0
// if event = 126 then
54584: LD_VAR 0 1
54588: PUSH
54589: LD_INT 126
54591: EQUAL
54592: IFFALSE 54598
// MC_RemoteDriver ( ) ;
54594: CALL 71642 0 0
// if event = 200 then
54598: LD_VAR 0 1
54602: PUSH
54603: LD_INT 200
54605: EQUAL
54606: IFFALSE 54612
// MC_Idle ( ) ;
54608: CALL 73591 0 0
// end ;
54612: PPOPN 1
54614: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54615: LD_INT 0
54617: PPUSH
54618: PPUSH
// if not mc_bases [ base ] or not tag then
54619: LD_EXP 59
54623: PUSH
54624: LD_VAR 0 1
54628: ARRAY
54629: NOT
54630: PUSH
54631: LD_VAR 0 2
54635: NOT
54636: OR
54637: IFFALSE 54641
// exit ;
54639: GO 54705
// for i in mc_bases [ base ] union mc_ape [ base ] do
54641: LD_ADDR_VAR 0 4
54645: PUSH
54646: LD_EXP 59
54650: PUSH
54651: LD_VAR 0 1
54655: ARRAY
54656: PUSH
54657: LD_EXP 88
54661: PUSH
54662: LD_VAR 0 1
54666: ARRAY
54667: UNION
54668: PUSH
54669: FOR_IN
54670: IFFALSE 54703
// if GetTag ( i ) = tag then
54672: LD_VAR 0 4
54676: PPUSH
54677: CALL_OW 110
54681: PUSH
54682: LD_VAR 0 2
54686: EQUAL
54687: IFFALSE 54701
// SetTag ( i , 0 ) ;
54689: LD_VAR 0 4
54693: PPUSH
54694: LD_INT 0
54696: PPUSH
54697: CALL_OW 109
54701: GO 54669
54703: POP
54704: POP
// end ;
54705: LD_VAR 0 3
54709: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54710: LD_INT 0
54712: PPUSH
54713: PPUSH
54714: PPUSH
54715: PPUSH
54716: PPUSH
54717: PPUSH
54718: PPUSH
54719: PPUSH
// if not mc_bases then
54720: LD_EXP 59
54724: NOT
54725: IFFALSE 54729
// exit ;
54727: GO 55187
// for i = 1 to mc_bases do
54729: LD_ADDR_VAR 0 2
54733: PUSH
54734: DOUBLE
54735: LD_INT 1
54737: DEC
54738: ST_TO_ADDR
54739: LD_EXP 59
54743: PUSH
54744: FOR_TO
54745: IFFALSE 55185
// begin tmp := MC_ClassCheckReq ( i ) ;
54747: LD_ADDR_VAR 0 4
54751: PUSH
54752: LD_VAR 0 2
54756: PPUSH
54757: CALL 55192 0 1
54761: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54762: LD_ADDR_EXP 100
54766: PUSH
54767: LD_EXP 100
54771: PPUSH
54772: LD_VAR 0 2
54776: PPUSH
54777: LD_VAR 0 4
54781: PPUSH
54782: CALL_OW 1
54786: ST_TO_ADDR
// if not tmp then
54787: LD_VAR 0 4
54791: NOT
54792: IFFALSE 54796
// continue ;
54794: GO 54744
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54796: LD_ADDR_VAR 0 6
54800: PUSH
54801: LD_EXP 59
54805: PUSH
54806: LD_VAR 0 2
54810: ARRAY
54811: PPUSH
54812: LD_INT 2
54814: PUSH
54815: LD_INT 30
54817: PUSH
54818: LD_INT 4
54820: PUSH
54821: EMPTY
54822: LIST
54823: LIST
54824: PUSH
54825: LD_INT 30
54827: PUSH
54828: LD_INT 5
54830: PUSH
54831: EMPTY
54832: LIST
54833: LIST
54834: PUSH
54835: EMPTY
54836: LIST
54837: LIST
54838: LIST
54839: PPUSH
54840: CALL_OW 72
54844: PUSH
54845: LD_EXP 59
54849: PUSH
54850: LD_VAR 0 2
54854: ARRAY
54855: PPUSH
54856: LD_INT 2
54858: PUSH
54859: LD_INT 30
54861: PUSH
54862: LD_INT 0
54864: PUSH
54865: EMPTY
54866: LIST
54867: LIST
54868: PUSH
54869: LD_INT 30
54871: PUSH
54872: LD_INT 1
54874: PUSH
54875: EMPTY
54876: LIST
54877: LIST
54878: PUSH
54879: EMPTY
54880: LIST
54881: LIST
54882: LIST
54883: PPUSH
54884: CALL_OW 72
54888: PUSH
54889: LD_EXP 59
54893: PUSH
54894: LD_VAR 0 2
54898: ARRAY
54899: PPUSH
54900: LD_INT 30
54902: PUSH
54903: LD_INT 3
54905: PUSH
54906: EMPTY
54907: LIST
54908: LIST
54909: PPUSH
54910: CALL_OW 72
54914: PUSH
54915: LD_EXP 59
54919: PUSH
54920: LD_VAR 0 2
54924: ARRAY
54925: PPUSH
54926: LD_INT 2
54928: PUSH
54929: LD_INT 30
54931: PUSH
54932: LD_INT 6
54934: PUSH
54935: EMPTY
54936: LIST
54937: LIST
54938: PUSH
54939: LD_INT 30
54941: PUSH
54942: LD_INT 7
54944: PUSH
54945: EMPTY
54946: LIST
54947: LIST
54948: PUSH
54949: LD_INT 30
54951: PUSH
54952: LD_INT 8
54954: PUSH
54955: EMPTY
54956: LIST
54957: LIST
54958: PUSH
54959: EMPTY
54960: LIST
54961: LIST
54962: LIST
54963: LIST
54964: PPUSH
54965: CALL_OW 72
54969: PUSH
54970: EMPTY
54971: LIST
54972: LIST
54973: LIST
54974: LIST
54975: ST_TO_ADDR
// for j = 1 to 4 do
54976: LD_ADDR_VAR 0 3
54980: PUSH
54981: DOUBLE
54982: LD_INT 1
54984: DEC
54985: ST_TO_ADDR
54986: LD_INT 4
54988: PUSH
54989: FOR_TO
54990: IFFALSE 55181
// begin if not tmp [ j ] then
54992: LD_VAR 0 4
54996: PUSH
54997: LD_VAR 0 3
55001: ARRAY
55002: NOT
55003: IFFALSE 55007
// continue ;
55005: GO 54989
// for p in tmp [ j ] do
55007: LD_ADDR_VAR 0 5
55011: PUSH
55012: LD_VAR 0 4
55016: PUSH
55017: LD_VAR 0 3
55021: ARRAY
55022: PUSH
55023: FOR_IN
55024: IFFALSE 55177
// begin if not b [ j ] then
55026: LD_VAR 0 6
55030: PUSH
55031: LD_VAR 0 3
55035: ARRAY
55036: NOT
55037: IFFALSE 55041
// break ;
55039: GO 55177
// e := 0 ;
55041: LD_ADDR_VAR 0 7
55045: PUSH
55046: LD_INT 0
55048: ST_TO_ADDR
// for k in b [ j ] do
55049: LD_ADDR_VAR 0 8
55053: PUSH
55054: LD_VAR 0 6
55058: PUSH
55059: LD_VAR 0 3
55063: ARRAY
55064: PUSH
55065: FOR_IN
55066: IFFALSE 55093
// if IsNotFull ( k ) then
55068: LD_VAR 0 8
55072: PPUSH
55073: CALL 16504 0 1
55077: IFFALSE 55091
// begin e := k ;
55079: LD_ADDR_VAR 0 7
55083: PUSH
55084: LD_VAR 0 8
55088: ST_TO_ADDR
// break ;
55089: GO 55093
// end ;
55091: GO 55065
55093: POP
55094: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55095: LD_VAR 0 7
55099: PUSH
55100: LD_VAR 0 5
55104: PPUSH
55105: LD_VAR 0 7
55109: PPUSH
55110: CALL 48924 0 2
55114: NOT
55115: AND
55116: IFFALSE 55175
// begin if IsInUnit ( p ) then
55118: LD_VAR 0 5
55122: PPUSH
55123: CALL_OW 310
55127: IFFALSE 55138
// ComExitBuilding ( p ) ;
55129: LD_VAR 0 5
55133: PPUSH
55134: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55138: LD_VAR 0 5
55142: PPUSH
55143: LD_VAR 0 7
55147: PPUSH
55148: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55152: LD_VAR 0 5
55156: PPUSH
55157: LD_VAR 0 3
55161: PPUSH
55162: CALL_OW 183
// AddComExitBuilding ( p ) ;
55166: LD_VAR 0 5
55170: PPUSH
55171: CALL_OW 182
// end ; end ;
55175: GO 55023
55177: POP
55178: POP
// end ;
55179: GO 54989
55181: POP
55182: POP
// end ;
55183: GO 54744
55185: POP
55186: POP
// end ;
55187: LD_VAR 0 1
55191: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55192: LD_INT 0
55194: PPUSH
55195: PPUSH
55196: PPUSH
55197: PPUSH
55198: PPUSH
55199: PPUSH
55200: PPUSH
55201: PPUSH
55202: PPUSH
55203: PPUSH
55204: PPUSH
55205: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55206: LD_VAR 0 1
55210: NOT
55211: PUSH
55212: LD_EXP 59
55216: PUSH
55217: LD_VAR 0 1
55221: ARRAY
55222: NOT
55223: OR
55224: PUSH
55225: LD_EXP 59
55229: PUSH
55230: LD_VAR 0 1
55234: ARRAY
55235: PPUSH
55236: LD_INT 2
55238: PUSH
55239: LD_INT 30
55241: PUSH
55242: LD_INT 0
55244: PUSH
55245: EMPTY
55246: LIST
55247: LIST
55248: PUSH
55249: LD_INT 30
55251: PUSH
55252: LD_INT 1
55254: PUSH
55255: EMPTY
55256: LIST
55257: LIST
55258: PUSH
55259: EMPTY
55260: LIST
55261: LIST
55262: LIST
55263: PPUSH
55264: CALL_OW 72
55268: NOT
55269: OR
55270: IFFALSE 55274
// exit ;
55272: GO 58777
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55274: LD_ADDR_VAR 0 4
55278: PUSH
55279: LD_EXP 59
55283: PUSH
55284: LD_VAR 0 1
55288: ARRAY
55289: PPUSH
55290: LD_INT 2
55292: PUSH
55293: LD_INT 25
55295: PUSH
55296: LD_INT 1
55298: PUSH
55299: EMPTY
55300: LIST
55301: LIST
55302: PUSH
55303: LD_INT 25
55305: PUSH
55306: LD_INT 2
55308: PUSH
55309: EMPTY
55310: LIST
55311: LIST
55312: PUSH
55313: LD_INT 25
55315: PUSH
55316: LD_INT 3
55318: PUSH
55319: EMPTY
55320: LIST
55321: LIST
55322: PUSH
55323: LD_INT 25
55325: PUSH
55326: LD_INT 4
55328: PUSH
55329: EMPTY
55330: LIST
55331: LIST
55332: PUSH
55333: LD_INT 25
55335: PUSH
55336: LD_INT 5
55338: PUSH
55339: EMPTY
55340: LIST
55341: LIST
55342: PUSH
55343: LD_INT 25
55345: PUSH
55346: LD_INT 8
55348: PUSH
55349: EMPTY
55350: LIST
55351: LIST
55352: PUSH
55353: LD_INT 25
55355: PUSH
55356: LD_INT 9
55358: PUSH
55359: EMPTY
55360: LIST
55361: LIST
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: LIST
55367: LIST
55368: LIST
55369: LIST
55370: LIST
55371: LIST
55372: PPUSH
55373: CALL_OW 72
55377: ST_TO_ADDR
// if not tmp then
55378: LD_VAR 0 4
55382: NOT
55383: IFFALSE 55387
// exit ;
55385: GO 58777
// for i in tmp do
55387: LD_ADDR_VAR 0 3
55391: PUSH
55392: LD_VAR 0 4
55396: PUSH
55397: FOR_IN
55398: IFFALSE 55429
// if GetTag ( i ) then
55400: LD_VAR 0 3
55404: PPUSH
55405: CALL_OW 110
55409: IFFALSE 55427
// tmp := tmp diff i ;
55411: LD_ADDR_VAR 0 4
55415: PUSH
55416: LD_VAR 0 4
55420: PUSH
55421: LD_VAR 0 3
55425: DIFF
55426: ST_TO_ADDR
55427: GO 55397
55429: POP
55430: POP
// if not tmp then
55431: LD_VAR 0 4
55435: NOT
55436: IFFALSE 55440
// exit ;
55438: GO 58777
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55440: LD_ADDR_VAR 0 5
55444: PUSH
55445: LD_EXP 59
55449: PUSH
55450: LD_VAR 0 1
55454: ARRAY
55455: PPUSH
55456: LD_INT 2
55458: PUSH
55459: LD_INT 25
55461: PUSH
55462: LD_INT 1
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 25
55471: PUSH
55472: LD_INT 5
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PUSH
55479: LD_INT 25
55481: PUSH
55482: LD_INT 8
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PUSH
55489: LD_INT 25
55491: PUSH
55492: LD_INT 9
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: LIST
55503: LIST
55504: LIST
55505: PPUSH
55506: CALL_OW 72
55510: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55511: LD_ADDR_VAR 0 6
55515: PUSH
55516: LD_EXP 59
55520: PUSH
55521: LD_VAR 0 1
55525: ARRAY
55526: PPUSH
55527: LD_INT 25
55529: PUSH
55530: LD_INT 2
55532: PUSH
55533: EMPTY
55534: LIST
55535: LIST
55536: PPUSH
55537: CALL_OW 72
55541: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55542: LD_ADDR_VAR 0 7
55546: PUSH
55547: LD_EXP 59
55551: PUSH
55552: LD_VAR 0 1
55556: ARRAY
55557: PPUSH
55558: LD_INT 25
55560: PUSH
55561: LD_INT 3
55563: PUSH
55564: EMPTY
55565: LIST
55566: LIST
55567: PPUSH
55568: CALL_OW 72
55572: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55573: LD_ADDR_VAR 0 8
55577: PUSH
55578: LD_EXP 59
55582: PUSH
55583: LD_VAR 0 1
55587: ARRAY
55588: PPUSH
55589: LD_INT 25
55591: PUSH
55592: LD_INT 4
55594: PUSH
55595: EMPTY
55596: LIST
55597: LIST
55598: PUSH
55599: LD_INT 24
55601: PUSH
55602: LD_INT 251
55604: PUSH
55605: EMPTY
55606: LIST
55607: LIST
55608: PUSH
55609: EMPTY
55610: LIST
55611: LIST
55612: PPUSH
55613: CALL_OW 72
55617: ST_TO_ADDR
// if mc_scan [ base ] then
55618: LD_EXP 82
55622: PUSH
55623: LD_VAR 0 1
55627: ARRAY
55628: IFFALSE 56089
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55630: LD_ADDR_EXP 101
55634: PUSH
55635: LD_EXP 101
55639: PPUSH
55640: LD_VAR 0 1
55644: PPUSH
55645: LD_INT 4
55647: PPUSH
55648: CALL_OW 1
55652: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55653: LD_ADDR_VAR 0 12
55657: PUSH
55658: LD_EXP 59
55662: PUSH
55663: LD_VAR 0 1
55667: ARRAY
55668: PPUSH
55669: LD_INT 2
55671: PUSH
55672: LD_INT 30
55674: PUSH
55675: LD_INT 4
55677: PUSH
55678: EMPTY
55679: LIST
55680: LIST
55681: PUSH
55682: LD_INT 30
55684: PUSH
55685: LD_INT 5
55687: PUSH
55688: EMPTY
55689: LIST
55690: LIST
55691: PUSH
55692: EMPTY
55693: LIST
55694: LIST
55695: LIST
55696: PPUSH
55697: CALL_OW 72
55701: ST_TO_ADDR
// if not b then
55702: LD_VAR 0 12
55706: NOT
55707: IFFALSE 55711
// exit ;
55709: GO 58777
// p := [ ] ;
55711: LD_ADDR_VAR 0 11
55715: PUSH
55716: EMPTY
55717: ST_TO_ADDR
// if sci >= 2 then
55718: LD_VAR 0 8
55722: PUSH
55723: LD_INT 2
55725: GREATEREQUAL
55726: IFFALSE 55757
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55728: LD_ADDR_VAR 0 8
55732: PUSH
55733: LD_VAR 0 8
55737: PUSH
55738: LD_INT 1
55740: ARRAY
55741: PUSH
55742: LD_VAR 0 8
55746: PUSH
55747: LD_INT 2
55749: ARRAY
55750: PUSH
55751: EMPTY
55752: LIST
55753: LIST
55754: ST_TO_ADDR
55755: GO 55818
// if sci = 1 then
55757: LD_VAR 0 8
55761: PUSH
55762: LD_INT 1
55764: EQUAL
55765: IFFALSE 55786
// sci := [ sci [ 1 ] ] else
55767: LD_ADDR_VAR 0 8
55771: PUSH
55772: LD_VAR 0 8
55776: PUSH
55777: LD_INT 1
55779: ARRAY
55780: PUSH
55781: EMPTY
55782: LIST
55783: ST_TO_ADDR
55784: GO 55818
// if sci = 0 then
55786: LD_VAR 0 8
55790: PUSH
55791: LD_INT 0
55793: EQUAL
55794: IFFALSE 55818
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55796: LD_ADDR_VAR 0 11
55800: PUSH
55801: LD_VAR 0 4
55805: PPUSH
55806: LD_INT 4
55808: PPUSH
55809: CALL 48787 0 2
55813: PUSH
55814: LD_INT 1
55816: ARRAY
55817: ST_TO_ADDR
// if eng > 4 then
55818: LD_VAR 0 6
55822: PUSH
55823: LD_INT 4
55825: GREATER
55826: IFFALSE 55872
// for i = eng downto 4 do
55828: LD_ADDR_VAR 0 3
55832: PUSH
55833: DOUBLE
55834: LD_VAR 0 6
55838: INC
55839: ST_TO_ADDR
55840: LD_INT 4
55842: PUSH
55843: FOR_DOWNTO
55844: IFFALSE 55870
// eng := eng diff eng [ i ] ;
55846: LD_ADDR_VAR 0 6
55850: PUSH
55851: LD_VAR 0 6
55855: PUSH
55856: LD_VAR 0 6
55860: PUSH
55861: LD_VAR 0 3
55865: ARRAY
55866: DIFF
55867: ST_TO_ADDR
55868: GO 55843
55870: POP
55871: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55872: LD_ADDR_VAR 0 4
55876: PUSH
55877: LD_VAR 0 4
55881: PUSH
55882: LD_VAR 0 5
55886: PUSH
55887: LD_VAR 0 6
55891: UNION
55892: PUSH
55893: LD_VAR 0 7
55897: UNION
55898: PUSH
55899: LD_VAR 0 8
55903: UNION
55904: DIFF
55905: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
55906: LD_ADDR_VAR 0 13
55910: PUSH
55911: LD_EXP 59
55915: PUSH
55916: LD_VAR 0 1
55920: ARRAY
55921: PPUSH
55922: LD_INT 2
55924: PUSH
55925: LD_INT 30
55927: PUSH
55928: LD_INT 32
55930: PUSH
55931: EMPTY
55932: LIST
55933: LIST
55934: PUSH
55935: LD_INT 30
55937: PUSH
55938: LD_INT 31
55940: PUSH
55941: EMPTY
55942: LIST
55943: LIST
55944: PUSH
55945: EMPTY
55946: LIST
55947: LIST
55948: LIST
55949: PPUSH
55950: CALL_OW 72
55954: PUSH
55955: LD_EXP 59
55959: PUSH
55960: LD_VAR 0 1
55964: ARRAY
55965: PPUSH
55966: LD_INT 2
55968: PUSH
55969: LD_INT 30
55971: PUSH
55972: LD_INT 4
55974: PUSH
55975: EMPTY
55976: LIST
55977: LIST
55978: PUSH
55979: LD_INT 30
55981: PUSH
55982: LD_INT 5
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: PUSH
55989: EMPTY
55990: LIST
55991: LIST
55992: LIST
55993: PPUSH
55994: CALL_OW 72
55998: PUSH
55999: LD_INT 6
56001: MUL
56002: PLUS
56003: ST_TO_ADDR
// if bcount < tmp then
56004: LD_VAR 0 13
56008: PUSH
56009: LD_VAR 0 4
56013: LESS
56014: IFFALSE 56060
// for i = tmp downto bcount do
56016: LD_ADDR_VAR 0 3
56020: PUSH
56021: DOUBLE
56022: LD_VAR 0 4
56026: INC
56027: ST_TO_ADDR
56028: LD_VAR 0 13
56032: PUSH
56033: FOR_DOWNTO
56034: IFFALSE 56058
// tmp := Delete ( tmp , tmp ) ;
56036: LD_ADDR_VAR 0 4
56040: PUSH
56041: LD_VAR 0 4
56045: PPUSH
56046: LD_VAR 0 4
56050: PPUSH
56051: CALL_OW 3
56055: ST_TO_ADDR
56056: GO 56033
56058: POP
56059: POP
// result := [ tmp , 0 , 0 , p ] ;
56060: LD_ADDR_VAR 0 2
56064: PUSH
56065: LD_VAR 0 4
56069: PUSH
56070: LD_INT 0
56072: PUSH
56073: LD_INT 0
56075: PUSH
56076: LD_VAR 0 11
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: LIST
56086: ST_TO_ADDR
// exit ;
56087: GO 58777
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56089: LD_EXP 59
56093: PUSH
56094: LD_VAR 0 1
56098: ARRAY
56099: PPUSH
56100: LD_INT 2
56102: PUSH
56103: LD_INT 30
56105: PUSH
56106: LD_INT 6
56108: PUSH
56109: EMPTY
56110: LIST
56111: LIST
56112: PUSH
56113: LD_INT 30
56115: PUSH
56116: LD_INT 7
56118: PUSH
56119: EMPTY
56120: LIST
56121: LIST
56122: PUSH
56123: LD_INT 30
56125: PUSH
56126: LD_INT 8
56128: PUSH
56129: EMPTY
56130: LIST
56131: LIST
56132: PUSH
56133: EMPTY
56134: LIST
56135: LIST
56136: LIST
56137: LIST
56138: PPUSH
56139: CALL_OW 72
56143: NOT
56144: PUSH
56145: LD_EXP 59
56149: PUSH
56150: LD_VAR 0 1
56154: ARRAY
56155: PPUSH
56156: LD_INT 30
56158: PUSH
56159: LD_INT 3
56161: PUSH
56162: EMPTY
56163: LIST
56164: LIST
56165: PPUSH
56166: CALL_OW 72
56170: NOT
56171: AND
56172: IFFALSE 56244
// begin if eng = tmp then
56174: LD_VAR 0 6
56178: PUSH
56179: LD_VAR 0 4
56183: EQUAL
56184: IFFALSE 56188
// exit ;
56186: GO 58777
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56188: LD_ADDR_EXP 101
56192: PUSH
56193: LD_EXP 101
56197: PPUSH
56198: LD_VAR 0 1
56202: PPUSH
56203: LD_INT 1
56205: PPUSH
56206: CALL_OW 1
56210: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56211: LD_ADDR_VAR 0 2
56215: PUSH
56216: LD_INT 0
56218: PUSH
56219: LD_VAR 0 4
56223: PUSH
56224: LD_VAR 0 6
56228: DIFF
56229: PUSH
56230: LD_INT 0
56232: PUSH
56233: LD_INT 0
56235: PUSH
56236: EMPTY
56237: LIST
56238: LIST
56239: LIST
56240: LIST
56241: ST_TO_ADDR
// exit ;
56242: GO 58777
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56244: LD_EXP 86
56248: PUSH
56249: LD_EXP 85
56253: PUSH
56254: LD_VAR 0 1
56258: ARRAY
56259: ARRAY
56260: PUSH
56261: LD_EXP 59
56265: PUSH
56266: LD_VAR 0 1
56270: ARRAY
56271: PPUSH
56272: LD_INT 2
56274: PUSH
56275: LD_INT 30
56277: PUSH
56278: LD_INT 6
56280: PUSH
56281: EMPTY
56282: LIST
56283: LIST
56284: PUSH
56285: LD_INT 30
56287: PUSH
56288: LD_INT 7
56290: PUSH
56291: EMPTY
56292: LIST
56293: LIST
56294: PUSH
56295: LD_INT 30
56297: PUSH
56298: LD_INT 8
56300: PUSH
56301: EMPTY
56302: LIST
56303: LIST
56304: PUSH
56305: EMPTY
56306: LIST
56307: LIST
56308: LIST
56309: LIST
56310: PPUSH
56311: CALL_OW 72
56315: AND
56316: PUSH
56317: LD_EXP 59
56321: PUSH
56322: LD_VAR 0 1
56326: ARRAY
56327: PPUSH
56328: LD_INT 30
56330: PUSH
56331: LD_INT 3
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PPUSH
56338: CALL_OW 72
56342: NOT
56343: AND
56344: IFFALSE 56558
// begin if sci >= 6 then
56346: LD_VAR 0 8
56350: PUSH
56351: LD_INT 6
56353: GREATEREQUAL
56354: IFFALSE 56358
// exit ;
56356: GO 58777
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56358: LD_ADDR_EXP 101
56362: PUSH
56363: LD_EXP 101
56367: PPUSH
56368: LD_VAR 0 1
56372: PPUSH
56373: LD_INT 2
56375: PPUSH
56376: CALL_OW 1
56380: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56381: LD_ADDR_VAR 0 9
56385: PUSH
56386: LD_VAR 0 4
56390: PUSH
56391: LD_VAR 0 8
56395: DIFF
56396: PPUSH
56397: LD_INT 4
56399: PPUSH
56400: CALL 48787 0 2
56404: ST_TO_ADDR
// p := [ ] ;
56405: LD_ADDR_VAR 0 11
56409: PUSH
56410: EMPTY
56411: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56412: LD_VAR 0 8
56416: PUSH
56417: LD_INT 6
56419: LESS
56420: PUSH
56421: LD_VAR 0 9
56425: PUSH
56426: LD_INT 6
56428: GREATER
56429: AND
56430: IFFALSE 56511
// begin for i = 1 to 6 - sci do
56432: LD_ADDR_VAR 0 3
56436: PUSH
56437: DOUBLE
56438: LD_INT 1
56440: DEC
56441: ST_TO_ADDR
56442: LD_INT 6
56444: PUSH
56445: LD_VAR 0 8
56449: MINUS
56450: PUSH
56451: FOR_TO
56452: IFFALSE 56507
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56454: LD_ADDR_VAR 0 11
56458: PUSH
56459: LD_VAR 0 11
56463: PPUSH
56464: LD_VAR 0 11
56468: PUSH
56469: LD_INT 1
56471: PLUS
56472: PPUSH
56473: LD_VAR 0 9
56477: PUSH
56478: LD_INT 1
56480: ARRAY
56481: PPUSH
56482: CALL_OW 2
56486: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56487: LD_ADDR_VAR 0 9
56491: PUSH
56492: LD_VAR 0 9
56496: PPUSH
56497: LD_INT 1
56499: PPUSH
56500: CALL_OW 3
56504: ST_TO_ADDR
// end ;
56505: GO 56451
56507: POP
56508: POP
// end else
56509: GO 56531
// if sort then
56511: LD_VAR 0 9
56515: IFFALSE 56531
// p := sort [ 1 ] ;
56517: LD_ADDR_VAR 0 11
56521: PUSH
56522: LD_VAR 0 9
56526: PUSH
56527: LD_INT 1
56529: ARRAY
56530: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56531: LD_ADDR_VAR 0 2
56535: PUSH
56536: LD_INT 0
56538: PUSH
56539: LD_INT 0
56541: PUSH
56542: LD_INT 0
56544: PUSH
56545: LD_VAR 0 11
56549: PUSH
56550: EMPTY
56551: LIST
56552: LIST
56553: LIST
56554: LIST
56555: ST_TO_ADDR
// exit ;
56556: GO 58777
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56558: LD_EXP 86
56562: PUSH
56563: LD_EXP 85
56567: PUSH
56568: LD_VAR 0 1
56572: ARRAY
56573: ARRAY
56574: PUSH
56575: LD_EXP 59
56579: PUSH
56580: LD_VAR 0 1
56584: ARRAY
56585: PPUSH
56586: LD_INT 2
56588: PUSH
56589: LD_INT 30
56591: PUSH
56592: LD_INT 6
56594: PUSH
56595: EMPTY
56596: LIST
56597: LIST
56598: PUSH
56599: LD_INT 30
56601: PUSH
56602: LD_INT 7
56604: PUSH
56605: EMPTY
56606: LIST
56607: LIST
56608: PUSH
56609: LD_INT 30
56611: PUSH
56612: LD_INT 8
56614: PUSH
56615: EMPTY
56616: LIST
56617: LIST
56618: PUSH
56619: EMPTY
56620: LIST
56621: LIST
56622: LIST
56623: LIST
56624: PPUSH
56625: CALL_OW 72
56629: AND
56630: PUSH
56631: LD_EXP 59
56635: PUSH
56636: LD_VAR 0 1
56640: ARRAY
56641: PPUSH
56642: LD_INT 30
56644: PUSH
56645: LD_INT 3
56647: PUSH
56648: EMPTY
56649: LIST
56650: LIST
56651: PPUSH
56652: CALL_OW 72
56656: AND
56657: IFFALSE 57391
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56659: LD_ADDR_EXP 101
56663: PUSH
56664: LD_EXP 101
56668: PPUSH
56669: LD_VAR 0 1
56673: PPUSH
56674: LD_INT 3
56676: PPUSH
56677: CALL_OW 1
56681: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56682: LD_ADDR_VAR 0 2
56686: PUSH
56687: LD_INT 0
56689: PUSH
56690: LD_INT 0
56692: PUSH
56693: LD_INT 0
56695: PUSH
56696: LD_INT 0
56698: PUSH
56699: EMPTY
56700: LIST
56701: LIST
56702: LIST
56703: LIST
56704: ST_TO_ADDR
// if not eng then
56705: LD_VAR 0 6
56709: NOT
56710: IFFALSE 56773
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56712: LD_ADDR_VAR 0 11
56716: PUSH
56717: LD_VAR 0 4
56721: PPUSH
56722: LD_INT 2
56724: PPUSH
56725: CALL 48787 0 2
56729: PUSH
56730: LD_INT 1
56732: ARRAY
56733: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56734: LD_ADDR_VAR 0 2
56738: PUSH
56739: LD_VAR 0 2
56743: PPUSH
56744: LD_INT 2
56746: PPUSH
56747: LD_VAR 0 11
56751: PPUSH
56752: CALL_OW 1
56756: ST_TO_ADDR
// tmp := tmp diff p ;
56757: LD_ADDR_VAR 0 4
56761: PUSH
56762: LD_VAR 0 4
56766: PUSH
56767: LD_VAR 0 11
56771: DIFF
56772: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56773: LD_VAR 0 4
56777: PUSH
56778: LD_VAR 0 8
56782: PUSH
56783: LD_INT 6
56785: LESS
56786: AND
56787: IFFALSE 56975
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56789: LD_ADDR_VAR 0 9
56793: PUSH
56794: LD_VAR 0 4
56798: PUSH
56799: LD_VAR 0 8
56803: PUSH
56804: LD_VAR 0 7
56808: UNION
56809: DIFF
56810: PPUSH
56811: LD_INT 4
56813: PPUSH
56814: CALL 48787 0 2
56818: ST_TO_ADDR
// p := [ ] ;
56819: LD_ADDR_VAR 0 11
56823: PUSH
56824: EMPTY
56825: ST_TO_ADDR
// if sort then
56826: LD_VAR 0 9
56830: IFFALSE 56946
// for i = 1 to 6 - sci do
56832: LD_ADDR_VAR 0 3
56836: PUSH
56837: DOUBLE
56838: LD_INT 1
56840: DEC
56841: ST_TO_ADDR
56842: LD_INT 6
56844: PUSH
56845: LD_VAR 0 8
56849: MINUS
56850: PUSH
56851: FOR_TO
56852: IFFALSE 56944
// begin if i = sort then
56854: LD_VAR 0 3
56858: PUSH
56859: LD_VAR 0 9
56863: EQUAL
56864: IFFALSE 56868
// break ;
56866: GO 56944
// if GetClass ( i ) = 4 then
56868: LD_VAR 0 3
56872: PPUSH
56873: CALL_OW 257
56877: PUSH
56878: LD_INT 4
56880: EQUAL
56881: IFFALSE 56885
// continue ;
56883: GO 56851
// p := Insert ( p , p + 1 , sort [ i ] ) ;
56885: LD_ADDR_VAR 0 11
56889: PUSH
56890: LD_VAR 0 11
56894: PPUSH
56895: LD_VAR 0 11
56899: PUSH
56900: LD_INT 1
56902: PLUS
56903: PPUSH
56904: LD_VAR 0 9
56908: PUSH
56909: LD_VAR 0 3
56913: ARRAY
56914: PPUSH
56915: CALL_OW 2
56919: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
56920: LD_ADDR_VAR 0 4
56924: PUSH
56925: LD_VAR 0 4
56929: PUSH
56930: LD_VAR 0 9
56934: PUSH
56935: LD_VAR 0 3
56939: ARRAY
56940: DIFF
56941: ST_TO_ADDR
// end ;
56942: GO 56851
56944: POP
56945: POP
// if p then
56946: LD_VAR 0 11
56950: IFFALSE 56975
// result := Replace ( result , 4 , p ) ;
56952: LD_ADDR_VAR 0 2
56956: PUSH
56957: LD_VAR 0 2
56961: PPUSH
56962: LD_INT 4
56964: PPUSH
56965: LD_VAR 0 11
56969: PPUSH
56970: CALL_OW 1
56974: ST_TO_ADDR
// end ; if tmp and mech < 6 then
56975: LD_VAR 0 4
56979: PUSH
56980: LD_VAR 0 7
56984: PUSH
56985: LD_INT 6
56987: LESS
56988: AND
56989: IFFALSE 57177
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
56991: LD_ADDR_VAR 0 9
56995: PUSH
56996: LD_VAR 0 4
57000: PUSH
57001: LD_VAR 0 8
57005: PUSH
57006: LD_VAR 0 7
57010: UNION
57011: DIFF
57012: PPUSH
57013: LD_INT 3
57015: PPUSH
57016: CALL 48787 0 2
57020: ST_TO_ADDR
// p := [ ] ;
57021: LD_ADDR_VAR 0 11
57025: PUSH
57026: EMPTY
57027: ST_TO_ADDR
// if sort then
57028: LD_VAR 0 9
57032: IFFALSE 57148
// for i = 1 to 6 - mech do
57034: LD_ADDR_VAR 0 3
57038: PUSH
57039: DOUBLE
57040: LD_INT 1
57042: DEC
57043: ST_TO_ADDR
57044: LD_INT 6
57046: PUSH
57047: LD_VAR 0 7
57051: MINUS
57052: PUSH
57053: FOR_TO
57054: IFFALSE 57146
// begin if i = sort then
57056: LD_VAR 0 3
57060: PUSH
57061: LD_VAR 0 9
57065: EQUAL
57066: IFFALSE 57070
// break ;
57068: GO 57146
// if GetClass ( i ) = 3 then
57070: LD_VAR 0 3
57074: PPUSH
57075: CALL_OW 257
57079: PUSH
57080: LD_INT 3
57082: EQUAL
57083: IFFALSE 57087
// continue ;
57085: GO 57053
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57087: LD_ADDR_VAR 0 11
57091: PUSH
57092: LD_VAR 0 11
57096: PPUSH
57097: LD_VAR 0 11
57101: PUSH
57102: LD_INT 1
57104: PLUS
57105: PPUSH
57106: LD_VAR 0 9
57110: PUSH
57111: LD_VAR 0 3
57115: ARRAY
57116: PPUSH
57117: CALL_OW 2
57121: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57122: LD_ADDR_VAR 0 4
57126: PUSH
57127: LD_VAR 0 4
57131: PUSH
57132: LD_VAR 0 9
57136: PUSH
57137: LD_VAR 0 3
57141: ARRAY
57142: DIFF
57143: ST_TO_ADDR
// end ;
57144: GO 57053
57146: POP
57147: POP
// if p then
57148: LD_VAR 0 11
57152: IFFALSE 57177
// result := Replace ( result , 3 , p ) ;
57154: LD_ADDR_VAR 0 2
57158: PUSH
57159: LD_VAR 0 2
57163: PPUSH
57164: LD_INT 3
57166: PPUSH
57167: LD_VAR 0 11
57171: PPUSH
57172: CALL_OW 1
57176: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57177: LD_VAR 0 4
57181: PUSH
57182: LD_INT 6
57184: GREATER
57185: PUSH
57186: LD_VAR 0 6
57190: PUSH
57191: LD_INT 6
57193: LESS
57194: AND
57195: IFFALSE 57389
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57197: LD_ADDR_VAR 0 9
57201: PUSH
57202: LD_VAR 0 4
57206: PUSH
57207: LD_VAR 0 8
57211: PUSH
57212: LD_VAR 0 7
57216: UNION
57217: PUSH
57218: LD_VAR 0 6
57222: UNION
57223: DIFF
57224: PPUSH
57225: LD_INT 2
57227: PPUSH
57228: CALL 48787 0 2
57232: ST_TO_ADDR
// p := [ ] ;
57233: LD_ADDR_VAR 0 11
57237: PUSH
57238: EMPTY
57239: ST_TO_ADDR
// if sort then
57240: LD_VAR 0 9
57244: IFFALSE 57360
// for i = 1 to 6 - eng do
57246: LD_ADDR_VAR 0 3
57250: PUSH
57251: DOUBLE
57252: LD_INT 1
57254: DEC
57255: ST_TO_ADDR
57256: LD_INT 6
57258: PUSH
57259: LD_VAR 0 6
57263: MINUS
57264: PUSH
57265: FOR_TO
57266: IFFALSE 57358
// begin if i = sort then
57268: LD_VAR 0 3
57272: PUSH
57273: LD_VAR 0 9
57277: EQUAL
57278: IFFALSE 57282
// break ;
57280: GO 57358
// if GetClass ( i ) = 2 then
57282: LD_VAR 0 3
57286: PPUSH
57287: CALL_OW 257
57291: PUSH
57292: LD_INT 2
57294: EQUAL
57295: IFFALSE 57299
// continue ;
57297: GO 57265
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57299: LD_ADDR_VAR 0 11
57303: PUSH
57304: LD_VAR 0 11
57308: PPUSH
57309: LD_VAR 0 11
57313: PUSH
57314: LD_INT 1
57316: PLUS
57317: PPUSH
57318: LD_VAR 0 9
57322: PUSH
57323: LD_VAR 0 3
57327: ARRAY
57328: PPUSH
57329: CALL_OW 2
57333: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57334: LD_ADDR_VAR 0 4
57338: PUSH
57339: LD_VAR 0 4
57343: PUSH
57344: LD_VAR 0 9
57348: PUSH
57349: LD_VAR 0 3
57353: ARRAY
57354: DIFF
57355: ST_TO_ADDR
// end ;
57356: GO 57265
57358: POP
57359: POP
// if p then
57360: LD_VAR 0 11
57364: IFFALSE 57389
// result := Replace ( result , 2 , p ) ;
57366: LD_ADDR_VAR 0 2
57370: PUSH
57371: LD_VAR 0 2
57375: PPUSH
57376: LD_INT 2
57378: PPUSH
57379: LD_VAR 0 11
57383: PPUSH
57384: CALL_OW 1
57388: ST_TO_ADDR
// end ; exit ;
57389: GO 58777
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57391: LD_EXP 86
57395: PUSH
57396: LD_EXP 85
57400: PUSH
57401: LD_VAR 0 1
57405: ARRAY
57406: ARRAY
57407: NOT
57408: PUSH
57409: LD_EXP 59
57413: PUSH
57414: LD_VAR 0 1
57418: ARRAY
57419: PPUSH
57420: LD_INT 30
57422: PUSH
57423: LD_INT 3
57425: PUSH
57426: EMPTY
57427: LIST
57428: LIST
57429: PPUSH
57430: CALL_OW 72
57434: AND
57435: PUSH
57436: LD_EXP 64
57440: PUSH
57441: LD_VAR 0 1
57445: ARRAY
57446: AND
57447: IFFALSE 58055
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57449: LD_ADDR_EXP 101
57453: PUSH
57454: LD_EXP 101
57458: PPUSH
57459: LD_VAR 0 1
57463: PPUSH
57464: LD_INT 5
57466: PPUSH
57467: CALL_OW 1
57471: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57472: LD_ADDR_VAR 0 2
57476: PUSH
57477: LD_INT 0
57479: PUSH
57480: LD_INT 0
57482: PUSH
57483: LD_INT 0
57485: PUSH
57486: LD_INT 0
57488: PUSH
57489: EMPTY
57490: LIST
57491: LIST
57492: LIST
57493: LIST
57494: ST_TO_ADDR
// if sci > 1 then
57495: LD_VAR 0 8
57499: PUSH
57500: LD_INT 1
57502: GREATER
57503: IFFALSE 57531
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57505: LD_ADDR_VAR 0 4
57509: PUSH
57510: LD_VAR 0 4
57514: PUSH
57515: LD_VAR 0 8
57519: PUSH
57520: LD_VAR 0 8
57524: PUSH
57525: LD_INT 1
57527: ARRAY
57528: DIFF
57529: DIFF
57530: ST_TO_ADDR
// if tmp and not sci then
57531: LD_VAR 0 4
57535: PUSH
57536: LD_VAR 0 8
57540: NOT
57541: AND
57542: IFFALSE 57611
// begin sort := SortBySkill ( tmp , 4 ) ;
57544: LD_ADDR_VAR 0 9
57548: PUSH
57549: LD_VAR 0 4
57553: PPUSH
57554: LD_INT 4
57556: PPUSH
57557: CALL 48787 0 2
57561: ST_TO_ADDR
// if sort then
57562: LD_VAR 0 9
57566: IFFALSE 57582
// p := sort [ 1 ] ;
57568: LD_ADDR_VAR 0 11
57572: PUSH
57573: LD_VAR 0 9
57577: PUSH
57578: LD_INT 1
57580: ARRAY
57581: ST_TO_ADDR
// if p then
57582: LD_VAR 0 11
57586: IFFALSE 57611
// result := Replace ( result , 4 , p ) ;
57588: LD_ADDR_VAR 0 2
57592: PUSH
57593: LD_VAR 0 2
57597: PPUSH
57598: LD_INT 4
57600: PPUSH
57601: LD_VAR 0 11
57605: PPUSH
57606: CALL_OW 1
57610: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57611: LD_ADDR_VAR 0 4
57615: PUSH
57616: LD_VAR 0 4
57620: PUSH
57621: LD_VAR 0 7
57625: DIFF
57626: ST_TO_ADDR
// if tmp and mech < 6 then
57627: LD_VAR 0 4
57631: PUSH
57632: LD_VAR 0 7
57636: PUSH
57637: LD_INT 6
57639: LESS
57640: AND
57641: IFFALSE 57829
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57643: LD_ADDR_VAR 0 9
57647: PUSH
57648: LD_VAR 0 4
57652: PUSH
57653: LD_VAR 0 8
57657: PUSH
57658: LD_VAR 0 7
57662: UNION
57663: DIFF
57664: PPUSH
57665: LD_INT 3
57667: PPUSH
57668: CALL 48787 0 2
57672: ST_TO_ADDR
// p := [ ] ;
57673: LD_ADDR_VAR 0 11
57677: PUSH
57678: EMPTY
57679: ST_TO_ADDR
// if sort then
57680: LD_VAR 0 9
57684: IFFALSE 57800
// for i = 1 to 6 - mech do
57686: LD_ADDR_VAR 0 3
57690: PUSH
57691: DOUBLE
57692: LD_INT 1
57694: DEC
57695: ST_TO_ADDR
57696: LD_INT 6
57698: PUSH
57699: LD_VAR 0 7
57703: MINUS
57704: PUSH
57705: FOR_TO
57706: IFFALSE 57798
// begin if i = sort then
57708: LD_VAR 0 3
57712: PUSH
57713: LD_VAR 0 9
57717: EQUAL
57718: IFFALSE 57722
// break ;
57720: GO 57798
// if GetClass ( i ) = 3 then
57722: LD_VAR 0 3
57726: PPUSH
57727: CALL_OW 257
57731: PUSH
57732: LD_INT 3
57734: EQUAL
57735: IFFALSE 57739
// continue ;
57737: GO 57705
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57739: LD_ADDR_VAR 0 11
57743: PUSH
57744: LD_VAR 0 11
57748: PPUSH
57749: LD_VAR 0 11
57753: PUSH
57754: LD_INT 1
57756: PLUS
57757: PPUSH
57758: LD_VAR 0 9
57762: PUSH
57763: LD_VAR 0 3
57767: ARRAY
57768: PPUSH
57769: CALL_OW 2
57773: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57774: LD_ADDR_VAR 0 4
57778: PUSH
57779: LD_VAR 0 4
57783: PUSH
57784: LD_VAR 0 9
57788: PUSH
57789: LD_VAR 0 3
57793: ARRAY
57794: DIFF
57795: ST_TO_ADDR
// end ;
57796: GO 57705
57798: POP
57799: POP
// if p then
57800: LD_VAR 0 11
57804: IFFALSE 57829
// result := Replace ( result , 3 , p ) ;
57806: LD_ADDR_VAR 0 2
57810: PUSH
57811: LD_VAR 0 2
57815: PPUSH
57816: LD_INT 3
57818: PPUSH
57819: LD_VAR 0 11
57823: PPUSH
57824: CALL_OW 1
57828: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57829: LD_ADDR_VAR 0 4
57833: PUSH
57834: LD_VAR 0 4
57838: PUSH
57839: LD_VAR 0 6
57843: DIFF
57844: ST_TO_ADDR
// if tmp and eng < 6 then
57845: LD_VAR 0 4
57849: PUSH
57850: LD_VAR 0 6
57854: PUSH
57855: LD_INT 6
57857: LESS
57858: AND
57859: IFFALSE 58053
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57861: LD_ADDR_VAR 0 9
57865: PUSH
57866: LD_VAR 0 4
57870: PUSH
57871: LD_VAR 0 8
57875: PUSH
57876: LD_VAR 0 7
57880: UNION
57881: PUSH
57882: LD_VAR 0 6
57886: UNION
57887: DIFF
57888: PPUSH
57889: LD_INT 2
57891: PPUSH
57892: CALL 48787 0 2
57896: ST_TO_ADDR
// p := [ ] ;
57897: LD_ADDR_VAR 0 11
57901: PUSH
57902: EMPTY
57903: ST_TO_ADDR
// if sort then
57904: LD_VAR 0 9
57908: IFFALSE 58024
// for i = 1 to 6 - eng do
57910: LD_ADDR_VAR 0 3
57914: PUSH
57915: DOUBLE
57916: LD_INT 1
57918: DEC
57919: ST_TO_ADDR
57920: LD_INT 6
57922: PUSH
57923: LD_VAR 0 6
57927: MINUS
57928: PUSH
57929: FOR_TO
57930: IFFALSE 58022
// begin if i = sort then
57932: LD_VAR 0 3
57936: PUSH
57937: LD_VAR 0 9
57941: EQUAL
57942: IFFALSE 57946
// break ;
57944: GO 58022
// if GetClass ( i ) = 2 then
57946: LD_VAR 0 3
57950: PPUSH
57951: CALL_OW 257
57955: PUSH
57956: LD_INT 2
57958: EQUAL
57959: IFFALSE 57963
// continue ;
57961: GO 57929
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57963: LD_ADDR_VAR 0 11
57967: PUSH
57968: LD_VAR 0 11
57972: PPUSH
57973: LD_VAR 0 11
57977: PUSH
57978: LD_INT 1
57980: PLUS
57981: PPUSH
57982: LD_VAR 0 9
57986: PUSH
57987: LD_VAR 0 3
57991: ARRAY
57992: PPUSH
57993: CALL_OW 2
57997: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57998: LD_ADDR_VAR 0 4
58002: PUSH
58003: LD_VAR 0 4
58007: PUSH
58008: LD_VAR 0 9
58012: PUSH
58013: LD_VAR 0 3
58017: ARRAY
58018: DIFF
58019: ST_TO_ADDR
// end ;
58020: GO 57929
58022: POP
58023: POP
// if p then
58024: LD_VAR 0 11
58028: IFFALSE 58053
// result := Replace ( result , 2 , p ) ;
58030: LD_ADDR_VAR 0 2
58034: PUSH
58035: LD_VAR 0 2
58039: PPUSH
58040: LD_INT 2
58042: PPUSH
58043: LD_VAR 0 11
58047: PPUSH
58048: CALL_OW 1
58052: ST_TO_ADDR
// end ; exit ;
58053: GO 58777
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58055: LD_EXP 86
58059: PUSH
58060: LD_EXP 85
58064: PUSH
58065: LD_VAR 0 1
58069: ARRAY
58070: ARRAY
58071: NOT
58072: PUSH
58073: LD_EXP 59
58077: PUSH
58078: LD_VAR 0 1
58082: ARRAY
58083: PPUSH
58084: LD_INT 30
58086: PUSH
58087: LD_INT 3
58089: PUSH
58090: EMPTY
58091: LIST
58092: LIST
58093: PPUSH
58094: CALL_OW 72
58098: AND
58099: PUSH
58100: LD_EXP 64
58104: PUSH
58105: LD_VAR 0 1
58109: ARRAY
58110: NOT
58111: AND
58112: IFFALSE 58777
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58114: LD_ADDR_EXP 101
58118: PUSH
58119: LD_EXP 101
58123: PPUSH
58124: LD_VAR 0 1
58128: PPUSH
58129: LD_INT 6
58131: PPUSH
58132: CALL_OW 1
58136: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58137: LD_ADDR_VAR 0 2
58141: PUSH
58142: LD_INT 0
58144: PUSH
58145: LD_INT 0
58147: PUSH
58148: LD_INT 0
58150: PUSH
58151: LD_INT 0
58153: PUSH
58154: EMPTY
58155: LIST
58156: LIST
58157: LIST
58158: LIST
58159: ST_TO_ADDR
// if sci >= 1 then
58160: LD_VAR 0 8
58164: PUSH
58165: LD_INT 1
58167: GREATEREQUAL
58168: IFFALSE 58190
// tmp := tmp diff sci [ 1 ] ;
58170: LD_ADDR_VAR 0 4
58174: PUSH
58175: LD_VAR 0 4
58179: PUSH
58180: LD_VAR 0 8
58184: PUSH
58185: LD_INT 1
58187: ARRAY
58188: DIFF
58189: ST_TO_ADDR
// if tmp and not sci then
58190: LD_VAR 0 4
58194: PUSH
58195: LD_VAR 0 8
58199: NOT
58200: AND
58201: IFFALSE 58270
// begin sort := SortBySkill ( tmp , 4 ) ;
58203: LD_ADDR_VAR 0 9
58207: PUSH
58208: LD_VAR 0 4
58212: PPUSH
58213: LD_INT 4
58215: PPUSH
58216: CALL 48787 0 2
58220: ST_TO_ADDR
// if sort then
58221: LD_VAR 0 9
58225: IFFALSE 58241
// p := sort [ 1 ] ;
58227: LD_ADDR_VAR 0 11
58231: PUSH
58232: LD_VAR 0 9
58236: PUSH
58237: LD_INT 1
58239: ARRAY
58240: ST_TO_ADDR
// if p then
58241: LD_VAR 0 11
58245: IFFALSE 58270
// result := Replace ( result , 4 , p ) ;
58247: LD_ADDR_VAR 0 2
58251: PUSH
58252: LD_VAR 0 2
58256: PPUSH
58257: LD_INT 4
58259: PPUSH
58260: LD_VAR 0 11
58264: PPUSH
58265: CALL_OW 1
58269: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58270: LD_ADDR_VAR 0 4
58274: PUSH
58275: LD_VAR 0 4
58279: PUSH
58280: LD_VAR 0 7
58284: DIFF
58285: ST_TO_ADDR
// if tmp and mech < 6 then
58286: LD_VAR 0 4
58290: PUSH
58291: LD_VAR 0 7
58295: PUSH
58296: LD_INT 6
58298: LESS
58299: AND
58300: IFFALSE 58482
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58302: LD_ADDR_VAR 0 9
58306: PUSH
58307: LD_VAR 0 4
58311: PUSH
58312: LD_VAR 0 7
58316: DIFF
58317: PPUSH
58318: LD_INT 3
58320: PPUSH
58321: CALL 48787 0 2
58325: ST_TO_ADDR
// p := [ ] ;
58326: LD_ADDR_VAR 0 11
58330: PUSH
58331: EMPTY
58332: ST_TO_ADDR
// if sort then
58333: LD_VAR 0 9
58337: IFFALSE 58453
// for i = 1 to 6 - mech do
58339: LD_ADDR_VAR 0 3
58343: PUSH
58344: DOUBLE
58345: LD_INT 1
58347: DEC
58348: ST_TO_ADDR
58349: LD_INT 6
58351: PUSH
58352: LD_VAR 0 7
58356: MINUS
58357: PUSH
58358: FOR_TO
58359: IFFALSE 58451
// begin if i = sort then
58361: LD_VAR 0 3
58365: PUSH
58366: LD_VAR 0 9
58370: EQUAL
58371: IFFALSE 58375
// break ;
58373: GO 58451
// if GetClass ( i ) = 3 then
58375: LD_VAR 0 3
58379: PPUSH
58380: CALL_OW 257
58384: PUSH
58385: LD_INT 3
58387: EQUAL
58388: IFFALSE 58392
// continue ;
58390: GO 58358
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58392: LD_ADDR_VAR 0 11
58396: PUSH
58397: LD_VAR 0 11
58401: PPUSH
58402: LD_VAR 0 11
58406: PUSH
58407: LD_INT 1
58409: PLUS
58410: PPUSH
58411: LD_VAR 0 9
58415: PUSH
58416: LD_VAR 0 3
58420: ARRAY
58421: PPUSH
58422: CALL_OW 2
58426: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58427: LD_ADDR_VAR 0 4
58431: PUSH
58432: LD_VAR 0 4
58436: PUSH
58437: LD_VAR 0 9
58441: PUSH
58442: LD_VAR 0 3
58446: ARRAY
58447: DIFF
58448: ST_TO_ADDR
// end ;
58449: GO 58358
58451: POP
58452: POP
// if p then
58453: LD_VAR 0 11
58457: IFFALSE 58482
// result := Replace ( result , 3 , p ) ;
58459: LD_ADDR_VAR 0 2
58463: PUSH
58464: LD_VAR 0 2
58468: PPUSH
58469: LD_INT 3
58471: PPUSH
58472: LD_VAR 0 11
58476: PPUSH
58477: CALL_OW 1
58481: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58482: LD_ADDR_VAR 0 4
58486: PUSH
58487: LD_VAR 0 4
58491: PUSH
58492: LD_VAR 0 6
58496: DIFF
58497: ST_TO_ADDR
// if tmp and eng < 4 then
58498: LD_VAR 0 4
58502: PUSH
58503: LD_VAR 0 6
58507: PUSH
58508: LD_INT 4
58510: LESS
58511: AND
58512: IFFALSE 58702
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58514: LD_ADDR_VAR 0 9
58518: PUSH
58519: LD_VAR 0 4
58523: PUSH
58524: LD_VAR 0 7
58528: PUSH
58529: LD_VAR 0 6
58533: UNION
58534: DIFF
58535: PPUSH
58536: LD_INT 2
58538: PPUSH
58539: CALL 48787 0 2
58543: ST_TO_ADDR
// p := [ ] ;
58544: LD_ADDR_VAR 0 11
58548: PUSH
58549: EMPTY
58550: ST_TO_ADDR
// if sort then
58551: LD_VAR 0 9
58555: IFFALSE 58671
// for i = 1 to 4 - eng do
58557: LD_ADDR_VAR 0 3
58561: PUSH
58562: DOUBLE
58563: LD_INT 1
58565: DEC
58566: ST_TO_ADDR
58567: LD_INT 4
58569: PUSH
58570: LD_VAR 0 6
58574: MINUS
58575: PUSH
58576: FOR_TO
58577: IFFALSE 58669
// begin if i = sort then
58579: LD_VAR 0 3
58583: PUSH
58584: LD_VAR 0 9
58588: EQUAL
58589: IFFALSE 58593
// break ;
58591: GO 58669
// if GetClass ( i ) = 2 then
58593: LD_VAR 0 3
58597: PPUSH
58598: CALL_OW 257
58602: PUSH
58603: LD_INT 2
58605: EQUAL
58606: IFFALSE 58610
// continue ;
58608: GO 58576
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58610: LD_ADDR_VAR 0 11
58614: PUSH
58615: LD_VAR 0 11
58619: PPUSH
58620: LD_VAR 0 11
58624: PUSH
58625: LD_INT 1
58627: PLUS
58628: PPUSH
58629: LD_VAR 0 9
58633: PUSH
58634: LD_VAR 0 3
58638: ARRAY
58639: PPUSH
58640: CALL_OW 2
58644: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58645: LD_ADDR_VAR 0 4
58649: PUSH
58650: LD_VAR 0 4
58654: PUSH
58655: LD_VAR 0 9
58659: PUSH
58660: LD_VAR 0 3
58664: ARRAY
58665: DIFF
58666: ST_TO_ADDR
// end ;
58667: GO 58576
58669: POP
58670: POP
// if p then
58671: LD_VAR 0 11
58675: IFFALSE 58700
// result := Replace ( result , 2 , p ) ;
58677: LD_ADDR_VAR 0 2
58681: PUSH
58682: LD_VAR 0 2
58686: PPUSH
58687: LD_INT 2
58689: PPUSH
58690: LD_VAR 0 11
58694: PPUSH
58695: CALL_OW 1
58699: ST_TO_ADDR
// end else
58700: GO 58746
// for i = eng downto 5 do
58702: LD_ADDR_VAR 0 3
58706: PUSH
58707: DOUBLE
58708: LD_VAR 0 6
58712: INC
58713: ST_TO_ADDR
58714: LD_INT 5
58716: PUSH
58717: FOR_DOWNTO
58718: IFFALSE 58744
// tmp := tmp union eng [ i ] ;
58720: LD_ADDR_VAR 0 4
58724: PUSH
58725: LD_VAR 0 4
58729: PUSH
58730: LD_VAR 0 6
58734: PUSH
58735: LD_VAR 0 3
58739: ARRAY
58740: UNION
58741: ST_TO_ADDR
58742: GO 58717
58744: POP
58745: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58746: LD_ADDR_VAR 0 2
58750: PUSH
58751: LD_VAR 0 2
58755: PPUSH
58756: LD_INT 1
58758: PPUSH
58759: LD_VAR 0 4
58763: PUSH
58764: LD_VAR 0 5
58768: DIFF
58769: PPUSH
58770: CALL_OW 1
58774: ST_TO_ADDR
// exit ;
58775: GO 58777
// end ; end ;
58777: LD_VAR 0 2
58781: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58782: LD_INT 0
58784: PPUSH
58785: PPUSH
58786: PPUSH
// if not mc_bases then
58787: LD_EXP 59
58791: NOT
58792: IFFALSE 58796
// exit ;
58794: GO 58902
// for i = 1 to mc_bases do
58796: LD_ADDR_VAR 0 2
58800: PUSH
58801: DOUBLE
58802: LD_INT 1
58804: DEC
58805: ST_TO_ADDR
58806: LD_EXP 59
58810: PUSH
58811: FOR_TO
58812: IFFALSE 58893
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58814: LD_ADDR_VAR 0 3
58818: PUSH
58819: LD_EXP 59
58823: PUSH
58824: LD_VAR 0 2
58828: ARRAY
58829: PPUSH
58830: LD_INT 21
58832: PUSH
58833: LD_INT 3
58835: PUSH
58836: EMPTY
58837: LIST
58838: LIST
58839: PUSH
58840: LD_INT 3
58842: PUSH
58843: LD_INT 24
58845: PUSH
58846: LD_INT 1000
58848: PUSH
58849: EMPTY
58850: LIST
58851: LIST
58852: PUSH
58853: EMPTY
58854: LIST
58855: LIST
58856: PUSH
58857: EMPTY
58858: LIST
58859: LIST
58860: PPUSH
58861: CALL_OW 72
58865: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58866: LD_ADDR_EXP 60
58870: PUSH
58871: LD_EXP 60
58875: PPUSH
58876: LD_VAR 0 2
58880: PPUSH
58881: LD_VAR 0 3
58885: PPUSH
58886: CALL_OW 1
58890: ST_TO_ADDR
// end ;
58891: GO 58811
58893: POP
58894: POP
// RaiseSailEvent ( 101 ) ;
58895: LD_INT 101
58897: PPUSH
58898: CALL_OW 427
// end ;
58902: LD_VAR 0 1
58906: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
58907: LD_INT 0
58909: PPUSH
58910: PPUSH
58911: PPUSH
58912: PPUSH
58913: PPUSH
58914: PPUSH
58915: PPUSH
// if not mc_bases then
58916: LD_EXP 59
58920: NOT
58921: IFFALSE 58925
// exit ;
58923: GO 59487
// for i = 1 to mc_bases do
58925: LD_ADDR_VAR 0 2
58929: PUSH
58930: DOUBLE
58931: LD_INT 1
58933: DEC
58934: ST_TO_ADDR
58935: LD_EXP 59
58939: PUSH
58940: FOR_TO
58941: IFFALSE 59478
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
58943: LD_ADDR_VAR 0 5
58947: PUSH
58948: LD_EXP 59
58952: PUSH
58953: LD_VAR 0 2
58957: ARRAY
58958: PUSH
58959: LD_EXP 88
58963: PUSH
58964: LD_VAR 0 2
58968: ARRAY
58969: UNION
58970: PPUSH
58971: LD_INT 21
58973: PUSH
58974: LD_INT 1
58976: PUSH
58977: EMPTY
58978: LIST
58979: LIST
58980: PUSH
58981: LD_INT 1
58983: PUSH
58984: LD_INT 3
58986: PUSH
58987: LD_INT 54
58989: PUSH
58990: EMPTY
58991: LIST
58992: PUSH
58993: EMPTY
58994: LIST
58995: LIST
58996: PUSH
58997: LD_INT 3
58999: PUSH
59000: LD_INT 24
59002: PUSH
59003: LD_INT 800
59005: PUSH
59006: EMPTY
59007: LIST
59008: LIST
59009: PUSH
59010: EMPTY
59011: LIST
59012: LIST
59013: PUSH
59014: EMPTY
59015: LIST
59016: LIST
59017: LIST
59018: PUSH
59019: EMPTY
59020: LIST
59021: LIST
59022: PPUSH
59023: CALL_OW 72
59027: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59028: LD_ADDR_VAR 0 6
59032: PUSH
59033: LD_EXP 59
59037: PUSH
59038: LD_VAR 0 2
59042: ARRAY
59043: PPUSH
59044: LD_INT 21
59046: PUSH
59047: LD_INT 1
59049: PUSH
59050: EMPTY
59051: LIST
59052: LIST
59053: PUSH
59054: LD_INT 1
59056: PUSH
59057: LD_INT 3
59059: PUSH
59060: LD_INT 54
59062: PUSH
59063: EMPTY
59064: LIST
59065: PUSH
59066: EMPTY
59067: LIST
59068: LIST
59069: PUSH
59070: LD_INT 3
59072: PUSH
59073: LD_INT 24
59075: PUSH
59076: LD_INT 250
59078: PUSH
59079: EMPTY
59080: LIST
59081: LIST
59082: PUSH
59083: EMPTY
59084: LIST
59085: LIST
59086: PUSH
59087: EMPTY
59088: LIST
59089: LIST
59090: LIST
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: PPUSH
59096: CALL_OW 72
59100: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59101: LD_ADDR_VAR 0 7
59105: PUSH
59106: LD_VAR 0 5
59110: PUSH
59111: LD_VAR 0 6
59115: DIFF
59116: ST_TO_ADDR
// if not need_heal_1 then
59117: LD_VAR 0 6
59121: NOT
59122: IFFALSE 59155
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59124: LD_ADDR_EXP 62
59128: PUSH
59129: LD_EXP 62
59133: PPUSH
59134: LD_VAR 0 2
59138: PUSH
59139: LD_INT 1
59141: PUSH
59142: EMPTY
59143: LIST
59144: LIST
59145: PPUSH
59146: EMPTY
59147: PPUSH
59148: CALL 19238 0 3
59152: ST_TO_ADDR
59153: GO 59225
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59155: LD_ADDR_EXP 62
59159: PUSH
59160: LD_EXP 62
59164: PPUSH
59165: LD_VAR 0 2
59169: PUSH
59170: LD_INT 1
59172: PUSH
59173: EMPTY
59174: LIST
59175: LIST
59176: PPUSH
59177: LD_EXP 62
59181: PUSH
59182: LD_VAR 0 2
59186: ARRAY
59187: PUSH
59188: LD_INT 1
59190: ARRAY
59191: PPUSH
59192: LD_INT 3
59194: PUSH
59195: LD_INT 24
59197: PUSH
59198: LD_INT 1000
59200: PUSH
59201: EMPTY
59202: LIST
59203: LIST
59204: PUSH
59205: EMPTY
59206: LIST
59207: LIST
59208: PPUSH
59209: CALL_OW 72
59213: PUSH
59214: LD_VAR 0 6
59218: UNION
59219: PPUSH
59220: CALL 19238 0 3
59224: ST_TO_ADDR
// if not need_heal_2 then
59225: LD_VAR 0 7
59229: NOT
59230: IFFALSE 59263
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59232: LD_ADDR_EXP 62
59236: PUSH
59237: LD_EXP 62
59241: PPUSH
59242: LD_VAR 0 2
59246: PUSH
59247: LD_INT 2
59249: PUSH
59250: EMPTY
59251: LIST
59252: LIST
59253: PPUSH
59254: EMPTY
59255: PPUSH
59256: CALL 19238 0 3
59260: ST_TO_ADDR
59261: GO 59295
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59263: LD_ADDR_EXP 62
59267: PUSH
59268: LD_EXP 62
59272: PPUSH
59273: LD_VAR 0 2
59277: PUSH
59278: LD_INT 2
59280: PUSH
59281: EMPTY
59282: LIST
59283: LIST
59284: PPUSH
59285: LD_VAR 0 7
59289: PPUSH
59290: CALL 19238 0 3
59294: ST_TO_ADDR
// if need_heal_2 then
59295: LD_VAR 0 7
59299: IFFALSE 59460
// for j in need_heal_2 do
59301: LD_ADDR_VAR 0 3
59305: PUSH
59306: LD_VAR 0 7
59310: PUSH
59311: FOR_IN
59312: IFFALSE 59458
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59314: LD_ADDR_VAR 0 5
59318: PUSH
59319: LD_EXP 59
59323: PUSH
59324: LD_VAR 0 2
59328: ARRAY
59329: PPUSH
59330: LD_INT 2
59332: PUSH
59333: LD_INT 30
59335: PUSH
59336: LD_INT 6
59338: PUSH
59339: EMPTY
59340: LIST
59341: LIST
59342: PUSH
59343: LD_INT 30
59345: PUSH
59346: LD_INT 7
59348: PUSH
59349: EMPTY
59350: LIST
59351: LIST
59352: PUSH
59353: LD_INT 30
59355: PUSH
59356: LD_INT 8
59358: PUSH
59359: EMPTY
59360: LIST
59361: LIST
59362: PUSH
59363: LD_INT 30
59365: PUSH
59366: LD_INT 0
59368: PUSH
59369: EMPTY
59370: LIST
59371: LIST
59372: PUSH
59373: LD_INT 30
59375: PUSH
59376: LD_INT 1
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: PUSH
59383: EMPTY
59384: LIST
59385: LIST
59386: LIST
59387: LIST
59388: LIST
59389: LIST
59390: PPUSH
59391: CALL_OW 72
59395: ST_TO_ADDR
// if tmp then
59396: LD_VAR 0 5
59400: IFFALSE 59456
// begin k := NearestUnitToUnit ( tmp , j ) ;
59402: LD_ADDR_VAR 0 4
59406: PUSH
59407: LD_VAR 0 5
59411: PPUSH
59412: LD_VAR 0 3
59416: PPUSH
59417: CALL_OW 74
59421: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59422: LD_VAR 0 3
59426: PPUSH
59427: LD_VAR 0 4
59431: PPUSH
59432: CALL_OW 296
59436: PUSH
59437: LD_INT 5
59439: GREATER
59440: IFFALSE 59456
// ComMoveUnit ( j , k ) ;
59442: LD_VAR 0 3
59446: PPUSH
59447: LD_VAR 0 4
59451: PPUSH
59452: CALL_OW 112
// end ; end ;
59456: GO 59311
59458: POP
59459: POP
// if not need_heal_1 and not need_heal_2 then
59460: LD_VAR 0 6
59464: NOT
59465: PUSH
59466: LD_VAR 0 7
59470: NOT
59471: AND
59472: IFFALSE 59476
// continue ;
59474: GO 58940
// end ;
59476: GO 58940
59478: POP
59479: POP
// RaiseSailEvent ( 102 ) ;
59480: LD_INT 102
59482: PPUSH
59483: CALL_OW 427
// end ;
59487: LD_VAR 0 1
59491: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59492: LD_INT 0
59494: PPUSH
59495: PPUSH
59496: PPUSH
59497: PPUSH
59498: PPUSH
59499: PPUSH
59500: PPUSH
59501: PPUSH
// if not mc_bases then
59502: LD_EXP 59
59506: NOT
59507: IFFALSE 59511
// exit ;
59509: GO 60346
// for i = 1 to mc_bases do
59511: LD_ADDR_VAR 0 2
59515: PUSH
59516: DOUBLE
59517: LD_INT 1
59519: DEC
59520: ST_TO_ADDR
59521: LD_EXP 59
59525: PUSH
59526: FOR_TO
59527: IFFALSE 60344
// begin if not mc_building_need_repair [ i ] then
59529: LD_EXP 60
59533: PUSH
59534: LD_VAR 0 2
59538: ARRAY
59539: NOT
59540: IFFALSE 59714
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
59542: LD_ADDR_VAR 0 6
59546: PUSH
59547: LD_EXP 78
59551: PUSH
59552: LD_VAR 0 2
59556: ARRAY
59557: PPUSH
59558: LD_INT 3
59560: PUSH
59561: LD_INT 24
59563: PUSH
59564: LD_INT 1000
59566: PUSH
59567: EMPTY
59568: LIST
59569: LIST
59570: PUSH
59571: EMPTY
59572: LIST
59573: LIST
59574: PUSH
59575: LD_INT 2
59577: PUSH
59578: LD_INT 34
59580: PUSH
59581: LD_INT 13
59583: PUSH
59584: EMPTY
59585: LIST
59586: LIST
59587: PUSH
59588: LD_INT 34
59590: PUSH
59591: LD_INT 52
59593: PUSH
59594: EMPTY
59595: LIST
59596: LIST
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: LIST
59602: PUSH
59603: EMPTY
59604: LIST
59605: LIST
59606: PPUSH
59607: CALL_OW 72
59611: ST_TO_ADDR
// if cranes then
59612: LD_VAR 0 6
59616: IFFALSE 59678
// for j in cranes do
59618: LD_ADDR_VAR 0 3
59622: PUSH
59623: LD_VAR 0 6
59627: PUSH
59628: FOR_IN
59629: IFFALSE 59676
// if not IsInArea ( j , mc_parking [ i ] ) then
59631: LD_VAR 0 3
59635: PPUSH
59636: LD_EXP 83
59640: PUSH
59641: LD_VAR 0 2
59645: ARRAY
59646: PPUSH
59647: CALL_OW 308
59651: NOT
59652: IFFALSE 59674
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59654: LD_VAR 0 3
59658: PPUSH
59659: LD_EXP 83
59663: PUSH
59664: LD_VAR 0 2
59668: ARRAY
59669: PPUSH
59670: CALL_OW 113
59674: GO 59628
59676: POP
59677: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59678: LD_ADDR_EXP 61
59682: PUSH
59683: LD_EXP 61
59687: PPUSH
59688: LD_VAR 0 2
59692: PPUSH
59693: EMPTY
59694: PPUSH
59695: CALL_OW 1
59699: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59700: LD_VAR 0 2
59704: PPUSH
59705: LD_INT 101
59707: PPUSH
59708: CALL 54615 0 2
// continue ;
59712: GO 59526
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59714: LD_ADDR_EXP 65
59718: PUSH
59719: LD_EXP 65
59723: PPUSH
59724: LD_VAR 0 2
59728: PPUSH
59729: EMPTY
59730: PPUSH
59731: CALL_OW 1
59735: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59736: LD_VAR 0 2
59740: PPUSH
59741: LD_INT 103
59743: PPUSH
59744: CALL 54615 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59748: LD_ADDR_VAR 0 5
59752: PUSH
59753: LD_EXP 59
59757: PUSH
59758: LD_VAR 0 2
59762: ARRAY
59763: PUSH
59764: LD_EXP 88
59768: PUSH
59769: LD_VAR 0 2
59773: ARRAY
59774: UNION
59775: PPUSH
59776: LD_INT 2
59778: PUSH
59779: LD_INT 25
59781: PUSH
59782: LD_INT 2
59784: PUSH
59785: EMPTY
59786: LIST
59787: LIST
59788: PUSH
59789: LD_INT 25
59791: PUSH
59792: LD_INT 16
59794: PUSH
59795: EMPTY
59796: LIST
59797: LIST
59798: PUSH
59799: EMPTY
59800: LIST
59801: LIST
59802: LIST
59803: PUSH
59804: EMPTY
59805: LIST
59806: PPUSH
59807: CALL_OW 72
59811: PUSH
59812: LD_EXP 62
59816: PUSH
59817: LD_VAR 0 2
59821: ARRAY
59822: PUSH
59823: LD_INT 1
59825: ARRAY
59826: PUSH
59827: LD_EXP 62
59831: PUSH
59832: LD_VAR 0 2
59836: ARRAY
59837: PUSH
59838: LD_INT 2
59840: ARRAY
59841: UNION
59842: DIFF
59843: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
59844: LD_ADDR_VAR 0 6
59848: PUSH
59849: LD_EXP 78
59853: PUSH
59854: LD_VAR 0 2
59858: ARRAY
59859: PPUSH
59860: LD_INT 2
59862: PUSH
59863: LD_INT 34
59865: PUSH
59866: LD_INT 13
59868: PUSH
59869: EMPTY
59870: LIST
59871: LIST
59872: PUSH
59873: LD_INT 34
59875: PUSH
59876: LD_INT 52
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: PUSH
59883: EMPTY
59884: LIST
59885: LIST
59886: LIST
59887: PPUSH
59888: CALL_OW 72
59892: ST_TO_ADDR
// if cranes then
59893: LD_VAR 0 6
59897: IFFALSE 60033
// begin for j in cranes do
59899: LD_ADDR_VAR 0 3
59903: PUSH
59904: LD_VAR 0 6
59908: PUSH
59909: FOR_IN
59910: IFFALSE 60031
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
59912: LD_VAR 0 3
59916: PPUSH
59917: CALL_OW 256
59921: PUSH
59922: LD_INT 500
59924: GREATEREQUAL
59925: PUSH
59926: LD_VAR 0 3
59930: PPUSH
59931: CALL_OW 314
59935: NOT
59936: AND
59937: IFFALSE 59971
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
59939: LD_VAR 0 3
59943: PPUSH
59944: LD_EXP 60
59948: PUSH
59949: LD_VAR 0 2
59953: ARRAY
59954: PPUSH
59955: LD_VAR 0 3
59959: PPUSH
59960: CALL_OW 74
59964: PPUSH
59965: CALL_OW 130
59969: GO 60029
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
59971: LD_VAR 0 3
59975: PPUSH
59976: CALL_OW 256
59980: PUSH
59981: LD_INT 500
59983: LESS
59984: PUSH
59985: LD_VAR 0 3
59989: PPUSH
59990: LD_EXP 83
59994: PUSH
59995: LD_VAR 0 2
59999: ARRAY
60000: PPUSH
60001: CALL_OW 308
60005: NOT
60006: AND
60007: IFFALSE 60029
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60009: LD_VAR 0 3
60013: PPUSH
60014: LD_EXP 83
60018: PUSH
60019: LD_VAR 0 2
60023: ARRAY
60024: PPUSH
60025: CALL_OW 113
60029: GO 59909
60031: POP
60032: POP
// end ; if tmp > 3 then
60033: LD_VAR 0 5
60037: PUSH
60038: LD_INT 3
60040: GREATER
60041: IFFALSE 60061
// tmp := ShrinkArray ( tmp , 4 ) ;
60043: LD_ADDR_VAR 0 5
60047: PUSH
60048: LD_VAR 0 5
60052: PPUSH
60053: LD_INT 4
60055: PPUSH
60056: CALL 50464 0 2
60060: ST_TO_ADDR
// if not tmp then
60061: LD_VAR 0 5
60065: NOT
60066: IFFALSE 60070
// continue ;
60068: GO 59526
// for j in tmp do
60070: LD_ADDR_VAR 0 3
60074: PUSH
60075: LD_VAR 0 5
60079: PUSH
60080: FOR_IN
60081: IFFALSE 60340
// begin if IsInUnit ( j ) then
60083: LD_VAR 0 3
60087: PPUSH
60088: CALL_OW 310
60092: IFFALSE 60103
// ComExitBuilding ( j ) ;
60094: LD_VAR 0 3
60098: PPUSH
60099: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60103: LD_VAR 0 3
60107: PUSH
60108: LD_EXP 61
60112: PUSH
60113: LD_VAR 0 2
60117: ARRAY
60118: IN
60119: NOT
60120: IFFALSE 60178
// begin SetTag ( j , 101 ) ;
60122: LD_VAR 0 3
60126: PPUSH
60127: LD_INT 101
60129: PPUSH
60130: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60134: LD_ADDR_EXP 61
60138: PUSH
60139: LD_EXP 61
60143: PPUSH
60144: LD_VAR 0 2
60148: PUSH
60149: LD_EXP 61
60153: PUSH
60154: LD_VAR 0 2
60158: ARRAY
60159: PUSH
60160: LD_INT 1
60162: PLUS
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: PPUSH
60168: LD_VAR 0 3
60172: PPUSH
60173: CALL 19238 0 3
60177: ST_TO_ADDR
// end ; wait ( 1 ) ;
60178: LD_INT 1
60180: PPUSH
60181: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60185: LD_ADDR_VAR 0 7
60189: PUSH
60190: LD_EXP 60
60194: PUSH
60195: LD_VAR 0 2
60199: ARRAY
60200: ST_TO_ADDR
// if mc_scan [ i ] then
60201: LD_EXP 82
60205: PUSH
60206: LD_VAR 0 2
60210: ARRAY
60211: IFFALSE 60273
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60213: LD_ADDR_VAR 0 7
60217: PUSH
60218: LD_EXP 60
60222: PUSH
60223: LD_VAR 0 2
60227: ARRAY
60228: PPUSH
60229: LD_INT 3
60231: PUSH
60232: LD_INT 30
60234: PUSH
60235: LD_INT 32
60237: PUSH
60238: EMPTY
60239: LIST
60240: LIST
60241: PUSH
60242: LD_INT 30
60244: PUSH
60245: LD_INT 33
60247: PUSH
60248: EMPTY
60249: LIST
60250: LIST
60251: PUSH
60252: LD_INT 30
60254: PUSH
60255: LD_INT 31
60257: PUSH
60258: EMPTY
60259: LIST
60260: LIST
60261: PUSH
60262: EMPTY
60263: LIST
60264: LIST
60265: LIST
60266: LIST
60267: PPUSH
60268: CALL_OW 72
60272: ST_TO_ADDR
// if not to_repair_tmp then
60273: LD_VAR 0 7
60277: NOT
60278: IFFALSE 60282
// continue ;
60280: GO 60080
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60282: LD_ADDR_VAR 0 8
60286: PUSH
60287: LD_VAR 0 7
60291: PPUSH
60292: LD_VAR 0 3
60296: PPUSH
60297: CALL_OW 74
60301: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
60302: LD_VAR 0 8
60306: PPUSH
60307: LD_INT 16
60309: PPUSH
60310: CALL 21831 0 2
60314: PUSH
60315: LD_INT 4
60317: ARRAY
60318: PUSH
60319: LD_INT 5
60321: LESS
60322: IFFALSE 60338
// ComRepairBuilding ( j , to_repair ) ;
60324: LD_VAR 0 3
60328: PPUSH
60329: LD_VAR 0 8
60333: PPUSH
60334: CALL_OW 130
// end ;
60338: GO 60080
60340: POP
60341: POP
// end ;
60342: GO 59526
60344: POP
60345: POP
// end ;
60346: LD_VAR 0 1
60350: RET
// export function MC_Heal ; var i , j , tmp ; begin
60351: LD_INT 0
60353: PPUSH
60354: PPUSH
60355: PPUSH
60356: PPUSH
// if not mc_bases then
60357: LD_EXP 59
60361: NOT
60362: IFFALSE 60366
// exit ;
60364: GO 60768
// for i = 1 to mc_bases do
60366: LD_ADDR_VAR 0 2
60370: PUSH
60371: DOUBLE
60372: LD_INT 1
60374: DEC
60375: ST_TO_ADDR
60376: LD_EXP 59
60380: PUSH
60381: FOR_TO
60382: IFFALSE 60766
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60384: LD_EXP 62
60388: PUSH
60389: LD_VAR 0 2
60393: ARRAY
60394: PUSH
60395: LD_INT 1
60397: ARRAY
60398: NOT
60399: PUSH
60400: LD_EXP 62
60404: PUSH
60405: LD_VAR 0 2
60409: ARRAY
60410: PUSH
60411: LD_INT 2
60413: ARRAY
60414: NOT
60415: AND
60416: IFFALSE 60454
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60418: LD_ADDR_EXP 63
60422: PUSH
60423: LD_EXP 63
60427: PPUSH
60428: LD_VAR 0 2
60432: PPUSH
60433: EMPTY
60434: PPUSH
60435: CALL_OW 1
60439: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60440: LD_VAR 0 2
60444: PPUSH
60445: LD_INT 102
60447: PPUSH
60448: CALL 54615 0 2
// continue ;
60452: GO 60381
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60454: LD_ADDR_VAR 0 4
60458: PUSH
60459: LD_EXP 59
60463: PUSH
60464: LD_VAR 0 2
60468: ARRAY
60469: PPUSH
60470: LD_INT 25
60472: PUSH
60473: LD_INT 4
60475: PUSH
60476: EMPTY
60477: LIST
60478: LIST
60479: PPUSH
60480: CALL_OW 72
60484: ST_TO_ADDR
// if not tmp then
60485: LD_VAR 0 4
60489: NOT
60490: IFFALSE 60494
// continue ;
60492: GO 60381
// if mc_taming [ i ] then
60494: LD_EXP 90
60498: PUSH
60499: LD_VAR 0 2
60503: ARRAY
60504: IFFALSE 60528
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60506: LD_ADDR_EXP 90
60510: PUSH
60511: LD_EXP 90
60515: PPUSH
60516: LD_VAR 0 2
60520: PPUSH
60521: EMPTY
60522: PPUSH
60523: CALL_OW 1
60527: ST_TO_ADDR
// for j in tmp do
60528: LD_ADDR_VAR 0 3
60532: PUSH
60533: LD_VAR 0 4
60537: PUSH
60538: FOR_IN
60539: IFFALSE 60762
// begin if IsInUnit ( j ) then
60541: LD_VAR 0 3
60545: PPUSH
60546: CALL_OW 310
60550: IFFALSE 60561
// ComExitBuilding ( j ) ;
60552: LD_VAR 0 3
60556: PPUSH
60557: CALL_OW 122
// if not j in mc_healers [ i ] then
60561: LD_VAR 0 3
60565: PUSH
60566: LD_EXP 63
60570: PUSH
60571: LD_VAR 0 2
60575: ARRAY
60576: IN
60577: NOT
60578: IFFALSE 60624
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60580: LD_ADDR_EXP 63
60584: PUSH
60585: LD_EXP 63
60589: PPUSH
60590: LD_VAR 0 2
60594: PUSH
60595: LD_EXP 63
60599: PUSH
60600: LD_VAR 0 2
60604: ARRAY
60605: PUSH
60606: LD_INT 1
60608: PLUS
60609: PUSH
60610: EMPTY
60611: LIST
60612: LIST
60613: PPUSH
60614: LD_VAR 0 3
60618: PPUSH
60619: CALL 19238 0 3
60623: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60624: LD_VAR 0 3
60628: PPUSH
60629: CALL_OW 110
60633: PUSH
60634: LD_INT 102
60636: NONEQUAL
60637: IFFALSE 60651
// SetTag ( j , 102 ) ;
60639: LD_VAR 0 3
60643: PPUSH
60644: LD_INT 102
60646: PPUSH
60647: CALL_OW 109
// Wait ( 3 ) ;
60651: LD_INT 3
60653: PPUSH
60654: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60658: LD_EXP 62
60662: PUSH
60663: LD_VAR 0 2
60667: ARRAY
60668: PUSH
60669: LD_INT 1
60671: ARRAY
60672: IFFALSE 60704
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60674: LD_VAR 0 3
60678: PPUSH
60679: LD_EXP 62
60683: PUSH
60684: LD_VAR 0 2
60688: ARRAY
60689: PUSH
60690: LD_INT 1
60692: ARRAY
60693: PUSH
60694: LD_INT 1
60696: ARRAY
60697: PPUSH
60698: CALL_OW 128
60702: GO 60760
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60704: LD_VAR 0 3
60708: PPUSH
60709: CALL_OW 314
60713: NOT
60714: PUSH
60715: LD_EXP 62
60719: PUSH
60720: LD_VAR 0 2
60724: ARRAY
60725: PUSH
60726: LD_INT 2
60728: ARRAY
60729: AND
60730: IFFALSE 60760
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60732: LD_VAR 0 3
60736: PPUSH
60737: LD_EXP 62
60741: PUSH
60742: LD_VAR 0 2
60746: ARRAY
60747: PUSH
60748: LD_INT 2
60750: ARRAY
60751: PUSH
60752: LD_INT 1
60754: ARRAY
60755: PPUSH
60756: CALL_OW 128
// end ;
60760: GO 60538
60762: POP
60763: POP
// end ;
60764: GO 60381
60766: POP
60767: POP
// end ;
60768: LD_VAR 0 1
60772: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60773: LD_INT 0
60775: PPUSH
60776: PPUSH
60777: PPUSH
60778: PPUSH
60779: PPUSH
// if not mc_bases then
60780: LD_EXP 59
60784: NOT
60785: IFFALSE 60789
// exit ;
60787: GO 61932
// for i = 1 to mc_bases do
60789: LD_ADDR_VAR 0 2
60793: PUSH
60794: DOUBLE
60795: LD_INT 1
60797: DEC
60798: ST_TO_ADDR
60799: LD_EXP 59
60803: PUSH
60804: FOR_TO
60805: IFFALSE 61930
// begin if mc_scan [ i ] then
60807: LD_EXP 82
60811: PUSH
60812: LD_VAR 0 2
60816: ARRAY
60817: IFFALSE 60821
// continue ;
60819: GO 60804
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60821: LD_EXP 64
60825: PUSH
60826: LD_VAR 0 2
60830: ARRAY
60831: NOT
60832: PUSH
60833: LD_EXP 66
60837: PUSH
60838: LD_VAR 0 2
60842: ARRAY
60843: NOT
60844: AND
60845: PUSH
60846: LD_EXP 65
60850: PUSH
60851: LD_VAR 0 2
60855: ARRAY
60856: AND
60857: IFFALSE 60895
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60859: LD_ADDR_EXP 65
60863: PUSH
60864: LD_EXP 65
60868: PPUSH
60869: LD_VAR 0 2
60873: PPUSH
60874: EMPTY
60875: PPUSH
60876: CALL_OW 1
60880: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60881: LD_VAR 0 2
60885: PPUSH
60886: LD_INT 103
60888: PPUSH
60889: CALL 54615 0 2
// continue ;
60893: GO 60804
// end ; if mc_construct_list [ i ] then
60895: LD_EXP 66
60899: PUSH
60900: LD_VAR 0 2
60904: ARRAY
60905: IFFALSE 61125
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
60907: LD_ADDR_VAR 0 4
60911: PUSH
60912: LD_EXP 59
60916: PUSH
60917: LD_VAR 0 2
60921: ARRAY
60922: PPUSH
60923: LD_INT 25
60925: PUSH
60926: LD_INT 2
60928: PUSH
60929: EMPTY
60930: LIST
60931: LIST
60932: PPUSH
60933: CALL_OW 72
60937: PUSH
60938: LD_EXP 61
60942: PUSH
60943: LD_VAR 0 2
60947: ARRAY
60948: DIFF
60949: ST_TO_ADDR
// if not tmp then
60950: LD_VAR 0 4
60954: NOT
60955: IFFALSE 60959
// continue ;
60957: GO 60804
// for j in tmp do
60959: LD_ADDR_VAR 0 3
60963: PUSH
60964: LD_VAR 0 4
60968: PUSH
60969: FOR_IN
60970: IFFALSE 61121
// begin if not mc_builders [ i ] then
60972: LD_EXP 65
60976: PUSH
60977: LD_VAR 0 2
60981: ARRAY
60982: NOT
60983: IFFALSE 61041
// begin SetTag ( j , 103 ) ;
60985: LD_VAR 0 3
60989: PPUSH
60990: LD_INT 103
60992: PPUSH
60993: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
60997: LD_ADDR_EXP 65
61001: PUSH
61002: LD_EXP 65
61006: PPUSH
61007: LD_VAR 0 2
61011: PUSH
61012: LD_EXP 65
61016: PUSH
61017: LD_VAR 0 2
61021: ARRAY
61022: PUSH
61023: LD_INT 1
61025: PLUS
61026: PUSH
61027: EMPTY
61028: LIST
61029: LIST
61030: PPUSH
61031: LD_VAR 0 3
61035: PPUSH
61036: CALL 19238 0 3
61040: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61041: LD_VAR 0 3
61045: PPUSH
61046: CALL_OW 310
61050: IFFALSE 61061
// ComExitBuilding ( j ) ;
61052: LD_VAR 0 3
61056: PPUSH
61057: CALL_OW 122
// wait ( 3 ) ;
61061: LD_INT 3
61063: PPUSH
61064: CALL_OW 67
// if not mc_construct_list [ i ] then
61068: LD_EXP 66
61072: PUSH
61073: LD_VAR 0 2
61077: ARRAY
61078: NOT
61079: IFFALSE 61083
// break ;
61081: GO 61121
// if not HasTask ( j ) then
61083: LD_VAR 0 3
61087: PPUSH
61088: CALL_OW 314
61092: NOT
61093: IFFALSE 61119
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61095: LD_VAR 0 3
61099: PPUSH
61100: LD_EXP 66
61104: PUSH
61105: LD_VAR 0 2
61109: ARRAY
61110: PUSH
61111: LD_INT 1
61113: ARRAY
61114: PPUSH
61115: CALL 22089 0 2
// end ;
61119: GO 60969
61121: POP
61122: POP
// end else
61123: GO 61928
// if mc_build_list [ i ] then
61125: LD_EXP 64
61129: PUSH
61130: LD_VAR 0 2
61134: ARRAY
61135: IFFALSE 61928
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61137: LD_ADDR_VAR 0 5
61141: PUSH
61142: LD_EXP 59
61146: PUSH
61147: LD_VAR 0 2
61151: ARRAY
61152: PPUSH
61153: LD_INT 2
61155: PUSH
61156: LD_INT 30
61158: PUSH
61159: LD_INT 0
61161: PUSH
61162: EMPTY
61163: LIST
61164: LIST
61165: PUSH
61166: LD_INT 30
61168: PUSH
61169: LD_INT 1
61171: PUSH
61172: EMPTY
61173: LIST
61174: LIST
61175: PUSH
61176: EMPTY
61177: LIST
61178: LIST
61179: LIST
61180: PPUSH
61181: CALL_OW 72
61185: ST_TO_ADDR
// if depot then
61186: LD_VAR 0 5
61190: IFFALSE 61208
// depot := depot [ 1 ] else
61192: LD_ADDR_VAR 0 5
61196: PUSH
61197: LD_VAR 0 5
61201: PUSH
61202: LD_INT 1
61204: ARRAY
61205: ST_TO_ADDR
61206: GO 61216
// depot := 0 ;
61208: LD_ADDR_VAR 0 5
61212: PUSH
61213: LD_INT 0
61215: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61216: LD_EXP 64
61220: PUSH
61221: LD_VAR 0 2
61225: ARRAY
61226: PUSH
61227: LD_INT 1
61229: ARRAY
61230: PUSH
61231: LD_INT 1
61233: ARRAY
61234: PPUSH
61235: CALL 21919 0 1
61239: PUSH
61240: LD_EXP 59
61244: PUSH
61245: LD_VAR 0 2
61249: ARRAY
61250: PPUSH
61251: LD_INT 2
61253: PUSH
61254: LD_INT 30
61256: PUSH
61257: LD_INT 2
61259: PUSH
61260: EMPTY
61261: LIST
61262: LIST
61263: PUSH
61264: LD_INT 30
61266: PUSH
61267: LD_INT 3
61269: PUSH
61270: EMPTY
61271: LIST
61272: LIST
61273: PUSH
61274: EMPTY
61275: LIST
61276: LIST
61277: LIST
61278: PPUSH
61279: CALL_OW 72
61283: NOT
61284: AND
61285: IFFALSE 61390
// begin for j = 1 to mc_build_list [ i ] do
61287: LD_ADDR_VAR 0 3
61291: PUSH
61292: DOUBLE
61293: LD_INT 1
61295: DEC
61296: ST_TO_ADDR
61297: LD_EXP 64
61301: PUSH
61302: LD_VAR 0 2
61306: ARRAY
61307: PUSH
61308: FOR_TO
61309: IFFALSE 61388
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61311: LD_EXP 64
61315: PUSH
61316: LD_VAR 0 2
61320: ARRAY
61321: PUSH
61322: LD_VAR 0 3
61326: ARRAY
61327: PUSH
61328: LD_INT 1
61330: ARRAY
61331: PUSH
61332: LD_INT 2
61334: EQUAL
61335: IFFALSE 61386
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61337: LD_ADDR_EXP 64
61341: PUSH
61342: LD_EXP 64
61346: PPUSH
61347: LD_VAR 0 2
61351: PPUSH
61352: LD_EXP 64
61356: PUSH
61357: LD_VAR 0 2
61361: ARRAY
61362: PPUSH
61363: LD_VAR 0 3
61367: PPUSH
61368: LD_INT 1
61370: PPUSH
61371: LD_INT 0
61373: PPUSH
61374: CALL 18656 0 4
61378: PPUSH
61379: CALL_OW 1
61383: ST_TO_ADDR
// break ;
61384: GO 61388
// end ;
61386: GO 61308
61388: POP
61389: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61390: LD_EXP 64
61394: PUSH
61395: LD_VAR 0 2
61399: ARRAY
61400: PUSH
61401: LD_INT 1
61403: ARRAY
61404: PUSH
61405: LD_INT 1
61407: ARRAY
61408: PUSH
61409: LD_INT 0
61411: EQUAL
61412: PUSH
61413: LD_VAR 0 5
61417: PUSH
61418: LD_VAR 0 5
61422: PPUSH
61423: LD_EXP 64
61427: PUSH
61428: LD_VAR 0 2
61432: ARRAY
61433: PUSH
61434: LD_INT 1
61436: ARRAY
61437: PUSH
61438: LD_INT 1
61440: ARRAY
61441: PPUSH
61442: LD_EXP 64
61446: PUSH
61447: LD_VAR 0 2
61451: ARRAY
61452: PUSH
61453: LD_INT 1
61455: ARRAY
61456: PUSH
61457: LD_INT 2
61459: ARRAY
61460: PPUSH
61461: LD_EXP 64
61465: PUSH
61466: LD_VAR 0 2
61470: ARRAY
61471: PUSH
61472: LD_INT 1
61474: ARRAY
61475: PUSH
61476: LD_INT 3
61478: ARRAY
61479: PPUSH
61480: LD_EXP 64
61484: PUSH
61485: LD_VAR 0 2
61489: ARRAY
61490: PUSH
61491: LD_INT 1
61493: ARRAY
61494: PUSH
61495: LD_INT 4
61497: ARRAY
61498: PPUSH
61499: CALL 26653 0 5
61503: AND
61504: OR
61505: IFFALSE 61786
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61507: LD_ADDR_VAR 0 4
61511: PUSH
61512: LD_EXP 59
61516: PUSH
61517: LD_VAR 0 2
61521: ARRAY
61522: PPUSH
61523: LD_INT 25
61525: PUSH
61526: LD_INT 2
61528: PUSH
61529: EMPTY
61530: LIST
61531: LIST
61532: PPUSH
61533: CALL_OW 72
61537: PUSH
61538: LD_EXP 61
61542: PUSH
61543: LD_VAR 0 2
61547: ARRAY
61548: DIFF
61549: ST_TO_ADDR
// if not tmp then
61550: LD_VAR 0 4
61554: NOT
61555: IFFALSE 61559
// continue ;
61557: GO 60804
// for j in tmp do
61559: LD_ADDR_VAR 0 3
61563: PUSH
61564: LD_VAR 0 4
61568: PUSH
61569: FOR_IN
61570: IFFALSE 61782
// begin if not mc_builders [ i ] then
61572: LD_EXP 65
61576: PUSH
61577: LD_VAR 0 2
61581: ARRAY
61582: NOT
61583: IFFALSE 61641
// begin SetTag ( j , 103 ) ;
61585: LD_VAR 0 3
61589: PPUSH
61590: LD_INT 103
61592: PPUSH
61593: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61597: LD_ADDR_EXP 65
61601: PUSH
61602: LD_EXP 65
61606: PPUSH
61607: LD_VAR 0 2
61611: PUSH
61612: LD_EXP 65
61616: PUSH
61617: LD_VAR 0 2
61621: ARRAY
61622: PUSH
61623: LD_INT 1
61625: PLUS
61626: PUSH
61627: EMPTY
61628: LIST
61629: LIST
61630: PPUSH
61631: LD_VAR 0 3
61635: PPUSH
61636: CALL 19238 0 3
61640: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61641: LD_VAR 0 3
61645: PPUSH
61646: CALL_OW 310
61650: IFFALSE 61661
// ComExitBuilding ( j ) ;
61652: LD_VAR 0 3
61656: PPUSH
61657: CALL_OW 122
// wait ( 3 ) ;
61661: LD_INT 3
61663: PPUSH
61664: CALL_OW 67
// if not mc_build_list [ i ] then
61668: LD_EXP 64
61672: PUSH
61673: LD_VAR 0 2
61677: ARRAY
61678: NOT
61679: IFFALSE 61683
// break ;
61681: GO 61782
// if not HasTask ( j ) then
61683: LD_VAR 0 3
61687: PPUSH
61688: CALL_OW 314
61692: NOT
61693: IFFALSE 61780
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61695: LD_VAR 0 3
61699: PPUSH
61700: LD_EXP 64
61704: PUSH
61705: LD_VAR 0 2
61709: ARRAY
61710: PUSH
61711: LD_INT 1
61713: ARRAY
61714: PUSH
61715: LD_INT 1
61717: ARRAY
61718: PPUSH
61719: LD_EXP 64
61723: PUSH
61724: LD_VAR 0 2
61728: ARRAY
61729: PUSH
61730: LD_INT 1
61732: ARRAY
61733: PUSH
61734: LD_INT 2
61736: ARRAY
61737: PPUSH
61738: LD_EXP 64
61742: PUSH
61743: LD_VAR 0 2
61747: ARRAY
61748: PUSH
61749: LD_INT 1
61751: ARRAY
61752: PUSH
61753: LD_INT 3
61755: ARRAY
61756: PPUSH
61757: LD_EXP 64
61761: PUSH
61762: LD_VAR 0 2
61766: ARRAY
61767: PUSH
61768: LD_INT 1
61770: ARRAY
61771: PUSH
61772: LD_INT 4
61774: ARRAY
61775: PPUSH
61776: CALL_OW 145
// end ;
61780: GO 61569
61782: POP
61783: POP
// end else
61784: GO 61928
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
61786: LD_EXP 59
61790: PUSH
61791: LD_VAR 0 2
61795: ARRAY
61796: PPUSH
61797: LD_EXP 64
61801: PUSH
61802: LD_VAR 0 2
61806: ARRAY
61807: PUSH
61808: LD_INT 1
61810: ARRAY
61811: PUSH
61812: LD_INT 1
61814: ARRAY
61815: PPUSH
61816: LD_EXP 64
61820: PUSH
61821: LD_VAR 0 2
61825: ARRAY
61826: PUSH
61827: LD_INT 1
61829: ARRAY
61830: PUSH
61831: LD_INT 2
61833: ARRAY
61834: PPUSH
61835: LD_EXP 64
61839: PUSH
61840: LD_VAR 0 2
61844: ARRAY
61845: PUSH
61846: LD_INT 1
61848: ARRAY
61849: PUSH
61850: LD_INT 3
61852: ARRAY
61853: PPUSH
61854: LD_EXP 64
61858: PUSH
61859: LD_VAR 0 2
61863: ARRAY
61864: PUSH
61865: LD_INT 1
61867: ARRAY
61868: PUSH
61869: LD_INT 4
61871: ARRAY
61872: PPUSH
61873: CALL 25989 0 5
61877: NOT
61878: IFFALSE 61928
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61880: LD_ADDR_EXP 64
61884: PUSH
61885: LD_EXP 64
61889: PPUSH
61890: LD_VAR 0 2
61894: PPUSH
61895: LD_EXP 64
61899: PUSH
61900: LD_VAR 0 2
61904: ARRAY
61905: PPUSH
61906: LD_INT 1
61908: PPUSH
61909: LD_INT 1
61911: NEG
61912: PPUSH
61913: LD_INT 0
61915: PPUSH
61916: CALL 18656 0 4
61920: PPUSH
61921: CALL_OW 1
61925: ST_TO_ADDR
// continue ;
61926: GO 60804
// end ; end ; end ;
61928: GO 60804
61930: POP
61931: POP
// end ;
61932: LD_VAR 0 1
61936: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
61937: LD_INT 0
61939: PPUSH
61940: PPUSH
61941: PPUSH
61942: PPUSH
61943: PPUSH
61944: PPUSH
// if not mc_bases then
61945: LD_EXP 59
61949: NOT
61950: IFFALSE 61954
// exit ;
61952: GO 62381
// for i = 1 to mc_bases do
61954: LD_ADDR_VAR 0 2
61958: PUSH
61959: DOUBLE
61960: LD_INT 1
61962: DEC
61963: ST_TO_ADDR
61964: LD_EXP 59
61968: PUSH
61969: FOR_TO
61970: IFFALSE 62379
// begin tmp := mc_build_upgrade [ i ] ;
61972: LD_ADDR_VAR 0 4
61976: PUSH
61977: LD_EXP 91
61981: PUSH
61982: LD_VAR 0 2
61986: ARRAY
61987: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
61988: LD_ADDR_VAR 0 6
61992: PUSH
61993: LD_EXP 92
61997: PUSH
61998: LD_VAR 0 2
62002: ARRAY
62003: PPUSH
62004: LD_INT 2
62006: PUSH
62007: LD_INT 30
62009: PUSH
62010: LD_INT 6
62012: PUSH
62013: EMPTY
62014: LIST
62015: LIST
62016: PUSH
62017: LD_INT 30
62019: PUSH
62020: LD_INT 7
62022: PUSH
62023: EMPTY
62024: LIST
62025: LIST
62026: PUSH
62027: EMPTY
62028: LIST
62029: LIST
62030: LIST
62031: PPUSH
62032: CALL_OW 72
62036: ST_TO_ADDR
// if not tmp and not lab then
62037: LD_VAR 0 4
62041: NOT
62042: PUSH
62043: LD_VAR 0 6
62047: NOT
62048: AND
62049: IFFALSE 62053
// continue ;
62051: GO 61969
// if tmp then
62053: LD_VAR 0 4
62057: IFFALSE 62177
// for j in tmp do
62059: LD_ADDR_VAR 0 3
62063: PUSH
62064: LD_VAR 0 4
62068: PUSH
62069: FOR_IN
62070: IFFALSE 62175
// begin if UpgradeCost ( j ) then
62072: LD_VAR 0 3
62076: PPUSH
62077: CALL 25649 0 1
62081: IFFALSE 62173
// begin ComUpgrade ( j ) ;
62083: LD_VAR 0 3
62087: PPUSH
62088: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62092: LD_ADDR_EXP 91
62096: PUSH
62097: LD_EXP 91
62101: PPUSH
62102: LD_VAR 0 2
62106: PPUSH
62107: LD_EXP 91
62111: PUSH
62112: LD_VAR 0 2
62116: ARRAY
62117: PUSH
62118: LD_VAR 0 3
62122: DIFF
62123: PPUSH
62124: CALL_OW 1
62128: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62129: LD_ADDR_EXP 66
62133: PUSH
62134: LD_EXP 66
62138: PPUSH
62139: LD_VAR 0 2
62143: PUSH
62144: LD_EXP 66
62148: PUSH
62149: LD_VAR 0 2
62153: ARRAY
62154: PUSH
62155: LD_INT 1
62157: PLUS
62158: PUSH
62159: EMPTY
62160: LIST
62161: LIST
62162: PPUSH
62163: LD_VAR 0 3
62167: PPUSH
62168: CALL 19238 0 3
62172: ST_TO_ADDR
// end ; end ;
62173: GO 62069
62175: POP
62176: POP
// if not lab or not mc_lab_upgrade [ i ] then
62177: LD_VAR 0 6
62181: NOT
62182: PUSH
62183: LD_EXP 93
62187: PUSH
62188: LD_VAR 0 2
62192: ARRAY
62193: NOT
62194: OR
62195: IFFALSE 62199
// continue ;
62197: GO 61969
// for j in lab do
62199: LD_ADDR_VAR 0 3
62203: PUSH
62204: LD_VAR 0 6
62208: PUSH
62209: FOR_IN
62210: IFFALSE 62375
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62212: LD_VAR 0 3
62216: PPUSH
62217: CALL_OW 266
62221: PUSH
62222: LD_INT 6
62224: PUSH
62225: LD_INT 7
62227: PUSH
62228: EMPTY
62229: LIST
62230: LIST
62231: IN
62232: PUSH
62233: LD_VAR 0 3
62237: PPUSH
62238: CALL_OW 461
62242: PUSH
62243: LD_INT 1
62245: NONEQUAL
62246: AND
62247: IFFALSE 62373
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62249: LD_VAR 0 3
62253: PPUSH
62254: LD_EXP 93
62258: PUSH
62259: LD_VAR 0 2
62263: ARRAY
62264: PUSH
62265: LD_INT 1
62267: ARRAY
62268: PPUSH
62269: CALL 25854 0 2
62273: IFFALSE 62373
// begin ComCancel ( j ) ;
62275: LD_VAR 0 3
62279: PPUSH
62280: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62284: LD_VAR 0 3
62288: PPUSH
62289: LD_EXP 93
62293: PUSH
62294: LD_VAR 0 2
62298: ARRAY
62299: PUSH
62300: LD_INT 1
62302: ARRAY
62303: PPUSH
62304: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62308: LD_VAR 0 3
62312: PUSH
62313: LD_EXP 66
62317: PUSH
62318: LD_VAR 0 2
62322: ARRAY
62323: IN
62324: NOT
62325: IFFALSE 62371
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62327: LD_ADDR_EXP 66
62331: PUSH
62332: LD_EXP 66
62336: PPUSH
62337: LD_VAR 0 2
62341: PUSH
62342: LD_EXP 66
62346: PUSH
62347: LD_VAR 0 2
62351: ARRAY
62352: PUSH
62353: LD_INT 1
62355: PLUS
62356: PUSH
62357: EMPTY
62358: LIST
62359: LIST
62360: PPUSH
62361: LD_VAR 0 3
62365: PPUSH
62366: CALL 19238 0 3
62370: ST_TO_ADDR
// break ;
62371: GO 62375
// end ; end ; end ;
62373: GO 62209
62375: POP
62376: POP
// end ;
62377: GO 61969
62379: POP
62380: POP
// end ;
62381: LD_VAR 0 1
62385: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62386: LD_INT 0
62388: PPUSH
62389: PPUSH
62390: PPUSH
62391: PPUSH
62392: PPUSH
62393: PPUSH
62394: PPUSH
62395: PPUSH
62396: PPUSH
// if not mc_bases then
62397: LD_EXP 59
62401: NOT
62402: IFFALSE 62406
// exit ;
62404: GO 62811
// for i = 1 to mc_bases do
62406: LD_ADDR_VAR 0 2
62410: PUSH
62411: DOUBLE
62412: LD_INT 1
62414: DEC
62415: ST_TO_ADDR
62416: LD_EXP 59
62420: PUSH
62421: FOR_TO
62422: IFFALSE 62809
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62424: LD_EXP 67
62428: PUSH
62429: LD_VAR 0 2
62433: ARRAY
62434: NOT
62435: PUSH
62436: LD_EXP 59
62440: PUSH
62441: LD_VAR 0 2
62445: ARRAY
62446: PPUSH
62447: LD_INT 30
62449: PUSH
62450: LD_INT 3
62452: PUSH
62453: EMPTY
62454: LIST
62455: LIST
62456: PPUSH
62457: CALL_OW 72
62461: NOT
62462: OR
62463: IFFALSE 62467
// continue ;
62465: GO 62421
// busy := false ;
62467: LD_ADDR_VAR 0 8
62471: PUSH
62472: LD_INT 0
62474: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62475: LD_ADDR_VAR 0 4
62479: PUSH
62480: LD_EXP 59
62484: PUSH
62485: LD_VAR 0 2
62489: ARRAY
62490: PPUSH
62491: LD_INT 30
62493: PUSH
62494: LD_INT 3
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: PPUSH
62501: CALL_OW 72
62505: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62506: LD_ADDR_VAR 0 6
62510: PUSH
62511: LD_EXP 67
62515: PUSH
62516: LD_VAR 0 2
62520: ARRAY
62521: PPUSH
62522: LD_INT 2
62524: PUSH
62525: LD_INT 30
62527: PUSH
62528: LD_INT 32
62530: PUSH
62531: EMPTY
62532: LIST
62533: LIST
62534: PUSH
62535: LD_INT 30
62537: PUSH
62538: LD_INT 33
62540: PUSH
62541: EMPTY
62542: LIST
62543: LIST
62544: PUSH
62545: EMPTY
62546: LIST
62547: LIST
62548: LIST
62549: PPUSH
62550: CALL_OW 72
62554: ST_TO_ADDR
// if not t then
62555: LD_VAR 0 6
62559: NOT
62560: IFFALSE 62564
// continue ;
62562: GO 62421
// for j in tmp do
62564: LD_ADDR_VAR 0 3
62568: PUSH
62569: LD_VAR 0 4
62573: PUSH
62574: FOR_IN
62575: IFFALSE 62605
// if not BuildingStatus ( j ) = bs_idle then
62577: LD_VAR 0 3
62581: PPUSH
62582: CALL_OW 461
62586: PUSH
62587: LD_INT 2
62589: EQUAL
62590: NOT
62591: IFFALSE 62603
// begin busy := true ;
62593: LD_ADDR_VAR 0 8
62597: PUSH
62598: LD_INT 1
62600: ST_TO_ADDR
// break ;
62601: GO 62605
// end ;
62603: GO 62574
62605: POP
62606: POP
// if busy then
62607: LD_VAR 0 8
62611: IFFALSE 62615
// continue ;
62613: GO 62421
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62615: LD_ADDR_VAR 0 7
62619: PUSH
62620: LD_VAR 0 6
62624: PPUSH
62625: LD_INT 35
62627: PUSH
62628: LD_INT 0
62630: PUSH
62631: EMPTY
62632: LIST
62633: LIST
62634: PPUSH
62635: CALL_OW 72
62639: ST_TO_ADDR
// if tw then
62640: LD_VAR 0 7
62644: IFFALSE 62721
// begin tw := tw [ 1 ] ;
62646: LD_ADDR_VAR 0 7
62650: PUSH
62651: LD_VAR 0 7
62655: PUSH
62656: LD_INT 1
62658: ARRAY
62659: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62660: LD_ADDR_VAR 0 9
62664: PUSH
62665: LD_VAR 0 7
62669: PPUSH
62670: LD_EXP 84
62674: PUSH
62675: LD_VAR 0 2
62679: ARRAY
62680: PPUSH
62681: CALL 24208 0 2
62685: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62686: LD_EXP 98
62690: PUSH
62691: LD_VAR 0 2
62695: ARRAY
62696: IFFALSE 62719
// if not weapon in mc_allowed_tower_weapons [ i ] then
62698: LD_VAR 0 9
62702: PUSH
62703: LD_EXP 98
62707: PUSH
62708: LD_VAR 0 2
62712: ARRAY
62713: IN
62714: NOT
62715: IFFALSE 62719
// continue ;
62717: GO 62421
// end else
62719: GO 62784
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62721: LD_ADDR_VAR 0 5
62725: PUSH
62726: LD_EXP 67
62730: PUSH
62731: LD_VAR 0 2
62735: ARRAY
62736: PPUSH
62737: LD_VAR 0 4
62741: PPUSH
62742: CALL 49710 0 2
62746: ST_TO_ADDR
// if not tmp2 then
62747: LD_VAR 0 5
62751: NOT
62752: IFFALSE 62756
// continue ;
62754: GO 62421
// tw := tmp2 [ 1 ] ;
62756: LD_ADDR_VAR 0 7
62760: PUSH
62761: LD_VAR 0 5
62765: PUSH
62766: LD_INT 1
62768: ARRAY
62769: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62770: LD_ADDR_VAR 0 9
62774: PUSH
62775: LD_VAR 0 5
62779: PUSH
62780: LD_INT 2
62782: ARRAY
62783: ST_TO_ADDR
// end ; if not weapon then
62784: LD_VAR 0 9
62788: NOT
62789: IFFALSE 62793
// continue ;
62791: GO 62421
// ComPlaceWeapon ( tw , weapon ) ;
62793: LD_VAR 0 7
62797: PPUSH
62798: LD_VAR 0 9
62802: PPUSH
62803: CALL_OW 148
// end ;
62807: GO 62421
62809: POP
62810: POP
// end ;
62811: LD_VAR 0 1
62815: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
62816: LD_INT 0
62818: PPUSH
62819: PPUSH
62820: PPUSH
62821: PPUSH
62822: PPUSH
62823: PPUSH
// if not mc_bases then
62824: LD_EXP 59
62828: NOT
62829: IFFALSE 62833
// exit ;
62831: GO 63609
// for i = 1 to mc_bases do
62833: LD_ADDR_VAR 0 2
62837: PUSH
62838: DOUBLE
62839: LD_INT 1
62841: DEC
62842: ST_TO_ADDR
62843: LD_EXP 59
62847: PUSH
62848: FOR_TO
62849: IFFALSE 63607
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62851: LD_EXP 72
62855: PUSH
62856: LD_VAR 0 2
62860: ARRAY
62861: NOT
62862: PUSH
62863: LD_EXP 72
62867: PUSH
62868: LD_VAR 0 2
62872: ARRAY
62873: PUSH
62874: LD_EXP 73
62878: PUSH
62879: LD_VAR 0 2
62883: ARRAY
62884: EQUAL
62885: OR
62886: PUSH
62887: LD_EXP 82
62891: PUSH
62892: LD_VAR 0 2
62896: ARRAY
62897: OR
62898: IFFALSE 62902
// continue ;
62900: GO 62848
// if mc_miners [ i ] then
62902: LD_EXP 73
62906: PUSH
62907: LD_VAR 0 2
62911: ARRAY
62912: IFFALSE 63294
// begin for j = mc_miners [ i ] downto 1 do
62914: LD_ADDR_VAR 0 3
62918: PUSH
62919: DOUBLE
62920: LD_EXP 73
62924: PUSH
62925: LD_VAR 0 2
62929: ARRAY
62930: INC
62931: ST_TO_ADDR
62932: LD_INT 1
62934: PUSH
62935: FOR_DOWNTO
62936: IFFALSE 63292
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
62938: LD_EXP 73
62942: PUSH
62943: LD_VAR 0 2
62947: ARRAY
62948: PUSH
62949: LD_VAR 0 3
62953: ARRAY
62954: PPUSH
62955: CALL_OW 301
62959: PUSH
62960: LD_EXP 73
62964: PUSH
62965: LD_VAR 0 2
62969: ARRAY
62970: PUSH
62971: LD_VAR 0 3
62975: ARRAY
62976: PPUSH
62977: CALL_OW 257
62981: PUSH
62982: LD_INT 1
62984: NONEQUAL
62985: OR
62986: IFFALSE 63049
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
62988: LD_ADDR_VAR 0 5
62992: PUSH
62993: LD_EXP 73
62997: PUSH
62998: LD_VAR 0 2
63002: ARRAY
63003: PUSH
63004: LD_EXP 73
63008: PUSH
63009: LD_VAR 0 2
63013: ARRAY
63014: PUSH
63015: LD_VAR 0 3
63019: ARRAY
63020: DIFF
63021: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63022: LD_ADDR_EXP 73
63026: PUSH
63027: LD_EXP 73
63031: PPUSH
63032: LD_VAR 0 2
63036: PPUSH
63037: LD_VAR 0 5
63041: PPUSH
63042: CALL_OW 1
63046: ST_TO_ADDR
// continue ;
63047: GO 62935
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63049: LD_EXP 73
63053: PUSH
63054: LD_VAR 0 2
63058: ARRAY
63059: PUSH
63060: LD_VAR 0 3
63064: ARRAY
63065: PPUSH
63066: CALL_OW 257
63070: PUSH
63071: LD_INT 1
63073: EQUAL
63074: PUSH
63075: LD_EXP 73
63079: PUSH
63080: LD_VAR 0 2
63084: ARRAY
63085: PUSH
63086: LD_VAR 0 3
63090: ARRAY
63091: PPUSH
63092: CALL_OW 459
63096: NOT
63097: AND
63098: PUSH
63099: LD_EXP 73
63103: PUSH
63104: LD_VAR 0 2
63108: ARRAY
63109: PUSH
63110: LD_VAR 0 3
63114: ARRAY
63115: PPUSH
63116: CALL_OW 314
63120: NOT
63121: AND
63122: IFFALSE 63290
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63124: LD_EXP 73
63128: PUSH
63129: LD_VAR 0 2
63133: ARRAY
63134: PUSH
63135: LD_VAR 0 3
63139: ARRAY
63140: PPUSH
63141: CALL_OW 310
63145: IFFALSE 63168
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63147: LD_EXP 73
63151: PUSH
63152: LD_VAR 0 2
63156: ARRAY
63157: PUSH
63158: LD_VAR 0 3
63162: ARRAY
63163: PPUSH
63164: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63168: LD_EXP 73
63172: PUSH
63173: LD_VAR 0 2
63177: ARRAY
63178: PUSH
63179: LD_VAR 0 3
63183: ARRAY
63184: PPUSH
63185: CALL_OW 314
63189: NOT
63190: IFFALSE 63290
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63192: LD_EXP 73
63196: PUSH
63197: LD_VAR 0 2
63201: ARRAY
63202: PUSH
63203: LD_VAR 0 3
63207: ARRAY
63208: PPUSH
63209: LD_EXP 72
63213: PUSH
63214: LD_VAR 0 2
63218: ARRAY
63219: PUSH
63220: LD_VAR 0 3
63224: PUSH
63225: LD_EXP 72
63229: PUSH
63230: LD_VAR 0 2
63234: ARRAY
63235: MOD
63236: PUSH
63237: LD_INT 1
63239: PLUS
63240: ARRAY
63241: PUSH
63242: LD_INT 1
63244: ARRAY
63245: PPUSH
63246: LD_EXP 72
63250: PUSH
63251: LD_VAR 0 2
63255: ARRAY
63256: PUSH
63257: LD_VAR 0 3
63261: PUSH
63262: LD_EXP 72
63266: PUSH
63267: LD_VAR 0 2
63271: ARRAY
63272: MOD
63273: PUSH
63274: LD_INT 1
63276: PLUS
63277: ARRAY
63278: PUSH
63279: LD_INT 2
63281: ARRAY
63282: PPUSH
63283: LD_INT 0
63285: PPUSH
63286: CALL_OW 193
// end ; end ;
63290: GO 62935
63292: POP
63293: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63294: LD_ADDR_VAR 0 5
63298: PUSH
63299: LD_EXP 59
63303: PUSH
63304: LD_VAR 0 2
63308: ARRAY
63309: PPUSH
63310: LD_INT 2
63312: PUSH
63313: LD_INT 30
63315: PUSH
63316: LD_INT 4
63318: PUSH
63319: EMPTY
63320: LIST
63321: LIST
63322: PUSH
63323: LD_INT 30
63325: PUSH
63326: LD_INT 5
63328: PUSH
63329: EMPTY
63330: LIST
63331: LIST
63332: PUSH
63333: LD_INT 30
63335: PUSH
63336: LD_INT 32
63338: PUSH
63339: EMPTY
63340: LIST
63341: LIST
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: LIST
63347: LIST
63348: PPUSH
63349: CALL_OW 72
63353: ST_TO_ADDR
// if not tmp then
63354: LD_VAR 0 5
63358: NOT
63359: IFFALSE 63363
// continue ;
63361: GO 62848
// list := [ ] ;
63363: LD_ADDR_VAR 0 6
63367: PUSH
63368: EMPTY
63369: ST_TO_ADDR
// for j in tmp do
63370: LD_ADDR_VAR 0 3
63374: PUSH
63375: LD_VAR 0 5
63379: PUSH
63380: FOR_IN
63381: IFFALSE 63450
// begin for k in UnitsInside ( j ) do
63383: LD_ADDR_VAR 0 4
63387: PUSH
63388: LD_VAR 0 3
63392: PPUSH
63393: CALL_OW 313
63397: PUSH
63398: FOR_IN
63399: IFFALSE 63446
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63401: LD_VAR 0 4
63405: PPUSH
63406: CALL_OW 257
63410: PUSH
63411: LD_INT 1
63413: EQUAL
63414: PUSH
63415: LD_VAR 0 4
63419: PPUSH
63420: CALL_OW 459
63424: NOT
63425: AND
63426: IFFALSE 63444
// list := list ^ k ;
63428: LD_ADDR_VAR 0 6
63432: PUSH
63433: LD_VAR 0 6
63437: PUSH
63438: LD_VAR 0 4
63442: ADD
63443: ST_TO_ADDR
63444: GO 63398
63446: POP
63447: POP
// end ;
63448: GO 63380
63450: POP
63451: POP
// list := list diff mc_miners [ i ] ;
63452: LD_ADDR_VAR 0 6
63456: PUSH
63457: LD_VAR 0 6
63461: PUSH
63462: LD_EXP 73
63466: PUSH
63467: LD_VAR 0 2
63471: ARRAY
63472: DIFF
63473: ST_TO_ADDR
// if not list then
63474: LD_VAR 0 6
63478: NOT
63479: IFFALSE 63483
// continue ;
63481: GO 62848
// k := mc_mines [ i ] - mc_miners [ i ] ;
63483: LD_ADDR_VAR 0 4
63487: PUSH
63488: LD_EXP 72
63492: PUSH
63493: LD_VAR 0 2
63497: ARRAY
63498: PUSH
63499: LD_EXP 73
63503: PUSH
63504: LD_VAR 0 2
63508: ARRAY
63509: MINUS
63510: ST_TO_ADDR
// if k > list then
63511: LD_VAR 0 4
63515: PUSH
63516: LD_VAR 0 6
63520: GREATER
63521: IFFALSE 63533
// k := list ;
63523: LD_ADDR_VAR 0 4
63527: PUSH
63528: LD_VAR 0 6
63532: ST_TO_ADDR
// for j = 1 to k do
63533: LD_ADDR_VAR 0 3
63537: PUSH
63538: DOUBLE
63539: LD_INT 1
63541: DEC
63542: ST_TO_ADDR
63543: LD_VAR 0 4
63547: PUSH
63548: FOR_TO
63549: IFFALSE 63603
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63551: LD_ADDR_EXP 73
63555: PUSH
63556: LD_EXP 73
63560: PPUSH
63561: LD_VAR 0 2
63565: PUSH
63566: LD_EXP 73
63570: PUSH
63571: LD_VAR 0 2
63575: ARRAY
63576: PUSH
63577: LD_INT 1
63579: PLUS
63580: PUSH
63581: EMPTY
63582: LIST
63583: LIST
63584: PPUSH
63585: LD_VAR 0 6
63589: PUSH
63590: LD_VAR 0 3
63594: ARRAY
63595: PPUSH
63596: CALL 19238 0 3
63600: ST_TO_ADDR
63601: GO 63548
63603: POP
63604: POP
// end ;
63605: GO 62848
63607: POP
63608: POP
// end ;
63609: LD_VAR 0 1
63613: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63614: LD_INT 0
63616: PPUSH
63617: PPUSH
63618: PPUSH
63619: PPUSH
63620: PPUSH
63621: PPUSH
63622: PPUSH
63623: PPUSH
63624: PPUSH
63625: PPUSH
// if not mc_bases then
63626: LD_EXP 59
63630: NOT
63631: IFFALSE 63635
// exit ;
63633: GO 65385
// for i = 1 to mc_bases do
63635: LD_ADDR_VAR 0 2
63639: PUSH
63640: DOUBLE
63641: LD_INT 1
63643: DEC
63644: ST_TO_ADDR
63645: LD_EXP 59
63649: PUSH
63650: FOR_TO
63651: IFFALSE 65383
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63653: LD_EXP 59
63657: PUSH
63658: LD_VAR 0 2
63662: ARRAY
63663: NOT
63664: PUSH
63665: LD_EXP 66
63669: PUSH
63670: LD_VAR 0 2
63674: ARRAY
63675: OR
63676: IFFALSE 63680
// continue ;
63678: GO 63650
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63680: LD_EXP 75
63684: PUSH
63685: LD_VAR 0 2
63689: ARRAY
63690: NOT
63691: PUSH
63692: LD_EXP 76
63696: PUSH
63697: LD_VAR 0 2
63701: ARRAY
63702: AND
63703: IFFALSE 63741
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63705: LD_ADDR_EXP 76
63709: PUSH
63710: LD_EXP 76
63714: PPUSH
63715: LD_VAR 0 2
63719: PPUSH
63720: EMPTY
63721: PPUSH
63722: CALL_OW 1
63726: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63727: LD_VAR 0 2
63731: PPUSH
63732: LD_INT 107
63734: PPUSH
63735: CALL 54615 0 2
// continue ;
63739: GO 63650
// end ; target := [ ] ;
63741: LD_ADDR_VAR 0 6
63745: PUSH
63746: EMPTY
63747: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63748: LD_ADDR_VAR 0 3
63752: PUSH
63753: DOUBLE
63754: LD_EXP 75
63758: PUSH
63759: LD_VAR 0 2
63763: ARRAY
63764: INC
63765: ST_TO_ADDR
63766: LD_INT 1
63768: PUSH
63769: FOR_DOWNTO
63770: IFFALSE 64030
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63772: LD_EXP 75
63776: PUSH
63777: LD_VAR 0 2
63781: ARRAY
63782: PUSH
63783: LD_VAR 0 3
63787: ARRAY
63788: PUSH
63789: LD_INT 2
63791: ARRAY
63792: PPUSH
63793: LD_EXP 75
63797: PUSH
63798: LD_VAR 0 2
63802: ARRAY
63803: PUSH
63804: LD_VAR 0 3
63808: ARRAY
63809: PUSH
63810: LD_INT 3
63812: ARRAY
63813: PPUSH
63814: CALL_OW 488
63818: PUSH
63819: LD_EXP 75
63823: PUSH
63824: LD_VAR 0 2
63828: ARRAY
63829: PUSH
63830: LD_VAR 0 3
63834: ARRAY
63835: PUSH
63836: LD_INT 2
63838: ARRAY
63839: PPUSH
63840: LD_EXP 75
63844: PUSH
63845: LD_VAR 0 2
63849: ARRAY
63850: PUSH
63851: LD_VAR 0 3
63855: ARRAY
63856: PUSH
63857: LD_INT 3
63859: ARRAY
63860: PPUSH
63861: CALL_OW 284
63865: PUSH
63866: LD_INT 0
63868: EQUAL
63869: AND
63870: IFFALSE 63925
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63872: LD_ADDR_VAR 0 5
63876: PUSH
63877: LD_EXP 75
63881: PUSH
63882: LD_VAR 0 2
63886: ARRAY
63887: PPUSH
63888: LD_VAR 0 3
63892: PPUSH
63893: CALL_OW 3
63897: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
63898: LD_ADDR_EXP 75
63902: PUSH
63903: LD_EXP 75
63907: PPUSH
63908: LD_VAR 0 2
63912: PPUSH
63913: LD_VAR 0 5
63917: PPUSH
63918: CALL_OW 1
63922: ST_TO_ADDR
// continue ;
63923: GO 63769
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
63925: LD_EXP 59
63929: PUSH
63930: LD_VAR 0 2
63934: ARRAY
63935: PUSH
63936: LD_INT 1
63938: ARRAY
63939: PPUSH
63940: CALL_OW 255
63944: PPUSH
63945: LD_EXP 75
63949: PUSH
63950: LD_VAR 0 2
63954: ARRAY
63955: PUSH
63956: LD_VAR 0 3
63960: ARRAY
63961: PUSH
63962: LD_INT 2
63964: ARRAY
63965: PPUSH
63966: LD_EXP 75
63970: PUSH
63971: LD_VAR 0 2
63975: ARRAY
63976: PUSH
63977: LD_VAR 0 3
63981: ARRAY
63982: PUSH
63983: LD_INT 3
63985: ARRAY
63986: PPUSH
63987: LD_INT 30
63989: PPUSH
63990: CALL 20134 0 4
63994: PUSH
63995: LD_INT 4
63997: ARRAY
63998: PUSH
63999: LD_INT 0
64001: EQUAL
64002: IFFALSE 64028
// begin target := mc_crates [ i ] [ j ] ;
64004: LD_ADDR_VAR 0 6
64008: PUSH
64009: LD_EXP 75
64013: PUSH
64014: LD_VAR 0 2
64018: ARRAY
64019: PUSH
64020: LD_VAR 0 3
64024: ARRAY
64025: ST_TO_ADDR
// break ;
64026: GO 64030
// end ; end ;
64028: GO 63769
64030: POP
64031: POP
// if not target then
64032: LD_VAR 0 6
64036: NOT
64037: IFFALSE 64041
// continue ;
64039: GO 63650
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64041: LD_ADDR_VAR 0 7
64045: PUSH
64046: LD_EXP 78
64050: PUSH
64051: LD_VAR 0 2
64055: ARRAY
64056: PPUSH
64057: LD_INT 2
64059: PUSH
64060: LD_INT 3
64062: PUSH
64063: LD_INT 58
64065: PUSH
64066: EMPTY
64067: LIST
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 61
64075: PUSH
64076: EMPTY
64077: LIST
64078: PUSH
64079: LD_INT 33
64081: PUSH
64082: LD_INT 5
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 33
64091: PUSH
64092: LD_INT 3
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: LIST
64103: LIST
64104: LIST
64105: PUSH
64106: LD_INT 2
64108: PUSH
64109: LD_INT 34
64111: PUSH
64112: LD_INT 32
64114: PUSH
64115: EMPTY
64116: LIST
64117: LIST
64118: PUSH
64119: LD_INT 34
64121: PUSH
64122: LD_INT 51
64124: PUSH
64125: EMPTY
64126: LIST
64127: LIST
64128: PUSH
64129: LD_INT 34
64131: PUSH
64132: LD_INT 12
64134: PUSH
64135: EMPTY
64136: LIST
64137: LIST
64138: PUSH
64139: EMPTY
64140: LIST
64141: LIST
64142: LIST
64143: LIST
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PPUSH
64149: CALL_OW 72
64153: ST_TO_ADDR
// if not cargo then
64154: LD_VAR 0 7
64158: NOT
64159: IFFALSE 64802
// begin if mc_crates_collector [ i ] < 5 then
64161: LD_EXP 76
64165: PUSH
64166: LD_VAR 0 2
64170: ARRAY
64171: PUSH
64172: LD_INT 5
64174: LESS
64175: IFFALSE 64541
// begin if mc_ape [ i ] then
64177: LD_EXP 88
64181: PUSH
64182: LD_VAR 0 2
64186: ARRAY
64187: IFFALSE 64234
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64189: LD_ADDR_VAR 0 5
64193: PUSH
64194: LD_EXP 88
64198: PUSH
64199: LD_VAR 0 2
64203: ARRAY
64204: PPUSH
64205: LD_INT 25
64207: PUSH
64208: LD_INT 16
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: LD_INT 24
64217: PUSH
64218: LD_INT 750
64220: PUSH
64221: EMPTY
64222: LIST
64223: LIST
64224: PUSH
64225: EMPTY
64226: LIST
64227: LIST
64228: PPUSH
64229: CALL_OW 72
64233: ST_TO_ADDR
// if not tmp then
64234: LD_VAR 0 5
64238: NOT
64239: IFFALSE 64286
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64241: LD_ADDR_VAR 0 5
64245: PUSH
64246: LD_EXP 59
64250: PUSH
64251: LD_VAR 0 2
64255: ARRAY
64256: PPUSH
64257: LD_INT 25
64259: PUSH
64260: LD_INT 2
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 24
64269: PUSH
64270: LD_INT 750
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: EMPTY
64278: LIST
64279: LIST
64280: PPUSH
64281: CALL_OW 72
64285: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64286: LD_EXP 88
64290: PUSH
64291: LD_VAR 0 2
64295: ARRAY
64296: PUSH
64297: LD_EXP 59
64301: PUSH
64302: LD_VAR 0 2
64306: ARRAY
64307: PPUSH
64308: LD_INT 25
64310: PUSH
64311: LD_INT 2
64313: PUSH
64314: EMPTY
64315: LIST
64316: LIST
64317: PUSH
64318: LD_INT 24
64320: PUSH
64321: LD_INT 750
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PPUSH
64332: CALL_OW 72
64336: AND
64337: PUSH
64338: LD_VAR 0 5
64342: PUSH
64343: LD_INT 5
64345: LESS
64346: AND
64347: IFFALSE 64429
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64349: LD_ADDR_VAR 0 3
64353: PUSH
64354: LD_EXP 59
64358: PUSH
64359: LD_VAR 0 2
64363: ARRAY
64364: PPUSH
64365: LD_INT 25
64367: PUSH
64368: LD_INT 2
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 24
64377: PUSH
64378: LD_INT 750
64380: PUSH
64381: EMPTY
64382: LIST
64383: LIST
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PPUSH
64389: CALL_OW 72
64393: PUSH
64394: FOR_IN
64395: IFFALSE 64427
// begin tmp := tmp union j ;
64397: LD_ADDR_VAR 0 5
64401: PUSH
64402: LD_VAR 0 5
64406: PUSH
64407: LD_VAR 0 3
64411: UNION
64412: ST_TO_ADDR
// if tmp >= 5 then
64413: LD_VAR 0 5
64417: PUSH
64418: LD_INT 5
64420: GREATEREQUAL
64421: IFFALSE 64425
// break ;
64423: GO 64427
// end ;
64425: GO 64394
64427: POP
64428: POP
// end ; if not tmp then
64429: LD_VAR 0 5
64433: NOT
64434: IFFALSE 64438
// continue ;
64436: GO 63650
// for j in tmp do
64438: LD_ADDR_VAR 0 3
64442: PUSH
64443: LD_VAR 0 5
64447: PUSH
64448: FOR_IN
64449: IFFALSE 64539
// if not GetTag ( j ) then
64451: LD_VAR 0 3
64455: PPUSH
64456: CALL_OW 110
64460: NOT
64461: IFFALSE 64537
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64463: LD_ADDR_EXP 76
64467: PUSH
64468: LD_EXP 76
64472: PPUSH
64473: LD_VAR 0 2
64477: PUSH
64478: LD_EXP 76
64482: PUSH
64483: LD_VAR 0 2
64487: ARRAY
64488: PUSH
64489: LD_INT 1
64491: PLUS
64492: PUSH
64493: EMPTY
64494: LIST
64495: LIST
64496: PPUSH
64497: LD_VAR 0 3
64501: PPUSH
64502: CALL 19238 0 3
64506: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64507: LD_VAR 0 3
64511: PPUSH
64512: LD_INT 107
64514: PPUSH
64515: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64519: LD_EXP 76
64523: PUSH
64524: LD_VAR 0 2
64528: ARRAY
64529: PUSH
64530: LD_INT 5
64532: GREATEREQUAL
64533: IFFALSE 64537
// break ;
64535: GO 64539
// end ;
64537: GO 64448
64539: POP
64540: POP
// end ; if mc_crates_collector [ i ] and target then
64541: LD_EXP 76
64545: PUSH
64546: LD_VAR 0 2
64550: ARRAY
64551: PUSH
64552: LD_VAR 0 6
64556: AND
64557: IFFALSE 64800
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64559: LD_EXP 76
64563: PUSH
64564: LD_VAR 0 2
64568: ARRAY
64569: PUSH
64570: LD_VAR 0 6
64574: PUSH
64575: LD_INT 1
64577: ARRAY
64578: LESS
64579: IFFALSE 64599
// tmp := mc_crates_collector [ i ] else
64581: LD_ADDR_VAR 0 5
64585: PUSH
64586: LD_EXP 76
64590: PUSH
64591: LD_VAR 0 2
64595: ARRAY
64596: ST_TO_ADDR
64597: GO 64613
// tmp := target [ 1 ] ;
64599: LD_ADDR_VAR 0 5
64603: PUSH
64604: LD_VAR 0 6
64608: PUSH
64609: LD_INT 1
64611: ARRAY
64612: ST_TO_ADDR
// k := 0 ;
64613: LD_ADDR_VAR 0 4
64617: PUSH
64618: LD_INT 0
64620: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64621: LD_ADDR_VAR 0 3
64625: PUSH
64626: LD_EXP 76
64630: PUSH
64631: LD_VAR 0 2
64635: ARRAY
64636: PUSH
64637: FOR_IN
64638: IFFALSE 64798
// begin k := k + 1 ;
64640: LD_ADDR_VAR 0 4
64644: PUSH
64645: LD_VAR 0 4
64649: PUSH
64650: LD_INT 1
64652: PLUS
64653: ST_TO_ADDR
// if k > tmp then
64654: LD_VAR 0 4
64658: PUSH
64659: LD_VAR 0 5
64663: GREATER
64664: IFFALSE 64668
// break ;
64666: GO 64798
// if not GetClass ( j ) in [ 2 , 16 ] then
64668: LD_VAR 0 3
64672: PPUSH
64673: CALL_OW 257
64677: PUSH
64678: LD_INT 2
64680: PUSH
64681: LD_INT 16
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: IN
64688: NOT
64689: IFFALSE 64742
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64691: LD_ADDR_EXP 76
64695: PUSH
64696: LD_EXP 76
64700: PPUSH
64701: LD_VAR 0 2
64705: PPUSH
64706: LD_EXP 76
64710: PUSH
64711: LD_VAR 0 2
64715: ARRAY
64716: PUSH
64717: LD_VAR 0 3
64721: DIFF
64722: PPUSH
64723: CALL_OW 1
64727: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64728: LD_VAR 0 3
64732: PPUSH
64733: LD_INT 0
64735: PPUSH
64736: CALL_OW 109
// continue ;
64740: GO 64637
// end ; if IsInUnit ( j ) then
64742: LD_VAR 0 3
64746: PPUSH
64747: CALL_OW 310
64751: IFFALSE 64762
// ComExitBuilding ( j ) ;
64753: LD_VAR 0 3
64757: PPUSH
64758: CALL_OW 122
// wait ( 3 ) ;
64762: LD_INT 3
64764: PPUSH
64765: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64769: LD_VAR 0 3
64773: PPUSH
64774: LD_VAR 0 6
64778: PUSH
64779: LD_INT 2
64781: ARRAY
64782: PPUSH
64783: LD_VAR 0 6
64787: PUSH
64788: LD_INT 3
64790: ARRAY
64791: PPUSH
64792: CALL_OW 117
// end ;
64796: GO 64637
64798: POP
64799: POP
// end ; end else
64800: GO 65381
// begin for j in cargo do
64802: LD_ADDR_VAR 0 3
64806: PUSH
64807: LD_VAR 0 7
64811: PUSH
64812: FOR_IN
64813: IFFALSE 65379
// begin if GetTag ( j ) <> 0 then
64815: LD_VAR 0 3
64819: PPUSH
64820: CALL_OW 110
64824: PUSH
64825: LD_INT 0
64827: NONEQUAL
64828: IFFALSE 64832
// continue ;
64830: GO 64812
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64832: LD_VAR 0 3
64836: PPUSH
64837: CALL_OW 256
64841: PUSH
64842: LD_INT 1000
64844: LESS
64845: PUSH
64846: LD_VAR 0 3
64850: PPUSH
64851: LD_EXP 83
64855: PUSH
64856: LD_VAR 0 2
64860: ARRAY
64861: PPUSH
64862: CALL_OW 308
64866: NOT
64867: AND
64868: IFFALSE 64890
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64870: LD_VAR 0 3
64874: PPUSH
64875: LD_EXP 83
64879: PUSH
64880: LD_VAR 0 2
64884: ARRAY
64885: PPUSH
64886: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
64890: LD_VAR 0 3
64894: PPUSH
64895: CALL_OW 256
64899: PUSH
64900: LD_INT 1000
64902: LESS
64903: PUSH
64904: LD_VAR 0 3
64908: PPUSH
64909: LD_EXP 83
64913: PUSH
64914: LD_VAR 0 2
64918: ARRAY
64919: PPUSH
64920: CALL_OW 308
64924: AND
64925: IFFALSE 64929
// continue ;
64927: GO 64812
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
64929: LD_VAR 0 3
64933: PPUSH
64934: CALL_OW 262
64938: PUSH
64939: LD_INT 2
64941: EQUAL
64942: PUSH
64943: LD_VAR 0 3
64947: PPUSH
64948: CALL_OW 261
64952: PUSH
64953: LD_INT 15
64955: LESS
64956: AND
64957: IFFALSE 64961
// continue ;
64959: GO 64812
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
64961: LD_VAR 0 3
64965: PPUSH
64966: CALL_OW 262
64970: PUSH
64971: LD_INT 1
64973: EQUAL
64974: PUSH
64975: LD_VAR 0 3
64979: PPUSH
64980: CALL_OW 261
64984: PUSH
64985: LD_INT 10
64987: LESS
64988: AND
64989: IFFALSE 65318
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64991: LD_ADDR_VAR 0 8
64995: PUSH
64996: LD_EXP 59
65000: PUSH
65001: LD_VAR 0 2
65005: ARRAY
65006: PPUSH
65007: LD_INT 2
65009: PUSH
65010: LD_INT 30
65012: PUSH
65013: LD_INT 0
65015: PUSH
65016: EMPTY
65017: LIST
65018: LIST
65019: PUSH
65020: LD_INT 30
65022: PUSH
65023: LD_INT 1
65025: PUSH
65026: EMPTY
65027: LIST
65028: LIST
65029: PUSH
65030: EMPTY
65031: LIST
65032: LIST
65033: LIST
65034: PPUSH
65035: CALL_OW 72
65039: ST_TO_ADDR
// if not depot then
65040: LD_VAR 0 8
65044: NOT
65045: IFFALSE 65049
// continue ;
65047: GO 64812
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65049: LD_VAR 0 3
65053: PPUSH
65054: LD_VAR 0 8
65058: PPUSH
65059: LD_VAR 0 3
65063: PPUSH
65064: CALL_OW 74
65068: PPUSH
65069: CALL_OW 296
65073: PUSH
65074: LD_INT 6
65076: LESS
65077: IFFALSE 65093
// SetFuel ( j , 100 ) else
65079: LD_VAR 0 3
65083: PPUSH
65084: LD_INT 100
65086: PPUSH
65087: CALL_OW 240
65091: GO 65318
// if GetFuel ( j ) = 0 then
65093: LD_VAR 0 3
65097: PPUSH
65098: CALL_OW 261
65102: PUSH
65103: LD_INT 0
65105: EQUAL
65106: IFFALSE 65318
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65108: LD_ADDR_EXP 78
65112: PUSH
65113: LD_EXP 78
65117: PPUSH
65118: LD_VAR 0 2
65122: PPUSH
65123: LD_EXP 78
65127: PUSH
65128: LD_VAR 0 2
65132: ARRAY
65133: PUSH
65134: LD_VAR 0 3
65138: DIFF
65139: PPUSH
65140: CALL_OW 1
65144: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65145: LD_VAR 0 3
65149: PPUSH
65150: CALL_OW 263
65154: PUSH
65155: LD_INT 1
65157: EQUAL
65158: IFFALSE 65174
// ComExitVehicle ( IsInUnit ( j ) ) ;
65160: LD_VAR 0 3
65164: PPUSH
65165: CALL_OW 310
65169: PPUSH
65170: CALL_OW 121
// if GetControl ( j ) = control_remote then
65174: LD_VAR 0 3
65178: PPUSH
65179: CALL_OW 263
65183: PUSH
65184: LD_INT 2
65186: EQUAL
65187: IFFALSE 65198
// ComUnlink ( j ) ;
65189: LD_VAR 0 3
65193: PPUSH
65194: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65198: LD_ADDR_VAR 0 9
65202: PUSH
65203: LD_VAR 0 2
65207: PPUSH
65208: LD_INT 3
65210: PPUSH
65211: CALL 74671 0 2
65215: ST_TO_ADDR
// if fac then
65216: LD_VAR 0 9
65220: IFFALSE 65316
// begin for k in fac do
65222: LD_ADDR_VAR 0 4
65226: PUSH
65227: LD_VAR 0 9
65231: PUSH
65232: FOR_IN
65233: IFFALSE 65314
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65235: LD_ADDR_VAR 0 10
65239: PUSH
65240: LD_VAR 0 9
65244: PPUSH
65245: LD_VAR 0 3
65249: PPUSH
65250: CALL_OW 265
65254: PPUSH
65255: LD_VAR 0 3
65259: PPUSH
65260: CALL_OW 262
65264: PPUSH
65265: LD_VAR 0 3
65269: PPUSH
65270: CALL_OW 263
65274: PPUSH
65275: LD_VAR 0 3
65279: PPUSH
65280: CALL_OW 264
65284: PPUSH
65285: CALL 16770 0 5
65289: ST_TO_ADDR
// if components then
65290: LD_VAR 0 10
65294: IFFALSE 65312
// begin MC_InsertProduceList ( i , components ) ;
65296: LD_VAR 0 2
65300: PPUSH
65301: LD_VAR 0 10
65305: PPUSH
65306: CALL 74216 0 2
// break ;
65310: GO 65314
// end ; end ;
65312: GO 65232
65314: POP
65315: POP
// end ; continue ;
65316: GO 64812
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65318: LD_VAR 0 3
65322: PPUSH
65323: LD_INT 1
65325: PPUSH
65326: CALL_OW 289
65330: PUSH
65331: LD_INT 100
65333: LESS
65334: PUSH
65335: LD_VAR 0 3
65339: PPUSH
65340: CALL_OW 314
65344: NOT
65345: AND
65346: IFFALSE 65375
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65348: LD_VAR 0 3
65352: PPUSH
65353: LD_VAR 0 6
65357: PUSH
65358: LD_INT 2
65360: ARRAY
65361: PPUSH
65362: LD_VAR 0 6
65366: PUSH
65367: LD_INT 3
65369: ARRAY
65370: PPUSH
65371: CALL_OW 117
// break ;
65375: GO 65379
// end ;
65377: GO 64812
65379: POP
65380: POP
// end ; end ;
65381: GO 63650
65383: POP
65384: POP
// end ;
65385: LD_VAR 0 1
65389: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65390: LD_INT 0
65392: PPUSH
65393: PPUSH
65394: PPUSH
65395: PPUSH
// if not mc_bases then
65396: LD_EXP 59
65400: NOT
65401: IFFALSE 65405
// exit ;
65403: GO 65566
// for i = 1 to mc_bases do
65405: LD_ADDR_VAR 0 2
65409: PUSH
65410: DOUBLE
65411: LD_INT 1
65413: DEC
65414: ST_TO_ADDR
65415: LD_EXP 59
65419: PUSH
65420: FOR_TO
65421: IFFALSE 65564
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65423: LD_ADDR_VAR 0 4
65427: PUSH
65428: LD_EXP 78
65432: PUSH
65433: LD_VAR 0 2
65437: ARRAY
65438: PUSH
65439: LD_EXP 81
65443: PUSH
65444: LD_VAR 0 2
65448: ARRAY
65449: UNION
65450: PPUSH
65451: LD_INT 33
65453: PUSH
65454: LD_INT 2
65456: PUSH
65457: EMPTY
65458: LIST
65459: LIST
65460: PPUSH
65461: CALL_OW 72
65465: ST_TO_ADDR
// if tmp then
65466: LD_VAR 0 4
65470: IFFALSE 65562
// for j in tmp do
65472: LD_ADDR_VAR 0 3
65476: PUSH
65477: LD_VAR 0 4
65481: PUSH
65482: FOR_IN
65483: IFFALSE 65560
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65485: LD_VAR 0 3
65489: PPUSH
65490: CALL_OW 312
65494: NOT
65495: PUSH
65496: LD_VAR 0 3
65500: PPUSH
65501: CALL_OW 256
65505: PUSH
65506: LD_INT 250
65508: GREATEREQUAL
65509: AND
65510: IFFALSE 65523
// Connect ( j ) else
65512: LD_VAR 0 3
65516: PPUSH
65517: CALL 22171 0 1
65521: GO 65558
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65523: LD_VAR 0 3
65527: PPUSH
65528: CALL_OW 256
65532: PUSH
65533: LD_INT 250
65535: LESS
65536: PUSH
65537: LD_VAR 0 3
65541: PPUSH
65542: CALL_OW 312
65546: AND
65547: IFFALSE 65558
// ComUnlink ( j ) ;
65549: LD_VAR 0 3
65553: PPUSH
65554: CALL_OW 136
65558: GO 65482
65560: POP
65561: POP
// end ;
65562: GO 65420
65564: POP
65565: POP
// end ;
65566: LD_VAR 0 1
65570: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65571: LD_INT 0
65573: PPUSH
65574: PPUSH
65575: PPUSH
65576: PPUSH
65577: PPUSH
// if not mc_bases then
65578: LD_EXP 59
65582: NOT
65583: IFFALSE 65587
// exit ;
65585: GO 66032
// for i = 1 to mc_bases do
65587: LD_ADDR_VAR 0 2
65591: PUSH
65592: DOUBLE
65593: LD_INT 1
65595: DEC
65596: ST_TO_ADDR
65597: LD_EXP 59
65601: PUSH
65602: FOR_TO
65603: IFFALSE 66030
// begin if not mc_produce [ i ] then
65605: LD_EXP 80
65609: PUSH
65610: LD_VAR 0 2
65614: ARRAY
65615: NOT
65616: IFFALSE 65620
// continue ;
65618: GO 65602
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65620: LD_ADDR_VAR 0 5
65624: PUSH
65625: LD_EXP 59
65629: PUSH
65630: LD_VAR 0 2
65634: ARRAY
65635: PPUSH
65636: LD_INT 30
65638: PUSH
65639: LD_INT 3
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PPUSH
65646: CALL_OW 72
65650: ST_TO_ADDR
// if not fac then
65651: LD_VAR 0 5
65655: NOT
65656: IFFALSE 65660
// continue ;
65658: GO 65602
// for j in fac do
65660: LD_ADDR_VAR 0 3
65664: PUSH
65665: LD_VAR 0 5
65669: PUSH
65670: FOR_IN
65671: IFFALSE 66026
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65673: LD_VAR 0 3
65677: PPUSH
65678: CALL_OW 461
65682: PUSH
65683: LD_INT 2
65685: NONEQUAL
65686: PUSH
65687: LD_VAR 0 3
65691: PPUSH
65692: LD_INT 15
65694: PPUSH
65695: CALL 21831 0 2
65699: PUSH
65700: LD_INT 4
65702: ARRAY
65703: OR
65704: IFFALSE 65708
// continue ;
65706: GO 65670
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65708: LD_VAR 0 3
65712: PPUSH
65713: LD_EXP 80
65717: PUSH
65718: LD_VAR 0 2
65722: ARRAY
65723: PUSH
65724: LD_INT 1
65726: ARRAY
65727: PUSH
65728: LD_INT 1
65730: ARRAY
65731: PPUSH
65732: LD_EXP 80
65736: PUSH
65737: LD_VAR 0 2
65741: ARRAY
65742: PUSH
65743: LD_INT 1
65745: ARRAY
65746: PUSH
65747: LD_INT 2
65749: ARRAY
65750: PPUSH
65751: LD_EXP 80
65755: PUSH
65756: LD_VAR 0 2
65760: ARRAY
65761: PUSH
65762: LD_INT 1
65764: ARRAY
65765: PUSH
65766: LD_INT 3
65768: ARRAY
65769: PPUSH
65770: LD_EXP 80
65774: PUSH
65775: LD_VAR 0 2
65779: ARRAY
65780: PUSH
65781: LD_INT 1
65783: ARRAY
65784: PUSH
65785: LD_INT 4
65787: ARRAY
65788: PPUSH
65789: CALL_OW 448
65793: PUSH
65794: LD_VAR 0 3
65798: PPUSH
65799: LD_EXP 80
65803: PUSH
65804: LD_VAR 0 2
65808: ARRAY
65809: PUSH
65810: LD_INT 1
65812: ARRAY
65813: PUSH
65814: LD_INT 1
65816: ARRAY
65817: PUSH
65818: LD_EXP 80
65822: PUSH
65823: LD_VAR 0 2
65827: ARRAY
65828: PUSH
65829: LD_INT 1
65831: ARRAY
65832: PUSH
65833: LD_INT 2
65835: ARRAY
65836: PUSH
65837: LD_EXP 80
65841: PUSH
65842: LD_VAR 0 2
65846: ARRAY
65847: PUSH
65848: LD_INT 1
65850: ARRAY
65851: PUSH
65852: LD_INT 3
65854: ARRAY
65855: PUSH
65856: LD_EXP 80
65860: PUSH
65861: LD_VAR 0 2
65865: ARRAY
65866: PUSH
65867: LD_INT 1
65869: ARRAY
65870: PUSH
65871: LD_INT 4
65873: ARRAY
65874: PUSH
65875: EMPTY
65876: LIST
65877: LIST
65878: LIST
65879: LIST
65880: PPUSH
65881: CALL 25502 0 2
65885: AND
65886: IFFALSE 66024
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
65888: LD_VAR 0 3
65892: PPUSH
65893: LD_EXP 80
65897: PUSH
65898: LD_VAR 0 2
65902: ARRAY
65903: PUSH
65904: LD_INT 1
65906: ARRAY
65907: PUSH
65908: LD_INT 1
65910: ARRAY
65911: PPUSH
65912: LD_EXP 80
65916: PUSH
65917: LD_VAR 0 2
65921: ARRAY
65922: PUSH
65923: LD_INT 1
65925: ARRAY
65926: PUSH
65927: LD_INT 2
65929: ARRAY
65930: PPUSH
65931: LD_EXP 80
65935: PUSH
65936: LD_VAR 0 2
65940: ARRAY
65941: PUSH
65942: LD_INT 1
65944: ARRAY
65945: PUSH
65946: LD_INT 3
65948: ARRAY
65949: PPUSH
65950: LD_EXP 80
65954: PUSH
65955: LD_VAR 0 2
65959: ARRAY
65960: PUSH
65961: LD_INT 1
65963: ARRAY
65964: PUSH
65965: LD_INT 4
65967: ARRAY
65968: PPUSH
65969: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
65973: LD_ADDR_VAR 0 4
65977: PUSH
65978: LD_EXP 80
65982: PUSH
65983: LD_VAR 0 2
65987: ARRAY
65988: PPUSH
65989: LD_INT 1
65991: PPUSH
65992: CALL_OW 3
65996: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
65997: LD_ADDR_EXP 80
66001: PUSH
66002: LD_EXP 80
66006: PPUSH
66007: LD_VAR 0 2
66011: PPUSH
66012: LD_VAR 0 4
66016: PPUSH
66017: CALL_OW 1
66021: ST_TO_ADDR
// break ;
66022: GO 66026
// end ; end ;
66024: GO 65670
66026: POP
66027: POP
// end ;
66028: GO 65602
66030: POP
66031: POP
// end ;
66032: LD_VAR 0 1
66036: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66037: LD_INT 0
66039: PPUSH
66040: PPUSH
66041: PPUSH
// if not mc_bases then
66042: LD_EXP 59
66046: NOT
66047: IFFALSE 66051
// exit ;
66049: GO 66140
// for i = 1 to mc_bases do
66051: LD_ADDR_VAR 0 2
66055: PUSH
66056: DOUBLE
66057: LD_INT 1
66059: DEC
66060: ST_TO_ADDR
66061: LD_EXP 59
66065: PUSH
66066: FOR_TO
66067: IFFALSE 66138
// begin if mc_attack [ i ] then
66069: LD_EXP 79
66073: PUSH
66074: LD_VAR 0 2
66078: ARRAY
66079: IFFALSE 66136
// begin tmp := mc_attack [ i ] [ 1 ] ;
66081: LD_ADDR_VAR 0 3
66085: PUSH
66086: LD_EXP 79
66090: PUSH
66091: LD_VAR 0 2
66095: ARRAY
66096: PUSH
66097: LD_INT 1
66099: ARRAY
66100: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66101: LD_ADDR_EXP 79
66105: PUSH
66106: LD_EXP 79
66110: PPUSH
66111: LD_VAR 0 2
66115: PPUSH
66116: EMPTY
66117: PPUSH
66118: CALL_OW 1
66122: ST_TO_ADDR
// Attack ( tmp ) ;
66123: LD_VAR 0 3
66127: PPUSH
66128: CALL 92265 0 1
// exit ;
66132: POP
66133: POP
66134: GO 66140
// end ; end ;
66136: GO 66066
66138: POP
66139: POP
// end ;
66140: LD_VAR 0 1
66144: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66145: LD_INT 0
66147: PPUSH
66148: PPUSH
66149: PPUSH
66150: PPUSH
66151: PPUSH
66152: PPUSH
66153: PPUSH
// if not mc_bases then
66154: LD_EXP 59
66158: NOT
66159: IFFALSE 66163
// exit ;
66161: GO 66745
// for i = 1 to mc_bases do
66163: LD_ADDR_VAR 0 2
66167: PUSH
66168: DOUBLE
66169: LD_INT 1
66171: DEC
66172: ST_TO_ADDR
66173: LD_EXP 59
66177: PUSH
66178: FOR_TO
66179: IFFALSE 66743
// begin if not mc_bases [ i ] then
66181: LD_EXP 59
66185: PUSH
66186: LD_VAR 0 2
66190: ARRAY
66191: NOT
66192: IFFALSE 66196
// continue ;
66194: GO 66178
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66196: LD_ADDR_VAR 0 7
66200: PUSH
66201: LD_EXP 59
66205: PUSH
66206: LD_VAR 0 2
66210: ARRAY
66211: PUSH
66212: LD_INT 1
66214: ARRAY
66215: PPUSH
66216: CALL 16074 0 1
66220: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66221: LD_ADDR_EXP 82
66225: PUSH
66226: LD_EXP 82
66230: PPUSH
66231: LD_VAR 0 2
66235: PPUSH
66236: LD_EXP 59
66240: PUSH
66241: LD_VAR 0 2
66245: ARRAY
66246: PUSH
66247: LD_INT 1
66249: ARRAY
66250: PPUSH
66251: CALL_OW 255
66255: PPUSH
66256: LD_EXP 84
66260: PUSH
66261: LD_VAR 0 2
66265: ARRAY
66266: PPUSH
66267: CALL 16039 0 2
66271: PPUSH
66272: CALL_OW 1
66276: ST_TO_ADDR
// if not mc_scan [ i ] then
66277: LD_EXP 82
66281: PUSH
66282: LD_VAR 0 2
66286: ARRAY
66287: NOT
66288: IFFALSE 66443
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66290: LD_ADDR_VAR 0 4
66294: PUSH
66295: LD_EXP 59
66299: PUSH
66300: LD_VAR 0 2
66304: ARRAY
66305: PPUSH
66306: LD_INT 2
66308: PUSH
66309: LD_INT 25
66311: PUSH
66312: LD_INT 5
66314: PUSH
66315: EMPTY
66316: LIST
66317: LIST
66318: PUSH
66319: LD_INT 25
66321: PUSH
66322: LD_INT 8
66324: PUSH
66325: EMPTY
66326: LIST
66327: LIST
66328: PUSH
66329: LD_INT 25
66331: PUSH
66332: LD_INT 9
66334: PUSH
66335: EMPTY
66336: LIST
66337: LIST
66338: PUSH
66339: EMPTY
66340: LIST
66341: LIST
66342: LIST
66343: LIST
66344: PPUSH
66345: CALL_OW 72
66349: ST_TO_ADDR
// if not tmp then
66350: LD_VAR 0 4
66354: NOT
66355: IFFALSE 66359
// continue ;
66357: GO 66178
// for j in tmp do
66359: LD_ADDR_VAR 0 3
66363: PUSH
66364: LD_VAR 0 4
66368: PUSH
66369: FOR_IN
66370: IFFALSE 66441
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66372: LD_VAR 0 3
66376: PPUSH
66377: CALL_OW 310
66381: PPUSH
66382: CALL_OW 266
66386: PUSH
66387: LD_INT 5
66389: EQUAL
66390: PUSH
66391: LD_VAR 0 3
66395: PPUSH
66396: CALL_OW 257
66400: PUSH
66401: LD_INT 1
66403: EQUAL
66404: AND
66405: PUSH
66406: LD_VAR 0 3
66410: PPUSH
66411: CALL_OW 459
66415: NOT
66416: AND
66417: PUSH
66418: LD_VAR 0 7
66422: AND
66423: IFFALSE 66439
// ComChangeProfession ( j , class ) ;
66425: LD_VAR 0 3
66429: PPUSH
66430: LD_VAR 0 7
66434: PPUSH
66435: CALL_OW 123
66439: GO 66369
66441: POP
66442: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66443: LD_EXP 82
66447: PUSH
66448: LD_VAR 0 2
66452: ARRAY
66453: PUSH
66454: LD_EXP 81
66458: PUSH
66459: LD_VAR 0 2
66463: ARRAY
66464: NOT
66465: AND
66466: PUSH
66467: LD_EXP 59
66471: PUSH
66472: LD_VAR 0 2
66476: ARRAY
66477: PPUSH
66478: LD_INT 30
66480: PUSH
66481: LD_INT 32
66483: PUSH
66484: EMPTY
66485: LIST
66486: LIST
66487: PPUSH
66488: CALL_OW 72
66492: NOT
66493: AND
66494: PUSH
66495: LD_EXP 59
66499: PUSH
66500: LD_VAR 0 2
66504: ARRAY
66505: PPUSH
66506: LD_INT 2
66508: PUSH
66509: LD_INT 30
66511: PUSH
66512: LD_INT 4
66514: PUSH
66515: EMPTY
66516: LIST
66517: LIST
66518: PUSH
66519: LD_INT 30
66521: PUSH
66522: LD_INT 5
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: PUSH
66529: EMPTY
66530: LIST
66531: LIST
66532: LIST
66533: PPUSH
66534: CALL_OW 72
66538: NOT
66539: AND
66540: IFFALSE 66672
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66542: LD_ADDR_VAR 0 4
66546: PUSH
66547: LD_EXP 59
66551: PUSH
66552: LD_VAR 0 2
66556: ARRAY
66557: PPUSH
66558: LD_INT 2
66560: PUSH
66561: LD_INT 25
66563: PUSH
66564: LD_INT 1
66566: PUSH
66567: EMPTY
66568: LIST
66569: LIST
66570: PUSH
66571: LD_INT 25
66573: PUSH
66574: LD_INT 5
66576: PUSH
66577: EMPTY
66578: LIST
66579: LIST
66580: PUSH
66581: LD_INT 25
66583: PUSH
66584: LD_INT 8
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 25
66593: PUSH
66594: LD_INT 9
66596: PUSH
66597: EMPTY
66598: LIST
66599: LIST
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: LIST
66605: LIST
66606: LIST
66607: PPUSH
66608: CALL_OW 72
66612: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66613: LD_ADDR_VAR 0 4
66617: PUSH
66618: LD_VAR 0 4
66622: PUSH
66623: LD_VAR 0 4
66627: PPUSH
66628: LD_INT 18
66630: PPUSH
66631: CALL 47799 0 2
66635: DIFF
66636: ST_TO_ADDR
// if tmp then
66637: LD_VAR 0 4
66641: IFFALSE 66672
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66643: LD_VAR 0 2
66647: PPUSH
66648: LD_VAR 0 4
66652: PPUSH
66653: LD_EXP 84
66657: PUSH
66658: LD_VAR 0 2
66662: ARRAY
66663: PPUSH
66664: CALL 96974 0 3
// exit ;
66668: POP
66669: POP
66670: GO 66745
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66672: LD_EXP 82
66676: PUSH
66677: LD_VAR 0 2
66681: ARRAY
66682: PUSH
66683: LD_EXP 81
66687: PUSH
66688: LD_VAR 0 2
66692: ARRAY
66693: AND
66694: IFFALSE 66741
// begin tmp := mc_defender [ i ] ;
66696: LD_ADDR_VAR 0 4
66700: PUSH
66701: LD_EXP 81
66705: PUSH
66706: LD_VAR 0 2
66710: ARRAY
66711: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
66712: LD_VAR 0 2
66716: PPUSH
66717: LD_VAR 0 4
66721: PPUSH
66722: LD_EXP 82
66726: PUSH
66727: LD_VAR 0 2
66731: ARRAY
66732: PPUSH
66733: CALL 97535 0 3
// exit ;
66737: POP
66738: POP
66739: GO 66745
// end ; end ;
66741: GO 66178
66743: POP
66744: POP
// end ;
66745: LD_VAR 0 1
66749: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66750: LD_INT 0
66752: PPUSH
66753: PPUSH
66754: PPUSH
66755: PPUSH
66756: PPUSH
66757: PPUSH
66758: PPUSH
66759: PPUSH
66760: PPUSH
66761: PPUSH
66762: PPUSH
// if not mc_bases then
66763: LD_EXP 59
66767: NOT
66768: IFFALSE 66772
// exit ;
66770: GO 67859
// for i = 1 to mc_bases do
66772: LD_ADDR_VAR 0 2
66776: PUSH
66777: DOUBLE
66778: LD_INT 1
66780: DEC
66781: ST_TO_ADDR
66782: LD_EXP 59
66786: PUSH
66787: FOR_TO
66788: IFFALSE 67857
// begin tmp := mc_lab [ i ] ;
66790: LD_ADDR_VAR 0 6
66794: PUSH
66795: LD_EXP 92
66799: PUSH
66800: LD_VAR 0 2
66804: ARRAY
66805: ST_TO_ADDR
// if not tmp then
66806: LD_VAR 0 6
66810: NOT
66811: IFFALSE 66815
// continue ;
66813: GO 66787
// idle_lab := 0 ;
66815: LD_ADDR_VAR 0 11
66819: PUSH
66820: LD_INT 0
66822: ST_TO_ADDR
// for j in tmp do
66823: LD_ADDR_VAR 0 3
66827: PUSH
66828: LD_VAR 0 6
66832: PUSH
66833: FOR_IN
66834: IFFALSE 67853
// begin researching := false ;
66836: LD_ADDR_VAR 0 10
66840: PUSH
66841: LD_INT 0
66843: ST_TO_ADDR
// side := GetSide ( j ) ;
66844: LD_ADDR_VAR 0 4
66848: PUSH
66849: LD_VAR 0 3
66853: PPUSH
66854: CALL_OW 255
66858: ST_TO_ADDR
// if not mc_tech [ side ] then
66859: LD_EXP 86
66863: PUSH
66864: LD_VAR 0 4
66868: ARRAY
66869: NOT
66870: IFFALSE 66874
// continue ;
66872: GO 66833
// if BuildingStatus ( j ) = bs_idle then
66874: LD_VAR 0 3
66878: PPUSH
66879: CALL_OW 461
66883: PUSH
66884: LD_INT 2
66886: EQUAL
66887: IFFALSE 67075
// begin if idle_lab and UnitsInside ( j ) < 6 then
66889: LD_VAR 0 11
66893: PUSH
66894: LD_VAR 0 3
66898: PPUSH
66899: CALL_OW 313
66903: PUSH
66904: LD_INT 6
66906: LESS
66907: AND
66908: IFFALSE 66979
// begin tmp2 := UnitsInside ( idle_lab ) ;
66910: LD_ADDR_VAR 0 9
66914: PUSH
66915: LD_VAR 0 11
66919: PPUSH
66920: CALL_OW 313
66924: ST_TO_ADDR
// if tmp2 then
66925: LD_VAR 0 9
66929: IFFALSE 66971
// for x in tmp2 do
66931: LD_ADDR_VAR 0 7
66935: PUSH
66936: LD_VAR 0 9
66940: PUSH
66941: FOR_IN
66942: IFFALSE 66969
// begin ComExitBuilding ( x ) ;
66944: LD_VAR 0 7
66948: PPUSH
66949: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
66953: LD_VAR 0 7
66957: PPUSH
66958: LD_VAR 0 3
66962: PPUSH
66963: CALL_OW 180
// end ;
66967: GO 66941
66969: POP
66970: POP
// idle_lab := 0 ;
66971: LD_ADDR_VAR 0 11
66975: PUSH
66976: LD_INT 0
66978: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
66979: LD_ADDR_VAR 0 5
66983: PUSH
66984: LD_EXP 86
66988: PUSH
66989: LD_VAR 0 4
66993: ARRAY
66994: PUSH
66995: FOR_IN
66996: IFFALSE 67056
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
66998: LD_VAR 0 3
67002: PPUSH
67003: LD_VAR 0 5
67007: PPUSH
67008: CALL_OW 430
67012: PUSH
67013: LD_VAR 0 4
67017: PPUSH
67018: LD_VAR 0 5
67022: PPUSH
67023: CALL 15144 0 2
67027: AND
67028: IFFALSE 67054
// begin researching := true ;
67030: LD_ADDR_VAR 0 10
67034: PUSH
67035: LD_INT 1
67037: ST_TO_ADDR
// ComResearch ( j , t ) ;
67038: LD_VAR 0 3
67042: PPUSH
67043: LD_VAR 0 5
67047: PPUSH
67048: CALL_OW 124
// break ;
67052: GO 67056
// end ;
67054: GO 66995
67056: POP
67057: POP
// if not researching then
67058: LD_VAR 0 10
67062: NOT
67063: IFFALSE 67075
// idle_lab := j ;
67065: LD_ADDR_VAR 0 11
67069: PUSH
67070: LD_VAR 0 3
67074: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67075: LD_VAR 0 3
67079: PPUSH
67080: CALL_OW 461
67084: PUSH
67085: LD_INT 10
67087: EQUAL
67088: IFFALSE 67676
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67090: LD_EXP 88
67094: PUSH
67095: LD_VAR 0 2
67099: ARRAY
67100: NOT
67101: PUSH
67102: LD_EXP 89
67106: PUSH
67107: LD_VAR 0 2
67111: ARRAY
67112: NOT
67113: AND
67114: PUSH
67115: LD_EXP 86
67119: PUSH
67120: LD_VAR 0 4
67124: ARRAY
67125: PUSH
67126: LD_INT 1
67128: GREATER
67129: AND
67130: IFFALSE 67261
// begin ComCancel ( j ) ;
67132: LD_VAR 0 3
67136: PPUSH
67137: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67141: LD_ADDR_EXP 86
67145: PUSH
67146: LD_EXP 86
67150: PPUSH
67151: LD_VAR 0 4
67155: PPUSH
67156: LD_EXP 86
67160: PUSH
67161: LD_VAR 0 4
67165: ARRAY
67166: PPUSH
67167: LD_EXP 86
67171: PUSH
67172: LD_VAR 0 4
67176: ARRAY
67177: PUSH
67178: LD_INT 1
67180: MINUS
67181: PPUSH
67182: LD_EXP 86
67186: PUSH
67187: LD_VAR 0 4
67191: ARRAY
67192: PPUSH
67193: LD_INT 0
67195: PPUSH
67196: CALL 18656 0 4
67200: PPUSH
67201: CALL_OW 1
67205: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67206: LD_ADDR_EXP 86
67210: PUSH
67211: LD_EXP 86
67215: PPUSH
67216: LD_VAR 0 4
67220: PPUSH
67221: LD_EXP 86
67225: PUSH
67226: LD_VAR 0 4
67230: ARRAY
67231: PPUSH
67232: LD_EXP 86
67236: PUSH
67237: LD_VAR 0 4
67241: ARRAY
67242: PPUSH
67243: LD_INT 1
67245: PPUSH
67246: LD_INT 0
67248: PPUSH
67249: CALL 18656 0 4
67253: PPUSH
67254: CALL_OW 1
67258: ST_TO_ADDR
// continue ;
67259: GO 66833
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67261: LD_EXP 88
67265: PUSH
67266: LD_VAR 0 2
67270: ARRAY
67271: PUSH
67272: LD_EXP 89
67276: PUSH
67277: LD_VAR 0 2
67281: ARRAY
67282: NOT
67283: AND
67284: IFFALSE 67411
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67286: LD_ADDR_EXP 89
67290: PUSH
67291: LD_EXP 89
67295: PPUSH
67296: LD_VAR 0 2
67300: PUSH
67301: LD_EXP 89
67305: PUSH
67306: LD_VAR 0 2
67310: ARRAY
67311: PUSH
67312: LD_INT 1
67314: PLUS
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PPUSH
67320: LD_EXP 88
67324: PUSH
67325: LD_VAR 0 2
67329: ARRAY
67330: PUSH
67331: LD_INT 1
67333: ARRAY
67334: PPUSH
67335: CALL 19238 0 3
67339: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67340: LD_EXP 88
67344: PUSH
67345: LD_VAR 0 2
67349: ARRAY
67350: PUSH
67351: LD_INT 1
67353: ARRAY
67354: PPUSH
67355: LD_INT 112
67357: PPUSH
67358: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67362: LD_ADDR_VAR 0 9
67366: PUSH
67367: LD_EXP 88
67371: PUSH
67372: LD_VAR 0 2
67376: ARRAY
67377: PPUSH
67378: LD_INT 1
67380: PPUSH
67381: CALL_OW 3
67385: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67386: LD_ADDR_EXP 88
67390: PUSH
67391: LD_EXP 88
67395: PPUSH
67396: LD_VAR 0 2
67400: PPUSH
67401: LD_VAR 0 9
67405: PPUSH
67406: CALL_OW 1
67410: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67411: LD_EXP 88
67415: PUSH
67416: LD_VAR 0 2
67420: ARRAY
67421: PUSH
67422: LD_EXP 89
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: AND
67433: PUSH
67434: LD_EXP 89
67438: PUSH
67439: LD_VAR 0 2
67443: ARRAY
67444: PUSH
67445: LD_INT 1
67447: ARRAY
67448: PPUSH
67449: CALL_OW 310
67453: NOT
67454: AND
67455: PUSH
67456: LD_VAR 0 3
67460: PPUSH
67461: CALL_OW 313
67465: PUSH
67466: LD_INT 6
67468: EQUAL
67469: AND
67470: IFFALSE 67526
// begin tmp2 := UnitsInside ( j ) ;
67472: LD_ADDR_VAR 0 9
67476: PUSH
67477: LD_VAR 0 3
67481: PPUSH
67482: CALL_OW 313
67486: ST_TO_ADDR
// if tmp2 = 6 then
67487: LD_VAR 0 9
67491: PUSH
67492: LD_INT 6
67494: EQUAL
67495: IFFALSE 67526
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67497: LD_VAR 0 9
67501: PUSH
67502: LD_INT 1
67504: ARRAY
67505: PPUSH
67506: LD_INT 112
67508: PPUSH
67509: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67513: LD_VAR 0 9
67517: PUSH
67518: LD_INT 1
67520: ARRAY
67521: PPUSH
67522: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67526: LD_EXP 89
67530: PUSH
67531: LD_VAR 0 2
67535: ARRAY
67536: PUSH
67537: LD_EXP 89
67541: PUSH
67542: LD_VAR 0 2
67546: ARRAY
67547: PUSH
67548: LD_INT 1
67550: ARRAY
67551: PPUSH
67552: CALL_OW 314
67556: NOT
67557: AND
67558: PUSH
67559: LD_EXP 89
67563: PUSH
67564: LD_VAR 0 2
67568: ARRAY
67569: PUSH
67570: LD_INT 1
67572: ARRAY
67573: PPUSH
67574: CALL_OW 310
67578: NOT
67579: AND
67580: IFFALSE 67606
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67582: LD_EXP 89
67586: PUSH
67587: LD_VAR 0 2
67591: ARRAY
67592: PUSH
67593: LD_INT 1
67595: ARRAY
67596: PPUSH
67597: LD_VAR 0 3
67601: PPUSH
67602: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67606: LD_EXP 89
67610: PUSH
67611: LD_VAR 0 2
67615: ARRAY
67616: PUSH
67617: LD_INT 1
67619: ARRAY
67620: PPUSH
67621: CALL_OW 310
67625: PUSH
67626: LD_EXP 89
67630: PUSH
67631: LD_VAR 0 2
67635: ARRAY
67636: PUSH
67637: LD_INT 1
67639: ARRAY
67640: PPUSH
67641: CALL_OW 310
67645: PPUSH
67646: CALL_OW 461
67650: PUSH
67651: LD_INT 3
67653: NONEQUAL
67654: AND
67655: IFFALSE 67676
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67657: LD_EXP 89
67661: PUSH
67662: LD_VAR 0 2
67666: ARRAY
67667: PUSH
67668: LD_INT 1
67670: ARRAY
67671: PPUSH
67672: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67676: LD_VAR 0 3
67680: PPUSH
67681: CALL_OW 461
67685: PUSH
67686: LD_INT 6
67688: EQUAL
67689: PUSH
67690: LD_VAR 0 6
67694: PUSH
67695: LD_INT 1
67697: GREATER
67698: AND
67699: IFFALSE 67851
// begin sci := [ ] ;
67701: LD_ADDR_VAR 0 8
67705: PUSH
67706: EMPTY
67707: ST_TO_ADDR
// for x in ( tmp diff j ) do
67708: LD_ADDR_VAR 0 7
67712: PUSH
67713: LD_VAR 0 6
67717: PUSH
67718: LD_VAR 0 3
67722: DIFF
67723: PUSH
67724: FOR_IN
67725: IFFALSE 67777
// begin if sci = 6 then
67727: LD_VAR 0 8
67731: PUSH
67732: LD_INT 6
67734: EQUAL
67735: IFFALSE 67739
// break ;
67737: GO 67777
// if BuildingStatus ( x ) = bs_idle then
67739: LD_VAR 0 7
67743: PPUSH
67744: CALL_OW 461
67748: PUSH
67749: LD_INT 2
67751: EQUAL
67752: IFFALSE 67775
// sci := sci ^ UnitsInside ( x ) ;
67754: LD_ADDR_VAR 0 8
67758: PUSH
67759: LD_VAR 0 8
67763: PUSH
67764: LD_VAR 0 7
67768: PPUSH
67769: CALL_OW 313
67773: ADD
67774: ST_TO_ADDR
// end ;
67775: GO 67724
67777: POP
67778: POP
// if not sci then
67779: LD_VAR 0 8
67783: NOT
67784: IFFALSE 67788
// continue ;
67786: GO 66833
// for x in sci do
67788: LD_ADDR_VAR 0 7
67792: PUSH
67793: LD_VAR 0 8
67797: PUSH
67798: FOR_IN
67799: IFFALSE 67849
// if IsInUnit ( x ) and not HasTask ( x ) then
67801: LD_VAR 0 7
67805: PPUSH
67806: CALL_OW 310
67810: PUSH
67811: LD_VAR 0 7
67815: PPUSH
67816: CALL_OW 314
67820: NOT
67821: AND
67822: IFFALSE 67847
// begin ComExitBuilding ( x ) ;
67824: LD_VAR 0 7
67828: PPUSH
67829: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67833: LD_VAR 0 7
67837: PPUSH
67838: LD_VAR 0 3
67842: PPUSH
67843: CALL_OW 180
// end ;
67847: GO 67798
67849: POP
67850: POP
// end ; end ;
67851: GO 66833
67853: POP
67854: POP
// end ;
67855: GO 66787
67857: POP
67858: POP
// end ;
67859: LD_VAR 0 1
67863: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67864: LD_INT 0
67866: PPUSH
67867: PPUSH
// if not mc_bases then
67868: LD_EXP 59
67872: NOT
67873: IFFALSE 67877
// exit ;
67875: GO 67958
// for i = 1 to mc_bases do
67877: LD_ADDR_VAR 0 2
67881: PUSH
67882: DOUBLE
67883: LD_INT 1
67885: DEC
67886: ST_TO_ADDR
67887: LD_EXP 59
67891: PUSH
67892: FOR_TO
67893: IFFALSE 67956
// if mc_mines [ i ] and mc_miners [ i ] then
67895: LD_EXP 72
67899: PUSH
67900: LD_VAR 0 2
67904: ARRAY
67905: PUSH
67906: LD_EXP 73
67910: PUSH
67911: LD_VAR 0 2
67915: ARRAY
67916: AND
67917: IFFALSE 67954
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
67919: LD_EXP 73
67923: PUSH
67924: LD_VAR 0 2
67928: ARRAY
67929: PUSH
67930: LD_INT 1
67932: ARRAY
67933: PPUSH
67934: CALL_OW 255
67938: PPUSH
67939: LD_EXP 72
67943: PUSH
67944: LD_VAR 0 2
67948: ARRAY
67949: PPUSH
67950: CALL 16227 0 2
67954: GO 67892
67956: POP
67957: POP
// end ;
67958: LD_VAR 0 1
67962: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
67963: LD_INT 0
67965: PPUSH
67966: PPUSH
67967: PPUSH
67968: PPUSH
67969: PPUSH
67970: PPUSH
67971: PPUSH
67972: PPUSH
// if not mc_bases or not mc_parking then
67973: LD_EXP 59
67977: NOT
67978: PUSH
67979: LD_EXP 83
67983: NOT
67984: OR
67985: IFFALSE 67989
// exit ;
67987: GO 68688
// for i = 1 to mc_bases do
67989: LD_ADDR_VAR 0 2
67993: PUSH
67994: DOUBLE
67995: LD_INT 1
67997: DEC
67998: ST_TO_ADDR
67999: LD_EXP 59
68003: PUSH
68004: FOR_TO
68005: IFFALSE 68686
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68007: LD_EXP 59
68011: PUSH
68012: LD_VAR 0 2
68016: ARRAY
68017: NOT
68018: PUSH
68019: LD_EXP 83
68023: PUSH
68024: LD_VAR 0 2
68028: ARRAY
68029: NOT
68030: OR
68031: IFFALSE 68035
// continue ;
68033: GO 68004
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68035: LD_ADDR_VAR 0 5
68039: PUSH
68040: LD_EXP 59
68044: PUSH
68045: LD_VAR 0 2
68049: ARRAY
68050: PUSH
68051: LD_INT 1
68053: ARRAY
68054: PPUSH
68055: CALL_OW 255
68059: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68060: LD_ADDR_VAR 0 6
68064: PUSH
68065: LD_EXP 59
68069: PUSH
68070: LD_VAR 0 2
68074: ARRAY
68075: PPUSH
68076: LD_INT 30
68078: PUSH
68079: LD_INT 3
68081: PUSH
68082: EMPTY
68083: LIST
68084: LIST
68085: PPUSH
68086: CALL_OW 72
68090: ST_TO_ADDR
// if not fac then
68091: LD_VAR 0 6
68095: NOT
68096: IFFALSE 68147
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68098: LD_ADDR_VAR 0 6
68102: PUSH
68103: LD_EXP 59
68107: PUSH
68108: LD_VAR 0 2
68112: ARRAY
68113: PPUSH
68114: LD_INT 2
68116: PUSH
68117: LD_INT 30
68119: PUSH
68120: LD_INT 0
68122: PUSH
68123: EMPTY
68124: LIST
68125: LIST
68126: PUSH
68127: LD_INT 30
68129: PUSH
68130: LD_INT 1
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: PUSH
68137: EMPTY
68138: LIST
68139: LIST
68140: LIST
68141: PPUSH
68142: CALL_OW 72
68146: ST_TO_ADDR
// if not fac then
68147: LD_VAR 0 6
68151: NOT
68152: IFFALSE 68156
// continue ;
68154: GO 68004
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68156: LD_ADDR_VAR 0 7
68160: PUSH
68161: LD_EXP 83
68165: PUSH
68166: LD_VAR 0 2
68170: ARRAY
68171: PPUSH
68172: LD_INT 22
68174: PUSH
68175: LD_VAR 0 5
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 21
68186: PUSH
68187: LD_INT 2
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 3
68196: PUSH
68197: LD_INT 24
68199: PUSH
68200: LD_INT 1000
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: EMPTY
68212: LIST
68213: LIST
68214: LIST
68215: PPUSH
68216: CALL_OW 70
68220: ST_TO_ADDR
// for j in fac do
68221: LD_ADDR_VAR 0 3
68225: PUSH
68226: LD_VAR 0 6
68230: PUSH
68231: FOR_IN
68232: IFFALSE 68313
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68234: LD_ADDR_VAR 0 7
68238: PUSH
68239: LD_VAR 0 7
68243: PUSH
68244: LD_INT 22
68246: PUSH
68247: LD_VAR 0 5
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 91
68258: PUSH
68259: LD_VAR 0 3
68263: PUSH
68264: LD_INT 15
68266: PUSH
68267: EMPTY
68268: LIST
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 21
68274: PUSH
68275: LD_INT 2
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: LD_INT 3
68284: PUSH
68285: LD_INT 24
68287: PUSH
68288: LD_INT 1000
68290: PUSH
68291: EMPTY
68292: LIST
68293: LIST
68294: PUSH
68295: EMPTY
68296: LIST
68297: LIST
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: LIST
68303: LIST
68304: PPUSH
68305: CALL_OW 69
68309: UNION
68310: ST_TO_ADDR
68311: GO 68231
68313: POP
68314: POP
// if not vehs then
68315: LD_VAR 0 7
68319: NOT
68320: IFFALSE 68346
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68322: LD_ADDR_EXP 71
68326: PUSH
68327: LD_EXP 71
68331: PPUSH
68332: LD_VAR 0 2
68336: PPUSH
68337: EMPTY
68338: PPUSH
68339: CALL_OW 1
68343: ST_TO_ADDR
// continue ;
68344: GO 68004
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68346: LD_ADDR_VAR 0 8
68350: PUSH
68351: LD_EXP 59
68355: PUSH
68356: LD_VAR 0 2
68360: ARRAY
68361: PPUSH
68362: LD_INT 30
68364: PUSH
68365: LD_INT 3
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PPUSH
68372: CALL_OW 72
68376: ST_TO_ADDR
// if tmp then
68377: LD_VAR 0 8
68381: IFFALSE 68484
// begin for j in tmp do
68383: LD_ADDR_VAR 0 3
68387: PUSH
68388: LD_VAR 0 8
68392: PUSH
68393: FOR_IN
68394: IFFALSE 68482
// for k in UnitsInside ( j ) do
68396: LD_ADDR_VAR 0 4
68400: PUSH
68401: LD_VAR 0 3
68405: PPUSH
68406: CALL_OW 313
68410: PUSH
68411: FOR_IN
68412: IFFALSE 68478
// if k then
68414: LD_VAR 0 4
68418: IFFALSE 68476
// if not k in mc_repair_vehicle [ i ] then
68420: LD_VAR 0 4
68424: PUSH
68425: LD_EXP 71
68429: PUSH
68430: LD_VAR 0 2
68434: ARRAY
68435: IN
68436: NOT
68437: IFFALSE 68476
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68439: LD_ADDR_EXP 71
68443: PUSH
68444: LD_EXP 71
68448: PPUSH
68449: LD_VAR 0 2
68453: PPUSH
68454: LD_EXP 71
68458: PUSH
68459: LD_VAR 0 2
68463: ARRAY
68464: PUSH
68465: LD_VAR 0 4
68469: UNION
68470: PPUSH
68471: CALL_OW 1
68475: ST_TO_ADDR
68476: GO 68411
68478: POP
68479: POP
68480: GO 68393
68482: POP
68483: POP
// end ; if not mc_repair_vehicle [ i ] then
68484: LD_EXP 71
68488: PUSH
68489: LD_VAR 0 2
68493: ARRAY
68494: NOT
68495: IFFALSE 68499
// continue ;
68497: GO 68004
// for j in mc_repair_vehicle [ i ] do
68499: LD_ADDR_VAR 0 3
68503: PUSH
68504: LD_EXP 71
68508: PUSH
68509: LD_VAR 0 2
68513: ARRAY
68514: PUSH
68515: FOR_IN
68516: IFFALSE 68682
// begin if GetClass ( j ) <> 3 then
68518: LD_VAR 0 3
68522: PPUSH
68523: CALL_OW 257
68527: PUSH
68528: LD_INT 3
68530: NONEQUAL
68531: IFFALSE 68572
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68533: LD_ADDR_EXP 71
68537: PUSH
68538: LD_EXP 71
68542: PPUSH
68543: LD_VAR 0 2
68547: PPUSH
68548: LD_EXP 71
68552: PUSH
68553: LD_VAR 0 2
68557: ARRAY
68558: PUSH
68559: LD_VAR 0 3
68563: DIFF
68564: PPUSH
68565: CALL_OW 1
68569: ST_TO_ADDR
// continue ;
68570: GO 68515
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68572: LD_VAR 0 3
68576: PPUSH
68577: CALL_OW 311
68581: NOT
68582: PUSH
68583: LD_VAR 0 3
68587: PUSH
68588: LD_EXP 62
68592: PUSH
68593: LD_VAR 0 2
68597: ARRAY
68598: PUSH
68599: LD_INT 1
68601: ARRAY
68602: IN
68603: NOT
68604: AND
68605: PUSH
68606: LD_VAR 0 3
68610: PUSH
68611: LD_EXP 62
68615: PUSH
68616: LD_VAR 0 2
68620: ARRAY
68621: PUSH
68622: LD_INT 2
68624: ARRAY
68625: IN
68626: NOT
68627: AND
68628: IFFALSE 68680
// begin if IsInUnit ( j ) then
68630: LD_VAR 0 3
68634: PPUSH
68635: CALL_OW 310
68639: IFFALSE 68650
// ComExitBuilding ( j ) ;
68641: LD_VAR 0 3
68645: PPUSH
68646: CALL_OW 122
// if not HasTask ( j ) then
68650: LD_VAR 0 3
68654: PPUSH
68655: CALL_OW 314
68659: NOT
68660: IFFALSE 68680
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68662: LD_VAR 0 3
68666: PPUSH
68667: LD_VAR 0 7
68671: PUSH
68672: LD_INT 1
68674: ARRAY
68675: PPUSH
68676: CALL_OW 189
// end ; end ;
68680: GO 68515
68682: POP
68683: POP
// end ;
68684: GO 68004
68686: POP
68687: POP
// end ;
68688: LD_VAR 0 1
68692: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68693: LD_INT 0
68695: PPUSH
68696: PPUSH
68697: PPUSH
68698: PPUSH
68699: PPUSH
68700: PPUSH
68701: PPUSH
68702: PPUSH
68703: PPUSH
68704: PPUSH
68705: PPUSH
// if not mc_bases then
68706: LD_EXP 59
68710: NOT
68711: IFFALSE 68715
// exit ;
68713: GO 69517
// for i = 1 to mc_bases do
68715: LD_ADDR_VAR 0 2
68719: PUSH
68720: DOUBLE
68721: LD_INT 1
68723: DEC
68724: ST_TO_ADDR
68725: LD_EXP 59
68729: PUSH
68730: FOR_TO
68731: IFFALSE 69515
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68733: LD_EXP 87
68737: PUSH
68738: LD_VAR 0 2
68742: ARRAY
68743: NOT
68744: PUSH
68745: LD_EXP 62
68749: PUSH
68750: LD_VAR 0 2
68754: ARRAY
68755: PUSH
68756: LD_INT 1
68758: ARRAY
68759: OR
68760: PUSH
68761: LD_EXP 62
68765: PUSH
68766: LD_VAR 0 2
68770: ARRAY
68771: PUSH
68772: LD_INT 2
68774: ARRAY
68775: OR
68776: PUSH
68777: LD_EXP 85
68781: PUSH
68782: LD_VAR 0 2
68786: ARRAY
68787: PPUSH
68788: LD_INT 1
68790: PPUSH
68791: CALL_OW 325
68795: NOT
68796: OR
68797: PUSH
68798: LD_EXP 82
68802: PUSH
68803: LD_VAR 0 2
68807: ARRAY
68808: OR
68809: IFFALSE 68813
// continue ;
68811: GO 68730
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68813: LD_ADDR_VAR 0 8
68817: PUSH
68818: LD_EXP 59
68822: PUSH
68823: LD_VAR 0 2
68827: ARRAY
68828: PPUSH
68829: LD_INT 25
68831: PUSH
68832: LD_INT 4
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 50
68841: PUSH
68842: EMPTY
68843: LIST
68844: PUSH
68845: LD_INT 3
68847: PUSH
68848: LD_INT 60
68850: PUSH
68851: EMPTY
68852: LIST
68853: PUSH
68854: EMPTY
68855: LIST
68856: LIST
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: LIST
68862: PPUSH
68863: CALL_OW 72
68867: PUSH
68868: LD_EXP 63
68872: PUSH
68873: LD_VAR 0 2
68877: ARRAY
68878: DIFF
68879: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68880: LD_ADDR_VAR 0 9
68884: PUSH
68885: LD_EXP 59
68889: PUSH
68890: LD_VAR 0 2
68894: ARRAY
68895: PPUSH
68896: LD_INT 2
68898: PUSH
68899: LD_INT 30
68901: PUSH
68902: LD_INT 0
68904: PUSH
68905: EMPTY
68906: LIST
68907: LIST
68908: PUSH
68909: LD_INT 30
68911: PUSH
68912: LD_INT 1
68914: PUSH
68915: EMPTY
68916: LIST
68917: LIST
68918: PUSH
68919: EMPTY
68920: LIST
68921: LIST
68922: LIST
68923: PPUSH
68924: CALL_OW 72
68928: ST_TO_ADDR
// if not tmp or not dep then
68929: LD_VAR 0 8
68933: NOT
68934: PUSH
68935: LD_VAR 0 9
68939: NOT
68940: OR
68941: IFFALSE 68945
// continue ;
68943: GO 68730
// side := GetSide ( tmp [ 1 ] ) ;
68945: LD_ADDR_VAR 0 11
68949: PUSH
68950: LD_VAR 0 8
68954: PUSH
68955: LD_INT 1
68957: ARRAY
68958: PPUSH
68959: CALL_OW 255
68963: ST_TO_ADDR
// dep := dep [ 1 ] ;
68964: LD_ADDR_VAR 0 9
68968: PUSH
68969: LD_VAR 0 9
68973: PUSH
68974: LD_INT 1
68976: ARRAY
68977: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
68978: LD_ADDR_VAR 0 7
68982: PUSH
68983: LD_EXP 87
68987: PUSH
68988: LD_VAR 0 2
68992: ARRAY
68993: PPUSH
68994: LD_INT 22
68996: PUSH
68997: LD_INT 0
68999: PUSH
69000: EMPTY
69001: LIST
69002: LIST
69003: PUSH
69004: LD_INT 25
69006: PUSH
69007: LD_INT 12
69009: PUSH
69010: EMPTY
69011: LIST
69012: LIST
69013: PUSH
69014: EMPTY
69015: LIST
69016: LIST
69017: PPUSH
69018: CALL_OW 70
69022: PUSH
69023: LD_INT 22
69025: PUSH
69026: LD_INT 0
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 25
69035: PUSH
69036: LD_INT 12
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 91
69045: PUSH
69046: LD_VAR 0 9
69050: PUSH
69051: LD_INT 20
69053: PUSH
69054: EMPTY
69055: LIST
69056: LIST
69057: LIST
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: LIST
69063: PPUSH
69064: CALL_OW 69
69068: UNION
69069: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69070: LD_ADDR_VAR 0 10
69074: PUSH
69075: LD_EXP 87
69079: PUSH
69080: LD_VAR 0 2
69084: ARRAY
69085: PPUSH
69086: LD_INT 81
69088: PUSH
69089: LD_VAR 0 11
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: PPUSH
69098: CALL_OW 70
69102: ST_TO_ADDR
// if not apes or danger_at_area then
69103: LD_VAR 0 7
69107: NOT
69108: PUSH
69109: LD_VAR 0 10
69113: OR
69114: IFFALSE 69164
// begin if mc_taming [ i ] then
69116: LD_EXP 90
69120: PUSH
69121: LD_VAR 0 2
69125: ARRAY
69126: IFFALSE 69162
// begin MC_Reset ( i , 121 ) ;
69128: LD_VAR 0 2
69132: PPUSH
69133: LD_INT 121
69135: PPUSH
69136: CALL 54615 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69140: LD_ADDR_EXP 90
69144: PUSH
69145: LD_EXP 90
69149: PPUSH
69150: LD_VAR 0 2
69154: PPUSH
69155: EMPTY
69156: PPUSH
69157: CALL_OW 1
69161: ST_TO_ADDR
// end ; continue ;
69162: GO 68730
// end ; for j in tmp do
69164: LD_ADDR_VAR 0 3
69168: PUSH
69169: LD_VAR 0 8
69173: PUSH
69174: FOR_IN
69175: IFFALSE 69511
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69177: LD_VAR 0 3
69181: PUSH
69182: LD_EXP 90
69186: PUSH
69187: LD_VAR 0 2
69191: ARRAY
69192: IN
69193: NOT
69194: PUSH
69195: LD_EXP 90
69199: PUSH
69200: LD_VAR 0 2
69204: ARRAY
69205: PUSH
69206: LD_INT 3
69208: LESS
69209: AND
69210: IFFALSE 69268
// begin SetTag ( j , 121 ) ;
69212: LD_VAR 0 3
69216: PPUSH
69217: LD_INT 121
69219: PPUSH
69220: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69224: LD_ADDR_EXP 90
69228: PUSH
69229: LD_EXP 90
69233: PPUSH
69234: LD_VAR 0 2
69238: PUSH
69239: LD_EXP 90
69243: PUSH
69244: LD_VAR 0 2
69248: ARRAY
69249: PUSH
69250: LD_INT 1
69252: PLUS
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PPUSH
69258: LD_VAR 0 3
69262: PPUSH
69263: CALL 19238 0 3
69267: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69268: LD_VAR 0 3
69272: PUSH
69273: LD_EXP 90
69277: PUSH
69278: LD_VAR 0 2
69282: ARRAY
69283: IN
69284: IFFALSE 69509
// begin if GetClass ( j ) <> 4 then
69286: LD_VAR 0 3
69290: PPUSH
69291: CALL_OW 257
69295: PUSH
69296: LD_INT 4
69298: NONEQUAL
69299: IFFALSE 69352
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69301: LD_ADDR_EXP 90
69305: PUSH
69306: LD_EXP 90
69310: PPUSH
69311: LD_VAR 0 2
69315: PPUSH
69316: LD_EXP 90
69320: PUSH
69321: LD_VAR 0 2
69325: ARRAY
69326: PUSH
69327: LD_VAR 0 3
69331: DIFF
69332: PPUSH
69333: CALL_OW 1
69337: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69338: LD_VAR 0 3
69342: PPUSH
69343: LD_INT 0
69345: PPUSH
69346: CALL_OW 109
// continue ;
69350: GO 69174
// end ; if IsInUnit ( j ) then
69352: LD_VAR 0 3
69356: PPUSH
69357: CALL_OW 310
69361: IFFALSE 69372
// ComExitBuilding ( j ) ;
69363: LD_VAR 0 3
69367: PPUSH
69368: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69372: LD_ADDR_VAR 0 6
69376: PUSH
69377: LD_VAR 0 7
69381: PPUSH
69382: LD_VAR 0 3
69386: PPUSH
69387: CALL_OW 74
69391: ST_TO_ADDR
// if not ape then
69392: LD_VAR 0 6
69396: NOT
69397: IFFALSE 69401
// break ;
69399: GO 69511
// x := GetX ( ape ) ;
69401: LD_ADDR_VAR 0 4
69405: PUSH
69406: LD_VAR 0 6
69410: PPUSH
69411: CALL_OW 250
69415: ST_TO_ADDR
// y := GetY ( ape ) ;
69416: LD_ADDR_VAR 0 5
69420: PUSH
69421: LD_VAR 0 6
69425: PPUSH
69426: CALL_OW 251
69430: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69431: LD_VAR 0 4
69435: PPUSH
69436: LD_VAR 0 5
69440: PPUSH
69441: CALL_OW 488
69445: NOT
69446: PUSH
69447: LD_VAR 0 11
69451: PPUSH
69452: LD_VAR 0 4
69456: PPUSH
69457: LD_VAR 0 5
69461: PPUSH
69462: LD_INT 20
69464: PPUSH
69465: CALL 20134 0 4
69469: PUSH
69470: LD_INT 4
69472: ARRAY
69473: OR
69474: IFFALSE 69478
// break ;
69476: GO 69511
// if not HasTask ( j ) then
69478: LD_VAR 0 3
69482: PPUSH
69483: CALL_OW 314
69487: NOT
69488: IFFALSE 69509
// ComTameXY ( j , x , y ) ;
69490: LD_VAR 0 3
69494: PPUSH
69495: LD_VAR 0 4
69499: PPUSH
69500: LD_VAR 0 5
69504: PPUSH
69505: CALL_OW 131
// end ; end ;
69509: GO 69174
69511: POP
69512: POP
// end ;
69513: GO 68730
69515: POP
69516: POP
// end ;
69517: LD_VAR 0 1
69521: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69522: LD_INT 0
69524: PPUSH
69525: PPUSH
69526: PPUSH
69527: PPUSH
69528: PPUSH
69529: PPUSH
69530: PPUSH
69531: PPUSH
// if not mc_bases then
69532: LD_EXP 59
69536: NOT
69537: IFFALSE 69541
// exit ;
69539: GO 70167
// for i = 1 to mc_bases do
69541: LD_ADDR_VAR 0 2
69545: PUSH
69546: DOUBLE
69547: LD_INT 1
69549: DEC
69550: ST_TO_ADDR
69551: LD_EXP 59
69555: PUSH
69556: FOR_TO
69557: IFFALSE 70165
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69559: LD_EXP 88
69563: PUSH
69564: LD_VAR 0 2
69568: ARRAY
69569: NOT
69570: PUSH
69571: LD_EXP 88
69575: PUSH
69576: LD_VAR 0 2
69580: ARRAY
69581: PPUSH
69582: LD_INT 25
69584: PUSH
69585: LD_INT 12
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PPUSH
69592: CALL_OW 72
69596: NOT
69597: OR
69598: IFFALSE 69602
// continue ;
69600: GO 69556
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69602: LD_ADDR_VAR 0 5
69606: PUSH
69607: LD_EXP 88
69611: PUSH
69612: LD_VAR 0 2
69616: ARRAY
69617: PUSH
69618: LD_INT 1
69620: ARRAY
69621: PPUSH
69622: CALL_OW 255
69626: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69627: LD_VAR 0 5
69631: PPUSH
69632: LD_INT 2
69634: PPUSH
69635: CALL_OW 325
69639: IFFALSE 69892
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69641: LD_ADDR_VAR 0 4
69645: PUSH
69646: LD_EXP 88
69650: PUSH
69651: LD_VAR 0 2
69655: ARRAY
69656: PPUSH
69657: LD_INT 25
69659: PUSH
69660: LD_INT 16
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PPUSH
69667: CALL_OW 72
69671: ST_TO_ADDR
// if tmp < 6 then
69672: LD_VAR 0 4
69676: PUSH
69677: LD_INT 6
69679: LESS
69680: IFFALSE 69892
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69682: LD_ADDR_VAR 0 6
69686: PUSH
69687: LD_EXP 59
69691: PUSH
69692: LD_VAR 0 2
69696: ARRAY
69697: PPUSH
69698: LD_INT 2
69700: PUSH
69701: LD_INT 30
69703: PUSH
69704: LD_INT 0
69706: PUSH
69707: EMPTY
69708: LIST
69709: LIST
69710: PUSH
69711: LD_INT 30
69713: PUSH
69714: LD_INT 1
69716: PUSH
69717: EMPTY
69718: LIST
69719: LIST
69720: PUSH
69721: EMPTY
69722: LIST
69723: LIST
69724: LIST
69725: PPUSH
69726: CALL_OW 72
69730: ST_TO_ADDR
// if depot then
69731: LD_VAR 0 6
69735: IFFALSE 69892
// begin selected := 0 ;
69737: LD_ADDR_VAR 0 7
69741: PUSH
69742: LD_INT 0
69744: ST_TO_ADDR
// for j in depot do
69745: LD_ADDR_VAR 0 3
69749: PUSH
69750: LD_VAR 0 6
69754: PUSH
69755: FOR_IN
69756: IFFALSE 69787
// begin if UnitsInside ( j ) < 6 then
69758: LD_VAR 0 3
69762: PPUSH
69763: CALL_OW 313
69767: PUSH
69768: LD_INT 6
69770: LESS
69771: IFFALSE 69785
// begin selected := j ;
69773: LD_ADDR_VAR 0 7
69777: PUSH
69778: LD_VAR 0 3
69782: ST_TO_ADDR
// break ;
69783: GO 69787
// end ; end ;
69785: GO 69755
69787: POP
69788: POP
// if selected then
69789: LD_VAR 0 7
69793: IFFALSE 69892
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69795: LD_ADDR_VAR 0 3
69799: PUSH
69800: LD_EXP 88
69804: PUSH
69805: LD_VAR 0 2
69809: ARRAY
69810: PPUSH
69811: LD_INT 25
69813: PUSH
69814: LD_INT 12
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PPUSH
69821: CALL_OW 72
69825: PUSH
69826: FOR_IN
69827: IFFALSE 69890
// if not HasTask ( j ) then
69829: LD_VAR 0 3
69833: PPUSH
69834: CALL_OW 314
69838: NOT
69839: IFFALSE 69888
// begin if not IsInUnit ( j ) then
69841: LD_VAR 0 3
69845: PPUSH
69846: CALL_OW 310
69850: NOT
69851: IFFALSE 69867
// ComEnterUnit ( j , selected ) ;
69853: LD_VAR 0 3
69857: PPUSH
69858: LD_VAR 0 7
69862: PPUSH
69863: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69867: LD_VAR 0 3
69871: PPUSH
69872: LD_INT 16
69874: PPUSH
69875: CALL_OW 183
// AddComExitBuilding ( j ) ;
69879: LD_VAR 0 3
69883: PPUSH
69884: CALL_OW 182
// end ;
69888: GO 69826
69890: POP
69891: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
69892: LD_VAR 0 5
69896: PPUSH
69897: LD_INT 11
69899: PPUSH
69900: CALL_OW 325
69904: IFFALSE 70163
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69906: LD_ADDR_VAR 0 4
69910: PUSH
69911: LD_EXP 88
69915: PUSH
69916: LD_VAR 0 2
69920: ARRAY
69921: PPUSH
69922: LD_INT 25
69924: PUSH
69925: LD_INT 16
69927: PUSH
69928: EMPTY
69929: LIST
69930: LIST
69931: PPUSH
69932: CALL_OW 72
69936: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
69937: LD_VAR 0 4
69941: PUSH
69942: LD_INT 6
69944: GREATEREQUAL
69945: PUSH
69946: LD_VAR 0 5
69950: PPUSH
69951: LD_INT 2
69953: PPUSH
69954: CALL_OW 325
69958: NOT
69959: OR
69960: IFFALSE 70163
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
69962: LD_ADDR_VAR 0 8
69966: PUSH
69967: LD_EXP 59
69971: PUSH
69972: LD_VAR 0 2
69976: ARRAY
69977: PPUSH
69978: LD_INT 2
69980: PUSH
69981: LD_INT 30
69983: PUSH
69984: LD_INT 4
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 30
69993: PUSH
69994: LD_INT 5
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: EMPTY
70002: LIST
70003: LIST
70004: LIST
70005: PPUSH
70006: CALL_OW 72
70010: ST_TO_ADDR
// if barracks then
70011: LD_VAR 0 8
70015: IFFALSE 70163
// begin selected := 0 ;
70017: LD_ADDR_VAR 0 7
70021: PUSH
70022: LD_INT 0
70024: ST_TO_ADDR
// for j in barracks do
70025: LD_ADDR_VAR 0 3
70029: PUSH
70030: LD_VAR 0 8
70034: PUSH
70035: FOR_IN
70036: IFFALSE 70067
// begin if UnitsInside ( j ) < 6 then
70038: LD_VAR 0 3
70042: PPUSH
70043: CALL_OW 313
70047: PUSH
70048: LD_INT 6
70050: LESS
70051: IFFALSE 70065
// begin selected := j ;
70053: LD_ADDR_VAR 0 7
70057: PUSH
70058: LD_VAR 0 3
70062: ST_TO_ADDR
// break ;
70063: GO 70067
// end ; end ;
70065: GO 70035
70067: POP
70068: POP
// if selected then
70069: LD_VAR 0 7
70073: IFFALSE 70163
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70075: LD_ADDR_VAR 0 3
70079: PUSH
70080: LD_EXP 88
70084: PUSH
70085: LD_VAR 0 2
70089: ARRAY
70090: PPUSH
70091: LD_INT 25
70093: PUSH
70094: LD_INT 12
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PPUSH
70101: CALL_OW 72
70105: PUSH
70106: FOR_IN
70107: IFFALSE 70161
// if not IsInUnit ( j ) and not HasTask ( j ) then
70109: LD_VAR 0 3
70113: PPUSH
70114: CALL_OW 310
70118: NOT
70119: PUSH
70120: LD_VAR 0 3
70124: PPUSH
70125: CALL_OW 314
70129: NOT
70130: AND
70131: IFFALSE 70159
// begin ComEnterUnit ( j , selected ) ;
70133: LD_VAR 0 3
70137: PPUSH
70138: LD_VAR 0 7
70142: PPUSH
70143: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70147: LD_VAR 0 3
70151: PPUSH
70152: LD_INT 15
70154: PPUSH
70155: CALL_OW 183
// end ;
70159: GO 70106
70161: POP
70162: POP
// end ; end ; end ; end ; end ;
70163: GO 69556
70165: POP
70166: POP
// end ;
70167: LD_VAR 0 1
70171: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70172: LD_INT 0
70174: PPUSH
70175: PPUSH
70176: PPUSH
70177: PPUSH
// if not mc_bases then
70178: LD_EXP 59
70182: NOT
70183: IFFALSE 70187
// exit ;
70185: GO 70365
// for i = 1 to mc_bases do
70187: LD_ADDR_VAR 0 2
70191: PUSH
70192: DOUBLE
70193: LD_INT 1
70195: DEC
70196: ST_TO_ADDR
70197: LD_EXP 59
70201: PUSH
70202: FOR_TO
70203: IFFALSE 70363
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70205: LD_ADDR_VAR 0 4
70209: PUSH
70210: LD_EXP 59
70214: PUSH
70215: LD_VAR 0 2
70219: ARRAY
70220: PPUSH
70221: LD_INT 25
70223: PUSH
70224: LD_INT 9
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PPUSH
70231: CALL_OW 72
70235: ST_TO_ADDR
// if not tmp then
70236: LD_VAR 0 4
70240: NOT
70241: IFFALSE 70245
// continue ;
70243: GO 70202
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70245: LD_EXP 85
70249: PUSH
70250: LD_VAR 0 2
70254: ARRAY
70255: PPUSH
70256: LD_INT 29
70258: PPUSH
70259: CALL_OW 325
70263: NOT
70264: PUSH
70265: LD_EXP 85
70269: PUSH
70270: LD_VAR 0 2
70274: ARRAY
70275: PPUSH
70276: LD_INT 28
70278: PPUSH
70279: CALL_OW 325
70283: NOT
70284: AND
70285: IFFALSE 70289
// continue ;
70287: GO 70202
// for j in tmp do
70289: LD_ADDR_VAR 0 3
70293: PUSH
70294: LD_VAR 0 4
70298: PUSH
70299: FOR_IN
70300: IFFALSE 70359
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70302: LD_VAR 0 3
70306: PUSH
70307: LD_EXP 62
70311: PUSH
70312: LD_VAR 0 2
70316: ARRAY
70317: PUSH
70318: LD_INT 1
70320: ARRAY
70321: IN
70322: NOT
70323: PUSH
70324: LD_VAR 0 3
70328: PUSH
70329: LD_EXP 62
70333: PUSH
70334: LD_VAR 0 2
70338: ARRAY
70339: PUSH
70340: LD_INT 2
70342: ARRAY
70343: IN
70344: NOT
70345: AND
70346: IFFALSE 70357
// ComSpaceTimeShoot ( j ) ;
70348: LD_VAR 0 3
70352: PPUSH
70353: CALL 15235 0 1
70357: GO 70299
70359: POP
70360: POP
// end ;
70361: GO 70202
70363: POP
70364: POP
// end ;
70365: LD_VAR 0 1
70369: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70370: LD_INT 0
70372: PPUSH
70373: PPUSH
70374: PPUSH
70375: PPUSH
70376: PPUSH
70377: PPUSH
70378: PPUSH
70379: PPUSH
70380: PPUSH
// if not mc_bases then
70381: LD_EXP 59
70385: NOT
70386: IFFALSE 70390
// exit ;
70388: GO 71012
// for i = 1 to mc_bases do
70390: LD_ADDR_VAR 0 2
70394: PUSH
70395: DOUBLE
70396: LD_INT 1
70398: DEC
70399: ST_TO_ADDR
70400: LD_EXP 59
70404: PUSH
70405: FOR_TO
70406: IFFALSE 71010
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70408: LD_EXP 94
70412: PUSH
70413: LD_VAR 0 2
70417: ARRAY
70418: NOT
70419: PUSH
70420: LD_INT 38
70422: PPUSH
70423: LD_EXP 85
70427: PUSH
70428: LD_VAR 0 2
70432: ARRAY
70433: PPUSH
70434: CALL_OW 321
70438: PUSH
70439: LD_INT 2
70441: NONEQUAL
70442: OR
70443: IFFALSE 70447
// continue ;
70445: GO 70405
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70447: LD_ADDR_VAR 0 8
70451: PUSH
70452: LD_EXP 59
70456: PUSH
70457: LD_VAR 0 2
70461: ARRAY
70462: PPUSH
70463: LD_INT 30
70465: PUSH
70466: LD_INT 34
70468: PUSH
70469: EMPTY
70470: LIST
70471: LIST
70472: PPUSH
70473: CALL_OW 72
70477: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70478: LD_ADDR_VAR 0 9
70482: PUSH
70483: LD_EXP 59
70487: PUSH
70488: LD_VAR 0 2
70492: ARRAY
70493: PPUSH
70494: LD_INT 25
70496: PUSH
70497: LD_INT 4
70499: PUSH
70500: EMPTY
70501: LIST
70502: LIST
70503: PPUSH
70504: CALL_OW 72
70508: PPUSH
70509: LD_INT 0
70511: PPUSH
70512: CALL 47799 0 2
70516: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70517: LD_VAR 0 9
70521: NOT
70522: PUSH
70523: LD_VAR 0 8
70527: NOT
70528: OR
70529: PUSH
70530: LD_EXP 59
70534: PUSH
70535: LD_VAR 0 2
70539: ARRAY
70540: PPUSH
70541: LD_INT 124
70543: PPUSH
70544: CALL 47799 0 2
70548: OR
70549: IFFALSE 70553
// continue ;
70551: GO 70405
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70553: LD_EXP 95
70557: PUSH
70558: LD_VAR 0 2
70562: ARRAY
70563: PUSH
70564: LD_EXP 94
70568: PUSH
70569: LD_VAR 0 2
70573: ARRAY
70574: LESS
70575: PUSH
70576: LD_EXP 95
70580: PUSH
70581: LD_VAR 0 2
70585: ARRAY
70586: PUSH
70587: LD_VAR 0 8
70591: LESS
70592: AND
70593: IFFALSE 71008
// begin tmp := sci [ 1 ] ;
70595: LD_ADDR_VAR 0 7
70599: PUSH
70600: LD_VAR 0 9
70604: PUSH
70605: LD_INT 1
70607: ARRAY
70608: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70609: LD_VAR 0 7
70613: PPUSH
70614: LD_INT 124
70616: PPUSH
70617: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70621: LD_ADDR_VAR 0 3
70625: PUSH
70626: DOUBLE
70627: LD_EXP 94
70631: PUSH
70632: LD_VAR 0 2
70636: ARRAY
70637: INC
70638: ST_TO_ADDR
70639: LD_EXP 94
70643: PUSH
70644: LD_VAR 0 2
70648: ARRAY
70649: PUSH
70650: FOR_DOWNTO
70651: IFFALSE 70994
// begin if IsInUnit ( tmp ) then
70653: LD_VAR 0 7
70657: PPUSH
70658: CALL_OW 310
70662: IFFALSE 70673
// ComExitBuilding ( tmp ) ;
70664: LD_VAR 0 7
70668: PPUSH
70669: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70673: LD_INT 35
70675: PPUSH
70676: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70680: LD_VAR 0 7
70684: PPUSH
70685: CALL_OW 310
70689: NOT
70690: PUSH
70691: LD_VAR 0 7
70695: PPUSH
70696: CALL_OW 314
70700: NOT
70701: AND
70702: IFFALSE 70673
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70704: LD_ADDR_VAR 0 6
70708: PUSH
70709: LD_VAR 0 7
70713: PPUSH
70714: CALL_OW 250
70718: PUSH
70719: LD_VAR 0 7
70723: PPUSH
70724: CALL_OW 251
70728: PUSH
70729: EMPTY
70730: LIST
70731: LIST
70732: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70733: LD_INT 35
70735: PPUSH
70736: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70740: LD_ADDR_VAR 0 4
70744: PUSH
70745: LD_EXP 94
70749: PUSH
70750: LD_VAR 0 2
70754: ARRAY
70755: PUSH
70756: LD_VAR 0 3
70760: ARRAY
70761: PUSH
70762: LD_INT 1
70764: ARRAY
70765: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70766: LD_ADDR_VAR 0 5
70770: PUSH
70771: LD_EXP 94
70775: PUSH
70776: LD_VAR 0 2
70780: ARRAY
70781: PUSH
70782: LD_VAR 0 3
70786: ARRAY
70787: PUSH
70788: LD_INT 2
70790: ARRAY
70791: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70792: LD_VAR 0 7
70796: PPUSH
70797: LD_INT 10
70799: PPUSH
70800: CALL 21831 0 2
70804: PUSH
70805: LD_INT 4
70807: ARRAY
70808: IFFALSE 70846
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70810: LD_VAR 0 7
70814: PPUSH
70815: LD_VAR 0 6
70819: PUSH
70820: LD_INT 1
70822: ARRAY
70823: PPUSH
70824: LD_VAR 0 6
70828: PUSH
70829: LD_INT 2
70831: ARRAY
70832: PPUSH
70833: CALL_OW 111
// wait ( 0 0$10 ) ;
70837: LD_INT 350
70839: PPUSH
70840: CALL_OW 67
// end else
70844: GO 70872
// begin ComMoveXY ( tmp , x , y ) ;
70846: LD_VAR 0 7
70850: PPUSH
70851: LD_VAR 0 4
70855: PPUSH
70856: LD_VAR 0 5
70860: PPUSH
70861: CALL_OW 111
// wait ( 0 0$3 ) ;
70865: LD_INT 105
70867: PPUSH
70868: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70872: LD_VAR 0 7
70876: PPUSH
70877: LD_VAR 0 4
70881: PPUSH
70882: LD_VAR 0 5
70886: PPUSH
70887: CALL_OW 307
70891: IFFALSE 70733
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
70893: LD_VAR 0 7
70897: PPUSH
70898: LD_VAR 0 4
70902: PPUSH
70903: LD_VAR 0 5
70907: PPUSH
70908: LD_VAR 0 8
70912: PUSH
70913: LD_VAR 0 3
70917: ARRAY
70918: PPUSH
70919: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
70923: LD_INT 35
70925: PPUSH
70926: CALL_OW 67
// until not HasTask ( tmp ) ;
70930: LD_VAR 0 7
70934: PPUSH
70935: CALL_OW 314
70939: NOT
70940: IFFALSE 70923
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
70942: LD_ADDR_EXP 95
70946: PUSH
70947: LD_EXP 95
70951: PPUSH
70952: LD_VAR 0 2
70956: PUSH
70957: LD_EXP 95
70961: PUSH
70962: LD_VAR 0 2
70966: ARRAY
70967: PUSH
70968: LD_INT 1
70970: PLUS
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PPUSH
70976: LD_VAR 0 8
70980: PUSH
70981: LD_VAR 0 3
70985: ARRAY
70986: PPUSH
70987: CALL 19238 0 3
70991: ST_TO_ADDR
// end ;
70992: GO 70650
70994: POP
70995: POP
// MC_Reset ( i , 124 ) ;
70996: LD_VAR 0 2
71000: PPUSH
71001: LD_INT 124
71003: PPUSH
71004: CALL 54615 0 2
// end ; end ;
71008: GO 70405
71010: POP
71011: POP
// end ;
71012: LD_VAR 0 1
71016: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71017: LD_INT 0
71019: PPUSH
71020: PPUSH
71021: PPUSH
// if not mc_bases then
71022: LD_EXP 59
71026: NOT
71027: IFFALSE 71031
// exit ;
71029: GO 71637
// for i = 1 to mc_bases do
71031: LD_ADDR_VAR 0 2
71035: PUSH
71036: DOUBLE
71037: LD_INT 1
71039: DEC
71040: ST_TO_ADDR
71041: LD_EXP 59
71045: PUSH
71046: FOR_TO
71047: IFFALSE 71635
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71049: LD_ADDR_VAR 0 3
71053: PUSH
71054: LD_EXP 59
71058: PUSH
71059: LD_VAR 0 2
71063: ARRAY
71064: PPUSH
71065: LD_INT 25
71067: PUSH
71068: LD_INT 4
71070: PUSH
71071: EMPTY
71072: LIST
71073: LIST
71074: PPUSH
71075: CALL_OW 72
71079: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71080: LD_VAR 0 3
71084: NOT
71085: PUSH
71086: LD_EXP 96
71090: PUSH
71091: LD_VAR 0 2
71095: ARRAY
71096: NOT
71097: OR
71098: PUSH
71099: LD_EXP 59
71103: PUSH
71104: LD_VAR 0 2
71108: ARRAY
71109: PPUSH
71110: LD_INT 2
71112: PUSH
71113: LD_INT 30
71115: PUSH
71116: LD_INT 0
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 30
71125: PUSH
71126: LD_INT 1
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: LIST
71137: PPUSH
71138: CALL_OW 72
71142: NOT
71143: OR
71144: IFFALSE 71194
// begin if mc_deposits_finder [ i ] then
71146: LD_EXP 97
71150: PUSH
71151: LD_VAR 0 2
71155: ARRAY
71156: IFFALSE 71192
// begin MC_Reset ( i , 125 ) ;
71158: LD_VAR 0 2
71162: PPUSH
71163: LD_INT 125
71165: PPUSH
71166: CALL 54615 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71170: LD_ADDR_EXP 97
71174: PUSH
71175: LD_EXP 97
71179: PPUSH
71180: LD_VAR 0 2
71184: PPUSH
71185: EMPTY
71186: PPUSH
71187: CALL_OW 1
71191: ST_TO_ADDR
// end ; continue ;
71192: GO 71046
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71194: LD_EXP 96
71198: PUSH
71199: LD_VAR 0 2
71203: ARRAY
71204: PUSH
71205: LD_INT 1
71207: ARRAY
71208: PUSH
71209: LD_INT 3
71211: ARRAY
71212: PUSH
71213: LD_INT 1
71215: EQUAL
71216: PUSH
71217: LD_INT 20
71219: PPUSH
71220: LD_EXP 85
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: PPUSH
71231: CALL_OW 321
71235: PUSH
71236: LD_INT 2
71238: NONEQUAL
71239: AND
71240: IFFALSE 71290
// begin if mc_deposits_finder [ i ] then
71242: LD_EXP 97
71246: PUSH
71247: LD_VAR 0 2
71251: ARRAY
71252: IFFALSE 71288
// begin MC_Reset ( i , 125 ) ;
71254: LD_VAR 0 2
71258: PPUSH
71259: LD_INT 125
71261: PPUSH
71262: CALL 54615 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71266: LD_ADDR_EXP 97
71270: PUSH
71271: LD_EXP 97
71275: PPUSH
71276: LD_VAR 0 2
71280: PPUSH
71281: EMPTY
71282: PPUSH
71283: CALL_OW 1
71287: ST_TO_ADDR
// end ; continue ;
71288: GO 71046
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71290: LD_EXP 96
71294: PUSH
71295: LD_VAR 0 2
71299: ARRAY
71300: PUSH
71301: LD_INT 1
71303: ARRAY
71304: PUSH
71305: LD_INT 1
71307: ARRAY
71308: PPUSH
71309: LD_EXP 96
71313: PUSH
71314: LD_VAR 0 2
71318: ARRAY
71319: PUSH
71320: LD_INT 1
71322: ARRAY
71323: PUSH
71324: LD_INT 2
71326: ARRAY
71327: PPUSH
71328: LD_EXP 85
71332: PUSH
71333: LD_VAR 0 2
71337: ARRAY
71338: PPUSH
71339: CALL_OW 440
71343: IFFALSE 71386
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71345: LD_ADDR_EXP 96
71349: PUSH
71350: LD_EXP 96
71354: PPUSH
71355: LD_VAR 0 2
71359: PPUSH
71360: LD_EXP 96
71364: PUSH
71365: LD_VAR 0 2
71369: ARRAY
71370: PPUSH
71371: LD_INT 1
71373: PPUSH
71374: CALL_OW 3
71378: PPUSH
71379: CALL_OW 1
71383: ST_TO_ADDR
71384: GO 71633
// begin if not mc_deposits_finder [ i ] then
71386: LD_EXP 97
71390: PUSH
71391: LD_VAR 0 2
71395: ARRAY
71396: NOT
71397: IFFALSE 71449
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71399: LD_ADDR_EXP 97
71403: PUSH
71404: LD_EXP 97
71408: PPUSH
71409: LD_VAR 0 2
71413: PPUSH
71414: LD_VAR 0 3
71418: PUSH
71419: LD_INT 1
71421: ARRAY
71422: PUSH
71423: EMPTY
71424: LIST
71425: PPUSH
71426: CALL_OW 1
71430: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71431: LD_VAR 0 3
71435: PUSH
71436: LD_INT 1
71438: ARRAY
71439: PPUSH
71440: LD_INT 125
71442: PPUSH
71443: CALL_OW 109
// end else
71447: GO 71633
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71449: LD_EXP 97
71453: PUSH
71454: LD_VAR 0 2
71458: ARRAY
71459: PUSH
71460: LD_INT 1
71462: ARRAY
71463: PPUSH
71464: CALL_OW 310
71468: IFFALSE 71491
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71470: LD_EXP 97
71474: PUSH
71475: LD_VAR 0 2
71479: ARRAY
71480: PUSH
71481: LD_INT 1
71483: ARRAY
71484: PPUSH
71485: CALL_OW 122
71489: GO 71633
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71491: LD_EXP 97
71495: PUSH
71496: LD_VAR 0 2
71500: ARRAY
71501: PUSH
71502: LD_INT 1
71504: ARRAY
71505: PPUSH
71506: CALL_OW 314
71510: NOT
71511: PUSH
71512: LD_EXP 97
71516: PUSH
71517: LD_VAR 0 2
71521: ARRAY
71522: PUSH
71523: LD_INT 1
71525: ARRAY
71526: PPUSH
71527: LD_EXP 96
71531: PUSH
71532: LD_VAR 0 2
71536: ARRAY
71537: PUSH
71538: LD_INT 1
71540: ARRAY
71541: PUSH
71542: LD_INT 1
71544: ARRAY
71545: PPUSH
71546: LD_EXP 96
71550: PUSH
71551: LD_VAR 0 2
71555: ARRAY
71556: PUSH
71557: LD_INT 1
71559: ARRAY
71560: PUSH
71561: LD_INT 2
71563: ARRAY
71564: PPUSH
71565: CALL_OW 297
71569: PUSH
71570: LD_INT 6
71572: GREATER
71573: AND
71574: IFFALSE 71633
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71576: LD_EXP 97
71580: PUSH
71581: LD_VAR 0 2
71585: ARRAY
71586: PUSH
71587: LD_INT 1
71589: ARRAY
71590: PPUSH
71591: LD_EXP 96
71595: PUSH
71596: LD_VAR 0 2
71600: ARRAY
71601: PUSH
71602: LD_INT 1
71604: ARRAY
71605: PUSH
71606: LD_INT 1
71608: ARRAY
71609: PPUSH
71610: LD_EXP 96
71614: PUSH
71615: LD_VAR 0 2
71619: ARRAY
71620: PUSH
71621: LD_INT 1
71623: ARRAY
71624: PUSH
71625: LD_INT 2
71627: ARRAY
71628: PPUSH
71629: CALL_OW 111
// end ; end ; end ;
71633: GO 71046
71635: POP
71636: POP
// end ;
71637: LD_VAR 0 1
71641: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71642: LD_INT 0
71644: PPUSH
71645: PPUSH
71646: PPUSH
71647: PPUSH
71648: PPUSH
71649: PPUSH
71650: PPUSH
71651: PPUSH
71652: PPUSH
71653: PPUSH
71654: PPUSH
// if not mc_bases then
71655: LD_EXP 59
71659: NOT
71660: IFFALSE 71664
// exit ;
71662: GO 72604
// for i = 1 to mc_bases do
71664: LD_ADDR_VAR 0 2
71668: PUSH
71669: DOUBLE
71670: LD_INT 1
71672: DEC
71673: ST_TO_ADDR
71674: LD_EXP 59
71678: PUSH
71679: FOR_TO
71680: IFFALSE 72602
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71682: LD_EXP 59
71686: PUSH
71687: LD_VAR 0 2
71691: ARRAY
71692: NOT
71693: PUSH
71694: LD_EXP 82
71698: PUSH
71699: LD_VAR 0 2
71703: ARRAY
71704: OR
71705: IFFALSE 71709
// continue ;
71707: GO 71679
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71709: LD_ADDR_VAR 0 7
71713: PUSH
71714: LD_EXP 59
71718: PUSH
71719: LD_VAR 0 2
71723: ARRAY
71724: PUSH
71725: LD_INT 1
71727: ARRAY
71728: PPUSH
71729: CALL_OW 248
71733: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71734: LD_VAR 0 7
71738: PUSH
71739: LD_INT 3
71741: EQUAL
71742: PUSH
71743: LD_EXP 78
71747: PUSH
71748: LD_VAR 0 2
71752: ARRAY
71753: PUSH
71754: LD_EXP 81
71758: PUSH
71759: LD_VAR 0 2
71763: ARRAY
71764: UNION
71765: PPUSH
71766: LD_INT 33
71768: PUSH
71769: LD_INT 2
71771: PUSH
71772: EMPTY
71773: LIST
71774: LIST
71775: PPUSH
71776: CALL_OW 72
71780: NOT
71781: OR
71782: IFFALSE 71786
// continue ;
71784: GO 71679
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71786: LD_ADDR_VAR 0 9
71790: PUSH
71791: LD_EXP 59
71795: PUSH
71796: LD_VAR 0 2
71800: ARRAY
71801: PPUSH
71802: LD_INT 30
71804: PUSH
71805: LD_INT 36
71807: PUSH
71808: EMPTY
71809: LIST
71810: LIST
71811: PPUSH
71812: CALL_OW 72
71816: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71817: LD_ADDR_VAR 0 10
71821: PUSH
71822: LD_EXP 78
71826: PUSH
71827: LD_VAR 0 2
71831: ARRAY
71832: PPUSH
71833: LD_INT 34
71835: PUSH
71836: LD_INT 31
71838: PUSH
71839: EMPTY
71840: LIST
71841: LIST
71842: PPUSH
71843: CALL_OW 72
71847: ST_TO_ADDR
// if not cts and not mcts then
71848: LD_VAR 0 9
71852: NOT
71853: PUSH
71854: LD_VAR 0 10
71858: NOT
71859: AND
71860: IFFALSE 71864
// continue ;
71862: GO 71679
// x := cts ;
71864: LD_ADDR_VAR 0 11
71868: PUSH
71869: LD_VAR 0 9
71873: ST_TO_ADDR
// if not x then
71874: LD_VAR 0 11
71878: NOT
71879: IFFALSE 71891
// x := mcts ;
71881: LD_ADDR_VAR 0 11
71885: PUSH
71886: LD_VAR 0 10
71890: ST_TO_ADDR
// if not x then
71891: LD_VAR 0 11
71895: NOT
71896: IFFALSE 71900
// continue ;
71898: GO 71679
// if mc_remote_driver [ i ] then
71900: LD_EXP 99
71904: PUSH
71905: LD_VAR 0 2
71909: ARRAY
71910: IFFALSE 72297
// for j in mc_remote_driver [ i ] do
71912: LD_ADDR_VAR 0 3
71916: PUSH
71917: LD_EXP 99
71921: PUSH
71922: LD_VAR 0 2
71926: ARRAY
71927: PUSH
71928: FOR_IN
71929: IFFALSE 72295
// begin if GetClass ( j ) <> 3 then
71931: LD_VAR 0 3
71935: PPUSH
71936: CALL_OW 257
71940: PUSH
71941: LD_INT 3
71943: NONEQUAL
71944: IFFALSE 71997
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
71946: LD_ADDR_EXP 99
71950: PUSH
71951: LD_EXP 99
71955: PPUSH
71956: LD_VAR 0 2
71960: PPUSH
71961: LD_EXP 99
71965: PUSH
71966: LD_VAR 0 2
71970: ARRAY
71971: PUSH
71972: LD_VAR 0 3
71976: DIFF
71977: PPUSH
71978: CALL_OW 1
71982: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71983: LD_VAR 0 3
71987: PPUSH
71988: LD_INT 0
71990: PPUSH
71991: CALL_OW 109
// continue ;
71995: GO 71928
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
71997: LD_EXP 78
72001: PUSH
72002: LD_VAR 0 2
72006: ARRAY
72007: PPUSH
72008: LD_INT 34
72010: PUSH
72011: LD_INT 31
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: LD_INT 58
72020: PUSH
72021: EMPTY
72022: LIST
72023: PUSH
72024: EMPTY
72025: LIST
72026: LIST
72027: PPUSH
72028: CALL_OW 72
72032: PUSH
72033: LD_VAR 0 3
72037: PPUSH
72038: CALL 47887 0 1
72042: NOT
72043: AND
72044: IFFALSE 72115
// begin if IsInUnit ( j ) then
72046: LD_VAR 0 3
72050: PPUSH
72051: CALL_OW 310
72055: IFFALSE 72066
// ComExitBuilding ( j ) ;
72057: LD_VAR 0 3
72061: PPUSH
72062: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72066: LD_VAR 0 3
72070: PPUSH
72071: LD_EXP 78
72075: PUSH
72076: LD_VAR 0 2
72080: ARRAY
72081: PPUSH
72082: LD_INT 34
72084: PUSH
72085: LD_INT 31
72087: PUSH
72088: EMPTY
72089: LIST
72090: LIST
72091: PUSH
72092: LD_INT 58
72094: PUSH
72095: EMPTY
72096: LIST
72097: PUSH
72098: EMPTY
72099: LIST
72100: LIST
72101: PPUSH
72102: CALL_OW 72
72106: PUSH
72107: LD_INT 1
72109: ARRAY
72110: PPUSH
72111: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72115: LD_VAR 0 3
72119: PPUSH
72120: CALL_OW 310
72124: NOT
72125: PUSH
72126: LD_VAR 0 3
72130: PPUSH
72131: CALL_OW 310
72135: PPUSH
72136: CALL_OW 266
72140: PUSH
72141: LD_INT 36
72143: NONEQUAL
72144: PUSH
72145: LD_VAR 0 3
72149: PPUSH
72150: CALL 47887 0 1
72154: NOT
72155: AND
72156: OR
72157: IFFALSE 72293
// begin if IsInUnit ( j ) then
72159: LD_VAR 0 3
72163: PPUSH
72164: CALL_OW 310
72168: IFFALSE 72179
// ComExitBuilding ( j ) ;
72170: LD_VAR 0 3
72174: PPUSH
72175: CALL_OW 122
// ct := 0 ;
72179: LD_ADDR_VAR 0 8
72183: PUSH
72184: LD_INT 0
72186: ST_TO_ADDR
// for k in x do
72187: LD_ADDR_VAR 0 4
72191: PUSH
72192: LD_VAR 0 11
72196: PUSH
72197: FOR_IN
72198: IFFALSE 72271
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72200: LD_VAR 0 4
72204: PPUSH
72205: CALL_OW 264
72209: PUSH
72210: LD_INT 31
72212: EQUAL
72213: PUSH
72214: LD_VAR 0 4
72218: PPUSH
72219: CALL_OW 311
72223: NOT
72224: AND
72225: PUSH
72226: LD_VAR 0 4
72230: PPUSH
72231: CALL_OW 266
72235: PUSH
72236: LD_INT 36
72238: EQUAL
72239: PUSH
72240: LD_VAR 0 4
72244: PPUSH
72245: CALL_OW 313
72249: PUSH
72250: LD_INT 3
72252: LESS
72253: AND
72254: OR
72255: IFFALSE 72269
// begin ct := k ;
72257: LD_ADDR_VAR 0 8
72261: PUSH
72262: LD_VAR 0 4
72266: ST_TO_ADDR
// break ;
72267: GO 72271
// end ;
72269: GO 72197
72271: POP
72272: POP
// if ct then
72273: LD_VAR 0 8
72277: IFFALSE 72293
// ComEnterUnit ( j , ct ) ;
72279: LD_VAR 0 3
72283: PPUSH
72284: LD_VAR 0 8
72288: PPUSH
72289: CALL_OW 120
// end ; end ;
72293: GO 71928
72295: POP
72296: POP
// places := 0 ;
72297: LD_ADDR_VAR 0 5
72301: PUSH
72302: LD_INT 0
72304: ST_TO_ADDR
// for j = 1 to x do
72305: LD_ADDR_VAR 0 3
72309: PUSH
72310: DOUBLE
72311: LD_INT 1
72313: DEC
72314: ST_TO_ADDR
72315: LD_VAR 0 11
72319: PUSH
72320: FOR_TO
72321: IFFALSE 72397
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72323: LD_VAR 0 11
72327: PUSH
72328: LD_VAR 0 3
72332: ARRAY
72333: PPUSH
72334: CALL_OW 264
72338: PUSH
72339: LD_INT 31
72341: EQUAL
72342: IFFALSE 72360
// places := places + 1 else
72344: LD_ADDR_VAR 0 5
72348: PUSH
72349: LD_VAR 0 5
72353: PUSH
72354: LD_INT 1
72356: PLUS
72357: ST_TO_ADDR
72358: GO 72395
// if GetBType ( x [ j ] ) = b_control_tower then
72360: LD_VAR 0 11
72364: PUSH
72365: LD_VAR 0 3
72369: ARRAY
72370: PPUSH
72371: CALL_OW 266
72375: PUSH
72376: LD_INT 36
72378: EQUAL
72379: IFFALSE 72395
// places := places + 3 ;
72381: LD_ADDR_VAR 0 5
72385: PUSH
72386: LD_VAR 0 5
72390: PUSH
72391: LD_INT 3
72393: PLUS
72394: ST_TO_ADDR
72395: GO 72320
72397: POP
72398: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72399: LD_VAR 0 5
72403: PUSH
72404: LD_INT 0
72406: EQUAL
72407: PUSH
72408: LD_VAR 0 5
72412: PUSH
72413: LD_EXP 99
72417: PUSH
72418: LD_VAR 0 2
72422: ARRAY
72423: LESSEQUAL
72424: OR
72425: IFFALSE 72429
// continue ;
72427: GO 71679
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72429: LD_ADDR_VAR 0 6
72433: PUSH
72434: LD_EXP 59
72438: PUSH
72439: LD_VAR 0 2
72443: ARRAY
72444: PPUSH
72445: LD_INT 25
72447: PUSH
72448: LD_INT 3
72450: PUSH
72451: EMPTY
72452: LIST
72453: LIST
72454: PPUSH
72455: CALL_OW 72
72459: PUSH
72460: LD_EXP 99
72464: PUSH
72465: LD_VAR 0 2
72469: ARRAY
72470: DIFF
72471: PPUSH
72472: LD_INT 3
72474: PPUSH
72475: CALL 48787 0 2
72479: ST_TO_ADDR
// for j in tmp do
72480: LD_ADDR_VAR 0 3
72484: PUSH
72485: LD_VAR 0 6
72489: PUSH
72490: FOR_IN
72491: IFFALSE 72526
// if GetTag ( j ) > 0 then
72493: LD_VAR 0 3
72497: PPUSH
72498: CALL_OW 110
72502: PUSH
72503: LD_INT 0
72505: GREATER
72506: IFFALSE 72524
// tmp := tmp diff j ;
72508: LD_ADDR_VAR 0 6
72512: PUSH
72513: LD_VAR 0 6
72517: PUSH
72518: LD_VAR 0 3
72522: DIFF
72523: ST_TO_ADDR
72524: GO 72490
72526: POP
72527: POP
// if not tmp then
72528: LD_VAR 0 6
72532: NOT
72533: IFFALSE 72537
// continue ;
72535: GO 71679
// if places then
72537: LD_VAR 0 5
72541: IFFALSE 72600
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72543: LD_ADDR_EXP 99
72547: PUSH
72548: LD_EXP 99
72552: PPUSH
72553: LD_VAR 0 2
72557: PPUSH
72558: LD_EXP 99
72562: PUSH
72563: LD_VAR 0 2
72567: ARRAY
72568: PUSH
72569: LD_VAR 0 6
72573: PUSH
72574: LD_INT 1
72576: ARRAY
72577: UNION
72578: PPUSH
72579: CALL_OW 1
72583: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72584: LD_VAR 0 6
72588: PUSH
72589: LD_INT 1
72591: ARRAY
72592: PPUSH
72593: LD_INT 126
72595: PPUSH
72596: CALL_OW 109
// end ; end ;
72600: GO 71679
72602: POP
72603: POP
// end ;
72604: LD_VAR 0 1
72608: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72609: LD_INT 0
72611: PPUSH
72612: PPUSH
72613: PPUSH
72614: PPUSH
72615: PPUSH
72616: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72617: LD_VAR 0 1
72621: NOT
72622: PUSH
72623: LD_VAR 0 2
72627: NOT
72628: OR
72629: PUSH
72630: LD_VAR 0 3
72634: NOT
72635: OR
72636: PUSH
72637: LD_VAR 0 4
72641: PUSH
72642: LD_INT 1
72644: PUSH
72645: LD_INT 2
72647: PUSH
72648: LD_INT 3
72650: PUSH
72651: LD_INT 4
72653: PUSH
72654: LD_INT 5
72656: PUSH
72657: LD_INT 8
72659: PUSH
72660: LD_INT 9
72662: PUSH
72663: LD_INT 15
72665: PUSH
72666: LD_INT 16
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: LIST
72677: LIST
72678: LIST
72679: IN
72680: NOT
72681: OR
72682: IFFALSE 72686
// exit ;
72684: GO 73586
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72686: LD_ADDR_VAR 0 2
72690: PUSH
72691: LD_VAR 0 2
72695: PPUSH
72696: LD_INT 21
72698: PUSH
72699: LD_INT 3
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 24
72708: PUSH
72709: LD_INT 250
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PPUSH
72720: CALL_OW 72
72724: ST_TO_ADDR
// case class of 1 , 15 :
72725: LD_VAR 0 4
72729: PUSH
72730: LD_INT 1
72732: DOUBLE
72733: EQUAL
72734: IFTRUE 72744
72736: LD_INT 15
72738: DOUBLE
72739: EQUAL
72740: IFTRUE 72744
72742: GO 72829
72744: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72745: LD_ADDR_VAR 0 8
72749: PUSH
72750: LD_VAR 0 2
72754: PPUSH
72755: LD_INT 2
72757: PUSH
72758: LD_INT 30
72760: PUSH
72761: LD_INT 32
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 30
72770: PUSH
72771: LD_INT 31
72773: PUSH
72774: EMPTY
72775: LIST
72776: LIST
72777: PUSH
72778: EMPTY
72779: LIST
72780: LIST
72781: LIST
72782: PPUSH
72783: CALL_OW 72
72787: PUSH
72788: LD_VAR 0 2
72792: PPUSH
72793: LD_INT 2
72795: PUSH
72796: LD_INT 30
72798: PUSH
72799: LD_INT 4
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 30
72808: PUSH
72809: LD_INT 5
72811: PUSH
72812: EMPTY
72813: LIST
72814: LIST
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: LIST
72820: PPUSH
72821: CALL_OW 72
72825: ADD
72826: ST_TO_ADDR
72827: GO 73075
72829: LD_INT 2
72831: DOUBLE
72832: EQUAL
72833: IFTRUE 72843
72835: LD_INT 16
72837: DOUBLE
72838: EQUAL
72839: IFTRUE 72843
72841: GO 72889
72843: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72844: LD_ADDR_VAR 0 8
72848: PUSH
72849: LD_VAR 0 2
72853: PPUSH
72854: LD_INT 2
72856: PUSH
72857: LD_INT 30
72859: PUSH
72860: LD_INT 0
72862: PUSH
72863: EMPTY
72864: LIST
72865: LIST
72866: PUSH
72867: LD_INT 30
72869: PUSH
72870: LD_INT 1
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: LIST
72881: PPUSH
72882: CALL_OW 72
72886: ST_TO_ADDR
72887: GO 73075
72889: LD_INT 3
72891: DOUBLE
72892: EQUAL
72893: IFTRUE 72897
72895: GO 72943
72897: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
72898: LD_ADDR_VAR 0 8
72902: PUSH
72903: LD_VAR 0 2
72907: PPUSH
72908: LD_INT 2
72910: PUSH
72911: LD_INT 30
72913: PUSH
72914: LD_INT 2
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: PUSH
72921: LD_INT 30
72923: PUSH
72924: LD_INT 3
72926: PUSH
72927: EMPTY
72928: LIST
72929: LIST
72930: PUSH
72931: EMPTY
72932: LIST
72933: LIST
72934: LIST
72935: PPUSH
72936: CALL_OW 72
72940: ST_TO_ADDR
72941: GO 73075
72943: LD_INT 4
72945: DOUBLE
72946: EQUAL
72947: IFTRUE 72951
72949: GO 73008
72951: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
72952: LD_ADDR_VAR 0 8
72956: PUSH
72957: LD_VAR 0 2
72961: PPUSH
72962: LD_INT 2
72964: PUSH
72965: LD_INT 30
72967: PUSH
72968: LD_INT 6
72970: PUSH
72971: EMPTY
72972: LIST
72973: LIST
72974: PUSH
72975: LD_INT 30
72977: PUSH
72978: LD_INT 7
72980: PUSH
72981: EMPTY
72982: LIST
72983: LIST
72984: PUSH
72985: LD_INT 30
72987: PUSH
72988: LD_INT 8
72990: PUSH
72991: EMPTY
72992: LIST
72993: LIST
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: LIST
72999: LIST
73000: PPUSH
73001: CALL_OW 72
73005: ST_TO_ADDR
73006: GO 73075
73008: LD_INT 5
73010: DOUBLE
73011: EQUAL
73012: IFTRUE 73028
73014: LD_INT 8
73016: DOUBLE
73017: EQUAL
73018: IFTRUE 73028
73020: LD_INT 9
73022: DOUBLE
73023: EQUAL
73024: IFTRUE 73028
73026: GO 73074
73028: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73029: LD_ADDR_VAR 0 8
73033: PUSH
73034: LD_VAR 0 2
73038: PPUSH
73039: LD_INT 2
73041: PUSH
73042: LD_INT 30
73044: PUSH
73045: LD_INT 4
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: PUSH
73052: LD_INT 30
73054: PUSH
73055: LD_INT 5
73057: PUSH
73058: EMPTY
73059: LIST
73060: LIST
73061: PUSH
73062: EMPTY
73063: LIST
73064: LIST
73065: LIST
73066: PPUSH
73067: CALL_OW 72
73071: ST_TO_ADDR
73072: GO 73075
73074: POP
// if not tmp then
73075: LD_VAR 0 8
73079: NOT
73080: IFFALSE 73084
// exit ;
73082: GO 73586
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73084: LD_VAR 0 4
73088: PUSH
73089: LD_INT 1
73091: PUSH
73092: LD_INT 15
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: IN
73099: PUSH
73100: LD_EXP 68
73104: PUSH
73105: LD_VAR 0 1
73109: ARRAY
73110: AND
73111: IFFALSE 73267
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73113: LD_ADDR_VAR 0 9
73117: PUSH
73118: LD_EXP 68
73122: PUSH
73123: LD_VAR 0 1
73127: ARRAY
73128: PUSH
73129: LD_INT 1
73131: ARRAY
73132: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73133: LD_VAR 0 9
73137: PUSH
73138: LD_EXP 69
73142: PUSH
73143: LD_VAR 0 1
73147: ARRAY
73148: IN
73149: NOT
73150: IFFALSE 73265
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73152: LD_ADDR_EXP 69
73156: PUSH
73157: LD_EXP 69
73161: PPUSH
73162: LD_VAR 0 1
73166: PUSH
73167: LD_EXP 69
73171: PUSH
73172: LD_VAR 0 1
73176: ARRAY
73177: PUSH
73178: LD_INT 1
73180: PLUS
73181: PUSH
73182: EMPTY
73183: LIST
73184: LIST
73185: PPUSH
73186: LD_VAR 0 9
73190: PPUSH
73191: CALL 19238 0 3
73195: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73196: LD_ADDR_EXP 68
73200: PUSH
73201: LD_EXP 68
73205: PPUSH
73206: LD_VAR 0 1
73210: PPUSH
73211: LD_EXP 68
73215: PUSH
73216: LD_VAR 0 1
73220: ARRAY
73221: PUSH
73222: LD_VAR 0 9
73226: DIFF
73227: PPUSH
73228: CALL_OW 1
73232: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73233: LD_VAR 0 3
73237: PPUSH
73238: LD_EXP 69
73242: PUSH
73243: LD_VAR 0 1
73247: ARRAY
73248: PUSH
73249: LD_EXP 69
73253: PUSH
73254: LD_VAR 0 1
73258: ARRAY
73259: ARRAY
73260: PPUSH
73261: CALL_OW 120
// end ; exit ;
73265: GO 73586
// end ; if tmp > 1 then
73267: LD_VAR 0 8
73271: PUSH
73272: LD_INT 1
73274: GREATER
73275: IFFALSE 73379
// for i = 2 to tmp do
73277: LD_ADDR_VAR 0 6
73281: PUSH
73282: DOUBLE
73283: LD_INT 2
73285: DEC
73286: ST_TO_ADDR
73287: LD_VAR 0 8
73291: PUSH
73292: FOR_TO
73293: IFFALSE 73377
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73295: LD_VAR 0 8
73299: PUSH
73300: LD_VAR 0 6
73304: ARRAY
73305: PPUSH
73306: CALL_OW 461
73310: PUSH
73311: LD_INT 6
73313: EQUAL
73314: IFFALSE 73375
// begin x := tmp [ i ] ;
73316: LD_ADDR_VAR 0 9
73320: PUSH
73321: LD_VAR 0 8
73325: PUSH
73326: LD_VAR 0 6
73330: ARRAY
73331: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73332: LD_ADDR_VAR 0 8
73336: PUSH
73337: LD_VAR 0 8
73341: PPUSH
73342: LD_VAR 0 6
73346: PPUSH
73347: CALL_OW 3
73351: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73352: LD_ADDR_VAR 0 8
73356: PUSH
73357: LD_VAR 0 8
73361: PPUSH
73362: LD_INT 1
73364: PPUSH
73365: LD_VAR 0 9
73369: PPUSH
73370: CALL_OW 2
73374: ST_TO_ADDR
// end ;
73375: GO 73292
73377: POP
73378: POP
// for i in tmp do
73379: LD_ADDR_VAR 0 6
73383: PUSH
73384: LD_VAR 0 8
73388: PUSH
73389: FOR_IN
73390: IFFALSE 73459
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73392: LD_VAR 0 6
73396: PPUSH
73397: CALL_OW 313
73401: PUSH
73402: LD_INT 6
73404: LESS
73405: PUSH
73406: LD_VAR 0 6
73410: PPUSH
73411: CALL_OW 266
73415: PUSH
73416: LD_INT 31
73418: PUSH
73419: LD_INT 32
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: IN
73426: NOT
73427: AND
73428: PUSH
73429: LD_VAR 0 6
73433: PPUSH
73434: CALL_OW 313
73438: PUSH
73439: LD_INT 0
73441: EQUAL
73442: OR
73443: IFFALSE 73457
// begin j := i ;
73445: LD_ADDR_VAR 0 7
73449: PUSH
73450: LD_VAR 0 6
73454: ST_TO_ADDR
// break ;
73455: GO 73459
// end ; end ;
73457: GO 73389
73459: POP
73460: POP
// if j then
73461: LD_VAR 0 7
73465: IFFALSE 73483
// ComEnterUnit ( unit , j ) else
73467: LD_VAR 0 3
73471: PPUSH
73472: LD_VAR 0 7
73476: PPUSH
73477: CALL_OW 120
73481: GO 73586
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73483: LD_ADDR_VAR 0 10
73487: PUSH
73488: LD_VAR 0 2
73492: PPUSH
73493: LD_INT 2
73495: PUSH
73496: LD_INT 30
73498: PUSH
73499: LD_INT 0
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 30
73508: PUSH
73509: LD_INT 1
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: EMPTY
73517: LIST
73518: LIST
73519: LIST
73520: PPUSH
73521: CALL_OW 72
73525: ST_TO_ADDR
// if depot then
73526: LD_VAR 0 10
73530: IFFALSE 73586
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73532: LD_ADDR_VAR 0 10
73536: PUSH
73537: LD_VAR 0 10
73541: PPUSH
73542: LD_VAR 0 3
73546: PPUSH
73547: CALL_OW 74
73551: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73552: LD_VAR 0 3
73556: PPUSH
73557: LD_VAR 0 10
73561: PPUSH
73562: CALL_OW 296
73566: PUSH
73567: LD_INT 10
73569: GREATER
73570: IFFALSE 73586
// ComStandNearbyBuilding ( unit , depot ) ;
73572: LD_VAR 0 3
73576: PPUSH
73577: LD_VAR 0 10
73581: PPUSH
73582: CALL 15852 0 2
// end ; end ; end ;
73586: LD_VAR 0 5
73590: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73591: LD_INT 0
73593: PPUSH
73594: PPUSH
73595: PPUSH
73596: PPUSH
// if not mc_bases then
73597: LD_EXP 59
73601: NOT
73602: IFFALSE 73606
// exit ;
73604: GO 73845
// for i = 1 to mc_bases do
73606: LD_ADDR_VAR 0 2
73610: PUSH
73611: DOUBLE
73612: LD_INT 1
73614: DEC
73615: ST_TO_ADDR
73616: LD_EXP 59
73620: PUSH
73621: FOR_TO
73622: IFFALSE 73843
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73624: LD_ADDR_VAR 0 4
73628: PUSH
73629: LD_EXP 59
73633: PUSH
73634: LD_VAR 0 2
73638: ARRAY
73639: PPUSH
73640: LD_INT 21
73642: PUSH
73643: LD_INT 1
73645: PUSH
73646: EMPTY
73647: LIST
73648: LIST
73649: PPUSH
73650: CALL_OW 72
73654: PUSH
73655: LD_EXP 88
73659: PUSH
73660: LD_VAR 0 2
73664: ARRAY
73665: UNION
73666: ST_TO_ADDR
// if not tmp then
73667: LD_VAR 0 4
73671: NOT
73672: IFFALSE 73676
// continue ;
73674: GO 73621
// for j in tmp do
73676: LD_ADDR_VAR 0 3
73680: PUSH
73681: LD_VAR 0 4
73685: PUSH
73686: FOR_IN
73687: IFFALSE 73839
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73689: LD_VAR 0 3
73693: PPUSH
73694: CALL_OW 110
73698: NOT
73699: PUSH
73700: LD_VAR 0 3
73704: PPUSH
73705: CALL_OW 314
73709: NOT
73710: AND
73711: PUSH
73712: LD_VAR 0 3
73716: PPUSH
73717: CALL_OW 311
73721: NOT
73722: AND
73723: PUSH
73724: LD_VAR 0 3
73728: PPUSH
73729: CALL_OW 310
73733: NOT
73734: AND
73735: PUSH
73736: LD_VAR 0 3
73740: PUSH
73741: LD_EXP 62
73745: PUSH
73746: LD_VAR 0 2
73750: ARRAY
73751: PUSH
73752: LD_INT 1
73754: ARRAY
73755: IN
73756: NOT
73757: AND
73758: PUSH
73759: LD_VAR 0 3
73763: PUSH
73764: LD_EXP 62
73768: PUSH
73769: LD_VAR 0 2
73773: ARRAY
73774: PUSH
73775: LD_INT 2
73777: ARRAY
73778: IN
73779: NOT
73780: AND
73781: PUSH
73782: LD_VAR 0 3
73786: PUSH
73787: LD_EXP 71
73791: PUSH
73792: LD_VAR 0 2
73796: ARRAY
73797: IN
73798: NOT
73799: AND
73800: IFFALSE 73837
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73802: LD_VAR 0 2
73806: PPUSH
73807: LD_EXP 59
73811: PUSH
73812: LD_VAR 0 2
73816: ARRAY
73817: PPUSH
73818: LD_VAR 0 3
73822: PPUSH
73823: LD_VAR 0 3
73827: PPUSH
73828: CALL_OW 257
73832: PPUSH
73833: CALL 72609 0 4
// end ;
73837: GO 73686
73839: POP
73840: POP
// end ;
73841: GO 73621
73843: POP
73844: POP
// end ;
73845: LD_VAR 0 1
73849: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73850: LD_INT 0
73852: PPUSH
73853: PPUSH
73854: PPUSH
73855: PPUSH
73856: PPUSH
73857: PPUSH
// if not mc_bases [ base ] then
73858: LD_EXP 59
73862: PUSH
73863: LD_VAR 0 1
73867: ARRAY
73868: NOT
73869: IFFALSE 73873
// exit ;
73871: GO 74055
// tmp := [ ] ;
73873: LD_ADDR_VAR 0 6
73877: PUSH
73878: EMPTY
73879: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73880: LD_ADDR_VAR 0 7
73884: PUSH
73885: LD_VAR 0 3
73889: PPUSH
73890: LD_INT 0
73892: PPUSH
73893: CALL_OW 517
73897: ST_TO_ADDR
// if not list then
73898: LD_VAR 0 7
73902: NOT
73903: IFFALSE 73907
// exit ;
73905: GO 74055
// for i = 1 to amount do
73907: LD_ADDR_VAR 0 5
73911: PUSH
73912: DOUBLE
73913: LD_INT 1
73915: DEC
73916: ST_TO_ADDR
73917: LD_VAR 0 2
73921: PUSH
73922: FOR_TO
73923: IFFALSE 74003
// begin x := rand ( 1 , list [ 1 ] ) ;
73925: LD_ADDR_VAR 0 8
73929: PUSH
73930: LD_INT 1
73932: PPUSH
73933: LD_VAR 0 7
73937: PUSH
73938: LD_INT 1
73940: ARRAY
73941: PPUSH
73942: CALL_OW 12
73946: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
73947: LD_ADDR_VAR 0 6
73951: PUSH
73952: LD_VAR 0 6
73956: PPUSH
73957: LD_VAR 0 5
73961: PPUSH
73962: LD_VAR 0 7
73966: PUSH
73967: LD_INT 1
73969: ARRAY
73970: PUSH
73971: LD_VAR 0 8
73975: ARRAY
73976: PUSH
73977: LD_VAR 0 7
73981: PUSH
73982: LD_INT 2
73984: ARRAY
73985: PUSH
73986: LD_VAR 0 8
73990: ARRAY
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: PPUSH
73996: CALL_OW 1
74000: ST_TO_ADDR
// end ;
74001: GO 73922
74003: POP
74004: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74005: LD_ADDR_EXP 72
74009: PUSH
74010: LD_EXP 72
74014: PPUSH
74015: LD_VAR 0 1
74019: PPUSH
74020: LD_VAR 0 6
74024: PPUSH
74025: CALL_OW 1
74029: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74030: LD_ADDR_EXP 74
74034: PUSH
74035: LD_EXP 74
74039: PPUSH
74040: LD_VAR 0 1
74044: PPUSH
74045: LD_VAR 0 3
74049: PPUSH
74050: CALL_OW 1
74054: ST_TO_ADDR
// end ;
74055: LD_VAR 0 4
74059: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74060: LD_INT 0
74062: PPUSH
// if not mc_bases [ base ] then
74063: LD_EXP 59
74067: PUSH
74068: LD_VAR 0 1
74072: ARRAY
74073: NOT
74074: IFFALSE 74078
// exit ;
74076: GO 74103
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74078: LD_ADDR_EXP 64
74082: PUSH
74083: LD_EXP 64
74087: PPUSH
74088: LD_VAR 0 1
74092: PPUSH
74093: LD_VAR 0 2
74097: PPUSH
74098: CALL_OW 1
74102: ST_TO_ADDR
// end ;
74103: LD_VAR 0 3
74107: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74108: LD_INT 0
74110: PPUSH
// if not mc_bases [ base ] then
74111: LD_EXP 59
74115: PUSH
74116: LD_VAR 0 1
74120: ARRAY
74121: NOT
74122: IFFALSE 74126
// exit ;
74124: GO 74163
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74126: LD_ADDR_EXP 64
74130: PUSH
74131: LD_EXP 64
74135: PPUSH
74136: LD_VAR 0 1
74140: PPUSH
74141: LD_EXP 64
74145: PUSH
74146: LD_VAR 0 1
74150: ARRAY
74151: PUSH
74152: LD_VAR 0 2
74156: UNION
74157: PPUSH
74158: CALL_OW 1
74162: ST_TO_ADDR
// end ;
74163: LD_VAR 0 3
74167: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74168: LD_INT 0
74170: PPUSH
// if not mc_bases [ base ] then
74171: LD_EXP 59
74175: PUSH
74176: LD_VAR 0 1
74180: ARRAY
74181: NOT
74182: IFFALSE 74186
// exit ;
74184: GO 74211
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74186: LD_ADDR_EXP 80
74190: PUSH
74191: LD_EXP 80
74195: PPUSH
74196: LD_VAR 0 1
74200: PPUSH
74201: LD_VAR 0 2
74205: PPUSH
74206: CALL_OW 1
74210: ST_TO_ADDR
// end ;
74211: LD_VAR 0 3
74215: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74216: LD_INT 0
74218: PPUSH
// if not mc_bases [ base ] then
74219: LD_EXP 59
74223: PUSH
74224: LD_VAR 0 1
74228: ARRAY
74229: NOT
74230: IFFALSE 74234
// exit ;
74232: GO 74271
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74234: LD_ADDR_EXP 80
74238: PUSH
74239: LD_EXP 80
74243: PPUSH
74244: LD_VAR 0 1
74248: PPUSH
74249: LD_EXP 80
74253: PUSH
74254: LD_VAR 0 1
74258: ARRAY
74259: PUSH
74260: LD_VAR 0 2
74264: ADD
74265: PPUSH
74266: CALL_OW 1
74270: ST_TO_ADDR
// end ;
74271: LD_VAR 0 3
74275: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74276: LD_INT 0
74278: PPUSH
// if not mc_bases [ base ] then
74279: LD_EXP 59
74283: PUSH
74284: LD_VAR 0 1
74288: ARRAY
74289: NOT
74290: IFFALSE 74294
// exit ;
74292: GO 74348
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74294: LD_ADDR_EXP 81
74298: PUSH
74299: LD_EXP 81
74303: PPUSH
74304: LD_VAR 0 1
74308: PPUSH
74309: LD_VAR 0 2
74313: PPUSH
74314: CALL_OW 1
74318: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74319: LD_ADDR_EXP 70
74323: PUSH
74324: LD_EXP 70
74328: PPUSH
74329: LD_VAR 0 1
74333: PPUSH
74334: LD_VAR 0 2
74338: PUSH
74339: LD_INT 0
74341: PLUS
74342: PPUSH
74343: CALL_OW 1
74347: ST_TO_ADDR
// end ;
74348: LD_VAR 0 3
74352: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74353: LD_INT 0
74355: PPUSH
// if not mc_bases [ base ] then
74356: LD_EXP 59
74360: PUSH
74361: LD_VAR 0 1
74365: ARRAY
74366: NOT
74367: IFFALSE 74371
// exit ;
74369: GO 74396
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74371: LD_ADDR_EXP 70
74375: PUSH
74376: LD_EXP 70
74380: PPUSH
74381: LD_VAR 0 1
74385: PPUSH
74386: LD_VAR 0 2
74390: PPUSH
74391: CALL_OW 1
74395: ST_TO_ADDR
// end ;
74396: LD_VAR 0 3
74400: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74401: LD_INT 0
74403: PPUSH
74404: PPUSH
74405: PPUSH
74406: PPUSH
// if not mc_bases [ base ] then
74407: LD_EXP 59
74411: PUSH
74412: LD_VAR 0 1
74416: ARRAY
74417: NOT
74418: IFFALSE 74422
// exit ;
74420: GO 74487
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74422: LD_ADDR_EXP 79
74426: PUSH
74427: LD_EXP 79
74431: PPUSH
74432: LD_VAR 0 1
74436: PUSH
74437: LD_EXP 79
74441: PUSH
74442: LD_VAR 0 1
74446: ARRAY
74447: PUSH
74448: LD_INT 1
74450: PLUS
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PPUSH
74456: LD_VAR 0 1
74460: PUSH
74461: LD_VAR 0 2
74465: PUSH
74466: LD_VAR 0 3
74470: PUSH
74471: LD_VAR 0 4
74475: PUSH
74476: EMPTY
74477: LIST
74478: LIST
74479: LIST
74480: LIST
74481: PPUSH
74482: CALL 19238 0 3
74486: ST_TO_ADDR
// end ;
74487: LD_VAR 0 5
74491: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74492: LD_INT 0
74494: PPUSH
// if not mc_bases [ base ] then
74495: LD_EXP 59
74499: PUSH
74500: LD_VAR 0 1
74504: ARRAY
74505: NOT
74506: IFFALSE 74510
// exit ;
74508: GO 74535
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74510: LD_ADDR_EXP 96
74514: PUSH
74515: LD_EXP 96
74519: PPUSH
74520: LD_VAR 0 1
74524: PPUSH
74525: LD_VAR 0 2
74529: PPUSH
74530: CALL_OW 1
74534: ST_TO_ADDR
// end ;
74535: LD_VAR 0 3
74539: RET
// export function MC_GetMinesField ( base ) ; begin
74540: LD_INT 0
74542: PPUSH
// result := mc_mines [ base ] ;
74543: LD_ADDR_VAR 0 2
74547: PUSH
74548: LD_EXP 72
74552: PUSH
74553: LD_VAR 0 1
74557: ARRAY
74558: ST_TO_ADDR
// end ;
74559: LD_VAR 0 2
74563: RET
// export function MC_GetProduceList ( base ) ; begin
74564: LD_INT 0
74566: PPUSH
// result := mc_produce [ base ] ;
74567: LD_ADDR_VAR 0 2
74571: PUSH
74572: LD_EXP 80
74576: PUSH
74577: LD_VAR 0 1
74581: ARRAY
74582: ST_TO_ADDR
// end ;
74583: LD_VAR 0 2
74587: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74588: LD_INT 0
74590: PPUSH
74591: PPUSH
// if not mc_bases then
74592: LD_EXP 59
74596: NOT
74597: IFFALSE 74601
// exit ;
74599: GO 74666
// if mc_bases [ base ] then
74601: LD_EXP 59
74605: PUSH
74606: LD_VAR 0 1
74610: ARRAY
74611: IFFALSE 74666
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74613: LD_ADDR_VAR 0 3
74617: PUSH
74618: LD_EXP 59
74622: PUSH
74623: LD_VAR 0 1
74627: ARRAY
74628: PPUSH
74629: LD_INT 30
74631: PUSH
74632: LD_VAR 0 2
74636: PUSH
74637: EMPTY
74638: LIST
74639: LIST
74640: PPUSH
74641: CALL_OW 72
74645: ST_TO_ADDR
// if result then
74646: LD_VAR 0 3
74650: IFFALSE 74666
// result := result [ 1 ] ;
74652: LD_ADDR_VAR 0 3
74656: PUSH
74657: LD_VAR 0 3
74661: PUSH
74662: LD_INT 1
74664: ARRAY
74665: ST_TO_ADDR
// end ; end ;
74666: LD_VAR 0 3
74670: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74671: LD_INT 0
74673: PPUSH
74674: PPUSH
// if not mc_bases then
74675: LD_EXP 59
74679: NOT
74680: IFFALSE 74684
// exit ;
74682: GO 74729
// if mc_bases [ base ] then
74684: LD_EXP 59
74688: PUSH
74689: LD_VAR 0 1
74693: ARRAY
74694: IFFALSE 74729
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74696: LD_ADDR_VAR 0 3
74700: PUSH
74701: LD_EXP 59
74705: PUSH
74706: LD_VAR 0 1
74710: ARRAY
74711: PPUSH
74712: LD_INT 30
74714: PUSH
74715: LD_VAR 0 2
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PPUSH
74724: CALL_OW 72
74728: ST_TO_ADDR
// end ;
74729: LD_VAR 0 3
74733: RET
// export function MC_SetTame ( base , area ) ; begin
74734: LD_INT 0
74736: PPUSH
// if not mc_bases or not base then
74737: LD_EXP 59
74741: NOT
74742: PUSH
74743: LD_VAR 0 1
74747: NOT
74748: OR
74749: IFFALSE 74753
// exit ;
74751: GO 74778
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74753: LD_ADDR_EXP 87
74757: PUSH
74758: LD_EXP 87
74762: PPUSH
74763: LD_VAR 0 1
74767: PPUSH
74768: LD_VAR 0 2
74772: PPUSH
74773: CALL_OW 1
74777: ST_TO_ADDR
// end ;
74778: LD_VAR 0 3
74782: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74783: LD_INT 0
74785: PPUSH
74786: PPUSH
// if not mc_bases or not base then
74787: LD_EXP 59
74791: NOT
74792: PUSH
74793: LD_VAR 0 1
74797: NOT
74798: OR
74799: IFFALSE 74803
// exit ;
74801: GO 74905
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74803: LD_ADDR_VAR 0 4
74807: PUSH
74808: LD_EXP 59
74812: PUSH
74813: LD_VAR 0 1
74817: ARRAY
74818: PPUSH
74819: LD_INT 30
74821: PUSH
74822: LD_VAR 0 2
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PPUSH
74831: CALL_OW 72
74835: ST_TO_ADDR
// if not tmp then
74836: LD_VAR 0 4
74840: NOT
74841: IFFALSE 74845
// exit ;
74843: GO 74905
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74845: LD_ADDR_EXP 91
74849: PUSH
74850: LD_EXP 91
74854: PPUSH
74855: LD_VAR 0 1
74859: PPUSH
74860: LD_EXP 91
74864: PUSH
74865: LD_VAR 0 1
74869: ARRAY
74870: PPUSH
74871: LD_EXP 91
74875: PUSH
74876: LD_VAR 0 1
74880: ARRAY
74881: PUSH
74882: LD_INT 1
74884: PLUS
74885: PPUSH
74886: LD_VAR 0 4
74890: PUSH
74891: LD_INT 1
74893: ARRAY
74894: PPUSH
74895: CALL_OW 2
74899: PPUSH
74900: CALL_OW 1
74904: ST_TO_ADDR
// end ;
74905: LD_VAR 0 3
74909: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
74910: LD_INT 0
74912: PPUSH
74913: PPUSH
// if not mc_bases or not base or not kinds then
74914: LD_EXP 59
74918: NOT
74919: PUSH
74920: LD_VAR 0 1
74924: NOT
74925: OR
74926: PUSH
74927: LD_VAR 0 2
74931: NOT
74932: OR
74933: IFFALSE 74937
// exit ;
74935: GO 74998
// for i in kinds do
74937: LD_ADDR_VAR 0 4
74941: PUSH
74942: LD_VAR 0 2
74946: PUSH
74947: FOR_IN
74948: IFFALSE 74996
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
74950: LD_ADDR_EXP 93
74954: PUSH
74955: LD_EXP 93
74959: PPUSH
74960: LD_VAR 0 1
74964: PUSH
74965: LD_EXP 93
74969: PUSH
74970: LD_VAR 0 1
74974: ARRAY
74975: PUSH
74976: LD_INT 1
74978: PLUS
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PPUSH
74984: LD_VAR 0 4
74988: PPUSH
74989: CALL 19238 0 3
74993: ST_TO_ADDR
74994: GO 74947
74996: POP
74997: POP
// end ;
74998: LD_VAR 0 3
75002: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75003: LD_INT 0
75005: PPUSH
// if not mc_bases or not base or not areas then
75006: LD_EXP 59
75010: NOT
75011: PUSH
75012: LD_VAR 0 1
75016: NOT
75017: OR
75018: PUSH
75019: LD_VAR 0 2
75023: NOT
75024: OR
75025: IFFALSE 75029
// exit ;
75027: GO 75054
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75029: LD_ADDR_EXP 77
75033: PUSH
75034: LD_EXP 77
75038: PPUSH
75039: LD_VAR 0 1
75043: PPUSH
75044: LD_VAR 0 2
75048: PPUSH
75049: CALL_OW 1
75053: ST_TO_ADDR
// end ;
75054: LD_VAR 0 3
75058: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75059: LD_INT 0
75061: PPUSH
// if not mc_bases or not base or not teleports_exit then
75062: LD_EXP 59
75066: NOT
75067: PUSH
75068: LD_VAR 0 1
75072: NOT
75073: OR
75074: PUSH
75075: LD_VAR 0 2
75079: NOT
75080: OR
75081: IFFALSE 75085
// exit ;
75083: GO 75110
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75085: LD_ADDR_EXP 94
75089: PUSH
75090: LD_EXP 94
75094: PPUSH
75095: LD_VAR 0 1
75099: PPUSH
75100: LD_VAR 0 2
75104: PPUSH
75105: CALL_OW 1
75109: ST_TO_ADDR
// end ;
75110: LD_VAR 0 3
75114: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75115: LD_INT 0
75117: PPUSH
75118: PPUSH
75119: PPUSH
// if not mc_bases or not base or not ext_list then
75120: LD_EXP 59
75124: NOT
75125: PUSH
75126: LD_VAR 0 1
75130: NOT
75131: OR
75132: PUSH
75133: LD_VAR 0 5
75137: NOT
75138: OR
75139: IFFALSE 75143
// exit ;
75141: GO 75316
// tmp := GetFacExtXYD ( x , y , d ) ;
75143: LD_ADDR_VAR 0 8
75147: PUSH
75148: LD_VAR 0 2
75152: PPUSH
75153: LD_VAR 0 3
75157: PPUSH
75158: LD_VAR 0 4
75162: PPUSH
75163: CALL 47917 0 3
75167: ST_TO_ADDR
// if not tmp then
75168: LD_VAR 0 8
75172: NOT
75173: IFFALSE 75177
// exit ;
75175: GO 75316
// for i in tmp do
75177: LD_ADDR_VAR 0 7
75181: PUSH
75182: LD_VAR 0 8
75186: PUSH
75187: FOR_IN
75188: IFFALSE 75314
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75190: LD_ADDR_EXP 64
75194: PUSH
75195: LD_EXP 64
75199: PPUSH
75200: LD_VAR 0 1
75204: PPUSH
75205: LD_EXP 64
75209: PUSH
75210: LD_VAR 0 1
75214: ARRAY
75215: PPUSH
75216: LD_EXP 64
75220: PUSH
75221: LD_VAR 0 1
75225: ARRAY
75226: PUSH
75227: LD_INT 1
75229: PLUS
75230: PPUSH
75231: LD_VAR 0 5
75235: PUSH
75236: LD_INT 1
75238: ARRAY
75239: PUSH
75240: LD_VAR 0 7
75244: PUSH
75245: LD_INT 1
75247: ARRAY
75248: PUSH
75249: LD_VAR 0 7
75253: PUSH
75254: LD_INT 2
75256: ARRAY
75257: PUSH
75258: LD_VAR 0 7
75262: PUSH
75263: LD_INT 3
75265: ARRAY
75266: PUSH
75267: EMPTY
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: PPUSH
75273: CALL_OW 2
75277: PPUSH
75278: CALL_OW 1
75282: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75283: LD_ADDR_VAR 0 5
75287: PUSH
75288: LD_VAR 0 5
75292: PPUSH
75293: LD_INT 1
75295: PPUSH
75296: CALL_OW 3
75300: ST_TO_ADDR
// if not ext_list then
75301: LD_VAR 0 5
75305: NOT
75306: IFFALSE 75312
// exit ;
75308: POP
75309: POP
75310: GO 75316
// end ;
75312: GO 75187
75314: POP
75315: POP
// end ;
75316: LD_VAR 0 6
75320: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75321: LD_INT 0
75323: PPUSH
// if not mc_bases or not base or not weapon_list then
75324: LD_EXP 59
75328: NOT
75329: PUSH
75330: LD_VAR 0 1
75334: NOT
75335: OR
75336: PUSH
75337: LD_VAR 0 2
75341: NOT
75342: OR
75343: IFFALSE 75347
// exit ;
75345: GO 75372
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75347: LD_ADDR_EXP 98
75351: PUSH
75352: LD_EXP 98
75356: PPUSH
75357: LD_VAR 0 1
75361: PPUSH
75362: LD_VAR 0 2
75366: PPUSH
75367: CALL_OW 1
75371: ST_TO_ADDR
// end ;
75372: LD_VAR 0 3
75376: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75377: LD_INT 0
75379: PPUSH
// if not mc_bases or not base or not tech_list then
75380: LD_EXP 59
75384: NOT
75385: PUSH
75386: LD_VAR 0 1
75390: NOT
75391: OR
75392: PUSH
75393: LD_VAR 0 2
75397: NOT
75398: OR
75399: IFFALSE 75403
// exit ;
75401: GO 75428
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75403: LD_ADDR_EXP 86
75407: PUSH
75408: LD_EXP 86
75412: PPUSH
75413: LD_VAR 0 1
75417: PPUSH
75418: LD_VAR 0 2
75422: PPUSH
75423: CALL_OW 1
75427: ST_TO_ADDR
// end ;
75428: LD_VAR 0 3
75432: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75433: LD_INT 0
75435: PPUSH
// if not mc_bases or not parking_area or not base then
75436: LD_EXP 59
75440: NOT
75441: PUSH
75442: LD_VAR 0 2
75446: NOT
75447: OR
75448: PUSH
75449: LD_VAR 0 1
75453: NOT
75454: OR
75455: IFFALSE 75459
// exit ;
75457: GO 75484
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75459: LD_ADDR_EXP 83
75463: PUSH
75464: LD_EXP 83
75468: PPUSH
75469: LD_VAR 0 1
75473: PPUSH
75474: LD_VAR 0 2
75478: PPUSH
75479: CALL_OW 1
75483: ST_TO_ADDR
// end ;
75484: LD_VAR 0 3
75488: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75489: LD_INT 0
75491: PPUSH
// if not mc_bases or not base or not scan_area then
75492: LD_EXP 59
75496: NOT
75497: PUSH
75498: LD_VAR 0 1
75502: NOT
75503: OR
75504: PUSH
75505: LD_VAR 0 2
75509: NOT
75510: OR
75511: IFFALSE 75515
// exit ;
75513: GO 75540
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75515: LD_ADDR_EXP 84
75519: PUSH
75520: LD_EXP 84
75524: PPUSH
75525: LD_VAR 0 1
75529: PPUSH
75530: LD_VAR 0 2
75534: PPUSH
75535: CALL_OW 1
75539: ST_TO_ADDR
// end ;
75540: LD_VAR 0 3
75544: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75545: LD_INT 0
75547: PPUSH
75548: PPUSH
// if not mc_bases or not base then
75549: LD_EXP 59
75553: NOT
75554: PUSH
75555: LD_VAR 0 1
75559: NOT
75560: OR
75561: IFFALSE 75565
// exit ;
75563: GO 75629
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75565: LD_ADDR_VAR 0 3
75569: PUSH
75570: LD_INT 1
75572: PUSH
75573: LD_INT 2
75575: PUSH
75576: LD_INT 3
75578: PUSH
75579: LD_INT 4
75581: PUSH
75582: LD_INT 11
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: LIST
75589: LIST
75590: LIST
75591: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75592: LD_ADDR_EXP 86
75596: PUSH
75597: LD_EXP 86
75601: PPUSH
75602: LD_VAR 0 1
75606: PPUSH
75607: LD_EXP 86
75611: PUSH
75612: LD_VAR 0 1
75616: ARRAY
75617: PUSH
75618: LD_VAR 0 3
75622: DIFF
75623: PPUSH
75624: CALL_OW 1
75628: ST_TO_ADDR
// end ;
75629: LD_VAR 0 2
75633: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75634: LD_INT 0
75636: PPUSH
// result := mc_vehicles [ base ] ;
75637: LD_ADDR_VAR 0 3
75641: PUSH
75642: LD_EXP 78
75646: PUSH
75647: LD_VAR 0 1
75651: ARRAY
75652: ST_TO_ADDR
// if onlyCombat then
75653: LD_VAR 0 2
75657: IFFALSE 75822
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75659: LD_ADDR_VAR 0 3
75663: PUSH
75664: LD_VAR 0 3
75668: PUSH
75669: LD_VAR 0 3
75673: PPUSH
75674: LD_INT 2
75676: PUSH
75677: LD_INT 34
75679: PUSH
75680: LD_INT 12
75682: PUSH
75683: EMPTY
75684: LIST
75685: LIST
75686: PUSH
75687: LD_INT 34
75689: PUSH
75690: LD_INT 51
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 34
75699: PUSH
75700: LD_EXP 103
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: LD_INT 34
75711: PUSH
75712: LD_INT 32
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 34
75721: PUSH
75722: LD_INT 13
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 34
75731: PUSH
75732: LD_INT 52
75734: PUSH
75735: EMPTY
75736: LIST
75737: LIST
75738: PUSH
75739: LD_INT 34
75741: PUSH
75742: LD_INT 14
75744: PUSH
75745: EMPTY
75746: LIST
75747: LIST
75748: PUSH
75749: LD_INT 34
75751: PUSH
75752: LD_INT 53
75754: PUSH
75755: EMPTY
75756: LIST
75757: LIST
75758: PUSH
75759: LD_INT 34
75761: PUSH
75762: LD_EXP 102
75766: PUSH
75767: EMPTY
75768: LIST
75769: LIST
75770: PUSH
75771: LD_INT 34
75773: PUSH
75774: LD_INT 31
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: PUSH
75781: LD_INT 34
75783: PUSH
75784: LD_INT 48
75786: PUSH
75787: EMPTY
75788: LIST
75789: LIST
75790: PUSH
75791: LD_INT 34
75793: PUSH
75794: LD_INT 8
75796: PUSH
75797: EMPTY
75798: LIST
75799: LIST
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: LIST
75805: LIST
75806: LIST
75807: LIST
75808: LIST
75809: LIST
75810: LIST
75811: LIST
75812: LIST
75813: LIST
75814: LIST
75815: PPUSH
75816: CALL_OW 72
75820: DIFF
75821: ST_TO_ADDR
// end ; end_of_file
75822: LD_VAR 0 3
75826: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75827: LD_INT 0
75829: PPUSH
75830: PPUSH
75831: PPUSH
// if not mc_bases or not skirmish then
75832: LD_EXP 59
75836: NOT
75837: PUSH
75838: LD_EXP 57
75842: NOT
75843: OR
75844: IFFALSE 75848
// exit ;
75846: GO 76013
// for i = 1 to mc_bases do
75848: LD_ADDR_VAR 0 4
75852: PUSH
75853: DOUBLE
75854: LD_INT 1
75856: DEC
75857: ST_TO_ADDR
75858: LD_EXP 59
75862: PUSH
75863: FOR_TO
75864: IFFALSE 76011
// begin if sci in mc_bases [ i ] then
75866: LD_VAR 0 2
75870: PUSH
75871: LD_EXP 59
75875: PUSH
75876: LD_VAR 0 4
75880: ARRAY
75881: IN
75882: IFFALSE 76009
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
75884: LD_ADDR_EXP 88
75888: PUSH
75889: LD_EXP 88
75893: PPUSH
75894: LD_VAR 0 4
75898: PUSH
75899: LD_EXP 88
75903: PUSH
75904: LD_VAR 0 4
75908: ARRAY
75909: PUSH
75910: LD_INT 1
75912: PLUS
75913: PUSH
75914: EMPTY
75915: LIST
75916: LIST
75917: PPUSH
75918: LD_VAR 0 1
75922: PPUSH
75923: CALL 19238 0 3
75927: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
75928: LD_ADDR_VAR 0 5
75932: PUSH
75933: LD_EXP 59
75937: PUSH
75938: LD_VAR 0 4
75942: ARRAY
75943: PPUSH
75944: LD_INT 2
75946: PUSH
75947: LD_INT 30
75949: PUSH
75950: LD_INT 0
75952: PUSH
75953: EMPTY
75954: LIST
75955: LIST
75956: PUSH
75957: LD_INT 30
75959: PUSH
75960: LD_INT 1
75962: PUSH
75963: EMPTY
75964: LIST
75965: LIST
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: LIST
75971: PPUSH
75972: CALL_OW 72
75976: PPUSH
75977: LD_VAR 0 1
75981: PPUSH
75982: CALL_OW 74
75986: ST_TO_ADDR
// if tmp then
75987: LD_VAR 0 5
75991: IFFALSE 76007
// ComStandNearbyBuilding ( ape , tmp ) ;
75993: LD_VAR 0 1
75997: PPUSH
75998: LD_VAR 0 5
76002: PPUSH
76003: CALL 15852 0 2
// break ;
76007: GO 76011
// end ; end ;
76009: GO 75863
76011: POP
76012: POP
// end ;
76013: LD_VAR 0 3
76017: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76018: LD_INT 0
76020: PPUSH
76021: PPUSH
76022: PPUSH
// if not mc_bases or not skirmish then
76023: LD_EXP 59
76027: NOT
76028: PUSH
76029: LD_EXP 57
76033: NOT
76034: OR
76035: IFFALSE 76039
// exit ;
76037: GO 76128
// for i = 1 to mc_bases do
76039: LD_ADDR_VAR 0 4
76043: PUSH
76044: DOUBLE
76045: LD_INT 1
76047: DEC
76048: ST_TO_ADDR
76049: LD_EXP 59
76053: PUSH
76054: FOR_TO
76055: IFFALSE 76126
// begin if building in mc_busy_turret_list [ i ] then
76057: LD_VAR 0 1
76061: PUSH
76062: LD_EXP 69
76066: PUSH
76067: LD_VAR 0 4
76071: ARRAY
76072: IN
76073: IFFALSE 76124
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76075: LD_ADDR_VAR 0 5
76079: PUSH
76080: LD_EXP 69
76084: PUSH
76085: LD_VAR 0 4
76089: ARRAY
76090: PUSH
76091: LD_VAR 0 1
76095: DIFF
76096: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76097: LD_ADDR_EXP 69
76101: PUSH
76102: LD_EXP 69
76106: PPUSH
76107: LD_VAR 0 4
76111: PPUSH
76112: LD_VAR 0 5
76116: PPUSH
76117: CALL_OW 1
76121: ST_TO_ADDR
// break ;
76122: GO 76126
// end ; end ;
76124: GO 76054
76126: POP
76127: POP
// end ;
76128: LD_VAR 0 3
76132: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76133: LD_INT 0
76135: PPUSH
76136: PPUSH
76137: PPUSH
// if not mc_bases or not skirmish then
76138: LD_EXP 59
76142: NOT
76143: PUSH
76144: LD_EXP 57
76148: NOT
76149: OR
76150: IFFALSE 76154
// exit ;
76152: GO 76353
// for i = 1 to mc_bases do
76154: LD_ADDR_VAR 0 5
76158: PUSH
76159: DOUBLE
76160: LD_INT 1
76162: DEC
76163: ST_TO_ADDR
76164: LD_EXP 59
76168: PUSH
76169: FOR_TO
76170: IFFALSE 76351
// if building in mc_bases [ i ] then
76172: LD_VAR 0 1
76176: PUSH
76177: LD_EXP 59
76181: PUSH
76182: LD_VAR 0 5
76186: ARRAY
76187: IN
76188: IFFALSE 76349
// begin tmp := mc_bases [ i ] diff building ;
76190: LD_ADDR_VAR 0 6
76194: PUSH
76195: LD_EXP 59
76199: PUSH
76200: LD_VAR 0 5
76204: ARRAY
76205: PUSH
76206: LD_VAR 0 1
76210: DIFF
76211: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76212: LD_ADDR_EXP 59
76216: PUSH
76217: LD_EXP 59
76221: PPUSH
76222: LD_VAR 0 5
76226: PPUSH
76227: LD_VAR 0 6
76231: PPUSH
76232: CALL_OW 1
76236: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76237: LD_VAR 0 1
76241: PUSH
76242: LD_EXP 67
76246: PUSH
76247: LD_VAR 0 5
76251: ARRAY
76252: IN
76253: IFFALSE 76292
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76255: LD_ADDR_EXP 67
76259: PUSH
76260: LD_EXP 67
76264: PPUSH
76265: LD_VAR 0 5
76269: PPUSH
76270: LD_EXP 67
76274: PUSH
76275: LD_VAR 0 5
76279: ARRAY
76280: PUSH
76281: LD_VAR 0 1
76285: DIFF
76286: PPUSH
76287: CALL_OW 1
76291: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76292: LD_VAR 0 1
76296: PUSH
76297: LD_EXP 68
76301: PUSH
76302: LD_VAR 0 5
76306: ARRAY
76307: IN
76308: IFFALSE 76347
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76310: LD_ADDR_EXP 68
76314: PUSH
76315: LD_EXP 68
76319: PPUSH
76320: LD_VAR 0 5
76324: PPUSH
76325: LD_EXP 68
76329: PUSH
76330: LD_VAR 0 5
76334: ARRAY
76335: PUSH
76336: LD_VAR 0 1
76340: DIFF
76341: PPUSH
76342: CALL_OW 1
76346: ST_TO_ADDR
// break ;
76347: GO 76351
// end ;
76349: GO 76169
76351: POP
76352: POP
// end ;
76353: LD_VAR 0 4
76357: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76358: LD_INT 0
76360: PPUSH
76361: PPUSH
76362: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76363: LD_EXP 59
76367: NOT
76368: PUSH
76369: LD_EXP 57
76373: NOT
76374: OR
76375: PUSH
76376: LD_VAR 0 3
76380: PUSH
76381: LD_EXP 85
76385: IN
76386: NOT
76387: OR
76388: IFFALSE 76392
// exit ;
76390: GO 76515
// for i = 1 to mc_vehicles do
76392: LD_ADDR_VAR 0 6
76396: PUSH
76397: DOUBLE
76398: LD_INT 1
76400: DEC
76401: ST_TO_ADDR
76402: LD_EXP 78
76406: PUSH
76407: FOR_TO
76408: IFFALSE 76513
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76410: LD_VAR 0 2
76414: PUSH
76415: LD_EXP 78
76419: PUSH
76420: LD_VAR 0 6
76424: ARRAY
76425: IN
76426: PUSH
76427: LD_VAR 0 1
76431: PUSH
76432: LD_EXP 78
76436: PUSH
76437: LD_VAR 0 6
76441: ARRAY
76442: IN
76443: OR
76444: IFFALSE 76511
// begin tmp := mc_vehicles [ i ] diff old ;
76446: LD_ADDR_VAR 0 7
76450: PUSH
76451: LD_EXP 78
76455: PUSH
76456: LD_VAR 0 6
76460: ARRAY
76461: PUSH
76462: LD_VAR 0 2
76466: DIFF
76467: ST_TO_ADDR
// tmp := tmp diff new ;
76468: LD_ADDR_VAR 0 7
76472: PUSH
76473: LD_VAR 0 7
76477: PUSH
76478: LD_VAR 0 1
76482: DIFF
76483: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76484: LD_ADDR_EXP 78
76488: PUSH
76489: LD_EXP 78
76493: PPUSH
76494: LD_VAR 0 6
76498: PPUSH
76499: LD_VAR 0 7
76503: PPUSH
76504: CALL_OW 1
76508: ST_TO_ADDR
// break ;
76509: GO 76513
// end ;
76511: GO 76407
76513: POP
76514: POP
// end ;
76515: LD_VAR 0 5
76519: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76520: LD_INT 0
76522: PPUSH
76523: PPUSH
76524: PPUSH
76525: PPUSH
// if not mc_bases or not skirmish then
76526: LD_EXP 59
76530: NOT
76531: PUSH
76532: LD_EXP 57
76536: NOT
76537: OR
76538: IFFALSE 76542
// exit ;
76540: GO 76919
// side := GetSide ( vehicle ) ;
76542: LD_ADDR_VAR 0 5
76546: PUSH
76547: LD_VAR 0 1
76551: PPUSH
76552: CALL_OW 255
76556: ST_TO_ADDR
// for i = 1 to mc_bases do
76557: LD_ADDR_VAR 0 4
76561: PUSH
76562: DOUBLE
76563: LD_INT 1
76565: DEC
76566: ST_TO_ADDR
76567: LD_EXP 59
76571: PUSH
76572: FOR_TO
76573: IFFALSE 76917
// begin if factory in mc_bases [ i ] then
76575: LD_VAR 0 2
76579: PUSH
76580: LD_EXP 59
76584: PUSH
76585: LD_VAR 0 4
76589: ARRAY
76590: IN
76591: IFFALSE 76915
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
76593: LD_EXP 81
76597: PUSH
76598: LD_VAR 0 4
76602: ARRAY
76603: PUSH
76604: LD_EXP 70
76608: PUSH
76609: LD_VAR 0 4
76613: ARRAY
76614: LESS
76615: PUSH
76616: LD_VAR 0 1
76620: PPUSH
76621: CALL_OW 264
76625: PUSH
76626: LD_INT 31
76628: PUSH
76629: LD_INT 32
76631: PUSH
76632: LD_INT 51
76634: PUSH
76635: LD_EXP 103
76639: PUSH
76640: LD_INT 12
76642: PUSH
76643: LD_INT 30
76645: PUSH
76646: LD_EXP 102
76650: PUSH
76651: LD_INT 11
76653: PUSH
76654: LD_INT 53
76656: PUSH
76657: LD_INT 14
76659: PUSH
76660: LD_EXP 106
76664: PUSH
76665: LD_INT 29
76667: PUSH
76668: LD_EXP 104
76672: PUSH
76673: LD_INT 13
76675: PUSH
76676: LD_INT 52
76678: PUSH
76679: LD_INT 48
76681: PUSH
76682: LD_INT 8
76684: PUSH
76685: EMPTY
76686: LIST
76687: LIST
76688: LIST
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: LIST
76694: LIST
76695: LIST
76696: LIST
76697: LIST
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: LIST
76703: IN
76704: NOT
76705: AND
76706: IFFALSE 76754
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76708: LD_ADDR_EXP 81
76712: PUSH
76713: LD_EXP 81
76717: PPUSH
76718: LD_VAR 0 4
76722: PUSH
76723: LD_EXP 81
76727: PUSH
76728: LD_VAR 0 4
76732: ARRAY
76733: PUSH
76734: LD_INT 1
76736: PLUS
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PPUSH
76742: LD_VAR 0 1
76746: PPUSH
76747: CALL 19238 0 3
76751: ST_TO_ADDR
76752: GO 76798
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76754: LD_ADDR_EXP 78
76758: PUSH
76759: LD_EXP 78
76763: PPUSH
76764: LD_VAR 0 4
76768: PUSH
76769: LD_EXP 78
76773: PUSH
76774: LD_VAR 0 4
76778: ARRAY
76779: PUSH
76780: LD_INT 1
76782: PLUS
76783: PUSH
76784: EMPTY
76785: LIST
76786: LIST
76787: PPUSH
76788: LD_VAR 0 1
76792: PPUSH
76793: CALL 19238 0 3
76797: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76798: LD_VAR 0 1
76802: PPUSH
76803: CALL_OW 263
76807: PUSH
76808: LD_INT 2
76810: EQUAL
76811: IFFALSE 76831
// begin repeat wait ( 0 0$1 ) ;
76813: LD_INT 35
76815: PPUSH
76816: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76820: LD_VAR 0 1
76824: PPUSH
76825: CALL_OW 312
76829: IFFALSE 76813
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76831: LD_VAR 0 1
76835: PPUSH
76836: LD_EXP 83
76840: PUSH
76841: LD_VAR 0 4
76845: ARRAY
76846: PPUSH
76847: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76851: LD_VAR 0 1
76855: PPUSH
76856: CALL_OW 263
76860: PUSH
76861: LD_INT 1
76863: NONEQUAL
76864: IFFALSE 76868
// break ;
76866: GO 76917
// repeat wait ( 0 0$1 ) ;
76868: LD_INT 35
76870: PPUSH
76871: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76875: LD_VAR 0 1
76879: PPUSH
76880: LD_EXP 83
76884: PUSH
76885: LD_VAR 0 4
76889: ARRAY
76890: PPUSH
76891: CALL_OW 308
76895: IFFALSE 76868
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
76897: LD_VAR 0 1
76901: PPUSH
76902: CALL_OW 311
76906: PPUSH
76907: CALL_OW 121
// exit ;
76911: POP
76912: POP
76913: GO 76919
// end ; end ;
76915: GO 76572
76917: POP
76918: POP
// end ;
76919: LD_VAR 0 3
76923: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
76924: LD_INT 0
76926: PPUSH
76927: PPUSH
76928: PPUSH
76929: PPUSH
// if not mc_bases or not skirmish then
76930: LD_EXP 59
76934: NOT
76935: PUSH
76936: LD_EXP 57
76940: NOT
76941: OR
76942: IFFALSE 76946
// exit ;
76944: GO 77299
// repeat wait ( 0 0$1 ) ;
76946: LD_INT 35
76948: PPUSH
76949: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
76953: LD_VAR 0 2
76957: PPUSH
76958: LD_VAR 0 3
76962: PPUSH
76963: CALL_OW 284
76967: IFFALSE 76946
// if GetResourceTypeXY ( x , y ) = mat_artefact then
76969: LD_VAR 0 2
76973: PPUSH
76974: LD_VAR 0 3
76978: PPUSH
76979: CALL_OW 283
76983: PUSH
76984: LD_INT 4
76986: EQUAL
76987: IFFALSE 76991
// exit ;
76989: GO 77299
// for i = 1 to mc_bases do
76991: LD_ADDR_VAR 0 7
76995: PUSH
76996: DOUBLE
76997: LD_INT 1
76999: DEC
77000: ST_TO_ADDR
77001: LD_EXP 59
77005: PUSH
77006: FOR_TO
77007: IFFALSE 77297
// begin if mc_crates_area [ i ] then
77009: LD_EXP 77
77013: PUSH
77014: LD_VAR 0 7
77018: ARRAY
77019: IFFALSE 77130
// for j in mc_crates_area [ i ] do
77021: LD_ADDR_VAR 0 8
77025: PUSH
77026: LD_EXP 77
77030: PUSH
77031: LD_VAR 0 7
77035: ARRAY
77036: PUSH
77037: FOR_IN
77038: IFFALSE 77128
// if InArea ( x , y , j ) then
77040: LD_VAR 0 2
77044: PPUSH
77045: LD_VAR 0 3
77049: PPUSH
77050: LD_VAR 0 8
77054: PPUSH
77055: CALL_OW 309
77059: IFFALSE 77126
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77061: LD_ADDR_EXP 75
77065: PUSH
77066: LD_EXP 75
77070: PPUSH
77071: LD_VAR 0 7
77075: PUSH
77076: LD_EXP 75
77080: PUSH
77081: LD_VAR 0 7
77085: ARRAY
77086: PUSH
77087: LD_INT 1
77089: PLUS
77090: PUSH
77091: EMPTY
77092: LIST
77093: LIST
77094: PPUSH
77095: LD_VAR 0 4
77099: PUSH
77100: LD_VAR 0 2
77104: PUSH
77105: LD_VAR 0 3
77109: PUSH
77110: EMPTY
77111: LIST
77112: LIST
77113: LIST
77114: PPUSH
77115: CALL 19238 0 3
77119: ST_TO_ADDR
// exit ;
77120: POP
77121: POP
77122: POP
77123: POP
77124: GO 77299
// end ;
77126: GO 77037
77128: POP
77129: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77130: LD_ADDR_VAR 0 9
77134: PUSH
77135: LD_EXP 59
77139: PUSH
77140: LD_VAR 0 7
77144: ARRAY
77145: PPUSH
77146: LD_INT 2
77148: PUSH
77149: LD_INT 30
77151: PUSH
77152: LD_INT 0
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PUSH
77159: LD_INT 30
77161: PUSH
77162: LD_INT 1
77164: PUSH
77165: EMPTY
77166: LIST
77167: LIST
77168: PUSH
77169: EMPTY
77170: LIST
77171: LIST
77172: LIST
77173: PPUSH
77174: CALL_OW 72
77178: ST_TO_ADDR
// if not depot then
77179: LD_VAR 0 9
77183: NOT
77184: IFFALSE 77188
// continue ;
77186: GO 77006
// for j in depot do
77188: LD_ADDR_VAR 0 8
77192: PUSH
77193: LD_VAR 0 9
77197: PUSH
77198: FOR_IN
77199: IFFALSE 77293
// if GetDistUnitXY ( j , x , y ) < 30 then
77201: LD_VAR 0 8
77205: PPUSH
77206: LD_VAR 0 2
77210: PPUSH
77211: LD_VAR 0 3
77215: PPUSH
77216: CALL_OW 297
77220: PUSH
77221: LD_INT 30
77223: LESS
77224: IFFALSE 77291
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77226: LD_ADDR_EXP 75
77230: PUSH
77231: LD_EXP 75
77235: PPUSH
77236: LD_VAR 0 7
77240: PUSH
77241: LD_EXP 75
77245: PUSH
77246: LD_VAR 0 7
77250: ARRAY
77251: PUSH
77252: LD_INT 1
77254: PLUS
77255: PUSH
77256: EMPTY
77257: LIST
77258: LIST
77259: PPUSH
77260: LD_VAR 0 4
77264: PUSH
77265: LD_VAR 0 2
77269: PUSH
77270: LD_VAR 0 3
77274: PUSH
77275: EMPTY
77276: LIST
77277: LIST
77278: LIST
77279: PPUSH
77280: CALL 19238 0 3
77284: ST_TO_ADDR
// exit ;
77285: POP
77286: POP
77287: POP
77288: POP
77289: GO 77299
// end ;
77291: GO 77198
77293: POP
77294: POP
// end ;
77295: GO 77006
77297: POP
77298: POP
// end ;
77299: LD_VAR 0 6
77303: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77304: LD_INT 0
77306: PPUSH
77307: PPUSH
77308: PPUSH
77309: PPUSH
// if not mc_bases or not skirmish then
77310: LD_EXP 59
77314: NOT
77315: PUSH
77316: LD_EXP 57
77320: NOT
77321: OR
77322: IFFALSE 77326
// exit ;
77324: GO 77603
// side := GetSide ( lab ) ;
77326: LD_ADDR_VAR 0 4
77330: PUSH
77331: LD_VAR 0 2
77335: PPUSH
77336: CALL_OW 255
77340: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77341: LD_VAR 0 4
77345: PUSH
77346: LD_EXP 85
77350: IN
77351: NOT
77352: PUSH
77353: LD_EXP 86
77357: NOT
77358: OR
77359: PUSH
77360: LD_EXP 59
77364: NOT
77365: OR
77366: IFFALSE 77370
// exit ;
77368: GO 77603
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77370: LD_ADDR_EXP 86
77374: PUSH
77375: LD_EXP 86
77379: PPUSH
77380: LD_VAR 0 4
77384: PPUSH
77385: LD_EXP 86
77389: PUSH
77390: LD_VAR 0 4
77394: ARRAY
77395: PUSH
77396: LD_VAR 0 1
77400: DIFF
77401: PPUSH
77402: CALL_OW 1
77406: ST_TO_ADDR
// for i = 1 to mc_bases do
77407: LD_ADDR_VAR 0 5
77411: PUSH
77412: DOUBLE
77413: LD_INT 1
77415: DEC
77416: ST_TO_ADDR
77417: LD_EXP 59
77421: PUSH
77422: FOR_TO
77423: IFFALSE 77601
// begin if lab in mc_bases [ i ] then
77425: LD_VAR 0 2
77429: PUSH
77430: LD_EXP 59
77434: PUSH
77435: LD_VAR 0 5
77439: ARRAY
77440: IN
77441: IFFALSE 77599
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77443: LD_VAR 0 1
77447: PUSH
77448: LD_INT 11
77450: PUSH
77451: LD_INT 4
77453: PUSH
77454: LD_INT 3
77456: PUSH
77457: LD_INT 2
77459: PUSH
77460: EMPTY
77461: LIST
77462: LIST
77463: LIST
77464: LIST
77465: IN
77466: PUSH
77467: LD_EXP 89
77471: PUSH
77472: LD_VAR 0 5
77476: ARRAY
77477: AND
77478: IFFALSE 77599
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77480: LD_ADDR_VAR 0 6
77484: PUSH
77485: LD_EXP 89
77489: PUSH
77490: LD_VAR 0 5
77494: ARRAY
77495: PUSH
77496: LD_INT 1
77498: ARRAY
77499: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77500: LD_ADDR_EXP 89
77504: PUSH
77505: LD_EXP 89
77509: PPUSH
77510: LD_VAR 0 5
77514: PPUSH
77515: EMPTY
77516: PPUSH
77517: CALL_OW 1
77521: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77522: LD_VAR 0 6
77526: PPUSH
77527: LD_INT 0
77529: PPUSH
77530: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77534: LD_VAR 0 6
77538: PPUSH
77539: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77543: LD_ADDR_EXP 88
77547: PUSH
77548: LD_EXP 88
77552: PPUSH
77553: LD_VAR 0 5
77557: PPUSH
77558: LD_EXP 88
77562: PUSH
77563: LD_VAR 0 5
77567: ARRAY
77568: PPUSH
77569: LD_INT 1
77571: PPUSH
77572: LD_VAR 0 6
77576: PPUSH
77577: CALL_OW 2
77581: PPUSH
77582: CALL_OW 1
77586: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77587: LD_VAR 0 5
77591: PPUSH
77592: LD_INT 112
77594: PPUSH
77595: CALL 54615 0 2
// end ; end ; end ;
77599: GO 77422
77601: POP
77602: POP
// end ;
77603: LD_VAR 0 3
77607: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77608: LD_INT 0
77610: PPUSH
77611: PPUSH
77612: PPUSH
77613: PPUSH
77614: PPUSH
77615: PPUSH
77616: PPUSH
77617: PPUSH
// if not mc_bases or not skirmish then
77618: LD_EXP 59
77622: NOT
77623: PUSH
77624: LD_EXP 57
77628: NOT
77629: OR
77630: IFFALSE 77634
// exit ;
77632: GO 79005
// for i = 1 to mc_bases do
77634: LD_ADDR_VAR 0 3
77638: PUSH
77639: DOUBLE
77640: LD_INT 1
77642: DEC
77643: ST_TO_ADDR
77644: LD_EXP 59
77648: PUSH
77649: FOR_TO
77650: IFFALSE 79003
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77652: LD_VAR 0 1
77656: PUSH
77657: LD_EXP 59
77661: PUSH
77662: LD_VAR 0 3
77666: ARRAY
77667: IN
77668: PUSH
77669: LD_VAR 0 1
77673: PUSH
77674: LD_EXP 66
77678: PUSH
77679: LD_VAR 0 3
77683: ARRAY
77684: IN
77685: OR
77686: PUSH
77687: LD_VAR 0 1
77691: PUSH
77692: LD_EXP 81
77696: PUSH
77697: LD_VAR 0 3
77701: ARRAY
77702: IN
77703: OR
77704: PUSH
77705: LD_VAR 0 1
77709: PUSH
77710: LD_EXP 78
77714: PUSH
77715: LD_VAR 0 3
77719: ARRAY
77720: IN
77721: OR
77722: PUSH
77723: LD_VAR 0 1
77727: PUSH
77728: LD_EXP 88
77732: PUSH
77733: LD_VAR 0 3
77737: ARRAY
77738: IN
77739: OR
77740: PUSH
77741: LD_VAR 0 1
77745: PUSH
77746: LD_EXP 89
77750: PUSH
77751: LD_VAR 0 3
77755: ARRAY
77756: IN
77757: OR
77758: IFFALSE 79001
// begin if un in mc_ape [ i ] then
77760: LD_VAR 0 1
77764: PUSH
77765: LD_EXP 88
77769: PUSH
77770: LD_VAR 0 3
77774: ARRAY
77775: IN
77776: IFFALSE 77815
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77778: LD_ADDR_EXP 88
77782: PUSH
77783: LD_EXP 88
77787: PPUSH
77788: LD_VAR 0 3
77792: PPUSH
77793: LD_EXP 88
77797: PUSH
77798: LD_VAR 0 3
77802: ARRAY
77803: PUSH
77804: LD_VAR 0 1
77808: DIFF
77809: PPUSH
77810: CALL_OW 1
77814: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77815: LD_VAR 0 1
77819: PUSH
77820: LD_EXP 89
77824: PUSH
77825: LD_VAR 0 3
77829: ARRAY
77830: IN
77831: IFFALSE 77855
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77833: LD_ADDR_EXP 89
77837: PUSH
77838: LD_EXP 89
77842: PPUSH
77843: LD_VAR 0 3
77847: PPUSH
77848: EMPTY
77849: PPUSH
77850: CALL_OW 1
77854: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77855: LD_VAR 0 1
77859: PPUSH
77860: CALL_OW 247
77864: PUSH
77865: LD_INT 2
77867: EQUAL
77868: PUSH
77869: LD_VAR 0 1
77873: PPUSH
77874: CALL_OW 110
77878: PUSH
77879: LD_INT 20
77881: EQUAL
77882: PUSH
77883: LD_VAR 0 1
77887: PUSH
77888: LD_EXP 81
77892: PUSH
77893: LD_VAR 0 3
77897: ARRAY
77898: IN
77899: OR
77900: PUSH
77901: LD_VAR 0 1
77905: PPUSH
77906: CALL_OW 264
77910: PUSH
77911: LD_INT 12
77913: PUSH
77914: LD_INT 51
77916: PUSH
77917: LD_EXP 103
77921: PUSH
77922: LD_INT 32
77924: PUSH
77925: LD_INT 13
77927: PUSH
77928: LD_INT 52
77930: PUSH
77931: LD_INT 31
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: LIST
77938: LIST
77939: LIST
77940: LIST
77941: LIST
77942: IN
77943: OR
77944: AND
77945: IFFALSE 78253
// begin if un in mc_defender [ i ] then
77947: LD_VAR 0 1
77951: PUSH
77952: LD_EXP 81
77956: PUSH
77957: LD_VAR 0 3
77961: ARRAY
77962: IN
77963: IFFALSE 78002
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
77965: LD_ADDR_EXP 81
77969: PUSH
77970: LD_EXP 81
77974: PPUSH
77975: LD_VAR 0 3
77979: PPUSH
77980: LD_EXP 81
77984: PUSH
77985: LD_VAR 0 3
77989: ARRAY
77990: PUSH
77991: LD_VAR 0 1
77995: DIFF
77996: PPUSH
77997: CALL_OW 1
78001: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78002: LD_ADDR_VAR 0 8
78006: PUSH
78007: LD_VAR 0 3
78011: PPUSH
78012: LD_INT 3
78014: PPUSH
78015: CALL 74671 0 2
78019: ST_TO_ADDR
// if fac then
78020: LD_VAR 0 8
78024: IFFALSE 78253
// begin for j in fac do
78026: LD_ADDR_VAR 0 4
78030: PUSH
78031: LD_VAR 0 8
78035: PUSH
78036: FOR_IN
78037: IFFALSE 78251
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78039: LD_ADDR_VAR 0 9
78043: PUSH
78044: LD_VAR 0 8
78048: PPUSH
78049: LD_VAR 0 1
78053: PPUSH
78054: CALL_OW 265
78058: PPUSH
78059: LD_VAR 0 1
78063: PPUSH
78064: CALL_OW 262
78068: PPUSH
78069: LD_VAR 0 1
78073: PPUSH
78074: CALL_OW 263
78078: PPUSH
78079: LD_VAR 0 1
78083: PPUSH
78084: CALL_OW 264
78088: PPUSH
78089: CALL 16770 0 5
78093: ST_TO_ADDR
// if components then
78094: LD_VAR 0 9
78098: IFFALSE 78249
// begin if GetWeapon ( un ) = ar_control_tower then
78100: LD_VAR 0 1
78104: PPUSH
78105: CALL_OW 264
78109: PUSH
78110: LD_INT 31
78112: EQUAL
78113: IFFALSE 78230
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78115: LD_VAR 0 1
78119: PPUSH
78120: CALL_OW 311
78124: PPUSH
78125: LD_INT 0
78127: PPUSH
78128: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78132: LD_ADDR_EXP 99
78136: PUSH
78137: LD_EXP 99
78141: PPUSH
78142: LD_VAR 0 3
78146: PPUSH
78147: LD_EXP 99
78151: PUSH
78152: LD_VAR 0 3
78156: ARRAY
78157: PUSH
78158: LD_VAR 0 1
78162: PPUSH
78163: CALL_OW 311
78167: DIFF
78168: PPUSH
78169: CALL_OW 1
78173: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78174: LD_ADDR_VAR 0 7
78178: PUSH
78179: LD_EXP 80
78183: PUSH
78184: LD_VAR 0 3
78188: ARRAY
78189: PPUSH
78190: LD_INT 1
78192: PPUSH
78193: LD_VAR 0 9
78197: PPUSH
78198: CALL_OW 2
78202: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78203: LD_ADDR_EXP 80
78207: PUSH
78208: LD_EXP 80
78212: PPUSH
78213: LD_VAR 0 3
78217: PPUSH
78218: LD_VAR 0 7
78222: PPUSH
78223: CALL_OW 1
78227: ST_TO_ADDR
// end else
78228: GO 78247
// MC_InsertProduceList ( i , [ components ] ) ;
78230: LD_VAR 0 3
78234: PPUSH
78235: LD_VAR 0 9
78239: PUSH
78240: EMPTY
78241: LIST
78242: PPUSH
78243: CALL 74216 0 2
// break ;
78247: GO 78251
// end ; end ;
78249: GO 78036
78251: POP
78252: POP
// end ; end ; if GetType ( un ) = unit_building then
78253: LD_VAR 0 1
78257: PPUSH
78258: CALL_OW 247
78262: PUSH
78263: LD_INT 3
78265: EQUAL
78266: IFFALSE 78669
// begin btype := GetBType ( un ) ;
78268: LD_ADDR_VAR 0 5
78272: PUSH
78273: LD_VAR 0 1
78277: PPUSH
78278: CALL_OW 266
78282: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78283: LD_VAR 0 5
78287: PUSH
78288: LD_INT 29
78290: PUSH
78291: LD_INT 30
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: IN
78298: IFFALSE 78371
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78300: LD_VAR 0 1
78304: PPUSH
78305: CALL_OW 250
78309: PPUSH
78310: LD_VAR 0 1
78314: PPUSH
78315: CALL_OW 251
78319: PPUSH
78320: LD_VAR 0 1
78324: PPUSH
78325: CALL_OW 255
78329: PPUSH
78330: CALL_OW 440
78334: NOT
78335: IFFALSE 78371
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78337: LD_VAR 0 1
78341: PPUSH
78342: CALL_OW 250
78346: PPUSH
78347: LD_VAR 0 1
78351: PPUSH
78352: CALL_OW 251
78356: PPUSH
78357: LD_VAR 0 1
78361: PPUSH
78362: CALL_OW 255
78366: PPUSH
78367: CALL_OW 441
// end ; if btype = b_warehouse then
78371: LD_VAR 0 5
78375: PUSH
78376: LD_INT 1
78378: EQUAL
78379: IFFALSE 78397
// begin btype := b_depot ;
78381: LD_ADDR_VAR 0 5
78385: PUSH
78386: LD_INT 0
78388: ST_TO_ADDR
// pos := 1 ;
78389: LD_ADDR_VAR 0 6
78393: PUSH
78394: LD_INT 1
78396: ST_TO_ADDR
// end ; if btype = b_factory then
78397: LD_VAR 0 5
78401: PUSH
78402: LD_INT 3
78404: EQUAL
78405: IFFALSE 78423
// begin btype := b_workshop ;
78407: LD_ADDR_VAR 0 5
78411: PUSH
78412: LD_INT 2
78414: ST_TO_ADDR
// pos := 1 ;
78415: LD_ADDR_VAR 0 6
78419: PUSH
78420: LD_INT 1
78422: ST_TO_ADDR
// end ; if btype = b_barracks then
78423: LD_VAR 0 5
78427: PUSH
78428: LD_INT 5
78430: EQUAL
78431: IFFALSE 78441
// btype := b_armoury ;
78433: LD_ADDR_VAR 0 5
78437: PUSH
78438: LD_INT 4
78440: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78441: LD_VAR 0 5
78445: PUSH
78446: LD_INT 7
78448: PUSH
78449: LD_INT 8
78451: PUSH
78452: EMPTY
78453: LIST
78454: LIST
78455: IN
78456: IFFALSE 78466
// btype := b_lab ;
78458: LD_ADDR_VAR 0 5
78462: PUSH
78463: LD_INT 6
78465: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78466: LD_ADDR_EXP 64
78470: PUSH
78471: LD_EXP 64
78475: PPUSH
78476: LD_VAR 0 3
78480: PUSH
78481: LD_EXP 64
78485: PUSH
78486: LD_VAR 0 3
78490: ARRAY
78491: PUSH
78492: LD_INT 1
78494: PLUS
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PPUSH
78500: LD_VAR 0 5
78504: PUSH
78505: LD_VAR 0 1
78509: PPUSH
78510: CALL_OW 250
78514: PUSH
78515: LD_VAR 0 1
78519: PPUSH
78520: CALL_OW 251
78524: PUSH
78525: LD_VAR 0 1
78529: PPUSH
78530: CALL_OW 254
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: PPUSH
78541: CALL 19238 0 3
78545: ST_TO_ADDR
// if pos = 1 then
78546: LD_VAR 0 6
78550: PUSH
78551: LD_INT 1
78553: EQUAL
78554: IFFALSE 78669
// begin tmp := mc_build_list [ i ] ;
78556: LD_ADDR_VAR 0 7
78560: PUSH
78561: LD_EXP 64
78565: PUSH
78566: LD_VAR 0 3
78570: ARRAY
78571: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78572: LD_VAR 0 7
78576: PPUSH
78577: LD_INT 2
78579: PUSH
78580: LD_INT 30
78582: PUSH
78583: LD_INT 0
78585: PUSH
78586: EMPTY
78587: LIST
78588: LIST
78589: PUSH
78590: LD_INT 30
78592: PUSH
78593: LD_INT 1
78595: PUSH
78596: EMPTY
78597: LIST
78598: LIST
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: LIST
78604: PPUSH
78605: CALL_OW 72
78609: IFFALSE 78619
// pos := 2 ;
78611: LD_ADDR_VAR 0 6
78615: PUSH
78616: LD_INT 2
78618: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78619: LD_ADDR_VAR 0 7
78623: PUSH
78624: LD_VAR 0 7
78628: PPUSH
78629: LD_VAR 0 6
78633: PPUSH
78634: LD_VAR 0 7
78638: PPUSH
78639: CALL 19564 0 3
78643: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78644: LD_ADDR_EXP 64
78648: PUSH
78649: LD_EXP 64
78653: PPUSH
78654: LD_VAR 0 3
78658: PPUSH
78659: LD_VAR 0 7
78663: PPUSH
78664: CALL_OW 1
78668: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78669: LD_VAR 0 1
78673: PUSH
78674: LD_EXP 59
78678: PUSH
78679: LD_VAR 0 3
78683: ARRAY
78684: IN
78685: IFFALSE 78724
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78687: LD_ADDR_EXP 59
78691: PUSH
78692: LD_EXP 59
78696: PPUSH
78697: LD_VAR 0 3
78701: PPUSH
78702: LD_EXP 59
78706: PUSH
78707: LD_VAR 0 3
78711: ARRAY
78712: PUSH
78713: LD_VAR 0 1
78717: DIFF
78718: PPUSH
78719: CALL_OW 1
78723: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78724: LD_VAR 0 1
78728: PUSH
78729: LD_EXP 66
78733: PUSH
78734: LD_VAR 0 3
78738: ARRAY
78739: IN
78740: IFFALSE 78779
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78742: LD_ADDR_EXP 66
78746: PUSH
78747: LD_EXP 66
78751: PPUSH
78752: LD_VAR 0 3
78756: PPUSH
78757: LD_EXP 66
78761: PUSH
78762: LD_VAR 0 3
78766: ARRAY
78767: PUSH
78768: LD_VAR 0 1
78772: DIFF
78773: PPUSH
78774: CALL_OW 1
78778: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78779: LD_VAR 0 1
78783: PUSH
78784: LD_EXP 78
78788: PUSH
78789: LD_VAR 0 3
78793: ARRAY
78794: IN
78795: IFFALSE 78834
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78797: LD_ADDR_EXP 78
78801: PUSH
78802: LD_EXP 78
78806: PPUSH
78807: LD_VAR 0 3
78811: PPUSH
78812: LD_EXP 78
78816: PUSH
78817: LD_VAR 0 3
78821: ARRAY
78822: PUSH
78823: LD_VAR 0 1
78827: DIFF
78828: PPUSH
78829: CALL_OW 1
78833: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78834: LD_VAR 0 1
78838: PUSH
78839: LD_EXP 81
78843: PUSH
78844: LD_VAR 0 3
78848: ARRAY
78849: IN
78850: IFFALSE 78889
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78852: LD_ADDR_EXP 81
78856: PUSH
78857: LD_EXP 81
78861: PPUSH
78862: LD_VAR 0 3
78866: PPUSH
78867: LD_EXP 81
78871: PUSH
78872: LD_VAR 0 3
78876: ARRAY
78877: PUSH
78878: LD_VAR 0 1
78882: DIFF
78883: PPUSH
78884: CALL_OW 1
78888: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
78889: LD_VAR 0 1
78893: PUSH
78894: LD_EXP 68
78898: PUSH
78899: LD_VAR 0 3
78903: ARRAY
78904: IN
78905: IFFALSE 78944
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
78907: LD_ADDR_EXP 68
78911: PUSH
78912: LD_EXP 68
78916: PPUSH
78917: LD_VAR 0 3
78921: PPUSH
78922: LD_EXP 68
78926: PUSH
78927: LD_VAR 0 3
78931: ARRAY
78932: PUSH
78933: LD_VAR 0 1
78937: DIFF
78938: PPUSH
78939: CALL_OW 1
78943: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
78944: LD_VAR 0 1
78948: PUSH
78949: LD_EXP 67
78953: PUSH
78954: LD_VAR 0 3
78958: ARRAY
78959: IN
78960: IFFALSE 78999
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
78962: LD_ADDR_EXP 67
78966: PUSH
78967: LD_EXP 67
78971: PPUSH
78972: LD_VAR 0 3
78976: PPUSH
78977: LD_EXP 67
78981: PUSH
78982: LD_VAR 0 3
78986: ARRAY
78987: PUSH
78988: LD_VAR 0 1
78992: DIFF
78993: PPUSH
78994: CALL_OW 1
78998: ST_TO_ADDR
// end ; break ;
78999: GO 79003
// end ;
79001: GO 77649
79003: POP
79004: POP
// end ;
79005: LD_VAR 0 2
79009: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79010: LD_INT 0
79012: PPUSH
79013: PPUSH
79014: PPUSH
// if not mc_bases or not skirmish then
79015: LD_EXP 59
79019: NOT
79020: PUSH
79021: LD_EXP 57
79025: NOT
79026: OR
79027: IFFALSE 79031
// exit ;
79029: GO 79246
// for i = 1 to mc_bases do
79031: LD_ADDR_VAR 0 3
79035: PUSH
79036: DOUBLE
79037: LD_INT 1
79039: DEC
79040: ST_TO_ADDR
79041: LD_EXP 59
79045: PUSH
79046: FOR_TO
79047: IFFALSE 79244
// begin if building in mc_construct_list [ i ] then
79049: LD_VAR 0 1
79053: PUSH
79054: LD_EXP 66
79058: PUSH
79059: LD_VAR 0 3
79063: ARRAY
79064: IN
79065: IFFALSE 79242
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79067: LD_ADDR_EXP 66
79071: PUSH
79072: LD_EXP 66
79076: PPUSH
79077: LD_VAR 0 3
79081: PPUSH
79082: LD_EXP 66
79086: PUSH
79087: LD_VAR 0 3
79091: ARRAY
79092: PUSH
79093: LD_VAR 0 1
79097: DIFF
79098: PPUSH
79099: CALL_OW 1
79103: ST_TO_ADDR
// if building in mc_lab [ i ] then
79104: LD_VAR 0 1
79108: PUSH
79109: LD_EXP 92
79113: PUSH
79114: LD_VAR 0 3
79118: ARRAY
79119: IN
79120: IFFALSE 79175
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79122: LD_ADDR_EXP 93
79126: PUSH
79127: LD_EXP 93
79131: PPUSH
79132: LD_VAR 0 3
79136: PPUSH
79137: LD_EXP 93
79141: PUSH
79142: LD_VAR 0 3
79146: ARRAY
79147: PPUSH
79148: LD_INT 1
79150: PPUSH
79151: LD_EXP 93
79155: PUSH
79156: LD_VAR 0 3
79160: ARRAY
79161: PPUSH
79162: LD_INT 0
79164: PPUSH
79165: CALL 18656 0 4
79169: PPUSH
79170: CALL_OW 1
79174: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79175: LD_VAR 0 1
79179: PUSH
79180: LD_EXP 59
79184: PUSH
79185: LD_VAR 0 3
79189: ARRAY
79190: IN
79191: NOT
79192: IFFALSE 79238
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79194: LD_ADDR_EXP 59
79198: PUSH
79199: LD_EXP 59
79203: PPUSH
79204: LD_VAR 0 3
79208: PUSH
79209: LD_EXP 59
79213: PUSH
79214: LD_VAR 0 3
79218: ARRAY
79219: PUSH
79220: LD_INT 1
79222: PLUS
79223: PUSH
79224: EMPTY
79225: LIST
79226: LIST
79227: PPUSH
79228: LD_VAR 0 1
79232: PPUSH
79233: CALL 19238 0 3
79237: ST_TO_ADDR
// exit ;
79238: POP
79239: POP
79240: GO 79246
// end ; end ;
79242: GO 79046
79244: POP
79245: POP
// end ;
79246: LD_VAR 0 2
79250: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79251: LD_INT 0
79253: PPUSH
79254: PPUSH
79255: PPUSH
79256: PPUSH
79257: PPUSH
79258: PPUSH
79259: PPUSH
// if not mc_bases or not skirmish then
79260: LD_EXP 59
79264: NOT
79265: PUSH
79266: LD_EXP 57
79270: NOT
79271: OR
79272: IFFALSE 79276
// exit ;
79274: GO 79937
// for i = 1 to mc_bases do
79276: LD_ADDR_VAR 0 3
79280: PUSH
79281: DOUBLE
79282: LD_INT 1
79284: DEC
79285: ST_TO_ADDR
79286: LD_EXP 59
79290: PUSH
79291: FOR_TO
79292: IFFALSE 79935
// begin if building in mc_construct_list [ i ] then
79294: LD_VAR 0 1
79298: PUSH
79299: LD_EXP 66
79303: PUSH
79304: LD_VAR 0 3
79308: ARRAY
79309: IN
79310: IFFALSE 79933
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79312: LD_ADDR_EXP 66
79316: PUSH
79317: LD_EXP 66
79321: PPUSH
79322: LD_VAR 0 3
79326: PPUSH
79327: LD_EXP 66
79331: PUSH
79332: LD_VAR 0 3
79336: ARRAY
79337: PUSH
79338: LD_VAR 0 1
79342: DIFF
79343: PPUSH
79344: CALL_OW 1
79348: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79349: LD_ADDR_EXP 59
79353: PUSH
79354: LD_EXP 59
79358: PPUSH
79359: LD_VAR 0 3
79363: PUSH
79364: LD_EXP 59
79368: PUSH
79369: LD_VAR 0 3
79373: ARRAY
79374: PUSH
79375: LD_INT 1
79377: PLUS
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: PPUSH
79383: LD_VAR 0 1
79387: PPUSH
79388: CALL 19238 0 3
79392: ST_TO_ADDR
// btype := GetBType ( building ) ;
79393: LD_ADDR_VAR 0 5
79397: PUSH
79398: LD_VAR 0 1
79402: PPUSH
79403: CALL_OW 266
79407: ST_TO_ADDR
// side := GetSide ( building ) ;
79408: LD_ADDR_VAR 0 8
79412: PUSH
79413: LD_VAR 0 1
79417: PPUSH
79418: CALL_OW 255
79422: ST_TO_ADDR
// if btype = b_lab then
79423: LD_VAR 0 5
79427: PUSH
79428: LD_INT 6
79430: EQUAL
79431: IFFALSE 79481
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79433: LD_ADDR_EXP 92
79437: PUSH
79438: LD_EXP 92
79442: PPUSH
79443: LD_VAR 0 3
79447: PUSH
79448: LD_EXP 92
79452: PUSH
79453: LD_VAR 0 3
79457: ARRAY
79458: PUSH
79459: LD_INT 1
79461: PLUS
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PPUSH
79467: LD_VAR 0 1
79471: PPUSH
79472: CALL 19238 0 3
79476: ST_TO_ADDR
// exit ;
79477: POP
79478: POP
79479: GO 79937
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79481: LD_VAR 0 5
79485: PUSH
79486: LD_INT 0
79488: PUSH
79489: LD_INT 2
79491: PUSH
79492: LD_INT 4
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: LIST
79499: IN
79500: IFFALSE 79624
// begin if btype = b_armoury then
79502: LD_VAR 0 5
79506: PUSH
79507: LD_INT 4
79509: EQUAL
79510: IFFALSE 79520
// btype := b_barracks ;
79512: LD_ADDR_VAR 0 5
79516: PUSH
79517: LD_INT 5
79519: ST_TO_ADDR
// if btype = b_depot then
79520: LD_VAR 0 5
79524: PUSH
79525: LD_INT 0
79527: EQUAL
79528: IFFALSE 79538
// btype := b_warehouse ;
79530: LD_ADDR_VAR 0 5
79534: PUSH
79535: LD_INT 1
79537: ST_TO_ADDR
// if btype = b_workshop then
79538: LD_VAR 0 5
79542: PUSH
79543: LD_INT 2
79545: EQUAL
79546: IFFALSE 79556
// btype := b_factory ;
79548: LD_ADDR_VAR 0 5
79552: PUSH
79553: LD_INT 3
79555: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79556: LD_VAR 0 5
79560: PPUSH
79561: LD_VAR 0 8
79565: PPUSH
79566: CALL_OW 323
79570: PUSH
79571: LD_INT 1
79573: EQUAL
79574: IFFALSE 79620
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79576: LD_ADDR_EXP 91
79580: PUSH
79581: LD_EXP 91
79585: PPUSH
79586: LD_VAR 0 3
79590: PUSH
79591: LD_EXP 91
79595: PUSH
79596: LD_VAR 0 3
79600: ARRAY
79601: PUSH
79602: LD_INT 1
79604: PLUS
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PPUSH
79610: LD_VAR 0 1
79614: PPUSH
79615: CALL 19238 0 3
79619: ST_TO_ADDR
// exit ;
79620: POP
79621: POP
79622: GO 79937
// end ; if btype in [ b_bunker , b_turret ] then
79624: LD_VAR 0 5
79628: PUSH
79629: LD_INT 32
79631: PUSH
79632: LD_INT 33
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: IN
79639: IFFALSE 79929
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79641: LD_ADDR_EXP 67
79645: PUSH
79646: LD_EXP 67
79650: PPUSH
79651: LD_VAR 0 3
79655: PUSH
79656: LD_EXP 67
79660: PUSH
79661: LD_VAR 0 3
79665: ARRAY
79666: PUSH
79667: LD_INT 1
79669: PLUS
79670: PUSH
79671: EMPTY
79672: LIST
79673: LIST
79674: PPUSH
79675: LD_VAR 0 1
79679: PPUSH
79680: CALL 19238 0 3
79684: ST_TO_ADDR
// if btype = b_bunker then
79685: LD_VAR 0 5
79689: PUSH
79690: LD_INT 32
79692: EQUAL
79693: IFFALSE 79929
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79695: LD_ADDR_EXP 68
79699: PUSH
79700: LD_EXP 68
79704: PPUSH
79705: LD_VAR 0 3
79709: PUSH
79710: LD_EXP 68
79714: PUSH
79715: LD_VAR 0 3
79719: ARRAY
79720: PUSH
79721: LD_INT 1
79723: PLUS
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PPUSH
79729: LD_VAR 0 1
79733: PPUSH
79734: CALL 19238 0 3
79738: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79739: LD_ADDR_VAR 0 6
79743: PUSH
79744: LD_EXP 59
79748: PUSH
79749: LD_VAR 0 3
79753: ARRAY
79754: PPUSH
79755: LD_INT 25
79757: PUSH
79758: LD_INT 1
79760: PUSH
79761: EMPTY
79762: LIST
79763: LIST
79764: PUSH
79765: LD_INT 3
79767: PUSH
79768: LD_INT 54
79770: PUSH
79771: EMPTY
79772: LIST
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: EMPTY
79779: LIST
79780: LIST
79781: PPUSH
79782: CALL_OW 72
79786: ST_TO_ADDR
// if tmp then
79787: LD_VAR 0 6
79791: IFFALSE 79797
// exit ;
79793: POP
79794: POP
79795: GO 79937
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79797: LD_ADDR_VAR 0 6
79801: PUSH
79802: LD_EXP 59
79806: PUSH
79807: LD_VAR 0 3
79811: ARRAY
79812: PPUSH
79813: LD_INT 2
79815: PUSH
79816: LD_INT 30
79818: PUSH
79819: LD_INT 4
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PUSH
79826: LD_INT 30
79828: PUSH
79829: LD_INT 5
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: LIST
79840: PPUSH
79841: CALL_OW 72
79845: ST_TO_ADDR
// if not tmp then
79846: LD_VAR 0 6
79850: NOT
79851: IFFALSE 79857
// exit ;
79853: POP
79854: POP
79855: GO 79937
// for j in tmp do
79857: LD_ADDR_VAR 0 4
79861: PUSH
79862: LD_VAR 0 6
79866: PUSH
79867: FOR_IN
79868: IFFALSE 79927
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79870: LD_ADDR_VAR 0 7
79874: PUSH
79875: LD_VAR 0 4
79879: PPUSH
79880: CALL_OW 313
79884: PPUSH
79885: LD_INT 25
79887: PUSH
79888: LD_INT 1
79890: PUSH
79891: EMPTY
79892: LIST
79893: LIST
79894: PPUSH
79895: CALL_OW 72
79899: ST_TO_ADDR
// if units then
79900: LD_VAR 0 7
79904: IFFALSE 79925
// begin ComExitBuilding ( units [ 1 ] ) ;
79906: LD_VAR 0 7
79910: PUSH
79911: LD_INT 1
79913: ARRAY
79914: PPUSH
79915: CALL_OW 122
// exit ;
79919: POP
79920: POP
79921: POP
79922: POP
79923: GO 79937
// end ; end ;
79925: GO 79867
79927: POP
79928: POP
// end ; end ; exit ;
79929: POP
79930: POP
79931: GO 79937
// end ; end ;
79933: GO 79291
79935: POP
79936: POP
// end ;
79937: LD_VAR 0 2
79941: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
79942: LD_INT 0
79944: PPUSH
79945: PPUSH
79946: PPUSH
79947: PPUSH
79948: PPUSH
79949: PPUSH
79950: PPUSH
// if not mc_bases or not skirmish then
79951: LD_EXP 59
79955: NOT
79956: PUSH
79957: LD_EXP 57
79961: NOT
79962: OR
79963: IFFALSE 79967
// exit ;
79965: GO 80198
// btype := GetBType ( building ) ;
79967: LD_ADDR_VAR 0 6
79971: PUSH
79972: LD_VAR 0 1
79976: PPUSH
79977: CALL_OW 266
79981: ST_TO_ADDR
// x := GetX ( building ) ;
79982: LD_ADDR_VAR 0 7
79986: PUSH
79987: LD_VAR 0 1
79991: PPUSH
79992: CALL_OW 250
79996: ST_TO_ADDR
// y := GetY ( building ) ;
79997: LD_ADDR_VAR 0 8
80001: PUSH
80002: LD_VAR 0 1
80006: PPUSH
80007: CALL_OW 251
80011: ST_TO_ADDR
// d := GetDir ( building ) ;
80012: LD_ADDR_VAR 0 9
80016: PUSH
80017: LD_VAR 0 1
80021: PPUSH
80022: CALL_OW 254
80026: ST_TO_ADDR
// for i = 1 to mc_bases do
80027: LD_ADDR_VAR 0 4
80031: PUSH
80032: DOUBLE
80033: LD_INT 1
80035: DEC
80036: ST_TO_ADDR
80037: LD_EXP 59
80041: PUSH
80042: FOR_TO
80043: IFFALSE 80196
// begin if not mc_build_list [ i ] then
80045: LD_EXP 64
80049: PUSH
80050: LD_VAR 0 4
80054: ARRAY
80055: NOT
80056: IFFALSE 80060
// continue ;
80058: GO 80042
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80060: LD_VAR 0 6
80064: PUSH
80065: LD_VAR 0 7
80069: PUSH
80070: LD_VAR 0 8
80074: PUSH
80075: LD_VAR 0 9
80079: PUSH
80080: EMPTY
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: PPUSH
80086: LD_EXP 64
80090: PUSH
80091: LD_VAR 0 4
80095: ARRAY
80096: PUSH
80097: LD_INT 1
80099: ARRAY
80100: PPUSH
80101: CALL 25407 0 2
80105: IFFALSE 80194
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
80107: LD_ADDR_EXP 64
80111: PUSH
80112: LD_EXP 64
80116: PPUSH
80117: LD_VAR 0 4
80121: PPUSH
80122: LD_EXP 64
80126: PUSH
80127: LD_VAR 0 4
80131: ARRAY
80132: PPUSH
80133: LD_INT 1
80135: PPUSH
80136: CALL_OW 3
80140: PPUSH
80141: CALL_OW 1
80145: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80146: LD_ADDR_EXP 66
80150: PUSH
80151: LD_EXP 66
80155: PPUSH
80156: LD_VAR 0 4
80160: PUSH
80161: LD_EXP 66
80165: PUSH
80166: LD_VAR 0 4
80170: ARRAY
80171: PUSH
80172: LD_INT 1
80174: PLUS
80175: PUSH
80176: EMPTY
80177: LIST
80178: LIST
80179: PPUSH
80180: LD_VAR 0 1
80184: PPUSH
80185: CALL 19238 0 3
80189: ST_TO_ADDR
// exit ;
80190: POP
80191: POP
80192: GO 80198
// end ; end ;
80194: GO 80042
80196: POP
80197: POP
// end ;
80198: LD_VAR 0 3
80202: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80203: LD_INT 0
80205: PPUSH
80206: PPUSH
80207: PPUSH
// if not mc_bases or not skirmish then
80208: LD_EXP 59
80212: NOT
80213: PUSH
80214: LD_EXP 57
80218: NOT
80219: OR
80220: IFFALSE 80224
// exit ;
80222: GO 80414
// for i = 1 to mc_bases do
80224: LD_ADDR_VAR 0 4
80228: PUSH
80229: DOUBLE
80230: LD_INT 1
80232: DEC
80233: ST_TO_ADDR
80234: LD_EXP 59
80238: PUSH
80239: FOR_TO
80240: IFFALSE 80327
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80242: LD_VAR 0 1
80246: PUSH
80247: LD_EXP 67
80251: PUSH
80252: LD_VAR 0 4
80256: ARRAY
80257: IN
80258: PUSH
80259: LD_VAR 0 1
80263: PUSH
80264: LD_EXP 68
80268: PUSH
80269: LD_VAR 0 4
80273: ARRAY
80274: IN
80275: NOT
80276: AND
80277: IFFALSE 80325
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80279: LD_ADDR_EXP 68
80283: PUSH
80284: LD_EXP 68
80288: PPUSH
80289: LD_VAR 0 4
80293: PUSH
80294: LD_EXP 68
80298: PUSH
80299: LD_VAR 0 4
80303: ARRAY
80304: PUSH
80305: LD_INT 1
80307: PLUS
80308: PUSH
80309: EMPTY
80310: LIST
80311: LIST
80312: PPUSH
80313: LD_VAR 0 1
80317: PPUSH
80318: CALL 19238 0 3
80322: ST_TO_ADDR
// break ;
80323: GO 80327
// end ; end ;
80325: GO 80239
80327: POP
80328: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80329: LD_VAR 0 1
80333: PPUSH
80334: CALL_OW 257
80338: PUSH
80339: LD_EXP 85
80343: IN
80344: PUSH
80345: LD_VAR 0 1
80349: PPUSH
80350: CALL_OW 266
80354: PUSH
80355: LD_INT 5
80357: EQUAL
80358: AND
80359: PUSH
80360: LD_VAR 0 2
80364: PPUSH
80365: CALL_OW 110
80369: PUSH
80370: LD_INT 18
80372: NONEQUAL
80373: AND
80374: IFFALSE 80414
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80376: LD_VAR 0 2
80380: PPUSH
80381: CALL_OW 257
80385: PUSH
80386: LD_INT 5
80388: PUSH
80389: LD_INT 8
80391: PUSH
80392: LD_INT 9
80394: PUSH
80395: EMPTY
80396: LIST
80397: LIST
80398: LIST
80399: IN
80400: IFFALSE 80414
// SetClass ( unit , 1 ) ;
80402: LD_VAR 0 2
80406: PPUSH
80407: LD_INT 1
80409: PPUSH
80410: CALL_OW 336
// end ;
80414: LD_VAR 0 3
80418: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80419: LD_INT 0
80421: PPUSH
80422: PPUSH
// if not mc_bases or not skirmish then
80423: LD_EXP 59
80427: NOT
80428: PUSH
80429: LD_EXP 57
80433: NOT
80434: OR
80435: IFFALSE 80439
// exit ;
80437: GO 80555
// if GetLives ( abandoned_vehicle ) > 250 then
80439: LD_VAR 0 2
80443: PPUSH
80444: CALL_OW 256
80448: PUSH
80449: LD_INT 250
80451: GREATER
80452: IFFALSE 80456
// exit ;
80454: GO 80555
// for i = 1 to mc_bases do
80456: LD_ADDR_VAR 0 6
80460: PUSH
80461: DOUBLE
80462: LD_INT 1
80464: DEC
80465: ST_TO_ADDR
80466: LD_EXP 59
80470: PUSH
80471: FOR_TO
80472: IFFALSE 80553
// begin if driver in mc_bases [ i ] then
80474: LD_VAR 0 1
80478: PUSH
80479: LD_EXP 59
80483: PUSH
80484: LD_VAR 0 6
80488: ARRAY
80489: IN
80490: IFFALSE 80551
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80492: LD_VAR 0 1
80496: PPUSH
80497: LD_EXP 59
80501: PUSH
80502: LD_VAR 0 6
80506: ARRAY
80507: PPUSH
80508: LD_INT 2
80510: PUSH
80511: LD_INT 30
80513: PUSH
80514: LD_INT 0
80516: PUSH
80517: EMPTY
80518: LIST
80519: LIST
80520: PUSH
80521: LD_INT 30
80523: PUSH
80524: LD_INT 1
80526: PUSH
80527: EMPTY
80528: LIST
80529: LIST
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: LIST
80535: PPUSH
80536: CALL_OW 72
80540: PUSH
80541: LD_INT 1
80543: ARRAY
80544: PPUSH
80545: CALL_OW 112
// break ;
80549: GO 80553
// end ; end ;
80551: GO 80471
80553: POP
80554: POP
// end ; end_of_file
80555: LD_VAR 0 5
80559: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; every 1 do
80560: GO 80562
80562: DISABLE
// begin ru_radar := 98 ;
80563: LD_ADDR_EXP 102
80567: PUSH
80568: LD_INT 98
80570: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80571: LD_ADDR_EXP 103
80575: PUSH
80576: LD_INT 89
80578: ST_TO_ADDR
// us_hack := 99 ;
80579: LD_ADDR_EXP 104
80583: PUSH
80584: LD_INT 99
80586: ST_TO_ADDR
// us_artillery := 97 ;
80587: LD_ADDR_EXP 105
80591: PUSH
80592: LD_INT 97
80594: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80595: LD_ADDR_EXP 106
80599: PUSH
80600: LD_INT 91
80602: ST_TO_ADDR
// tech_Artillery := 80 ;
80603: LD_ADDR_EXP 107
80607: PUSH
80608: LD_INT 80
80610: ST_TO_ADDR
// tech_RadMat := 81 ;
80611: LD_ADDR_EXP 108
80615: PUSH
80616: LD_INT 81
80618: ST_TO_ADDR
// tech_BasicTools := 82 ;
80619: LD_ADDR_EXP 109
80623: PUSH
80624: LD_INT 82
80626: ST_TO_ADDR
// tech_Cargo := 83 ;
80627: LD_ADDR_EXP 110
80631: PUSH
80632: LD_INT 83
80634: ST_TO_ADDR
// tech_Track := 84 ;
80635: LD_ADDR_EXP 111
80639: PUSH
80640: LD_INT 84
80642: ST_TO_ADDR
// tech_Crane := 85 ;
80643: LD_ADDR_EXP 112
80647: PUSH
80648: LD_INT 85
80650: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80651: LD_ADDR_EXP 113
80655: PUSH
80656: LD_INT 86
80658: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80659: LD_ADDR_EXP 114
80663: PUSH
80664: LD_INT 87
80666: ST_TO_ADDR
// end ; end_of_file end_of_file
80667: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
80668: GO 80670
80670: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
80671: LD_STRING initStreamRollete();
80673: PPUSH
80674: CALL_OW 559
// InitStreamMode ;
80678: CALL 80687 0 0
// DefineStreamItems ( ) ;
80682: CALL 81127 0 0
// end ;
80686: END
// function InitStreamMode ; begin
80687: LD_INT 0
80689: PPUSH
// streamModeActive := false ;
80690: LD_ADDR_EXP 115
80694: PUSH
80695: LD_INT 0
80697: ST_TO_ADDR
// normalCounter := 36 ;
80698: LD_ADDR_EXP 116
80702: PUSH
80703: LD_INT 36
80705: ST_TO_ADDR
// hardcoreCounter := 16 ;
80706: LD_ADDR_EXP 117
80710: PUSH
80711: LD_INT 16
80713: ST_TO_ADDR
// sRocket := false ;
80714: LD_ADDR_EXP 120
80718: PUSH
80719: LD_INT 0
80721: ST_TO_ADDR
// sSpeed := false ;
80722: LD_ADDR_EXP 119
80726: PUSH
80727: LD_INT 0
80729: ST_TO_ADDR
// sEngine := false ;
80730: LD_ADDR_EXP 121
80734: PUSH
80735: LD_INT 0
80737: ST_TO_ADDR
// sSpec := false ;
80738: LD_ADDR_EXP 118
80742: PUSH
80743: LD_INT 0
80745: ST_TO_ADDR
// sLevel := false ;
80746: LD_ADDR_EXP 122
80750: PUSH
80751: LD_INT 0
80753: ST_TO_ADDR
// sArmoury := false ;
80754: LD_ADDR_EXP 123
80758: PUSH
80759: LD_INT 0
80761: ST_TO_ADDR
// sRadar := false ;
80762: LD_ADDR_EXP 124
80766: PUSH
80767: LD_INT 0
80769: ST_TO_ADDR
// sBunker := false ;
80770: LD_ADDR_EXP 125
80774: PUSH
80775: LD_INT 0
80777: ST_TO_ADDR
// sHack := false ;
80778: LD_ADDR_EXP 126
80782: PUSH
80783: LD_INT 0
80785: ST_TO_ADDR
// sFire := false ;
80786: LD_ADDR_EXP 127
80790: PUSH
80791: LD_INT 0
80793: ST_TO_ADDR
// sRefresh := false ;
80794: LD_ADDR_EXP 128
80798: PUSH
80799: LD_INT 0
80801: ST_TO_ADDR
// sExp := false ;
80802: LD_ADDR_EXP 129
80806: PUSH
80807: LD_INT 0
80809: ST_TO_ADDR
// sDepot := false ;
80810: LD_ADDR_EXP 130
80814: PUSH
80815: LD_INT 0
80817: ST_TO_ADDR
// sFlag := false ;
80818: LD_ADDR_EXP 131
80822: PUSH
80823: LD_INT 0
80825: ST_TO_ADDR
// sKamikadze := false ;
80826: LD_ADDR_EXP 139
80830: PUSH
80831: LD_INT 0
80833: ST_TO_ADDR
// sTroll := false ;
80834: LD_ADDR_EXP 140
80838: PUSH
80839: LD_INT 0
80841: ST_TO_ADDR
// sSlow := false ;
80842: LD_ADDR_EXP 141
80846: PUSH
80847: LD_INT 0
80849: ST_TO_ADDR
// sLack := false ;
80850: LD_ADDR_EXP 142
80854: PUSH
80855: LD_INT 0
80857: ST_TO_ADDR
// sTank := false ;
80858: LD_ADDR_EXP 144
80862: PUSH
80863: LD_INT 0
80865: ST_TO_ADDR
// sRemote := false ;
80866: LD_ADDR_EXP 145
80870: PUSH
80871: LD_INT 0
80873: ST_TO_ADDR
// sPowell := false ;
80874: LD_ADDR_EXP 146
80878: PUSH
80879: LD_INT 0
80881: ST_TO_ADDR
// sTeleport := false ;
80882: LD_ADDR_EXP 149
80886: PUSH
80887: LD_INT 0
80889: ST_TO_ADDR
// sOilTower := false ;
80890: LD_ADDR_EXP 151
80894: PUSH
80895: LD_INT 0
80897: ST_TO_ADDR
// sShovel := false ;
80898: LD_ADDR_EXP 152
80902: PUSH
80903: LD_INT 0
80905: ST_TO_ADDR
// sSheik := false ;
80906: LD_ADDR_EXP 153
80910: PUSH
80911: LD_INT 0
80913: ST_TO_ADDR
// sEarthquake := false ;
80914: LD_ADDR_EXP 155
80918: PUSH
80919: LD_INT 0
80921: ST_TO_ADDR
// sAI := false ;
80922: LD_ADDR_EXP 156
80926: PUSH
80927: LD_INT 0
80929: ST_TO_ADDR
// sCargo := false ;
80930: LD_ADDR_EXP 159
80934: PUSH
80935: LD_INT 0
80937: ST_TO_ADDR
// sDLaser := false ;
80938: LD_ADDR_EXP 160
80942: PUSH
80943: LD_INT 0
80945: ST_TO_ADDR
// sExchange := false ;
80946: LD_ADDR_EXP 161
80950: PUSH
80951: LD_INT 0
80953: ST_TO_ADDR
// sFac := false ;
80954: LD_ADDR_EXP 162
80958: PUSH
80959: LD_INT 0
80961: ST_TO_ADDR
// sPower := false ;
80962: LD_ADDR_EXP 163
80966: PUSH
80967: LD_INT 0
80969: ST_TO_ADDR
// sRandom := false ;
80970: LD_ADDR_EXP 164
80974: PUSH
80975: LD_INT 0
80977: ST_TO_ADDR
// sShield := false ;
80978: LD_ADDR_EXP 165
80982: PUSH
80983: LD_INT 0
80985: ST_TO_ADDR
// sTime := false ;
80986: LD_ADDR_EXP 166
80990: PUSH
80991: LD_INT 0
80993: ST_TO_ADDR
// sTools := false ;
80994: LD_ADDR_EXP 167
80998: PUSH
80999: LD_INT 0
81001: ST_TO_ADDR
// sSold := false ;
81002: LD_ADDR_EXP 132
81006: PUSH
81007: LD_INT 0
81009: ST_TO_ADDR
// sDiff := false ;
81010: LD_ADDR_EXP 133
81014: PUSH
81015: LD_INT 0
81017: ST_TO_ADDR
// sFog := false ;
81018: LD_ADDR_EXP 136
81022: PUSH
81023: LD_INT 0
81025: ST_TO_ADDR
// sReset := false ;
81026: LD_ADDR_EXP 137
81030: PUSH
81031: LD_INT 0
81033: ST_TO_ADDR
// sSun := false ;
81034: LD_ADDR_EXP 138
81038: PUSH
81039: LD_INT 0
81041: ST_TO_ADDR
// sTiger := false ;
81042: LD_ADDR_EXP 134
81046: PUSH
81047: LD_INT 0
81049: ST_TO_ADDR
// sBomb := false ;
81050: LD_ADDR_EXP 135
81054: PUSH
81055: LD_INT 0
81057: ST_TO_ADDR
// sWound := false ;
81058: LD_ADDR_EXP 143
81062: PUSH
81063: LD_INT 0
81065: ST_TO_ADDR
// sBetray := false ;
81066: LD_ADDR_EXP 147
81070: PUSH
81071: LD_INT 0
81073: ST_TO_ADDR
// sContamin := false ;
81074: LD_ADDR_EXP 148
81078: PUSH
81079: LD_INT 0
81081: ST_TO_ADDR
// sOil := false ;
81082: LD_ADDR_EXP 150
81086: PUSH
81087: LD_INT 0
81089: ST_TO_ADDR
// sStu := false ;
81090: LD_ADDR_EXP 154
81094: PUSH
81095: LD_INT 0
81097: ST_TO_ADDR
// sBazooka := false ;
81098: LD_ADDR_EXP 157
81102: PUSH
81103: LD_INT 0
81105: ST_TO_ADDR
// sMortar := false ;
81106: LD_ADDR_EXP 158
81110: PUSH
81111: LD_INT 0
81113: ST_TO_ADDR
// sRanger := false ;
81114: LD_ADDR_EXP 168
81118: PUSH
81119: LD_INT 0
81121: ST_TO_ADDR
// end ;
81122: LD_VAR 0 1
81126: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
81127: LD_INT 0
81129: PPUSH
81130: PPUSH
81131: PPUSH
81132: PPUSH
81133: PPUSH
// result := [ ] ;
81134: LD_ADDR_VAR 0 1
81138: PUSH
81139: EMPTY
81140: ST_TO_ADDR
// if campaign_id = 1 then
81141: LD_OWVAR 69
81145: PUSH
81146: LD_INT 1
81148: EQUAL
81149: IFFALSE 84087
// begin case mission_number of 1 :
81151: LD_OWVAR 70
81155: PUSH
81156: LD_INT 1
81158: DOUBLE
81159: EQUAL
81160: IFTRUE 81164
81162: GO 81228
81164: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
81165: LD_ADDR_VAR 0 1
81169: PUSH
81170: LD_INT 2
81172: PUSH
81173: LD_INT 4
81175: PUSH
81176: LD_INT 11
81178: PUSH
81179: LD_INT 12
81181: PUSH
81182: LD_INT 15
81184: PUSH
81185: LD_INT 16
81187: PUSH
81188: LD_INT 22
81190: PUSH
81191: LD_INT 23
81193: PUSH
81194: LD_INT 26
81196: PUSH
81197: EMPTY
81198: LIST
81199: LIST
81200: LIST
81201: LIST
81202: LIST
81203: LIST
81204: LIST
81205: LIST
81206: LIST
81207: PUSH
81208: LD_INT 101
81210: PUSH
81211: LD_INT 102
81213: PUSH
81214: LD_INT 106
81216: PUSH
81217: EMPTY
81218: LIST
81219: LIST
81220: LIST
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: ST_TO_ADDR
81226: GO 84085
81228: LD_INT 2
81230: DOUBLE
81231: EQUAL
81232: IFTRUE 81236
81234: GO 81308
81236: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
81237: LD_ADDR_VAR 0 1
81241: PUSH
81242: LD_INT 2
81244: PUSH
81245: LD_INT 4
81247: PUSH
81248: LD_INT 11
81250: PUSH
81251: LD_INT 12
81253: PUSH
81254: LD_INT 15
81256: PUSH
81257: LD_INT 16
81259: PUSH
81260: LD_INT 22
81262: PUSH
81263: LD_INT 23
81265: PUSH
81266: LD_INT 26
81268: PUSH
81269: EMPTY
81270: LIST
81271: LIST
81272: LIST
81273: LIST
81274: LIST
81275: LIST
81276: LIST
81277: LIST
81278: LIST
81279: PUSH
81280: LD_INT 101
81282: PUSH
81283: LD_INT 102
81285: PUSH
81286: LD_INT 105
81288: PUSH
81289: LD_INT 106
81291: PUSH
81292: LD_INT 108
81294: PUSH
81295: EMPTY
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: PUSH
81302: EMPTY
81303: LIST
81304: LIST
81305: ST_TO_ADDR
81306: GO 84085
81308: LD_INT 3
81310: DOUBLE
81311: EQUAL
81312: IFTRUE 81316
81314: GO 81392
81316: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
81317: LD_ADDR_VAR 0 1
81321: PUSH
81322: LD_INT 2
81324: PUSH
81325: LD_INT 4
81327: PUSH
81328: LD_INT 5
81330: PUSH
81331: LD_INT 11
81333: PUSH
81334: LD_INT 12
81336: PUSH
81337: LD_INT 15
81339: PUSH
81340: LD_INT 16
81342: PUSH
81343: LD_INT 22
81345: PUSH
81346: LD_INT 26
81348: PUSH
81349: LD_INT 36
81351: PUSH
81352: EMPTY
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: LIST
81358: LIST
81359: LIST
81360: LIST
81361: LIST
81362: LIST
81363: PUSH
81364: LD_INT 101
81366: PUSH
81367: LD_INT 102
81369: PUSH
81370: LD_INT 105
81372: PUSH
81373: LD_INT 106
81375: PUSH
81376: LD_INT 108
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: LIST
81383: LIST
81384: LIST
81385: PUSH
81386: EMPTY
81387: LIST
81388: LIST
81389: ST_TO_ADDR
81390: GO 84085
81392: LD_INT 4
81394: DOUBLE
81395: EQUAL
81396: IFTRUE 81400
81398: GO 81484
81400: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
81401: LD_ADDR_VAR 0 1
81405: PUSH
81406: LD_INT 2
81408: PUSH
81409: LD_INT 4
81411: PUSH
81412: LD_INT 5
81414: PUSH
81415: LD_INT 8
81417: PUSH
81418: LD_INT 11
81420: PUSH
81421: LD_INT 12
81423: PUSH
81424: LD_INT 15
81426: PUSH
81427: LD_INT 16
81429: PUSH
81430: LD_INT 22
81432: PUSH
81433: LD_INT 23
81435: PUSH
81436: LD_INT 26
81438: PUSH
81439: LD_INT 36
81441: PUSH
81442: EMPTY
81443: LIST
81444: LIST
81445: LIST
81446: LIST
81447: LIST
81448: LIST
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: PUSH
81456: LD_INT 101
81458: PUSH
81459: LD_INT 102
81461: PUSH
81462: LD_INT 105
81464: PUSH
81465: LD_INT 106
81467: PUSH
81468: LD_INT 108
81470: PUSH
81471: EMPTY
81472: LIST
81473: LIST
81474: LIST
81475: LIST
81476: LIST
81477: PUSH
81478: EMPTY
81479: LIST
81480: LIST
81481: ST_TO_ADDR
81482: GO 84085
81484: LD_INT 5
81486: DOUBLE
81487: EQUAL
81488: IFTRUE 81492
81490: GO 81592
81492: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
81493: LD_ADDR_VAR 0 1
81497: PUSH
81498: LD_INT 2
81500: PUSH
81501: LD_INT 4
81503: PUSH
81504: LD_INT 5
81506: PUSH
81507: LD_INT 6
81509: PUSH
81510: LD_INT 8
81512: PUSH
81513: LD_INT 11
81515: PUSH
81516: LD_INT 12
81518: PUSH
81519: LD_INT 15
81521: PUSH
81522: LD_INT 16
81524: PUSH
81525: LD_INT 22
81527: PUSH
81528: LD_INT 23
81530: PUSH
81531: LD_INT 25
81533: PUSH
81534: LD_INT 26
81536: PUSH
81537: LD_INT 36
81539: PUSH
81540: EMPTY
81541: LIST
81542: LIST
81543: LIST
81544: LIST
81545: LIST
81546: LIST
81547: LIST
81548: LIST
81549: LIST
81550: LIST
81551: LIST
81552: LIST
81553: LIST
81554: LIST
81555: PUSH
81556: LD_INT 101
81558: PUSH
81559: LD_INT 102
81561: PUSH
81562: LD_INT 105
81564: PUSH
81565: LD_INT 106
81567: PUSH
81568: LD_INT 108
81570: PUSH
81571: LD_INT 109
81573: PUSH
81574: LD_INT 112
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: LIST
81581: LIST
81582: LIST
81583: LIST
81584: LIST
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: ST_TO_ADDR
81590: GO 84085
81592: LD_INT 6
81594: DOUBLE
81595: EQUAL
81596: IFTRUE 81600
81598: GO 81720
81600: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
81601: LD_ADDR_VAR 0 1
81605: PUSH
81606: LD_INT 2
81608: PUSH
81609: LD_INT 4
81611: PUSH
81612: LD_INT 5
81614: PUSH
81615: LD_INT 6
81617: PUSH
81618: LD_INT 8
81620: PUSH
81621: LD_INT 11
81623: PUSH
81624: LD_INT 12
81626: PUSH
81627: LD_INT 15
81629: PUSH
81630: LD_INT 16
81632: PUSH
81633: LD_INT 20
81635: PUSH
81636: LD_INT 21
81638: PUSH
81639: LD_INT 22
81641: PUSH
81642: LD_INT 23
81644: PUSH
81645: LD_INT 25
81647: PUSH
81648: LD_INT 26
81650: PUSH
81651: LD_INT 30
81653: PUSH
81654: LD_INT 31
81656: PUSH
81657: LD_INT 32
81659: PUSH
81660: LD_INT 36
81662: PUSH
81663: EMPTY
81664: LIST
81665: LIST
81666: LIST
81667: LIST
81668: LIST
81669: LIST
81670: LIST
81671: LIST
81672: LIST
81673: LIST
81674: LIST
81675: LIST
81676: LIST
81677: LIST
81678: LIST
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: PUSH
81684: LD_INT 101
81686: PUSH
81687: LD_INT 102
81689: PUSH
81690: LD_INT 105
81692: PUSH
81693: LD_INT 106
81695: PUSH
81696: LD_INT 108
81698: PUSH
81699: LD_INT 109
81701: PUSH
81702: LD_INT 112
81704: PUSH
81705: EMPTY
81706: LIST
81707: LIST
81708: LIST
81709: LIST
81710: LIST
81711: LIST
81712: LIST
81713: PUSH
81714: EMPTY
81715: LIST
81716: LIST
81717: ST_TO_ADDR
81718: GO 84085
81720: LD_INT 7
81722: DOUBLE
81723: EQUAL
81724: IFTRUE 81728
81726: GO 81828
81728: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
81729: LD_ADDR_VAR 0 1
81733: PUSH
81734: LD_INT 2
81736: PUSH
81737: LD_INT 4
81739: PUSH
81740: LD_INT 5
81742: PUSH
81743: LD_INT 7
81745: PUSH
81746: LD_INT 11
81748: PUSH
81749: LD_INT 12
81751: PUSH
81752: LD_INT 15
81754: PUSH
81755: LD_INT 16
81757: PUSH
81758: LD_INT 20
81760: PUSH
81761: LD_INT 21
81763: PUSH
81764: LD_INT 22
81766: PUSH
81767: LD_INT 23
81769: PUSH
81770: LD_INT 25
81772: PUSH
81773: LD_INT 26
81775: PUSH
81776: EMPTY
81777: LIST
81778: LIST
81779: LIST
81780: LIST
81781: LIST
81782: LIST
81783: LIST
81784: LIST
81785: LIST
81786: LIST
81787: LIST
81788: LIST
81789: LIST
81790: LIST
81791: PUSH
81792: LD_INT 101
81794: PUSH
81795: LD_INT 102
81797: PUSH
81798: LD_INT 103
81800: PUSH
81801: LD_INT 105
81803: PUSH
81804: LD_INT 106
81806: PUSH
81807: LD_INT 108
81809: PUSH
81810: LD_INT 112
81812: PUSH
81813: EMPTY
81814: LIST
81815: LIST
81816: LIST
81817: LIST
81818: LIST
81819: LIST
81820: LIST
81821: PUSH
81822: EMPTY
81823: LIST
81824: LIST
81825: ST_TO_ADDR
81826: GO 84085
81828: LD_INT 8
81830: DOUBLE
81831: EQUAL
81832: IFTRUE 81836
81834: GO 81964
81836: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
81837: LD_ADDR_VAR 0 1
81841: PUSH
81842: LD_INT 2
81844: PUSH
81845: LD_INT 4
81847: PUSH
81848: LD_INT 5
81850: PUSH
81851: LD_INT 6
81853: PUSH
81854: LD_INT 7
81856: PUSH
81857: LD_INT 8
81859: PUSH
81860: LD_INT 11
81862: PUSH
81863: LD_INT 12
81865: PUSH
81866: LD_INT 15
81868: PUSH
81869: LD_INT 16
81871: PUSH
81872: LD_INT 20
81874: PUSH
81875: LD_INT 21
81877: PUSH
81878: LD_INT 22
81880: PUSH
81881: LD_INT 23
81883: PUSH
81884: LD_INT 25
81886: PUSH
81887: LD_INT 26
81889: PUSH
81890: LD_INT 30
81892: PUSH
81893: LD_INT 31
81895: PUSH
81896: LD_INT 32
81898: PUSH
81899: LD_INT 36
81901: PUSH
81902: EMPTY
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: LIST
81915: LIST
81916: LIST
81917: LIST
81918: LIST
81919: LIST
81920: LIST
81921: LIST
81922: LIST
81923: PUSH
81924: LD_INT 101
81926: PUSH
81927: LD_INT 102
81929: PUSH
81930: LD_INT 103
81932: PUSH
81933: LD_INT 105
81935: PUSH
81936: LD_INT 106
81938: PUSH
81939: LD_INT 108
81941: PUSH
81942: LD_INT 109
81944: PUSH
81945: LD_INT 112
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: LIST
81955: LIST
81956: LIST
81957: PUSH
81958: EMPTY
81959: LIST
81960: LIST
81961: ST_TO_ADDR
81962: GO 84085
81964: LD_INT 9
81966: DOUBLE
81967: EQUAL
81968: IFTRUE 81972
81970: GO 82108
81972: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
81973: LD_ADDR_VAR 0 1
81977: PUSH
81978: LD_INT 2
81980: PUSH
81981: LD_INT 4
81983: PUSH
81984: LD_INT 5
81986: PUSH
81987: LD_INT 6
81989: PUSH
81990: LD_INT 7
81992: PUSH
81993: LD_INT 8
81995: PUSH
81996: LD_INT 11
81998: PUSH
81999: LD_INT 12
82001: PUSH
82002: LD_INT 15
82004: PUSH
82005: LD_INT 16
82007: PUSH
82008: LD_INT 20
82010: PUSH
82011: LD_INT 21
82013: PUSH
82014: LD_INT 22
82016: PUSH
82017: LD_INT 23
82019: PUSH
82020: LD_INT 25
82022: PUSH
82023: LD_INT 26
82025: PUSH
82026: LD_INT 28
82028: PUSH
82029: LD_INT 30
82031: PUSH
82032: LD_INT 31
82034: PUSH
82035: LD_INT 32
82037: PUSH
82038: LD_INT 36
82040: PUSH
82041: EMPTY
82042: LIST
82043: LIST
82044: LIST
82045: LIST
82046: LIST
82047: LIST
82048: LIST
82049: LIST
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: LIST
82058: LIST
82059: LIST
82060: LIST
82061: LIST
82062: LIST
82063: PUSH
82064: LD_INT 101
82066: PUSH
82067: LD_INT 102
82069: PUSH
82070: LD_INT 103
82072: PUSH
82073: LD_INT 105
82075: PUSH
82076: LD_INT 106
82078: PUSH
82079: LD_INT 108
82081: PUSH
82082: LD_INT 109
82084: PUSH
82085: LD_INT 112
82087: PUSH
82088: LD_INT 114
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: LIST
82095: LIST
82096: LIST
82097: LIST
82098: LIST
82099: LIST
82100: LIST
82101: PUSH
82102: EMPTY
82103: LIST
82104: LIST
82105: ST_TO_ADDR
82106: GO 84085
82108: LD_INT 10
82110: DOUBLE
82111: EQUAL
82112: IFTRUE 82116
82114: GO 82300
82116: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
82117: LD_ADDR_VAR 0 1
82121: PUSH
82122: LD_INT 2
82124: PUSH
82125: LD_INT 4
82127: PUSH
82128: LD_INT 5
82130: PUSH
82131: LD_INT 6
82133: PUSH
82134: LD_INT 7
82136: PUSH
82137: LD_INT 8
82139: PUSH
82140: LD_INT 9
82142: PUSH
82143: LD_INT 10
82145: PUSH
82146: LD_INT 11
82148: PUSH
82149: LD_INT 12
82151: PUSH
82152: LD_INT 13
82154: PUSH
82155: LD_INT 14
82157: PUSH
82158: LD_INT 15
82160: PUSH
82161: LD_INT 16
82163: PUSH
82164: LD_INT 17
82166: PUSH
82167: LD_INT 18
82169: PUSH
82170: LD_INT 19
82172: PUSH
82173: LD_INT 20
82175: PUSH
82176: LD_INT 21
82178: PUSH
82179: LD_INT 22
82181: PUSH
82182: LD_INT 23
82184: PUSH
82185: LD_INT 24
82187: PUSH
82188: LD_INT 25
82190: PUSH
82191: LD_INT 26
82193: PUSH
82194: LD_INT 28
82196: PUSH
82197: LD_INT 30
82199: PUSH
82200: LD_INT 31
82202: PUSH
82203: LD_INT 32
82205: PUSH
82206: LD_INT 36
82208: PUSH
82209: EMPTY
82210: LIST
82211: LIST
82212: LIST
82213: LIST
82214: LIST
82215: LIST
82216: LIST
82217: LIST
82218: LIST
82219: LIST
82220: LIST
82221: LIST
82222: LIST
82223: LIST
82224: LIST
82225: LIST
82226: LIST
82227: LIST
82228: LIST
82229: LIST
82230: LIST
82231: LIST
82232: LIST
82233: LIST
82234: LIST
82235: LIST
82236: LIST
82237: LIST
82238: LIST
82239: PUSH
82240: LD_INT 101
82242: PUSH
82243: LD_INT 102
82245: PUSH
82246: LD_INT 103
82248: PUSH
82249: LD_INT 104
82251: PUSH
82252: LD_INT 105
82254: PUSH
82255: LD_INT 106
82257: PUSH
82258: LD_INT 107
82260: PUSH
82261: LD_INT 108
82263: PUSH
82264: LD_INT 109
82266: PUSH
82267: LD_INT 110
82269: PUSH
82270: LD_INT 111
82272: PUSH
82273: LD_INT 112
82275: PUSH
82276: LD_INT 114
82278: PUSH
82279: EMPTY
82280: LIST
82281: LIST
82282: LIST
82283: LIST
82284: LIST
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: LIST
82290: LIST
82291: LIST
82292: LIST
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: ST_TO_ADDR
82298: GO 84085
82300: LD_INT 11
82302: DOUBLE
82303: EQUAL
82304: IFTRUE 82308
82306: GO 82500
82308: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
82309: LD_ADDR_VAR 0 1
82313: PUSH
82314: LD_INT 2
82316: PUSH
82317: LD_INT 3
82319: PUSH
82320: LD_INT 4
82322: PUSH
82323: LD_INT 5
82325: PUSH
82326: LD_INT 6
82328: PUSH
82329: LD_INT 7
82331: PUSH
82332: LD_INT 8
82334: PUSH
82335: LD_INT 9
82337: PUSH
82338: LD_INT 10
82340: PUSH
82341: LD_INT 11
82343: PUSH
82344: LD_INT 12
82346: PUSH
82347: LD_INT 13
82349: PUSH
82350: LD_INT 14
82352: PUSH
82353: LD_INT 15
82355: PUSH
82356: LD_INT 16
82358: PUSH
82359: LD_INT 17
82361: PUSH
82362: LD_INT 18
82364: PUSH
82365: LD_INT 19
82367: PUSH
82368: LD_INT 20
82370: PUSH
82371: LD_INT 21
82373: PUSH
82374: LD_INT 22
82376: PUSH
82377: LD_INT 23
82379: PUSH
82380: LD_INT 24
82382: PUSH
82383: LD_INT 25
82385: PUSH
82386: LD_INT 26
82388: PUSH
82389: LD_INT 28
82391: PUSH
82392: LD_INT 30
82394: PUSH
82395: LD_INT 31
82397: PUSH
82398: LD_INT 32
82400: PUSH
82401: LD_INT 34
82403: PUSH
82404: LD_INT 36
82406: PUSH
82407: EMPTY
82408: LIST
82409: LIST
82410: LIST
82411: LIST
82412: LIST
82413: LIST
82414: LIST
82415: LIST
82416: LIST
82417: LIST
82418: LIST
82419: LIST
82420: LIST
82421: LIST
82422: LIST
82423: LIST
82424: LIST
82425: LIST
82426: LIST
82427: LIST
82428: LIST
82429: LIST
82430: LIST
82431: LIST
82432: LIST
82433: LIST
82434: LIST
82435: LIST
82436: LIST
82437: LIST
82438: LIST
82439: PUSH
82440: LD_INT 101
82442: PUSH
82443: LD_INT 102
82445: PUSH
82446: LD_INT 103
82448: PUSH
82449: LD_INT 104
82451: PUSH
82452: LD_INT 105
82454: PUSH
82455: LD_INT 106
82457: PUSH
82458: LD_INT 107
82460: PUSH
82461: LD_INT 108
82463: PUSH
82464: LD_INT 109
82466: PUSH
82467: LD_INT 110
82469: PUSH
82470: LD_INT 111
82472: PUSH
82473: LD_INT 112
82475: PUSH
82476: LD_INT 114
82478: PUSH
82479: EMPTY
82480: LIST
82481: LIST
82482: LIST
82483: LIST
82484: LIST
82485: LIST
82486: LIST
82487: LIST
82488: LIST
82489: LIST
82490: LIST
82491: LIST
82492: LIST
82493: PUSH
82494: EMPTY
82495: LIST
82496: LIST
82497: ST_TO_ADDR
82498: GO 84085
82500: LD_INT 12
82502: DOUBLE
82503: EQUAL
82504: IFTRUE 82508
82506: GO 82716
82508: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
82509: LD_ADDR_VAR 0 1
82513: PUSH
82514: LD_INT 1
82516: PUSH
82517: LD_INT 2
82519: PUSH
82520: LD_INT 3
82522: PUSH
82523: LD_INT 4
82525: PUSH
82526: LD_INT 5
82528: PUSH
82529: LD_INT 6
82531: PUSH
82532: LD_INT 7
82534: PUSH
82535: LD_INT 8
82537: PUSH
82538: LD_INT 9
82540: PUSH
82541: LD_INT 10
82543: PUSH
82544: LD_INT 11
82546: PUSH
82547: LD_INT 12
82549: PUSH
82550: LD_INT 13
82552: PUSH
82553: LD_INT 14
82555: PUSH
82556: LD_INT 15
82558: PUSH
82559: LD_INT 16
82561: PUSH
82562: LD_INT 17
82564: PUSH
82565: LD_INT 18
82567: PUSH
82568: LD_INT 19
82570: PUSH
82571: LD_INT 20
82573: PUSH
82574: LD_INT 21
82576: PUSH
82577: LD_INT 22
82579: PUSH
82580: LD_INT 23
82582: PUSH
82583: LD_INT 24
82585: PUSH
82586: LD_INT 25
82588: PUSH
82589: LD_INT 26
82591: PUSH
82592: LD_INT 27
82594: PUSH
82595: LD_INT 28
82597: PUSH
82598: LD_INT 30
82600: PUSH
82601: LD_INT 31
82603: PUSH
82604: LD_INT 32
82606: PUSH
82607: LD_INT 33
82609: PUSH
82610: LD_INT 34
82612: PUSH
82613: LD_INT 36
82615: PUSH
82616: EMPTY
82617: LIST
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: LIST
82623: LIST
82624: LIST
82625: LIST
82626: LIST
82627: LIST
82628: LIST
82629: LIST
82630: LIST
82631: LIST
82632: LIST
82633: LIST
82634: LIST
82635: LIST
82636: LIST
82637: LIST
82638: LIST
82639: LIST
82640: LIST
82641: LIST
82642: LIST
82643: LIST
82644: LIST
82645: LIST
82646: LIST
82647: LIST
82648: LIST
82649: LIST
82650: LIST
82651: PUSH
82652: LD_INT 101
82654: PUSH
82655: LD_INT 102
82657: PUSH
82658: LD_INT 103
82660: PUSH
82661: LD_INT 104
82663: PUSH
82664: LD_INT 105
82666: PUSH
82667: LD_INT 106
82669: PUSH
82670: LD_INT 107
82672: PUSH
82673: LD_INT 108
82675: PUSH
82676: LD_INT 109
82678: PUSH
82679: LD_INT 110
82681: PUSH
82682: LD_INT 111
82684: PUSH
82685: LD_INT 112
82687: PUSH
82688: LD_INT 113
82690: PUSH
82691: LD_INT 114
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: LIST
82702: LIST
82703: LIST
82704: LIST
82705: LIST
82706: LIST
82707: LIST
82708: LIST
82709: PUSH
82710: EMPTY
82711: LIST
82712: LIST
82713: ST_TO_ADDR
82714: GO 84085
82716: LD_INT 13
82718: DOUBLE
82719: EQUAL
82720: IFTRUE 82724
82722: GO 82920
82724: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
82725: LD_ADDR_VAR 0 1
82729: PUSH
82730: LD_INT 1
82732: PUSH
82733: LD_INT 2
82735: PUSH
82736: LD_INT 3
82738: PUSH
82739: LD_INT 4
82741: PUSH
82742: LD_INT 5
82744: PUSH
82745: LD_INT 8
82747: PUSH
82748: LD_INT 9
82750: PUSH
82751: LD_INT 10
82753: PUSH
82754: LD_INT 11
82756: PUSH
82757: LD_INT 12
82759: PUSH
82760: LD_INT 14
82762: PUSH
82763: LD_INT 15
82765: PUSH
82766: LD_INT 16
82768: PUSH
82769: LD_INT 17
82771: PUSH
82772: LD_INT 18
82774: PUSH
82775: LD_INT 19
82777: PUSH
82778: LD_INT 20
82780: PUSH
82781: LD_INT 21
82783: PUSH
82784: LD_INT 22
82786: PUSH
82787: LD_INT 23
82789: PUSH
82790: LD_INT 24
82792: PUSH
82793: LD_INT 25
82795: PUSH
82796: LD_INT 26
82798: PUSH
82799: LD_INT 27
82801: PUSH
82802: LD_INT 28
82804: PUSH
82805: LD_INT 30
82807: PUSH
82808: LD_INT 31
82810: PUSH
82811: LD_INT 32
82813: PUSH
82814: LD_INT 33
82816: PUSH
82817: LD_INT 34
82819: PUSH
82820: LD_INT 36
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: LIST
82827: LIST
82828: LIST
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: LIST
82835: LIST
82836: LIST
82837: LIST
82838: LIST
82839: LIST
82840: LIST
82841: LIST
82842: LIST
82843: LIST
82844: LIST
82845: LIST
82846: LIST
82847: LIST
82848: LIST
82849: LIST
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: PUSH
82856: LD_INT 101
82858: PUSH
82859: LD_INT 102
82861: PUSH
82862: LD_INT 103
82864: PUSH
82865: LD_INT 104
82867: PUSH
82868: LD_INT 105
82870: PUSH
82871: LD_INT 106
82873: PUSH
82874: LD_INT 107
82876: PUSH
82877: LD_INT 108
82879: PUSH
82880: LD_INT 109
82882: PUSH
82883: LD_INT 110
82885: PUSH
82886: LD_INT 111
82888: PUSH
82889: LD_INT 112
82891: PUSH
82892: LD_INT 113
82894: PUSH
82895: LD_INT 114
82897: PUSH
82898: EMPTY
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: LIST
82906: LIST
82907: LIST
82908: LIST
82909: LIST
82910: LIST
82911: LIST
82912: LIST
82913: PUSH
82914: EMPTY
82915: LIST
82916: LIST
82917: ST_TO_ADDR
82918: GO 84085
82920: LD_INT 14
82922: DOUBLE
82923: EQUAL
82924: IFTRUE 82928
82926: GO 83140
82928: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
82929: LD_ADDR_VAR 0 1
82933: PUSH
82934: LD_INT 1
82936: PUSH
82937: LD_INT 2
82939: PUSH
82940: LD_INT 3
82942: PUSH
82943: LD_INT 4
82945: PUSH
82946: LD_INT 5
82948: PUSH
82949: LD_INT 6
82951: PUSH
82952: LD_INT 7
82954: PUSH
82955: LD_INT 8
82957: PUSH
82958: LD_INT 9
82960: PUSH
82961: LD_INT 10
82963: PUSH
82964: LD_INT 11
82966: PUSH
82967: LD_INT 12
82969: PUSH
82970: LD_INT 13
82972: PUSH
82973: LD_INT 14
82975: PUSH
82976: LD_INT 15
82978: PUSH
82979: LD_INT 16
82981: PUSH
82982: LD_INT 17
82984: PUSH
82985: LD_INT 18
82987: PUSH
82988: LD_INT 19
82990: PUSH
82991: LD_INT 20
82993: PUSH
82994: LD_INT 21
82996: PUSH
82997: LD_INT 22
82999: PUSH
83000: LD_INT 23
83002: PUSH
83003: LD_INT 24
83005: PUSH
83006: LD_INT 25
83008: PUSH
83009: LD_INT 26
83011: PUSH
83012: LD_INT 27
83014: PUSH
83015: LD_INT 28
83017: PUSH
83018: LD_INT 29
83020: PUSH
83021: LD_INT 30
83023: PUSH
83024: LD_INT 31
83026: PUSH
83027: LD_INT 32
83029: PUSH
83030: LD_INT 33
83032: PUSH
83033: LD_INT 34
83035: PUSH
83036: LD_INT 36
83038: PUSH
83039: EMPTY
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: LIST
83050: LIST
83051: LIST
83052: LIST
83053: LIST
83054: LIST
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: LIST
83060: LIST
83061: LIST
83062: LIST
83063: LIST
83064: LIST
83065: LIST
83066: LIST
83067: LIST
83068: LIST
83069: LIST
83070: LIST
83071: LIST
83072: LIST
83073: LIST
83074: LIST
83075: PUSH
83076: LD_INT 101
83078: PUSH
83079: LD_INT 102
83081: PUSH
83082: LD_INT 103
83084: PUSH
83085: LD_INT 104
83087: PUSH
83088: LD_INT 105
83090: PUSH
83091: LD_INT 106
83093: PUSH
83094: LD_INT 107
83096: PUSH
83097: LD_INT 108
83099: PUSH
83100: LD_INT 109
83102: PUSH
83103: LD_INT 110
83105: PUSH
83106: LD_INT 111
83108: PUSH
83109: LD_INT 112
83111: PUSH
83112: LD_INT 113
83114: PUSH
83115: LD_INT 114
83117: PUSH
83118: EMPTY
83119: LIST
83120: LIST
83121: LIST
83122: LIST
83123: LIST
83124: LIST
83125: LIST
83126: LIST
83127: LIST
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: PUSH
83134: EMPTY
83135: LIST
83136: LIST
83137: ST_TO_ADDR
83138: GO 84085
83140: LD_INT 15
83142: DOUBLE
83143: EQUAL
83144: IFTRUE 83148
83146: GO 83360
83148: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
83149: LD_ADDR_VAR 0 1
83153: PUSH
83154: LD_INT 1
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: LD_INT 3
83162: PUSH
83163: LD_INT 4
83165: PUSH
83166: LD_INT 5
83168: PUSH
83169: LD_INT 6
83171: PUSH
83172: LD_INT 7
83174: PUSH
83175: LD_INT 8
83177: PUSH
83178: LD_INT 9
83180: PUSH
83181: LD_INT 10
83183: PUSH
83184: LD_INT 11
83186: PUSH
83187: LD_INT 12
83189: PUSH
83190: LD_INT 13
83192: PUSH
83193: LD_INT 14
83195: PUSH
83196: LD_INT 15
83198: PUSH
83199: LD_INT 16
83201: PUSH
83202: LD_INT 17
83204: PUSH
83205: LD_INT 18
83207: PUSH
83208: LD_INT 19
83210: PUSH
83211: LD_INT 20
83213: PUSH
83214: LD_INT 21
83216: PUSH
83217: LD_INT 22
83219: PUSH
83220: LD_INT 23
83222: PUSH
83223: LD_INT 24
83225: PUSH
83226: LD_INT 25
83228: PUSH
83229: LD_INT 26
83231: PUSH
83232: LD_INT 27
83234: PUSH
83235: LD_INT 28
83237: PUSH
83238: LD_INT 29
83240: PUSH
83241: LD_INT 30
83243: PUSH
83244: LD_INT 31
83246: PUSH
83247: LD_INT 32
83249: PUSH
83250: LD_INT 33
83252: PUSH
83253: LD_INT 34
83255: PUSH
83256: LD_INT 36
83258: PUSH
83259: EMPTY
83260: LIST
83261: LIST
83262: LIST
83263: LIST
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: LIST
83275: LIST
83276: LIST
83277: LIST
83278: LIST
83279: LIST
83280: LIST
83281: LIST
83282: LIST
83283: LIST
83284: LIST
83285: LIST
83286: LIST
83287: LIST
83288: LIST
83289: LIST
83290: LIST
83291: LIST
83292: LIST
83293: LIST
83294: LIST
83295: PUSH
83296: LD_INT 101
83298: PUSH
83299: LD_INT 102
83301: PUSH
83302: LD_INT 103
83304: PUSH
83305: LD_INT 104
83307: PUSH
83308: LD_INT 105
83310: PUSH
83311: LD_INT 106
83313: PUSH
83314: LD_INT 107
83316: PUSH
83317: LD_INT 108
83319: PUSH
83320: LD_INT 109
83322: PUSH
83323: LD_INT 110
83325: PUSH
83326: LD_INT 111
83328: PUSH
83329: LD_INT 112
83331: PUSH
83332: LD_INT 113
83334: PUSH
83335: LD_INT 114
83337: PUSH
83338: EMPTY
83339: LIST
83340: LIST
83341: LIST
83342: LIST
83343: LIST
83344: LIST
83345: LIST
83346: LIST
83347: LIST
83348: LIST
83349: LIST
83350: LIST
83351: LIST
83352: LIST
83353: PUSH
83354: EMPTY
83355: LIST
83356: LIST
83357: ST_TO_ADDR
83358: GO 84085
83360: LD_INT 16
83362: DOUBLE
83363: EQUAL
83364: IFTRUE 83368
83366: GO 83492
83368: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
83369: LD_ADDR_VAR 0 1
83373: PUSH
83374: LD_INT 2
83376: PUSH
83377: LD_INT 4
83379: PUSH
83380: LD_INT 5
83382: PUSH
83383: LD_INT 7
83385: PUSH
83386: LD_INT 11
83388: PUSH
83389: LD_INT 12
83391: PUSH
83392: LD_INT 15
83394: PUSH
83395: LD_INT 16
83397: PUSH
83398: LD_INT 20
83400: PUSH
83401: LD_INT 21
83403: PUSH
83404: LD_INT 22
83406: PUSH
83407: LD_INT 23
83409: PUSH
83410: LD_INT 25
83412: PUSH
83413: LD_INT 26
83415: PUSH
83416: LD_INT 30
83418: PUSH
83419: LD_INT 31
83421: PUSH
83422: LD_INT 32
83424: PUSH
83425: LD_INT 33
83427: PUSH
83428: LD_INT 34
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: LIST
83435: LIST
83436: LIST
83437: LIST
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: LIST
83443: LIST
83444: LIST
83445: LIST
83446: LIST
83447: LIST
83448: LIST
83449: LIST
83450: LIST
83451: PUSH
83452: LD_INT 101
83454: PUSH
83455: LD_INT 102
83457: PUSH
83458: LD_INT 103
83460: PUSH
83461: LD_INT 106
83463: PUSH
83464: LD_INT 108
83466: PUSH
83467: LD_INT 112
83469: PUSH
83470: LD_INT 113
83472: PUSH
83473: LD_INT 114
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: PUSH
83486: EMPTY
83487: LIST
83488: LIST
83489: ST_TO_ADDR
83490: GO 84085
83492: LD_INT 17
83494: DOUBLE
83495: EQUAL
83496: IFTRUE 83500
83498: GO 83712
83500: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
83501: LD_ADDR_VAR 0 1
83505: PUSH
83506: LD_INT 1
83508: PUSH
83509: LD_INT 2
83511: PUSH
83512: LD_INT 3
83514: PUSH
83515: LD_INT 4
83517: PUSH
83518: LD_INT 5
83520: PUSH
83521: LD_INT 6
83523: PUSH
83524: LD_INT 7
83526: PUSH
83527: LD_INT 8
83529: PUSH
83530: LD_INT 9
83532: PUSH
83533: LD_INT 10
83535: PUSH
83536: LD_INT 11
83538: PUSH
83539: LD_INT 12
83541: PUSH
83542: LD_INT 13
83544: PUSH
83545: LD_INT 14
83547: PUSH
83548: LD_INT 15
83550: PUSH
83551: LD_INT 16
83553: PUSH
83554: LD_INT 17
83556: PUSH
83557: LD_INT 18
83559: PUSH
83560: LD_INT 19
83562: PUSH
83563: LD_INT 20
83565: PUSH
83566: LD_INT 21
83568: PUSH
83569: LD_INT 22
83571: PUSH
83572: LD_INT 23
83574: PUSH
83575: LD_INT 24
83577: PUSH
83578: LD_INT 25
83580: PUSH
83581: LD_INT 26
83583: PUSH
83584: LD_INT 27
83586: PUSH
83587: LD_INT 28
83589: PUSH
83590: LD_INT 29
83592: PUSH
83593: LD_INT 30
83595: PUSH
83596: LD_INT 31
83598: PUSH
83599: LD_INT 32
83601: PUSH
83602: LD_INT 33
83604: PUSH
83605: LD_INT 34
83607: PUSH
83608: LD_INT 36
83610: PUSH
83611: EMPTY
83612: LIST
83613: LIST
83614: LIST
83615: LIST
83616: LIST
83617: LIST
83618: LIST
83619: LIST
83620: LIST
83621: LIST
83622: LIST
83623: LIST
83624: LIST
83625: LIST
83626: LIST
83627: LIST
83628: LIST
83629: LIST
83630: LIST
83631: LIST
83632: LIST
83633: LIST
83634: LIST
83635: LIST
83636: LIST
83637: LIST
83638: LIST
83639: LIST
83640: LIST
83641: LIST
83642: LIST
83643: LIST
83644: LIST
83645: LIST
83646: LIST
83647: PUSH
83648: LD_INT 101
83650: PUSH
83651: LD_INT 102
83653: PUSH
83654: LD_INT 103
83656: PUSH
83657: LD_INT 104
83659: PUSH
83660: LD_INT 105
83662: PUSH
83663: LD_INT 106
83665: PUSH
83666: LD_INT 107
83668: PUSH
83669: LD_INT 108
83671: PUSH
83672: LD_INT 109
83674: PUSH
83675: LD_INT 110
83677: PUSH
83678: LD_INT 111
83680: PUSH
83681: LD_INT 112
83683: PUSH
83684: LD_INT 113
83686: PUSH
83687: LD_INT 114
83689: PUSH
83690: EMPTY
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: PUSH
83706: EMPTY
83707: LIST
83708: LIST
83709: ST_TO_ADDR
83710: GO 84085
83712: LD_INT 18
83714: DOUBLE
83715: EQUAL
83716: IFTRUE 83720
83718: GO 83856
83720: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
83721: LD_ADDR_VAR 0 1
83725: PUSH
83726: LD_INT 2
83728: PUSH
83729: LD_INT 4
83731: PUSH
83732: LD_INT 5
83734: PUSH
83735: LD_INT 7
83737: PUSH
83738: LD_INT 11
83740: PUSH
83741: LD_INT 12
83743: PUSH
83744: LD_INT 15
83746: PUSH
83747: LD_INT 16
83749: PUSH
83750: LD_INT 20
83752: PUSH
83753: LD_INT 21
83755: PUSH
83756: LD_INT 22
83758: PUSH
83759: LD_INT 23
83761: PUSH
83762: LD_INT 25
83764: PUSH
83765: LD_INT 26
83767: PUSH
83768: LD_INT 30
83770: PUSH
83771: LD_INT 31
83773: PUSH
83774: LD_INT 32
83776: PUSH
83777: LD_INT 33
83779: PUSH
83780: LD_INT 34
83782: PUSH
83783: LD_INT 35
83785: PUSH
83786: LD_INT 36
83788: PUSH
83789: EMPTY
83790: LIST
83791: LIST
83792: LIST
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: PUSH
83812: LD_INT 101
83814: PUSH
83815: LD_INT 102
83817: PUSH
83818: LD_INT 103
83820: PUSH
83821: LD_INT 106
83823: PUSH
83824: LD_INT 108
83826: PUSH
83827: LD_INT 112
83829: PUSH
83830: LD_INT 113
83832: PUSH
83833: LD_INT 114
83835: PUSH
83836: LD_INT 115
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: LIST
83848: LIST
83849: PUSH
83850: EMPTY
83851: LIST
83852: LIST
83853: ST_TO_ADDR
83854: GO 84085
83856: LD_INT 19
83858: DOUBLE
83859: EQUAL
83860: IFTRUE 83864
83862: GO 84084
83864: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
83865: LD_ADDR_VAR 0 1
83869: PUSH
83870: LD_INT 1
83872: PUSH
83873: LD_INT 2
83875: PUSH
83876: LD_INT 3
83878: PUSH
83879: LD_INT 4
83881: PUSH
83882: LD_INT 5
83884: PUSH
83885: LD_INT 6
83887: PUSH
83888: LD_INT 7
83890: PUSH
83891: LD_INT 8
83893: PUSH
83894: LD_INT 9
83896: PUSH
83897: LD_INT 10
83899: PUSH
83900: LD_INT 11
83902: PUSH
83903: LD_INT 12
83905: PUSH
83906: LD_INT 13
83908: PUSH
83909: LD_INT 14
83911: PUSH
83912: LD_INT 15
83914: PUSH
83915: LD_INT 16
83917: PUSH
83918: LD_INT 17
83920: PUSH
83921: LD_INT 18
83923: PUSH
83924: LD_INT 19
83926: PUSH
83927: LD_INT 20
83929: PUSH
83930: LD_INT 21
83932: PUSH
83933: LD_INT 22
83935: PUSH
83936: LD_INT 23
83938: PUSH
83939: LD_INT 24
83941: PUSH
83942: LD_INT 25
83944: PUSH
83945: LD_INT 26
83947: PUSH
83948: LD_INT 27
83950: PUSH
83951: LD_INT 28
83953: PUSH
83954: LD_INT 29
83956: PUSH
83957: LD_INT 30
83959: PUSH
83960: LD_INT 31
83962: PUSH
83963: LD_INT 32
83965: PUSH
83966: LD_INT 33
83968: PUSH
83969: LD_INT 34
83971: PUSH
83972: LD_INT 35
83974: PUSH
83975: LD_INT 36
83977: PUSH
83978: EMPTY
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: LIST
83984: LIST
83985: LIST
83986: LIST
83987: LIST
83988: LIST
83989: LIST
83990: LIST
83991: LIST
83992: LIST
83993: LIST
83994: LIST
83995: LIST
83996: LIST
83997: LIST
83998: LIST
83999: LIST
84000: LIST
84001: LIST
84002: LIST
84003: LIST
84004: LIST
84005: LIST
84006: LIST
84007: LIST
84008: LIST
84009: LIST
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: PUSH
84016: LD_INT 101
84018: PUSH
84019: LD_INT 102
84021: PUSH
84022: LD_INT 103
84024: PUSH
84025: LD_INT 104
84027: PUSH
84028: LD_INT 105
84030: PUSH
84031: LD_INT 106
84033: PUSH
84034: LD_INT 107
84036: PUSH
84037: LD_INT 108
84039: PUSH
84040: LD_INT 109
84042: PUSH
84043: LD_INT 110
84045: PUSH
84046: LD_INT 111
84048: PUSH
84049: LD_INT 112
84051: PUSH
84052: LD_INT 113
84054: PUSH
84055: LD_INT 114
84057: PUSH
84058: LD_INT 115
84060: PUSH
84061: EMPTY
84062: LIST
84063: LIST
84064: LIST
84065: LIST
84066: LIST
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: ST_TO_ADDR
84082: GO 84085
84084: POP
// end else
84085: GO 84304
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
84087: LD_ADDR_VAR 0 1
84091: PUSH
84092: LD_INT 1
84094: PUSH
84095: LD_INT 2
84097: PUSH
84098: LD_INT 3
84100: PUSH
84101: LD_INT 4
84103: PUSH
84104: LD_INT 5
84106: PUSH
84107: LD_INT 6
84109: PUSH
84110: LD_INT 7
84112: PUSH
84113: LD_INT 8
84115: PUSH
84116: LD_INT 9
84118: PUSH
84119: LD_INT 10
84121: PUSH
84122: LD_INT 11
84124: PUSH
84125: LD_INT 12
84127: PUSH
84128: LD_INT 13
84130: PUSH
84131: LD_INT 14
84133: PUSH
84134: LD_INT 15
84136: PUSH
84137: LD_INT 16
84139: PUSH
84140: LD_INT 17
84142: PUSH
84143: LD_INT 18
84145: PUSH
84146: LD_INT 19
84148: PUSH
84149: LD_INT 20
84151: PUSH
84152: LD_INT 21
84154: PUSH
84155: LD_INT 22
84157: PUSH
84158: LD_INT 23
84160: PUSH
84161: LD_INT 24
84163: PUSH
84164: LD_INT 25
84166: PUSH
84167: LD_INT 26
84169: PUSH
84170: LD_INT 27
84172: PUSH
84173: LD_INT 28
84175: PUSH
84176: LD_INT 29
84178: PUSH
84179: LD_INT 30
84181: PUSH
84182: LD_INT 31
84184: PUSH
84185: LD_INT 32
84187: PUSH
84188: LD_INT 33
84190: PUSH
84191: LD_INT 34
84193: PUSH
84194: LD_INT 35
84196: PUSH
84197: LD_INT 36
84199: PUSH
84200: EMPTY
84201: LIST
84202: LIST
84203: LIST
84204: LIST
84205: LIST
84206: LIST
84207: LIST
84208: LIST
84209: LIST
84210: LIST
84211: LIST
84212: LIST
84213: LIST
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: LIST
84233: LIST
84234: LIST
84235: LIST
84236: LIST
84237: PUSH
84238: LD_INT 101
84240: PUSH
84241: LD_INT 102
84243: PUSH
84244: LD_INT 103
84246: PUSH
84247: LD_INT 104
84249: PUSH
84250: LD_INT 105
84252: PUSH
84253: LD_INT 106
84255: PUSH
84256: LD_INT 107
84258: PUSH
84259: LD_INT 108
84261: PUSH
84262: LD_INT 109
84264: PUSH
84265: LD_INT 110
84267: PUSH
84268: LD_INT 111
84270: PUSH
84271: LD_INT 112
84273: PUSH
84274: LD_INT 113
84276: PUSH
84277: LD_INT 114
84279: PUSH
84280: LD_INT 115
84282: PUSH
84283: EMPTY
84284: LIST
84285: LIST
84286: LIST
84287: LIST
84288: LIST
84289: LIST
84290: LIST
84291: LIST
84292: LIST
84293: LIST
84294: LIST
84295: LIST
84296: LIST
84297: LIST
84298: LIST
84299: PUSH
84300: EMPTY
84301: LIST
84302: LIST
84303: ST_TO_ADDR
// if result then
84304: LD_VAR 0 1
84308: IFFALSE 84597
// begin normal :=  ;
84310: LD_ADDR_VAR 0 3
84314: PUSH
84315: LD_STRING 
84317: ST_TO_ADDR
// hardcore :=  ;
84318: LD_ADDR_VAR 0 4
84322: PUSH
84323: LD_STRING 
84325: ST_TO_ADDR
// for i = 1 to normalCounter do
84326: LD_ADDR_VAR 0 5
84330: PUSH
84331: DOUBLE
84332: LD_INT 1
84334: DEC
84335: ST_TO_ADDR
84336: LD_EXP 116
84340: PUSH
84341: FOR_TO
84342: IFFALSE 84443
// begin tmp := 0 ;
84344: LD_ADDR_VAR 0 2
84348: PUSH
84349: LD_STRING 0
84351: ST_TO_ADDR
// if result [ 1 ] then
84352: LD_VAR 0 1
84356: PUSH
84357: LD_INT 1
84359: ARRAY
84360: IFFALSE 84425
// if result [ 1 ] [ 1 ] = i then
84362: LD_VAR 0 1
84366: PUSH
84367: LD_INT 1
84369: ARRAY
84370: PUSH
84371: LD_INT 1
84373: ARRAY
84374: PUSH
84375: LD_VAR 0 5
84379: EQUAL
84380: IFFALSE 84425
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
84382: LD_ADDR_VAR 0 1
84386: PUSH
84387: LD_VAR 0 1
84391: PPUSH
84392: LD_INT 1
84394: PPUSH
84395: LD_VAR 0 1
84399: PUSH
84400: LD_INT 1
84402: ARRAY
84403: PPUSH
84404: LD_INT 1
84406: PPUSH
84407: CALL_OW 3
84411: PPUSH
84412: CALL_OW 1
84416: ST_TO_ADDR
// tmp := 1 ;
84417: LD_ADDR_VAR 0 2
84421: PUSH
84422: LD_STRING 1
84424: ST_TO_ADDR
// end ; normal := normal & tmp ;
84425: LD_ADDR_VAR 0 3
84429: PUSH
84430: LD_VAR 0 3
84434: PUSH
84435: LD_VAR 0 2
84439: STR
84440: ST_TO_ADDR
// end ;
84441: GO 84341
84443: POP
84444: POP
// for i = 1 to hardcoreCounter do
84445: LD_ADDR_VAR 0 5
84449: PUSH
84450: DOUBLE
84451: LD_INT 1
84453: DEC
84454: ST_TO_ADDR
84455: LD_EXP 117
84459: PUSH
84460: FOR_TO
84461: IFFALSE 84566
// begin tmp := 0 ;
84463: LD_ADDR_VAR 0 2
84467: PUSH
84468: LD_STRING 0
84470: ST_TO_ADDR
// if result [ 2 ] then
84471: LD_VAR 0 1
84475: PUSH
84476: LD_INT 2
84478: ARRAY
84479: IFFALSE 84548
// if result [ 2 ] [ 1 ] = 100 + i then
84481: LD_VAR 0 1
84485: PUSH
84486: LD_INT 2
84488: ARRAY
84489: PUSH
84490: LD_INT 1
84492: ARRAY
84493: PUSH
84494: LD_INT 100
84496: PUSH
84497: LD_VAR 0 5
84501: PLUS
84502: EQUAL
84503: IFFALSE 84548
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
84505: LD_ADDR_VAR 0 1
84509: PUSH
84510: LD_VAR 0 1
84514: PPUSH
84515: LD_INT 2
84517: PPUSH
84518: LD_VAR 0 1
84522: PUSH
84523: LD_INT 2
84525: ARRAY
84526: PPUSH
84527: LD_INT 1
84529: PPUSH
84530: CALL_OW 3
84534: PPUSH
84535: CALL_OW 1
84539: ST_TO_ADDR
// tmp := 1 ;
84540: LD_ADDR_VAR 0 2
84544: PUSH
84545: LD_STRING 1
84547: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
84548: LD_ADDR_VAR 0 4
84552: PUSH
84553: LD_VAR 0 4
84557: PUSH
84558: LD_VAR 0 2
84562: STR
84563: ST_TO_ADDR
// end ;
84564: GO 84460
84566: POP
84567: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
84568: LD_STRING getStreamItemsFromMission("
84570: PUSH
84571: LD_VAR 0 3
84575: STR
84576: PUSH
84577: LD_STRING ","
84579: STR
84580: PUSH
84581: LD_VAR 0 4
84585: STR
84586: PUSH
84587: LD_STRING ")
84589: STR
84590: PPUSH
84591: CALL_OW 559
// end else
84595: GO 84604
// ToLua ( getStreamItemsFromMission("","") ) ;
84597: LD_STRING getStreamItemsFromMission("","")
84599: PPUSH
84600: CALL_OW 559
// end ;
84604: LD_VAR 0 1
84608: RET
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
84609: LD_VAR 0 2
84613: PUSH
84614: LD_INT 100
84616: EQUAL
84617: IFFALSE 85566
// begin if not StreamModeActive then
84619: LD_EXP 115
84623: NOT
84624: IFFALSE 84634
// StreamModeActive := true ;
84626: LD_ADDR_EXP 115
84630: PUSH
84631: LD_INT 1
84633: ST_TO_ADDR
// if p3 = 0 then
84634: LD_VAR 0 3
84638: PUSH
84639: LD_INT 0
84641: EQUAL
84642: IFFALSE 84648
// InitStreamMode ;
84644: CALL 80687 0 0
// if p3 = 1 then
84648: LD_VAR 0 3
84652: PUSH
84653: LD_INT 1
84655: EQUAL
84656: IFFALSE 84666
// sRocket := true ;
84658: LD_ADDR_EXP 120
84662: PUSH
84663: LD_INT 1
84665: ST_TO_ADDR
// if p3 = 2 then
84666: LD_VAR 0 3
84670: PUSH
84671: LD_INT 2
84673: EQUAL
84674: IFFALSE 84684
// sSpeed := true ;
84676: LD_ADDR_EXP 119
84680: PUSH
84681: LD_INT 1
84683: ST_TO_ADDR
// if p3 = 3 then
84684: LD_VAR 0 3
84688: PUSH
84689: LD_INT 3
84691: EQUAL
84692: IFFALSE 84702
// sEngine := true ;
84694: LD_ADDR_EXP 121
84698: PUSH
84699: LD_INT 1
84701: ST_TO_ADDR
// if p3 = 4 then
84702: LD_VAR 0 3
84706: PUSH
84707: LD_INT 4
84709: EQUAL
84710: IFFALSE 84720
// sSpec := true ;
84712: LD_ADDR_EXP 118
84716: PUSH
84717: LD_INT 1
84719: ST_TO_ADDR
// if p3 = 5 then
84720: LD_VAR 0 3
84724: PUSH
84725: LD_INT 5
84727: EQUAL
84728: IFFALSE 84738
// sLevel := true ;
84730: LD_ADDR_EXP 122
84734: PUSH
84735: LD_INT 1
84737: ST_TO_ADDR
// if p3 = 6 then
84738: LD_VAR 0 3
84742: PUSH
84743: LD_INT 6
84745: EQUAL
84746: IFFALSE 84756
// sArmoury := true ;
84748: LD_ADDR_EXP 123
84752: PUSH
84753: LD_INT 1
84755: ST_TO_ADDR
// if p3 = 7 then
84756: LD_VAR 0 3
84760: PUSH
84761: LD_INT 7
84763: EQUAL
84764: IFFALSE 84774
// sRadar := true ;
84766: LD_ADDR_EXP 124
84770: PUSH
84771: LD_INT 1
84773: ST_TO_ADDR
// if p3 = 8 then
84774: LD_VAR 0 3
84778: PUSH
84779: LD_INT 8
84781: EQUAL
84782: IFFALSE 84792
// sBunker := true ;
84784: LD_ADDR_EXP 125
84788: PUSH
84789: LD_INT 1
84791: ST_TO_ADDR
// if p3 = 9 then
84792: LD_VAR 0 3
84796: PUSH
84797: LD_INT 9
84799: EQUAL
84800: IFFALSE 84810
// sHack := true ;
84802: LD_ADDR_EXP 126
84806: PUSH
84807: LD_INT 1
84809: ST_TO_ADDR
// if p3 = 10 then
84810: LD_VAR 0 3
84814: PUSH
84815: LD_INT 10
84817: EQUAL
84818: IFFALSE 84828
// sFire := true ;
84820: LD_ADDR_EXP 127
84824: PUSH
84825: LD_INT 1
84827: ST_TO_ADDR
// if p3 = 11 then
84828: LD_VAR 0 3
84832: PUSH
84833: LD_INT 11
84835: EQUAL
84836: IFFALSE 84846
// sRefresh := true ;
84838: LD_ADDR_EXP 128
84842: PUSH
84843: LD_INT 1
84845: ST_TO_ADDR
// if p3 = 12 then
84846: LD_VAR 0 3
84850: PUSH
84851: LD_INT 12
84853: EQUAL
84854: IFFALSE 84864
// sExp := true ;
84856: LD_ADDR_EXP 129
84860: PUSH
84861: LD_INT 1
84863: ST_TO_ADDR
// if p3 = 13 then
84864: LD_VAR 0 3
84868: PUSH
84869: LD_INT 13
84871: EQUAL
84872: IFFALSE 84882
// sDepot := true ;
84874: LD_ADDR_EXP 130
84878: PUSH
84879: LD_INT 1
84881: ST_TO_ADDR
// if p3 = 14 then
84882: LD_VAR 0 3
84886: PUSH
84887: LD_INT 14
84889: EQUAL
84890: IFFALSE 84900
// sFlag := true ;
84892: LD_ADDR_EXP 131
84896: PUSH
84897: LD_INT 1
84899: ST_TO_ADDR
// if p3 = 15 then
84900: LD_VAR 0 3
84904: PUSH
84905: LD_INT 15
84907: EQUAL
84908: IFFALSE 84918
// sKamikadze := true ;
84910: LD_ADDR_EXP 139
84914: PUSH
84915: LD_INT 1
84917: ST_TO_ADDR
// if p3 = 16 then
84918: LD_VAR 0 3
84922: PUSH
84923: LD_INT 16
84925: EQUAL
84926: IFFALSE 84936
// sTroll := true ;
84928: LD_ADDR_EXP 140
84932: PUSH
84933: LD_INT 1
84935: ST_TO_ADDR
// if p3 = 17 then
84936: LD_VAR 0 3
84940: PUSH
84941: LD_INT 17
84943: EQUAL
84944: IFFALSE 84954
// sSlow := true ;
84946: LD_ADDR_EXP 141
84950: PUSH
84951: LD_INT 1
84953: ST_TO_ADDR
// if p3 = 18 then
84954: LD_VAR 0 3
84958: PUSH
84959: LD_INT 18
84961: EQUAL
84962: IFFALSE 84972
// sLack := true ;
84964: LD_ADDR_EXP 142
84968: PUSH
84969: LD_INT 1
84971: ST_TO_ADDR
// if p3 = 19 then
84972: LD_VAR 0 3
84976: PUSH
84977: LD_INT 19
84979: EQUAL
84980: IFFALSE 84990
// sTank := true ;
84982: LD_ADDR_EXP 144
84986: PUSH
84987: LD_INT 1
84989: ST_TO_ADDR
// if p3 = 20 then
84990: LD_VAR 0 3
84994: PUSH
84995: LD_INT 20
84997: EQUAL
84998: IFFALSE 85008
// sRemote := true ;
85000: LD_ADDR_EXP 145
85004: PUSH
85005: LD_INT 1
85007: ST_TO_ADDR
// if p3 = 21 then
85008: LD_VAR 0 3
85012: PUSH
85013: LD_INT 21
85015: EQUAL
85016: IFFALSE 85026
// sPowell := true ;
85018: LD_ADDR_EXP 146
85022: PUSH
85023: LD_INT 1
85025: ST_TO_ADDR
// if p3 = 22 then
85026: LD_VAR 0 3
85030: PUSH
85031: LD_INT 22
85033: EQUAL
85034: IFFALSE 85044
// sTeleport := true ;
85036: LD_ADDR_EXP 149
85040: PUSH
85041: LD_INT 1
85043: ST_TO_ADDR
// if p3 = 23 then
85044: LD_VAR 0 3
85048: PUSH
85049: LD_INT 23
85051: EQUAL
85052: IFFALSE 85062
// sOilTower := true ;
85054: LD_ADDR_EXP 151
85058: PUSH
85059: LD_INT 1
85061: ST_TO_ADDR
// if p3 = 24 then
85062: LD_VAR 0 3
85066: PUSH
85067: LD_INT 24
85069: EQUAL
85070: IFFALSE 85080
// sShovel := true ;
85072: LD_ADDR_EXP 152
85076: PUSH
85077: LD_INT 1
85079: ST_TO_ADDR
// if p3 = 25 then
85080: LD_VAR 0 3
85084: PUSH
85085: LD_INT 25
85087: EQUAL
85088: IFFALSE 85098
// sSheik := true ;
85090: LD_ADDR_EXP 153
85094: PUSH
85095: LD_INT 1
85097: ST_TO_ADDR
// if p3 = 26 then
85098: LD_VAR 0 3
85102: PUSH
85103: LD_INT 26
85105: EQUAL
85106: IFFALSE 85116
// sEarthquake := true ;
85108: LD_ADDR_EXP 155
85112: PUSH
85113: LD_INT 1
85115: ST_TO_ADDR
// if p3 = 27 then
85116: LD_VAR 0 3
85120: PUSH
85121: LD_INT 27
85123: EQUAL
85124: IFFALSE 85134
// sAI := true ;
85126: LD_ADDR_EXP 156
85130: PUSH
85131: LD_INT 1
85133: ST_TO_ADDR
// if p3 = 28 then
85134: LD_VAR 0 3
85138: PUSH
85139: LD_INT 28
85141: EQUAL
85142: IFFALSE 85152
// sCargo := true ;
85144: LD_ADDR_EXP 159
85148: PUSH
85149: LD_INT 1
85151: ST_TO_ADDR
// if p3 = 29 then
85152: LD_VAR 0 3
85156: PUSH
85157: LD_INT 29
85159: EQUAL
85160: IFFALSE 85170
// sDLaser := true ;
85162: LD_ADDR_EXP 160
85166: PUSH
85167: LD_INT 1
85169: ST_TO_ADDR
// if p3 = 30 then
85170: LD_VAR 0 3
85174: PUSH
85175: LD_INT 30
85177: EQUAL
85178: IFFALSE 85188
// sExchange := true ;
85180: LD_ADDR_EXP 161
85184: PUSH
85185: LD_INT 1
85187: ST_TO_ADDR
// if p3 = 31 then
85188: LD_VAR 0 3
85192: PUSH
85193: LD_INT 31
85195: EQUAL
85196: IFFALSE 85206
// sFac := true ;
85198: LD_ADDR_EXP 162
85202: PUSH
85203: LD_INT 1
85205: ST_TO_ADDR
// if p3 = 32 then
85206: LD_VAR 0 3
85210: PUSH
85211: LD_INT 32
85213: EQUAL
85214: IFFALSE 85224
// sPower := true ;
85216: LD_ADDR_EXP 163
85220: PUSH
85221: LD_INT 1
85223: ST_TO_ADDR
// if p3 = 33 then
85224: LD_VAR 0 3
85228: PUSH
85229: LD_INT 33
85231: EQUAL
85232: IFFALSE 85242
// sRandom := true ;
85234: LD_ADDR_EXP 164
85238: PUSH
85239: LD_INT 1
85241: ST_TO_ADDR
// if p3 = 34 then
85242: LD_VAR 0 3
85246: PUSH
85247: LD_INT 34
85249: EQUAL
85250: IFFALSE 85260
// sShield := true ;
85252: LD_ADDR_EXP 165
85256: PUSH
85257: LD_INT 1
85259: ST_TO_ADDR
// if p3 = 35 then
85260: LD_VAR 0 3
85264: PUSH
85265: LD_INT 35
85267: EQUAL
85268: IFFALSE 85278
// sTime := true ;
85270: LD_ADDR_EXP 166
85274: PUSH
85275: LD_INT 1
85277: ST_TO_ADDR
// if p3 = 36 then
85278: LD_VAR 0 3
85282: PUSH
85283: LD_INT 36
85285: EQUAL
85286: IFFALSE 85296
// sTools := true ;
85288: LD_ADDR_EXP 167
85292: PUSH
85293: LD_INT 1
85295: ST_TO_ADDR
// if p3 = 101 then
85296: LD_VAR 0 3
85300: PUSH
85301: LD_INT 101
85303: EQUAL
85304: IFFALSE 85314
// sSold := true ;
85306: LD_ADDR_EXP 132
85310: PUSH
85311: LD_INT 1
85313: ST_TO_ADDR
// if p3 = 102 then
85314: LD_VAR 0 3
85318: PUSH
85319: LD_INT 102
85321: EQUAL
85322: IFFALSE 85332
// sDiff := true ;
85324: LD_ADDR_EXP 133
85328: PUSH
85329: LD_INT 1
85331: ST_TO_ADDR
// if p3 = 103 then
85332: LD_VAR 0 3
85336: PUSH
85337: LD_INT 103
85339: EQUAL
85340: IFFALSE 85350
// sFog := true ;
85342: LD_ADDR_EXP 136
85346: PUSH
85347: LD_INT 1
85349: ST_TO_ADDR
// if p3 = 104 then
85350: LD_VAR 0 3
85354: PUSH
85355: LD_INT 104
85357: EQUAL
85358: IFFALSE 85368
// sReset := true ;
85360: LD_ADDR_EXP 137
85364: PUSH
85365: LD_INT 1
85367: ST_TO_ADDR
// if p3 = 105 then
85368: LD_VAR 0 3
85372: PUSH
85373: LD_INT 105
85375: EQUAL
85376: IFFALSE 85386
// sSun := true ;
85378: LD_ADDR_EXP 138
85382: PUSH
85383: LD_INT 1
85385: ST_TO_ADDR
// if p3 = 106 then
85386: LD_VAR 0 3
85390: PUSH
85391: LD_INT 106
85393: EQUAL
85394: IFFALSE 85404
// sTiger := true ;
85396: LD_ADDR_EXP 134
85400: PUSH
85401: LD_INT 1
85403: ST_TO_ADDR
// if p3 = 107 then
85404: LD_VAR 0 3
85408: PUSH
85409: LD_INT 107
85411: EQUAL
85412: IFFALSE 85422
// sBomb := true ;
85414: LD_ADDR_EXP 135
85418: PUSH
85419: LD_INT 1
85421: ST_TO_ADDR
// if p3 = 108 then
85422: LD_VAR 0 3
85426: PUSH
85427: LD_INT 108
85429: EQUAL
85430: IFFALSE 85440
// sWound := true ;
85432: LD_ADDR_EXP 143
85436: PUSH
85437: LD_INT 1
85439: ST_TO_ADDR
// if p3 = 109 then
85440: LD_VAR 0 3
85444: PUSH
85445: LD_INT 109
85447: EQUAL
85448: IFFALSE 85458
// sBetray := true ;
85450: LD_ADDR_EXP 147
85454: PUSH
85455: LD_INT 1
85457: ST_TO_ADDR
// if p3 = 110 then
85458: LD_VAR 0 3
85462: PUSH
85463: LD_INT 110
85465: EQUAL
85466: IFFALSE 85476
// sContamin := true ;
85468: LD_ADDR_EXP 148
85472: PUSH
85473: LD_INT 1
85475: ST_TO_ADDR
// if p3 = 111 then
85476: LD_VAR 0 3
85480: PUSH
85481: LD_INT 111
85483: EQUAL
85484: IFFALSE 85494
// sOil := true ;
85486: LD_ADDR_EXP 150
85490: PUSH
85491: LD_INT 1
85493: ST_TO_ADDR
// if p3 = 112 then
85494: LD_VAR 0 3
85498: PUSH
85499: LD_INT 112
85501: EQUAL
85502: IFFALSE 85512
// sStu := true ;
85504: LD_ADDR_EXP 154
85508: PUSH
85509: LD_INT 1
85511: ST_TO_ADDR
// if p3 = 113 then
85512: LD_VAR 0 3
85516: PUSH
85517: LD_INT 113
85519: EQUAL
85520: IFFALSE 85530
// sBazooka := true ;
85522: LD_ADDR_EXP 157
85526: PUSH
85527: LD_INT 1
85529: ST_TO_ADDR
// if p3 = 114 then
85530: LD_VAR 0 3
85534: PUSH
85535: LD_INT 114
85537: EQUAL
85538: IFFALSE 85548
// sMortar := true ;
85540: LD_ADDR_EXP 158
85544: PUSH
85545: LD_INT 1
85547: ST_TO_ADDR
// if p3 = 115 then
85548: LD_VAR 0 3
85552: PUSH
85553: LD_INT 115
85555: EQUAL
85556: IFFALSE 85566
// sRanger := true ;
85558: LD_ADDR_EXP 168
85562: PUSH
85563: LD_INT 1
85565: ST_TO_ADDR
// end ; end ;
85566: PPOPN 6
85568: END
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85569: LD_EXP 115
85573: PUSH
85574: LD_EXP 120
85578: AND
85579: IFFALSE 85703
85581: GO 85583
85583: DISABLE
85584: LD_INT 0
85586: PPUSH
85587: PPUSH
// begin enable ;
85588: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85589: LD_ADDR_VAR 0 2
85593: PUSH
85594: LD_INT 22
85596: PUSH
85597: LD_OWVAR 2
85601: PUSH
85602: EMPTY
85603: LIST
85604: LIST
85605: PUSH
85606: LD_INT 2
85608: PUSH
85609: LD_INT 34
85611: PUSH
85612: LD_INT 7
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: PUSH
85619: LD_INT 34
85621: PUSH
85622: LD_INT 45
85624: PUSH
85625: EMPTY
85626: LIST
85627: LIST
85628: PUSH
85629: LD_INT 34
85631: PUSH
85632: LD_INT 28
85634: PUSH
85635: EMPTY
85636: LIST
85637: LIST
85638: PUSH
85639: LD_INT 34
85641: PUSH
85642: LD_INT 47
85644: PUSH
85645: EMPTY
85646: LIST
85647: LIST
85648: PUSH
85649: EMPTY
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: PUSH
85656: EMPTY
85657: LIST
85658: LIST
85659: PPUSH
85660: CALL_OW 69
85664: ST_TO_ADDR
// if not tmp then
85665: LD_VAR 0 2
85669: NOT
85670: IFFALSE 85674
// exit ;
85672: GO 85703
// for i in tmp do
85674: LD_ADDR_VAR 0 1
85678: PUSH
85679: LD_VAR 0 2
85683: PUSH
85684: FOR_IN
85685: IFFALSE 85701
// begin SetLives ( i , 0 ) ;
85687: LD_VAR 0 1
85691: PPUSH
85692: LD_INT 0
85694: PPUSH
85695: CALL_OW 234
// end ;
85699: GO 85684
85701: POP
85702: POP
// end ;
85703: PPOPN 2
85705: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
85706: LD_EXP 115
85710: PUSH
85711: LD_EXP 121
85715: AND
85716: IFFALSE 85800
85718: GO 85720
85720: DISABLE
85721: LD_INT 0
85723: PPUSH
85724: PPUSH
// begin enable ;
85725: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
85726: LD_ADDR_VAR 0 2
85730: PUSH
85731: LD_INT 22
85733: PUSH
85734: LD_OWVAR 2
85738: PUSH
85739: EMPTY
85740: LIST
85741: LIST
85742: PUSH
85743: LD_INT 32
85745: PUSH
85746: LD_INT 3
85748: PUSH
85749: EMPTY
85750: LIST
85751: LIST
85752: PUSH
85753: EMPTY
85754: LIST
85755: LIST
85756: PPUSH
85757: CALL_OW 69
85761: ST_TO_ADDR
// if not tmp then
85762: LD_VAR 0 2
85766: NOT
85767: IFFALSE 85771
// exit ;
85769: GO 85800
// for i in tmp do
85771: LD_ADDR_VAR 0 1
85775: PUSH
85776: LD_VAR 0 2
85780: PUSH
85781: FOR_IN
85782: IFFALSE 85798
// begin SetLives ( i , 0 ) ;
85784: LD_VAR 0 1
85788: PPUSH
85789: LD_INT 0
85791: PPUSH
85792: CALL_OW 234
// end ;
85796: GO 85781
85798: POP
85799: POP
// end ;
85800: PPOPN 2
85802: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
85803: LD_EXP 115
85807: PUSH
85808: LD_EXP 118
85812: AND
85813: IFFALSE 85906
85815: GO 85817
85817: DISABLE
85818: LD_INT 0
85820: PPUSH
// begin enable ;
85821: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
85822: LD_ADDR_VAR 0 1
85826: PUSH
85827: LD_INT 22
85829: PUSH
85830: LD_OWVAR 2
85834: PUSH
85835: EMPTY
85836: LIST
85837: LIST
85838: PUSH
85839: LD_INT 2
85841: PUSH
85842: LD_INT 25
85844: PUSH
85845: LD_INT 5
85847: PUSH
85848: EMPTY
85849: LIST
85850: LIST
85851: PUSH
85852: LD_INT 25
85854: PUSH
85855: LD_INT 9
85857: PUSH
85858: EMPTY
85859: LIST
85860: LIST
85861: PUSH
85862: LD_INT 25
85864: PUSH
85865: LD_INT 8
85867: PUSH
85868: EMPTY
85869: LIST
85870: LIST
85871: PUSH
85872: EMPTY
85873: LIST
85874: LIST
85875: LIST
85876: LIST
85877: PUSH
85878: EMPTY
85879: LIST
85880: LIST
85881: PPUSH
85882: CALL_OW 69
85886: PUSH
85887: FOR_IN
85888: IFFALSE 85904
// begin SetClass ( i , 1 ) ;
85890: LD_VAR 0 1
85894: PPUSH
85895: LD_INT 1
85897: PPUSH
85898: CALL_OW 336
// end ;
85902: GO 85887
85904: POP
85905: POP
// end ;
85906: PPOPN 1
85908: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
85909: LD_EXP 115
85913: PUSH
85914: LD_EXP 119
85918: AND
85919: PUSH
85920: LD_OWVAR 65
85924: PUSH
85925: LD_INT 7
85927: LESS
85928: AND
85929: IFFALSE 85943
85931: GO 85933
85933: DISABLE
// begin enable ;
85934: ENABLE
// game_speed := 7 ;
85935: LD_ADDR_OWVAR 65
85939: PUSH
85940: LD_INT 7
85942: ST_TO_ADDR
// end ;
85943: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
85944: LD_EXP 115
85948: PUSH
85949: LD_EXP 122
85953: AND
85954: IFFALSE 86156
85956: GO 85958
85958: DISABLE
85959: LD_INT 0
85961: PPUSH
85962: PPUSH
85963: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
85964: LD_ADDR_VAR 0 3
85968: PUSH
85969: LD_INT 81
85971: PUSH
85972: LD_OWVAR 2
85976: PUSH
85977: EMPTY
85978: LIST
85979: LIST
85980: PUSH
85981: LD_INT 21
85983: PUSH
85984: LD_INT 1
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: PUSH
85991: EMPTY
85992: LIST
85993: LIST
85994: PPUSH
85995: CALL_OW 69
85999: ST_TO_ADDR
// if not tmp then
86000: LD_VAR 0 3
86004: NOT
86005: IFFALSE 86009
// exit ;
86007: GO 86156
// if tmp > 5 then
86009: LD_VAR 0 3
86013: PUSH
86014: LD_INT 5
86016: GREATER
86017: IFFALSE 86029
// k := 5 else
86019: LD_ADDR_VAR 0 2
86023: PUSH
86024: LD_INT 5
86026: ST_TO_ADDR
86027: GO 86039
// k := tmp ;
86029: LD_ADDR_VAR 0 2
86033: PUSH
86034: LD_VAR 0 3
86038: ST_TO_ADDR
// for i := 1 to k do
86039: LD_ADDR_VAR 0 1
86043: PUSH
86044: DOUBLE
86045: LD_INT 1
86047: DEC
86048: ST_TO_ADDR
86049: LD_VAR 0 2
86053: PUSH
86054: FOR_TO
86055: IFFALSE 86154
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
86057: LD_VAR 0 3
86061: PUSH
86062: LD_VAR 0 1
86066: ARRAY
86067: PPUSH
86068: LD_VAR 0 1
86072: PUSH
86073: LD_INT 4
86075: MOD
86076: PUSH
86077: LD_INT 1
86079: PLUS
86080: PPUSH
86081: CALL_OW 259
86085: PUSH
86086: LD_INT 10
86088: LESS
86089: IFFALSE 86152
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86091: LD_VAR 0 3
86095: PUSH
86096: LD_VAR 0 1
86100: ARRAY
86101: PPUSH
86102: LD_VAR 0 1
86106: PUSH
86107: LD_INT 4
86109: MOD
86110: PUSH
86111: LD_INT 1
86113: PLUS
86114: PPUSH
86115: LD_VAR 0 3
86119: PUSH
86120: LD_VAR 0 1
86124: ARRAY
86125: PPUSH
86126: LD_VAR 0 1
86130: PUSH
86131: LD_INT 4
86133: MOD
86134: PUSH
86135: LD_INT 1
86137: PLUS
86138: PPUSH
86139: CALL_OW 259
86143: PUSH
86144: LD_INT 1
86146: PLUS
86147: PPUSH
86148: CALL_OW 237
86152: GO 86054
86154: POP
86155: POP
// end ;
86156: PPOPN 3
86158: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86159: LD_EXP 115
86163: PUSH
86164: LD_EXP 123
86168: AND
86169: IFFALSE 86189
86171: GO 86173
86173: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86174: LD_INT 4
86176: PPUSH
86177: LD_OWVAR 2
86181: PPUSH
86182: LD_INT 0
86184: PPUSH
86185: CALL_OW 324
86189: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86190: LD_EXP 115
86194: PUSH
86195: LD_EXP 152
86199: AND
86200: IFFALSE 86220
86202: GO 86204
86204: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86205: LD_INT 19
86207: PPUSH
86208: LD_OWVAR 2
86212: PPUSH
86213: LD_INT 0
86215: PPUSH
86216: CALL_OW 324
86220: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86221: LD_EXP 115
86225: PUSH
86226: LD_EXP 124
86230: AND
86231: IFFALSE 86333
86233: GO 86235
86235: DISABLE
86236: LD_INT 0
86238: PPUSH
86239: PPUSH
// begin enable ;
86240: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86241: LD_ADDR_VAR 0 2
86245: PUSH
86246: LD_INT 22
86248: PUSH
86249: LD_OWVAR 2
86253: PUSH
86254: EMPTY
86255: LIST
86256: LIST
86257: PUSH
86258: LD_INT 2
86260: PUSH
86261: LD_INT 34
86263: PUSH
86264: LD_INT 11
86266: PUSH
86267: EMPTY
86268: LIST
86269: LIST
86270: PUSH
86271: LD_INT 34
86273: PUSH
86274: LD_INT 30
86276: PUSH
86277: EMPTY
86278: LIST
86279: LIST
86280: PUSH
86281: EMPTY
86282: LIST
86283: LIST
86284: LIST
86285: PUSH
86286: EMPTY
86287: LIST
86288: LIST
86289: PPUSH
86290: CALL_OW 69
86294: ST_TO_ADDR
// if not tmp then
86295: LD_VAR 0 2
86299: NOT
86300: IFFALSE 86304
// exit ;
86302: GO 86333
// for i in tmp do
86304: LD_ADDR_VAR 0 1
86308: PUSH
86309: LD_VAR 0 2
86313: PUSH
86314: FOR_IN
86315: IFFALSE 86331
// begin SetLives ( i , 0 ) ;
86317: LD_VAR 0 1
86321: PPUSH
86322: LD_INT 0
86324: PPUSH
86325: CALL_OW 234
// end ;
86329: GO 86314
86331: POP
86332: POP
// end ;
86333: PPOPN 2
86335: END
// every 0 0$1 trigger StreamModeActive and sBunker do
86336: LD_EXP 115
86340: PUSH
86341: LD_EXP 125
86345: AND
86346: IFFALSE 86366
86348: GO 86350
86350: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
86351: LD_INT 32
86353: PPUSH
86354: LD_OWVAR 2
86358: PPUSH
86359: LD_INT 0
86361: PPUSH
86362: CALL_OW 324
86366: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
86367: LD_EXP 115
86371: PUSH
86372: LD_EXP 126
86376: AND
86377: IFFALSE 86558
86379: GO 86381
86381: DISABLE
86382: LD_INT 0
86384: PPUSH
86385: PPUSH
86386: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
86387: LD_ADDR_VAR 0 2
86391: PUSH
86392: LD_INT 22
86394: PUSH
86395: LD_OWVAR 2
86399: PUSH
86400: EMPTY
86401: LIST
86402: LIST
86403: PUSH
86404: LD_INT 33
86406: PUSH
86407: LD_INT 3
86409: PUSH
86410: EMPTY
86411: LIST
86412: LIST
86413: PUSH
86414: EMPTY
86415: LIST
86416: LIST
86417: PPUSH
86418: CALL_OW 69
86422: ST_TO_ADDR
// if not tmp then
86423: LD_VAR 0 2
86427: NOT
86428: IFFALSE 86432
// exit ;
86430: GO 86558
// side := 0 ;
86432: LD_ADDR_VAR 0 3
86436: PUSH
86437: LD_INT 0
86439: ST_TO_ADDR
// for i := 1 to 8 do
86440: LD_ADDR_VAR 0 1
86444: PUSH
86445: DOUBLE
86446: LD_INT 1
86448: DEC
86449: ST_TO_ADDR
86450: LD_INT 8
86452: PUSH
86453: FOR_TO
86454: IFFALSE 86502
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86456: LD_OWVAR 2
86460: PUSH
86461: LD_VAR 0 1
86465: NONEQUAL
86466: PUSH
86467: LD_OWVAR 2
86471: PPUSH
86472: LD_VAR 0 1
86476: PPUSH
86477: CALL_OW 81
86481: PUSH
86482: LD_INT 2
86484: EQUAL
86485: AND
86486: IFFALSE 86500
// begin side := i ;
86488: LD_ADDR_VAR 0 3
86492: PUSH
86493: LD_VAR 0 1
86497: ST_TO_ADDR
// break ;
86498: GO 86502
// end ;
86500: GO 86453
86502: POP
86503: POP
// if not side then
86504: LD_VAR 0 3
86508: NOT
86509: IFFALSE 86513
// exit ;
86511: GO 86558
// for i := 1 to tmp do
86513: LD_ADDR_VAR 0 1
86517: PUSH
86518: DOUBLE
86519: LD_INT 1
86521: DEC
86522: ST_TO_ADDR
86523: LD_VAR 0 2
86527: PUSH
86528: FOR_TO
86529: IFFALSE 86556
// if Prob ( 60 ) then
86531: LD_INT 60
86533: PPUSH
86534: CALL_OW 13
86538: IFFALSE 86554
// SetSide ( i , side ) ;
86540: LD_VAR 0 1
86544: PPUSH
86545: LD_VAR 0 3
86549: PPUSH
86550: CALL_OW 235
86554: GO 86528
86556: POP
86557: POP
// end ;
86558: PPOPN 3
86560: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86561: LD_EXP 115
86565: PUSH
86566: LD_EXP 128
86570: AND
86571: IFFALSE 86690
86573: GO 86575
86575: DISABLE
86576: LD_INT 0
86578: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86579: LD_ADDR_VAR 0 1
86583: PUSH
86584: LD_INT 22
86586: PUSH
86587: LD_OWVAR 2
86591: PUSH
86592: EMPTY
86593: LIST
86594: LIST
86595: PUSH
86596: LD_INT 21
86598: PUSH
86599: LD_INT 1
86601: PUSH
86602: EMPTY
86603: LIST
86604: LIST
86605: PUSH
86606: LD_INT 3
86608: PUSH
86609: LD_INT 23
86611: PUSH
86612: LD_INT 0
86614: PUSH
86615: EMPTY
86616: LIST
86617: LIST
86618: PUSH
86619: EMPTY
86620: LIST
86621: LIST
86622: PUSH
86623: EMPTY
86624: LIST
86625: LIST
86626: LIST
86627: PPUSH
86628: CALL_OW 69
86632: PUSH
86633: FOR_IN
86634: IFFALSE 86688
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
86636: LD_VAR 0 1
86640: PPUSH
86641: CALL_OW 257
86645: PUSH
86646: LD_INT 1
86648: PUSH
86649: LD_INT 2
86651: PUSH
86652: LD_INT 3
86654: PUSH
86655: LD_INT 4
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: IN
86664: IFFALSE 86686
// SetClass ( un , rand ( 1 , 4 ) ) ;
86666: LD_VAR 0 1
86670: PPUSH
86671: LD_INT 1
86673: PPUSH
86674: LD_INT 4
86676: PPUSH
86677: CALL_OW 12
86681: PPUSH
86682: CALL_OW 336
86686: GO 86633
86688: POP
86689: POP
// end ;
86690: PPOPN 1
86692: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
86693: LD_EXP 115
86697: PUSH
86698: LD_EXP 127
86702: AND
86703: IFFALSE 86782
86705: GO 86707
86707: DISABLE
86708: LD_INT 0
86710: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86711: LD_ADDR_VAR 0 1
86715: PUSH
86716: LD_INT 22
86718: PUSH
86719: LD_OWVAR 2
86723: PUSH
86724: EMPTY
86725: LIST
86726: LIST
86727: PUSH
86728: LD_INT 21
86730: PUSH
86731: LD_INT 3
86733: PUSH
86734: EMPTY
86735: LIST
86736: LIST
86737: PUSH
86738: EMPTY
86739: LIST
86740: LIST
86741: PPUSH
86742: CALL_OW 69
86746: ST_TO_ADDR
// if not tmp then
86747: LD_VAR 0 1
86751: NOT
86752: IFFALSE 86756
// exit ;
86754: GO 86782
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
86756: LD_VAR 0 1
86760: PUSH
86761: LD_INT 1
86763: PPUSH
86764: LD_VAR 0 1
86768: PPUSH
86769: CALL_OW 12
86773: ARRAY
86774: PPUSH
86775: LD_INT 100
86777: PPUSH
86778: CALL_OW 234
// end ;
86782: PPOPN 1
86784: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
86785: LD_EXP 115
86789: PUSH
86790: LD_EXP 129
86794: AND
86795: IFFALSE 86893
86797: GO 86799
86799: DISABLE
86800: LD_INT 0
86802: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
86803: LD_ADDR_VAR 0 1
86807: PUSH
86808: LD_INT 22
86810: PUSH
86811: LD_OWVAR 2
86815: PUSH
86816: EMPTY
86817: LIST
86818: LIST
86819: PUSH
86820: LD_INT 21
86822: PUSH
86823: LD_INT 1
86825: PUSH
86826: EMPTY
86827: LIST
86828: LIST
86829: PUSH
86830: EMPTY
86831: LIST
86832: LIST
86833: PPUSH
86834: CALL_OW 69
86838: ST_TO_ADDR
// if not tmp then
86839: LD_VAR 0 1
86843: NOT
86844: IFFALSE 86848
// exit ;
86846: GO 86893
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
86848: LD_VAR 0 1
86852: PUSH
86853: LD_INT 1
86855: PPUSH
86856: LD_VAR 0 1
86860: PPUSH
86861: CALL_OW 12
86865: ARRAY
86866: PPUSH
86867: LD_INT 1
86869: PPUSH
86870: LD_INT 4
86872: PPUSH
86873: CALL_OW 12
86877: PPUSH
86878: LD_INT 3000
86880: PPUSH
86881: LD_INT 9000
86883: PPUSH
86884: CALL_OW 12
86888: PPUSH
86889: CALL_OW 492
// end ;
86893: PPOPN 1
86895: END
// every 0 0$1 trigger StreamModeActive and sDepot do
86896: LD_EXP 115
86900: PUSH
86901: LD_EXP 130
86905: AND
86906: IFFALSE 86926
86908: GO 86910
86910: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
86911: LD_INT 1
86913: PPUSH
86914: LD_OWVAR 2
86918: PPUSH
86919: LD_INT 0
86921: PPUSH
86922: CALL_OW 324
86926: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
86927: LD_EXP 115
86931: PUSH
86932: LD_EXP 131
86936: AND
86937: IFFALSE 87020
86939: GO 86941
86941: DISABLE
86942: LD_INT 0
86944: PPUSH
86945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
86946: LD_ADDR_VAR 0 2
86950: PUSH
86951: LD_INT 22
86953: PUSH
86954: LD_OWVAR 2
86958: PUSH
86959: EMPTY
86960: LIST
86961: LIST
86962: PUSH
86963: LD_INT 21
86965: PUSH
86966: LD_INT 3
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: PUSH
86973: EMPTY
86974: LIST
86975: LIST
86976: PPUSH
86977: CALL_OW 69
86981: ST_TO_ADDR
// if not tmp then
86982: LD_VAR 0 2
86986: NOT
86987: IFFALSE 86991
// exit ;
86989: GO 87020
// for i in tmp do
86991: LD_ADDR_VAR 0 1
86995: PUSH
86996: LD_VAR 0 2
87000: PUSH
87001: FOR_IN
87002: IFFALSE 87018
// SetBLevel ( i , 10 ) ;
87004: LD_VAR 0 1
87008: PPUSH
87009: LD_INT 10
87011: PPUSH
87012: CALL_OW 241
87016: GO 87001
87018: POP
87019: POP
// end ;
87020: PPOPN 2
87022: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
87023: LD_EXP 115
87027: PUSH
87028: LD_EXP 132
87032: AND
87033: IFFALSE 87144
87035: GO 87037
87037: DISABLE
87038: LD_INT 0
87040: PPUSH
87041: PPUSH
87042: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
87043: LD_ADDR_VAR 0 3
87047: PUSH
87048: LD_INT 22
87050: PUSH
87051: LD_OWVAR 2
87055: PUSH
87056: EMPTY
87057: LIST
87058: LIST
87059: PUSH
87060: LD_INT 25
87062: PUSH
87063: LD_INT 1
87065: PUSH
87066: EMPTY
87067: LIST
87068: LIST
87069: PUSH
87070: EMPTY
87071: LIST
87072: LIST
87073: PPUSH
87074: CALL_OW 69
87078: ST_TO_ADDR
// if not tmp then
87079: LD_VAR 0 3
87083: NOT
87084: IFFALSE 87088
// exit ;
87086: GO 87144
// un := tmp [ rand ( 1 , tmp ) ] ;
87088: LD_ADDR_VAR 0 2
87092: PUSH
87093: LD_VAR 0 3
87097: PUSH
87098: LD_INT 1
87100: PPUSH
87101: LD_VAR 0 3
87105: PPUSH
87106: CALL_OW 12
87110: ARRAY
87111: ST_TO_ADDR
// if Crawls ( un ) then
87112: LD_VAR 0 2
87116: PPUSH
87117: CALL_OW 318
87121: IFFALSE 87132
// ComWalk ( un ) ;
87123: LD_VAR 0 2
87127: PPUSH
87128: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87132: LD_VAR 0 2
87136: PPUSH
87137: LD_INT 5
87139: PPUSH
87140: CALL_OW 336
// end ;
87144: PPOPN 3
87146: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87147: LD_EXP 115
87151: PUSH
87152: LD_EXP 133
87156: AND
87157: PUSH
87158: LD_OWVAR 67
87162: PUSH
87163: LD_INT 3
87165: LESS
87166: AND
87167: IFFALSE 87186
87169: GO 87171
87171: DISABLE
// Difficulty := Difficulty + 1 ;
87172: LD_ADDR_OWVAR 67
87176: PUSH
87177: LD_OWVAR 67
87181: PUSH
87182: LD_INT 1
87184: PLUS
87185: ST_TO_ADDR
87186: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87187: LD_EXP 115
87191: PUSH
87192: LD_EXP 134
87196: AND
87197: IFFALSE 87300
87199: GO 87201
87201: DISABLE
87202: LD_INT 0
87204: PPUSH
// begin for i := 1 to 5 do
87205: LD_ADDR_VAR 0 1
87209: PUSH
87210: DOUBLE
87211: LD_INT 1
87213: DEC
87214: ST_TO_ADDR
87215: LD_INT 5
87217: PUSH
87218: FOR_TO
87219: IFFALSE 87298
// begin uc_nation := nation_nature ;
87221: LD_ADDR_OWVAR 21
87225: PUSH
87226: LD_INT 0
87228: ST_TO_ADDR
// uc_side := 0 ;
87229: LD_ADDR_OWVAR 20
87233: PUSH
87234: LD_INT 0
87236: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87237: LD_ADDR_OWVAR 29
87241: PUSH
87242: LD_INT 12
87244: PUSH
87245: LD_INT 12
87247: PUSH
87248: EMPTY
87249: LIST
87250: LIST
87251: ST_TO_ADDR
// hc_agressivity := 20 ;
87252: LD_ADDR_OWVAR 35
87256: PUSH
87257: LD_INT 20
87259: ST_TO_ADDR
// hc_class := class_tiger ;
87260: LD_ADDR_OWVAR 28
87264: PUSH
87265: LD_INT 14
87267: ST_TO_ADDR
// hc_gallery :=  ;
87268: LD_ADDR_OWVAR 33
87272: PUSH
87273: LD_STRING 
87275: ST_TO_ADDR
// hc_name :=  ;
87276: LD_ADDR_OWVAR 26
87280: PUSH
87281: LD_STRING 
87283: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
87284: CALL_OW 44
87288: PPUSH
87289: LD_INT 0
87291: PPUSH
87292: CALL_OW 51
// end ;
87296: GO 87218
87298: POP
87299: POP
// end ;
87300: PPOPN 1
87302: END
// every 0 0$1 trigger StreamModeActive and sBomb do
87303: LD_EXP 115
87307: PUSH
87308: LD_EXP 135
87312: AND
87313: IFFALSE 87322
87315: GO 87317
87317: DISABLE
// StreamSibBomb ;
87318: CALL 87323 0 0
87322: END
// export function StreamSibBomb ; var i , x , y ; begin
87323: LD_INT 0
87325: PPUSH
87326: PPUSH
87327: PPUSH
87328: PPUSH
// result := false ;
87329: LD_ADDR_VAR 0 1
87333: PUSH
87334: LD_INT 0
87336: ST_TO_ADDR
// for i := 1 to 16 do
87337: LD_ADDR_VAR 0 2
87341: PUSH
87342: DOUBLE
87343: LD_INT 1
87345: DEC
87346: ST_TO_ADDR
87347: LD_INT 16
87349: PUSH
87350: FOR_TO
87351: IFFALSE 87550
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87353: LD_ADDR_VAR 0 3
87357: PUSH
87358: LD_INT 10
87360: PUSH
87361: LD_INT 20
87363: PUSH
87364: LD_INT 30
87366: PUSH
87367: LD_INT 40
87369: PUSH
87370: LD_INT 50
87372: PUSH
87373: LD_INT 60
87375: PUSH
87376: LD_INT 70
87378: PUSH
87379: LD_INT 80
87381: PUSH
87382: LD_INT 90
87384: PUSH
87385: LD_INT 100
87387: PUSH
87388: LD_INT 110
87390: PUSH
87391: LD_INT 120
87393: PUSH
87394: LD_INT 130
87396: PUSH
87397: LD_INT 140
87399: PUSH
87400: LD_INT 150
87402: PUSH
87403: EMPTY
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: PUSH
87420: LD_INT 1
87422: PPUSH
87423: LD_INT 15
87425: PPUSH
87426: CALL_OW 12
87430: ARRAY
87431: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87432: LD_ADDR_VAR 0 4
87436: PUSH
87437: LD_INT 10
87439: PUSH
87440: LD_INT 20
87442: PUSH
87443: LD_INT 30
87445: PUSH
87446: LD_INT 40
87448: PUSH
87449: LD_INT 50
87451: PUSH
87452: LD_INT 60
87454: PUSH
87455: LD_INT 70
87457: PUSH
87458: LD_INT 80
87460: PUSH
87461: LD_INT 90
87463: PUSH
87464: LD_INT 100
87466: PUSH
87467: LD_INT 110
87469: PUSH
87470: LD_INT 120
87472: PUSH
87473: LD_INT 130
87475: PUSH
87476: LD_INT 140
87478: PUSH
87479: LD_INT 150
87481: PUSH
87482: EMPTY
87483: LIST
87484: LIST
87485: LIST
87486: LIST
87487: LIST
87488: LIST
87489: LIST
87490: LIST
87491: LIST
87492: LIST
87493: LIST
87494: LIST
87495: LIST
87496: LIST
87497: LIST
87498: PUSH
87499: LD_INT 1
87501: PPUSH
87502: LD_INT 15
87504: PPUSH
87505: CALL_OW 12
87509: ARRAY
87510: ST_TO_ADDR
// if ValidHex ( x , y ) then
87511: LD_VAR 0 3
87515: PPUSH
87516: LD_VAR 0 4
87520: PPUSH
87521: CALL_OW 488
87525: IFFALSE 87548
// begin result := [ x , y ] ;
87527: LD_ADDR_VAR 0 1
87531: PUSH
87532: LD_VAR 0 3
87536: PUSH
87537: LD_VAR 0 4
87541: PUSH
87542: EMPTY
87543: LIST
87544: LIST
87545: ST_TO_ADDR
// break ;
87546: GO 87550
// end ; end ;
87548: GO 87350
87550: POP
87551: POP
// if result then
87552: LD_VAR 0 1
87556: IFFALSE 87616
// begin ToLua ( playSibBomb() ) ;
87558: LD_STRING playSibBomb()
87560: PPUSH
87561: CALL_OW 559
// wait ( 0 0$14 ) ;
87565: LD_INT 490
87567: PPUSH
87568: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87572: LD_VAR 0 1
87576: PUSH
87577: LD_INT 1
87579: ARRAY
87580: PPUSH
87581: LD_VAR 0 1
87585: PUSH
87586: LD_INT 2
87588: ARRAY
87589: PPUSH
87590: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87594: LD_VAR 0 1
87598: PUSH
87599: LD_INT 1
87601: ARRAY
87602: PPUSH
87603: LD_VAR 0 1
87607: PUSH
87608: LD_INT 2
87610: ARRAY
87611: PPUSH
87612: CALL_OW 429
// end ; end ;
87616: LD_VAR 0 1
87620: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87621: LD_EXP 115
87625: PUSH
87626: LD_EXP 137
87630: AND
87631: IFFALSE 87643
87633: GO 87635
87635: DISABLE
// YouLost (  ) ;
87636: LD_STRING 
87638: PPUSH
87639: CALL_OW 104
87643: END
// every 0 0$1 trigger StreamModeActive and sFog do
87644: LD_EXP 115
87648: PUSH
87649: LD_EXP 136
87653: AND
87654: IFFALSE 87668
87656: GO 87658
87658: DISABLE
// FogOff ( your_side ) ;
87659: LD_OWVAR 2
87663: PPUSH
87664: CALL_OW 344
87668: END
// every 0 0$1 trigger StreamModeActive and sSun do
87669: LD_EXP 115
87673: PUSH
87674: LD_EXP 138
87678: AND
87679: IFFALSE 87707
87681: GO 87683
87683: DISABLE
// begin solar_recharge_percent := 0 ;
87684: LD_ADDR_OWVAR 79
87688: PUSH
87689: LD_INT 0
87691: ST_TO_ADDR
// wait ( 5 5$00 ) ;
87692: LD_INT 10500
87694: PPUSH
87695: CALL_OW 67
// solar_recharge_percent := 100 ;
87699: LD_ADDR_OWVAR 79
87703: PUSH
87704: LD_INT 100
87706: ST_TO_ADDR
// end ;
87707: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
87708: LD_EXP 115
87712: PUSH
87713: LD_EXP 139
87717: AND
87718: IFFALSE 87957
87720: GO 87722
87722: DISABLE
87723: LD_INT 0
87725: PPUSH
87726: PPUSH
87727: PPUSH
// begin tmp := [ ] ;
87728: LD_ADDR_VAR 0 3
87732: PUSH
87733: EMPTY
87734: ST_TO_ADDR
// for i := 1 to 6 do
87735: LD_ADDR_VAR 0 1
87739: PUSH
87740: DOUBLE
87741: LD_INT 1
87743: DEC
87744: ST_TO_ADDR
87745: LD_INT 6
87747: PUSH
87748: FOR_TO
87749: IFFALSE 87854
// begin uc_nation := nation_nature ;
87751: LD_ADDR_OWVAR 21
87755: PUSH
87756: LD_INT 0
87758: ST_TO_ADDR
// uc_side := 0 ;
87759: LD_ADDR_OWVAR 20
87763: PUSH
87764: LD_INT 0
87766: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87767: LD_ADDR_OWVAR 29
87771: PUSH
87772: LD_INT 12
87774: PUSH
87775: LD_INT 12
87777: PUSH
87778: EMPTY
87779: LIST
87780: LIST
87781: ST_TO_ADDR
// hc_agressivity := 20 ;
87782: LD_ADDR_OWVAR 35
87786: PUSH
87787: LD_INT 20
87789: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
87790: LD_ADDR_OWVAR 28
87794: PUSH
87795: LD_INT 17
87797: ST_TO_ADDR
// hc_gallery :=  ;
87798: LD_ADDR_OWVAR 33
87802: PUSH
87803: LD_STRING 
87805: ST_TO_ADDR
// hc_name :=  ;
87806: LD_ADDR_OWVAR 26
87810: PUSH
87811: LD_STRING 
87813: ST_TO_ADDR
// un := CreateHuman ;
87814: LD_ADDR_VAR 0 2
87818: PUSH
87819: CALL_OW 44
87823: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
87824: LD_VAR 0 2
87828: PPUSH
87829: LD_INT 1
87831: PPUSH
87832: CALL_OW 51
// tmp := tmp ^ un ;
87836: LD_ADDR_VAR 0 3
87840: PUSH
87841: LD_VAR 0 3
87845: PUSH
87846: LD_VAR 0 2
87850: ADD
87851: ST_TO_ADDR
// end ;
87852: GO 87748
87854: POP
87855: POP
// repeat wait ( 0 0$1 ) ;
87856: LD_INT 35
87858: PPUSH
87859: CALL_OW 67
// for un in tmp do
87863: LD_ADDR_VAR 0 2
87867: PUSH
87868: LD_VAR 0 3
87872: PUSH
87873: FOR_IN
87874: IFFALSE 87948
// begin if IsDead ( un ) then
87876: LD_VAR 0 2
87880: PPUSH
87881: CALL_OW 301
87885: IFFALSE 87905
// begin tmp := tmp diff un ;
87887: LD_ADDR_VAR 0 3
87891: PUSH
87892: LD_VAR 0 3
87896: PUSH
87897: LD_VAR 0 2
87901: DIFF
87902: ST_TO_ADDR
// continue ;
87903: GO 87873
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
87905: LD_VAR 0 2
87909: PPUSH
87910: LD_INT 3
87912: PUSH
87913: LD_INT 22
87915: PUSH
87916: LD_INT 0
87918: PUSH
87919: EMPTY
87920: LIST
87921: LIST
87922: PUSH
87923: EMPTY
87924: LIST
87925: LIST
87926: PPUSH
87927: CALL_OW 69
87931: PPUSH
87932: LD_VAR 0 2
87936: PPUSH
87937: CALL_OW 74
87941: PPUSH
87942: CALL_OW 115
// end ;
87946: GO 87873
87948: POP
87949: POP
// until not tmp ;
87950: LD_VAR 0 3
87954: NOT
87955: IFFALSE 87856
// end ;
87957: PPOPN 3
87959: END
// every 0 0$1 trigger StreamModeActive and sTroll do
87960: LD_EXP 115
87964: PUSH
87965: LD_EXP 140
87969: AND
87970: IFFALSE 88024
87972: GO 87974
87974: DISABLE
// begin ToLua ( displayTroll(); ) ;
87975: LD_STRING displayTroll();
87977: PPUSH
87978: CALL_OW 559
// wait ( 3 3$00 ) ;
87982: LD_INT 6300
87984: PPUSH
87985: CALL_OW 67
// ToLua ( hideTroll(); ) ;
87989: LD_STRING hideTroll();
87991: PPUSH
87992: CALL_OW 559
// wait ( 1 1$00 ) ;
87996: LD_INT 2100
87998: PPUSH
87999: CALL_OW 67
// ToLua ( displayTroll(); ) ;
88003: LD_STRING displayTroll();
88005: PPUSH
88006: CALL_OW 559
// wait ( 1 1$00 ) ;
88010: LD_INT 2100
88012: PPUSH
88013: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88017: LD_STRING hideTroll();
88019: PPUSH
88020: CALL_OW 559
// end ;
88024: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
88025: LD_EXP 115
88029: PUSH
88030: LD_EXP 141
88034: AND
88035: IFFALSE 88098
88037: GO 88039
88039: DISABLE
88040: LD_INT 0
88042: PPUSH
// begin p := 0 ;
88043: LD_ADDR_VAR 0 1
88047: PUSH
88048: LD_INT 0
88050: ST_TO_ADDR
// repeat game_speed := 1 ;
88051: LD_ADDR_OWVAR 65
88055: PUSH
88056: LD_INT 1
88058: ST_TO_ADDR
// wait ( 0 0$1 ) ;
88059: LD_INT 35
88061: PPUSH
88062: CALL_OW 67
// p := p + 1 ;
88066: LD_ADDR_VAR 0 1
88070: PUSH
88071: LD_VAR 0 1
88075: PUSH
88076: LD_INT 1
88078: PLUS
88079: ST_TO_ADDR
// until p >= 60 ;
88080: LD_VAR 0 1
88084: PUSH
88085: LD_INT 60
88087: GREATEREQUAL
88088: IFFALSE 88051
// game_speed := 4 ;
88090: LD_ADDR_OWVAR 65
88094: PUSH
88095: LD_INT 4
88097: ST_TO_ADDR
// end ;
88098: PPOPN 1
88100: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88101: LD_EXP 115
88105: PUSH
88106: LD_EXP 142
88110: AND
88111: IFFALSE 88257
88113: GO 88115
88115: DISABLE
88116: LD_INT 0
88118: PPUSH
88119: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88120: LD_ADDR_VAR 0 1
88124: PUSH
88125: LD_INT 22
88127: PUSH
88128: LD_OWVAR 2
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: PUSH
88137: LD_INT 2
88139: PUSH
88140: LD_INT 30
88142: PUSH
88143: LD_INT 0
88145: PUSH
88146: EMPTY
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 30
88152: PUSH
88153: LD_INT 1
88155: PUSH
88156: EMPTY
88157: LIST
88158: LIST
88159: PUSH
88160: EMPTY
88161: LIST
88162: LIST
88163: LIST
88164: PUSH
88165: EMPTY
88166: LIST
88167: LIST
88168: PPUSH
88169: CALL_OW 69
88173: ST_TO_ADDR
// if not depot then
88174: LD_VAR 0 1
88178: NOT
88179: IFFALSE 88183
// exit ;
88181: GO 88257
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88183: LD_ADDR_VAR 0 2
88187: PUSH
88188: LD_VAR 0 1
88192: PUSH
88193: LD_INT 1
88195: PPUSH
88196: LD_VAR 0 1
88200: PPUSH
88201: CALL_OW 12
88205: ARRAY
88206: PPUSH
88207: CALL_OW 274
88211: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88212: LD_VAR 0 2
88216: PPUSH
88217: LD_INT 1
88219: PPUSH
88220: LD_INT 0
88222: PPUSH
88223: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88227: LD_VAR 0 2
88231: PPUSH
88232: LD_INT 2
88234: PPUSH
88235: LD_INT 0
88237: PPUSH
88238: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88242: LD_VAR 0 2
88246: PPUSH
88247: LD_INT 3
88249: PPUSH
88250: LD_INT 0
88252: PPUSH
88253: CALL_OW 277
// end ;
88257: PPOPN 2
88259: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88260: LD_EXP 115
88264: PUSH
88265: LD_EXP 143
88269: AND
88270: IFFALSE 88367
88272: GO 88274
88274: DISABLE
88275: LD_INT 0
88277: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
88278: LD_ADDR_VAR 0 1
88282: PUSH
88283: LD_INT 22
88285: PUSH
88286: LD_OWVAR 2
88290: PUSH
88291: EMPTY
88292: LIST
88293: LIST
88294: PUSH
88295: LD_INT 21
88297: PUSH
88298: LD_INT 1
88300: PUSH
88301: EMPTY
88302: LIST
88303: LIST
88304: PUSH
88305: LD_INT 3
88307: PUSH
88308: LD_INT 23
88310: PUSH
88311: LD_INT 0
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: PUSH
88318: EMPTY
88319: LIST
88320: LIST
88321: PUSH
88322: EMPTY
88323: LIST
88324: LIST
88325: LIST
88326: PPUSH
88327: CALL_OW 69
88331: ST_TO_ADDR
// if not tmp then
88332: LD_VAR 0 1
88336: NOT
88337: IFFALSE 88341
// exit ;
88339: GO 88367
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
88341: LD_VAR 0 1
88345: PUSH
88346: LD_INT 1
88348: PPUSH
88349: LD_VAR 0 1
88353: PPUSH
88354: CALL_OW 12
88358: ARRAY
88359: PPUSH
88360: LD_INT 200
88362: PPUSH
88363: CALL_OW 234
// end ;
88367: PPOPN 1
88369: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
88370: LD_EXP 115
88374: PUSH
88375: LD_EXP 144
88379: AND
88380: IFFALSE 88459
88382: GO 88384
88384: DISABLE
88385: LD_INT 0
88387: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
88388: LD_ADDR_VAR 0 1
88392: PUSH
88393: LD_INT 22
88395: PUSH
88396: LD_OWVAR 2
88400: PUSH
88401: EMPTY
88402: LIST
88403: LIST
88404: PUSH
88405: LD_INT 21
88407: PUSH
88408: LD_INT 2
88410: PUSH
88411: EMPTY
88412: LIST
88413: LIST
88414: PUSH
88415: EMPTY
88416: LIST
88417: LIST
88418: PPUSH
88419: CALL_OW 69
88423: ST_TO_ADDR
// if not tmp then
88424: LD_VAR 0 1
88428: NOT
88429: IFFALSE 88433
// exit ;
88431: GO 88459
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
88433: LD_VAR 0 1
88437: PUSH
88438: LD_INT 1
88440: PPUSH
88441: LD_VAR 0 1
88445: PPUSH
88446: CALL_OW 12
88450: ARRAY
88451: PPUSH
88452: LD_INT 60
88454: PPUSH
88455: CALL_OW 234
// end ;
88459: PPOPN 1
88461: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88462: LD_EXP 115
88466: PUSH
88467: LD_EXP 145
88471: AND
88472: IFFALSE 88571
88474: GO 88476
88476: DISABLE
88477: LD_INT 0
88479: PPUSH
88480: PPUSH
// begin enable ;
88481: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88482: LD_ADDR_VAR 0 1
88486: PUSH
88487: LD_INT 22
88489: PUSH
88490: LD_OWVAR 2
88494: PUSH
88495: EMPTY
88496: LIST
88497: LIST
88498: PUSH
88499: LD_INT 61
88501: PUSH
88502: EMPTY
88503: LIST
88504: PUSH
88505: LD_INT 33
88507: PUSH
88508: LD_INT 2
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: LIST
88519: PPUSH
88520: CALL_OW 69
88524: ST_TO_ADDR
// if not tmp then
88525: LD_VAR 0 1
88529: NOT
88530: IFFALSE 88534
// exit ;
88532: GO 88571
// for i in tmp do
88534: LD_ADDR_VAR 0 2
88538: PUSH
88539: LD_VAR 0 1
88543: PUSH
88544: FOR_IN
88545: IFFALSE 88569
// if IsControledBy ( i ) then
88547: LD_VAR 0 2
88551: PPUSH
88552: CALL_OW 312
88556: IFFALSE 88567
// ComUnlink ( i ) ;
88558: LD_VAR 0 2
88562: PPUSH
88563: CALL_OW 136
88567: GO 88544
88569: POP
88570: POP
// end ;
88571: PPOPN 2
88573: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88574: LD_EXP 115
88578: PUSH
88579: LD_EXP 146
88583: AND
88584: IFFALSE 88724
88586: GO 88588
88588: DISABLE
88589: LD_INT 0
88591: PPUSH
88592: PPUSH
// begin ToLua ( displayPowell(); ) ;
88593: LD_STRING displayPowell();
88595: PPUSH
88596: CALL_OW 559
// uc_side := 0 ;
88600: LD_ADDR_OWVAR 20
88604: PUSH
88605: LD_INT 0
88607: ST_TO_ADDR
// uc_nation := 2 ;
88608: LD_ADDR_OWVAR 21
88612: PUSH
88613: LD_INT 2
88615: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88616: LD_ADDR_OWVAR 37
88620: PUSH
88621: LD_INT 14
88623: ST_TO_ADDR
// vc_engine := engine_siberite ;
88624: LD_ADDR_OWVAR 39
88628: PUSH
88629: LD_INT 3
88631: ST_TO_ADDR
// vc_control := control_apeman ;
88632: LD_ADDR_OWVAR 38
88636: PUSH
88637: LD_INT 5
88639: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
88640: LD_ADDR_OWVAR 40
88644: PUSH
88645: LD_INT 29
88647: ST_TO_ADDR
// un := CreateVehicle ;
88648: LD_ADDR_VAR 0 2
88652: PUSH
88653: CALL_OW 45
88657: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
88658: LD_VAR 0 2
88662: PPUSH
88663: LD_INT 1
88665: PPUSH
88666: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
88670: LD_INT 35
88672: PPUSH
88673: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
88677: LD_VAR 0 2
88681: PPUSH
88682: LD_INT 22
88684: PUSH
88685: LD_OWVAR 2
88689: PUSH
88690: EMPTY
88691: LIST
88692: LIST
88693: PPUSH
88694: CALL_OW 69
88698: PPUSH
88699: LD_VAR 0 2
88703: PPUSH
88704: CALL_OW 74
88708: PPUSH
88709: CALL_OW 115
// until IsDead ( un ) ;
88713: LD_VAR 0 2
88717: PPUSH
88718: CALL_OW 301
88722: IFFALSE 88670
// end ;
88724: PPOPN 2
88726: END
// every 0 0$1 trigger StreamModeActive and sStu do
88727: LD_EXP 115
88731: PUSH
88732: LD_EXP 154
88736: AND
88737: IFFALSE 88753
88739: GO 88741
88741: DISABLE
// begin ToLua ( displayStucuk(); ) ;
88742: LD_STRING displayStucuk();
88744: PPUSH
88745: CALL_OW 559
// ResetFog ;
88749: CALL_OW 335
// end ;
88753: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
88754: LD_EXP 115
88758: PUSH
88759: LD_EXP 147
88763: AND
88764: IFFALSE 88905
88766: GO 88768
88768: DISABLE
88769: LD_INT 0
88771: PPUSH
88772: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88773: LD_ADDR_VAR 0 2
88777: PUSH
88778: LD_INT 22
88780: PUSH
88781: LD_OWVAR 2
88785: PUSH
88786: EMPTY
88787: LIST
88788: LIST
88789: PUSH
88790: LD_INT 21
88792: PUSH
88793: LD_INT 1
88795: PUSH
88796: EMPTY
88797: LIST
88798: LIST
88799: PUSH
88800: EMPTY
88801: LIST
88802: LIST
88803: PPUSH
88804: CALL_OW 69
88808: ST_TO_ADDR
// if not tmp then
88809: LD_VAR 0 2
88813: NOT
88814: IFFALSE 88818
// exit ;
88816: GO 88905
// un := tmp [ rand ( 1 , tmp ) ] ;
88818: LD_ADDR_VAR 0 1
88822: PUSH
88823: LD_VAR 0 2
88827: PUSH
88828: LD_INT 1
88830: PPUSH
88831: LD_VAR 0 2
88835: PPUSH
88836: CALL_OW 12
88840: ARRAY
88841: ST_TO_ADDR
// SetSide ( un , 0 ) ;
88842: LD_VAR 0 1
88846: PPUSH
88847: LD_INT 0
88849: PPUSH
88850: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
88854: LD_VAR 0 1
88858: PPUSH
88859: LD_OWVAR 3
88863: PUSH
88864: LD_VAR 0 1
88868: DIFF
88869: PPUSH
88870: LD_VAR 0 1
88874: PPUSH
88875: CALL_OW 74
88879: PPUSH
88880: CALL_OW 115
// wait ( 0 0$20 ) ;
88884: LD_INT 700
88886: PPUSH
88887: CALL_OW 67
// SetSide ( un , your_side ) ;
88891: LD_VAR 0 1
88895: PPUSH
88896: LD_OWVAR 2
88900: PPUSH
88901: CALL_OW 235
// end ;
88905: PPOPN 2
88907: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
88908: LD_EXP 115
88912: PUSH
88913: LD_EXP 148
88917: AND
88918: IFFALSE 89024
88920: GO 88922
88922: DISABLE
88923: LD_INT 0
88925: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88926: LD_ADDR_VAR 0 1
88930: PUSH
88931: LD_INT 22
88933: PUSH
88934: LD_OWVAR 2
88938: PUSH
88939: EMPTY
88940: LIST
88941: LIST
88942: PUSH
88943: LD_INT 2
88945: PUSH
88946: LD_INT 30
88948: PUSH
88949: LD_INT 0
88951: PUSH
88952: EMPTY
88953: LIST
88954: LIST
88955: PUSH
88956: LD_INT 30
88958: PUSH
88959: LD_INT 1
88961: PUSH
88962: EMPTY
88963: LIST
88964: LIST
88965: PUSH
88966: EMPTY
88967: LIST
88968: LIST
88969: LIST
88970: PUSH
88971: EMPTY
88972: LIST
88973: LIST
88974: PPUSH
88975: CALL_OW 69
88979: ST_TO_ADDR
// if not depot then
88980: LD_VAR 0 1
88984: NOT
88985: IFFALSE 88989
// exit ;
88987: GO 89024
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
88989: LD_VAR 0 1
88993: PUSH
88994: LD_INT 1
88996: ARRAY
88997: PPUSH
88998: CALL_OW 250
89002: PPUSH
89003: LD_VAR 0 1
89007: PUSH
89008: LD_INT 1
89010: ARRAY
89011: PPUSH
89012: CALL_OW 251
89016: PPUSH
89017: LD_INT 70
89019: PPUSH
89020: CALL_OW 495
// end ;
89024: PPOPN 1
89026: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
89027: LD_EXP 115
89031: PUSH
89032: LD_EXP 149
89036: AND
89037: IFFALSE 89248
89039: GO 89041
89041: DISABLE
89042: LD_INT 0
89044: PPUSH
89045: PPUSH
89046: PPUSH
89047: PPUSH
89048: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89049: LD_ADDR_VAR 0 5
89053: PUSH
89054: LD_INT 22
89056: PUSH
89057: LD_OWVAR 2
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: PUSH
89066: LD_INT 21
89068: PUSH
89069: LD_INT 1
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: PUSH
89076: EMPTY
89077: LIST
89078: LIST
89079: PPUSH
89080: CALL_OW 69
89084: ST_TO_ADDR
// if not tmp then
89085: LD_VAR 0 5
89089: NOT
89090: IFFALSE 89094
// exit ;
89092: GO 89248
// for i in tmp do
89094: LD_ADDR_VAR 0 1
89098: PUSH
89099: LD_VAR 0 5
89103: PUSH
89104: FOR_IN
89105: IFFALSE 89246
// begin d := rand ( 0 , 5 ) ;
89107: LD_ADDR_VAR 0 4
89111: PUSH
89112: LD_INT 0
89114: PPUSH
89115: LD_INT 5
89117: PPUSH
89118: CALL_OW 12
89122: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89123: LD_ADDR_VAR 0 2
89127: PUSH
89128: LD_VAR 0 1
89132: PPUSH
89133: CALL_OW 250
89137: PPUSH
89138: LD_VAR 0 4
89142: PPUSH
89143: LD_INT 3
89145: PPUSH
89146: LD_INT 12
89148: PPUSH
89149: CALL_OW 12
89153: PPUSH
89154: CALL_OW 272
89158: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89159: LD_ADDR_VAR 0 3
89163: PUSH
89164: LD_VAR 0 1
89168: PPUSH
89169: CALL_OW 251
89173: PPUSH
89174: LD_VAR 0 4
89178: PPUSH
89179: LD_INT 3
89181: PPUSH
89182: LD_INT 12
89184: PPUSH
89185: CALL_OW 12
89189: PPUSH
89190: CALL_OW 273
89194: ST_TO_ADDR
// if ValidHex ( x , y ) then
89195: LD_VAR 0 2
89199: PPUSH
89200: LD_VAR 0 3
89204: PPUSH
89205: CALL_OW 488
89209: IFFALSE 89244
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89211: LD_VAR 0 1
89215: PPUSH
89216: LD_VAR 0 2
89220: PPUSH
89221: LD_VAR 0 3
89225: PPUSH
89226: LD_INT 3
89228: PPUSH
89229: LD_INT 6
89231: PPUSH
89232: CALL_OW 12
89236: PPUSH
89237: LD_INT 1
89239: PPUSH
89240: CALL_OW 483
// end ;
89244: GO 89104
89246: POP
89247: POP
// end ;
89248: PPOPN 5
89250: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89251: LD_EXP 115
89255: PUSH
89256: LD_EXP 150
89260: AND
89261: IFFALSE 89355
89263: GO 89265
89265: DISABLE
89266: LD_INT 0
89268: PPUSH
89269: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
89270: LD_ADDR_VAR 0 2
89274: PUSH
89275: LD_INT 22
89277: PUSH
89278: LD_OWVAR 2
89282: PUSH
89283: EMPTY
89284: LIST
89285: LIST
89286: PUSH
89287: LD_INT 32
89289: PUSH
89290: LD_INT 1
89292: PUSH
89293: EMPTY
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 21
89299: PUSH
89300: LD_INT 2
89302: PUSH
89303: EMPTY
89304: LIST
89305: LIST
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: LIST
89311: PPUSH
89312: CALL_OW 69
89316: ST_TO_ADDR
// if not tmp then
89317: LD_VAR 0 2
89321: NOT
89322: IFFALSE 89326
// exit ;
89324: GO 89355
// for i in tmp do
89326: LD_ADDR_VAR 0 1
89330: PUSH
89331: LD_VAR 0 2
89335: PUSH
89336: FOR_IN
89337: IFFALSE 89353
// SetFuel ( i , 0 ) ;
89339: LD_VAR 0 1
89343: PPUSH
89344: LD_INT 0
89346: PPUSH
89347: CALL_OW 240
89351: GO 89336
89353: POP
89354: POP
// end ;
89355: PPOPN 2
89357: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
89358: LD_EXP 115
89362: PUSH
89363: LD_EXP 151
89367: AND
89368: IFFALSE 89434
89370: GO 89372
89372: DISABLE
89373: LD_INT 0
89375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
89376: LD_ADDR_VAR 0 1
89380: PUSH
89381: LD_INT 22
89383: PUSH
89384: LD_OWVAR 2
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: PUSH
89393: LD_INT 30
89395: PUSH
89396: LD_INT 29
89398: PUSH
89399: EMPTY
89400: LIST
89401: LIST
89402: PUSH
89403: EMPTY
89404: LIST
89405: LIST
89406: PPUSH
89407: CALL_OW 69
89411: ST_TO_ADDR
// if not tmp then
89412: LD_VAR 0 1
89416: NOT
89417: IFFALSE 89421
// exit ;
89419: GO 89434
// DestroyUnit ( tmp [ 1 ] ) ;
89421: LD_VAR 0 1
89425: PUSH
89426: LD_INT 1
89428: ARRAY
89429: PPUSH
89430: CALL_OW 65
// end ;
89434: PPOPN 1
89436: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
89437: LD_EXP 115
89441: PUSH
89442: LD_EXP 153
89446: AND
89447: IFFALSE 89576
89449: GO 89451
89451: DISABLE
89452: LD_INT 0
89454: PPUSH
// begin uc_side := 0 ;
89455: LD_ADDR_OWVAR 20
89459: PUSH
89460: LD_INT 0
89462: ST_TO_ADDR
// uc_nation := nation_arabian ;
89463: LD_ADDR_OWVAR 21
89467: PUSH
89468: LD_INT 2
89470: ST_TO_ADDR
// hc_gallery :=  ;
89471: LD_ADDR_OWVAR 33
89475: PUSH
89476: LD_STRING 
89478: ST_TO_ADDR
// hc_name :=  ;
89479: LD_ADDR_OWVAR 26
89483: PUSH
89484: LD_STRING 
89486: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89487: LD_INT 1
89489: PPUSH
89490: LD_INT 11
89492: PPUSH
89493: LD_INT 10
89495: PPUSH
89496: CALL_OW 380
// un := CreateHuman ;
89500: LD_ADDR_VAR 0 1
89504: PUSH
89505: CALL_OW 44
89509: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89510: LD_VAR 0 1
89514: PPUSH
89515: LD_INT 1
89517: PPUSH
89518: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89522: LD_INT 35
89524: PPUSH
89525: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89529: LD_VAR 0 1
89533: PPUSH
89534: LD_INT 22
89536: PUSH
89537: LD_OWVAR 2
89541: PUSH
89542: EMPTY
89543: LIST
89544: LIST
89545: PPUSH
89546: CALL_OW 69
89550: PPUSH
89551: LD_VAR 0 1
89555: PPUSH
89556: CALL_OW 74
89560: PPUSH
89561: CALL_OW 115
// until IsDead ( un ) ;
89565: LD_VAR 0 1
89569: PPUSH
89570: CALL_OW 301
89574: IFFALSE 89522
// end ;
89576: PPOPN 1
89578: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89579: LD_EXP 115
89583: PUSH
89584: LD_EXP 155
89588: AND
89589: IFFALSE 89601
89591: GO 89593
89593: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89594: LD_STRING earthquake(getX(game), 0, 32)
89596: PPUSH
89597: CALL_OW 559
89601: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89602: LD_EXP 115
89606: PUSH
89607: LD_EXP 156
89611: AND
89612: IFFALSE 89703
89614: GO 89616
89616: DISABLE
89617: LD_INT 0
89619: PPUSH
// begin enable ;
89620: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89621: LD_ADDR_VAR 0 1
89625: PUSH
89626: LD_INT 22
89628: PUSH
89629: LD_OWVAR 2
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: PUSH
89638: LD_INT 21
89640: PUSH
89641: LD_INT 2
89643: PUSH
89644: EMPTY
89645: LIST
89646: LIST
89647: PUSH
89648: LD_INT 33
89650: PUSH
89651: LD_INT 3
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: LIST
89662: PPUSH
89663: CALL_OW 69
89667: ST_TO_ADDR
// if not tmp then
89668: LD_VAR 0 1
89672: NOT
89673: IFFALSE 89677
// exit ;
89675: GO 89703
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
89677: LD_VAR 0 1
89681: PUSH
89682: LD_INT 1
89684: PPUSH
89685: LD_VAR 0 1
89689: PPUSH
89690: CALL_OW 12
89694: ARRAY
89695: PPUSH
89696: LD_INT 1
89698: PPUSH
89699: CALL_OW 234
// end ;
89703: PPOPN 1
89705: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
89706: LD_EXP 115
89710: PUSH
89711: LD_EXP 157
89715: AND
89716: IFFALSE 89857
89718: GO 89720
89720: DISABLE
89721: LD_INT 0
89723: PPUSH
89724: PPUSH
89725: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89726: LD_ADDR_VAR 0 3
89730: PUSH
89731: LD_INT 22
89733: PUSH
89734: LD_OWVAR 2
89738: PUSH
89739: EMPTY
89740: LIST
89741: LIST
89742: PUSH
89743: LD_INT 25
89745: PUSH
89746: LD_INT 1
89748: PUSH
89749: EMPTY
89750: LIST
89751: LIST
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: PPUSH
89757: CALL_OW 69
89761: ST_TO_ADDR
// if not tmp then
89762: LD_VAR 0 3
89766: NOT
89767: IFFALSE 89771
// exit ;
89769: GO 89857
// un := tmp [ rand ( 1 , tmp ) ] ;
89771: LD_ADDR_VAR 0 2
89775: PUSH
89776: LD_VAR 0 3
89780: PUSH
89781: LD_INT 1
89783: PPUSH
89784: LD_VAR 0 3
89788: PPUSH
89789: CALL_OW 12
89793: ARRAY
89794: ST_TO_ADDR
// if Crawls ( un ) then
89795: LD_VAR 0 2
89799: PPUSH
89800: CALL_OW 318
89804: IFFALSE 89815
// ComWalk ( un ) ;
89806: LD_VAR 0 2
89810: PPUSH
89811: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
89815: LD_VAR 0 2
89819: PPUSH
89820: LD_INT 9
89822: PPUSH
89823: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
89827: LD_INT 28
89829: PPUSH
89830: LD_OWVAR 2
89834: PPUSH
89835: LD_INT 2
89837: PPUSH
89838: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
89842: LD_INT 29
89844: PPUSH
89845: LD_OWVAR 2
89849: PPUSH
89850: LD_INT 2
89852: PPUSH
89853: CALL_OW 322
// end ;
89857: PPOPN 3
89859: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
89860: LD_EXP 115
89864: PUSH
89865: LD_EXP 158
89869: AND
89870: IFFALSE 89981
89872: GO 89874
89874: DISABLE
89875: LD_INT 0
89877: PPUSH
89878: PPUSH
89879: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
89880: LD_ADDR_VAR 0 3
89884: PUSH
89885: LD_INT 22
89887: PUSH
89888: LD_OWVAR 2
89892: PUSH
89893: EMPTY
89894: LIST
89895: LIST
89896: PUSH
89897: LD_INT 25
89899: PUSH
89900: LD_INT 1
89902: PUSH
89903: EMPTY
89904: LIST
89905: LIST
89906: PUSH
89907: EMPTY
89908: LIST
89909: LIST
89910: PPUSH
89911: CALL_OW 69
89915: ST_TO_ADDR
// if not tmp then
89916: LD_VAR 0 3
89920: NOT
89921: IFFALSE 89925
// exit ;
89923: GO 89981
// un := tmp [ rand ( 1 , tmp ) ] ;
89925: LD_ADDR_VAR 0 2
89929: PUSH
89930: LD_VAR 0 3
89934: PUSH
89935: LD_INT 1
89937: PPUSH
89938: LD_VAR 0 3
89942: PPUSH
89943: CALL_OW 12
89947: ARRAY
89948: ST_TO_ADDR
// if Crawls ( un ) then
89949: LD_VAR 0 2
89953: PPUSH
89954: CALL_OW 318
89958: IFFALSE 89969
// ComWalk ( un ) ;
89960: LD_VAR 0 2
89964: PPUSH
89965: CALL_OW 138
// SetClass ( un , class_mortar ) ;
89969: LD_VAR 0 2
89973: PPUSH
89974: LD_INT 8
89976: PPUSH
89977: CALL_OW 336
// end ;
89981: PPOPN 3
89983: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
89984: LD_EXP 115
89988: PUSH
89989: LD_EXP 159
89993: AND
89994: IFFALSE 90138
89996: GO 89998
89998: DISABLE
89999: LD_INT 0
90001: PPUSH
90002: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
90003: LD_ADDR_VAR 0 2
90007: PUSH
90008: LD_INT 22
90010: PUSH
90011: LD_OWVAR 2
90015: PUSH
90016: EMPTY
90017: LIST
90018: LIST
90019: PUSH
90020: LD_INT 21
90022: PUSH
90023: LD_INT 2
90025: PUSH
90026: EMPTY
90027: LIST
90028: LIST
90029: PUSH
90030: LD_INT 2
90032: PUSH
90033: LD_INT 34
90035: PUSH
90036: LD_INT 12
90038: PUSH
90039: EMPTY
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 34
90045: PUSH
90046: LD_INT 51
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: LD_INT 34
90055: PUSH
90056: LD_INT 32
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: LIST
90073: PPUSH
90074: CALL_OW 69
90078: ST_TO_ADDR
// if not tmp then
90079: LD_VAR 0 2
90083: NOT
90084: IFFALSE 90088
// exit ;
90086: GO 90138
// for i in tmp do
90088: LD_ADDR_VAR 0 1
90092: PUSH
90093: LD_VAR 0 2
90097: PUSH
90098: FOR_IN
90099: IFFALSE 90136
// if GetCargo ( i , mat_artifact ) = 0 then
90101: LD_VAR 0 1
90105: PPUSH
90106: LD_INT 4
90108: PPUSH
90109: CALL_OW 289
90113: PUSH
90114: LD_INT 0
90116: EQUAL
90117: IFFALSE 90134
// SetCargo ( i , mat_siberit , 100 ) ;
90119: LD_VAR 0 1
90123: PPUSH
90124: LD_INT 3
90126: PPUSH
90127: LD_INT 100
90129: PPUSH
90130: CALL_OW 290
90134: GO 90098
90136: POP
90137: POP
// end ;
90138: PPOPN 2
90140: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90141: LD_EXP 115
90145: PUSH
90146: LD_EXP 160
90150: AND
90151: IFFALSE 90304
90153: GO 90155
90155: DISABLE
90156: LD_INT 0
90158: PPUSH
90159: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90160: LD_ADDR_VAR 0 2
90164: PUSH
90165: LD_INT 22
90167: PUSH
90168: LD_OWVAR 2
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PPUSH
90177: CALL_OW 69
90181: ST_TO_ADDR
// if not tmp then
90182: LD_VAR 0 2
90186: NOT
90187: IFFALSE 90191
// exit ;
90189: GO 90304
// for i := 1 to 2 do
90191: LD_ADDR_VAR 0 1
90195: PUSH
90196: DOUBLE
90197: LD_INT 1
90199: DEC
90200: ST_TO_ADDR
90201: LD_INT 2
90203: PUSH
90204: FOR_TO
90205: IFFALSE 90302
// begin uc_side := your_side ;
90207: LD_ADDR_OWVAR 20
90211: PUSH
90212: LD_OWVAR 2
90216: ST_TO_ADDR
// uc_nation := nation_american ;
90217: LD_ADDR_OWVAR 21
90221: PUSH
90222: LD_INT 1
90224: ST_TO_ADDR
// vc_chassis := us_morphling ;
90225: LD_ADDR_OWVAR 37
90229: PUSH
90230: LD_INT 5
90232: ST_TO_ADDR
// vc_engine := engine_siberite ;
90233: LD_ADDR_OWVAR 39
90237: PUSH
90238: LD_INT 3
90240: ST_TO_ADDR
// vc_control := control_computer ;
90241: LD_ADDR_OWVAR 38
90245: PUSH
90246: LD_INT 3
90248: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90249: LD_ADDR_OWVAR 40
90253: PUSH
90254: LD_INT 10
90256: ST_TO_ADDR
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) ;
90257: CALL_OW 45
90261: PPUSH
90262: LD_VAR 0 2
90266: PUSH
90267: LD_INT 1
90269: ARRAY
90270: PPUSH
90271: CALL_OW 250
90275: PPUSH
90276: LD_VAR 0 2
90280: PUSH
90281: LD_INT 1
90283: ARRAY
90284: PPUSH
90285: CALL_OW 251
90289: PPUSH
90290: LD_INT 12
90292: PPUSH
90293: LD_INT 1
90295: PPUSH
90296: CALL_OW 50
// end ;
90300: GO 90204
90302: POP
90303: POP
// end ;
90304: PPOPN 2
90306: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
90307: LD_EXP 115
90311: PUSH
90312: LD_EXP 161
90316: AND
90317: IFFALSE 90539
90319: GO 90321
90321: DISABLE
90322: LD_INT 0
90324: PPUSH
90325: PPUSH
90326: PPUSH
90327: PPUSH
90328: PPUSH
90329: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90330: LD_ADDR_VAR 0 6
90334: PUSH
90335: LD_INT 22
90337: PUSH
90338: LD_OWVAR 2
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: PUSH
90347: LD_INT 21
90349: PUSH
90350: LD_INT 1
90352: PUSH
90353: EMPTY
90354: LIST
90355: LIST
90356: PUSH
90357: LD_INT 3
90359: PUSH
90360: LD_INT 23
90362: PUSH
90363: LD_INT 0
90365: PUSH
90366: EMPTY
90367: LIST
90368: LIST
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: LIST
90378: PPUSH
90379: CALL_OW 69
90383: ST_TO_ADDR
// if not tmp then
90384: LD_VAR 0 6
90388: NOT
90389: IFFALSE 90393
// exit ;
90391: GO 90539
// s1 := rand ( 1 , 4 ) ;
90393: LD_ADDR_VAR 0 2
90397: PUSH
90398: LD_INT 1
90400: PPUSH
90401: LD_INT 4
90403: PPUSH
90404: CALL_OW 12
90408: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
90409: LD_ADDR_VAR 0 4
90413: PUSH
90414: LD_VAR 0 6
90418: PUSH
90419: LD_INT 1
90421: ARRAY
90422: PPUSH
90423: LD_VAR 0 2
90427: PPUSH
90428: CALL_OW 259
90432: ST_TO_ADDR
// if s1 = 1 then
90433: LD_VAR 0 2
90437: PUSH
90438: LD_INT 1
90440: EQUAL
90441: IFFALSE 90461
// s2 := rand ( 2 , 4 ) else
90443: LD_ADDR_VAR 0 3
90447: PUSH
90448: LD_INT 2
90450: PPUSH
90451: LD_INT 4
90453: PPUSH
90454: CALL_OW 12
90458: ST_TO_ADDR
90459: GO 90469
// s2 := 1 ;
90461: LD_ADDR_VAR 0 3
90465: PUSH
90466: LD_INT 1
90468: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90469: LD_ADDR_VAR 0 5
90473: PUSH
90474: LD_VAR 0 6
90478: PUSH
90479: LD_INT 1
90481: ARRAY
90482: PPUSH
90483: LD_VAR 0 3
90487: PPUSH
90488: CALL_OW 259
90492: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90493: LD_VAR 0 6
90497: PUSH
90498: LD_INT 1
90500: ARRAY
90501: PPUSH
90502: LD_VAR 0 2
90506: PPUSH
90507: LD_VAR 0 5
90511: PPUSH
90512: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90516: LD_VAR 0 6
90520: PUSH
90521: LD_INT 1
90523: ARRAY
90524: PPUSH
90525: LD_VAR 0 3
90529: PPUSH
90530: LD_VAR 0 4
90534: PPUSH
90535: CALL_OW 237
// end ;
90539: PPOPN 6
90541: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90542: LD_EXP 115
90546: PUSH
90547: LD_EXP 162
90551: AND
90552: IFFALSE 90631
90554: GO 90556
90556: DISABLE
90557: LD_INT 0
90559: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90560: LD_ADDR_VAR 0 1
90564: PUSH
90565: LD_INT 22
90567: PUSH
90568: LD_OWVAR 2
90572: PUSH
90573: EMPTY
90574: LIST
90575: LIST
90576: PUSH
90577: LD_INT 30
90579: PUSH
90580: LD_INT 3
90582: PUSH
90583: EMPTY
90584: LIST
90585: LIST
90586: PUSH
90587: EMPTY
90588: LIST
90589: LIST
90590: PPUSH
90591: CALL_OW 69
90595: ST_TO_ADDR
// if not tmp then
90596: LD_VAR 0 1
90600: NOT
90601: IFFALSE 90605
// exit ;
90603: GO 90631
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90605: LD_VAR 0 1
90609: PUSH
90610: LD_INT 1
90612: PPUSH
90613: LD_VAR 0 1
90617: PPUSH
90618: CALL_OW 12
90622: ARRAY
90623: PPUSH
90624: LD_INT 1
90626: PPUSH
90627: CALL_OW 234
// end ;
90631: PPOPN 1
90633: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
90634: LD_EXP 115
90638: PUSH
90639: LD_EXP 163
90643: AND
90644: IFFALSE 90756
90646: GO 90648
90648: DISABLE
90649: LD_INT 0
90651: PPUSH
90652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
90653: LD_ADDR_VAR 0 2
90657: PUSH
90658: LD_INT 22
90660: PUSH
90661: LD_OWVAR 2
90665: PUSH
90666: EMPTY
90667: LIST
90668: LIST
90669: PUSH
90670: LD_INT 2
90672: PUSH
90673: LD_INT 30
90675: PUSH
90676: LD_INT 27
90678: PUSH
90679: EMPTY
90680: LIST
90681: LIST
90682: PUSH
90683: LD_INT 30
90685: PUSH
90686: LD_INT 26
90688: PUSH
90689: EMPTY
90690: LIST
90691: LIST
90692: PUSH
90693: LD_INT 30
90695: PUSH
90696: LD_INT 28
90698: PUSH
90699: EMPTY
90700: LIST
90701: LIST
90702: PUSH
90703: EMPTY
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PPUSH
90713: CALL_OW 69
90717: ST_TO_ADDR
// if not tmp then
90718: LD_VAR 0 2
90722: NOT
90723: IFFALSE 90727
// exit ;
90725: GO 90756
// for i in tmp do
90727: LD_ADDR_VAR 0 1
90731: PUSH
90732: LD_VAR 0 2
90736: PUSH
90737: FOR_IN
90738: IFFALSE 90754
// SetLives ( i , 1 ) ;
90740: LD_VAR 0 1
90744: PPUSH
90745: LD_INT 1
90747: PPUSH
90748: CALL_OW 234
90752: GO 90737
90754: POP
90755: POP
// end ;
90756: PPOPN 2
90758: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
90759: LD_EXP 115
90763: PUSH
90764: LD_EXP 164
90768: AND
90769: IFFALSE 91043
90771: GO 90773
90773: DISABLE
90774: LD_INT 0
90776: PPUSH
90777: PPUSH
90778: PPUSH
// begin i := rand ( 1 , 7 ) ;
90779: LD_ADDR_VAR 0 1
90783: PUSH
90784: LD_INT 1
90786: PPUSH
90787: LD_INT 7
90789: PPUSH
90790: CALL_OW 12
90794: ST_TO_ADDR
// case i of 1 :
90795: LD_VAR 0 1
90799: PUSH
90800: LD_INT 1
90802: DOUBLE
90803: EQUAL
90804: IFTRUE 90808
90806: GO 90818
90808: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
90809: LD_STRING earthquake(getX(game), 0, 32)
90811: PPUSH
90812: CALL_OW 559
90816: GO 91043
90818: LD_INT 2
90820: DOUBLE
90821: EQUAL
90822: IFTRUE 90826
90824: GO 90840
90826: POP
// begin ToLua ( displayStucuk(); ) ;
90827: LD_STRING displayStucuk();
90829: PPUSH
90830: CALL_OW 559
// ResetFog ;
90834: CALL_OW 335
// end ; 3 :
90838: GO 91043
90840: LD_INT 3
90842: DOUBLE
90843: EQUAL
90844: IFTRUE 90848
90846: GO 90952
90848: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90849: LD_ADDR_VAR 0 2
90853: PUSH
90854: LD_INT 22
90856: PUSH
90857: LD_OWVAR 2
90861: PUSH
90862: EMPTY
90863: LIST
90864: LIST
90865: PUSH
90866: LD_INT 25
90868: PUSH
90869: LD_INT 1
90871: PUSH
90872: EMPTY
90873: LIST
90874: LIST
90875: PUSH
90876: EMPTY
90877: LIST
90878: LIST
90879: PPUSH
90880: CALL_OW 69
90884: ST_TO_ADDR
// if not tmp then
90885: LD_VAR 0 2
90889: NOT
90890: IFFALSE 90894
// exit ;
90892: GO 91043
// un := tmp [ rand ( 1 , tmp ) ] ;
90894: LD_ADDR_VAR 0 3
90898: PUSH
90899: LD_VAR 0 2
90903: PUSH
90904: LD_INT 1
90906: PPUSH
90907: LD_VAR 0 2
90911: PPUSH
90912: CALL_OW 12
90916: ARRAY
90917: ST_TO_ADDR
// if Crawls ( un ) then
90918: LD_VAR 0 3
90922: PPUSH
90923: CALL_OW 318
90927: IFFALSE 90938
// ComWalk ( un ) ;
90929: LD_VAR 0 3
90933: PPUSH
90934: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90938: LD_VAR 0 3
90942: PPUSH
90943: LD_INT 8
90945: PPUSH
90946: CALL_OW 336
// end ; 4 :
90950: GO 91043
90952: LD_INT 4
90954: DOUBLE
90955: EQUAL
90956: IFTRUE 90960
90958: GO 91021
90960: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90961: LD_ADDR_VAR 0 2
90965: PUSH
90966: LD_INT 22
90968: PUSH
90969: LD_OWVAR 2
90973: PUSH
90974: EMPTY
90975: LIST
90976: LIST
90977: PUSH
90978: LD_INT 30
90980: PUSH
90981: LD_INT 29
90983: PUSH
90984: EMPTY
90985: LIST
90986: LIST
90987: PUSH
90988: EMPTY
90989: LIST
90990: LIST
90991: PPUSH
90992: CALL_OW 69
90996: ST_TO_ADDR
// if not tmp then
90997: LD_VAR 0 2
91001: NOT
91002: IFFALSE 91006
// exit ;
91004: GO 91043
// DestroyUnit ( tmp [ 1 ] ) ;
91006: LD_VAR 0 2
91010: PUSH
91011: LD_INT 1
91013: ARRAY
91014: PPUSH
91015: CALL_OW 65
// end ; 5 .. 7 :
91019: GO 91043
91021: LD_INT 5
91023: DOUBLE
91024: GREATEREQUAL
91025: IFFALSE 91033
91027: LD_INT 7
91029: DOUBLE
91030: LESSEQUAL
91031: IFTRUE 91035
91033: GO 91042
91035: POP
// StreamSibBomb ; end ;
91036: CALL 87323 0 0
91040: GO 91043
91042: POP
// end ;
91043: PPOPN 3
91045: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
91046: LD_EXP 115
91050: PUSH
91051: LD_EXP 165
91055: AND
91056: IFFALSE 91212
91058: GO 91060
91060: DISABLE
91061: LD_INT 0
91063: PPUSH
91064: PPUSH
91065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91066: LD_ADDR_VAR 0 2
91070: PUSH
91071: LD_INT 81
91073: PUSH
91074: LD_OWVAR 2
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: PUSH
91083: LD_INT 2
91085: PUSH
91086: LD_INT 21
91088: PUSH
91089: LD_INT 1
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 21
91098: PUSH
91099: LD_INT 2
91101: PUSH
91102: EMPTY
91103: LIST
91104: LIST
91105: PUSH
91106: EMPTY
91107: LIST
91108: LIST
91109: LIST
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: PPUSH
91115: CALL_OW 69
91119: ST_TO_ADDR
// if not tmp then
91120: LD_VAR 0 2
91124: NOT
91125: IFFALSE 91129
// exit ;
91127: GO 91212
// p := 0 ;
91129: LD_ADDR_VAR 0 3
91133: PUSH
91134: LD_INT 0
91136: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91137: LD_INT 35
91139: PPUSH
91140: CALL_OW 67
// p := p + 1 ;
91144: LD_ADDR_VAR 0 3
91148: PUSH
91149: LD_VAR 0 3
91153: PUSH
91154: LD_INT 1
91156: PLUS
91157: ST_TO_ADDR
// for i in tmp do
91158: LD_ADDR_VAR 0 1
91162: PUSH
91163: LD_VAR 0 2
91167: PUSH
91168: FOR_IN
91169: IFFALSE 91200
// if GetLives ( i ) < 1000 then
91171: LD_VAR 0 1
91175: PPUSH
91176: CALL_OW 256
91180: PUSH
91181: LD_INT 1000
91183: LESS
91184: IFFALSE 91198
// SetLives ( i , 1000 ) ;
91186: LD_VAR 0 1
91190: PPUSH
91191: LD_INT 1000
91193: PPUSH
91194: CALL_OW 234
91198: GO 91168
91200: POP
91201: POP
// until p > 20 ;
91202: LD_VAR 0 3
91206: PUSH
91207: LD_INT 20
91209: GREATER
91210: IFFALSE 91137
// end ;
91212: PPOPN 3
91214: END
// every 0 0$1 trigger StreamModeActive and sTime do
91215: LD_EXP 115
91219: PUSH
91220: LD_EXP 166
91224: AND
91225: IFFALSE 91260
91227: GO 91229
91229: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91230: LD_INT 28
91232: PPUSH
91233: LD_OWVAR 2
91237: PPUSH
91238: LD_INT 2
91240: PPUSH
91241: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
91245: LD_INT 30
91247: PPUSH
91248: LD_OWVAR 2
91252: PPUSH
91253: LD_INT 2
91255: PPUSH
91256: CALL_OW 322
// end ;
91260: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
91261: LD_EXP 115
91265: PUSH
91266: LD_EXP 167
91270: AND
91271: IFFALSE 91392
91273: GO 91275
91275: DISABLE
91276: LD_INT 0
91278: PPUSH
91279: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91280: LD_ADDR_VAR 0 2
91284: PUSH
91285: LD_INT 22
91287: PUSH
91288: LD_OWVAR 2
91292: PUSH
91293: EMPTY
91294: LIST
91295: LIST
91296: PUSH
91297: LD_INT 21
91299: PUSH
91300: LD_INT 1
91302: PUSH
91303: EMPTY
91304: LIST
91305: LIST
91306: PUSH
91307: LD_INT 3
91309: PUSH
91310: LD_INT 23
91312: PUSH
91313: LD_INT 0
91315: PUSH
91316: EMPTY
91317: LIST
91318: LIST
91319: PUSH
91320: EMPTY
91321: LIST
91322: LIST
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: LIST
91328: PPUSH
91329: CALL_OW 69
91333: ST_TO_ADDR
// if not tmp then
91334: LD_VAR 0 2
91338: NOT
91339: IFFALSE 91343
// exit ;
91341: GO 91392
// for i in tmp do
91343: LD_ADDR_VAR 0 1
91347: PUSH
91348: LD_VAR 0 2
91352: PUSH
91353: FOR_IN
91354: IFFALSE 91390
// begin if Crawls ( i ) then
91356: LD_VAR 0 1
91360: PPUSH
91361: CALL_OW 318
91365: IFFALSE 91376
// ComWalk ( i ) ;
91367: LD_VAR 0 1
91371: PPUSH
91372: CALL_OW 138
// SetClass ( i , 2 ) ;
91376: LD_VAR 0 1
91380: PPUSH
91381: LD_INT 2
91383: PPUSH
91384: CALL_OW 336
// end ;
91388: GO 91353
91390: POP
91391: POP
// end ;
91392: PPOPN 2
91394: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
91395: LD_EXP 115
91399: PUSH
91400: LD_EXP 168
91404: AND
91405: IFFALSE 91686
91407: GO 91409
91409: DISABLE
91410: LD_INT 0
91412: PPUSH
91413: PPUSH
91414: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
91415: LD_OWVAR 2
91419: PPUSH
91420: LD_INT 9
91422: PPUSH
91423: LD_INT 1
91425: PPUSH
91426: LD_INT 1
91428: PPUSH
91429: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91433: LD_INT 9
91435: PPUSH
91436: LD_OWVAR 2
91440: PPUSH
91441: CALL_OW 343
// uc_side := 9 ;
91445: LD_ADDR_OWVAR 20
91449: PUSH
91450: LD_INT 9
91452: ST_TO_ADDR
// uc_nation := 2 ;
91453: LD_ADDR_OWVAR 21
91457: PUSH
91458: LD_INT 2
91460: ST_TO_ADDR
// hc_name := Dark Warrior ;
91461: LD_ADDR_OWVAR 26
91465: PUSH
91466: LD_STRING Dark Warrior
91468: ST_TO_ADDR
// hc_gallery :=  ;
91469: LD_ADDR_OWVAR 33
91473: PUSH
91474: LD_STRING 
91476: ST_TO_ADDR
// hc_noskilllimit := true ;
91477: LD_ADDR_OWVAR 76
91481: PUSH
91482: LD_INT 1
91484: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91485: LD_ADDR_OWVAR 31
91489: PUSH
91490: LD_INT 30
91492: PUSH
91493: LD_INT 30
91495: PUSH
91496: LD_INT 30
91498: PUSH
91499: LD_INT 30
91501: PUSH
91502: EMPTY
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: ST_TO_ADDR
// un := CreateHuman ;
91508: LD_ADDR_VAR 0 3
91512: PUSH
91513: CALL_OW 44
91517: ST_TO_ADDR
// hc_noskilllimit := false ;
91518: LD_ADDR_OWVAR 76
91522: PUSH
91523: LD_INT 0
91525: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91526: LD_VAR 0 3
91530: PPUSH
91531: LD_INT 1
91533: PPUSH
91534: CALL_OW 51
// p := 0 ;
91538: LD_ADDR_VAR 0 2
91542: PUSH
91543: LD_INT 0
91545: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91546: LD_INT 35
91548: PPUSH
91549: CALL_OW 67
// p := p + 1 ;
91553: LD_ADDR_VAR 0 2
91557: PUSH
91558: LD_VAR 0 2
91562: PUSH
91563: LD_INT 1
91565: PLUS
91566: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91567: LD_VAR 0 3
91571: PPUSH
91572: CALL_OW 256
91576: PUSH
91577: LD_INT 1000
91579: LESS
91580: IFFALSE 91594
// SetLives ( un , 1000 ) ;
91582: LD_VAR 0 3
91586: PPUSH
91587: LD_INT 1000
91589: PPUSH
91590: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91594: LD_VAR 0 3
91598: PPUSH
91599: LD_INT 81
91601: PUSH
91602: LD_OWVAR 2
91606: PUSH
91607: EMPTY
91608: LIST
91609: LIST
91610: PUSH
91611: LD_INT 91
91613: PUSH
91614: LD_VAR 0 3
91618: PUSH
91619: LD_INT 30
91621: PUSH
91622: EMPTY
91623: LIST
91624: LIST
91625: LIST
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: PPUSH
91631: CALL_OW 69
91635: PPUSH
91636: LD_VAR 0 3
91640: PPUSH
91641: CALL_OW 74
91645: PPUSH
91646: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
91650: LD_VAR 0 2
91654: PUSH
91655: LD_INT 60
91657: GREATER
91658: PUSH
91659: LD_VAR 0 3
91663: PPUSH
91664: CALL_OW 301
91668: OR
91669: IFFALSE 91546
// if un then
91671: LD_VAR 0 3
91675: IFFALSE 91686
// RemoveUnit ( un ) ;
91677: LD_VAR 0 3
91681: PPUSH
91682: CALL_OW 64
// end ; end_of_file
91686: PPOPN 3
91688: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
91689: LD_INT 0
91691: PPUSH
91692: PPUSH
91693: PPUSH
91694: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
91695: LD_VAR 0 1
91699: PPUSH
91700: CALL_OW 264
91704: PUSH
91705: LD_EXP 106
91709: EQUAL
91710: IFFALSE 91782
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
91712: LD_INT 68
91714: PPUSH
91715: LD_VAR 0 1
91719: PPUSH
91720: CALL_OW 255
91724: PPUSH
91725: CALL_OW 321
91729: PUSH
91730: LD_INT 2
91732: EQUAL
91733: IFFALSE 91745
// eff := 70 else
91735: LD_ADDR_VAR 0 4
91739: PUSH
91740: LD_INT 70
91742: ST_TO_ADDR
91743: GO 91753
// eff := 30 ;
91745: LD_ADDR_VAR 0 4
91749: PUSH
91750: LD_INT 30
91752: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
91753: LD_VAR 0 1
91757: PPUSH
91758: CALL_OW 250
91762: PPUSH
91763: LD_VAR 0 1
91767: PPUSH
91768: CALL_OW 251
91772: PPUSH
91773: LD_VAR 0 4
91777: PPUSH
91778: CALL_OW 495
// end ; end ;
91782: LD_VAR 0 2
91786: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
91787: LD_INT 0
91789: PPUSH
// end ;
91790: LD_VAR 0 4
91794: RET
// export function SOS_Command ( cmd ) ; begin
91795: LD_INT 0
91797: PPUSH
// end ;
91798: LD_VAR 0 2
91802: RET
// on TargetableSAIL ( cmd , unit , selectedunit , x , y ) do begin if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
91803: LD_VAR 0 1
91807: PUSH
91808: LD_INT 255
91810: EQUAL
91811: PUSH
91812: LD_VAR 0 2
91816: PPUSH
91817: CALL_OW 264
91821: PUSH
91822: LD_INT 14
91824: PUSH
91825: LD_INT 53
91827: PUSH
91828: EMPTY
91829: LIST
91830: LIST
91831: IN
91832: AND
91833: PUSH
91834: LD_VAR 0 4
91838: PPUSH
91839: LD_VAR 0 5
91843: PPUSH
91844: CALL_OW 488
91848: AND
91849: IFFALSE 91873
// CutTreeXYR ( unit , x , y , 12 ) ;
91851: LD_VAR 0 2
91855: PPUSH
91856: LD_VAR 0 4
91860: PPUSH
91861: LD_VAR 0 5
91865: PPUSH
91866: LD_INT 12
91868: PPUSH
91869: CALL 91876 0 4
// end ;
91873: PPOPN 5
91875: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
91876: LD_INT 0
91878: PPUSH
91879: PPUSH
91880: PPUSH
91881: PPUSH
91882: PPUSH
91883: PPUSH
91884: PPUSH
91885: PPUSH
91886: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
91887: LD_VAR 0 1
91891: NOT
91892: PUSH
91893: LD_VAR 0 2
91897: PPUSH
91898: LD_VAR 0 3
91902: PPUSH
91903: CALL_OW 488
91907: NOT
91908: OR
91909: PUSH
91910: LD_VAR 0 4
91914: NOT
91915: OR
91916: IFFALSE 91920
// exit ;
91918: GO 92260
// list := [ ] ;
91920: LD_ADDR_VAR 0 13
91924: PUSH
91925: EMPTY
91926: ST_TO_ADDR
// if x - r < 0 then
91927: LD_VAR 0 2
91931: PUSH
91932: LD_VAR 0 4
91936: MINUS
91937: PUSH
91938: LD_INT 0
91940: LESS
91941: IFFALSE 91953
// min_x := 0 else
91943: LD_ADDR_VAR 0 7
91947: PUSH
91948: LD_INT 0
91950: ST_TO_ADDR
91951: GO 91969
// min_x := x - r ;
91953: LD_ADDR_VAR 0 7
91957: PUSH
91958: LD_VAR 0 2
91962: PUSH
91963: LD_VAR 0 4
91967: MINUS
91968: ST_TO_ADDR
// if y - r < 0 then
91969: LD_VAR 0 3
91973: PUSH
91974: LD_VAR 0 4
91978: MINUS
91979: PUSH
91980: LD_INT 0
91982: LESS
91983: IFFALSE 91995
// min_y := 0 else
91985: LD_ADDR_VAR 0 8
91989: PUSH
91990: LD_INT 0
91992: ST_TO_ADDR
91993: GO 92011
// min_y := y - r ;
91995: LD_ADDR_VAR 0 8
91999: PUSH
92000: LD_VAR 0 3
92004: PUSH
92005: LD_VAR 0 4
92009: MINUS
92010: ST_TO_ADDR
// max_x := x + r ;
92011: LD_ADDR_VAR 0 9
92015: PUSH
92016: LD_VAR 0 2
92020: PUSH
92021: LD_VAR 0 4
92025: PLUS
92026: ST_TO_ADDR
// max_y := y + r ;
92027: LD_ADDR_VAR 0 10
92031: PUSH
92032: LD_VAR 0 3
92036: PUSH
92037: LD_VAR 0 4
92041: PLUS
92042: ST_TO_ADDR
// for _x = min_x to max_x do
92043: LD_ADDR_VAR 0 11
92047: PUSH
92048: DOUBLE
92049: LD_VAR 0 7
92053: DEC
92054: ST_TO_ADDR
92055: LD_VAR 0 9
92059: PUSH
92060: FOR_TO
92061: IFFALSE 92178
// for _y = min_y to max_y do
92063: LD_ADDR_VAR 0 12
92067: PUSH
92068: DOUBLE
92069: LD_VAR 0 8
92073: DEC
92074: ST_TO_ADDR
92075: LD_VAR 0 10
92079: PUSH
92080: FOR_TO
92081: IFFALSE 92174
// begin if not ValidHex ( _x , _y ) then
92083: LD_VAR 0 11
92087: PPUSH
92088: LD_VAR 0 12
92092: PPUSH
92093: CALL_OW 488
92097: NOT
92098: IFFALSE 92102
// continue ;
92100: GO 92080
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
92102: LD_VAR 0 11
92106: PPUSH
92107: LD_VAR 0 12
92111: PPUSH
92112: CALL_OW 351
92116: PUSH
92117: LD_VAR 0 11
92121: PPUSH
92122: LD_VAR 0 12
92126: PPUSH
92127: CALL_OW 554
92131: AND
92132: IFFALSE 92172
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
92134: LD_ADDR_VAR 0 13
92138: PUSH
92139: LD_VAR 0 13
92143: PPUSH
92144: LD_VAR 0 13
92148: PUSH
92149: LD_INT 1
92151: PLUS
92152: PPUSH
92153: LD_VAR 0 11
92157: PUSH
92158: LD_VAR 0 12
92162: PUSH
92163: EMPTY
92164: LIST
92165: LIST
92166: PPUSH
92167: CALL_OW 2
92171: ST_TO_ADDR
// end ;
92172: GO 92080
92174: POP
92175: POP
92176: GO 92060
92178: POP
92179: POP
// if not list then
92180: LD_VAR 0 13
92184: NOT
92185: IFFALSE 92189
// exit ;
92187: GO 92260
// for i in list do
92189: LD_ADDR_VAR 0 6
92193: PUSH
92194: LD_VAR 0 13
92198: PUSH
92199: FOR_IN
92200: IFFALSE 92258
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
92202: LD_VAR 0 1
92206: PPUSH
92207: LD_STRING M
92209: PUSH
92210: LD_VAR 0 6
92214: PUSH
92215: LD_INT 1
92217: ARRAY
92218: PUSH
92219: LD_VAR 0 6
92223: PUSH
92224: LD_INT 2
92226: ARRAY
92227: PUSH
92228: LD_INT 0
92230: PUSH
92231: LD_INT 0
92233: PUSH
92234: LD_INT 0
92236: PUSH
92237: LD_INT 0
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: PUSH
92249: EMPTY
92250: LIST
92251: PPUSH
92252: CALL_OW 447
92256: GO 92199
92258: POP
92259: POP
// end ; end_of_file
92260: LD_VAR 0 5
92264: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
92265: LD_INT 0
92267: PPUSH
92268: PPUSH
92269: PPUSH
92270: PPUSH
92271: PPUSH
92272: PPUSH
92273: PPUSH
92274: PPUSH
92275: PPUSH
92276: PPUSH
92277: PPUSH
92278: PPUSH
92279: PPUSH
92280: PPUSH
92281: PPUSH
92282: PPUSH
92283: PPUSH
92284: PPUSH
92285: PPUSH
92286: PPUSH
92287: PPUSH
92288: PPUSH
92289: PPUSH
92290: PPUSH
92291: PPUSH
92292: PPUSH
92293: PPUSH
92294: PPUSH
92295: PPUSH
92296: PPUSH
92297: PPUSH
92298: PPUSH
92299: PPUSH
92300: PPUSH
// if not list then
92301: LD_VAR 0 1
92305: NOT
92306: IFFALSE 92310
// exit ;
92308: GO 96969
// base := list [ 1 ] ;
92310: LD_ADDR_VAR 0 3
92314: PUSH
92315: LD_VAR 0 1
92319: PUSH
92320: LD_INT 1
92322: ARRAY
92323: ST_TO_ADDR
// group := list [ 2 ] ;
92324: LD_ADDR_VAR 0 4
92328: PUSH
92329: LD_VAR 0 1
92333: PUSH
92334: LD_INT 2
92336: ARRAY
92337: ST_TO_ADDR
// path := list [ 3 ] ;
92338: LD_ADDR_VAR 0 5
92342: PUSH
92343: LD_VAR 0 1
92347: PUSH
92348: LD_INT 3
92350: ARRAY
92351: ST_TO_ADDR
// flags := list [ 4 ] ;
92352: LD_ADDR_VAR 0 6
92356: PUSH
92357: LD_VAR 0 1
92361: PUSH
92362: LD_INT 4
92364: ARRAY
92365: ST_TO_ADDR
// mined := [ ] ;
92366: LD_ADDR_VAR 0 27
92370: PUSH
92371: EMPTY
92372: ST_TO_ADDR
// bombed := [ ] ;
92373: LD_ADDR_VAR 0 28
92377: PUSH
92378: EMPTY
92379: ST_TO_ADDR
// healers := [ ] ;
92380: LD_ADDR_VAR 0 31
92384: PUSH
92385: EMPTY
92386: ST_TO_ADDR
// to_heal := [ ] ;
92387: LD_ADDR_VAR 0 30
92391: PUSH
92392: EMPTY
92393: ST_TO_ADDR
// repairs := [ ] ;
92394: LD_ADDR_VAR 0 33
92398: PUSH
92399: EMPTY
92400: ST_TO_ADDR
// to_repair := [ ] ;
92401: LD_ADDR_VAR 0 32
92405: PUSH
92406: EMPTY
92407: ST_TO_ADDR
// if not group or not path then
92408: LD_VAR 0 4
92412: NOT
92413: PUSH
92414: LD_VAR 0 5
92418: NOT
92419: OR
92420: IFFALSE 92424
// exit ;
92422: GO 96969
// side := GetSide ( group [ 1 ] ) ;
92424: LD_ADDR_VAR 0 35
92428: PUSH
92429: LD_VAR 0 4
92433: PUSH
92434: LD_INT 1
92436: ARRAY
92437: PPUSH
92438: CALL_OW 255
92442: ST_TO_ADDR
// if flags then
92443: LD_VAR 0 6
92447: IFFALSE 92591
// begin f_ignore_area := flags [ 1 ] ;
92449: LD_ADDR_VAR 0 17
92453: PUSH
92454: LD_VAR 0 6
92458: PUSH
92459: LD_INT 1
92461: ARRAY
92462: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
92463: LD_ADDR_VAR 0 18
92467: PUSH
92468: LD_VAR 0 6
92472: PUSH
92473: LD_INT 2
92475: ARRAY
92476: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
92477: LD_ADDR_VAR 0 19
92481: PUSH
92482: LD_VAR 0 6
92486: PUSH
92487: LD_INT 3
92489: ARRAY
92490: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
92491: LD_ADDR_VAR 0 20
92495: PUSH
92496: LD_VAR 0 6
92500: PUSH
92501: LD_INT 4
92503: ARRAY
92504: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
92505: LD_ADDR_VAR 0 21
92509: PUSH
92510: LD_VAR 0 6
92514: PUSH
92515: LD_INT 5
92517: ARRAY
92518: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
92519: LD_ADDR_VAR 0 22
92523: PUSH
92524: LD_VAR 0 6
92528: PUSH
92529: LD_INT 6
92531: ARRAY
92532: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
92533: LD_ADDR_VAR 0 23
92537: PUSH
92538: LD_VAR 0 6
92542: PUSH
92543: LD_INT 7
92545: ARRAY
92546: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
92547: LD_ADDR_VAR 0 24
92551: PUSH
92552: LD_VAR 0 6
92556: PUSH
92557: LD_INT 8
92559: ARRAY
92560: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
92561: LD_ADDR_VAR 0 25
92565: PUSH
92566: LD_VAR 0 6
92570: PUSH
92571: LD_INT 9
92573: ARRAY
92574: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
92575: LD_ADDR_VAR 0 26
92579: PUSH
92580: LD_VAR 0 6
92584: PUSH
92585: LD_INT 10
92587: ARRAY
92588: ST_TO_ADDR
// end else
92589: GO 92671
// begin f_ignore_area := false ;
92591: LD_ADDR_VAR 0 17
92595: PUSH
92596: LD_INT 0
92598: ST_TO_ADDR
// f_capture := false ;
92599: LD_ADDR_VAR 0 18
92603: PUSH
92604: LD_INT 0
92606: ST_TO_ADDR
// f_ignore_civ := false ;
92607: LD_ADDR_VAR 0 19
92611: PUSH
92612: LD_INT 0
92614: ST_TO_ADDR
// f_murder := false ;
92615: LD_ADDR_VAR 0 20
92619: PUSH
92620: LD_INT 0
92622: ST_TO_ADDR
// f_mines := false ;
92623: LD_ADDR_VAR 0 21
92627: PUSH
92628: LD_INT 0
92630: ST_TO_ADDR
// f_repair := false ;
92631: LD_ADDR_VAR 0 22
92635: PUSH
92636: LD_INT 0
92638: ST_TO_ADDR
// f_heal := false ;
92639: LD_ADDR_VAR 0 23
92643: PUSH
92644: LD_INT 0
92646: ST_TO_ADDR
// f_spacetime := false ;
92647: LD_ADDR_VAR 0 24
92651: PUSH
92652: LD_INT 0
92654: ST_TO_ADDR
// f_attack_depot := false ;
92655: LD_ADDR_VAR 0 25
92659: PUSH
92660: LD_INT 0
92662: ST_TO_ADDR
// f_crawl := false ;
92663: LD_ADDR_VAR 0 26
92667: PUSH
92668: LD_INT 0
92670: ST_TO_ADDR
// end ; if f_heal then
92671: LD_VAR 0 23
92675: IFFALSE 92702
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
92677: LD_ADDR_VAR 0 31
92681: PUSH
92682: LD_VAR 0 4
92686: PPUSH
92687: LD_INT 25
92689: PUSH
92690: LD_INT 4
92692: PUSH
92693: EMPTY
92694: LIST
92695: LIST
92696: PPUSH
92697: CALL_OW 72
92701: ST_TO_ADDR
// if f_repair then
92702: LD_VAR 0 22
92706: IFFALSE 92733
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
92708: LD_ADDR_VAR 0 33
92712: PUSH
92713: LD_VAR 0 4
92717: PPUSH
92718: LD_INT 25
92720: PUSH
92721: LD_INT 3
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: PPUSH
92728: CALL_OW 72
92732: ST_TO_ADDR
// units_path := [ ] ;
92733: LD_ADDR_VAR 0 16
92737: PUSH
92738: EMPTY
92739: ST_TO_ADDR
// for i = 1 to group do
92740: LD_ADDR_VAR 0 7
92744: PUSH
92745: DOUBLE
92746: LD_INT 1
92748: DEC
92749: ST_TO_ADDR
92750: LD_VAR 0 4
92754: PUSH
92755: FOR_TO
92756: IFFALSE 92785
// units_path := Replace ( units_path , i , path ) ;
92758: LD_ADDR_VAR 0 16
92762: PUSH
92763: LD_VAR 0 16
92767: PPUSH
92768: LD_VAR 0 7
92772: PPUSH
92773: LD_VAR 0 5
92777: PPUSH
92778: CALL_OW 1
92782: ST_TO_ADDR
92783: GO 92755
92785: POP
92786: POP
// repeat for i = group downto 1 do
92787: LD_ADDR_VAR 0 7
92791: PUSH
92792: DOUBLE
92793: LD_VAR 0 4
92797: INC
92798: ST_TO_ADDR
92799: LD_INT 1
92801: PUSH
92802: FOR_DOWNTO
92803: IFFALSE 96925
// begin wait ( 5 ) ;
92805: LD_INT 5
92807: PPUSH
92808: CALL_OW 67
// tmp := [ ] ;
92812: LD_ADDR_VAR 0 14
92816: PUSH
92817: EMPTY
92818: ST_TO_ADDR
// attacking := false ;
92819: LD_ADDR_VAR 0 29
92823: PUSH
92824: LD_INT 0
92826: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
92827: LD_VAR 0 4
92831: PUSH
92832: LD_VAR 0 7
92836: ARRAY
92837: PPUSH
92838: CALL_OW 301
92842: PUSH
92843: LD_VAR 0 4
92847: PUSH
92848: LD_VAR 0 7
92852: ARRAY
92853: NOT
92854: OR
92855: IFFALSE 92964
// begin if GetType ( group [ i ] ) = unit_human then
92857: LD_VAR 0 4
92861: PUSH
92862: LD_VAR 0 7
92866: ARRAY
92867: PPUSH
92868: CALL_OW 247
92872: PUSH
92873: LD_INT 1
92875: EQUAL
92876: IFFALSE 92922
// begin to_heal := to_heal diff group [ i ] ;
92878: LD_ADDR_VAR 0 30
92882: PUSH
92883: LD_VAR 0 30
92887: PUSH
92888: LD_VAR 0 4
92892: PUSH
92893: LD_VAR 0 7
92897: ARRAY
92898: DIFF
92899: ST_TO_ADDR
// healers := healers diff group [ i ] ;
92900: LD_ADDR_VAR 0 31
92904: PUSH
92905: LD_VAR 0 31
92909: PUSH
92910: LD_VAR 0 4
92914: PUSH
92915: LD_VAR 0 7
92919: ARRAY
92920: DIFF
92921: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
92922: LD_ADDR_VAR 0 4
92926: PUSH
92927: LD_VAR 0 4
92931: PPUSH
92932: LD_VAR 0 7
92936: PPUSH
92937: CALL_OW 3
92941: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
92942: LD_ADDR_VAR 0 16
92946: PUSH
92947: LD_VAR 0 16
92951: PPUSH
92952: LD_VAR 0 7
92956: PPUSH
92957: CALL_OW 3
92961: ST_TO_ADDR
// continue ;
92962: GO 92802
// end ; if f_repair then
92964: LD_VAR 0 22
92968: IFFALSE 93457
// begin if GetType ( group [ i ] ) = unit_vehicle then
92970: LD_VAR 0 4
92974: PUSH
92975: LD_VAR 0 7
92979: ARRAY
92980: PPUSH
92981: CALL_OW 247
92985: PUSH
92986: LD_INT 2
92988: EQUAL
92989: IFFALSE 93179
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
92991: LD_VAR 0 4
92995: PUSH
92996: LD_VAR 0 7
93000: ARRAY
93001: PPUSH
93002: CALL_OW 256
93006: PUSH
93007: LD_INT 700
93009: LESS
93010: PUSH
93011: LD_VAR 0 4
93015: PUSH
93016: LD_VAR 0 7
93020: ARRAY
93021: PUSH
93022: LD_VAR 0 32
93026: IN
93027: NOT
93028: AND
93029: IFFALSE 93053
// to_repair := to_repair union group [ i ] ;
93031: LD_ADDR_VAR 0 32
93035: PUSH
93036: LD_VAR 0 32
93040: PUSH
93041: LD_VAR 0 4
93045: PUSH
93046: LD_VAR 0 7
93050: ARRAY
93051: UNION
93052: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
93053: LD_VAR 0 4
93057: PUSH
93058: LD_VAR 0 7
93062: ARRAY
93063: PPUSH
93064: CALL_OW 256
93068: PUSH
93069: LD_INT 1000
93071: EQUAL
93072: PUSH
93073: LD_VAR 0 4
93077: PUSH
93078: LD_VAR 0 7
93082: ARRAY
93083: PUSH
93084: LD_VAR 0 32
93088: IN
93089: AND
93090: IFFALSE 93114
// to_repair := to_repair diff group [ i ] ;
93092: LD_ADDR_VAR 0 32
93096: PUSH
93097: LD_VAR 0 32
93101: PUSH
93102: LD_VAR 0 4
93106: PUSH
93107: LD_VAR 0 7
93111: ARRAY
93112: DIFF
93113: ST_TO_ADDR
// if group [ i ] in to_repair then
93114: LD_VAR 0 4
93118: PUSH
93119: LD_VAR 0 7
93123: ARRAY
93124: PUSH
93125: LD_VAR 0 32
93129: IN
93130: IFFALSE 93177
// begin if not IsInArea ( group [ i ] , f_repair ) then
93132: LD_VAR 0 4
93136: PUSH
93137: LD_VAR 0 7
93141: ARRAY
93142: PPUSH
93143: LD_VAR 0 22
93147: PPUSH
93148: CALL_OW 308
93152: NOT
93153: IFFALSE 93175
// ComMoveToArea ( group [ i ] , f_repair ) ;
93155: LD_VAR 0 4
93159: PUSH
93160: LD_VAR 0 7
93164: ARRAY
93165: PPUSH
93166: LD_VAR 0 22
93170: PPUSH
93171: CALL_OW 113
// continue ;
93175: GO 92802
// end ; end else
93177: GO 93457
// if group [ i ] in repairs then
93179: LD_VAR 0 4
93183: PUSH
93184: LD_VAR 0 7
93188: ARRAY
93189: PUSH
93190: LD_VAR 0 33
93194: IN
93195: IFFALSE 93457
// begin if IsInUnit ( group [ i ] ) then
93197: LD_VAR 0 4
93201: PUSH
93202: LD_VAR 0 7
93206: ARRAY
93207: PPUSH
93208: CALL_OW 310
93212: IFFALSE 93280
// begin z := IsInUnit ( group [ i ] ) ;
93214: LD_ADDR_VAR 0 13
93218: PUSH
93219: LD_VAR 0 4
93223: PUSH
93224: LD_VAR 0 7
93228: ARRAY
93229: PPUSH
93230: CALL_OW 310
93234: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
93235: LD_VAR 0 13
93239: PUSH
93240: LD_VAR 0 32
93244: IN
93245: PUSH
93246: LD_VAR 0 13
93250: PPUSH
93251: LD_VAR 0 22
93255: PPUSH
93256: CALL_OW 308
93260: AND
93261: IFFALSE 93278
// ComExitVehicle ( group [ i ] ) ;
93263: LD_VAR 0 4
93267: PUSH
93268: LD_VAR 0 7
93272: ARRAY
93273: PPUSH
93274: CALL_OW 121
// end else
93278: GO 93457
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
93280: LD_ADDR_VAR 0 13
93284: PUSH
93285: LD_VAR 0 4
93289: PPUSH
93290: LD_INT 95
93292: PUSH
93293: LD_VAR 0 22
93297: PUSH
93298: EMPTY
93299: LIST
93300: LIST
93301: PUSH
93302: LD_INT 58
93304: PUSH
93305: EMPTY
93306: LIST
93307: PUSH
93308: EMPTY
93309: LIST
93310: LIST
93311: PPUSH
93312: CALL_OW 72
93316: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
93317: LD_VAR 0 4
93321: PUSH
93322: LD_VAR 0 7
93326: ARRAY
93327: PPUSH
93328: CALL_OW 314
93332: NOT
93333: IFFALSE 93455
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
93335: LD_ADDR_VAR 0 10
93339: PUSH
93340: LD_VAR 0 13
93344: PPUSH
93345: LD_VAR 0 4
93349: PUSH
93350: LD_VAR 0 7
93354: ARRAY
93355: PPUSH
93356: CALL_OW 74
93360: ST_TO_ADDR
// if not x then
93361: LD_VAR 0 10
93365: NOT
93366: IFFALSE 93370
// continue ;
93368: GO 92802
// if GetLives ( x ) < 1000 then
93370: LD_VAR 0 10
93374: PPUSH
93375: CALL_OW 256
93379: PUSH
93380: LD_INT 1000
93382: LESS
93383: IFFALSE 93407
// ComRepairVehicle ( group [ i ] , x ) else
93385: LD_VAR 0 4
93389: PUSH
93390: LD_VAR 0 7
93394: ARRAY
93395: PPUSH
93396: LD_VAR 0 10
93400: PPUSH
93401: CALL_OW 129
93405: GO 93455
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
93407: LD_VAR 0 23
93411: PUSH
93412: LD_VAR 0 4
93416: PUSH
93417: LD_VAR 0 7
93421: ARRAY
93422: PPUSH
93423: CALL_OW 256
93427: PUSH
93428: LD_INT 1000
93430: LESS
93431: AND
93432: NOT
93433: IFFALSE 93455
// ComEnterUnit ( group [ i ] , x ) ;
93435: LD_VAR 0 4
93439: PUSH
93440: LD_VAR 0 7
93444: ARRAY
93445: PPUSH
93446: LD_VAR 0 10
93450: PPUSH
93451: CALL_OW 120
// end ; continue ;
93455: GO 92802
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
93457: LD_VAR 0 23
93461: PUSH
93462: LD_VAR 0 4
93466: PUSH
93467: LD_VAR 0 7
93471: ARRAY
93472: PPUSH
93473: CALL_OW 247
93477: PUSH
93478: LD_INT 1
93480: EQUAL
93481: AND
93482: IFFALSE 93960
// begin if group [ i ] in healers then
93484: LD_VAR 0 4
93488: PUSH
93489: LD_VAR 0 7
93493: ARRAY
93494: PUSH
93495: LD_VAR 0 31
93499: IN
93500: IFFALSE 93773
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
93502: LD_VAR 0 4
93506: PUSH
93507: LD_VAR 0 7
93511: ARRAY
93512: PPUSH
93513: LD_VAR 0 23
93517: PPUSH
93518: CALL_OW 308
93522: NOT
93523: PUSH
93524: LD_VAR 0 4
93528: PUSH
93529: LD_VAR 0 7
93533: ARRAY
93534: PPUSH
93535: CALL_OW 314
93539: NOT
93540: AND
93541: IFFALSE 93565
// ComMoveToArea ( group [ i ] , f_heal ) else
93543: LD_VAR 0 4
93547: PUSH
93548: LD_VAR 0 7
93552: ARRAY
93553: PPUSH
93554: LD_VAR 0 23
93558: PPUSH
93559: CALL_OW 113
93563: GO 93771
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
93565: LD_VAR 0 4
93569: PUSH
93570: LD_VAR 0 7
93574: ARRAY
93575: PPUSH
93576: CALL 47610 0 1
93580: PPUSH
93581: CALL_OW 256
93585: PUSH
93586: LD_INT 1000
93588: EQUAL
93589: IFFALSE 93608
// ComStop ( group [ i ] ) else
93591: LD_VAR 0 4
93595: PUSH
93596: LD_VAR 0 7
93600: ARRAY
93601: PPUSH
93602: CALL_OW 141
93606: GO 93771
// if not HasTask ( group [ i ] ) and to_heal then
93608: LD_VAR 0 4
93612: PUSH
93613: LD_VAR 0 7
93617: ARRAY
93618: PPUSH
93619: CALL_OW 314
93623: NOT
93624: PUSH
93625: LD_VAR 0 30
93629: AND
93630: IFFALSE 93771
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
93632: LD_ADDR_VAR 0 13
93636: PUSH
93637: LD_VAR 0 30
93641: PPUSH
93642: LD_INT 3
93644: PUSH
93645: LD_INT 54
93647: PUSH
93648: EMPTY
93649: LIST
93650: PUSH
93651: EMPTY
93652: LIST
93653: LIST
93654: PPUSH
93655: CALL_OW 72
93659: PPUSH
93660: LD_VAR 0 4
93664: PUSH
93665: LD_VAR 0 7
93669: ARRAY
93670: PPUSH
93671: CALL_OW 74
93675: ST_TO_ADDR
// if z then
93676: LD_VAR 0 13
93680: IFFALSE 93771
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
93682: LD_INT 91
93684: PUSH
93685: LD_VAR 0 13
93689: PUSH
93690: LD_INT 10
93692: PUSH
93693: EMPTY
93694: LIST
93695: LIST
93696: LIST
93697: PUSH
93698: LD_INT 81
93700: PUSH
93701: LD_VAR 0 13
93705: PPUSH
93706: CALL_OW 255
93710: PUSH
93711: EMPTY
93712: LIST
93713: LIST
93714: PUSH
93715: EMPTY
93716: LIST
93717: LIST
93718: PPUSH
93719: CALL_OW 69
93723: PUSH
93724: LD_INT 0
93726: EQUAL
93727: IFFALSE 93751
// ComHeal ( group [ i ] , z ) else
93729: LD_VAR 0 4
93733: PUSH
93734: LD_VAR 0 7
93738: ARRAY
93739: PPUSH
93740: LD_VAR 0 13
93744: PPUSH
93745: CALL_OW 128
93749: GO 93771
// ComMoveToArea ( group [ i ] , f_heal ) ;
93751: LD_VAR 0 4
93755: PUSH
93756: LD_VAR 0 7
93760: ARRAY
93761: PPUSH
93762: LD_VAR 0 23
93766: PPUSH
93767: CALL_OW 113
// end ; continue ;
93771: GO 92802
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
93773: LD_VAR 0 4
93777: PUSH
93778: LD_VAR 0 7
93782: ARRAY
93783: PPUSH
93784: CALL_OW 256
93788: PUSH
93789: LD_INT 700
93791: LESS
93792: PUSH
93793: LD_VAR 0 4
93797: PUSH
93798: LD_VAR 0 7
93802: ARRAY
93803: PUSH
93804: LD_VAR 0 30
93808: IN
93809: NOT
93810: AND
93811: IFFALSE 93835
// to_heal := to_heal union group [ i ] ;
93813: LD_ADDR_VAR 0 30
93817: PUSH
93818: LD_VAR 0 30
93822: PUSH
93823: LD_VAR 0 4
93827: PUSH
93828: LD_VAR 0 7
93832: ARRAY
93833: UNION
93834: ST_TO_ADDR
// if group [ i ] in to_heal then
93835: LD_VAR 0 4
93839: PUSH
93840: LD_VAR 0 7
93844: ARRAY
93845: PUSH
93846: LD_VAR 0 30
93850: IN
93851: IFFALSE 93960
// begin if GetLives ( group [ i ] ) = 1000 then
93853: LD_VAR 0 4
93857: PUSH
93858: LD_VAR 0 7
93862: ARRAY
93863: PPUSH
93864: CALL_OW 256
93868: PUSH
93869: LD_INT 1000
93871: EQUAL
93872: IFFALSE 93898
// to_heal := to_heal diff group [ i ] else
93874: LD_ADDR_VAR 0 30
93878: PUSH
93879: LD_VAR 0 30
93883: PUSH
93884: LD_VAR 0 4
93888: PUSH
93889: LD_VAR 0 7
93893: ARRAY
93894: DIFF
93895: ST_TO_ADDR
93896: GO 93960
// begin if not IsInArea ( group [ i ] , to_heal ) then
93898: LD_VAR 0 4
93902: PUSH
93903: LD_VAR 0 7
93907: ARRAY
93908: PPUSH
93909: LD_VAR 0 30
93913: PPUSH
93914: CALL_OW 308
93918: NOT
93919: IFFALSE 93943
// ComMoveToArea ( group [ i ] , f_heal ) else
93921: LD_VAR 0 4
93925: PUSH
93926: LD_VAR 0 7
93930: ARRAY
93931: PPUSH
93932: LD_VAR 0 23
93936: PPUSH
93937: CALL_OW 113
93941: GO 93958
// ComHold ( group [ i ] ) ;
93943: LD_VAR 0 4
93947: PUSH
93948: LD_VAR 0 7
93952: ARRAY
93953: PPUSH
93954: CALL_OW 140
// continue ;
93958: GO 92802
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
93960: LD_VAR 0 4
93964: PUSH
93965: LD_VAR 0 7
93969: ARRAY
93970: PPUSH
93971: LD_INT 10
93973: PPUSH
93974: CALL 46030 0 2
93978: NOT
93979: PUSH
93980: LD_VAR 0 16
93984: PUSH
93985: LD_VAR 0 7
93989: ARRAY
93990: PUSH
93991: EMPTY
93992: EQUAL
93993: NOT
93994: AND
93995: IFFALSE 94261
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
93997: LD_VAR 0 4
94001: PUSH
94002: LD_VAR 0 7
94006: ARRAY
94007: PPUSH
94008: CALL_OW 262
94012: PUSH
94013: LD_INT 1
94015: PUSH
94016: LD_INT 2
94018: PUSH
94019: EMPTY
94020: LIST
94021: LIST
94022: IN
94023: IFFALSE 94064
// if GetFuel ( group [ i ] ) < 10 then
94025: LD_VAR 0 4
94029: PUSH
94030: LD_VAR 0 7
94034: ARRAY
94035: PPUSH
94036: CALL_OW 261
94040: PUSH
94041: LD_INT 10
94043: LESS
94044: IFFALSE 94064
// SetFuel ( group [ i ] , 12 ) ;
94046: LD_VAR 0 4
94050: PUSH
94051: LD_VAR 0 7
94055: ARRAY
94056: PPUSH
94057: LD_INT 12
94059: PPUSH
94060: CALL_OW 240
// if units_path [ i ] then
94064: LD_VAR 0 16
94068: PUSH
94069: LD_VAR 0 7
94073: ARRAY
94074: IFFALSE 94259
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
94076: LD_VAR 0 4
94080: PUSH
94081: LD_VAR 0 7
94085: ARRAY
94086: PPUSH
94087: LD_VAR 0 16
94091: PUSH
94092: LD_VAR 0 7
94096: ARRAY
94097: PUSH
94098: LD_INT 1
94100: ARRAY
94101: PUSH
94102: LD_INT 1
94104: ARRAY
94105: PPUSH
94106: LD_VAR 0 16
94110: PUSH
94111: LD_VAR 0 7
94115: ARRAY
94116: PUSH
94117: LD_INT 1
94119: ARRAY
94120: PUSH
94121: LD_INT 2
94123: ARRAY
94124: PPUSH
94125: CALL_OW 297
94129: PUSH
94130: LD_INT 6
94132: GREATER
94133: IFFALSE 94208
// begin if not HasTask ( group [ i ] ) then
94135: LD_VAR 0 4
94139: PUSH
94140: LD_VAR 0 7
94144: ARRAY
94145: PPUSH
94146: CALL_OW 314
94150: NOT
94151: IFFALSE 94206
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
94153: LD_VAR 0 4
94157: PUSH
94158: LD_VAR 0 7
94162: ARRAY
94163: PPUSH
94164: LD_VAR 0 16
94168: PUSH
94169: LD_VAR 0 7
94173: ARRAY
94174: PUSH
94175: LD_INT 1
94177: ARRAY
94178: PUSH
94179: LD_INT 1
94181: ARRAY
94182: PPUSH
94183: LD_VAR 0 16
94187: PUSH
94188: LD_VAR 0 7
94192: ARRAY
94193: PUSH
94194: LD_INT 1
94196: ARRAY
94197: PUSH
94198: LD_INT 2
94200: ARRAY
94201: PPUSH
94202: CALL_OW 114
// end else
94206: GO 94259
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
94208: LD_ADDR_VAR 0 15
94212: PUSH
94213: LD_VAR 0 16
94217: PUSH
94218: LD_VAR 0 7
94222: ARRAY
94223: PPUSH
94224: LD_INT 1
94226: PPUSH
94227: CALL_OW 3
94231: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
94232: LD_ADDR_VAR 0 16
94236: PUSH
94237: LD_VAR 0 16
94241: PPUSH
94242: LD_VAR 0 7
94246: PPUSH
94247: LD_VAR 0 15
94251: PPUSH
94252: CALL_OW 1
94256: ST_TO_ADDR
// continue ;
94257: GO 92802
// end ; end ; end else
94259: GO 96923
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
94261: LD_ADDR_VAR 0 14
94265: PUSH
94266: LD_INT 81
94268: PUSH
94269: LD_VAR 0 4
94273: PUSH
94274: LD_VAR 0 7
94278: ARRAY
94279: PPUSH
94280: CALL_OW 255
94284: PUSH
94285: EMPTY
94286: LIST
94287: LIST
94288: PPUSH
94289: CALL_OW 69
94293: ST_TO_ADDR
// if not tmp then
94294: LD_VAR 0 14
94298: NOT
94299: IFFALSE 94303
// continue ;
94301: GO 92802
// if f_ignore_area then
94303: LD_VAR 0 17
94307: IFFALSE 94395
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
94309: LD_ADDR_VAR 0 15
94313: PUSH
94314: LD_VAR 0 14
94318: PPUSH
94319: LD_INT 3
94321: PUSH
94322: LD_INT 92
94324: PUSH
94325: LD_VAR 0 17
94329: PUSH
94330: LD_INT 1
94332: ARRAY
94333: PUSH
94334: LD_VAR 0 17
94338: PUSH
94339: LD_INT 2
94341: ARRAY
94342: PUSH
94343: LD_VAR 0 17
94347: PUSH
94348: LD_INT 3
94350: ARRAY
94351: PUSH
94352: EMPTY
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: PUSH
94358: EMPTY
94359: LIST
94360: LIST
94361: PPUSH
94362: CALL_OW 72
94366: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
94367: LD_VAR 0 14
94371: PUSH
94372: LD_VAR 0 15
94376: DIFF
94377: IFFALSE 94395
// tmp := tmp diff tmp2 ;
94379: LD_ADDR_VAR 0 14
94383: PUSH
94384: LD_VAR 0 14
94388: PUSH
94389: LD_VAR 0 15
94393: DIFF
94394: ST_TO_ADDR
// end ; if not f_murder then
94395: LD_VAR 0 20
94399: NOT
94400: IFFALSE 94458
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
94402: LD_ADDR_VAR 0 15
94406: PUSH
94407: LD_VAR 0 14
94411: PPUSH
94412: LD_INT 3
94414: PUSH
94415: LD_INT 50
94417: PUSH
94418: EMPTY
94419: LIST
94420: PUSH
94421: EMPTY
94422: LIST
94423: LIST
94424: PPUSH
94425: CALL_OW 72
94429: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
94430: LD_VAR 0 14
94434: PUSH
94435: LD_VAR 0 15
94439: DIFF
94440: IFFALSE 94458
// tmp := tmp diff tmp2 ;
94442: LD_ADDR_VAR 0 14
94446: PUSH
94447: LD_VAR 0 14
94451: PUSH
94452: LD_VAR 0 15
94456: DIFF
94457: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
94458: LD_ADDR_VAR 0 14
94462: PUSH
94463: LD_VAR 0 4
94467: PUSH
94468: LD_VAR 0 7
94472: ARRAY
94473: PPUSH
94474: LD_VAR 0 14
94478: PPUSH
94479: LD_INT 1
94481: PPUSH
94482: LD_INT 1
94484: PPUSH
94485: CALL 19673 0 4
94489: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
94490: LD_VAR 0 4
94494: PUSH
94495: LD_VAR 0 7
94499: ARRAY
94500: PPUSH
94501: CALL_OW 257
94505: PUSH
94506: LD_INT 1
94508: EQUAL
94509: IFFALSE 94957
// begin if WantPlant ( group [ i ] ) then
94511: LD_VAR 0 4
94515: PUSH
94516: LD_VAR 0 7
94520: ARRAY
94521: PPUSH
94522: CALL 19174 0 1
94526: IFFALSE 94530
// continue ;
94528: GO 92802
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
94530: LD_VAR 0 18
94534: PUSH
94535: LD_VAR 0 4
94539: PUSH
94540: LD_VAR 0 7
94544: ARRAY
94545: PPUSH
94546: CALL_OW 310
94550: NOT
94551: AND
94552: PUSH
94553: LD_VAR 0 14
94557: PUSH
94558: LD_INT 1
94560: ARRAY
94561: PUSH
94562: LD_VAR 0 14
94566: PPUSH
94567: LD_INT 21
94569: PUSH
94570: LD_INT 2
94572: PUSH
94573: EMPTY
94574: LIST
94575: LIST
94576: PUSH
94577: LD_INT 58
94579: PUSH
94580: EMPTY
94581: LIST
94582: PUSH
94583: EMPTY
94584: LIST
94585: LIST
94586: PPUSH
94587: CALL_OW 72
94591: IN
94592: AND
94593: IFFALSE 94629
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
94595: LD_VAR 0 4
94599: PUSH
94600: LD_VAR 0 7
94604: ARRAY
94605: PPUSH
94606: LD_VAR 0 14
94610: PUSH
94611: LD_INT 1
94613: ARRAY
94614: PPUSH
94615: CALL_OW 120
// attacking := true ;
94619: LD_ADDR_VAR 0 29
94623: PUSH
94624: LD_INT 1
94626: ST_TO_ADDR
// continue ;
94627: GO 92802
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
94629: LD_VAR 0 26
94633: PUSH
94634: LD_VAR 0 4
94638: PUSH
94639: LD_VAR 0 7
94643: ARRAY
94644: PPUSH
94645: CALL_OW 257
94649: PUSH
94650: LD_INT 1
94652: EQUAL
94653: AND
94654: PUSH
94655: LD_VAR 0 4
94659: PUSH
94660: LD_VAR 0 7
94664: ARRAY
94665: PPUSH
94666: CALL_OW 256
94670: PUSH
94671: LD_INT 800
94673: LESS
94674: AND
94675: PUSH
94676: LD_VAR 0 4
94680: PUSH
94681: LD_VAR 0 7
94685: ARRAY
94686: PPUSH
94687: CALL_OW 318
94691: NOT
94692: AND
94693: IFFALSE 94710
// ComCrawl ( group [ i ] ) ;
94695: LD_VAR 0 4
94699: PUSH
94700: LD_VAR 0 7
94704: ARRAY
94705: PPUSH
94706: CALL_OW 137
// if f_mines then
94710: LD_VAR 0 21
94714: IFFALSE 94957
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
94716: LD_VAR 0 14
94720: PUSH
94721: LD_INT 1
94723: ARRAY
94724: PPUSH
94725: CALL_OW 247
94729: PUSH
94730: LD_INT 3
94732: EQUAL
94733: PUSH
94734: LD_VAR 0 14
94738: PUSH
94739: LD_INT 1
94741: ARRAY
94742: PUSH
94743: LD_VAR 0 27
94747: IN
94748: NOT
94749: AND
94750: IFFALSE 94957
// begin x := GetX ( tmp [ 1 ] ) ;
94752: LD_ADDR_VAR 0 10
94756: PUSH
94757: LD_VAR 0 14
94761: PUSH
94762: LD_INT 1
94764: ARRAY
94765: PPUSH
94766: CALL_OW 250
94770: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
94771: LD_ADDR_VAR 0 11
94775: PUSH
94776: LD_VAR 0 14
94780: PUSH
94781: LD_INT 1
94783: ARRAY
94784: PPUSH
94785: CALL_OW 251
94789: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
94790: LD_ADDR_VAR 0 12
94794: PUSH
94795: LD_VAR 0 4
94799: PUSH
94800: LD_VAR 0 7
94804: ARRAY
94805: PPUSH
94806: CALL 46115 0 1
94810: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
94811: LD_VAR 0 4
94815: PUSH
94816: LD_VAR 0 7
94820: ARRAY
94821: PPUSH
94822: LD_VAR 0 10
94826: PPUSH
94827: LD_VAR 0 11
94831: PPUSH
94832: LD_VAR 0 14
94836: PUSH
94837: LD_INT 1
94839: ARRAY
94840: PPUSH
94841: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
94845: LD_VAR 0 4
94849: PUSH
94850: LD_VAR 0 7
94854: ARRAY
94855: PPUSH
94856: LD_VAR 0 10
94860: PPUSH
94861: LD_VAR 0 12
94865: PPUSH
94866: LD_INT 7
94868: PPUSH
94869: CALL_OW 272
94873: PPUSH
94874: LD_VAR 0 11
94878: PPUSH
94879: LD_VAR 0 12
94883: PPUSH
94884: LD_INT 7
94886: PPUSH
94887: CALL_OW 273
94891: PPUSH
94892: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
94896: LD_VAR 0 4
94900: PUSH
94901: LD_VAR 0 7
94905: ARRAY
94906: PPUSH
94907: LD_INT 71
94909: PPUSH
94910: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
94914: LD_ADDR_VAR 0 27
94918: PUSH
94919: LD_VAR 0 27
94923: PPUSH
94924: LD_VAR 0 27
94928: PUSH
94929: LD_INT 1
94931: PLUS
94932: PPUSH
94933: LD_VAR 0 14
94937: PUSH
94938: LD_INT 1
94940: ARRAY
94941: PPUSH
94942: CALL_OW 1
94946: ST_TO_ADDR
// attacking := true ;
94947: LD_ADDR_VAR 0 29
94951: PUSH
94952: LD_INT 1
94954: ST_TO_ADDR
// continue ;
94955: GO 92802
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
94957: LD_VAR 0 4
94961: PUSH
94962: LD_VAR 0 7
94966: ARRAY
94967: PPUSH
94968: CALL_OW 257
94972: PUSH
94973: LD_INT 17
94975: EQUAL
94976: PUSH
94977: LD_VAR 0 4
94981: PUSH
94982: LD_VAR 0 7
94986: ARRAY
94987: PPUSH
94988: CALL_OW 110
94992: PUSH
94993: LD_INT 71
94995: EQUAL
94996: NOT
94997: AND
94998: IFFALSE 95144
// begin attacking := false ;
95000: LD_ADDR_VAR 0 29
95004: PUSH
95005: LD_INT 0
95007: ST_TO_ADDR
// k := 5 ;
95008: LD_ADDR_VAR 0 9
95012: PUSH
95013: LD_INT 5
95015: ST_TO_ADDR
// if tmp < k then
95016: LD_VAR 0 14
95020: PUSH
95021: LD_VAR 0 9
95025: LESS
95026: IFFALSE 95038
// k := tmp ;
95028: LD_ADDR_VAR 0 9
95032: PUSH
95033: LD_VAR 0 14
95037: ST_TO_ADDR
// for j = 1 to k do
95038: LD_ADDR_VAR 0 8
95042: PUSH
95043: DOUBLE
95044: LD_INT 1
95046: DEC
95047: ST_TO_ADDR
95048: LD_VAR 0 9
95052: PUSH
95053: FOR_TO
95054: IFFALSE 95142
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
95056: LD_VAR 0 14
95060: PUSH
95061: LD_VAR 0 8
95065: ARRAY
95066: PUSH
95067: LD_VAR 0 14
95071: PPUSH
95072: LD_INT 58
95074: PUSH
95075: EMPTY
95076: LIST
95077: PPUSH
95078: CALL_OW 72
95082: IN
95083: NOT
95084: IFFALSE 95140
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
95086: LD_VAR 0 4
95090: PUSH
95091: LD_VAR 0 7
95095: ARRAY
95096: PPUSH
95097: LD_VAR 0 14
95101: PUSH
95102: LD_VAR 0 8
95106: ARRAY
95107: PPUSH
95108: CALL_OW 115
// attacking := true ;
95112: LD_ADDR_VAR 0 29
95116: PUSH
95117: LD_INT 1
95119: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
95120: LD_VAR 0 4
95124: PUSH
95125: LD_VAR 0 7
95129: ARRAY
95130: PPUSH
95131: LD_INT 71
95133: PPUSH
95134: CALL_OW 109
// continue ;
95138: GO 95053
// end ; end ;
95140: GO 95053
95142: POP
95143: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
95144: LD_VAR 0 4
95148: PUSH
95149: LD_VAR 0 7
95153: ARRAY
95154: PPUSH
95155: CALL_OW 257
95159: PUSH
95160: LD_INT 8
95162: EQUAL
95163: PUSH
95164: LD_VAR 0 4
95168: PUSH
95169: LD_VAR 0 7
95173: ARRAY
95174: PPUSH
95175: CALL_OW 264
95179: PUSH
95180: LD_INT 28
95182: PUSH
95183: LD_INT 45
95185: PUSH
95186: LD_INT 7
95188: PUSH
95189: LD_INT 47
95191: PUSH
95192: EMPTY
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: IN
95198: OR
95199: IFFALSE 95455
// begin attacking := false ;
95201: LD_ADDR_VAR 0 29
95205: PUSH
95206: LD_INT 0
95208: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
95209: LD_VAR 0 14
95213: PUSH
95214: LD_INT 1
95216: ARRAY
95217: PPUSH
95218: CALL_OW 266
95222: PUSH
95223: LD_INT 32
95225: PUSH
95226: LD_INT 31
95228: PUSH
95229: LD_INT 33
95231: PUSH
95232: LD_INT 4
95234: PUSH
95235: LD_INT 5
95237: PUSH
95238: EMPTY
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: IN
95245: IFFALSE 95431
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
95247: LD_ADDR_VAR 0 9
95251: PUSH
95252: LD_VAR 0 14
95256: PUSH
95257: LD_INT 1
95259: ARRAY
95260: PPUSH
95261: CALL_OW 266
95265: PPUSH
95266: LD_VAR 0 14
95270: PUSH
95271: LD_INT 1
95273: ARRAY
95274: PPUSH
95275: CALL_OW 250
95279: PPUSH
95280: LD_VAR 0 14
95284: PUSH
95285: LD_INT 1
95287: ARRAY
95288: PPUSH
95289: CALL_OW 251
95293: PPUSH
95294: LD_VAR 0 14
95298: PUSH
95299: LD_INT 1
95301: ARRAY
95302: PPUSH
95303: CALL_OW 254
95307: PPUSH
95308: LD_VAR 0 14
95312: PUSH
95313: LD_INT 1
95315: ARRAY
95316: PPUSH
95317: CALL_OW 248
95321: PPUSH
95322: LD_INT 0
95324: PPUSH
95325: CALL 27485 0 6
95329: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
95330: LD_ADDR_VAR 0 8
95334: PUSH
95335: LD_VAR 0 4
95339: PUSH
95340: LD_VAR 0 7
95344: ARRAY
95345: PPUSH
95346: LD_VAR 0 9
95350: PPUSH
95351: CALL 46155 0 2
95355: ST_TO_ADDR
// if j then
95356: LD_VAR 0 8
95360: IFFALSE 95429
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
95362: LD_VAR 0 8
95366: PUSH
95367: LD_INT 1
95369: ARRAY
95370: PPUSH
95371: LD_VAR 0 8
95375: PUSH
95376: LD_INT 2
95378: ARRAY
95379: PPUSH
95380: CALL_OW 488
95384: IFFALSE 95429
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
95386: LD_VAR 0 4
95390: PUSH
95391: LD_VAR 0 7
95395: ARRAY
95396: PPUSH
95397: LD_VAR 0 8
95401: PUSH
95402: LD_INT 1
95404: ARRAY
95405: PPUSH
95406: LD_VAR 0 8
95410: PUSH
95411: LD_INT 2
95413: ARRAY
95414: PPUSH
95415: CALL_OW 116
// attacking := true ;
95419: LD_ADDR_VAR 0 29
95423: PUSH
95424: LD_INT 1
95426: ST_TO_ADDR
// continue ;
95427: GO 92802
// end ; end else
95429: GO 95455
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
95431: LD_VAR 0 4
95435: PUSH
95436: LD_VAR 0 7
95440: ARRAY
95441: PPUSH
95442: LD_VAR 0 14
95446: PUSH
95447: LD_INT 1
95449: ARRAY
95450: PPUSH
95451: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
95455: LD_VAR 0 4
95459: PUSH
95460: LD_VAR 0 7
95464: ARRAY
95465: PPUSH
95466: CALL_OW 265
95470: PUSH
95471: LD_INT 11
95473: EQUAL
95474: IFFALSE 95752
// begin k := 10 ;
95476: LD_ADDR_VAR 0 9
95480: PUSH
95481: LD_INT 10
95483: ST_TO_ADDR
// x := 0 ;
95484: LD_ADDR_VAR 0 10
95488: PUSH
95489: LD_INT 0
95491: ST_TO_ADDR
// if tmp < k then
95492: LD_VAR 0 14
95496: PUSH
95497: LD_VAR 0 9
95501: LESS
95502: IFFALSE 95514
// k := tmp ;
95504: LD_ADDR_VAR 0 9
95508: PUSH
95509: LD_VAR 0 14
95513: ST_TO_ADDR
// for j = k downto 1 do
95514: LD_ADDR_VAR 0 8
95518: PUSH
95519: DOUBLE
95520: LD_VAR 0 9
95524: INC
95525: ST_TO_ADDR
95526: LD_INT 1
95528: PUSH
95529: FOR_DOWNTO
95530: IFFALSE 95605
// begin if GetType ( tmp [ j ] ) = unit_human then
95532: LD_VAR 0 14
95536: PUSH
95537: LD_VAR 0 8
95541: ARRAY
95542: PPUSH
95543: CALL_OW 247
95547: PUSH
95548: LD_INT 1
95550: EQUAL
95551: IFFALSE 95603
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
95553: LD_VAR 0 4
95557: PUSH
95558: LD_VAR 0 7
95562: ARRAY
95563: PPUSH
95564: LD_VAR 0 14
95568: PUSH
95569: LD_VAR 0 8
95573: ARRAY
95574: PPUSH
95575: CALL 46426 0 2
// x := tmp [ j ] ;
95579: LD_ADDR_VAR 0 10
95583: PUSH
95584: LD_VAR 0 14
95588: PUSH
95589: LD_VAR 0 8
95593: ARRAY
95594: ST_TO_ADDR
// attacking := true ;
95595: LD_ADDR_VAR 0 29
95599: PUSH
95600: LD_INT 1
95602: ST_TO_ADDR
// end ; end ;
95603: GO 95529
95605: POP
95606: POP
// if not x then
95607: LD_VAR 0 10
95611: NOT
95612: IFFALSE 95752
// begin attacking := true ;
95614: LD_ADDR_VAR 0 29
95618: PUSH
95619: LD_INT 1
95621: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
95622: LD_VAR 0 4
95626: PUSH
95627: LD_VAR 0 7
95631: ARRAY
95632: PPUSH
95633: CALL_OW 250
95637: PPUSH
95638: LD_VAR 0 4
95642: PUSH
95643: LD_VAR 0 7
95647: ARRAY
95648: PPUSH
95649: CALL_OW 251
95653: PPUSH
95654: CALL_OW 546
95658: PUSH
95659: LD_INT 2
95661: ARRAY
95662: PUSH
95663: LD_VAR 0 14
95667: PUSH
95668: LD_INT 1
95670: ARRAY
95671: PPUSH
95672: CALL_OW 250
95676: PPUSH
95677: LD_VAR 0 14
95681: PUSH
95682: LD_INT 1
95684: ARRAY
95685: PPUSH
95686: CALL_OW 251
95690: PPUSH
95691: CALL_OW 546
95695: PUSH
95696: LD_INT 2
95698: ARRAY
95699: EQUAL
95700: IFFALSE 95728
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
95702: LD_VAR 0 4
95706: PUSH
95707: LD_VAR 0 7
95711: ARRAY
95712: PPUSH
95713: LD_VAR 0 14
95717: PUSH
95718: LD_INT 1
95720: ARRAY
95721: PPUSH
95722: CALL 46426 0 2
95726: GO 95752
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
95728: LD_VAR 0 4
95732: PUSH
95733: LD_VAR 0 7
95737: ARRAY
95738: PPUSH
95739: LD_VAR 0 14
95743: PUSH
95744: LD_INT 1
95746: ARRAY
95747: PPUSH
95748: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
95752: LD_VAR 0 4
95756: PUSH
95757: LD_VAR 0 7
95761: ARRAY
95762: PPUSH
95763: CALL_OW 264
95767: PUSH
95768: LD_INT 29
95770: EQUAL
95771: IFFALSE 96137
// begin if WantsToAttack ( group [ i ] ) in bombed then
95773: LD_VAR 0 4
95777: PUSH
95778: LD_VAR 0 7
95782: ARRAY
95783: PPUSH
95784: CALL_OW 319
95788: PUSH
95789: LD_VAR 0 28
95793: IN
95794: IFFALSE 95798
// continue ;
95796: GO 92802
// k := 8 ;
95798: LD_ADDR_VAR 0 9
95802: PUSH
95803: LD_INT 8
95805: ST_TO_ADDR
// x := 0 ;
95806: LD_ADDR_VAR 0 10
95810: PUSH
95811: LD_INT 0
95813: ST_TO_ADDR
// if tmp < k then
95814: LD_VAR 0 14
95818: PUSH
95819: LD_VAR 0 9
95823: LESS
95824: IFFALSE 95836
// k := tmp ;
95826: LD_ADDR_VAR 0 9
95830: PUSH
95831: LD_VAR 0 14
95835: ST_TO_ADDR
// for j = 1 to k do
95836: LD_ADDR_VAR 0 8
95840: PUSH
95841: DOUBLE
95842: LD_INT 1
95844: DEC
95845: ST_TO_ADDR
95846: LD_VAR 0 9
95850: PUSH
95851: FOR_TO
95852: IFFALSE 95984
// begin if GetType ( tmp [ j ] ) = unit_building then
95854: LD_VAR 0 14
95858: PUSH
95859: LD_VAR 0 8
95863: ARRAY
95864: PPUSH
95865: CALL_OW 247
95869: PUSH
95870: LD_INT 3
95872: EQUAL
95873: IFFALSE 95982
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
95875: LD_VAR 0 14
95879: PUSH
95880: LD_VAR 0 8
95884: ARRAY
95885: PUSH
95886: LD_VAR 0 28
95890: IN
95891: NOT
95892: PUSH
95893: LD_VAR 0 14
95897: PUSH
95898: LD_VAR 0 8
95902: ARRAY
95903: PPUSH
95904: CALL_OW 313
95908: AND
95909: IFFALSE 95982
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
95911: LD_VAR 0 4
95915: PUSH
95916: LD_VAR 0 7
95920: ARRAY
95921: PPUSH
95922: LD_VAR 0 14
95926: PUSH
95927: LD_VAR 0 8
95931: ARRAY
95932: PPUSH
95933: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
95937: LD_ADDR_VAR 0 28
95941: PUSH
95942: LD_VAR 0 28
95946: PPUSH
95947: LD_VAR 0 28
95951: PUSH
95952: LD_INT 1
95954: PLUS
95955: PPUSH
95956: LD_VAR 0 14
95960: PUSH
95961: LD_VAR 0 8
95965: ARRAY
95966: PPUSH
95967: CALL_OW 1
95971: ST_TO_ADDR
// attacking := true ;
95972: LD_ADDR_VAR 0 29
95976: PUSH
95977: LD_INT 1
95979: ST_TO_ADDR
// break ;
95980: GO 95984
// end ; end ;
95982: GO 95851
95984: POP
95985: POP
// if not attacking and f_attack_depot then
95986: LD_VAR 0 29
95990: NOT
95991: PUSH
95992: LD_VAR 0 25
95996: AND
95997: IFFALSE 96092
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
95999: LD_ADDR_VAR 0 13
96003: PUSH
96004: LD_VAR 0 14
96008: PPUSH
96009: LD_INT 2
96011: PUSH
96012: LD_INT 30
96014: PUSH
96015: LD_INT 0
96017: PUSH
96018: EMPTY
96019: LIST
96020: LIST
96021: PUSH
96022: LD_INT 30
96024: PUSH
96025: LD_INT 1
96027: PUSH
96028: EMPTY
96029: LIST
96030: LIST
96031: PUSH
96032: EMPTY
96033: LIST
96034: LIST
96035: LIST
96036: PPUSH
96037: CALL_OW 72
96041: ST_TO_ADDR
// if z then
96042: LD_VAR 0 13
96046: IFFALSE 96092
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
96048: LD_VAR 0 4
96052: PUSH
96053: LD_VAR 0 7
96057: ARRAY
96058: PPUSH
96059: LD_VAR 0 13
96063: PPUSH
96064: LD_VAR 0 4
96068: PUSH
96069: LD_VAR 0 7
96073: ARRAY
96074: PPUSH
96075: CALL_OW 74
96079: PPUSH
96080: CALL_OW 115
// attacking := true ;
96084: LD_ADDR_VAR 0 29
96088: PUSH
96089: LD_INT 1
96091: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
96092: LD_VAR 0 4
96096: PUSH
96097: LD_VAR 0 7
96101: ARRAY
96102: PPUSH
96103: CALL_OW 256
96107: PUSH
96108: LD_INT 500
96110: LESS
96111: IFFALSE 96137
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
96113: LD_VAR 0 4
96117: PUSH
96118: LD_VAR 0 7
96122: ARRAY
96123: PPUSH
96124: LD_VAR 0 14
96128: PUSH
96129: LD_INT 1
96131: ARRAY
96132: PPUSH
96133: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
96137: LD_VAR 0 4
96141: PUSH
96142: LD_VAR 0 7
96146: ARRAY
96147: PPUSH
96148: CALL_OW 264
96152: PUSH
96153: LD_INT 49
96155: EQUAL
96156: IFFALSE 96277
// begin if not HasTask ( group [ i ] ) then
96158: LD_VAR 0 4
96162: PUSH
96163: LD_VAR 0 7
96167: ARRAY
96168: PPUSH
96169: CALL_OW 314
96173: NOT
96174: IFFALSE 96277
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
96176: LD_ADDR_VAR 0 9
96180: PUSH
96181: LD_INT 81
96183: PUSH
96184: LD_VAR 0 4
96188: PUSH
96189: LD_VAR 0 7
96193: ARRAY
96194: PPUSH
96195: CALL_OW 255
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: PPUSH
96204: CALL_OW 69
96208: PPUSH
96209: LD_VAR 0 4
96213: PUSH
96214: LD_VAR 0 7
96218: ARRAY
96219: PPUSH
96220: CALL_OW 74
96224: ST_TO_ADDR
// if k then
96225: LD_VAR 0 9
96229: IFFALSE 96277
// if GetDistUnits ( group [ i ] , k ) > 10 then
96231: LD_VAR 0 4
96235: PUSH
96236: LD_VAR 0 7
96240: ARRAY
96241: PPUSH
96242: LD_VAR 0 9
96246: PPUSH
96247: CALL_OW 296
96251: PUSH
96252: LD_INT 10
96254: GREATER
96255: IFFALSE 96277
// ComMoveUnit ( group [ i ] , k ) ;
96257: LD_VAR 0 4
96261: PUSH
96262: LD_VAR 0 7
96266: ARRAY
96267: PPUSH
96268: LD_VAR 0 9
96272: PPUSH
96273: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
96277: LD_VAR 0 4
96281: PUSH
96282: LD_VAR 0 7
96286: ARRAY
96287: PPUSH
96288: CALL_OW 256
96292: PUSH
96293: LD_INT 250
96295: LESS
96296: PUSH
96297: LD_VAR 0 4
96301: PUSH
96302: LD_VAR 0 7
96306: ARRAY
96307: PUSH
96308: LD_INT 21
96310: PUSH
96311: LD_INT 2
96313: PUSH
96314: EMPTY
96315: LIST
96316: LIST
96317: PUSH
96318: LD_INT 23
96320: PUSH
96321: LD_INT 2
96323: PUSH
96324: EMPTY
96325: LIST
96326: LIST
96327: PUSH
96328: EMPTY
96329: LIST
96330: LIST
96331: PPUSH
96332: CALL_OW 69
96336: IN
96337: AND
96338: IFFALSE 96463
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
96340: LD_ADDR_VAR 0 9
96344: PUSH
96345: LD_OWVAR 3
96349: PUSH
96350: LD_VAR 0 4
96354: PUSH
96355: LD_VAR 0 7
96359: ARRAY
96360: DIFF
96361: PPUSH
96362: LD_VAR 0 4
96366: PUSH
96367: LD_VAR 0 7
96371: ARRAY
96372: PPUSH
96373: CALL_OW 74
96377: ST_TO_ADDR
// if not k then
96378: LD_VAR 0 9
96382: NOT
96383: IFFALSE 96387
// continue ;
96385: GO 92802
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
96387: LD_VAR 0 9
96391: PUSH
96392: LD_INT 81
96394: PUSH
96395: LD_VAR 0 4
96399: PUSH
96400: LD_VAR 0 7
96404: ARRAY
96405: PPUSH
96406: CALL_OW 255
96410: PUSH
96411: EMPTY
96412: LIST
96413: LIST
96414: PPUSH
96415: CALL_OW 69
96419: IN
96420: PUSH
96421: LD_VAR 0 9
96425: PPUSH
96426: LD_VAR 0 4
96430: PUSH
96431: LD_VAR 0 7
96435: ARRAY
96436: PPUSH
96437: CALL_OW 296
96441: PUSH
96442: LD_INT 5
96444: LESS
96445: AND
96446: IFFALSE 96463
// ComAutodestruct ( group [ i ] ) ;
96448: LD_VAR 0 4
96452: PUSH
96453: LD_VAR 0 7
96457: ARRAY
96458: PPUSH
96459: CALL 46324 0 1
// end ; if f_attack_depot then
96463: LD_VAR 0 25
96467: IFFALSE 96579
// begin k := 6 ;
96469: LD_ADDR_VAR 0 9
96473: PUSH
96474: LD_INT 6
96476: ST_TO_ADDR
// if tmp < k then
96477: LD_VAR 0 14
96481: PUSH
96482: LD_VAR 0 9
96486: LESS
96487: IFFALSE 96499
// k := tmp ;
96489: LD_ADDR_VAR 0 9
96493: PUSH
96494: LD_VAR 0 14
96498: ST_TO_ADDR
// for j = 1 to k do
96499: LD_ADDR_VAR 0 8
96503: PUSH
96504: DOUBLE
96505: LD_INT 1
96507: DEC
96508: ST_TO_ADDR
96509: LD_VAR 0 9
96513: PUSH
96514: FOR_TO
96515: IFFALSE 96577
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
96517: LD_VAR 0 8
96521: PPUSH
96522: CALL_OW 266
96526: PUSH
96527: LD_INT 0
96529: PUSH
96530: LD_INT 1
96532: PUSH
96533: EMPTY
96534: LIST
96535: LIST
96536: IN
96537: IFFALSE 96575
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
96539: LD_VAR 0 4
96543: PUSH
96544: LD_VAR 0 7
96548: ARRAY
96549: PPUSH
96550: LD_VAR 0 14
96554: PUSH
96555: LD_VAR 0 8
96559: ARRAY
96560: PPUSH
96561: CALL_OW 115
// attacking := true ;
96565: LD_ADDR_VAR 0 29
96569: PUSH
96570: LD_INT 1
96572: ST_TO_ADDR
// break ;
96573: GO 96577
// end ;
96575: GO 96514
96577: POP
96578: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
96579: LD_VAR 0 4
96583: PUSH
96584: LD_VAR 0 7
96588: ARRAY
96589: PPUSH
96590: CALL_OW 302
96594: PUSH
96595: LD_VAR 0 29
96599: NOT
96600: AND
96601: IFFALSE 96923
// begin if GetTag ( group [ i ] ) = 71 then
96603: LD_VAR 0 4
96607: PUSH
96608: LD_VAR 0 7
96612: ARRAY
96613: PPUSH
96614: CALL_OW 110
96618: PUSH
96619: LD_INT 71
96621: EQUAL
96622: IFFALSE 96663
// begin if HasTask ( group [ i ] ) then
96624: LD_VAR 0 4
96628: PUSH
96629: LD_VAR 0 7
96633: ARRAY
96634: PPUSH
96635: CALL_OW 314
96639: IFFALSE 96645
// continue else
96641: GO 92802
96643: GO 96663
// SetTag ( group [ i ] , 0 ) ;
96645: LD_VAR 0 4
96649: PUSH
96650: LD_VAR 0 7
96654: ARRAY
96655: PPUSH
96656: LD_INT 0
96658: PPUSH
96659: CALL_OW 109
// end ; k := 8 ;
96663: LD_ADDR_VAR 0 9
96667: PUSH
96668: LD_INT 8
96670: ST_TO_ADDR
// x := 0 ;
96671: LD_ADDR_VAR 0 10
96675: PUSH
96676: LD_INT 0
96678: ST_TO_ADDR
// if tmp < k then
96679: LD_VAR 0 14
96683: PUSH
96684: LD_VAR 0 9
96688: LESS
96689: IFFALSE 96701
// k := tmp ;
96691: LD_ADDR_VAR 0 9
96695: PUSH
96696: LD_VAR 0 14
96700: ST_TO_ADDR
// for j = 1 to k do
96701: LD_ADDR_VAR 0 8
96705: PUSH
96706: DOUBLE
96707: LD_INT 1
96709: DEC
96710: ST_TO_ADDR
96711: LD_VAR 0 9
96715: PUSH
96716: FOR_TO
96717: IFFALSE 96815
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
96719: LD_VAR 0 14
96723: PUSH
96724: LD_VAR 0 8
96728: ARRAY
96729: PPUSH
96730: CALL_OW 247
96734: PUSH
96735: LD_INT 1
96737: EQUAL
96738: PUSH
96739: LD_VAR 0 14
96743: PUSH
96744: LD_VAR 0 8
96748: ARRAY
96749: PPUSH
96750: CALL_OW 256
96754: PUSH
96755: LD_INT 250
96757: LESS
96758: PUSH
96759: LD_VAR 0 20
96763: AND
96764: PUSH
96765: LD_VAR 0 20
96769: NOT
96770: PUSH
96771: LD_VAR 0 14
96775: PUSH
96776: LD_VAR 0 8
96780: ARRAY
96781: PPUSH
96782: CALL_OW 256
96786: PUSH
96787: LD_INT 250
96789: GREATEREQUAL
96790: AND
96791: OR
96792: AND
96793: IFFALSE 96813
// begin x := tmp [ j ] ;
96795: LD_ADDR_VAR 0 10
96799: PUSH
96800: LD_VAR 0 14
96804: PUSH
96805: LD_VAR 0 8
96809: ARRAY
96810: ST_TO_ADDR
// break ;
96811: GO 96815
// end ;
96813: GO 96716
96815: POP
96816: POP
// if x then
96817: LD_VAR 0 10
96821: IFFALSE 96845
// ComAttackUnit ( group [ i ] , x ) else
96823: LD_VAR 0 4
96827: PUSH
96828: LD_VAR 0 7
96832: ARRAY
96833: PPUSH
96834: LD_VAR 0 10
96838: PPUSH
96839: CALL_OW 115
96843: GO 96869
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
96845: LD_VAR 0 4
96849: PUSH
96850: LD_VAR 0 7
96854: ARRAY
96855: PPUSH
96856: LD_VAR 0 14
96860: PUSH
96861: LD_INT 1
96863: ARRAY
96864: PPUSH
96865: CALL_OW 115
// if not HasTask ( group [ i ] ) then
96869: LD_VAR 0 4
96873: PUSH
96874: LD_VAR 0 7
96878: ARRAY
96879: PPUSH
96880: CALL_OW 314
96884: NOT
96885: IFFALSE 96923
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
96887: LD_VAR 0 4
96891: PUSH
96892: LD_VAR 0 7
96896: ARRAY
96897: PPUSH
96898: LD_VAR 0 14
96902: PPUSH
96903: LD_VAR 0 4
96907: PUSH
96908: LD_VAR 0 7
96912: ARRAY
96913: PPUSH
96914: CALL_OW 74
96918: PPUSH
96919: CALL_OW 115
// end ; end ; end ;
96923: GO 92802
96925: POP
96926: POP
// wait ( 0 0$2 ) ;
96927: LD_INT 70
96929: PPUSH
96930: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
96934: LD_VAR 0 4
96938: NOT
96939: PUSH
96940: LD_VAR 0 4
96944: PUSH
96945: EMPTY
96946: EQUAL
96947: OR
96948: PUSH
96949: LD_INT 81
96951: PUSH
96952: LD_VAR 0 35
96956: PUSH
96957: EMPTY
96958: LIST
96959: LIST
96960: PPUSH
96961: CALL_OW 69
96965: NOT
96966: OR
96967: IFFALSE 92787
// end ;
96969: LD_VAR 0 2
96973: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
96974: LD_INT 0
96976: PPUSH
96977: PPUSH
96978: PPUSH
96979: PPUSH
96980: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
96981: LD_VAR 0 1
96985: NOT
96986: PUSH
96987: LD_EXP 59
96991: PUSH
96992: LD_VAR 0 1
96996: ARRAY
96997: NOT
96998: OR
96999: PUSH
97000: LD_VAR 0 2
97004: NOT
97005: OR
97006: PUSH
97007: LD_VAR 0 3
97011: NOT
97012: OR
97013: IFFALSE 97017
// exit ;
97015: GO 97530
// side := mc_sides [ base ] ;
97017: LD_ADDR_VAR 0 6
97021: PUSH
97022: LD_EXP 85
97026: PUSH
97027: LD_VAR 0 1
97031: ARRAY
97032: ST_TO_ADDR
// if not side then
97033: LD_VAR 0 6
97037: NOT
97038: IFFALSE 97042
// exit ;
97040: GO 97530
// for i in solds do
97042: LD_ADDR_VAR 0 7
97046: PUSH
97047: LD_VAR 0 2
97051: PUSH
97052: FOR_IN
97053: IFFALSE 97114
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
97055: LD_VAR 0 7
97059: PPUSH
97060: CALL_OW 310
97064: PPUSH
97065: CALL_OW 266
97069: PUSH
97070: LD_INT 32
97072: PUSH
97073: LD_INT 31
97075: PUSH
97076: EMPTY
97077: LIST
97078: LIST
97079: IN
97080: IFFALSE 97100
// solds := solds diff i else
97082: LD_ADDR_VAR 0 2
97086: PUSH
97087: LD_VAR 0 2
97091: PUSH
97092: LD_VAR 0 7
97096: DIFF
97097: ST_TO_ADDR
97098: GO 97112
// SetTag ( i , 18 ) ;
97100: LD_VAR 0 7
97104: PPUSH
97105: LD_INT 18
97107: PPUSH
97108: CALL_OW 109
97112: GO 97052
97114: POP
97115: POP
// if not solds then
97116: LD_VAR 0 2
97120: NOT
97121: IFFALSE 97125
// exit ;
97123: GO 97530
// repeat wait ( 0 0$1 ) ;
97125: LD_INT 35
97127: PPUSH
97128: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
97132: LD_ADDR_VAR 0 5
97136: PUSH
97137: LD_VAR 0 6
97141: PPUSH
97142: LD_VAR 0 3
97146: PPUSH
97147: CALL 16039 0 2
97151: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
97152: LD_EXP 59
97156: PUSH
97157: LD_VAR 0 1
97161: ARRAY
97162: NOT
97163: PUSH
97164: LD_EXP 59
97168: PUSH
97169: LD_VAR 0 1
97173: ARRAY
97174: PUSH
97175: EMPTY
97176: EQUAL
97177: OR
97178: IFFALSE 97215
// begin for i in solds do
97180: LD_ADDR_VAR 0 7
97184: PUSH
97185: LD_VAR 0 2
97189: PUSH
97190: FOR_IN
97191: IFFALSE 97204
// ComStop ( i ) ;
97193: LD_VAR 0 7
97197: PPUSH
97198: CALL_OW 141
97202: GO 97190
97204: POP
97205: POP
// solds := [ ] ;
97206: LD_ADDR_VAR 0 2
97210: PUSH
97211: EMPTY
97212: ST_TO_ADDR
// exit ;
97213: GO 97530
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
97215: LD_VAR 0 5
97219: NOT
97220: PUSH
97221: LD_VAR 0 5
97225: PUSH
97226: LD_INT 3
97228: GREATER
97229: OR
97230: PUSH
97231: LD_EXP 81
97235: PUSH
97236: LD_VAR 0 1
97240: ARRAY
97241: OR
97242: IFFALSE 97283
// begin for i in solds do
97244: LD_ADDR_VAR 0 7
97248: PUSH
97249: LD_VAR 0 2
97253: PUSH
97254: FOR_IN
97255: IFFALSE 97279
// if HasTask ( i ) then
97257: LD_VAR 0 7
97261: PPUSH
97262: CALL_OW 314
97266: IFFALSE 97277
// ComStop ( i ) ;
97268: LD_VAR 0 7
97272: PPUSH
97273: CALL_OW 141
97277: GO 97254
97279: POP
97280: POP
// break ;
97281: GO 97518
// end ; for i in solds do
97283: LD_ADDR_VAR 0 7
97287: PUSH
97288: LD_VAR 0 2
97292: PUSH
97293: FOR_IN
97294: IFFALSE 97510
// begin if IsInUnit ( i ) then
97296: LD_VAR 0 7
97300: PPUSH
97301: CALL_OW 310
97305: IFFALSE 97316
// ComExitBuilding ( i ) ;
97307: LD_VAR 0 7
97311: PPUSH
97312: CALL_OW 122
// if GetLives ( i ) > 333 then
97316: LD_VAR 0 7
97320: PPUSH
97321: CALL_OW 256
97325: PUSH
97326: LD_INT 333
97328: GREATER
97329: IFFALSE 97357
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
97331: LD_VAR 0 7
97335: PPUSH
97336: LD_VAR 0 5
97340: PPUSH
97341: LD_VAR 0 7
97345: PPUSH
97346: CALL_OW 74
97350: PPUSH
97351: CALL_OW 115
97355: GO 97508
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
97357: LD_ADDR_VAR 0 8
97361: PUSH
97362: LD_EXP 59
97366: PUSH
97367: LD_VAR 0 1
97371: ARRAY
97372: PPUSH
97373: LD_INT 2
97375: PUSH
97376: LD_INT 30
97378: PUSH
97379: LD_INT 0
97381: PUSH
97382: EMPTY
97383: LIST
97384: LIST
97385: PUSH
97386: LD_INT 30
97388: PUSH
97389: LD_INT 1
97391: PUSH
97392: EMPTY
97393: LIST
97394: LIST
97395: PUSH
97396: LD_INT 30
97398: PUSH
97399: LD_INT 6
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: PUSH
97406: EMPTY
97407: LIST
97408: LIST
97409: LIST
97410: LIST
97411: PPUSH
97412: CALL_OW 72
97416: PPUSH
97417: LD_VAR 0 7
97421: PPUSH
97422: CALL_OW 74
97426: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
97427: LD_VAR 0 7
97431: PPUSH
97432: LD_VAR 0 8
97436: PPUSH
97437: CALL_OW 250
97441: PPUSH
97442: LD_INT 3
97444: PPUSH
97445: LD_INT 5
97447: PPUSH
97448: CALL_OW 272
97452: PPUSH
97453: LD_VAR 0 8
97457: PPUSH
97458: CALL_OW 251
97462: PPUSH
97463: LD_INT 3
97465: PPUSH
97466: LD_INT 5
97468: PPUSH
97469: CALL_OW 273
97473: PPUSH
97474: CALL_OW 111
// SetTag ( i , 0 ) ;
97478: LD_VAR 0 7
97482: PPUSH
97483: LD_INT 0
97485: PPUSH
97486: CALL_OW 109
// solds := solds diff i ;
97490: LD_ADDR_VAR 0 2
97494: PUSH
97495: LD_VAR 0 2
97499: PUSH
97500: LD_VAR 0 7
97504: DIFF
97505: ST_TO_ADDR
// continue ;
97506: GO 97293
// end ; end ;
97508: GO 97293
97510: POP
97511: POP
// until solds ;
97512: LD_VAR 0 2
97516: IFFALSE 97125
// MC_Reset ( base , 18 ) ;
97518: LD_VAR 0 1
97522: PPUSH
97523: LD_INT 18
97525: PPUSH
97526: CALL 54615 0 2
// end ;
97530: LD_VAR 0 4
97534: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
97535: LD_INT 0
97537: PPUSH
97538: PPUSH
97539: PPUSH
97540: PPUSH
97541: PPUSH
97542: PPUSH
97543: PPUSH
97544: PPUSH
97545: PPUSH
97546: PPUSH
97547: PPUSH
97548: PPUSH
97549: PPUSH
97550: PPUSH
97551: PPUSH
97552: PPUSH
97553: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
97554: LD_ADDR_VAR 0 13
97558: PUSH
97559: LD_EXP 59
97563: PUSH
97564: LD_VAR 0 1
97568: ARRAY
97569: PPUSH
97570: LD_INT 25
97572: PUSH
97573: LD_INT 3
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PPUSH
97580: CALL_OW 72
97584: ST_TO_ADDR
// if mc_remote_driver [ base ] then
97585: LD_EXP 99
97589: PUSH
97590: LD_VAR 0 1
97594: ARRAY
97595: IFFALSE 97619
// mechs := mechs diff mc_remote_driver [ base ] ;
97597: LD_ADDR_VAR 0 13
97601: PUSH
97602: LD_VAR 0 13
97606: PUSH
97607: LD_EXP 99
97611: PUSH
97612: LD_VAR 0 1
97616: ARRAY
97617: DIFF
97618: ST_TO_ADDR
// for i in mechs do
97619: LD_ADDR_VAR 0 5
97623: PUSH
97624: LD_VAR 0 13
97628: PUSH
97629: FOR_IN
97630: IFFALSE 97665
// if GetTag ( i ) > 0 then
97632: LD_VAR 0 5
97636: PPUSH
97637: CALL_OW 110
97641: PUSH
97642: LD_INT 0
97644: GREATER
97645: IFFALSE 97663
// mechs := mechs diff i ;
97647: LD_ADDR_VAR 0 13
97651: PUSH
97652: LD_VAR 0 13
97656: PUSH
97657: LD_VAR 0 5
97661: DIFF
97662: ST_TO_ADDR
97663: GO 97629
97665: POP
97666: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
97667: LD_ADDR_VAR 0 9
97671: PUSH
97672: LD_EXP 59
97676: PUSH
97677: LD_VAR 0 1
97681: ARRAY
97682: PPUSH
97683: LD_INT 2
97685: PUSH
97686: LD_INT 25
97688: PUSH
97689: LD_INT 1
97691: PUSH
97692: EMPTY
97693: LIST
97694: LIST
97695: PUSH
97696: LD_INT 25
97698: PUSH
97699: LD_INT 5
97701: PUSH
97702: EMPTY
97703: LIST
97704: LIST
97705: PUSH
97706: LD_INT 25
97708: PUSH
97709: LD_INT 8
97711: PUSH
97712: EMPTY
97713: LIST
97714: LIST
97715: PUSH
97716: LD_INT 25
97718: PUSH
97719: LD_INT 9
97721: PUSH
97722: EMPTY
97723: LIST
97724: LIST
97725: PUSH
97726: EMPTY
97727: LIST
97728: LIST
97729: LIST
97730: LIST
97731: LIST
97732: PPUSH
97733: CALL_OW 72
97737: ST_TO_ADDR
// if not defenders and not solds then
97738: LD_VAR 0 2
97742: NOT
97743: PUSH
97744: LD_VAR 0 9
97748: NOT
97749: AND
97750: IFFALSE 97754
// exit ;
97752: GO 99380
// depot_under_attack := false ;
97754: LD_ADDR_VAR 0 17
97758: PUSH
97759: LD_INT 0
97761: ST_TO_ADDR
// sold_defenders := [ ] ;
97762: LD_ADDR_VAR 0 18
97766: PUSH
97767: EMPTY
97768: ST_TO_ADDR
// if mechs then
97769: LD_VAR 0 13
97773: IFFALSE 97902
// for i in defenders do
97775: LD_ADDR_VAR 0 5
97779: PUSH
97780: LD_VAR 0 2
97784: PUSH
97785: FOR_IN
97786: IFFALSE 97900
// begin SetTag ( i , 20 ) ;
97788: LD_VAR 0 5
97792: PPUSH
97793: LD_INT 20
97795: PPUSH
97796: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
97800: LD_VAR 0 5
97804: PPUSH
97805: CALL_OW 263
97809: PUSH
97810: LD_INT 1
97812: EQUAL
97813: PUSH
97814: LD_VAR 0 5
97818: PPUSH
97819: CALL_OW 311
97823: NOT
97824: AND
97825: PUSH
97826: LD_VAR 0 13
97830: AND
97831: IFFALSE 97898
// begin un := mechs [ 1 ] ;
97833: LD_ADDR_VAR 0 11
97837: PUSH
97838: LD_VAR 0 13
97842: PUSH
97843: LD_INT 1
97845: ARRAY
97846: ST_TO_ADDR
// ComExitBuilding ( un ) ;
97847: LD_VAR 0 11
97851: PPUSH
97852: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
97856: LD_VAR 0 11
97860: PPUSH
97861: LD_VAR 0 5
97865: PPUSH
97866: CALL_OW 180
// SetTag ( un , 19 ) ;
97870: LD_VAR 0 11
97874: PPUSH
97875: LD_INT 19
97877: PPUSH
97878: CALL_OW 109
// mechs := mechs diff un ;
97882: LD_ADDR_VAR 0 13
97886: PUSH
97887: LD_VAR 0 13
97891: PUSH
97892: LD_VAR 0 11
97896: DIFF
97897: ST_TO_ADDR
// end ; end ;
97898: GO 97785
97900: POP
97901: POP
// if solds then
97902: LD_VAR 0 9
97906: IFFALSE 97965
// for i in solds do
97908: LD_ADDR_VAR 0 5
97912: PUSH
97913: LD_VAR 0 9
97917: PUSH
97918: FOR_IN
97919: IFFALSE 97963
// if not GetTag ( i ) then
97921: LD_VAR 0 5
97925: PPUSH
97926: CALL_OW 110
97930: NOT
97931: IFFALSE 97961
// begin defenders := defenders union i ;
97933: LD_ADDR_VAR 0 2
97937: PUSH
97938: LD_VAR 0 2
97942: PUSH
97943: LD_VAR 0 5
97947: UNION
97948: ST_TO_ADDR
// SetTag ( i , 18 ) ;
97949: LD_VAR 0 5
97953: PPUSH
97954: LD_INT 18
97956: PPUSH
97957: CALL_OW 109
// end ;
97961: GO 97918
97963: POP
97964: POP
// repeat wait ( 0 0$1 ) ;
97965: LD_INT 35
97967: PPUSH
97968: CALL_OW 67
// enemy := mc_scan [ base ] ;
97972: LD_ADDR_VAR 0 3
97976: PUSH
97977: LD_EXP 82
97981: PUSH
97982: LD_VAR 0 1
97986: ARRAY
97987: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
97988: LD_EXP 59
97992: PUSH
97993: LD_VAR 0 1
97997: ARRAY
97998: NOT
97999: PUSH
98000: LD_EXP 59
98004: PUSH
98005: LD_VAR 0 1
98009: ARRAY
98010: PUSH
98011: EMPTY
98012: EQUAL
98013: OR
98014: IFFALSE 98051
// begin for i in defenders do
98016: LD_ADDR_VAR 0 5
98020: PUSH
98021: LD_VAR 0 2
98025: PUSH
98026: FOR_IN
98027: IFFALSE 98040
// ComStop ( i ) ;
98029: LD_VAR 0 5
98033: PPUSH
98034: CALL_OW 141
98038: GO 98026
98040: POP
98041: POP
// defenders := [ ] ;
98042: LD_ADDR_VAR 0 2
98046: PUSH
98047: EMPTY
98048: ST_TO_ADDR
// exit ;
98049: GO 99380
// end ; for i in defenders do
98051: LD_ADDR_VAR 0 5
98055: PUSH
98056: LD_VAR 0 2
98060: PUSH
98061: FOR_IN
98062: IFFALSE 98880
// begin e := NearestUnitToUnit ( enemy , i ) ;
98064: LD_ADDR_VAR 0 14
98068: PUSH
98069: LD_VAR 0 3
98073: PPUSH
98074: LD_VAR 0 5
98078: PPUSH
98079: CALL_OW 74
98083: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98084: LD_ADDR_VAR 0 8
98088: PUSH
98089: LD_EXP 59
98093: PUSH
98094: LD_VAR 0 1
98098: ARRAY
98099: PPUSH
98100: LD_INT 2
98102: PUSH
98103: LD_INT 30
98105: PUSH
98106: LD_INT 0
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: PUSH
98113: LD_INT 30
98115: PUSH
98116: LD_INT 1
98118: PUSH
98119: EMPTY
98120: LIST
98121: LIST
98122: PUSH
98123: EMPTY
98124: LIST
98125: LIST
98126: LIST
98127: PPUSH
98128: CALL_OW 72
98132: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
98133: LD_ADDR_VAR 0 17
98137: PUSH
98138: LD_VAR 0 8
98142: NOT
98143: PUSH
98144: LD_VAR 0 8
98148: PPUSH
98149: LD_INT 3
98151: PUSH
98152: LD_INT 24
98154: PUSH
98155: LD_INT 600
98157: PUSH
98158: EMPTY
98159: LIST
98160: LIST
98161: PUSH
98162: EMPTY
98163: LIST
98164: LIST
98165: PPUSH
98166: CALL_OW 72
98170: OR
98171: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
98172: LD_VAR 0 5
98176: PPUSH
98177: CALL_OW 247
98181: PUSH
98182: LD_INT 2
98184: DOUBLE
98185: EQUAL
98186: IFTRUE 98190
98188: GO 98586
98190: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
98191: LD_VAR 0 5
98195: PPUSH
98196: CALL_OW 256
98200: PUSH
98201: LD_INT 650
98203: GREATER
98204: PUSH
98205: LD_VAR 0 5
98209: PPUSH
98210: LD_VAR 0 14
98214: PPUSH
98215: CALL_OW 296
98219: PUSH
98220: LD_INT 40
98222: LESS
98223: PUSH
98224: LD_VAR 0 14
98228: PPUSH
98229: LD_EXP 84
98233: PUSH
98234: LD_VAR 0 1
98238: ARRAY
98239: PPUSH
98240: CALL_OW 308
98244: OR
98245: AND
98246: IFFALSE 98368
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
98248: LD_VAR 0 5
98252: PPUSH
98253: CALL_OW 262
98257: PUSH
98258: LD_INT 1
98260: EQUAL
98261: PUSH
98262: LD_VAR 0 5
98266: PPUSH
98267: CALL_OW 261
98271: PUSH
98272: LD_INT 30
98274: LESS
98275: AND
98276: PUSH
98277: LD_VAR 0 8
98281: AND
98282: IFFALSE 98352
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
98284: LD_VAR 0 5
98288: PPUSH
98289: LD_VAR 0 8
98293: PPUSH
98294: LD_VAR 0 5
98298: PPUSH
98299: CALL_OW 74
98303: PPUSH
98304: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
98308: LD_VAR 0 5
98312: PPUSH
98313: LD_VAR 0 8
98317: PPUSH
98318: LD_VAR 0 5
98322: PPUSH
98323: CALL_OW 74
98327: PPUSH
98328: CALL_OW 296
98332: PUSH
98333: LD_INT 6
98335: LESS
98336: IFFALSE 98350
// SetFuel ( i , 100 ) ;
98338: LD_VAR 0 5
98342: PPUSH
98343: LD_INT 100
98345: PPUSH
98346: CALL_OW 240
// end else
98350: GO 98366
// ComAttackUnit ( i , e ) ;
98352: LD_VAR 0 5
98356: PPUSH
98357: LD_VAR 0 14
98361: PPUSH
98362: CALL_OW 115
// end else
98366: GO 98469
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
98368: LD_VAR 0 14
98372: PPUSH
98373: LD_EXP 84
98377: PUSH
98378: LD_VAR 0 1
98382: ARRAY
98383: PPUSH
98384: CALL_OW 308
98388: NOT
98389: PUSH
98390: LD_VAR 0 5
98394: PPUSH
98395: LD_VAR 0 14
98399: PPUSH
98400: CALL_OW 296
98404: PUSH
98405: LD_INT 40
98407: GREATEREQUAL
98408: AND
98409: PUSH
98410: LD_VAR 0 5
98414: PPUSH
98415: CALL_OW 256
98419: PUSH
98420: LD_INT 650
98422: LESSEQUAL
98423: OR
98424: PUSH
98425: LD_VAR 0 5
98429: PPUSH
98430: LD_EXP 83
98434: PUSH
98435: LD_VAR 0 1
98439: ARRAY
98440: PPUSH
98441: CALL_OW 308
98445: NOT
98446: AND
98447: IFFALSE 98469
// ComMoveToArea ( i , mc_parking [ base ] ) ;
98449: LD_VAR 0 5
98453: PPUSH
98454: LD_EXP 83
98458: PUSH
98459: LD_VAR 0 1
98463: ARRAY
98464: PPUSH
98465: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
98469: LD_VAR 0 5
98473: PPUSH
98474: CALL_OW 256
98478: PUSH
98479: LD_INT 998
98481: LESS
98482: PUSH
98483: LD_VAR 0 5
98487: PPUSH
98488: CALL_OW 263
98492: PUSH
98493: LD_INT 1
98495: EQUAL
98496: AND
98497: PUSH
98498: LD_VAR 0 5
98502: PPUSH
98503: CALL_OW 311
98507: AND
98508: PUSH
98509: LD_VAR 0 5
98513: PPUSH
98514: LD_EXP 83
98518: PUSH
98519: LD_VAR 0 1
98523: ARRAY
98524: PPUSH
98525: CALL_OW 308
98529: AND
98530: IFFALSE 98584
// begin mech := IsDrivenBy ( i ) ;
98532: LD_ADDR_VAR 0 10
98536: PUSH
98537: LD_VAR 0 5
98541: PPUSH
98542: CALL_OW 311
98546: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
98547: LD_VAR 0 10
98551: PPUSH
98552: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
98556: LD_VAR 0 10
98560: PPUSH
98561: LD_VAR 0 5
98565: PPUSH
98566: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
98570: LD_VAR 0 10
98574: PPUSH
98575: LD_VAR 0 5
98579: PPUSH
98580: CALL_OW 180
// end ; end ; unit_human :
98584: GO 98851
98586: LD_INT 1
98588: DOUBLE
98589: EQUAL
98590: IFTRUE 98594
98592: GO 98850
98594: POP
// begin b := IsInUnit ( i ) ;
98595: LD_ADDR_VAR 0 19
98599: PUSH
98600: LD_VAR 0 5
98604: PPUSH
98605: CALL_OW 310
98609: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
98610: LD_ADDR_VAR 0 20
98614: PUSH
98615: LD_VAR 0 19
98619: NOT
98620: PUSH
98621: LD_VAR 0 19
98625: PPUSH
98626: CALL_OW 266
98630: PUSH
98631: LD_INT 32
98633: PUSH
98634: LD_INT 31
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: IN
98641: OR
98642: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
98643: LD_VAR 0 17
98647: PUSH
98648: LD_VAR 0 2
98652: PPUSH
98653: LD_INT 21
98655: PUSH
98656: LD_INT 2
98658: PUSH
98659: EMPTY
98660: LIST
98661: LIST
98662: PPUSH
98663: CALL_OW 72
98667: PUSH
98668: LD_INT 1
98670: LESSEQUAL
98671: OR
98672: PUSH
98673: LD_VAR 0 20
98677: AND
98678: PUSH
98679: LD_VAR 0 5
98683: PUSH
98684: LD_VAR 0 18
98688: IN
98689: NOT
98690: AND
98691: IFFALSE 98784
// begin if b then
98693: LD_VAR 0 19
98697: IFFALSE 98746
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
98699: LD_VAR 0 19
98703: PPUSH
98704: LD_VAR 0 3
98708: PPUSH
98709: LD_VAR 0 19
98713: PPUSH
98714: CALL_OW 74
98718: PPUSH
98719: CALL_OW 296
98723: PUSH
98724: LD_INT 10
98726: LESS
98727: PUSH
98728: LD_VAR 0 19
98732: PPUSH
98733: CALL_OW 461
98737: PUSH
98738: LD_INT 7
98740: NONEQUAL
98741: AND
98742: IFFALSE 98746
// continue ;
98744: GO 98061
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
98746: LD_ADDR_VAR 0 18
98750: PUSH
98751: LD_VAR 0 18
98755: PPUSH
98756: LD_VAR 0 18
98760: PUSH
98761: LD_INT 1
98763: PLUS
98764: PPUSH
98765: LD_VAR 0 5
98769: PPUSH
98770: CALL_OW 1
98774: ST_TO_ADDR
// ComExitBuilding ( i ) ;
98775: LD_VAR 0 5
98779: PPUSH
98780: CALL_OW 122
// end ; if sold_defenders then
98784: LD_VAR 0 18
98788: IFFALSE 98848
// if i in sold_defenders then
98790: LD_VAR 0 5
98794: PUSH
98795: LD_VAR 0 18
98799: IN
98800: IFFALSE 98848
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
98802: LD_VAR 0 5
98806: PPUSH
98807: CALL_OW 314
98811: NOT
98812: PUSH
98813: LD_VAR 0 5
98817: PPUSH
98818: LD_VAR 0 14
98822: PPUSH
98823: CALL_OW 296
98827: PUSH
98828: LD_INT 30
98830: LESS
98831: AND
98832: IFFALSE 98848
// ComAttackUnit ( i , e ) ;
98834: LD_VAR 0 5
98838: PPUSH
98839: LD_VAR 0 14
98843: PPUSH
98844: CALL_OW 115
// end ; end ; end ;
98848: GO 98851
98850: POP
// if IsDead ( i ) then
98851: LD_VAR 0 5
98855: PPUSH
98856: CALL_OW 301
98860: IFFALSE 98878
// defenders := defenders diff i ;
98862: LD_ADDR_VAR 0 2
98866: PUSH
98867: LD_VAR 0 2
98871: PUSH
98872: LD_VAR 0 5
98876: DIFF
98877: ST_TO_ADDR
// end ;
98878: GO 98061
98880: POP
98881: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
98882: LD_VAR 0 3
98886: NOT
98887: PUSH
98888: LD_VAR 0 2
98892: NOT
98893: OR
98894: PUSH
98895: LD_EXP 59
98899: PUSH
98900: LD_VAR 0 1
98904: ARRAY
98905: NOT
98906: OR
98907: IFFALSE 97965
// MC_Reset ( base , 18 ) ;
98909: LD_VAR 0 1
98913: PPUSH
98914: LD_INT 18
98916: PPUSH
98917: CALL 54615 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
98921: LD_ADDR_VAR 0 2
98925: PUSH
98926: LD_VAR 0 2
98930: PUSH
98931: LD_VAR 0 2
98935: PPUSH
98936: LD_INT 2
98938: PUSH
98939: LD_INT 25
98941: PUSH
98942: LD_INT 1
98944: PUSH
98945: EMPTY
98946: LIST
98947: LIST
98948: PUSH
98949: LD_INT 25
98951: PUSH
98952: LD_INT 5
98954: PUSH
98955: EMPTY
98956: LIST
98957: LIST
98958: PUSH
98959: LD_INT 25
98961: PUSH
98962: LD_INT 8
98964: PUSH
98965: EMPTY
98966: LIST
98967: LIST
98968: PUSH
98969: LD_INT 25
98971: PUSH
98972: LD_INT 9
98974: PUSH
98975: EMPTY
98976: LIST
98977: LIST
98978: PUSH
98979: EMPTY
98980: LIST
98981: LIST
98982: LIST
98983: LIST
98984: LIST
98985: PPUSH
98986: CALL_OW 72
98990: DIFF
98991: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
98992: LD_VAR 0 3
98996: NOT
98997: PUSH
98998: LD_VAR 0 2
99002: PPUSH
99003: LD_INT 21
99005: PUSH
99006: LD_INT 2
99008: PUSH
99009: EMPTY
99010: LIST
99011: LIST
99012: PPUSH
99013: CALL_OW 72
99017: AND
99018: IFFALSE 99356
// begin tmp := FilterByTag ( defenders , 19 ) ;
99020: LD_ADDR_VAR 0 12
99024: PUSH
99025: LD_VAR 0 2
99029: PPUSH
99030: LD_INT 19
99032: PPUSH
99033: CALL 47799 0 2
99037: ST_TO_ADDR
// if tmp then
99038: LD_VAR 0 12
99042: IFFALSE 99112
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
99044: LD_ADDR_VAR 0 12
99048: PUSH
99049: LD_VAR 0 12
99053: PPUSH
99054: LD_INT 25
99056: PUSH
99057: LD_INT 3
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: PPUSH
99064: CALL_OW 72
99068: ST_TO_ADDR
// if tmp then
99069: LD_VAR 0 12
99073: IFFALSE 99112
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
99075: LD_ADDR_EXP 71
99079: PUSH
99080: LD_EXP 71
99084: PPUSH
99085: LD_VAR 0 1
99089: PPUSH
99090: LD_EXP 71
99094: PUSH
99095: LD_VAR 0 1
99099: ARRAY
99100: PUSH
99101: LD_VAR 0 12
99105: UNION
99106: PPUSH
99107: CALL_OW 1
99111: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
99112: LD_VAR 0 1
99116: PPUSH
99117: LD_INT 19
99119: PPUSH
99120: CALL 54615 0 2
// repeat wait ( 0 0$1 ) ;
99124: LD_INT 35
99126: PPUSH
99127: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
99131: LD_EXP 59
99135: PUSH
99136: LD_VAR 0 1
99140: ARRAY
99141: NOT
99142: PUSH
99143: LD_EXP 59
99147: PUSH
99148: LD_VAR 0 1
99152: ARRAY
99153: PUSH
99154: EMPTY
99155: EQUAL
99156: OR
99157: IFFALSE 99194
// begin for i in defenders do
99159: LD_ADDR_VAR 0 5
99163: PUSH
99164: LD_VAR 0 2
99168: PUSH
99169: FOR_IN
99170: IFFALSE 99183
// ComStop ( i ) ;
99172: LD_VAR 0 5
99176: PPUSH
99177: CALL_OW 141
99181: GO 99169
99183: POP
99184: POP
// defenders := [ ] ;
99185: LD_ADDR_VAR 0 2
99189: PUSH
99190: EMPTY
99191: ST_TO_ADDR
// exit ;
99192: GO 99380
// end ; for i in defenders do
99194: LD_ADDR_VAR 0 5
99198: PUSH
99199: LD_VAR 0 2
99203: PUSH
99204: FOR_IN
99205: IFFALSE 99294
// begin if not IsInArea ( i , mc_parking [ base ] ) then
99207: LD_VAR 0 5
99211: PPUSH
99212: LD_EXP 83
99216: PUSH
99217: LD_VAR 0 1
99221: ARRAY
99222: PPUSH
99223: CALL_OW 308
99227: NOT
99228: IFFALSE 99252
// ComMoveToArea ( i , mc_parking [ base ] ) else
99230: LD_VAR 0 5
99234: PPUSH
99235: LD_EXP 83
99239: PUSH
99240: LD_VAR 0 1
99244: ARRAY
99245: PPUSH
99246: CALL_OW 113
99250: GO 99292
// if GetControl ( i ) = control_manual then
99252: LD_VAR 0 5
99256: PPUSH
99257: CALL_OW 263
99261: PUSH
99262: LD_INT 1
99264: EQUAL
99265: IFFALSE 99292
// if IsDrivenBy ( i ) then
99267: LD_VAR 0 5
99271: PPUSH
99272: CALL_OW 311
99276: IFFALSE 99292
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
99278: LD_VAR 0 5
99282: PPUSH
99283: CALL_OW 311
99287: PPUSH
99288: CALL_OW 121
// end ;
99292: GO 99204
99294: POP
99295: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
99296: LD_VAR 0 2
99300: PPUSH
99301: LD_INT 95
99303: PUSH
99304: LD_EXP 83
99308: PUSH
99309: LD_VAR 0 1
99313: ARRAY
99314: PUSH
99315: EMPTY
99316: LIST
99317: LIST
99318: PPUSH
99319: CALL_OW 72
99323: PUSH
99324: LD_VAR 0 2
99328: EQUAL
99329: PUSH
99330: LD_EXP 82
99334: PUSH
99335: LD_VAR 0 1
99339: ARRAY
99340: OR
99341: PUSH
99342: LD_EXP 59
99346: PUSH
99347: LD_VAR 0 1
99351: ARRAY
99352: NOT
99353: OR
99354: IFFALSE 99124
// end ; MC_Reset ( base , 19 ) ;
99356: LD_VAR 0 1
99360: PPUSH
99361: LD_INT 19
99363: PPUSH
99364: CALL 54615 0 2
// MC_Reset ( base , 20 ) ;
99368: LD_VAR 0 1
99372: PPUSH
99373: LD_INT 20
99375: PPUSH
99376: CALL 54615 0 2
// end ;
99380: LD_VAR 0 4
99384: RET
