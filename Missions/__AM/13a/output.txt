// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 690 0 0
// InitGlobalVariables ;
  19: CALL 86706 0 0
// InitMacro ;
  23: CALL 56080 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 48947 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 48947 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 48947 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 4
 128: PUSH
 129: LD_INT 3
 131: PUSH
 132: LD_INT 2
 134: PUSH
 135: LD_INT 2
 137: PUSH
 138: EMPTY
 139: LIST
 140: LIST
 141: LIST
 142: LIST
 143: PUSH
 144: LD_OWVAR 67
 148: ARRAY
 149: PPUSH
 150: LD_INT 0
 152: PPUSH
 153: LD_INT 0
 155: PPUSH
 156: LD_INT 0
 158: PPUSH
 159: LD_INT 0
 161: PPUSH
 162: LD_INT 12
 164: PPUSH
 165: LD_INT 0
 167: PPUSH
 168: CALL 48947 0 9
// PrepareArabian ;
 172: CALL 3964 0 0
// PrepareRussian ;
 176: CALL 2935 0 0
// PrepareAlliance ;
 180: CALL 900 0 0
// MC_Start ( ) ;
 184: CALL 58245 0 0
// if debug then
 188: LD_EXP 1
 192: IFFALSE 201
// FogOff ( 1 ) ;
 194: LD_INT 1
 196: PPUSH
 197: CALL_OW 344
// Action ;
 201: CALL 7326 0 0
// end ;
 205: END
// export function CustomInitMacro ; var i ; begin
 206: LD_INT 0
 208: PPUSH
 209: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 210: LD_ADDR_EXP 84
 214: PUSH
 215: LD_INT 1
 217: PUSH
 218: LD_INT 2
 220: PUSH
 221: EMPTY
 222: LIST
 223: LIST
 224: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 225: LD_ADDR_EXP 85
 229: PUSH
 230: LD_INT 3
 232: PUSH
 233: LD_INT 4
 235: PUSH
 236: EMPTY
 237: LIST
 238: LIST
 239: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 240: LD_INT 1
 242: PPUSH
 243: LD_INT 12
 245: PUSH
 246: LD_INT 15
 248: PUSH
 249: LD_INT 18
 251: PUSH
 252: LD_INT 20
 254: PUSH
 255: EMPTY
 256: LIST
 257: LIST
 258: LIST
 259: LIST
 260: PUSH
 261: LD_OWVAR 67
 265: ARRAY
 266: PPUSH
 267: LD_INT 7
 269: PPUSH
 270: CALL 79934 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 274: LD_INT 1
 276: PPUSH
 277: LD_EXP 55
 281: PPUSH
 282: CALL 80360 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 286: LD_INT 1
 288: PPUSH
 289: LD_INT 6
 291: PPUSH
 292: CALL 80818 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 296: LD_INT 1
 298: PPUSH
 299: LD_INT 9
 301: PUSH
 302: EMPTY
 303: LIST
 304: PPUSH
 305: CALL 81087 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 13
 314: PUSH
 315: LD_INT 1
 317: PUSH
 318: LD_INT 2
 320: PUSH
 321: LD_INT 32
 323: PUSH
 324: EMPTY
 325: LIST
 326: LIST
 327: LIST
 328: LIST
 329: PUSH
 330: LD_INT 13
 332: PUSH
 333: LD_INT 1
 335: PUSH
 336: LD_INT 2
 338: PUSH
 339: LD_EXP 110
 343: PUSH
 344: EMPTY
 345: LIST
 346: LIST
 347: LIST
 348: LIST
 349: PUSH
 350: EMPTY
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 80300 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_INT 12
 363: PUSH
 364: LD_INT 14
 366: PUSH
 367: LD_INT 10
 369: PUSH
 370: LD_INT 11
 372: PUSH
 373: EMPTY
 374: LIST
 375: LIST
 376: LIST
 377: LIST
 378: PPUSH
 379: CALL 80994 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 383: LD_INT 2
 385: PPUSH
 386: LD_EXP 52
 390: PPUSH
 391: CALL 80360 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 395: LD_INT 2
 397: PPUSH
 398: LD_INT 8
 400: PPUSH
 401: CALL 80818 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 405: LD_INT 2
 407: PPUSH
 408: LD_INT 10
 410: PUSH
 411: EMPTY
 412: LIST
 413: PPUSH
 414: CALL 81087 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 418: LD_INT 2
 420: PPUSH
 421: LD_INT 6
 423: PUSH
 424: LD_INT 71
 426: PUSH
 427: LD_INT 116
 429: PUSH
 430: LD_INT 4
 432: PUSH
 433: EMPTY
 434: LIST
 435: LIST
 436: LIST
 437: LIST
 438: PUSH
 439: LD_INT 4
 441: PUSH
 442: LD_INT 85
 444: PUSH
 445: LD_INT 116
 447: PUSH
 448: LD_INT 4
 450: PUSH
 451: EMPTY
 452: LIST
 453: LIST
 454: LIST
 455: LIST
 456: PUSH
 457: LD_INT 32
 459: PUSH
 460: LD_INT 83
 462: PUSH
 463: LD_INT 111
 465: PUSH
 466: LD_INT 4
 468: PUSH
 469: EMPTY
 470: LIST
 471: LIST
 472: LIST
 473: LIST
 474: PUSH
 475: LD_INT 32
 477: PUSH
 478: LD_INT 87
 480: PUSH
 481: LD_INT 121
 483: PUSH
 484: LD_INT 4
 486: PUSH
 487: EMPTY
 488: LIST
 489: LIST
 490: LIST
 491: LIST
 492: PUSH
 493: LD_INT 33
 495: PUSH
 496: LD_INT 88
 498: PUSH
 499: LD_INT 128
 501: PUSH
 502: LD_INT 4
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 32
 513: PUSH
 514: LD_INT 59
 516: PUSH
 517: LD_INT 89
 519: PUSH
 520: LD_INT 3
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: LD_INT 33
 531: PUSH
 532: LD_INT 69
 534: PUSH
 535: LD_INT 98
 537: PUSH
 538: LD_INT 3
 540: PUSH
 541: EMPTY
 542: LIST
 543: LIST
 544: LIST
 545: LIST
 546: PUSH
 547: LD_INT 33
 549: PUSH
 550: LD_INT 77
 552: PUSH
 553: LD_INT 103
 555: PUSH
 556: LD_INT 3
 558: PUSH
 559: EMPTY
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: PUSH
 565: LD_INT 33
 567: PUSH
 568: LD_INT 83
 570: PUSH
 571: LD_INT 105
 573: PUSH
 574: LD_INT 3
 576: PUSH
 577: EMPTY
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: PUSH
 583: LD_INT 33
 585: PUSH
 586: LD_INT 71
 588: PUSH
 589: LD_INT 125
 591: PUSH
 592: LD_INT 5
 594: PUSH
 595: EMPTY
 596: LIST
 597: LIST
 598: LIST
 599: LIST
 600: PUSH
 601: EMPTY
 602: LIST
 603: LIST
 604: LIST
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PPUSH
 613: CALL 80144 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 617: LD_INT 2
 619: PPUSH
 620: LD_INT 43
 622: PUSH
 623: LD_INT 47
 625: PUSH
 626: LD_INT 46
 628: PUSH
 629: EMPTY
 630: LIST
 631: LIST
 632: LIST
 633: PPUSH
 634: CALL 81405 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 638: LD_INT 2
 640: PPUSH
 641: LD_INT 21
 643: PUSH
 644: LD_INT 1
 646: PUSH
 647: LD_INT 3
 649: PUSH
 650: LD_INT 51
 652: PUSH
 653: EMPTY
 654: LIST
 655: LIST
 656: LIST
 657: LIST
 658: PUSH
 659: LD_INT 22
 661: PUSH
 662: LD_INT 1
 664: PUSH
 665: LD_INT 3
 667: PUSH
 668: LD_INT 52
 670: PUSH
 671: EMPTY
 672: LIST
 673: LIST
 674: LIST
 675: LIST
 676: PUSH
 677: EMPTY
 678: LIST
 679: LIST
 680: PPUSH
 681: CALL 80300 0 2
// end ;
 685: LD_VAR 0 1
 689: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 690: LD_INT 0
 692: PPUSH
// debug := false ;
 693: LD_ADDR_EXP 1
 697: PUSH
 698: LD_INT 0
 700: ST_TO_ADDR
// game := true ;
 701: LD_ADDR_EXP 2
 705: PUSH
 706: LD_INT 1
 708: ST_TO_ADDR
// gossudarov_arrive := false ;
 709: LD_ADDR_EXP 4
 713: PUSH
 714: LD_INT 0
 716: ST_TO_ADDR
// ru_lab_builded := false ;
 717: LD_ADDR_EXP 5
 721: PUSH
 722: LD_INT 0
 724: ST_TO_ADDR
// player_spotted := false ;
 725: LD_ADDR_EXP 6
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// first_attack := false ;
 733: LD_ADDR_EXP 7
 737: PUSH
 738: LD_INT 0
 740: ST_TO_ADDR
// ru_attackers := [ ] ;
 741: LD_ADDR_EXP 53
 745: PUSH
 746: EMPTY
 747: ST_TO_ADDR
// ar_base_spotted := false ;
 748: LD_ADDR_EXP 8
 752: PUSH
 753: LD_INT 0
 755: ST_TO_ADDR
// ar_active_attack := false ;
 756: LD_ADDR_EXP 9
 760: PUSH
 761: LD_INT 0
 763: ST_TO_ADDR
// ar_attackers := [ ] ;
 764: LD_ADDR_EXP 11
 768: PUSH
 769: EMPTY
 770: ST_TO_ADDR
// first_powell_attack := false ;
 771: LD_ADDR_EXP 12
 775: PUSH
 776: LD_INT 0
 778: ST_TO_ADDR
// masha_killed := false ;
 779: LD_ADDR_EXP 10
 783: PUSH
 784: LD_INT 0
 786: ST_TO_ADDR
// abdul_escaped := true ;
 787: LD_ADDR_EXP 13
 791: PUSH
 792: LD_INT 1
 794: ST_TO_ADDR
// loss_counter := 0 ;
 795: LD_ADDR_EXP 14
 799: PUSH
 800: LD_INT 0
 802: ST_TO_ADDR
// hack_counter := 0 ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_INT 0
 810: ST_TO_ADDR
// end ;
 811: LD_VAR 0 1
 815: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 816: LD_EXP 49
 820: PPUSH
 821: CALL_OW 255
 825: PUSH
 826: LD_INT 7
 828: EQUAL
 829: PUSH
 830: LD_EXP 48
 834: PPUSH
 835: CALL_OW 255
 839: PUSH
 840: LD_INT 7
 842: EQUAL
 843: AND
 844: PUSH
 845: LD_EXP 49
 849: PPUSH
 850: CALL_OW 302
 854: AND
 855: PUSH
 856: LD_EXP 48
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: IFFALSE 878
 868: GO 870
 870: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 871: LD_STRING ACH_COMRADE
 873: PPUSH
 874: CALL_OW 543
 878: END
// every 0 0$1 trigger hack_counter >= 10 do
 879: LD_EXP 15
 883: PUSH
 884: LD_INT 10
 886: GREATEREQUAL
 887: IFFALSE 899
 889: GO 891
 891: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 892: LD_STRING ACH_HACK
 894: PPUSH
 895: CALL_OW 543
 899: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 900: LD_INT 0
 902: PPUSH
 903: PPUSH
 904: PPUSH
 905: PPUSH
// uc_side := 7 ;
 906: LD_ADDR_OWVAR 20
 910: PUSH
 911: LD_INT 7
 913: ST_TO_ADDR
// uc_nation := 1 ;
 914: LD_ADDR_OWVAR 21
 918: PUSH
 919: LD_INT 1
 921: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 922: LD_ADDR_EXP 16
 926: PUSH
 927: LD_STRING JMM
 929: PPUSH
 930: LD_EXP 1
 934: NOT
 935: PPUSH
 936: LD_STRING 12a_
 938: PPUSH
 939: CALL 14864 0 3
 943: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 944: LD_EXP 16
 948: PPUSH
 949: LD_INT 71
 951: PPUSH
 952: LD_INT 23
 954: PPUSH
 955: LD_INT 0
 957: PPUSH
 958: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 962: LD_EXP 16
 966: PPUSH
 967: LD_INT 2
 969: PPUSH
 970: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 974: LD_ADDR_EXP 17
 978: PUSH
 979: LD_STRING Roth
 981: PPUSH
 982: LD_EXP 1
 986: NOT
 987: PPUSH
 988: LD_STRING 12a_
 990: PPUSH
 991: CALL 14864 0 3
 995: ST_TO_ADDR
// if Roth then
 996: LD_EXP 17
1000: IFFALSE 1020
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1002: LD_EXP 17
1006: PPUSH
1007: LD_INT 71
1009: PPUSH
1010: LD_INT 21
1012: PPUSH
1013: LD_INT 0
1015: PPUSH
1016: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1020: LD_ADDR_EXP 18
1024: PUSH
1025: LD_STRING Lisa
1027: PPUSH
1028: LD_EXP 1
1032: NOT
1033: PPUSH
1034: LD_STRING 12a_
1036: PPUSH
1037: CALL 14864 0 3
1041: ST_TO_ADDR
// if Lisa then
1042: LD_EXP 18
1046: IFFALSE 1063
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1048: LD_EXP 18
1052: PPUSH
1053: LD_INT 13
1055: PPUSH
1056: LD_INT 0
1058: PPUSH
1059: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1063: LD_ADDR_EXP 19
1067: PUSH
1068: LD_STRING Donaldson
1070: PPUSH
1071: LD_EXP 1
1075: NOT
1076: PPUSH
1077: LD_STRING 12a_
1079: PPUSH
1080: CALL 14864 0 3
1084: ST_TO_ADDR
// if Donaldson then
1085: LD_EXP 19
1089: IFFALSE 1106
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1091: LD_EXP 19
1095: PPUSH
1096: LD_INT 13
1098: PPUSH
1099: LD_INT 0
1101: PPUSH
1102: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1106: LD_ADDR_EXP 20
1110: PUSH
1111: LD_STRING Bobby
1113: PPUSH
1114: LD_EXP 1
1118: NOT
1119: PPUSH
1120: LD_STRING 12a_
1122: PPUSH
1123: CALL 14864 0 3
1127: ST_TO_ADDR
// if Bobby then
1128: LD_EXP 20
1132: IFFALSE 1149
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1134: LD_EXP 20
1138: PPUSH
1139: LD_INT 13
1141: PPUSH
1142: LD_INT 0
1144: PPUSH
1145: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1149: LD_ADDR_EXP 21
1153: PUSH
1154: LD_STRING Cyrus
1156: PPUSH
1157: LD_EXP 1
1161: NOT
1162: PPUSH
1163: LD_STRING 12a_
1165: PPUSH
1166: CALL 14864 0 3
1170: ST_TO_ADDR
// if Cyrus then
1171: LD_EXP 21
1175: IFFALSE 1192
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1177: LD_EXP 21
1181: PPUSH
1182: LD_INT 13
1184: PPUSH
1185: LD_INT 0
1187: PPUSH
1188: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1192: LD_ADDR_EXP 22
1196: PUSH
1197: LD_STRING Denis
1199: PPUSH
1200: LD_EXP 1
1204: NOT
1205: PPUSH
1206: LD_STRING 12a_
1208: PPUSH
1209: CALL 14864 0 3
1213: ST_TO_ADDR
// if Denis then
1214: LD_EXP 22
1218: IFFALSE 1235
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1220: LD_EXP 22
1224: PPUSH
1225: LD_INT 13
1227: PPUSH
1228: LD_INT 0
1230: PPUSH
1231: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1235: LD_ADDR_EXP 23
1239: PUSH
1240: LD_STRING Brown
1242: PPUSH
1243: LD_EXP 1
1247: NOT
1248: PPUSH
1249: LD_STRING 12a_
1251: PPUSH
1252: CALL 14864 0 3
1256: ST_TO_ADDR
// if Brown then
1257: LD_EXP 23
1261: IFFALSE 1278
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1263: LD_EXP 23
1267: PPUSH
1268: LD_INT 13
1270: PPUSH
1271: LD_INT 0
1273: PPUSH
1274: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1278: LD_ADDR_EXP 24
1282: PUSH
1283: LD_STRING Gladstone
1285: PPUSH
1286: LD_EXP 1
1290: NOT
1291: PPUSH
1292: LD_STRING 12a_
1294: PPUSH
1295: CALL 14864 0 3
1299: ST_TO_ADDR
// if Gladstone then
1300: LD_EXP 24
1304: IFFALSE 1321
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1306: LD_EXP 24
1310: PPUSH
1311: LD_INT 13
1313: PPUSH
1314: LD_INT 0
1316: PPUSH
1317: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1321: LD_ADDR_EXP 25
1325: PUSH
1326: LD_STRING Houten
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_STRING 12a_
1337: PPUSH
1338: CALL 14864 0 3
1342: ST_TO_ADDR
// if Houten then
1343: LD_EXP 25
1347: IFFALSE 1364
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1349: LD_EXP 25
1353: PPUSH
1354: LD_INT 13
1356: PPUSH
1357: LD_INT 0
1359: PPUSH
1360: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1364: LD_ADDR_EXP 26
1368: PUSH
1369: LD_STRING Cornell
1371: PPUSH
1372: LD_EXP 1
1376: NOT
1377: PPUSH
1378: LD_STRING 12a_
1380: PPUSH
1381: CALL 14864 0 3
1385: ST_TO_ADDR
// if Cornel then
1386: LD_EXP 26
1390: IFFALSE 1407
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1392: LD_EXP 26
1396: PPUSH
1397: LD_INT 13
1399: PPUSH
1400: LD_INT 0
1402: PPUSH
1403: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1407: LD_ADDR_EXP 27
1411: PUSH
1412: LD_STRING Gary
1414: PPUSH
1415: LD_EXP 1
1419: NOT
1420: PPUSH
1421: LD_STRING 12a_
1423: PPUSH
1424: CALL 14864 0 3
1428: ST_TO_ADDR
// if Gary then
1429: LD_EXP 27
1433: IFFALSE 1450
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1435: LD_EXP 27
1439: PPUSH
1440: LD_INT 13
1442: PPUSH
1443: LD_INT 0
1445: PPUSH
1446: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1450: LD_ADDR_EXP 28
1454: PUSH
1455: LD_STRING Frank
1457: PPUSH
1458: LD_EXP 1
1462: NOT
1463: PPUSH
1464: LD_STRING 12a_
1466: PPUSH
1467: CALL 14864 0 3
1471: ST_TO_ADDR
// if Frank then
1472: LD_EXP 28
1476: IFFALSE 1493
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1478: LD_EXP 28
1482: PPUSH
1483: LD_INT 13
1485: PPUSH
1486: LD_INT 0
1488: PPUSH
1489: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1493: LD_ADDR_EXP 29
1497: PUSH
1498: LD_STRING Kikuchi
1500: PPUSH
1501: LD_EXP 1
1505: NOT
1506: PPUSH
1507: LD_STRING 12a_
1509: PPUSH
1510: CALL 14864 0 3
1514: ST_TO_ADDR
// if Kikuchi then
1515: LD_EXP 29
1519: IFFALSE 1536
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1521: LD_EXP 29
1525: PPUSH
1526: LD_INT 13
1528: PPUSH
1529: LD_INT 0
1531: PPUSH
1532: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1536: LD_ADDR_EXP 30
1540: PUSH
1541: LD_STRING Simms
1543: PPUSH
1544: LD_EXP 1
1548: NOT
1549: PPUSH
1550: LD_STRING 12a_
1552: PPUSH
1553: CALL 14864 0 3
1557: ST_TO_ADDR
// if Simms then
1558: LD_EXP 30
1562: IFFALSE 1579
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1564: LD_EXP 30
1568: PPUSH
1569: LD_INT 13
1571: PPUSH
1572: LD_INT 0
1574: PPUSH
1575: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1579: LD_ADDR_EXP 31
1583: PUSH
1584: LD_STRING Joan
1586: PPUSH
1587: LD_EXP 1
1591: NOT
1592: PPUSH
1593: LD_STRING 12a_
1595: PPUSH
1596: CALL 14864 0 3
1600: ST_TO_ADDR
// if Joan then
1601: LD_EXP 31
1605: IFFALSE 1622
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1607: LD_EXP 31
1611: PPUSH
1612: LD_INT 13
1614: PPUSH
1615: LD_INT 0
1617: PPUSH
1618: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1622: LD_ADDR_EXP 32
1626: PUSH
1627: LD_STRING DeltaDoctor
1629: PPUSH
1630: LD_EXP 1
1634: NOT
1635: PPUSH
1636: LD_STRING 12a_
1638: PPUSH
1639: CALL 14864 0 3
1643: ST_TO_ADDR
// if DeltaDoctor then
1644: LD_EXP 32
1648: IFFALSE 1665
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1650: LD_EXP 32
1654: PPUSH
1655: LD_INT 13
1657: PPUSH
1658: LD_INT 0
1660: PPUSH
1661: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1665: LD_ADDR_VAR 0 4
1669: PUSH
1670: LD_STRING 12a_others
1672: PPUSH
1673: CALL_OW 31
1677: ST_TO_ADDR
// if tmp then
1678: LD_VAR 0 4
1682: IFFALSE 1716
// for i in tmp do
1684: LD_ADDR_VAR 0 3
1688: PUSH
1689: LD_VAR 0 4
1693: PUSH
1694: FOR_IN
1695: IFFALSE 1714
// PlaceUnitArea ( i , alliance_start , false ) ;
1697: LD_VAR 0 3
1701: PPUSH
1702: LD_INT 13
1704: PPUSH
1705: LD_INT 0
1707: PPUSH
1708: CALL_OW 49
1712: GO 1694
1714: POP
1715: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1716: LD_INT 3
1718: PPUSH
1719: LD_INT 3
1721: PPUSH
1722: LD_INT 3
1724: PPUSH
1725: LD_INT 12
1727: PPUSH
1728: LD_INT 100
1730: PPUSH
1731: CALL 19881 0 5
// veh := CreateVehicle ;
1735: LD_ADDR_VAR 0 2
1739: PUSH
1740: CALL_OW 45
1744: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1745: LD_VAR 0 2
1749: PPUSH
1750: LD_INT 2
1752: PPUSH
1753: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1757: LD_VAR 0 2
1761: PPUSH
1762: LD_INT 60
1764: PPUSH
1765: LD_INT 6
1767: PPUSH
1768: LD_INT 0
1770: PPUSH
1771: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1775: LD_VAR 0 2
1779: PPUSH
1780: LD_INT 4
1782: PPUSH
1783: LD_INT 30
1785: PPUSH
1786: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1790: LD_STRING 11_artifact_captured
1792: PPUSH
1793: LD_INT 0
1795: PPUSH
1796: CALL_OW 30
1800: IFFALSE 1876
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1802: LD_INT 3
1804: PPUSH
1805: LD_INT 3
1807: PPUSH
1808: LD_INT 3
1810: PPUSH
1811: LD_INT 12
1813: PPUSH
1814: LD_INT 100
1816: PPUSH
1817: CALL 19881 0 5
// veh := CreateVehicle ;
1821: LD_ADDR_VAR 0 2
1825: PUSH
1826: CALL_OW 45
1830: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1831: LD_VAR 0 2
1835: PPUSH
1836: LD_INT 3
1838: PPUSH
1839: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1843: LD_VAR 0 2
1847: PPUSH
1848: LD_INT 75
1850: PPUSH
1851: LD_INT 6
1853: PPUSH
1854: LD_INT 0
1856: PPUSH
1857: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1861: LD_VAR 0 2
1865: PPUSH
1866: LD_INT 4
1868: PPUSH
1869: LD_INT 50
1871: PPUSH
1872: CALL_OW 290
// end ; end ;
1876: LD_VAR 0 1
1880: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1881: LD_INT 0
1883: PPUSH
1884: PPUSH
1885: PPUSH
1886: PPUSH
// uc_side := 6 ;
1887: LD_ADDR_OWVAR 20
1891: PUSH
1892: LD_INT 6
1894: ST_TO_ADDR
// uc_nation := 3 ;
1895: LD_ADDR_OWVAR 21
1899: PUSH
1900: LD_INT 3
1902: ST_TO_ADDR
// InitHc ;
1903: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1907: LD_ADDR_EXP 33
1911: PUSH
1912: LD_STRING Gossudarov
1914: PPUSH
1915: CALL_OW 25
1919: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1920: LD_ADDR_EXP 34
1924: PUSH
1925: LD_STRING Kirilenkova
1927: PPUSH
1928: CALL_OW 25
1932: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1933: LD_ADDR_EXP 35
1937: PUSH
1938: LD_STRING Titov
1940: PPUSH
1941: CALL_OW 25
1945: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1946: LD_ADDR_EXP 40
1950: PUSH
1951: LD_STRING Oblukov
1953: PPUSH
1954: CALL_OW 25
1958: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1959: LD_ADDR_EXP 37
1963: PUSH
1964: LD_STRING Dolgov
1966: PPUSH
1967: CALL_OW 25
1971: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1972: LD_ADDR_EXP 38
1976: PUSH
1977: LD_STRING Petrosyan
1979: PPUSH
1980: CALL_OW 25
1984: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1985: LD_ADDR_EXP 39
1989: PUSH
1990: LD_STRING Scholtze
1992: PPUSH
1993: CALL_OW 25
1997: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1998: LD_ADDR_EXP 41
2002: PUSH
2003: LD_STRING Kapitsova
2005: PPUSH
2006: CALL_OW 25
2010: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2011: LD_ADDR_VAR 0 2
2015: PUSH
2016: LD_EXP 33
2020: PUSH
2021: LD_EXP 34
2025: PUSH
2026: LD_EXP 35
2030: PUSH
2031: LD_EXP 40
2035: PUSH
2036: LD_EXP 37
2040: PUSH
2041: LD_EXP 38
2045: PUSH
2046: LD_EXP 39
2050: PUSH
2051: LD_EXP 41
2055: PUSH
2056: EMPTY
2057: LIST
2058: LIST
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: LIST
2064: LIST
2065: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2066: LD_INT 1
2068: PPUSH
2069: LD_INT 4
2071: PPUSH
2072: LD_INT 8
2074: PPUSH
2075: CALL_OW 380
// un := CreateHuman ;
2079: LD_ADDR_VAR 0 4
2083: PUSH
2084: CALL_OW 44
2088: ST_TO_ADDR
// tmp := tmp ^ un ;
2089: LD_ADDR_VAR 0 2
2093: PUSH
2094: LD_VAR 0 2
2098: PUSH
2099: LD_VAR 0 4
2103: ADD
2104: ST_TO_ADDR
// for i in tmp do
2105: LD_ADDR_VAR 0 3
2109: PUSH
2110: LD_VAR 0 2
2114: PUSH
2115: FOR_IN
2116: IFFALSE 2135
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2118: LD_VAR 0 3
2122: PPUSH
2123: LD_INT 14
2125: PPUSH
2126: LD_INT 0
2128: PPUSH
2129: CALL_OW 49
2133: GO 2115
2135: POP
2136: POP
// if freedom then
2137: LD_EXP 3
2141: IFFALSE 2174
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2143: LD_VAR 0 2
2147: PPUSH
2148: LD_EXP 3
2152: PPUSH
2153: CALL_OW 250
2157: PPUSH
2158: LD_EXP 3
2162: PPUSH
2163: CALL_OW 251
2167: PPUSH
2168: CALL_OW 111
2172: GO 2189
// ComMoveXY ( tmp , 70 , 48 ) ;
2174: LD_VAR 0 2
2178: PPUSH
2179: LD_INT 70
2181: PPUSH
2182: LD_INT 48
2184: PPUSH
2185: CALL_OW 111
// end ;
2189: LD_VAR 0 1
2193: RET
// export function PrepareBelkov ; begin
2194: LD_INT 0
2196: PPUSH
// uc_side := 4 ;
2197: LD_ADDR_OWVAR 20
2201: PUSH
2202: LD_INT 4
2204: ST_TO_ADDR
// uc_nation := 3 ;
2205: LD_ADDR_OWVAR 21
2209: PUSH
2210: LD_INT 3
2212: ST_TO_ADDR
// InitHc ;
2213: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2217: LD_ADDR_EXP 48
2221: PUSH
2222: LD_STRING Belkov
2224: PPUSH
2225: CALL_OW 25
2229: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2230: LD_EXP 48
2234: PPUSH
2235: LD_INT 14
2237: PPUSH
2238: LD_INT 0
2240: PPUSH
2241: CALL_OW 49
// end ;
2245: LD_VAR 0 1
2249: RET
// export function PrepareGnyevko ; begin
2250: LD_INT 0
2252: PPUSH
// uc_side := 4 ;
2253: LD_ADDR_OWVAR 20
2257: PUSH
2258: LD_INT 4
2260: ST_TO_ADDR
// uc_nation := 3 ;
2261: LD_ADDR_OWVAR 21
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// InitHc ;
2269: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2273: LD_ADDR_EXP 49
2277: PUSH
2278: LD_STRING Gnyevko
2280: PPUSH
2281: CALL_OW 25
2285: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2286: LD_EXP 49
2290: PPUSH
2291: LD_INT 14
2293: PPUSH
2294: LD_INT 0
2296: PPUSH
2297: CALL_OW 49
// end ;
2301: LD_VAR 0 1
2305: RET
// export function PrepareBurlak ; var i , tmp ; begin
2306: LD_INT 0
2308: PPUSH
2309: PPUSH
2310: PPUSH
// uc_side := 4 ;
2311: LD_ADDR_OWVAR 20
2315: PUSH
2316: LD_INT 4
2318: ST_TO_ADDR
// uc_nation := 3 ;
2319: LD_ADDR_OWVAR 21
2323: PUSH
2324: LD_INT 3
2326: ST_TO_ADDR
// InitHc ;
2327: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2331: LD_ADDR_EXP 47
2335: PUSH
2336: LD_STRING Burlak
2338: PPUSH
2339: CALL_OW 25
2343: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2344: LD_INT 24
2346: PUSH
2347: LD_INT 23
2349: PUSH
2350: LD_INT 22
2352: PUSH
2353: LD_INT 22
2355: PUSH
2356: EMPTY
2357: LIST
2358: LIST
2359: LIST
2360: LIST
2361: PUSH
2362: LD_OWVAR 67
2366: ARRAY
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: LD_INT 1
2373: PPUSH
2374: LD_INT 45
2376: PUSH
2377: LD_INT 44
2379: PUSH
2380: LD_INT 43
2382: PUSH
2383: LD_INT 42
2385: PUSH
2386: EMPTY
2387: LIST
2388: LIST
2389: LIST
2390: LIST
2391: PUSH
2392: LD_OWVAR 67
2396: ARRAY
2397: PPUSH
2398: LD_INT 0
2400: PPUSH
2401: CALL 19881 0 5
// Masha := CreateVehicle ;
2405: LD_ADDR_EXP 50
2409: PUSH
2410: CALL_OW 45
2414: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2415: LD_EXP 50
2419: PUSH
2420: LD_EXP 47
2424: PUSH
2425: EMPTY
2426: LIST
2427: LIST
2428: PPUSH
2429: LD_INT 499
2431: PPUSH
2432: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2436: LD_EXP 50
2440: PPUSH
2441: LD_INT 3
2443: PPUSH
2444: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2448: LD_EXP 50
2452: PPUSH
2453: LD_INT 1
2455: PPUSH
2456: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2460: LD_INT 1
2462: PPUSH
2463: LD_INT 18
2465: PPUSH
2466: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2470: LD_INT 35
2472: PPUSH
2473: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2477: LD_ADDR_VAR 0 3
2481: PUSH
2482: LD_INT 18
2484: PPUSH
2485: EMPTY
2486: PPUSH
2487: CALL_OW 70
2491: ST_TO_ADDR
// if tmp then
2492: LD_VAR 0 3
2496: IFFALSE 2530
// for i in tmp do
2498: LD_ADDR_VAR 0 2
2502: PUSH
2503: LD_VAR 0 3
2507: PUSH
2508: FOR_IN
2509: IFFALSE 2528
// ComMoveXY ( i , 114 , 9 ) ;
2511: LD_VAR 0 2
2515: PPUSH
2516: LD_INT 114
2518: PPUSH
2519: LD_INT 9
2521: PPUSH
2522: CALL_OW 111
2526: GO 2508
2528: POP
2529: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2530: LD_INT 18
2532: PPUSH
2533: EMPTY
2534: PPUSH
2535: CALL_OW 70
2539: NOT
2540: PUSH
2541: LD_INT 123
2543: PPUSH
2544: LD_INT 3
2546: PPUSH
2547: CALL_OW 428
2551: PUSH
2552: LD_INT 0
2554: EQUAL
2555: AND
2556: IFFALSE 2470
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2558: LD_EXP 50
2562: PPUSH
2563: LD_INT 123
2565: PPUSH
2566: LD_INT 3
2568: PPUSH
2569: LD_INT 0
2571: PPUSH
2572: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2576: LD_EXP 47
2580: PPUSH
2581: LD_INT 125
2583: PPUSH
2584: LD_INT 1
2586: PPUSH
2587: LD_INT 0
2589: PPUSH
2590: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2594: LD_EXP 47
2598: PPUSH
2599: LD_EXP 50
2603: PPUSH
2604: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2608: LD_INT 10
2610: PPUSH
2611: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2615: LD_EXP 50
2619: PPUSH
2620: LD_INT 110
2622: PPUSH
2623: LD_INT 10
2625: PPUSH
2626: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2630: LD_ADDR_EXP 43
2634: PUSH
2635: LD_STRING Petrovova
2637: PPUSH
2638: CALL_OW 25
2642: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2643: LD_ADDR_EXP 45
2647: PUSH
2648: LD_STRING Kuzmov
2650: PPUSH
2651: CALL_OW 25
2655: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2656: LD_ADDR_EXP 44
2660: PUSH
2661: LD_STRING Kovalyuk
2663: PPUSH
2664: CALL_OW 25
2668: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2669: LD_ADDR_EXP 42
2673: PUSH
2674: LD_STRING Lipshchin
2676: PPUSH
2677: CALL_OW 25
2681: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2682: LD_ADDR_EXP 46
2686: PUSH
2687: LD_STRING Karamazov
2689: PPUSH
2690: CALL_OW 25
2694: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2695: LD_ADDR_VAR 0 3
2699: PUSH
2700: LD_EXP 43
2704: PUSH
2705: LD_EXP 45
2709: PUSH
2710: LD_EXP 44
2714: PUSH
2715: LD_EXP 42
2719: PUSH
2720: LD_EXP 46
2724: PUSH
2725: EMPTY
2726: LIST
2727: LIST
2728: LIST
2729: LIST
2730: LIST
2731: ST_TO_ADDR
// for i in tmp do
2732: LD_ADDR_VAR 0 2
2736: PUSH
2737: LD_VAR 0 3
2741: PUSH
2742: FOR_IN
2743: IFFALSE 2782
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2745: LD_VAR 0 2
2749: PPUSH
2750: LD_INT 399
2752: PPUSH
2753: LD_INT 799
2755: PPUSH
2756: CALL_OW 12
2760: PPUSH
2761: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2765: LD_VAR 0 2
2769: PPUSH
2770: LD_INT 19
2772: PPUSH
2773: LD_INT 0
2775: PPUSH
2776: CALL_OW 49
// end ;
2780: GO 2742
2782: POP
2783: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2784: LD_VAR 0 3
2788: PPUSH
2789: LD_INT 112
2791: PPUSH
2792: LD_INT 5
2794: PPUSH
2795: CALL_OW 111
// AddComHold ( tmp ) ;
2799: LD_VAR 0 3
2803: PPUSH
2804: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2808: LD_ADDR_VAR 0 2
2812: PUSH
2813: LD_VAR 0 3
2817: PPUSH
2818: LD_INT 25
2820: PUSH
2821: LD_INT 1
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: PPUSH
2828: CALL_OW 72
2832: PUSH
2833: FOR_IN
2834: IFFALSE 2874
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2836: LD_VAR 0 2
2840: PPUSH
2841: LD_INT 20
2843: PPUSH
2844: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2848: LD_VAR 0 2
2852: PPUSH
2853: LD_INT 147
2855: PPUSH
2856: LD_INT 45
2858: PPUSH
2859: CALL_OW 178
// AddComCrawl ( i ) ;
2863: LD_VAR 0 2
2867: PPUSH
2868: CALL_OW 197
// end ;
2872: GO 2833
2874: POP
2875: POP
// repeat wait ( 0 0$1 ) ;
2876: LD_INT 35
2878: PPUSH
2879: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2883: LD_EXP 50
2887: PPUSH
2888: LD_INT 110
2890: PPUSH
2891: LD_INT 10
2893: PPUSH
2894: CALL_OW 307
2898: PUSH
2899: LD_EXP 50
2903: PPUSH
2904: CALL_OW 305
2908: NOT
2909: OR
2910: IFFALSE 2876
// ComStop ( Burlak ) ;
2912: LD_EXP 47
2916: PPUSH
2917: CALL_OW 141
// AddComHold ( Burlak ) ;
2921: LD_EXP 47
2925: PPUSH
2926: CALL_OW 200
// end ; end_of_file
2930: LD_VAR 0 1
2934: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2935: LD_INT 0
2937: PPUSH
2938: PPUSH
2939: PPUSH
2940: PPUSH
2941: PPUSH
// uc_side := 3 ;
2942: LD_ADDR_OWVAR 20
2946: PUSH
2947: LD_INT 3
2949: ST_TO_ADDR
// uc_nation := 3 ;
2950: LD_ADDR_OWVAR 21
2954: PUSH
2955: LD_INT 3
2957: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2958: LD_ADDR_EXP 51
2962: PUSH
2963: LD_INT 47
2965: PPUSH
2966: LD_INT 4
2968: PPUSH
2969: LD_STRING 
2971: PPUSH
2972: LD_INT 7
2974: PUSH
2975: LD_INT 8
2977: PUSH
2978: LD_INT 9
2980: PUSH
2981: LD_INT 10
2983: PUSH
2984: EMPTY
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PPUSH
2996: LD_INT 10000
2998: PUSH
2999: LD_INT 3000
3001: PUSH
3002: LD_INT 300
3004: PUSH
3005: EMPTY
3006: LIST
3007: LIST
3008: LIST
3009: PPUSH
3010: LD_INT 9
3012: PUSH
3013: LD_INT 5
3015: PUSH
3016: LD_INT 6
3018: PUSH
3019: LD_INT 6
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 23327 0 6
3032: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3033: LD_ADDR_EXP 60
3037: PUSH
3038: LD_EXP 60
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_EXP 51
3050: PPUSH
3051: CALL_OW 1
3055: ST_TO_ADDR
// tmp := [ ] ;
3056: LD_ADDR_VAR 0 4
3060: PUSH
3061: EMPTY
3062: ST_TO_ADDR
// for i = 1 to 4 do
3063: LD_ADDR_VAR 0 2
3067: PUSH
3068: DOUBLE
3069: LD_INT 1
3071: DEC
3072: ST_TO_ADDR
3073: LD_INT 4
3075: PUSH
3076: FOR_TO
3077: IFFALSE 3170
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3079: LD_INT 22
3081: PPUSH
3082: LD_INT 3
3084: PPUSH
3085: LD_INT 3
3087: PPUSH
3088: LD_INT 43
3090: PUSH
3091: LD_INT 45
3093: PUSH
3094: LD_INT 45
3096: PUSH
3097: LD_INT 44
3099: PUSH
3100: EMPTY
3101: LIST
3102: LIST
3103: LIST
3104: LIST
3105: PUSH
3106: LD_VAR 0 2
3110: PUSH
3111: LD_INT 4
3113: MOD
3114: PUSH
3115: LD_INT 1
3117: PLUS
3118: ARRAY
3119: PPUSH
3120: LD_INT 100
3122: PPUSH
3123: CALL 19881 0 5
// veh := CreateVehicle ;
3127: LD_ADDR_VAR 0 3
3131: PUSH
3132: CALL_OW 45
3136: ST_TO_ADDR
// tmp := tmp ^ veh ;
3137: LD_ADDR_VAR 0 4
3141: PUSH
3142: LD_VAR 0 4
3146: PUSH
3147: LD_VAR 0 3
3151: ADD
3152: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3153: LD_VAR 0 3
3157: PPUSH
3158: LD_INT 2
3160: PPUSH
3161: LD_INT 0
3163: PPUSH
3164: CALL_OW 49
// end ;
3168: GO 3076
3170: POP
3171: POP
// russian_guard := tmp ;
3172: LD_ADDR_EXP 52
3176: PUSH
3177: LD_VAR 0 4
3181: ST_TO_ADDR
// if Difficulty >= 3 then
3182: LD_OWVAR 67
3186: PUSH
3187: LD_INT 3
3189: GREATEREQUAL
3190: IFFALSE 3254
// begin bc_type := b_breastwork ;
3192: LD_ADDR_OWVAR 42
3196: PUSH
3197: LD_INT 31
3199: ST_TO_ADDR
// bc_level := 10 ;
3200: LD_ADDR_OWVAR 43
3204: PUSH
3205: LD_INT 10
3207: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3208: LD_ADDR_VAR 0 5
3212: PUSH
3213: LD_INT 96
3215: PPUSH
3216: LD_INT 105
3218: PPUSH
3219: LD_INT 3
3221: PPUSH
3222: CALL_OW 47
3226: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3227: LD_INT 0
3229: PPUSH
3230: LD_INT 9
3232: PPUSH
3233: LD_INT 10
3235: PPUSH
3236: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3240: CALL_OW 44
3244: PPUSH
3245: LD_VAR 0 5
3249: PPUSH
3250: CALL_OW 52
// end ; end ;
3254: LD_VAR 0 1
3258: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers , amount ;
3259: LD_INT 47
3261: PPUSH
3262: CALL_OW 302
3266: PUSH
3267: LD_EXP 6
3271: AND
3272: IFFALSE 3961
3274: GO 3276
3276: DISABLE
3277: LD_INT 0
3279: PPUSH
3280: PPUSH
3281: PPUSH
3282: PPUSH
3283: PPUSH
3284: PPUSH
3285: PPUSH
// begin enable ;
3286: ENABLE
// base := 2 ;
3287: LD_ADDR_VAR 0 2
3291: PUSH
3292: LD_INT 2
3294: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3295: LD_ADDR_VAR 0 4
3299: PUSH
3300: LD_INT 0
3302: PUSH
3303: LD_INT 0
3305: PUSH
3306: LD_INT 0
3308: PUSH
3309: LD_INT 0
3311: PUSH
3312: LD_INT 0
3314: PUSH
3315: LD_INT 0
3317: PUSH
3318: LD_INT 0
3320: PUSH
3321: LD_INT 0
3323: PUSH
3324: LD_INT 1
3326: PUSH
3327: LD_INT 0
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: LIST
3334: LIST
3335: LIST
3336: LIST
3337: LIST
3338: LIST
3339: LIST
3340: LIST
3341: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 22
3349: PUSH
3350: LD_INT 1
3352: PUSH
3353: LD_INT 3
3355: PUSH
3356: LD_INT 45
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: LIST
3364: PUSH
3365: LD_INT 21
3367: PUSH
3368: LD_INT 1
3370: PUSH
3371: LD_INT 3
3373: PUSH
3374: LD_INT 45
3376: PUSH
3377: EMPTY
3378: LIST
3379: LIST
3380: LIST
3381: LIST
3382: PUSH
3383: LD_INT 22
3385: PUSH
3386: LD_INT 1
3388: PUSH
3389: LD_INT 3
3391: PUSH
3392: LD_INT 45
3394: PUSH
3395: EMPTY
3396: LIST
3397: LIST
3398: LIST
3399: LIST
3400: PUSH
3401: LD_INT 23
3403: PUSH
3404: LD_INT 1
3406: PUSH
3407: LD_INT 3
3409: PUSH
3410: LD_INT 46
3412: PUSH
3413: EMPTY
3414: LIST
3415: LIST
3416: LIST
3417: LIST
3418: PUSH
3419: EMPTY
3420: LIST
3421: LIST
3422: LIST
3423: LIST
3424: ST_TO_ADDR
// amount := Difficulty ;
3425: LD_ADDR_VAR 0 7
3429: PUSH
3430: LD_OWVAR 67
3434: ST_TO_ADDR
// if tick > 30 30$00 then
3435: LD_OWVAR 1
3439: PUSH
3440: LD_INT 63000
3442: GREATER
3443: IFFALSE 3480
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3445: LD_ADDR_VAR 0 7
3449: PUSH
3450: LD_VAR 0 7
3454: PUSH
3455: LD_INT 2
3457: PUSH
3458: LD_INT 3
3460: PUSH
3461: LD_INT 4
3463: PUSH
3464: LD_INT 4
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: PUSH
3473: LD_OWVAR 67
3477: ARRAY
3478: PLUS
3479: ST_TO_ADDR
// for i = 1 to amount do
3480: LD_ADDR_VAR 0 1
3484: PUSH
3485: DOUBLE
3486: LD_INT 1
3488: DEC
3489: ST_TO_ADDR
3490: LD_VAR 0 7
3494: PUSH
3495: FOR_TO
3496: IFFALSE 3584
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3498: LD_ADDR_VAR 0 3
3502: PUSH
3503: LD_VAR 0 3
3507: PPUSH
3508: LD_VAR 0 3
3512: PUSH
3513: LD_INT 1
3515: PLUS
3516: PPUSH
3517: LD_INT 23
3519: PUSH
3520: LD_INT 24
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: LD_INT 1
3529: PPUSH
3530: LD_INT 2
3532: PPUSH
3533: CALL_OW 12
3537: ARRAY
3538: PUSH
3539: LD_INT 1
3541: PUSH
3542: LD_INT 3
3544: PUSH
3545: LD_INT 46
3547: PUSH
3548: LD_INT 47
3550: PUSH
3551: LD_INT 45
3553: PUSH
3554: EMPTY
3555: LIST
3556: LIST
3557: LIST
3558: PUSH
3559: LD_INT 1
3561: PPUSH
3562: LD_INT 3
3564: PPUSH
3565: CALL_OW 12
3569: ARRAY
3570: PUSH
3571: EMPTY
3572: LIST
3573: LIST
3574: LIST
3575: LIST
3576: PPUSH
3577: CALL_OW 2
3581: ST_TO_ADDR
3582: GO 3495
3584: POP
3585: POP
// MC_InsertProduceList ( base , tmp ) ;
3586: LD_VAR 0 2
3590: PPUSH
3591: LD_VAR 0 3
3595: PPUSH
3596: CALL 80300 0 2
// repeat wait ( 0 0$1 ) ;
3600: LD_INT 35
3602: PPUSH
3603: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= amount ;
3607: LD_VAR 0 2
3611: PPUSH
3612: LD_INT 1
3614: PPUSH
3615: CALL 81718 0 2
3619: PUSH
3620: LD_VAR 0 7
3624: GREATEREQUAL
3625: IFFALSE 3600
// wait ( 0 0$30 ) ;
3627: LD_INT 1050
3629: PPUSH
3630: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3634: LD_ADDR_VAR 0 5
3638: PUSH
3639: LD_INT 71
3641: PUSH
3642: LD_INT 19
3644: PUSH
3645: EMPTY
3646: LIST
3647: LIST
3648: PUSH
3649: LD_INT 91
3651: PUSH
3652: LD_INT 67
3654: PUSH
3655: EMPTY
3656: LIST
3657: LIST
3658: PUSH
3659: LD_INT 52
3661: PUSH
3662: LD_INT 44
3664: PUSH
3665: EMPTY
3666: LIST
3667: LIST
3668: PUSH
3669: LD_INT 68
3671: PUSH
3672: LD_INT 48
3674: PUSH
3675: EMPTY
3676: LIST
3677: LIST
3678: PUSH
3679: EMPTY
3680: LIST
3681: LIST
3682: LIST
3683: LIST
3684: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3685: LD_ADDR_VAR 0 6
3689: PUSH
3690: LD_EXP 79
3694: PUSH
3695: LD_VAR 0 2
3699: ARRAY
3700: PUSH
3701: LD_EXP 79
3705: PUSH
3706: LD_VAR 0 2
3710: ARRAY
3711: PPUSH
3712: LD_INT 2
3714: PUSH
3715: LD_INT 34
3717: PUSH
3718: LD_INT 51
3720: PUSH
3721: EMPTY
3722: LIST
3723: LIST
3724: PUSH
3725: LD_INT 34
3727: PUSH
3728: LD_INT 52
3730: PUSH
3731: EMPTY
3732: LIST
3733: LIST
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PPUSH
3740: CALL_OW 72
3744: DIFF
3745: ST_TO_ADDR
// if not attackers then
3746: LD_VAR 0 6
3750: NOT
3751: IFFALSE 3755
// exit ;
3753: GO 3961
// ru_attackers := attackers ;
3755: LD_ADDR_EXP 53
3759: PUSH
3760: LD_VAR 0 6
3764: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3765: LD_ADDR_EXP 79
3769: PUSH
3770: LD_EXP 79
3774: PPUSH
3775: LD_VAR 0 2
3779: PPUSH
3780: LD_EXP 79
3784: PUSH
3785: LD_VAR 0 2
3789: ARRAY
3790: PUSH
3791: LD_VAR 0 6
3795: DIFF
3796: PPUSH
3797: CALL_OW 1
3801: ST_TO_ADDR
// for i = 1 to attackers do
3802: LD_ADDR_VAR 0 1
3806: PUSH
3807: DOUBLE
3808: LD_INT 1
3810: DEC
3811: ST_TO_ADDR
3812: LD_VAR 0 6
3816: PUSH
3817: FOR_TO
3818: IFFALSE 3895
// begin case i mod 3 of 0 :
3820: LD_VAR 0 1
3824: PUSH
3825: LD_INT 3
3827: MOD
3828: PUSH
3829: LD_INT 0
3831: DOUBLE
3832: EQUAL
3833: IFTRUE 3837
3835: GO 3840
3837: POP
// ; 1 :
3838: GO 3893
3840: LD_INT 1
3842: DOUBLE
3843: EQUAL
3844: IFTRUE 3848
3846: GO 3866
3848: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3849: LD_VAR 0 1
3853: PPUSH
3854: LD_INT 32
3856: PPUSH
3857: LD_INT 49
3859: PPUSH
3860: CALL_OW 114
3864: GO 3893
3866: LD_INT 2
3868: DOUBLE
3869: EQUAL
3870: IFTRUE 3874
3872: GO 3892
3874: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3875: LD_VAR 0 1
3879: PPUSH
3880: LD_INT 117
3882: PPUSH
3883: LD_INT 107
3885: PPUSH
3886: CALL_OW 114
3890: GO 3893
3892: POP
// end ;
3893: GO 3817
3895: POP
3896: POP
// repeat wait ( 0 0$1 ) ;
3897: LD_INT 35
3899: PPUSH
3900: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3904: LD_VAR 0 6
3908: PPUSH
3909: LD_INT 60
3911: PUSH
3912: EMPTY
3913: LIST
3914: PPUSH
3915: CALL_OW 72
3919: NOT
3920: IFFALSE 3897
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3922: LD_VAR 0 2
3926: PPUSH
3927: LD_VAR 0 6
3931: PPUSH
3932: LD_VAR 0 5
3936: PPUSH
3937: LD_VAR 0 4
3941: PPUSH
3942: CALL 80485 0 4
// if not first_attack then
3946: LD_EXP 7
3950: NOT
3951: IFFALSE 3961
// first_attack := true ;
3953: LD_ADDR_EXP 7
3957: PUSH
3958: LD_INT 1
3960: ST_TO_ADDR
// end ; end_of_file
3961: PPOPN 7
3963: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3964: LD_INT 0
3966: PPUSH
3967: PPUSH
3968: PPUSH
3969: PPUSH
3970: PPUSH
3971: PPUSH
3972: PPUSH
// uc_side := 2 ;
3973: LD_ADDR_OWVAR 20
3977: PUSH
3978: LD_INT 2
3980: ST_TO_ADDR
// uc_nation := 2 ;
3981: LD_ADDR_OWVAR 21
3985: PUSH
3986: LD_INT 2
3988: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3989: LD_ADDR_EXP 56
3993: PUSH
3994: LD_STRING Abdul
3996: PPUSH
3997: CALL_OW 25
4001: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4002: LD_EXP 56
4006: PPUSH
4007: LD_INT 11
4009: PPUSH
4010: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4014: LD_EXP 56
4018: PPUSH
4019: LD_INT 1
4021: PPUSH
4022: CALL_OW 52
// vc_chassis := 31 ;
4026: LD_ADDR_OWVAR 37
4030: PUSH
4031: LD_INT 31
4033: ST_TO_ADDR
// vc_control := control_rider ;
4034: LD_ADDR_OWVAR 38
4038: PUSH
4039: LD_INT 4
4041: ST_TO_ADDR
// mastodont := CreateVehicle ;
4042: LD_ADDR_EXP 57
4046: PUSH
4047: CALL_OW 45
4051: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4052: LD_EXP 57
4056: PPUSH
4057: LD_INT 153
4059: PPUSH
4060: LD_INT 71
4062: PPUSH
4063: LD_INT 0
4065: PPUSH
4066: CALL_OW 48
// InitVc ;
4070: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4074: LD_ADDR_EXP 54
4078: PUSH
4079: LD_INT 1
4081: PPUSH
4082: LD_INT 3
4084: PPUSH
4085: LD_STRING 
4087: PPUSH
4088: LD_INT 7
4090: PUSH
4091: LD_INT 8
4093: PUSH
4094: LD_INT 9
4096: PUSH
4097: LD_INT 10
4099: PUSH
4100: EMPTY
4101: LIST
4102: LIST
4103: LIST
4104: LIST
4105: PUSH
4106: LD_OWVAR 67
4110: ARRAY
4111: PPUSH
4112: LD_INT 5000
4114: PUSH
4115: LD_INT 1000
4117: PUSH
4118: LD_INT 300
4120: PUSH
4121: EMPTY
4122: LIST
4123: LIST
4124: LIST
4125: PPUSH
4126: LD_INT 18
4128: PUSH
4129: LD_INT 5
4131: PUSH
4132: LD_INT 6
4134: PUSH
4135: LD_INT 9
4137: PUSH
4138: EMPTY
4139: LIST
4140: LIST
4141: LIST
4142: LIST
4143: PPUSH
4144: CALL 23327 0 6
4148: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4149: LD_ADDR_EXP 60
4153: PUSH
4154: LD_EXP 60
4158: PPUSH
4159: LD_INT 1
4161: PPUSH
4162: LD_EXP 54
4166: PPUSH
4167: CALL_OW 1
4171: ST_TO_ADDR
// tmp := [ ] ;
4172: LD_ADDR_VAR 0 4
4176: PUSH
4177: EMPTY
4178: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
4179: LD_ADDR_OWVAR 37
4183: PUSH
4184: LD_INT 14
4186: ST_TO_ADDR
// vc_engine := engine_siberite ;
4187: LD_ADDR_OWVAR 39
4191: PUSH
4192: LD_INT 3
4194: ST_TO_ADDR
// vc_control := control_manual ;
4195: LD_ADDR_OWVAR 38
4199: PUSH
4200: LD_INT 1
4202: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4203: LD_ADDR_OWVAR 40
4207: PUSH
4208: LD_INT 31
4210: ST_TO_ADDR
// for i = 1 to 3 do
4211: LD_ADDR_VAR 0 2
4215: PUSH
4216: DOUBLE
4217: LD_INT 1
4219: DEC
4220: ST_TO_ADDR
4221: LD_INT 3
4223: PUSH
4224: FOR_TO
4225: IFFALSE 4473
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4227: LD_ADDR_VAR 0 5
4231: PUSH
4232: LD_INT 153
4234: PUSH
4235: LD_INT 71
4237: PUSH
4238: EMPTY
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 155
4244: PUSH
4245: LD_INT 81
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: PUSH
4252: EMPTY
4253: LIST
4254: LIST
4255: PUSH
4256: LD_VAR 0 2
4260: PUSH
4261: LD_INT 2
4263: MOD
4264: PUSH
4265: LD_INT 1
4267: PLUS
4268: ARRAY
4269: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4270: LD_INT 0
4272: PPUSH
4273: LD_INT 3
4275: PPUSH
4276: LD_INT 7
4278: PUSH
4279: LD_INT 8
4281: PUSH
4282: LD_INT 10
4284: PUSH
4285: LD_INT 10
4287: PUSH
4288: EMPTY
4289: LIST
4290: LIST
4291: LIST
4292: LIST
4293: PUSH
4294: LD_OWVAR 67
4298: ARRAY
4299: PPUSH
4300: CALL_OW 380
// un := CreateVehicle ;
4304: LD_ADDR_VAR 0 6
4308: PUSH
4309: CALL_OW 45
4313: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4314: LD_VAR 0 6
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: LD_INT 5
4324: PPUSH
4325: CALL_OW 12
4329: PPUSH
4330: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4334: LD_VAR 0 6
4338: PPUSH
4339: LD_VAR 0 5
4343: PUSH
4344: LD_INT 1
4346: ARRAY
4347: PPUSH
4348: LD_VAR 0 5
4352: PUSH
4353: LD_INT 2
4355: ARRAY
4356: PPUSH
4357: LD_INT 6
4359: PPUSH
4360: LD_INT 0
4362: PPUSH
4363: CALL_OW 50
// un2 := CreateHuman ;
4367: LD_ADDR_VAR 0 7
4371: PUSH
4372: CALL_OW 44
4376: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4377: LD_VAR 0 7
4381: PPUSH
4382: LD_VAR 0 6
4386: PPUSH
4387: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4391: LD_ADDR_EXP 60
4395: PUSH
4396: LD_EXP 60
4400: PPUSH
4401: LD_INT 1
4403: PUSH
4404: LD_EXP 60
4408: PUSH
4409: LD_INT 1
4411: ARRAY
4412: PUSH
4413: LD_INT 1
4415: PLUS
4416: PUSH
4417: EMPTY
4418: LIST
4419: LIST
4420: PPUSH
4421: LD_VAR 0 6
4425: PPUSH
4426: CALL 20003 0 3
4430: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4431: LD_ADDR_EXP 60
4435: PUSH
4436: LD_EXP 60
4440: PPUSH
4441: LD_INT 1
4443: PUSH
4444: LD_EXP 60
4448: PUSH
4449: LD_INT 1
4451: ARRAY
4452: PUSH
4453: LD_INT 1
4455: PLUS
4456: PUSH
4457: EMPTY
4458: LIST
4459: LIST
4460: PPUSH
4461: LD_VAR 0 7
4465: PPUSH
4466: CALL 20003 0 3
4470: ST_TO_ADDR
// end ;
4471: GO 4224
4473: POP
4474: POP
// for i = 1 to 5 do
4475: LD_ADDR_VAR 0 2
4479: PUSH
4480: DOUBLE
4481: LD_INT 1
4483: DEC
4484: ST_TO_ADDR
4485: LD_INT 5
4487: PUSH
4488: FOR_TO
4489: IFFALSE 4582
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4491: LD_INT 14
4493: PPUSH
4494: LD_INT 3
4496: PPUSH
4497: LD_INT 1
4499: PPUSH
4500: LD_INT 25
4502: PUSH
4503: LD_INT 28
4505: PUSH
4506: LD_INT 28
4508: PUSH
4509: LD_INT 26
4511: PUSH
4512: EMPTY
4513: LIST
4514: LIST
4515: LIST
4516: LIST
4517: PUSH
4518: LD_VAR 0 2
4522: PUSH
4523: LD_INT 4
4525: MOD
4526: PUSH
4527: LD_INT 1
4529: PLUS
4530: ARRAY
4531: PPUSH
4532: LD_INT 100
4534: PPUSH
4535: CALL 19881 0 5
// veh := CreateVehicle ;
4539: LD_ADDR_VAR 0 3
4543: PUSH
4544: CALL_OW 45
4548: ST_TO_ADDR
// tmp := tmp ^ veh ;
4549: LD_ADDR_VAR 0 4
4553: PUSH
4554: LD_VAR 0 4
4558: PUSH
4559: LD_VAR 0 3
4563: ADD
4564: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4565: LD_VAR 0 3
4569: PPUSH
4570: LD_INT 1
4572: PPUSH
4573: LD_INT 0
4575: PPUSH
4576: CALL_OW 49
// end ;
4580: GO 4488
4582: POP
4583: POP
// arabian_guard := tmp ;
4584: LD_ADDR_EXP 55
4588: PUSH
4589: LD_VAR 0 4
4593: ST_TO_ADDR
// end ;
4594: LD_VAR 0 1
4598: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4599: LD_INT 22
4601: PUSH
4602: LD_INT 7
4604: PUSH
4605: EMPTY
4606: LIST
4607: LIST
4608: PUSH
4609: LD_INT 91
4611: PUSH
4612: LD_INT 1
4614: PUSH
4615: LD_INT 12
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: LIST
4622: PUSH
4623: EMPTY
4624: LIST
4625: LIST
4626: PPUSH
4627: CALL_OW 69
4631: PUSH
4632: LD_EXP 57
4636: PPUSH
4637: CALL_OW 256
4641: PUSH
4642: LD_INT 990
4644: LESS
4645: OR
4646: PUSH
4647: LD_EXP 56
4651: PPUSH
4652: CALL_OW 256
4656: PUSH
4657: LD_INT 990
4659: LESS
4660: OR
4661: IFFALSE 4804
4663: GO 4665
4665: DISABLE
// begin if IsInUnit ( Abdul ) then
4666: LD_EXP 56
4670: PPUSH
4671: CALL_OW 310
4675: IFFALSE 4686
// ComExitBuilding ( Abdul ) ;
4677: LD_EXP 56
4681: PPUSH
4682: CALL_OW 122
// if Mastodont then
4686: LD_EXP 57
4690: IFFALSE 4707
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4692: LD_EXP 57
4696: PPUSH
4697: LD_INT 205
4699: PPUSH
4700: LD_INT 132
4702: PPUSH
4703: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4707: LD_EXP 56
4711: PPUSH
4712: LD_INT 205
4714: PPUSH
4715: LD_INT 132
4717: PPUSH
4718: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4722: LD_INT 35
4724: PPUSH
4725: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4729: LD_EXP 56
4733: PPUSH
4734: LD_INT 21
4736: PPUSH
4737: CALL_OW 308
4741: IFFALSE 4722
// RemoveUnit ( Abdul ) ;
4743: LD_EXP 56
4747: PPUSH
4748: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4752: LD_INT 35
4754: PPUSH
4755: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4759: LD_EXP 57
4763: PPUSH
4764: LD_INT 21
4766: PPUSH
4767: CALL_OW 308
4771: PUSH
4772: LD_EXP 57
4776: PPUSH
4777: CALL_OW 301
4781: OR
4782: IFFALSE 4752
// if IsOk ( Mastodont ) then
4784: LD_EXP 57
4788: PPUSH
4789: CALL_OW 302
4793: IFFALSE 4804
// RemoveUnit ( Mastodont ) ;
4795: LD_EXP 57
4799: PPUSH
4800: CALL_OW 64
// end ;
4804: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4805: LD_EXP 56
4809: PPUSH
4810: CALL_OW 301
4814: PUSH
4815: LD_INT 22
4817: PUSH
4818: LD_INT 2
4820: PUSH
4821: EMPTY
4822: LIST
4823: LIST
4824: PUSH
4825: LD_INT 2
4827: PUSH
4828: LD_INT 25
4830: PUSH
4831: LD_INT 1
4833: PUSH
4834: EMPTY
4835: LIST
4836: LIST
4837: PUSH
4838: LD_INT 25
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 25
4850: PUSH
4851: LD_INT 3
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 25
4860: PUSH
4861: LD_INT 4
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: LD_INT 25
4870: PUSH
4871: LD_INT 8
4873: PUSH
4874: EMPTY
4875: LIST
4876: LIST
4877: PUSH
4878: EMPTY
4879: LIST
4880: LIST
4881: LIST
4882: LIST
4883: LIST
4884: LIST
4885: PUSH
4886: EMPTY
4887: LIST
4888: LIST
4889: PPUSH
4890: CALL_OW 69
4894: PUSH
4895: LD_INT 16
4897: PUSH
4898: LD_INT 19
4900: PUSH
4901: LD_INT 22
4903: PUSH
4904: LD_INT 22
4906: PUSH
4907: EMPTY
4908: LIST
4909: LIST
4910: LIST
4911: LIST
4912: PUSH
4913: LD_OWVAR 67
4917: ARRAY
4918: LESS
4919: OR
4920: IFFALSE 5593
4922: GO 4924
4924: DISABLE
4925: LD_INT 0
4927: PPUSH
4928: PPUSH
4929: PPUSH
4930: PPUSH
4931: PPUSH
4932: PPUSH
// begin MC_Kill ( 1 ) ;
4933: LD_INT 1
4935: PPUSH
4936: CALL 56322 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4940: LD_ADDR_VAR 0 2
4944: PUSH
4945: LD_INT 22
4947: PUSH
4948: LD_INT 2
4950: PUSH
4951: EMPTY
4952: LIST
4953: LIST
4954: PUSH
4955: LD_INT 2
4957: PUSH
4958: LD_INT 25
4960: PUSH
4961: LD_INT 1
4963: PUSH
4964: EMPTY
4965: LIST
4966: LIST
4967: PUSH
4968: LD_INT 25
4970: PUSH
4971: LD_INT 2
4973: PUSH
4974: EMPTY
4975: LIST
4976: LIST
4977: PUSH
4978: LD_INT 25
4980: PUSH
4981: LD_INT 3
4983: PUSH
4984: EMPTY
4985: LIST
4986: LIST
4987: PUSH
4988: LD_INT 25
4990: PUSH
4991: LD_INT 4
4993: PUSH
4994: EMPTY
4995: LIST
4996: LIST
4997: PUSH
4998: LD_INT 25
5000: PUSH
5001: LD_INT 8
5003: PUSH
5004: EMPTY
5005: LIST
5006: LIST
5007: PUSH
5008: EMPTY
5009: LIST
5010: LIST
5011: LIST
5012: LIST
5013: LIST
5014: LIST
5015: PUSH
5016: EMPTY
5017: LIST
5018: LIST
5019: PPUSH
5020: CALL_OW 69
5024: ST_TO_ADDR
// for i in tmp do
5025: LD_ADDR_VAR 0 5
5029: PUSH
5030: LD_VAR 0 2
5034: PUSH
5035: FOR_IN
5036: IFFALSE 5052
// SetTag ( i , 10 ) ;
5038: LD_VAR 0 5
5042: PPUSH
5043: LD_INT 10
5045: PPUSH
5046: CALL_OW 109
5050: GO 5035
5052: POP
5053: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5054: LD_ADDR_VAR 0 3
5058: PUSH
5059: LD_INT 22
5061: PUSH
5062: LD_INT 2
5064: PUSH
5065: EMPTY
5066: LIST
5067: LIST
5068: PUSH
5069: LD_INT 21
5071: PUSH
5072: LD_INT 1
5074: PUSH
5075: EMPTY
5076: LIST
5077: LIST
5078: PUSH
5079: EMPTY
5080: LIST
5081: LIST
5082: PPUSH
5083: CALL_OW 69
5087: PUSH
5088: LD_VAR 0 2
5092: DIFF
5093: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5094: LD_ADDR_VAR 0 1
5098: PUSH
5099: LD_INT 22
5101: PUSH
5102: LD_INT 2
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 21
5111: PUSH
5112: LD_INT 2
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 24
5121: PUSH
5122: LD_INT 300
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: PPUSH
5134: CALL_OW 69
5138: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5139: LD_ADDR_VAR 0 4
5143: PUSH
5144: LD_VAR 0 1
5148: PPUSH
5149: LD_INT 33
5151: PUSH
5152: LD_INT 1
5154: PUSH
5155: EMPTY
5156: LIST
5157: LIST
5158: PUSH
5159: LD_INT 58
5161: PUSH
5162: EMPTY
5163: LIST
5164: PUSH
5165: EMPTY
5166: LIST
5167: LIST
5168: PPUSH
5169: CALL_OW 72
5173: ST_TO_ADDR
// for i in tmp do
5174: LD_ADDR_VAR 0 5
5178: PUSH
5179: LD_VAR 0 2
5183: PUSH
5184: FOR_IN
5185: IFFALSE 5369
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5187: LD_VAR 0 5
5191: PUSH
5192: LD_INT 55
5194: PUSH
5195: EMPTY
5196: LIST
5197: PPUSH
5198: CALL_OW 69
5202: IN
5203: IFFALSE 5222
// begin AddComMoveXY ( i , 209 , 132 ) ;
5205: LD_VAR 0 5
5209: PPUSH
5210: LD_INT 209
5212: PPUSH
5213: LD_INT 132
5215: PPUSH
5216: CALL_OW 171
// continue ;
5220: GO 5184
// end ; if IsInUnit ( i ) then
5222: LD_VAR 0 5
5226: PPUSH
5227: CALL_OW 310
5231: IFFALSE 5249
// begin ComExitBuilding ( i ) ;
5233: LD_VAR 0 5
5237: PPUSH
5238: CALL_OW 122
// wait ( 3 ) ;
5242: LD_INT 3
5244: PPUSH
5245: CALL_OW 67
// end ; if tmp_empty then
5249: LD_VAR 0 4
5253: IFFALSE 5352
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5255: LD_VAR 0 5
5259: PPUSH
5260: LD_VAR 0 4
5264: PPUSH
5265: LD_VAR 0 5
5269: PPUSH
5270: CALL_OW 74
5274: PPUSH
5275: CALL_OW 296
5279: PUSH
5280: LD_INT 25
5282: LESS
5283: IFFALSE 5352
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5285: LD_ADDR_VAR 0 6
5289: PUSH
5290: LD_VAR 0 4
5294: PPUSH
5295: LD_VAR 0 5
5299: PPUSH
5300: CALL_OW 74
5304: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5305: LD_VAR 0 5
5309: PPUSH
5310: LD_VAR 0 6
5314: PPUSH
5315: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5319: LD_VAR 0 5
5323: PPUSH
5324: LD_INT 209
5326: PPUSH
5327: LD_INT 132
5329: PPUSH
5330: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5334: LD_ADDR_VAR 0 4
5338: PUSH
5339: LD_VAR 0 4
5343: PUSH
5344: LD_VAR 0 6
5348: DIFF
5349: ST_TO_ADDR
// continue ;
5350: GO 5184
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5352: LD_VAR 0 5
5356: PPUSH
5357: LD_INT 201
5359: PPUSH
5360: LD_INT 132
5362: PPUSH
5363: CALL_OW 171
// end ;
5367: GO 5184
5369: POP
5370: POP
// for i in tmp_ape do
5371: LD_ADDR_VAR 0 5
5375: PUSH
5376: LD_VAR 0 3
5380: PUSH
5381: FOR_IN
5382: IFFALSE 5421
// begin if IsInUnit ( i ) then
5384: LD_VAR 0 5
5388: PPUSH
5389: CALL_OW 310
5393: IFFALSE 5404
// ComExitBuilding ( i ) ;
5395: LD_VAR 0 5
5399: PPUSH
5400: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5404: LD_VAR 0 5
5408: PPUSH
5409: LD_INT 201
5411: PPUSH
5412: LD_INT 132
5414: PPUSH
5415: CALL_OW 171
// end ;
5419: GO 5381
5421: POP
5422: POP
// repeat wait ( 0 0$1 ) ;
5423: LD_INT 35
5425: PPUSH
5426: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5430: LD_ADDR_VAR 0 5
5434: PUSH
5435: LD_VAR 0 2
5439: PUSH
5440: LD_VAR 0 3
5444: UNION
5445: PUSH
5446: LD_VAR 0 1
5450: UNION
5451: PUSH
5452: FOR_IN
5453: IFFALSE 5484
// if not HasTask ( i ) then
5455: LD_VAR 0 5
5459: PPUSH
5460: CALL_OW 314
5464: NOT
5465: IFFALSE 5482
// ComMoveXY ( i , 201 , 132 ) ;
5467: LD_VAR 0 5
5471: PPUSH
5472: LD_INT 201
5474: PPUSH
5475: LD_INT 132
5477: PPUSH
5478: CALL_OW 111
5482: GO 5452
5484: POP
5485: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5486: LD_INT 21
5488: PPUSH
5489: LD_INT 22
5491: PUSH
5492: LD_INT 2
5494: PUSH
5495: EMPTY
5496: LIST
5497: LIST
5498: PPUSH
5499: CALL_OW 70
5503: IFFALSE 5544
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5505: LD_ADDR_VAR 0 5
5509: PUSH
5510: LD_INT 21
5512: PPUSH
5513: LD_INT 22
5515: PUSH
5516: LD_INT 2
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PPUSH
5523: CALL_OW 70
5527: PUSH
5528: FOR_IN
5529: IFFALSE 5542
// RemoveUnit ( i ) ;
5531: LD_VAR 0 5
5535: PPUSH
5536: CALL_OW 64
5540: GO 5528
5542: POP
5543: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5544: LD_INT 22
5546: PUSH
5547: LD_INT 2
5549: PUSH
5550: EMPTY
5551: LIST
5552: LIST
5553: PUSH
5554: LD_INT 2
5556: PUSH
5557: LD_INT 21
5559: PUSH
5560: LD_INT 1
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: PUSH
5567: LD_INT 21
5569: PUSH
5570: LD_INT 2
5572: PUSH
5573: EMPTY
5574: LIST
5575: LIST
5576: PUSH
5577: EMPTY
5578: LIST
5579: LIST
5580: LIST
5581: PUSH
5582: EMPTY
5583: LIST
5584: LIST
5585: PPUSH
5586: CALL_OW 69
5590: NOT
5591: IFFALSE 5423
// end ;
5593: PPOPN 6
5595: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5596: LD_EXP 9
5600: PUSH
5601: LD_INT 92
5603: PPUSH
5604: LD_INT 40
5606: PPUSH
5607: CALL_OW 428
5611: PPUSH
5612: CALL_OW 266
5616: PUSH
5617: LD_INT 30
5619: EQUAL
5620: AND
5621: IFFALSE 5817
5623: GO 5625
5625: DISABLE
5626: LD_INT 0
5628: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5629: LD_ADDR_VAR 0 1
5633: PUSH
5634: LD_EXP 60
5638: PUSH
5639: LD_INT 1
5641: ARRAY
5642: PPUSH
5643: LD_INT 25
5645: PUSH
5646: LD_INT 4
5648: PUSH
5649: EMPTY
5650: LIST
5651: LIST
5652: PPUSH
5653: CALL_OW 72
5657: ST_TO_ADDR
// if not sci then
5658: LD_VAR 0 1
5662: NOT
5663: IFFALSE 5667
// exit ;
5665: GO 5817
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5667: LD_ADDR_EXP 60
5671: PUSH
5672: LD_EXP 60
5676: PPUSH
5677: LD_INT 1
5679: PPUSH
5680: LD_EXP 60
5684: PUSH
5685: LD_INT 1
5687: ARRAY
5688: PUSH
5689: LD_VAR 0 1
5693: PUSH
5694: LD_INT 1
5696: ARRAY
5697: DIFF
5698: PPUSH
5699: CALL_OW 1
5703: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5704: LD_VAR 0 1
5708: PUSH
5709: LD_INT 1
5711: ARRAY
5712: PPUSH
5713: CALL_OW 310
5717: IFFALSE 5732
// ComExitBuilding ( sci [ 1 ] ) ;
5719: LD_VAR 0 1
5723: PUSH
5724: LD_INT 1
5726: ARRAY
5727: PPUSH
5728: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5732: LD_INT 2
5734: PPUSH
5735: LD_INT 105
5737: PPUSH
5738: LD_INT 14
5740: PPUSH
5741: LD_INT 20
5743: PPUSH
5744: CALL 20899 0 4
5748: PUSH
5749: LD_INT 4
5751: ARRAY
5752: PUSH
5753: LD_INT 10
5755: LESS
5756: IFFALSE 5779
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5758: LD_VAR 0 1
5762: PUSH
5763: LD_INT 1
5765: ARRAY
5766: PPUSH
5767: LD_INT 105
5769: PPUSH
5770: LD_INT 14
5772: PPUSH
5773: CALL_OW 171
5777: GO 5798
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5779: LD_VAR 0 1
5783: PUSH
5784: LD_INT 1
5786: ARRAY
5787: PPUSH
5788: LD_INT 118
5790: PPUSH
5791: LD_INT 77
5793: PPUSH
5794: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5798: LD_VAR 0 1
5802: PUSH
5803: LD_INT 1
5805: ARRAY
5806: PPUSH
5807: LD_INT 92
5809: PPUSH
5810: LD_INT 40
5812: PPUSH
5813: CALL_OW 218
// end ;
5817: PPOPN 1
5819: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5820: LD_INT 1
5822: PPUSH
5823: CALL_OW 302
5827: PUSH
5828: LD_EXP 9
5832: AND
5833: IFFALSE 6312
5835: GO 5837
5837: DISABLE
5838: LD_INT 0
5840: PPUSH
5841: PPUSH
5842: PPUSH
5843: PPUSH
5844: PPUSH
5845: PPUSH
// begin enable ;
5846: ENABLE
// base := 1 ;
5847: LD_ADDR_VAR 0 2
5851: PUSH
5852: LD_INT 1
5854: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5855: LD_ADDR_VAR 0 4
5859: PUSH
5860: LD_INT 0
5862: PUSH
5863: LD_INT 0
5865: PUSH
5866: LD_INT 0
5868: PUSH
5869: LD_INT 0
5871: PUSH
5872: LD_INT 0
5874: PUSH
5875: LD_INT 0
5877: PUSH
5878: LD_INT 0
5880: PUSH
5881: LD_INT 0
5883: PUSH
5884: LD_INT 1
5886: PUSH
5887: LD_INT 0
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: LIST
5894: LIST
5895: LIST
5896: LIST
5897: LIST
5898: LIST
5899: LIST
5900: LIST
5901: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5902: LD_ADDR_VAR 0 3
5906: PUSH
5907: LD_INT 14
5909: PUSH
5910: LD_INT 1
5912: PUSH
5913: LD_INT 2
5915: PUSH
5916: LD_INT 26
5918: PUSH
5919: EMPTY
5920: LIST
5921: LIST
5922: LIST
5923: LIST
5924: PUSH
5925: LD_INT 14
5927: PUSH
5928: LD_INT 1
5930: PUSH
5931: LD_INT 2
5933: PUSH
5934: LD_INT 28
5936: PUSH
5937: EMPTY
5938: LIST
5939: LIST
5940: LIST
5941: LIST
5942: PUSH
5943: LD_INT 13
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 29
5954: PUSH
5955: EMPTY
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: PUSH
5961: EMPTY
5962: LIST
5963: LIST
5964: LIST
5965: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5966: LD_ADDR_VAR 0 1
5970: PUSH
5971: DOUBLE
5972: LD_INT 1
5974: DEC
5975: ST_TO_ADDR
5976: LD_OWVAR 67
5980: PUSH
5981: LD_OWVAR 1
5985: PUSH
5986: LD_INT 21000
5988: DIV
5989: PLUS
5990: PUSH
5991: FOR_TO
5992: IFFALSE 6084
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5994: LD_ADDR_VAR 0 3
5998: PUSH
5999: LD_VAR 0 3
6003: PPUSH
6004: LD_VAR 0 3
6008: PUSH
6009: LD_INT 1
6011: PLUS
6012: PPUSH
6013: LD_INT 13
6015: PUSH
6016: LD_INT 14
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 1
6025: PPUSH
6026: LD_INT 2
6028: PPUSH
6029: CALL_OW 12
6033: ARRAY
6034: PUSH
6035: LD_INT 1
6037: PUSH
6038: LD_INT 2
6040: PUSH
6041: LD_INT 28
6043: PUSH
6044: LD_INT 29
6046: PUSH
6047: LD_INT 25
6049: PUSH
6050: LD_INT 26
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: LD_INT 1
6061: PPUSH
6062: LD_INT 4
6064: PPUSH
6065: CALL_OW 12
6069: ARRAY
6070: PUSH
6071: EMPTY
6072: LIST
6073: LIST
6074: LIST
6075: LIST
6076: PPUSH
6077: CALL_OW 2
6081: ST_TO_ADDR
6082: GO 5991
6084: POP
6085: POP
// MC_InsertProduceList ( base , tmp ) ;
6086: LD_VAR 0 2
6090: PPUSH
6091: LD_VAR 0 3
6095: PPUSH
6096: CALL 80300 0 2
// repeat wait ( 0 0$1 ) ;
6100: LD_INT 35
6102: PPUSH
6103: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
6107: LD_EXP 79
6111: PUSH
6112: LD_VAR 0 2
6116: ARRAY
6117: PUSH
6118: LD_INT 6
6120: GREATER
6121: IFFALSE 6100
// wait ( 0 0$20 ) ;
6123: LD_INT 700
6125: PPUSH
6126: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6130: LD_ADDR_VAR 0 5
6134: PUSH
6135: LD_INT 124
6137: PUSH
6138: LD_INT 85
6140: PUSH
6141: EMPTY
6142: LIST
6143: LIST
6144: PUSH
6145: LD_INT 90
6147: PUSH
6148: LD_INT 61
6150: PUSH
6151: EMPTY
6152: LIST
6153: LIST
6154: PUSH
6155: LD_INT 69
6157: PUSH
6158: LD_INT 48
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PUSH
6165: LD_INT 68
6167: PUSH
6168: LD_INT 48
6170: PUSH
6171: EMPTY
6172: LIST
6173: LIST
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6181: LD_ADDR_VAR 0 6
6185: PUSH
6186: LD_EXP 79
6190: PUSH
6191: LD_VAR 0 2
6195: ARRAY
6196: PUSH
6197: LD_EXP 79
6201: PUSH
6202: LD_VAR 0 2
6206: ARRAY
6207: PPUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 34
6213: PUSH
6214: LD_INT 32
6216: PUSH
6217: EMPTY
6218: LIST
6219: LIST
6220: PUSH
6221: LD_INT 34
6223: PUSH
6224: LD_EXP 110
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PUSH
6233: EMPTY
6234: LIST
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6312
// ar_attackers := attackers ;
6253: LD_ADDR_EXP 11
6257: PUSH
6258: LD_VAR 0 6
6262: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6263: LD_INT 35
6265: PPUSH
6266: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6270: LD_VAR 0 6
6274: PPUSH
6275: LD_INT 60
6277: PUSH
6278: EMPTY
6279: LIST
6280: PPUSH
6281: CALL_OW 72
6285: NOT
6286: IFFALSE 6263
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6288: LD_VAR 0 2
6292: PPUSH
6293: LD_VAR 0 6
6297: PPUSH
6298: LD_VAR 0 5
6302: PPUSH
6303: LD_VAR 0 4
6307: PPUSH
6308: CALL 80485 0 4
// end ;
6312: PPOPN 6
6314: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6315: LD_INT 1
6317: PPUSH
6318: CALL_OW 302
6322: PUSH
6323: LD_EXP 9
6327: AND
6328: PUSH
6329: LD_EXP 50
6333: PPUSH
6334: LD_INT 22
6336: PPUSH
6337: CALL_OW 308
6341: AND
6342: PUSH
6343: LD_INT 1
6345: PPUSH
6346: CALL 80648 0 1
6350: PUSH
6351: LD_INT 0
6353: EQUAL
6354: AND
6355: PUSH
6356: LD_EXP 11
6360: NOT
6361: AND
6362: IFFALSE 6850
6364: GO 6366
6366: DISABLE
6367: LD_INT 0
6369: PPUSH
6370: PPUSH
6371: PPUSH
6372: PPUSH
6373: PPUSH
6374: PPUSH
6375: PPUSH
// begin base := 1 ;
6376: LD_ADDR_VAR 0 2
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6384: LD_ADDR_VAR 0 4
6388: PUSH
6389: LD_INT 0
6391: PUSH
6392: LD_INT 0
6394: PUSH
6395: LD_INT 0
6397: PUSH
6398: LD_INT 0
6400: PUSH
6401: LD_INT 0
6403: PUSH
6404: LD_INT 0
6406: PUSH
6407: LD_INT 0
6409: PUSH
6410: LD_INT 0
6412: PUSH
6413: LD_INT 1
6415: PUSH
6416: LD_INT 0
6418: PUSH
6419: EMPTY
6420: LIST
6421: LIST
6422: LIST
6423: LIST
6424: LIST
6425: LIST
6426: LIST
6427: LIST
6428: LIST
6429: LIST
6430: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6431: LD_ADDR_VAR 0 3
6435: PUSH
6436: LD_INT 13
6438: PUSH
6439: LD_INT 1
6441: PUSH
6442: LD_INT 2
6444: PUSH
6445: LD_INT 28
6447: PUSH
6448: EMPTY
6449: LIST
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_INT 13
6456: PUSH
6457: LD_INT 1
6459: PUSH
6460: LD_INT 2
6462: PUSH
6463: LD_INT 27
6465: PUSH
6466: EMPTY
6467: LIST
6468: LIST
6469: LIST
6470: LIST
6471: PUSH
6472: LD_INT 13
6474: PUSH
6475: LD_INT 1
6477: PUSH
6478: LD_INT 2
6480: PUSH
6481: LD_INT 25
6483: PUSH
6484: EMPTY
6485: LIST
6486: LIST
6487: LIST
6488: LIST
6489: PUSH
6490: LD_INT 11
6492: PUSH
6493: LD_INT 2
6495: PUSH
6496: LD_INT 2
6498: PUSH
6499: LD_INT 24
6501: PUSH
6502: EMPTY
6503: LIST
6504: LIST
6505: LIST
6506: LIST
6507: PUSH
6508: LD_INT 11
6510: PUSH
6511: LD_INT 2
6513: PUSH
6514: LD_INT 2
6516: PUSH
6517: LD_INT 24
6519: PUSH
6520: EMPTY
6521: LIST
6522: LIST
6523: LIST
6524: LIST
6525: PUSH
6526: EMPTY
6527: LIST
6528: LIST
6529: LIST
6530: LIST
6531: LIST
6532: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6533: LD_VAR 0 2
6537: PPUSH
6538: LD_VAR 0 3
6542: PPUSH
6543: CALL 80300 0 2
// repeat wait ( 0 0$1 ) ;
6547: LD_INT 35
6549: PPUSH
6550: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6554: LD_EXP 79
6558: PUSH
6559: LD_VAR 0 2
6563: ARRAY
6564: PUSH
6565: LD_INT 6
6567: GREATEREQUAL
6568: IFFALSE 6547
// wait ( 0 0$20 ) ;
6570: LD_INT 700
6572: PPUSH
6573: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6577: LD_ADDR_VAR 0 5
6581: PUSH
6582: LD_INT 119
6584: PUSH
6585: LD_INT 9
6587: PUSH
6588: EMPTY
6589: LIST
6590: LIST
6591: PUSH
6592: EMPTY
6593: LIST
6594: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6595: LD_ADDR_VAR 0 6
6599: PUSH
6600: LD_EXP 79
6604: PUSH
6605: LD_VAR 0 2
6609: ARRAY
6610: PUSH
6611: LD_EXP 79
6615: PUSH
6616: LD_VAR 0 2
6620: ARRAY
6621: PPUSH
6622: LD_INT 2
6624: PUSH
6625: LD_INT 34
6627: PUSH
6628: LD_INT 32
6630: PUSH
6631: EMPTY
6632: LIST
6633: LIST
6634: PUSH
6635: LD_INT 34
6637: PUSH
6638: LD_EXP 110
6642: PUSH
6643: EMPTY
6644: LIST
6645: LIST
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: LIST
6651: PPUSH
6652: CALL_OW 72
6656: DIFF
6657: ST_TO_ADDR
// if not attackers then
6658: LD_VAR 0 6
6662: NOT
6663: IFFALSE 6667
// exit ;
6665: GO 6850
// uc_side := 2 ;
6667: LD_ADDR_OWVAR 20
6671: PUSH
6672: LD_INT 2
6674: ST_TO_ADDR
// uc_nation := 2 ;
6675: LD_ADDR_OWVAR 21
6679: PUSH
6680: LD_INT 2
6682: ST_TO_ADDR
// InitHc ;
6683: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
6687: LD_ADDR_VAR 0 1
6691: PUSH
6692: DOUBLE
6693: LD_INT 1
6695: DEC
6696: ST_TO_ADDR
6697: LD_INT 4
6699: PUSH
6700: LD_INT 5
6702: PUSH
6703: LD_INT 6
6705: PUSH
6706: LD_INT 6
6708: PUSH
6709: EMPTY
6710: LIST
6711: LIST
6712: LIST
6713: LIST
6714: PUSH
6715: LD_OWVAR 67
6719: ARRAY
6720: PUSH
6721: FOR_TO
6722: IFFALSE 6799
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6724: LD_INT 0
6726: PPUSH
6727: LD_INT 15
6729: PUSH
6730: LD_INT 17
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: PUSH
6737: LD_INT 1
6739: PPUSH
6740: LD_INT 2
6742: PPUSH
6743: CALL_OW 12
6747: ARRAY
6748: PPUSH
6749: LD_INT 8
6751: PPUSH
6752: CALL_OW 380
// un := CreateHuman ;
6756: LD_ADDR_VAR 0 7
6760: PUSH
6761: CALL_OW 44
6765: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6766: LD_VAR 0 7
6770: PPUSH
6771: LD_INT 23
6773: PPUSH
6774: LD_INT 0
6776: PPUSH
6777: CALL_OW 49
// attackers := attackers union un ;
6781: LD_ADDR_VAR 0 6
6785: PUSH
6786: LD_VAR 0 6
6790: PUSH
6791: LD_VAR 0 7
6795: UNION
6796: ST_TO_ADDR
// end ;
6797: GO 6721
6799: POP
6800: POP
// repeat wait ( 0 0$1 ) ;
6801: LD_INT 35
6803: PPUSH
6804: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6808: LD_VAR 0 6
6812: PPUSH
6813: LD_INT 60
6815: PUSH
6816: EMPTY
6817: LIST
6818: PPUSH
6819: CALL_OW 72
6823: NOT
6824: IFFALSE 6801
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6826: LD_VAR 0 2
6830: PPUSH
6831: LD_VAR 0 6
6835: PPUSH
6836: LD_VAR 0 5
6840: PPUSH
6841: LD_VAR 0 4
6845: PPUSH
6846: CALL 80485 0 4
// end ; end_of_file
6850: PPOPN 7
6852: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
6859: PPUSH
6860: PPUSH
// uc_side := 1 ;
6861: LD_ADDR_OWVAR 20
6865: PUSH
6866: LD_INT 1
6868: ST_TO_ADDR
// uc_nation := 1 ;
6869: LD_ADDR_OWVAR 21
6873: PUSH
6874: LD_INT 1
6876: ST_TO_ADDR
// InitHc ;
6877: CALL_OW 19
// InitVc ;
6881: CALL_OW 20
// tmp := [ ] ;
6885: LD_ADDR_VAR 0 3
6889: PUSH
6890: EMPTY
6891: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: DOUBLE
6898: LD_INT 1
6900: DEC
6901: ST_TO_ADDR
6902: LD_INT 6
6904: PUSH
6905: LD_INT 8
6907: PUSH
6908: LD_INT 10
6910: PUSH
6911: LD_INT 10
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PUSH
6920: LD_OWVAR 67
6924: ARRAY
6925: PUSH
6926: FOR_TO
6927: IFFALSE 7201
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
6929: LD_ADDR_VAR 0 5
6933: PUSH
6934: LD_INT 2
6936: PUSH
6937: LD_INT 4
6939: PUSH
6940: LD_INT 5
6942: PUSH
6943: EMPTY
6944: LIST
6945: LIST
6946: LIST
6947: PUSH
6948: LD_INT 1
6950: PPUSH
6951: LD_INT 3
6953: PPUSH
6954: CALL_OW 12
6958: ARRAY
6959: ST_TO_ADDR
// case chassis of us_medium_wheeled :
6960: LD_VAR 0 5
6964: PUSH
6965: LD_INT 2
6967: DOUBLE
6968: EQUAL
6969: IFTRUE 6973
6971: GO 7007
6973: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
6974: LD_ADDR_VAR 0 6
6978: PUSH
6979: LD_INT 9
6981: PUSH
6982: LD_INT 5
6984: PUSH
6985: LD_INT 7
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: LIST
6992: PUSH
6993: LD_INT 1
6995: PPUSH
6996: LD_INT 3
6998: PPUSH
6999: CALL_OW 12
7003: ARRAY
7004: ST_TO_ADDR
7005: GO 7096
7007: LD_INT 4
7009: DOUBLE
7010: EQUAL
7011: IFTRUE 7015
7013: GO 7053
7015: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7016: LD_ADDR_VAR 0 6
7020: PUSH
7021: LD_INT 9
7023: PUSH
7024: LD_INT 6
7026: PUSH
7027: LD_INT 6
7029: PUSH
7030: LD_INT 7
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: LIST
7038: PUSH
7039: LD_INT 1
7041: PPUSH
7042: LD_INT 4
7044: PPUSH
7045: CALL_OW 12
7049: ARRAY
7050: ST_TO_ADDR
7051: GO 7096
7053: LD_INT 5
7055: DOUBLE
7056: EQUAL
7057: IFTRUE 7061
7059: GO 7095
7061: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7062: LD_ADDR_VAR 0 6
7066: PUSH
7067: LD_INT 9
7069: PUSH
7070: LD_INT 6
7072: PUSH
7073: LD_INT 7
7075: PUSH
7076: EMPTY
7077: LIST
7078: LIST
7079: LIST
7080: PUSH
7081: LD_INT 1
7083: PPUSH
7084: LD_INT 3
7086: PPUSH
7087: CALL_OW 12
7091: ARRAY
7092: ST_TO_ADDR
7093: GO 7096
7095: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7096: LD_VAR 0 5
7100: PPUSH
7101: LD_INT 1
7103: PUSH
7104: LD_INT 3
7106: PUSH
7107: EMPTY
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 1
7113: PPUSH
7114: LD_INT 2
7116: PPUSH
7117: CALL_OW 12
7121: ARRAY
7122: PPUSH
7123: LD_INT 3
7125: PPUSH
7126: LD_VAR 0 6
7130: PPUSH
7131: LD_INT 70
7133: PPUSH
7134: LD_INT 90
7136: PPUSH
7137: CALL_OW 12
7141: PPUSH
7142: CALL 19881 0 5
// veh := CreateVehicle ;
7146: LD_ADDR_VAR 0 4
7150: PUSH
7151: CALL_OW 45
7155: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7156: LD_VAR 0 4
7160: PPUSH
7161: LD_INT 2
7163: PPUSH
7164: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7168: LD_VAR 0 4
7172: PPUSH
7173: LD_INT 17
7175: PPUSH
7176: LD_INT 0
7178: PPUSH
7179: CALL_OW 49
// tmp := tmp ^ veh ;
7183: LD_ADDR_VAR 0 3
7187: PUSH
7188: LD_VAR 0 3
7192: PUSH
7193: LD_VAR 0 4
7197: ADD
7198: ST_TO_ADDR
// end ;
7199: GO 6926
7201: POP
7202: POP
// if not tmp then
7203: LD_VAR 0 3
7207: NOT
7208: IFFALSE 7212
// exit ;
7210: GO 7321
// if not first_powell_attack then
7212: LD_EXP 12
7216: NOT
7217: IFFALSE 7227
// first_powell_attack := true ;
7219: LD_ADDR_EXP 12
7223: PUSH
7224: LD_INT 1
7226: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7227: LD_INT 70
7229: PPUSH
7230: CALL_OW 67
// for i in tmp do
7234: LD_ADDR_VAR 0 2
7238: PUSH
7239: LD_VAR 0 3
7243: PUSH
7244: FOR_IN
7245: IFFALSE 7312
// if IsOk ( i ) then
7247: LD_VAR 0 2
7251: PPUSH
7252: CALL_OW 302
7256: IFFALSE 7294
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 81
7265: PUSH
7266: LD_INT 1
7268: PUSH
7269: EMPTY
7270: LIST
7271: LIST
7272: PPUSH
7273: CALL_OW 69
7277: PPUSH
7278: LD_VAR 0 2
7282: PPUSH
7283: CALL_OW 74
7287: PPUSH
7288: CALL_OW 115
7292: GO 7310
// tmp := tmp diff i ;
7294: LD_ADDR_VAR 0 3
7298: PUSH
7299: LD_VAR 0 3
7303: PUSH
7304: LD_VAR 0 2
7308: DIFF
7309: ST_TO_ADDR
7310: GO 7244
7312: POP
7313: POP
// until not tmp ;
7314: LD_VAR 0 3
7318: NOT
7319: IFFALSE 7227
// end ; end_of_file
7321: LD_VAR 0 1
7325: RET
// export function Action ; var tmp , i , un ; begin
7326: LD_INT 0
7328: PPUSH
7329: PPUSH
7330: PPUSH
7331: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7332: LD_INT 68
7334: PPUSH
7335: LD_INT 39
7337: PPUSH
7338: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7342: LD_ADDR_VAR 0 2
7346: PUSH
7347: LD_INT 22
7349: PUSH
7350: LD_INT 7
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: PPUSH
7357: CALL_OW 69
7361: ST_TO_ADDR
// InGameOn ;
7362: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7366: LD_VAR 0 2
7370: PPUSH
7371: LD_INT 71
7373: PPUSH
7374: LD_INT 49
7376: PPUSH
7377: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7381: LD_INT 35
7383: PPUSH
7384: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7388: LD_INT 7
7390: PPUSH
7391: LD_INT 71
7393: PPUSH
7394: LD_INT 51
7396: PPUSH
7397: CALL_OW 293
7401: IFFALSE 7381
// DialogueOn ;
7403: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7407: LD_EXP 16
7411: PPUSH
7412: LD_STRING D1-JMM-1
7414: PPUSH
7415: CALL_OW 88
// if Joan then
7419: LD_EXP 31
7423: IFFALSE 7437
// Say ( Joan , D1-Joan-1 ) ;
7425: LD_EXP 31
7429: PPUSH
7430: LD_STRING D1-Joan-1
7432: PPUSH
7433: CALL_OW 88
// if Lisa then
7437: LD_EXP 18
7441: IFFALSE 7455
// Say ( Lisa , D1-Lisa-1 ) ;
7443: LD_EXP 18
7447: PPUSH
7448: LD_STRING D1-Lisa-1
7450: PPUSH
7451: CALL_OW 88
// if Joan or Lisa then
7455: LD_EXP 31
7459: PUSH
7460: LD_EXP 18
7464: OR
7465: IFFALSE 7479
// Say ( JMM , D1-JMM-2 ) ;
7467: LD_EXP 16
7471: PPUSH
7472: LD_STRING D1-JMM-2
7474: PPUSH
7475: CALL_OW 88
// DialogueOff ;
7479: CALL_OW 7
// InGameOff ;
7483: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7487: LD_INT 71
7489: PPUSH
7490: LD_INT 50
7492: PPUSH
7493: LD_INT 7
7495: PPUSH
7496: LD_INT 30
7498: NEG
7499: PPUSH
7500: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7504: LD_INT 71
7506: PPUSH
7507: LD_INT 50
7509: PPUSH
7510: LD_INT 7
7512: PPUSH
7513: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7517: LD_STRING M1
7519: PPUSH
7520: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7524: LD_INT 35
7526: PPUSH
7527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7531: LD_EXP 3
7535: PUSH
7536: LD_OWVAR 1
7540: PUSH
7541: LD_INT 2100
7543: GREATER
7544: OR
7545: IFFALSE 7524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7547: LD_INT 350
7549: PPUSH
7550: LD_INT 700
7552: PPUSH
7553: CALL_OW 12
7557: PPUSH
7558: CALL_OW 67
// PrepareGossudarov ;
7562: CALL 1881 0 0
// repeat wait ( 0 0$1 ) ;
7566: LD_INT 35
7568: PPUSH
7569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7573: LD_INT 22
7575: PUSH
7576: LD_INT 6
7578: PUSH
7579: EMPTY
7580: LIST
7581: LIST
7582: PUSH
7583: LD_INT 3
7585: PUSH
7586: LD_INT 24
7588: PUSH
7589: LD_INT 1000
7591: PUSH
7592: EMPTY
7593: LIST
7594: LIST
7595: PUSH
7596: EMPTY
7597: LIST
7598: LIST
7599: PUSH
7600: EMPTY
7601: LIST
7602: LIST
7603: PPUSH
7604: CALL_OW 69
7608: PUSH
7609: LD_INT 7
7611: PPUSH
7612: LD_EXP 33
7616: PPUSH
7617: CALL_OW 292
7621: OR
7622: IFFALSE 7566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7624: LD_ADDR_VAR 0 2
7628: PUSH
7629: LD_INT 22
7631: PUSH
7632: LD_INT 6
7634: PUSH
7635: EMPTY
7636: LIST
7637: LIST
7638: PPUSH
7639: CALL_OW 69
7643: ST_TO_ADDR
// for i in tmp do
7644: LD_ADDR_VAR 0 3
7648: PUSH
7649: LD_VAR 0 2
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7671
// SetSide ( i , 7 ) ;
7657: LD_VAR 0 3
7661: PPUSH
7662: LD_INT 7
7664: PPUSH
7665: CALL_OW 235
7669: GO 7654
7671: POP
7672: POP
// DialogueOn ;
7673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7677: LD_EXP 16
7681: PUSH
7682: LD_EXP 17
7686: PUSH
7687: EMPTY
7688: LIST
7689: LIST
7690: PPUSH
7691: LD_EXP 33
7695: PPUSH
7696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7700: LD_EXP 33
7704: PPUSH
7705: CALL_OW 87
// if not Roth then
7709: LD_EXP 17
7713: NOT
7714: IFFALSE 7806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7716: LD_VAR 0 2
7720: PPUSH
7721: LD_INT 3
7723: PUSH
7724: LD_INT 24
7726: PUSH
7727: LD_INT 1000
7729: PUSH
7730: EMPTY
7731: LIST
7732: LIST
7733: PUSH
7734: EMPTY
7735: LIST
7736: LIST
7737: PPUSH
7738: CALL_OW 72
7742: IFFALSE 7756
// Say ( JMM , D2-JMM-1 ) ;
7744: LD_EXP 16
7748: PPUSH
7749: LD_STRING D2-JMM-1
7751: PPUSH
7752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7756: LD_EXP 16
7760: PPUSH
7761: LD_STRING D2-JMM-1b
7763: PPUSH
7764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7768: LD_EXP 33
7772: PPUSH
7773: LD_STRING D2-Gos-1
7775: PPUSH
7776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7780: LD_EXP 16
7784: PPUSH
7785: LD_STRING D2-JMM-2
7787: PPUSH
7788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7792: LD_EXP 33
7796: PPUSH
7797: LD_STRING D2-Gos-2
7799: PPUSH
7800: CALL_OW 88
// end else
7804: GO 7958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7806: LD_VAR 0 2
7810: PPUSH
7811: LD_INT 3
7813: PUSH
7814: LD_INT 24
7816: PUSH
7817: LD_INT 1000
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: PPUSH
7828: CALL_OW 72
7832: IFFALSE 7858
// begin Say ( Roth , D2-Roth-2 ) ;
7834: LD_EXP 17
7838: PPUSH
7839: LD_STRING D2-Roth-2
7841: PPUSH
7842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7846: LD_EXP 16
7850: PPUSH
7851: LD_STRING D2-JMM-1a
7853: PPUSH
7854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7858: LD_EXP 17
7862: PPUSH
7863: LD_STRING D2-Roth-2a
7865: PPUSH
7866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7870: LD_EXP 17
7874: PPUSH
7875: LD_STRING D2-Roth-2b
7877: PPUSH
7878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7882: LD_EXP 16
7886: PPUSH
7887: LD_STRING D2-JMM-3
7889: PPUSH
7890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7894: LD_VAR 0 2
7898: PPUSH
7899: LD_INT 3
7901: PUSH
7902: LD_INT 24
7904: PUSH
7905: LD_INT 1000
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PUSH
7912: EMPTY
7913: LIST
7914: LIST
7915: PPUSH
7916: CALL_OW 72
7920: IFFALSE 7958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7922: LD_EXP 33
7926: PPUSH
7927: LD_STRING D2-Gos-3
7929: PPUSH
7930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7934: LD_EXP 16
7938: PPUSH
7939: LD_STRING D2-JMM-4
7941: PPUSH
7942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7946: LD_EXP 33
7950: PPUSH
7951: LD_STRING D2-Gos-4
7953: PPUSH
7954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7958: LD_EXP 16
7962: PPUSH
7963: LD_STRING D2-JMM-5
7965: PPUSH
7966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7970: LD_EXP 33
7974: PPUSH
7975: LD_STRING D2-Gos-5
7977: PPUSH
7978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7982: LD_EXP 16
7986: PPUSH
7987: LD_STRING D2-JMM-6
7989: PPUSH
7990: CALL_OW 88
// DialogueOff ;
7994: CALL_OW 7
// wait ( 0 0$2 ) ;
7998: LD_INT 70
8000: PPUSH
8001: CALL_OW 67
// if Kirilenkova then
8005: LD_EXP 34
8009: IFFALSE 8023
// Say ( Kirilenkova , D3-Kir-1 ) ;
8011: LD_EXP 34
8015: PPUSH
8016: LD_STRING D3-Kir-1
8018: PPUSH
8019: CALL_OW 88
// gossudarov_arrive := true ;
8023: LD_ADDR_EXP 4
8027: PUSH
8028: LD_INT 1
8030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8031: LD_INT 35
8033: PPUSH
8034: CALL_OW 67
// until ru_lab_builded ;
8038: LD_EXP 5
8042: IFFALSE 8031
// DialogueOn ;
8044: CALL_OW 6
// if Kirilenkova then
8048: LD_EXP 34
8052: IFFALSE 8068
// Say ( Kirilenkova , D3a-Kir-1 ) else
8054: LD_EXP 34
8058: PPUSH
8059: LD_STRING D3a-Kir-1
8061: PPUSH
8062: CALL_OW 88
8066: GO 8090
// begin un := SciRu ;
8068: LD_ADDR_VAR 0 4
8072: PUSH
8073: CALL 13248 0 0
8077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8078: LD_VAR 0 4
8082: PPUSH
8083: LD_STRING D3a-Sci1-1
8085: PPUSH
8086: CALL_OW 88
// end ; if Kirilenkova or un then
8090: LD_EXP 34
8094: PUSH
8095: LD_VAR 0 4
8099: OR
8100: IFFALSE 8114
// Say ( JMM , D3a-JMM-1 ) ;
8102: LD_EXP 16
8106: PPUSH
8107: LD_STRING D3a-JMM-1
8109: PPUSH
8110: CALL_OW 88
// DialogueOff ;
8114: CALL_OW 7
// end ;
8118: LD_VAR 0 1
8122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8123: LD_EXP 4
8127: PUSH
8128: LD_INT 22
8130: PUSH
8131: LD_INT 7
8133: PUSH
8134: EMPTY
8135: LIST
8136: LIST
8137: PUSH
8138: LD_INT 2
8140: PUSH
8141: LD_INT 25
8143: PUSH
8144: LD_INT 1
8146: PUSH
8147: EMPTY
8148: LIST
8149: LIST
8150: PUSH
8151: LD_INT 25
8153: PUSH
8154: LD_INT 2
8156: PUSH
8157: EMPTY
8158: LIST
8159: LIST
8160: PUSH
8161: LD_INT 25
8163: PUSH
8164: LD_INT 3
8166: PUSH
8167: EMPTY
8168: LIST
8169: LIST
8170: PUSH
8171: LD_INT 25
8173: PUSH
8174: LD_INT 4
8176: PUSH
8177: EMPTY
8178: LIST
8179: LIST
8180: PUSH
8181: LD_INT 25
8183: PUSH
8184: LD_INT 5
8186: PUSH
8187: EMPTY
8188: LIST
8189: LIST
8190: PUSH
8191: LD_INT 25
8193: PUSH
8194: LD_INT 8
8196: PUSH
8197: EMPTY
8198: LIST
8199: LIST
8200: PUSH
8201: LD_INT 25
8203: PUSH
8204: LD_INT 9
8206: PUSH
8207: EMPTY
8208: LIST
8209: LIST
8210: PUSH
8211: EMPTY
8212: LIST
8213: LIST
8214: LIST
8215: LIST
8216: LIST
8217: LIST
8218: LIST
8219: LIST
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PUSH
8230: LD_INT 7
8232: LESS
8233: AND
8234: IFFALSE 8246
8236: GO 8238
8238: DISABLE
// YouLost ( TooMany ) ;
8239: LD_STRING TooMany
8241: PPUSH
8242: CALL_OW 104
8246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8247: LD_EXP 33
8251: PPUSH
8252: CALL_OW 255
8256: PUSH
8257: LD_INT 7
8259: EQUAL
8260: IFFALSE 8477
8262: GO 8264
8264: DISABLE
8265: LD_INT 0
8267: PPUSH
8268: PPUSH
8269: PPUSH
// begin uc_side := 3 ;
8270: LD_ADDR_OWVAR 20
8274: PUSH
8275: LD_INT 3
8277: ST_TO_ADDR
// uc_nation := 3 ;
8278: LD_ADDR_OWVAR 21
8282: PUSH
8283: LD_INT 3
8285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8286: LD_INT 21
8288: PPUSH
8289: LD_INT 3
8291: PPUSH
8292: LD_INT 3
8294: PPUSH
8295: LD_INT 42
8297: PPUSH
8298: LD_INT 100
8300: PPUSH
8301: CALL 19881 0 5
// un := CreateVehicle ;
8305: LD_ADDR_VAR 0 3
8309: PUSH
8310: CALL_OW 45
8314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8315: LD_VAR 0 3
8319: PPUSH
8320: LD_INT 15
8322: PPUSH
8323: LD_INT 0
8325: PPUSH
8326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8330: LD_VAR 0 3
8334: PPUSH
8335: LD_INT 67
8337: PPUSH
8338: LD_INT 45
8340: PPUSH
8341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8345: LD_VAR 0 3
8349: PPUSH
8350: LD_INT 70
8352: PPUSH
8353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8357: LD_VAR 0 3
8361: PPUSH
8362: LD_INT 69
8364: PPUSH
8365: LD_INT 18
8367: PPUSH
8368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8372: LD_VAR 0 3
8376: PPUSH
8377: LD_INT 60
8379: PPUSH
8380: LD_INT 3
8382: PPUSH
8383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8387: LD_INT 35
8389: PPUSH
8390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8394: LD_VAR 0 3
8398: PPUSH
8399: CALL_OW 302
8403: NOT
8404: PUSH
8405: LD_VAR 0 3
8409: PPUSH
8410: LD_INT 17
8412: PPUSH
8413: CALL_OW 308
8417: OR
8418: PUSH
8419: LD_VAR 0 3
8423: PPUSH
8424: LD_INT 60
8426: PPUSH
8427: LD_INT 3
8429: PPUSH
8430: CALL_OW 307
8434: OR
8435: IFFALSE 8387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8437: LD_VAR 0 3
8441: PPUSH
8442: LD_INT 17
8444: PPUSH
8445: CALL_OW 308
8449: PUSH
8450: LD_VAR 0 3
8454: PPUSH
8455: LD_INT 60
8457: PPUSH
8458: LD_INT 3
8460: PPUSH
8461: CALL_OW 307
8465: OR
8466: IFFALSE 8477
// RemoveUnit ( un ) ;
8468: LD_VAR 0 3
8472: PPUSH
8473: CALL_OW 64
// end ;
8477: PPOPN 3
8479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8480: LD_EXP 4
8484: IFFALSE 8726
8486: GO 8488
8488: DISABLE
8489: LD_INT 0
8491: PPUSH
8492: PPUSH
8493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8494: LD_INT 70
8496: PPUSH
8497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8501: LD_ADDR_VAR 0 3
8505: PUSH
8506: LD_INT 22
8508: PUSH
8509: LD_INT 7
8511: PUSH
8512: EMPTY
8513: LIST
8514: LIST
8515: PUSH
8516: LD_INT 101
8518: PUSH
8519: LD_INT 3
8521: PUSH
8522: EMPTY
8523: LIST
8524: LIST
8525: PUSH
8526: EMPTY
8527: LIST
8528: LIST
8529: PPUSH
8530: CALL_OW 69
8534: ST_TO_ADDR
// until tmp ;
8535: LD_VAR 0 3
8539: IFFALSE 8494
// un := NearestUnitToUnit ( tmp , JMM ) ;
8541: LD_ADDR_VAR 0 2
8545: PUSH
8546: LD_VAR 0 3
8550: PPUSH
8551: LD_EXP 16
8555: PPUSH
8556: CALL_OW 74
8560: ST_TO_ADDR
// player_spotted := true ;
8561: LD_ADDR_EXP 6
8565: PUSH
8566: LD_INT 1
8568: ST_TO_ADDR
// tmp := SciRu ;
8569: LD_ADDR_VAR 0 3
8573: PUSH
8574: CALL 13248 0 0
8578: ST_TO_ADDR
// if not tmp then
8579: LD_VAR 0 3
8583: NOT
8584: IFFALSE 8596
// tmp := SolRu ;
8586: LD_ADDR_VAR 0 3
8590: PUSH
8591: CALL 13395 0 0
8595: ST_TO_ADDR
// DialogueOn ;
8596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8600: LD_VAR 0 2
8604: PPUSH
8605: CALL_OW 250
8609: PPUSH
8610: LD_VAR 0 2
8614: PPUSH
8615: CALL_OW 251
8619: PPUSH
8620: LD_INT 7
8622: PPUSH
8623: LD_INT 8
8625: NEG
8626: PPUSH
8627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8631: LD_VAR 0 2
8635: PPUSH
8636: CALL_OW 87
// if tmp then
8640: LD_VAR 0 3
8644: IFFALSE 8658
// Say ( tmp , D4-RSci1-1 ) ;
8646: LD_VAR 0 3
8650: PPUSH
8651: LD_STRING D4-RSci1-1
8653: PPUSH
8654: CALL_OW 88
// if Gossudarov then
8658: LD_EXP 33
8662: IFFALSE 8688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8664: LD_EXP 33
8668: PPUSH
8669: LD_STRING D4-Gos-1
8671: PPUSH
8672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8676: LD_EXP 16
8680: PPUSH
8681: LD_STRING D4-JMM-1
8683: PPUSH
8684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8688: LD_VAR 0 2
8692: PPUSH
8693: CALL_OW 250
8697: PPUSH
8698: LD_VAR 0 2
8702: PPUSH
8703: CALL_OW 251
8707: PPUSH
8708: LD_INT 7
8710: PPUSH
8711: CALL_OW 331
// DialogueOff ;
8715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8719: LD_STRING M5
8721: PPUSH
8722: CALL_OW 337
// end ;
8726: PPOPN 3
8728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8729: LD_EXP 6
8733: IFFALSE 9326
8735: GO 8737
8737: DISABLE
8738: LD_INT 0
8740: PPUSH
8741: PPUSH
8742: PPUSH
// begin PrepareBelkov ;
8743: CALL 2194 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8747: LD_EXP 48
8751: PPUSH
8752: LD_INT 118
8754: PPUSH
8755: LD_INT 106
8757: PPUSH
8758: CALL_OW 111
// AddComHold ( Belkov ) ;
8762: LD_EXP 48
8766: PPUSH
8767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8771: LD_INT 35
8773: PPUSH
8774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8778: LD_EXP 48
8782: PPUSH
8783: LD_INT 118
8785: PPUSH
8786: LD_INT 106
8788: PPUSH
8789: CALL_OW 307
8793: IFFALSE 8771
// ChangeSideFog ( 4 , 7 ) ;
8795: LD_INT 4
8797: PPUSH
8798: LD_INT 7
8800: PPUSH
8801: CALL_OW 343
// if IsOk ( Belkov ) then
8805: LD_EXP 48
8809: PPUSH
8810: CALL_OW 302
8814: IFFALSE 8898
// begin InGameOn ;
8816: CALL_OW 8
// DialogueOn ;
8820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8824: LD_EXP 48
8828: PPUSH
8829: LD_STRING D5-Bel-1
8831: PPUSH
8832: CALL_OW 94
// if Gossudarov then
8836: LD_EXP 33
8840: IFFALSE 8890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8842: LD_EXP 33
8846: PPUSH
8847: LD_STRING D5-Gos-1
8849: PPUSH
8850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8854: LD_EXP 16
8858: PPUSH
8859: LD_STRING D5-JMM-1
8861: PPUSH
8862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8866: LD_EXP 33
8870: PPUSH
8871: LD_STRING D5-Gos-2
8873: PPUSH
8874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8878: LD_EXP 16
8882: PPUSH
8883: LD_STRING D5-JMM-2
8885: PPUSH
8886: CALL_OW 88
// end ; DialogueOff ;
8890: CALL_OW 7
// InGameOff ;
8894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8898: LD_STRING QSaveBelkov
8900: PPUSH
8901: CALL_OW 97
8905: PUSH
8906: LD_INT 1
8908: DOUBLE
8909: EQUAL
8910: IFTRUE 8914
8912: GO 8964
8914: POP
// begin DialogueOn ;
8915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8919: LD_EXP 16
8923: PPUSH
8924: LD_STRING D5a-JMM-1
8926: PPUSH
8927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8931: LD_EXP 48
8935: PPUSH
8936: LD_STRING D5a-Bel-1
8938: PPUSH
8939: CALL_OW 94
// DialogueOff ;
8943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8947: LD_EXP 48
8951: PPUSH
8952: LD_INT 83
8954: PPUSH
8955: LD_INT 49
8957: PPUSH
8958: CALL_OW 111
// end ; 2 :
8962: GO 8997
8964: LD_INT 2
8966: DOUBLE
8967: EQUAL
8968: IFTRUE 8972
8970: GO 8996
8972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8973: LD_EXP 16
8977: PPUSH
8978: LD_STRING D5a-JMM-2
8980: PPUSH
8981: CALL_OW 88
// ComHold ( Belkov ) ;
8985: LD_EXP 48
8989: PPUSH
8990: CALL_OW 140
// end ; end ;
8994: GO 8997
8996: POP
// time := 0 0$00 ;
8997: LD_ADDR_VAR 0 1
9001: PUSH
9002: LD_INT 0
9004: ST_TO_ADDR
// vehSpawned := false ;
9005: LD_ADDR_VAR 0 3
9009: PUSH
9010: LD_INT 0
9012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9013: LD_INT 35
9015: PPUSH
9016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9020: LD_VAR 0 1
9024: PUSH
9025: LD_INT 350
9027: PUSH
9028: LD_INT 175
9030: PUSH
9031: LD_INT 105
9033: PUSH
9034: LD_INT 70
9036: PUSH
9037: EMPTY
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: PUSH
9043: LD_OWVAR 67
9047: ARRAY
9048: GREATEREQUAL
9049: PUSH
9050: LD_VAR 0 3
9054: NOT
9055: AND
9056: IFFALSE 9146
// begin vehSpawned := true ;
9058: LD_ADDR_VAR 0 3
9062: PUSH
9063: LD_INT 1
9065: ST_TO_ADDR
// uc_side := 3 ;
9066: LD_ADDR_OWVAR 20
9070: PUSH
9071: LD_INT 3
9073: ST_TO_ADDR
// uc_nation := 3 ;
9074: LD_ADDR_OWVAR 21
9078: PUSH
9079: LD_INT 3
9081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9082: LD_INT 22
9084: PPUSH
9085: LD_INT 3
9087: PPUSH
9088: LD_INT 3
9090: PPUSH
9091: LD_INT 43
9093: PPUSH
9094: LD_INT 100
9096: PPUSH
9097: CALL 19881 0 5
// veh := CreateVehicle ;
9101: LD_ADDR_VAR 0 2
9105: PUSH
9106: CALL_OW 45
9110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9111: LD_VAR 0 2
9115: PPUSH
9116: LD_INT 130
9118: PPUSH
9119: LD_INT 131
9121: PPUSH
9122: LD_INT 0
9124: PPUSH
9125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9129: LD_VAR 0 2
9133: PPUSH
9134: LD_INT 100
9136: PPUSH
9137: LD_INT 82
9139: PPUSH
9140: CALL_OW 114
// end else
9144: GO 9160
// time := time + 0 0$1 ;
9146: LD_ADDR_VAR 0 1
9150: PUSH
9151: LD_VAR 0 1
9155: PUSH
9156: LD_INT 35
9158: PLUS
9159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9160: LD_EXP 48
9164: PPUSH
9165: CALL_OW 301
9169: PUSH
9170: LD_EXP 48
9174: PPUSH
9175: CALL_OW 255
9179: PUSH
9180: LD_INT 4
9182: EQUAL
9183: AND
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PPUSH
9200: LD_EXP 48
9204: PPUSH
9205: CALL_OW 74
9209: PPUSH
9210: LD_EXP 48
9214: PPUSH
9215: CALL_OW 296
9219: PUSH
9220: LD_INT 10
9222: LESS
9223: OR
9224: IFFALSE 9013
// if IsDead ( Belkov ) then
9226: LD_EXP 48
9230: PPUSH
9231: CALL_OW 301
9235: IFFALSE 9260
// begin CenterNowOnUnits ( Belkov ) ;
9237: LD_EXP 48
9241: PPUSH
9242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9246: LD_EXP 16
9250: PPUSH
9251: LD_STRING D5a-JMM-2a
9253: PPUSH
9254: CALL_OW 88
// exit ;
9258: GO 9326
// end ; if See ( 7 , Belkov ) then
9260: LD_INT 7
9262: PPUSH
9263: LD_EXP 48
9267: PPUSH
9268: CALL_OW 292
9272: IFFALSE 9286
// SetSide ( Belkov , 7 ) ;
9274: LD_EXP 48
9278: PPUSH
9279: LD_INT 7
9281: PPUSH
9282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9286: LD_INT 35
9288: PPUSH
9289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9293: LD_EXP 48
9297: PPUSH
9298: LD_INT 66
9300: PPUSH
9301: LD_INT 45
9303: PPUSH
9304: CALL_OW 297
9308: PUSH
9309: LD_INT 30
9311: LESS
9312: IFFALSE 9286
// Say ( Belkov , D6-Bel-1 ) ;
9314: LD_EXP 48
9318: PPUSH
9319: LD_STRING D6-Bel-1
9321: PPUSH
9322: CALL_OW 88
// end ;
9326: PPOPN 3
9328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9329: LD_EXP 48
9333: PPUSH
9334: CALL_OW 302
9338: PUSH
9339: LD_EXP 48
9343: PPUSH
9344: CALL_OW 504
9348: PUSH
9349: LD_INT 2
9351: PUSH
9352: LD_INT 34
9354: PUSH
9355: LD_INT 47
9357: PUSH
9358: EMPTY
9359: LIST
9360: LIST
9361: PUSH
9362: LD_INT 34
9364: PUSH
9365: LD_INT 45
9367: PUSH
9368: EMPTY
9369: LIST
9370: LIST
9371: PUSH
9372: EMPTY
9373: LIST
9374: LIST
9375: LIST
9376: PPUSH
9377: CALL_OW 69
9381: IN
9382: AND
9383: IFFALSE 9400
9385: GO 9387
9387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9388: LD_EXP 48
9392: PPUSH
9393: LD_STRING D7-Bel-1
9395: PPUSH
9396: CALL_OW 88
9400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9401: LD_INT 22
9403: PUSH
9404: LD_INT 7
9406: PUSH
9407: EMPTY
9408: LIST
9409: LIST
9410: PUSH
9411: LD_INT 101
9413: PUSH
9414: LD_INT 2
9416: PUSH
9417: EMPTY
9418: LIST
9419: LIST
9420: PUSH
9421: EMPTY
9422: LIST
9423: LIST
9424: PPUSH
9425: CALL_OW 69
9429: PUSH
9430: LD_EXP 8
9434: NOT
9435: AND
9436: PUSH
9437: LD_EXP 47
9441: PPUSH
9442: CALL_OW 305
9446: NOT
9447: AND
9448: IFFALSE 9918
9450: GO 9452
9452: DISABLE
9453: LD_INT 0
9455: PPUSH
// begin ar_base_spotted := true ;
9456: LD_ADDR_EXP 8
9460: PUSH
9461: LD_INT 1
9463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9464: LD_ADDR_VAR 0 1
9468: PUSH
9469: LD_INT 22
9471: PUSH
9472: LD_INT 2
9474: PUSH
9475: EMPTY
9476: LIST
9477: LIST
9478: PUSH
9479: LD_INT 21
9481: PUSH
9482: LD_INT 3
9484: PUSH
9485: EMPTY
9486: LIST
9487: LIST
9488: PUSH
9489: EMPTY
9490: LIST
9491: LIST
9492: PPUSH
9493: CALL_OW 69
9497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9498: LD_ADDR_VAR 0 1
9502: PUSH
9503: LD_VAR 0 1
9507: PPUSH
9508: LD_EXP 16
9512: PPUSH
9513: CALL_OW 74
9517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9518: LD_INT 7
9520: PPUSH
9521: LD_INT 3
9523: PPUSH
9524: CALL_OW 332
// DialogueOn ;
9528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9532: LD_VAR 0 1
9536: PPUSH
9537: CALL_OW 250
9541: PPUSH
9542: LD_VAR 0 1
9546: PPUSH
9547: CALL_OW 251
9551: PPUSH
9552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_INT 22
9563: PUSH
9564: LD_INT 7
9566: PUSH
9567: EMPTY
9568: LIST
9569: LIST
9570: PUSH
9571: LD_INT 23
9573: PUSH
9574: LD_INT 1
9576: PUSH
9577: EMPTY
9578: LIST
9579: LIST
9580: PUSH
9581: LD_INT 26
9583: PUSH
9584: LD_INT 1
9586: PUSH
9587: EMPTY
9588: LIST
9589: LIST
9590: PUSH
9591: EMPTY
9592: LIST
9593: LIST
9594: LIST
9595: PPUSH
9596: CALL_OW 69
9600: PUSH
9601: LD_EXP 16
9605: PUSH
9606: LD_EXP 20
9610: PUSH
9611: LD_EXP 21
9615: PUSH
9616: LD_EXP 28
9620: PUSH
9621: LD_EXP 17
9625: PUSH
9626: LD_EXP 26
9630: PUSH
9631: LD_EXP 22
9635: PUSH
9636: LD_EXP 24
9640: PUSH
9641: EMPTY
9642: LIST
9643: LIST
9644: LIST
9645: LIST
9646: LIST
9647: LIST
9648: LIST
9649: LIST
9650: DIFF
9651: ST_TO_ADDR
// if not tmp then
9652: LD_VAR 0 1
9656: NOT
9657: IFFALSE 9731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9659: LD_ADDR_VAR 0 1
9663: PUSH
9664: LD_INT 22
9666: PUSH
9667: LD_INT 7
9669: PUSH
9670: EMPTY
9671: LIST
9672: LIST
9673: PUSH
9674: LD_INT 23
9676: PUSH
9677: LD_INT 1
9679: PUSH
9680: EMPTY
9681: LIST
9682: LIST
9683: PUSH
9684: LD_INT 26
9686: PUSH
9687: LD_INT 2
9689: PUSH
9690: EMPTY
9691: LIST
9692: LIST
9693: PUSH
9694: EMPTY
9695: LIST
9696: LIST
9697: LIST
9698: PPUSH
9699: CALL_OW 69
9703: PUSH
9704: LD_EXP 31
9708: PUSH
9709: LD_EXP 18
9713: PUSH
9714: LD_EXP 29
9718: PUSH
9719: LD_EXP 30
9723: PUSH
9724: EMPTY
9725: LIST
9726: LIST
9727: LIST
9728: LIST
9729: DIFF
9730: ST_TO_ADDR
// if tmp then
9731: LD_VAR 0 1
9735: IFFALSE 9806
// case GetSex ( tmp [ 1 ] ) of sex_male :
9737: LD_VAR 0 1
9741: PUSH
9742: LD_INT 1
9744: ARRAY
9745: PPUSH
9746: CALL_OW 258
9750: PUSH
9751: LD_INT 1
9753: DOUBLE
9754: EQUAL
9755: IFTRUE 9759
9757: GO 9778
9759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9760: LD_VAR 0 1
9764: PUSH
9765: LD_INT 1
9767: ARRAY
9768: PPUSH
9769: LD_STRING D9-Sol1-1
9771: PPUSH
9772: CALL_OW 88
9776: GO 9806
9778: LD_INT 2
9780: DOUBLE
9781: EQUAL
9782: IFTRUE 9786
9784: GO 9805
9786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9787: LD_VAR 0 1
9791: PUSH
9792: LD_INT 1
9794: ARRAY
9795: PPUSH
9796: LD_STRING D9-FSol1-1
9798: PPUSH
9799: CALL_OW 88
9803: GO 9806
9805: POP
// if Frank then
9806: LD_EXP 28
9810: IFFALSE 9914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9812: LD_EXP 57
9816: PPUSH
9817: CALL_OW 250
9821: PPUSH
9822: LD_EXP 57
9826: PPUSH
9827: CALL_OW 251
9831: PPUSH
9832: LD_INT 7
9834: PPUSH
9835: LD_INT 8
9837: PPUSH
9838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9842: LD_EXP 57
9846: PPUSH
9847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9851: LD_EXP 28
9855: PPUSH
9856: LD_STRING D9-Frank-1
9858: PPUSH
9859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9863: LD_EXP 16
9867: PPUSH
9868: LD_STRING D9-JMM-1
9870: PPUSH
9871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9875: LD_EXP 28
9879: PPUSH
9880: LD_STRING D9-Frank-2
9882: PPUSH
9883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9887: LD_EXP 57
9891: PPUSH
9892: CALL_OW 250
9896: PPUSH
9897: LD_EXP 57
9901: PPUSH
9902: CALL_OW 251
9906: PPUSH
9907: LD_INT 7
9909: PPUSH
9910: CALL_OW 331
// end ; DialogueOff ;
9914: CALL_OW 7
// end ;
9918: PPOPN 1
9920: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9921: LD_EXP 7
9925: PUSH
9926: LD_OWVAR 1
9930: PUSH
9931: LD_INT 42000
9933: GREATEREQUAL
9934: OR
9935: IFFALSE 10962
9937: GO 9939
9939: DISABLE
9940: LD_INT 0
9942: PPUSH
9943: PPUSH
// begin selected_option := 1 ;
9944: LD_ADDR_VAR 0 2
9948: PUSH
9949: LD_INT 1
9951: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9952: LD_INT 10500
9954: PPUSH
9955: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9959: LD_INT 35
9961: PPUSH
9962: CALL_OW 67
// until not ru_attackers ;
9966: LD_EXP 53
9970: NOT
9971: IFFALSE 9959
// PrepareBurlak ;
9973: CALL 2306 0 0
// repeat wait ( 0 0$2 ) ;
9977: LD_INT 70
9979: PPUSH
9980: CALL_OW 67
// until not HasTask ( Burlak ) ;
9984: LD_EXP 47
9988: PPUSH
9989: CALL_OW 314
9993: NOT
9994: IFFALSE 9977
// InGameOn ;
9996: CALL_OW 8
// DialogueOn ;
10000: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10004: LD_EXP 50
10008: PPUSH
10009: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10013: LD_EXP 47
10017: PPUSH
10018: LD_STRING D10-Bur-1
10020: PPUSH
10021: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10025: LD_EXP 48
10029: PUSH
10030: LD_EXP 48
10034: PPUSH
10035: CALL_OW 255
10039: PUSH
10040: LD_INT 7
10042: EQUAL
10043: AND
10044: IFFALSE 10058
// Say ( Belkov , D10-Bel-1 ) ;
10046: LD_EXP 48
10050: PPUSH
10051: LD_STRING D10-Bel-1
10053: PPUSH
10054: CALL_OW 88
// if Gossudarov then
10058: LD_EXP 33
10062: IFFALSE 10076
// Say ( Gossudarov , D10-Gos-1 ) ;
10064: LD_EXP 33
10068: PPUSH
10069: LD_STRING D10-Gos-1
10071: PPUSH
10072: CALL_OW 88
// if Kirilenkova then
10076: LD_EXP 34
10080: IFFALSE 10094
// Say ( Kirilenkova , D10-Kir-1 ) ;
10082: LD_EXP 34
10086: PPUSH
10087: LD_STRING D10-Kir-1
10089: PPUSH
10090: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10094: CALL 13395 0 0
10098: PPUSH
10099: LD_STRING D10-RSol1-1
10101: PPUSH
10102: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10106: LD_EXP 47
10110: PPUSH
10111: LD_STRING D10-Bur-2
10113: PPUSH
10114: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10118: LD_EXP 16
10122: PPUSH
10123: LD_STRING D10-JMM-2
10125: PPUSH
10126: CALL_OW 88
// if Kirilenkova then
10130: LD_EXP 34
10134: IFFALSE 10150
// Say ( Kirilenkova , D10-Kir-2 ) else
10136: LD_EXP 34
10140: PPUSH
10141: LD_STRING D10-Kir-2
10143: PPUSH
10144: CALL_OW 88
10148: GO 10162
// Say ( SolRu , D10-RSol1-2 ) ;
10150: CALL 13395 0 0
10154: PPUSH
10155: LD_STRING D10-RSol1-2
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10162: LD_EXP 16
10166: PPUSH
10167: LD_STRING D10-JMM-3
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10174: LD_EXP 47
10178: PPUSH
10179: LD_STRING D10-Bur-3
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10186: LD_EXP 16
10190: PPUSH
10191: LD_STRING D10-JMM-4
10193: PPUSH
10194: CALL_OW 88
// DialogueOff ;
10198: CALL_OW 7
// InGameOff ;
10202: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10206: LD_STRING M2
10208: PPUSH
10209: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10213: LD_INT 35
10215: PPUSH
10216: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10220: LD_INT 22
10222: PUSH
10223: LD_INT 7
10225: PUSH
10226: EMPTY
10227: LIST
10228: LIST
10229: PUSH
10230: LD_INT 91
10232: PUSH
10233: LD_EXP 47
10237: PUSH
10238: LD_INT 8
10240: PUSH
10241: EMPTY
10242: LIST
10243: LIST
10244: LIST
10245: PUSH
10246: EMPTY
10247: LIST
10248: LIST
10249: PPUSH
10250: CALL_OW 69
10254: IFFALSE 10213
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10256: LD_ADDR_VAR 0 1
10260: PUSH
10261: LD_INT 22
10263: PUSH
10264: LD_INT 4
10266: PUSH
10267: EMPTY
10268: LIST
10269: LIST
10270: PPUSH
10271: CALL_OW 69
10275: PUSH
10276: FOR_IN
10277: IFFALSE 10293
// SetSide ( i , 7 ) ;
10279: LD_VAR 0 1
10283: PPUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 235
10291: GO 10276
10293: POP
10294: POP
// ChangeMissionObjectives ( M3 ) ;
10295: LD_STRING M3
10297: PPUSH
10298: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10302: LD_INT 35
10304: PPUSH
10305: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10309: LD_EXP 16
10313: PPUSH
10314: LD_EXP 47
10318: PPUSH
10319: CALL_OW 296
10323: PUSH
10324: LD_INT 8
10326: LESS
10327: IFFALSE 10302
// ComTurnUnit ( JMM , Burlak ) ;
10329: LD_EXP 16
10333: PPUSH
10334: LD_EXP 47
10338: PPUSH
10339: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10343: LD_EXP 47
10347: PPUSH
10348: LD_EXP 16
10352: PPUSH
10353: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10357: LD_INT 10
10359: PPUSH
10360: CALL_OW 67
// DialogueOn ;
10364: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10368: LD_EXP 16
10372: PPUSH
10373: LD_STRING D11-JMM-1
10375: PPUSH
10376: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10380: LD_EXP 47
10384: PPUSH
10385: LD_STRING D11-Bur-1
10387: PPUSH
10388: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10392: LD_EXP 16
10396: PPUSH
10397: LD_STRING D11-JMM-2
10399: PPUSH
10400: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10404: LD_EXP 47
10408: PPUSH
10409: LD_STRING D11-Bur-2
10411: PPUSH
10412: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10416: LD_EXP 16
10420: PPUSH
10421: LD_STRING D11-JMM-3
10423: PPUSH
10424: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10428: LD_EXP 47
10432: PPUSH
10433: LD_STRING D11-Bur-3
10435: PPUSH
10436: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10440: LD_EXP 16
10444: PPUSH
10445: LD_STRING D11-JMM-4
10447: PPUSH
10448: CALL_OW 88
// if ar_base_spotted then
10452: LD_EXP 8
10456: IFFALSE 10472
// Say ( Burlak , D12-Bur-1 ) else
10458: LD_EXP 47
10462: PPUSH
10463: LD_STRING D12-Bur-1
10465: PPUSH
10466: CALL_OW 88
10470: GO 10511
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10472: LD_INT 7
10474: PPUSH
10475: LD_INT 3
10477: PPUSH
10478: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10482: LD_INT 127
10484: PPUSH
10485: LD_INT 45
10487: PPUSH
10488: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10492: LD_EXP 47
10496: PPUSH
10497: LD_STRING D12-Bur-1a
10499: PPUSH
10500: CALL_OW 88
// dwait ( 0 0$2 ) ;
10504: LD_INT 70
10506: PPUSH
10507: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10511: LD_EXP 47
10515: PPUSH
10516: LD_STRING D12-Bur-1b
10518: PPUSH
10519: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10523: LD_EXP 16
10527: PPUSH
10528: LD_STRING D12-JMM-1
10530: PPUSH
10531: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10535: LD_EXP 47
10539: PPUSH
10540: LD_STRING D12-Bur-2
10542: PPUSH
10543: CALL_OW 88
// if Roth then
10547: LD_EXP 17
10551: IFFALSE 10567
// Say ( Roth , D12-Roth-2 ) else
10553: LD_EXP 17
10557: PPUSH
10558: LD_STRING D12-Roth-2
10560: PPUSH
10561: CALL_OW 88
10565: GO 10579
// Say ( SciRu , D12-RSci1-2 ) ;
10567: CALL 13248 0 0
10571: PPUSH
10572: LD_STRING D12-RSci1-2
10574: PPUSH
10575: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10579: LD_EXP 16
10583: PPUSH
10584: LD_STRING D12-JMM-2
10586: PPUSH
10587: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10591: LD_EXP 47
10595: PPUSH
10596: LD_STRING D12-Bur-3
10598: PPUSH
10599: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10603: LD_EXP 16
10607: PPUSH
10608: LD_STRING D12-JMM-3
10610: PPUSH
10611: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10615: LD_EXP 47
10619: PPUSH
10620: LD_STRING D12-Bur-4
10622: PPUSH
10623: CALL_OW 88
// case Query ( QBase ) of 1 :
10627: LD_STRING QBase
10629: PPUSH
10630: CALL_OW 97
10634: PUSH
10635: LD_INT 1
10637: DOUBLE
10638: EQUAL
10639: IFTRUE 10643
10641: GO 10761
10643: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10644: LD_EXP 16
10648: PPUSH
10649: LD_STRING D13a-JMM-1
10651: PPUSH
10652: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10656: LD_EXP 47
10660: PPUSH
10661: LD_STRING D13a-Bur-1
10663: PPUSH
10664: CALL_OW 88
// if Roth then
10668: LD_EXP 17
10672: IFFALSE 10688
// Say ( Roth , D13a-Roth-1 ) else
10674: LD_EXP 17
10678: PPUSH
10679: LD_STRING D13a-Roth-1
10681: PPUSH
10682: CALL_OW 88
10686: GO 10700
// Say ( SciRu , D13a-RSci1-1 ) ;
10688: CALL 13248 0 0
10692: PPUSH
10693: LD_STRING D13a-RSci1-1
10695: PPUSH
10696: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10700: LD_EXP 16
10704: PPUSH
10705: LD_STRING D13a-JMM-2
10707: PPUSH
10708: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10712: LD_STRING QBaseAgain
10714: PPUSH
10715: CALL_OW 97
10719: PUSH
10720: LD_INT 1
10722: DOUBLE
10723: EQUAL
10724: IFTRUE 10728
10726: GO 10739
10728: POP
// selected_option := 2 ; 2 :
10729: LD_ADDR_VAR 0 2
10733: PUSH
10734: LD_INT 2
10736: ST_TO_ADDR
10737: GO 10759
10739: LD_INT 2
10741: DOUBLE
10742: EQUAL
10743: IFTRUE 10747
10745: GO 10758
10747: POP
// selected_option := 3 ; end ;
10748: LD_ADDR_VAR 0 2
10752: PUSH
10753: LD_INT 3
10755: ST_TO_ADDR
10756: GO 10759
10758: POP
// end ; 2 :
10759: GO 10800
10761: LD_INT 2
10763: DOUBLE
10764: EQUAL
10765: IFTRUE 10769
10767: GO 10780
10769: POP
// selected_option := 2 ; 3 :
10770: LD_ADDR_VAR 0 2
10774: PUSH
10775: LD_INT 2
10777: ST_TO_ADDR
10778: GO 10800
10780: LD_INT 3
10782: DOUBLE
10783: EQUAL
10784: IFTRUE 10788
10786: GO 10799
10788: POP
// selected_option := 3 ; end ;
10789: LD_ADDR_VAR 0 2
10793: PUSH
10794: LD_INT 3
10796: ST_TO_ADDR
10797: GO 10800
10799: POP
// if selected_option = 2 then
10800: LD_VAR 0 2
10804: PUSH
10805: LD_INT 2
10807: EQUAL
10808: IFFALSE 10902
// begin Say ( JMM , D13b-JMM-1 ) ;
10810: LD_EXP 16
10814: PPUSH
10815: LD_STRING D13b-JMM-1
10817: PPUSH
10818: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10822: LD_EXP 47
10826: PPUSH
10827: LD_STRING D13b-Bur-1
10829: PPUSH
10830: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10834: LD_EXP 16
10838: PPUSH
10839: LD_STRING D13b-JMM-2
10841: PPUSH
10842: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10846: LD_EXP 56
10850: PPUSH
10851: LD_STRING D13b-Abd-2
10853: PPUSH
10854: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10858: LD_EXP 16
10862: PPUSH
10863: LD_STRING D13b-JMM-3
10865: PPUSH
10866: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10870: LD_EXP 56
10874: PPUSH
10875: LD_STRING D13b-Abd-3
10877: PPUSH
10878: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10882: LD_EXP 16
10886: PPUSH
10887: LD_STRING D13b-JMM-4
10889: PPUSH
10890: CALL_OW 88
// ar_active_attack := true ;
10894: LD_ADDR_EXP 9
10898: PUSH
10899: LD_INT 1
10901: ST_TO_ADDR
// end ; if selected_option = 3 then
10902: LD_VAR 0 2
10906: PUSH
10907: LD_INT 3
10909: EQUAL
10910: IFFALSE 10936
// begin Say ( JMM , D13c-JMM-1 ) ;
10912: LD_EXP 16
10916: PPUSH
10917: LD_STRING D13c-JMM-1
10919: PPUSH
10920: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10924: LD_EXP 47
10928: PPUSH
10929: LD_STRING D13c-Bur-1
10931: PPUSH
10932: CALL_OW 88
// end ; DialogueOff ;
10936: CALL_OW 7
// if not ar_active_attack then
10940: LD_EXP 9
10944: NOT
10945: IFFALSE 10962
// begin wait ( 6 6$00 ) ;
10947: LD_INT 12600
10949: PPUSH
10950: CALL_OW 67
// ar_active_attack := true ;
10954: LD_ADDR_EXP 9
10958: PUSH
10959: LD_INT 1
10961: ST_TO_ADDR
// end ; end ;
10962: PPOPN 2
10964: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10965: LD_EXP 47
10969: PPUSH
10970: CALL_OW 305
10974: PUSH
10975: LD_EXP 47
10979: PPUSH
10980: CALL_OW 255
10984: PUSH
10985: LD_INT 7
10987: EQUAL
10988: AND
10989: IFFALSE 11185
10991: GO 10993
10993: DISABLE
10994: LD_INT 0
10996: PPUSH
// begin wait ( 4 4$40 ) ;
10997: LD_INT 9800
10999: PPUSH
11000: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11004: LD_INT 35
11006: PPUSH
11007: CALL_OW 67
// until not ru_attackers ;
11011: LD_EXP 53
11015: NOT
11016: IFFALSE 11004
// PrepareGnyevko ;
11018: CALL 2250 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11022: LD_EXP 49
11026: PPUSH
11027: LD_INT 124
11029: PPUSH
11030: LD_INT 118
11032: PPUSH
11033: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11037: LD_EXP 49
11041: PPUSH
11042: CALL_OW 200
// time := 0 0$00 ;
11046: LD_ADDR_VAR 0 1
11050: PUSH
11051: LD_INT 0
11053: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11054: LD_INT 35
11056: PPUSH
11057: CALL_OW 67
// time := time + 0 0$1 ;
11061: LD_ADDR_VAR 0 1
11065: PUSH
11066: LD_VAR 0 1
11070: PUSH
11071: LD_INT 35
11073: PLUS
11074: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11075: LD_EXP 49
11079: PPUSH
11080: LD_INT 124
11082: PPUSH
11083: LD_INT 118
11085: PPUSH
11086: CALL_OW 307
11090: PUSH
11091: LD_VAR 0 1
11095: PUSH
11096: LD_INT 1050
11098: GREATEREQUAL
11099: OR
11100: IFFALSE 11054
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11102: LD_EXP 49
11106: PPUSH
11107: LD_STRING DBelkov-Gny-1
11109: PPUSH
11110: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11114: LD_EXP 47
11118: PPUSH
11119: LD_STRING DBelkov-Bur-1a
11121: PPUSH
11122: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11126: LD_INT 35
11128: PPUSH
11129: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11133: LD_EXP 49
11137: PPUSH
11138: LD_INT 22
11140: PUSH
11141: LD_INT 7
11143: PUSH
11144: EMPTY
11145: LIST
11146: LIST
11147: PPUSH
11148: CALL_OW 69
11152: PPUSH
11153: LD_EXP 49
11157: PPUSH
11158: CALL_OW 74
11162: PPUSH
11163: CALL_OW 296
11167: PUSH
11168: LD_INT 8
11170: LESS
11171: IFFALSE 11126
// SetSide ( Gnyevko , 7 ) ;
11173: LD_EXP 49
11177: PPUSH
11178: LD_INT 7
11180: PPUSH
11181: CALL_OW 235
// end ;
11185: PPOPN 1
11187: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11188: LD_EXP 47
11192: PPUSH
11193: CALL_OW 255
11197: PUSH
11198: LD_INT 7
11200: EQUAL
11201: IFFALSE 11211
11203: GO 11205
11205: DISABLE
// begin enable ;
11206: ENABLE
// PrepareAmericanAttack ;
11207: CALL 6853 0 0
// end ;
11211: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11212: LD_INT 22
11214: PUSH
11215: LD_INT 1
11217: PUSH
11218: EMPTY
11219: LIST
11220: LIST
11221: PPUSH
11222: CALL_OW 69
11226: IFFALSE 11410
11228: GO 11230
11230: DISABLE
11231: LD_INT 0
11233: PPUSH
11234: PPUSH
// begin while true do
11235: LD_INT 1
11237: IFFALSE 11294
// begin wait ( 0 0$1 ) ;
11239: LD_INT 35
11241: PPUSH
11242: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11246: LD_ADDR_VAR 0 2
11250: PUSH
11251: LD_INT 22
11253: PUSH
11254: LD_INT 1
11256: PUSH
11257: EMPTY
11258: LIST
11259: LIST
11260: PPUSH
11261: CALL_OW 69
11265: PPUSH
11266: LD_EXP 16
11270: PPUSH
11271: CALL_OW 74
11275: ST_TO_ADDR
// if See ( 7 , tmp ) then
11276: LD_INT 7
11278: PPUSH
11279: LD_VAR 0 2
11283: PPUSH
11284: CALL_OW 292
11288: IFFALSE 11292
// break ;
11290: GO 11294
// end ;
11292: GO 11235
// DialogueOn ;
11294: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11298: LD_VAR 0 2
11302: PPUSH
11303: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11307: LD_VAR 0 2
11311: PPUSH
11312: CALL_OW 250
11316: PPUSH
11317: LD_VAR 0 2
11321: PPUSH
11322: CALL_OW 251
11326: PPUSH
11327: LD_INT 7
11329: PPUSH
11330: LD_INT 8
11332: PPUSH
11333: CALL_OW 330
// if Denis then
11337: LD_EXP 22
11341: IFFALSE 11355
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11343: LD_EXP 22
11347: PPUSH
11348: LD_STRING DAmerAttack-Pet-1
11350: PPUSH
11351: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11355: LD_EXP 16
11359: PPUSH
11360: LD_STRING DAmerAttack-JMM-1
11362: PPUSH
11363: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11367: LD_EXP 47
11371: PPUSH
11372: LD_STRING DStop-Bur-1
11374: PPUSH
11375: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11379: LD_VAR 0 2
11383: PPUSH
11384: CALL_OW 250
11388: PPUSH
11389: LD_VAR 0 2
11393: PPUSH
11394: CALL_OW 251
11398: PPUSH
11399: LD_INT 7
11401: PPUSH
11402: CALL_OW 331
// DialogueOff ;
11406: CALL_OW 7
// end ;
11410: PPOPN 2
11412: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11413: LD_INT 22
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 21
11425: PUSH
11426: LD_INT 1
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: EMPTY
11434: LIST
11435: LIST
11436: PPUSH
11437: CALL_OW 69
11441: PUSH
11442: LD_INT 0
11444: EQUAL
11445: IFFALSE 11487
11447: GO 11449
11449: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11450: LD_STRING M5a
11452: PPUSH
11453: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11457: LD_EXP 16
11461: PPUSH
11462: LD_STRING D8-JMM-1
11464: PPUSH
11465: CALL_OW 88
// if Gossudarov then
11469: LD_EXP 33
11473: IFFALSE 11487
// Say ( Gossudarov , D8-Gos-1 ) ;
11475: LD_EXP 33
11479: PPUSH
11480: LD_STRING D8-Gos-1
11482: PPUSH
11483: CALL_OW 88
// end ;
11487: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11488: LD_INT 22
11490: PUSH
11491: LD_INT 2
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: PUSH
11498: LD_INT 21
11500: PUSH
11501: LD_INT 1
11503: PUSH
11504: EMPTY
11505: LIST
11506: LIST
11507: PUSH
11508: EMPTY
11509: LIST
11510: LIST
11511: PPUSH
11512: CALL_OW 69
11516: PUSH
11517: LD_INT 0
11519: EQUAL
11520: IFFALSE 11570
11522: GO 11524
11524: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11525: LD_STRING M4c
11527: PPUSH
11528: CALL_OW 337
// if Roth then
11532: LD_EXP 17
11536: IFFALSE 11552
// Say ( Roth , DStop-Roth-1 ) else
11538: LD_EXP 17
11542: PPUSH
11543: LD_STRING DStop-Roth-1
11545: PPUSH
11546: CALL_OW 88
11550: GO 11570
// if Gossudarov then
11552: LD_EXP 33
11556: IFFALSE 11570
// Say ( Gossudarov , D8-Gos-1a ) ;
11558: LD_EXP 33
11562: PPUSH
11563: LD_STRING D8-Gos-1a
11565: PPUSH
11566: CALL_OW 88
// end ;
11570: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11571: LD_INT 7
11573: PPUSH
11574: LD_INT 1
11576: PPUSH
11577: LD_INT 1
11579: PPUSH
11580: CALL 14927 0 3
11584: PUSH
11585: LD_INT 0
11587: EQUAL
11588: PUSH
11589: LD_INT 7
11591: PPUSH
11592: LD_INT 3
11594: PPUSH
11595: LD_INT 1
11597: PPUSH
11598: CALL 14927 0 3
11602: PUSH
11603: LD_INT 0
11605: EQUAL
11606: AND
11607: IFFALSE 11619
11609: GO 11611
11611: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11612: LD_STRING M1a
11614: PPUSH
11615: CALL_OW 337
// end ;
11619: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
11620: LD_INT 22
11622: PUSH
11623: LD_INT 2
11625: PUSH
11626: EMPTY
11627: LIST
11628: LIST
11629: PUSH
11630: LD_INT 21
11632: PUSH
11633: LD_INT 1
11635: PUSH
11636: EMPTY
11637: LIST
11638: LIST
11639: PUSH
11640: EMPTY
11641: LIST
11642: LIST
11643: PPUSH
11644: CALL_OW 69
11648: PUSH
11649: LD_INT 0
11651: EQUAL
11652: PUSH
11653: LD_INT 22
11655: PUSH
11656: LD_INT 3
11658: PUSH
11659: EMPTY
11660: LIST
11661: LIST
11662: PUSH
11663: LD_INT 21
11665: PUSH
11666: LD_INT 1
11668: PUSH
11669: EMPTY
11670: LIST
11671: LIST
11672: PUSH
11673: EMPTY
11674: LIST
11675: LIST
11676: PPUSH
11677: CALL_OW 69
11681: PUSH
11682: LD_INT 0
11684: EQUAL
11685: AND
11686: PUSH
11687: LD_INT 22
11689: PUSH
11690: LD_INT 1
11692: PUSH
11693: EMPTY
11694: LIST
11695: LIST
11696: PPUSH
11697: CALL_OW 69
11701: PUSH
11702: LD_INT 0
11704: EQUAL
11705: AND
11706: PUSH
11707: LD_INT 7
11709: PPUSH
11710: LD_INT 1
11712: PPUSH
11713: LD_INT 1
11715: PPUSH
11716: CALL 14927 0 3
11720: PUSH
11721: LD_INT 0
11723: EQUAL
11724: AND
11725: PUSH
11726: LD_INT 7
11728: PPUSH
11729: LD_INT 3
11731: PPUSH
11732: LD_INT 1
11734: PPUSH
11735: CALL 14927 0 3
11739: PUSH
11740: LD_INT 0
11742: EQUAL
11743: AND
11744: PUSH
11745: LD_EXP 47
11749: PPUSH
11750: CALL_OW 255
11754: PUSH
11755: LD_INT 7
11757: EQUAL
11758: AND
11759: PUSH
11760: LD_EXP 47
11764: PPUSH
11765: CALL_OW 302
11769: AND
11770: IFFALSE 13245
11772: GO 11774
11774: DISABLE
11775: LD_INT 0
11777: PPUSH
11778: PPUSH
11779: PPUSH
11780: PPUSH
11781: PPUSH
11782: PPUSH
// begin m1 := false ;
11783: LD_ADDR_VAR 0 4
11787: PUSH
11788: LD_INT 0
11790: ST_TO_ADDR
// m2 := false ;
11791: LD_ADDR_VAR 0 5
11795: PUSH
11796: LD_INT 0
11798: ST_TO_ADDR
// m3 := false ;
11799: LD_ADDR_VAR 0 6
11803: PUSH
11804: LD_INT 0
11806: ST_TO_ADDR
// if tick < 40 40$00 then
11807: LD_OWVAR 1
11811: PUSH
11812: LD_INT 84000
11814: LESS
11815: IFFALSE 11824
// SetAchievement ( ACH_ASPEED_17 ) ;
11817: LD_STRING ACH_ASPEED_17
11819: PPUSH
11820: CALL_OW 543
// wait ( 0 0$5 ) ;
11824: LD_INT 175
11826: PPUSH
11827: CALL_OW 67
// if not masha_killed then
11831: LD_EXP 10
11835: NOT
11836: IFFALSE 11858
// begin m1 := true ;
11838: LD_ADDR_VAR 0 4
11842: PUSH
11843: LD_INT 1
11845: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11846: LD_STRING Masha
11848: PPUSH
11849: LD_INT 1
11851: PPUSH
11852: CALL_OW 101
// end else
11856: GO 11869
// AddMedal ( Masha , - 1 ) ;
11858: LD_STRING Masha
11860: PPUSH
11861: LD_INT 1
11863: NEG
11864: PPUSH
11865: CALL_OW 101
// if abdul_escaped then
11869: LD_EXP 13
11873: IFFALSE 11888
// AddMedal ( Abdul , - 1 ) else
11875: LD_STRING Abdul
11877: PPUSH
11878: LD_INT 1
11880: NEG
11881: PPUSH
11882: CALL_OW 101
11886: GO 11906
// begin m2 := true ;
11888: LD_ADDR_VAR 0 5
11892: PUSH
11893: LD_INT 1
11895: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11896: LD_STRING Abdul
11898: PPUSH
11899: LD_INT 1
11901: PPUSH
11902: CALL_OW 101
// end ; if loss_counter = 0 then
11906: LD_EXP 14
11910: PUSH
11911: LD_INT 0
11913: EQUAL
11914: IFFALSE 11936
// begin m3 := true ;
11916: LD_ADDR_VAR 0 6
11920: PUSH
11921: LD_INT 1
11923: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11924: LD_STRING People
11926: PPUSH
11927: LD_INT 2
11929: PPUSH
11930: CALL_OW 101
// end else
11934: GO 11998
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
11936: LD_EXP 14
11940: PUSH
11941: LD_INT 3
11943: PUSH
11944: LD_INT 2
11946: PUSH
11947: LD_INT 2
11949: PUSH
11950: LD_INT 1
11952: PUSH
11953: EMPTY
11954: LIST
11955: LIST
11956: LIST
11957: LIST
11958: PUSH
11959: LD_OWVAR 67
11963: ARRAY
11964: LESSEQUAL
11965: IFFALSE 11987
// begin AddMedal ( People , 1 ) ;
11967: LD_STRING People
11969: PPUSH
11970: LD_INT 1
11972: PPUSH
11973: CALL_OW 101
// m3 := true ;
11977: LD_ADDR_VAR 0 6
11981: PUSH
11982: LD_INT 1
11984: ST_TO_ADDR
// end else
11985: GO 11998
// AddMedal ( People , - 1 ) ;
11987: LD_STRING People
11989: PPUSH
11990: LD_INT 1
11992: NEG
11993: PPUSH
11994: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
11998: LD_OWVAR 67
12002: PUSH
12003: LD_INT 3
12005: GREATEREQUAL
12006: PUSH
12007: LD_VAR 0 4
12011: AND
12012: PUSH
12013: LD_VAR 0 5
12017: AND
12018: PUSH
12019: LD_VAR 0 6
12023: AND
12024: IFFALSE 12036
// SetAchievementEX ( ACH_AMER , 17 ) ;
12026: LD_STRING ACH_AMER
12028: PPUSH
12029: LD_INT 17
12031: PPUSH
12032: CALL_OW 564
// GiveMedals ( MAIN ) ;
12036: LD_STRING MAIN
12038: PPUSH
12039: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12043: LD_ADDR_VAR 0 2
12047: PUSH
12048: LD_INT 22
12050: PUSH
12051: LD_INT 7
12053: PUSH
12054: EMPTY
12055: LIST
12056: LIST
12057: PUSH
12058: LD_INT 2
12060: PUSH
12061: LD_INT 25
12063: PUSH
12064: LD_INT 1
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: PUSH
12071: LD_INT 25
12073: PUSH
12074: LD_INT 2
12076: PUSH
12077: EMPTY
12078: LIST
12079: LIST
12080: PUSH
12081: LD_INT 25
12083: PUSH
12084: LD_INT 3
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 25
12093: PUSH
12094: LD_INT 4
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 25
12103: PUSH
12104: LD_INT 5
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: LD_INT 25
12113: PUSH
12114: LD_INT 8
12116: PUSH
12117: EMPTY
12118: LIST
12119: LIST
12120: PUSH
12121: LD_INT 25
12123: PUSH
12124: LD_INT 9
12126: PUSH
12127: EMPTY
12128: LIST
12129: LIST
12130: PUSH
12131: EMPTY
12132: LIST
12133: LIST
12134: LIST
12135: LIST
12136: LIST
12137: LIST
12138: LIST
12139: LIST
12140: PUSH
12141: EMPTY
12142: LIST
12143: LIST
12144: PPUSH
12145: CALL_OW 69
12149: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12150: LD_VAR 0 2
12154: PPUSH
12155: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
12159: LD_ADDR_VAR 0 3
12163: PUSH
12164: LD_EXP 16
12168: PUSH
12169: LD_EXP 17
12173: PUSH
12174: LD_EXP 18
12178: PUSH
12179: LD_EXP 19
12183: PUSH
12184: LD_EXP 20
12188: PUSH
12189: LD_EXP 21
12193: PUSH
12194: LD_EXP 22
12198: PUSH
12199: LD_EXP 23
12203: PUSH
12204: LD_EXP 24
12208: PUSH
12209: LD_EXP 25
12213: PUSH
12214: LD_EXP 26
12218: PUSH
12219: LD_EXP 27
12223: PUSH
12224: LD_EXP 28
12228: PUSH
12229: LD_EXP 29
12233: PUSH
12234: LD_EXP 30
12238: PUSH
12239: LD_EXP 31
12243: PUSH
12244: LD_EXP 32
12248: PUSH
12249: LD_EXP 33
12253: PUSH
12254: LD_EXP 34
12258: PUSH
12259: LD_EXP 35
12263: PUSH
12264: LD_EXP 37
12268: PUSH
12269: LD_EXP 38
12273: PUSH
12274: LD_EXP 39
12278: PUSH
12279: LD_EXP 40
12283: PUSH
12284: LD_EXP 41
12288: PUSH
12289: LD_EXP 42
12293: PUSH
12294: LD_EXP 43
12298: PUSH
12299: LD_EXP 44
12303: PUSH
12304: LD_EXP 45
12308: PUSH
12309: LD_EXP 46
12313: PUSH
12314: LD_EXP 47
12318: PUSH
12319: LD_EXP 48
12323: PUSH
12324: LD_EXP 49
12328: PUSH
12329: EMPTY
12330: LIST
12331: LIST
12332: LIST
12333: LIST
12334: LIST
12335: LIST
12336: LIST
12337: LIST
12338: LIST
12339: LIST
12340: LIST
12341: LIST
12342: LIST
12343: LIST
12344: LIST
12345: LIST
12346: LIST
12347: LIST
12348: LIST
12349: LIST
12350: LIST
12351: LIST
12352: LIST
12353: LIST
12354: LIST
12355: LIST
12356: LIST
12357: LIST
12358: LIST
12359: LIST
12360: LIST
12361: LIST
12362: LIST
12363: ST_TO_ADDR
// if tmp diff tmp2 then
12364: LD_VAR 0 2
12368: PUSH
12369: LD_VAR 0 3
12373: DIFF
12374: IFFALSE 12394
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12376: LD_VAR 0 2
12380: PUSH
12381: LD_VAR 0 3
12385: DIFF
12386: PPUSH
12387: LD_STRING 13a_others
12389: PPUSH
12390: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12394: LD_EXP 16
12398: PPUSH
12399: LD_STRING 13a_JMM
12401: PPUSH
12402: CALL_OW 38
// if Titov then
12406: LD_EXP 35
12410: IFFALSE 12424
// SaveCharacters ( Titov , 13a_Titov ) ;
12412: LD_EXP 35
12416: PPUSH
12417: LD_STRING 13a_Titov
12419: PPUSH
12420: CALL_OW 38
// if Dolgov then
12424: LD_EXP 37
12428: IFFALSE 12442
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12430: LD_EXP 37
12434: PPUSH
12435: LD_STRING 13a_Dolgov
12437: PPUSH
12438: CALL_OW 38
// if Petrosyan then
12442: LD_EXP 38
12446: IFFALSE 12460
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12448: LD_EXP 38
12452: PPUSH
12453: LD_STRING 13a_Petrosyan
12455: PPUSH
12456: CALL_OW 38
// if Scholtze then
12460: LD_EXP 39
12464: IFFALSE 12478
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12466: LD_EXP 39
12470: PPUSH
12471: LD_STRING 13a_Scholtze
12473: PPUSH
12474: CALL_OW 38
// if Oblukov then
12478: LD_EXP 40
12482: IFFALSE 12496
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12484: LD_EXP 40
12488: PPUSH
12489: LD_STRING 13a_Oblukov
12491: PPUSH
12492: CALL_OW 38
// if Kapitsova then
12496: LD_EXP 41
12500: IFFALSE 12514
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12502: LD_EXP 41
12506: PPUSH
12507: LD_STRING 13a_Kapitsova
12509: PPUSH
12510: CALL_OW 38
// if Lipshchin then
12514: LD_EXP 42
12518: IFFALSE 12532
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12520: LD_EXP 42
12524: PPUSH
12525: LD_STRING 13a_Lipshchin
12527: PPUSH
12528: CALL_OW 38
// if Petrovova then
12532: LD_EXP 43
12536: IFFALSE 12550
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12538: LD_EXP 43
12542: PPUSH
12543: LD_STRING 13a_Petrovova
12545: PPUSH
12546: CALL_OW 38
// if Kovalyuk then
12550: LD_EXP 44
12554: IFFALSE 12568
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12556: LD_EXP 44
12560: PPUSH
12561: LD_STRING 13a_Kovalyuk
12563: PPUSH
12564: CALL_OW 38
// if Kuzmov then
12568: LD_EXP 45
12572: IFFALSE 12586
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12574: LD_EXP 45
12578: PPUSH
12579: LD_STRING 13a_Kuzmov
12581: PPUSH
12582: CALL_OW 38
// if Karamazov then
12586: LD_EXP 46
12590: IFFALSE 12604
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12592: LD_EXP 46
12596: PPUSH
12597: LD_STRING 13a_Karamazov
12599: PPUSH
12600: CALL_OW 38
// if Burlak then
12604: LD_EXP 47
12608: IFFALSE 12622
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12610: LD_EXP 47
12614: PPUSH
12615: LD_STRING 13a_Burlak
12617: PPUSH
12618: CALL_OW 38
// if Belkov then
12622: LD_EXP 48
12626: IFFALSE 12640
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12628: LD_EXP 48
12632: PPUSH
12633: LD_STRING 13a_Belkov
12635: PPUSH
12636: CALL_OW 38
// if Gnyevko then
12640: LD_EXP 49
12644: IFFALSE 12658
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12646: LD_EXP 49
12650: PPUSH
12651: LD_STRING 13a_Gnyevko
12653: PPUSH
12654: CALL_OW 38
// if Lisa then
12658: LD_EXP 18
12662: IFFALSE 12676
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12664: LD_EXP 18
12668: PPUSH
12669: LD_STRING 13a_Lisa
12671: PPUSH
12672: CALL_OW 38
// if Donaldson then
12676: LD_EXP 19
12680: IFFALSE 12694
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12682: LD_EXP 19
12686: PPUSH
12687: LD_STRING 13a_Donaldson
12689: PPUSH
12690: CALL_OW 38
// if Bobby then
12694: LD_EXP 20
12698: IFFALSE 12712
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12700: LD_EXP 20
12704: PPUSH
12705: LD_STRING 13a_Bobby
12707: PPUSH
12708: CALL_OW 38
// if Cyrus then
12712: LD_EXP 21
12716: IFFALSE 12730
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12718: LD_EXP 21
12722: PPUSH
12723: LD_STRING 13a_Cyrus
12725: PPUSH
12726: CALL_OW 38
// if Denis then
12730: LD_EXP 22
12734: IFFALSE 12748
// SaveCharacters ( Denis , 13a_Denis ) ;
12736: LD_EXP 22
12740: PPUSH
12741: LD_STRING 13a_Denis
12743: PPUSH
12744: CALL_OW 38
// if Brown then
12748: LD_EXP 23
12752: IFFALSE 12766
// SaveCharacters ( Brown , 13a_Brown ) ;
12754: LD_EXP 23
12758: PPUSH
12759: LD_STRING 13a_Brown
12761: PPUSH
12762: CALL_OW 38
// if Gladstone then
12766: LD_EXP 24
12770: IFFALSE 12784
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12772: LD_EXP 24
12776: PPUSH
12777: LD_STRING 13a_Gladstone
12779: PPUSH
12780: CALL_OW 38
// if Houten then
12784: LD_EXP 25
12788: IFFALSE 12802
// SaveCharacters ( Houten , 13a_Houten ) ;
12790: LD_EXP 25
12794: PPUSH
12795: LD_STRING 13a_Houten
12797: PPUSH
12798: CALL_OW 38
// if Cornel then
12802: LD_EXP 26
12806: IFFALSE 12820
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12808: LD_EXP 26
12812: PPUSH
12813: LD_STRING 13a_Cornel
12815: PPUSH
12816: CALL_OW 38
// if Gary then
12820: LD_EXP 27
12824: IFFALSE 12838
// SaveCharacters ( Gary , 13a_Gary ) ;
12826: LD_EXP 27
12830: PPUSH
12831: LD_STRING 13a_Gary
12833: PPUSH
12834: CALL_OW 38
// if Frank then
12838: LD_EXP 28
12842: IFFALSE 12856
// SaveCharacters ( Frank , 13a_Frank ) ;
12844: LD_EXP 28
12848: PPUSH
12849: LD_STRING 13a_Frank
12851: PPUSH
12852: CALL_OW 38
// if Kikuchi then
12856: LD_EXP 29
12860: IFFALSE 12874
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12862: LD_EXP 29
12866: PPUSH
12867: LD_STRING 13a_Kikuchi
12869: PPUSH
12870: CALL_OW 38
// if Simms then
12874: LD_EXP 30
12878: IFFALSE 12892
// SaveCharacters ( Simms , 13a_Simms ) ;
12880: LD_EXP 30
12884: PPUSH
12885: LD_STRING 13a_Simms
12887: PPUSH
12888: CALL_OW 38
// if Joan then
12892: LD_EXP 31
12896: IFFALSE 12910
// SaveCharacters ( Joan , 13a_Joan ) ;
12898: LD_EXP 31
12902: PPUSH
12903: LD_STRING 13a_Joan
12905: PPUSH
12906: CALL_OW 38
// if DeltaDoctor then
12910: LD_EXP 32
12914: IFFALSE 12928
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12916: LD_EXP 32
12920: PPUSH
12921: LD_STRING 13a_DeltaDoctor
12923: PPUSH
12924: CALL_OW 38
// if Gossudarov then
12928: LD_EXP 33
12932: IFFALSE 12946
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12934: LD_EXP 33
12938: PPUSH
12939: LD_STRING 13a_Gossudarov
12941: PPUSH
12942: CALL_OW 38
// if Kirilenkova then
12946: LD_EXP 34
12950: IFFALSE 12964
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12952: LD_EXP 34
12956: PPUSH
12957: LD_STRING 13a_Kirilenkova
12959: PPUSH
12960: CALL_OW 38
// if Roth then
12964: LD_EXP 17
12968: IFFALSE 12982
// SaveCharacters ( Roth , 13a_Roth ) ;
12970: LD_EXP 17
12974: PPUSH
12975: LD_STRING 13a_Roth
12977: PPUSH
12978: CALL_OW 38
// if Masha then
12982: LD_EXP 50
12986: IFFALSE 13041
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12988: LD_EXP 50
12992: PPUSH
12993: CALL_OW 265
12997: PUSH
12998: LD_EXP 50
13002: PPUSH
13003: CALL_OW 262
13007: PUSH
13008: LD_EXP 50
13012: PPUSH
13013: CALL_OW 263
13017: PUSH
13018: LD_EXP 50
13022: PPUSH
13023: CALL_OW 264
13027: PUSH
13028: EMPTY
13029: LIST
13030: LIST
13031: LIST
13032: LIST
13033: PPUSH
13034: LD_STRING 13a_Masha
13036: PPUSH
13037: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13041: LD_ADDR_VAR 0 2
13045: PUSH
13046: LD_INT 21
13048: PUSH
13049: LD_INT 3
13051: PUSH
13052: EMPTY
13053: LIST
13054: LIST
13055: PPUSH
13056: CALL_OW 69
13060: ST_TO_ADDR
// tmp2 := [ ] ;
13061: LD_ADDR_VAR 0 3
13065: PUSH
13066: EMPTY
13067: ST_TO_ADDR
// if tmp then
13068: LD_VAR 0 2
13072: IFFALSE 13223
// for i in tmp do
13074: LD_ADDR_VAR 0 1
13078: PUSH
13079: LD_VAR 0 2
13083: PUSH
13084: FOR_IN
13085: IFFALSE 13221
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13087: LD_ADDR_VAR 0 3
13091: PUSH
13092: LD_VAR 0 3
13096: PUSH
13097: LD_VAR 0 1
13101: PPUSH
13102: CALL_OW 255
13106: PUSH
13107: LD_VAR 0 1
13111: PPUSH
13112: CALL_OW 248
13116: PUSH
13117: LD_VAR 0 1
13121: PPUSH
13122: CALL_OW 266
13126: PUSH
13127: LD_VAR 0 1
13131: PPUSH
13132: CALL_OW 250
13136: PUSH
13137: LD_VAR 0 1
13141: PPUSH
13142: CALL_OW 251
13146: PUSH
13147: LD_VAR 0 1
13151: PPUSH
13152: CALL_OW 254
13156: PUSH
13157: LD_VAR 0 1
13161: PPUSH
13162: CALL_OW 267
13166: PUSH
13167: LD_VAR 0 1
13171: PPUSH
13172: LD_INT 1
13174: PPUSH
13175: CALL_OW 268
13179: PUSH
13180: LD_VAR 0 1
13184: PPUSH
13185: LD_INT 2
13187: PPUSH
13188: CALL_OW 268
13192: PUSH
13193: LD_VAR 0 1
13197: PPUSH
13198: CALL_OW 269
13202: PUSH
13203: EMPTY
13204: LIST
13205: LIST
13206: LIST
13207: LIST
13208: LIST
13209: LIST
13210: LIST
13211: LIST
13212: LIST
13213: LIST
13214: PUSH
13215: EMPTY
13216: LIST
13217: ADD
13218: ST_TO_ADDR
13219: GO 13084
13221: POP
13222: POP
// if tmp2 then
13223: LD_VAR 0 3
13227: IFFALSE 13241
// SaveVariable ( tmp2 , 13a_buildings ) ;
13229: LD_VAR 0 3
13233: PPUSH
13234: LD_STRING 13a_buildings
13236: PPUSH
13237: CALL_OW 39
// YouWin ;
13241: CALL_OW 103
// end ;
13245: PPOPN 6
13247: END
// export function SciRu ; var tmp , t ; begin
13248: LD_INT 0
13250: PPUSH
13251: PPUSH
13252: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13253: LD_ADDR_VAR 0 3
13257: PUSH
13258: LD_EXP 33
13262: PUSH
13263: LD_EXP 47
13267: PUSH
13268: LD_EXP 35
13272: PUSH
13273: LD_EXP 48
13277: PUSH
13278: LD_EXP 49
13282: PUSH
13283: LD_EXP 38
13287: PUSH
13288: LD_EXP 39
13292: PUSH
13293: LD_EXP 37
13297: PUSH
13298: EMPTY
13299: LIST
13300: LIST
13301: LIST
13302: LIST
13303: LIST
13304: LIST
13305: LIST
13306: LIST
13307: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13308: LD_ADDR_VAR 0 2
13312: PUSH
13313: LD_INT 22
13315: PUSH
13316: LD_INT 7
13318: PUSH
13319: EMPTY
13320: LIST
13321: LIST
13322: PUSH
13323: LD_INT 23
13325: PUSH
13326: LD_INT 3
13328: PUSH
13329: EMPTY
13330: LIST
13331: LIST
13332: PUSH
13333: LD_INT 25
13335: PUSH
13336: LD_INT 4
13338: PUSH
13339: EMPTY
13340: LIST
13341: LIST
13342: PUSH
13343: LD_INT 26
13345: PUSH
13346: LD_INT 1
13348: PUSH
13349: EMPTY
13350: LIST
13351: LIST
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: LIST
13357: LIST
13358: PPUSH
13359: CALL_OW 69
13363: PUSH
13364: LD_VAR 0 3
13368: DIFF
13369: ST_TO_ADDR
// if tmp then
13370: LD_VAR 0 2
13374: IFFALSE 13390
// result := tmp [ 1 ] ;
13376: LD_ADDR_VAR 0 1
13380: PUSH
13381: LD_VAR 0 2
13385: PUSH
13386: LD_INT 1
13388: ARRAY
13389: ST_TO_ADDR
// end ;
13390: LD_VAR 0 1
13394: RET
// export function SolRu ; var tmp , t ; begin
13395: LD_INT 0
13397: PPUSH
13398: PPUSH
13399: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13400: LD_ADDR_VAR 0 3
13404: PUSH
13405: LD_EXP 33
13409: PUSH
13410: LD_EXP 47
13414: PUSH
13415: LD_EXP 35
13419: PUSH
13420: LD_EXP 48
13424: PUSH
13425: LD_EXP 49
13429: PUSH
13430: LD_EXP 38
13434: PUSH
13435: LD_EXP 39
13439: PUSH
13440: LD_EXP 37
13444: PUSH
13445: EMPTY
13446: LIST
13447: LIST
13448: LIST
13449: LIST
13450: LIST
13451: LIST
13452: LIST
13453: LIST
13454: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
13455: LD_ADDR_VAR 0 2
13459: PUSH
13460: LD_INT 22
13462: PUSH
13463: LD_INT 7
13465: PUSH
13466: EMPTY
13467: LIST
13468: LIST
13469: PUSH
13470: LD_INT 23
13472: PUSH
13473: LD_INT 3
13475: PUSH
13476: EMPTY
13477: LIST
13478: LIST
13479: PUSH
13480: LD_INT 25
13482: PUSH
13483: LD_INT 1
13485: PUSH
13486: EMPTY
13487: LIST
13488: LIST
13489: PUSH
13490: LD_INT 26
13492: PUSH
13493: LD_INT 1
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: EMPTY
13501: LIST
13502: LIST
13503: LIST
13504: LIST
13505: PPUSH
13506: CALL_OW 69
13510: PUSH
13511: LD_VAR 0 3
13515: DIFF
13516: ST_TO_ADDR
// if tmp then
13517: LD_VAR 0 2
13521: IFFALSE 13537
// result := tmp [ 1 ] ;
13523: LD_ADDR_VAR 0 1
13527: PUSH
13528: LD_VAR 0 2
13532: PUSH
13533: LD_INT 1
13535: ARRAY
13536: ST_TO_ADDR
// end ; end_of_file
13537: LD_VAR 0 1
13541: RET
// export function CustomEvent ( event ) ; begin
13542: LD_INT 0
13544: PPUSH
// end ;
13545: LD_VAR 0 2
13549: RET
// on UnitDestroyed ( un ) do var i , side ;
13550: LD_INT 0
13552: PPUSH
13553: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL 102517 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13563: LD_VAR 0 1
13567: PUSH
13568: LD_INT 22
13570: PUSH
13571: LD_INT 7
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 2
13580: PUSH
13581: LD_INT 25
13583: PUSH
13584: LD_INT 1
13586: PUSH
13587: EMPTY
13588: LIST
13589: LIST
13590: PUSH
13591: LD_INT 25
13593: PUSH
13594: LD_INT 2
13596: PUSH
13597: EMPTY
13598: LIST
13599: LIST
13600: PUSH
13601: LD_INT 25
13603: PUSH
13604: LD_INT 3
13606: PUSH
13607: EMPTY
13608: LIST
13609: LIST
13610: PUSH
13611: LD_INT 25
13613: PUSH
13614: LD_INT 4
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 25
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: LD_INT 25
13633: PUSH
13634: LD_INT 8
13636: PUSH
13637: EMPTY
13638: LIST
13639: LIST
13640: PUSH
13641: LD_INT 25
13643: PUSH
13644: LD_INT 9
13646: PUSH
13647: EMPTY
13648: LIST
13649: LIST
13650: PUSH
13651: EMPTY
13652: LIST
13653: LIST
13654: LIST
13655: LIST
13656: LIST
13657: LIST
13658: LIST
13659: LIST
13660: PUSH
13661: EMPTY
13662: LIST
13663: LIST
13664: PPUSH
13665: CALL_OW 69
13669: IN
13670: IFFALSE 13686
// loss_counter := loss_counter + 1 ;
13672: LD_ADDR_EXP 14
13676: PUSH
13677: LD_EXP 14
13681: PUSH
13682: LD_INT 1
13684: PLUS
13685: ST_TO_ADDR
// if un = Abdul then
13686: LD_VAR 0 1
13690: PUSH
13691: LD_EXP 56
13695: EQUAL
13696: IFFALSE 13706
// abdul_escaped := false ;
13698: LD_ADDR_EXP 13
13702: PUSH
13703: LD_INT 0
13705: ST_TO_ADDR
// if un in ru_attackers then
13706: LD_VAR 0 1
13710: PUSH
13711: LD_EXP 53
13715: IN
13716: IFFALSE 13734
// ru_attackers := ru_attackers diff un ;
13718: LD_ADDR_EXP 53
13722: PUSH
13723: LD_EXP 53
13727: PUSH
13728: LD_VAR 0 1
13732: DIFF
13733: ST_TO_ADDR
// if un in ar_attackers then
13734: LD_VAR 0 1
13738: PUSH
13739: LD_EXP 11
13743: IN
13744: IFFALSE 13762
// ar_attackers := ar_attackers diff un ;
13746: LD_ADDR_EXP 11
13750: PUSH
13751: LD_EXP 11
13755: PUSH
13756: LD_VAR 0 1
13760: DIFF
13761: ST_TO_ADDR
// if un = JMM then
13762: LD_VAR 0 1
13766: PUSH
13767: LD_EXP 16
13771: EQUAL
13772: IFFALSE 13783
// begin YouLost ( JMM ) ;
13774: LD_STRING JMM
13776: PPUSH
13777: CALL_OW 104
// exit ;
13781: GO 13880
// end ; if un = Burlak then
13783: LD_VAR 0 1
13787: PUSH
13788: LD_EXP 47
13792: EQUAL
13793: IFFALSE 13804
// begin YouLost ( Burlak ) ;
13795: LD_STRING Burlak
13797: PPUSH
13798: CALL_OW 104
// exit ;
13802: GO 13880
// end ; if un = freedom then
13804: LD_VAR 0 1
13808: PUSH
13809: LD_EXP 3
13813: EQUAL
13814: IFFALSE 13825
// begin YouLost ( Destroyed ) ;
13816: LD_STRING Destroyed
13818: PPUSH
13819: CALL_OW 104
// exit ;
13823: GO 13880
// end ; if un = Masha then
13825: LD_VAR 0 1
13829: PUSH
13830: LD_EXP 50
13834: EQUAL
13835: IFFALSE 13852
// begin ChangeMissionObjectives ( M4b ) ;
13837: LD_STRING M4b
13839: PPUSH
13840: CALL_OW 337
// masha_killed := true ;
13844: LD_ADDR_EXP 10
13848: PUSH
13849: LD_INT 1
13851: ST_TO_ADDR
// end ; if un = Mastodont then
13852: LD_VAR 0 1
13856: PUSH
13857: LD_EXP 57
13861: EQUAL
13862: IFFALSE 13871
// ChangeMissionObjectives ( M4a ) ;
13864: LD_STRING M4a
13866: PPUSH
13867: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13871: LD_VAR 0 1
13875: PPUSH
13876: CALL 83720 0 1
// end ;
13880: PPOPN 3
13882: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13883: LD_VAR 0 1
13887: PPUSH
13888: LD_VAR 0 2
13892: PPUSH
13893: CALL 86054 0 2
// end ;
13897: PPOPN 2
13899: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13900: LD_VAR 0 1
13904: PPUSH
13905: CALL 85122 0 1
// end ;
13909: PPOPN 1
13911: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13912: LD_VAR 0 1
13916: PUSH
13917: LD_INT 22
13919: PUSH
13920: LD_INT 7
13922: PUSH
13923: EMPTY
13924: LIST
13925: LIST
13926: PUSH
13927: LD_INT 30
13929: PUSH
13930: LD_INT 0
13932: PUSH
13933: EMPTY
13934: LIST
13935: LIST
13936: PUSH
13937: EMPTY
13938: LIST
13939: LIST
13940: PPUSH
13941: CALL_OW 69
13945: IN
13946: IFFALSE 13985
// begin SetBName ( building , freedom ) ;
13948: LD_VAR 0 1
13952: PPUSH
13953: LD_STRING freedom
13955: PPUSH
13956: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13960: LD_INT 0
13962: PPUSH
13963: LD_INT 7
13965: PPUSH
13966: LD_INT 0
13968: PPUSH
13969: CALL_OW 324
// freedom := building ;
13973: LD_ADDR_EXP 3
13977: PUSH
13978: LD_VAR 0 1
13982: ST_TO_ADDR
// exit ;
13983: GO 14051
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13985: LD_VAR 0 1
13989: PUSH
13990: LD_INT 22
13992: PUSH
13993: LD_INT 7
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: PUSH
14000: LD_INT 23
14002: PUSH
14003: LD_INT 3
14005: PUSH
14006: EMPTY
14007: LIST
14008: LIST
14009: PUSH
14010: LD_INT 30
14012: PUSH
14013: LD_INT 6
14015: PUSH
14016: EMPTY
14017: LIST
14018: LIST
14019: PUSH
14020: EMPTY
14021: LIST
14022: LIST
14023: LIST
14024: PPUSH
14025: CALL_OW 69
14029: IN
14030: IFFALSE 14042
// begin ru_lab_builded := true ;
14032: LD_ADDR_EXP 5
14036: PUSH
14037: LD_INT 1
14039: ST_TO_ADDR
// exit ;
14040: GO 14051
// end ; MCE_BuildingComplete ( building ) ;
14042: LD_VAR 0 1
14046: PPUSH
14047: CALL 85363 0 1
// end ;
14051: PPOPN 1
14053: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14054: LD_VAR 0 1
14058: PPUSH
14059: LD_VAR 0 2
14063: PPUSH
14064: CALL 83416 0 2
// end ;
14068: PPOPN 2
14070: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14071: LD_VAR 0 1
14075: PPUSH
14076: LD_VAR 0 2
14080: PPUSH
14081: LD_VAR 0 3
14085: PPUSH
14086: LD_VAR 0 4
14090: PPUSH
14091: LD_VAR 0 5
14095: PPUSH
14096: CALL 83036 0 5
// end ;
14100: PPOPN 5
14102: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14103: LD_VAR 0 1
14107: PPUSH
14108: LD_VAR 0 2
14112: PPUSH
14113: CALL 102639 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14117: LD_VAR 0 1
14121: PPUSH
14122: LD_VAR 0 2
14126: PPUSH
14127: CALL 82617 0 2
// end ;
14131: PPOPN 2
14133: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14134: LD_VAR 0 1
14138: PPUSH
14139: CALL_OW 263
14143: PUSH
14144: LD_INT 3
14146: EQUAL
14147: PUSH
14148: LD_VAR 0 2
14152: PPUSH
14153: CALL_OW 263
14157: PUSH
14158: LD_INT 3
14160: EQUAL
14161: OR
14162: IFFALSE 14178
// hack_counter := hack_counter + 1 ;
14164: LD_ADDR_EXP 15
14168: PUSH
14169: LD_EXP 15
14173: PUSH
14174: LD_INT 1
14176: PLUS
14177: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14178: LD_VAR 0 1
14182: PPUSH
14183: LD_VAR 0 2
14187: PPUSH
14188: LD_VAR 0 3
14192: PPUSH
14193: LD_VAR 0 4
14197: PPUSH
14198: CALL 82455 0 4
// end ;
14202: PPOPN 4
14204: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14205: LD_VAR 0 1
14209: PPUSH
14210: LD_VAR 0 2
14214: PPUSH
14215: LD_VAR 0 3
14219: PPUSH
14220: CALL 82230 0 3
// end ;
14224: PPOPN 3
14226: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14227: LD_VAR 0 1
14231: PPUSH
14232: LD_VAR 0 2
14236: PPUSH
14237: CALL 82115 0 2
// end ;
14241: PPOPN 2
14243: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14244: LD_VAR 0 1
14248: PPUSH
14249: LD_VAR 0 2
14253: PPUSH
14254: CALL 86349 0 2
// end ;
14258: PPOPN 2
14260: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14261: LD_VAR 0 1
14265: PPUSH
14266: LD_VAR 0 2
14270: PPUSH
14271: LD_VAR 0 3
14275: PPUSH
14276: LD_VAR 0 4
14280: PPUSH
14281: CALL 86565 0 4
// end ;
14285: PPOPN 4
14287: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14288: LD_VAR 0 1
14292: PPUSH
14293: LD_VAR 0 2
14297: PPUSH
14298: CALL 81924 0 2
// end ;
14302: PPOPN 2
14304: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14305: LD_VAR 0 1
14309: PPUSH
14310: CALL 102623 0 1
// end ; end_of_file
14314: PPOPN 1
14316: END
// every 0 0$30 do var cr , time ;
14317: GO 14319
14319: DISABLE
14320: LD_INT 0
14322: PPUSH
14323: PPUSH
// begin time := 0 0$20 ;
14324: LD_ADDR_VAR 0 2
14328: PUSH
14329: LD_INT 700
14331: ST_TO_ADDR
// while game do
14332: LD_EXP 2
14336: IFFALSE 14439
// begin wait ( time ) ;
14338: LD_VAR 0 2
14342: PPUSH
14343: CALL_OW 67
// if tick > 2 2$00 then
14347: LD_OWVAR 1
14351: PUSH
14352: LD_INT 4200
14354: GREATER
14355: IFFALSE 14392
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14357: LD_ADDR_VAR 0 2
14361: PUSH
14362: LD_VAR 0 2
14366: PUSH
14367: LD_INT 140
14369: PUSH
14370: LD_INT 140
14372: PUSH
14373: LD_INT 210
14375: PUSH
14376: LD_INT 280
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: PUSH
14385: LD_OWVAR 67
14389: ARRAY
14390: PLUS
14391: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
14392: LD_INT 1
14394: PPUSH
14395: LD_INT 5
14397: PPUSH
14398: CALL_OW 12
14402: PPUSH
14403: LD_INT 70
14405: PPUSH
14406: LD_INT 49
14408: PPUSH
14409: LD_INT 25
14411: PPUSH
14412: LD_INT 1
14414: PPUSH
14415: CALL_OW 56
// if time > 3 3$00 then
14419: LD_VAR 0 2
14423: PUSH
14424: LD_INT 6300
14426: GREATER
14427: IFFALSE 14437
// time := 0 0$30 ;
14429: LD_ADDR_VAR 0 2
14433: PUSH
14434: LD_INT 1050
14436: ST_TO_ADDR
// end ;
14437: GO 14332
// end ;
14439: PPOPN 2
14441: END
// every 0 0$30 do var cr , time ;
14442: GO 14444
14444: DISABLE
14445: LD_INT 0
14447: PPUSH
14448: PPUSH
// begin time := 0 0$20 ;
14449: LD_ADDR_VAR 0 2
14453: PUSH
14454: LD_INT 700
14456: ST_TO_ADDR
// while game do
14457: LD_EXP 2
14461: IFFALSE 14554
// begin wait ( time ) ;
14463: LD_VAR 0 2
14467: PPUSH
14468: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14472: LD_ADDR_VAR 0 2
14476: PUSH
14477: LD_VAR 0 2
14481: PUSH
14482: LD_INT 140
14484: PUSH
14485: LD_INT 175
14487: PUSH
14488: LD_INT 210
14490: PUSH
14491: LD_INT 280
14493: PUSH
14494: EMPTY
14495: LIST
14496: LIST
14497: LIST
14498: LIST
14499: PUSH
14500: LD_OWVAR 67
14504: ARRAY
14505: PLUS
14506: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14507: LD_INT 3
14509: PPUSH
14510: LD_INT 5
14512: PPUSH
14513: CALL_OW 12
14517: PPUSH
14518: LD_INT 26
14520: PPUSH
14521: LD_INT 9
14523: PPUSH
14524: LD_INT 30
14526: PPUSH
14527: LD_INT 1
14529: PPUSH
14530: CALL_OW 56
// if time > 3 3$00 then
14534: LD_VAR 0 2
14538: PUSH
14539: LD_INT 6300
14541: GREATER
14542: IFFALSE 14552
// time := 0 0$20 ;
14544: LD_ADDR_VAR 0 2
14548: PUSH
14549: LD_INT 700
14551: ST_TO_ADDR
// end ;
14552: GO 14457
// end ;
14554: PPOPN 2
14556: END
// every 0 0$30 do var cr , time ;
14557: GO 14559
14559: DISABLE
14560: LD_INT 0
14562: PPUSH
14563: PPUSH
// begin time := 0 0$20 ;
14564: LD_ADDR_VAR 0 2
14568: PUSH
14569: LD_INT 700
14571: ST_TO_ADDR
// while game do
14572: LD_EXP 2
14576: IFFALSE 14705
// begin wait ( time ) ;
14578: LD_VAR 0 2
14582: PPUSH
14583: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
14587: LD_ADDR_VAR 0 2
14591: PUSH
14592: LD_VAR 0 2
14596: PUSH
14597: LD_INT 175
14599: PUSH
14600: LD_INT 210
14602: PUSH
14603: LD_INT 280
14605: PUSH
14606: LD_INT 350
14608: PUSH
14609: EMPTY
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: PUSH
14615: LD_OWVAR 67
14619: ARRAY
14620: PLUS
14621: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14622: LD_INT 1
14624: PPUSH
14625: LD_INT 5
14627: PPUSH
14628: CALL_OW 12
14632: PPUSH
14633: LD_INT 179
14635: PPUSH
14636: LD_INT 101
14638: PPUSH
14639: LD_INT 20
14641: PPUSH
14642: LD_INT 1
14644: PPUSH
14645: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14649: LD_INT 350
14651: PPUSH
14652: LD_INT 525
14654: PPUSH
14655: CALL_OW 12
14659: PPUSH
14660: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14664: LD_INT 1
14666: PPUSH
14667: LD_INT 5
14669: PPUSH
14670: CALL_OW 12
14674: PPUSH
14675: LD_INT 9
14677: PPUSH
14678: LD_INT 1
14680: PPUSH
14681: CALL_OW 55
// if time > 4 4$00 then
14685: LD_VAR 0 2
14689: PUSH
14690: LD_INT 8400
14692: GREATER
14693: IFFALSE 14703
// time := 0 0$30 ;
14695: LD_ADDR_VAR 0 2
14699: PUSH
14700: LD_INT 1050
14702: ST_TO_ADDR
// end ;
14703: GO 14572
// end ;
14705: PPOPN 2
14707: END
// every 0 0$30 do var cr , time ;
14708: GO 14710
14710: DISABLE
14711: LD_INT 0
14713: PPUSH
14714: PPUSH
// begin time := 0 0$10 ;
14715: LD_ADDR_VAR 0 2
14719: PUSH
14720: LD_INT 350
14722: ST_TO_ADDR
// while game do
14723: LD_EXP 2
14727: IFFALSE 14861
// begin wait ( time ) ;
14729: LD_VAR 0 2
14733: PPUSH
14734: CALL_OW 67
// time := time + 0 0$10 ;
14738: LD_ADDR_VAR 0 2
14742: PUSH
14743: LD_VAR 0 2
14747: PUSH
14748: LD_INT 350
14750: PLUS
14751: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14752: LD_INT 1
14754: PPUSH
14755: LD_INT 5
14757: PPUSH
14758: CALL_OW 12
14762: PPUSH
14763: LD_INT 11
14765: PPUSH
14766: LD_INT 1
14768: PPUSH
14769: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14773: LD_ADDR_VAR 0 1
14777: PUSH
14778: LD_INT 1
14780: PPUSH
14781: LD_INT 3
14783: PPUSH
14784: CALL_OW 12
14788: ST_TO_ADDR
// if cr = 1 then
14789: LD_VAR 0 1
14793: PUSH
14794: LD_INT 1
14796: EQUAL
14797: IFFALSE 14841
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14799: LD_INT 700
14801: PPUSH
14802: LD_INT 1575
14804: PPUSH
14805: CALL_OW 12
14809: PPUSH
14810: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14814: LD_INT 1
14816: PPUSH
14817: LD_INT 5
14819: PPUSH
14820: CALL_OW 12
14824: PPUSH
14825: LD_INT 34
14827: PPUSH
14828: LD_INT 50
14830: PPUSH
14831: LD_INT 7
14833: PPUSH
14834: LD_INT 1
14836: PPUSH
14837: CALL_OW 56
// end ; if time > 4 4$00 then
14841: LD_VAR 0 2
14845: PUSH
14846: LD_INT 8400
14848: GREATER
14849: IFFALSE 14859
// time := 0 0$40 ;
14851: LD_ADDR_VAR 0 2
14855: PUSH
14856: LD_INT 1400
14858: ST_TO_ADDR
// end ;
14859: GO 14723
// end ; end_of_file
14861: PPOPN 2
14863: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14864: LD_INT 0
14866: PPUSH
14867: PPUSH
// if exist_mode then
14868: LD_VAR 0 2
14872: IFFALSE 14897
// unit := CreateCharacter ( prefix & ident ) else
14874: LD_ADDR_VAR 0 5
14878: PUSH
14879: LD_VAR 0 3
14883: PUSH
14884: LD_VAR 0 1
14888: STR
14889: PPUSH
14890: CALL_OW 34
14894: ST_TO_ADDR
14895: GO 14912
// unit := NewCharacter ( ident ) ;
14897: LD_ADDR_VAR 0 5
14901: PUSH
14902: LD_VAR 0 1
14906: PPUSH
14907: CALL_OW 25
14911: ST_TO_ADDR
// result := unit ;
14912: LD_ADDR_VAR 0 4
14916: PUSH
14917: LD_VAR 0 5
14921: ST_TO_ADDR
// end ;
14922: LD_VAR 0 4
14926: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14927: LD_INT 0
14929: PPUSH
14930: PPUSH
// if not side or not nation then
14931: LD_VAR 0 1
14935: NOT
14936: PUSH
14937: LD_VAR 0 2
14941: NOT
14942: OR
14943: IFFALSE 14947
// exit ;
14945: GO 15715
// case nation of nation_american :
14947: LD_VAR 0 2
14951: PUSH
14952: LD_INT 1
14954: DOUBLE
14955: EQUAL
14956: IFTRUE 14960
14958: GO 15174
14960: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14961: LD_ADDR_VAR 0 4
14965: PUSH
14966: LD_INT 35
14968: PUSH
14969: LD_INT 45
14971: PUSH
14972: LD_INT 46
14974: PUSH
14975: LD_INT 47
14977: PUSH
14978: LD_INT 82
14980: PUSH
14981: LD_INT 83
14983: PUSH
14984: LD_INT 84
14986: PUSH
14987: LD_INT 85
14989: PUSH
14990: LD_INT 86
14992: PUSH
14993: LD_INT 1
14995: PUSH
14996: LD_INT 2
14998: PUSH
14999: LD_INT 6
15001: PUSH
15002: LD_INT 15
15004: PUSH
15005: LD_INT 16
15007: PUSH
15008: LD_INT 7
15010: PUSH
15011: LD_INT 12
15013: PUSH
15014: LD_INT 13
15016: PUSH
15017: LD_INT 10
15019: PUSH
15020: LD_INT 14
15022: PUSH
15023: LD_INT 20
15025: PUSH
15026: LD_INT 21
15028: PUSH
15029: LD_INT 22
15031: PUSH
15032: LD_INT 25
15034: PUSH
15035: LD_INT 32
15037: PUSH
15038: LD_INT 27
15040: PUSH
15041: LD_INT 36
15043: PUSH
15044: LD_INT 69
15046: PUSH
15047: LD_INT 39
15049: PUSH
15050: LD_INT 34
15052: PUSH
15053: LD_INT 40
15055: PUSH
15056: LD_INT 48
15058: PUSH
15059: LD_INT 49
15061: PUSH
15062: LD_INT 50
15064: PUSH
15065: LD_INT 51
15067: PUSH
15068: LD_INT 52
15070: PUSH
15071: LD_INT 53
15073: PUSH
15074: LD_INT 54
15076: PUSH
15077: LD_INT 55
15079: PUSH
15080: LD_INT 56
15082: PUSH
15083: LD_INT 57
15085: PUSH
15086: LD_INT 58
15088: PUSH
15089: LD_INT 59
15091: PUSH
15092: LD_INT 60
15094: PUSH
15095: LD_INT 61
15097: PUSH
15098: LD_INT 62
15100: PUSH
15101: LD_INT 80
15103: PUSH
15104: LD_INT 82
15106: PUSH
15107: LD_INT 83
15109: PUSH
15110: LD_INT 84
15112: PUSH
15113: LD_INT 85
15115: PUSH
15116: LD_INT 86
15118: PUSH
15119: EMPTY
15120: LIST
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: LIST
15126: LIST
15127: LIST
15128: LIST
15129: LIST
15130: LIST
15131: LIST
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: LIST
15137: LIST
15138: LIST
15139: LIST
15140: LIST
15141: LIST
15142: LIST
15143: LIST
15144: LIST
15145: LIST
15146: LIST
15147: LIST
15148: LIST
15149: LIST
15150: LIST
15151: LIST
15152: LIST
15153: LIST
15154: LIST
15155: LIST
15156: LIST
15157: LIST
15158: LIST
15159: LIST
15160: LIST
15161: LIST
15162: LIST
15163: LIST
15164: LIST
15165: LIST
15166: LIST
15167: LIST
15168: LIST
15169: LIST
15170: LIST
15171: ST_TO_ADDR
15172: GO 15639
15174: LD_INT 2
15176: DOUBLE
15177: EQUAL
15178: IFTRUE 15182
15180: GO 15408
15182: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15183: LD_ADDR_VAR 0 4
15187: PUSH
15188: LD_INT 35
15190: PUSH
15191: LD_INT 45
15193: PUSH
15194: LD_INT 46
15196: PUSH
15197: LD_INT 47
15199: PUSH
15200: LD_INT 82
15202: PUSH
15203: LD_INT 83
15205: PUSH
15206: LD_INT 84
15208: PUSH
15209: LD_INT 85
15211: PUSH
15212: LD_INT 87
15214: PUSH
15215: LD_INT 70
15217: PUSH
15218: LD_INT 1
15220: PUSH
15221: LD_INT 11
15223: PUSH
15224: LD_INT 3
15226: PUSH
15227: LD_INT 4
15229: PUSH
15230: LD_INT 5
15232: PUSH
15233: LD_INT 6
15235: PUSH
15236: LD_INT 15
15238: PUSH
15239: LD_INT 18
15241: PUSH
15242: LD_INT 7
15244: PUSH
15245: LD_INT 17
15247: PUSH
15248: LD_INT 8
15250: PUSH
15251: LD_INT 20
15253: PUSH
15254: LD_INT 21
15256: PUSH
15257: LD_INT 22
15259: PUSH
15260: LD_INT 72
15262: PUSH
15263: LD_INT 26
15265: PUSH
15266: LD_INT 69
15268: PUSH
15269: LD_INT 39
15271: PUSH
15272: LD_INT 40
15274: PUSH
15275: LD_INT 41
15277: PUSH
15278: LD_INT 42
15280: PUSH
15281: LD_INT 43
15283: PUSH
15284: LD_INT 48
15286: PUSH
15287: LD_INT 49
15289: PUSH
15290: LD_INT 50
15292: PUSH
15293: LD_INT 51
15295: PUSH
15296: LD_INT 52
15298: PUSH
15299: LD_INT 53
15301: PUSH
15302: LD_INT 54
15304: PUSH
15305: LD_INT 55
15307: PUSH
15308: LD_INT 56
15310: PUSH
15311: LD_INT 60
15313: PUSH
15314: LD_INT 61
15316: PUSH
15317: LD_INT 62
15319: PUSH
15320: LD_INT 66
15322: PUSH
15323: LD_INT 67
15325: PUSH
15326: LD_INT 68
15328: PUSH
15329: LD_INT 81
15331: PUSH
15332: LD_INT 82
15334: PUSH
15335: LD_INT 83
15337: PUSH
15338: LD_INT 84
15340: PUSH
15341: LD_INT 85
15343: PUSH
15344: LD_INT 87
15346: PUSH
15347: LD_INT 88
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: LIST
15354: LIST
15355: LIST
15356: LIST
15357: LIST
15358: LIST
15359: LIST
15360: LIST
15361: LIST
15362: LIST
15363: LIST
15364: LIST
15365: LIST
15366: LIST
15367: LIST
15368: LIST
15369: LIST
15370: LIST
15371: LIST
15372: LIST
15373: LIST
15374: LIST
15375: LIST
15376: LIST
15377: LIST
15378: LIST
15379: LIST
15380: LIST
15381: LIST
15382: LIST
15383: LIST
15384: LIST
15385: LIST
15386: LIST
15387: LIST
15388: LIST
15389: LIST
15390: LIST
15391: LIST
15392: LIST
15393: LIST
15394: LIST
15395: LIST
15396: LIST
15397: LIST
15398: LIST
15399: LIST
15400: LIST
15401: LIST
15402: LIST
15403: LIST
15404: LIST
15405: ST_TO_ADDR
15406: GO 15639
15408: LD_INT 3
15410: DOUBLE
15411: EQUAL
15412: IFTRUE 15416
15414: GO 15638
15416: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
15417: LD_ADDR_VAR 0 4
15421: PUSH
15422: LD_INT 46
15424: PUSH
15425: LD_INT 47
15427: PUSH
15428: LD_INT 1
15430: PUSH
15431: LD_INT 2
15433: PUSH
15434: LD_INT 82
15436: PUSH
15437: LD_INT 83
15439: PUSH
15440: LD_INT 84
15442: PUSH
15443: LD_INT 85
15445: PUSH
15446: LD_INT 86
15448: PUSH
15449: LD_INT 11
15451: PUSH
15452: LD_INT 9
15454: PUSH
15455: LD_INT 20
15457: PUSH
15458: LD_INT 19
15460: PUSH
15461: LD_INT 21
15463: PUSH
15464: LD_INT 24
15466: PUSH
15467: LD_INT 22
15469: PUSH
15470: LD_INT 25
15472: PUSH
15473: LD_INT 28
15475: PUSH
15476: LD_INT 29
15478: PUSH
15479: LD_INT 30
15481: PUSH
15482: LD_INT 31
15484: PUSH
15485: LD_INT 37
15487: PUSH
15488: LD_INT 38
15490: PUSH
15491: LD_INT 32
15493: PUSH
15494: LD_INT 27
15496: PUSH
15497: LD_INT 33
15499: PUSH
15500: LD_INT 69
15502: PUSH
15503: LD_INT 39
15505: PUSH
15506: LD_INT 34
15508: PUSH
15509: LD_INT 40
15511: PUSH
15512: LD_INT 71
15514: PUSH
15515: LD_INT 23
15517: PUSH
15518: LD_INT 44
15520: PUSH
15521: LD_INT 48
15523: PUSH
15524: LD_INT 49
15526: PUSH
15527: LD_INT 50
15529: PUSH
15530: LD_INT 51
15532: PUSH
15533: LD_INT 52
15535: PUSH
15536: LD_INT 53
15538: PUSH
15539: LD_INT 54
15541: PUSH
15542: LD_INT 55
15544: PUSH
15545: LD_INT 56
15547: PUSH
15548: LD_INT 57
15550: PUSH
15551: LD_INT 58
15553: PUSH
15554: LD_INT 59
15556: PUSH
15557: LD_INT 63
15559: PUSH
15560: LD_INT 64
15562: PUSH
15563: LD_INT 65
15565: PUSH
15566: LD_INT 82
15568: PUSH
15569: LD_INT 83
15571: PUSH
15572: LD_INT 84
15574: PUSH
15575: LD_INT 85
15577: PUSH
15578: LD_INT 86
15580: PUSH
15581: EMPTY
15582: LIST
15583: LIST
15584: LIST
15585: LIST
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: LIST
15597: LIST
15598: LIST
15599: LIST
15600: LIST
15601: LIST
15602: LIST
15603: LIST
15604: LIST
15605: LIST
15606: LIST
15607: LIST
15608: LIST
15609: LIST
15610: LIST
15611: LIST
15612: LIST
15613: LIST
15614: LIST
15615: LIST
15616: LIST
15617: LIST
15618: LIST
15619: LIST
15620: LIST
15621: LIST
15622: LIST
15623: LIST
15624: LIST
15625: LIST
15626: LIST
15627: LIST
15628: LIST
15629: LIST
15630: LIST
15631: LIST
15632: LIST
15633: LIST
15634: LIST
15635: ST_TO_ADDR
15636: GO 15639
15638: POP
// if state > - 1 and state < 3 then
15639: LD_VAR 0 3
15643: PUSH
15644: LD_INT 1
15646: NEG
15647: GREATER
15648: PUSH
15649: LD_VAR 0 3
15653: PUSH
15654: LD_INT 3
15656: LESS
15657: AND
15658: IFFALSE 15715
// for i in result do
15660: LD_ADDR_VAR 0 5
15664: PUSH
15665: LD_VAR 0 4
15669: PUSH
15670: FOR_IN
15671: IFFALSE 15713
// if GetTech ( i , side ) <> state then
15673: LD_VAR 0 5
15677: PPUSH
15678: LD_VAR 0 1
15682: PPUSH
15683: CALL_OW 321
15687: PUSH
15688: LD_VAR 0 3
15692: NONEQUAL
15693: IFFALSE 15711
// result := result diff i ;
15695: LD_ADDR_VAR 0 4
15699: PUSH
15700: LD_VAR 0 4
15704: PUSH
15705: LD_VAR 0 5
15709: DIFF
15710: ST_TO_ADDR
15711: GO 15670
15713: POP
15714: POP
// end ;
15715: LD_VAR 0 4
15719: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15720: LD_INT 0
15722: PPUSH
15723: PPUSH
15724: PPUSH
// result := true ;
15725: LD_ADDR_VAR 0 3
15729: PUSH
15730: LD_INT 1
15732: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15733: LD_ADDR_VAR 0 5
15737: PUSH
15738: LD_VAR 0 2
15742: PPUSH
15743: CALL_OW 480
15747: ST_TO_ADDR
// if not tmp then
15748: LD_VAR 0 5
15752: NOT
15753: IFFALSE 15757
// exit ;
15755: GO 15806
// for i in tmp do
15757: LD_ADDR_VAR 0 4
15761: PUSH
15762: LD_VAR 0 5
15766: PUSH
15767: FOR_IN
15768: IFFALSE 15804
// if GetTech ( i , side ) <> state_researched then
15770: LD_VAR 0 4
15774: PPUSH
15775: LD_VAR 0 1
15779: PPUSH
15780: CALL_OW 321
15784: PUSH
15785: LD_INT 2
15787: NONEQUAL
15788: IFFALSE 15802
// begin result := false ;
15790: LD_ADDR_VAR 0 3
15794: PUSH
15795: LD_INT 0
15797: ST_TO_ADDR
// exit ;
15798: POP
15799: POP
15800: GO 15806
// end ;
15802: GO 15767
15804: POP
15805: POP
// end ;
15806: LD_VAR 0 3
15810: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15811: LD_INT 0
15813: PPUSH
15814: PPUSH
15815: PPUSH
15816: PPUSH
15817: PPUSH
15818: PPUSH
15819: PPUSH
15820: PPUSH
15821: PPUSH
15822: PPUSH
15823: PPUSH
15824: PPUSH
15825: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15826: LD_VAR 0 1
15830: NOT
15831: PUSH
15832: LD_VAR 0 1
15836: PPUSH
15837: CALL_OW 257
15841: PUSH
15842: LD_INT 9
15844: NONEQUAL
15845: OR
15846: IFFALSE 15850
// exit ;
15848: GO 16423
// side := GetSide ( unit ) ;
15850: LD_ADDR_VAR 0 9
15854: PUSH
15855: LD_VAR 0 1
15859: PPUSH
15860: CALL_OW 255
15864: ST_TO_ADDR
// tech_space := tech_spacanom ;
15865: LD_ADDR_VAR 0 12
15869: PUSH
15870: LD_INT 29
15872: ST_TO_ADDR
// tech_time := tech_taurad ;
15873: LD_ADDR_VAR 0 13
15877: PUSH
15878: LD_INT 28
15880: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15881: LD_ADDR_VAR 0 11
15885: PUSH
15886: LD_VAR 0 1
15890: PPUSH
15891: CALL_OW 310
15895: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15896: LD_VAR 0 11
15900: PPUSH
15901: CALL_OW 247
15905: PUSH
15906: LD_INT 2
15908: EQUAL
15909: IFFALSE 15913
// exit ;
15911: GO 16423
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15913: LD_ADDR_VAR 0 8
15917: PUSH
15918: LD_INT 81
15920: PUSH
15921: LD_VAR 0 9
15925: PUSH
15926: EMPTY
15927: LIST
15928: LIST
15929: PUSH
15930: LD_INT 3
15932: PUSH
15933: LD_INT 21
15935: PUSH
15936: LD_INT 3
15938: PUSH
15939: EMPTY
15940: LIST
15941: LIST
15942: PUSH
15943: EMPTY
15944: LIST
15945: LIST
15946: PUSH
15947: EMPTY
15948: LIST
15949: LIST
15950: PPUSH
15951: CALL_OW 69
15955: ST_TO_ADDR
// if not tmp then
15956: LD_VAR 0 8
15960: NOT
15961: IFFALSE 15965
// exit ;
15963: GO 16423
// if in_unit then
15965: LD_VAR 0 11
15969: IFFALSE 15993
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15971: LD_ADDR_VAR 0 10
15975: PUSH
15976: LD_VAR 0 8
15980: PPUSH
15981: LD_VAR 0 11
15985: PPUSH
15986: CALL_OW 74
15990: ST_TO_ADDR
15991: GO 16013
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15993: LD_ADDR_VAR 0 10
15997: PUSH
15998: LD_VAR 0 8
16002: PPUSH
16003: LD_VAR 0 1
16007: PPUSH
16008: CALL_OW 74
16012: ST_TO_ADDR
// if not enemy then
16013: LD_VAR 0 10
16017: NOT
16018: IFFALSE 16022
// exit ;
16020: GO 16423
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16022: LD_VAR 0 11
16026: PUSH
16027: LD_VAR 0 11
16031: PPUSH
16032: LD_VAR 0 10
16036: PPUSH
16037: CALL_OW 296
16041: PUSH
16042: LD_INT 13
16044: GREATER
16045: AND
16046: PUSH
16047: LD_VAR 0 1
16051: PPUSH
16052: LD_VAR 0 10
16056: PPUSH
16057: CALL_OW 296
16061: PUSH
16062: LD_INT 12
16064: GREATER
16065: OR
16066: IFFALSE 16070
// exit ;
16068: GO 16423
// missile := [ 1 ] ;
16070: LD_ADDR_VAR 0 14
16074: PUSH
16075: LD_INT 1
16077: PUSH
16078: EMPTY
16079: LIST
16080: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16081: LD_VAR 0 9
16085: PPUSH
16086: LD_VAR 0 12
16090: PPUSH
16091: CALL_OW 325
16095: IFFALSE 16124
// missile := Replace ( missile , missile + 1 , 2 ) ;
16097: LD_ADDR_VAR 0 14
16101: PUSH
16102: LD_VAR 0 14
16106: PPUSH
16107: LD_VAR 0 14
16111: PUSH
16112: LD_INT 1
16114: PLUS
16115: PPUSH
16116: LD_INT 2
16118: PPUSH
16119: CALL_OW 1
16123: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16124: LD_VAR 0 9
16128: PPUSH
16129: LD_VAR 0 13
16133: PPUSH
16134: CALL_OW 325
16138: PUSH
16139: LD_VAR 0 10
16143: PPUSH
16144: CALL_OW 255
16148: PPUSH
16149: LD_VAR 0 13
16153: PPUSH
16154: CALL_OW 325
16158: NOT
16159: AND
16160: IFFALSE 16189
// missile := Replace ( missile , missile + 1 , 3 ) ;
16162: LD_ADDR_VAR 0 14
16166: PUSH
16167: LD_VAR 0 14
16171: PPUSH
16172: LD_VAR 0 14
16176: PUSH
16177: LD_INT 1
16179: PLUS
16180: PPUSH
16181: LD_INT 3
16183: PPUSH
16184: CALL_OW 1
16188: ST_TO_ADDR
// if missile < 2 then
16189: LD_VAR 0 14
16193: PUSH
16194: LD_INT 2
16196: LESS
16197: IFFALSE 16201
// exit ;
16199: GO 16423
// x := GetX ( enemy ) ;
16201: LD_ADDR_VAR 0 4
16205: PUSH
16206: LD_VAR 0 10
16210: PPUSH
16211: CALL_OW 250
16215: ST_TO_ADDR
// y := GetY ( enemy ) ;
16216: LD_ADDR_VAR 0 5
16220: PUSH
16221: LD_VAR 0 10
16225: PPUSH
16226: CALL_OW 251
16230: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16231: LD_ADDR_VAR 0 6
16235: PUSH
16236: LD_VAR 0 4
16240: PUSH
16241: LD_INT 1
16243: NEG
16244: PPUSH
16245: LD_INT 1
16247: PPUSH
16248: CALL_OW 12
16252: PLUS
16253: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16254: LD_ADDR_VAR 0 7
16258: PUSH
16259: LD_VAR 0 5
16263: PUSH
16264: LD_INT 1
16266: NEG
16267: PPUSH
16268: LD_INT 1
16270: PPUSH
16271: CALL_OW 12
16275: PLUS
16276: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16277: LD_VAR 0 6
16281: PPUSH
16282: LD_VAR 0 7
16286: PPUSH
16287: CALL_OW 488
16291: NOT
16292: IFFALSE 16314
// begin _x := x ;
16294: LD_ADDR_VAR 0 6
16298: PUSH
16299: LD_VAR 0 4
16303: ST_TO_ADDR
// _y := y ;
16304: LD_ADDR_VAR 0 7
16308: PUSH
16309: LD_VAR 0 5
16313: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16314: LD_ADDR_VAR 0 3
16318: PUSH
16319: LD_INT 1
16321: PPUSH
16322: LD_VAR 0 14
16326: PPUSH
16327: CALL_OW 12
16331: ST_TO_ADDR
// case i of 1 :
16332: LD_VAR 0 3
16336: PUSH
16337: LD_INT 1
16339: DOUBLE
16340: EQUAL
16341: IFTRUE 16345
16343: GO 16362
16345: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16346: LD_VAR 0 1
16350: PPUSH
16351: LD_VAR 0 10
16355: PPUSH
16356: CALL_OW 115
16360: GO 16423
16362: LD_INT 2
16364: DOUBLE
16365: EQUAL
16366: IFTRUE 16370
16368: GO 16392
16370: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
16371: LD_VAR 0 1
16375: PPUSH
16376: LD_VAR 0 6
16380: PPUSH
16381: LD_VAR 0 7
16385: PPUSH
16386: CALL_OW 153
16390: GO 16423
16392: LD_INT 3
16394: DOUBLE
16395: EQUAL
16396: IFTRUE 16400
16398: GO 16422
16400: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
16401: LD_VAR 0 1
16405: PPUSH
16406: LD_VAR 0 6
16410: PPUSH
16411: LD_VAR 0 7
16415: PPUSH
16416: CALL_OW 154
16420: GO 16423
16422: POP
// end ;
16423: LD_VAR 0 2
16427: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
16428: LD_INT 0
16430: PPUSH
16431: PPUSH
16432: PPUSH
16433: PPUSH
16434: PPUSH
16435: PPUSH
// if not unit or not building then
16436: LD_VAR 0 1
16440: NOT
16441: PUSH
16442: LD_VAR 0 2
16446: NOT
16447: OR
16448: IFFALSE 16452
// exit ;
16450: GO 16610
// x := GetX ( building ) ;
16452: LD_ADDR_VAR 0 5
16456: PUSH
16457: LD_VAR 0 2
16461: PPUSH
16462: CALL_OW 250
16466: ST_TO_ADDR
// y := GetY ( building ) ;
16467: LD_ADDR_VAR 0 6
16471: PUSH
16472: LD_VAR 0 2
16476: PPUSH
16477: CALL_OW 251
16481: ST_TO_ADDR
// for i = 0 to 5 do
16482: LD_ADDR_VAR 0 4
16486: PUSH
16487: DOUBLE
16488: LD_INT 0
16490: DEC
16491: ST_TO_ADDR
16492: LD_INT 5
16494: PUSH
16495: FOR_TO
16496: IFFALSE 16608
// begin _x := ShiftX ( x , i , 3 ) ;
16498: LD_ADDR_VAR 0 7
16502: PUSH
16503: LD_VAR 0 5
16507: PPUSH
16508: LD_VAR 0 4
16512: PPUSH
16513: LD_INT 3
16515: PPUSH
16516: CALL_OW 272
16520: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16521: LD_ADDR_VAR 0 8
16525: PUSH
16526: LD_VAR 0 6
16530: PPUSH
16531: LD_VAR 0 4
16535: PPUSH
16536: LD_INT 3
16538: PPUSH
16539: CALL_OW 273
16543: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16544: LD_VAR 0 7
16548: PPUSH
16549: LD_VAR 0 8
16553: PPUSH
16554: CALL_OW 488
16558: NOT
16559: IFFALSE 16563
// continue ;
16561: GO 16495
// if HexInfo ( _x , _y ) = 0 then
16563: LD_VAR 0 7
16567: PPUSH
16568: LD_VAR 0 8
16572: PPUSH
16573: CALL_OW 428
16577: PUSH
16578: LD_INT 0
16580: EQUAL
16581: IFFALSE 16606
// begin ComMoveXY ( unit , _x , _y ) ;
16583: LD_VAR 0 1
16587: PPUSH
16588: LD_VAR 0 7
16592: PPUSH
16593: LD_VAR 0 8
16597: PPUSH
16598: CALL_OW 111
// exit ;
16602: POP
16603: POP
16604: GO 16610
// end ; end ;
16606: GO 16495
16608: POP
16609: POP
// end ;
16610: LD_VAR 0 3
16614: RET
// export function ScanBase ( side , base_area ) ; begin
16615: LD_INT 0
16617: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16618: LD_ADDR_VAR 0 3
16622: PUSH
16623: LD_VAR 0 2
16627: PPUSH
16628: LD_INT 81
16630: PUSH
16631: LD_VAR 0 1
16635: PUSH
16636: EMPTY
16637: LIST
16638: LIST
16639: PPUSH
16640: CALL_OW 70
16644: ST_TO_ADDR
// end ;
16645: LD_VAR 0 3
16649: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16650: LD_INT 0
16652: PPUSH
16653: PPUSH
16654: PPUSH
16655: PPUSH
// result := false ;
16656: LD_ADDR_VAR 0 2
16660: PUSH
16661: LD_INT 0
16663: ST_TO_ADDR
// side := GetSide ( unit ) ;
16664: LD_ADDR_VAR 0 3
16668: PUSH
16669: LD_VAR 0 1
16673: PPUSH
16674: CALL_OW 255
16678: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16679: LD_ADDR_VAR 0 4
16683: PUSH
16684: LD_VAR 0 1
16688: PPUSH
16689: CALL_OW 248
16693: ST_TO_ADDR
// case nat of 1 :
16694: LD_VAR 0 4
16698: PUSH
16699: LD_INT 1
16701: DOUBLE
16702: EQUAL
16703: IFTRUE 16707
16705: GO 16718
16707: POP
// tech := tech_lassight ; 2 :
16708: LD_ADDR_VAR 0 5
16712: PUSH
16713: LD_INT 12
16715: ST_TO_ADDR
16716: GO 16757
16718: LD_INT 2
16720: DOUBLE
16721: EQUAL
16722: IFTRUE 16726
16724: GO 16737
16726: POP
// tech := tech_mortar ; 3 :
16727: LD_ADDR_VAR 0 5
16731: PUSH
16732: LD_INT 41
16734: ST_TO_ADDR
16735: GO 16757
16737: LD_INT 3
16739: DOUBLE
16740: EQUAL
16741: IFTRUE 16745
16743: GO 16756
16745: POP
// tech := tech_bazooka ; end ;
16746: LD_ADDR_VAR 0 5
16750: PUSH
16751: LD_INT 44
16753: ST_TO_ADDR
16754: GO 16757
16756: POP
// if Researched ( side , tech ) then
16757: LD_VAR 0 3
16761: PPUSH
16762: LD_VAR 0 5
16766: PPUSH
16767: CALL_OW 325
16771: IFFALSE 16798
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16773: LD_ADDR_VAR 0 2
16777: PUSH
16778: LD_INT 5
16780: PUSH
16781: LD_INT 8
16783: PUSH
16784: LD_INT 9
16786: PUSH
16787: EMPTY
16788: LIST
16789: LIST
16790: LIST
16791: PUSH
16792: LD_VAR 0 4
16796: ARRAY
16797: ST_TO_ADDR
// end ;
16798: LD_VAR 0 2
16802: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16803: LD_INT 0
16805: PPUSH
16806: PPUSH
16807: PPUSH
// if not mines then
16808: LD_VAR 0 2
16812: NOT
16813: IFFALSE 16817
// exit ;
16815: GO 16961
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16817: LD_ADDR_VAR 0 5
16821: PUSH
16822: LD_INT 81
16824: PUSH
16825: LD_VAR 0 1
16829: PUSH
16830: EMPTY
16831: LIST
16832: LIST
16833: PUSH
16834: LD_INT 3
16836: PUSH
16837: LD_INT 21
16839: PUSH
16840: LD_INT 3
16842: PUSH
16843: EMPTY
16844: LIST
16845: LIST
16846: PUSH
16847: EMPTY
16848: LIST
16849: LIST
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PPUSH
16855: CALL_OW 69
16859: ST_TO_ADDR
// for i in mines do
16860: LD_ADDR_VAR 0 4
16864: PUSH
16865: LD_VAR 0 2
16869: PUSH
16870: FOR_IN
16871: IFFALSE 16959
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16873: LD_VAR 0 4
16877: PUSH
16878: LD_INT 1
16880: ARRAY
16881: PPUSH
16882: LD_VAR 0 4
16886: PUSH
16887: LD_INT 2
16889: ARRAY
16890: PPUSH
16891: CALL_OW 458
16895: NOT
16896: IFFALSE 16900
// continue ;
16898: GO 16870
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16900: LD_VAR 0 4
16904: PUSH
16905: LD_INT 1
16907: ARRAY
16908: PPUSH
16909: LD_VAR 0 4
16913: PUSH
16914: LD_INT 2
16916: ARRAY
16917: PPUSH
16918: CALL_OW 428
16922: PUSH
16923: LD_VAR 0 5
16927: IN
16928: IFFALSE 16957
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16930: LD_VAR 0 4
16934: PUSH
16935: LD_INT 1
16937: ARRAY
16938: PPUSH
16939: LD_VAR 0 4
16943: PUSH
16944: LD_INT 2
16946: ARRAY
16947: PPUSH
16948: LD_VAR 0 1
16952: PPUSH
16953: CALL_OW 456
// end ;
16957: GO 16870
16959: POP
16960: POP
// end ;
16961: LD_VAR 0 3
16965: RET
// export function Count ( array ) ; var i ; begin
16966: LD_INT 0
16968: PPUSH
16969: PPUSH
// result := 0 ;
16970: LD_ADDR_VAR 0 2
16974: PUSH
16975: LD_INT 0
16977: ST_TO_ADDR
// for i in array do
16978: LD_ADDR_VAR 0 3
16982: PUSH
16983: LD_VAR 0 1
16987: PUSH
16988: FOR_IN
16989: IFFALSE 17013
// if i then
16991: LD_VAR 0 3
16995: IFFALSE 17011
// result := result + 1 ;
16997: LD_ADDR_VAR 0 2
17001: PUSH
17002: LD_VAR 0 2
17006: PUSH
17007: LD_INT 1
17009: PLUS
17010: ST_TO_ADDR
17011: GO 16988
17013: POP
17014: POP
// end ;
17015: LD_VAR 0 2
17019: RET
// export function IsEmpty ( building ) ; begin
17020: LD_INT 0
17022: PPUSH
// if not building then
17023: LD_VAR 0 1
17027: NOT
17028: IFFALSE 17032
// exit ;
17030: GO 17075
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17032: LD_ADDR_VAR 0 2
17036: PUSH
17037: LD_VAR 0 1
17041: PUSH
17042: LD_INT 22
17044: PUSH
17045: LD_VAR 0 1
17049: PPUSH
17050: CALL_OW 255
17054: PUSH
17055: EMPTY
17056: LIST
17057: LIST
17058: PUSH
17059: LD_INT 58
17061: PUSH
17062: EMPTY
17063: LIST
17064: PUSH
17065: EMPTY
17066: LIST
17067: LIST
17068: PPUSH
17069: CALL_OW 69
17073: IN
17074: ST_TO_ADDR
// end ;
17075: LD_VAR 0 2
17079: RET
// export function IsNotFull ( building ) ; var places ; begin
17080: LD_INT 0
17082: PPUSH
17083: PPUSH
// if not building then
17084: LD_VAR 0 1
17088: NOT
17089: IFFALSE 17093
// exit ;
17091: GO 17264
// result := false ;
17093: LD_ADDR_VAR 0 2
17097: PUSH
17098: LD_INT 0
17100: ST_TO_ADDR
// places := 0 ;
17101: LD_ADDR_VAR 0 3
17105: PUSH
17106: LD_INT 0
17108: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
17109: LD_VAR 0 1
17113: PPUSH
17114: CALL_OW 266
17118: PUSH
17119: LD_INT 0
17121: DOUBLE
17122: EQUAL
17123: IFTRUE 17181
17125: LD_INT 1
17127: DOUBLE
17128: EQUAL
17129: IFTRUE 17181
17131: LD_INT 6
17133: DOUBLE
17134: EQUAL
17135: IFTRUE 17181
17137: LD_INT 7
17139: DOUBLE
17140: EQUAL
17141: IFTRUE 17181
17143: LD_INT 8
17145: DOUBLE
17146: EQUAL
17147: IFTRUE 17181
17149: LD_INT 4
17151: DOUBLE
17152: EQUAL
17153: IFTRUE 17181
17155: LD_INT 5
17157: DOUBLE
17158: EQUAL
17159: IFTRUE 17181
17161: LD_INT 2
17163: DOUBLE
17164: EQUAL
17165: IFTRUE 17181
17167: LD_INT 3
17169: DOUBLE
17170: EQUAL
17171: IFTRUE 17181
17173: LD_INT 35
17175: DOUBLE
17176: EQUAL
17177: IFTRUE 17181
17179: GO 17192
17181: POP
// places := 6 ; b_bunker , b_breastwork :
17182: LD_ADDR_VAR 0 3
17186: PUSH
17187: LD_INT 6
17189: ST_TO_ADDR
17190: GO 17237
17192: LD_INT 32
17194: DOUBLE
17195: EQUAL
17196: IFTRUE 17206
17198: LD_INT 31
17200: DOUBLE
17201: EQUAL
17202: IFTRUE 17206
17204: GO 17217
17206: POP
// places := 1 ; b_control_tower :
17207: LD_ADDR_VAR 0 3
17211: PUSH
17212: LD_INT 1
17214: ST_TO_ADDR
17215: GO 17237
17217: LD_INT 36
17219: DOUBLE
17220: EQUAL
17221: IFTRUE 17225
17223: GO 17236
17225: POP
// places := 3 ; end ;
17226: LD_ADDR_VAR 0 3
17230: PUSH
17231: LD_INT 3
17233: ST_TO_ADDR
17234: GO 17237
17236: POP
// if places then
17237: LD_VAR 0 3
17241: IFFALSE 17264
// result := UnitsInside ( building ) < places ;
17243: LD_ADDR_VAR 0 2
17247: PUSH
17248: LD_VAR 0 1
17252: PPUSH
17253: CALL_OW 313
17257: PUSH
17258: LD_VAR 0 3
17262: LESS
17263: ST_TO_ADDR
// end ;
17264: LD_VAR 0 2
17268: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17269: LD_INT 0
17271: PPUSH
17272: PPUSH
17273: PPUSH
17274: PPUSH
// tmp := [ ] ;
17275: LD_ADDR_VAR 0 3
17279: PUSH
17280: EMPTY
17281: ST_TO_ADDR
// list := [ ] ;
17282: LD_ADDR_VAR 0 5
17286: PUSH
17287: EMPTY
17288: ST_TO_ADDR
// for i = 16 to 25 do
17289: LD_ADDR_VAR 0 4
17293: PUSH
17294: DOUBLE
17295: LD_INT 16
17297: DEC
17298: ST_TO_ADDR
17299: LD_INT 25
17301: PUSH
17302: FOR_TO
17303: IFFALSE 17376
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17305: LD_ADDR_VAR 0 3
17309: PUSH
17310: LD_VAR 0 3
17314: PUSH
17315: LD_INT 22
17317: PUSH
17318: LD_VAR 0 1
17322: PPUSH
17323: CALL_OW 255
17327: PUSH
17328: EMPTY
17329: LIST
17330: LIST
17331: PUSH
17332: LD_INT 91
17334: PUSH
17335: LD_VAR 0 1
17339: PUSH
17340: LD_INT 6
17342: PUSH
17343: EMPTY
17344: LIST
17345: LIST
17346: LIST
17347: PUSH
17348: LD_INT 30
17350: PUSH
17351: LD_VAR 0 4
17355: PUSH
17356: EMPTY
17357: LIST
17358: LIST
17359: PUSH
17360: EMPTY
17361: LIST
17362: LIST
17363: LIST
17364: PUSH
17365: EMPTY
17366: LIST
17367: PPUSH
17368: CALL_OW 69
17372: ADD
17373: ST_TO_ADDR
17374: GO 17302
17376: POP
17377: POP
// for i = 1 to tmp do
17378: LD_ADDR_VAR 0 4
17382: PUSH
17383: DOUBLE
17384: LD_INT 1
17386: DEC
17387: ST_TO_ADDR
17388: LD_VAR 0 3
17392: PUSH
17393: FOR_TO
17394: IFFALSE 17482
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17396: LD_ADDR_VAR 0 5
17400: PUSH
17401: LD_VAR 0 5
17405: PUSH
17406: LD_VAR 0 3
17410: PUSH
17411: LD_VAR 0 4
17415: ARRAY
17416: PPUSH
17417: CALL_OW 266
17421: PUSH
17422: LD_VAR 0 3
17426: PUSH
17427: LD_VAR 0 4
17431: ARRAY
17432: PPUSH
17433: CALL_OW 250
17437: PUSH
17438: LD_VAR 0 3
17442: PUSH
17443: LD_VAR 0 4
17447: ARRAY
17448: PPUSH
17449: CALL_OW 251
17453: PUSH
17454: LD_VAR 0 3
17458: PUSH
17459: LD_VAR 0 4
17463: ARRAY
17464: PPUSH
17465: CALL_OW 254
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: LIST
17474: LIST
17475: PUSH
17476: EMPTY
17477: LIST
17478: ADD
17479: ST_TO_ADDR
17480: GO 17393
17482: POP
17483: POP
// result := list ;
17484: LD_ADDR_VAR 0 2
17488: PUSH
17489: LD_VAR 0 5
17493: ST_TO_ADDR
// end ;
17494: LD_VAR 0 2
17498: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17499: LD_INT 0
17501: PPUSH
17502: PPUSH
17503: PPUSH
17504: PPUSH
17505: PPUSH
17506: PPUSH
17507: PPUSH
// if not factory then
17508: LD_VAR 0 1
17512: NOT
17513: IFFALSE 17517
// exit ;
17515: GO 18110
// if control = control_apeman then
17517: LD_VAR 0 4
17521: PUSH
17522: LD_INT 5
17524: EQUAL
17525: IFFALSE 17634
// begin tmp := UnitsInside ( factory ) ;
17527: LD_ADDR_VAR 0 8
17531: PUSH
17532: LD_VAR 0 1
17536: PPUSH
17537: CALL_OW 313
17541: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
17542: LD_VAR 0 8
17546: PPUSH
17547: LD_INT 25
17549: PUSH
17550: LD_INT 12
17552: PUSH
17553: EMPTY
17554: LIST
17555: LIST
17556: PPUSH
17557: CALL_OW 72
17561: NOT
17562: IFFALSE 17572
// control := control_manual ;
17564: LD_ADDR_VAR 0 4
17568: PUSH
17569: LD_INT 1
17571: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
17572: LD_ADDR_VAR 0 8
17576: PUSH
17577: LD_VAR 0 1
17581: PPUSH
17582: CALL 17269 0 1
17586: ST_TO_ADDR
// if tmp then
17587: LD_VAR 0 8
17591: IFFALSE 17634
// begin for i in tmp do
17593: LD_ADDR_VAR 0 7
17597: PUSH
17598: LD_VAR 0 8
17602: PUSH
17603: FOR_IN
17604: IFFALSE 17632
// if i [ 1 ] = b_ext_radio then
17606: LD_VAR 0 7
17610: PUSH
17611: LD_INT 1
17613: ARRAY
17614: PUSH
17615: LD_INT 22
17617: EQUAL
17618: IFFALSE 17630
// begin control := control_remote ;
17620: LD_ADDR_VAR 0 4
17624: PUSH
17625: LD_INT 2
17627: ST_TO_ADDR
// break ;
17628: GO 17632
// end ;
17630: GO 17603
17632: POP
17633: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17634: LD_VAR 0 1
17638: PPUSH
17639: LD_VAR 0 2
17643: PPUSH
17644: LD_VAR 0 3
17648: PPUSH
17649: LD_VAR 0 4
17653: PPUSH
17654: LD_VAR 0 5
17658: PPUSH
17659: CALL_OW 448
17663: IFFALSE 17698
// begin result := [ chassis , engine , control , weapon ] ;
17665: LD_ADDR_VAR 0 6
17669: PUSH
17670: LD_VAR 0 2
17674: PUSH
17675: LD_VAR 0 3
17679: PUSH
17680: LD_VAR 0 4
17684: PUSH
17685: LD_VAR 0 5
17689: PUSH
17690: EMPTY
17691: LIST
17692: LIST
17693: LIST
17694: LIST
17695: ST_TO_ADDR
// exit ;
17696: GO 18110
// end ; _chassis := AvailableChassisList ( factory ) ;
17698: LD_ADDR_VAR 0 9
17702: PUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: CALL_OW 475
17712: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17713: LD_ADDR_VAR 0 11
17717: PUSH
17718: LD_VAR 0 1
17722: PPUSH
17723: CALL_OW 476
17727: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17728: LD_ADDR_VAR 0 12
17732: PUSH
17733: LD_VAR 0 1
17737: PPUSH
17738: CALL_OW 477
17742: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17743: LD_ADDR_VAR 0 10
17747: PUSH
17748: LD_VAR 0 1
17752: PPUSH
17753: CALL_OW 478
17757: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17758: LD_VAR 0 9
17762: NOT
17763: PUSH
17764: LD_VAR 0 11
17768: NOT
17769: OR
17770: PUSH
17771: LD_VAR 0 12
17775: NOT
17776: OR
17777: PUSH
17778: LD_VAR 0 10
17782: NOT
17783: OR
17784: IFFALSE 17819
// begin result := [ chassis , engine , control , weapon ] ;
17786: LD_ADDR_VAR 0 6
17790: PUSH
17791: LD_VAR 0 2
17795: PUSH
17796: LD_VAR 0 3
17800: PUSH
17801: LD_VAR 0 4
17805: PUSH
17806: LD_VAR 0 5
17810: PUSH
17811: EMPTY
17812: LIST
17813: LIST
17814: LIST
17815: LIST
17816: ST_TO_ADDR
// exit ;
17817: GO 18110
// end ; if not chassis in _chassis then
17819: LD_VAR 0 2
17823: PUSH
17824: LD_VAR 0 9
17828: IN
17829: NOT
17830: IFFALSE 17856
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17832: LD_ADDR_VAR 0 2
17836: PUSH
17837: LD_VAR 0 9
17841: PUSH
17842: LD_INT 1
17844: PPUSH
17845: LD_VAR 0 9
17849: PPUSH
17850: CALL_OW 12
17854: ARRAY
17855: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17856: LD_VAR 0 2
17860: PPUSH
17861: LD_VAR 0 3
17865: PPUSH
17866: CALL 18115 0 2
17870: NOT
17871: IFFALSE 17930
// repeat engine := _engine [ 1 ] ;
17873: LD_ADDR_VAR 0 3
17877: PUSH
17878: LD_VAR 0 11
17882: PUSH
17883: LD_INT 1
17885: ARRAY
17886: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17887: LD_ADDR_VAR 0 11
17891: PUSH
17892: LD_VAR 0 11
17896: PPUSH
17897: LD_INT 1
17899: PPUSH
17900: CALL_OW 3
17904: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17905: LD_VAR 0 2
17909: PPUSH
17910: LD_VAR 0 3
17914: PPUSH
17915: CALL 18115 0 2
17919: PUSH
17920: LD_VAR 0 11
17924: PUSH
17925: EMPTY
17926: EQUAL
17927: OR
17928: IFFALSE 17873
// if not control in _control then
17930: LD_VAR 0 4
17934: PUSH
17935: LD_VAR 0 12
17939: IN
17940: NOT
17941: IFFALSE 17967
// control := _control [ rand ( 1 , _control ) ] ;
17943: LD_ADDR_VAR 0 4
17947: PUSH
17948: LD_VAR 0 12
17952: PUSH
17953: LD_INT 1
17955: PPUSH
17956: LD_VAR 0 12
17960: PPUSH
17961: CALL_OW 12
17965: ARRAY
17966: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17967: LD_VAR 0 2
17971: PPUSH
17972: LD_VAR 0 5
17976: PPUSH
17977: CALL 18335 0 2
17981: NOT
17982: IFFALSE 18041
// repeat weapon := _weapon [ 1 ] ;
17984: LD_ADDR_VAR 0 5
17988: PUSH
17989: LD_VAR 0 10
17993: PUSH
17994: LD_INT 1
17996: ARRAY
17997: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17998: LD_ADDR_VAR 0 10
18002: PUSH
18003: LD_VAR 0 10
18007: PPUSH
18008: LD_INT 1
18010: PPUSH
18011: CALL_OW 3
18015: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18016: LD_VAR 0 2
18020: PPUSH
18021: LD_VAR 0 5
18025: PPUSH
18026: CALL 18335 0 2
18030: PUSH
18031: LD_VAR 0 10
18035: PUSH
18036: EMPTY
18037: EQUAL
18038: OR
18039: IFFALSE 17984
// result := [ ] ;
18041: LD_ADDR_VAR 0 6
18045: PUSH
18046: EMPTY
18047: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18048: LD_VAR 0 1
18052: PPUSH
18053: LD_VAR 0 2
18057: PPUSH
18058: LD_VAR 0 3
18062: PPUSH
18063: LD_VAR 0 4
18067: PPUSH
18068: LD_VAR 0 5
18072: PPUSH
18073: CALL_OW 448
18077: IFFALSE 18110
// result := [ chassis , engine , control , weapon ] ;
18079: LD_ADDR_VAR 0 6
18083: PUSH
18084: LD_VAR 0 2
18088: PUSH
18089: LD_VAR 0 3
18093: PUSH
18094: LD_VAR 0 4
18098: PUSH
18099: LD_VAR 0 5
18103: PUSH
18104: EMPTY
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: ST_TO_ADDR
// end ;
18110: LD_VAR 0 6
18114: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18115: LD_INT 0
18117: PPUSH
// if not chassis or not engine then
18118: LD_VAR 0 1
18122: NOT
18123: PUSH
18124: LD_VAR 0 2
18128: NOT
18129: OR
18130: IFFALSE 18134
// exit ;
18132: GO 18330
// case engine of engine_solar :
18134: LD_VAR 0 2
18138: PUSH
18139: LD_INT 2
18141: DOUBLE
18142: EQUAL
18143: IFTRUE 18147
18145: GO 18185
18147: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18148: LD_ADDR_VAR 0 3
18152: PUSH
18153: LD_INT 11
18155: PUSH
18156: LD_INT 12
18158: PUSH
18159: LD_INT 13
18161: PUSH
18162: LD_INT 14
18164: PUSH
18165: LD_INT 1
18167: PUSH
18168: LD_INT 2
18170: PUSH
18171: LD_INT 3
18173: PUSH
18174: EMPTY
18175: LIST
18176: LIST
18177: LIST
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: ST_TO_ADDR
18183: GO 18314
18185: LD_INT 1
18187: DOUBLE
18188: EQUAL
18189: IFTRUE 18193
18191: GO 18255
18193: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18194: LD_ADDR_VAR 0 3
18198: PUSH
18199: LD_INT 11
18201: PUSH
18202: LD_INT 12
18204: PUSH
18205: LD_INT 13
18207: PUSH
18208: LD_INT 14
18210: PUSH
18211: LD_INT 1
18213: PUSH
18214: LD_INT 2
18216: PUSH
18217: LD_INT 3
18219: PUSH
18220: LD_INT 4
18222: PUSH
18223: LD_INT 5
18225: PUSH
18226: LD_INT 21
18228: PUSH
18229: LD_INT 23
18231: PUSH
18232: LD_INT 22
18234: PUSH
18235: LD_INT 24
18237: PUSH
18238: EMPTY
18239: LIST
18240: LIST
18241: LIST
18242: LIST
18243: LIST
18244: LIST
18245: LIST
18246: LIST
18247: LIST
18248: LIST
18249: LIST
18250: LIST
18251: LIST
18252: ST_TO_ADDR
18253: GO 18314
18255: LD_INT 3
18257: DOUBLE
18258: EQUAL
18259: IFTRUE 18263
18261: GO 18313
18263: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18264: LD_ADDR_VAR 0 3
18268: PUSH
18269: LD_INT 13
18271: PUSH
18272: LD_INT 14
18274: PUSH
18275: LD_INT 2
18277: PUSH
18278: LD_INT 3
18280: PUSH
18281: LD_INT 4
18283: PUSH
18284: LD_INT 5
18286: PUSH
18287: LD_INT 21
18289: PUSH
18290: LD_INT 22
18292: PUSH
18293: LD_INT 23
18295: PUSH
18296: LD_INT 24
18298: PUSH
18299: EMPTY
18300: LIST
18301: LIST
18302: LIST
18303: LIST
18304: LIST
18305: LIST
18306: LIST
18307: LIST
18308: LIST
18309: LIST
18310: ST_TO_ADDR
18311: GO 18314
18313: POP
// result := ( chassis in result ) ;
18314: LD_ADDR_VAR 0 3
18318: PUSH
18319: LD_VAR 0 1
18323: PUSH
18324: LD_VAR 0 3
18328: IN
18329: ST_TO_ADDR
// end ;
18330: LD_VAR 0 3
18334: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18335: LD_INT 0
18337: PPUSH
// if not chassis or not weapon then
18338: LD_VAR 0 1
18342: NOT
18343: PUSH
18344: LD_VAR 0 2
18348: NOT
18349: OR
18350: IFFALSE 18354
// exit ;
18352: GO 19416
// case weapon of us_machine_gun :
18354: LD_VAR 0 2
18358: PUSH
18359: LD_INT 2
18361: DOUBLE
18362: EQUAL
18363: IFTRUE 18367
18365: GO 18397
18367: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18368: LD_ADDR_VAR 0 3
18372: PUSH
18373: LD_INT 1
18375: PUSH
18376: LD_INT 2
18378: PUSH
18379: LD_INT 3
18381: PUSH
18382: LD_INT 4
18384: PUSH
18385: LD_INT 5
18387: PUSH
18388: EMPTY
18389: LIST
18390: LIST
18391: LIST
18392: LIST
18393: LIST
18394: ST_TO_ADDR
18395: GO 19400
18397: LD_INT 3
18399: DOUBLE
18400: EQUAL
18401: IFTRUE 18405
18403: GO 18435
18405: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18406: LD_ADDR_VAR 0 3
18410: PUSH
18411: LD_INT 1
18413: PUSH
18414: LD_INT 2
18416: PUSH
18417: LD_INT 3
18419: PUSH
18420: LD_INT 4
18422: PUSH
18423: LD_INT 5
18425: PUSH
18426: EMPTY
18427: LIST
18428: LIST
18429: LIST
18430: LIST
18431: LIST
18432: ST_TO_ADDR
18433: GO 19400
18435: LD_INT 11
18437: DOUBLE
18438: EQUAL
18439: IFTRUE 18443
18441: GO 18473
18443: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18444: LD_ADDR_VAR 0 3
18448: PUSH
18449: LD_INT 1
18451: PUSH
18452: LD_INT 2
18454: PUSH
18455: LD_INT 3
18457: PUSH
18458: LD_INT 4
18460: PUSH
18461: LD_INT 5
18463: PUSH
18464: EMPTY
18465: LIST
18466: LIST
18467: LIST
18468: LIST
18469: LIST
18470: ST_TO_ADDR
18471: GO 19400
18473: LD_INT 4
18475: DOUBLE
18476: EQUAL
18477: IFTRUE 18481
18479: GO 18507
18481: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18482: LD_ADDR_VAR 0 3
18486: PUSH
18487: LD_INT 2
18489: PUSH
18490: LD_INT 3
18492: PUSH
18493: LD_INT 4
18495: PUSH
18496: LD_INT 5
18498: PUSH
18499: EMPTY
18500: LIST
18501: LIST
18502: LIST
18503: LIST
18504: ST_TO_ADDR
18505: GO 19400
18507: LD_INT 5
18509: DOUBLE
18510: EQUAL
18511: IFTRUE 18515
18513: GO 18541
18515: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18516: LD_ADDR_VAR 0 3
18520: PUSH
18521: LD_INT 2
18523: PUSH
18524: LD_INT 3
18526: PUSH
18527: LD_INT 4
18529: PUSH
18530: LD_INT 5
18532: PUSH
18533: EMPTY
18534: LIST
18535: LIST
18536: LIST
18537: LIST
18538: ST_TO_ADDR
18539: GO 19400
18541: LD_INT 9
18543: DOUBLE
18544: EQUAL
18545: IFTRUE 18549
18547: GO 18575
18549: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
18550: LD_ADDR_VAR 0 3
18554: PUSH
18555: LD_INT 2
18557: PUSH
18558: LD_INT 3
18560: PUSH
18561: LD_INT 4
18563: PUSH
18564: LD_INT 5
18566: PUSH
18567: EMPTY
18568: LIST
18569: LIST
18570: LIST
18571: LIST
18572: ST_TO_ADDR
18573: GO 19400
18575: LD_INT 7
18577: DOUBLE
18578: EQUAL
18579: IFTRUE 18583
18581: GO 18609
18583: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
18584: LD_ADDR_VAR 0 3
18588: PUSH
18589: LD_INT 2
18591: PUSH
18592: LD_INT 3
18594: PUSH
18595: LD_INT 4
18597: PUSH
18598: LD_INT 5
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: LIST
18605: LIST
18606: ST_TO_ADDR
18607: GO 19400
18609: LD_INT 12
18611: DOUBLE
18612: EQUAL
18613: IFTRUE 18617
18615: GO 18643
18617: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
18618: LD_ADDR_VAR 0 3
18622: PUSH
18623: LD_INT 2
18625: PUSH
18626: LD_INT 3
18628: PUSH
18629: LD_INT 4
18631: PUSH
18632: LD_INT 5
18634: PUSH
18635: EMPTY
18636: LIST
18637: LIST
18638: LIST
18639: LIST
18640: ST_TO_ADDR
18641: GO 19400
18643: LD_INT 13
18645: DOUBLE
18646: EQUAL
18647: IFTRUE 18651
18649: GO 18677
18651: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
18652: LD_ADDR_VAR 0 3
18656: PUSH
18657: LD_INT 2
18659: PUSH
18660: LD_INT 3
18662: PUSH
18663: LD_INT 4
18665: PUSH
18666: LD_INT 5
18668: PUSH
18669: EMPTY
18670: LIST
18671: LIST
18672: LIST
18673: LIST
18674: ST_TO_ADDR
18675: GO 19400
18677: LD_INT 14
18679: DOUBLE
18680: EQUAL
18681: IFTRUE 18685
18683: GO 18703
18685: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18686: LD_ADDR_VAR 0 3
18690: PUSH
18691: LD_INT 4
18693: PUSH
18694: LD_INT 5
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: ST_TO_ADDR
18701: GO 19400
18703: LD_INT 6
18705: DOUBLE
18706: EQUAL
18707: IFTRUE 18711
18709: GO 18729
18711: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18712: LD_ADDR_VAR 0 3
18716: PUSH
18717: LD_INT 4
18719: PUSH
18720: LD_INT 5
18722: PUSH
18723: EMPTY
18724: LIST
18725: LIST
18726: ST_TO_ADDR
18727: GO 19400
18729: LD_INT 10
18731: DOUBLE
18732: EQUAL
18733: IFTRUE 18737
18735: GO 18755
18737: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18738: LD_ADDR_VAR 0 3
18742: PUSH
18743: LD_INT 4
18745: PUSH
18746: LD_INT 5
18748: PUSH
18749: EMPTY
18750: LIST
18751: LIST
18752: ST_TO_ADDR
18753: GO 19400
18755: LD_INT 22
18757: DOUBLE
18758: EQUAL
18759: IFTRUE 18763
18761: GO 18789
18763: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18764: LD_ADDR_VAR 0 3
18768: PUSH
18769: LD_INT 11
18771: PUSH
18772: LD_INT 12
18774: PUSH
18775: LD_INT 13
18777: PUSH
18778: LD_INT 14
18780: PUSH
18781: EMPTY
18782: LIST
18783: LIST
18784: LIST
18785: LIST
18786: ST_TO_ADDR
18787: GO 19400
18789: LD_INT 23
18791: DOUBLE
18792: EQUAL
18793: IFTRUE 18797
18795: GO 18823
18797: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18798: LD_ADDR_VAR 0 3
18802: PUSH
18803: LD_INT 11
18805: PUSH
18806: LD_INT 12
18808: PUSH
18809: LD_INT 13
18811: PUSH
18812: LD_INT 14
18814: PUSH
18815: EMPTY
18816: LIST
18817: LIST
18818: LIST
18819: LIST
18820: ST_TO_ADDR
18821: GO 19400
18823: LD_INT 24
18825: DOUBLE
18826: EQUAL
18827: IFTRUE 18831
18829: GO 18857
18831: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18832: LD_ADDR_VAR 0 3
18836: PUSH
18837: LD_INT 11
18839: PUSH
18840: LD_INT 12
18842: PUSH
18843: LD_INT 13
18845: PUSH
18846: LD_INT 14
18848: PUSH
18849: EMPTY
18850: LIST
18851: LIST
18852: LIST
18853: LIST
18854: ST_TO_ADDR
18855: GO 19400
18857: LD_INT 30
18859: DOUBLE
18860: EQUAL
18861: IFTRUE 18865
18863: GO 18891
18865: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18866: LD_ADDR_VAR 0 3
18870: PUSH
18871: LD_INT 11
18873: PUSH
18874: LD_INT 12
18876: PUSH
18877: LD_INT 13
18879: PUSH
18880: LD_INT 14
18882: PUSH
18883: EMPTY
18884: LIST
18885: LIST
18886: LIST
18887: LIST
18888: ST_TO_ADDR
18889: GO 19400
18891: LD_INT 25
18893: DOUBLE
18894: EQUAL
18895: IFTRUE 18899
18897: GO 18917
18899: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18900: LD_ADDR_VAR 0 3
18904: PUSH
18905: LD_INT 13
18907: PUSH
18908: LD_INT 14
18910: PUSH
18911: EMPTY
18912: LIST
18913: LIST
18914: ST_TO_ADDR
18915: GO 19400
18917: LD_INT 27
18919: DOUBLE
18920: EQUAL
18921: IFTRUE 18925
18923: GO 18943
18925: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
18926: LD_ADDR_VAR 0 3
18930: PUSH
18931: LD_INT 13
18933: PUSH
18934: LD_INT 14
18936: PUSH
18937: EMPTY
18938: LIST
18939: LIST
18940: ST_TO_ADDR
18941: GO 19400
18943: LD_EXP 109
18947: DOUBLE
18948: EQUAL
18949: IFTRUE 18953
18951: GO 18979
18953: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18954: LD_ADDR_VAR 0 3
18958: PUSH
18959: LD_INT 11
18961: PUSH
18962: LD_INT 12
18964: PUSH
18965: LD_INT 13
18967: PUSH
18968: LD_INT 14
18970: PUSH
18971: EMPTY
18972: LIST
18973: LIST
18974: LIST
18975: LIST
18976: ST_TO_ADDR
18977: GO 19400
18979: LD_INT 28
18981: DOUBLE
18982: EQUAL
18983: IFTRUE 18987
18985: GO 19005
18987: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18988: LD_ADDR_VAR 0 3
18992: PUSH
18993: LD_INT 13
18995: PUSH
18996: LD_INT 14
18998: PUSH
18999: EMPTY
19000: LIST
19001: LIST
19002: ST_TO_ADDR
19003: GO 19400
19005: LD_INT 29
19007: DOUBLE
19008: EQUAL
19009: IFTRUE 19013
19011: GO 19031
19013: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19014: LD_ADDR_VAR 0 3
19018: PUSH
19019: LD_INT 13
19021: PUSH
19022: LD_INT 14
19024: PUSH
19025: EMPTY
19026: LIST
19027: LIST
19028: ST_TO_ADDR
19029: GO 19400
19031: LD_INT 31
19033: DOUBLE
19034: EQUAL
19035: IFTRUE 19039
19037: GO 19057
19039: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19040: LD_ADDR_VAR 0 3
19044: PUSH
19045: LD_INT 13
19047: PUSH
19048: LD_INT 14
19050: PUSH
19051: EMPTY
19052: LIST
19053: LIST
19054: ST_TO_ADDR
19055: GO 19400
19057: LD_INT 26
19059: DOUBLE
19060: EQUAL
19061: IFTRUE 19065
19063: GO 19083
19065: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19066: LD_ADDR_VAR 0 3
19070: PUSH
19071: LD_INT 13
19073: PUSH
19074: LD_INT 14
19076: PUSH
19077: EMPTY
19078: LIST
19079: LIST
19080: ST_TO_ADDR
19081: GO 19400
19083: LD_INT 42
19085: DOUBLE
19086: EQUAL
19087: IFTRUE 19091
19089: GO 19117
19091: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19092: LD_ADDR_VAR 0 3
19096: PUSH
19097: LD_INT 21
19099: PUSH
19100: LD_INT 22
19102: PUSH
19103: LD_INT 23
19105: PUSH
19106: LD_INT 24
19108: PUSH
19109: EMPTY
19110: LIST
19111: LIST
19112: LIST
19113: LIST
19114: ST_TO_ADDR
19115: GO 19400
19117: LD_INT 43
19119: DOUBLE
19120: EQUAL
19121: IFTRUE 19125
19123: GO 19151
19125: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19126: LD_ADDR_VAR 0 3
19130: PUSH
19131: LD_INT 21
19133: PUSH
19134: LD_INT 22
19136: PUSH
19137: LD_INT 23
19139: PUSH
19140: LD_INT 24
19142: PUSH
19143: EMPTY
19144: LIST
19145: LIST
19146: LIST
19147: LIST
19148: ST_TO_ADDR
19149: GO 19400
19151: LD_INT 44
19153: DOUBLE
19154: EQUAL
19155: IFTRUE 19159
19157: GO 19185
19159: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19160: LD_ADDR_VAR 0 3
19164: PUSH
19165: LD_INT 21
19167: PUSH
19168: LD_INT 22
19170: PUSH
19171: LD_INT 23
19173: PUSH
19174: LD_INT 24
19176: PUSH
19177: EMPTY
19178: LIST
19179: LIST
19180: LIST
19181: LIST
19182: ST_TO_ADDR
19183: GO 19400
19185: LD_INT 45
19187: DOUBLE
19188: EQUAL
19189: IFTRUE 19193
19191: GO 19219
19193: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19194: LD_ADDR_VAR 0 3
19198: PUSH
19199: LD_INT 21
19201: PUSH
19202: LD_INT 22
19204: PUSH
19205: LD_INT 23
19207: PUSH
19208: LD_INT 24
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: LIST
19215: LIST
19216: ST_TO_ADDR
19217: GO 19400
19219: LD_INT 49
19221: DOUBLE
19222: EQUAL
19223: IFTRUE 19227
19225: GO 19253
19227: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19228: LD_ADDR_VAR 0 3
19232: PUSH
19233: LD_INT 21
19235: PUSH
19236: LD_INT 22
19238: PUSH
19239: LD_INT 23
19241: PUSH
19242: LD_INT 24
19244: PUSH
19245: EMPTY
19246: LIST
19247: LIST
19248: LIST
19249: LIST
19250: ST_TO_ADDR
19251: GO 19400
19253: LD_INT 51
19255: DOUBLE
19256: EQUAL
19257: IFTRUE 19261
19259: GO 19287
19261: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19262: LD_ADDR_VAR 0 3
19266: PUSH
19267: LD_INT 21
19269: PUSH
19270: LD_INT 22
19272: PUSH
19273: LD_INT 23
19275: PUSH
19276: LD_INT 24
19278: PUSH
19279: EMPTY
19280: LIST
19281: LIST
19282: LIST
19283: LIST
19284: ST_TO_ADDR
19285: GO 19400
19287: LD_INT 52
19289: DOUBLE
19290: EQUAL
19291: IFTRUE 19295
19293: GO 19321
19295: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19296: LD_ADDR_VAR 0 3
19300: PUSH
19301: LD_INT 21
19303: PUSH
19304: LD_INT 22
19306: PUSH
19307: LD_INT 23
19309: PUSH
19310: LD_INT 24
19312: PUSH
19313: EMPTY
19314: LIST
19315: LIST
19316: LIST
19317: LIST
19318: ST_TO_ADDR
19319: GO 19400
19321: LD_INT 53
19323: DOUBLE
19324: EQUAL
19325: IFTRUE 19329
19327: GO 19347
19329: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19330: LD_ADDR_VAR 0 3
19334: PUSH
19335: LD_INT 23
19337: PUSH
19338: LD_INT 24
19340: PUSH
19341: EMPTY
19342: LIST
19343: LIST
19344: ST_TO_ADDR
19345: GO 19400
19347: LD_INT 46
19349: DOUBLE
19350: EQUAL
19351: IFTRUE 19355
19353: GO 19373
19355: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19356: LD_ADDR_VAR 0 3
19360: PUSH
19361: LD_INT 23
19363: PUSH
19364: LD_INT 24
19366: PUSH
19367: EMPTY
19368: LIST
19369: LIST
19370: ST_TO_ADDR
19371: GO 19400
19373: LD_INT 47
19375: DOUBLE
19376: EQUAL
19377: IFTRUE 19381
19379: GO 19399
19381: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19382: LD_ADDR_VAR 0 3
19386: PUSH
19387: LD_INT 23
19389: PUSH
19390: LD_INT 24
19392: PUSH
19393: EMPTY
19394: LIST
19395: LIST
19396: ST_TO_ADDR
19397: GO 19400
19399: POP
// result := ( chassis in result ) ;
19400: LD_ADDR_VAR 0 3
19404: PUSH
19405: LD_VAR 0 1
19409: PUSH
19410: LD_VAR 0 3
19414: IN
19415: ST_TO_ADDR
// end ;
19416: LD_VAR 0 3
19420: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19421: LD_INT 0
19423: PPUSH
19424: PPUSH
19425: PPUSH
19426: PPUSH
19427: PPUSH
19428: PPUSH
19429: PPUSH
// result := array ;
19430: LD_ADDR_VAR 0 5
19434: PUSH
19435: LD_VAR 0 1
19439: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19440: LD_VAR 0 1
19444: NOT
19445: PUSH
19446: LD_VAR 0 2
19450: NOT
19451: OR
19452: PUSH
19453: LD_VAR 0 3
19457: NOT
19458: OR
19459: PUSH
19460: LD_VAR 0 2
19464: PUSH
19465: LD_VAR 0 1
19469: GREATER
19470: OR
19471: PUSH
19472: LD_VAR 0 3
19476: PUSH
19477: LD_VAR 0 1
19481: GREATER
19482: OR
19483: IFFALSE 19487
// exit ;
19485: GO 19783
// if direction then
19487: LD_VAR 0 4
19491: IFFALSE 19555
// begin d := 1 ;
19493: LD_ADDR_VAR 0 9
19497: PUSH
19498: LD_INT 1
19500: ST_TO_ADDR
// if i_from > i_to then
19501: LD_VAR 0 2
19505: PUSH
19506: LD_VAR 0 3
19510: GREATER
19511: IFFALSE 19537
// length := ( array - i_from ) + i_to else
19513: LD_ADDR_VAR 0 11
19517: PUSH
19518: LD_VAR 0 1
19522: PUSH
19523: LD_VAR 0 2
19527: MINUS
19528: PUSH
19529: LD_VAR 0 3
19533: PLUS
19534: ST_TO_ADDR
19535: GO 19553
// length := i_to - i_from ;
19537: LD_ADDR_VAR 0 11
19541: PUSH
19542: LD_VAR 0 3
19546: PUSH
19547: LD_VAR 0 2
19551: MINUS
19552: ST_TO_ADDR
// end else
19553: GO 19616
// begin d := - 1 ;
19555: LD_ADDR_VAR 0 9
19559: PUSH
19560: LD_INT 1
19562: NEG
19563: ST_TO_ADDR
// if i_from > i_to then
19564: LD_VAR 0 2
19568: PUSH
19569: LD_VAR 0 3
19573: GREATER
19574: IFFALSE 19594
// length := i_from - i_to else
19576: LD_ADDR_VAR 0 11
19580: PUSH
19581: LD_VAR 0 2
19585: PUSH
19586: LD_VAR 0 3
19590: MINUS
19591: ST_TO_ADDR
19592: GO 19616
// length := ( array - i_to ) + i_from ;
19594: LD_ADDR_VAR 0 11
19598: PUSH
19599: LD_VAR 0 1
19603: PUSH
19604: LD_VAR 0 3
19608: MINUS
19609: PUSH
19610: LD_VAR 0 2
19614: PLUS
19615: ST_TO_ADDR
// end ; if not length then
19616: LD_VAR 0 11
19620: NOT
19621: IFFALSE 19625
// exit ;
19623: GO 19783
// tmp := array ;
19625: LD_ADDR_VAR 0 10
19629: PUSH
19630: LD_VAR 0 1
19634: ST_TO_ADDR
// for i = 1 to length do
19635: LD_ADDR_VAR 0 6
19639: PUSH
19640: DOUBLE
19641: LD_INT 1
19643: DEC
19644: ST_TO_ADDR
19645: LD_VAR 0 11
19649: PUSH
19650: FOR_TO
19651: IFFALSE 19771
// begin for j = 1 to array do
19653: LD_ADDR_VAR 0 7
19657: PUSH
19658: DOUBLE
19659: LD_INT 1
19661: DEC
19662: ST_TO_ADDR
19663: LD_VAR 0 1
19667: PUSH
19668: FOR_TO
19669: IFFALSE 19757
// begin k := j + d ;
19671: LD_ADDR_VAR 0 8
19675: PUSH
19676: LD_VAR 0 7
19680: PUSH
19681: LD_VAR 0 9
19685: PLUS
19686: ST_TO_ADDR
// if k > array then
19687: LD_VAR 0 8
19691: PUSH
19692: LD_VAR 0 1
19696: GREATER
19697: IFFALSE 19707
// k := 1 ;
19699: LD_ADDR_VAR 0 8
19703: PUSH
19704: LD_INT 1
19706: ST_TO_ADDR
// if not k then
19707: LD_VAR 0 8
19711: NOT
19712: IFFALSE 19724
// k := array ;
19714: LD_ADDR_VAR 0 8
19718: PUSH
19719: LD_VAR 0 1
19723: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19724: LD_ADDR_VAR 0 10
19728: PUSH
19729: LD_VAR 0 10
19733: PPUSH
19734: LD_VAR 0 8
19738: PPUSH
19739: LD_VAR 0 1
19743: PUSH
19744: LD_VAR 0 7
19748: ARRAY
19749: PPUSH
19750: CALL_OW 1
19754: ST_TO_ADDR
// end ;
19755: GO 19668
19757: POP
19758: POP
// array := tmp ;
19759: LD_ADDR_VAR 0 1
19763: PUSH
19764: LD_VAR 0 10
19768: ST_TO_ADDR
// end ;
19769: GO 19650
19771: POP
19772: POP
// result := array ;
19773: LD_ADDR_VAR 0 5
19777: PUSH
19778: LD_VAR 0 1
19782: ST_TO_ADDR
// end ;
19783: LD_VAR 0 5
19787: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19788: LD_INT 0
19790: PPUSH
19791: PPUSH
// result := 0 ;
19792: LD_ADDR_VAR 0 3
19796: PUSH
19797: LD_INT 0
19799: ST_TO_ADDR
// if not array or not value in array then
19800: LD_VAR 0 1
19804: NOT
19805: PUSH
19806: LD_VAR 0 2
19810: PUSH
19811: LD_VAR 0 1
19815: IN
19816: NOT
19817: OR
19818: IFFALSE 19822
// exit ;
19820: GO 19876
// for i = 1 to array do
19822: LD_ADDR_VAR 0 4
19826: PUSH
19827: DOUBLE
19828: LD_INT 1
19830: DEC
19831: ST_TO_ADDR
19832: LD_VAR 0 1
19836: PUSH
19837: FOR_TO
19838: IFFALSE 19874
// if value = array [ i ] then
19840: LD_VAR 0 2
19844: PUSH
19845: LD_VAR 0 1
19849: PUSH
19850: LD_VAR 0 4
19854: ARRAY
19855: EQUAL
19856: IFFALSE 19872
// begin result := i ;
19858: LD_ADDR_VAR 0 3
19862: PUSH
19863: LD_VAR 0 4
19867: ST_TO_ADDR
// exit ;
19868: POP
19869: POP
19870: GO 19876
// end ;
19872: GO 19837
19874: POP
19875: POP
// end ;
19876: LD_VAR 0 3
19880: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19881: LD_INT 0
19883: PPUSH
// vc_chassis := chassis ;
19884: LD_ADDR_OWVAR 37
19888: PUSH
19889: LD_VAR 0 1
19893: ST_TO_ADDR
// vc_engine := engine ;
19894: LD_ADDR_OWVAR 39
19898: PUSH
19899: LD_VAR 0 2
19903: ST_TO_ADDR
// vc_control := control ;
19904: LD_ADDR_OWVAR 38
19908: PUSH
19909: LD_VAR 0 3
19913: ST_TO_ADDR
// vc_weapon := weapon ;
19914: LD_ADDR_OWVAR 40
19918: PUSH
19919: LD_VAR 0 4
19923: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19924: LD_ADDR_OWVAR 41
19928: PUSH
19929: LD_VAR 0 5
19933: ST_TO_ADDR
// end ;
19934: LD_VAR 0 6
19938: RET
// export function WantPlant ( unit ) ; var task ; begin
19939: LD_INT 0
19941: PPUSH
19942: PPUSH
// result := false ;
19943: LD_ADDR_VAR 0 2
19947: PUSH
19948: LD_INT 0
19950: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19951: LD_ADDR_VAR 0 3
19955: PUSH
19956: LD_VAR 0 1
19960: PPUSH
19961: CALL_OW 437
19965: ST_TO_ADDR
// if task then
19966: LD_VAR 0 3
19970: IFFALSE 19998
// if task [ 1 ] [ 1 ] = p then
19972: LD_VAR 0 3
19976: PUSH
19977: LD_INT 1
19979: ARRAY
19980: PUSH
19981: LD_INT 1
19983: ARRAY
19984: PUSH
19985: LD_STRING p
19987: EQUAL
19988: IFFALSE 19998
// result := true ;
19990: LD_ADDR_VAR 0 2
19994: PUSH
19995: LD_INT 1
19997: ST_TO_ADDR
// end ;
19998: LD_VAR 0 2
20002: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20003: LD_INT 0
20005: PPUSH
20006: PPUSH
20007: PPUSH
20008: PPUSH
// if pos < 1 then
20009: LD_VAR 0 2
20013: PUSH
20014: LD_INT 1
20016: LESS
20017: IFFALSE 20021
// exit ;
20019: GO 20324
// if pos = 1 then
20021: LD_VAR 0 2
20025: PUSH
20026: LD_INT 1
20028: EQUAL
20029: IFFALSE 20062
// result := Replace ( arr , pos [ 1 ] , value ) else
20031: LD_ADDR_VAR 0 4
20035: PUSH
20036: LD_VAR 0 1
20040: PPUSH
20041: LD_VAR 0 2
20045: PUSH
20046: LD_INT 1
20048: ARRAY
20049: PPUSH
20050: LD_VAR 0 3
20054: PPUSH
20055: CALL_OW 1
20059: ST_TO_ADDR
20060: GO 20324
// begin tmp := arr ;
20062: LD_ADDR_VAR 0 6
20066: PUSH
20067: LD_VAR 0 1
20071: ST_TO_ADDR
// s_arr := [ tmp ] ;
20072: LD_ADDR_VAR 0 7
20076: PUSH
20077: LD_VAR 0 6
20081: PUSH
20082: EMPTY
20083: LIST
20084: ST_TO_ADDR
// for i = 1 to pos - 1 do
20085: LD_ADDR_VAR 0 5
20089: PUSH
20090: DOUBLE
20091: LD_INT 1
20093: DEC
20094: ST_TO_ADDR
20095: LD_VAR 0 2
20099: PUSH
20100: LD_INT 1
20102: MINUS
20103: PUSH
20104: FOR_TO
20105: IFFALSE 20150
// begin tmp := tmp [ pos [ i ] ] ;
20107: LD_ADDR_VAR 0 6
20111: PUSH
20112: LD_VAR 0 6
20116: PUSH
20117: LD_VAR 0 2
20121: PUSH
20122: LD_VAR 0 5
20126: ARRAY
20127: ARRAY
20128: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20129: LD_ADDR_VAR 0 7
20133: PUSH
20134: LD_VAR 0 7
20138: PUSH
20139: LD_VAR 0 6
20143: PUSH
20144: EMPTY
20145: LIST
20146: ADD
20147: ST_TO_ADDR
// end ;
20148: GO 20104
20150: POP
20151: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20152: LD_ADDR_VAR 0 6
20156: PUSH
20157: LD_VAR 0 6
20161: PPUSH
20162: LD_VAR 0 2
20166: PUSH
20167: LD_VAR 0 2
20171: ARRAY
20172: PPUSH
20173: LD_VAR 0 3
20177: PPUSH
20178: CALL_OW 1
20182: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20183: LD_ADDR_VAR 0 7
20187: PUSH
20188: LD_VAR 0 7
20192: PPUSH
20193: LD_VAR 0 7
20197: PPUSH
20198: LD_VAR 0 6
20202: PPUSH
20203: CALL_OW 1
20207: ST_TO_ADDR
// for i = s_arr downto 2 do
20208: LD_ADDR_VAR 0 5
20212: PUSH
20213: DOUBLE
20214: LD_VAR 0 7
20218: INC
20219: ST_TO_ADDR
20220: LD_INT 2
20222: PUSH
20223: FOR_DOWNTO
20224: IFFALSE 20308
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20226: LD_ADDR_VAR 0 6
20230: PUSH
20231: LD_VAR 0 7
20235: PUSH
20236: LD_VAR 0 5
20240: PUSH
20241: LD_INT 1
20243: MINUS
20244: ARRAY
20245: PPUSH
20246: LD_VAR 0 2
20250: PUSH
20251: LD_VAR 0 5
20255: PUSH
20256: LD_INT 1
20258: MINUS
20259: ARRAY
20260: PPUSH
20261: LD_VAR 0 7
20265: PUSH
20266: LD_VAR 0 5
20270: ARRAY
20271: PPUSH
20272: CALL_OW 1
20276: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20277: LD_ADDR_VAR 0 7
20281: PUSH
20282: LD_VAR 0 7
20286: PPUSH
20287: LD_VAR 0 5
20291: PUSH
20292: LD_INT 1
20294: MINUS
20295: PPUSH
20296: LD_VAR 0 6
20300: PPUSH
20301: CALL_OW 1
20305: ST_TO_ADDR
// end ;
20306: GO 20223
20308: POP
20309: POP
// result := s_arr [ 1 ] ;
20310: LD_ADDR_VAR 0 4
20314: PUSH
20315: LD_VAR 0 7
20319: PUSH
20320: LD_INT 1
20322: ARRAY
20323: ST_TO_ADDR
// end ; end ;
20324: LD_VAR 0 4
20328: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20329: LD_INT 0
20331: PPUSH
20332: PPUSH
// if not list then
20333: LD_VAR 0 1
20337: NOT
20338: IFFALSE 20342
// exit ;
20340: GO 20433
// i := list [ pos1 ] ;
20342: LD_ADDR_VAR 0 5
20346: PUSH
20347: LD_VAR 0 1
20351: PUSH
20352: LD_VAR 0 2
20356: ARRAY
20357: ST_TO_ADDR
// if not i then
20358: LD_VAR 0 5
20362: NOT
20363: IFFALSE 20367
// exit ;
20365: GO 20433
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20367: LD_ADDR_VAR 0 1
20371: PUSH
20372: LD_VAR 0 1
20376: PPUSH
20377: LD_VAR 0 2
20381: PPUSH
20382: LD_VAR 0 1
20386: PUSH
20387: LD_VAR 0 3
20391: ARRAY
20392: PPUSH
20393: CALL_OW 1
20397: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20398: LD_ADDR_VAR 0 1
20402: PUSH
20403: LD_VAR 0 1
20407: PPUSH
20408: LD_VAR 0 3
20412: PPUSH
20413: LD_VAR 0 5
20417: PPUSH
20418: CALL_OW 1
20422: ST_TO_ADDR
// result := list ;
20423: LD_ADDR_VAR 0 4
20427: PUSH
20428: LD_VAR 0 1
20432: ST_TO_ADDR
// end ;
20433: LD_VAR 0 4
20437: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20438: LD_INT 0
20440: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20441: LD_ADDR_VAR 0 5
20445: PUSH
20446: LD_VAR 0 1
20450: PPUSH
20451: CALL_OW 250
20455: PPUSH
20456: LD_VAR 0 1
20460: PPUSH
20461: CALL_OW 251
20465: PPUSH
20466: LD_VAR 0 2
20470: PPUSH
20471: LD_VAR 0 3
20475: PPUSH
20476: LD_VAR 0 4
20480: PPUSH
20481: CALL 20491 0 5
20485: ST_TO_ADDR
// end ;
20486: LD_VAR 0 5
20490: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20491: LD_INT 0
20493: PPUSH
20494: PPUSH
20495: PPUSH
20496: PPUSH
// if not list then
20497: LD_VAR 0 3
20501: NOT
20502: IFFALSE 20506
// exit ;
20504: GO 20894
// result := [ ] ;
20506: LD_ADDR_VAR 0 6
20510: PUSH
20511: EMPTY
20512: ST_TO_ADDR
// for i in list do
20513: LD_ADDR_VAR 0 7
20517: PUSH
20518: LD_VAR 0 3
20522: PUSH
20523: FOR_IN
20524: IFFALSE 20726
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20526: LD_ADDR_VAR 0 9
20530: PUSH
20531: LD_VAR 0 7
20535: PPUSH
20536: LD_VAR 0 1
20540: PPUSH
20541: LD_VAR 0 2
20545: PPUSH
20546: CALL_OW 297
20550: ST_TO_ADDR
// if not result then
20551: LD_VAR 0 6
20555: NOT
20556: IFFALSE 20582
// result := [ [ i , tmp ] ] else
20558: LD_ADDR_VAR 0 6
20562: PUSH
20563: LD_VAR 0 7
20567: PUSH
20568: LD_VAR 0 9
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: PUSH
20577: EMPTY
20578: LIST
20579: ST_TO_ADDR
20580: GO 20724
// begin if result [ result ] [ 2 ] < tmp then
20582: LD_VAR 0 6
20586: PUSH
20587: LD_VAR 0 6
20591: ARRAY
20592: PUSH
20593: LD_INT 2
20595: ARRAY
20596: PUSH
20597: LD_VAR 0 9
20601: LESS
20602: IFFALSE 20644
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
20604: LD_ADDR_VAR 0 6
20608: PUSH
20609: LD_VAR 0 6
20613: PPUSH
20614: LD_VAR 0 6
20618: PUSH
20619: LD_INT 1
20621: PLUS
20622: PPUSH
20623: LD_VAR 0 7
20627: PUSH
20628: LD_VAR 0 9
20632: PUSH
20633: EMPTY
20634: LIST
20635: LIST
20636: PPUSH
20637: CALL_OW 2
20641: ST_TO_ADDR
20642: GO 20724
// for j = 1 to result do
20644: LD_ADDR_VAR 0 8
20648: PUSH
20649: DOUBLE
20650: LD_INT 1
20652: DEC
20653: ST_TO_ADDR
20654: LD_VAR 0 6
20658: PUSH
20659: FOR_TO
20660: IFFALSE 20722
// begin if tmp < result [ j ] [ 2 ] then
20662: LD_VAR 0 9
20666: PUSH
20667: LD_VAR 0 6
20671: PUSH
20672: LD_VAR 0 8
20676: ARRAY
20677: PUSH
20678: LD_INT 2
20680: ARRAY
20681: LESS
20682: IFFALSE 20720
// begin result := Insert ( result , j , [ i , tmp ] ) ;
20684: LD_ADDR_VAR 0 6
20688: PUSH
20689: LD_VAR 0 6
20693: PPUSH
20694: LD_VAR 0 8
20698: PPUSH
20699: LD_VAR 0 7
20703: PUSH
20704: LD_VAR 0 9
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: PPUSH
20713: CALL_OW 2
20717: ST_TO_ADDR
// break ;
20718: GO 20722
// end ; end ;
20720: GO 20659
20722: POP
20723: POP
// end ; end ;
20724: GO 20523
20726: POP
20727: POP
// if result and not asc then
20728: LD_VAR 0 6
20732: PUSH
20733: LD_VAR 0 4
20737: NOT
20738: AND
20739: IFFALSE 20814
// begin tmp := result ;
20741: LD_ADDR_VAR 0 9
20745: PUSH
20746: LD_VAR 0 6
20750: ST_TO_ADDR
// for i = tmp downto 1 do
20751: LD_ADDR_VAR 0 7
20755: PUSH
20756: DOUBLE
20757: LD_VAR 0 9
20761: INC
20762: ST_TO_ADDR
20763: LD_INT 1
20765: PUSH
20766: FOR_DOWNTO
20767: IFFALSE 20812
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20769: LD_ADDR_VAR 0 6
20773: PUSH
20774: LD_VAR 0 6
20778: PPUSH
20779: LD_VAR 0 9
20783: PUSH
20784: LD_VAR 0 7
20788: MINUS
20789: PUSH
20790: LD_INT 1
20792: PLUS
20793: PPUSH
20794: LD_VAR 0 9
20798: PUSH
20799: LD_VAR 0 7
20803: ARRAY
20804: PPUSH
20805: CALL_OW 1
20809: ST_TO_ADDR
20810: GO 20766
20812: POP
20813: POP
// end ; tmp := [ ] ;
20814: LD_ADDR_VAR 0 9
20818: PUSH
20819: EMPTY
20820: ST_TO_ADDR
// if mode then
20821: LD_VAR 0 5
20825: IFFALSE 20894
// begin for i = 1 to result do
20827: LD_ADDR_VAR 0 7
20831: PUSH
20832: DOUBLE
20833: LD_INT 1
20835: DEC
20836: ST_TO_ADDR
20837: LD_VAR 0 6
20841: PUSH
20842: FOR_TO
20843: IFFALSE 20882
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20845: LD_ADDR_VAR 0 9
20849: PUSH
20850: LD_VAR 0 9
20854: PPUSH
20855: LD_VAR 0 7
20859: PPUSH
20860: LD_VAR 0 6
20864: PUSH
20865: LD_VAR 0 7
20869: ARRAY
20870: PUSH
20871: LD_INT 1
20873: ARRAY
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
20880: GO 20842
20882: POP
20883: POP
// result := tmp ;
20884: LD_ADDR_VAR 0 6
20888: PUSH
20889: LD_VAR 0 9
20893: ST_TO_ADDR
// end ; end ;
20894: LD_VAR 0 6
20898: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20899: LD_INT 0
20901: PPUSH
20902: PPUSH
20903: PPUSH
20904: PPUSH
20905: PPUSH
20906: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20907: LD_ADDR_VAR 0 5
20911: PUSH
20912: LD_INT 0
20914: PUSH
20915: LD_INT 0
20917: PUSH
20918: LD_INT 0
20920: PUSH
20921: EMPTY
20922: PUSH
20923: EMPTY
20924: LIST
20925: LIST
20926: LIST
20927: LIST
20928: ST_TO_ADDR
// if not x or not y then
20929: LD_VAR 0 2
20933: NOT
20934: PUSH
20935: LD_VAR 0 3
20939: NOT
20940: OR
20941: IFFALSE 20945
// exit ;
20943: GO 22597
// if not range then
20945: LD_VAR 0 4
20949: NOT
20950: IFFALSE 20960
// range := 10 ;
20952: LD_ADDR_VAR 0 4
20956: PUSH
20957: LD_INT 10
20959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20960: LD_ADDR_VAR 0 8
20964: PUSH
20965: LD_INT 81
20967: PUSH
20968: LD_VAR 0 1
20972: PUSH
20973: EMPTY
20974: LIST
20975: LIST
20976: PUSH
20977: LD_INT 92
20979: PUSH
20980: LD_VAR 0 2
20984: PUSH
20985: LD_VAR 0 3
20989: PUSH
20990: LD_VAR 0 4
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: LIST
20999: LIST
21000: PUSH
21001: LD_INT 3
21003: PUSH
21004: LD_INT 21
21006: PUSH
21007: LD_INT 3
21009: PUSH
21010: EMPTY
21011: LIST
21012: LIST
21013: PUSH
21014: EMPTY
21015: LIST
21016: LIST
21017: PUSH
21018: EMPTY
21019: LIST
21020: LIST
21021: LIST
21022: PPUSH
21023: CALL_OW 69
21027: ST_TO_ADDR
// if not tmp then
21028: LD_VAR 0 8
21032: NOT
21033: IFFALSE 21037
// exit ;
21035: GO 22597
// for i in tmp do
21037: LD_ADDR_VAR 0 6
21041: PUSH
21042: LD_VAR 0 8
21046: PUSH
21047: FOR_IN
21048: IFFALSE 22572
// begin points := [ 0 , 0 , 0 ] ;
21050: LD_ADDR_VAR 0 9
21054: PUSH
21055: LD_INT 0
21057: PUSH
21058: LD_INT 0
21060: PUSH
21061: LD_INT 0
21063: PUSH
21064: EMPTY
21065: LIST
21066: LIST
21067: LIST
21068: ST_TO_ADDR
// bpoints := 1 ;
21069: LD_ADDR_VAR 0 10
21073: PUSH
21074: LD_INT 1
21076: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21077: LD_VAR 0 6
21081: PPUSH
21082: CALL_OW 247
21086: PUSH
21087: LD_INT 1
21089: DOUBLE
21090: EQUAL
21091: IFTRUE 21095
21093: GO 21673
21095: POP
// begin if GetClass ( i ) = 1 then
21096: LD_VAR 0 6
21100: PPUSH
21101: CALL_OW 257
21105: PUSH
21106: LD_INT 1
21108: EQUAL
21109: IFFALSE 21130
// points := [ 10 , 5 , 3 ] ;
21111: LD_ADDR_VAR 0 9
21115: PUSH
21116: LD_INT 10
21118: PUSH
21119: LD_INT 5
21121: PUSH
21122: LD_INT 3
21124: PUSH
21125: EMPTY
21126: LIST
21127: LIST
21128: LIST
21129: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21130: LD_VAR 0 6
21134: PPUSH
21135: CALL_OW 257
21139: PUSH
21140: LD_INT 2
21142: PUSH
21143: LD_INT 3
21145: PUSH
21146: LD_INT 4
21148: PUSH
21149: EMPTY
21150: LIST
21151: LIST
21152: LIST
21153: IN
21154: IFFALSE 21175
// points := [ 3 , 2 , 1 ] ;
21156: LD_ADDR_VAR 0 9
21160: PUSH
21161: LD_INT 3
21163: PUSH
21164: LD_INT 2
21166: PUSH
21167: LD_INT 1
21169: PUSH
21170: EMPTY
21171: LIST
21172: LIST
21173: LIST
21174: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21175: LD_VAR 0 6
21179: PPUSH
21180: CALL_OW 257
21184: PUSH
21185: LD_INT 5
21187: EQUAL
21188: IFFALSE 21209
// points := [ 130 , 5 , 2 ] ;
21190: LD_ADDR_VAR 0 9
21194: PUSH
21195: LD_INT 130
21197: PUSH
21198: LD_INT 5
21200: PUSH
21201: LD_INT 2
21203: PUSH
21204: EMPTY
21205: LIST
21206: LIST
21207: LIST
21208: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21209: LD_VAR 0 6
21213: PPUSH
21214: CALL_OW 257
21218: PUSH
21219: LD_INT 8
21221: EQUAL
21222: IFFALSE 21243
// points := [ 35 , 35 , 30 ] ;
21224: LD_ADDR_VAR 0 9
21228: PUSH
21229: LD_INT 35
21231: PUSH
21232: LD_INT 35
21234: PUSH
21235: LD_INT 30
21237: PUSH
21238: EMPTY
21239: LIST
21240: LIST
21241: LIST
21242: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21243: LD_VAR 0 6
21247: PPUSH
21248: CALL_OW 257
21252: PUSH
21253: LD_INT 9
21255: EQUAL
21256: IFFALSE 21277
// points := [ 20 , 55 , 40 ] ;
21258: LD_ADDR_VAR 0 9
21262: PUSH
21263: LD_INT 20
21265: PUSH
21266: LD_INT 55
21268: PUSH
21269: LD_INT 40
21271: PUSH
21272: EMPTY
21273: LIST
21274: LIST
21275: LIST
21276: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21277: LD_VAR 0 6
21281: PPUSH
21282: CALL_OW 257
21286: PUSH
21287: LD_INT 12
21289: PUSH
21290: LD_INT 16
21292: PUSH
21293: EMPTY
21294: LIST
21295: LIST
21296: IN
21297: IFFALSE 21318
// points := [ 5 , 3 , 2 ] ;
21299: LD_ADDR_VAR 0 9
21303: PUSH
21304: LD_INT 5
21306: PUSH
21307: LD_INT 3
21309: PUSH
21310: LD_INT 2
21312: PUSH
21313: EMPTY
21314: LIST
21315: LIST
21316: LIST
21317: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21318: LD_VAR 0 6
21322: PPUSH
21323: CALL_OW 257
21327: PUSH
21328: LD_INT 17
21330: EQUAL
21331: IFFALSE 21352
// points := [ 100 , 50 , 75 ] ;
21333: LD_ADDR_VAR 0 9
21337: PUSH
21338: LD_INT 100
21340: PUSH
21341: LD_INT 50
21343: PUSH
21344: LD_INT 75
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: LIST
21351: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21352: LD_VAR 0 6
21356: PPUSH
21357: CALL_OW 257
21361: PUSH
21362: LD_INT 15
21364: EQUAL
21365: IFFALSE 21386
// points := [ 10 , 5 , 3 ] ;
21367: LD_ADDR_VAR 0 9
21371: PUSH
21372: LD_INT 10
21374: PUSH
21375: LD_INT 5
21377: PUSH
21378: LD_INT 3
21380: PUSH
21381: EMPTY
21382: LIST
21383: LIST
21384: LIST
21385: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21386: LD_VAR 0 6
21390: PPUSH
21391: CALL_OW 257
21395: PUSH
21396: LD_INT 14
21398: EQUAL
21399: IFFALSE 21420
// points := [ 10 , 0 , 0 ] ;
21401: LD_ADDR_VAR 0 9
21405: PUSH
21406: LD_INT 10
21408: PUSH
21409: LD_INT 0
21411: PUSH
21412: LD_INT 0
21414: PUSH
21415: EMPTY
21416: LIST
21417: LIST
21418: LIST
21419: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21420: LD_VAR 0 6
21424: PPUSH
21425: CALL_OW 257
21429: PUSH
21430: LD_INT 11
21432: EQUAL
21433: IFFALSE 21454
// points := [ 30 , 10 , 5 ] ;
21435: LD_ADDR_VAR 0 9
21439: PUSH
21440: LD_INT 30
21442: PUSH
21443: LD_INT 10
21445: PUSH
21446: LD_INT 5
21448: PUSH
21449: EMPTY
21450: LIST
21451: LIST
21452: LIST
21453: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21454: LD_VAR 0 1
21458: PPUSH
21459: LD_INT 5
21461: PPUSH
21462: CALL_OW 321
21466: PUSH
21467: LD_INT 2
21469: EQUAL
21470: IFFALSE 21487
// bpoints := bpoints * 1.8 ;
21472: LD_ADDR_VAR 0 10
21476: PUSH
21477: LD_VAR 0 10
21481: PUSH
21482: LD_REAL  1.80000000000000E+0000
21485: MUL
21486: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21487: LD_VAR 0 6
21491: PPUSH
21492: CALL_OW 257
21496: PUSH
21497: LD_INT 1
21499: PUSH
21500: LD_INT 2
21502: PUSH
21503: LD_INT 3
21505: PUSH
21506: LD_INT 4
21508: PUSH
21509: EMPTY
21510: LIST
21511: LIST
21512: LIST
21513: LIST
21514: IN
21515: PUSH
21516: LD_VAR 0 1
21520: PPUSH
21521: LD_INT 51
21523: PPUSH
21524: CALL_OW 321
21528: PUSH
21529: LD_INT 2
21531: EQUAL
21532: AND
21533: IFFALSE 21550
// bpoints := bpoints * 1.2 ;
21535: LD_ADDR_VAR 0 10
21539: PUSH
21540: LD_VAR 0 10
21544: PUSH
21545: LD_REAL  1.20000000000000E+0000
21548: MUL
21549: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
21550: LD_VAR 0 6
21554: PPUSH
21555: CALL_OW 257
21559: PUSH
21560: LD_INT 5
21562: PUSH
21563: LD_INT 7
21565: PUSH
21566: LD_INT 9
21568: PUSH
21569: EMPTY
21570: LIST
21571: LIST
21572: LIST
21573: IN
21574: PUSH
21575: LD_VAR 0 1
21579: PPUSH
21580: LD_INT 52
21582: PPUSH
21583: CALL_OW 321
21587: PUSH
21588: LD_INT 2
21590: EQUAL
21591: AND
21592: IFFALSE 21609
// bpoints := bpoints * 1.5 ;
21594: LD_ADDR_VAR 0 10
21598: PUSH
21599: LD_VAR 0 10
21603: PUSH
21604: LD_REAL  1.50000000000000E+0000
21607: MUL
21608: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
21609: LD_VAR 0 1
21613: PPUSH
21614: LD_INT 66
21616: PPUSH
21617: CALL_OW 321
21621: PUSH
21622: LD_INT 2
21624: EQUAL
21625: IFFALSE 21642
// bpoints := bpoints * 1.1 ;
21627: LD_ADDR_VAR 0 10
21631: PUSH
21632: LD_VAR 0 10
21636: PUSH
21637: LD_REAL  1.10000000000000E+0000
21640: MUL
21641: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
21642: LD_ADDR_VAR 0 10
21646: PUSH
21647: LD_VAR 0 10
21651: PUSH
21652: LD_VAR 0 6
21656: PPUSH
21657: LD_INT 1
21659: PPUSH
21660: CALL_OW 259
21664: PUSH
21665: LD_REAL  1.15000000000000E+0000
21668: MUL
21669: MUL
21670: ST_TO_ADDR
// end ; unit_vehicle :
21671: GO 22501
21673: LD_INT 2
21675: DOUBLE
21676: EQUAL
21677: IFTRUE 21681
21679: GO 22489
21681: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
21682: LD_VAR 0 6
21686: PPUSH
21687: CALL_OW 264
21691: PUSH
21692: LD_INT 2
21694: PUSH
21695: LD_INT 42
21697: PUSH
21698: LD_INT 24
21700: PUSH
21701: EMPTY
21702: LIST
21703: LIST
21704: LIST
21705: IN
21706: IFFALSE 21727
// points := [ 25 , 5 , 3 ] ;
21708: LD_ADDR_VAR 0 9
21712: PUSH
21713: LD_INT 25
21715: PUSH
21716: LD_INT 5
21718: PUSH
21719: LD_INT 3
21721: PUSH
21722: EMPTY
21723: LIST
21724: LIST
21725: LIST
21726: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21727: LD_VAR 0 6
21731: PPUSH
21732: CALL_OW 264
21736: PUSH
21737: LD_INT 4
21739: PUSH
21740: LD_INT 43
21742: PUSH
21743: LD_INT 25
21745: PUSH
21746: EMPTY
21747: LIST
21748: LIST
21749: LIST
21750: IN
21751: IFFALSE 21772
// points := [ 40 , 15 , 5 ] ;
21753: LD_ADDR_VAR 0 9
21757: PUSH
21758: LD_INT 40
21760: PUSH
21761: LD_INT 15
21763: PUSH
21764: LD_INT 5
21766: PUSH
21767: EMPTY
21768: LIST
21769: LIST
21770: LIST
21771: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21772: LD_VAR 0 6
21776: PPUSH
21777: CALL_OW 264
21781: PUSH
21782: LD_INT 3
21784: PUSH
21785: LD_INT 23
21787: PUSH
21788: EMPTY
21789: LIST
21790: LIST
21791: IN
21792: IFFALSE 21813
// points := [ 7 , 25 , 8 ] ;
21794: LD_ADDR_VAR 0 9
21798: PUSH
21799: LD_INT 7
21801: PUSH
21802: LD_INT 25
21804: PUSH
21805: LD_INT 8
21807: PUSH
21808: EMPTY
21809: LIST
21810: LIST
21811: LIST
21812: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21813: LD_VAR 0 6
21817: PPUSH
21818: CALL_OW 264
21822: PUSH
21823: LD_INT 5
21825: PUSH
21826: LD_INT 27
21828: PUSH
21829: LD_INT 44
21831: PUSH
21832: EMPTY
21833: LIST
21834: LIST
21835: LIST
21836: IN
21837: IFFALSE 21858
// points := [ 14 , 50 , 16 ] ;
21839: LD_ADDR_VAR 0 9
21843: PUSH
21844: LD_INT 14
21846: PUSH
21847: LD_INT 50
21849: PUSH
21850: LD_INT 16
21852: PUSH
21853: EMPTY
21854: LIST
21855: LIST
21856: LIST
21857: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21858: LD_VAR 0 6
21862: PPUSH
21863: CALL_OW 264
21867: PUSH
21868: LD_INT 6
21870: PUSH
21871: LD_INT 46
21873: PUSH
21874: EMPTY
21875: LIST
21876: LIST
21877: IN
21878: IFFALSE 21899
// points := [ 32 , 120 , 70 ] ;
21880: LD_ADDR_VAR 0 9
21884: PUSH
21885: LD_INT 32
21887: PUSH
21888: LD_INT 120
21890: PUSH
21891: LD_INT 70
21893: PUSH
21894: EMPTY
21895: LIST
21896: LIST
21897: LIST
21898: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
21899: LD_VAR 0 6
21903: PPUSH
21904: CALL_OW 264
21908: PUSH
21909: LD_INT 7
21911: PUSH
21912: LD_INT 28
21914: PUSH
21915: LD_INT 45
21917: PUSH
21918: LD_EXP 109
21922: PUSH
21923: EMPTY
21924: LIST
21925: LIST
21926: LIST
21927: LIST
21928: IN
21929: IFFALSE 21950
// points := [ 35 , 20 , 45 ] ;
21931: LD_ADDR_VAR 0 9
21935: PUSH
21936: LD_INT 35
21938: PUSH
21939: LD_INT 20
21941: PUSH
21942: LD_INT 45
21944: PUSH
21945: EMPTY
21946: LIST
21947: LIST
21948: LIST
21949: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21950: LD_VAR 0 6
21954: PPUSH
21955: CALL_OW 264
21959: PUSH
21960: LD_INT 47
21962: PUSH
21963: EMPTY
21964: LIST
21965: IN
21966: IFFALSE 21987
// points := [ 67 , 45 , 75 ] ;
21968: LD_ADDR_VAR 0 9
21972: PUSH
21973: LD_INT 67
21975: PUSH
21976: LD_INT 45
21978: PUSH
21979: LD_INT 75
21981: PUSH
21982: EMPTY
21983: LIST
21984: LIST
21985: LIST
21986: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21987: LD_VAR 0 6
21991: PPUSH
21992: CALL_OW 264
21996: PUSH
21997: LD_INT 26
21999: PUSH
22000: EMPTY
22001: LIST
22002: IN
22003: IFFALSE 22024
// points := [ 120 , 30 , 80 ] ;
22005: LD_ADDR_VAR 0 9
22009: PUSH
22010: LD_INT 120
22012: PUSH
22013: LD_INT 30
22015: PUSH
22016: LD_INT 80
22018: PUSH
22019: EMPTY
22020: LIST
22021: LIST
22022: LIST
22023: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22024: LD_VAR 0 6
22028: PPUSH
22029: CALL_OW 264
22033: PUSH
22034: LD_INT 22
22036: PUSH
22037: EMPTY
22038: LIST
22039: IN
22040: IFFALSE 22061
// points := [ 40 , 1 , 1 ] ;
22042: LD_ADDR_VAR 0 9
22046: PUSH
22047: LD_INT 40
22049: PUSH
22050: LD_INT 1
22052: PUSH
22053: LD_INT 1
22055: PUSH
22056: EMPTY
22057: LIST
22058: LIST
22059: LIST
22060: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22061: LD_VAR 0 6
22065: PPUSH
22066: CALL_OW 264
22070: PUSH
22071: LD_INT 29
22073: PUSH
22074: EMPTY
22075: LIST
22076: IN
22077: IFFALSE 22098
// points := [ 70 , 200 , 400 ] ;
22079: LD_ADDR_VAR 0 9
22083: PUSH
22084: LD_INT 70
22086: PUSH
22087: LD_INT 200
22089: PUSH
22090: LD_INT 400
22092: PUSH
22093: EMPTY
22094: LIST
22095: LIST
22096: LIST
22097: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22098: LD_VAR 0 6
22102: PPUSH
22103: CALL_OW 264
22107: PUSH
22108: LD_INT 14
22110: PUSH
22111: LD_INT 53
22113: PUSH
22114: EMPTY
22115: LIST
22116: LIST
22117: IN
22118: IFFALSE 22139
// points := [ 40 , 10 , 20 ] ;
22120: LD_ADDR_VAR 0 9
22124: PUSH
22125: LD_INT 40
22127: PUSH
22128: LD_INT 10
22130: PUSH
22131: LD_INT 20
22133: PUSH
22134: EMPTY
22135: LIST
22136: LIST
22137: LIST
22138: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22139: LD_VAR 0 6
22143: PPUSH
22144: CALL_OW 264
22148: PUSH
22149: LD_INT 9
22151: PUSH
22152: EMPTY
22153: LIST
22154: IN
22155: IFFALSE 22176
// points := [ 5 , 70 , 20 ] ;
22157: LD_ADDR_VAR 0 9
22161: PUSH
22162: LD_INT 5
22164: PUSH
22165: LD_INT 70
22167: PUSH
22168: LD_INT 20
22170: PUSH
22171: EMPTY
22172: LIST
22173: LIST
22174: LIST
22175: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22176: LD_VAR 0 6
22180: PPUSH
22181: CALL_OW 264
22185: PUSH
22186: LD_INT 10
22188: PUSH
22189: EMPTY
22190: LIST
22191: IN
22192: IFFALSE 22213
// points := [ 35 , 110 , 70 ] ;
22194: LD_ADDR_VAR 0 9
22198: PUSH
22199: LD_INT 35
22201: PUSH
22202: LD_INT 110
22204: PUSH
22205: LD_INT 70
22207: PUSH
22208: EMPTY
22209: LIST
22210: LIST
22211: LIST
22212: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22213: LD_VAR 0 6
22217: PPUSH
22218: CALL_OW 265
22222: PUSH
22223: LD_INT 25
22225: EQUAL
22226: IFFALSE 22247
// points := [ 80 , 65 , 100 ] ;
22228: LD_ADDR_VAR 0 9
22232: PUSH
22233: LD_INT 80
22235: PUSH
22236: LD_INT 65
22238: PUSH
22239: LD_INT 100
22241: PUSH
22242: EMPTY
22243: LIST
22244: LIST
22245: LIST
22246: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22247: LD_VAR 0 6
22251: PPUSH
22252: CALL_OW 263
22256: PUSH
22257: LD_INT 1
22259: EQUAL
22260: IFFALSE 22295
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22262: LD_ADDR_VAR 0 10
22266: PUSH
22267: LD_VAR 0 10
22271: PUSH
22272: LD_VAR 0 6
22276: PPUSH
22277: CALL_OW 311
22281: PPUSH
22282: LD_INT 3
22284: PPUSH
22285: CALL_OW 259
22289: PUSH
22290: LD_INT 4
22292: MUL
22293: MUL
22294: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22295: LD_VAR 0 6
22299: PPUSH
22300: CALL_OW 263
22304: PUSH
22305: LD_INT 2
22307: EQUAL
22308: IFFALSE 22359
// begin j := IsControledBy ( i ) ;
22310: LD_ADDR_VAR 0 7
22314: PUSH
22315: LD_VAR 0 6
22319: PPUSH
22320: CALL_OW 312
22324: ST_TO_ADDR
// if j then
22325: LD_VAR 0 7
22329: IFFALSE 22359
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22331: LD_ADDR_VAR 0 10
22335: PUSH
22336: LD_VAR 0 10
22340: PUSH
22341: LD_VAR 0 7
22345: PPUSH
22346: LD_INT 3
22348: PPUSH
22349: CALL_OW 259
22353: PUSH
22354: LD_INT 3
22356: MUL
22357: MUL
22358: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 5
22371: PUSH
22372: LD_INT 6
22374: PUSH
22375: LD_INT 46
22377: PUSH
22378: LD_INT 44
22380: PUSH
22381: LD_INT 47
22383: PUSH
22384: LD_INT 45
22386: PUSH
22387: LD_INT 28
22389: PUSH
22390: LD_INT 7
22392: PUSH
22393: LD_INT 27
22395: PUSH
22396: LD_INT 29
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: LIST
22403: LIST
22404: LIST
22405: LIST
22406: LIST
22407: LIST
22408: LIST
22409: LIST
22410: IN
22411: PUSH
22412: LD_VAR 0 1
22416: PPUSH
22417: LD_INT 52
22419: PPUSH
22420: CALL_OW 321
22424: PUSH
22425: LD_INT 2
22427: EQUAL
22428: AND
22429: IFFALSE 22446
// bpoints := bpoints * 1.2 ;
22431: LD_ADDR_VAR 0 10
22435: PUSH
22436: LD_VAR 0 10
22440: PUSH
22441: LD_REAL  1.20000000000000E+0000
22444: MUL
22445: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22446: LD_VAR 0 6
22450: PPUSH
22451: CALL_OW 264
22455: PUSH
22456: LD_INT 6
22458: PUSH
22459: LD_INT 46
22461: PUSH
22462: LD_INT 47
22464: PUSH
22465: EMPTY
22466: LIST
22467: LIST
22468: LIST
22469: IN
22470: IFFALSE 22487
// bpoints := bpoints * 1.2 ;
22472: LD_ADDR_VAR 0 10
22476: PUSH
22477: LD_VAR 0 10
22481: PUSH
22482: LD_REAL  1.20000000000000E+0000
22485: MUL
22486: ST_TO_ADDR
// end ; unit_building :
22487: GO 22501
22489: LD_INT 3
22491: DOUBLE
22492: EQUAL
22493: IFTRUE 22497
22495: GO 22500
22497: POP
// ; end ;
22498: GO 22501
22500: POP
// for j = 1 to 3 do
22501: LD_ADDR_VAR 0 7
22505: PUSH
22506: DOUBLE
22507: LD_INT 1
22509: DEC
22510: ST_TO_ADDR
22511: LD_INT 3
22513: PUSH
22514: FOR_TO
22515: IFFALSE 22568
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22517: LD_ADDR_VAR 0 5
22521: PUSH
22522: LD_VAR 0 5
22526: PPUSH
22527: LD_VAR 0 7
22531: PPUSH
22532: LD_VAR 0 5
22536: PUSH
22537: LD_VAR 0 7
22541: ARRAY
22542: PUSH
22543: LD_VAR 0 9
22547: PUSH
22548: LD_VAR 0 7
22552: ARRAY
22553: PUSH
22554: LD_VAR 0 10
22558: MUL
22559: PLUS
22560: PPUSH
22561: CALL_OW 1
22565: ST_TO_ADDR
22566: GO 22514
22568: POP
22569: POP
// end ;
22570: GO 21047
22572: POP
22573: POP
// result := Replace ( result , 4 , tmp ) ;
22574: LD_ADDR_VAR 0 5
22578: PUSH
22579: LD_VAR 0 5
22583: PPUSH
22584: LD_INT 4
22586: PPUSH
22587: LD_VAR 0 8
22591: PPUSH
22592: CALL_OW 1
22596: ST_TO_ADDR
// end ;
22597: LD_VAR 0 5
22601: RET
// export function DangerAtRange ( unit , range ) ; begin
22602: LD_INT 0
22604: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
22605: LD_ADDR_VAR 0 3
22609: PUSH
22610: LD_VAR 0 1
22614: PPUSH
22615: CALL_OW 255
22619: PPUSH
22620: LD_VAR 0 1
22624: PPUSH
22625: CALL_OW 250
22629: PPUSH
22630: LD_VAR 0 1
22634: PPUSH
22635: CALL_OW 251
22639: PPUSH
22640: LD_VAR 0 2
22644: PPUSH
22645: CALL 20899 0 4
22649: ST_TO_ADDR
// end ;
22650: LD_VAR 0 3
22654: RET
// export function DangerInArea ( side , area ) ; begin
22655: LD_INT 0
22657: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
22658: LD_ADDR_VAR 0 3
22662: PUSH
22663: LD_VAR 0 2
22667: PPUSH
22668: LD_INT 81
22670: PUSH
22671: LD_VAR 0 1
22675: PUSH
22676: EMPTY
22677: LIST
22678: LIST
22679: PPUSH
22680: CALL_OW 70
22684: ST_TO_ADDR
// end ;
22685: LD_VAR 0 3
22689: RET
// export function IsExtension ( b ) ; begin
22690: LD_INT 0
22692: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
22693: LD_ADDR_VAR 0 2
22697: PUSH
22698: LD_VAR 0 1
22702: PUSH
22703: LD_INT 23
22705: PUSH
22706: LD_INT 20
22708: PUSH
22709: LD_INT 22
22711: PUSH
22712: LD_INT 17
22714: PUSH
22715: LD_INT 24
22717: PUSH
22718: LD_INT 21
22720: PUSH
22721: LD_INT 19
22723: PUSH
22724: LD_INT 16
22726: PUSH
22727: LD_INT 25
22729: PUSH
22730: LD_INT 18
22732: PUSH
22733: EMPTY
22734: LIST
22735: LIST
22736: LIST
22737: LIST
22738: LIST
22739: LIST
22740: LIST
22741: LIST
22742: LIST
22743: LIST
22744: IN
22745: ST_TO_ADDR
// end ;
22746: LD_VAR 0 2
22750: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22751: LD_INT 0
22753: PPUSH
22754: PPUSH
22755: PPUSH
// result := [ ] ;
22756: LD_ADDR_VAR 0 4
22760: PUSH
22761: EMPTY
22762: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22763: LD_ADDR_VAR 0 5
22767: PUSH
22768: LD_VAR 0 2
22772: PPUSH
22773: LD_INT 21
22775: PUSH
22776: LD_INT 3
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: PPUSH
22783: CALL_OW 70
22787: ST_TO_ADDR
// if not tmp then
22788: LD_VAR 0 5
22792: NOT
22793: IFFALSE 22797
// exit ;
22795: GO 22861
// if checkLink then
22797: LD_VAR 0 3
22801: IFFALSE 22851
// begin for i in tmp do
22803: LD_ADDR_VAR 0 6
22807: PUSH
22808: LD_VAR 0 5
22812: PUSH
22813: FOR_IN
22814: IFFALSE 22849
// if GetBase ( i ) <> base then
22816: LD_VAR 0 6
22820: PPUSH
22821: CALL_OW 274
22825: PUSH
22826: LD_VAR 0 1
22830: NONEQUAL
22831: IFFALSE 22847
// ComLinkToBase ( base , i ) ;
22833: LD_VAR 0 1
22837: PPUSH
22838: LD_VAR 0 6
22842: PPUSH
22843: CALL_OW 169
22847: GO 22813
22849: POP
22850: POP
// end ; result := tmp ;
22851: LD_ADDR_VAR 0 4
22855: PUSH
22856: LD_VAR 0 5
22860: ST_TO_ADDR
// end ;
22861: LD_VAR 0 4
22865: RET
// export function ComComplete ( units , b ) ; var i ; begin
22866: LD_INT 0
22868: PPUSH
22869: PPUSH
// if not units then
22870: LD_VAR 0 1
22874: NOT
22875: IFFALSE 22879
// exit ;
22877: GO 22969
// for i in units do
22879: LD_ADDR_VAR 0 4
22883: PUSH
22884: LD_VAR 0 1
22888: PUSH
22889: FOR_IN
22890: IFFALSE 22967
// if BuildingStatus ( b ) = bs_build then
22892: LD_VAR 0 2
22896: PPUSH
22897: CALL_OW 461
22901: PUSH
22902: LD_INT 1
22904: EQUAL
22905: IFFALSE 22965
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22907: LD_VAR 0 4
22911: PPUSH
22912: LD_STRING h
22914: PUSH
22915: LD_VAR 0 2
22919: PPUSH
22920: CALL_OW 250
22924: PUSH
22925: LD_VAR 0 2
22929: PPUSH
22930: CALL_OW 251
22934: PUSH
22935: LD_VAR 0 2
22939: PUSH
22940: LD_INT 0
22942: PUSH
22943: LD_INT 0
22945: PUSH
22946: LD_INT 0
22948: PUSH
22949: EMPTY
22950: LIST
22951: LIST
22952: LIST
22953: LIST
22954: LIST
22955: LIST
22956: LIST
22957: PUSH
22958: EMPTY
22959: LIST
22960: PPUSH
22961: CALL_OW 446
22965: GO 22889
22967: POP
22968: POP
// end ;
22969: LD_VAR 0 3
22973: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22974: LD_INT 0
22976: PPUSH
22977: PPUSH
22978: PPUSH
22979: PPUSH
22980: PPUSH
22981: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
22982: LD_VAR 0 1
22986: NOT
22987: PUSH
22988: LD_VAR 0 1
22992: PPUSH
22993: CALL_OW 263
22997: PUSH
22998: LD_INT 2
23000: NONEQUAL
23001: OR
23002: IFFALSE 23006
// exit ;
23004: GO 23322
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23006: LD_ADDR_VAR 0 6
23010: PUSH
23011: LD_INT 22
23013: PUSH
23014: LD_VAR 0 1
23018: PPUSH
23019: CALL_OW 255
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 2
23030: PUSH
23031: LD_INT 30
23033: PUSH
23034: LD_INT 36
23036: PUSH
23037: EMPTY
23038: LIST
23039: LIST
23040: PUSH
23041: LD_INT 34
23043: PUSH
23044: LD_INT 31
23046: PUSH
23047: EMPTY
23048: LIST
23049: LIST
23050: PUSH
23051: EMPTY
23052: LIST
23053: LIST
23054: LIST
23055: PUSH
23056: EMPTY
23057: LIST
23058: LIST
23059: PPUSH
23060: CALL_OW 69
23064: ST_TO_ADDR
// if not tmp then
23065: LD_VAR 0 6
23069: NOT
23070: IFFALSE 23074
// exit ;
23072: GO 23322
// result := [ ] ;
23074: LD_ADDR_VAR 0 2
23078: PUSH
23079: EMPTY
23080: ST_TO_ADDR
// for i in tmp do
23081: LD_ADDR_VAR 0 3
23085: PUSH
23086: LD_VAR 0 6
23090: PUSH
23091: FOR_IN
23092: IFFALSE 23163
// begin t := UnitsInside ( i ) ;
23094: LD_ADDR_VAR 0 4
23098: PUSH
23099: LD_VAR 0 3
23103: PPUSH
23104: CALL_OW 313
23108: ST_TO_ADDR
// if t then
23109: LD_VAR 0 4
23113: IFFALSE 23161
// for j in t do
23115: LD_ADDR_VAR 0 7
23119: PUSH
23120: LD_VAR 0 4
23124: PUSH
23125: FOR_IN
23126: IFFALSE 23159
// result := Replace ( result , result + 1 , j ) ;
23128: LD_ADDR_VAR 0 2
23132: PUSH
23133: LD_VAR 0 2
23137: PPUSH
23138: LD_VAR 0 2
23142: PUSH
23143: LD_INT 1
23145: PLUS
23146: PPUSH
23147: LD_VAR 0 7
23151: PPUSH
23152: CALL_OW 1
23156: ST_TO_ADDR
23157: GO 23125
23159: POP
23160: POP
// end ;
23161: GO 23091
23163: POP
23164: POP
// if not result then
23165: LD_VAR 0 2
23169: NOT
23170: IFFALSE 23174
// exit ;
23172: GO 23322
// mech := result [ 1 ] ;
23174: LD_ADDR_VAR 0 5
23178: PUSH
23179: LD_VAR 0 2
23183: PUSH
23184: LD_INT 1
23186: ARRAY
23187: ST_TO_ADDR
// if result > 1 then
23188: LD_VAR 0 2
23192: PUSH
23193: LD_INT 1
23195: GREATER
23196: IFFALSE 23308
// begin for i = 2 to result do
23198: LD_ADDR_VAR 0 3
23202: PUSH
23203: DOUBLE
23204: LD_INT 2
23206: DEC
23207: ST_TO_ADDR
23208: LD_VAR 0 2
23212: PUSH
23213: FOR_TO
23214: IFFALSE 23306
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23216: LD_ADDR_VAR 0 4
23220: PUSH
23221: LD_VAR 0 2
23225: PUSH
23226: LD_VAR 0 3
23230: ARRAY
23231: PPUSH
23232: LD_INT 3
23234: PPUSH
23235: CALL_OW 259
23239: PUSH
23240: LD_VAR 0 2
23244: PUSH
23245: LD_VAR 0 3
23249: ARRAY
23250: PPUSH
23251: CALL_OW 432
23255: MINUS
23256: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23257: LD_VAR 0 4
23261: PUSH
23262: LD_VAR 0 5
23266: PPUSH
23267: LD_INT 3
23269: PPUSH
23270: CALL_OW 259
23274: PUSH
23275: LD_VAR 0 5
23279: PPUSH
23280: CALL_OW 432
23284: MINUS
23285: GREATEREQUAL
23286: IFFALSE 23304
// mech := result [ i ] ;
23288: LD_ADDR_VAR 0 5
23292: PUSH
23293: LD_VAR 0 2
23297: PUSH
23298: LD_VAR 0 3
23302: ARRAY
23303: ST_TO_ADDR
// end ;
23304: GO 23213
23306: POP
23307: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23308: LD_VAR 0 1
23312: PPUSH
23313: LD_VAR 0 5
23317: PPUSH
23318: CALL_OW 135
// end ;
23322: LD_VAR 0 2
23326: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23327: LD_INT 0
23329: PPUSH
23330: PPUSH
23331: PPUSH
23332: PPUSH
23333: PPUSH
23334: PPUSH
23335: PPUSH
23336: PPUSH
23337: PPUSH
23338: PPUSH
23339: PPUSH
23340: PPUSH
23341: PPUSH
// result := [ ] ;
23342: LD_ADDR_VAR 0 7
23346: PUSH
23347: EMPTY
23348: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23349: LD_VAR 0 1
23353: PPUSH
23354: CALL_OW 266
23358: PUSH
23359: LD_INT 0
23361: PUSH
23362: LD_INT 1
23364: PUSH
23365: EMPTY
23366: LIST
23367: LIST
23368: IN
23369: NOT
23370: IFFALSE 23374
// exit ;
23372: GO 25008
// if name then
23374: LD_VAR 0 3
23378: IFFALSE 23394
// SetBName ( base_dep , name ) ;
23380: LD_VAR 0 1
23384: PPUSH
23385: LD_VAR 0 3
23389: PPUSH
23390: CALL_OW 500
// base := GetBase ( base_dep ) ;
23394: LD_ADDR_VAR 0 15
23398: PUSH
23399: LD_VAR 0 1
23403: PPUSH
23404: CALL_OW 274
23408: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23409: LD_ADDR_VAR 0 16
23413: PUSH
23414: LD_VAR 0 1
23418: PPUSH
23419: CALL_OW 255
23423: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23424: LD_ADDR_VAR 0 17
23428: PUSH
23429: LD_VAR 0 1
23433: PPUSH
23434: CALL_OW 248
23438: ST_TO_ADDR
// if sources then
23439: LD_VAR 0 5
23443: IFFALSE 23490
// for i = 1 to 3 do
23445: LD_ADDR_VAR 0 8
23449: PUSH
23450: DOUBLE
23451: LD_INT 1
23453: DEC
23454: ST_TO_ADDR
23455: LD_INT 3
23457: PUSH
23458: FOR_TO
23459: IFFALSE 23488
// AddResourceType ( base , i , sources [ i ] ) ;
23461: LD_VAR 0 15
23465: PPUSH
23466: LD_VAR 0 8
23470: PPUSH
23471: LD_VAR 0 5
23475: PUSH
23476: LD_VAR 0 8
23480: ARRAY
23481: PPUSH
23482: CALL_OW 276
23486: GO 23458
23488: POP
23489: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23490: LD_ADDR_VAR 0 18
23494: PUSH
23495: LD_VAR 0 15
23499: PPUSH
23500: LD_VAR 0 2
23504: PPUSH
23505: LD_INT 1
23507: PPUSH
23508: CALL 22751 0 3
23512: ST_TO_ADDR
// InitHc ;
23513: CALL_OW 19
// InitUc ;
23517: CALL_OW 18
// uc_side := side ;
23521: LD_ADDR_OWVAR 20
23525: PUSH
23526: LD_VAR 0 16
23530: ST_TO_ADDR
// uc_nation := nation ;
23531: LD_ADDR_OWVAR 21
23535: PUSH
23536: LD_VAR 0 17
23540: ST_TO_ADDR
// if buildings then
23541: LD_VAR 0 18
23545: IFFALSE 24867
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
23547: LD_ADDR_VAR 0 19
23551: PUSH
23552: LD_VAR 0 18
23556: PPUSH
23557: LD_INT 2
23559: PUSH
23560: LD_INT 30
23562: PUSH
23563: LD_INT 29
23565: PUSH
23566: EMPTY
23567: LIST
23568: LIST
23569: PUSH
23570: LD_INT 30
23572: PUSH
23573: LD_INT 30
23575: PUSH
23576: EMPTY
23577: LIST
23578: LIST
23579: PUSH
23580: EMPTY
23581: LIST
23582: LIST
23583: LIST
23584: PPUSH
23585: CALL_OW 72
23589: ST_TO_ADDR
// if tmp then
23590: LD_VAR 0 19
23594: IFFALSE 23642
// for i in tmp do
23596: LD_ADDR_VAR 0 8
23600: PUSH
23601: LD_VAR 0 19
23605: PUSH
23606: FOR_IN
23607: IFFALSE 23640
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
23609: LD_VAR 0 8
23613: PPUSH
23614: CALL_OW 250
23618: PPUSH
23619: LD_VAR 0 8
23623: PPUSH
23624: CALL_OW 251
23628: PPUSH
23629: LD_VAR 0 16
23633: PPUSH
23634: CALL_OW 441
23638: GO 23606
23640: POP
23641: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
23642: LD_VAR 0 18
23646: PPUSH
23647: LD_INT 2
23649: PUSH
23650: LD_INT 30
23652: PUSH
23653: LD_INT 32
23655: PUSH
23656: EMPTY
23657: LIST
23658: LIST
23659: PUSH
23660: LD_INT 30
23662: PUSH
23663: LD_INT 33
23665: PUSH
23666: EMPTY
23667: LIST
23668: LIST
23669: PUSH
23670: EMPTY
23671: LIST
23672: LIST
23673: LIST
23674: PPUSH
23675: CALL_OW 72
23679: IFFALSE 23767
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
23681: LD_ADDR_VAR 0 8
23685: PUSH
23686: LD_VAR 0 18
23690: PPUSH
23691: LD_INT 2
23693: PUSH
23694: LD_INT 30
23696: PUSH
23697: LD_INT 32
23699: PUSH
23700: EMPTY
23701: LIST
23702: LIST
23703: PUSH
23704: LD_INT 30
23706: PUSH
23707: LD_INT 33
23709: PUSH
23710: EMPTY
23711: LIST
23712: LIST
23713: PUSH
23714: EMPTY
23715: LIST
23716: LIST
23717: LIST
23718: PPUSH
23719: CALL_OW 72
23723: PUSH
23724: FOR_IN
23725: IFFALSE 23765
// begin if not GetBWeapon ( i ) then
23727: LD_VAR 0 8
23731: PPUSH
23732: CALL_OW 269
23736: NOT
23737: IFFALSE 23763
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23739: LD_VAR 0 8
23743: PPUSH
23744: LD_VAR 0 8
23748: PPUSH
23749: LD_VAR 0 2
23753: PPUSH
23754: CALL 25013 0 2
23758: PPUSH
23759: CALL_OW 431
// end ;
23763: GO 23724
23765: POP
23766: POP
// end ; for i = 1 to personel do
23767: LD_ADDR_VAR 0 8
23771: PUSH
23772: DOUBLE
23773: LD_INT 1
23775: DEC
23776: ST_TO_ADDR
23777: LD_VAR 0 6
23781: PUSH
23782: FOR_TO
23783: IFFALSE 24847
// begin if i > 4 then
23785: LD_VAR 0 8
23789: PUSH
23790: LD_INT 4
23792: GREATER
23793: IFFALSE 23797
// break ;
23795: GO 24847
// case i of 1 :
23797: LD_VAR 0 8
23801: PUSH
23802: LD_INT 1
23804: DOUBLE
23805: EQUAL
23806: IFTRUE 23810
23808: GO 23890
23810: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23811: LD_ADDR_VAR 0 12
23815: PUSH
23816: LD_VAR 0 18
23820: PPUSH
23821: LD_INT 22
23823: PUSH
23824: LD_VAR 0 16
23828: PUSH
23829: EMPTY
23830: LIST
23831: LIST
23832: PUSH
23833: LD_INT 58
23835: PUSH
23836: EMPTY
23837: LIST
23838: PUSH
23839: LD_INT 2
23841: PUSH
23842: LD_INT 30
23844: PUSH
23845: LD_INT 32
23847: PUSH
23848: EMPTY
23849: LIST
23850: LIST
23851: PUSH
23852: LD_INT 30
23854: PUSH
23855: LD_INT 4
23857: PUSH
23858: EMPTY
23859: LIST
23860: LIST
23861: PUSH
23862: LD_INT 30
23864: PUSH
23865: LD_INT 5
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PUSH
23872: EMPTY
23873: LIST
23874: LIST
23875: LIST
23876: LIST
23877: PUSH
23878: EMPTY
23879: LIST
23880: LIST
23881: LIST
23882: PPUSH
23883: CALL_OW 72
23887: ST_TO_ADDR
23888: GO 24112
23890: LD_INT 2
23892: DOUBLE
23893: EQUAL
23894: IFTRUE 23898
23896: GO 23960
23898: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23899: LD_ADDR_VAR 0 12
23903: PUSH
23904: LD_VAR 0 18
23908: PPUSH
23909: LD_INT 22
23911: PUSH
23912: LD_VAR 0 16
23916: PUSH
23917: EMPTY
23918: LIST
23919: LIST
23920: PUSH
23921: LD_INT 2
23923: PUSH
23924: LD_INT 30
23926: PUSH
23927: LD_INT 0
23929: PUSH
23930: EMPTY
23931: LIST
23932: LIST
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 1
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: LIST
23948: PUSH
23949: EMPTY
23950: LIST
23951: LIST
23952: PPUSH
23953: CALL_OW 72
23957: ST_TO_ADDR
23958: GO 24112
23960: LD_INT 3
23962: DOUBLE
23963: EQUAL
23964: IFTRUE 23968
23966: GO 24030
23968: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23969: LD_ADDR_VAR 0 12
23973: PUSH
23974: LD_VAR 0 18
23978: PPUSH
23979: LD_INT 22
23981: PUSH
23982: LD_VAR 0 16
23986: PUSH
23987: EMPTY
23988: LIST
23989: LIST
23990: PUSH
23991: LD_INT 2
23993: PUSH
23994: LD_INT 30
23996: PUSH
23997: LD_INT 2
23999: PUSH
24000: EMPTY
24001: LIST
24002: LIST
24003: PUSH
24004: LD_INT 30
24006: PUSH
24007: LD_INT 3
24009: PUSH
24010: EMPTY
24011: LIST
24012: LIST
24013: PUSH
24014: EMPTY
24015: LIST
24016: LIST
24017: LIST
24018: PUSH
24019: EMPTY
24020: LIST
24021: LIST
24022: PPUSH
24023: CALL_OW 72
24027: ST_TO_ADDR
24028: GO 24112
24030: LD_INT 4
24032: DOUBLE
24033: EQUAL
24034: IFTRUE 24038
24036: GO 24111
24038: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24039: LD_ADDR_VAR 0 12
24043: PUSH
24044: LD_VAR 0 18
24048: PPUSH
24049: LD_INT 22
24051: PUSH
24052: LD_VAR 0 16
24056: PUSH
24057: EMPTY
24058: LIST
24059: LIST
24060: PUSH
24061: LD_INT 2
24063: PUSH
24064: LD_INT 30
24066: PUSH
24067: LD_INT 6
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PUSH
24074: LD_INT 30
24076: PUSH
24077: LD_INT 7
24079: PUSH
24080: EMPTY
24081: LIST
24082: LIST
24083: PUSH
24084: LD_INT 30
24086: PUSH
24087: LD_INT 8
24089: PUSH
24090: EMPTY
24091: LIST
24092: LIST
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: LIST
24098: LIST
24099: PUSH
24100: EMPTY
24101: LIST
24102: LIST
24103: PPUSH
24104: CALL_OW 72
24108: ST_TO_ADDR
24109: GO 24112
24111: POP
// if i = 1 then
24112: LD_VAR 0 8
24116: PUSH
24117: LD_INT 1
24119: EQUAL
24120: IFFALSE 24231
// begin tmp := [ ] ;
24122: LD_ADDR_VAR 0 19
24126: PUSH
24127: EMPTY
24128: ST_TO_ADDR
// for j in f do
24129: LD_ADDR_VAR 0 9
24133: PUSH
24134: LD_VAR 0 12
24138: PUSH
24139: FOR_IN
24140: IFFALSE 24213
// if GetBType ( j ) = b_bunker then
24142: LD_VAR 0 9
24146: PPUSH
24147: CALL_OW 266
24151: PUSH
24152: LD_INT 32
24154: EQUAL
24155: IFFALSE 24182
// tmp := Insert ( tmp , 1 , j ) else
24157: LD_ADDR_VAR 0 19
24161: PUSH
24162: LD_VAR 0 19
24166: PPUSH
24167: LD_INT 1
24169: PPUSH
24170: LD_VAR 0 9
24174: PPUSH
24175: CALL_OW 2
24179: ST_TO_ADDR
24180: GO 24211
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24182: LD_ADDR_VAR 0 19
24186: PUSH
24187: LD_VAR 0 19
24191: PPUSH
24192: LD_VAR 0 19
24196: PUSH
24197: LD_INT 1
24199: PLUS
24200: PPUSH
24201: LD_VAR 0 9
24205: PPUSH
24206: CALL_OW 2
24210: ST_TO_ADDR
24211: GO 24139
24213: POP
24214: POP
// if tmp then
24215: LD_VAR 0 19
24219: IFFALSE 24231
// f := tmp ;
24221: LD_ADDR_VAR 0 12
24225: PUSH
24226: LD_VAR 0 19
24230: ST_TO_ADDR
// end ; x := personel [ i ] ;
24231: LD_ADDR_VAR 0 13
24235: PUSH
24236: LD_VAR 0 6
24240: PUSH
24241: LD_VAR 0 8
24245: ARRAY
24246: ST_TO_ADDR
// if x = - 1 then
24247: LD_VAR 0 13
24251: PUSH
24252: LD_INT 1
24254: NEG
24255: EQUAL
24256: IFFALSE 24465
// begin for j in f do
24258: LD_ADDR_VAR 0 9
24262: PUSH
24263: LD_VAR 0 12
24267: PUSH
24268: FOR_IN
24269: IFFALSE 24461
// repeat InitHc ;
24271: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24275: LD_VAR 0 9
24279: PPUSH
24280: CALL_OW 266
24284: PUSH
24285: LD_INT 5
24287: EQUAL
24288: IFFALSE 24358
// begin if UnitsInside ( j ) < 3 then
24290: LD_VAR 0 9
24294: PPUSH
24295: CALL_OW 313
24299: PUSH
24300: LD_INT 3
24302: LESS
24303: IFFALSE 24339
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24305: LD_INT 0
24307: PPUSH
24308: LD_INT 5
24310: PUSH
24311: LD_INT 8
24313: PUSH
24314: LD_INT 9
24316: PUSH
24317: EMPTY
24318: LIST
24319: LIST
24320: LIST
24321: PUSH
24322: LD_VAR 0 17
24326: ARRAY
24327: PPUSH
24328: LD_VAR 0 4
24332: PPUSH
24333: CALL_OW 380
24337: GO 24356
// PrepareHuman ( false , i , skill ) ;
24339: LD_INT 0
24341: PPUSH
24342: LD_VAR 0 8
24346: PPUSH
24347: LD_VAR 0 4
24351: PPUSH
24352: CALL_OW 380
// end else
24356: GO 24375
// PrepareHuman ( false , i , skill ) ;
24358: LD_INT 0
24360: PPUSH
24361: LD_VAR 0 8
24365: PPUSH
24366: LD_VAR 0 4
24370: PPUSH
24371: CALL_OW 380
// un := CreateHuman ;
24375: LD_ADDR_VAR 0 14
24379: PUSH
24380: CALL_OW 44
24384: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24385: LD_ADDR_VAR 0 7
24389: PUSH
24390: LD_VAR 0 7
24394: PPUSH
24395: LD_INT 1
24397: PPUSH
24398: LD_VAR 0 14
24402: PPUSH
24403: CALL_OW 2
24407: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24408: LD_VAR 0 14
24412: PPUSH
24413: LD_VAR 0 9
24417: PPUSH
24418: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24422: LD_VAR 0 9
24426: PPUSH
24427: CALL_OW 313
24431: PUSH
24432: LD_INT 6
24434: EQUAL
24435: PUSH
24436: LD_VAR 0 9
24440: PPUSH
24441: CALL_OW 266
24445: PUSH
24446: LD_INT 32
24448: PUSH
24449: LD_INT 31
24451: PUSH
24452: EMPTY
24453: LIST
24454: LIST
24455: IN
24456: OR
24457: IFFALSE 24271
24459: GO 24268
24461: POP
24462: POP
// end else
24463: GO 24845
// for j = 1 to x do
24465: LD_ADDR_VAR 0 9
24469: PUSH
24470: DOUBLE
24471: LD_INT 1
24473: DEC
24474: ST_TO_ADDR
24475: LD_VAR 0 13
24479: PUSH
24480: FOR_TO
24481: IFFALSE 24843
// begin InitHc ;
24483: CALL_OW 19
// if not f then
24487: LD_VAR 0 12
24491: NOT
24492: IFFALSE 24581
// begin PrepareHuman ( false , i , skill ) ;
24494: LD_INT 0
24496: PPUSH
24497: LD_VAR 0 8
24501: PPUSH
24502: LD_VAR 0 4
24506: PPUSH
24507: CALL_OW 380
// un := CreateHuman ;
24511: LD_ADDR_VAR 0 14
24515: PUSH
24516: CALL_OW 44
24520: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24521: LD_ADDR_VAR 0 7
24525: PUSH
24526: LD_VAR 0 7
24530: PPUSH
24531: LD_INT 1
24533: PPUSH
24534: LD_VAR 0 14
24538: PPUSH
24539: CALL_OW 2
24543: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24544: LD_VAR 0 14
24548: PPUSH
24549: LD_VAR 0 1
24553: PPUSH
24554: CALL_OW 250
24558: PPUSH
24559: LD_VAR 0 1
24563: PPUSH
24564: CALL_OW 251
24568: PPUSH
24569: LD_INT 10
24571: PPUSH
24572: LD_INT 0
24574: PPUSH
24575: CALL_OW 50
// continue ;
24579: GO 24480
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
24581: LD_VAR 0 12
24585: PUSH
24586: LD_INT 1
24588: ARRAY
24589: PPUSH
24590: CALL_OW 313
24594: PUSH
24595: LD_VAR 0 12
24599: PUSH
24600: LD_INT 1
24602: ARRAY
24603: PPUSH
24604: CALL_OW 266
24608: PUSH
24609: LD_INT 32
24611: PUSH
24612: LD_INT 31
24614: PUSH
24615: EMPTY
24616: LIST
24617: LIST
24618: IN
24619: AND
24620: PUSH
24621: LD_VAR 0 12
24625: PUSH
24626: LD_INT 1
24628: ARRAY
24629: PPUSH
24630: CALL_OW 313
24634: PUSH
24635: LD_INT 6
24637: EQUAL
24638: OR
24639: IFFALSE 24659
// f := Delete ( f , 1 ) ;
24641: LD_ADDR_VAR 0 12
24645: PUSH
24646: LD_VAR 0 12
24650: PPUSH
24651: LD_INT 1
24653: PPUSH
24654: CALL_OW 3
24658: ST_TO_ADDR
// if not f then
24659: LD_VAR 0 12
24663: NOT
24664: IFFALSE 24682
// begin x := x + 2 ;
24666: LD_ADDR_VAR 0 13
24670: PUSH
24671: LD_VAR 0 13
24675: PUSH
24676: LD_INT 2
24678: PLUS
24679: ST_TO_ADDR
// continue ;
24680: GO 24480
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
24682: LD_VAR 0 12
24686: PUSH
24687: LD_INT 1
24689: ARRAY
24690: PPUSH
24691: CALL_OW 266
24695: PUSH
24696: LD_INT 5
24698: EQUAL
24699: IFFALSE 24773
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24701: LD_VAR 0 12
24705: PUSH
24706: LD_INT 1
24708: ARRAY
24709: PPUSH
24710: CALL_OW 313
24714: PUSH
24715: LD_INT 3
24717: LESS
24718: IFFALSE 24754
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24720: LD_INT 0
24722: PPUSH
24723: LD_INT 5
24725: PUSH
24726: LD_INT 8
24728: PUSH
24729: LD_INT 9
24731: PUSH
24732: EMPTY
24733: LIST
24734: LIST
24735: LIST
24736: PUSH
24737: LD_VAR 0 17
24741: ARRAY
24742: PPUSH
24743: LD_VAR 0 4
24747: PPUSH
24748: CALL_OW 380
24752: GO 24771
// PrepareHuman ( false , i , skill ) ;
24754: LD_INT 0
24756: PPUSH
24757: LD_VAR 0 8
24761: PPUSH
24762: LD_VAR 0 4
24766: PPUSH
24767: CALL_OW 380
// end else
24771: GO 24790
// PrepareHuman ( false , i , skill ) ;
24773: LD_INT 0
24775: PPUSH
24776: LD_VAR 0 8
24780: PPUSH
24781: LD_VAR 0 4
24785: PPUSH
24786: CALL_OW 380
// un := CreateHuman ;
24790: LD_ADDR_VAR 0 14
24794: PUSH
24795: CALL_OW 44
24799: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24800: LD_ADDR_VAR 0 7
24804: PUSH
24805: LD_VAR 0 7
24809: PPUSH
24810: LD_INT 1
24812: PPUSH
24813: LD_VAR 0 14
24817: PPUSH
24818: CALL_OW 2
24822: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24823: LD_VAR 0 14
24827: PPUSH
24828: LD_VAR 0 12
24832: PUSH
24833: LD_INT 1
24835: ARRAY
24836: PPUSH
24837: CALL_OW 52
// end ;
24841: GO 24480
24843: POP
24844: POP
// end ;
24845: GO 23782
24847: POP
24848: POP
// result := result ^ buildings ;
24849: LD_ADDR_VAR 0 7
24853: PUSH
24854: LD_VAR 0 7
24858: PUSH
24859: LD_VAR 0 18
24863: ADD
24864: ST_TO_ADDR
// end else
24865: GO 25008
// begin for i = 1 to personel do
24867: LD_ADDR_VAR 0 8
24871: PUSH
24872: DOUBLE
24873: LD_INT 1
24875: DEC
24876: ST_TO_ADDR
24877: LD_VAR 0 6
24881: PUSH
24882: FOR_TO
24883: IFFALSE 25006
// begin if i > 4 then
24885: LD_VAR 0 8
24889: PUSH
24890: LD_INT 4
24892: GREATER
24893: IFFALSE 24897
// break ;
24895: GO 25006
// x := personel [ i ] ;
24897: LD_ADDR_VAR 0 13
24901: PUSH
24902: LD_VAR 0 6
24906: PUSH
24907: LD_VAR 0 8
24911: ARRAY
24912: ST_TO_ADDR
// if x = - 1 then
24913: LD_VAR 0 13
24917: PUSH
24918: LD_INT 1
24920: NEG
24921: EQUAL
24922: IFFALSE 24926
// continue ;
24924: GO 24882
// PrepareHuman ( false , i , skill ) ;
24926: LD_INT 0
24928: PPUSH
24929: LD_VAR 0 8
24933: PPUSH
24934: LD_VAR 0 4
24938: PPUSH
24939: CALL_OW 380
// un := CreateHuman ;
24943: LD_ADDR_VAR 0 14
24947: PUSH
24948: CALL_OW 44
24952: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24953: LD_VAR 0 14
24957: PPUSH
24958: LD_VAR 0 1
24962: PPUSH
24963: CALL_OW 250
24967: PPUSH
24968: LD_VAR 0 1
24972: PPUSH
24973: CALL_OW 251
24977: PPUSH
24978: LD_INT 10
24980: PPUSH
24981: LD_INT 0
24983: PPUSH
24984: CALL_OW 50
// result := result ^ un ;
24988: LD_ADDR_VAR 0 7
24992: PUSH
24993: LD_VAR 0 7
24997: PUSH
24998: LD_VAR 0 14
25002: ADD
25003: ST_TO_ADDR
// end ;
25004: GO 24882
25006: POP
25007: POP
// end ; end ;
25008: LD_VAR 0 7
25012: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25013: LD_INT 0
25015: PPUSH
25016: PPUSH
25017: PPUSH
25018: PPUSH
25019: PPUSH
25020: PPUSH
25021: PPUSH
25022: PPUSH
25023: PPUSH
25024: PPUSH
25025: PPUSH
25026: PPUSH
25027: PPUSH
25028: PPUSH
25029: PPUSH
25030: PPUSH
// result := false ;
25031: LD_ADDR_VAR 0 3
25035: PUSH
25036: LD_INT 0
25038: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25039: LD_VAR 0 1
25043: NOT
25044: PUSH
25045: LD_VAR 0 1
25049: PPUSH
25050: CALL_OW 266
25054: PUSH
25055: LD_INT 32
25057: PUSH
25058: LD_INT 33
25060: PUSH
25061: EMPTY
25062: LIST
25063: LIST
25064: IN
25065: NOT
25066: OR
25067: IFFALSE 25071
// exit ;
25069: GO 26180
// nat := GetNation ( tower ) ;
25071: LD_ADDR_VAR 0 12
25075: PUSH
25076: LD_VAR 0 1
25080: PPUSH
25081: CALL_OW 248
25085: ST_TO_ADDR
// side := GetSide ( tower ) ;
25086: LD_ADDR_VAR 0 16
25090: PUSH
25091: LD_VAR 0 1
25095: PPUSH
25096: CALL_OW 255
25100: ST_TO_ADDR
// x := GetX ( tower ) ;
25101: LD_ADDR_VAR 0 10
25105: PUSH
25106: LD_VAR 0 1
25110: PPUSH
25111: CALL_OW 250
25115: ST_TO_ADDR
// y := GetY ( tower ) ;
25116: LD_ADDR_VAR 0 11
25120: PUSH
25121: LD_VAR 0 1
25125: PPUSH
25126: CALL_OW 251
25130: ST_TO_ADDR
// if not x or not y then
25131: LD_VAR 0 10
25135: NOT
25136: PUSH
25137: LD_VAR 0 11
25141: NOT
25142: OR
25143: IFFALSE 25147
// exit ;
25145: GO 26180
// weapon := 0 ;
25147: LD_ADDR_VAR 0 18
25151: PUSH
25152: LD_INT 0
25154: ST_TO_ADDR
// fac_list := [ ] ;
25155: LD_ADDR_VAR 0 17
25159: PUSH
25160: EMPTY
25161: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25162: LD_ADDR_VAR 0 6
25166: PUSH
25167: LD_VAR 0 1
25171: PPUSH
25172: CALL_OW 274
25176: PPUSH
25177: LD_VAR 0 2
25181: PPUSH
25182: LD_INT 0
25184: PPUSH
25185: CALL 22751 0 3
25189: PPUSH
25190: LD_INT 30
25192: PUSH
25193: LD_INT 3
25195: PUSH
25196: EMPTY
25197: LIST
25198: LIST
25199: PPUSH
25200: CALL_OW 72
25204: ST_TO_ADDR
// if not factories then
25205: LD_VAR 0 6
25209: NOT
25210: IFFALSE 25214
// exit ;
25212: GO 26180
// for i in factories do
25214: LD_ADDR_VAR 0 8
25218: PUSH
25219: LD_VAR 0 6
25223: PUSH
25224: FOR_IN
25225: IFFALSE 25250
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25227: LD_ADDR_VAR 0 17
25231: PUSH
25232: LD_VAR 0 17
25236: PUSH
25237: LD_VAR 0 8
25241: PPUSH
25242: CALL_OW 478
25246: UNION
25247: ST_TO_ADDR
25248: GO 25224
25250: POP
25251: POP
// if not fac_list then
25252: LD_VAR 0 17
25256: NOT
25257: IFFALSE 25261
// exit ;
25259: GO 26180
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25261: LD_ADDR_VAR 0 5
25265: PUSH
25266: LD_INT 4
25268: PUSH
25269: LD_INT 5
25271: PUSH
25272: LD_INT 9
25274: PUSH
25275: LD_INT 10
25277: PUSH
25278: LD_INT 6
25280: PUSH
25281: LD_INT 7
25283: PUSH
25284: LD_INT 11
25286: PUSH
25287: EMPTY
25288: LIST
25289: LIST
25290: LIST
25291: LIST
25292: LIST
25293: LIST
25294: LIST
25295: PUSH
25296: LD_INT 27
25298: PUSH
25299: LD_INT 28
25301: PUSH
25302: LD_INT 26
25304: PUSH
25305: LD_INT 30
25307: PUSH
25308: EMPTY
25309: LIST
25310: LIST
25311: LIST
25312: LIST
25313: PUSH
25314: LD_INT 43
25316: PUSH
25317: LD_INT 44
25319: PUSH
25320: LD_INT 46
25322: PUSH
25323: LD_INT 45
25325: PUSH
25326: LD_INT 47
25328: PUSH
25329: LD_INT 49
25331: PUSH
25332: EMPTY
25333: LIST
25334: LIST
25335: LIST
25336: LIST
25337: LIST
25338: LIST
25339: PUSH
25340: EMPTY
25341: LIST
25342: LIST
25343: LIST
25344: PUSH
25345: LD_VAR 0 12
25349: ARRAY
25350: ST_TO_ADDR
// list := list isect fac_list ;
25351: LD_ADDR_VAR 0 5
25355: PUSH
25356: LD_VAR 0 5
25360: PUSH
25361: LD_VAR 0 17
25365: ISECT
25366: ST_TO_ADDR
// if not list then
25367: LD_VAR 0 5
25371: NOT
25372: IFFALSE 25376
// exit ;
25374: GO 26180
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25376: LD_VAR 0 12
25380: PUSH
25381: LD_INT 3
25383: EQUAL
25384: PUSH
25385: LD_INT 49
25387: PUSH
25388: LD_VAR 0 5
25392: IN
25393: AND
25394: PUSH
25395: LD_INT 31
25397: PPUSH
25398: LD_VAR 0 16
25402: PPUSH
25403: CALL_OW 321
25407: PUSH
25408: LD_INT 2
25410: EQUAL
25411: AND
25412: IFFALSE 25472
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25414: LD_INT 22
25416: PUSH
25417: LD_VAR 0 16
25421: PUSH
25422: EMPTY
25423: LIST
25424: LIST
25425: PUSH
25426: LD_INT 35
25428: PUSH
25429: LD_INT 49
25431: PUSH
25432: EMPTY
25433: LIST
25434: LIST
25435: PUSH
25436: LD_INT 91
25438: PUSH
25439: LD_VAR 0 1
25443: PUSH
25444: LD_INT 10
25446: PUSH
25447: EMPTY
25448: LIST
25449: LIST
25450: LIST
25451: PUSH
25452: EMPTY
25453: LIST
25454: LIST
25455: LIST
25456: PPUSH
25457: CALL_OW 69
25461: NOT
25462: IFFALSE 25472
// weapon := ru_time_lapser ;
25464: LD_ADDR_VAR 0 18
25468: PUSH
25469: LD_INT 49
25471: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25472: LD_VAR 0 12
25476: PUSH
25477: LD_INT 1
25479: PUSH
25480: LD_INT 2
25482: PUSH
25483: EMPTY
25484: LIST
25485: LIST
25486: IN
25487: PUSH
25488: LD_INT 11
25490: PUSH
25491: LD_VAR 0 5
25495: IN
25496: PUSH
25497: LD_INT 30
25499: PUSH
25500: LD_VAR 0 5
25504: IN
25505: OR
25506: AND
25507: PUSH
25508: LD_INT 6
25510: PPUSH
25511: LD_VAR 0 16
25515: PPUSH
25516: CALL_OW 321
25520: PUSH
25521: LD_INT 2
25523: EQUAL
25524: AND
25525: IFFALSE 25690
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25527: LD_INT 22
25529: PUSH
25530: LD_VAR 0 16
25534: PUSH
25535: EMPTY
25536: LIST
25537: LIST
25538: PUSH
25539: LD_INT 2
25541: PUSH
25542: LD_INT 35
25544: PUSH
25545: LD_INT 11
25547: PUSH
25548: EMPTY
25549: LIST
25550: LIST
25551: PUSH
25552: LD_INT 35
25554: PUSH
25555: LD_INT 30
25557: PUSH
25558: EMPTY
25559: LIST
25560: LIST
25561: PUSH
25562: EMPTY
25563: LIST
25564: LIST
25565: LIST
25566: PUSH
25567: LD_INT 91
25569: PUSH
25570: LD_VAR 0 1
25574: PUSH
25575: LD_INT 18
25577: PUSH
25578: EMPTY
25579: LIST
25580: LIST
25581: LIST
25582: PUSH
25583: EMPTY
25584: LIST
25585: LIST
25586: LIST
25587: PPUSH
25588: CALL_OW 69
25592: NOT
25593: PUSH
25594: LD_INT 22
25596: PUSH
25597: LD_VAR 0 16
25601: PUSH
25602: EMPTY
25603: LIST
25604: LIST
25605: PUSH
25606: LD_INT 2
25608: PUSH
25609: LD_INT 30
25611: PUSH
25612: LD_INT 32
25614: PUSH
25615: EMPTY
25616: LIST
25617: LIST
25618: PUSH
25619: LD_INT 30
25621: PUSH
25622: LD_INT 33
25624: PUSH
25625: EMPTY
25626: LIST
25627: LIST
25628: PUSH
25629: EMPTY
25630: LIST
25631: LIST
25632: LIST
25633: PUSH
25634: LD_INT 91
25636: PUSH
25637: LD_VAR 0 1
25641: PUSH
25642: LD_INT 12
25644: PUSH
25645: EMPTY
25646: LIST
25647: LIST
25648: LIST
25649: PUSH
25650: EMPTY
25651: LIST
25652: LIST
25653: LIST
25654: PUSH
25655: EMPTY
25656: LIST
25657: PPUSH
25658: CALL_OW 69
25662: PUSH
25663: LD_INT 2
25665: GREATER
25666: AND
25667: IFFALSE 25690
// weapon := [ us_radar , ar_radar ] [ nat ] ;
25669: LD_ADDR_VAR 0 18
25673: PUSH
25674: LD_INT 11
25676: PUSH
25677: LD_INT 30
25679: PUSH
25680: EMPTY
25681: LIST
25682: LIST
25683: PUSH
25684: LD_VAR 0 12
25688: ARRAY
25689: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25690: LD_VAR 0 18
25694: NOT
25695: PUSH
25696: LD_INT 40
25698: PPUSH
25699: LD_VAR 0 16
25703: PPUSH
25704: CALL_OW 321
25708: PUSH
25709: LD_INT 2
25711: EQUAL
25712: AND
25713: PUSH
25714: LD_INT 7
25716: PUSH
25717: LD_VAR 0 5
25721: IN
25722: PUSH
25723: LD_INT 28
25725: PUSH
25726: LD_VAR 0 5
25730: IN
25731: OR
25732: PUSH
25733: LD_INT 45
25735: PUSH
25736: LD_VAR 0 5
25740: IN
25741: OR
25742: AND
25743: IFFALSE 25997
// begin hex := GetHexInfo ( x , y ) ;
25745: LD_ADDR_VAR 0 4
25749: PUSH
25750: LD_VAR 0 10
25754: PPUSH
25755: LD_VAR 0 11
25759: PPUSH
25760: CALL_OW 546
25764: ST_TO_ADDR
// if hex [ 1 ] then
25765: LD_VAR 0 4
25769: PUSH
25770: LD_INT 1
25772: ARRAY
25773: IFFALSE 25777
// exit ;
25775: GO 26180
// height := hex [ 2 ] ;
25777: LD_ADDR_VAR 0 15
25781: PUSH
25782: LD_VAR 0 4
25786: PUSH
25787: LD_INT 2
25789: ARRAY
25790: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25791: LD_ADDR_VAR 0 14
25795: PUSH
25796: LD_INT 0
25798: PUSH
25799: LD_INT 2
25801: PUSH
25802: LD_INT 3
25804: PUSH
25805: LD_INT 5
25807: PUSH
25808: EMPTY
25809: LIST
25810: LIST
25811: LIST
25812: LIST
25813: ST_TO_ADDR
// for i in tmp do
25814: LD_ADDR_VAR 0 8
25818: PUSH
25819: LD_VAR 0 14
25823: PUSH
25824: FOR_IN
25825: IFFALSE 25995
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25827: LD_ADDR_VAR 0 9
25831: PUSH
25832: LD_VAR 0 10
25836: PPUSH
25837: LD_VAR 0 8
25841: PPUSH
25842: LD_INT 5
25844: PPUSH
25845: CALL_OW 272
25849: PUSH
25850: LD_VAR 0 11
25854: PPUSH
25855: LD_VAR 0 8
25859: PPUSH
25860: LD_INT 5
25862: PPUSH
25863: CALL_OW 273
25867: PUSH
25868: EMPTY
25869: LIST
25870: LIST
25871: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25872: LD_VAR 0 9
25876: PUSH
25877: LD_INT 1
25879: ARRAY
25880: PPUSH
25881: LD_VAR 0 9
25885: PUSH
25886: LD_INT 2
25888: ARRAY
25889: PPUSH
25890: CALL_OW 488
25894: IFFALSE 25993
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25896: LD_ADDR_VAR 0 4
25900: PUSH
25901: LD_VAR 0 9
25905: PUSH
25906: LD_INT 1
25908: ARRAY
25909: PPUSH
25910: LD_VAR 0 9
25914: PUSH
25915: LD_INT 2
25917: ARRAY
25918: PPUSH
25919: CALL_OW 546
25923: ST_TO_ADDR
// if hex [ 1 ] then
25924: LD_VAR 0 4
25928: PUSH
25929: LD_INT 1
25931: ARRAY
25932: IFFALSE 25936
// continue ;
25934: GO 25824
// h := hex [ 2 ] ;
25936: LD_ADDR_VAR 0 13
25940: PUSH
25941: LD_VAR 0 4
25945: PUSH
25946: LD_INT 2
25948: ARRAY
25949: ST_TO_ADDR
// if h + 7 < height then
25950: LD_VAR 0 13
25954: PUSH
25955: LD_INT 7
25957: PLUS
25958: PUSH
25959: LD_VAR 0 15
25963: LESS
25964: IFFALSE 25993
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25966: LD_ADDR_VAR 0 18
25970: PUSH
25971: LD_INT 7
25973: PUSH
25974: LD_INT 28
25976: PUSH
25977: LD_INT 45
25979: PUSH
25980: EMPTY
25981: LIST
25982: LIST
25983: LIST
25984: PUSH
25985: LD_VAR 0 12
25989: ARRAY
25990: ST_TO_ADDR
// break ;
25991: GO 25995
// end ; end ; end ;
25993: GO 25824
25995: POP
25996: POP
// end ; if not weapon then
25997: LD_VAR 0 18
26001: NOT
26002: IFFALSE 26062
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26004: LD_ADDR_VAR 0 5
26008: PUSH
26009: LD_VAR 0 5
26013: PUSH
26014: LD_INT 11
26016: PUSH
26017: LD_INT 30
26019: PUSH
26020: LD_INT 49
26022: PUSH
26023: EMPTY
26024: LIST
26025: LIST
26026: LIST
26027: DIFF
26028: ST_TO_ADDR
// if not list then
26029: LD_VAR 0 5
26033: NOT
26034: IFFALSE 26038
// exit ;
26036: GO 26180
// weapon := list [ rand ( 1 , list ) ] ;
26038: LD_ADDR_VAR 0 18
26042: PUSH
26043: LD_VAR 0 5
26047: PUSH
26048: LD_INT 1
26050: PPUSH
26051: LD_VAR 0 5
26055: PPUSH
26056: CALL_OW 12
26060: ARRAY
26061: ST_TO_ADDR
// end ; if weapon then
26062: LD_VAR 0 18
26066: IFFALSE 26180
// begin tmp := CostOfWeapon ( weapon ) ;
26068: LD_ADDR_VAR 0 14
26072: PUSH
26073: LD_VAR 0 18
26077: PPUSH
26078: CALL_OW 451
26082: ST_TO_ADDR
// j := GetBase ( tower ) ;
26083: LD_ADDR_VAR 0 9
26087: PUSH
26088: LD_VAR 0 1
26092: PPUSH
26093: CALL_OW 274
26097: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26098: LD_VAR 0 9
26102: PPUSH
26103: LD_INT 1
26105: PPUSH
26106: CALL_OW 275
26110: PUSH
26111: LD_VAR 0 14
26115: PUSH
26116: LD_INT 1
26118: ARRAY
26119: GREATEREQUAL
26120: PUSH
26121: LD_VAR 0 9
26125: PPUSH
26126: LD_INT 2
26128: PPUSH
26129: CALL_OW 275
26133: PUSH
26134: LD_VAR 0 14
26138: PUSH
26139: LD_INT 2
26141: ARRAY
26142: GREATEREQUAL
26143: AND
26144: PUSH
26145: LD_VAR 0 9
26149: PPUSH
26150: LD_INT 3
26152: PPUSH
26153: CALL_OW 275
26157: PUSH
26158: LD_VAR 0 14
26162: PUSH
26163: LD_INT 3
26165: ARRAY
26166: GREATEREQUAL
26167: AND
26168: IFFALSE 26180
// result := weapon ;
26170: LD_ADDR_VAR 0 3
26174: PUSH
26175: LD_VAR 0 18
26179: ST_TO_ADDR
// end ; end ;
26180: LD_VAR 0 3
26184: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26185: LD_INT 0
26187: PPUSH
26188: PPUSH
// result := true ;
26189: LD_ADDR_VAR 0 3
26193: PUSH
26194: LD_INT 1
26196: ST_TO_ADDR
// if array1 = array2 then
26197: LD_VAR 0 1
26201: PUSH
26202: LD_VAR 0 2
26206: EQUAL
26207: IFFALSE 26267
// begin for i = 1 to array1 do
26209: LD_ADDR_VAR 0 4
26213: PUSH
26214: DOUBLE
26215: LD_INT 1
26217: DEC
26218: ST_TO_ADDR
26219: LD_VAR 0 1
26223: PUSH
26224: FOR_TO
26225: IFFALSE 26263
// if array1 [ i ] <> array2 [ i ] then
26227: LD_VAR 0 1
26231: PUSH
26232: LD_VAR 0 4
26236: ARRAY
26237: PUSH
26238: LD_VAR 0 2
26242: PUSH
26243: LD_VAR 0 4
26247: ARRAY
26248: NONEQUAL
26249: IFFALSE 26261
// begin result := false ;
26251: LD_ADDR_VAR 0 3
26255: PUSH
26256: LD_INT 0
26258: ST_TO_ADDR
// break ;
26259: GO 26263
// end ;
26261: GO 26224
26263: POP
26264: POP
// end else
26265: GO 26275
// result := false ;
26267: LD_ADDR_VAR 0 3
26271: PUSH
26272: LD_INT 0
26274: ST_TO_ADDR
// end ;
26275: LD_VAR 0 3
26279: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26280: LD_INT 0
26282: PPUSH
26283: PPUSH
// if not array1 or not array2 then
26284: LD_VAR 0 1
26288: NOT
26289: PUSH
26290: LD_VAR 0 2
26294: NOT
26295: OR
26296: IFFALSE 26300
// exit ;
26298: GO 26364
// result := true ;
26300: LD_ADDR_VAR 0 3
26304: PUSH
26305: LD_INT 1
26307: ST_TO_ADDR
// for i = 1 to array1 do
26308: LD_ADDR_VAR 0 4
26312: PUSH
26313: DOUBLE
26314: LD_INT 1
26316: DEC
26317: ST_TO_ADDR
26318: LD_VAR 0 1
26322: PUSH
26323: FOR_TO
26324: IFFALSE 26362
// if array1 [ i ] <> array2 [ i ] then
26326: LD_VAR 0 1
26330: PUSH
26331: LD_VAR 0 4
26335: ARRAY
26336: PUSH
26337: LD_VAR 0 2
26341: PUSH
26342: LD_VAR 0 4
26346: ARRAY
26347: NONEQUAL
26348: IFFALSE 26360
// begin result := false ;
26350: LD_ADDR_VAR 0 3
26354: PUSH
26355: LD_INT 0
26357: ST_TO_ADDR
// break ;
26358: GO 26362
// end ;
26360: GO 26323
26362: POP
26363: POP
// end ;
26364: LD_VAR 0 3
26368: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26369: LD_INT 0
26371: PPUSH
26372: PPUSH
26373: PPUSH
// pom := GetBase ( fac ) ;
26374: LD_ADDR_VAR 0 5
26378: PUSH
26379: LD_VAR 0 1
26383: PPUSH
26384: CALL_OW 274
26388: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26389: LD_ADDR_VAR 0 4
26393: PUSH
26394: LD_VAR 0 2
26398: PUSH
26399: LD_INT 1
26401: ARRAY
26402: PPUSH
26403: LD_VAR 0 2
26407: PUSH
26408: LD_INT 2
26410: ARRAY
26411: PPUSH
26412: LD_VAR 0 2
26416: PUSH
26417: LD_INT 3
26419: ARRAY
26420: PPUSH
26421: LD_VAR 0 2
26425: PUSH
26426: LD_INT 4
26428: ARRAY
26429: PPUSH
26430: CALL_OW 449
26434: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26435: LD_ADDR_VAR 0 3
26439: PUSH
26440: LD_VAR 0 5
26444: PPUSH
26445: LD_INT 1
26447: PPUSH
26448: CALL_OW 275
26452: PUSH
26453: LD_VAR 0 4
26457: PUSH
26458: LD_INT 1
26460: ARRAY
26461: GREATEREQUAL
26462: PUSH
26463: LD_VAR 0 5
26467: PPUSH
26468: LD_INT 2
26470: PPUSH
26471: CALL_OW 275
26475: PUSH
26476: LD_VAR 0 4
26480: PUSH
26481: LD_INT 2
26483: ARRAY
26484: GREATEREQUAL
26485: AND
26486: PUSH
26487: LD_VAR 0 5
26491: PPUSH
26492: LD_INT 3
26494: PPUSH
26495: CALL_OW 275
26499: PUSH
26500: LD_VAR 0 4
26504: PUSH
26505: LD_INT 3
26507: ARRAY
26508: GREATEREQUAL
26509: AND
26510: ST_TO_ADDR
// end ;
26511: LD_VAR 0 3
26515: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26516: LD_INT 0
26518: PPUSH
26519: PPUSH
26520: PPUSH
26521: PPUSH
// pom := GetBase ( building ) ;
26522: LD_ADDR_VAR 0 3
26526: PUSH
26527: LD_VAR 0 1
26531: PPUSH
26532: CALL_OW 274
26536: ST_TO_ADDR
// if not pom then
26537: LD_VAR 0 3
26541: NOT
26542: IFFALSE 26546
// exit ;
26544: GO 26716
// btype := GetBType ( building ) ;
26546: LD_ADDR_VAR 0 5
26550: PUSH
26551: LD_VAR 0 1
26555: PPUSH
26556: CALL_OW 266
26560: ST_TO_ADDR
// if btype = b_armoury then
26561: LD_VAR 0 5
26565: PUSH
26566: LD_INT 4
26568: EQUAL
26569: IFFALSE 26579
// btype := b_barracks ;
26571: LD_ADDR_VAR 0 5
26575: PUSH
26576: LD_INT 5
26578: ST_TO_ADDR
// if btype = b_depot then
26579: LD_VAR 0 5
26583: PUSH
26584: LD_INT 0
26586: EQUAL
26587: IFFALSE 26597
// btype := b_warehouse ;
26589: LD_ADDR_VAR 0 5
26593: PUSH
26594: LD_INT 1
26596: ST_TO_ADDR
// if btype = b_workshop then
26597: LD_VAR 0 5
26601: PUSH
26602: LD_INT 2
26604: EQUAL
26605: IFFALSE 26615
// btype := b_factory ;
26607: LD_ADDR_VAR 0 5
26611: PUSH
26612: LD_INT 3
26614: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26615: LD_ADDR_VAR 0 4
26619: PUSH
26620: LD_VAR 0 5
26624: PPUSH
26625: LD_VAR 0 1
26629: PPUSH
26630: CALL_OW 248
26634: PPUSH
26635: CALL_OW 450
26639: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26640: LD_ADDR_VAR 0 2
26644: PUSH
26645: LD_VAR 0 3
26649: PPUSH
26650: LD_INT 1
26652: PPUSH
26653: CALL_OW 275
26657: PUSH
26658: LD_VAR 0 4
26662: PUSH
26663: LD_INT 1
26665: ARRAY
26666: GREATEREQUAL
26667: PUSH
26668: LD_VAR 0 3
26672: PPUSH
26673: LD_INT 2
26675: PPUSH
26676: CALL_OW 275
26680: PUSH
26681: LD_VAR 0 4
26685: PUSH
26686: LD_INT 2
26688: ARRAY
26689: GREATEREQUAL
26690: AND
26691: PUSH
26692: LD_VAR 0 3
26696: PPUSH
26697: LD_INT 3
26699: PPUSH
26700: CALL_OW 275
26704: PUSH
26705: LD_VAR 0 4
26709: PUSH
26710: LD_INT 3
26712: ARRAY
26713: GREATEREQUAL
26714: AND
26715: ST_TO_ADDR
// end ;
26716: LD_VAR 0 2
26720: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26721: LD_INT 0
26723: PPUSH
26724: PPUSH
26725: PPUSH
// pom := GetBase ( building ) ;
26726: LD_ADDR_VAR 0 4
26730: PUSH
26731: LD_VAR 0 1
26735: PPUSH
26736: CALL_OW 274
26740: ST_TO_ADDR
// if not pom then
26741: LD_VAR 0 4
26745: NOT
26746: IFFALSE 26750
// exit ;
26748: GO 26851
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26750: LD_ADDR_VAR 0 5
26754: PUSH
26755: LD_VAR 0 2
26759: PPUSH
26760: LD_VAR 0 1
26764: PPUSH
26765: CALL_OW 248
26769: PPUSH
26770: CALL_OW 450
26774: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26775: LD_ADDR_VAR 0 3
26779: PUSH
26780: LD_VAR 0 4
26784: PPUSH
26785: LD_INT 1
26787: PPUSH
26788: CALL_OW 275
26792: PUSH
26793: LD_VAR 0 5
26797: PUSH
26798: LD_INT 1
26800: ARRAY
26801: GREATEREQUAL
26802: PUSH
26803: LD_VAR 0 4
26807: PPUSH
26808: LD_INT 2
26810: PPUSH
26811: CALL_OW 275
26815: PUSH
26816: LD_VAR 0 5
26820: PUSH
26821: LD_INT 2
26823: ARRAY
26824: GREATEREQUAL
26825: AND
26826: PUSH
26827: LD_VAR 0 4
26831: PPUSH
26832: LD_INT 3
26834: PPUSH
26835: CALL_OW 275
26839: PUSH
26840: LD_VAR 0 5
26844: PUSH
26845: LD_INT 3
26847: ARRAY
26848: GREATEREQUAL
26849: AND
26850: ST_TO_ADDR
// end ;
26851: LD_VAR 0 3
26855: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26856: LD_INT 0
26858: PPUSH
26859: PPUSH
26860: PPUSH
26861: PPUSH
26862: PPUSH
26863: PPUSH
26864: PPUSH
26865: PPUSH
26866: PPUSH
26867: PPUSH
26868: PPUSH
// result := false ;
26869: LD_ADDR_VAR 0 8
26873: PUSH
26874: LD_INT 0
26876: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26877: LD_VAR 0 5
26881: NOT
26882: PUSH
26883: LD_VAR 0 1
26887: NOT
26888: OR
26889: PUSH
26890: LD_VAR 0 2
26894: NOT
26895: OR
26896: PUSH
26897: LD_VAR 0 3
26901: NOT
26902: OR
26903: IFFALSE 26907
// exit ;
26905: GO 27721
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26907: LD_ADDR_VAR 0 14
26911: PUSH
26912: LD_VAR 0 1
26916: PPUSH
26917: LD_VAR 0 2
26921: PPUSH
26922: LD_VAR 0 3
26926: PPUSH
26927: LD_VAR 0 4
26931: PPUSH
26932: LD_VAR 0 5
26936: PUSH
26937: LD_INT 1
26939: ARRAY
26940: PPUSH
26941: CALL_OW 248
26945: PPUSH
26946: LD_INT 0
26948: PPUSH
26949: CALL 28958 0 6
26953: ST_TO_ADDR
// if not hexes then
26954: LD_VAR 0 14
26958: NOT
26959: IFFALSE 26963
// exit ;
26961: GO 27721
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26963: LD_ADDR_VAR 0 17
26967: PUSH
26968: LD_VAR 0 5
26972: PPUSH
26973: LD_INT 22
26975: PUSH
26976: LD_VAR 0 13
26980: PPUSH
26981: CALL_OW 255
26985: PUSH
26986: EMPTY
26987: LIST
26988: LIST
26989: PUSH
26990: LD_INT 2
26992: PUSH
26993: LD_INT 30
26995: PUSH
26996: LD_INT 0
26998: PUSH
26999: EMPTY
27000: LIST
27001: LIST
27002: PUSH
27003: LD_INT 30
27005: PUSH
27006: LD_INT 1
27008: PUSH
27009: EMPTY
27010: LIST
27011: LIST
27012: PUSH
27013: EMPTY
27014: LIST
27015: LIST
27016: LIST
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PPUSH
27022: CALL_OW 72
27026: ST_TO_ADDR
// for i = 1 to hexes do
27027: LD_ADDR_VAR 0 9
27031: PUSH
27032: DOUBLE
27033: LD_INT 1
27035: DEC
27036: ST_TO_ADDR
27037: LD_VAR 0 14
27041: PUSH
27042: FOR_TO
27043: IFFALSE 27719
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27045: LD_ADDR_VAR 0 13
27049: PUSH
27050: LD_VAR 0 14
27054: PUSH
27055: LD_VAR 0 9
27059: ARRAY
27060: PUSH
27061: LD_INT 1
27063: ARRAY
27064: PPUSH
27065: LD_VAR 0 14
27069: PUSH
27070: LD_VAR 0 9
27074: ARRAY
27075: PUSH
27076: LD_INT 2
27078: ARRAY
27079: PPUSH
27080: CALL_OW 428
27084: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27085: LD_VAR 0 14
27089: PUSH
27090: LD_VAR 0 9
27094: ARRAY
27095: PUSH
27096: LD_INT 1
27098: ARRAY
27099: PPUSH
27100: LD_VAR 0 14
27104: PUSH
27105: LD_VAR 0 9
27109: ARRAY
27110: PUSH
27111: LD_INT 2
27113: ARRAY
27114: PPUSH
27115: CALL_OW 351
27119: PUSH
27120: LD_VAR 0 14
27124: PUSH
27125: LD_VAR 0 9
27129: ARRAY
27130: PUSH
27131: LD_INT 1
27133: ARRAY
27134: PPUSH
27135: LD_VAR 0 14
27139: PUSH
27140: LD_VAR 0 9
27144: ARRAY
27145: PUSH
27146: LD_INT 2
27148: ARRAY
27149: PPUSH
27150: CALL_OW 488
27154: NOT
27155: OR
27156: PUSH
27157: LD_VAR 0 13
27161: PPUSH
27162: CALL_OW 247
27166: PUSH
27167: LD_INT 3
27169: EQUAL
27170: OR
27171: IFFALSE 27177
// exit ;
27173: POP
27174: POP
27175: GO 27721
// if not tmp then
27177: LD_VAR 0 13
27181: NOT
27182: IFFALSE 27186
// continue ;
27184: GO 27042
// result := true ;
27186: LD_ADDR_VAR 0 8
27190: PUSH
27191: LD_INT 1
27193: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27194: LD_VAR 0 6
27198: PUSH
27199: LD_VAR 0 13
27203: PPUSH
27204: CALL_OW 247
27208: PUSH
27209: LD_INT 2
27211: EQUAL
27212: AND
27213: PUSH
27214: LD_VAR 0 13
27218: PPUSH
27219: CALL_OW 263
27223: PUSH
27224: LD_INT 1
27226: EQUAL
27227: AND
27228: IFFALSE 27392
// begin if IsDrivenBy ( tmp ) then
27230: LD_VAR 0 13
27234: PPUSH
27235: CALL_OW 311
27239: IFFALSE 27243
// continue ;
27241: GO 27042
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27243: LD_VAR 0 6
27247: PPUSH
27248: LD_INT 3
27250: PUSH
27251: LD_INT 60
27253: PUSH
27254: EMPTY
27255: LIST
27256: PUSH
27257: EMPTY
27258: LIST
27259: LIST
27260: PUSH
27261: LD_INT 3
27263: PUSH
27264: LD_INT 55
27266: PUSH
27267: EMPTY
27268: LIST
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: EMPTY
27275: LIST
27276: LIST
27277: PPUSH
27278: CALL_OW 72
27282: IFFALSE 27390
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27284: LD_ADDR_VAR 0 18
27288: PUSH
27289: LD_VAR 0 6
27293: PPUSH
27294: LD_INT 3
27296: PUSH
27297: LD_INT 60
27299: PUSH
27300: EMPTY
27301: LIST
27302: PUSH
27303: EMPTY
27304: LIST
27305: LIST
27306: PUSH
27307: LD_INT 3
27309: PUSH
27310: LD_INT 55
27312: PUSH
27313: EMPTY
27314: LIST
27315: PUSH
27316: EMPTY
27317: LIST
27318: LIST
27319: PUSH
27320: EMPTY
27321: LIST
27322: LIST
27323: PPUSH
27324: CALL_OW 72
27328: PUSH
27329: LD_INT 1
27331: ARRAY
27332: ST_TO_ADDR
// if IsInUnit ( driver ) then
27333: LD_VAR 0 18
27337: PPUSH
27338: CALL_OW 310
27342: IFFALSE 27353
// ComExit ( driver ) ;
27344: LD_VAR 0 18
27348: PPUSH
27349: CALL 52663 0 1
// AddComEnterUnit ( driver , tmp ) ;
27353: LD_VAR 0 18
27357: PPUSH
27358: LD_VAR 0 13
27362: PPUSH
27363: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27367: LD_VAR 0 18
27371: PPUSH
27372: LD_VAR 0 7
27376: PPUSH
27377: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27381: LD_VAR 0 18
27385: PPUSH
27386: CALL_OW 181
// end ; continue ;
27390: GO 27042
// end ; if not cleaners or not tmp in cleaners then
27392: LD_VAR 0 6
27396: NOT
27397: PUSH
27398: LD_VAR 0 13
27402: PUSH
27403: LD_VAR 0 6
27407: IN
27408: NOT
27409: OR
27410: IFFALSE 27717
// begin if dep then
27412: LD_VAR 0 17
27416: IFFALSE 27552
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27418: LD_ADDR_VAR 0 16
27422: PUSH
27423: LD_VAR 0 17
27427: PUSH
27428: LD_INT 1
27430: ARRAY
27431: PPUSH
27432: CALL_OW 250
27436: PPUSH
27437: LD_VAR 0 17
27441: PUSH
27442: LD_INT 1
27444: ARRAY
27445: PPUSH
27446: CALL_OW 254
27450: PPUSH
27451: LD_INT 5
27453: PPUSH
27454: CALL_OW 272
27458: PUSH
27459: LD_VAR 0 17
27463: PUSH
27464: LD_INT 1
27466: ARRAY
27467: PPUSH
27468: CALL_OW 251
27472: PPUSH
27473: LD_VAR 0 17
27477: PUSH
27478: LD_INT 1
27480: ARRAY
27481: PPUSH
27482: CALL_OW 254
27486: PPUSH
27487: LD_INT 5
27489: PPUSH
27490: CALL_OW 273
27494: PUSH
27495: EMPTY
27496: LIST
27497: LIST
27498: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27499: LD_VAR 0 16
27503: PUSH
27504: LD_INT 1
27506: ARRAY
27507: PPUSH
27508: LD_VAR 0 16
27512: PUSH
27513: LD_INT 2
27515: ARRAY
27516: PPUSH
27517: CALL_OW 488
27521: IFFALSE 27552
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27523: LD_VAR 0 13
27527: PPUSH
27528: LD_VAR 0 16
27532: PUSH
27533: LD_INT 1
27535: ARRAY
27536: PPUSH
27537: LD_VAR 0 16
27541: PUSH
27542: LD_INT 2
27544: ARRAY
27545: PPUSH
27546: CALL_OW 111
// continue ;
27550: GO 27042
// end ; end ; r := GetDir ( tmp ) ;
27552: LD_ADDR_VAR 0 15
27556: PUSH
27557: LD_VAR 0 13
27561: PPUSH
27562: CALL_OW 254
27566: ST_TO_ADDR
// if r = 5 then
27567: LD_VAR 0 15
27571: PUSH
27572: LD_INT 5
27574: EQUAL
27575: IFFALSE 27585
// r := 0 ;
27577: LD_ADDR_VAR 0 15
27581: PUSH
27582: LD_INT 0
27584: ST_TO_ADDR
// for j = r to 5 do
27585: LD_ADDR_VAR 0 10
27589: PUSH
27590: DOUBLE
27591: LD_VAR 0 15
27595: DEC
27596: ST_TO_ADDR
27597: LD_INT 5
27599: PUSH
27600: FOR_TO
27601: IFFALSE 27715
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
27603: LD_ADDR_VAR 0 11
27607: PUSH
27608: LD_VAR 0 13
27612: PPUSH
27613: CALL_OW 250
27617: PPUSH
27618: LD_VAR 0 10
27622: PPUSH
27623: LD_INT 2
27625: PPUSH
27626: CALL_OW 272
27630: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
27631: LD_ADDR_VAR 0 12
27635: PUSH
27636: LD_VAR 0 13
27640: PPUSH
27641: CALL_OW 251
27645: PPUSH
27646: LD_VAR 0 10
27650: PPUSH
27651: LD_INT 2
27653: PPUSH
27654: CALL_OW 273
27658: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
27659: LD_VAR 0 11
27663: PPUSH
27664: LD_VAR 0 12
27668: PPUSH
27669: CALL_OW 488
27673: PUSH
27674: LD_VAR 0 11
27678: PPUSH
27679: LD_VAR 0 12
27683: PPUSH
27684: CALL_OW 428
27688: NOT
27689: AND
27690: IFFALSE 27713
// begin ComMoveXY ( tmp , _x , _y ) ;
27692: LD_VAR 0 13
27696: PPUSH
27697: LD_VAR 0 11
27701: PPUSH
27702: LD_VAR 0 12
27706: PPUSH
27707: CALL_OW 111
// break ;
27711: GO 27715
// end ; end ;
27713: GO 27600
27715: POP
27716: POP
// end ; end ;
27717: GO 27042
27719: POP
27720: POP
// end ;
27721: LD_VAR 0 8
27725: RET
// export function BuildingTechInvented ( side , btype ) ; begin
27726: LD_INT 0
27728: PPUSH
// result := true ;
27729: LD_ADDR_VAR 0 3
27733: PUSH
27734: LD_INT 1
27736: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
27737: LD_VAR 0 2
27741: PUSH
27742: LD_INT 24
27744: DOUBLE
27745: EQUAL
27746: IFTRUE 27756
27748: LD_INT 33
27750: DOUBLE
27751: EQUAL
27752: IFTRUE 27756
27754: GO 27781
27756: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
27757: LD_ADDR_VAR 0 3
27761: PUSH
27762: LD_INT 32
27764: PPUSH
27765: LD_VAR 0 1
27769: PPUSH
27770: CALL_OW 321
27774: PUSH
27775: LD_INT 2
27777: EQUAL
27778: ST_TO_ADDR
27779: GO 28101
27781: LD_INT 20
27783: DOUBLE
27784: EQUAL
27785: IFTRUE 27789
27787: GO 27814
27789: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
27790: LD_ADDR_VAR 0 3
27794: PUSH
27795: LD_INT 6
27797: PPUSH
27798: LD_VAR 0 1
27802: PPUSH
27803: CALL_OW 321
27807: PUSH
27808: LD_INT 2
27810: EQUAL
27811: ST_TO_ADDR
27812: GO 28101
27814: LD_INT 22
27816: DOUBLE
27817: EQUAL
27818: IFTRUE 27828
27820: LD_INT 36
27822: DOUBLE
27823: EQUAL
27824: IFTRUE 27828
27826: GO 27853
27828: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
27829: LD_ADDR_VAR 0 3
27833: PUSH
27834: LD_INT 15
27836: PPUSH
27837: LD_VAR 0 1
27841: PPUSH
27842: CALL_OW 321
27846: PUSH
27847: LD_INT 2
27849: EQUAL
27850: ST_TO_ADDR
27851: GO 28101
27853: LD_INT 30
27855: DOUBLE
27856: EQUAL
27857: IFTRUE 27861
27859: GO 27886
27861: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
27862: LD_ADDR_VAR 0 3
27866: PUSH
27867: LD_INT 20
27869: PPUSH
27870: LD_VAR 0 1
27874: PPUSH
27875: CALL_OW 321
27879: PUSH
27880: LD_INT 2
27882: EQUAL
27883: ST_TO_ADDR
27884: GO 28101
27886: LD_INT 28
27888: DOUBLE
27889: EQUAL
27890: IFTRUE 27900
27892: LD_INT 21
27894: DOUBLE
27895: EQUAL
27896: IFTRUE 27900
27898: GO 27925
27900: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
27901: LD_ADDR_VAR 0 3
27905: PUSH
27906: LD_INT 21
27908: PPUSH
27909: LD_VAR 0 1
27913: PPUSH
27914: CALL_OW 321
27918: PUSH
27919: LD_INT 2
27921: EQUAL
27922: ST_TO_ADDR
27923: GO 28101
27925: LD_INT 16
27927: DOUBLE
27928: EQUAL
27929: IFTRUE 27933
27931: GO 27960
27933: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
27934: LD_ADDR_VAR 0 3
27938: PUSH
27939: LD_EXP 117
27943: PPUSH
27944: LD_VAR 0 1
27948: PPUSH
27949: CALL_OW 321
27953: PUSH
27954: LD_INT 2
27956: EQUAL
27957: ST_TO_ADDR
27958: GO 28101
27960: LD_INT 19
27962: DOUBLE
27963: EQUAL
27964: IFTRUE 27974
27966: LD_INT 23
27968: DOUBLE
27969: EQUAL
27970: IFTRUE 27974
27972: GO 28001
27974: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
27975: LD_ADDR_VAR 0 3
27979: PUSH
27980: LD_EXP 116
27984: PPUSH
27985: LD_VAR 0 1
27989: PPUSH
27990: CALL_OW 321
27994: PUSH
27995: LD_INT 2
27997: EQUAL
27998: ST_TO_ADDR
27999: GO 28101
28001: LD_INT 17
28003: DOUBLE
28004: EQUAL
28005: IFTRUE 28009
28007: GO 28034
28009: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28010: LD_ADDR_VAR 0 3
28014: PUSH
28015: LD_INT 39
28017: PPUSH
28018: LD_VAR 0 1
28022: PPUSH
28023: CALL_OW 321
28027: PUSH
28028: LD_INT 2
28030: EQUAL
28031: ST_TO_ADDR
28032: GO 28101
28034: LD_INT 18
28036: DOUBLE
28037: EQUAL
28038: IFTRUE 28042
28040: GO 28067
28042: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28043: LD_ADDR_VAR 0 3
28047: PUSH
28048: LD_INT 40
28050: PPUSH
28051: LD_VAR 0 1
28055: PPUSH
28056: CALL_OW 321
28060: PUSH
28061: LD_INT 2
28063: EQUAL
28064: ST_TO_ADDR
28065: GO 28101
28067: LD_INT 27
28069: DOUBLE
28070: EQUAL
28071: IFTRUE 28075
28073: GO 28100
28075: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28076: LD_ADDR_VAR 0 3
28080: PUSH
28081: LD_INT 35
28083: PPUSH
28084: LD_VAR 0 1
28088: PPUSH
28089: CALL_OW 321
28093: PUSH
28094: LD_INT 2
28096: EQUAL
28097: ST_TO_ADDR
28098: GO 28101
28100: POP
// end ;
28101: LD_VAR 0 3
28105: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28106: LD_INT 0
28108: PPUSH
28109: PPUSH
28110: PPUSH
28111: PPUSH
28112: PPUSH
28113: PPUSH
28114: PPUSH
28115: PPUSH
28116: PPUSH
28117: PPUSH
28118: PPUSH
// result := false ;
28119: LD_ADDR_VAR 0 6
28123: PUSH
28124: LD_INT 0
28126: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28127: LD_VAR 0 1
28131: NOT
28132: PUSH
28133: LD_VAR 0 1
28137: PPUSH
28138: CALL_OW 266
28142: PUSH
28143: LD_INT 0
28145: PUSH
28146: LD_INT 1
28148: PUSH
28149: EMPTY
28150: LIST
28151: LIST
28152: IN
28153: NOT
28154: OR
28155: PUSH
28156: LD_VAR 0 2
28160: NOT
28161: OR
28162: PUSH
28163: LD_VAR 0 5
28167: PUSH
28168: LD_INT 0
28170: PUSH
28171: LD_INT 1
28173: PUSH
28174: LD_INT 2
28176: PUSH
28177: LD_INT 3
28179: PUSH
28180: LD_INT 4
28182: PUSH
28183: LD_INT 5
28185: PUSH
28186: EMPTY
28187: LIST
28188: LIST
28189: LIST
28190: LIST
28191: LIST
28192: LIST
28193: IN
28194: NOT
28195: OR
28196: PUSH
28197: LD_VAR 0 3
28201: PPUSH
28202: LD_VAR 0 4
28206: PPUSH
28207: CALL_OW 488
28211: NOT
28212: OR
28213: IFFALSE 28217
// exit ;
28215: GO 28953
// side := GetSide ( depot ) ;
28217: LD_ADDR_VAR 0 9
28221: PUSH
28222: LD_VAR 0 1
28226: PPUSH
28227: CALL_OW 255
28231: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28232: LD_VAR 0 9
28236: PPUSH
28237: LD_VAR 0 2
28241: PPUSH
28242: CALL 27726 0 2
28246: NOT
28247: IFFALSE 28251
// exit ;
28249: GO 28953
// pom := GetBase ( depot ) ;
28251: LD_ADDR_VAR 0 10
28255: PUSH
28256: LD_VAR 0 1
28260: PPUSH
28261: CALL_OW 274
28265: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28266: LD_ADDR_VAR 0 11
28270: PUSH
28271: LD_VAR 0 2
28275: PPUSH
28276: LD_VAR 0 1
28280: PPUSH
28281: CALL_OW 248
28285: PPUSH
28286: CALL_OW 450
28290: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28291: LD_VAR 0 10
28295: PPUSH
28296: LD_INT 1
28298: PPUSH
28299: CALL_OW 275
28303: PUSH
28304: LD_VAR 0 11
28308: PUSH
28309: LD_INT 1
28311: ARRAY
28312: GREATEREQUAL
28313: PUSH
28314: LD_VAR 0 10
28318: PPUSH
28319: LD_INT 2
28321: PPUSH
28322: CALL_OW 275
28326: PUSH
28327: LD_VAR 0 11
28331: PUSH
28332: LD_INT 2
28334: ARRAY
28335: GREATEREQUAL
28336: AND
28337: PUSH
28338: LD_VAR 0 10
28342: PPUSH
28343: LD_INT 3
28345: PPUSH
28346: CALL_OW 275
28350: PUSH
28351: LD_VAR 0 11
28355: PUSH
28356: LD_INT 3
28358: ARRAY
28359: GREATEREQUAL
28360: AND
28361: NOT
28362: IFFALSE 28366
// exit ;
28364: GO 28953
// if GetBType ( depot ) = b_depot then
28366: LD_VAR 0 1
28370: PPUSH
28371: CALL_OW 266
28375: PUSH
28376: LD_INT 0
28378: EQUAL
28379: IFFALSE 28391
// dist := 28 else
28381: LD_ADDR_VAR 0 14
28385: PUSH
28386: LD_INT 28
28388: ST_TO_ADDR
28389: GO 28399
// dist := 36 ;
28391: LD_ADDR_VAR 0 14
28395: PUSH
28396: LD_INT 36
28398: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28399: LD_VAR 0 1
28403: PPUSH
28404: LD_VAR 0 3
28408: PPUSH
28409: LD_VAR 0 4
28413: PPUSH
28414: CALL_OW 297
28418: PUSH
28419: LD_VAR 0 14
28423: GREATER
28424: IFFALSE 28428
// exit ;
28426: GO 28953
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28428: LD_ADDR_VAR 0 12
28432: PUSH
28433: LD_VAR 0 2
28437: PPUSH
28438: LD_VAR 0 3
28442: PPUSH
28443: LD_VAR 0 4
28447: PPUSH
28448: LD_VAR 0 5
28452: PPUSH
28453: LD_VAR 0 1
28457: PPUSH
28458: CALL_OW 248
28462: PPUSH
28463: LD_INT 0
28465: PPUSH
28466: CALL 28958 0 6
28470: ST_TO_ADDR
// if not hexes then
28471: LD_VAR 0 12
28475: NOT
28476: IFFALSE 28480
// exit ;
28478: GO 28953
// hex := GetHexInfo ( x , y ) ;
28480: LD_ADDR_VAR 0 15
28484: PUSH
28485: LD_VAR 0 3
28489: PPUSH
28490: LD_VAR 0 4
28494: PPUSH
28495: CALL_OW 546
28499: ST_TO_ADDR
// if hex [ 1 ] then
28500: LD_VAR 0 15
28504: PUSH
28505: LD_INT 1
28507: ARRAY
28508: IFFALSE 28512
// exit ;
28510: GO 28953
// height := hex [ 2 ] ;
28512: LD_ADDR_VAR 0 13
28516: PUSH
28517: LD_VAR 0 15
28521: PUSH
28522: LD_INT 2
28524: ARRAY
28525: ST_TO_ADDR
// for i = 1 to hexes do
28526: LD_ADDR_VAR 0 7
28530: PUSH
28531: DOUBLE
28532: LD_INT 1
28534: DEC
28535: ST_TO_ADDR
28536: LD_VAR 0 12
28540: PUSH
28541: FOR_TO
28542: IFFALSE 28872
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28544: LD_VAR 0 12
28548: PUSH
28549: LD_VAR 0 7
28553: ARRAY
28554: PUSH
28555: LD_INT 1
28557: ARRAY
28558: PPUSH
28559: LD_VAR 0 12
28563: PUSH
28564: LD_VAR 0 7
28568: ARRAY
28569: PUSH
28570: LD_INT 2
28572: ARRAY
28573: PPUSH
28574: CALL_OW 488
28578: NOT
28579: PUSH
28580: LD_VAR 0 12
28584: PUSH
28585: LD_VAR 0 7
28589: ARRAY
28590: PUSH
28591: LD_INT 1
28593: ARRAY
28594: PPUSH
28595: LD_VAR 0 12
28599: PUSH
28600: LD_VAR 0 7
28604: ARRAY
28605: PUSH
28606: LD_INT 2
28608: ARRAY
28609: PPUSH
28610: CALL_OW 428
28614: PUSH
28615: LD_INT 0
28617: GREATER
28618: OR
28619: PUSH
28620: LD_VAR 0 12
28624: PUSH
28625: LD_VAR 0 7
28629: ARRAY
28630: PUSH
28631: LD_INT 1
28633: ARRAY
28634: PPUSH
28635: LD_VAR 0 12
28639: PUSH
28640: LD_VAR 0 7
28644: ARRAY
28645: PUSH
28646: LD_INT 2
28648: ARRAY
28649: PPUSH
28650: CALL_OW 351
28654: OR
28655: IFFALSE 28661
// exit ;
28657: POP
28658: POP
28659: GO 28953
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28661: LD_ADDR_VAR 0 8
28665: PUSH
28666: LD_VAR 0 12
28670: PUSH
28671: LD_VAR 0 7
28675: ARRAY
28676: PUSH
28677: LD_INT 1
28679: ARRAY
28680: PPUSH
28681: LD_VAR 0 12
28685: PUSH
28686: LD_VAR 0 7
28690: ARRAY
28691: PUSH
28692: LD_INT 2
28694: ARRAY
28695: PPUSH
28696: CALL_OW 546
28700: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
28701: LD_VAR 0 8
28705: PUSH
28706: LD_INT 1
28708: ARRAY
28709: PUSH
28710: LD_VAR 0 8
28714: PUSH
28715: LD_INT 2
28717: ARRAY
28718: PUSH
28719: LD_VAR 0 13
28723: PUSH
28724: LD_INT 2
28726: PLUS
28727: GREATER
28728: OR
28729: PUSH
28730: LD_VAR 0 8
28734: PUSH
28735: LD_INT 2
28737: ARRAY
28738: PUSH
28739: LD_VAR 0 13
28743: PUSH
28744: LD_INT 2
28746: MINUS
28747: LESS
28748: OR
28749: PUSH
28750: LD_VAR 0 8
28754: PUSH
28755: LD_INT 3
28757: ARRAY
28758: PUSH
28759: LD_INT 0
28761: PUSH
28762: LD_INT 8
28764: PUSH
28765: LD_INT 9
28767: PUSH
28768: LD_INT 10
28770: PUSH
28771: LD_INT 11
28773: PUSH
28774: LD_INT 12
28776: PUSH
28777: LD_INT 13
28779: PUSH
28780: LD_INT 16
28782: PUSH
28783: LD_INT 17
28785: PUSH
28786: LD_INT 18
28788: PUSH
28789: LD_INT 19
28791: PUSH
28792: LD_INT 20
28794: PUSH
28795: LD_INT 21
28797: PUSH
28798: EMPTY
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: IN
28813: NOT
28814: OR
28815: PUSH
28816: LD_VAR 0 8
28820: PUSH
28821: LD_INT 5
28823: ARRAY
28824: NOT
28825: OR
28826: PUSH
28827: LD_VAR 0 8
28831: PUSH
28832: LD_INT 6
28834: ARRAY
28835: PUSH
28836: LD_INT 1
28838: PUSH
28839: LD_INT 2
28841: PUSH
28842: LD_INT 7
28844: PUSH
28845: LD_INT 9
28847: PUSH
28848: LD_INT 10
28850: PUSH
28851: LD_INT 11
28853: PUSH
28854: EMPTY
28855: LIST
28856: LIST
28857: LIST
28858: LIST
28859: LIST
28860: LIST
28861: IN
28862: NOT
28863: OR
28864: IFFALSE 28870
// exit ;
28866: POP
28867: POP
28868: GO 28953
// end ;
28870: GO 28541
28872: POP
28873: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
28874: LD_VAR 0 9
28878: PPUSH
28879: LD_VAR 0 3
28883: PPUSH
28884: LD_VAR 0 4
28888: PPUSH
28889: LD_INT 20
28891: PPUSH
28892: CALL 20899 0 4
28896: PUSH
28897: LD_INT 4
28899: ARRAY
28900: IFFALSE 28904
// exit ;
28902: GO 28953
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
28904: LD_VAR 0 2
28908: PUSH
28909: LD_INT 29
28911: PUSH
28912: LD_INT 30
28914: PUSH
28915: EMPTY
28916: LIST
28917: LIST
28918: IN
28919: PUSH
28920: LD_VAR 0 3
28924: PPUSH
28925: LD_VAR 0 4
28929: PPUSH
28930: LD_VAR 0 9
28934: PPUSH
28935: CALL_OW 440
28939: NOT
28940: AND
28941: IFFALSE 28945
// exit ;
28943: GO 28953
// result := true ;
28945: LD_ADDR_VAR 0 6
28949: PUSH
28950: LD_INT 1
28952: ST_TO_ADDR
// end ;
28953: LD_VAR 0 6
28957: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
28958: LD_INT 0
28960: PPUSH
28961: PPUSH
28962: PPUSH
28963: PPUSH
28964: PPUSH
28965: PPUSH
28966: PPUSH
28967: PPUSH
28968: PPUSH
28969: PPUSH
28970: PPUSH
28971: PPUSH
28972: PPUSH
28973: PPUSH
28974: PPUSH
28975: PPUSH
28976: PPUSH
28977: PPUSH
28978: PPUSH
28979: PPUSH
28980: PPUSH
28981: PPUSH
28982: PPUSH
28983: PPUSH
28984: PPUSH
28985: PPUSH
28986: PPUSH
28987: PPUSH
28988: PPUSH
28989: PPUSH
28990: PPUSH
28991: PPUSH
28992: PPUSH
28993: PPUSH
28994: PPUSH
28995: PPUSH
28996: PPUSH
28997: PPUSH
28998: PPUSH
28999: PPUSH
29000: PPUSH
29001: PPUSH
29002: PPUSH
29003: PPUSH
29004: PPUSH
29005: PPUSH
29006: PPUSH
29007: PPUSH
29008: PPUSH
29009: PPUSH
29010: PPUSH
29011: PPUSH
29012: PPUSH
29013: PPUSH
29014: PPUSH
29015: PPUSH
29016: PPUSH
29017: PPUSH
// result = [ ] ;
29018: LD_ADDR_VAR 0 7
29022: PUSH
29023: EMPTY
29024: ST_TO_ADDR
// temp_list = [ ] ;
29025: LD_ADDR_VAR 0 9
29029: PUSH
29030: EMPTY
29031: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29032: LD_VAR 0 4
29036: PUSH
29037: LD_INT 0
29039: PUSH
29040: LD_INT 1
29042: PUSH
29043: LD_INT 2
29045: PUSH
29046: LD_INT 3
29048: PUSH
29049: LD_INT 4
29051: PUSH
29052: LD_INT 5
29054: PUSH
29055: EMPTY
29056: LIST
29057: LIST
29058: LIST
29059: LIST
29060: LIST
29061: LIST
29062: IN
29063: NOT
29064: PUSH
29065: LD_VAR 0 1
29069: PUSH
29070: LD_INT 0
29072: PUSH
29073: LD_INT 1
29075: PUSH
29076: EMPTY
29077: LIST
29078: LIST
29079: IN
29080: PUSH
29081: LD_VAR 0 5
29085: PUSH
29086: LD_INT 1
29088: PUSH
29089: LD_INT 2
29091: PUSH
29092: LD_INT 3
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: LIST
29099: IN
29100: NOT
29101: AND
29102: OR
29103: IFFALSE 29107
// exit ;
29105: GO 47498
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29107: LD_VAR 0 1
29111: PUSH
29112: LD_INT 6
29114: PUSH
29115: LD_INT 7
29117: PUSH
29118: LD_INT 8
29120: PUSH
29121: LD_INT 13
29123: PUSH
29124: LD_INT 12
29126: PUSH
29127: LD_INT 15
29129: PUSH
29130: LD_INT 11
29132: PUSH
29133: LD_INT 14
29135: PUSH
29136: LD_INT 10
29138: PUSH
29139: EMPTY
29140: LIST
29141: LIST
29142: LIST
29143: LIST
29144: LIST
29145: LIST
29146: LIST
29147: LIST
29148: LIST
29149: IN
29150: IFFALSE 29160
// btype = b_lab ;
29152: LD_ADDR_VAR 0 1
29156: PUSH
29157: LD_INT 6
29159: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29160: LD_VAR 0 6
29164: PUSH
29165: LD_INT 0
29167: PUSH
29168: LD_INT 1
29170: PUSH
29171: LD_INT 2
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: LIST
29178: IN
29179: NOT
29180: PUSH
29181: LD_VAR 0 1
29185: PUSH
29186: LD_INT 0
29188: PUSH
29189: LD_INT 1
29191: PUSH
29192: LD_INT 2
29194: PUSH
29195: LD_INT 3
29197: PUSH
29198: LD_INT 6
29200: PUSH
29201: LD_INT 36
29203: PUSH
29204: LD_INT 4
29206: PUSH
29207: LD_INT 5
29209: PUSH
29210: LD_INT 31
29212: PUSH
29213: LD_INT 32
29215: PUSH
29216: LD_INT 33
29218: PUSH
29219: EMPTY
29220: LIST
29221: LIST
29222: LIST
29223: LIST
29224: LIST
29225: LIST
29226: LIST
29227: LIST
29228: LIST
29229: LIST
29230: LIST
29231: IN
29232: NOT
29233: PUSH
29234: LD_VAR 0 6
29238: PUSH
29239: LD_INT 1
29241: EQUAL
29242: AND
29243: OR
29244: PUSH
29245: LD_VAR 0 1
29249: PUSH
29250: LD_INT 2
29252: PUSH
29253: LD_INT 3
29255: PUSH
29256: EMPTY
29257: LIST
29258: LIST
29259: IN
29260: NOT
29261: PUSH
29262: LD_VAR 0 6
29266: PUSH
29267: LD_INT 2
29269: EQUAL
29270: AND
29271: OR
29272: IFFALSE 29282
// mode = 0 ;
29274: LD_ADDR_VAR 0 6
29278: PUSH
29279: LD_INT 0
29281: ST_TO_ADDR
// case mode of 0 :
29282: LD_VAR 0 6
29286: PUSH
29287: LD_INT 0
29289: DOUBLE
29290: EQUAL
29291: IFTRUE 29295
29293: GO 40748
29295: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29296: LD_ADDR_VAR 0 11
29300: PUSH
29301: LD_INT 0
29303: PUSH
29304: LD_INT 0
29306: PUSH
29307: EMPTY
29308: LIST
29309: LIST
29310: PUSH
29311: LD_INT 0
29313: PUSH
29314: LD_INT 1
29316: NEG
29317: PUSH
29318: EMPTY
29319: LIST
29320: LIST
29321: PUSH
29322: LD_INT 1
29324: PUSH
29325: LD_INT 0
29327: PUSH
29328: EMPTY
29329: LIST
29330: LIST
29331: PUSH
29332: LD_INT 1
29334: PUSH
29335: LD_INT 1
29337: PUSH
29338: EMPTY
29339: LIST
29340: LIST
29341: PUSH
29342: LD_INT 0
29344: PUSH
29345: LD_INT 1
29347: PUSH
29348: EMPTY
29349: LIST
29350: LIST
29351: PUSH
29352: LD_INT 1
29354: NEG
29355: PUSH
29356: LD_INT 0
29358: PUSH
29359: EMPTY
29360: LIST
29361: LIST
29362: PUSH
29363: LD_INT 1
29365: NEG
29366: PUSH
29367: LD_INT 1
29369: NEG
29370: PUSH
29371: EMPTY
29372: LIST
29373: LIST
29374: PUSH
29375: LD_INT 1
29377: NEG
29378: PUSH
29379: LD_INT 2
29381: NEG
29382: PUSH
29383: EMPTY
29384: LIST
29385: LIST
29386: PUSH
29387: LD_INT 0
29389: PUSH
29390: LD_INT 2
29392: NEG
29393: PUSH
29394: EMPTY
29395: LIST
29396: LIST
29397: PUSH
29398: LD_INT 1
29400: PUSH
29401: LD_INT 1
29403: NEG
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: PUSH
29409: LD_INT 1
29411: PUSH
29412: LD_INT 2
29414: PUSH
29415: EMPTY
29416: LIST
29417: LIST
29418: PUSH
29419: LD_INT 0
29421: PUSH
29422: LD_INT 2
29424: PUSH
29425: EMPTY
29426: LIST
29427: LIST
29428: PUSH
29429: LD_INT 1
29431: NEG
29432: PUSH
29433: LD_INT 1
29435: PUSH
29436: EMPTY
29437: LIST
29438: LIST
29439: PUSH
29440: LD_INT 1
29442: PUSH
29443: LD_INT 3
29445: PUSH
29446: EMPTY
29447: LIST
29448: LIST
29449: PUSH
29450: LD_INT 0
29452: PUSH
29453: LD_INT 3
29455: PUSH
29456: EMPTY
29457: LIST
29458: LIST
29459: PUSH
29460: LD_INT 1
29462: NEG
29463: PUSH
29464: LD_INT 2
29466: PUSH
29467: EMPTY
29468: LIST
29469: LIST
29470: PUSH
29471: EMPTY
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: LIST
29478: LIST
29479: LIST
29480: LIST
29481: LIST
29482: LIST
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29489: LD_ADDR_VAR 0 12
29493: PUSH
29494: LD_INT 0
29496: PUSH
29497: LD_INT 0
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 0
29506: PUSH
29507: LD_INT 1
29509: NEG
29510: PUSH
29511: EMPTY
29512: LIST
29513: LIST
29514: PUSH
29515: LD_INT 1
29517: PUSH
29518: LD_INT 0
29520: PUSH
29521: EMPTY
29522: LIST
29523: LIST
29524: PUSH
29525: LD_INT 1
29527: PUSH
29528: LD_INT 1
29530: PUSH
29531: EMPTY
29532: LIST
29533: LIST
29534: PUSH
29535: LD_INT 0
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: NEG
29548: PUSH
29549: LD_INT 0
29551: PUSH
29552: EMPTY
29553: LIST
29554: LIST
29555: PUSH
29556: LD_INT 1
29558: NEG
29559: PUSH
29560: LD_INT 1
29562: NEG
29563: PUSH
29564: EMPTY
29565: LIST
29566: LIST
29567: PUSH
29568: LD_INT 1
29570: PUSH
29571: LD_INT 1
29573: NEG
29574: PUSH
29575: EMPTY
29576: LIST
29577: LIST
29578: PUSH
29579: LD_INT 2
29581: PUSH
29582: LD_INT 0
29584: PUSH
29585: EMPTY
29586: LIST
29587: LIST
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: LD_INT 1
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PUSH
29599: LD_INT 1
29601: NEG
29602: PUSH
29603: LD_INT 1
29605: PUSH
29606: EMPTY
29607: LIST
29608: LIST
29609: PUSH
29610: LD_INT 2
29612: NEG
29613: PUSH
29614: LD_INT 0
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 2
29623: NEG
29624: PUSH
29625: LD_INT 1
29627: NEG
29628: PUSH
29629: EMPTY
29630: LIST
29631: LIST
29632: PUSH
29633: LD_INT 2
29635: NEG
29636: PUSH
29637: LD_INT 1
29639: PUSH
29640: EMPTY
29641: LIST
29642: LIST
29643: PUSH
29644: LD_INT 3
29646: NEG
29647: PUSH
29648: LD_INT 0
29650: PUSH
29651: EMPTY
29652: LIST
29653: LIST
29654: PUSH
29655: LD_INT 3
29657: NEG
29658: PUSH
29659: LD_INT 1
29661: NEG
29662: PUSH
29663: EMPTY
29664: LIST
29665: LIST
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: LIST
29683: LIST
29684: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
29685: LD_ADDR_VAR 0 13
29689: PUSH
29690: LD_INT 0
29692: PUSH
29693: LD_INT 0
29695: PUSH
29696: EMPTY
29697: LIST
29698: LIST
29699: PUSH
29700: LD_INT 0
29702: PUSH
29703: LD_INT 1
29705: NEG
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: PUSH
29711: LD_INT 1
29713: PUSH
29714: LD_INT 0
29716: PUSH
29717: EMPTY
29718: LIST
29719: LIST
29720: PUSH
29721: LD_INT 1
29723: PUSH
29724: LD_INT 1
29726: PUSH
29727: EMPTY
29728: LIST
29729: LIST
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: LD_INT 1
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 1
29743: NEG
29744: PUSH
29745: LD_INT 0
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: NEG
29755: PUSH
29756: LD_INT 1
29758: NEG
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 2
29770: NEG
29771: PUSH
29772: EMPTY
29773: LIST
29774: LIST
29775: PUSH
29776: LD_INT 2
29778: PUSH
29779: LD_INT 1
29781: PUSH
29782: EMPTY
29783: LIST
29784: LIST
29785: PUSH
29786: LD_INT 2
29788: PUSH
29789: LD_INT 2
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 1
29798: PUSH
29799: LD_INT 2
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: NEG
29809: PUSH
29810: LD_INT 1
29812: NEG
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: PUSH
29818: LD_INT 2
29820: NEG
29821: PUSH
29822: LD_INT 2
29824: NEG
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PUSH
29830: LD_INT 2
29832: NEG
29833: PUSH
29834: LD_INT 3
29836: NEG
29837: PUSH
29838: EMPTY
29839: LIST
29840: LIST
29841: PUSH
29842: LD_INT 3
29844: NEG
29845: PUSH
29846: LD_INT 2
29848: NEG
29849: PUSH
29850: EMPTY
29851: LIST
29852: LIST
29853: PUSH
29854: LD_INT 3
29856: NEG
29857: PUSH
29858: LD_INT 3
29860: NEG
29861: PUSH
29862: EMPTY
29863: LIST
29864: LIST
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: LIST
29870: LIST
29871: LIST
29872: LIST
29873: LIST
29874: LIST
29875: LIST
29876: LIST
29877: LIST
29878: LIST
29879: LIST
29880: LIST
29881: LIST
29882: LIST
29883: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
29884: LD_ADDR_VAR 0 14
29888: PUSH
29889: LD_INT 0
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 0
29901: PUSH
29902: LD_INT 1
29904: NEG
29905: PUSH
29906: EMPTY
29907: LIST
29908: LIST
29909: PUSH
29910: LD_INT 1
29912: PUSH
29913: LD_INT 0
29915: PUSH
29916: EMPTY
29917: LIST
29918: LIST
29919: PUSH
29920: LD_INT 1
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: EMPTY
29927: LIST
29928: LIST
29929: PUSH
29930: LD_INT 0
29932: PUSH
29933: LD_INT 1
29935: PUSH
29936: EMPTY
29937: LIST
29938: LIST
29939: PUSH
29940: LD_INT 1
29942: NEG
29943: PUSH
29944: LD_INT 0
29946: PUSH
29947: EMPTY
29948: LIST
29949: LIST
29950: PUSH
29951: LD_INT 1
29953: NEG
29954: PUSH
29955: LD_INT 1
29957: NEG
29958: PUSH
29959: EMPTY
29960: LIST
29961: LIST
29962: PUSH
29963: LD_INT 1
29965: NEG
29966: PUSH
29967: LD_INT 2
29969: NEG
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 0
29977: PUSH
29978: LD_INT 2
29980: NEG
29981: PUSH
29982: EMPTY
29983: LIST
29984: LIST
29985: PUSH
29986: LD_INT 1
29988: PUSH
29989: LD_INT 1
29991: NEG
29992: PUSH
29993: EMPTY
29994: LIST
29995: LIST
29996: PUSH
29997: LD_INT 1
29999: PUSH
30000: LD_INT 2
30002: PUSH
30003: EMPTY
30004: LIST
30005: LIST
30006: PUSH
30007: LD_INT 0
30009: PUSH
30010: LD_INT 2
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 1
30019: NEG
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 1
30030: NEG
30031: PUSH
30032: LD_INT 3
30034: NEG
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 0
30042: PUSH
30043: LD_INT 3
30045: NEG
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: LD_INT 2
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30080: LD_ADDR_VAR 0 15
30084: PUSH
30085: LD_INT 0
30087: PUSH
30088: LD_INT 0
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 0
30097: PUSH
30098: LD_INT 1
30100: NEG
30101: PUSH
30102: EMPTY
30103: LIST
30104: LIST
30105: PUSH
30106: LD_INT 1
30108: PUSH
30109: LD_INT 0
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 1
30118: PUSH
30119: LD_INT 1
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: PUSH
30126: LD_INT 0
30128: PUSH
30129: LD_INT 1
30131: PUSH
30132: EMPTY
30133: LIST
30134: LIST
30135: PUSH
30136: LD_INT 1
30138: NEG
30139: PUSH
30140: LD_INT 0
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: LD_INT 1
30149: NEG
30150: PUSH
30151: LD_INT 1
30153: NEG
30154: PUSH
30155: EMPTY
30156: LIST
30157: LIST
30158: PUSH
30159: LD_INT 1
30161: PUSH
30162: LD_INT 1
30164: NEG
30165: PUSH
30166: EMPTY
30167: LIST
30168: LIST
30169: PUSH
30170: LD_INT 2
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: EMPTY
30177: LIST
30178: LIST
30179: PUSH
30180: LD_INT 2
30182: PUSH
30183: LD_INT 1
30185: PUSH
30186: EMPTY
30187: LIST
30188: LIST
30189: PUSH
30190: LD_INT 1
30192: NEG
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: EMPTY
30198: LIST
30199: LIST
30200: PUSH
30201: LD_INT 2
30203: NEG
30204: PUSH
30205: LD_INT 0
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: LD_INT 2
30214: NEG
30215: PUSH
30216: LD_INT 1
30218: NEG
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 2
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 3
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 3
30247: PUSH
30248: LD_INT 1
30250: PUSH
30251: EMPTY
30252: LIST
30253: LIST
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: LIST
30259: LIST
30260: LIST
30261: LIST
30262: LIST
30263: LIST
30264: LIST
30265: LIST
30266: LIST
30267: LIST
30268: LIST
30269: LIST
30270: LIST
30271: LIST
30272: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30273: LD_ADDR_VAR 0 16
30277: PUSH
30278: LD_INT 0
30280: PUSH
30281: LD_INT 0
30283: PUSH
30284: EMPTY
30285: LIST
30286: LIST
30287: PUSH
30288: LD_INT 0
30290: PUSH
30291: LD_INT 1
30293: NEG
30294: PUSH
30295: EMPTY
30296: LIST
30297: LIST
30298: PUSH
30299: LD_INT 1
30301: PUSH
30302: LD_INT 0
30304: PUSH
30305: EMPTY
30306: LIST
30307: LIST
30308: PUSH
30309: LD_INT 1
30311: PUSH
30312: LD_INT 1
30314: PUSH
30315: EMPTY
30316: LIST
30317: LIST
30318: PUSH
30319: LD_INT 0
30321: PUSH
30322: LD_INT 1
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 1
30331: NEG
30332: PUSH
30333: LD_INT 0
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 1
30342: NEG
30343: PUSH
30344: LD_INT 1
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 1
30354: NEG
30355: PUSH
30356: LD_INT 2
30358: NEG
30359: PUSH
30360: EMPTY
30361: LIST
30362: LIST
30363: PUSH
30364: LD_INT 2
30366: PUSH
30367: LD_INT 1
30369: PUSH
30370: EMPTY
30371: LIST
30372: LIST
30373: PUSH
30374: LD_INT 2
30376: PUSH
30377: LD_INT 2
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 1
30386: PUSH
30387: LD_INT 2
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 2
30396: NEG
30397: PUSH
30398: LD_INT 1
30400: NEG
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 2
30408: NEG
30409: PUSH
30410: LD_INT 2
30412: NEG
30413: PUSH
30414: EMPTY
30415: LIST
30416: LIST
30417: PUSH
30418: LD_INT 3
30420: PUSH
30421: LD_INT 2
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 3
30430: PUSH
30431: LD_INT 3
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: PUSH
30441: LD_INT 3
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: LIST
30452: LIST
30453: LIST
30454: LIST
30455: LIST
30456: LIST
30457: LIST
30458: LIST
30459: LIST
30460: LIST
30461: LIST
30462: LIST
30463: LIST
30464: LIST
30465: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30466: LD_ADDR_VAR 0 17
30470: PUSH
30471: LD_INT 0
30473: PUSH
30474: LD_INT 0
30476: PUSH
30477: EMPTY
30478: LIST
30479: LIST
30480: PUSH
30481: LD_INT 0
30483: PUSH
30484: LD_INT 1
30486: NEG
30487: PUSH
30488: EMPTY
30489: LIST
30490: LIST
30491: PUSH
30492: LD_INT 1
30494: PUSH
30495: LD_INT 0
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 1
30504: PUSH
30505: LD_INT 1
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 0
30514: PUSH
30515: LD_INT 1
30517: PUSH
30518: EMPTY
30519: LIST
30520: LIST
30521: PUSH
30522: LD_INT 1
30524: NEG
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 1
30535: NEG
30536: PUSH
30537: LD_INT 1
30539: NEG
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: LD_INT 1
30547: NEG
30548: PUSH
30549: LD_INT 2
30551: NEG
30552: PUSH
30553: EMPTY
30554: LIST
30555: LIST
30556: PUSH
30557: LD_INT 0
30559: PUSH
30560: LD_INT 2
30562: NEG
30563: PUSH
30564: EMPTY
30565: LIST
30566: LIST
30567: PUSH
30568: LD_INT 1
30570: PUSH
30571: LD_INT 1
30573: NEG
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 2
30581: PUSH
30582: LD_INT 0
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 2
30591: PUSH
30592: LD_INT 1
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 2
30601: PUSH
30602: LD_INT 2
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 1
30611: PUSH
30612: LD_INT 2
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 0
30621: PUSH
30622: LD_INT 2
30624: PUSH
30625: EMPTY
30626: LIST
30627: LIST
30628: PUSH
30629: LD_INT 1
30631: NEG
30632: PUSH
30633: LD_INT 1
30635: PUSH
30636: EMPTY
30637: LIST
30638: LIST
30639: PUSH
30640: LD_INT 2
30642: NEG
30643: PUSH
30644: LD_INT 0
30646: PUSH
30647: EMPTY
30648: LIST
30649: LIST
30650: PUSH
30651: LD_INT 2
30653: NEG
30654: PUSH
30655: LD_INT 1
30657: NEG
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 2
30665: NEG
30666: PUSH
30667: LD_INT 2
30669: NEG
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: LIST
30679: LIST
30680: LIST
30681: LIST
30682: LIST
30683: LIST
30684: LIST
30685: LIST
30686: LIST
30687: LIST
30688: LIST
30689: LIST
30690: LIST
30691: LIST
30692: LIST
30693: LIST
30694: LIST
30695: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30696: LD_ADDR_VAR 0 18
30700: PUSH
30701: LD_INT 0
30703: PUSH
30704: LD_INT 0
30706: PUSH
30707: EMPTY
30708: LIST
30709: LIST
30710: PUSH
30711: LD_INT 0
30713: PUSH
30714: LD_INT 1
30716: NEG
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: PUSH
30722: LD_INT 1
30724: PUSH
30725: LD_INT 0
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: PUSH
30735: LD_INT 1
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 0
30744: PUSH
30745: LD_INT 1
30747: PUSH
30748: EMPTY
30749: LIST
30750: LIST
30751: PUSH
30752: LD_INT 1
30754: NEG
30755: PUSH
30756: LD_INT 0
30758: PUSH
30759: EMPTY
30760: LIST
30761: LIST
30762: PUSH
30763: LD_INT 1
30765: NEG
30766: PUSH
30767: LD_INT 1
30769: NEG
30770: PUSH
30771: EMPTY
30772: LIST
30773: LIST
30774: PUSH
30775: LD_INT 1
30777: NEG
30778: PUSH
30779: LD_INT 2
30781: NEG
30782: PUSH
30783: EMPTY
30784: LIST
30785: LIST
30786: PUSH
30787: LD_INT 0
30789: PUSH
30790: LD_INT 2
30792: NEG
30793: PUSH
30794: EMPTY
30795: LIST
30796: LIST
30797: PUSH
30798: LD_INT 1
30800: PUSH
30801: LD_INT 1
30803: NEG
30804: PUSH
30805: EMPTY
30806: LIST
30807: LIST
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: LD_INT 0
30814: PUSH
30815: EMPTY
30816: LIST
30817: LIST
30818: PUSH
30819: LD_INT 2
30821: PUSH
30822: LD_INT 1
30824: PUSH
30825: EMPTY
30826: LIST
30827: LIST
30828: PUSH
30829: LD_INT 2
30831: PUSH
30832: LD_INT 2
30834: PUSH
30835: EMPTY
30836: LIST
30837: LIST
30838: PUSH
30839: LD_INT 1
30841: PUSH
30842: LD_INT 2
30844: PUSH
30845: EMPTY
30846: LIST
30847: LIST
30848: PUSH
30849: LD_INT 0
30851: PUSH
30852: LD_INT 2
30854: PUSH
30855: EMPTY
30856: LIST
30857: LIST
30858: PUSH
30859: LD_INT 1
30861: NEG
30862: PUSH
30863: LD_INT 1
30865: PUSH
30866: EMPTY
30867: LIST
30868: LIST
30869: PUSH
30870: LD_INT 2
30872: NEG
30873: PUSH
30874: LD_INT 0
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 2
30883: NEG
30884: PUSH
30885: LD_INT 1
30887: NEG
30888: PUSH
30889: EMPTY
30890: LIST
30891: LIST
30892: PUSH
30893: LD_INT 2
30895: NEG
30896: PUSH
30897: LD_INT 2
30899: NEG
30900: PUSH
30901: EMPTY
30902: LIST
30903: LIST
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30926: LD_ADDR_VAR 0 19
30930: PUSH
30931: LD_INT 0
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: EMPTY
30938: LIST
30939: LIST
30940: PUSH
30941: LD_INT 0
30943: PUSH
30944: LD_INT 1
30946: NEG
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: PUSH
30955: LD_INT 0
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 1
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 0
30974: PUSH
30975: LD_INT 1
30977: PUSH
30978: EMPTY
30979: LIST
30980: LIST
30981: PUSH
30982: LD_INT 1
30984: NEG
30985: PUSH
30986: LD_INT 0
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 1
30995: NEG
30996: PUSH
30997: LD_INT 1
30999: NEG
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: LD_INT 2
31011: NEG
31012: PUSH
31013: EMPTY
31014: LIST
31015: LIST
31016: PUSH
31017: LD_INT 0
31019: PUSH
31020: LD_INT 2
31022: NEG
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 1
31030: PUSH
31031: LD_INT 1
31033: NEG
31034: PUSH
31035: EMPTY
31036: LIST
31037: LIST
31038: PUSH
31039: LD_INT 2
31041: PUSH
31042: LD_INT 0
31044: PUSH
31045: EMPTY
31046: LIST
31047: LIST
31048: PUSH
31049: LD_INT 2
31051: PUSH
31052: LD_INT 1
31054: PUSH
31055: EMPTY
31056: LIST
31057: LIST
31058: PUSH
31059: LD_INT 2
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: EMPTY
31066: LIST
31067: LIST
31068: PUSH
31069: LD_INT 1
31071: PUSH
31072: LD_INT 2
31074: PUSH
31075: EMPTY
31076: LIST
31077: LIST
31078: PUSH
31079: LD_INT 0
31081: PUSH
31082: LD_INT 2
31084: PUSH
31085: EMPTY
31086: LIST
31087: LIST
31088: PUSH
31089: LD_INT 1
31091: NEG
31092: PUSH
31093: LD_INT 1
31095: PUSH
31096: EMPTY
31097: LIST
31098: LIST
31099: PUSH
31100: LD_INT 2
31102: NEG
31103: PUSH
31104: LD_INT 0
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 2
31113: NEG
31114: PUSH
31115: LD_INT 1
31117: NEG
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 2
31125: NEG
31126: PUSH
31127: LD_INT 2
31129: NEG
31130: PUSH
31131: EMPTY
31132: LIST
31133: LIST
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: LIST
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31156: LD_ADDR_VAR 0 20
31160: PUSH
31161: LD_INT 0
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: EMPTY
31168: LIST
31169: LIST
31170: PUSH
31171: LD_INT 0
31173: PUSH
31174: LD_INT 1
31176: NEG
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 1
31194: PUSH
31195: LD_INT 1
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 0
31204: PUSH
31205: LD_INT 1
31207: PUSH
31208: EMPTY
31209: LIST
31210: LIST
31211: PUSH
31212: LD_INT 1
31214: NEG
31215: PUSH
31216: LD_INT 0
31218: PUSH
31219: EMPTY
31220: LIST
31221: LIST
31222: PUSH
31223: LD_INT 1
31225: NEG
31226: PUSH
31227: LD_INT 1
31229: NEG
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: NEG
31238: PUSH
31239: LD_INT 2
31241: NEG
31242: PUSH
31243: EMPTY
31244: LIST
31245: LIST
31246: PUSH
31247: LD_INT 0
31249: PUSH
31250: LD_INT 2
31252: NEG
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: LD_INT 1
31260: PUSH
31261: LD_INT 1
31263: NEG
31264: PUSH
31265: EMPTY
31266: LIST
31267: LIST
31268: PUSH
31269: LD_INT 2
31271: PUSH
31272: LD_INT 0
31274: PUSH
31275: EMPTY
31276: LIST
31277: LIST
31278: PUSH
31279: LD_INT 2
31281: PUSH
31282: LD_INT 1
31284: PUSH
31285: EMPTY
31286: LIST
31287: LIST
31288: PUSH
31289: LD_INT 2
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: EMPTY
31296: LIST
31297: LIST
31298: PUSH
31299: LD_INT 1
31301: PUSH
31302: LD_INT 2
31304: PUSH
31305: EMPTY
31306: LIST
31307: LIST
31308: PUSH
31309: LD_INT 0
31311: PUSH
31312: LD_INT 2
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 1
31321: NEG
31322: PUSH
31323: LD_INT 1
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 2
31332: NEG
31333: PUSH
31334: LD_INT 0
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 2
31343: NEG
31344: PUSH
31345: LD_INT 1
31347: NEG
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 2
31355: NEG
31356: PUSH
31357: LD_INT 2
31359: NEG
31360: PUSH
31361: EMPTY
31362: LIST
31363: LIST
31364: PUSH
31365: EMPTY
31366: LIST
31367: LIST
31368: LIST
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31386: LD_ADDR_VAR 0 21
31390: PUSH
31391: LD_INT 0
31393: PUSH
31394: LD_INT 0
31396: PUSH
31397: EMPTY
31398: LIST
31399: LIST
31400: PUSH
31401: LD_INT 0
31403: PUSH
31404: LD_INT 1
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: PUSH
31415: LD_INT 0
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 1
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 0
31434: PUSH
31435: LD_INT 1
31437: PUSH
31438: EMPTY
31439: LIST
31440: LIST
31441: PUSH
31442: LD_INT 1
31444: NEG
31445: PUSH
31446: LD_INT 0
31448: PUSH
31449: EMPTY
31450: LIST
31451: LIST
31452: PUSH
31453: LD_INT 1
31455: NEG
31456: PUSH
31457: LD_INT 1
31459: NEG
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: LD_INT 2
31471: NEG
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: PUSH
31477: LD_INT 0
31479: PUSH
31480: LD_INT 2
31482: NEG
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 1
31490: PUSH
31491: LD_INT 1
31493: NEG
31494: PUSH
31495: EMPTY
31496: LIST
31497: LIST
31498: PUSH
31499: LD_INT 2
31501: PUSH
31502: LD_INT 0
31504: PUSH
31505: EMPTY
31506: LIST
31507: LIST
31508: PUSH
31509: LD_INT 2
31511: PUSH
31512: LD_INT 1
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 2
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: EMPTY
31526: LIST
31527: LIST
31528: PUSH
31529: LD_INT 1
31531: PUSH
31532: LD_INT 2
31534: PUSH
31535: EMPTY
31536: LIST
31537: LIST
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: LD_INT 2
31544: PUSH
31545: EMPTY
31546: LIST
31547: LIST
31548: PUSH
31549: LD_INT 1
31551: NEG
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 2
31562: NEG
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 2
31573: NEG
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 2
31585: NEG
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: EMPTY
31596: LIST
31597: LIST
31598: LIST
31599: LIST
31600: LIST
31601: LIST
31602: LIST
31603: LIST
31604: LIST
31605: LIST
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31616: LD_ADDR_VAR 0 22
31620: PUSH
31621: LD_INT 0
31623: PUSH
31624: LD_INT 0
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 0
31633: PUSH
31634: LD_INT 1
31636: NEG
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: PUSH
31645: LD_INT 0
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 1
31654: PUSH
31655: LD_INT 1
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 0
31664: PUSH
31665: LD_INT 1
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 1
31674: NEG
31675: PUSH
31676: LD_INT 0
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PUSH
31683: LD_INT 1
31685: NEG
31686: PUSH
31687: LD_INT 1
31689: NEG
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 0
31709: PUSH
31710: LD_INT 2
31712: NEG
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: PUSH
31721: LD_INT 1
31723: NEG
31724: PUSH
31725: EMPTY
31726: LIST
31727: LIST
31728: PUSH
31729: LD_INT 2
31731: PUSH
31732: LD_INT 0
31734: PUSH
31735: EMPTY
31736: LIST
31737: LIST
31738: PUSH
31739: LD_INT 2
31741: PUSH
31742: LD_INT 1
31744: PUSH
31745: EMPTY
31746: LIST
31747: LIST
31748: PUSH
31749: LD_INT 2
31751: PUSH
31752: LD_INT 2
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: LD_INT 1
31761: PUSH
31762: LD_INT 2
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: PUSH
31769: LD_INT 0
31771: PUSH
31772: LD_INT 2
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 1
31781: NEG
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: NEG
31793: PUSH
31794: LD_INT 0
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 2
31803: NEG
31804: PUSH
31805: LD_INT 1
31807: NEG
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 2
31815: NEG
31816: PUSH
31817: LD_INT 2
31819: NEG
31820: PUSH
31821: EMPTY
31822: LIST
31823: LIST
31824: PUSH
31825: EMPTY
31826: LIST
31827: LIST
31828: LIST
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
31846: LD_ADDR_VAR 0 23
31850: PUSH
31851: LD_INT 0
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 0
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 1
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 0
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: NEG
31905: PUSH
31906: LD_INT 0
31908: PUSH
31909: EMPTY
31910: LIST
31911: LIST
31912: PUSH
31913: LD_INT 1
31915: NEG
31916: PUSH
31917: LD_INT 1
31919: NEG
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: LD_INT 2
31931: NEG
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: LD_INT 2
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 1
31950: PUSH
31951: LD_INT 1
31953: NEG
31954: PUSH
31955: EMPTY
31956: LIST
31957: LIST
31958: PUSH
31959: LD_INT 2
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 2
31971: PUSH
31972: LD_INT 1
31974: PUSH
31975: EMPTY
31976: LIST
31977: LIST
31978: PUSH
31979: LD_INT 2
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: EMPTY
31986: LIST
31987: LIST
31988: PUSH
31989: LD_INT 1
31991: PUSH
31992: LD_INT 2
31994: PUSH
31995: EMPTY
31996: LIST
31997: LIST
31998: PUSH
31999: LD_INT 0
32001: PUSH
32002: LD_INT 2
32004: PUSH
32005: EMPTY
32006: LIST
32007: LIST
32008: PUSH
32009: LD_INT 1
32011: NEG
32012: PUSH
32013: LD_INT 1
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: PUSH
32020: LD_INT 2
32022: NEG
32023: PUSH
32024: LD_INT 0
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 2
32033: NEG
32034: PUSH
32035: LD_INT 1
32037: NEG
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 2
32045: NEG
32046: PUSH
32047: LD_INT 2
32049: NEG
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 2
32057: NEG
32058: PUSH
32059: LD_INT 3
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: NEG
32070: PUSH
32071: LD_INT 3
32073: NEG
32074: PUSH
32075: EMPTY
32076: LIST
32077: LIST
32078: PUSH
32079: LD_INT 1
32081: PUSH
32082: LD_INT 2
32084: NEG
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 2
32092: PUSH
32093: LD_INT 1
32095: NEG
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: LIST
32105: LIST
32106: LIST
32107: LIST
32108: LIST
32109: LIST
32110: LIST
32111: LIST
32112: LIST
32113: LIST
32114: LIST
32115: LIST
32116: LIST
32117: LIST
32118: LIST
32119: LIST
32120: LIST
32121: LIST
32122: LIST
32123: LIST
32124: LIST
32125: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32126: LD_ADDR_VAR 0 24
32130: PUSH
32131: LD_INT 0
32133: PUSH
32134: LD_INT 0
32136: PUSH
32137: EMPTY
32138: LIST
32139: LIST
32140: PUSH
32141: LD_INT 0
32143: PUSH
32144: LD_INT 1
32146: NEG
32147: PUSH
32148: EMPTY
32149: LIST
32150: LIST
32151: PUSH
32152: LD_INT 1
32154: PUSH
32155: LD_INT 0
32157: PUSH
32158: EMPTY
32159: LIST
32160: LIST
32161: PUSH
32162: LD_INT 1
32164: PUSH
32165: LD_INT 1
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: PUSH
32172: LD_INT 0
32174: PUSH
32175: LD_INT 1
32177: PUSH
32178: EMPTY
32179: LIST
32180: LIST
32181: PUSH
32182: LD_INT 1
32184: NEG
32185: PUSH
32186: LD_INT 0
32188: PUSH
32189: EMPTY
32190: LIST
32191: LIST
32192: PUSH
32193: LD_INT 1
32195: NEG
32196: PUSH
32197: LD_INT 1
32199: NEG
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 1
32207: NEG
32208: PUSH
32209: LD_INT 2
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 0
32219: PUSH
32220: LD_INT 2
32222: NEG
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 1
32230: PUSH
32231: LD_INT 1
32233: NEG
32234: PUSH
32235: EMPTY
32236: LIST
32237: LIST
32238: PUSH
32239: LD_INT 2
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 2
32251: PUSH
32252: LD_INT 1
32254: PUSH
32255: EMPTY
32256: LIST
32257: LIST
32258: PUSH
32259: LD_INT 2
32261: PUSH
32262: LD_INT 2
32264: PUSH
32265: EMPTY
32266: LIST
32267: LIST
32268: PUSH
32269: LD_INT 1
32271: PUSH
32272: LD_INT 2
32274: PUSH
32275: EMPTY
32276: LIST
32277: LIST
32278: PUSH
32279: LD_INT 0
32281: PUSH
32282: LD_INT 2
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 1
32291: NEG
32292: PUSH
32293: LD_INT 1
32295: PUSH
32296: EMPTY
32297: LIST
32298: LIST
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: LD_INT 0
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 2
32313: NEG
32314: PUSH
32315: LD_INT 1
32317: NEG
32318: PUSH
32319: EMPTY
32320: LIST
32321: LIST
32322: PUSH
32323: LD_INT 2
32325: NEG
32326: PUSH
32327: LD_INT 2
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 1
32337: PUSH
32338: LD_INT 2
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 2
32348: PUSH
32349: LD_INT 1
32351: NEG
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 3
32359: PUSH
32360: LD_INT 1
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 3
32369: PUSH
32370: LD_INT 2
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32402: LD_ADDR_VAR 0 25
32406: PUSH
32407: LD_INT 0
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: EMPTY
32414: LIST
32415: LIST
32416: PUSH
32417: LD_INT 0
32419: PUSH
32420: LD_INT 1
32422: NEG
32423: PUSH
32424: EMPTY
32425: LIST
32426: LIST
32427: PUSH
32428: LD_INT 1
32430: PUSH
32431: LD_INT 0
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: LD_INT 1
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: LD_INT 1
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 1
32460: NEG
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 1
32471: NEG
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: EMPTY
32478: LIST
32479: LIST
32480: PUSH
32481: LD_INT 1
32483: NEG
32484: PUSH
32485: LD_INT 2
32487: NEG
32488: PUSH
32489: EMPTY
32490: LIST
32491: LIST
32492: PUSH
32493: LD_INT 0
32495: PUSH
32496: LD_INT 2
32498: NEG
32499: PUSH
32500: EMPTY
32501: LIST
32502: LIST
32503: PUSH
32504: LD_INT 1
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 2
32517: PUSH
32518: LD_INT 0
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 2
32527: PUSH
32528: LD_INT 1
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: PUSH
32538: LD_INT 2
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: LD_INT 2
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 0
32557: PUSH
32558: LD_INT 2
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 2
32578: NEG
32579: PUSH
32580: LD_INT 0
32582: PUSH
32583: EMPTY
32584: LIST
32585: LIST
32586: PUSH
32587: LD_INT 2
32589: NEG
32590: PUSH
32591: LD_INT 1
32593: NEG
32594: PUSH
32595: EMPTY
32596: LIST
32597: LIST
32598: PUSH
32599: LD_INT 2
32601: NEG
32602: PUSH
32603: LD_INT 2
32605: NEG
32606: PUSH
32607: EMPTY
32608: LIST
32609: LIST
32610: PUSH
32611: LD_INT 3
32613: PUSH
32614: LD_INT 1
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 3
32623: PUSH
32624: LD_INT 2
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 2
32633: PUSH
32634: LD_INT 3
32636: PUSH
32637: EMPTY
32638: LIST
32639: LIST
32640: PUSH
32641: LD_INT 1
32643: PUSH
32644: LD_INT 3
32646: PUSH
32647: EMPTY
32648: LIST
32649: LIST
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: LIST
32655: LIST
32656: LIST
32657: LIST
32658: LIST
32659: LIST
32660: LIST
32661: LIST
32662: LIST
32663: LIST
32664: LIST
32665: LIST
32666: LIST
32667: LIST
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
32676: LD_ADDR_VAR 0 26
32680: PUSH
32681: LD_INT 0
32683: PUSH
32684: LD_INT 0
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 0
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 1
32714: PUSH
32715: LD_INT 1
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 0
32724: PUSH
32725: LD_INT 1
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: NEG
32735: PUSH
32736: LD_INT 0
32738: PUSH
32739: EMPTY
32740: LIST
32741: LIST
32742: PUSH
32743: LD_INT 1
32745: NEG
32746: PUSH
32747: LD_INT 1
32749: NEG
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: NEG
32758: PUSH
32759: LD_INT 2
32761: NEG
32762: PUSH
32763: EMPTY
32764: LIST
32765: LIST
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: LD_INT 2
32772: NEG
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: PUSH
32781: LD_INT 1
32783: NEG
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 2
32791: PUSH
32792: LD_INT 0
32794: PUSH
32795: EMPTY
32796: LIST
32797: LIST
32798: PUSH
32799: LD_INT 2
32801: PUSH
32802: LD_INT 1
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 2
32814: PUSH
32815: EMPTY
32816: LIST
32817: LIST
32818: PUSH
32819: LD_INT 1
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 0
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 1
32841: NEG
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 2
32852: NEG
32853: PUSH
32854: LD_INT 0
32856: PUSH
32857: EMPTY
32858: LIST
32859: LIST
32860: PUSH
32861: LD_INT 2
32863: NEG
32864: PUSH
32865: LD_INT 1
32867: NEG
32868: PUSH
32869: EMPTY
32870: LIST
32871: LIST
32872: PUSH
32873: LD_INT 2
32875: NEG
32876: PUSH
32877: LD_INT 2
32879: NEG
32880: PUSH
32881: EMPTY
32882: LIST
32883: LIST
32884: PUSH
32885: LD_INT 2
32887: PUSH
32888: LD_INT 3
32890: PUSH
32891: EMPTY
32892: LIST
32893: LIST
32894: PUSH
32895: LD_INT 1
32897: PUSH
32898: LD_INT 3
32900: PUSH
32901: EMPTY
32902: LIST
32903: LIST
32904: PUSH
32905: LD_INT 1
32907: NEG
32908: PUSH
32909: LD_INT 2
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 2
32918: NEG
32919: PUSH
32920: LD_INT 1
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: LIST
32931: LIST
32932: LIST
32933: LIST
32934: LIST
32935: LIST
32936: LIST
32937: LIST
32938: LIST
32939: LIST
32940: LIST
32941: LIST
32942: LIST
32943: LIST
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32952: LD_ADDR_VAR 0 27
32956: PUSH
32957: LD_INT 0
32959: PUSH
32960: LD_INT 0
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 1
32990: PUSH
32991: LD_INT 1
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: LD_INT 1
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: NEG
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 1
33021: NEG
33022: PUSH
33023: LD_INT 1
33025: NEG
33026: PUSH
33027: EMPTY
33028: LIST
33029: LIST
33030: PUSH
33031: LD_INT 1
33033: NEG
33034: PUSH
33035: LD_INT 2
33037: NEG
33038: PUSH
33039: EMPTY
33040: LIST
33041: LIST
33042: PUSH
33043: LD_INT 0
33045: PUSH
33046: LD_INT 2
33048: NEG
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 1
33056: PUSH
33057: LD_INT 1
33059: NEG
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: PUSH
33068: LD_INT 0
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 2
33077: PUSH
33078: LD_INT 1
33080: PUSH
33081: EMPTY
33082: LIST
33083: LIST
33084: PUSH
33085: LD_INT 2
33087: PUSH
33088: LD_INT 2
33090: PUSH
33091: EMPTY
33092: LIST
33093: LIST
33094: PUSH
33095: LD_INT 1
33097: PUSH
33098: LD_INT 2
33100: PUSH
33101: EMPTY
33102: LIST
33103: LIST
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: LD_INT 2
33110: PUSH
33111: EMPTY
33112: LIST
33113: LIST
33114: PUSH
33115: LD_INT 1
33117: NEG
33118: PUSH
33119: LD_INT 1
33121: PUSH
33122: EMPTY
33123: LIST
33124: LIST
33125: PUSH
33126: LD_INT 2
33128: NEG
33129: PUSH
33130: LD_INT 0
33132: PUSH
33133: EMPTY
33134: LIST
33135: LIST
33136: PUSH
33137: LD_INT 2
33139: NEG
33140: PUSH
33141: LD_INT 1
33143: NEG
33144: PUSH
33145: EMPTY
33146: LIST
33147: LIST
33148: PUSH
33149: LD_INT 2
33151: NEG
33152: PUSH
33153: LD_INT 2
33155: NEG
33156: PUSH
33157: EMPTY
33158: LIST
33159: LIST
33160: PUSH
33161: LD_INT 1
33163: NEG
33164: PUSH
33165: LD_INT 2
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 2
33174: NEG
33175: PUSH
33176: LD_INT 1
33178: PUSH
33179: EMPTY
33180: LIST
33181: LIST
33182: PUSH
33183: LD_INT 3
33185: NEG
33186: PUSH
33187: LD_INT 1
33189: NEG
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 3
33197: NEG
33198: PUSH
33199: LD_INT 2
33201: NEG
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: EMPTY
33208: LIST
33209: LIST
33210: LIST
33211: LIST
33212: LIST
33213: LIST
33214: LIST
33215: LIST
33216: LIST
33217: LIST
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33232: LD_ADDR_VAR 0 28
33236: PUSH
33237: LD_INT 0
33239: PUSH
33240: LD_INT 0
33242: PUSH
33243: EMPTY
33244: LIST
33245: LIST
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 1
33260: PUSH
33261: LD_INT 0
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: LD_INT 1
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 0
33280: PUSH
33281: LD_INT 1
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 1
33290: NEG
33291: PUSH
33292: LD_INT 0
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 1
33301: NEG
33302: PUSH
33303: LD_INT 1
33305: NEG
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 1
33313: NEG
33314: PUSH
33315: LD_INT 2
33317: NEG
33318: PUSH
33319: EMPTY
33320: LIST
33321: LIST
33322: PUSH
33323: LD_INT 0
33325: PUSH
33326: LD_INT 2
33328: NEG
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: LD_INT 1
33339: NEG
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 2
33347: PUSH
33348: LD_INT 0
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 2
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: PUSH
33368: LD_INT 2
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 0
33387: PUSH
33388: LD_INT 2
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 1
33397: NEG
33398: PUSH
33399: LD_INT 1
33401: PUSH
33402: EMPTY
33403: LIST
33404: LIST
33405: PUSH
33406: LD_INT 2
33408: NEG
33409: PUSH
33410: LD_INT 0
33412: PUSH
33413: EMPTY
33414: LIST
33415: LIST
33416: PUSH
33417: LD_INT 2
33419: NEG
33420: PUSH
33421: LD_INT 1
33423: NEG
33424: PUSH
33425: EMPTY
33426: LIST
33427: LIST
33428: PUSH
33429: LD_INT 2
33431: NEG
33432: PUSH
33433: LD_INT 2
33435: NEG
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 2
33443: NEG
33444: PUSH
33445: LD_INT 3
33447: NEG
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 1
33455: NEG
33456: PUSH
33457: LD_INT 3
33459: NEG
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 3
33467: NEG
33468: PUSH
33469: LD_INT 1
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 3
33479: NEG
33480: PUSH
33481: LD_INT 2
33483: NEG
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: LIST
33493: LIST
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33514: LD_ADDR_VAR 0 29
33518: PUSH
33519: LD_INT 0
33521: PUSH
33522: LD_INT 0
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 0
33531: PUSH
33532: LD_INT 1
33534: NEG
33535: PUSH
33536: EMPTY
33537: LIST
33538: LIST
33539: PUSH
33540: LD_INT 1
33542: PUSH
33543: LD_INT 0
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: LD_INT 1
33552: PUSH
33553: LD_INT 1
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 0
33562: PUSH
33563: LD_INT 1
33565: PUSH
33566: EMPTY
33567: LIST
33568: LIST
33569: PUSH
33570: LD_INT 1
33572: NEG
33573: PUSH
33574: LD_INT 0
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 1
33583: NEG
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: PUSH
33589: EMPTY
33590: LIST
33591: LIST
33592: PUSH
33593: LD_INT 1
33595: NEG
33596: PUSH
33597: LD_INT 2
33599: NEG
33600: PUSH
33601: EMPTY
33602: LIST
33603: LIST
33604: PUSH
33605: LD_INT 0
33607: PUSH
33608: LD_INT 2
33610: NEG
33611: PUSH
33612: EMPTY
33613: LIST
33614: LIST
33615: PUSH
33616: LD_INT 1
33618: PUSH
33619: LD_INT 1
33621: NEG
33622: PUSH
33623: EMPTY
33624: LIST
33625: LIST
33626: PUSH
33627: LD_INT 2
33629: PUSH
33630: LD_INT 0
33632: PUSH
33633: EMPTY
33634: LIST
33635: LIST
33636: PUSH
33637: LD_INT 2
33639: PUSH
33640: LD_INT 1
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 2
33652: PUSH
33653: EMPTY
33654: LIST
33655: LIST
33656: PUSH
33657: LD_INT 0
33659: PUSH
33660: LD_INT 2
33662: PUSH
33663: EMPTY
33664: LIST
33665: LIST
33666: PUSH
33667: LD_INT 1
33669: NEG
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 2
33680: NEG
33681: PUSH
33682: LD_INT 1
33684: NEG
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 2
33692: NEG
33693: PUSH
33694: LD_INT 2
33696: NEG
33697: PUSH
33698: EMPTY
33699: LIST
33700: LIST
33701: PUSH
33702: LD_INT 2
33704: NEG
33705: PUSH
33706: LD_INT 3
33708: NEG
33709: PUSH
33710: EMPTY
33711: LIST
33712: LIST
33713: PUSH
33714: LD_INT 2
33716: PUSH
33717: LD_INT 1
33719: NEG
33720: PUSH
33721: EMPTY
33722: LIST
33723: LIST
33724: PUSH
33725: LD_INT 3
33727: PUSH
33728: LD_INT 1
33730: PUSH
33731: EMPTY
33732: LIST
33733: LIST
33734: PUSH
33735: LD_INT 1
33737: PUSH
33738: LD_INT 3
33740: PUSH
33741: EMPTY
33742: LIST
33743: LIST
33744: PUSH
33745: LD_INT 1
33747: NEG
33748: PUSH
33749: LD_INT 2
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 3
33758: NEG
33759: PUSH
33760: LD_INT 2
33762: NEG
33763: PUSH
33764: EMPTY
33765: LIST
33766: LIST
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: LIST
33772: LIST
33773: LIST
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33793: LD_ADDR_VAR 0 30
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: LD_INT 0
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 0
33810: PUSH
33811: LD_INT 1
33813: NEG
33814: PUSH
33815: EMPTY
33816: LIST
33817: LIST
33818: PUSH
33819: LD_INT 1
33821: PUSH
33822: LD_INT 0
33824: PUSH
33825: EMPTY
33826: LIST
33827: LIST
33828: PUSH
33829: LD_INT 1
33831: PUSH
33832: LD_INT 1
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: LD_INT 0
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 1
33851: NEG
33852: PUSH
33853: LD_INT 0
33855: PUSH
33856: EMPTY
33857: LIST
33858: LIST
33859: PUSH
33860: LD_INT 1
33862: NEG
33863: PUSH
33864: LD_INT 1
33866: NEG
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 1
33874: NEG
33875: PUSH
33876: LD_INT 2
33878: NEG
33879: PUSH
33880: EMPTY
33881: LIST
33882: LIST
33883: PUSH
33884: LD_INT 0
33886: PUSH
33887: LD_INT 2
33889: NEG
33890: PUSH
33891: EMPTY
33892: LIST
33893: LIST
33894: PUSH
33895: LD_INT 1
33897: PUSH
33898: LD_INT 1
33900: NEG
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 2
33908: PUSH
33909: LD_INT 0
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 2
33918: PUSH
33919: LD_INT 1
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 2
33928: PUSH
33929: LD_INT 2
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: PUSH
33939: LD_INT 2
33941: PUSH
33942: EMPTY
33943: LIST
33944: LIST
33945: PUSH
33946: LD_INT 1
33948: NEG
33949: PUSH
33950: LD_INT 1
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 2
33959: NEG
33960: PUSH
33961: LD_INT 0
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 2
33970: NEG
33971: PUSH
33972: LD_INT 1
33974: NEG
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: LD_INT 3
33986: NEG
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: LD_INT 2
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 3
34005: PUSH
34006: LD_INT 2
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 2
34015: PUSH
34016: LD_INT 3
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 2
34025: NEG
34026: PUSH
34027: LD_INT 1
34029: PUSH
34030: EMPTY
34031: LIST
34032: LIST
34033: PUSH
34034: LD_INT 3
34036: NEG
34037: PUSH
34038: LD_INT 1
34040: NEG
34041: PUSH
34042: EMPTY
34043: LIST
34044: LIST
34045: PUSH
34046: EMPTY
34047: LIST
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: LIST
34053: LIST
34054: LIST
34055: LIST
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34071: LD_ADDR_VAR 0 31
34075: PUSH
34076: LD_INT 0
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 0
34088: PUSH
34089: LD_INT 1
34091: NEG
34092: PUSH
34093: EMPTY
34094: LIST
34095: LIST
34096: PUSH
34097: LD_INT 1
34099: PUSH
34100: LD_INT 0
34102: PUSH
34103: EMPTY
34104: LIST
34105: LIST
34106: PUSH
34107: LD_INT 1
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: EMPTY
34114: LIST
34115: LIST
34116: PUSH
34117: LD_INT 0
34119: PUSH
34120: LD_INT 1
34122: PUSH
34123: EMPTY
34124: LIST
34125: LIST
34126: PUSH
34127: LD_INT 1
34129: NEG
34130: PUSH
34131: LD_INT 0
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 1
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: LD_INT 2
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 1
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: EMPTY
34180: LIST
34181: LIST
34182: PUSH
34183: LD_INT 2
34185: PUSH
34186: LD_INT 1
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 2
34195: PUSH
34196: LD_INT 2
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: PUSH
34206: LD_INT 2
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 0
34215: PUSH
34216: LD_INT 2
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 1
34225: NEG
34226: PUSH
34227: LD_INT 1
34229: PUSH
34230: EMPTY
34231: LIST
34232: LIST
34233: PUSH
34234: LD_INT 2
34236: NEG
34237: PUSH
34238: LD_INT 1
34240: NEG
34241: PUSH
34242: EMPTY
34243: LIST
34244: LIST
34245: PUSH
34246: LD_INT 2
34248: NEG
34249: PUSH
34250: LD_INT 2
34252: NEG
34253: PUSH
34254: EMPTY
34255: LIST
34256: LIST
34257: PUSH
34258: LD_INT 2
34260: NEG
34261: PUSH
34262: LD_INT 3
34264: NEG
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: PUSH
34273: LD_INT 1
34275: NEG
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 3
34283: PUSH
34284: LD_INT 1
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 1
34293: PUSH
34294: LD_INT 3
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: NEG
34304: PUSH
34305: LD_INT 2
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 3
34314: NEG
34315: PUSH
34316: LD_INT 2
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: LIST
34328: LIST
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34349: LD_ADDR_VAR 0 32
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 0
34359: PUSH
34360: EMPTY
34361: LIST
34362: LIST
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: LD_INT 1
34369: NEG
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: LD_INT 0
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 0
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 0
34411: PUSH
34412: EMPTY
34413: LIST
34414: LIST
34415: PUSH
34416: LD_INT 1
34418: NEG
34419: PUSH
34420: LD_INT 1
34422: NEG
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: LD_INT 2
34434: NEG
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 0
34442: PUSH
34443: LD_INT 2
34445: NEG
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 1
34453: PUSH
34454: LD_INT 1
34456: NEG
34457: PUSH
34458: EMPTY
34459: LIST
34460: LIST
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: LD_INT 1
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 2
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 1
34484: PUSH
34485: LD_INT 2
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 0
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: NEG
34505: PUSH
34506: LD_INT 1
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: PUSH
34513: LD_INT 2
34515: NEG
34516: PUSH
34517: LD_INT 0
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 2
34526: NEG
34527: PUSH
34528: LD_INT 1
34530: NEG
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 1
34538: NEG
34539: PUSH
34540: LD_INT 3
34542: NEG
34543: PUSH
34544: EMPTY
34545: LIST
34546: LIST
34547: PUSH
34548: LD_INT 1
34550: PUSH
34551: LD_INT 2
34553: NEG
34554: PUSH
34555: EMPTY
34556: LIST
34557: LIST
34558: PUSH
34559: LD_INT 3
34561: PUSH
34562: LD_INT 2
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 2
34571: PUSH
34572: LD_INT 3
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 2
34581: NEG
34582: PUSH
34583: LD_INT 1
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 3
34592: NEG
34593: PUSH
34594: LD_INT 1
34596: NEG
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: LIST
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: LIST
34611: LIST
34612: LIST
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34627: LD_ADDR_VAR 0 33
34631: PUSH
34632: LD_INT 0
34634: PUSH
34635: LD_INT 0
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 1
34647: NEG
34648: PUSH
34649: EMPTY
34650: LIST
34651: LIST
34652: PUSH
34653: LD_INT 1
34655: PUSH
34656: LD_INT 0
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 0
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 1
34685: NEG
34686: PUSH
34687: LD_INT 0
34689: PUSH
34690: EMPTY
34691: LIST
34692: LIST
34693: PUSH
34694: LD_INT 1
34696: NEG
34697: PUSH
34698: LD_INT 1
34700: NEG
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: LD_INT 2
34712: NEG
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: LD_INT 1
34723: NEG
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 2
34731: PUSH
34732: LD_INT 0
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: LD_INT 1
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 1
34751: PUSH
34752: LD_INT 2
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 0
34761: PUSH
34762: LD_INT 2
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 1
34771: NEG
34772: PUSH
34773: LD_INT 1
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: PUSH
34780: LD_INT 2
34782: NEG
34783: PUSH
34784: LD_INT 0
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 2
34793: NEG
34794: PUSH
34795: LD_INT 1
34797: NEG
34798: PUSH
34799: EMPTY
34800: LIST
34801: LIST
34802: PUSH
34803: LD_INT 2
34805: NEG
34806: PUSH
34807: LD_INT 2
34809: NEG
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 2
34817: NEG
34818: PUSH
34819: LD_INT 3
34821: NEG
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 2
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 3
34840: PUSH
34841: LD_INT 1
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: LD_INT 3
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: LD_INT 2
34864: PUSH
34865: EMPTY
34866: LIST
34867: LIST
34868: PUSH
34869: LD_INT 3
34871: NEG
34872: PUSH
34873: LD_INT 2
34875: NEG
34876: PUSH
34877: EMPTY
34878: LIST
34879: LIST
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: LIST
34885: LIST
34886: LIST
34887: LIST
34888: LIST
34889: LIST
34890: LIST
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34906: LD_ADDR_VAR 0 34
34910: PUSH
34911: LD_INT 0
34913: PUSH
34914: LD_INT 0
34916: PUSH
34917: EMPTY
34918: LIST
34919: LIST
34920: PUSH
34921: LD_INT 0
34923: PUSH
34924: LD_INT 1
34926: NEG
34927: PUSH
34928: EMPTY
34929: LIST
34930: LIST
34931: PUSH
34932: LD_INT 1
34934: PUSH
34935: LD_INT 0
34937: PUSH
34938: EMPTY
34939: LIST
34940: LIST
34941: PUSH
34942: LD_INT 1
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: EMPTY
34949: LIST
34950: LIST
34951: PUSH
34952: LD_INT 0
34954: PUSH
34955: LD_INT 1
34957: PUSH
34958: EMPTY
34959: LIST
34960: LIST
34961: PUSH
34962: LD_INT 1
34964: NEG
34965: PUSH
34966: LD_INT 0
34968: PUSH
34969: EMPTY
34970: LIST
34971: LIST
34972: PUSH
34973: LD_INT 1
34975: NEG
34976: PUSH
34977: LD_INT 1
34979: NEG
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 2
34991: NEG
34992: PUSH
34993: EMPTY
34994: LIST
34995: LIST
34996: PUSH
34997: LD_INT 0
34999: PUSH
35000: LD_INT 2
35002: NEG
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: PUSH
35008: LD_INT 1
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 2
35021: PUSH
35022: LD_INT 1
35024: PUSH
35025: EMPTY
35026: LIST
35027: LIST
35028: PUSH
35029: LD_INT 2
35031: PUSH
35032: LD_INT 2
35034: PUSH
35035: EMPTY
35036: LIST
35037: LIST
35038: PUSH
35039: LD_INT 1
35041: PUSH
35042: LD_INT 2
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 1
35051: NEG
35052: PUSH
35053: LD_INT 1
35055: PUSH
35056: EMPTY
35057: LIST
35058: LIST
35059: PUSH
35060: LD_INT 2
35062: NEG
35063: PUSH
35064: LD_INT 0
35066: PUSH
35067: EMPTY
35068: LIST
35069: LIST
35070: PUSH
35071: LD_INT 2
35073: NEG
35074: PUSH
35075: LD_INT 1
35077: NEG
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: PUSH
35083: LD_INT 2
35085: NEG
35086: PUSH
35087: LD_INT 2
35089: NEG
35090: PUSH
35091: EMPTY
35092: LIST
35093: LIST
35094: PUSH
35095: LD_INT 1
35097: NEG
35098: PUSH
35099: LD_INT 3
35101: NEG
35102: PUSH
35103: EMPTY
35104: LIST
35105: LIST
35106: PUSH
35107: LD_INT 1
35109: PUSH
35110: LD_INT 2
35112: NEG
35113: PUSH
35114: EMPTY
35115: LIST
35116: LIST
35117: PUSH
35118: LD_INT 3
35120: PUSH
35121: LD_INT 2
35123: PUSH
35124: EMPTY
35125: LIST
35126: LIST
35127: PUSH
35128: LD_INT 2
35130: PUSH
35131: LD_INT 3
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 2
35140: NEG
35141: PUSH
35142: LD_INT 1
35144: PUSH
35145: EMPTY
35146: LIST
35147: LIST
35148: PUSH
35149: LD_INT 3
35151: NEG
35152: PUSH
35153: LD_INT 1
35155: NEG
35156: PUSH
35157: EMPTY
35158: LIST
35159: LIST
35160: PUSH
35161: EMPTY
35162: LIST
35163: LIST
35164: LIST
35165: LIST
35166: LIST
35167: LIST
35168: LIST
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: LIST
35175: LIST
35176: LIST
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35186: LD_ADDR_VAR 0 35
35190: PUSH
35191: LD_INT 0
35193: PUSH
35194: LD_INT 0
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 1
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: LD_INT 0
35234: PUSH
35235: LD_INT 1
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: LD_INT 0
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 1
35255: NEG
35256: PUSH
35257: LD_INT 1
35259: NEG
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 2
35267: PUSH
35268: LD_INT 1
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 2
35277: NEG
35278: PUSH
35279: LD_INT 1
35281: NEG
35282: PUSH
35283: EMPTY
35284: LIST
35285: LIST
35286: PUSH
35287: EMPTY
35288: LIST
35289: LIST
35290: LIST
35291: LIST
35292: LIST
35293: LIST
35294: LIST
35295: LIST
35296: LIST
35297: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35298: LD_ADDR_VAR 0 36
35302: PUSH
35303: LD_INT 0
35305: PUSH
35306: LD_INT 0
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 0
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: EMPTY
35321: LIST
35322: LIST
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: LD_INT 0
35329: PUSH
35330: EMPTY
35331: LIST
35332: LIST
35333: PUSH
35334: LD_INT 1
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: LD_INT 0
35346: PUSH
35347: LD_INT 1
35349: PUSH
35350: EMPTY
35351: LIST
35352: LIST
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: LD_INT 0
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: PUSH
35365: LD_INT 1
35367: NEG
35368: PUSH
35369: LD_INT 1
35371: NEG
35372: PUSH
35373: EMPTY
35374: LIST
35375: LIST
35376: PUSH
35377: LD_INT 1
35379: NEG
35380: PUSH
35381: LD_INT 2
35383: NEG
35384: PUSH
35385: EMPTY
35386: LIST
35387: LIST
35388: PUSH
35389: LD_INT 1
35391: PUSH
35392: LD_INT 2
35394: PUSH
35395: EMPTY
35396: LIST
35397: LIST
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: LIST
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35410: LD_ADDR_VAR 0 37
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: LD_INT 0
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 0
35427: PUSH
35428: LD_INT 1
35430: NEG
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: PUSH
35439: LD_INT 0
35441: PUSH
35442: EMPTY
35443: LIST
35444: LIST
35445: PUSH
35446: LD_INT 1
35448: PUSH
35449: LD_INT 1
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 0
35458: PUSH
35459: LD_INT 1
35461: PUSH
35462: EMPTY
35463: LIST
35464: LIST
35465: PUSH
35466: LD_INT 1
35468: NEG
35469: PUSH
35470: LD_INT 0
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 1
35479: NEG
35480: PUSH
35481: LD_INT 1
35483: NEG
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: PUSH
35492: LD_INT 1
35494: NEG
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 1
35506: PUSH
35507: EMPTY
35508: LIST
35509: LIST
35510: PUSH
35511: EMPTY
35512: LIST
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35522: LD_ADDR_VAR 0 38
35526: PUSH
35527: LD_INT 0
35529: PUSH
35530: LD_INT 0
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: LD_INT 1
35542: NEG
35543: PUSH
35544: EMPTY
35545: LIST
35546: LIST
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: LD_INT 0
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: PUSH
35561: LD_INT 1
35563: PUSH
35564: EMPTY
35565: LIST
35566: LIST
35567: PUSH
35568: LD_INT 0
35570: PUSH
35571: LD_INT 1
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: LD_INT 0
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: NEG
35592: PUSH
35593: LD_INT 1
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: NEG
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: EMPTY
35620: LIST
35621: LIST
35622: PUSH
35623: EMPTY
35624: LIST
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35634: LD_ADDR_VAR 0 39
35638: PUSH
35639: LD_INT 0
35641: PUSH
35642: LD_INT 0
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: LD_INT 1
35654: NEG
35655: PUSH
35656: EMPTY
35657: LIST
35658: LIST
35659: PUSH
35660: LD_INT 1
35662: PUSH
35663: LD_INT 0
35665: PUSH
35666: EMPTY
35667: LIST
35668: LIST
35669: PUSH
35670: LD_INT 1
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: EMPTY
35677: LIST
35678: LIST
35679: PUSH
35680: LD_INT 0
35682: PUSH
35683: LD_INT 1
35685: PUSH
35686: EMPTY
35687: LIST
35688: LIST
35689: PUSH
35690: LD_INT 1
35692: NEG
35693: PUSH
35694: LD_INT 0
35696: PUSH
35697: EMPTY
35698: LIST
35699: LIST
35700: PUSH
35701: LD_INT 1
35703: NEG
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: EMPTY
35710: LIST
35711: LIST
35712: PUSH
35713: LD_INT 1
35715: NEG
35716: PUSH
35717: LD_INT 2
35719: NEG
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: PUSH
35728: LD_INT 2
35730: PUSH
35731: EMPTY
35732: LIST
35733: LIST
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35746: LD_ADDR_VAR 0 40
35750: PUSH
35751: LD_INT 0
35753: PUSH
35754: LD_INT 0
35756: PUSH
35757: EMPTY
35758: LIST
35759: LIST
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: LD_INT 1
35766: NEG
35767: PUSH
35768: EMPTY
35769: LIST
35770: LIST
35771: PUSH
35772: LD_INT 1
35774: PUSH
35775: LD_INT 0
35777: PUSH
35778: EMPTY
35779: LIST
35780: LIST
35781: PUSH
35782: LD_INT 1
35784: PUSH
35785: LD_INT 1
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 0
35794: PUSH
35795: LD_INT 1
35797: PUSH
35798: EMPTY
35799: LIST
35800: LIST
35801: PUSH
35802: LD_INT 1
35804: NEG
35805: PUSH
35806: LD_INT 0
35808: PUSH
35809: EMPTY
35810: LIST
35811: LIST
35812: PUSH
35813: LD_INT 1
35815: NEG
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 1
35838: NEG
35839: PUSH
35840: LD_INT 1
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: LIST
35851: LIST
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: LIST
35857: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35858: LD_ADDR_VAR 0 41
35862: PUSH
35863: LD_INT 0
35865: PUSH
35866: LD_INT 0
35868: PUSH
35869: EMPTY
35870: LIST
35871: LIST
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: LD_INT 1
35878: NEG
35879: PUSH
35880: EMPTY
35881: LIST
35882: LIST
35883: PUSH
35884: LD_INT 1
35886: PUSH
35887: LD_INT 0
35889: PUSH
35890: EMPTY
35891: LIST
35892: LIST
35893: PUSH
35894: LD_INT 1
35896: PUSH
35897: LD_INT 1
35899: PUSH
35900: EMPTY
35901: LIST
35902: LIST
35903: PUSH
35904: LD_INT 0
35906: PUSH
35907: LD_INT 1
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 1
35916: NEG
35917: PUSH
35918: LD_INT 0
35920: PUSH
35921: EMPTY
35922: LIST
35923: LIST
35924: PUSH
35925: LD_INT 1
35927: NEG
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 1
35939: NEG
35940: PUSH
35941: LD_INT 2
35943: NEG
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: PUSH
35952: LD_INT 1
35954: NEG
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 2
35962: PUSH
35963: LD_INT 0
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: PUSH
35970: LD_INT 2
35972: PUSH
35973: LD_INT 1
35975: PUSH
35976: EMPTY
35977: LIST
35978: LIST
35979: PUSH
35980: LD_INT 2
35982: PUSH
35983: LD_INT 2
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: LD_INT 1
35992: PUSH
35993: LD_INT 2
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 1
36002: NEG
36003: PUSH
36004: LD_INT 1
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: NEG
36014: PUSH
36015: LD_INT 0
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 2
36024: NEG
36025: PUSH
36026: LD_INT 1
36028: NEG
36029: PUSH
36030: EMPTY
36031: LIST
36032: LIST
36033: PUSH
36034: LD_INT 2
36036: NEG
36037: PUSH
36038: LD_INT 2
36040: NEG
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 2
36048: NEG
36049: PUSH
36050: LD_INT 3
36052: NEG
36053: PUSH
36054: EMPTY
36055: LIST
36056: LIST
36057: PUSH
36058: LD_INT 2
36060: PUSH
36061: LD_INT 1
36063: NEG
36064: PUSH
36065: EMPTY
36066: LIST
36067: LIST
36068: PUSH
36069: LD_INT 3
36071: PUSH
36072: LD_INT 0
36074: PUSH
36075: EMPTY
36076: LIST
36077: LIST
36078: PUSH
36079: LD_INT 3
36081: PUSH
36082: LD_INT 1
36084: PUSH
36085: EMPTY
36086: LIST
36087: LIST
36088: PUSH
36089: LD_INT 3
36091: PUSH
36092: LD_INT 2
36094: PUSH
36095: EMPTY
36096: LIST
36097: LIST
36098: PUSH
36099: LD_INT 3
36101: PUSH
36102: LD_INT 3
36104: PUSH
36105: EMPTY
36106: LIST
36107: LIST
36108: PUSH
36109: LD_INT 2
36111: PUSH
36112: LD_INT 3
36114: PUSH
36115: EMPTY
36116: LIST
36117: LIST
36118: PUSH
36119: LD_INT 2
36121: NEG
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 3
36132: NEG
36133: PUSH
36134: LD_INT 0
36136: PUSH
36137: EMPTY
36138: LIST
36139: LIST
36140: PUSH
36141: LD_INT 3
36143: NEG
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 3
36155: NEG
36156: PUSH
36157: LD_INT 2
36159: NEG
36160: PUSH
36161: EMPTY
36162: LIST
36163: LIST
36164: PUSH
36165: LD_INT 3
36167: NEG
36168: PUSH
36169: LD_INT 3
36171: NEG
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: EMPTY
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: LIST
36185: LIST
36186: LIST
36187: LIST
36188: LIST
36189: LIST
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36208: LD_ADDR_VAR 0 42
36212: PUSH
36213: LD_INT 0
36215: PUSH
36216: LD_INT 0
36218: PUSH
36219: EMPTY
36220: LIST
36221: LIST
36222: PUSH
36223: LD_INT 0
36225: PUSH
36226: LD_INT 1
36228: NEG
36229: PUSH
36230: EMPTY
36231: LIST
36232: LIST
36233: PUSH
36234: LD_INT 1
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 1
36246: PUSH
36247: LD_INT 1
36249: PUSH
36250: EMPTY
36251: LIST
36252: LIST
36253: PUSH
36254: LD_INT 0
36256: PUSH
36257: LD_INT 1
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: LD_INT 0
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 1
36277: NEG
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: NEG
36290: PUSH
36291: LD_INT 2
36293: NEG
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 0
36301: PUSH
36302: LD_INT 2
36304: NEG
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: LD_INT 1
36312: PUSH
36313: LD_INT 1
36315: NEG
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 2
36323: PUSH
36324: LD_INT 1
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: LD_INT 2
36333: PUSH
36334: LD_INT 2
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: PUSH
36341: LD_INT 1
36343: PUSH
36344: LD_INT 2
36346: PUSH
36347: EMPTY
36348: LIST
36349: LIST
36350: PUSH
36351: LD_INT 0
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 1
36363: NEG
36364: PUSH
36365: LD_INT 1
36367: PUSH
36368: EMPTY
36369: LIST
36370: LIST
36371: PUSH
36372: LD_INT 2
36374: NEG
36375: PUSH
36376: LD_INT 1
36378: NEG
36379: PUSH
36380: EMPTY
36381: LIST
36382: LIST
36383: PUSH
36384: LD_INT 2
36386: NEG
36387: PUSH
36388: LD_INT 2
36390: NEG
36391: PUSH
36392: EMPTY
36393: LIST
36394: LIST
36395: PUSH
36396: LD_INT 2
36398: NEG
36399: PUSH
36400: LD_INT 3
36402: NEG
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: LD_INT 3
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: LD_INT 3
36425: NEG
36426: PUSH
36427: EMPTY
36428: LIST
36429: LIST
36430: PUSH
36431: LD_INT 1
36433: PUSH
36434: LD_INT 2
36436: NEG
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 3
36444: PUSH
36445: LD_INT 2
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 3
36454: PUSH
36455: LD_INT 3
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 2
36464: PUSH
36465: LD_INT 3
36467: PUSH
36468: EMPTY
36469: LIST
36470: LIST
36471: PUSH
36472: LD_INT 1
36474: PUSH
36475: LD_INT 3
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: PUSH
36482: LD_INT 0
36484: PUSH
36485: LD_INT 3
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 1
36494: NEG
36495: PUSH
36496: LD_INT 2
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 3
36505: NEG
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 3
36517: NEG
36518: PUSH
36519: LD_INT 3
36521: NEG
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: EMPTY
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: LIST
36551: LIST
36552: LIST
36553: LIST
36554: LIST
36555: LIST
36556: LIST
36557: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36558: LD_ADDR_VAR 0 43
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 0
36575: PUSH
36576: LD_INT 1
36578: NEG
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: LD_INT 1
36586: PUSH
36587: LD_INT 0
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 1
36596: PUSH
36597: LD_INT 1
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 0
36606: PUSH
36607: LD_INT 1
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: NEG
36617: PUSH
36618: LD_INT 0
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: LD_INT 1
36627: NEG
36628: PUSH
36629: LD_INT 1
36631: NEG
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 1
36639: NEG
36640: PUSH
36641: LD_INT 2
36643: NEG
36644: PUSH
36645: EMPTY
36646: LIST
36647: LIST
36648: PUSH
36649: LD_INT 0
36651: PUSH
36652: LD_INT 2
36654: NEG
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: LD_INT 1
36662: PUSH
36663: LD_INT 1
36665: NEG
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: LD_INT 2
36673: PUSH
36674: LD_INT 0
36676: PUSH
36677: EMPTY
36678: LIST
36679: LIST
36680: PUSH
36681: LD_INT 2
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: EMPTY
36688: LIST
36689: LIST
36690: PUSH
36691: LD_INT 1
36693: PUSH
36694: LD_INT 2
36696: PUSH
36697: EMPTY
36698: LIST
36699: LIST
36700: PUSH
36701: LD_INT 0
36703: PUSH
36704: LD_INT 2
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: LD_INT 1
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 2
36724: NEG
36725: PUSH
36726: LD_INT 0
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 2
36735: NEG
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 1
36747: NEG
36748: PUSH
36749: LD_INT 3
36751: NEG
36752: PUSH
36753: EMPTY
36754: LIST
36755: LIST
36756: PUSH
36757: LD_INT 0
36759: PUSH
36760: LD_INT 3
36762: NEG
36763: PUSH
36764: EMPTY
36765: LIST
36766: LIST
36767: PUSH
36768: LD_INT 1
36770: PUSH
36771: LD_INT 2
36773: NEG
36774: PUSH
36775: EMPTY
36776: LIST
36777: LIST
36778: PUSH
36779: LD_INT 2
36781: PUSH
36782: LD_INT 1
36784: NEG
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: LD_INT 3
36792: PUSH
36793: LD_INT 0
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 3
36802: PUSH
36803: LD_INT 1
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: LD_INT 3
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 0
36822: PUSH
36823: LD_INT 3
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: LD_INT 2
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 2
36843: NEG
36844: PUSH
36845: LD_INT 1
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: LD_INT 3
36854: NEG
36855: PUSH
36856: LD_INT 0
36858: PUSH
36859: EMPTY
36860: LIST
36861: LIST
36862: PUSH
36863: LD_INT 3
36865: NEG
36866: PUSH
36867: LD_INT 1
36869: NEG
36870: PUSH
36871: EMPTY
36872: LIST
36873: LIST
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: LIST
36901: LIST
36902: LIST
36903: LIST
36904: LIST
36905: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36906: LD_ADDR_VAR 0 44
36910: PUSH
36911: LD_INT 0
36913: PUSH
36914: LD_INT 0
36916: PUSH
36917: EMPTY
36918: LIST
36919: LIST
36920: PUSH
36921: LD_INT 0
36923: PUSH
36924: LD_INT 1
36926: NEG
36927: PUSH
36928: EMPTY
36929: LIST
36930: LIST
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: LD_INT 0
36937: PUSH
36938: EMPTY
36939: LIST
36940: LIST
36941: PUSH
36942: LD_INT 1
36944: PUSH
36945: LD_INT 1
36947: PUSH
36948: EMPTY
36949: LIST
36950: LIST
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: LD_INT 1
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 0
36968: PUSH
36969: EMPTY
36970: LIST
36971: LIST
36972: PUSH
36973: LD_INT 1
36975: NEG
36976: PUSH
36977: LD_INT 1
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: NEG
36988: PUSH
36989: LD_INT 2
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: LD_INT 1
37002: NEG
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 2
37010: PUSH
37011: LD_INT 0
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 2
37020: PUSH
37021: LD_INT 1
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 2
37030: PUSH
37031: LD_INT 2
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: LD_INT 2
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 1
37050: NEG
37051: PUSH
37052: LD_INT 1
37054: PUSH
37055: EMPTY
37056: LIST
37057: LIST
37058: PUSH
37059: LD_INT 2
37061: NEG
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 2
37072: NEG
37073: PUSH
37074: LD_INT 1
37076: NEG
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 2
37084: NEG
37085: PUSH
37086: LD_INT 2
37088: NEG
37089: PUSH
37090: EMPTY
37091: LIST
37092: LIST
37093: PUSH
37094: LD_INT 2
37096: NEG
37097: PUSH
37098: LD_INT 3
37100: NEG
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: PUSH
37106: LD_INT 2
37108: PUSH
37109: LD_INT 1
37111: NEG
37112: PUSH
37113: EMPTY
37114: LIST
37115: LIST
37116: PUSH
37117: LD_INT 3
37119: PUSH
37120: LD_INT 0
37122: PUSH
37123: EMPTY
37124: LIST
37125: LIST
37126: PUSH
37127: LD_INT 3
37129: PUSH
37130: LD_INT 1
37132: PUSH
37133: EMPTY
37134: LIST
37135: LIST
37136: PUSH
37137: LD_INT 3
37139: PUSH
37140: LD_INT 2
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 3
37149: PUSH
37150: LD_INT 3
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 2
37159: PUSH
37160: LD_INT 3
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: LD_INT 2
37169: NEG
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: EMPTY
37175: LIST
37176: LIST
37177: PUSH
37178: LD_INT 3
37180: NEG
37181: PUSH
37182: LD_INT 0
37184: PUSH
37185: EMPTY
37186: LIST
37187: LIST
37188: PUSH
37189: LD_INT 3
37191: NEG
37192: PUSH
37193: LD_INT 1
37195: NEG
37196: PUSH
37197: EMPTY
37198: LIST
37199: LIST
37200: PUSH
37201: LD_INT 3
37203: NEG
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 3
37215: NEG
37216: PUSH
37217: LD_INT 3
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: LIST
37249: LIST
37250: LIST
37251: LIST
37252: LIST
37253: LIST
37254: LIST
37255: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37256: LD_ADDR_VAR 0 45
37260: PUSH
37261: LD_INT 0
37263: PUSH
37264: LD_INT 0
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 0
37273: PUSH
37274: LD_INT 1
37276: NEG
37277: PUSH
37278: EMPTY
37279: LIST
37280: LIST
37281: PUSH
37282: LD_INT 1
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: EMPTY
37289: LIST
37290: LIST
37291: PUSH
37292: LD_INT 1
37294: PUSH
37295: LD_INT 1
37297: PUSH
37298: EMPTY
37299: LIST
37300: LIST
37301: PUSH
37302: LD_INT 0
37304: PUSH
37305: LD_INT 1
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: LD_INT 1
37314: NEG
37315: PUSH
37316: LD_INT 0
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 1
37325: NEG
37326: PUSH
37327: LD_INT 1
37329: NEG
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 1
37337: NEG
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: EMPTY
37344: LIST
37345: LIST
37346: PUSH
37347: LD_INT 0
37349: PUSH
37350: LD_INT 2
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: LD_INT 1
37360: PUSH
37361: LD_INT 1
37363: NEG
37364: PUSH
37365: EMPTY
37366: LIST
37367: LIST
37368: PUSH
37369: LD_INT 2
37371: PUSH
37372: LD_INT 1
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PUSH
37379: LD_INT 2
37381: PUSH
37382: LD_INT 2
37384: PUSH
37385: EMPTY
37386: LIST
37387: LIST
37388: PUSH
37389: LD_INT 1
37391: PUSH
37392: LD_INT 2
37394: PUSH
37395: EMPTY
37396: LIST
37397: LIST
37398: PUSH
37399: LD_INT 0
37401: PUSH
37402: LD_INT 2
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: PUSH
37409: LD_INT 1
37411: NEG
37412: PUSH
37413: LD_INT 1
37415: PUSH
37416: EMPTY
37417: LIST
37418: LIST
37419: PUSH
37420: LD_INT 2
37422: NEG
37423: PUSH
37424: LD_INT 1
37426: NEG
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 2
37434: NEG
37435: PUSH
37436: LD_INT 2
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 2
37446: NEG
37447: PUSH
37448: LD_INT 3
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: LD_INT 3
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: LD_INT 3
37473: NEG
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: PUSH
37482: LD_INT 2
37484: NEG
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 3
37492: PUSH
37493: LD_INT 2
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 3
37502: PUSH
37503: LD_INT 3
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 2
37512: PUSH
37513: LD_INT 3
37515: PUSH
37516: EMPTY
37517: LIST
37518: LIST
37519: PUSH
37520: LD_INT 1
37522: PUSH
37523: LD_INT 3
37525: PUSH
37526: EMPTY
37527: LIST
37528: LIST
37529: PUSH
37530: LD_INT 0
37532: PUSH
37533: LD_INT 3
37535: PUSH
37536: EMPTY
37537: LIST
37538: LIST
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: LD_INT 2
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 3
37553: NEG
37554: PUSH
37555: LD_INT 2
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 3
37565: NEG
37566: PUSH
37567: LD_INT 3
37569: NEG
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: LIST
37595: LIST
37596: LIST
37597: LIST
37598: LIST
37599: LIST
37600: LIST
37601: LIST
37602: LIST
37603: LIST
37604: LIST
37605: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37606: LD_ADDR_VAR 0 46
37610: PUSH
37611: LD_INT 0
37613: PUSH
37614: LD_INT 0
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: LD_INT 1
37626: NEG
37627: PUSH
37628: EMPTY
37629: LIST
37630: LIST
37631: PUSH
37632: LD_INT 1
37634: PUSH
37635: LD_INT 0
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 1
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 0
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: EMPTY
37670: LIST
37671: LIST
37672: PUSH
37673: LD_INT 1
37675: NEG
37676: PUSH
37677: LD_INT 1
37679: NEG
37680: PUSH
37681: EMPTY
37682: LIST
37683: LIST
37684: PUSH
37685: LD_INT 1
37687: NEG
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 0
37699: PUSH
37700: LD_INT 2
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 1
37710: PUSH
37711: LD_INT 1
37713: NEG
37714: PUSH
37715: EMPTY
37716: LIST
37717: LIST
37718: PUSH
37719: LD_INT 2
37721: PUSH
37722: LD_INT 0
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 1
37741: PUSH
37742: LD_INT 2
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 0
37751: PUSH
37752: LD_INT 2
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: NEG
37773: PUSH
37774: LD_INT 0
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 1
37795: NEG
37796: PUSH
37797: LD_INT 3
37799: NEG
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 0
37807: PUSH
37808: LD_INT 3
37810: NEG
37811: PUSH
37812: EMPTY
37813: LIST
37814: LIST
37815: PUSH
37816: LD_INT 1
37818: PUSH
37819: LD_INT 2
37821: NEG
37822: PUSH
37823: EMPTY
37824: LIST
37825: LIST
37826: PUSH
37827: LD_INT 2
37829: PUSH
37830: LD_INT 1
37832: NEG
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 3
37840: PUSH
37841: LD_INT 0
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 3
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: PUSH
37861: LD_INT 3
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 0
37870: PUSH
37871: LD_INT 3
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: LD_INT 2
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 2
37891: NEG
37892: PUSH
37893: LD_INT 1
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 3
37902: NEG
37903: PUSH
37904: LD_INT 0
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 3
37913: NEG
37914: PUSH
37915: LD_INT 1
37917: NEG
37918: PUSH
37919: EMPTY
37920: LIST
37921: LIST
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: LIST
37949: LIST
37950: LIST
37951: LIST
37952: LIST
37953: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37954: LD_ADDR_VAR 0 47
37958: PUSH
37959: LD_INT 0
37961: PUSH
37962: LD_INT 0
37964: PUSH
37965: EMPTY
37966: LIST
37967: LIST
37968: PUSH
37969: LD_INT 0
37971: PUSH
37972: LD_INT 1
37974: NEG
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PUSH
37980: LD_INT 1
37982: PUSH
37983: LD_INT 0
37985: PUSH
37986: EMPTY
37987: LIST
37988: LIST
37989: PUSH
37990: LD_INT 1
37992: PUSH
37993: LD_INT 1
37995: PUSH
37996: EMPTY
37997: LIST
37998: LIST
37999: PUSH
38000: LD_INT 0
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 1
38012: NEG
38013: PUSH
38014: LD_INT 0
38016: PUSH
38017: EMPTY
38018: LIST
38019: LIST
38020: PUSH
38021: LD_INT 1
38023: NEG
38024: PUSH
38025: LD_INT 1
38027: NEG
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 1
38035: NEG
38036: PUSH
38037: LD_INT 2
38039: NEG
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 0
38047: PUSH
38048: LD_INT 2
38050: NEG
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 1
38058: PUSH
38059: LD_INT 1
38061: NEG
38062: PUSH
38063: EMPTY
38064: LIST
38065: LIST
38066: PUSH
38067: LD_INT 2
38069: NEG
38070: PUSH
38071: LD_INT 1
38073: NEG
38074: PUSH
38075: EMPTY
38076: LIST
38077: LIST
38078: PUSH
38079: LD_INT 2
38081: NEG
38082: PUSH
38083: LD_INT 2
38085: NEG
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: LIST
38095: LIST
38096: LIST
38097: LIST
38098: LIST
38099: LIST
38100: LIST
38101: LIST
38102: LIST
38103: LIST
38104: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38105: LD_ADDR_VAR 0 48
38109: PUSH
38110: LD_INT 0
38112: PUSH
38113: LD_INT 0
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 0
38122: PUSH
38123: LD_INT 1
38125: NEG
38126: PUSH
38127: EMPTY
38128: LIST
38129: LIST
38130: PUSH
38131: LD_INT 1
38133: PUSH
38134: LD_INT 0
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: LD_INT 1
38143: PUSH
38144: LD_INT 1
38146: PUSH
38147: EMPTY
38148: LIST
38149: LIST
38150: PUSH
38151: LD_INT 0
38153: PUSH
38154: LD_INT 1
38156: PUSH
38157: EMPTY
38158: LIST
38159: LIST
38160: PUSH
38161: LD_INT 1
38163: NEG
38164: PUSH
38165: LD_INT 0
38167: PUSH
38168: EMPTY
38169: LIST
38170: LIST
38171: PUSH
38172: LD_INT 1
38174: NEG
38175: PUSH
38176: LD_INT 1
38178: NEG
38179: PUSH
38180: EMPTY
38181: LIST
38182: LIST
38183: PUSH
38184: LD_INT 1
38186: NEG
38187: PUSH
38188: LD_INT 2
38190: NEG
38191: PUSH
38192: EMPTY
38193: LIST
38194: LIST
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: LD_INT 2
38201: NEG
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: LD_INT 1
38209: PUSH
38210: LD_INT 1
38212: NEG
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 2
38220: PUSH
38221: LD_INT 0
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 2
38230: PUSH
38231: LD_INT 1
38233: PUSH
38234: EMPTY
38235: LIST
38236: LIST
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: LIST
38242: LIST
38243: LIST
38244: LIST
38245: LIST
38246: LIST
38247: LIST
38248: LIST
38249: LIST
38250: LIST
38251: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38252: LD_ADDR_VAR 0 49
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: LD_INT 0
38262: PUSH
38263: EMPTY
38264: LIST
38265: LIST
38266: PUSH
38267: LD_INT 0
38269: PUSH
38270: LD_INT 1
38272: NEG
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 1
38280: PUSH
38281: LD_INT 0
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: PUSH
38291: LD_INT 1
38293: PUSH
38294: EMPTY
38295: LIST
38296: LIST
38297: PUSH
38298: LD_INT 0
38300: PUSH
38301: LD_INT 1
38303: PUSH
38304: EMPTY
38305: LIST
38306: LIST
38307: PUSH
38308: LD_INT 1
38310: NEG
38311: PUSH
38312: LD_INT 0
38314: PUSH
38315: EMPTY
38316: LIST
38317: LIST
38318: PUSH
38319: LD_INT 1
38321: NEG
38322: PUSH
38323: LD_INT 1
38325: NEG
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 1
38333: PUSH
38334: LD_INT 1
38336: NEG
38337: PUSH
38338: EMPTY
38339: LIST
38340: LIST
38341: PUSH
38342: LD_INT 2
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 2
38354: PUSH
38355: LD_INT 1
38357: PUSH
38358: EMPTY
38359: LIST
38360: LIST
38361: PUSH
38362: LD_INT 2
38364: PUSH
38365: LD_INT 2
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 1
38374: PUSH
38375: LD_INT 2
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: LIST
38386: LIST
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38396: LD_ADDR_VAR 0 50
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 0
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 1
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 1
38434: PUSH
38435: LD_INT 1
38437: PUSH
38438: EMPTY
38439: LIST
38440: LIST
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 1
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 1
38454: NEG
38455: PUSH
38456: LD_INT 0
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: NEG
38466: PUSH
38467: LD_INT 1
38469: NEG
38470: PUSH
38471: EMPTY
38472: LIST
38473: LIST
38474: PUSH
38475: LD_INT 2
38477: PUSH
38478: LD_INT 1
38480: PUSH
38481: EMPTY
38482: LIST
38483: LIST
38484: PUSH
38485: LD_INT 2
38487: PUSH
38488: LD_INT 2
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 1
38497: PUSH
38498: LD_INT 2
38500: PUSH
38501: EMPTY
38502: LIST
38503: LIST
38504: PUSH
38505: LD_INT 0
38507: PUSH
38508: LD_INT 2
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 1
38517: NEG
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: EMPTY
38523: LIST
38524: LIST
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38540: LD_ADDR_VAR 0 51
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: LD_INT 0
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 1
38560: NEG
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 1
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 1
38621: PUSH
38622: LD_INT 2
38624: PUSH
38625: EMPTY
38626: LIST
38627: LIST
38628: PUSH
38629: LD_INT 0
38631: PUSH
38632: LD_INT 2
38634: PUSH
38635: EMPTY
38636: LIST
38637: LIST
38638: PUSH
38639: LD_INT 1
38641: NEG
38642: PUSH
38643: LD_INT 1
38645: PUSH
38646: EMPTY
38647: LIST
38648: LIST
38649: PUSH
38650: LD_INT 2
38652: NEG
38653: PUSH
38654: LD_INT 0
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: PUSH
38661: LD_INT 2
38663: NEG
38664: PUSH
38665: LD_INT 1
38667: NEG
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: EMPTY
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38687: LD_ADDR_VAR 0 52
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: LD_INT 0
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 0
38704: PUSH
38705: LD_INT 1
38707: NEG
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 1
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 0
38735: PUSH
38736: LD_INT 1
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 1
38756: NEG
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: LD_INT 2
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 1
38780: NEG
38781: PUSH
38782: LD_INT 1
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 2
38791: NEG
38792: PUSH
38793: LD_INT 0
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 2
38802: NEG
38803: PUSH
38804: LD_INT 1
38806: NEG
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 2
38814: NEG
38815: PUSH
38816: LD_INT 2
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: LIST
38833: LIST
38834: LIST
38835: LIST
38836: LIST
38837: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38838: LD_ADDR_VAR 0 53
38842: PUSH
38843: LD_INT 0
38845: PUSH
38846: LD_INT 0
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: PUSH
38853: LD_INT 0
38855: PUSH
38856: LD_INT 1
38858: NEG
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 1
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 1
38876: PUSH
38877: LD_INT 1
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 0
38886: PUSH
38887: LD_INT 1
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: NEG
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 1
38907: NEG
38908: PUSH
38909: LD_INT 1
38911: NEG
38912: PUSH
38913: EMPTY
38914: LIST
38915: LIST
38916: PUSH
38917: LD_INT 1
38919: NEG
38920: PUSH
38921: LD_INT 2
38923: NEG
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: LD_INT 2
38934: NEG
38935: PUSH
38936: EMPTY
38937: LIST
38938: LIST
38939: PUSH
38940: LD_INT 1
38942: PUSH
38943: LD_INT 1
38945: NEG
38946: PUSH
38947: EMPTY
38948: LIST
38949: LIST
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: LD_INT 0
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 2
38963: PUSH
38964: LD_INT 1
38966: PUSH
38967: EMPTY
38968: LIST
38969: LIST
38970: PUSH
38971: LD_INT 2
38973: PUSH
38974: LD_INT 2
38976: PUSH
38977: EMPTY
38978: LIST
38979: LIST
38980: PUSH
38981: LD_INT 1
38983: PUSH
38984: LD_INT 2
38986: PUSH
38987: EMPTY
38988: LIST
38989: LIST
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: LD_INT 2
38996: PUSH
38997: EMPTY
38998: LIST
38999: LIST
39000: PUSH
39001: LD_INT 1
39003: NEG
39004: PUSH
39005: LD_INT 1
39007: PUSH
39008: EMPTY
39009: LIST
39010: LIST
39011: PUSH
39012: LD_INT 2
39014: NEG
39015: PUSH
39016: LD_INT 0
39018: PUSH
39019: EMPTY
39020: LIST
39021: LIST
39022: PUSH
39023: LD_INT 2
39025: NEG
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 2
39037: NEG
39038: PUSH
39039: LD_INT 2
39041: NEG
39042: PUSH
39043: EMPTY
39044: LIST
39045: LIST
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: LIST
39051: LIST
39052: LIST
39053: LIST
39054: LIST
39055: LIST
39056: LIST
39057: LIST
39058: LIST
39059: LIST
39060: LIST
39061: LIST
39062: LIST
39063: LIST
39064: LIST
39065: LIST
39066: LIST
39067: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39068: LD_ADDR_VAR 0 54
39072: PUSH
39073: LD_INT 0
39075: PUSH
39076: LD_INT 0
39078: PUSH
39079: EMPTY
39080: LIST
39081: LIST
39082: PUSH
39083: LD_INT 0
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 1
39096: PUSH
39097: LD_INT 0
39099: PUSH
39100: EMPTY
39101: LIST
39102: LIST
39103: PUSH
39104: LD_INT 1
39106: PUSH
39107: LD_INT 1
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: LD_INT 1
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: LD_INT 0
39130: PUSH
39131: EMPTY
39132: LIST
39133: LIST
39134: PUSH
39135: LD_INT 1
39137: NEG
39138: PUSH
39139: LD_INT 1
39141: NEG
39142: PUSH
39143: EMPTY
39144: LIST
39145: LIST
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: LD_INT 2
39153: NEG
39154: PUSH
39155: EMPTY
39156: LIST
39157: LIST
39158: PUSH
39159: LD_INT 0
39161: PUSH
39162: LD_INT 2
39164: NEG
39165: PUSH
39166: EMPTY
39167: LIST
39168: LIST
39169: PUSH
39170: LD_INT 1
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: LD_INT 2
39183: PUSH
39184: LD_INT 0
39186: PUSH
39187: EMPTY
39188: LIST
39189: LIST
39190: PUSH
39191: LD_INT 2
39193: PUSH
39194: LD_INT 1
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: LD_INT 2
39203: PUSH
39204: LD_INT 2
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 2
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 0
39223: PUSH
39224: LD_INT 2
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 1
39233: NEG
39234: PUSH
39235: LD_INT 1
39237: PUSH
39238: EMPTY
39239: LIST
39240: LIST
39241: PUSH
39242: LD_INT 2
39244: NEG
39245: PUSH
39246: LD_INT 0
39248: PUSH
39249: EMPTY
39250: LIST
39251: LIST
39252: PUSH
39253: LD_INT 2
39255: NEG
39256: PUSH
39257: LD_INT 1
39259: NEG
39260: PUSH
39261: EMPTY
39262: LIST
39263: LIST
39264: PUSH
39265: LD_INT 2
39267: NEG
39268: PUSH
39269: LD_INT 2
39271: NEG
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: LIST
39281: LIST
39282: LIST
39283: LIST
39284: LIST
39285: LIST
39286: LIST
39287: LIST
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39298: LD_ADDR_VAR 0 55
39302: PUSH
39303: LD_INT 0
39305: PUSH
39306: LD_INT 0
39308: PUSH
39309: EMPTY
39310: LIST
39311: LIST
39312: PUSH
39313: LD_INT 0
39315: PUSH
39316: LD_INT 1
39318: NEG
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 1
39326: PUSH
39327: LD_INT 0
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 1
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 0
39346: PUSH
39347: LD_INT 1
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 1
39356: NEG
39357: PUSH
39358: LD_INT 0
39360: PUSH
39361: EMPTY
39362: LIST
39363: LIST
39364: PUSH
39365: LD_INT 1
39367: NEG
39368: PUSH
39369: LD_INT 1
39371: NEG
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: LD_INT 2
39383: NEG
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: LD_INT 0
39391: PUSH
39392: LD_INT 2
39394: NEG
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 1
39402: PUSH
39403: LD_INT 1
39405: NEG
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 2
39413: PUSH
39414: LD_INT 0
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 2
39423: PUSH
39424: LD_INT 1
39426: PUSH
39427: EMPTY
39428: LIST
39429: LIST
39430: PUSH
39431: LD_INT 2
39433: PUSH
39434: LD_INT 2
39436: PUSH
39437: EMPTY
39438: LIST
39439: LIST
39440: PUSH
39441: LD_INT 1
39443: PUSH
39444: LD_INT 2
39446: PUSH
39447: EMPTY
39448: LIST
39449: LIST
39450: PUSH
39451: LD_INT 0
39453: PUSH
39454: LD_INT 2
39456: PUSH
39457: EMPTY
39458: LIST
39459: LIST
39460: PUSH
39461: LD_INT 1
39463: NEG
39464: PUSH
39465: LD_INT 1
39467: PUSH
39468: EMPTY
39469: LIST
39470: LIST
39471: PUSH
39472: LD_INT 2
39474: NEG
39475: PUSH
39476: LD_INT 0
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 2
39485: NEG
39486: PUSH
39487: LD_INT 1
39489: NEG
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 2
39497: NEG
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: EMPTY
39504: LIST
39505: LIST
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: LIST
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39528: LD_ADDR_VAR 0 56
39532: PUSH
39533: LD_INT 0
39535: PUSH
39536: LD_INT 0
39538: PUSH
39539: EMPTY
39540: LIST
39541: LIST
39542: PUSH
39543: LD_INT 0
39545: PUSH
39546: LD_INT 1
39548: NEG
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 1
39566: PUSH
39567: LD_INT 1
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 0
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: EMPTY
39581: LIST
39582: LIST
39583: PUSH
39584: LD_INT 1
39586: NEG
39587: PUSH
39588: LD_INT 0
39590: PUSH
39591: EMPTY
39592: LIST
39593: LIST
39594: PUSH
39595: LD_INT 1
39597: NEG
39598: PUSH
39599: LD_INT 1
39601: NEG
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 1
39609: NEG
39610: PUSH
39611: LD_INT 2
39613: NEG
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: LD_INT 0
39621: PUSH
39622: LD_INT 2
39624: NEG
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 1
39632: PUSH
39633: LD_INT 1
39635: NEG
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PUSH
39641: LD_INT 2
39643: PUSH
39644: LD_INT 0
39646: PUSH
39647: EMPTY
39648: LIST
39649: LIST
39650: PUSH
39651: LD_INT 2
39653: PUSH
39654: LD_INT 1
39656: PUSH
39657: EMPTY
39658: LIST
39659: LIST
39660: PUSH
39661: LD_INT 2
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: EMPTY
39668: LIST
39669: LIST
39670: PUSH
39671: LD_INT 1
39673: PUSH
39674: LD_INT 2
39676: PUSH
39677: EMPTY
39678: LIST
39679: LIST
39680: PUSH
39681: LD_INT 0
39683: PUSH
39684: LD_INT 2
39686: PUSH
39687: EMPTY
39688: LIST
39689: LIST
39690: PUSH
39691: LD_INT 1
39693: NEG
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: EMPTY
39699: LIST
39700: LIST
39701: PUSH
39702: LD_INT 2
39704: NEG
39705: PUSH
39706: LD_INT 0
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 2
39715: NEG
39716: PUSH
39717: LD_INT 1
39719: NEG
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 2
39727: NEG
39728: PUSH
39729: LD_INT 2
39731: NEG
39732: PUSH
39733: EMPTY
39734: LIST
39735: LIST
39736: PUSH
39737: EMPTY
39738: LIST
39739: LIST
39740: LIST
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39758: LD_ADDR_VAR 0 57
39762: PUSH
39763: LD_INT 0
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: EMPTY
39770: LIST
39771: LIST
39772: PUSH
39773: LD_INT 0
39775: PUSH
39776: LD_INT 1
39778: NEG
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: PUSH
39787: LD_INT 0
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 1
39796: PUSH
39797: LD_INT 1
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 0
39806: PUSH
39807: LD_INT 1
39809: PUSH
39810: EMPTY
39811: LIST
39812: LIST
39813: PUSH
39814: LD_INT 1
39816: NEG
39817: PUSH
39818: LD_INT 0
39820: PUSH
39821: EMPTY
39822: LIST
39823: LIST
39824: PUSH
39825: LD_INT 1
39827: NEG
39828: PUSH
39829: LD_INT 1
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 2
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 0
39851: PUSH
39852: LD_INT 2
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: PUSH
39863: LD_INT 1
39865: NEG
39866: PUSH
39867: EMPTY
39868: LIST
39869: LIST
39870: PUSH
39871: LD_INT 2
39873: PUSH
39874: LD_INT 0
39876: PUSH
39877: EMPTY
39878: LIST
39879: LIST
39880: PUSH
39881: LD_INT 2
39883: PUSH
39884: LD_INT 1
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 2
39893: PUSH
39894: LD_INT 2
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: LD_INT 1
39903: PUSH
39904: LD_INT 2
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 0
39913: PUSH
39914: LD_INT 2
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 1
39923: NEG
39924: PUSH
39925: LD_INT 1
39927: PUSH
39928: EMPTY
39929: LIST
39930: LIST
39931: PUSH
39932: LD_INT 2
39934: NEG
39935: PUSH
39936: LD_INT 0
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: LD_INT 2
39945: NEG
39946: PUSH
39947: LD_INT 1
39949: NEG
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 2
39957: NEG
39958: PUSH
39959: LD_INT 2
39961: NEG
39962: PUSH
39963: EMPTY
39964: LIST
39965: LIST
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: LIST
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39988: LD_ADDR_VAR 0 58
39992: PUSH
39993: LD_INT 0
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 0
40005: PUSH
40006: LD_INT 1
40008: NEG
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 1
40016: PUSH
40017: LD_INT 0
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 1
40026: PUSH
40027: LD_INT 1
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 0
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: EMPTY
40041: LIST
40042: LIST
40043: PUSH
40044: LD_INT 1
40046: NEG
40047: PUSH
40048: LD_INT 0
40050: PUSH
40051: EMPTY
40052: LIST
40053: LIST
40054: PUSH
40055: LD_INT 1
40057: NEG
40058: PUSH
40059: LD_INT 1
40061: NEG
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: LD_INT 2
40073: NEG
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 0
40081: PUSH
40082: LD_INT 2
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: PUSH
40093: LD_INT 1
40095: NEG
40096: PUSH
40097: EMPTY
40098: LIST
40099: LIST
40100: PUSH
40101: LD_INT 2
40103: PUSH
40104: LD_INT 0
40106: PUSH
40107: EMPTY
40108: LIST
40109: LIST
40110: PUSH
40111: LD_INT 2
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: EMPTY
40118: LIST
40119: LIST
40120: PUSH
40121: LD_INT 2
40123: PUSH
40124: LD_INT 2
40126: PUSH
40127: EMPTY
40128: LIST
40129: LIST
40130: PUSH
40131: LD_INT 1
40133: PUSH
40134: LD_INT 2
40136: PUSH
40137: EMPTY
40138: LIST
40139: LIST
40140: PUSH
40141: LD_INT 0
40143: PUSH
40144: LD_INT 2
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: PUSH
40151: LD_INT 1
40153: NEG
40154: PUSH
40155: LD_INT 1
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 2
40164: NEG
40165: PUSH
40166: LD_INT 0
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 2
40175: NEG
40176: PUSH
40177: LD_INT 1
40179: NEG
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 2
40187: NEG
40188: PUSH
40189: LD_INT 2
40191: NEG
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: PUSH
40197: EMPTY
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40218: LD_ADDR_VAR 0 59
40222: PUSH
40223: LD_INT 0
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 0
40235: PUSH
40236: LD_INT 1
40238: NEG
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 1
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 0
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 1
40276: NEG
40277: PUSH
40278: LD_INT 0
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 1
40287: NEG
40288: PUSH
40289: LD_INT 1
40291: NEG
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: EMPTY
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40306: LD_ADDR_VAR 0 60
40310: PUSH
40311: LD_INT 0
40313: PUSH
40314: LD_INT 0
40316: PUSH
40317: EMPTY
40318: LIST
40319: LIST
40320: PUSH
40321: LD_INT 0
40323: PUSH
40324: LD_INT 1
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 1
40334: PUSH
40335: LD_INT 0
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 1
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 0
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 1
40364: NEG
40365: PUSH
40366: LD_INT 0
40368: PUSH
40369: EMPTY
40370: LIST
40371: LIST
40372: PUSH
40373: LD_INT 1
40375: NEG
40376: PUSH
40377: LD_INT 1
40379: NEG
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: EMPTY
40386: LIST
40387: LIST
40388: LIST
40389: LIST
40390: LIST
40391: LIST
40392: LIST
40393: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40394: LD_ADDR_VAR 0 61
40398: PUSH
40399: LD_INT 0
40401: PUSH
40402: LD_INT 0
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PUSH
40409: LD_INT 0
40411: PUSH
40412: LD_INT 1
40414: NEG
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 1
40422: PUSH
40423: LD_INT 0
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 1
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: LD_INT 1
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 1
40452: NEG
40453: PUSH
40454: LD_INT 0
40456: PUSH
40457: EMPTY
40458: LIST
40459: LIST
40460: PUSH
40461: LD_INT 1
40463: NEG
40464: PUSH
40465: LD_INT 1
40467: NEG
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40482: LD_ADDR_VAR 0 62
40486: PUSH
40487: LD_INT 0
40489: PUSH
40490: LD_INT 0
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 1
40502: NEG
40503: PUSH
40504: EMPTY
40505: LIST
40506: LIST
40507: PUSH
40508: LD_INT 1
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 1
40520: PUSH
40521: LD_INT 1
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 0
40530: PUSH
40531: LD_INT 1
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: EMPTY
40546: LIST
40547: LIST
40548: PUSH
40549: LD_INT 1
40551: NEG
40552: PUSH
40553: LD_INT 1
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: EMPTY
40562: LIST
40563: LIST
40564: LIST
40565: LIST
40566: LIST
40567: LIST
40568: LIST
40569: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40570: LD_ADDR_VAR 0 63
40574: PUSH
40575: LD_INT 0
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: EMPTY
40582: LIST
40583: LIST
40584: PUSH
40585: LD_INT 0
40587: PUSH
40588: LD_INT 1
40590: NEG
40591: PUSH
40592: EMPTY
40593: LIST
40594: LIST
40595: PUSH
40596: LD_INT 1
40598: PUSH
40599: LD_INT 0
40601: PUSH
40602: EMPTY
40603: LIST
40604: LIST
40605: PUSH
40606: LD_INT 1
40608: PUSH
40609: LD_INT 1
40611: PUSH
40612: EMPTY
40613: LIST
40614: LIST
40615: PUSH
40616: LD_INT 0
40618: PUSH
40619: LD_INT 1
40621: PUSH
40622: EMPTY
40623: LIST
40624: LIST
40625: PUSH
40626: LD_INT 1
40628: NEG
40629: PUSH
40630: LD_INT 0
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: LD_INT 1
40639: NEG
40640: PUSH
40641: LD_INT 1
40643: NEG
40644: PUSH
40645: EMPTY
40646: LIST
40647: LIST
40648: PUSH
40649: EMPTY
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40658: LD_ADDR_VAR 0 64
40662: PUSH
40663: LD_INT 0
40665: PUSH
40666: LD_INT 0
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 0
40675: PUSH
40676: LD_INT 1
40678: NEG
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 1
40686: PUSH
40687: LD_INT 0
40689: PUSH
40690: EMPTY
40691: LIST
40692: LIST
40693: PUSH
40694: LD_INT 1
40696: PUSH
40697: LD_INT 1
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: PUSH
40704: LD_INT 0
40706: PUSH
40707: LD_INT 1
40709: PUSH
40710: EMPTY
40711: LIST
40712: LIST
40713: PUSH
40714: LD_INT 1
40716: NEG
40717: PUSH
40718: LD_INT 0
40720: PUSH
40721: EMPTY
40722: LIST
40723: LIST
40724: PUSH
40725: LD_INT 1
40727: NEG
40728: PUSH
40729: LD_INT 1
40731: NEG
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: ST_TO_ADDR
// end ; 1 :
40746: GO 46643
40748: LD_INT 1
40750: DOUBLE
40751: EQUAL
40752: IFTRUE 40756
40754: GO 43379
40756: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
40757: LD_ADDR_VAR 0 11
40761: PUSH
40762: LD_INT 1
40764: NEG
40765: PUSH
40766: LD_INT 3
40768: NEG
40769: PUSH
40770: EMPTY
40771: LIST
40772: LIST
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: LD_INT 3
40779: NEG
40780: PUSH
40781: EMPTY
40782: LIST
40783: LIST
40784: PUSH
40785: LD_INT 1
40787: PUSH
40788: LD_INT 2
40790: NEG
40791: PUSH
40792: EMPTY
40793: LIST
40794: LIST
40795: PUSH
40796: EMPTY
40797: LIST
40798: LIST
40799: LIST
40800: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
40801: LD_ADDR_VAR 0 12
40805: PUSH
40806: LD_INT 2
40808: PUSH
40809: LD_INT 1
40811: NEG
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 3
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 3
40829: PUSH
40830: LD_INT 1
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: LIST
40841: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40842: LD_ADDR_VAR 0 13
40846: PUSH
40847: LD_INT 3
40849: PUSH
40850: LD_INT 2
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 3
40859: PUSH
40860: LD_INT 3
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 2
40869: PUSH
40870: LD_INT 3
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: LIST
40881: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40882: LD_ADDR_VAR 0 14
40886: PUSH
40887: LD_INT 1
40889: PUSH
40890: LD_INT 3
40892: PUSH
40893: EMPTY
40894: LIST
40895: LIST
40896: PUSH
40897: LD_INT 0
40899: PUSH
40900: LD_INT 3
40902: PUSH
40903: EMPTY
40904: LIST
40905: LIST
40906: PUSH
40907: LD_INT 1
40909: NEG
40910: PUSH
40911: LD_INT 2
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: EMPTY
40919: LIST
40920: LIST
40921: LIST
40922: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40923: LD_ADDR_VAR 0 15
40927: PUSH
40928: LD_INT 2
40930: NEG
40931: PUSH
40932: LD_INT 1
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 3
40941: NEG
40942: PUSH
40943: LD_INT 0
40945: PUSH
40946: EMPTY
40947: LIST
40948: LIST
40949: PUSH
40950: LD_INT 3
40952: NEG
40953: PUSH
40954: LD_INT 1
40956: NEG
40957: PUSH
40958: EMPTY
40959: LIST
40960: LIST
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: LIST
40966: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40967: LD_ADDR_VAR 0 16
40971: PUSH
40972: LD_INT 2
40974: NEG
40975: PUSH
40976: LD_INT 3
40978: NEG
40979: PUSH
40980: EMPTY
40981: LIST
40982: LIST
40983: PUSH
40984: LD_INT 3
40986: NEG
40987: PUSH
40988: LD_INT 2
40990: NEG
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 3
40998: NEG
40999: PUSH
41000: LD_INT 3
41002: NEG
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: LIST
41012: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41013: LD_ADDR_VAR 0 17
41017: PUSH
41018: LD_INT 1
41020: NEG
41021: PUSH
41022: LD_INT 3
41024: NEG
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: LD_INT 3
41035: NEG
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 1
41043: PUSH
41044: LD_INT 2
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: EMPTY
41053: LIST
41054: LIST
41055: LIST
41056: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41057: LD_ADDR_VAR 0 18
41061: PUSH
41062: LD_INT 2
41064: PUSH
41065: LD_INT 1
41067: NEG
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 3
41075: PUSH
41076: LD_INT 0
41078: PUSH
41079: EMPTY
41080: LIST
41081: LIST
41082: PUSH
41083: LD_INT 3
41085: PUSH
41086: LD_INT 1
41088: PUSH
41089: EMPTY
41090: LIST
41091: LIST
41092: PUSH
41093: EMPTY
41094: LIST
41095: LIST
41096: LIST
41097: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41098: LD_ADDR_VAR 0 19
41102: PUSH
41103: LD_INT 3
41105: PUSH
41106: LD_INT 2
41108: PUSH
41109: EMPTY
41110: LIST
41111: LIST
41112: PUSH
41113: LD_INT 3
41115: PUSH
41116: LD_INT 3
41118: PUSH
41119: EMPTY
41120: LIST
41121: LIST
41122: PUSH
41123: LD_INT 2
41125: PUSH
41126: LD_INT 3
41128: PUSH
41129: EMPTY
41130: LIST
41131: LIST
41132: PUSH
41133: EMPTY
41134: LIST
41135: LIST
41136: LIST
41137: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41138: LD_ADDR_VAR 0 20
41142: PUSH
41143: LD_INT 1
41145: PUSH
41146: LD_INT 3
41148: PUSH
41149: EMPTY
41150: LIST
41151: LIST
41152: PUSH
41153: LD_INT 0
41155: PUSH
41156: LD_INT 3
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 1
41165: NEG
41166: PUSH
41167: LD_INT 2
41169: PUSH
41170: EMPTY
41171: LIST
41172: LIST
41173: PUSH
41174: EMPTY
41175: LIST
41176: LIST
41177: LIST
41178: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41179: LD_ADDR_VAR 0 21
41183: PUSH
41184: LD_INT 2
41186: NEG
41187: PUSH
41188: LD_INT 1
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 3
41197: NEG
41198: PUSH
41199: LD_INT 0
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: LD_INT 1
41212: NEG
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: LIST
41222: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41223: LD_ADDR_VAR 0 22
41227: PUSH
41228: LD_INT 2
41230: NEG
41231: PUSH
41232: LD_INT 3
41234: NEG
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 3
41242: NEG
41243: PUSH
41244: LD_INT 2
41246: NEG
41247: PUSH
41248: EMPTY
41249: LIST
41250: LIST
41251: PUSH
41252: LD_INT 3
41254: NEG
41255: PUSH
41256: LD_INT 3
41258: NEG
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41269: LD_ADDR_VAR 0 23
41273: PUSH
41274: LD_INT 0
41276: PUSH
41277: LD_INT 3
41279: NEG
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 1
41287: NEG
41288: PUSH
41289: LD_INT 4
41291: NEG
41292: PUSH
41293: EMPTY
41294: LIST
41295: LIST
41296: PUSH
41297: LD_INT 1
41299: PUSH
41300: LD_INT 3
41302: NEG
41303: PUSH
41304: EMPTY
41305: LIST
41306: LIST
41307: PUSH
41308: EMPTY
41309: LIST
41310: LIST
41311: LIST
41312: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41313: LD_ADDR_VAR 0 24
41317: PUSH
41318: LD_INT 3
41320: PUSH
41321: LD_INT 0
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: PUSH
41328: LD_INT 3
41330: PUSH
41331: LD_INT 1
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 4
41341: PUSH
41342: LD_INT 1
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: LIST
41353: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41354: LD_ADDR_VAR 0 25
41358: PUSH
41359: LD_INT 3
41361: PUSH
41362: LD_INT 3
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 4
41371: PUSH
41372: LD_INT 3
41374: PUSH
41375: EMPTY
41376: LIST
41377: LIST
41378: PUSH
41379: LD_INT 3
41381: PUSH
41382: LD_INT 4
41384: PUSH
41385: EMPTY
41386: LIST
41387: LIST
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: LIST
41393: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41394: LD_ADDR_VAR 0 26
41398: PUSH
41399: LD_INT 0
41401: PUSH
41402: LD_INT 3
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 1
41411: PUSH
41412: LD_INT 4
41414: PUSH
41415: EMPTY
41416: LIST
41417: LIST
41418: PUSH
41419: LD_INT 1
41421: NEG
41422: PUSH
41423: LD_INT 3
41425: PUSH
41426: EMPTY
41427: LIST
41428: LIST
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: LIST
41434: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41435: LD_ADDR_VAR 0 27
41439: PUSH
41440: LD_INT 3
41442: NEG
41443: PUSH
41444: LD_INT 0
41446: PUSH
41447: EMPTY
41448: LIST
41449: LIST
41450: PUSH
41451: LD_INT 3
41453: NEG
41454: PUSH
41455: LD_INT 1
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 4
41464: NEG
41465: PUSH
41466: LD_INT 1
41468: NEG
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: PUSH
41474: EMPTY
41475: LIST
41476: LIST
41477: LIST
41478: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41479: LD_ADDR_VAR 0 28
41483: PUSH
41484: LD_INT 3
41486: NEG
41487: PUSH
41488: LD_INT 3
41490: NEG
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 3
41498: NEG
41499: PUSH
41500: LD_INT 4
41502: NEG
41503: PUSH
41504: EMPTY
41505: LIST
41506: LIST
41507: PUSH
41508: LD_INT 4
41510: NEG
41511: PUSH
41512: LD_INT 3
41514: NEG
41515: PUSH
41516: EMPTY
41517: LIST
41518: LIST
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: LIST
41524: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41525: LD_ADDR_VAR 0 29
41529: PUSH
41530: LD_INT 1
41532: NEG
41533: PUSH
41534: LD_INT 3
41536: NEG
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 0
41544: PUSH
41545: LD_INT 3
41547: NEG
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: LD_INT 1
41555: PUSH
41556: LD_INT 2
41558: NEG
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: LD_INT 1
41566: NEG
41567: PUSH
41568: LD_INT 4
41570: NEG
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 0
41578: PUSH
41579: LD_INT 4
41581: NEG
41582: PUSH
41583: EMPTY
41584: LIST
41585: LIST
41586: PUSH
41587: LD_INT 1
41589: PUSH
41590: LD_INT 3
41592: NEG
41593: PUSH
41594: EMPTY
41595: LIST
41596: LIST
41597: PUSH
41598: LD_INT 1
41600: NEG
41601: PUSH
41602: LD_INT 5
41604: NEG
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 0
41612: PUSH
41613: LD_INT 5
41615: NEG
41616: PUSH
41617: EMPTY
41618: LIST
41619: LIST
41620: PUSH
41621: LD_INT 1
41623: PUSH
41624: LD_INT 4
41626: NEG
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: PUSH
41632: LD_INT 1
41634: NEG
41635: PUSH
41636: LD_INT 6
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 0
41646: PUSH
41647: LD_INT 6
41649: NEG
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: LD_INT 5
41660: NEG
41661: PUSH
41662: EMPTY
41663: LIST
41664: LIST
41665: PUSH
41666: EMPTY
41667: LIST
41668: LIST
41669: LIST
41670: LIST
41671: LIST
41672: LIST
41673: LIST
41674: LIST
41675: LIST
41676: LIST
41677: LIST
41678: LIST
41679: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
41680: LD_ADDR_VAR 0 30
41684: PUSH
41685: LD_INT 2
41687: PUSH
41688: LD_INT 1
41690: NEG
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: PUSH
41696: LD_INT 3
41698: PUSH
41699: LD_INT 0
41701: PUSH
41702: EMPTY
41703: LIST
41704: LIST
41705: PUSH
41706: LD_INT 3
41708: PUSH
41709: LD_INT 1
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 3
41718: PUSH
41719: LD_INT 1
41721: NEG
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: LD_INT 4
41729: PUSH
41730: LD_INT 0
41732: PUSH
41733: EMPTY
41734: LIST
41735: LIST
41736: PUSH
41737: LD_INT 4
41739: PUSH
41740: LD_INT 1
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: LD_INT 4
41749: PUSH
41750: LD_INT 1
41752: NEG
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 5
41760: PUSH
41761: LD_INT 0
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 5
41770: PUSH
41771: LD_INT 1
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 5
41780: PUSH
41781: LD_INT 1
41783: NEG
41784: PUSH
41785: EMPTY
41786: LIST
41787: LIST
41788: PUSH
41789: LD_INT 6
41791: PUSH
41792: LD_INT 0
41794: PUSH
41795: EMPTY
41796: LIST
41797: LIST
41798: PUSH
41799: LD_INT 6
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: LIST
41814: LIST
41815: LIST
41816: LIST
41817: LIST
41818: LIST
41819: LIST
41820: LIST
41821: LIST
41822: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
41823: LD_ADDR_VAR 0 31
41827: PUSH
41828: LD_INT 3
41830: PUSH
41831: LD_INT 2
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: PUSH
41838: LD_INT 3
41840: PUSH
41841: LD_INT 3
41843: PUSH
41844: EMPTY
41845: LIST
41846: LIST
41847: PUSH
41848: LD_INT 2
41850: PUSH
41851: LD_INT 3
41853: PUSH
41854: EMPTY
41855: LIST
41856: LIST
41857: PUSH
41858: LD_INT 4
41860: PUSH
41861: LD_INT 3
41863: PUSH
41864: EMPTY
41865: LIST
41866: LIST
41867: PUSH
41868: LD_INT 4
41870: PUSH
41871: LD_INT 4
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: LD_INT 3
41880: PUSH
41881: LD_INT 4
41883: PUSH
41884: EMPTY
41885: LIST
41886: LIST
41887: PUSH
41888: LD_INT 5
41890: PUSH
41891: LD_INT 4
41893: PUSH
41894: EMPTY
41895: LIST
41896: LIST
41897: PUSH
41898: LD_INT 5
41900: PUSH
41901: LD_INT 5
41903: PUSH
41904: EMPTY
41905: LIST
41906: LIST
41907: PUSH
41908: LD_INT 4
41910: PUSH
41911: LD_INT 5
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: PUSH
41918: LD_INT 6
41920: PUSH
41921: LD_INT 5
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: PUSH
41928: LD_INT 6
41930: PUSH
41931: LD_INT 6
41933: PUSH
41934: EMPTY
41935: LIST
41936: LIST
41937: PUSH
41938: LD_INT 5
41940: PUSH
41941: LD_INT 6
41943: PUSH
41944: EMPTY
41945: LIST
41946: LIST
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: LIST
41952: LIST
41953: LIST
41954: LIST
41955: LIST
41956: LIST
41957: LIST
41958: LIST
41959: LIST
41960: LIST
41961: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
41962: LD_ADDR_VAR 0 32
41966: PUSH
41967: LD_INT 1
41969: PUSH
41970: LD_INT 3
41972: PUSH
41973: EMPTY
41974: LIST
41975: LIST
41976: PUSH
41977: LD_INT 0
41979: PUSH
41980: LD_INT 3
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 1
41989: NEG
41990: PUSH
41991: LD_INT 2
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: LD_INT 4
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PUSH
42008: LD_INT 0
42010: PUSH
42011: LD_INT 4
42013: PUSH
42014: EMPTY
42015: LIST
42016: LIST
42017: PUSH
42018: LD_INT 1
42020: NEG
42021: PUSH
42022: LD_INT 3
42024: PUSH
42025: EMPTY
42026: LIST
42027: LIST
42028: PUSH
42029: LD_INT 1
42031: PUSH
42032: LD_INT 5
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 0
42041: PUSH
42042: LD_INT 5
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 1
42051: NEG
42052: PUSH
42053: LD_INT 4
42055: PUSH
42056: EMPTY
42057: LIST
42058: LIST
42059: PUSH
42060: LD_INT 1
42062: PUSH
42063: LD_INT 6
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 0
42072: PUSH
42073: LD_INT 6
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 1
42082: NEG
42083: PUSH
42084: LD_INT 5
42086: PUSH
42087: EMPTY
42088: LIST
42089: LIST
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: LIST
42095: LIST
42096: LIST
42097: LIST
42098: LIST
42099: LIST
42100: LIST
42101: LIST
42102: LIST
42103: LIST
42104: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42105: LD_ADDR_VAR 0 33
42109: PUSH
42110: LD_INT 2
42112: NEG
42113: PUSH
42114: LD_INT 1
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 3
42123: NEG
42124: PUSH
42125: LD_INT 0
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 3
42134: NEG
42135: PUSH
42136: LD_INT 1
42138: NEG
42139: PUSH
42140: EMPTY
42141: LIST
42142: LIST
42143: PUSH
42144: LD_INT 3
42146: NEG
42147: PUSH
42148: LD_INT 1
42150: PUSH
42151: EMPTY
42152: LIST
42153: LIST
42154: PUSH
42155: LD_INT 4
42157: NEG
42158: PUSH
42159: LD_INT 0
42161: PUSH
42162: EMPTY
42163: LIST
42164: LIST
42165: PUSH
42166: LD_INT 4
42168: NEG
42169: PUSH
42170: LD_INT 1
42172: NEG
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 4
42180: NEG
42181: PUSH
42182: LD_INT 1
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 5
42191: NEG
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 5
42202: NEG
42203: PUSH
42204: LD_INT 1
42206: NEG
42207: PUSH
42208: EMPTY
42209: LIST
42210: LIST
42211: PUSH
42212: LD_INT 5
42214: NEG
42215: PUSH
42216: LD_INT 1
42218: PUSH
42219: EMPTY
42220: LIST
42221: LIST
42222: PUSH
42223: LD_INT 6
42225: NEG
42226: PUSH
42227: LD_INT 0
42229: PUSH
42230: EMPTY
42231: LIST
42232: LIST
42233: PUSH
42234: LD_INT 6
42236: NEG
42237: PUSH
42238: LD_INT 1
42240: NEG
42241: PUSH
42242: EMPTY
42243: LIST
42244: LIST
42245: PUSH
42246: EMPTY
42247: LIST
42248: LIST
42249: LIST
42250: LIST
42251: LIST
42252: LIST
42253: LIST
42254: LIST
42255: LIST
42256: LIST
42257: LIST
42258: LIST
42259: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42260: LD_ADDR_VAR 0 34
42264: PUSH
42265: LD_INT 2
42267: NEG
42268: PUSH
42269: LD_INT 3
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 3
42279: NEG
42280: PUSH
42281: LD_INT 2
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 3
42291: NEG
42292: PUSH
42293: LD_INT 3
42295: NEG
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 3
42303: NEG
42304: PUSH
42305: LD_INT 4
42307: NEG
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 4
42315: NEG
42316: PUSH
42317: LD_INT 3
42319: NEG
42320: PUSH
42321: EMPTY
42322: LIST
42323: LIST
42324: PUSH
42325: LD_INT 4
42327: NEG
42328: PUSH
42329: LD_INT 4
42331: NEG
42332: PUSH
42333: EMPTY
42334: LIST
42335: LIST
42336: PUSH
42337: LD_INT 4
42339: NEG
42340: PUSH
42341: LD_INT 5
42343: NEG
42344: PUSH
42345: EMPTY
42346: LIST
42347: LIST
42348: PUSH
42349: LD_INT 5
42351: NEG
42352: PUSH
42353: LD_INT 4
42355: NEG
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 5
42363: NEG
42364: PUSH
42365: LD_INT 5
42367: NEG
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 5
42375: NEG
42376: PUSH
42377: LD_INT 6
42379: NEG
42380: PUSH
42381: EMPTY
42382: LIST
42383: LIST
42384: PUSH
42385: LD_INT 6
42387: NEG
42388: PUSH
42389: LD_INT 5
42391: NEG
42392: PUSH
42393: EMPTY
42394: LIST
42395: LIST
42396: PUSH
42397: LD_INT 6
42399: NEG
42400: PUSH
42401: LD_INT 6
42403: NEG
42404: PUSH
42405: EMPTY
42406: LIST
42407: LIST
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42423: LD_ADDR_VAR 0 41
42427: PUSH
42428: LD_INT 0
42430: PUSH
42431: LD_INT 2
42433: NEG
42434: PUSH
42435: EMPTY
42436: LIST
42437: LIST
42438: PUSH
42439: LD_INT 1
42441: NEG
42442: PUSH
42443: LD_INT 3
42445: NEG
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: PUSH
42451: LD_INT 1
42453: PUSH
42454: LD_INT 2
42456: NEG
42457: PUSH
42458: EMPTY
42459: LIST
42460: LIST
42461: PUSH
42462: EMPTY
42463: LIST
42464: LIST
42465: LIST
42466: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42467: LD_ADDR_VAR 0 42
42471: PUSH
42472: LD_INT 2
42474: PUSH
42475: LD_INT 0
42477: PUSH
42478: EMPTY
42479: LIST
42480: LIST
42481: PUSH
42482: LD_INT 2
42484: PUSH
42485: LD_INT 1
42487: NEG
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 3
42495: PUSH
42496: LD_INT 1
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: EMPTY
42504: LIST
42505: LIST
42506: LIST
42507: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42508: LD_ADDR_VAR 0 43
42512: PUSH
42513: LD_INT 2
42515: PUSH
42516: LD_INT 2
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 3
42525: PUSH
42526: LD_INT 2
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 2
42535: PUSH
42536: LD_INT 3
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: LIST
42547: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42548: LD_ADDR_VAR 0 44
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: LD_INT 2
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 1
42565: PUSH
42566: LD_INT 3
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 1
42575: NEG
42576: PUSH
42577: LD_INT 2
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: LIST
42588: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42589: LD_ADDR_VAR 0 45
42593: PUSH
42594: LD_INT 2
42596: NEG
42597: PUSH
42598: LD_INT 0
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 2
42607: NEG
42608: PUSH
42609: LD_INT 1
42611: PUSH
42612: EMPTY
42613: LIST
42614: LIST
42615: PUSH
42616: LD_INT 3
42618: NEG
42619: PUSH
42620: LD_INT 1
42622: NEG
42623: PUSH
42624: EMPTY
42625: LIST
42626: LIST
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: LIST
42632: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42633: LD_ADDR_VAR 0 46
42637: PUSH
42638: LD_INT 2
42640: NEG
42641: PUSH
42642: LD_INT 2
42644: NEG
42645: PUSH
42646: EMPTY
42647: LIST
42648: LIST
42649: PUSH
42650: LD_INT 2
42652: NEG
42653: PUSH
42654: LD_INT 3
42656: NEG
42657: PUSH
42658: EMPTY
42659: LIST
42660: LIST
42661: PUSH
42662: LD_INT 3
42664: NEG
42665: PUSH
42666: LD_INT 2
42668: NEG
42669: PUSH
42670: EMPTY
42671: LIST
42672: LIST
42673: PUSH
42674: EMPTY
42675: LIST
42676: LIST
42677: LIST
42678: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
42679: LD_ADDR_VAR 0 47
42683: PUSH
42684: LD_INT 2
42686: NEG
42687: PUSH
42688: LD_INT 3
42690: NEG
42691: PUSH
42692: EMPTY
42693: LIST
42694: LIST
42695: PUSH
42696: LD_INT 1
42698: NEG
42699: PUSH
42700: LD_INT 3
42702: NEG
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
42712: LD_ADDR_VAR 0 48
42716: PUSH
42717: LD_INT 1
42719: PUSH
42720: LD_INT 2
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 2
42730: PUSH
42731: LD_INT 1
42733: NEG
42734: PUSH
42735: EMPTY
42736: LIST
42737: LIST
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
42743: LD_ADDR_VAR 0 49
42747: PUSH
42748: LD_INT 3
42750: PUSH
42751: LD_INT 1
42753: PUSH
42754: EMPTY
42755: LIST
42756: LIST
42757: PUSH
42758: LD_INT 3
42760: PUSH
42761: LD_INT 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
42772: LD_ADDR_VAR 0 50
42776: PUSH
42777: LD_INT 2
42779: PUSH
42780: LD_INT 3
42782: PUSH
42783: EMPTY
42784: LIST
42785: LIST
42786: PUSH
42787: LD_INT 1
42789: PUSH
42790: LD_INT 3
42792: PUSH
42793: EMPTY
42794: LIST
42795: LIST
42796: PUSH
42797: EMPTY
42798: LIST
42799: LIST
42800: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
42801: LD_ADDR_VAR 0 51
42805: PUSH
42806: LD_INT 1
42808: NEG
42809: PUSH
42810: LD_INT 2
42812: PUSH
42813: EMPTY
42814: LIST
42815: LIST
42816: PUSH
42817: LD_INT 2
42819: NEG
42820: PUSH
42821: LD_INT 1
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
42832: LD_ADDR_VAR 0 52
42836: PUSH
42837: LD_INT 3
42839: NEG
42840: PUSH
42841: LD_INT 1
42843: NEG
42844: PUSH
42845: EMPTY
42846: LIST
42847: LIST
42848: PUSH
42849: LD_INT 3
42851: NEG
42852: PUSH
42853: LD_INT 2
42855: NEG
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: EMPTY
42862: LIST
42863: LIST
42864: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
42865: LD_ADDR_VAR 0 53
42869: PUSH
42870: LD_INT 1
42872: NEG
42873: PUSH
42874: LD_INT 3
42876: NEG
42877: PUSH
42878: EMPTY
42879: LIST
42880: LIST
42881: PUSH
42882: LD_INT 0
42884: PUSH
42885: LD_INT 3
42887: NEG
42888: PUSH
42889: EMPTY
42890: LIST
42891: LIST
42892: PUSH
42893: LD_INT 1
42895: PUSH
42896: LD_INT 2
42898: NEG
42899: PUSH
42900: EMPTY
42901: LIST
42902: LIST
42903: PUSH
42904: EMPTY
42905: LIST
42906: LIST
42907: LIST
42908: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
42909: LD_ADDR_VAR 0 54
42913: PUSH
42914: LD_INT 2
42916: PUSH
42917: LD_INT 1
42919: NEG
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: LD_INT 3
42927: PUSH
42928: LD_INT 0
42930: PUSH
42931: EMPTY
42932: LIST
42933: LIST
42934: PUSH
42935: LD_INT 3
42937: PUSH
42938: LD_INT 1
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: LIST
42949: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
42950: LD_ADDR_VAR 0 55
42954: PUSH
42955: LD_INT 3
42957: PUSH
42958: LD_INT 2
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 3
42967: PUSH
42968: LD_INT 3
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 2
42977: PUSH
42978: LD_INT 3
42980: PUSH
42981: EMPTY
42982: LIST
42983: LIST
42984: PUSH
42985: EMPTY
42986: LIST
42987: LIST
42988: LIST
42989: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
42990: LD_ADDR_VAR 0 56
42994: PUSH
42995: LD_INT 1
42997: PUSH
42998: LD_INT 3
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 3
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 1
43017: NEG
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: LIST
43030: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43031: LD_ADDR_VAR 0 57
43035: PUSH
43036: LD_INT 2
43038: NEG
43039: PUSH
43040: LD_INT 1
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: LD_INT 3
43049: NEG
43050: PUSH
43051: LD_INT 0
43053: PUSH
43054: EMPTY
43055: LIST
43056: LIST
43057: PUSH
43058: LD_INT 3
43060: NEG
43061: PUSH
43062: LD_INT 1
43064: NEG
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: EMPTY
43071: LIST
43072: LIST
43073: LIST
43074: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43075: LD_ADDR_VAR 0 58
43079: PUSH
43080: LD_INT 2
43082: NEG
43083: PUSH
43084: LD_INT 3
43086: NEG
43087: PUSH
43088: EMPTY
43089: LIST
43090: LIST
43091: PUSH
43092: LD_INT 3
43094: NEG
43095: PUSH
43096: LD_INT 2
43098: NEG
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PUSH
43104: LD_INT 3
43106: NEG
43107: PUSH
43108: LD_INT 3
43110: NEG
43111: PUSH
43112: EMPTY
43113: LIST
43114: LIST
43115: PUSH
43116: EMPTY
43117: LIST
43118: LIST
43119: LIST
43120: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43121: LD_ADDR_VAR 0 59
43125: PUSH
43126: LD_INT 1
43128: NEG
43129: PUSH
43130: LD_INT 2
43132: NEG
43133: PUSH
43134: EMPTY
43135: LIST
43136: LIST
43137: PUSH
43138: LD_INT 0
43140: PUSH
43141: LD_INT 2
43143: NEG
43144: PUSH
43145: EMPTY
43146: LIST
43147: LIST
43148: PUSH
43149: LD_INT 1
43151: PUSH
43152: LD_INT 1
43154: NEG
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: EMPTY
43161: LIST
43162: LIST
43163: LIST
43164: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43165: LD_ADDR_VAR 0 60
43169: PUSH
43170: LD_INT 1
43172: PUSH
43173: LD_INT 1
43175: NEG
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 2
43183: PUSH
43184: LD_INT 0
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: LD_INT 1
43196: PUSH
43197: EMPTY
43198: LIST
43199: LIST
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: LIST
43205: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43206: LD_ADDR_VAR 0 61
43210: PUSH
43211: LD_INT 2
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 2
43223: PUSH
43224: LD_INT 2
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: LD_INT 1
43233: PUSH
43234: LD_INT 2
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: EMPTY
43242: LIST
43243: LIST
43244: LIST
43245: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43246: LD_ADDR_VAR 0 62
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: LD_INT 2
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 0
43263: PUSH
43264: LD_INT 2
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: LD_INT 1
43273: NEG
43274: PUSH
43275: LD_INT 1
43277: PUSH
43278: EMPTY
43279: LIST
43280: LIST
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: LIST
43286: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43287: LD_ADDR_VAR 0 63
43291: PUSH
43292: LD_INT 1
43294: NEG
43295: PUSH
43296: LD_INT 1
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 2
43305: NEG
43306: PUSH
43307: LD_INT 0
43309: PUSH
43310: EMPTY
43311: LIST
43312: LIST
43313: PUSH
43314: LD_INT 2
43316: NEG
43317: PUSH
43318: LD_INT 1
43320: NEG
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: LIST
43330: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43331: LD_ADDR_VAR 0 64
43335: PUSH
43336: LD_INT 1
43338: NEG
43339: PUSH
43340: LD_INT 2
43342: NEG
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 2
43350: NEG
43351: PUSH
43352: LD_INT 1
43354: NEG
43355: PUSH
43356: EMPTY
43357: LIST
43358: LIST
43359: PUSH
43360: LD_INT 2
43362: NEG
43363: PUSH
43364: LD_INT 2
43366: NEG
43367: PUSH
43368: EMPTY
43369: LIST
43370: LIST
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: LIST
43376: ST_TO_ADDR
// end ; 2 :
43377: GO 46643
43379: LD_INT 2
43381: DOUBLE
43382: EQUAL
43383: IFTRUE 43387
43385: GO 46642
43387: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43388: LD_ADDR_VAR 0 29
43392: PUSH
43393: LD_INT 4
43395: PUSH
43396: LD_INT 0
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 4
43405: PUSH
43406: LD_INT 1
43408: NEG
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 5
43416: PUSH
43417: LD_INT 0
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 5
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: EMPTY
43431: LIST
43432: LIST
43433: PUSH
43434: LD_INT 4
43436: PUSH
43437: LD_INT 1
43439: PUSH
43440: EMPTY
43441: LIST
43442: LIST
43443: PUSH
43444: LD_INT 3
43446: PUSH
43447: LD_INT 0
43449: PUSH
43450: EMPTY
43451: LIST
43452: LIST
43453: PUSH
43454: LD_INT 3
43456: PUSH
43457: LD_INT 1
43459: NEG
43460: PUSH
43461: EMPTY
43462: LIST
43463: LIST
43464: PUSH
43465: LD_INT 3
43467: PUSH
43468: LD_INT 2
43470: NEG
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 5
43478: PUSH
43479: LD_INT 2
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: LD_INT 3
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: PUSH
43499: LD_INT 2
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: LD_INT 4
43508: PUSH
43509: LD_INT 3
43511: PUSH
43512: EMPTY
43513: LIST
43514: LIST
43515: PUSH
43516: LD_INT 4
43518: PUSH
43519: LD_INT 4
43521: PUSH
43522: EMPTY
43523: LIST
43524: LIST
43525: PUSH
43526: LD_INT 3
43528: PUSH
43529: LD_INT 4
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: PUSH
43536: LD_INT 2
43538: PUSH
43539: LD_INT 3
43541: PUSH
43542: EMPTY
43543: LIST
43544: LIST
43545: PUSH
43546: LD_INT 2
43548: PUSH
43549: LD_INT 2
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PUSH
43556: LD_INT 4
43558: PUSH
43559: LD_INT 2
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 2
43568: PUSH
43569: LD_INT 4
43571: PUSH
43572: EMPTY
43573: LIST
43574: LIST
43575: PUSH
43576: LD_INT 0
43578: PUSH
43579: LD_INT 4
43581: PUSH
43582: EMPTY
43583: LIST
43584: LIST
43585: PUSH
43586: LD_INT 0
43588: PUSH
43589: LD_INT 3
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: PUSH
43596: LD_INT 1
43598: PUSH
43599: LD_INT 4
43601: PUSH
43602: EMPTY
43603: LIST
43604: LIST
43605: PUSH
43606: LD_INT 1
43608: PUSH
43609: LD_INT 5
43611: PUSH
43612: EMPTY
43613: LIST
43614: LIST
43615: PUSH
43616: LD_INT 0
43618: PUSH
43619: LD_INT 5
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: LD_INT 4
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PUSH
43637: LD_INT 1
43639: NEG
43640: PUSH
43641: LD_INT 3
43643: PUSH
43644: EMPTY
43645: LIST
43646: LIST
43647: PUSH
43648: LD_INT 2
43650: PUSH
43651: LD_INT 5
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 2
43660: NEG
43661: PUSH
43662: LD_INT 3
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: LD_INT 0
43675: PUSH
43676: EMPTY
43677: LIST
43678: LIST
43679: PUSH
43680: LD_INT 3
43682: NEG
43683: PUSH
43684: LD_INT 1
43686: NEG
43687: PUSH
43688: EMPTY
43689: LIST
43690: LIST
43691: PUSH
43692: LD_INT 2
43694: NEG
43695: PUSH
43696: LD_INT 0
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 2
43705: NEG
43706: PUSH
43707: LD_INT 1
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 3
43716: NEG
43717: PUSH
43718: LD_INT 1
43720: PUSH
43721: EMPTY
43722: LIST
43723: LIST
43724: PUSH
43725: LD_INT 4
43727: NEG
43728: PUSH
43729: LD_INT 0
43731: PUSH
43732: EMPTY
43733: LIST
43734: LIST
43735: PUSH
43736: LD_INT 4
43738: NEG
43739: PUSH
43740: LD_INT 1
43742: NEG
43743: PUSH
43744: EMPTY
43745: LIST
43746: LIST
43747: PUSH
43748: LD_INT 4
43750: NEG
43751: PUSH
43752: LD_INT 2
43754: NEG
43755: PUSH
43756: EMPTY
43757: LIST
43758: LIST
43759: PUSH
43760: LD_INT 2
43762: NEG
43763: PUSH
43764: LD_INT 2
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: PUSH
43771: LD_INT 4
43773: NEG
43774: PUSH
43775: LD_INT 4
43777: NEG
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 4
43785: NEG
43786: PUSH
43787: LD_INT 5
43789: NEG
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 3
43797: NEG
43798: PUSH
43799: LD_INT 4
43801: NEG
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: PUSH
43807: LD_INT 3
43809: NEG
43810: PUSH
43811: LD_INT 3
43813: NEG
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 4
43821: NEG
43822: PUSH
43823: LD_INT 3
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 5
43833: NEG
43834: PUSH
43835: LD_INT 4
43837: NEG
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 5
43845: NEG
43846: PUSH
43847: LD_INT 5
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 3
43857: NEG
43858: PUSH
43859: LD_INT 5
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 5
43869: NEG
43870: PUSH
43871: LD_INT 3
43873: NEG
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: EMPTY
43880: LIST
43881: LIST
43882: LIST
43883: LIST
43884: LIST
43885: LIST
43886: LIST
43887: LIST
43888: LIST
43889: LIST
43890: LIST
43891: LIST
43892: LIST
43893: LIST
43894: LIST
43895: LIST
43896: LIST
43897: LIST
43898: LIST
43899: LIST
43900: LIST
43901: LIST
43902: LIST
43903: LIST
43904: LIST
43905: LIST
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
43926: LD_ADDR_VAR 0 30
43930: PUSH
43931: LD_INT 4
43933: PUSH
43934: LD_INT 4
43936: PUSH
43937: EMPTY
43938: LIST
43939: LIST
43940: PUSH
43941: LD_INT 4
43943: PUSH
43944: LD_INT 3
43946: PUSH
43947: EMPTY
43948: LIST
43949: LIST
43950: PUSH
43951: LD_INT 5
43953: PUSH
43954: LD_INT 4
43956: PUSH
43957: EMPTY
43958: LIST
43959: LIST
43960: PUSH
43961: LD_INT 5
43963: PUSH
43964: LD_INT 5
43966: PUSH
43967: EMPTY
43968: LIST
43969: LIST
43970: PUSH
43971: LD_INT 4
43973: PUSH
43974: LD_INT 5
43976: PUSH
43977: EMPTY
43978: LIST
43979: LIST
43980: PUSH
43981: LD_INT 3
43983: PUSH
43984: LD_INT 4
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 3
43993: PUSH
43994: LD_INT 3
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 5
44003: PUSH
44004: LD_INT 3
44006: PUSH
44007: EMPTY
44008: LIST
44009: LIST
44010: PUSH
44011: LD_INT 3
44013: PUSH
44014: LD_INT 5
44016: PUSH
44017: EMPTY
44018: LIST
44019: LIST
44020: PUSH
44021: LD_INT 0
44023: PUSH
44024: LD_INT 3
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 0
44033: PUSH
44034: LD_INT 2
44036: PUSH
44037: EMPTY
44038: LIST
44039: LIST
44040: PUSH
44041: LD_INT 1
44043: PUSH
44044: LD_INT 3
44046: PUSH
44047: EMPTY
44048: LIST
44049: LIST
44050: PUSH
44051: LD_INT 1
44053: PUSH
44054: LD_INT 4
44056: PUSH
44057: EMPTY
44058: LIST
44059: LIST
44060: PUSH
44061: LD_INT 0
44063: PUSH
44064: LD_INT 4
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 1
44073: NEG
44074: PUSH
44075: LD_INT 3
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 1
44084: NEG
44085: PUSH
44086: LD_INT 2
44088: PUSH
44089: EMPTY
44090: LIST
44091: LIST
44092: PUSH
44093: LD_INT 2
44095: PUSH
44096: LD_INT 4
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 2
44105: NEG
44106: PUSH
44107: LD_INT 2
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 0
44120: PUSH
44121: EMPTY
44122: LIST
44123: LIST
44124: PUSH
44125: LD_INT 4
44127: NEG
44128: PUSH
44129: LD_INT 1
44131: NEG
44132: PUSH
44133: EMPTY
44134: LIST
44135: LIST
44136: PUSH
44137: LD_INT 3
44139: NEG
44140: PUSH
44141: LD_INT 0
44143: PUSH
44144: EMPTY
44145: LIST
44146: LIST
44147: PUSH
44148: LD_INT 3
44150: NEG
44151: PUSH
44152: LD_INT 1
44154: PUSH
44155: EMPTY
44156: LIST
44157: LIST
44158: PUSH
44159: LD_INT 4
44161: NEG
44162: PUSH
44163: LD_INT 1
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 5
44172: NEG
44173: PUSH
44174: LD_INT 0
44176: PUSH
44177: EMPTY
44178: LIST
44179: LIST
44180: PUSH
44181: LD_INT 5
44183: NEG
44184: PUSH
44185: LD_INT 1
44187: NEG
44188: PUSH
44189: EMPTY
44190: LIST
44191: LIST
44192: PUSH
44193: LD_INT 5
44195: NEG
44196: PUSH
44197: LD_INT 2
44199: NEG
44200: PUSH
44201: EMPTY
44202: LIST
44203: LIST
44204: PUSH
44205: LD_INT 3
44207: NEG
44208: PUSH
44209: LD_INT 2
44211: PUSH
44212: EMPTY
44213: LIST
44214: LIST
44215: PUSH
44216: LD_INT 3
44218: NEG
44219: PUSH
44220: LD_INT 3
44222: NEG
44223: PUSH
44224: EMPTY
44225: LIST
44226: LIST
44227: PUSH
44228: LD_INT 3
44230: NEG
44231: PUSH
44232: LD_INT 4
44234: NEG
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 2
44242: NEG
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 2
44254: NEG
44255: PUSH
44256: LD_INT 2
44258: NEG
44259: PUSH
44260: EMPTY
44261: LIST
44262: LIST
44263: PUSH
44264: LD_INT 3
44266: NEG
44267: PUSH
44268: LD_INT 2
44270: NEG
44271: PUSH
44272: EMPTY
44273: LIST
44274: LIST
44275: PUSH
44276: LD_INT 4
44278: NEG
44279: PUSH
44280: LD_INT 3
44282: NEG
44283: PUSH
44284: EMPTY
44285: LIST
44286: LIST
44287: PUSH
44288: LD_INT 4
44290: NEG
44291: PUSH
44292: LD_INT 4
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: LD_INT 4
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: NEG
44315: PUSH
44316: LD_INT 2
44318: NEG
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 0
44326: PUSH
44327: LD_INT 4
44329: NEG
44330: PUSH
44331: EMPTY
44332: LIST
44333: LIST
44334: PUSH
44335: LD_INT 0
44337: PUSH
44338: LD_INT 5
44340: NEG
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: LD_INT 4
44351: NEG
44352: PUSH
44353: EMPTY
44354: LIST
44355: LIST
44356: PUSH
44357: LD_INT 1
44359: PUSH
44360: LD_INT 3
44362: NEG
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 0
44370: PUSH
44371: LD_INT 3
44373: NEG
44374: PUSH
44375: EMPTY
44376: LIST
44377: LIST
44378: PUSH
44379: LD_INT 1
44381: NEG
44382: PUSH
44383: LD_INT 4
44385: NEG
44386: PUSH
44387: EMPTY
44388: LIST
44389: LIST
44390: PUSH
44391: LD_INT 1
44393: NEG
44394: PUSH
44395: LD_INT 5
44397: NEG
44398: PUSH
44399: EMPTY
44400: LIST
44401: LIST
44402: PUSH
44403: LD_INT 2
44405: PUSH
44406: LD_INT 3
44408: NEG
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 2
44416: NEG
44417: PUSH
44418: LD_INT 5
44420: NEG
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: LIST
44430: LIST
44431: LIST
44432: LIST
44433: LIST
44434: LIST
44435: LIST
44436: LIST
44437: LIST
44438: LIST
44439: LIST
44440: LIST
44441: LIST
44442: LIST
44443: LIST
44444: LIST
44445: LIST
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44473: LD_ADDR_VAR 0 31
44477: PUSH
44478: LD_INT 0
44480: PUSH
44481: LD_INT 4
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 0
44490: PUSH
44491: LD_INT 3
44493: PUSH
44494: EMPTY
44495: LIST
44496: LIST
44497: PUSH
44498: LD_INT 1
44500: PUSH
44501: LD_INT 4
44503: PUSH
44504: EMPTY
44505: LIST
44506: LIST
44507: PUSH
44508: LD_INT 1
44510: PUSH
44511: LD_INT 5
44513: PUSH
44514: EMPTY
44515: LIST
44516: LIST
44517: PUSH
44518: LD_INT 0
44520: PUSH
44521: LD_INT 5
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 1
44530: NEG
44531: PUSH
44532: LD_INT 4
44534: PUSH
44535: EMPTY
44536: LIST
44537: LIST
44538: PUSH
44539: LD_INT 1
44541: NEG
44542: PUSH
44543: LD_INT 3
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 2
44552: PUSH
44553: LD_INT 5
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 2
44562: NEG
44563: PUSH
44564: LD_INT 3
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 3
44573: NEG
44574: PUSH
44575: LD_INT 0
44577: PUSH
44578: EMPTY
44579: LIST
44580: LIST
44581: PUSH
44582: LD_INT 3
44584: NEG
44585: PUSH
44586: LD_INT 1
44588: NEG
44589: PUSH
44590: EMPTY
44591: LIST
44592: LIST
44593: PUSH
44594: LD_INT 2
44596: NEG
44597: PUSH
44598: LD_INT 0
44600: PUSH
44601: EMPTY
44602: LIST
44603: LIST
44604: PUSH
44605: LD_INT 2
44607: NEG
44608: PUSH
44609: LD_INT 1
44611: PUSH
44612: EMPTY
44613: LIST
44614: LIST
44615: PUSH
44616: LD_INT 3
44618: NEG
44619: PUSH
44620: LD_INT 1
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 4
44629: NEG
44630: PUSH
44631: LD_INT 0
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 4
44640: NEG
44641: PUSH
44642: LD_INT 1
44644: NEG
44645: PUSH
44646: EMPTY
44647: LIST
44648: LIST
44649: PUSH
44650: LD_INT 4
44652: NEG
44653: PUSH
44654: LD_INT 2
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 2
44664: NEG
44665: PUSH
44666: LD_INT 2
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 4
44675: NEG
44676: PUSH
44677: LD_INT 4
44679: NEG
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: PUSH
44685: LD_INT 4
44687: NEG
44688: PUSH
44689: LD_INT 5
44691: NEG
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 3
44699: NEG
44700: PUSH
44701: LD_INT 4
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 3
44711: NEG
44712: PUSH
44713: LD_INT 3
44715: NEG
44716: PUSH
44717: EMPTY
44718: LIST
44719: LIST
44720: PUSH
44721: LD_INT 4
44723: NEG
44724: PUSH
44725: LD_INT 3
44727: NEG
44728: PUSH
44729: EMPTY
44730: LIST
44731: LIST
44732: PUSH
44733: LD_INT 5
44735: NEG
44736: PUSH
44737: LD_INT 4
44739: NEG
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 5
44747: NEG
44748: PUSH
44749: LD_INT 5
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 3
44759: NEG
44760: PUSH
44761: LD_INT 5
44763: NEG
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: LD_INT 5
44771: NEG
44772: PUSH
44773: LD_INT 3
44775: NEG
44776: PUSH
44777: EMPTY
44778: LIST
44779: LIST
44780: PUSH
44781: LD_INT 0
44783: PUSH
44784: LD_INT 3
44786: NEG
44787: PUSH
44788: EMPTY
44789: LIST
44790: LIST
44791: PUSH
44792: LD_INT 0
44794: PUSH
44795: LD_INT 4
44797: NEG
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 1
44805: PUSH
44806: LD_INT 3
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 1
44816: PUSH
44817: LD_INT 2
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 0
44827: PUSH
44828: LD_INT 2
44830: NEG
44831: PUSH
44832: EMPTY
44833: LIST
44834: LIST
44835: PUSH
44836: LD_INT 1
44838: NEG
44839: PUSH
44840: LD_INT 3
44842: NEG
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: PUSH
44848: LD_INT 1
44850: NEG
44851: PUSH
44852: LD_INT 4
44854: NEG
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 2
44862: PUSH
44863: LD_INT 2
44865: NEG
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 2
44873: NEG
44874: PUSH
44875: LD_INT 4
44877: NEG
44878: PUSH
44879: EMPTY
44880: LIST
44881: LIST
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 4
44895: PUSH
44896: LD_INT 1
44898: NEG
44899: PUSH
44900: EMPTY
44901: LIST
44902: LIST
44903: PUSH
44904: LD_INT 5
44906: PUSH
44907: LD_INT 0
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 5
44916: PUSH
44917: LD_INT 1
44919: PUSH
44920: EMPTY
44921: LIST
44922: LIST
44923: PUSH
44924: LD_INT 4
44926: PUSH
44927: LD_INT 1
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 3
44936: PUSH
44937: LD_INT 0
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 3
44946: PUSH
44947: LD_INT 1
44949: NEG
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 3
44957: PUSH
44958: LD_INT 2
44960: NEG
44961: PUSH
44962: EMPTY
44963: LIST
44964: LIST
44965: PUSH
44966: LD_INT 5
44968: PUSH
44969: LD_INT 2
44971: PUSH
44972: EMPTY
44973: LIST
44974: LIST
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: LIST
44980: LIST
44981: LIST
44982: LIST
44983: LIST
44984: LIST
44985: LIST
44986: LIST
44987: LIST
44988: LIST
44989: LIST
44990: LIST
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: LIST
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45023: LD_ADDR_VAR 0 32
45027: PUSH
45028: LD_INT 4
45030: NEG
45031: PUSH
45032: LD_INT 0
45034: PUSH
45035: EMPTY
45036: LIST
45037: LIST
45038: PUSH
45039: LD_INT 4
45041: NEG
45042: PUSH
45043: LD_INT 1
45045: NEG
45046: PUSH
45047: EMPTY
45048: LIST
45049: LIST
45050: PUSH
45051: LD_INT 3
45053: NEG
45054: PUSH
45055: LD_INT 0
45057: PUSH
45058: EMPTY
45059: LIST
45060: LIST
45061: PUSH
45062: LD_INT 3
45064: NEG
45065: PUSH
45066: LD_INT 1
45068: PUSH
45069: EMPTY
45070: LIST
45071: LIST
45072: PUSH
45073: LD_INT 4
45075: NEG
45076: PUSH
45077: LD_INT 1
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 5
45086: NEG
45087: PUSH
45088: LD_INT 0
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 5
45097: NEG
45098: PUSH
45099: LD_INT 1
45101: NEG
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: LD_INT 5
45109: NEG
45110: PUSH
45111: LD_INT 2
45113: NEG
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: LD_INT 3
45121: NEG
45122: PUSH
45123: LD_INT 2
45125: PUSH
45126: EMPTY
45127: LIST
45128: LIST
45129: PUSH
45130: LD_INT 3
45132: NEG
45133: PUSH
45134: LD_INT 3
45136: NEG
45137: PUSH
45138: EMPTY
45139: LIST
45140: LIST
45141: PUSH
45142: LD_INT 3
45144: NEG
45145: PUSH
45146: LD_INT 4
45148: NEG
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: LD_INT 2
45156: NEG
45157: PUSH
45158: LD_INT 3
45160: NEG
45161: PUSH
45162: EMPTY
45163: LIST
45164: LIST
45165: PUSH
45166: LD_INT 2
45168: NEG
45169: PUSH
45170: LD_INT 2
45172: NEG
45173: PUSH
45174: EMPTY
45175: LIST
45176: LIST
45177: PUSH
45178: LD_INT 3
45180: NEG
45181: PUSH
45182: LD_INT 2
45184: NEG
45185: PUSH
45186: EMPTY
45187: LIST
45188: LIST
45189: PUSH
45190: LD_INT 4
45192: NEG
45193: PUSH
45194: LD_INT 3
45196: NEG
45197: PUSH
45198: EMPTY
45199: LIST
45200: LIST
45201: PUSH
45202: LD_INT 4
45204: NEG
45205: PUSH
45206: LD_INT 4
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 2
45216: NEG
45217: PUSH
45218: LD_INT 4
45220: NEG
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 4
45228: NEG
45229: PUSH
45230: LD_INT 2
45232: NEG
45233: PUSH
45234: EMPTY
45235: LIST
45236: LIST
45237: PUSH
45238: LD_INT 0
45240: PUSH
45241: LD_INT 4
45243: NEG
45244: PUSH
45245: EMPTY
45246: LIST
45247: LIST
45248: PUSH
45249: LD_INT 0
45251: PUSH
45252: LD_INT 5
45254: NEG
45255: PUSH
45256: EMPTY
45257: LIST
45258: LIST
45259: PUSH
45260: LD_INT 1
45262: PUSH
45263: LD_INT 4
45265: NEG
45266: PUSH
45267: EMPTY
45268: LIST
45269: LIST
45270: PUSH
45271: LD_INT 1
45273: PUSH
45274: LD_INT 3
45276: NEG
45277: PUSH
45278: EMPTY
45279: LIST
45280: LIST
45281: PUSH
45282: LD_INT 0
45284: PUSH
45285: LD_INT 3
45287: NEG
45288: PUSH
45289: EMPTY
45290: LIST
45291: LIST
45292: PUSH
45293: LD_INT 1
45295: NEG
45296: PUSH
45297: LD_INT 4
45299: NEG
45300: PUSH
45301: EMPTY
45302: LIST
45303: LIST
45304: PUSH
45305: LD_INT 1
45307: NEG
45308: PUSH
45309: LD_INT 5
45311: NEG
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 2
45319: PUSH
45320: LD_INT 3
45322: NEG
45323: PUSH
45324: EMPTY
45325: LIST
45326: LIST
45327: PUSH
45328: LD_INT 2
45330: NEG
45331: PUSH
45332: LD_INT 5
45334: NEG
45335: PUSH
45336: EMPTY
45337: LIST
45338: LIST
45339: PUSH
45340: LD_INT 3
45342: PUSH
45343: LD_INT 0
45345: PUSH
45346: EMPTY
45347: LIST
45348: LIST
45349: PUSH
45350: LD_INT 3
45352: PUSH
45353: LD_INT 1
45355: NEG
45356: PUSH
45357: EMPTY
45358: LIST
45359: LIST
45360: PUSH
45361: LD_INT 4
45363: PUSH
45364: LD_INT 0
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: PUSH
45371: LD_INT 4
45373: PUSH
45374: LD_INT 1
45376: PUSH
45377: EMPTY
45378: LIST
45379: LIST
45380: PUSH
45381: LD_INT 3
45383: PUSH
45384: LD_INT 1
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 2
45393: PUSH
45394: LD_INT 0
45396: PUSH
45397: EMPTY
45398: LIST
45399: LIST
45400: PUSH
45401: LD_INT 2
45403: PUSH
45404: LD_INT 1
45406: NEG
45407: PUSH
45408: EMPTY
45409: LIST
45410: LIST
45411: PUSH
45412: LD_INT 2
45414: PUSH
45415: LD_INT 2
45417: NEG
45418: PUSH
45419: EMPTY
45420: LIST
45421: LIST
45422: PUSH
45423: LD_INT 4
45425: PUSH
45426: LD_INT 2
45428: PUSH
45429: EMPTY
45430: LIST
45431: LIST
45432: PUSH
45433: LD_INT 4
45435: PUSH
45436: LD_INT 4
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 4
45445: PUSH
45446: LD_INT 3
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: PUSH
45453: LD_INT 5
45455: PUSH
45456: LD_INT 4
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: PUSH
45463: LD_INT 5
45465: PUSH
45466: LD_INT 5
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 4
45475: PUSH
45476: LD_INT 5
45478: PUSH
45479: EMPTY
45480: LIST
45481: LIST
45482: PUSH
45483: LD_INT 3
45485: PUSH
45486: LD_INT 4
45488: PUSH
45489: EMPTY
45490: LIST
45491: LIST
45492: PUSH
45493: LD_INT 3
45495: PUSH
45496: LD_INT 3
45498: PUSH
45499: EMPTY
45500: LIST
45501: LIST
45502: PUSH
45503: LD_INT 5
45505: PUSH
45506: LD_INT 3
45508: PUSH
45509: EMPTY
45510: LIST
45511: LIST
45512: PUSH
45513: LD_INT 3
45515: PUSH
45516: LD_INT 5
45518: PUSH
45519: EMPTY
45520: LIST
45521: LIST
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45570: LD_ADDR_VAR 0 33
45574: PUSH
45575: LD_INT 4
45577: NEG
45578: PUSH
45579: LD_INT 4
45581: NEG
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: PUSH
45587: LD_INT 4
45589: NEG
45590: PUSH
45591: LD_INT 5
45593: NEG
45594: PUSH
45595: EMPTY
45596: LIST
45597: LIST
45598: PUSH
45599: LD_INT 3
45601: NEG
45602: PUSH
45603: LD_INT 4
45605: NEG
45606: PUSH
45607: EMPTY
45608: LIST
45609: LIST
45610: PUSH
45611: LD_INT 3
45613: NEG
45614: PUSH
45615: LD_INT 3
45617: NEG
45618: PUSH
45619: EMPTY
45620: LIST
45621: LIST
45622: PUSH
45623: LD_INT 4
45625: NEG
45626: PUSH
45627: LD_INT 3
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 5
45637: NEG
45638: PUSH
45639: LD_INT 4
45641: NEG
45642: PUSH
45643: EMPTY
45644: LIST
45645: LIST
45646: PUSH
45647: LD_INT 5
45649: NEG
45650: PUSH
45651: LD_INT 5
45653: NEG
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: PUSH
45659: LD_INT 3
45661: NEG
45662: PUSH
45663: LD_INT 5
45665: NEG
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: LD_INT 5
45673: NEG
45674: PUSH
45675: LD_INT 3
45677: NEG
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 0
45685: PUSH
45686: LD_INT 3
45688: NEG
45689: PUSH
45690: EMPTY
45691: LIST
45692: LIST
45693: PUSH
45694: LD_INT 0
45696: PUSH
45697: LD_INT 4
45699: NEG
45700: PUSH
45701: EMPTY
45702: LIST
45703: LIST
45704: PUSH
45705: LD_INT 1
45707: PUSH
45708: LD_INT 3
45710: NEG
45711: PUSH
45712: EMPTY
45713: LIST
45714: LIST
45715: PUSH
45716: LD_INT 1
45718: PUSH
45719: LD_INT 2
45721: NEG
45722: PUSH
45723: EMPTY
45724: LIST
45725: LIST
45726: PUSH
45727: LD_INT 0
45729: PUSH
45730: LD_INT 2
45732: NEG
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: PUSH
45738: LD_INT 1
45740: NEG
45741: PUSH
45742: LD_INT 3
45744: NEG
45745: PUSH
45746: EMPTY
45747: LIST
45748: LIST
45749: PUSH
45750: LD_INT 1
45752: NEG
45753: PUSH
45754: LD_INT 4
45756: NEG
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: LD_INT 2
45764: PUSH
45765: LD_INT 2
45767: NEG
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PUSH
45773: LD_INT 2
45775: NEG
45776: PUSH
45777: LD_INT 4
45779: NEG
45780: PUSH
45781: EMPTY
45782: LIST
45783: LIST
45784: PUSH
45785: LD_INT 4
45787: PUSH
45788: LD_INT 0
45790: PUSH
45791: EMPTY
45792: LIST
45793: LIST
45794: PUSH
45795: LD_INT 4
45797: PUSH
45798: LD_INT 1
45800: NEG
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 5
45808: PUSH
45809: LD_INT 0
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 5
45818: PUSH
45819: LD_INT 1
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 4
45828: PUSH
45829: LD_INT 1
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 3
45838: PUSH
45839: LD_INT 0
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 3
45848: PUSH
45849: LD_INT 1
45851: NEG
45852: PUSH
45853: EMPTY
45854: LIST
45855: LIST
45856: PUSH
45857: LD_INT 3
45859: PUSH
45860: LD_INT 2
45862: NEG
45863: PUSH
45864: EMPTY
45865: LIST
45866: LIST
45867: PUSH
45868: LD_INT 5
45870: PUSH
45871: LD_INT 2
45873: PUSH
45874: EMPTY
45875: LIST
45876: LIST
45877: PUSH
45878: LD_INT 3
45880: PUSH
45881: LD_INT 3
45883: PUSH
45884: EMPTY
45885: LIST
45886: LIST
45887: PUSH
45888: LD_INT 3
45890: PUSH
45891: LD_INT 2
45893: PUSH
45894: EMPTY
45895: LIST
45896: LIST
45897: PUSH
45898: LD_INT 4
45900: PUSH
45901: LD_INT 3
45903: PUSH
45904: EMPTY
45905: LIST
45906: LIST
45907: PUSH
45908: LD_INT 4
45910: PUSH
45911: LD_INT 4
45913: PUSH
45914: EMPTY
45915: LIST
45916: LIST
45917: PUSH
45918: LD_INT 3
45920: PUSH
45921: LD_INT 4
45923: PUSH
45924: EMPTY
45925: LIST
45926: LIST
45927: PUSH
45928: LD_INT 2
45930: PUSH
45931: LD_INT 3
45933: PUSH
45934: EMPTY
45935: LIST
45936: LIST
45937: PUSH
45938: LD_INT 2
45940: PUSH
45941: LD_INT 2
45943: PUSH
45944: EMPTY
45945: LIST
45946: LIST
45947: PUSH
45948: LD_INT 4
45950: PUSH
45951: LD_INT 2
45953: PUSH
45954: EMPTY
45955: LIST
45956: LIST
45957: PUSH
45958: LD_INT 2
45960: PUSH
45961: LD_INT 4
45963: PUSH
45964: EMPTY
45965: LIST
45966: LIST
45967: PUSH
45968: LD_INT 0
45970: PUSH
45971: LD_INT 4
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 0
45980: PUSH
45981: LD_INT 3
45983: PUSH
45984: EMPTY
45985: LIST
45986: LIST
45987: PUSH
45988: LD_INT 1
45990: PUSH
45991: LD_INT 4
45993: PUSH
45994: EMPTY
45995: LIST
45996: LIST
45997: PUSH
45998: LD_INT 1
46000: PUSH
46001: LD_INT 5
46003: PUSH
46004: EMPTY
46005: LIST
46006: LIST
46007: PUSH
46008: LD_INT 0
46010: PUSH
46011: LD_INT 5
46013: PUSH
46014: EMPTY
46015: LIST
46016: LIST
46017: PUSH
46018: LD_INT 1
46020: NEG
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 1
46031: NEG
46032: PUSH
46033: LD_INT 3
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: PUSH
46040: LD_INT 2
46042: PUSH
46043: LD_INT 5
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 2
46052: NEG
46053: PUSH
46054: LD_INT 3
46056: PUSH
46057: EMPTY
46058: LIST
46059: LIST
46060: PUSH
46061: EMPTY
46062: LIST
46063: LIST
46064: LIST
46065: LIST
46066: LIST
46067: LIST
46068: LIST
46069: LIST
46070: LIST
46071: LIST
46072: LIST
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: LIST
46078: LIST
46079: LIST
46080: LIST
46081: LIST
46082: LIST
46083: LIST
46084: LIST
46085: LIST
46086: LIST
46087: LIST
46088: LIST
46089: LIST
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: LIST
46100: LIST
46101: LIST
46102: LIST
46103: LIST
46104: LIST
46105: LIST
46106: LIST
46107: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46108: LD_ADDR_VAR 0 34
46112: PUSH
46113: LD_INT 0
46115: PUSH
46116: LD_INT 4
46118: NEG
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PUSH
46124: LD_INT 0
46126: PUSH
46127: LD_INT 5
46129: NEG
46130: PUSH
46131: EMPTY
46132: LIST
46133: LIST
46134: PUSH
46135: LD_INT 1
46137: PUSH
46138: LD_INT 4
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 1
46148: PUSH
46149: LD_INT 3
46151: NEG
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: PUSH
46157: LD_INT 0
46159: PUSH
46160: LD_INT 3
46162: NEG
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 1
46170: NEG
46171: PUSH
46172: LD_INT 4
46174: NEG
46175: PUSH
46176: EMPTY
46177: LIST
46178: LIST
46179: PUSH
46180: LD_INT 1
46182: NEG
46183: PUSH
46184: LD_INT 5
46186: NEG
46187: PUSH
46188: EMPTY
46189: LIST
46190: LIST
46191: PUSH
46192: LD_INT 2
46194: PUSH
46195: LD_INT 3
46197: NEG
46198: PUSH
46199: EMPTY
46200: LIST
46201: LIST
46202: PUSH
46203: LD_INT 2
46205: NEG
46206: PUSH
46207: LD_INT 5
46209: NEG
46210: PUSH
46211: EMPTY
46212: LIST
46213: LIST
46214: PUSH
46215: LD_INT 3
46217: PUSH
46218: LD_INT 0
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 3
46227: PUSH
46228: LD_INT 1
46230: NEG
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 4
46238: PUSH
46239: LD_INT 0
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 4
46248: PUSH
46249: LD_INT 1
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 3
46258: PUSH
46259: LD_INT 1
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 2
46268: PUSH
46269: LD_INT 0
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 2
46278: PUSH
46279: LD_INT 1
46281: NEG
46282: PUSH
46283: EMPTY
46284: LIST
46285: LIST
46286: PUSH
46287: LD_INT 2
46289: PUSH
46290: LD_INT 2
46292: NEG
46293: PUSH
46294: EMPTY
46295: LIST
46296: LIST
46297: PUSH
46298: LD_INT 4
46300: PUSH
46301: LD_INT 2
46303: PUSH
46304: EMPTY
46305: LIST
46306: LIST
46307: PUSH
46308: LD_INT 4
46310: PUSH
46311: LD_INT 4
46313: PUSH
46314: EMPTY
46315: LIST
46316: LIST
46317: PUSH
46318: LD_INT 4
46320: PUSH
46321: LD_INT 3
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 5
46330: PUSH
46331: LD_INT 4
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: PUSH
46338: LD_INT 5
46340: PUSH
46341: LD_INT 5
46343: PUSH
46344: EMPTY
46345: LIST
46346: LIST
46347: PUSH
46348: LD_INT 4
46350: PUSH
46351: LD_INT 5
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 3
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 3
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: EMPTY
46375: LIST
46376: LIST
46377: PUSH
46378: LD_INT 5
46380: PUSH
46381: LD_INT 3
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PUSH
46388: LD_INT 3
46390: PUSH
46391: LD_INT 5
46393: PUSH
46394: EMPTY
46395: LIST
46396: LIST
46397: PUSH
46398: LD_INT 0
46400: PUSH
46401: LD_INT 3
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: PUSH
46408: LD_INT 0
46410: PUSH
46411: LD_INT 2
46413: PUSH
46414: EMPTY
46415: LIST
46416: LIST
46417: PUSH
46418: LD_INT 1
46420: PUSH
46421: LD_INT 3
46423: PUSH
46424: EMPTY
46425: LIST
46426: LIST
46427: PUSH
46428: LD_INT 1
46430: PUSH
46431: LD_INT 4
46433: PUSH
46434: EMPTY
46435: LIST
46436: LIST
46437: PUSH
46438: LD_INT 0
46440: PUSH
46441: LD_INT 4
46443: PUSH
46444: EMPTY
46445: LIST
46446: LIST
46447: PUSH
46448: LD_INT 1
46450: NEG
46451: PUSH
46452: LD_INT 3
46454: PUSH
46455: EMPTY
46456: LIST
46457: LIST
46458: PUSH
46459: LD_INT 1
46461: NEG
46462: PUSH
46463: LD_INT 2
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 2
46472: PUSH
46473: LD_INT 4
46475: PUSH
46476: EMPTY
46477: LIST
46478: LIST
46479: PUSH
46480: LD_INT 2
46482: NEG
46483: PUSH
46484: LD_INT 2
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PUSH
46491: LD_INT 4
46493: NEG
46494: PUSH
46495: LD_INT 0
46497: PUSH
46498: EMPTY
46499: LIST
46500: LIST
46501: PUSH
46502: LD_INT 4
46504: NEG
46505: PUSH
46506: LD_INT 1
46508: NEG
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: PUSH
46514: LD_INT 3
46516: NEG
46517: PUSH
46518: LD_INT 0
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PUSH
46525: LD_INT 3
46527: NEG
46528: PUSH
46529: LD_INT 1
46531: PUSH
46532: EMPTY
46533: LIST
46534: LIST
46535: PUSH
46536: LD_INT 4
46538: NEG
46539: PUSH
46540: LD_INT 1
46542: PUSH
46543: EMPTY
46544: LIST
46545: LIST
46546: PUSH
46547: LD_INT 5
46549: NEG
46550: PUSH
46551: LD_INT 0
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 5
46560: NEG
46561: PUSH
46562: LD_INT 1
46564: NEG
46565: PUSH
46566: EMPTY
46567: LIST
46568: LIST
46569: PUSH
46570: LD_INT 5
46572: NEG
46573: PUSH
46574: LD_INT 2
46576: NEG
46577: PUSH
46578: EMPTY
46579: LIST
46580: LIST
46581: PUSH
46582: LD_INT 3
46584: NEG
46585: PUSH
46586: LD_INT 2
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: ST_TO_ADDR
// end ; end ;
46640: GO 46643
46642: POP
// case btype of b_depot , b_warehouse :
46643: LD_VAR 0 1
46647: PUSH
46648: LD_INT 0
46650: DOUBLE
46651: EQUAL
46652: IFTRUE 46662
46654: LD_INT 1
46656: DOUBLE
46657: EQUAL
46658: IFTRUE 46662
46660: GO 46863
46662: POP
// case nation of nation_american :
46663: LD_VAR 0 5
46667: PUSH
46668: LD_INT 1
46670: DOUBLE
46671: EQUAL
46672: IFTRUE 46676
46674: GO 46732
46676: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
46677: LD_ADDR_VAR 0 9
46681: PUSH
46682: LD_VAR 0 11
46686: PUSH
46687: LD_VAR 0 12
46691: PUSH
46692: LD_VAR 0 13
46696: PUSH
46697: LD_VAR 0 14
46701: PUSH
46702: LD_VAR 0 15
46706: PUSH
46707: LD_VAR 0 16
46711: PUSH
46712: EMPTY
46713: LIST
46714: LIST
46715: LIST
46716: LIST
46717: LIST
46718: LIST
46719: PUSH
46720: LD_VAR 0 4
46724: PUSH
46725: LD_INT 1
46727: PLUS
46728: ARRAY
46729: ST_TO_ADDR
46730: GO 46861
46732: LD_INT 2
46734: DOUBLE
46735: EQUAL
46736: IFTRUE 46740
46738: GO 46796
46740: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
46741: LD_ADDR_VAR 0 9
46745: PUSH
46746: LD_VAR 0 17
46750: PUSH
46751: LD_VAR 0 18
46755: PUSH
46756: LD_VAR 0 19
46760: PUSH
46761: LD_VAR 0 20
46765: PUSH
46766: LD_VAR 0 21
46770: PUSH
46771: LD_VAR 0 22
46775: PUSH
46776: EMPTY
46777: LIST
46778: LIST
46779: LIST
46780: LIST
46781: LIST
46782: LIST
46783: PUSH
46784: LD_VAR 0 4
46788: PUSH
46789: LD_INT 1
46791: PLUS
46792: ARRAY
46793: ST_TO_ADDR
46794: GO 46861
46796: LD_INT 3
46798: DOUBLE
46799: EQUAL
46800: IFTRUE 46804
46802: GO 46860
46804: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
46805: LD_ADDR_VAR 0 9
46809: PUSH
46810: LD_VAR 0 23
46814: PUSH
46815: LD_VAR 0 24
46819: PUSH
46820: LD_VAR 0 25
46824: PUSH
46825: LD_VAR 0 26
46829: PUSH
46830: LD_VAR 0 27
46834: PUSH
46835: LD_VAR 0 28
46839: PUSH
46840: EMPTY
46841: LIST
46842: LIST
46843: LIST
46844: LIST
46845: LIST
46846: LIST
46847: PUSH
46848: LD_VAR 0 4
46852: PUSH
46853: LD_INT 1
46855: PLUS
46856: ARRAY
46857: ST_TO_ADDR
46858: GO 46861
46860: POP
46861: GO 47416
46863: LD_INT 2
46865: DOUBLE
46866: EQUAL
46867: IFTRUE 46877
46869: LD_INT 3
46871: DOUBLE
46872: EQUAL
46873: IFTRUE 46877
46875: GO 46933
46877: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
46878: LD_ADDR_VAR 0 9
46882: PUSH
46883: LD_VAR 0 29
46887: PUSH
46888: LD_VAR 0 30
46892: PUSH
46893: LD_VAR 0 31
46897: PUSH
46898: LD_VAR 0 32
46902: PUSH
46903: LD_VAR 0 33
46907: PUSH
46908: LD_VAR 0 34
46912: PUSH
46913: EMPTY
46914: LIST
46915: LIST
46916: LIST
46917: LIST
46918: LIST
46919: LIST
46920: PUSH
46921: LD_VAR 0 4
46925: PUSH
46926: LD_INT 1
46928: PLUS
46929: ARRAY
46930: ST_TO_ADDR
46931: GO 47416
46933: LD_INT 16
46935: DOUBLE
46936: EQUAL
46937: IFTRUE 46995
46939: LD_INT 17
46941: DOUBLE
46942: EQUAL
46943: IFTRUE 46995
46945: LD_INT 18
46947: DOUBLE
46948: EQUAL
46949: IFTRUE 46995
46951: LD_INT 19
46953: DOUBLE
46954: EQUAL
46955: IFTRUE 46995
46957: LD_INT 22
46959: DOUBLE
46960: EQUAL
46961: IFTRUE 46995
46963: LD_INT 20
46965: DOUBLE
46966: EQUAL
46967: IFTRUE 46995
46969: LD_INT 21
46971: DOUBLE
46972: EQUAL
46973: IFTRUE 46995
46975: LD_INT 23
46977: DOUBLE
46978: EQUAL
46979: IFTRUE 46995
46981: LD_INT 24
46983: DOUBLE
46984: EQUAL
46985: IFTRUE 46995
46987: LD_INT 25
46989: DOUBLE
46990: EQUAL
46991: IFTRUE 46995
46993: GO 47051
46995: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
46996: LD_ADDR_VAR 0 9
47000: PUSH
47001: LD_VAR 0 35
47005: PUSH
47006: LD_VAR 0 36
47010: PUSH
47011: LD_VAR 0 37
47015: PUSH
47016: LD_VAR 0 38
47020: PUSH
47021: LD_VAR 0 39
47025: PUSH
47026: LD_VAR 0 40
47030: PUSH
47031: EMPTY
47032: LIST
47033: LIST
47034: LIST
47035: LIST
47036: LIST
47037: LIST
47038: PUSH
47039: LD_VAR 0 4
47043: PUSH
47044: LD_INT 1
47046: PLUS
47047: ARRAY
47048: ST_TO_ADDR
47049: GO 47416
47051: LD_INT 6
47053: DOUBLE
47054: EQUAL
47055: IFTRUE 47107
47057: LD_INT 7
47059: DOUBLE
47060: EQUAL
47061: IFTRUE 47107
47063: LD_INT 8
47065: DOUBLE
47066: EQUAL
47067: IFTRUE 47107
47069: LD_INT 13
47071: DOUBLE
47072: EQUAL
47073: IFTRUE 47107
47075: LD_INT 12
47077: DOUBLE
47078: EQUAL
47079: IFTRUE 47107
47081: LD_INT 15
47083: DOUBLE
47084: EQUAL
47085: IFTRUE 47107
47087: LD_INT 11
47089: DOUBLE
47090: EQUAL
47091: IFTRUE 47107
47093: LD_INT 14
47095: DOUBLE
47096: EQUAL
47097: IFTRUE 47107
47099: LD_INT 10
47101: DOUBLE
47102: EQUAL
47103: IFTRUE 47107
47105: GO 47163
47107: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47108: LD_ADDR_VAR 0 9
47112: PUSH
47113: LD_VAR 0 41
47117: PUSH
47118: LD_VAR 0 42
47122: PUSH
47123: LD_VAR 0 43
47127: PUSH
47128: LD_VAR 0 44
47132: PUSH
47133: LD_VAR 0 45
47137: PUSH
47138: LD_VAR 0 46
47142: PUSH
47143: EMPTY
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: PUSH
47151: LD_VAR 0 4
47155: PUSH
47156: LD_INT 1
47158: PLUS
47159: ARRAY
47160: ST_TO_ADDR
47161: GO 47416
47163: LD_INT 36
47165: DOUBLE
47166: EQUAL
47167: IFTRUE 47171
47169: GO 47227
47171: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47172: LD_ADDR_VAR 0 9
47176: PUSH
47177: LD_VAR 0 47
47181: PUSH
47182: LD_VAR 0 48
47186: PUSH
47187: LD_VAR 0 49
47191: PUSH
47192: LD_VAR 0 50
47196: PUSH
47197: LD_VAR 0 51
47201: PUSH
47202: LD_VAR 0 52
47206: PUSH
47207: EMPTY
47208: LIST
47209: LIST
47210: LIST
47211: LIST
47212: LIST
47213: LIST
47214: PUSH
47215: LD_VAR 0 4
47219: PUSH
47220: LD_INT 1
47222: PLUS
47223: ARRAY
47224: ST_TO_ADDR
47225: GO 47416
47227: LD_INT 4
47229: DOUBLE
47230: EQUAL
47231: IFTRUE 47253
47233: LD_INT 5
47235: DOUBLE
47236: EQUAL
47237: IFTRUE 47253
47239: LD_INT 34
47241: DOUBLE
47242: EQUAL
47243: IFTRUE 47253
47245: LD_INT 37
47247: DOUBLE
47248: EQUAL
47249: IFTRUE 47253
47251: GO 47309
47253: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47254: LD_ADDR_VAR 0 9
47258: PUSH
47259: LD_VAR 0 53
47263: PUSH
47264: LD_VAR 0 54
47268: PUSH
47269: LD_VAR 0 55
47273: PUSH
47274: LD_VAR 0 56
47278: PUSH
47279: LD_VAR 0 57
47283: PUSH
47284: LD_VAR 0 58
47288: PUSH
47289: EMPTY
47290: LIST
47291: LIST
47292: LIST
47293: LIST
47294: LIST
47295: LIST
47296: PUSH
47297: LD_VAR 0 4
47301: PUSH
47302: LD_INT 1
47304: PLUS
47305: ARRAY
47306: ST_TO_ADDR
47307: GO 47416
47309: LD_INT 31
47311: DOUBLE
47312: EQUAL
47313: IFTRUE 47359
47315: LD_INT 32
47317: DOUBLE
47318: EQUAL
47319: IFTRUE 47359
47321: LD_INT 33
47323: DOUBLE
47324: EQUAL
47325: IFTRUE 47359
47327: LD_INT 27
47329: DOUBLE
47330: EQUAL
47331: IFTRUE 47359
47333: LD_INT 26
47335: DOUBLE
47336: EQUAL
47337: IFTRUE 47359
47339: LD_INT 28
47341: DOUBLE
47342: EQUAL
47343: IFTRUE 47359
47345: LD_INT 29
47347: DOUBLE
47348: EQUAL
47349: IFTRUE 47359
47351: LD_INT 30
47353: DOUBLE
47354: EQUAL
47355: IFTRUE 47359
47357: GO 47415
47359: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47360: LD_ADDR_VAR 0 9
47364: PUSH
47365: LD_VAR 0 59
47369: PUSH
47370: LD_VAR 0 60
47374: PUSH
47375: LD_VAR 0 61
47379: PUSH
47380: LD_VAR 0 62
47384: PUSH
47385: LD_VAR 0 63
47389: PUSH
47390: LD_VAR 0 64
47394: PUSH
47395: EMPTY
47396: LIST
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: PUSH
47403: LD_VAR 0 4
47407: PUSH
47408: LD_INT 1
47410: PLUS
47411: ARRAY
47412: ST_TO_ADDR
47413: GO 47416
47415: POP
// temp_list2 = [ ] ;
47416: LD_ADDR_VAR 0 10
47420: PUSH
47421: EMPTY
47422: ST_TO_ADDR
// for i in temp_list do
47423: LD_ADDR_VAR 0 8
47427: PUSH
47428: LD_VAR 0 9
47432: PUSH
47433: FOR_IN
47434: IFFALSE 47486
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47436: LD_ADDR_VAR 0 10
47440: PUSH
47441: LD_VAR 0 10
47445: PUSH
47446: LD_VAR 0 8
47450: PUSH
47451: LD_INT 1
47453: ARRAY
47454: PUSH
47455: LD_VAR 0 2
47459: PLUS
47460: PUSH
47461: LD_VAR 0 8
47465: PUSH
47466: LD_INT 2
47468: ARRAY
47469: PUSH
47470: LD_VAR 0 3
47474: PLUS
47475: PUSH
47476: EMPTY
47477: LIST
47478: LIST
47479: PUSH
47480: EMPTY
47481: LIST
47482: ADD
47483: ST_TO_ADDR
47484: GO 47433
47486: POP
47487: POP
// result = temp_list2 ;
47488: LD_ADDR_VAR 0 7
47492: PUSH
47493: LD_VAR 0 10
47497: ST_TO_ADDR
// end ;
47498: LD_VAR 0 7
47502: RET
// export function EnemyInRange ( unit , dist ) ; begin
47503: LD_INT 0
47505: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47506: LD_ADDR_VAR 0 3
47510: PUSH
47511: LD_VAR 0 1
47515: PPUSH
47516: CALL_OW 255
47520: PPUSH
47521: LD_VAR 0 1
47525: PPUSH
47526: CALL_OW 250
47530: PPUSH
47531: LD_VAR 0 1
47535: PPUSH
47536: CALL_OW 251
47540: PPUSH
47541: LD_VAR 0 2
47545: PPUSH
47546: CALL 20899 0 4
47550: PUSH
47551: LD_INT 4
47553: ARRAY
47554: ST_TO_ADDR
// end ;
47555: LD_VAR 0 3
47559: RET
// export function PlayerSeeMe ( unit ) ; begin
47560: LD_INT 0
47562: PPUSH
// result := See ( your_side , unit ) ;
47563: LD_ADDR_VAR 0 2
47567: PUSH
47568: LD_OWVAR 2
47572: PPUSH
47573: LD_VAR 0 1
47577: PPUSH
47578: CALL_OW 292
47582: ST_TO_ADDR
// end ;
47583: LD_VAR 0 2
47587: RET
// export function ReverseDir ( unit ) ; begin
47588: LD_INT 0
47590: PPUSH
// if not unit then
47591: LD_VAR 0 1
47595: NOT
47596: IFFALSE 47600
// exit ;
47598: GO 47623
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
47600: LD_ADDR_VAR 0 2
47604: PUSH
47605: LD_VAR 0 1
47609: PPUSH
47610: CALL_OW 254
47614: PUSH
47615: LD_INT 3
47617: PLUS
47618: PUSH
47619: LD_INT 6
47621: MOD
47622: ST_TO_ADDR
// end ;
47623: LD_VAR 0 2
47627: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47628: LD_INT 0
47630: PPUSH
47631: PPUSH
47632: PPUSH
47633: PPUSH
47634: PPUSH
// if not hexes then
47635: LD_VAR 0 2
47639: NOT
47640: IFFALSE 47644
// exit ;
47642: GO 47792
// dist := 9999 ;
47644: LD_ADDR_VAR 0 5
47648: PUSH
47649: LD_INT 9999
47651: ST_TO_ADDR
// for i = 1 to hexes do
47652: LD_ADDR_VAR 0 4
47656: PUSH
47657: DOUBLE
47658: LD_INT 1
47660: DEC
47661: ST_TO_ADDR
47662: LD_VAR 0 2
47666: PUSH
47667: FOR_TO
47668: IFFALSE 47780
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
47670: LD_VAR 0 1
47674: PPUSH
47675: LD_VAR 0 2
47679: PUSH
47680: LD_VAR 0 4
47684: ARRAY
47685: PUSH
47686: LD_INT 1
47688: ARRAY
47689: PPUSH
47690: LD_VAR 0 2
47694: PUSH
47695: LD_VAR 0 4
47699: ARRAY
47700: PUSH
47701: LD_INT 2
47703: ARRAY
47704: PPUSH
47705: CALL_OW 297
47709: PUSH
47710: LD_VAR 0 5
47714: LESS
47715: IFFALSE 47778
// begin hex := hexes [ i ] ;
47717: LD_ADDR_VAR 0 7
47721: PUSH
47722: LD_VAR 0 2
47726: PUSH
47727: LD_VAR 0 4
47731: ARRAY
47732: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
47733: LD_ADDR_VAR 0 5
47737: PUSH
47738: LD_VAR 0 1
47742: PPUSH
47743: LD_VAR 0 2
47747: PUSH
47748: LD_VAR 0 4
47752: ARRAY
47753: PUSH
47754: LD_INT 1
47756: ARRAY
47757: PPUSH
47758: LD_VAR 0 2
47762: PUSH
47763: LD_VAR 0 4
47767: ARRAY
47768: PUSH
47769: LD_INT 2
47771: ARRAY
47772: PPUSH
47773: CALL_OW 297
47777: ST_TO_ADDR
// end ; end ;
47778: GO 47667
47780: POP
47781: POP
// result := hex ;
47782: LD_ADDR_VAR 0 3
47786: PUSH
47787: LD_VAR 0 7
47791: ST_TO_ADDR
// end ;
47792: LD_VAR 0 3
47796: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
47797: LD_INT 0
47799: PPUSH
47800: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
47801: LD_VAR 0 1
47805: NOT
47806: PUSH
47807: LD_VAR 0 1
47811: PUSH
47812: LD_INT 21
47814: PUSH
47815: LD_INT 2
47817: PUSH
47818: EMPTY
47819: LIST
47820: LIST
47821: PUSH
47822: LD_INT 23
47824: PUSH
47825: LD_INT 2
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PPUSH
47836: CALL_OW 69
47840: IN
47841: NOT
47842: OR
47843: IFFALSE 47847
// exit ;
47845: GO 47894
// for i = 1 to 3 do
47847: LD_ADDR_VAR 0 3
47851: PUSH
47852: DOUBLE
47853: LD_INT 1
47855: DEC
47856: ST_TO_ADDR
47857: LD_INT 3
47859: PUSH
47860: FOR_TO
47861: IFFALSE 47892
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
47863: LD_VAR 0 1
47867: PPUSH
47868: CALL_OW 250
47872: PPUSH
47873: LD_VAR 0 1
47877: PPUSH
47878: CALL_OW 251
47882: PPUSH
47883: LD_INT 1
47885: PPUSH
47886: CALL_OW 453
47890: GO 47860
47892: POP
47893: POP
// end ;
47894: LD_VAR 0 2
47898: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
47899: LD_INT 0
47901: PPUSH
47902: PPUSH
47903: PPUSH
47904: PPUSH
47905: PPUSH
47906: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
47907: LD_VAR 0 1
47911: NOT
47912: PUSH
47913: LD_VAR 0 2
47917: NOT
47918: OR
47919: PUSH
47920: LD_VAR 0 1
47924: PPUSH
47925: CALL_OW 314
47929: OR
47930: IFFALSE 47934
// exit ;
47932: GO 48375
// x := GetX ( enemy_unit ) ;
47934: LD_ADDR_VAR 0 7
47938: PUSH
47939: LD_VAR 0 2
47943: PPUSH
47944: CALL_OW 250
47948: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
47949: LD_ADDR_VAR 0 8
47953: PUSH
47954: LD_VAR 0 2
47958: PPUSH
47959: CALL_OW 251
47963: ST_TO_ADDR
// if not x or not y then
47964: LD_VAR 0 7
47968: NOT
47969: PUSH
47970: LD_VAR 0 8
47974: NOT
47975: OR
47976: IFFALSE 47980
// exit ;
47978: GO 48375
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
47980: LD_ADDR_VAR 0 6
47984: PUSH
47985: LD_VAR 0 7
47989: PPUSH
47990: LD_INT 0
47992: PPUSH
47993: LD_INT 4
47995: PPUSH
47996: CALL_OW 272
48000: PUSH
48001: LD_VAR 0 8
48005: PPUSH
48006: LD_INT 0
48008: PPUSH
48009: LD_INT 4
48011: PPUSH
48012: CALL_OW 273
48016: PUSH
48017: EMPTY
48018: LIST
48019: LIST
48020: PUSH
48021: LD_VAR 0 7
48025: PPUSH
48026: LD_INT 1
48028: PPUSH
48029: LD_INT 4
48031: PPUSH
48032: CALL_OW 272
48036: PUSH
48037: LD_VAR 0 8
48041: PPUSH
48042: LD_INT 1
48044: PPUSH
48045: LD_INT 4
48047: PPUSH
48048: CALL_OW 273
48052: PUSH
48053: EMPTY
48054: LIST
48055: LIST
48056: PUSH
48057: LD_VAR 0 7
48061: PPUSH
48062: LD_INT 2
48064: PPUSH
48065: LD_INT 4
48067: PPUSH
48068: CALL_OW 272
48072: PUSH
48073: LD_VAR 0 8
48077: PPUSH
48078: LD_INT 2
48080: PPUSH
48081: LD_INT 4
48083: PPUSH
48084: CALL_OW 273
48088: PUSH
48089: EMPTY
48090: LIST
48091: LIST
48092: PUSH
48093: LD_VAR 0 7
48097: PPUSH
48098: LD_INT 3
48100: PPUSH
48101: LD_INT 4
48103: PPUSH
48104: CALL_OW 272
48108: PUSH
48109: LD_VAR 0 8
48113: PPUSH
48114: LD_INT 3
48116: PPUSH
48117: LD_INT 4
48119: PPUSH
48120: CALL_OW 273
48124: PUSH
48125: EMPTY
48126: LIST
48127: LIST
48128: PUSH
48129: LD_VAR 0 7
48133: PPUSH
48134: LD_INT 4
48136: PPUSH
48137: LD_INT 4
48139: PPUSH
48140: CALL_OW 272
48144: PUSH
48145: LD_VAR 0 8
48149: PPUSH
48150: LD_INT 4
48152: PPUSH
48153: LD_INT 4
48155: PPUSH
48156: CALL_OW 273
48160: PUSH
48161: EMPTY
48162: LIST
48163: LIST
48164: PUSH
48165: LD_VAR 0 7
48169: PPUSH
48170: LD_INT 5
48172: PPUSH
48173: LD_INT 4
48175: PPUSH
48176: CALL_OW 272
48180: PUSH
48181: LD_VAR 0 8
48185: PPUSH
48186: LD_INT 5
48188: PPUSH
48189: LD_INT 4
48191: PPUSH
48192: CALL_OW 273
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: LIST
48206: LIST
48207: LIST
48208: ST_TO_ADDR
// for i = tmp downto 1 do
48209: LD_ADDR_VAR 0 4
48213: PUSH
48214: DOUBLE
48215: LD_VAR 0 6
48219: INC
48220: ST_TO_ADDR
48221: LD_INT 1
48223: PUSH
48224: FOR_DOWNTO
48225: IFFALSE 48326
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48227: LD_VAR 0 6
48231: PUSH
48232: LD_VAR 0 4
48236: ARRAY
48237: PUSH
48238: LD_INT 1
48240: ARRAY
48241: PPUSH
48242: LD_VAR 0 6
48246: PUSH
48247: LD_VAR 0 4
48251: ARRAY
48252: PUSH
48253: LD_INT 2
48255: ARRAY
48256: PPUSH
48257: CALL_OW 488
48261: NOT
48262: PUSH
48263: LD_VAR 0 6
48267: PUSH
48268: LD_VAR 0 4
48272: ARRAY
48273: PUSH
48274: LD_INT 1
48276: ARRAY
48277: PPUSH
48278: LD_VAR 0 6
48282: PUSH
48283: LD_VAR 0 4
48287: ARRAY
48288: PUSH
48289: LD_INT 2
48291: ARRAY
48292: PPUSH
48293: CALL_OW 428
48297: PUSH
48298: LD_INT 0
48300: NONEQUAL
48301: OR
48302: IFFALSE 48324
// tmp := Delete ( tmp , i ) ;
48304: LD_ADDR_VAR 0 6
48308: PUSH
48309: LD_VAR 0 6
48313: PPUSH
48314: LD_VAR 0 4
48318: PPUSH
48319: CALL_OW 3
48323: ST_TO_ADDR
48324: GO 48224
48326: POP
48327: POP
// j := GetClosestHex ( unit , tmp ) ;
48328: LD_ADDR_VAR 0 5
48332: PUSH
48333: LD_VAR 0 1
48337: PPUSH
48338: LD_VAR 0 6
48342: PPUSH
48343: CALL 47628 0 2
48347: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48348: LD_VAR 0 1
48352: PPUSH
48353: LD_VAR 0 5
48357: PUSH
48358: LD_INT 1
48360: ARRAY
48361: PPUSH
48362: LD_VAR 0 5
48366: PUSH
48367: LD_INT 2
48369: ARRAY
48370: PPUSH
48371: CALL_OW 111
// end ;
48375: LD_VAR 0 3
48379: RET
// export function PrepareApemanSoldier ( ) ; begin
48380: LD_INT 0
48382: PPUSH
// uc_nation := 0 ;
48383: LD_ADDR_OWVAR 21
48387: PUSH
48388: LD_INT 0
48390: ST_TO_ADDR
// hc_sex := sex_male ;
48391: LD_ADDR_OWVAR 27
48395: PUSH
48396: LD_INT 1
48398: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48399: LD_ADDR_OWVAR 28
48403: PUSH
48404: LD_INT 15
48406: ST_TO_ADDR
// hc_gallery :=  ;
48407: LD_ADDR_OWVAR 33
48411: PUSH
48412: LD_STRING 
48414: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48415: LD_ADDR_OWVAR 31
48419: PUSH
48420: LD_INT 0
48422: PPUSH
48423: LD_INT 3
48425: PPUSH
48426: CALL_OW 12
48430: PUSH
48431: LD_INT 0
48433: PPUSH
48434: LD_INT 3
48436: PPUSH
48437: CALL_OW 12
48441: PUSH
48442: LD_INT 0
48444: PUSH
48445: LD_INT 0
48447: PUSH
48448: EMPTY
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: ST_TO_ADDR
// end ;
48454: LD_VAR 0 1
48458: RET
// export function PrepareApemanEngineer ( ) ; begin
48459: LD_INT 0
48461: PPUSH
// uc_nation := 0 ;
48462: LD_ADDR_OWVAR 21
48466: PUSH
48467: LD_INT 0
48469: ST_TO_ADDR
// hc_sex := sex_male ;
48470: LD_ADDR_OWVAR 27
48474: PUSH
48475: LD_INT 1
48477: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
48478: LD_ADDR_OWVAR 28
48482: PUSH
48483: LD_INT 16
48485: ST_TO_ADDR
// hc_gallery :=  ;
48486: LD_ADDR_OWVAR 33
48490: PUSH
48491: LD_STRING 
48493: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48494: LD_ADDR_OWVAR 31
48498: PUSH
48499: LD_INT 0
48501: PPUSH
48502: LD_INT 3
48504: PPUSH
48505: CALL_OW 12
48509: PUSH
48510: LD_INT 0
48512: PPUSH
48513: LD_INT 3
48515: PPUSH
48516: CALL_OW 12
48520: PUSH
48521: LD_INT 0
48523: PUSH
48524: LD_INT 0
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: LIST
48531: LIST
48532: ST_TO_ADDR
// end ;
48533: LD_VAR 0 1
48537: RET
// export function PrepareApeman ( agressivity ) ; begin
48538: LD_INT 0
48540: PPUSH
// uc_side := 0 ;
48541: LD_ADDR_OWVAR 20
48545: PUSH
48546: LD_INT 0
48548: ST_TO_ADDR
// uc_nation := 0 ;
48549: LD_ADDR_OWVAR 21
48553: PUSH
48554: LD_INT 0
48556: ST_TO_ADDR
// hc_sex := sex_male ;
48557: LD_ADDR_OWVAR 27
48561: PUSH
48562: LD_INT 1
48564: ST_TO_ADDR
// hc_class := class_apeman ;
48565: LD_ADDR_OWVAR 28
48569: PUSH
48570: LD_INT 12
48572: ST_TO_ADDR
// hc_gallery :=  ;
48573: LD_ADDR_OWVAR 33
48577: PUSH
48578: LD_STRING 
48580: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48581: LD_ADDR_OWVAR 35
48585: PUSH
48586: LD_VAR 0 1
48590: NEG
48591: PPUSH
48592: LD_VAR 0 1
48596: PPUSH
48597: CALL_OW 12
48601: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48602: LD_ADDR_OWVAR 31
48606: PUSH
48607: LD_INT 0
48609: PPUSH
48610: LD_INT 3
48612: PPUSH
48613: CALL_OW 12
48617: PUSH
48618: LD_INT 0
48620: PPUSH
48621: LD_INT 3
48623: PPUSH
48624: CALL_OW 12
48628: PUSH
48629: LD_INT 0
48631: PUSH
48632: LD_INT 0
48634: PUSH
48635: EMPTY
48636: LIST
48637: LIST
48638: LIST
48639: LIST
48640: ST_TO_ADDR
// end ;
48641: LD_VAR 0 2
48645: RET
// export function PrepareTiger ( agressivity ) ; begin
48646: LD_INT 0
48648: PPUSH
// uc_side := 0 ;
48649: LD_ADDR_OWVAR 20
48653: PUSH
48654: LD_INT 0
48656: ST_TO_ADDR
// uc_nation := 0 ;
48657: LD_ADDR_OWVAR 21
48661: PUSH
48662: LD_INT 0
48664: ST_TO_ADDR
// hc_class := class_tiger ;
48665: LD_ADDR_OWVAR 28
48669: PUSH
48670: LD_INT 14
48672: ST_TO_ADDR
// hc_gallery :=  ;
48673: LD_ADDR_OWVAR 33
48677: PUSH
48678: LD_STRING 
48680: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
48681: LD_ADDR_OWVAR 35
48685: PUSH
48686: LD_VAR 0 1
48690: NEG
48691: PPUSH
48692: LD_VAR 0 1
48696: PPUSH
48697: CALL_OW 12
48701: ST_TO_ADDR
// end ;
48702: LD_VAR 0 2
48706: RET
// export function PrepareEnchidna ( ) ; begin
48707: LD_INT 0
48709: PPUSH
// uc_side := 0 ;
48710: LD_ADDR_OWVAR 20
48714: PUSH
48715: LD_INT 0
48717: ST_TO_ADDR
// uc_nation := 0 ;
48718: LD_ADDR_OWVAR 21
48722: PUSH
48723: LD_INT 0
48725: ST_TO_ADDR
// hc_class := class_baggie ;
48726: LD_ADDR_OWVAR 28
48730: PUSH
48731: LD_INT 13
48733: ST_TO_ADDR
// hc_gallery :=  ;
48734: LD_ADDR_OWVAR 33
48738: PUSH
48739: LD_STRING 
48741: ST_TO_ADDR
// end ;
48742: LD_VAR 0 1
48746: RET
// export function PrepareFrog ( ) ; begin
48747: LD_INT 0
48749: PPUSH
// uc_side := 0 ;
48750: LD_ADDR_OWVAR 20
48754: PUSH
48755: LD_INT 0
48757: ST_TO_ADDR
// uc_nation := 0 ;
48758: LD_ADDR_OWVAR 21
48762: PUSH
48763: LD_INT 0
48765: ST_TO_ADDR
// hc_class := class_frog ;
48766: LD_ADDR_OWVAR 28
48770: PUSH
48771: LD_INT 19
48773: ST_TO_ADDR
// hc_gallery :=  ;
48774: LD_ADDR_OWVAR 33
48778: PUSH
48779: LD_STRING 
48781: ST_TO_ADDR
// end ;
48782: LD_VAR 0 1
48786: RET
// export function PrepareFish ( ) ; begin
48787: LD_INT 0
48789: PPUSH
// uc_side := 0 ;
48790: LD_ADDR_OWVAR 20
48794: PUSH
48795: LD_INT 0
48797: ST_TO_ADDR
// uc_nation := 0 ;
48798: LD_ADDR_OWVAR 21
48802: PUSH
48803: LD_INT 0
48805: ST_TO_ADDR
// hc_class := class_fish ;
48806: LD_ADDR_OWVAR 28
48810: PUSH
48811: LD_INT 20
48813: ST_TO_ADDR
// hc_gallery :=  ;
48814: LD_ADDR_OWVAR 33
48818: PUSH
48819: LD_STRING 
48821: ST_TO_ADDR
// end ;
48822: LD_VAR 0 1
48826: RET
// export function PrepareBird ( ) ; begin
48827: LD_INT 0
48829: PPUSH
// uc_side := 0 ;
48830: LD_ADDR_OWVAR 20
48834: PUSH
48835: LD_INT 0
48837: ST_TO_ADDR
// uc_nation := 0 ;
48838: LD_ADDR_OWVAR 21
48842: PUSH
48843: LD_INT 0
48845: ST_TO_ADDR
// hc_class := class_phororhacos ;
48846: LD_ADDR_OWVAR 28
48850: PUSH
48851: LD_INT 18
48853: ST_TO_ADDR
// hc_gallery :=  ;
48854: LD_ADDR_OWVAR 33
48858: PUSH
48859: LD_STRING 
48861: ST_TO_ADDR
// end ;
48862: LD_VAR 0 1
48866: RET
// export function PrepareHorse ( ) ; begin
48867: LD_INT 0
48869: PPUSH
// uc_side := 0 ;
48870: LD_ADDR_OWVAR 20
48874: PUSH
48875: LD_INT 0
48877: ST_TO_ADDR
// uc_nation := 0 ;
48878: LD_ADDR_OWVAR 21
48882: PUSH
48883: LD_INT 0
48885: ST_TO_ADDR
// hc_class := class_horse ;
48886: LD_ADDR_OWVAR 28
48890: PUSH
48891: LD_INT 21
48893: ST_TO_ADDR
// hc_gallery :=  ;
48894: LD_ADDR_OWVAR 33
48898: PUSH
48899: LD_STRING 
48901: ST_TO_ADDR
// end ;
48902: LD_VAR 0 1
48906: RET
// export function PrepareMastodont ( ) ; begin
48907: LD_INT 0
48909: PPUSH
// uc_side := 0 ;
48910: LD_ADDR_OWVAR 20
48914: PUSH
48915: LD_INT 0
48917: ST_TO_ADDR
// uc_nation := 0 ;
48918: LD_ADDR_OWVAR 21
48922: PUSH
48923: LD_INT 0
48925: ST_TO_ADDR
// vc_chassis := class_mastodont ;
48926: LD_ADDR_OWVAR 37
48930: PUSH
48931: LD_INT 31
48933: ST_TO_ADDR
// vc_control := control_rider ;
48934: LD_ADDR_OWVAR 38
48938: PUSH
48939: LD_INT 4
48941: ST_TO_ADDR
// end ;
48942: LD_VAR 0 1
48946: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48947: LD_INT 0
48949: PPUSH
48950: PPUSH
48951: PPUSH
// uc_side = 0 ;
48952: LD_ADDR_OWVAR 20
48956: PUSH
48957: LD_INT 0
48959: ST_TO_ADDR
// uc_nation = 0 ;
48960: LD_ADDR_OWVAR 21
48964: PUSH
48965: LD_INT 0
48967: ST_TO_ADDR
// InitHc_All ( ) ;
48968: CALL_OW 584
// InitVc ;
48972: CALL_OW 20
// if mastodonts then
48976: LD_VAR 0 6
48980: IFFALSE 49047
// for i = 1 to mastodonts do
48982: LD_ADDR_VAR 0 11
48986: PUSH
48987: DOUBLE
48988: LD_INT 1
48990: DEC
48991: ST_TO_ADDR
48992: LD_VAR 0 6
48996: PUSH
48997: FOR_TO
48998: IFFALSE 49045
// begin vc_chassis := 31 ;
49000: LD_ADDR_OWVAR 37
49004: PUSH
49005: LD_INT 31
49007: ST_TO_ADDR
// vc_control := control_rider ;
49008: LD_ADDR_OWVAR 38
49012: PUSH
49013: LD_INT 4
49015: ST_TO_ADDR
// animal := CreateVehicle ;
49016: LD_ADDR_VAR 0 12
49020: PUSH
49021: CALL_OW 45
49025: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49026: LD_VAR 0 12
49030: PPUSH
49031: LD_VAR 0 8
49035: PPUSH
49036: LD_INT 0
49038: PPUSH
49039: CALL 51182 0 3
// end ;
49043: GO 48997
49045: POP
49046: POP
// if horses then
49047: LD_VAR 0 5
49051: IFFALSE 49118
// for i = 1 to horses do
49053: LD_ADDR_VAR 0 11
49057: PUSH
49058: DOUBLE
49059: LD_INT 1
49061: DEC
49062: ST_TO_ADDR
49063: LD_VAR 0 5
49067: PUSH
49068: FOR_TO
49069: IFFALSE 49116
// begin hc_class := 21 ;
49071: LD_ADDR_OWVAR 28
49075: PUSH
49076: LD_INT 21
49078: ST_TO_ADDR
// hc_gallery :=  ;
49079: LD_ADDR_OWVAR 33
49083: PUSH
49084: LD_STRING 
49086: ST_TO_ADDR
// animal := CreateHuman ;
49087: LD_ADDR_VAR 0 12
49091: PUSH
49092: CALL_OW 44
49096: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49097: LD_VAR 0 12
49101: PPUSH
49102: LD_VAR 0 8
49106: PPUSH
49107: LD_INT 0
49109: PPUSH
49110: CALL 51182 0 3
// end ;
49114: GO 49068
49116: POP
49117: POP
// if birds then
49118: LD_VAR 0 1
49122: IFFALSE 49189
// for i = 1 to birds do
49124: LD_ADDR_VAR 0 11
49128: PUSH
49129: DOUBLE
49130: LD_INT 1
49132: DEC
49133: ST_TO_ADDR
49134: LD_VAR 0 1
49138: PUSH
49139: FOR_TO
49140: IFFALSE 49187
// begin hc_class = 18 ;
49142: LD_ADDR_OWVAR 28
49146: PUSH
49147: LD_INT 18
49149: ST_TO_ADDR
// hc_gallery =  ;
49150: LD_ADDR_OWVAR 33
49154: PUSH
49155: LD_STRING 
49157: ST_TO_ADDR
// animal := CreateHuman ;
49158: LD_ADDR_VAR 0 12
49162: PUSH
49163: CALL_OW 44
49167: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49168: LD_VAR 0 12
49172: PPUSH
49173: LD_VAR 0 8
49177: PPUSH
49178: LD_INT 0
49180: PPUSH
49181: CALL 51182 0 3
// end ;
49185: GO 49139
49187: POP
49188: POP
// if tigers then
49189: LD_VAR 0 2
49193: IFFALSE 49277
// for i = 1 to tigers do
49195: LD_ADDR_VAR 0 11
49199: PUSH
49200: DOUBLE
49201: LD_INT 1
49203: DEC
49204: ST_TO_ADDR
49205: LD_VAR 0 2
49209: PUSH
49210: FOR_TO
49211: IFFALSE 49275
// begin hc_class = class_tiger ;
49213: LD_ADDR_OWVAR 28
49217: PUSH
49218: LD_INT 14
49220: ST_TO_ADDR
// hc_gallery =  ;
49221: LD_ADDR_OWVAR 33
49225: PUSH
49226: LD_STRING 
49228: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49229: LD_ADDR_OWVAR 35
49233: PUSH
49234: LD_INT 7
49236: NEG
49237: PPUSH
49238: LD_INT 7
49240: PPUSH
49241: CALL_OW 12
49245: ST_TO_ADDR
// animal := CreateHuman ;
49246: LD_ADDR_VAR 0 12
49250: PUSH
49251: CALL_OW 44
49255: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49256: LD_VAR 0 12
49260: PPUSH
49261: LD_VAR 0 8
49265: PPUSH
49266: LD_INT 0
49268: PPUSH
49269: CALL 51182 0 3
// end ;
49273: GO 49210
49275: POP
49276: POP
// if apemans then
49277: LD_VAR 0 3
49281: IFFALSE 49404
// for i = 1 to apemans do
49283: LD_ADDR_VAR 0 11
49287: PUSH
49288: DOUBLE
49289: LD_INT 1
49291: DEC
49292: ST_TO_ADDR
49293: LD_VAR 0 3
49297: PUSH
49298: FOR_TO
49299: IFFALSE 49402
// begin hc_class = class_apeman ;
49301: LD_ADDR_OWVAR 28
49305: PUSH
49306: LD_INT 12
49308: ST_TO_ADDR
// hc_gallery =  ;
49309: LD_ADDR_OWVAR 33
49313: PUSH
49314: LD_STRING 
49316: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49317: LD_ADDR_OWVAR 35
49321: PUSH
49322: LD_INT 2
49324: NEG
49325: PPUSH
49326: LD_INT 2
49328: PPUSH
49329: CALL_OW 12
49333: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49334: LD_ADDR_OWVAR 31
49338: PUSH
49339: LD_INT 1
49341: PPUSH
49342: LD_INT 3
49344: PPUSH
49345: CALL_OW 12
49349: PUSH
49350: LD_INT 1
49352: PPUSH
49353: LD_INT 3
49355: PPUSH
49356: CALL_OW 12
49360: PUSH
49361: LD_INT 0
49363: PUSH
49364: LD_INT 0
49366: PUSH
49367: EMPTY
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: ST_TO_ADDR
// animal := CreateHuman ;
49373: LD_ADDR_VAR 0 12
49377: PUSH
49378: CALL_OW 44
49382: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49383: LD_VAR 0 12
49387: PPUSH
49388: LD_VAR 0 8
49392: PPUSH
49393: LD_INT 0
49395: PPUSH
49396: CALL 51182 0 3
// end ;
49400: GO 49298
49402: POP
49403: POP
// if enchidnas then
49404: LD_VAR 0 4
49408: IFFALSE 49475
// for i = 1 to enchidnas do
49410: LD_ADDR_VAR 0 11
49414: PUSH
49415: DOUBLE
49416: LD_INT 1
49418: DEC
49419: ST_TO_ADDR
49420: LD_VAR 0 4
49424: PUSH
49425: FOR_TO
49426: IFFALSE 49473
// begin hc_class = 13 ;
49428: LD_ADDR_OWVAR 28
49432: PUSH
49433: LD_INT 13
49435: ST_TO_ADDR
// hc_gallery =  ;
49436: LD_ADDR_OWVAR 33
49440: PUSH
49441: LD_STRING 
49443: ST_TO_ADDR
// animal := CreateHuman ;
49444: LD_ADDR_VAR 0 12
49448: PUSH
49449: CALL_OW 44
49453: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49454: LD_VAR 0 12
49458: PPUSH
49459: LD_VAR 0 8
49463: PPUSH
49464: LD_INT 0
49466: PPUSH
49467: CALL 51182 0 3
// end ;
49471: GO 49425
49473: POP
49474: POP
// if fishes then
49475: LD_VAR 0 7
49479: IFFALSE 49546
// for i = 1 to fishes do
49481: LD_ADDR_VAR 0 11
49485: PUSH
49486: DOUBLE
49487: LD_INT 1
49489: DEC
49490: ST_TO_ADDR
49491: LD_VAR 0 7
49495: PUSH
49496: FOR_TO
49497: IFFALSE 49544
// begin hc_class = 20 ;
49499: LD_ADDR_OWVAR 28
49503: PUSH
49504: LD_INT 20
49506: ST_TO_ADDR
// hc_gallery =  ;
49507: LD_ADDR_OWVAR 33
49511: PUSH
49512: LD_STRING 
49514: ST_TO_ADDR
// animal := CreateHuman ;
49515: LD_ADDR_VAR 0 12
49519: PUSH
49520: CALL_OW 44
49524: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49525: LD_VAR 0 12
49529: PPUSH
49530: LD_VAR 0 9
49534: PPUSH
49535: LD_INT 0
49537: PPUSH
49538: CALL 51182 0 3
// end ;
49542: GO 49496
49544: POP
49545: POP
// end ;
49546: LD_VAR 0 10
49550: RET
// export function WantHeal ( sci , unit ) ; begin
49551: LD_INT 0
49553: PPUSH
// if GetTaskList ( sci ) > 0 then
49554: LD_VAR 0 1
49558: PPUSH
49559: CALL_OW 437
49563: PUSH
49564: LD_INT 0
49566: GREATER
49567: IFFALSE 49637
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49569: LD_VAR 0 1
49573: PPUSH
49574: CALL_OW 437
49578: PUSH
49579: LD_INT 1
49581: ARRAY
49582: PUSH
49583: LD_INT 1
49585: ARRAY
49586: PUSH
49587: LD_STRING l
49589: EQUAL
49590: PUSH
49591: LD_VAR 0 1
49595: PPUSH
49596: CALL_OW 437
49600: PUSH
49601: LD_INT 1
49603: ARRAY
49604: PUSH
49605: LD_INT 4
49607: ARRAY
49608: PUSH
49609: LD_VAR 0 2
49613: EQUAL
49614: AND
49615: IFFALSE 49627
// result := true else
49617: LD_ADDR_VAR 0 3
49621: PUSH
49622: LD_INT 1
49624: ST_TO_ADDR
49625: GO 49635
// result := false ;
49627: LD_ADDR_VAR 0 3
49631: PUSH
49632: LD_INT 0
49634: ST_TO_ADDR
// end else
49635: GO 49645
// result := false ;
49637: LD_ADDR_VAR 0 3
49641: PUSH
49642: LD_INT 0
49644: ST_TO_ADDR
// end ;
49645: LD_VAR 0 3
49649: RET
// export function HealTarget ( sci ) ; begin
49650: LD_INT 0
49652: PPUSH
// if not sci then
49653: LD_VAR 0 1
49657: NOT
49658: IFFALSE 49662
// exit ;
49660: GO 49727
// result := 0 ;
49662: LD_ADDR_VAR 0 2
49666: PUSH
49667: LD_INT 0
49669: ST_TO_ADDR
// if GetTaskList ( sci ) then
49670: LD_VAR 0 1
49674: PPUSH
49675: CALL_OW 437
49679: IFFALSE 49727
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49681: LD_VAR 0 1
49685: PPUSH
49686: CALL_OW 437
49690: PUSH
49691: LD_INT 1
49693: ARRAY
49694: PUSH
49695: LD_INT 1
49697: ARRAY
49698: PUSH
49699: LD_STRING l
49701: EQUAL
49702: IFFALSE 49727
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49704: LD_ADDR_VAR 0 2
49708: PUSH
49709: LD_VAR 0 1
49713: PPUSH
49714: CALL_OW 437
49718: PUSH
49719: LD_INT 1
49721: ARRAY
49722: PUSH
49723: LD_INT 4
49725: ARRAY
49726: ST_TO_ADDR
// end ;
49727: LD_VAR 0 2
49731: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
49732: LD_INT 0
49734: PPUSH
49735: PPUSH
49736: PPUSH
49737: PPUSH
// if not base_units then
49738: LD_VAR 0 1
49742: NOT
49743: IFFALSE 49747
// exit ;
49745: GO 49834
// result := false ;
49747: LD_ADDR_VAR 0 2
49751: PUSH
49752: LD_INT 0
49754: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
49755: LD_ADDR_VAR 0 5
49759: PUSH
49760: LD_VAR 0 1
49764: PPUSH
49765: LD_INT 21
49767: PUSH
49768: LD_INT 3
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: PPUSH
49775: CALL_OW 72
49779: ST_TO_ADDR
// if not tmp then
49780: LD_VAR 0 5
49784: NOT
49785: IFFALSE 49789
// exit ;
49787: GO 49834
// for i in tmp do
49789: LD_ADDR_VAR 0 3
49793: PUSH
49794: LD_VAR 0 5
49798: PUSH
49799: FOR_IN
49800: IFFALSE 49832
// begin result := EnemyInRange ( i , 22 ) ;
49802: LD_ADDR_VAR 0 2
49806: PUSH
49807: LD_VAR 0 3
49811: PPUSH
49812: LD_INT 22
49814: PPUSH
49815: CALL 47503 0 2
49819: ST_TO_ADDR
// if result then
49820: LD_VAR 0 2
49824: IFFALSE 49830
// exit ;
49826: POP
49827: POP
49828: GO 49834
// end ;
49830: GO 49799
49832: POP
49833: POP
// end ;
49834: LD_VAR 0 2
49838: RET
// export function FilterByTag ( units , tag ) ; begin
49839: LD_INT 0
49841: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
49842: LD_ADDR_VAR 0 3
49846: PUSH
49847: LD_VAR 0 1
49851: PPUSH
49852: LD_INT 120
49854: PUSH
49855: LD_VAR 0 2
49859: PUSH
49860: EMPTY
49861: LIST
49862: LIST
49863: PPUSH
49864: CALL_OW 72
49868: ST_TO_ADDR
// end ;
49869: LD_VAR 0 3
49873: RET
// export function IsDriver ( un ) ; begin
49874: LD_INT 0
49876: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
49877: LD_ADDR_VAR 0 2
49881: PUSH
49882: LD_VAR 0 1
49886: PUSH
49887: LD_INT 55
49889: PUSH
49890: EMPTY
49891: LIST
49892: PPUSH
49893: CALL_OW 69
49897: IN
49898: ST_TO_ADDR
// end ;
49899: LD_VAR 0 2
49903: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
49904: LD_INT 0
49906: PPUSH
49907: PPUSH
// list := [ ] ;
49908: LD_ADDR_VAR 0 5
49912: PUSH
49913: EMPTY
49914: ST_TO_ADDR
// case d of 0 :
49915: LD_VAR 0 3
49919: PUSH
49920: LD_INT 0
49922: DOUBLE
49923: EQUAL
49924: IFTRUE 49928
49926: GO 50061
49928: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
49929: LD_ADDR_VAR 0 5
49933: PUSH
49934: LD_VAR 0 1
49938: PUSH
49939: LD_INT 4
49941: MINUS
49942: PUSH
49943: LD_VAR 0 2
49947: PUSH
49948: LD_INT 4
49950: MINUS
49951: PUSH
49952: LD_INT 2
49954: PUSH
49955: EMPTY
49956: LIST
49957: LIST
49958: LIST
49959: PUSH
49960: LD_VAR 0 1
49964: PUSH
49965: LD_INT 3
49967: MINUS
49968: PUSH
49969: LD_VAR 0 2
49973: PUSH
49974: LD_INT 1
49976: PUSH
49977: EMPTY
49978: LIST
49979: LIST
49980: LIST
49981: PUSH
49982: LD_VAR 0 1
49986: PUSH
49987: LD_INT 4
49989: PLUS
49990: PUSH
49991: LD_VAR 0 2
49995: PUSH
49996: LD_INT 4
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: LIST
50003: PUSH
50004: LD_VAR 0 1
50008: PUSH
50009: LD_INT 3
50011: PLUS
50012: PUSH
50013: LD_VAR 0 2
50017: PUSH
50018: LD_INT 3
50020: PLUS
50021: PUSH
50022: LD_INT 5
50024: PUSH
50025: EMPTY
50026: LIST
50027: LIST
50028: LIST
50029: PUSH
50030: LD_VAR 0 1
50034: PUSH
50035: LD_VAR 0 2
50039: PUSH
50040: LD_INT 4
50042: PLUS
50043: PUSH
50044: LD_INT 0
50046: PUSH
50047: EMPTY
50048: LIST
50049: LIST
50050: LIST
50051: PUSH
50052: EMPTY
50053: LIST
50054: LIST
50055: LIST
50056: LIST
50057: LIST
50058: ST_TO_ADDR
// end ; 1 :
50059: GO 50759
50061: LD_INT 1
50063: DOUBLE
50064: EQUAL
50065: IFTRUE 50069
50067: GO 50202
50069: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50070: LD_ADDR_VAR 0 5
50074: PUSH
50075: LD_VAR 0 1
50079: PUSH
50080: LD_VAR 0 2
50084: PUSH
50085: LD_INT 4
50087: MINUS
50088: PUSH
50089: LD_INT 3
50091: PUSH
50092: EMPTY
50093: LIST
50094: LIST
50095: LIST
50096: PUSH
50097: LD_VAR 0 1
50101: PUSH
50102: LD_INT 3
50104: MINUS
50105: PUSH
50106: LD_VAR 0 2
50110: PUSH
50111: LD_INT 3
50113: MINUS
50114: PUSH
50115: LD_INT 2
50117: PUSH
50118: EMPTY
50119: LIST
50120: LIST
50121: LIST
50122: PUSH
50123: LD_VAR 0 1
50127: PUSH
50128: LD_INT 4
50130: MINUS
50131: PUSH
50132: LD_VAR 0 2
50136: PUSH
50137: LD_INT 1
50139: PUSH
50140: EMPTY
50141: LIST
50142: LIST
50143: LIST
50144: PUSH
50145: LD_VAR 0 1
50149: PUSH
50150: LD_VAR 0 2
50154: PUSH
50155: LD_INT 3
50157: PLUS
50158: PUSH
50159: LD_INT 0
50161: PUSH
50162: EMPTY
50163: LIST
50164: LIST
50165: LIST
50166: PUSH
50167: LD_VAR 0 1
50171: PUSH
50172: LD_INT 4
50174: PLUS
50175: PUSH
50176: LD_VAR 0 2
50180: PUSH
50181: LD_INT 4
50183: PLUS
50184: PUSH
50185: LD_INT 5
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: LIST
50192: PUSH
50193: EMPTY
50194: LIST
50195: LIST
50196: LIST
50197: LIST
50198: LIST
50199: ST_TO_ADDR
// end ; 2 :
50200: GO 50759
50202: LD_INT 2
50204: DOUBLE
50205: EQUAL
50206: IFTRUE 50210
50208: GO 50339
50210: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50211: LD_ADDR_VAR 0 5
50215: PUSH
50216: LD_VAR 0 1
50220: PUSH
50221: LD_VAR 0 2
50225: PUSH
50226: LD_INT 3
50228: MINUS
50229: PUSH
50230: LD_INT 3
50232: PUSH
50233: EMPTY
50234: LIST
50235: LIST
50236: LIST
50237: PUSH
50238: LD_VAR 0 1
50242: PUSH
50243: LD_INT 4
50245: PLUS
50246: PUSH
50247: LD_VAR 0 2
50251: PUSH
50252: LD_INT 4
50254: PUSH
50255: EMPTY
50256: LIST
50257: LIST
50258: LIST
50259: PUSH
50260: LD_VAR 0 1
50264: PUSH
50265: LD_VAR 0 2
50269: PUSH
50270: LD_INT 4
50272: PLUS
50273: PUSH
50274: LD_INT 0
50276: PUSH
50277: EMPTY
50278: LIST
50279: LIST
50280: LIST
50281: PUSH
50282: LD_VAR 0 1
50286: PUSH
50287: LD_INT 3
50289: MINUS
50290: PUSH
50291: LD_VAR 0 2
50295: PUSH
50296: LD_INT 1
50298: PUSH
50299: EMPTY
50300: LIST
50301: LIST
50302: LIST
50303: PUSH
50304: LD_VAR 0 1
50308: PUSH
50309: LD_INT 4
50311: MINUS
50312: PUSH
50313: LD_VAR 0 2
50317: PUSH
50318: LD_INT 4
50320: MINUS
50321: PUSH
50322: LD_INT 2
50324: PUSH
50325: EMPTY
50326: LIST
50327: LIST
50328: LIST
50329: PUSH
50330: EMPTY
50331: LIST
50332: LIST
50333: LIST
50334: LIST
50335: LIST
50336: ST_TO_ADDR
// end ; 3 :
50337: GO 50759
50339: LD_INT 3
50341: DOUBLE
50342: EQUAL
50343: IFTRUE 50347
50345: GO 50480
50347: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50348: LD_ADDR_VAR 0 5
50352: PUSH
50353: LD_VAR 0 1
50357: PUSH
50358: LD_INT 3
50360: PLUS
50361: PUSH
50362: LD_VAR 0 2
50366: PUSH
50367: LD_INT 4
50369: PUSH
50370: EMPTY
50371: LIST
50372: LIST
50373: LIST
50374: PUSH
50375: LD_VAR 0 1
50379: PUSH
50380: LD_INT 4
50382: PLUS
50383: PUSH
50384: LD_VAR 0 2
50388: PUSH
50389: LD_INT 4
50391: PLUS
50392: PUSH
50393: LD_INT 5
50395: PUSH
50396: EMPTY
50397: LIST
50398: LIST
50399: LIST
50400: PUSH
50401: LD_VAR 0 1
50405: PUSH
50406: LD_INT 4
50408: MINUS
50409: PUSH
50410: LD_VAR 0 2
50414: PUSH
50415: LD_INT 1
50417: PUSH
50418: EMPTY
50419: LIST
50420: LIST
50421: LIST
50422: PUSH
50423: LD_VAR 0 1
50427: PUSH
50428: LD_VAR 0 2
50432: PUSH
50433: LD_INT 4
50435: MINUS
50436: PUSH
50437: LD_INT 3
50439: PUSH
50440: EMPTY
50441: LIST
50442: LIST
50443: LIST
50444: PUSH
50445: LD_VAR 0 1
50449: PUSH
50450: LD_INT 3
50452: MINUS
50453: PUSH
50454: LD_VAR 0 2
50458: PUSH
50459: LD_INT 3
50461: MINUS
50462: PUSH
50463: LD_INT 2
50465: PUSH
50466: EMPTY
50467: LIST
50468: LIST
50469: LIST
50470: PUSH
50471: EMPTY
50472: LIST
50473: LIST
50474: LIST
50475: LIST
50476: LIST
50477: ST_TO_ADDR
// end ; 4 :
50478: GO 50759
50480: LD_INT 4
50482: DOUBLE
50483: EQUAL
50484: IFTRUE 50488
50486: GO 50621
50488: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
50489: LD_ADDR_VAR 0 5
50493: PUSH
50494: LD_VAR 0 1
50498: PUSH
50499: LD_VAR 0 2
50503: PUSH
50504: LD_INT 4
50506: PLUS
50507: PUSH
50508: LD_INT 0
50510: PUSH
50511: EMPTY
50512: LIST
50513: LIST
50514: LIST
50515: PUSH
50516: LD_VAR 0 1
50520: PUSH
50521: LD_INT 3
50523: PLUS
50524: PUSH
50525: LD_VAR 0 2
50529: PUSH
50530: LD_INT 3
50532: PLUS
50533: PUSH
50534: LD_INT 5
50536: PUSH
50537: EMPTY
50538: LIST
50539: LIST
50540: LIST
50541: PUSH
50542: LD_VAR 0 1
50546: PUSH
50547: LD_INT 4
50549: PLUS
50550: PUSH
50551: LD_VAR 0 2
50555: PUSH
50556: LD_INT 4
50558: PUSH
50559: EMPTY
50560: LIST
50561: LIST
50562: LIST
50563: PUSH
50564: LD_VAR 0 1
50568: PUSH
50569: LD_VAR 0 2
50573: PUSH
50574: LD_INT 3
50576: MINUS
50577: PUSH
50578: LD_INT 3
50580: PUSH
50581: EMPTY
50582: LIST
50583: LIST
50584: LIST
50585: PUSH
50586: LD_VAR 0 1
50590: PUSH
50591: LD_INT 4
50593: MINUS
50594: PUSH
50595: LD_VAR 0 2
50599: PUSH
50600: LD_INT 4
50602: MINUS
50603: PUSH
50604: LD_INT 2
50606: PUSH
50607: EMPTY
50608: LIST
50609: LIST
50610: LIST
50611: PUSH
50612: EMPTY
50613: LIST
50614: LIST
50615: LIST
50616: LIST
50617: LIST
50618: ST_TO_ADDR
// end ; 5 :
50619: GO 50759
50621: LD_INT 5
50623: DOUBLE
50624: EQUAL
50625: IFTRUE 50629
50627: GO 50758
50629: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
50630: LD_ADDR_VAR 0 5
50634: PUSH
50635: LD_VAR 0 1
50639: PUSH
50640: LD_INT 4
50642: MINUS
50643: PUSH
50644: LD_VAR 0 2
50648: PUSH
50649: LD_INT 1
50651: PUSH
50652: EMPTY
50653: LIST
50654: LIST
50655: LIST
50656: PUSH
50657: LD_VAR 0 1
50661: PUSH
50662: LD_VAR 0 2
50666: PUSH
50667: LD_INT 4
50669: MINUS
50670: PUSH
50671: LD_INT 3
50673: PUSH
50674: EMPTY
50675: LIST
50676: LIST
50677: LIST
50678: PUSH
50679: LD_VAR 0 1
50683: PUSH
50684: LD_INT 4
50686: PLUS
50687: PUSH
50688: LD_VAR 0 2
50692: PUSH
50693: LD_INT 4
50695: PLUS
50696: PUSH
50697: LD_INT 5
50699: PUSH
50700: EMPTY
50701: LIST
50702: LIST
50703: LIST
50704: PUSH
50705: LD_VAR 0 1
50709: PUSH
50710: LD_INT 3
50712: PLUS
50713: PUSH
50714: LD_VAR 0 2
50718: PUSH
50719: LD_INT 4
50721: PUSH
50722: EMPTY
50723: LIST
50724: LIST
50725: LIST
50726: PUSH
50727: LD_VAR 0 1
50731: PUSH
50732: LD_VAR 0 2
50736: PUSH
50737: LD_INT 3
50739: PLUS
50740: PUSH
50741: LD_INT 0
50743: PUSH
50744: EMPTY
50745: LIST
50746: LIST
50747: LIST
50748: PUSH
50749: EMPTY
50750: LIST
50751: LIST
50752: LIST
50753: LIST
50754: LIST
50755: ST_TO_ADDR
// end ; end ;
50756: GO 50759
50758: POP
// result := list ;
50759: LD_ADDR_VAR 0 4
50763: PUSH
50764: LD_VAR 0 5
50768: ST_TO_ADDR
// end ;
50769: LD_VAR 0 4
50773: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
50774: LD_INT 0
50776: PPUSH
50777: PPUSH
50778: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
50779: LD_VAR 0 1
50783: NOT
50784: PUSH
50785: LD_VAR 0 2
50789: PUSH
50790: LD_INT 1
50792: PUSH
50793: LD_INT 2
50795: PUSH
50796: LD_INT 3
50798: PUSH
50799: LD_INT 4
50801: PUSH
50802: EMPTY
50803: LIST
50804: LIST
50805: LIST
50806: LIST
50807: IN
50808: NOT
50809: OR
50810: IFFALSE 50814
// exit ;
50812: GO 50906
// tmp := [ ] ;
50814: LD_ADDR_VAR 0 5
50818: PUSH
50819: EMPTY
50820: ST_TO_ADDR
// for i in units do
50821: LD_ADDR_VAR 0 4
50825: PUSH
50826: LD_VAR 0 1
50830: PUSH
50831: FOR_IN
50832: IFFALSE 50875
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
50834: LD_ADDR_VAR 0 5
50838: PUSH
50839: LD_VAR 0 5
50843: PPUSH
50844: LD_VAR 0 5
50848: PUSH
50849: LD_INT 1
50851: PLUS
50852: PPUSH
50853: LD_VAR 0 4
50857: PPUSH
50858: LD_VAR 0 2
50862: PPUSH
50863: CALL_OW 259
50867: PPUSH
50868: CALL_OW 2
50872: ST_TO_ADDR
50873: GO 50831
50875: POP
50876: POP
// if not tmp then
50877: LD_VAR 0 5
50881: NOT
50882: IFFALSE 50886
// exit ;
50884: GO 50906
// result := SortListByListDesc ( units , tmp ) ;
50886: LD_ADDR_VAR 0 3
50890: PUSH
50891: LD_VAR 0 1
50895: PPUSH
50896: LD_VAR 0 5
50900: PPUSH
50901: CALL_OW 77
50905: ST_TO_ADDR
// end ;
50906: LD_VAR 0 3
50910: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
50911: LD_INT 0
50913: PPUSH
50914: PPUSH
50915: PPUSH
// result := false ;
50916: LD_ADDR_VAR 0 3
50920: PUSH
50921: LD_INT 0
50923: ST_TO_ADDR
// x := GetX ( building ) ;
50924: LD_ADDR_VAR 0 4
50928: PUSH
50929: LD_VAR 0 2
50933: PPUSH
50934: CALL_OW 250
50938: ST_TO_ADDR
// y := GetY ( building ) ;
50939: LD_ADDR_VAR 0 5
50943: PUSH
50944: LD_VAR 0 2
50948: PPUSH
50949: CALL_OW 251
50953: ST_TO_ADDR
// if not building or not x or not y then
50954: LD_VAR 0 2
50958: NOT
50959: PUSH
50960: LD_VAR 0 4
50964: NOT
50965: OR
50966: PUSH
50967: LD_VAR 0 5
50971: NOT
50972: OR
50973: IFFALSE 50977
// exit ;
50975: GO 51069
// if GetTaskList ( unit ) then
50977: LD_VAR 0 1
50981: PPUSH
50982: CALL_OW 437
50986: IFFALSE 51069
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
50988: LD_STRING e
50990: PUSH
50991: LD_VAR 0 1
50995: PPUSH
50996: CALL_OW 437
51000: PUSH
51001: LD_INT 1
51003: ARRAY
51004: PUSH
51005: LD_INT 1
51007: ARRAY
51008: EQUAL
51009: PUSH
51010: LD_VAR 0 4
51014: PUSH
51015: LD_VAR 0 1
51019: PPUSH
51020: CALL_OW 437
51024: PUSH
51025: LD_INT 1
51027: ARRAY
51028: PUSH
51029: LD_INT 2
51031: ARRAY
51032: EQUAL
51033: AND
51034: PUSH
51035: LD_VAR 0 5
51039: PUSH
51040: LD_VAR 0 1
51044: PPUSH
51045: CALL_OW 437
51049: PUSH
51050: LD_INT 1
51052: ARRAY
51053: PUSH
51054: LD_INT 3
51056: ARRAY
51057: EQUAL
51058: AND
51059: IFFALSE 51069
// result := true end ;
51061: LD_ADDR_VAR 0 3
51065: PUSH
51066: LD_INT 1
51068: ST_TO_ADDR
// end ;
51069: LD_VAR 0 3
51073: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51074: LD_INT 0
51076: PPUSH
// result := false ;
51077: LD_ADDR_VAR 0 4
51081: PUSH
51082: LD_INT 0
51084: ST_TO_ADDR
// if GetTaskList ( unit ) then
51085: LD_VAR 0 1
51089: PPUSH
51090: CALL_OW 437
51094: IFFALSE 51177
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51096: LD_STRING M
51098: PUSH
51099: LD_VAR 0 1
51103: PPUSH
51104: CALL_OW 437
51108: PUSH
51109: LD_INT 1
51111: ARRAY
51112: PUSH
51113: LD_INT 1
51115: ARRAY
51116: EQUAL
51117: PUSH
51118: LD_VAR 0 2
51122: PUSH
51123: LD_VAR 0 1
51127: PPUSH
51128: CALL_OW 437
51132: PUSH
51133: LD_INT 1
51135: ARRAY
51136: PUSH
51137: LD_INT 2
51139: ARRAY
51140: EQUAL
51141: AND
51142: PUSH
51143: LD_VAR 0 3
51147: PUSH
51148: LD_VAR 0 1
51152: PPUSH
51153: CALL_OW 437
51157: PUSH
51158: LD_INT 1
51160: ARRAY
51161: PUSH
51162: LD_INT 3
51164: ARRAY
51165: EQUAL
51166: AND
51167: IFFALSE 51177
// result := true ;
51169: LD_ADDR_VAR 0 4
51173: PUSH
51174: LD_INT 1
51176: ST_TO_ADDR
// end ; end ;
51177: LD_VAR 0 4
51181: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51182: LD_INT 0
51184: PPUSH
51185: PPUSH
51186: PPUSH
51187: PPUSH
// if not unit or not area then
51188: LD_VAR 0 1
51192: NOT
51193: PUSH
51194: LD_VAR 0 2
51198: NOT
51199: OR
51200: IFFALSE 51204
// exit ;
51202: GO 51368
// tmp := AreaToList ( area , i ) ;
51204: LD_ADDR_VAR 0 6
51208: PUSH
51209: LD_VAR 0 2
51213: PPUSH
51214: LD_VAR 0 5
51218: PPUSH
51219: CALL_OW 517
51223: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51224: LD_ADDR_VAR 0 5
51228: PUSH
51229: DOUBLE
51230: LD_INT 1
51232: DEC
51233: ST_TO_ADDR
51234: LD_VAR 0 6
51238: PUSH
51239: LD_INT 1
51241: ARRAY
51242: PUSH
51243: FOR_TO
51244: IFFALSE 51366
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51246: LD_ADDR_VAR 0 7
51250: PUSH
51251: LD_VAR 0 6
51255: PUSH
51256: LD_INT 1
51258: ARRAY
51259: PUSH
51260: LD_VAR 0 5
51264: ARRAY
51265: PUSH
51266: LD_VAR 0 6
51270: PUSH
51271: LD_INT 2
51273: ARRAY
51274: PUSH
51275: LD_VAR 0 5
51279: ARRAY
51280: PUSH
51281: EMPTY
51282: LIST
51283: LIST
51284: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
51285: LD_VAR 0 7
51289: PUSH
51290: LD_INT 1
51292: ARRAY
51293: PPUSH
51294: LD_VAR 0 7
51298: PUSH
51299: LD_INT 2
51301: ARRAY
51302: PPUSH
51303: CALL_OW 428
51307: PUSH
51308: LD_INT 0
51310: EQUAL
51311: IFFALSE 51364
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
51313: LD_VAR 0 1
51317: PPUSH
51318: LD_VAR 0 7
51322: PUSH
51323: LD_INT 1
51325: ARRAY
51326: PPUSH
51327: LD_VAR 0 7
51331: PUSH
51332: LD_INT 2
51334: ARRAY
51335: PPUSH
51336: LD_VAR 0 3
51340: PPUSH
51341: CALL_OW 48
// result := IsPlaced ( unit ) ;
51345: LD_ADDR_VAR 0 4
51349: PUSH
51350: LD_VAR 0 1
51354: PPUSH
51355: CALL_OW 305
51359: ST_TO_ADDR
// exit ;
51360: POP
51361: POP
51362: GO 51368
// end ; end ;
51364: GO 51243
51366: POP
51367: POP
// end ;
51368: LD_VAR 0 4
51372: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51373: LD_INT 0
51375: PPUSH
51376: PPUSH
51377: PPUSH
// if not side or side > 8 then
51378: LD_VAR 0 1
51382: NOT
51383: PUSH
51384: LD_VAR 0 1
51388: PUSH
51389: LD_INT 8
51391: GREATER
51392: OR
51393: IFFALSE 51397
// exit ;
51395: GO 51584
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51397: LD_ADDR_VAR 0 4
51401: PUSH
51402: LD_INT 22
51404: PUSH
51405: LD_VAR 0 1
51409: PUSH
51410: EMPTY
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 21
51416: PUSH
51417: LD_INT 3
51419: PUSH
51420: EMPTY
51421: LIST
51422: LIST
51423: PUSH
51424: EMPTY
51425: LIST
51426: LIST
51427: PPUSH
51428: CALL_OW 69
51432: ST_TO_ADDR
// if not tmp then
51433: LD_VAR 0 4
51437: NOT
51438: IFFALSE 51442
// exit ;
51440: GO 51584
// enable_addtolog := true ;
51442: LD_ADDR_OWVAR 81
51446: PUSH
51447: LD_INT 1
51449: ST_TO_ADDR
// AddToLog ( [ ) ;
51450: LD_STRING [
51452: PPUSH
51453: CALL_OW 561
// for i in tmp do
51457: LD_ADDR_VAR 0 3
51461: PUSH
51462: LD_VAR 0 4
51466: PUSH
51467: FOR_IN
51468: IFFALSE 51575
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
51470: LD_STRING [
51472: PUSH
51473: LD_VAR 0 3
51477: PPUSH
51478: CALL_OW 266
51482: STR
51483: PUSH
51484: LD_STRING , 
51486: STR
51487: PUSH
51488: LD_VAR 0 3
51492: PPUSH
51493: CALL_OW 250
51497: STR
51498: PUSH
51499: LD_STRING , 
51501: STR
51502: PUSH
51503: LD_VAR 0 3
51507: PPUSH
51508: CALL_OW 251
51512: STR
51513: PUSH
51514: LD_STRING , 
51516: STR
51517: PUSH
51518: LD_VAR 0 3
51522: PPUSH
51523: CALL_OW 254
51527: STR
51528: PUSH
51529: LD_STRING , 
51531: STR
51532: PUSH
51533: LD_VAR 0 3
51537: PPUSH
51538: LD_INT 1
51540: PPUSH
51541: CALL_OW 268
51545: STR
51546: PUSH
51547: LD_STRING , 
51549: STR
51550: PUSH
51551: LD_VAR 0 3
51555: PPUSH
51556: LD_INT 2
51558: PPUSH
51559: CALL_OW 268
51563: STR
51564: PUSH
51565: LD_STRING ],
51567: STR
51568: PPUSH
51569: CALL_OW 561
// end ;
51573: GO 51467
51575: POP
51576: POP
// AddToLog ( ]; ) ;
51577: LD_STRING ];
51579: PPUSH
51580: CALL_OW 561
// end ;
51584: LD_VAR 0 2
51588: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
51589: LD_INT 0
51591: PPUSH
51592: PPUSH
51593: PPUSH
51594: PPUSH
51595: PPUSH
// if not area or not rate or not max then
51596: LD_VAR 0 1
51600: NOT
51601: PUSH
51602: LD_VAR 0 2
51606: NOT
51607: OR
51608: PUSH
51609: LD_VAR 0 4
51613: NOT
51614: OR
51615: IFFALSE 51619
// exit ;
51617: GO 51808
// while 1 do
51619: LD_INT 1
51621: IFFALSE 51808
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
51623: LD_ADDR_VAR 0 9
51627: PUSH
51628: LD_VAR 0 1
51632: PPUSH
51633: LD_INT 1
51635: PPUSH
51636: CALL_OW 287
51640: PUSH
51641: LD_INT 10
51643: MUL
51644: ST_TO_ADDR
// r := rate / 10 ;
51645: LD_ADDR_VAR 0 7
51649: PUSH
51650: LD_VAR 0 2
51654: PUSH
51655: LD_INT 10
51657: DIVREAL
51658: ST_TO_ADDR
// time := 1 1$00 ;
51659: LD_ADDR_VAR 0 8
51663: PUSH
51664: LD_INT 2100
51666: ST_TO_ADDR
// if amount < min then
51667: LD_VAR 0 9
51671: PUSH
51672: LD_VAR 0 3
51676: LESS
51677: IFFALSE 51695
// r := r * 2 else
51679: LD_ADDR_VAR 0 7
51683: PUSH
51684: LD_VAR 0 7
51688: PUSH
51689: LD_INT 2
51691: MUL
51692: ST_TO_ADDR
51693: GO 51721
// if amount > max then
51695: LD_VAR 0 9
51699: PUSH
51700: LD_VAR 0 4
51704: GREATER
51705: IFFALSE 51721
// r := r / 2 ;
51707: LD_ADDR_VAR 0 7
51711: PUSH
51712: LD_VAR 0 7
51716: PUSH
51717: LD_INT 2
51719: DIVREAL
51720: ST_TO_ADDR
// time := time / r ;
51721: LD_ADDR_VAR 0 8
51725: PUSH
51726: LD_VAR 0 8
51730: PUSH
51731: LD_VAR 0 7
51735: DIVREAL
51736: ST_TO_ADDR
// if time < 0 then
51737: LD_VAR 0 8
51741: PUSH
51742: LD_INT 0
51744: LESS
51745: IFFALSE 51762
// time := time * - 1 ;
51747: LD_ADDR_VAR 0 8
51751: PUSH
51752: LD_VAR 0 8
51756: PUSH
51757: LD_INT 1
51759: NEG
51760: MUL
51761: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
51762: LD_VAR 0 8
51766: PUSH
51767: LD_INT 35
51769: PPUSH
51770: LD_INT 875
51772: PPUSH
51773: CALL_OW 12
51777: PLUS
51778: PPUSH
51779: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
51783: LD_INT 1
51785: PPUSH
51786: LD_INT 5
51788: PPUSH
51789: CALL_OW 12
51793: PPUSH
51794: LD_VAR 0 1
51798: PPUSH
51799: LD_INT 1
51801: PPUSH
51802: CALL_OW 55
// end ;
51806: GO 51619
// end ;
51808: LD_VAR 0 5
51812: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
51813: LD_INT 0
51815: PPUSH
51816: PPUSH
51817: PPUSH
51818: PPUSH
51819: PPUSH
51820: PPUSH
51821: PPUSH
51822: PPUSH
// if not turrets or not factories then
51823: LD_VAR 0 1
51827: NOT
51828: PUSH
51829: LD_VAR 0 2
51833: NOT
51834: OR
51835: IFFALSE 51839
// exit ;
51837: GO 52146
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
51839: LD_ADDR_VAR 0 10
51843: PUSH
51844: LD_INT 5
51846: PUSH
51847: LD_INT 6
51849: PUSH
51850: EMPTY
51851: LIST
51852: LIST
51853: PUSH
51854: LD_INT 2
51856: PUSH
51857: LD_INT 4
51859: PUSH
51860: EMPTY
51861: LIST
51862: LIST
51863: PUSH
51864: LD_INT 3
51866: PUSH
51867: LD_INT 5
51869: PUSH
51870: EMPTY
51871: LIST
51872: LIST
51873: PUSH
51874: EMPTY
51875: LIST
51876: LIST
51877: LIST
51878: PUSH
51879: LD_INT 24
51881: PUSH
51882: LD_INT 25
51884: PUSH
51885: EMPTY
51886: LIST
51887: LIST
51888: PUSH
51889: LD_INT 23
51891: PUSH
51892: LD_INT 27
51894: PUSH
51895: EMPTY
51896: LIST
51897: LIST
51898: PUSH
51899: EMPTY
51900: LIST
51901: LIST
51902: PUSH
51903: LD_INT 42
51905: PUSH
51906: LD_INT 43
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: PUSH
51913: LD_INT 44
51915: PUSH
51916: LD_INT 46
51918: PUSH
51919: EMPTY
51920: LIST
51921: LIST
51922: PUSH
51923: LD_INT 45
51925: PUSH
51926: LD_INT 47
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: PUSH
51933: EMPTY
51934: LIST
51935: LIST
51936: LIST
51937: PUSH
51938: EMPTY
51939: LIST
51940: LIST
51941: LIST
51942: ST_TO_ADDR
// result := [ ] ;
51943: LD_ADDR_VAR 0 3
51947: PUSH
51948: EMPTY
51949: ST_TO_ADDR
// for i in turrets do
51950: LD_ADDR_VAR 0 4
51954: PUSH
51955: LD_VAR 0 1
51959: PUSH
51960: FOR_IN
51961: IFFALSE 52144
// begin nat := GetNation ( i ) ;
51963: LD_ADDR_VAR 0 7
51967: PUSH
51968: LD_VAR 0 4
51972: PPUSH
51973: CALL_OW 248
51977: ST_TO_ADDR
// weapon := 0 ;
51978: LD_ADDR_VAR 0 8
51982: PUSH
51983: LD_INT 0
51985: ST_TO_ADDR
// if not nat then
51986: LD_VAR 0 7
51990: NOT
51991: IFFALSE 51995
// continue ;
51993: GO 51960
// for j in list [ nat ] do
51995: LD_ADDR_VAR 0 5
51999: PUSH
52000: LD_VAR 0 10
52004: PUSH
52005: LD_VAR 0 7
52009: ARRAY
52010: PUSH
52011: FOR_IN
52012: IFFALSE 52053
// if GetBWeapon ( i ) = j [ 1 ] then
52014: LD_VAR 0 4
52018: PPUSH
52019: CALL_OW 269
52023: PUSH
52024: LD_VAR 0 5
52028: PUSH
52029: LD_INT 1
52031: ARRAY
52032: EQUAL
52033: IFFALSE 52051
// begin weapon := j [ 2 ] ;
52035: LD_ADDR_VAR 0 8
52039: PUSH
52040: LD_VAR 0 5
52044: PUSH
52045: LD_INT 2
52047: ARRAY
52048: ST_TO_ADDR
// break ;
52049: GO 52053
// end ;
52051: GO 52011
52053: POP
52054: POP
// if not weapon then
52055: LD_VAR 0 8
52059: NOT
52060: IFFALSE 52064
// continue ;
52062: GO 51960
// for k in factories do
52064: LD_ADDR_VAR 0 6
52068: PUSH
52069: LD_VAR 0 2
52073: PUSH
52074: FOR_IN
52075: IFFALSE 52140
// begin weapons := AvailableWeaponList ( k ) ;
52077: LD_ADDR_VAR 0 9
52081: PUSH
52082: LD_VAR 0 6
52086: PPUSH
52087: CALL_OW 478
52091: ST_TO_ADDR
// if not weapons then
52092: LD_VAR 0 9
52096: NOT
52097: IFFALSE 52101
// continue ;
52099: GO 52074
// if weapon in weapons then
52101: LD_VAR 0 8
52105: PUSH
52106: LD_VAR 0 9
52110: IN
52111: IFFALSE 52138
// begin result := [ i , weapon ] ;
52113: LD_ADDR_VAR 0 3
52117: PUSH
52118: LD_VAR 0 4
52122: PUSH
52123: LD_VAR 0 8
52127: PUSH
52128: EMPTY
52129: LIST
52130: LIST
52131: ST_TO_ADDR
// exit ;
52132: POP
52133: POP
52134: POP
52135: POP
52136: GO 52146
// end ; end ;
52138: GO 52074
52140: POP
52141: POP
// end ;
52142: GO 51960
52144: POP
52145: POP
// end ;
52146: LD_VAR 0 3
52150: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52151: LD_INT 0
52153: PPUSH
// if not side or side > 8 then
52154: LD_VAR 0 3
52158: NOT
52159: PUSH
52160: LD_VAR 0 3
52164: PUSH
52165: LD_INT 8
52167: GREATER
52168: OR
52169: IFFALSE 52173
// exit ;
52171: GO 52232
// if not range then
52173: LD_VAR 0 4
52177: NOT
52178: IFFALSE 52189
// range := - 12 ;
52180: LD_ADDR_VAR 0 4
52184: PUSH
52185: LD_INT 12
52187: NEG
52188: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52189: LD_VAR 0 1
52193: PPUSH
52194: LD_VAR 0 2
52198: PPUSH
52199: LD_VAR 0 3
52203: PPUSH
52204: LD_VAR 0 4
52208: PPUSH
52209: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52213: LD_VAR 0 1
52217: PPUSH
52218: LD_VAR 0 2
52222: PPUSH
52223: LD_VAR 0 3
52227: PPUSH
52228: CALL_OW 331
// end ;
52232: LD_VAR 0 5
52236: RET
// export function Video ( mode ) ; begin
52237: LD_INT 0
52239: PPUSH
// ingame_video = mode ;
52240: LD_ADDR_OWVAR 52
52244: PUSH
52245: LD_VAR 0 1
52249: ST_TO_ADDR
// interface_hidden = mode ;
52250: LD_ADDR_OWVAR 54
52254: PUSH
52255: LD_VAR 0 1
52259: ST_TO_ADDR
// end ;
52260: LD_VAR 0 2
52264: RET
// export function Join ( array , element ) ; begin
52265: LD_INT 0
52267: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52268: LD_ADDR_VAR 0 3
52272: PUSH
52273: LD_VAR 0 1
52277: PPUSH
52278: LD_VAR 0 1
52282: PUSH
52283: LD_INT 1
52285: PLUS
52286: PPUSH
52287: LD_VAR 0 2
52291: PPUSH
52292: CALL_OW 1
52296: ST_TO_ADDR
// end ;
52297: LD_VAR 0 3
52301: RET
// export function JoinUnion ( array , element ) ; begin
52302: LD_INT 0
52304: PPUSH
// result := array union element ;
52305: LD_ADDR_VAR 0 3
52309: PUSH
52310: LD_VAR 0 1
52314: PUSH
52315: LD_VAR 0 2
52319: UNION
52320: ST_TO_ADDR
// end ;
52321: LD_VAR 0 3
52325: RET
// export function GetBehemoths ( side ) ; begin
52326: LD_INT 0
52328: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52329: LD_ADDR_VAR 0 2
52333: PUSH
52334: LD_INT 22
52336: PUSH
52337: LD_VAR 0 1
52341: PUSH
52342: EMPTY
52343: LIST
52344: LIST
52345: PUSH
52346: LD_INT 31
52348: PUSH
52349: LD_INT 25
52351: PUSH
52352: EMPTY
52353: LIST
52354: LIST
52355: PUSH
52356: EMPTY
52357: LIST
52358: LIST
52359: PPUSH
52360: CALL_OW 69
52364: ST_TO_ADDR
// end ;
52365: LD_VAR 0 2
52369: RET
// export function Shuffle ( array ) ; var i , index ; begin
52370: LD_INT 0
52372: PPUSH
52373: PPUSH
52374: PPUSH
// result := [ ] ;
52375: LD_ADDR_VAR 0 2
52379: PUSH
52380: EMPTY
52381: ST_TO_ADDR
// if not array then
52382: LD_VAR 0 1
52386: NOT
52387: IFFALSE 52391
// exit ;
52389: GO 52490
// Randomize ;
52391: CALL_OW 10
// for i = array downto 1 do
52395: LD_ADDR_VAR 0 3
52399: PUSH
52400: DOUBLE
52401: LD_VAR 0 1
52405: INC
52406: ST_TO_ADDR
52407: LD_INT 1
52409: PUSH
52410: FOR_DOWNTO
52411: IFFALSE 52488
// begin index := rand ( 1 , array ) ;
52413: LD_ADDR_VAR 0 4
52417: PUSH
52418: LD_INT 1
52420: PPUSH
52421: LD_VAR 0 1
52425: PPUSH
52426: CALL_OW 12
52430: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52431: LD_ADDR_VAR 0 2
52435: PUSH
52436: LD_VAR 0 2
52440: PPUSH
52441: LD_VAR 0 2
52445: PUSH
52446: LD_INT 1
52448: PLUS
52449: PPUSH
52450: LD_VAR 0 1
52454: PUSH
52455: LD_VAR 0 4
52459: ARRAY
52460: PPUSH
52461: CALL_OW 2
52465: ST_TO_ADDR
// array := Delete ( array , index ) ;
52466: LD_ADDR_VAR 0 1
52470: PUSH
52471: LD_VAR 0 1
52475: PPUSH
52476: LD_VAR 0 4
52480: PPUSH
52481: CALL_OW 3
52485: ST_TO_ADDR
// end ;
52486: GO 52410
52488: POP
52489: POP
// end ;
52490: LD_VAR 0 2
52494: RET
// export function GetBaseMaterials ( base ) ; begin
52495: LD_INT 0
52497: PPUSH
// result := [ 0 , 0 , 0 ] ;
52498: LD_ADDR_VAR 0 2
52502: PUSH
52503: LD_INT 0
52505: PUSH
52506: LD_INT 0
52508: PUSH
52509: LD_INT 0
52511: PUSH
52512: EMPTY
52513: LIST
52514: LIST
52515: LIST
52516: ST_TO_ADDR
// if not base then
52517: LD_VAR 0 1
52521: NOT
52522: IFFALSE 52526
// exit ;
52524: GO 52575
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
52526: LD_ADDR_VAR 0 2
52530: PUSH
52531: LD_VAR 0 1
52535: PPUSH
52536: LD_INT 1
52538: PPUSH
52539: CALL_OW 275
52543: PUSH
52544: LD_VAR 0 1
52548: PPUSH
52549: LD_INT 2
52551: PPUSH
52552: CALL_OW 275
52556: PUSH
52557: LD_VAR 0 1
52561: PPUSH
52562: LD_INT 3
52564: PPUSH
52565: CALL_OW 275
52569: PUSH
52570: EMPTY
52571: LIST
52572: LIST
52573: LIST
52574: ST_TO_ADDR
// end ;
52575: LD_VAR 0 2
52579: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
52580: LD_INT 0
52582: PPUSH
52583: PPUSH
// result := array ;
52584: LD_ADDR_VAR 0 3
52588: PUSH
52589: LD_VAR 0 1
52593: ST_TO_ADDR
// if size >= result then
52594: LD_VAR 0 2
52598: PUSH
52599: LD_VAR 0 3
52603: GREATEREQUAL
52604: IFFALSE 52608
// exit ;
52606: GO 52658
// if size then
52608: LD_VAR 0 2
52612: IFFALSE 52658
// for i := array downto size do
52614: LD_ADDR_VAR 0 4
52618: PUSH
52619: DOUBLE
52620: LD_VAR 0 1
52624: INC
52625: ST_TO_ADDR
52626: LD_VAR 0 2
52630: PUSH
52631: FOR_DOWNTO
52632: IFFALSE 52656
// result := Delete ( result , result ) ;
52634: LD_ADDR_VAR 0 3
52638: PUSH
52639: LD_VAR 0 3
52643: PPUSH
52644: LD_VAR 0 3
52648: PPUSH
52649: CALL_OW 3
52653: ST_TO_ADDR
52654: GO 52631
52656: POP
52657: POP
// end ;
52658: LD_VAR 0 3
52662: RET
// export function ComExit ( unit ) ; var tmp ; begin
52663: LD_INT 0
52665: PPUSH
52666: PPUSH
// if not IsInUnit ( unit ) then
52667: LD_VAR 0 1
52671: PPUSH
52672: CALL_OW 310
52676: NOT
52677: IFFALSE 52681
// exit ;
52679: GO 52741
// tmp := IsInUnit ( unit ) ;
52681: LD_ADDR_VAR 0 3
52685: PUSH
52686: LD_VAR 0 1
52690: PPUSH
52691: CALL_OW 310
52695: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
52696: LD_VAR 0 3
52700: PPUSH
52701: CALL_OW 247
52705: PUSH
52706: LD_INT 2
52708: EQUAL
52709: IFFALSE 52722
// ComExitVehicle ( unit ) else
52711: LD_VAR 0 1
52715: PPUSH
52716: CALL_OW 121
52720: GO 52731
// ComExitBuilding ( unit ) ;
52722: LD_VAR 0 1
52726: PPUSH
52727: CALL_OW 122
// result := tmp ;
52731: LD_ADDR_VAR 0 2
52735: PUSH
52736: LD_VAR 0 3
52740: ST_TO_ADDR
// end ;
52741: LD_VAR 0 2
52745: RET
// export function ComExitAll ( units ) ; var i ; begin
52746: LD_INT 0
52748: PPUSH
52749: PPUSH
// if not units then
52750: LD_VAR 0 1
52754: NOT
52755: IFFALSE 52759
// exit ;
52757: GO 52785
// for i in units do
52759: LD_ADDR_VAR 0 3
52763: PUSH
52764: LD_VAR 0 1
52768: PUSH
52769: FOR_IN
52770: IFFALSE 52783
// ComExit ( i ) ;
52772: LD_VAR 0 3
52776: PPUSH
52777: CALL 52663 0 1
52781: GO 52769
52783: POP
52784: POP
// end ;
52785: LD_VAR 0 2
52789: RET
// export function ResetHc ; begin
52790: LD_INT 0
52792: PPUSH
// InitHc ;
52793: CALL_OW 19
// hc_importance := 0 ;
52797: LD_ADDR_OWVAR 32
52801: PUSH
52802: LD_INT 0
52804: ST_TO_ADDR
// end ;
52805: LD_VAR 0 1
52809: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
52810: LD_INT 0
52812: PPUSH
52813: PPUSH
52814: PPUSH
// _x := ( x1 + x2 ) div 2 ;
52815: LD_ADDR_VAR 0 6
52819: PUSH
52820: LD_VAR 0 1
52824: PUSH
52825: LD_VAR 0 3
52829: PLUS
52830: PUSH
52831: LD_INT 2
52833: DIV
52834: ST_TO_ADDR
// if _x < 0 then
52835: LD_VAR 0 6
52839: PUSH
52840: LD_INT 0
52842: LESS
52843: IFFALSE 52860
// _x := _x * - 1 ;
52845: LD_ADDR_VAR 0 6
52849: PUSH
52850: LD_VAR 0 6
52854: PUSH
52855: LD_INT 1
52857: NEG
52858: MUL
52859: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
52860: LD_ADDR_VAR 0 7
52864: PUSH
52865: LD_VAR 0 2
52869: PUSH
52870: LD_VAR 0 4
52874: PLUS
52875: PUSH
52876: LD_INT 2
52878: DIV
52879: ST_TO_ADDR
// if _y < 0 then
52880: LD_VAR 0 7
52884: PUSH
52885: LD_INT 0
52887: LESS
52888: IFFALSE 52905
// _y := _y * - 1 ;
52890: LD_ADDR_VAR 0 7
52894: PUSH
52895: LD_VAR 0 7
52899: PUSH
52900: LD_INT 1
52902: NEG
52903: MUL
52904: ST_TO_ADDR
// result := [ _x , _y ] ;
52905: LD_ADDR_VAR 0 5
52909: PUSH
52910: LD_VAR 0 6
52914: PUSH
52915: LD_VAR 0 7
52919: PUSH
52920: EMPTY
52921: LIST
52922: LIST
52923: ST_TO_ADDR
// end ;
52924: LD_VAR 0 5
52928: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
52929: LD_INT 0
52931: PPUSH
52932: PPUSH
52933: PPUSH
52934: PPUSH
// task := GetTaskList ( unit ) ;
52935: LD_ADDR_VAR 0 7
52939: PUSH
52940: LD_VAR 0 1
52944: PPUSH
52945: CALL_OW 437
52949: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
52950: LD_VAR 0 7
52954: NOT
52955: PUSH
52956: LD_VAR 0 1
52960: PPUSH
52961: LD_VAR 0 2
52965: PPUSH
52966: CALL_OW 308
52970: NOT
52971: AND
52972: IFFALSE 52976
// exit ;
52974: GO 53094
// if IsInArea ( unit , area ) then
52976: LD_VAR 0 1
52980: PPUSH
52981: LD_VAR 0 2
52985: PPUSH
52986: CALL_OW 308
52990: IFFALSE 53008
// begin ComMoveToArea ( unit , goAway ) ;
52992: LD_VAR 0 1
52996: PPUSH
52997: LD_VAR 0 3
53001: PPUSH
53002: CALL_OW 113
// exit ;
53006: GO 53094
// end ; if task [ 1 ] [ 1 ] <> M then
53008: LD_VAR 0 7
53012: PUSH
53013: LD_INT 1
53015: ARRAY
53016: PUSH
53017: LD_INT 1
53019: ARRAY
53020: PUSH
53021: LD_STRING M
53023: NONEQUAL
53024: IFFALSE 53028
// exit ;
53026: GO 53094
// x := task [ 1 ] [ 2 ] ;
53028: LD_ADDR_VAR 0 5
53032: PUSH
53033: LD_VAR 0 7
53037: PUSH
53038: LD_INT 1
53040: ARRAY
53041: PUSH
53042: LD_INT 2
53044: ARRAY
53045: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53046: LD_ADDR_VAR 0 6
53050: PUSH
53051: LD_VAR 0 7
53055: PUSH
53056: LD_INT 1
53058: ARRAY
53059: PUSH
53060: LD_INT 3
53062: ARRAY
53063: ST_TO_ADDR
// if InArea ( x , y , area ) then
53064: LD_VAR 0 5
53068: PPUSH
53069: LD_VAR 0 6
53073: PPUSH
53074: LD_VAR 0 2
53078: PPUSH
53079: CALL_OW 309
53083: IFFALSE 53094
// ComStop ( unit ) ;
53085: LD_VAR 0 1
53089: PPUSH
53090: CALL_OW 141
// end ;
53094: LD_VAR 0 4
53098: RET
// export function Abs ( value ) ; begin
53099: LD_INT 0
53101: PPUSH
// result := value ;
53102: LD_ADDR_VAR 0 2
53106: PUSH
53107: LD_VAR 0 1
53111: ST_TO_ADDR
// if value < 0 then
53112: LD_VAR 0 1
53116: PUSH
53117: LD_INT 0
53119: LESS
53120: IFFALSE 53137
// result := value * - 1 ;
53122: LD_ADDR_VAR 0 2
53126: PUSH
53127: LD_VAR 0 1
53131: PUSH
53132: LD_INT 1
53134: NEG
53135: MUL
53136: ST_TO_ADDR
// end ;
53137: LD_VAR 0 2
53141: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53142: LD_INT 0
53144: PPUSH
53145: PPUSH
53146: PPUSH
53147: PPUSH
53148: PPUSH
53149: PPUSH
53150: PPUSH
53151: PPUSH
// if not unit or not building then
53152: LD_VAR 0 1
53156: NOT
53157: PUSH
53158: LD_VAR 0 2
53162: NOT
53163: OR
53164: IFFALSE 53168
// exit ;
53166: GO 53394
// x := GetX ( building ) ;
53168: LD_ADDR_VAR 0 4
53172: PUSH
53173: LD_VAR 0 2
53177: PPUSH
53178: CALL_OW 250
53182: ST_TO_ADDR
// y := GetY ( building ) ;
53183: LD_ADDR_VAR 0 6
53187: PUSH
53188: LD_VAR 0 2
53192: PPUSH
53193: CALL_OW 251
53197: ST_TO_ADDR
// d := GetDir ( building ) ;
53198: LD_ADDR_VAR 0 8
53202: PUSH
53203: LD_VAR 0 2
53207: PPUSH
53208: CALL_OW 254
53212: ST_TO_ADDR
// r := 4 ;
53213: LD_ADDR_VAR 0 9
53217: PUSH
53218: LD_INT 4
53220: ST_TO_ADDR
// for i := 1 to 5 do
53221: LD_ADDR_VAR 0 10
53225: PUSH
53226: DOUBLE
53227: LD_INT 1
53229: DEC
53230: ST_TO_ADDR
53231: LD_INT 5
53233: PUSH
53234: FOR_TO
53235: IFFALSE 53392
// begin _x := ShiftX ( x , d , r + i ) ;
53237: LD_ADDR_VAR 0 5
53241: PUSH
53242: LD_VAR 0 4
53246: PPUSH
53247: LD_VAR 0 8
53251: PPUSH
53252: LD_VAR 0 9
53256: PUSH
53257: LD_VAR 0 10
53261: PLUS
53262: PPUSH
53263: CALL_OW 272
53267: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53268: LD_ADDR_VAR 0 7
53272: PUSH
53273: LD_VAR 0 6
53277: PPUSH
53278: LD_VAR 0 8
53282: PPUSH
53283: LD_VAR 0 9
53287: PUSH
53288: LD_VAR 0 10
53292: PLUS
53293: PPUSH
53294: CALL_OW 273
53298: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53299: LD_VAR 0 5
53303: PPUSH
53304: LD_VAR 0 7
53308: PPUSH
53309: CALL_OW 488
53313: PUSH
53314: LD_VAR 0 5
53318: PPUSH
53319: LD_VAR 0 7
53323: PPUSH
53324: CALL_OW 428
53328: PPUSH
53329: CALL_OW 247
53333: PUSH
53334: LD_INT 3
53336: PUSH
53337: LD_INT 2
53339: PUSH
53340: EMPTY
53341: LIST
53342: LIST
53343: IN
53344: NOT
53345: AND
53346: IFFALSE 53390
// begin ComMoveXY ( unit , _x , _y ) ;
53348: LD_VAR 0 1
53352: PPUSH
53353: LD_VAR 0 5
53357: PPUSH
53358: LD_VAR 0 7
53362: PPUSH
53363: CALL_OW 111
// result := [ _x , _y ] ;
53367: LD_ADDR_VAR 0 3
53371: PUSH
53372: LD_VAR 0 5
53376: PUSH
53377: LD_VAR 0 7
53381: PUSH
53382: EMPTY
53383: LIST
53384: LIST
53385: ST_TO_ADDR
// exit ;
53386: POP
53387: POP
53388: GO 53394
// end ; end ;
53390: GO 53234
53392: POP
53393: POP
// end ;
53394: LD_VAR 0 3
53398: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53399: LD_INT 0
53401: PPUSH
53402: PPUSH
53403: PPUSH
// result := 0 ;
53404: LD_ADDR_VAR 0 3
53408: PUSH
53409: LD_INT 0
53411: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53412: LD_VAR 0 1
53416: PUSH
53417: LD_INT 0
53419: LESS
53420: PUSH
53421: LD_VAR 0 1
53425: PUSH
53426: LD_INT 8
53428: GREATER
53429: OR
53430: PUSH
53431: LD_VAR 0 2
53435: PUSH
53436: LD_INT 0
53438: LESS
53439: OR
53440: PUSH
53441: LD_VAR 0 2
53445: PUSH
53446: LD_INT 8
53448: GREATER
53449: OR
53450: IFFALSE 53454
// exit ;
53452: GO 53529
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53454: LD_ADDR_VAR 0 4
53458: PUSH
53459: LD_INT 22
53461: PUSH
53462: LD_VAR 0 2
53466: PUSH
53467: EMPTY
53468: LIST
53469: LIST
53470: PPUSH
53471: CALL_OW 69
53475: PUSH
53476: FOR_IN
53477: IFFALSE 53527
// begin un := UnitShoot ( i ) ;
53479: LD_ADDR_VAR 0 5
53483: PUSH
53484: LD_VAR 0 4
53488: PPUSH
53489: CALL_OW 504
53493: ST_TO_ADDR
// if GetSide ( un ) = side1 then
53494: LD_VAR 0 5
53498: PPUSH
53499: CALL_OW 255
53503: PUSH
53504: LD_VAR 0 1
53508: EQUAL
53509: IFFALSE 53525
// begin result := un ;
53511: LD_ADDR_VAR 0 3
53515: PUSH
53516: LD_VAR 0 5
53520: ST_TO_ADDR
// exit ;
53521: POP
53522: POP
53523: GO 53529
// end ; end ;
53525: GO 53476
53527: POP
53528: POP
// end ;
53529: LD_VAR 0 3
53533: RET
// export function GetCargoBay ( units ) ; begin
53534: LD_INT 0
53536: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
53537: LD_ADDR_VAR 0 2
53541: PUSH
53542: LD_VAR 0 1
53546: PPUSH
53547: LD_INT 2
53549: PUSH
53550: LD_INT 34
53552: PUSH
53553: LD_INT 12
53555: PUSH
53556: EMPTY
53557: LIST
53558: LIST
53559: PUSH
53560: LD_INT 34
53562: PUSH
53563: LD_INT 51
53565: PUSH
53566: EMPTY
53567: LIST
53568: LIST
53569: PUSH
53570: LD_INT 34
53572: PUSH
53573: LD_INT 32
53575: PUSH
53576: EMPTY
53577: LIST
53578: LIST
53579: PUSH
53580: LD_INT 34
53582: PUSH
53583: LD_EXP 105
53587: PUSH
53588: EMPTY
53589: LIST
53590: LIST
53591: PUSH
53592: EMPTY
53593: LIST
53594: LIST
53595: LIST
53596: LIST
53597: LIST
53598: PPUSH
53599: CALL_OW 72
53603: ST_TO_ADDR
// end ;
53604: LD_VAR 0 2
53608: RET
// export function Negate ( value ) ; begin
53609: LD_INT 0
53611: PPUSH
// result := not value ;
53612: LD_ADDR_VAR 0 2
53616: PUSH
53617: LD_VAR 0 1
53621: NOT
53622: ST_TO_ADDR
// end ;
53623: LD_VAR 0 2
53627: RET
// export function Inc ( value ) ; begin
53628: LD_INT 0
53630: PPUSH
// result := value + 1 ;
53631: LD_ADDR_VAR 0 2
53635: PUSH
53636: LD_VAR 0 1
53640: PUSH
53641: LD_INT 1
53643: PLUS
53644: ST_TO_ADDR
// end ;
53645: LD_VAR 0 2
53649: RET
// export function Dec ( value ) ; begin
53650: LD_INT 0
53652: PPUSH
// result := value - 1 ;
53653: LD_ADDR_VAR 0 2
53657: PUSH
53658: LD_VAR 0 1
53662: PUSH
53663: LD_INT 1
53665: MINUS
53666: ST_TO_ADDR
// end ;
53667: LD_VAR 0 2
53671: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
53672: LD_INT 0
53674: PPUSH
53675: PPUSH
53676: PPUSH
53677: PPUSH
53678: PPUSH
53679: PPUSH
53680: PPUSH
53681: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
53682: LD_VAR 0 1
53686: PPUSH
53687: LD_VAR 0 2
53691: PPUSH
53692: CALL_OW 488
53696: NOT
53697: PUSH
53698: LD_VAR 0 3
53702: PPUSH
53703: LD_VAR 0 4
53707: PPUSH
53708: CALL_OW 488
53712: NOT
53713: OR
53714: IFFALSE 53727
// begin result := - 1 ;
53716: LD_ADDR_VAR 0 5
53720: PUSH
53721: LD_INT 1
53723: NEG
53724: ST_TO_ADDR
// exit ;
53725: GO 53962
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
53727: LD_ADDR_VAR 0 12
53731: PUSH
53732: LD_VAR 0 1
53736: PPUSH
53737: LD_VAR 0 2
53741: PPUSH
53742: LD_VAR 0 3
53746: PPUSH
53747: LD_VAR 0 4
53751: PPUSH
53752: CALL 52810 0 4
53756: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
53757: LD_ADDR_VAR 0 11
53761: PUSH
53762: LD_VAR 0 1
53766: PPUSH
53767: LD_VAR 0 2
53771: PPUSH
53772: LD_VAR 0 12
53776: PUSH
53777: LD_INT 1
53779: ARRAY
53780: PPUSH
53781: LD_VAR 0 12
53785: PUSH
53786: LD_INT 2
53788: ARRAY
53789: PPUSH
53790: CALL_OW 298
53794: ST_TO_ADDR
// distance := 9999 ;
53795: LD_ADDR_VAR 0 10
53799: PUSH
53800: LD_INT 9999
53802: ST_TO_ADDR
// for i := 0 to 5 do
53803: LD_ADDR_VAR 0 6
53807: PUSH
53808: DOUBLE
53809: LD_INT 0
53811: DEC
53812: ST_TO_ADDR
53813: LD_INT 5
53815: PUSH
53816: FOR_TO
53817: IFFALSE 53960
// begin _x := ShiftX ( x1 , i , centerDist ) ;
53819: LD_ADDR_VAR 0 7
53823: PUSH
53824: LD_VAR 0 1
53828: PPUSH
53829: LD_VAR 0 6
53833: PPUSH
53834: LD_VAR 0 11
53838: PPUSH
53839: CALL_OW 272
53843: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
53844: LD_ADDR_VAR 0 8
53848: PUSH
53849: LD_VAR 0 2
53853: PPUSH
53854: LD_VAR 0 6
53858: PPUSH
53859: LD_VAR 0 11
53863: PPUSH
53864: CALL_OW 273
53868: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
53869: LD_VAR 0 7
53873: PPUSH
53874: LD_VAR 0 8
53878: PPUSH
53879: CALL_OW 488
53883: NOT
53884: IFFALSE 53888
// continue ;
53886: GO 53816
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
53888: LD_ADDR_VAR 0 9
53892: PUSH
53893: LD_VAR 0 12
53897: PUSH
53898: LD_INT 1
53900: ARRAY
53901: PPUSH
53902: LD_VAR 0 12
53906: PUSH
53907: LD_INT 2
53909: ARRAY
53910: PPUSH
53911: LD_VAR 0 7
53915: PPUSH
53916: LD_VAR 0 8
53920: PPUSH
53921: CALL_OW 298
53925: ST_TO_ADDR
// if tmp < distance then
53926: LD_VAR 0 9
53930: PUSH
53931: LD_VAR 0 10
53935: LESS
53936: IFFALSE 53958
// begin result := i ;
53938: LD_ADDR_VAR 0 5
53942: PUSH
53943: LD_VAR 0 6
53947: ST_TO_ADDR
// distance := tmp ;
53948: LD_ADDR_VAR 0 10
53952: PUSH
53953: LD_VAR 0 9
53957: ST_TO_ADDR
// end ; end ;
53958: GO 53816
53960: POP
53961: POP
// end ;
53962: LD_VAR 0 5
53966: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
53967: LD_INT 0
53969: PPUSH
53970: PPUSH
// if not driver or not IsInUnit ( driver ) then
53971: LD_VAR 0 1
53975: NOT
53976: PUSH
53977: LD_VAR 0 1
53981: PPUSH
53982: CALL_OW 310
53986: NOT
53987: OR
53988: IFFALSE 53992
// exit ;
53990: GO 54082
// vehicle := IsInUnit ( driver ) ;
53992: LD_ADDR_VAR 0 3
53996: PUSH
53997: LD_VAR 0 1
54001: PPUSH
54002: CALL_OW 310
54006: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54007: LD_VAR 0 1
54011: PPUSH
54012: LD_STRING \
54014: PUSH
54015: LD_INT 0
54017: PUSH
54018: LD_INT 0
54020: PUSH
54021: LD_INT 0
54023: PUSH
54024: LD_INT 0
54026: PUSH
54027: LD_INT 0
54029: PUSH
54030: LD_INT 0
54032: PUSH
54033: EMPTY
54034: LIST
54035: LIST
54036: LIST
54037: LIST
54038: LIST
54039: LIST
54040: LIST
54041: PUSH
54042: LD_STRING E
54044: PUSH
54045: LD_INT 0
54047: PUSH
54048: LD_INT 0
54050: PUSH
54051: LD_VAR 0 3
54055: PUSH
54056: LD_INT 0
54058: PUSH
54059: LD_INT 0
54061: PUSH
54062: LD_INT 0
54064: PUSH
54065: EMPTY
54066: LIST
54067: LIST
54068: LIST
54069: LIST
54070: LIST
54071: LIST
54072: LIST
54073: PUSH
54074: EMPTY
54075: LIST
54076: LIST
54077: PPUSH
54078: CALL_OW 446
// end ;
54082: LD_VAR 0 2
54086: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54087: LD_INT 0
54089: PPUSH
54090: PPUSH
// if not driver or not IsInUnit ( driver ) then
54091: LD_VAR 0 1
54095: NOT
54096: PUSH
54097: LD_VAR 0 1
54101: PPUSH
54102: CALL_OW 310
54106: NOT
54107: OR
54108: IFFALSE 54112
// exit ;
54110: GO 54202
// vehicle := IsInUnit ( driver ) ;
54112: LD_ADDR_VAR 0 3
54116: PUSH
54117: LD_VAR 0 1
54121: PPUSH
54122: CALL_OW 310
54126: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54127: LD_VAR 0 1
54131: PPUSH
54132: LD_STRING \
54134: PUSH
54135: LD_INT 0
54137: PUSH
54138: LD_INT 0
54140: PUSH
54141: LD_INT 0
54143: PUSH
54144: LD_INT 0
54146: PUSH
54147: LD_INT 0
54149: PUSH
54150: LD_INT 0
54152: PUSH
54153: EMPTY
54154: LIST
54155: LIST
54156: LIST
54157: LIST
54158: LIST
54159: LIST
54160: LIST
54161: PUSH
54162: LD_STRING E
54164: PUSH
54165: LD_INT 0
54167: PUSH
54168: LD_INT 0
54170: PUSH
54171: LD_VAR 0 3
54175: PUSH
54176: LD_INT 0
54178: PUSH
54179: LD_INT 0
54181: PUSH
54182: LD_INT 0
54184: PUSH
54185: EMPTY
54186: LIST
54187: LIST
54188: LIST
54189: LIST
54190: LIST
54191: LIST
54192: LIST
54193: PUSH
54194: EMPTY
54195: LIST
54196: LIST
54197: PPUSH
54198: CALL_OW 447
// end ;
54202: LD_VAR 0 2
54206: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54207: LD_INT 0
54209: PPUSH
54210: PPUSH
54211: PPUSH
// tmp := [ ] ;
54212: LD_ADDR_VAR 0 5
54216: PUSH
54217: EMPTY
54218: ST_TO_ADDR
// for i in units do
54219: LD_ADDR_VAR 0 4
54223: PUSH
54224: LD_VAR 0 1
54228: PUSH
54229: FOR_IN
54230: IFFALSE 54268
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54232: LD_ADDR_VAR 0 5
54236: PUSH
54237: LD_VAR 0 5
54241: PPUSH
54242: LD_VAR 0 5
54246: PUSH
54247: LD_INT 1
54249: PLUS
54250: PPUSH
54251: LD_VAR 0 4
54255: PPUSH
54256: CALL_OW 256
54260: PPUSH
54261: CALL_OW 2
54265: ST_TO_ADDR
54266: GO 54229
54268: POP
54269: POP
// if not tmp then
54270: LD_VAR 0 5
54274: NOT
54275: IFFALSE 54279
// exit ;
54277: GO 54327
// if asc then
54279: LD_VAR 0 2
54283: IFFALSE 54307
// result := SortListByListAsc ( units , tmp ) else
54285: LD_ADDR_VAR 0 3
54289: PUSH
54290: LD_VAR 0 1
54294: PPUSH
54295: LD_VAR 0 5
54299: PPUSH
54300: CALL_OW 76
54304: ST_TO_ADDR
54305: GO 54327
// result := SortListByListDesc ( units , tmp ) ;
54307: LD_ADDR_VAR 0 3
54311: PUSH
54312: LD_VAR 0 1
54316: PPUSH
54317: LD_VAR 0 5
54321: PPUSH
54322: CALL_OW 77
54326: ST_TO_ADDR
// end ;
54327: LD_VAR 0 3
54331: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54332: LD_INT 0
54334: PPUSH
54335: PPUSH
// task := GetTaskList ( mech ) ;
54336: LD_ADDR_VAR 0 4
54340: PUSH
54341: LD_VAR 0 1
54345: PPUSH
54346: CALL_OW 437
54350: ST_TO_ADDR
// if not task then
54351: LD_VAR 0 4
54355: NOT
54356: IFFALSE 54360
// exit ;
54358: GO 54402
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54360: LD_ADDR_VAR 0 3
54364: PUSH
54365: LD_VAR 0 4
54369: PUSH
54370: LD_INT 1
54372: ARRAY
54373: PUSH
54374: LD_INT 1
54376: ARRAY
54377: PUSH
54378: LD_STRING r
54380: EQUAL
54381: PUSH
54382: LD_VAR 0 4
54386: PUSH
54387: LD_INT 1
54389: ARRAY
54390: PUSH
54391: LD_INT 4
54393: ARRAY
54394: PUSH
54395: LD_VAR 0 2
54399: EQUAL
54400: AND
54401: ST_TO_ADDR
// end ;
54402: LD_VAR 0 3
54406: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54407: LD_INT 0
54409: PPUSH
// SetDir ( unit , d ) ;
54410: LD_VAR 0 1
54414: PPUSH
54415: LD_VAR 0 4
54419: PPUSH
54420: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54424: LD_VAR 0 1
54428: PPUSH
54429: LD_VAR 0 2
54433: PPUSH
54434: LD_VAR 0 3
54438: PPUSH
54439: LD_VAR 0 5
54443: PPUSH
54444: CALL_OW 48
// end ;
54448: LD_VAR 0 6
54452: RET
// export function ToNaturalNumber ( number ) ; begin
54453: LD_INT 0
54455: PPUSH
// result := number div 1 ;
54456: LD_ADDR_VAR 0 2
54460: PUSH
54461: LD_VAR 0 1
54465: PUSH
54466: LD_INT 1
54468: DIV
54469: ST_TO_ADDR
// if number < 0 then
54470: LD_VAR 0 1
54474: PUSH
54475: LD_INT 0
54477: LESS
54478: IFFALSE 54488
// result := 0 ;
54480: LD_ADDR_VAR 0 2
54484: PUSH
54485: LD_INT 0
54487: ST_TO_ADDR
// end ;
54488: LD_VAR 0 2
54492: RET
// export function SortByClass ( units , class ) ; var un ; begin
54493: LD_INT 0
54495: PPUSH
54496: PPUSH
// if not units or not class then
54497: LD_VAR 0 1
54501: NOT
54502: PUSH
54503: LD_VAR 0 2
54507: NOT
54508: OR
54509: IFFALSE 54513
// exit ;
54511: GO 54608
// result := [ ] ;
54513: LD_ADDR_VAR 0 3
54517: PUSH
54518: EMPTY
54519: ST_TO_ADDR
// for un in units do
54520: LD_ADDR_VAR 0 4
54524: PUSH
54525: LD_VAR 0 1
54529: PUSH
54530: FOR_IN
54531: IFFALSE 54606
// if GetClass ( un ) = class then
54533: LD_VAR 0 4
54537: PPUSH
54538: CALL_OW 257
54542: PUSH
54543: LD_VAR 0 2
54547: EQUAL
54548: IFFALSE 54575
// result := Insert ( result , 1 , un ) else
54550: LD_ADDR_VAR 0 3
54554: PUSH
54555: LD_VAR 0 3
54559: PPUSH
54560: LD_INT 1
54562: PPUSH
54563: LD_VAR 0 4
54567: PPUSH
54568: CALL_OW 2
54572: ST_TO_ADDR
54573: GO 54604
// result := Replace ( result , result + 1 , un ) ;
54575: LD_ADDR_VAR 0 3
54579: PUSH
54580: LD_VAR 0 3
54584: PPUSH
54585: LD_VAR 0 3
54589: PUSH
54590: LD_INT 1
54592: PLUS
54593: PPUSH
54594: LD_VAR 0 4
54598: PPUSH
54599: CALL_OW 1
54603: ST_TO_ADDR
54604: GO 54530
54606: POP
54607: POP
// end ;
54608: LD_VAR 0 3
54612: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
54613: LD_INT 0
54615: PPUSH
54616: PPUSH
54617: PPUSH
54618: PPUSH
54619: PPUSH
54620: PPUSH
54621: PPUSH
// result := [ ] ;
54622: LD_ADDR_VAR 0 4
54626: PUSH
54627: EMPTY
54628: ST_TO_ADDR
// if x - r < 0 then
54629: LD_VAR 0 1
54633: PUSH
54634: LD_VAR 0 3
54638: MINUS
54639: PUSH
54640: LD_INT 0
54642: LESS
54643: IFFALSE 54655
// min_x := 0 else
54645: LD_ADDR_VAR 0 8
54649: PUSH
54650: LD_INT 0
54652: ST_TO_ADDR
54653: GO 54671
// min_x := x - r ;
54655: LD_ADDR_VAR 0 8
54659: PUSH
54660: LD_VAR 0 1
54664: PUSH
54665: LD_VAR 0 3
54669: MINUS
54670: ST_TO_ADDR
// if y - r < 0 then
54671: LD_VAR 0 2
54675: PUSH
54676: LD_VAR 0 3
54680: MINUS
54681: PUSH
54682: LD_INT 0
54684: LESS
54685: IFFALSE 54697
// min_y := 0 else
54687: LD_ADDR_VAR 0 7
54691: PUSH
54692: LD_INT 0
54694: ST_TO_ADDR
54695: GO 54713
// min_y := y - r ;
54697: LD_ADDR_VAR 0 7
54701: PUSH
54702: LD_VAR 0 2
54706: PUSH
54707: LD_VAR 0 3
54711: MINUS
54712: ST_TO_ADDR
// max_x := x + r ;
54713: LD_ADDR_VAR 0 9
54717: PUSH
54718: LD_VAR 0 1
54722: PUSH
54723: LD_VAR 0 3
54727: PLUS
54728: ST_TO_ADDR
// max_y := y + r ;
54729: LD_ADDR_VAR 0 10
54733: PUSH
54734: LD_VAR 0 2
54738: PUSH
54739: LD_VAR 0 3
54743: PLUS
54744: ST_TO_ADDR
// for _x = min_x to max_x do
54745: LD_ADDR_VAR 0 5
54749: PUSH
54750: DOUBLE
54751: LD_VAR 0 8
54755: DEC
54756: ST_TO_ADDR
54757: LD_VAR 0 9
54761: PUSH
54762: FOR_TO
54763: IFFALSE 54864
// for _y = min_y to max_y do
54765: LD_ADDR_VAR 0 6
54769: PUSH
54770: DOUBLE
54771: LD_VAR 0 7
54775: DEC
54776: ST_TO_ADDR
54777: LD_VAR 0 10
54781: PUSH
54782: FOR_TO
54783: IFFALSE 54860
// begin if not ValidHex ( _x , _y ) then
54785: LD_VAR 0 5
54789: PPUSH
54790: LD_VAR 0 6
54794: PPUSH
54795: CALL_OW 488
54799: NOT
54800: IFFALSE 54804
// continue ;
54802: GO 54782
// if GetResourceTypeXY ( _x , _y ) then
54804: LD_VAR 0 5
54808: PPUSH
54809: LD_VAR 0 6
54813: PPUSH
54814: CALL_OW 283
54818: IFFALSE 54858
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
54820: LD_ADDR_VAR 0 4
54824: PUSH
54825: LD_VAR 0 4
54829: PPUSH
54830: LD_VAR 0 4
54834: PUSH
54835: LD_INT 1
54837: PLUS
54838: PPUSH
54839: LD_VAR 0 5
54843: PUSH
54844: LD_VAR 0 6
54848: PUSH
54849: EMPTY
54850: LIST
54851: LIST
54852: PPUSH
54853: CALL_OW 1
54857: ST_TO_ADDR
// end ;
54858: GO 54782
54860: POP
54861: POP
54862: GO 54762
54864: POP
54865: POP
// end ;
54866: LD_VAR 0 4
54870: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
54871: LD_INT 0
54873: PPUSH
54874: PPUSH
54875: PPUSH
54876: PPUSH
54877: PPUSH
54878: PPUSH
54879: PPUSH
54880: PPUSH
// if not units then
54881: LD_VAR 0 1
54885: NOT
54886: IFFALSE 54890
// exit ;
54888: GO 55416
// result := UnitFilter ( units , [ f_ok ] ) ;
54890: LD_ADDR_VAR 0 3
54894: PUSH
54895: LD_VAR 0 1
54899: PPUSH
54900: LD_INT 50
54902: PUSH
54903: EMPTY
54904: LIST
54905: PPUSH
54906: CALL_OW 72
54910: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
54911: LD_ADDR_VAR 0 8
54915: PUSH
54916: LD_VAR 0 1
54920: PUSH
54921: LD_INT 1
54923: ARRAY
54924: PPUSH
54925: CALL_OW 255
54929: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
54930: LD_ADDR_VAR 0 10
54934: PUSH
54935: LD_INT 29
54937: PUSH
54938: LD_EXP 108
54942: PUSH
54943: LD_INT 49
54945: PUSH
54946: EMPTY
54947: LIST
54948: LIST
54949: LIST
54950: ST_TO_ADDR
// if not result then
54951: LD_VAR 0 3
54955: NOT
54956: IFFALSE 54960
// exit ;
54958: GO 55416
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
54960: LD_ADDR_VAR 0 5
54964: PUSH
54965: LD_INT 81
54967: PUSH
54968: LD_VAR 0 8
54972: PUSH
54973: EMPTY
54974: LIST
54975: LIST
54976: PPUSH
54977: CALL_OW 69
54981: ST_TO_ADDR
// for i in result do
54982: LD_ADDR_VAR 0 4
54986: PUSH
54987: LD_VAR 0 3
54991: PUSH
54992: FOR_IN
54993: IFFALSE 55414
// begin tag := GetTag ( i ) + 1 ;
54995: LD_ADDR_VAR 0 9
54999: PUSH
55000: LD_VAR 0 4
55004: PPUSH
55005: CALL_OW 110
55009: PUSH
55010: LD_INT 1
55012: PLUS
55013: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55014: LD_ADDR_VAR 0 7
55018: PUSH
55019: LD_VAR 0 4
55023: PPUSH
55024: CALL_OW 250
55028: PPUSH
55029: LD_VAR 0 4
55033: PPUSH
55034: CALL_OW 251
55038: PPUSH
55039: LD_INT 6
55041: PPUSH
55042: CALL 54613 0 3
55046: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55047: LD_VAR 0 4
55051: PPUSH
55052: CALL_OW 247
55056: PUSH
55057: LD_INT 2
55059: EQUAL
55060: PUSH
55061: LD_VAR 0 7
55065: AND
55066: PUSH
55067: LD_VAR 0 4
55071: PPUSH
55072: CALL_OW 264
55076: PUSH
55077: LD_VAR 0 10
55081: IN
55082: NOT
55083: AND
55084: IFFALSE 55123
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55086: LD_VAR 0 4
55090: PPUSH
55091: LD_VAR 0 7
55095: PUSH
55096: LD_INT 1
55098: ARRAY
55099: PUSH
55100: LD_INT 1
55102: ARRAY
55103: PPUSH
55104: LD_VAR 0 7
55108: PUSH
55109: LD_INT 1
55111: ARRAY
55112: PUSH
55113: LD_INT 2
55115: ARRAY
55116: PPUSH
55117: CALL_OW 116
55121: GO 55412
// if path > tag then
55123: LD_VAR 0 2
55127: PUSH
55128: LD_VAR 0 9
55132: GREATER
55133: IFFALSE 55341
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55135: LD_ADDR_VAR 0 6
55139: PUSH
55140: LD_VAR 0 5
55144: PPUSH
55145: LD_INT 91
55147: PUSH
55148: LD_VAR 0 4
55152: PUSH
55153: LD_INT 8
55155: PUSH
55156: EMPTY
55157: LIST
55158: LIST
55159: LIST
55160: PPUSH
55161: CALL_OW 72
55165: ST_TO_ADDR
// if nearEnemy then
55166: LD_VAR 0 6
55170: IFFALSE 55239
// begin if GetWeapon ( i ) = ru_time_lapser then
55172: LD_VAR 0 4
55176: PPUSH
55177: CALL_OW 264
55181: PUSH
55182: LD_INT 49
55184: EQUAL
55185: IFFALSE 55213
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55187: LD_VAR 0 4
55191: PPUSH
55192: LD_VAR 0 6
55196: PPUSH
55197: LD_VAR 0 4
55201: PPUSH
55202: CALL_OW 74
55206: PPUSH
55207: CALL_OW 112
55211: GO 55237
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55213: LD_VAR 0 4
55217: PPUSH
55218: LD_VAR 0 6
55222: PPUSH
55223: LD_VAR 0 4
55227: PPUSH
55228: CALL_OW 74
55232: PPUSH
55233: CALL_OW 115
// end else
55237: GO 55339
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55239: LD_VAR 0 4
55243: PPUSH
55244: LD_VAR 0 2
55248: PUSH
55249: LD_VAR 0 9
55253: ARRAY
55254: PUSH
55255: LD_INT 1
55257: ARRAY
55258: PPUSH
55259: LD_VAR 0 2
55263: PUSH
55264: LD_VAR 0 9
55268: ARRAY
55269: PUSH
55270: LD_INT 2
55272: ARRAY
55273: PPUSH
55274: CALL_OW 297
55278: PUSH
55279: LD_INT 6
55281: GREATER
55282: IFFALSE 55325
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55284: LD_VAR 0 4
55288: PPUSH
55289: LD_VAR 0 2
55293: PUSH
55294: LD_VAR 0 9
55298: ARRAY
55299: PUSH
55300: LD_INT 1
55302: ARRAY
55303: PPUSH
55304: LD_VAR 0 2
55308: PUSH
55309: LD_VAR 0 9
55313: ARRAY
55314: PUSH
55315: LD_INT 2
55317: ARRAY
55318: PPUSH
55319: CALL_OW 114
55323: GO 55339
// SetTag ( i , tag ) ;
55325: LD_VAR 0 4
55329: PPUSH
55330: LD_VAR 0 9
55334: PPUSH
55335: CALL_OW 109
// end else
55339: GO 55412
// if enemy then
55341: LD_VAR 0 5
55345: IFFALSE 55412
// begin if GetWeapon ( i ) = ru_time_lapser then
55347: LD_VAR 0 4
55351: PPUSH
55352: CALL_OW 264
55356: PUSH
55357: LD_INT 49
55359: EQUAL
55360: IFFALSE 55388
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55362: LD_VAR 0 4
55366: PPUSH
55367: LD_VAR 0 5
55371: PPUSH
55372: LD_VAR 0 4
55376: PPUSH
55377: CALL_OW 74
55381: PPUSH
55382: CALL_OW 112
55386: GO 55412
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55388: LD_VAR 0 4
55392: PPUSH
55393: LD_VAR 0 5
55397: PPUSH
55398: LD_VAR 0 4
55402: PPUSH
55403: CALL_OW 74
55407: PPUSH
55408: CALL_OW 115
// end ; end ;
55412: GO 54992
55414: POP
55415: POP
// end ;
55416: LD_VAR 0 3
55420: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55421: LD_INT 0
55423: PPUSH
55424: PPUSH
55425: PPUSH
// if not unit or IsInUnit ( unit ) then
55426: LD_VAR 0 1
55430: NOT
55431: PUSH
55432: LD_VAR 0 1
55436: PPUSH
55437: CALL_OW 310
55441: OR
55442: IFFALSE 55446
// exit ;
55444: GO 55537
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55446: LD_ADDR_VAR 0 4
55450: PUSH
55451: LD_VAR 0 1
55455: PPUSH
55456: CALL_OW 250
55460: PPUSH
55461: LD_VAR 0 2
55465: PPUSH
55466: LD_INT 1
55468: PPUSH
55469: CALL_OW 272
55473: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
55474: LD_ADDR_VAR 0 5
55478: PUSH
55479: LD_VAR 0 1
55483: PPUSH
55484: CALL_OW 251
55488: PPUSH
55489: LD_VAR 0 2
55493: PPUSH
55494: LD_INT 1
55496: PPUSH
55497: CALL_OW 273
55501: ST_TO_ADDR
// if ValidHex ( x , y ) then
55502: LD_VAR 0 4
55506: PPUSH
55507: LD_VAR 0 5
55511: PPUSH
55512: CALL_OW 488
55516: IFFALSE 55537
// ComTurnXY ( unit , x , y ) ;
55518: LD_VAR 0 1
55522: PPUSH
55523: LD_VAR 0 4
55527: PPUSH
55528: LD_VAR 0 5
55532: PPUSH
55533: CALL_OW 118
// end ;
55537: LD_VAR 0 3
55541: RET
// export function SeeUnits ( side , units ) ; var i ; begin
55542: LD_INT 0
55544: PPUSH
55545: PPUSH
// result := false ;
55546: LD_ADDR_VAR 0 3
55550: PUSH
55551: LD_INT 0
55553: ST_TO_ADDR
// if not units then
55554: LD_VAR 0 2
55558: NOT
55559: IFFALSE 55563
// exit ;
55561: GO 55608
// for i in units do
55563: LD_ADDR_VAR 0 4
55567: PUSH
55568: LD_VAR 0 2
55572: PUSH
55573: FOR_IN
55574: IFFALSE 55606
// if See ( side , i ) then
55576: LD_VAR 0 1
55580: PPUSH
55581: LD_VAR 0 4
55585: PPUSH
55586: CALL_OW 292
55590: IFFALSE 55604
// begin result := true ;
55592: LD_ADDR_VAR 0 3
55596: PUSH
55597: LD_INT 1
55599: ST_TO_ADDR
// exit ;
55600: POP
55601: POP
55602: GO 55608
// end ;
55604: GO 55573
55606: POP
55607: POP
// end ;
55608: LD_VAR 0 3
55612: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
55613: LD_INT 0
55615: PPUSH
55616: PPUSH
55617: PPUSH
55618: PPUSH
// if not unit or not points then
55619: LD_VAR 0 1
55623: NOT
55624: PUSH
55625: LD_VAR 0 2
55629: NOT
55630: OR
55631: IFFALSE 55635
// exit ;
55633: GO 55725
// dist := 99999 ;
55635: LD_ADDR_VAR 0 5
55639: PUSH
55640: LD_INT 99999
55642: ST_TO_ADDR
// for i in points do
55643: LD_ADDR_VAR 0 4
55647: PUSH
55648: LD_VAR 0 2
55652: PUSH
55653: FOR_IN
55654: IFFALSE 55723
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
55656: LD_ADDR_VAR 0 6
55660: PUSH
55661: LD_VAR 0 1
55665: PPUSH
55666: LD_VAR 0 4
55670: PUSH
55671: LD_INT 1
55673: ARRAY
55674: PPUSH
55675: LD_VAR 0 4
55679: PUSH
55680: LD_INT 2
55682: ARRAY
55683: PPUSH
55684: CALL_OW 297
55688: ST_TO_ADDR
// if tmpDist < dist then
55689: LD_VAR 0 6
55693: PUSH
55694: LD_VAR 0 5
55698: LESS
55699: IFFALSE 55721
// begin result := i ;
55701: LD_ADDR_VAR 0 3
55705: PUSH
55706: LD_VAR 0 4
55710: ST_TO_ADDR
// dist := tmpDist ;
55711: LD_ADDR_VAR 0 5
55715: PUSH
55716: LD_VAR 0 6
55720: ST_TO_ADDR
// end ; end ;
55721: GO 55653
55723: POP
55724: POP
// end ;
55725: LD_VAR 0 3
55729: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
55730: LD_INT 0
55732: PPUSH
// uc_side := side ;
55733: LD_ADDR_OWVAR 20
55737: PUSH
55738: LD_VAR 0 1
55742: ST_TO_ADDR
// uc_nation := 3 ;
55743: LD_ADDR_OWVAR 21
55747: PUSH
55748: LD_INT 3
55750: ST_TO_ADDR
// vc_chassis := 25 ;
55751: LD_ADDR_OWVAR 37
55755: PUSH
55756: LD_INT 25
55758: ST_TO_ADDR
// vc_engine := engine_siberite ;
55759: LD_ADDR_OWVAR 39
55763: PUSH
55764: LD_INT 3
55766: ST_TO_ADDR
// vc_control := control_computer ;
55767: LD_ADDR_OWVAR 38
55771: PUSH
55772: LD_INT 3
55774: ST_TO_ADDR
// vc_weapon := 59 ;
55775: LD_ADDR_OWVAR 40
55779: PUSH
55780: LD_INT 59
55782: ST_TO_ADDR
// result := CreateVehicle ;
55783: LD_ADDR_VAR 0 5
55787: PUSH
55788: CALL_OW 45
55792: ST_TO_ADDR
// SetDir ( result , d ) ;
55793: LD_VAR 0 5
55797: PPUSH
55798: LD_VAR 0 4
55802: PPUSH
55803: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
55807: LD_VAR 0 5
55811: PPUSH
55812: LD_VAR 0 2
55816: PPUSH
55817: LD_VAR 0 3
55821: PPUSH
55822: LD_INT 0
55824: PPUSH
55825: CALL_OW 48
// end ;
55829: LD_VAR 0 5
55833: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
55834: LD_INT 0
55836: PPUSH
55837: PPUSH
55838: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
55839: LD_ADDR_VAR 0 2
55843: PUSH
55844: LD_INT 0
55846: PUSH
55847: LD_INT 0
55849: PUSH
55850: LD_INT 0
55852: PUSH
55853: LD_INT 0
55855: PUSH
55856: EMPTY
55857: LIST
55858: LIST
55859: LIST
55860: LIST
55861: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
55862: LD_VAR 0 1
55866: NOT
55867: PUSH
55868: LD_VAR 0 1
55872: PPUSH
55873: CALL_OW 264
55877: PUSH
55878: LD_INT 12
55880: PUSH
55881: LD_INT 51
55883: PUSH
55884: LD_INT 32
55886: PUSH
55887: LD_EXP 105
55891: PUSH
55892: EMPTY
55893: LIST
55894: LIST
55895: LIST
55896: LIST
55897: IN
55898: NOT
55899: OR
55900: IFFALSE 55904
// exit ;
55902: GO 56002
// for i := 1 to 3 do
55904: LD_ADDR_VAR 0 3
55908: PUSH
55909: DOUBLE
55910: LD_INT 1
55912: DEC
55913: ST_TO_ADDR
55914: LD_INT 3
55916: PUSH
55917: FOR_TO
55918: IFFALSE 56000
// begin tmp := GetCargo ( cargo , i ) ;
55920: LD_ADDR_VAR 0 4
55924: PUSH
55925: LD_VAR 0 1
55929: PPUSH
55930: LD_VAR 0 3
55934: PPUSH
55935: CALL_OW 289
55939: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
55940: LD_ADDR_VAR 0 2
55944: PUSH
55945: LD_VAR 0 2
55949: PPUSH
55950: LD_VAR 0 3
55954: PPUSH
55955: LD_VAR 0 4
55959: PPUSH
55960: CALL_OW 1
55964: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
55965: LD_ADDR_VAR 0 2
55969: PUSH
55970: LD_VAR 0 2
55974: PPUSH
55975: LD_INT 4
55977: PPUSH
55978: LD_VAR 0 2
55982: PUSH
55983: LD_INT 4
55985: ARRAY
55986: PUSH
55987: LD_VAR 0 4
55991: PLUS
55992: PPUSH
55993: CALL_OW 1
55997: ST_TO_ADDR
// end ;
55998: GO 55917
56000: POP
56001: POP
// end ;
56002: LD_VAR 0 2
56006: RET
// export function Length ( array ) ; begin
56007: LD_INT 0
56009: PPUSH
// result := array + 0 ;
56010: LD_ADDR_VAR 0 2
56014: PUSH
56015: LD_VAR 0 1
56019: PUSH
56020: LD_INT 0
56022: PLUS
56023: ST_TO_ADDR
// end ;
56024: LD_VAR 0 2
56028: RET
// export function PrepareArray ( array ) ; begin
56029: LD_INT 0
56031: PPUSH
// result := array diff 0 ;
56032: LD_ADDR_VAR 0 2
56036: PUSH
56037: LD_VAR 0 1
56041: PUSH
56042: LD_INT 0
56044: DIFF
56045: ST_TO_ADDR
// if not result [ 1 ] then
56046: LD_VAR 0 2
56050: PUSH
56051: LD_INT 1
56053: ARRAY
56054: NOT
56055: IFFALSE 56075
// result := Delete ( result , 1 ) ;
56057: LD_ADDR_VAR 0 2
56061: PUSH
56062: LD_VAR 0 2
56066: PPUSH
56067: LD_INT 1
56069: PPUSH
56070: CALL_OW 3
56074: ST_TO_ADDR
// end ; end_of_file
56075: LD_VAR 0 2
56079: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
56080: LD_INT 0
56082: PPUSH
56083: PPUSH
// skirmish := false ;
56084: LD_ADDR_EXP 58
56088: PUSH
56089: LD_INT 0
56091: ST_TO_ADDR
// debug_mc := false ;
56092: LD_ADDR_EXP 59
56096: PUSH
56097: LD_INT 0
56099: ST_TO_ADDR
// mc_bases := [ ] ;
56100: LD_ADDR_EXP 60
56104: PUSH
56105: EMPTY
56106: ST_TO_ADDR
// mc_sides := [ ] ;
56107: LD_ADDR_EXP 86
56111: PUSH
56112: EMPTY
56113: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
56114: LD_ADDR_EXP 61
56118: PUSH
56119: EMPTY
56120: ST_TO_ADDR
// mc_building_repairs := [ ] ;
56121: LD_ADDR_EXP 62
56125: PUSH
56126: EMPTY
56127: ST_TO_ADDR
// mc_need_heal := [ ] ;
56128: LD_ADDR_EXP 63
56132: PUSH
56133: EMPTY
56134: ST_TO_ADDR
// mc_healers := [ ] ;
56135: LD_ADDR_EXP 64
56139: PUSH
56140: EMPTY
56141: ST_TO_ADDR
// mc_build_list := [ ] ;
56142: LD_ADDR_EXP 65
56146: PUSH
56147: EMPTY
56148: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
56149: LD_ADDR_EXP 92
56153: PUSH
56154: EMPTY
56155: ST_TO_ADDR
// mc_builders := [ ] ;
56156: LD_ADDR_EXP 66
56160: PUSH
56161: EMPTY
56162: ST_TO_ADDR
// mc_construct_list := [ ] ;
56163: LD_ADDR_EXP 67
56167: PUSH
56168: EMPTY
56169: ST_TO_ADDR
// mc_turret_list := [ ] ;
56170: LD_ADDR_EXP 68
56174: PUSH
56175: EMPTY
56176: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
56177: LD_ADDR_EXP 69
56181: PUSH
56182: EMPTY
56183: ST_TO_ADDR
// mc_miners := [ ] ;
56184: LD_ADDR_EXP 74
56188: PUSH
56189: EMPTY
56190: ST_TO_ADDR
// mc_mines := [ ] ;
56191: LD_ADDR_EXP 73
56195: PUSH
56196: EMPTY
56197: ST_TO_ADDR
// mc_minefields := [ ] ;
56198: LD_ADDR_EXP 75
56202: PUSH
56203: EMPTY
56204: ST_TO_ADDR
// mc_crates := [ ] ;
56205: LD_ADDR_EXP 76
56209: PUSH
56210: EMPTY
56211: ST_TO_ADDR
// mc_crates_collector := [ ] ;
56212: LD_ADDR_EXP 77
56216: PUSH
56217: EMPTY
56218: ST_TO_ADDR
// mc_crates_area := [ ] ;
56219: LD_ADDR_EXP 78
56223: PUSH
56224: EMPTY
56225: ST_TO_ADDR
// mc_vehicles := [ ] ;
56226: LD_ADDR_EXP 79
56230: PUSH
56231: EMPTY
56232: ST_TO_ADDR
// mc_attack := [ ] ;
56233: LD_ADDR_EXP 80
56237: PUSH
56238: EMPTY
56239: ST_TO_ADDR
// mc_produce := [ ] ;
56240: LD_ADDR_EXP 81
56244: PUSH
56245: EMPTY
56246: ST_TO_ADDR
// mc_defender := [ ] ;
56247: LD_ADDR_EXP 82
56251: PUSH
56252: EMPTY
56253: ST_TO_ADDR
// mc_parking := [ ] ;
56254: LD_ADDR_EXP 84
56258: PUSH
56259: EMPTY
56260: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
56261: LD_ADDR_EXP 70
56265: PUSH
56266: EMPTY
56267: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
56268: LD_ADDR_EXP 72
56272: PUSH
56273: EMPTY
56274: ST_TO_ADDR
// mc_scan := [ ] ;
56275: LD_ADDR_EXP 83
56279: PUSH
56280: EMPTY
56281: ST_TO_ADDR
// mc_scan_area := [ ] ;
56282: LD_ADDR_EXP 85
56286: PUSH
56287: EMPTY
56288: ST_TO_ADDR
// mc_tech := [ ] ;
56289: LD_ADDR_EXP 87
56293: PUSH
56294: EMPTY
56295: ST_TO_ADDR
// mc_class := [ ] ;
56296: LD_ADDR_EXP 101
56300: PUSH
56301: EMPTY
56302: ST_TO_ADDR
// mc_class_case_use := [ ] ;
56303: LD_ADDR_EXP 102
56307: PUSH
56308: EMPTY
56309: ST_TO_ADDR
// mc_is_defending := [ ] ;
56310: LD_ADDR_EXP 103
56314: PUSH
56315: EMPTY
56316: ST_TO_ADDR
// end ;
56317: LD_VAR 0 1
56321: RET
// export function MC_Kill ( base ) ; begin
56322: LD_INT 0
56324: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
56325: LD_ADDR_EXP 60
56329: PUSH
56330: LD_EXP 60
56334: PPUSH
56335: LD_VAR 0 1
56339: PPUSH
56340: EMPTY
56341: PPUSH
56342: CALL_OW 1
56346: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
56347: LD_ADDR_EXP 61
56351: PUSH
56352: LD_EXP 61
56356: PPUSH
56357: LD_VAR 0 1
56361: PPUSH
56362: EMPTY
56363: PPUSH
56364: CALL_OW 1
56368: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
56369: LD_ADDR_EXP 62
56373: PUSH
56374: LD_EXP 62
56378: PPUSH
56379: LD_VAR 0 1
56383: PPUSH
56384: EMPTY
56385: PPUSH
56386: CALL_OW 1
56390: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
56391: LD_ADDR_EXP 63
56395: PUSH
56396: LD_EXP 63
56400: PPUSH
56401: LD_VAR 0 1
56405: PPUSH
56406: EMPTY
56407: PPUSH
56408: CALL_OW 1
56412: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
56413: LD_ADDR_EXP 64
56417: PUSH
56418: LD_EXP 64
56422: PPUSH
56423: LD_VAR 0 1
56427: PPUSH
56428: EMPTY
56429: PPUSH
56430: CALL_OW 1
56434: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
56435: LD_ADDR_EXP 65
56439: PUSH
56440: LD_EXP 65
56444: PPUSH
56445: LD_VAR 0 1
56449: PPUSH
56450: EMPTY
56451: PPUSH
56452: CALL_OW 1
56456: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
56457: LD_ADDR_EXP 66
56461: PUSH
56462: LD_EXP 66
56466: PPUSH
56467: LD_VAR 0 1
56471: PPUSH
56472: EMPTY
56473: PPUSH
56474: CALL_OW 1
56478: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
56479: LD_ADDR_EXP 67
56483: PUSH
56484: LD_EXP 67
56488: PPUSH
56489: LD_VAR 0 1
56493: PPUSH
56494: EMPTY
56495: PPUSH
56496: CALL_OW 1
56500: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
56501: LD_ADDR_EXP 68
56505: PUSH
56506: LD_EXP 68
56510: PPUSH
56511: LD_VAR 0 1
56515: PPUSH
56516: EMPTY
56517: PPUSH
56518: CALL_OW 1
56522: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
56523: LD_ADDR_EXP 69
56527: PUSH
56528: LD_EXP 69
56532: PPUSH
56533: LD_VAR 0 1
56537: PPUSH
56538: EMPTY
56539: PPUSH
56540: CALL_OW 1
56544: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
56545: LD_ADDR_EXP 70
56549: PUSH
56550: LD_EXP 70
56554: PPUSH
56555: LD_VAR 0 1
56559: PPUSH
56560: EMPTY
56561: PPUSH
56562: CALL_OW 1
56566: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
56567: LD_ADDR_EXP 71
56571: PUSH
56572: LD_EXP 71
56576: PPUSH
56577: LD_VAR 0 1
56581: PPUSH
56582: LD_INT 0
56584: PPUSH
56585: CALL_OW 1
56589: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
56590: LD_ADDR_EXP 72
56594: PUSH
56595: LD_EXP 72
56599: PPUSH
56600: LD_VAR 0 1
56604: PPUSH
56605: EMPTY
56606: PPUSH
56607: CALL_OW 1
56611: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
56612: LD_ADDR_EXP 73
56616: PUSH
56617: LD_EXP 73
56621: PPUSH
56622: LD_VAR 0 1
56626: PPUSH
56627: EMPTY
56628: PPUSH
56629: CALL_OW 1
56633: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
56634: LD_ADDR_EXP 74
56638: PUSH
56639: LD_EXP 74
56643: PPUSH
56644: LD_VAR 0 1
56648: PPUSH
56649: EMPTY
56650: PPUSH
56651: CALL_OW 1
56655: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
56656: LD_ADDR_EXP 75
56660: PUSH
56661: LD_EXP 75
56665: PPUSH
56666: LD_VAR 0 1
56670: PPUSH
56671: EMPTY
56672: PPUSH
56673: CALL_OW 1
56677: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
56678: LD_ADDR_EXP 76
56682: PUSH
56683: LD_EXP 76
56687: PPUSH
56688: LD_VAR 0 1
56692: PPUSH
56693: EMPTY
56694: PPUSH
56695: CALL_OW 1
56699: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
56700: LD_ADDR_EXP 77
56704: PUSH
56705: LD_EXP 77
56709: PPUSH
56710: LD_VAR 0 1
56714: PPUSH
56715: EMPTY
56716: PPUSH
56717: CALL_OW 1
56721: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
56722: LD_ADDR_EXP 78
56726: PUSH
56727: LD_EXP 78
56731: PPUSH
56732: LD_VAR 0 1
56736: PPUSH
56737: EMPTY
56738: PPUSH
56739: CALL_OW 1
56743: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
56744: LD_ADDR_EXP 79
56748: PUSH
56749: LD_EXP 79
56753: PPUSH
56754: LD_VAR 0 1
56758: PPUSH
56759: EMPTY
56760: PPUSH
56761: CALL_OW 1
56765: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
56766: LD_ADDR_EXP 80
56770: PUSH
56771: LD_EXP 80
56775: PPUSH
56776: LD_VAR 0 1
56780: PPUSH
56781: EMPTY
56782: PPUSH
56783: CALL_OW 1
56787: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
56788: LD_ADDR_EXP 81
56792: PUSH
56793: LD_EXP 81
56797: PPUSH
56798: LD_VAR 0 1
56802: PPUSH
56803: EMPTY
56804: PPUSH
56805: CALL_OW 1
56809: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
56810: LD_ADDR_EXP 82
56814: PUSH
56815: LD_EXP 82
56819: PPUSH
56820: LD_VAR 0 1
56824: PPUSH
56825: EMPTY
56826: PPUSH
56827: CALL_OW 1
56831: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
56832: LD_ADDR_EXP 83
56836: PUSH
56837: LD_EXP 83
56841: PPUSH
56842: LD_VAR 0 1
56846: PPUSH
56847: EMPTY
56848: PPUSH
56849: CALL_OW 1
56853: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
56854: LD_ADDR_EXP 84
56858: PUSH
56859: LD_EXP 84
56863: PPUSH
56864: LD_VAR 0 1
56868: PPUSH
56869: EMPTY
56870: PPUSH
56871: CALL_OW 1
56875: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
56876: LD_ADDR_EXP 85
56880: PUSH
56881: LD_EXP 85
56885: PPUSH
56886: LD_VAR 0 1
56890: PPUSH
56891: EMPTY
56892: PPUSH
56893: CALL_OW 1
56897: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
56898: LD_ADDR_EXP 87
56902: PUSH
56903: LD_EXP 87
56907: PPUSH
56908: LD_VAR 0 1
56912: PPUSH
56913: EMPTY
56914: PPUSH
56915: CALL_OW 1
56919: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
56920: LD_ADDR_EXP 89
56924: PUSH
56925: LD_EXP 89
56929: PPUSH
56930: LD_VAR 0 1
56934: PPUSH
56935: EMPTY
56936: PPUSH
56937: CALL_OW 1
56941: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
56942: LD_ADDR_EXP 90
56946: PUSH
56947: LD_EXP 90
56951: PPUSH
56952: LD_VAR 0 1
56956: PPUSH
56957: EMPTY
56958: PPUSH
56959: CALL_OW 1
56963: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
56964: LD_ADDR_EXP 91
56968: PUSH
56969: LD_EXP 91
56973: PPUSH
56974: LD_VAR 0 1
56978: PPUSH
56979: EMPTY
56980: PPUSH
56981: CALL_OW 1
56985: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
56986: LD_ADDR_EXP 92
56990: PUSH
56991: LD_EXP 92
56995: PPUSH
56996: LD_VAR 0 1
57000: PPUSH
57001: EMPTY
57002: PPUSH
57003: CALL_OW 1
57007: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57008: LD_ADDR_EXP 93
57012: PUSH
57013: LD_EXP 93
57017: PPUSH
57018: LD_VAR 0 1
57022: PPUSH
57023: EMPTY
57024: PPUSH
57025: CALL_OW 1
57029: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57030: LD_ADDR_EXP 94
57034: PUSH
57035: LD_EXP 94
57039: PPUSH
57040: LD_VAR 0 1
57044: PPUSH
57045: EMPTY
57046: PPUSH
57047: CALL_OW 1
57051: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57052: LD_ADDR_EXP 95
57056: PUSH
57057: LD_EXP 95
57061: PPUSH
57062: LD_VAR 0 1
57066: PPUSH
57067: EMPTY
57068: PPUSH
57069: CALL_OW 1
57073: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57074: LD_ADDR_EXP 96
57078: PUSH
57079: LD_EXP 96
57083: PPUSH
57084: LD_VAR 0 1
57088: PPUSH
57089: EMPTY
57090: PPUSH
57091: CALL_OW 1
57095: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57096: LD_ADDR_EXP 97
57100: PUSH
57101: LD_EXP 97
57105: PPUSH
57106: LD_VAR 0 1
57110: PPUSH
57111: EMPTY
57112: PPUSH
57113: CALL_OW 1
57117: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
57118: LD_ADDR_EXP 98
57122: PUSH
57123: LD_EXP 98
57127: PPUSH
57128: LD_VAR 0 1
57132: PPUSH
57133: EMPTY
57134: PPUSH
57135: CALL_OW 1
57139: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
57140: LD_ADDR_EXP 99
57144: PUSH
57145: LD_EXP 99
57149: PPUSH
57150: LD_VAR 0 1
57154: PPUSH
57155: EMPTY
57156: PPUSH
57157: CALL_OW 1
57161: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
57162: LD_ADDR_EXP 100
57166: PUSH
57167: LD_EXP 100
57171: PPUSH
57172: LD_VAR 0 1
57176: PPUSH
57177: EMPTY
57178: PPUSH
57179: CALL_OW 1
57183: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
57184: LD_ADDR_EXP 101
57188: PUSH
57189: LD_EXP 101
57193: PPUSH
57194: LD_VAR 0 1
57198: PPUSH
57199: EMPTY
57200: PPUSH
57201: CALL_OW 1
57205: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
57206: LD_ADDR_EXP 102
57210: PUSH
57211: LD_EXP 102
57215: PPUSH
57216: LD_VAR 0 1
57220: PPUSH
57221: LD_INT 0
57223: PPUSH
57224: CALL_OW 1
57228: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
57229: LD_ADDR_EXP 103
57233: PUSH
57234: LD_EXP 103
57238: PPUSH
57239: LD_VAR 0 1
57243: PPUSH
57244: LD_INT 0
57246: PPUSH
57247: CALL_OW 1
57251: ST_TO_ADDR
// end ;
57252: LD_VAR 0 2
57256: RET
// export function MC_Add ( side , units ) ; var base ; begin
57257: LD_INT 0
57259: PPUSH
57260: PPUSH
// base := mc_bases + 1 ;
57261: LD_ADDR_VAR 0 4
57265: PUSH
57266: LD_EXP 60
57270: PUSH
57271: LD_INT 1
57273: PLUS
57274: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
57275: LD_ADDR_EXP 86
57279: PUSH
57280: LD_EXP 86
57284: PPUSH
57285: LD_VAR 0 4
57289: PPUSH
57290: LD_VAR 0 1
57294: PPUSH
57295: CALL_OW 1
57299: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
57300: LD_ADDR_EXP 60
57304: PUSH
57305: LD_EXP 60
57309: PPUSH
57310: LD_VAR 0 4
57314: PPUSH
57315: LD_VAR 0 2
57319: PPUSH
57320: CALL_OW 1
57324: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57325: LD_ADDR_EXP 61
57329: PUSH
57330: LD_EXP 61
57334: PPUSH
57335: LD_VAR 0 4
57339: PPUSH
57340: EMPTY
57341: PPUSH
57342: CALL_OW 1
57346: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57347: LD_ADDR_EXP 62
57351: PUSH
57352: LD_EXP 62
57356: PPUSH
57357: LD_VAR 0 4
57361: PPUSH
57362: EMPTY
57363: PPUSH
57364: CALL_OW 1
57368: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57369: LD_ADDR_EXP 63
57373: PUSH
57374: LD_EXP 63
57378: PPUSH
57379: LD_VAR 0 4
57383: PPUSH
57384: EMPTY
57385: PPUSH
57386: CALL_OW 1
57390: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57391: LD_ADDR_EXP 64
57395: PUSH
57396: LD_EXP 64
57400: PPUSH
57401: LD_VAR 0 4
57405: PPUSH
57406: EMPTY
57407: PPUSH
57408: CALL_OW 1
57412: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57413: LD_ADDR_EXP 65
57417: PUSH
57418: LD_EXP 65
57422: PPUSH
57423: LD_VAR 0 4
57427: PPUSH
57428: EMPTY
57429: PPUSH
57430: CALL_OW 1
57434: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57435: LD_ADDR_EXP 66
57439: PUSH
57440: LD_EXP 66
57444: PPUSH
57445: LD_VAR 0 4
57449: PPUSH
57450: EMPTY
57451: PPUSH
57452: CALL_OW 1
57456: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57457: LD_ADDR_EXP 67
57461: PUSH
57462: LD_EXP 67
57466: PPUSH
57467: LD_VAR 0 4
57471: PPUSH
57472: EMPTY
57473: PPUSH
57474: CALL_OW 1
57478: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57479: LD_ADDR_EXP 68
57483: PUSH
57484: LD_EXP 68
57488: PPUSH
57489: LD_VAR 0 4
57493: PPUSH
57494: EMPTY
57495: PPUSH
57496: CALL_OW 1
57500: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57501: LD_ADDR_EXP 69
57505: PUSH
57506: LD_EXP 69
57510: PPUSH
57511: LD_VAR 0 4
57515: PPUSH
57516: EMPTY
57517: PPUSH
57518: CALL_OW 1
57522: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57523: LD_ADDR_EXP 70
57527: PUSH
57528: LD_EXP 70
57532: PPUSH
57533: LD_VAR 0 4
57537: PPUSH
57538: EMPTY
57539: PPUSH
57540: CALL_OW 1
57544: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57545: LD_ADDR_EXP 71
57549: PUSH
57550: LD_EXP 71
57554: PPUSH
57555: LD_VAR 0 4
57559: PPUSH
57560: LD_INT 0
57562: PPUSH
57563: CALL_OW 1
57567: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57568: LD_ADDR_EXP 72
57572: PUSH
57573: LD_EXP 72
57577: PPUSH
57578: LD_VAR 0 4
57582: PPUSH
57583: EMPTY
57584: PPUSH
57585: CALL_OW 1
57589: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57590: LD_ADDR_EXP 73
57594: PUSH
57595: LD_EXP 73
57599: PPUSH
57600: LD_VAR 0 4
57604: PPUSH
57605: EMPTY
57606: PPUSH
57607: CALL_OW 1
57611: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57612: LD_ADDR_EXP 74
57616: PUSH
57617: LD_EXP 74
57621: PPUSH
57622: LD_VAR 0 4
57626: PPUSH
57627: EMPTY
57628: PPUSH
57629: CALL_OW 1
57633: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57634: LD_ADDR_EXP 75
57638: PUSH
57639: LD_EXP 75
57643: PPUSH
57644: LD_VAR 0 4
57648: PPUSH
57649: EMPTY
57650: PPUSH
57651: CALL_OW 1
57655: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57656: LD_ADDR_EXP 76
57660: PUSH
57661: LD_EXP 76
57665: PPUSH
57666: LD_VAR 0 4
57670: PPUSH
57671: EMPTY
57672: PPUSH
57673: CALL_OW 1
57677: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57678: LD_ADDR_EXP 77
57682: PUSH
57683: LD_EXP 77
57687: PPUSH
57688: LD_VAR 0 4
57692: PPUSH
57693: EMPTY
57694: PPUSH
57695: CALL_OW 1
57699: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57700: LD_ADDR_EXP 78
57704: PUSH
57705: LD_EXP 78
57709: PPUSH
57710: LD_VAR 0 4
57714: PPUSH
57715: EMPTY
57716: PPUSH
57717: CALL_OW 1
57721: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57722: LD_ADDR_EXP 79
57726: PUSH
57727: LD_EXP 79
57731: PPUSH
57732: LD_VAR 0 4
57736: PPUSH
57737: EMPTY
57738: PPUSH
57739: CALL_OW 1
57743: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57744: LD_ADDR_EXP 80
57748: PUSH
57749: LD_EXP 80
57753: PPUSH
57754: LD_VAR 0 4
57758: PPUSH
57759: EMPTY
57760: PPUSH
57761: CALL_OW 1
57765: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57766: LD_ADDR_EXP 81
57770: PUSH
57771: LD_EXP 81
57775: PPUSH
57776: LD_VAR 0 4
57780: PPUSH
57781: EMPTY
57782: PPUSH
57783: CALL_OW 1
57787: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57788: LD_ADDR_EXP 82
57792: PUSH
57793: LD_EXP 82
57797: PPUSH
57798: LD_VAR 0 4
57802: PPUSH
57803: EMPTY
57804: PPUSH
57805: CALL_OW 1
57809: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57810: LD_ADDR_EXP 83
57814: PUSH
57815: LD_EXP 83
57819: PPUSH
57820: LD_VAR 0 4
57824: PPUSH
57825: EMPTY
57826: PPUSH
57827: CALL_OW 1
57831: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57832: LD_ADDR_EXP 84
57836: PUSH
57837: LD_EXP 84
57841: PPUSH
57842: LD_VAR 0 4
57846: PPUSH
57847: EMPTY
57848: PPUSH
57849: CALL_OW 1
57853: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57854: LD_ADDR_EXP 85
57858: PUSH
57859: LD_EXP 85
57863: PPUSH
57864: LD_VAR 0 4
57868: PPUSH
57869: EMPTY
57870: PPUSH
57871: CALL_OW 1
57875: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57876: LD_ADDR_EXP 87
57880: PUSH
57881: LD_EXP 87
57885: PPUSH
57886: LD_VAR 0 4
57890: PPUSH
57891: EMPTY
57892: PPUSH
57893: CALL_OW 1
57897: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57898: LD_ADDR_EXP 89
57902: PUSH
57903: LD_EXP 89
57907: PPUSH
57908: LD_VAR 0 4
57912: PPUSH
57913: EMPTY
57914: PPUSH
57915: CALL_OW 1
57919: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57920: LD_ADDR_EXP 90
57924: PUSH
57925: LD_EXP 90
57929: PPUSH
57930: LD_VAR 0 4
57934: PPUSH
57935: EMPTY
57936: PPUSH
57937: CALL_OW 1
57941: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57942: LD_ADDR_EXP 91
57946: PUSH
57947: LD_EXP 91
57951: PPUSH
57952: LD_VAR 0 4
57956: PPUSH
57957: EMPTY
57958: PPUSH
57959: CALL_OW 1
57963: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57964: LD_ADDR_EXP 92
57968: PUSH
57969: LD_EXP 92
57973: PPUSH
57974: LD_VAR 0 4
57978: PPUSH
57979: EMPTY
57980: PPUSH
57981: CALL_OW 1
57985: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57986: LD_ADDR_EXP 93
57990: PUSH
57991: LD_EXP 93
57995: PPUSH
57996: LD_VAR 0 4
58000: PPUSH
58001: EMPTY
58002: PPUSH
58003: CALL_OW 1
58007: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58008: LD_ADDR_EXP 94
58012: PUSH
58013: LD_EXP 94
58017: PPUSH
58018: LD_VAR 0 4
58022: PPUSH
58023: EMPTY
58024: PPUSH
58025: CALL_OW 1
58029: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58030: LD_ADDR_EXP 95
58034: PUSH
58035: LD_EXP 95
58039: PPUSH
58040: LD_VAR 0 4
58044: PPUSH
58045: EMPTY
58046: PPUSH
58047: CALL_OW 1
58051: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58052: LD_ADDR_EXP 96
58056: PUSH
58057: LD_EXP 96
58061: PPUSH
58062: LD_VAR 0 4
58066: PPUSH
58067: EMPTY
58068: PPUSH
58069: CALL_OW 1
58073: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58074: LD_ADDR_EXP 97
58078: PUSH
58079: LD_EXP 97
58083: PPUSH
58084: LD_VAR 0 4
58088: PPUSH
58089: EMPTY
58090: PPUSH
58091: CALL_OW 1
58095: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58096: LD_ADDR_EXP 98
58100: PUSH
58101: LD_EXP 98
58105: PPUSH
58106: LD_VAR 0 4
58110: PPUSH
58111: EMPTY
58112: PPUSH
58113: CALL_OW 1
58117: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58118: LD_ADDR_EXP 99
58122: PUSH
58123: LD_EXP 99
58127: PPUSH
58128: LD_VAR 0 4
58132: PPUSH
58133: EMPTY
58134: PPUSH
58135: CALL_OW 1
58139: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58140: LD_ADDR_EXP 100
58144: PUSH
58145: LD_EXP 100
58149: PPUSH
58150: LD_VAR 0 4
58154: PPUSH
58155: EMPTY
58156: PPUSH
58157: CALL_OW 1
58161: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58162: LD_ADDR_EXP 101
58166: PUSH
58167: LD_EXP 101
58171: PPUSH
58172: LD_VAR 0 4
58176: PPUSH
58177: EMPTY
58178: PPUSH
58179: CALL_OW 1
58183: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58184: LD_ADDR_EXP 102
58188: PUSH
58189: LD_EXP 102
58193: PPUSH
58194: LD_VAR 0 4
58198: PPUSH
58199: LD_INT 0
58201: PPUSH
58202: CALL_OW 1
58206: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58207: LD_ADDR_EXP 103
58211: PUSH
58212: LD_EXP 103
58216: PPUSH
58217: LD_VAR 0 4
58221: PPUSH
58222: LD_INT 0
58224: PPUSH
58225: CALL_OW 1
58229: ST_TO_ADDR
// result := base ;
58230: LD_ADDR_VAR 0 3
58234: PUSH
58235: LD_VAR 0 4
58239: ST_TO_ADDR
// end ;
58240: LD_VAR 0 3
58244: RET
// export function MC_Start ( ) ; var i ; begin
58245: LD_INT 0
58247: PPUSH
58248: PPUSH
// for i = 1 to mc_bases do
58249: LD_ADDR_VAR 0 2
58253: PUSH
58254: DOUBLE
58255: LD_INT 1
58257: DEC
58258: ST_TO_ADDR
58259: LD_EXP 60
58263: PUSH
58264: FOR_TO
58265: IFFALSE 59365
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
58267: LD_ADDR_EXP 60
58271: PUSH
58272: LD_EXP 60
58276: PPUSH
58277: LD_VAR 0 2
58281: PPUSH
58282: LD_EXP 60
58286: PUSH
58287: LD_VAR 0 2
58291: ARRAY
58292: PUSH
58293: LD_INT 0
58295: DIFF
58296: PPUSH
58297: CALL_OW 1
58301: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
58302: LD_ADDR_EXP 61
58306: PUSH
58307: LD_EXP 61
58311: PPUSH
58312: LD_VAR 0 2
58316: PPUSH
58317: EMPTY
58318: PPUSH
58319: CALL_OW 1
58323: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
58324: LD_ADDR_EXP 62
58328: PUSH
58329: LD_EXP 62
58333: PPUSH
58334: LD_VAR 0 2
58338: PPUSH
58339: EMPTY
58340: PPUSH
58341: CALL_OW 1
58345: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
58346: LD_ADDR_EXP 63
58350: PUSH
58351: LD_EXP 63
58355: PPUSH
58356: LD_VAR 0 2
58360: PPUSH
58361: EMPTY
58362: PPUSH
58363: CALL_OW 1
58367: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
58368: LD_ADDR_EXP 64
58372: PUSH
58373: LD_EXP 64
58377: PPUSH
58378: LD_VAR 0 2
58382: PPUSH
58383: EMPTY
58384: PUSH
58385: EMPTY
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PPUSH
58391: CALL_OW 1
58395: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
58396: LD_ADDR_EXP 65
58400: PUSH
58401: LD_EXP 65
58405: PPUSH
58406: LD_VAR 0 2
58410: PPUSH
58411: EMPTY
58412: PPUSH
58413: CALL_OW 1
58417: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
58418: LD_ADDR_EXP 92
58422: PUSH
58423: LD_EXP 92
58427: PPUSH
58428: LD_VAR 0 2
58432: PPUSH
58433: EMPTY
58434: PPUSH
58435: CALL_OW 1
58439: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
58440: LD_ADDR_EXP 66
58444: PUSH
58445: LD_EXP 66
58449: PPUSH
58450: LD_VAR 0 2
58454: PPUSH
58455: EMPTY
58456: PPUSH
58457: CALL_OW 1
58461: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
58462: LD_ADDR_EXP 67
58466: PUSH
58467: LD_EXP 67
58471: PPUSH
58472: LD_VAR 0 2
58476: PPUSH
58477: EMPTY
58478: PPUSH
58479: CALL_OW 1
58483: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
58484: LD_ADDR_EXP 68
58488: PUSH
58489: LD_EXP 68
58493: PPUSH
58494: LD_VAR 0 2
58498: PPUSH
58499: LD_EXP 60
58503: PUSH
58504: LD_VAR 0 2
58508: ARRAY
58509: PPUSH
58510: LD_INT 2
58512: PUSH
58513: LD_INT 30
58515: PUSH
58516: LD_INT 32
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: PUSH
58523: LD_INT 30
58525: PUSH
58526: LD_INT 33
58528: PUSH
58529: EMPTY
58530: LIST
58531: LIST
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: LIST
58537: PPUSH
58538: CALL_OW 72
58542: PPUSH
58543: CALL_OW 1
58547: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
58548: LD_ADDR_EXP 69
58552: PUSH
58553: LD_EXP 69
58557: PPUSH
58558: LD_VAR 0 2
58562: PPUSH
58563: LD_EXP 60
58567: PUSH
58568: LD_VAR 0 2
58572: ARRAY
58573: PPUSH
58574: LD_INT 2
58576: PUSH
58577: LD_INT 30
58579: PUSH
58580: LD_INT 32
58582: PUSH
58583: EMPTY
58584: LIST
58585: LIST
58586: PUSH
58587: LD_INT 30
58589: PUSH
58590: LD_INT 31
58592: PUSH
58593: EMPTY
58594: LIST
58595: LIST
58596: PUSH
58597: EMPTY
58598: LIST
58599: LIST
58600: LIST
58601: PUSH
58602: LD_INT 58
58604: PUSH
58605: EMPTY
58606: LIST
58607: PUSH
58608: EMPTY
58609: LIST
58610: LIST
58611: PPUSH
58612: CALL_OW 72
58616: PPUSH
58617: CALL_OW 1
58621: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
58622: LD_ADDR_EXP 70
58626: PUSH
58627: LD_EXP 70
58631: PPUSH
58632: LD_VAR 0 2
58636: PPUSH
58637: EMPTY
58638: PPUSH
58639: CALL_OW 1
58643: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
58644: LD_ADDR_EXP 74
58648: PUSH
58649: LD_EXP 74
58653: PPUSH
58654: LD_VAR 0 2
58658: PPUSH
58659: EMPTY
58660: PPUSH
58661: CALL_OW 1
58665: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
58666: LD_ADDR_EXP 73
58670: PUSH
58671: LD_EXP 73
58675: PPUSH
58676: LD_VAR 0 2
58680: PPUSH
58681: EMPTY
58682: PPUSH
58683: CALL_OW 1
58687: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
58688: LD_ADDR_EXP 75
58692: PUSH
58693: LD_EXP 75
58697: PPUSH
58698: LD_VAR 0 2
58702: PPUSH
58703: EMPTY
58704: PPUSH
58705: CALL_OW 1
58709: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
58710: LD_ADDR_EXP 76
58714: PUSH
58715: LD_EXP 76
58719: PPUSH
58720: LD_VAR 0 2
58724: PPUSH
58725: EMPTY
58726: PPUSH
58727: CALL_OW 1
58731: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
58732: LD_ADDR_EXP 77
58736: PUSH
58737: LD_EXP 77
58741: PPUSH
58742: LD_VAR 0 2
58746: PPUSH
58747: EMPTY
58748: PPUSH
58749: CALL_OW 1
58753: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
58754: LD_ADDR_EXP 78
58758: PUSH
58759: LD_EXP 78
58763: PPUSH
58764: LD_VAR 0 2
58768: PPUSH
58769: EMPTY
58770: PPUSH
58771: CALL_OW 1
58775: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
58776: LD_ADDR_EXP 79
58780: PUSH
58781: LD_EXP 79
58785: PPUSH
58786: LD_VAR 0 2
58790: PPUSH
58791: EMPTY
58792: PPUSH
58793: CALL_OW 1
58797: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
58798: LD_ADDR_EXP 80
58802: PUSH
58803: LD_EXP 80
58807: PPUSH
58808: LD_VAR 0 2
58812: PPUSH
58813: EMPTY
58814: PPUSH
58815: CALL_OW 1
58819: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
58820: LD_ADDR_EXP 81
58824: PUSH
58825: LD_EXP 81
58829: PPUSH
58830: LD_VAR 0 2
58834: PPUSH
58835: EMPTY
58836: PPUSH
58837: CALL_OW 1
58841: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
58842: LD_ADDR_EXP 82
58846: PUSH
58847: LD_EXP 82
58851: PPUSH
58852: LD_VAR 0 2
58856: PPUSH
58857: EMPTY
58858: PPUSH
58859: CALL_OW 1
58863: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
58864: LD_ADDR_EXP 71
58868: PUSH
58869: LD_EXP 71
58873: PPUSH
58874: LD_VAR 0 2
58878: PPUSH
58879: LD_INT 0
58881: PPUSH
58882: CALL_OW 1
58886: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
58887: LD_ADDR_EXP 84
58891: PUSH
58892: LD_EXP 84
58896: PPUSH
58897: LD_VAR 0 2
58901: PPUSH
58902: LD_INT 0
58904: PPUSH
58905: CALL_OW 1
58909: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
58910: LD_ADDR_EXP 72
58914: PUSH
58915: LD_EXP 72
58919: PPUSH
58920: LD_VAR 0 2
58924: PPUSH
58925: EMPTY
58926: PPUSH
58927: CALL_OW 1
58931: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
58932: LD_ADDR_EXP 83
58936: PUSH
58937: LD_EXP 83
58941: PPUSH
58942: LD_VAR 0 2
58946: PPUSH
58947: LD_INT 0
58949: PPUSH
58950: CALL_OW 1
58954: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
58955: LD_ADDR_EXP 85
58959: PUSH
58960: LD_EXP 85
58964: PPUSH
58965: LD_VAR 0 2
58969: PPUSH
58970: EMPTY
58971: PPUSH
58972: CALL_OW 1
58976: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
58977: LD_ADDR_EXP 88
58981: PUSH
58982: LD_EXP 88
58986: PPUSH
58987: LD_VAR 0 2
58991: PPUSH
58992: LD_INT 0
58994: PPUSH
58995: CALL_OW 1
58999: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59000: LD_ADDR_EXP 89
59004: PUSH
59005: LD_EXP 89
59009: PPUSH
59010: LD_VAR 0 2
59014: PPUSH
59015: EMPTY
59016: PPUSH
59017: CALL_OW 1
59021: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59022: LD_ADDR_EXP 90
59026: PUSH
59027: LD_EXP 90
59031: PPUSH
59032: LD_VAR 0 2
59036: PPUSH
59037: EMPTY
59038: PPUSH
59039: CALL_OW 1
59043: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59044: LD_ADDR_EXP 91
59048: PUSH
59049: LD_EXP 91
59053: PPUSH
59054: LD_VAR 0 2
59058: PPUSH
59059: EMPTY
59060: PPUSH
59061: CALL_OW 1
59065: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59066: LD_ADDR_EXP 93
59070: PUSH
59071: LD_EXP 93
59075: PPUSH
59076: LD_VAR 0 2
59080: PPUSH
59081: LD_EXP 60
59085: PUSH
59086: LD_VAR 0 2
59090: ARRAY
59091: PPUSH
59092: LD_INT 2
59094: PUSH
59095: LD_INT 30
59097: PUSH
59098: LD_INT 6
59100: PUSH
59101: EMPTY
59102: LIST
59103: LIST
59104: PUSH
59105: LD_INT 30
59107: PUSH
59108: LD_INT 7
59110: PUSH
59111: EMPTY
59112: LIST
59113: LIST
59114: PUSH
59115: LD_INT 30
59117: PUSH
59118: LD_INT 8
59120: PUSH
59121: EMPTY
59122: LIST
59123: LIST
59124: PUSH
59125: EMPTY
59126: LIST
59127: LIST
59128: LIST
59129: LIST
59130: PPUSH
59131: CALL_OW 72
59135: PPUSH
59136: CALL_OW 1
59140: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59141: LD_ADDR_EXP 94
59145: PUSH
59146: LD_EXP 94
59150: PPUSH
59151: LD_VAR 0 2
59155: PPUSH
59156: EMPTY
59157: PPUSH
59158: CALL_OW 1
59162: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
59163: LD_ADDR_EXP 95
59167: PUSH
59168: LD_EXP 95
59172: PPUSH
59173: LD_VAR 0 2
59177: PPUSH
59178: EMPTY
59179: PPUSH
59180: CALL_OW 1
59184: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
59185: LD_ADDR_EXP 96
59189: PUSH
59190: LD_EXP 96
59194: PPUSH
59195: LD_VAR 0 2
59199: PPUSH
59200: EMPTY
59201: PPUSH
59202: CALL_OW 1
59206: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
59207: LD_ADDR_EXP 97
59211: PUSH
59212: LD_EXP 97
59216: PPUSH
59217: LD_VAR 0 2
59221: PPUSH
59222: EMPTY
59223: PPUSH
59224: CALL_OW 1
59228: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
59229: LD_ADDR_EXP 98
59233: PUSH
59234: LD_EXP 98
59238: PPUSH
59239: LD_VAR 0 2
59243: PPUSH
59244: EMPTY
59245: PPUSH
59246: CALL_OW 1
59250: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
59251: LD_ADDR_EXP 99
59255: PUSH
59256: LD_EXP 99
59260: PPUSH
59261: LD_VAR 0 2
59265: PPUSH
59266: EMPTY
59267: PPUSH
59268: CALL_OW 1
59272: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
59273: LD_ADDR_EXP 100
59277: PUSH
59278: LD_EXP 100
59282: PPUSH
59283: LD_VAR 0 2
59287: PPUSH
59288: EMPTY
59289: PPUSH
59290: CALL_OW 1
59294: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
59295: LD_ADDR_EXP 101
59299: PUSH
59300: LD_EXP 101
59304: PPUSH
59305: LD_VAR 0 2
59309: PPUSH
59310: EMPTY
59311: PPUSH
59312: CALL_OW 1
59316: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
59317: LD_ADDR_EXP 102
59321: PUSH
59322: LD_EXP 102
59326: PPUSH
59327: LD_VAR 0 2
59331: PPUSH
59332: LD_INT 0
59334: PPUSH
59335: CALL_OW 1
59339: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
59340: LD_ADDR_EXP 103
59344: PUSH
59345: LD_EXP 103
59349: PPUSH
59350: LD_VAR 0 2
59354: PPUSH
59355: LD_INT 0
59357: PPUSH
59358: CALL_OW 1
59362: ST_TO_ADDR
// end ;
59363: GO 58264
59365: POP
59366: POP
// MC_InitSides ( ) ;
59367: CALL 59653 0 0
// MC_InitResearch ( ) ;
59371: CALL 59392 0 0
// CustomInitMacro ( ) ;
59375: CALL 206 0 0
// skirmish := true ;
59379: LD_ADDR_EXP 58
59383: PUSH
59384: LD_INT 1
59386: ST_TO_ADDR
// end ;
59387: LD_VAR 0 1
59391: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
59392: LD_INT 0
59394: PPUSH
59395: PPUSH
59396: PPUSH
59397: PPUSH
59398: PPUSH
59399: PPUSH
// if not mc_bases then
59400: LD_EXP 60
59404: NOT
59405: IFFALSE 59409
// exit ;
59407: GO 59648
// for i = 1 to 8 do
59409: LD_ADDR_VAR 0 2
59413: PUSH
59414: DOUBLE
59415: LD_INT 1
59417: DEC
59418: ST_TO_ADDR
59419: LD_INT 8
59421: PUSH
59422: FOR_TO
59423: IFFALSE 59449
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
59425: LD_ADDR_EXP 87
59429: PUSH
59430: LD_EXP 87
59434: PPUSH
59435: LD_VAR 0 2
59439: PPUSH
59440: EMPTY
59441: PPUSH
59442: CALL_OW 1
59446: ST_TO_ADDR
59447: GO 59422
59449: POP
59450: POP
// tmp := [ ] ;
59451: LD_ADDR_VAR 0 5
59455: PUSH
59456: EMPTY
59457: ST_TO_ADDR
// for i = 1 to mc_sides do
59458: LD_ADDR_VAR 0 2
59462: PUSH
59463: DOUBLE
59464: LD_INT 1
59466: DEC
59467: ST_TO_ADDR
59468: LD_EXP 86
59472: PUSH
59473: FOR_TO
59474: IFFALSE 59532
// if not mc_sides [ i ] in tmp then
59476: LD_EXP 86
59480: PUSH
59481: LD_VAR 0 2
59485: ARRAY
59486: PUSH
59487: LD_VAR 0 5
59491: IN
59492: NOT
59493: IFFALSE 59530
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
59495: LD_ADDR_VAR 0 5
59499: PUSH
59500: LD_VAR 0 5
59504: PPUSH
59505: LD_VAR 0 5
59509: PUSH
59510: LD_INT 1
59512: PLUS
59513: PPUSH
59514: LD_EXP 86
59518: PUSH
59519: LD_VAR 0 2
59523: ARRAY
59524: PPUSH
59525: CALL_OW 2
59529: ST_TO_ADDR
59530: GO 59473
59532: POP
59533: POP
// if not tmp then
59534: LD_VAR 0 5
59538: NOT
59539: IFFALSE 59543
// exit ;
59541: GO 59648
// for j in tmp do
59543: LD_ADDR_VAR 0 3
59547: PUSH
59548: LD_VAR 0 5
59552: PUSH
59553: FOR_IN
59554: IFFALSE 59646
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
59556: LD_ADDR_VAR 0 6
59560: PUSH
59561: LD_INT 22
59563: PUSH
59564: LD_VAR 0 3
59568: PUSH
59569: EMPTY
59570: LIST
59571: LIST
59572: PPUSH
59573: CALL_OW 69
59577: ST_TO_ADDR
// if not un then
59578: LD_VAR 0 6
59582: NOT
59583: IFFALSE 59587
// continue ;
59585: GO 59553
// nation := GetNation ( un [ 1 ] ) ;
59587: LD_ADDR_VAR 0 4
59591: PUSH
59592: LD_VAR 0 6
59596: PUSH
59597: LD_INT 1
59599: ARRAY
59600: PPUSH
59601: CALL_OW 248
59605: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
59606: LD_ADDR_EXP 87
59610: PUSH
59611: LD_EXP 87
59615: PPUSH
59616: LD_VAR 0 3
59620: PPUSH
59621: LD_VAR 0 3
59625: PPUSH
59626: LD_VAR 0 4
59630: PPUSH
59631: LD_INT 1
59633: PPUSH
59634: CALL 14927 0 3
59638: PPUSH
59639: CALL_OW 1
59643: ST_TO_ADDR
// end ;
59644: GO 59553
59646: POP
59647: POP
// end ;
59648: LD_VAR 0 1
59652: RET
// export function MC_InitSides ( ) ; var i ; begin
59653: LD_INT 0
59655: PPUSH
59656: PPUSH
// if not mc_bases then
59657: LD_EXP 60
59661: NOT
59662: IFFALSE 59666
// exit ;
59664: GO 59740
// for i = 1 to mc_bases do
59666: LD_ADDR_VAR 0 2
59670: PUSH
59671: DOUBLE
59672: LD_INT 1
59674: DEC
59675: ST_TO_ADDR
59676: LD_EXP 60
59680: PUSH
59681: FOR_TO
59682: IFFALSE 59738
// if mc_bases [ i ] then
59684: LD_EXP 60
59688: PUSH
59689: LD_VAR 0 2
59693: ARRAY
59694: IFFALSE 59736
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
59696: LD_ADDR_EXP 86
59700: PUSH
59701: LD_EXP 86
59705: PPUSH
59706: LD_VAR 0 2
59710: PPUSH
59711: LD_EXP 60
59715: PUSH
59716: LD_VAR 0 2
59720: ARRAY
59721: PUSH
59722: LD_INT 1
59724: ARRAY
59725: PPUSH
59726: CALL_OW 255
59730: PPUSH
59731: CALL_OW 1
59735: ST_TO_ADDR
59736: GO 59681
59738: POP
59739: POP
// end ;
59740: LD_VAR 0 1
59744: RET
// every 0 0$03 trigger skirmish do
59745: LD_EXP 58
59749: IFFALSE 59903
59751: GO 59753
59753: DISABLE
// begin enable ;
59754: ENABLE
// MC_CheckBuildings ( ) ;
59755: CALL 64401 0 0
// MC_CheckPeopleLife ( ) ;
59759: CALL 64562 0 0
// RaiseSailEvent ( 100 ) ;
59763: LD_INT 100
59765: PPUSH
59766: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
59770: LD_INT 103
59772: PPUSH
59773: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
59777: LD_INT 104
59779: PPUSH
59780: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
59784: LD_INT 105
59786: PPUSH
59787: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
59791: LD_INT 106
59793: PPUSH
59794: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
59798: LD_INT 107
59800: PPUSH
59801: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
59805: LD_INT 108
59807: PPUSH
59808: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
59812: LD_INT 109
59814: PPUSH
59815: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
59819: LD_INT 110
59821: PPUSH
59822: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
59826: LD_INT 111
59828: PPUSH
59829: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
59833: LD_INT 112
59835: PPUSH
59836: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
59840: LD_INT 113
59842: PPUSH
59843: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
59847: LD_INT 120
59849: PPUSH
59850: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
59854: LD_INT 121
59856: PPUSH
59857: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
59861: LD_INT 122
59863: PPUSH
59864: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
59868: LD_INT 123
59870: PPUSH
59871: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
59875: LD_INT 124
59877: PPUSH
59878: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
59882: LD_INT 125
59884: PPUSH
59885: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
59889: LD_INT 126
59891: PPUSH
59892: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
59896: LD_INT 200
59898: PPUSH
59899: CALL_OW 427
// end ;
59903: END
// on SailEvent ( event ) do begin if event < 100 then
59904: LD_VAR 0 1
59908: PUSH
59909: LD_INT 100
59911: LESS
59912: IFFALSE 59923
// CustomEvent ( event ) ;
59914: LD_VAR 0 1
59918: PPUSH
59919: CALL 13542 0 1
// if event = 100 then
59923: LD_VAR 0 1
59927: PUSH
59928: LD_INT 100
59930: EQUAL
59931: IFFALSE 59937
// MC_ClassManager ( ) ;
59933: CALL 60329 0 0
// if event = 101 then
59937: LD_VAR 0 1
59941: PUSH
59942: LD_INT 101
59944: EQUAL
59945: IFFALSE 59951
// MC_RepairBuildings ( ) ;
59947: CALL 65147 0 0
// if event = 102 then
59951: LD_VAR 0 1
59955: PUSH
59956: LD_INT 102
59958: EQUAL
59959: IFFALSE 59965
// MC_Heal ( ) ;
59961: CALL 66054 0 0
// if event = 103 then
59965: LD_VAR 0 1
59969: PUSH
59970: LD_INT 103
59972: EQUAL
59973: IFFALSE 59979
// MC_Build ( ) ;
59975: CALL 66476 0 0
// if event = 104 then
59979: LD_VAR 0 1
59983: PUSH
59984: LD_INT 104
59986: EQUAL
59987: IFFALSE 59993
// MC_TurretWeapon ( ) ;
59989: CALL 68117 0 0
// if event = 105 then
59993: LD_VAR 0 1
59997: PUSH
59998: LD_INT 105
60000: EQUAL
60001: IFFALSE 60007
// MC_BuildUpgrade ( ) ;
60003: CALL 67668 0 0
// if event = 106 then
60007: LD_VAR 0 1
60011: PUSH
60012: LD_INT 106
60014: EQUAL
60015: IFFALSE 60021
// MC_PlantMines ( ) ;
60017: CALL 68547 0 0
// if event = 107 then
60021: LD_VAR 0 1
60025: PUSH
60026: LD_INT 107
60028: EQUAL
60029: IFFALSE 60035
// MC_CollectCrates ( ) ;
60031: CALL 69338 0 0
// if event = 108 then
60035: LD_VAR 0 1
60039: PUSH
60040: LD_INT 108
60042: EQUAL
60043: IFFALSE 60049
// MC_LinkRemoteControl ( ) ;
60045: CALL 71188 0 0
// if event = 109 then
60049: LD_VAR 0 1
60053: PUSH
60054: LD_INT 109
60056: EQUAL
60057: IFFALSE 60063
// MC_ProduceVehicle ( ) ;
60059: CALL 71369 0 0
// if event = 110 then
60063: LD_VAR 0 1
60067: PUSH
60068: LD_INT 110
60070: EQUAL
60071: IFFALSE 60077
// MC_SendAttack ( ) ;
60073: CALL 71835 0 0
// if event = 111 then
60077: LD_VAR 0 1
60081: PUSH
60082: LD_INT 111
60084: EQUAL
60085: IFFALSE 60091
// MC_Defend ( ) ;
60087: CALL 71943 0 0
// if event = 112 then
60091: LD_VAR 0 1
60095: PUSH
60096: LD_INT 112
60098: EQUAL
60099: IFFALSE 60105
// MC_Research ( ) ;
60101: CALL 72823 0 0
// if event = 113 then
60105: LD_VAR 0 1
60109: PUSH
60110: LD_INT 113
60112: EQUAL
60113: IFFALSE 60119
// MC_MinesTrigger ( ) ;
60115: CALL 73937 0 0
// if event = 120 then
60119: LD_VAR 0 1
60123: PUSH
60124: LD_INT 120
60126: EQUAL
60127: IFFALSE 60133
// MC_RepairVehicle ( ) ;
60129: CALL 74036 0 0
// if event = 121 then
60133: LD_VAR 0 1
60137: PUSH
60138: LD_INT 121
60140: EQUAL
60141: IFFALSE 60147
// MC_TameApe ( ) ;
60143: CALL 74777 0 0
// if event = 122 then
60147: LD_VAR 0 1
60151: PUSH
60152: LD_INT 122
60154: EQUAL
60155: IFFALSE 60161
// MC_ChangeApeClass ( ) ;
60157: CALL 75606 0 0
// if event = 123 then
60161: LD_VAR 0 1
60165: PUSH
60166: LD_INT 123
60168: EQUAL
60169: IFFALSE 60175
// MC_Bazooka ( ) ;
60171: CALL 76256 0 0
// if event = 124 then
60175: LD_VAR 0 1
60179: PUSH
60180: LD_INT 124
60182: EQUAL
60183: IFFALSE 60189
// MC_TeleportExit ( ) ;
60185: CALL 76454 0 0
// if event = 125 then
60189: LD_VAR 0 1
60193: PUSH
60194: LD_INT 125
60196: EQUAL
60197: IFFALSE 60203
// MC_Deposits ( ) ;
60199: CALL 77101 0 0
// if event = 126 then
60203: LD_VAR 0 1
60207: PUSH
60208: LD_INT 126
60210: EQUAL
60211: IFFALSE 60217
// MC_RemoteDriver ( ) ;
60213: CALL 77726 0 0
// if event = 200 then
60217: LD_VAR 0 1
60221: PUSH
60222: LD_INT 200
60224: EQUAL
60225: IFFALSE 60231
// MC_Idle ( ) ;
60227: CALL 79675 0 0
// end ;
60231: PPOPN 1
60233: END
// export function MC_Reset ( base , tag ) ; var i ; begin
60234: LD_INT 0
60236: PPUSH
60237: PPUSH
// if not mc_bases [ base ] or not tag then
60238: LD_EXP 60
60242: PUSH
60243: LD_VAR 0 1
60247: ARRAY
60248: NOT
60249: PUSH
60250: LD_VAR 0 2
60254: NOT
60255: OR
60256: IFFALSE 60260
// exit ;
60258: GO 60324
// for i in mc_bases [ base ] union mc_ape [ base ] do
60260: LD_ADDR_VAR 0 4
60264: PUSH
60265: LD_EXP 60
60269: PUSH
60270: LD_VAR 0 1
60274: ARRAY
60275: PUSH
60276: LD_EXP 89
60280: PUSH
60281: LD_VAR 0 1
60285: ARRAY
60286: UNION
60287: PUSH
60288: FOR_IN
60289: IFFALSE 60322
// if GetTag ( i ) = tag then
60291: LD_VAR 0 4
60295: PPUSH
60296: CALL_OW 110
60300: PUSH
60301: LD_VAR 0 2
60305: EQUAL
60306: IFFALSE 60320
// SetTag ( i , 0 ) ;
60308: LD_VAR 0 4
60312: PPUSH
60313: LD_INT 0
60315: PPUSH
60316: CALL_OW 109
60320: GO 60288
60322: POP
60323: POP
// end ;
60324: LD_VAR 0 3
60328: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
60329: LD_INT 0
60331: PPUSH
60332: PPUSH
60333: PPUSH
60334: PPUSH
60335: PPUSH
60336: PPUSH
60337: PPUSH
60338: PPUSH
// if not mc_bases then
60339: LD_EXP 60
60343: NOT
60344: IFFALSE 60348
// exit ;
60346: GO 60806
// for i = 1 to mc_bases do
60348: LD_ADDR_VAR 0 2
60352: PUSH
60353: DOUBLE
60354: LD_INT 1
60356: DEC
60357: ST_TO_ADDR
60358: LD_EXP 60
60362: PUSH
60363: FOR_TO
60364: IFFALSE 60804
// begin tmp := MC_ClassCheckReq ( i ) ;
60366: LD_ADDR_VAR 0 4
60370: PUSH
60371: LD_VAR 0 2
60375: PPUSH
60376: CALL 60811 0 1
60380: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
60381: LD_ADDR_EXP 101
60385: PUSH
60386: LD_EXP 101
60390: PPUSH
60391: LD_VAR 0 2
60395: PPUSH
60396: LD_VAR 0 4
60400: PPUSH
60401: CALL_OW 1
60405: ST_TO_ADDR
// if not tmp then
60406: LD_VAR 0 4
60410: NOT
60411: IFFALSE 60415
// continue ;
60413: GO 60363
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
60415: LD_ADDR_VAR 0 6
60419: PUSH
60420: LD_EXP 60
60424: PUSH
60425: LD_VAR 0 2
60429: ARRAY
60430: PPUSH
60431: LD_INT 2
60433: PUSH
60434: LD_INT 30
60436: PUSH
60437: LD_INT 4
60439: PUSH
60440: EMPTY
60441: LIST
60442: LIST
60443: PUSH
60444: LD_INT 30
60446: PUSH
60447: LD_INT 5
60449: PUSH
60450: EMPTY
60451: LIST
60452: LIST
60453: PUSH
60454: EMPTY
60455: LIST
60456: LIST
60457: LIST
60458: PPUSH
60459: CALL_OW 72
60463: PUSH
60464: LD_EXP 60
60468: PUSH
60469: LD_VAR 0 2
60473: ARRAY
60474: PPUSH
60475: LD_INT 2
60477: PUSH
60478: LD_INT 30
60480: PUSH
60481: LD_INT 0
60483: PUSH
60484: EMPTY
60485: LIST
60486: LIST
60487: PUSH
60488: LD_INT 30
60490: PUSH
60491: LD_INT 1
60493: PUSH
60494: EMPTY
60495: LIST
60496: LIST
60497: PUSH
60498: EMPTY
60499: LIST
60500: LIST
60501: LIST
60502: PPUSH
60503: CALL_OW 72
60507: PUSH
60508: LD_EXP 60
60512: PUSH
60513: LD_VAR 0 2
60517: ARRAY
60518: PPUSH
60519: LD_INT 30
60521: PUSH
60522: LD_INT 3
60524: PUSH
60525: EMPTY
60526: LIST
60527: LIST
60528: PPUSH
60529: CALL_OW 72
60533: PUSH
60534: LD_EXP 60
60538: PUSH
60539: LD_VAR 0 2
60543: ARRAY
60544: PPUSH
60545: LD_INT 2
60547: PUSH
60548: LD_INT 30
60550: PUSH
60551: LD_INT 6
60553: PUSH
60554: EMPTY
60555: LIST
60556: LIST
60557: PUSH
60558: LD_INT 30
60560: PUSH
60561: LD_INT 7
60563: PUSH
60564: EMPTY
60565: LIST
60566: LIST
60567: PUSH
60568: LD_INT 30
60570: PUSH
60571: LD_INT 8
60573: PUSH
60574: EMPTY
60575: LIST
60576: LIST
60577: PUSH
60578: EMPTY
60579: LIST
60580: LIST
60581: LIST
60582: LIST
60583: PPUSH
60584: CALL_OW 72
60588: PUSH
60589: EMPTY
60590: LIST
60591: LIST
60592: LIST
60593: LIST
60594: ST_TO_ADDR
// for j = 1 to 4 do
60595: LD_ADDR_VAR 0 3
60599: PUSH
60600: DOUBLE
60601: LD_INT 1
60603: DEC
60604: ST_TO_ADDR
60605: LD_INT 4
60607: PUSH
60608: FOR_TO
60609: IFFALSE 60800
// begin if not tmp [ j ] then
60611: LD_VAR 0 4
60615: PUSH
60616: LD_VAR 0 3
60620: ARRAY
60621: NOT
60622: IFFALSE 60626
// continue ;
60624: GO 60608
// for p in tmp [ j ] do
60626: LD_ADDR_VAR 0 5
60630: PUSH
60631: LD_VAR 0 4
60635: PUSH
60636: LD_VAR 0 3
60640: ARRAY
60641: PUSH
60642: FOR_IN
60643: IFFALSE 60796
// begin if not b [ j ] then
60645: LD_VAR 0 6
60649: PUSH
60650: LD_VAR 0 3
60654: ARRAY
60655: NOT
60656: IFFALSE 60660
// break ;
60658: GO 60796
// e := 0 ;
60660: LD_ADDR_VAR 0 7
60664: PUSH
60665: LD_INT 0
60667: ST_TO_ADDR
// for k in b [ j ] do
60668: LD_ADDR_VAR 0 8
60672: PUSH
60673: LD_VAR 0 6
60677: PUSH
60678: LD_VAR 0 3
60682: ARRAY
60683: PUSH
60684: FOR_IN
60685: IFFALSE 60712
// if IsNotFull ( k ) then
60687: LD_VAR 0 8
60691: PPUSH
60692: CALL 17080 0 1
60696: IFFALSE 60710
// begin e := k ;
60698: LD_ADDR_VAR 0 7
60702: PUSH
60703: LD_VAR 0 8
60707: ST_TO_ADDR
// break ;
60708: GO 60712
// end ;
60710: GO 60684
60712: POP
60713: POP
// if e and not UnitGoingToBuilding ( p , e ) then
60714: LD_VAR 0 7
60718: PUSH
60719: LD_VAR 0 5
60723: PPUSH
60724: LD_VAR 0 7
60728: PPUSH
60729: CALL 50911 0 2
60733: NOT
60734: AND
60735: IFFALSE 60794
// begin if IsInUnit ( p ) then
60737: LD_VAR 0 5
60741: PPUSH
60742: CALL_OW 310
60746: IFFALSE 60757
// ComExitBuilding ( p ) ;
60748: LD_VAR 0 5
60752: PPUSH
60753: CALL_OW 122
// ComEnterUnit ( p , e ) ;
60757: LD_VAR 0 5
60761: PPUSH
60762: LD_VAR 0 7
60766: PPUSH
60767: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
60771: LD_VAR 0 5
60775: PPUSH
60776: LD_VAR 0 3
60780: PPUSH
60781: CALL_OW 183
// AddComExitBuilding ( p ) ;
60785: LD_VAR 0 5
60789: PPUSH
60790: CALL_OW 182
// end ; end ;
60794: GO 60642
60796: POP
60797: POP
// end ;
60798: GO 60608
60800: POP
60801: POP
// end ;
60802: GO 60363
60804: POP
60805: POP
// end ;
60806: LD_VAR 0 1
60810: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
60811: LD_INT 0
60813: PPUSH
60814: PPUSH
60815: PPUSH
60816: PPUSH
60817: PPUSH
60818: PPUSH
60819: PPUSH
60820: PPUSH
60821: PPUSH
60822: PPUSH
60823: PPUSH
60824: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
60825: LD_VAR 0 1
60829: NOT
60830: PUSH
60831: LD_EXP 60
60835: PUSH
60836: LD_VAR 0 1
60840: ARRAY
60841: NOT
60842: OR
60843: PUSH
60844: LD_EXP 60
60848: PUSH
60849: LD_VAR 0 1
60853: ARRAY
60854: PPUSH
60855: LD_INT 2
60857: PUSH
60858: LD_INT 30
60860: PUSH
60861: LD_INT 0
60863: PUSH
60864: EMPTY
60865: LIST
60866: LIST
60867: PUSH
60868: LD_INT 30
60870: PUSH
60871: LD_INT 1
60873: PUSH
60874: EMPTY
60875: LIST
60876: LIST
60877: PUSH
60878: EMPTY
60879: LIST
60880: LIST
60881: LIST
60882: PPUSH
60883: CALL_OW 72
60887: NOT
60888: OR
60889: IFFALSE 60893
// exit ;
60891: GO 64396
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
60893: LD_ADDR_VAR 0 4
60897: PUSH
60898: LD_EXP 60
60902: PUSH
60903: LD_VAR 0 1
60907: ARRAY
60908: PPUSH
60909: LD_INT 2
60911: PUSH
60912: LD_INT 25
60914: PUSH
60915: LD_INT 1
60917: PUSH
60918: EMPTY
60919: LIST
60920: LIST
60921: PUSH
60922: LD_INT 25
60924: PUSH
60925: LD_INT 2
60927: PUSH
60928: EMPTY
60929: LIST
60930: LIST
60931: PUSH
60932: LD_INT 25
60934: PUSH
60935: LD_INT 3
60937: PUSH
60938: EMPTY
60939: LIST
60940: LIST
60941: PUSH
60942: LD_INT 25
60944: PUSH
60945: LD_INT 4
60947: PUSH
60948: EMPTY
60949: LIST
60950: LIST
60951: PUSH
60952: LD_INT 25
60954: PUSH
60955: LD_INT 5
60957: PUSH
60958: EMPTY
60959: LIST
60960: LIST
60961: PUSH
60962: LD_INT 25
60964: PUSH
60965: LD_INT 8
60967: PUSH
60968: EMPTY
60969: LIST
60970: LIST
60971: PUSH
60972: LD_INT 25
60974: PUSH
60975: LD_INT 9
60977: PUSH
60978: EMPTY
60979: LIST
60980: LIST
60981: PUSH
60982: EMPTY
60983: LIST
60984: LIST
60985: LIST
60986: LIST
60987: LIST
60988: LIST
60989: LIST
60990: LIST
60991: PPUSH
60992: CALL_OW 72
60996: ST_TO_ADDR
// if not tmp then
60997: LD_VAR 0 4
61001: NOT
61002: IFFALSE 61006
// exit ;
61004: GO 64396
// for i in tmp do
61006: LD_ADDR_VAR 0 3
61010: PUSH
61011: LD_VAR 0 4
61015: PUSH
61016: FOR_IN
61017: IFFALSE 61048
// if GetTag ( i ) then
61019: LD_VAR 0 3
61023: PPUSH
61024: CALL_OW 110
61028: IFFALSE 61046
// tmp := tmp diff i ;
61030: LD_ADDR_VAR 0 4
61034: PUSH
61035: LD_VAR 0 4
61039: PUSH
61040: LD_VAR 0 3
61044: DIFF
61045: ST_TO_ADDR
61046: GO 61016
61048: POP
61049: POP
// if not tmp then
61050: LD_VAR 0 4
61054: NOT
61055: IFFALSE 61059
// exit ;
61057: GO 64396
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61059: LD_ADDR_VAR 0 5
61063: PUSH
61064: LD_EXP 60
61068: PUSH
61069: LD_VAR 0 1
61073: ARRAY
61074: PPUSH
61075: LD_INT 2
61077: PUSH
61078: LD_INT 25
61080: PUSH
61081: LD_INT 1
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: PUSH
61088: LD_INT 25
61090: PUSH
61091: LD_INT 5
61093: PUSH
61094: EMPTY
61095: LIST
61096: LIST
61097: PUSH
61098: LD_INT 25
61100: PUSH
61101: LD_INT 8
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PUSH
61108: LD_INT 25
61110: PUSH
61111: LD_INT 9
61113: PUSH
61114: EMPTY
61115: LIST
61116: LIST
61117: PUSH
61118: EMPTY
61119: LIST
61120: LIST
61121: LIST
61122: LIST
61123: LIST
61124: PPUSH
61125: CALL_OW 72
61129: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61130: LD_ADDR_VAR 0 6
61134: PUSH
61135: LD_EXP 60
61139: PUSH
61140: LD_VAR 0 1
61144: ARRAY
61145: PPUSH
61146: LD_INT 25
61148: PUSH
61149: LD_INT 2
61151: PUSH
61152: EMPTY
61153: LIST
61154: LIST
61155: PPUSH
61156: CALL_OW 72
61160: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61161: LD_ADDR_VAR 0 7
61165: PUSH
61166: LD_EXP 60
61170: PUSH
61171: LD_VAR 0 1
61175: ARRAY
61176: PPUSH
61177: LD_INT 25
61179: PUSH
61180: LD_INT 3
61182: PUSH
61183: EMPTY
61184: LIST
61185: LIST
61186: PPUSH
61187: CALL_OW 72
61191: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
61192: LD_ADDR_VAR 0 8
61196: PUSH
61197: LD_EXP 60
61201: PUSH
61202: LD_VAR 0 1
61206: ARRAY
61207: PPUSH
61208: LD_INT 25
61210: PUSH
61211: LD_INT 4
61213: PUSH
61214: EMPTY
61215: LIST
61216: LIST
61217: PUSH
61218: LD_INT 24
61220: PUSH
61221: LD_INT 251
61223: PUSH
61224: EMPTY
61225: LIST
61226: LIST
61227: PUSH
61228: EMPTY
61229: LIST
61230: LIST
61231: PPUSH
61232: CALL_OW 72
61236: ST_TO_ADDR
// if mc_is_defending [ base ] then
61237: LD_EXP 103
61241: PUSH
61242: LD_VAR 0 1
61246: ARRAY
61247: IFFALSE 61708
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
61249: LD_ADDR_EXP 102
61253: PUSH
61254: LD_EXP 102
61258: PPUSH
61259: LD_VAR 0 1
61263: PPUSH
61264: LD_INT 4
61266: PPUSH
61267: CALL_OW 1
61271: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
61272: LD_ADDR_VAR 0 12
61276: PUSH
61277: LD_EXP 60
61281: PUSH
61282: LD_VAR 0 1
61286: ARRAY
61287: PPUSH
61288: LD_INT 2
61290: PUSH
61291: LD_INT 30
61293: PUSH
61294: LD_INT 4
61296: PUSH
61297: EMPTY
61298: LIST
61299: LIST
61300: PUSH
61301: LD_INT 30
61303: PUSH
61304: LD_INT 5
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: LIST
61315: PPUSH
61316: CALL_OW 72
61320: ST_TO_ADDR
// if not b then
61321: LD_VAR 0 12
61325: NOT
61326: IFFALSE 61330
// exit ;
61328: GO 64396
// p := [ ] ;
61330: LD_ADDR_VAR 0 11
61334: PUSH
61335: EMPTY
61336: ST_TO_ADDR
// if sci >= 2 then
61337: LD_VAR 0 8
61341: PUSH
61342: LD_INT 2
61344: GREATEREQUAL
61345: IFFALSE 61376
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
61347: LD_ADDR_VAR 0 8
61351: PUSH
61352: LD_VAR 0 8
61356: PUSH
61357: LD_INT 1
61359: ARRAY
61360: PUSH
61361: LD_VAR 0 8
61365: PUSH
61366: LD_INT 2
61368: ARRAY
61369: PUSH
61370: EMPTY
61371: LIST
61372: LIST
61373: ST_TO_ADDR
61374: GO 61437
// if sci = 1 then
61376: LD_VAR 0 8
61380: PUSH
61381: LD_INT 1
61383: EQUAL
61384: IFFALSE 61405
// sci := [ sci [ 1 ] ] else
61386: LD_ADDR_VAR 0 8
61390: PUSH
61391: LD_VAR 0 8
61395: PUSH
61396: LD_INT 1
61398: ARRAY
61399: PUSH
61400: EMPTY
61401: LIST
61402: ST_TO_ADDR
61403: GO 61437
// if sci = 0 then
61405: LD_VAR 0 8
61409: PUSH
61410: LD_INT 0
61412: EQUAL
61413: IFFALSE 61437
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
61415: LD_ADDR_VAR 0 11
61419: PUSH
61420: LD_VAR 0 4
61424: PPUSH
61425: LD_INT 4
61427: PPUSH
61428: CALL 50774 0 2
61432: PUSH
61433: LD_INT 1
61435: ARRAY
61436: ST_TO_ADDR
// if eng > 4 then
61437: LD_VAR 0 6
61441: PUSH
61442: LD_INT 4
61444: GREATER
61445: IFFALSE 61491
// for i = eng downto 4 do
61447: LD_ADDR_VAR 0 3
61451: PUSH
61452: DOUBLE
61453: LD_VAR 0 6
61457: INC
61458: ST_TO_ADDR
61459: LD_INT 4
61461: PUSH
61462: FOR_DOWNTO
61463: IFFALSE 61489
// eng := eng diff eng [ i ] ;
61465: LD_ADDR_VAR 0 6
61469: PUSH
61470: LD_VAR 0 6
61474: PUSH
61475: LD_VAR 0 6
61479: PUSH
61480: LD_VAR 0 3
61484: ARRAY
61485: DIFF
61486: ST_TO_ADDR
61487: GO 61462
61489: POP
61490: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
61491: LD_ADDR_VAR 0 4
61495: PUSH
61496: LD_VAR 0 4
61500: PUSH
61501: LD_VAR 0 5
61505: PUSH
61506: LD_VAR 0 6
61510: UNION
61511: PUSH
61512: LD_VAR 0 7
61516: UNION
61517: PUSH
61518: LD_VAR 0 8
61522: UNION
61523: DIFF
61524: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
61525: LD_ADDR_VAR 0 13
61529: PUSH
61530: LD_EXP 60
61534: PUSH
61535: LD_VAR 0 1
61539: ARRAY
61540: PPUSH
61541: LD_INT 2
61543: PUSH
61544: LD_INT 30
61546: PUSH
61547: LD_INT 32
61549: PUSH
61550: EMPTY
61551: LIST
61552: LIST
61553: PUSH
61554: LD_INT 30
61556: PUSH
61557: LD_INT 31
61559: PUSH
61560: EMPTY
61561: LIST
61562: LIST
61563: PUSH
61564: EMPTY
61565: LIST
61566: LIST
61567: LIST
61568: PPUSH
61569: CALL_OW 72
61573: PUSH
61574: LD_EXP 60
61578: PUSH
61579: LD_VAR 0 1
61583: ARRAY
61584: PPUSH
61585: LD_INT 2
61587: PUSH
61588: LD_INT 30
61590: PUSH
61591: LD_INT 4
61593: PUSH
61594: EMPTY
61595: LIST
61596: LIST
61597: PUSH
61598: LD_INT 30
61600: PUSH
61601: LD_INT 5
61603: PUSH
61604: EMPTY
61605: LIST
61606: LIST
61607: PUSH
61608: EMPTY
61609: LIST
61610: LIST
61611: LIST
61612: PPUSH
61613: CALL_OW 72
61617: PUSH
61618: LD_INT 6
61620: MUL
61621: PLUS
61622: ST_TO_ADDR
// if bcount < tmp then
61623: LD_VAR 0 13
61627: PUSH
61628: LD_VAR 0 4
61632: LESS
61633: IFFALSE 61679
// for i = tmp downto bcount do
61635: LD_ADDR_VAR 0 3
61639: PUSH
61640: DOUBLE
61641: LD_VAR 0 4
61645: INC
61646: ST_TO_ADDR
61647: LD_VAR 0 13
61651: PUSH
61652: FOR_DOWNTO
61653: IFFALSE 61677
// tmp := Delete ( tmp , tmp ) ;
61655: LD_ADDR_VAR 0 4
61659: PUSH
61660: LD_VAR 0 4
61664: PPUSH
61665: LD_VAR 0 4
61669: PPUSH
61670: CALL_OW 3
61674: ST_TO_ADDR
61675: GO 61652
61677: POP
61678: POP
// result := [ tmp , 0 , 0 , p ] ;
61679: LD_ADDR_VAR 0 2
61683: PUSH
61684: LD_VAR 0 4
61688: PUSH
61689: LD_INT 0
61691: PUSH
61692: LD_INT 0
61694: PUSH
61695: LD_VAR 0 11
61699: PUSH
61700: EMPTY
61701: LIST
61702: LIST
61703: LIST
61704: LIST
61705: ST_TO_ADDR
// exit ;
61706: GO 64396
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61708: LD_EXP 60
61712: PUSH
61713: LD_VAR 0 1
61717: ARRAY
61718: PPUSH
61719: LD_INT 2
61721: PUSH
61722: LD_INT 30
61724: PUSH
61725: LD_INT 6
61727: PUSH
61728: EMPTY
61729: LIST
61730: LIST
61731: PUSH
61732: LD_INT 30
61734: PUSH
61735: LD_INT 7
61737: PUSH
61738: EMPTY
61739: LIST
61740: LIST
61741: PUSH
61742: LD_INT 30
61744: PUSH
61745: LD_INT 8
61747: PUSH
61748: EMPTY
61749: LIST
61750: LIST
61751: PUSH
61752: EMPTY
61753: LIST
61754: LIST
61755: LIST
61756: LIST
61757: PPUSH
61758: CALL_OW 72
61762: NOT
61763: PUSH
61764: LD_EXP 60
61768: PUSH
61769: LD_VAR 0 1
61773: ARRAY
61774: PPUSH
61775: LD_INT 30
61777: PUSH
61778: LD_INT 3
61780: PUSH
61781: EMPTY
61782: LIST
61783: LIST
61784: PPUSH
61785: CALL_OW 72
61789: NOT
61790: AND
61791: IFFALSE 61863
// begin if eng = tmp then
61793: LD_VAR 0 6
61797: PUSH
61798: LD_VAR 0 4
61802: EQUAL
61803: IFFALSE 61807
// exit ;
61805: GO 64396
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
61807: LD_ADDR_EXP 102
61811: PUSH
61812: LD_EXP 102
61816: PPUSH
61817: LD_VAR 0 1
61821: PPUSH
61822: LD_INT 1
61824: PPUSH
61825: CALL_OW 1
61829: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
61830: LD_ADDR_VAR 0 2
61834: PUSH
61835: LD_INT 0
61837: PUSH
61838: LD_VAR 0 4
61842: PUSH
61843: LD_VAR 0 6
61847: DIFF
61848: PUSH
61849: LD_INT 0
61851: PUSH
61852: LD_INT 0
61854: PUSH
61855: EMPTY
61856: LIST
61857: LIST
61858: LIST
61859: LIST
61860: ST_TO_ADDR
// exit ;
61861: GO 64396
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
61863: LD_EXP 87
61867: PUSH
61868: LD_EXP 86
61872: PUSH
61873: LD_VAR 0 1
61877: ARRAY
61878: ARRAY
61879: PUSH
61880: LD_EXP 60
61884: PUSH
61885: LD_VAR 0 1
61889: ARRAY
61890: PPUSH
61891: LD_INT 2
61893: PUSH
61894: LD_INT 30
61896: PUSH
61897: LD_INT 6
61899: PUSH
61900: EMPTY
61901: LIST
61902: LIST
61903: PUSH
61904: LD_INT 30
61906: PUSH
61907: LD_INT 7
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: PUSH
61914: LD_INT 30
61916: PUSH
61917: LD_INT 8
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: LIST
61928: LIST
61929: PPUSH
61930: CALL_OW 72
61934: AND
61935: PUSH
61936: LD_EXP 60
61940: PUSH
61941: LD_VAR 0 1
61945: ARRAY
61946: PPUSH
61947: LD_INT 30
61949: PUSH
61950: LD_INT 3
61952: PUSH
61953: EMPTY
61954: LIST
61955: LIST
61956: PPUSH
61957: CALL_OW 72
61961: NOT
61962: AND
61963: IFFALSE 62177
// begin if sci >= 6 then
61965: LD_VAR 0 8
61969: PUSH
61970: LD_INT 6
61972: GREATEREQUAL
61973: IFFALSE 61977
// exit ;
61975: GO 64396
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
61977: LD_ADDR_EXP 102
61981: PUSH
61982: LD_EXP 102
61986: PPUSH
61987: LD_VAR 0 1
61991: PPUSH
61992: LD_INT 2
61994: PPUSH
61995: CALL_OW 1
61999: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62000: LD_ADDR_VAR 0 9
62004: PUSH
62005: LD_VAR 0 4
62009: PUSH
62010: LD_VAR 0 8
62014: DIFF
62015: PPUSH
62016: LD_INT 4
62018: PPUSH
62019: CALL 50774 0 2
62023: ST_TO_ADDR
// p := [ ] ;
62024: LD_ADDR_VAR 0 11
62028: PUSH
62029: EMPTY
62030: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62031: LD_VAR 0 8
62035: PUSH
62036: LD_INT 6
62038: LESS
62039: PUSH
62040: LD_VAR 0 9
62044: PUSH
62045: LD_INT 6
62047: GREATER
62048: AND
62049: IFFALSE 62130
// begin for i = 1 to 6 - sci do
62051: LD_ADDR_VAR 0 3
62055: PUSH
62056: DOUBLE
62057: LD_INT 1
62059: DEC
62060: ST_TO_ADDR
62061: LD_INT 6
62063: PUSH
62064: LD_VAR 0 8
62068: MINUS
62069: PUSH
62070: FOR_TO
62071: IFFALSE 62126
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62073: LD_ADDR_VAR 0 11
62077: PUSH
62078: LD_VAR 0 11
62082: PPUSH
62083: LD_VAR 0 11
62087: PUSH
62088: LD_INT 1
62090: PLUS
62091: PPUSH
62092: LD_VAR 0 9
62096: PUSH
62097: LD_INT 1
62099: ARRAY
62100: PPUSH
62101: CALL_OW 2
62105: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62106: LD_ADDR_VAR 0 9
62110: PUSH
62111: LD_VAR 0 9
62115: PPUSH
62116: LD_INT 1
62118: PPUSH
62119: CALL_OW 3
62123: ST_TO_ADDR
// end ;
62124: GO 62070
62126: POP
62127: POP
// end else
62128: GO 62150
// if sort then
62130: LD_VAR 0 9
62134: IFFALSE 62150
// p := sort [ 1 ] ;
62136: LD_ADDR_VAR 0 11
62140: PUSH
62141: LD_VAR 0 9
62145: PUSH
62146: LD_INT 1
62148: ARRAY
62149: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62150: LD_ADDR_VAR 0 2
62154: PUSH
62155: LD_INT 0
62157: PUSH
62158: LD_INT 0
62160: PUSH
62161: LD_INT 0
62163: PUSH
62164: LD_VAR 0 11
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: LIST
62173: LIST
62174: ST_TO_ADDR
// exit ;
62175: GO 64396
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62177: LD_EXP 87
62181: PUSH
62182: LD_EXP 86
62186: PUSH
62187: LD_VAR 0 1
62191: ARRAY
62192: ARRAY
62193: PUSH
62194: LD_EXP 60
62198: PUSH
62199: LD_VAR 0 1
62203: ARRAY
62204: PPUSH
62205: LD_INT 2
62207: PUSH
62208: LD_INT 30
62210: PUSH
62211: LD_INT 6
62213: PUSH
62214: EMPTY
62215: LIST
62216: LIST
62217: PUSH
62218: LD_INT 30
62220: PUSH
62221: LD_INT 7
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PUSH
62228: LD_INT 30
62230: PUSH
62231: LD_INT 8
62233: PUSH
62234: EMPTY
62235: LIST
62236: LIST
62237: PUSH
62238: EMPTY
62239: LIST
62240: LIST
62241: LIST
62242: LIST
62243: PPUSH
62244: CALL_OW 72
62248: AND
62249: PUSH
62250: LD_EXP 60
62254: PUSH
62255: LD_VAR 0 1
62259: ARRAY
62260: PPUSH
62261: LD_INT 30
62263: PUSH
62264: LD_INT 3
62266: PUSH
62267: EMPTY
62268: LIST
62269: LIST
62270: PPUSH
62271: CALL_OW 72
62275: AND
62276: IFFALSE 63010
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
62278: LD_ADDR_EXP 102
62282: PUSH
62283: LD_EXP 102
62287: PPUSH
62288: LD_VAR 0 1
62292: PPUSH
62293: LD_INT 3
62295: PPUSH
62296: CALL_OW 1
62300: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
62301: LD_ADDR_VAR 0 2
62305: PUSH
62306: LD_INT 0
62308: PUSH
62309: LD_INT 0
62311: PUSH
62312: LD_INT 0
62314: PUSH
62315: LD_INT 0
62317: PUSH
62318: EMPTY
62319: LIST
62320: LIST
62321: LIST
62322: LIST
62323: ST_TO_ADDR
// if not eng then
62324: LD_VAR 0 6
62328: NOT
62329: IFFALSE 62392
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
62331: LD_ADDR_VAR 0 11
62335: PUSH
62336: LD_VAR 0 4
62340: PPUSH
62341: LD_INT 2
62343: PPUSH
62344: CALL 50774 0 2
62348: PUSH
62349: LD_INT 1
62351: ARRAY
62352: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
62353: LD_ADDR_VAR 0 2
62357: PUSH
62358: LD_VAR 0 2
62362: PPUSH
62363: LD_INT 2
62365: PPUSH
62366: LD_VAR 0 11
62370: PPUSH
62371: CALL_OW 1
62375: ST_TO_ADDR
// tmp := tmp diff p ;
62376: LD_ADDR_VAR 0 4
62380: PUSH
62381: LD_VAR 0 4
62385: PUSH
62386: LD_VAR 0 11
62390: DIFF
62391: ST_TO_ADDR
// end ; if tmp and sci < 6 then
62392: LD_VAR 0 4
62396: PUSH
62397: LD_VAR 0 8
62401: PUSH
62402: LD_INT 6
62404: LESS
62405: AND
62406: IFFALSE 62594
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
62408: LD_ADDR_VAR 0 9
62412: PUSH
62413: LD_VAR 0 4
62417: PUSH
62418: LD_VAR 0 8
62422: PUSH
62423: LD_VAR 0 7
62427: UNION
62428: DIFF
62429: PPUSH
62430: LD_INT 4
62432: PPUSH
62433: CALL 50774 0 2
62437: ST_TO_ADDR
// p := [ ] ;
62438: LD_ADDR_VAR 0 11
62442: PUSH
62443: EMPTY
62444: ST_TO_ADDR
// if sort then
62445: LD_VAR 0 9
62449: IFFALSE 62565
// for i = 1 to 6 - sci do
62451: LD_ADDR_VAR 0 3
62455: PUSH
62456: DOUBLE
62457: LD_INT 1
62459: DEC
62460: ST_TO_ADDR
62461: LD_INT 6
62463: PUSH
62464: LD_VAR 0 8
62468: MINUS
62469: PUSH
62470: FOR_TO
62471: IFFALSE 62563
// begin if i = sort then
62473: LD_VAR 0 3
62477: PUSH
62478: LD_VAR 0 9
62482: EQUAL
62483: IFFALSE 62487
// break ;
62485: GO 62563
// if GetClass ( i ) = 4 then
62487: LD_VAR 0 3
62491: PPUSH
62492: CALL_OW 257
62496: PUSH
62497: LD_INT 4
62499: EQUAL
62500: IFFALSE 62504
// continue ;
62502: GO 62470
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62504: LD_ADDR_VAR 0 11
62508: PUSH
62509: LD_VAR 0 11
62513: PPUSH
62514: LD_VAR 0 11
62518: PUSH
62519: LD_INT 1
62521: PLUS
62522: PPUSH
62523: LD_VAR 0 9
62527: PUSH
62528: LD_VAR 0 3
62532: ARRAY
62533: PPUSH
62534: CALL_OW 2
62538: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62539: LD_ADDR_VAR 0 4
62543: PUSH
62544: LD_VAR 0 4
62548: PUSH
62549: LD_VAR 0 9
62553: PUSH
62554: LD_VAR 0 3
62558: ARRAY
62559: DIFF
62560: ST_TO_ADDR
// end ;
62561: GO 62470
62563: POP
62564: POP
// if p then
62565: LD_VAR 0 11
62569: IFFALSE 62594
// result := Replace ( result , 4 , p ) ;
62571: LD_ADDR_VAR 0 2
62575: PUSH
62576: LD_VAR 0 2
62580: PPUSH
62581: LD_INT 4
62583: PPUSH
62584: LD_VAR 0 11
62588: PPUSH
62589: CALL_OW 1
62593: ST_TO_ADDR
// end ; if tmp and mech < 6 then
62594: LD_VAR 0 4
62598: PUSH
62599: LD_VAR 0 7
62603: PUSH
62604: LD_INT 6
62606: LESS
62607: AND
62608: IFFALSE 62796
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
62610: LD_ADDR_VAR 0 9
62614: PUSH
62615: LD_VAR 0 4
62619: PUSH
62620: LD_VAR 0 8
62624: PUSH
62625: LD_VAR 0 7
62629: UNION
62630: DIFF
62631: PPUSH
62632: LD_INT 3
62634: PPUSH
62635: CALL 50774 0 2
62639: ST_TO_ADDR
// p := [ ] ;
62640: LD_ADDR_VAR 0 11
62644: PUSH
62645: EMPTY
62646: ST_TO_ADDR
// if sort then
62647: LD_VAR 0 9
62651: IFFALSE 62767
// for i = 1 to 6 - mech do
62653: LD_ADDR_VAR 0 3
62657: PUSH
62658: DOUBLE
62659: LD_INT 1
62661: DEC
62662: ST_TO_ADDR
62663: LD_INT 6
62665: PUSH
62666: LD_VAR 0 7
62670: MINUS
62671: PUSH
62672: FOR_TO
62673: IFFALSE 62765
// begin if i = sort then
62675: LD_VAR 0 3
62679: PUSH
62680: LD_VAR 0 9
62684: EQUAL
62685: IFFALSE 62689
// break ;
62687: GO 62765
// if GetClass ( i ) = 3 then
62689: LD_VAR 0 3
62693: PPUSH
62694: CALL_OW 257
62698: PUSH
62699: LD_INT 3
62701: EQUAL
62702: IFFALSE 62706
// continue ;
62704: GO 62672
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62706: LD_ADDR_VAR 0 11
62710: PUSH
62711: LD_VAR 0 11
62715: PPUSH
62716: LD_VAR 0 11
62720: PUSH
62721: LD_INT 1
62723: PLUS
62724: PPUSH
62725: LD_VAR 0 9
62729: PUSH
62730: LD_VAR 0 3
62734: ARRAY
62735: PPUSH
62736: CALL_OW 2
62740: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62741: LD_ADDR_VAR 0 4
62745: PUSH
62746: LD_VAR 0 4
62750: PUSH
62751: LD_VAR 0 9
62755: PUSH
62756: LD_VAR 0 3
62760: ARRAY
62761: DIFF
62762: ST_TO_ADDR
// end ;
62763: GO 62672
62765: POP
62766: POP
// if p then
62767: LD_VAR 0 11
62771: IFFALSE 62796
// result := Replace ( result , 3 , p ) ;
62773: LD_ADDR_VAR 0 2
62777: PUSH
62778: LD_VAR 0 2
62782: PPUSH
62783: LD_INT 3
62785: PPUSH
62786: LD_VAR 0 11
62790: PPUSH
62791: CALL_OW 1
62795: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
62796: LD_VAR 0 4
62800: PUSH
62801: LD_INT 6
62803: GREATER
62804: PUSH
62805: LD_VAR 0 6
62809: PUSH
62810: LD_INT 6
62812: LESS
62813: AND
62814: IFFALSE 63008
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
62816: LD_ADDR_VAR 0 9
62820: PUSH
62821: LD_VAR 0 4
62825: PUSH
62826: LD_VAR 0 8
62830: PUSH
62831: LD_VAR 0 7
62835: UNION
62836: PUSH
62837: LD_VAR 0 6
62841: UNION
62842: DIFF
62843: PPUSH
62844: LD_INT 2
62846: PPUSH
62847: CALL 50774 0 2
62851: ST_TO_ADDR
// p := [ ] ;
62852: LD_ADDR_VAR 0 11
62856: PUSH
62857: EMPTY
62858: ST_TO_ADDR
// if sort then
62859: LD_VAR 0 9
62863: IFFALSE 62979
// for i = 1 to 6 - eng do
62865: LD_ADDR_VAR 0 3
62869: PUSH
62870: DOUBLE
62871: LD_INT 1
62873: DEC
62874: ST_TO_ADDR
62875: LD_INT 6
62877: PUSH
62878: LD_VAR 0 6
62882: MINUS
62883: PUSH
62884: FOR_TO
62885: IFFALSE 62977
// begin if i = sort then
62887: LD_VAR 0 3
62891: PUSH
62892: LD_VAR 0 9
62896: EQUAL
62897: IFFALSE 62901
// break ;
62899: GO 62977
// if GetClass ( i ) = 2 then
62901: LD_VAR 0 3
62905: PPUSH
62906: CALL_OW 257
62910: PUSH
62911: LD_INT 2
62913: EQUAL
62914: IFFALSE 62918
// continue ;
62916: GO 62884
// p := Insert ( p , p + 1 , sort [ i ] ) ;
62918: LD_ADDR_VAR 0 11
62922: PUSH
62923: LD_VAR 0 11
62927: PPUSH
62928: LD_VAR 0 11
62932: PUSH
62933: LD_INT 1
62935: PLUS
62936: PPUSH
62937: LD_VAR 0 9
62941: PUSH
62942: LD_VAR 0 3
62946: ARRAY
62947: PPUSH
62948: CALL_OW 2
62952: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
62953: LD_ADDR_VAR 0 4
62957: PUSH
62958: LD_VAR 0 4
62962: PUSH
62963: LD_VAR 0 9
62967: PUSH
62968: LD_VAR 0 3
62972: ARRAY
62973: DIFF
62974: ST_TO_ADDR
// end ;
62975: GO 62884
62977: POP
62978: POP
// if p then
62979: LD_VAR 0 11
62983: IFFALSE 63008
// result := Replace ( result , 2 , p ) ;
62985: LD_ADDR_VAR 0 2
62989: PUSH
62990: LD_VAR 0 2
62994: PPUSH
62995: LD_INT 2
62997: PPUSH
62998: LD_VAR 0 11
63002: PPUSH
63003: CALL_OW 1
63007: ST_TO_ADDR
// end ; exit ;
63008: GO 64396
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63010: LD_EXP 87
63014: PUSH
63015: LD_EXP 86
63019: PUSH
63020: LD_VAR 0 1
63024: ARRAY
63025: ARRAY
63026: NOT
63027: PUSH
63028: LD_EXP 60
63032: PUSH
63033: LD_VAR 0 1
63037: ARRAY
63038: PPUSH
63039: LD_INT 30
63041: PUSH
63042: LD_INT 3
63044: PUSH
63045: EMPTY
63046: LIST
63047: LIST
63048: PPUSH
63049: CALL_OW 72
63053: AND
63054: PUSH
63055: LD_EXP 65
63059: PUSH
63060: LD_VAR 0 1
63064: ARRAY
63065: AND
63066: IFFALSE 63674
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63068: LD_ADDR_EXP 102
63072: PUSH
63073: LD_EXP 102
63077: PPUSH
63078: LD_VAR 0 1
63082: PPUSH
63083: LD_INT 5
63085: PPUSH
63086: CALL_OW 1
63090: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63091: LD_ADDR_VAR 0 2
63095: PUSH
63096: LD_INT 0
63098: PUSH
63099: LD_INT 0
63101: PUSH
63102: LD_INT 0
63104: PUSH
63105: LD_INT 0
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: LIST
63112: LIST
63113: ST_TO_ADDR
// if sci > 1 then
63114: LD_VAR 0 8
63118: PUSH
63119: LD_INT 1
63121: GREATER
63122: IFFALSE 63150
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63124: LD_ADDR_VAR 0 4
63128: PUSH
63129: LD_VAR 0 4
63133: PUSH
63134: LD_VAR 0 8
63138: PUSH
63139: LD_VAR 0 8
63143: PUSH
63144: LD_INT 1
63146: ARRAY
63147: DIFF
63148: DIFF
63149: ST_TO_ADDR
// if tmp and not sci then
63150: LD_VAR 0 4
63154: PUSH
63155: LD_VAR 0 8
63159: NOT
63160: AND
63161: IFFALSE 63230
// begin sort := SortBySkill ( tmp , 4 ) ;
63163: LD_ADDR_VAR 0 9
63167: PUSH
63168: LD_VAR 0 4
63172: PPUSH
63173: LD_INT 4
63175: PPUSH
63176: CALL 50774 0 2
63180: ST_TO_ADDR
// if sort then
63181: LD_VAR 0 9
63185: IFFALSE 63201
// p := sort [ 1 ] ;
63187: LD_ADDR_VAR 0 11
63191: PUSH
63192: LD_VAR 0 9
63196: PUSH
63197: LD_INT 1
63199: ARRAY
63200: ST_TO_ADDR
// if p then
63201: LD_VAR 0 11
63205: IFFALSE 63230
// result := Replace ( result , 4 , p ) ;
63207: LD_ADDR_VAR 0 2
63211: PUSH
63212: LD_VAR 0 2
63216: PPUSH
63217: LD_INT 4
63219: PPUSH
63220: LD_VAR 0 11
63224: PPUSH
63225: CALL_OW 1
63229: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63230: LD_ADDR_VAR 0 4
63234: PUSH
63235: LD_VAR 0 4
63239: PUSH
63240: LD_VAR 0 7
63244: DIFF
63245: ST_TO_ADDR
// if tmp and mech < 6 then
63246: LD_VAR 0 4
63250: PUSH
63251: LD_VAR 0 7
63255: PUSH
63256: LD_INT 6
63258: LESS
63259: AND
63260: IFFALSE 63448
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63262: LD_ADDR_VAR 0 9
63266: PUSH
63267: LD_VAR 0 4
63271: PUSH
63272: LD_VAR 0 8
63276: PUSH
63277: LD_VAR 0 7
63281: UNION
63282: DIFF
63283: PPUSH
63284: LD_INT 3
63286: PPUSH
63287: CALL 50774 0 2
63291: ST_TO_ADDR
// p := [ ] ;
63292: LD_ADDR_VAR 0 11
63296: PUSH
63297: EMPTY
63298: ST_TO_ADDR
// if sort then
63299: LD_VAR 0 9
63303: IFFALSE 63419
// for i = 1 to 6 - mech do
63305: LD_ADDR_VAR 0 3
63309: PUSH
63310: DOUBLE
63311: LD_INT 1
63313: DEC
63314: ST_TO_ADDR
63315: LD_INT 6
63317: PUSH
63318: LD_VAR 0 7
63322: MINUS
63323: PUSH
63324: FOR_TO
63325: IFFALSE 63417
// begin if i = sort then
63327: LD_VAR 0 3
63331: PUSH
63332: LD_VAR 0 9
63336: EQUAL
63337: IFFALSE 63341
// break ;
63339: GO 63417
// if GetClass ( i ) = 3 then
63341: LD_VAR 0 3
63345: PPUSH
63346: CALL_OW 257
63350: PUSH
63351: LD_INT 3
63353: EQUAL
63354: IFFALSE 63358
// continue ;
63356: GO 63324
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63358: LD_ADDR_VAR 0 11
63362: PUSH
63363: LD_VAR 0 11
63367: PPUSH
63368: LD_VAR 0 11
63372: PUSH
63373: LD_INT 1
63375: PLUS
63376: PPUSH
63377: LD_VAR 0 9
63381: PUSH
63382: LD_VAR 0 3
63386: ARRAY
63387: PPUSH
63388: CALL_OW 2
63392: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63393: LD_ADDR_VAR 0 4
63397: PUSH
63398: LD_VAR 0 4
63402: PUSH
63403: LD_VAR 0 9
63407: PUSH
63408: LD_VAR 0 3
63412: ARRAY
63413: DIFF
63414: ST_TO_ADDR
// end ;
63415: GO 63324
63417: POP
63418: POP
// if p then
63419: LD_VAR 0 11
63423: IFFALSE 63448
// result := Replace ( result , 3 , p ) ;
63425: LD_ADDR_VAR 0 2
63429: PUSH
63430: LD_VAR 0 2
63434: PPUSH
63435: LD_INT 3
63437: PPUSH
63438: LD_VAR 0 11
63442: PPUSH
63443: CALL_OW 1
63447: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
63448: LD_ADDR_VAR 0 4
63452: PUSH
63453: LD_VAR 0 4
63457: PUSH
63458: LD_VAR 0 6
63462: DIFF
63463: ST_TO_ADDR
// if tmp and eng < 6 then
63464: LD_VAR 0 4
63468: PUSH
63469: LD_VAR 0 6
63473: PUSH
63474: LD_INT 6
63476: LESS
63477: AND
63478: IFFALSE 63672
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63480: LD_ADDR_VAR 0 9
63484: PUSH
63485: LD_VAR 0 4
63489: PUSH
63490: LD_VAR 0 8
63494: PUSH
63495: LD_VAR 0 7
63499: UNION
63500: PUSH
63501: LD_VAR 0 6
63505: UNION
63506: DIFF
63507: PPUSH
63508: LD_INT 2
63510: PPUSH
63511: CALL 50774 0 2
63515: ST_TO_ADDR
// p := [ ] ;
63516: LD_ADDR_VAR 0 11
63520: PUSH
63521: EMPTY
63522: ST_TO_ADDR
// if sort then
63523: LD_VAR 0 9
63527: IFFALSE 63643
// for i = 1 to 6 - eng do
63529: LD_ADDR_VAR 0 3
63533: PUSH
63534: DOUBLE
63535: LD_INT 1
63537: DEC
63538: ST_TO_ADDR
63539: LD_INT 6
63541: PUSH
63542: LD_VAR 0 6
63546: MINUS
63547: PUSH
63548: FOR_TO
63549: IFFALSE 63641
// begin if i = sort then
63551: LD_VAR 0 3
63555: PUSH
63556: LD_VAR 0 9
63560: EQUAL
63561: IFFALSE 63565
// break ;
63563: GO 63641
// if GetClass ( i ) = 2 then
63565: LD_VAR 0 3
63569: PPUSH
63570: CALL_OW 257
63574: PUSH
63575: LD_INT 2
63577: EQUAL
63578: IFFALSE 63582
// continue ;
63580: GO 63548
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63582: LD_ADDR_VAR 0 11
63586: PUSH
63587: LD_VAR 0 11
63591: PPUSH
63592: LD_VAR 0 11
63596: PUSH
63597: LD_INT 1
63599: PLUS
63600: PPUSH
63601: LD_VAR 0 9
63605: PUSH
63606: LD_VAR 0 3
63610: ARRAY
63611: PPUSH
63612: CALL_OW 2
63616: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63617: LD_ADDR_VAR 0 4
63621: PUSH
63622: LD_VAR 0 4
63626: PUSH
63627: LD_VAR 0 9
63631: PUSH
63632: LD_VAR 0 3
63636: ARRAY
63637: DIFF
63638: ST_TO_ADDR
// end ;
63639: GO 63548
63641: POP
63642: POP
// if p then
63643: LD_VAR 0 11
63647: IFFALSE 63672
// result := Replace ( result , 2 , p ) ;
63649: LD_ADDR_VAR 0 2
63653: PUSH
63654: LD_VAR 0 2
63658: PPUSH
63659: LD_INT 2
63661: PPUSH
63662: LD_VAR 0 11
63666: PPUSH
63667: CALL_OW 1
63671: ST_TO_ADDR
// end ; exit ;
63672: GO 64396
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
63674: LD_EXP 87
63678: PUSH
63679: LD_EXP 86
63683: PUSH
63684: LD_VAR 0 1
63688: ARRAY
63689: ARRAY
63690: NOT
63691: PUSH
63692: LD_EXP 60
63696: PUSH
63697: LD_VAR 0 1
63701: ARRAY
63702: PPUSH
63703: LD_INT 30
63705: PUSH
63706: LD_INT 3
63708: PUSH
63709: EMPTY
63710: LIST
63711: LIST
63712: PPUSH
63713: CALL_OW 72
63717: AND
63718: PUSH
63719: LD_EXP 65
63723: PUSH
63724: LD_VAR 0 1
63728: ARRAY
63729: NOT
63730: AND
63731: IFFALSE 64396
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
63733: LD_ADDR_EXP 102
63737: PUSH
63738: LD_EXP 102
63742: PPUSH
63743: LD_VAR 0 1
63747: PPUSH
63748: LD_INT 6
63750: PPUSH
63751: CALL_OW 1
63755: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63756: LD_ADDR_VAR 0 2
63760: PUSH
63761: LD_INT 0
63763: PUSH
63764: LD_INT 0
63766: PUSH
63767: LD_INT 0
63769: PUSH
63770: LD_INT 0
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: LIST
63777: LIST
63778: ST_TO_ADDR
// if sci >= 1 then
63779: LD_VAR 0 8
63783: PUSH
63784: LD_INT 1
63786: GREATEREQUAL
63787: IFFALSE 63809
// tmp := tmp diff sci [ 1 ] ;
63789: LD_ADDR_VAR 0 4
63793: PUSH
63794: LD_VAR 0 4
63798: PUSH
63799: LD_VAR 0 8
63803: PUSH
63804: LD_INT 1
63806: ARRAY
63807: DIFF
63808: ST_TO_ADDR
// if tmp and not sci then
63809: LD_VAR 0 4
63813: PUSH
63814: LD_VAR 0 8
63818: NOT
63819: AND
63820: IFFALSE 63889
// begin sort := SortBySkill ( tmp , 4 ) ;
63822: LD_ADDR_VAR 0 9
63826: PUSH
63827: LD_VAR 0 4
63831: PPUSH
63832: LD_INT 4
63834: PPUSH
63835: CALL 50774 0 2
63839: ST_TO_ADDR
// if sort then
63840: LD_VAR 0 9
63844: IFFALSE 63860
// p := sort [ 1 ] ;
63846: LD_ADDR_VAR 0 11
63850: PUSH
63851: LD_VAR 0 9
63855: PUSH
63856: LD_INT 1
63858: ARRAY
63859: ST_TO_ADDR
// if p then
63860: LD_VAR 0 11
63864: IFFALSE 63889
// result := Replace ( result , 4 , p ) ;
63866: LD_ADDR_VAR 0 2
63870: PUSH
63871: LD_VAR 0 2
63875: PPUSH
63876: LD_INT 4
63878: PPUSH
63879: LD_VAR 0 11
63883: PPUSH
63884: CALL_OW 1
63888: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
63889: LD_ADDR_VAR 0 4
63893: PUSH
63894: LD_VAR 0 4
63898: PUSH
63899: LD_VAR 0 7
63903: DIFF
63904: ST_TO_ADDR
// if tmp and mech < 6 then
63905: LD_VAR 0 4
63909: PUSH
63910: LD_VAR 0 7
63914: PUSH
63915: LD_INT 6
63917: LESS
63918: AND
63919: IFFALSE 64101
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
63921: LD_ADDR_VAR 0 9
63925: PUSH
63926: LD_VAR 0 4
63930: PUSH
63931: LD_VAR 0 7
63935: DIFF
63936: PPUSH
63937: LD_INT 3
63939: PPUSH
63940: CALL 50774 0 2
63944: ST_TO_ADDR
// p := [ ] ;
63945: LD_ADDR_VAR 0 11
63949: PUSH
63950: EMPTY
63951: ST_TO_ADDR
// if sort then
63952: LD_VAR 0 9
63956: IFFALSE 64072
// for i = 1 to 6 - mech do
63958: LD_ADDR_VAR 0 3
63962: PUSH
63963: DOUBLE
63964: LD_INT 1
63966: DEC
63967: ST_TO_ADDR
63968: LD_INT 6
63970: PUSH
63971: LD_VAR 0 7
63975: MINUS
63976: PUSH
63977: FOR_TO
63978: IFFALSE 64070
// begin if i = sort then
63980: LD_VAR 0 3
63984: PUSH
63985: LD_VAR 0 9
63989: EQUAL
63990: IFFALSE 63994
// break ;
63992: GO 64070
// if GetClass ( i ) = 3 then
63994: LD_VAR 0 3
63998: PPUSH
63999: CALL_OW 257
64003: PUSH
64004: LD_INT 3
64006: EQUAL
64007: IFFALSE 64011
// continue ;
64009: GO 63977
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64011: LD_ADDR_VAR 0 11
64015: PUSH
64016: LD_VAR 0 11
64020: PPUSH
64021: LD_VAR 0 11
64025: PUSH
64026: LD_INT 1
64028: PLUS
64029: PPUSH
64030: LD_VAR 0 9
64034: PUSH
64035: LD_VAR 0 3
64039: ARRAY
64040: PPUSH
64041: CALL_OW 2
64045: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64046: LD_ADDR_VAR 0 4
64050: PUSH
64051: LD_VAR 0 4
64055: PUSH
64056: LD_VAR 0 9
64060: PUSH
64061: LD_VAR 0 3
64065: ARRAY
64066: DIFF
64067: ST_TO_ADDR
// end ;
64068: GO 63977
64070: POP
64071: POP
// if p then
64072: LD_VAR 0 11
64076: IFFALSE 64101
// result := Replace ( result , 3 , p ) ;
64078: LD_ADDR_VAR 0 2
64082: PUSH
64083: LD_VAR 0 2
64087: PPUSH
64088: LD_INT 3
64090: PPUSH
64091: LD_VAR 0 11
64095: PPUSH
64096: CALL_OW 1
64100: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64101: LD_ADDR_VAR 0 4
64105: PUSH
64106: LD_VAR 0 4
64110: PUSH
64111: LD_VAR 0 6
64115: DIFF
64116: ST_TO_ADDR
// if tmp and eng < 4 then
64117: LD_VAR 0 4
64121: PUSH
64122: LD_VAR 0 6
64126: PUSH
64127: LD_INT 4
64129: LESS
64130: AND
64131: IFFALSE 64321
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64133: LD_ADDR_VAR 0 9
64137: PUSH
64138: LD_VAR 0 4
64142: PUSH
64143: LD_VAR 0 7
64147: PUSH
64148: LD_VAR 0 6
64152: UNION
64153: DIFF
64154: PPUSH
64155: LD_INT 2
64157: PPUSH
64158: CALL 50774 0 2
64162: ST_TO_ADDR
// p := [ ] ;
64163: LD_ADDR_VAR 0 11
64167: PUSH
64168: EMPTY
64169: ST_TO_ADDR
// if sort then
64170: LD_VAR 0 9
64174: IFFALSE 64290
// for i = 1 to 4 - eng do
64176: LD_ADDR_VAR 0 3
64180: PUSH
64181: DOUBLE
64182: LD_INT 1
64184: DEC
64185: ST_TO_ADDR
64186: LD_INT 4
64188: PUSH
64189: LD_VAR 0 6
64193: MINUS
64194: PUSH
64195: FOR_TO
64196: IFFALSE 64288
// begin if i = sort then
64198: LD_VAR 0 3
64202: PUSH
64203: LD_VAR 0 9
64207: EQUAL
64208: IFFALSE 64212
// break ;
64210: GO 64288
// if GetClass ( i ) = 2 then
64212: LD_VAR 0 3
64216: PPUSH
64217: CALL_OW 257
64221: PUSH
64222: LD_INT 2
64224: EQUAL
64225: IFFALSE 64229
// continue ;
64227: GO 64195
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64229: LD_ADDR_VAR 0 11
64233: PUSH
64234: LD_VAR 0 11
64238: PPUSH
64239: LD_VAR 0 11
64243: PUSH
64244: LD_INT 1
64246: PLUS
64247: PPUSH
64248: LD_VAR 0 9
64252: PUSH
64253: LD_VAR 0 3
64257: ARRAY
64258: PPUSH
64259: CALL_OW 2
64263: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64264: LD_ADDR_VAR 0 4
64268: PUSH
64269: LD_VAR 0 4
64273: PUSH
64274: LD_VAR 0 9
64278: PUSH
64279: LD_VAR 0 3
64283: ARRAY
64284: DIFF
64285: ST_TO_ADDR
// end ;
64286: GO 64195
64288: POP
64289: POP
// if p then
64290: LD_VAR 0 11
64294: IFFALSE 64319
// result := Replace ( result , 2 , p ) ;
64296: LD_ADDR_VAR 0 2
64300: PUSH
64301: LD_VAR 0 2
64305: PPUSH
64306: LD_INT 2
64308: PPUSH
64309: LD_VAR 0 11
64313: PPUSH
64314: CALL_OW 1
64318: ST_TO_ADDR
// end else
64319: GO 64365
// for i = eng downto 5 do
64321: LD_ADDR_VAR 0 3
64325: PUSH
64326: DOUBLE
64327: LD_VAR 0 6
64331: INC
64332: ST_TO_ADDR
64333: LD_INT 5
64335: PUSH
64336: FOR_DOWNTO
64337: IFFALSE 64363
// tmp := tmp union eng [ i ] ;
64339: LD_ADDR_VAR 0 4
64343: PUSH
64344: LD_VAR 0 4
64348: PUSH
64349: LD_VAR 0 6
64353: PUSH
64354: LD_VAR 0 3
64358: ARRAY
64359: UNION
64360: ST_TO_ADDR
64361: GO 64336
64363: POP
64364: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
64365: LD_ADDR_VAR 0 2
64369: PUSH
64370: LD_VAR 0 2
64374: PPUSH
64375: LD_INT 1
64377: PPUSH
64378: LD_VAR 0 4
64382: PUSH
64383: LD_VAR 0 5
64387: DIFF
64388: PPUSH
64389: CALL_OW 1
64393: ST_TO_ADDR
// exit ;
64394: GO 64396
// end ; end ;
64396: LD_VAR 0 2
64400: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
64401: LD_INT 0
64403: PPUSH
64404: PPUSH
64405: PPUSH
// if not mc_bases then
64406: LD_EXP 60
64410: NOT
64411: IFFALSE 64415
// exit ;
64413: GO 64557
// for i = 1 to mc_bases do
64415: LD_ADDR_VAR 0 2
64419: PUSH
64420: DOUBLE
64421: LD_INT 1
64423: DEC
64424: ST_TO_ADDR
64425: LD_EXP 60
64429: PUSH
64430: FOR_TO
64431: IFFALSE 64548
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
64433: LD_ADDR_VAR 0 3
64437: PUSH
64438: LD_EXP 60
64442: PUSH
64443: LD_VAR 0 2
64447: ARRAY
64448: PPUSH
64449: LD_INT 21
64451: PUSH
64452: LD_INT 3
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: PUSH
64459: LD_INT 3
64461: PUSH
64462: LD_INT 2
64464: PUSH
64465: LD_INT 30
64467: PUSH
64468: LD_INT 29
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 30
64477: PUSH
64478: LD_INT 30
64480: PUSH
64481: EMPTY
64482: LIST
64483: LIST
64484: PUSH
64485: EMPTY
64486: LIST
64487: LIST
64488: LIST
64489: PUSH
64490: EMPTY
64491: LIST
64492: LIST
64493: PUSH
64494: LD_INT 3
64496: PUSH
64497: LD_INT 24
64499: PUSH
64500: LD_INT 1000
64502: PUSH
64503: EMPTY
64504: LIST
64505: LIST
64506: PUSH
64507: EMPTY
64508: LIST
64509: LIST
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: LIST
64515: PPUSH
64516: CALL_OW 72
64520: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
64521: LD_ADDR_EXP 61
64525: PUSH
64526: LD_EXP 61
64530: PPUSH
64531: LD_VAR 0 2
64535: PPUSH
64536: LD_VAR 0 3
64540: PPUSH
64541: CALL_OW 1
64545: ST_TO_ADDR
// end ;
64546: GO 64430
64548: POP
64549: POP
// RaiseSailEvent ( 101 ) ;
64550: LD_INT 101
64552: PPUSH
64553: CALL_OW 427
// end ;
64557: LD_VAR 0 1
64561: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
64562: LD_INT 0
64564: PPUSH
64565: PPUSH
64566: PPUSH
64567: PPUSH
64568: PPUSH
64569: PPUSH
64570: PPUSH
// if not mc_bases then
64571: LD_EXP 60
64575: NOT
64576: IFFALSE 64580
// exit ;
64578: GO 65142
// for i = 1 to mc_bases do
64580: LD_ADDR_VAR 0 2
64584: PUSH
64585: DOUBLE
64586: LD_INT 1
64588: DEC
64589: ST_TO_ADDR
64590: LD_EXP 60
64594: PUSH
64595: FOR_TO
64596: IFFALSE 65133
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
64598: LD_ADDR_VAR 0 5
64602: PUSH
64603: LD_EXP 60
64607: PUSH
64608: LD_VAR 0 2
64612: ARRAY
64613: PUSH
64614: LD_EXP 89
64618: PUSH
64619: LD_VAR 0 2
64623: ARRAY
64624: UNION
64625: PPUSH
64626: LD_INT 21
64628: PUSH
64629: LD_INT 1
64631: PUSH
64632: EMPTY
64633: LIST
64634: LIST
64635: PUSH
64636: LD_INT 1
64638: PUSH
64639: LD_INT 3
64641: PUSH
64642: LD_INT 54
64644: PUSH
64645: EMPTY
64646: LIST
64647: PUSH
64648: EMPTY
64649: LIST
64650: LIST
64651: PUSH
64652: LD_INT 3
64654: PUSH
64655: LD_INT 24
64657: PUSH
64658: LD_INT 1000
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: LIST
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: PPUSH
64678: CALL_OW 72
64682: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
64683: LD_ADDR_VAR 0 6
64687: PUSH
64688: LD_EXP 60
64692: PUSH
64693: LD_VAR 0 2
64697: ARRAY
64698: PPUSH
64699: LD_INT 21
64701: PUSH
64702: LD_INT 1
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PUSH
64709: LD_INT 1
64711: PUSH
64712: LD_INT 3
64714: PUSH
64715: LD_INT 54
64717: PUSH
64718: EMPTY
64719: LIST
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 3
64727: PUSH
64728: LD_INT 24
64730: PUSH
64731: LD_INT 250
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: EMPTY
64743: LIST
64744: LIST
64745: LIST
64746: PUSH
64747: EMPTY
64748: LIST
64749: LIST
64750: PPUSH
64751: CALL_OW 72
64755: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
64756: LD_ADDR_VAR 0 7
64760: PUSH
64761: LD_VAR 0 5
64765: PUSH
64766: LD_VAR 0 6
64770: DIFF
64771: ST_TO_ADDR
// if not need_heal_1 then
64772: LD_VAR 0 6
64776: NOT
64777: IFFALSE 64810
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
64779: LD_ADDR_EXP 63
64783: PUSH
64784: LD_EXP 63
64788: PPUSH
64789: LD_VAR 0 2
64793: PUSH
64794: LD_INT 1
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PPUSH
64801: EMPTY
64802: PPUSH
64803: CALL 20003 0 3
64807: ST_TO_ADDR
64808: GO 64880
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
64810: LD_ADDR_EXP 63
64814: PUSH
64815: LD_EXP 63
64819: PPUSH
64820: LD_VAR 0 2
64824: PUSH
64825: LD_INT 1
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PPUSH
64832: LD_EXP 63
64836: PUSH
64837: LD_VAR 0 2
64841: ARRAY
64842: PUSH
64843: LD_INT 1
64845: ARRAY
64846: PPUSH
64847: LD_INT 3
64849: PUSH
64850: LD_INT 24
64852: PUSH
64853: LD_INT 1000
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PPUSH
64864: CALL_OW 72
64868: PUSH
64869: LD_VAR 0 6
64873: UNION
64874: PPUSH
64875: CALL 20003 0 3
64879: ST_TO_ADDR
// if not need_heal_2 then
64880: LD_VAR 0 7
64884: NOT
64885: IFFALSE 64918
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
64887: LD_ADDR_EXP 63
64891: PUSH
64892: LD_EXP 63
64896: PPUSH
64897: LD_VAR 0 2
64901: PUSH
64902: LD_INT 2
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: PPUSH
64909: EMPTY
64910: PPUSH
64911: CALL 20003 0 3
64915: ST_TO_ADDR
64916: GO 64950
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
64918: LD_ADDR_EXP 63
64922: PUSH
64923: LD_EXP 63
64927: PPUSH
64928: LD_VAR 0 2
64932: PUSH
64933: LD_INT 2
64935: PUSH
64936: EMPTY
64937: LIST
64938: LIST
64939: PPUSH
64940: LD_VAR 0 7
64944: PPUSH
64945: CALL 20003 0 3
64949: ST_TO_ADDR
// if need_heal_2 then
64950: LD_VAR 0 7
64954: IFFALSE 65115
// for j in need_heal_2 do
64956: LD_ADDR_VAR 0 3
64960: PUSH
64961: LD_VAR 0 7
64965: PUSH
64966: FOR_IN
64967: IFFALSE 65113
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
64969: LD_ADDR_VAR 0 5
64973: PUSH
64974: LD_EXP 60
64978: PUSH
64979: LD_VAR 0 2
64983: ARRAY
64984: PPUSH
64985: LD_INT 2
64987: PUSH
64988: LD_INT 30
64990: PUSH
64991: LD_INT 6
64993: PUSH
64994: EMPTY
64995: LIST
64996: LIST
64997: PUSH
64998: LD_INT 30
65000: PUSH
65001: LD_INT 7
65003: PUSH
65004: EMPTY
65005: LIST
65006: LIST
65007: PUSH
65008: LD_INT 30
65010: PUSH
65011: LD_INT 8
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 30
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 30
65030: PUSH
65031: LD_INT 1
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: LIST
65042: LIST
65043: LIST
65044: LIST
65045: PPUSH
65046: CALL_OW 72
65050: ST_TO_ADDR
// if tmp then
65051: LD_VAR 0 5
65055: IFFALSE 65111
// begin k := NearestUnitToUnit ( tmp , j ) ;
65057: LD_ADDR_VAR 0 4
65061: PUSH
65062: LD_VAR 0 5
65066: PPUSH
65067: LD_VAR 0 3
65071: PPUSH
65072: CALL_OW 74
65076: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
65077: LD_VAR 0 3
65081: PPUSH
65082: LD_VAR 0 4
65086: PPUSH
65087: CALL_OW 296
65091: PUSH
65092: LD_INT 5
65094: GREATER
65095: IFFALSE 65111
// ComMoveToNearbyEntrance ( j , k ) ;
65097: LD_VAR 0 3
65101: PPUSH
65102: LD_VAR 0 4
65106: PPUSH
65107: CALL 53142 0 2
// end ; end ;
65111: GO 64966
65113: POP
65114: POP
// if not need_heal_1 and not need_heal_2 then
65115: LD_VAR 0 6
65119: NOT
65120: PUSH
65121: LD_VAR 0 7
65125: NOT
65126: AND
65127: IFFALSE 65131
// continue ;
65129: GO 64595
// end ;
65131: GO 64595
65133: POP
65134: POP
// RaiseSailEvent ( 102 ) ;
65135: LD_INT 102
65137: PPUSH
65138: CALL_OW 427
// end ;
65142: LD_VAR 0 1
65146: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
65147: LD_INT 0
65149: PPUSH
65150: PPUSH
65151: PPUSH
65152: PPUSH
65153: PPUSH
65154: PPUSH
65155: PPUSH
65156: PPUSH
// if not mc_bases then
65157: LD_EXP 60
65161: NOT
65162: IFFALSE 65166
// exit ;
65164: GO 66049
// for i = 1 to mc_bases do
65166: LD_ADDR_VAR 0 2
65170: PUSH
65171: DOUBLE
65172: LD_INT 1
65174: DEC
65175: ST_TO_ADDR
65176: LD_EXP 60
65180: PUSH
65181: FOR_TO
65182: IFFALSE 66047
// begin if not mc_building_need_repair [ i ] then
65184: LD_EXP 61
65188: PUSH
65189: LD_VAR 0 2
65193: ARRAY
65194: NOT
65195: IFFALSE 65382
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
65197: LD_ADDR_VAR 0 6
65201: PUSH
65202: LD_EXP 79
65206: PUSH
65207: LD_VAR 0 2
65211: ARRAY
65212: PPUSH
65213: LD_INT 3
65215: PUSH
65216: LD_INT 24
65218: PUSH
65219: LD_INT 1000
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: PUSH
65226: EMPTY
65227: LIST
65228: LIST
65229: PUSH
65230: LD_INT 2
65232: PUSH
65233: LD_INT 34
65235: PUSH
65236: LD_INT 13
65238: PUSH
65239: EMPTY
65240: LIST
65241: LIST
65242: PUSH
65243: LD_INT 34
65245: PUSH
65246: LD_INT 52
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 34
65255: PUSH
65256: LD_EXP 110
65260: PUSH
65261: EMPTY
65262: LIST
65263: LIST
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PPUSH
65275: CALL_OW 72
65279: ST_TO_ADDR
// if cranes then
65280: LD_VAR 0 6
65284: IFFALSE 65346
// for j in cranes do
65286: LD_ADDR_VAR 0 3
65290: PUSH
65291: LD_VAR 0 6
65295: PUSH
65296: FOR_IN
65297: IFFALSE 65344
// if not IsInArea ( j , mc_parking [ i ] ) then
65299: LD_VAR 0 3
65303: PPUSH
65304: LD_EXP 84
65308: PUSH
65309: LD_VAR 0 2
65313: ARRAY
65314: PPUSH
65315: CALL_OW 308
65319: NOT
65320: IFFALSE 65342
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65322: LD_VAR 0 3
65326: PPUSH
65327: LD_EXP 84
65331: PUSH
65332: LD_VAR 0 2
65336: ARRAY
65337: PPUSH
65338: CALL_OW 113
65342: GO 65296
65344: POP
65345: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
65346: LD_ADDR_EXP 62
65350: PUSH
65351: LD_EXP 62
65355: PPUSH
65356: LD_VAR 0 2
65360: PPUSH
65361: EMPTY
65362: PPUSH
65363: CALL_OW 1
65367: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
65368: LD_VAR 0 2
65372: PPUSH
65373: LD_INT 101
65375: PPUSH
65376: CALL 60234 0 2
// continue ;
65380: GO 65181
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
65382: LD_ADDR_EXP 66
65386: PUSH
65387: LD_EXP 66
65391: PPUSH
65392: LD_VAR 0 2
65396: PPUSH
65397: EMPTY
65398: PPUSH
65399: CALL_OW 1
65403: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
65404: LD_VAR 0 2
65408: PPUSH
65409: LD_INT 103
65411: PPUSH
65412: CALL 60234 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
65416: LD_ADDR_VAR 0 5
65420: PUSH
65421: LD_EXP 60
65425: PUSH
65426: LD_VAR 0 2
65430: ARRAY
65431: PUSH
65432: LD_EXP 89
65436: PUSH
65437: LD_VAR 0 2
65441: ARRAY
65442: UNION
65443: PPUSH
65444: LD_INT 2
65446: PUSH
65447: LD_INT 25
65449: PUSH
65450: LD_INT 2
65452: PUSH
65453: EMPTY
65454: LIST
65455: LIST
65456: PUSH
65457: LD_INT 25
65459: PUSH
65460: LD_INT 16
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: EMPTY
65468: LIST
65469: LIST
65470: LIST
65471: PUSH
65472: EMPTY
65473: LIST
65474: PPUSH
65475: CALL_OW 72
65479: ST_TO_ADDR
// if mc_need_heal [ i ] then
65480: LD_EXP 63
65484: PUSH
65485: LD_VAR 0 2
65489: ARRAY
65490: IFFALSE 65534
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
65492: LD_ADDR_VAR 0 5
65496: PUSH
65497: LD_VAR 0 5
65501: PUSH
65502: LD_EXP 63
65506: PUSH
65507: LD_VAR 0 2
65511: ARRAY
65512: PUSH
65513: LD_INT 1
65515: ARRAY
65516: PUSH
65517: LD_EXP 63
65521: PUSH
65522: LD_VAR 0 2
65526: ARRAY
65527: PUSH
65528: LD_INT 2
65530: ARRAY
65531: UNION
65532: DIFF
65533: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
65534: LD_ADDR_VAR 0 6
65538: PUSH
65539: LD_EXP 79
65543: PUSH
65544: LD_VAR 0 2
65548: ARRAY
65549: PPUSH
65550: LD_INT 2
65552: PUSH
65553: LD_INT 34
65555: PUSH
65556: LD_INT 13
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: LD_INT 34
65565: PUSH
65566: LD_INT 52
65568: PUSH
65569: EMPTY
65570: LIST
65571: LIST
65572: PUSH
65573: LD_INT 34
65575: PUSH
65576: LD_EXP 110
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: PUSH
65585: EMPTY
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: PPUSH
65591: CALL_OW 72
65595: ST_TO_ADDR
// if cranes then
65596: LD_VAR 0 6
65600: IFFALSE 65736
// begin for j in cranes do
65602: LD_ADDR_VAR 0 3
65606: PUSH
65607: LD_VAR 0 6
65611: PUSH
65612: FOR_IN
65613: IFFALSE 65734
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
65615: LD_VAR 0 3
65619: PPUSH
65620: CALL_OW 256
65624: PUSH
65625: LD_INT 1000
65627: EQUAL
65628: PUSH
65629: LD_VAR 0 3
65633: PPUSH
65634: CALL_OW 314
65638: NOT
65639: AND
65640: IFFALSE 65674
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
65642: LD_VAR 0 3
65646: PPUSH
65647: LD_EXP 61
65651: PUSH
65652: LD_VAR 0 2
65656: ARRAY
65657: PPUSH
65658: LD_VAR 0 3
65662: PPUSH
65663: CALL_OW 74
65667: PPUSH
65668: CALL_OW 130
65672: GO 65732
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
65674: LD_VAR 0 3
65678: PPUSH
65679: CALL_OW 256
65683: PUSH
65684: LD_INT 500
65686: LESS
65687: PUSH
65688: LD_VAR 0 3
65692: PPUSH
65693: LD_EXP 84
65697: PUSH
65698: LD_VAR 0 2
65702: ARRAY
65703: PPUSH
65704: CALL_OW 308
65708: NOT
65709: AND
65710: IFFALSE 65732
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65712: LD_VAR 0 3
65716: PPUSH
65717: LD_EXP 84
65721: PUSH
65722: LD_VAR 0 2
65726: ARRAY
65727: PPUSH
65728: CALL_OW 113
// end ;
65732: GO 65612
65734: POP
65735: POP
// end ; if tmp > 3 then
65736: LD_VAR 0 5
65740: PUSH
65741: LD_INT 3
65743: GREATER
65744: IFFALSE 65764
// tmp := ShrinkArray ( tmp , 4 ) ;
65746: LD_ADDR_VAR 0 5
65750: PUSH
65751: LD_VAR 0 5
65755: PPUSH
65756: LD_INT 4
65758: PPUSH
65759: CALL 52580 0 2
65763: ST_TO_ADDR
// if not tmp then
65764: LD_VAR 0 5
65768: NOT
65769: IFFALSE 65773
// continue ;
65771: GO 65181
// for j in tmp do
65773: LD_ADDR_VAR 0 3
65777: PUSH
65778: LD_VAR 0 5
65782: PUSH
65783: FOR_IN
65784: IFFALSE 66043
// begin if IsInUnit ( j ) then
65786: LD_VAR 0 3
65790: PPUSH
65791: CALL_OW 310
65795: IFFALSE 65806
// ComExitBuilding ( j ) ;
65797: LD_VAR 0 3
65801: PPUSH
65802: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
65806: LD_VAR 0 3
65810: PUSH
65811: LD_EXP 62
65815: PUSH
65816: LD_VAR 0 2
65820: ARRAY
65821: IN
65822: NOT
65823: IFFALSE 65881
// begin SetTag ( j , 101 ) ;
65825: LD_VAR 0 3
65829: PPUSH
65830: LD_INT 101
65832: PPUSH
65833: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
65837: LD_ADDR_EXP 62
65841: PUSH
65842: LD_EXP 62
65846: PPUSH
65847: LD_VAR 0 2
65851: PUSH
65852: LD_EXP 62
65856: PUSH
65857: LD_VAR 0 2
65861: ARRAY
65862: PUSH
65863: LD_INT 1
65865: PLUS
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PPUSH
65871: LD_VAR 0 3
65875: PPUSH
65876: CALL 20003 0 3
65880: ST_TO_ADDR
// end ; wait ( 1 ) ;
65881: LD_INT 1
65883: PPUSH
65884: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
65888: LD_ADDR_VAR 0 7
65892: PUSH
65893: LD_EXP 61
65897: PUSH
65898: LD_VAR 0 2
65902: ARRAY
65903: ST_TO_ADDR
// if mc_scan [ i ] then
65904: LD_EXP 83
65908: PUSH
65909: LD_VAR 0 2
65913: ARRAY
65914: IFFALSE 65976
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
65916: LD_ADDR_VAR 0 7
65920: PUSH
65921: LD_EXP 61
65925: PUSH
65926: LD_VAR 0 2
65930: ARRAY
65931: PPUSH
65932: LD_INT 3
65934: PUSH
65935: LD_INT 30
65937: PUSH
65938: LD_INT 32
65940: PUSH
65941: EMPTY
65942: LIST
65943: LIST
65944: PUSH
65945: LD_INT 30
65947: PUSH
65948: LD_INT 33
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 30
65957: PUSH
65958: LD_INT 31
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: PPUSH
65971: CALL_OW 72
65975: ST_TO_ADDR
// if not to_repair_tmp then
65976: LD_VAR 0 7
65980: NOT
65981: IFFALSE 65985
// continue ;
65983: GO 65783
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
65985: LD_ADDR_VAR 0 8
65989: PUSH
65990: LD_VAR 0 7
65994: PPUSH
65995: LD_VAR 0 3
65999: PPUSH
66000: CALL_OW 74
66004: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
66005: LD_VAR 0 8
66009: PPUSH
66010: LD_INT 16
66012: PPUSH
66013: CALL 22602 0 2
66017: PUSH
66018: LD_INT 4
66020: ARRAY
66021: PUSH
66022: LD_INT 10
66024: LESS
66025: IFFALSE 66041
// ComRepairBuilding ( j , to_repair ) ;
66027: LD_VAR 0 3
66031: PPUSH
66032: LD_VAR 0 8
66036: PPUSH
66037: CALL_OW 130
// end ;
66041: GO 65783
66043: POP
66044: POP
// end ;
66045: GO 65181
66047: POP
66048: POP
// end ;
66049: LD_VAR 0 1
66053: RET
// export function MC_Heal ; var i , j , tmp ; begin
66054: LD_INT 0
66056: PPUSH
66057: PPUSH
66058: PPUSH
66059: PPUSH
// if not mc_bases then
66060: LD_EXP 60
66064: NOT
66065: IFFALSE 66069
// exit ;
66067: GO 66471
// for i = 1 to mc_bases do
66069: LD_ADDR_VAR 0 2
66073: PUSH
66074: DOUBLE
66075: LD_INT 1
66077: DEC
66078: ST_TO_ADDR
66079: LD_EXP 60
66083: PUSH
66084: FOR_TO
66085: IFFALSE 66469
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66087: LD_EXP 63
66091: PUSH
66092: LD_VAR 0 2
66096: ARRAY
66097: PUSH
66098: LD_INT 1
66100: ARRAY
66101: NOT
66102: PUSH
66103: LD_EXP 63
66107: PUSH
66108: LD_VAR 0 2
66112: ARRAY
66113: PUSH
66114: LD_INT 2
66116: ARRAY
66117: NOT
66118: AND
66119: IFFALSE 66157
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66121: LD_ADDR_EXP 64
66125: PUSH
66126: LD_EXP 64
66130: PPUSH
66131: LD_VAR 0 2
66135: PPUSH
66136: EMPTY
66137: PPUSH
66138: CALL_OW 1
66142: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66143: LD_VAR 0 2
66147: PPUSH
66148: LD_INT 102
66150: PPUSH
66151: CALL 60234 0 2
// continue ;
66155: GO 66084
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66157: LD_ADDR_VAR 0 4
66161: PUSH
66162: LD_EXP 60
66166: PUSH
66167: LD_VAR 0 2
66171: ARRAY
66172: PPUSH
66173: LD_INT 25
66175: PUSH
66176: LD_INT 4
66178: PUSH
66179: EMPTY
66180: LIST
66181: LIST
66182: PPUSH
66183: CALL_OW 72
66187: ST_TO_ADDR
// if not tmp then
66188: LD_VAR 0 4
66192: NOT
66193: IFFALSE 66197
// continue ;
66195: GO 66084
// if mc_taming [ i ] then
66197: LD_EXP 91
66201: PUSH
66202: LD_VAR 0 2
66206: ARRAY
66207: IFFALSE 66231
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66209: LD_ADDR_EXP 91
66213: PUSH
66214: LD_EXP 91
66218: PPUSH
66219: LD_VAR 0 2
66223: PPUSH
66224: EMPTY
66225: PPUSH
66226: CALL_OW 1
66230: ST_TO_ADDR
// for j in tmp do
66231: LD_ADDR_VAR 0 3
66235: PUSH
66236: LD_VAR 0 4
66240: PUSH
66241: FOR_IN
66242: IFFALSE 66465
// begin if IsInUnit ( j ) then
66244: LD_VAR 0 3
66248: PPUSH
66249: CALL_OW 310
66253: IFFALSE 66264
// ComExitBuilding ( j ) ;
66255: LD_VAR 0 3
66259: PPUSH
66260: CALL_OW 122
// if not j in mc_healers [ i ] then
66264: LD_VAR 0 3
66268: PUSH
66269: LD_EXP 64
66273: PUSH
66274: LD_VAR 0 2
66278: ARRAY
66279: IN
66280: NOT
66281: IFFALSE 66327
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66283: LD_ADDR_EXP 64
66287: PUSH
66288: LD_EXP 64
66292: PPUSH
66293: LD_VAR 0 2
66297: PUSH
66298: LD_EXP 64
66302: PUSH
66303: LD_VAR 0 2
66307: ARRAY
66308: PUSH
66309: LD_INT 1
66311: PLUS
66312: PUSH
66313: EMPTY
66314: LIST
66315: LIST
66316: PPUSH
66317: LD_VAR 0 3
66321: PPUSH
66322: CALL 20003 0 3
66326: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66327: LD_VAR 0 3
66331: PPUSH
66332: CALL_OW 110
66336: PUSH
66337: LD_INT 102
66339: NONEQUAL
66340: IFFALSE 66354
// SetTag ( j , 102 ) ;
66342: LD_VAR 0 3
66346: PPUSH
66347: LD_INT 102
66349: PPUSH
66350: CALL_OW 109
// Wait ( 3 ) ;
66354: LD_INT 3
66356: PPUSH
66357: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66361: LD_EXP 63
66365: PUSH
66366: LD_VAR 0 2
66370: ARRAY
66371: PUSH
66372: LD_INT 1
66374: ARRAY
66375: IFFALSE 66407
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
66377: LD_VAR 0 3
66381: PPUSH
66382: LD_EXP 63
66386: PUSH
66387: LD_VAR 0 2
66391: ARRAY
66392: PUSH
66393: LD_INT 1
66395: ARRAY
66396: PUSH
66397: LD_INT 1
66399: ARRAY
66400: PPUSH
66401: CALL_OW 128
66405: GO 66463
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
66407: LD_VAR 0 3
66411: PPUSH
66412: CALL_OW 314
66416: NOT
66417: PUSH
66418: LD_EXP 63
66422: PUSH
66423: LD_VAR 0 2
66427: ARRAY
66428: PUSH
66429: LD_INT 2
66431: ARRAY
66432: AND
66433: IFFALSE 66463
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
66435: LD_VAR 0 3
66439: PPUSH
66440: LD_EXP 63
66444: PUSH
66445: LD_VAR 0 2
66449: ARRAY
66450: PUSH
66451: LD_INT 2
66453: ARRAY
66454: PUSH
66455: LD_INT 1
66457: ARRAY
66458: PPUSH
66459: CALL_OW 128
// end ;
66463: GO 66241
66465: POP
66466: POP
// end ;
66467: GO 66084
66469: POP
66470: POP
// end ;
66471: LD_VAR 0 1
66475: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
66476: LD_INT 0
66478: PPUSH
66479: PPUSH
66480: PPUSH
66481: PPUSH
66482: PPUSH
// if not mc_bases then
66483: LD_EXP 60
66487: NOT
66488: IFFALSE 66492
// exit ;
66490: GO 67663
// for i = 1 to mc_bases do
66492: LD_ADDR_VAR 0 2
66496: PUSH
66497: DOUBLE
66498: LD_INT 1
66500: DEC
66501: ST_TO_ADDR
66502: LD_EXP 60
66506: PUSH
66507: FOR_TO
66508: IFFALSE 67661
// begin if mc_scan [ i ] then
66510: LD_EXP 83
66514: PUSH
66515: LD_VAR 0 2
66519: ARRAY
66520: IFFALSE 66524
// continue ;
66522: GO 66507
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
66524: LD_EXP 65
66528: PUSH
66529: LD_VAR 0 2
66533: ARRAY
66534: NOT
66535: PUSH
66536: LD_EXP 67
66540: PUSH
66541: LD_VAR 0 2
66545: ARRAY
66546: NOT
66547: AND
66548: PUSH
66549: LD_EXP 66
66553: PUSH
66554: LD_VAR 0 2
66558: ARRAY
66559: AND
66560: IFFALSE 66598
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
66562: LD_ADDR_EXP 66
66566: PUSH
66567: LD_EXP 66
66571: PPUSH
66572: LD_VAR 0 2
66576: PPUSH
66577: EMPTY
66578: PPUSH
66579: CALL_OW 1
66583: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66584: LD_VAR 0 2
66588: PPUSH
66589: LD_INT 103
66591: PPUSH
66592: CALL 60234 0 2
// continue ;
66596: GO 66507
// end ; if mc_construct_list [ i ] then
66598: LD_EXP 67
66602: PUSH
66603: LD_VAR 0 2
66607: ARRAY
66608: IFFALSE 66828
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
66610: LD_ADDR_VAR 0 4
66614: PUSH
66615: LD_EXP 60
66619: PUSH
66620: LD_VAR 0 2
66624: ARRAY
66625: PPUSH
66626: LD_INT 25
66628: PUSH
66629: LD_INT 2
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PPUSH
66636: CALL_OW 72
66640: PUSH
66641: LD_EXP 62
66645: PUSH
66646: LD_VAR 0 2
66650: ARRAY
66651: DIFF
66652: ST_TO_ADDR
// if not tmp then
66653: LD_VAR 0 4
66657: NOT
66658: IFFALSE 66662
// continue ;
66660: GO 66507
// for j in tmp do
66662: LD_ADDR_VAR 0 3
66666: PUSH
66667: LD_VAR 0 4
66671: PUSH
66672: FOR_IN
66673: IFFALSE 66824
// begin if not mc_builders [ i ] then
66675: LD_EXP 66
66679: PUSH
66680: LD_VAR 0 2
66684: ARRAY
66685: NOT
66686: IFFALSE 66744
// begin SetTag ( j , 103 ) ;
66688: LD_VAR 0 3
66692: PPUSH
66693: LD_INT 103
66695: PPUSH
66696: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
66700: LD_ADDR_EXP 66
66704: PUSH
66705: LD_EXP 66
66709: PPUSH
66710: LD_VAR 0 2
66714: PUSH
66715: LD_EXP 66
66719: PUSH
66720: LD_VAR 0 2
66724: ARRAY
66725: PUSH
66726: LD_INT 1
66728: PLUS
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PPUSH
66734: LD_VAR 0 3
66738: PPUSH
66739: CALL 20003 0 3
66743: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
66744: LD_VAR 0 3
66748: PPUSH
66749: CALL_OW 310
66753: IFFALSE 66764
// ComExitBuilding ( j ) ;
66755: LD_VAR 0 3
66759: PPUSH
66760: CALL_OW 122
// wait ( 3 ) ;
66764: LD_INT 3
66766: PPUSH
66767: CALL_OW 67
// if not mc_construct_list [ i ] then
66771: LD_EXP 67
66775: PUSH
66776: LD_VAR 0 2
66780: ARRAY
66781: NOT
66782: IFFALSE 66786
// break ;
66784: GO 66824
// if not HasTask ( j ) then
66786: LD_VAR 0 3
66790: PPUSH
66791: CALL_OW 314
66795: NOT
66796: IFFALSE 66822
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
66798: LD_VAR 0 3
66802: PPUSH
66803: LD_EXP 67
66807: PUSH
66808: LD_VAR 0 2
66812: ARRAY
66813: PUSH
66814: LD_INT 1
66816: ARRAY
66817: PPUSH
66818: CALL 22866 0 2
// end ;
66822: GO 66672
66824: POP
66825: POP
// end else
66826: GO 67659
// if mc_build_list [ i ] then
66828: LD_EXP 65
66832: PUSH
66833: LD_VAR 0 2
66837: ARRAY
66838: IFFALSE 67659
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66840: LD_ADDR_VAR 0 5
66844: PUSH
66845: LD_EXP 60
66849: PUSH
66850: LD_VAR 0 2
66854: ARRAY
66855: PPUSH
66856: LD_INT 2
66858: PUSH
66859: LD_INT 30
66861: PUSH
66862: LD_INT 0
66864: PUSH
66865: EMPTY
66866: LIST
66867: LIST
66868: PUSH
66869: LD_INT 30
66871: PUSH
66872: LD_INT 1
66874: PUSH
66875: EMPTY
66876: LIST
66877: LIST
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: LIST
66883: PPUSH
66884: CALL_OW 72
66888: ST_TO_ADDR
// if depot then
66889: LD_VAR 0 5
66893: IFFALSE 66911
// depot := depot [ 1 ] else
66895: LD_ADDR_VAR 0 5
66899: PUSH
66900: LD_VAR 0 5
66904: PUSH
66905: LD_INT 1
66907: ARRAY
66908: ST_TO_ADDR
66909: GO 66919
// depot := 0 ;
66911: LD_ADDR_VAR 0 5
66915: PUSH
66916: LD_INT 0
66918: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
66919: LD_EXP 65
66923: PUSH
66924: LD_VAR 0 2
66928: ARRAY
66929: PUSH
66930: LD_INT 1
66932: ARRAY
66933: PUSH
66934: LD_INT 1
66936: ARRAY
66937: PPUSH
66938: CALL 22690 0 1
66942: PUSH
66943: LD_EXP 60
66947: PUSH
66948: LD_VAR 0 2
66952: ARRAY
66953: PPUSH
66954: LD_INT 2
66956: PUSH
66957: LD_INT 30
66959: PUSH
66960: LD_INT 2
66962: PUSH
66963: EMPTY
66964: LIST
66965: LIST
66966: PUSH
66967: LD_INT 30
66969: PUSH
66970: LD_INT 3
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: PUSH
66977: EMPTY
66978: LIST
66979: LIST
66980: LIST
66981: PPUSH
66982: CALL_OW 72
66986: NOT
66987: AND
66988: IFFALSE 67093
// begin for j = 1 to mc_build_list [ i ] do
66990: LD_ADDR_VAR 0 3
66994: PUSH
66995: DOUBLE
66996: LD_INT 1
66998: DEC
66999: ST_TO_ADDR
67000: LD_EXP 65
67004: PUSH
67005: LD_VAR 0 2
67009: ARRAY
67010: PUSH
67011: FOR_TO
67012: IFFALSE 67091
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67014: LD_EXP 65
67018: PUSH
67019: LD_VAR 0 2
67023: ARRAY
67024: PUSH
67025: LD_VAR 0 3
67029: ARRAY
67030: PUSH
67031: LD_INT 1
67033: ARRAY
67034: PUSH
67035: LD_INT 2
67037: EQUAL
67038: IFFALSE 67089
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67040: LD_ADDR_EXP 65
67044: PUSH
67045: LD_EXP 65
67049: PPUSH
67050: LD_VAR 0 2
67054: PPUSH
67055: LD_EXP 65
67059: PUSH
67060: LD_VAR 0 2
67064: ARRAY
67065: PPUSH
67066: LD_VAR 0 3
67070: PPUSH
67071: LD_INT 1
67073: PPUSH
67074: LD_INT 0
67076: PPUSH
67077: CALL 19421 0 4
67081: PPUSH
67082: CALL_OW 1
67086: ST_TO_ADDR
// break ;
67087: GO 67091
// end ;
67089: GO 67011
67091: POP
67092: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67093: LD_EXP 65
67097: PUSH
67098: LD_VAR 0 2
67102: ARRAY
67103: PUSH
67104: LD_INT 1
67106: ARRAY
67107: PUSH
67108: LD_INT 1
67110: ARRAY
67111: PUSH
67112: LD_INT 0
67114: EQUAL
67115: PUSH
67116: LD_VAR 0 5
67120: PUSH
67121: LD_VAR 0 5
67125: PPUSH
67126: LD_EXP 65
67130: PUSH
67131: LD_VAR 0 2
67135: ARRAY
67136: PUSH
67137: LD_INT 1
67139: ARRAY
67140: PUSH
67141: LD_INT 1
67143: ARRAY
67144: PPUSH
67145: LD_EXP 65
67149: PUSH
67150: LD_VAR 0 2
67154: ARRAY
67155: PUSH
67156: LD_INT 1
67158: ARRAY
67159: PUSH
67160: LD_INT 2
67162: ARRAY
67163: PPUSH
67164: LD_EXP 65
67168: PUSH
67169: LD_VAR 0 2
67173: ARRAY
67174: PUSH
67175: LD_INT 1
67177: ARRAY
67178: PUSH
67179: LD_INT 3
67181: ARRAY
67182: PPUSH
67183: LD_EXP 65
67187: PUSH
67188: LD_VAR 0 2
67192: ARRAY
67193: PUSH
67194: LD_INT 1
67196: ARRAY
67197: PUSH
67198: LD_INT 4
67200: ARRAY
67201: PPUSH
67202: CALL 28106 0 5
67206: AND
67207: OR
67208: IFFALSE 67489
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67210: LD_ADDR_VAR 0 4
67214: PUSH
67215: LD_EXP 60
67219: PUSH
67220: LD_VAR 0 2
67224: ARRAY
67225: PPUSH
67226: LD_INT 25
67228: PUSH
67229: LD_INT 2
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PPUSH
67236: CALL_OW 72
67240: PUSH
67241: LD_EXP 62
67245: PUSH
67246: LD_VAR 0 2
67250: ARRAY
67251: DIFF
67252: ST_TO_ADDR
// if not tmp then
67253: LD_VAR 0 4
67257: NOT
67258: IFFALSE 67262
// continue ;
67260: GO 66507
// for j in tmp do
67262: LD_ADDR_VAR 0 3
67266: PUSH
67267: LD_VAR 0 4
67271: PUSH
67272: FOR_IN
67273: IFFALSE 67485
// begin if not mc_builders [ i ] then
67275: LD_EXP 66
67279: PUSH
67280: LD_VAR 0 2
67284: ARRAY
67285: NOT
67286: IFFALSE 67344
// begin SetTag ( j , 103 ) ;
67288: LD_VAR 0 3
67292: PPUSH
67293: LD_INT 103
67295: PPUSH
67296: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67300: LD_ADDR_EXP 66
67304: PUSH
67305: LD_EXP 66
67309: PPUSH
67310: LD_VAR 0 2
67314: PUSH
67315: LD_EXP 66
67319: PUSH
67320: LD_VAR 0 2
67324: ARRAY
67325: PUSH
67326: LD_INT 1
67328: PLUS
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PPUSH
67334: LD_VAR 0 3
67338: PPUSH
67339: CALL 20003 0 3
67343: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67344: LD_VAR 0 3
67348: PPUSH
67349: CALL_OW 310
67353: IFFALSE 67364
// ComExitBuilding ( j ) ;
67355: LD_VAR 0 3
67359: PPUSH
67360: CALL_OW 122
// wait ( 3 ) ;
67364: LD_INT 3
67366: PPUSH
67367: CALL_OW 67
// if not mc_build_list [ i ] then
67371: LD_EXP 65
67375: PUSH
67376: LD_VAR 0 2
67380: ARRAY
67381: NOT
67382: IFFALSE 67386
// break ;
67384: GO 67485
// if not HasTask ( j ) then
67386: LD_VAR 0 3
67390: PPUSH
67391: CALL_OW 314
67395: NOT
67396: IFFALSE 67483
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
67398: LD_VAR 0 3
67402: PPUSH
67403: LD_EXP 65
67407: PUSH
67408: LD_VAR 0 2
67412: ARRAY
67413: PUSH
67414: LD_INT 1
67416: ARRAY
67417: PUSH
67418: LD_INT 1
67420: ARRAY
67421: PPUSH
67422: LD_EXP 65
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: PUSH
67433: LD_INT 1
67435: ARRAY
67436: PUSH
67437: LD_INT 2
67439: ARRAY
67440: PPUSH
67441: LD_EXP 65
67445: PUSH
67446: LD_VAR 0 2
67450: ARRAY
67451: PUSH
67452: LD_INT 1
67454: ARRAY
67455: PUSH
67456: LD_INT 3
67458: ARRAY
67459: PPUSH
67460: LD_EXP 65
67464: PUSH
67465: LD_VAR 0 2
67469: ARRAY
67470: PUSH
67471: LD_INT 1
67473: ARRAY
67474: PUSH
67475: LD_INT 4
67477: ARRAY
67478: PPUSH
67479: CALL_OW 145
// end ;
67483: GO 67272
67485: POP
67486: POP
// end else
67487: GO 67659
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
67489: LD_EXP 60
67493: PUSH
67494: LD_VAR 0 2
67498: ARRAY
67499: PPUSH
67500: LD_EXP 65
67504: PUSH
67505: LD_VAR 0 2
67509: ARRAY
67510: PUSH
67511: LD_INT 1
67513: ARRAY
67514: PUSH
67515: LD_INT 1
67517: ARRAY
67518: PPUSH
67519: LD_EXP 65
67523: PUSH
67524: LD_VAR 0 2
67528: ARRAY
67529: PUSH
67530: LD_INT 1
67532: ARRAY
67533: PUSH
67534: LD_INT 2
67536: ARRAY
67537: PPUSH
67538: LD_EXP 65
67542: PUSH
67543: LD_VAR 0 2
67547: ARRAY
67548: PUSH
67549: LD_INT 1
67551: ARRAY
67552: PUSH
67553: LD_INT 3
67555: ARRAY
67556: PPUSH
67557: LD_EXP 65
67561: PUSH
67562: LD_VAR 0 2
67566: ARRAY
67567: PUSH
67568: LD_INT 1
67570: ARRAY
67571: PUSH
67572: LD_INT 4
67574: ARRAY
67575: PPUSH
67576: LD_EXP 60
67580: PUSH
67581: LD_VAR 0 2
67585: ARRAY
67586: PPUSH
67587: LD_INT 21
67589: PUSH
67590: LD_INT 3
67592: PUSH
67593: EMPTY
67594: LIST
67595: LIST
67596: PPUSH
67597: CALL_OW 72
67601: PPUSH
67602: EMPTY
67603: PPUSH
67604: CALL 26856 0 7
67608: NOT
67609: IFFALSE 67659
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
67611: LD_ADDR_EXP 65
67615: PUSH
67616: LD_EXP 65
67620: PPUSH
67621: LD_VAR 0 2
67625: PPUSH
67626: LD_EXP 65
67630: PUSH
67631: LD_VAR 0 2
67635: ARRAY
67636: PPUSH
67637: LD_INT 1
67639: PPUSH
67640: LD_INT 1
67642: NEG
67643: PPUSH
67644: LD_INT 0
67646: PPUSH
67647: CALL 19421 0 4
67651: PPUSH
67652: CALL_OW 1
67656: ST_TO_ADDR
// continue ;
67657: GO 66507
// end ; end ; end ;
67659: GO 66507
67661: POP
67662: POP
// end ;
67663: LD_VAR 0 1
67667: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
67668: LD_INT 0
67670: PPUSH
67671: PPUSH
67672: PPUSH
67673: PPUSH
67674: PPUSH
67675: PPUSH
// if not mc_bases then
67676: LD_EXP 60
67680: NOT
67681: IFFALSE 67685
// exit ;
67683: GO 68112
// for i = 1 to mc_bases do
67685: LD_ADDR_VAR 0 2
67689: PUSH
67690: DOUBLE
67691: LD_INT 1
67693: DEC
67694: ST_TO_ADDR
67695: LD_EXP 60
67699: PUSH
67700: FOR_TO
67701: IFFALSE 68110
// begin tmp := mc_build_upgrade [ i ] ;
67703: LD_ADDR_VAR 0 4
67707: PUSH
67708: LD_EXP 92
67712: PUSH
67713: LD_VAR 0 2
67717: ARRAY
67718: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
67719: LD_ADDR_VAR 0 6
67723: PUSH
67724: LD_EXP 93
67728: PUSH
67729: LD_VAR 0 2
67733: ARRAY
67734: PPUSH
67735: LD_INT 2
67737: PUSH
67738: LD_INT 30
67740: PUSH
67741: LD_INT 6
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 30
67750: PUSH
67751: LD_INT 7
67753: PUSH
67754: EMPTY
67755: LIST
67756: LIST
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: LIST
67762: PPUSH
67763: CALL_OW 72
67767: ST_TO_ADDR
// if not tmp and not lab then
67768: LD_VAR 0 4
67772: NOT
67773: PUSH
67774: LD_VAR 0 6
67778: NOT
67779: AND
67780: IFFALSE 67784
// continue ;
67782: GO 67700
// if tmp then
67784: LD_VAR 0 4
67788: IFFALSE 67908
// for j in tmp do
67790: LD_ADDR_VAR 0 3
67794: PUSH
67795: LD_VAR 0 4
67799: PUSH
67800: FOR_IN
67801: IFFALSE 67906
// begin if UpgradeCost ( j ) then
67803: LD_VAR 0 3
67807: PPUSH
67808: CALL 26516 0 1
67812: IFFALSE 67904
// begin ComUpgrade ( j ) ;
67814: LD_VAR 0 3
67818: PPUSH
67819: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
67823: LD_ADDR_EXP 92
67827: PUSH
67828: LD_EXP 92
67832: PPUSH
67833: LD_VAR 0 2
67837: PPUSH
67838: LD_EXP 92
67842: PUSH
67843: LD_VAR 0 2
67847: ARRAY
67848: PUSH
67849: LD_VAR 0 3
67853: DIFF
67854: PPUSH
67855: CALL_OW 1
67859: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
67860: LD_ADDR_EXP 67
67864: PUSH
67865: LD_EXP 67
67869: PPUSH
67870: LD_VAR 0 2
67874: PUSH
67875: LD_EXP 67
67879: PUSH
67880: LD_VAR 0 2
67884: ARRAY
67885: PUSH
67886: LD_INT 1
67888: PLUS
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PPUSH
67894: LD_VAR 0 3
67898: PPUSH
67899: CALL 20003 0 3
67903: ST_TO_ADDR
// end ; end ;
67904: GO 67800
67906: POP
67907: POP
// if not lab or not mc_lab_upgrade [ i ] then
67908: LD_VAR 0 6
67912: NOT
67913: PUSH
67914: LD_EXP 94
67918: PUSH
67919: LD_VAR 0 2
67923: ARRAY
67924: NOT
67925: OR
67926: IFFALSE 67930
// continue ;
67928: GO 67700
// for j in lab do
67930: LD_ADDR_VAR 0 3
67934: PUSH
67935: LD_VAR 0 6
67939: PUSH
67940: FOR_IN
67941: IFFALSE 68106
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
67943: LD_VAR 0 3
67947: PPUSH
67948: CALL_OW 266
67952: PUSH
67953: LD_INT 6
67955: PUSH
67956: LD_INT 7
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: IN
67963: PUSH
67964: LD_VAR 0 3
67968: PPUSH
67969: CALL_OW 461
67973: PUSH
67974: LD_INT 1
67976: NONEQUAL
67977: AND
67978: IFFALSE 68104
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
67980: LD_VAR 0 3
67984: PPUSH
67985: LD_EXP 94
67989: PUSH
67990: LD_VAR 0 2
67994: ARRAY
67995: PUSH
67996: LD_INT 1
67998: ARRAY
67999: PPUSH
68000: CALL 26721 0 2
68004: IFFALSE 68104
// begin ComCancel ( j ) ;
68006: LD_VAR 0 3
68010: PPUSH
68011: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68015: LD_VAR 0 3
68019: PPUSH
68020: LD_EXP 94
68024: PUSH
68025: LD_VAR 0 2
68029: ARRAY
68030: PUSH
68031: LD_INT 1
68033: ARRAY
68034: PPUSH
68035: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68039: LD_VAR 0 3
68043: PUSH
68044: LD_EXP 67
68048: PUSH
68049: LD_VAR 0 2
68053: ARRAY
68054: IN
68055: NOT
68056: IFFALSE 68102
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68058: LD_ADDR_EXP 67
68062: PUSH
68063: LD_EXP 67
68067: PPUSH
68068: LD_VAR 0 2
68072: PUSH
68073: LD_EXP 67
68077: PUSH
68078: LD_VAR 0 2
68082: ARRAY
68083: PUSH
68084: LD_INT 1
68086: PLUS
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PPUSH
68092: LD_VAR 0 3
68096: PPUSH
68097: CALL 20003 0 3
68101: ST_TO_ADDR
// break ;
68102: GO 68106
// end ; end ; end ;
68104: GO 67940
68106: POP
68107: POP
// end ;
68108: GO 67700
68110: POP
68111: POP
// end ;
68112: LD_VAR 0 1
68116: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68117: LD_INT 0
68119: PPUSH
68120: PPUSH
68121: PPUSH
68122: PPUSH
68123: PPUSH
68124: PPUSH
68125: PPUSH
68126: PPUSH
68127: PPUSH
// if not mc_bases then
68128: LD_EXP 60
68132: NOT
68133: IFFALSE 68137
// exit ;
68135: GO 68542
// for i = 1 to mc_bases do
68137: LD_ADDR_VAR 0 2
68141: PUSH
68142: DOUBLE
68143: LD_INT 1
68145: DEC
68146: ST_TO_ADDR
68147: LD_EXP 60
68151: PUSH
68152: FOR_TO
68153: IFFALSE 68540
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68155: LD_EXP 68
68159: PUSH
68160: LD_VAR 0 2
68164: ARRAY
68165: NOT
68166: PUSH
68167: LD_EXP 60
68171: PUSH
68172: LD_VAR 0 2
68176: ARRAY
68177: PPUSH
68178: LD_INT 30
68180: PUSH
68181: LD_INT 3
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PPUSH
68188: CALL_OW 72
68192: NOT
68193: OR
68194: IFFALSE 68198
// continue ;
68196: GO 68152
// busy := false ;
68198: LD_ADDR_VAR 0 8
68202: PUSH
68203: LD_INT 0
68205: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68206: LD_ADDR_VAR 0 4
68210: PUSH
68211: LD_EXP 60
68215: PUSH
68216: LD_VAR 0 2
68220: ARRAY
68221: PPUSH
68222: LD_INT 30
68224: PUSH
68225: LD_INT 3
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PPUSH
68232: CALL_OW 72
68236: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68237: LD_ADDR_VAR 0 6
68241: PUSH
68242: LD_EXP 68
68246: PUSH
68247: LD_VAR 0 2
68251: ARRAY
68252: PPUSH
68253: LD_INT 2
68255: PUSH
68256: LD_INT 30
68258: PUSH
68259: LD_INT 32
68261: PUSH
68262: EMPTY
68263: LIST
68264: LIST
68265: PUSH
68266: LD_INT 30
68268: PUSH
68269: LD_INT 33
68271: PUSH
68272: EMPTY
68273: LIST
68274: LIST
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: LIST
68280: PPUSH
68281: CALL_OW 72
68285: ST_TO_ADDR
// if not t then
68286: LD_VAR 0 6
68290: NOT
68291: IFFALSE 68295
// continue ;
68293: GO 68152
// for j in tmp do
68295: LD_ADDR_VAR 0 3
68299: PUSH
68300: LD_VAR 0 4
68304: PUSH
68305: FOR_IN
68306: IFFALSE 68336
// if not BuildingStatus ( j ) = bs_idle then
68308: LD_VAR 0 3
68312: PPUSH
68313: CALL_OW 461
68317: PUSH
68318: LD_INT 2
68320: EQUAL
68321: NOT
68322: IFFALSE 68334
// begin busy := true ;
68324: LD_ADDR_VAR 0 8
68328: PUSH
68329: LD_INT 1
68331: ST_TO_ADDR
// break ;
68332: GO 68336
// end ;
68334: GO 68305
68336: POP
68337: POP
// if busy then
68338: LD_VAR 0 8
68342: IFFALSE 68346
// continue ;
68344: GO 68152
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68346: LD_ADDR_VAR 0 7
68350: PUSH
68351: LD_VAR 0 6
68355: PPUSH
68356: LD_INT 35
68358: PUSH
68359: LD_INT 0
68361: PUSH
68362: EMPTY
68363: LIST
68364: LIST
68365: PPUSH
68366: CALL_OW 72
68370: ST_TO_ADDR
// if tw then
68371: LD_VAR 0 7
68375: IFFALSE 68452
// begin tw := tw [ 1 ] ;
68377: LD_ADDR_VAR 0 7
68381: PUSH
68382: LD_VAR 0 7
68386: PUSH
68387: LD_INT 1
68389: ARRAY
68390: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68391: LD_ADDR_VAR 0 9
68395: PUSH
68396: LD_VAR 0 7
68400: PPUSH
68401: LD_EXP 85
68405: PUSH
68406: LD_VAR 0 2
68410: ARRAY
68411: PPUSH
68412: CALL 25013 0 2
68416: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
68417: LD_EXP 99
68421: PUSH
68422: LD_VAR 0 2
68426: ARRAY
68427: IFFALSE 68450
// if not weapon in mc_allowed_tower_weapons [ i ] then
68429: LD_VAR 0 9
68433: PUSH
68434: LD_EXP 99
68438: PUSH
68439: LD_VAR 0 2
68443: ARRAY
68444: IN
68445: NOT
68446: IFFALSE 68450
// continue ;
68448: GO 68152
// end else
68450: GO 68515
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
68452: LD_ADDR_VAR 0 5
68456: PUSH
68457: LD_EXP 68
68461: PUSH
68462: LD_VAR 0 2
68466: ARRAY
68467: PPUSH
68468: LD_VAR 0 4
68472: PPUSH
68473: CALL 51813 0 2
68477: ST_TO_ADDR
// if not tmp2 then
68478: LD_VAR 0 5
68482: NOT
68483: IFFALSE 68487
// continue ;
68485: GO 68152
// tw := tmp2 [ 1 ] ;
68487: LD_ADDR_VAR 0 7
68491: PUSH
68492: LD_VAR 0 5
68496: PUSH
68497: LD_INT 1
68499: ARRAY
68500: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
68501: LD_ADDR_VAR 0 9
68505: PUSH
68506: LD_VAR 0 5
68510: PUSH
68511: LD_INT 2
68513: ARRAY
68514: ST_TO_ADDR
// end ; if not weapon then
68515: LD_VAR 0 9
68519: NOT
68520: IFFALSE 68524
// continue ;
68522: GO 68152
// ComPlaceWeapon ( tw , weapon ) ;
68524: LD_VAR 0 7
68528: PPUSH
68529: LD_VAR 0 9
68533: PPUSH
68534: CALL_OW 148
// end ;
68538: GO 68152
68540: POP
68541: POP
// end ;
68542: LD_VAR 0 1
68546: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
68547: LD_INT 0
68549: PPUSH
68550: PPUSH
68551: PPUSH
68552: PPUSH
68553: PPUSH
68554: PPUSH
68555: PPUSH
// if not mc_bases then
68556: LD_EXP 60
68560: NOT
68561: IFFALSE 68565
// exit ;
68563: GO 69333
// for i = 1 to mc_bases do
68565: LD_ADDR_VAR 0 2
68569: PUSH
68570: DOUBLE
68571: LD_INT 1
68573: DEC
68574: ST_TO_ADDR
68575: LD_EXP 60
68579: PUSH
68580: FOR_TO
68581: IFFALSE 69331
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
68583: LD_EXP 73
68587: PUSH
68588: LD_VAR 0 2
68592: ARRAY
68593: NOT
68594: PUSH
68595: LD_EXP 73
68599: PUSH
68600: LD_VAR 0 2
68604: ARRAY
68605: PUSH
68606: LD_EXP 74
68610: PUSH
68611: LD_VAR 0 2
68615: ARRAY
68616: EQUAL
68617: OR
68618: PUSH
68619: LD_EXP 83
68623: PUSH
68624: LD_VAR 0 2
68628: ARRAY
68629: OR
68630: IFFALSE 68634
// continue ;
68632: GO 68580
// if mc_miners [ i ] then
68634: LD_EXP 74
68638: PUSH
68639: LD_VAR 0 2
68643: ARRAY
68644: IFFALSE 69018
// begin for j = mc_miners [ i ] downto 1 do
68646: LD_ADDR_VAR 0 3
68650: PUSH
68651: DOUBLE
68652: LD_EXP 74
68656: PUSH
68657: LD_VAR 0 2
68661: ARRAY
68662: INC
68663: ST_TO_ADDR
68664: LD_INT 1
68666: PUSH
68667: FOR_DOWNTO
68668: IFFALSE 69016
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
68670: LD_EXP 74
68674: PUSH
68675: LD_VAR 0 2
68679: ARRAY
68680: PUSH
68681: LD_VAR 0 3
68685: ARRAY
68686: PPUSH
68687: CALL_OW 301
68691: PUSH
68692: LD_EXP 74
68696: PUSH
68697: LD_VAR 0 2
68701: ARRAY
68702: PUSH
68703: LD_VAR 0 3
68707: ARRAY
68708: PPUSH
68709: CALL_OW 257
68713: PUSH
68714: LD_INT 1
68716: NONEQUAL
68717: OR
68718: IFFALSE 68781
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
68720: LD_ADDR_VAR 0 5
68724: PUSH
68725: LD_EXP 74
68729: PUSH
68730: LD_VAR 0 2
68734: ARRAY
68735: PUSH
68736: LD_EXP 74
68740: PUSH
68741: LD_VAR 0 2
68745: ARRAY
68746: PUSH
68747: LD_VAR 0 3
68751: ARRAY
68752: DIFF
68753: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
68754: LD_ADDR_EXP 74
68758: PUSH
68759: LD_EXP 74
68763: PPUSH
68764: LD_VAR 0 2
68768: PPUSH
68769: LD_VAR 0 5
68773: PPUSH
68774: CALL_OW 1
68778: ST_TO_ADDR
// continue ;
68779: GO 68667
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
68781: LD_EXP 74
68785: PUSH
68786: LD_VAR 0 2
68790: ARRAY
68791: PUSH
68792: LD_VAR 0 3
68796: ARRAY
68797: PPUSH
68798: CALL_OW 257
68802: PUSH
68803: LD_INT 1
68805: EQUAL
68806: PUSH
68807: LD_EXP 74
68811: PUSH
68812: LD_VAR 0 2
68816: ARRAY
68817: PUSH
68818: LD_VAR 0 3
68822: ARRAY
68823: PPUSH
68824: CALL_OW 459
68828: NOT
68829: AND
68830: PUSH
68831: LD_EXP 74
68835: PUSH
68836: LD_VAR 0 2
68840: ARRAY
68841: PUSH
68842: LD_VAR 0 3
68846: ARRAY
68847: PPUSH
68848: CALL_OW 314
68852: NOT
68853: AND
68854: IFFALSE 69014
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
68856: LD_EXP 74
68860: PUSH
68861: LD_VAR 0 2
68865: ARRAY
68866: PUSH
68867: LD_VAR 0 3
68871: ARRAY
68872: PPUSH
68873: CALL_OW 310
68877: IFFALSE 68900
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
68879: LD_EXP 74
68883: PUSH
68884: LD_VAR 0 2
68888: ARRAY
68889: PUSH
68890: LD_VAR 0 3
68894: ARRAY
68895: PPUSH
68896: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
68900: LD_EXP 74
68904: PUSH
68905: LD_VAR 0 2
68909: ARRAY
68910: PUSH
68911: LD_VAR 0 3
68915: ARRAY
68916: PPUSH
68917: CALL_OW 314
68921: NOT
68922: IFFALSE 69014
// begin r := rand ( 1 , mc_mines [ i ] ) ;
68924: LD_ADDR_VAR 0 7
68928: PUSH
68929: LD_INT 1
68931: PPUSH
68932: LD_EXP 73
68936: PUSH
68937: LD_VAR 0 2
68941: ARRAY
68942: PPUSH
68943: CALL_OW 12
68947: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
68948: LD_EXP 74
68952: PUSH
68953: LD_VAR 0 2
68957: ARRAY
68958: PUSH
68959: LD_VAR 0 3
68963: ARRAY
68964: PPUSH
68965: LD_EXP 73
68969: PUSH
68970: LD_VAR 0 2
68974: ARRAY
68975: PUSH
68976: LD_VAR 0 7
68980: ARRAY
68981: PUSH
68982: LD_INT 1
68984: ARRAY
68985: PPUSH
68986: LD_EXP 73
68990: PUSH
68991: LD_VAR 0 2
68995: ARRAY
68996: PUSH
68997: LD_VAR 0 7
69001: ARRAY
69002: PUSH
69003: LD_INT 2
69005: ARRAY
69006: PPUSH
69007: LD_INT 0
69009: PPUSH
69010: CALL_OW 193
// end ; end ; end ;
69014: GO 68667
69016: POP
69017: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69018: LD_ADDR_VAR 0 5
69022: PUSH
69023: LD_EXP 60
69027: PUSH
69028: LD_VAR 0 2
69032: ARRAY
69033: PPUSH
69034: LD_INT 2
69036: PUSH
69037: LD_INT 30
69039: PUSH
69040: LD_INT 4
69042: PUSH
69043: EMPTY
69044: LIST
69045: LIST
69046: PUSH
69047: LD_INT 30
69049: PUSH
69050: LD_INT 5
69052: PUSH
69053: EMPTY
69054: LIST
69055: LIST
69056: PUSH
69057: LD_INT 30
69059: PUSH
69060: LD_INT 32
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: PPUSH
69073: CALL_OW 72
69077: ST_TO_ADDR
// if not tmp then
69078: LD_VAR 0 5
69082: NOT
69083: IFFALSE 69087
// continue ;
69085: GO 68580
// list := [ ] ;
69087: LD_ADDR_VAR 0 6
69091: PUSH
69092: EMPTY
69093: ST_TO_ADDR
// for j in tmp do
69094: LD_ADDR_VAR 0 3
69098: PUSH
69099: LD_VAR 0 5
69103: PUSH
69104: FOR_IN
69105: IFFALSE 69174
// begin for k in UnitsInside ( j ) do
69107: LD_ADDR_VAR 0 4
69111: PUSH
69112: LD_VAR 0 3
69116: PPUSH
69117: CALL_OW 313
69121: PUSH
69122: FOR_IN
69123: IFFALSE 69170
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69125: LD_VAR 0 4
69129: PPUSH
69130: CALL_OW 257
69134: PUSH
69135: LD_INT 1
69137: EQUAL
69138: PUSH
69139: LD_VAR 0 4
69143: PPUSH
69144: CALL_OW 459
69148: NOT
69149: AND
69150: IFFALSE 69168
// list := list ^ k ;
69152: LD_ADDR_VAR 0 6
69156: PUSH
69157: LD_VAR 0 6
69161: PUSH
69162: LD_VAR 0 4
69166: ADD
69167: ST_TO_ADDR
69168: GO 69122
69170: POP
69171: POP
// end ;
69172: GO 69104
69174: POP
69175: POP
// list := list diff mc_miners [ i ] ;
69176: LD_ADDR_VAR 0 6
69180: PUSH
69181: LD_VAR 0 6
69185: PUSH
69186: LD_EXP 74
69190: PUSH
69191: LD_VAR 0 2
69195: ARRAY
69196: DIFF
69197: ST_TO_ADDR
// if not list then
69198: LD_VAR 0 6
69202: NOT
69203: IFFALSE 69207
// continue ;
69205: GO 68580
// k := mc_mines [ i ] - mc_miners [ i ] ;
69207: LD_ADDR_VAR 0 4
69211: PUSH
69212: LD_EXP 73
69216: PUSH
69217: LD_VAR 0 2
69221: ARRAY
69222: PUSH
69223: LD_EXP 74
69227: PUSH
69228: LD_VAR 0 2
69232: ARRAY
69233: MINUS
69234: ST_TO_ADDR
// if k > list then
69235: LD_VAR 0 4
69239: PUSH
69240: LD_VAR 0 6
69244: GREATER
69245: IFFALSE 69257
// k := list ;
69247: LD_ADDR_VAR 0 4
69251: PUSH
69252: LD_VAR 0 6
69256: ST_TO_ADDR
// for j = 1 to k do
69257: LD_ADDR_VAR 0 3
69261: PUSH
69262: DOUBLE
69263: LD_INT 1
69265: DEC
69266: ST_TO_ADDR
69267: LD_VAR 0 4
69271: PUSH
69272: FOR_TO
69273: IFFALSE 69327
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
69275: LD_ADDR_EXP 74
69279: PUSH
69280: LD_EXP 74
69284: PPUSH
69285: LD_VAR 0 2
69289: PUSH
69290: LD_EXP 74
69294: PUSH
69295: LD_VAR 0 2
69299: ARRAY
69300: PUSH
69301: LD_INT 1
69303: PLUS
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PPUSH
69309: LD_VAR 0 6
69313: PUSH
69314: LD_VAR 0 3
69318: ARRAY
69319: PPUSH
69320: CALL 20003 0 3
69324: ST_TO_ADDR
69325: GO 69272
69327: POP
69328: POP
// end ;
69329: GO 68580
69331: POP
69332: POP
// end ;
69333: LD_VAR 0 1
69337: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
69338: LD_INT 0
69340: PPUSH
69341: PPUSH
69342: PPUSH
69343: PPUSH
69344: PPUSH
69345: PPUSH
69346: PPUSH
69347: PPUSH
69348: PPUSH
69349: PPUSH
69350: PPUSH
// if not mc_bases then
69351: LD_EXP 60
69355: NOT
69356: IFFALSE 69360
// exit ;
69358: GO 71183
// for i = 1 to mc_bases do
69360: LD_ADDR_VAR 0 2
69364: PUSH
69365: DOUBLE
69366: LD_INT 1
69368: DEC
69369: ST_TO_ADDR
69370: LD_EXP 60
69374: PUSH
69375: FOR_TO
69376: IFFALSE 71181
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
69378: LD_EXP 60
69382: PUSH
69383: LD_VAR 0 2
69387: ARRAY
69388: NOT
69389: PUSH
69390: LD_EXP 67
69394: PUSH
69395: LD_VAR 0 2
69399: ARRAY
69400: OR
69401: IFFALSE 69405
// continue ;
69403: GO 69375
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
69405: LD_EXP 76
69409: PUSH
69410: LD_VAR 0 2
69414: ARRAY
69415: NOT
69416: PUSH
69417: LD_EXP 77
69421: PUSH
69422: LD_VAR 0 2
69426: ARRAY
69427: AND
69428: IFFALSE 69466
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
69430: LD_ADDR_EXP 77
69434: PUSH
69435: LD_EXP 77
69439: PPUSH
69440: LD_VAR 0 2
69444: PPUSH
69445: EMPTY
69446: PPUSH
69447: CALL_OW 1
69451: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
69452: LD_VAR 0 2
69456: PPUSH
69457: LD_INT 107
69459: PPUSH
69460: CALL 60234 0 2
// continue ;
69464: GO 69375
// end ; target := [ ] ;
69466: LD_ADDR_VAR 0 7
69470: PUSH
69471: EMPTY
69472: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69473: LD_ADDR_VAR 0 6
69477: PUSH
69478: LD_EXP 60
69482: PUSH
69483: LD_VAR 0 2
69487: ARRAY
69488: PUSH
69489: LD_INT 1
69491: ARRAY
69492: PPUSH
69493: CALL_OW 255
69497: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69498: LD_ADDR_VAR 0 9
69502: PUSH
69503: LD_EXP 60
69507: PUSH
69508: LD_VAR 0 2
69512: ARRAY
69513: PPUSH
69514: LD_INT 2
69516: PUSH
69517: LD_INT 30
69519: PUSH
69520: LD_INT 0
69522: PUSH
69523: EMPTY
69524: LIST
69525: LIST
69526: PUSH
69527: LD_INT 30
69529: PUSH
69530: LD_INT 1
69532: PUSH
69533: EMPTY
69534: LIST
69535: LIST
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: LIST
69541: PPUSH
69542: CALL_OW 72
69546: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
69547: LD_ADDR_VAR 0 3
69551: PUSH
69552: DOUBLE
69553: LD_EXP 76
69557: PUSH
69558: LD_VAR 0 2
69562: ARRAY
69563: INC
69564: ST_TO_ADDR
69565: LD_INT 1
69567: PUSH
69568: FOR_DOWNTO
69569: IFFALSE 69814
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
69571: LD_EXP 76
69575: PUSH
69576: LD_VAR 0 2
69580: ARRAY
69581: PUSH
69582: LD_VAR 0 3
69586: ARRAY
69587: PUSH
69588: LD_INT 2
69590: ARRAY
69591: PPUSH
69592: LD_EXP 76
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: LD_VAR 0 3
69607: ARRAY
69608: PUSH
69609: LD_INT 3
69611: ARRAY
69612: PPUSH
69613: CALL_OW 488
69617: PUSH
69618: LD_EXP 76
69622: PUSH
69623: LD_VAR 0 2
69627: ARRAY
69628: PUSH
69629: LD_VAR 0 3
69633: ARRAY
69634: PUSH
69635: LD_INT 2
69637: ARRAY
69638: PPUSH
69639: LD_EXP 76
69643: PUSH
69644: LD_VAR 0 2
69648: ARRAY
69649: PUSH
69650: LD_VAR 0 3
69654: ARRAY
69655: PUSH
69656: LD_INT 3
69658: ARRAY
69659: PPUSH
69660: CALL_OW 284
69664: PUSH
69665: LD_INT 0
69667: EQUAL
69668: AND
69669: IFFALSE 69724
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
69671: LD_ADDR_VAR 0 5
69675: PUSH
69676: LD_EXP 76
69680: PUSH
69681: LD_VAR 0 2
69685: ARRAY
69686: PPUSH
69687: LD_VAR 0 3
69691: PPUSH
69692: CALL_OW 3
69696: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
69697: LD_ADDR_EXP 76
69701: PUSH
69702: LD_EXP 76
69706: PPUSH
69707: LD_VAR 0 2
69711: PPUSH
69712: LD_VAR 0 5
69716: PPUSH
69717: CALL_OW 1
69721: ST_TO_ADDR
// continue ;
69722: GO 69568
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
69724: LD_VAR 0 6
69728: PPUSH
69729: LD_EXP 76
69733: PUSH
69734: LD_VAR 0 2
69738: ARRAY
69739: PUSH
69740: LD_VAR 0 3
69744: ARRAY
69745: PUSH
69746: LD_INT 2
69748: ARRAY
69749: PPUSH
69750: LD_EXP 76
69754: PUSH
69755: LD_VAR 0 2
69759: ARRAY
69760: PUSH
69761: LD_VAR 0 3
69765: ARRAY
69766: PUSH
69767: LD_INT 3
69769: ARRAY
69770: PPUSH
69771: LD_INT 30
69773: PPUSH
69774: CALL 20899 0 4
69778: PUSH
69779: LD_INT 4
69781: ARRAY
69782: PUSH
69783: LD_INT 0
69785: EQUAL
69786: IFFALSE 69812
// begin target := mc_crates [ i ] [ j ] ;
69788: LD_ADDR_VAR 0 7
69792: PUSH
69793: LD_EXP 76
69797: PUSH
69798: LD_VAR 0 2
69802: ARRAY
69803: PUSH
69804: LD_VAR 0 3
69808: ARRAY
69809: ST_TO_ADDR
// break ;
69810: GO 69814
// end ; end ;
69812: GO 69568
69814: POP
69815: POP
// if not target then
69816: LD_VAR 0 7
69820: NOT
69821: IFFALSE 69825
// continue ;
69823: GO 69375
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
69825: LD_ADDR_VAR 0 8
69829: PUSH
69830: LD_EXP 79
69834: PUSH
69835: LD_VAR 0 2
69839: ARRAY
69840: PPUSH
69841: LD_INT 2
69843: PUSH
69844: LD_INT 3
69846: PUSH
69847: LD_INT 58
69849: PUSH
69850: EMPTY
69851: LIST
69852: PUSH
69853: EMPTY
69854: LIST
69855: LIST
69856: PUSH
69857: LD_INT 61
69859: PUSH
69860: EMPTY
69861: LIST
69862: PUSH
69863: LD_INT 33
69865: PUSH
69866: LD_INT 5
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 33
69875: PUSH
69876: LD_INT 3
69878: PUSH
69879: EMPTY
69880: LIST
69881: LIST
69882: PUSH
69883: EMPTY
69884: LIST
69885: LIST
69886: LIST
69887: LIST
69888: LIST
69889: PUSH
69890: LD_INT 2
69892: PUSH
69893: LD_INT 34
69895: PUSH
69896: LD_INT 32
69898: PUSH
69899: EMPTY
69900: LIST
69901: LIST
69902: PUSH
69903: LD_INT 34
69905: PUSH
69906: LD_INT 51
69908: PUSH
69909: EMPTY
69910: LIST
69911: LIST
69912: PUSH
69913: LD_INT 34
69915: PUSH
69916: LD_INT 12
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: EMPTY
69924: LIST
69925: LIST
69926: LIST
69927: LIST
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PPUSH
69933: CALL_OW 72
69937: ST_TO_ADDR
// if not cargo then
69938: LD_VAR 0 8
69942: NOT
69943: IFFALSE 70649
// begin if mc_crates_collector [ i ] < 5 then
69945: LD_EXP 77
69949: PUSH
69950: LD_VAR 0 2
69954: ARRAY
69955: PUSH
69956: LD_INT 5
69958: LESS
69959: IFFALSE 70325
// begin if mc_ape [ i ] then
69961: LD_EXP 89
69965: PUSH
69966: LD_VAR 0 2
69970: ARRAY
69971: IFFALSE 70018
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
69973: LD_ADDR_VAR 0 5
69977: PUSH
69978: LD_EXP 89
69982: PUSH
69983: LD_VAR 0 2
69987: ARRAY
69988: PPUSH
69989: LD_INT 25
69991: PUSH
69992: LD_INT 16
69994: PUSH
69995: EMPTY
69996: LIST
69997: LIST
69998: PUSH
69999: LD_INT 24
70001: PUSH
70002: LD_INT 750
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PUSH
70009: EMPTY
70010: LIST
70011: LIST
70012: PPUSH
70013: CALL_OW 72
70017: ST_TO_ADDR
// if not tmp then
70018: LD_VAR 0 5
70022: NOT
70023: IFFALSE 70070
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70025: LD_ADDR_VAR 0 5
70029: PUSH
70030: LD_EXP 60
70034: PUSH
70035: LD_VAR 0 2
70039: ARRAY
70040: PPUSH
70041: LD_INT 25
70043: PUSH
70044: LD_INT 2
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 24
70053: PUSH
70054: LD_INT 750
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: PPUSH
70065: CALL_OW 72
70069: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70070: LD_EXP 89
70074: PUSH
70075: LD_VAR 0 2
70079: ARRAY
70080: PUSH
70081: LD_EXP 60
70085: PUSH
70086: LD_VAR 0 2
70090: ARRAY
70091: PPUSH
70092: LD_INT 25
70094: PUSH
70095: LD_INT 2
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 24
70104: PUSH
70105: LD_INT 750
70107: PUSH
70108: EMPTY
70109: LIST
70110: LIST
70111: PUSH
70112: EMPTY
70113: LIST
70114: LIST
70115: PPUSH
70116: CALL_OW 72
70120: AND
70121: PUSH
70122: LD_VAR 0 5
70126: PUSH
70127: LD_INT 5
70129: LESS
70130: AND
70131: IFFALSE 70213
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70133: LD_ADDR_VAR 0 3
70137: PUSH
70138: LD_EXP 60
70142: PUSH
70143: LD_VAR 0 2
70147: ARRAY
70148: PPUSH
70149: LD_INT 25
70151: PUSH
70152: LD_INT 2
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 24
70161: PUSH
70162: LD_INT 750
70164: PUSH
70165: EMPTY
70166: LIST
70167: LIST
70168: PUSH
70169: EMPTY
70170: LIST
70171: LIST
70172: PPUSH
70173: CALL_OW 72
70177: PUSH
70178: FOR_IN
70179: IFFALSE 70211
// begin tmp := tmp union j ;
70181: LD_ADDR_VAR 0 5
70185: PUSH
70186: LD_VAR 0 5
70190: PUSH
70191: LD_VAR 0 3
70195: UNION
70196: ST_TO_ADDR
// if tmp >= 5 then
70197: LD_VAR 0 5
70201: PUSH
70202: LD_INT 5
70204: GREATEREQUAL
70205: IFFALSE 70209
// break ;
70207: GO 70211
// end ;
70209: GO 70178
70211: POP
70212: POP
// end ; if not tmp then
70213: LD_VAR 0 5
70217: NOT
70218: IFFALSE 70222
// continue ;
70220: GO 69375
// for j in tmp do
70222: LD_ADDR_VAR 0 3
70226: PUSH
70227: LD_VAR 0 5
70231: PUSH
70232: FOR_IN
70233: IFFALSE 70323
// if not GetTag ( j ) then
70235: LD_VAR 0 3
70239: PPUSH
70240: CALL_OW 110
70244: NOT
70245: IFFALSE 70321
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
70247: LD_ADDR_EXP 77
70251: PUSH
70252: LD_EXP 77
70256: PPUSH
70257: LD_VAR 0 2
70261: PUSH
70262: LD_EXP 77
70266: PUSH
70267: LD_VAR 0 2
70271: ARRAY
70272: PUSH
70273: LD_INT 1
70275: PLUS
70276: PUSH
70277: EMPTY
70278: LIST
70279: LIST
70280: PPUSH
70281: LD_VAR 0 3
70285: PPUSH
70286: CALL 20003 0 3
70290: ST_TO_ADDR
// SetTag ( j , 107 ) ;
70291: LD_VAR 0 3
70295: PPUSH
70296: LD_INT 107
70298: PPUSH
70299: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
70303: LD_EXP 77
70307: PUSH
70308: LD_VAR 0 2
70312: ARRAY
70313: PUSH
70314: LD_INT 5
70316: GREATEREQUAL
70317: IFFALSE 70321
// break ;
70319: GO 70323
// end ;
70321: GO 70232
70323: POP
70324: POP
// end ; if mc_crates_collector [ i ] and target then
70325: LD_EXP 77
70329: PUSH
70330: LD_VAR 0 2
70334: ARRAY
70335: PUSH
70336: LD_VAR 0 7
70340: AND
70341: IFFALSE 70647
// begin if mc_crates_collector [ i ] < target [ 1 ] then
70343: LD_EXP 77
70347: PUSH
70348: LD_VAR 0 2
70352: ARRAY
70353: PUSH
70354: LD_VAR 0 7
70358: PUSH
70359: LD_INT 1
70361: ARRAY
70362: LESS
70363: IFFALSE 70383
// tmp := mc_crates_collector [ i ] else
70365: LD_ADDR_VAR 0 5
70369: PUSH
70370: LD_EXP 77
70374: PUSH
70375: LD_VAR 0 2
70379: ARRAY
70380: ST_TO_ADDR
70381: GO 70397
// tmp := target [ 1 ] ;
70383: LD_ADDR_VAR 0 5
70387: PUSH
70388: LD_VAR 0 7
70392: PUSH
70393: LD_INT 1
70395: ARRAY
70396: ST_TO_ADDR
// k := 0 ;
70397: LD_ADDR_VAR 0 4
70401: PUSH
70402: LD_INT 0
70404: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
70405: LD_ADDR_VAR 0 3
70409: PUSH
70410: LD_EXP 77
70414: PUSH
70415: LD_VAR 0 2
70419: ARRAY
70420: PUSH
70421: FOR_IN
70422: IFFALSE 70645
// begin k := k + 1 ;
70424: LD_ADDR_VAR 0 4
70428: PUSH
70429: LD_VAR 0 4
70433: PUSH
70434: LD_INT 1
70436: PLUS
70437: ST_TO_ADDR
// if k > tmp then
70438: LD_VAR 0 4
70442: PUSH
70443: LD_VAR 0 5
70447: GREATER
70448: IFFALSE 70452
// break ;
70450: GO 70645
// if not GetClass ( j ) in [ 2 , 16 ] then
70452: LD_VAR 0 3
70456: PPUSH
70457: CALL_OW 257
70461: PUSH
70462: LD_INT 2
70464: PUSH
70465: LD_INT 16
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: IN
70472: NOT
70473: IFFALSE 70526
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
70475: LD_ADDR_EXP 77
70479: PUSH
70480: LD_EXP 77
70484: PPUSH
70485: LD_VAR 0 2
70489: PPUSH
70490: LD_EXP 77
70494: PUSH
70495: LD_VAR 0 2
70499: ARRAY
70500: PUSH
70501: LD_VAR 0 3
70505: DIFF
70506: PPUSH
70507: CALL_OW 1
70511: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70512: LD_VAR 0 3
70516: PPUSH
70517: LD_INT 0
70519: PPUSH
70520: CALL_OW 109
// continue ;
70524: GO 70421
// end ; if IsInUnit ( j ) then
70526: LD_VAR 0 3
70530: PPUSH
70531: CALL_OW 310
70535: IFFALSE 70546
// ComExitBuilding ( j ) ;
70537: LD_VAR 0 3
70541: PPUSH
70542: CALL_OW 122
// wait ( 3 ) ;
70546: LD_INT 3
70548: PPUSH
70549: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
70553: LD_VAR 0 3
70557: PPUSH
70558: CALL_OW 314
70562: PUSH
70563: LD_VAR 0 6
70567: PPUSH
70568: LD_VAR 0 7
70572: PUSH
70573: LD_INT 2
70575: ARRAY
70576: PPUSH
70577: LD_VAR 0 7
70581: PUSH
70582: LD_INT 3
70584: ARRAY
70585: PPUSH
70586: LD_INT 30
70588: PPUSH
70589: CALL 20899 0 4
70593: PUSH
70594: LD_INT 4
70596: ARRAY
70597: AND
70598: IFFALSE 70616
// ComStandNearbyBuilding ( j , depot ) else
70600: LD_VAR 0 3
70604: PPUSH
70605: LD_VAR 0 9
70609: PPUSH
70610: CALL 16428 0 2
70614: GO 70643
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
70616: LD_VAR 0 3
70620: PPUSH
70621: LD_VAR 0 7
70625: PUSH
70626: LD_INT 2
70628: ARRAY
70629: PPUSH
70630: LD_VAR 0 7
70634: PUSH
70635: LD_INT 3
70637: ARRAY
70638: PPUSH
70639: CALL_OW 117
// end ;
70643: GO 70421
70645: POP
70646: POP
// end ; end else
70647: GO 71179
// begin for j in cargo do
70649: LD_ADDR_VAR 0 3
70653: PUSH
70654: LD_VAR 0 8
70658: PUSH
70659: FOR_IN
70660: IFFALSE 71177
// begin if GetTag ( j ) <> 0 then
70662: LD_VAR 0 3
70666: PPUSH
70667: CALL_OW 110
70671: PUSH
70672: LD_INT 0
70674: NONEQUAL
70675: IFFALSE 70679
// continue ;
70677: GO 70659
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
70679: LD_VAR 0 3
70683: PPUSH
70684: CALL_OW 256
70688: PUSH
70689: LD_INT 1000
70691: LESS
70692: PUSH
70693: LD_VAR 0 3
70697: PPUSH
70698: LD_EXP 84
70702: PUSH
70703: LD_VAR 0 2
70707: ARRAY
70708: PPUSH
70709: CALL_OW 308
70713: NOT
70714: AND
70715: IFFALSE 70737
// ComMoveToArea ( j , mc_parking [ i ] ) ;
70717: LD_VAR 0 3
70721: PPUSH
70722: LD_EXP 84
70726: PUSH
70727: LD_VAR 0 2
70731: ARRAY
70732: PPUSH
70733: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
70737: LD_VAR 0 3
70741: PPUSH
70742: CALL_OW 256
70746: PUSH
70747: LD_INT 1000
70749: LESS
70750: PUSH
70751: LD_VAR 0 3
70755: PPUSH
70756: LD_EXP 84
70760: PUSH
70761: LD_VAR 0 2
70765: ARRAY
70766: PPUSH
70767: CALL_OW 308
70771: AND
70772: IFFALSE 70776
// continue ;
70774: GO 70659
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
70776: LD_VAR 0 3
70780: PPUSH
70781: CALL_OW 262
70785: PUSH
70786: LD_INT 2
70788: EQUAL
70789: PUSH
70790: LD_VAR 0 3
70794: PPUSH
70795: CALL_OW 261
70799: PUSH
70800: LD_INT 15
70802: LESS
70803: AND
70804: IFFALSE 70808
// continue ;
70806: GO 70659
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
70808: LD_VAR 0 3
70812: PPUSH
70813: CALL_OW 262
70817: PUSH
70818: LD_INT 1
70820: EQUAL
70821: PUSH
70822: LD_VAR 0 3
70826: PPUSH
70827: CALL_OW 261
70831: PUSH
70832: LD_INT 10
70834: LESS
70835: AND
70836: IFFALSE 71116
// begin if not depot then
70838: LD_VAR 0 9
70842: NOT
70843: IFFALSE 70847
// continue ;
70845: GO 70659
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
70847: LD_VAR 0 3
70851: PPUSH
70852: LD_VAR 0 9
70856: PPUSH
70857: LD_VAR 0 3
70861: PPUSH
70862: CALL_OW 74
70866: PPUSH
70867: CALL_OW 296
70871: PUSH
70872: LD_INT 6
70874: LESS
70875: IFFALSE 70891
// SetFuel ( j , 100 ) else
70877: LD_VAR 0 3
70881: PPUSH
70882: LD_INT 100
70884: PPUSH
70885: CALL_OW 240
70889: GO 71116
// if GetFuel ( j ) = 0 then
70891: LD_VAR 0 3
70895: PPUSH
70896: CALL_OW 261
70900: PUSH
70901: LD_INT 0
70903: EQUAL
70904: IFFALSE 71116
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
70906: LD_ADDR_EXP 79
70910: PUSH
70911: LD_EXP 79
70915: PPUSH
70916: LD_VAR 0 2
70920: PPUSH
70921: LD_EXP 79
70925: PUSH
70926: LD_VAR 0 2
70930: ARRAY
70931: PUSH
70932: LD_VAR 0 3
70936: DIFF
70937: PPUSH
70938: CALL_OW 1
70942: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
70943: LD_VAR 0 3
70947: PPUSH
70948: CALL_OW 263
70952: PUSH
70953: LD_INT 1
70955: EQUAL
70956: IFFALSE 70972
// ComExitVehicle ( IsInUnit ( j ) ) ;
70958: LD_VAR 0 3
70962: PPUSH
70963: CALL_OW 310
70967: PPUSH
70968: CALL_OW 121
// if GetControl ( j ) = control_remote then
70972: LD_VAR 0 3
70976: PPUSH
70977: CALL_OW 263
70981: PUSH
70982: LD_INT 2
70984: EQUAL
70985: IFFALSE 70996
// ComUnlink ( j ) ;
70987: LD_VAR 0 3
70991: PPUSH
70992: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
70996: LD_ADDR_VAR 0 10
71000: PUSH
71001: LD_VAR 0 2
71005: PPUSH
71006: LD_INT 3
71008: PPUSH
71009: CALL 80755 0 2
71013: ST_TO_ADDR
// if fac then
71014: LD_VAR 0 10
71018: IFFALSE 71114
// begin for k in fac do
71020: LD_ADDR_VAR 0 4
71024: PUSH
71025: LD_VAR 0 10
71029: PUSH
71030: FOR_IN
71031: IFFALSE 71112
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71033: LD_ADDR_VAR 0 11
71037: PUSH
71038: LD_VAR 0 10
71042: PPUSH
71043: LD_VAR 0 3
71047: PPUSH
71048: CALL_OW 265
71052: PPUSH
71053: LD_VAR 0 3
71057: PPUSH
71058: CALL_OW 262
71062: PPUSH
71063: LD_VAR 0 3
71067: PPUSH
71068: CALL_OW 263
71072: PPUSH
71073: LD_VAR 0 3
71077: PPUSH
71078: CALL_OW 264
71082: PPUSH
71083: CALL 17499 0 5
71087: ST_TO_ADDR
// if components then
71088: LD_VAR 0 11
71092: IFFALSE 71110
// begin MC_InsertProduceList ( i , components ) ;
71094: LD_VAR 0 2
71098: PPUSH
71099: LD_VAR 0 11
71103: PPUSH
71104: CALL 80300 0 2
// break ;
71108: GO 71112
// end ; end ;
71110: GO 71030
71112: POP
71113: POP
// end ; continue ;
71114: GO 70659
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71116: LD_VAR 0 3
71120: PPUSH
71121: LD_INT 1
71123: PPUSH
71124: CALL_OW 289
71128: PUSH
71129: LD_INT 100
71131: LESS
71132: PUSH
71133: LD_VAR 0 3
71137: PPUSH
71138: CALL_OW 314
71142: NOT
71143: AND
71144: IFFALSE 71173
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71146: LD_VAR 0 3
71150: PPUSH
71151: LD_VAR 0 7
71155: PUSH
71156: LD_INT 2
71158: ARRAY
71159: PPUSH
71160: LD_VAR 0 7
71164: PUSH
71165: LD_INT 3
71167: ARRAY
71168: PPUSH
71169: CALL_OW 117
// break ;
71173: GO 71177
// end ;
71175: GO 70659
71177: POP
71178: POP
// end ; end ;
71179: GO 69375
71181: POP
71182: POP
// end ;
71183: LD_VAR 0 1
71187: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71188: LD_INT 0
71190: PPUSH
71191: PPUSH
71192: PPUSH
71193: PPUSH
// if not mc_bases then
71194: LD_EXP 60
71198: NOT
71199: IFFALSE 71203
// exit ;
71201: GO 71364
// for i = 1 to mc_bases do
71203: LD_ADDR_VAR 0 2
71207: PUSH
71208: DOUBLE
71209: LD_INT 1
71211: DEC
71212: ST_TO_ADDR
71213: LD_EXP 60
71217: PUSH
71218: FOR_TO
71219: IFFALSE 71362
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71221: LD_ADDR_VAR 0 4
71225: PUSH
71226: LD_EXP 79
71230: PUSH
71231: LD_VAR 0 2
71235: ARRAY
71236: PUSH
71237: LD_EXP 82
71241: PUSH
71242: LD_VAR 0 2
71246: ARRAY
71247: UNION
71248: PPUSH
71249: LD_INT 33
71251: PUSH
71252: LD_INT 2
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PPUSH
71259: CALL_OW 72
71263: ST_TO_ADDR
// if tmp then
71264: LD_VAR 0 4
71268: IFFALSE 71360
// for j in tmp do
71270: LD_ADDR_VAR 0 3
71274: PUSH
71275: LD_VAR 0 4
71279: PUSH
71280: FOR_IN
71281: IFFALSE 71358
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
71283: LD_VAR 0 3
71287: PPUSH
71288: CALL_OW 312
71292: NOT
71293: PUSH
71294: LD_VAR 0 3
71298: PPUSH
71299: CALL_OW 256
71303: PUSH
71304: LD_INT 250
71306: GREATEREQUAL
71307: AND
71308: IFFALSE 71321
// Connect ( j ) else
71310: LD_VAR 0 3
71314: PPUSH
71315: CALL 22974 0 1
71319: GO 71356
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
71321: LD_VAR 0 3
71325: PPUSH
71326: CALL_OW 256
71330: PUSH
71331: LD_INT 250
71333: LESS
71334: PUSH
71335: LD_VAR 0 3
71339: PPUSH
71340: CALL_OW 312
71344: AND
71345: IFFALSE 71356
// ComUnlink ( j ) ;
71347: LD_VAR 0 3
71351: PPUSH
71352: CALL_OW 136
71356: GO 71280
71358: POP
71359: POP
// end ;
71360: GO 71218
71362: POP
71363: POP
// end ;
71364: LD_VAR 0 1
71368: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
71369: LD_INT 0
71371: PPUSH
71372: PPUSH
71373: PPUSH
71374: PPUSH
71375: PPUSH
// if not mc_bases then
71376: LD_EXP 60
71380: NOT
71381: IFFALSE 71385
// exit ;
71383: GO 71830
// for i = 1 to mc_bases do
71385: LD_ADDR_VAR 0 2
71389: PUSH
71390: DOUBLE
71391: LD_INT 1
71393: DEC
71394: ST_TO_ADDR
71395: LD_EXP 60
71399: PUSH
71400: FOR_TO
71401: IFFALSE 71828
// begin if not mc_produce [ i ] then
71403: LD_EXP 81
71407: PUSH
71408: LD_VAR 0 2
71412: ARRAY
71413: NOT
71414: IFFALSE 71418
// continue ;
71416: GO 71400
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
71418: LD_ADDR_VAR 0 5
71422: PUSH
71423: LD_EXP 60
71427: PUSH
71428: LD_VAR 0 2
71432: ARRAY
71433: PPUSH
71434: LD_INT 30
71436: PUSH
71437: LD_INT 3
71439: PUSH
71440: EMPTY
71441: LIST
71442: LIST
71443: PPUSH
71444: CALL_OW 72
71448: ST_TO_ADDR
// if not fac then
71449: LD_VAR 0 5
71453: NOT
71454: IFFALSE 71458
// continue ;
71456: GO 71400
// for j in fac do
71458: LD_ADDR_VAR 0 3
71462: PUSH
71463: LD_VAR 0 5
71467: PUSH
71468: FOR_IN
71469: IFFALSE 71824
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
71471: LD_VAR 0 3
71475: PPUSH
71476: CALL_OW 461
71480: PUSH
71481: LD_INT 2
71483: NONEQUAL
71484: PUSH
71485: LD_VAR 0 3
71489: PPUSH
71490: LD_INT 15
71492: PPUSH
71493: CALL 22602 0 2
71497: PUSH
71498: LD_INT 4
71500: ARRAY
71501: OR
71502: IFFALSE 71506
// continue ;
71504: GO 71468
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
71506: LD_VAR 0 3
71510: PPUSH
71511: LD_EXP 81
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PUSH
71522: LD_INT 1
71524: ARRAY
71525: PUSH
71526: LD_INT 1
71528: ARRAY
71529: PPUSH
71530: LD_EXP 81
71534: PUSH
71535: LD_VAR 0 2
71539: ARRAY
71540: PUSH
71541: LD_INT 1
71543: ARRAY
71544: PUSH
71545: LD_INT 2
71547: ARRAY
71548: PPUSH
71549: LD_EXP 81
71553: PUSH
71554: LD_VAR 0 2
71558: ARRAY
71559: PUSH
71560: LD_INT 1
71562: ARRAY
71563: PUSH
71564: LD_INT 3
71566: ARRAY
71567: PPUSH
71568: LD_EXP 81
71572: PUSH
71573: LD_VAR 0 2
71577: ARRAY
71578: PUSH
71579: LD_INT 1
71581: ARRAY
71582: PUSH
71583: LD_INT 4
71585: ARRAY
71586: PPUSH
71587: CALL_OW 448
71591: PUSH
71592: LD_VAR 0 3
71596: PPUSH
71597: LD_EXP 81
71601: PUSH
71602: LD_VAR 0 2
71606: ARRAY
71607: PUSH
71608: LD_INT 1
71610: ARRAY
71611: PUSH
71612: LD_INT 1
71614: ARRAY
71615: PUSH
71616: LD_EXP 81
71620: PUSH
71621: LD_VAR 0 2
71625: ARRAY
71626: PUSH
71627: LD_INT 1
71629: ARRAY
71630: PUSH
71631: LD_INT 2
71633: ARRAY
71634: PUSH
71635: LD_EXP 81
71639: PUSH
71640: LD_VAR 0 2
71644: ARRAY
71645: PUSH
71646: LD_INT 1
71648: ARRAY
71649: PUSH
71650: LD_INT 3
71652: ARRAY
71653: PUSH
71654: LD_EXP 81
71658: PUSH
71659: LD_VAR 0 2
71663: ARRAY
71664: PUSH
71665: LD_INT 1
71667: ARRAY
71668: PUSH
71669: LD_INT 4
71671: ARRAY
71672: PUSH
71673: EMPTY
71674: LIST
71675: LIST
71676: LIST
71677: LIST
71678: PPUSH
71679: CALL 26369 0 2
71683: AND
71684: IFFALSE 71822
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
71686: LD_VAR 0 3
71690: PPUSH
71691: LD_EXP 81
71695: PUSH
71696: LD_VAR 0 2
71700: ARRAY
71701: PUSH
71702: LD_INT 1
71704: ARRAY
71705: PUSH
71706: LD_INT 1
71708: ARRAY
71709: PPUSH
71710: LD_EXP 81
71714: PUSH
71715: LD_VAR 0 2
71719: ARRAY
71720: PUSH
71721: LD_INT 1
71723: ARRAY
71724: PUSH
71725: LD_INT 2
71727: ARRAY
71728: PPUSH
71729: LD_EXP 81
71733: PUSH
71734: LD_VAR 0 2
71738: ARRAY
71739: PUSH
71740: LD_INT 1
71742: ARRAY
71743: PUSH
71744: LD_INT 3
71746: ARRAY
71747: PPUSH
71748: LD_EXP 81
71752: PUSH
71753: LD_VAR 0 2
71757: ARRAY
71758: PUSH
71759: LD_INT 1
71761: ARRAY
71762: PUSH
71763: LD_INT 4
71765: ARRAY
71766: PPUSH
71767: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
71771: LD_ADDR_VAR 0 4
71775: PUSH
71776: LD_EXP 81
71780: PUSH
71781: LD_VAR 0 2
71785: ARRAY
71786: PPUSH
71787: LD_INT 1
71789: PPUSH
71790: CALL_OW 3
71794: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
71795: LD_ADDR_EXP 81
71799: PUSH
71800: LD_EXP 81
71804: PPUSH
71805: LD_VAR 0 2
71809: PPUSH
71810: LD_VAR 0 4
71814: PPUSH
71815: CALL_OW 1
71819: ST_TO_ADDR
// break ;
71820: GO 71824
// end ; end ;
71822: GO 71468
71824: POP
71825: POP
// end ;
71826: GO 71400
71828: POP
71829: POP
// end ;
71830: LD_VAR 0 1
71834: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
71835: LD_INT 0
71837: PPUSH
71838: PPUSH
71839: PPUSH
// if not mc_bases then
71840: LD_EXP 60
71844: NOT
71845: IFFALSE 71849
// exit ;
71847: GO 71938
// for i = 1 to mc_bases do
71849: LD_ADDR_VAR 0 2
71853: PUSH
71854: DOUBLE
71855: LD_INT 1
71857: DEC
71858: ST_TO_ADDR
71859: LD_EXP 60
71863: PUSH
71864: FOR_TO
71865: IFFALSE 71936
// begin if mc_attack [ i ] then
71867: LD_EXP 80
71871: PUSH
71872: LD_VAR 0 2
71876: ARRAY
71877: IFFALSE 71934
// begin tmp := mc_attack [ i ] [ 1 ] ;
71879: LD_ADDR_VAR 0 3
71883: PUSH
71884: LD_EXP 80
71888: PUSH
71889: LD_VAR 0 2
71893: ARRAY
71894: PUSH
71895: LD_INT 1
71897: ARRAY
71898: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
71899: LD_ADDR_EXP 80
71903: PUSH
71904: LD_EXP 80
71908: PPUSH
71909: LD_VAR 0 2
71913: PPUSH
71914: EMPTY
71915: PPUSH
71916: CALL_OW 1
71920: ST_TO_ADDR
// Attack ( tmp ) ;
71921: LD_VAR 0 3
71925: PPUSH
71926: CALL 106828 0 1
// exit ;
71930: POP
71931: POP
71932: GO 71938
// end ; end ;
71934: GO 71864
71936: POP
71937: POP
// end ;
71938: LD_VAR 0 1
71942: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
71943: LD_INT 0
71945: PPUSH
71946: PPUSH
71947: PPUSH
71948: PPUSH
71949: PPUSH
71950: PPUSH
71951: PPUSH
// if not mc_bases then
71952: LD_EXP 60
71956: NOT
71957: IFFALSE 71961
// exit ;
71959: GO 72818
// for i = 1 to mc_bases do
71961: LD_ADDR_VAR 0 2
71965: PUSH
71966: DOUBLE
71967: LD_INT 1
71969: DEC
71970: ST_TO_ADDR
71971: LD_EXP 60
71975: PUSH
71976: FOR_TO
71977: IFFALSE 72816
// begin if not mc_bases [ i ] then
71979: LD_EXP 60
71983: PUSH
71984: LD_VAR 0 2
71988: ARRAY
71989: NOT
71990: IFFALSE 71994
// continue ;
71992: GO 71976
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
71994: LD_ADDR_VAR 0 7
71998: PUSH
71999: LD_EXP 60
72003: PUSH
72004: LD_VAR 0 2
72008: ARRAY
72009: PUSH
72010: LD_INT 1
72012: ARRAY
72013: PPUSH
72014: CALL 16650 0 1
72018: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72019: LD_ADDR_EXP 83
72023: PUSH
72024: LD_EXP 83
72028: PPUSH
72029: LD_VAR 0 2
72033: PPUSH
72034: LD_EXP 60
72038: PUSH
72039: LD_VAR 0 2
72043: ARRAY
72044: PUSH
72045: LD_INT 1
72047: ARRAY
72048: PPUSH
72049: CALL_OW 255
72053: PPUSH
72054: LD_EXP 85
72058: PUSH
72059: LD_VAR 0 2
72063: ARRAY
72064: PPUSH
72065: CALL 16615 0 2
72069: PPUSH
72070: CALL_OW 1
72074: ST_TO_ADDR
// if not mc_scan [ i ] then
72075: LD_EXP 83
72079: PUSH
72080: LD_VAR 0 2
72084: ARRAY
72085: NOT
72086: IFFALSE 72264
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
72088: LD_ADDR_EXP 103
72092: PUSH
72093: LD_EXP 103
72097: PPUSH
72098: LD_VAR 0 2
72102: PPUSH
72103: LD_INT 0
72105: PPUSH
72106: CALL_OW 1
72110: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72111: LD_ADDR_VAR 0 4
72115: PUSH
72116: LD_EXP 60
72120: PUSH
72121: LD_VAR 0 2
72125: ARRAY
72126: PPUSH
72127: LD_INT 2
72129: PUSH
72130: LD_INT 25
72132: PUSH
72133: LD_INT 5
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 25
72142: PUSH
72143: LD_INT 8
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 25
72152: PUSH
72153: LD_INT 9
72155: PUSH
72156: EMPTY
72157: LIST
72158: LIST
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: LIST
72164: LIST
72165: PPUSH
72166: CALL_OW 72
72170: ST_TO_ADDR
// if not tmp then
72171: LD_VAR 0 4
72175: NOT
72176: IFFALSE 72180
// continue ;
72178: GO 71976
// for j in tmp do
72180: LD_ADDR_VAR 0 3
72184: PUSH
72185: LD_VAR 0 4
72189: PUSH
72190: FOR_IN
72191: IFFALSE 72262
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72193: LD_VAR 0 3
72197: PPUSH
72198: CALL_OW 310
72202: PPUSH
72203: CALL_OW 266
72207: PUSH
72208: LD_INT 5
72210: EQUAL
72211: PUSH
72212: LD_VAR 0 3
72216: PPUSH
72217: CALL_OW 257
72221: PUSH
72222: LD_INT 1
72224: EQUAL
72225: AND
72226: PUSH
72227: LD_VAR 0 3
72231: PPUSH
72232: CALL_OW 459
72236: NOT
72237: AND
72238: PUSH
72239: LD_VAR 0 7
72243: AND
72244: IFFALSE 72260
// ComChangeProfession ( j , class ) ;
72246: LD_VAR 0 3
72250: PPUSH
72251: LD_VAR 0 7
72255: PPUSH
72256: CALL_OW 123
72260: GO 72190
72262: POP
72263: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
72264: LD_EXP 83
72268: PUSH
72269: LD_VAR 0 2
72273: ARRAY
72274: PUSH
72275: LD_EXP 103
72279: PUSH
72280: LD_VAR 0 2
72284: ARRAY
72285: NOT
72286: AND
72287: PUSH
72288: LD_EXP 82
72292: PUSH
72293: LD_VAR 0 2
72297: ARRAY
72298: NOT
72299: AND
72300: PUSH
72301: LD_EXP 60
72305: PUSH
72306: LD_VAR 0 2
72310: ARRAY
72311: PPUSH
72312: LD_INT 50
72314: PUSH
72315: EMPTY
72316: LIST
72317: PUSH
72318: LD_INT 2
72320: PUSH
72321: LD_INT 30
72323: PUSH
72324: LD_INT 32
72326: PUSH
72327: EMPTY
72328: LIST
72329: LIST
72330: PUSH
72331: LD_INT 30
72333: PUSH
72334: LD_INT 33
72336: PUSH
72337: EMPTY
72338: LIST
72339: LIST
72340: PUSH
72341: LD_INT 30
72343: PUSH
72344: LD_INT 4
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 30
72353: PUSH
72354: LD_INT 5
72356: PUSH
72357: EMPTY
72358: LIST
72359: LIST
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: PUSH
72368: EMPTY
72369: LIST
72370: LIST
72371: PPUSH
72372: CALL_OW 72
72376: PUSH
72377: LD_INT 4
72379: LESS
72380: PUSH
72381: LD_EXP 60
72385: PUSH
72386: LD_VAR 0 2
72390: ARRAY
72391: PPUSH
72392: LD_INT 3
72394: PUSH
72395: LD_INT 24
72397: PUSH
72398: LD_INT 1000
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 2
72411: PUSH
72412: LD_INT 30
72414: PUSH
72415: LD_INT 0
72417: PUSH
72418: EMPTY
72419: LIST
72420: LIST
72421: PUSH
72422: LD_INT 30
72424: PUSH
72425: LD_INT 1
72427: PUSH
72428: EMPTY
72429: LIST
72430: LIST
72431: PUSH
72432: EMPTY
72433: LIST
72434: LIST
72435: LIST
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PPUSH
72441: CALL_OW 72
72445: OR
72446: AND
72447: IFFALSE 72698
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72449: LD_ADDR_EXP 103
72453: PUSH
72454: LD_EXP 103
72458: PPUSH
72459: LD_VAR 0 2
72463: PPUSH
72464: LD_INT 1
72466: PPUSH
72467: CALL_OW 1
72471: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72472: LD_ADDR_VAR 0 4
72476: PUSH
72477: LD_EXP 60
72481: PUSH
72482: LD_VAR 0 2
72486: ARRAY
72487: PPUSH
72488: LD_INT 2
72490: PUSH
72491: LD_INT 25
72493: PUSH
72494: LD_INT 1
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 25
72503: PUSH
72504: LD_INT 5
72506: PUSH
72507: EMPTY
72508: LIST
72509: LIST
72510: PUSH
72511: LD_INT 25
72513: PUSH
72514: LD_INT 8
72516: PUSH
72517: EMPTY
72518: LIST
72519: LIST
72520: PUSH
72521: LD_INT 25
72523: PUSH
72524: LD_INT 9
72526: PUSH
72527: EMPTY
72528: LIST
72529: LIST
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: LIST
72535: LIST
72536: LIST
72537: PPUSH
72538: CALL_OW 72
72542: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
72543: LD_ADDR_VAR 0 4
72547: PUSH
72548: LD_VAR 0 4
72552: PUSH
72553: LD_VAR 0 4
72557: PPUSH
72558: LD_INT 18
72560: PPUSH
72561: CALL 49839 0 2
72565: DIFF
72566: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
72567: LD_VAR 0 4
72571: NOT
72572: PUSH
72573: LD_EXP 60
72577: PUSH
72578: LD_VAR 0 2
72582: ARRAY
72583: PPUSH
72584: LD_INT 2
72586: PUSH
72587: LD_INT 30
72589: PUSH
72590: LD_INT 4
72592: PUSH
72593: EMPTY
72594: LIST
72595: LIST
72596: PUSH
72597: LD_INT 30
72599: PUSH
72600: LD_INT 5
72602: PUSH
72603: EMPTY
72604: LIST
72605: LIST
72606: PUSH
72607: EMPTY
72608: LIST
72609: LIST
72610: LIST
72611: PPUSH
72612: CALL_OW 72
72616: NOT
72617: AND
72618: IFFALSE 72680
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
72620: LD_ADDR_VAR 0 4
72624: PUSH
72625: LD_EXP 60
72629: PUSH
72630: LD_VAR 0 2
72634: ARRAY
72635: PPUSH
72636: LD_INT 2
72638: PUSH
72639: LD_INT 25
72641: PUSH
72642: LD_INT 2
72644: PUSH
72645: EMPTY
72646: LIST
72647: LIST
72648: PUSH
72649: LD_INT 25
72651: PUSH
72652: LD_INT 3
72654: PUSH
72655: EMPTY
72656: LIST
72657: LIST
72658: PUSH
72659: LD_INT 25
72661: PUSH
72662: LD_INT 4
72664: PUSH
72665: EMPTY
72666: LIST
72667: LIST
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: PPUSH
72675: CALL_OW 72
72679: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
72680: LD_VAR 0 2
72684: PPUSH
72685: LD_VAR 0 4
72689: PPUSH
72690: CALL 111537 0 2
// exit ;
72694: POP
72695: POP
72696: GO 72818
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
72698: LD_EXP 83
72702: PUSH
72703: LD_VAR 0 2
72707: ARRAY
72708: PUSH
72709: LD_EXP 103
72713: PUSH
72714: LD_VAR 0 2
72718: ARRAY
72719: NOT
72720: AND
72721: PUSH
72722: LD_EXP 82
72726: PUSH
72727: LD_VAR 0 2
72731: ARRAY
72732: AND
72733: IFFALSE 72814
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
72735: LD_ADDR_EXP 103
72739: PUSH
72740: LD_EXP 103
72744: PPUSH
72745: LD_VAR 0 2
72749: PPUSH
72750: LD_INT 1
72752: PPUSH
72753: CALL_OW 1
72757: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
72758: LD_ADDR_VAR 0 4
72762: PUSH
72763: LD_EXP 82
72767: PUSH
72768: LD_VAR 0 2
72772: ARRAY
72773: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
72774: LD_ADDR_EXP 82
72778: PUSH
72779: LD_EXP 82
72783: PPUSH
72784: LD_VAR 0 2
72788: PPUSH
72789: EMPTY
72790: PPUSH
72791: CALL_OW 1
72795: ST_TO_ADDR
// Defend ( i , tmp ) ;
72796: LD_VAR 0 2
72800: PPUSH
72801: LD_VAR 0 4
72805: PPUSH
72806: CALL 112133 0 2
// exit ;
72810: POP
72811: POP
72812: GO 72818
// end ; end ;
72814: GO 71976
72816: POP
72817: POP
// end ;
72818: LD_VAR 0 1
72822: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
72823: LD_INT 0
72825: PPUSH
72826: PPUSH
72827: PPUSH
72828: PPUSH
72829: PPUSH
72830: PPUSH
72831: PPUSH
72832: PPUSH
72833: PPUSH
72834: PPUSH
72835: PPUSH
// if not mc_bases then
72836: LD_EXP 60
72840: NOT
72841: IFFALSE 72845
// exit ;
72843: GO 73932
// for i = 1 to mc_bases do
72845: LD_ADDR_VAR 0 2
72849: PUSH
72850: DOUBLE
72851: LD_INT 1
72853: DEC
72854: ST_TO_ADDR
72855: LD_EXP 60
72859: PUSH
72860: FOR_TO
72861: IFFALSE 73930
// begin tmp := mc_lab [ i ] ;
72863: LD_ADDR_VAR 0 6
72867: PUSH
72868: LD_EXP 93
72872: PUSH
72873: LD_VAR 0 2
72877: ARRAY
72878: ST_TO_ADDR
// if not tmp then
72879: LD_VAR 0 6
72883: NOT
72884: IFFALSE 72888
// continue ;
72886: GO 72860
// idle_lab := 0 ;
72888: LD_ADDR_VAR 0 11
72892: PUSH
72893: LD_INT 0
72895: ST_TO_ADDR
// for j in tmp do
72896: LD_ADDR_VAR 0 3
72900: PUSH
72901: LD_VAR 0 6
72905: PUSH
72906: FOR_IN
72907: IFFALSE 73926
// begin researching := false ;
72909: LD_ADDR_VAR 0 10
72913: PUSH
72914: LD_INT 0
72916: ST_TO_ADDR
// side := GetSide ( j ) ;
72917: LD_ADDR_VAR 0 4
72921: PUSH
72922: LD_VAR 0 3
72926: PPUSH
72927: CALL_OW 255
72931: ST_TO_ADDR
// if not mc_tech [ side ] then
72932: LD_EXP 87
72936: PUSH
72937: LD_VAR 0 4
72941: ARRAY
72942: NOT
72943: IFFALSE 72947
// continue ;
72945: GO 72906
// if BuildingStatus ( j ) = bs_idle then
72947: LD_VAR 0 3
72951: PPUSH
72952: CALL_OW 461
72956: PUSH
72957: LD_INT 2
72959: EQUAL
72960: IFFALSE 73148
// begin if idle_lab and UnitsInside ( j ) < 6 then
72962: LD_VAR 0 11
72966: PUSH
72967: LD_VAR 0 3
72971: PPUSH
72972: CALL_OW 313
72976: PUSH
72977: LD_INT 6
72979: LESS
72980: AND
72981: IFFALSE 73052
// begin tmp2 := UnitsInside ( idle_lab ) ;
72983: LD_ADDR_VAR 0 9
72987: PUSH
72988: LD_VAR 0 11
72992: PPUSH
72993: CALL_OW 313
72997: ST_TO_ADDR
// if tmp2 then
72998: LD_VAR 0 9
73002: IFFALSE 73044
// for x in tmp2 do
73004: LD_ADDR_VAR 0 7
73008: PUSH
73009: LD_VAR 0 9
73013: PUSH
73014: FOR_IN
73015: IFFALSE 73042
// begin ComExitBuilding ( x ) ;
73017: LD_VAR 0 7
73021: PPUSH
73022: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73026: LD_VAR 0 7
73030: PPUSH
73031: LD_VAR 0 3
73035: PPUSH
73036: CALL_OW 180
// end ;
73040: GO 73014
73042: POP
73043: POP
// idle_lab := 0 ;
73044: LD_ADDR_VAR 0 11
73048: PUSH
73049: LD_INT 0
73051: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73052: LD_ADDR_VAR 0 5
73056: PUSH
73057: LD_EXP 87
73061: PUSH
73062: LD_VAR 0 4
73066: ARRAY
73067: PUSH
73068: FOR_IN
73069: IFFALSE 73129
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73071: LD_VAR 0 3
73075: PPUSH
73076: LD_VAR 0 5
73080: PPUSH
73081: CALL_OW 430
73085: PUSH
73086: LD_VAR 0 4
73090: PPUSH
73091: LD_VAR 0 5
73095: PPUSH
73096: CALL 15720 0 2
73100: AND
73101: IFFALSE 73127
// begin researching := true ;
73103: LD_ADDR_VAR 0 10
73107: PUSH
73108: LD_INT 1
73110: ST_TO_ADDR
// ComResearch ( j , t ) ;
73111: LD_VAR 0 3
73115: PPUSH
73116: LD_VAR 0 5
73120: PPUSH
73121: CALL_OW 124
// break ;
73125: GO 73129
// end ;
73127: GO 73068
73129: POP
73130: POP
// if not researching then
73131: LD_VAR 0 10
73135: NOT
73136: IFFALSE 73148
// idle_lab := j ;
73138: LD_ADDR_VAR 0 11
73142: PUSH
73143: LD_VAR 0 3
73147: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73148: LD_VAR 0 3
73152: PPUSH
73153: CALL_OW 461
73157: PUSH
73158: LD_INT 10
73160: EQUAL
73161: IFFALSE 73749
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73163: LD_EXP 89
73167: PUSH
73168: LD_VAR 0 2
73172: ARRAY
73173: NOT
73174: PUSH
73175: LD_EXP 90
73179: PUSH
73180: LD_VAR 0 2
73184: ARRAY
73185: NOT
73186: AND
73187: PUSH
73188: LD_EXP 87
73192: PUSH
73193: LD_VAR 0 4
73197: ARRAY
73198: PUSH
73199: LD_INT 1
73201: GREATER
73202: AND
73203: IFFALSE 73334
// begin ComCancel ( j ) ;
73205: LD_VAR 0 3
73209: PPUSH
73210: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73214: LD_ADDR_EXP 87
73218: PUSH
73219: LD_EXP 87
73223: PPUSH
73224: LD_VAR 0 4
73228: PPUSH
73229: LD_EXP 87
73233: PUSH
73234: LD_VAR 0 4
73238: ARRAY
73239: PPUSH
73240: LD_EXP 87
73244: PUSH
73245: LD_VAR 0 4
73249: ARRAY
73250: PUSH
73251: LD_INT 1
73253: MINUS
73254: PPUSH
73255: LD_EXP 87
73259: PUSH
73260: LD_VAR 0 4
73264: ARRAY
73265: PPUSH
73266: LD_INT 0
73268: PPUSH
73269: CALL 19421 0 4
73273: PPUSH
73274: CALL_OW 1
73278: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73279: LD_ADDR_EXP 87
73283: PUSH
73284: LD_EXP 87
73288: PPUSH
73289: LD_VAR 0 4
73293: PPUSH
73294: LD_EXP 87
73298: PUSH
73299: LD_VAR 0 4
73303: ARRAY
73304: PPUSH
73305: LD_EXP 87
73309: PUSH
73310: LD_VAR 0 4
73314: ARRAY
73315: PPUSH
73316: LD_INT 1
73318: PPUSH
73319: LD_INT 0
73321: PPUSH
73322: CALL 19421 0 4
73326: PPUSH
73327: CALL_OW 1
73331: ST_TO_ADDR
// continue ;
73332: GO 72906
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73334: LD_EXP 89
73338: PUSH
73339: LD_VAR 0 2
73343: ARRAY
73344: PUSH
73345: LD_EXP 90
73349: PUSH
73350: LD_VAR 0 2
73354: ARRAY
73355: NOT
73356: AND
73357: IFFALSE 73484
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73359: LD_ADDR_EXP 90
73363: PUSH
73364: LD_EXP 90
73368: PPUSH
73369: LD_VAR 0 2
73373: PUSH
73374: LD_EXP 90
73378: PUSH
73379: LD_VAR 0 2
73383: ARRAY
73384: PUSH
73385: LD_INT 1
73387: PLUS
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PPUSH
73393: LD_EXP 89
73397: PUSH
73398: LD_VAR 0 2
73402: ARRAY
73403: PUSH
73404: LD_INT 1
73406: ARRAY
73407: PPUSH
73408: CALL 20003 0 3
73412: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73413: LD_EXP 89
73417: PUSH
73418: LD_VAR 0 2
73422: ARRAY
73423: PUSH
73424: LD_INT 1
73426: ARRAY
73427: PPUSH
73428: LD_INT 112
73430: PPUSH
73431: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73435: LD_ADDR_VAR 0 9
73439: PUSH
73440: LD_EXP 89
73444: PUSH
73445: LD_VAR 0 2
73449: ARRAY
73450: PPUSH
73451: LD_INT 1
73453: PPUSH
73454: CALL_OW 3
73458: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73459: LD_ADDR_EXP 89
73463: PUSH
73464: LD_EXP 89
73468: PPUSH
73469: LD_VAR 0 2
73473: PPUSH
73474: LD_VAR 0 9
73478: PPUSH
73479: CALL_OW 1
73483: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73484: LD_EXP 89
73488: PUSH
73489: LD_VAR 0 2
73493: ARRAY
73494: PUSH
73495: LD_EXP 90
73499: PUSH
73500: LD_VAR 0 2
73504: ARRAY
73505: AND
73506: PUSH
73507: LD_EXP 90
73511: PUSH
73512: LD_VAR 0 2
73516: ARRAY
73517: PUSH
73518: LD_INT 1
73520: ARRAY
73521: PPUSH
73522: CALL_OW 310
73526: NOT
73527: AND
73528: PUSH
73529: LD_VAR 0 3
73533: PPUSH
73534: CALL_OW 313
73538: PUSH
73539: LD_INT 6
73541: EQUAL
73542: AND
73543: IFFALSE 73599
// begin tmp2 := UnitsInside ( j ) ;
73545: LD_ADDR_VAR 0 9
73549: PUSH
73550: LD_VAR 0 3
73554: PPUSH
73555: CALL_OW 313
73559: ST_TO_ADDR
// if tmp2 = 6 then
73560: LD_VAR 0 9
73564: PUSH
73565: LD_INT 6
73567: EQUAL
73568: IFFALSE 73599
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
73570: LD_VAR 0 9
73574: PUSH
73575: LD_INT 1
73577: ARRAY
73578: PPUSH
73579: LD_INT 112
73581: PPUSH
73582: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
73586: LD_VAR 0 9
73590: PUSH
73591: LD_INT 1
73593: ARRAY
73594: PPUSH
73595: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
73599: LD_EXP 90
73603: PUSH
73604: LD_VAR 0 2
73608: ARRAY
73609: PUSH
73610: LD_EXP 90
73614: PUSH
73615: LD_VAR 0 2
73619: ARRAY
73620: PUSH
73621: LD_INT 1
73623: ARRAY
73624: PPUSH
73625: CALL_OW 314
73629: NOT
73630: AND
73631: PUSH
73632: LD_EXP 90
73636: PUSH
73637: LD_VAR 0 2
73641: ARRAY
73642: PUSH
73643: LD_INT 1
73645: ARRAY
73646: PPUSH
73647: CALL_OW 310
73651: NOT
73652: AND
73653: IFFALSE 73679
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
73655: LD_EXP 90
73659: PUSH
73660: LD_VAR 0 2
73664: ARRAY
73665: PUSH
73666: LD_INT 1
73668: ARRAY
73669: PPUSH
73670: LD_VAR 0 3
73674: PPUSH
73675: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
73679: LD_EXP 90
73683: PUSH
73684: LD_VAR 0 2
73688: ARRAY
73689: PUSH
73690: LD_INT 1
73692: ARRAY
73693: PPUSH
73694: CALL_OW 310
73698: PUSH
73699: LD_EXP 90
73703: PUSH
73704: LD_VAR 0 2
73708: ARRAY
73709: PUSH
73710: LD_INT 1
73712: ARRAY
73713: PPUSH
73714: CALL_OW 310
73718: PPUSH
73719: CALL_OW 461
73723: PUSH
73724: LD_INT 3
73726: NONEQUAL
73727: AND
73728: IFFALSE 73749
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
73730: LD_EXP 90
73734: PUSH
73735: LD_VAR 0 2
73739: ARRAY
73740: PUSH
73741: LD_INT 1
73743: ARRAY
73744: PPUSH
73745: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
73749: LD_VAR 0 3
73753: PPUSH
73754: CALL_OW 461
73758: PUSH
73759: LD_INT 6
73761: EQUAL
73762: PUSH
73763: LD_VAR 0 6
73767: PUSH
73768: LD_INT 1
73770: GREATER
73771: AND
73772: IFFALSE 73924
// begin sci := [ ] ;
73774: LD_ADDR_VAR 0 8
73778: PUSH
73779: EMPTY
73780: ST_TO_ADDR
// for x in ( tmp diff j ) do
73781: LD_ADDR_VAR 0 7
73785: PUSH
73786: LD_VAR 0 6
73790: PUSH
73791: LD_VAR 0 3
73795: DIFF
73796: PUSH
73797: FOR_IN
73798: IFFALSE 73850
// begin if sci = 6 then
73800: LD_VAR 0 8
73804: PUSH
73805: LD_INT 6
73807: EQUAL
73808: IFFALSE 73812
// break ;
73810: GO 73850
// if BuildingStatus ( x ) = bs_idle then
73812: LD_VAR 0 7
73816: PPUSH
73817: CALL_OW 461
73821: PUSH
73822: LD_INT 2
73824: EQUAL
73825: IFFALSE 73848
// sci := sci ^ UnitsInside ( x ) ;
73827: LD_ADDR_VAR 0 8
73831: PUSH
73832: LD_VAR 0 8
73836: PUSH
73837: LD_VAR 0 7
73841: PPUSH
73842: CALL_OW 313
73846: ADD
73847: ST_TO_ADDR
// end ;
73848: GO 73797
73850: POP
73851: POP
// if not sci then
73852: LD_VAR 0 8
73856: NOT
73857: IFFALSE 73861
// continue ;
73859: GO 72906
// for x in sci do
73861: LD_ADDR_VAR 0 7
73865: PUSH
73866: LD_VAR 0 8
73870: PUSH
73871: FOR_IN
73872: IFFALSE 73922
// if IsInUnit ( x ) and not HasTask ( x ) then
73874: LD_VAR 0 7
73878: PPUSH
73879: CALL_OW 310
73883: PUSH
73884: LD_VAR 0 7
73888: PPUSH
73889: CALL_OW 314
73893: NOT
73894: AND
73895: IFFALSE 73920
// begin ComExitBuilding ( x ) ;
73897: LD_VAR 0 7
73901: PPUSH
73902: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73906: LD_VAR 0 7
73910: PPUSH
73911: LD_VAR 0 3
73915: PPUSH
73916: CALL_OW 180
// end ;
73920: GO 73871
73922: POP
73923: POP
// end ; end ;
73924: GO 72906
73926: POP
73927: POP
// end ;
73928: GO 72860
73930: POP
73931: POP
// end ;
73932: LD_VAR 0 1
73936: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
73937: LD_INT 0
73939: PPUSH
73940: PPUSH
// if not mc_bases then
73941: LD_EXP 60
73945: NOT
73946: IFFALSE 73950
// exit ;
73948: GO 74031
// for i = 1 to mc_bases do
73950: LD_ADDR_VAR 0 2
73954: PUSH
73955: DOUBLE
73956: LD_INT 1
73958: DEC
73959: ST_TO_ADDR
73960: LD_EXP 60
73964: PUSH
73965: FOR_TO
73966: IFFALSE 74029
// if mc_mines [ i ] and mc_miners [ i ] then
73968: LD_EXP 73
73972: PUSH
73973: LD_VAR 0 2
73977: ARRAY
73978: PUSH
73979: LD_EXP 74
73983: PUSH
73984: LD_VAR 0 2
73988: ARRAY
73989: AND
73990: IFFALSE 74027
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
73992: LD_EXP 74
73996: PUSH
73997: LD_VAR 0 2
74001: ARRAY
74002: PUSH
74003: LD_INT 1
74005: ARRAY
74006: PPUSH
74007: CALL_OW 255
74011: PPUSH
74012: LD_EXP 73
74016: PUSH
74017: LD_VAR 0 2
74021: ARRAY
74022: PPUSH
74023: CALL 16803 0 2
74027: GO 73965
74029: POP
74030: POP
// end ;
74031: LD_VAR 0 1
74035: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74036: LD_INT 0
74038: PPUSH
74039: PPUSH
74040: PPUSH
74041: PPUSH
74042: PPUSH
74043: PPUSH
74044: PPUSH
74045: PPUSH
// if not mc_bases or not mc_parking then
74046: LD_EXP 60
74050: NOT
74051: PUSH
74052: LD_EXP 84
74056: NOT
74057: OR
74058: IFFALSE 74062
// exit ;
74060: GO 74772
// for i = 1 to mc_bases do
74062: LD_ADDR_VAR 0 2
74066: PUSH
74067: DOUBLE
74068: LD_INT 1
74070: DEC
74071: ST_TO_ADDR
74072: LD_EXP 60
74076: PUSH
74077: FOR_TO
74078: IFFALSE 74770
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74080: LD_EXP 60
74084: PUSH
74085: LD_VAR 0 2
74089: ARRAY
74090: NOT
74091: PUSH
74092: LD_EXP 84
74096: PUSH
74097: LD_VAR 0 2
74101: ARRAY
74102: NOT
74103: OR
74104: IFFALSE 74108
// continue ;
74106: GO 74077
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74108: LD_ADDR_VAR 0 5
74112: PUSH
74113: LD_EXP 60
74117: PUSH
74118: LD_VAR 0 2
74122: ARRAY
74123: PUSH
74124: LD_INT 1
74126: ARRAY
74127: PPUSH
74128: CALL_OW 255
74132: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74133: LD_ADDR_VAR 0 6
74137: PUSH
74138: LD_EXP 60
74142: PUSH
74143: LD_VAR 0 2
74147: ARRAY
74148: PPUSH
74149: LD_INT 30
74151: PUSH
74152: LD_INT 3
74154: PUSH
74155: EMPTY
74156: LIST
74157: LIST
74158: PPUSH
74159: CALL_OW 72
74163: ST_TO_ADDR
// if not fac then
74164: LD_VAR 0 6
74168: NOT
74169: IFFALSE 74220
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74171: LD_ADDR_VAR 0 6
74175: PUSH
74176: LD_EXP 60
74180: PUSH
74181: LD_VAR 0 2
74185: ARRAY
74186: PPUSH
74187: LD_INT 2
74189: PUSH
74190: LD_INT 30
74192: PUSH
74193: LD_INT 0
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 30
74202: PUSH
74203: LD_INT 1
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: EMPTY
74211: LIST
74212: LIST
74213: LIST
74214: PPUSH
74215: CALL_OW 72
74219: ST_TO_ADDR
// if not fac then
74220: LD_VAR 0 6
74224: NOT
74225: IFFALSE 74229
// continue ;
74227: GO 74077
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74229: LD_ADDR_VAR 0 7
74233: PUSH
74234: LD_EXP 84
74238: PUSH
74239: LD_VAR 0 2
74243: ARRAY
74244: PPUSH
74245: LD_INT 22
74247: PUSH
74248: LD_VAR 0 5
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: PUSH
74257: LD_INT 21
74259: PUSH
74260: LD_INT 2
74262: PUSH
74263: EMPTY
74264: LIST
74265: LIST
74266: PUSH
74267: LD_INT 3
74269: PUSH
74270: LD_INT 24
74272: PUSH
74273: LD_INT 1000
74275: PUSH
74276: EMPTY
74277: LIST
74278: LIST
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: LIST
74288: PPUSH
74289: CALL_OW 70
74293: ST_TO_ADDR
// for j in fac do
74294: LD_ADDR_VAR 0 3
74298: PUSH
74299: LD_VAR 0 6
74303: PUSH
74304: FOR_IN
74305: IFFALSE 74386
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74307: LD_ADDR_VAR 0 7
74311: PUSH
74312: LD_VAR 0 7
74316: PUSH
74317: LD_INT 22
74319: PUSH
74320: LD_VAR 0 5
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 91
74331: PUSH
74332: LD_VAR 0 3
74336: PUSH
74337: LD_INT 15
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: LIST
74344: PUSH
74345: LD_INT 21
74347: PUSH
74348: LD_INT 2
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 3
74357: PUSH
74358: LD_INT 24
74360: PUSH
74361: LD_INT 1000
74363: PUSH
74364: EMPTY
74365: LIST
74366: LIST
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: LIST
74376: LIST
74377: PPUSH
74378: CALL_OW 69
74382: UNION
74383: ST_TO_ADDR
74384: GO 74304
74386: POP
74387: POP
// if not vehs then
74388: LD_VAR 0 7
74392: NOT
74393: IFFALSE 74419
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74395: LD_ADDR_EXP 72
74399: PUSH
74400: LD_EXP 72
74404: PPUSH
74405: LD_VAR 0 2
74409: PPUSH
74410: EMPTY
74411: PPUSH
74412: CALL_OW 1
74416: ST_TO_ADDR
// continue ;
74417: GO 74077
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74419: LD_ADDR_VAR 0 8
74423: PUSH
74424: LD_EXP 60
74428: PUSH
74429: LD_VAR 0 2
74433: ARRAY
74434: PPUSH
74435: LD_INT 30
74437: PUSH
74438: LD_INT 3
74440: PUSH
74441: EMPTY
74442: LIST
74443: LIST
74444: PPUSH
74445: CALL_OW 72
74449: ST_TO_ADDR
// if tmp then
74450: LD_VAR 0 8
74454: IFFALSE 74557
// begin for j in tmp do
74456: LD_ADDR_VAR 0 3
74460: PUSH
74461: LD_VAR 0 8
74465: PUSH
74466: FOR_IN
74467: IFFALSE 74555
// for k in UnitsInside ( j ) do
74469: LD_ADDR_VAR 0 4
74473: PUSH
74474: LD_VAR 0 3
74478: PPUSH
74479: CALL_OW 313
74483: PUSH
74484: FOR_IN
74485: IFFALSE 74551
// if k then
74487: LD_VAR 0 4
74491: IFFALSE 74549
// if not k in mc_repair_vehicle [ i ] then
74493: LD_VAR 0 4
74497: PUSH
74498: LD_EXP 72
74502: PUSH
74503: LD_VAR 0 2
74507: ARRAY
74508: IN
74509: NOT
74510: IFFALSE 74549
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
74512: LD_ADDR_EXP 72
74516: PUSH
74517: LD_EXP 72
74521: PPUSH
74522: LD_VAR 0 2
74526: PPUSH
74527: LD_EXP 72
74531: PUSH
74532: LD_VAR 0 2
74536: ARRAY
74537: PUSH
74538: LD_VAR 0 4
74542: UNION
74543: PPUSH
74544: CALL_OW 1
74548: ST_TO_ADDR
74549: GO 74484
74551: POP
74552: POP
74553: GO 74466
74555: POP
74556: POP
// end ; if not mc_repair_vehicle [ i ] then
74557: LD_EXP 72
74561: PUSH
74562: LD_VAR 0 2
74566: ARRAY
74567: NOT
74568: IFFALSE 74572
// continue ;
74570: GO 74077
// for j in mc_repair_vehicle [ i ] do
74572: LD_ADDR_VAR 0 3
74576: PUSH
74577: LD_EXP 72
74581: PUSH
74582: LD_VAR 0 2
74586: ARRAY
74587: PUSH
74588: FOR_IN
74589: IFFALSE 74766
// begin if GetClass ( j ) <> 3 then
74591: LD_VAR 0 3
74595: PPUSH
74596: CALL_OW 257
74600: PUSH
74601: LD_INT 3
74603: NONEQUAL
74604: IFFALSE 74645
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
74606: LD_ADDR_EXP 72
74610: PUSH
74611: LD_EXP 72
74615: PPUSH
74616: LD_VAR 0 2
74620: PPUSH
74621: LD_EXP 72
74625: PUSH
74626: LD_VAR 0 2
74630: ARRAY
74631: PUSH
74632: LD_VAR 0 3
74636: DIFF
74637: PPUSH
74638: CALL_OW 1
74642: ST_TO_ADDR
// continue ;
74643: GO 74588
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
74645: LD_VAR 0 3
74649: PPUSH
74650: CALL_OW 311
74654: NOT
74655: PUSH
74656: LD_VAR 0 3
74660: PUSH
74661: LD_EXP 63
74665: PUSH
74666: LD_VAR 0 2
74670: ARRAY
74671: PUSH
74672: LD_INT 1
74674: ARRAY
74675: IN
74676: NOT
74677: AND
74678: PUSH
74679: LD_VAR 0 3
74683: PUSH
74684: LD_EXP 63
74688: PUSH
74689: LD_VAR 0 2
74693: ARRAY
74694: PUSH
74695: LD_INT 2
74697: ARRAY
74698: IN
74699: NOT
74700: AND
74701: IFFALSE 74764
// begin if IsInUnit ( j ) then
74703: LD_VAR 0 3
74707: PPUSH
74708: CALL_OW 310
74712: IFFALSE 74725
// ComExitBuilding ( j ) else
74714: LD_VAR 0 3
74718: PPUSH
74719: CALL_OW 122
74723: GO 74764
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
74725: LD_VAR 0 3
74729: PPUSH
74730: LD_VAR 0 7
74734: PUSH
74735: LD_INT 1
74737: ARRAY
74738: PPUSH
74739: CALL 54332 0 2
74743: NOT
74744: IFFALSE 74764
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
74746: LD_VAR 0 3
74750: PPUSH
74751: LD_VAR 0 7
74755: PUSH
74756: LD_INT 1
74758: ARRAY
74759: PPUSH
74760: CALL_OW 129
// end ; end ;
74764: GO 74588
74766: POP
74767: POP
// end ;
74768: GO 74077
74770: POP
74771: POP
// end ;
74772: LD_VAR 0 1
74776: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
74777: LD_INT 0
74779: PPUSH
74780: PPUSH
74781: PPUSH
74782: PPUSH
74783: PPUSH
74784: PPUSH
74785: PPUSH
74786: PPUSH
74787: PPUSH
74788: PPUSH
74789: PPUSH
// if not mc_bases then
74790: LD_EXP 60
74794: NOT
74795: IFFALSE 74799
// exit ;
74797: GO 75601
// for i = 1 to mc_bases do
74799: LD_ADDR_VAR 0 2
74803: PUSH
74804: DOUBLE
74805: LD_INT 1
74807: DEC
74808: ST_TO_ADDR
74809: LD_EXP 60
74813: PUSH
74814: FOR_TO
74815: IFFALSE 75599
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
74817: LD_EXP 88
74821: PUSH
74822: LD_VAR 0 2
74826: ARRAY
74827: NOT
74828: PUSH
74829: LD_EXP 63
74833: PUSH
74834: LD_VAR 0 2
74838: ARRAY
74839: PUSH
74840: LD_INT 1
74842: ARRAY
74843: OR
74844: PUSH
74845: LD_EXP 63
74849: PUSH
74850: LD_VAR 0 2
74854: ARRAY
74855: PUSH
74856: LD_INT 2
74858: ARRAY
74859: OR
74860: PUSH
74861: LD_EXP 86
74865: PUSH
74866: LD_VAR 0 2
74870: ARRAY
74871: PPUSH
74872: LD_INT 1
74874: PPUSH
74875: CALL_OW 325
74879: NOT
74880: OR
74881: PUSH
74882: LD_EXP 83
74886: PUSH
74887: LD_VAR 0 2
74891: ARRAY
74892: OR
74893: IFFALSE 74897
// continue ;
74895: GO 74814
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
74897: LD_ADDR_VAR 0 8
74901: PUSH
74902: LD_EXP 60
74906: PUSH
74907: LD_VAR 0 2
74911: ARRAY
74912: PPUSH
74913: LD_INT 25
74915: PUSH
74916: LD_INT 4
74918: PUSH
74919: EMPTY
74920: LIST
74921: LIST
74922: PUSH
74923: LD_INT 50
74925: PUSH
74926: EMPTY
74927: LIST
74928: PUSH
74929: LD_INT 3
74931: PUSH
74932: LD_INT 60
74934: PUSH
74935: EMPTY
74936: LIST
74937: PUSH
74938: EMPTY
74939: LIST
74940: LIST
74941: PUSH
74942: EMPTY
74943: LIST
74944: LIST
74945: LIST
74946: PPUSH
74947: CALL_OW 72
74951: PUSH
74952: LD_EXP 64
74956: PUSH
74957: LD_VAR 0 2
74961: ARRAY
74962: DIFF
74963: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74964: LD_ADDR_VAR 0 9
74968: PUSH
74969: LD_EXP 60
74973: PUSH
74974: LD_VAR 0 2
74978: ARRAY
74979: PPUSH
74980: LD_INT 2
74982: PUSH
74983: LD_INT 30
74985: PUSH
74986: LD_INT 0
74988: PUSH
74989: EMPTY
74990: LIST
74991: LIST
74992: PUSH
74993: LD_INT 30
74995: PUSH
74996: LD_INT 1
74998: PUSH
74999: EMPTY
75000: LIST
75001: LIST
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: LIST
75007: PPUSH
75008: CALL_OW 72
75012: ST_TO_ADDR
// if not tmp or not dep then
75013: LD_VAR 0 8
75017: NOT
75018: PUSH
75019: LD_VAR 0 9
75023: NOT
75024: OR
75025: IFFALSE 75029
// continue ;
75027: GO 74814
// side := GetSide ( tmp [ 1 ] ) ;
75029: LD_ADDR_VAR 0 11
75033: PUSH
75034: LD_VAR 0 8
75038: PUSH
75039: LD_INT 1
75041: ARRAY
75042: PPUSH
75043: CALL_OW 255
75047: ST_TO_ADDR
// dep := dep [ 1 ] ;
75048: LD_ADDR_VAR 0 9
75052: PUSH
75053: LD_VAR 0 9
75057: PUSH
75058: LD_INT 1
75060: ARRAY
75061: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75062: LD_ADDR_VAR 0 7
75066: PUSH
75067: LD_EXP 88
75071: PUSH
75072: LD_VAR 0 2
75076: ARRAY
75077: PPUSH
75078: LD_INT 22
75080: PUSH
75081: LD_INT 0
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: LD_INT 25
75090: PUSH
75091: LD_INT 12
75093: PUSH
75094: EMPTY
75095: LIST
75096: LIST
75097: PUSH
75098: EMPTY
75099: LIST
75100: LIST
75101: PPUSH
75102: CALL_OW 70
75106: PUSH
75107: LD_INT 22
75109: PUSH
75110: LD_INT 0
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 25
75119: PUSH
75120: LD_INT 12
75122: PUSH
75123: EMPTY
75124: LIST
75125: LIST
75126: PUSH
75127: LD_INT 91
75129: PUSH
75130: LD_VAR 0 9
75134: PUSH
75135: LD_INT 20
75137: PUSH
75138: EMPTY
75139: LIST
75140: LIST
75141: LIST
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: LIST
75147: PPUSH
75148: CALL_OW 69
75152: UNION
75153: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75154: LD_ADDR_VAR 0 10
75158: PUSH
75159: LD_EXP 88
75163: PUSH
75164: LD_VAR 0 2
75168: ARRAY
75169: PPUSH
75170: LD_INT 81
75172: PUSH
75173: LD_VAR 0 11
75177: PUSH
75178: EMPTY
75179: LIST
75180: LIST
75181: PPUSH
75182: CALL_OW 70
75186: ST_TO_ADDR
// if not apes or danger_at_area then
75187: LD_VAR 0 7
75191: NOT
75192: PUSH
75193: LD_VAR 0 10
75197: OR
75198: IFFALSE 75248
// begin if mc_taming [ i ] then
75200: LD_EXP 91
75204: PUSH
75205: LD_VAR 0 2
75209: ARRAY
75210: IFFALSE 75246
// begin MC_Reset ( i , 121 ) ;
75212: LD_VAR 0 2
75216: PPUSH
75217: LD_INT 121
75219: PPUSH
75220: CALL 60234 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75224: LD_ADDR_EXP 91
75228: PUSH
75229: LD_EXP 91
75233: PPUSH
75234: LD_VAR 0 2
75238: PPUSH
75239: EMPTY
75240: PPUSH
75241: CALL_OW 1
75245: ST_TO_ADDR
// end ; continue ;
75246: GO 74814
// end ; for j in tmp do
75248: LD_ADDR_VAR 0 3
75252: PUSH
75253: LD_VAR 0 8
75257: PUSH
75258: FOR_IN
75259: IFFALSE 75595
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75261: LD_VAR 0 3
75265: PUSH
75266: LD_EXP 91
75270: PUSH
75271: LD_VAR 0 2
75275: ARRAY
75276: IN
75277: NOT
75278: PUSH
75279: LD_EXP 91
75283: PUSH
75284: LD_VAR 0 2
75288: ARRAY
75289: PUSH
75290: LD_INT 3
75292: LESS
75293: AND
75294: IFFALSE 75352
// begin SetTag ( j , 121 ) ;
75296: LD_VAR 0 3
75300: PPUSH
75301: LD_INT 121
75303: PPUSH
75304: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75308: LD_ADDR_EXP 91
75312: PUSH
75313: LD_EXP 91
75317: PPUSH
75318: LD_VAR 0 2
75322: PUSH
75323: LD_EXP 91
75327: PUSH
75328: LD_VAR 0 2
75332: ARRAY
75333: PUSH
75334: LD_INT 1
75336: PLUS
75337: PUSH
75338: EMPTY
75339: LIST
75340: LIST
75341: PPUSH
75342: LD_VAR 0 3
75346: PPUSH
75347: CALL 20003 0 3
75351: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75352: LD_VAR 0 3
75356: PUSH
75357: LD_EXP 91
75361: PUSH
75362: LD_VAR 0 2
75366: ARRAY
75367: IN
75368: IFFALSE 75593
// begin if GetClass ( j ) <> 4 then
75370: LD_VAR 0 3
75374: PPUSH
75375: CALL_OW 257
75379: PUSH
75380: LD_INT 4
75382: NONEQUAL
75383: IFFALSE 75436
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75385: LD_ADDR_EXP 91
75389: PUSH
75390: LD_EXP 91
75394: PPUSH
75395: LD_VAR 0 2
75399: PPUSH
75400: LD_EXP 91
75404: PUSH
75405: LD_VAR 0 2
75409: ARRAY
75410: PUSH
75411: LD_VAR 0 3
75415: DIFF
75416: PPUSH
75417: CALL_OW 1
75421: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75422: LD_VAR 0 3
75426: PPUSH
75427: LD_INT 0
75429: PPUSH
75430: CALL_OW 109
// continue ;
75434: GO 75258
// end ; if IsInUnit ( j ) then
75436: LD_VAR 0 3
75440: PPUSH
75441: CALL_OW 310
75445: IFFALSE 75456
// ComExitBuilding ( j ) ;
75447: LD_VAR 0 3
75451: PPUSH
75452: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75456: LD_ADDR_VAR 0 6
75460: PUSH
75461: LD_VAR 0 7
75465: PPUSH
75466: LD_VAR 0 3
75470: PPUSH
75471: CALL_OW 74
75475: ST_TO_ADDR
// if not ape then
75476: LD_VAR 0 6
75480: NOT
75481: IFFALSE 75485
// break ;
75483: GO 75595
// x := GetX ( ape ) ;
75485: LD_ADDR_VAR 0 4
75489: PUSH
75490: LD_VAR 0 6
75494: PPUSH
75495: CALL_OW 250
75499: ST_TO_ADDR
// y := GetY ( ape ) ;
75500: LD_ADDR_VAR 0 5
75504: PUSH
75505: LD_VAR 0 6
75509: PPUSH
75510: CALL_OW 251
75514: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75515: LD_VAR 0 4
75519: PPUSH
75520: LD_VAR 0 5
75524: PPUSH
75525: CALL_OW 488
75529: NOT
75530: PUSH
75531: LD_VAR 0 11
75535: PPUSH
75536: LD_VAR 0 4
75540: PPUSH
75541: LD_VAR 0 5
75545: PPUSH
75546: LD_INT 20
75548: PPUSH
75549: CALL 20899 0 4
75553: PUSH
75554: LD_INT 4
75556: ARRAY
75557: OR
75558: IFFALSE 75562
// break ;
75560: GO 75595
// if not HasTask ( j ) then
75562: LD_VAR 0 3
75566: PPUSH
75567: CALL_OW 314
75571: NOT
75572: IFFALSE 75593
// ComTameXY ( j , x , y ) ;
75574: LD_VAR 0 3
75578: PPUSH
75579: LD_VAR 0 4
75583: PPUSH
75584: LD_VAR 0 5
75588: PPUSH
75589: CALL_OW 131
// end ; end ;
75593: GO 75258
75595: POP
75596: POP
// end ;
75597: GO 74814
75599: POP
75600: POP
// end ;
75601: LD_VAR 0 1
75605: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
75606: LD_INT 0
75608: PPUSH
75609: PPUSH
75610: PPUSH
75611: PPUSH
75612: PPUSH
75613: PPUSH
75614: PPUSH
75615: PPUSH
// if not mc_bases then
75616: LD_EXP 60
75620: NOT
75621: IFFALSE 75625
// exit ;
75623: GO 76251
// for i = 1 to mc_bases do
75625: LD_ADDR_VAR 0 2
75629: PUSH
75630: DOUBLE
75631: LD_INT 1
75633: DEC
75634: ST_TO_ADDR
75635: LD_EXP 60
75639: PUSH
75640: FOR_TO
75641: IFFALSE 76249
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
75643: LD_EXP 89
75647: PUSH
75648: LD_VAR 0 2
75652: ARRAY
75653: NOT
75654: PUSH
75655: LD_EXP 89
75659: PUSH
75660: LD_VAR 0 2
75664: ARRAY
75665: PPUSH
75666: LD_INT 25
75668: PUSH
75669: LD_INT 12
75671: PUSH
75672: EMPTY
75673: LIST
75674: LIST
75675: PPUSH
75676: CALL_OW 72
75680: NOT
75681: OR
75682: IFFALSE 75686
// continue ;
75684: GO 75640
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
75686: LD_ADDR_VAR 0 5
75690: PUSH
75691: LD_EXP 89
75695: PUSH
75696: LD_VAR 0 2
75700: ARRAY
75701: PUSH
75702: LD_INT 1
75704: ARRAY
75705: PPUSH
75706: CALL_OW 255
75710: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
75711: LD_VAR 0 5
75715: PPUSH
75716: LD_INT 2
75718: PPUSH
75719: CALL_OW 325
75723: IFFALSE 75976
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75725: LD_ADDR_VAR 0 4
75729: PUSH
75730: LD_EXP 89
75734: PUSH
75735: LD_VAR 0 2
75739: ARRAY
75740: PPUSH
75741: LD_INT 25
75743: PUSH
75744: LD_INT 16
75746: PUSH
75747: EMPTY
75748: LIST
75749: LIST
75750: PPUSH
75751: CALL_OW 72
75755: ST_TO_ADDR
// if tmp < 6 then
75756: LD_VAR 0 4
75760: PUSH
75761: LD_INT 6
75763: LESS
75764: IFFALSE 75976
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75766: LD_ADDR_VAR 0 6
75770: PUSH
75771: LD_EXP 60
75775: PUSH
75776: LD_VAR 0 2
75780: ARRAY
75781: PPUSH
75782: LD_INT 2
75784: PUSH
75785: LD_INT 30
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 30
75797: PUSH
75798: LD_INT 1
75800: PUSH
75801: EMPTY
75802: LIST
75803: LIST
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: LIST
75809: PPUSH
75810: CALL_OW 72
75814: ST_TO_ADDR
// if depot then
75815: LD_VAR 0 6
75819: IFFALSE 75976
// begin selected := 0 ;
75821: LD_ADDR_VAR 0 7
75825: PUSH
75826: LD_INT 0
75828: ST_TO_ADDR
// for j in depot do
75829: LD_ADDR_VAR 0 3
75833: PUSH
75834: LD_VAR 0 6
75838: PUSH
75839: FOR_IN
75840: IFFALSE 75871
// begin if UnitsInside ( j ) < 6 then
75842: LD_VAR 0 3
75846: PPUSH
75847: CALL_OW 313
75851: PUSH
75852: LD_INT 6
75854: LESS
75855: IFFALSE 75869
// begin selected := j ;
75857: LD_ADDR_VAR 0 7
75861: PUSH
75862: LD_VAR 0 3
75866: ST_TO_ADDR
// break ;
75867: GO 75871
// end ; end ;
75869: GO 75839
75871: POP
75872: POP
// if selected then
75873: LD_VAR 0 7
75877: IFFALSE 75976
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
75879: LD_ADDR_VAR 0 3
75883: PUSH
75884: LD_EXP 89
75888: PUSH
75889: LD_VAR 0 2
75893: ARRAY
75894: PPUSH
75895: LD_INT 25
75897: PUSH
75898: LD_INT 12
75900: PUSH
75901: EMPTY
75902: LIST
75903: LIST
75904: PPUSH
75905: CALL_OW 72
75909: PUSH
75910: FOR_IN
75911: IFFALSE 75974
// if not HasTask ( j ) then
75913: LD_VAR 0 3
75917: PPUSH
75918: CALL_OW 314
75922: NOT
75923: IFFALSE 75972
// begin if not IsInUnit ( j ) then
75925: LD_VAR 0 3
75929: PPUSH
75930: CALL_OW 310
75934: NOT
75935: IFFALSE 75951
// ComEnterUnit ( j , selected ) ;
75937: LD_VAR 0 3
75941: PPUSH
75942: LD_VAR 0 7
75946: PPUSH
75947: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
75951: LD_VAR 0 3
75955: PPUSH
75956: LD_INT 16
75958: PPUSH
75959: CALL_OW 183
// AddComExitBuilding ( j ) ;
75963: LD_VAR 0 3
75967: PPUSH
75968: CALL_OW 182
// end ;
75972: GO 75910
75974: POP
75975: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
75976: LD_VAR 0 5
75980: PPUSH
75981: LD_INT 11
75983: PPUSH
75984: CALL_OW 325
75988: IFFALSE 76247
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
75990: LD_ADDR_VAR 0 4
75994: PUSH
75995: LD_EXP 89
75999: PUSH
76000: LD_VAR 0 2
76004: ARRAY
76005: PPUSH
76006: LD_INT 25
76008: PUSH
76009: LD_INT 16
76011: PUSH
76012: EMPTY
76013: LIST
76014: LIST
76015: PPUSH
76016: CALL_OW 72
76020: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76021: LD_VAR 0 4
76025: PUSH
76026: LD_INT 6
76028: GREATEREQUAL
76029: PUSH
76030: LD_VAR 0 5
76034: PPUSH
76035: LD_INT 2
76037: PPUSH
76038: CALL_OW 325
76042: NOT
76043: OR
76044: IFFALSE 76247
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76046: LD_ADDR_VAR 0 8
76050: PUSH
76051: LD_EXP 60
76055: PUSH
76056: LD_VAR 0 2
76060: ARRAY
76061: PPUSH
76062: LD_INT 2
76064: PUSH
76065: LD_INT 30
76067: PUSH
76068: LD_INT 4
76070: PUSH
76071: EMPTY
76072: LIST
76073: LIST
76074: PUSH
76075: LD_INT 30
76077: PUSH
76078: LD_INT 5
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: EMPTY
76086: LIST
76087: LIST
76088: LIST
76089: PPUSH
76090: CALL_OW 72
76094: ST_TO_ADDR
// if barracks then
76095: LD_VAR 0 8
76099: IFFALSE 76247
// begin selected := 0 ;
76101: LD_ADDR_VAR 0 7
76105: PUSH
76106: LD_INT 0
76108: ST_TO_ADDR
// for j in barracks do
76109: LD_ADDR_VAR 0 3
76113: PUSH
76114: LD_VAR 0 8
76118: PUSH
76119: FOR_IN
76120: IFFALSE 76151
// begin if UnitsInside ( j ) < 6 then
76122: LD_VAR 0 3
76126: PPUSH
76127: CALL_OW 313
76131: PUSH
76132: LD_INT 6
76134: LESS
76135: IFFALSE 76149
// begin selected := j ;
76137: LD_ADDR_VAR 0 7
76141: PUSH
76142: LD_VAR 0 3
76146: ST_TO_ADDR
// break ;
76147: GO 76151
// end ; end ;
76149: GO 76119
76151: POP
76152: POP
// if selected then
76153: LD_VAR 0 7
76157: IFFALSE 76247
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76159: LD_ADDR_VAR 0 3
76163: PUSH
76164: LD_EXP 89
76168: PUSH
76169: LD_VAR 0 2
76173: ARRAY
76174: PPUSH
76175: LD_INT 25
76177: PUSH
76178: LD_INT 12
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PPUSH
76185: CALL_OW 72
76189: PUSH
76190: FOR_IN
76191: IFFALSE 76245
// if not IsInUnit ( j ) and not HasTask ( j ) then
76193: LD_VAR 0 3
76197: PPUSH
76198: CALL_OW 310
76202: NOT
76203: PUSH
76204: LD_VAR 0 3
76208: PPUSH
76209: CALL_OW 314
76213: NOT
76214: AND
76215: IFFALSE 76243
// begin ComEnterUnit ( j , selected ) ;
76217: LD_VAR 0 3
76221: PPUSH
76222: LD_VAR 0 7
76226: PPUSH
76227: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76231: LD_VAR 0 3
76235: PPUSH
76236: LD_INT 15
76238: PPUSH
76239: CALL_OW 183
// end ;
76243: GO 76190
76245: POP
76246: POP
// end ; end ; end ; end ; end ;
76247: GO 75640
76249: POP
76250: POP
// end ;
76251: LD_VAR 0 1
76255: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76256: LD_INT 0
76258: PPUSH
76259: PPUSH
76260: PPUSH
76261: PPUSH
// if not mc_bases then
76262: LD_EXP 60
76266: NOT
76267: IFFALSE 76271
// exit ;
76269: GO 76449
// for i = 1 to mc_bases do
76271: LD_ADDR_VAR 0 2
76275: PUSH
76276: DOUBLE
76277: LD_INT 1
76279: DEC
76280: ST_TO_ADDR
76281: LD_EXP 60
76285: PUSH
76286: FOR_TO
76287: IFFALSE 76447
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76289: LD_ADDR_VAR 0 4
76293: PUSH
76294: LD_EXP 60
76298: PUSH
76299: LD_VAR 0 2
76303: ARRAY
76304: PPUSH
76305: LD_INT 25
76307: PUSH
76308: LD_INT 9
76310: PUSH
76311: EMPTY
76312: LIST
76313: LIST
76314: PPUSH
76315: CALL_OW 72
76319: ST_TO_ADDR
// if not tmp then
76320: LD_VAR 0 4
76324: NOT
76325: IFFALSE 76329
// continue ;
76327: GO 76286
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76329: LD_EXP 86
76333: PUSH
76334: LD_VAR 0 2
76338: ARRAY
76339: PPUSH
76340: LD_INT 29
76342: PPUSH
76343: CALL_OW 325
76347: NOT
76348: PUSH
76349: LD_EXP 86
76353: PUSH
76354: LD_VAR 0 2
76358: ARRAY
76359: PPUSH
76360: LD_INT 28
76362: PPUSH
76363: CALL_OW 325
76367: NOT
76368: AND
76369: IFFALSE 76373
// continue ;
76371: GO 76286
// for j in tmp do
76373: LD_ADDR_VAR 0 3
76377: PUSH
76378: LD_VAR 0 4
76382: PUSH
76383: FOR_IN
76384: IFFALSE 76443
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76386: LD_VAR 0 3
76390: PUSH
76391: LD_EXP 63
76395: PUSH
76396: LD_VAR 0 2
76400: ARRAY
76401: PUSH
76402: LD_INT 1
76404: ARRAY
76405: IN
76406: NOT
76407: PUSH
76408: LD_VAR 0 3
76412: PUSH
76413: LD_EXP 63
76417: PUSH
76418: LD_VAR 0 2
76422: ARRAY
76423: PUSH
76424: LD_INT 2
76426: ARRAY
76427: IN
76428: NOT
76429: AND
76430: IFFALSE 76441
// ComSpaceTimeShoot ( j ) ;
76432: LD_VAR 0 3
76436: PPUSH
76437: CALL 15811 0 1
76441: GO 76383
76443: POP
76444: POP
// end ;
76445: GO 76286
76447: POP
76448: POP
// end ;
76449: LD_VAR 0 1
76453: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76454: LD_INT 0
76456: PPUSH
76457: PPUSH
76458: PPUSH
76459: PPUSH
76460: PPUSH
76461: PPUSH
76462: PPUSH
76463: PPUSH
76464: PPUSH
// if not mc_bases then
76465: LD_EXP 60
76469: NOT
76470: IFFALSE 76474
// exit ;
76472: GO 77096
// for i = 1 to mc_bases do
76474: LD_ADDR_VAR 0 2
76478: PUSH
76479: DOUBLE
76480: LD_INT 1
76482: DEC
76483: ST_TO_ADDR
76484: LD_EXP 60
76488: PUSH
76489: FOR_TO
76490: IFFALSE 77094
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76492: LD_EXP 95
76496: PUSH
76497: LD_VAR 0 2
76501: ARRAY
76502: NOT
76503: PUSH
76504: LD_INT 38
76506: PPUSH
76507: LD_EXP 86
76511: PUSH
76512: LD_VAR 0 2
76516: ARRAY
76517: PPUSH
76518: CALL_OW 321
76522: PUSH
76523: LD_INT 2
76525: NONEQUAL
76526: OR
76527: IFFALSE 76531
// continue ;
76529: GO 76489
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
76531: LD_ADDR_VAR 0 8
76535: PUSH
76536: LD_EXP 60
76540: PUSH
76541: LD_VAR 0 2
76545: ARRAY
76546: PPUSH
76547: LD_INT 30
76549: PUSH
76550: LD_INT 34
76552: PUSH
76553: EMPTY
76554: LIST
76555: LIST
76556: PPUSH
76557: CALL_OW 72
76561: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
76562: LD_ADDR_VAR 0 9
76566: PUSH
76567: LD_EXP 60
76571: PUSH
76572: LD_VAR 0 2
76576: ARRAY
76577: PPUSH
76578: LD_INT 25
76580: PUSH
76581: LD_INT 4
76583: PUSH
76584: EMPTY
76585: LIST
76586: LIST
76587: PPUSH
76588: CALL_OW 72
76592: PPUSH
76593: LD_INT 0
76595: PPUSH
76596: CALL 49839 0 2
76600: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
76601: LD_VAR 0 9
76605: NOT
76606: PUSH
76607: LD_VAR 0 8
76611: NOT
76612: OR
76613: PUSH
76614: LD_EXP 60
76618: PUSH
76619: LD_VAR 0 2
76623: ARRAY
76624: PPUSH
76625: LD_INT 124
76627: PPUSH
76628: CALL 49839 0 2
76632: OR
76633: IFFALSE 76637
// continue ;
76635: GO 76489
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
76637: LD_EXP 96
76641: PUSH
76642: LD_VAR 0 2
76646: ARRAY
76647: PUSH
76648: LD_EXP 95
76652: PUSH
76653: LD_VAR 0 2
76657: ARRAY
76658: LESS
76659: PUSH
76660: LD_EXP 96
76664: PUSH
76665: LD_VAR 0 2
76669: ARRAY
76670: PUSH
76671: LD_VAR 0 8
76675: LESS
76676: AND
76677: IFFALSE 77092
// begin tmp := sci [ 1 ] ;
76679: LD_ADDR_VAR 0 7
76683: PUSH
76684: LD_VAR 0 9
76688: PUSH
76689: LD_INT 1
76691: ARRAY
76692: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
76693: LD_VAR 0 7
76697: PPUSH
76698: LD_INT 124
76700: PPUSH
76701: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
76705: LD_ADDR_VAR 0 3
76709: PUSH
76710: DOUBLE
76711: LD_EXP 95
76715: PUSH
76716: LD_VAR 0 2
76720: ARRAY
76721: INC
76722: ST_TO_ADDR
76723: LD_EXP 95
76727: PUSH
76728: LD_VAR 0 2
76732: ARRAY
76733: PUSH
76734: FOR_DOWNTO
76735: IFFALSE 77078
// begin if IsInUnit ( tmp ) then
76737: LD_VAR 0 7
76741: PPUSH
76742: CALL_OW 310
76746: IFFALSE 76757
// ComExitBuilding ( tmp ) ;
76748: LD_VAR 0 7
76752: PPUSH
76753: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
76757: LD_INT 35
76759: PPUSH
76760: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
76764: LD_VAR 0 7
76768: PPUSH
76769: CALL_OW 310
76773: NOT
76774: PUSH
76775: LD_VAR 0 7
76779: PPUSH
76780: CALL_OW 314
76784: NOT
76785: AND
76786: IFFALSE 76757
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
76788: LD_ADDR_VAR 0 6
76792: PUSH
76793: LD_VAR 0 7
76797: PPUSH
76798: CALL_OW 250
76802: PUSH
76803: LD_VAR 0 7
76807: PPUSH
76808: CALL_OW 251
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
76817: LD_INT 35
76819: PPUSH
76820: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
76824: LD_ADDR_VAR 0 4
76828: PUSH
76829: LD_EXP 95
76833: PUSH
76834: LD_VAR 0 2
76838: ARRAY
76839: PUSH
76840: LD_VAR 0 3
76844: ARRAY
76845: PUSH
76846: LD_INT 1
76848: ARRAY
76849: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
76850: LD_ADDR_VAR 0 5
76854: PUSH
76855: LD_EXP 95
76859: PUSH
76860: LD_VAR 0 2
76864: ARRAY
76865: PUSH
76866: LD_VAR 0 3
76870: ARRAY
76871: PUSH
76872: LD_INT 2
76874: ARRAY
76875: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
76876: LD_VAR 0 7
76880: PPUSH
76881: LD_INT 10
76883: PPUSH
76884: CALL 22602 0 2
76888: PUSH
76889: LD_INT 4
76891: ARRAY
76892: IFFALSE 76930
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
76894: LD_VAR 0 7
76898: PPUSH
76899: LD_VAR 0 6
76903: PUSH
76904: LD_INT 1
76906: ARRAY
76907: PPUSH
76908: LD_VAR 0 6
76912: PUSH
76913: LD_INT 2
76915: ARRAY
76916: PPUSH
76917: CALL_OW 111
// wait ( 0 0$10 ) ;
76921: LD_INT 350
76923: PPUSH
76924: CALL_OW 67
// end else
76928: GO 76956
// begin ComMoveXY ( tmp , x , y ) ;
76930: LD_VAR 0 7
76934: PPUSH
76935: LD_VAR 0 4
76939: PPUSH
76940: LD_VAR 0 5
76944: PPUSH
76945: CALL_OW 111
// wait ( 0 0$3 ) ;
76949: LD_INT 105
76951: PPUSH
76952: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
76956: LD_VAR 0 7
76960: PPUSH
76961: LD_VAR 0 4
76965: PPUSH
76966: LD_VAR 0 5
76970: PPUSH
76971: CALL_OW 307
76975: IFFALSE 76817
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
76977: LD_VAR 0 7
76981: PPUSH
76982: LD_VAR 0 4
76986: PPUSH
76987: LD_VAR 0 5
76991: PPUSH
76992: LD_VAR 0 8
76996: PUSH
76997: LD_VAR 0 3
77001: ARRAY
77002: PPUSH
77003: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77007: LD_INT 35
77009: PPUSH
77010: CALL_OW 67
// until not HasTask ( tmp ) ;
77014: LD_VAR 0 7
77018: PPUSH
77019: CALL_OW 314
77023: NOT
77024: IFFALSE 77007
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77026: LD_ADDR_EXP 96
77030: PUSH
77031: LD_EXP 96
77035: PPUSH
77036: LD_VAR 0 2
77040: PUSH
77041: LD_EXP 96
77045: PUSH
77046: LD_VAR 0 2
77050: ARRAY
77051: PUSH
77052: LD_INT 1
77054: PLUS
77055: PUSH
77056: EMPTY
77057: LIST
77058: LIST
77059: PPUSH
77060: LD_VAR 0 8
77064: PUSH
77065: LD_VAR 0 3
77069: ARRAY
77070: PPUSH
77071: CALL 20003 0 3
77075: ST_TO_ADDR
// end ;
77076: GO 76734
77078: POP
77079: POP
// MC_Reset ( i , 124 ) ;
77080: LD_VAR 0 2
77084: PPUSH
77085: LD_INT 124
77087: PPUSH
77088: CALL 60234 0 2
// end ; end ;
77092: GO 76489
77094: POP
77095: POP
// end ;
77096: LD_VAR 0 1
77100: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77101: LD_INT 0
77103: PPUSH
77104: PPUSH
77105: PPUSH
// if not mc_bases then
77106: LD_EXP 60
77110: NOT
77111: IFFALSE 77115
// exit ;
77113: GO 77721
// for i = 1 to mc_bases do
77115: LD_ADDR_VAR 0 2
77119: PUSH
77120: DOUBLE
77121: LD_INT 1
77123: DEC
77124: ST_TO_ADDR
77125: LD_EXP 60
77129: PUSH
77130: FOR_TO
77131: IFFALSE 77719
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77133: LD_ADDR_VAR 0 3
77137: PUSH
77138: LD_EXP 60
77142: PUSH
77143: LD_VAR 0 2
77147: ARRAY
77148: PPUSH
77149: LD_INT 25
77151: PUSH
77152: LD_INT 4
77154: PUSH
77155: EMPTY
77156: LIST
77157: LIST
77158: PPUSH
77159: CALL_OW 72
77163: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77164: LD_VAR 0 3
77168: NOT
77169: PUSH
77170: LD_EXP 97
77174: PUSH
77175: LD_VAR 0 2
77179: ARRAY
77180: NOT
77181: OR
77182: PUSH
77183: LD_EXP 60
77187: PUSH
77188: LD_VAR 0 2
77192: ARRAY
77193: PPUSH
77194: LD_INT 2
77196: PUSH
77197: LD_INT 30
77199: PUSH
77200: LD_INT 0
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PUSH
77207: LD_INT 30
77209: PUSH
77210: LD_INT 1
77212: PUSH
77213: EMPTY
77214: LIST
77215: LIST
77216: PUSH
77217: EMPTY
77218: LIST
77219: LIST
77220: LIST
77221: PPUSH
77222: CALL_OW 72
77226: NOT
77227: OR
77228: IFFALSE 77278
// begin if mc_deposits_finder [ i ] then
77230: LD_EXP 98
77234: PUSH
77235: LD_VAR 0 2
77239: ARRAY
77240: IFFALSE 77276
// begin MC_Reset ( i , 125 ) ;
77242: LD_VAR 0 2
77246: PPUSH
77247: LD_INT 125
77249: PPUSH
77250: CALL 60234 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77254: LD_ADDR_EXP 98
77258: PUSH
77259: LD_EXP 98
77263: PPUSH
77264: LD_VAR 0 2
77268: PPUSH
77269: EMPTY
77270: PPUSH
77271: CALL_OW 1
77275: ST_TO_ADDR
// end ; continue ;
77276: GO 77130
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77278: LD_EXP 97
77282: PUSH
77283: LD_VAR 0 2
77287: ARRAY
77288: PUSH
77289: LD_INT 1
77291: ARRAY
77292: PUSH
77293: LD_INT 3
77295: ARRAY
77296: PUSH
77297: LD_INT 1
77299: EQUAL
77300: PUSH
77301: LD_INT 20
77303: PPUSH
77304: LD_EXP 86
77308: PUSH
77309: LD_VAR 0 2
77313: ARRAY
77314: PPUSH
77315: CALL_OW 321
77319: PUSH
77320: LD_INT 2
77322: NONEQUAL
77323: AND
77324: IFFALSE 77374
// begin if mc_deposits_finder [ i ] then
77326: LD_EXP 98
77330: PUSH
77331: LD_VAR 0 2
77335: ARRAY
77336: IFFALSE 77372
// begin MC_Reset ( i , 125 ) ;
77338: LD_VAR 0 2
77342: PPUSH
77343: LD_INT 125
77345: PPUSH
77346: CALL 60234 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77350: LD_ADDR_EXP 98
77354: PUSH
77355: LD_EXP 98
77359: PPUSH
77360: LD_VAR 0 2
77364: PPUSH
77365: EMPTY
77366: PPUSH
77367: CALL_OW 1
77371: ST_TO_ADDR
// end ; continue ;
77372: GO 77130
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77374: LD_EXP 97
77378: PUSH
77379: LD_VAR 0 2
77383: ARRAY
77384: PUSH
77385: LD_INT 1
77387: ARRAY
77388: PUSH
77389: LD_INT 1
77391: ARRAY
77392: PPUSH
77393: LD_EXP 97
77397: PUSH
77398: LD_VAR 0 2
77402: ARRAY
77403: PUSH
77404: LD_INT 1
77406: ARRAY
77407: PUSH
77408: LD_INT 2
77410: ARRAY
77411: PPUSH
77412: LD_EXP 86
77416: PUSH
77417: LD_VAR 0 2
77421: ARRAY
77422: PPUSH
77423: CALL_OW 440
77427: IFFALSE 77470
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77429: LD_ADDR_EXP 97
77433: PUSH
77434: LD_EXP 97
77438: PPUSH
77439: LD_VAR 0 2
77443: PPUSH
77444: LD_EXP 97
77448: PUSH
77449: LD_VAR 0 2
77453: ARRAY
77454: PPUSH
77455: LD_INT 1
77457: PPUSH
77458: CALL_OW 3
77462: PPUSH
77463: CALL_OW 1
77467: ST_TO_ADDR
77468: GO 77717
// begin if not mc_deposits_finder [ i ] then
77470: LD_EXP 98
77474: PUSH
77475: LD_VAR 0 2
77479: ARRAY
77480: NOT
77481: IFFALSE 77533
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77483: LD_ADDR_EXP 98
77487: PUSH
77488: LD_EXP 98
77492: PPUSH
77493: LD_VAR 0 2
77497: PPUSH
77498: LD_VAR 0 3
77502: PUSH
77503: LD_INT 1
77505: ARRAY
77506: PUSH
77507: EMPTY
77508: LIST
77509: PPUSH
77510: CALL_OW 1
77514: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77515: LD_VAR 0 3
77519: PUSH
77520: LD_INT 1
77522: ARRAY
77523: PPUSH
77524: LD_INT 125
77526: PPUSH
77527: CALL_OW 109
// end else
77531: GO 77717
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
77533: LD_EXP 98
77537: PUSH
77538: LD_VAR 0 2
77542: ARRAY
77543: PUSH
77544: LD_INT 1
77546: ARRAY
77547: PPUSH
77548: CALL_OW 310
77552: IFFALSE 77575
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
77554: LD_EXP 98
77558: PUSH
77559: LD_VAR 0 2
77563: ARRAY
77564: PUSH
77565: LD_INT 1
77567: ARRAY
77568: PPUSH
77569: CALL_OW 122
77573: GO 77717
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
77575: LD_EXP 98
77579: PUSH
77580: LD_VAR 0 2
77584: ARRAY
77585: PUSH
77586: LD_INT 1
77588: ARRAY
77589: PPUSH
77590: CALL_OW 314
77594: NOT
77595: PUSH
77596: LD_EXP 98
77600: PUSH
77601: LD_VAR 0 2
77605: ARRAY
77606: PUSH
77607: LD_INT 1
77609: ARRAY
77610: PPUSH
77611: LD_EXP 97
77615: PUSH
77616: LD_VAR 0 2
77620: ARRAY
77621: PUSH
77622: LD_INT 1
77624: ARRAY
77625: PUSH
77626: LD_INT 1
77628: ARRAY
77629: PPUSH
77630: LD_EXP 97
77634: PUSH
77635: LD_VAR 0 2
77639: ARRAY
77640: PUSH
77641: LD_INT 1
77643: ARRAY
77644: PUSH
77645: LD_INT 2
77647: ARRAY
77648: PPUSH
77649: CALL_OW 297
77653: PUSH
77654: LD_INT 6
77656: GREATER
77657: AND
77658: IFFALSE 77717
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
77660: LD_EXP 98
77664: PUSH
77665: LD_VAR 0 2
77669: ARRAY
77670: PUSH
77671: LD_INT 1
77673: ARRAY
77674: PPUSH
77675: LD_EXP 97
77679: PUSH
77680: LD_VAR 0 2
77684: ARRAY
77685: PUSH
77686: LD_INT 1
77688: ARRAY
77689: PUSH
77690: LD_INT 1
77692: ARRAY
77693: PPUSH
77694: LD_EXP 97
77698: PUSH
77699: LD_VAR 0 2
77703: ARRAY
77704: PUSH
77705: LD_INT 1
77707: ARRAY
77708: PUSH
77709: LD_INT 2
77711: ARRAY
77712: PPUSH
77713: CALL_OW 111
// end ; end ; end ;
77717: GO 77130
77719: POP
77720: POP
// end ;
77721: LD_VAR 0 1
77725: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
77726: LD_INT 0
77728: PPUSH
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
77734: PPUSH
77735: PPUSH
77736: PPUSH
77737: PPUSH
77738: PPUSH
// if not mc_bases then
77739: LD_EXP 60
77743: NOT
77744: IFFALSE 77748
// exit ;
77746: GO 78688
// for i = 1 to mc_bases do
77748: LD_ADDR_VAR 0 2
77752: PUSH
77753: DOUBLE
77754: LD_INT 1
77756: DEC
77757: ST_TO_ADDR
77758: LD_EXP 60
77762: PUSH
77763: FOR_TO
77764: IFFALSE 78686
// begin if not mc_bases [ i ] or mc_scan [ i ] then
77766: LD_EXP 60
77770: PUSH
77771: LD_VAR 0 2
77775: ARRAY
77776: NOT
77777: PUSH
77778: LD_EXP 83
77782: PUSH
77783: LD_VAR 0 2
77787: ARRAY
77788: OR
77789: IFFALSE 77793
// continue ;
77791: GO 77763
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
77793: LD_ADDR_VAR 0 7
77797: PUSH
77798: LD_EXP 60
77802: PUSH
77803: LD_VAR 0 2
77807: ARRAY
77808: PUSH
77809: LD_INT 1
77811: ARRAY
77812: PPUSH
77813: CALL_OW 248
77817: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
77818: LD_VAR 0 7
77822: PUSH
77823: LD_INT 3
77825: EQUAL
77826: PUSH
77827: LD_EXP 79
77831: PUSH
77832: LD_VAR 0 2
77836: ARRAY
77837: PUSH
77838: LD_EXP 82
77842: PUSH
77843: LD_VAR 0 2
77847: ARRAY
77848: UNION
77849: PPUSH
77850: LD_INT 33
77852: PUSH
77853: LD_INT 2
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PPUSH
77860: CALL_OW 72
77864: NOT
77865: OR
77866: IFFALSE 77870
// continue ;
77868: GO 77763
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
77870: LD_ADDR_VAR 0 9
77874: PUSH
77875: LD_EXP 60
77879: PUSH
77880: LD_VAR 0 2
77884: ARRAY
77885: PPUSH
77886: LD_INT 30
77888: PUSH
77889: LD_INT 36
77891: PUSH
77892: EMPTY
77893: LIST
77894: LIST
77895: PPUSH
77896: CALL_OW 72
77900: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
77901: LD_ADDR_VAR 0 10
77905: PUSH
77906: LD_EXP 79
77910: PUSH
77911: LD_VAR 0 2
77915: ARRAY
77916: PPUSH
77917: LD_INT 34
77919: PUSH
77920: LD_INT 31
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PPUSH
77927: CALL_OW 72
77931: ST_TO_ADDR
// if not cts and not mcts then
77932: LD_VAR 0 9
77936: NOT
77937: PUSH
77938: LD_VAR 0 10
77942: NOT
77943: AND
77944: IFFALSE 77948
// continue ;
77946: GO 77763
// x := cts ;
77948: LD_ADDR_VAR 0 11
77952: PUSH
77953: LD_VAR 0 9
77957: ST_TO_ADDR
// if not x then
77958: LD_VAR 0 11
77962: NOT
77963: IFFALSE 77975
// x := mcts ;
77965: LD_ADDR_VAR 0 11
77969: PUSH
77970: LD_VAR 0 10
77974: ST_TO_ADDR
// if not x then
77975: LD_VAR 0 11
77979: NOT
77980: IFFALSE 77984
// continue ;
77982: GO 77763
// if mc_remote_driver [ i ] then
77984: LD_EXP 100
77988: PUSH
77989: LD_VAR 0 2
77993: ARRAY
77994: IFFALSE 78381
// for j in mc_remote_driver [ i ] do
77996: LD_ADDR_VAR 0 3
78000: PUSH
78001: LD_EXP 100
78005: PUSH
78006: LD_VAR 0 2
78010: ARRAY
78011: PUSH
78012: FOR_IN
78013: IFFALSE 78379
// begin if GetClass ( j ) <> 3 then
78015: LD_VAR 0 3
78019: PPUSH
78020: CALL_OW 257
78024: PUSH
78025: LD_INT 3
78027: NONEQUAL
78028: IFFALSE 78081
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78030: LD_ADDR_EXP 100
78034: PUSH
78035: LD_EXP 100
78039: PPUSH
78040: LD_VAR 0 2
78044: PPUSH
78045: LD_EXP 100
78049: PUSH
78050: LD_VAR 0 2
78054: ARRAY
78055: PUSH
78056: LD_VAR 0 3
78060: DIFF
78061: PPUSH
78062: CALL_OW 1
78066: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78067: LD_VAR 0 3
78071: PPUSH
78072: LD_INT 0
78074: PPUSH
78075: CALL_OW 109
// continue ;
78079: GO 78012
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78081: LD_EXP 79
78085: PUSH
78086: LD_VAR 0 2
78090: ARRAY
78091: PPUSH
78092: LD_INT 34
78094: PUSH
78095: LD_INT 31
78097: PUSH
78098: EMPTY
78099: LIST
78100: LIST
78101: PUSH
78102: LD_INT 58
78104: PUSH
78105: EMPTY
78106: LIST
78107: PUSH
78108: EMPTY
78109: LIST
78110: LIST
78111: PPUSH
78112: CALL_OW 72
78116: PUSH
78117: LD_VAR 0 3
78121: PPUSH
78122: CALL 49874 0 1
78126: NOT
78127: AND
78128: IFFALSE 78199
// begin if IsInUnit ( j ) then
78130: LD_VAR 0 3
78134: PPUSH
78135: CALL_OW 310
78139: IFFALSE 78150
// ComExitBuilding ( j ) ;
78141: LD_VAR 0 3
78145: PPUSH
78146: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78150: LD_VAR 0 3
78154: PPUSH
78155: LD_EXP 79
78159: PUSH
78160: LD_VAR 0 2
78164: ARRAY
78165: PPUSH
78166: LD_INT 34
78168: PUSH
78169: LD_INT 31
78171: PUSH
78172: EMPTY
78173: LIST
78174: LIST
78175: PUSH
78176: LD_INT 58
78178: PUSH
78179: EMPTY
78180: LIST
78181: PUSH
78182: EMPTY
78183: LIST
78184: LIST
78185: PPUSH
78186: CALL_OW 72
78190: PUSH
78191: LD_INT 1
78193: ARRAY
78194: PPUSH
78195: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78199: LD_VAR 0 3
78203: PPUSH
78204: CALL_OW 310
78208: NOT
78209: PUSH
78210: LD_VAR 0 3
78214: PPUSH
78215: CALL_OW 310
78219: PPUSH
78220: CALL_OW 266
78224: PUSH
78225: LD_INT 36
78227: NONEQUAL
78228: PUSH
78229: LD_VAR 0 3
78233: PPUSH
78234: CALL 49874 0 1
78238: NOT
78239: AND
78240: OR
78241: IFFALSE 78377
// begin if IsInUnit ( j ) then
78243: LD_VAR 0 3
78247: PPUSH
78248: CALL_OW 310
78252: IFFALSE 78263
// ComExitBuilding ( j ) ;
78254: LD_VAR 0 3
78258: PPUSH
78259: CALL_OW 122
// ct := 0 ;
78263: LD_ADDR_VAR 0 8
78267: PUSH
78268: LD_INT 0
78270: ST_TO_ADDR
// for k in x do
78271: LD_ADDR_VAR 0 4
78275: PUSH
78276: LD_VAR 0 11
78280: PUSH
78281: FOR_IN
78282: IFFALSE 78355
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78284: LD_VAR 0 4
78288: PPUSH
78289: CALL_OW 264
78293: PUSH
78294: LD_INT 31
78296: EQUAL
78297: PUSH
78298: LD_VAR 0 4
78302: PPUSH
78303: CALL_OW 311
78307: NOT
78308: AND
78309: PUSH
78310: LD_VAR 0 4
78314: PPUSH
78315: CALL_OW 266
78319: PUSH
78320: LD_INT 36
78322: EQUAL
78323: PUSH
78324: LD_VAR 0 4
78328: PPUSH
78329: CALL_OW 313
78333: PUSH
78334: LD_INT 3
78336: LESS
78337: AND
78338: OR
78339: IFFALSE 78353
// begin ct := k ;
78341: LD_ADDR_VAR 0 8
78345: PUSH
78346: LD_VAR 0 4
78350: ST_TO_ADDR
// break ;
78351: GO 78355
// end ;
78353: GO 78281
78355: POP
78356: POP
// if ct then
78357: LD_VAR 0 8
78361: IFFALSE 78377
// ComEnterUnit ( j , ct ) ;
78363: LD_VAR 0 3
78367: PPUSH
78368: LD_VAR 0 8
78372: PPUSH
78373: CALL_OW 120
// end ; end ;
78377: GO 78012
78379: POP
78380: POP
// places := 0 ;
78381: LD_ADDR_VAR 0 5
78385: PUSH
78386: LD_INT 0
78388: ST_TO_ADDR
// for j = 1 to x do
78389: LD_ADDR_VAR 0 3
78393: PUSH
78394: DOUBLE
78395: LD_INT 1
78397: DEC
78398: ST_TO_ADDR
78399: LD_VAR 0 11
78403: PUSH
78404: FOR_TO
78405: IFFALSE 78481
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78407: LD_VAR 0 11
78411: PUSH
78412: LD_VAR 0 3
78416: ARRAY
78417: PPUSH
78418: CALL_OW 264
78422: PUSH
78423: LD_INT 31
78425: EQUAL
78426: IFFALSE 78444
// places := places + 1 else
78428: LD_ADDR_VAR 0 5
78432: PUSH
78433: LD_VAR 0 5
78437: PUSH
78438: LD_INT 1
78440: PLUS
78441: ST_TO_ADDR
78442: GO 78479
// if GetBType ( x [ j ] ) = b_control_tower then
78444: LD_VAR 0 11
78448: PUSH
78449: LD_VAR 0 3
78453: ARRAY
78454: PPUSH
78455: CALL_OW 266
78459: PUSH
78460: LD_INT 36
78462: EQUAL
78463: IFFALSE 78479
// places := places + 3 ;
78465: LD_ADDR_VAR 0 5
78469: PUSH
78470: LD_VAR 0 5
78474: PUSH
78475: LD_INT 3
78477: PLUS
78478: ST_TO_ADDR
78479: GO 78404
78481: POP
78482: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
78483: LD_VAR 0 5
78487: PUSH
78488: LD_INT 0
78490: EQUAL
78491: PUSH
78492: LD_VAR 0 5
78496: PUSH
78497: LD_EXP 100
78501: PUSH
78502: LD_VAR 0 2
78506: ARRAY
78507: LESSEQUAL
78508: OR
78509: IFFALSE 78513
// continue ;
78511: GO 77763
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78513: LD_ADDR_VAR 0 6
78517: PUSH
78518: LD_EXP 60
78522: PUSH
78523: LD_VAR 0 2
78527: ARRAY
78528: PPUSH
78529: LD_INT 25
78531: PUSH
78532: LD_INT 3
78534: PUSH
78535: EMPTY
78536: LIST
78537: LIST
78538: PPUSH
78539: CALL_OW 72
78543: PUSH
78544: LD_EXP 100
78548: PUSH
78549: LD_VAR 0 2
78553: ARRAY
78554: DIFF
78555: PPUSH
78556: LD_INT 3
78558: PPUSH
78559: CALL 50774 0 2
78563: ST_TO_ADDR
// for j in tmp do
78564: LD_ADDR_VAR 0 3
78568: PUSH
78569: LD_VAR 0 6
78573: PUSH
78574: FOR_IN
78575: IFFALSE 78610
// if GetTag ( j ) > 0 then
78577: LD_VAR 0 3
78581: PPUSH
78582: CALL_OW 110
78586: PUSH
78587: LD_INT 0
78589: GREATER
78590: IFFALSE 78608
// tmp := tmp diff j ;
78592: LD_ADDR_VAR 0 6
78596: PUSH
78597: LD_VAR 0 6
78601: PUSH
78602: LD_VAR 0 3
78606: DIFF
78607: ST_TO_ADDR
78608: GO 78574
78610: POP
78611: POP
// if not tmp then
78612: LD_VAR 0 6
78616: NOT
78617: IFFALSE 78621
// continue ;
78619: GO 77763
// if places then
78621: LD_VAR 0 5
78625: IFFALSE 78684
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78627: LD_ADDR_EXP 100
78631: PUSH
78632: LD_EXP 100
78636: PPUSH
78637: LD_VAR 0 2
78641: PPUSH
78642: LD_EXP 100
78646: PUSH
78647: LD_VAR 0 2
78651: ARRAY
78652: PUSH
78653: LD_VAR 0 6
78657: PUSH
78658: LD_INT 1
78660: ARRAY
78661: UNION
78662: PPUSH
78663: CALL_OW 1
78667: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78668: LD_VAR 0 6
78672: PUSH
78673: LD_INT 1
78675: ARRAY
78676: PPUSH
78677: LD_INT 126
78679: PPUSH
78680: CALL_OW 109
// end ; end ;
78684: GO 77763
78686: POP
78687: POP
// end ;
78688: LD_VAR 0 1
78692: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78693: LD_INT 0
78695: PPUSH
78696: PPUSH
78697: PPUSH
78698: PPUSH
78699: PPUSH
78700: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78701: LD_VAR 0 1
78705: NOT
78706: PUSH
78707: LD_VAR 0 2
78711: NOT
78712: OR
78713: PUSH
78714: LD_VAR 0 3
78718: NOT
78719: OR
78720: PUSH
78721: LD_VAR 0 4
78725: PUSH
78726: LD_INT 1
78728: PUSH
78729: LD_INT 2
78731: PUSH
78732: LD_INT 3
78734: PUSH
78735: LD_INT 4
78737: PUSH
78738: LD_INT 5
78740: PUSH
78741: LD_INT 8
78743: PUSH
78744: LD_INT 9
78746: PUSH
78747: LD_INT 15
78749: PUSH
78750: LD_INT 16
78752: PUSH
78753: EMPTY
78754: LIST
78755: LIST
78756: LIST
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: IN
78764: NOT
78765: OR
78766: IFFALSE 78770
// exit ;
78768: GO 79670
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
78770: LD_ADDR_VAR 0 2
78774: PUSH
78775: LD_VAR 0 2
78779: PPUSH
78780: LD_INT 21
78782: PUSH
78783: LD_INT 3
78785: PUSH
78786: EMPTY
78787: LIST
78788: LIST
78789: PUSH
78790: LD_INT 24
78792: PUSH
78793: LD_INT 250
78795: PUSH
78796: EMPTY
78797: LIST
78798: LIST
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PPUSH
78804: CALL_OW 72
78808: ST_TO_ADDR
// case class of 1 , 15 :
78809: LD_VAR 0 4
78813: PUSH
78814: LD_INT 1
78816: DOUBLE
78817: EQUAL
78818: IFTRUE 78828
78820: LD_INT 15
78822: DOUBLE
78823: EQUAL
78824: IFTRUE 78828
78826: GO 78913
78828: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
78829: LD_ADDR_VAR 0 8
78833: PUSH
78834: LD_VAR 0 2
78838: PPUSH
78839: LD_INT 2
78841: PUSH
78842: LD_INT 30
78844: PUSH
78845: LD_INT 32
78847: PUSH
78848: EMPTY
78849: LIST
78850: LIST
78851: PUSH
78852: LD_INT 30
78854: PUSH
78855: LD_INT 31
78857: PUSH
78858: EMPTY
78859: LIST
78860: LIST
78861: PUSH
78862: EMPTY
78863: LIST
78864: LIST
78865: LIST
78866: PPUSH
78867: CALL_OW 72
78871: PUSH
78872: LD_VAR 0 2
78876: PPUSH
78877: LD_INT 2
78879: PUSH
78880: LD_INT 30
78882: PUSH
78883: LD_INT 4
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 30
78892: PUSH
78893: LD_INT 5
78895: PUSH
78896: EMPTY
78897: LIST
78898: LIST
78899: PUSH
78900: EMPTY
78901: LIST
78902: LIST
78903: LIST
78904: PPUSH
78905: CALL_OW 72
78909: ADD
78910: ST_TO_ADDR
78911: GO 79159
78913: LD_INT 2
78915: DOUBLE
78916: EQUAL
78917: IFTRUE 78927
78919: LD_INT 16
78921: DOUBLE
78922: EQUAL
78923: IFTRUE 78927
78925: GO 78973
78927: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
78928: LD_ADDR_VAR 0 8
78932: PUSH
78933: LD_VAR 0 2
78937: PPUSH
78938: LD_INT 2
78940: PUSH
78941: LD_INT 30
78943: PUSH
78944: LD_INT 0
78946: PUSH
78947: EMPTY
78948: LIST
78949: LIST
78950: PUSH
78951: LD_INT 30
78953: PUSH
78954: LD_INT 1
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: LIST
78965: PPUSH
78966: CALL_OW 72
78970: ST_TO_ADDR
78971: GO 79159
78973: LD_INT 3
78975: DOUBLE
78976: EQUAL
78977: IFTRUE 78981
78979: GO 79027
78981: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
78982: LD_ADDR_VAR 0 8
78986: PUSH
78987: LD_VAR 0 2
78991: PPUSH
78992: LD_INT 2
78994: PUSH
78995: LD_INT 30
78997: PUSH
78998: LD_INT 2
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 30
79007: PUSH
79008: LD_INT 3
79010: PUSH
79011: EMPTY
79012: LIST
79013: LIST
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: LIST
79019: PPUSH
79020: CALL_OW 72
79024: ST_TO_ADDR
79025: GO 79159
79027: LD_INT 4
79029: DOUBLE
79030: EQUAL
79031: IFTRUE 79035
79033: GO 79092
79035: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79036: LD_ADDR_VAR 0 8
79040: PUSH
79041: LD_VAR 0 2
79045: PPUSH
79046: LD_INT 2
79048: PUSH
79049: LD_INT 30
79051: PUSH
79052: LD_INT 6
79054: PUSH
79055: EMPTY
79056: LIST
79057: LIST
79058: PUSH
79059: LD_INT 30
79061: PUSH
79062: LD_INT 7
79064: PUSH
79065: EMPTY
79066: LIST
79067: LIST
79068: PUSH
79069: LD_INT 30
79071: PUSH
79072: LD_INT 8
79074: PUSH
79075: EMPTY
79076: LIST
79077: LIST
79078: PUSH
79079: EMPTY
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: PPUSH
79085: CALL_OW 72
79089: ST_TO_ADDR
79090: GO 79159
79092: LD_INT 5
79094: DOUBLE
79095: EQUAL
79096: IFTRUE 79112
79098: LD_INT 8
79100: DOUBLE
79101: EQUAL
79102: IFTRUE 79112
79104: LD_INT 9
79106: DOUBLE
79107: EQUAL
79108: IFTRUE 79112
79110: GO 79158
79112: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79113: LD_ADDR_VAR 0 8
79117: PUSH
79118: LD_VAR 0 2
79122: PPUSH
79123: LD_INT 2
79125: PUSH
79126: LD_INT 30
79128: PUSH
79129: LD_INT 4
79131: PUSH
79132: EMPTY
79133: LIST
79134: LIST
79135: PUSH
79136: LD_INT 30
79138: PUSH
79139: LD_INT 5
79141: PUSH
79142: EMPTY
79143: LIST
79144: LIST
79145: PUSH
79146: EMPTY
79147: LIST
79148: LIST
79149: LIST
79150: PPUSH
79151: CALL_OW 72
79155: ST_TO_ADDR
79156: GO 79159
79158: POP
// if not tmp then
79159: LD_VAR 0 8
79163: NOT
79164: IFFALSE 79168
// exit ;
79166: GO 79670
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79168: LD_VAR 0 4
79172: PUSH
79173: LD_INT 1
79175: PUSH
79176: LD_INT 15
79178: PUSH
79179: EMPTY
79180: LIST
79181: LIST
79182: IN
79183: PUSH
79184: LD_EXP 69
79188: PUSH
79189: LD_VAR 0 1
79193: ARRAY
79194: AND
79195: IFFALSE 79351
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79197: LD_ADDR_VAR 0 9
79201: PUSH
79202: LD_EXP 69
79206: PUSH
79207: LD_VAR 0 1
79211: ARRAY
79212: PUSH
79213: LD_INT 1
79215: ARRAY
79216: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79217: LD_VAR 0 9
79221: PUSH
79222: LD_EXP 70
79226: PUSH
79227: LD_VAR 0 1
79231: ARRAY
79232: IN
79233: NOT
79234: IFFALSE 79349
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79236: LD_ADDR_EXP 70
79240: PUSH
79241: LD_EXP 70
79245: PPUSH
79246: LD_VAR 0 1
79250: PUSH
79251: LD_EXP 70
79255: PUSH
79256: LD_VAR 0 1
79260: ARRAY
79261: PUSH
79262: LD_INT 1
79264: PLUS
79265: PUSH
79266: EMPTY
79267: LIST
79268: LIST
79269: PPUSH
79270: LD_VAR 0 9
79274: PPUSH
79275: CALL 20003 0 3
79279: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79280: LD_ADDR_EXP 69
79284: PUSH
79285: LD_EXP 69
79289: PPUSH
79290: LD_VAR 0 1
79294: PPUSH
79295: LD_EXP 69
79299: PUSH
79300: LD_VAR 0 1
79304: ARRAY
79305: PUSH
79306: LD_VAR 0 9
79310: DIFF
79311: PPUSH
79312: CALL_OW 1
79316: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79317: LD_VAR 0 3
79321: PPUSH
79322: LD_EXP 70
79326: PUSH
79327: LD_VAR 0 1
79331: ARRAY
79332: PUSH
79333: LD_EXP 70
79337: PUSH
79338: LD_VAR 0 1
79342: ARRAY
79343: ARRAY
79344: PPUSH
79345: CALL_OW 120
// end ; exit ;
79349: GO 79670
// end ; if tmp > 1 then
79351: LD_VAR 0 8
79355: PUSH
79356: LD_INT 1
79358: GREATER
79359: IFFALSE 79463
// for i = 2 to tmp do
79361: LD_ADDR_VAR 0 6
79365: PUSH
79366: DOUBLE
79367: LD_INT 2
79369: DEC
79370: ST_TO_ADDR
79371: LD_VAR 0 8
79375: PUSH
79376: FOR_TO
79377: IFFALSE 79461
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79379: LD_VAR 0 8
79383: PUSH
79384: LD_VAR 0 6
79388: ARRAY
79389: PPUSH
79390: CALL_OW 461
79394: PUSH
79395: LD_INT 6
79397: EQUAL
79398: IFFALSE 79459
// begin x := tmp [ i ] ;
79400: LD_ADDR_VAR 0 9
79404: PUSH
79405: LD_VAR 0 8
79409: PUSH
79410: LD_VAR 0 6
79414: ARRAY
79415: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79416: LD_ADDR_VAR 0 8
79420: PUSH
79421: LD_VAR 0 8
79425: PPUSH
79426: LD_VAR 0 6
79430: PPUSH
79431: CALL_OW 3
79435: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79436: LD_ADDR_VAR 0 8
79440: PUSH
79441: LD_VAR 0 8
79445: PPUSH
79446: LD_INT 1
79448: PPUSH
79449: LD_VAR 0 9
79453: PPUSH
79454: CALL_OW 2
79458: ST_TO_ADDR
// end ;
79459: GO 79376
79461: POP
79462: POP
// for i in tmp do
79463: LD_ADDR_VAR 0 6
79467: PUSH
79468: LD_VAR 0 8
79472: PUSH
79473: FOR_IN
79474: IFFALSE 79543
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79476: LD_VAR 0 6
79480: PPUSH
79481: CALL_OW 313
79485: PUSH
79486: LD_INT 6
79488: LESS
79489: PUSH
79490: LD_VAR 0 6
79494: PPUSH
79495: CALL_OW 266
79499: PUSH
79500: LD_INT 31
79502: PUSH
79503: LD_INT 32
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: IN
79510: NOT
79511: AND
79512: PUSH
79513: LD_VAR 0 6
79517: PPUSH
79518: CALL_OW 313
79522: PUSH
79523: LD_INT 0
79525: EQUAL
79526: OR
79527: IFFALSE 79541
// begin j := i ;
79529: LD_ADDR_VAR 0 7
79533: PUSH
79534: LD_VAR 0 6
79538: ST_TO_ADDR
// break ;
79539: GO 79543
// end ; end ;
79541: GO 79473
79543: POP
79544: POP
// if j then
79545: LD_VAR 0 7
79549: IFFALSE 79567
// ComEnterUnit ( unit , j ) else
79551: LD_VAR 0 3
79555: PPUSH
79556: LD_VAR 0 7
79560: PPUSH
79561: CALL_OW 120
79565: GO 79670
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79567: LD_ADDR_VAR 0 10
79571: PUSH
79572: LD_VAR 0 2
79576: PPUSH
79577: LD_INT 2
79579: PUSH
79580: LD_INT 30
79582: PUSH
79583: LD_INT 0
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 30
79592: PUSH
79593: LD_INT 1
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: EMPTY
79601: LIST
79602: LIST
79603: LIST
79604: PPUSH
79605: CALL_OW 72
79609: ST_TO_ADDR
// if depot then
79610: LD_VAR 0 10
79614: IFFALSE 79670
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79616: LD_ADDR_VAR 0 10
79620: PUSH
79621: LD_VAR 0 10
79625: PPUSH
79626: LD_VAR 0 3
79630: PPUSH
79631: CALL_OW 74
79635: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79636: LD_VAR 0 3
79640: PPUSH
79641: LD_VAR 0 10
79645: PPUSH
79646: CALL_OW 296
79650: PUSH
79651: LD_INT 10
79653: GREATER
79654: IFFALSE 79670
// ComStandNearbyBuilding ( unit , depot ) ;
79656: LD_VAR 0 3
79660: PPUSH
79661: LD_VAR 0 10
79665: PPUSH
79666: CALL 16428 0 2
// end ; end ; end ;
79670: LD_VAR 0 5
79674: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79675: LD_INT 0
79677: PPUSH
79678: PPUSH
79679: PPUSH
79680: PPUSH
// if not mc_bases then
79681: LD_EXP 60
79685: NOT
79686: IFFALSE 79690
// exit ;
79688: GO 79929
// for i = 1 to mc_bases do
79690: LD_ADDR_VAR 0 2
79694: PUSH
79695: DOUBLE
79696: LD_INT 1
79698: DEC
79699: ST_TO_ADDR
79700: LD_EXP 60
79704: PUSH
79705: FOR_TO
79706: IFFALSE 79927
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79708: LD_ADDR_VAR 0 4
79712: PUSH
79713: LD_EXP 60
79717: PUSH
79718: LD_VAR 0 2
79722: ARRAY
79723: PPUSH
79724: LD_INT 21
79726: PUSH
79727: LD_INT 1
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PPUSH
79734: CALL_OW 72
79738: PUSH
79739: LD_EXP 89
79743: PUSH
79744: LD_VAR 0 2
79748: ARRAY
79749: UNION
79750: ST_TO_ADDR
// if not tmp then
79751: LD_VAR 0 4
79755: NOT
79756: IFFALSE 79760
// continue ;
79758: GO 79705
// for j in tmp do
79760: LD_ADDR_VAR 0 3
79764: PUSH
79765: LD_VAR 0 4
79769: PUSH
79770: FOR_IN
79771: IFFALSE 79923
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
79773: LD_VAR 0 3
79777: PPUSH
79778: CALL_OW 110
79782: NOT
79783: PUSH
79784: LD_VAR 0 3
79788: PPUSH
79789: CALL_OW 314
79793: NOT
79794: AND
79795: PUSH
79796: LD_VAR 0 3
79800: PPUSH
79801: CALL_OW 311
79805: NOT
79806: AND
79807: PUSH
79808: LD_VAR 0 3
79812: PPUSH
79813: CALL_OW 310
79817: NOT
79818: AND
79819: PUSH
79820: LD_VAR 0 3
79824: PUSH
79825: LD_EXP 63
79829: PUSH
79830: LD_VAR 0 2
79834: ARRAY
79835: PUSH
79836: LD_INT 1
79838: ARRAY
79839: IN
79840: NOT
79841: AND
79842: PUSH
79843: LD_VAR 0 3
79847: PUSH
79848: LD_EXP 63
79852: PUSH
79853: LD_VAR 0 2
79857: ARRAY
79858: PUSH
79859: LD_INT 2
79861: ARRAY
79862: IN
79863: NOT
79864: AND
79865: PUSH
79866: LD_VAR 0 3
79870: PUSH
79871: LD_EXP 72
79875: PUSH
79876: LD_VAR 0 2
79880: ARRAY
79881: IN
79882: NOT
79883: AND
79884: IFFALSE 79921
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
79886: LD_VAR 0 2
79890: PPUSH
79891: LD_EXP 60
79895: PUSH
79896: LD_VAR 0 2
79900: ARRAY
79901: PPUSH
79902: LD_VAR 0 3
79906: PPUSH
79907: LD_VAR 0 3
79911: PPUSH
79912: CALL_OW 257
79916: PPUSH
79917: CALL 78693 0 4
// end ;
79921: GO 79770
79923: POP
79924: POP
// end ;
79925: GO 79705
79927: POP
79928: POP
// end ;
79929: LD_VAR 0 1
79933: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
79934: LD_INT 0
79936: PPUSH
79937: PPUSH
79938: PPUSH
79939: PPUSH
79940: PPUSH
79941: PPUSH
// if not mc_bases [ base ] then
79942: LD_EXP 60
79946: PUSH
79947: LD_VAR 0 1
79951: ARRAY
79952: NOT
79953: IFFALSE 79957
// exit ;
79955: GO 80139
// tmp := [ ] ;
79957: LD_ADDR_VAR 0 6
79961: PUSH
79962: EMPTY
79963: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
79964: LD_ADDR_VAR 0 7
79968: PUSH
79969: LD_VAR 0 3
79973: PPUSH
79974: LD_INT 0
79976: PPUSH
79977: CALL_OW 517
79981: ST_TO_ADDR
// if not list then
79982: LD_VAR 0 7
79986: NOT
79987: IFFALSE 79991
// exit ;
79989: GO 80139
// for i = 1 to amount do
79991: LD_ADDR_VAR 0 5
79995: PUSH
79996: DOUBLE
79997: LD_INT 1
79999: DEC
80000: ST_TO_ADDR
80001: LD_VAR 0 2
80005: PUSH
80006: FOR_TO
80007: IFFALSE 80087
// begin x := rand ( 1 , list [ 1 ] ) ;
80009: LD_ADDR_VAR 0 8
80013: PUSH
80014: LD_INT 1
80016: PPUSH
80017: LD_VAR 0 7
80021: PUSH
80022: LD_INT 1
80024: ARRAY
80025: PPUSH
80026: CALL_OW 12
80030: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80031: LD_ADDR_VAR 0 6
80035: PUSH
80036: LD_VAR 0 6
80040: PPUSH
80041: LD_VAR 0 5
80045: PPUSH
80046: LD_VAR 0 7
80050: PUSH
80051: LD_INT 1
80053: ARRAY
80054: PUSH
80055: LD_VAR 0 8
80059: ARRAY
80060: PUSH
80061: LD_VAR 0 7
80065: PUSH
80066: LD_INT 2
80068: ARRAY
80069: PUSH
80070: LD_VAR 0 8
80074: ARRAY
80075: PUSH
80076: EMPTY
80077: LIST
80078: LIST
80079: PPUSH
80080: CALL_OW 1
80084: ST_TO_ADDR
// end ;
80085: GO 80006
80087: POP
80088: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80089: LD_ADDR_EXP 73
80093: PUSH
80094: LD_EXP 73
80098: PPUSH
80099: LD_VAR 0 1
80103: PPUSH
80104: LD_VAR 0 6
80108: PPUSH
80109: CALL_OW 1
80113: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80114: LD_ADDR_EXP 75
80118: PUSH
80119: LD_EXP 75
80123: PPUSH
80124: LD_VAR 0 1
80128: PPUSH
80129: LD_VAR 0 3
80133: PPUSH
80134: CALL_OW 1
80138: ST_TO_ADDR
// end ;
80139: LD_VAR 0 4
80143: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80144: LD_INT 0
80146: PPUSH
// if not mc_bases [ base ] then
80147: LD_EXP 60
80151: PUSH
80152: LD_VAR 0 1
80156: ARRAY
80157: NOT
80158: IFFALSE 80162
// exit ;
80160: GO 80187
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80162: LD_ADDR_EXP 65
80166: PUSH
80167: LD_EXP 65
80171: PPUSH
80172: LD_VAR 0 1
80176: PPUSH
80177: LD_VAR 0 2
80181: PPUSH
80182: CALL_OW 1
80186: ST_TO_ADDR
// end ;
80187: LD_VAR 0 3
80191: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80192: LD_INT 0
80194: PPUSH
// if not mc_bases [ base ] then
80195: LD_EXP 60
80199: PUSH
80200: LD_VAR 0 1
80204: ARRAY
80205: NOT
80206: IFFALSE 80210
// exit ;
80208: GO 80247
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80210: LD_ADDR_EXP 65
80214: PUSH
80215: LD_EXP 65
80219: PPUSH
80220: LD_VAR 0 1
80224: PPUSH
80225: LD_EXP 65
80229: PUSH
80230: LD_VAR 0 1
80234: ARRAY
80235: PUSH
80236: LD_VAR 0 2
80240: UNION
80241: PPUSH
80242: CALL_OW 1
80246: ST_TO_ADDR
// end ;
80247: LD_VAR 0 3
80251: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80252: LD_INT 0
80254: PPUSH
// if not mc_bases [ base ] then
80255: LD_EXP 60
80259: PUSH
80260: LD_VAR 0 1
80264: ARRAY
80265: NOT
80266: IFFALSE 80270
// exit ;
80268: GO 80295
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80270: LD_ADDR_EXP 81
80274: PUSH
80275: LD_EXP 81
80279: PPUSH
80280: LD_VAR 0 1
80284: PPUSH
80285: LD_VAR 0 2
80289: PPUSH
80290: CALL_OW 1
80294: ST_TO_ADDR
// end ;
80295: LD_VAR 0 3
80299: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80300: LD_INT 0
80302: PPUSH
// if not mc_bases [ base ] then
80303: LD_EXP 60
80307: PUSH
80308: LD_VAR 0 1
80312: ARRAY
80313: NOT
80314: IFFALSE 80318
// exit ;
80316: GO 80355
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80318: LD_ADDR_EXP 81
80322: PUSH
80323: LD_EXP 81
80327: PPUSH
80328: LD_VAR 0 1
80332: PPUSH
80333: LD_EXP 81
80337: PUSH
80338: LD_VAR 0 1
80342: ARRAY
80343: PUSH
80344: LD_VAR 0 2
80348: ADD
80349: PPUSH
80350: CALL_OW 1
80354: ST_TO_ADDR
// end ;
80355: LD_VAR 0 3
80359: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80360: LD_INT 0
80362: PPUSH
// if not mc_bases [ base ] then
80363: LD_EXP 60
80367: PUSH
80368: LD_VAR 0 1
80372: ARRAY
80373: NOT
80374: IFFALSE 80378
// exit ;
80376: GO 80432
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80378: LD_ADDR_EXP 82
80382: PUSH
80383: LD_EXP 82
80387: PPUSH
80388: LD_VAR 0 1
80392: PPUSH
80393: LD_VAR 0 2
80397: PPUSH
80398: CALL_OW 1
80402: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80403: LD_ADDR_EXP 71
80407: PUSH
80408: LD_EXP 71
80412: PPUSH
80413: LD_VAR 0 1
80417: PPUSH
80418: LD_VAR 0 2
80422: PUSH
80423: LD_INT 0
80425: PLUS
80426: PPUSH
80427: CALL_OW 1
80431: ST_TO_ADDR
// end ;
80432: LD_VAR 0 3
80436: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80437: LD_INT 0
80439: PPUSH
// if not mc_bases [ base ] then
80440: LD_EXP 60
80444: PUSH
80445: LD_VAR 0 1
80449: ARRAY
80450: NOT
80451: IFFALSE 80455
// exit ;
80453: GO 80480
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80455: LD_ADDR_EXP 71
80459: PUSH
80460: LD_EXP 71
80464: PPUSH
80465: LD_VAR 0 1
80469: PPUSH
80470: LD_VAR 0 2
80474: PPUSH
80475: CALL_OW 1
80479: ST_TO_ADDR
// end ;
80480: LD_VAR 0 3
80484: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80485: LD_INT 0
80487: PPUSH
80488: PPUSH
80489: PPUSH
80490: PPUSH
// if not mc_bases [ base ] then
80491: LD_EXP 60
80495: PUSH
80496: LD_VAR 0 1
80500: ARRAY
80501: NOT
80502: IFFALSE 80506
// exit ;
80504: GO 80571
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80506: LD_ADDR_EXP 80
80510: PUSH
80511: LD_EXP 80
80515: PPUSH
80516: LD_VAR 0 1
80520: PUSH
80521: LD_EXP 80
80525: PUSH
80526: LD_VAR 0 1
80530: ARRAY
80531: PUSH
80532: LD_INT 1
80534: PLUS
80535: PUSH
80536: EMPTY
80537: LIST
80538: LIST
80539: PPUSH
80540: LD_VAR 0 1
80544: PUSH
80545: LD_VAR 0 2
80549: PUSH
80550: LD_VAR 0 3
80554: PUSH
80555: LD_VAR 0 4
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: LIST
80564: LIST
80565: PPUSH
80566: CALL 20003 0 3
80570: ST_TO_ADDR
// end ;
80571: LD_VAR 0 5
80575: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80576: LD_INT 0
80578: PPUSH
// if not mc_bases [ base ] then
80579: LD_EXP 60
80583: PUSH
80584: LD_VAR 0 1
80588: ARRAY
80589: NOT
80590: IFFALSE 80594
// exit ;
80592: GO 80619
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80594: LD_ADDR_EXP 97
80598: PUSH
80599: LD_EXP 97
80603: PPUSH
80604: LD_VAR 0 1
80608: PPUSH
80609: LD_VAR 0 2
80613: PPUSH
80614: CALL_OW 1
80618: ST_TO_ADDR
// end ;
80619: LD_VAR 0 3
80623: RET
// export function MC_GetMinesField ( base ) ; begin
80624: LD_INT 0
80626: PPUSH
// result := mc_mines [ base ] ;
80627: LD_ADDR_VAR 0 2
80631: PUSH
80632: LD_EXP 73
80636: PUSH
80637: LD_VAR 0 1
80641: ARRAY
80642: ST_TO_ADDR
// end ;
80643: LD_VAR 0 2
80647: RET
// export function MC_GetProduceList ( base ) ; begin
80648: LD_INT 0
80650: PPUSH
// result := mc_produce [ base ] ;
80651: LD_ADDR_VAR 0 2
80655: PUSH
80656: LD_EXP 81
80660: PUSH
80661: LD_VAR 0 1
80665: ARRAY
80666: ST_TO_ADDR
// end ;
80667: LD_VAR 0 2
80671: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80672: LD_INT 0
80674: PPUSH
80675: PPUSH
// if not mc_bases then
80676: LD_EXP 60
80680: NOT
80681: IFFALSE 80685
// exit ;
80683: GO 80750
// if mc_bases [ base ] then
80685: LD_EXP 60
80689: PUSH
80690: LD_VAR 0 1
80694: ARRAY
80695: IFFALSE 80750
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80697: LD_ADDR_VAR 0 3
80701: PUSH
80702: LD_EXP 60
80706: PUSH
80707: LD_VAR 0 1
80711: ARRAY
80712: PPUSH
80713: LD_INT 30
80715: PUSH
80716: LD_VAR 0 2
80720: PUSH
80721: EMPTY
80722: LIST
80723: LIST
80724: PPUSH
80725: CALL_OW 72
80729: ST_TO_ADDR
// if result then
80730: LD_VAR 0 3
80734: IFFALSE 80750
// result := result [ 1 ] ;
80736: LD_ADDR_VAR 0 3
80740: PUSH
80741: LD_VAR 0 3
80745: PUSH
80746: LD_INT 1
80748: ARRAY
80749: ST_TO_ADDR
// end ; end ;
80750: LD_VAR 0 3
80754: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
80755: LD_INT 0
80757: PPUSH
80758: PPUSH
// if not mc_bases then
80759: LD_EXP 60
80763: NOT
80764: IFFALSE 80768
// exit ;
80766: GO 80813
// if mc_bases [ base ] then
80768: LD_EXP 60
80772: PUSH
80773: LD_VAR 0 1
80777: ARRAY
80778: IFFALSE 80813
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80780: LD_ADDR_VAR 0 3
80784: PUSH
80785: LD_EXP 60
80789: PUSH
80790: LD_VAR 0 1
80794: ARRAY
80795: PPUSH
80796: LD_INT 30
80798: PUSH
80799: LD_VAR 0 2
80803: PUSH
80804: EMPTY
80805: LIST
80806: LIST
80807: PPUSH
80808: CALL_OW 72
80812: ST_TO_ADDR
// end ;
80813: LD_VAR 0 3
80817: RET
// export function MC_SetTame ( base , area ) ; begin
80818: LD_INT 0
80820: PPUSH
// if not mc_bases or not base then
80821: LD_EXP 60
80825: NOT
80826: PUSH
80827: LD_VAR 0 1
80831: NOT
80832: OR
80833: IFFALSE 80837
// exit ;
80835: GO 80862
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
80837: LD_ADDR_EXP 88
80841: PUSH
80842: LD_EXP 88
80846: PPUSH
80847: LD_VAR 0 1
80851: PPUSH
80852: LD_VAR 0 2
80856: PPUSH
80857: CALL_OW 1
80861: ST_TO_ADDR
// end ;
80862: LD_VAR 0 3
80866: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
80867: LD_INT 0
80869: PPUSH
80870: PPUSH
// if not mc_bases or not base then
80871: LD_EXP 60
80875: NOT
80876: PUSH
80877: LD_VAR 0 1
80881: NOT
80882: OR
80883: IFFALSE 80887
// exit ;
80885: GO 80989
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80887: LD_ADDR_VAR 0 4
80891: PUSH
80892: LD_EXP 60
80896: PUSH
80897: LD_VAR 0 1
80901: ARRAY
80902: PPUSH
80903: LD_INT 30
80905: PUSH
80906: LD_VAR 0 2
80910: PUSH
80911: EMPTY
80912: LIST
80913: LIST
80914: PPUSH
80915: CALL_OW 72
80919: ST_TO_ADDR
// if not tmp then
80920: LD_VAR 0 4
80924: NOT
80925: IFFALSE 80929
// exit ;
80927: GO 80989
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
80929: LD_ADDR_EXP 92
80933: PUSH
80934: LD_EXP 92
80938: PPUSH
80939: LD_VAR 0 1
80943: PPUSH
80944: LD_EXP 92
80948: PUSH
80949: LD_VAR 0 1
80953: ARRAY
80954: PPUSH
80955: LD_EXP 92
80959: PUSH
80960: LD_VAR 0 1
80964: ARRAY
80965: PUSH
80966: LD_INT 1
80968: PLUS
80969: PPUSH
80970: LD_VAR 0 4
80974: PUSH
80975: LD_INT 1
80977: ARRAY
80978: PPUSH
80979: CALL_OW 2
80983: PPUSH
80984: CALL_OW 1
80988: ST_TO_ADDR
// end ;
80989: LD_VAR 0 3
80993: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
80994: LD_INT 0
80996: PPUSH
80997: PPUSH
// if not mc_bases or not base or not kinds then
80998: LD_EXP 60
81002: NOT
81003: PUSH
81004: LD_VAR 0 1
81008: NOT
81009: OR
81010: PUSH
81011: LD_VAR 0 2
81015: NOT
81016: OR
81017: IFFALSE 81021
// exit ;
81019: GO 81082
// for i in kinds do
81021: LD_ADDR_VAR 0 4
81025: PUSH
81026: LD_VAR 0 2
81030: PUSH
81031: FOR_IN
81032: IFFALSE 81080
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81034: LD_ADDR_EXP 94
81038: PUSH
81039: LD_EXP 94
81043: PPUSH
81044: LD_VAR 0 1
81048: PUSH
81049: LD_EXP 94
81053: PUSH
81054: LD_VAR 0 1
81058: ARRAY
81059: PUSH
81060: LD_INT 1
81062: PLUS
81063: PUSH
81064: EMPTY
81065: LIST
81066: LIST
81067: PPUSH
81068: LD_VAR 0 4
81072: PPUSH
81073: CALL 20003 0 3
81077: ST_TO_ADDR
81078: GO 81031
81080: POP
81081: POP
// end ;
81082: LD_VAR 0 3
81086: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81087: LD_INT 0
81089: PPUSH
// if not mc_bases or not base or not areas then
81090: LD_EXP 60
81094: NOT
81095: PUSH
81096: LD_VAR 0 1
81100: NOT
81101: OR
81102: PUSH
81103: LD_VAR 0 2
81107: NOT
81108: OR
81109: IFFALSE 81113
// exit ;
81111: GO 81138
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81113: LD_ADDR_EXP 78
81117: PUSH
81118: LD_EXP 78
81122: PPUSH
81123: LD_VAR 0 1
81127: PPUSH
81128: LD_VAR 0 2
81132: PPUSH
81133: CALL_OW 1
81137: ST_TO_ADDR
// end ;
81138: LD_VAR 0 3
81142: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81143: LD_INT 0
81145: PPUSH
// if not mc_bases or not base or not teleports_exit then
81146: LD_EXP 60
81150: NOT
81151: PUSH
81152: LD_VAR 0 1
81156: NOT
81157: OR
81158: PUSH
81159: LD_VAR 0 2
81163: NOT
81164: OR
81165: IFFALSE 81169
// exit ;
81167: GO 81194
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81169: LD_ADDR_EXP 95
81173: PUSH
81174: LD_EXP 95
81178: PPUSH
81179: LD_VAR 0 1
81183: PPUSH
81184: LD_VAR 0 2
81188: PPUSH
81189: CALL_OW 1
81193: ST_TO_ADDR
// end ;
81194: LD_VAR 0 3
81198: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81199: LD_INT 0
81201: PPUSH
81202: PPUSH
81203: PPUSH
// if not mc_bases or not base or not ext_list then
81204: LD_EXP 60
81208: NOT
81209: PUSH
81210: LD_VAR 0 1
81214: NOT
81215: OR
81216: PUSH
81217: LD_VAR 0 5
81221: NOT
81222: OR
81223: IFFALSE 81227
// exit ;
81225: GO 81400
// tmp := GetFacExtXYD ( x , y , d ) ;
81227: LD_ADDR_VAR 0 8
81231: PUSH
81232: LD_VAR 0 2
81236: PPUSH
81237: LD_VAR 0 3
81241: PPUSH
81242: LD_VAR 0 4
81246: PPUSH
81247: CALL 49904 0 3
81251: ST_TO_ADDR
// if not tmp then
81252: LD_VAR 0 8
81256: NOT
81257: IFFALSE 81261
// exit ;
81259: GO 81400
// for i in tmp do
81261: LD_ADDR_VAR 0 7
81265: PUSH
81266: LD_VAR 0 8
81270: PUSH
81271: FOR_IN
81272: IFFALSE 81398
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81274: LD_ADDR_EXP 65
81278: PUSH
81279: LD_EXP 65
81283: PPUSH
81284: LD_VAR 0 1
81288: PPUSH
81289: LD_EXP 65
81293: PUSH
81294: LD_VAR 0 1
81298: ARRAY
81299: PPUSH
81300: LD_EXP 65
81304: PUSH
81305: LD_VAR 0 1
81309: ARRAY
81310: PUSH
81311: LD_INT 1
81313: PLUS
81314: PPUSH
81315: LD_VAR 0 5
81319: PUSH
81320: LD_INT 1
81322: ARRAY
81323: PUSH
81324: LD_VAR 0 7
81328: PUSH
81329: LD_INT 1
81331: ARRAY
81332: PUSH
81333: LD_VAR 0 7
81337: PUSH
81338: LD_INT 2
81340: ARRAY
81341: PUSH
81342: LD_VAR 0 7
81346: PUSH
81347: LD_INT 3
81349: ARRAY
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: PPUSH
81357: CALL_OW 2
81361: PPUSH
81362: CALL_OW 1
81366: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81367: LD_ADDR_VAR 0 5
81371: PUSH
81372: LD_VAR 0 5
81376: PPUSH
81377: LD_INT 1
81379: PPUSH
81380: CALL_OW 3
81384: ST_TO_ADDR
// if not ext_list then
81385: LD_VAR 0 5
81389: NOT
81390: IFFALSE 81396
// exit ;
81392: POP
81393: POP
81394: GO 81400
// end ;
81396: GO 81271
81398: POP
81399: POP
// end ;
81400: LD_VAR 0 6
81404: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81405: LD_INT 0
81407: PPUSH
// if not mc_bases or not base or not weapon_list then
81408: LD_EXP 60
81412: NOT
81413: PUSH
81414: LD_VAR 0 1
81418: NOT
81419: OR
81420: PUSH
81421: LD_VAR 0 2
81425: NOT
81426: OR
81427: IFFALSE 81431
// exit ;
81429: GO 81456
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81431: LD_ADDR_EXP 99
81435: PUSH
81436: LD_EXP 99
81440: PPUSH
81441: LD_VAR 0 1
81445: PPUSH
81446: LD_VAR 0 2
81450: PPUSH
81451: CALL_OW 1
81455: ST_TO_ADDR
// end ;
81456: LD_VAR 0 3
81460: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81461: LD_INT 0
81463: PPUSH
// if not mc_bases or not base or not tech_list then
81464: LD_EXP 60
81468: NOT
81469: PUSH
81470: LD_VAR 0 1
81474: NOT
81475: OR
81476: PUSH
81477: LD_VAR 0 2
81481: NOT
81482: OR
81483: IFFALSE 81487
// exit ;
81485: GO 81512
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81487: LD_ADDR_EXP 87
81491: PUSH
81492: LD_EXP 87
81496: PPUSH
81497: LD_VAR 0 1
81501: PPUSH
81502: LD_VAR 0 2
81506: PPUSH
81507: CALL_OW 1
81511: ST_TO_ADDR
// end ;
81512: LD_VAR 0 3
81516: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81517: LD_INT 0
81519: PPUSH
// if not mc_bases or not parking_area or not base then
81520: LD_EXP 60
81524: NOT
81525: PUSH
81526: LD_VAR 0 2
81530: NOT
81531: OR
81532: PUSH
81533: LD_VAR 0 1
81537: NOT
81538: OR
81539: IFFALSE 81543
// exit ;
81541: GO 81568
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81543: LD_ADDR_EXP 84
81547: PUSH
81548: LD_EXP 84
81552: PPUSH
81553: LD_VAR 0 1
81557: PPUSH
81558: LD_VAR 0 2
81562: PPUSH
81563: CALL_OW 1
81567: ST_TO_ADDR
// end ;
81568: LD_VAR 0 3
81572: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81573: LD_INT 0
81575: PPUSH
// if not mc_bases or not base or not scan_area then
81576: LD_EXP 60
81580: NOT
81581: PUSH
81582: LD_VAR 0 1
81586: NOT
81587: OR
81588: PUSH
81589: LD_VAR 0 2
81593: NOT
81594: OR
81595: IFFALSE 81599
// exit ;
81597: GO 81624
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81599: LD_ADDR_EXP 85
81603: PUSH
81604: LD_EXP 85
81608: PPUSH
81609: LD_VAR 0 1
81613: PPUSH
81614: LD_VAR 0 2
81618: PPUSH
81619: CALL_OW 1
81623: ST_TO_ADDR
// end ;
81624: LD_VAR 0 3
81628: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81629: LD_INT 0
81631: PPUSH
81632: PPUSH
// if not mc_bases or not base then
81633: LD_EXP 60
81637: NOT
81638: PUSH
81639: LD_VAR 0 1
81643: NOT
81644: OR
81645: IFFALSE 81649
// exit ;
81647: GO 81713
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81649: LD_ADDR_VAR 0 3
81653: PUSH
81654: LD_INT 1
81656: PUSH
81657: LD_INT 2
81659: PUSH
81660: LD_INT 3
81662: PUSH
81663: LD_INT 4
81665: PUSH
81666: LD_INT 11
81668: PUSH
81669: EMPTY
81670: LIST
81671: LIST
81672: LIST
81673: LIST
81674: LIST
81675: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81676: LD_ADDR_EXP 87
81680: PUSH
81681: LD_EXP 87
81685: PPUSH
81686: LD_VAR 0 1
81690: PPUSH
81691: LD_EXP 87
81695: PUSH
81696: LD_VAR 0 1
81700: ARRAY
81701: PUSH
81702: LD_VAR 0 3
81706: DIFF
81707: PPUSH
81708: CALL_OW 1
81712: ST_TO_ADDR
// end ;
81713: LD_VAR 0 2
81717: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81718: LD_INT 0
81720: PPUSH
// result := mc_vehicles [ base ] ;
81721: LD_ADDR_VAR 0 3
81725: PUSH
81726: LD_EXP 79
81730: PUSH
81731: LD_VAR 0 1
81735: ARRAY
81736: ST_TO_ADDR
// if onlyCombat then
81737: LD_VAR 0 2
81741: IFFALSE 81919
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
81743: LD_ADDR_VAR 0 3
81747: PUSH
81748: LD_VAR 0 3
81752: PUSH
81753: LD_VAR 0 3
81757: PPUSH
81758: LD_INT 2
81760: PUSH
81761: LD_INT 34
81763: PUSH
81764: LD_INT 12
81766: PUSH
81767: EMPTY
81768: LIST
81769: LIST
81770: PUSH
81771: LD_INT 34
81773: PUSH
81774: LD_INT 51
81776: PUSH
81777: EMPTY
81778: LIST
81779: LIST
81780: PUSH
81781: LD_INT 34
81783: PUSH
81784: LD_EXP 105
81788: PUSH
81789: EMPTY
81790: LIST
81791: LIST
81792: PUSH
81793: LD_INT 34
81795: PUSH
81796: LD_INT 32
81798: PUSH
81799: EMPTY
81800: LIST
81801: LIST
81802: PUSH
81803: LD_INT 34
81805: PUSH
81806: LD_INT 13
81808: PUSH
81809: EMPTY
81810: LIST
81811: LIST
81812: PUSH
81813: LD_INT 34
81815: PUSH
81816: LD_INT 52
81818: PUSH
81819: EMPTY
81820: LIST
81821: LIST
81822: PUSH
81823: LD_INT 34
81825: PUSH
81826: LD_EXP 110
81830: PUSH
81831: EMPTY
81832: LIST
81833: LIST
81834: PUSH
81835: LD_INT 34
81837: PUSH
81838: LD_INT 14
81840: PUSH
81841: EMPTY
81842: LIST
81843: LIST
81844: PUSH
81845: LD_INT 34
81847: PUSH
81848: LD_INT 53
81850: PUSH
81851: EMPTY
81852: LIST
81853: LIST
81854: PUSH
81855: LD_INT 34
81857: PUSH
81858: LD_EXP 104
81862: PUSH
81863: EMPTY
81864: LIST
81865: LIST
81866: PUSH
81867: LD_INT 34
81869: PUSH
81870: LD_INT 31
81872: PUSH
81873: EMPTY
81874: LIST
81875: LIST
81876: PUSH
81877: LD_INT 34
81879: PUSH
81880: LD_INT 48
81882: PUSH
81883: EMPTY
81884: LIST
81885: LIST
81886: PUSH
81887: LD_INT 34
81889: PUSH
81890: LD_INT 8
81892: PUSH
81893: EMPTY
81894: LIST
81895: LIST
81896: PUSH
81897: EMPTY
81898: LIST
81899: LIST
81900: LIST
81901: LIST
81902: LIST
81903: LIST
81904: LIST
81905: LIST
81906: LIST
81907: LIST
81908: LIST
81909: LIST
81910: LIST
81911: LIST
81912: PPUSH
81913: CALL_OW 72
81917: DIFF
81918: ST_TO_ADDR
// end ; end_of_file
81919: LD_VAR 0 3
81923: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
81924: LD_INT 0
81926: PPUSH
81927: PPUSH
81928: PPUSH
// if not mc_bases or not skirmish then
81929: LD_EXP 60
81933: NOT
81934: PUSH
81935: LD_EXP 58
81939: NOT
81940: OR
81941: IFFALSE 81945
// exit ;
81943: GO 82110
// for i = 1 to mc_bases do
81945: LD_ADDR_VAR 0 4
81949: PUSH
81950: DOUBLE
81951: LD_INT 1
81953: DEC
81954: ST_TO_ADDR
81955: LD_EXP 60
81959: PUSH
81960: FOR_TO
81961: IFFALSE 82108
// begin if sci in mc_bases [ i ] then
81963: LD_VAR 0 2
81967: PUSH
81968: LD_EXP 60
81972: PUSH
81973: LD_VAR 0 4
81977: ARRAY
81978: IN
81979: IFFALSE 82106
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
81981: LD_ADDR_EXP 89
81985: PUSH
81986: LD_EXP 89
81990: PPUSH
81991: LD_VAR 0 4
81995: PUSH
81996: LD_EXP 89
82000: PUSH
82001: LD_VAR 0 4
82005: ARRAY
82006: PUSH
82007: LD_INT 1
82009: PLUS
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PPUSH
82015: LD_VAR 0 1
82019: PPUSH
82020: CALL 20003 0 3
82024: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82025: LD_ADDR_VAR 0 5
82029: PUSH
82030: LD_EXP 60
82034: PUSH
82035: LD_VAR 0 4
82039: ARRAY
82040: PPUSH
82041: LD_INT 2
82043: PUSH
82044: LD_INT 30
82046: PUSH
82047: LD_INT 0
82049: PUSH
82050: EMPTY
82051: LIST
82052: LIST
82053: PUSH
82054: LD_INT 30
82056: PUSH
82057: LD_INT 1
82059: PUSH
82060: EMPTY
82061: LIST
82062: LIST
82063: PUSH
82064: EMPTY
82065: LIST
82066: LIST
82067: LIST
82068: PPUSH
82069: CALL_OW 72
82073: PPUSH
82074: LD_VAR 0 1
82078: PPUSH
82079: CALL_OW 74
82083: ST_TO_ADDR
// if tmp then
82084: LD_VAR 0 5
82088: IFFALSE 82104
// ComStandNearbyBuilding ( ape , tmp ) ;
82090: LD_VAR 0 1
82094: PPUSH
82095: LD_VAR 0 5
82099: PPUSH
82100: CALL 16428 0 2
// break ;
82104: GO 82108
// end ; end ;
82106: GO 81960
82108: POP
82109: POP
// end ;
82110: LD_VAR 0 3
82114: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82115: LD_INT 0
82117: PPUSH
82118: PPUSH
82119: PPUSH
// if not mc_bases or not skirmish then
82120: LD_EXP 60
82124: NOT
82125: PUSH
82126: LD_EXP 58
82130: NOT
82131: OR
82132: IFFALSE 82136
// exit ;
82134: GO 82225
// for i = 1 to mc_bases do
82136: LD_ADDR_VAR 0 4
82140: PUSH
82141: DOUBLE
82142: LD_INT 1
82144: DEC
82145: ST_TO_ADDR
82146: LD_EXP 60
82150: PUSH
82151: FOR_TO
82152: IFFALSE 82223
// begin if building in mc_busy_turret_list [ i ] then
82154: LD_VAR 0 1
82158: PUSH
82159: LD_EXP 70
82163: PUSH
82164: LD_VAR 0 4
82168: ARRAY
82169: IN
82170: IFFALSE 82221
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82172: LD_ADDR_VAR 0 5
82176: PUSH
82177: LD_EXP 70
82181: PUSH
82182: LD_VAR 0 4
82186: ARRAY
82187: PUSH
82188: LD_VAR 0 1
82192: DIFF
82193: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82194: LD_ADDR_EXP 70
82198: PUSH
82199: LD_EXP 70
82203: PPUSH
82204: LD_VAR 0 4
82208: PPUSH
82209: LD_VAR 0 5
82213: PPUSH
82214: CALL_OW 1
82218: ST_TO_ADDR
// break ;
82219: GO 82223
// end ; end ;
82221: GO 82151
82223: POP
82224: POP
// end ;
82225: LD_VAR 0 3
82229: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82230: LD_INT 0
82232: PPUSH
82233: PPUSH
82234: PPUSH
// if not mc_bases or not skirmish then
82235: LD_EXP 60
82239: NOT
82240: PUSH
82241: LD_EXP 58
82245: NOT
82246: OR
82247: IFFALSE 82251
// exit ;
82249: GO 82450
// for i = 1 to mc_bases do
82251: LD_ADDR_VAR 0 5
82255: PUSH
82256: DOUBLE
82257: LD_INT 1
82259: DEC
82260: ST_TO_ADDR
82261: LD_EXP 60
82265: PUSH
82266: FOR_TO
82267: IFFALSE 82448
// if building in mc_bases [ i ] then
82269: LD_VAR 0 1
82273: PUSH
82274: LD_EXP 60
82278: PUSH
82279: LD_VAR 0 5
82283: ARRAY
82284: IN
82285: IFFALSE 82446
// begin tmp := mc_bases [ i ] diff building ;
82287: LD_ADDR_VAR 0 6
82291: PUSH
82292: LD_EXP 60
82296: PUSH
82297: LD_VAR 0 5
82301: ARRAY
82302: PUSH
82303: LD_VAR 0 1
82307: DIFF
82308: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82309: LD_ADDR_EXP 60
82313: PUSH
82314: LD_EXP 60
82318: PPUSH
82319: LD_VAR 0 5
82323: PPUSH
82324: LD_VAR 0 6
82328: PPUSH
82329: CALL_OW 1
82333: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82334: LD_VAR 0 1
82338: PUSH
82339: LD_EXP 68
82343: PUSH
82344: LD_VAR 0 5
82348: ARRAY
82349: IN
82350: IFFALSE 82389
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82352: LD_ADDR_EXP 68
82356: PUSH
82357: LD_EXP 68
82361: PPUSH
82362: LD_VAR 0 5
82366: PPUSH
82367: LD_EXP 68
82371: PUSH
82372: LD_VAR 0 5
82376: ARRAY
82377: PUSH
82378: LD_VAR 0 1
82382: DIFF
82383: PPUSH
82384: CALL_OW 1
82388: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82389: LD_VAR 0 1
82393: PUSH
82394: LD_EXP 69
82398: PUSH
82399: LD_VAR 0 5
82403: ARRAY
82404: IN
82405: IFFALSE 82444
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82407: LD_ADDR_EXP 69
82411: PUSH
82412: LD_EXP 69
82416: PPUSH
82417: LD_VAR 0 5
82421: PPUSH
82422: LD_EXP 69
82426: PUSH
82427: LD_VAR 0 5
82431: ARRAY
82432: PUSH
82433: LD_VAR 0 1
82437: DIFF
82438: PPUSH
82439: CALL_OW 1
82443: ST_TO_ADDR
// break ;
82444: GO 82448
// end ;
82446: GO 82266
82448: POP
82449: POP
// end ;
82450: LD_VAR 0 4
82454: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82455: LD_INT 0
82457: PPUSH
82458: PPUSH
82459: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82460: LD_EXP 60
82464: NOT
82465: PUSH
82466: LD_EXP 58
82470: NOT
82471: OR
82472: PUSH
82473: LD_VAR 0 3
82477: PUSH
82478: LD_EXP 86
82482: IN
82483: NOT
82484: OR
82485: IFFALSE 82489
// exit ;
82487: GO 82612
// for i = 1 to mc_vehicles do
82489: LD_ADDR_VAR 0 6
82493: PUSH
82494: DOUBLE
82495: LD_INT 1
82497: DEC
82498: ST_TO_ADDR
82499: LD_EXP 79
82503: PUSH
82504: FOR_TO
82505: IFFALSE 82610
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82507: LD_VAR 0 2
82511: PUSH
82512: LD_EXP 79
82516: PUSH
82517: LD_VAR 0 6
82521: ARRAY
82522: IN
82523: PUSH
82524: LD_VAR 0 1
82528: PUSH
82529: LD_EXP 79
82533: PUSH
82534: LD_VAR 0 6
82538: ARRAY
82539: IN
82540: OR
82541: IFFALSE 82608
// begin tmp := mc_vehicles [ i ] diff old ;
82543: LD_ADDR_VAR 0 7
82547: PUSH
82548: LD_EXP 79
82552: PUSH
82553: LD_VAR 0 6
82557: ARRAY
82558: PUSH
82559: LD_VAR 0 2
82563: DIFF
82564: ST_TO_ADDR
// tmp := tmp diff new ;
82565: LD_ADDR_VAR 0 7
82569: PUSH
82570: LD_VAR 0 7
82574: PUSH
82575: LD_VAR 0 1
82579: DIFF
82580: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82581: LD_ADDR_EXP 79
82585: PUSH
82586: LD_EXP 79
82590: PPUSH
82591: LD_VAR 0 6
82595: PPUSH
82596: LD_VAR 0 7
82600: PPUSH
82601: CALL_OW 1
82605: ST_TO_ADDR
// break ;
82606: GO 82610
// end ;
82608: GO 82504
82610: POP
82611: POP
// end ;
82612: LD_VAR 0 5
82616: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82617: LD_INT 0
82619: PPUSH
82620: PPUSH
82621: PPUSH
82622: PPUSH
// if not mc_bases or not skirmish then
82623: LD_EXP 60
82627: NOT
82628: PUSH
82629: LD_EXP 58
82633: NOT
82634: OR
82635: IFFALSE 82639
// exit ;
82637: GO 83031
// side := GetSide ( vehicle ) ;
82639: LD_ADDR_VAR 0 5
82643: PUSH
82644: LD_VAR 0 1
82648: PPUSH
82649: CALL_OW 255
82653: ST_TO_ADDR
// for i = 1 to mc_bases do
82654: LD_ADDR_VAR 0 4
82658: PUSH
82659: DOUBLE
82660: LD_INT 1
82662: DEC
82663: ST_TO_ADDR
82664: LD_EXP 60
82668: PUSH
82669: FOR_TO
82670: IFFALSE 83029
// begin if factory in mc_bases [ i ] then
82672: LD_VAR 0 2
82676: PUSH
82677: LD_EXP 60
82681: PUSH
82682: LD_VAR 0 4
82686: ARRAY
82687: IN
82688: IFFALSE 83027
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
82690: LD_EXP 82
82694: PUSH
82695: LD_VAR 0 4
82699: ARRAY
82700: PUSH
82701: LD_EXP 71
82705: PUSH
82706: LD_VAR 0 4
82710: ARRAY
82711: LESS
82712: PUSH
82713: LD_VAR 0 1
82717: PPUSH
82718: CALL_OW 264
82722: PUSH
82723: LD_INT 31
82725: PUSH
82726: LD_INT 32
82728: PUSH
82729: LD_INT 51
82731: PUSH
82732: LD_EXP 105
82736: PUSH
82737: LD_INT 12
82739: PUSH
82740: LD_INT 30
82742: PUSH
82743: LD_EXP 104
82747: PUSH
82748: LD_INT 11
82750: PUSH
82751: LD_INT 53
82753: PUSH
82754: LD_INT 14
82756: PUSH
82757: LD_EXP 108
82761: PUSH
82762: LD_INT 29
82764: PUSH
82765: LD_EXP 106
82769: PUSH
82770: LD_INT 13
82772: PUSH
82773: LD_INT 52
82775: PUSH
82776: LD_EXP 110
82780: PUSH
82781: LD_INT 48
82783: PUSH
82784: LD_INT 8
82786: PUSH
82787: EMPTY
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: LIST
82793: LIST
82794: LIST
82795: LIST
82796: LIST
82797: LIST
82798: LIST
82799: LIST
82800: LIST
82801: LIST
82802: LIST
82803: LIST
82804: LIST
82805: LIST
82806: IN
82807: NOT
82808: AND
82809: IFFALSE 82857
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
82811: LD_ADDR_EXP 82
82815: PUSH
82816: LD_EXP 82
82820: PPUSH
82821: LD_VAR 0 4
82825: PUSH
82826: LD_EXP 82
82830: PUSH
82831: LD_VAR 0 4
82835: ARRAY
82836: PUSH
82837: LD_INT 1
82839: PLUS
82840: PUSH
82841: EMPTY
82842: LIST
82843: LIST
82844: PPUSH
82845: LD_VAR 0 1
82849: PPUSH
82850: CALL 20003 0 3
82854: ST_TO_ADDR
82855: GO 82901
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
82857: LD_ADDR_EXP 79
82861: PUSH
82862: LD_EXP 79
82866: PPUSH
82867: LD_VAR 0 4
82871: PUSH
82872: LD_EXP 79
82876: PUSH
82877: LD_VAR 0 4
82881: ARRAY
82882: PUSH
82883: LD_INT 1
82885: PLUS
82886: PUSH
82887: EMPTY
82888: LIST
82889: LIST
82890: PPUSH
82891: LD_VAR 0 1
82895: PPUSH
82896: CALL 20003 0 3
82900: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
82901: LD_VAR 0 1
82905: PPUSH
82906: CALL_OW 263
82910: PUSH
82911: LD_INT 2
82913: EQUAL
82914: IFFALSE 82943
// begin repeat wait ( 0 0$3 ) ;
82916: LD_INT 105
82918: PPUSH
82919: CALL_OW 67
// Connect ( vehicle ) ;
82923: LD_VAR 0 1
82927: PPUSH
82928: CALL 22974 0 1
// until IsControledBy ( vehicle ) ;
82932: LD_VAR 0 1
82936: PPUSH
82937: CALL_OW 312
82941: IFFALSE 82916
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
82943: LD_VAR 0 1
82947: PPUSH
82948: LD_EXP 84
82952: PUSH
82953: LD_VAR 0 4
82957: ARRAY
82958: PPUSH
82959: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
82963: LD_VAR 0 1
82967: PPUSH
82968: CALL_OW 263
82972: PUSH
82973: LD_INT 1
82975: NONEQUAL
82976: IFFALSE 82980
// break ;
82978: GO 83029
// repeat wait ( 0 0$1 ) ;
82980: LD_INT 35
82982: PPUSH
82983: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
82987: LD_VAR 0 1
82991: PPUSH
82992: LD_EXP 84
82996: PUSH
82997: LD_VAR 0 4
83001: ARRAY
83002: PPUSH
83003: CALL_OW 308
83007: IFFALSE 82980
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83009: LD_VAR 0 1
83013: PPUSH
83014: CALL_OW 311
83018: PPUSH
83019: CALL_OW 121
// exit ;
83023: POP
83024: POP
83025: GO 83031
// end ; end ;
83027: GO 82669
83029: POP
83030: POP
// end ;
83031: LD_VAR 0 3
83035: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83036: LD_INT 0
83038: PPUSH
83039: PPUSH
83040: PPUSH
83041: PPUSH
// if not mc_bases or not skirmish then
83042: LD_EXP 60
83046: NOT
83047: PUSH
83048: LD_EXP 58
83052: NOT
83053: OR
83054: IFFALSE 83058
// exit ;
83056: GO 83411
// repeat wait ( 0 0$1 ) ;
83058: LD_INT 35
83060: PPUSH
83061: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83065: LD_VAR 0 2
83069: PPUSH
83070: LD_VAR 0 3
83074: PPUSH
83075: CALL_OW 284
83079: IFFALSE 83058
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83081: LD_VAR 0 2
83085: PPUSH
83086: LD_VAR 0 3
83090: PPUSH
83091: CALL_OW 283
83095: PUSH
83096: LD_INT 4
83098: EQUAL
83099: IFFALSE 83103
// exit ;
83101: GO 83411
// for i = 1 to mc_bases do
83103: LD_ADDR_VAR 0 7
83107: PUSH
83108: DOUBLE
83109: LD_INT 1
83111: DEC
83112: ST_TO_ADDR
83113: LD_EXP 60
83117: PUSH
83118: FOR_TO
83119: IFFALSE 83409
// begin if mc_crates_area [ i ] then
83121: LD_EXP 78
83125: PUSH
83126: LD_VAR 0 7
83130: ARRAY
83131: IFFALSE 83242
// for j in mc_crates_area [ i ] do
83133: LD_ADDR_VAR 0 8
83137: PUSH
83138: LD_EXP 78
83142: PUSH
83143: LD_VAR 0 7
83147: ARRAY
83148: PUSH
83149: FOR_IN
83150: IFFALSE 83240
// if InArea ( x , y , j ) then
83152: LD_VAR 0 2
83156: PPUSH
83157: LD_VAR 0 3
83161: PPUSH
83162: LD_VAR 0 8
83166: PPUSH
83167: CALL_OW 309
83171: IFFALSE 83238
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83173: LD_ADDR_EXP 76
83177: PUSH
83178: LD_EXP 76
83182: PPUSH
83183: LD_VAR 0 7
83187: PUSH
83188: LD_EXP 76
83192: PUSH
83193: LD_VAR 0 7
83197: ARRAY
83198: PUSH
83199: LD_INT 1
83201: PLUS
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: PPUSH
83207: LD_VAR 0 4
83211: PUSH
83212: LD_VAR 0 2
83216: PUSH
83217: LD_VAR 0 3
83221: PUSH
83222: EMPTY
83223: LIST
83224: LIST
83225: LIST
83226: PPUSH
83227: CALL 20003 0 3
83231: ST_TO_ADDR
// exit ;
83232: POP
83233: POP
83234: POP
83235: POP
83236: GO 83411
// end ;
83238: GO 83149
83240: POP
83241: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83242: LD_ADDR_VAR 0 9
83246: PUSH
83247: LD_EXP 60
83251: PUSH
83252: LD_VAR 0 7
83256: ARRAY
83257: PPUSH
83258: LD_INT 2
83260: PUSH
83261: LD_INT 30
83263: PUSH
83264: LD_INT 0
83266: PUSH
83267: EMPTY
83268: LIST
83269: LIST
83270: PUSH
83271: LD_INT 30
83273: PUSH
83274: LD_INT 1
83276: PUSH
83277: EMPTY
83278: LIST
83279: LIST
83280: PUSH
83281: EMPTY
83282: LIST
83283: LIST
83284: LIST
83285: PPUSH
83286: CALL_OW 72
83290: ST_TO_ADDR
// if not depot then
83291: LD_VAR 0 9
83295: NOT
83296: IFFALSE 83300
// continue ;
83298: GO 83118
// for j in depot do
83300: LD_ADDR_VAR 0 8
83304: PUSH
83305: LD_VAR 0 9
83309: PUSH
83310: FOR_IN
83311: IFFALSE 83405
// if GetDistUnitXY ( j , x , y ) < 30 then
83313: LD_VAR 0 8
83317: PPUSH
83318: LD_VAR 0 2
83322: PPUSH
83323: LD_VAR 0 3
83327: PPUSH
83328: CALL_OW 297
83332: PUSH
83333: LD_INT 30
83335: LESS
83336: IFFALSE 83403
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83338: LD_ADDR_EXP 76
83342: PUSH
83343: LD_EXP 76
83347: PPUSH
83348: LD_VAR 0 7
83352: PUSH
83353: LD_EXP 76
83357: PUSH
83358: LD_VAR 0 7
83362: ARRAY
83363: PUSH
83364: LD_INT 1
83366: PLUS
83367: PUSH
83368: EMPTY
83369: LIST
83370: LIST
83371: PPUSH
83372: LD_VAR 0 4
83376: PUSH
83377: LD_VAR 0 2
83381: PUSH
83382: LD_VAR 0 3
83386: PUSH
83387: EMPTY
83388: LIST
83389: LIST
83390: LIST
83391: PPUSH
83392: CALL 20003 0 3
83396: ST_TO_ADDR
// exit ;
83397: POP
83398: POP
83399: POP
83400: POP
83401: GO 83411
// end ;
83403: GO 83310
83405: POP
83406: POP
// end ;
83407: GO 83118
83409: POP
83410: POP
// end ;
83411: LD_VAR 0 6
83415: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83416: LD_INT 0
83418: PPUSH
83419: PPUSH
83420: PPUSH
83421: PPUSH
// if not mc_bases or not skirmish then
83422: LD_EXP 60
83426: NOT
83427: PUSH
83428: LD_EXP 58
83432: NOT
83433: OR
83434: IFFALSE 83438
// exit ;
83436: GO 83715
// side := GetSide ( lab ) ;
83438: LD_ADDR_VAR 0 4
83442: PUSH
83443: LD_VAR 0 2
83447: PPUSH
83448: CALL_OW 255
83452: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83453: LD_VAR 0 4
83457: PUSH
83458: LD_EXP 86
83462: IN
83463: NOT
83464: PUSH
83465: LD_EXP 87
83469: NOT
83470: OR
83471: PUSH
83472: LD_EXP 60
83476: NOT
83477: OR
83478: IFFALSE 83482
// exit ;
83480: GO 83715
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83482: LD_ADDR_EXP 87
83486: PUSH
83487: LD_EXP 87
83491: PPUSH
83492: LD_VAR 0 4
83496: PPUSH
83497: LD_EXP 87
83501: PUSH
83502: LD_VAR 0 4
83506: ARRAY
83507: PUSH
83508: LD_VAR 0 1
83512: DIFF
83513: PPUSH
83514: CALL_OW 1
83518: ST_TO_ADDR
// for i = 1 to mc_bases do
83519: LD_ADDR_VAR 0 5
83523: PUSH
83524: DOUBLE
83525: LD_INT 1
83527: DEC
83528: ST_TO_ADDR
83529: LD_EXP 60
83533: PUSH
83534: FOR_TO
83535: IFFALSE 83713
// begin if lab in mc_bases [ i ] then
83537: LD_VAR 0 2
83541: PUSH
83542: LD_EXP 60
83546: PUSH
83547: LD_VAR 0 5
83551: ARRAY
83552: IN
83553: IFFALSE 83711
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83555: LD_VAR 0 1
83559: PUSH
83560: LD_INT 11
83562: PUSH
83563: LD_INT 4
83565: PUSH
83566: LD_INT 3
83568: PUSH
83569: LD_INT 2
83571: PUSH
83572: EMPTY
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: IN
83578: PUSH
83579: LD_EXP 90
83583: PUSH
83584: LD_VAR 0 5
83588: ARRAY
83589: AND
83590: IFFALSE 83711
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83592: LD_ADDR_VAR 0 6
83596: PUSH
83597: LD_EXP 90
83601: PUSH
83602: LD_VAR 0 5
83606: ARRAY
83607: PUSH
83608: LD_INT 1
83610: ARRAY
83611: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83612: LD_ADDR_EXP 90
83616: PUSH
83617: LD_EXP 90
83621: PPUSH
83622: LD_VAR 0 5
83626: PPUSH
83627: EMPTY
83628: PPUSH
83629: CALL_OW 1
83633: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83634: LD_VAR 0 6
83638: PPUSH
83639: LD_INT 0
83641: PPUSH
83642: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83646: LD_VAR 0 6
83650: PPUSH
83651: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83655: LD_ADDR_EXP 89
83659: PUSH
83660: LD_EXP 89
83664: PPUSH
83665: LD_VAR 0 5
83669: PPUSH
83670: LD_EXP 89
83674: PUSH
83675: LD_VAR 0 5
83679: ARRAY
83680: PPUSH
83681: LD_INT 1
83683: PPUSH
83684: LD_VAR 0 6
83688: PPUSH
83689: CALL_OW 2
83693: PPUSH
83694: CALL_OW 1
83698: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83699: LD_VAR 0 5
83703: PPUSH
83704: LD_INT 112
83706: PPUSH
83707: CALL 60234 0 2
// end ; end ; end ;
83711: GO 83534
83713: POP
83714: POP
// end ;
83715: LD_VAR 0 3
83719: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83720: LD_INT 0
83722: PPUSH
83723: PPUSH
83724: PPUSH
83725: PPUSH
83726: PPUSH
83727: PPUSH
83728: PPUSH
83729: PPUSH
// if not mc_bases or not skirmish then
83730: LD_EXP 60
83734: NOT
83735: PUSH
83736: LD_EXP 58
83740: NOT
83741: OR
83742: IFFALSE 83746
// exit ;
83744: GO 85117
// for i = 1 to mc_bases do
83746: LD_ADDR_VAR 0 3
83750: PUSH
83751: DOUBLE
83752: LD_INT 1
83754: DEC
83755: ST_TO_ADDR
83756: LD_EXP 60
83760: PUSH
83761: FOR_TO
83762: IFFALSE 85115
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83764: LD_VAR 0 1
83768: PUSH
83769: LD_EXP 60
83773: PUSH
83774: LD_VAR 0 3
83778: ARRAY
83779: IN
83780: PUSH
83781: LD_VAR 0 1
83785: PUSH
83786: LD_EXP 67
83790: PUSH
83791: LD_VAR 0 3
83795: ARRAY
83796: IN
83797: OR
83798: PUSH
83799: LD_VAR 0 1
83803: PUSH
83804: LD_EXP 82
83808: PUSH
83809: LD_VAR 0 3
83813: ARRAY
83814: IN
83815: OR
83816: PUSH
83817: LD_VAR 0 1
83821: PUSH
83822: LD_EXP 79
83826: PUSH
83827: LD_VAR 0 3
83831: ARRAY
83832: IN
83833: OR
83834: PUSH
83835: LD_VAR 0 1
83839: PUSH
83840: LD_EXP 89
83844: PUSH
83845: LD_VAR 0 3
83849: ARRAY
83850: IN
83851: OR
83852: PUSH
83853: LD_VAR 0 1
83857: PUSH
83858: LD_EXP 90
83862: PUSH
83863: LD_VAR 0 3
83867: ARRAY
83868: IN
83869: OR
83870: IFFALSE 85113
// begin if un in mc_ape [ i ] then
83872: LD_VAR 0 1
83876: PUSH
83877: LD_EXP 89
83881: PUSH
83882: LD_VAR 0 3
83886: ARRAY
83887: IN
83888: IFFALSE 83927
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
83890: LD_ADDR_EXP 89
83894: PUSH
83895: LD_EXP 89
83899: PPUSH
83900: LD_VAR 0 3
83904: PPUSH
83905: LD_EXP 89
83909: PUSH
83910: LD_VAR 0 3
83914: ARRAY
83915: PUSH
83916: LD_VAR 0 1
83920: DIFF
83921: PPUSH
83922: CALL_OW 1
83926: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
83927: LD_VAR 0 1
83931: PUSH
83932: LD_EXP 90
83936: PUSH
83937: LD_VAR 0 3
83941: ARRAY
83942: IN
83943: IFFALSE 83967
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83945: LD_ADDR_EXP 90
83949: PUSH
83950: LD_EXP 90
83954: PPUSH
83955: LD_VAR 0 3
83959: PPUSH
83960: EMPTY
83961: PPUSH
83962: CALL_OW 1
83966: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
83967: LD_VAR 0 1
83971: PPUSH
83972: CALL_OW 247
83976: PUSH
83977: LD_INT 2
83979: EQUAL
83980: PUSH
83981: LD_VAR 0 1
83985: PPUSH
83986: CALL_OW 110
83990: PUSH
83991: LD_INT 20
83993: EQUAL
83994: PUSH
83995: LD_VAR 0 1
83999: PUSH
84000: LD_EXP 82
84004: PUSH
84005: LD_VAR 0 3
84009: ARRAY
84010: IN
84011: OR
84012: PUSH
84013: LD_VAR 0 1
84017: PPUSH
84018: CALL_OW 264
84022: PUSH
84023: LD_INT 12
84025: PUSH
84026: LD_INT 51
84028: PUSH
84029: LD_EXP 105
84033: PUSH
84034: LD_INT 32
84036: PUSH
84037: LD_INT 13
84039: PUSH
84040: LD_INT 52
84042: PUSH
84043: LD_INT 31
84045: PUSH
84046: EMPTY
84047: LIST
84048: LIST
84049: LIST
84050: LIST
84051: LIST
84052: LIST
84053: LIST
84054: IN
84055: OR
84056: AND
84057: IFFALSE 84365
// begin if un in mc_defender [ i ] then
84059: LD_VAR 0 1
84063: PUSH
84064: LD_EXP 82
84068: PUSH
84069: LD_VAR 0 3
84073: ARRAY
84074: IN
84075: IFFALSE 84114
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84077: LD_ADDR_EXP 82
84081: PUSH
84082: LD_EXP 82
84086: PPUSH
84087: LD_VAR 0 3
84091: PPUSH
84092: LD_EXP 82
84096: PUSH
84097: LD_VAR 0 3
84101: ARRAY
84102: PUSH
84103: LD_VAR 0 1
84107: DIFF
84108: PPUSH
84109: CALL_OW 1
84113: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84114: LD_ADDR_VAR 0 8
84118: PUSH
84119: LD_VAR 0 3
84123: PPUSH
84124: LD_INT 3
84126: PPUSH
84127: CALL 80755 0 2
84131: ST_TO_ADDR
// if fac then
84132: LD_VAR 0 8
84136: IFFALSE 84365
// begin for j in fac do
84138: LD_ADDR_VAR 0 4
84142: PUSH
84143: LD_VAR 0 8
84147: PUSH
84148: FOR_IN
84149: IFFALSE 84363
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84151: LD_ADDR_VAR 0 9
84155: PUSH
84156: LD_VAR 0 8
84160: PPUSH
84161: LD_VAR 0 1
84165: PPUSH
84166: CALL_OW 265
84170: PPUSH
84171: LD_VAR 0 1
84175: PPUSH
84176: CALL_OW 262
84180: PPUSH
84181: LD_VAR 0 1
84185: PPUSH
84186: CALL_OW 263
84190: PPUSH
84191: LD_VAR 0 1
84195: PPUSH
84196: CALL_OW 264
84200: PPUSH
84201: CALL 17499 0 5
84205: ST_TO_ADDR
// if components then
84206: LD_VAR 0 9
84210: IFFALSE 84361
// begin if GetWeapon ( un ) = ar_control_tower then
84212: LD_VAR 0 1
84216: PPUSH
84217: CALL_OW 264
84221: PUSH
84222: LD_INT 31
84224: EQUAL
84225: IFFALSE 84342
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84227: LD_VAR 0 1
84231: PPUSH
84232: CALL_OW 311
84236: PPUSH
84237: LD_INT 0
84239: PPUSH
84240: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84244: LD_ADDR_EXP 100
84248: PUSH
84249: LD_EXP 100
84253: PPUSH
84254: LD_VAR 0 3
84258: PPUSH
84259: LD_EXP 100
84263: PUSH
84264: LD_VAR 0 3
84268: ARRAY
84269: PUSH
84270: LD_VAR 0 1
84274: PPUSH
84275: CALL_OW 311
84279: DIFF
84280: PPUSH
84281: CALL_OW 1
84285: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84286: LD_ADDR_VAR 0 7
84290: PUSH
84291: LD_EXP 81
84295: PUSH
84296: LD_VAR 0 3
84300: ARRAY
84301: PPUSH
84302: LD_INT 1
84304: PPUSH
84305: LD_VAR 0 9
84309: PPUSH
84310: CALL_OW 2
84314: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84315: LD_ADDR_EXP 81
84319: PUSH
84320: LD_EXP 81
84324: PPUSH
84325: LD_VAR 0 3
84329: PPUSH
84330: LD_VAR 0 7
84334: PPUSH
84335: CALL_OW 1
84339: ST_TO_ADDR
// end else
84340: GO 84359
// MC_InsertProduceList ( i , [ components ] ) ;
84342: LD_VAR 0 3
84346: PPUSH
84347: LD_VAR 0 9
84351: PUSH
84352: EMPTY
84353: LIST
84354: PPUSH
84355: CALL 80300 0 2
// break ;
84359: GO 84363
// end ; end ;
84361: GO 84148
84363: POP
84364: POP
// end ; end ; if GetType ( un ) = unit_building then
84365: LD_VAR 0 1
84369: PPUSH
84370: CALL_OW 247
84374: PUSH
84375: LD_INT 3
84377: EQUAL
84378: IFFALSE 84781
// begin btype := GetBType ( un ) ;
84380: LD_ADDR_VAR 0 5
84384: PUSH
84385: LD_VAR 0 1
84389: PPUSH
84390: CALL_OW 266
84394: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84395: LD_VAR 0 5
84399: PUSH
84400: LD_INT 29
84402: PUSH
84403: LD_INT 30
84405: PUSH
84406: EMPTY
84407: LIST
84408: LIST
84409: IN
84410: IFFALSE 84483
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84412: LD_VAR 0 1
84416: PPUSH
84417: CALL_OW 250
84421: PPUSH
84422: LD_VAR 0 1
84426: PPUSH
84427: CALL_OW 251
84431: PPUSH
84432: LD_VAR 0 1
84436: PPUSH
84437: CALL_OW 255
84441: PPUSH
84442: CALL_OW 440
84446: NOT
84447: IFFALSE 84483
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84449: LD_VAR 0 1
84453: PPUSH
84454: CALL_OW 250
84458: PPUSH
84459: LD_VAR 0 1
84463: PPUSH
84464: CALL_OW 251
84468: PPUSH
84469: LD_VAR 0 1
84473: PPUSH
84474: CALL_OW 255
84478: PPUSH
84479: CALL_OW 441
// end ; if btype = b_warehouse then
84483: LD_VAR 0 5
84487: PUSH
84488: LD_INT 1
84490: EQUAL
84491: IFFALSE 84509
// begin btype := b_depot ;
84493: LD_ADDR_VAR 0 5
84497: PUSH
84498: LD_INT 0
84500: ST_TO_ADDR
// pos := 1 ;
84501: LD_ADDR_VAR 0 6
84505: PUSH
84506: LD_INT 1
84508: ST_TO_ADDR
// end ; if btype = b_factory then
84509: LD_VAR 0 5
84513: PUSH
84514: LD_INT 3
84516: EQUAL
84517: IFFALSE 84535
// begin btype := b_workshop ;
84519: LD_ADDR_VAR 0 5
84523: PUSH
84524: LD_INT 2
84526: ST_TO_ADDR
// pos := 1 ;
84527: LD_ADDR_VAR 0 6
84531: PUSH
84532: LD_INT 1
84534: ST_TO_ADDR
// end ; if btype = b_barracks then
84535: LD_VAR 0 5
84539: PUSH
84540: LD_INT 5
84542: EQUAL
84543: IFFALSE 84553
// btype := b_armoury ;
84545: LD_ADDR_VAR 0 5
84549: PUSH
84550: LD_INT 4
84552: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84553: LD_VAR 0 5
84557: PUSH
84558: LD_INT 7
84560: PUSH
84561: LD_INT 8
84563: PUSH
84564: EMPTY
84565: LIST
84566: LIST
84567: IN
84568: IFFALSE 84578
// btype := b_lab ;
84570: LD_ADDR_VAR 0 5
84574: PUSH
84575: LD_INT 6
84577: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84578: LD_ADDR_EXP 65
84582: PUSH
84583: LD_EXP 65
84587: PPUSH
84588: LD_VAR 0 3
84592: PUSH
84593: LD_EXP 65
84597: PUSH
84598: LD_VAR 0 3
84602: ARRAY
84603: PUSH
84604: LD_INT 1
84606: PLUS
84607: PUSH
84608: EMPTY
84609: LIST
84610: LIST
84611: PPUSH
84612: LD_VAR 0 5
84616: PUSH
84617: LD_VAR 0 1
84621: PPUSH
84622: CALL_OW 250
84626: PUSH
84627: LD_VAR 0 1
84631: PPUSH
84632: CALL_OW 251
84636: PUSH
84637: LD_VAR 0 1
84641: PPUSH
84642: CALL_OW 254
84646: PUSH
84647: EMPTY
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: PPUSH
84653: CALL 20003 0 3
84657: ST_TO_ADDR
// if pos = 1 then
84658: LD_VAR 0 6
84662: PUSH
84663: LD_INT 1
84665: EQUAL
84666: IFFALSE 84781
// begin tmp := mc_build_list [ i ] ;
84668: LD_ADDR_VAR 0 7
84672: PUSH
84673: LD_EXP 65
84677: PUSH
84678: LD_VAR 0 3
84682: ARRAY
84683: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84684: LD_VAR 0 7
84688: PPUSH
84689: LD_INT 2
84691: PUSH
84692: LD_INT 30
84694: PUSH
84695: LD_INT 0
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: PUSH
84702: LD_INT 30
84704: PUSH
84705: LD_INT 1
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PUSH
84712: EMPTY
84713: LIST
84714: LIST
84715: LIST
84716: PPUSH
84717: CALL_OW 72
84721: IFFALSE 84731
// pos := 2 ;
84723: LD_ADDR_VAR 0 6
84727: PUSH
84728: LD_INT 2
84730: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84731: LD_ADDR_VAR 0 7
84735: PUSH
84736: LD_VAR 0 7
84740: PPUSH
84741: LD_VAR 0 6
84745: PPUSH
84746: LD_VAR 0 7
84750: PPUSH
84751: CALL 20329 0 3
84755: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84756: LD_ADDR_EXP 65
84760: PUSH
84761: LD_EXP 65
84765: PPUSH
84766: LD_VAR 0 3
84770: PPUSH
84771: LD_VAR 0 7
84775: PPUSH
84776: CALL_OW 1
84780: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84781: LD_VAR 0 1
84785: PUSH
84786: LD_EXP 60
84790: PUSH
84791: LD_VAR 0 3
84795: ARRAY
84796: IN
84797: IFFALSE 84836
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84799: LD_ADDR_EXP 60
84803: PUSH
84804: LD_EXP 60
84808: PPUSH
84809: LD_VAR 0 3
84813: PPUSH
84814: LD_EXP 60
84818: PUSH
84819: LD_VAR 0 3
84823: ARRAY
84824: PUSH
84825: LD_VAR 0 1
84829: DIFF
84830: PPUSH
84831: CALL_OW 1
84835: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
84836: LD_VAR 0 1
84840: PUSH
84841: LD_EXP 67
84845: PUSH
84846: LD_VAR 0 3
84850: ARRAY
84851: IN
84852: IFFALSE 84891
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84854: LD_ADDR_EXP 67
84858: PUSH
84859: LD_EXP 67
84863: PPUSH
84864: LD_VAR 0 3
84868: PPUSH
84869: LD_EXP 67
84873: PUSH
84874: LD_VAR 0 3
84878: ARRAY
84879: PUSH
84880: LD_VAR 0 1
84884: DIFF
84885: PPUSH
84886: CALL_OW 1
84890: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84891: LD_VAR 0 1
84895: PUSH
84896: LD_EXP 79
84900: PUSH
84901: LD_VAR 0 3
84905: ARRAY
84906: IN
84907: IFFALSE 84946
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
84909: LD_ADDR_EXP 79
84913: PUSH
84914: LD_EXP 79
84918: PPUSH
84919: LD_VAR 0 3
84923: PPUSH
84924: LD_EXP 79
84928: PUSH
84929: LD_VAR 0 3
84933: ARRAY
84934: PUSH
84935: LD_VAR 0 1
84939: DIFF
84940: PPUSH
84941: CALL_OW 1
84945: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
84946: LD_VAR 0 1
84950: PUSH
84951: LD_EXP 82
84955: PUSH
84956: LD_VAR 0 3
84960: ARRAY
84961: IN
84962: IFFALSE 85001
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84964: LD_ADDR_EXP 82
84968: PUSH
84969: LD_EXP 82
84973: PPUSH
84974: LD_VAR 0 3
84978: PPUSH
84979: LD_EXP 82
84983: PUSH
84984: LD_VAR 0 3
84988: ARRAY
84989: PUSH
84990: LD_VAR 0 1
84994: DIFF
84995: PPUSH
84996: CALL_OW 1
85000: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85001: LD_VAR 0 1
85005: PUSH
85006: LD_EXP 69
85010: PUSH
85011: LD_VAR 0 3
85015: ARRAY
85016: IN
85017: IFFALSE 85056
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85019: LD_ADDR_EXP 69
85023: PUSH
85024: LD_EXP 69
85028: PPUSH
85029: LD_VAR 0 3
85033: PPUSH
85034: LD_EXP 69
85038: PUSH
85039: LD_VAR 0 3
85043: ARRAY
85044: PUSH
85045: LD_VAR 0 1
85049: DIFF
85050: PPUSH
85051: CALL_OW 1
85055: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85056: LD_VAR 0 1
85060: PUSH
85061: LD_EXP 68
85065: PUSH
85066: LD_VAR 0 3
85070: ARRAY
85071: IN
85072: IFFALSE 85111
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85074: LD_ADDR_EXP 68
85078: PUSH
85079: LD_EXP 68
85083: PPUSH
85084: LD_VAR 0 3
85088: PPUSH
85089: LD_EXP 68
85093: PUSH
85094: LD_VAR 0 3
85098: ARRAY
85099: PUSH
85100: LD_VAR 0 1
85104: DIFF
85105: PPUSH
85106: CALL_OW 1
85110: ST_TO_ADDR
// end ; break ;
85111: GO 85115
// end ;
85113: GO 83761
85115: POP
85116: POP
// end ;
85117: LD_VAR 0 2
85121: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85122: LD_INT 0
85124: PPUSH
85125: PPUSH
85126: PPUSH
// if not mc_bases or not skirmish then
85127: LD_EXP 60
85131: NOT
85132: PUSH
85133: LD_EXP 58
85137: NOT
85138: OR
85139: IFFALSE 85143
// exit ;
85141: GO 85358
// for i = 1 to mc_bases do
85143: LD_ADDR_VAR 0 3
85147: PUSH
85148: DOUBLE
85149: LD_INT 1
85151: DEC
85152: ST_TO_ADDR
85153: LD_EXP 60
85157: PUSH
85158: FOR_TO
85159: IFFALSE 85356
// begin if building in mc_construct_list [ i ] then
85161: LD_VAR 0 1
85165: PUSH
85166: LD_EXP 67
85170: PUSH
85171: LD_VAR 0 3
85175: ARRAY
85176: IN
85177: IFFALSE 85354
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85179: LD_ADDR_EXP 67
85183: PUSH
85184: LD_EXP 67
85188: PPUSH
85189: LD_VAR 0 3
85193: PPUSH
85194: LD_EXP 67
85198: PUSH
85199: LD_VAR 0 3
85203: ARRAY
85204: PUSH
85205: LD_VAR 0 1
85209: DIFF
85210: PPUSH
85211: CALL_OW 1
85215: ST_TO_ADDR
// if building in mc_lab [ i ] then
85216: LD_VAR 0 1
85220: PUSH
85221: LD_EXP 93
85225: PUSH
85226: LD_VAR 0 3
85230: ARRAY
85231: IN
85232: IFFALSE 85287
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85234: LD_ADDR_EXP 94
85238: PUSH
85239: LD_EXP 94
85243: PPUSH
85244: LD_VAR 0 3
85248: PPUSH
85249: LD_EXP 94
85253: PUSH
85254: LD_VAR 0 3
85258: ARRAY
85259: PPUSH
85260: LD_INT 1
85262: PPUSH
85263: LD_EXP 94
85267: PUSH
85268: LD_VAR 0 3
85272: ARRAY
85273: PPUSH
85274: LD_INT 0
85276: PPUSH
85277: CALL 19421 0 4
85281: PPUSH
85282: CALL_OW 1
85286: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85287: LD_VAR 0 1
85291: PUSH
85292: LD_EXP 60
85296: PUSH
85297: LD_VAR 0 3
85301: ARRAY
85302: IN
85303: NOT
85304: IFFALSE 85350
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85306: LD_ADDR_EXP 60
85310: PUSH
85311: LD_EXP 60
85315: PPUSH
85316: LD_VAR 0 3
85320: PUSH
85321: LD_EXP 60
85325: PUSH
85326: LD_VAR 0 3
85330: ARRAY
85331: PUSH
85332: LD_INT 1
85334: PLUS
85335: PUSH
85336: EMPTY
85337: LIST
85338: LIST
85339: PPUSH
85340: LD_VAR 0 1
85344: PPUSH
85345: CALL 20003 0 3
85349: ST_TO_ADDR
// exit ;
85350: POP
85351: POP
85352: GO 85358
// end ; end ;
85354: GO 85158
85356: POP
85357: POP
// end ;
85358: LD_VAR 0 2
85362: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85363: LD_INT 0
85365: PPUSH
85366: PPUSH
85367: PPUSH
85368: PPUSH
85369: PPUSH
85370: PPUSH
85371: PPUSH
// if not mc_bases or not skirmish then
85372: LD_EXP 60
85376: NOT
85377: PUSH
85378: LD_EXP 58
85382: NOT
85383: OR
85384: IFFALSE 85388
// exit ;
85386: GO 86049
// for i = 1 to mc_bases do
85388: LD_ADDR_VAR 0 3
85392: PUSH
85393: DOUBLE
85394: LD_INT 1
85396: DEC
85397: ST_TO_ADDR
85398: LD_EXP 60
85402: PUSH
85403: FOR_TO
85404: IFFALSE 86047
// begin if building in mc_construct_list [ i ] then
85406: LD_VAR 0 1
85410: PUSH
85411: LD_EXP 67
85415: PUSH
85416: LD_VAR 0 3
85420: ARRAY
85421: IN
85422: IFFALSE 86045
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85424: LD_ADDR_EXP 67
85428: PUSH
85429: LD_EXP 67
85433: PPUSH
85434: LD_VAR 0 3
85438: PPUSH
85439: LD_EXP 67
85443: PUSH
85444: LD_VAR 0 3
85448: ARRAY
85449: PUSH
85450: LD_VAR 0 1
85454: DIFF
85455: PPUSH
85456: CALL_OW 1
85460: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85461: LD_ADDR_EXP 60
85465: PUSH
85466: LD_EXP 60
85470: PPUSH
85471: LD_VAR 0 3
85475: PUSH
85476: LD_EXP 60
85480: PUSH
85481: LD_VAR 0 3
85485: ARRAY
85486: PUSH
85487: LD_INT 1
85489: PLUS
85490: PUSH
85491: EMPTY
85492: LIST
85493: LIST
85494: PPUSH
85495: LD_VAR 0 1
85499: PPUSH
85500: CALL 20003 0 3
85504: ST_TO_ADDR
// btype := GetBType ( building ) ;
85505: LD_ADDR_VAR 0 5
85509: PUSH
85510: LD_VAR 0 1
85514: PPUSH
85515: CALL_OW 266
85519: ST_TO_ADDR
// side := GetSide ( building ) ;
85520: LD_ADDR_VAR 0 8
85524: PUSH
85525: LD_VAR 0 1
85529: PPUSH
85530: CALL_OW 255
85534: ST_TO_ADDR
// if btype = b_lab then
85535: LD_VAR 0 5
85539: PUSH
85540: LD_INT 6
85542: EQUAL
85543: IFFALSE 85593
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85545: LD_ADDR_EXP 93
85549: PUSH
85550: LD_EXP 93
85554: PPUSH
85555: LD_VAR 0 3
85559: PUSH
85560: LD_EXP 93
85564: PUSH
85565: LD_VAR 0 3
85569: ARRAY
85570: PUSH
85571: LD_INT 1
85573: PLUS
85574: PUSH
85575: EMPTY
85576: LIST
85577: LIST
85578: PPUSH
85579: LD_VAR 0 1
85583: PPUSH
85584: CALL 20003 0 3
85588: ST_TO_ADDR
// exit ;
85589: POP
85590: POP
85591: GO 86049
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85593: LD_VAR 0 5
85597: PUSH
85598: LD_INT 0
85600: PUSH
85601: LD_INT 2
85603: PUSH
85604: LD_INT 4
85606: PUSH
85607: EMPTY
85608: LIST
85609: LIST
85610: LIST
85611: IN
85612: IFFALSE 85736
// begin if btype = b_armoury then
85614: LD_VAR 0 5
85618: PUSH
85619: LD_INT 4
85621: EQUAL
85622: IFFALSE 85632
// btype := b_barracks ;
85624: LD_ADDR_VAR 0 5
85628: PUSH
85629: LD_INT 5
85631: ST_TO_ADDR
// if btype = b_depot then
85632: LD_VAR 0 5
85636: PUSH
85637: LD_INT 0
85639: EQUAL
85640: IFFALSE 85650
// btype := b_warehouse ;
85642: LD_ADDR_VAR 0 5
85646: PUSH
85647: LD_INT 1
85649: ST_TO_ADDR
// if btype = b_workshop then
85650: LD_VAR 0 5
85654: PUSH
85655: LD_INT 2
85657: EQUAL
85658: IFFALSE 85668
// btype := b_factory ;
85660: LD_ADDR_VAR 0 5
85664: PUSH
85665: LD_INT 3
85667: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85668: LD_VAR 0 5
85672: PPUSH
85673: LD_VAR 0 8
85677: PPUSH
85678: CALL_OW 323
85682: PUSH
85683: LD_INT 1
85685: EQUAL
85686: IFFALSE 85732
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85688: LD_ADDR_EXP 92
85692: PUSH
85693: LD_EXP 92
85697: PPUSH
85698: LD_VAR 0 3
85702: PUSH
85703: LD_EXP 92
85707: PUSH
85708: LD_VAR 0 3
85712: ARRAY
85713: PUSH
85714: LD_INT 1
85716: PLUS
85717: PUSH
85718: EMPTY
85719: LIST
85720: LIST
85721: PPUSH
85722: LD_VAR 0 1
85726: PPUSH
85727: CALL 20003 0 3
85731: ST_TO_ADDR
// exit ;
85732: POP
85733: POP
85734: GO 86049
// end ; if btype in [ b_bunker , b_turret ] then
85736: LD_VAR 0 5
85740: PUSH
85741: LD_INT 32
85743: PUSH
85744: LD_INT 33
85746: PUSH
85747: EMPTY
85748: LIST
85749: LIST
85750: IN
85751: IFFALSE 86041
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85753: LD_ADDR_EXP 68
85757: PUSH
85758: LD_EXP 68
85762: PPUSH
85763: LD_VAR 0 3
85767: PUSH
85768: LD_EXP 68
85772: PUSH
85773: LD_VAR 0 3
85777: ARRAY
85778: PUSH
85779: LD_INT 1
85781: PLUS
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: PPUSH
85787: LD_VAR 0 1
85791: PPUSH
85792: CALL 20003 0 3
85796: ST_TO_ADDR
// if btype = b_bunker then
85797: LD_VAR 0 5
85801: PUSH
85802: LD_INT 32
85804: EQUAL
85805: IFFALSE 86041
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85807: LD_ADDR_EXP 69
85811: PUSH
85812: LD_EXP 69
85816: PPUSH
85817: LD_VAR 0 3
85821: PUSH
85822: LD_EXP 69
85826: PUSH
85827: LD_VAR 0 3
85831: ARRAY
85832: PUSH
85833: LD_INT 1
85835: PLUS
85836: PUSH
85837: EMPTY
85838: LIST
85839: LIST
85840: PPUSH
85841: LD_VAR 0 1
85845: PPUSH
85846: CALL 20003 0 3
85850: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85851: LD_ADDR_VAR 0 6
85855: PUSH
85856: LD_EXP 60
85860: PUSH
85861: LD_VAR 0 3
85865: ARRAY
85866: PPUSH
85867: LD_INT 25
85869: PUSH
85870: LD_INT 1
85872: PUSH
85873: EMPTY
85874: LIST
85875: LIST
85876: PUSH
85877: LD_INT 3
85879: PUSH
85880: LD_INT 54
85882: PUSH
85883: EMPTY
85884: LIST
85885: PUSH
85886: EMPTY
85887: LIST
85888: LIST
85889: PUSH
85890: EMPTY
85891: LIST
85892: LIST
85893: PPUSH
85894: CALL_OW 72
85898: ST_TO_ADDR
// if tmp then
85899: LD_VAR 0 6
85903: IFFALSE 85909
// exit ;
85905: POP
85906: POP
85907: GO 86049
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
85909: LD_ADDR_VAR 0 6
85913: PUSH
85914: LD_EXP 60
85918: PUSH
85919: LD_VAR 0 3
85923: ARRAY
85924: PPUSH
85925: LD_INT 2
85927: PUSH
85928: LD_INT 30
85930: PUSH
85931: LD_INT 4
85933: PUSH
85934: EMPTY
85935: LIST
85936: LIST
85937: PUSH
85938: LD_INT 30
85940: PUSH
85941: LD_INT 5
85943: PUSH
85944: EMPTY
85945: LIST
85946: LIST
85947: PUSH
85948: EMPTY
85949: LIST
85950: LIST
85951: LIST
85952: PPUSH
85953: CALL_OW 72
85957: ST_TO_ADDR
// if not tmp then
85958: LD_VAR 0 6
85962: NOT
85963: IFFALSE 85969
// exit ;
85965: POP
85966: POP
85967: GO 86049
// for j in tmp do
85969: LD_ADDR_VAR 0 4
85973: PUSH
85974: LD_VAR 0 6
85978: PUSH
85979: FOR_IN
85980: IFFALSE 86039
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
85982: LD_ADDR_VAR 0 7
85986: PUSH
85987: LD_VAR 0 4
85991: PPUSH
85992: CALL_OW 313
85996: PPUSH
85997: LD_INT 25
85999: PUSH
86000: LD_INT 1
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: PPUSH
86007: CALL_OW 72
86011: ST_TO_ADDR
// if units then
86012: LD_VAR 0 7
86016: IFFALSE 86037
// begin ComExitBuilding ( units [ 1 ] ) ;
86018: LD_VAR 0 7
86022: PUSH
86023: LD_INT 1
86025: ARRAY
86026: PPUSH
86027: CALL_OW 122
// exit ;
86031: POP
86032: POP
86033: POP
86034: POP
86035: GO 86049
// end ; end ;
86037: GO 85979
86039: POP
86040: POP
// end ; end ; exit ;
86041: POP
86042: POP
86043: GO 86049
// end ; end ;
86045: GO 85403
86047: POP
86048: POP
// end ;
86049: LD_VAR 0 2
86053: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86054: LD_INT 0
86056: PPUSH
86057: PPUSH
86058: PPUSH
86059: PPUSH
86060: PPUSH
86061: PPUSH
86062: PPUSH
// if not mc_bases or not skirmish then
86063: LD_EXP 60
86067: NOT
86068: PUSH
86069: LD_EXP 58
86073: NOT
86074: OR
86075: IFFALSE 86079
// exit ;
86077: GO 86344
// btype := GetBType ( building ) ;
86079: LD_ADDR_VAR 0 6
86083: PUSH
86084: LD_VAR 0 1
86088: PPUSH
86089: CALL_OW 266
86093: ST_TO_ADDR
// x := GetX ( building ) ;
86094: LD_ADDR_VAR 0 7
86098: PUSH
86099: LD_VAR 0 1
86103: PPUSH
86104: CALL_OW 250
86108: ST_TO_ADDR
// y := GetY ( building ) ;
86109: LD_ADDR_VAR 0 8
86113: PUSH
86114: LD_VAR 0 1
86118: PPUSH
86119: CALL_OW 251
86123: ST_TO_ADDR
// d := GetDir ( building ) ;
86124: LD_ADDR_VAR 0 9
86128: PUSH
86129: LD_VAR 0 1
86133: PPUSH
86134: CALL_OW 254
86138: ST_TO_ADDR
// for i = 1 to mc_bases do
86139: LD_ADDR_VAR 0 4
86143: PUSH
86144: DOUBLE
86145: LD_INT 1
86147: DEC
86148: ST_TO_ADDR
86149: LD_EXP 60
86153: PUSH
86154: FOR_TO
86155: IFFALSE 86342
// begin if not mc_build_list [ i ] then
86157: LD_EXP 65
86161: PUSH
86162: LD_VAR 0 4
86166: ARRAY
86167: NOT
86168: IFFALSE 86172
// continue ;
86170: GO 86154
// for j := 1 to mc_build_list [ i ] do
86172: LD_ADDR_VAR 0 5
86176: PUSH
86177: DOUBLE
86178: LD_INT 1
86180: DEC
86181: ST_TO_ADDR
86182: LD_EXP 65
86186: PUSH
86187: LD_VAR 0 4
86191: ARRAY
86192: PUSH
86193: FOR_TO
86194: IFFALSE 86338
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
86196: LD_VAR 0 6
86200: PUSH
86201: LD_VAR 0 7
86205: PUSH
86206: LD_VAR 0 8
86210: PUSH
86211: LD_VAR 0 9
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: PPUSH
86222: LD_EXP 65
86226: PUSH
86227: LD_VAR 0 4
86231: ARRAY
86232: PUSH
86233: LD_VAR 0 5
86237: ARRAY
86238: PPUSH
86239: CALL 26185 0 2
86243: IFFALSE 86336
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
86245: LD_ADDR_EXP 65
86249: PUSH
86250: LD_EXP 65
86254: PPUSH
86255: LD_VAR 0 4
86259: PPUSH
86260: LD_EXP 65
86264: PUSH
86265: LD_VAR 0 4
86269: ARRAY
86270: PPUSH
86271: LD_VAR 0 5
86275: PPUSH
86276: CALL_OW 3
86280: PPUSH
86281: CALL_OW 1
86285: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86286: LD_ADDR_EXP 67
86290: PUSH
86291: LD_EXP 67
86295: PPUSH
86296: LD_VAR 0 4
86300: PUSH
86301: LD_EXP 67
86305: PUSH
86306: LD_VAR 0 4
86310: ARRAY
86311: PUSH
86312: LD_INT 1
86314: PLUS
86315: PUSH
86316: EMPTY
86317: LIST
86318: LIST
86319: PPUSH
86320: LD_VAR 0 1
86324: PPUSH
86325: CALL 20003 0 3
86329: ST_TO_ADDR
// exit ;
86330: POP
86331: POP
86332: POP
86333: POP
86334: GO 86344
// end ;
86336: GO 86193
86338: POP
86339: POP
// end ;
86340: GO 86154
86342: POP
86343: POP
// end ;
86344: LD_VAR 0 3
86348: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86349: LD_INT 0
86351: PPUSH
86352: PPUSH
86353: PPUSH
// if not mc_bases or not skirmish then
86354: LD_EXP 60
86358: NOT
86359: PUSH
86360: LD_EXP 58
86364: NOT
86365: OR
86366: IFFALSE 86370
// exit ;
86368: GO 86560
// for i = 1 to mc_bases do
86370: LD_ADDR_VAR 0 4
86374: PUSH
86375: DOUBLE
86376: LD_INT 1
86378: DEC
86379: ST_TO_ADDR
86380: LD_EXP 60
86384: PUSH
86385: FOR_TO
86386: IFFALSE 86473
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86388: LD_VAR 0 1
86392: PUSH
86393: LD_EXP 68
86397: PUSH
86398: LD_VAR 0 4
86402: ARRAY
86403: IN
86404: PUSH
86405: LD_VAR 0 1
86409: PUSH
86410: LD_EXP 69
86414: PUSH
86415: LD_VAR 0 4
86419: ARRAY
86420: IN
86421: NOT
86422: AND
86423: IFFALSE 86471
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86425: LD_ADDR_EXP 69
86429: PUSH
86430: LD_EXP 69
86434: PPUSH
86435: LD_VAR 0 4
86439: PUSH
86440: LD_EXP 69
86444: PUSH
86445: LD_VAR 0 4
86449: ARRAY
86450: PUSH
86451: LD_INT 1
86453: PLUS
86454: PUSH
86455: EMPTY
86456: LIST
86457: LIST
86458: PPUSH
86459: LD_VAR 0 1
86463: PPUSH
86464: CALL 20003 0 3
86468: ST_TO_ADDR
// break ;
86469: GO 86473
// end ; end ;
86471: GO 86385
86473: POP
86474: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86475: LD_VAR 0 1
86479: PPUSH
86480: CALL_OW 257
86484: PUSH
86485: LD_EXP 86
86489: IN
86490: PUSH
86491: LD_VAR 0 1
86495: PPUSH
86496: CALL_OW 266
86500: PUSH
86501: LD_INT 5
86503: EQUAL
86504: AND
86505: PUSH
86506: LD_VAR 0 2
86510: PPUSH
86511: CALL_OW 110
86515: PUSH
86516: LD_INT 18
86518: NONEQUAL
86519: AND
86520: IFFALSE 86560
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86522: LD_VAR 0 2
86526: PPUSH
86527: CALL_OW 257
86531: PUSH
86532: LD_INT 5
86534: PUSH
86535: LD_INT 8
86537: PUSH
86538: LD_INT 9
86540: PUSH
86541: EMPTY
86542: LIST
86543: LIST
86544: LIST
86545: IN
86546: IFFALSE 86560
// SetClass ( unit , 1 ) ;
86548: LD_VAR 0 2
86552: PPUSH
86553: LD_INT 1
86555: PPUSH
86556: CALL_OW 336
// end ;
86560: LD_VAR 0 3
86564: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86565: LD_INT 0
86567: PPUSH
86568: PPUSH
// if not mc_bases or not skirmish then
86569: LD_EXP 60
86573: NOT
86574: PUSH
86575: LD_EXP 58
86579: NOT
86580: OR
86581: IFFALSE 86585
// exit ;
86583: GO 86701
// if GetLives ( abandoned_vehicle ) > 250 then
86585: LD_VAR 0 2
86589: PPUSH
86590: CALL_OW 256
86594: PUSH
86595: LD_INT 250
86597: GREATER
86598: IFFALSE 86602
// exit ;
86600: GO 86701
// for i = 1 to mc_bases do
86602: LD_ADDR_VAR 0 6
86606: PUSH
86607: DOUBLE
86608: LD_INT 1
86610: DEC
86611: ST_TO_ADDR
86612: LD_EXP 60
86616: PUSH
86617: FOR_TO
86618: IFFALSE 86699
// begin if driver in mc_bases [ i ] then
86620: LD_VAR 0 1
86624: PUSH
86625: LD_EXP 60
86629: PUSH
86630: LD_VAR 0 6
86634: ARRAY
86635: IN
86636: IFFALSE 86697
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86638: LD_VAR 0 1
86642: PPUSH
86643: LD_EXP 60
86647: PUSH
86648: LD_VAR 0 6
86652: ARRAY
86653: PPUSH
86654: LD_INT 2
86656: PUSH
86657: LD_INT 30
86659: PUSH
86660: LD_INT 0
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PUSH
86667: LD_INT 30
86669: PUSH
86670: LD_INT 1
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: PUSH
86677: EMPTY
86678: LIST
86679: LIST
86680: LIST
86681: PPUSH
86682: CALL_OW 72
86686: PUSH
86687: LD_INT 1
86689: ARRAY
86690: PPUSH
86691: CALL 53142 0 2
// break ;
86695: GO 86699
// end ; end ;
86697: GO 86617
86699: POP
86700: POP
// end ; end_of_file
86701: LD_VAR 0 5
86705: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner , ru_flamethrower ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export function InitGlobalVariables ; begin
86706: LD_INT 0
86708: PPUSH
// ar_miner := 81 ;
86709: LD_ADDR_EXP 111
86713: PUSH
86714: LD_INT 81
86716: ST_TO_ADDR
// ar_crane := 88 ;
86717: LD_ADDR_EXP 110
86721: PUSH
86722: LD_INT 88
86724: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86725: LD_ADDR_EXP 105
86729: PUSH
86730: LD_INT 89
86732: ST_TO_ADDR
// us_hack := 99 ;
86733: LD_ADDR_EXP 106
86737: PUSH
86738: LD_INT 99
86740: ST_TO_ADDR
// us_artillery := 97 ;
86741: LD_ADDR_EXP 107
86745: PUSH
86746: LD_INT 97
86748: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86749: LD_ADDR_EXP 108
86753: PUSH
86754: LD_INT 91
86756: ST_TO_ADDR
// ar_mortar := 92 ;
86757: LD_ADDR_EXP 109
86761: PUSH
86762: LD_INT 92
86764: ST_TO_ADDR
// ru_flamethrower := 93 ;
86765: LD_ADDR_EXP 112
86769: PUSH
86770: LD_INT 93
86772: ST_TO_ADDR
// ru_radar := 98 ;
86773: LD_ADDR_EXP 104
86777: PUSH
86778: LD_INT 98
86780: ST_TO_ADDR
// tech_Artillery := 80 ;
86781: LD_ADDR_EXP 113
86785: PUSH
86786: LD_INT 80
86788: ST_TO_ADDR
// tech_RadMat := 81 ;
86789: LD_ADDR_EXP 114
86793: PUSH
86794: LD_INT 81
86796: ST_TO_ADDR
// tech_BasicTools := 82 ;
86797: LD_ADDR_EXP 115
86801: PUSH
86802: LD_INT 82
86804: ST_TO_ADDR
// tech_Cargo := 83 ;
86805: LD_ADDR_EXP 116
86809: PUSH
86810: LD_INT 83
86812: ST_TO_ADDR
// tech_Track := 84 ;
86813: LD_ADDR_EXP 117
86817: PUSH
86818: LD_INT 84
86820: ST_TO_ADDR
// tech_Crane := 85 ;
86821: LD_ADDR_EXP 118
86825: PUSH
86826: LD_INT 85
86828: ST_TO_ADDR
// tech_Bulldozer := 86 ;
86829: LD_ADDR_EXP 119
86833: PUSH
86834: LD_INT 86
86836: ST_TO_ADDR
// tech_Hovercraft := 87 ;
86837: LD_ADDR_EXP 120
86841: PUSH
86842: LD_INT 87
86844: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
86845: LD_ADDR_EXP 121
86849: PUSH
86850: LD_INT 88
86852: ST_TO_ADDR
// end ;
86853: LD_VAR 0 1
86857: RET
// every 1 do
86858: GO 86860
86860: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
86861: CALL 86706 0 0
86865: END
// every 0 0$1 do
86866: GO 86868
86868: DISABLE
// begin enable ;
86869: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
86870: LD_STRING updateTimer(
86872: PUSH
86873: LD_OWVAR 1
86877: STR
86878: PUSH
86879: LD_STRING );
86881: STR
86882: PPUSH
86883: CALL_OW 559
// end ;
86887: END
// export function SOS_MapStart ( ) ; begin
86888: LD_INT 0
86890: PPUSH
// if streamModeActive then
86891: LD_EXP 122
86895: IFFALSE 86904
// DefineStreamItems ( true ) ;
86897: LD_INT 1
86899: PPUSH
86900: CALL 88558 0 1
// UpdateFactoryWaypoints ( ) ;
86904: CALL 101419 0 0
// UpdateWarehouseGatheringPoints ( ) ;
86908: CALL 101676 0 0
// end ;
86912: LD_VAR 0 1
86916: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
86917: LD_INT 0
86919: PPUSH
// if p2 = 100 then
86920: LD_VAR 0 2
86924: PUSH
86925: LD_INT 100
86927: EQUAL
86928: IFFALSE 87931
// begin if not StreamModeActive then
86930: LD_EXP 122
86934: NOT
86935: IFFALSE 86945
// StreamModeActive := true ;
86937: LD_ADDR_EXP 122
86941: PUSH
86942: LD_INT 1
86944: ST_TO_ADDR
// if p3 = 0 then
86945: LD_VAR 0 3
86949: PUSH
86950: LD_INT 0
86952: EQUAL
86953: IFFALSE 86959
// InitStreamMode ;
86955: CALL 88094 0 0
// if p3 = 1 then
86959: LD_VAR 0 3
86963: PUSH
86964: LD_INT 1
86966: EQUAL
86967: IFFALSE 86977
// sRocket := true ;
86969: LD_ADDR_EXP 127
86973: PUSH
86974: LD_INT 1
86976: ST_TO_ADDR
// if p3 = 2 then
86977: LD_VAR 0 3
86981: PUSH
86982: LD_INT 2
86984: EQUAL
86985: IFFALSE 86995
// sSpeed := true ;
86987: LD_ADDR_EXP 126
86991: PUSH
86992: LD_INT 1
86994: ST_TO_ADDR
// if p3 = 3 then
86995: LD_VAR 0 3
86999: PUSH
87000: LD_INT 3
87002: EQUAL
87003: IFFALSE 87013
// sEngine := true ;
87005: LD_ADDR_EXP 128
87009: PUSH
87010: LD_INT 1
87012: ST_TO_ADDR
// if p3 = 4 then
87013: LD_VAR 0 3
87017: PUSH
87018: LD_INT 4
87020: EQUAL
87021: IFFALSE 87031
// sSpec := true ;
87023: LD_ADDR_EXP 125
87027: PUSH
87028: LD_INT 1
87030: ST_TO_ADDR
// if p3 = 5 then
87031: LD_VAR 0 3
87035: PUSH
87036: LD_INT 5
87038: EQUAL
87039: IFFALSE 87049
// sLevel := true ;
87041: LD_ADDR_EXP 129
87045: PUSH
87046: LD_INT 1
87048: ST_TO_ADDR
// if p3 = 6 then
87049: LD_VAR 0 3
87053: PUSH
87054: LD_INT 6
87056: EQUAL
87057: IFFALSE 87067
// sArmoury := true ;
87059: LD_ADDR_EXP 130
87063: PUSH
87064: LD_INT 1
87066: ST_TO_ADDR
// if p3 = 7 then
87067: LD_VAR 0 3
87071: PUSH
87072: LD_INT 7
87074: EQUAL
87075: IFFALSE 87085
// sRadar := true ;
87077: LD_ADDR_EXP 131
87081: PUSH
87082: LD_INT 1
87084: ST_TO_ADDR
// if p3 = 8 then
87085: LD_VAR 0 3
87089: PUSH
87090: LD_INT 8
87092: EQUAL
87093: IFFALSE 87103
// sBunker := true ;
87095: LD_ADDR_EXP 132
87099: PUSH
87100: LD_INT 1
87102: ST_TO_ADDR
// if p3 = 9 then
87103: LD_VAR 0 3
87107: PUSH
87108: LD_INT 9
87110: EQUAL
87111: IFFALSE 87121
// sHack := true ;
87113: LD_ADDR_EXP 133
87117: PUSH
87118: LD_INT 1
87120: ST_TO_ADDR
// if p3 = 10 then
87121: LD_VAR 0 3
87125: PUSH
87126: LD_INT 10
87128: EQUAL
87129: IFFALSE 87139
// sFire := true ;
87131: LD_ADDR_EXP 134
87135: PUSH
87136: LD_INT 1
87138: ST_TO_ADDR
// if p3 = 11 then
87139: LD_VAR 0 3
87143: PUSH
87144: LD_INT 11
87146: EQUAL
87147: IFFALSE 87157
// sRefresh := true ;
87149: LD_ADDR_EXP 135
87153: PUSH
87154: LD_INT 1
87156: ST_TO_ADDR
// if p3 = 12 then
87157: LD_VAR 0 3
87161: PUSH
87162: LD_INT 12
87164: EQUAL
87165: IFFALSE 87175
// sExp := true ;
87167: LD_ADDR_EXP 136
87171: PUSH
87172: LD_INT 1
87174: ST_TO_ADDR
// if p3 = 13 then
87175: LD_VAR 0 3
87179: PUSH
87180: LD_INT 13
87182: EQUAL
87183: IFFALSE 87193
// sDepot := true ;
87185: LD_ADDR_EXP 137
87189: PUSH
87190: LD_INT 1
87192: ST_TO_ADDR
// if p3 = 14 then
87193: LD_VAR 0 3
87197: PUSH
87198: LD_INT 14
87200: EQUAL
87201: IFFALSE 87211
// sFlag := true ;
87203: LD_ADDR_EXP 138
87207: PUSH
87208: LD_INT 1
87210: ST_TO_ADDR
// if p3 = 15 then
87211: LD_VAR 0 3
87215: PUSH
87216: LD_INT 15
87218: EQUAL
87219: IFFALSE 87229
// sKamikadze := true ;
87221: LD_ADDR_EXP 146
87225: PUSH
87226: LD_INT 1
87228: ST_TO_ADDR
// if p3 = 16 then
87229: LD_VAR 0 3
87233: PUSH
87234: LD_INT 16
87236: EQUAL
87237: IFFALSE 87247
// sTroll := true ;
87239: LD_ADDR_EXP 147
87243: PUSH
87244: LD_INT 1
87246: ST_TO_ADDR
// if p3 = 17 then
87247: LD_VAR 0 3
87251: PUSH
87252: LD_INT 17
87254: EQUAL
87255: IFFALSE 87265
// sSlow := true ;
87257: LD_ADDR_EXP 148
87261: PUSH
87262: LD_INT 1
87264: ST_TO_ADDR
// if p3 = 18 then
87265: LD_VAR 0 3
87269: PUSH
87270: LD_INT 18
87272: EQUAL
87273: IFFALSE 87283
// sLack := true ;
87275: LD_ADDR_EXP 149
87279: PUSH
87280: LD_INT 1
87282: ST_TO_ADDR
// if p3 = 19 then
87283: LD_VAR 0 3
87287: PUSH
87288: LD_INT 19
87290: EQUAL
87291: IFFALSE 87301
// sTank := true ;
87293: LD_ADDR_EXP 151
87297: PUSH
87298: LD_INT 1
87300: ST_TO_ADDR
// if p3 = 20 then
87301: LD_VAR 0 3
87305: PUSH
87306: LD_INT 20
87308: EQUAL
87309: IFFALSE 87319
// sRemote := true ;
87311: LD_ADDR_EXP 152
87315: PUSH
87316: LD_INT 1
87318: ST_TO_ADDR
// if p3 = 21 then
87319: LD_VAR 0 3
87323: PUSH
87324: LD_INT 21
87326: EQUAL
87327: IFFALSE 87337
// sPowell := true ;
87329: LD_ADDR_EXP 153
87333: PUSH
87334: LD_INT 1
87336: ST_TO_ADDR
// if p3 = 22 then
87337: LD_VAR 0 3
87341: PUSH
87342: LD_INT 22
87344: EQUAL
87345: IFFALSE 87355
// sTeleport := true ;
87347: LD_ADDR_EXP 156
87351: PUSH
87352: LD_INT 1
87354: ST_TO_ADDR
// if p3 = 23 then
87355: LD_VAR 0 3
87359: PUSH
87360: LD_INT 23
87362: EQUAL
87363: IFFALSE 87373
// sOilTower := true ;
87365: LD_ADDR_EXP 158
87369: PUSH
87370: LD_INT 1
87372: ST_TO_ADDR
// if p3 = 24 then
87373: LD_VAR 0 3
87377: PUSH
87378: LD_INT 24
87380: EQUAL
87381: IFFALSE 87391
// sShovel := true ;
87383: LD_ADDR_EXP 159
87387: PUSH
87388: LD_INT 1
87390: ST_TO_ADDR
// if p3 = 25 then
87391: LD_VAR 0 3
87395: PUSH
87396: LD_INT 25
87398: EQUAL
87399: IFFALSE 87409
// sSheik := true ;
87401: LD_ADDR_EXP 160
87405: PUSH
87406: LD_INT 1
87408: ST_TO_ADDR
// if p3 = 26 then
87409: LD_VAR 0 3
87413: PUSH
87414: LD_INT 26
87416: EQUAL
87417: IFFALSE 87427
// sEarthquake := true ;
87419: LD_ADDR_EXP 162
87423: PUSH
87424: LD_INT 1
87426: ST_TO_ADDR
// if p3 = 27 then
87427: LD_VAR 0 3
87431: PUSH
87432: LD_INT 27
87434: EQUAL
87435: IFFALSE 87445
// sAI := true ;
87437: LD_ADDR_EXP 163
87441: PUSH
87442: LD_INT 1
87444: ST_TO_ADDR
// if p3 = 28 then
87445: LD_VAR 0 3
87449: PUSH
87450: LD_INT 28
87452: EQUAL
87453: IFFALSE 87463
// sCargo := true ;
87455: LD_ADDR_EXP 166
87459: PUSH
87460: LD_INT 1
87462: ST_TO_ADDR
// if p3 = 29 then
87463: LD_VAR 0 3
87467: PUSH
87468: LD_INT 29
87470: EQUAL
87471: IFFALSE 87481
// sDLaser := true ;
87473: LD_ADDR_EXP 167
87477: PUSH
87478: LD_INT 1
87480: ST_TO_ADDR
// if p3 = 30 then
87481: LD_VAR 0 3
87485: PUSH
87486: LD_INT 30
87488: EQUAL
87489: IFFALSE 87499
// sExchange := true ;
87491: LD_ADDR_EXP 168
87495: PUSH
87496: LD_INT 1
87498: ST_TO_ADDR
// if p3 = 31 then
87499: LD_VAR 0 3
87503: PUSH
87504: LD_INT 31
87506: EQUAL
87507: IFFALSE 87517
// sFac := true ;
87509: LD_ADDR_EXP 169
87513: PUSH
87514: LD_INT 1
87516: ST_TO_ADDR
// if p3 = 32 then
87517: LD_VAR 0 3
87521: PUSH
87522: LD_INT 32
87524: EQUAL
87525: IFFALSE 87535
// sPower := true ;
87527: LD_ADDR_EXP 170
87531: PUSH
87532: LD_INT 1
87534: ST_TO_ADDR
// if p3 = 33 then
87535: LD_VAR 0 3
87539: PUSH
87540: LD_INT 33
87542: EQUAL
87543: IFFALSE 87553
// sRandom := true ;
87545: LD_ADDR_EXP 171
87549: PUSH
87550: LD_INT 1
87552: ST_TO_ADDR
// if p3 = 34 then
87553: LD_VAR 0 3
87557: PUSH
87558: LD_INT 34
87560: EQUAL
87561: IFFALSE 87571
// sShield := true ;
87563: LD_ADDR_EXP 172
87567: PUSH
87568: LD_INT 1
87570: ST_TO_ADDR
// if p3 = 35 then
87571: LD_VAR 0 3
87575: PUSH
87576: LD_INT 35
87578: EQUAL
87579: IFFALSE 87589
// sTime := true ;
87581: LD_ADDR_EXP 173
87585: PUSH
87586: LD_INT 1
87588: ST_TO_ADDR
// if p3 = 36 then
87589: LD_VAR 0 3
87593: PUSH
87594: LD_INT 36
87596: EQUAL
87597: IFFALSE 87607
// sTools := true ;
87599: LD_ADDR_EXP 174
87603: PUSH
87604: LD_INT 1
87606: ST_TO_ADDR
// if p3 = 101 then
87607: LD_VAR 0 3
87611: PUSH
87612: LD_INT 101
87614: EQUAL
87615: IFFALSE 87625
// sSold := true ;
87617: LD_ADDR_EXP 139
87621: PUSH
87622: LD_INT 1
87624: ST_TO_ADDR
// if p3 = 102 then
87625: LD_VAR 0 3
87629: PUSH
87630: LD_INT 102
87632: EQUAL
87633: IFFALSE 87643
// sDiff := true ;
87635: LD_ADDR_EXP 140
87639: PUSH
87640: LD_INT 1
87642: ST_TO_ADDR
// if p3 = 103 then
87643: LD_VAR 0 3
87647: PUSH
87648: LD_INT 103
87650: EQUAL
87651: IFFALSE 87661
// sFog := true ;
87653: LD_ADDR_EXP 143
87657: PUSH
87658: LD_INT 1
87660: ST_TO_ADDR
// if p3 = 104 then
87661: LD_VAR 0 3
87665: PUSH
87666: LD_INT 104
87668: EQUAL
87669: IFFALSE 87679
// sReset := true ;
87671: LD_ADDR_EXP 144
87675: PUSH
87676: LD_INT 1
87678: ST_TO_ADDR
// if p3 = 105 then
87679: LD_VAR 0 3
87683: PUSH
87684: LD_INT 105
87686: EQUAL
87687: IFFALSE 87697
// sSun := true ;
87689: LD_ADDR_EXP 145
87693: PUSH
87694: LD_INT 1
87696: ST_TO_ADDR
// if p3 = 106 then
87697: LD_VAR 0 3
87701: PUSH
87702: LD_INT 106
87704: EQUAL
87705: IFFALSE 87715
// sTiger := true ;
87707: LD_ADDR_EXP 141
87711: PUSH
87712: LD_INT 1
87714: ST_TO_ADDR
// if p3 = 107 then
87715: LD_VAR 0 3
87719: PUSH
87720: LD_INT 107
87722: EQUAL
87723: IFFALSE 87733
// sBomb := true ;
87725: LD_ADDR_EXP 142
87729: PUSH
87730: LD_INT 1
87732: ST_TO_ADDR
// if p3 = 108 then
87733: LD_VAR 0 3
87737: PUSH
87738: LD_INT 108
87740: EQUAL
87741: IFFALSE 87751
// sWound := true ;
87743: LD_ADDR_EXP 150
87747: PUSH
87748: LD_INT 1
87750: ST_TO_ADDR
// if p3 = 109 then
87751: LD_VAR 0 3
87755: PUSH
87756: LD_INT 109
87758: EQUAL
87759: IFFALSE 87769
// sBetray := true ;
87761: LD_ADDR_EXP 154
87765: PUSH
87766: LD_INT 1
87768: ST_TO_ADDR
// if p3 = 110 then
87769: LD_VAR 0 3
87773: PUSH
87774: LD_INT 110
87776: EQUAL
87777: IFFALSE 87787
// sContamin := true ;
87779: LD_ADDR_EXP 155
87783: PUSH
87784: LD_INT 1
87786: ST_TO_ADDR
// if p3 = 111 then
87787: LD_VAR 0 3
87791: PUSH
87792: LD_INT 111
87794: EQUAL
87795: IFFALSE 87805
// sOil := true ;
87797: LD_ADDR_EXP 157
87801: PUSH
87802: LD_INT 1
87804: ST_TO_ADDR
// if p3 = 112 then
87805: LD_VAR 0 3
87809: PUSH
87810: LD_INT 112
87812: EQUAL
87813: IFFALSE 87823
// sStu := true ;
87815: LD_ADDR_EXP 161
87819: PUSH
87820: LD_INT 1
87822: ST_TO_ADDR
// if p3 = 113 then
87823: LD_VAR 0 3
87827: PUSH
87828: LD_INT 113
87830: EQUAL
87831: IFFALSE 87841
// sBazooka := true ;
87833: LD_ADDR_EXP 164
87837: PUSH
87838: LD_INT 1
87840: ST_TO_ADDR
// if p3 = 114 then
87841: LD_VAR 0 3
87845: PUSH
87846: LD_INT 114
87848: EQUAL
87849: IFFALSE 87859
// sMortar := true ;
87851: LD_ADDR_EXP 165
87855: PUSH
87856: LD_INT 1
87858: ST_TO_ADDR
// if p3 = 115 then
87859: LD_VAR 0 3
87863: PUSH
87864: LD_INT 115
87866: EQUAL
87867: IFFALSE 87877
// sRanger := true ;
87869: LD_ADDR_EXP 175
87873: PUSH
87874: LD_INT 1
87876: ST_TO_ADDR
// if p3 = 116 then
87877: LD_VAR 0 3
87881: PUSH
87882: LD_INT 116
87884: EQUAL
87885: IFFALSE 87895
// sComputer := true ;
87887: LD_ADDR_EXP 176
87891: PUSH
87892: LD_INT 1
87894: ST_TO_ADDR
// if p3 = 117 then
87895: LD_VAR 0 3
87899: PUSH
87900: LD_INT 117
87902: EQUAL
87903: IFFALSE 87913
// s30 := true ;
87905: LD_ADDR_EXP 177
87909: PUSH
87910: LD_INT 1
87912: ST_TO_ADDR
// if p3 = 118 then
87913: LD_VAR 0 3
87917: PUSH
87918: LD_INT 118
87920: EQUAL
87921: IFFALSE 87931
// s60 := true ;
87923: LD_ADDR_EXP 178
87927: PUSH
87928: LD_INT 1
87930: ST_TO_ADDR
// end ; if p2 = 101 then
87931: LD_VAR 0 2
87935: PUSH
87936: LD_INT 101
87938: EQUAL
87939: IFFALSE 88067
// begin case p3 of 1 :
87941: LD_VAR 0 3
87945: PUSH
87946: LD_INT 1
87948: DOUBLE
87949: EQUAL
87950: IFTRUE 87954
87952: GO 87961
87954: POP
// hHackUnlimitedResources ; 2 :
87955: CALL 100165 0 0
87959: GO 88067
87961: LD_INT 2
87963: DOUBLE
87964: EQUAL
87965: IFTRUE 87969
87967: GO 87976
87969: POP
// hHackSetLevel10 ; 3 :
87970: CALL 100298 0 0
87974: GO 88067
87976: LD_INT 3
87978: DOUBLE
87979: EQUAL
87980: IFTRUE 87984
87982: GO 87991
87984: POP
// hHackSetLevel10YourUnits ; 4 :
87985: CALL 100383 0 0
87989: GO 88067
87991: LD_INT 4
87993: DOUBLE
87994: EQUAL
87995: IFTRUE 87999
87997: GO 88006
87999: POP
// hHackInvincible ; 5 :
88000: CALL 100831 0 0
88004: GO 88067
88006: LD_INT 5
88008: DOUBLE
88009: EQUAL
88010: IFTRUE 88014
88012: GO 88021
88014: POP
// hHackInvisible ; 6 :
88015: CALL 100942 0 0
88019: GO 88067
88021: LD_INT 6
88023: DOUBLE
88024: EQUAL
88025: IFTRUE 88029
88027: GO 88036
88029: POP
// hHackChangeYourSide ; 7 :
88030: CALL 100999 0 0
88034: GO 88067
88036: LD_INT 7
88038: DOUBLE
88039: EQUAL
88040: IFTRUE 88044
88042: GO 88051
88044: POP
// hHackChangeUnitSide ; 8 :
88045: CALL 101041 0 0
88049: GO 88067
88051: LD_INT 8
88053: DOUBLE
88054: EQUAL
88055: IFTRUE 88059
88057: GO 88066
88059: POP
// hHackFog ; end ;
88060: CALL 101142 0 0
88064: GO 88067
88066: POP
// end ; end ;
88067: LD_VAR 0 7
88071: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
88072: GO 88074
88074: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88075: LD_STRING initStreamRollete();
88077: PPUSH
88078: CALL_OW 559
// InitStreamMode ;
88082: CALL 88094 0 0
// DefineStreamItems ( false ) ;
88086: LD_INT 0
88088: PPUSH
88089: CALL 88558 0 1
// end ;
88093: END
// function InitStreamMode ; begin
88094: LD_INT 0
88096: PPUSH
// streamModeActive := false ;
88097: LD_ADDR_EXP 122
88101: PUSH
88102: LD_INT 0
88104: ST_TO_ADDR
// normalCounter := 36 ;
88105: LD_ADDR_EXP 123
88109: PUSH
88110: LD_INT 36
88112: ST_TO_ADDR
// hardcoreCounter := 18 ;
88113: LD_ADDR_EXP 124
88117: PUSH
88118: LD_INT 18
88120: ST_TO_ADDR
// sRocket := false ;
88121: LD_ADDR_EXP 127
88125: PUSH
88126: LD_INT 0
88128: ST_TO_ADDR
// sSpeed := false ;
88129: LD_ADDR_EXP 126
88133: PUSH
88134: LD_INT 0
88136: ST_TO_ADDR
// sEngine := false ;
88137: LD_ADDR_EXP 128
88141: PUSH
88142: LD_INT 0
88144: ST_TO_ADDR
// sSpec := false ;
88145: LD_ADDR_EXP 125
88149: PUSH
88150: LD_INT 0
88152: ST_TO_ADDR
// sLevel := false ;
88153: LD_ADDR_EXP 129
88157: PUSH
88158: LD_INT 0
88160: ST_TO_ADDR
// sArmoury := false ;
88161: LD_ADDR_EXP 130
88165: PUSH
88166: LD_INT 0
88168: ST_TO_ADDR
// sRadar := false ;
88169: LD_ADDR_EXP 131
88173: PUSH
88174: LD_INT 0
88176: ST_TO_ADDR
// sBunker := false ;
88177: LD_ADDR_EXP 132
88181: PUSH
88182: LD_INT 0
88184: ST_TO_ADDR
// sHack := false ;
88185: LD_ADDR_EXP 133
88189: PUSH
88190: LD_INT 0
88192: ST_TO_ADDR
// sFire := false ;
88193: LD_ADDR_EXP 134
88197: PUSH
88198: LD_INT 0
88200: ST_TO_ADDR
// sRefresh := false ;
88201: LD_ADDR_EXP 135
88205: PUSH
88206: LD_INT 0
88208: ST_TO_ADDR
// sExp := false ;
88209: LD_ADDR_EXP 136
88213: PUSH
88214: LD_INT 0
88216: ST_TO_ADDR
// sDepot := false ;
88217: LD_ADDR_EXP 137
88221: PUSH
88222: LD_INT 0
88224: ST_TO_ADDR
// sFlag := false ;
88225: LD_ADDR_EXP 138
88229: PUSH
88230: LD_INT 0
88232: ST_TO_ADDR
// sKamikadze := false ;
88233: LD_ADDR_EXP 146
88237: PUSH
88238: LD_INT 0
88240: ST_TO_ADDR
// sTroll := false ;
88241: LD_ADDR_EXP 147
88245: PUSH
88246: LD_INT 0
88248: ST_TO_ADDR
// sSlow := false ;
88249: LD_ADDR_EXP 148
88253: PUSH
88254: LD_INT 0
88256: ST_TO_ADDR
// sLack := false ;
88257: LD_ADDR_EXP 149
88261: PUSH
88262: LD_INT 0
88264: ST_TO_ADDR
// sTank := false ;
88265: LD_ADDR_EXP 151
88269: PUSH
88270: LD_INT 0
88272: ST_TO_ADDR
// sRemote := false ;
88273: LD_ADDR_EXP 152
88277: PUSH
88278: LD_INT 0
88280: ST_TO_ADDR
// sPowell := false ;
88281: LD_ADDR_EXP 153
88285: PUSH
88286: LD_INT 0
88288: ST_TO_ADDR
// sTeleport := false ;
88289: LD_ADDR_EXP 156
88293: PUSH
88294: LD_INT 0
88296: ST_TO_ADDR
// sOilTower := false ;
88297: LD_ADDR_EXP 158
88301: PUSH
88302: LD_INT 0
88304: ST_TO_ADDR
// sShovel := false ;
88305: LD_ADDR_EXP 159
88309: PUSH
88310: LD_INT 0
88312: ST_TO_ADDR
// sSheik := false ;
88313: LD_ADDR_EXP 160
88317: PUSH
88318: LD_INT 0
88320: ST_TO_ADDR
// sEarthquake := false ;
88321: LD_ADDR_EXP 162
88325: PUSH
88326: LD_INT 0
88328: ST_TO_ADDR
// sAI := false ;
88329: LD_ADDR_EXP 163
88333: PUSH
88334: LD_INT 0
88336: ST_TO_ADDR
// sCargo := false ;
88337: LD_ADDR_EXP 166
88341: PUSH
88342: LD_INT 0
88344: ST_TO_ADDR
// sDLaser := false ;
88345: LD_ADDR_EXP 167
88349: PUSH
88350: LD_INT 0
88352: ST_TO_ADDR
// sExchange := false ;
88353: LD_ADDR_EXP 168
88357: PUSH
88358: LD_INT 0
88360: ST_TO_ADDR
// sFac := false ;
88361: LD_ADDR_EXP 169
88365: PUSH
88366: LD_INT 0
88368: ST_TO_ADDR
// sPower := false ;
88369: LD_ADDR_EXP 170
88373: PUSH
88374: LD_INT 0
88376: ST_TO_ADDR
// sRandom := false ;
88377: LD_ADDR_EXP 171
88381: PUSH
88382: LD_INT 0
88384: ST_TO_ADDR
// sShield := false ;
88385: LD_ADDR_EXP 172
88389: PUSH
88390: LD_INT 0
88392: ST_TO_ADDR
// sTime := false ;
88393: LD_ADDR_EXP 173
88397: PUSH
88398: LD_INT 0
88400: ST_TO_ADDR
// sTools := false ;
88401: LD_ADDR_EXP 174
88405: PUSH
88406: LD_INT 0
88408: ST_TO_ADDR
// sSold := false ;
88409: LD_ADDR_EXP 139
88413: PUSH
88414: LD_INT 0
88416: ST_TO_ADDR
// sDiff := false ;
88417: LD_ADDR_EXP 140
88421: PUSH
88422: LD_INT 0
88424: ST_TO_ADDR
// sFog := false ;
88425: LD_ADDR_EXP 143
88429: PUSH
88430: LD_INT 0
88432: ST_TO_ADDR
// sReset := false ;
88433: LD_ADDR_EXP 144
88437: PUSH
88438: LD_INT 0
88440: ST_TO_ADDR
// sSun := false ;
88441: LD_ADDR_EXP 145
88445: PUSH
88446: LD_INT 0
88448: ST_TO_ADDR
// sTiger := false ;
88449: LD_ADDR_EXP 141
88453: PUSH
88454: LD_INT 0
88456: ST_TO_ADDR
// sBomb := false ;
88457: LD_ADDR_EXP 142
88461: PUSH
88462: LD_INT 0
88464: ST_TO_ADDR
// sWound := false ;
88465: LD_ADDR_EXP 150
88469: PUSH
88470: LD_INT 0
88472: ST_TO_ADDR
// sBetray := false ;
88473: LD_ADDR_EXP 154
88477: PUSH
88478: LD_INT 0
88480: ST_TO_ADDR
// sContamin := false ;
88481: LD_ADDR_EXP 155
88485: PUSH
88486: LD_INT 0
88488: ST_TO_ADDR
// sOil := false ;
88489: LD_ADDR_EXP 157
88493: PUSH
88494: LD_INT 0
88496: ST_TO_ADDR
// sStu := false ;
88497: LD_ADDR_EXP 161
88501: PUSH
88502: LD_INT 0
88504: ST_TO_ADDR
// sBazooka := false ;
88505: LD_ADDR_EXP 164
88509: PUSH
88510: LD_INT 0
88512: ST_TO_ADDR
// sMortar := false ;
88513: LD_ADDR_EXP 165
88517: PUSH
88518: LD_INT 0
88520: ST_TO_ADDR
// sRanger := false ;
88521: LD_ADDR_EXP 175
88525: PUSH
88526: LD_INT 0
88528: ST_TO_ADDR
// sComputer := false ;
88529: LD_ADDR_EXP 176
88533: PUSH
88534: LD_INT 0
88536: ST_TO_ADDR
// s30 := false ;
88537: LD_ADDR_EXP 177
88541: PUSH
88542: LD_INT 0
88544: ST_TO_ADDR
// s60 := false ;
88545: LD_ADDR_EXP 178
88549: PUSH
88550: LD_INT 0
88552: ST_TO_ADDR
// end ;
88553: LD_VAR 0 1
88557: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
88558: LD_INT 0
88560: PPUSH
88561: PPUSH
88562: PPUSH
88563: PPUSH
88564: PPUSH
88565: PPUSH
88566: PPUSH
// result := [ ] ;
88567: LD_ADDR_VAR 0 2
88571: PUSH
88572: EMPTY
88573: ST_TO_ADDR
// if campaign_id = 1 then
88574: LD_OWVAR 69
88578: PUSH
88579: LD_INT 1
88581: EQUAL
88582: IFFALSE 91748
// begin case mission_number of 1 :
88584: LD_OWVAR 70
88588: PUSH
88589: LD_INT 1
88591: DOUBLE
88592: EQUAL
88593: IFTRUE 88597
88595: GO 88673
88597: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
88598: LD_ADDR_VAR 0 2
88602: PUSH
88603: LD_INT 2
88605: PUSH
88606: LD_INT 4
88608: PUSH
88609: LD_INT 11
88611: PUSH
88612: LD_INT 12
88614: PUSH
88615: LD_INT 15
88617: PUSH
88618: LD_INT 16
88620: PUSH
88621: LD_INT 22
88623: PUSH
88624: LD_INT 23
88626: PUSH
88627: LD_INT 26
88629: PUSH
88630: EMPTY
88631: LIST
88632: LIST
88633: LIST
88634: LIST
88635: LIST
88636: LIST
88637: LIST
88638: LIST
88639: LIST
88640: PUSH
88641: LD_INT 101
88643: PUSH
88644: LD_INT 102
88646: PUSH
88647: LD_INT 106
88649: PUSH
88650: LD_INT 116
88652: PUSH
88653: LD_INT 117
88655: PUSH
88656: LD_INT 118
88658: PUSH
88659: EMPTY
88660: LIST
88661: LIST
88662: LIST
88663: LIST
88664: LIST
88665: LIST
88666: PUSH
88667: EMPTY
88668: LIST
88669: LIST
88670: ST_TO_ADDR
88671: GO 91746
88673: LD_INT 2
88675: DOUBLE
88676: EQUAL
88677: IFTRUE 88681
88679: GO 88765
88681: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
88682: LD_ADDR_VAR 0 2
88686: PUSH
88687: LD_INT 2
88689: PUSH
88690: LD_INT 4
88692: PUSH
88693: LD_INT 11
88695: PUSH
88696: LD_INT 12
88698: PUSH
88699: LD_INT 15
88701: PUSH
88702: LD_INT 16
88704: PUSH
88705: LD_INT 22
88707: PUSH
88708: LD_INT 23
88710: PUSH
88711: LD_INT 26
88713: PUSH
88714: EMPTY
88715: LIST
88716: LIST
88717: LIST
88718: LIST
88719: LIST
88720: LIST
88721: LIST
88722: LIST
88723: LIST
88724: PUSH
88725: LD_INT 101
88727: PUSH
88728: LD_INT 102
88730: PUSH
88731: LD_INT 105
88733: PUSH
88734: LD_INT 106
88736: PUSH
88737: LD_INT 108
88739: PUSH
88740: LD_INT 116
88742: PUSH
88743: LD_INT 117
88745: PUSH
88746: LD_INT 118
88748: PUSH
88749: EMPTY
88750: LIST
88751: LIST
88752: LIST
88753: LIST
88754: LIST
88755: LIST
88756: LIST
88757: LIST
88758: PUSH
88759: EMPTY
88760: LIST
88761: LIST
88762: ST_TO_ADDR
88763: GO 91746
88765: LD_INT 3
88767: DOUBLE
88768: EQUAL
88769: IFTRUE 88773
88771: GO 88861
88773: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
88774: LD_ADDR_VAR 0 2
88778: PUSH
88779: LD_INT 2
88781: PUSH
88782: LD_INT 4
88784: PUSH
88785: LD_INT 5
88787: PUSH
88788: LD_INT 11
88790: PUSH
88791: LD_INT 12
88793: PUSH
88794: LD_INT 15
88796: PUSH
88797: LD_INT 16
88799: PUSH
88800: LD_INT 22
88802: PUSH
88803: LD_INT 26
88805: PUSH
88806: LD_INT 36
88808: PUSH
88809: EMPTY
88810: LIST
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: LIST
88816: LIST
88817: LIST
88818: LIST
88819: LIST
88820: PUSH
88821: LD_INT 101
88823: PUSH
88824: LD_INT 102
88826: PUSH
88827: LD_INT 105
88829: PUSH
88830: LD_INT 106
88832: PUSH
88833: LD_INT 108
88835: PUSH
88836: LD_INT 116
88838: PUSH
88839: LD_INT 117
88841: PUSH
88842: LD_INT 118
88844: PUSH
88845: EMPTY
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: LIST
88852: LIST
88853: LIST
88854: PUSH
88855: EMPTY
88856: LIST
88857: LIST
88858: ST_TO_ADDR
88859: GO 91746
88861: LD_INT 4
88863: DOUBLE
88864: EQUAL
88865: IFTRUE 88869
88867: GO 88965
88869: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
88870: LD_ADDR_VAR 0 2
88874: PUSH
88875: LD_INT 2
88877: PUSH
88878: LD_INT 4
88880: PUSH
88881: LD_INT 5
88883: PUSH
88884: LD_INT 8
88886: PUSH
88887: LD_INT 11
88889: PUSH
88890: LD_INT 12
88892: PUSH
88893: LD_INT 15
88895: PUSH
88896: LD_INT 16
88898: PUSH
88899: LD_INT 22
88901: PUSH
88902: LD_INT 23
88904: PUSH
88905: LD_INT 26
88907: PUSH
88908: LD_INT 36
88910: PUSH
88911: EMPTY
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: LIST
88924: PUSH
88925: LD_INT 101
88927: PUSH
88928: LD_INT 102
88930: PUSH
88931: LD_INT 105
88933: PUSH
88934: LD_INT 106
88936: PUSH
88937: LD_INT 108
88939: PUSH
88940: LD_INT 116
88942: PUSH
88943: LD_INT 117
88945: PUSH
88946: LD_INT 118
88948: PUSH
88949: EMPTY
88950: LIST
88951: LIST
88952: LIST
88953: LIST
88954: LIST
88955: LIST
88956: LIST
88957: LIST
88958: PUSH
88959: EMPTY
88960: LIST
88961: LIST
88962: ST_TO_ADDR
88963: GO 91746
88965: LD_INT 5
88967: DOUBLE
88968: EQUAL
88969: IFTRUE 88973
88971: GO 89085
88973: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
88974: LD_ADDR_VAR 0 2
88978: PUSH
88979: LD_INT 2
88981: PUSH
88982: LD_INT 4
88984: PUSH
88985: LD_INT 5
88987: PUSH
88988: LD_INT 6
88990: PUSH
88991: LD_INT 8
88993: PUSH
88994: LD_INT 11
88996: PUSH
88997: LD_INT 12
88999: PUSH
89000: LD_INT 15
89002: PUSH
89003: LD_INT 16
89005: PUSH
89006: LD_INT 22
89008: PUSH
89009: LD_INT 23
89011: PUSH
89012: LD_INT 25
89014: PUSH
89015: LD_INT 26
89017: PUSH
89018: LD_INT 36
89020: PUSH
89021: EMPTY
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: LIST
89032: LIST
89033: LIST
89034: LIST
89035: LIST
89036: PUSH
89037: LD_INT 101
89039: PUSH
89040: LD_INT 102
89042: PUSH
89043: LD_INT 105
89045: PUSH
89046: LD_INT 106
89048: PUSH
89049: LD_INT 108
89051: PUSH
89052: LD_INT 109
89054: PUSH
89055: LD_INT 112
89057: PUSH
89058: LD_INT 116
89060: PUSH
89061: LD_INT 117
89063: PUSH
89064: LD_INT 118
89066: PUSH
89067: EMPTY
89068: LIST
89069: LIST
89070: LIST
89071: LIST
89072: LIST
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: PUSH
89079: EMPTY
89080: LIST
89081: LIST
89082: ST_TO_ADDR
89083: GO 91746
89085: LD_INT 6
89087: DOUBLE
89088: EQUAL
89089: IFTRUE 89093
89091: GO 89225
89093: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
89094: LD_ADDR_VAR 0 2
89098: PUSH
89099: LD_INT 2
89101: PUSH
89102: LD_INT 4
89104: PUSH
89105: LD_INT 5
89107: PUSH
89108: LD_INT 6
89110: PUSH
89111: LD_INT 8
89113: PUSH
89114: LD_INT 11
89116: PUSH
89117: LD_INT 12
89119: PUSH
89120: LD_INT 15
89122: PUSH
89123: LD_INT 16
89125: PUSH
89126: LD_INT 20
89128: PUSH
89129: LD_INT 21
89131: PUSH
89132: LD_INT 22
89134: PUSH
89135: LD_INT 23
89137: PUSH
89138: LD_INT 25
89140: PUSH
89141: LD_INT 26
89143: PUSH
89144: LD_INT 30
89146: PUSH
89147: LD_INT 31
89149: PUSH
89150: LD_INT 32
89152: PUSH
89153: LD_INT 36
89155: PUSH
89156: EMPTY
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: LIST
89167: LIST
89168: LIST
89169: LIST
89170: LIST
89171: LIST
89172: LIST
89173: LIST
89174: LIST
89175: LIST
89176: PUSH
89177: LD_INT 101
89179: PUSH
89180: LD_INT 102
89182: PUSH
89183: LD_INT 105
89185: PUSH
89186: LD_INT 106
89188: PUSH
89189: LD_INT 108
89191: PUSH
89192: LD_INT 109
89194: PUSH
89195: LD_INT 112
89197: PUSH
89198: LD_INT 116
89200: PUSH
89201: LD_INT 117
89203: PUSH
89204: LD_INT 118
89206: PUSH
89207: EMPTY
89208: LIST
89209: LIST
89210: LIST
89211: LIST
89212: LIST
89213: LIST
89214: LIST
89215: LIST
89216: LIST
89217: LIST
89218: PUSH
89219: EMPTY
89220: LIST
89221: LIST
89222: ST_TO_ADDR
89223: GO 91746
89225: LD_INT 7
89227: DOUBLE
89228: EQUAL
89229: IFTRUE 89233
89231: GO 89345
89233: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
89234: LD_ADDR_VAR 0 2
89238: PUSH
89239: LD_INT 2
89241: PUSH
89242: LD_INT 4
89244: PUSH
89245: LD_INT 5
89247: PUSH
89248: LD_INT 7
89250: PUSH
89251: LD_INT 11
89253: PUSH
89254: LD_INT 12
89256: PUSH
89257: LD_INT 15
89259: PUSH
89260: LD_INT 16
89262: PUSH
89263: LD_INT 20
89265: PUSH
89266: LD_INT 21
89268: PUSH
89269: LD_INT 22
89271: PUSH
89272: LD_INT 23
89274: PUSH
89275: LD_INT 25
89277: PUSH
89278: LD_INT 26
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: PUSH
89297: LD_INT 101
89299: PUSH
89300: LD_INT 102
89302: PUSH
89303: LD_INT 103
89305: PUSH
89306: LD_INT 105
89308: PUSH
89309: LD_INT 106
89311: PUSH
89312: LD_INT 108
89314: PUSH
89315: LD_INT 112
89317: PUSH
89318: LD_INT 116
89320: PUSH
89321: LD_INT 117
89323: PUSH
89324: LD_INT 118
89326: PUSH
89327: EMPTY
89328: LIST
89329: LIST
89330: LIST
89331: LIST
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: PUSH
89339: EMPTY
89340: LIST
89341: LIST
89342: ST_TO_ADDR
89343: GO 91746
89345: LD_INT 8
89347: DOUBLE
89348: EQUAL
89349: IFTRUE 89353
89351: GO 89493
89353: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
89354: LD_ADDR_VAR 0 2
89358: PUSH
89359: LD_INT 2
89361: PUSH
89362: LD_INT 4
89364: PUSH
89365: LD_INT 5
89367: PUSH
89368: LD_INT 6
89370: PUSH
89371: LD_INT 7
89373: PUSH
89374: LD_INT 8
89376: PUSH
89377: LD_INT 11
89379: PUSH
89380: LD_INT 12
89382: PUSH
89383: LD_INT 15
89385: PUSH
89386: LD_INT 16
89388: PUSH
89389: LD_INT 20
89391: PUSH
89392: LD_INT 21
89394: PUSH
89395: LD_INT 22
89397: PUSH
89398: LD_INT 23
89400: PUSH
89401: LD_INT 25
89403: PUSH
89404: LD_INT 26
89406: PUSH
89407: LD_INT 30
89409: PUSH
89410: LD_INT 31
89412: PUSH
89413: LD_INT 32
89415: PUSH
89416: LD_INT 36
89418: PUSH
89419: EMPTY
89420: LIST
89421: LIST
89422: LIST
89423: LIST
89424: LIST
89425: LIST
89426: LIST
89427: LIST
89428: LIST
89429: LIST
89430: LIST
89431: LIST
89432: LIST
89433: LIST
89434: LIST
89435: LIST
89436: LIST
89437: LIST
89438: LIST
89439: LIST
89440: PUSH
89441: LD_INT 101
89443: PUSH
89444: LD_INT 102
89446: PUSH
89447: LD_INT 103
89449: PUSH
89450: LD_INT 105
89452: PUSH
89453: LD_INT 106
89455: PUSH
89456: LD_INT 108
89458: PUSH
89459: LD_INT 109
89461: PUSH
89462: LD_INT 112
89464: PUSH
89465: LD_INT 116
89467: PUSH
89468: LD_INT 117
89470: PUSH
89471: LD_INT 118
89473: PUSH
89474: EMPTY
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: PUSH
89487: EMPTY
89488: LIST
89489: LIST
89490: ST_TO_ADDR
89491: GO 91746
89493: LD_INT 9
89495: DOUBLE
89496: EQUAL
89497: IFTRUE 89501
89499: GO 89649
89501: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
89502: LD_ADDR_VAR 0 2
89506: PUSH
89507: LD_INT 2
89509: PUSH
89510: LD_INT 4
89512: PUSH
89513: LD_INT 5
89515: PUSH
89516: LD_INT 6
89518: PUSH
89519: LD_INT 7
89521: PUSH
89522: LD_INT 8
89524: PUSH
89525: LD_INT 11
89527: PUSH
89528: LD_INT 12
89530: PUSH
89531: LD_INT 15
89533: PUSH
89534: LD_INT 16
89536: PUSH
89537: LD_INT 20
89539: PUSH
89540: LD_INT 21
89542: PUSH
89543: LD_INT 22
89545: PUSH
89546: LD_INT 23
89548: PUSH
89549: LD_INT 25
89551: PUSH
89552: LD_INT 26
89554: PUSH
89555: LD_INT 28
89557: PUSH
89558: LD_INT 30
89560: PUSH
89561: LD_INT 31
89563: PUSH
89564: LD_INT 32
89566: PUSH
89567: LD_INT 36
89569: PUSH
89570: EMPTY
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: LIST
89576: LIST
89577: LIST
89578: LIST
89579: LIST
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: PUSH
89593: LD_INT 101
89595: PUSH
89596: LD_INT 102
89598: PUSH
89599: LD_INT 103
89601: PUSH
89602: LD_INT 105
89604: PUSH
89605: LD_INT 106
89607: PUSH
89608: LD_INT 108
89610: PUSH
89611: LD_INT 109
89613: PUSH
89614: LD_INT 112
89616: PUSH
89617: LD_INT 114
89619: PUSH
89620: LD_INT 116
89622: PUSH
89623: LD_INT 117
89625: PUSH
89626: LD_INT 118
89628: PUSH
89629: EMPTY
89630: LIST
89631: LIST
89632: LIST
89633: LIST
89634: LIST
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: PUSH
89643: EMPTY
89644: LIST
89645: LIST
89646: ST_TO_ADDR
89647: GO 91746
89649: LD_INT 10
89651: DOUBLE
89652: EQUAL
89653: IFTRUE 89657
89655: GO 89853
89657: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
89658: LD_ADDR_VAR 0 2
89662: PUSH
89663: LD_INT 2
89665: PUSH
89666: LD_INT 4
89668: PUSH
89669: LD_INT 5
89671: PUSH
89672: LD_INT 6
89674: PUSH
89675: LD_INT 7
89677: PUSH
89678: LD_INT 8
89680: PUSH
89681: LD_INT 9
89683: PUSH
89684: LD_INT 10
89686: PUSH
89687: LD_INT 11
89689: PUSH
89690: LD_INT 12
89692: PUSH
89693: LD_INT 13
89695: PUSH
89696: LD_INT 14
89698: PUSH
89699: LD_INT 15
89701: PUSH
89702: LD_INT 16
89704: PUSH
89705: LD_INT 17
89707: PUSH
89708: LD_INT 18
89710: PUSH
89711: LD_INT 19
89713: PUSH
89714: LD_INT 20
89716: PUSH
89717: LD_INT 21
89719: PUSH
89720: LD_INT 22
89722: PUSH
89723: LD_INT 23
89725: PUSH
89726: LD_INT 24
89728: PUSH
89729: LD_INT 25
89731: PUSH
89732: LD_INT 26
89734: PUSH
89735: LD_INT 28
89737: PUSH
89738: LD_INT 30
89740: PUSH
89741: LD_INT 31
89743: PUSH
89744: LD_INT 32
89746: PUSH
89747: LD_INT 36
89749: PUSH
89750: EMPTY
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: LIST
89763: LIST
89764: LIST
89765: LIST
89766: LIST
89767: LIST
89768: LIST
89769: LIST
89770: LIST
89771: LIST
89772: LIST
89773: LIST
89774: LIST
89775: LIST
89776: LIST
89777: LIST
89778: LIST
89779: LIST
89780: PUSH
89781: LD_INT 101
89783: PUSH
89784: LD_INT 102
89786: PUSH
89787: LD_INT 103
89789: PUSH
89790: LD_INT 104
89792: PUSH
89793: LD_INT 105
89795: PUSH
89796: LD_INT 106
89798: PUSH
89799: LD_INT 107
89801: PUSH
89802: LD_INT 108
89804: PUSH
89805: LD_INT 109
89807: PUSH
89808: LD_INT 110
89810: PUSH
89811: LD_INT 111
89813: PUSH
89814: LD_INT 112
89816: PUSH
89817: LD_INT 114
89819: PUSH
89820: LD_INT 116
89822: PUSH
89823: LD_INT 117
89825: PUSH
89826: LD_INT 118
89828: PUSH
89829: EMPTY
89830: LIST
89831: LIST
89832: LIST
89833: LIST
89834: LIST
89835: LIST
89836: LIST
89837: LIST
89838: LIST
89839: LIST
89840: LIST
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: PUSH
89847: EMPTY
89848: LIST
89849: LIST
89850: ST_TO_ADDR
89851: GO 91746
89853: LD_INT 11
89855: DOUBLE
89856: EQUAL
89857: IFTRUE 89861
89859: GO 90065
89861: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
89862: LD_ADDR_VAR 0 2
89866: PUSH
89867: LD_INT 2
89869: PUSH
89870: LD_INT 3
89872: PUSH
89873: LD_INT 4
89875: PUSH
89876: LD_INT 5
89878: PUSH
89879: LD_INT 6
89881: PUSH
89882: LD_INT 7
89884: PUSH
89885: LD_INT 8
89887: PUSH
89888: LD_INT 9
89890: PUSH
89891: LD_INT 10
89893: PUSH
89894: LD_INT 11
89896: PUSH
89897: LD_INT 12
89899: PUSH
89900: LD_INT 13
89902: PUSH
89903: LD_INT 14
89905: PUSH
89906: LD_INT 15
89908: PUSH
89909: LD_INT 16
89911: PUSH
89912: LD_INT 17
89914: PUSH
89915: LD_INT 18
89917: PUSH
89918: LD_INT 19
89920: PUSH
89921: LD_INT 20
89923: PUSH
89924: LD_INT 21
89926: PUSH
89927: LD_INT 22
89929: PUSH
89930: LD_INT 23
89932: PUSH
89933: LD_INT 24
89935: PUSH
89936: LD_INT 25
89938: PUSH
89939: LD_INT 26
89941: PUSH
89942: LD_INT 28
89944: PUSH
89945: LD_INT 30
89947: PUSH
89948: LD_INT 31
89950: PUSH
89951: LD_INT 32
89953: PUSH
89954: LD_INT 34
89956: PUSH
89957: LD_INT 36
89959: PUSH
89960: EMPTY
89961: LIST
89962: LIST
89963: LIST
89964: LIST
89965: LIST
89966: LIST
89967: LIST
89968: LIST
89969: LIST
89970: LIST
89971: LIST
89972: LIST
89973: LIST
89974: LIST
89975: LIST
89976: LIST
89977: LIST
89978: LIST
89979: LIST
89980: LIST
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: LIST
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 101
89995: PUSH
89996: LD_INT 102
89998: PUSH
89999: LD_INT 103
90001: PUSH
90002: LD_INT 104
90004: PUSH
90005: LD_INT 105
90007: PUSH
90008: LD_INT 106
90010: PUSH
90011: LD_INT 107
90013: PUSH
90014: LD_INT 108
90016: PUSH
90017: LD_INT 109
90019: PUSH
90020: LD_INT 110
90022: PUSH
90023: LD_INT 111
90025: PUSH
90026: LD_INT 112
90028: PUSH
90029: LD_INT 114
90031: PUSH
90032: LD_INT 116
90034: PUSH
90035: LD_INT 117
90037: PUSH
90038: LD_INT 118
90040: PUSH
90041: EMPTY
90042: LIST
90043: LIST
90044: LIST
90045: LIST
90046: LIST
90047: LIST
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: LIST
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: PUSH
90059: EMPTY
90060: LIST
90061: LIST
90062: ST_TO_ADDR
90063: GO 91746
90065: LD_INT 12
90067: DOUBLE
90068: EQUAL
90069: IFTRUE 90073
90071: GO 90293
90073: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
90074: LD_ADDR_VAR 0 2
90078: PUSH
90079: LD_INT 1
90081: PUSH
90082: LD_INT 2
90084: PUSH
90085: LD_INT 3
90087: PUSH
90088: LD_INT 4
90090: PUSH
90091: LD_INT 5
90093: PUSH
90094: LD_INT 6
90096: PUSH
90097: LD_INT 7
90099: PUSH
90100: LD_INT 8
90102: PUSH
90103: LD_INT 9
90105: PUSH
90106: LD_INT 10
90108: PUSH
90109: LD_INT 11
90111: PUSH
90112: LD_INT 12
90114: PUSH
90115: LD_INT 13
90117: PUSH
90118: LD_INT 14
90120: PUSH
90121: LD_INT 15
90123: PUSH
90124: LD_INT 16
90126: PUSH
90127: LD_INT 17
90129: PUSH
90130: LD_INT 18
90132: PUSH
90133: LD_INT 19
90135: PUSH
90136: LD_INT 20
90138: PUSH
90139: LD_INT 21
90141: PUSH
90142: LD_INT 22
90144: PUSH
90145: LD_INT 23
90147: PUSH
90148: LD_INT 24
90150: PUSH
90151: LD_INT 25
90153: PUSH
90154: LD_INT 26
90156: PUSH
90157: LD_INT 27
90159: PUSH
90160: LD_INT 28
90162: PUSH
90163: LD_INT 30
90165: PUSH
90166: LD_INT 31
90168: PUSH
90169: LD_INT 32
90171: PUSH
90172: LD_INT 33
90174: PUSH
90175: LD_INT 34
90177: PUSH
90178: LD_INT 36
90180: PUSH
90181: EMPTY
90182: LIST
90183: LIST
90184: LIST
90185: LIST
90186: LIST
90187: LIST
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: LIST
90208: LIST
90209: LIST
90210: LIST
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: PUSH
90217: LD_INT 101
90219: PUSH
90220: LD_INT 102
90222: PUSH
90223: LD_INT 103
90225: PUSH
90226: LD_INT 104
90228: PUSH
90229: LD_INT 105
90231: PUSH
90232: LD_INT 106
90234: PUSH
90235: LD_INT 107
90237: PUSH
90238: LD_INT 108
90240: PUSH
90241: LD_INT 109
90243: PUSH
90244: LD_INT 110
90246: PUSH
90247: LD_INT 111
90249: PUSH
90250: LD_INT 112
90252: PUSH
90253: LD_INT 113
90255: PUSH
90256: LD_INT 114
90258: PUSH
90259: LD_INT 116
90261: PUSH
90262: LD_INT 117
90264: PUSH
90265: LD_INT 118
90267: PUSH
90268: EMPTY
90269: LIST
90270: LIST
90271: LIST
90272: LIST
90273: LIST
90274: LIST
90275: LIST
90276: LIST
90277: LIST
90278: LIST
90279: LIST
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: ST_TO_ADDR
90291: GO 91746
90293: LD_INT 13
90295: DOUBLE
90296: EQUAL
90297: IFTRUE 90301
90299: GO 90509
90301: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
90302: LD_ADDR_VAR 0 2
90306: PUSH
90307: LD_INT 1
90309: PUSH
90310: LD_INT 2
90312: PUSH
90313: LD_INT 3
90315: PUSH
90316: LD_INT 4
90318: PUSH
90319: LD_INT 5
90321: PUSH
90322: LD_INT 8
90324: PUSH
90325: LD_INT 9
90327: PUSH
90328: LD_INT 10
90330: PUSH
90331: LD_INT 11
90333: PUSH
90334: LD_INT 12
90336: PUSH
90337: LD_INT 14
90339: PUSH
90340: LD_INT 15
90342: PUSH
90343: LD_INT 16
90345: PUSH
90346: LD_INT 17
90348: PUSH
90349: LD_INT 18
90351: PUSH
90352: LD_INT 19
90354: PUSH
90355: LD_INT 20
90357: PUSH
90358: LD_INT 21
90360: PUSH
90361: LD_INT 22
90363: PUSH
90364: LD_INT 23
90366: PUSH
90367: LD_INT 24
90369: PUSH
90370: LD_INT 25
90372: PUSH
90373: LD_INT 26
90375: PUSH
90376: LD_INT 27
90378: PUSH
90379: LD_INT 28
90381: PUSH
90382: LD_INT 30
90384: PUSH
90385: LD_INT 31
90387: PUSH
90388: LD_INT 32
90390: PUSH
90391: LD_INT 33
90393: PUSH
90394: LD_INT 34
90396: PUSH
90397: LD_INT 36
90399: PUSH
90400: EMPTY
90401: LIST
90402: LIST
90403: LIST
90404: LIST
90405: LIST
90406: LIST
90407: LIST
90408: LIST
90409: LIST
90410: LIST
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: LIST
90416: LIST
90417: LIST
90418: LIST
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: PUSH
90433: LD_INT 101
90435: PUSH
90436: LD_INT 102
90438: PUSH
90439: LD_INT 103
90441: PUSH
90442: LD_INT 104
90444: PUSH
90445: LD_INT 105
90447: PUSH
90448: LD_INT 106
90450: PUSH
90451: LD_INT 107
90453: PUSH
90454: LD_INT 108
90456: PUSH
90457: LD_INT 109
90459: PUSH
90460: LD_INT 110
90462: PUSH
90463: LD_INT 111
90465: PUSH
90466: LD_INT 112
90468: PUSH
90469: LD_INT 113
90471: PUSH
90472: LD_INT 114
90474: PUSH
90475: LD_INT 116
90477: PUSH
90478: LD_INT 117
90480: PUSH
90481: LD_INT 118
90483: PUSH
90484: EMPTY
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: LIST
90491: LIST
90492: LIST
90493: LIST
90494: LIST
90495: LIST
90496: LIST
90497: LIST
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: PUSH
90503: EMPTY
90504: LIST
90505: LIST
90506: ST_TO_ADDR
90507: GO 91746
90509: LD_INT 14
90511: DOUBLE
90512: EQUAL
90513: IFTRUE 90517
90515: GO 90741
90517: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
90518: LD_ADDR_VAR 0 2
90522: PUSH
90523: LD_INT 1
90525: PUSH
90526: LD_INT 2
90528: PUSH
90529: LD_INT 3
90531: PUSH
90532: LD_INT 4
90534: PUSH
90535: LD_INT 5
90537: PUSH
90538: LD_INT 6
90540: PUSH
90541: LD_INT 7
90543: PUSH
90544: LD_INT 8
90546: PUSH
90547: LD_INT 9
90549: PUSH
90550: LD_INT 10
90552: PUSH
90553: LD_INT 11
90555: PUSH
90556: LD_INT 12
90558: PUSH
90559: LD_INT 13
90561: PUSH
90562: LD_INT 14
90564: PUSH
90565: LD_INT 15
90567: PUSH
90568: LD_INT 16
90570: PUSH
90571: LD_INT 17
90573: PUSH
90574: LD_INT 18
90576: PUSH
90577: LD_INT 19
90579: PUSH
90580: LD_INT 20
90582: PUSH
90583: LD_INT 21
90585: PUSH
90586: LD_INT 22
90588: PUSH
90589: LD_INT 23
90591: PUSH
90592: LD_INT 24
90594: PUSH
90595: LD_INT 25
90597: PUSH
90598: LD_INT 26
90600: PUSH
90601: LD_INT 27
90603: PUSH
90604: LD_INT 28
90606: PUSH
90607: LD_INT 29
90609: PUSH
90610: LD_INT 30
90612: PUSH
90613: LD_INT 31
90615: PUSH
90616: LD_INT 32
90618: PUSH
90619: LD_INT 33
90621: PUSH
90622: LD_INT 34
90624: PUSH
90625: LD_INT 36
90627: PUSH
90628: EMPTY
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: LIST
90659: LIST
90660: LIST
90661: LIST
90662: LIST
90663: LIST
90664: PUSH
90665: LD_INT 101
90667: PUSH
90668: LD_INT 102
90670: PUSH
90671: LD_INT 103
90673: PUSH
90674: LD_INT 104
90676: PUSH
90677: LD_INT 105
90679: PUSH
90680: LD_INT 106
90682: PUSH
90683: LD_INT 107
90685: PUSH
90686: LD_INT 108
90688: PUSH
90689: LD_INT 109
90691: PUSH
90692: LD_INT 110
90694: PUSH
90695: LD_INT 111
90697: PUSH
90698: LD_INT 112
90700: PUSH
90701: LD_INT 113
90703: PUSH
90704: LD_INT 114
90706: PUSH
90707: LD_INT 116
90709: PUSH
90710: LD_INT 117
90712: PUSH
90713: LD_INT 118
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: LIST
90726: LIST
90727: LIST
90728: LIST
90729: LIST
90730: LIST
90731: LIST
90732: LIST
90733: LIST
90734: PUSH
90735: EMPTY
90736: LIST
90737: LIST
90738: ST_TO_ADDR
90739: GO 91746
90741: LD_INT 15
90743: DOUBLE
90744: EQUAL
90745: IFTRUE 90749
90747: GO 90973
90749: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
90750: LD_ADDR_VAR 0 2
90754: PUSH
90755: LD_INT 1
90757: PUSH
90758: LD_INT 2
90760: PUSH
90761: LD_INT 3
90763: PUSH
90764: LD_INT 4
90766: PUSH
90767: LD_INT 5
90769: PUSH
90770: LD_INT 6
90772: PUSH
90773: LD_INT 7
90775: PUSH
90776: LD_INT 8
90778: PUSH
90779: LD_INT 9
90781: PUSH
90782: LD_INT 10
90784: PUSH
90785: LD_INT 11
90787: PUSH
90788: LD_INT 12
90790: PUSH
90791: LD_INT 13
90793: PUSH
90794: LD_INT 14
90796: PUSH
90797: LD_INT 15
90799: PUSH
90800: LD_INT 16
90802: PUSH
90803: LD_INT 17
90805: PUSH
90806: LD_INT 18
90808: PUSH
90809: LD_INT 19
90811: PUSH
90812: LD_INT 20
90814: PUSH
90815: LD_INT 21
90817: PUSH
90818: LD_INT 22
90820: PUSH
90821: LD_INT 23
90823: PUSH
90824: LD_INT 24
90826: PUSH
90827: LD_INT 25
90829: PUSH
90830: LD_INT 26
90832: PUSH
90833: LD_INT 27
90835: PUSH
90836: LD_INT 28
90838: PUSH
90839: LD_INT 29
90841: PUSH
90842: LD_INT 30
90844: PUSH
90845: LD_INT 31
90847: PUSH
90848: LD_INT 32
90850: PUSH
90851: LD_INT 33
90853: PUSH
90854: LD_INT 34
90856: PUSH
90857: LD_INT 36
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: LIST
90888: LIST
90889: LIST
90890: LIST
90891: LIST
90892: LIST
90893: LIST
90894: LIST
90895: LIST
90896: PUSH
90897: LD_INT 101
90899: PUSH
90900: LD_INT 102
90902: PUSH
90903: LD_INT 103
90905: PUSH
90906: LD_INT 104
90908: PUSH
90909: LD_INT 105
90911: PUSH
90912: LD_INT 106
90914: PUSH
90915: LD_INT 107
90917: PUSH
90918: LD_INT 108
90920: PUSH
90921: LD_INT 109
90923: PUSH
90924: LD_INT 110
90926: PUSH
90927: LD_INT 111
90929: PUSH
90930: LD_INT 112
90932: PUSH
90933: LD_INT 113
90935: PUSH
90936: LD_INT 114
90938: PUSH
90939: LD_INT 116
90941: PUSH
90942: LD_INT 117
90944: PUSH
90945: LD_INT 118
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: LIST
90952: LIST
90953: LIST
90954: LIST
90955: LIST
90956: LIST
90957: LIST
90958: LIST
90959: LIST
90960: LIST
90961: LIST
90962: LIST
90963: LIST
90964: LIST
90965: LIST
90966: PUSH
90967: EMPTY
90968: LIST
90969: LIST
90970: ST_TO_ADDR
90971: GO 91746
90973: LD_INT 16
90975: DOUBLE
90976: EQUAL
90977: IFTRUE 90981
90979: GO 91117
90981: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
90982: LD_ADDR_VAR 0 2
90986: PUSH
90987: LD_INT 2
90989: PUSH
90990: LD_INT 4
90992: PUSH
90993: LD_INT 5
90995: PUSH
90996: LD_INT 7
90998: PUSH
90999: LD_INT 11
91001: PUSH
91002: LD_INT 12
91004: PUSH
91005: LD_INT 15
91007: PUSH
91008: LD_INT 16
91010: PUSH
91011: LD_INT 20
91013: PUSH
91014: LD_INT 21
91016: PUSH
91017: LD_INT 22
91019: PUSH
91020: LD_INT 23
91022: PUSH
91023: LD_INT 25
91025: PUSH
91026: LD_INT 26
91028: PUSH
91029: LD_INT 30
91031: PUSH
91032: LD_INT 31
91034: PUSH
91035: LD_INT 32
91037: PUSH
91038: LD_INT 33
91040: PUSH
91041: LD_INT 34
91043: PUSH
91044: EMPTY
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: LIST
91063: LIST
91064: PUSH
91065: LD_INT 101
91067: PUSH
91068: LD_INT 102
91070: PUSH
91071: LD_INT 103
91073: PUSH
91074: LD_INT 106
91076: PUSH
91077: LD_INT 108
91079: PUSH
91080: LD_INT 112
91082: PUSH
91083: LD_INT 113
91085: PUSH
91086: LD_INT 114
91088: PUSH
91089: LD_INT 116
91091: PUSH
91092: LD_INT 117
91094: PUSH
91095: LD_INT 118
91097: PUSH
91098: EMPTY
91099: LIST
91100: LIST
91101: LIST
91102: LIST
91103: LIST
91104: LIST
91105: LIST
91106: LIST
91107: LIST
91108: LIST
91109: LIST
91110: PUSH
91111: EMPTY
91112: LIST
91113: LIST
91114: ST_TO_ADDR
91115: GO 91746
91117: LD_INT 17
91119: DOUBLE
91120: EQUAL
91121: IFTRUE 91125
91123: GO 91349
91125: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
91126: LD_ADDR_VAR 0 2
91130: PUSH
91131: LD_INT 1
91133: PUSH
91134: LD_INT 2
91136: PUSH
91137: LD_INT 3
91139: PUSH
91140: LD_INT 4
91142: PUSH
91143: LD_INT 5
91145: PUSH
91146: LD_INT 6
91148: PUSH
91149: LD_INT 7
91151: PUSH
91152: LD_INT 8
91154: PUSH
91155: LD_INT 9
91157: PUSH
91158: LD_INT 10
91160: PUSH
91161: LD_INT 11
91163: PUSH
91164: LD_INT 12
91166: PUSH
91167: LD_INT 13
91169: PUSH
91170: LD_INT 14
91172: PUSH
91173: LD_INT 15
91175: PUSH
91176: LD_INT 16
91178: PUSH
91179: LD_INT 17
91181: PUSH
91182: LD_INT 18
91184: PUSH
91185: LD_INT 19
91187: PUSH
91188: LD_INT 20
91190: PUSH
91191: LD_INT 21
91193: PUSH
91194: LD_INT 22
91196: PUSH
91197: LD_INT 23
91199: PUSH
91200: LD_INT 24
91202: PUSH
91203: LD_INT 25
91205: PUSH
91206: LD_INT 26
91208: PUSH
91209: LD_INT 27
91211: PUSH
91212: LD_INT 28
91214: PUSH
91215: LD_INT 29
91217: PUSH
91218: LD_INT 30
91220: PUSH
91221: LD_INT 31
91223: PUSH
91224: LD_INT 32
91226: PUSH
91227: LD_INT 33
91229: PUSH
91230: LD_INT 34
91232: PUSH
91233: LD_INT 36
91235: PUSH
91236: EMPTY
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: LIST
91256: LIST
91257: LIST
91258: LIST
91259: LIST
91260: LIST
91261: LIST
91262: LIST
91263: LIST
91264: LIST
91265: LIST
91266: LIST
91267: LIST
91268: LIST
91269: LIST
91270: LIST
91271: LIST
91272: PUSH
91273: LD_INT 101
91275: PUSH
91276: LD_INT 102
91278: PUSH
91279: LD_INT 103
91281: PUSH
91282: LD_INT 104
91284: PUSH
91285: LD_INT 105
91287: PUSH
91288: LD_INT 106
91290: PUSH
91291: LD_INT 107
91293: PUSH
91294: LD_INT 108
91296: PUSH
91297: LD_INT 109
91299: PUSH
91300: LD_INT 110
91302: PUSH
91303: LD_INT 111
91305: PUSH
91306: LD_INT 112
91308: PUSH
91309: LD_INT 113
91311: PUSH
91312: LD_INT 114
91314: PUSH
91315: LD_INT 116
91317: PUSH
91318: LD_INT 117
91320: PUSH
91321: LD_INT 118
91323: PUSH
91324: EMPTY
91325: LIST
91326: LIST
91327: LIST
91328: LIST
91329: LIST
91330: LIST
91331: LIST
91332: LIST
91333: LIST
91334: LIST
91335: LIST
91336: LIST
91337: LIST
91338: LIST
91339: LIST
91340: LIST
91341: LIST
91342: PUSH
91343: EMPTY
91344: LIST
91345: LIST
91346: ST_TO_ADDR
91347: GO 91746
91349: LD_INT 18
91351: DOUBLE
91352: EQUAL
91353: IFTRUE 91357
91355: GO 91505
91357: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
91358: LD_ADDR_VAR 0 2
91362: PUSH
91363: LD_INT 2
91365: PUSH
91366: LD_INT 4
91368: PUSH
91369: LD_INT 5
91371: PUSH
91372: LD_INT 7
91374: PUSH
91375: LD_INT 11
91377: PUSH
91378: LD_INT 12
91380: PUSH
91381: LD_INT 15
91383: PUSH
91384: LD_INT 16
91386: PUSH
91387: LD_INT 20
91389: PUSH
91390: LD_INT 21
91392: PUSH
91393: LD_INT 22
91395: PUSH
91396: LD_INT 23
91398: PUSH
91399: LD_INT 25
91401: PUSH
91402: LD_INT 26
91404: PUSH
91405: LD_INT 30
91407: PUSH
91408: LD_INT 31
91410: PUSH
91411: LD_INT 32
91413: PUSH
91414: LD_INT 33
91416: PUSH
91417: LD_INT 34
91419: PUSH
91420: LD_INT 35
91422: PUSH
91423: LD_INT 36
91425: PUSH
91426: EMPTY
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: PUSH
91449: LD_INT 101
91451: PUSH
91452: LD_INT 102
91454: PUSH
91455: LD_INT 103
91457: PUSH
91458: LD_INT 106
91460: PUSH
91461: LD_INT 108
91463: PUSH
91464: LD_INT 112
91466: PUSH
91467: LD_INT 113
91469: PUSH
91470: LD_INT 114
91472: PUSH
91473: LD_INT 115
91475: PUSH
91476: LD_INT 116
91478: PUSH
91479: LD_INT 117
91481: PUSH
91482: LD_INT 118
91484: PUSH
91485: EMPTY
91486: LIST
91487: LIST
91488: LIST
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: PUSH
91499: EMPTY
91500: LIST
91501: LIST
91502: ST_TO_ADDR
91503: GO 91746
91505: LD_INT 19
91507: DOUBLE
91508: EQUAL
91509: IFTRUE 91513
91511: GO 91745
91513: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
91514: LD_ADDR_VAR 0 2
91518: PUSH
91519: LD_INT 1
91521: PUSH
91522: LD_INT 2
91524: PUSH
91525: LD_INT 3
91527: PUSH
91528: LD_INT 4
91530: PUSH
91531: LD_INT 5
91533: PUSH
91534: LD_INT 6
91536: PUSH
91537: LD_INT 7
91539: PUSH
91540: LD_INT 8
91542: PUSH
91543: LD_INT 9
91545: PUSH
91546: LD_INT 10
91548: PUSH
91549: LD_INT 11
91551: PUSH
91552: LD_INT 12
91554: PUSH
91555: LD_INT 13
91557: PUSH
91558: LD_INT 14
91560: PUSH
91561: LD_INT 15
91563: PUSH
91564: LD_INT 16
91566: PUSH
91567: LD_INT 17
91569: PUSH
91570: LD_INT 18
91572: PUSH
91573: LD_INT 19
91575: PUSH
91576: LD_INT 20
91578: PUSH
91579: LD_INT 21
91581: PUSH
91582: LD_INT 22
91584: PUSH
91585: LD_INT 23
91587: PUSH
91588: LD_INT 24
91590: PUSH
91591: LD_INT 25
91593: PUSH
91594: LD_INT 26
91596: PUSH
91597: LD_INT 27
91599: PUSH
91600: LD_INT 28
91602: PUSH
91603: LD_INT 29
91605: PUSH
91606: LD_INT 30
91608: PUSH
91609: LD_INT 31
91611: PUSH
91612: LD_INT 32
91614: PUSH
91615: LD_INT 33
91617: PUSH
91618: LD_INT 34
91620: PUSH
91621: LD_INT 35
91623: PUSH
91624: LD_INT 36
91626: PUSH
91627: EMPTY
91628: LIST
91629: LIST
91630: LIST
91631: LIST
91632: LIST
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: PUSH
91665: LD_INT 101
91667: PUSH
91668: LD_INT 102
91670: PUSH
91671: LD_INT 103
91673: PUSH
91674: LD_INT 104
91676: PUSH
91677: LD_INT 105
91679: PUSH
91680: LD_INT 106
91682: PUSH
91683: LD_INT 107
91685: PUSH
91686: LD_INT 108
91688: PUSH
91689: LD_INT 109
91691: PUSH
91692: LD_INT 110
91694: PUSH
91695: LD_INT 111
91697: PUSH
91698: LD_INT 112
91700: PUSH
91701: LD_INT 113
91703: PUSH
91704: LD_INT 114
91706: PUSH
91707: LD_INT 115
91709: PUSH
91710: LD_INT 116
91712: PUSH
91713: LD_INT 117
91715: PUSH
91716: LD_INT 118
91718: PUSH
91719: EMPTY
91720: LIST
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: ST_TO_ADDR
91743: GO 91746
91745: POP
// end else
91746: GO 91977
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
91748: LD_ADDR_VAR 0 2
91752: PUSH
91753: LD_INT 1
91755: PUSH
91756: LD_INT 2
91758: PUSH
91759: LD_INT 3
91761: PUSH
91762: LD_INT 4
91764: PUSH
91765: LD_INT 5
91767: PUSH
91768: LD_INT 6
91770: PUSH
91771: LD_INT 7
91773: PUSH
91774: LD_INT 8
91776: PUSH
91777: LD_INT 9
91779: PUSH
91780: LD_INT 10
91782: PUSH
91783: LD_INT 11
91785: PUSH
91786: LD_INT 12
91788: PUSH
91789: LD_INT 13
91791: PUSH
91792: LD_INT 14
91794: PUSH
91795: LD_INT 15
91797: PUSH
91798: LD_INT 16
91800: PUSH
91801: LD_INT 17
91803: PUSH
91804: LD_INT 18
91806: PUSH
91807: LD_INT 19
91809: PUSH
91810: LD_INT 20
91812: PUSH
91813: LD_INT 21
91815: PUSH
91816: LD_INT 22
91818: PUSH
91819: LD_INT 23
91821: PUSH
91822: LD_INT 24
91824: PUSH
91825: LD_INT 25
91827: PUSH
91828: LD_INT 26
91830: PUSH
91831: LD_INT 27
91833: PUSH
91834: LD_INT 28
91836: PUSH
91837: LD_INT 29
91839: PUSH
91840: LD_INT 30
91842: PUSH
91843: LD_INT 31
91845: PUSH
91846: LD_INT 32
91848: PUSH
91849: LD_INT 33
91851: PUSH
91852: LD_INT 34
91854: PUSH
91855: LD_INT 35
91857: PUSH
91858: LD_INT 36
91860: PUSH
91861: EMPTY
91862: LIST
91863: LIST
91864: LIST
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: PUSH
91899: LD_INT 101
91901: PUSH
91902: LD_INT 102
91904: PUSH
91905: LD_INT 103
91907: PUSH
91908: LD_INT 104
91910: PUSH
91911: LD_INT 105
91913: PUSH
91914: LD_INT 106
91916: PUSH
91917: LD_INT 107
91919: PUSH
91920: LD_INT 108
91922: PUSH
91923: LD_INT 109
91925: PUSH
91926: LD_INT 110
91928: PUSH
91929: LD_INT 111
91931: PUSH
91932: LD_INT 112
91934: PUSH
91935: LD_INT 113
91937: PUSH
91938: LD_INT 114
91940: PUSH
91941: LD_INT 115
91943: PUSH
91944: LD_INT 116
91946: PUSH
91947: LD_INT 117
91949: PUSH
91950: LD_INT 118
91952: PUSH
91953: EMPTY
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: PUSH
91973: EMPTY
91974: LIST
91975: LIST
91976: ST_TO_ADDR
// if result then
91977: LD_VAR 0 2
91981: IFFALSE 92767
// begin normal :=  ;
91983: LD_ADDR_VAR 0 5
91987: PUSH
91988: LD_STRING 
91990: ST_TO_ADDR
// hardcore :=  ;
91991: LD_ADDR_VAR 0 6
91995: PUSH
91996: LD_STRING 
91998: ST_TO_ADDR
// active :=  ;
91999: LD_ADDR_VAR 0 7
92003: PUSH
92004: LD_STRING 
92006: ST_TO_ADDR
// for i = 1 to normalCounter do
92007: LD_ADDR_VAR 0 8
92011: PUSH
92012: DOUBLE
92013: LD_INT 1
92015: DEC
92016: ST_TO_ADDR
92017: LD_EXP 123
92021: PUSH
92022: FOR_TO
92023: IFFALSE 92124
// begin tmp := 0 ;
92025: LD_ADDR_VAR 0 3
92029: PUSH
92030: LD_STRING 0
92032: ST_TO_ADDR
// if result [ 1 ] then
92033: LD_VAR 0 2
92037: PUSH
92038: LD_INT 1
92040: ARRAY
92041: IFFALSE 92106
// if result [ 1 ] [ 1 ] = i then
92043: LD_VAR 0 2
92047: PUSH
92048: LD_INT 1
92050: ARRAY
92051: PUSH
92052: LD_INT 1
92054: ARRAY
92055: PUSH
92056: LD_VAR 0 8
92060: EQUAL
92061: IFFALSE 92106
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92063: LD_ADDR_VAR 0 2
92067: PUSH
92068: LD_VAR 0 2
92072: PPUSH
92073: LD_INT 1
92075: PPUSH
92076: LD_VAR 0 2
92080: PUSH
92081: LD_INT 1
92083: ARRAY
92084: PPUSH
92085: LD_INT 1
92087: PPUSH
92088: CALL_OW 3
92092: PPUSH
92093: CALL_OW 1
92097: ST_TO_ADDR
// tmp := 1 ;
92098: LD_ADDR_VAR 0 3
92102: PUSH
92103: LD_STRING 1
92105: ST_TO_ADDR
// end ; normal := normal & tmp ;
92106: LD_ADDR_VAR 0 5
92110: PUSH
92111: LD_VAR 0 5
92115: PUSH
92116: LD_VAR 0 3
92120: STR
92121: ST_TO_ADDR
// end ;
92122: GO 92022
92124: POP
92125: POP
// for i = 1 to hardcoreCounter do
92126: LD_ADDR_VAR 0 8
92130: PUSH
92131: DOUBLE
92132: LD_INT 1
92134: DEC
92135: ST_TO_ADDR
92136: LD_EXP 124
92140: PUSH
92141: FOR_TO
92142: IFFALSE 92247
// begin tmp := 0 ;
92144: LD_ADDR_VAR 0 3
92148: PUSH
92149: LD_STRING 0
92151: ST_TO_ADDR
// if result [ 2 ] then
92152: LD_VAR 0 2
92156: PUSH
92157: LD_INT 2
92159: ARRAY
92160: IFFALSE 92229
// if result [ 2 ] [ 1 ] = 100 + i then
92162: LD_VAR 0 2
92166: PUSH
92167: LD_INT 2
92169: ARRAY
92170: PUSH
92171: LD_INT 1
92173: ARRAY
92174: PUSH
92175: LD_INT 100
92177: PUSH
92178: LD_VAR 0 8
92182: PLUS
92183: EQUAL
92184: IFFALSE 92229
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92186: LD_ADDR_VAR 0 2
92190: PUSH
92191: LD_VAR 0 2
92195: PPUSH
92196: LD_INT 2
92198: PPUSH
92199: LD_VAR 0 2
92203: PUSH
92204: LD_INT 2
92206: ARRAY
92207: PPUSH
92208: LD_INT 1
92210: PPUSH
92211: CALL_OW 3
92215: PPUSH
92216: CALL_OW 1
92220: ST_TO_ADDR
// tmp := 1 ;
92221: LD_ADDR_VAR 0 3
92225: PUSH
92226: LD_STRING 1
92228: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92229: LD_ADDR_VAR 0 6
92233: PUSH
92234: LD_VAR 0 6
92238: PUSH
92239: LD_VAR 0 3
92243: STR
92244: ST_TO_ADDR
// end ;
92245: GO 92141
92247: POP
92248: POP
// if isGameLoad then
92249: LD_VAR 0 1
92253: IFFALSE 92728
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
92255: LD_ADDR_VAR 0 4
92259: PUSH
92260: LD_EXP 127
92264: PUSH
92265: LD_EXP 126
92269: PUSH
92270: LD_EXP 128
92274: PUSH
92275: LD_EXP 125
92279: PUSH
92280: LD_EXP 129
92284: PUSH
92285: LD_EXP 130
92289: PUSH
92290: LD_EXP 131
92294: PUSH
92295: LD_EXP 132
92299: PUSH
92300: LD_EXP 133
92304: PUSH
92305: LD_EXP 134
92309: PUSH
92310: LD_EXP 135
92314: PUSH
92315: LD_EXP 136
92319: PUSH
92320: LD_EXP 137
92324: PUSH
92325: LD_EXP 138
92329: PUSH
92330: LD_EXP 146
92334: PUSH
92335: LD_EXP 147
92339: PUSH
92340: LD_EXP 148
92344: PUSH
92345: LD_EXP 149
92349: PUSH
92350: LD_EXP 151
92354: PUSH
92355: LD_EXP 152
92359: PUSH
92360: LD_EXP 153
92364: PUSH
92365: LD_EXP 156
92369: PUSH
92370: LD_EXP 158
92374: PUSH
92375: LD_EXP 159
92379: PUSH
92380: LD_EXP 160
92384: PUSH
92385: LD_EXP 162
92389: PUSH
92390: LD_EXP 163
92394: PUSH
92395: LD_EXP 166
92399: PUSH
92400: LD_EXP 167
92404: PUSH
92405: LD_EXP 168
92409: PUSH
92410: LD_EXP 169
92414: PUSH
92415: LD_EXP 170
92419: PUSH
92420: LD_EXP 171
92424: PUSH
92425: LD_EXP 172
92429: PUSH
92430: LD_EXP 173
92434: PUSH
92435: LD_EXP 174
92439: PUSH
92440: LD_EXP 139
92444: PUSH
92445: LD_EXP 140
92449: PUSH
92450: LD_EXP 143
92454: PUSH
92455: LD_EXP 144
92459: PUSH
92460: LD_EXP 145
92464: PUSH
92465: LD_EXP 141
92469: PUSH
92470: LD_EXP 142
92474: PUSH
92475: LD_EXP 150
92479: PUSH
92480: LD_EXP 154
92484: PUSH
92485: LD_EXP 155
92489: PUSH
92490: LD_EXP 157
92494: PUSH
92495: LD_EXP 161
92499: PUSH
92500: LD_EXP 164
92504: PUSH
92505: LD_EXP 165
92509: PUSH
92510: LD_EXP 175
92514: PUSH
92515: LD_EXP 176
92519: PUSH
92520: LD_EXP 177
92524: PUSH
92525: LD_EXP 178
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: LIST
92534: LIST
92535: LIST
92536: LIST
92537: LIST
92538: LIST
92539: LIST
92540: LIST
92541: LIST
92542: LIST
92543: LIST
92544: LIST
92545: LIST
92546: LIST
92547: LIST
92548: LIST
92549: LIST
92550: LIST
92551: LIST
92552: LIST
92553: LIST
92554: LIST
92555: LIST
92556: LIST
92557: LIST
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: LIST
92568: LIST
92569: LIST
92570: LIST
92571: LIST
92572: LIST
92573: LIST
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: ST_TO_ADDR
// tmp :=  ;
92586: LD_ADDR_VAR 0 3
92590: PUSH
92591: LD_STRING 
92593: ST_TO_ADDR
// for i = 1 to normalCounter do
92594: LD_ADDR_VAR 0 8
92598: PUSH
92599: DOUBLE
92600: LD_INT 1
92602: DEC
92603: ST_TO_ADDR
92604: LD_EXP 123
92608: PUSH
92609: FOR_TO
92610: IFFALSE 92646
// begin if flags [ i ] then
92612: LD_VAR 0 4
92616: PUSH
92617: LD_VAR 0 8
92621: ARRAY
92622: IFFALSE 92644
// tmp := tmp & i & ; ;
92624: LD_ADDR_VAR 0 3
92628: PUSH
92629: LD_VAR 0 3
92633: PUSH
92634: LD_VAR 0 8
92638: STR
92639: PUSH
92640: LD_STRING ;
92642: STR
92643: ST_TO_ADDR
// end ;
92644: GO 92609
92646: POP
92647: POP
// for i = 1 to hardcoreCounter do
92648: LD_ADDR_VAR 0 8
92652: PUSH
92653: DOUBLE
92654: LD_INT 1
92656: DEC
92657: ST_TO_ADDR
92658: LD_EXP 124
92662: PUSH
92663: FOR_TO
92664: IFFALSE 92710
// begin if flags [ normalCounter + i ] then
92666: LD_VAR 0 4
92670: PUSH
92671: LD_EXP 123
92675: PUSH
92676: LD_VAR 0 8
92680: PLUS
92681: ARRAY
92682: IFFALSE 92708
// tmp := tmp & ( 100 + i ) & ; ;
92684: LD_ADDR_VAR 0 3
92688: PUSH
92689: LD_VAR 0 3
92693: PUSH
92694: LD_INT 100
92696: PUSH
92697: LD_VAR 0 8
92701: PLUS
92702: STR
92703: PUSH
92704: LD_STRING ;
92706: STR
92707: ST_TO_ADDR
// end ;
92708: GO 92663
92710: POP
92711: POP
// if tmp then
92712: LD_VAR 0 3
92716: IFFALSE 92728
// active := tmp ;
92718: LD_ADDR_VAR 0 7
92722: PUSH
92723: LD_VAR 0 3
92727: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
92728: LD_STRING getStreamItemsFromMission("
92730: PUSH
92731: LD_VAR 0 5
92735: STR
92736: PUSH
92737: LD_STRING ","
92739: STR
92740: PUSH
92741: LD_VAR 0 6
92745: STR
92746: PUSH
92747: LD_STRING ","
92749: STR
92750: PUSH
92751: LD_VAR 0 7
92755: STR
92756: PUSH
92757: LD_STRING ")
92759: STR
92760: PPUSH
92761: CALL_OW 559
// end else
92765: GO 92774
// ToLua ( getStreamItemsFromMission("","","") ) ;
92767: LD_STRING getStreamItemsFromMission("","","")
92769: PPUSH
92770: CALL_OW 559
// end ;
92774: LD_VAR 0 2
92778: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92779: LD_EXP 122
92783: PUSH
92784: LD_EXP 127
92788: AND
92789: IFFALSE 92913
92791: GO 92793
92793: DISABLE
92794: LD_INT 0
92796: PPUSH
92797: PPUSH
// begin enable ;
92798: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92799: LD_ADDR_VAR 0 2
92803: PUSH
92804: LD_INT 22
92806: PUSH
92807: LD_OWVAR 2
92811: PUSH
92812: EMPTY
92813: LIST
92814: LIST
92815: PUSH
92816: LD_INT 2
92818: PUSH
92819: LD_INT 34
92821: PUSH
92822: LD_INT 7
92824: PUSH
92825: EMPTY
92826: LIST
92827: LIST
92828: PUSH
92829: LD_INT 34
92831: PUSH
92832: LD_INT 45
92834: PUSH
92835: EMPTY
92836: LIST
92837: LIST
92838: PUSH
92839: LD_INT 34
92841: PUSH
92842: LD_INT 28
92844: PUSH
92845: EMPTY
92846: LIST
92847: LIST
92848: PUSH
92849: LD_INT 34
92851: PUSH
92852: LD_INT 47
92854: PUSH
92855: EMPTY
92856: LIST
92857: LIST
92858: PUSH
92859: EMPTY
92860: LIST
92861: LIST
92862: LIST
92863: LIST
92864: LIST
92865: PUSH
92866: EMPTY
92867: LIST
92868: LIST
92869: PPUSH
92870: CALL_OW 69
92874: ST_TO_ADDR
// if not tmp then
92875: LD_VAR 0 2
92879: NOT
92880: IFFALSE 92884
// exit ;
92882: GO 92913
// for i in tmp do
92884: LD_ADDR_VAR 0 1
92888: PUSH
92889: LD_VAR 0 2
92893: PUSH
92894: FOR_IN
92895: IFFALSE 92911
// begin SetLives ( i , 0 ) ;
92897: LD_VAR 0 1
92901: PPUSH
92902: LD_INT 0
92904: PPUSH
92905: CALL_OW 234
// end ;
92909: GO 92894
92911: POP
92912: POP
// end ;
92913: PPOPN 2
92915: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92916: LD_EXP 122
92920: PUSH
92921: LD_EXP 128
92925: AND
92926: IFFALSE 93010
92928: GO 92930
92930: DISABLE
92931: LD_INT 0
92933: PPUSH
92934: PPUSH
// begin enable ;
92935: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92936: LD_ADDR_VAR 0 2
92940: PUSH
92941: LD_INT 22
92943: PUSH
92944: LD_OWVAR 2
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: LD_INT 32
92955: PUSH
92956: LD_INT 3
92958: PUSH
92959: EMPTY
92960: LIST
92961: LIST
92962: PUSH
92963: EMPTY
92964: LIST
92965: LIST
92966: PPUSH
92967: CALL_OW 69
92971: ST_TO_ADDR
// if not tmp then
92972: LD_VAR 0 2
92976: NOT
92977: IFFALSE 92981
// exit ;
92979: GO 93010
// for i in tmp do
92981: LD_ADDR_VAR 0 1
92985: PUSH
92986: LD_VAR 0 2
92990: PUSH
92991: FOR_IN
92992: IFFALSE 93008
// begin SetLives ( i , 0 ) ;
92994: LD_VAR 0 1
92998: PPUSH
92999: LD_INT 0
93001: PPUSH
93002: CALL_OW 234
// end ;
93006: GO 92991
93008: POP
93009: POP
// end ;
93010: PPOPN 2
93012: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
93013: LD_EXP 122
93017: PUSH
93018: LD_EXP 125
93022: AND
93023: IFFALSE 93116
93025: GO 93027
93027: DISABLE
93028: LD_INT 0
93030: PPUSH
// begin enable ;
93031: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
93032: LD_ADDR_VAR 0 1
93036: PUSH
93037: LD_INT 22
93039: PUSH
93040: LD_OWVAR 2
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: PUSH
93049: LD_INT 2
93051: PUSH
93052: LD_INT 25
93054: PUSH
93055: LD_INT 5
93057: PUSH
93058: EMPTY
93059: LIST
93060: LIST
93061: PUSH
93062: LD_INT 25
93064: PUSH
93065: LD_INT 9
93067: PUSH
93068: EMPTY
93069: LIST
93070: LIST
93071: PUSH
93072: LD_INT 25
93074: PUSH
93075: LD_INT 8
93077: PUSH
93078: EMPTY
93079: LIST
93080: LIST
93081: PUSH
93082: EMPTY
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: PUSH
93088: EMPTY
93089: LIST
93090: LIST
93091: PPUSH
93092: CALL_OW 69
93096: PUSH
93097: FOR_IN
93098: IFFALSE 93114
// begin SetClass ( i , 1 ) ;
93100: LD_VAR 0 1
93104: PPUSH
93105: LD_INT 1
93107: PPUSH
93108: CALL_OW 336
// end ;
93112: GO 93097
93114: POP
93115: POP
// end ;
93116: PPOPN 1
93118: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
93119: LD_EXP 122
93123: PUSH
93124: LD_EXP 126
93128: AND
93129: PUSH
93130: LD_OWVAR 65
93134: PUSH
93135: LD_INT 7
93137: LESS
93138: AND
93139: IFFALSE 93153
93141: GO 93143
93143: DISABLE
// begin enable ;
93144: ENABLE
// game_speed := 7 ;
93145: LD_ADDR_OWVAR 65
93149: PUSH
93150: LD_INT 7
93152: ST_TO_ADDR
// end ;
93153: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
93154: LD_EXP 122
93158: PUSH
93159: LD_EXP 129
93163: AND
93164: IFFALSE 93366
93166: GO 93168
93168: DISABLE
93169: LD_INT 0
93171: PPUSH
93172: PPUSH
93173: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
93174: LD_ADDR_VAR 0 3
93178: PUSH
93179: LD_INT 81
93181: PUSH
93182: LD_OWVAR 2
93186: PUSH
93187: EMPTY
93188: LIST
93189: LIST
93190: PUSH
93191: LD_INT 21
93193: PUSH
93194: LD_INT 1
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: PUSH
93201: EMPTY
93202: LIST
93203: LIST
93204: PPUSH
93205: CALL_OW 69
93209: ST_TO_ADDR
// if not tmp then
93210: LD_VAR 0 3
93214: NOT
93215: IFFALSE 93219
// exit ;
93217: GO 93366
// if tmp > 5 then
93219: LD_VAR 0 3
93223: PUSH
93224: LD_INT 5
93226: GREATER
93227: IFFALSE 93239
// k := 5 else
93229: LD_ADDR_VAR 0 2
93233: PUSH
93234: LD_INT 5
93236: ST_TO_ADDR
93237: GO 93249
// k := tmp ;
93239: LD_ADDR_VAR 0 2
93243: PUSH
93244: LD_VAR 0 3
93248: ST_TO_ADDR
// for i := 1 to k do
93249: LD_ADDR_VAR 0 1
93253: PUSH
93254: DOUBLE
93255: LD_INT 1
93257: DEC
93258: ST_TO_ADDR
93259: LD_VAR 0 2
93263: PUSH
93264: FOR_TO
93265: IFFALSE 93364
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
93267: LD_VAR 0 3
93271: PUSH
93272: LD_VAR 0 1
93276: ARRAY
93277: PPUSH
93278: LD_VAR 0 1
93282: PUSH
93283: LD_INT 4
93285: MOD
93286: PUSH
93287: LD_INT 1
93289: PLUS
93290: PPUSH
93291: CALL_OW 259
93295: PUSH
93296: LD_INT 10
93298: LESS
93299: IFFALSE 93362
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
93301: LD_VAR 0 3
93305: PUSH
93306: LD_VAR 0 1
93310: ARRAY
93311: PPUSH
93312: LD_VAR 0 1
93316: PUSH
93317: LD_INT 4
93319: MOD
93320: PUSH
93321: LD_INT 1
93323: PLUS
93324: PPUSH
93325: LD_VAR 0 3
93329: PUSH
93330: LD_VAR 0 1
93334: ARRAY
93335: PPUSH
93336: LD_VAR 0 1
93340: PUSH
93341: LD_INT 4
93343: MOD
93344: PUSH
93345: LD_INT 1
93347: PLUS
93348: PPUSH
93349: CALL_OW 259
93353: PUSH
93354: LD_INT 1
93356: PLUS
93357: PPUSH
93358: CALL_OW 237
93362: GO 93264
93364: POP
93365: POP
// end ;
93366: PPOPN 3
93368: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93369: LD_EXP 122
93373: PUSH
93374: LD_EXP 130
93378: AND
93379: IFFALSE 93399
93381: GO 93383
93383: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93384: LD_INT 4
93386: PPUSH
93387: LD_OWVAR 2
93391: PPUSH
93392: LD_INT 0
93394: PPUSH
93395: CALL_OW 324
93399: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93400: LD_EXP 122
93404: PUSH
93405: LD_EXP 159
93409: AND
93410: IFFALSE 93430
93412: GO 93414
93414: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93415: LD_INT 19
93417: PPUSH
93418: LD_OWVAR 2
93422: PPUSH
93423: LD_INT 0
93425: PPUSH
93426: CALL_OW 324
93430: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93431: LD_EXP 122
93435: PUSH
93436: LD_EXP 131
93440: AND
93441: IFFALSE 93543
93443: GO 93445
93445: DISABLE
93446: LD_INT 0
93448: PPUSH
93449: PPUSH
// begin enable ;
93450: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93451: LD_ADDR_VAR 0 2
93455: PUSH
93456: LD_INT 22
93458: PUSH
93459: LD_OWVAR 2
93463: PUSH
93464: EMPTY
93465: LIST
93466: LIST
93467: PUSH
93468: LD_INT 2
93470: PUSH
93471: LD_INT 34
93473: PUSH
93474: LD_INT 11
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 34
93483: PUSH
93484: LD_INT 30
93486: PUSH
93487: EMPTY
93488: LIST
93489: LIST
93490: PUSH
93491: EMPTY
93492: LIST
93493: LIST
93494: LIST
93495: PUSH
93496: EMPTY
93497: LIST
93498: LIST
93499: PPUSH
93500: CALL_OW 69
93504: ST_TO_ADDR
// if not tmp then
93505: LD_VAR 0 2
93509: NOT
93510: IFFALSE 93514
// exit ;
93512: GO 93543
// for i in tmp do
93514: LD_ADDR_VAR 0 1
93518: PUSH
93519: LD_VAR 0 2
93523: PUSH
93524: FOR_IN
93525: IFFALSE 93541
// begin SetLives ( i , 0 ) ;
93527: LD_VAR 0 1
93531: PPUSH
93532: LD_INT 0
93534: PPUSH
93535: CALL_OW 234
// end ;
93539: GO 93524
93541: POP
93542: POP
// end ;
93543: PPOPN 2
93545: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93546: LD_EXP 122
93550: PUSH
93551: LD_EXP 132
93555: AND
93556: IFFALSE 93576
93558: GO 93560
93560: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93561: LD_INT 32
93563: PPUSH
93564: LD_OWVAR 2
93568: PPUSH
93569: LD_INT 0
93571: PPUSH
93572: CALL_OW 324
93576: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93577: LD_EXP 122
93581: PUSH
93582: LD_EXP 133
93586: AND
93587: IFFALSE 93768
93589: GO 93591
93591: DISABLE
93592: LD_INT 0
93594: PPUSH
93595: PPUSH
93596: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93597: LD_ADDR_VAR 0 2
93601: PUSH
93602: LD_INT 22
93604: PUSH
93605: LD_OWVAR 2
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: LD_INT 33
93616: PUSH
93617: LD_INT 3
93619: PUSH
93620: EMPTY
93621: LIST
93622: LIST
93623: PUSH
93624: EMPTY
93625: LIST
93626: LIST
93627: PPUSH
93628: CALL_OW 69
93632: ST_TO_ADDR
// if not tmp then
93633: LD_VAR 0 2
93637: NOT
93638: IFFALSE 93642
// exit ;
93640: GO 93768
// side := 0 ;
93642: LD_ADDR_VAR 0 3
93646: PUSH
93647: LD_INT 0
93649: ST_TO_ADDR
// for i := 1 to 8 do
93650: LD_ADDR_VAR 0 1
93654: PUSH
93655: DOUBLE
93656: LD_INT 1
93658: DEC
93659: ST_TO_ADDR
93660: LD_INT 8
93662: PUSH
93663: FOR_TO
93664: IFFALSE 93712
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93666: LD_OWVAR 2
93670: PUSH
93671: LD_VAR 0 1
93675: NONEQUAL
93676: PUSH
93677: LD_OWVAR 2
93681: PPUSH
93682: LD_VAR 0 1
93686: PPUSH
93687: CALL_OW 81
93691: PUSH
93692: LD_INT 2
93694: EQUAL
93695: AND
93696: IFFALSE 93710
// begin side := i ;
93698: LD_ADDR_VAR 0 3
93702: PUSH
93703: LD_VAR 0 1
93707: ST_TO_ADDR
// break ;
93708: GO 93712
// end ;
93710: GO 93663
93712: POP
93713: POP
// if not side then
93714: LD_VAR 0 3
93718: NOT
93719: IFFALSE 93723
// exit ;
93721: GO 93768
// for i := 1 to tmp do
93723: LD_ADDR_VAR 0 1
93727: PUSH
93728: DOUBLE
93729: LD_INT 1
93731: DEC
93732: ST_TO_ADDR
93733: LD_VAR 0 2
93737: PUSH
93738: FOR_TO
93739: IFFALSE 93766
// if Prob ( 60 ) then
93741: LD_INT 60
93743: PPUSH
93744: CALL_OW 13
93748: IFFALSE 93764
// SetSide ( i , side ) ;
93750: LD_VAR 0 1
93754: PPUSH
93755: LD_VAR 0 3
93759: PPUSH
93760: CALL_OW 235
93764: GO 93738
93766: POP
93767: POP
// end ;
93768: PPOPN 3
93770: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93771: LD_EXP 122
93775: PUSH
93776: LD_EXP 135
93780: AND
93781: IFFALSE 93900
93783: GO 93785
93785: DISABLE
93786: LD_INT 0
93788: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93789: LD_ADDR_VAR 0 1
93793: PUSH
93794: LD_INT 22
93796: PUSH
93797: LD_OWVAR 2
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 21
93808: PUSH
93809: LD_INT 1
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: LD_INT 3
93818: PUSH
93819: LD_INT 23
93821: PUSH
93822: LD_INT 0
93824: PUSH
93825: EMPTY
93826: LIST
93827: LIST
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: EMPTY
93834: LIST
93835: LIST
93836: LIST
93837: PPUSH
93838: CALL_OW 69
93842: PUSH
93843: FOR_IN
93844: IFFALSE 93898
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93846: LD_VAR 0 1
93850: PPUSH
93851: CALL_OW 257
93855: PUSH
93856: LD_INT 1
93858: PUSH
93859: LD_INT 2
93861: PUSH
93862: LD_INT 3
93864: PUSH
93865: LD_INT 4
93867: PUSH
93868: EMPTY
93869: LIST
93870: LIST
93871: LIST
93872: LIST
93873: IN
93874: IFFALSE 93896
// SetClass ( un , rand ( 1 , 4 ) ) ;
93876: LD_VAR 0 1
93880: PPUSH
93881: LD_INT 1
93883: PPUSH
93884: LD_INT 4
93886: PPUSH
93887: CALL_OW 12
93891: PPUSH
93892: CALL_OW 336
93896: GO 93843
93898: POP
93899: POP
// end ;
93900: PPOPN 1
93902: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93903: LD_EXP 122
93907: PUSH
93908: LD_EXP 134
93912: AND
93913: IFFALSE 93992
93915: GO 93917
93917: DISABLE
93918: LD_INT 0
93920: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93921: LD_ADDR_VAR 0 1
93925: PUSH
93926: LD_INT 22
93928: PUSH
93929: LD_OWVAR 2
93933: PUSH
93934: EMPTY
93935: LIST
93936: LIST
93937: PUSH
93938: LD_INT 21
93940: PUSH
93941: LD_INT 3
93943: PUSH
93944: EMPTY
93945: LIST
93946: LIST
93947: PUSH
93948: EMPTY
93949: LIST
93950: LIST
93951: PPUSH
93952: CALL_OW 69
93956: ST_TO_ADDR
// if not tmp then
93957: LD_VAR 0 1
93961: NOT
93962: IFFALSE 93966
// exit ;
93964: GO 93992
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93966: LD_VAR 0 1
93970: PUSH
93971: LD_INT 1
93973: PPUSH
93974: LD_VAR 0 1
93978: PPUSH
93979: CALL_OW 12
93983: ARRAY
93984: PPUSH
93985: LD_INT 100
93987: PPUSH
93988: CALL_OW 234
// end ;
93992: PPOPN 1
93994: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93995: LD_EXP 122
93999: PUSH
94000: LD_EXP 136
94004: AND
94005: IFFALSE 94103
94007: GO 94009
94009: DISABLE
94010: LD_INT 0
94012: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
94013: LD_ADDR_VAR 0 1
94017: PUSH
94018: LD_INT 22
94020: PUSH
94021: LD_OWVAR 2
94025: PUSH
94026: EMPTY
94027: LIST
94028: LIST
94029: PUSH
94030: LD_INT 21
94032: PUSH
94033: LD_INT 1
94035: PUSH
94036: EMPTY
94037: LIST
94038: LIST
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: PPUSH
94044: CALL_OW 69
94048: ST_TO_ADDR
// if not tmp then
94049: LD_VAR 0 1
94053: NOT
94054: IFFALSE 94058
// exit ;
94056: GO 94103
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
94058: LD_VAR 0 1
94062: PUSH
94063: LD_INT 1
94065: PPUSH
94066: LD_VAR 0 1
94070: PPUSH
94071: CALL_OW 12
94075: ARRAY
94076: PPUSH
94077: LD_INT 1
94079: PPUSH
94080: LD_INT 4
94082: PPUSH
94083: CALL_OW 12
94087: PPUSH
94088: LD_INT 3000
94090: PPUSH
94091: LD_INT 9000
94093: PPUSH
94094: CALL_OW 12
94098: PPUSH
94099: CALL_OW 492
// end ;
94103: PPOPN 1
94105: END
// every 0 0$1 trigger StreamModeActive and sDepot do
94106: LD_EXP 122
94110: PUSH
94111: LD_EXP 137
94115: AND
94116: IFFALSE 94136
94118: GO 94120
94120: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
94121: LD_INT 1
94123: PPUSH
94124: LD_OWVAR 2
94128: PPUSH
94129: LD_INT 0
94131: PPUSH
94132: CALL_OW 324
94136: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
94137: LD_EXP 122
94141: PUSH
94142: LD_EXP 138
94146: AND
94147: IFFALSE 94230
94149: GO 94151
94151: DISABLE
94152: LD_INT 0
94154: PPUSH
94155: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94156: LD_ADDR_VAR 0 2
94160: PUSH
94161: LD_INT 22
94163: PUSH
94164: LD_OWVAR 2
94168: PUSH
94169: EMPTY
94170: LIST
94171: LIST
94172: PUSH
94173: LD_INT 21
94175: PUSH
94176: LD_INT 3
94178: PUSH
94179: EMPTY
94180: LIST
94181: LIST
94182: PUSH
94183: EMPTY
94184: LIST
94185: LIST
94186: PPUSH
94187: CALL_OW 69
94191: ST_TO_ADDR
// if not tmp then
94192: LD_VAR 0 2
94196: NOT
94197: IFFALSE 94201
// exit ;
94199: GO 94230
// for i in tmp do
94201: LD_ADDR_VAR 0 1
94205: PUSH
94206: LD_VAR 0 2
94210: PUSH
94211: FOR_IN
94212: IFFALSE 94228
// SetBLevel ( i , 10 ) ;
94214: LD_VAR 0 1
94218: PPUSH
94219: LD_INT 10
94221: PPUSH
94222: CALL_OW 241
94226: GO 94211
94228: POP
94229: POP
// end ;
94230: PPOPN 2
94232: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
94233: LD_EXP 122
94237: PUSH
94238: LD_EXP 139
94242: AND
94243: IFFALSE 94354
94245: GO 94247
94247: DISABLE
94248: LD_INT 0
94250: PPUSH
94251: PPUSH
94252: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94253: LD_ADDR_VAR 0 3
94257: PUSH
94258: LD_INT 22
94260: PUSH
94261: LD_OWVAR 2
94265: PUSH
94266: EMPTY
94267: LIST
94268: LIST
94269: PUSH
94270: LD_INT 25
94272: PUSH
94273: LD_INT 1
94275: PUSH
94276: EMPTY
94277: LIST
94278: LIST
94279: PUSH
94280: EMPTY
94281: LIST
94282: LIST
94283: PPUSH
94284: CALL_OW 69
94288: ST_TO_ADDR
// if not tmp then
94289: LD_VAR 0 3
94293: NOT
94294: IFFALSE 94298
// exit ;
94296: GO 94354
// un := tmp [ rand ( 1 , tmp ) ] ;
94298: LD_ADDR_VAR 0 2
94302: PUSH
94303: LD_VAR 0 3
94307: PUSH
94308: LD_INT 1
94310: PPUSH
94311: LD_VAR 0 3
94315: PPUSH
94316: CALL_OW 12
94320: ARRAY
94321: ST_TO_ADDR
// if Crawls ( un ) then
94322: LD_VAR 0 2
94326: PPUSH
94327: CALL_OW 318
94331: IFFALSE 94342
// ComWalk ( un ) ;
94333: LD_VAR 0 2
94337: PPUSH
94338: CALL_OW 138
// SetClass ( un , class_sniper ) ;
94342: LD_VAR 0 2
94346: PPUSH
94347: LD_INT 5
94349: PPUSH
94350: CALL_OW 336
// end ;
94354: PPOPN 3
94356: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
94357: LD_EXP 122
94361: PUSH
94362: LD_EXP 140
94366: AND
94367: PUSH
94368: LD_OWVAR 67
94372: PUSH
94373: LD_INT 4
94375: LESS
94376: AND
94377: IFFALSE 94396
94379: GO 94381
94381: DISABLE
// begin Difficulty := Difficulty + 1 ;
94382: LD_ADDR_OWVAR 67
94386: PUSH
94387: LD_OWVAR 67
94391: PUSH
94392: LD_INT 1
94394: PLUS
94395: ST_TO_ADDR
// end ;
94396: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94397: LD_EXP 122
94401: PUSH
94402: LD_EXP 141
94406: AND
94407: IFFALSE 94510
94409: GO 94411
94411: DISABLE
94412: LD_INT 0
94414: PPUSH
// begin for i := 1 to 5 do
94415: LD_ADDR_VAR 0 1
94419: PUSH
94420: DOUBLE
94421: LD_INT 1
94423: DEC
94424: ST_TO_ADDR
94425: LD_INT 5
94427: PUSH
94428: FOR_TO
94429: IFFALSE 94508
// begin uc_nation := nation_nature ;
94431: LD_ADDR_OWVAR 21
94435: PUSH
94436: LD_INT 0
94438: ST_TO_ADDR
// uc_side := 0 ;
94439: LD_ADDR_OWVAR 20
94443: PUSH
94444: LD_INT 0
94446: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94447: LD_ADDR_OWVAR 29
94451: PUSH
94452: LD_INT 12
94454: PUSH
94455: LD_INT 12
94457: PUSH
94458: EMPTY
94459: LIST
94460: LIST
94461: ST_TO_ADDR
// hc_agressivity := 20 ;
94462: LD_ADDR_OWVAR 35
94466: PUSH
94467: LD_INT 20
94469: ST_TO_ADDR
// hc_class := class_tiger ;
94470: LD_ADDR_OWVAR 28
94474: PUSH
94475: LD_INT 14
94477: ST_TO_ADDR
// hc_gallery :=  ;
94478: LD_ADDR_OWVAR 33
94482: PUSH
94483: LD_STRING 
94485: ST_TO_ADDR
// hc_name :=  ;
94486: LD_ADDR_OWVAR 26
94490: PUSH
94491: LD_STRING 
94493: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94494: CALL_OW 44
94498: PPUSH
94499: LD_INT 0
94501: PPUSH
94502: CALL_OW 51
// end ;
94506: GO 94428
94508: POP
94509: POP
// end ;
94510: PPOPN 1
94512: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94513: LD_EXP 122
94517: PUSH
94518: LD_EXP 142
94522: AND
94523: IFFALSE 94532
94525: GO 94527
94527: DISABLE
// StreamSibBomb ;
94528: CALL 94533 0 0
94532: END
// export function StreamSibBomb ; var i , x , y ; begin
94533: LD_INT 0
94535: PPUSH
94536: PPUSH
94537: PPUSH
94538: PPUSH
// result := false ;
94539: LD_ADDR_VAR 0 1
94543: PUSH
94544: LD_INT 0
94546: ST_TO_ADDR
// for i := 1 to 16 do
94547: LD_ADDR_VAR 0 2
94551: PUSH
94552: DOUBLE
94553: LD_INT 1
94555: DEC
94556: ST_TO_ADDR
94557: LD_INT 16
94559: PUSH
94560: FOR_TO
94561: IFFALSE 94760
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94563: LD_ADDR_VAR 0 3
94567: PUSH
94568: LD_INT 10
94570: PUSH
94571: LD_INT 20
94573: PUSH
94574: LD_INT 30
94576: PUSH
94577: LD_INT 40
94579: PUSH
94580: LD_INT 50
94582: PUSH
94583: LD_INT 60
94585: PUSH
94586: LD_INT 70
94588: PUSH
94589: LD_INT 80
94591: PUSH
94592: LD_INT 90
94594: PUSH
94595: LD_INT 100
94597: PUSH
94598: LD_INT 110
94600: PUSH
94601: LD_INT 120
94603: PUSH
94604: LD_INT 130
94606: PUSH
94607: LD_INT 140
94609: PUSH
94610: LD_INT 150
94612: PUSH
94613: EMPTY
94614: LIST
94615: LIST
94616: LIST
94617: LIST
94618: LIST
94619: LIST
94620: LIST
94621: LIST
94622: LIST
94623: LIST
94624: LIST
94625: LIST
94626: LIST
94627: LIST
94628: LIST
94629: PUSH
94630: LD_INT 1
94632: PPUSH
94633: LD_INT 15
94635: PPUSH
94636: CALL_OW 12
94640: ARRAY
94641: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94642: LD_ADDR_VAR 0 4
94646: PUSH
94647: LD_INT 10
94649: PUSH
94650: LD_INT 20
94652: PUSH
94653: LD_INT 30
94655: PUSH
94656: LD_INT 40
94658: PUSH
94659: LD_INT 50
94661: PUSH
94662: LD_INT 60
94664: PUSH
94665: LD_INT 70
94667: PUSH
94668: LD_INT 80
94670: PUSH
94671: LD_INT 90
94673: PUSH
94674: LD_INT 100
94676: PUSH
94677: LD_INT 110
94679: PUSH
94680: LD_INT 120
94682: PUSH
94683: LD_INT 130
94685: PUSH
94686: LD_INT 140
94688: PUSH
94689: LD_INT 150
94691: PUSH
94692: EMPTY
94693: LIST
94694: LIST
94695: LIST
94696: LIST
94697: LIST
94698: LIST
94699: LIST
94700: LIST
94701: LIST
94702: LIST
94703: LIST
94704: LIST
94705: LIST
94706: LIST
94707: LIST
94708: PUSH
94709: LD_INT 1
94711: PPUSH
94712: LD_INT 15
94714: PPUSH
94715: CALL_OW 12
94719: ARRAY
94720: ST_TO_ADDR
// if ValidHex ( x , y ) then
94721: LD_VAR 0 3
94725: PPUSH
94726: LD_VAR 0 4
94730: PPUSH
94731: CALL_OW 488
94735: IFFALSE 94758
// begin result := [ x , y ] ;
94737: LD_ADDR_VAR 0 1
94741: PUSH
94742: LD_VAR 0 3
94746: PUSH
94747: LD_VAR 0 4
94751: PUSH
94752: EMPTY
94753: LIST
94754: LIST
94755: ST_TO_ADDR
// break ;
94756: GO 94760
// end ; end ;
94758: GO 94560
94760: POP
94761: POP
// if result then
94762: LD_VAR 0 1
94766: IFFALSE 94826
// begin ToLua ( playSibBomb() ) ;
94768: LD_STRING playSibBomb()
94770: PPUSH
94771: CALL_OW 559
// wait ( 0 0$14 ) ;
94775: LD_INT 490
94777: PPUSH
94778: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94782: LD_VAR 0 1
94786: PUSH
94787: LD_INT 1
94789: ARRAY
94790: PPUSH
94791: LD_VAR 0 1
94795: PUSH
94796: LD_INT 2
94798: ARRAY
94799: PPUSH
94800: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94804: LD_VAR 0 1
94808: PUSH
94809: LD_INT 1
94811: ARRAY
94812: PPUSH
94813: LD_VAR 0 1
94817: PUSH
94818: LD_INT 2
94820: ARRAY
94821: PPUSH
94822: CALL_OW 429
// end ; end ;
94826: LD_VAR 0 1
94830: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94831: LD_EXP 122
94835: PUSH
94836: LD_EXP 144
94840: AND
94841: IFFALSE 94853
94843: GO 94845
94845: DISABLE
// YouLost (  ) ;
94846: LD_STRING 
94848: PPUSH
94849: CALL_OW 104
94853: END
// every 0 0$1 trigger StreamModeActive and sFog do
94854: LD_EXP 122
94858: PUSH
94859: LD_EXP 143
94863: AND
94864: IFFALSE 94878
94866: GO 94868
94868: DISABLE
// FogOff ( your_side ) ;
94869: LD_OWVAR 2
94873: PPUSH
94874: CALL_OW 344
94878: END
// every 0 0$1 trigger StreamModeActive and sSun do
94879: LD_EXP 122
94883: PUSH
94884: LD_EXP 145
94888: AND
94889: IFFALSE 94917
94891: GO 94893
94893: DISABLE
// begin solar_recharge_percent := 0 ;
94894: LD_ADDR_OWVAR 79
94898: PUSH
94899: LD_INT 0
94901: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94902: LD_INT 10500
94904: PPUSH
94905: CALL_OW 67
// solar_recharge_percent := 100 ;
94909: LD_ADDR_OWVAR 79
94913: PUSH
94914: LD_INT 100
94916: ST_TO_ADDR
// end ;
94917: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94918: LD_EXP 122
94922: PUSH
94923: LD_EXP 146
94927: AND
94928: IFFALSE 95167
94930: GO 94932
94932: DISABLE
94933: LD_INT 0
94935: PPUSH
94936: PPUSH
94937: PPUSH
// begin tmp := [ ] ;
94938: LD_ADDR_VAR 0 3
94942: PUSH
94943: EMPTY
94944: ST_TO_ADDR
// for i := 1 to 6 do
94945: LD_ADDR_VAR 0 1
94949: PUSH
94950: DOUBLE
94951: LD_INT 1
94953: DEC
94954: ST_TO_ADDR
94955: LD_INT 6
94957: PUSH
94958: FOR_TO
94959: IFFALSE 95064
// begin uc_nation := nation_nature ;
94961: LD_ADDR_OWVAR 21
94965: PUSH
94966: LD_INT 0
94968: ST_TO_ADDR
// uc_side := 0 ;
94969: LD_ADDR_OWVAR 20
94973: PUSH
94974: LD_INT 0
94976: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94977: LD_ADDR_OWVAR 29
94981: PUSH
94982: LD_INT 12
94984: PUSH
94985: LD_INT 12
94987: PUSH
94988: EMPTY
94989: LIST
94990: LIST
94991: ST_TO_ADDR
// hc_agressivity := 20 ;
94992: LD_ADDR_OWVAR 35
94996: PUSH
94997: LD_INT 20
94999: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
95000: LD_ADDR_OWVAR 28
95004: PUSH
95005: LD_INT 17
95007: ST_TO_ADDR
// hc_gallery :=  ;
95008: LD_ADDR_OWVAR 33
95012: PUSH
95013: LD_STRING 
95015: ST_TO_ADDR
// hc_name :=  ;
95016: LD_ADDR_OWVAR 26
95020: PUSH
95021: LD_STRING 
95023: ST_TO_ADDR
// un := CreateHuman ;
95024: LD_ADDR_VAR 0 2
95028: PUSH
95029: CALL_OW 44
95033: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
95034: LD_VAR 0 2
95038: PPUSH
95039: LD_INT 1
95041: PPUSH
95042: CALL_OW 51
// tmp := tmp ^ un ;
95046: LD_ADDR_VAR 0 3
95050: PUSH
95051: LD_VAR 0 3
95055: PUSH
95056: LD_VAR 0 2
95060: ADD
95061: ST_TO_ADDR
// end ;
95062: GO 94958
95064: POP
95065: POP
// repeat wait ( 0 0$1 ) ;
95066: LD_INT 35
95068: PPUSH
95069: CALL_OW 67
// for un in tmp do
95073: LD_ADDR_VAR 0 2
95077: PUSH
95078: LD_VAR 0 3
95082: PUSH
95083: FOR_IN
95084: IFFALSE 95158
// begin if IsDead ( un ) then
95086: LD_VAR 0 2
95090: PPUSH
95091: CALL_OW 301
95095: IFFALSE 95115
// begin tmp := tmp diff un ;
95097: LD_ADDR_VAR 0 3
95101: PUSH
95102: LD_VAR 0 3
95106: PUSH
95107: LD_VAR 0 2
95111: DIFF
95112: ST_TO_ADDR
// continue ;
95113: GO 95083
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
95115: LD_VAR 0 2
95119: PPUSH
95120: LD_INT 3
95122: PUSH
95123: LD_INT 22
95125: PUSH
95126: LD_INT 0
95128: PUSH
95129: EMPTY
95130: LIST
95131: LIST
95132: PUSH
95133: EMPTY
95134: LIST
95135: LIST
95136: PPUSH
95137: CALL_OW 69
95141: PPUSH
95142: LD_VAR 0 2
95146: PPUSH
95147: CALL_OW 74
95151: PPUSH
95152: CALL_OW 115
// end ;
95156: GO 95083
95158: POP
95159: POP
// until not tmp ;
95160: LD_VAR 0 3
95164: NOT
95165: IFFALSE 95066
// end ;
95167: PPOPN 3
95169: END
// every 0 0$1 trigger StreamModeActive and sTroll do
95170: LD_EXP 122
95174: PUSH
95175: LD_EXP 147
95179: AND
95180: IFFALSE 95234
95182: GO 95184
95184: DISABLE
// begin ToLua ( displayTroll(); ) ;
95185: LD_STRING displayTroll();
95187: PPUSH
95188: CALL_OW 559
// wait ( 3 3$00 ) ;
95192: LD_INT 6300
95194: PPUSH
95195: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95199: LD_STRING hideTroll();
95201: PPUSH
95202: CALL_OW 559
// wait ( 1 1$00 ) ;
95206: LD_INT 2100
95208: PPUSH
95209: CALL_OW 67
// ToLua ( displayTroll(); ) ;
95213: LD_STRING displayTroll();
95215: PPUSH
95216: CALL_OW 559
// wait ( 1 1$00 ) ;
95220: LD_INT 2100
95222: PPUSH
95223: CALL_OW 67
// ToLua ( hideTroll(); ) ;
95227: LD_STRING hideTroll();
95229: PPUSH
95230: CALL_OW 559
// end ;
95234: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
95235: LD_EXP 122
95239: PUSH
95240: LD_EXP 148
95244: AND
95245: IFFALSE 95308
95247: GO 95249
95249: DISABLE
95250: LD_INT 0
95252: PPUSH
// begin p := 0 ;
95253: LD_ADDR_VAR 0 1
95257: PUSH
95258: LD_INT 0
95260: ST_TO_ADDR
// repeat game_speed := 1 ;
95261: LD_ADDR_OWVAR 65
95265: PUSH
95266: LD_INT 1
95268: ST_TO_ADDR
// wait ( 0 0$1 ) ;
95269: LD_INT 35
95271: PPUSH
95272: CALL_OW 67
// p := p + 1 ;
95276: LD_ADDR_VAR 0 1
95280: PUSH
95281: LD_VAR 0 1
95285: PUSH
95286: LD_INT 1
95288: PLUS
95289: ST_TO_ADDR
// until p >= 60 ;
95290: LD_VAR 0 1
95294: PUSH
95295: LD_INT 60
95297: GREATEREQUAL
95298: IFFALSE 95261
// game_speed := 4 ;
95300: LD_ADDR_OWVAR 65
95304: PUSH
95305: LD_INT 4
95307: ST_TO_ADDR
// end ;
95308: PPOPN 1
95310: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
95311: LD_EXP 122
95315: PUSH
95316: LD_EXP 149
95320: AND
95321: IFFALSE 95467
95323: GO 95325
95325: DISABLE
95326: LD_INT 0
95328: PPUSH
95329: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95330: LD_ADDR_VAR 0 1
95334: PUSH
95335: LD_INT 22
95337: PUSH
95338: LD_OWVAR 2
95342: PUSH
95343: EMPTY
95344: LIST
95345: LIST
95346: PUSH
95347: LD_INT 2
95349: PUSH
95350: LD_INT 30
95352: PUSH
95353: LD_INT 0
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PUSH
95360: LD_INT 30
95362: PUSH
95363: LD_INT 1
95365: PUSH
95366: EMPTY
95367: LIST
95368: LIST
95369: PUSH
95370: EMPTY
95371: LIST
95372: LIST
95373: LIST
95374: PUSH
95375: EMPTY
95376: LIST
95377: LIST
95378: PPUSH
95379: CALL_OW 69
95383: ST_TO_ADDR
// if not depot then
95384: LD_VAR 0 1
95388: NOT
95389: IFFALSE 95393
// exit ;
95391: GO 95467
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95393: LD_ADDR_VAR 0 2
95397: PUSH
95398: LD_VAR 0 1
95402: PUSH
95403: LD_INT 1
95405: PPUSH
95406: LD_VAR 0 1
95410: PPUSH
95411: CALL_OW 12
95415: ARRAY
95416: PPUSH
95417: CALL_OW 274
95421: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95422: LD_VAR 0 2
95426: PPUSH
95427: LD_INT 1
95429: PPUSH
95430: LD_INT 0
95432: PPUSH
95433: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95437: LD_VAR 0 2
95441: PPUSH
95442: LD_INT 2
95444: PPUSH
95445: LD_INT 0
95447: PPUSH
95448: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95452: LD_VAR 0 2
95456: PPUSH
95457: LD_INT 3
95459: PPUSH
95460: LD_INT 0
95462: PPUSH
95463: CALL_OW 277
// end ;
95467: PPOPN 2
95469: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95470: LD_EXP 122
95474: PUSH
95475: LD_EXP 150
95479: AND
95480: IFFALSE 95577
95482: GO 95484
95484: DISABLE
95485: LD_INT 0
95487: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95488: LD_ADDR_VAR 0 1
95492: PUSH
95493: LD_INT 22
95495: PUSH
95496: LD_OWVAR 2
95500: PUSH
95501: EMPTY
95502: LIST
95503: LIST
95504: PUSH
95505: LD_INT 21
95507: PUSH
95508: LD_INT 1
95510: PUSH
95511: EMPTY
95512: LIST
95513: LIST
95514: PUSH
95515: LD_INT 3
95517: PUSH
95518: LD_INT 23
95520: PUSH
95521: LD_INT 0
95523: PUSH
95524: EMPTY
95525: LIST
95526: LIST
95527: PUSH
95528: EMPTY
95529: LIST
95530: LIST
95531: PUSH
95532: EMPTY
95533: LIST
95534: LIST
95535: LIST
95536: PPUSH
95537: CALL_OW 69
95541: ST_TO_ADDR
// if not tmp then
95542: LD_VAR 0 1
95546: NOT
95547: IFFALSE 95551
// exit ;
95549: GO 95577
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95551: LD_VAR 0 1
95555: PUSH
95556: LD_INT 1
95558: PPUSH
95559: LD_VAR 0 1
95563: PPUSH
95564: CALL_OW 12
95568: ARRAY
95569: PPUSH
95570: LD_INT 200
95572: PPUSH
95573: CALL_OW 234
// end ;
95577: PPOPN 1
95579: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95580: LD_EXP 122
95584: PUSH
95585: LD_EXP 151
95589: AND
95590: IFFALSE 95669
95592: GO 95594
95594: DISABLE
95595: LD_INT 0
95597: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95598: LD_ADDR_VAR 0 1
95602: PUSH
95603: LD_INT 22
95605: PUSH
95606: LD_OWVAR 2
95610: PUSH
95611: EMPTY
95612: LIST
95613: LIST
95614: PUSH
95615: LD_INT 21
95617: PUSH
95618: LD_INT 2
95620: PUSH
95621: EMPTY
95622: LIST
95623: LIST
95624: PUSH
95625: EMPTY
95626: LIST
95627: LIST
95628: PPUSH
95629: CALL_OW 69
95633: ST_TO_ADDR
// if not tmp then
95634: LD_VAR 0 1
95638: NOT
95639: IFFALSE 95643
// exit ;
95641: GO 95669
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95643: LD_VAR 0 1
95647: PUSH
95648: LD_INT 1
95650: PPUSH
95651: LD_VAR 0 1
95655: PPUSH
95656: CALL_OW 12
95660: ARRAY
95661: PPUSH
95662: LD_INT 60
95664: PPUSH
95665: CALL_OW 234
// end ;
95669: PPOPN 1
95671: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95672: LD_EXP 122
95676: PUSH
95677: LD_EXP 152
95681: AND
95682: IFFALSE 95781
95684: GO 95686
95686: DISABLE
95687: LD_INT 0
95689: PPUSH
95690: PPUSH
// begin enable ;
95691: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95692: LD_ADDR_VAR 0 1
95696: PUSH
95697: LD_INT 22
95699: PUSH
95700: LD_OWVAR 2
95704: PUSH
95705: EMPTY
95706: LIST
95707: LIST
95708: PUSH
95709: LD_INT 61
95711: PUSH
95712: EMPTY
95713: LIST
95714: PUSH
95715: LD_INT 33
95717: PUSH
95718: LD_INT 2
95720: PUSH
95721: EMPTY
95722: LIST
95723: LIST
95724: PUSH
95725: EMPTY
95726: LIST
95727: LIST
95728: LIST
95729: PPUSH
95730: CALL_OW 69
95734: ST_TO_ADDR
// if not tmp then
95735: LD_VAR 0 1
95739: NOT
95740: IFFALSE 95744
// exit ;
95742: GO 95781
// for i in tmp do
95744: LD_ADDR_VAR 0 2
95748: PUSH
95749: LD_VAR 0 1
95753: PUSH
95754: FOR_IN
95755: IFFALSE 95779
// if IsControledBy ( i ) then
95757: LD_VAR 0 2
95761: PPUSH
95762: CALL_OW 312
95766: IFFALSE 95777
// ComUnlink ( i ) ;
95768: LD_VAR 0 2
95772: PPUSH
95773: CALL_OW 136
95777: GO 95754
95779: POP
95780: POP
// end ;
95781: PPOPN 2
95783: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95784: LD_EXP 122
95788: PUSH
95789: LD_EXP 153
95793: AND
95794: IFFALSE 95934
95796: GO 95798
95798: DISABLE
95799: LD_INT 0
95801: PPUSH
95802: PPUSH
// begin ToLua ( displayPowell(); ) ;
95803: LD_STRING displayPowell();
95805: PPUSH
95806: CALL_OW 559
// uc_side := 0 ;
95810: LD_ADDR_OWVAR 20
95814: PUSH
95815: LD_INT 0
95817: ST_TO_ADDR
// uc_nation := 2 ;
95818: LD_ADDR_OWVAR 21
95822: PUSH
95823: LD_INT 2
95825: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95826: LD_ADDR_OWVAR 37
95830: PUSH
95831: LD_INT 14
95833: ST_TO_ADDR
// vc_engine := engine_siberite ;
95834: LD_ADDR_OWVAR 39
95838: PUSH
95839: LD_INT 3
95841: ST_TO_ADDR
// vc_control := control_apeman ;
95842: LD_ADDR_OWVAR 38
95846: PUSH
95847: LD_INT 5
95849: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95850: LD_ADDR_OWVAR 40
95854: PUSH
95855: LD_INT 29
95857: ST_TO_ADDR
// un := CreateVehicle ;
95858: LD_ADDR_VAR 0 2
95862: PUSH
95863: CALL_OW 45
95867: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95868: LD_VAR 0 2
95872: PPUSH
95873: LD_INT 1
95875: PPUSH
95876: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95880: LD_INT 35
95882: PPUSH
95883: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95887: LD_VAR 0 2
95891: PPUSH
95892: LD_INT 22
95894: PUSH
95895: LD_OWVAR 2
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: PPUSH
95904: CALL_OW 69
95908: PPUSH
95909: LD_VAR 0 2
95913: PPUSH
95914: CALL_OW 74
95918: PPUSH
95919: CALL_OW 115
// until IsDead ( un ) ;
95923: LD_VAR 0 2
95927: PPUSH
95928: CALL_OW 301
95932: IFFALSE 95880
// end ;
95934: PPOPN 2
95936: END
// every 0 0$1 trigger StreamModeActive and sStu do
95937: LD_EXP 122
95941: PUSH
95942: LD_EXP 161
95946: AND
95947: IFFALSE 95963
95949: GO 95951
95951: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95952: LD_STRING displayStucuk();
95954: PPUSH
95955: CALL_OW 559
// ResetFog ;
95959: CALL_OW 335
// end ;
95963: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95964: LD_EXP 122
95968: PUSH
95969: LD_EXP 154
95973: AND
95974: IFFALSE 96115
95976: GO 95978
95978: DISABLE
95979: LD_INT 0
95981: PPUSH
95982: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95983: LD_ADDR_VAR 0 2
95987: PUSH
95988: LD_INT 22
95990: PUSH
95991: LD_OWVAR 2
95995: PUSH
95996: EMPTY
95997: LIST
95998: LIST
95999: PUSH
96000: LD_INT 21
96002: PUSH
96003: LD_INT 1
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: PUSH
96010: EMPTY
96011: LIST
96012: LIST
96013: PPUSH
96014: CALL_OW 69
96018: ST_TO_ADDR
// if not tmp then
96019: LD_VAR 0 2
96023: NOT
96024: IFFALSE 96028
// exit ;
96026: GO 96115
// un := tmp [ rand ( 1 , tmp ) ] ;
96028: LD_ADDR_VAR 0 1
96032: PUSH
96033: LD_VAR 0 2
96037: PUSH
96038: LD_INT 1
96040: PPUSH
96041: LD_VAR 0 2
96045: PPUSH
96046: CALL_OW 12
96050: ARRAY
96051: ST_TO_ADDR
// SetSide ( un , 0 ) ;
96052: LD_VAR 0 1
96056: PPUSH
96057: LD_INT 0
96059: PPUSH
96060: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
96064: LD_VAR 0 1
96068: PPUSH
96069: LD_OWVAR 3
96073: PUSH
96074: LD_VAR 0 1
96078: DIFF
96079: PPUSH
96080: LD_VAR 0 1
96084: PPUSH
96085: CALL_OW 74
96089: PPUSH
96090: CALL_OW 115
// wait ( 0 0$20 ) ;
96094: LD_INT 700
96096: PPUSH
96097: CALL_OW 67
// SetSide ( un , your_side ) ;
96101: LD_VAR 0 1
96105: PPUSH
96106: LD_OWVAR 2
96110: PPUSH
96111: CALL_OW 235
// end ;
96115: PPOPN 2
96117: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
96118: LD_EXP 122
96122: PUSH
96123: LD_EXP 155
96127: AND
96128: IFFALSE 96234
96130: GO 96132
96132: DISABLE
96133: LD_INT 0
96135: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96136: LD_ADDR_VAR 0 1
96140: PUSH
96141: LD_INT 22
96143: PUSH
96144: LD_OWVAR 2
96148: PUSH
96149: EMPTY
96150: LIST
96151: LIST
96152: PUSH
96153: LD_INT 2
96155: PUSH
96156: LD_INT 30
96158: PUSH
96159: LD_INT 0
96161: PUSH
96162: EMPTY
96163: LIST
96164: LIST
96165: PUSH
96166: LD_INT 30
96168: PUSH
96169: LD_INT 1
96171: PUSH
96172: EMPTY
96173: LIST
96174: LIST
96175: PUSH
96176: EMPTY
96177: LIST
96178: LIST
96179: LIST
96180: PUSH
96181: EMPTY
96182: LIST
96183: LIST
96184: PPUSH
96185: CALL_OW 69
96189: ST_TO_ADDR
// if not depot then
96190: LD_VAR 0 1
96194: NOT
96195: IFFALSE 96199
// exit ;
96197: GO 96234
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
96199: LD_VAR 0 1
96203: PUSH
96204: LD_INT 1
96206: ARRAY
96207: PPUSH
96208: CALL_OW 250
96212: PPUSH
96213: LD_VAR 0 1
96217: PUSH
96218: LD_INT 1
96220: ARRAY
96221: PPUSH
96222: CALL_OW 251
96226: PPUSH
96227: LD_INT 70
96229: PPUSH
96230: CALL_OW 495
// end ;
96234: PPOPN 1
96236: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
96237: LD_EXP 122
96241: PUSH
96242: LD_EXP 156
96246: AND
96247: IFFALSE 96458
96249: GO 96251
96251: DISABLE
96252: LD_INT 0
96254: PPUSH
96255: PPUSH
96256: PPUSH
96257: PPUSH
96258: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96259: LD_ADDR_VAR 0 5
96263: PUSH
96264: LD_INT 22
96266: PUSH
96267: LD_OWVAR 2
96271: PUSH
96272: EMPTY
96273: LIST
96274: LIST
96275: PUSH
96276: LD_INT 21
96278: PUSH
96279: LD_INT 1
96281: PUSH
96282: EMPTY
96283: LIST
96284: LIST
96285: PUSH
96286: EMPTY
96287: LIST
96288: LIST
96289: PPUSH
96290: CALL_OW 69
96294: ST_TO_ADDR
// if not tmp then
96295: LD_VAR 0 5
96299: NOT
96300: IFFALSE 96304
// exit ;
96302: GO 96458
// for i in tmp do
96304: LD_ADDR_VAR 0 1
96308: PUSH
96309: LD_VAR 0 5
96313: PUSH
96314: FOR_IN
96315: IFFALSE 96456
// begin d := rand ( 0 , 5 ) ;
96317: LD_ADDR_VAR 0 4
96321: PUSH
96322: LD_INT 0
96324: PPUSH
96325: LD_INT 5
96327: PPUSH
96328: CALL_OW 12
96332: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
96333: LD_ADDR_VAR 0 2
96337: PUSH
96338: LD_VAR 0 1
96342: PPUSH
96343: CALL_OW 250
96347: PPUSH
96348: LD_VAR 0 4
96352: PPUSH
96353: LD_INT 3
96355: PPUSH
96356: LD_INT 12
96358: PPUSH
96359: CALL_OW 12
96363: PPUSH
96364: CALL_OW 272
96368: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96369: LD_ADDR_VAR 0 3
96373: PUSH
96374: LD_VAR 0 1
96378: PPUSH
96379: CALL_OW 251
96383: PPUSH
96384: LD_VAR 0 4
96388: PPUSH
96389: LD_INT 3
96391: PPUSH
96392: LD_INT 12
96394: PPUSH
96395: CALL_OW 12
96399: PPUSH
96400: CALL_OW 273
96404: ST_TO_ADDR
// if ValidHex ( x , y ) then
96405: LD_VAR 0 2
96409: PPUSH
96410: LD_VAR 0 3
96414: PPUSH
96415: CALL_OW 488
96419: IFFALSE 96454
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96421: LD_VAR 0 1
96425: PPUSH
96426: LD_VAR 0 2
96430: PPUSH
96431: LD_VAR 0 3
96435: PPUSH
96436: LD_INT 3
96438: PPUSH
96439: LD_INT 6
96441: PPUSH
96442: CALL_OW 12
96446: PPUSH
96447: LD_INT 1
96449: PPUSH
96450: CALL_OW 483
// end ;
96454: GO 96314
96456: POP
96457: POP
// end ;
96458: PPOPN 5
96460: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96461: LD_EXP 122
96465: PUSH
96466: LD_EXP 157
96470: AND
96471: IFFALSE 96565
96473: GO 96475
96475: DISABLE
96476: LD_INT 0
96478: PPUSH
96479: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96480: LD_ADDR_VAR 0 2
96484: PUSH
96485: LD_INT 22
96487: PUSH
96488: LD_OWVAR 2
96492: PUSH
96493: EMPTY
96494: LIST
96495: LIST
96496: PUSH
96497: LD_INT 32
96499: PUSH
96500: LD_INT 1
96502: PUSH
96503: EMPTY
96504: LIST
96505: LIST
96506: PUSH
96507: LD_INT 21
96509: PUSH
96510: LD_INT 2
96512: PUSH
96513: EMPTY
96514: LIST
96515: LIST
96516: PUSH
96517: EMPTY
96518: LIST
96519: LIST
96520: LIST
96521: PPUSH
96522: CALL_OW 69
96526: ST_TO_ADDR
// if not tmp then
96527: LD_VAR 0 2
96531: NOT
96532: IFFALSE 96536
// exit ;
96534: GO 96565
// for i in tmp do
96536: LD_ADDR_VAR 0 1
96540: PUSH
96541: LD_VAR 0 2
96545: PUSH
96546: FOR_IN
96547: IFFALSE 96563
// SetFuel ( i , 0 ) ;
96549: LD_VAR 0 1
96553: PPUSH
96554: LD_INT 0
96556: PPUSH
96557: CALL_OW 240
96561: GO 96546
96563: POP
96564: POP
// end ;
96565: PPOPN 2
96567: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96568: LD_EXP 122
96572: PUSH
96573: LD_EXP 158
96577: AND
96578: IFFALSE 96644
96580: GO 96582
96582: DISABLE
96583: LD_INT 0
96585: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96586: LD_ADDR_VAR 0 1
96590: PUSH
96591: LD_INT 22
96593: PUSH
96594: LD_OWVAR 2
96598: PUSH
96599: EMPTY
96600: LIST
96601: LIST
96602: PUSH
96603: LD_INT 30
96605: PUSH
96606: LD_INT 29
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: PUSH
96613: EMPTY
96614: LIST
96615: LIST
96616: PPUSH
96617: CALL_OW 69
96621: ST_TO_ADDR
// if not tmp then
96622: LD_VAR 0 1
96626: NOT
96627: IFFALSE 96631
// exit ;
96629: GO 96644
// DestroyUnit ( tmp [ 1 ] ) ;
96631: LD_VAR 0 1
96635: PUSH
96636: LD_INT 1
96638: ARRAY
96639: PPUSH
96640: CALL_OW 65
// end ;
96644: PPOPN 1
96646: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96647: LD_EXP 122
96651: PUSH
96652: LD_EXP 160
96656: AND
96657: IFFALSE 96786
96659: GO 96661
96661: DISABLE
96662: LD_INT 0
96664: PPUSH
// begin uc_side := 0 ;
96665: LD_ADDR_OWVAR 20
96669: PUSH
96670: LD_INT 0
96672: ST_TO_ADDR
// uc_nation := nation_arabian ;
96673: LD_ADDR_OWVAR 21
96677: PUSH
96678: LD_INT 2
96680: ST_TO_ADDR
// hc_gallery :=  ;
96681: LD_ADDR_OWVAR 33
96685: PUSH
96686: LD_STRING 
96688: ST_TO_ADDR
// hc_name :=  ;
96689: LD_ADDR_OWVAR 26
96693: PUSH
96694: LD_STRING 
96696: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96697: LD_INT 1
96699: PPUSH
96700: LD_INT 11
96702: PPUSH
96703: LD_INT 10
96705: PPUSH
96706: CALL_OW 380
// un := CreateHuman ;
96710: LD_ADDR_VAR 0 1
96714: PUSH
96715: CALL_OW 44
96719: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96720: LD_VAR 0 1
96724: PPUSH
96725: LD_INT 1
96727: PPUSH
96728: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96732: LD_INT 35
96734: PPUSH
96735: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96739: LD_VAR 0 1
96743: PPUSH
96744: LD_INT 22
96746: PUSH
96747: LD_OWVAR 2
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PPUSH
96756: CALL_OW 69
96760: PPUSH
96761: LD_VAR 0 1
96765: PPUSH
96766: CALL_OW 74
96770: PPUSH
96771: CALL_OW 115
// until IsDead ( un ) ;
96775: LD_VAR 0 1
96779: PPUSH
96780: CALL_OW 301
96784: IFFALSE 96732
// end ;
96786: PPOPN 1
96788: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96789: LD_EXP 122
96793: PUSH
96794: LD_EXP 162
96798: AND
96799: IFFALSE 96811
96801: GO 96803
96803: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96804: LD_STRING earthquake(getX(game), 0, 32)
96806: PPUSH
96807: CALL_OW 559
96811: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96812: LD_EXP 122
96816: PUSH
96817: LD_EXP 163
96821: AND
96822: IFFALSE 96913
96824: GO 96826
96826: DISABLE
96827: LD_INT 0
96829: PPUSH
// begin enable ;
96830: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96831: LD_ADDR_VAR 0 1
96835: PUSH
96836: LD_INT 22
96838: PUSH
96839: LD_OWVAR 2
96843: PUSH
96844: EMPTY
96845: LIST
96846: LIST
96847: PUSH
96848: LD_INT 21
96850: PUSH
96851: LD_INT 2
96853: PUSH
96854: EMPTY
96855: LIST
96856: LIST
96857: PUSH
96858: LD_INT 33
96860: PUSH
96861: LD_INT 3
96863: PUSH
96864: EMPTY
96865: LIST
96866: LIST
96867: PUSH
96868: EMPTY
96869: LIST
96870: LIST
96871: LIST
96872: PPUSH
96873: CALL_OW 69
96877: ST_TO_ADDR
// if not tmp then
96878: LD_VAR 0 1
96882: NOT
96883: IFFALSE 96887
// exit ;
96885: GO 96913
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96887: LD_VAR 0 1
96891: PUSH
96892: LD_INT 1
96894: PPUSH
96895: LD_VAR 0 1
96899: PPUSH
96900: CALL_OW 12
96904: ARRAY
96905: PPUSH
96906: LD_INT 1
96908: PPUSH
96909: CALL_OW 234
// end ;
96913: PPOPN 1
96915: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96916: LD_EXP 122
96920: PUSH
96921: LD_EXP 164
96925: AND
96926: IFFALSE 97067
96928: GO 96930
96930: DISABLE
96931: LD_INT 0
96933: PPUSH
96934: PPUSH
96935: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96936: LD_ADDR_VAR 0 3
96940: PUSH
96941: LD_INT 22
96943: PUSH
96944: LD_OWVAR 2
96948: PUSH
96949: EMPTY
96950: LIST
96951: LIST
96952: PUSH
96953: LD_INT 25
96955: PUSH
96956: LD_INT 1
96958: PUSH
96959: EMPTY
96960: LIST
96961: LIST
96962: PUSH
96963: EMPTY
96964: LIST
96965: LIST
96966: PPUSH
96967: CALL_OW 69
96971: ST_TO_ADDR
// if not tmp then
96972: LD_VAR 0 3
96976: NOT
96977: IFFALSE 96981
// exit ;
96979: GO 97067
// un := tmp [ rand ( 1 , tmp ) ] ;
96981: LD_ADDR_VAR 0 2
96985: PUSH
96986: LD_VAR 0 3
96990: PUSH
96991: LD_INT 1
96993: PPUSH
96994: LD_VAR 0 3
96998: PPUSH
96999: CALL_OW 12
97003: ARRAY
97004: ST_TO_ADDR
// if Crawls ( un ) then
97005: LD_VAR 0 2
97009: PPUSH
97010: CALL_OW 318
97014: IFFALSE 97025
// ComWalk ( un ) ;
97016: LD_VAR 0 2
97020: PPUSH
97021: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
97025: LD_VAR 0 2
97029: PPUSH
97030: LD_INT 9
97032: PPUSH
97033: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
97037: LD_INT 28
97039: PPUSH
97040: LD_OWVAR 2
97044: PPUSH
97045: LD_INT 2
97047: PPUSH
97048: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
97052: LD_INT 29
97054: PPUSH
97055: LD_OWVAR 2
97059: PPUSH
97060: LD_INT 2
97062: PPUSH
97063: CALL_OW 322
// end ;
97067: PPOPN 3
97069: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
97070: LD_EXP 122
97074: PUSH
97075: LD_EXP 165
97079: AND
97080: IFFALSE 97191
97082: GO 97084
97084: DISABLE
97085: LD_INT 0
97087: PPUSH
97088: PPUSH
97089: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97090: LD_ADDR_VAR 0 3
97094: PUSH
97095: LD_INT 22
97097: PUSH
97098: LD_OWVAR 2
97102: PUSH
97103: EMPTY
97104: LIST
97105: LIST
97106: PUSH
97107: LD_INT 25
97109: PUSH
97110: LD_INT 1
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: PUSH
97117: EMPTY
97118: LIST
97119: LIST
97120: PPUSH
97121: CALL_OW 69
97125: ST_TO_ADDR
// if not tmp then
97126: LD_VAR 0 3
97130: NOT
97131: IFFALSE 97135
// exit ;
97133: GO 97191
// un := tmp [ rand ( 1 , tmp ) ] ;
97135: LD_ADDR_VAR 0 2
97139: PUSH
97140: LD_VAR 0 3
97144: PUSH
97145: LD_INT 1
97147: PPUSH
97148: LD_VAR 0 3
97152: PPUSH
97153: CALL_OW 12
97157: ARRAY
97158: ST_TO_ADDR
// if Crawls ( un ) then
97159: LD_VAR 0 2
97163: PPUSH
97164: CALL_OW 318
97168: IFFALSE 97179
// ComWalk ( un ) ;
97170: LD_VAR 0 2
97174: PPUSH
97175: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97179: LD_VAR 0 2
97183: PPUSH
97184: LD_INT 8
97186: PPUSH
97187: CALL_OW 336
// end ;
97191: PPOPN 3
97193: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
97194: LD_EXP 122
97198: PUSH
97199: LD_EXP 166
97203: AND
97204: IFFALSE 97348
97206: GO 97208
97208: DISABLE
97209: LD_INT 0
97211: PPUSH
97212: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
97213: LD_ADDR_VAR 0 2
97217: PUSH
97218: LD_INT 22
97220: PUSH
97221: LD_OWVAR 2
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 21
97232: PUSH
97233: LD_INT 2
97235: PUSH
97236: EMPTY
97237: LIST
97238: LIST
97239: PUSH
97240: LD_INT 2
97242: PUSH
97243: LD_INT 34
97245: PUSH
97246: LD_INT 12
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PUSH
97253: LD_INT 34
97255: PUSH
97256: LD_INT 51
97258: PUSH
97259: EMPTY
97260: LIST
97261: LIST
97262: PUSH
97263: LD_INT 34
97265: PUSH
97266: LD_INT 32
97268: PUSH
97269: EMPTY
97270: LIST
97271: LIST
97272: PUSH
97273: EMPTY
97274: LIST
97275: LIST
97276: LIST
97277: LIST
97278: PUSH
97279: EMPTY
97280: LIST
97281: LIST
97282: LIST
97283: PPUSH
97284: CALL_OW 69
97288: ST_TO_ADDR
// if not tmp then
97289: LD_VAR 0 2
97293: NOT
97294: IFFALSE 97298
// exit ;
97296: GO 97348
// for i in tmp do
97298: LD_ADDR_VAR 0 1
97302: PUSH
97303: LD_VAR 0 2
97307: PUSH
97308: FOR_IN
97309: IFFALSE 97346
// if GetCargo ( i , mat_artifact ) = 0 then
97311: LD_VAR 0 1
97315: PPUSH
97316: LD_INT 4
97318: PPUSH
97319: CALL_OW 289
97323: PUSH
97324: LD_INT 0
97326: EQUAL
97327: IFFALSE 97344
// SetCargo ( i , mat_siberit , 100 ) ;
97329: LD_VAR 0 1
97333: PPUSH
97334: LD_INT 3
97336: PPUSH
97337: LD_INT 100
97339: PPUSH
97340: CALL_OW 290
97344: GO 97308
97346: POP
97347: POP
// end ;
97348: PPOPN 2
97350: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
97351: LD_EXP 122
97355: PUSH
97356: LD_EXP 167
97360: AND
97361: IFFALSE 97544
97363: GO 97365
97365: DISABLE
97366: LD_INT 0
97368: PPUSH
97369: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97370: LD_ADDR_VAR 0 2
97374: PUSH
97375: LD_INT 22
97377: PUSH
97378: LD_OWVAR 2
97382: PUSH
97383: EMPTY
97384: LIST
97385: LIST
97386: PPUSH
97387: CALL_OW 69
97391: ST_TO_ADDR
// if not tmp then
97392: LD_VAR 0 2
97396: NOT
97397: IFFALSE 97401
// exit ;
97399: GO 97544
// for i := 1 to 2 do
97401: LD_ADDR_VAR 0 1
97405: PUSH
97406: DOUBLE
97407: LD_INT 1
97409: DEC
97410: ST_TO_ADDR
97411: LD_INT 2
97413: PUSH
97414: FOR_TO
97415: IFFALSE 97542
// begin uc_side := your_side ;
97417: LD_ADDR_OWVAR 20
97421: PUSH
97422: LD_OWVAR 2
97426: ST_TO_ADDR
// uc_nation := nation_american ;
97427: LD_ADDR_OWVAR 21
97431: PUSH
97432: LD_INT 1
97434: ST_TO_ADDR
// vc_chassis := us_morphling ;
97435: LD_ADDR_OWVAR 37
97439: PUSH
97440: LD_INT 5
97442: ST_TO_ADDR
// vc_engine := engine_siberite ;
97443: LD_ADDR_OWVAR 39
97447: PUSH
97448: LD_INT 3
97450: ST_TO_ADDR
// vc_control := control_computer ;
97451: LD_ADDR_OWVAR 38
97455: PUSH
97456: LD_INT 3
97458: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97459: LD_ADDR_OWVAR 40
97463: PUSH
97464: LD_INT 10
97466: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97467: LD_VAR 0 2
97471: PUSH
97472: LD_INT 1
97474: ARRAY
97475: PPUSH
97476: CALL_OW 310
97480: NOT
97481: IFFALSE 97528
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97483: CALL_OW 45
97487: PPUSH
97488: LD_VAR 0 2
97492: PUSH
97493: LD_INT 1
97495: ARRAY
97496: PPUSH
97497: CALL_OW 250
97501: PPUSH
97502: LD_VAR 0 2
97506: PUSH
97507: LD_INT 1
97509: ARRAY
97510: PPUSH
97511: CALL_OW 251
97515: PPUSH
97516: LD_INT 12
97518: PPUSH
97519: LD_INT 1
97521: PPUSH
97522: CALL_OW 50
97526: GO 97540
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97528: CALL_OW 45
97532: PPUSH
97533: LD_INT 1
97535: PPUSH
97536: CALL_OW 51
// end ;
97540: GO 97414
97542: POP
97543: POP
// end ;
97544: PPOPN 2
97546: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97547: LD_EXP 122
97551: PUSH
97552: LD_EXP 168
97556: AND
97557: IFFALSE 97779
97559: GO 97561
97561: DISABLE
97562: LD_INT 0
97564: PPUSH
97565: PPUSH
97566: PPUSH
97567: PPUSH
97568: PPUSH
97569: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97570: LD_ADDR_VAR 0 6
97574: PUSH
97575: LD_INT 22
97577: PUSH
97578: LD_OWVAR 2
97582: PUSH
97583: EMPTY
97584: LIST
97585: LIST
97586: PUSH
97587: LD_INT 21
97589: PUSH
97590: LD_INT 1
97592: PUSH
97593: EMPTY
97594: LIST
97595: LIST
97596: PUSH
97597: LD_INT 3
97599: PUSH
97600: LD_INT 23
97602: PUSH
97603: LD_INT 0
97605: PUSH
97606: EMPTY
97607: LIST
97608: LIST
97609: PUSH
97610: EMPTY
97611: LIST
97612: LIST
97613: PUSH
97614: EMPTY
97615: LIST
97616: LIST
97617: LIST
97618: PPUSH
97619: CALL_OW 69
97623: ST_TO_ADDR
// if not tmp then
97624: LD_VAR 0 6
97628: NOT
97629: IFFALSE 97633
// exit ;
97631: GO 97779
// s1 := rand ( 1 , 4 ) ;
97633: LD_ADDR_VAR 0 2
97637: PUSH
97638: LD_INT 1
97640: PPUSH
97641: LD_INT 4
97643: PPUSH
97644: CALL_OW 12
97648: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97649: LD_ADDR_VAR 0 4
97653: PUSH
97654: LD_VAR 0 6
97658: PUSH
97659: LD_INT 1
97661: ARRAY
97662: PPUSH
97663: LD_VAR 0 2
97667: PPUSH
97668: CALL_OW 259
97672: ST_TO_ADDR
// if s1 = 1 then
97673: LD_VAR 0 2
97677: PUSH
97678: LD_INT 1
97680: EQUAL
97681: IFFALSE 97701
// s2 := rand ( 2 , 4 ) else
97683: LD_ADDR_VAR 0 3
97687: PUSH
97688: LD_INT 2
97690: PPUSH
97691: LD_INT 4
97693: PPUSH
97694: CALL_OW 12
97698: ST_TO_ADDR
97699: GO 97709
// s2 := 1 ;
97701: LD_ADDR_VAR 0 3
97705: PUSH
97706: LD_INT 1
97708: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97709: LD_ADDR_VAR 0 5
97713: PUSH
97714: LD_VAR 0 6
97718: PUSH
97719: LD_INT 1
97721: ARRAY
97722: PPUSH
97723: LD_VAR 0 3
97727: PPUSH
97728: CALL_OW 259
97732: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97733: LD_VAR 0 6
97737: PUSH
97738: LD_INT 1
97740: ARRAY
97741: PPUSH
97742: LD_VAR 0 2
97746: PPUSH
97747: LD_VAR 0 5
97751: PPUSH
97752: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97756: LD_VAR 0 6
97760: PUSH
97761: LD_INT 1
97763: ARRAY
97764: PPUSH
97765: LD_VAR 0 3
97769: PPUSH
97770: LD_VAR 0 4
97774: PPUSH
97775: CALL_OW 237
// end ;
97779: PPOPN 6
97781: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97782: LD_EXP 122
97786: PUSH
97787: LD_EXP 169
97791: AND
97792: IFFALSE 97871
97794: GO 97796
97796: DISABLE
97797: LD_INT 0
97799: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97800: LD_ADDR_VAR 0 1
97804: PUSH
97805: LD_INT 22
97807: PUSH
97808: LD_OWVAR 2
97812: PUSH
97813: EMPTY
97814: LIST
97815: LIST
97816: PUSH
97817: LD_INT 30
97819: PUSH
97820: LD_INT 3
97822: PUSH
97823: EMPTY
97824: LIST
97825: LIST
97826: PUSH
97827: EMPTY
97828: LIST
97829: LIST
97830: PPUSH
97831: CALL_OW 69
97835: ST_TO_ADDR
// if not tmp then
97836: LD_VAR 0 1
97840: NOT
97841: IFFALSE 97845
// exit ;
97843: GO 97871
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97845: LD_VAR 0 1
97849: PUSH
97850: LD_INT 1
97852: PPUSH
97853: LD_VAR 0 1
97857: PPUSH
97858: CALL_OW 12
97862: ARRAY
97863: PPUSH
97864: LD_INT 1
97866: PPUSH
97867: CALL_OW 234
// end ;
97871: PPOPN 1
97873: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97874: LD_EXP 122
97878: PUSH
97879: LD_EXP 170
97883: AND
97884: IFFALSE 97996
97886: GO 97888
97888: DISABLE
97889: LD_INT 0
97891: PPUSH
97892: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97893: LD_ADDR_VAR 0 2
97897: PUSH
97898: LD_INT 22
97900: PUSH
97901: LD_OWVAR 2
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: PUSH
97910: LD_INT 2
97912: PUSH
97913: LD_INT 30
97915: PUSH
97916: LD_INT 27
97918: PUSH
97919: EMPTY
97920: LIST
97921: LIST
97922: PUSH
97923: LD_INT 30
97925: PUSH
97926: LD_INT 26
97928: PUSH
97929: EMPTY
97930: LIST
97931: LIST
97932: PUSH
97933: LD_INT 30
97935: PUSH
97936: LD_INT 28
97938: PUSH
97939: EMPTY
97940: LIST
97941: LIST
97942: PUSH
97943: EMPTY
97944: LIST
97945: LIST
97946: LIST
97947: LIST
97948: PUSH
97949: EMPTY
97950: LIST
97951: LIST
97952: PPUSH
97953: CALL_OW 69
97957: ST_TO_ADDR
// if not tmp then
97958: LD_VAR 0 2
97962: NOT
97963: IFFALSE 97967
// exit ;
97965: GO 97996
// for i in tmp do
97967: LD_ADDR_VAR 0 1
97971: PUSH
97972: LD_VAR 0 2
97976: PUSH
97977: FOR_IN
97978: IFFALSE 97994
// SetLives ( i , 1 ) ;
97980: LD_VAR 0 1
97984: PPUSH
97985: LD_INT 1
97987: PPUSH
97988: CALL_OW 234
97992: GO 97977
97994: POP
97995: POP
// end ;
97996: PPOPN 2
97998: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97999: LD_EXP 122
98003: PUSH
98004: LD_EXP 171
98008: AND
98009: IFFALSE 98296
98011: GO 98013
98013: DISABLE
98014: LD_INT 0
98016: PPUSH
98017: PPUSH
98018: PPUSH
// begin i := rand ( 1 , 7 ) ;
98019: LD_ADDR_VAR 0 1
98023: PUSH
98024: LD_INT 1
98026: PPUSH
98027: LD_INT 7
98029: PPUSH
98030: CALL_OW 12
98034: ST_TO_ADDR
// case i of 1 :
98035: LD_VAR 0 1
98039: PUSH
98040: LD_INT 1
98042: DOUBLE
98043: EQUAL
98044: IFTRUE 98048
98046: GO 98058
98048: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
98049: LD_STRING earthquake(getX(game), 0, 32)
98051: PPUSH
98052: CALL_OW 559
98056: GO 98296
98058: LD_INT 2
98060: DOUBLE
98061: EQUAL
98062: IFTRUE 98066
98064: GO 98080
98066: POP
// begin ToLua ( displayStucuk(); ) ;
98067: LD_STRING displayStucuk();
98069: PPUSH
98070: CALL_OW 559
// ResetFog ;
98074: CALL_OW 335
// end ; 3 :
98078: GO 98296
98080: LD_INT 3
98082: DOUBLE
98083: EQUAL
98084: IFTRUE 98088
98086: GO 98192
98088: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98089: LD_ADDR_VAR 0 2
98093: PUSH
98094: LD_INT 22
98096: PUSH
98097: LD_OWVAR 2
98101: PUSH
98102: EMPTY
98103: LIST
98104: LIST
98105: PUSH
98106: LD_INT 25
98108: PUSH
98109: LD_INT 1
98111: PUSH
98112: EMPTY
98113: LIST
98114: LIST
98115: PUSH
98116: EMPTY
98117: LIST
98118: LIST
98119: PPUSH
98120: CALL_OW 69
98124: ST_TO_ADDR
// if not tmp then
98125: LD_VAR 0 2
98129: NOT
98130: IFFALSE 98134
// exit ;
98132: GO 98296
// un := tmp [ rand ( 1 , tmp ) ] ;
98134: LD_ADDR_VAR 0 3
98138: PUSH
98139: LD_VAR 0 2
98143: PUSH
98144: LD_INT 1
98146: PPUSH
98147: LD_VAR 0 2
98151: PPUSH
98152: CALL_OW 12
98156: ARRAY
98157: ST_TO_ADDR
// if Crawls ( un ) then
98158: LD_VAR 0 3
98162: PPUSH
98163: CALL_OW 318
98167: IFFALSE 98178
// ComWalk ( un ) ;
98169: LD_VAR 0 3
98173: PPUSH
98174: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98178: LD_VAR 0 3
98182: PPUSH
98183: LD_INT 8
98185: PPUSH
98186: CALL_OW 336
// end ; 4 :
98190: GO 98296
98192: LD_INT 4
98194: DOUBLE
98195: EQUAL
98196: IFTRUE 98200
98198: GO 98274
98200: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
98201: LD_ADDR_VAR 0 2
98205: PUSH
98206: LD_INT 22
98208: PUSH
98209: LD_OWVAR 2
98213: PUSH
98214: EMPTY
98215: LIST
98216: LIST
98217: PUSH
98218: LD_INT 30
98220: PUSH
98221: LD_INT 29
98223: PUSH
98224: EMPTY
98225: LIST
98226: LIST
98227: PUSH
98228: EMPTY
98229: LIST
98230: LIST
98231: PPUSH
98232: CALL_OW 69
98236: ST_TO_ADDR
// if not tmp then
98237: LD_VAR 0 2
98241: NOT
98242: IFFALSE 98246
// exit ;
98244: GO 98296
// CenterNowOnUnits ( tmp [ 1 ] ) ;
98246: LD_VAR 0 2
98250: PUSH
98251: LD_INT 1
98253: ARRAY
98254: PPUSH
98255: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
98259: LD_VAR 0 2
98263: PUSH
98264: LD_INT 1
98266: ARRAY
98267: PPUSH
98268: CALL_OW 65
// end ; 5 .. 7 :
98272: GO 98296
98274: LD_INT 5
98276: DOUBLE
98277: GREATEREQUAL
98278: IFFALSE 98286
98280: LD_INT 7
98282: DOUBLE
98283: LESSEQUAL
98284: IFTRUE 98288
98286: GO 98295
98288: POP
// StreamSibBomb ; end ;
98289: CALL 94533 0 0
98293: GO 98296
98295: POP
// end ;
98296: PPOPN 3
98298: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
98299: LD_EXP 122
98303: PUSH
98304: LD_EXP 172
98308: AND
98309: IFFALSE 98465
98311: GO 98313
98313: DISABLE
98314: LD_INT 0
98316: PPUSH
98317: PPUSH
98318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
98319: LD_ADDR_VAR 0 2
98323: PUSH
98324: LD_INT 81
98326: PUSH
98327: LD_OWVAR 2
98331: PUSH
98332: EMPTY
98333: LIST
98334: LIST
98335: PUSH
98336: LD_INT 2
98338: PUSH
98339: LD_INT 21
98341: PUSH
98342: LD_INT 1
98344: PUSH
98345: EMPTY
98346: LIST
98347: LIST
98348: PUSH
98349: LD_INT 21
98351: PUSH
98352: LD_INT 2
98354: PUSH
98355: EMPTY
98356: LIST
98357: LIST
98358: PUSH
98359: EMPTY
98360: LIST
98361: LIST
98362: LIST
98363: PUSH
98364: EMPTY
98365: LIST
98366: LIST
98367: PPUSH
98368: CALL_OW 69
98372: ST_TO_ADDR
// if not tmp then
98373: LD_VAR 0 2
98377: NOT
98378: IFFALSE 98382
// exit ;
98380: GO 98465
// p := 0 ;
98382: LD_ADDR_VAR 0 3
98386: PUSH
98387: LD_INT 0
98389: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98390: LD_INT 35
98392: PPUSH
98393: CALL_OW 67
// p := p + 1 ;
98397: LD_ADDR_VAR 0 3
98401: PUSH
98402: LD_VAR 0 3
98406: PUSH
98407: LD_INT 1
98409: PLUS
98410: ST_TO_ADDR
// for i in tmp do
98411: LD_ADDR_VAR 0 1
98415: PUSH
98416: LD_VAR 0 2
98420: PUSH
98421: FOR_IN
98422: IFFALSE 98453
// if GetLives ( i ) < 1000 then
98424: LD_VAR 0 1
98428: PPUSH
98429: CALL_OW 256
98433: PUSH
98434: LD_INT 1000
98436: LESS
98437: IFFALSE 98451
// SetLives ( i , 1000 ) ;
98439: LD_VAR 0 1
98443: PPUSH
98444: LD_INT 1000
98446: PPUSH
98447: CALL_OW 234
98451: GO 98421
98453: POP
98454: POP
// until p > 20 ;
98455: LD_VAR 0 3
98459: PUSH
98460: LD_INT 20
98462: GREATER
98463: IFFALSE 98390
// end ;
98465: PPOPN 3
98467: END
// every 0 0$1 trigger StreamModeActive and sTime do
98468: LD_EXP 122
98472: PUSH
98473: LD_EXP 173
98477: AND
98478: IFFALSE 98513
98480: GO 98482
98482: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98483: LD_INT 28
98485: PPUSH
98486: LD_OWVAR 2
98490: PPUSH
98491: LD_INT 2
98493: PPUSH
98494: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98498: LD_INT 30
98500: PPUSH
98501: LD_OWVAR 2
98505: PPUSH
98506: LD_INT 2
98508: PPUSH
98509: CALL_OW 322
// end ;
98513: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98514: LD_EXP 122
98518: PUSH
98519: LD_EXP 174
98523: AND
98524: IFFALSE 98645
98526: GO 98528
98528: DISABLE
98529: LD_INT 0
98531: PPUSH
98532: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98533: LD_ADDR_VAR 0 2
98537: PUSH
98538: LD_INT 22
98540: PUSH
98541: LD_OWVAR 2
98545: PUSH
98546: EMPTY
98547: LIST
98548: LIST
98549: PUSH
98550: LD_INT 21
98552: PUSH
98553: LD_INT 1
98555: PUSH
98556: EMPTY
98557: LIST
98558: LIST
98559: PUSH
98560: LD_INT 3
98562: PUSH
98563: LD_INT 23
98565: PUSH
98566: LD_INT 0
98568: PUSH
98569: EMPTY
98570: LIST
98571: LIST
98572: PUSH
98573: EMPTY
98574: LIST
98575: LIST
98576: PUSH
98577: EMPTY
98578: LIST
98579: LIST
98580: LIST
98581: PPUSH
98582: CALL_OW 69
98586: ST_TO_ADDR
// if not tmp then
98587: LD_VAR 0 2
98591: NOT
98592: IFFALSE 98596
// exit ;
98594: GO 98645
// for i in tmp do
98596: LD_ADDR_VAR 0 1
98600: PUSH
98601: LD_VAR 0 2
98605: PUSH
98606: FOR_IN
98607: IFFALSE 98643
// begin if Crawls ( i ) then
98609: LD_VAR 0 1
98613: PPUSH
98614: CALL_OW 318
98618: IFFALSE 98629
// ComWalk ( i ) ;
98620: LD_VAR 0 1
98624: PPUSH
98625: CALL_OW 138
// SetClass ( i , 2 ) ;
98629: LD_VAR 0 1
98633: PPUSH
98634: LD_INT 2
98636: PPUSH
98637: CALL_OW 336
// end ;
98641: GO 98606
98643: POP
98644: POP
// end ;
98645: PPOPN 2
98647: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98648: LD_EXP 122
98652: PUSH
98653: LD_EXP 175
98657: AND
98658: IFFALSE 98946
98660: GO 98662
98662: DISABLE
98663: LD_INT 0
98665: PPUSH
98666: PPUSH
98667: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98668: LD_OWVAR 2
98672: PPUSH
98673: LD_INT 9
98675: PPUSH
98676: LD_INT 1
98678: PPUSH
98679: LD_INT 1
98681: PPUSH
98682: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98686: LD_INT 9
98688: PPUSH
98689: LD_OWVAR 2
98693: PPUSH
98694: CALL_OW 343
// uc_side := 9 ;
98698: LD_ADDR_OWVAR 20
98702: PUSH
98703: LD_INT 9
98705: ST_TO_ADDR
// uc_nation := 2 ;
98706: LD_ADDR_OWVAR 21
98710: PUSH
98711: LD_INT 2
98713: ST_TO_ADDR
// hc_name := Dark Warrior ;
98714: LD_ADDR_OWVAR 26
98718: PUSH
98719: LD_STRING Dark Warrior
98721: ST_TO_ADDR
// hc_gallery :=  ;
98722: LD_ADDR_OWVAR 33
98726: PUSH
98727: LD_STRING 
98729: ST_TO_ADDR
// hc_noskilllimit := true ;
98730: LD_ADDR_OWVAR 76
98734: PUSH
98735: LD_INT 1
98737: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98738: LD_ADDR_OWVAR 31
98742: PUSH
98743: LD_INT 30
98745: PUSH
98746: LD_INT 30
98748: PUSH
98749: LD_INT 30
98751: PUSH
98752: LD_INT 30
98754: PUSH
98755: EMPTY
98756: LIST
98757: LIST
98758: LIST
98759: LIST
98760: ST_TO_ADDR
// un := CreateHuman ;
98761: LD_ADDR_VAR 0 3
98765: PUSH
98766: CALL_OW 44
98770: ST_TO_ADDR
// hc_noskilllimit := false ;
98771: LD_ADDR_OWVAR 76
98775: PUSH
98776: LD_INT 0
98778: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98779: LD_VAR 0 3
98783: PPUSH
98784: LD_INT 1
98786: PPUSH
98787: CALL_OW 51
// ToLua ( playRanger() ) ;
98791: LD_STRING playRanger()
98793: PPUSH
98794: CALL_OW 559
// p := 0 ;
98798: LD_ADDR_VAR 0 2
98802: PUSH
98803: LD_INT 0
98805: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98806: LD_INT 35
98808: PPUSH
98809: CALL_OW 67
// p := p + 1 ;
98813: LD_ADDR_VAR 0 2
98817: PUSH
98818: LD_VAR 0 2
98822: PUSH
98823: LD_INT 1
98825: PLUS
98826: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98827: LD_VAR 0 3
98831: PPUSH
98832: CALL_OW 256
98836: PUSH
98837: LD_INT 1000
98839: LESS
98840: IFFALSE 98854
// SetLives ( un , 1000 ) ;
98842: LD_VAR 0 3
98846: PPUSH
98847: LD_INT 1000
98849: PPUSH
98850: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98854: LD_VAR 0 3
98858: PPUSH
98859: LD_INT 81
98861: PUSH
98862: LD_OWVAR 2
98866: PUSH
98867: EMPTY
98868: LIST
98869: LIST
98870: PUSH
98871: LD_INT 91
98873: PUSH
98874: LD_VAR 0 3
98878: PUSH
98879: LD_INT 30
98881: PUSH
98882: EMPTY
98883: LIST
98884: LIST
98885: LIST
98886: PUSH
98887: EMPTY
98888: LIST
98889: LIST
98890: PPUSH
98891: CALL_OW 69
98895: PPUSH
98896: LD_VAR 0 3
98900: PPUSH
98901: CALL_OW 74
98905: PPUSH
98906: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
98910: LD_VAR 0 2
98914: PUSH
98915: LD_INT 80
98917: GREATER
98918: PUSH
98919: LD_VAR 0 3
98923: PPUSH
98924: CALL_OW 301
98928: OR
98929: IFFALSE 98806
// if un then
98931: LD_VAR 0 3
98935: IFFALSE 98946
// RemoveUnit ( un ) ;
98937: LD_VAR 0 3
98941: PPUSH
98942: CALL_OW 64
// end ;
98946: PPOPN 3
98948: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
98949: LD_EXP 176
98953: IFFALSE 99069
98955: GO 98957
98957: DISABLE
98958: LD_INT 0
98960: PPUSH
98961: PPUSH
98962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98963: LD_ADDR_VAR 0 2
98967: PUSH
98968: LD_INT 81
98970: PUSH
98971: LD_OWVAR 2
98975: PUSH
98976: EMPTY
98977: LIST
98978: LIST
98979: PUSH
98980: LD_INT 21
98982: PUSH
98983: LD_INT 1
98985: PUSH
98986: EMPTY
98987: LIST
98988: LIST
98989: PUSH
98990: EMPTY
98991: LIST
98992: LIST
98993: PPUSH
98994: CALL_OW 69
98998: ST_TO_ADDR
// ToLua ( playComputer() ) ;
98999: LD_STRING playComputer()
99001: PPUSH
99002: CALL_OW 559
// if not tmp then
99006: LD_VAR 0 2
99010: NOT
99011: IFFALSE 99015
// exit ;
99013: GO 99069
// for i in tmp do
99015: LD_ADDR_VAR 0 1
99019: PUSH
99020: LD_VAR 0 2
99024: PUSH
99025: FOR_IN
99026: IFFALSE 99067
// for j := 1 to 4 do
99028: LD_ADDR_VAR 0 3
99032: PUSH
99033: DOUBLE
99034: LD_INT 1
99036: DEC
99037: ST_TO_ADDR
99038: LD_INT 4
99040: PUSH
99041: FOR_TO
99042: IFFALSE 99063
// SetSkill ( i , j , 10 ) ;
99044: LD_VAR 0 1
99048: PPUSH
99049: LD_VAR 0 3
99053: PPUSH
99054: LD_INT 10
99056: PPUSH
99057: CALL_OW 237
99061: GO 99041
99063: POP
99064: POP
99065: GO 99025
99067: POP
99068: POP
// end ;
99069: PPOPN 3
99071: END
// every 0 0$1 trigger s30 do var i , tmp ;
99072: LD_EXP 177
99076: IFFALSE 99145
99078: GO 99080
99080: DISABLE
99081: LD_INT 0
99083: PPUSH
99084: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99085: LD_ADDR_VAR 0 2
99089: PUSH
99090: LD_INT 22
99092: PUSH
99093: LD_OWVAR 2
99097: PUSH
99098: EMPTY
99099: LIST
99100: LIST
99101: PPUSH
99102: CALL_OW 69
99106: ST_TO_ADDR
// if not tmp then
99107: LD_VAR 0 2
99111: NOT
99112: IFFALSE 99116
// exit ;
99114: GO 99145
// for i in tmp do
99116: LD_ADDR_VAR 0 1
99120: PUSH
99121: LD_VAR 0 2
99125: PUSH
99126: FOR_IN
99127: IFFALSE 99143
// SetLives ( i , 300 ) ;
99129: LD_VAR 0 1
99133: PPUSH
99134: LD_INT 300
99136: PPUSH
99137: CALL_OW 234
99141: GO 99126
99143: POP
99144: POP
// end ;
99145: PPOPN 2
99147: END
// every 0 0$1 trigger s60 do var i , tmp ;
99148: LD_EXP 178
99152: IFFALSE 99221
99154: GO 99156
99156: DISABLE
99157: LD_INT 0
99159: PPUSH
99160: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
99161: LD_ADDR_VAR 0 2
99165: PUSH
99166: LD_INT 22
99168: PUSH
99169: LD_OWVAR 2
99173: PUSH
99174: EMPTY
99175: LIST
99176: LIST
99177: PPUSH
99178: CALL_OW 69
99182: ST_TO_ADDR
// if not tmp then
99183: LD_VAR 0 2
99187: NOT
99188: IFFALSE 99192
// exit ;
99190: GO 99221
// for i in tmp do
99192: LD_ADDR_VAR 0 1
99196: PUSH
99197: LD_VAR 0 2
99201: PUSH
99202: FOR_IN
99203: IFFALSE 99219
// SetLives ( i , 600 ) ;
99205: LD_VAR 0 1
99209: PPUSH
99210: LD_INT 600
99212: PPUSH
99213: CALL_OW 234
99217: GO 99202
99219: POP
99220: POP
// end ;
99221: PPOPN 2
99223: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
99224: LD_INT 0
99226: PPUSH
// case cmd of 301 :
99227: LD_VAR 0 1
99231: PUSH
99232: LD_INT 301
99234: DOUBLE
99235: EQUAL
99236: IFTRUE 99240
99238: GO 99272
99240: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
99241: LD_VAR 0 6
99245: PPUSH
99246: LD_VAR 0 7
99250: PPUSH
99251: LD_VAR 0 8
99255: PPUSH
99256: LD_VAR 0 4
99260: PPUSH
99261: LD_VAR 0 5
99265: PPUSH
99266: CALL 100473 0 5
99270: GO 99393
99272: LD_INT 302
99274: DOUBLE
99275: EQUAL
99276: IFTRUE 99280
99278: GO 99317
99280: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
99281: LD_VAR 0 6
99285: PPUSH
99286: LD_VAR 0 7
99290: PPUSH
99291: LD_VAR 0 8
99295: PPUSH
99296: LD_VAR 0 9
99300: PPUSH
99301: LD_VAR 0 4
99305: PPUSH
99306: LD_VAR 0 5
99310: PPUSH
99311: CALL 100564 0 6
99315: GO 99393
99317: LD_INT 303
99319: DOUBLE
99320: EQUAL
99321: IFTRUE 99325
99323: GO 99362
99325: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
99326: LD_VAR 0 6
99330: PPUSH
99331: LD_VAR 0 7
99335: PPUSH
99336: LD_VAR 0 8
99340: PPUSH
99341: LD_VAR 0 9
99345: PPUSH
99346: LD_VAR 0 4
99350: PPUSH
99351: LD_VAR 0 5
99355: PPUSH
99356: CALL 99398 0 6
99360: GO 99393
99362: LD_INT 304
99364: DOUBLE
99365: EQUAL
99366: IFTRUE 99370
99368: GO 99392
99370: POP
// hHackTeleport ( unit , x , y ) ; end ;
99371: LD_VAR 0 2
99375: PPUSH
99376: LD_VAR 0 4
99380: PPUSH
99381: LD_VAR 0 5
99385: PPUSH
99386: CALL 101157 0 3
99390: GO 99393
99392: POP
// end ;
99393: LD_VAR 0 12
99397: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
99398: LD_INT 0
99400: PPUSH
99401: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
99402: LD_VAR 0 1
99406: PUSH
99407: LD_INT 1
99409: LESS
99410: PUSH
99411: LD_VAR 0 1
99415: PUSH
99416: LD_INT 3
99418: GREATER
99419: OR
99420: PUSH
99421: LD_VAR 0 5
99425: PPUSH
99426: LD_VAR 0 6
99430: PPUSH
99431: CALL_OW 428
99435: OR
99436: IFFALSE 99440
// exit ;
99438: GO 100160
// uc_side := your_side ;
99440: LD_ADDR_OWVAR 20
99444: PUSH
99445: LD_OWVAR 2
99449: ST_TO_ADDR
// uc_nation := nation ;
99450: LD_ADDR_OWVAR 21
99454: PUSH
99455: LD_VAR 0 1
99459: ST_TO_ADDR
// bc_level = 1 ;
99460: LD_ADDR_OWVAR 43
99464: PUSH
99465: LD_INT 1
99467: ST_TO_ADDR
// case btype of 1 :
99468: LD_VAR 0 2
99472: PUSH
99473: LD_INT 1
99475: DOUBLE
99476: EQUAL
99477: IFTRUE 99481
99479: GO 99492
99481: POP
// bc_type := b_depot ; 2 :
99482: LD_ADDR_OWVAR 42
99486: PUSH
99487: LD_INT 0
99489: ST_TO_ADDR
99490: GO 100104
99492: LD_INT 2
99494: DOUBLE
99495: EQUAL
99496: IFTRUE 99500
99498: GO 99511
99500: POP
// bc_type := b_warehouse ; 3 :
99501: LD_ADDR_OWVAR 42
99505: PUSH
99506: LD_INT 1
99508: ST_TO_ADDR
99509: GO 100104
99511: LD_INT 3
99513: DOUBLE
99514: EQUAL
99515: IFTRUE 99519
99517: GO 99530
99519: POP
// bc_type := b_lab ; 4 .. 9 :
99520: LD_ADDR_OWVAR 42
99524: PUSH
99525: LD_INT 6
99527: ST_TO_ADDR
99528: GO 100104
99530: LD_INT 4
99532: DOUBLE
99533: GREATEREQUAL
99534: IFFALSE 99542
99536: LD_INT 9
99538: DOUBLE
99539: LESSEQUAL
99540: IFTRUE 99544
99542: GO 99596
99544: POP
// begin bc_type := b_lab_half ;
99545: LD_ADDR_OWVAR 42
99549: PUSH
99550: LD_INT 7
99552: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
99553: LD_ADDR_OWVAR 44
99557: PUSH
99558: LD_INT 10
99560: PUSH
99561: LD_INT 11
99563: PUSH
99564: LD_INT 12
99566: PUSH
99567: LD_INT 15
99569: PUSH
99570: LD_INT 14
99572: PUSH
99573: LD_INT 13
99575: PUSH
99576: EMPTY
99577: LIST
99578: LIST
99579: LIST
99580: LIST
99581: LIST
99582: LIST
99583: PUSH
99584: LD_VAR 0 2
99588: PUSH
99589: LD_INT 3
99591: MINUS
99592: ARRAY
99593: ST_TO_ADDR
// end ; 10 .. 13 :
99594: GO 100104
99596: LD_INT 10
99598: DOUBLE
99599: GREATEREQUAL
99600: IFFALSE 99608
99602: LD_INT 13
99604: DOUBLE
99605: LESSEQUAL
99606: IFTRUE 99610
99608: GO 99687
99610: POP
// begin bc_type := b_lab_full ;
99611: LD_ADDR_OWVAR 42
99615: PUSH
99616: LD_INT 8
99618: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
99619: LD_ADDR_OWVAR 44
99623: PUSH
99624: LD_INT 10
99626: PUSH
99627: LD_INT 12
99629: PUSH
99630: LD_INT 14
99632: PUSH
99633: LD_INT 13
99635: PUSH
99636: EMPTY
99637: LIST
99638: LIST
99639: LIST
99640: LIST
99641: PUSH
99642: LD_VAR 0 2
99646: PUSH
99647: LD_INT 9
99649: MINUS
99650: ARRAY
99651: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
99652: LD_ADDR_OWVAR 45
99656: PUSH
99657: LD_INT 11
99659: PUSH
99660: LD_INT 15
99662: PUSH
99663: LD_INT 12
99665: PUSH
99666: LD_INT 15
99668: PUSH
99669: EMPTY
99670: LIST
99671: LIST
99672: LIST
99673: LIST
99674: PUSH
99675: LD_VAR 0 2
99679: PUSH
99680: LD_INT 9
99682: MINUS
99683: ARRAY
99684: ST_TO_ADDR
// end ; 14 :
99685: GO 100104
99687: LD_INT 14
99689: DOUBLE
99690: EQUAL
99691: IFTRUE 99695
99693: GO 99706
99695: POP
// bc_type := b_workshop ; 15 :
99696: LD_ADDR_OWVAR 42
99700: PUSH
99701: LD_INT 2
99703: ST_TO_ADDR
99704: GO 100104
99706: LD_INT 15
99708: DOUBLE
99709: EQUAL
99710: IFTRUE 99714
99712: GO 99725
99714: POP
// bc_type := b_factory ; 16 :
99715: LD_ADDR_OWVAR 42
99719: PUSH
99720: LD_INT 3
99722: ST_TO_ADDR
99723: GO 100104
99725: LD_INT 16
99727: DOUBLE
99728: EQUAL
99729: IFTRUE 99733
99731: GO 99744
99733: POP
// bc_type := b_ext_gun ; 17 :
99734: LD_ADDR_OWVAR 42
99738: PUSH
99739: LD_INT 17
99741: ST_TO_ADDR
99742: GO 100104
99744: LD_INT 17
99746: DOUBLE
99747: EQUAL
99748: IFTRUE 99752
99750: GO 99780
99752: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99753: LD_ADDR_OWVAR 42
99757: PUSH
99758: LD_INT 19
99760: PUSH
99761: LD_INT 23
99763: PUSH
99764: LD_INT 19
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: LIST
99771: PUSH
99772: LD_VAR 0 1
99776: ARRAY
99777: ST_TO_ADDR
99778: GO 100104
99780: LD_INT 18
99782: DOUBLE
99783: EQUAL
99784: IFTRUE 99788
99786: GO 99799
99788: POP
// bc_type := b_ext_radar ; 19 :
99789: LD_ADDR_OWVAR 42
99793: PUSH
99794: LD_INT 20
99796: ST_TO_ADDR
99797: GO 100104
99799: LD_INT 19
99801: DOUBLE
99802: EQUAL
99803: IFTRUE 99807
99805: GO 99818
99807: POP
// bc_type := b_ext_radio ; 20 :
99808: LD_ADDR_OWVAR 42
99812: PUSH
99813: LD_INT 22
99815: ST_TO_ADDR
99816: GO 100104
99818: LD_INT 20
99820: DOUBLE
99821: EQUAL
99822: IFTRUE 99826
99824: GO 99837
99826: POP
// bc_type := b_ext_siberium ; 21 :
99827: LD_ADDR_OWVAR 42
99831: PUSH
99832: LD_INT 21
99834: ST_TO_ADDR
99835: GO 100104
99837: LD_INT 21
99839: DOUBLE
99840: EQUAL
99841: IFTRUE 99845
99843: GO 99856
99845: POP
// bc_type := b_ext_computer ; 22 :
99846: LD_ADDR_OWVAR 42
99850: PUSH
99851: LD_INT 24
99853: ST_TO_ADDR
99854: GO 100104
99856: LD_INT 22
99858: DOUBLE
99859: EQUAL
99860: IFTRUE 99864
99862: GO 99875
99864: POP
// bc_type := b_ext_track ; 23 :
99865: LD_ADDR_OWVAR 42
99869: PUSH
99870: LD_INT 16
99872: ST_TO_ADDR
99873: GO 100104
99875: LD_INT 23
99877: DOUBLE
99878: EQUAL
99879: IFTRUE 99883
99881: GO 99894
99883: POP
// bc_type := b_ext_laser ; 24 :
99884: LD_ADDR_OWVAR 42
99888: PUSH
99889: LD_INT 25
99891: ST_TO_ADDR
99892: GO 100104
99894: LD_INT 24
99896: DOUBLE
99897: EQUAL
99898: IFTRUE 99902
99900: GO 99913
99902: POP
// bc_type := b_control_tower ; 25 :
99903: LD_ADDR_OWVAR 42
99907: PUSH
99908: LD_INT 36
99910: ST_TO_ADDR
99911: GO 100104
99913: LD_INT 25
99915: DOUBLE
99916: EQUAL
99917: IFTRUE 99921
99919: GO 99932
99921: POP
// bc_type := b_breastwork ; 26 :
99922: LD_ADDR_OWVAR 42
99926: PUSH
99927: LD_INT 31
99929: ST_TO_ADDR
99930: GO 100104
99932: LD_INT 26
99934: DOUBLE
99935: EQUAL
99936: IFTRUE 99940
99938: GO 99951
99940: POP
// bc_type := b_bunker ; 27 :
99941: LD_ADDR_OWVAR 42
99945: PUSH
99946: LD_INT 32
99948: ST_TO_ADDR
99949: GO 100104
99951: LD_INT 27
99953: DOUBLE
99954: EQUAL
99955: IFTRUE 99959
99957: GO 99970
99959: POP
// bc_type := b_turret ; 28 :
99960: LD_ADDR_OWVAR 42
99964: PUSH
99965: LD_INT 33
99967: ST_TO_ADDR
99968: GO 100104
99970: LD_INT 28
99972: DOUBLE
99973: EQUAL
99974: IFTRUE 99978
99976: GO 99989
99978: POP
// bc_type := b_armoury ; 29 :
99979: LD_ADDR_OWVAR 42
99983: PUSH
99984: LD_INT 4
99986: ST_TO_ADDR
99987: GO 100104
99989: LD_INT 29
99991: DOUBLE
99992: EQUAL
99993: IFTRUE 99997
99995: GO 100008
99997: POP
// bc_type := b_barracks ; 30 :
99998: LD_ADDR_OWVAR 42
100002: PUSH
100003: LD_INT 5
100005: ST_TO_ADDR
100006: GO 100104
100008: LD_INT 30
100010: DOUBLE
100011: EQUAL
100012: IFTRUE 100016
100014: GO 100027
100016: POP
// bc_type := b_solar_power ; 31 :
100017: LD_ADDR_OWVAR 42
100021: PUSH
100022: LD_INT 27
100024: ST_TO_ADDR
100025: GO 100104
100027: LD_INT 31
100029: DOUBLE
100030: EQUAL
100031: IFTRUE 100035
100033: GO 100046
100035: POP
// bc_type := b_oil_power ; 32 :
100036: LD_ADDR_OWVAR 42
100040: PUSH
100041: LD_INT 26
100043: ST_TO_ADDR
100044: GO 100104
100046: LD_INT 32
100048: DOUBLE
100049: EQUAL
100050: IFTRUE 100054
100052: GO 100065
100054: POP
// bc_type := b_siberite_power ; 33 :
100055: LD_ADDR_OWVAR 42
100059: PUSH
100060: LD_INT 28
100062: ST_TO_ADDR
100063: GO 100104
100065: LD_INT 33
100067: DOUBLE
100068: EQUAL
100069: IFTRUE 100073
100071: GO 100084
100073: POP
// bc_type := b_oil_mine ; 34 :
100074: LD_ADDR_OWVAR 42
100078: PUSH
100079: LD_INT 29
100081: ST_TO_ADDR
100082: GO 100104
100084: LD_INT 34
100086: DOUBLE
100087: EQUAL
100088: IFTRUE 100092
100090: GO 100103
100092: POP
// bc_type := b_siberite_mine ; end ;
100093: LD_ADDR_OWVAR 42
100097: PUSH
100098: LD_INT 30
100100: ST_TO_ADDR
100101: GO 100104
100103: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
100104: LD_ADDR_VAR 0 8
100108: PUSH
100109: LD_VAR 0 5
100113: PPUSH
100114: LD_VAR 0 6
100118: PPUSH
100119: LD_VAR 0 3
100123: PPUSH
100124: CALL_OW 47
100128: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
100129: LD_OWVAR 42
100133: PUSH
100134: LD_INT 32
100136: PUSH
100137: LD_INT 33
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: IN
100144: IFFALSE 100160
// PlaceWeaponTurret ( b , weapon ) ;
100146: LD_VAR 0 8
100150: PPUSH
100151: LD_VAR 0 4
100155: PPUSH
100156: CALL_OW 431
// end ;
100160: LD_VAR 0 7
100164: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
100165: LD_INT 0
100167: PPUSH
100168: PPUSH
100169: PPUSH
100170: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100171: LD_ADDR_VAR 0 4
100175: PUSH
100176: LD_INT 22
100178: PUSH
100179: LD_OWVAR 2
100183: PUSH
100184: EMPTY
100185: LIST
100186: LIST
100187: PUSH
100188: LD_INT 2
100190: PUSH
100191: LD_INT 30
100193: PUSH
100194: LD_INT 0
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: PUSH
100201: LD_INT 30
100203: PUSH
100204: LD_INT 1
100206: PUSH
100207: EMPTY
100208: LIST
100209: LIST
100210: PUSH
100211: EMPTY
100212: LIST
100213: LIST
100214: LIST
100215: PUSH
100216: EMPTY
100217: LIST
100218: LIST
100219: PPUSH
100220: CALL_OW 69
100224: ST_TO_ADDR
// if not tmp then
100225: LD_VAR 0 4
100229: NOT
100230: IFFALSE 100234
// exit ;
100232: GO 100293
// for i in tmp do
100234: LD_ADDR_VAR 0 2
100238: PUSH
100239: LD_VAR 0 4
100243: PUSH
100244: FOR_IN
100245: IFFALSE 100291
// for j = 1 to 3 do
100247: LD_ADDR_VAR 0 3
100251: PUSH
100252: DOUBLE
100253: LD_INT 1
100255: DEC
100256: ST_TO_ADDR
100257: LD_INT 3
100259: PUSH
100260: FOR_TO
100261: IFFALSE 100287
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
100263: LD_VAR 0 2
100267: PPUSH
100268: CALL_OW 274
100272: PPUSH
100273: LD_VAR 0 3
100277: PPUSH
100278: LD_INT 99999
100280: PPUSH
100281: CALL_OW 277
100285: GO 100260
100287: POP
100288: POP
100289: GO 100244
100291: POP
100292: POP
// end ;
100293: LD_VAR 0 1
100297: RET
// export function hHackSetLevel10 ; var i , j ; begin
100298: LD_INT 0
100300: PPUSH
100301: PPUSH
100302: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100303: LD_ADDR_VAR 0 2
100307: PUSH
100308: LD_INT 21
100310: PUSH
100311: LD_INT 1
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PPUSH
100318: CALL_OW 69
100322: PUSH
100323: FOR_IN
100324: IFFALSE 100376
// if IsSelected ( i ) then
100326: LD_VAR 0 2
100330: PPUSH
100331: CALL_OW 306
100335: IFFALSE 100374
// begin for j := 1 to 4 do
100337: LD_ADDR_VAR 0 3
100341: PUSH
100342: DOUBLE
100343: LD_INT 1
100345: DEC
100346: ST_TO_ADDR
100347: LD_INT 4
100349: PUSH
100350: FOR_TO
100351: IFFALSE 100372
// SetSkill ( i , j , 10 ) ;
100353: LD_VAR 0 2
100357: PPUSH
100358: LD_VAR 0 3
100362: PPUSH
100363: LD_INT 10
100365: PPUSH
100366: CALL_OW 237
100370: GO 100350
100372: POP
100373: POP
// end ;
100374: GO 100323
100376: POP
100377: POP
// end ;
100378: LD_VAR 0 1
100382: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
100383: LD_INT 0
100385: PPUSH
100386: PPUSH
100387: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
100388: LD_ADDR_VAR 0 2
100392: PUSH
100393: LD_INT 22
100395: PUSH
100396: LD_OWVAR 2
100400: PUSH
100401: EMPTY
100402: LIST
100403: LIST
100404: PUSH
100405: LD_INT 21
100407: PUSH
100408: LD_INT 1
100410: PUSH
100411: EMPTY
100412: LIST
100413: LIST
100414: PUSH
100415: EMPTY
100416: LIST
100417: LIST
100418: PPUSH
100419: CALL_OW 69
100423: PUSH
100424: FOR_IN
100425: IFFALSE 100466
// begin for j := 1 to 4 do
100427: LD_ADDR_VAR 0 3
100431: PUSH
100432: DOUBLE
100433: LD_INT 1
100435: DEC
100436: ST_TO_ADDR
100437: LD_INT 4
100439: PUSH
100440: FOR_TO
100441: IFFALSE 100462
// SetSkill ( i , j , 10 ) ;
100443: LD_VAR 0 2
100447: PPUSH
100448: LD_VAR 0 3
100452: PPUSH
100453: LD_INT 10
100455: PPUSH
100456: CALL_OW 237
100460: GO 100440
100462: POP
100463: POP
// end ;
100464: GO 100424
100466: POP
100467: POP
// end ;
100468: LD_VAR 0 1
100472: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
100473: LD_INT 0
100475: PPUSH
// uc_side := your_side ;
100476: LD_ADDR_OWVAR 20
100480: PUSH
100481: LD_OWVAR 2
100485: ST_TO_ADDR
// uc_nation := nation ;
100486: LD_ADDR_OWVAR 21
100490: PUSH
100491: LD_VAR 0 1
100495: ST_TO_ADDR
// InitHc ;
100496: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
100500: LD_INT 0
100502: PPUSH
100503: LD_VAR 0 2
100507: PPUSH
100508: LD_VAR 0 3
100512: PPUSH
100513: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
100517: LD_VAR 0 4
100521: PPUSH
100522: LD_VAR 0 5
100526: PPUSH
100527: CALL_OW 428
100531: PUSH
100532: LD_INT 0
100534: EQUAL
100535: IFFALSE 100559
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
100537: CALL_OW 44
100541: PPUSH
100542: LD_VAR 0 4
100546: PPUSH
100547: LD_VAR 0 5
100551: PPUSH
100552: LD_INT 1
100554: PPUSH
100555: CALL_OW 48
// end ;
100559: LD_VAR 0 6
100563: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
100564: LD_INT 0
100566: PPUSH
100567: PPUSH
// uc_side := your_side ;
100568: LD_ADDR_OWVAR 20
100572: PUSH
100573: LD_OWVAR 2
100577: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
100578: LD_VAR 0 1
100582: PUSH
100583: LD_INT 1
100585: PUSH
100586: LD_INT 2
100588: PUSH
100589: LD_INT 3
100591: PUSH
100592: LD_INT 4
100594: PUSH
100595: LD_INT 5
100597: PUSH
100598: EMPTY
100599: LIST
100600: LIST
100601: LIST
100602: LIST
100603: LIST
100604: IN
100605: IFFALSE 100617
// uc_nation := nation_american else
100607: LD_ADDR_OWVAR 21
100611: PUSH
100612: LD_INT 1
100614: ST_TO_ADDR
100615: GO 100660
// if chassis in [ 11 , 12 , 13 , 14 ] then
100617: LD_VAR 0 1
100621: PUSH
100622: LD_INT 11
100624: PUSH
100625: LD_INT 12
100627: PUSH
100628: LD_INT 13
100630: PUSH
100631: LD_INT 14
100633: PUSH
100634: EMPTY
100635: LIST
100636: LIST
100637: LIST
100638: LIST
100639: IN
100640: IFFALSE 100652
// uc_nation := nation_arabian else
100642: LD_ADDR_OWVAR 21
100646: PUSH
100647: LD_INT 2
100649: ST_TO_ADDR
100650: GO 100660
// uc_nation := nation_russian ;
100652: LD_ADDR_OWVAR 21
100656: PUSH
100657: LD_INT 3
100659: ST_TO_ADDR
// vc_chassis := chassis ;
100660: LD_ADDR_OWVAR 37
100664: PUSH
100665: LD_VAR 0 1
100669: ST_TO_ADDR
// vc_engine := engine ;
100670: LD_ADDR_OWVAR 39
100674: PUSH
100675: LD_VAR 0 2
100679: ST_TO_ADDR
// vc_control := control ;
100680: LD_ADDR_OWVAR 38
100684: PUSH
100685: LD_VAR 0 3
100689: ST_TO_ADDR
// vc_weapon := weapon ;
100690: LD_ADDR_OWVAR 40
100694: PUSH
100695: LD_VAR 0 4
100699: ST_TO_ADDR
// un := CreateVehicle ;
100700: LD_ADDR_VAR 0 8
100704: PUSH
100705: CALL_OW 45
100709: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100710: LD_VAR 0 8
100714: PPUSH
100715: LD_INT 0
100717: PPUSH
100718: LD_INT 5
100720: PPUSH
100721: CALL_OW 12
100725: PPUSH
100726: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100730: LD_VAR 0 8
100734: PPUSH
100735: LD_VAR 0 5
100739: PPUSH
100740: LD_VAR 0 6
100744: PPUSH
100745: LD_INT 1
100747: PPUSH
100748: CALL_OW 48
// end ;
100752: LD_VAR 0 7
100756: RET
// export hInvincible ; every 1 do
100757: GO 100759
100759: DISABLE
// hInvincible := [ ] ;
100760: LD_ADDR_EXP 179
100764: PUSH
100765: EMPTY
100766: ST_TO_ADDR
100767: END
// every 10 do var i ;
100768: GO 100770
100770: DISABLE
100771: LD_INT 0
100773: PPUSH
// begin enable ;
100774: ENABLE
// if not hInvincible then
100775: LD_EXP 179
100779: NOT
100780: IFFALSE 100784
// exit ;
100782: GO 100828
// for i in hInvincible do
100784: LD_ADDR_VAR 0 1
100788: PUSH
100789: LD_EXP 179
100793: PUSH
100794: FOR_IN
100795: IFFALSE 100826
// if GetLives ( i ) < 1000 then
100797: LD_VAR 0 1
100801: PPUSH
100802: CALL_OW 256
100806: PUSH
100807: LD_INT 1000
100809: LESS
100810: IFFALSE 100824
// SetLives ( i , 1000 ) ;
100812: LD_VAR 0 1
100816: PPUSH
100817: LD_INT 1000
100819: PPUSH
100820: CALL_OW 234
100824: GO 100794
100826: POP
100827: POP
// end ;
100828: PPOPN 1
100830: END
// export function hHackInvincible ; var i ; begin
100831: LD_INT 0
100833: PPUSH
100834: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100835: LD_ADDR_VAR 0 2
100839: PUSH
100840: LD_INT 2
100842: PUSH
100843: LD_INT 21
100845: PUSH
100846: LD_INT 1
100848: PUSH
100849: EMPTY
100850: LIST
100851: LIST
100852: PUSH
100853: LD_INT 21
100855: PUSH
100856: LD_INT 2
100858: PUSH
100859: EMPTY
100860: LIST
100861: LIST
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: LIST
100867: PPUSH
100868: CALL_OW 69
100872: PUSH
100873: FOR_IN
100874: IFFALSE 100935
// if IsSelected ( i ) then
100876: LD_VAR 0 2
100880: PPUSH
100881: CALL_OW 306
100885: IFFALSE 100933
// begin if i in hInvincible then
100887: LD_VAR 0 2
100891: PUSH
100892: LD_EXP 179
100896: IN
100897: IFFALSE 100917
// hInvincible := hInvincible diff i else
100899: LD_ADDR_EXP 179
100903: PUSH
100904: LD_EXP 179
100908: PUSH
100909: LD_VAR 0 2
100913: DIFF
100914: ST_TO_ADDR
100915: GO 100933
// hInvincible := hInvincible union i ;
100917: LD_ADDR_EXP 179
100921: PUSH
100922: LD_EXP 179
100926: PUSH
100927: LD_VAR 0 2
100931: UNION
100932: ST_TO_ADDR
// end ;
100933: GO 100873
100935: POP
100936: POP
// end ;
100937: LD_VAR 0 1
100941: RET
// export function hHackInvisible ; var i , j ; begin
100942: LD_INT 0
100944: PPUSH
100945: PPUSH
100946: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100947: LD_ADDR_VAR 0 2
100951: PUSH
100952: LD_INT 21
100954: PUSH
100955: LD_INT 1
100957: PUSH
100958: EMPTY
100959: LIST
100960: LIST
100961: PPUSH
100962: CALL_OW 69
100966: PUSH
100967: FOR_IN
100968: IFFALSE 100992
// if IsSelected ( i ) then
100970: LD_VAR 0 2
100974: PPUSH
100975: CALL_OW 306
100979: IFFALSE 100990
// ComForceInvisible ( i ) ;
100981: LD_VAR 0 2
100985: PPUSH
100986: CALL_OW 496
100990: GO 100967
100992: POP
100993: POP
// end ;
100994: LD_VAR 0 1
100998: RET
// export function hHackChangeYourSide ; begin
100999: LD_INT 0
101001: PPUSH
// if your_side = 8 then
101002: LD_OWVAR 2
101006: PUSH
101007: LD_INT 8
101009: EQUAL
101010: IFFALSE 101022
// your_side := 0 else
101012: LD_ADDR_OWVAR 2
101016: PUSH
101017: LD_INT 0
101019: ST_TO_ADDR
101020: GO 101036
// your_side := your_side + 1 ;
101022: LD_ADDR_OWVAR 2
101026: PUSH
101027: LD_OWVAR 2
101031: PUSH
101032: LD_INT 1
101034: PLUS
101035: ST_TO_ADDR
// end ;
101036: LD_VAR 0 1
101040: RET
// export function hHackChangeUnitSide ; var i , j ; begin
101041: LD_INT 0
101043: PPUSH
101044: PPUSH
101045: PPUSH
// for i in all_units do
101046: LD_ADDR_VAR 0 2
101050: PUSH
101051: LD_OWVAR 3
101055: PUSH
101056: FOR_IN
101057: IFFALSE 101135
// if IsSelected ( i ) then
101059: LD_VAR 0 2
101063: PPUSH
101064: CALL_OW 306
101068: IFFALSE 101133
// begin j := GetSide ( i ) ;
101070: LD_ADDR_VAR 0 3
101074: PUSH
101075: LD_VAR 0 2
101079: PPUSH
101080: CALL_OW 255
101084: ST_TO_ADDR
// if j = 8 then
101085: LD_VAR 0 3
101089: PUSH
101090: LD_INT 8
101092: EQUAL
101093: IFFALSE 101105
// j := 0 else
101095: LD_ADDR_VAR 0 3
101099: PUSH
101100: LD_INT 0
101102: ST_TO_ADDR
101103: GO 101119
// j := j + 1 ;
101105: LD_ADDR_VAR 0 3
101109: PUSH
101110: LD_VAR 0 3
101114: PUSH
101115: LD_INT 1
101117: PLUS
101118: ST_TO_ADDR
// SetSide ( i , j ) ;
101119: LD_VAR 0 2
101123: PPUSH
101124: LD_VAR 0 3
101128: PPUSH
101129: CALL_OW 235
// end ;
101133: GO 101056
101135: POP
101136: POP
// end ;
101137: LD_VAR 0 1
101141: RET
// export function hHackFog ; begin
101142: LD_INT 0
101144: PPUSH
// FogOff ( true ) ;
101145: LD_INT 1
101147: PPUSH
101148: CALL_OW 344
// end ;
101152: LD_VAR 0 1
101156: RET
// export function hHackTeleport ( unit , x , y ) ; begin
101157: LD_INT 0
101159: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
101160: LD_VAR 0 1
101164: PPUSH
101165: LD_VAR 0 2
101169: PPUSH
101170: LD_VAR 0 3
101174: PPUSH
101175: LD_INT 1
101177: PPUSH
101178: LD_INT 1
101180: PPUSH
101181: CALL_OW 483
// CenterOnXY ( x , y ) ;
101185: LD_VAR 0 2
101189: PPUSH
101190: LD_VAR 0 3
101194: PPUSH
101195: CALL_OW 84
// end ;
101199: LD_VAR 0 4
101203: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
101204: LD_INT 0
101206: PPUSH
101207: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
101208: LD_VAR 0 1
101212: NOT
101213: PUSH
101214: LD_VAR 0 2
101218: PPUSH
101219: LD_VAR 0 3
101223: PPUSH
101224: CALL_OW 488
101228: NOT
101229: OR
101230: PUSH
101231: LD_VAR 0 1
101235: PPUSH
101236: CALL_OW 266
101240: PUSH
101241: LD_INT 3
101243: NONEQUAL
101244: PUSH
101245: LD_VAR 0 1
101249: PPUSH
101250: CALL_OW 247
101254: PUSH
101255: LD_INT 1
101257: EQUAL
101258: NOT
101259: AND
101260: OR
101261: IFFALSE 101265
// exit ;
101263: GO 101414
// if GetType ( factory ) = unit_human then
101265: LD_VAR 0 1
101269: PPUSH
101270: CALL_OW 247
101274: PUSH
101275: LD_INT 1
101277: EQUAL
101278: IFFALSE 101295
// factory := IsInUnit ( factory ) ;
101280: LD_ADDR_VAR 0 1
101284: PUSH
101285: LD_VAR 0 1
101289: PPUSH
101290: CALL_OW 310
101294: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
101295: LD_VAR 0 1
101299: PPUSH
101300: CALL_OW 266
101304: PUSH
101305: LD_INT 3
101307: NONEQUAL
101308: IFFALSE 101312
// exit ;
101310: GO 101414
// if HexInfo ( x , y ) = factory then
101312: LD_VAR 0 2
101316: PPUSH
101317: LD_VAR 0 3
101321: PPUSH
101322: CALL_OW 428
101326: PUSH
101327: LD_VAR 0 1
101331: EQUAL
101332: IFFALSE 101359
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
101334: LD_ADDR_EXP 180
101338: PUSH
101339: LD_EXP 180
101343: PPUSH
101344: LD_VAR 0 1
101348: PPUSH
101349: LD_INT 0
101351: PPUSH
101352: CALL_OW 1
101356: ST_TO_ADDR
101357: GO 101410
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
101359: LD_ADDR_EXP 180
101363: PUSH
101364: LD_EXP 180
101368: PPUSH
101369: LD_VAR 0 1
101373: PPUSH
101374: LD_VAR 0 1
101378: PPUSH
101379: CALL_OW 255
101383: PUSH
101384: LD_VAR 0 1
101388: PUSH
101389: LD_VAR 0 2
101393: PUSH
101394: LD_VAR 0 3
101398: PUSH
101399: EMPTY
101400: LIST
101401: LIST
101402: LIST
101403: LIST
101404: PPUSH
101405: CALL_OW 1
101409: ST_TO_ADDR
// UpdateFactoryWaypoints ;
101410: CALL 101419 0 0
// end ;
101414: LD_VAR 0 4
101418: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
101419: LD_INT 0
101421: PPUSH
101422: PPUSH
101423: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
101424: LD_STRING resetFactoryWaypoint();
101426: PPUSH
101427: CALL_OW 559
// if factoryWaypoints then
101431: LD_EXP 180
101435: IFFALSE 101561
// begin list := PrepareArray ( factoryWaypoints ) ;
101437: LD_ADDR_VAR 0 3
101441: PUSH
101442: LD_EXP 180
101446: PPUSH
101447: CALL 56029 0 1
101451: ST_TO_ADDR
// for i := 1 to list do
101452: LD_ADDR_VAR 0 2
101456: PUSH
101457: DOUBLE
101458: LD_INT 1
101460: DEC
101461: ST_TO_ADDR
101462: LD_VAR 0 3
101466: PUSH
101467: FOR_TO
101468: IFFALSE 101559
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101470: LD_STRING setFactoryWaypointXY(
101472: PUSH
101473: LD_VAR 0 3
101477: PUSH
101478: LD_VAR 0 2
101482: ARRAY
101483: PUSH
101484: LD_INT 1
101486: ARRAY
101487: STR
101488: PUSH
101489: LD_STRING ,
101491: STR
101492: PUSH
101493: LD_VAR 0 3
101497: PUSH
101498: LD_VAR 0 2
101502: ARRAY
101503: PUSH
101504: LD_INT 2
101506: ARRAY
101507: STR
101508: PUSH
101509: LD_STRING ,
101511: STR
101512: PUSH
101513: LD_VAR 0 3
101517: PUSH
101518: LD_VAR 0 2
101522: ARRAY
101523: PUSH
101524: LD_INT 3
101526: ARRAY
101527: STR
101528: PUSH
101529: LD_STRING ,
101531: STR
101532: PUSH
101533: LD_VAR 0 3
101537: PUSH
101538: LD_VAR 0 2
101542: ARRAY
101543: PUSH
101544: LD_INT 4
101546: ARRAY
101547: STR
101548: PUSH
101549: LD_STRING )
101551: STR
101552: PPUSH
101553: CALL_OW 559
101557: GO 101467
101559: POP
101560: POP
// end ; end ;
101561: LD_VAR 0 1
101565: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
101566: LD_INT 0
101568: PPUSH
// if HexInfo ( x , y ) = warehouse then
101569: LD_VAR 0 2
101573: PPUSH
101574: LD_VAR 0 3
101578: PPUSH
101579: CALL_OW 428
101583: PUSH
101584: LD_VAR 0 1
101588: EQUAL
101589: IFFALSE 101616
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
101591: LD_ADDR_EXP 181
101595: PUSH
101596: LD_EXP 181
101600: PPUSH
101601: LD_VAR 0 1
101605: PPUSH
101606: LD_INT 0
101608: PPUSH
101609: CALL_OW 1
101613: ST_TO_ADDR
101614: GO 101667
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
101616: LD_ADDR_EXP 181
101620: PUSH
101621: LD_EXP 181
101625: PPUSH
101626: LD_VAR 0 1
101630: PPUSH
101631: LD_VAR 0 1
101635: PPUSH
101636: CALL_OW 255
101640: PUSH
101641: LD_VAR 0 1
101645: PUSH
101646: LD_VAR 0 2
101650: PUSH
101651: LD_VAR 0 3
101655: PUSH
101656: EMPTY
101657: LIST
101658: LIST
101659: LIST
101660: LIST
101661: PPUSH
101662: CALL_OW 1
101666: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
101667: CALL 101676 0 0
// end ;
101671: LD_VAR 0 4
101675: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
101676: LD_INT 0
101678: PPUSH
101679: PPUSH
101680: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
101681: LD_STRING resetWarehouseGatheringPoints();
101683: PPUSH
101684: CALL_OW 559
// if warehouseGatheringPoints then
101688: LD_EXP 181
101692: IFFALSE 101818
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
101694: LD_ADDR_VAR 0 3
101698: PUSH
101699: LD_EXP 181
101703: PPUSH
101704: CALL 56029 0 1
101708: ST_TO_ADDR
// for i := 1 to list do
101709: LD_ADDR_VAR 0 2
101713: PUSH
101714: DOUBLE
101715: LD_INT 1
101717: DEC
101718: ST_TO_ADDR
101719: LD_VAR 0 3
101723: PUSH
101724: FOR_TO
101725: IFFALSE 101816
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
101727: LD_STRING setWarehouseGatheringPointXY(
101729: PUSH
101730: LD_VAR 0 3
101734: PUSH
101735: LD_VAR 0 2
101739: ARRAY
101740: PUSH
101741: LD_INT 1
101743: ARRAY
101744: STR
101745: PUSH
101746: LD_STRING ,
101748: STR
101749: PUSH
101750: LD_VAR 0 3
101754: PUSH
101755: LD_VAR 0 2
101759: ARRAY
101760: PUSH
101761: LD_INT 2
101763: ARRAY
101764: STR
101765: PUSH
101766: LD_STRING ,
101768: STR
101769: PUSH
101770: LD_VAR 0 3
101774: PUSH
101775: LD_VAR 0 2
101779: ARRAY
101780: PUSH
101781: LD_INT 3
101783: ARRAY
101784: STR
101785: PUSH
101786: LD_STRING ,
101788: STR
101789: PUSH
101790: LD_VAR 0 3
101794: PUSH
101795: LD_VAR 0 2
101799: ARRAY
101800: PUSH
101801: LD_INT 4
101803: ARRAY
101804: STR
101805: PUSH
101806: LD_STRING )
101808: STR
101809: PPUSH
101810: CALL_OW 559
101814: GO 101724
101816: POP
101817: POP
// end ; end ;
101818: LD_VAR 0 1
101822: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
101823: LD_EXP 181
101827: IFFALSE 102514
101829: GO 101831
101831: DISABLE
101832: LD_INT 0
101834: PPUSH
101835: PPUSH
101836: PPUSH
101837: PPUSH
101838: PPUSH
101839: PPUSH
101840: PPUSH
101841: PPUSH
101842: PPUSH
// begin enable ;
101843: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
101844: LD_ADDR_VAR 0 3
101848: PUSH
101849: LD_EXP 181
101853: PPUSH
101854: CALL 56029 0 1
101858: ST_TO_ADDR
// if not list then
101859: LD_VAR 0 3
101863: NOT
101864: IFFALSE 101868
// exit ;
101866: GO 102514
// for i := 1 to list do
101868: LD_ADDR_VAR 0 1
101872: PUSH
101873: DOUBLE
101874: LD_INT 1
101876: DEC
101877: ST_TO_ADDR
101878: LD_VAR 0 3
101882: PUSH
101883: FOR_TO
101884: IFFALSE 102512
// begin depot := list [ i ] [ 2 ] ;
101886: LD_ADDR_VAR 0 8
101890: PUSH
101891: LD_VAR 0 3
101895: PUSH
101896: LD_VAR 0 1
101900: ARRAY
101901: PUSH
101902: LD_INT 2
101904: ARRAY
101905: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
101906: LD_ADDR_VAR 0 5
101910: PUSH
101911: LD_VAR 0 3
101915: PUSH
101916: LD_VAR 0 1
101920: ARRAY
101921: PUSH
101922: LD_INT 1
101924: ARRAY
101925: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
101926: LD_VAR 0 8
101930: PPUSH
101931: CALL_OW 301
101935: PUSH
101936: LD_VAR 0 5
101940: PUSH
101941: LD_VAR 0 8
101945: PPUSH
101946: CALL_OW 255
101950: NONEQUAL
101951: OR
101952: IFFALSE 101981
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
101954: LD_ADDR_EXP 181
101958: PUSH
101959: LD_EXP 181
101963: PPUSH
101964: LD_VAR 0 8
101968: PPUSH
101969: LD_INT 0
101971: PPUSH
101972: CALL_OW 1
101976: ST_TO_ADDR
// exit ;
101977: POP
101978: POP
101979: GO 102514
// end ; x := list [ i ] [ 3 ] ;
101981: LD_ADDR_VAR 0 6
101985: PUSH
101986: LD_VAR 0 3
101990: PUSH
101991: LD_VAR 0 1
101995: ARRAY
101996: PUSH
101997: LD_INT 3
101999: ARRAY
102000: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
102001: LD_ADDR_VAR 0 7
102005: PUSH
102006: LD_VAR 0 3
102010: PUSH
102011: LD_VAR 0 1
102015: ARRAY
102016: PUSH
102017: LD_INT 4
102019: ARRAY
102020: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
102021: LD_ADDR_VAR 0 9
102025: PUSH
102026: LD_VAR 0 6
102030: PPUSH
102031: LD_VAR 0 7
102035: PPUSH
102036: LD_INT 16
102038: PPUSH
102039: CALL 54613 0 3
102043: ST_TO_ADDR
// if not cratesNearbyPoint then
102044: LD_VAR 0 9
102048: NOT
102049: IFFALSE 102055
// exit ;
102051: POP
102052: POP
102053: GO 102514
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
102055: LD_ADDR_VAR 0 4
102059: PUSH
102060: LD_INT 22
102062: PUSH
102063: LD_VAR 0 5
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: PUSH
102072: LD_INT 3
102074: PUSH
102075: LD_INT 60
102077: PUSH
102078: EMPTY
102079: LIST
102080: PUSH
102081: EMPTY
102082: LIST
102083: LIST
102084: PUSH
102085: LD_INT 91
102087: PUSH
102088: LD_VAR 0 8
102092: PUSH
102093: LD_INT 6
102095: PUSH
102096: EMPTY
102097: LIST
102098: LIST
102099: LIST
102100: PUSH
102101: LD_INT 2
102103: PUSH
102104: LD_INT 25
102106: PUSH
102107: LD_INT 2
102109: PUSH
102110: EMPTY
102111: LIST
102112: LIST
102113: PUSH
102114: LD_INT 25
102116: PUSH
102117: LD_INT 16
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: PUSH
102124: EMPTY
102125: LIST
102126: LIST
102127: LIST
102128: PUSH
102129: EMPTY
102130: LIST
102131: LIST
102132: LIST
102133: LIST
102134: PPUSH
102135: CALL_OW 69
102139: PUSH
102140: LD_VAR 0 8
102144: PPUSH
102145: CALL_OW 313
102149: PPUSH
102150: LD_INT 3
102152: PUSH
102153: LD_INT 60
102155: PUSH
102156: EMPTY
102157: LIST
102158: PUSH
102159: EMPTY
102160: LIST
102161: LIST
102162: PUSH
102163: LD_INT 2
102165: PUSH
102166: LD_INT 25
102168: PUSH
102169: LD_INT 2
102171: PUSH
102172: EMPTY
102173: LIST
102174: LIST
102175: PUSH
102176: LD_INT 25
102178: PUSH
102179: LD_INT 16
102181: PUSH
102182: EMPTY
102183: LIST
102184: LIST
102185: PUSH
102186: EMPTY
102187: LIST
102188: LIST
102189: LIST
102190: PUSH
102191: EMPTY
102192: LIST
102193: LIST
102194: PPUSH
102195: CALL_OW 72
102199: UNION
102200: ST_TO_ADDR
// if tmp then
102201: LD_VAR 0 4
102205: IFFALSE 102285
// begin tmp := ShrinkArray ( tmp , 3 ) ;
102207: LD_ADDR_VAR 0 4
102211: PUSH
102212: LD_VAR 0 4
102216: PPUSH
102217: LD_INT 3
102219: PPUSH
102220: CALL 52580 0 2
102224: ST_TO_ADDR
// for j in tmp do
102225: LD_ADDR_VAR 0 2
102229: PUSH
102230: LD_VAR 0 4
102234: PUSH
102235: FOR_IN
102236: IFFALSE 102279
// begin if IsInUnit ( j ) then
102238: LD_VAR 0 2
102242: PPUSH
102243: CALL_OW 310
102247: IFFALSE 102258
// ComExit ( j ) ;
102249: LD_VAR 0 2
102253: PPUSH
102254: CALL 52663 0 1
// AddComCollect ( j , x , y ) ;
102258: LD_VAR 0 2
102262: PPUSH
102263: LD_VAR 0 6
102267: PPUSH
102268: LD_VAR 0 7
102272: PPUSH
102273: CALL_OW 177
// end ;
102277: GO 102235
102279: POP
102280: POP
// exit ;
102281: POP
102282: POP
102283: GO 102514
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
102285: LD_ADDR_VAR 0 4
102289: PUSH
102290: LD_INT 22
102292: PUSH
102293: LD_VAR 0 5
102297: PUSH
102298: EMPTY
102299: LIST
102300: LIST
102301: PUSH
102302: LD_INT 91
102304: PUSH
102305: LD_VAR 0 8
102309: PUSH
102310: LD_INT 8
102312: PUSH
102313: EMPTY
102314: LIST
102315: LIST
102316: LIST
102317: PUSH
102318: LD_INT 2
102320: PUSH
102321: LD_INT 34
102323: PUSH
102324: LD_INT 12
102326: PUSH
102327: EMPTY
102328: LIST
102329: LIST
102330: PUSH
102331: LD_INT 34
102333: PUSH
102334: LD_INT 51
102336: PUSH
102337: EMPTY
102338: LIST
102339: LIST
102340: PUSH
102341: LD_INT 34
102343: PUSH
102344: LD_INT 32
102346: PUSH
102347: EMPTY
102348: LIST
102349: LIST
102350: PUSH
102351: LD_INT 34
102353: PUSH
102354: LD_EXP 105
102358: PUSH
102359: EMPTY
102360: LIST
102361: LIST
102362: PUSH
102363: EMPTY
102364: LIST
102365: LIST
102366: LIST
102367: LIST
102368: LIST
102369: PUSH
102370: EMPTY
102371: LIST
102372: LIST
102373: LIST
102374: PPUSH
102375: CALL_OW 69
102379: ST_TO_ADDR
// if tmp then
102380: LD_VAR 0 4
102384: IFFALSE 102510
// begin for j in tmp do
102386: LD_ADDR_VAR 0 2
102390: PUSH
102391: LD_VAR 0 4
102395: PUSH
102396: FOR_IN
102397: IFFALSE 102508
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
102399: LD_VAR 0 2
102403: PPUSH
102404: CALL_OW 262
102408: PUSH
102409: LD_INT 3
102411: EQUAL
102412: PUSH
102413: LD_VAR 0 2
102417: PPUSH
102418: CALL_OW 261
102422: PUSH
102423: LD_INT 20
102425: GREATER
102426: OR
102427: PUSH
102428: LD_VAR 0 2
102432: PPUSH
102433: CALL_OW 314
102437: NOT
102438: AND
102439: PUSH
102440: LD_VAR 0 2
102444: PPUSH
102445: CALL_OW 263
102449: PUSH
102450: LD_INT 1
102452: NONEQUAL
102453: PUSH
102454: LD_VAR 0 2
102458: PPUSH
102459: CALL_OW 311
102463: OR
102464: AND
102465: IFFALSE 102506
// begin ComCollect ( j , x , y ) ;
102467: LD_VAR 0 2
102471: PPUSH
102472: LD_VAR 0 6
102476: PPUSH
102477: LD_VAR 0 7
102481: PPUSH
102482: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
102486: LD_VAR 0 2
102490: PPUSH
102491: LD_VAR 0 8
102495: PPUSH
102496: CALL_OW 172
// exit ;
102500: POP
102501: POP
102502: POP
102503: POP
102504: GO 102514
// end ;
102506: GO 102396
102508: POP
102509: POP
// end ; end ;
102510: GO 101883
102512: POP
102513: POP
// end ; end_of_file
102514: PPOPN 9
102516: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
102517: LD_INT 0
102519: PPUSH
102520: PPUSH
102521: PPUSH
102522: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
102523: LD_VAR 0 1
102527: PPUSH
102528: CALL_OW 264
102532: PUSH
102533: LD_EXP 108
102537: EQUAL
102538: IFFALSE 102610
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
102540: LD_INT 68
102542: PPUSH
102543: LD_VAR 0 1
102547: PPUSH
102548: CALL_OW 255
102552: PPUSH
102553: CALL_OW 321
102557: PUSH
102558: LD_INT 2
102560: EQUAL
102561: IFFALSE 102573
// eff := 70 else
102563: LD_ADDR_VAR 0 4
102567: PUSH
102568: LD_INT 70
102570: ST_TO_ADDR
102571: GO 102581
// eff := 30 ;
102573: LD_ADDR_VAR 0 4
102577: PUSH
102578: LD_INT 30
102580: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
102581: LD_VAR 0 1
102585: PPUSH
102586: CALL_OW 250
102590: PPUSH
102591: LD_VAR 0 1
102595: PPUSH
102596: CALL_OW 251
102600: PPUSH
102601: LD_VAR 0 4
102605: PPUSH
102606: CALL_OW 495
// end ; end ;
102610: LD_VAR 0 2
102614: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
102615: LD_INT 0
102617: PPUSH
// end ;
102618: LD_VAR 0 4
102622: RET
// export function SOS_Command ( cmd ) ; begin
102623: LD_INT 0
102625: PPUSH
// end ;
102626: LD_VAR 0 2
102630: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
102631: LD_INT 0
102633: PPUSH
// end ;
102634: LD_VAR 0 6
102638: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
102639: LD_INT 0
102641: PPUSH
102642: PPUSH
// if not vehicle or not factory then
102643: LD_VAR 0 1
102647: NOT
102648: PUSH
102649: LD_VAR 0 2
102653: NOT
102654: OR
102655: IFFALSE 102659
// exit ;
102657: GO 102890
// if factoryWaypoints >= factory then
102659: LD_EXP 180
102663: PUSH
102664: LD_VAR 0 2
102668: GREATEREQUAL
102669: IFFALSE 102890
// if factoryWaypoints [ factory ] then
102671: LD_EXP 180
102675: PUSH
102676: LD_VAR 0 2
102680: ARRAY
102681: IFFALSE 102890
// begin if GetControl ( vehicle ) = control_manual then
102683: LD_VAR 0 1
102687: PPUSH
102688: CALL_OW 263
102692: PUSH
102693: LD_INT 1
102695: EQUAL
102696: IFFALSE 102777
// begin driver := IsDrivenBy ( vehicle ) ;
102698: LD_ADDR_VAR 0 4
102702: PUSH
102703: LD_VAR 0 1
102707: PPUSH
102708: CALL_OW 311
102712: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102713: LD_VAR 0 4
102717: PPUSH
102718: LD_EXP 180
102722: PUSH
102723: LD_VAR 0 2
102727: ARRAY
102728: PUSH
102729: LD_INT 3
102731: ARRAY
102732: PPUSH
102733: LD_EXP 180
102737: PUSH
102738: LD_VAR 0 2
102742: ARRAY
102743: PUSH
102744: LD_INT 4
102746: ARRAY
102747: PPUSH
102748: CALL_OW 171
// AddComExitVehicle ( driver ) ;
102752: LD_VAR 0 4
102756: PPUSH
102757: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
102761: LD_VAR 0 4
102765: PPUSH
102766: LD_VAR 0 2
102770: PPUSH
102771: CALL_OW 180
// end else
102775: GO 102890
// if GetControl ( vehicle ) = control_remote then
102777: LD_VAR 0 1
102781: PPUSH
102782: CALL_OW 263
102786: PUSH
102787: LD_INT 2
102789: EQUAL
102790: IFFALSE 102851
// begin wait ( 0 0$2 ) ;
102792: LD_INT 70
102794: PPUSH
102795: CALL_OW 67
// if Connect ( vehicle ) then
102799: LD_VAR 0 1
102803: PPUSH
102804: CALL 22974 0 1
102808: IFFALSE 102849
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102810: LD_VAR 0 1
102814: PPUSH
102815: LD_EXP 180
102819: PUSH
102820: LD_VAR 0 2
102824: ARRAY
102825: PUSH
102826: LD_INT 3
102828: ARRAY
102829: PPUSH
102830: LD_EXP 180
102834: PUSH
102835: LD_VAR 0 2
102839: ARRAY
102840: PUSH
102841: LD_INT 4
102843: ARRAY
102844: PPUSH
102845: CALL_OW 171
// end else
102849: GO 102890
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
102851: LD_VAR 0 1
102855: PPUSH
102856: LD_EXP 180
102860: PUSH
102861: LD_VAR 0 2
102865: ARRAY
102866: PUSH
102867: LD_INT 3
102869: ARRAY
102870: PPUSH
102871: LD_EXP 180
102875: PUSH
102876: LD_VAR 0 2
102880: ARRAY
102881: PUSH
102882: LD_INT 4
102884: ARRAY
102885: PPUSH
102886: CALL_OW 171
// end ; end ;
102890: LD_VAR 0 3
102894: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
102895: LD_INT 0
102897: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
102898: LD_VAR 0 1
102902: PUSH
102903: LD_INT 250
102905: EQUAL
102906: PUSH
102907: LD_VAR 0 2
102911: PPUSH
102912: CALL_OW 264
102916: PUSH
102917: LD_EXP 111
102921: EQUAL
102922: AND
102923: IFFALSE 102944
// MinerPlaceMine ( unit , x , y ) ;
102925: LD_VAR 0 2
102929: PPUSH
102930: LD_VAR 0 4
102934: PPUSH
102935: LD_VAR 0 5
102939: PPUSH
102940: CALL 105343 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
102944: LD_VAR 0 1
102948: PUSH
102949: LD_INT 251
102951: EQUAL
102952: PUSH
102953: LD_VAR 0 2
102957: PPUSH
102958: CALL_OW 264
102962: PUSH
102963: LD_EXP 111
102967: EQUAL
102968: AND
102969: IFFALSE 102990
// MinerDetonateMine ( unit , x , y ) ;
102971: LD_VAR 0 2
102975: PPUSH
102976: LD_VAR 0 4
102980: PPUSH
102981: LD_VAR 0 5
102985: PPUSH
102986: CALL 105620 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
102990: LD_VAR 0 1
102994: PUSH
102995: LD_INT 252
102997: EQUAL
102998: PUSH
102999: LD_VAR 0 2
103003: PPUSH
103004: CALL_OW 264
103008: PUSH
103009: LD_EXP 111
103013: EQUAL
103014: AND
103015: IFFALSE 103036
// MinerCreateMinefield ( unit , x , y ) ;
103017: LD_VAR 0 2
103021: PPUSH
103022: LD_VAR 0 4
103026: PPUSH
103027: LD_VAR 0 5
103031: PPUSH
103032: CALL 106037 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
103036: LD_VAR 0 1
103040: PUSH
103041: LD_INT 253
103043: EQUAL
103044: PUSH
103045: LD_VAR 0 2
103049: PPUSH
103050: CALL_OW 257
103054: PUSH
103055: LD_INT 5
103057: EQUAL
103058: AND
103059: IFFALSE 103080
// ComBinocular ( unit , x , y ) ;
103061: LD_VAR 0 2
103065: PPUSH
103066: LD_VAR 0 4
103070: PPUSH
103071: LD_VAR 0 5
103075: PPUSH
103076: CALL 106408 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
103080: LD_VAR 0 1
103084: PUSH
103085: LD_INT 254
103087: EQUAL
103088: PUSH
103089: LD_VAR 0 2
103093: PPUSH
103094: CALL_OW 264
103098: PUSH
103099: LD_EXP 106
103103: EQUAL
103104: AND
103105: PUSH
103106: LD_VAR 0 3
103110: PPUSH
103111: CALL_OW 263
103115: PUSH
103116: LD_INT 3
103118: EQUAL
103119: AND
103120: IFFALSE 103136
// HackDestroyVehicle ( unit , selectedUnit ) ;
103122: LD_VAR 0 2
103126: PPUSH
103127: LD_VAR 0 3
103131: PPUSH
103132: CALL 104703 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
103136: LD_VAR 0 1
103140: PUSH
103141: LD_INT 255
103143: EQUAL
103144: PUSH
103145: LD_VAR 0 2
103149: PPUSH
103150: CALL_OW 264
103154: PUSH
103155: LD_INT 14
103157: PUSH
103158: LD_INT 53
103160: PUSH
103161: EMPTY
103162: LIST
103163: LIST
103164: IN
103165: AND
103166: PUSH
103167: LD_VAR 0 4
103171: PPUSH
103172: LD_VAR 0 5
103176: PPUSH
103177: CALL_OW 488
103181: AND
103182: IFFALSE 103206
// CutTreeXYR ( unit , x , y , 12 ) ;
103184: LD_VAR 0 2
103188: PPUSH
103189: LD_VAR 0 4
103193: PPUSH
103194: LD_VAR 0 5
103198: PPUSH
103199: LD_INT 12
103201: PPUSH
103202: CALL 103269 0 4
// if cmd = 256 then
103206: LD_VAR 0 1
103210: PUSH
103211: LD_INT 256
103213: EQUAL
103214: IFFALSE 103235
// SetFactoryWaypoint ( unit , x , y ) ;
103216: LD_VAR 0 2
103220: PPUSH
103221: LD_VAR 0 4
103225: PPUSH
103226: LD_VAR 0 5
103230: PPUSH
103231: CALL 101204 0 3
// if cmd = 257 then
103235: LD_VAR 0 1
103239: PUSH
103240: LD_INT 257
103242: EQUAL
103243: IFFALSE 103264
// SetWarehouseGatheringPoint ( unit , x , y ) ;
103245: LD_VAR 0 2
103249: PPUSH
103250: LD_VAR 0 4
103254: PPUSH
103255: LD_VAR 0 5
103259: PPUSH
103260: CALL 101566 0 3
// end ;
103264: LD_VAR 0 6
103268: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
103269: LD_INT 0
103271: PPUSH
103272: PPUSH
103273: PPUSH
103274: PPUSH
103275: PPUSH
103276: PPUSH
103277: PPUSH
103278: PPUSH
103279: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
103280: LD_VAR 0 1
103284: NOT
103285: PUSH
103286: LD_VAR 0 2
103290: PPUSH
103291: LD_VAR 0 3
103295: PPUSH
103296: CALL_OW 488
103300: NOT
103301: OR
103302: PUSH
103303: LD_VAR 0 4
103307: NOT
103308: OR
103309: IFFALSE 103313
// exit ;
103311: GO 103653
// list := [ ] ;
103313: LD_ADDR_VAR 0 13
103317: PUSH
103318: EMPTY
103319: ST_TO_ADDR
// if x - r < 0 then
103320: LD_VAR 0 2
103324: PUSH
103325: LD_VAR 0 4
103329: MINUS
103330: PUSH
103331: LD_INT 0
103333: LESS
103334: IFFALSE 103346
// min_x := 0 else
103336: LD_ADDR_VAR 0 7
103340: PUSH
103341: LD_INT 0
103343: ST_TO_ADDR
103344: GO 103362
// min_x := x - r ;
103346: LD_ADDR_VAR 0 7
103350: PUSH
103351: LD_VAR 0 2
103355: PUSH
103356: LD_VAR 0 4
103360: MINUS
103361: ST_TO_ADDR
// if y - r < 0 then
103362: LD_VAR 0 3
103366: PUSH
103367: LD_VAR 0 4
103371: MINUS
103372: PUSH
103373: LD_INT 0
103375: LESS
103376: IFFALSE 103388
// min_y := 0 else
103378: LD_ADDR_VAR 0 8
103382: PUSH
103383: LD_INT 0
103385: ST_TO_ADDR
103386: GO 103404
// min_y := y - r ;
103388: LD_ADDR_VAR 0 8
103392: PUSH
103393: LD_VAR 0 3
103397: PUSH
103398: LD_VAR 0 4
103402: MINUS
103403: ST_TO_ADDR
// max_x := x + r ;
103404: LD_ADDR_VAR 0 9
103408: PUSH
103409: LD_VAR 0 2
103413: PUSH
103414: LD_VAR 0 4
103418: PLUS
103419: ST_TO_ADDR
// max_y := y + r ;
103420: LD_ADDR_VAR 0 10
103424: PUSH
103425: LD_VAR 0 3
103429: PUSH
103430: LD_VAR 0 4
103434: PLUS
103435: ST_TO_ADDR
// for _x = min_x to max_x do
103436: LD_ADDR_VAR 0 11
103440: PUSH
103441: DOUBLE
103442: LD_VAR 0 7
103446: DEC
103447: ST_TO_ADDR
103448: LD_VAR 0 9
103452: PUSH
103453: FOR_TO
103454: IFFALSE 103571
// for _y = min_y to max_y do
103456: LD_ADDR_VAR 0 12
103460: PUSH
103461: DOUBLE
103462: LD_VAR 0 8
103466: DEC
103467: ST_TO_ADDR
103468: LD_VAR 0 10
103472: PUSH
103473: FOR_TO
103474: IFFALSE 103567
// begin if not ValidHex ( _x , _y ) then
103476: LD_VAR 0 11
103480: PPUSH
103481: LD_VAR 0 12
103485: PPUSH
103486: CALL_OW 488
103490: NOT
103491: IFFALSE 103495
// continue ;
103493: GO 103473
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
103495: LD_VAR 0 11
103499: PPUSH
103500: LD_VAR 0 12
103504: PPUSH
103505: CALL_OW 351
103509: PUSH
103510: LD_VAR 0 11
103514: PPUSH
103515: LD_VAR 0 12
103519: PPUSH
103520: CALL_OW 554
103524: AND
103525: IFFALSE 103565
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
103527: LD_ADDR_VAR 0 13
103531: PUSH
103532: LD_VAR 0 13
103536: PPUSH
103537: LD_VAR 0 13
103541: PUSH
103542: LD_INT 1
103544: PLUS
103545: PPUSH
103546: LD_VAR 0 11
103550: PUSH
103551: LD_VAR 0 12
103555: PUSH
103556: EMPTY
103557: LIST
103558: LIST
103559: PPUSH
103560: CALL_OW 2
103564: ST_TO_ADDR
// end ;
103565: GO 103473
103567: POP
103568: POP
103569: GO 103453
103571: POP
103572: POP
// if not list then
103573: LD_VAR 0 13
103577: NOT
103578: IFFALSE 103582
// exit ;
103580: GO 103653
// for i in list do
103582: LD_ADDR_VAR 0 6
103586: PUSH
103587: LD_VAR 0 13
103591: PUSH
103592: FOR_IN
103593: IFFALSE 103651
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
103595: LD_VAR 0 1
103599: PPUSH
103600: LD_STRING M
103602: PUSH
103603: LD_VAR 0 6
103607: PUSH
103608: LD_INT 1
103610: ARRAY
103611: PUSH
103612: LD_VAR 0 6
103616: PUSH
103617: LD_INT 2
103619: ARRAY
103620: PUSH
103621: LD_INT 0
103623: PUSH
103624: LD_INT 0
103626: PUSH
103627: LD_INT 0
103629: PUSH
103630: LD_INT 0
103632: PUSH
103633: EMPTY
103634: LIST
103635: LIST
103636: LIST
103637: LIST
103638: LIST
103639: LIST
103640: LIST
103641: PUSH
103642: EMPTY
103643: LIST
103644: PPUSH
103645: CALL_OW 447
103649: GO 103592
103651: POP
103652: POP
// end ;
103653: LD_VAR 0 5
103657: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
103658: LD_EXP 183
103662: NOT
103663: IFFALSE 103713
103665: GO 103667
103667: DISABLE
// begin initHack := true ;
103668: LD_ADDR_EXP 183
103672: PUSH
103673: LD_INT 1
103675: ST_TO_ADDR
// hackTanks := [ ] ;
103676: LD_ADDR_EXP 184
103680: PUSH
103681: EMPTY
103682: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
103683: LD_ADDR_EXP 185
103687: PUSH
103688: EMPTY
103689: ST_TO_ADDR
// hackLimit := 3 ;
103690: LD_ADDR_EXP 186
103694: PUSH
103695: LD_INT 3
103697: ST_TO_ADDR
// hackDist := 12 ;
103698: LD_ADDR_EXP 187
103702: PUSH
103703: LD_INT 12
103705: ST_TO_ADDR
// hackCounter := [ ] ;
103706: LD_ADDR_EXP 188
103710: PUSH
103711: EMPTY
103712: ST_TO_ADDR
// end ;
103713: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
103714: LD_EXP 183
103718: PUSH
103719: LD_INT 34
103721: PUSH
103722: LD_EXP 106
103726: PUSH
103727: EMPTY
103728: LIST
103729: LIST
103730: PPUSH
103731: CALL_OW 69
103735: AND
103736: IFFALSE 103991
103738: GO 103740
103740: DISABLE
103741: LD_INT 0
103743: PPUSH
103744: PPUSH
// begin enable ;
103745: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
103746: LD_ADDR_VAR 0 1
103750: PUSH
103751: LD_INT 34
103753: PUSH
103754: LD_EXP 106
103758: PUSH
103759: EMPTY
103760: LIST
103761: LIST
103762: PPUSH
103763: CALL_OW 69
103767: PUSH
103768: FOR_IN
103769: IFFALSE 103989
// begin if not i in hackTanks then
103771: LD_VAR 0 1
103775: PUSH
103776: LD_EXP 184
103780: IN
103781: NOT
103782: IFFALSE 103865
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
103784: LD_ADDR_EXP 184
103788: PUSH
103789: LD_EXP 184
103793: PPUSH
103794: LD_EXP 184
103798: PUSH
103799: LD_INT 1
103801: PLUS
103802: PPUSH
103803: LD_VAR 0 1
103807: PPUSH
103808: CALL_OW 1
103812: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
103813: LD_ADDR_EXP 185
103817: PUSH
103818: LD_EXP 185
103822: PPUSH
103823: LD_EXP 185
103827: PUSH
103828: LD_INT 1
103830: PLUS
103831: PPUSH
103832: EMPTY
103833: PPUSH
103834: CALL_OW 1
103838: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
103839: LD_ADDR_EXP 188
103843: PUSH
103844: LD_EXP 188
103848: PPUSH
103849: LD_EXP 188
103853: PUSH
103854: LD_INT 1
103856: PLUS
103857: PPUSH
103858: EMPTY
103859: PPUSH
103860: CALL_OW 1
103864: ST_TO_ADDR
// end ; if not IsOk ( i ) then
103865: LD_VAR 0 1
103869: PPUSH
103870: CALL_OW 302
103874: NOT
103875: IFFALSE 103888
// begin HackUnlinkAll ( i ) ;
103877: LD_VAR 0 1
103881: PPUSH
103882: CALL 103994 0 1
// continue ;
103886: GO 103768
// end ; HackCheckCapturedStatus ( i ) ;
103888: LD_VAR 0 1
103892: PPUSH
103893: CALL 104437 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
103897: LD_ADDR_VAR 0 2
103901: PUSH
103902: LD_INT 81
103904: PUSH
103905: LD_VAR 0 1
103909: PPUSH
103910: CALL_OW 255
103914: PUSH
103915: EMPTY
103916: LIST
103917: LIST
103918: PUSH
103919: LD_INT 33
103921: PUSH
103922: LD_INT 3
103924: PUSH
103925: EMPTY
103926: LIST
103927: LIST
103928: PUSH
103929: LD_INT 91
103931: PUSH
103932: LD_VAR 0 1
103936: PUSH
103937: LD_EXP 187
103941: PUSH
103942: EMPTY
103943: LIST
103944: LIST
103945: LIST
103946: PUSH
103947: LD_INT 50
103949: PUSH
103950: EMPTY
103951: LIST
103952: PUSH
103953: EMPTY
103954: LIST
103955: LIST
103956: LIST
103957: LIST
103958: PPUSH
103959: CALL_OW 69
103963: ST_TO_ADDR
// if not tmp then
103964: LD_VAR 0 2
103968: NOT
103969: IFFALSE 103973
// continue ;
103971: GO 103768
// HackLink ( i , tmp ) ;
103973: LD_VAR 0 1
103977: PPUSH
103978: LD_VAR 0 2
103982: PPUSH
103983: CALL 104130 0 2
// end ;
103987: GO 103768
103989: POP
103990: POP
// end ;
103991: PPOPN 2
103993: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
103994: LD_INT 0
103996: PPUSH
103997: PPUSH
103998: PPUSH
// if not hack in hackTanks then
103999: LD_VAR 0 1
104003: PUSH
104004: LD_EXP 184
104008: IN
104009: NOT
104010: IFFALSE 104014
// exit ;
104012: GO 104125
// index := GetElementIndex ( hackTanks , hack ) ;
104014: LD_ADDR_VAR 0 4
104018: PUSH
104019: LD_EXP 184
104023: PPUSH
104024: LD_VAR 0 1
104028: PPUSH
104029: CALL 19788 0 2
104033: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
104034: LD_EXP 185
104038: PUSH
104039: LD_VAR 0 4
104043: ARRAY
104044: IFFALSE 104125
// begin for i in hackTanksCaptured [ index ] do
104046: LD_ADDR_VAR 0 3
104050: PUSH
104051: LD_EXP 185
104055: PUSH
104056: LD_VAR 0 4
104060: ARRAY
104061: PUSH
104062: FOR_IN
104063: IFFALSE 104089
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
104065: LD_VAR 0 3
104069: PUSH
104070: LD_INT 1
104072: ARRAY
104073: PPUSH
104074: LD_VAR 0 3
104078: PUSH
104079: LD_INT 2
104081: ARRAY
104082: PPUSH
104083: CALL_OW 235
104087: GO 104062
104089: POP
104090: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
104091: LD_ADDR_EXP 185
104095: PUSH
104096: LD_EXP 185
104100: PPUSH
104101: LD_VAR 0 4
104105: PPUSH
104106: EMPTY
104107: PPUSH
104108: CALL_OW 1
104112: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
104113: LD_VAR 0 1
104117: PPUSH
104118: LD_INT 0
104120: PPUSH
104121: CALL_OW 505
// end ; end ;
104125: LD_VAR 0 2
104129: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
104130: LD_INT 0
104132: PPUSH
104133: PPUSH
104134: PPUSH
// if not hack in hackTanks or not vehicles then
104135: LD_VAR 0 1
104139: PUSH
104140: LD_EXP 184
104144: IN
104145: NOT
104146: PUSH
104147: LD_VAR 0 2
104151: NOT
104152: OR
104153: IFFALSE 104157
// exit ;
104155: GO 104432
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
104157: LD_ADDR_VAR 0 2
104161: PUSH
104162: LD_VAR 0 1
104166: PPUSH
104167: LD_VAR 0 2
104171: PPUSH
104172: LD_INT 1
104174: PPUSH
104175: LD_INT 1
104177: PPUSH
104178: CALL 20438 0 4
104182: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
104183: LD_ADDR_VAR 0 5
104187: PUSH
104188: LD_EXP 184
104192: PPUSH
104193: LD_VAR 0 1
104197: PPUSH
104198: CALL 19788 0 2
104202: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
104203: LD_EXP 185
104207: PUSH
104208: LD_VAR 0 5
104212: ARRAY
104213: PUSH
104214: LD_EXP 186
104218: LESS
104219: IFFALSE 104408
// begin for i := 1 to vehicles do
104221: LD_ADDR_VAR 0 4
104225: PUSH
104226: DOUBLE
104227: LD_INT 1
104229: DEC
104230: ST_TO_ADDR
104231: LD_VAR 0 2
104235: PUSH
104236: FOR_TO
104237: IFFALSE 104406
// begin if hackTanksCaptured [ index ] = hackLimit then
104239: LD_EXP 185
104243: PUSH
104244: LD_VAR 0 5
104248: ARRAY
104249: PUSH
104250: LD_EXP 186
104254: EQUAL
104255: IFFALSE 104259
// break ;
104257: GO 104406
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
104259: LD_ADDR_EXP 188
104263: PUSH
104264: LD_EXP 188
104268: PPUSH
104269: LD_VAR 0 5
104273: PPUSH
104274: LD_EXP 188
104278: PUSH
104279: LD_VAR 0 5
104283: ARRAY
104284: PUSH
104285: LD_INT 1
104287: PLUS
104288: PPUSH
104289: CALL_OW 1
104293: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
104294: LD_ADDR_EXP 185
104298: PUSH
104299: LD_EXP 185
104303: PPUSH
104304: LD_VAR 0 5
104308: PUSH
104309: LD_EXP 185
104313: PUSH
104314: LD_VAR 0 5
104318: ARRAY
104319: PUSH
104320: LD_INT 1
104322: PLUS
104323: PUSH
104324: EMPTY
104325: LIST
104326: LIST
104327: PPUSH
104328: LD_VAR 0 2
104332: PUSH
104333: LD_VAR 0 4
104337: ARRAY
104338: PUSH
104339: LD_VAR 0 2
104343: PUSH
104344: LD_VAR 0 4
104348: ARRAY
104349: PPUSH
104350: CALL_OW 255
104354: PUSH
104355: EMPTY
104356: LIST
104357: LIST
104358: PPUSH
104359: CALL 20003 0 3
104363: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
104364: LD_VAR 0 2
104368: PUSH
104369: LD_VAR 0 4
104373: ARRAY
104374: PPUSH
104375: LD_VAR 0 1
104379: PPUSH
104380: CALL_OW 255
104384: PPUSH
104385: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
104389: LD_VAR 0 2
104393: PUSH
104394: LD_VAR 0 4
104398: ARRAY
104399: PPUSH
104400: CALL_OW 141
// end ;
104404: GO 104236
104406: POP
104407: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104408: LD_VAR 0 1
104412: PPUSH
104413: LD_EXP 185
104417: PUSH
104418: LD_VAR 0 5
104422: ARRAY
104423: PUSH
104424: LD_INT 0
104426: PLUS
104427: PPUSH
104428: CALL_OW 505
// end ;
104432: LD_VAR 0 3
104436: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
104437: LD_INT 0
104439: PPUSH
104440: PPUSH
104441: PPUSH
104442: PPUSH
// if not hack in hackTanks then
104443: LD_VAR 0 1
104447: PUSH
104448: LD_EXP 184
104452: IN
104453: NOT
104454: IFFALSE 104458
// exit ;
104456: GO 104698
// index := GetElementIndex ( hackTanks , hack ) ;
104458: LD_ADDR_VAR 0 4
104462: PUSH
104463: LD_EXP 184
104467: PPUSH
104468: LD_VAR 0 1
104472: PPUSH
104473: CALL 19788 0 2
104477: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
104478: LD_ADDR_VAR 0 3
104482: PUSH
104483: DOUBLE
104484: LD_EXP 185
104488: PUSH
104489: LD_VAR 0 4
104493: ARRAY
104494: INC
104495: ST_TO_ADDR
104496: LD_INT 1
104498: PUSH
104499: FOR_DOWNTO
104500: IFFALSE 104672
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
104502: LD_ADDR_VAR 0 5
104506: PUSH
104507: LD_EXP 185
104511: PUSH
104512: LD_VAR 0 4
104516: ARRAY
104517: PUSH
104518: LD_VAR 0 3
104522: ARRAY
104523: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
104524: LD_VAR 0 5
104528: PUSH
104529: LD_INT 1
104531: ARRAY
104532: PPUSH
104533: CALL_OW 302
104537: NOT
104538: PUSH
104539: LD_VAR 0 5
104543: PUSH
104544: LD_INT 1
104546: ARRAY
104547: PPUSH
104548: CALL_OW 255
104552: PUSH
104553: LD_VAR 0 1
104557: PPUSH
104558: CALL_OW 255
104562: NONEQUAL
104563: OR
104564: IFFALSE 104670
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
104566: LD_VAR 0 5
104570: PUSH
104571: LD_INT 1
104573: ARRAY
104574: PPUSH
104575: CALL_OW 305
104579: PUSH
104580: LD_VAR 0 5
104584: PUSH
104585: LD_INT 1
104587: ARRAY
104588: PPUSH
104589: CALL_OW 255
104593: PUSH
104594: LD_VAR 0 1
104598: PPUSH
104599: CALL_OW 255
104603: EQUAL
104604: AND
104605: IFFALSE 104629
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
104607: LD_VAR 0 5
104611: PUSH
104612: LD_INT 1
104614: ARRAY
104615: PPUSH
104616: LD_VAR 0 5
104620: PUSH
104621: LD_INT 2
104623: ARRAY
104624: PPUSH
104625: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
104629: LD_ADDR_EXP 185
104633: PUSH
104634: LD_EXP 185
104638: PPUSH
104639: LD_VAR 0 4
104643: PPUSH
104644: LD_EXP 185
104648: PUSH
104649: LD_VAR 0 4
104653: ARRAY
104654: PPUSH
104655: LD_VAR 0 3
104659: PPUSH
104660: CALL_OW 3
104664: PPUSH
104665: CALL_OW 1
104669: ST_TO_ADDR
// end ; end ;
104670: GO 104499
104672: POP
104673: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
104674: LD_VAR 0 1
104678: PPUSH
104679: LD_EXP 185
104683: PUSH
104684: LD_VAR 0 4
104688: ARRAY
104689: PUSH
104690: LD_INT 0
104692: PLUS
104693: PPUSH
104694: CALL_OW 505
// end ;
104698: LD_VAR 0 2
104702: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
104703: LD_INT 0
104705: PPUSH
104706: PPUSH
104707: PPUSH
104708: PPUSH
// if not hack in hackTanks then
104709: LD_VAR 0 1
104713: PUSH
104714: LD_EXP 184
104718: IN
104719: NOT
104720: IFFALSE 104724
// exit ;
104722: GO 104809
// index := GetElementIndex ( hackTanks , hack ) ;
104724: LD_ADDR_VAR 0 5
104728: PUSH
104729: LD_EXP 184
104733: PPUSH
104734: LD_VAR 0 1
104738: PPUSH
104739: CALL 19788 0 2
104743: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
104744: LD_ADDR_VAR 0 4
104748: PUSH
104749: DOUBLE
104750: LD_INT 1
104752: DEC
104753: ST_TO_ADDR
104754: LD_EXP 185
104758: PUSH
104759: LD_VAR 0 5
104763: ARRAY
104764: PUSH
104765: FOR_TO
104766: IFFALSE 104807
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
104768: LD_EXP 185
104772: PUSH
104773: LD_VAR 0 5
104777: ARRAY
104778: PUSH
104779: LD_VAR 0 4
104783: ARRAY
104784: PUSH
104785: LD_INT 1
104787: ARRAY
104788: PUSH
104789: LD_VAR 0 2
104793: EQUAL
104794: IFFALSE 104805
// KillUnit ( vehicle ) ;
104796: LD_VAR 0 2
104800: PPUSH
104801: CALL_OW 66
104805: GO 104765
104807: POP
104808: POP
// end ;
104809: LD_VAR 0 3
104813: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
104814: LD_EXP 189
104818: NOT
104819: IFFALSE 104854
104821: GO 104823
104823: DISABLE
// begin initMiner := true ;
104824: LD_ADDR_EXP 189
104828: PUSH
104829: LD_INT 1
104831: ST_TO_ADDR
// minersList := [ ] ;
104832: LD_ADDR_EXP 190
104836: PUSH
104837: EMPTY
104838: ST_TO_ADDR
// minerMinesList := [ ] ;
104839: LD_ADDR_EXP 191
104843: PUSH
104844: EMPTY
104845: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
104846: LD_ADDR_EXP 192
104850: PUSH
104851: LD_INT 5
104853: ST_TO_ADDR
// end ;
104854: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
104855: LD_EXP 189
104859: PUSH
104860: LD_INT 34
104862: PUSH
104863: LD_EXP 111
104867: PUSH
104868: EMPTY
104869: LIST
104870: LIST
104871: PPUSH
104872: CALL_OW 69
104876: AND
104877: IFFALSE 105340
104879: GO 104881
104881: DISABLE
104882: LD_INT 0
104884: PPUSH
104885: PPUSH
104886: PPUSH
104887: PPUSH
// begin enable ;
104888: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
104889: LD_ADDR_VAR 0 1
104893: PUSH
104894: LD_INT 34
104896: PUSH
104897: LD_EXP 111
104901: PUSH
104902: EMPTY
104903: LIST
104904: LIST
104905: PPUSH
104906: CALL_OW 69
104910: PUSH
104911: FOR_IN
104912: IFFALSE 104984
// begin if not i in minersList then
104914: LD_VAR 0 1
104918: PUSH
104919: LD_EXP 190
104923: IN
104924: NOT
104925: IFFALSE 104982
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
104927: LD_ADDR_EXP 190
104931: PUSH
104932: LD_EXP 190
104936: PPUSH
104937: LD_EXP 190
104941: PUSH
104942: LD_INT 1
104944: PLUS
104945: PPUSH
104946: LD_VAR 0 1
104950: PPUSH
104951: CALL_OW 1
104955: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
104956: LD_ADDR_EXP 191
104960: PUSH
104961: LD_EXP 191
104965: PPUSH
104966: LD_EXP 191
104970: PUSH
104971: LD_INT 1
104973: PLUS
104974: PPUSH
104975: EMPTY
104976: PPUSH
104977: CALL_OW 1
104981: ST_TO_ADDR
// end end ;
104982: GO 104911
104984: POP
104985: POP
// for i := minerMinesList downto 1 do
104986: LD_ADDR_VAR 0 1
104990: PUSH
104991: DOUBLE
104992: LD_EXP 191
104996: INC
104997: ST_TO_ADDR
104998: LD_INT 1
105000: PUSH
105001: FOR_DOWNTO
105002: IFFALSE 105338
// begin if IsLive ( minersList [ i ] ) then
105004: LD_EXP 190
105008: PUSH
105009: LD_VAR 0 1
105013: ARRAY
105014: PPUSH
105015: CALL_OW 300
105019: IFFALSE 105047
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
105021: LD_EXP 190
105025: PUSH
105026: LD_VAR 0 1
105030: ARRAY
105031: PPUSH
105032: LD_EXP 191
105036: PUSH
105037: LD_VAR 0 1
105041: ARRAY
105042: PPUSH
105043: CALL_OW 505
// if not minerMinesList [ i ] then
105047: LD_EXP 191
105051: PUSH
105052: LD_VAR 0 1
105056: ARRAY
105057: NOT
105058: IFFALSE 105062
// continue ;
105060: GO 105001
// for j := minerMinesList [ i ] downto 1 do
105062: LD_ADDR_VAR 0 2
105066: PUSH
105067: DOUBLE
105068: LD_EXP 191
105072: PUSH
105073: LD_VAR 0 1
105077: ARRAY
105078: INC
105079: ST_TO_ADDR
105080: LD_INT 1
105082: PUSH
105083: FOR_DOWNTO
105084: IFFALSE 105334
// begin side := GetSide ( minersList [ i ] ) ;
105086: LD_ADDR_VAR 0 3
105090: PUSH
105091: LD_EXP 190
105095: PUSH
105096: LD_VAR 0 1
105100: ARRAY
105101: PPUSH
105102: CALL_OW 255
105106: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
105107: LD_ADDR_VAR 0 4
105111: PUSH
105112: LD_EXP 191
105116: PUSH
105117: LD_VAR 0 1
105121: ARRAY
105122: PUSH
105123: LD_VAR 0 2
105127: ARRAY
105128: PUSH
105129: LD_INT 1
105131: ARRAY
105132: PPUSH
105133: LD_EXP 191
105137: PUSH
105138: LD_VAR 0 1
105142: ARRAY
105143: PUSH
105144: LD_VAR 0 2
105148: ARRAY
105149: PUSH
105150: LD_INT 2
105152: ARRAY
105153: PPUSH
105154: CALL_OW 428
105158: ST_TO_ADDR
// if not tmp then
105159: LD_VAR 0 4
105163: NOT
105164: IFFALSE 105168
// continue ;
105166: GO 105083
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
105168: LD_VAR 0 4
105172: PUSH
105173: LD_INT 81
105175: PUSH
105176: LD_VAR 0 3
105180: PUSH
105181: EMPTY
105182: LIST
105183: LIST
105184: PPUSH
105185: CALL_OW 69
105189: IN
105190: PUSH
105191: LD_EXP 191
105195: PUSH
105196: LD_VAR 0 1
105200: ARRAY
105201: PUSH
105202: LD_VAR 0 2
105206: ARRAY
105207: PUSH
105208: LD_INT 1
105210: ARRAY
105211: PPUSH
105212: LD_EXP 191
105216: PUSH
105217: LD_VAR 0 1
105221: ARRAY
105222: PUSH
105223: LD_VAR 0 2
105227: ARRAY
105228: PUSH
105229: LD_INT 2
105231: ARRAY
105232: PPUSH
105233: CALL_OW 458
105237: AND
105238: IFFALSE 105332
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
105240: LD_EXP 191
105244: PUSH
105245: LD_VAR 0 1
105249: ARRAY
105250: PUSH
105251: LD_VAR 0 2
105255: ARRAY
105256: PUSH
105257: LD_INT 1
105259: ARRAY
105260: PPUSH
105261: LD_EXP 191
105265: PUSH
105266: LD_VAR 0 1
105270: ARRAY
105271: PUSH
105272: LD_VAR 0 2
105276: ARRAY
105277: PUSH
105278: LD_INT 2
105280: ARRAY
105281: PPUSH
105282: LD_VAR 0 3
105286: PPUSH
105287: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
105291: LD_ADDR_EXP 191
105295: PUSH
105296: LD_EXP 191
105300: PPUSH
105301: LD_VAR 0 1
105305: PPUSH
105306: LD_EXP 191
105310: PUSH
105311: LD_VAR 0 1
105315: ARRAY
105316: PPUSH
105317: LD_VAR 0 2
105321: PPUSH
105322: CALL_OW 3
105326: PPUSH
105327: CALL_OW 1
105331: ST_TO_ADDR
// end ; end ;
105332: GO 105083
105334: POP
105335: POP
// end ;
105336: GO 105001
105338: POP
105339: POP
// end ;
105340: PPOPN 4
105342: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
105343: LD_INT 0
105345: PPUSH
105346: PPUSH
// result := false ;
105347: LD_ADDR_VAR 0 4
105351: PUSH
105352: LD_INT 0
105354: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
105355: LD_VAR 0 1
105359: PPUSH
105360: CALL_OW 264
105364: PUSH
105365: LD_EXP 111
105369: EQUAL
105370: NOT
105371: IFFALSE 105375
// exit ;
105373: GO 105615
// index := GetElementIndex ( minersList , unit ) ;
105375: LD_ADDR_VAR 0 5
105379: PUSH
105380: LD_EXP 190
105384: PPUSH
105385: LD_VAR 0 1
105389: PPUSH
105390: CALL 19788 0 2
105394: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
105395: LD_EXP 191
105399: PUSH
105400: LD_VAR 0 5
105404: ARRAY
105405: PUSH
105406: LD_EXP 192
105410: GREATEREQUAL
105411: IFFALSE 105415
// exit ;
105413: GO 105615
// ComMoveXY ( unit , x , y ) ;
105415: LD_VAR 0 1
105419: PPUSH
105420: LD_VAR 0 2
105424: PPUSH
105425: LD_VAR 0 3
105429: PPUSH
105430: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
105434: LD_INT 35
105436: PPUSH
105437: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
105441: LD_VAR 0 1
105445: PPUSH
105446: LD_VAR 0 2
105450: PPUSH
105451: LD_VAR 0 3
105455: PPUSH
105456: CALL 51074 0 3
105460: NOT
105461: PUSH
105462: LD_VAR 0 1
105466: PPUSH
105467: CALL_OW 314
105471: AND
105472: IFFALSE 105476
// exit ;
105474: GO 105615
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
105476: LD_VAR 0 2
105480: PPUSH
105481: LD_VAR 0 3
105485: PPUSH
105486: CALL_OW 428
105490: PUSH
105491: LD_VAR 0 1
105495: EQUAL
105496: PUSH
105497: LD_VAR 0 1
105501: PPUSH
105502: CALL_OW 314
105506: NOT
105507: AND
105508: IFFALSE 105434
// PlaySoundXY ( x , y , PlantMine ) ;
105510: LD_VAR 0 2
105514: PPUSH
105515: LD_VAR 0 3
105519: PPUSH
105520: LD_STRING PlantMine
105522: PPUSH
105523: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
105527: LD_VAR 0 2
105531: PPUSH
105532: LD_VAR 0 3
105536: PPUSH
105537: LD_VAR 0 1
105541: PPUSH
105542: CALL_OW 255
105546: PPUSH
105547: LD_INT 0
105549: PPUSH
105550: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
105554: LD_ADDR_EXP 191
105558: PUSH
105559: LD_EXP 191
105563: PPUSH
105564: LD_VAR 0 5
105568: PUSH
105569: LD_EXP 191
105573: PUSH
105574: LD_VAR 0 5
105578: ARRAY
105579: PUSH
105580: LD_INT 1
105582: PLUS
105583: PUSH
105584: EMPTY
105585: LIST
105586: LIST
105587: PPUSH
105588: LD_VAR 0 2
105592: PUSH
105593: LD_VAR 0 3
105597: PUSH
105598: EMPTY
105599: LIST
105600: LIST
105601: PPUSH
105602: CALL 20003 0 3
105606: ST_TO_ADDR
// result := true ;
105607: LD_ADDR_VAR 0 4
105611: PUSH
105612: LD_INT 1
105614: ST_TO_ADDR
// end ;
105615: LD_VAR 0 4
105619: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
105620: LD_INT 0
105622: PPUSH
105623: PPUSH
105624: PPUSH
// if not unit in minersList then
105625: LD_VAR 0 1
105629: PUSH
105630: LD_EXP 190
105634: IN
105635: NOT
105636: IFFALSE 105640
// exit ;
105638: GO 106032
// index := GetElementIndex ( minersList , unit ) ;
105640: LD_ADDR_VAR 0 6
105644: PUSH
105645: LD_EXP 190
105649: PPUSH
105650: LD_VAR 0 1
105654: PPUSH
105655: CALL 19788 0 2
105659: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
105660: LD_ADDR_VAR 0 5
105664: PUSH
105665: DOUBLE
105666: LD_EXP 191
105670: PUSH
105671: LD_VAR 0 6
105675: ARRAY
105676: INC
105677: ST_TO_ADDR
105678: LD_INT 1
105680: PUSH
105681: FOR_DOWNTO
105682: IFFALSE 105843
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
105684: LD_EXP 191
105688: PUSH
105689: LD_VAR 0 6
105693: ARRAY
105694: PUSH
105695: LD_VAR 0 5
105699: ARRAY
105700: PUSH
105701: LD_INT 1
105703: ARRAY
105704: PUSH
105705: LD_VAR 0 2
105709: EQUAL
105710: PUSH
105711: LD_EXP 191
105715: PUSH
105716: LD_VAR 0 6
105720: ARRAY
105721: PUSH
105722: LD_VAR 0 5
105726: ARRAY
105727: PUSH
105728: LD_INT 2
105730: ARRAY
105731: PUSH
105732: LD_VAR 0 3
105736: EQUAL
105737: AND
105738: IFFALSE 105841
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105740: LD_EXP 191
105744: PUSH
105745: LD_VAR 0 6
105749: ARRAY
105750: PUSH
105751: LD_VAR 0 5
105755: ARRAY
105756: PUSH
105757: LD_INT 1
105759: ARRAY
105760: PPUSH
105761: LD_EXP 191
105765: PUSH
105766: LD_VAR 0 6
105770: ARRAY
105771: PUSH
105772: LD_VAR 0 5
105776: ARRAY
105777: PUSH
105778: LD_INT 2
105780: ARRAY
105781: PPUSH
105782: LD_VAR 0 1
105786: PPUSH
105787: CALL_OW 255
105791: PPUSH
105792: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105796: LD_ADDR_EXP 191
105800: PUSH
105801: LD_EXP 191
105805: PPUSH
105806: LD_VAR 0 6
105810: PPUSH
105811: LD_EXP 191
105815: PUSH
105816: LD_VAR 0 6
105820: ARRAY
105821: PPUSH
105822: LD_VAR 0 5
105826: PPUSH
105827: CALL_OW 3
105831: PPUSH
105832: CALL_OW 1
105836: ST_TO_ADDR
// exit ;
105837: POP
105838: POP
105839: GO 106032
// end ; end ;
105841: GO 105681
105843: POP
105844: POP
// for i := minerMinesList [ index ] downto 1 do
105845: LD_ADDR_VAR 0 5
105849: PUSH
105850: DOUBLE
105851: LD_EXP 191
105855: PUSH
105856: LD_VAR 0 6
105860: ARRAY
105861: INC
105862: ST_TO_ADDR
105863: LD_INT 1
105865: PUSH
105866: FOR_DOWNTO
105867: IFFALSE 106030
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
105869: LD_EXP 191
105873: PUSH
105874: LD_VAR 0 6
105878: ARRAY
105879: PUSH
105880: LD_VAR 0 5
105884: ARRAY
105885: PUSH
105886: LD_INT 1
105888: ARRAY
105889: PPUSH
105890: LD_EXP 191
105894: PUSH
105895: LD_VAR 0 6
105899: ARRAY
105900: PUSH
105901: LD_VAR 0 5
105905: ARRAY
105906: PUSH
105907: LD_INT 2
105909: ARRAY
105910: PPUSH
105911: LD_VAR 0 2
105915: PPUSH
105916: LD_VAR 0 3
105920: PPUSH
105921: CALL_OW 298
105925: PUSH
105926: LD_INT 6
105928: LESS
105929: IFFALSE 106028
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
105931: LD_EXP 191
105935: PUSH
105936: LD_VAR 0 6
105940: ARRAY
105941: PUSH
105942: LD_VAR 0 5
105946: ARRAY
105947: PUSH
105948: LD_INT 1
105950: ARRAY
105951: PPUSH
105952: LD_EXP 191
105956: PUSH
105957: LD_VAR 0 6
105961: ARRAY
105962: PUSH
105963: LD_VAR 0 5
105967: ARRAY
105968: PUSH
105969: LD_INT 2
105971: ARRAY
105972: PPUSH
105973: LD_VAR 0 1
105977: PPUSH
105978: CALL_OW 255
105982: PPUSH
105983: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
105987: LD_ADDR_EXP 191
105991: PUSH
105992: LD_EXP 191
105996: PPUSH
105997: LD_VAR 0 6
106001: PPUSH
106002: LD_EXP 191
106006: PUSH
106007: LD_VAR 0 6
106011: ARRAY
106012: PPUSH
106013: LD_VAR 0 5
106017: PPUSH
106018: CALL_OW 3
106022: PPUSH
106023: CALL_OW 1
106027: ST_TO_ADDR
// end ; end ;
106028: GO 105866
106030: POP
106031: POP
// end ;
106032: LD_VAR 0 4
106036: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
106037: LD_INT 0
106039: PPUSH
106040: PPUSH
106041: PPUSH
106042: PPUSH
106043: PPUSH
106044: PPUSH
106045: PPUSH
106046: PPUSH
106047: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
106048: LD_VAR 0 1
106052: PPUSH
106053: CALL_OW 264
106057: PUSH
106058: LD_EXP 111
106062: EQUAL
106063: NOT
106064: PUSH
106065: LD_VAR 0 1
106069: PUSH
106070: LD_EXP 190
106074: IN
106075: NOT
106076: OR
106077: IFFALSE 106081
// exit ;
106079: GO 106403
// index := GetElementIndex ( minersList , unit ) ;
106081: LD_ADDR_VAR 0 6
106085: PUSH
106086: LD_EXP 190
106090: PPUSH
106091: LD_VAR 0 1
106095: PPUSH
106096: CALL 19788 0 2
106100: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
106101: LD_ADDR_VAR 0 8
106105: PUSH
106106: LD_EXP 192
106110: PUSH
106111: LD_EXP 191
106115: PUSH
106116: LD_VAR 0 6
106120: ARRAY
106121: MINUS
106122: ST_TO_ADDR
// if not minesFreeAmount then
106123: LD_VAR 0 8
106127: NOT
106128: IFFALSE 106132
// exit ;
106130: GO 106403
// tmp := [ ] ;
106132: LD_ADDR_VAR 0 7
106136: PUSH
106137: EMPTY
106138: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
106139: LD_ADDR_VAR 0 5
106143: PUSH
106144: DOUBLE
106145: LD_INT 1
106147: DEC
106148: ST_TO_ADDR
106149: LD_VAR 0 8
106153: PUSH
106154: FOR_TO
106155: IFFALSE 106350
// begin _d := rand ( 0 , 5 ) ;
106157: LD_ADDR_VAR 0 11
106161: PUSH
106162: LD_INT 0
106164: PPUSH
106165: LD_INT 5
106167: PPUSH
106168: CALL_OW 12
106172: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
106173: LD_ADDR_VAR 0 12
106177: PUSH
106178: LD_INT 2
106180: PPUSH
106181: LD_INT 6
106183: PPUSH
106184: CALL_OW 12
106188: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
106189: LD_ADDR_VAR 0 9
106193: PUSH
106194: LD_VAR 0 2
106198: PPUSH
106199: LD_VAR 0 11
106203: PPUSH
106204: LD_VAR 0 12
106208: PPUSH
106209: CALL_OW 272
106213: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
106214: LD_ADDR_VAR 0 10
106218: PUSH
106219: LD_VAR 0 3
106223: PPUSH
106224: LD_VAR 0 11
106228: PPUSH
106229: LD_VAR 0 12
106233: PPUSH
106234: CALL_OW 273
106238: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
106239: LD_VAR 0 9
106243: PPUSH
106244: LD_VAR 0 10
106248: PPUSH
106249: CALL_OW 488
106253: PUSH
106254: LD_VAR 0 9
106258: PUSH
106259: LD_VAR 0 10
106263: PUSH
106264: EMPTY
106265: LIST
106266: LIST
106267: PUSH
106268: LD_VAR 0 7
106272: IN
106273: NOT
106274: AND
106275: PUSH
106276: LD_VAR 0 9
106280: PPUSH
106281: LD_VAR 0 10
106285: PPUSH
106286: CALL_OW 458
106290: NOT
106291: AND
106292: IFFALSE 106334
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
106294: LD_ADDR_VAR 0 7
106298: PUSH
106299: LD_VAR 0 7
106303: PPUSH
106304: LD_VAR 0 7
106308: PUSH
106309: LD_INT 1
106311: PLUS
106312: PPUSH
106313: LD_VAR 0 9
106317: PUSH
106318: LD_VAR 0 10
106322: PUSH
106323: EMPTY
106324: LIST
106325: LIST
106326: PPUSH
106327: CALL_OW 1
106331: ST_TO_ADDR
106332: GO 106348
// i := i - 1 ;
106334: LD_ADDR_VAR 0 5
106338: PUSH
106339: LD_VAR 0 5
106343: PUSH
106344: LD_INT 1
106346: MINUS
106347: ST_TO_ADDR
// end ;
106348: GO 106154
106350: POP
106351: POP
// for i in tmp do
106352: LD_ADDR_VAR 0 5
106356: PUSH
106357: LD_VAR 0 7
106361: PUSH
106362: FOR_IN
106363: IFFALSE 106401
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
106365: LD_VAR 0 1
106369: PPUSH
106370: LD_VAR 0 5
106374: PUSH
106375: LD_INT 1
106377: ARRAY
106378: PPUSH
106379: LD_VAR 0 5
106383: PUSH
106384: LD_INT 2
106386: ARRAY
106387: PPUSH
106388: CALL 105343 0 3
106392: NOT
106393: IFFALSE 106399
// exit ;
106395: POP
106396: POP
106397: GO 106403
106399: GO 106362
106401: POP
106402: POP
// end ;
106403: LD_VAR 0 4
106407: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
106408: LD_INT 0
106410: PPUSH
106411: PPUSH
106412: PPUSH
106413: PPUSH
106414: PPUSH
106415: PPUSH
106416: PPUSH
// if not GetClass ( unit ) = class_sniper then
106417: LD_VAR 0 1
106421: PPUSH
106422: CALL_OW 257
106426: PUSH
106427: LD_INT 5
106429: EQUAL
106430: NOT
106431: IFFALSE 106435
// exit ;
106433: GO 106823
// dist := 8 ;
106435: LD_ADDR_VAR 0 5
106439: PUSH
106440: LD_INT 8
106442: ST_TO_ADDR
// viewRange := 12 ;
106443: LD_ADDR_VAR 0 7
106447: PUSH
106448: LD_INT 12
106450: ST_TO_ADDR
// side := GetSide ( unit ) ;
106451: LD_ADDR_VAR 0 6
106455: PUSH
106456: LD_VAR 0 1
106460: PPUSH
106461: CALL_OW 255
106465: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
106466: LD_INT 61
106468: PPUSH
106469: LD_VAR 0 6
106473: PPUSH
106474: CALL_OW 321
106478: PUSH
106479: LD_INT 2
106481: EQUAL
106482: IFFALSE 106492
// viewRange := 16 ;
106484: LD_ADDR_VAR 0 7
106488: PUSH
106489: LD_INT 16
106491: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
106492: LD_VAR 0 1
106496: PPUSH
106497: LD_VAR 0 2
106501: PPUSH
106502: LD_VAR 0 3
106506: PPUSH
106507: CALL_OW 297
106511: PUSH
106512: LD_VAR 0 5
106516: GREATER
106517: IFFALSE 106596
// begin ComMoveXY ( unit , x , y ) ;
106519: LD_VAR 0 1
106523: PPUSH
106524: LD_VAR 0 2
106528: PPUSH
106529: LD_VAR 0 3
106533: PPUSH
106534: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106538: LD_INT 35
106540: PPUSH
106541: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
106545: LD_VAR 0 1
106549: PPUSH
106550: LD_VAR 0 2
106554: PPUSH
106555: LD_VAR 0 3
106559: PPUSH
106560: CALL 51074 0 3
106564: NOT
106565: IFFALSE 106569
// exit ;
106567: GO 106823
// until GetDistUnitXY ( unit , x , y ) < dist ;
106569: LD_VAR 0 1
106573: PPUSH
106574: LD_VAR 0 2
106578: PPUSH
106579: LD_VAR 0 3
106583: PPUSH
106584: CALL_OW 297
106588: PUSH
106589: LD_VAR 0 5
106593: LESS
106594: IFFALSE 106538
// end ; ComTurnXY ( unit , x , y ) ;
106596: LD_VAR 0 1
106600: PPUSH
106601: LD_VAR 0 2
106605: PPUSH
106606: LD_VAR 0 3
106610: PPUSH
106611: CALL_OW 118
// wait ( 5 ) ;
106615: LD_INT 5
106617: PPUSH
106618: CALL_OW 67
// _d := GetDir ( unit ) ;
106622: LD_ADDR_VAR 0 10
106626: PUSH
106627: LD_VAR 0 1
106631: PPUSH
106632: CALL_OW 254
106636: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
106637: LD_ADDR_VAR 0 8
106641: PUSH
106642: LD_VAR 0 1
106646: PPUSH
106647: CALL_OW 250
106651: PPUSH
106652: LD_VAR 0 10
106656: PPUSH
106657: LD_VAR 0 5
106661: PPUSH
106662: CALL_OW 272
106666: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
106667: LD_ADDR_VAR 0 9
106671: PUSH
106672: LD_VAR 0 1
106676: PPUSH
106677: CALL_OW 251
106681: PPUSH
106682: LD_VAR 0 10
106686: PPUSH
106687: LD_VAR 0 5
106691: PPUSH
106692: CALL_OW 273
106696: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
106697: LD_VAR 0 8
106701: PPUSH
106702: LD_VAR 0 9
106706: PPUSH
106707: CALL_OW 488
106711: NOT
106712: IFFALSE 106716
// exit ;
106714: GO 106823
// ComAnimCustom ( unit , 1 ) ;
106716: LD_VAR 0 1
106720: PPUSH
106721: LD_INT 1
106723: PPUSH
106724: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
106728: LD_VAR 0 8
106732: PPUSH
106733: LD_VAR 0 9
106737: PPUSH
106738: LD_VAR 0 6
106742: PPUSH
106743: LD_VAR 0 7
106747: PPUSH
106748: CALL_OW 330
// repeat wait ( 1 ) ;
106752: LD_INT 1
106754: PPUSH
106755: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
106759: LD_VAR 0 1
106763: PPUSH
106764: CALL_OW 316
106768: PUSH
106769: LD_VAR 0 1
106773: PPUSH
106774: CALL_OW 314
106778: OR
106779: PUSH
106780: LD_VAR 0 1
106784: PPUSH
106785: CALL_OW 302
106789: NOT
106790: OR
106791: PUSH
106792: LD_VAR 0 1
106796: PPUSH
106797: CALL_OW 301
106801: OR
106802: IFFALSE 106752
// RemoveSeeing ( _x , _y , side ) ;
106804: LD_VAR 0 8
106808: PPUSH
106809: LD_VAR 0 9
106813: PPUSH
106814: LD_VAR 0 6
106818: PPUSH
106819: CALL_OW 331
// end ; end_of_file
106823: LD_VAR 0 4
106827: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
106828: LD_INT 0
106830: PPUSH
106831: PPUSH
106832: PPUSH
106833: PPUSH
106834: PPUSH
106835: PPUSH
106836: PPUSH
106837: PPUSH
106838: PPUSH
106839: PPUSH
106840: PPUSH
106841: PPUSH
106842: PPUSH
106843: PPUSH
106844: PPUSH
106845: PPUSH
106846: PPUSH
106847: PPUSH
106848: PPUSH
106849: PPUSH
106850: PPUSH
106851: PPUSH
106852: PPUSH
106853: PPUSH
106854: PPUSH
106855: PPUSH
106856: PPUSH
106857: PPUSH
106858: PPUSH
106859: PPUSH
106860: PPUSH
106861: PPUSH
106862: PPUSH
106863: PPUSH
// if not list then
106864: LD_VAR 0 1
106868: NOT
106869: IFFALSE 106873
// exit ;
106871: GO 111532
// base := list [ 1 ] ;
106873: LD_ADDR_VAR 0 3
106877: PUSH
106878: LD_VAR 0 1
106882: PUSH
106883: LD_INT 1
106885: ARRAY
106886: ST_TO_ADDR
// group := list [ 2 ] ;
106887: LD_ADDR_VAR 0 4
106891: PUSH
106892: LD_VAR 0 1
106896: PUSH
106897: LD_INT 2
106899: ARRAY
106900: ST_TO_ADDR
// path := list [ 3 ] ;
106901: LD_ADDR_VAR 0 5
106905: PUSH
106906: LD_VAR 0 1
106910: PUSH
106911: LD_INT 3
106913: ARRAY
106914: ST_TO_ADDR
// flags := list [ 4 ] ;
106915: LD_ADDR_VAR 0 6
106919: PUSH
106920: LD_VAR 0 1
106924: PUSH
106925: LD_INT 4
106927: ARRAY
106928: ST_TO_ADDR
// mined := [ ] ;
106929: LD_ADDR_VAR 0 27
106933: PUSH
106934: EMPTY
106935: ST_TO_ADDR
// bombed := [ ] ;
106936: LD_ADDR_VAR 0 28
106940: PUSH
106941: EMPTY
106942: ST_TO_ADDR
// healers := [ ] ;
106943: LD_ADDR_VAR 0 31
106947: PUSH
106948: EMPTY
106949: ST_TO_ADDR
// to_heal := [ ] ;
106950: LD_ADDR_VAR 0 30
106954: PUSH
106955: EMPTY
106956: ST_TO_ADDR
// repairs := [ ] ;
106957: LD_ADDR_VAR 0 33
106961: PUSH
106962: EMPTY
106963: ST_TO_ADDR
// to_repair := [ ] ;
106964: LD_ADDR_VAR 0 32
106968: PUSH
106969: EMPTY
106970: ST_TO_ADDR
// if not group or not path then
106971: LD_VAR 0 4
106975: NOT
106976: PUSH
106977: LD_VAR 0 5
106981: NOT
106982: OR
106983: IFFALSE 106987
// exit ;
106985: GO 111532
// side := GetSide ( group [ 1 ] ) ;
106987: LD_ADDR_VAR 0 35
106991: PUSH
106992: LD_VAR 0 4
106996: PUSH
106997: LD_INT 1
106999: ARRAY
107000: PPUSH
107001: CALL_OW 255
107005: ST_TO_ADDR
// if flags then
107006: LD_VAR 0 6
107010: IFFALSE 107154
// begin f_ignore_area := flags [ 1 ] ;
107012: LD_ADDR_VAR 0 17
107016: PUSH
107017: LD_VAR 0 6
107021: PUSH
107022: LD_INT 1
107024: ARRAY
107025: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
107026: LD_ADDR_VAR 0 18
107030: PUSH
107031: LD_VAR 0 6
107035: PUSH
107036: LD_INT 2
107038: ARRAY
107039: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
107040: LD_ADDR_VAR 0 19
107044: PUSH
107045: LD_VAR 0 6
107049: PUSH
107050: LD_INT 3
107052: ARRAY
107053: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
107054: LD_ADDR_VAR 0 20
107058: PUSH
107059: LD_VAR 0 6
107063: PUSH
107064: LD_INT 4
107066: ARRAY
107067: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
107068: LD_ADDR_VAR 0 21
107072: PUSH
107073: LD_VAR 0 6
107077: PUSH
107078: LD_INT 5
107080: ARRAY
107081: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
107082: LD_ADDR_VAR 0 22
107086: PUSH
107087: LD_VAR 0 6
107091: PUSH
107092: LD_INT 6
107094: ARRAY
107095: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
107096: LD_ADDR_VAR 0 23
107100: PUSH
107101: LD_VAR 0 6
107105: PUSH
107106: LD_INT 7
107108: ARRAY
107109: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
107110: LD_ADDR_VAR 0 24
107114: PUSH
107115: LD_VAR 0 6
107119: PUSH
107120: LD_INT 8
107122: ARRAY
107123: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
107124: LD_ADDR_VAR 0 25
107128: PUSH
107129: LD_VAR 0 6
107133: PUSH
107134: LD_INT 9
107136: ARRAY
107137: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
107138: LD_ADDR_VAR 0 26
107142: PUSH
107143: LD_VAR 0 6
107147: PUSH
107148: LD_INT 10
107150: ARRAY
107151: ST_TO_ADDR
// end else
107152: GO 107234
// begin f_ignore_area := false ;
107154: LD_ADDR_VAR 0 17
107158: PUSH
107159: LD_INT 0
107161: ST_TO_ADDR
// f_capture := false ;
107162: LD_ADDR_VAR 0 18
107166: PUSH
107167: LD_INT 0
107169: ST_TO_ADDR
// f_ignore_civ := false ;
107170: LD_ADDR_VAR 0 19
107174: PUSH
107175: LD_INT 0
107177: ST_TO_ADDR
// f_murder := false ;
107178: LD_ADDR_VAR 0 20
107182: PUSH
107183: LD_INT 0
107185: ST_TO_ADDR
// f_mines := false ;
107186: LD_ADDR_VAR 0 21
107190: PUSH
107191: LD_INT 0
107193: ST_TO_ADDR
// f_repair := false ;
107194: LD_ADDR_VAR 0 22
107198: PUSH
107199: LD_INT 0
107201: ST_TO_ADDR
// f_heal := false ;
107202: LD_ADDR_VAR 0 23
107206: PUSH
107207: LD_INT 0
107209: ST_TO_ADDR
// f_spacetime := false ;
107210: LD_ADDR_VAR 0 24
107214: PUSH
107215: LD_INT 0
107217: ST_TO_ADDR
// f_attack_depot := false ;
107218: LD_ADDR_VAR 0 25
107222: PUSH
107223: LD_INT 0
107225: ST_TO_ADDR
// f_crawl := false ;
107226: LD_ADDR_VAR 0 26
107230: PUSH
107231: LD_INT 0
107233: ST_TO_ADDR
// end ; if f_heal then
107234: LD_VAR 0 23
107238: IFFALSE 107265
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
107240: LD_ADDR_VAR 0 31
107244: PUSH
107245: LD_VAR 0 4
107249: PPUSH
107250: LD_INT 25
107252: PUSH
107253: LD_INT 4
107255: PUSH
107256: EMPTY
107257: LIST
107258: LIST
107259: PPUSH
107260: CALL_OW 72
107264: ST_TO_ADDR
// if f_repair then
107265: LD_VAR 0 22
107269: IFFALSE 107296
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
107271: LD_ADDR_VAR 0 33
107275: PUSH
107276: LD_VAR 0 4
107280: PPUSH
107281: LD_INT 25
107283: PUSH
107284: LD_INT 3
107286: PUSH
107287: EMPTY
107288: LIST
107289: LIST
107290: PPUSH
107291: CALL_OW 72
107295: ST_TO_ADDR
// units_path := [ ] ;
107296: LD_ADDR_VAR 0 16
107300: PUSH
107301: EMPTY
107302: ST_TO_ADDR
// for i = 1 to group do
107303: LD_ADDR_VAR 0 7
107307: PUSH
107308: DOUBLE
107309: LD_INT 1
107311: DEC
107312: ST_TO_ADDR
107313: LD_VAR 0 4
107317: PUSH
107318: FOR_TO
107319: IFFALSE 107348
// units_path := Replace ( units_path , i , path ) ;
107321: LD_ADDR_VAR 0 16
107325: PUSH
107326: LD_VAR 0 16
107330: PPUSH
107331: LD_VAR 0 7
107335: PPUSH
107336: LD_VAR 0 5
107340: PPUSH
107341: CALL_OW 1
107345: ST_TO_ADDR
107346: GO 107318
107348: POP
107349: POP
// repeat for i = group downto 1 do
107350: LD_ADDR_VAR 0 7
107354: PUSH
107355: DOUBLE
107356: LD_VAR 0 4
107360: INC
107361: ST_TO_ADDR
107362: LD_INT 1
107364: PUSH
107365: FOR_DOWNTO
107366: IFFALSE 111488
// begin wait ( 5 ) ;
107368: LD_INT 5
107370: PPUSH
107371: CALL_OW 67
// tmp := [ ] ;
107375: LD_ADDR_VAR 0 14
107379: PUSH
107380: EMPTY
107381: ST_TO_ADDR
// attacking := false ;
107382: LD_ADDR_VAR 0 29
107386: PUSH
107387: LD_INT 0
107389: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
107390: LD_VAR 0 4
107394: PUSH
107395: LD_VAR 0 7
107399: ARRAY
107400: PPUSH
107401: CALL_OW 301
107405: PUSH
107406: LD_VAR 0 4
107410: PUSH
107411: LD_VAR 0 7
107415: ARRAY
107416: NOT
107417: OR
107418: IFFALSE 107527
// begin if GetType ( group [ i ] ) = unit_human then
107420: LD_VAR 0 4
107424: PUSH
107425: LD_VAR 0 7
107429: ARRAY
107430: PPUSH
107431: CALL_OW 247
107435: PUSH
107436: LD_INT 1
107438: EQUAL
107439: IFFALSE 107485
// begin to_heal := to_heal diff group [ i ] ;
107441: LD_ADDR_VAR 0 30
107445: PUSH
107446: LD_VAR 0 30
107450: PUSH
107451: LD_VAR 0 4
107455: PUSH
107456: LD_VAR 0 7
107460: ARRAY
107461: DIFF
107462: ST_TO_ADDR
// healers := healers diff group [ i ] ;
107463: LD_ADDR_VAR 0 31
107467: PUSH
107468: LD_VAR 0 31
107472: PUSH
107473: LD_VAR 0 4
107477: PUSH
107478: LD_VAR 0 7
107482: ARRAY
107483: DIFF
107484: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
107485: LD_ADDR_VAR 0 4
107489: PUSH
107490: LD_VAR 0 4
107494: PPUSH
107495: LD_VAR 0 7
107499: PPUSH
107500: CALL_OW 3
107504: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
107505: LD_ADDR_VAR 0 16
107509: PUSH
107510: LD_VAR 0 16
107514: PPUSH
107515: LD_VAR 0 7
107519: PPUSH
107520: CALL_OW 3
107524: ST_TO_ADDR
// continue ;
107525: GO 107365
// end ; if f_repair then
107527: LD_VAR 0 22
107531: IFFALSE 108020
// begin if GetType ( group [ i ] ) = unit_vehicle then
107533: LD_VAR 0 4
107537: PUSH
107538: LD_VAR 0 7
107542: ARRAY
107543: PPUSH
107544: CALL_OW 247
107548: PUSH
107549: LD_INT 2
107551: EQUAL
107552: IFFALSE 107742
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
107554: LD_VAR 0 4
107558: PUSH
107559: LD_VAR 0 7
107563: ARRAY
107564: PPUSH
107565: CALL_OW 256
107569: PUSH
107570: LD_INT 700
107572: LESS
107573: PUSH
107574: LD_VAR 0 4
107578: PUSH
107579: LD_VAR 0 7
107583: ARRAY
107584: PUSH
107585: LD_VAR 0 32
107589: IN
107590: NOT
107591: AND
107592: IFFALSE 107616
// to_repair := to_repair union group [ i ] ;
107594: LD_ADDR_VAR 0 32
107598: PUSH
107599: LD_VAR 0 32
107603: PUSH
107604: LD_VAR 0 4
107608: PUSH
107609: LD_VAR 0 7
107613: ARRAY
107614: UNION
107615: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
107616: LD_VAR 0 4
107620: PUSH
107621: LD_VAR 0 7
107625: ARRAY
107626: PPUSH
107627: CALL_OW 256
107631: PUSH
107632: LD_INT 1000
107634: EQUAL
107635: PUSH
107636: LD_VAR 0 4
107640: PUSH
107641: LD_VAR 0 7
107645: ARRAY
107646: PUSH
107647: LD_VAR 0 32
107651: IN
107652: AND
107653: IFFALSE 107677
// to_repair := to_repair diff group [ i ] ;
107655: LD_ADDR_VAR 0 32
107659: PUSH
107660: LD_VAR 0 32
107664: PUSH
107665: LD_VAR 0 4
107669: PUSH
107670: LD_VAR 0 7
107674: ARRAY
107675: DIFF
107676: ST_TO_ADDR
// if group [ i ] in to_repair then
107677: LD_VAR 0 4
107681: PUSH
107682: LD_VAR 0 7
107686: ARRAY
107687: PUSH
107688: LD_VAR 0 32
107692: IN
107693: IFFALSE 107740
// begin if not IsInArea ( group [ i ] , f_repair ) then
107695: LD_VAR 0 4
107699: PUSH
107700: LD_VAR 0 7
107704: ARRAY
107705: PPUSH
107706: LD_VAR 0 22
107710: PPUSH
107711: CALL_OW 308
107715: NOT
107716: IFFALSE 107738
// ComMoveToArea ( group [ i ] , f_repair ) ;
107718: LD_VAR 0 4
107722: PUSH
107723: LD_VAR 0 7
107727: ARRAY
107728: PPUSH
107729: LD_VAR 0 22
107733: PPUSH
107734: CALL_OW 113
// continue ;
107738: GO 107365
// end ; end else
107740: GO 108020
// if group [ i ] in repairs then
107742: LD_VAR 0 4
107746: PUSH
107747: LD_VAR 0 7
107751: ARRAY
107752: PUSH
107753: LD_VAR 0 33
107757: IN
107758: IFFALSE 108020
// begin if IsInUnit ( group [ i ] ) then
107760: LD_VAR 0 4
107764: PUSH
107765: LD_VAR 0 7
107769: ARRAY
107770: PPUSH
107771: CALL_OW 310
107775: IFFALSE 107843
// begin z := IsInUnit ( group [ i ] ) ;
107777: LD_ADDR_VAR 0 13
107781: PUSH
107782: LD_VAR 0 4
107786: PUSH
107787: LD_VAR 0 7
107791: ARRAY
107792: PPUSH
107793: CALL_OW 310
107797: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
107798: LD_VAR 0 13
107802: PUSH
107803: LD_VAR 0 32
107807: IN
107808: PUSH
107809: LD_VAR 0 13
107813: PPUSH
107814: LD_VAR 0 22
107818: PPUSH
107819: CALL_OW 308
107823: AND
107824: IFFALSE 107841
// ComExitVehicle ( group [ i ] ) ;
107826: LD_VAR 0 4
107830: PUSH
107831: LD_VAR 0 7
107835: ARRAY
107836: PPUSH
107837: CALL_OW 121
// end else
107841: GO 108020
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
107843: LD_ADDR_VAR 0 13
107847: PUSH
107848: LD_VAR 0 4
107852: PPUSH
107853: LD_INT 95
107855: PUSH
107856: LD_VAR 0 22
107860: PUSH
107861: EMPTY
107862: LIST
107863: LIST
107864: PUSH
107865: LD_INT 58
107867: PUSH
107868: EMPTY
107869: LIST
107870: PUSH
107871: EMPTY
107872: LIST
107873: LIST
107874: PPUSH
107875: CALL_OW 72
107879: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
107880: LD_VAR 0 4
107884: PUSH
107885: LD_VAR 0 7
107889: ARRAY
107890: PPUSH
107891: CALL_OW 314
107895: NOT
107896: IFFALSE 108018
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
107898: LD_ADDR_VAR 0 10
107902: PUSH
107903: LD_VAR 0 13
107907: PPUSH
107908: LD_VAR 0 4
107912: PUSH
107913: LD_VAR 0 7
107917: ARRAY
107918: PPUSH
107919: CALL_OW 74
107923: ST_TO_ADDR
// if not x then
107924: LD_VAR 0 10
107928: NOT
107929: IFFALSE 107933
// continue ;
107931: GO 107365
// if GetLives ( x ) < 1000 then
107933: LD_VAR 0 10
107937: PPUSH
107938: CALL_OW 256
107942: PUSH
107943: LD_INT 1000
107945: LESS
107946: IFFALSE 107970
// ComRepairVehicle ( group [ i ] , x ) else
107948: LD_VAR 0 4
107952: PUSH
107953: LD_VAR 0 7
107957: ARRAY
107958: PPUSH
107959: LD_VAR 0 10
107963: PPUSH
107964: CALL_OW 129
107968: GO 108018
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
107970: LD_VAR 0 23
107974: PUSH
107975: LD_VAR 0 4
107979: PUSH
107980: LD_VAR 0 7
107984: ARRAY
107985: PPUSH
107986: CALL_OW 256
107990: PUSH
107991: LD_INT 1000
107993: LESS
107994: AND
107995: NOT
107996: IFFALSE 108018
// ComEnterUnit ( group [ i ] , x ) ;
107998: LD_VAR 0 4
108002: PUSH
108003: LD_VAR 0 7
108007: ARRAY
108008: PPUSH
108009: LD_VAR 0 10
108013: PPUSH
108014: CALL_OW 120
// end ; continue ;
108018: GO 107365
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
108020: LD_VAR 0 23
108024: PUSH
108025: LD_VAR 0 4
108029: PUSH
108030: LD_VAR 0 7
108034: ARRAY
108035: PPUSH
108036: CALL_OW 247
108040: PUSH
108041: LD_INT 1
108043: EQUAL
108044: AND
108045: IFFALSE 108523
// begin if group [ i ] in healers then
108047: LD_VAR 0 4
108051: PUSH
108052: LD_VAR 0 7
108056: ARRAY
108057: PUSH
108058: LD_VAR 0 31
108062: IN
108063: IFFALSE 108336
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
108065: LD_VAR 0 4
108069: PUSH
108070: LD_VAR 0 7
108074: ARRAY
108075: PPUSH
108076: LD_VAR 0 23
108080: PPUSH
108081: CALL_OW 308
108085: NOT
108086: PUSH
108087: LD_VAR 0 4
108091: PUSH
108092: LD_VAR 0 7
108096: ARRAY
108097: PPUSH
108098: CALL_OW 314
108102: NOT
108103: AND
108104: IFFALSE 108128
// ComMoveToArea ( group [ i ] , f_heal ) else
108106: LD_VAR 0 4
108110: PUSH
108111: LD_VAR 0 7
108115: ARRAY
108116: PPUSH
108117: LD_VAR 0 23
108121: PPUSH
108122: CALL_OW 113
108126: GO 108334
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
108128: LD_VAR 0 4
108132: PUSH
108133: LD_VAR 0 7
108137: ARRAY
108138: PPUSH
108139: CALL 49650 0 1
108143: PPUSH
108144: CALL_OW 256
108148: PUSH
108149: LD_INT 1000
108151: EQUAL
108152: IFFALSE 108171
// ComStop ( group [ i ] ) else
108154: LD_VAR 0 4
108158: PUSH
108159: LD_VAR 0 7
108163: ARRAY
108164: PPUSH
108165: CALL_OW 141
108169: GO 108334
// if not HasTask ( group [ i ] ) and to_heal then
108171: LD_VAR 0 4
108175: PUSH
108176: LD_VAR 0 7
108180: ARRAY
108181: PPUSH
108182: CALL_OW 314
108186: NOT
108187: PUSH
108188: LD_VAR 0 30
108192: AND
108193: IFFALSE 108334
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
108195: LD_ADDR_VAR 0 13
108199: PUSH
108200: LD_VAR 0 30
108204: PPUSH
108205: LD_INT 3
108207: PUSH
108208: LD_INT 54
108210: PUSH
108211: EMPTY
108212: LIST
108213: PUSH
108214: EMPTY
108215: LIST
108216: LIST
108217: PPUSH
108218: CALL_OW 72
108222: PPUSH
108223: LD_VAR 0 4
108227: PUSH
108228: LD_VAR 0 7
108232: ARRAY
108233: PPUSH
108234: CALL_OW 74
108238: ST_TO_ADDR
// if z then
108239: LD_VAR 0 13
108243: IFFALSE 108334
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
108245: LD_INT 91
108247: PUSH
108248: LD_VAR 0 13
108252: PUSH
108253: LD_INT 10
108255: PUSH
108256: EMPTY
108257: LIST
108258: LIST
108259: LIST
108260: PUSH
108261: LD_INT 81
108263: PUSH
108264: LD_VAR 0 13
108268: PPUSH
108269: CALL_OW 255
108273: PUSH
108274: EMPTY
108275: LIST
108276: LIST
108277: PUSH
108278: EMPTY
108279: LIST
108280: LIST
108281: PPUSH
108282: CALL_OW 69
108286: PUSH
108287: LD_INT 0
108289: EQUAL
108290: IFFALSE 108314
// ComHeal ( group [ i ] , z ) else
108292: LD_VAR 0 4
108296: PUSH
108297: LD_VAR 0 7
108301: ARRAY
108302: PPUSH
108303: LD_VAR 0 13
108307: PPUSH
108308: CALL_OW 128
108312: GO 108334
// ComMoveToArea ( group [ i ] , f_heal ) ;
108314: LD_VAR 0 4
108318: PUSH
108319: LD_VAR 0 7
108323: ARRAY
108324: PPUSH
108325: LD_VAR 0 23
108329: PPUSH
108330: CALL_OW 113
// end ; continue ;
108334: GO 107365
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
108336: LD_VAR 0 4
108340: PUSH
108341: LD_VAR 0 7
108345: ARRAY
108346: PPUSH
108347: CALL_OW 256
108351: PUSH
108352: LD_INT 700
108354: LESS
108355: PUSH
108356: LD_VAR 0 4
108360: PUSH
108361: LD_VAR 0 7
108365: ARRAY
108366: PUSH
108367: LD_VAR 0 30
108371: IN
108372: NOT
108373: AND
108374: IFFALSE 108398
// to_heal := to_heal union group [ i ] ;
108376: LD_ADDR_VAR 0 30
108380: PUSH
108381: LD_VAR 0 30
108385: PUSH
108386: LD_VAR 0 4
108390: PUSH
108391: LD_VAR 0 7
108395: ARRAY
108396: UNION
108397: ST_TO_ADDR
// if group [ i ] in to_heal then
108398: LD_VAR 0 4
108402: PUSH
108403: LD_VAR 0 7
108407: ARRAY
108408: PUSH
108409: LD_VAR 0 30
108413: IN
108414: IFFALSE 108523
// begin if GetLives ( group [ i ] ) = 1000 then
108416: LD_VAR 0 4
108420: PUSH
108421: LD_VAR 0 7
108425: ARRAY
108426: PPUSH
108427: CALL_OW 256
108431: PUSH
108432: LD_INT 1000
108434: EQUAL
108435: IFFALSE 108461
// to_heal := to_heal diff group [ i ] else
108437: LD_ADDR_VAR 0 30
108441: PUSH
108442: LD_VAR 0 30
108446: PUSH
108447: LD_VAR 0 4
108451: PUSH
108452: LD_VAR 0 7
108456: ARRAY
108457: DIFF
108458: ST_TO_ADDR
108459: GO 108523
// begin if not IsInArea ( group [ i ] , to_heal ) then
108461: LD_VAR 0 4
108465: PUSH
108466: LD_VAR 0 7
108470: ARRAY
108471: PPUSH
108472: LD_VAR 0 30
108476: PPUSH
108477: CALL_OW 308
108481: NOT
108482: IFFALSE 108506
// ComMoveToArea ( group [ i ] , f_heal ) else
108484: LD_VAR 0 4
108488: PUSH
108489: LD_VAR 0 7
108493: ARRAY
108494: PPUSH
108495: LD_VAR 0 23
108499: PPUSH
108500: CALL_OW 113
108504: GO 108521
// ComHold ( group [ i ] ) ;
108506: LD_VAR 0 4
108510: PUSH
108511: LD_VAR 0 7
108515: ARRAY
108516: PPUSH
108517: CALL_OW 140
// continue ;
108521: GO 107365
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
108523: LD_VAR 0 4
108527: PUSH
108528: LD_VAR 0 7
108532: ARRAY
108533: PPUSH
108534: LD_INT 10
108536: PPUSH
108537: CALL 47503 0 2
108541: NOT
108542: PUSH
108543: LD_VAR 0 16
108547: PUSH
108548: LD_VAR 0 7
108552: ARRAY
108553: PUSH
108554: EMPTY
108555: EQUAL
108556: NOT
108557: AND
108558: IFFALSE 108824
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
108560: LD_VAR 0 4
108564: PUSH
108565: LD_VAR 0 7
108569: ARRAY
108570: PPUSH
108571: CALL_OW 262
108575: PUSH
108576: LD_INT 1
108578: PUSH
108579: LD_INT 2
108581: PUSH
108582: EMPTY
108583: LIST
108584: LIST
108585: IN
108586: IFFALSE 108627
// if GetFuel ( group [ i ] ) < 10 then
108588: LD_VAR 0 4
108592: PUSH
108593: LD_VAR 0 7
108597: ARRAY
108598: PPUSH
108599: CALL_OW 261
108603: PUSH
108604: LD_INT 10
108606: LESS
108607: IFFALSE 108627
// SetFuel ( group [ i ] , 12 ) ;
108609: LD_VAR 0 4
108613: PUSH
108614: LD_VAR 0 7
108618: ARRAY
108619: PPUSH
108620: LD_INT 12
108622: PPUSH
108623: CALL_OW 240
// if units_path [ i ] then
108627: LD_VAR 0 16
108631: PUSH
108632: LD_VAR 0 7
108636: ARRAY
108637: IFFALSE 108822
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
108639: LD_VAR 0 4
108643: PUSH
108644: LD_VAR 0 7
108648: ARRAY
108649: PPUSH
108650: LD_VAR 0 16
108654: PUSH
108655: LD_VAR 0 7
108659: ARRAY
108660: PUSH
108661: LD_INT 1
108663: ARRAY
108664: PUSH
108665: LD_INT 1
108667: ARRAY
108668: PPUSH
108669: LD_VAR 0 16
108673: PUSH
108674: LD_VAR 0 7
108678: ARRAY
108679: PUSH
108680: LD_INT 1
108682: ARRAY
108683: PUSH
108684: LD_INT 2
108686: ARRAY
108687: PPUSH
108688: CALL_OW 297
108692: PUSH
108693: LD_INT 6
108695: GREATER
108696: IFFALSE 108771
// begin if not HasTask ( group [ i ] ) then
108698: LD_VAR 0 4
108702: PUSH
108703: LD_VAR 0 7
108707: ARRAY
108708: PPUSH
108709: CALL_OW 314
108713: NOT
108714: IFFALSE 108769
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
108716: LD_VAR 0 4
108720: PUSH
108721: LD_VAR 0 7
108725: ARRAY
108726: PPUSH
108727: LD_VAR 0 16
108731: PUSH
108732: LD_VAR 0 7
108736: ARRAY
108737: PUSH
108738: LD_INT 1
108740: ARRAY
108741: PUSH
108742: LD_INT 1
108744: ARRAY
108745: PPUSH
108746: LD_VAR 0 16
108750: PUSH
108751: LD_VAR 0 7
108755: ARRAY
108756: PUSH
108757: LD_INT 1
108759: ARRAY
108760: PUSH
108761: LD_INT 2
108763: ARRAY
108764: PPUSH
108765: CALL_OW 114
// end else
108769: GO 108822
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
108771: LD_ADDR_VAR 0 15
108775: PUSH
108776: LD_VAR 0 16
108780: PUSH
108781: LD_VAR 0 7
108785: ARRAY
108786: PPUSH
108787: LD_INT 1
108789: PPUSH
108790: CALL_OW 3
108794: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
108795: LD_ADDR_VAR 0 16
108799: PUSH
108800: LD_VAR 0 16
108804: PPUSH
108805: LD_VAR 0 7
108809: PPUSH
108810: LD_VAR 0 15
108814: PPUSH
108815: CALL_OW 1
108819: ST_TO_ADDR
// continue ;
108820: GO 107365
// end ; end ; end else
108822: GO 111486
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
108824: LD_ADDR_VAR 0 14
108828: PUSH
108829: LD_INT 81
108831: PUSH
108832: LD_VAR 0 4
108836: PUSH
108837: LD_VAR 0 7
108841: ARRAY
108842: PPUSH
108843: CALL_OW 255
108847: PUSH
108848: EMPTY
108849: LIST
108850: LIST
108851: PPUSH
108852: CALL_OW 69
108856: ST_TO_ADDR
// if not tmp then
108857: LD_VAR 0 14
108861: NOT
108862: IFFALSE 108866
// continue ;
108864: GO 107365
// if f_ignore_area then
108866: LD_VAR 0 17
108870: IFFALSE 108958
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
108872: LD_ADDR_VAR 0 15
108876: PUSH
108877: LD_VAR 0 14
108881: PPUSH
108882: LD_INT 3
108884: PUSH
108885: LD_INT 92
108887: PUSH
108888: LD_VAR 0 17
108892: PUSH
108893: LD_INT 1
108895: ARRAY
108896: PUSH
108897: LD_VAR 0 17
108901: PUSH
108902: LD_INT 2
108904: ARRAY
108905: PUSH
108906: LD_VAR 0 17
108910: PUSH
108911: LD_INT 3
108913: ARRAY
108914: PUSH
108915: EMPTY
108916: LIST
108917: LIST
108918: LIST
108919: LIST
108920: PUSH
108921: EMPTY
108922: LIST
108923: LIST
108924: PPUSH
108925: CALL_OW 72
108929: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108930: LD_VAR 0 14
108934: PUSH
108935: LD_VAR 0 15
108939: DIFF
108940: IFFALSE 108958
// tmp := tmp diff tmp2 ;
108942: LD_ADDR_VAR 0 14
108946: PUSH
108947: LD_VAR 0 14
108951: PUSH
108952: LD_VAR 0 15
108956: DIFF
108957: ST_TO_ADDR
// end ; if not f_murder then
108958: LD_VAR 0 20
108962: NOT
108963: IFFALSE 109021
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
108965: LD_ADDR_VAR 0 15
108969: PUSH
108970: LD_VAR 0 14
108974: PPUSH
108975: LD_INT 3
108977: PUSH
108978: LD_INT 50
108980: PUSH
108981: EMPTY
108982: LIST
108983: PUSH
108984: EMPTY
108985: LIST
108986: LIST
108987: PPUSH
108988: CALL_OW 72
108992: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
108993: LD_VAR 0 14
108997: PUSH
108998: LD_VAR 0 15
109002: DIFF
109003: IFFALSE 109021
// tmp := tmp diff tmp2 ;
109005: LD_ADDR_VAR 0 14
109009: PUSH
109010: LD_VAR 0 14
109014: PUSH
109015: LD_VAR 0 15
109019: DIFF
109020: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
109021: LD_ADDR_VAR 0 14
109025: PUSH
109026: LD_VAR 0 4
109030: PUSH
109031: LD_VAR 0 7
109035: ARRAY
109036: PPUSH
109037: LD_VAR 0 14
109041: PPUSH
109042: LD_INT 1
109044: PPUSH
109045: LD_INT 1
109047: PPUSH
109048: CALL 20438 0 4
109052: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
109053: LD_VAR 0 4
109057: PUSH
109058: LD_VAR 0 7
109062: ARRAY
109063: PPUSH
109064: CALL_OW 257
109068: PUSH
109069: LD_INT 1
109071: EQUAL
109072: IFFALSE 109520
// begin if WantPlant ( group [ i ] ) then
109074: LD_VAR 0 4
109078: PUSH
109079: LD_VAR 0 7
109083: ARRAY
109084: PPUSH
109085: CALL 19939 0 1
109089: IFFALSE 109093
// continue ;
109091: GO 107365
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
109093: LD_VAR 0 18
109097: PUSH
109098: LD_VAR 0 4
109102: PUSH
109103: LD_VAR 0 7
109107: ARRAY
109108: PPUSH
109109: CALL_OW 310
109113: NOT
109114: AND
109115: PUSH
109116: LD_VAR 0 14
109120: PUSH
109121: LD_INT 1
109123: ARRAY
109124: PUSH
109125: LD_VAR 0 14
109129: PPUSH
109130: LD_INT 21
109132: PUSH
109133: LD_INT 2
109135: PUSH
109136: EMPTY
109137: LIST
109138: LIST
109139: PUSH
109140: LD_INT 58
109142: PUSH
109143: EMPTY
109144: LIST
109145: PUSH
109146: EMPTY
109147: LIST
109148: LIST
109149: PPUSH
109150: CALL_OW 72
109154: IN
109155: AND
109156: IFFALSE 109192
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
109158: LD_VAR 0 4
109162: PUSH
109163: LD_VAR 0 7
109167: ARRAY
109168: PPUSH
109169: LD_VAR 0 14
109173: PUSH
109174: LD_INT 1
109176: ARRAY
109177: PPUSH
109178: CALL_OW 120
// attacking := true ;
109182: LD_ADDR_VAR 0 29
109186: PUSH
109187: LD_INT 1
109189: ST_TO_ADDR
// continue ;
109190: GO 107365
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
109192: LD_VAR 0 26
109196: PUSH
109197: LD_VAR 0 4
109201: PUSH
109202: LD_VAR 0 7
109206: ARRAY
109207: PPUSH
109208: CALL_OW 257
109212: PUSH
109213: LD_INT 1
109215: EQUAL
109216: AND
109217: PUSH
109218: LD_VAR 0 4
109222: PUSH
109223: LD_VAR 0 7
109227: ARRAY
109228: PPUSH
109229: CALL_OW 256
109233: PUSH
109234: LD_INT 800
109236: LESS
109237: AND
109238: PUSH
109239: LD_VAR 0 4
109243: PUSH
109244: LD_VAR 0 7
109248: ARRAY
109249: PPUSH
109250: CALL_OW 318
109254: NOT
109255: AND
109256: IFFALSE 109273
// ComCrawl ( group [ i ] ) ;
109258: LD_VAR 0 4
109262: PUSH
109263: LD_VAR 0 7
109267: ARRAY
109268: PPUSH
109269: CALL_OW 137
// if f_mines then
109273: LD_VAR 0 21
109277: IFFALSE 109520
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
109279: LD_VAR 0 14
109283: PUSH
109284: LD_INT 1
109286: ARRAY
109287: PPUSH
109288: CALL_OW 247
109292: PUSH
109293: LD_INT 3
109295: EQUAL
109296: PUSH
109297: LD_VAR 0 14
109301: PUSH
109302: LD_INT 1
109304: ARRAY
109305: PUSH
109306: LD_VAR 0 27
109310: IN
109311: NOT
109312: AND
109313: IFFALSE 109520
// begin x := GetX ( tmp [ 1 ] ) ;
109315: LD_ADDR_VAR 0 10
109319: PUSH
109320: LD_VAR 0 14
109324: PUSH
109325: LD_INT 1
109327: ARRAY
109328: PPUSH
109329: CALL_OW 250
109333: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
109334: LD_ADDR_VAR 0 11
109338: PUSH
109339: LD_VAR 0 14
109343: PUSH
109344: LD_INT 1
109346: ARRAY
109347: PPUSH
109348: CALL_OW 251
109352: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
109353: LD_ADDR_VAR 0 12
109357: PUSH
109358: LD_VAR 0 4
109362: PUSH
109363: LD_VAR 0 7
109367: ARRAY
109368: PPUSH
109369: CALL 47588 0 1
109373: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
109374: LD_VAR 0 4
109378: PUSH
109379: LD_VAR 0 7
109383: ARRAY
109384: PPUSH
109385: LD_VAR 0 10
109389: PPUSH
109390: LD_VAR 0 11
109394: PPUSH
109395: LD_VAR 0 14
109399: PUSH
109400: LD_INT 1
109402: ARRAY
109403: PPUSH
109404: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
109408: LD_VAR 0 4
109412: PUSH
109413: LD_VAR 0 7
109417: ARRAY
109418: PPUSH
109419: LD_VAR 0 10
109423: PPUSH
109424: LD_VAR 0 12
109428: PPUSH
109429: LD_INT 7
109431: PPUSH
109432: CALL_OW 272
109436: PPUSH
109437: LD_VAR 0 11
109441: PPUSH
109442: LD_VAR 0 12
109446: PPUSH
109447: LD_INT 7
109449: PPUSH
109450: CALL_OW 273
109454: PPUSH
109455: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
109459: LD_VAR 0 4
109463: PUSH
109464: LD_VAR 0 7
109468: ARRAY
109469: PPUSH
109470: LD_INT 71
109472: PPUSH
109473: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
109477: LD_ADDR_VAR 0 27
109481: PUSH
109482: LD_VAR 0 27
109486: PPUSH
109487: LD_VAR 0 27
109491: PUSH
109492: LD_INT 1
109494: PLUS
109495: PPUSH
109496: LD_VAR 0 14
109500: PUSH
109501: LD_INT 1
109503: ARRAY
109504: PPUSH
109505: CALL_OW 1
109509: ST_TO_ADDR
// attacking := true ;
109510: LD_ADDR_VAR 0 29
109514: PUSH
109515: LD_INT 1
109517: ST_TO_ADDR
// continue ;
109518: GO 107365
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
109520: LD_VAR 0 4
109524: PUSH
109525: LD_VAR 0 7
109529: ARRAY
109530: PPUSH
109531: CALL_OW 257
109535: PUSH
109536: LD_INT 17
109538: EQUAL
109539: PUSH
109540: LD_VAR 0 4
109544: PUSH
109545: LD_VAR 0 7
109549: ARRAY
109550: PPUSH
109551: CALL_OW 110
109555: PUSH
109556: LD_INT 71
109558: EQUAL
109559: NOT
109560: AND
109561: IFFALSE 109707
// begin attacking := false ;
109563: LD_ADDR_VAR 0 29
109567: PUSH
109568: LD_INT 0
109570: ST_TO_ADDR
// k := 5 ;
109571: LD_ADDR_VAR 0 9
109575: PUSH
109576: LD_INT 5
109578: ST_TO_ADDR
// if tmp < k then
109579: LD_VAR 0 14
109583: PUSH
109584: LD_VAR 0 9
109588: LESS
109589: IFFALSE 109601
// k := tmp ;
109591: LD_ADDR_VAR 0 9
109595: PUSH
109596: LD_VAR 0 14
109600: ST_TO_ADDR
// for j = 1 to k do
109601: LD_ADDR_VAR 0 8
109605: PUSH
109606: DOUBLE
109607: LD_INT 1
109609: DEC
109610: ST_TO_ADDR
109611: LD_VAR 0 9
109615: PUSH
109616: FOR_TO
109617: IFFALSE 109705
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
109619: LD_VAR 0 14
109623: PUSH
109624: LD_VAR 0 8
109628: ARRAY
109629: PUSH
109630: LD_VAR 0 14
109634: PPUSH
109635: LD_INT 58
109637: PUSH
109638: EMPTY
109639: LIST
109640: PPUSH
109641: CALL_OW 72
109645: IN
109646: NOT
109647: IFFALSE 109703
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
109649: LD_VAR 0 4
109653: PUSH
109654: LD_VAR 0 7
109658: ARRAY
109659: PPUSH
109660: LD_VAR 0 14
109664: PUSH
109665: LD_VAR 0 8
109669: ARRAY
109670: PPUSH
109671: CALL_OW 115
// attacking := true ;
109675: LD_ADDR_VAR 0 29
109679: PUSH
109680: LD_INT 1
109682: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
109683: LD_VAR 0 4
109687: PUSH
109688: LD_VAR 0 7
109692: ARRAY
109693: PPUSH
109694: LD_INT 71
109696: PPUSH
109697: CALL_OW 109
// continue ;
109701: GO 109616
// end ; end ;
109703: GO 109616
109705: POP
109706: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
109707: LD_VAR 0 4
109711: PUSH
109712: LD_VAR 0 7
109716: ARRAY
109717: PPUSH
109718: CALL_OW 257
109722: PUSH
109723: LD_INT 8
109725: EQUAL
109726: PUSH
109727: LD_VAR 0 4
109731: PUSH
109732: LD_VAR 0 7
109736: ARRAY
109737: PPUSH
109738: CALL_OW 264
109742: PUSH
109743: LD_INT 28
109745: PUSH
109746: LD_INT 45
109748: PUSH
109749: LD_INT 7
109751: PUSH
109752: LD_INT 47
109754: PUSH
109755: EMPTY
109756: LIST
109757: LIST
109758: LIST
109759: LIST
109760: IN
109761: OR
109762: IFFALSE 110018
// begin attacking := false ;
109764: LD_ADDR_VAR 0 29
109768: PUSH
109769: LD_INT 0
109771: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
109772: LD_VAR 0 14
109776: PUSH
109777: LD_INT 1
109779: ARRAY
109780: PPUSH
109781: CALL_OW 266
109785: PUSH
109786: LD_INT 32
109788: PUSH
109789: LD_INT 31
109791: PUSH
109792: LD_INT 33
109794: PUSH
109795: LD_INT 4
109797: PUSH
109798: LD_INT 5
109800: PUSH
109801: EMPTY
109802: LIST
109803: LIST
109804: LIST
109805: LIST
109806: LIST
109807: IN
109808: IFFALSE 109994
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
109810: LD_ADDR_VAR 0 9
109814: PUSH
109815: LD_VAR 0 14
109819: PUSH
109820: LD_INT 1
109822: ARRAY
109823: PPUSH
109824: CALL_OW 266
109828: PPUSH
109829: LD_VAR 0 14
109833: PUSH
109834: LD_INT 1
109836: ARRAY
109837: PPUSH
109838: CALL_OW 250
109842: PPUSH
109843: LD_VAR 0 14
109847: PUSH
109848: LD_INT 1
109850: ARRAY
109851: PPUSH
109852: CALL_OW 251
109856: PPUSH
109857: LD_VAR 0 14
109861: PUSH
109862: LD_INT 1
109864: ARRAY
109865: PPUSH
109866: CALL_OW 254
109870: PPUSH
109871: LD_VAR 0 14
109875: PUSH
109876: LD_INT 1
109878: ARRAY
109879: PPUSH
109880: CALL_OW 248
109884: PPUSH
109885: LD_INT 0
109887: PPUSH
109888: CALL 28958 0 6
109892: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
109893: LD_ADDR_VAR 0 8
109897: PUSH
109898: LD_VAR 0 4
109902: PUSH
109903: LD_VAR 0 7
109907: ARRAY
109908: PPUSH
109909: LD_VAR 0 9
109913: PPUSH
109914: CALL 47628 0 2
109918: ST_TO_ADDR
// if j then
109919: LD_VAR 0 8
109923: IFFALSE 109992
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
109925: LD_VAR 0 8
109929: PUSH
109930: LD_INT 1
109932: ARRAY
109933: PPUSH
109934: LD_VAR 0 8
109938: PUSH
109939: LD_INT 2
109941: ARRAY
109942: PPUSH
109943: CALL_OW 488
109947: IFFALSE 109992
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
109949: LD_VAR 0 4
109953: PUSH
109954: LD_VAR 0 7
109958: ARRAY
109959: PPUSH
109960: LD_VAR 0 8
109964: PUSH
109965: LD_INT 1
109967: ARRAY
109968: PPUSH
109969: LD_VAR 0 8
109973: PUSH
109974: LD_INT 2
109976: ARRAY
109977: PPUSH
109978: CALL_OW 116
// attacking := true ;
109982: LD_ADDR_VAR 0 29
109986: PUSH
109987: LD_INT 1
109989: ST_TO_ADDR
// continue ;
109990: GO 107365
// end ; end else
109992: GO 110018
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109994: LD_VAR 0 4
109998: PUSH
109999: LD_VAR 0 7
110003: ARRAY
110004: PPUSH
110005: LD_VAR 0 14
110009: PUSH
110010: LD_INT 1
110012: ARRAY
110013: PPUSH
110014: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
110018: LD_VAR 0 4
110022: PUSH
110023: LD_VAR 0 7
110027: ARRAY
110028: PPUSH
110029: CALL_OW 265
110033: PUSH
110034: LD_INT 11
110036: EQUAL
110037: IFFALSE 110315
// begin k := 10 ;
110039: LD_ADDR_VAR 0 9
110043: PUSH
110044: LD_INT 10
110046: ST_TO_ADDR
// x := 0 ;
110047: LD_ADDR_VAR 0 10
110051: PUSH
110052: LD_INT 0
110054: ST_TO_ADDR
// if tmp < k then
110055: LD_VAR 0 14
110059: PUSH
110060: LD_VAR 0 9
110064: LESS
110065: IFFALSE 110077
// k := tmp ;
110067: LD_ADDR_VAR 0 9
110071: PUSH
110072: LD_VAR 0 14
110076: ST_TO_ADDR
// for j = k downto 1 do
110077: LD_ADDR_VAR 0 8
110081: PUSH
110082: DOUBLE
110083: LD_VAR 0 9
110087: INC
110088: ST_TO_ADDR
110089: LD_INT 1
110091: PUSH
110092: FOR_DOWNTO
110093: IFFALSE 110168
// begin if GetType ( tmp [ j ] ) = unit_human then
110095: LD_VAR 0 14
110099: PUSH
110100: LD_VAR 0 8
110104: ARRAY
110105: PPUSH
110106: CALL_OW 247
110110: PUSH
110111: LD_INT 1
110113: EQUAL
110114: IFFALSE 110166
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
110116: LD_VAR 0 4
110120: PUSH
110121: LD_VAR 0 7
110125: ARRAY
110126: PPUSH
110127: LD_VAR 0 14
110131: PUSH
110132: LD_VAR 0 8
110136: ARRAY
110137: PPUSH
110138: CALL 47899 0 2
// x := tmp [ j ] ;
110142: LD_ADDR_VAR 0 10
110146: PUSH
110147: LD_VAR 0 14
110151: PUSH
110152: LD_VAR 0 8
110156: ARRAY
110157: ST_TO_ADDR
// attacking := true ;
110158: LD_ADDR_VAR 0 29
110162: PUSH
110163: LD_INT 1
110165: ST_TO_ADDR
// end ; end ;
110166: GO 110092
110168: POP
110169: POP
// if not x then
110170: LD_VAR 0 10
110174: NOT
110175: IFFALSE 110315
// begin attacking := true ;
110177: LD_ADDR_VAR 0 29
110181: PUSH
110182: LD_INT 1
110184: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
110185: LD_VAR 0 4
110189: PUSH
110190: LD_VAR 0 7
110194: ARRAY
110195: PPUSH
110196: CALL_OW 250
110200: PPUSH
110201: LD_VAR 0 4
110205: PUSH
110206: LD_VAR 0 7
110210: ARRAY
110211: PPUSH
110212: CALL_OW 251
110216: PPUSH
110217: CALL_OW 546
110221: PUSH
110222: LD_INT 2
110224: ARRAY
110225: PUSH
110226: LD_VAR 0 14
110230: PUSH
110231: LD_INT 1
110233: ARRAY
110234: PPUSH
110235: CALL_OW 250
110239: PPUSH
110240: LD_VAR 0 14
110244: PUSH
110245: LD_INT 1
110247: ARRAY
110248: PPUSH
110249: CALL_OW 251
110253: PPUSH
110254: CALL_OW 546
110258: PUSH
110259: LD_INT 2
110261: ARRAY
110262: EQUAL
110263: IFFALSE 110291
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
110265: LD_VAR 0 4
110269: PUSH
110270: LD_VAR 0 7
110274: ARRAY
110275: PPUSH
110276: LD_VAR 0 14
110280: PUSH
110281: LD_INT 1
110283: ARRAY
110284: PPUSH
110285: CALL 47899 0 2
110289: GO 110315
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110291: LD_VAR 0 4
110295: PUSH
110296: LD_VAR 0 7
110300: ARRAY
110301: PPUSH
110302: LD_VAR 0 14
110306: PUSH
110307: LD_INT 1
110309: ARRAY
110310: PPUSH
110311: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
110315: LD_VAR 0 4
110319: PUSH
110320: LD_VAR 0 7
110324: ARRAY
110325: PPUSH
110326: CALL_OW 264
110330: PUSH
110331: LD_INT 29
110333: EQUAL
110334: IFFALSE 110700
// begin if WantsToAttack ( group [ i ] ) in bombed then
110336: LD_VAR 0 4
110340: PUSH
110341: LD_VAR 0 7
110345: ARRAY
110346: PPUSH
110347: CALL_OW 319
110351: PUSH
110352: LD_VAR 0 28
110356: IN
110357: IFFALSE 110361
// continue ;
110359: GO 107365
// k := 8 ;
110361: LD_ADDR_VAR 0 9
110365: PUSH
110366: LD_INT 8
110368: ST_TO_ADDR
// x := 0 ;
110369: LD_ADDR_VAR 0 10
110373: PUSH
110374: LD_INT 0
110376: ST_TO_ADDR
// if tmp < k then
110377: LD_VAR 0 14
110381: PUSH
110382: LD_VAR 0 9
110386: LESS
110387: IFFALSE 110399
// k := tmp ;
110389: LD_ADDR_VAR 0 9
110393: PUSH
110394: LD_VAR 0 14
110398: ST_TO_ADDR
// for j = 1 to k do
110399: LD_ADDR_VAR 0 8
110403: PUSH
110404: DOUBLE
110405: LD_INT 1
110407: DEC
110408: ST_TO_ADDR
110409: LD_VAR 0 9
110413: PUSH
110414: FOR_TO
110415: IFFALSE 110547
// begin if GetType ( tmp [ j ] ) = unit_building then
110417: LD_VAR 0 14
110421: PUSH
110422: LD_VAR 0 8
110426: ARRAY
110427: PPUSH
110428: CALL_OW 247
110432: PUSH
110433: LD_INT 3
110435: EQUAL
110436: IFFALSE 110545
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
110438: LD_VAR 0 14
110442: PUSH
110443: LD_VAR 0 8
110447: ARRAY
110448: PUSH
110449: LD_VAR 0 28
110453: IN
110454: NOT
110455: PUSH
110456: LD_VAR 0 14
110460: PUSH
110461: LD_VAR 0 8
110465: ARRAY
110466: PPUSH
110467: CALL_OW 313
110471: AND
110472: IFFALSE 110545
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110474: LD_VAR 0 4
110478: PUSH
110479: LD_VAR 0 7
110483: ARRAY
110484: PPUSH
110485: LD_VAR 0 14
110489: PUSH
110490: LD_VAR 0 8
110494: ARRAY
110495: PPUSH
110496: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
110500: LD_ADDR_VAR 0 28
110504: PUSH
110505: LD_VAR 0 28
110509: PPUSH
110510: LD_VAR 0 28
110514: PUSH
110515: LD_INT 1
110517: PLUS
110518: PPUSH
110519: LD_VAR 0 14
110523: PUSH
110524: LD_VAR 0 8
110528: ARRAY
110529: PPUSH
110530: CALL_OW 1
110534: ST_TO_ADDR
// attacking := true ;
110535: LD_ADDR_VAR 0 29
110539: PUSH
110540: LD_INT 1
110542: ST_TO_ADDR
// break ;
110543: GO 110547
// end ; end ;
110545: GO 110414
110547: POP
110548: POP
// if not attacking and f_attack_depot then
110549: LD_VAR 0 29
110553: NOT
110554: PUSH
110555: LD_VAR 0 25
110559: AND
110560: IFFALSE 110655
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110562: LD_ADDR_VAR 0 13
110566: PUSH
110567: LD_VAR 0 14
110571: PPUSH
110572: LD_INT 2
110574: PUSH
110575: LD_INT 30
110577: PUSH
110578: LD_INT 0
110580: PUSH
110581: EMPTY
110582: LIST
110583: LIST
110584: PUSH
110585: LD_INT 30
110587: PUSH
110588: LD_INT 1
110590: PUSH
110591: EMPTY
110592: LIST
110593: LIST
110594: PUSH
110595: EMPTY
110596: LIST
110597: LIST
110598: LIST
110599: PPUSH
110600: CALL_OW 72
110604: ST_TO_ADDR
// if z then
110605: LD_VAR 0 13
110609: IFFALSE 110655
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
110611: LD_VAR 0 4
110615: PUSH
110616: LD_VAR 0 7
110620: ARRAY
110621: PPUSH
110622: LD_VAR 0 13
110626: PPUSH
110627: LD_VAR 0 4
110631: PUSH
110632: LD_VAR 0 7
110636: ARRAY
110637: PPUSH
110638: CALL_OW 74
110642: PPUSH
110643: CALL_OW 115
// attacking := true ;
110647: LD_ADDR_VAR 0 29
110651: PUSH
110652: LD_INT 1
110654: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
110655: LD_VAR 0 4
110659: PUSH
110660: LD_VAR 0 7
110664: ARRAY
110665: PPUSH
110666: CALL_OW 256
110670: PUSH
110671: LD_INT 500
110673: LESS
110674: IFFALSE 110700
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110676: LD_VAR 0 4
110680: PUSH
110681: LD_VAR 0 7
110685: ARRAY
110686: PPUSH
110687: LD_VAR 0 14
110691: PUSH
110692: LD_INT 1
110694: ARRAY
110695: PPUSH
110696: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
110700: LD_VAR 0 4
110704: PUSH
110705: LD_VAR 0 7
110709: ARRAY
110710: PPUSH
110711: CALL_OW 264
110715: PUSH
110716: LD_INT 49
110718: EQUAL
110719: IFFALSE 110840
// begin if not HasTask ( group [ i ] ) then
110721: LD_VAR 0 4
110725: PUSH
110726: LD_VAR 0 7
110730: ARRAY
110731: PPUSH
110732: CALL_OW 314
110736: NOT
110737: IFFALSE 110840
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
110739: LD_ADDR_VAR 0 9
110743: PUSH
110744: LD_INT 81
110746: PUSH
110747: LD_VAR 0 4
110751: PUSH
110752: LD_VAR 0 7
110756: ARRAY
110757: PPUSH
110758: CALL_OW 255
110762: PUSH
110763: EMPTY
110764: LIST
110765: LIST
110766: PPUSH
110767: CALL_OW 69
110771: PPUSH
110772: LD_VAR 0 4
110776: PUSH
110777: LD_VAR 0 7
110781: ARRAY
110782: PPUSH
110783: CALL_OW 74
110787: ST_TO_ADDR
// if k then
110788: LD_VAR 0 9
110792: IFFALSE 110840
// if GetDistUnits ( group [ i ] , k ) > 10 then
110794: LD_VAR 0 4
110798: PUSH
110799: LD_VAR 0 7
110803: ARRAY
110804: PPUSH
110805: LD_VAR 0 9
110809: PPUSH
110810: CALL_OW 296
110814: PUSH
110815: LD_INT 10
110817: GREATER
110818: IFFALSE 110840
// ComMoveUnit ( group [ i ] , k ) ;
110820: LD_VAR 0 4
110824: PUSH
110825: LD_VAR 0 7
110829: ARRAY
110830: PPUSH
110831: LD_VAR 0 9
110835: PPUSH
110836: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
110840: LD_VAR 0 4
110844: PUSH
110845: LD_VAR 0 7
110849: ARRAY
110850: PPUSH
110851: CALL_OW 256
110855: PUSH
110856: LD_INT 250
110858: LESS
110859: PUSH
110860: LD_VAR 0 4
110864: PUSH
110865: LD_VAR 0 7
110869: ARRAY
110870: PUSH
110871: LD_INT 21
110873: PUSH
110874: LD_INT 2
110876: PUSH
110877: EMPTY
110878: LIST
110879: LIST
110880: PUSH
110881: LD_INT 23
110883: PUSH
110884: LD_INT 2
110886: PUSH
110887: EMPTY
110888: LIST
110889: LIST
110890: PUSH
110891: EMPTY
110892: LIST
110893: LIST
110894: PPUSH
110895: CALL_OW 69
110899: IN
110900: AND
110901: IFFALSE 111026
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
110903: LD_ADDR_VAR 0 9
110907: PUSH
110908: LD_OWVAR 3
110912: PUSH
110913: LD_VAR 0 4
110917: PUSH
110918: LD_VAR 0 7
110922: ARRAY
110923: DIFF
110924: PPUSH
110925: LD_VAR 0 4
110929: PUSH
110930: LD_VAR 0 7
110934: ARRAY
110935: PPUSH
110936: CALL_OW 74
110940: ST_TO_ADDR
// if not k then
110941: LD_VAR 0 9
110945: NOT
110946: IFFALSE 110950
// continue ;
110948: GO 107365
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
110950: LD_VAR 0 9
110954: PUSH
110955: LD_INT 81
110957: PUSH
110958: LD_VAR 0 4
110962: PUSH
110963: LD_VAR 0 7
110967: ARRAY
110968: PPUSH
110969: CALL_OW 255
110973: PUSH
110974: EMPTY
110975: LIST
110976: LIST
110977: PPUSH
110978: CALL_OW 69
110982: IN
110983: PUSH
110984: LD_VAR 0 9
110988: PPUSH
110989: LD_VAR 0 4
110993: PUSH
110994: LD_VAR 0 7
110998: ARRAY
110999: PPUSH
111000: CALL_OW 296
111004: PUSH
111005: LD_INT 5
111007: LESS
111008: AND
111009: IFFALSE 111026
// ComAutodestruct ( group [ i ] ) ;
111011: LD_VAR 0 4
111015: PUSH
111016: LD_VAR 0 7
111020: ARRAY
111021: PPUSH
111022: CALL 47797 0 1
// end ; if f_attack_depot then
111026: LD_VAR 0 25
111030: IFFALSE 111142
// begin k := 6 ;
111032: LD_ADDR_VAR 0 9
111036: PUSH
111037: LD_INT 6
111039: ST_TO_ADDR
// if tmp < k then
111040: LD_VAR 0 14
111044: PUSH
111045: LD_VAR 0 9
111049: LESS
111050: IFFALSE 111062
// k := tmp ;
111052: LD_ADDR_VAR 0 9
111056: PUSH
111057: LD_VAR 0 14
111061: ST_TO_ADDR
// for j = 1 to k do
111062: LD_ADDR_VAR 0 8
111066: PUSH
111067: DOUBLE
111068: LD_INT 1
111070: DEC
111071: ST_TO_ADDR
111072: LD_VAR 0 9
111076: PUSH
111077: FOR_TO
111078: IFFALSE 111140
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
111080: LD_VAR 0 8
111084: PPUSH
111085: CALL_OW 266
111089: PUSH
111090: LD_INT 0
111092: PUSH
111093: LD_INT 1
111095: PUSH
111096: EMPTY
111097: LIST
111098: LIST
111099: IN
111100: IFFALSE 111138
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111102: LD_VAR 0 4
111106: PUSH
111107: LD_VAR 0 7
111111: ARRAY
111112: PPUSH
111113: LD_VAR 0 14
111117: PUSH
111118: LD_VAR 0 8
111122: ARRAY
111123: PPUSH
111124: CALL_OW 115
// attacking := true ;
111128: LD_ADDR_VAR 0 29
111132: PUSH
111133: LD_INT 1
111135: ST_TO_ADDR
// break ;
111136: GO 111140
// end ;
111138: GO 111077
111140: POP
111141: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
111142: LD_VAR 0 4
111146: PUSH
111147: LD_VAR 0 7
111151: ARRAY
111152: PPUSH
111153: CALL_OW 302
111157: PUSH
111158: LD_VAR 0 29
111162: NOT
111163: AND
111164: IFFALSE 111486
// begin if GetTag ( group [ i ] ) = 71 then
111166: LD_VAR 0 4
111170: PUSH
111171: LD_VAR 0 7
111175: ARRAY
111176: PPUSH
111177: CALL_OW 110
111181: PUSH
111182: LD_INT 71
111184: EQUAL
111185: IFFALSE 111226
// begin if HasTask ( group [ i ] ) then
111187: LD_VAR 0 4
111191: PUSH
111192: LD_VAR 0 7
111196: ARRAY
111197: PPUSH
111198: CALL_OW 314
111202: IFFALSE 111208
// continue else
111204: GO 107365
111206: GO 111226
// SetTag ( group [ i ] , 0 ) ;
111208: LD_VAR 0 4
111212: PUSH
111213: LD_VAR 0 7
111217: ARRAY
111218: PPUSH
111219: LD_INT 0
111221: PPUSH
111222: CALL_OW 109
// end ; k := 8 ;
111226: LD_ADDR_VAR 0 9
111230: PUSH
111231: LD_INT 8
111233: ST_TO_ADDR
// x := 0 ;
111234: LD_ADDR_VAR 0 10
111238: PUSH
111239: LD_INT 0
111241: ST_TO_ADDR
// if tmp < k then
111242: LD_VAR 0 14
111246: PUSH
111247: LD_VAR 0 9
111251: LESS
111252: IFFALSE 111264
// k := tmp ;
111254: LD_ADDR_VAR 0 9
111258: PUSH
111259: LD_VAR 0 14
111263: ST_TO_ADDR
// for j = 1 to k do
111264: LD_ADDR_VAR 0 8
111268: PUSH
111269: DOUBLE
111270: LD_INT 1
111272: DEC
111273: ST_TO_ADDR
111274: LD_VAR 0 9
111278: PUSH
111279: FOR_TO
111280: IFFALSE 111378
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
111282: LD_VAR 0 14
111286: PUSH
111287: LD_VAR 0 8
111291: ARRAY
111292: PPUSH
111293: CALL_OW 247
111297: PUSH
111298: LD_INT 1
111300: EQUAL
111301: PUSH
111302: LD_VAR 0 14
111306: PUSH
111307: LD_VAR 0 8
111311: ARRAY
111312: PPUSH
111313: CALL_OW 256
111317: PUSH
111318: LD_INT 250
111320: LESS
111321: PUSH
111322: LD_VAR 0 20
111326: AND
111327: PUSH
111328: LD_VAR 0 20
111332: NOT
111333: PUSH
111334: LD_VAR 0 14
111338: PUSH
111339: LD_VAR 0 8
111343: ARRAY
111344: PPUSH
111345: CALL_OW 256
111349: PUSH
111350: LD_INT 250
111352: GREATEREQUAL
111353: AND
111354: OR
111355: AND
111356: IFFALSE 111376
// begin x := tmp [ j ] ;
111358: LD_ADDR_VAR 0 10
111362: PUSH
111363: LD_VAR 0 14
111367: PUSH
111368: LD_VAR 0 8
111372: ARRAY
111373: ST_TO_ADDR
// break ;
111374: GO 111378
// end ;
111376: GO 111279
111378: POP
111379: POP
// if x then
111380: LD_VAR 0 10
111384: IFFALSE 111408
// ComAttackUnit ( group [ i ] , x ) else
111386: LD_VAR 0 4
111390: PUSH
111391: LD_VAR 0 7
111395: ARRAY
111396: PPUSH
111397: LD_VAR 0 10
111401: PPUSH
111402: CALL_OW 115
111406: GO 111432
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111408: LD_VAR 0 4
111412: PUSH
111413: LD_VAR 0 7
111417: ARRAY
111418: PPUSH
111419: LD_VAR 0 14
111423: PUSH
111424: LD_INT 1
111426: ARRAY
111427: PPUSH
111428: CALL_OW 115
// if not HasTask ( group [ i ] ) then
111432: LD_VAR 0 4
111436: PUSH
111437: LD_VAR 0 7
111441: ARRAY
111442: PPUSH
111443: CALL_OW 314
111447: NOT
111448: IFFALSE 111486
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
111450: LD_VAR 0 4
111454: PUSH
111455: LD_VAR 0 7
111459: ARRAY
111460: PPUSH
111461: LD_VAR 0 14
111465: PPUSH
111466: LD_VAR 0 4
111470: PUSH
111471: LD_VAR 0 7
111475: ARRAY
111476: PPUSH
111477: CALL_OW 74
111481: PPUSH
111482: CALL_OW 115
// end ; end ; end ;
111486: GO 107365
111488: POP
111489: POP
// wait ( 0 0$2 ) ;
111490: LD_INT 70
111492: PPUSH
111493: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
111497: LD_VAR 0 4
111501: NOT
111502: PUSH
111503: LD_VAR 0 4
111507: PUSH
111508: EMPTY
111509: EQUAL
111510: OR
111511: PUSH
111512: LD_INT 81
111514: PUSH
111515: LD_VAR 0 35
111519: PUSH
111520: EMPTY
111521: LIST
111522: LIST
111523: PPUSH
111524: CALL_OW 69
111528: NOT
111529: OR
111530: IFFALSE 107350
// end ;
111532: LD_VAR 0 2
111536: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
111537: LD_INT 0
111539: PPUSH
111540: PPUSH
111541: PPUSH
111542: PPUSH
111543: PPUSH
111544: PPUSH
// if not base or not mc_bases [ base ] or not solds then
111545: LD_VAR 0 1
111549: NOT
111550: PUSH
111551: LD_EXP 60
111555: PUSH
111556: LD_VAR 0 1
111560: ARRAY
111561: NOT
111562: OR
111563: PUSH
111564: LD_VAR 0 2
111568: NOT
111569: OR
111570: IFFALSE 111574
// exit ;
111572: GO 112128
// side := mc_sides [ base ] ;
111574: LD_ADDR_VAR 0 6
111578: PUSH
111579: LD_EXP 86
111583: PUSH
111584: LD_VAR 0 1
111588: ARRAY
111589: ST_TO_ADDR
// if not side then
111590: LD_VAR 0 6
111594: NOT
111595: IFFALSE 111599
// exit ;
111597: GO 112128
// for i in solds do
111599: LD_ADDR_VAR 0 7
111603: PUSH
111604: LD_VAR 0 2
111608: PUSH
111609: FOR_IN
111610: IFFALSE 111671
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
111612: LD_VAR 0 7
111616: PPUSH
111617: CALL_OW 310
111621: PPUSH
111622: CALL_OW 266
111626: PUSH
111627: LD_INT 32
111629: PUSH
111630: LD_INT 31
111632: PUSH
111633: EMPTY
111634: LIST
111635: LIST
111636: IN
111637: IFFALSE 111657
// solds := solds diff i else
111639: LD_ADDR_VAR 0 2
111643: PUSH
111644: LD_VAR 0 2
111648: PUSH
111649: LD_VAR 0 7
111653: DIFF
111654: ST_TO_ADDR
111655: GO 111669
// SetTag ( i , 18 ) ;
111657: LD_VAR 0 7
111661: PPUSH
111662: LD_INT 18
111664: PPUSH
111665: CALL_OW 109
111669: GO 111609
111671: POP
111672: POP
// if not solds then
111673: LD_VAR 0 2
111677: NOT
111678: IFFALSE 111682
// exit ;
111680: GO 112128
// repeat wait ( 0 0$2 ) ;
111682: LD_INT 70
111684: PPUSH
111685: CALL_OW 67
// enemy := mc_scan [ base ] ;
111689: LD_ADDR_VAR 0 4
111693: PUSH
111694: LD_EXP 83
111698: PUSH
111699: LD_VAR 0 1
111703: ARRAY
111704: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111705: LD_EXP 60
111709: PUSH
111710: LD_VAR 0 1
111714: ARRAY
111715: NOT
111716: PUSH
111717: LD_EXP 60
111721: PUSH
111722: LD_VAR 0 1
111726: ARRAY
111727: PUSH
111728: EMPTY
111729: EQUAL
111730: OR
111731: IFFALSE 111768
// begin for i in solds do
111733: LD_ADDR_VAR 0 7
111737: PUSH
111738: LD_VAR 0 2
111742: PUSH
111743: FOR_IN
111744: IFFALSE 111757
// ComStop ( i ) ;
111746: LD_VAR 0 7
111750: PPUSH
111751: CALL_OW 141
111755: GO 111743
111757: POP
111758: POP
// solds := [ ] ;
111759: LD_ADDR_VAR 0 2
111763: PUSH
111764: EMPTY
111765: ST_TO_ADDR
// exit ;
111766: GO 112128
// end ; for i in solds do
111768: LD_ADDR_VAR 0 7
111772: PUSH
111773: LD_VAR 0 2
111777: PUSH
111778: FOR_IN
111779: IFFALSE 112100
// begin if IsInUnit ( i ) then
111781: LD_VAR 0 7
111785: PPUSH
111786: CALL_OW 310
111790: IFFALSE 111801
// ComExitBuilding ( i ) ;
111792: LD_VAR 0 7
111796: PPUSH
111797: CALL_OW 122
// if GetLives ( i ) > 500 then
111801: LD_VAR 0 7
111805: PPUSH
111806: CALL_OW 256
111810: PUSH
111811: LD_INT 500
111813: GREATER
111814: IFFALSE 111867
// begin e := NearestUnitToUnit ( enemy , i ) ;
111816: LD_ADDR_VAR 0 5
111820: PUSH
111821: LD_VAR 0 4
111825: PPUSH
111826: LD_VAR 0 7
111830: PPUSH
111831: CALL_OW 74
111835: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
111836: LD_VAR 0 7
111840: PPUSH
111841: LD_VAR 0 5
111845: PPUSH
111846: CALL_OW 250
111850: PPUSH
111851: LD_VAR 0 5
111855: PPUSH
111856: CALL_OW 251
111860: PPUSH
111861: CALL_OW 114
// end else
111865: GO 112098
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
111867: LD_VAR 0 7
111871: PPUSH
111872: LD_EXP 60
111876: PUSH
111877: LD_VAR 0 1
111881: ARRAY
111882: PPUSH
111883: LD_INT 2
111885: PUSH
111886: LD_INT 30
111888: PUSH
111889: LD_INT 0
111891: PUSH
111892: EMPTY
111893: LIST
111894: LIST
111895: PUSH
111896: LD_INT 30
111898: PUSH
111899: LD_INT 1
111901: PUSH
111902: EMPTY
111903: LIST
111904: LIST
111905: PUSH
111906: LD_INT 30
111908: PUSH
111909: LD_INT 6
111911: PUSH
111912: EMPTY
111913: LIST
111914: LIST
111915: PUSH
111916: EMPTY
111917: LIST
111918: LIST
111919: LIST
111920: LIST
111921: PPUSH
111922: CALL_OW 72
111926: PPUSH
111927: LD_VAR 0 7
111931: PPUSH
111932: CALL_OW 74
111936: PPUSH
111937: CALL_OW 296
111941: PUSH
111942: LD_INT 10
111944: GREATER
111945: IFFALSE 112098
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
111947: LD_ADDR_VAR 0 8
111951: PUSH
111952: LD_EXP 60
111956: PUSH
111957: LD_VAR 0 1
111961: ARRAY
111962: PPUSH
111963: LD_INT 2
111965: PUSH
111966: LD_INT 30
111968: PUSH
111969: LD_INT 0
111971: PUSH
111972: EMPTY
111973: LIST
111974: LIST
111975: PUSH
111976: LD_INT 30
111978: PUSH
111979: LD_INT 1
111981: PUSH
111982: EMPTY
111983: LIST
111984: LIST
111985: PUSH
111986: LD_INT 30
111988: PUSH
111989: LD_INT 6
111991: PUSH
111992: EMPTY
111993: LIST
111994: LIST
111995: PUSH
111996: EMPTY
111997: LIST
111998: LIST
111999: LIST
112000: LIST
112001: PPUSH
112002: CALL_OW 72
112006: PPUSH
112007: LD_VAR 0 7
112011: PPUSH
112012: CALL_OW 74
112016: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
112017: LD_VAR 0 7
112021: PPUSH
112022: LD_VAR 0 8
112026: PPUSH
112027: CALL_OW 250
112031: PPUSH
112032: LD_INT 3
112034: PPUSH
112035: LD_INT 5
112037: PPUSH
112038: CALL_OW 272
112042: PPUSH
112043: LD_VAR 0 8
112047: PPUSH
112048: CALL_OW 251
112052: PPUSH
112053: LD_INT 3
112055: PPUSH
112056: LD_INT 5
112058: PPUSH
112059: CALL_OW 273
112063: PPUSH
112064: CALL_OW 111
// SetTag ( i , 0 ) ;
112068: LD_VAR 0 7
112072: PPUSH
112073: LD_INT 0
112075: PPUSH
112076: CALL_OW 109
// solds := solds diff i ;
112080: LD_ADDR_VAR 0 2
112084: PUSH
112085: LD_VAR 0 2
112089: PUSH
112090: LD_VAR 0 7
112094: DIFF
112095: ST_TO_ADDR
// continue ;
112096: GO 111778
// end ; end ;
112098: GO 111778
112100: POP
112101: POP
// until not solds or not enemy ;
112102: LD_VAR 0 2
112106: NOT
112107: PUSH
112108: LD_VAR 0 4
112112: NOT
112113: OR
112114: IFFALSE 111682
// MC_Reset ( base , 18 ) ;
112116: LD_VAR 0 1
112120: PPUSH
112121: LD_INT 18
112123: PPUSH
112124: CALL 60234 0 2
// end ;
112128: LD_VAR 0 3
112132: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
112133: LD_INT 0
112135: PPUSH
112136: PPUSH
112137: PPUSH
112138: PPUSH
112139: PPUSH
112140: PPUSH
112141: PPUSH
112142: PPUSH
112143: PPUSH
112144: PPUSH
112145: PPUSH
112146: PPUSH
112147: PPUSH
112148: PPUSH
112149: PPUSH
112150: PPUSH
112151: PPUSH
112152: PPUSH
112153: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
112154: LD_ADDR_VAR 0 12
112158: PUSH
112159: LD_EXP 60
112163: PUSH
112164: LD_VAR 0 1
112168: ARRAY
112169: PPUSH
112170: LD_INT 25
112172: PUSH
112173: LD_INT 3
112175: PUSH
112176: EMPTY
112177: LIST
112178: LIST
112179: PPUSH
112180: CALL_OW 72
112184: ST_TO_ADDR
// if mc_remote_driver [ base ] then
112185: LD_EXP 100
112189: PUSH
112190: LD_VAR 0 1
112194: ARRAY
112195: IFFALSE 112219
// mechs := mechs diff mc_remote_driver [ base ] ;
112197: LD_ADDR_VAR 0 12
112201: PUSH
112202: LD_VAR 0 12
112206: PUSH
112207: LD_EXP 100
112211: PUSH
112212: LD_VAR 0 1
112216: ARRAY
112217: DIFF
112218: ST_TO_ADDR
// for i in mechs do
112219: LD_ADDR_VAR 0 4
112223: PUSH
112224: LD_VAR 0 12
112228: PUSH
112229: FOR_IN
112230: IFFALSE 112265
// if GetTag ( i ) > 0 then
112232: LD_VAR 0 4
112236: PPUSH
112237: CALL_OW 110
112241: PUSH
112242: LD_INT 0
112244: GREATER
112245: IFFALSE 112263
// mechs := mechs diff i ;
112247: LD_ADDR_VAR 0 12
112251: PUSH
112252: LD_VAR 0 12
112256: PUSH
112257: LD_VAR 0 4
112261: DIFF
112262: ST_TO_ADDR
112263: GO 112229
112265: POP
112266: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
112267: LD_ADDR_VAR 0 8
112271: PUSH
112272: LD_EXP 60
112276: PUSH
112277: LD_VAR 0 1
112281: ARRAY
112282: PPUSH
112283: LD_INT 2
112285: PUSH
112286: LD_INT 25
112288: PUSH
112289: LD_INT 1
112291: PUSH
112292: EMPTY
112293: LIST
112294: LIST
112295: PUSH
112296: LD_INT 25
112298: PUSH
112299: LD_INT 5
112301: PUSH
112302: EMPTY
112303: LIST
112304: LIST
112305: PUSH
112306: LD_INT 25
112308: PUSH
112309: LD_INT 8
112311: PUSH
112312: EMPTY
112313: LIST
112314: LIST
112315: PUSH
112316: LD_INT 25
112318: PUSH
112319: LD_INT 9
112321: PUSH
112322: EMPTY
112323: LIST
112324: LIST
112325: PUSH
112326: EMPTY
112327: LIST
112328: LIST
112329: LIST
112330: LIST
112331: LIST
112332: PPUSH
112333: CALL_OW 72
112337: ST_TO_ADDR
// if not defenders and not solds then
112338: LD_VAR 0 2
112342: NOT
112343: PUSH
112344: LD_VAR 0 8
112348: NOT
112349: AND
112350: IFFALSE 112354
// exit ;
112352: GO 114124
// depot_under_attack := false ;
112354: LD_ADDR_VAR 0 16
112358: PUSH
112359: LD_INT 0
112361: ST_TO_ADDR
// sold_defenders := [ ] ;
112362: LD_ADDR_VAR 0 17
112366: PUSH
112367: EMPTY
112368: ST_TO_ADDR
// if mechs then
112369: LD_VAR 0 12
112373: IFFALSE 112526
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
112375: LD_ADDR_VAR 0 4
112379: PUSH
112380: LD_VAR 0 2
112384: PPUSH
112385: LD_INT 21
112387: PUSH
112388: LD_INT 2
112390: PUSH
112391: EMPTY
112392: LIST
112393: LIST
112394: PPUSH
112395: CALL_OW 72
112399: PUSH
112400: FOR_IN
112401: IFFALSE 112524
// begin if GetTag ( i ) <> 20 then
112403: LD_VAR 0 4
112407: PPUSH
112408: CALL_OW 110
112412: PUSH
112413: LD_INT 20
112415: NONEQUAL
112416: IFFALSE 112430
// SetTag ( i , 20 ) ;
112418: LD_VAR 0 4
112422: PPUSH
112423: LD_INT 20
112425: PPUSH
112426: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
112430: LD_VAR 0 4
112434: PPUSH
112435: CALL_OW 263
112439: PUSH
112440: LD_INT 1
112442: EQUAL
112443: PUSH
112444: LD_VAR 0 4
112448: PPUSH
112449: CALL_OW 311
112453: NOT
112454: AND
112455: IFFALSE 112522
// begin un := mechs [ 1 ] ;
112457: LD_ADDR_VAR 0 10
112461: PUSH
112462: LD_VAR 0 12
112466: PUSH
112467: LD_INT 1
112469: ARRAY
112470: ST_TO_ADDR
// ComExit ( un ) ;
112471: LD_VAR 0 10
112475: PPUSH
112476: CALL 52663 0 1
// AddComEnterUnit ( un , i ) ;
112480: LD_VAR 0 10
112484: PPUSH
112485: LD_VAR 0 4
112489: PPUSH
112490: CALL_OW 180
// SetTag ( un , 19 ) ;
112494: LD_VAR 0 10
112498: PPUSH
112499: LD_INT 19
112501: PPUSH
112502: CALL_OW 109
// mechs := mechs diff un ;
112506: LD_ADDR_VAR 0 12
112510: PUSH
112511: LD_VAR 0 12
112515: PUSH
112516: LD_VAR 0 10
112520: DIFF
112521: ST_TO_ADDR
// end ; end ;
112522: GO 112400
112524: POP
112525: POP
// if solds then
112526: LD_VAR 0 8
112530: IFFALSE 112589
// for i in solds do
112532: LD_ADDR_VAR 0 4
112536: PUSH
112537: LD_VAR 0 8
112541: PUSH
112542: FOR_IN
112543: IFFALSE 112587
// if not GetTag ( i ) then
112545: LD_VAR 0 4
112549: PPUSH
112550: CALL_OW 110
112554: NOT
112555: IFFALSE 112585
// begin defenders := defenders union i ;
112557: LD_ADDR_VAR 0 2
112561: PUSH
112562: LD_VAR 0 2
112566: PUSH
112567: LD_VAR 0 4
112571: UNION
112572: ST_TO_ADDR
// SetTag ( i , 18 ) ;
112573: LD_VAR 0 4
112577: PPUSH
112578: LD_INT 18
112580: PPUSH
112581: CALL_OW 109
// end ;
112585: GO 112542
112587: POP
112588: POP
// repeat wait ( 0 0$2 ) ;
112589: LD_INT 70
112591: PPUSH
112592: CALL_OW 67
// enemy := mc_scan [ base ] ;
112596: LD_ADDR_VAR 0 21
112600: PUSH
112601: LD_EXP 83
112605: PUSH
112606: LD_VAR 0 1
112610: ARRAY
112611: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112612: LD_EXP 60
112616: PUSH
112617: LD_VAR 0 1
112621: ARRAY
112622: NOT
112623: PUSH
112624: LD_EXP 60
112628: PUSH
112629: LD_VAR 0 1
112633: ARRAY
112634: PUSH
112635: EMPTY
112636: EQUAL
112637: OR
112638: IFFALSE 112675
// begin for i in defenders do
112640: LD_ADDR_VAR 0 4
112644: PUSH
112645: LD_VAR 0 2
112649: PUSH
112650: FOR_IN
112651: IFFALSE 112664
// ComStop ( i ) ;
112653: LD_VAR 0 4
112657: PPUSH
112658: CALL_OW 141
112662: GO 112650
112664: POP
112665: POP
// defenders := [ ] ;
112666: LD_ADDR_VAR 0 2
112670: PUSH
112671: EMPTY
112672: ST_TO_ADDR
// exit ;
112673: GO 114124
// end ; for i in defenders do
112675: LD_ADDR_VAR 0 4
112679: PUSH
112680: LD_VAR 0 2
112684: PUSH
112685: FOR_IN
112686: IFFALSE 113584
// begin e := NearestUnitToUnit ( enemy , i ) ;
112688: LD_ADDR_VAR 0 13
112692: PUSH
112693: LD_VAR 0 21
112697: PPUSH
112698: LD_VAR 0 4
112702: PPUSH
112703: CALL_OW 74
112707: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
112708: LD_ADDR_VAR 0 7
112712: PUSH
112713: LD_EXP 60
112717: PUSH
112718: LD_VAR 0 1
112722: ARRAY
112723: PPUSH
112724: LD_INT 2
112726: PUSH
112727: LD_INT 30
112729: PUSH
112730: LD_INT 0
112732: PUSH
112733: EMPTY
112734: LIST
112735: LIST
112736: PUSH
112737: LD_INT 30
112739: PUSH
112740: LD_INT 1
112742: PUSH
112743: EMPTY
112744: LIST
112745: LIST
112746: PUSH
112747: EMPTY
112748: LIST
112749: LIST
112750: LIST
112751: PPUSH
112752: CALL_OW 72
112756: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
112757: LD_ADDR_VAR 0 16
112761: PUSH
112762: LD_VAR 0 7
112766: NOT
112767: PUSH
112768: LD_VAR 0 7
112772: PPUSH
112773: LD_INT 3
112775: PUSH
112776: LD_INT 24
112778: PUSH
112779: LD_INT 600
112781: PUSH
112782: EMPTY
112783: LIST
112784: LIST
112785: PUSH
112786: EMPTY
112787: LIST
112788: LIST
112789: PPUSH
112790: CALL_OW 72
112794: OR
112795: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
112796: LD_VAR 0 4
112800: PPUSH
112801: CALL_OW 247
112805: PUSH
112806: LD_INT 2
112808: DOUBLE
112809: EQUAL
112810: IFTRUE 112814
112812: GO 113210
112814: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
112815: LD_VAR 0 4
112819: PPUSH
112820: CALL_OW 256
112824: PUSH
112825: LD_INT 1000
112827: EQUAL
112828: PUSH
112829: LD_VAR 0 4
112833: PPUSH
112834: LD_VAR 0 13
112838: PPUSH
112839: CALL_OW 296
112843: PUSH
112844: LD_INT 40
112846: LESS
112847: PUSH
112848: LD_VAR 0 13
112852: PPUSH
112853: LD_EXP 85
112857: PUSH
112858: LD_VAR 0 1
112862: ARRAY
112863: PPUSH
112864: CALL_OW 308
112868: OR
112869: AND
112870: IFFALSE 112992
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
112872: LD_VAR 0 4
112876: PPUSH
112877: CALL_OW 262
112881: PUSH
112882: LD_INT 1
112884: EQUAL
112885: PUSH
112886: LD_VAR 0 4
112890: PPUSH
112891: CALL_OW 261
112895: PUSH
112896: LD_INT 30
112898: LESS
112899: AND
112900: PUSH
112901: LD_VAR 0 7
112905: AND
112906: IFFALSE 112976
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
112908: LD_VAR 0 4
112912: PPUSH
112913: LD_VAR 0 7
112917: PPUSH
112918: LD_VAR 0 4
112922: PPUSH
112923: CALL_OW 74
112927: PPUSH
112928: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
112932: LD_VAR 0 4
112936: PPUSH
112937: LD_VAR 0 7
112941: PPUSH
112942: LD_VAR 0 4
112946: PPUSH
112947: CALL_OW 74
112951: PPUSH
112952: CALL_OW 296
112956: PUSH
112957: LD_INT 6
112959: LESS
112960: IFFALSE 112974
// SetFuel ( i , 100 ) ;
112962: LD_VAR 0 4
112966: PPUSH
112967: LD_INT 100
112969: PPUSH
112970: CALL_OW 240
// end else
112974: GO 112990
// ComAttackUnit ( i , e ) ;
112976: LD_VAR 0 4
112980: PPUSH
112981: LD_VAR 0 13
112985: PPUSH
112986: CALL_OW 115
// end else
112990: GO 113093
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
112992: LD_VAR 0 13
112996: PPUSH
112997: LD_EXP 85
113001: PUSH
113002: LD_VAR 0 1
113006: ARRAY
113007: PPUSH
113008: CALL_OW 308
113012: NOT
113013: PUSH
113014: LD_VAR 0 4
113018: PPUSH
113019: LD_VAR 0 13
113023: PPUSH
113024: CALL_OW 296
113028: PUSH
113029: LD_INT 40
113031: GREATEREQUAL
113032: AND
113033: PUSH
113034: LD_VAR 0 4
113038: PPUSH
113039: CALL_OW 256
113043: PUSH
113044: LD_INT 650
113046: LESSEQUAL
113047: OR
113048: PUSH
113049: LD_VAR 0 4
113053: PPUSH
113054: LD_EXP 84
113058: PUSH
113059: LD_VAR 0 1
113063: ARRAY
113064: PPUSH
113065: CALL_OW 308
113069: NOT
113070: AND
113071: IFFALSE 113093
// ComMoveToArea ( i , mc_parking [ base ] ) ;
113073: LD_VAR 0 4
113077: PPUSH
113078: LD_EXP 84
113082: PUSH
113083: LD_VAR 0 1
113087: ARRAY
113088: PPUSH
113089: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
113093: LD_VAR 0 4
113097: PPUSH
113098: CALL_OW 256
113102: PUSH
113103: LD_INT 1000
113105: LESS
113106: PUSH
113107: LD_VAR 0 4
113111: PPUSH
113112: CALL_OW 263
113116: PUSH
113117: LD_INT 1
113119: EQUAL
113120: AND
113121: PUSH
113122: LD_VAR 0 4
113126: PPUSH
113127: CALL_OW 311
113131: AND
113132: PUSH
113133: LD_VAR 0 4
113137: PPUSH
113138: LD_EXP 84
113142: PUSH
113143: LD_VAR 0 1
113147: ARRAY
113148: PPUSH
113149: CALL_OW 308
113153: AND
113154: IFFALSE 113208
// begin mech := IsDrivenBy ( i ) ;
113156: LD_ADDR_VAR 0 9
113160: PUSH
113161: LD_VAR 0 4
113165: PPUSH
113166: CALL_OW 311
113170: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
113171: LD_VAR 0 9
113175: PPUSH
113176: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
113180: LD_VAR 0 9
113184: PPUSH
113185: LD_VAR 0 4
113189: PPUSH
113190: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
113194: LD_VAR 0 9
113198: PPUSH
113199: LD_VAR 0 4
113203: PPUSH
113204: CALL_OW 180
// end ; end ; unit_human :
113208: GO 113555
113210: LD_INT 1
113212: DOUBLE
113213: EQUAL
113214: IFTRUE 113218
113216: GO 113554
113218: POP
// begin b := IsInUnit ( i ) ;
113219: LD_ADDR_VAR 0 18
113223: PUSH
113224: LD_VAR 0 4
113228: PPUSH
113229: CALL_OW 310
113233: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
113234: LD_ADDR_VAR 0 19
113238: PUSH
113239: LD_VAR 0 18
113243: NOT
113244: PUSH
113245: LD_VAR 0 18
113249: PPUSH
113250: CALL_OW 266
113254: PUSH
113255: LD_INT 32
113257: PUSH
113258: LD_INT 31
113260: PUSH
113261: EMPTY
113262: LIST
113263: LIST
113264: IN
113265: OR
113266: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
113267: LD_VAR 0 18
113271: PPUSH
113272: CALL_OW 266
113276: PUSH
113277: LD_INT 5
113279: EQUAL
113280: PUSH
113281: LD_VAR 0 4
113285: PPUSH
113286: CALL_OW 257
113290: PUSH
113291: LD_INT 1
113293: PUSH
113294: LD_INT 2
113296: PUSH
113297: LD_INT 3
113299: PUSH
113300: LD_INT 4
113302: PUSH
113303: EMPTY
113304: LIST
113305: LIST
113306: LIST
113307: LIST
113308: IN
113309: AND
113310: IFFALSE 113347
// begin class := AllowSpecClass ( i ) ;
113312: LD_ADDR_VAR 0 20
113316: PUSH
113317: LD_VAR 0 4
113321: PPUSH
113322: CALL 16650 0 1
113326: ST_TO_ADDR
// if class then
113327: LD_VAR 0 20
113331: IFFALSE 113347
// ComChangeProfession ( i , class ) ;
113333: LD_VAR 0 4
113337: PPUSH
113338: LD_VAR 0 20
113342: PPUSH
113343: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
113347: LD_VAR 0 16
113351: PUSH
113352: LD_VAR 0 2
113356: PPUSH
113357: LD_INT 21
113359: PUSH
113360: LD_INT 2
113362: PUSH
113363: EMPTY
113364: LIST
113365: LIST
113366: PPUSH
113367: CALL_OW 72
113371: PUSH
113372: LD_INT 1
113374: LESSEQUAL
113375: OR
113376: PUSH
113377: LD_VAR 0 19
113381: AND
113382: PUSH
113383: LD_VAR 0 4
113387: PUSH
113388: LD_VAR 0 17
113392: IN
113393: NOT
113394: AND
113395: IFFALSE 113488
// begin if b then
113397: LD_VAR 0 18
113401: IFFALSE 113450
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
113403: LD_VAR 0 18
113407: PPUSH
113408: LD_VAR 0 21
113412: PPUSH
113413: LD_VAR 0 18
113417: PPUSH
113418: CALL_OW 74
113422: PPUSH
113423: CALL_OW 296
113427: PUSH
113428: LD_INT 10
113430: LESS
113431: PUSH
113432: LD_VAR 0 18
113436: PPUSH
113437: CALL_OW 461
113441: PUSH
113442: LD_INT 7
113444: NONEQUAL
113445: AND
113446: IFFALSE 113450
// continue ;
113448: GO 112685
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
113450: LD_ADDR_VAR 0 17
113454: PUSH
113455: LD_VAR 0 17
113459: PPUSH
113460: LD_VAR 0 17
113464: PUSH
113465: LD_INT 1
113467: PLUS
113468: PPUSH
113469: LD_VAR 0 4
113473: PPUSH
113474: CALL_OW 1
113478: ST_TO_ADDR
// ComExitBuilding ( i ) ;
113479: LD_VAR 0 4
113483: PPUSH
113484: CALL_OW 122
// end ; if sold_defenders then
113488: LD_VAR 0 17
113492: IFFALSE 113552
// if i in sold_defenders then
113494: LD_VAR 0 4
113498: PUSH
113499: LD_VAR 0 17
113503: IN
113504: IFFALSE 113552
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
113506: LD_VAR 0 4
113510: PPUSH
113511: CALL_OW 314
113515: NOT
113516: PUSH
113517: LD_VAR 0 4
113521: PPUSH
113522: LD_VAR 0 13
113526: PPUSH
113527: CALL_OW 296
113531: PUSH
113532: LD_INT 30
113534: LESS
113535: AND
113536: IFFALSE 113552
// ComAttackUnit ( i , e ) ;
113538: LD_VAR 0 4
113542: PPUSH
113543: LD_VAR 0 13
113547: PPUSH
113548: CALL_OW 115
// end ; end ; end ;
113552: GO 113555
113554: POP
// if IsDead ( i ) then
113555: LD_VAR 0 4
113559: PPUSH
113560: CALL_OW 301
113564: IFFALSE 113582
// defenders := defenders diff i ;
113566: LD_ADDR_VAR 0 2
113570: PUSH
113571: LD_VAR 0 2
113575: PUSH
113576: LD_VAR 0 4
113580: DIFF
113581: ST_TO_ADDR
// end ;
113582: GO 112685
113584: POP
113585: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
113586: LD_VAR 0 21
113590: NOT
113591: PUSH
113592: LD_VAR 0 2
113596: NOT
113597: OR
113598: PUSH
113599: LD_EXP 60
113603: PUSH
113604: LD_VAR 0 1
113608: ARRAY
113609: NOT
113610: OR
113611: IFFALSE 112589
// MC_Reset ( base , 18 ) ;
113613: LD_VAR 0 1
113617: PPUSH
113618: LD_INT 18
113620: PPUSH
113621: CALL 60234 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113625: LD_ADDR_VAR 0 2
113629: PUSH
113630: LD_VAR 0 2
113634: PUSH
113635: LD_VAR 0 2
113639: PPUSH
113640: LD_INT 2
113642: PUSH
113643: LD_INT 25
113645: PUSH
113646: LD_INT 1
113648: PUSH
113649: EMPTY
113650: LIST
113651: LIST
113652: PUSH
113653: LD_INT 25
113655: PUSH
113656: LD_INT 5
113658: PUSH
113659: EMPTY
113660: LIST
113661: LIST
113662: PUSH
113663: LD_INT 25
113665: PUSH
113666: LD_INT 8
113668: PUSH
113669: EMPTY
113670: LIST
113671: LIST
113672: PUSH
113673: LD_INT 25
113675: PUSH
113676: LD_INT 9
113678: PUSH
113679: EMPTY
113680: LIST
113681: LIST
113682: PUSH
113683: EMPTY
113684: LIST
113685: LIST
113686: LIST
113687: LIST
113688: LIST
113689: PPUSH
113690: CALL_OW 72
113694: DIFF
113695: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
113696: LD_VAR 0 21
113700: NOT
113701: PUSH
113702: LD_VAR 0 2
113706: PPUSH
113707: LD_INT 21
113709: PUSH
113710: LD_INT 2
113712: PUSH
113713: EMPTY
113714: LIST
113715: LIST
113716: PPUSH
113717: CALL_OW 72
113721: AND
113722: IFFALSE 114060
// begin tmp := FilterByTag ( defenders , 19 ) ;
113724: LD_ADDR_VAR 0 11
113728: PUSH
113729: LD_VAR 0 2
113733: PPUSH
113734: LD_INT 19
113736: PPUSH
113737: CALL 49839 0 2
113741: ST_TO_ADDR
// if tmp then
113742: LD_VAR 0 11
113746: IFFALSE 113816
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
113748: LD_ADDR_VAR 0 11
113752: PUSH
113753: LD_VAR 0 11
113757: PPUSH
113758: LD_INT 25
113760: PUSH
113761: LD_INT 3
113763: PUSH
113764: EMPTY
113765: LIST
113766: LIST
113767: PPUSH
113768: CALL_OW 72
113772: ST_TO_ADDR
// if tmp then
113773: LD_VAR 0 11
113777: IFFALSE 113816
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
113779: LD_ADDR_EXP 72
113783: PUSH
113784: LD_EXP 72
113788: PPUSH
113789: LD_VAR 0 1
113793: PPUSH
113794: LD_EXP 72
113798: PUSH
113799: LD_VAR 0 1
113803: ARRAY
113804: PUSH
113805: LD_VAR 0 11
113809: UNION
113810: PPUSH
113811: CALL_OW 1
113815: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
113816: LD_VAR 0 1
113820: PPUSH
113821: LD_INT 19
113823: PPUSH
113824: CALL 60234 0 2
// repeat wait ( 0 0$1 ) ;
113828: LD_INT 35
113830: PPUSH
113831: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113835: LD_EXP 60
113839: PUSH
113840: LD_VAR 0 1
113844: ARRAY
113845: NOT
113846: PUSH
113847: LD_EXP 60
113851: PUSH
113852: LD_VAR 0 1
113856: ARRAY
113857: PUSH
113858: EMPTY
113859: EQUAL
113860: OR
113861: IFFALSE 113898
// begin for i in defenders do
113863: LD_ADDR_VAR 0 4
113867: PUSH
113868: LD_VAR 0 2
113872: PUSH
113873: FOR_IN
113874: IFFALSE 113887
// ComStop ( i ) ;
113876: LD_VAR 0 4
113880: PPUSH
113881: CALL_OW 141
113885: GO 113873
113887: POP
113888: POP
// defenders := [ ] ;
113889: LD_ADDR_VAR 0 2
113893: PUSH
113894: EMPTY
113895: ST_TO_ADDR
// exit ;
113896: GO 114124
// end ; for i in defenders do
113898: LD_ADDR_VAR 0 4
113902: PUSH
113903: LD_VAR 0 2
113907: PUSH
113908: FOR_IN
113909: IFFALSE 113998
// begin if not IsInArea ( i , mc_parking [ base ] ) then
113911: LD_VAR 0 4
113915: PPUSH
113916: LD_EXP 84
113920: PUSH
113921: LD_VAR 0 1
113925: ARRAY
113926: PPUSH
113927: CALL_OW 308
113931: NOT
113932: IFFALSE 113956
// ComMoveToArea ( i , mc_parking [ base ] ) else
113934: LD_VAR 0 4
113938: PPUSH
113939: LD_EXP 84
113943: PUSH
113944: LD_VAR 0 1
113948: ARRAY
113949: PPUSH
113950: CALL_OW 113
113954: GO 113996
// if GetControl ( i ) = control_manual then
113956: LD_VAR 0 4
113960: PPUSH
113961: CALL_OW 263
113965: PUSH
113966: LD_INT 1
113968: EQUAL
113969: IFFALSE 113996
// if IsDrivenBy ( i ) then
113971: LD_VAR 0 4
113975: PPUSH
113976: CALL_OW 311
113980: IFFALSE 113996
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
113982: LD_VAR 0 4
113986: PPUSH
113987: CALL_OW 311
113991: PPUSH
113992: CALL_OW 121
// end ;
113996: GO 113908
113998: POP
113999: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114000: LD_VAR 0 2
114004: PPUSH
114005: LD_INT 95
114007: PUSH
114008: LD_EXP 84
114012: PUSH
114013: LD_VAR 0 1
114017: ARRAY
114018: PUSH
114019: EMPTY
114020: LIST
114021: LIST
114022: PPUSH
114023: CALL_OW 72
114027: PUSH
114028: LD_VAR 0 2
114032: EQUAL
114033: PUSH
114034: LD_EXP 83
114038: PUSH
114039: LD_VAR 0 1
114043: ARRAY
114044: OR
114045: PUSH
114046: LD_EXP 60
114050: PUSH
114051: LD_VAR 0 1
114055: ARRAY
114056: NOT
114057: OR
114058: IFFALSE 113828
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
114060: LD_ADDR_EXP 82
114064: PUSH
114065: LD_EXP 82
114069: PPUSH
114070: LD_VAR 0 1
114074: PPUSH
114075: LD_VAR 0 2
114079: PPUSH
114080: LD_INT 21
114082: PUSH
114083: LD_INT 2
114085: PUSH
114086: EMPTY
114087: LIST
114088: LIST
114089: PPUSH
114090: CALL_OW 72
114094: PPUSH
114095: CALL_OW 1
114099: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
114100: LD_VAR 0 1
114104: PPUSH
114105: LD_INT 19
114107: PPUSH
114108: CALL 60234 0 2
// MC_Reset ( base , 20 ) ;
114112: LD_VAR 0 1
114116: PPUSH
114117: LD_INT 20
114119: PPUSH
114120: CALL 60234 0 2
// end ; end_of_file
114124: LD_VAR 0 3
114128: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
114129: LD_VAR 0 1
114133: PUSH
114134: LD_INT 200
114136: DOUBLE
114137: GREATEREQUAL
114138: IFFALSE 114146
114140: LD_INT 299
114142: DOUBLE
114143: LESSEQUAL
114144: IFTRUE 114148
114146: GO 114180
114148: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
114149: LD_VAR 0 1
114153: PPUSH
114154: LD_VAR 0 2
114158: PPUSH
114159: LD_VAR 0 3
114163: PPUSH
114164: LD_VAR 0 4
114168: PPUSH
114169: LD_VAR 0 5
114173: PPUSH
114174: CALL 102895 0 5
114178: GO 114257
114180: LD_INT 300
114182: DOUBLE
114183: GREATEREQUAL
114184: IFFALSE 114192
114186: LD_INT 399
114188: DOUBLE
114189: LESSEQUAL
114190: IFTRUE 114194
114192: GO 114256
114194: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
114195: LD_VAR 0 1
114199: PPUSH
114200: LD_VAR 0 2
114204: PPUSH
114205: LD_VAR 0 3
114209: PPUSH
114210: LD_VAR 0 4
114214: PPUSH
114215: LD_VAR 0 5
114219: PPUSH
114220: LD_VAR 0 6
114224: PPUSH
114225: LD_VAR 0 7
114229: PPUSH
114230: LD_VAR 0 8
114234: PPUSH
114235: LD_VAR 0 9
114239: PPUSH
114240: LD_VAR 0 10
114244: PPUSH
114245: LD_VAR 0 11
114249: PPUSH
114250: CALL 99224 0 11
114254: GO 114257
114256: POP
// end ;
114257: PPOPN 11
114259: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
114260: LD_VAR 0 1
114264: PPUSH
114265: LD_VAR 0 2
114269: PPUSH
114270: LD_VAR 0 3
114274: PPUSH
114275: LD_VAR 0 4
114279: PPUSH
114280: LD_VAR 0 5
114284: PPUSH
114285: CALL 102631 0 5
// end ; end_of_file
114289: PPOPN 5
114291: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
114292: LD_VAR 0 1
114296: PPUSH
114297: LD_VAR 0 2
114301: PPUSH
114302: LD_VAR 0 3
114306: PPUSH
114307: LD_VAR 0 4
114311: PPUSH
114312: LD_VAR 0 5
114316: PPUSH
114317: LD_VAR 0 6
114321: PPUSH
114322: CALL 86917 0 6
// end ;
114326: PPOPN 6
114328: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
114329: LD_INT 0
114331: PPUSH
// begin if not units then
114332: LD_VAR 0 1
114336: NOT
114337: IFFALSE 114341
// exit ;
114339: GO 114341
// end ;
114341: PPOPN 7
114343: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
114344: CALL 86888 0 0
// end ;
114348: PPOPN 1
114350: END
