// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 644 0 0
// InitGlobalVariables ;
  19: CALL 82276 0 0
// InitMacro ;
  23: CALL 52017 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 47309 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 47309 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 47309 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 5
 128: PPUSH
 129: LD_INT 0
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 12
 143: PPUSH
 144: LD_INT 0
 146: PPUSH
 147: CALL 47309 0 9
// PrepareArabian ;
 151: CALL 3719 0 0
// PrepareRussian ;
 155: CALL 2850 0 0
// PrepareAlliance ;
 159: CALL 846 0 0
// MC_Start ( ) ;
 163: CALL 54182 0 0
// if debug then
 167: LD_EXP 1
 171: IFFALSE 180
// FogOff ( 1 ) ;
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 344
// Action ;
 180: CALL 6922 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 83
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 84
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 75547 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 54
 256: PPUSH
 257: CALL 75973 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 76431 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 76700 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 1
 310: PUSH
 311: LD_INT 2
 313: PUSH
 314: LD_EXP 109
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: LIST
 323: LIST
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 75913 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_INT 12
 338: PUSH
 339: LD_INT 14
 341: PUSH
 342: LD_INT 10
 344: PUSH
 345: LD_INT 11
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 76607 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_EXP 51
 365: PPUSH
 366: CALL 75973 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 370: LD_INT 2
 372: PPUSH
 373: LD_INT 8
 375: PPUSH
 376: CALL 76431 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 10
 385: PUSH
 386: EMPTY
 387: LIST
 388: PPUSH
 389: CALL 76700 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 393: LD_INT 2
 395: PPUSH
 396: LD_INT 6
 398: PUSH
 399: LD_INT 71
 401: PUSH
 402: LD_INT 116
 404: PUSH
 405: LD_INT 4
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: LIST
 412: LIST
 413: PUSH
 414: LD_INT 4
 416: PUSH
 417: LD_INT 85
 419: PUSH
 420: LD_INT 116
 422: PUSH
 423: LD_INT 4
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: PUSH
 432: LD_INT 32
 434: PUSH
 435: LD_INT 83
 437: PUSH
 438: LD_INT 111
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 32
 452: PUSH
 453: LD_INT 87
 455: PUSH
 456: LD_INT 121
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 33
 470: PUSH
 471: LD_INT 88
 473: PUSH
 474: LD_INT 128
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 59
 491: PUSH
 492: LD_INT 89
 494: PUSH
 495: LD_INT 3
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 69
 509: PUSH
 510: LD_INT 98
 512: PUSH
 513: LD_INT 3
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 33
 524: PUSH
 525: LD_INT 77
 527: PUSH
 528: LD_INT 103
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 83
 545: PUSH
 546: LD_INT 105
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 71
 563: PUSH
 564: LD_INT 125
 566: PUSH
 567: LD_INT 5
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PPUSH
 588: CALL 75757 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 1
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: PPUSH
 635: CALL 75913 0 2
// end ;
 639: LD_VAR 0 1
 643: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 644: LD_INT 0
 646: PPUSH
// debug := false ;
 647: LD_ADDR_EXP 1
 651: PUSH
 652: LD_INT 0
 654: ST_TO_ADDR
// game := true ;
 655: LD_ADDR_EXP 2
 659: PUSH
 660: LD_INT 1
 662: ST_TO_ADDR
// gossudarov_arrive := false ;
 663: LD_ADDR_EXP 4
 667: PUSH
 668: LD_INT 0
 670: ST_TO_ADDR
// ru_lab_builded := false ;
 671: LD_ADDR_EXP 5
 675: PUSH
 676: LD_INT 0
 678: ST_TO_ADDR
// player_spotted := false ;
 679: LD_ADDR_EXP 6
 683: PUSH
 684: LD_INT 0
 686: ST_TO_ADDR
// first_attack := false ;
 687: LD_ADDR_EXP 7
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// ru_attackers := [ ] ;
 695: LD_ADDR_EXP 52
 699: PUSH
 700: EMPTY
 701: ST_TO_ADDR
// ar_base_spotted := false ;
 702: LD_ADDR_EXP 8
 706: PUSH
 707: LD_INT 0
 709: ST_TO_ADDR
// ar_active_attack := false ;
 710: LD_ADDR_EXP 9
 714: PUSH
 715: LD_INT 0
 717: ST_TO_ADDR
// ar_attackers := [ ] ;
 718: LD_ADDR_EXP 10
 722: PUSH
 723: EMPTY
 724: ST_TO_ADDR
// first_powell_attack := false ;
 725: LD_ADDR_EXP 11
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// abdul_escaped := true ;
 733: LD_ADDR_EXP 12
 737: PUSH
 738: LD_INT 1
 740: ST_TO_ADDR
// loss_counter := 0 ;
 741: LD_ADDR_EXP 13
 745: PUSH
 746: LD_INT 0
 748: ST_TO_ADDR
// hack_counter := 0 ;
 749: LD_ADDR_EXP 14
 753: PUSH
 754: LD_INT 0
 756: ST_TO_ADDR
// end ;
 757: LD_VAR 0 1
 761: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 762: LD_EXP 48
 766: PPUSH
 767: CALL_OW 255
 771: PUSH
 772: LD_INT 7
 774: EQUAL
 775: PUSH
 776: LD_EXP 47
 780: PPUSH
 781: CALL_OW 255
 785: PUSH
 786: LD_INT 7
 788: EQUAL
 789: AND
 790: PUSH
 791: LD_EXP 48
 795: PPUSH
 796: CALL_OW 302
 800: AND
 801: PUSH
 802: LD_EXP 47
 806: PPUSH
 807: CALL_OW 302
 811: AND
 812: IFFALSE 824
 814: GO 816
 816: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 817: LD_STRING ACH_COMRADE
 819: PPUSH
 820: CALL_OW 543
 824: END
// every 0 0$1 trigger hack_counter >= 10 do
 825: LD_EXP 14
 829: PUSH
 830: LD_INT 10
 832: GREATEREQUAL
 833: IFFALSE 845
 835: GO 837
 837: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 838: LD_STRING ACH_HACK
 840: PPUSH
 841: CALL_OW 543
 845: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 846: LD_INT 0
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
// uc_side := 7 ;
 852: LD_ADDR_OWVAR 20
 856: PUSH
 857: LD_INT 7
 859: ST_TO_ADDR
// uc_nation := 1 ;
 860: LD_ADDR_OWVAR 21
 864: PUSH
 865: LD_INT 1
 867: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 868: LD_ADDR_EXP 15
 872: PUSH
 873: LD_STRING JMM
 875: PPUSH
 876: LD_EXP 1
 880: NOT
 881: PPUSH
 882: LD_STRING 12a_
 884: PPUSH
 885: CALL 14361 0 3
 889: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 890: LD_EXP 15
 894: PPUSH
 895: LD_INT 71
 897: PPUSH
 898: LD_INT 23
 900: PPUSH
 901: LD_INT 0
 903: PPUSH
 904: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 908: LD_EXP 15
 912: PPUSH
 913: LD_INT 2
 915: PPUSH
 916: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 920: LD_ADDR_EXP 16
 924: PUSH
 925: LD_STRING Roth
 927: PPUSH
 928: LD_EXP 1
 932: NOT
 933: PPUSH
 934: LD_STRING 12a_
 936: PPUSH
 937: CALL 14361 0 3
 941: ST_TO_ADDR
// if Roth then
 942: LD_EXP 16
 946: IFFALSE 966
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 948: LD_EXP 16
 952: PPUSH
 953: LD_INT 71
 955: PPUSH
 956: LD_INT 21
 958: PPUSH
 959: LD_INT 0
 961: PPUSH
 962: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 966: LD_ADDR_EXP 17
 970: PUSH
 971: LD_STRING Lisa
 973: PPUSH
 974: LD_EXP 1
 978: NOT
 979: PPUSH
 980: LD_STRING 12a_
 982: PPUSH
 983: CALL 14361 0 3
 987: ST_TO_ADDR
// if Lisa then
 988: LD_EXP 17
 992: IFFALSE 1009
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 994: LD_EXP 17
 998: PPUSH
 999: LD_INT 13
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1009: LD_ADDR_EXP 18
1013: PUSH
1014: LD_STRING Donaldson
1016: PPUSH
1017: LD_EXP 1
1021: NOT
1022: PPUSH
1023: LD_STRING 12a_
1025: PPUSH
1026: CALL 14361 0 3
1030: ST_TO_ADDR
// if Donaldson then
1031: LD_EXP 18
1035: IFFALSE 1052
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1037: LD_EXP 18
1041: PPUSH
1042: LD_INT 13
1044: PPUSH
1045: LD_INT 0
1047: PPUSH
1048: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1052: LD_ADDR_EXP 19
1056: PUSH
1057: LD_STRING Bobby
1059: PPUSH
1060: LD_EXP 1
1064: NOT
1065: PPUSH
1066: LD_STRING 12a_
1068: PPUSH
1069: CALL 14361 0 3
1073: ST_TO_ADDR
// if Bobby then
1074: LD_EXP 19
1078: IFFALSE 1095
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1080: LD_EXP 19
1084: PPUSH
1085: LD_INT 13
1087: PPUSH
1088: LD_INT 0
1090: PPUSH
1091: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1095: LD_ADDR_EXP 20
1099: PUSH
1100: LD_STRING Cyrus
1102: PPUSH
1103: LD_EXP 1
1107: NOT
1108: PPUSH
1109: LD_STRING 12a_
1111: PPUSH
1112: CALL 14361 0 3
1116: ST_TO_ADDR
// if Cyrus then
1117: LD_EXP 20
1121: IFFALSE 1138
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1123: LD_EXP 20
1127: PPUSH
1128: LD_INT 13
1130: PPUSH
1131: LD_INT 0
1133: PPUSH
1134: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1138: LD_ADDR_EXP 21
1142: PUSH
1143: LD_STRING Denis
1145: PPUSH
1146: LD_EXP 1
1150: NOT
1151: PPUSH
1152: LD_STRING 12a_
1154: PPUSH
1155: CALL 14361 0 3
1159: ST_TO_ADDR
// if Denis then
1160: LD_EXP 21
1164: IFFALSE 1181
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1166: LD_EXP 21
1170: PPUSH
1171: LD_INT 13
1173: PPUSH
1174: LD_INT 0
1176: PPUSH
1177: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1181: LD_ADDR_EXP 22
1185: PUSH
1186: LD_STRING Brown
1188: PPUSH
1189: LD_EXP 1
1193: NOT
1194: PPUSH
1195: LD_STRING 12a_
1197: PPUSH
1198: CALL 14361 0 3
1202: ST_TO_ADDR
// if Brown then
1203: LD_EXP 22
1207: IFFALSE 1224
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1209: LD_EXP 22
1213: PPUSH
1214: LD_INT 13
1216: PPUSH
1217: LD_INT 0
1219: PPUSH
1220: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1224: LD_ADDR_EXP 23
1228: PUSH
1229: LD_STRING Gladstone
1231: PPUSH
1232: LD_EXP 1
1236: NOT
1237: PPUSH
1238: LD_STRING 12a_
1240: PPUSH
1241: CALL 14361 0 3
1245: ST_TO_ADDR
// if Gladstone then
1246: LD_EXP 23
1250: IFFALSE 1267
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1252: LD_EXP 23
1256: PPUSH
1257: LD_INT 13
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1267: LD_ADDR_EXP 24
1271: PUSH
1272: LD_STRING Houten
1274: PPUSH
1275: LD_EXP 1
1279: NOT
1280: PPUSH
1281: LD_STRING 12a_
1283: PPUSH
1284: CALL 14361 0 3
1288: ST_TO_ADDR
// if Houten then
1289: LD_EXP 24
1293: IFFALSE 1310
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1295: LD_EXP 24
1299: PPUSH
1300: LD_INT 13
1302: PPUSH
1303: LD_INT 0
1305: PPUSH
1306: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1310: LD_ADDR_EXP 25
1314: PUSH
1315: LD_STRING Cornell
1317: PPUSH
1318: LD_EXP 1
1322: NOT
1323: PPUSH
1324: LD_STRING 12a_
1326: PPUSH
1327: CALL 14361 0 3
1331: ST_TO_ADDR
// if Cornel then
1332: LD_EXP 25
1336: IFFALSE 1353
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1338: LD_EXP 25
1342: PPUSH
1343: LD_INT 13
1345: PPUSH
1346: LD_INT 0
1348: PPUSH
1349: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1353: LD_ADDR_EXP 26
1357: PUSH
1358: LD_STRING Gary
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: LD_STRING 12a_
1369: PPUSH
1370: CALL 14361 0 3
1374: ST_TO_ADDR
// if Gary then
1375: LD_EXP 26
1379: IFFALSE 1396
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1381: LD_EXP 26
1385: PPUSH
1386: LD_INT 13
1388: PPUSH
1389: LD_INT 0
1391: PPUSH
1392: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1396: LD_ADDR_EXP 27
1400: PUSH
1401: LD_STRING Frank
1403: PPUSH
1404: LD_EXP 1
1408: NOT
1409: PPUSH
1410: LD_STRING 12a_
1412: PPUSH
1413: CALL 14361 0 3
1417: ST_TO_ADDR
// if Frank then
1418: LD_EXP 27
1422: IFFALSE 1439
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1424: LD_EXP 27
1428: PPUSH
1429: LD_INT 13
1431: PPUSH
1432: LD_INT 0
1434: PPUSH
1435: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1439: LD_ADDR_EXP 28
1443: PUSH
1444: LD_STRING Kikuchi
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 12a_
1455: PPUSH
1456: CALL 14361 0 3
1460: ST_TO_ADDR
// if Kikuchi then
1461: LD_EXP 28
1465: IFFALSE 1482
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1467: LD_EXP 28
1471: PPUSH
1472: LD_INT 13
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1482: LD_ADDR_EXP 29
1486: PUSH
1487: LD_STRING Simms
1489: PPUSH
1490: LD_EXP 1
1494: NOT
1495: PPUSH
1496: LD_STRING 12a_
1498: PPUSH
1499: CALL 14361 0 3
1503: ST_TO_ADDR
// if Simms then
1504: LD_EXP 29
1508: IFFALSE 1525
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1510: LD_EXP 29
1514: PPUSH
1515: LD_INT 13
1517: PPUSH
1518: LD_INT 0
1520: PPUSH
1521: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1525: LD_ADDR_EXP 30
1529: PUSH
1530: LD_STRING Joan
1532: PPUSH
1533: LD_EXP 1
1537: NOT
1538: PPUSH
1539: LD_STRING 12a_
1541: PPUSH
1542: CALL 14361 0 3
1546: ST_TO_ADDR
// if Joan then
1547: LD_EXP 30
1551: IFFALSE 1568
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1553: LD_EXP 30
1557: PPUSH
1558: LD_INT 13
1560: PPUSH
1561: LD_INT 0
1563: PPUSH
1564: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1568: LD_ADDR_EXP 31
1572: PUSH
1573: LD_STRING DeltaDoctor
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 12a_
1584: PPUSH
1585: CALL 14361 0 3
1589: ST_TO_ADDR
// if DeltaDoctor then
1590: LD_EXP 31
1594: IFFALSE 1611
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1596: LD_EXP 31
1600: PPUSH
1601: LD_INT 13
1603: PPUSH
1604: LD_INT 0
1606: PPUSH
1607: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_STRING 12a_others
1618: PPUSH
1619: CALL_OW 31
1623: ST_TO_ADDR
// if tmp then
1624: LD_VAR 0 4
1628: IFFALSE 1662
// for i in tmp do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: LD_VAR 0 4
1639: PUSH
1640: FOR_IN
1641: IFFALSE 1660
// PlaceUnitArea ( i , alliance_start , false ) ;
1643: LD_VAR 0 3
1647: PPUSH
1648: LD_INT 13
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 49
1658: GO 1640
1660: POP
1661: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1662: LD_INT 3
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 12
1673: PPUSH
1674: LD_INT 100
1676: PPUSH
1677: CALL 19185 0 5
// veh := CreateVehicle ;
1681: LD_ADDR_VAR 0 2
1685: PUSH
1686: CALL_OW 45
1690: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1691: LD_VAR 0 2
1695: PPUSH
1696: LD_INT 2
1698: PPUSH
1699: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1703: LD_VAR 0 2
1707: PPUSH
1708: LD_INT 60
1710: PPUSH
1711: LD_INT 6
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1721: LD_VAR 0 2
1725: PPUSH
1726: LD_INT 4
1728: PPUSH
1729: LD_INT 30
1731: PPUSH
1732: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1736: LD_STRING 11_artifact_captured
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: CALL_OW 30
1746: IFFALSE 1822
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1748: LD_INT 3
1750: PPUSH
1751: LD_INT 3
1753: PPUSH
1754: LD_INT 3
1756: PPUSH
1757: LD_INT 12
1759: PPUSH
1760: LD_INT 100
1762: PPUSH
1763: CALL 19185 0 5
// veh := CreateVehicle ;
1767: LD_ADDR_VAR 0 2
1771: PUSH
1772: CALL_OW 45
1776: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1777: LD_VAR 0 2
1781: PPUSH
1782: LD_INT 3
1784: PPUSH
1785: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1789: LD_VAR 0 2
1793: PPUSH
1794: LD_INT 75
1796: PPUSH
1797: LD_INT 6
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 4
1814: PPUSH
1815: LD_INT 50
1817: PPUSH
1818: CALL_OW 290
// end ; end ;
1822: LD_VAR 0 1
1826: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1827: LD_INT 0
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// uc_side := 6 ;
1833: LD_ADDR_OWVAR 20
1837: PUSH
1838: LD_INT 6
1840: ST_TO_ADDR
// uc_nation := 3 ;
1841: LD_ADDR_OWVAR 21
1845: PUSH
1846: LD_INT 3
1848: ST_TO_ADDR
// InitHc ;
1849: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1853: LD_ADDR_EXP 32
1857: PUSH
1858: LD_STRING Gossudarov
1860: PPUSH
1861: CALL_OW 25
1865: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1866: LD_ADDR_EXP 33
1870: PUSH
1871: LD_STRING Kirilenkova
1873: PPUSH
1874: CALL_OW 25
1878: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1879: LD_ADDR_EXP 34
1883: PUSH
1884: LD_STRING Titov
1886: PPUSH
1887: CALL_OW 25
1891: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1892: LD_ADDR_EXP 39
1896: PUSH
1897: LD_STRING Oblukov
1899: PPUSH
1900: CALL_OW 25
1904: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1905: LD_ADDR_EXP 36
1909: PUSH
1910: LD_STRING Dolgov
1912: PPUSH
1913: CALL_OW 25
1917: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1918: LD_ADDR_EXP 37
1922: PUSH
1923: LD_STRING Petrosyan
1925: PPUSH
1926: CALL_OW 25
1930: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1931: LD_ADDR_EXP 38
1935: PUSH
1936: LD_STRING Scholtze
1938: PPUSH
1939: CALL_OW 25
1943: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1944: LD_ADDR_EXP 40
1948: PUSH
1949: LD_STRING Kapitsova
1951: PPUSH
1952: CALL_OW 25
1956: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1957: LD_ADDR_VAR 0 2
1961: PUSH
1962: LD_EXP 32
1966: PUSH
1967: LD_EXP 33
1971: PUSH
1972: LD_EXP 34
1976: PUSH
1977: LD_EXP 39
1981: PUSH
1982: LD_EXP 36
1986: PUSH
1987: LD_EXP 37
1991: PUSH
1992: LD_EXP 38
1996: PUSH
1997: LD_EXP 40
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2012: LD_INT 1
2014: PPUSH
2015: LD_INT 4
2017: PPUSH
2018: LD_INT 8
2020: PPUSH
2021: CALL_OW 380
// un := CreateHuman ;
2025: LD_ADDR_VAR 0 4
2029: PUSH
2030: CALL_OW 44
2034: ST_TO_ADDR
// tmp := tmp ^ un ;
2035: LD_ADDR_VAR 0 2
2039: PUSH
2040: LD_VAR 0 2
2044: PUSH
2045: LD_VAR 0 4
2049: ADD
2050: ST_TO_ADDR
// for i in tmp do
2051: LD_ADDR_VAR 0 3
2055: PUSH
2056: LD_VAR 0 2
2060: PUSH
2061: FOR_IN
2062: IFFALSE 2081
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2064: LD_VAR 0 3
2068: PPUSH
2069: LD_INT 14
2071: PPUSH
2072: LD_INT 0
2074: PPUSH
2075: CALL_OW 49
2079: GO 2061
2081: POP
2082: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2083: LD_VAR 0 2
2087: PPUSH
2088: LD_EXP 3
2092: PPUSH
2093: CALL_OW 250
2097: PPUSH
2098: LD_EXP 3
2102: PPUSH
2103: CALL_OW 251
2107: PPUSH
2108: CALL_OW 111
// end ;
2112: LD_VAR 0 1
2116: RET
// export function PrepareBelkov ; begin
2117: LD_INT 0
2119: PPUSH
// uc_side := 4 ;
2120: LD_ADDR_OWVAR 20
2124: PUSH
2125: LD_INT 4
2127: ST_TO_ADDR
// uc_nation := 3 ;
2128: LD_ADDR_OWVAR 21
2132: PUSH
2133: LD_INT 3
2135: ST_TO_ADDR
// InitHc ;
2136: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2140: LD_ADDR_EXP 47
2144: PUSH
2145: LD_STRING Belkov
2147: PPUSH
2148: CALL_OW 25
2152: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2153: LD_EXP 47
2157: PPUSH
2158: LD_INT 14
2160: PPUSH
2161: LD_INT 0
2163: PPUSH
2164: CALL_OW 49
// end ;
2168: LD_VAR 0 1
2172: RET
// export function PrepareGnyevko ; begin
2173: LD_INT 0
2175: PPUSH
// uc_side := 4 ;
2176: LD_ADDR_OWVAR 20
2180: PUSH
2181: LD_INT 4
2183: ST_TO_ADDR
// uc_nation := 3 ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_INT 3
2191: ST_TO_ADDR
// InitHc ;
2192: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2196: LD_ADDR_EXP 48
2200: PUSH
2201: LD_STRING Gnyevko
2203: PPUSH
2204: CALL_OW 25
2208: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2209: LD_EXP 48
2213: PPUSH
2214: LD_INT 14
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// end ;
2224: LD_VAR 0 1
2228: RET
// export function PrepareBurlak ; var i , tmp ; begin
2229: LD_INT 0
2231: PPUSH
2232: PPUSH
2233: PPUSH
// uc_side := 4 ;
2234: LD_ADDR_OWVAR 20
2238: PUSH
2239: LD_INT 4
2241: ST_TO_ADDR
// uc_nation := 3 ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_INT 3
2249: ST_TO_ADDR
// InitHc ;
2250: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2254: LD_ADDR_EXP 46
2258: PUSH
2259: LD_STRING Burlak
2261: PPUSH
2262: CALL_OW 25
2266: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2267: LD_INT 24
2269: PUSH
2270: LD_INT 23
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: PUSH
2281: LD_OWVAR 67
2285: ARRAY
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 1
2292: PPUSH
2293: LD_INT 45
2295: PUSH
2296: LD_INT 44
2298: PUSH
2299: LD_INT 43
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PUSH
2307: LD_OWVAR 67
2311: ARRAY
2312: PPUSH
2313: LD_INT 0
2315: PPUSH
2316: CALL 19185 0 5
// Masha := CreateVehicle ;
2320: LD_ADDR_EXP 49
2324: PUSH
2325: CALL_OW 45
2329: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2330: LD_EXP 49
2334: PUSH
2335: LD_EXP 46
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: LD_INT 499
2346: PPUSH
2347: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2351: LD_EXP 49
2355: PPUSH
2356: LD_INT 3
2358: PPUSH
2359: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2363: LD_EXP 49
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2375: LD_INT 1
2377: PPUSH
2378: LD_INT 18
2380: PPUSH
2381: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2385: LD_INT 35
2387: PPUSH
2388: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2392: LD_ADDR_VAR 0 3
2396: PUSH
2397: LD_INT 18
2399: PPUSH
2400: EMPTY
2401: PPUSH
2402: CALL_OW 70
2406: ST_TO_ADDR
// if tmp then
2407: LD_VAR 0 3
2411: IFFALSE 2445
// for i in tmp do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_VAR 0 3
2422: PUSH
2423: FOR_IN
2424: IFFALSE 2443
// ComMoveXY ( i , 114 , 9 ) ;
2426: LD_VAR 0 2
2430: PPUSH
2431: LD_INT 114
2433: PPUSH
2434: LD_INT 9
2436: PPUSH
2437: CALL_OW 111
2441: GO 2423
2443: POP
2444: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2445: LD_INT 18
2447: PPUSH
2448: EMPTY
2449: PPUSH
2450: CALL_OW 70
2454: NOT
2455: PUSH
2456: LD_INT 123
2458: PPUSH
2459: LD_INT 3
2461: PPUSH
2462: CALL_OW 428
2466: PUSH
2467: LD_INT 0
2469: EQUAL
2470: AND
2471: IFFALSE 2385
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2473: LD_EXP 49
2477: PPUSH
2478: LD_INT 123
2480: PPUSH
2481: LD_INT 3
2483: PPUSH
2484: LD_INT 0
2486: PPUSH
2487: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2491: LD_EXP 46
2495: PPUSH
2496: LD_INT 125
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2509: LD_EXP 46
2513: PPUSH
2514: LD_EXP 49
2518: PPUSH
2519: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2523: LD_INT 10
2525: PPUSH
2526: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2530: LD_EXP 49
2534: PPUSH
2535: LD_INT 110
2537: PPUSH
2538: LD_INT 10
2540: PPUSH
2541: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2545: LD_ADDR_EXP 42
2549: PUSH
2550: LD_STRING Petrovova
2552: PPUSH
2553: CALL_OW 25
2557: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2558: LD_ADDR_EXP 44
2562: PUSH
2563: LD_STRING Kuzmov
2565: PPUSH
2566: CALL_OW 25
2570: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2571: LD_ADDR_EXP 43
2575: PUSH
2576: LD_STRING Kovalyuk
2578: PPUSH
2579: CALL_OW 25
2583: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2584: LD_ADDR_EXP 41
2588: PUSH
2589: LD_STRING Lipshchin
2591: PPUSH
2592: CALL_OW 25
2596: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2597: LD_ADDR_EXP 45
2601: PUSH
2602: LD_STRING Karamazov
2604: PPUSH
2605: CALL_OW 25
2609: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2610: LD_ADDR_VAR 0 3
2614: PUSH
2615: LD_EXP 42
2619: PUSH
2620: LD_EXP 44
2624: PUSH
2625: LD_EXP 43
2629: PUSH
2630: LD_EXP 41
2634: PUSH
2635: LD_EXP 45
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: ST_TO_ADDR
// for i in tmp do
2647: LD_ADDR_VAR 0 2
2651: PUSH
2652: LD_VAR 0 3
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2697
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2660: LD_VAR 0 2
2664: PPUSH
2665: LD_INT 399
2667: PPUSH
2668: LD_INT 799
2670: PPUSH
2671: CALL_OW 12
2675: PPUSH
2676: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2680: LD_VAR 0 2
2684: PPUSH
2685: LD_INT 19
2687: PPUSH
2688: LD_INT 0
2690: PPUSH
2691: CALL_OW 49
// end ;
2695: GO 2657
2697: POP
2698: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2699: LD_VAR 0 3
2703: PPUSH
2704: LD_INT 116
2706: PPUSH
2707: LD_INT 8
2709: PPUSH
2710: CALL_OW 111
// AddComHold ( tmp ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2723: LD_ADDR_VAR 0 2
2727: PUSH
2728: LD_VAR 0 3
2732: PPUSH
2733: LD_INT 25
2735: PUSH
2736: LD_INT 1
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 72
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2789
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 20
2758: PPUSH
2759: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2763: LD_VAR 0 2
2767: PPUSH
2768: LD_INT 147
2770: PPUSH
2771: LD_INT 45
2773: PPUSH
2774: CALL_OW 178
// AddComCrawl ( i ) ;
2778: LD_VAR 0 2
2782: PPUSH
2783: CALL_OW 197
// end ;
2787: GO 2748
2789: POP
2790: POP
// repeat wait ( 0 0$1 ) ;
2791: LD_INT 35
2793: PPUSH
2794: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2798: LD_EXP 49
2802: PPUSH
2803: LD_INT 110
2805: PPUSH
2806: LD_INT 10
2808: PPUSH
2809: CALL_OW 307
2813: PUSH
2814: LD_EXP 49
2818: PPUSH
2819: CALL_OW 305
2823: NOT
2824: OR
2825: IFFALSE 2791
// ComStop ( Burlak ) ;
2827: LD_EXP 46
2831: PPUSH
2832: CALL_OW 141
// AddComHold ( Burlak ) ;
2836: LD_EXP 46
2840: PPUSH
2841: CALL_OW 200
// end ; end_of_file
2845: LD_VAR 0 1
2849: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2850: LD_INT 0
2852: PPUSH
2853: PPUSH
2854: PPUSH
2855: PPUSH
// uc_side := 3 ;
2856: LD_ADDR_OWVAR 20
2860: PUSH
2861: LD_INT 3
2863: ST_TO_ADDR
// uc_nation := 3 ;
2864: LD_ADDR_OWVAR 21
2868: PUSH
2869: LD_INT 3
2871: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2872: LD_ADDR_EXP 50
2876: PUSH
2877: LD_INT 47
2879: PPUSH
2880: LD_INT 4
2882: PPUSH
2883: LD_STRING 
2885: PPUSH
2886: LD_INT 7
2888: PUSH
2889: LD_INT 8
2891: PUSH
2892: LD_INT 9
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: LIST
2899: PUSH
2900: LD_OWVAR 67
2904: ARRAY
2905: PPUSH
2906: LD_INT 10000
2908: PUSH
2909: LD_INT 3000
2911: PUSH
2912: LD_INT 300
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: PPUSH
2920: LD_INT 9
2922: PUSH
2923: LD_INT 5
2925: PUSH
2926: LD_INT 6
2928: PUSH
2929: LD_INT 6
2931: PUSH
2932: EMPTY
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: PPUSH
2938: CALL 22626 0 6
2942: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2943: LD_ADDR_EXP 59
2947: PUSH
2948: LD_EXP 59
2952: PPUSH
2953: LD_INT 2
2955: PPUSH
2956: LD_EXP 50
2960: PPUSH
2961: CALL_OW 1
2965: ST_TO_ADDR
// tmp := [ ] ;
2966: LD_ADDR_VAR 0 4
2970: PUSH
2971: EMPTY
2972: ST_TO_ADDR
// for i = 1 to 4 do
2973: LD_ADDR_VAR 0 2
2977: PUSH
2978: DOUBLE
2979: LD_INT 1
2981: DEC
2982: ST_TO_ADDR
2983: LD_INT 4
2985: PUSH
2986: FOR_TO
2987: IFFALSE 3080
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2989: LD_INT 22
2991: PPUSH
2992: LD_INT 3
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 43
3000: PUSH
3001: LD_INT 45
3003: PUSH
3004: LD_INT 45
3006: PUSH
3007: LD_INT 44
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_INT 4
3023: MOD
3024: PUSH
3025: LD_INT 1
3027: PLUS
3028: ARRAY
3029: PPUSH
3030: LD_INT 100
3032: PPUSH
3033: CALL 19185 0 5
// veh := CreateVehicle ;
3037: LD_ADDR_VAR 0 3
3041: PUSH
3042: CALL_OW 45
3046: ST_TO_ADDR
// tmp := tmp ^ veh ;
3047: LD_ADDR_VAR 0 4
3051: PUSH
3052: LD_VAR 0 4
3056: PUSH
3057: LD_VAR 0 3
3061: ADD
3062: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3063: LD_VAR 0 3
3067: PPUSH
3068: LD_INT 2
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 49
// end ;
3078: GO 2986
3080: POP
3081: POP
// russian_guard := tmp ;
3082: LD_ADDR_EXP 51
3086: PUSH
3087: LD_VAR 0 4
3091: ST_TO_ADDR
// end ;
3092: LD_VAR 0 1
3096: RET
// every 8 8$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3097: LD_INT 47
3099: PPUSH
3100: CALL_OW 302
3104: PUSH
3105: LD_EXP 6
3109: AND
3110: IFFALSE 3716
3112: GO 3114
3114: DISABLE
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
3122: PPUSH
// begin enable ;
3123: ENABLE
// base := 2 ;
3124: LD_ADDR_VAR 0 2
3128: PUSH
3129: LD_INT 2
3131: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3132: LD_ADDR_VAR 0 4
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 0
3142: PUSH
3143: LD_INT 0
3145: PUSH
3146: LD_INT 0
3148: PUSH
3149: LD_INT 0
3151: PUSH
3152: LD_INT 0
3154: PUSH
3155: LD_INT 0
3157: PUSH
3158: LD_INT 0
3160: PUSH
3161: LD_INT 1
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3179: LD_ADDR_VAR 0 3
3183: PUSH
3184: LD_INT 22
3186: PUSH
3187: LD_INT 1
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: LD_INT 45
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 21
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: LD_INT 45
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: LD_INT 45
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 23
3240: PUSH
3241: LD_INT 1
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 46
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: LIST
3261: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3262: LD_ADDR_VAR 0 1
3266: PUSH
3267: DOUBLE
3268: LD_INT 1
3270: DEC
3271: ST_TO_ADDR
3272: LD_OWVAR 67
3276: PUSH
3277: LD_OWVAR 1
3281: PUSH
3282: LD_INT 21000
3284: DIV
3285: PLUS
3286: PUSH
3287: FOR_TO
3288: IFFALSE 3376
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3290: LD_ADDR_VAR 0 3
3294: PUSH
3295: LD_VAR 0 3
3299: PPUSH
3300: LD_VAR 0 3
3304: PUSH
3305: LD_INT 1
3307: PLUS
3308: PPUSH
3309: LD_INT 23
3311: PUSH
3312: LD_INT 24
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: LD_INT 1
3321: PPUSH
3322: LD_INT 2
3324: PPUSH
3325: CALL_OW 12
3329: ARRAY
3330: PUSH
3331: LD_INT 1
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: LD_INT 46
3339: PUSH
3340: LD_INT 47
3342: PUSH
3343: LD_INT 45
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 12
3361: ARRAY
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PPUSH
3369: CALL_OW 2
3373: ST_TO_ADDR
3374: GO 3287
3376: POP
3377: POP
// MC_InsertProduceList ( base , tmp ) ;
3378: LD_VAR 0 2
3382: PPUSH
3383: LD_VAR 0 3
3387: PPUSH
3388: CALL 75913 0 2
// repeat wait ( 0 0$1 ) ;
3392: LD_INT 35
3394: PPUSH
3395: CALL_OW 67
// until MC_GetVehicles ( base , true ) >= tmp ;
3399: LD_VAR 0 2
3403: PPUSH
3404: LD_INT 1
3406: PPUSH
3407: CALL 77331 0 2
3411: PUSH
3412: LD_VAR 0 3
3416: GREATEREQUAL
3417: IFFALSE 3392
// wait ( 0 0$20 ) ;
3419: LD_INT 700
3421: PPUSH
3422: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3426: LD_ADDR_VAR 0 5
3430: PUSH
3431: LD_INT 71
3433: PUSH
3434: LD_INT 19
3436: PUSH
3437: EMPTY
3438: LIST
3439: LIST
3440: PUSH
3441: LD_INT 91
3443: PUSH
3444: LD_INT 67
3446: PUSH
3447: EMPTY
3448: LIST
3449: LIST
3450: PUSH
3451: LD_INT 52
3453: PUSH
3454: LD_INT 44
3456: PUSH
3457: EMPTY
3458: LIST
3459: LIST
3460: PUSH
3461: LD_INT 68
3463: PUSH
3464: LD_INT 48
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: PUSH
3471: EMPTY
3472: LIST
3473: LIST
3474: LIST
3475: LIST
3476: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3477: LD_ADDR_VAR 0 6
3481: PUSH
3482: LD_EXP 78
3486: PUSH
3487: LD_VAR 0 2
3491: ARRAY
3492: PUSH
3493: LD_EXP 78
3497: PUSH
3498: LD_VAR 0 2
3502: ARRAY
3503: PPUSH
3504: LD_INT 2
3506: PUSH
3507: LD_INT 34
3509: PUSH
3510: LD_INT 51
3512: PUSH
3513: EMPTY
3514: LIST
3515: LIST
3516: PUSH
3517: LD_INT 34
3519: PUSH
3520: LD_INT 52
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: PUSH
3527: EMPTY
3528: LIST
3529: LIST
3530: LIST
3531: PPUSH
3532: CALL_OW 72
3536: DIFF
3537: ST_TO_ADDR
// if not attackers then
3538: LD_VAR 0 6
3542: NOT
3543: IFFALSE 3547
// exit ;
3545: GO 3716
// ru_attackers := attackers ;
3547: LD_ADDR_EXP 52
3551: PUSH
3552: LD_VAR 0 6
3556: ST_TO_ADDR
// for i = 1 to attackers do
3557: LD_ADDR_VAR 0 1
3561: PUSH
3562: DOUBLE
3563: LD_INT 1
3565: DEC
3566: ST_TO_ADDR
3567: LD_VAR 0 6
3571: PUSH
3572: FOR_TO
3573: IFFALSE 3650
// begin case i mod 3 of 0 :
3575: LD_VAR 0 1
3579: PUSH
3580: LD_INT 3
3582: MOD
3583: PUSH
3584: LD_INT 0
3586: DOUBLE
3587: EQUAL
3588: IFTRUE 3592
3590: GO 3595
3592: POP
// ; 1 :
3593: GO 3648
3595: LD_INT 1
3597: DOUBLE
3598: EQUAL
3599: IFTRUE 3603
3601: GO 3621
3603: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3604: LD_VAR 0 1
3608: PPUSH
3609: LD_INT 32
3611: PPUSH
3612: LD_INT 49
3614: PPUSH
3615: CALL_OW 114
3619: GO 3648
3621: LD_INT 2
3623: DOUBLE
3624: EQUAL
3625: IFTRUE 3629
3627: GO 3647
3629: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3630: LD_VAR 0 1
3634: PPUSH
3635: LD_INT 117
3637: PPUSH
3638: LD_INT 107
3640: PPUSH
3641: CALL_OW 114
3645: GO 3648
3647: POP
// end ;
3648: GO 3572
3650: POP
3651: POP
// repeat wait ( 0 0$1 ) ;
3652: LD_INT 35
3654: PPUSH
3655: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3659: LD_VAR 0 6
3663: PPUSH
3664: LD_INT 60
3666: PUSH
3667: EMPTY
3668: LIST
3669: PPUSH
3670: CALL_OW 72
3674: NOT
3675: IFFALSE 3652
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3677: LD_VAR 0 2
3681: PPUSH
3682: LD_VAR 0 6
3686: PPUSH
3687: LD_VAR 0 5
3691: PPUSH
3692: LD_VAR 0 4
3696: PPUSH
3697: CALL 76098 0 4
// if not first_attack then
3701: LD_EXP 7
3705: NOT
3706: IFFALSE 3716
// first_attack := true ;
3708: LD_ADDR_EXP 7
3712: PUSH
3713: LD_INT 1
3715: ST_TO_ADDR
// end ; end_of_file
3716: PPOPN 6
3718: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3719: LD_INT 0
3721: PPUSH
3722: PPUSH
3723: PPUSH
3724: PPUSH
3725: PPUSH
3726: PPUSH
3727: PPUSH
// uc_side := 2 ;
3728: LD_ADDR_OWVAR 20
3732: PUSH
3733: LD_INT 2
3735: ST_TO_ADDR
// uc_nation := 2 ;
3736: LD_ADDR_OWVAR 21
3740: PUSH
3741: LD_INT 2
3743: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3744: LD_ADDR_EXP 55
3748: PUSH
3749: LD_STRING Abdul
3751: PPUSH
3752: CALL_OW 25
3756: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3757: LD_EXP 55
3761: PPUSH
3762: LD_INT 11
3764: PPUSH
3765: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3769: LD_EXP 55
3773: PPUSH
3774: LD_INT 1
3776: PPUSH
3777: CALL_OW 52
// vc_chassis := 31 ;
3781: LD_ADDR_OWVAR 37
3785: PUSH
3786: LD_INT 31
3788: ST_TO_ADDR
// vc_control := control_rider ;
3789: LD_ADDR_OWVAR 38
3793: PUSH
3794: LD_INT 4
3796: ST_TO_ADDR
// mastodont := CreateVehicle ;
3797: LD_ADDR_EXP 56
3801: PUSH
3802: CALL_OW 45
3806: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3807: LD_EXP 56
3811: PPUSH
3812: LD_INT 153
3814: PPUSH
3815: LD_INT 71
3817: PPUSH
3818: LD_INT 0
3820: PPUSH
3821: CALL_OW 48
// InitVc ;
3825: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
3829: LD_ADDR_EXP 53
3833: PUSH
3834: LD_INT 1
3836: PPUSH
3837: LD_INT 3
3839: PPUSH
3840: LD_STRING 
3842: PPUSH
3843: LD_INT 7
3845: PUSH
3846: LD_INT 8
3848: PUSH
3849: LD_INT 9
3851: PUSH
3852: EMPTY
3853: LIST
3854: LIST
3855: LIST
3856: PUSH
3857: LD_OWVAR 67
3861: ARRAY
3862: PPUSH
3863: LD_INT 5000
3865: PUSH
3866: LD_INT 1000
3868: PUSH
3869: LD_INT 300
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: LIST
3876: PPUSH
3877: LD_INT 18
3879: PUSH
3880: LD_INT 5
3882: PUSH
3883: LD_INT 6
3885: PUSH
3886: LD_INT 9
3888: PUSH
3889: EMPTY
3890: LIST
3891: LIST
3892: LIST
3893: LIST
3894: PPUSH
3895: CALL 22626 0 6
3899: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3900: LD_ADDR_EXP 59
3904: PUSH
3905: LD_EXP 59
3909: PPUSH
3910: LD_INT 1
3912: PPUSH
3913: LD_EXP 53
3917: PPUSH
3918: CALL_OW 1
3922: ST_TO_ADDR
// tmp := [ ] ;
3923: LD_ADDR_VAR 0 4
3927: PUSH
3928: EMPTY
3929: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3930: LD_ADDR_OWVAR 37
3934: PUSH
3935: LD_INT 14
3937: ST_TO_ADDR
// vc_engine := engine_siberite ;
3938: LD_ADDR_OWVAR 39
3942: PUSH
3943: LD_INT 3
3945: ST_TO_ADDR
// vc_control := control_manual ;
3946: LD_ADDR_OWVAR 38
3950: PUSH
3951: LD_INT 1
3953: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3954: LD_ADDR_OWVAR 40
3958: PUSH
3959: LD_INT 31
3961: ST_TO_ADDR
// for i = 1 to 3 do
3962: LD_ADDR_VAR 0 2
3966: PUSH
3967: DOUBLE
3968: LD_INT 1
3970: DEC
3971: ST_TO_ADDR
3972: LD_INT 3
3974: PUSH
3975: FOR_TO
3976: IFFALSE 4220
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3978: LD_ADDR_VAR 0 5
3982: PUSH
3983: LD_INT 153
3985: PUSH
3986: LD_INT 71
3988: PUSH
3989: EMPTY
3990: LIST
3991: LIST
3992: PUSH
3993: LD_INT 155
3995: PUSH
3996: LD_INT 81
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: EMPTY
4004: LIST
4005: LIST
4006: PUSH
4007: LD_VAR 0 2
4011: PUSH
4012: LD_INT 2
4014: MOD
4015: PUSH
4016: LD_INT 1
4018: PLUS
4019: ARRAY
4020: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
4021: LD_INT 0
4023: PPUSH
4024: LD_INT 3
4026: PPUSH
4027: LD_INT 7
4029: PUSH
4030: LD_INT 8
4032: PUSH
4033: LD_INT 9
4035: PUSH
4036: EMPTY
4037: LIST
4038: LIST
4039: LIST
4040: PUSH
4041: LD_OWVAR 67
4045: ARRAY
4046: PPUSH
4047: CALL_OW 380
// un := CreateVehicle ;
4051: LD_ADDR_VAR 0 6
4055: PUSH
4056: CALL_OW 45
4060: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4061: LD_VAR 0 6
4065: PPUSH
4066: LD_INT 0
4068: PPUSH
4069: LD_INT 5
4071: PPUSH
4072: CALL_OW 12
4076: PPUSH
4077: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4081: LD_VAR 0 6
4085: PPUSH
4086: LD_VAR 0 5
4090: PUSH
4091: LD_INT 1
4093: ARRAY
4094: PPUSH
4095: LD_VAR 0 5
4099: PUSH
4100: LD_INT 2
4102: ARRAY
4103: PPUSH
4104: LD_INT 6
4106: PPUSH
4107: LD_INT 0
4109: PPUSH
4110: CALL_OW 50
// un2 := CreateHuman ;
4114: LD_ADDR_VAR 0 7
4118: PUSH
4119: CALL_OW 44
4123: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4124: LD_VAR 0 7
4128: PPUSH
4129: LD_VAR 0 6
4133: PPUSH
4134: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4138: LD_ADDR_EXP 59
4142: PUSH
4143: LD_EXP 59
4147: PPUSH
4148: LD_INT 1
4150: PUSH
4151: LD_EXP 59
4155: PUSH
4156: LD_INT 1
4158: ARRAY
4159: PUSH
4160: LD_INT 1
4162: PLUS
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PPUSH
4168: LD_VAR 0 6
4172: PPUSH
4173: CALL 19307 0 3
4177: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4178: LD_ADDR_EXP 59
4182: PUSH
4183: LD_EXP 59
4187: PPUSH
4188: LD_INT 1
4190: PUSH
4191: LD_EXP 59
4195: PUSH
4196: LD_INT 1
4198: ARRAY
4199: PUSH
4200: LD_INT 1
4202: PLUS
4203: PUSH
4204: EMPTY
4205: LIST
4206: LIST
4207: PPUSH
4208: LD_VAR 0 7
4212: PPUSH
4213: CALL 19307 0 3
4217: ST_TO_ADDR
// end ;
4218: GO 3975
4220: POP
4221: POP
// for i = 1 to 5 do
4222: LD_ADDR_VAR 0 2
4226: PUSH
4227: DOUBLE
4228: LD_INT 1
4230: DEC
4231: ST_TO_ADDR
4232: LD_INT 5
4234: PUSH
4235: FOR_TO
4236: IFFALSE 4329
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4238: LD_INT 14
4240: PPUSH
4241: LD_INT 3
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 28
4252: PUSH
4253: LD_INT 28
4255: PUSH
4256: LD_INT 26
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: PUSH
4265: LD_VAR 0 2
4269: PUSH
4270: LD_INT 4
4272: MOD
4273: PUSH
4274: LD_INT 1
4276: PLUS
4277: ARRAY
4278: PPUSH
4279: LD_INT 100
4281: PPUSH
4282: CALL 19185 0 5
// veh := CreateVehicle ;
4286: LD_ADDR_VAR 0 3
4290: PUSH
4291: CALL_OW 45
4295: ST_TO_ADDR
// tmp := tmp ^ veh ;
4296: LD_ADDR_VAR 0 4
4300: PUSH
4301: LD_VAR 0 4
4305: PUSH
4306: LD_VAR 0 3
4310: ADD
4311: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4312: LD_VAR 0 3
4316: PPUSH
4317: LD_INT 1
4319: PPUSH
4320: LD_INT 0
4322: PPUSH
4323: CALL_OW 49
// end ;
4327: GO 4235
4329: POP
4330: POP
// arabian_guard := tmp ;
4331: LD_ADDR_EXP 54
4335: PUSH
4336: LD_VAR 0 4
4340: ST_TO_ADDR
// end ;
4341: LD_VAR 0 1
4345: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4346: LD_INT 22
4348: PUSH
4349: LD_INT 7
4351: PUSH
4352: EMPTY
4353: LIST
4354: LIST
4355: PUSH
4356: LD_INT 91
4358: PUSH
4359: LD_INT 1
4361: PUSH
4362: LD_INT 12
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: EMPTY
4371: LIST
4372: LIST
4373: PPUSH
4374: CALL_OW 69
4378: PUSH
4379: LD_EXP 56
4383: PPUSH
4384: CALL_OW 256
4388: PUSH
4389: LD_INT 990
4391: LESS
4392: OR
4393: PUSH
4394: LD_EXP 55
4398: PPUSH
4399: CALL_OW 256
4403: PUSH
4404: LD_INT 990
4406: LESS
4407: OR
4408: IFFALSE 4551
4410: GO 4412
4412: DISABLE
// begin if IsInUnit ( Abdul ) then
4413: LD_EXP 55
4417: PPUSH
4418: CALL_OW 310
4422: IFFALSE 4433
// ComExitBuilding ( Abdul ) ;
4424: LD_EXP 55
4428: PPUSH
4429: CALL_OW 122
// if Mastodont then
4433: LD_EXP 56
4437: IFFALSE 4454
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4439: LD_EXP 56
4443: PPUSH
4444: LD_INT 205
4446: PPUSH
4447: LD_INT 132
4449: PPUSH
4450: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4454: LD_EXP 55
4458: PPUSH
4459: LD_INT 205
4461: PPUSH
4462: LD_INT 132
4464: PPUSH
4465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4469: LD_INT 35
4471: PPUSH
4472: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4476: LD_EXP 55
4480: PPUSH
4481: LD_INT 21
4483: PPUSH
4484: CALL_OW 308
4488: IFFALSE 4469
// RemoveUnit ( Abdul ) ;
4490: LD_EXP 55
4494: PPUSH
4495: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4499: LD_INT 35
4501: PPUSH
4502: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4506: LD_EXP 56
4510: PPUSH
4511: LD_INT 21
4513: PPUSH
4514: CALL_OW 308
4518: PUSH
4519: LD_EXP 56
4523: PPUSH
4524: CALL_OW 301
4528: OR
4529: IFFALSE 4499
// if IsOk ( Mastodont ) then
4531: LD_EXP 56
4535: PPUSH
4536: CALL_OW 302
4540: IFFALSE 4551
// RemoveUnit ( Mastodont ) ;
4542: LD_EXP 56
4546: PPUSH
4547: CALL_OW 64
// end ;
4551: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4552: LD_EXP 55
4556: PPUSH
4557: CALL_OW 301
4561: PUSH
4562: LD_INT 22
4564: PUSH
4565: LD_INT 2
4567: PUSH
4568: EMPTY
4569: LIST
4570: LIST
4571: PUSH
4572: LD_INT 2
4574: PUSH
4575: LD_INT 25
4577: PUSH
4578: LD_INT 1
4580: PUSH
4581: EMPTY
4582: LIST
4583: LIST
4584: PUSH
4585: LD_INT 25
4587: PUSH
4588: LD_INT 2
4590: PUSH
4591: EMPTY
4592: LIST
4593: LIST
4594: PUSH
4595: LD_INT 25
4597: PUSH
4598: LD_INT 3
4600: PUSH
4601: EMPTY
4602: LIST
4603: LIST
4604: PUSH
4605: LD_INT 25
4607: PUSH
4608: LD_INT 4
4610: PUSH
4611: EMPTY
4612: LIST
4613: LIST
4614: PUSH
4615: LD_INT 25
4617: PUSH
4618: LD_INT 8
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: PUSH
4625: EMPTY
4626: LIST
4627: LIST
4628: LIST
4629: LIST
4630: LIST
4631: LIST
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: PPUSH
4637: CALL_OW 69
4641: PUSH
4642: LD_INT 16
4644: PUSH
4645: LD_INT 19
4647: PUSH
4648: LD_INT 22
4650: PUSH
4651: EMPTY
4652: LIST
4653: LIST
4654: LIST
4655: PUSH
4656: LD_OWVAR 67
4660: ARRAY
4661: LESS
4662: OR
4663: IFFALSE 5336
4665: GO 4667
4667: DISABLE
4668: LD_INT 0
4670: PPUSH
4671: PPUSH
4672: PPUSH
4673: PPUSH
4674: PPUSH
4675: PPUSH
// begin MC_Kill ( 1 ) ;
4676: LD_INT 1
4678: PPUSH
4679: CALL 52259 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4683: LD_ADDR_VAR 0 2
4687: PUSH
4688: LD_INT 22
4690: PUSH
4691: LD_INT 2
4693: PUSH
4694: EMPTY
4695: LIST
4696: LIST
4697: PUSH
4698: LD_INT 2
4700: PUSH
4701: LD_INT 25
4703: PUSH
4704: LD_INT 1
4706: PUSH
4707: EMPTY
4708: LIST
4709: LIST
4710: PUSH
4711: LD_INT 25
4713: PUSH
4714: LD_INT 2
4716: PUSH
4717: EMPTY
4718: LIST
4719: LIST
4720: PUSH
4721: LD_INT 25
4723: PUSH
4724: LD_INT 3
4726: PUSH
4727: EMPTY
4728: LIST
4729: LIST
4730: PUSH
4731: LD_INT 25
4733: PUSH
4734: LD_INT 4
4736: PUSH
4737: EMPTY
4738: LIST
4739: LIST
4740: PUSH
4741: LD_INT 25
4743: PUSH
4744: LD_INT 8
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: LIST
4758: PUSH
4759: EMPTY
4760: LIST
4761: LIST
4762: PPUSH
4763: CALL_OW 69
4767: ST_TO_ADDR
// for i in tmp do
4768: LD_ADDR_VAR 0 5
4772: PUSH
4773: LD_VAR 0 2
4777: PUSH
4778: FOR_IN
4779: IFFALSE 4795
// SetTag ( i , 10 ) ;
4781: LD_VAR 0 5
4785: PPUSH
4786: LD_INT 10
4788: PPUSH
4789: CALL_OW 109
4793: GO 4778
4795: POP
4796: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4797: LD_ADDR_VAR 0 3
4801: PUSH
4802: LD_INT 22
4804: PUSH
4805: LD_INT 2
4807: PUSH
4808: EMPTY
4809: LIST
4810: LIST
4811: PUSH
4812: LD_INT 21
4814: PUSH
4815: LD_INT 1
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PUSH
4822: EMPTY
4823: LIST
4824: LIST
4825: PPUSH
4826: CALL_OW 69
4830: PUSH
4831: LD_VAR 0 2
4835: DIFF
4836: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4837: LD_ADDR_VAR 0 1
4841: PUSH
4842: LD_INT 22
4844: PUSH
4845: LD_INT 2
4847: PUSH
4848: EMPTY
4849: LIST
4850: LIST
4851: PUSH
4852: LD_INT 21
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 24
4864: PUSH
4865: LD_INT 300
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: LIST
4876: PPUSH
4877: CALL_OW 69
4881: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4882: LD_ADDR_VAR 0 4
4886: PUSH
4887: LD_VAR 0 1
4891: PPUSH
4892: LD_INT 33
4894: PUSH
4895: LD_INT 1
4897: PUSH
4898: EMPTY
4899: LIST
4900: LIST
4901: PUSH
4902: LD_INT 58
4904: PUSH
4905: EMPTY
4906: LIST
4907: PUSH
4908: EMPTY
4909: LIST
4910: LIST
4911: PPUSH
4912: CALL_OW 72
4916: ST_TO_ADDR
// for i in tmp do
4917: LD_ADDR_VAR 0 5
4921: PUSH
4922: LD_VAR 0 2
4926: PUSH
4927: FOR_IN
4928: IFFALSE 5112
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4930: LD_VAR 0 5
4934: PUSH
4935: LD_INT 55
4937: PUSH
4938: EMPTY
4939: LIST
4940: PPUSH
4941: CALL_OW 69
4945: IN
4946: IFFALSE 4965
// begin AddComMoveXY ( i , 209 , 132 ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: LD_INT 209
4955: PPUSH
4956: LD_INT 132
4958: PPUSH
4959: CALL_OW 171
// continue ;
4963: GO 4927
// end ; if IsInUnit ( i ) then
4965: LD_VAR 0 5
4969: PPUSH
4970: CALL_OW 310
4974: IFFALSE 4992
// begin ComExitBuilding ( i ) ;
4976: LD_VAR 0 5
4980: PPUSH
4981: CALL_OW 122
// wait ( 3 ) ;
4985: LD_INT 3
4987: PPUSH
4988: CALL_OW 67
// end ; if tmp_empty then
4992: LD_VAR 0 4
4996: IFFALSE 5095
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4998: LD_VAR 0 5
5002: PPUSH
5003: LD_VAR 0 4
5007: PPUSH
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 74
5017: PPUSH
5018: CALL_OW 296
5022: PUSH
5023: LD_INT 25
5025: LESS
5026: IFFALSE 5095
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5028: LD_ADDR_VAR 0 6
5032: PUSH
5033: LD_VAR 0 4
5037: PPUSH
5038: LD_VAR 0 5
5042: PPUSH
5043: CALL_OW 74
5047: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5048: LD_VAR 0 5
5052: PPUSH
5053: LD_VAR 0 6
5057: PPUSH
5058: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5062: LD_VAR 0 5
5066: PPUSH
5067: LD_INT 209
5069: PPUSH
5070: LD_INT 132
5072: PPUSH
5073: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5077: LD_ADDR_VAR 0 4
5081: PUSH
5082: LD_VAR 0 4
5086: PUSH
5087: LD_VAR 0 6
5091: DIFF
5092: ST_TO_ADDR
// continue ;
5093: GO 4927
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5095: LD_VAR 0 5
5099: PPUSH
5100: LD_INT 201
5102: PPUSH
5103: LD_INT 132
5105: PPUSH
5106: CALL_OW 171
// end ;
5110: GO 4927
5112: POP
5113: POP
// for i in tmp_ape do
5114: LD_ADDR_VAR 0 5
5118: PUSH
5119: LD_VAR 0 3
5123: PUSH
5124: FOR_IN
5125: IFFALSE 5164
// begin if IsInUnit ( i ) then
5127: LD_VAR 0 5
5131: PPUSH
5132: CALL_OW 310
5136: IFFALSE 5147
// ComExitBuilding ( i ) ;
5138: LD_VAR 0 5
5142: PPUSH
5143: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5147: LD_VAR 0 5
5151: PPUSH
5152: LD_INT 201
5154: PPUSH
5155: LD_INT 132
5157: PPUSH
5158: CALL_OW 171
// end ;
5162: GO 5124
5164: POP
5165: POP
// repeat wait ( 0 0$1 ) ;
5166: LD_INT 35
5168: PPUSH
5169: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5173: LD_ADDR_VAR 0 5
5177: PUSH
5178: LD_VAR 0 2
5182: PUSH
5183: LD_VAR 0 3
5187: UNION
5188: PUSH
5189: LD_VAR 0 1
5193: UNION
5194: PUSH
5195: FOR_IN
5196: IFFALSE 5227
// if not HasTask ( i ) then
5198: LD_VAR 0 5
5202: PPUSH
5203: CALL_OW 314
5207: NOT
5208: IFFALSE 5225
// ComMoveXY ( i , 201 , 132 ) ;
5210: LD_VAR 0 5
5214: PPUSH
5215: LD_INT 201
5217: PPUSH
5218: LD_INT 132
5220: PPUSH
5221: CALL_OW 111
5225: GO 5195
5227: POP
5228: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5229: LD_INT 21
5231: PPUSH
5232: LD_INT 22
5234: PUSH
5235: LD_INT 2
5237: PUSH
5238: EMPTY
5239: LIST
5240: LIST
5241: PPUSH
5242: CALL_OW 70
5246: IFFALSE 5287
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5248: LD_ADDR_VAR 0 5
5252: PUSH
5253: LD_INT 21
5255: PPUSH
5256: LD_INT 22
5258: PUSH
5259: LD_INT 2
5261: PUSH
5262: EMPTY
5263: LIST
5264: LIST
5265: PPUSH
5266: CALL_OW 70
5270: PUSH
5271: FOR_IN
5272: IFFALSE 5285
// RemoveUnit ( i ) ;
5274: LD_VAR 0 5
5278: PPUSH
5279: CALL_OW 64
5283: GO 5271
5285: POP
5286: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5287: LD_INT 22
5289: PUSH
5290: LD_INT 2
5292: PUSH
5293: EMPTY
5294: LIST
5295: LIST
5296: PUSH
5297: LD_INT 2
5299: PUSH
5300: LD_INT 21
5302: PUSH
5303: LD_INT 1
5305: PUSH
5306: EMPTY
5307: LIST
5308: LIST
5309: PUSH
5310: LD_INT 21
5312: PUSH
5313: LD_INT 2
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: PUSH
5320: EMPTY
5321: LIST
5322: LIST
5323: LIST
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: PPUSH
5329: CALL_OW 69
5333: NOT
5334: IFFALSE 5166
// end ;
5336: PPOPN 6
5338: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5339: LD_EXP 9
5343: PUSH
5344: LD_INT 92
5346: PPUSH
5347: LD_INT 40
5349: PPUSH
5350: CALL_OW 428
5354: PPUSH
5355: CALL_OW 266
5359: PUSH
5360: LD_INT 30
5362: EQUAL
5363: AND
5364: IFFALSE 5560
5366: GO 5368
5368: DISABLE
5369: LD_INT 0
5371: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5372: LD_ADDR_VAR 0 1
5376: PUSH
5377: LD_EXP 59
5381: PUSH
5382: LD_INT 1
5384: ARRAY
5385: PPUSH
5386: LD_INT 25
5388: PUSH
5389: LD_INT 4
5391: PUSH
5392: EMPTY
5393: LIST
5394: LIST
5395: PPUSH
5396: CALL_OW 72
5400: ST_TO_ADDR
// if not sci then
5401: LD_VAR 0 1
5405: NOT
5406: IFFALSE 5410
// exit ;
5408: GO 5560
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5410: LD_ADDR_EXP 59
5414: PUSH
5415: LD_EXP 59
5419: PPUSH
5420: LD_INT 1
5422: PPUSH
5423: LD_EXP 59
5427: PUSH
5428: LD_INT 1
5430: ARRAY
5431: PUSH
5432: LD_VAR 0 1
5436: PUSH
5437: LD_INT 1
5439: ARRAY
5440: DIFF
5441: PPUSH
5442: CALL_OW 1
5446: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5447: LD_VAR 0 1
5451: PUSH
5452: LD_INT 1
5454: ARRAY
5455: PPUSH
5456: CALL_OW 310
5460: IFFALSE 5475
// ComExitBuilding ( sci [ 1 ] ) ;
5462: LD_VAR 0 1
5466: PUSH
5467: LD_INT 1
5469: ARRAY
5470: PPUSH
5471: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5475: LD_INT 2
5477: PPUSH
5478: LD_INT 105
5480: PPUSH
5481: LD_INT 14
5483: PPUSH
5484: LD_INT 20
5486: PPUSH
5487: CALL 20203 0 4
5491: PUSH
5492: LD_INT 4
5494: ARRAY
5495: PUSH
5496: LD_INT 10
5498: LESS
5499: IFFALSE 5522
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5501: LD_VAR 0 1
5505: PUSH
5506: LD_INT 1
5508: ARRAY
5509: PPUSH
5510: LD_INT 105
5512: PPUSH
5513: LD_INT 14
5515: PPUSH
5516: CALL_OW 171
5520: GO 5541
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5522: LD_VAR 0 1
5526: PUSH
5527: LD_INT 1
5529: ARRAY
5530: PPUSH
5531: LD_INT 118
5533: PPUSH
5534: LD_INT 77
5536: PPUSH
5537: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5541: LD_VAR 0 1
5545: PUSH
5546: LD_INT 1
5548: ARRAY
5549: PPUSH
5550: LD_INT 92
5552: PPUSH
5553: LD_INT 40
5555: PPUSH
5556: CALL_OW 218
// end ;
5560: PPOPN 1
5562: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5563: LD_INT 1
5565: PPUSH
5566: CALL_OW 302
5570: PUSH
5571: LD_EXP 9
5575: AND
5576: IFFALSE 6055
5578: GO 5580
5580: DISABLE
5581: LD_INT 0
5583: PPUSH
5584: PPUSH
5585: PPUSH
5586: PPUSH
5587: PPUSH
5588: PPUSH
// begin enable ;
5589: ENABLE
// base := 1 ;
5590: LD_ADDR_VAR 0 2
5594: PUSH
5595: LD_INT 1
5597: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5598: LD_ADDR_VAR 0 4
5602: PUSH
5603: LD_INT 0
5605: PUSH
5606: LD_INT 0
5608: PUSH
5609: LD_INT 0
5611: PUSH
5612: LD_INT 0
5614: PUSH
5615: LD_INT 0
5617: PUSH
5618: LD_INT 0
5620: PUSH
5621: LD_INT 0
5623: PUSH
5624: LD_INT 0
5626: PUSH
5627: LD_INT 1
5629: PUSH
5630: LD_INT 0
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: LIST
5641: LIST
5642: LIST
5643: LIST
5644: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5645: LD_ADDR_VAR 0 3
5649: PUSH
5650: LD_INT 14
5652: PUSH
5653: LD_INT 1
5655: PUSH
5656: LD_INT 2
5658: PUSH
5659: LD_INT 26
5661: PUSH
5662: EMPTY
5663: LIST
5664: LIST
5665: LIST
5666: LIST
5667: PUSH
5668: LD_INT 14
5670: PUSH
5671: LD_INT 1
5673: PUSH
5674: LD_INT 2
5676: PUSH
5677: LD_INT 28
5679: PUSH
5680: EMPTY
5681: LIST
5682: LIST
5683: LIST
5684: LIST
5685: PUSH
5686: LD_INT 13
5688: PUSH
5689: LD_INT 1
5691: PUSH
5692: LD_INT 2
5694: PUSH
5695: LD_INT 29
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: LIST
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: LIST
5708: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5709: LD_ADDR_VAR 0 1
5713: PUSH
5714: DOUBLE
5715: LD_INT 1
5717: DEC
5718: ST_TO_ADDR
5719: LD_OWVAR 67
5723: PUSH
5724: LD_OWVAR 1
5728: PUSH
5729: LD_INT 21000
5731: DIV
5732: PLUS
5733: PUSH
5734: FOR_TO
5735: IFFALSE 5827
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5737: LD_ADDR_VAR 0 3
5741: PUSH
5742: LD_VAR 0 3
5746: PPUSH
5747: LD_VAR 0 3
5751: PUSH
5752: LD_INT 1
5754: PLUS
5755: PPUSH
5756: LD_INT 13
5758: PUSH
5759: LD_INT 14
5761: PUSH
5762: EMPTY
5763: LIST
5764: LIST
5765: PUSH
5766: LD_INT 1
5768: PPUSH
5769: LD_INT 2
5771: PPUSH
5772: CALL_OW 12
5776: ARRAY
5777: PUSH
5778: LD_INT 1
5780: PUSH
5781: LD_INT 2
5783: PUSH
5784: LD_INT 28
5786: PUSH
5787: LD_INT 29
5789: PUSH
5790: LD_INT 25
5792: PUSH
5793: LD_INT 26
5795: PUSH
5796: EMPTY
5797: LIST
5798: LIST
5799: LIST
5800: LIST
5801: PUSH
5802: LD_INT 1
5804: PPUSH
5805: LD_INT 4
5807: PPUSH
5808: CALL_OW 12
5812: ARRAY
5813: PUSH
5814: EMPTY
5815: LIST
5816: LIST
5817: LIST
5818: LIST
5819: PPUSH
5820: CALL_OW 2
5824: ST_TO_ADDR
5825: GO 5734
5827: POP
5828: POP
// MC_InsertProduceList ( base , tmp ) ;
5829: LD_VAR 0 2
5833: PPUSH
5834: LD_VAR 0 3
5838: PPUSH
5839: CALL 75913 0 2
// repeat wait ( 0 0$1 ) ;
5843: LD_INT 35
5845: PPUSH
5846: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5850: LD_EXP 78
5854: PUSH
5855: LD_VAR 0 2
5859: ARRAY
5860: PUSH
5861: LD_INT 6
5863: GREATER
5864: IFFALSE 5843
// wait ( 0 0$20 ) ;
5866: LD_INT 700
5868: PPUSH
5869: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5873: LD_ADDR_VAR 0 5
5877: PUSH
5878: LD_INT 124
5880: PUSH
5881: LD_INT 85
5883: PUSH
5884: EMPTY
5885: LIST
5886: LIST
5887: PUSH
5888: LD_INT 90
5890: PUSH
5891: LD_INT 61
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: PUSH
5898: LD_INT 69
5900: PUSH
5901: LD_INT 48
5903: PUSH
5904: EMPTY
5905: LIST
5906: LIST
5907: PUSH
5908: LD_INT 68
5910: PUSH
5911: LD_INT 48
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: PUSH
5918: EMPTY
5919: LIST
5920: LIST
5921: LIST
5922: LIST
5923: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
5924: LD_ADDR_VAR 0 6
5928: PUSH
5929: LD_EXP 78
5933: PUSH
5934: LD_VAR 0 2
5938: ARRAY
5939: PUSH
5940: LD_EXP 78
5944: PUSH
5945: LD_VAR 0 2
5949: ARRAY
5950: PPUSH
5951: LD_INT 2
5953: PUSH
5954: LD_INT 34
5956: PUSH
5957: LD_INT 32
5959: PUSH
5960: EMPTY
5961: LIST
5962: LIST
5963: PUSH
5964: LD_INT 34
5966: PUSH
5967: LD_EXP 109
5971: PUSH
5972: EMPTY
5973: LIST
5974: LIST
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: PPUSH
5981: CALL_OW 72
5985: DIFF
5986: ST_TO_ADDR
// if not attackers then
5987: LD_VAR 0 6
5991: NOT
5992: IFFALSE 5996
// exit ;
5994: GO 6055
// ar_attackers := attackers ;
5996: LD_ADDR_EXP 10
6000: PUSH
6001: LD_VAR 0 6
6005: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6006: LD_INT 35
6008: PPUSH
6009: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6013: LD_VAR 0 6
6017: PPUSH
6018: LD_INT 60
6020: PUSH
6021: EMPTY
6022: LIST
6023: PPUSH
6024: CALL_OW 72
6028: NOT
6029: IFFALSE 6006
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6031: LD_VAR 0 2
6035: PPUSH
6036: LD_VAR 0 6
6040: PPUSH
6041: LD_VAR 0 5
6045: PPUSH
6046: LD_VAR 0 4
6050: PPUSH
6051: CALL 76098 0 4
// end ;
6055: PPOPN 6
6057: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6058: LD_INT 1
6060: PPUSH
6061: CALL_OW 302
6065: PUSH
6066: LD_EXP 9
6070: AND
6071: PUSH
6072: LD_EXP 49
6076: PPUSH
6077: LD_INT 22
6079: PPUSH
6080: CALL_OW 308
6084: AND
6085: PUSH
6086: LD_INT 1
6088: PPUSH
6089: CALL 76261 0 1
6093: PUSH
6094: LD_INT 0
6096: EQUAL
6097: AND
6098: PUSH
6099: LD_EXP 10
6103: NOT
6104: AND
6105: IFFALSE 6589
6107: GO 6109
6109: DISABLE
6110: LD_INT 0
6112: PPUSH
6113: PPUSH
6114: PPUSH
6115: PPUSH
6116: PPUSH
6117: PPUSH
6118: PPUSH
// begin base := 1 ;
6119: LD_ADDR_VAR 0 2
6123: PUSH
6124: LD_INT 1
6126: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6127: LD_ADDR_VAR 0 4
6131: PUSH
6132: LD_INT 0
6134: PUSH
6135: LD_INT 0
6137: PUSH
6138: LD_INT 0
6140: PUSH
6141: LD_INT 0
6143: PUSH
6144: LD_INT 0
6146: PUSH
6147: LD_INT 0
6149: PUSH
6150: LD_INT 0
6152: PUSH
6153: LD_INT 0
6155: PUSH
6156: LD_INT 1
6158: PUSH
6159: LD_INT 0
6161: PUSH
6162: EMPTY
6163: LIST
6164: LIST
6165: LIST
6166: LIST
6167: LIST
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6174: LD_ADDR_VAR 0 3
6178: PUSH
6179: LD_INT 13
6181: PUSH
6182: LD_INT 1
6184: PUSH
6185: LD_INT 2
6187: PUSH
6188: LD_INT 28
6190: PUSH
6191: EMPTY
6192: LIST
6193: LIST
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 13
6199: PUSH
6200: LD_INT 1
6202: PUSH
6203: LD_INT 2
6205: PUSH
6206: LD_INT 27
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 13
6217: PUSH
6218: LD_INT 1
6220: PUSH
6221: LD_INT 2
6223: PUSH
6224: LD_INT 25
6226: PUSH
6227: EMPTY
6228: LIST
6229: LIST
6230: LIST
6231: LIST
6232: PUSH
6233: LD_INT 11
6235: PUSH
6236: LD_INT 2
6238: PUSH
6239: LD_INT 2
6241: PUSH
6242: LD_INT 24
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: PUSH
6251: LD_INT 11
6253: PUSH
6254: LD_INT 2
6256: PUSH
6257: LD_INT 2
6259: PUSH
6260: LD_INT 24
6262: PUSH
6263: EMPTY
6264: LIST
6265: LIST
6266: LIST
6267: LIST
6268: PUSH
6269: EMPTY
6270: LIST
6271: LIST
6272: LIST
6273: LIST
6274: LIST
6275: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6276: LD_VAR 0 2
6280: PPUSH
6281: LD_VAR 0 3
6285: PPUSH
6286: CALL 75913 0 2
// repeat wait ( 0 0$1 ) ;
6290: LD_INT 35
6292: PPUSH
6293: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6297: LD_EXP 78
6301: PUSH
6302: LD_VAR 0 2
6306: ARRAY
6307: PUSH
6308: LD_INT 6
6310: GREATEREQUAL
6311: IFFALSE 6290
// wait ( 0 0$20 ) ;
6313: LD_INT 700
6315: PPUSH
6316: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6320: LD_ADDR_VAR 0 5
6324: PUSH
6325: LD_INT 119
6327: PUSH
6328: LD_INT 9
6330: PUSH
6331: EMPTY
6332: LIST
6333: LIST
6334: PUSH
6335: EMPTY
6336: LIST
6337: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6338: LD_ADDR_VAR 0 6
6342: PUSH
6343: LD_EXP 78
6347: PUSH
6348: LD_VAR 0 2
6352: ARRAY
6353: PUSH
6354: LD_EXP 78
6358: PUSH
6359: LD_VAR 0 2
6363: ARRAY
6364: PPUSH
6365: LD_INT 2
6367: PUSH
6368: LD_INT 34
6370: PUSH
6371: LD_INT 32
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PUSH
6378: LD_INT 34
6380: PUSH
6381: LD_EXP 109
6385: PUSH
6386: EMPTY
6387: LIST
6388: LIST
6389: PUSH
6390: EMPTY
6391: LIST
6392: LIST
6393: LIST
6394: PPUSH
6395: CALL_OW 72
6399: DIFF
6400: ST_TO_ADDR
// if not attackers then
6401: LD_VAR 0 6
6405: NOT
6406: IFFALSE 6410
// exit ;
6408: GO 6589
// uc_side := 2 ;
6410: LD_ADDR_OWVAR 20
6414: PUSH
6415: LD_INT 2
6417: ST_TO_ADDR
// uc_nation := 2 ;
6418: LD_ADDR_OWVAR 21
6422: PUSH
6423: LD_INT 2
6425: ST_TO_ADDR
// InitHc ;
6426: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6430: LD_ADDR_VAR 0 1
6434: PUSH
6435: DOUBLE
6436: LD_INT 1
6438: DEC
6439: ST_TO_ADDR
6440: LD_INT 4
6442: PUSH
6443: LD_INT 5
6445: PUSH
6446: LD_INT 6
6448: PUSH
6449: EMPTY
6450: LIST
6451: LIST
6452: LIST
6453: PUSH
6454: LD_OWVAR 67
6458: ARRAY
6459: PUSH
6460: FOR_TO
6461: IFFALSE 6538
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6463: LD_INT 0
6465: PPUSH
6466: LD_INT 15
6468: PUSH
6469: LD_INT 17
6471: PUSH
6472: EMPTY
6473: LIST
6474: LIST
6475: PUSH
6476: LD_INT 1
6478: PPUSH
6479: LD_INT 2
6481: PPUSH
6482: CALL_OW 12
6486: ARRAY
6487: PPUSH
6488: LD_INT 8
6490: PPUSH
6491: CALL_OW 380
// un := CreateHuman ;
6495: LD_ADDR_VAR 0 7
6499: PUSH
6500: CALL_OW 44
6504: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6505: LD_VAR 0 7
6509: PPUSH
6510: LD_INT 23
6512: PPUSH
6513: LD_INT 0
6515: PPUSH
6516: CALL_OW 49
// attackers := attackers union un ;
6520: LD_ADDR_VAR 0 6
6524: PUSH
6525: LD_VAR 0 6
6529: PUSH
6530: LD_VAR 0 7
6534: UNION
6535: ST_TO_ADDR
// end ;
6536: GO 6460
6538: POP
6539: POP
// repeat wait ( 0 0$1 ) ;
6540: LD_INT 35
6542: PPUSH
6543: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6547: LD_VAR 0 6
6551: PPUSH
6552: LD_INT 60
6554: PUSH
6555: EMPTY
6556: LIST
6557: PPUSH
6558: CALL_OW 72
6562: NOT
6563: IFFALSE 6540
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6565: LD_VAR 0 2
6569: PPUSH
6570: LD_VAR 0 6
6574: PPUSH
6575: LD_VAR 0 5
6579: PPUSH
6580: LD_VAR 0 4
6584: PPUSH
6585: CALL 76098 0 4
// end ; end_of_file
6589: PPOPN 7
6591: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6592: LD_INT 0
6594: PPUSH
6595: PPUSH
6596: PPUSH
6597: PPUSH
// uc_side := 1 ;
6598: LD_ADDR_OWVAR 20
6602: PUSH
6603: LD_INT 1
6605: ST_TO_ADDR
// uc_nation := 1 ;
6606: LD_ADDR_OWVAR 21
6610: PUSH
6611: LD_INT 1
6613: ST_TO_ADDR
// InitHc ;
6614: CALL_OW 19
// InitVc ;
6618: CALL_OW 20
// tmp := [ ] ;
6622: LD_ADDR_VAR 0 3
6626: PUSH
6627: EMPTY
6628: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6629: LD_ADDR_VAR 0 2
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_INT 5
6641: PUSH
6642: LD_INT 6
6644: PUSH
6645: LD_INT 6
6647: PUSH
6648: EMPTY
6649: LIST
6650: LIST
6651: LIST
6652: PUSH
6653: LD_OWVAR 67
6657: ARRAY
6658: PUSH
6659: FOR_TO
6660: IFFALSE 6797
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6662: LD_INT 2
6664: PUSH
6665: LD_INT 4
6667: PUSH
6668: LD_INT 5
6670: PUSH
6671: EMPTY
6672: LIST
6673: LIST
6674: LIST
6675: PUSH
6676: LD_INT 1
6678: PPUSH
6679: LD_INT 3
6681: PPUSH
6682: CALL_OW 12
6686: ARRAY
6687: PPUSH
6688: LD_INT 1
6690: PUSH
6691: LD_INT 3
6693: PUSH
6694: EMPTY
6695: LIST
6696: LIST
6697: PUSH
6698: LD_INT 1
6700: PPUSH
6701: LD_INT 2
6703: PPUSH
6704: CALL_OW 12
6708: ARRAY
6709: PPUSH
6710: LD_INT 3
6712: PPUSH
6713: LD_INT 9
6715: PUSH
6716: LD_INT 7
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PUSH
6723: LD_INT 1
6725: PPUSH
6726: LD_INT 2
6728: PPUSH
6729: CALL_OW 12
6733: ARRAY
6734: PPUSH
6735: LD_INT 78
6737: PPUSH
6738: CALL 19185 0 5
// veh := CreateVehicle ;
6742: LD_ADDR_VAR 0 4
6746: PUSH
6747: CALL_OW 45
6751: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6752: LD_VAR 0 4
6756: PPUSH
6757: LD_INT 2
6759: PPUSH
6760: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6764: LD_VAR 0 4
6768: PPUSH
6769: LD_INT 17
6771: PPUSH
6772: LD_INT 0
6774: PPUSH
6775: CALL_OW 49
// tmp := tmp ^ veh ;
6779: LD_ADDR_VAR 0 3
6783: PUSH
6784: LD_VAR 0 3
6788: PUSH
6789: LD_VAR 0 4
6793: ADD
6794: ST_TO_ADDR
// end ;
6795: GO 6659
6797: POP
6798: POP
// if not tmp then
6799: LD_VAR 0 3
6803: NOT
6804: IFFALSE 6808
// exit ;
6806: GO 6917
// if not first_powell_attack then
6808: LD_EXP 11
6812: NOT
6813: IFFALSE 6823
// first_powell_attack := true ;
6815: LD_ADDR_EXP 11
6819: PUSH
6820: LD_INT 1
6822: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6823: LD_INT 70
6825: PPUSH
6826: CALL_OW 67
// for i in tmp do
6830: LD_ADDR_VAR 0 2
6834: PUSH
6835: LD_VAR 0 3
6839: PUSH
6840: FOR_IN
6841: IFFALSE 6908
// if IsOk ( i ) then
6843: LD_VAR 0 2
6847: PPUSH
6848: CALL_OW 302
6852: IFFALSE 6890
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6854: LD_VAR 0 2
6858: PPUSH
6859: LD_INT 81
6861: PUSH
6862: LD_INT 1
6864: PUSH
6865: EMPTY
6866: LIST
6867: LIST
6868: PPUSH
6869: CALL_OW 69
6873: PPUSH
6874: LD_VAR 0 2
6878: PPUSH
6879: CALL_OW 74
6883: PPUSH
6884: CALL_OW 115
6888: GO 6906
// tmp := tmp diff i ;
6890: LD_ADDR_VAR 0 3
6894: PUSH
6895: LD_VAR 0 3
6899: PUSH
6900: LD_VAR 0 2
6904: DIFF
6905: ST_TO_ADDR
6906: GO 6840
6908: POP
6909: POP
// until not tmp ;
6910: LD_VAR 0 3
6914: NOT
6915: IFFALSE 6823
// end ; end_of_file
6917: LD_VAR 0 1
6921: RET
// export function Action ; var tmp , i , un ; begin
6922: LD_INT 0
6924: PPUSH
6925: PPUSH
6926: PPUSH
6927: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6928: LD_INT 68
6930: PPUSH
6931: LD_INT 39
6933: PPUSH
6934: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6938: LD_ADDR_VAR 0 2
6942: PUSH
6943: LD_INT 22
6945: PUSH
6946: LD_INT 7
6948: PUSH
6949: EMPTY
6950: LIST
6951: LIST
6952: PPUSH
6953: CALL_OW 69
6957: ST_TO_ADDR
// InGameOn ;
6958: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6962: LD_VAR 0 2
6966: PPUSH
6967: LD_INT 71
6969: PPUSH
6970: LD_INT 49
6972: PPUSH
6973: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6977: LD_INT 35
6979: PPUSH
6980: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6984: LD_INT 7
6986: PPUSH
6987: LD_INT 71
6989: PPUSH
6990: LD_INT 51
6992: PPUSH
6993: CALL_OW 293
6997: IFFALSE 6977
// DialogueOn ;
6999: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7003: LD_EXP 15
7007: PPUSH
7008: LD_STRING D1-JMM-1
7010: PPUSH
7011: CALL_OW 88
// if Joan then
7015: LD_EXP 30
7019: IFFALSE 7033
// Say ( Joan , D1-Joan-1 ) ;
7021: LD_EXP 30
7025: PPUSH
7026: LD_STRING D1-Joan-1
7028: PPUSH
7029: CALL_OW 88
// if Lisa then
7033: LD_EXP 17
7037: IFFALSE 7051
// Say ( Lisa , D1-Lisa-1 ) ;
7039: LD_EXP 17
7043: PPUSH
7044: LD_STRING D1-Lisa-1
7046: PPUSH
7047: CALL_OW 88
// if Joan or Lisa then
7051: LD_EXP 30
7055: PUSH
7056: LD_EXP 17
7060: OR
7061: IFFALSE 7075
// Say ( JMM , D1-JMM-2 ) ;
7063: LD_EXP 15
7067: PPUSH
7068: LD_STRING D1-JMM-2
7070: PPUSH
7071: CALL_OW 88
// DialogueOff ;
7075: CALL_OW 7
// InGameOff ;
7079: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7083: LD_INT 71
7085: PPUSH
7086: LD_INT 50
7088: PPUSH
7089: LD_INT 7
7091: PPUSH
7092: LD_INT 30
7094: NEG
7095: PPUSH
7096: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7100: LD_INT 71
7102: PPUSH
7103: LD_INT 50
7105: PPUSH
7106: LD_INT 7
7108: PPUSH
7109: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7113: LD_STRING M1
7115: PPUSH
7116: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7120: LD_INT 35
7122: PPUSH
7123: CALL_OW 67
// until freedom ;
7127: LD_EXP 3
7131: IFFALSE 7120
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7133: LD_INT 350
7135: PPUSH
7136: LD_INT 700
7138: PPUSH
7139: CALL_OW 12
7143: PPUSH
7144: CALL_OW 67
// PrepareGossudarov ;
7148: CALL 1827 0 0
// repeat wait ( 0 0$1 ) ;
7152: LD_INT 35
7154: PPUSH
7155: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7159: LD_INT 22
7161: PUSH
7162: LD_INT 6
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: PUSH
7169: LD_INT 3
7171: PUSH
7172: LD_INT 24
7174: PUSH
7175: LD_INT 1000
7177: PUSH
7178: EMPTY
7179: LIST
7180: LIST
7181: PUSH
7182: EMPTY
7183: LIST
7184: LIST
7185: PUSH
7186: EMPTY
7187: LIST
7188: LIST
7189: PPUSH
7190: CALL_OW 69
7194: PUSH
7195: LD_INT 7
7197: PPUSH
7198: LD_EXP 32
7202: PPUSH
7203: CALL_OW 292
7207: OR
7208: IFFALSE 7152
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7210: LD_ADDR_VAR 0 2
7214: PUSH
7215: LD_INT 22
7217: PUSH
7218: LD_INT 6
7220: PUSH
7221: EMPTY
7222: LIST
7223: LIST
7224: PPUSH
7225: CALL_OW 69
7229: ST_TO_ADDR
// for i in tmp do
7230: LD_ADDR_VAR 0 3
7234: PUSH
7235: LD_VAR 0 2
7239: PUSH
7240: FOR_IN
7241: IFFALSE 7257
// SetSide ( i , 7 ) ;
7243: LD_VAR 0 3
7247: PPUSH
7248: LD_INT 7
7250: PPUSH
7251: CALL_OW 235
7255: GO 7240
7257: POP
7258: POP
// DialogueOn ;
7259: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7263: LD_EXP 15
7267: PUSH
7268: LD_EXP 16
7272: PUSH
7273: EMPTY
7274: LIST
7275: LIST
7276: PPUSH
7277: LD_EXP 32
7281: PPUSH
7282: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7286: LD_EXP 32
7290: PPUSH
7291: CALL_OW 87
// if not Roth then
7295: LD_EXP 16
7299: NOT
7300: IFFALSE 7392
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7302: LD_VAR 0 2
7306: PPUSH
7307: LD_INT 3
7309: PUSH
7310: LD_INT 24
7312: PUSH
7313: LD_INT 1000
7315: PUSH
7316: EMPTY
7317: LIST
7318: LIST
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: PPUSH
7324: CALL_OW 72
7328: IFFALSE 7342
// Say ( JMM , D2-JMM-1 ) ;
7330: LD_EXP 15
7334: PPUSH
7335: LD_STRING D2-JMM-1
7337: PPUSH
7338: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7342: LD_EXP 15
7346: PPUSH
7347: LD_STRING D2-JMM-1b
7349: PPUSH
7350: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7354: LD_EXP 32
7358: PPUSH
7359: LD_STRING D2-Gos-1
7361: PPUSH
7362: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7366: LD_EXP 15
7370: PPUSH
7371: LD_STRING D2-JMM-2
7373: PPUSH
7374: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7378: LD_EXP 32
7382: PPUSH
7383: LD_STRING D2-Gos-2
7385: PPUSH
7386: CALL_OW 88
// end else
7390: GO 7544
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7392: LD_VAR 0 2
7396: PPUSH
7397: LD_INT 3
7399: PUSH
7400: LD_INT 24
7402: PUSH
7403: LD_INT 1000
7405: PUSH
7406: EMPTY
7407: LIST
7408: LIST
7409: PUSH
7410: EMPTY
7411: LIST
7412: LIST
7413: PPUSH
7414: CALL_OW 72
7418: IFFALSE 7444
// begin Say ( Roth , D2-Roth-2 ) ;
7420: LD_EXP 16
7424: PPUSH
7425: LD_STRING D2-Roth-2
7427: PPUSH
7428: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7432: LD_EXP 15
7436: PPUSH
7437: LD_STRING D2-JMM-1a
7439: PPUSH
7440: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7444: LD_EXP 16
7448: PPUSH
7449: LD_STRING D2-Roth-2a
7451: PPUSH
7452: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7456: LD_EXP 16
7460: PPUSH
7461: LD_STRING D2-Roth-2b
7463: PPUSH
7464: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7468: LD_EXP 15
7472: PPUSH
7473: LD_STRING D2-JMM-3
7475: PPUSH
7476: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7480: LD_VAR 0 2
7484: PPUSH
7485: LD_INT 3
7487: PUSH
7488: LD_INT 24
7490: PUSH
7491: LD_INT 1000
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: PPUSH
7502: CALL_OW 72
7506: IFFALSE 7544
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7508: LD_EXP 32
7512: PPUSH
7513: LD_STRING D2-Gos-3
7515: PPUSH
7516: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7520: LD_EXP 15
7524: PPUSH
7525: LD_STRING D2-JMM-4
7527: PPUSH
7528: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7532: LD_EXP 32
7536: PPUSH
7537: LD_STRING D2-Gos-4
7539: PPUSH
7540: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7544: LD_EXP 15
7548: PPUSH
7549: LD_STRING D2-JMM-5
7551: PPUSH
7552: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7556: LD_EXP 32
7560: PPUSH
7561: LD_STRING D2-Gos-5
7563: PPUSH
7564: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7568: LD_EXP 15
7572: PPUSH
7573: LD_STRING D2-JMM-6
7575: PPUSH
7576: CALL_OW 88
// DialogueOff ;
7580: CALL_OW 7
// wait ( 0 0$2 ) ;
7584: LD_INT 70
7586: PPUSH
7587: CALL_OW 67
// if Kirilenkova then
7591: LD_EXP 33
7595: IFFALSE 7609
// Say ( Kirilenkova , D3-Kir-1 ) ;
7597: LD_EXP 33
7601: PPUSH
7602: LD_STRING D3-Kir-1
7604: PPUSH
7605: CALL_OW 88
// gossudarov_arrive := true ;
7609: LD_ADDR_EXP 4
7613: PUSH
7614: LD_INT 1
7616: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7617: LD_INT 35
7619: PPUSH
7620: CALL_OW 67
// until ru_lab_builded ;
7624: LD_EXP 5
7628: IFFALSE 7617
// DialogueOn ;
7630: CALL_OW 6
// if Kirilenkova then
7634: LD_EXP 33
7638: IFFALSE 7654
// Say ( Kirilenkova , D3a-Kir-1 ) else
7640: LD_EXP 33
7644: PPUSH
7645: LD_STRING D3a-Kir-1
7647: PPUSH
7648: CALL_OW 88
7652: GO 7676
// begin un := SciRu ;
7654: LD_ADDR_VAR 0 4
7658: PUSH
7659: CALL 12788 0 0
7663: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7664: LD_VAR 0 4
7668: PPUSH
7669: LD_STRING D3a-Sci1-1
7671: PPUSH
7672: CALL_OW 88
// end ; if Kirilenkova or un then
7676: LD_EXP 33
7680: PUSH
7681: LD_VAR 0 4
7685: OR
7686: IFFALSE 7700
// Say ( JMM , D3a-JMM-1 ) ;
7688: LD_EXP 15
7692: PPUSH
7693: LD_STRING D3a-JMM-1
7695: PPUSH
7696: CALL_OW 88
// DialogueOff ;
7700: CALL_OW 7
// end ;
7704: LD_VAR 0 1
7708: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7709: LD_EXP 4
7713: PUSH
7714: LD_INT 22
7716: PUSH
7717: LD_INT 7
7719: PUSH
7720: EMPTY
7721: LIST
7722: LIST
7723: PUSH
7724: LD_INT 2
7726: PUSH
7727: LD_INT 25
7729: PUSH
7730: LD_INT 1
7732: PUSH
7733: EMPTY
7734: LIST
7735: LIST
7736: PUSH
7737: LD_INT 25
7739: PUSH
7740: LD_INT 2
7742: PUSH
7743: EMPTY
7744: LIST
7745: LIST
7746: PUSH
7747: LD_INT 25
7749: PUSH
7750: LD_INT 3
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: PUSH
7757: LD_INT 25
7759: PUSH
7760: LD_INT 4
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PUSH
7767: LD_INT 25
7769: PUSH
7770: LD_INT 5
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PUSH
7777: LD_INT 25
7779: PUSH
7780: LD_INT 8
7782: PUSH
7783: EMPTY
7784: LIST
7785: LIST
7786: PUSH
7787: LD_INT 25
7789: PUSH
7790: LD_INT 9
7792: PUSH
7793: EMPTY
7794: LIST
7795: LIST
7796: PUSH
7797: EMPTY
7798: LIST
7799: LIST
7800: LIST
7801: LIST
7802: LIST
7803: LIST
7804: LIST
7805: LIST
7806: PUSH
7807: EMPTY
7808: LIST
7809: LIST
7810: PPUSH
7811: CALL_OW 69
7815: PUSH
7816: LD_INT 7
7818: LESS
7819: AND
7820: IFFALSE 7832
7822: GO 7824
7824: DISABLE
// YouLost ( TooMany ) ;
7825: LD_STRING TooMany
7827: PPUSH
7828: CALL_OW 104
7832: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7833: LD_EXP 32
7837: PPUSH
7838: CALL_OW 255
7842: PUSH
7843: LD_INT 7
7845: EQUAL
7846: IFFALSE 8046
7848: GO 7850
7850: DISABLE
7851: LD_INT 0
7853: PPUSH
7854: PPUSH
7855: PPUSH
// begin uc_side := 3 ;
7856: LD_ADDR_OWVAR 20
7860: PUSH
7861: LD_INT 3
7863: ST_TO_ADDR
// uc_nation := 3 ;
7864: LD_ADDR_OWVAR 21
7868: PUSH
7869: LD_INT 3
7871: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7872: LD_INT 21
7874: PPUSH
7875: LD_INT 3
7877: PPUSH
7878: LD_INT 3
7880: PPUSH
7881: LD_INT 42
7883: PPUSH
7884: LD_INT 100
7886: PPUSH
7887: CALL 19185 0 5
// un := CreateVehicle ;
7891: LD_ADDR_VAR 0 3
7895: PUSH
7896: CALL_OW 45
7900: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7901: LD_VAR 0 3
7905: PPUSH
7906: LD_INT 15
7908: PPUSH
7909: LD_INT 0
7911: PPUSH
7912: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7916: LD_VAR 0 3
7920: PPUSH
7921: LD_INT 67
7923: PPUSH
7924: LD_INT 45
7926: PPUSH
7927: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7931: LD_VAR 0 3
7935: PPUSH
7936: LD_INT 70
7938: PPUSH
7939: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7943: LD_VAR 0 3
7947: PPUSH
7948: LD_INT 69
7950: PPUSH
7951: LD_INT 18
7953: PPUSH
7954: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7958: LD_VAR 0 3
7962: PPUSH
7963: LD_INT 60
7965: PPUSH
7966: LD_INT 2
7968: PPUSH
7969: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7973: LD_INT 35
7975: PPUSH
7976: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7980: LD_VAR 0 3
7984: PPUSH
7985: CALL_OW 302
7989: NOT
7990: PUSH
7991: LD_VAR 0 3
7995: PPUSH
7996: LD_INT 17
7998: PPUSH
7999: CALL_OW 308
8003: OR
8004: IFFALSE 7973
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
8006: LD_VAR 0 3
8010: PPUSH
8011: LD_INT 17
8013: PPUSH
8014: CALL_OW 308
8018: PUSH
8019: LD_VAR 0 3
8023: PPUSH
8024: LD_INT 60
8026: PPUSH
8027: LD_INT 2
8029: PPUSH
8030: CALL_OW 307
8034: OR
8035: IFFALSE 8046
// RemoveUnit ( un ) ;
8037: LD_VAR 0 3
8041: PPUSH
8042: CALL_OW 64
// end ;
8046: PPOPN 3
8048: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8049: LD_EXP 4
8053: IFFALSE 8295
8055: GO 8057
8057: DISABLE
8058: LD_INT 0
8060: PPUSH
8061: PPUSH
8062: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8063: LD_INT 70
8065: PPUSH
8066: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8070: LD_ADDR_VAR 0 3
8074: PUSH
8075: LD_INT 22
8077: PUSH
8078: LD_INT 7
8080: PUSH
8081: EMPTY
8082: LIST
8083: LIST
8084: PUSH
8085: LD_INT 101
8087: PUSH
8088: LD_INT 3
8090: PUSH
8091: EMPTY
8092: LIST
8093: LIST
8094: PUSH
8095: EMPTY
8096: LIST
8097: LIST
8098: PPUSH
8099: CALL_OW 69
8103: ST_TO_ADDR
// until tmp ;
8104: LD_VAR 0 3
8108: IFFALSE 8063
// un := NearestUnitToUnit ( tmp , JMM ) ;
8110: LD_ADDR_VAR 0 2
8114: PUSH
8115: LD_VAR 0 3
8119: PPUSH
8120: LD_EXP 15
8124: PPUSH
8125: CALL_OW 74
8129: ST_TO_ADDR
// player_spotted := true ;
8130: LD_ADDR_EXP 6
8134: PUSH
8135: LD_INT 1
8137: ST_TO_ADDR
// tmp := SciRu ;
8138: LD_ADDR_VAR 0 3
8142: PUSH
8143: CALL 12788 0 0
8147: ST_TO_ADDR
// if not tmp then
8148: LD_VAR 0 3
8152: NOT
8153: IFFALSE 8165
// tmp := SolRu ;
8155: LD_ADDR_VAR 0 3
8159: PUSH
8160: CALL 12935 0 0
8164: ST_TO_ADDR
// DialogueOn ;
8165: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8169: LD_VAR 0 2
8173: PPUSH
8174: CALL_OW 250
8178: PPUSH
8179: LD_VAR 0 2
8183: PPUSH
8184: CALL_OW 251
8188: PPUSH
8189: LD_INT 7
8191: PPUSH
8192: LD_INT 8
8194: NEG
8195: PPUSH
8196: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8200: LD_VAR 0 2
8204: PPUSH
8205: CALL_OW 87
// if tmp then
8209: LD_VAR 0 3
8213: IFFALSE 8227
// Say ( tmp , D4-RSci1-1 ) ;
8215: LD_VAR 0 3
8219: PPUSH
8220: LD_STRING D4-RSci1-1
8222: PPUSH
8223: CALL_OW 88
// if Gossudarov then
8227: LD_EXP 32
8231: IFFALSE 8257
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8233: LD_EXP 32
8237: PPUSH
8238: LD_STRING D4-Gos-1
8240: PPUSH
8241: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8245: LD_EXP 15
8249: PPUSH
8250: LD_STRING D4-JMM-1
8252: PPUSH
8253: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8257: LD_VAR 0 2
8261: PPUSH
8262: CALL_OW 250
8266: PPUSH
8267: LD_VAR 0 2
8271: PPUSH
8272: CALL_OW 251
8276: PPUSH
8277: LD_INT 7
8279: PPUSH
8280: CALL_OW 331
// DialogueOff ;
8284: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8288: LD_STRING M5
8290: PPUSH
8291: CALL_OW 337
// end ;
8295: PPOPN 3
8297: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8298: LD_EXP 6
8302: IFFALSE 8891
8304: GO 8306
8306: DISABLE
8307: LD_INT 0
8309: PPUSH
8310: PPUSH
8311: PPUSH
// begin PrepareBelkov ;
8312: CALL 2117 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8316: LD_EXP 47
8320: PPUSH
8321: LD_INT 118
8323: PPUSH
8324: LD_INT 106
8326: PPUSH
8327: CALL_OW 111
// AddComHold ( Belkov ) ;
8331: LD_EXP 47
8335: PPUSH
8336: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8340: LD_INT 35
8342: PPUSH
8343: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8347: LD_EXP 47
8351: PPUSH
8352: LD_INT 118
8354: PPUSH
8355: LD_INT 106
8357: PPUSH
8358: CALL_OW 307
8362: IFFALSE 8340
// ChangeSideFog ( 4 , 7 ) ;
8364: LD_INT 4
8366: PPUSH
8367: LD_INT 7
8369: PPUSH
8370: CALL_OW 343
// if IsOk ( Belkov ) then
8374: LD_EXP 47
8378: PPUSH
8379: CALL_OW 302
8383: IFFALSE 8467
// begin InGameOn ;
8385: CALL_OW 8
// DialogueOn ;
8389: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8393: LD_EXP 47
8397: PPUSH
8398: LD_STRING D5-Bel-1
8400: PPUSH
8401: CALL_OW 94
// if Gossudarov then
8405: LD_EXP 32
8409: IFFALSE 8459
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8411: LD_EXP 32
8415: PPUSH
8416: LD_STRING D5-Gos-1
8418: PPUSH
8419: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8423: LD_EXP 15
8427: PPUSH
8428: LD_STRING D5-JMM-1
8430: PPUSH
8431: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8435: LD_EXP 32
8439: PPUSH
8440: LD_STRING D5-Gos-2
8442: PPUSH
8443: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8447: LD_EXP 15
8451: PPUSH
8452: LD_STRING D5-JMM-2
8454: PPUSH
8455: CALL_OW 88
// end ; DialogueOff ;
8459: CALL_OW 7
// InGameOff ;
8463: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8467: LD_STRING QSaveBelkov
8469: PPUSH
8470: CALL_OW 97
8474: PUSH
8475: LD_INT 1
8477: DOUBLE
8478: EQUAL
8479: IFTRUE 8483
8481: GO 8533
8483: POP
// begin DialogueOn ;
8484: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8488: LD_EXP 15
8492: PPUSH
8493: LD_STRING D5a-JMM-1
8495: PPUSH
8496: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8500: LD_EXP 47
8504: PPUSH
8505: LD_STRING D5a-Bel-1
8507: PPUSH
8508: CALL_OW 94
// DialogueOff ;
8512: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8516: LD_EXP 47
8520: PPUSH
8521: LD_INT 83
8523: PPUSH
8524: LD_INT 49
8526: PPUSH
8527: CALL_OW 111
// end ; 2 :
8531: GO 8566
8533: LD_INT 2
8535: DOUBLE
8536: EQUAL
8537: IFTRUE 8541
8539: GO 8565
8541: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8542: LD_EXP 15
8546: PPUSH
8547: LD_STRING D5a-JMM-2
8549: PPUSH
8550: CALL_OW 88
// ComHold ( Belkov ) ;
8554: LD_EXP 47
8558: PPUSH
8559: CALL_OW 140
// end ; end ;
8563: GO 8566
8565: POP
// time := 0 0$00 ;
8566: LD_ADDR_VAR 0 1
8570: PUSH
8571: LD_INT 0
8573: ST_TO_ADDR
// vehSpawned := false ;
8574: LD_ADDR_VAR 0 3
8578: PUSH
8579: LD_INT 0
8581: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8582: LD_INT 35
8584: PPUSH
8585: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8589: LD_VAR 0 1
8593: PUSH
8594: LD_INT 350
8596: PUSH
8597: LD_INT 175
8599: PUSH
8600: LD_INT 70
8602: PUSH
8603: EMPTY
8604: LIST
8605: LIST
8606: LIST
8607: PUSH
8608: LD_OWVAR 67
8612: ARRAY
8613: GREATEREQUAL
8614: PUSH
8615: LD_VAR 0 3
8619: NOT
8620: AND
8621: IFFALSE 8711
// begin vehSpawned := true ;
8623: LD_ADDR_VAR 0 3
8627: PUSH
8628: LD_INT 1
8630: ST_TO_ADDR
// uc_side := 3 ;
8631: LD_ADDR_OWVAR 20
8635: PUSH
8636: LD_INT 3
8638: ST_TO_ADDR
// uc_nation := 3 ;
8639: LD_ADDR_OWVAR 21
8643: PUSH
8644: LD_INT 3
8646: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8647: LD_INT 22
8649: PPUSH
8650: LD_INT 3
8652: PPUSH
8653: LD_INT 3
8655: PPUSH
8656: LD_INT 43
8658: PPUSH
8659: LD_INT 100
8661: PPUSH
8662: CALL 19185 0 5
// veh := CreateVehicle ;
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: CALL_OW 45
8675: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8676: LD_VAR 0 2
8680: PPUSH
8681: LD_INT 130
8683: PPUSH
8684: LD_INT 131
8686: PPUSH
8687: LD_INT 0
8689: PPUSH
8690: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8694: LD_VAR 0 2
8698: PPUSH
8699: LD_INT 100
8701: PPUSH
8702: LD_INT 82
8704: PPUSH
8705: CALL_OW 114
// end else
8709: GO 8725
// time := time + 0 0$1 ;
8711: LD_ADDR_VAR 0 1
8715: PUSH
8716: LD_VAR 0 1
8720: PUSH
8721: LD_INT 35
8723: PLUS
8724: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8725: LD_EXP 47
8729: PPUSH
8730: CALL_OW 301
8734: PUSH
8735: LD_EXP 47
8739: PPUSH
8740: CALL_OW 255
8744: PUSH
8745: LD_INT 4
8747: EQUAL
8748: AND
8749: PUSH
8750: LD_INT 22
8752: PUSH
8753: LD_INT 7
8755: PUSH
8756: EMPTY
8757: LIST
8758: LIST
8759: PPUSH
8760: CALL_OW 69
8764: PPUSH
8765: LD_EXP 47
8769: PPUSH
8770: CALL_OW 74
8774: PPUSH
8775: LD_EXP 47
8779: PPUSH
8780: CALL_OW 296
8784: PUSH
8785: LD_INT 10
8787: LESS
8788: OR
8789: IFFALSE 8582
// if IsDead ( Belkov ) then
8791: LD_EXP 47
8795: PPUSH
8796: CALL_OW 301
8800: IFFALSE 8825
// begin CenterNowOnUnits ( Belkov ) ;
8802: LD_EXP 47
8806: PPUSH
8807: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8811: LD_EXP 15
8815: PPUSH
8816: LD_STRING D5a-JMM-2a
8818: PPUSH
8819: CALL_OW 88
// exit ;
8823: GO 8891
// end ; if See ( 7 , Belkov ) then
8825: LD_INT 7
8827: PPUSH
8828: LD_EXP 47
8832: PPUSH
8833: CALL_OW 292
8837: IFFALSE 8851
// SetSide ( Belkov , 7 ) ;
8839: LD_EXP 47
8843: PPUSH
8844: LD_INT 7
8846: PPUSH
8847: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8851: LD_INT 35
8853: PPUSH
8854: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8858: LD_EXP 47
8862: PPUSH
8863: LD_INT 66
8865: PPUSH
8866: LD_INT 45
8868: PPUSH
8869: CALL_OW 297
8873: PUSH
8874: LD_INT 30
8876: LESS
8877: IFFALSE 8851
// Say ( Belkov , D6-Bel-1 ) ;
8879: LD_EXP 47
8883: PPUSH
8884: LD_STRING D6-Bel-1
8886: PPUSH
8887: CALL_OW 88
// end ;
8891: PPOPN 3
8893: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8894: LD_EXP 47
8898: PPUSH
8899: CALL_OW 302
8903: PUSH
8904: LD_EXP 47
8908: PPUSH
8909: CALL_OW 504
8913: PUSH
8914: LD_INT 2
8916: PUSH
8917: LD_INT 34
8919: PUSH
8920: LD_INT 47
8922: PUSH
8923: EMPTY
8924: LIST
8925: LIST
8926: PUSH
8927: LD_INT 34
8929: PUSH
8930: LD_INT 45
8932: PUSH
8933: EMPTY
8934: LIST
8935: LIST
8936: PUSH
8937: EMPTY
8938: LIST
8939: LIST
8940: LIST
8941: PPUSH
8942: CALL_OW 69
8946: IN
8947: AND
8948: IFFALSE 8965
8950: GO 8952
8952: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8953: LD_EXP 47
8957: PPUSH
8958: LD_STRING D7-Bel-1
8960: PPUSH
8961: CALL_OW 88
8965: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8966: LD_INT 22
8968: PUSH
8969: LD_INT 7
8971: PUSH
8972: EMPTY
8973: LIST
8974: LIST
8975: PUSH
8976: LD_INT 101
8978: PUSH
8979: LD_INT 2
8981: PUSH
8982: EMPTY
8983: LIST
8984: LIST
8985: PUSH
8986: EMPTY
8987: LIST
8988: LIST
8989: PPUSH
8990: CALL_OW 69
8994: PUSH
8995: LD_EXP 8
8999: NOT
9000: AND
9001: PUSH
9002: LD_EXP 46
9006: PPUSH
9007: CALL_OW 305
9011: NOT
9012: AND
9013: IFFALSE 9483
9015: GO 9017
9017: DISABLE
9018: LD_INT 0
9020: PPUSH
// begin ar_base_spotted := true ;
9021: LD_ADDR_EXP 8
9025: PUSH
9026: LD_INT 1
9028: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9029: LD_ADDR_VAR 0 1
9033: PUSH
9034: LD_INT 22
9036: PUSH
9037: LD_INT 2
9039: PUSH
9040: EMPTY
9041: LIST
9042: LIST
9043: PUSH
9044: LD_INT 21
9046: PUSH
9047: LD_INT 3
9049: PUSH
9050: EMPTY
9051: LIST
9052: LIST
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 69
9062: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9063: LD_ADDR_VAR 0 1
9067: PUSH
9068: LD_VAR 0 1
9072: PPUSH
9073: LD_EXP 15
9077: PPUSH
9078: CALL_OW 74
9082: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9083: LD_INT 7
9085: PPUSH
9086: LD_INT 3
9088: PPUSH
9089: CALL_OW 332
// DialogueOn ;
9093: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9097: LD_VAR 0 1
9101: PPUSH
9102: CALL_OW 250
9106: PPUSH
9107: LD_VAR 0 1
9111: PPUSH
9112: CALL_OW 251
9116: PPUSH
9117: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9121: LD_ADDR_VAR 0 1
9125: PUSH
9126: LD_INT 22
9128: PUSH
9129: LD_INT 7
9131: PUSH
9132: EMPTY
9133: LIST
9134: LIST
9135: PUSH
9136: LD_INT 23
9138: PUSH
9139: LD_INT 1
9141: PUSH
9142: EMPTY
9143: LIST
9144: LIST
9145: PUSH
9146: LD_INT 26
9148: PUSH
9149: LD_INT 1
9151: PUSH
9152: EMPTY
9153: LIST
9154: LIST
9155: PUSH
9156: EMPTY
9157: LIST
9158: LIST
9159: LIST
9160: PPUSH
9161: CALL_OW 69
9165: PUSH
9166: LD_EXP 15
9170: PUSH
9171: LD_EXP 19
9175: PUSH
9176: LD_EXP 20
9180: PUSH
9181: LD_EXP 27
9185: PUSH
9186: LD_EXP 16
9190: PUSH
9191: LD_EXP 25
9195: PUSH
9196: LD_EXP 21
9200: PUSH
9201: LD_EXP 23
9205: PUSH
9206: EMPTY
9207: LIST
9208: LIST
9209: LIST
9210: LIST
9211: LIST
9212: LIST
9213: LIST
9214: LIST
9215: DIFF
9216: ST_TO_ADDR
// if not tmp then
9217: LD_VAR 0 1
9221: NOT
9222: IFFALSE 9296
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9224: LD_ADDR_VAR 0 1
9228: PUSH
9229: LD_INT 22
9231: PUSH
9232: LD_INT 7
9234: PUSH
9235: EMPTY
9236: LIST
9237: LIST
9238: PUSH
9239: LD_INT 23
9241: PUSH
9242: LD_INT 1
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: PUSH
9249: LD_INT 26
9251: PUSH
9252: LD_INT 2
9254: PUSH
9255: EMPTY
9256: LIST
9257: LIST
9258: PUSH
9259: EMPTY
9260: LIST
9261: LIST
9262: LIST
9263: PPUSH
9264: CALL_OW 69
9268: PUSH
9269: LD_EXP 30
9273: PUSH
9274: LD_EXP 17
9278: PUSH
9279: LD_EXP 28
9283: PUSH
9284: LD_EXP 29
9288: PUSH
9289: EMPTY
9290: LIST
9291: LIST
9292: LIST
9293: LIST
9294: DIFF
9295: ST_TO_ADDR
// if tmp then
9296: LD_VAR 0 1
9300: IFFALSE 9371
// case GetSex ( tmp [ 1 ] ) of sex_male :
9302: LD_VAR 0 1
9306: PUSH
9307: LD_INT 1
9309: ARRAY
9310: PPUSH
9311: CALL_OW 258
9315: PUSH
9316: LD_INT 1
9318: DOUBLE
9319: EQUAL
9320: IFTRUE 9324
9322: GO 9343
9324: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9325: LD_VAR 0 1
9329: PUSH
9330: LD_INT 1
9332: ARRAY
9333: PPUSH
9334: LD_STRING D9-Sol1-1
9336: PPUSH
9337: CALL_OW 88
9341: GO 9371
9343: LD_INT 2
9345: DOUBLE
9346: EQUAL
9347: IFTRUE 9351
9349: GO 9370
9351: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9352: LD_VAR 0 1
9356: PUSH
9357: LD_INT 1
9359: ARRAY
9360: PPUSH
9361: LD_STRING D9-FSol1-1
9363: PPUSH
9364: CALL_OW 88
9368: GO 9371
9370: POP
// if Frank then
9371: LD_EXP 27
9375: IFFALSE 9479
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9377: LD_EXP 56
9381: PPUSH
9382: CALL_OW 250
9386: PPUSH
9387: LD_EXP 56
9391: PPUSH
9392: CALL_OW 251
9396: PPUSH
9397: LD_INT 7
9399: PPUSH
9400: LD_INT 8
9402: PPUSH
9403: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9407: LD_EXP 56
9411: PPUSH
9412: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9416: LD_EXP 27
9420: PPUSH
9421: LD_STRING D9-Frank-1
9423: PPUSH
9424: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9428: LD_EXP 15
9432: PPUSH
9433: LD_STRING D9-JMM-1
9435: PPUSH
9436: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9440: LD_EXP 27
9444: PPUSH
9445: LD_STRING D9-Frank-2
9447: PPUSH
9448: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9452: LD_EXP 56
9456: PPUSH
9457: CALL_OW 250
9461: PPUSH
9462: LD_EXP 56
9466: PPUSH
9467: CALL_OW 251
9471: PPUSH
9472: LD_INT 7
9474: PPUSH
9475: CALL_OW 331
// end ; DialogueOff ;
9479: CALL_OW 7
// end ;
9483: PPOPN 1
9485: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9486: LD_EXP 7
9490: PUSH
9491: LD_OWVAR 1
9495: PUSH
9496: LD_INT 42000
9498: GREATEREQUAL
9499: OR
9500: IFFALSE 10527
9502: GO 9504
9504: DISABLE
9505: LD_INT 0
9507: PPUSH
9508: PPUSH
// begin selected_option := 1 ;
9509: LD_ADDR_VAR 0 2
9513: PUSH
9514: LD_INT 1
9516: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9517: LD_INT 10500
9519: PPUSH
9520: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9524: LD_INT 35
9526: PPUSH
9527: CALL_OW 67
// until not ru_attackers ;
9531: LD_EXP 52
9535: NOT
9536: IFFALSE 9524
// PrepareBurlak ;
9538: CALL 2229 0 0
// repeat wait ( 0 0$2 ) ;
9542: LD_INT 70
9544: PPUSH
9545: CALL_OW 67
// until not HasTask ( Burlak ) ;
9549: LD_EXP 46
9553: PPUSH
9554: CALL_OW 314
9558: NOT
9559: IFFALSE 9542
// InGameOn ;
9561: CALL_OW 8
// DialogueOn ;
9565: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9569: LD_EXP 49
9573: PPUSH
9574: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9578: LD_EXP 46
9582: PPUSH
9583: LD_STRING D10-Bur-1
9585: PPUSH
9586: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9590: LD_EXP 47
9594: PUSH
9595: LD_EXP 47
9599: PPUSH
9600: CALL_OW 255
9604: PUSH
9605: LD_INT 7
9607: EQUAL
9608: AND
9609: IFFALSE 9623
// Say ( Belkov , D10-Bel-1 ) ;
9611: LD_EXP 47
9615: PPUSH
9616: LD_STRING D10-Bel-1
9618: PPUSH
9619: CALL_OW 88
// if Gossudarov then
9623: LD_EXP 32
9627: IFFALSE 9641
// Say ( Gossudarov , D10-Gos-1 ) ;
9629: LD_EXP 32
9633: PPUSH
9634: LD_STRING D10-Gos-1
9636: PPUSH
9637: CALL_OW 88
// if Kirilenkova then
9641: LD_EXP 33
9645: IFFALSE 9659
// Say ( Kirilenkova , D10-Kir-1 ) ;
9647: LD_EXP 33
9651: PPUSH
9652: LD_STRING D10-Kir-1
9654: PPUSH
9655: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9659: CALL 12935 0 0
9663: PPUSH
9664: LD_STRING D10-RSol1-1
9666: PPUSH
9667: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9671: LD_EXP 46
9675: PPUSH
9676: LD_STRING D10-Bur-2
9678: PPUSH
9679: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D10-JMM-2
9690: PPUSH
9691: CALL_OW 88
// if Kirilenkova then
9695: LD_EXP 33
9699: IFFALSE 9715
// Say ( Kirilenkova , D10-Kir-2 ) else
9701: LD_EXP 33
9705: PPUSH
9706: LD_STRING D10-Kir-2
9708: PPUSH
9709: CALL_OW 88
9713: GO 9727
// Say ( SolRu , D10-RSol1-2 ) ;
9715: CALL 12935 0 0
9719: PPUSH
9720: LD_STRING D10-RSol1-2
9722: PPUSH
9723: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9727: LD_EXP 15
9731: PPUSH
9732: LD_STRING D10-JMM-3
9734: PPUSH
9735: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9739: LD_EXP 46
9743: PPUSH
9744: LD_STRING D10-Bur-3
9746: PPUSH
9747: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9751: LD_EXP 15
9755: PPUSH
9756: LD_STRING D10-JMM-4
9758: PPUSH
9759: CALL_OW 88
// DialogueOff ;
9763: CALL_OW 7
// InGameOff ;
9767: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9771: LD_STRING M2
9773: PPUSH
9774: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9778: LD_INT 35
9780: PPUSH
9781: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9785: LD_INT 22
9787: PUSH
9788: LD_INT 7
9790: PUSH
9791: EMPTY
9792: LIST
9793: LIST
9794: PUSH
9795: LD_INT 91
9797: PUSH
9798: LD_EXP 46
9802: PUSH
9803: LD_INT 8
9805: PUSH
9806: EMPTY
9807: LIST
9808: LIST
9809: LIST
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PPUSH
9815: CALL_OW 69
9819: IFFALSE 9778
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9821: LD_ADDR_VAR 0 1
9825: PUSH
9826: LD_INT 22
9828: PUSH
9829: LD_INT 4
9831: PUSH
9832: EMPTY
9833: LIST
9834: LIST
9835: PPUSH
9836: CALL_OW 69
9840: PUSH
9841: FOR_IN
9842: IFFALSE 9858
// SetSide ( i , 7 ) ;
9844: LD_VAR 0 1
9848: PPUSH
9849: LD_INT 7
9851: PPUSH
9852: CALL_OW 235
9856: GO 9841
9858: POP
9859: POP
// ChangeMissionObjectives ( M3 ) ;
9860: LD_STRING M3
9862: PPUSH
9863: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9867: LD_INT 35
9869: PPUSH
9870: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9874: LD_EXP 15
9878: PPUSH
9879: LD_EXP 46
9883: PPUSH
9884: CALL_OW 296
9888: PUSH
9889: LD_INT 8
9891: LESS
9892: IFFALSE 9867
// ComTurnUnit ( JMM , Burlak ) ;
9894: LD_EXP 15
9898: PPUSH
9899: LD_EXP 46
9903: PPUSH
9904: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9908: LD_EXP 46
9912: PPUSH
9913: LD_EXP 15
9917: PPUSH
9918: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9922: LD_INT 10
9924: PPUSH
9925: CALL_OW 67
// DialogueOn ;
9929: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9933: LD_EXP 15
9937: PPUSH
9938: LD_STRING D11-JMM-1
9940: PPUSH
9941: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9945: LD_EXP 46
9949: PPUSH
9950: LD_STRING D11-Bur-1
9952: PPUSH
9953: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9957: LD_EXP 15
9961: PPUSH
9962: LD_STRING D11-JMM-2
9964: PPUSH
9965: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9969: LD_EXP 46
9973: PPUSH
9974: LD_STRING D11-Bur-2
9976: PPUSH
9977: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9981: LD_EXP 15
9985: PPUSH
9986: LD_STRING D11-JMM-3
9988: PPUSH
9989: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9993: LD_EXP 46
9997: PPUSH
9998: LD_STRING D11-Bur-3
10000: PPUSH
10001: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10005: LD_EXP 15
10009: PPUSH
10010: LD_STRING D11-JMM-4
10012: PPUSH
10013: CALL_OW 88
// if ar_base_spotted then
10017: LD_EXP 8
10021: IFFALSE 10037
// Say ( Burlak , D12-Bur-1 ) else
10023: LD_EXP 46
10027: PPUSH
10028: LD_STRING D12-Bur-1
10030: PPUSH
10031: CALL_OW 88
10035: GO 10076
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10037: LD_INT 7
10039: PPUSH
10040: LD_INT 3
10042: PPUSH
10043: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10047: LD_INT 127
10049: PPUSH
10050: LD_INT 45
10052: PPUSH
10053: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10057: LD_EXP 46
10061: PPUSH
10062: LD_STRING D12-Bur-1a
10064: PPUSH
10065: CALL_OW 88
// dwait ( 0 0$2 ) ;
10069: LD_INT 70
10071: PPUSH
10072: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10076: LD_EXP 46
10080: PPUSH
10081: LD_STRING D12-Bur-1b
10083: PPUSH
10084: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10088: LD_EXP 15
10092: PPUSH
10093: LD_STRING D12-JMM-1
10095: PPUSH
10096: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10100: LD_EXP 46
10104: PPUSH
10105: LD_STRING D12-Bur-2
10107: PPUSH
10108: CALL_OW 88
// if Roth then
10112: LD_EXP 16
10116: IFFALSE 10132
// Say ( Roth , D12-Roth-2 ) else
10118: LD_EXP 16
10122: PPUSH
10123: LD_STRING D12-Roth-2
10125: PPUSH
10126: CALL_OW 88
10130: GO 10144
// Say ( SciRu , D12-RSci1-2 ) ;
10132: CALL 12788 0 0
10136: PPUSH
10137: LD_STRING D12-RSci1-2
10139: PPUSH
10140: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10144: LD_EXP 15
10148: PPUSH
10149: LD_STRING D12-JMM-2
10151: PPUSH
10152: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10156: LD_EXP 46
10160: PPUSH
10161: LD_STRING D12-Bur-3
10163: PPUSH
10164: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10168: LD_EXP 15
10172: PPUSH
10173: LD_STRING D12-JMM-3
10175: PPUSH
10176: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10180: LD_EXP 46
10184: PPUSH
10185: LD_STRING D12-Bur-4
10187: PPUSH
10188: CALL_OW 88
// case Query ( QBase ) of 1 :
10192: LD_STRING QBase
10194: PPUSH
10195: CALL_OW 97
10199: PUSH
10200: LD_INT 1
10202: DOUBLE
10203: EQUAL
10204: IFTRUE 10208
10206: GO 10326
10208: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10209: LD_EXP 15
10213: PPUSH
10214: LD_STRING D13a-JMM-1
10216: PPUSH
10217: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10221: LD_EXP 46
10225: PPUSH
10226: LD_STRING D13a-Bur-1
10228: PPUSH
10229: CALL_OW 88
// if Roth then
10233: LD_EXP 16
10237: IFFALSE 10253
// Say ( Roth , D13a-Roth-1 ) else
10239: LD_EXP 16
10243: PPUSH
10244: LD_STRING D13a-Roth-1
10246: PPUSH
10247: CALL_OW 88
10251: GO 10265
// Say ( SciRu , D13a-RSci1-1 ) ;
10253: CALL 12788 0 0
10257: PPUSH
10258: LD_STRING D13a-RSci1-1
10260: PPUSH
10261: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10265: LD_EXP 15
10269: PPUSH
10270: LD_STRING D13a-JMM-2
10272: PPUSH
10273: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10277: LD_STRING QBaseAgain
10279: PPUSH
10280: CALL_OW 97
10284: PUSH
10285: LD_INT 1
10287: DOUBLE
10288: EQUAL
10289: IFTRUE 10293
10291: GO 10304
10293: POP
// selected_option := 2 ; 2 :
10294: LD_ADDR_VAR 0 2
10298: PUSH
10299: LD_INT 2
10301: ST_TO_ADDR
10302: GO 10324
10304: LD_INT 2
10306: DOUBLE
10307: EQUAL
10308: IFTRUE 10312
10310: GO 10323
10312: POP
// selected_option := 3 ; end ;
10313: LD_ADDR_VAR 0 2
10317: PUSH
10318: LD_INT 3
10320: ST_TO_ADDR
10321: GO 10324
10323: POP
// end ; 2 :
10324: GO 10365
10326: LD_INT 2
10328: DOUBLE
10329: EQUAL
10330: IFTRUE 10334
10332: GO 10345
10334: POP
// selected_option := 2 ; 3 :
10335: LD_ADDR_VAR 0 2
10339: PUSH
10340: LD_INT 2
10342: ST_TO_ADDR
10343: GO 10365
10345: LD_INT 3
10347: DOUBLE
10348: EQUAL
10349: IFTRUE 10353
10351: GO 10364
10353: POP
// selected_option := 3 ; end ;
10354: LD_ADDR_VAR 0 2
10358: PUSH
10359: LD_INT 3
10361: ST_TO_ADDR
10362: GO 10365
10364: POP
// if selected_option = 2 then
10365: LD_VAR 0 2
10369: PUSH
10370: LD_INT 2
10372: EQUAL
10373: IFFALSE 10467
// begin Say ( JMM , D13b-JMM-1 ) ;
10375: LD_EXP 15
10379: PPUSH
10380: LD_STRING D13b-JMM-1
10382: PPUSH
10383: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10387: LD_EXP 46
10391: PPUSH
10392: LD_STRING D13b-Bur-1
10394: PPUSH
10395: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10399: LD_EXP 15
10403: PPUSH
10404: LD_STRING D13b-JMM-2
10406: PPUSH
10407: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10411: LD_EXP 55
10415: PPUSH
10416: LD_STRING D13b-Abd-2
10418: PPUSH
10419: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10423: LD_EXP 15
10427: PPUSH
10428: LD_STRING D13b-JMM-3
10430: PPUSH
10431: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10435: LD_EXP 55
10439: PPUSH
10440: LD_STRING D13b-Abd-3
10442: PPUSH
10443: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10447: LD_EXP 15
10451: PPUSH
10452: LD_STRING D13b-JMM-4
10454: PPUSH
10455: CALL_OW 88
// ar_active_attack := true ;
10459: LD_ADDR_EXP 9
10463: PUSH
10464: LD_INT 1
10466: ST_TO_ADDR
// end ; if selected_option = 3 then
10467: LD_VAR 0 2
10471: PUSH
10472: LD_INT 3
10474: EQUAL
10475: IFFALSE 10501
// begin Say ( JMM , D13c-JMM-1 ) ;
10477: LD_EXP 15
10481: PPUSH
10482: LD_STRING D13c-JMM-1
10484: PPUSH
10485: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10489: LD_EXP 46
10493: PPUSH
10494: LD_STRING D13c-Bur-1
10496: PPUSH
10497: CALL_OW 88
// end ; DialogueOff ;
10501: CALL_OW 7
// if not ar_active_attack then
10505: LD_EXP 9
10509: NOT
10510: IFFALSE 10527
// begin wait ( 6 6$00 ) ;
10512: LD_INT 12600
10514: PPUSH
10515: CALL_OW 67
// ar_active_attack := true ;
10519: LD_ADDR_EXP 9
10523: PUSH
10524: LD_INT 1
10526: ST_TO_ADDR
// end ; end ;
10527: PPOPN 2
10529: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10530: LD_EXP 46
10534: PPUSH
10535: CALL_OW 305
10539: PUSH
10540: LD_EXP 46
10544: PPUSH
10545: CALL_OW 255
10549: PUSH
10550: LD_INT 7
10552: EQUAL
10553: AND
10554: IFFALSE 10750
10556: GO 10558
10558: DISABLE
10559: LD_INT 0
10561: PPUSH
// begin wait ( 4 4$40 ) ;
10562: LD_INT 9800
10564: PPUSH
10565: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10569: LD_INT 35
10571: PPUSH
10572: CALL_OW 67
// until not ru_attackers ;
10576: LD_EXP 52
10580: NOT
10581: IFFALSE 10569
// PrepareGnyevko ;
10583: CALL 2173 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10587: LD_EXP 48
10591: PPUSH
10592: LD_INT 124
10594: PPUSH
10595: LD_INT 118
10597: PPUSH
10598: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10602: LD_EXP 48
10606: PPUSH
10607: CALL_OW 200
// time := 0 0$00 ;
10611: LD_ADDR_VAR 0 1
10615: PUSH
10616: LD_INT 0
10618: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10619: LD_INT 35
10621: PPUSH
10622: CALL_OW 67
// time := time + 0 0$1 ;
10626: LD_ADDR_VAR 0 1
10630: PUSH
10631: LD_VAR 0 1
10635: PUSH
10636: LD_INT 35
10638: PLUS
10639: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10640: LD_EXP 48
10644: PPUSH
10645: LD_INT 124
10647: PPUSH
10648: LD_INT 118
10650: PPUSH
10651: CALL_OW 307
10655: PUSH
10656: LD_VAR 0 1
10660: PUSH
10661: LD_INT 1050
10663: GREATEREQUAL
10664: OR
10665: IFFALSE 10619
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10667: LD_EXP 48
10671: PPUSH
10672: LD_STRING DBelkov-Gny-1
10674: PPUSH
10675: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10679: LD_EXP 46
10683: PPUSH
10684: LD_STRING DBelkov-Bur-1a
10686: PPUSH
10687: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10691: LD_INT 35
10693: PPUSH
10694: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10698: LD_EXP 48
10702: PPUSH
10703: LD_INT 22
10705: PUSH
10706: LD_INT 7
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PPUSH
10713: CALL_OW 69
10717: PPUSH
10718: LD_EXP 48
10722: PPUSH
10723: CALL_OW 74
10727: PPUSH
10728: CALL_OW 296
10732: PUSH
10733: LD_INT 8
10735: LESS
10736: IFFALSE 10691
// SetSide ( Gnyevko , 7 ) ;
10738: LD_EXP 48
10742: PPUSH
10743: LD_INT 7
10745: PPUSH
10746: CALL_OW 235
// end ;
10750: PPOPN 1
10752: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10753: LD_EXP 46
10757: PPUSH
10758: CALL_OW 255
10762: PUSH
10763: LD_INT 7
10765: EQUAL
10766: IFFALSE 10776
10768: GO 10770
10770: DISABLE
// begin enable ;
10771: ENABLE
// PrepareAmericanAttack ;
10772: CALL 6592 0 0
// end ;
10776: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10777: LD_INT 22
10779: PUSH
10780: LD_INT 1
10782: PUSH
10783: EMPTY
10784: LIST
10785: LIST
10786: PPUSH
10787: CALL_OW 69
10791: IFFALSE 10975
10793: GO 10795
10795: DISABLE
10796: LD_INT 0
10798: PPUSH
10799: PPUSH
// begin while true do
10800: LD_INT 1
10802: IFFALSE 10859
// begin wait ( 0 0$1 ) ;
10804: LD_INT 35
10806: PPUSH
10807: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10811: LD_ADDR_VAR 0 2
10815: PUSH
10816: LD_INT 22
10818: PUSH
10819: LD_INT 1
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PPUSH
10826: CALL_OW 69
10830: PPUSH
10831: LD_EXP 15
10835: PPUSH
10836: CALL_OW 74
10840: ST_TO_ADDR
// if See ( 7 , tmp ) then
10841: LD_INT 7
10843: PPUSH
10844: LD_VAR 0 2
10848: PPUSH
10849: CALL_OW 292
10853: IFFALSE 10857
// break ;
10855: GO 10859
// end ;
10857: GO 10800
// DialogueOn ;
10859: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10863: LD_VAR 0 2
10867: PPUSH
10868: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10872: LD_VAR 0 2
10876: PPUSH
10877: CALL_OW 250
10881: PPUSH
10882: LD_VAR 0 2
10886: PPUSH
10887: CALL_OW 251
10891: PPUSH
10892: LD_INT 7
10894: PPUSH
10895: LD_INT 8
10897: PPUSH
10898: CALL_OW 330
// if Denis then
10902: LD_EXP 21
10906: IFFALSE 10920
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10908: LD_EXP 21
10912: PPUSH
10913: LD_STRING DAmerAttack-Pet-1
10915: PPUSH
10916: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10920: LD_EXP 15
10924: PPUSH
10925: LD_STRING DAmerAttack-JMM-1
10927: PPUSH
10928: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10932: LD_EXP 46
10936: PPUSH
10937: LD_STRING DStop-Bur-1
10939: PPUSH
10940: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10944: LD_VAR 0 2
10948: PPUSH
10949: CALL_OW 250
10953: PPUSH
10954: LD_VAR 0 2
10958: PPUSH
10959: CALL_OW 251
10963: PPUSH
10964: LD_INT 7
10966: PPUSH
10967: CALL_OW 331
// DialogueOff ;
10971: CALL_OW 7
// end ;
10975: PPOPN 2
10977: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10978: LD_INT 22
10980: PUSH
10981: LD_INT 3
10983: PUSH
10984: EMPTY
10985: LIST
10986: LIST
10987: PUSH
10988: LD_INT 21
10990: PUSH
10991: LD_INT 1
10993: PUSH
10994: EMPTY
10995: LIST
10996: LIST
10997: PUSH
10998: EMPTY
10999: LIST
11000: LIST
11001: PPUSH
11002: CALL_OW 69
11006: PUSH
11007: LD_INT 0
11009: EQUAL
11010: IFFALSE 11052
11012: GO 11014
11014: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11015: LD_STRING M5a
11017: PPUSH
11018: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11022: LD_EXP 15
11026: PPUSH
11027: LD_STRING D8-JMM-1
11029: PPUSH
11030: CALL_OW 88
// if Gossudarov then
11034: LD_EXP 32
11038: IFFALSE 11052
// Say ( Gossudarov , D8-Gos-1 ) ;
11040: LD_EXP 32
11044: PPUSH
11045: LD_STRING D8-Gos-1
11047: PPUSH
11048: CALL_OW 88
// end ;
11052: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11053: LD_INT 22
11055: PUSH
11056: LD_INT 2
11058: PUSH
11059: EMPTY
11060: LIST
11061: LIST
11062: PUSH
11063: LD_INT 21
11065: PUSH
11066: LD_INT 1
11068: PUSH
11069: EMPTY
11070: LIST
11071: LIST
11072: PUSH
11073: EMPTY
11074: LIST
11075: LIST
11076: PPUSH
11077: CALL_OW 69
11081: PUSH
11082: LD_INT 0
11084: EQUAL
11085: IFFALSE 11135
11087: GO 11089
11089: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11090: LD_STRING M4c
11092: PPUSH
11093: CALL_OW 337
// if Roth then
11097: LD_EXP 16
11101: IFFALSE 11117
// Say ( Roth , DStop-Roth-1 ) else
11103: LD_EXP 16
11107: PPUSH
11108: LD_STRING DStop-Roth-1
11110: PPUSH
11111: CALL_OW 88
11115: GO 11135
// if Gossudarov then
11117: LD_EXP 32
11121: IFFALSE 11135
// Say ( Gossudarov , D8-Gos-1a ) ;
11123: LD_EXP 32
11127: PPUSH
11128: LD_STRING D8-Gos-1a
11130: PPUSH
11131: CALL_OW 88
// end ;
11135: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11136: LD_INT 7
11138: PPUSH
11139: LD_INT 1
11141: PPUSH
11142: LD_INT 1
11144: PPUSH
11145: CALL 14424 0 3
11149: PUSH
11150: LD_INT 0
11152: EQUAL
11153: PUSH
11154: LD_INT 7
11156: PPUSH
11157: LD_INT 3
11159: PPUSH
11160: LD_INT 1
11162: PPUSH
11163: CALL 14424 0 3
11167: PUSH
11168: LD_INT 0
11170: EQUAL
11171: AND
11172: IFFALSE 11184
11174: GO 11176
11176: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11177: LD_STRING M1a
11179: PPUSH
11180: CALL_OW 337
// end ;
11184: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11185: LD_INT 22
11187: PUSH
11188: LD_INT 2
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PUSH
11195: LD_INT 21
11197: PUSH
11198: LD_INT 1
11200: PUSH
11201: EMPTY
11202: LIST
11203: LIST
11204: PUSH
11205: EMPTY
11206: LIST
11207: LIST
11208: PPUSH
11209: CALL_OW 69
11213: PUSH
11214: LD_INT 0
11216: EQUAL
11217: PUSH
11218: LD_INT 22
11220: PUSH
11221: LD_INT 3
11223: PUSH
11224: EMPTY
11225: LIST
11226: LIST
11227: PUSH
11228: LD_INT 21
11230: PUSH
11231: LD_INT 1
11233: PUSH
11234: EMPTY
11235: LIST
11236: LIST
11237: PUSH
11238: EMPTY
11239: LIST
11240: LIST
11241: PPUSH
11242: CALL_OW 69
11246: PUSH
11247: LD_INT 0
11249: EQUAL
11250: AND
11251: PUSH
11252: LD_INT 22
11254: PUSH
11255: LD_INT 1
11257: PUSH
11258: EMPTY
11259: LIST
11260: LIST
11261: PPUSH
11262: CALL_OW 69
11266: PUSH
11267: LD_INT 0
11269: EQUAL
11270: AND
11271: PUSH
11272: LD_INT 7
11274: PPUSH
11275: LD_INT 1
11277: PPUSH
11278: LD_INT 1
11280: PPUSH
11281: CALL 14424 0 3
11285: PUSH
11286: LD_INT 0
11288: EQUAL
11289: AND
11290: PUSH
11291: LD_INT 7
11293: PPUSH
11294: LD_INT 3
11296: PPUSH
11297: LD_INT 1
11299: PPUSH
11300: CALL 14424 0 3
11304: PUSH
11305: LD_INT 0
11307: EQUAL
11308: AND
11309: IFFALSE 12785
11311: GO 11313
11313: DISABLE
11314: LD_INT 0
11316: PPUSH
11317: PPUSH
11318: PPUSH
11319: PPUSH
11320: PPUSH
11321: PPUSH
// begin m1 := false ;
11322: LD_ADDR_VAR 0 4
11326: PUSH
11327: LD_INT 0
11329: ST_TO_ADDR
// m2 := false ;
11330: LD_ADDR_VAR 0 5
11334: PUSH
11335: LD_INT 0
11337: ST_TO_ADDR
// m3 := false ;
11338: LD_ADDR_VAR 0 6
11342: PUSH
11343: LD_INT 0
11345: ST_TO_ADDR
// if tick < 40 40$00 then
11346: LD_OWVAR 1
11350: PUSH
11351: LD_INT 84000
11353: LESS
11354: IFFALSE 11363
// SetAchievement ( ACH_ASPEED_17 ) ;
11356: LD_STRING ACH_ASPEED_17
11358: PPUSH
11359: CALL_OW 543
// wait ( 0 0$1 ) ;
11363: LD_INT 35
11365: PPUSH
11366: CALL_OW 67
// if not IsDead ( Masha ) then
11370: LD_EXP 49
11374: PPUSH
11375: CALL_OW 301
11379: NOT
11380: IFFALSE 11402
// begin m1 := true ;
11382: LD_ADDR_VAR 0 4
11386: PUSH
11387: LD_INT 1
11389: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11390: LD_STRING Masha
11392: PPUSH
11393: LD_INT 1
11395: PPUSH
11396: CALL_OW 101
// end else
11400: GO 11413
// AddMedal ( Masha , - 1 ) ;
11402: LD_STRING Masha
11404: PPUSH
11405: LD_INT 1
11407: NEG
11408: PPUSH
11409: CALL_OW 101
// if abdul_escaped then
11413: LD_EXP 12
11417: IFFALSE 11432
// AddMedal ( Abdul , - 1 ) else
11419: LD_STRING Abdul
11421: PPUSH
11422: LD_INT 1
11424: NEG
11425: PPUSH
11426: CALL_OW 101
11430: GO 11450
// begin m2 := true ;
11432: LD_ADDR_VAR 0 5
11436: PUSH
11437: LD_INT 1
11439: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11440: LD_STRING Abdul
11442: PPUSH
11443: LD_INT 1
11445: PPUSH
11446: CALL_OW 101
// end ; if loss_counter = 0 then
11450: LD_EXP 13
11454: PUSH
11455: LD_INT 0
11457: EQUAL
11458: IFFALSE 11480
// begin m3 := true ;
11460: LD_ADDR_VAR 0 6
11464: PUSH
11465: LD_INT 1
11467: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11468: LD_STRING People
11470: PPUSH
11471: LD_INT 2
11473: PPUSH
11474: CALL_OW 101
// end else
11478: GO 11538
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11480: LD_EXP 13
11484: PUSH
11485: LD_INT 3
11487: PUSH
11488: LD_INT 2
11490: PUSH
11491: LD_INT 2
11493: PUSH
11494: EMPTY
11495: LIST
11496: LIST
11497: LIST
11498: PUSH
11499: LD_OWVAR 67
11503: ARRAY
11504: LESSEQUAL
11505: IFFALSE 11527
// begin AddMedal ( People , 1 ) ;
11507: LD_STRING People
11509: PPUSH
11510: LD_INT 1
11512: PPUSH
11513: CALL_OW 101
// m3 := true ;
11517: LD_ADDR_VAR 0 6
11521: PUSH
11522: LD_INT 1
11524: ST_TO_ADDR
// end else
11525: GO 11538
// AddMedal ( People , - 1 ) ;
11527: LD_STRING People
11529: PPUSH
11530: LD_INT 1
11532: NEG
11533: PPUSH
11534: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11538: LD_OWVAR 67
11542: PUSH
11543: LD_INT 3
11545: EQUAL
11546: PUSH
11547: LD_VAR 0 4
11551: AND
11552: PUSH
11553: LD_VAR 0 5
11557: AND
11558: PUSH
11559: LD_VAR 0 6
11563: AND
11564: IFFALSE 11576
// SetAchievementEX ( ACH_AMER , 17 ) ;
11566: LD_STRING ACH_AMER
11568: PPUSH
11569: LD_INT 17
11571: PPUSH
11572: CALL_OW 564
// GiveMedals ( MAIN ) ;
11576: LD_STRING MAIN
11578: PPUSH
11579: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11583: LD_ADDR_VAR 0 2
11587: PUSH
11588: LD_INT 22
11590: PUSH
11591: LD_INT 7
11593: PUSH
11594: EMPTY
11595: LIST
11596: LIST
11597: PUSH
11598: LD_INT 2
11600: PUSH
11601: LD_INT 25
11603: PUSH
11604: LD_INT 1
11606: PUSH
11607: EMPTY
11608: LIST
11609: LIST
11610: PUSH
11611: LD_INT 25
11613: PUSH
11614: LD_INT 2
11616: PUSH
11617: EMPTY
11618: LIST
11619: LIST
11620: PUSH
11621: LD_INT 25
11623: PUSH
11624: LD_INT 3
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: PUSH
11631: LD_INT 25
11633: PUSH
11634: LD_INT 4
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PUSH
11641: LD_INT 25
11643: PUSH
11644: LD_INT 5
11646: PUSH
11647: EMPTY
11648: LIST
11649: LIST
11650: PUSH
11651: LD_INT 25
11653: PUSH
11654: LD_INT 8
11656: PUSH
11657: EMPTY
11658: LIST
11659: LIST
11660: PUSH
11661: LD_INT 25
11663: PUSH
11664: LD_INT 9
11666: PUSH
11667: EMPTY
11668: LIST
11669: LIST
11670: PUSH
11671: EMPTY
11672: LIST
11673: LIST
11674: LIST
11675: LIST
11676: LIST
11677: LIST
11678: LIST
11679: LIST
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: PPUSH
11685: CALL_OW 69
11689: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11690: LD_VAR 0 2
11694: PPUSH
11695: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11699: LD_ADDR_VAR 0 3
11703: PUSH
11704: LD_EXP 15
11708: PUSH
11709: LD_EXP 16
11713: PUSH
11714: LD_EXP 17
11718: PUSH
11719: LD_EXP 18
11723: PUSH
11724: LD_EXP 19
11728: PUSH
11729: LD_EXP 20
11733: PUSH
11734: LD_EXP 21
11738: PUSH
11739: LD_EXP 22
11743: PUSH
11744: LD_EXP 23
11748: PUSH
11749: LD_EXP 24
11753: PUSH
11754: LD_EXP 25
11758: PUSH
11759: LD_EXP 26
11763: PUSH
11764: LD_EXP 27
11768: PUSH
11769: LD_EXP 28
11773: PUSH
11774: LD_EXP 29
11778: PUSH
11779: LD_EXP 30
11783: PUSH
11784: LD_EXP 31
11788: PUSH
11789: LD_EXP 32
11793: PUSH
11794: LD_EXP 33
11798: PUSH
11799: LD_EXP 34
11803: PUSH
11804: LD_EXP 36
11808: PUSH
11809: LD_EXP 37
11813: PUSH
11814: LD_EXP 38
11818: PUSH
11819: LD_EXP 39
11823: PUSH
11824: LD_EXP 40
11828: PUSH
11829: LD_EXP 41
11833: PUSH
11834: LD_EXP 42
11838: PUSH
11839: LD_EXP 43
11843: PUSH
11844: LD_EXP 44
11848: PUSH
11849: LD_EXP 45
11853: PUSH
11854: LD_EXP 46
11858: PUSH
11859: LD_EXP 47
11863: PUSH
11864: LD_EXP 48
11868: PUSH
11869: EMPTY
11870: LIST
11871: LIST
11872: LIST
11873: LIST
11874: LIST
11875: LIST
11876: LIST
11877: LIST
11878: LIST
11879: LIST
11880: LIST
11881: LIST
11882: LIST
11883: LIST
11884: LIST
11885: LIST
11886: LIST
11887: LIST
11888: LIST
11889: LIST
11890: LIST
11891: LIST
11892: LIST
11893: LIST
11894: LIST
11895: LIST
11896: LIST
11897: LIST
11898: LIST
11899: LIST
11900: LIST
11901: LIST
11902: LIST
11903: ST_TO_ADDR
// if tmp diff tmp2 then
11904: LD_VAR 0 2
11908: PUSH
11909: LD_VAR 0 3
11913: DIFF
11914: IFFALSE 11934
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11916: LD_VAR 0 2
11920: PUSH
11921: LD_VAR 0 3
11925: DIFF
11926: PPUSH
11927: LD_STRING 13a_others
11929: PPUSH
11930: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11934: LD_EXP 15
11938: PPUSH
11939: LD_STRING 13a_JMM
11941: PPUSH
11942: CALL_OW 38
// if Titov then
11946: LD_EXP 34
11950: IFFALSE 11964
// SaveCharacters ( Titov , 13a_Titov ) ;
11952: LD_EXP 34
11956: PPUSH
11957: LD_STRING 13a_Titov
11959: PPUSH
11960: CALL_OW 38
// if Dolgov then
11964: LD_EXP 36
11968: IFFALSE 11982
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11970: LD_EXP 36
11974: PPUSH
11975: LD_STRING 13a_Dolgov
11977: PPUSH
11978: CALL_OW 38
// if Petrosyan then
11982: LD_EXP 37
11986: IFFALSE 12000
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11988: LD_EXP 37
11992: PPUSH
11993: LD_STRING 13a_Petrosyan
11995: PPUSH
11996: CALL_OW 38
// if Scholtze then
12000: LD_EXP 38
12004: IFFALSE 12018
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12006: LD_EXP 38
12010: PPUSH
12011: LD_STRING 13a_Scholtze
12013: PPUSH
12014: CALL_OW 38
// if Oblukov then
12018: LD_EXP 39
12022: IFFALSE 12036
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12024: LD_EXP 39
12028: PPUSH
12029: LD_STRING 13a_Oblukov
12031: PPUSH
12032: CALL_OW 38
// if Kapitsova then
12036: LD_EXP 40
12040: IFFALSE 12054
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
12042: LD_EXP 40
12046: PPUSH
12047: LD_STRING 13a_Kapitsova
12049: PPUSH
12050: CALL_OW 38
// if Lipshchin then
12054: LD_EXP 41
12058: IFFALSE 12072
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12060: LD_EXP 41
12064: PPUSH
12065: LD_STRING 13a_Lipshchin
12067: PPUSH
12068: CALL_OW 38
// if Petrovova then
12072: LD_EXP 42
12076: IFFALSE 12090
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12078: LD_EXP 42
12082: PPUSH
12083: LD_STRING 13a_Petrovova
12085: PPUSH
12086: CALL_OW 38
// if Kovalyuk then
12090: LD_EXP 43
12094: IFFALSE 12108
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12096: LD_EXP 43
12100: PPUSH
12101: LD_STRING 13a_Kovalyuk
12103: PPUSH
12104: CALL_OW 38
// if Kuzmov then
12108: LD_EXP 44
12112: IFFALSE 12126
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12114: LD_EXP 44
12118: PPUSH
12119: LD_STRING 13a_Kuzmov
12121: PPUSH
12122: CALL_OW 38
// if Karamazov then
12126: LD_EXP 45
12130: IFFALSE 12144
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12132: LD_EXP 45
12136: PPUSH
12137: LD_STRING 13a_Karamazov
12139: PPUSH
12140: CALL_OW 38
// if Burlak then
12144: LD_EXP 46
12148: IFFALSE 12162
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12150: LD_EXP 46
12154: PPUSH
12155: LD_STRING 13a_Burlak
12157: PPUSH
12158: CALL_OW 38
// if Belkov then
12162: LD_EXP 47
12166: IFFALSE 12180
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12168: LD_EXP 47
12172: PPUSH
12173: LD_STRING 13a_Belkov
12175: PPUSH
12176: CALL_OW 38
// if Gnyevko then
12180: LD_EXP 48
12184: IFFALSE 12198
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12186: LD_EXP 48
12190: PPUSH
12191: LD_STRING 13a_Gnyevko
12193: PPUSH
12194: CALL_OW 38
// if Lisa then
12198: LD_EXP 17
12202: IFFALSE 12216
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12204: LD_EXP 17
12208: PPUSH
12209: LD_STRING 13a_Lisa
12211: PPUSH
12212: CALL_OW 38
// if Donaldson then
12216: LD_EXP 18
12220: IFFALSE 12234
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12222: LD_EXP 18
12226: PPUSH
12227: LD_STRING 13a_Donaldson
12229: PPUSH
12230: CALL_OW 38
// if Bobby then
12234: LD_EXP 19
12238: IFFALSE 12252
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12240: LD_EXP 19
12244: PPUSH
12245: LD_STRING 13a_Bobby
12247: PPUSH
12248: CALL_OW 38
// if Cyrus then
12252: LD_EXP 20
12256: IFFALSE 12270
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12258: LD_EXP 20
12262: PPUSH
12263: LD_STRING 13a_Cyrus
12265: PPUSH
12266: CALL_OW 38
// if Denis then
12270: LD_EXP 21
12274: IFFALSE 12288
// SaveCharacters ( Denis , 13a_Denis ) ;
12276: LD_EXP 21
12280: PPUSH
12281: LD_STRING 13a_Denis
12283: PPUSH
12284: CALL_OW 38
// if Brown then
12288: LD_EXP 22
12292: IFFALSE 12306
// SaveCharacters ( Brown , 13a_Brown ) ;
12294: LD_EXP 22
12298: PPUSH
12299: LD_STRING 13a_Brown
12301: PPUSH
12302: CALL_OW 38
// if Gladstone then
12306: LD_EXP 23
12310: IFFALSE 12324
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12312: LD_EXP 23
12316: PPUSH
12317: LD_STRING 13a_Gladstone
12319: PPUSH
12320: CALL_OW 38
// if Houten then
12324: LD_EXP 24
12328: IFFALSE 12342
// SaveCharacters ( Houten , 13a_Houten ) ;
12330: LD_EXP 24
12334: PPUSH
12335: LD_STRING 13a_Houten
12337: PPUSH
12338: CALL_OW 38
// if Cornel then
12342: LD_EXP 25
12346: IFFALSE 12360
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12348: LD_EXP 25
12352: PPUSH
12353: LD_STRING 13a_Cornel
12355: PPUSH
12356: CALL_OW 38
// if Gary then
12360: LD_EXP 26
12364: IFFALSE 12378
// SaveCharacters ( Gary , 13a_Gary ) ;
12366: LD_EXP 26
12370: PPUSH
12371: LD_STRING 13a_Gary
12373: PPUSH
12374: CALL_OW 38
// if Frank then
12378: LD_EXP 27
12382: IFFALSE 12396
// SaveCharacters ( Frank , 13a_Frank ) ;
12384: LD_EXP 27
12388: PPUSH
12389: LD_STRING 13a_Frank
12391: PPUSH
12392: CALL_OW 38
// if Kikuchi then
12396: LD_EXP 28
12400: IFFALSE 12414
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12402: LD_EXP 28
12406: PPUSH
12407: LD_STRING 13a_Kikuchi
12409: PPUSH
12410: CALL_OW 38
// if Simms then
12414: LD_EXP 29
12418: IFFALSE 12432
// SaveCharacters ( Simms , 13a_Simms ) ;
12420: LD_EXP 29
12424: PPUSH
12425: LD_STRING 13a_Simms
12427: PPUSH
12428: CALL_OW 38
// if Joan then
12432: LD_EXP 30
12436: IFFALSE 12450
// SaveCharacters ( Joan , 13a_Joan ) ;
12438: LD_EXP 30
12442: PPUSH
12443: LD_STRING 13a_Joan
12445: PPUSH
12446: CALL_OW 38
// if DeltaDoctor then
12450: LD_EXP 31
12454: IFFALSE 12468
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12456: LD_EXP 31
12460: PPUSH
12461: LD_STRING 13a_DeltaDoctor
12463: PPUSH
12464: CALL_OW 38
// if Gossudarov then
12468: LD_EXP 32
12472: IFFALSE 12486
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12474: LD_EXP 32
12478: PPUSH
12479: LD_STRING 13a_Gossudarov
12481: PPUSH
12482: CALL_OW 38
// if Kirilenkova then
12486: LD_EXP 33
12490: IFFALSE 12504
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12492: LD_EXP 33
12496: PPUSH
12497: LD_STRING 13a_Kirilenkova
12499: PPUSH
12500: CALL_OW 38
// if Roth then
12504: LD_EXP 16
12508: IFFALSE 12522
// SaveCharacters ( Roth , 13a_Roth ) ;
12510: LD_EXP 16
12514: PPUSH
12515: LD_STRING 13a_Roth
12517: PPUSH
12518: CALL_OW 38
// if Masha then
12522: LD_EXP 49
12526: IFFALSE 12581
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12528: LD_EXP 49
12532: PPUSH
12533: CALL_OW 265
12537: PUSH
12538: LD_EXP 49
12542: PPUSH
12543: CALL_OW 262
12547: PUSH
12548: LD_EXP 49
12552: PPUSH
12553: CALL_OW 263
12557: PUSH
12558: LD_EXP 49
12562: PPUSH
12563: CALL_OW 264
12567: PUSH
12568: EMPTY
12569: LIST
12570: LIST
12571: LIST
12572: LIST
12573: PPUSH
12574: LD_STRING 13a_Masha
12576: PPUSH
12577: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12581: LD_ADDR_VAR 0 2
12585: PUSH
12586: LD_INT 21
12588: PUSH
12589: LD_INT 3
12591: PUSH
12592: EMPTY
12593: LIST
12594: LIST
12595: PPUSH
12596: CALL_OW 69
12600: ST_TO_ADDR
// tmp2 := [ ] ;
12601: LD_ADDR_VAR 0 3
12605: PUSH
12606: EMPTY
12607: ST_TO_ADDR
// if tmp then
12608: LD_VAR 0 2
12612: IFFALSE 12763
// for i in tmp do
12614: LD_ADDR_VAR 0 1
12618: PUSH
12619: LD_VAR 0 2
12623: PUSH
12624: FOR_IN
12625: IFFALSE 12761
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12627: LD_ADDR_VAR 0 3
12631: PUSH
12632: LD_VAR 0 3
12636: PUSH
12637: LD_VAR 0 1
12641: PPUSH
12642: CALL_OW 255
12646: PUSH
12647: LD_VAR 0 1
12651: PPUSH
12652: CALL_OW 248
12656: PUSH
12657: LD_VAR 0 1
12661: PPUSH
12662: CALL_OW 266
12666: PUSH
12667: LD_VAR 0 1
12671: PPUSH
12672: CALL_OW 250
12676: PUSH
12677: LD_VAR 0 1
12681: PPUSH
12682: CALL_OW 251
12686: PUSH
12687: LD_VAR 0 1
12691: PPUSH
12692: CALL_OW 254
12696: PUSH
12697: LD_VAR 0 1
12701: PPUSH
12702: CALL_OW 267
12706: PUSH
12707: LD_VAR 0 1
12711: PPUSH
12712: LD_INT 1
12714: PPUSH
12715: CALL_OW 268
12719: PUSH
12720: LD_VAR 0 1
12724: PPUSH
12725: LD_INT 2
12727: PPUSH
12728: CALL_OW 268
12732: PUSH
12733: LD_VAR 0 1
12737: PPUSH
12738: CALL_OW 269
12742: PUSH
12743: EMPTY
12744: LIST
12745: LIST
12746: LIST
12747: LIST
12748: LIST
12749: LIST
12750: LIST
12751: LIST
12752: LIST
12753: LIST
12754: PUSH
12755: EMPTY
12756: LIST
12757: ADD
12758: ST_TO_ADDR
12759: GO 12624
12761: POP
12762: POP
// if tmp2 then
12763: LD_VAR 0 3
12767: IFFALSE 12781
// SaveVariable ( tmp2 , 13a_buildings ) ;
12769: LD_VAR 0 3
12773: PPUSH
12774: LD_STRING 13a_buildings
12776: PPUSH
12777: CALL_OW 39
// YouWin ;
12781: CALL_OW 103
// end ;
12785: PPOPN 6
12787: END
// export function SciRu ; var tmp , t ; begin
12788: LD_INT 0
12790: PPUSH
12791: PPUSH
12792: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12793: LD_ADDR_VAR 0 3
12797: PUSH
12798: LD_EXP 32
12802: PUSH
12803: LD_EXP 46
12807: PUSH
12808: LD_EXP 34
12812: PUSH
12813: LD_EXP 47
12817: PUSH
12818: LD_EXP 48
12822: PUSH
12823: LD_EXP 37
12827: PUSH
12828: LD_EXP 38
12832: PUSH
12833: LD_EXP 36
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: LIST
12842: LIST
12843: LIST
12844: LIST
12845: LIST
12846: LIST
12847: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12848: LD_ADDR_VAR 0 2
12852: PUSH
12853: LD_INT 22
12855: PUSH
12856: LD_INT 7
12858: PUSH
12859: EMPTY
12860: LIST
12861: LIST
12862: PUSH
12863: LD_INT 23
12865: PUSH
12866: LD_INT 3
12868: PUSH
12869: EMPTY
12870: LIST
12871: LIST
12872: PUSH
12873: LD_INT 25
12875: PUSH
12876: LD_INT 4
12878: PUSH
12879: EMPTY
12880: LIST
12881: LIST
12882: PUSH
12883: LD_INT 26
12885: PUSH
12886: LD_INT 1
12888: PUSH
12889: EMPTY
12890: LIST
12891: LIST
12892: PUSH
12893: EMPTY
12894: LIST
12895: LIST
12896: LIST
12897: LIST
12898: PPUSH
12899: CALL_OW 69
12903: PUSH
12904: LD_VAR 0 3
12908: DIFF
12909: ST_TO_ADDR
// if tmp then
12910: LD_VAR 0 2
12914: IFFALSE 12930
// result := tmp [ 1 ] ;
12916: LD_ADDR_VAR 0 1
12920: PUSH
12921: LD_VAR 0 2
12925: PUSH
12926: LD_INT 1
12928: ARRAY
12929: ST_TO_ADDR
// end ;
12930: LD_VAR 0 1
12934: RET
// export function SolRu ; var tmp , t ; begin
12935: LD_INT 0
12937: PPUSH
12938: PPUSH
12939: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12940: LD_ADDR_VAR 0 3
12944: PUSH
12945: LD_EXP 32
12949: PUSH
12950: LD_EXP 46
12954: PUSH
12955: LD_EXP 34
12959: PUSH
12960: LD_EXP 47
12964: PUSH
12965: LD_EXP 48
12969: PUSH
12970: LD_EXP 37
12974: PUSH
12975: LD_EXP 38
12979: PUSH
12980: LD_EXP 36
12984: PUSH
12985: EMPTY
12986: LIST
12987: LIST
12988: LIST
12989: LIST
12990: LIST
12991: LIST
12992: LIST
12993: LIST
12994: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12995: LD_ADDR_VAR 0 2
12999: PUSH
13000: LD_INT 22
13002: PUSH
13003: LD_INT 7
13005: PUSH
13006: EMPTY
13007: LIST
13008: LIST
13009: PUSH
13010: LD_INT 23
13012: PUSH
13013: LD_INT 3
13015: PUSH
13016: EMPTY
13017: LIST
13018: LIST
13019: PUSH
13020: LD_INT 25
13022: PUSH
13023: LD_INT 1
13025: PUSH
13026: EMPTY
13027: LIST
13028: LIST
13029: PUSH
13030: LD_INT 26
13032: PUSH
13033: LD_INT 1
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: EMPTY
13041: LIST
13042: LIST
13043: LIST
13044: LIST
13045: PPUSH
13046: CALL_OW 69
13050: PUSH
13051: LD_VAR 0 3
13055: DIFF
13056: ST_TO_ADDR
// if tmp then
13057: LD_VAR 0 2
13061: IFFALSE 13077
// result := tmp [ 1 ] ;
13063: LD_ADDR_VAR 0 1
13067: PUSH
13068: LD_VAR 0 2
13072: PUSH
13073: LD_INT 1
13075: ARRAY
13076: ST_TO_ADDR
// end ; end_of_file
13077: LD_VAR 0 1
13081: RET
// export function CustomEvent ( event ) ; begin
13082: LD_INT 0
13084: PPUSH
// end ;
13085: LD_VAR 0 2
13089: RET
// on UnitDestroyed ( un ) do var i , side ;
13090: LD_INT 0
13092: PPUSH
13093: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13094: LD_VAR 0 1
13098: PUSH
13099: LD_INT 22
13101: PUSH
13102: LD_INT 7
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: PUSH
13109: LD_INT 2
13111: PUSH
13112: LD_INT 25
13114: PUSH
13115: LD_INT 1
13117: PUSH
13118: EMPTY
13119: LIST
13120: LIST
13121: PUSH
13122: LD_INT 25
13124: PUSH
13125: LD_INT 2
13127: PUSH
13128: EMPTY
13129: LIST
13130: LIST
13131: PUSH
13132: LD_INT 25
13134: PUSH
13135: LD_INT 3
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: PUSH
13142: LD_INT 25
13144: PUSH
13145: LD_INT 4
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: PUSH
13152: LD_INT 25
13154: PUSH
13155: LD_INT 5
13157: PUSH
13158: EMPTY
13159: LIST
13160: LIST
13161: PUSH
13162: LD_INT 25
13164: PUSH
13165: LD_INT 8
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 25
13174: PUSH
13175: LD_INT 9
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: PUSH
13182: EMPTY
13183: LIST
13184: LIST
13185: LIST
13186: LIST
13187: LIST
13188: LIST
13189: LIST
13190: LIST
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: PPUSH
13196: CALL_OW 69
13200: IN
13201: IFFALSE 13217
// loss_counter := loss_counter + 1 ;
13203: LD_ADDR_EXP 13
13207: PUSH
13208: LD_EXP 13
13212: PUSH
13213: LD_INT 1
13215: PLUS
13216: ST_TO_ADDR
// if un = Abdul then
13217: LD_VAR 0 1
13221: PUSH
13222: LD_EXP 55
13226: EQUAL
13227: IFFALSE 13237
// abdul_escaped := false ;
13229: LD_ADDR_EXP 12
13233: PUSH
13234: LD_INT 0
13236: ST_TO_ADDR
// if un in ru_attackers then
13237: LD_VAR 0 1
13241: PUSH
13242: LD_EXP 52
13246: IN
13247: IFFALSE 13265
// ru_attackers := ru_attackers diff un ;
13249: LD_ADDR_EXP 52
13253: PUSH
13254: LD_EXP 52
13258: PUSH
13259: LD_VAR 0 1
13263: DIFF
13264: ST_TO_ADDR
// if un in ar_attackers then
13265: LD_VAR 0 1
13269: PUSH
13270: LD_EXP 10
13274: IN
13275: IFFALSE 13293
// ar_attackers := ar_attackers diff un ;
13277: LD_ADDR_EXP 10
13281: PUSH
13282: LD_EXP 10
13286: PUSH
13287: LD_VAR 0 1
13291: DIFF
13292: ST_TO_ADDR
// if un = JMM then
13293: LD_VAR 0 1
13297: PUSH
13298: LD_EXP 15
13302: EQUAL
13303: IFFALSE 13314
// begin YouLost ( JMM ) ;
13305: LD_STRING JMM
13307: PPUSH
13308: CALL_OW 104
// exit ;
13312: GO 13403
// end ; if un = Burlak then
13314: LD_VAR 0 1
13318: PUSH
13319: LD_EXP 46
13323: EQUAL
13324: IFFALSE 13335
// begin YouLost ( Burlak ) ;
13326: LD_STRING Burlak
13328: PPUSH
13329: CALL_OW 104
// exit ;
13333: GO 13403
// end ; if un = freedom then
13335: LD_VAR 0 1
13339: PUSH
13340: LD_EXP 3
13344: EQUAL
13345: IFFALSE 13356
// begin YouLost ( Destroyed ) ;
13347: LD_STRING Destroyed
13349: PPUSH
13350: CALL_OW 104
// exit ;
13354: GO 13403
// end ; if un = Masha then
13356: LD_VAR 0 1
13360: PUSH
13361: LD_EXP 49
13365: EQUAL
13366: IFFALSE 13375
// ChangeMissionObjectives ( M4b ) ;
13368: LD_STRING M4b
13370: PPUSH
13371: CALL_OW 337
// if un = Mastodont then
13375: LD_VAR 0 1
13379: PUSH
13380: LD_EXP 56
13384: EQUAL
13385: IFFALSE 13394
// ChangeMissionObjectives ( M4a ) ;
13387: LD_STRING M4a
13389: PPUSH
13390: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13394: LD_VAR 0 1
13398: PPUSH
13399: CALL 79324 0 1
// end ;
13403: PPOPN 3
13405: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13406: LD_VAR 0 1
13410: PPUSH
13411: LD_VAR 0 2
13415: PPUSH
13416: CALL 81658 0 2
// end ;
13420: PPOPN 2
13422: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13423: LD_VAR 0 1
13427: PPUSH
13428: CALL 80726 0 1
// end ;
13432: PPOPN 1
13434: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13435: LD_VAR 0 1
13439: PUSH
13440: LD_INT 22
13442: PUSH
13443: LD_INT 7
13445: PUSH
13446: EMPTY
13447: LIST
13448: LIST
13449: PUSH
13450: LD_INT 30
13452: PUSH
13453: LD_INT 0
13455: PUSH
13456: EMPTY
13457: LIST
13458: LIST
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PPUSH
13464: CALL_OW 69
13468: IN
13469: IFFALSE 13508
// begin SetBName ( building , freedom ) ;
13471: LD_VAR 0 1
13475: PPUSH
13476: LD_STRING freedom
13478: PPUSH
13479: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13483: LD_INT 0
13485: PPUSH
13486: LD_INT 7
13488: PPUSH
13489: LD_INT 0
13491: PPUSH
13492: CALL_OW 324
// freedom := building ;
13496: LD_ADDR_EXP 3
13500: PUSH
13501: LD_VAR 0 1
13505: ST_TO_ADDR
// exit ;
13506: GO 13574
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13508: LD_VAR 0 1
13512: PUSH
13513: LD_INT 22
13515: PUSH
13516: LD_INT 7
13518: PUSH
13519: EMPTY
13520: LIST
13521: LIST
13522: PUSH
13523: LD_INT 23
13525: PUSH
13526: LD_INT 3
13528: PUSH
13529: EMPTY
13530: LIST
13531: LIST
13532: PUSH
13533: LD_INT 30
13535: PUSH
13536: LD_INT 6
13538: PUSH
13539: EMPTY
13540: LIST
13541: LIST
13542: PUSH
13543: EMPTY
13544: LIST
13545: LIST
13546: LIST
13547: PPUSH
13548: CALL_OW 69
13552: IN
13553: IFFALSE 13565
// begin ru_lab_builded := true ;
13555: LD_ADDR_EXP 5
13559: PUSH
13560: LD_INT 1
13562: ST_TO_ADDR
// exit ;
13563: GO 13574
// end ; MCE_BuildingComplete ( building ) ;
13565: LD_VAR 0 1
13569: PPUSH
13570: CALL 80967 0 1
// end ;
13574: PPOPN 1
13576: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13577: LD_VAR 0 1
13581: PPUSH
13582: LD_VAR 0 2
13586: PPUSH
13587: CALL 79020 0 2
// end ;
13591: PPOPN 2
13593: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13594: LD_VAR 0 1
13598: PPUSH
13599: LD_VAR 0 2
13603: PPUSH
13604: LD_VAR 0 3
13608: PPUSH
13609: LD_VAR 0 4
13613: PPUSH
13614: LD_VAR 0 5
13618: PPUSH
13619: CALL 78640 0 5
// end ;
13623: PPOPN 5
13625: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13626: LD_VAR 0 1
13630: PPUSH
13631: LD_VAR 0 2
13635: PPUSH
13636: CALL 78230 0 2
// end ;
13640: PPOPN 2
13642: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13643: LD_VAR 0 1
13647: PPUSH
13648: CALL_OW 263
13652: PUSH
13653: LD_INT 3
13655: EQUAL
13656: PUSH
13657: LD_VAR 0 2
13661: PPUSH
13662: CALL_OW 263
13666: PUSH
13667: LD_INT 3
13669: EQUAL
13670: OR
13671: IFFALSE 13687
// hack_counter := hack_counter + 1 ;
13673: LD_ADDR_EXP 14
13677: PUSH
13678: LD_EXP 14
13682: PUSH
13683: LD_INT 1
13685: PLUS
13686: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13687: LD_VAR 0 1
13691: PPUSH
13692: LD_VAR 0 2
13696: PPUSH
13697: LD_VAR 0 3
13701: PPUSH
13702: LD_VAR 0 4
13706: PPUSH
13707: CALL 78068 0 4
// end ;
13711: PPOPN 4
13713: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13714: LD_VAR 0 1
13718: PPUSH
13719: LD_VAR 0 2
13723: PPUSH
13724: LD_VAR 0 3
13728: PPUSH
13729: CALL 77843 0 3
// end ;
13733: PPOPN 3
13735: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13736: LD_VAR 0 1
13740: PPUSH
13741: LD_VAR 0 2
13745: PPUSH
13746: CALL 77728 0 2
// end ;
13750: PPOPN 2
13752: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13753: LD_VAR 0 1
13757: PPUSH
13758: LD_VAR 0 2
13762: PPUSH
13763: CALL 81919 0 2
// end ;
13767: PPOPN 2
13769: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13770: LD_VAR 0 1
13774: PPUSH
13775: LD_VAR 0 2
13779: PPUSH
13780: LD_VAR 0 3
13784: PPUSH
13785: LD_VAR 0 4
13789: PPUSH
13790: CALL 82135 0 4
// end ;
13794: PPOPN 4
13796: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13797: LD_VAR 0 1
13801: PPUSH
13802: LD_VAR 0 2
13806: PPUSH
13807: CALL 77537 0 2
// end ;
13811: PPOPN 2
13813: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13814: LD_VAR 0 1
13818: PPUSH
13819: CALL 95714 0 1
// end ; end_of_file
13823: PPOPN 1
13825: END
// every 0 0$30 do var cr , time ;
13826: GO 13828
13828: DISABLE
13829: LD_INT 0
13831: PPUSH
13832: PPUSH
// begin time := 0 0$20 ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_INT 700
13840: ST_TO_ADDR
// while game do
13841: LD_EXP 2
13845: IFFALSE 13944
// begin wait ( time ) ;
13847: LD_VAR 0 2
13851: PPUSH
13852: CALL_OW 67
// if tick > 2 2$00 then
13856: LD_OWVAR 1
13860: PUSH
13861: LD_INT 4200
13863: GREATER
13864: IFFALSE 13897
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13866: LD_ADDR_VAR 0 2
13870: PUSH
13871: LD_VAR 0 2
13875: PUSH
13876: LD_INT 280
13878: PUSH
13879: LD_INT 420
13881: PUSH
13882: LD_INT 630
13884: PUSH
13885: EMPTY
13886: LIST
13887: LIST
13888: LIST
13889: PUSH
13890: LD_OWVAR 67
13894: ARRAY
13895: PLUS
13896: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13897: LD_INT 1
13899: PPUSH
13900: LD_INT 5
13902: PPUSH
13903: CALL_OW 12
13907: PPUSH
13908: LD_INT 70
13910: PPUSH
13911: LD_INT 49
13913: PPUSH
13914: LD_INT 25
13916: PPUSH
13917: LD_INT 1
13919: PPUSH
13920: CALL_OW 56
// if time > 5 5$00 then
13924: LD_VAR 0 2
13928: PUSH
13929: LD_INT 10500
13931: GREATER
13932: IFFALSE 13942
// time := 0 0$30 ;
13934: LD_ADDR_VAR 0 2
13938: PUSH
13939: LD_INT 1050
13941: ST_TO_ADDR
// end ;
13942: GO 13841
// end ;
13944: PPOPN 2
13946: END
// every 0 0$30 do var cr , time ;
13947: GO 13949
13949: DISABLE
13950: LD_INT 0
13952: PPUSH
13953: PPUSH
// begin time := 0 0$20 ;
13954: LD_ADDR_VAR 0 2
13958: PUSH
13959: LD_INT 700
13961: ST_TO_ADDR
// while game do
13962: LD_EXP 2
13966: IFFALSE 14055
// begin wait ( time ) ;
13968: LD_VAR 0 2
13972: PPUSH
13973: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13977: LD_ADDR_VAR 0 2
13981: PUSH
13982: LD_VAR 0 2
13986: PUSH
13987: LD_INT 490
13989: PUSH
13990: LD_INT 525
13992: PUSH
13993: LD_INT 560
13995: PUSH
13996: EMPTY
13997: LIST
13998: LIST
13999: LIST
14000: PUSH
14001: LD_OWVAR 67
14005: ARRAY
14006: PLUS
14007: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
14008: LD_INT 3
14010: PPUSH
14011: LD_INT 5
14013: PPUSH
14014: CALL_OW 12
14018: PPUSH
14019: LD_INT 26
14021: PPUSH
14022: LD_INT 9
14024: PPUSH
14025: LD_INT 30
14027: PPUSH
14028: LD_INT 1
14030: PPUSH
14031: CALL_OW 56
// if time > 3 3$00 then
14035: LD_VAR 0 2
14039: PUSH
14040: LD_INT 6300
14042: GREATER
14043: IFFALSE 14053
// time := 0 0$20 ;
14045: LD_ADDR_VAR 0 2
14049: PUSH
14050: LD_INT 700
14052: ST_TO_ADDR
// end ;
14053: GO 13962
// end ;
14055: PPOPN 2
14057: END
// every 0 0$30 do var cr , time ;
14058: GO 14060
14060: DISABLE
14061: LD_INT 0
14063: PPUSH
14064: PPUSH
// begin time := 0 0$20 ;
14065: LD_ADDR_VAR 0 2
14069: PUSH
14070: LD_INT 700
14072: ST_TO_ADDR
// while game do
14073: LD_EXP 2
14077: IFFALSE 14202
// begin wait ( time ) ;
14079: LD_VAR 0 2
14083: PPUSH
14084: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14088: LD_ADDR_VAR 0 2
14092: PUSH
14093: LD_VAR 0 2
14097: PUSH
14098: LD_INT 175
14100: PUSH
14101: LD_INT 210
14103: PUSH
14104: LD_INT 280
14106: PUSH
14107: EMPTY
14108: LIST
14109: LIST
14110: LIST
14111: PUSH
14112: LD_OWVAR 67
14116: ARRAY
14117: PLUS
14118: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14119: LD_INT 1
14121: PPUSH
14122: LD_INT 5
14124: PPUSH
14125: CALL_OW 12
14129: PPUSH
14130: LD_INT 179
14132: PPUSH
14133: LD_INT 101
14135: PPUSH
14136: LD_INT 20
14138: PPUSH
14139: LD_INT 1
14141: PPUSH
14142: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14146: LD_INT 350
14148: PPUSH
14149: LD_INT 525
14151: PPUSH
14152: CALL_OW 12
14156: PPUSH
14157: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14161: LD_INT 1
14163: PPUSH
14164: LD_INT 5
14166: PPUSH
14167: CALL_OW 12
14171: PPUSH
14172: LD_INT 9
14174: PPUSH
14175: LD_INT 1
14177: PPUSH
14178: CALL_OW 55
// if time > 4 4$00 then
14182: LD_VAR 0 2
14186: PUSH
14187: LD_INT 8400
14189: GREATER
14190: IFFALSE 14200
// time := 0 0$30 ;
14192: LD_ADDR_VAR 0 2
14196: PUSH
14197: LD_INT 1050
14199: ST_TO_ADDR
// end ;
14200: GO 14073
// end ;
14202: PPOPN 2
14204: END
// every 0 0$30 do var cr , time ;
14205: GO 14207
14207: DISABLE
14208: LD_INT 0
14210: PPUSH
14211: PPUSH
// begin time := 0 0$10 ;
14212: LD_ADDR_VAR 0 2
14216: PUSH
14217: LD_INT 350
14219: ST_TO_ADDR
// while game do
14220: LD_EXP 2
14224: IFFALSE 14358
// begin wait ( time ) ;
14226: LD_VAR 0 2
14230: PPUSH
14231: CALL_OW 67
// time := time + 0 0$10 ;
14235: LD_ADDR_VAR 0 2
14239: PUSH
14240: LD_VAR 0 2
14244: PUSH
14245: LD_INT 350
14247: PLUS
14248: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14249: LD_INT 1
14251: PPUSH
14252: LD_INT 5
14254: PPUSH
14255: CALL_OW 12
14259: PPUSH
14260: LD_INT 11
14262: PPUSH
14263: LD_INT 1
14265: PPUSH
14266: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14270: LD_ADDR_VAR 0 1
14274: PUSH
14275: LD_INT 1
14277: PPUSH
14278: LD_INT 3
14280: PPUSH
14281: CALL_OW 12
14285: ST_TO_ADDR
// if cr = 1 then
14286: LD_VAR 0 1
14290: PUSH
14291: LD_INT 1
14293: EQUAL
14294: IFFALSE 14338
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14296: LD_INT 700
14298: PPUSH
14299: LD_INT 1575
14301: PPUSH
14302: CALL_OW 12
14306: PPUSH
14307: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14311: LD_INT 1
14313: PPUSH
14314: LD_INT 5
14316: PPUSH
14317: CALL_OW 12
14321: PPUSH
14322: LD_INT 34
14324: PPUSH
14325: LD_INT 50
14327: PPUSH
14328: LD_INT 7
14330: PPUSH
14331: LD_INT 1
14333: PPUSH
14334: CALL_OW 56
// end ; if time > 8 8$00 then
14338: LD_VAR 0 2
14342: PUSH
14343: LD_INT 16800
14345: GREATER
14346: IFFALSE 14356
// time := 0 0$40 ;
14348: LD_ADDR_VAR 0 2
14352: PUSH
14353: LD_INT 1400
14355: ST_TO_ADDR
// end ;
14356: GO 14220
// end ; end_of_file
14358: PPOPN 2
14360: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14361: LD_INT 0
14363: PPUSH
14364: PPUSH
// if exist_mode then
14365: LD_VAR 0 2
14369: IFFALSE 14394
// unit := CreateCharacter ( prefix & ident ) else
14371: LD_ADDR_VAR 0 5
14375: PUSH
14376: LD_VAR 0 3
14380: PUSH
14381: LD_VAR 0 1
14385: STR
14386: PPUSH
14387: CALL_OW 34
14391: ST_TO_ADDR
14392: GO 14409
// unit := NewCharacter ( ident ) ;
14394: LD_ADDR_VAR 0 5
14398: PUSH
14399: LD_VAR 0 1
14403: PPUSH
14404: CALL_OW 25
14408: ST_TO_ADDR
// result := unit ;
14409: LD_ADDR_VAR 0 4
14413: PUSH
14414: LD_VAR 0 5
14418: ST_TO_ADDR
// end ;
14419: LD_VAR 0 4
14423: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14424: LD_INT 0
14426: PPUSH
14427: PPUSH
// if not side or not nation then
14428: LD_VAR 0 1
14432: NOT
14433: PUSH
14434: LD_VAR 0 2
14438: NOT
14439: OR
14440: IFFALSE 14444
// exit ;
14442: GO 15208
// case nation of nation_american :
14444: LD_VAR 0 2
14448: PUSH
14449: LD_INT 1
14451: DOUBLE
14452: EQUAL
14453: IFTRUE 14457
14455: GO 14671
14457: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14458: LD_ADDR_VAR 0 4
14462: PUSH
14463: LD_INT 35
14465: PUSH
14466: LD_INT 45
14468: PUSH
14469: LD_INT 46
14471: PUSH
14472: LD_INT 47
14474: PUSH
14475: LD_INT 82
14477: PUSH
14478: LD_INT 83
14480: PUSH
14481: LD_INT 84
14483: PUSH
14484: LD_INT 85
14486: PUSH
14487: LD_INT 86
14489: PUSH
14490: LD_INT 1
14492: PUSH
14493: LD_INT 2
14495: PUSH
14496: LD_INT 6
14498: PUSH
14499: LD_INT 15
14501: PUSH
14502: LD_INT 16
14504: PUSH
14505: LD_INT 7
14507: PUSH
14508: LD_INT 12
14510: PUSH
14511: LD_INT 13
14513: PUSH
14514: LD_INT 10
14516: PUSH
14517: LD_INT 14
14519: PUSH
14520: LD_INT 20
14522: PUSH
14523: LD_INT 21
14525: PUSH
14526: LD_INT 22
14528: PUSH
14529: LD_INT 25
14531: PUSH
14532: LD_INT 32
14534: PUSH
14535: LD_INT 27
14537: PUSH
14538: LD_INT 36
14540: PUSH
14541: LD_INT 69
14543: PUSH
14544: LD_INT 39
14546: PUSH
14547: LD_INT 34
14549: PUSH
14550: LD_INT 40
14552: PUSH
14553: LD_INT 48
14555: PUSH
14556: LD_INT 49
14558: PUSH
14559: LD_INT 50
14561: PUSH
14562: LD_INT 51
14564: PUSH
14565: LD_INT 52
14567: PUSH
14568: LD_INT 53
14570: PUSH
14571: LD_INT 54
14573: PUSH
14574: LD_INT 55
14576: PUSH
14577: LD_INT 56
14579: PUSH
14580: LD_INT 57
14582: PUSH
14583: LD_INT 58
14585: PUSH
14586: LD_INT 59
14588: PUSH
14589: LD_INT 60
14591: PUSH
14592: LD_INT 61
14594: PUSH
14595: LD_INT 62
14597: PUSH
14598: LD_INT 80
14600: PUSH
14601: LD_INT 82
14603: PUSH
14604: LD_INT 83
14606: PUSH
14607: LD_INT 84
14609: PUSH
14610: LD_INT 85
14612: PUSH
14613: LD_INT 86
14615: PUSH
14616: EMPTY
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: LIST
14625: LIST
14626: LIST
14627: LIST
14628: LIST
14629: LIST
14630: LIST
14631: LIST
14632: LIST
14633: LIST
14634: LIST
14635: LIST
14636: LIST
14637: LIST
14638: LIST
14639: LIST
14640: LIST
14641: LIST
14642: LIST
14643: LIST
14644: LIST
14645: LIST
14646: LIST
14647: LIST
14648: LIST
14649: LIST
14650: LIST
14651: LIST
14652: LIST
14653: LIST
14654: LIST
14655: LIST
14656: LIST
14657: LIST
14658: LIST
14659: LIST
14660: LIST
14661: LIST
14662: LIST
14663: LIST
14664: LIST
14665: LIST
14666: LIST
14667: LIST
14668: ST_TO_ADDR
14669: GO 15132
14671: LD_INT 2
14673: DOUBLE
14674: EQUAL
14675: IFTRUE 14679
14677: GO 14901
14679: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14680: LD_ADDR_VAR 0 4
14684: PUSH
14685: LD_INT 35
14687: PUSH
14688: LD_INT 45
14690: PUSH
14691: LD_INT 46
14693: PUSH
14694: LD_INT 47
14696: PUSH
14697: LD_INT 82
14699: PUSH
14700: LD_INT 83
14702: PUSH
14703: LD_INT 84
14705: PUSH
14706: LD_INT 85
14708: PUSH
14709: LD_INT 87
14711: PUSH
14712: LD_INT 70
14714: PUSH
14715: LD_INT 1
14717: PUSH
14718: LD_INT 11
14720: PUSH
14721: LD_INT 3
14723: PUSH
14724: LD_INT 4
14726: PUSH
14727: LD_INT 5
14729: PUSH
14730: LD_INT 6
14732: PUSH
14733: LD_INT 15
14735: PUSH
14736: LD_INT 18
14738: PUSH
14739: LD_INT 7
14741: PUSH
14742: LD_INT 17
14744: PUSH
14745: LD_INT 8
14747: PUSH
14748: LD_INT 20
14750: PUSH
14751: LD_INT 21
14753: PUSH
14754: LD_INT 22
14756: PUSH
14757: LD_INT 72
14759: PUSH
14760: LD_INT 26
14762: PUSH
14763: LD_INT 69
14765: PUSH
14766: LD_INT 39
14768: PUSH
14769: LD_INT 40
14771: PUSH
14772: LD_INT 41
14774: PUSH
14775: LD_INT 42
14777: PUSH
14778: LD_INT 43
14780: PUSH
14781: LD_INT 48
14783: PUSH
14784: LD_INT 49
14786: PUSH
14787: LD_INT 50
14789: PUSH
14790: LD_INT 51
14792: PUSH
14793: LD_INT 52
14795: PUSH
14796: LD_INT 53
14798: PUSH
14799: LD_INT 54
14801: PUSH
14802: LD_INT 55
14804: PUSH
14805: LD_INT 56
14807: PUSH
14808: LD_INT 60
14810: PUSH
14811: LD_INT 61
14813: PUSH
14814: LD_INT 62
14816: PUSH
14817: LD_INT 66
14819: PUSH
14820: LD_INT 67
14822: PUSH
14823: LD_INT 68
14825: PUSH
14826: LD_INT 81
14828: PUSH
14829: LD_INT 82
14831: PUSH
14832: LD_INT 83
14834: PUSH
14835: LD_INT 84
14837: PUSH
14838: LD_INT 85
14840: PUSH
14841: LD_INT 87
14843: PUSH
14844: EMPTY
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: LIST
14855: LIST
14856: LIST
14857: LIST
14858: LIST
14859: LIST
14860: LIST
14861: LIST
14862: LIST
14863: LIST
14864: LIST
14865: LIST
14866: LIST
14867: LIST
14868: LIST
14869: LIST
14870: LIST
14871: LIST
14872: LIST
14873: LIST
14874: LIST
14875: LIST
14876: LIST
14877: LIST
14878: LIST
14879: LIST
14880: LIST
14881: LIST
14882: LIST
14883: LIST
14884: LIST
14885: LIST
14886: LIST
14887: LIST
14888: LIST
14889: LIST
14890: LIST
14891: LIST
14892: LIST
14893: LIST
14894: LIST
14895: LIST
14896: LIST
14897: LIST
14898: ST_TO_ADDR
14899: GO 15132
14901: LD_INT 3
14903: DOUBLE
14904: EQUAL
14905: IFTRUE 14909
14907: GO 15131
14909: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14910: LD_ADDR_VAR 0 4
14914: PUSH
14915: LD_INT 46
14917: PUSH
14918: LD_INT 47
14920: PUSH
14921: LD_INT 1
14923: PUSH
14924: LD_INT 2
14926: PUSH
14927: LD_INT 82
14929: PUSH
14930: LD_INT 83
14932: PUSH
14933: LD_INT 84
14935: PUSH
14936: LD_INT 85
14938: PUSH
14939: LD_INT 86
14941: PUSH
14942: LD_INT 11
14944: PUSH
14945: LD_INT 9
14947: PUSH
14948: LD_INT 20
14950: PUSH
14951: LD_INT 19
14953: PUSH
14954: LD_INT 21
14956: PUSH
14957: LD_INT 24
14959: PUSH
14960: LD_INT 22
14962: PUSH
14963: LD_INT 25
14965: PUSH
14966: LD_INT 28
14968: PUSH
14969: LD_INT 29
14971: PUSH
14972: LD_INT 30
14974: PUSH
14975: LD_INT 31
14977: PUSH
14978: LD_INT 37
14980: PUSH
14981: LD_INT 38
14983: PUSH
14984: LD_INT 32
14986: PUSH
14987: LD_INT 27
14989: PUSH
14990: LD_INT 33
14992: PUSH
14993: LD_INT 69
14995: PUSH
14996: LD_INT 39
14998: PUSH
14999: LD_INT 34
15001: PUSH
15002: LD_INT 40
15004: PUSH
15005: LD_INT 71
15007: PUSH
15008: LD_INT 23
15010: PUSH
15011: LD_INT 44
15013: PUSH
15014: LD_INT 48
15016: PUSH
15017: LD_INT 49
15019: PUSH
15020: LD_INT 50
15022: PUSH
15023: LD_INT 51
15025: PUSH
15026: LD_INT 52
15028: PUSH
15029: LD_INT 53
15031: PUSH
15032: LD_INT 54
15034: PUSH
15035: LD_INT 55
15037: PUSH
15038: LD_INT 56
15040: PUSH
15041: LD_INT 57
15043: PUSH
15044: LD_INT 58
15046: PUSH
15047: LD_INT 59
15049: PUSH
15050: LD_INT 63
15052: PUSH
15053: LD_INT 64
15055: PUSH
15056: LD_INT 65
15058: PUSH
15059: LD_INT 82
15061: PUSH
15062: LD_INT 83
15064: PUSH
15065: LD_INT 84
15067: PUSH
15068: LD_INT 85
15070: PUSH
15071: LD_INT 86
15073: PUSH
15074: EMPTY
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: LIST
15085: LIST
15086: LIST
15087: LIST
15088: LIST
15089: LIST
15090: LIST
15091: LIST
15092: LIST
15093: LIST
15094: LIST
15095: LIST
15096: LIST
15097: LIST
15098: LIST
15099: LIST
15100: LIST
15101: LIST
15102: LIST
15103: LIST
15104: LIST
15105: LIST
15106: LIST
15107: LIST
15108: LIST
15109: LIST
15110: LIST
15111: LIST
15112: LIST
15113: LIST
15114: LIST
15115: LIST
15116: LIST
15117: LIST
15118: LIST
15119: LIST
15120: LIST
15121: LIST
15122: LIST
15123: LIST
15124: LIST
15125: LIST
15126: LIST
15127: LIST
15128: ST_TO_ADDR
15129: GO 15132
15131: POP
// if state > - 1 and state < 3 then
15132: LD_VAR 0 3
15136: PUSH
15137: LD_INT 1
15139: NEG
15140: GREATER
15141: PUSH
15142: LD_VAR 0 3
15146: PUSH
15147: LD_INT 3
15149: LESS
15150: AND
15151: IFFALSE 15208
// for i in result do
15153: LD_ADDR_VAR 0 5
15157: PUSH
15158: LD_VAR 0 4
15162: PUSH
15163: FOR_IN
15164: IFFALSE 15206
// if GetTech ( i , side ) <> state then
15166: LD_VAR 0 5
15170: PPUSH
15171: LD_VAR 0 1
15175: PPUSH
15176: CALL_OW 321
15180: PUSH
15181: LD_VAR 0 3
15185: NONEQUAL
15186: IFFALSE 15204
// result := result diff i ;
15188: LD_ADDR_VAR 0 4
15192: PUSH
15193: LD_VAR 0 4
15197: PUSH
15198: LD_VAR 0 5
15202: DIFF
15203: ST_TO_ADDR
15204: GO 15163
15206: POP
15207: POP
// end ;
15208: LD_VAR 0 4
15212: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15213: LD_INT 0
15215: PPUSH
15216: PPUSH
15217: PPUSH
// result := true ;
15218: LD_ADDR_VAR 0 3
15222: PUSH
15223: LD_INT 1
15225: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15226: LD_ADDR_VAR 0 5
15230: PUSH
15231: LD_VAR 0 2
15235: PPUSH
15236: CALL_OW 480
15240: ST_TO_ADDR
// if not tmp then
15241: LD_VAR 0 5
15245: NOT
15246: IFFALSE 15250
// exit ;
15248: GO 15299
// for i in tmp do
15250: LD_ADDR_VAR 0 4
15254: PUSH
15255: LD_VAR 0 5
15259: PUSH
15260: FOR_IN
15261: IFFALSE 15297
// if GetTech ( i , side ) <> state_researched then
15263: LD_VAR 0 4
15267: PPUSH
15268: LD_VAR 0 1
15272: PPUSH
15273: CALL_OW 321
15277: PUSH
15278: LD_INT 2
15280: NONEQUAL
15281: IFFALSE 15295
// begin result := false ;
15283: LD_ADDR_VAR 0 3
15287: PUSH
15288: LD_INT 0
15290: ST_TO_ADDR
// exit ;
15291: POP
15292: POP
15293: GO 15299
// end ;
15295: GO 15260
15297: POP
15298: POP
// end ;
15299: LD_VAR 0 3
15303: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15304: LD_INT 0
15306: PPUSH
15307: PPUSH
15308: PPUSH
15309: PPUSH
15310: PPUSH
15311: PPUSH
15312: PPUSH
15313: PPUSH
15314: PPUSH
15315: PPUSH
15316: PPUSH
15317: PPUSH
15318: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15319: LD_VAR 0 1
15323: NOT
15324: PUSH
15325: LD_VAR 0 1
15329: PPUSH
15330: CALL_OW 257
15334: PUSH
15335: LD_INT 9
15337: NONEQUAL
15338: OR
15339: IFFALSE 15343
// exit ;
15341: GO 15916
// side := GetSide ( unit ) ;
15343: LD_ADDR_VAR 0 9
15347: PUSH
15348: LD_VAR 0 1
15352: PPUSH
15353: CALL_OW 255
15357: ST_TO_ADDR
// tech_space := tech_spacanom ;
15358: LD_ADDR_VAR 0 12
15362: PUSH
15363: LD_INT 29
15365: ST_TO_ADDR
// tech_time := tech_taurad ;
15366: LD_ADDR_VAR 0 13
15370: PUSH
15371: LD_INT 28
15373: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15374: LD_ADDR_VAR 0 11
15378: PUSH
15379: LD_VAR 0 1
15383: PPUSH
15384: CALL_OW 310
15388: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15389: LD_VAR 0 11
15393: PPUSH
15394: CALL_OW 247
15398: PUSH
15399: LD_INT 2
15401: EQUAL
15402: IFFALSE 15406
// exit ;
15404: GO 15916
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15406: LD_ADDR_VAR 0 8
15410: PUSH
15411: LD_INT 81
15413: PUSH
15414: LD_VAR 0 9
15418: PUSH
15419: EMPTY
15420: LIST
15421: LIST
15422: PUSH
15423: LD_INT 3
15425: PUSH
15426: LD_INT 21
15428: PUSH
15429: LD_INT 3
15431: PUSH
15432: EMPTY
15433: LIST
15434: LIST
15435: PUSH
15436: EMPTY
15437: LIST
15438: LIST
15439: PUSH
15440: EMPTY
15441: LIST
15442: LIST
15443: PPUSH
15444: CALL_OW 69
15448: ST_TO_ADDR
// if not tmp then
15449: LD_VAR 0 8
15453: NOT
15454: IFFALSE 15458
// exit ;
15456: GO 15916
// if in_unit then
15458: LD_VAR 0 11
15462: IFFALSE 15486
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15464: LD_ADDR_VAR 0 10
15468: PUSH
15469: LD_VAR 0 8
15473: PPUSH
15474: LD_VAR 0 11
15478: PPUSH
15479: CALL_OW 74
15483: ST_TO_ADDR
15484: GO 15506
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15486: LD_ADDR_VAR 0 10
15490: PUSH
15491: LD_VAR 0 8
15495: PPUSH
15496: LD_VAR 0 1
15500: PPUSH
15501: CALL_OW 74
15505: ST_TO_ADDR
// if not enemy then
15506: LD_VAR 0 10
15510: NOT
15511: IFFALSE 15515
// exit ;
15513: GO 15916
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15515: LD_VAR 0 11
15519: PUSH
15520: LD_VAR 0 11
15524: PPUSH
15525: LD_VAR 0 10
15529: PPUSH
15530: CALL_OW 296
15534: PUSH
15535: LD_INT 13
15537: GREATER
15538: AND
15539: PUSH
15540: LD_VAR 0 1
15544: PPUSH
15545: LD_VAR 0 10
15549: PPUSH
15550: CALL_OW 296
15554: PUSH
15555: LD_INT 12
15557: GREATER
15558: OR
15559: IFFALSE 15563
// exit ;
15561: GO 15916
// missile := [ 1 ] ;
15563: LD_ADDR_VAR 0 14
15567: PUSH
15568: LD_INT 1
15570: PUSH
15571: EMPTY
15572: LIST
15573: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15574: LD_VAR 0 9
15578: PPUSH
15579: LD_VAR 0 12
15583: PPUSH
15584: CALL_OW 325
15588: IFFALSE 15617
// missile := Insert ( missile , missile + 1 , 2 ) ;
15590: LD_ADDR_VAR 0 14
15594: PUSH
15595: LD_VAR 0 14
15599: PPUSH
15600: LD_VAR 0 14
15604: PUSH
15605: LD_INT 1
15607: PLUS
15608: PPUSH
15609: LD_INT 2
15611: PPUSH
15612: CALL_OW 2
15616: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15617: LD_VAR 0 9
15621: PPUSH
15622: LD_VAR 0 13
15626: PPUSH
15627: CALL_OW 325
15631: PUSH
15632: LD_VAR 0 10
15636: PPUSH
15637: CALL_OW 255
15641: PPUSH
15642: LD_VAR 0 13
15646: PPUSH
15647: CALL_OW 325
15651: NOT
15652: AND
15653: IFFALSE 15682
// missile := Insert ( missile , missile + 1 , 3 ) ;
15655: LD_ADDR_VAR 0 14
15659: PUSH
15660: LD_VAR 0 14
15664: PPUSH
15665: LD_VAR 0 14
15669: PUSH
15670: LD_INT 1
15672: PLUS
15673: PPUSH
15674: LD_INT 3
15676: PPUSH
15677: CALL_OW 2
15681: ST_TO_ADDR
// if missile < 2 then
15682: LD_VAR 0 14
15686: PUSH
15687: LD_INT 2
15689: LESS
15690: IFFALSE 15694
// exit ;
15692: GO 15916
// x := GetX ( enemy ) ;
15694: LD_ADDR_VAR 0 4
15698: PUSH
15699: LD_VAR 0 10
15703: PPUSH
15704: CALL_OW 250
15708: ST_TO_ADDR
// y := GetY ( enemy ) ;
15709: LD_ADDR_VAR 0 5
15713: PUSH
15714: LD_VAR 0 10
15718: PPUSH
15719: CALL_OW 251
15723: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15724: LD_ADDR_VAR 0 6
15728: PUSH
15729: LD_VAR 0 4
15733: PUSH
15734: LD_INT 1
15736: NEG
15737: PPUSH
15738: LD_INT 1
15740: PPUSH
15741: CALL_OW 12
15745: PLUS
15746: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15747: LD_ADDR_VAR 0 7
15751: PUSH
15752: LD_VAR 0 5
15756: PUSH
15757: LD_INT 1
15759: NEG
15760: PPUSH
15761: LD_INT 1
15763: PPUSH
15764: CALL_OW 12
15768: PLUS
15769: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15770: LD_VAR 0 6
15774: PPUSH
15775: LD_VAR 0 7
15779: PPUSH
15780: CALL_OW 488
15784: NOT
15785: IFFALSE 15807
// begin _x := x ;
15787: LD_ADDR_VAR 0 6
15791: PUSH
15792: LD_VAR 0 4
15796: ST_TO_ADDR
// _y := y ;
15797: LD_ADDR_VAR 0 7
15801: PUSH
15802: LD_VAR 0 5
15806: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15807: LD_ADDR_VAR 0 3
15811: PUSH
15812: LD_INT 1
15814: PPUSH
15815: LD_VAR 0 14
15819: PPUSH
15820: CALL_OW 12
15824: ST_TO_ADDR
// case i of 1 :
15825: LD_VAR 0 3
15829: PUSH
15830: LD_INT 1
15832: DOUBLE
15833: EQUAL
15834: IFTRUE 15838
15836: GO 15855
15838: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15839: LD_VAR 0 1
15843: PPUSH
15844: LD_VAR 0 10
15848: PPUSH
15849: CALL_OW 115
15853: GO 15916
15855: LD_INT 2
15857: DOUBLE
15858: EQUAL
15859: IFTRUE 15863
15861: GO 15885
15863: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15864: LD_VAR 0 1
15868: PPUSH
15869: LD_VAR 0 6
15873: PPUSH
15874: LD_VAR 0 7
15878: PPUSH
15879: CALL_OW 153
15883: GO 15916
15885: LD_INT 3
15887: DOUBLE
15888: EQUAL
15889: IFTRUE 15893
15891: GO 15915
15893: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15894: LD_VAR 0 1
15898: PPUSH
15899: LD_VAR 0 6
15903: PPUSH
15904: LD_VAR 0 7
15908: PPUSH
15909: CALL_OW 154
15913: GO 15916
15915: POP
// end ;
15916: LD_VAR 0 2
15920: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15921: LD_INT 0
15923: PPUSH
15924: PPUSH
15925: PPUSH
15926: PPUSH
15927: PPUSH
15928: PPUSH
// if not unit or not building then
15929: LD_VAR 0 1
15933: NOT
15934: PUSH
15935: LD_VAR 0 2
15939: NOT
15940: OR
15941: IFFALSE 15945
// exit ;
15943: GO 16103
// x := GetX ( building ) ;
15945: LD_ADDR_VAR 0 5
15949: PUSH
15950: LD_VAR 0 2
15954: PPUSH
15955: CALL_OW 250
15959: ST_TO_ADDR
// y := GetY ( building ) ;
15960: LD_ADDR_VAR 0 6
15964: PUSH
15965: LD_VAR 0 2
15969: PPUSH
15970: CALL_OW 251
15974: ST_TO_ADDR
// for i = 0 to 5 do
15975: LD_ADDR_VAR 0 4
15979: PUSH
15980: DOUBLE
15981: LD_INT 0
15983: DEC
15984: ST_TO_ADDR
15985: LD_INT 5
15987: PUSH
15988: FOR_TO
15989: IFFALSE 16101
// begin _x := ShiftX ( x , i , 3 ) ;
15991: LD_ADDR_VAR 0 7
15995: PUSH
15996: LD_VAR 0 5
16000: PPUSH
16001: LD_VAR 0 4
16005: PPUSH
16006: LD_INT 3
16008: PPUSH
16009: CALL_OW 272
16013: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
16014: LD_ADDR_VAR 0 8
16018: PUSH
16019: LD_VAR 0 6
16023: PPUSH
16024: LD_VAR 0 4
16028: PPUSH
16029: LD_INT 3
16031: PPUSH
16032: CALL_OW 273
16036: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16037: LD_VAR 0 7
16041: PPUSH
16042: LD_VAR 0 8
16046: PPUSH
16047: CALL_OW 488
16051: NOT
16052: IFFALSE 16056
// continue ;
16054: GO 15988
// if HexInfo ( _x , _y ) = 0 then
16056: LD_VAR 0 7
16060: PPUSH
16061: LD_VAR 0 8
16065: PPUSH
16066: CALL_OW 428
16070: PUSH
16071: LD_INT 0
16073: EQUAL
16074: IFFALSE 16099
// begin ComMoveXY ( unit , _x , _y ) ;
16076: LD_VAR 0 1
16080: PPUSH
16081: LD_VAR 0 7
16085: PPUSH
16086: LD_VAR 0 8
16090: PPUSH
16091: CALL_OW 111
// exit ;
16095: POP
16096: POP
16097: GO 16103
// end ; end ;
16099: GO 15988
16101: POP
16102: POP
// end ;
16103: LD_VAR 0 3
16107: RET
// export function ScanBase ( side , base_area ) ; begin
16108: LD_INT 0
16110: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16111: LD_ADDR_VAR 0 3
16115: PUSH
16116: LD_VAR 0 2
16120: PPUSH
16121: LD_INT 81
16123: PUSH
16124: LD_VAR 0 1
16128: PUSH
16129: EMPTY
16130: LIST
16131: LIST
16132: PPUSH
16133: CALL_OW 70
16137: ST_TO_ADDR
// end ;
16138: LD_VAR 0 3
16142: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16143: LD_INT 0
16145: PPUSH
16146: PPUSH
16147: PPUSH
16148: PPUSH
// result := false ;
16149: LD_ADDR_VAR 0 2
16153: PUSH
16154: LD_INT 0
16156: ST_TO_ADDR
// side := GetSide ( unit ) ;
16157: LD_ADDR_VAR 0 3
16161: PUSH
16162: LD_VAR 0 1
16166: PPUSH
16167: CALL_OW 255
16171: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16172: LD_ADDR_VAR 0 4
16176: PUSH
16177: LD_VAR 0 1
16181: PPUSH
16182: CALL_OW 248
16186: ST_TO_ADDR
// case nat of 1 :
16187: LD_VAR 0 4
16191: PUSH
16192: LD_INT 1
16194: DOUBLE
16195: EQUAL
16196: IFTRUE 16200
16198: GO 16211
16200: POP
// tech := tech_lassight ; 2 :
16201: LD_ADDR_VAR 0 5
16205: PUSH
16206: LD_INT 12
16208: ST_TO_ADDR
16209: GO 16250
16211: LD_INT 2
16213: DOUBLE
16214: EQUAL
16215: IFTRUE 16219
16217: GO 16230
16219: POP
// tech := tech_mortar ; 3 :
16220: LD_ADDR_VAR 0 5
16224: PUSH
16225: LD_INT 41
16227: ST_TO_ADDR
16228: GO 16250
16230: LD_INT 3
16232: DOUBLE
16233: EQUAL
16234: IFTRUE 16238
16236: GO 16249
16238: POP
// tech := tech_bazooka ; end ;
16239: LD_ADDR_VAR 0 5
16243: PUSH
16244: LD_INT 44
16246: ST_TO_ADDR
16247: GO 16250
16249: POP
// if Researched ( side , tech ) then
16250: LD_VAR 0 3
16254: PPUSH
16255: LD_VAR 0 5
16259: PPUSH
16260: CALL_OW 325
16264: IFFALSE 16291
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16266: LD_ADDR_VAR 0 2
16270: PUSH
16271: LD_INT 5
16273: PUSH
16274: LD_INT 8
16276: PUSH
16277: LD_INT 9
16279: PUSH
16280: EMPTY
16281: LIST
16282: LIST
16283: LIST
16284: PUSH
16285: LD_VAR 0 4
16289: ARRAY
16290: ST_TO_ADDR
// end ;
16291: LD_VAR 0 2
16295: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16296: LD_INT 0
16298: PPUSH
16299: PPUSH
16300: PPUSH
// if not mines then
16301: LD_VAR 0 2
16305: NOT
16306: IFFALSE 16310
// exit ;
16308: GO 16454
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16310: LD_ADDR_VAR 0 5
16314: PUSH
16315: LD_INT 81
16317: PUSH
16318: LD_VAR 0 1
16322: PUSH
16323: EMPTY
16324: LIST
16325: LIST
16326: PUSH
16327: LD_INT 3
16329: PUSH
16330: LD_INT 21
16332: PUSH
16333: LD_INT 3
16335: PUSH
16336: EMPTY
16337: LIST
16338: LIST
16339: PUSH
16340: EMPTY
16341: LIST
16342: LIST
16343: PUSH
16344: EMPTY
16345: LIST
16346: LIST
16347: PPUSH
16348: CALL_OW 69
16352: ST_TO_ADDR
// for i in mines do
16353: LD_ADDR_VAR 0 4
16357: PUSH
16358: LD_VAR 0 2
16362: PUSH
16363: FOR_IN
16364: IFFALSE 16452
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16366: LD_VAR 0 4
16370: PUSH
16371: LD_INT 1
16373: ARRAY
16374: PPUSH
16375: LD_VAR 0 4
16379: PUSH
16380: LD_INT 2
16382: ARRAY
16383: PPUSH
16384: CALL_OW 458
16388: NOT
16389: IFFALSE 16393
// continue ;
16391: GO 16363
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16393: LD_VAR 0 4
16397: PUSH
16398: LD_INT 1
16400: ARRAY
16401: PPUSH
16402: LD_VAR 0 4
16406: PUSH
16407: LD_INT 2
16409: ARRAY
16410: PPUSH
16411: CALL_OW 428
16415: PUSH
16416: LD_VAR 0 5
16420: IN
16421: IFFALSE 16450
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16423: LD_VAR 0 4
16427: PUSH
16428: LD_INT 1
16430: ARRAY
16431: PPUSH
16432: LD_VAR 0 4
16436: PUSH
16437: LD_INT 2
16439: ARRAY
16440: PPUSH
16441: LD_VAR 0 1
16445: PPUSH
16446: CALL_OW 456
// end ;
16450: GO 16363
16452: POP
16453: POP
// end ;
16454: LD_VAR 0 3
16458: RET
// export function Count ( array ) ; var i ; begin
16459: LD_INT 0
16461: PPUSH
16462: PPUSH
// result := 0 ;
16463: LD_ADDR_VAR 0 2
16467: PUSH
16468: LD_INT 0
16470: ST_TO_ADDR
// for i in array do
16471: LD_ADDR_VAR 0 3
16475: PUSH
16476: LD_VAR 0 1
16480: PUSH
16481: FOR_IN
16482: IFFALSE 16506
// if i then
16484: LD_VAR 0 3
16488: IFFALSE 16504
// result := result + 1 ;
16490: LD_ADDR_VAR 0 2
16494: PUSH
16495: LD_VAR 0 2
16499: PUSH
16500: LD_INT 1
16502: PLUS
16503: ST_TO_ADDR
16504: GO 16481
16506: POP
16507: POP
// end ;
16508: LD_VAR 0 2
16512: RET
// export function IsEmpty ( building ) ; begin
16513: LD_INT 0
16515: PPUSH
// if not building then
16516: LD_VAR 0 1
16520: NOT
16521: IFFALSE 16525
// exit ;
16523: GO 16568
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16525: LD_ADDR_VAR 0 2
16529: PUSH
16530: LD_VAR 0 1
16534: PUSH
16535: LD_INT 22
16537: PUSH
16538: LD_VAR 0 1
16542: PPUSH
16543: CALL_OW 255
16547: PUSH
16548: EMPTY
16549: LIST
16550: LIST
16551: PUSH
16552: LD_INT 58
16554: PUSH
16555: EMPTY
16556: LIST
16557: PUSH
16558: EMPTY
16559: LIST
16560: LIST
16561: PPUSH
16562: CALL_OW 69
16566: IN
16567: ST_TO_ADDR
// end ;
16568: LD_VAR 0 2
16572: RET
// export function IsNotFull ( building ) ; begin
16573: LD_INT 0
16575: PPUSH
// if not building then
16576: LD_VAR 0 1
16580: NOT
16581: IFFALSE 16585
// exit ;
16583: GO 16604
// result := UnitsInside ( building ) < 6 ;
16585: LD_ADDR_VAR 0 2
16589: PUSH
16590: LD_VAR 0 1
16594: PPUSH
16595: CALL_OW 313
16599: PUSH
16600: LD_INT 6
16602: LESS
16603: ST_TO_ADDR
// end ;
16604: LD_VAR 0 2
16608: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16609: LD_INT 0
16611: PPUSH
16612: PPUSH
16613: PPUSH
16614: PPUSH
// tmp := [ ] ;
16615: LD_ADDR_VAR 0 3
16619: PUSH
16620: EMPTY
16621: ST_TO_ADDR
// list := [ ] ;
16622: LD_ADDR_VAR 0 5
16626: PUSH
16627: EMPTY
16628: ST_TO_ADDR
// for i = 16 to 25 do
16629: LD_ADDR_VAR 0 4
16633: PUSH
16634: DOUBLE
16635: LD_INT 16
16637: DEC
16638: ST_TO_ADDR
16639: LD_INT 25
16641: PUSH
16642: FOR_TO
16643: IFFALSE 16716
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16645: LD_ADDR_VAR 0 3
16649: PUSH
16650: LD_VAR 0 3
16654: PUSH
16655: LD_INT 22
16657: PUSH
16658: LD_VAR 0 1
16662: PPUSH
16663: CALL_OW 255
16667: PUSH
16668: EMPTY
16669: LIST
16670: LIST
16671: PUSH
16672: LD_INT 91
16674: PUSH
16675: LD_VAR 0 1
16679: PUSH
16680: LD_INT 6
16682: PUSH
16683: EMPTY
16684: LIST
16685: LIST
16686: LIST
16687: PUSH
16688: LD_INT 30
16690: PUSH
16691: LD_VAR 0 4
16695: PUSH
16696: EMPTY
16697: LIST
16698: LIST
16699: PUSH
16700: EMPTY
16701: LIST
16702: LIST
16703: LIST
16704: PUSH
16705: EMPTY
16706: LIST
16707: PPUSH
16708: CALL_OW 69
16712: ADD
16713: ST_TO_ADDR
16714: GO 16642
16716: POP
16717: POP
// for i = 1 to tmp do
16718: LD_ADDR_VAR 0 4
16722: PUSH
16723: DOUBLE
16724: LD_INT 1
16726: DEC
16727: ST_TO_ADDR
16728: LD_VAR 0 3
16732: PUSH
16733: FOR_TO
16734: IFFALSE 16822
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16736: LD_ADDR_VAR 0 5
16740: PUSH
16741: LD_VAR 0 5
16745: PUSH
16746: LD_VAR 0 3
16750: PUSH
16751: LD_VAR 0 4
16755: ARRAY
16756: PPUSH
16757: CALL_OW 266
16761: PUSH
16762: LD_VAR 0 3
16766: PUSH
16767: LD_VAR 0 4
16771: ARRAY
16772: PPUSH
16773: CALL_OW 250
16777: PUSH
16778: LD_VAR 0 3
16782: PUSH
16783: LD_VAR 0 4
16787: ARRAY
16788: PPUSH
16789: CALL_OW 251
16793: PUSH
16794: LD_VAR 0 3
16798: PUSH
16799: LD_VAR 0 4
16803: ARRAY
16804: PPUSH
16805: CALL_OW 254
16809: PUSH
16810: EMPTY
16811: LIST
16812: LIST
16813: LIST
16814: LIST
16815: PUSH
16816: EMPTY
16817: LIST
16818: ADD
16819: ST_TO_ADDR
16820: GO 16733
16822: POP
16823: POP
// result := list ;
16824: LD_ADDR_VAR 0 2
16828: PUSH
16829: LD_VAR 0 5
16833: ST_TO_ADDR
// end ;
16834: LD_VAR 0 2
16838: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16839: LD_INT 0
16841: PPUSH
16842: PPUSH
16843: PPUSH
16844: PPUSH
16845: PPUSH
16846: PPUSH
16847: PPUSH
// if not factory then
16848: LD_VAR 0 1
16852: NOT
16853: IFFALSE 16857
// exit ;
16855: GO 17450
// if control = control_apeman then
16857: LD_VAR 0 4
16861: PUSH
16862: LD_INT 5
16864: EQUAL
16865: IFFALSE 16974
// begin tmp := UnitsInside ( factory ) ;
16867: LD_ADDR_VAR 0 8
16871: PUSH
16872: LD_VAR 0 1
16876: PPUSH
16877: CALL_OW 313
16881: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16882: LD_VAR 0 8
16886: PPUSH
16887: LD_INT 25
16889: PUSH
16890: LD_INT 12
16892: PUSH
16893: EMPTY
16894: LIST
16895: LIST
16896: PPUSH
16897: CALL_OW 72
16901: NOT
16902: IFFALSE 16912
// control := control_manual ;
16904: LD_ADDR_VAR 0 4
16908: PUSH
16909: LD_INT 1
16911: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16912: LD_ADDR_VAR 0 8
16916: PUSH
16917: LD_VAR 0 1
16921: PPUSH
16922: CALL 16609 0 1
16926: ST_TO_ADDR
// if tmp then
16927: LD_VAR 0 8
16931: IFFALSE 16974
// begin for i in tmp do
16933: LD_ADDR_VAR 0 7
16937: PUSH
16938: LD_VAR 0 8
16942: PUSH
16943: FOR_IN
16944: IFFALSE 16972
// if i [ 1 ] = b_ext_radio then
16946: LD_VAR 0 7
16950: PUSH
16951: LD_INT 1
16953: ARRAY
16954: PUSH
16955: LD_INT 22
16957: EQUAL
16958: IFFALSE 16970
// begin control := control_remote ;
16960: LD_ADDR_VAR 0 4
16964: PUSH
16965: LD_INT 2
16967: ST_TO_ADDR
// break ;
16968: GO 16972
// end ;
16970: GO 16943
16972: POP
16973: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16974: LD_VAR 0 1
16978: PPUSH
16979: LD_VAR 0 2
16983: PPUSH
16984: LD_VAR 0 3
16988: PPUSH
16989: LD_VAR 0 4
16993: PPUSH
16994: LD_VAR 0 5
16998: PPUSH
16999: CALL_OW 448
17003: IFFALSE 17038
// begin result := [ chassis , engine , control , weapon ] ;
17005: LD_ADDR_VAR 0 6
17009: PUSH
17010: LD_VAR 0 2
17014: PUSH
17015: LD_VAR 0 3
17019: PUSH
17020: LD_VAR 0 4
17024: PUSH
17025: LD_VAR 0 5
17029: PUSH
17030: EMPTY
17031: LIST
17032: LIST
17033: LIST
17034: LIST
17035: ST_TO_ADDR
// exit ;
17036: GO 17450
// end ; _chassis := AvailableChassisList ( factory ) ;
17038: LD_ADDR_VAR 0 9
17042: PUSH
17043: LD_VAR 0 1
17047: PPUSH
17048: CALL_OW 475
17052: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17053: LD_ADDR_VAR 0 11
17057: PUSH
17058: LD_VAR 0 1
17062: PPUSH
17063: CALL_OW 476
17067: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17068: LD_ADDR_VAR 0 12
17072: PUSH
17073: LD_VAR 0 1
17077: PPUSH
17078: CALL_OW 477
17082: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17083: LD_ADDR_VAR 0 10
17087: PUSH
17088: LD_VAR 0 1
17092: PPUSH
17093: CALL_OW 478
17097: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17098: LD_VAR 0 9
17102: NOT
17103: PUSH
17104: LD_VAR 0 11
17108: NOT
17109: OR
17110: PUSH
17111: LD_VAR 0 12
17115: NOT
17116: OR
17117: PUSH
17118: LD_VAR 0 10
17122: NOT
17123: OR
17124: IFFALSE 17159
// begin result := [ chassis , engine , control , weapon ] ;
17126: LD_ADDR_VAR 0 6
17130: PUSH
17131: LD_VAR 0 2
17135: PUSH
17136: LD_VAR 0 3
17140: PUSH
17141: LD_VAR 0 4
17145: PUSH
17146: LD_VAR 0 5
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: LIST
17155: LIST
17156: ST_TO_ADDR
// exit ;
17157: GO 17450
// end ; if not chassis in _chassis then
17159: LD_VAR 0 2
17163: PUSH
17164: LD_VAR 0 9
17168: IN
17169: NOT
17170: IFFALSE 17196
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17172: LD_ADDR_VAR 0 2
17176: PUSH
17177: LD_VAR 0 9
17181: PUSH
17182: LD_INT 1
17184: PPUSH
17185: LD_VAR 0 9
17189: PPUSH
17190: CALL_OW 12
17194: ARRAY
17195: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17196: LD_VAR 0 2
17200: PPUSH
17201: LD_VAR 0 3
17205: PPUSH
17206: CALL 17455 0 2
17210: NOT
17211: IFFALSE 17270
// repeat engine := _engine [ 1 ] ;
17213: LD_ADDR_VAR 0 3
17217: PUSH
17218: LD_VAR 0 11
17222: PUSH
17223: LD_INT 1
17225: ARRAY
17226: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17227: LD_ADDR_VAR 0 11
17231: PUSH
17232: LD_VAR 0 11
17236: PPUSH
17237: LD_INT 1
17239: PPUSH
17240: CALL_OW 3
17244: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17245: LD_VAR 0 2
17249: PPUSH
17250: LD_VAR 0 3
17254: PPUSH
17255: CALL 17455 0 2
17259: PUSH
17260: LD_VAR 0 11
17264: PUSH
17265: EMPTY
17266: EQUAL
17267: OR
17268: IFFALSE 17213
// if not control in _control then
17270: LD_VAR 0 4
17274: PUSH
17275: LD_VAR 0 12
17279: IN
17280: NOT
17281: IFFALSE 17307
// control := _control [ rand ( 1 , _control ) ] ;
17283: LD_ADDR_VAR 0 4
17287: PUSH
17288: LD_VAR 0 12
17292: PUSH
17293: LD_INT 1
17295: PPUSH
17296: LD_VAR 0 12
17300: PPUSH
17301: CALL_OW 12
17305: ARRAY
17306: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17307: LD_VAR 0 2
17311: PPUSH
17312: LD_VAR 0 5
17316: PPUSH
17317: CALL 17675 0 2
17321: NOT
17322: IFFALSE 17381
// repeat weapon := _weapon [ 1 ] ;
17324: LD_ADDR_VAR 0 5
17328: PUSH
17329: LD_VAR 0 10
17333: PUSH
17334: LD_INT 1
17336: ARRAY
17337: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17338: LD_ADDR_VAR 0 10
17342: PUSH
17343: LD_VAR 0 10
17347: PPUSH
17348: LD_INT 1
17350: PPUSH
17351: CALL_OW 3
17355: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17356: LD_VAR 0 2
17360: PPUSH
17361: LD_VAR 0 5
17365: PPUSH
17366: CALL 17675 0 2
17370: PUSH
17371: LD_VAR 0 10
17375: PUSH
17376: EMPTY
17377: EQUAL
17378: OR
17379: IFFALSE 17324
// result := [ ] ;
17381: LD_ADDR_VAR 0 6
17385: PUSH
17386: EMPTY
17387: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17388: LD_VAR 0 1
17392: PPUSH
17393: LD_VAR 0 2
17397: PPUSH
17398: LD_VAR 0 3
17402: PPUSH
17403: LD_VAR 0 4
17407: PPUSH
17408: LD_VAR 0 5
17412: PPUSH
17413: CALL_OW 448
17417: IFFALSE 17450
// result := [ chassis , engine , control , weapon ] ;
17419: LD_ADDR_VAR 0 6
17423: PUSH
17424: LD_VAR 0 2
17428: PUSH
17429: LD_VAR 0 3
17433: PUSH
17434: LD_VAR 0 4
17438: PUSH
17439: LD_VAR 0 5
17443: PUSH
17444: EMPTY
17445: LIST
17446: LIST
17447: LIST
17448: LIST
17449: ST_TO_ADDR
// end ;
17450: LD_VAR 0 6
17454: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17455: LD_INT 0
17457: PPUSH
// if not chassis or not engine then
17458: LD_VAR 0 1
17462: NOT
17463: PUSH
17464: LD_VAR 0 2
17468: NOT
17469: OR
17470: IFFALSE 17474
// exit ;
17472: GO 17670
// case engine of engine_solar :
17474: LD_VAR 0 2
17478: PUSH
17479: LD_INT 2
17481: DOUBLE
17482: EQUAL
17483: IFTRUE 17487
17485: GO 17525
17487: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17488: LD_ADDR_VAR 0 3
17492: PUSH
17493: LD_INT 11
17495: PUSH
17496: LD_INT 12
17498: PUSH
17499: LD_INT 13
17501: PUSH
17502: LD_INT 14
17504: PUSH
17505: LD_INT 1
17507: PUSH
17508: LD_INT 2
17510: PUSH
17511: LD_INT 3
17513: PUSH
17514: EMPTY
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: ST_TO_ADDR
17523: GO 17654
17525: LD_INT 1
17527: DOUBLE
17528: EQUAL
17529: IFTRUE 17533
17531: GO 17595
17533: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17534: LD_ADDR_VAR 0 3
17538: PUSH
17539: LD_INT 11
17541: PUSH
17542: LD_INT 12
17544: PUSH
17545: LD_INT 13
17547: PUSH
17548: LD_INT 14
17550: PUSH
17551: LD_INT 1
17553: PUSH
17554: LD_INT 2
17556: PUSH
17557: LD_INT 3
17559: PUSH
17560: LD_INT 4
17562: PUSH
17563: LD_INT 5
17565: PUSH
17566: LD_INT 21
17568: PUSH
17569: LD_INT 23
17571: PUSH
17572: LD_INT 22
17574: PUSH
17575: LD_INT 24
17577: PUSH
17578: EMPTY
17579: LIST
17580: LIST
17581: LIST
17582: LIST
17583: LIST
17584: LIST
17585: LIST
17586: LIST
17587: LIST
17588: LIST
17589: LIST
17590: LIST
17591: LIST
17592: ST_TO_ADDR
17593: GO 17654
17595: LD_INT 3
17597: DOUBLE
17598: EQUAL
17599: IFTRUE 17603
17601: GO 17653
17603: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17604: LD_ADDR_VAR 0 3
17608: PUSH
17609: LD_INT 13
17611: PUSH
17612: LD_INT 14
17614: PUSH
17615: LD_INT 2
17617: PUSH
17618: LD_INT 3
17620: PUSH
17621: LD_INT 4
17623: PUSH
17624: LD_INT 5
17626: PUSH
17627: LD_INT 21
17629: PUSH
17630: LD_INT 22
17632: PUSH
17633: LD_INT 23
17635: PUSH
17636: LD_INT 24
17638: PUSH
17639: EMPTY
17640: LIST
17641: LIST
17642: LIST
17643: LIST
17644: LIST
17645: LIST
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: ST_TO_ADDR
17651: GO 17654
17653: POP
// result := ( chassis in result ) ;
17654: LD_ADDR_VAR 0 3
17658: PUSH
17659: LD_VAR 0 1
17663: PUSH
17664: LD_VAR 0 3
17668: IN
17669: ST_TO_ADDR
// end ;
17670: LD_VAR 0 3
17674: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17675: LD_INT 0
17677: PPUSH
// if not chassis or not weapon then
17678: LD_VAR 0 1
17682: NOT
17683: PUSH
17684: LD_VAR 0 2
17688: NOT
17689: OR
17690: IFFALSE 17694
// exit ;
17692: GO 18720
// case weapon of us_machine_gun :
17694: LD_VAR 0 2
17698: PUSH
17699: LD_INT 2
17701: DOUBLE
17702: EQUAL
17703: IFTRUE 17707
17705: GO 17737
17707: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17708: LD_ADDR_VAR 0 3
17712: PUSH
17713: LD_INT 1
17715: PUSH
17716: LD_INT 2
17718: PUSH
17719: LD_INT 3
17721: PUSH
17722: LD_INT 4
17724: PUSH
17725: LD_INT 5
17727: PUSH
17728: EMPTY
17729: LIST
17730: LIST
17731: LIST
17732: LIST
17733: LIST
17734: ST_TO_ADDR
17735: GO 18704
17737: LD_INT 3
17739: DOUBLE
17740: EQUAL
17741: IFTRUE 17745
17743: GO 17775
17745: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17746: LD_ADDR_VAR 0 3
17750: PUSH
17751: LD_INT 1
17753: PUSH
17754: LD_INT 2
17756: PUSH
17757: LD_INT 3
17759: PUSH
17760: LD_INT 4
17762: PUSH
17763: LD_INT 5
17765: PUSH
17766: EMPTY
17767: LIST
17768: LIST
17769: LIST
17770: LIST
17771: LIST
17772: ST_TO_ADDR
17773: GO 18704
17775: LD_INT 11
17777: DOUBLE
17778: EQUAL
17779: IFTRUE 17783
17781: GO 17813
17783: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17784: LD_ADDR_VAR 0 3
17788: PUSH
17789: LD_INT 1
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 3
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: LD_INT 5
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: LIST
17810: ST_TO_ADDR
17811: GO 18704
17813: LD_INT 4
17815: DOUBLE
17816: EQUAL
17817: IFTRUE 17821
17819: GO 17847
17821: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17822: LD_ADDR_VAR 0 3
17826: PUSH
17827: LD_INT 2
17829: PUSH
17830: LD_INT 3
17832: PUSH
17833: LD_INT 4
17835: PUSH
17836: LD_INT 5
17838: PUSH
17839: EMPTY
17840: LIST
17841: LIST
17842: LIST
17843: LIST
17844: ST_TO_ADDR
17845: GO 18704
17847: LD_INT 5
17849: DOUBLE
17850: EQUAL
17851: IFTRUE 17855
17853: GO 17881
17855: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17856: LD_ADDR_VAR 0 3
17860: PUSH
17861: LD_INT 2
17863: PUSH
17864: LD_INT 3
17866: PUSH
17867: LD_INT 4
17869: PUSH
17870: LD_INT 5
17872: PUSH
17873: EMPTY
17874: LIST
17875: LIST
17876: LIST
17877: LIST
17878: ST_TO_ADDR
17879: GO 18704
17881: LD_INT 9
17883: DOUBLE
17884: EQUAL
17885: IFTRUE 17889
17887: GO 17915
17889: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17890: LD_ADDR_VAR 0 3
17894: PUSH
17895: LD_INT 2
17897: PUSH
17898: LD_INT 3
17900: PUSH
17901: LD_INT 4
17903: PUSH
17904: LD_INT 5
17906: PUSH
17907: EMPTY
17908: LIST
17909: LIST
17910: LIST
17911: LIST
17912: ST_TO_ADDR
17913: GO 18704
17915: LD_INT 7
17917: DOUBLE
17918: EQUAL
17919: IFTRUE 17923
17921: GO 17949
17923: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17924: LD_ADDR_VAR 0 3
17928: PUSH
17929: LD_INT 2
17931: PUSH
17932: LD_INT 3
17934: PUSH
17935: LD_INT 4
17937: PUSH
17938: LD_INT 5
17940: PUSH
17941: EMPTY
17942: LIST
17943: LIST
17944: LIST
17945: LIST
17946: ST_TO_ADDR
17947: GO 18704
17949: LD_INT 12
17951: DOUBLE
17952: EQUAL
17953: IFTRUE 17957
17955: GO 17983
17957: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17958: LD_ADDR_VAR 0 3
17962: PUSH
17963: LD_INT 2
17965: PUSH
17966: LD_INT 3
17968: PUSH
17969: LD_INT 4
17971: PUSH
17972: LD_INT 5
17974: PUSH
17975: EMPTY
17976: LIST
17977: LIST
17978: LIST
17979: LIST
17980: ST_TO_ADDR
17981: GO 18704
17983: LD_INT 13
17985: DOUBLE
17986: EQUAL
17987: IFTRUE 17991
17989: GO 18017
17991: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17992: LD_ADDR_VAR 0 3
17996: PUSH
17997: LD_INT 2
17999: PUSH
18000: LD_INT 3
18002: PUSH
18003: LD_INT 4
18005: PUSH
18006: LD_INT 5
18008: PUSH
18009: EMPTY
18010: LIST
18011: LIST
18012: LIST
18013: LIST
18014: ST_TO_ADDR
18015: GO 18704
18017: LD_INT 14
18019: DOUBLE
18020: EQUAL
18021: IFTRUE 18025
18023: GO 18043
18025: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
18026: LD_ADDR_VAR 0 3
18030: PUSH
18031: LD_INT 4
18033: PUSH
18034: LD_INT 5
18036: PUSH
18037: EMPTY
18038: LIST
18039: LIST
18040: ST_TO_ADDR
18041: GO 18704
18043: LD_INT 6
18045: DOUBLE
18046: EQUAL
18047: IFTRUE 18051
18049: GO 18069
18051: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18052: LD_ADDR_VAR 0 3
18056: PUSH
18057: LD_INT 4
18059: PUSH
18060: LD_INT 5
18062: PUSH
18063: EMPTY
18064: LIST
18065: LIST
18066: ST_TO_ADDR
18067: GO 18704
18069: LD_INT 10
18071: DOUBLE
18072: EQUAL
18073: IFTRUE 18077
18075: GO 18095
18077: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18078: LD_ADDR_VAR 0 3
18082: PUSH
18083: LD_INT 4
18085: PUSH
18086: LD_INT 5
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: ST_TO_ADDR
18093: GO 18704
18095: LD_INT 22
18097: DOUBLE
18098: EQUAL
18099: IFTRUE 18103
18101: GO 18129
18103: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18104: LD_ADDR_VAR 0 3
18108: PUSH
18109: LD_INT 11
18111: PUSH
18112: LD_INT 12
18114: PUSH
18115: LD_INT 13
18117: PUSH
18118: LD_INT 14
18120: PUSH
18121: EMPTY
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: ST_TO_ADDR
18127: GO 18704
18129: LD_INT 23
18131: DOUBLE
18132: EQUAL
18133: IFTRUE 18137
18135: GO 18163
18137: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18138: LD_ADDR_VAR 0 3
18142: PUSH
18143: LD_INT 11
18145: PUSH
18146: LD_INT 12
18148: PUSH
18149: LD_INT 13
18151: PUSH
18152: LD_INT 14
18154: PUSH
18155: EMPTY
18156: LIST
18157: LIST
18158: LIST
18159: LIST
18160: ST_TO_ADDR
18161: GO 18704
18163: LD_INT 24
18165: DOUBLE
18166: EQUAL
18167: IFTRUE 18171
18169: GO 18197
18171: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18172: LD_ADDR_VAR 0 3
18176: PUSH
18177: LD_INT 11
18179: PUSH
18180: LD_INT 12
18182: PUSH
18183: LD_INT 13
18185: PUSH
18186: LD_INT 14
18188: PUSH
18189: EMPTY
18190: LIST
18191: LIST
18192: LIST
18193: LIST
18194: ST_TO_ADDR
18195: GO 18704
18197: LD_INT 30
18199: DOUBLE
18200: EQUAL
18201: IFTRUE 18205
18203: GO 18231
18205: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18206: LD_ADDR_VAR 0 3
18210: PUSH
18211: LD_INT 11
18213: PUSH
18214: LD_INT 12
18216: PUSH
18217: LD_INT 13
18219: PUSH
18220: LD_INT 14
18222: PUSH
18223: EMPTY
18224: LIST
18225: LIST
18226: LIST
18227: LIST
18228: ST_TO_ADDR
18229: GO 18704
18231: LD_INT 25
18233: DOUBLE
18234: EQUAL
18235: IFTRUE 18239
18237: GO 18257
18239: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18240: LD_ADDR_VAR 0 3
18244: PUSH
18245: LD_INT 13
18247: PUSH
18248: LD_INT 14
18250: PUSH
18251: EMPTY
18252: LIST
18253: LIST
18254: ST_TO_ADDR
18255: GO 18704
18257: LD_INT 27
18259: DOUBLE
18260: EQUAL
18261: IFTRUE 18265
18263: GO 18283
18265: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18266: LD_ADDR_VAR 0 3
18270: PUSH
18271: LD_INT 13
18273: PUSH
18274: LD_INT 14
18276: PUSH
18277: EMPTY
18278: LIST
18279: LIST
18280: ST_TO_ADDR
18281: GO 18704
18283: LD_INT 28
18285: DOUBLE
18286: EQUAL
18287: IFTRUE 18291
18289: GO 18309
18291: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18292: LD_ADDR_VAR 0 3
18296: PUSH
18297: LD_INT 13
18299: PUSH
18300: LD_INT 14
18302: PUSH
18303: EMPTY
18304: LIST
18305: LIST
18306: ST_TO_ADDR
18307: GO 18704
18309: LD_INT 29
18311: DOUBLE
18312: EQUAL
18313: IFTRUE 18317
18315: GO 18335
18317: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18318: LD_ADDR_VAR 0 3
18322: PUSH
18323: LD_INT 13
18325: PUSH
18326: LD_INT 14
18328: PUSH
18329: EMPTY
18330: LIST
18331: LIST
18332: ST_TO_ADDR
18333: GO 18704
18335: LD_INT 31
18337: DOUBLE
18338: EQUAL
18339: IFTRUE 18343
18341: GO 18361
18343: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18344: LD_ADDR_VAR 0 3
18348: PUSH
18349: LD_INT 13
18351: PUSH
18352: LD_INT 14
18354: PUSH
18355: EMPTY
18356: LIST
18357: LIST
18358: ST_TO_ADDR
18359: GO 18704
18361: LD_INT 26
18363: DOUBLE
18364: EQUAL
18365: IFTRUE 18369
18367: GO 18387
18369: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18370: LD_ADDR_VAR 0 3
18374: PUSH
18375: LD_INT 13
18377: PUSH
18378: LD_INT 14
18380: PUSH
18381: EMPTY
18382: LIST
18383: LIST
18384: ST_TO_ADDR
18385: GO 18704
18387: LD_INT 42
18389: DOUBLE
18390: EQUAL
18391: IFTRUE 18395
18393: GO 18421
18395: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18396: LD_ADDR_VAR 0 3
18400: PUSH
18401: LD_INT 21
18403: PUSH
18404: LD_INT 22
18406: PUSH
18407: LD_INT 23
18409: PUSH
18410: LD_INT 24
18412: PUSH
18413: EMPTY
18414: LIST
18415: LIST
18416: LIST
18417: LIST
18418: ST_TO_ADDR
18419: GO 18704
18421: LD_INT 43
18423: DOUBLE
18424: EQUAL
18425: IFTRUE 18429
18427: GO 18455
18429: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18430: LD_ADDR_VAR 0 3
18434: PUSH
18435: LD_INT 21
18437: PUSH
18438: LD_INT 22
18440: PUSH
18441: LD_INT 23
18443: PUSH
18444: LD_INT 24
18446: PUSH
18447: EMPTY
18448: LIST
18449: LIST
18450: LIST
18451: LIST
18452: ST_TO_ADDR
18453: GO 18704
18455: LD_INT 44
18457: DOUBLE
18458: EQUAL
18459: IFTRUE 18463
18461: GO 18489
18463: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18464: LD_ADDR_VAR 0 3
18468: PUSH
18469: LD_INT 21
18471: PUSH
18472: LD_INT 22
18474: PUSH
18475: LD_INT 23
18477: PUSH
18478: LD_INT 24
18480: PUSH
18481: EMPTY
18482: LIST
18483: LIST
18484: LIST
18485: LIST
18486: ST_TO_ADDR
18487: GO 18704
18489: LD_INT 45
18491: DOUBLE
18492: EQUAL
18493: IFTRUE 18497
18495: GO 18523
18497: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18498: LD_ADDR_VAR 0 3
18502: PUSH
18503: LD_INT 21
18505: PUSH
18506: LD_INT 22
18508: PUSH
18509: LD_INT 23
18511: PUSH
18512: LD_INT 24
18514: PUSH
18515: EMPTY
18516: LIST
18517: LIST
18518: LIST
18519: LIST
18520: ST_TO_ADDR
18521: GO 18704
18523: LD_INT 49
18525: DOUBLE
18526: EQUAL
18527: IFTRUE 18531
18529: GO 18557
18531: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18532: LD_ADDR_VAR 0 3
18536: PUSH
18537: LD_INT 21
18539: PUSH
18540: LD_INT 22
18542: PUSH
18543: LD_INT 23
18545: PUSH
18546: LD_INT 24
18548: PUSH
18549: EMPTY
18550: LIST
18551: LIST
18552: LIST
18553: LIST
18554: ST_TO_ADDR
18555: GO 18704
18557: LD_INT 51
18559: DOUBLE
18560: EQUAL
18561: IFTRUE 18565
18563: GO 18591
18565: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18566: LD_ADDR_VAR 0 3
18570: PUSH
18571: LD_INT 21
18573: PUSH
18574: LD_INT 22
18576: PUSH
18577: LD_INT 23
18579: PUSH
18580: LD_INT 24
18582: PUSH
18583: EMPTY
18584: LIST
18585: LIST
18586: LIST
18587: LIST
18588: ST_TO_ADDR
18589: GO 18704
18591: LD_INT 52
18593: DOUBLE
18594: EQUAL
18595: IFTRUE 18599
18597: GO 18625
18599: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18600: LD_ADDR_VAR 0 3
18604: PUSH
18605: LD_INT 21
18607: PUSH
18608: LD_INT 22
18610: PUSH
18611: LD_INT 23
18613: PUSH
18614: LD_INT 24
18616: PUSH
18617: EMPTY
18618: LIST
18619: LIST
18620: LIST
18621: LIST
18622: ST_TO_ADDR
18623: GO 18704
18625: LD_INT 53
18627: DOUBLE
18628: EQUAL
18629: IFTRUE 18633
18631: GO 18651
18633: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18634: LD_ADDR_VAR 0 3
18638: PUSH
18639: LD_INT 23
18641: PUSH
18642: LD_INT 24
18644: PUSH
18645: EMPTY
18646: LIST
18647: LIST
18648: ST_TO_ADDR
18649: GO 18704
18651: LD_INT 46
18653: DOUBLE
18654: EQUAL
18655: IFTRUE 18659
18657: GO 18677
18659: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18660: LD_ADDR_VAR 0 3
18664: PUSH
18665: LD_INT 23
18667: PUSH
18668: LD_INT 24
18670: PUSH
18671: EMPTY
18672: LIST
18673: LIST
18674: ST_TO_ADDR
18675: GO 18704
18677: LD_INT 47
18679: DOUBLE
18680: EQUAL
18681: IFTRUE 18685
18683: GO 18703
18685: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18686: LD_ADDR_VAR 0 3
18690: PUSH
18691: LD_INT 23
18693: PUSH
18694: LD_INT 24
18696: PUSH
18697: EMPTY
18698: LIST
18699: LIST
18700: ST_TO_ADDR
18701: GO 18704
18703: POP
// result := ( chassis in result ) ;
18704: LD_ADDR_VAR 0 3
18708: PUSH
18709: LD_VAR 0 1
18713: PUSH
18714: LD_VAR 0 3
18718: IN
18719: ST_TO_ADDR
// end ;
18720: LD_VAR 0 3
18724: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18725: LD_INT 0
18727: PPUSH
18728: PPUSH
18729: PPUSH
18730: PPUSH
18731: PPUSH
18732: PPUSH
18733: PPUSH
// result := array ;
18734: LD_ADDR_VAR 0 5
18738: PUSH
18739: LD_VAR 0 1
18743: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18744: LD_VAR 0 1
18748: NOT
18749: PUSH
18750: LD_VAR 0 2
18754: NOT
18755: OR
18756: PUSH
18757: LD_VAR 0 3
18761: NOT
18762: OR
18763: PUSH
18764: LD_VAR 0 2
18768: PUSH
18769: LD_VAR 0 1
18773: GREATER
18774: OR
18775: PUSH
18776: LD_VAR 0 3
18780: PUSH
18781: LD_VAR 0 1
18785: GREATER
18786: OR
18787: IFFALSE 18791
// exit ;
18789: GO 19087
// if direction then
18791: LD_VAR 0 4
18795: IFFALSE 18859
// begin d := 1 ;
18797: LD_ADDR_VAR 0 9
18801: PUSH
18802: LD_INT 1
18804: ST_TO_ADDR
// if i_from > i_to then
18805: LD_VAR 0 2
18809: PUSH
18810: LD_VAR 0 3
18814: GREATER
18815: IFFALSE 18841
// length := ( array - i_from ) + i_to else
18817: LD_ADDR_VAR 0 11
18821: PUSH
18822: LD_VAR 0 1
18826: PUSH
18827: LD_VAR 0 2
18831: MINUS
18832: PUSH
18833: LD_VAR 0 3
18837: PLUS
18838: ST_TO_ADDR
18839: GO 18857
// length := i_to - i_from ;
18841: LD_ADDR_VAR 0 11
18845: PUSH
18846: LD_VAR 0 3
18850: PUSH
18851: LD_VAR 0 2
18855: MINUS
18856: ST_TO_ADDR
// end else
18857: GO 18920
// begin d := - 1 ;
18859: LD_ADDR_VAR 0 9
18863: PUSH
18864: LD_INT 1
18866: NEG
18867: ST_TO_ADDR
// if i_from > i_to then
18868: LD_VAR 0 2
18872: PUSH
18873: LD_VAR 0 3
18877: GREATER
18878: IFFALSE 18898
// length := i_from - i_to else
18880: LD_ADDR_VAR 0 11
18884: PUSH
18885: LD_VAR 0 2
18889: PUSH
18890: LD_VAR 0 3
18894: MINUS
18895: ST_TO_ADDR
18896: GO 18920
// length := ( array - i_to ) + i_from ;
18898: LD_ADDR_VAR 0 11
18902: PUSH
18903: LD_VAR 0 1
18907: PUSH
18908: LD_VAR 0 3
18912: MINUS
18913: PUSH
18914: LD_VAR 0 2
18918: PLUS
18919: ST_TO_ADDR
// end ; if not length then
18920: LD_VAR 0 11
18924: NOT
18925: IFFALSE 18929
// exit ;
18927: GO 19087
// tmp := array ;
18929: LD_ADDR_VAR 0 10
18933: PUSH
18934: LD_VAR 0 1
18938: ST_TO_ADDR
// for i = 1 to length do
18939: LD_ADDR_VAR 0 6
18943: PUSH
18944: DOUBLE
18945: LD_INT 1
18947: DEC
18948: ST_TO_ADDR
18949: LD_VAR 0 11
18953: PUSH
18954: FOR_TO
18955: IFFALSE 19075
// begin for j = 1 to array do
18957: LD_ADDR_VAR 0 7
18961: PUSH
18962: DOUBLE
18963: LD_INT 1
18965: DEC
18966: ST_TO_ADDR
18967: LD_VAR 0 1
18971: PUSH
18972: FOR_TO
18973: IFFALSE 19061
// begin k := j + d ;
18975: LD_ADDR_VAR 0 8
18979: PUSH
18980: LD_VAR 0 7
18984: PUSH
18985: LD_VAR 0 9
18989: PLUS
18990: ST_TO_ADDR
// if k > array then
18991: LD_VAR 0 8
18995: PUSH
18996: LD_VAR 0 1
19000: GREATER
19001: IFFALSE 19011
// k := 1 ;
19003: LD_ADDR_VAR 0 8
19007: PUSH
19008: LD_INT 1
19010: ST_TO_ADDR
// if not k then
19011: LD_VAR 0 8
19015: NOT
19016: IFFALSE 19028
// k := array ;
19018: LD_ADDR_VAR 0 8
19022: PUSH
19023: LD_VAR 0 1
19027: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
19028: LD_ADDR_VAR 0 10
19032: PUSH
19033: LD_VAR 0 10
19037: PPUSH
19038: LD_VAR 0 8
19042: PPUSH
19043: LD_VAR 0 1
19047: PUSH
19048: LD_VAR 0 7
19052: ARRAY
19053: PPUSH
19054: CALL_OW 1
19058: ST_TO_ADDR
// end ;
19059: GO 18972
19061: POP
19062: POP
// array := tmp ;
19063: LD_ADDR_VAR 0 1
19067: PUSH
19068: LD_VAR 0 10
19072: ST_TO_ADDR
// end ;
19073: GO 18954
19075: POP
19076: POP
// result := array ;
19077: LD_ADDR_VAR 0 5
19081: PUSH
19082: LD_VAR 0 1
19086: ST_TO_ADDR
// end ;
19087: LD_VAR 0 5
19091: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19092: LD_INT 0
19094: PPUSH
19095: PPUSH
// result := 0 ;
19096: LD_ADDR_VAR 0 3
19100: PUSH
19101: LD_INT 0
19103: ST_TO_ADDR
// if not array or not value in array then
19104: LD_VAR 0 1
19108: NOT
19109: PUSH
19110: LD_VAR 0 2
19114: PUSH
19115: LD_VAR 0 1
19119: IN
19120: NOT
19121: OR
19122: IFFALSE 19126
// exit ;
19124: GO 19180
// for i = 1 to array do
19126: LD_ADDR_VAR 0 4
19130: PUSH
19131: DOUBLE
19132: LD_INT 1
19134: DEC
19135: ST_TO_ADDR
19136: LD_VAR 0 1
19140: PUSH
19141: FOR_TO
19142: IFFALSE 19178
// if value = array [ i ] then
19144: LD_VAR 0 2
19148: PUSH
19149: LD_VAR 0 1
19153: PUSH
19154: LD_VAR 0 4
19158: ARRAY
19159: EQUAL
19160: IFFALSE 19176
// begin result := i ;
19162: LD_ADDR_VAR 0 3
19166: PUSH
19167: LD_VAR 0 4
19171: ST_TO_ADDR
// exit ;
19172: POP
19173: POP
19174: GO 19180
// end ;
19176: GO 19141
19178: POP
19179: POP
// end ;
19180: LD_VAR 0 3
19184: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19185: LD_INT 0
19187: PPUSH
// vc_chassis := chassis ;
19188: LD_ADDR_OWVAR 37
19192: PUSH
19193: LD_VAR 0 1
19197: ST_TO_ADDR
// vc_engine := engine ;
19198: LD_ADDR_OWVAR 39
19202: PUSH
19203: LD_VAR 0 2
19207: ST_TO_ADDR
// vc_control := control ;
19208: LD_ADDR_OWVAR 38
19212: PUSH
19213: LD_VAR 0 3
19217: ST_TO_ADDR
// vc_weapon := weapon ;
19218: LD_ADDR_OWVAR 40
19222: PUSH
19223: LD_VAR 0 4
19227: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19228: LD_ADDR_OWVAR 41
19232: PUSH
19233: LD_VAR 0 5
19237: ST_TO_ADDR
// end ;
19238: LD_VAR 0 6
19242: RET
// export function WantPlant ( unit ) ; var task ; begin
19243: LD_INT 0
19245: PPUSH
19246: PPUSH
// result := false ;
19247: LD_ADDR_VAR 0 2
19251: PUSH
19252: LD_INT 0
19254: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19255: LD_ADDR_VAR 0 3
19259: PUSH
19260: LD_VAR 0 1
19264: PPUSH
19265: CALL_OW 437
19269: ST_TO_ADDR
// if task then
19270: LD_VAR 0 3
19274: IFFALSE 19302
// if task [ 1 ] [ 1 ] = p then
19276: LD_VAR 0 3
19280: PUSH
19281: LD_INT 1
19283: ARRAY
19284: PUSH
19285: LD_INT 1
19287: ARRAY
19288: PUSH
19289: LD_STRING p
19291: EQUAL
19292: IFFALSE 19302
// result := true ;
19294: LD_ADDR_VAR 0 2
19298: PUSH
19299: LD_INT 1
19301: ST_TO_ADDR
// end ;
19302: LD_VAR 0 2
19306: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19307: LD_INT 0
19309: PPUSH
19310: PPUSH
19311: PPUSH
19312: PPUSH
// if pos < 1 then
19313: LD_VAR 0 2
19317: PUSH
19318: LD_INT 1
19320: LESS
19321: IFFALSE 19325
// exit ;
19323: GO 19628
// if pos = 1 then
19325: LD_VAR 0 2
19329: PUSH
19330: LD_INT 1
19332: EQUAL
19333: IFFALSE 19366
// result := Replace ( arr , pos [ 1 ] , value ) else
19335: LD_ADDR_VAR 0 4
19339: PUSH
19340: LD_VAR 0 1
19344: PPUSH
19345: LD_VAR 0 2
19349: PUSH
19350: LD_INT 1
19352: ARRAY
19353: PPUSH
19354: LD_VAR 0 3
19358: PPUSH
19359: CALL_OW 1
19363: ST_TO_ADDR
19364: GO 19628
// begin tmp := arr ;
19366: LD_ADDR_VAR 0 6
19370: PUSH
19371: LD_VAR 0 1
19375: ST_TO_ADDR
// s_arr := [ tmp ] ;
19376: LD_ADDR_VAR 0 7
19380: PUSH
19381: LD_VAR 0 6
19385: PUSH
19386: EMPTY
19387: LIST
19388: ST_TO_ADDR
// for i = 1 to pos - 1 do
19389: LD_ADDR_VAR 0 5
19393: PUSH
19394: DOUBLE
19395: LD_INT 1
19397: DEC
19398: ST_TO_ADDR
19399: LD_VAR 0 2
19403: PUSH
19404: LD_INT 1
19406: MINUS
19407: PUSH
19408: FOR_TO
19409: IFFALSE 19454
// begin tmp := tmp [ pos [ i ] ] ;
19411: LD_ADDR_VAR 0 6
19415: PUSH
19416: LD_VAR 0 6
19420: PUSH
19421: LD_VAR 0 2
19425: PUSH
19426: LD_VAR 0 5
19430: ARRAY
19431: ARRAY
19432: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19433: LD_ADDR_VAR 0 7
19437: PUSH
19438: LD_VAR 0 7
19442: PUSH
19443: LD_VAR 0 6
19447: PUSH
19448: EMPTY
19449: LIST
19450: ADD
19451: ST_TO_ADDR
// end ;
19452: GO 19408
19454: POP
19455: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19456: LD_ADDR_VAR 0 6
19460: PUSH
19461: LD_VAR 0 6
19465: PPUSH
19466: LD_VAR 0 2
19470: PUSH
19471: LD_VAR 0 2
19475: ARRAY
19476: PPUSH
19477: LD_VAR 0 3
19481: PPUSH
19482: CALL_OW 1
19486: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19487: LD_ADDR_VAR 0 7
19491: PUSH
19492: LD_VAR 0 7
19496: PPUSH
19497: LD_VAR 0 7
19501: PPUSH
19502: LD_VAR 0 6
19506: PPUSH
19507: CALL_OW 1
19511: ST_TO_ADDR
// for i = s_arr downto 2 do
19512: LD_ADDR_VAR 0 5
19516: PUSH
19517: DOUBLE
19518: LD_VAR 0 7
19522: INC
19523: ST_TO_ADDR
19524: LD_INT 2
19526: PUSH
19527: FOR_DOWNTO
19528: IFFALSE 19612
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19530: LD_ADDR_VAR 0 6
19534: PUSH
19535: LD_VAR 0 7
19539: PUSH
19540: LD_VAR 0 5
19544: PUSH
19545: LD_INT 1
19547: MINUS
19548: ARRAY
19549: PPUSH
19550: LD_VAR 0 2
19554: PUSH
19555: LD_VAR 0 5
19559: PUSH
19560: LD_INT 1
19562: MINUS
19563: ARRAY
19564: PPUSH
19565: LD_VAR 0 7
19569: PUSH
19570: LD_VAR 0 5
19574: ARRAY
19575: PPUSH
19576: CALL_OW 1
19580: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19581: LD_ADDR_VAR 0 7
19585: PUSH
19586: LD_VAR 0 7
19590: PPUSH
19591: LD_VAR 0 5
19595: PUSH
19596: LD_INT 1
19598: MINUS
19599: PPUSH
19600: LD_VAR 0 6
19604: PPUSH
19605: CALL_OW 1
19609: ST_TO_ADDR
// end ;
19610: GO 19527
19612: POP
19613: POP
// result := s_arr [ 1 ] ;
19614: LD_ADDR_VAR 0 4
19618: PUSH
19619: LD_VAR 0 7
19623: PUSH
19624: LD_INT 1
19626: ARRAY
19627: ST_TO_ADDR
// end ; end ;
19628: LD_VAR 0 4
19632: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19633: LD_INT 0
19635: PPUSH
19636: PPUSH
// if not list then
19637: LD_VAR 0 1
19641: NOT
19642: IFFALSE 19646
// exit ;
19644: GO 19737
// i := list [ pos1 ] ;
19646: LD_ADDR_VAR 0 5
19650: PUSH
19651: LD_VAR 0 1
19655: PUSH
19656: LD_VAR 0 2
19660: ARRAY
19661: ST_TO_ADDR
// if not i then
19662: LD_VAR 0 5
19666: NOT
19667: IFFALSE 19671
// exit ;
19669: GO 19737
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19671: LD_ADDR_VAR 0 1
19675: PUSH
19676: LD_VAR 0 1
19680: PPUSH
19681: LD_VAR 0 2
19685: PPUSH
19686: LD_VAR 0 1
19690: PUSH
19691: LD_VAR 0 3
19695: ARRAY
19696: PPUSH
19697: CALL_OW 1
19701: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19702: LD_ADDR_VAR 0 1
19706: PUSH
19707: LD_VAR 0 1
19711: PPUSH
19712: LD_VAR 0 3
19716: PPUSH
19717: LD_VAR 0 5
19721: PPUSH
19722: CALL_OW 1
19726: ST_TO_ADDR
// result := list ;
19727: LD_ADDR_VAR 0 4
19731: PUSH
19732: LD_VAR 0 1
19736: ST_TO_ADDR
// end ;
19737: LD_VAR 0 4
19741: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19742: LD_INT 0
19744: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19745: LD_ADDR_VAR 0 5
19749: PUSH
19750: LD_VAR 0 1
19754: PPUSH
19755: CALL_OW 250
19759: PPUSH
19760: LD_VAR 0 1
19764: PPUSH
19765: CALL_OW 251
19769: PPUSH
19770: LD_VAR 0 2
19774: PPUSH
19775: LD_VAR 0 3
19779: PPUSH
19780: LD_VAR 0 4
19784: PPUSH
19785: CALL 19795 0 5
19789: ST_TO_ADDR
// end ;
19790: LD_VAR 0 5
19794: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19795: LD_INT 0
19797: PPUSH
19798: PPUSH
19799: PPUSH
19800: PPUSH
// if not list then
19801: LD_VAR 0 3
19805: NOT
19806: IFFALSE 19810
// exit ;
19808: GO 20198
// result := [ ] ;
19810: LD_ADDR_VAR 0 6
19814: PUSH
19815: EMPTY
19816: ST_TO_ADDR
// for i in list do
19817: LD_ADDR_VAR 0 7
19821: PUSH
19822: LD_VAR 0 3
19826: PUSH
19827: FOR_IN
19828: IFFALSE 20030
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19830: LD_ADDR_VAR 0 9
19834: PUSH
19835: LD_VAR 0 7
19839: PPUSH
19840: LD_VAR 0 1
19844: PPUSH
19845: LD_VAR 0 2
19849: PPUSH
19850: CALL_OW 297
19854: ST_TO_ADDR
// if not result then
19855: LD_VAR 0 6
19859: NOT
19860: IFFALSE 19886
// result := [ [ i , tmp ] ] else
19862: LD_ADDR_VAR 0 6
19866: PUSH
19867: LD_VAR 0 7
19871: PUSH
19872: LD_VAR 0 9
19876: PUSH
19877: EMPTY
19878: LIST
19879: LIST
19880: PUSH
19881: EMPTY
19882: LIST
19883: ST_TO_ADDR
19884: GO 20028
// begin if result [ result ] [ 2 ] < tmp then
19886: LD_VAR 0 6
19890: PUSH
19891: LD_VAR 0 6
19895: ARRAY
19896: PUSH
19897: LD_INT 2
19899: ARRAY
19900: PUSH
19901: LD_VAR 0 9
19905: LESS
19906: IFFALSE 19948
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19908: LD_ADDR_VAR 0 6
19912: PUSH
19913: LD_VAR 0 6
19917: PPUSH
19918: LD_VAR 0 6
19922: PUSH
19923: LD_INT 1
19925: PLUS
19926: PPUSH
19927: LD_VAR 0 7
19931: PUSH
19932: LD_VAR 0 9
19936: PUSH
19937: EMPTY
19938: LIST
19939: LIST
19940: PPUSH
19941: CALL_OW 2
19945: ST_TO_ADDR
19946: GO 20028
// for j = 1 to result do
19948: LD_ADDR_VAR 0 8
19952: PUSH
19953: DOUBLE
19954: LD_INT 1
19956: DEC
19957: ST_TO_ADDR
19958: LD_VAR 0 6
19962: PUSH
19963: FOR_TO
19964: IFFALSE 20026
// begin if tmp < result [ j ] [ 2 ] then
19966: LD_VAR 0 9
19970: PUSH
19971: LD_VAR 0 6
19975: PUSH
19976: LD_VAR 0 8
19980: ARRAY
19981: PUSH
19982: LD_INT 2
19984: ARRAY
19985: LESS
19986: IFFALSE 20024
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19988: LD_ADDR_VAR 0 6
19992: PUSH
19993: LD_VAR 0 6
19997: PPUSH
19998: LD_VAR 0 8
20002: PPUSH
20003: LD_VAR 0 7
20007: PUSH
20008: LD_VAR 0 9
20012: PUSH
20013: EMPTY
20014: LIST
20015: LIST
20016: PPUSH
20017: CALL_OW 2
20021: ST_TO_ADDR
// break ;
20022: GO 20026
// end ; end ;
20024: GO 19963
20026: POP
20027: POP
// end ; end ;
20028: GO 19827
20030: POP
20031: POP
// if result and not asc then
20032: LD_VAR 0 6
20036: PUSH
20037: LD_VAR 0 4
20041: NOT
20042: AND
20043: IFFALSE 20118
// begin tmp := result ;
20045: LD_ADDR_VAR 0 9
20049: PUSH
20050: LD_VAR 0 6
20054: ST_TO_ADDR
// for i = tmp downto 1 do
20055: LD_ADDR_VAR 0 7
20059: PUSH
20060: DOUBLE
20061: LD_VAR 0 9
20065: INC
20066: ST_TO_ADDR
20067: LD_INT 1
20069: PUSH
20070: FOR_DOWNTO
20071: IFFALSE 20116
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20073: LD_ADDR_VAR 0 6
20077: PUSH
20078: LD_VAR 0 6
20082: PPUSH
20083: LD_VAR 0 9
20087: PUSH
20088: LD_VAR 0 7
20092: MINUS
20093: PUSH
20094: LD_INT 1
20096: PLUS
20097: PPUSH
20098: LD_VAR 0 9
20102: PUSH
20103: LD_VAR 0 7
20107: ARRAY
20108: PPUSH
20109: CALL_OW 1
20113: ST_TO_ADDR
20114: GO 20070
20116: POP
20117: POP
// end ; tmp := [ ] ;
20118: LD_ADDR_VAR 0 9
20122: PUSH
20123: EMPTY
20124: ST_TO_ADDR
// if mode then
20125: LD_VAR 0 5
20129: IFFALSE 20198
// begin for i = 1 to result do
20131: LD_ADDR_VAR 0 7
20135: PUSH
20136: DOUBLE
20137: LD_INT 1
20139: DEC
20140: ST_TO_ADDR
20141: LD_VAR 0 6
20145: PUSH
20146: FOR_TO
20147: IFFALSE 20186
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20149: LD_ADDR_VAR 0 9
20153: PUSH
20154: LD_VAR 0 9
20158: PPUSH
20159: LD_VAR 0 7
20163: PPUSH
20164: LD_VAR 0 6
20168: PUSH
20169: LD_VAR 0 7
20173: ARRAY
20174: PUSH
20175: LD_INT 1
20177: ARRAY
20178: PPUSH
20179: CALL_OW 1
20183: ST_TO_ADDR
20184: GO 20146
20186: POP
20187: POP
// result := tmp ;
20188: LD_ADDR_VAR 0 6
20192: PUSH
20193: LD_VAR 0 9
20197: ST_TO_ADDR
// end ; end ;
20198: LD_VAR 0 6
20202: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20203: LD_INT 0
20205: PPUSH
20206: PPUSH
20207: PPUSH
20208: PPUSH
20209: PPUSH
20210: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20211: LD_ADDR_VAR 0 5
20215: PUSH
20216: LD_INT 0
20218: PUSH
20219: LD_INT 0
20221: PUSH
20222: LD_INT 0
20224: PUSH
20225: EMPTY
20226: PUSH
20227: EMPTY
20228: LIST
20229: LIST
20230: LIST
20231: LIST
20232: ST_TO_ADDR
// if not x or not y then
20233: LD_VAR 0 2
20237: NOT
20238: PUSH
20239: LD_VAR 0 3
20243: NOT
20244: OR
20245: IFFALSE 20249
// exit ;
20247: GO 21895
// if not range then
20249: LD_VAR 0 4
20253: NOT
20254: IFFALSE 20264
// range := 10 ;
20256: LD_ADDR_VAR 0 4
20260: PUSH
20261: LD_INT 10
20263: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20264: LD_ADDR_VAR 0 8
20268: PUSH
20269: LD_INT 81
20271: PUSH
20272: LD_VAR 0 1
20276: PUSH
20277: EMPTY
20278: LIST
20279: LIST
20280: PUSH
20281: LD_INT 92
20283: PUSH
20284: LD_VAR 0 2
20288: PUSH
20289: LD_VAR 0 3
20293: PUSH
20294: LD_VAR 0 4
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: LIST
20303: LIST
20304: PUSH
20305: LD_INT 3
20307: PUSH
20308: LD_INT 21
20310: PUSH
20311: LD_INT 3
20313: PUSH
20314: EMPTY
20315: LIST
20316: LIST
20317: PUSH
20318: EMPTY
20319: LIST
20320: LIST
20321: PUSH
20322: EMPTY
20323: LIST
20324: LIST
20325: LIST
20326: PPUSH
20327: CALL_OW 69
20331: ST_TO_ADDR
// if not tmp then
20332: LD_VAR 0 8
20336: NOT
20337: IFFALSE 20341
// exit ;
20339: GO 21895
// for i in tmp do
20341: LD_ADDR_VAR 0 6
20345: PUSH
20346: LD_VAR 0 8
20350: PUSH
20351: FOR_IN
20352: IFFALSE 21870
// begin points := [ 0 , 0 , 0 ] ;
20354: LD_ADDR_VAR 0 9
20358: PUSH
20359: LD_INT 0
20361: PUSH
20362: LD_INT 0
20364: PUSH
20365: LD_INT 0
20367: PUSH
20368: EMPTY
20369: LIST
20370: LIST
20371: LIST
20372: ST_TO_ADDR
// bpoints := 1 ;
20373: LD_ADDR_VAR 0 10
20377: PUSH
20378: LD_INT 1
20380: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20381: LD_VAR 0 6
20385: PPUSH
20386: CALL_OW 247
20390: PUSH
20391: LD_INT 1
20393: DOUBLE
20394: EQUAL
20395: IFTRUE 20399
20397: GO 20977
20399: POP
// begin if GetClass ( i ) = 1 then
20400: LD_VAR 0 6
20404: PPUSH
20405: CALL_OW 257
20409: PUSH
20410: LD_INT 1
20412: EQUAL
20413: IFFALSE 20434
// points := [ 10 , 5 , 3 ] ;
20415: LD_ADDR_VAR 0 9
20419: PUSH
20420: LD_INT 10
20422: PUSH
20423: LD_INT 5
20425: PUSH
20426: LD_INT 3
20428: PUSH
20429: EMPTY
20430: LIST
20431: LIST
20432: LIST
20433: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20434: LD_VAR 0 6
20438: PPUSH
20439: CALL_OW 257
20443: PUSH
20444: LD_INT 2
20446: PUSH
20447: LD_INT 3
20449: PUSH
20450: LD_INT 4
20452: PUSH
20453: EMPTY
20454: LIST
20455: LIST
20456: LIST
20457: IN
20458: IFFALSE 20479
// points := [ 3 , 2 , 1 ] ;
20460: LD_ADDR_VAR 0 9
20464: PUSH
20465: LD_INT 3
20467: PUSH
20468: LD_INT 2
20470: PUSH
20471: LD_INT 1
20473: PUSH
20474: EMPTY
20475: LIST
20476: LIST
20477: LIST
20478: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20479: LD_VAR 0 6
20483: PPUSH
20484: CALL_OW 257
20488: PUSH
20489: LD_INT 5
20491: EQUAL
20492: IFFALSE 20513
// points := [ 130 , 5 , 2 ] ;
20494: LD_ADDR_VAR 0 9
20498: PUSH
20499: LD_INT 130
20501: PUSH
20502: LD_INT 5
20504: PUSH
20505: LD_INT 2
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: LIST
20512: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20513: LD_VAR 0 6
20517: PPUSH
20518: CALL_OW 257
20522: PUSH
20523: LD_INT 8
20525: EQUAL
20526: IFFALSE 20547
// points := [ 35 , 35 , 30 ] ;
20528: LD_ADDR_VAR 0 9
20532: PUSH
20533: LD_INT 35
20535: PUSH
20536: LD_INT 35
20538: PUSH
20539: LD_INT 30
20541: PUSH
20542: EMPTY
20543: LIST
20544: LIST
20545: LIST
20546: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20547: LD_VAR 0 6
20551: PPUSH
20552: CALL_OW 257
20556: PUSH
20557: LD_INT 9
20559: EQUAL
20560: IFFALSE 20581
// points := [ 20 , 55 , 40 ] ;
20562: LD_ADDR_VAR 0 9
20566: PUSH
20567: LD_INT 20
20569: PUSH
20570: LD_INT 55
20572: PUSH
20573: LD_INT 40
20575: PUSH
20576: EMPTY
20577: LIST
20578: LIST
20579: LIST
20580: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20581: LD_VAR 0 6
20585: PPUSH
20586: CALL_OW 257
20590: PUSH
20591: LD_INT 12
20593: PUSH
20594: LD_INT 16
20596: PUSH
20597: EMPTY
20598: LIST
20599: LIST
20600: IN
20601: IFFALSE 20622
// points := [ 5 , 3 , 2 ] ;
20603: LD_ADDR_VAR 0 9
20607: PUSH
20608: LD_INT 5
20610: PUSH
20611: LD_INT 3
20613: PUSH
20614: LD_INT 2
20616: PUSH
20617: EMPTY
20618: LIST
20619: LIST
20620: LIST
20621: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20622: LD_VAR 0 6
20626: PPUSH
20627: CALL_OW 257
20631: PUSH
20632: LD_INT 17
20634: EQUAL
20635: IFFALSE 20656
// points := [ 100 , 50 , 75 ] ;
20637: LD_ADDR_VAR 0 9
20641: PUSH
20642: LD_INT 100
20644: PUSH
20645: LD_INT 50
20647: PUSH
20648: LD_INT 75
20650: PUSH
20651: EMPTY
20652: LIST
20653: LIST
20654: LIST
20655: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20656: LD_VAR 0 6
20660: PPUSH
20661: CALL_OW 257
20665: PUSH
20666: LD_INT 15
20668: EQUAL
20669: IFFALSE 20690
// points := [ 10 , 5 , 3 ] ;
20671: LD_ADDR_VAR 0 9
20675: PUSH
20676: LD_INT 10
20678: PUSH
20679: LD_INT 5
20681: PUSH
20682: LD_INT 3
20684: PUSH
20685: EMPTY
20686: LIST
20687: LIST
20688: LIST
20689: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20690: LD_VAR 0 6
20694: PPUSH
20695: CALL_OW 257
20699: PUSH
20700: LD_INT 14
20702: EQUAL
20703: IFFALSE 20724
// points := [ 10 , 0 , 0 ] ;
20705: LD_ADDR_VAR 0 9
20709: PUSH
20710: LD_INT 10
20712: PUSH
20713: LD_INT 0
20715: PUSH
20716: LD_INT 0
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: LIST
20723: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20724: LD_VAR 0 6
20728: PPUSH
20729: CALL_OW 257
20733: PUSH
20734: LD_INT 11
20736: EQUAL
20737: IFFALSE 20758
// points := [ 30 , 10 , 5 ] ;
20739: LD_ADDR_VAR 0 9
20743: PUSH
20744: LD_INT 30
20746: PUSH
20747: LD_INT 10
20749: PUSH
20750: LD_INT 5
20752: PUSH
20753: EMPTY
20754: LIST
20755: LIST
20756: LIST
20757: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20758: LD_VAR 0 1
20762: PPUSH
20763: LD_INT 5
20765: PPUSH
20766: CALL_OW 321
20770: PUSH
20771: LD_INT 2
20773: EQUAL
20774: IFFALSE 20791
// bpoints := bpoints * 1.8 ;
20776: LD_ADDR_VAR 0 10
20780: PUSH
20781: LD_VAR 0 10
20785: PUSH
20786: LD_REAL  1.80000000000000E+0000
20789: MUL
20790: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20791: LD_VAR 0 6
20795: PPUSH
20796: CALL_OW 257
20800: PUSH
20801: LD_INT 1
20803: PUSH
20804: LD_INT 2
20806: PUSH
20807: LD_INT 3
20809: PUSH
20810: LD_INT 4
20812: PUSH
20813: EMPTY
20814: LIST
20815: LIST
20816: LIST
20817: LIST
20818: IN
20819: PUSH
20820: LD_VAR 0 1
20824: PPUSH
20825: LD_INT 51
20827: PPUSH
20828: CALL_OW 321
20832: PUSH
20833: LD_INT 2
20835: EQUAL
20836: AND
20837: IFFALSE 20854
// bpoints := bpoints * 1.2 ;
20839: LD_ADDR_VAR 0 10
20843: PUSH
20844: LD_VAR 0 10
20848: PUSH
20849: LD_REAL  1.20000000000000E+0000
20852: MUL
20853: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20854: LD_VAR 0 6
20858: PPUSH
20859: CALL_OW 257
20863: PUSH
20864: LD_INT 5
20866: PUSH
20867: LD_INT 7
20869: PUSH
20870: LD_INT 9
20872: PUSH
20873: EMPTY
20874: LIST
20875: LIST
20876: LIST
20877: IN
20878: PUSH
20879: LD_VAR 0 1
20883: PPUSH
20884: LD_INT 52
20886: PPUSH
20887: CALL_OW 321
20891: PUSH
20892: LD_INT 2
20894: EQUAL
20895: AND
20896: IFFALSE 20913
// bpoints := bpoints * 1.5 ;
20898: LD_ADDR_VAR 0 10
20902: PUSH
20903: LD_VAR 0 10
20907: PUSH
20908: LD_REAL  1.50000000000000E+0000
20911: MUL
20912: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20913: LD_VAR 0 1
20917: PPUSH
20918: LD_INT 66
20920: PPUSH
20921: CALL_OW 321
20925: PUSH
20926: LD_INT 2
20928: EQUAL
20929: IFFALSE 20946
// bpoints := bpoints * 1.1 ;
20931: LD_ADDR_VAR 0 10
20935: PUSH
20936: LD_VAR 0 10
20940: PUSH
20941: LD_REAL  1.10000000000000E+0000
20944: MUL
20945: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20946: LD_ADDR_VAR 0 10
20950: PUSH
20951: LD_VAR 0 10
20955: PUSH
20956: LD_VAR 0 6
20960: PPUSH
20961: LD_INT 1
20963: PPUSH
20964: CALL_OW 259
20968: PUSH
20969: LD_REAL  1.15000000000000E+0000
20972: MUL
20973: MUL
20974: ST_TO_ADDR
// end ; unit_vehicle :
20975: GO 21799
20977: LD_INT 2
20979: DOUBLE
20980: EQUAL
20981: IFTRUE 20985
20983: GO 21787
20985: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20986: LD_VAR 0 6
20990: PPUSH
20991: CALL_OW 264
20995: PUSH
20996: LD_INT 2
20998: PUSH
20999: LD_INT 42
21001: PUSH
21002: LD_INT 24
21004: PUSH
21005: EMPTY
21006: LIST
21007: LIST
21008: LIST
21009: IN
21010: IFFALSE 21031
// points := [ 25 , 5 , 3 ] ;
21012: LD_ADDR_VAR 0 9
21016: PUSH
21017: LD_INT 25
21019: PUSH
21020: LD_INT 5
21022: PUSH
21023: LD_INT 3
21025: PUSH
21026: EMPTY
21027: LIST
21028: LIST
21029: LIST
21030: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
21031: LD_VAR 0 6
21035: PPUSH
21036: CALL_OW 264
21040: PUSH
21041: LD_INT 4
21043: PUSH
21044: LD_INT 43
21046: PUSH
21047: LD_INT 25
21049: PUSH
21050: EMPTY
21051: LIST
21052: LIST
21053: LIST
21054: IN
21055: IFFALSE 21076
// points := [ 40 , 15 , 5 ] ;
21057: LD_ADDR_VAR 0 9
21061: PUSH
21062: LD_INT 40
21064: PUSH
21065: LD_INT 15
21067: PUSH
21068: LD_INT 5
21070: PUSH
21071: EMPTY
21072: LIST
21073: LIST
21074: LIST
21075: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21076: LD_VAR 0 6
21080: PPUSH
21081: CALL_OW 264
21085: PUSH
21086: LD_INT 3
21088: PUSH
21089: LD_INT 23
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: IN
21096: IFFALSE 21117
// points := [ 7 , 25 , 8 ] ;
21098: LD_ADDR_VAR 0 9
21102: PUSH
21103: LD_INT 7
21105: PUSH
21106: LD_INT 25
21108: PUSH
21109: LD_INT 8
21111: PUSH
21112: EMPTY
21113: LIST
21114: LIST
21115: LIST
21116: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21117: LD_VAR 0 6
21121: PPUSH
21122: CALL_OW 264
21126: PUSH
21127: LD_INT 5
21129: PUSH
21130: LD_INT 27
21132: PUSH
21133: LD_INT 44
21135: PUSH
21136: EMPTY
21137: LIST
21138: LIST
21139: LIST
21140: IN
21141: IFFALSE 21162
// points := [ 14 , 50 , 16 ] ;
21143: LD_ADDR_VAR 0 9
21147: PUSH
21148: LD_INT 14
21150: PUSH
21151: LD_INT 50
21153: PUSH
21154: LD_INT 16
21156: PUSH
21157: EMPTY
21158: LIST
21159: LIST
21160: LIST
21161: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21162: LD_VAR 0 6
21166: PPUSH
21167: CALL_OW 264
21171: PUSH
21172: LD_INT 6
21174: PUSH
21175: LD_INT 46
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: IN
21182: IFFALSE 21203
// points := [ 32 , 120 , 70 ] ;
21184: LD_ADDR_VAR 0 9
21188: PUSH
21189: LD_INT 32
21191: PUSH
21192: LD_INT 120
21194: PUSH
21195: LD_INT 70
21197: PUSH
21198: EMPTY
21199: LIST
21200: LIST
21201: LIST
21202: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21203: LD_VAR 0 6
21207: PPUSH
21208: CALL_OW 264
21212: PUSH
21213: LD_INT 7
21215: PUSH
21216: LD_INT 28
21218: PUSH
21219: LD_INT 45
21221: PUSH
21222: EMPTY
21223: LIST
21224: LIST
21225: LIST
21226: IN
21227: IFFALSE 21248
// points := [ 35 , 20 , 45 ] ;
21229: LD_ADDR_VAR 0 9
21233: PUSH
21234: LD_INT 35
21236: PUSH
21237: LD_INT 20
21239: PUSH
21240: LD_INT 45
21242: PUSH
21243: EMPTY
21244: LIST
21245: LIST
21246: LIST
21247: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21248: LD_VAR 0 6
21252: PPUSH
21253: CALL_OW 264
21257: PUSH
21258: LD_INT 47
21260: PUSH
21261: EMPTY
21262: LIST
21263: IN
21264: IFFALSE 21285
// points := [ 67 , 45 , 75 ] ;
21266: LD_ADDR_VAR 0 9
21270: PUSH
21271: LD_INT 67
21273: PUSH
21274: LD_INT 45
21276: PUSH
21277: LD_INT 75
21279: PUSH
21280: EMPTY
21281: LIST
21282: LIST
21283: LIST
21284: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21285: LD_VAR 0 6
21289: PPUSH
21290: CALL_OW 264
21294: PUSH
21295: LD_INT 26
21297: PUSH
21298: EMPTY
21299: LIST
21300: IN
21301: IFFALSE 21322
// points := [ 120 , 30 , 80 ] ;
21303: LD_ADDR_VAR 0 9
21307: PUSH
21308: LD_INT 120
21310: PUSH
21311: LD_INT 30
21313: PUSH
21314: LD_INT 80
21316: PUSH
21317: EMPTY
21318: LIST
21319: LIST
21320: LIST
21321: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21322: LD_VAR 0 6
21326: PPUSH
21327: CALL_OW 264
21331: PUSH
21332: LD_INT 22
21334: PUSH
21335: EMPTY
21336: LIST
21337: IN
21338: IFFALSE 21359
// points := [ 40 , 1 , 1 ] ;
21340: LD_ADDR_VAR 0 9
21344: PUSH
21345: LD_INT 40
21347: PUSH
21348: LD_INT 1
21350: PUSH
21351: LD_INT 1
21353: PUSH
21354: EMPTY
21355: LIST
21356: LIST
21357: LIST
21358: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21359: LD_VAR 0 6
21363: PPUSH
21364: CALL_OW 264
21368: PUSH
21369: LD_INT 29
21371: PUSH
21372: EMPTY
21373: LIST
21374: IN
21375: IFFALSE 21396
// points := [ 70 , 200 , 400 ] ;
21377: LD_ADDR_VAR 0 9
21381: PUSH
21382: LD_INT 70
21384: PUSH
21385: LD_INT 200
21387: PUSH
21388: LD_INT 400
21390: PUSH
21391: EMPTY
21392: LIST
21393: LIST
21394: LIST
21395: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21396: LD_VAR 0 6
21400: PPUSH
21401: CALL_OW 264
21405: PUSH
21406: LD_INT 14
21408: PUSH
21409: LD_INT 53
21411: PUSH
21412: EMPTY
21413: LIST
21414: LIST
21415: IN
21416: IFFALSE 21437
// points := [ 40 , 10 , 20 ] ;
21418: LD_ADDR_VAR 0 9
21422: PUSH
21423: LD_INT 40
21425: PUSH
21426: LD_INT 10
21428: PUSH
21429: LD_INT 20
21431: PUSH
21432: EMPTY
21433: LIST
21434: LIST
21435: LIST
21436: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21437: LD_VAR 0 6
21441: PPUSH
21442: CALL_OW 264
21446: PUSH
21447: LD_INT 9
21449: PUSH
21450: EMPTY
21451: LIST
21452: IN
21453: IFFALSE 21474
// points := [ 5 , 70 , 20 ] ;
21455: LD_ADDR_VAR 0 9
21459: PUSH
21460: LD_INT 5
21462: PUSH
21463: LD_INT 70
21465: PUSH
21466: LD_INT 20
21468: PUSH
21469: EMPTY
21470: LIST
21471: LIST
21472: LIST
21473: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21474: LD_VAR 0 6
21478: PPUSH
21479: CALL_OW 264
21483: PUSH
21484: LD_INT 10
21486: PUSH
21487: EMPTY
21488: LIST
21489: IN
21490: IFFALSE 21511
// points := [ 35 , 110 , 70 ] ;
21492: LD_ADDR_VAR 0 9
21496: PUSH
21497: LD_INT 35
21499: PUSH
21500: LD_INT 110
21502: PUSH
21503: LD_INT 70
21505: PUSH
21506: EMPTY
21507: LIST
21508: LIST
21509: LIST
21510: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21511: LD_VAR 0 6
21515: PPUSH
21516: CALL_OW 265
21520: PUSH
21521: LD_INT 25
21523: EQUAL
21524: IFFALSE 21545
// points := [ 80 , 65 , 100 ] ;
21526: LD_ADDR_VAR 0 9
21530: PUSH
21531: LD_INT 80
21533: PUSH
21534: LD_INT 65
21536: PUSH
21537: LD_INT 100
21539: PUSH
21540: EMPTY
21541: LIST
21542: LIST
21543: LIST
21544: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21545: LD_VAR 0 6
21549: PPUSH
21550: CALL_OW 263
21554: PUSH
21555: LD_INT 1
21557: EQUAL
21558: IFFALSE 21593
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21560: LD_ADDR_VAR 0 10
21564: PUSH
21565: LD_VAR 0 10
21569: PUSH
21570: LD_VAR 0 6
21574: PPUSH
21575: CALL_OW 311
21579: PPUSH
21580: LD_INT 3
21582: PPUSH
21583: CALL_OW 259
21587: PUSH
21588: LD_INT 4
21590: MUL
21591: MUL
21592: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21593: LD_VAR 0 6
21597: PPUSH
21598: CALL_OW 263
21602: PUSH
21603: LD_INT 2
21605: EQUAL
21606: IFFALSE 21657
// begin j := IsControledBy ( i ) ;
21608: LD_ADDR_VAR 0 7
21612: PUSH
21613: LD_VAR 0 6
21617: PPUSH
21618: CALL_OW 312
21622: ST_TO_ADDR
// if j then
21623: LD_VAR 0 7
21627: IFFALSE 21657
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21629: LD_ADDR_VAR 0 10
21633: PUSH
21634: LD_VAR 0 10
21638: PUSH
21639: LD_VAR 0 7
21643: PPUSH
21644: LD_INT 3
21646: PPUSH
21647: CALL_OW 259
21651: PUSH
21652: LD_INT 3
21654: MUL
21655: MUL
21656: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21657: LD_VAR 0 6
21661: PPUSH
21662: CALL_OW 264
21666: PUSH
21667: LD_INT 5
21669: PUSH
21670: LD_INT 6
21672: PUSH
21673: LD_INT 46
21675: PUSH
21676: LD_INT 44
21678: PUSH
21679: LD_INT 47
21681: PUSH
21682: LD_INT 45
21684: PUSH
21685: LD_INT 28
21687: PUSH
21688: LD_INT 7
21690: PUSH
21691: LD_INT 27
21693: PUSH
21694: LD_INT 29
21696: PUSH
21697: EMPTY
21698: LIST
21699: LIST
21700: LIST
21701: LIST
21702: LIST
21703: LIST
21704: LIST
21705: LIST
21706: LIST
21707: LIST
21708: IN
21709: PUSH
21710: LD_VAR 0 1
21714: PPUSH
21715: LD_INT 52
21717: PPUSH
21718: CALL_OW 321
21722: PUSH
21723: LD_INT 2
21725: EQUAL
21726: AND
21727: IFFALSE 21744
// bpoints := bpoints * 1.2 ;
21729: LD_ADDR_VAR 0 10
21733: PUSH
21734: LD_VAR 0 10
21738: PUSH
21739: LD_REAL  1.20000000000000E+0000
21742: MUL
21743: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21744: LD_VAR 0 6
21748: PPUSH
21749: CALL_OW 264
21753: PUSH
21754: LD_INT 6
21756: PUSH
21757: LD_INT 46
21759: PUSH
21760: LD_INT 47
21762: PUSH
21763: EMPTY
21764: LIST
21765: LIST
21766: LIST
21767: IN
21768: IFFALSE 21785
// bpoints := bpoints * 1.2 ;
21770: LD_ADDR_VAR 0 10
21774: PUSH
21775: LD_VAR 0 10
21779: PUSH
21780: LD_REAL  1.20000000000000E+0000
21783: MUL
21784: ST_TO_ADDR
// end ; unit_building :
21785: GO 21799
21787: LD_INT 3
21789: DOUBLE
21790: EQUAL
21791: IFTRUE 21795
21793: GO 21798
21795: POP
// ; end ;
21796: GO 21799
21798: POP
// for j = 1 to 3 do
21799: LD_ADDR_VAR 0 7
21803: PUSH
21804: DOUBLE
21805: LD_INT 1
21807: DEC
21808: ST_TO_ADDR
21809: LD_INT 3
21811: PUSH
21812: FOR_TO
21813: IFFALSE 21866
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21815: LD_ADDR_VAR 0 5
21819: PUSH
21820: LD_VAR 0 5
21824: PPUSH
21825: LD_VAR 0 7
21829: PPUSH
21830: LD_VAR 0 5
21834: PUSH
21835: LD_VAR 0 7
21839: ARRAY
21840: PUSH
21841: LD_VAR 0 9
21845: PUSH
21846: LD_VAR 0 7
21850: ARRAY
21851: PUSH
21852: LD_VAR 0 10
21856: MUL
21857: PLUS
21858: PPUSH
21859: CALL_OW 1
21863: ST_TO_ADDR
21864: GO 21812
21866: POP
21867: POP
// end ;
21868: GO 20351
21870: POP
21871: POP
// result := Replace ( result , 4 , tmp ) ;
21872: LD_ADDR_VAR 0 5
21876: PUSH
21877: LD_VAR 0 5
21881: PPUSH
21882: LD_INT 4
21884: PPUSH
21885: LD_VAR 0 8
21889: PPUSH
21890: CALL_OW 1
21894: ST_TO_ADDR
// end ;
21895: LD_VAR 0 5
21899: RET
// export function DangerAtRange ( unit , range ) ; begin
21900: LD_INT 0
21902: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21903: LD_ADDR_VAR 0 3
21907: PUSH
21908: LD_VAR 0 1
21912: PPUSH
21913: CALL_OW 255
21917: PPUSH
21918: LD_VAR 0 1
21922: PPUSH
21923: CALL_OW 250
21927: PPUSH
21928: LD_VAR 0 1
21932: PPUSH
21933: CALL_OW 251
21937: PPUSH
21938: LD_VAR 0 2
21942: PPUSH
21943: CALL 20203 0 4
21947: ST_TO_ADDR
// end ;
21948: LD_VAR 0 3
21952: RET
// export function DangerInArea ( side , area ) ; begin
21953: LD_INT 0
21955: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21956: LD_ADDR_VAR 0 3
21960: PUSH
21961: LD_VAR 0 2
21965: PPUSH
21966: LD_INT 81
21968: PUSH
21969: LD_VAR 0 1
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: PPUSH
21978: CALL_OW 70
21982: ST_TO_ADDR
// end ;
21983: LD_VAR 0 3
21987: RET
// export function IsExtension ( b ) ; begin
21988: LD_INT 0
21990: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21991: LD_ADDR_VAR 0 2
21995: PUSH
21996: LD_VAR 0 1
22000: PUSH
22001: LD_INT 23
22003: PUSH
22004: LD_INT 20
22006: PUSH
22007: LD_INT 22
22009: PUSH
22010: LD_INT 17
22012: PUSH
22013: LD_INT 24
22015: PUSH
22016: LD_INT 21
22018: PUSH
22019: LD_INT 19
22021: PUSH
22022: LD_INT 16
22024: PUSH
22025: LD_INT 25
22027: PUSH
22028: LD_INT 18
22030: PUSH
22031: EMPTY
22032: LIST
22033: LIST
22034: LIST
22035: LIST
22036: LIST
22037: LIST
22038: LIST
22039: LIST
22040: LIST
22041: LIST
22042: IN
22043: ST_TO_ADDR
// end ;
22044: LD_VAR 0 2
22048: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
22049: LD_INT 0
22051: PPUSH
22052: PPUSH
22053: PPUSH
// result := [ ] ;
22054: LD_ADDR_VAR 0 4
22058: PUSH
22059: EMPTY
22060: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22061: LD_ADDR_VAR 0 5
22065: PUSH
22066: LD_VAR 0 2
22070: PPUSH
22071: LD_INT 21
22073: PUSH
22074: LD_INT 3
22076: PUSH
22077: EMPTY
22078: LIST
22079: LIST
22080: PPUSH
22081: CALL_OW 70
22085: ST_TO_ADDR
// if not tmp then
22086: LD_VAR 0 5
22090: NOT
22091: IFFALSE 22095
// exit ;
22093: GO 22159
// if checkLink then
22095: LD_VAR 0 3
22099: IFFALSE 22149
// begin for i in tmp do
22101: LD_ADDR_VAR 0 6
22105: PUSH
22106: LD_VAR 0 5
22110: PUSH
22111: FOR_IN
22112: IFFALSE 22147
// if GetBase ( i ) <> base then
22114: LD_VAR 0 6
22118: PPUSH
22119: CALL_OW 274
22123: PUSH
22124: LD_VAR 0 1
22128: NONEQUAL
22129: IFFALSE 22145
// ComLinkToBase ( base , i ) ;
22131: LD_VAR 0 1
22135: PPUSH
22136: LD_VAR 0 6
22140: PPUSH
22141: CALL_OW 169
22145: GO 22111
22147: POP
22148: POP
// end ; result := tmp ;
22149: LD_ADDR_VAR 0 4
22153: PUSH
22154: LD_VAR 0 5
22158: ST_TO_ADDR
// end ;
22159: LD_VAR 0 4
22163: RET
// export function ComComplete ( units , b ) ; var i ; begin
22164: LD_INT 0
22166: PPUSH
22167: PPUSH
// if not units then
22168: LD_VAR 0 1
22172: NOT
22173: IFFALSE 22177
// exit ;
22175: GO 22267
// for i in units do
22177: LD_ADDR_VAR 0 4
22181: PUSH
22182: LD_VAR 0 1
22186: PUSH
22187: FOR_IN
22188: IFFALSE 22265
// if BuildingStatus ( b ) = bs_build then
22190: LD_VAR 0 2
22194: PPUSH
22195: CALL_OW 461
22199: PUSH
22200: LD_INT 1
22202: EQUAL
22203: IFFALSE 22263
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22205: LD_VAR 0 4
22209: PPUSH
22210: LD_STRING h
22212: PUSH
22213: LD_VAR 0 2
22217: PPUSH
22218: CALL_OW 250
22222: PUSH
22223: LD_VAR 0 2
22227: PPUSH
22228: CALL_OW 251
22232: PUSH
22233: LD_VAR 0 2
22237: PUSH
22238: LD_INT 0
22240: PUSH
22241: LD_INT 0
22243: PUSH
22244: LD_INT 0
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: LIST
22251: LIST
22252: LIST
22253: LIST
22254: LIST
22255: PUSH
22256: EMPTY
22257: LIST
22258: PPUSH
22259: CALL_OW 446
22263: GO 22187
22265: POP
22266: POP
// end ;
22267: LD_VAR 0 3
22271: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22272: LD_INT 0
22274: PPUSH
22275: PPUSH
22276: PPUSH
22277: PPUSH
22278: PPUSH
22279: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22280: LD_VAR 0 1
22284: NOT
22285: PUSH
22286: LD_VAR 0 1
22290: PPUSH
22291: CALL_OW 263
22295: PUSH
22296: LD_INT 2
22298: EQUAL
22299: NOT
22300: OR
22301: IFFALSE 22305
// exit ;
22303: GO 22621
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22305: LD_ADDR_VAR 0 6
22309: PUSH
22310: LD_INT 22
22312: PUSH
22313: LD_VAR 0 1
22317: PPUSH
22318: CALL_OW 255
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 2
22329: PUSH
22330: LD_INT 30
22332: PUSH
22333: LD_INT 36
22335: PUSH
22336: EMPTY
22337: LIST
22338: LIST
22339: PUSH
22340: LD_INT 34
22342: PUSH
22343: LD_INT 31
22345: PUSH
22346: EMPTY
22347: LIST
22348: LIST
22349: PUSH
22350: EMPTY
22351: LIST
22352: LIST
22353: LIST
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: PPUSH
22359: CALL_OW 69
22363: ST_TO_ADDR
// if not tmp then
22364: LD_VAR 0 6
22368: NOT
22369: IFFALSE 22373
// exit ;
22371: GO 22621
// result := [ ] ;
22373: LD_ADDR_VAR 0 2
22377: PUSH
22378: EMPTY
22379: ST_TO_ADDR
// for i in tmp do
22380: LD_ADDR_VAR 0 3
22384: PUSH
22385: LD_VAR 0 6
22389: PUSH
22390: FOR_IN
22391: IFFALSE 22462
// begin t := UnitsInside ( i ) ;
22393: LD_ADDR_VAR 0 4
22397: PUSH
22398: LD_VAR 0 3
22402: PPUSH
22403: CALL_OW 313
22407: ST_TO_ADDR
// if t then
22408: LD_VAR 0 4
22412: IFFALSE 22460
// for j in t do
22414: LD_ADDR_VAR 0 7
22418: PUSH
22419: LD_VAR 0 4
22423: PUSH
22424: FOR_IN
22425: IFFALSE 22458
// result := Insert ( result , result + 1 , j ) ;
22427: LD_ADDR_VAR 0 2
22431: PUSH
22432: LD_VAR 0 2
22436: PPUSH
22437: LD_VAR 0 2
22441: PUSH
22442: LD_INT 1
22444: PLUS
22445: PPUSH
22446: LD_VAR 0 7
22450: PPUSH
22451: CALL_OW 2
22455: ST_TO_ADDR
22456: GO 22424
22458: POP
22459: POP
// end ;
22460: GO 22390
22462: POP
22463: POP
// if not result then
22464: LD_VAR 0 2
22468: NOT
22469: IFFALSE 22473
// exit ;
22471: GO 22621
// mech := result [ 1 ] ;
22473: LD_ADDR_VAR 0 5
22477: PUSH
22478: LD_VAR 0 2
22482: PUSH
22483: LD_INT 1
22485: ARRAY
22486: ST_TO_ADDR
// if result > 1 then
22487: LD_VAR 0 2
22491: PUSH
22492: LD_INT 1
22494: GREATER
22495: IFFALSE 22607
// for i = 2 to result do
22497: LD_ADDR_VAR 0 3
22501: PUSH
22502: DOUBLE
22503: LD_INT 2
22505: DEC
22506: ST_TO_ADDR
22507: LD_VAR 0 2
22511: PUSH
22512: FOR_TO
22513: IFFALSE 22605
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22515: LD_ADDR_VAR 0 4
22519: PUSH
22520: LD_VAR 0 2
22524: PUSH
22525: LD_VAR 0 3
22529: ARRAY
22530: PPUSH
22531: LD_INT 3
22533: PPUSH
22534: CALL_OW 259
22538: PUSH
22539: LD_VAR 0 2
22543: PUSH
22544: LD_VAR 0 3
22548: ARRAY
22549: PPUSH
22550: CALL_OW 432
22554: MINUS
22555: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22556: LD_VAR 0 4
22560: PUSH
22561: LD_VAR 0 5
22565: PPUSH
22566: LD_INT 3
22568: PPUSH
22569: CALL_OW 259
22573: PUSH
22574: LD_VAR 0 5
22578: PPUSH
22579: CALL_OW 432
22583: MINUS
22584: GREATEREQUAL
22585: IFFALSE 22603
// mech := result [ i ] ;
22587: LD_ADDR_VAR 0 5
22591: PUSH
22592: LD_VAR 0 2
22596: PUSH
22597: LD_VAR 0 3
22601: ARRAY
22602: ST_TO_ADDR
// end ;
22603: GO 22512
22605: POP
22606: POP
// ComLinkTo ( vehicle , mech ) ;
22607: LD_VAR 0 1
22611: PPUSH
22612: LD_VAR 0 5
22616: PPUSH
22617: CALL_OW 135
// end ;
22621: LD_VAR 0 2
22625: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22626: LD_INT 0
22628: PPUSH
22629: PPUSH
22630: PPUSH
22631: PPUSH
22632: PPUSH
22633: PPUSH
22634: PPUSH
22635: PPUSH
22636: PPUSH
22637: PPUSH
22638: PPUSH
22639: PPUSH
22640: PPUSH
// result := [ ] ;
22641: LD_ADDR_VAR 0 7
22645: PUSH
22646: EMPTY
22647: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22648: LD_VAR 0 1
22652: PPUSH
22653: CALL_OW 266
22657: PUSH
22658: LD_INT 0
22660: PUSH
22661: LD_INT 1
22663: PUSH
22664: EMPTY
22665: LIST
22666: LIST
22667: IN
22668: NOT
22669: IFFALSE 22673
// exit ;
22671: GO 24307
// if name then
22673: LD_VAR 0 3
22677: IFFALSE 22693
// SetBName ( base_dep , name ) ;
22679: LD_VAR 0 1
22683: PPUSH
22684: LD_VAR 0 3
22688: PPUSH
22689: CALL_OW 500
// base := GetBase ( base_dep ) ;
22693: LD_ADDR_VAR 0 15
22697: PUSH
22698: LD_VAR 0 1
22702: PPUSH
22703: CALL_OW 274
22707: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22708: LD_ADDR_VAR 0 16
22712: PUSH
22713: LD_VAR 0 1
22717: PPUSH
22718: CALL_OW 255
22722: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22723: LD_ADDR_VAR 0 17
22727: PUSH
22728: LD_VAR 0 1
22732: PPUSH
22733: CALL_OW 248
22737: ST_TO_ADDR
// if sources then
22738: LD_VAR 0 5
22742: IFFALSE 22789
// for i = 1 to 3 do
22744: LD_ADDR_VAR 0 8
22748: PUSH
22749: DOUBLE
22750: LD_INT 1
22752: DEC
22753: ST_TO_ADDR
22754: LD_INT 3
22756: PUSH
22757: FOR_TO
22758: IFFALSE 22787
// AddResourceType ( base , i , sources [ i ] ) ;
22760: LD_VAR 0 15
22764: PPUSH
22765: LD_VAR 0 8
22769: PPUSH
22770: LD_VAR 0 5
22774: PUSH
22775: LD_VAR 0 8
22779: ARRAY
22780: PPUSH
22781: CALL_OW 276
22785: GO 22757
22787: POP
22788: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
22789: LD_ADDR_VAR 0 18
22793: PUSH
22794: LD_VAR 0 15
22798: PPUSH
22799: LD_VAR 0 2
22803: PPUSH
22804: LD_INT 1
22806: PPUSH
22807: CALL 22049 0 3
22811: ST_TO_ADDR
// InitHc ;
22812: CALL_OW 19
// InitUc ;
22816: CALL_OW 18
// uc_side := side ;
22820: LD_ADDR_OWVAR 20
22824: PUSH
22825: LD_VAR 0 16
22829: ST_TO_ADDR
// uc_nation := nation ;
22830: LD_ADDR_OWVAR 21
22834: PUSH
22835: LD_VAR 0 17
22839: ST_TO_ADDR
// if buildings then
22840: LD_VAR 0 18
22844: IFFALSE 24166
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22846: LD_ADDR_VAR 0 19
22850: PUSH
22851: LD_VAR 0 18
22855: PPUSH
22856: LD_INT 2
22858: PUSH
22859: LD_INT 30
22861: PUSH
22862: LD_INT 29
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: PUSH
22869: LD_INT 30
22871: PUSH
22872: LD_INT 30
22874: PUSH
22875: EMPTY
22876: LIST
22877: LIST
22878: PUSH
22879: EMPTY
22880: LIST
22881: LIST
22882: LIST
22883: PPUSH
22884: CALL_OW 72
22888: ST_TO_ADDR
// if tmp then
22889: LD_VAR 0 19
22893: IFFALSE 22941
// for i in tmp do
22895: LD_ADDR_VAR 0 8
22899: PUSH
22900: LD_VAR 0 19
22904: PUSH
22905: FOR_IN
22906: IFFALSE 22939
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22908: LD_VAR 0 8
22912: PPUSH
22913: CALL_OW 250
22917: PPUSH
22918: LD_VAR 0 8
22922: PPUSH
22923: CALL_OW 251
22927: PPUSH
22928: LD_VAR 0 16
22932: PPUSH
22933: CALL_OW 441
22937: GO 22905
22939: POP
22940: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22941: LD_VAR 0 18
22945: PPUSH
22946: LD_INT 2
22948: PUSH
22949: LD_INT 30
22951: PUSH
22952: LD_INT 32
22954: PUSH
22955: EMPTY
22956: LIST
22957: LIST
22958: PUSH
22959: LD_INT 30
22961: PUSH
22962: LD_INT 33
22964: PUSH
22965: EMPTY
22966: LIST
22967: LIST
22968: PUSH
22969: EMPTY
22970: LIST
22971: LIST
22972: LIST
22973: PPUSH
22974: CALL_OW 72
22978: IFFALSE 23066
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22980: LD_ADDR_VAR 0 8
22984: PUSH
22985: LD_VAR 0 18
22989: PPUSH
22990: LD_INT 2
22992: PUSH
22993: LD_INT 30
22995: PUSH
22996: LD_INT 32
22998: PUSH
22999: EMPTY
23000: LIST
23001: LIST
23002: PUSH
23003: LD_INT 30
23005: PUSH
23006: LD_INT 33
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: PUSH
23013: EMPTY
23014: LIST
23015: LIST
23016: LIST
23017: PPUSH
23018: CALL_OW 72
23022: PUSH
23023: FOR_IN
23024: IFFALSE 23064
// begin if not GetBWeapon ( i ) then
23026: LD_VAR 0 8
23030: PPUSH
23031: CALL_OW 269
23035: NOT
23036: IFFALSE 23062
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
23038: LD_VAR 0 8
23042: PPUSH
23043: LD_VAR 0 8
23047: PPUSH
23048: LD_VAR 0 2
23052: PPUSH
23053: CALL 24312 0 2
23057: PPUSH
23058: CALL_OW 431
// end ;
23062: GO 23023
23064: POP
23065: POP
// end ; for i = 1 to personel do
23066: LD_ADDR_VAR 0 8
23070: PUSH
23071: DOUBLE
23072: LD_INT 1
23074: DEC
23075: ST_TO_ADDR
23076: LD_VAR 0 6
23080: PUSH
23081: FOR_TO
23082: IFFALSE 24146
// begin if i > 4 then
23084: LD_VAR 0 8
23088: PUSH
23089: LD_INT 4
23091: GREATER
23092: IFFALSE 23096
// break ;
23094: GO 24146
// case i of 1 :
23096: LD_VAR 0 8
23100: PUSH
23101: LD_INT 1
23103: DOUBLE
23104: EQUAL
23105: IFTRUE 23109
23107: GO 23189
23109: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23110: LD_ADDR_VAR 0 12
23114: PUSH
23115: LD_VAR 0 18
23119: PPUSH
23120: LD_INT 22
23122: PUSH
23123: LD_VAR 0 16
23127: PUSH
23128: EMPTY
23129: LIST
23130: LIST
23131: PUSH
23132: LD_INT 58
23134: PUSH
23135: EMPTY
23136: LIST
23137: PUSH
23138: LD_INT 2
23140: PUSH
23141: LD_INT 30
23143: PUSH
23144: LD_INT 32
23146: PUSH
23147: EMPTY
23148: LIST
23149: LIST
23150: PUSH
23151: LD_INT 30
23153: PUSH
23154: LD_INT 4
23156: PUSH
23157: EMPTY
23158: LIST
23159: LIST
23160: PUSH
23161: LD_INT 30
23163: PUSH
23164: LD_INT 5
23166: PUSH
23167: EMPTY
23168: LIST
23169: LIST
23170: PUSH
23171: EMPTY
23172: LIST
23173: LIST
23174: LIST
23175: LIST
23176: PUSH
23177: EMPTY
23178: LIST
23179: LIST
23180: LIST
23181: PPUSH
23182: CALL_OW 72
23186: ST_TO_ADDR
23187: GO 23411
23189: LD_INT 2
23191: DOUBLE
23192: EQUAL
23193: IFTRUE 23197
23195: GO 23259
23197: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23198: LD_ADDR_VAR 0 12
23202: PUSH
23203: LD_VAR 0 18
23207: PPUSH
23208: LD_INT 22
23210: PUSH
23211: LD_VAR 0 16
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: PUSH
23220: LD_INT 2
23222: PUSH
23223: LD_INT 30
23225: PUSH
23226: LD_INT 0
23228: PUSH
23229: EMPTY
23230: LIST
23231: LIST
23232: PUSH
23233: LD_INT 30
23235: PUSH
23236: LD_INT 1
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PUSH
23243: EMPTY
23244: LIST
23245: LIST
23246: LIST
23247: PUSH
23248: EMPTY
23249: LIST
23250: LIST
23251: PPUSH
23252: CALL_OW 72
23256: ST_TO_ADDR
23257: GO 23411
23259: LD_INT 3
23261: DOUBLE
23262: EQUAL
23263: IFTRUE 23267
23265: GO 23329
23267: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23268: LD_ADDR_VAR 0 12
23272: PUSH
23273: LD_VAR 0 18
23277: PPUSH
23278: LD_INT 22
23280: PUSH
23281: LD_VAR 0 16
23285: PUSH
23286: EMPTY
23287: LIST
23288: LIST
23289: PUSH
23290: LD_INT 2
23292: PUSH
23293: LD_INT 30
23295: PUSH
23296: LD_INT 2
23298: PUSH
23299: EMPTY
23300: LIST
23301: LIST
23302: PUSH
23303: LD_INT 30
23305: PUSH
23306: LD_INT 3
23308: PUSH
23309: EMPTY
23310: LIST
23311: LIST
23312: PUSH
23313: EMPTY
23314: LIST
23315: LIST
23316: LIST
23317: PUSH
23318: EMPTY
23319: LIST
23320: LIST
23321: PPUSH
23322: CALL_OW 72
23326: ST_TO_ADDR
23327: GO 23411
23329: LD_INT 4
23331: DOUBLE
23332: EQUAL
23333: IFTRUE 23337
23335: GO 23410
23337: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23338: LD_ADDR_VAR 0 12
23342: PUSH
23343: LD_VAR 0 18
23347: PPUSH
23348: LD_INT 22
23350: PUSH
23351: LD_VAR 0 16
23355: PUSH
23356: EMPTY
23357: LIST
23358: LIST
23359: PUSH
23360: LD_INT 2
23362: PUSH
23363: LD_INT 30
23365: PUSH
23366: LD_INT 6
23368: PUSH
23369: EMPTY
23370: LIST
23371: LIST
23372: PUSH
23373: LD_INT 30
23375: PUSH
23376: LD_INT 7
23378: PUSH
23379: EMPTY
23380: LIST
23381: LIST
23382: PUSH
23383: LD_INT 30
23385: PUSH
23386: LD_INT 8
23388: PUSH
23389: EMPTY
23390: LIST
23391: LIST
23392: PUSH
23393: EMPTY
23394: LIST
23395: LIST
23396: LIST
23397: LIST
23398: PUSH
23399: EMPTY
23400: LIST
23401: LIST
23402: PPUSH
23403: CALL_OW 72
23407: ST_TO_ADDR
23408: GO 23411
23410: POP
// if i = 1 then
23411: LD_VAR 0 8
23415: PUSH
23416: LD_INT 1
23418: EQUAL
23419: IFFALSE 23530
// begin tmp := [ ] ;
23421: LD_ADDR_VAR 0 19
23425: PUSH
23426: EMPTY
23427: ST_TO_ADDR
// for j in f do
23428: LD_ADDR_VAR 0 9
23432: PUSH
23433: LD_VAR 0 12
23437: PUSH
23438: FOR_IN
23439: IFFALSE 23512
// if GetBType ( j ) = b_bunker then
23441: LD_VAR 0 9
23445: PPUSH
23446: CALL_OW 266
23450: PUSH
23451: LD_INT 32
23453: EQUAL
23454: IFFALSE 23481
// tmp := Insert ( tmp , 1 , j ) else
23456: LD_ADDR_VAR 0 19
23460: PUSH
23461: LD_VAR 0 19
23465: PPUSH
23466: LD_INT 1
23468: PPUSH
23469: LD_VAR 0 9
23473: PPUSH
23474: CALL_OW 2
23478: ST_TO_ADDR
23479: GO 23510
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23481: LD_ADDR_VAR 0 19
23485: PUSH
23486: LD_VAR 0 19
23490: PPUSH
23491: LD_VAR 0 19
23495: PUSH
23496: LD_INT 1
23498: PLUS
23499: PPUSH
23500: LD_VAR 0 9
23504: PPUSH
23505: CALL_OW 2
23509: ST_TO_ADDR
23510: GO 23438
23512: POP
23513: POP
// if tmp then
23514: LD_VAR 0 19
23518: IFFALSE 23530
// f := tmp ;
23520: LD_ADDR_VAR 0 12
23524: PUSH
23525: LD_VAR 0 19
23529: ST_TO_ADDR
// end ; x := personel [ i ] ;
23530: LD_ADDR_VAR 0 13
23534: PUSH
23535: LD_VAR 0 6
23539: PUSH
23540: LD_VAR 0 8
23544: ARRAY
23545: ST_TO_ADDR
// if x = - 1 then
23546: LD_VAR 0 13
23550: PUSH
23551: LD_INT 1
23553: NEG
23554: EQUAL
23555: IFFALSE 23764
// begin for j in f do
23557: LD_ADDR_VAR 0 9
23561: PUSH
23562: LD_VAR 0 12
23566: PUSH
23567: FOR_IN
23568: IFFALSE 23760
// repeat InitHc ;
23570: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23574: LD_VAR 0 9
23578: PPUSH
23579: CALL_OW 266
23583: PUSH
23584: LD_INT 5
23586: EQUAL
23587: IFFALSE 23657
// begin if UnitsInside ( j ) < 3 then
23589: LD_VAR 0 9
23593: PPUSH
23594: CALL_OW 313
23598: PUSH
23599: LD_INT 3
23601: LESS
23602: IFFALSE 23638
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23604: LD_INT 0
23606: PPUSH
23607: LD_INT 5
23609: PUSH
23610: LD_INT 8
23612: PUSH
23613: LD_INT 9
23615: PUSH
23616: EMPTY
23617: LIST
23618: LIST
23619: LIST
23620: PUSH
23621: LD_VAR 0 17
23625: ARRAY
23626: PPUSH
23627: LD_VAR 0 4
23631: PPUSH
23632: CALL_OW 380
23636: GO 23655
// PrepareHuman ( false , i , skill ) ;
23638: LD_INT 0
23640: PPUSH
23641: LD_VAR 0 8
23645: PPUSH
23646: LD_VAR 0 4
23650: PPUSH
23651: CALL_OW 380
// end else
23655: GO 23674
// PrepareHuman ( false , i , skill ) ;
23657: LD_INT 0
23659: PPUSH
23660: LD_VAR 0 8
23664: PPUSH
23665: LD_VAR 0 4
23669: PPUSH
23670: CALL_OW 380
// un := CreateHuman ;
23674: LD_ADDR_VAR 0 14
23678: PUSH
23679: CALL_OW 44
23683: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23684: LD_ADDR_VAR 0 7
23688: PUSH
23689: LD_VAR 0 7
23693: PPUSH
23694: LD_INT 1
23696: PPUSH
23697: LD_VAR 0 14
23701: PPUSH
23702: CALL_OW 2
23706: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23707: LD_VAR 0 14
23711: PPUSH
23712: LD_VAR 0 9
23716: PPUSH
23717: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23721: LD_VAR 0 9
23725: PPUSH
23726: CALL_OW 313
23730: PUSH
23731: LD_INT 6
23733: EQUAL
23734: PUSH
23735: LD_VAR 0 9
23739: PPUSH
23740: CALL_OW 266
23744: PUSH
23745: LD_INT 32
23747: PUSH
23748: LD_INT 31
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: IN
23755: OR
23756: IFFALSE 23570
23758: GO 23567
23760: POP
23761: POP
// end else
23762: GO 24144
// for j = 1 to x do
23764: LD_ADDR_VAR 0 9
23768: PUSH
23769: DOUBLE
23770: LD_INT 1
23772: DEC
23773: ST_TO_ADDR
23774: LD_VAR 0 13
23778: PUSH
23779: FOR_TO
23780: IFFALSE 24142
// begin InitHc ;
23782: CALL_OW 19
// if not f then
23786: LD_VAR 0 12
23790: NOT
23791: IFFALSE 23880
// begin PrepareHuman ( false , i , skill ) ;
23793: LD_INT 0
23795: PPUSH
23796: LD_VAR 0 8
23800: PPUSH
23801: LD_VAR 0 4
23805: PPUSH
23806: CALL_OW 380
// un := CreateHuman ;
23810: LD_ADDR_VAR 0 14
23814: PUSH
23815: CALL_OW 44
23819: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23820: LD_ADDR_VAR 0 7
23824: PUSH
23825: LD_VAR 0 7
23829: PPUSH
23830: LD_INT 1
23832: PPUSH
23833: LD_VAR 0 14
23837: PPUSH
23838: CALL_OW 2
23842: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23843: LD_VAR 0 14
23847: PPUSH
23848: LD_VAR 0 1
23852: PPUSH
23853: CALL_OW 250
23857: PPUSH
23858: LD_VAR 0 1
23862: PPUSH
23863: CALL_OW 251
23867: PPUSH
23868: LD_INT 10
23870: PPUSH
23871: LD_INT 0
23873: PPUSH
23874: CALL_OW 50
// continue ;
23878: GO 23779
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23880: LD_VAR 0 12
23884: PUSH
23885: LD_INT 1
23887: ARRAY
23888: PPUSH
23889: CALL_OW 313
23893: PUSH
23894: LD_VAR 0 12
23898: PUSH
23899: LD_INT 1
23901: ARRAY
23902: PPUSH
23903: CALL_OW 266
23907: PUSH
23908: LD_INT 32
23910: PUSH
23911: LD_INT 31
23913: PUSH
23914: EMPTY
23915: LIST
23916: LIST
23917: IN
23918: AND
23919: PUSH
23920: LD_VAR 0 12
23924: PUSH
23925: LD_INT 1
23927: ARRAY
23928: PPUSH
23929: CALL_OW 313
23933: PUSH
23934: LD_INT 6
23936: EQUAL
23937: OR
23938: IFFALSE 23958
// f := Delete ( f , 1 ) ;
23940: LD_ADDR_VAR 0 12
23944: PUSH
23945: LD_VAR 0 12
23949: PPUSH
23950: LD_INT 1
23952: PPUSH
23953: CALL_OW 3
23957: ST_TO_ADDR
// if not f then
23958: LD_VAR 0 12
23962: NOT
23963: IFFALSE 23981
// begin x := x + 2 ;
23965: LD_ADDR_VAR 0 13
23969: PUSH
23970: LD_VAR 0 13
23974: PUSH
23975: LD_INT 2
23977: PLUS
23978: ST_TO_ADDR
// continue ;
23979: GO 23779
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23981: LD_VAR 0 12
23985: PUSH
23986: LD_INT 1
23988: ARRAY
23989: PPUSH
23990: CALL_OW 266
23994: PUSH
23995: LD_INT 5
23997: EQUAL
23998: IFFALSE 24072
// begin if UnitsInside ( f [ 1 ] ) < 3 then
24000: LD_VAR 0 12
24004: PUSH
24005: LD_INT 1
24007: ARRAY
24008: PPUSH
24009: CALL_OW 313
24013: PUSH
24014: LD_INT 3
24016: LESS
24017: IFFALSE 24053
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24019: LD_INT 0
24021: PPUSH
24022: LD_INT 5
24024: PUSH
24025: LD_INT 8
24027: PUSH
24028: LD_INT 9
24030: PUSH
24031: EMPTY
24032: LIST
24033: LIST
24034: LIST
24035: PUSH
24036: LD_VAR 0 17
24040: ARRAY
24041: PPUSH
24042: LD_VAR 0 4
24046: PPUSH
24047: CALL_OW 380
24051: GO 24070
// PrepareHuman ( false , i , skill ) ;
24053: LD_INT 0
24055: PPUSH
24056: LD_VAR 0 8
24060: PPUSH
24061: LD_VAR 0 4
24065: PPUSH
24066: CALL_OW 380
// end else
24070: GO 24089
// PrepareHuman ( false , i , skill ) ;
24072: LD_INT 0
24074: PPUSH
24075: LD_VAR 0 8
24079: PPUSH
24080: LD_VAR 0 4
24084: PPUSH
24085: CALL_OW 380
// un := CreateHuman ;
24089: LD_ADDR_VAR 0 14
24093: PUSH
24094: CALL_OW 44
24098: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24099: LD_ADDR_VAR 0 7
24103: PUSH
24104: LD_VAR 0 7
24108: PPUSH
24109: LD_INT 1
24111: PPUSH
24112: LD_VAR 0 14
24116: PPUSH
24117: CALL_OW 2
24121: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24122: LD_VAR 0 14
24126: PPUSH
24127: LD_VAR 0 12
24131: PUSH
24132: LD_INT 1
24134: ARRAY
24135: PPUSH
24136: CALL_OW 52
// end ;
24140: GO 23779
24142: POP
24143: POP
// end ;
24144: GO 23081
24146: POP
24147: POP
// result := result ^ buildings ;
24148: LD_ADDR_VAR 0 7
24152: PUSH
24153: LD_VAR 0 7
24157: PUSH
24158: LD_VAR 0 18
24162: ADD
24163: ST_TO_ADDR
// end else
24164: GO 24307
// begin for i = 1 to personel do
24166: LD_ADDR_VAR 0 8
24170: PUSH
24171: DOUBLE
24172: LD_INT 1
24174: DEC
24175: ST_TO_ADDR
24176: LD_VAR 0 6
24180: PUSH
24181: FOR_TO
24182: IFFALSE 24305
// begin if i > 4 then
24184: LD_VAR 0 8
24188: PUSH
24189: LD_INT 4
24191: GREATER
24192: IFFALSE 24196
// break ;
24194: GO 24305
// x := personel [ i ] ;
24196: LD_ADDR_VAR 0 13
24200: PUSH
24201: LD_VAR 0 6
24205: PUSH
24206: LD_VAR 0 8
24210: ARRAY
24211: ST_TO_ADDR
// if x = - 1 then
24212: LD_VAR 0 13
24216: PUSH
24217: LD_INT 1
24219: NEG
24220: EQUAL
24221: IFFALSE 24225
// continue ;
24223: GO 24181
// PrepareHuman ( false , i , skill ) ;
24225: LD_INT 0
24227: PPUSH
24228: LD_VAR 0 8
24232: PPUSH
24233: LD_VAR 0 4
24237: PPUSH
24238: CALL_OW 380
// un := CreateHuman ;
24242: LD_ADDR_VAR 0 14
24246: PUSH
24247: CALL_OW 44
24251: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24252: LD_VAR 0 14
24256: PPUSH
24257: LD_VAR 0 1
24261: PPUSH
24262: CALL_OW 250
24266: PPUSH
24267: LD_VAR 0 1
24271: PPUSH
24272: CALL_OW 251
24276: PPUSH
24277: LD_INT 10
24279: PPUSH
24280: LD_INT 0
24282: PPUSH
24283: CALL_OW 50
// result := result ^ un ;
24287: LD_ADDR_VAR 0 7
24291: PUSH
24292: LD_VAR 0 7
24296: PUSH
24297: LD_VAR 0 14
24301: ADD
24302: ST_TO_ADDR
// end ;
24303: GO 24181
24305: POP
24306: POP
// end ; end ;
24307: LD_VAR 0 7
24311: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24312: LD_INT 0
24314: PPUSH
24315: PPUSH
24316: PPUSH
24317: PPUSH
24318: PPUSH
24319: PPUSH
24320: PPUSH
24321: PPUSH
24322: PPUSH
24323: PPUSH
24324: PPUSH
24325: PPUSH
24326: PPUSH
24327: PPUSH
24328: PPUSH
24329: PPUSH
// result := false ;
24330: LD_ADDR_VAR 0 3
24334: PUSH
24335: LD_INT 0
24337: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24338: LD_VAR 0 1
24342: NOT
24343: PUSH
24344: LD_VAR 0 1
24348: PPUSH
24349: CALL_OW 266
24353: PUSH
24354: LD_INT 32
24356: PUSH
24357: LD_INT 33
24359: PUSH
24360: EMPTY
24361: LIST
24362: LIST
24363: IN
24364: NOT
24365: OR
24366: IFFALSE 24370
// exit ;
24368: GO 25509
// nat := GetNation ( tower ) ;
24370: LD_ADDR_VAR 0 12
24374: PUSH
24375: LD_VAR 0 1
24379: PPUSH
24380: CALL_OW 248
24384: ST_TO_ADDR
// side := GetSide ( tower ) ;
24385: LD_ADDR_VAR 0 16
24389: PUSH
24390: LD_VAR 0 1
24394: PPUSH
24395: CALL_OW 255
24399: ST_TO_ADDR
// x := GetX ( tower ) ;
24400: LD_ADDR_VAR 0 10
24404: PUSH
24405: LD_VAR 0 1
24409: PPUSH
24410: CALL_OW 250
24414: ST_TO_ADDR
// y := GetY ( tower ) ;
24415: LD_ADDR_VAR 0 11
24419: PUSH
24420: LD_VAR 0 1
24424: PPUSH
24425: CALL_OW 251
24429: ST_TO_ADDR
// if not x or not y then
24430: LD_VAR 0 10
24434: NOT
24435: PUSH
24436: LD_VAR 0 11
24440: NOT
24441: OR
24442: IFFALSE 24446
// exit ;
24444: GO 25509
// weapon := 0 ;
24446: LD_ADDR_VAR 0 18
24450: PUSH
24451: LD_INT 0
24453: ST_TO_ADDR
// fac_list := [ ] ;
24454: LD_ADDR_VAR 0 17
24458: PUSH
24459: EMPTY
24460: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
24461: LD_ADDR_VAR 0 6
24465: PUSH
24466: LD_VAR 0 1
24470: PPUSH
24471: CALL_OW 274
24475: PPUSH
24476: LD_VAR 0 2
24480: PPUSH
24481: LD_INT 0
24483: PPUSH
24484: CALL 22049 0 3
24488: PPUSH
24489: LD_INT 30
24491: PUSH
24492: LD_INT 3
24494: PUSH
24495: EMPTY
24496: LIST
24497: LIST
24498: PPUSH
24499: CALL_OW 72
24503: ST_TO_ADDR
// if not factories then
24504: LD_VAR 0 6
24508: NOT
24509: IFFALSE 24513
// exit ;
24511: GO 25509
// for i in factories do
24513: LD_ADDR_VAR 0 8
24517: PUSH
24518: LD_VAR 0 6
24522: PUSH
24523: FOR_IN
24524: IFFALSE 24549
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24526: LD_ADDR_VAR 0 17
24530: PUSH
24531: LD_VAR 0 17
24535: PUSH
24536: LD_VAR 0 8
24540: PPUSH
24541: CALL_OW 478
24545: UNION
24546: ST_TO_ADDR
24547: GO 24523
24549: POP
24550: POP
// if not fac_list then
24551: LD_VAR 0 17
24555: NOT
24556: IFFALSE 24560
// exit ;
24558: GO 25509
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24560: LD_ADDR_VAR 0 5
24564: PUSH
24565: LD_INT 4
24567: PUSH
24568: LD_INT 5
24570: PUSH
24571: LD_INT 9
24573: PUSH
24574: LD_INT 10
24576: PUSH
24577: LD_INT 6
24579: PUSH
24580: LD_INT 7
24582: PUSH
24583: LD_INT 11
24585: PUSH
24586: EMPTY
24587: LIST
24588: LIST
24589: LIST
24590: LIST
24591: LIST
24592: LIST
24593: LIST
24594: PUSH
24595: LD_INT 27
24597: PUSH
24598: LD_INT 28
24600: PUSH
24601: LD_INT 26
24603: PUSH
24604: LD_INT 30
24606: PUSH
24607: EMPTY
24608: LIST
24609: LIST
24610: LIST
24611: LIST
24612: PUSH
24613: LD_INT 43
24615: PUSH
24616: LD_INT 44
24618: PUSH
24619: LD_INT 46
24621: PUSH
24622: LD_INT 45
24624: PUSH
24625: LD_INT 47
24627: PUSH
24628: LD_INT 49
24630: PUSH
24631: EMPTY
24632: LIST
24633: LIST
24634: LIST
24635: LIST
24636: LIST
24637: LIST
24638: PUSH
24639: EMPTY
24640: LIST
24641: LIST
24642: LIST
24643: PUSH
24644: LD_VAR 0 12
24648: ARRAY
24649: ST_TO_ADDR
// for i in list do
24650: LD_ADDR_VAR 0 8
24654: PUSH
24655: LD_VAR 0 5
24659: PUSH
24660: FOR_IN
24661: IFFALSE 24694
// if not i in fac_list then
24663: LD_VAR 0 8
24667: PUSH
24668: LD_VAR 0 17
24672: IN
24673: NOT
24674: IFFALSE 24692
// list := list diff i ;
24676: LD_ADDR_VAR 0 5
24680: PUSH
24681: LD_VAR 0 5
24685: PUSH
24686: LD_VAR 0 8
24690: DIFF
24691: ST_TO_ADDR
24692: GO 24660
24694: POP
24695: POP
// if not list then
24696: LD_VAR 0 5
24700: NOT
24701: IFFALSE 24705
// exit ;
24703: GO 25509
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24705: LD_VAR 0 12
24709: PUSH
24710: LD_INT 3
24712: EQUAL
24713: PUSH
24714: LD_INT 49
24716: PUSH
24717: LD_VAR 0 5
24721: IN
24722: AND
24723: PUSH
24724: LD_INT 31
24726: PPUSH
24727: LD_VAR 0 16
24731: PPUSH
24732: CALL_OW 321
24736: PUSH
24737: LD_INT 2
24739: EQUAL
24740: AND
24741: IFFALSE 24801
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24743: LD_INT 22
24745: PUSH
24746: LD_VAR 0 16
24750: PUSH
24751: EMPTY
24752: LIST
24753: LIST
24754: PUSH
24755: LD_INT 35
24757: PUSH
24758: LD_INT 49
24760: PUSH
24761: EMPTY
24762: LIST
24763: LIST
24764: PUSH
24765: LD_INT 91
24767: PUSH
24768: LD_VAR 0 1
24772: PUSH
24773: LD_INT 10
24775: PUSH
24776: EMPTY
24777: LIST
24778: LIST
24779: LIST
24780: PUSH
24781: EMPTY
24782: LIST
24783: LIST
24784: LIST
24785: PPUSH
24786: CALL_OW 69
24790: NOT
24791: IFFALSE 24801
// weapon := ru_time_lapser ;
24793: LD_ADDR_VAR 0 18
24797: PUSH
24798: LD_INT 49
24800: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24801: LD_VAR 0 12
24805: PUSH
24806: LD_INT 1
24808: PUSH
24809: LD_INT 2
24811: PUSH
24812: EMPTY
24813: LIST
24814: LIST
24815: IN
24816: PUSH
24817: LD_INT 11
24819: PUSH
24820: LD_VAR 0 5
24824: IN
24825: PUSH
24826: LD_INT 30
24828: PUSH
24829: LD_VAR 0 5
24833: IN
24834: OR
24835: AND
24836: PUSH
24837: LD_INT 6
24839: PPUSH
24840: LD_VAR 0 16
24844: PPUSH
24845: CALL_OW 321
24849: PUSH
24850: LD_INT 2
24852: EQUAL
24853: AND
24854: IFFALSE 25019
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24856: LD_INT 22
24858: PUSH
24859: LD_VAR 0 16
24863: PUSH
24864: EMPTY
24865: LIST
24866: LIST
24867: PUSH
24868: LD_INT 2
24870: PUSH
24871: LD_INT 35
24873: PUSH
24874: LD_INT 11
24876: PUSH
24877: EMPTY
24878: LIST
24879: LIST
24880: PUSH
24881: LD_INT 35
24883: PUSH
24884: LD_INT 30
24886: PUSH
24887: EMPTY
24888: LIST
24889: LIST
24890: PUSH
24891: EMPTY
24892: LIST
24893: LIST
24894: LIST
24895: PUSH
24896: LD_INT 91
24898: PUSH
24899: LD_VAR 0 1
24903: PUSH
24904: LD_INT 18
24906: PUSH
24907: EMPTY
24908: LIST
24909: LIST
24910: LIST
24911: PUSH
24912: EMPTY
24913: LIST
24914: LIST
24915: LIST
24916: PPUSH
24917: CALL_OW 69
24921: NOT
24922: PUSH
24923: LD_INT 22
24925: PUSH
24926: LD_VAR 0 16
24930: PUSH
24931: EMPTY
24932: LIST
24933: LIST
24934: PUSH
24935: LD_INT 2
24937: PUSH
24938: LD_INT 30
24940: PUSH
24941: LD_INT 32
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: LD_INT 30
24950: PUSH
24951: LD_INT 33
24953: PUSH
24954: EMPTY
24955: LIST
24956: LIST
24957: PUSH
24958: EMPTY
24959: LIST
24960: LIST
24961: LIST
24962: PUSH
24963: LD_INT 91
24965: PUSH
24966: LD_VAR 0 1
24970: PUSH
24971: LD_INT 12
24973: PUSH
24974: EMPTY
24975: LIST
24976: LIST
24977: LIST
24978: PUSH
24979: EMPTY
24980: LIST
24981: LIST
24982: LIST
24983: PUSH
24984: EMPTY
24985: LIST
24986: PPUSH
24987: CALL_OW 69
24991: PUSH
24992: LD_INT 2
24994: GREATER
24995: AND
24996: IFFALSE 25019
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24998: LD_ADDR_VAR 0 18
25002: PUSH
25003: LD_INT 11
25005: PUSH
25006: LD_INT 30
25008: PUSH
25009: EMPTY
25010: LIST
25011: LIST
25012: PUSH
25013: LD_VAR 0 12
25017: ARRAY
25018: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
25019: LD_VAR 0 18
25023: NOT
25024: PUSH
25025: LD_INT 40
25027: PPUSH
25028: LD_VAR 0 16
25032: PPUSH
25033: CALL_OW 321
25037: PUSH
25038: LD_INT 2
25040: EQUAL
25041: AND
25042: PUSH
25043: LD_INT 7
25045: PUSH
25046: LD_VAR 0 5
25050: IN
25051: PUSH
25052: LD_INT 28
25054: PUSH
25055: LD_VAR 0 5
25059: IN
25060: OR
25061: PUSH
25062: LD_INT 45
25064: PUSH
25065: LD_VAR 0 5
25069: IN
25070: OR
25071: AND
25072: IFFALSE 25326
// begin hex := GetHexInfo ( x , y ) ;
25074: LD_ADDR_VAR 0 4
25078: PUSH
25079: LD_VAR 0 10
25083: PPUSH
25084: LD_VAR 0 11
25088: PPUSH
25089: CALL_OW 546
25093: ST_TO_ADDR
// if hex [ 1 ] then
25094: LD_VAR 0 4
25098: PUSH
25099: LD_INT 1
25101: ARRAY
25102: IFFALSE 25106
// exit ;
25104: GO 25509
// height := hex [ 2 ] ;
25106: LD_ADDR_VAR 0 15
25110: PUSH
25111: LD_VAR 0 4
25115: PUSH
25116: LD_INT 2
25118: ARRAY
25119: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25120: LD_ADDR_VAR 0 14
25124: PUSH
25125: LD_INT 0
25127: PUSH
25128: LD_INT 2
25130: PUSH
25131: LD_INT 3
25133: PUSH
25134: LD_INT 5
25136: PUSH
25137: EMPTY
25138: LIST
25139: LIST
25140: LIST
25141: LIST
25142: ST_TO_ADDR
// for i in tmp do
25143: LD_ADDR_VAR 0 8
25147: PUSH
25148: LD_VAR 0 14
25152: PUSH
25153: FOR_IN
25154: IFFALSE 25324
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25156: LD_ADDR_VAR 0 9
25160: PUSH
25161: LD_VAR 0 10
25165: PPUSH
25166: LD_VAR 0 8
25170: PPUSH
25171: LD_INT 5
25173: PPUSH
25174: CALL_OW 272
25178: PUSH
25179: LD_VAR 0 11
25183: PPUSH
25184: LD_VAR 0 8
25188: PPUSH
25189: LD_INT 5
25191: PPUSH
25192: CALL_OW 273
25196: PUSH
25197: EMPTY
25198: LIST
25199: LIST
25200: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25201: LD_VAR 0 9
25205: PUSH
25206: LD_INT 1
25208: ARRAY
25209: PPUSH
25210: LD_VAR 0 9
25214: PUSH
25215: LD_INT 2
25217: ARRAY
25218: PPUSH
25219: CALL_OW 488
25223: IFFALSE 25322
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25225: LD_ADDR_VAR 0 4
25229: PUSH
25230: LD_VAR 0 9
25234: PUSH
25235: LD_INT 1
25237: ARRAY
25238: PPUSH
25239: LD_VAR 0 9
25243: PUSH
25244: LD_INT 2
25246: ARRAY
25247: PPUSH
25248: CALL_OW 546
25252: ST_TO_ADDR
// if hex [ 1 ] then
25253: LD_VAR 0 4
25257: PUSH
25258: LD_INT 1
25260: ARRAY
25261: IFFALSE 25265
// continue ;
25263: GO 25153
// h := hex [ 2 ] ;
25265: LD_ADDR_VAR 0 13
25269: PUSH
25270: LD_VAR 0 4
25274: PUSH
25275: LD_INT 2
25277: ARRAY
25278: ST_TO_ADDR
// if h + 7 < height then
25279: LD_VAR 0 13
25283: PUSH
25284: LD_INT 7
25286: PLUS
25287: PUSH
25288: LD_VAR 0 15
25292: LESS
25293: IFFALSE 25322
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25295: LD_ADDR_VAR 0 18
25299: PUSH
25300: LD_INT 7
25302: PUSH
25303: LD_INT 28
25305: PUSH
25306: LD_INT 45
25308: PUSH
25309: EMPTY
25310: LIST
25311: LIST
25312: LIST
25313: PUSH
25314: LD_VAR 0 12
25318: ARRAY
25319: ST_TO_ADDR
// break ;
25320: GO 25324
// end ; end ; end ;
25322: GO 25153
25324: POP
25325: POP
// end ; if not weapon then
25326: LD_VAR 0 18
25330: NOT
25331: IFFALSE 25391
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25333: LD_ADDR_VAR 0 5
25337: PUSH
25338: LD_VAR 0 5
25342: PUSH
25343: LD_INT 11
25345: PUSH
25346: LD_INT 30
25348: PUSH
25349: LD_INT 49
25351: PUSH
25352: EMPTY
25353: LIST
25354: LIST
25355: LIST
25356: DIFF
25357: ST_TO_ADDR
// if not list then
25358: LD_VAR 0 5
25362: NOT
25363: IFFALSE 25367
// exit ;
25365: GO 25509
// weapon := list [ rand ( 1 , list ) ] ;
25367: LD_ADDR_VAR 0 18
25371: PUSH
25372: LD_VAR 0 5
25376: PUSH
25377: LD_INT 1
25379: PPUSH
25380: LD_VAR 0 5
25384: PPUSH
25385: CALL_OW 12
25389: ARRAY
25390: ST_TO_ADDR
// end ; if weapon then
25391: LD_VAR 0 18
25395: IFFALSE 25509
// begin tmp := CostOfWeapon ( weapon ) ;
25397: LD_ADDR_VAR 0 14
25401: PUSH
25402: LD_VAR 0 18
25406: PPUSH
25407: CALL_OW 451
25411: ST_TO_ADDR
// j := GetBase ( tower ) ;
25412: LD_ADDR_VAR 0 9
25416: PUSH
25417: LD_VAR 0 1
25421: PPUSH
25422: CALL_OW 274
25426: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25427: LD_VAR 0 9
25431: PPUSH
25432: LD_INT 1
25434: PPUSH
25435: CALL_OW 275
25439: PUSH
25440: LD_VAR 0 14
25444: PUSH
25445: LD_INT 1
25447: ARRAY
25448: GREATEREQUAL
25449: PUSH
25450: LD_VAR 0 9
25454: PPUSH
25455: LD_INT 2
25457: PPUSH
25458: CALL_OW 275
25462: PUSH
25463: LD_VAR 0 14
25467: PUSH
25468: LD_INT 2
25470: ARRAY
25471: GREATEREQUAL
25472: AND
25473: PUSH
25474: LD_VAR 0 9
25478: PPUSH
25479: LD_INT 3
25481: PPUSH
25482: CALL_OW 275
25486: PUSH
25487: LD_VAR 0 14
25491: PUSH
25492: LD_INT 3
25494: ARRAY
25495: GREATEREQUAL
25496: AND
25497: IFFALSE 25509
// result := weapon ;
25499: LD_ADDR_VAR 0 3
25503: PUSH
25504: LD_VAR 0 18
25508: ST_TO_ADDR
// end ; end ;
25509: LD_VAR 0 3
25513: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25514: LD_INT 0
25516: PPUSH
25517: PPUSH
// result := true ;
25518: LD_ADDR_VAR 0 3
25522: PUSH
25523: LD_INT 1
25525: ST_TO_ADDR
// if array1 = array2 then
25526: LD_VAR 0 1
25530: PUSH
25531: LD_VAR 0 2
25535: EQUAL
25536: IFFALSE 25596
// begin for i = 1 to array1 do
25538: LD_ADDR_VAR 0 4
25542: PUSH
25543: DOUBLE
25544: LD_INT 1
25546: DEC
25547: ST_TO_ADDR
25548: LD_VAR 0 1
25552: PUSH
25553: FOR_TO
25554: IFFALSE 25592
// if array1 [ i ] <> array2 [ i ] then
25556: LD_VAR 0 1
25560: PUSH
25561: LD_VAR 0 4
25565: ARRAY
25566: PUSH
25567: LD_VAR 0 2
25571: PUSH
25572: LD_VAR 0 4
25576: ARRAY
25577: NONEQUAL
25578: IFFALSE 25590
// begin result := false ;
25580: LD_ADDR_VAR 0 3
25584: PUSH
25585: LD_INT 0
25587: ST_TO_ADDR
// break ;
25588: GO 25592
// end ;
25590: GO 25553
25592: POP
25593: POP
// end else
25594: GO 25604
// result := false ;
25596: LD_ADDR_VAR 0 3
25600: PUSH
25601: LD_INT 0
25603: ST_TO_ADDR
// end ;
25604: LD_VAR 0 3
25608: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
25609: LD_INT 0
25611: PPUSH
25612: PPUSH
// if not array1 or not array2 then
25613: LD_VAR 0 1
25617: NOT
25618: PUSH
25619: LD_VAR 0 2
25623: NOT
25624: OR
25625: IFFALSE 25629
// exit ;
25627: GO 25693
// result := true ;
25629: LD_ADDR_VAR 0 3
25633: PUSH
25634: LD_INT 1
25636: ST_TO_ADDR
// for i = 1 to array1 do
25637: LD_ADDR_VAR 0 4
25641: PUSH
25642: DOUBLE
25643: LD_INT 1
25645: DEC
25646: ST_TO_ADDR
25647: LD_VAR 0 1
25651: PUSH
25652: FOR_TO
25653: IFFALSE 25691
// if array1 [ i ] <> array2 [ i ] then
25655: LD_VAR 0 1
25659: PUSH
25660: LD_VAR 0 4
25664: ARRAY
25665: PUSH
25666: LD_VAR 0 2
25670: PUSH
25671: LD_VAR 0 4
25675: ARRAY
25676: NONEQUAL
25677: IFFALSE 25689
// begin result := false ;
25679: LD_ADDR_VAR 0 3
25683: PUSH
25684: LD_INT 0
25686: ST_TO_ADDR
// break ;
25687: GO 25691
// end ;
25689: GO 25652
25691: POP
25692: POP
// end ;
25693: LD_VAR 0 3
25697: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25698: LD_INT 0
25700: PPUSH
25701: PPUSH
25702: PPUSH
// pom := GetBase ( fac ) ;
25703: LD_ADDR_VAR 0 5
25707: PUSH
25708: LD_VAR 0 1
25712: PPUSH
25713: CALL_OW 274
25717: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25718: LD_ADDR_VAR 0 4
25722: PUSH
25723: LD_VAR 0 2
25727: PUSH
25728: LD_INT 1
25730: ARRAY
25731: PPUSH
25732: LD_VAR 0 2
25736: PUSH
25737: LD_INT 2
25739: ARRAY
25740: PPUSH
25741: LD_VAR 0 2
25745: PUSH
25746: LD_INT 3
25748: ARRAY
25749: PPUSH
25750: LD_VAR 0 2
25754: PUSH
25755: LD_INT 4
25757: ARRAY
25758: PPUSH
25759: CALL_OW 449
25763: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25764: LD_ADDR_VAR 0 3
25768: PUSH
25769: LD_VAR 0 5
25773: PPUSH
25774: LD_INT 1
25776: PPUSH
25777: CALL_OW 275
25781: PUSH
25782: LD_VAR 0 4
25786: PUSH
25787: LD_INT 1
25789: ARRAY
25790: GREATEREQUAL
25791: PUSH
25792: LD_VAR 0 5
25796: PPUSH
25797: LD_INT 2
25799: PPUSH
25800: CALL_OW 275
25804: PUSH
25805: LD_VAR 0 4
25809: PUSH
25810: LD_INT 2
25812: ARRAY
25813: GREATEREQUAL
25814: AND
25815: PUSH
25816: LD_VAR 0 5
25820: PPUSH
25821: LD_INT 3
25823: PPUSH
25824: CALL_OW 275
25828: PUSH
25829: LD_VAR 0 4
25833: PUSH
25834: LD_INT 3
25836: ARRAY
25837: GREATEREQUAL
25838: AND
25839: ST_TO_ADDR
// end ;
25840: LD_VAR 0 3
25844: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25845: LD_INT 0
25847: PPUSH
25848: PPUSH
25849: PPUSH
25850: PPUSH
// pom := GetBase ( building ) ;
25851: LD_ADDR_VAR 0 3
25855: PUSH
25856: LD_VAR 0 1
25860: PPUSH
25861: CALL_OW 274
25865: ST_TO_ADDR
// if not pom then
25866: LD_VAR 0 3
25870: NOT
25871: IFFALSE 25875
// exit ;
25873: GO 26045
// btype := GetBType ( building ) ;
25875: LD_ADDR_VAR 0 5
25879: PUSH
25880: LD_VAR 0 1
25884: PPUSH
25885: CALL_OW 266
25889: ST_TO_ADDR
// if btype = b_armoury then
25890: LD_VAR 0 5
25894: PUSH
25895: LD_INT 4
25897: EQUAL
25898: IFFALSE 25908
// btype := b_barracks ;
25900: LD_ADDR_VAR 0 5
25904: PUSH
25905: LD_INT 5
25907: ST_TO_ADDR
// if btype = b_depot then
25908: LD_VAR 0 5
25912: PUSH
25913: LD_INT 0
25915: EQUAL
25916: IFFALSE 25926
// btype := b_warehouse ;
25918: LD_ADDR_VAR 0 5
25922: PUSH
25923: LD_INT 1
25925: ST_TO_ADDR
// if btype = b_workshop then
25926: LD_VAR 0 5
25930: PUSH
25931: LD_INT 2
25933: EQUAL
25934: IFFALSE 25944
// btype := b_factory ;
25936: LD_ADDR_VAR 0 5
25940: PUSH
25941: LD_INT 3
25943: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25944: LD_ADDR_VAR 0 4
25948: PUSH
25949: LD_VAR 0 5
25953: PPUSH
25954: LD_VAR 0 1
25958: PPUSH
25959: CALL_OW 248
25963: PPUSH
25964: CALL_OW 450
25968: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25969: LD_ADDR_VAR 0 2
25973: PUSH
25974: LD_VAR 0 3
25978: PPUSH
25979: LD_INT 1
25981: PPUSH
25982: CALL_OW 275
25986: PUSH
25987: LD_VAR 0 4
25991: PUSH
25992: LD_INT 1
25994: ARRAY
25995: GREATEREQUAL
25996: PUSH
25997: LD_VAR 0 3
26001: PPUSH
26002: LD_INT 2
26004: PPUSH
26005: CALL_OW 275
26009: PUSH
26010: LD_VAR 0 4
26014: PUSH
26015: LD_INT 2
26017: ARRAY
26018: GREATEREQUAL
26019: AND
26020: PUSH
26021: LD_VAR 0 3
26025: PPUSH
26026: LD_INT 3
26028: PPUSH
26029: CALL_OW 275
26033: PUSH
26034: LD_VAR 0 4
26038: PUSH
26039: LD_INT 3
26041: ARRAY
26042: GREATEREQUAL
26043: AND
26044: ST_TO_ADDR
// end ;
26045: LD_VAR 0 2
26049: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
26050: LD_INT 0
26052: PPUSH
26053: PPUSH
26054: PPUSH
// pom := GetBase ( building ) ;
26055: LD_ADDR_VAR 0 4
26059: PUSH
26060: LD_VAR 0 1
26064: PPUSH
26065: CALL_OW 274
26069: ST_TO_ADDR
// if not pom then
26070: LD_VAR 0 4
26074: NOT
26075: IFFALSE 26079
// exit ;
26077: GO 26180
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
26079: LD_ADDR_VAR 0 5
26083: PUSH
26084: LD_VAR 0 2
26088: PPUSH
26089: LD_VAR 0 1
26093: PPUSH
26094: CALL_OW 248
26098: PPUSH
26099: CALL_OW 450
26103: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26104: LD_ADDR_VAR 0 3
26108: PUSH
26109: LD_VAR 0 4
26113: PPUSH
26114: LD_INT 1
26116: PPUSH
26117: CALL_OW 275
26121: PUSH
26122: LD_VAR 0 5
26126: PUSH
26127: LD_INT 1
26129: ARRAY
26130: GREATEREQUAL
26131: PUSH
26132: LD_VAR 0 4
26136: PPUSH
26137: LD_INT 2
26139: PPUSH
26140: CALL_OW 275
26144: PUSH
26145: LD_VAR 0 5
26149: PUSH
26150: LD_INT 2
26152: ARRAY
26153: GREATEREQUAL
26154: AND
26155: PUSH
26156: LD_VAR 0 4
26160: PPUSH
26161: LD_INT 3
26163: PPUSH
26164: CALL_OW 275
26168: PUSH
26169: LD_VAR 0 5
26173: PUSH
26174: LD_INT 3
26176: ARRAY
26177: GREATEREQUAL
26178: AND
26179: ST_TO_ADDR
// end ;
26180: LD_VAR 0 3
26184: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
26185: LD_INT 0
26187: PPUSH
26188: PPUSH
26189: PPUSH
26190: PPUSH
26191: PPUSH
26192: PPUSH
26193: PPUSH
26194: PPUSH
26195: PPUSH
26196: PPUSH
26197: PPUSH
// result := false ;
26198: LD_ADDR_VAR 0 8
26202: PUSH
26203: LD_INT 0
26205: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
26206: LD_VAR 0 5
26210: NOT
26211: PUSH
26212: LD_VAR 0 1
26216: NOT
26217: OR
26218: PUSH
26219: LD_VAR 0 2
26223: NOT
26224: OR
26225: PUSH
26226: LD_VAR 0 3
26230: NOT
26231: OR
26232: IFFALSE 26236
// exit ;
26234: GO 27050
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
26236: LD_ADDR_VAR 0 14
26240: PUSH
26241: LD_VAR 0 1
26245: PPUSH
26246: LD_VAR 0 2
26250: PPUSH
26251: LD_VAR 0 3
26255: PPUSH
26256: LD_VAR 0 4
26260: PPUSH
26261: LD_VAR 0 5
26265: PUSH
26266: LD_INT 1
26268: ARRAY
26269: PPUSH
26270: CALL_OW 248
26274: PPUSH
26275: LD_INT 0
26277: PPUSH
26278: CALL 27887 0 6
26282: ST_TO_ADDR
// if not hexes then
26283: LD_VAR 0 14
26287: NOT
26288: IFFALSE 26292
// exit ;
26290: GO 27050
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26292: LD_ADDR_VAR 0 17
26296: PUSH
26297: LD_VAR 0 5
26301: PPUSH
26302: LD_INT 22
26304: PUSH
26305: LD_VAR 0 13
26309: PPUSH
26310: CALL_OW 255
26314: PUSH
26315: EMPTY
26316: LIST
26317: LIST
26318: PUSH
26319: LD_INT 2
26321: PUSH
26322: LD_INT 30
26324: PUSH
26325: LD_INT 0
26327: PUSH
26328: EMPTY
26329: LIST
26330: LIST
26331: PUSH
26332: LD_INT 30
26334: PUSH
26335: LD_INT 1
26337: PUSH
26338: EMPTY
26339: LIST
26340: LIST
26341: PUSH
26342: EMPTY
26343: LIST
26344: LIST
26345: LIST
26346: PUSH
26347: EMPTY
26348: LIST
26349: LIST
26350: PPUSH
26351: CALL_OW 72
26355: ST_TO_ADDR
// for i = 1 to hexes do
26356: LD_ADDR_VAR 0 9
26360: PUSH
26361: DOUBLE
26362: LD_INT 1
26364: DEC
26365: ST_TO_ADDR
26366: LD_VAR 0 14
26370: PUSH
26371: FOR_TO
26372: IFFALSE 27048
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26374: LD_ADDR_VAR 0 13
26378: PUSH
26379: LD_VAR 0 14
26383: PUSH
26384: LD_VAR 0 9
26388: ARRAY
26389: PUSH
26390: LD_INT 1
26392: ARRAY
26393: PPUSH
26394: LD_VAR 0 14
26398: PUSH
26399: LD_VAR 0 9
26403: ARRAY
26404: PUSH
26405: LD_INT 2
26407: ARRAY
26408: PPUSH
26409: CALL_OW 428
26413: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26414: LD_VAR 0 14
26418: PUSH
26419: LD_VAR 0 9
26423: ARRAY
26424: PUSH
26425: LD_INT 1
26427: ARRAY
26428: PPUSH
26429: LD_VAR 0 14
26433: PUSH
26434: LD_VAR 0 9
26438: ARRAY
26439: PUSH
26440: LD_INT 2
26442: ARRAY
26443: PPUSH
26444: CALL_OW 351
26448: PUSH
26449: LD_VAR 0 14
26453: PUSH
26454: LD_VAR 0 9
26458: ARRAY
26459: PUSH
26460: LD_INT 1
26462: ARRAY
26463: PPUSH
26464: LD_VAR 0 14
26468: PUSH
26469: LD_VAR 0 9
26473: ARRAY
26474: PUSH
26475: LD_INT 2
26477: ARRAY
26478: PPUSH
26479: CALL_OW 488
26483: NOT
26484: OR
26485: PUSH
26486: LD_VAR 0 13
26490: PPUSH
26491: CALL_OW 247
26495: PUSH
26496: LD_INT 3
26498: EQUAL
26499: OR
26500: IFFALSE 26506
// exit ;
26502: POP
26503: POP
26504: GO 27050
// if not tmp then
26506: LD_VAR 0 13
26510: NOT
26511: IFFALSE 26515
// continue ;
26513: GO 26371
// result := true ;
26515: LD_ADDR_VAR 0 8
26519: PUSH
26520: LD_INT 1
26522: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
26523: LD_VAR 0 6
26527: PUSH
26528: LD_VAR 0 13
26532: PPUSH
26533: CALL_OW 247
26537: PUSH
26538: LD_INT 2
26540: EQUAL
26541: AND
26542: PUSH
26543: LD_VAR 0 13
26547: PPUSH
26548: CALL_OW 263
26552: PUSH
26553: LD_INT 1
26555: EQUAL
26556: AND
26557: IFFALSE 26721
// begin if IsDrivenBy ( tmp ) then
26559: LD_VAR 0 13
26563: PPUSH
26564: CALL_OW 311
26568: IFFALSE 26572
// continue ;
26570: GO 26371
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
26572: LD_VAR 0 6
26576: PPUSH
26577: LD_INT 3
26579: PUSH
26580: LD_INT 60
26582: PUSH
26583: EMPTY
26584: LIST
26585: PUSH
26586: EMPTY
26587: LIST
26588: LIST
26589: PUSH
26590: LD_INT 3
26592: PUSH
26593: LD_INT 55
26595: PUSH
26596: EMPTY
26597: LIST
26598: PUSH
26599: EMPTY
26600: LIST
26601: LIST
26602: PUSH
26603: EMPTY
26604: LIST
26605: LIST
26606: PPUSH
26607: CALL_OW 72
26611: IFFALSE 26719
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
26613: LD_ADDR_VAR 0 18
26617: PUSH
26618: LD_VAR 0 6
26622: PPUSH
26623: LD_INT 3
26625: PUSH
26626: LD_INT 60
26628: PUSH
26629: EMPTY
26630: LIST
26631: PUSH
26632: EMPTY
26633: LIST
26634: LIST
26635: PUSH
26636: LD_INT 3
26638: PUSH
26639: LD_INT 55
26641: PUSH
26642: EMPTY
26643: LIST
26644: PUSH
26645: EMPTY
26646: LIST
26647: LIST
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PPUSH
26653: CALL_OW 72
26657: PUSH
26658: LD_INT 1
26660: ARRAY
26661: ST_TO_ADDR
// if IsInUnit ( driver ) then
26662: LD_VAR 0 18
26666: PPUSH
26667: CALL_OW 310
26671: IFFALSE 26682
// ComExit ( driver ) ;
26673: LD_VAR 0 18
26677: PPUSH
26678: CALL 51071 0 1
// AddComEnterUnit ( driver , tmp ) ;
26682: LD_VAR 0 18
26686: PPUSH
26687: LD_VAR 0 13
26691: PPUSH
26692: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
26696: LD_VAR 0 18
26700: PPUSH
26701: LD_VAR 0 7
26705: PPUSH
26706: CALL_OW 173
// AddComExitVehicle ( driver ) ;
26710: LD_VAR 0 18
26714: PPUSH
26715: CALL_OW 181
// end ; continue ;
26719: GO 26371
// end ; if not cleaners or not tmp in cleaners then
26721: LD_VAR 0 6
26725: NOT
26726: PUSH
26727: LD_VAR 0 13
26731: PUSH
26732: LD_VAR 0 6
26736: IN
26737: NOT
26738: OR
26739: IFFALSE 27046
// begin if dep then
26741: LD_VAR 0 17
26745: IFFALSE 26881
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26747: LD_ADDR_VAR 0 16
26751: PUSH
26752: LD_VAR 0 17
26756: PUSH
26757: LD_INT 1
26759: ARRAY
26760: PPUSH
26761: CALL_OW 250
26765: PPUSH
26766: LD_VAR 0 17
26770: PUSH
26771: LD_INT 1
26773: ARRAY
26774: PPUSH
26775: CALL_OW 254
26779: PPUSH
26780: LD_INT 5
26782: PPUSH
26783: CALL_OW 272
26787: PUSH
26788: LD_VAR 0 17
26792: PUSH
26793: LD_INT 1
26795: ARRAY
26796: PPUSH
26797: CALL_OW 251
26801: PPUSH
26802: LD_VAR 0 17
26806: PUSH
26807: LD_INT 1
26809: ARRAY
26810: PPUSH
26811: CALL_OW 254
26815: PPUSH
26816: LD_INT 5
26818: PPUSH
26819: CALL_OW 273
26823: PUSH
26824: EMPTY
26825: LIST
26826: LIST
26827: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26828: LD_VAR 0 16
26832: PUSH
26833: LD_INT 1
26835: ARRAY
26836: PPUSH
26837: LD_VAR 0 16
26841: PUSH
26842: LD_INT 2
26844: ARRAY
26845: PPUSH
26846: CALL_OW 488
26850: IFFALSE 26881
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26852: LD_VAR 0 13
26856: PPUSH
26857: LD_VAR 0 16
26861: PUSH
26862: LD_INT 1
26864: ARRAY
26865: PPUSH
26866: LD_VAR 0 16
26870: PUSH
26871: LD_INT 2
26873: ARRAY
26874: PPUSH
26875: CALL_OW 111
// continue ;
26879: GO 26371
// end ; end ; r := GetDir ( tmp ) ;
26881: LD_ADDR_VAR 0 15
26885: PUSH
26886: LD_VAR 0 13
26890: PPUSH
26891: CALL_OW 254
26895: ST_TO_ADDR
// if r = 5 then
26896: LD_VAR 0 15
26900: PUSH
26901: LD_INT 5
26903: EQUAL
26904: IFFALSE 26914
// r := 0 ;
26906: LD_ADDR_VAR 0 15
26910: PUSH
26911: LD_INT 0
26913: ST_TO_ADDR
// for j = r to 5 do
26914: LD_ADDR_VAR 0 10
26918: PUSH
26919: DOUBLE
26920: LD_VAR 0 15
26924: DEC
26925: ST_TO_ADDR
26926: LD_INT 5
26928: PUSH
26929: FOR_TO
26930: IFFALSE 27044
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26932: LD_ADDR_VAR 0 11
26936: PUSH
26937: LD_VAR 0 13
26941: PPUSH
26942: CALL_OW 250
26946: PPUSH
26947: LD_VAR 0 10
26951: PPUSH
26952: LD_INT 2
26954: PPUSH
26955: CALL_OW 272
26959: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26960: LD_ADDR_VAR 0 12
26964: PUSH
26965: LD_VAR 0 13
26969: PPUSH
26970: CALL_OW 251
26974: PPUSH
26975: LD_VAR 0 10
26979: PPUSH
26980: LD_INT 2
26982: PPUSH
26983: CALL_OW 273
26987: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26988: LD_VAR 0 11
26992: PPUSH
26993: LD_VAR 0 12
26997: PPUSH
26998: CALL_OW 488
27002: PUSH
27003: LD_VAR 0 11
27007: PPUSH
27008: LD_VAR 0 12
27012: PPUSH
27013: CALL_OW 428
27017: NOT
27018: AND
27019: IFFALSE 27042
// begin ComMoveXY ( tmp , _x , _y ) ;
27021: LD_VAR 0 13
27025: PPUSH
27026: LD_VAR 0 11
27030: PPUSH
27031: LD_VAR 0 12
27035: PPUSH
27036: CALL_OW 111
// break ;
27040: GO 27044
// end ; end ;
27042: GO 26929
27044: POP
27045: POP
// end ; end ;
27046: GO 26371
27048: POP
27049: POP
// end ;
27050: LD_VAR 0 8
27054: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
27055: LD_INT 0
27057: PPUSH
27058: PPUSH
27059: PPUSH
27060: PPUSH
27061: PPUSH
27062: PPUSH
27063: PPUSH
27064: PPUSH
27065: PPUSH
27066: PPUSH
// result := false ;
27067: LD_ADDR_VAR 0 6
27071: PUSH
27072: LD_INT 0
27074: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
27075: LD_VAR 0 1
27079: NOT
27080: PUSH
27081: LD_VAR 0 1
27085: PPUSH
27086: CALL_OW 266
27090: PUSH
27091: LD_INT 0
27093: PUSH
27094: LD_INT 1
27096: PUSH
27097: EMPTY
27098: LIST
27099: LIST
27100: IN
27101: NOT
27102: OR
27103: PUSH
27104: LD_VAR 0 2
27108: NOT
27109: OR
27110: PUSH
27111: LD_VAR 0 5
27115: PUSH
27116: LD_INT 0
27118: PUSH
27119: LD_INT 1
27121: PUSH
27122: LD_INT 2
27124: PUSH
27125: LD_INT 3
27127: PUSH
27128: LD_INT 4
27130: PUSH
27131: LD_INT 5
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: LIST
27138: LIST
27139: LIST
27140: LIST
27141: IN
27142: NOT
27143: OR
27144: PUSH
27145: LD_VAR 0 3
27149: PPUSH
27150: LD_VAR 0 4
27154: PPUSH
27155: CALL_OW 488
27159: NOT
27160: OR
27161: IFFALSE 27165
// exit ;
27163: GO 27882
// pom := GetBase ( depot ) ;
27165: LD_ADDR_VAR 0 10
27169: PUSH
27170: LD_VAR 0 1
27174: PPUSH
27175: CALL_OW 274
27179: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
27180: LD_ADDR_VAR 0 11
27184: PUSH
27185: LD_VAR 0 2
27189: PPUSH
27190: LD_VAR 0 1
27194: PPUSH
27195: CALL_OW 248
27199: PPUSH
27200: CALL_OW 450
27204: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
27205: LD_VAR 0 10
27209: PPUSH
27210: LD_INT 1
27212: PPUSH
27213: CALL_OW 275
27217: PUSH
27218: LD_VAR 0 11
27222: PUSH
27223: LD_INT 1
27225: ARRAY
27226: GREATEREQUAL
27227: PUSH
27228: LD_VAR 0 10
27232: PPUSH
27233: LD_INT 2
27235: PPUSH
27236: CALL_OW 275
27240: PUSH
27241: LD_VAR 0 11
27245: PUSH
27246: LD_INT 2
27248: ARRAY
27249: GREATEREQUAL
27250: AND
27251: PUSH
27252: LD_VAR 0 10
27256: PPUSH
27257: LD_INT 3
27259: PPUSH
27260: CALL_OW 275
27264: PUSH
27265: LD_VAR 0 11
27269: PUSH
27270: LD_INT 3
27272: ARRAY
27273: GREATEREQUAL
27274: AND
27275: NOT
27276: IFFALSE 27280
// exit ;
27278: GO 27882
// if GetBType ( depot ) = b_depot then
27280: LD_VAR 0 1
27284: PPUSH
27285: CALL_OW 266
27289: PUSH
27290: LD_INT 0
27292: EQUAL
27293: IFFALSE 27305
// dist := 28 else
27295: LD_ADDR_VAR 0 14
27299: PUSH
27300: LD_INT 28
27302: ST_TO_ADDR
27303: GO 27313
// dist := 36 ;
27305: LD_ADDR_VAR 0 14
27309: PUSH
27310: LD_INT 36
27312: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
27313: LD_VAR 0 1
27317: PPUSH
27318: LD_VAR 0 3
27322: PPUSH
27323: LD_VAR 0 4
27327: PPUSH
27328: CALL_OW 297
27332: PUSH
27333: LD_VAR 0 14
27337: GREATER
27338: IFFALSE 27342
// exit ;
27340: GO 27882
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
27342: LD_ADDR_VAR 0 12
27346: PUSH
27347: LD_VAR 0 2
27351: PPUSH
27352: LD_VAR 0 3
27356: PPUSH
27357: LD_VAR 0 4
27361: PPUSH
27362: LD_VAR 0 5
27366: PPUSH
27367: LD_VAR 0 1
27371: PPUSH
27372: CALL_OW 248
27376: PPUSH
27377: LD_INT 0
27379: PPUSH
27380: CALL 27887 0 6
27384: ST_TO_ADDR
// if not hexes then
27385: LD_VAR 0 12
27389: NOT
27390: IFFALSE 27394
// exit ;
27392: GO 27882
// hex := GetHexInfo ( x , y ) ;
27394: LD_ADDR_VAR 0 15
27398: PUSH
27399: LD_VAR 0 3
27403: PPUSH
27404: LD_VAR 0 4
27408: PPUSH
27409: CALL_OW 546
27413: ST_TO_ADDR
// if hex [ 1 ] then
27414: LD_VAR 0 15
27418: PUSH
27419: LD_INT 1
27421: ARRAY
27422: IFFALSE 27426
// exit ;
27424: GO 27882
// height := hex [ 2 ] ;
27426: LD_ADDR_VAR 0 13
27430: PUSH
27431: LD_VAR 0 15
27435: PUSH
27436: LD_INT 2
27438: ARRAY
27439: ST_TO_ADDR
// for i = 1 to hexes do
27440: LD_ADDR_VAR 0 7
27444: PUSH
27445: DOUBLE
27446: LD_INT 1
27448: DEC
27449: ST_TO_ADDR
27450: LD_VAR 0 12
27454: PUSH
27455: FOR_TO
27456: IFFALSE 27786
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27458: LD_VAR 0 12
27462: PUSH
27463: LD_VAR 0 7
27467: ARRAY
27468: PUSH
27469: LD_INT 1
27471: ARRAY
27472: PPUSH
27473: LD_VAR 0 12
27477: PUSH
27478: LD_VAR 0 7
27482: ARRAY
27483: PUSH
27484: LD_INT 2
27486: ARRAY
27487: PPUSH
27488: CALL_OW 488
27492: NOT
27493: PUSH
27494: LD_VAR 0 12
27498: PUSH
27499: LD_VAR 0 7
27503: ARRAY
27504: PUSH
27505: LD_INT 1
27507: ARRAY
27508: PPUSH
27509: LD_VAR 0 12
27513: PUSH
27514: LD_VAR 0 7
27518: ARRAY
27519: PUSH
27520: LD_INT 2
27522: ARRAY
27523: PPUSH
27524: CALL_OW 428
27528: PUSH
27529: LD_INT 0
27531: GREATER
27532: OR
27533: PUSH
27534: LD_VAR 0 12
27538: PUSH
27539: LD_VAR 0 7
27543: ARRAY
27544: PUSH
27545: LD_INT 1
27547: ARRAY
27548: PPUSH
27549: LD_VAR 0 12
27553: PUSH
27554: LD_VAR 0 7
27558: ARRAY
27559: PUSH
27560: LD_INT 2
27562: ARRAY
27563: PPUSH
27564: CALL_OW 351
27568: OR
27569: IFFALSE 27575
// exit ;
27571: POP
27572: POP
27573: GO 27882
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27575: LD_ADDR_VAR 0 8
27579: PUSH
27580: LD_VAR 0 12
27584: PUSH
27585: LD_VAR 0 7
27589: ARRAY
27590: PUSH
27591: LD_INT 1
27593: ARRAY
27594: PPUSH
27595: LD_VAR 0 12
27599: PUSH
27600: LD_VAR 0 7
27604: ARRAY
27605: PUSH
27606: LD_INT 2
27608: ARRAY
27609: PPUSH
27610: CALL_OW 546
27614: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27615: LD_VAR 0 8
27619: PUSH
27620: LD_INT 1
27622: ARRAY
27623: PUSH
27624: LD_VAR 0 8
27628: PUSH
27629: LD_INT 2
27631: ARRAY
27632: PUSH
27633: LD_VAR 0 13
27637: PUSH
27638: LD_INT 2
27640: PLUS
27641: GREATER
27642: OR
27643: PUSH
27644: LD_VAR 0 8
27648: PUSH
27649: LD_INT 2
27651: ARRAY
27652: PUSH
27653: LD_VAR 0 13
27657: PUSH
27658: LD_INT 2
27660: MINUS
27661: LESS
27662: OR
27663: PUSH
27664: LD_VAR 0 8
27668: PUSH
27669: LD_INT 3
27671: ARRAY
27672: PUSH
27673: LD_INT 0
27675: PUSH
27676: LD_INT 8
27678: PUSH
27679: LD_INT 9
27681: PUSH
27682: LD_INT 10
27684: PUSH
27685: LD_INT 11
27687: PUSH
27688: LD_INT 12
27690: PUSH
27691: LD_INT 13
27693: PUSH
27694: LD_INT 16
27696: PUSH
27697: LD_INT 17
27699: PUSH
27700: LD_INT 18
27702: PUSH
27703: LD_INT 19
27705: PUSH
27706: LD_INT 20
27708: PUSH
27709: LD_INT 21
27711: PUSH
27712: EMPTY
27713: LIST
27714: LIST
27715: LIST
27716: LIST
27717: LIST
27718: LIST
27719: LIST
27720: LIST
27721: LIST
27722: LIST
27723: LIST
27724: LIST
27725: LIST
27726: IN
27727: NOT
27728: OR
27729: PUSH
27730: LD_VAR 0 8
27734: PUSH
27735: LD_INT 5
27737: ARRAY
27738: NOT
27739: OR
27740: PUSH
27741: LD_VAR 0 8
27745: PUSH
27746: LD_INT 6
27748: ARRAY
27749: PUSH
27750: LD_INT 1
27752: PUSH
27753: LD_INT 2
27755: PUSH
27756: LD_INT 7
27758: PUSH
27759: LD_INT 9
27761: PUSH
27762: LD_INT 10
27764: PUSH
27765: LD_INT 11
27767: PUSH
27768: EMPTY
27769: LIST
27770: LIST
27771: LIST
27772: LIST
27773: LIST
27774: LIST
27775: IN
27776: NOT
27777: OR
27778: IFFALSE 27784
// exit ;
27780: POP
27781: POP
27782: GO 27882
// end ;
27784: GO 27455
27786: POP
27787: POP
// side := GetSide ( depot ) ;
27788: LD_ADDR_VAR 0 9
27792: PUSH
27793: LD_VAR 0 1
27797: PPUSH
27798: CALL_OW 255
27802: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27803: LD_VAR 0 9
27807: PPUSH
27808: LD_VAR 0 3
27812: PPUSH
27813: LD_VAR 0 4
27817: PPUSH
27818: LD_INT 20
27820: PPUSH
27821: CALL 20203 0 4
27825: PUSH
27826: LD_INT 4
27828: ARRAY
27829: IFFALSE 27833
// exit ;
27831: GO 27882
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27833: LD_VAR 0 2
27837: PUSH
27838: LD_INT 29
27840: PUSH
27841: LD_INT 30
27843: PUSH
27844: EMPTY
27845: LIST
27846: LIST
27847: IN
27848: PUSH
27849: LD_VAR 0 3
27853: PPUSH
27854: LD_VAR 0 4
27858: PPUSH
27859: LD_VAR 0 9
27863: PPUSH
27864: CALL_OW 440
27868: NOT
27869: AND
27870: IFFALSE 27874
// exit ;
27872: GO 27882
// result := true ;
27874: LD_ADDR_VAR 0 6
27878: PUSH
27879: LD_INT 1
27881: ST_TO_ADDR
// end ;
27882: LD_VAR 0 6
27886: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27887: LD_INT 0
27889: PPUSH
27890: PPUSH
27891: PPUSH
27892: PPUSH
27893: PPUSH
27894: PPUSH
27895: PPUSH
27896: PPUSH
27897: PPUSH
27898: PPUSH
27899: PPUSH
27900: PPUSH
27901: PPUSH
27902: PPUSH
27903: PPUSH
27904: PPUSH
27905: PPUSH
27906: PPUSH
27907: PPUSH
27908: PPUSH
27909: PPUSH
27910: PPUSH
27911: PPUSH
27912: PPUSH
27913: PPUSH
27914: PPUSH
27915: PPUSH
27916: PPUSH
27917: PPUSH
27918: PPUSH
27919: PPUSH
27920: PPUSH
27921: PPUSH
27922: PPUSH
27923: PPUSH
27924: PPUSH
27925: PPUSH
27926: PPUSH
27927: PPUSH
27928: PPUSH
27929: PPUSH
27930: PPUSH
27931: PPUSH
27932: PPUSH
27933: PPUSH
27934: PPUSH
27935: PPUSH
27936: PPUSH
27937: PPUSH
27938: PPUSH
27939: PPUSH
27940: PPUSH
27941: PPUSH
27942: PPUSH
27943: PPUSH
27944: PPUSH
27945: PPUSH
27946: PPUSH
// result = [ ] ;
27947: LD_ADDR_VAR 0 7
27951: PUSH
27952: EMPTY
27953: ST_TO_ADDR
// temp_list = [ ] ;
27954: LD_ADDR_VAR 0 9
27958: PUSH
27959: EMPTY
27960: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27961: LD_VAR 0 4
27965: PUSH
27966: LD_INT 0
27968: PUSH
27969: LD_INT 1
27971: PUSH
27972: LD_INT 2
27974: PUSH
27975: LD_INT 3
27977: PUSH
27978: LD_INT 4
27980: PUSH
27981: LD_INT 5
27983: PUSH
27984: EMPTY
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: LIST
27990: LIST
27991: IN
27992: NOT
27993: PUSH
27994: LD_VAR 0 1
27998: PUSH
27999: LD_INT 0
28001: PUSH
28002: LD_INT 1
28004: PUSH
28005: EMPTY
28006: LIST
28007: LIST
28008: IN
28009: PUSH
28010: LD_VAR 0 5
28014: PUSH
28015: LD_INT 1
28017: PUSH
28018: LD_INT 2
28020: PUSH
28021: LD_INT 3
28023: PUSH
28024: EMPTY
28025: LIST
28026: LIST
28027: LIST
28028: IN
28029: NOT
28030: AND
28031: OR
28032: IFFALSE 28036
// exit ;
28034: GO 46427
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
28036: LD_VAR 0 1
28040: PUSH
28041: LD_INT 6
28043: PUSH
28044: LD_INT 7
28046: PUSH
28047: LD_INT 8
28049: PUSH
28050: LD_INT 13
28052: PUSH
28053: LD_INT 12
28055: PUSH
28056: LD_INT 15
28058: PUSH
28059: LD_INT 11
28061: PUSH
28062: LD_INT 14
28064: PUSH
28065: LD_INT 10
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: LIST
28072: LIST
28073: LIST
28074: LIST
28075: LIST
28076: LIST
28077: LIST
28078: IN
28079: IFFALSE 28089
// btype = b_lab ;
28081: LD_ADDR_VAR 0 1
28085: PUSH
28086: LD_INT 6
28088: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
28089: LD_VAR 0 6
28093: PUSH
28094: LD_INT 0
28096: PUSH
28097: LD_INT 1
28099: PUSH
28100: LD_INT 2
28102: PUSH
28103: EMPTY
28104: LIST
28105: LIST
28106: LIST
28107: IN
28108: NOT
28109: PUSH
28110: LD_VAR 0 1
28114: PUSH
28115: LD_INT 0
28117: PUSH
28118: LD_INT 1
28120: PUSH
28121: LD_INT 2
28123: PUSH
28124: LD_INT 3
28126: PUSH
28127: LD_INT 6
28129: PUSH
28130: LD_INT 36
28132: PUSH
28133: LD_INT 4
28135: PUSH
28136: LD_INT 5
28138: PUSH
28139: LD_INT 31
28141: PUSH
28142: LD_INT 32
28144: PUSH
28145: LD_INT 33
28147: PUSH
28148: EMPTY
28149: LIST
28150: LIST
28151: LIST
28152: LIST
28153: LIST
28154: LIST
28155: LIST
28156: LIST
28157: LIST
28158: LIST
28159: LIST
28160: IN
28161: NOT
28162: PUSH
28163: LD_VAR 0 6
28167: PUSH
28168: LD_INT 1
28170: EQUAL
28171: AND
28172: OR
28173: PUSH
28174: LD_VAR 0 1
28178: PUSH
28179: LD_INT 2
28181: PUSH
28182: LD_INT 3
28184: PUSH
28185: EMPTY
28186: LIST
28187: LIST
28188: IN
28189: NOT
28190: PUSH
28191: LD_VAR 0 6
28195: PUSH
28196: LD_INT 2
28198: EQUAL
28199: AND
28200: OR
28201: IFFALSE 28211
// mode = 0 ;
28203: LD_ADDR_VAR 0 6
28207: PUSH
28208: LD_INT 0
28210: ST_TO_ADDR
// case mode of 0 :
28211: LD_VAR 0 6
28215: PUSH
28216: LD_INT 0
28218: DOUBLE
28219: EQUAL
28220: IFTRUE 28224
28222: GO 39677
28224: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
28225: LD_ADDR_VAR 0 11
28229: PUSH
28230: LD_INT 0
28232: PUSH
28233: LD_INT 0
28235: PUSH
28236: EMPTY
28237: LIST
28238: LIST
28239: PUSH
28240: LD_INT 0
28242: PUSH
28243: LD_INT 1
28245: NEG
28246: PUSH
28247: EMPTY
28248: LIST
28249: LIST
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: LD_INT 0
28256: PUSH
28257: EMPTY
28258: LIST
28259: LIST
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: LD_INT 1
28266: PUSH
28267: EMPTY
28268: LIST
28269: LIST
28270: PUSH
28271: LD_INT 0
28273: PUSH
28274: LD_INT 1
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: PUSH
28281: LD_INT 1
28283: NEG
28284: PUSH
28285: LD_INT 0
28287: PUSH
28288: EMPTY
28289: LIST
28290: LIST
28291: PUSH
28292: LD_INT 1
28294: NEG
28295: PUSH
28296: LD_INT 1
28298: NEG
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 1
28306: NEG
28307: PUSH
28308: LD_INT 2
28310: NEG
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 0
28318: PUSH
28319: LD_INT 2
28321: NEG
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: PUSH
28327: LD_INT 1
28329: PUSH
28330: LD_INT 1
28332: NEG
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 1
28340: PUSH
28341: LD_INT 2
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 0
28350: PUSH
28351: LD_INT 2
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: PUSH
28358: LD_INT 1
28360: NEG
28361: PUSH
28362: LD_INT 1
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 1
28371: PUSH
28372: LD_INT 3
28374: PUSH
28375: EMPTY
28376: LIST
28377: LIST
28378: PUSH
28379: LD_INT 0
28381: PUSH
28382: LD_INT 3
28384: PUSH
28385: EMPTY
28386: LIST
28387: LIST
28388: PUSH
28389: LD_INT 1
28391: NEG
28392: PUSH
28393: LD_INT 2
28395: PUSH
28396: EMPTY
28397: LIST
28398: LIST
28399: PUSH
28400: EMPTY
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: LIST
28411: LIST
28412: LIST
28413: LIST
28414: LIST
28415: LIST
28416: LIST
28417: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28418: LD_ADDR_VAR 0 12
28422: PUSH
28423: LD_INT 0
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: EMPTY
28430: LIST
28431: LIST
28432: PUSH
28433: LD_INT 0
28435: PUSH
28436: LD_INT 1
28438: NEG
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 1
28446: PUSH
28447: LD_INT 0
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: LD_INT 1
28456: PUSH
28457: LD_INT 1
28459: PUSH
28460: EMPTY
28461: LIST
28462: LIST
28463: PUSH
28464: LD_INT 0
28466: PUSH
28467: LD_INT 1
28469: PUSH
28470: EMPTY
28471: LIST
28472: LIST
28473: PUSH
28474: LD_INT 1
28476: NEG
28477: PUSH
28478: LD_INT 0
28480: PUSH
28481: EMPTY
28482: LIST
28483: LIST
28484: PUSH
28485: LD_INT 1
28487: NEG
28488: PUSH
28489: LD_INT 1
28491: NEG
28492: PUSH
28493: EMPTY
28494: LIST
28495: LIST
28496: PUSH
28497: LD_INT 1
28499: PUSH
28500: LD_INT 1
28502: NEG
28503: PUSH
28504: EMPTY
28505: LIST
28506: LIST
28507: PUSH
28508: LD_INT 2
28510: PUSH
28511: LD_INT 0
28513: PUSH
28514: EMPTY
28515: LIST
28516: LIST
28517: PUSH
28518: LD_INT 2
28520: PUSH
28521: LD_INT 1
28523: PUSH
28524: EMPTY
28525: LIST
28526: LIST
28527: PUSH
28528: LD_INT 1
28530: NEG
28531: PUSH
28532: LD_INT 1
28534: PUSH
28535: EMPTY
28536: LIST
28537: LIST
28538: PUSH
28539: LD_INT 2
28541: NEG
28542: PUSH
28543: LD_INT 0
28545: PUSH
28546: EMPTY
28547: LIST
28548: LIST
28549: PUSH
28550: LD_INT 2
28552: NEG
28553: PUSH
28554: LD_INT 1
28556: NEG
28557: PUSH
28558: EMPTY
28559: LIST
28560: LIST
28561: PUSH
28562: LD_INT 2
28564: NEG
28565: PUSH
28566: LD_INT 1
28568: PUSH
28569: EMPTY
28570: LIST
28571: LIST
28572: PUSH
28573: LD_INT 3
28575: NEG
28576: PUSH
28577: LD_INT 0
28579: PUSH
28580: EMPTY
28581: LIST
28582: LIST
28583: PUSH
28584: LD_INT 3
28586: NEG
28587: PUSH
28588: LD_INT 1
28590: NEG
28591: PUSH
28592: EMPTY
28593: LIST
28594: LIST
28595: PUSH
28596: EMPTY
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: LIST
28607: LIST
28608: LIST
28609: LIST
28610: LIST
28611: LIST
28612: LIST
28613: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28614: LD_ADDR_VAR 0 13
28618: PUSH
28619: LD_INT 0
28621: PUSH
28622: LD_INT 0
28624: PUSH
28625: EMPTY
28626: LIST
28627: LIST
28628: PUSH
28629: LD_INT 0
28631: PUSH
28632: LD_INT 1
28634: NEG
28635: PUSH
28636: EMPTY
28637: LIST
28638: LIST
28639: PUSH
28640: LD_INT 1
28642: PUSH
28643: LD_INT 0
28645: PUSH
28646: EMPTY
28647: LIST
28648: LIST
28649: PUSH
28650: LD_INT 1
28652: PUSH
28653: LD_INT 1
28655: PUSH
28656: EMPTY
28657: LIST
28658: LIST
28659: PUSH
28660: LD_INT 0
28662: PUSH
28663: LD_INT 1
28665: PUSH
28666: EMPTY
28667: LIST
28668: LIST
28669: PUSH
28670: LD_INT 1
28672: NEG
28673: PUSH
28674: LD_INT 0
28676: PUSH
28677: EMPTY
28678: LIST
28679: LIST
28680: PUSH
28681: LD_INT 1
28683: NEG
28684: PUSH
28685: LD_INT 1
28687: NEG
28688: PUSH
28689: EMPTY
28690: LIST
28691: LIST
28692: PUSH
28693: LD_INT 1
28695: NEG
28696: PUSH
28697: LD_INT 2
28699: NEG
28700: PUSH
28701: EMPTY
28702: LIST
28703: LIST
28704: PUSH
28705: LD_INT 2
28707: PUSH
28708: LD_INT 1
28710: PUSH
28711: EMPTY
28712: LIST
28713: LIST
28714: PUSH
28715: LD_INT 2
28717: PUSH
28718: LD_INT 2
28720: PUSH
28721: EMPTY
28722: LIST
28723: LIST
28724: PUSH
28725: LD_INT 1
28727: PUSH
28728: LD_INT 2
28730: PUSH
28731: EMPTY
28732: LIST
28733: LIST
28734: PUSH
28735: LD_INT 2
28737: NEG
28738: PUSH
28739: LD_INT 1
28741: NEG
28742: PUSH
28743: EMPTY
28744: LIST
28745: LIST
28746: PUSH
28747: LD_INT 2
28749: NEG
28750: PUSH
28751: LD_INT 2
28753: NEG
28754: PUSH
28755: EMPTY
28756: LIST
28757: LIST
28758: PUSH
28759: LD_INT 2
28761: NEG
28762: PUSH
28763: LD_INT 3
28765: NEG
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PUSH
28771: LD_INT 3
28773: NEG
28774: PUSH
28775: LD_INT 2
28777: NEG
28778: PUSH
28779: EMPTY
28780: LIST
28781: LIST
28782: PUSH
28783: LD_INT 3
28785: NEG
28786: PUSH
28787: LD_INT 3
28789: NEG
28790: PUSH
28791: EMPTY
28792: LIST
28793: LIST
28794: PUSH
28795: EMPTY
28796: LIST
28797: LIST
28798: LIST
28799: LIST
28800: LIST
28801: LIST
28802: LIST
28803: LIST
28804: LIST
28805: LIST
28806: LIST
28807: LIST
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28813: LD_ADDR_VAR 0 14
28817: PUSH
28818: LD_INT 0
28820: PUSH
28821: LD_INT 0
28823: PUSH
28824: EMPTY
28825: LIST
28826: LIST
28827: PUSH
28828: LD_INT 0
28830: PUSH
28831: LD_INT 1
28833: NEG
28834: PUSH
28835: EMPTY
28836: LIST
28837: LIST
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: LD_INT 0
28844: PUSH
28845: EMPTY
28846: LIST
28847: LIST
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: LD_INT 1
28854: PUSH
28855: EMPTY
28856: LIST
28857: LIST
28858: PUSH
28859: LD_INT 0
28861: PUSH
28862: LD_INT 1
28864: PUSH
28865: EMPTY
28866: LIST
28867: LIST
28868: PUSH
28869: LD_INT 1
28871: NEG
28872: PUSH
28873: LD_INT 0
28875: PUSH
28876: EMPTY
28877: LIST
28878: LIST
28879: PUSH
28880: LD_INT 1
28882: NEG
28883: PUSH
28884: LD_INT 1
28886: NEG
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 2
28898: NEG
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 0
28906: PUSH
28907: LD_INT 2
28909: NEG
28910: PUSH
28911: EMPTY
28912: LIST
28913: LIST
28914: PUSH
28915: LD_INT 1
28917: PUSH
28918: LD_INT 1
28920: NEG
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 1
28928: PUSH
28929: LD_INT 2
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 0
28938: PUSH
28939: LD_INT 2
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 1
28948: NEG
28949: PUSH
28950: LD_INT 1
28952: PUSH
28953: EMPTY
28954: LIST
28955: LIST
28956: PUSH
28957: LD_INT 1
28959: NEG
28960: PUSH
28961: LD_INT 3
28963: NEG
28964: PUSH
28965: EMPTY
28966: LIST
28967: LIST
28968: PUSH
28969: LD_INT 0
28971: PUSH
28972: LD_INT 3
28974: NEG
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 1
28982: PUSH
28983: LD_INT 2
28985: NEG
28986: PUSH
28987: EMPTY
28988: LIST
28989: LIST
28990: PUSH
28991: EMPTY
28992: LIST
28993: LIST
28994: LIST
28995: LIST
28996: LIST
28997: LIST
28998: LIST
28999: LIST
29000: LIST
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
29009: LD_ADDR_VAR 0 15
29013: PUSH
29014: LD_INT 0
29016: PUSH
29017: LD_INT 0
29019: PUSH
29020: EMPTY
29021: LIST
29022: LIST
29023: PUSH
29024: LD_INT 0
29026: PUSH
29027: LD_INT 1
29029: NEG
29030: PUSH
29031: EMPTY
29032: LIST
29033: LIST
29034: PUSH
29035: LD_INT 1
29037: PUSH
29038: LD_INT 0
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PUSH
29045: LD_INT 1
29047: PUSH
29048: LD_INT 1
29050: PUSH
29051: EMPTY
29052: LIST
29053: LIST
29054: PUSH
29055: LD_INT 0
29057: PUSH
29058: LD_INT 1
29060: PUSH
29061: EMPTY
29062: LIST
29063: LIST
29064: PUSH
29065: LD_INT 1
29067: NEG
29068: PUSH
29069: LD_INT 0
29071: PUSH
29072: EMPTY
29073: LIST
29074: LIST
29075: PUSH
29076: LD_INT 1
29078: NEG
29079: PUSH
29080: LD_INT 1
29082: NEG
29083: PUSH
29084: EMPTY
29085: LIST
29086: LIST
29087: PUSH
29088: LD_INT 1
29090: PUSH
29091: LD_INT 1
29093: NEG
29094: PUSH
29095: EMPTY
29096: LIST
29097: LIST
29098: PUSH
29099: LD_INT 2
29101: PUSH
29102: LD_INT 0
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 2
29111: PUSH
29112: LD_INT 1
29114: PUSH
29115: EMPTY
29116: LIST
29117: LIST
29118: PUSH
29119: LD_INT 1
29121: NEG
29122: PUSH
29123: LD_INT 1
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: PUSH
29130: LD_INT 2
29132: NEG
29133: PUSH
29134: LD_INT 0
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 2
29143: NEG
29144: PUSH
29145: LD_INT 1
29147: NEG
29148: PUSH
29149: EMPTY
29150: LIST
29151: LIST
29152: PUSH
29153: LD_INT 2
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: EMPTY
29161: LIST
29162: LIST
29163: PUSH
29164: LD_INT 3
29166: PUSH
29167: LD_INT 0
29169: PUSH
29170: EMPTY
29171: LIST
29172: LIST
29173: PUSH
29174: LD_INT 3
29176: PUSH
29177: LD_INT 1
29179: PUSH
29180: EMPTY
29181: LIST
29182: LIST
29183: PUSH
29184: EMPTY
29185: LIST
29186: LIST
29187: LIST
29188: LIST
29189: LIST
29190: LIST
29191: LIST
29192: LIST
29193: LIST
29194: LIST
29195: LIST
29196: LIST
29197: LIST
29198: LIST
29199: LIST
29200: LIST
29201: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
29202: LD_ADDR_VAR 0 16
29206: PUSH
29207: LD_INT 0
29209: PUSH
29210: LD_INT 0
29212: PUSH
29213: EMPTY
29214: LIST
29215: LIST
29216: PUSH
29217: LD_INT 0
29219: PUSH
29220: LD_INT 1
29222: NEG
29223: PUSH
29224: EMPTY
29225: LIST
29226: LIST
29227: PUSH
29228: LD_INT 1
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 1
29240: PUSH
29241: LD_INT 1
29243: PUSH
29244: EMPTY
29245: LIST
29246: LIST
29247: PUSH
29248: LD_INT 0
29250: PUSH
29251: LD_INT 1
29253: PUSH
29254: EMPTY
29255: LIST
29256: LIST
29257: PUSH
29258: LD_INT 1
29260: NEG
29261: PUSH
29262: LD_INT 0
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 1
29271: NEG
29272: PUSH
29273: LD_INT 1
29275: NEG
29276: PUSH
29277: EMPTY
29278: LIST
29279: LIST
29280: PUSH
29281: LD_INT 1
29283: NEG
29284: PUSH
29285: LD_INT 2
29287: NEG
29288: PUSH
29289: EMPTY
29290: LIST
29291: LIST
29292: PUSH
29293: LD_INT 2
29295: PUSH
29296: LD_INT 1
29298: PUSH
29299: EMPTY
29300: LIST
29301: LIST
29302: PUSH
29303: LD_INT 2
29305: PUSH
29306: LD_INT 2
29308: PUSH
29309: EMPTY
29310: LIST
29311: LIST
29312: PUSH
29313: LD_INT 1
29315: PUSH
29316: LD_INT 2
29318: PUSH
29319: EMPTY
29320: LIST
29321: LIST
29322: PUSH
29323: LD_INT 2
29325: NEG
29326: PUSH
29327: LD_INT 1
29329: NEG
29330: PUSH
29331: EMPTY
29332: LIST
29333: LIST
29334: PUSH
29335: LD_INT 2
29337: NEG
29338: PUSH
29339: LD_INT 2
29341: NEG
29342: PUSH
29343: EMPTY
29344: LIST
29345: LIST
29346: PUSH
29347: LD_INT 3
29349: PUSH
29350: LD_INT 2
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: PUSH
29357: LD_INT 3
29359: PUSH
29360: LD_INT 3
29362: PUSH
29363: EMPTY
29364: LIST
29365: LIST
29366: PUSH
29367: LD_INT 2
29369: PUSH
29370: LD_INT 3
29372: PUSH
29373: EMPTY
29374: LIST
29375: LIST
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: LIST
29381: LIST
29382: LIST
29383: LIST
29384: LIST
29385: LIST
29386: LIST
29387: LIST
29388: LIST
29389: LIST
29390: LIST
29391: LIST
29392: LIST
29393: LIST
29394: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29395: LD_ADDR_VAR 0 17
29399: PUSH
29400: LD_INT 0
29402: PUSH
29403: LD_INT 0
29405: PUSH
29406: EMPTY
29407: LIST
29408: LIST
29409: PUSH
29410: LD_INT 0
29412: PUSH
29413: LD_INT 1
29415: NEG
29416: PUSH
29417: EMPTY
29418: LIST
29419: LIST
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: LD_INT 0
29426: PUSH
29427: EMPTY
29428: LIST
29429: LIST
29430: PUSH
29431: LD_INT 1
29433: PUSH
29434: LD_INT 1
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PUSH
29441: LD_INT 0
29443: PUSH
29444: LD_INT 1
29446: PUSH
29447: EMPTY
29448: LIST
29449: LIST
29450: PUSH
29451: LD_INT 1
29453: NEG
29454: PUSH
29455: LD_INT 0
29457: PUSH
29458: EMPTY
29459: LIST
29460: LIST
29461: PUSH
29462: LD_INT 1
29464: NEG
29465: PUSH
29466: LD_INT 1
29468: NEG
29469: PUSH
29470: EMPTY
29471: LIST
29472: LIST
29473: PUSH
29474: LD_INT 1
29476: NEG
29477: PUSH
29478: LD_INT 2
29480: NEG
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: LD_INT 2
29491: NEG
29492: PUSH
29493: EMPTY
29494: LIST
29495: LIST
29496: PUSH
29497: LD_INT 1
29499: PUSH
29500: LD_INT 1
29502: NEG
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: LD_INT 2
29510: PUSH
29511: LD_INT 0
29513: PUSH
29514: EMPTY
29515: LIST
29516: LIST
29517: PUSH
29518: LD_INT 2
29520: PUSH
29521: LD_INT 1
29523: PUSH
29524: EMPTY
29525: LIST
29526: LIST
29527: PUSH
29528: LD_INT 2
29530: PUSH
29531: LD_INT 2
29533: PUSH
29534: EMPTY
29535: LIST
29536: LIST
29537: PUSH
29538: LD_INT 1
29540: PUSH
29541: LD_INT 2
29543: PUSH
29544: EMPTY
29545: LIST
29546: LIST
29547: PUSH
29548: LD_INT 0
29550: PUSH
29551: LD_INT 2
29553: PUSH
29554: EMPTY
29555: LIST
29556: LIST
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: LD_INT 1
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 2
29571: NEG
29572: PUSH
29573: LD_INT 0
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 2
29582: NEG
29583: PUSH
29584: LD_INT 1
29586: NEG
29587: PUSH
29588: EMPTY
29589: LIST
29590: LIST
29591: PUSH
29592: LD_INT 2
29594: NEG
29595: PUSH
29596: LD_INT 2
29598: NEG
29599: PUSH
29600: EMPTY
29601: LIST
29602: LIST
29603: PUSH
29604: EMPTY
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: LIST
29613: LIST
29614: LIST
29615: LIST
29616: LIST
29617: LIST
29618: LIST
29619: LIST
29620: LIST
29621: LIST
29622: LIST
29623: LIST
29624: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29625: LD_ADDR_VAR 0 18
29629: PUSH
29630: LD_INT 0
29632: PUSH
29633: LD_INT 0
29635: PUSH
29636: EMPTY
29637: LIST
29638: LIST
29639: PUSH
29640: LD_INT 0
29642: PUSH
29643: LD_INT 1
29645: NEG
29646: PUSH
29647: EMPTY
29648: LIST
29649: LIST
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: PUSH
29661: LD_INT 1
29663: PUSH
29664: LD_INT 1
29666: PUSH
29667: EMPTY
29668: LIST
29669: LIST
29670: PUSH
29671: LD_INT 0
29673: PUSH
29674: LD_INT 1
29676: PUSH
29677: EMPTY
29678: LIST
29679: LIST
29680: PUSH
29681: LD_INT 1
29683: NEG
29684: PUSH
29685: LD_INT 0
29687: PUSH
29688: EMPTY
29689: LIST
29690: LIST
29691: PUSH
29692: LD_INT 1
29694: NEG
29695: PUSH
29696: LD_INT 1
29698: NEG
29699: PUSH
29700: EMPTY
29701: LIST
29702: LIST
29703: PUSH
29704: LD_INT 1
29706: NEG
29707: PUSH
29708: LD_INT 2
29710: NEG
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PUSH
29716: LD_INT 0
29718: PUSH
29719: LD_INT 2
29721: NEG
29722: PUSH
29723: EMPTY
29724: LIST
29725: LIST
29726: PUSH
29727: LD_INT 1
29729: PUSH
29730: LD_INT 1
29732: NEG
29733: PUSH
29734: EMPTY
29735: LIST
29736: LIST
29737: PUSH
29738: LD_INT 2
29740: PUSH
29741: LD_INT 0
29743: PUSH
29744: EMPTY
29745: LIST
29746: LIST
29747: PUSH
29748: LD_INT 2
29750: PUSH
29751: LD_INT 1
29753: PUSH
29754: EMPTY
29755: LIST
29756: LIST
29757: PUSH
29758: LD_INT 2
29760: PUSH
29761: LD_INT 2
29763: PUSH
29764: EMPTY
29765: LIST
29766: LIST
29767: PUSH
29768: LD_INT 1
29770: PUSH
29771: LD_INT 2
29773: PUSH
29774: EMPTY
29775: LIST
29776: LIST
29777: PUSH
29778: LD_INT 0
29780: PUSH
29781: LD_INT 2
29783: PUSH
29784: EMPTY
29785: LIST
29786: LIST
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: LD_INT 1
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 2
29801: NEG
29802: PUSH
29803: LD_INT 0
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 2
29812: NEG
29813: PUSH
29814: LD_INT 1
29816: NEG
29817: PUSH
29818: EMPTY
29819: LIST
29820: LIST
29821: PUSH
29822: LD_INT 2
29824: NEG
29825: PUSH
29826: LD_INT 2
29828: NEG
29829: PUSH
29830: EMPTY
29831: LIST
29832: LIST
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: LIST
29838: LIST
29839: LIST
29840: LIST
29841: LIST
29842: LIST
29843: LIST
29844: LIST
29845: LIST
29846: LIST
29847: LIST
29848: LIST
29849: LIST
29850: LIST
29851: LIST
29852: LIST
29853: LIST
29854: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29855: LD_ADDR_VAR 0 19
29859: PUSH
29860: LD_INT 0
29862: PUSH
29863: LD_INT 0
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 0
29872: PUSH
29873: LD_INT 1
29875: NEG
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: PUSH
29884: LD_INT 0
29886: PUSH
29887: EMPTY
29888: LIST
29889: LIST
29890: PUSH
29891: LD_INT 1
29893: PUSH
29894: LD_INT 1
29896: PUSH
29897: EMPTY
29898: LIST
29899: LIST
29900: PUSH
29901: LD_INT 0
29903: PUSH
29904: LD_INT 1
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: NEG
29914: PUSH
29915: LD_INT 0
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 1
29924: NEG
29925: PUSH
29926: LD_INT 1
29928: NEG
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: LD_INT 1
29936: NEG
29937: PUSH
29938: LD_INT 2
29940: NEG
29941: PUSH
29942: EMPTY
29943: LIST
29944: LIST
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: LD_INT 2
29951: NEG
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PUSH
29957: LD_INT 1
29959: PUSH
29960: LD_INT 1
29962: NEG
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: LD_INT 2
29970: PUSH
29971: LD_INT 0
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 2
29980: PUSH
29981: LD_INT 1
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 2
29990: PUSH
29991: LD_INT 2
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 1
30000: PUSH
30001: LD_INT 2
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 0
30010: PUSH
30011: LD_INT 2
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: LD_INT 1
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 2
30031: NEG
30032: PUSH
30033: LD_INT 0
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 2
30042: NEG
30043: PUSH
30044: LD_INT 1
30046: NEG
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 2
30054: NEG
30055: PUSH
30056: LD_INT 2
30058: NEG
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: EMPTY
30065: LIST
30066: LIST
30067: LIST
30068: LIST
30069: LIST
30070: LIST
30071: LIST
30072: LIST
30073: LIST
30074: LIST
30075: LIST
30076: LIST
30077: LIST
30078: LIST
30079: LIST
30080: LIST
30081: LIST
30082: LIST
30083: LIST
30084: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30085: LD_ADDR_VAR 0 20
30089: PUSH
30090: LD_INT 0
30092: PUSH
30093: LD_INT 0
30095: PUSH
30096: EMPTY
30097: LIST
30098: LIST
30099: PUSH
30100: LD_INT 0
30102: PUSH
30103: LD_INT 1
30105: NEG
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 1
30113: PUSH
30114: LD_INT 0
30116: PUSH
30117: EMPTY
30118: LIST
30119: LIST
30120: PUSH
30121: LD_INT 1
30123: PUSH
30124: LD_INT 1
30126: PUSH
30127: EMPTY
30128: LIST
30129: LIST
30130: PUSH
30131: LD_INT 0
30133: PUSH
30134: LD_INT 1
30136: PUSH
30137: EMPTY
30138: LIST
30139: LIST
30140: PUSH
30141: LD_INT 1
30143: NEG
30144: PUSH
30145: LD_INT 0
30147: PUSH
30148: EMPTY
30149: LIST
30150: LIST
30151: PUSH
30152: LD_INT 1
30154: NEG
30155: PUSH
30156: LD_INT 1
30158: NEG
30159: PUSH
30160: EMPTY
30161: LIST
30162: LIST
30163: PUSH
30164: LD_INT 1
30166: NEG
30167: PUSH
30168: LD_INT 2
30170: NEG
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: LD_INT 2
30181: NEG
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 1
30189: PUSH
30190: LD_INT 1
30192: NEG
30193: PUSH
30194: EMPTY
30195: LIST
30196: LIST
30197: PUSH
30198: LD_INT 2
30200: PUSH
30201: LD_INT 0
30203: PUSH
30204: EMPTY
30205: LIST
30206: LIST
30207: PUSH
30208: LD_INT 2
30210: PUSH
30211: LD_INT 1
30213: PUSH
30214: EMPTY
30215: LIST
30216: LIST
30217: PUSH
30218: LD_INT 2
30220: PUSH
30221: LD_INT 2
30223: PUSH
30224: EMPTY
30225: LIST
30226: LIST
30227: PUSH
30228: LD_INT 1
30230: PUSH
30231: LD_INT 2
30233: PUSH
30234: EMPTY
30235: LIST
30236: LIST
30237: PUSH
30238: LD_INT 0
30240: PUSH
30241: LD_INT 2
30243: PUSH
30244: EMPTY
30245: LIST
30246: LIST
30247: PUSH
30248: LD_INT 1
30250: NEG
30251: PUSH
30252: LD_INT 1
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 2
30261: NEG
30262: PUSH
30263: LD_INT 0
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 2
30272: NEG
30273: PUSH
30274: LD_INT 1
30276: NEG
30277: PUSH
30278: EMPTY
30279: LIST
30280: LIST
30281: PUSH
30282: LD_INT 2
30284: NEG
30285: PUSH
30286: LD_INT 2
30288: NEG
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: EMPTY
30295: LIST
30296: LIST
30297: LIST
30298: LIST
30299: LIST
30300: LIST
30301: LIST
30302: LIST
30303: LIST
30304: LIST
30305: LIST
30306: LIST
30307: LIST
30308: LIST
30309: LIST
30310: LIST
30311: LIST
30312: LIST
30313: LIST
30314: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30315: LD_ADDR_VAR 0 21
30319: PUSH
30320: LD_INT 0
30322: PUSH
30323: LD_INT 0
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 0
30332: PUSH
30333: LD_INT 1
30335: NEG
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PUSH
30341: LD_INT 1
30343: PUSH
30344: LD_INT 0
30346: PUSH
30347: EMPTY
30348: LIST
30349: LIST
30350: PUSH
30351: LD_INT 1
30353: PUSH
30354: LD_INT 1
30356: PUSH
30357: EMPTY
30358: LIST
30359: LIST
30360: PUSH
30361: LD_INT 0
30363: PUSH
30364: LD_INT 1
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 1
30373: NEG
30374: PUSH
30375: LD_INT 0
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 1
30384: NEG
30385: PUSH
30386: LD_INT 1
30388: NEG
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 1
30396: NEG
30397: PUSH
30398: LD_INT 2
30400: NEG
30401: PUSH
30402: EMPTY
30403: LIST
30404: LIST
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: LD_INT 2
30411: NEG
30412: PUSH
30413: EMPTY
30414: LIST
30415: LIST
30416: PUSH
30417: LD_INT 1
30419: PUSH
30420: LD_INT 1
30422: NEG
30423: PUSH
30424: EMPTY
30425: LIST
30426: LIST
30427: PUSH
30428: LD_INT 2
30430: PUSH
30431: LD_INT 0
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 2
30440: PUSH
30441: LD_INT 1
30443: PUSH
30444: EMPTY
30445: LIST
30446: LIST
30447: PUSH
30448: LD_INT 2
30450: PUSH
30451: LD_INT 2
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 1
30460: PUSH
30461: LD_INT 2
30463: PUSH
30464: EMPTY
30465: LIST
30466: LIST
30467: PUSH
30468: LD_INT 0
30470: PUSH
30471: LD_INT 2
30473: PUSH
30474: EMPTY
30475: LIST
30476: LIST
30477: PUSH
30478: LD_INT 1
30480: NEG
30481: PUSH
30482: LD_INT 1
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 2
30491: NEG
30492: PUSH
30493: LD_INT 0
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 2
30502: NEG
30503: PUSH
30504: LD_INT 1
30506: NEG
30507: PUSH
30508: EMPTY
30509: LIST
30510: LIST
30511: PUSH
30512: LD_INT 2
30514: NEG
30515: PUSH
30516: LD_INT 2
30518: NEG
30519: PUSH
30520: EMPTY
30521: LIST
30522: LIST
30523: PUSH
30524: EMPTY
30525: LIST
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: LIST
30543: LIST
30544: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30545: LD_ADDR_VAR 0 22
30549: PUSH
30550: LD_INT 0
30552: PUSH
30553: LD_INT 0
30555: PUSH
30556: EMPTY
30557: LIST
30558: LIST
30559: PUSH
30560: LD_INT 0
30562: PUSH
30563: LD_INT 1
30565: NEG
30566: PUSH
30567: EMPTY
30568: LIST
30569: LIST
30570: PUSH
30571: LD_INT 1
30573: PUSH
30574: LD_INT 0
30576: PUSH
30577: EMPTY
30578: LIST
30579: LIST
30580: PUSH
30581: LD_INT 1
30583: PUSH
30584: LD_INT 1
30586: PUSH
30587: EMPTY
30588: LIST
30589: LIST
30590: PUSH
30591: LD_INT 0
30593: PUSH
30594: LD_INT 1
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 1
30603: NEG
30604: PUSH
30605: LD_INT 0
30607: PUSH
30608: EMPTY
30609: LIST
30610: LIST
30611: PUSH
30612: LD_INT 1
30614: NEG
30615: PUSH
30616: LD_INT 1
30618: NEG
30619: PUSH
30620: EMPTY
30621: LIST
30622: LIST
30623: PUSH
30624: LD_INT 1
30626: NEG
30627: PUSH
30628: LD_INT 2
30630: NEG
30631: PUSH
30632: EMPTY
30633: LIST
30634: LIST
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: LD_INT 2
30641: NEG
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: PUSH
30647: LD_INT 1
30649: PUSH
30650: LD_INT 1
30652: NEG
30653: PUSH
30654: EMPTY
30655: LIST
30656: LIST
30657: PUSH
30658: LD_INT 2
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 2
30670: PUSH
30671: LD_INT 1
30673: PUSH
30674: EMPTY
30675: LIST
30676: LIST
30677: PUSH
30678: LD_INT 2
30680: PUSH
30681: LD_INT 2
30683: PUSH
30684: EMPTY
30685: LIST
30686: LIST
30687: PUSH
30688: LD_INT 1
30690: PUSH
30691: LD_INT 2
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 0
30700: PUSH
30701: LD_INT 2
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PUSH
30708: LD_INT 1
30710: NEG
30711: PUSH
30712: LD_INT 1
30714: PUSH
30715: EMPTY
30716: LIST
30717: LIST
30718: PUSH
30719: LD_INT 2
30721: NEG
30722: PUSH
30723: LD_INT 0
30725: PUSH
30726: EMPTY
30727: LIST
30728: LIST
30729: PUSH
30730: LD_INT 2
30732: NEG
30733: PUSH
30734: LD_INT 1
30736: NEG
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: PUSH
30742: LD_INT 2
30744: NEG
30745: PUSH
30746: LD_INT 2
30748: NEG
30749: PUSH
30750: EMPTY
30751: LIST
30752: LIST
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: LIST
30758: LIST
30759: LIST
30760: LIST
30761: LIST
30762: LIST
30763: LIST
30764: LIST
30765: LIST
30766: LIST
30767: LIST
30768: LIST
30769: LIST
30770: LIST
30771: LIST
30772: LIST
30773: LIST
30774: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30775: LD_ADDR_VAR 0 23
30779: PUSH
30780: LD_INT 0
30782: PUSH
30783: LD_INT 0
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 0
30792: PUSH
30793: LD_INT 1
30795: NEG
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 1
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 1
30813: PUSH
30814: LD_INT 1
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 0
30823: PUSH
30824: LD_INT 1
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 1
30833: NEG
30834: PUSH
30835: LD_INT 0
30837: PUSH
30838: EMPTY
30839: LIST
30840: LIST
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: LD_INT 1
30848: NEG
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 1
30856: NEG
30857: PUSH
30858: LD_INT 2
30860: NEG
30861: PUSH
30862: EMPTY
30863: LIST
30864: LIST
30865: PUSH
30866: LD_INT 0
30868: PUSH
30869: LD_INT 2
30871: NEG
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 1
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 2
30890: PUSH
30891: LD_INT 0
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: PUSH
30901: LD_INT 1
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: PUSH
30908: LD_INT 2
30910: PUSH
30911: LD_INT 2
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 1
30920: PUSH
30921: LD_INT 2
30923: PUSH
30924: EMPTY
30925: LIST
30926: LIST
30927: PUSH
30928: LD_INT 0
30930: PUSH
30931: LD_INT 2
30933: PUSH
30934: EMPTY
30935: LIST
30936: LIST
30937: PUSH
30938: LD_INT 1
30940: NEG
30941: PUSH
30942: LD_INT 1
30944: PUSH
30945: EMPTY
30946: LIST
30947: LIST
30948: PUSH
30949: LD_INT 2
30951: NEG
30952: PUSH
30953: LD_INT 0
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 2
30962: NEG
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 2
30974: NEG
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 2
30986: NEG
30987: PUSH
30988: LD_INT 3
30990: NEG
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 3
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: PUSH
31011: LD_INT 2
31013: NEG
31014: PUSH
31015: EMPTY
31016: LIST
31017: LIST
31018: PUSH
31019: LD_INT 2
31021: PUSH
31022: LD_INT 1
31024: NEG
31025: PUSH
31026: EMPTY
31027: LIST
31028: LIST
31029: PUSH
31030: EMPTY
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: LIST
31039: LIST
31040: LIST
31041: LIST
31042: LIST
31043: LIST
31044: LIST
31045: LIST
31046: LIST
31047: LIST
31048: LIST
31049: LIST
31050: LIST
31051: LIST
31052: LIST
31053: LIST
31054: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
31055: LD_ADDR_VAR 0 24
31059: PUSH
31060: LD_INT 0
31062: PUSH
31063: LD_INT 0
31065: PUSH
31066: EMPTY
31067: LIST
31068: LIST
31069: PUSH
31070: LD_INT 0
31072: PUSH
31073: LD_INT 1
31075: NEG
31076: PUSH
31077: EMPTY
31078: LIST
31079: LIST
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: LD_INT 0
31086: PUSH
31087: EMPTY
31088: LIST
31089: LIST
31090: PUSH
31091: LD_INT 1
31093: PUSH
31094: LD_INT 1
31096: PUSH
31097: EMPTY
31098: LIST
31099: LIST
31100: PUSH
31101: LD_INT 0
31103: PUSH
31104: LD_INT 1
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 1
31113: NEG
31114: PUSH
31115: LD_INT 0
31117: PUSH
31118: EMPTY
31119: LIST
31120: LIST
31121: PUSH
31122: LD_INT 1
31124: NEG
31125: PUSH
31126: LD_INT 1
31128: NEG
31129: PUSH
31130: EMPTY
31131: LIST
31132: LIST
31133: PUSH
31134: LD_INT 1
31136: NEG
31137: PUSH
31138: LD_INT 2
31140: NEG
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 0
31148: PUSH
31149: LD_INT 2
31151: NEG
31152: PUSH
31153: EMPTY
31154: LIST
31155: LIST
31156: PUSH
31157: LD_INT 1
31159: PUSH
31160: LD_INT 1
31162: NEG
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: LD_INT 0
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: LD_INT 1
31183: PUSH
31184: EMPTY
31185: LIST
31186: LIST
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: LD_INT 2
31193: PUSH
31194: EMPTY
31195: LIST
31196: LIST
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: LD_INT 2
31203: PUSH
31204: EMPTY
31205: LIST
31206: LIST
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: LD_INT 2
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 1
31220: NEG
31221: PUSH
31222: LD_INT 1
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 2
31231: NEG
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: EMPTY
31237: LIST
31238: LIST
31239: PUSH
31240: LD_INT 2
31242: NEG
31243: PUSH
31244: LD_INT 1
31246: NEG
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: PUSH
31252: LD_INT 2
31254: NEG
31255: PUSH
31256: LD_INT 2
31258: NEG
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: LD_INT 2
31269: NEG
31270: PUSH
31271: EMPTY
31272: LIST
31273: LIST
31274: PUSH
31275: LD_INT 2
31277: PUSH
31278: LD_INT 1
31280: NEG
31281: PUSH
31282: EMPTY
31283: LIST
31284: LIST
31285: PUSH
31286: LD_INT 3
31288: PUSH
31289: LD_INT 1
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 3
31298: PUSH
31299: LD_INT 2
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: LIST
31310: LIST
31311: LIST
31312: LIST
31313: LIST
31314: LIST
31315: LIST
31316: LIST
31317: LIST
31318: LIST
31319: LIST
31320: LIST
31321: LIST
31322: LIST
31323: LIST
31324: LIST
31325: LIST
31326: LIST
31327: LIST
31328: LIST
31329: LIST
31330: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
31331: LD_ADDR_VAR 0 25
31335: PUSH
31336: LD_INT 0
31338: PUSH
31339: LD_INT 0
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 0
31348: PUSH
31349: LD_INT 1
31351: NEG
31352: PUSH
31353: EMPTY
31354: LIST
31355: LIST
31356: PUSH
31357: LD_INT 1
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 1
31369: PUSH
31370: LD_INT 1
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 0
31379: PUSH
31380: LD_INT 1
31382: PUSH
31383: EMPTY
31384: LIST
31385: LIST
31386: PUSH
31387: LD_INT 1
31389: NEG
31390: PUSH
31391: LD_INT 0
31393: PUSH
31394: EMPTY
31395: LIST
31396: LIST
31397: PUSH
31398: LD_INT 1
31400: NEG
31401: PUSH
31402: LD_INT 1
31404: NEG
31405: PUSH
31406: EMPTY
31407: LIST
31408: LIST
31409: PUSH
31410: LD_INT 1
31412: NEG
31413: PUSH
31414: LD_INT 2
31416: NEG
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: LD_INT 2
31427: NEG
31428: PUSH
31429: EMPTY
31430: LIST
31431: LIST
31432: PUSH
31433: LD_INT 1
31435: PUSH
31436: LD_INT 1
31438: NEG
31439: PUSH
31440: EMPTY
31441: LIST
31442: LIST
31443: PUSH
31444: LD_INT 2
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 2
31456: PUSH
31457: LD_INT 1
31459: PUSH
31460: EMPTY
31461: LIST
31462: LIST
31463: PUSH
31464: LD_INT 2
31466: PUSH
31467: LD_INT 2
31469: PUSH
31470: EMPTY
31471: LIST
31472: LIST
31473: PUSH
31474: LD_INT 1
31476: PUSH
31477: LD_INT 2
31479: PUSH
31480: EMPTY
31481: LIST
31482: LIST
31483: PUSH
31484: LD_INT 0
31486: PUSH
31487: LD_INT 2
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 1
31496: NEG
31497: PUSH
31498: LD_INT 1
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 2
31507: NEG
31508: PUSH
31509: LD_INT 0
31511: PUSH
31512: EMPTY
31513: LIST
31514: LIST
31515: PUSH
31516: LD_INT 2
31518: NEG
31519: PUSH
31520: LD_INT 1
31522: NEG
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 2
31530: NEG
31531: PUSH
31532: LD_INT 2
31534: NEG
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 3
31542: PUSH
31543: LD_INT 1
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 3
31552: PUSH
31553: LD_INT 2
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 2
31562: PUSH
31563: LD_INT 3
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 1
31572: PUSH
31573: LD_INT 3
31575: PUSH
31576: EMPTY
31577: LIST
31578: LIST
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: LIST
31584: LIST
31585: LIST
31586: LIST
31587: LIST
31588: LIST
31589: LIST
31590: LIST
31591: LIST
31592: LIST
31593: LIST
31594: LIST
31595: LIST
31596: LIST
31597: LIST
31598: LIST
31599: LIST
31600: LIST
31601: LIST
31602: LIST
31603: LIST
31604: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31605: LD_ADDR_VAR 0 26
31609: PUSH
31610: LD_INT 0
31612: PUSH
31613: LD_INT 0
31615: PUSH
31616: EMPTY
31617: LIST
31618: LIST
31619: PUSH
31620: LD_INT 0
31622: PUSH
31623: LD_INT 1
31625: NEG
31626: PUSH
31627: EMPTY
31628: LIST
31629: LIST
31630: PUSH
31631: LD_INT 1
31633: PUSH
31634: LD_INT 0
31636: PUSH
31637: EMPTY
31638: LIST
31639: LIST
31640: PUSH
31641: LD_INT 1
31643: PUSH
31644: LD_INT 1
31646: PUSH
31647: EMPTY
31648: LIST
31649: LIST
31650: PUSH
31651: LD_INT 0
31653: PUSH
31654: LD_INT 1
31656: PUSH
31657: EMPTY
31658: LIST
31659: LIST
31660: PUSH
31661: LD_INT 1
31663: NEG
31664: PUSH
31665: LD_INT 0
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 1
31674: NEG
31675: PUSH
31676: LD_INT 1
31678: NEG
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 1
31686: NEG
31687: PUSH
31688: LD_INT 2
31690: NEG
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: PUSH
31696: LD_INT 0
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: EMPTY
31704: LIST
31705: LIST
31706: PUSH
31707: LD_INT 1
31709: PUSH
31710: LD_INT 1
31712: NEG
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 2
31720: PUSH
31721: LD_INT 0
31723: PUSH
31724: EMPTY
31725: LIST
31726: LIST
31727: PUSH
31728: LD_INT 2
31730: PUSH
31731: LD_INT 1
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: PUSH
31738: LD_INT 2
31740: PUSH
31741: LD_INT 2
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: LD_INT 2
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 0
31760: PUSH
31761: LD_INT 2
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 1
31770: NEG
31771: PUSH
31772: LD_INT 1
31774: PUSH
31775: EMPTY
31776: LIST
31777: LIST
31778: PUSH
31779: LD_INT 2
31781: NEG
31782: PUSH
31783: LD_INT 0
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: PUSH
31790: LD_INT 2
31792: NEG
31793: PUSH
31794: LD_INT 1
31796: NEG
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 2
31804: NEG
31805: PUSH
31806: LD_INT 2
31808: NEG
31809: PUSH
31810: EMPTY
31811: LIST
31812: LIST
31813: PUSH
31814: LD_INT 2
31816: PUSH
31817: LD_INT 3
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PUSH
31824: LD_INT 1
31826: PUSH
31827: LD_INT 3
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: LD_INT 2
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 2
31847: NEG
31848: PUSH
31849: LD_INT 1
31851: PUSH
31852: EMPTY
31853: LIST
31854: LIST
31855: PUSH
31856: EMPTY
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: LIST
31869: LIST
31870: LIST
31871: LIST
31872: LIST
31873: LIST
31874: LIST
31875: LIST
31876: LIST
31877: LIST
31878: LIST
31879: LIST
31880: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31881: LD_ADDR_VAR 0 27
31885: PUSH
31886: LD_INT 0
31888: PUSH
31889: LD_INT 0
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 0
31898: PUSH
31899: LD_INT 1
31901: NEG
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 1
31909: PUSH
31910: LD_INT 0
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 1
31919: PUSH
31920: LD_INT 1
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 0
31929: PUSH
31930: LD_INT 1
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 1
31939: NEG
31940: PUSH
31941: LD_INT 0
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: LD_INT 1
31954: NEG
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 1
31962: NEG
31963: PUSH
31964: LD_INT 2
31966: NEG
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 0
31974: PUSH
31975: LD_INT 2
31977: NEG
31978: PUSH
31979: EMPTY
31980: LIST
31981: LIST
31982: PUSH
31983: LD_INT 1
31985: PUSH
31986: LD_INT 1
31988: NEG
31989: PUSH
31990: EMPTY
31991: LIST
31992: LIST
31993: PUSH
31994: LD_INT 2
31996: PUSH
31997: LD_INT 0
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 2
32006: PUSH
32007: LD_INT 1
32009: PUSH
32010: EMPTY
32011: LIST
32012: LIST
32013: PUSH
32014: LD_INT 2
32016: PUSH
32017: LD_INT 2
32019: PUSH
32020: EMPTY
32021: LIST
32022: LIST
32023: PUSH
32024: LD_INT 1
32026: PUSH
32027: LD_INT 2
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 0
32036: PUSH
32037: LD_INT 2
32039: PUSH
32040: EMPTY
32041: LIST
32042: LIST
32043: PUSH
32044: LD_INT 1
32046: NEG
32047: PUSH
32048: LD_INT 1
32050: PUSH
32051: EMPTY
32052: LIST
32053: LIST
32054: PUSH
32055: LD_INT 2
32057: NEG
32058: PUSH
32059: LD_INT 0
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: NEG
32069: PUSH
32070: LD_INT 1
32072: NEG
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: LD_INT 2
32080: NEG
32081: PUSH
32082: LD_INT 2
32084: NEG
32085: PUSH
32086: EMPTY
32087: LIST
32088: LIST
32089: PUSH
32090: LD_INT 1
32092: NEG
32093: PUSH
32094: LD_INT 2
32096: PUSH
32097: EMPTY
32098: LIST
32099: LIST
32100: PUSH
32101: LD_INT 2
32103: NEG
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 3
32114: NEG
32115: PUSH
32116: LD_INT 1
32118: NEG
32119: PUSH
32120: EMPTY
32121: LIST
32122: LIST
32123: PUSH
32124: LD_INT 3
32126: NEG
32127: PUSH
32128: LD_INT 2
32130: NEG
32131: PUSH
32132: EMPTY
32133: LIST
32134: LIST
32135: PUSH
32136: EMPTY
32137: LIST
32138: LIST
32139: LIST
32140: LIST
32141: LIST
32142: LIST
32143: LIST
32144: LIST
32145: LIST
32146: LIST
32147: LIST
32148: LIST
32149: LIST
32150: LIST
32151: LIST
32152: LIST
32153: LIST
32154: LIST
32155: LIST
32156: LIST
32157: LIST
32158: LIST
32159: LIST
32160: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
32161: LD_ADDR_VAR 0 28
32165: PUSH
32166: LD_INT 0
32168: PUSH
32169: LD_INT 0
32171: PUSH
32172: EMPTY
32173: LIST
32174: LIST
32175: PUSH
32176: LD_INT 0
32178: PUSH
32179: LD_INT 1
32181: NEG
32182: PUSH
32183: EMPTY
32184: LIST
32185: LIST
32186: PUSH
32187: LD_INT 1
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: LD_INT 1
32199: PUSH
32200: LD_INT 1
32202: PUSH
32203: EMPTY
32204: LIST
32205: LIST
32206: PUSH
32207: LD_INT 0
32209: PUSH
32210: LD_INT 1
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 1
32219: NEG
32220: PUSH
32221: LD_INT 0
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 1
32230: NEG
32231: PUSH
32232: LD_INT 1
32234: NEG
32235: PUSH
32236: EMPTY
32237: LIST
32238: LIST
32239: PUSH
32240: LD_INT 1
32242: NEG
32243: PUSH
32244: LD_INT 2
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 0
32254: PUSH
32255: LD_INT 2
32257: NEG
32258: PUSH
32259: EMPTY
32260: LIST
32261: LIST
32262: PUSH
32263: LD_INT 1
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: EMPTY
32271: LIST
32272: LIST
32273: PUSH
32274: LD_INT 2
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 2
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: EMPTY
32291: LIST
32292: LIST
32293: PUSH
32294: LD_INT 2
32296: PUSH
32297: LD_INT 2
32299: PUSH
32300: EMPTY
32301: LIST
32302: LIST
32303: PUSH
32304: LD_INT 1
32306: PUSH
32307: LD_INT 2
32309: PUSH
32310: EMPTY
32311: LIST
32312: LIST
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: LD_INT 2
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 1
32326: NEG
32327: PUSH
32328: LD_INT 1
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 2
32337: NEG
32338: PUSH
32339: LD_INT 0
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 2
32348: NEG
32349: PUSH
32350: LD_INT 1
32352: NEG
32353: PUSH
32354: EMPTY
32355: LIST
32356: LIST
32357: PUSH
32358: LD_INT 2
32360: NEG
32361: PUSH
32362: LD_INT 2
32364: NEG
32365: PUSH
32366: EMPTY
32367: LIST
32368: LIST
32369: PUSH
32370: LD_INT 2
32372: NEG
32373: PUSH
32374: LD_INT 3
32376: NEG
32377: PUSH
32378: EMPTY
32379: LIST
32380: LIST
32381: PUSH
32382: LD_INT 1
32384: NEG
32385: PUSH
32386: LD_INT 3
32388: NEG
32389: PUSH
32390: EMPTY
32391: LIST
32392: LIST
32393: PUSH
32394: LD_INT 3
32396: NEG
32397: PUSH
32398: LD_INT 1
32400: NEG
32401: PUSH
32402: EMPTY
32403: LIST
32404: LIST
32405: PUSH
32406: LD_INT 3
32408: NEG
32409: PUSH
32410: LD_INT 2
32412: NEG
32413: PUSH
32414: EMPTY
32415: LIST
32416: LIST
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: LIST
32422: LIST
32423: LIST
32424: LIST
32425: LIST
32426: LIST
32427: LIST
32428: LIST
32429: LIST
32430: LIST
32431: LIST
32432: LIST
32433: LIST
32434: LIST
32435: LIST
32436: LIST
32437: LIST
32438: LIST
32439: LIST
32440: LIST
32441: LIST
32442: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32443: LD_ADDR_VAR 0 29
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: LD_INT 0
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 0
32460: PUSH
32461: LD_INT 1
32463: NEG
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: PUSH
32469: LD_INT 1
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: PUSH
32482: LD_INT 1
32484: PUSH
32485: EMPTY
32486: LIST
32487: LIST
32488: PUSH
32489: LD_INT 0
32491: PUSH
32492: LD_INT 1
32494: PUSH
32495: EMPTY
32496: LIST
32497: LIST
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: EMPTY
32507: LIST
32508: LIST
32509: PUSH
32510: LD_INT 1
32512: NEG
32513: PUSH
32514: LD_INT 1
32516: NEG
32517: PUSH
32518: EMPTY
32519: LIST
32520: LIST
32521: PUSH
32522: LD_INT 1
32524: NEG
32525: PUSH
32526: LD_INT 2
32528: NEG
32529: PUSH
32530: EMPTY
32531: LIST
32532: LIST
32533: PUSH
32534: LD_INT 0
32536: PUSH
32537: LD_INT 2
32539: NEG
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 1
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 2
32558: PUSH
32559: LD_INT 0
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: LD_INT 2
32568: PUSH
32569: LD_INT 1
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: LD_INT 1
32578: PUSH
32579: LD_INT 2
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 0
32588: PUSH
32589: LD_INT 2
32591: PUSH
32592: EMPTY
32593: LIST
32594: LIST
32595: PUSH
32596: LD_INT 1
32598: NEG
32599: PUSH
32600: LD_INT 1
32602: PUSH
32603: EMPTY
32604: LIST
32605: LIST
32606: PUSH
32607: LD_INT 2
32609: NEG
32610: PUSH
32611: LD_INT 1
32613: NEG
32614: PUSH
32615: EMPTY
32616: LIST
32617: LIST
32618: PUSH
32619: LD_INT 2
32621: NEG
32622: PUSH
32623: LD_INT 2
32625: NEG
32626: PUSH
32627: EMPTY
32628: LIST
32629: LIST
32630: PUSH
32631: LD_INT 2
32633: NEG
32634: PUSH
32635: LD_INT 3
32637: NEG
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 2
32645: PUSH
32646: LD_INT 1
32648: NEG
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 3
32656: PUSH
32657: LD_INT 1
32659: PUSH
32660: EMPTY
32661: LIST
32662: LIST
32663: PUSH
32664: LD_INT 1
32666: PUSH
32667: LD_INT 3
32669: PUSH
32670: EMPTY
32671: LIST
32672: LIST
32673: PUSH
32674: LD_INT 1
32676: NEG
32677: PUSH
32678: LD_INT 2
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 3
32687: NEG
32688: PUSH
32689: LD_INT 2
32691: NEG
32692: PUSH
32693: EMPTY
32694: LIST
32695: LIST
32696: PUSH
32697: EMPTY
32698: LIST
32699: LIST
32700: LIST
32701: LIST
32702: LIST
32703: LIST
32704: LIST
32705: LIST
32706: LIST
32707: LIST
32708: LIST
32709: LIST
32710: LIST
32711: LIST
32712: LIST
32713: LIST
32714: LIST
32715: LIST
32716: LIST
32717: LIST
32718: LIST
32719: LIST
32720: LIST
32721: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32722: LD_ADDR_VAR 0 30
32726: PUSH
32727: LD_INT 0
32729: PUSH
32730: LD_INT 0
32732: PUSH
32733: EMPTY
32734: LIST
32735: LIST
32736: PUSH
32737: LD_INT 0
32739: PUSH
32740: LD_INT 1
32742: NEG
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: LD_INT 1
32750: PUSH
32751: LD_INT 0
32753: PUSH
32754: EMPTY
32755: LIST
32756: LIST
32757: PUSH
32758: LD_INT 1
32760: PUSH
32761: LD_INT 1
32763: PUSH
32764: EMPTY
32765: LIST
32766: LIST
32767: PUSH
32768: LD_INT 0
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: EMPTY
32775: LIST
32776: LIST
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: LD_INT 0
32784: PUSH
32785: EMPTY
32786: LIST
32787: LIST
32788: PUSH
32789: LD_INT 1
32791: NEG
32792: PUSH
32793: LD_INT 1
32795: NEG
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 1
32803: NEG
32804: PUSH
32805: LD_INT 2
32807: NEG
32808: PUSH
32809: EMPTY
32810: LIST
32811: LIST
32812: PUSH
32813: LD_INT 0
32815: PUSH
32816: LD_INT 2
32818: NEG
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: PUSH
32827: LD_INT 1
32829: NEG
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 2
32837: PUSH
32838: LD_INT 0
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 2
32847: PUSH
32848: LD_INT 1
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 2
32857: PUSH
32858: LD_INT 2
32860: PUSH
32861: EMPTY
32862: LIST
32863: LIST
32864: PUSH
32865: LD_INT 1
32867: PUSH
32868: LD_INT 2
32870: PUSH
32871: EMPTY
32872: LIST
32873: LIST
32874: PUSH
32875: LD_INT 1
32877: NEG
32878: PUSH
32879: LD_INT 1
32881: PUSH
32882: EMPTY
32883: LIST
32884: LIST
32885: PUSH
32886: LD_INT 2
32888: NEG
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: EMPTY
32894: LIST
32895: LIST
32896: PUSH
32897: LD_INT 2
32899: NEG
32900: PUSH
32901: LD_INT 1
32903: NEG
32904: PUSH
32905: EMPTY
32906: LIST
32907: LIST
32908: PUSH
32909: LD_INT 1
32911: NEG
32912: PUSH
32913: LD_INT 3
32915: NEG
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: PUSH
32924: LD_INT 2
32926: NEG
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 3
32934: PUSH
32935: LD_INT 2
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 2
32944: PUSH
32945: LD_INT 3
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 2
32954: NEG
32955: PUSH
32956: LD_INT 1
32958: PUSH
32959: EMPTY
32960: LIST
32961: LIST
32962: PUSH
32963: LD_INT 3
32965: NEG
32966: PUSH
32967: LD_INT 1
32969: NEG
32970: PUSH
32971: EMPTY
32972: LIST
32973: LIST
32974: PUSH
32975: EMPTY
32976: LIST
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: LIST
32983: LIST
32984: LIST
32985: LIST
32986: LIST
32987: LIST
32988: LIST
32989: LIST
32990: LIST
32991: LIST
32992: LIST
32993: LIST
32994: LIST
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33000: LD_ADDR_VAR 0 31
33004: PUSH
33005: LD_INT 0
33007: PUSH
33008: LD_INT 0
33010: PUSH
33011: EMPTY
33012: LIST
33013: LIST
33014: PUSH
33015: LD_INT 0
33017: PUSH
33018: LD_INT 1
33020: NEG
33021: PUSH
33022: EMPTY
33023: LIST
33024: LIST
33025: PUSH
33026: LD_INT 1
33028: PUSH
33029: LD_INT 0
33031: PUSH
33032: EMPTY
33033: LIST
33034: LIST
33035: PUSH
33036: LD_INT 1
33038: PUSH
33039: LD_INT 1
33041: PUSH
33042: EMPTY
33043: LIST
33044: LIST
33045: PUSH
33046: LD_INT 0
33048: PUSH
33049: LD_INT 1
33051: PUSH
33052: EMPTY
33053: LIST
33054: LIST
33055: PUSH
33056: LD_INT 1
33058: NEG
33059: PUSH
33060: LD_INT 0
33062: PUSH
33063: EMPTY
33064: LIST
33065: LIST
33066: PUSH
33067: LD_INT 1
33069: NEG
33070: PUSH
33071: LD_INT 1
33073: NEG
33074: PUSH
33075: EMPTY
33076: LIST
33077: LIST
33078: PUSH
33079: LD_INT 1
33081: NEG
33082: PUSH
33083: LD_INT 2
33085: NEG
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 1
33093: PUSH
33094: LD_INT 1
33096: NEG
33097: PUSH
33098: EMPTY
33099: LIST
33100: LIST
33101: PUSH
33102: LD_INT 2
33104: PUSH
33105: LD_INT 0
33107: PUSH
33108: EMPTY
33109: LIST
33110: LIST
33111: PUSH
33112: LD_INT 2
33114: PUSH
33115: LD_INT 1
33117: PUSH
33118: EMPTY
33119: LIST
33120: LIST
33121: PUSH
33122: LD_INT 2
33124: PUSH
33125: LD_INT 2
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 1
33134: PUSH
33135: LD_INT 2
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 0
33144: PUSH
33145: LD_INT 2
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 1
33154: NEG
33155: PUSH
33156: LD_INT 1
33158: PUSH
33159: EMPTY
33160: LIST
33161: LIST
33162: PUSH
33163: LD_INT 2
33165: NEG
33166: PUSH
33167: LD_INT 1
33169: NEG
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 2
33177: NEG
33178: PUSH
33179: LD_INT 2
33181: NEG
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 2
33189: NEG
33190: PUSH
33191: LD_INT 3
33193: NEG
33194: PUSH
33195: EMPTY
33196: LIST
33197: LIST
33198: PUSH
33199: LD_INT 2
33201: PUSH
33202: LD_INT 1
33204: NEG
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 3
33212: PUSH
33213: LD_INT 1
33215: PUSH
33216: EMPTY
33217: LIST
33218: LIST
33219: PUSH
33220: LD_INT 1
33222: PUSH
33223: LD_INT 3
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: LD_INT 2
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 3
33243: NEG
33244: PUSH
33245: LD_INT 2
33247: NEG
33248: PUSH
33249: EMPTY
33250: LIST
33251: LIST
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: LIST
33257: LIST
33258: LIST
33259: LIST
33260: LIST
33261: LIST
33262: LIST
33263: LIST
33264: LIST
33265: LIST
33266: LIST
33267: LIST
33268: LIST
33269: LIST
33270: LIST
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33278: LD_ADDR_VAR 0 32
33282: PUSH
33283: LD_INT 0
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: EMPTY
33290: LIST
33291: LIST
33292: PUSH
33293: LD_INT 0
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: EMPTY
33301: LIST
33302: LIST
33303: PUSH
33304: LD_INT 1
33306: PUSH
33307: LD_INT 0
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: PUSH
33314: LD_INT 1
33316: PUSH
33317: LD_INT 1
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: LD_INT 1
33329: PUSH
33330: EMPTY
33331: LIST
33332: LIST
33333: PUSH
33334: LD_INT 1
33336: NEG
33337: PUSH
33338: LD_INT 0
33340: PUSH
33341: EMPTY
33342: LIST
33343: LIST
33344: PUSH
33345: LD_INT 1
33347: NEG
33348: PUSH
33349: LD_INT 1
33351: NEG
33352: PUSH
33353: EMPTY
33354: LIST
33355: LIST
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: LD_INT 2
33363: NEG
33364: PUSH
33365: EMPTY
33366: LIST
33367: LIST
33368: PUSH
33369: LD_INT 0
33371: PUSH
33372: LD_INT 2
33374: NEG
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PUSH
33380: LD_INT 1
33382: PUSH
33383: LD_INT 1
33385: NEG
33386: PUSH
33387: EMPTY
33388: LIST
33389: LIST
33390: PUSH
33391: LD_INT 2
33393: PUSH
33394: LD_INT 1
33396: PUSH
33397: EMPTY
33398: LIST
33399: LIST
33400: PUSH
33401: LD_INT 2
33403: PUSH
33404: LD_INT 2
33406: PUSH
33407: EMPTY
33408: LIST
33409: LIST
33410: PUSH
33411: LD_INT 1
33413: PUSH
33414: LD_INT 2
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 0
33423: PUSH
33424: LD_INT 2
33426: PUSH
33427: EMPTY
33428: LIST
33429: LIST
33430: PUSH
33431: LD_INT 1
33433: NEG
33434: PUSH
33435: LD_INT 1
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 2
33444: NEG
33445: PUSH
33446: LD_INT 0
33448: PUSH
33449: EMPTY
33450: LIST
33451: LIST
33452: PUSH
33453: LD_INT 2
33455: NEG
33456: PUSH
33457: LD_INT 1
33459: NEG
33460: PUSH
33461: EMPTY
33462: LIST
33463: LIST
33464: PUSH
33465: LD_INT 1
33467: NEG
33468: PUSH
33469: LD_INT 3
33471: NEG
33472: PUSH
33473: EMPTY
33474: LIST
33475: LIST
33476: PUSH
33477: LD_INT 1
33479: PUSH
33480: LD_INT 2
33482: NEG
33483: PUSH
33484: EMPTY
33485: LIST
33486: LIST
33487: PUSH
33488: LD_INT 3
33490: PUSH
33491: LD_INT 2
33493: PUSH
33494: EMPTY
33495: LIST
33496: LIST
33497: PUSH
33498: LD_INT 2
33500: PUSH
33501: LD_INT 3
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 2
33510: NEG
33511: PUSH
33512: LD_INT 1
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 3
33521: NEG
33522: PUSH
33523: LD_INT 1
33525: NEG
33526: PUSH
33527: EMPTY
33528: LIST
33529: LIST
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: LIST
33535: LIST
33536: LIST
33537: LIST
33538: LIST
33539: LIST
33540: LIST
33541: LIST
33542: LIST
33543: LIST
33544: LIST
33545: LIST
33546: LIST
33547: LIST
33548: LIST
33549: LIST
33550: LIST
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33556: LD_ADDR_VAR 0 33
33560: PUSH
33561: LD_INT 0
33563: PUSH
33564: LD_INT 0
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 0
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: EMPTY
33579: LIST
33580: LIST
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: LD_INT 0
33587: PUSH
33588: EMPTY
33589: LIST
33590: LIST
33591: PUSH
33592: LD_INT 1
33594: PUSH
33595: LD_INT 1
33597: PUSH
33598: EMPTY
33599: LIST
33600: LIST
33601: PUSH
33602: LD_INT 0
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 1
33614: NEG
33615: PUSH
33616: LD_INT 0
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 1
33625: NEG
33626: PUSH
33627: LD_INT 1
33629: NEG
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 1
33637: NEG
33638: PUSH
33639: LD_INT 2
33641: NEG
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 2
33660: PUSH
33661: LD_INT 0
33663: PUSH
33664: EMPTY
33665: LIST
33666: LIST
33667: PUSH
33668: LD_INT 2
33670: PUSH
33671: LD_INT 1
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 1
33680: PUSH
33681: LD_INT 2
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 0
33690: PUSH
33691: LD_INT 2
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 1
33700: NEG
33701: PUSH
33702: LD_INT 1
33704: PUSH
33705: EMPTY
33706: LIST
33707: LIST
33708: PUSH
33709: LD_INT 2
33711: NEG
33712: PUSH
33713: LD_INT 0
33715: PUSH
33716: EMPTY
33717: LIST
33718: LIST
33719: PUSH
33720: LD_INT 2
33722: NEG
33723: PUSH
33724: LD_INT 1
33726: NEG
33727: PUSH
33728: EMPTY
33729: LIST
33730: LIST
33731: PUSH
33732: LD_INT 2
33734: NEG
33735: PUSH
33736: LD_INT 2
33738: NEG
33739: PUSH
33740: EMPTY
33741: LIST
33742: LIST
33743: PUSH
33744: LD_INT 2
33746: NEG
33747: PUSH
33748: LD_INT 3
33750: NEG
33751: PUSH
33752: EMPTY
33753: LIST
33754: LIST
33755: PUSH
33756: LD_INT 2
33758: PUSH
33759: LD_INT 1
33761: NEG
33762: PUSH
33763: EMPTY
33764: LIST
33765: LIST
33766: PUSH
33767: LD_INT 3
33769: PUSH
33770: LD_INT 1
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: PUSH
33777: LD_INT 1
33779: PUSH
33780: LD_INT 3
33782: PUSH
33783: EMPTY
33784: LIST
33785: LIST
33786: PUSH
33787: LD_INT 1
33789: NEG
33790: PUSH
33791: LD_INT 2
33793: PUSH
33794: EMPTY
33795: LIST
33796: LIST
33797: PUSH
33798: LD_INT 3
33800: NEG
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: LIST
33814: LIST
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: LIST
33825: LIST
33826: LIST
33827: LIST
33828: LIST
33829: LIST
33830: LIST
33831: LIST
33832: LIST
33833: LIST
33834: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33835: LD_ADDR_VAR 0 34
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 0
33845: PUSH
33846: EMPTY
33847: LIST
33848: LIST
33849: PUSH
33850: LD_INT 0
33852: PUSH
33853: LD_INT 1
33855: NEG
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 0
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 1
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 0
33883: PUSH
33884: LD_INT 1
33886: PUSH
33887: EMPTY
33888: LIST
33889: LIST
33890: PUSH
33891: LD_INT 1
33893: NEG
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 1
33904: NEG
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: EMPTY
33911: LIST
33912: LIST
33913: PUSH
33914: LD_INT 1
33916: NEG
33917: PUSH
33918: LD_INT 2
33920: NEG
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: LD_INT 2
33931: NEG
33932: PUSH
33933: EMPTY
33934: LIST
33935: LIST
33936: PUSH
33937: LD_INT 1
33939: PUSH
33940: LD_INT 1
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 2
33950: PUSH
33951: LD_INT 1
33953: PUSH
33954: EMPTY
33955: LIST
33956: LIST
33957: PUSH
33958: LD_INT 2
33960: PUSH
33961: LD_INT 2
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: LD_INT 2
33973: PUSH
33974: EMPTY
33975: LIST
33976: LIST
33977: PUSH
33978: LD_INT 1
33980: NEG
33981: PUSH
33982: LD_INT 1
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 2
33991: NEG
33992: PUSH
33993: LD_INT 0
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 2
34002: NEG
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 2
34014: NEG
34015: PUSH
34016: LD_INT 2
34018: NEG
34019: PUSH
34020: EMPTY
34021: LIST
34022: LIST
34023: PUSH
34024: LD_INT 1
34026: NEG
34027: PUSH
34028: LD_INT 3
34030: NEG
34031: PUSH
34032: EMPTY
34033: LIST
34034: LIST
34035: PUSH
34036: LD_INT 1
34038: PUSH
34039: LD_INT 2
34041: NEG
34042: PUSH
34043: EMPTY
34044: LIST
34045: LIST
34046: PUSH
34047: LD_INT 3
34049: PUSH
34050: LD_INT 2
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: LD_INT 3
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: PUSH
34067: LD_INT 2
34069: NEG
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 3
34080: NEG
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: EMPTY
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: LIST
34096: LIST
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: LIST
34102: LIST
34103: LIST
34104: LIST
34105: LIST
34106: LIST
34107: LIST
34108: LIST
34109: LIST
34110: LIST
34111: LIST
34112: LIST
34113: LIST
34114: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34115: LD_ADDR_VAR 0 35
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 0
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 0
34132: PUSH
34133: LD_INT 1
34135: NEG
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 1
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 1
34153: PUSH
34154: LD_INT 1
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 0
34163: PUSH
34164: LD_INT 1
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 1
34173: NEG
34174: PUSH
34175: LD_INT 0
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 1
34184: NEG
34185: PUSH
34186: LD_INT 1
34188: NEG
34189: PUSH
34190: EMPTY
34191: LIST
34192: LIST
34193: PUSH
34194: LD_INT 2
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: EMPTY
34201: LIST
34202: LIST
34203: PUSH
34204: LD_INT 2
34206: NEG
34207: PUSH
34208: LD_INT 1
34210: NEG
34211: PUSH
34212: EMPTY
34213: LIST
34214: LIST
34215: PUSH
34216: EMPTY
34217: LIST
34218: LIST
34219: LIST
34220: LIST
34221: LIST
34222: LIST
34223: LIST
34224: LIST
34225: LIST
34226: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34227: LD_ADDR_VAR 0 36
34231: PUSH
34232: LD_INT 0
34234: PUSH
34235: LD_INT 0
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 0
34244: PUSH
34245: LD_INT 1
34247: NEG
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: PUSH
34256: LD_INT 0
34258: PUSH
34259: EMPTY
34260: LIST
34261: LIST
34262: PUSH
34263: LD_INT 1
34265: PUSH
34266: LD_INT 1
34268: PUSH
34269: EMPTY
34270: LIST
34271: LIST
34272: PUSH
34273: LD_INT 0
34275: PUSH
34276: LD_INT 1
34278: PUSH
34279: EMPTY
34280: LIST
34281: LIST
34282: PUSH
34283: LD_INT 1
34285: NEG
34286: PUSH
34287: LD_INT 0
34289: PUSH
34290: EMPTY
34291: LIST
34292: LIST
34293: PUSH
34294: LD_INT 1
34296: NEG
34297: PUSH
34298: LD_INT 1
34300: NEG
34301: PUSH
34302: EMPTY
34303: LIST
34304: LIST
34305: PUSH
34306: LD_INT 1
34308: NEG
34309: PUSH
34310: LD_INT 2
34312: NEG
34313: PUSH
34314: EMPTY
34315: LIST
34316: LIST
34317: PUSH
34318: LD_INT 1
34320: PUSH
34321: LD_INT 2
34323: PUSH
34324: EMPTY
34325: LIST
34326: LIST
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: LIST
34332: LIST
34333: LIST
34334: LIST
34335: LIST
34336: LIST
34337: LIST
34338: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34339: LD_ADDR_VAR 0 37
34343: PUSH
34344: LD_INT 0
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 0
34356: PUSH
34357: LD_INT 1
34359: NEG
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: LD_INT 0
34370: PUSH
34371: EMPTY
34372: LIST
34373: LIST
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 0
34387: PUSH
34388: LD_INT 1
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 1
34397: NEG
34398: PUSH
34399: LD_INT 0
34401: PUSH
34402: EMPTY
34403: LIST
34404: LIST
34405: PUSH
34406: LD_INT 1
34408: NEG
34409: PUSH
34410: LD_INT 1
34412: NEG
34413: PUSH
34414: EMPTY
34415: LIST
34416: LIST
34417: PUSH
34418: LD_INT 1
34420: PUSH
34421: LD_INT 1
34423: NEG
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: EMPTY
34441: LIST
34442: LIST
34443: LIST
34444: LIST
34445: LIST
34446: LIST
34447: LIST
34448: LIST
34449: LIST
34450: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34451: LD_ADDR_VAR 0 38
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 0
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 0
34468: PUSH
34469: LD_INT 1
34471: NEG
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: PUSH
34480: LD_INT 0
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 1
34489: PUSH
34490: LD_INT 1
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 0
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 1
34509: NEG
34510: PUSH
34511: LD_INT 0
34513: PUSH
34514: EMPTY
34515: LIST
34516: LIST
34517: PUSH
34518: LD_INT 1
34520: NEG
34521: PUSH
34522: LD_INT 1
34524: NEG
34525: PUSH
34526: EMPTY
34527: LIST
34528: LIST
34529: PUSH
34530: LD_INT 2
34532: PUSH
34533: LD_INT 1
34535: PUSH
34536: EMPTY
34537: LIST
34538: LIST
34539: PUSH
34540: LD_INT 2
34542: NEG
34543: PUSH
34544: LD_INT 1
34546: NEG
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: LIST
34556: LIST
34557: LIST
34558: LIST
34559: LIST
34560: LIST
34561: LIST
34562: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34563: LD_ADDR_VAR 0 39
34567: PUSH
34568: LD_INT 0
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: EMPTY
34575: LIST
34576: LIST
34577: PUSH
34578: LD_INT 0
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 1
34591: PUSH
34592: LD_INT 0
34594: PUSH
34595: EMPTY
34596: LIST
34597: LIST
34598: PUSH
34599: LD_INT 1
34601: PUSH
34602: LD_INT 1
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: PUSH
34609: LD_INT 0
34611: PUSH
34612: LD_INT 1
34614: PUSH
34615: EMPTY
34616: LIST
34617: LIST
34618: PUSH
34619: LD_INT 1
34621: NEG
34622: PUSH
34623: LD_INT 0
34625: PUSH
34626: EMPTY
34627: LIST
34628: LIST
34629: PUSH
34630: LD_INT 1
34632: NEG
34633: PUSH
34634: LD_INT 1
34636: NEG
34637: PUSH
34638: EMPTY
34639: LIST
34640: LIST
34641: PUSH
34642: LD_INT 1
34644: NEG
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: EMPTY
34651: LIST
34652: LIST
34653: PUSH
34654: LD_INT 1
34656: PUSH
34657: LD_INT 2
34659: PUSH
34660: EMPTY
34661: LIST
34662: LIST
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: LIST
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34675: LD_ADDR_VAR 0 40
34679: PUSH
34680: LD_INT 0
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: EMPTY
34687: LIST
34688: LIST
34689: PUSH
34690: LD_INT 0
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: EMPTY
34698: LIST
34699: LIST
34700: PUSH
34701: LD_INT 1
34703: PUSH
34704: LD_INT 0
34706: PUSH
34707: EMPTY
34708: LIST
34709: LIST
34710: PUSH
34711: LD_INT 1
34713: PUSH
34714: LD_INT 1
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 0
34723: PUSH
34724: LD_INT 1
34726: PUSH
34727: EMPTY
34728: LIST
34729: LIST
34730: PUSH
34731: LD_INT 1
34733: NEG
34734: PUSH
34735: LD_INT 0
34737: PUSH
34738: EMPTY
34739: LIST
34740: LIST
34741: PUSH
34742: LD_INT 1
34744: NEG
34745: PUSH
34746: LD_INT 1
34748: NEG
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 1
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 1
34767: NEG
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: EMPTY
34773: LIST
34774: LIST
34775: PUSH
34776: EMPTY
34777: LIST
34778: LIST
34779: LIST
34780: LIST
34781: LIST
34782: LIST
34783: LIST
34784: LIST
34785: LIST
34786: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34787: LD_ADDR_VAR 0 41
34791: PUSH
34792: LD_INT 0
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 0
34804: PUSH
34805: LD_INT 1
34807: NEG
34808: PUSH
34809: EMPTY
34810: LIST
34811: LIST
34812: PUSH
34813: LD_INT 1
34815: PUSH
34816: LD_INT 0
34818: PUSH
34819: EMPTY
34820: LIST
34821: LIST
34822: PUSH
34823: LD_INT 1
34825: PUSH
34826: LD_INT 1
34828: PUSH
34829: EMPTY
34830: LIST
34831: LIST
34832: PUSH
34833: LD_INT 0
34835: PUSH
34836: LD_INT 1
34838: PUSH
34839: EMPTY
34840: LIST
34841: LIST
34842: PUSH
34843: LD_INT 1
34845: NEG
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: EMPTY
34851: LIST
34852: LIST
34853: PUSH
34854: LD_INT 1
34856: NEG
34857: PUSH
34858: LD_INT 1
34860: NEG
34861: PUSH
34862: EMPTY
34863: LIST
34864: LIST
34865: PUSH
34866: LD_INT 1
34868: NEG
34869: PUSH
34870: LD_INT 2
34872: NEG
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 1
34880: PUSH
34881: LD_INT 1
34883: NEG
34884: PUSH
34885: EMPTY
34886: LIST
34887: LIST
34888: PUSH
34889: LD_INT 2
34891: PUSH
34892: LD_INT 0
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 2
34901: PUSH
34902: LD_INT 1
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: PUSH
34909: LD_INT 2
34911: PUSH
34912: LD_INT 2
34914: PUSH
34915: EMPTY
34916: LIST
34917: LIST
34918: PUSH
34919: LD_INT 1
34921: PUSH
34922: LD_INT 2
34924: PUSH
34925: EMPTY
34926: LIST
34927: LIST
34928: PUSH
34929: LD_INT 1
34931: NEG
34932: PUSH
34933: LD_INT 1
34935: PUSH
34936: EMPTY
34937: LIST
34938: LIST
34939: PUSH
34940: LD_INT 2
34942: NEG
34943: PUSH
34944: LD_INT 0
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 2
34953: NEG
34954: PUSH
34955: LD_INT 1
34957: NEG
34958: PUSH
34959: EMPTY
34960: LIST
34961: LIST
34962: PUSH
34963: LD_INT 2
34965: NEG
34966: PUSH
34967: LD_INT 2
34969: NEG
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 2
34977: NEG
34978: PUSH
34979: LD_INT 3
34981: NEG
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: PUSH
34990: LD_INT 1
34992: NEG
34993: PUSH
34994: EMPTY
34995: LIST
34996: LIST
34997: PUSH
34998: LD_INT 3
35000: PUSH
35001: LD_INT 0
35003: PUSH
35004: EMPTY
35005: LIST
35006: LIST
35007: PUSH
35008: LD_INT 3
35010: PUSH
35011: LD_INT 1
35013: PUSH
35014: EMPTY
35015: LIST
35016: LIST
35017: PUSH
35018: LD_INT 3
35020: PUSH
35021: LD_INT 2
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PUSH
35028: LD_INT 3
35030: PUSH
35031: LD_INT 3
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 2
35040: PUSH
35041: LD_INT 3
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 2
35050: NEG
35051: PUSH
35052: LD_INT 1
35054: PUSH
35055: EMPTY
35056: LIST
35057: LIST
35058: PUSH
35059: LD_INT 3
35061: NEG
35062: PUSH
35063: LD_INT 0
35065: PUSH
35066: EMPTY
35067: LIST
35068: LIST
35069: PUSH
35070: LD_INT 3
35072: NEG
35073: PUSH
35074: LD_INT 1
35076: NEG
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 3
35084: NEG
35085: PUSH
35086: LD_INT 2
35088: NEG
35089: PUSH
35090: EMPTY
35091: LIST
35092: LIST
35093: PUSH
35094: LD_INT 3
35096: NEG
35097: PUSH
35098: LD_INT 3
35100: NEG
35101: PUSH
35102: EMPTY
35103: LIST
35104: LIST
35105: PUSH
35106: EMPTY
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: LIST
35112: LIST
35113: LIST
35114: LIST
35115: LIST
35116: LIST
35117: LIST
35118: LIST
35119: LIST
35120: LIST
35121: LIST
35122: LIST
35123: LIST
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: LIST
35129: LIST
35130: LIST
35131: LIST
35132: LIST
35133: LIST
35134: LIST
35135: LIST
35136: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35137: LD_ADDR_VAR 0 42
35141: PUSH
35142: LD_INT 0
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 0
35154: PUSH
35155: LD_INT 1
35157: NEG
35158: PUSH
35159: EMPTY
35160: LIST
35161: LIST
35162: PUSH
35163: LD_INT 1
35165: PUSH
35166: LD_INT 0
35168: PUSH
35169: EMPTY
35170: LIST
35171: LIST
35172: PUSH
35173: LD_INT 1
35175: PUSH
35176: LD_INT 1
35178: PUSH
35179: EMPTY
35180: LIST
35181: LIST
35182: PUSH
35183: LD_INT 0
35185: PUSH
35186: LD_INT 1
35188: PUSH
35189: EMPTY
35190: LIST
35191: LIST
35192: PUSH
35193: LD_INT 1
35195: NEG
35196: PUSH
35197: LD_INT 0
35199: PUSH
35200: EMPTY
35201: LIST
35202: LIST
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: LD_INT 1
35210: NEG
35211: PUSH
35212: EMPTY
35213: LIST
35214: LIST
35215: PUSH
35216: LD_INT 1
35218: NEG
35219: PUSH
35220: LD_INT 2
35222: NEG
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: LD_INT 2
35233: NEG
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 1
35241: PUSH
35242: LD_INT 1
35244: NEG
35245: PUSH
35246: EMPTY
35247: LIST
35248: LIST
35249: PUSH
35250: LD_INT 2
35252: PUSH
35253: LD_INT 1
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 2
35262: PUSH
35263: LD_INT 2
35265: PUSH
35266: EMPTY
35267: LIST
35268: LIST
35269: PUSH
35270: LD_INT 1
35272: PUSH
35273: LD_INT 2
35275: PUSH
35276: EMPTY
35277: LIST
35278: LIST
35279: PUSH
35280: LD_INT 0
35282: PUSH
35283: LD_INT 2
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 1
35292: NEG
35293: PUSH
35294: LD_INT 1
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 2
35303: NEG
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: EMPTY
35310: LIST
35311: LIST
35312: PUSH
35313: LD_INT 2
35315: NEG
35316: PUSH
35317: LD_INT 2
35319: NEG
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 2
35327: NEG
35328: PUSH
35329: LD_INT 3
35331: NEG
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: NEG
35340: PUSH
35341: LD_INT 3
35343: NEG
35344: PUSH
35345: EMPTY
35346: LIST
35347: LIST
35348: PUSH
35349: LD_INT 0
35351: PUSH
35352: LD_INT 3
35354: NEG
35355: PUSH
35356: EMPTY
35357: LIST
35358: LIST
35359: PUSH
35360: LD_INT 1
35362: PUSH
35363: LD_INT 2
35365: NEG
35366: PUSH
35367: EMPTY
35368: LIST
35369: LIST
35370: PUSH
35371: LD_INT 3
35373: PUSH
35374: LD_INT 2
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: LD_INT 3
35383: PUSH
35384: LD_INT 3
35386: PUSH
35387: EMPTY
35388: LIST
35389: LIST
35390: PUSH
35391: LD_INT 2
35393: PUSH
35394: LD_INT 3
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 1
35403: PUSH
35404: LD_INT 3
35406: PUSH
35407: EMPTY
35408: LIST
35409: LIST
35410: PUSH
35411: LD_INT 0
35413: PUSH
35414: LD_INT 3
35416: PUSH
35417: EMPTY
35418: LIST
35419: LIST
35420: PUSH
35421: LD_INT 1
35423: NEG
35424: PUSH
35425: LD_INT 2
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 3
35434: NEG
35435: PUSH
35436: LD_INT 2
35438: NEG
35439: PUSH
35440: EMPTY
35441: LIST
35442: LIST
35443: PUSH
35444: LD_INT 3
35446: NEG
35447: PUSH
35448: LD_INT 3
35450: NEG
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: LIST
35472: LIST
35473: LIST
35474: LIST
35475: LIST
35476: LIST
35477: LIST
35478: LIST
35479: LIST
35480: LIST
35481: LIST
35482: LIST
35483: LIST
35484: LIST
35485: LIST
35486: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35487: LD_ADDR_VAR 0 43
35491: PUSH
35492: LD_INT 0
35494: PUSH
35495: LD_INT 0
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 0
35504: PUSH
35505: LD_INT 1
35507: NEG
35508: PUSH
35509: EMPTY
35510: LIST
35511: LIST
35512: PUSH
35513: LD_INT 1
35515: PUSH
35516: LD_INT 0
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 1
35525: PUSH
35526: LD_INT 1
35528: PUSH
35529: EMPTY
35530: LIST
35531: LIST
35532: PUSH
35533: LD_INT 0
35535: PUSH
35536: LD_INT 1
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 1
35545: NEG
35546: PUSH
35547: LD_INT 0
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 1
35556: NEG
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 1
35568: NEG
35569: PUSH
35570: LD_INT 2
35572: NEG
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 0
35580: PUSH
35581: LD_INT 2
35583: NEG
35584: PUSH
35585: EMPTY
35586: LIST
35587: LIST
35588: PUSH
35589: LD_INT 1
35591: PUSH
35592: LD_INT 1
35594: NEG
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 2
35602: PUSH
35603: LD_INT 0
35605: PUSH
35606: EMPTY
35607: LIST
35608: LIST
35609: PUSH
35610: LD_INT 2
35612: PUSH
35613: LD_INT 1
35615: PUSH
35616: EMPTY
35617: LIST
35618: LIST
35619: PUSH
35620: LD_INT 1
35622: PUSH
35623: LD_INT 2
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: EMPTY
35637: LIST
35638: LIST
35639: PUSH
35640: LD_INT 1
35642: NEG
35643: PUSH
35644: LD_INT 1
35646: PUSH
35647: EMPTY
35648: LIST
35649: LIST
35650: PUSH
35651: LD_INT 2
35653: NEG
35654: PUSH
35655: LD_INT 0
35657: PUSH
35658: EMPTY
35659: LIST
35660: LIST
35661: PUSH
35662: LD_INT 2
35664: NEG
35665: PUSH
35666: LD_INT 1
35668: NEG
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 1
35676: NEG
35677: PUSH
35678: LD_INT 3
35680: NEG
35681: PUSH
35682: EMPTY
35683: LIST
35684: LIST
35685: PUSH
35686: LD_INT 0
35688: PUSH
35689: LD_INT 3
35691: NEG
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 1
35699: PUSH
35700: LD_INT 2
35702: NEG
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 2
35710: PUSH
35711: LD_INT 1
35713: NEG
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: LD_INT 3
35721: PUSH
35722: LD_INT 0
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: LD_INT 3
35731: PUSH
35732: LD_INT 1
35734: PUSH
35735: EMPTY
35736: LIST
35737: LIST
35738: PUSH
35739: LD_INT 1
35741: PUSH
35742: LD_INT 3
35744: PUSH
35745: EMPTY
35746: LIST
35747: LIST
35748: PUSH
35749: LD_INT 0
35751: PUSH
35752: LD_INT 3
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: LD_INT 1
35761: NEG
35762: PUSH
35763: LD_INT 2
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: LD_INT 2
35772: NEG
35773: PUSH
35774: LD_INT 1
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PUSH
35781: LD_INT 3
35783: NEG
35784: PUSH
35785: LD_INT 0
35787: PUSH
35788: EMPTY
35789: LIST
35790: LIST
35791: PUSH
35792: LD_INT 3
35794: NEG
35795: PUSH
35796: LD_INT 1
35798: NEG
35799: PUSH
35800: EMPTY
35801: LIST
35802: LIST
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: LIST
35808: LIST
35809: LIST
35810: LIST
35811: LIST
35812: LIST
35813: LIST
35814: LIST
35815: LIST
35816: LIST
35817: LIST
35818: LIST
35819: LIST
35820: LIST
35821: LIST
35822: LIST
35823: LIST
35824: LIST
35825: LIST
35826: LIST
35827: LIST
35828: LIST
35829: LIST
35830: LIST
35831: LIST
35832: LIST
35833: LIST
35834: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35835: LD_ADDR_VAR 0 44
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: LD_INT 0
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 0
35852: PUSH
35853: LD_INT 1
35855: NEG
35856: PUSH
35857: EMPTY
35858: LIST
35859: LIST
35860: PUSH
35861: LD_INT 1
35863: PUSH
35864: LD_INT 0
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: PUSH
35874: LD_INT 1
35876: PUSH
35877: EMPTY
35878: LIST
35879: LIST
35880: PUSH
35881: LD_INT 0
35883: PUSH
35884: LD_INT 1
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 1
35893: NEG
35894: PUSH
35895: LD_INT 0
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: LD_INT 1
35904: NEG
35905: PUSH
35906: LD_INT 1
35908: NEG
35909: PUSH
35910: EMPTY
35911: LIST
35912: LIST
35913: PUSH
35914: LD_INT 1
35916: NEG
35917: PUSH
35918: LD_INT 2
35920: NEG
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 1
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: EMPTY
35934: LIST
35935: LIST
35936: PUSH
35937: LD_INT 2
35939: PUSH
35940: LD_INT 0
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: PUSH
35950: LD_INT 1
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 2
35959: PUSH
35960: LD_INT 2
35962: PUSH
35963: EMPTY
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 1
35969: PUSH
35970: LD_INT 2
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 1
35979: NEG
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 2
35990: NEG
35991: PUSH
35992: LD_INT 0
35994: PUSH
35995: EMPTY
35996: LIST
35997: LIST
35998: PUSH
35999: LD_INT 2
36001: NEG
36002: PUSH
36003: LD_INT 1
36005: NEG
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 2
36013: NEG
36014: PUSH
36015: LD_INT 2
36017: NEG
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 2
36025: NEG
36026: PUSH
36027: LD_INT 3
36029: NEG
36030: PUSH
36031: EMPTY
36032: LIST
36033: LIST
36034: PUSH
36035: LD_INT 2
36037: PUSH
36038: LD_INT 1
36040: NEG
36041: PUSH
36042: EMPTY
36043: LIST
36044: LIST
36045: PUSH
36046: LD_INT 3
36048: PUSH
36049: LD_INT 0
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 3
36058: PUSH
36059: LD_INT 1
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 3
36068: PUSH
36069: LD_INT 2
36071: PUSH
36072: EMPTY
36073: LIST
36074: LIST
36075: PUSH
36076: LD_INT 3
36078: PUSH
36079: LD_INT 3
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: LD_INT 2
36088: PUSH
36089: LD_INT 3
36091: PUSH
36092: EMPTY
36093: LIST
36094: LIST
36095: PUSH
36096: LD_INT 2
36098: NEG
36099: PUSH
36100: LD_INT 1
36102: PUSH
36103: EMPTY
36104: LIST
36105: LIST
36106: PUSH
36107: LD_INT 3
36109: NEG
36110: PUSH
36111: LD_INT 0
36113: PUSH
36114: EMPTY
36115: LIST
36116: LIST
36117: PUSH
36118: LD_INT 3
36120: NEG
36121: PUSH
36122: LD_INT 1
36124: NEG
36125: PUSH
36126: EMPTY
36127: LIST
36128: LIST
36129: PUSH
36130: LD_INT 3
36132: NEG
36133: PUSH
36134: LD_INT 2
36136: NEG
36137: PUSH
36138: EMPTY
36139: LIST
36140: LIST
36141: PUSH
36142: LD_INT 3
36144: NEG
36145: PUSH
36146: LD_INT 3
36148: NEG
36149: PUSH
36150: EMPTY
36151: LIST
36152: LIST
36153: PUSH
36154: EMPTY
36155: LIST
36156: LIST
36157: LIST
36158: LIST
36159: LIST
36160: LIST
36161: LIST
36162: LIST
36163: LIST
36164: LIST
36165: LIST
36166: LIST
36167: LIST
36168: LIST
36169: LIST
36170: LIST
36171: LIST
36172: LIST
36173: LIST
36174: LIST
36175: LIST
36176: LIST
36177: LIST
36178: LIST
36179: LIST
36180: LIST
36181: LIST
36182: LIST
36183: LIST
36184: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36185: LD_ADDR_VAR 0 45
36189: PUSH
36190: LD_INT 0
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 0
36202: PUSH
36203: LD_INT 1
36205: NEG
36206: PUSH
36207: EMPTY
36208: LIST
36209: LIST
36210: PUSH
36211: LD_INT 1
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: EMPTY
36218: LIST
36219: LIST
36220: PUSH
36221: LD_INT 1
36223: PUSH
36224: LD_INT 1
36226: PUSH
36227: EMPTY
36228: LIST
36229: LIST
36230: PUSH
36231: LD_INT 0
36233: PUSH
36234: LD_INT 1
36236: PUSH
36237: EMPTY
36238: LIST
36239: LIST
36240: PUSH
36241: LD_INT 1
36243: NEG
36244: PUSH
36245: LD_INT 0
36247: PUSH
36248: EMPTY
36249: LIST
36250: LIST
36251: PUSH
36252: LD_INT 1
36254: NEG
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: EMPTY
36261: LIST
36262: LIST
36263: PUSH
36264: LD_INT 1
36266: NEG
36267: PUSH
36268: LD_INT 2
36270: NEG
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 2
36281: NEG
36282: PUSH
36283: EMPTY
36284: LIST
36285: LIST
36286: PUSH
36287: LD_INT 1
36289: PUSH
36290: LD_INT 1
36292: NEG
36293: PUSH
36294: EMPTY
36295: LIST
36296: LIST
36297: PUSH
36298: LD_INT 2
36300: PUSH
36301: LD_INT 1
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: PUSH
36311: LD_INT 2
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 1
36320: PUSH
36321: LD_INT 2
36323: PUSH
36324: EMPTY
36325: LIST
36326: LIST
36327: PUSH
36328: LD_INT 0
36330: PUSH
36331: LD_INT 2
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: LD_INT 1
36340: NEG
36341: PUSH
36342: LD_INT 1
36344: PUSH
36345: EMPTY
36346: LIST
36347: LIST
36348: PUSH
36349: LD_INT 2
36351: NEG
36352: PUSH
36353: LD_INT 1
36355: NEG
36356: PUSH
36357: EMPTY
36358: LIST
36359: LIST
36360: PUSH
36361: LD_INT 2
36363: NEG
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: EMPTY
36370: LIST
36371: LIST
36372: PUSH
36373: LD_INT 2
36375: NEG
36376: PUSH
36377: LD_INT 3
36379: NEG
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: NEG
36388: PUSH
36389: LD_INT 3
36391: NEG
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 0
36399: PUSH
36400: LD_INT 3
36402: NEG
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: PUSH
36411: LD_INT 2
36413: NEG
36414: PUSH
36415: EMPTY
36416: LIST
36417: LIST
36418: PUSH
36419: LD_INT 3
36421: PUSH
36422: LD_INT 2
36424: PUSH
36425: EMPTY
36426: LIST
36427: LIST
36428: PUSH
36429: LD_INT 3
36431: PUSH
36432: LD_INT 3
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 2
36441: PUSH
36442: LD_INT 3
36444: PUSH
36445: EMPTY
36446: LIST
36447: LIST
36448: PUSH
36449: LD_INT 1
36451: PUSH
36452: LD_INT 3
36454: PUSH
36455: EMPTY
36456: LIST
36457: LIST
36458: PUSH
36459: LD_INT 0
36461: PUSH
36462: LD_INT 3
36464: PUSH
36465: EMPTY
36466: LIST
36467: LIST
36468: PUSH
36469: LD_INT 1
36471: NEG
36472: PUSH
36473: LD_INT 2
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 3
36482: NEG
36483: PUSH
36484: LD_INT 2
36486: NEG
36487: PUSH
36488: EMPTY
36489: LIST
36490: LIST
36491: PUSH
36492: LD_INT 3
36494: NEG
36495: PUSH
36496: LD_INT 3
36498: NEG
36499: PUSH
36500: EMPTY
36501: LIST
36502: LIST
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: LIST
36508: LIST
36509: LIST
36510: LIST
36511: LIST
36512: LIST
36513: LIST
36514: LIST
36515: LIST
36516: LIST
36517: LIST
36518: LIST
36519: LIST
36520: LIST
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36535: LD_ADDR_VAR 0 46
36539: PUSH
36540: LD_INT 0
36542: PUSH
36543: LD_INT 0
36545: PUSH
36546: EMPTY
36547: LIST
36548: LIST
36549: PUSH
36550: LD_INT 0
36552: PUSH
36553: LD_INT 1
36555: NEG
36556: PUSH
36557: EMPTY
36558: LIST
36559: LIST
36560: PUSH
36561: LD_INT 1
36563: PUSH
36564: LD_INT 0
36566: PUSH
36567: EMPTY
36568: LIST
36569: LIST
36570: PUSH
36571: LD_INT 1
36573: PUSH
36574: LD_INT 1
36576: PUSH
36577: EMPTY
36578: LIST
36579: LIST
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: LD_INT 1
36586: PUSH
36587: EMPTY
36588: LIST
36589: LIST
36590: PUSH
36591: LD_INT 1
36593: NEG
36594: PUSH
36595: LD_INT 0
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 1
36604: NEG
36605: PUSH
36606: LD_INT 1
36608: NEG
36609: PUSH
36610: EMPTY
36611: LIST
36612: LIST
36613: PUSH
36614: LD_INT 1
36616: NEG
36617: PUSH
36618: LD_INT 2
36620: NEG
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 0
36628: PUSH
36629: LD_INT 2
36631: NEG
36632: PUSH
36633: EMPTY
36634: LIST
36635: LIST
36636: PUSH
36637: LD_INT 1
36639: PUSH
36640: LD_INT 1
36642: NEG
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PUSH
36648: LD_INT 2
36650: PUSH
36651: LD_INT 0
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 2
36660: PUSH
36661: LD_INT 1
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: LD_INT 2
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: LD_INT 2
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 1
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 2
36701: NEG
36702: PUSH
36703: LD_INT 0
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 2
36712: NEG
36713: PUSH
36714: LD_INT 1
36716: NEG
36717: PUSH
36718: EMPTY
36719: LIST
36720: LIST
36721: PUSH
36722: LD_INT 1
36724: NEG
36725: PUSH
36726: LD_INT 3
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 0
36736: PUSH
36737: LD_INT 3
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 1
36747: PUSH
36748: LD_INT 2
36750: NEG
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 2
36758: PUSH
36759: LD_INT 1
36761: NEG
36762: PUSH
36763: EMPTY
36764: LIST
36765: LIST
36766: PUSH
36767: LD_INT 3
36769: PUSH
36770: LD_INT 0
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: PUSH
36777: LD_INT 3
36779: PUSH
36780: LD_INT 1
36782: PUSH
36783: EMPTY
36784: LIST
36785: LIST
36786: PUSH
36787: LD_INT 1
36789: PUSH
36790: LD_INT 3
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 0
36799: PUSH
36800: LD_INT 3
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 1
36809: NEG
36810: PUSH
36811: LD_INT 2
36813: PUSH
36814: EMPTY
36815: LIST
36816: LIST
36817: PUSH
36818: LD_INT 2
36820: NEG
36821: PUSH
36822: LD_INT 1
36824: PUSH
36825: EMPTY
36826: LIST
36827: LIST
36828: PUSH
36829: LD_INT 3
36831: NEG
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 3
36842: NEG
36843: PUSH
36844: LD_INT 1
36846: NEG
36847: PUSH
36848: EMPTY
36849: LIST
36850: LIST
36851: PUSH
36852: EMPTY
36853: LIST
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: LIST
36860: LIST
36861: LIST
36862: LIST
36863: LIST
36864: LIST
36865: LIST
36866: LIST
36867: LIST
36868: LIST
36869: LIST
36870: LIST
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36883: LD_ADDR_VAR 0 47
36887: PUSH
36888: LD_INT 0
36890: PUSH
36891: LD_INT 0
36893: PUSH
36894: EMPTY
36895: LIST
36896: LIST
36897: PUSH
36898: LD_INT 0
36900: PUSH
36901: LD_INT 1
36903: NEG
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: LD_INT 1
36911: PUSH
36912: LD_INT 0
36914: PUSH
36915: EMPTY
36916: LIST
36917: LIST
36918: PUSH
36919: LD_INT 1
36921: PUSH
36922: LD_INT 1
36924: PUSH
36925: EMPTY
36926: LIST
36927: LIST
36928: PUSH
36929: LD_INT 0
36931: PUSH
36932: LD_INT 1
36934: PUSH
36935: EMPTY
36936: LIST
36937: LIST
36938: PUSH
36939: LD_INT 1
36941: NEG
36942: PUSH
36943: LD_INT 0
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 1
36952: NEG
36953: PUSH
36954: LD_INT 1
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 1
36964: NEG
36965: PUSH
36966: LD_INT 2
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 0
36976: PUSH
36977: LD_INT 2
36979: NEG
36980: PUSH
36981: EMPTY
36982: LIST
36983: LIST
36984: PUSH
36985: LD_INT 1
36987: PUSH
36988: LD_INT 1
36990: NEG
36991: PUSH
36992: EMPTY
36993: LIST
36994: LIST
36995: PUSH
36996: LD_INT 2
36998: NEG
36999: PUSH
37000: LD_INT 1
37002: NEG
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 2
37010: NEG
37011: PUSH
37012: LD_INT 2
37014: NEG
37015: PUSH
37016: EMPTY
37017: LIST
37018: LIST
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
37034: LD_ADDR_VAR 0 48
37038: PUSH
37039: LD_INT 0
37041: PUSH
37042: LD_INT 0
37044: PUSH
37045: EMPTY
37046: LIST
37047: LIST
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: LD_INT 1
37054: NEG
37055: PUSH
37056: EMPTY
37057: LIST
37058: LIST
37059: PUSH
37060: LD_INT 1
37062: PUSH
37063: LD_INT 0
37065: PUSH
37066: EMPTY
37067: LIST
37068: LIST
37069: PUSH
37070: LD_INT 1
37072: PUSH
37073: LD_INT 1
37075: PUSH
37076: EMPTY
37077: LIST
37078: LIST
37079: PUSH
37080: LD_INT 0
37082: PUSH
37083: LD_INT 1
37085: PUSH
37086: EMPTY
37087: LIST
37088: LIST
37089: PUSH
37090: LD_INT 1
37092: NEG
37093: PUSH
37094: LD_INT 0
37096: PUSH
37097: EMPTY
37098: LIST
37099: LIST
37100: PUSH
37101: LD_INT 1
37103: NEG
37104: PUSH
37105: LD_INT 1
37107: NEG
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 1
37115: NEG
37116: PUSH
37117: LD_INT 2
37119: NEG
37120: PUSH
37121: EMPTY
37122: LIST
37123: LIST
37124: PUSH
37125: LD_INT 0
37127: PUSH
37128: LD_INT 2
37130: NEG
37131: PUSH
37132: EMPTY
37133: LIST
37134: LIST
37135: PUSH
37136: LD_INT 1
37138: PUSH
37139: LD_INT 1
37141: NEG
37142: PUSH
37143: EMPTY
37144: LIST
37145: LIST
37146: PUSH
37147: LD_INT 2
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: EMPTY
37154: LIST
37155: LIST
37156: PUSH
37157: LD_INT 2
37159: PUSH
37160: LD_INT 1
37162: PUSH
37163: EMPTY
37164: LIST
37165: LIST
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: LIST
37171: LIST
37172: LIST
37173: LIST
37174: LIST
37175: LIST
37176: LIST
37177: LIST
37178: LIST
37179: LIST
37180: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
37181: LD_ADDR_VAR 0 49
37185: PUSH
37186: LD_INT 0
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PUSH
37196: LD_INT 0
37198: PUSH
37199: LD_INT 1
37201: NEG
37202: PUSH
37203: EMPTY
37204: LIST
37205: LIST
37206: PUSH
37207: LD_INT 1
37209: PUSH
37210: LD_INT 0
37212: PUSH
37213: EMPTY
37214: LIST
37215: LIST
37216: PUSH
37217: LD_INT 1
37219: PUSH
37220: LD_INT 1
37222: PUSH
37223: EMPTY
37224: LIST
37225: LIST
37226: PUSH
37227: LD_INT 0
37229: PUSH
37230: LD_INT 1
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 1
37239: NEG
37240: PUSH
37241: LD_INT 0
37243: PUSH
37244: EMPTY
37245: LIST
37246: LIST
37247: PUSH
37248: LD_INT 1
37250: NEG
37251: PUSH
37252: LD_INT 1
37254: NEG
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 1
37262: PUSH
37263: LD_INT 1
37265: NEG
37266: PUSH
37267: EMPTY
37268: LIST
37269: LIST
37270: PUSH
37271: LD_INT 2
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 2
37283: PUSH
37284: LD_INT 1
37286: PUSH
37287: EMPTY
37288: LIST
37289: LIST
37290: PUSH
37291: LD_INT 2
37293: PUSH
37294: LD_INT 2
37296: PUSH
37297: EMPTY
37298: LIST
37299: LIST
37300: PUSH
37301: LD_INT 1
37303: PUSH
37304: LD_INT 2
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
37325: LD_ADDR_VAR 0 50
37329: PUSH
37330: LD_INT 0
37332: PUSH
37333: LD_INT 0
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 0
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 1
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 1
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 0
37373: PUSH
37374: LD_INT 1
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 1
37383: NEG
37384: PUSH
37385: LD_INT 0
37387: PUSH
37388: EMPTY
37389: LIST
37390: LIST
37391: PUSH
37392: LD_INT 1
37394: NEG
37395: PUSH
37396: LD_INT 1
37398: NEG
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 2
37406: PUSH
37407: LD_INT 1
37409: PUSH
37410: EMPTY
37411: LIST
37412: LIST
37413: PUSH
37414: LD_INT 2
37416: PUSH
37417: LD_INT 2
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: LD_INT 1
37426: PUSH
37427: LD_INT 2
37429: PUSH
37430: EMPTY
37431: LIST
37432: LIST
37433: PUSH
37434: LD_INT 0
37436: PUSH
37437: LD_INT 2
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 1
37450: PUSH
37451: EMPTY
37452: LIST
37453: LIST
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: LIST
37459: LIST
37460: LIST
37461: LIST
37462: LIST
37463: LIST
37464: LIST
37465: LIST
37466: LIST
37467: LIST
37468: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37469: LD_ADDR_VAR 0 51
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: LD_INT 0
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PUSH
37484: LD_INT 0
37486: PUSH
37487: LD_INT 1
37489: NEG
37490: PUSH
37491: EMPTY
37492: LIST
37493: LIST
37494: PUSH
37495: LD_INT 1
37497: PUSH
37498: LD_INT 0
37500: PUSH
37501: EMPTY
37502: LIST
37503: LIST
37504: PUSH
37505: LD_INT 1
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: EMPTY
37512: LIST
37513: LIST
37514: PUSH
37515: LD_INT 0
37517: PUSH
37518: LD_INT 1
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 1
37527: NEG
37528: PUSH
37529: LD_INT 0
37531: PUSH
37532: EMPTY
37533: LIST
37534: LIST
37535: PUSH
37536: LD_INT 1
37538: NEG
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 1
37550: PUSH
37551: LD_INT 2
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 0
37560: PUSH
37561: LD_INT 2
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: NEG
37571: PUSH
37572: LD_INT 1
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 2
37581: NEG
37582: PUSH
37583: LD_INT 0
37585: PUSH
37586: EMPTY
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 2
37592: NEG
37593: PUSH
37594: LD_INT 1
37596: NEG
37597: PUSH
37598: EMPTY
37599: LIST
37600: LIST
37601: PUSH
37602: EMPTY
37603: LIST
37604: LIST
37605: LIST
37606: LIST
37607: LIST
37608: LIST
37609: LIST
37610: LIST
37611: LIST
37612: LIST
37613: LIST
37614: LIST
37615: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37616: LD_ADDR_VAR 0 52
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 1
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 0
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 0
37664: PUSH
37665: LD_INT 1
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: NEG
37675: PUSH
37676: LD_INT 0
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 1
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 2
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 1
37709: NEG
37710: PUSH
37711: LD_INT 1
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: NEG
37721: PUSH
37722: LD_INT 0
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 2
37731: NEG
37732: PUSH
37733: LD_INT 1
37735: NEG
37736: PUSH
37737: EMPTY
37738: LIST
37739: LIST
37740: PUSH
37741: LD_INT 2
37743: NEG
37744: PUSH
37745: LD_INT 2
37747: NEG
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: EMPTY
37754: LIST
37755: LIST
37756: LIST
37757: LIST
37758: LIST
37759: LIST
37760: LIST
37761: LIST
37762: LIST
37763: LIST
37764: LIST
37765: LIST
37766: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37767: LD_ADDR_VAR 0 53
37771: PUSH
37772: LD_INT 0
37774: PUSH
37775: LD_INT 0
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PUSH
37782: LD_INT 0
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 1
37795: PUSH
37796: LD_INT 0
37798: PUSH
37799: EMPTY
37800: LIST
37801: LIST
37802: PUSH
37803: LD_INT 1
37805: PUSH
37806: LD_INT 1
37808: PUSH
37809: EMPTY
37810: LIST
37811: LIST
37812: PUSH
37813: LD_INT 0
37815: PUSH
37816: LD_INT 1
37818: PUSH
37819: EMPTY
37820: LIST
37821: LIST
37822: PUSH
37823: LD_INT 1
37825: NEG
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: EMPTY
37831: LIST
37832: LIST
37833: PUSH
37834: LD_INT 1
37836: NEG
37837: PUSH
37838: LD_INT 1
37840: NEG
37841: PUSH
37842: EMPTY
37843: LIST
37844: LIST
37845: PUSH
37846: LD_INT 1
37848: NEG
37849: PUSH
37850: LD_INT 2
37852: NEG
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 0
37860: PUSH
37861: LD_INT 2
37863: NEG
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PUSH
37869: LD_INT 1
37871: PUSH
37872: LD_INT 1
37874: NEG
37875: PUSH
37876: EMPTY
37877: LIST
37878: LIST
37879: PUSH
37880: LD_INT 2
37882: PUSH
37883: LD_INT 0
37885: PUSH
37886: EMPTY
37887: LIST
37888: LIST
37889: PUSH
37890: LD_INT 2
37892: PUSH
37893: LD_INT 1
37895: PUSH
37896: EMPTY
37897: LIST
37898: LIST
37899: PUSH
37900: LD_INT 2
37902: PUSH
37903: LD_INT 2
37905: PUSH
37906: EMPTY
37907: LIST
37908: LIST
37909: PUSH
37910: LD_INT 1
37912: PUSH
37913: LD_INT 2
37915: PUSH
37916: EMPTY
37917: LIST
37918: LIST
37919: PUSH
37920: LD_INT 0
37922: PUSH
37923: LD_INT 2
37925: PUSH
37926: EMPTY
37927: LIST
37928: LIST
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: LD_INT 1
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 2
37943: NEG
37944: PUSH
37945: LD_INT 0
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 2
37954: NEG
37955: PUSH
37956: LD_INT 1
37958: NEG
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 2
37966: NEG
37967: PUSH
37968: LD_INT 2
37970: NEG
37971: PUSH
37972: EMPTY
37973: LIST
37974: LIST
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: LIST
37980: LIST
37981: LIST
37982: LIST
37983: LIST
37984: LIST
37985: LIST
37986: LIST
37987: LIST
37988: LIST
37989: LIST
37990: LIST
37991: LIST
37992: LIST
37993: LIST
37994: LIST
37995: LIST
37996: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37997: LD_ADDR_VAR 0 54
38001: PUSH
38002: LD_INT 0
38004: PUSH
38005: LD_INT 0
38007: PUSH
38008: EMPTY
38009: LIST
38010: LIST
38011: PUSH
38012: LD_INT 0
38014: PUSH
38015: LD_INT 1
38017: NEG
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 1
38025: PUSH
38026: LD_INT 0
38028: PUSH
38029: EMPTY
38030: LIST
38031: LIST
38032: PUSH
38033: LD_INT 1
38035: PUSH
38036: LD_INT 1
38038: PUSH
38039: EMPTY
38040: LIST
38041: LIST
38042: PUSH
38043: LD_INT 0
38045: PUSH
38046: LD_INT 1
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: PUSH
38053: LD_INT 1
38055: NEG
38056: PUSH
38057: LD_INT 0
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: LD_INT 1
38070: NEG
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 1
38078: NEG
38079: PUSH
38080: LD_INT 2
38082: NEG
38083: PUSH
38084: EMPTY
38085: LIST
38086: LIST
38087: PUSH
38088: LD_INT 0
38090: PUSH
38091: LD_INT 2
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 1
38104: NEG
38105: PUSH
38106: EMPTY
38107: LIST
38108: LIST
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: LD_INT 0
38115: PUSH
38116: EMPTY
38117: LIST
38118: LIST
38119: PUSH
38120: LD_INT 2
38122: PUSH
38123: LD_INT 1
38125: PUSH
38126: EMPTY
38127: LIST
38128: LIST
38129: PUSH
38130: LD_INT 2
38132: PUSH
38133: LD_INT 2
38135: PUSH
38136: EMPTY
38137: LIST
38138: LIST
38139: PUSH
38140: LD_INT 1
38142: PUSH
38143: LD_INT 2
38145: PUSH
38146: EMPTY
38147: LIST
38148: LIST
38149: PUSH
38150: LD_INT 0
38152: PUSH
38153: LD_INT 2
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: LD_INT 1
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 2
38173: NEG
38174: PUSH
38175: LD_INT 0
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: NEG
38185: PUSH
38186: LD_INT 1
38188: NEG
38189: PUSH
38190: EMPTY
38191: LIST
38192: LIST
38193: PUSH
38194: LD_INT 2
38196: NEG
38197: PUSH
38198: LD_INT 2
38200: NEG
38201: PUSH
38202: EMPTY
38203: LIST
38204: LIST
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: LIST
38210: LIST
38211: LIST
38212: LIST
38213: LIST
38214: LIST
38215: LIST
38216: LIST
38217: LIST
38218: LIST
38219: LIST
38220: LIST
38221: LIST
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38227: LD_ADDR_VAR 0 55
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: LD_INT 0
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 0
38244: PUSH
38245: LD_INT 1
38247: NEG
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: LD_INT 1
38255: PUSH
38256: LD_INT 0
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 1
38265: PUSH
38266: LD_INT 1
38268: PUSH
38269: EMPTY
38270: LIST
38271: LIST
38272: PUSH
38273: LD_INT 0
38275: PUSH
38276: LD_INT 1
38278: PUSH
38279: EMPTY
38280: LIST
38281: LIST
38282: PUSH
38283: LD_INT 1
38285: NEG
38286: PUSH
38287: LD_INT 0
38289: PUSH
38290: EMPTY
38291: LIST
38292: LIST
38293: PUSH
38294: LD_INT 1
38296: NEG
38297: PUSH
38298: LD_INT 1
38300: NEG
38301: PUSH
38302: EMPTY
38303: LIST
38304: LIST
38305: PUSH
38306: LD_INT 1
38308: NEG
38309: PUSH
38310: LD_INT 2
38312: NEG
38313: PUSH
38314: EMPTY
38315: LIST
38316: LIST
38317: PUSH
38318: LD_INT 0
38320: PUSH
38321: LD_INT 2
38323: NEG
38324: PUSH
38325: EMPTY
38326: LIST
38327: LIST
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: LD_INT 1
38334: NEG
38335: PUSH
38336: EMPTY
38337: LIST
38338: LIST
38339: PUSH
38340: LD_INT 2
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: EMPTY
38347: LIST
38348: LIST
38349: PUSH
38350: LD_INT 2
38352: PUSH
38353: LD_INT 1
38355: PUSH
38356: EMPTY
38357: LIST
38358: LIST
38359: PUSH
38360: LD_INT 2
38362: PUSH
38363: LD_INT 2
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: LD_INT 2
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 0
38382: PUSH
38383: LD_INT 2
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: LD_INT 1
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 2
38403: NEG
38404: PUSH
38405: LD_INT 0
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 2
38414: NEG
38415: PUSH
38416: LD_INT 1
38418: NEG
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 2
38426: NEG
38427: PUSH
38428: LD_INT 2
38430: NEG
38431: PUSH
38432: EMPTY
38433: LIST
38434: LIST
38435: PUSH
38436: EMPTY
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: LIST
38455: LIST
38456: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38457: LD_ADDR_VAR 0 56
38461: PUSH
38462: LD_INT 0
38464: PUSH
38465: LD_INT 0
38467: PUSH
38468: EMPTY
38469: LIST
38470: LIST
38471: PUSH
38472: LD_INT 0
38474: PUSH
38475: LD_INT 1
38477: NEG
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 1
38485: PUSH
38486: LD_INT 0
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: PUSH
38496: LD_INT 1
38498: PUSH
38499: EMPTY
38500: LIST
38501: LIST
38502: PUSH
38503: LD_INT 0
38505: PUSH
38506: LD_INT 1
38508: PUSH
38509: EMPTY
38510: LIST
38511: LIST
38512: PUSH
38513: LD_INT 1
38515: NEG
38516: PUSH
38517: LD_INT 0
38519: PUSH
38520: EMPTY
38521: LIST
38522: LIST
38523: PUSH
38524: LD_INT 1
38526: NEG
38527: PUSH
38528: LD_INT 1
38530: NEG
38531: PUSH
38532: EMPTY
38533: LIST
38534: LIST
38535: PUSH
38536: LD_INT 1
38538: NEG
38539: PUSH
38540: LD_INT 2
38542: NEG
38543: PUSH
38544: EMPTY
38545: LIST
38546: LIST
38547: PUSH
38548: LD_INT 0
38550: PUSH
38551: LD_INT 2
38553: NEG
38554: PUSH
38555: EMPTY
38556: LIST
38557: LIST
38558: PUSH
38559: LD_INT 1
38561: PUSH
38562: LD_INT 1
38564: NEG
38565: PUSH
38566: EMPTY
38567: LIST
38568: LIST
38569: PUSH
38570: LD_INT 2
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: EMPTY
38577: LIST
38578: LIST
38579: PUSH
38580: LD_INT 2
38582: PUSH
38583: LD_INT 1
38585: PUSH
38586: EMPTY
38587: LIST
38588: LIST
38589: PUSH
38590: LD_INT 2
38592: PUSH
38593: LD_INT 2
38595: PUSH
38596: EMPTY
38597: LIST
38598: LIST
38599: PUSH
38600: LD_INT 1
38602: PUSH
38603: LD_INT 2
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: LD_INT 2
38615: PUSH
38616: EMPTY
38617: LIST
38618: LIST
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: LD_INT 1
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 2
38633: NEG
38634: PUSH
38635: LD_INT 0
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 2
38644: NEG
38645: PUSH
38646: LD_INT 1
38648: NEG
38649: PUSH
38650: EMPTY
38651: LIST
38652: LIST
38653: PUSH
38654: LD_INT 2
38656: NEG
38657: PUSH
38658: LD_INT 2
38660: NEG
38661: PUSH
38662: EMPTY
38663: LIST
38664: LIST
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: LIST
38670: LIST
38671: LIST
38672: LIST
38673: LIST
38674: LIST
38675: LIST
38676: LIST
38677: LIST
38678: LIST
38679: LIST
38680: LIST
38681: LIST
38682: LIST
38683: LIST
38684: LIST
38685: LIST
38686: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38687: LD_ADDR_VAR 0 57
38691: PUSH
38692: LD_INT 0
38694: PUSH
38695: LD_INT 0
38697: PUSH
38698: EMPTY
38699: LIST
38700: LIST
38701: PUSH
38702: LD_INT 0
38704: PUSH
38705: LD_INT 1
38707: NEG
38708: PUSH
38709: EMPTY
38710: LIST
38711: LIST
38712: PUSH
38713: LD_INT 1
38715: PUSH
38716: LD_INT 0
38718: PUSH
38719: EMPTY
38720: LIST
38721: LIST
38722: PUSH
38723: LD_INT 1
38725: PUSH
38726: LD_INT 1
38728: PUSH
38729: EMPTY
38730: LIST
38731: LIST
38732: PUSH
38733: LD_INT 0
38735: PUSH
38736: LD_INT 1
38738: PUSH
38739: EMPTY
38740: LIST
38741: LIST
38742: PUSH
38743: LD_INT 1
38745: NEG
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 1
38756: NEG
38757: PUSH
38758: LD_INT 1
38760: NEG
38761: PUSH
38762: EMPTY
38763: LIST
38764: LIST
38765: PUSH
38766: LD_INT 1
38768: NEG
38769: PUSH
38770: LD_INT 2
38772: NEG
38773: PUSH
38774: EMPTY
38775: LIST
38776: LIST
38777: PUSH
38778: LD_INT 0
38780: PUSH
38781: LD_INT 2
38783: NEG
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 1
38791: PUSH
38792: LD_INT 1
38794: NEG
38795: PUSH
38796: EMPTY
38797: LIST
38798: LIST
38799: PUSH
38800: LD_INT 2
38802: PUSH
38803: LD_INT 0
38805: PUSH
38806: EMPTY
38807: LIST
38808: LIST
38809: PUSH
38810: LD_INT 2
38812: PUSH
38813: LD_INT 1
38815: PUSH
38816: EMPTY
38817: LIST
38818: LIST
38819: PUSH
38820: LD_INT 2
38822: PUSH
38823: LD_INT 2
38825: PUSH
38826: EMPTY
38827: LIST
38828: LIST
38829: PUSH
38830: LD_INT 1
38832: PUSH
38833: LD_INT 2
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 0
38842: PUSH
38843: LD_INT 2
38845: PUSH
38846: EMPTY
38847: LIST
38848: LIST
38849: PUSH
38850: LD_INT 1
38852: NEG
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: EMPTY
38858: LIST
38859: LIST
38860: PUSH
38861: LD_INT 2
38863: NEG
38864: PUSH
38865: LD_INT 0
38867: PUSH
38868: EMPTY
38869: LIST
38870: LIST
38871: PUSH
38872: LD_INT 2
38874: NEG
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 2
38886: NEG
38887: PUSH
38888: LD_INT 2
38890: NEG
38891: PUSH
38892: EMPTY
38893: LIST
38894: LIST
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38917: LD_ADDR_VAR 0 58
38921: PUSH
38922: LD_INT 0
38924: PUSH
38925: LD_INT 0
38927: PUSH
38928: EMPTY
38929: LIST
38930: LIST
38931: PUSH
38932: LD_INT 0
38934: PUSH
38935: LD_INT 1
38937: NEG
38938: PUSH
38939: EMPTY
38940: LIST
38941: LIST
38942: PUSH
38943: LD_INT 1
38945: PUSH
38946: LD_INT 0
38948: PUSH
38949: EMPTY
38950: LIST
38951: LIST
38952: PUSH
38953: LD_INT 1
38955: PUSH
38956: LD_INT 1
38958: PUSH
38959: EMPTY
38960: LIST
38961: LIST
38962: PUSH
38963: LD_INT 0
38965: PUSH
38966: LD_INT 1
38968: PUSH
38969: EMPTY
38970: LIST
38971: LIST
38972: PUSH
38973: LD_INT 1
38975: NEG
38976: PUSH
38977: LD_INT 0
38979: PUSH
38980: EMPTY
38981: LIST
38982: LIST
38983: PUSH
38984: LD_INT 1
38986: NEG
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: EMPTY
38993: LIST
38994: LIST
38995: PUSH
38996: LD_INT 1
38998: NEG
38999: PUSH
39000: LD_INT 2
39002: NEG
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: LD_INT 2
39013: NEG
39014: PUSH
39015: EMPTY
39016: LIST
39017: LIST
39018: PUSH
39019: LD_INT 1
39021: PUSH
39022: LD_INT 1
39024: NEG
39025: PUSH
39026: EMPTY
39027: LIST
39028: LIST
39029: PUSH
39030: LD_INT 2
39032: PUSH
39033: LD_INT 0
39035: PUSH
39036: EMPTY
39037: LIST
39038: LIST
39039: PUSH
39040: LD_INT 2
39042: PUSH
39043: LD_INT 1
39045: PUSH
39046: EMPTY
39047: LIST
39048: LIST
39049: PUSH
39050: LD_INT 2
39052: PUSH
39053: LD_INT 2
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: LD_INT 2
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 0
39072: PUSH
39073: LD_INT 2
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: LD_INT 1
39086: PUSH
39087: EMPTY
39088: LIST
39089: LIST
39090: PUSH
39091: LD_INT 2
39093: NEG
39094: PUSH
39095: LD_INT 0
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 2
39104: NEG
39105: PUSH
39106: LD_INT 1
39108: NEG
39109: PUSH
39110: EMPTY
39111: LIST
39112: LIST
39113: PUSH
39114: LD_INT 2
39116: NEG
39117: PUSH
39118: LD_INT 2
39120: NEG
39121: PUSH
39122: EMPTY
39123: LIST
39124: LIST
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: LIST
39130: LIST
39131: LIST
39132: LIST
39133: LIST
39134: LIST
39135: LIST
39136: LIST
39137: LIST
39138: LIST
39139: LIST
39140: LIST
39141: LIST
39142: LIST
39143: LIST
39144: LIST
39145: LIST
39146: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39147: LD_ADDR_VAR 0 59
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: LD_INT 0
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 0
39164: PUSH
39165: LD_INT 1
39167: NEG
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 1
39175: PUSH
39176: LD_INT 0
39178: PUSH
39179: EMPTY
39180: LIST
39181: LIST
39182: PUSH
39183: LD_INT 1
39185: PUSH
39186: LD_INT 1
39188: PUSH
39189: EMPTY
39190: LIST
39191: LIST
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: LD_INT 1
39198: PUSH
39199: EMPTY
39200: LIST
39201: LIST
39202: PUSH
39203: LD_INT 1
39205: NEG
39206: PUSH
39207: LD_INT 0
39209: PUSH
39210: EMPTY
39211: LIST
39212: LIST
39213: PUSH
39214: LD_INT 1
39216: NEG
39217: PUSH
39218: LD_INT 1
39220: NEG
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: EMPTY
39227: LIST
39228: LIST
39229: LIST
39230: LIST
39231: LIST
39232: LIST
39233: LIST
39234: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39235: LD_ADDR_VAR 0 60
39239: PUSH
39240: LD_INT 0
39242: PUSH
39243: LD_INT 0
39245: PUSH
39246: EMPTY
39247: LIST
39248: LIST
39249: PUSH
39250: LD_INT 0
39252: PUSH
39253: LD_INT 1
39255: NEG
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: LD_INT 1
39263: PUSH
39264: LD_INT 0
39266: PUSH
39267: EMPTY
39268: LIST
39269: LIST
39270: PUSH
39271: LD_INT 1
39273: PUSH
39274: LD_INT 1
39276: PUSH
39277: EMPTY
39278: LIST
39279: LIST
39280: PUSH
39281: LD_INT 0
39283: PUSH
39284: LD_INT 1
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: PUSH
39291: LD_INT 1
39293: NEG
39294: PUSH
39295: LD_INT 0
39297: PUSH
39298: EMPTY
39299: LIST
39300: LIST
39301: PUSH
39302: LD_INT 1
39304: NEG
39305: PUSH
39306: LD_INT 1
39308: NEG
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: EMPTY
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: LIST
39321: LIST
39322: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39323: LD_ADDR_VAR 0 61
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: LD_INT 0
39333: PUSH
39334: EMPTY
39335: LIST
39336: LIST
39337: PUSH
39338: LD_INT 0
39340: PUSH
39341: LD_INT 1
39343: NEG
39344: PUSH
39345: EMPTY
39346: LIST
39347: LIST
39348: PUSH
39349: LD_INT 1
39351: PUSH
39352: LD_INT 0
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 1
39361: PUSH
39362: LD_INT 1
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 0
39371: PUSH
39372: LD_INT 1
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 1
39381: NEG
39382: PUSH
39383: LD_INT 0
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: LD_INT 1
39392: NEG
39393: PUSH
39394: LD_INT 1
39396: NEG
39397: PUSH
39398: EMPTY
39399: LIST
39400: LIST
39401: PUSH
39402: EMPTY
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39411: LD_ADDR_VAR 0 62
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: LD_INT 1
39431: NEG
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: LD_INT 0
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: LD_INT 1
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: LD_INT 1
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: NEG
39470: PUSH
39471: LD_INT 0
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 1
39480: NEG
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: EMPTY
39491: LIST
39492: LIST
39493: LIST
39494: LIST
39495: LIST
39496: LIST
39497: LIST
39498: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39499: LD_ADDR_VAR 0 63
39503: PUSH
39504: LD_INT 0
39506: PUSH
39507: LD_INT 0
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: LD_INT 0
39516: PUSH
39517: LD_INT 1
39519: NEG
39520: PUSH
39521: EMPTY
39522: LIST
39523: LIST
39524: PUSH
39525: LD_INT 1
39527: PUSH
39528: LD_INT 0
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: LD_INT 1
39537: PUSH
39538: LD_INT 1
39540: PUSH
39541: EMPTY
39542: LIST
39543: LIST
39544: PUSH
39545: LD_INT 0
39547: PUSH
39548: LD_INT 1
39550: PUSH
39551: EMPTY
39552: LIST
39553: LIST
39554: PUSH
39555: LD_INT 1
39557: NEG
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 1
39568: NEG
39569: PUSH
39570: LD_INT 1
39572: NEG
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: LIST
39582: LIST
39583: LIST
39584: LIST
39585: LIST
39586: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39587: LD_ADDR_VAR 0 64
39591: PUSH
39592: LD_INT 0
39594: PUSH
39595: LD_INT 0
39597: PUSH
39598: EMPTY
39599: LIST
39600: LIST
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: LD_INT 1
39607: NEG
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: LD_INT 0
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: PUSH
39623: LD_INT 1
39625: PUSH
39626: LD_INT 1
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 0
39635: PUSH
39636: LD_INT 1
39638: PUSH
39639: EMPTY
39640: LIST
39641: LIST
39642: PUSH
39643: LD_INT 1
39645: NEG
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 1
39656: NEG
39657: PUSH
39658: LD_INT 1
39660: NEG
39661: PUSH
39662: EMPTY
39663: LIST
39664: LIST
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: LIST
39670: LIST
39671: LIST
39672: LIST
39673: LIST
39674: ST_TO_ADDR
// end ; 1 :
39675: GO 45572
39677: LD_INT 1
39679: DOUBLE
39680: EQUAL
39681: IFTRUE 39685
39683: GO 42308
39685: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39686: LD_ADDR_VAR 0 11
39690: PUSH
39691: LD_INT 1
39693: NEG
39694: PUSH
39695: LD_INT 3
39697: NEG
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: PUSH
39703: LD_INT 0
39705: PUSH
39706: LD_INT 3
39708: NEG
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 1
39716: PUSH
39717: LD_INT 2
39719: NEG
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: EMPTY
39726: LIST
39727: LIST
39728: LIST
39729: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39730: LD_ADDR_VAR 0 12
39734: PUSH
39735: LD_INT 2
39737: PUSH
39738: LD_INT 1
39740: NEG
39741: PUSH
39742: EMPTY
39743: LIST
39744: LIST
39745: PUSH
39746: LD_INT 3
39748: PUSH
39749: LD_INT 0
39751: PUSH
39752: EMPTY
39753: LIST
39754: LIST
39755: PUSH
39756: LD_INT 3
39758: PUSH
39759: LD_INT 1
39761: PUSH
39762: EMPTY
39763: LIST
39764: LIST
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: LIST
39770: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39771: LD_ADDR_VAR 0 13
39775: PUSH
39776: LD_INT 3
39778: PUSH
39779: LD_INT 2
39781: PUSH
39782: EMPTY
39783: LIST
39784: LIST
39785: PUSH
39786: LD_INT 3
39788: PUSH
39789: LD_INT 3
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 2
39798: PUSH
39799: LD_INT 3
39801: PUSH
39802: EMPTY
39803: LIST
39804: LIST
39805: PUSH
39806: EMPTY
39807: LIST
39808: LIST
39809: LIST
39810: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39811: LD_ADDR_VAR 0 14
39815: PUSH
39816: LD_INT 1
39818: PUSH
39819: LD_INT 3
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: LD_INT 3
39831: PUSH
39832: EMPTY
39833: LIST
39834: LIST
39835: PUSH
39836: LD_INT 1
39838: NEG
39839: PUSH
39840: LD_INT 2
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: EMPTY
39848: LIST
39849: LIST
39850: LIST
39851: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39852: LD_ADDR_VAR 0 15
39856: PUSH
39857: LD_INT 2
39859: NEG
39860: PUSH
39861: LD_INT 1
39863: PUSH
39864: EMPTY
39865: LIST
39866: LIST
39867: PUSH
39868: LD_INT 3
39870: NEG
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 3
39881: NEG
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: EMPTY
39892: LIST
39893: LIST
39894: LIST
39895: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39896: LD_ADDR_VAR 0 16
39900: PUSH
39901: LD_INT 2
39903: NEG
39904: PUSH
39905: LD_INT 3
39907: NEG
39908: PUSH
39909: EMPTY
39910: LIST
39911: LIST
39912: PUSH
39913: LD_INT 3
39915: NEG
39916: PUSH
39917: LD_INT 2
39919: NEG
39920: PUSH
39921: EMPTY
39922: LIST
39923: LIST
39924: PUSH
39925: LD_INT 3
39927: NEG
39928: PUSH
39929: LD_INT 3
39931: NEG
39932: PUSH
39933: EMPTY
39934: LIST
39935: LIST
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: LIST
39941: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39942: LD_ADDR_VAR 0 17
39946: PUSH
39947: LD_INT 1
39949: NEG
39950: PUSH
39951: LD_INT 3
39953: NEG
39954: PUSH
39955: EMPTY
39956: LIST
39957: LIST
39958: PUSH
39959: LD_INT 0
39961: PUSH
39962: LD_INT 3
39964: NEG
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: LD_INT 1
39972: PUSH
39973: LD_INT 2
39975: NEG
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: EMPTY
39982: LIST
39983: LIST
39984: LIST
39985: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39986: LD_ADDR_VAR 0 18
39990: PUSH
39991: LD_INT 2
39993: PUSH
39994: LD_INT 1
39996: NEG
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 3
40004: PUSH
40005: LD_INT 0
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 3
40014: PUSH
40015: LD_INT 1
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: LIST
40026: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
40027: LD_ADDR_VAR 0 19
40031: PUSH
40032: LD_INT 3
40034: PUSH
40035: LD_INT 2
40037: PUSH
40038: EMPTY
40039: LIST
40040: LIST
40041: PUSH
40042: LD_INT 3
40044: PUSH
40045: LD_INT 3
40047: PUSH
40048: EMPTY
40049: LIST
40050: LIST
40051: PUSH
40052: LD_INT 2
40054: PUSH
40055: LD_INT 3
40057: PUSH
40058: EMPTY
40059: LIST
40060: LIST
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: LIST
40066: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
40067: LD_ADDR_VAR 0 20
40071: PUSH
40072: LD_INT 1
40074: PUSH
40075: LD_INT 3
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 0
40084: PUSH
40085: LD_INT 3
40087: PUSH
40088: EMPTY
40089: LIST
40090: LIST
40091: PUSH
40092: LD_INT 1
40094: NEG
40095: PUSH
40096: LD_INT 2
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: EMPTY
40104: LIST
40105: LIST
40106: LIST
40107: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40108: LD_ADDR_VAR 0 21
40112: PUSH
40113: LD_INT 2
40115: NEG
40116: PUSH
40117: LD_INT 1
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 3
40126: NEG
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: EMPTY
40132: LIST
40133: LIST
40134: PUSH
40135: LD_INT 3
40137: NEG
40138: PUSH
40139: LD_INT 1
40141: NEG
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: EMPTY
40148: LIST
40149: LIST
40150: LIST
40151: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
40152: LD_ADDR_VAR 0 22
40156: PUSH
40157: LD_INT 2
40159: NEG
40160: PUSH
40161: LD_INT 3
40163: NEG
40164: PUSH
40165: EMPTY
40166: LIST
40167: LIST
40168: PUSH
40169: LD_INT 3
40171: NEG
40172: PUSH
40173: LD_INT 2
40175: NEG
40176: PUSH
40177: EMPTY
40178: LIST
40179: LIST
40180: PUSH
40181: LD_INT 3
40183: NEG
40184: PUSH
40185: LD_INT 3
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: LIST
40197: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
40198: LD_ADDR_VAR 0 23
40202: PUSH
40203: LD_INT 0
40205: PUSH
40206: LD_INT 3
40208: NEG
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 1
40216: NEG
40217: PUSH
40218: LD_INT 4
40220: NEG
40221: PUSH
40222: EMPTY
40223: LIST
40224: LIST
40225: PUSH
40226: LD_INT 1
40228: PUSH
40229: LD_INT 3
40231: NEG
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: EMPTY
40238: LIST
40239: LIST
40240: LIST
40241: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
40242: LD_ADDR_VAR 0 24
40246: PUSH
40247: LD_INT 3
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 3
40259: PUSH
40260: LD_INT 1
40262: NEG
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 4
40270: PUSH
40271: LD_INT 1
40273: PUSH
40274: EMPTY
40275: LIST
40276: LIST
40277: PUSH
40278: EMPTY
40279: LIST
40280: LIST
40281: LIST
40282: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
40283: LD_ADDR_VAR 0 25
40287: PUSH
40288: LD_INT 3
40290: PUSH
40291: LD_INT 3
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 4
40300: PUSH
40301: LD_INT 3
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 3
40310: PUSH
40311: LD_INT 4
40313: PUSH
40314: EMPTY
40315: LIST
40316: LIST
40317: PUSH
40318: EMPTY
40319: LIST
40320: LIST
40321: LIST
40322: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
40323: LD_ADDR_VAR 0 26
40327: PUSH
40328: LD_INT 0
40330: PUSH
40331: LD_INT 3
40333: PUSH
40334: EMPTY
40335: LIST
40336: LIST
40337: PUSH
40338: LD_INT 1
40340: PUSH
40341: LD_INT 4
40343: PUSH
40344: EMPTY
40345: LIST
40346: LIST
40347: PUSH
40348: LD_INT 1
40350: NEG
40351: PUSH
40352: LD_INT 3
40354: PUSH
40355: EMPTY
40356: LIST
40357: LIST
40358: PUSH
40359: EMPTY
40360: LIST
40361: LIST
40362: LIST
40363: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
40364: LD_ADDR_VAR 0 27
40368: PUSH
40369: LD_INT 3
40371: NEG
40372: PUSH
40373: LD_INT 0
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 3
40382: NEG
40383: PUSH
40384: LD_INT 1
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 4
40393: NEG
40394: PUSH
40395: LD_INT 1
40397: NEG
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: LIST
40407: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40408: LD_ADDR_VAR 0 28
40412: PUSH
40413: LD_INT 3
40415: NEG
40416: PUSH
40417: LD_INT 3
40419: NEG
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 3
40427: NEG
40428: PUSH
40429: LD_INT 4
40431: NEG
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 4
40439: NEG
40440: PUSH
40441: LD_INT 3
40443: NEG
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: EMPTY
40450: LIST
40451: LIST
40452: LIST
40453: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40454: LD_ADDR_VAR 0 29
40458: PUSH
40459: LD_INT 1
40461: NEG
40462: PUSH
40463: LD_INT 3
40465: NEG
40466: PUSH
40467: EMPTY
40468: LIST
40469: LIST
40470: PUSH
40471: LD_INT 0
40473: PUSH
40474: LD_INT 3
40476: NEG
40477: PUSH
40478: EMPTY
40479: LIST
40480: LIST
40481: PUSH
40482: LD_INT 1
40484: PUSH
40485: LD_INT 2
40487: NEG
40488: PUSH
40489: EMPTY
40490: LIST
40491: LIST
40492: PUSH
40493: LD_INT 1
40495: NEG
40496: PUSH
40497: LD_INT 4
40499: NEG
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 0
40507: PUSH
40508: LD_INT 4
40510: NEG
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 1
40518: PUSH
40519: LD_INT 3
40521: NEG
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: LD_INT 5
40533: NEG
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 0
40541: PUSH
40542: LD_INT 5
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: LD_INT 4
40555: NEG
40556: PUSH
40557: EMPTY
40558: LIST
40559: LIST
40560: PUSH
40561: LD_INT 1
40563: NEG
40564: PUSH
40565: LD_INT 6
40567: NEG
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 0
40575: PUSH
40576: LD_INT 6
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 1
40586: PUSH
40587: LD_INT 5
40589: NEG
40590: PUSH
40591: EMPTY
40592: LIST
40593: LIST
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: LIST
40599: LIST
40600: LIST
40601: LIST
40602: LIST
40603: LIST
40604: LIST
40605: LIST
40606: LIST
40607: LIST
40608: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40609: LD_ADDR_VAR 0 30
40613: PUSH
40614: LD_INT 2
40616: PUSH
40617: LD_INT 1
40619: NEG
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 3
40627: PUSH
40628: LD_INT 0
40630: PUSH
40631: EMPTY
40632: LIST
40633: LIST
40634: PUSH
40635: LD_INT 3
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 3
40647: PUSH
40648: LD_INT 1
40650: NEG
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 4
40658: PUSH
40659: LD_INT 0
40661: PUSH
40662: EMPTY
40663: LIST
40664: LIST
40665: PUSH
40666: LD_INT 4
40668: PUSH
40669: LD_INT 1
40671: PUSH
40672: EMPTY
40673: LIST
40674: LIST
40675: PUSH
40676: LD_INT 4
40678: PUSH
40679: LD_INT 1
40681: NEG
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: LD_INT 5
40689: PUSH
40690: LD_INT 0
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 5
40699: PUSH
40700: LD_INT 1
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 5
40709: PUSH
40710: LD_INT 1
40712: NEG
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 6
40720: PUSH
40721: LD_INT 0
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 6
40730: PUSH
40731: LD_INT 1
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PUSH
40738: EMPTY
40739: LIST
40740: LIST
40741: LIST
40742: LIST
40743: LIST
40744: LIST
40745: LIST
40746: LIST
40747: LIST
40748: LIST
40749: LIST
40750: LIST
40751: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40752: LD_ADDR_VAR 0 31
40756: PUSH
40757: LD_INT 3
40759: PUSH
40760: LD_INT 2
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: PUSH
40767: LD_INT 3
40769: PUSH
40770: LD_INT 3
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 2
40779: PUSH
40780: LD_INT 3
40782: PUSH
40783: EMPTY
40784: LIST
40785: LIST
40786: PUSH
40787: LD_INT 4
40789: PUSH
40790: LD_INT 3
40792: PUSH
40793: EMPTY
40794: LIST
40795: LIST
40796: PUSH
40797: LD_INT 4
40799: PUSH
40800: LD_INT 4
40802: PUSH
40803: EMPTY
40804: LIST
40805: LIST
40806: PUSH
40807: LD_INT 3
40809: PUSH
40810: LD_INT 4
40812: PUSH
40813: EMPTY
40814: LIST
40815: LIST
40816: PUSH
40817: LD_INT 5
40819: PUSH
40820: LD_INT 4
40822: PUSH
40823: EMPTY
40824: LIST
40825: LIST
40826: PUSH
40827: LD_INT 5
40829: PUSH
40830: LD_INT 5
40832: PUSH
40833: EMPTY
40834: LIST
40835: LIST
40836: PUSH
40837: LD_INT 4
40839: PUSH
40840: LD_INT 5
40842: PUSH
40843: EMPTY
40844: LIST
40845: LIST
40846: PUSH
40847: LD_INT 6
40849: PUSH
40850: LD_INT 5
40852: PUSH
40853: EMPTY
40854: LIST
40855: LIST
40856: PUSH
40857: LD_INT 6
40859: PUSH
40860: LD_INT 6
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: PUSH
40867: LD_INT 5
40869: PUSH
40870: LD_INT 6
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: LIST
40881: LIST
40882: LIST
40883: LIST
40884: LIST
40885: LIST
40886: LIST
40887: LIST
40888: LIST
40889: LIST
40890: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40891: LD_ADDR_VAR 0 32
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: LD_INT 3
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: LD_INT 3
40911: PUSH
40912: EMPTY
40913: LIST
40914: LIST
40915: PUSH
40916: LD_INT 1
40918: NEG
40919: PUSH
40920: LD_INT 2
40922: PUSH
40923: EMPTY
40924: LIST
40925: LIST
40926: PUSH
40927: LD_INT 1
40929: PUSH
40930: LD_INT 4
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 0
40939: PUSH
40940: LD_INT 4
40942: PUSH
40943: EMPTY
40944: LIST
40945: LIST
40946: PUSH
40947: LD_INT 1
40949: NEG
40950: PUSH
40951: LD_INT 3
40953: PUSH
40954: EMPTY
40955: LIST
40956: LIST
40957: PUSH
40958: LD_INT 1
40960: PUSH
40961: LD_INT 5
40963: PUSH
40964: EMPTY
40965: LIST
40966: LIST
40967: PUSH
40968: LD_INT 0
40970: PUSH
40971: LD_INT 5
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: NEG
40981: PUSH
40982: LD_INT 4
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: LD_INT 1
40991: PUSH
40992: LD_INT 6
40994: PUSH
40995: EMPTY
40996: LIST
40997: LIST
40998: PUSH
40999: LD_INT 0
41001: PUSH
41002: LD_INT 6
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 1
41011: NEG
41012: PUSH
41013: LD_INT 5
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: LIST
41024: LIST
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: LIST
41033: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
41034: LD_ADDR_VAR 0 33
41038: PUSH
41039: LD_INT 2
41041: NEG
41042: PUSH
41043: LD_INT 1
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: NEG
41053: PUSH
41054: LD_INT 0
41056: PUSH
41057: EMPTY
41058: LIST
41059: LIST
41060: PUSH
41061: LD_INT 3
41063: NEG
41064: PUSH
41065: LD_INT 1
41067: NEG
41068: PUSH
41069: EMPTY
41070: LIST
41071: LIST
41072: PUSH
41073: LD_INT 3
41075: NEG
41076: PUSH
41077: LD_INT 1
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 4
41086: NEG
41087: PUSH
41088: LD_INT 0
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: LD_INT 4
41097: NEG
41098: PUSH
41099: LD_INT 1
41101: NEG
41102: PUSH
41103: EMPTY
41104: LIST
41105: LIST
41106: PUSH
41107: LD_INT 4
41109: NEG
41110: PUSH
41111: LD_INT 1
41113: PUSH
41114: EMPTY
41115: LIST
41116: LIST
41117: PUSH
41118: LD_INT 5
41120: NEG
41121: PUSH
41122: LD_INT 0
41124: PUSH
41125: EMPTY
41126: LIST
41127: LIST
41128: PUSH
41129: LD_INT 5
41131: NEG
41132: PUSH
41133: LD_INT 1
41135: NEG
41136: PUSH
41137: EMPTY
41138: LIST
41139: LIST
41140: PUSH
41141: LD_INT 5
41143: NEG
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 6
41154: NEG
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: EMPTY
41160: LIST
41161: LIST
41162: PUSH
41163: LD_INT 6
41165: NEG
41166: PUSH
41167: LD_INT 1
41169: NEG
41170: PUSH
41171: EMPTY
41172: LIST
41173: LIST
41174: PUSH
41175: EMPTY
41176: LIST
41177: LIST
41178: LIST
41179: LIST
41180: LIST
41181: LIST
41182: LIST
41183: LIST
41184: LIST
41185: LIST
41186: LIST
41187: LIST
41188: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
41189: LD_ADDR_VAR 0 34
41193: PUSH
41194: LD_INT 2
41196: NEG
41197: PUSH
41198: LD_INT 3
41200: NEG
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: LD_INT 2
41212: NEG
41213: PUSH
41214: EMPTY
41215: LIST
41216: LIST
41217: PUSH
41218: LD_INT 3
41220: NEG
41221: PUSH
41222: LD_INT 3
41224: NEG
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: PUSH
41230: LD_INT 3
41232: NEG
41233: PUSH
41234: LD_INT 4
41236: NEG
41237: PUSH
41238: EMPTY
41239: LIST
41240: LIST
41241: PUSH
41242: LD_INT 4
41244: NEG
41245: PUSH
41246: LD_INT 3
41248: NEG
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 4
41256: NEG
41257: PUSH
41258: LD_INT 4
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: LD_INT 4
41268: NEG
41269: PUSH
41270: LD_INT 5
41272: NEG
41273: PUSH
41274: EMPTY
41275: LIST
41276: LIST
41277: PUSH
41278: LD_INT 5
41280: NEG
41281: PUSH
41282: LD_INT 4
41284: NEG
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 5
41292: NEG
41293: PUSH
41294: LD_INT 5
41296: NEG
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: LD_INT 5
41304: NEG
41305: PUSH
41306: LD_INT 6
41308: NEG
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 6
41316: NEG
41317: PUSH
41318: LD_INT 5
41320: NEG
41321: PUSH
41322: EMPTY
41323: LIST
41324: LIST
41325: PUSH
41326: LD_INT 6
41328: NEG
41329: PUSH
41330: LD_INT 6
41332: NEG
41333: PUSH
41334: EMPTY
41335: LIST
41336: LIST
41337: PUSH
41338: EMPTY
41339: LIST
41340: LIST
41341: LIST
41342: LIST
41343: LIST
41344: LIST
41345: LIST
41346: LIST
41347: LIST
41348: LIST
41349: LIST
41350: LIST
41351: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
41352: LD_ADDR_VAR 0 41
41356: PUSH
41357: LD_INT 0
41359: PUSH
41360: LD_INT 2
41362: NEG
41363: PUSH
41364: EMPTY
41365: LIST
41366: LIST
41367: PUSH
41368: LD_INT 1
41370: NEG
41371: PUSH
41372: LD_INT 3
41374: NEG
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 1
41382: PUSH
41383: LD_INT 2
41385: NEG
41386: PUSH
41387: EMPTY
41388: LIST
41389: LIST
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: LIST
41395: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41396: LD_ADDR_VAR 0 42
41400: PUSH
41401: LD_INT 2
41403: PUSH
41404: LD_INT 0
41406: PUSH
41407: EMPTY
41408: LIST
41409: LIST
41410: PUSH
41411: LD_INT 2
41413: PUSH
41414: LD_INT 1
41416: NEG
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 3
41424: PUSH
41425: LD_INT 1
41427: PUSH
41428: EMPTY
41429: LIST
41430: LIST
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: LIST
41436: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41437: LD_ADDR_VAR 0 43
41441: PUSH
41442: LD_INT 2
41444: PUSH
41445: LD_INT 2
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 3
41454: PUSH
41455: LD_INT 2
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 2
41464: PUSH
41465: LD_INT 3
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: LIST
41476: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41477: LD_ADDR_VAR 0 44
41481: PUSH
41482: LD_INT 0
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 1
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 1
41504: NEG
41505: PUSH
41506: LD_INT 2
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: LIST
41517: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41518: LD_ADDR_VAR 0 45
41522: PUSH
41523: LD_INT 2
41525: NEG
41526: PUSH
41527: LD_INT 0
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: LD_INT 2
41536: NEG
41537: PUSH
41538: LD_INT 1
41540: PUSH
41541: EMPTY
41542: LIST
41543: LIST
41544: PUSH
41545: LD_INT 3
41547: NEG
41548: PUSH
41549: LD_INT 1
41551: NEG
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: LIST
41561: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41562: LD_ADDR_VAR 0 46
41566: PUSH
41567: LD_INT 2
41569: NEG
41570: PUSH
41571: LD_INT 2
41573: NEG
41574: PUSH
41575: EMPTY
41576: LIST
41577: LIST
41578: PUSH
41579: LD_INT 2
41581: NEG
41582: PUSH
41583: LD_INT 3
41585: NEG
41586: PUSH
41587: EMPTY
41588: LIST
41589: LIST
41590: PUSH
41591: LD_INT 3
41593: NEG
41594: PUSH
41595: LD_INT 2
41597: NEG
41598: PUSH
41599: EMPTY
41600: LIST
41601: LIST
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: LIST
41607: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41608: LD_ADDR_VAR 0 47
41612: PUSH
41613: LD_INT 2
41615: NEG
41616: PUSH
41617: LD_INT 3
41619: NEG
41620: PUSH
41621: EMPTY
41622: LIST
41623: LIST
41624: PUSH
41625: LD_INT 1
41627: NEG
41628: PUSH
41629: LD_INT 3
41631: NEG
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41641: LD_ADDR_VAR 0 48
41645: PUSH
41646: LD_INT 1
41648: PUSH
41649: LD_INT 2
41651: NEG
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: LD_INT 2
41659: PUSH
41660: LD_INT 1
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41672: LD_ADDR_VAR 0 49
41676: PUSH
41677: LD_INT 3
41679: PUSH
41680: LD_INT 1
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: LD_INT 3
41689: PUSH
41690: LD_INT 2
41692: PUSH
41693: EMPTY
41694: LIST
41695: LIST
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41701: LD_ADDR_VAR 0 50
41705: PUSH
41706: LD_INT 2
41708: PUSH
41709: LD_INT 3
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: PUSH
41716: LD_INT 1
41718: PUSH
41719: LD_INT 3
41721: PUSH
41722: EMPTY
41723: LIST
41724: LIST
41725: PUSH
41726: EMPTY
41727: LIST
41728: LIST
41729: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41730: LD_ADDR_VAR 0 51
41734: PUSH
41735: LD_INT 1
41737: NEG
41738: PUSH
41739: LD_INT 2
41741: PUSH
41742: EMPTY
41743: LIST
41744: LIST
41745: PUSH
41746: LD_INT 2
41748: NEG
41749: PUSH
41750: LD_INT 1
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41761: LD_ADDR_VAR 0 52
41765: PUSH
41766: LD_INT 3
41768: NEG
41769: PUSH
41770: LD_INT 1
41772: NEG
41773: PUSH
41774: EMPTY
41775: LIST
41776: LIST
41777: PUSH
41778: LD_INT 3
41780: NEG
41781: PUSH
41782: LD_INT 2
41784: NEG
41785: PUSH
41786: EMPTY
41787: LIST
41788: LIST
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41794: LD_ADDR_VAR 0 53
41798: PUSH
41799: LD_INT 1
41801: NEG
41802: PUSH
41803: LD_INT 3
41805: NEG
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 0
41813: PUSH
41814: LD_INT 3
41816: NEG
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 1
41824: PUSH
41825: LD_INT 2
41827: NEG
41828: PUSH
41829: EMPTY
41830: LIST
41831: LIST
41832: PUSH
41833: EMPTY
41834: LIST
41835: LIST
41836: LIST
41837: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41838: LD_ADDR_VAR 0 54
41842: PUSH
41843: LD_INT 2
41845: PUSH
41846: LD_INT 1
41848: NEG
41849: PUSH
41850: EMPTY
41851: LIST
41852: LIST
41853: PUSH
41854: LD_INT 3
41856: PUSH
41857: LD_INT 0
41859: PUSH
41860: EMPTY
41861: LIST
41862: LIST
41863: PUSH
41864: LD_INT 3
41866: PUSH
41867: LD_INT 1
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: LIST
41878: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41879: LD_ADDR_VAR 0 55
41883: PUSH
41884: LD_INT 3
41886: PUSH
41887: LD_INT 2
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 3
41896: PUSH
41897: LD_INT 3
41899: PUSH
41900: EMPTY
41901: LIST
41902: LIST
41903: PUSH
41904: LD_INT 2
41906: PUSH
41907: LD_INT 3
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: EMPTY
41915: LIST
41916: LIST
41917: LIST
41918: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41919: LD_ADDR_VAR 0 56
41923: PUSH
41924: LD_INT 1
41926: PUSH
41927: LD_INT 3
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 0
41936: PUSH
41937: LD_INT 3
41939: PUSH
41940: EMPTY
41941: LIST
41942: LIST
41943: PUSH
41944: LD_INT 1
41946: NEG
41947: PUSH
41948: LD_INT 2
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: LIST
41959: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41960: LD_ADDR_VAR 0 57
41964: PUSH
41965: LD_INT 2
41967: NEG
41968: PUSH
41969: LD_INT 1
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 3
41978: NEG
41979: PUSH
41980: LD_INT 0
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 3
41989: NEG
41990: PUSH
41991: LD_INT 1
41993: NEG
41994: PUSH
41995: EMPTY
41996: LIST
41997: LIST
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: LIST
42003: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
42004: LD_ADDR_VAR 0 58
42008: PUSH
42009: LD_INT 2
42011: NEG
42012: PUSH
42013: LD_INT 3
42015: NEG
42016: PUSH
42017: EMPTY
42018: LIST
42019: LIST
42020: PUSH
42021: LD_INT 3
42023: NEG
42024: PUSH
42025: LD_INT 2
42027: NEG
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 3
42035: NEG
42036: PUSH
42037: LD_INT 3
42039: NEG
42040: PUSH
42041: EMPTY
42042: LIST
42043: LIST
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: LIST
42049: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
42050: LD_ADDR_VAR 0 59
42054: PUSH
42055: LD_INT 1
42057: NEG
42058: PUSH
42059: LD_INT 2
42061: NEG
42062: PUSH
42063: EMPTY
42064: LIST
42065: LIST
42066: PUSH
42067: LD_INT 0
42069: PUSH
42070: LD_INT 2
42072: NEG
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 1
42080: PUSH
42081: LD_INT 1
42083: NEG
42084: PUSH
42085: EMPTY
42086: LIST
42087: LIST
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: LIST
42093: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
42094: LD_ADDR_VAR 0 60
42098: PUSH
42099: LD_INT 1
42101: PUSH
42102: LD_INT 1
42104: NEG
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 2
42112: PUSH
42113: LD_INT 0
42115: PUSH
42116: EMPTY
42117: LIST
42118: LIST
42119: PUSH
42120: LD_INT 2
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: EMPTY
42131: LIST
42132: LIST
42133: LIST
42134: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
42135: LD_ADDR_VAR 0 61
42139: PUSH
42140: LD_INT 2
42142: PUSH
42143: LD_INT 1
42145: PUSH
42146: EMPTY
42147: LIST
42148: LIST
42149: PUSH
42150: LD_INT 2
42152: PUSH
42153: LD_INT 2
42155: PUSH
42156: EMPTY
42157: LIST
42158: LIST
42159: PUSH
42160: LD_INT 1
42162: PUSH
42163: LD_INT 2
42165: PUSH
42166: EMPTY
42167: LIST
42168: LIST
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: LIST
42174: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
42175: LD_ADDR_VAR 0 62
42179: PUSH
42180: LD_INT 1
42182: PUSH
42183: LD_INT 2
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 0
42192: PUSH
42193: LD_INT 2
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 1
42202: NEG
42203: PUSH
42204: LD_INT 1
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: EMPTY
42212: LIST
42213: LIST
42214: LIST
42215: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
42216: LD_ADDR_VAR 0 63
42220: PUSH
42221: LD_INT 1
42223: NEG
42224: PUSH
42225: LD_INT 1
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 2
42234: NEG
42235: PUSH
42236: LD_INT 0
42238: PUSH
42239: EMPTY
42240: LIST
42241: LIST
42242: PUSH
42243: LD_INT 2
42245: NEG
42246: PUSH
42247: LD_INT 1
42249: NEG
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: EMPTY
42256: LIST
42257: LIST
42258: LIST
42259: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42260: LD_ADDR_VAR 0 64
42264: PUSH
42265: LD_INT 1
42267: NEG
42268: PUSH
42269: LD_INT 2
42271: NEG
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 2
42279: NEG
42280: PUSH
42281: LD_INT 1
42283: NEG
42284: PUSH
42285: EMPTY
42286: LIST
42287: LIST
42288: PUSH
42289: LD_INT 2
42291: NEG
42292: PUSH
42293: LD_INT 2
42295: NEG
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: LIST
42305: ST_TO_ADDR
// end ; 2 :
42306: GO 45572
42308: LD_INT 2
42310: DOUBLE
42311: EQUAL
42312: IFTRUE 42316
42314: GO 45571
42316: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
42317: LD_ADDR_VAR 0 29
42321: PUSH
42322: LD_INT 4
42324: PUSH
42325: LD_INT 0
42327: PUSH
42328: EMPTY
42329: LIST
42330: LIST
42331: PUSH
42332: LD_INT 4
42334: PUSH
42335: LD_INT 1
42337: NEG
42338: PUSH
42339: EMPTY
42340: LIST
42341: LIST
42342: PUSH
42343: LD_INT 5
42345: PUSH
42346: LD_INT 0
42348: PUSH
42349: EMPTY
42350: LIST
42351: LIST
42352: PUSH
42353: LD_INT 5
42355: PUSH
42356: LD_INT 1
42358: PUSH
42359: EMPTY
42360: LIST
42361: LIST
42362: PUSH
42363: LD_INT 4
42365: PUSH
42366: LD_INT 1
42368: PUSH
42369: EMPTY
42370: LIST
42371: LIST
42372: PUSH
42373: LD_INT 3
42375: PUSH
42376: LD_INT 0
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 3
42385: PUSH
42386: LD_INT 1
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 3
42396: PUSH
42397: LD_INT 2
42399: NEG
42400: PUSH
42401: EMPTY
42402: LIST
42403: LIST
42404: PUSH
42405: LD_INT 5
42407: PUSH
42408: LD_INT 2
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: PUSH
42415: LD_INT 3
42417: PUSH
42418: LD_INT 3
42420: PUSH
42421: EMPTY
42422: LIST
42423: LIST
42424: PUSH
42425: LD_INT 3
42427: PUSH
42428: LD_INT 2
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 4
42437: PUSH
42438: LD_INT 3
42440: PUSH
42441: EMPTY
42442: LIST
42443: LIST
42444: PUSH
42445: LD_INT 4
42447: PUSH
42448: LD_INT 4
42450: PUSH
42451: EMPTY
42452: LIST
42453: LIST
42454: PUSH
42455: LD_INT 3
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: EMPTY
42462: LIST
42463: LIST
42464: PUSH
42465: LD_INT 2
42467: PUSH
42468: LD_INT 3
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 2
42477: PUSH
42478: LD_INT 2
42480: PUSH
42481: EMPTY
42482: LIST
42483: LIST
42484: PUSH
42485: LD_INT 4
42487: PUSH
42488: LD_INT 2
42490: PUSH
42491: EMPTY
42492: LIST
42493: LIST
42494: PUSH
42495: LD_INT 2
42497: PUSH
42498: LD_INT 4
42500: PUSH
42501: EMPTY
42502: LIST
42503: LIST
42504: PUSH
42505: LD_INT 0
42507: PUSH
42508: LD_INT 4
42510: PUSH
42511: EMPTY
42512: LIST
42513: LIST
42514: PUSH
42515: LD_INT 0
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: EMPTY
42522: LIST
42523: LIST
42524: PUSH
42525: LD_INT 1
42527: PUSH
42528: LD_INT 4
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 1
42537: PUSH
42538: LD_INT 5
42540: PUSH
42541: EMPTY
42542: LIST
42543: LIST
42544: PUSH
42545: LD_INT 0
42547: PUSH
42548: LD_INT 5
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 1
42557: NEG
42558: PUSH
42559: LD_INT 4
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 1
42568: NEG
42569: PUSH
42570: LD_INT 3
42572: PUSH
42573: EMPTY
42574: LIST
42575: LIST
42576: PUSH
42577: LD_INT 2
42579: PUSH
42580: LD_INT 5
42582: PUSH
42583: EMPTY
42584: LIST
42585: LIST
42586: PUSH
42587: LD_INT 2
42589: NEG
42590: PUSH
42591: LD_INT 3
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 3
42600: NEG
42601: PUSH
42602: LD_INT 0
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 3
42611: NEG
42612: PUSH
42613: LD_INT 1
42615: NEG
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 2
42623: NEG
42624: PUSH
42625: LD_INT 0
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 2
42634: NEG
42635: PUSH
42636: LD_INT 1
42638: PUSH
42639: EMPTY
42640: LIST
42641: LIST
42642: PUSH
42643: LD_INT 3
42645: NEG
42646: PUSH
42647: LD_INT 1
42649: PUSH
42650: EMPTY
42651: LIST
42652: LIST
42653: PUSH
42654: LD_INT 4
42656: NEG
42657: PUSH
42658: LD_INT 0
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 4
42667: NEG
42668: PUSH
42669: LD_INT 1
42671: NEG
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 4
42679: NEG
42680: PUSH
42681: LD_INT 2
42683: NEG
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 2
42691: NEG
42692: PUSH
42693: LD_INT 2
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 4
42702: NEG
42703: PUSH
42704: LD_INT 4
42706: NEG
42707: PUSH
42708: EMPTY
42709: LIST
42710: LIST
42711: PUSH
42712: LD_INT 4
42714: NEG
42715: PUSH
42716: LD_INT 5
42718: NEG
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 3
42726: NEG
42727: PUSH
42728: LD_INT 4
42730: NEG
42731: PUSH
42732: EMPTY
42733: LIST
42734: LIST
42735: PUSH
42736: LD_INT 3
42738: NEG
42739: PUSH
42740: LD_INT 3
42742: NEG
42743: PUSH
42744: EMPTY
42745: LIST
42746: LIST
42747: PUSH
42748: LD_INT 4
42750: NEG
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 5
42762: NEG
42763: PUSH
42764: LD_INT 4
42766: NEG
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 5
42774: NEG
42775: PUSH
42776: LD_INT 5
42778: NEG
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: LD_INT 3
42786: NEG
42787: PUSH
42788: LD_INT 5
42790: NEG
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 5
42798: NEG
42799: PUSH
42800: LD_INT 3
42802: NEG
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: LIST
42812: LIST
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: LIST
42826: LIST
42827: LIST
42828: LIST
42829: LIST
42830: LIST
42831: LIST
42832: LIST
42833: LIST
42834: LIST
42835: LIST
42836: LIST
42837: LIST
42838: LIST
42839: LIST
42840: LIST
42841: LIST
42842: LIST
42843: LIST
42844: LIST
42845: LIST
42846: LIST
42847: LIST
42848: LIST
42849: LIST
42850: LIST
42851: LIST
42852: LIST
42853: LIST
42854: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42855: LD_ADDR_VAR 0 30
42859: PUSH
42860: LD_INT 4
42862: PUSH
42863: LD_INT 4
42865: PUSH
42866: EMPTY
42867: LIST
42868: LIST
42869: PUSH
42870: LD_INT 4
42872: PUSH
42873: LD_INT 3
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 5
42882: PUSH
42883: LD_INT 4
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: PUSH
42890: LD_INT 5
42892: PUSH
42893: LD_INT 5
42895: PUSH
42896: EMPTY
42897: LIST
42898: LIST
42899: PUSH
42900: LD_INT 4
42902: PUSH
42903: LD_INT 5
42905: PUSH
42906: EMPTY
42907: LIST
42908: LIST
42909: PUSH
42910: LD_INT 3
42912: PUSH
42913: LD_INT 4
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 3
42922: PUSH
42923: LD_INT 3
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 5
42932: PUSH
42933: LD_INT 3
42935: PUSH
42936: EMPTY
42937: LIST
42938: LIST
42939: PUSH
42940: LD_INT 3
42942: PUSH
42943: LD_INT 5
42945: PUSH
42946: EMPTY
42947: LIST
42948: LIST
42949: PUSH
42950: LD_INT 0
42952: PUSH
42953: LD_INT 3
42955: PUSH
42956: EMPTY
42957: LIST
42958: LIST
42959: PUSH
42960: LD_INT 0
42962: PUSH
42963: LD_INT 2
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: PUSH
42970: LD_INT 1
42972: PUSH
42973: LD_INT 3
42975: PUSH
42976: EMPTY
42977: LIST
42978: LIST
42979: PUSH
42980: LD_INT 1
42982: PUSH
42983: LD_INT 4
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: PUSH
42990: LD_INT 0
42992: PUSH
42993: LD_INT 4
42995: PUSH
42996: EMPTY
42997: LIST
42998: LIST
42999: PUSH
43000: LD_INT 1
43002: NEG
43003: PUSH
43004: LD_INT 3
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: PUSH
43011: LD_INT 1
43013: NEG
43014: PUSH
43015: LD_INT 2
43017: PUSH
43018: EMPTY
43019: LIST
43020: LIST
43021: PUSH
43022: LD_INT 2
43024: PUSH
43025: LD_INT 4
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PUSH
43032: LD_INT 2
43034: NEG
43035: PUSH
43036: LD_INT 2
43038: PUSH
43039: EMPTY
43040: LIST
43041: LIST
43042: PUSH
43043: LD_INT 4
43045: NEG
43046: PUSH
43047: LD_INT 0
43049: PUSH
43050: EMPTY
43051: LIST
43052: LIST
43053: PUSH
43054: LD_INT 4
43056: NEG
43057: PUSH
43058: LD_INT 1
43060: NEG
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 3
43068: NEG
43069: PUSH
43070: LD_INT 0
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 3
43079: NEG
43080: PUSH
43081: LD_INT 1
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: PUSH
43088: LD_INT 4
43090: NEG
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 5
43101: NEG
43102: PUSH
43103: LD_INT 0
43105: PUSH
43106: EMPTY
43107: LIST
43108: LIST
43109: PUSH
43110: LD_INT 5
43112: NEG
43113: PUSH
43114: LD_INT 1
43116: NEG
43117: PUSH
43118: EMPTY
43119: LIST
43120: LIST
43121: PUSH
43122: LD_INT 5
43124: NEG
43125: PUSH
43126: LD_INT 2
43128: NEG
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 3
43136: NEG
43137: PUSH
43138: LD_INT 2
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 3
43147: NEG
43148: PUSH
43149: LD_INT 3
43151: NEG
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 3
43159: NEG
43160: PUSH
43161: LD_INT 4
43163: NEG
43164: PUSH
43165: EMPTY
43166: LIST
43167: LIST
43168: PUSH
43169: LD_INT 2
43171: NEG
43172: PUSH
43173: LD_INT 3
43175: NEG
43176: PUSH
43177: EMPTY
43178: LIST
43179: LIST
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: LD_INT 2
43187: NEG
43188: PUSH
43189: EMPTY
43190: LIST
43191: LIST
43192: PUSH
43193: LD_INT 3
43195: NEG
43196: PUSH
43197: LD_INT 2
43199: NEG
43200: PUSH
43201: EMPTY
43202: LIST
43203: LIST
43204: PUSH
43205: LD_INT 4
43207: NEG
43208: PUSH
43209: LD_INT 3
43211: NEG
43212: PUSH
43213: EMPTY
43214: LIST
43215: LIST
43216: PUSH
43217: LD_INT 4
43219: NEG
43220: PUSH
43221: LD_INT 4
43223: NEG
43224: PUSH
43225: EMPTY
43226: LIST
43227: LIST
43228: PUSH
43229: LD_INT 2
43231: NEG
43232: PUSH
43233: LD_INT 4
43235: NEG
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: LD_INT 4
43243: NEG
43244: PUSH
43245: LD_INT 2
43247: NEG
43248: PUSH
43249: EMPTY
43250: LIST
43251: LIST
43252: PUSH
43253: LD_INT 0
43255: PUSH
43256: LD_INT 4
43258: NEG
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: PUSH
43264: LD_INT 0
43266: PUSH
43267: LD_INT 5
43269: NEG
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: PUSH
43275: LD_INT 1
43277: PUSH
43278: LD_INT 4
43280: NEG
43281: PUSH
43282: EMPTY
43283: LIST
43284: LIST
43285: PUSH
43286: LD_INT 1
43288: PUSH
43289: LD_INT 3
43291: NEG
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 0
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 1
43310: NEG
43311: PUSH
43312: LD_INT 4
43314: NEG
43315: PUSH
43316: EMPTY
43317: LIST
43318: LIST
43319: PUSH
43320: LD_INT 1
43322: NEG
43323: PUSH
43324: LD_INT 5
43326: NEG
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 2
43334: PUSH
43335: LD_INT 3
43337: NEG
43338: PUSH
43339: EMPTY
43340: LIST
43341: LIST
43342: PUSH
43343: LD_INT 2
43345: NEG
43346: PUSH
43347: LD_INT 5
43349: NEG
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: LIST
43359: LIST
43360: LIST
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: LIST
43379: LIST
43380: LIST
43381: LIST
43382: LIST
43383: LIST
43384: LIST
43385: LIST
43386: LIST
43387: LIST
43388: LIST
43389: LIST
43390: LIST
43391: LIST
43392: LIST
43393: LIST
43394: LIST
43395: LIST
43396: LIST
43397: LIST
43398: LIST
43399: LIST
43400: LIST
43401: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43402: LD_ADDR_VAR 0 31
43406: PUSH
43407: LD_INT 0
43409: PUSH
43410: LD_INT 4
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: PUSH
43417: LD_INT 0
43419: PUSH
43420: LD_INT 3
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: LD_INT 1
43429: PUSH
43430: LD_INT 4
43432: PUSH
43433: EMPTY
43434: LIST
43435: LIST
43436: PUSH
43437: LD_INT 1
43439: PUSH
43440: LD_INT 5
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: LD_INT 0
43449: PUSH
43450: LD_INT 5
43452: PUSH
43453: EMPTY
43454: LIST
43455: LIST
43456: PUSH
43457: LD_INT 1
43459: NEG
43460: PUSH
43461: LD_INT 4
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 1
43470: NEG
43471: PUSH
43472: LD_INT 3
43474: PUSH
43475: EMPTY
43476: LIST
43477: LIST
43478: PUSH
43479: LD_INT 2
43481: PUSH
43482: LD_INT 5
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 2
43491: NEG
43492: PUSH
43493: LD_INT 3
43495: PUSH
43496: EMPTY
43497: LIST
43498: LIST
43499: PUSH
43500: LD_INT 3
43502: NEG
43503: PUSH
43504: LD_INT 0
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: LD_INT 3
43513: NEG
43514: PUSH
43515: LD_INT 1
43517: NEG
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: PUSH
43523: LD_INT 2
43525: NEG
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 2
43536: NEG
43537: PUSH
43538: LD_INT 1
43540: PUSH
43541: EMPTY
43542: LIST
43543: LIST
43544: PUSH
43545: LD_INT 3
43547: NEG
43548: PUSH
43549: LD_INT 1
43551: PUSH
43552: EMPTY
43553: LIST
43554: LIST
43555: PUSH
43556: LD_INT 4
43558: NEG
43559: PUSH
43560: LD_INT 0
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 4
43569: NEG
43570: PUSH
43571: LD_INT 1
43573: NEG
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: LD_INT 4
43581: NEG
43582: PUSH
43583: LD_INT 2
43585: NEG
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 2
43593: NEG
43594: PUSH
43595: LD_INT 2
43597: PUSH
43598: EMPTY
43599: LIST
43600: LIST
43601: PUSH
43602: LD_INT 4
43604: NEG
43605: PUSH
43606: LD_INT 4
43608: NEG
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 4
43616: NEG
43617: PUSH
43618: LD_INT 5
43620: NEG
43621: PUSH
43622: EMPTY
43623: LIST
43624: LIST
43625: PUSH
43626: LD_INT 3
43628: NEG
43629: PUSH
43630: LD_INT 4
43632: NEG
43633: PUSH
43634: EMPTY
43635: LIST
43636: LIST
43637: PUSH
43638: LD_INT 3
43640: NEG
43641: PUSH
43642: LD_INT 3
43644: NEG
43645: PUSH
43646: EMPTY
43647: LIST
43648: LIST
43649: PUSH
43650: LD_INT 4
43652: NEG
43653: PUSH
43654: LD_INT 3
43656: NEG
43657: PUSH
43658: EMPTY
43659: LIST
43660: LIST
43661: PUSH
43662: LD_INT 5
43664: NEG
43665: PUSH
43666: LD_INT 4
43668: NEG
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 5
43676: NEG
43677: PUSH
43678: LD_INT 5
43680: NEG
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: LD_INT 3
43688: NEG
43689: PUSH
43690: LD_INT 5
43692: NEG
43693: PUSH
43694: EMPTY
43695: LIST
43696: LIST
43697: PUSH
43698: LD_INT 5
43700: NEG
43701: PUSH
43702: LD_INT 3
43704: NEG
43705: PUSH
43706: EMPTY
43707: LIST
43708: LIST
43709: PUSH
43710: LD_INT 0
43712: PUSH
43713: LD_INT 3
43715: NEG
43716: PUSH
43717: EMPTY
43718: LIST
43719: LIST
43720: PUSH
43721: LD_INT 0
43723: PUSH
43724: LD_INT 4
43726: NEG
43727: PUSH
43728: EMPTY
43729: LIST
43730: LIST
43731: PUSH
43732: LD_INT 1
43734: PUSH
43735: LD_INT 3
43737: NEG
43738: PUSH
43739: EMPTY
43740: LIST
43741: LIST
43742: PUSH
43743: LD_INT 1
43745: PUSH
43746: LD_INT 2
43748: NEG
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 0
43756: PUSH
43757: LD_INT 2
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 1
43767: NEG
43768: PUSH
43769: LD_INT 3
43771: NEG
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 1
43779: NEG
43780: PUSH
43781: LD_INT 4
43783: NEG
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: LD_INT 2
43791: PUSH
43792: LD_INT 2
43794: NEG
43795: PUSH
43796: EMPTY
43797: LIST
43798: LIST
43799: PUSH
43800: LD_INT 2
43802: NEG
43803: PUSH
43804: LD_INT 4
43806: NEG
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 4
43814: PUSH
43815: LD_INT 0
43817: PUSH
43818: EMPTY
43819: LIST
43820: LIST
43821: PUSH
43822: LD_INT 4
43824: PUSH
43825: LD_INT 1
43827: NEG
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 5
43835: PUSH
43836: LD_INT 0
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 5
43845: PUSH
43846: LD_INT 1
43848: PUSH
43849: EMPTY
43850: LIST
43851: LIST
43852: PUSH
43853: LD_INT 4
43855: PUSH
43856: LD_INT 1
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: LD_INT 3
43865: PUSH
43866: LD_INT 0
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 3
43875: PUSH
43876: LD_INT 1
43878: NEG
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: LD_INT 3
43886: PUSH
43887: LD_INT 2
43889: NEG
43890: PUSH
43891: EMPTY
43892: LIST
43893: LIST
43894: PUSH
43895: LD_INT 5
43897: PUSH
43898: LD_INT 2
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: LIST
43909: LIST
43910: LIST
43911: LIST
43912: LIST
43913: LIST
43914: LIST
43915: LIST
43916: LIST
43917: LIST
43918: LIST
43919: LIST
43920: LIST
43921: LIST
43922: LIST
43923: LIST
43924: LIST
43925: LIST
43926: LIST
43927: LIST
43928: LIST
43929: LIST
43930: LIST
43931: LIST
43932: LIST
43933: LIST
43934: LIST
43935: LIST
43936: LIST
43937: LIST
43938: LIST
43939: LIST
43940: LIST
43941: LIST
43942: LIST
43943: LIST
43944: LIST
43945: LIST
43946: LIST
43947: LIST
43948: LIST
43949: LIST
43950: LIST
43951: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43952: LD_ADDR_VAR 0 32
43956: PUSH
43957: LD_INT 4
43959: NEG
43960: PUSH
43961: LD_INT 0
43963: PUSH
43964: EMPTY
43965: LIST
43966: LIST
43967: PUSH
43968: LD_INT 4
43970: NEG
43971: PUSH
43972: LD_INT 1
43974: NEG
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 3
43982: NEG
43983: PUSH
43984: LD_INT 0
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 3
43993: NEG
43994: PUSH
43995: LD_INT 1
43997: PUSH
43998: EMPTY
43999: LIST
44000: LIST
44001: PUSH
44002: LD_INT 4
44004: NEG
44005: PUSH
44006: LD_INT 1
44008: PUSH
44009: EMPTY
44010: LIST
44011: LIST
44012: PUSH
44013: LD_INT 5
44015: NEG
44016: PUSH
44017: LD_INT 0
44019: PUSH
44020: EMPTY
44021: LIST
44022: LIST
44023: PUSH
44024: LD_INT 5
44026: NEG
44027: PUSH
44028: LD_INT 1
44030: NEG
44031: PUSH
44032: EMPTY
44033: LIST
44034: LIST
44035: PUSH
44036: LD_INT 5
44038: NEG
44039: PUSH
44040: LD_INT 2
44042: NEG
44043: PUSH
44044: EMPTY
44045: LIST
44046: LIST
44047: PUSH
44048: LD_INT 3
44050: NEG
44051: PUSH
44052: LD_INT 2
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 3
44061: NEG
44062: PUSH
44063: LD_INT 3
44065: NEG
44066: PUSH
44067: EMPTY
44068: LIST
44069: LIST
44070: PUSH
44071: LD_INT 3
44073: NEG
44074: PUSH
44075: LD_INT 4
44077: NEG
44078: PUSH
44079: EMPTY
44080: LIST
44081: LIST
44082: PUSH
44083: LD_INT 2
44085: NEG
44086: PUSH
44087: LD_INT 3
44089: NEG
44090: PUSH
44091: EMPTY
44092: LIST
44093: LIST
44094: PUSH
44095: LD_INT 2
44097: NEG
44098: PUSH
44099: LD_INT 2
44101: NEG
44102: PUSH
44103: EMPTY
44104: LIST
44105: LIST
44106: PUSH
44107: LD_INT 3
44109: NEG
44110: PUSH
44111: LD_INT 2
44113: NEG
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 4
44121: NEG
44122: PUSH
44123: LD_INT 3
44125: NEG
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 4
44133: NEG
44134: PUSH
44135: LD_INT 4
44137: NEG
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 2
44145: NEG
44146: PUSH
44147: LD_INT 4
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 4
44157: NEG
44158: PUSH
44159: LD_INT 2
44161: NEG
44162: PUSH
44163: EMPTY
44164: LIST
44165: LIST
44166: PUSH
44167: LD_INT 0
44169: PUSH
44170: LD_INT 4
44172: NEG
44173: PUSH
44174: EMPTY
44175: LIST
44176: LIST
44177: PUSH
44178: LD_INT 0
44180: PUSH
44181: LD_INT 5
44183: NEG
44184: PUSH
44185: EMPTY
44186: LIST
44187: LIST
44188: PUSH
44189: LD_INT 1
44191: PUSH
44192: LD_INT 4
44194: NEG
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 1
44202: PUSH
44203: LD_INT 3
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 0
44213: PUSH
44214: LD_INT 3
44216: NEG
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: LD_INT 1
44224: NEG
44225: PUSH
44226: LD_INT 4
44228: NEG
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 1
44236: NEG
44237: PUSH
44238: LD_INT 5
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 2
44248: PUSH
44249: LD_INT 3
44251: NEG
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: LD_INT 5
44263: NEG
44264: PUSH
44265: EMPTY
44266: LIST
44267: LIST
44268: PUSH
44269: LD_INT 3
44271: PUSH
44272: LD_INT 0
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 3
44281: PUSH
44282: LD_INT 1
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 4
44292: PUSH
44293: LD_INT 0
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 4
44302: PUSH
44303: LD_INT 1
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 3
44312: PUSH
44313: LD_INT 1
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 2
44322: PUSH
44323: LD_INT 0
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 2
44332: PUSH
44333: LD_INT 1
44335: NEG
44336: PUSH
44337: EMPTY
44338: LIST
44339: LIST
44340: PUSH
44341: LD_INT 2
44343: PUSH
44344: LD_INT 2
44346: NEG
44347: PUSH
44348: EMPTY
44349: LIST
44350: LIST
44351: PUSH
44352: LD_INT 4
44354: PUSH
44355: LD_INT 2
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: LD_INT 4
44364: PUSH
44365: LD_INT 4
44367: PUSH
44368: EMPTY
44369: LIST
44370: LIST
44371: PUSH
44372: LD_INT 4
44374: PUSH
44375: LD_INT 3
44377: PUSH
44378: EMPTY
44379: LIST
44380: LIST
44381: PUSH
44382: LD_INT 5
44384: PUSH
44385: LD_INT 4
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PUSH
44392: LD_INT 5
44394: PUSH
44395: LD_INT 5
44397: PUSH
44398: EMPTY
44399: LIST
44400: LIST
44401: PUSH
44402: LD_INT 4
44404: PUSH
44405: LD_INT 5
44407: PUSH
44408: EMPTY
44409: LIST
44410: LIST
44411: PUSH
44412: LD_INT 3
44414: PUSH
44415: LD_INT 4
44417: PUSH
44418: EMPTY
44419: LIST
44420: LIST
44421: PUSH
44422: LD_INT 3
44424: PUSH
44425: LD_INT 3
44427: PUSH
44428: EMPTY
44429: LIST
44430: LIST
44431: PUSH
44432: LD_INT 5
44434: PUSH
44435: LD_INT 3
44437: PUSH
44438: EMPTY
44439: LIST
44440: LIST
44441: PUSH
44442: LD_INT 3
44444: PUSH
44445: LD_INT 5
44447: PUSH
44448: EMPTY
44449: LIST
44450: LIST
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: LIST
44478: LIST
44479: LIST
44480: LIST
44481: LIST
44482: LIST
44483: LIST
44484: LIST
44485: LIST
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: LIST
44492: LIST
44493: LIST
44494: LIST
44495: LIST
44496: LIST
44497: LIST
44498: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44499: LD_ADDR_VAR 0 33
44503: PUSH
44504: LD_INT 4
44506: NEG
44507: PUSH
44508: LD_INT 4
44510: NEG
44511: PUSH
44512: EMPTY
44513: LIST
44514: LIST
44515: PUSH
44516: LD_INT 4
44518: NEG
44519: PUSH
44520: LD_INT 5
44522: NEG
44523: PUSH
44524: EMPTY
44525: LIST
44526: LIST
44527: PUSH
44528: LD_INT 3
44530: NEG
44531: PUSH
44532: LD_INT 4
44534: NEG
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: PUSH
44540: LD_INT 3
44542: NEG
44543: PUSH
44544: LD_INT 3
44546: NEG
44547: PUSH
44548: EMPTY
44549: LIST
44550: LIST
44551: PUSH
44552: LD_INT 4
44554: NEG
44555: PUSH
44556: LD_INT 3
44558: NEG
44559: PUSH
44560: EMPTY
44561: LIST
44562: LIST
44563: PUSH
44564: LD_INT 5
44566: NEG
44567: PUSH
44568: LD_INT 4
44570: NEG
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 5
44578: NEG
44579: PUSH
44580: LD_INT 5
44582: NEG
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 3
44590: NEG
44591: PUSH
44592: LD_INT 5
44594: NEG
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 5
44602: NEG
44603: PUSH
44604: LD_INT 3
44606: NEG
44607: PUSH
44608: EMPTY
44609: LIST
44610: LIST
44611: PUSH
44612: LD_INT 0
44614: PUSH
44615: LD_INT 3
44617: NEG
44618: PUSH
44619: EMPTY
44620: LIST
44621: LIST
44622: PUSH
44623: LD_INT 0
44625: PUSH
44626: LD_INT 4
44628: NEG
44629: PUSH
44630: EMPTY
44631: LIST
44632: LIST
44633: PUSH
44634: LD_INT 1
44636: PUSH
44637: LD_INT 3
44639: NEG
44640: PUSH
44641: EMPTY
44642: LIST
44643: LIST
44644: PUSH
44645: LD_INT 1
44647: PUSH
44648: LD_INT 2
44650: NEG
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 0
44658: PUSH
44659: LD_INT 2
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 1
44669: NEG
44670: PUSH
44671: LD_INT 3
44673: NEG
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 1
44681: NEG
44682: PUSH
44683: LD_INT 4
44685: NEG
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 2
44693: PUSH
44694: LD_INT 2
44696: NEG
44697: PUSH
44698: EMPTY
44699: LIST
44700: LIST
44701: PUSH
44702: LD_INT 2
44704: NEG
44705: PUSH
44706: LD_INT 4
44708: NEG
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 4
44716: PUSH
44717: LD_INT 0
44719: PUSH
44720: EMPTY
44721: LIST
44722: LIST
44723: PUSH
44724: LD_INT 4
44726: PUSH
44727: LD_INT 1
44729: NEG
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 5
44737: PUSH
44738: LD_INT 0
44740: PUSH
44741: EMPTY
44742: LIST
44743: LIST
44744: PUSH
44745: LD_INT 5
44747: PUSH
44748: LD_INT 1
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 4
44757: PUSH
44758: LD_INT 1
44760: PUSH
44761: EMPTY
44762: LIST
44763: LIST
44764: PUSH
44765: LD_INT 3
44767: PUSH
44768: LD_INT 0
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 3
44777: PUSH
44778: LD_INT 1
44780: NEG
44781: PUSH
44782: EMPTY
44783: LIST
44784: LIST
44785: PUSH
44786: LD_INT 3
44788: PUSH
44789: LD_INT 2
44791: NEG
44792: PUSH
44793: EMPTY
44794: LIST
44795: LIST
44796: PUSH
44797: LD_INT 5
44799: PUSH
44800: LD_INT 2
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 3
44809: PUSH
44810: LD_INT 3
44812: PUSH
44813: EMPTY
44814: LIST
44815: LIST
44816: PUSH
44817: LD_INT 3
44819: PUSH
44820: LD_INT 2
44822: PUSH
44823: EMPTY
44824: LIST
44825: LIST
44826: PUSH
44827: LD_INT 4
44829: PUSH
44830: LD_INT 3
44832: PUSH
44833: EMPTY
44834: LIST
44835: LIST
44836: PUSH
44837: LD_INT 4
44839: PUSH
44840: LD_INT 4
44842: PUSH
44843: EMPTY
44844: LIST
44845: LIST
44846: PUSH
44847: LD_INT 3
44849: PUSH
44850: LD_INT 4
44852: PUSH
44853: EMPTY
44854: LIST
44855: LIST
44856: PUSH
44857: LD_INT 2
44859: PUSH
44860: LD_INT 3
44862: PUSH
44863: EMPTY
44864: LIST
44865: LIST
44866: PUSH
44867: LD_INT 2
44869: PUSH
44870: LD_INT 2
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 4
44879: PUSH
44880: LD_INT 2
44882: PUSH
44883: EMPTY
44884: LIST
44885: LIST
44886: PUSH
44887: LD_INT 2
44889: PUSH
44890: LD_INT 4
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 0
44899: PUSH
44900: LD_INT 4
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: PUSH
44907: LD_INT 0
44909: PUSH
44910: LD_INT 3
44912: PUSH
44913: EMPTY
44914: LIST
44915: LIST
44916: PUSH
44917: LD_INT 1
44919: PUSH
44920: LD_INT 4
44922: PUSH
44923: EMPTY
44924: LIST
44925: LIST
44926: PUSH
44927: LD_INT 1
44929: PUSH
44930: LD_INT 5
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 0
44939: PUSH
44940: LD_INT 5
44942: PUSH
44943: EMPTY
44944: LIST
44945: LIST
44946: PUSH
44947: LD_INT 1
44949: NEG
44950: PUSH
44951: LD_INT 4
44953: PUSH
44954: EMPTY
44955: LIST
44956: LIST
44957: PUSH
44958: LD_INT 1
44960: NEG
44961: PUSH
44962: LD_INT 3
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 2
44971: PUSH
44972: LD_INT 5
44974: PUSH
44975: EMPTY
44976: LIST
44977: LIST
44978: PUSH
44979: LD_INT 2
44981: NEG
44982: PUSH
44983: LD_INT 3
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: LIST
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: LIST
45023: LIST
45024: LIST
45025: LIST
45026: LIST
45027: LIST
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
45037: LD_ADDR_VAR 0 34
45041: PUSH
45042: LD_INT 0
45044: PUSH
45045: LD_INT 4
45047: NEG
45048: PUSH
45049: EMPTY
45050: LIST
45051: LIST
45052: PUSH
45053: LD_INT 0
45055: PUSH
45056: LD_INT 5
45058: NEG
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 1
45066: PUSH
45067: LD_INT 4
45069: NEG
45070: PUSH
45071: EMPTY
45072: LIST
45073: LIST
45074: PUSH
45075: LD_INT 1
45077: PUSH
45078: LD_INT 3
45080: NEG
45081: PUSH
45082: EMPTY
45083: LIST
45084: LIST
45085: PUSH
45086: LD_INT 0
45088: PUSH
45089: LD_INT 3
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 1
45099: NEG
45100: PUSH
45101: LD_INT 4
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 1
45111: NEG
45112: PUSH
45113: LD_INT 5
45115: NEG
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 2
45123: PUSH
45124: LD_INT 3
45126: NEG
45127: PUSH
45128: EMPTY
45129: LIST
45130: LIST
45131: PUSH
45132: LD_INT 2
45134: NEG
45135: PUSH
45136: LD_INT 5
45138: NEG
45139: PUSH
45140: EMPTY
45141: LIST
45142: LIST
45143: PUSH
45144: LD_INT 3
45146: PUSH
45147: LD_INT 0
45149: PUSH
45150: EMPTY
45151: LIST
45152: LIST
45153: PUSH
45154: LD_INT 3
45156: PUSH
45157: LD_INT 1
45159: NEG
45160: PUSH
45161: EMPTY
45162: LIST
45163: LIST
45164: PUSH
45165: LD_INT 4
45167: PUSH
45168: LD_INT 0
45170: PUSH
45171: EMPTY
45172: LIST
45173: LIST
45174: PUSH
45175: LD_INT 4
45177: PUSH
45178: LD_INT 1
45180: PUSH
45181: EMPTY
45182: LIST
45183: LIST
45184: PUSH
45185: LD_INT 3
45187: PUSH
45188: LD_INT 1
45190: PUSH
45191: EMPTY
45192: LIST
45193: LIST
45194: PUSH
45195: LD_INT 2
45197: PUSH
45198: LD_INT 0
45200: PUSH
45201: EMPTY
45202: LIST
45203: LIST
45204: PUSH
45205: LD_INT 2
45207: PUSH
45208: LD_INT 1
45210: NEG
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: PUSH
45216: LD_INT 2
45218: PUSH
45219: LD_INT 2
45221: NEG
45222: PUSH
45223: EMPTY
45224: LIST
45225: LIST
45226: PUSH
45227: LD_INT 4
45229: PUSH
45230: LD_INT 2
45232: PUSH
45233: EMPTY
45234: LIST
45235: LIST
45236: PUSH
45237: LD_INT 4
45239: PUSH
45240: LD_INT 4
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 4
45249: PUSH
45250: LD_INT 3
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 5
45259: PUSH
45260: LD_INT 4
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 5
45269: PUSH
45270: LD_INT 5
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 4
45279: PUSH
45280: LD_INT 5
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 3
45289: PUSH
45290: LD_INT 4
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 3
45299: PUSH
45300: LD_INT 3
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: PUSH
45307: LD_INT 5
45309: PUSH
45310: LD_INT 3
45312: PUSH
45313: EMPTY
45314: LIST
45315: LIST
45316: PUSH
45317: LD_INT 3
45319: PUSH
45320: LD_INT 5
45322: PUSH
45323: EMPTY
45324: LIST
45325: LIST
45326: PUSH
45327: LD_INT 0
45329: PUSH
45330: LD_INT 3
45332: PUSH
45333: EMPTY
45334: LIST
45335: LIST
45336: PUSH
45337: LD_INT 0
45339: PUSH
45340: LD_INT 2
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 1
45349: PUSH
45350: LD_INT 3
45352: PUSH
45353: EMPTY
45354: LIST
45355: LIST
45356: PUSH
45357: LD_INT 1
45359: PUSH
45360: LD_INT 4
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 0
45369: PUSH
45370: LD_INT 4
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 1
45379: NEG
45380: PUSH
45381: LD_INT 3
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: PUSH
45388: LD_INT 1
45390: NEG
45391: PUSH
45392: LD_INT 2
45394: PUSH
45395: EMPTY
45396: LIST
45397: LIST
45398: PUSH
45399: LD_INT 2
45401: PUSH
45402: LD_INT 4
45404: PUSH
45405: EMPTY
45406: LIST
45407: LIST
45408: PUSH
45409: LD_INT 2
45411: NEG
45412: PUSH
45413: LD_INT 2
45415: PUSH
45416: EMPTY
45417: LIST
45418: LIST
45419: PUSH
45420: LD_INT 4
45422: NEG
45423: PUSH
45424: LD_INT 0
45426: PUSH
45427: EMPTY
45428: LIST
45429: LIST
45430: PUSH
45431: LD_INT 4
45433: NEG
45434: PUSH
45435: LD_INT 1
45437: NEG
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: PUSH
45443: LD_INT 3
45445: NEG
45446: PUSH
45447: LD_INT 0
45449: PUSH
45450: EMPTY
45451: LIST
45452: LIST
45453: PUSH
45454: LD_INT 3
45456: NEG
45457: PUSH
45458: LD_INT 1
45460: PUSH
45461: EMPTY
45462: LIST
45463: LIST
45464: PUSH
45465: LD_INT 4
45467: NEG
45468: PUSH
45469: LD_INT 1
45471: PUSH
45472: EMPTY
45473: LIST
45474: LIST
45475: PUSH
45476: LD_INT 5
45478: NEG
45479: PUSH
45480: LD_INT 0
45482: PUSH
45483: EMPTY
45484: LIST
45485: LIST
45486: PUSH
45487: LD_INT 5
45489: NEG
45490: PUSH
45491: LD_INT 1
45493: NEG
45494: PUSH
45495: EMPTY
45496: LIST
45497: LIST
45498: PUSH
45499: LD_INT 5
45501: NEG
45502: PUSH
45503: LD_INT 2
45505: NEG
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: PUSH
45511: LD_INT 3
45513: NEG
45514: PUSH
45515: LD_INT 2
45517: PUSH
45518: EMPTY
45519: LIST
45520: LIST
45521: PUSH
45522: EMPTY
45523: LIST
45524: LIST
45525: LIST
45526: LIST
45527: LIST
45528: LIST
45529: LIST
45530: LIST
45531: LIST
45532: LIST
45533: LIST
45534: LIST
45535: LIST
45536: LIST
45537: LIST
45538: LIST
45539: LIST
45540: LIST
45541: LIST
45542: LIST
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: ST_TO_ADDR
// end ; end ;
45569: GO 45572
45571: POP
// case btype of b_depot , b_warehouse :
45572: LD_VAR 0 1
45576: PUSH
45577: LD_INT 0
45579: DOUBLE
45580: EQUAL
45581: IFTRUE 45591
45583: LD_INT 1
45585: DOUBLE
45586: EQUAL
45587: IFTRUE 45591
45589: GO 45792
45591: POP
// case nation of nation_american :
45592: LD_VAR 0 5
45596: PUSH
45597: LD_INT 1
45599: DOUBLE
45600: EQUAL
45601: IFTRUE 45605
45603: GO 45661
45605: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45606: LD_ADDR_VAR 0 9
45610: PUSH
45611: LD_VAR 0 11
45615: PUSH
45616: LD_VAR 0 12
45620: PUSH
45621: LD_VAR 0 13
45625: PUSH
45626: LD_VAR 0 14
45630: PUSH
45631: LD_VAR 0 15
45635: PUSH
45636: LD_VAR 0 16
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: LIST
45645: LIST
45646: LIST
45647: LIST
45648: PUSH
45649: LD_VAR 0 4
45653: PUSH
45654: LD_INT 1
45656: PLUS
45657: ARRAY
45658: ST_TO_ADDR
45659: GO 45790
45661: LD_INT 2
45663: DOUBLE
45664: EQUAL
45665: IFTRUE 45669
45667: GO 45725
45669: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45670: LD_ADDR_VAR 0 9
45674: PUSH
45675: LD_VAR 0 17
45679: PUSH
45680: LD_VAR 0 18
45684: PUSH
45685: LD_VAR 0 19
45689: PUSH
45690: LD_VAR 0 20
45694: PUSH
45695: LD_VAR 0 21
45699: PUSH
45700: LD_VAR 0 22
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: LIST
45709: LIST
45710: LIST
45711: LIST
45712: PUSH
45713: LD_VAR 0 4
45717: PUSH
45718: LD_INT 1
45720: PLUS
45721: ARRAY
45722: ST_TO_ADDR
45723: GO 45790
45725: LD_INT 3
45727: DOUBLE
45728: EQUAL
45729: IFTRUE 45733
45731: GO 45789
45733: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45734: LD_ADDR_VAR 0 9
45738: PUSH
45739: LD_VAR 0 23
45743: PUSH
45744: LD_VAR 0 24
45748: PUSH
45749: LD_VAR 0 25
45753: PUSH
45754: LD_VAR 0 26
45758: PUSH
45759: LD_VAR 0 27
45763: PUSH
45764: LD_VAR 0 28
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: LIST
45773: LIST
45774: LIST
45775: LIST
45776: PUSH
45777: LD_VAR 0 4
45781: PUSH
45782: LD_INT 1
45784: PLUS
45785: ARRAY
45786: ST_TO_ADDR
45787: GO 45790
45789: POP
45790: GO 46345
45792: LD_INT 2
45794: DOUBLE
45795: EQUAL
45796: IFTRUE 45806
45798: LD_INT 3
45800: DOUBLE
45801: EQUAL
45802: IFTRUE 45806
45804: GO 45862
45806: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45807: LD_ADDR_VAR 0 9
45811: PUSH
45812: LD_VAR 0 29
45816: PUSH
45817: LD_VAR 0 30
45821: PUSH
45822: LD_VAR 0 31
45826: PUSH
45827: LD_VAR 0 32
45831: PUSH
45832: LD_VAR 0 33
45836: PUSH
45837: LD_VAR 0 34
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: LIST
45849: PUSH
45850: LD_VAR 0 4
45854: PUSH
45855: LD_INT 1
45857: PLUS
45858: ARRAY
45859: ST_TO_ADDR
45860: GO 46345
45862: LD_INT 16
45864: DOUBLE
45865: EQUAL
45866: IFTRUE 45924
45868: LD_INT 17
45870: DOUBLE
45871: EQUAL
45872: IFTRUE 45924
45874: LD_INT 18
45876: DOUBLE
45877: EQUAL
45878: IFTRUE 45924
45880: LD_INT 19
45882: DOUBLE
45883: EQUAL
45884: IFTRUE 45924
45886: LD_INT 22
45888: DOUBLE
45889: EQUAL
45890: IFTRUE 45924
45892: LD_INT 20
45894: DOUBLE
45895: EQUAL
45896: IFTRUE 45924
45898: LD_INT 21
45900: DOUBLE
45901: EQUAL
45902: IFTRUE 45924
45904: LD_INT 23
45906: DOUBLE
45907: EQUAL
45908: IFTRUE 45924
45910: LD_INT 24
45912: DOUBLE
45913: EQUAL
45914: IFTRUE 45924
45916: LD_INT 25
45918: DOUBLE
45919: EQUAL
45920: IFTRUE 45924
45922: GO 45980
45924: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45925: LD_ADDR_VAR 0 9
45929: PUSH
45930: LD_VAR 0 35
45934: PUSH
45935: LD_VAR 0 36
45939: PUSH
45940: LD_VAR 0 37
45944: PUSH
45945: LD_VAR 0 38
45949: PUSH
45950: LD_VAR 0 39
45954: PUSH
45955: LD_VAR 0 40
45959: PUSH
45960: EMPTY
45961: LIST
45962: LIST
45963: LIST
45964: LIST
45965: LIST
45966: LIST
45967: PUSH
45968: LD_VAR 0 4
45972: PUSH
45973: LD_INT 1
45975: PLUS
45976: ARRAY
45977: ST_TO_ADDR
45978: GO 46345
45980: LD_INT 6
45982: DOUBLE
45983: EQUAL
45984: IFTRUE 46036
45986: LD_INT 7
45988: DOUBLE
45989: EQUAL
45990: IFTRUE 46036
45992: LD_INT 8
45994: DOUBLE
45995: EQUAL
45996: IFTRUE 46036
45998: LD_INT 13
46000: DOUBLE
46001: EQUAL
46002: IFTRUE 46036
46004: LD_INT 12
46006: DOUBLE
46007: EQUAL
46008: IFTRUE 46036
46010: LD_INT 15
46012: DOUBLE
46013: EQUAL
46014: IFTRUE 46036
46016: LD_INT 11
46018: DOUBLE
46019: EQUAL
46020: IFTRUE 46036
46022: LD_INT 14
46024: DOUBLE
46025: EQUAL
46026: IFTRUE 46036
46028: LD_INT 10
46030: DOUBLE
46031: EQUAL
46032: IFTRUE 46036
46034: GO 46092
46036: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
46037: LD_ADDR_VAR 0 9
46041: PUSH
46042: LD_VAR 0 41
46046: PUSH
46047: LD_VAR 0 42
46051: PUSH
46052: LD_VAR 0 43
46056: PUSH
46057: LD_VAR 0 44
46061: PUSH
46062: LD_VAR 0 45
46066: PUSH
46067: LD_VAR 0 46
46071: PUSH
46072: EMPTY
46073: LIST
46074: LIST
46075: LIST
46076: LIST
46077: LIST
46078: LIST
46079: PUSH
46080: LD_VAR 0 4
46084: PUSH
46085: LD_INT 1
46087: PLUS
46088: ARRAY
46089: ST_TO_ADDR
46090: GO 46345
46092: LD_INT 36
46094: DOUBLE
46095: EQUAL
46096: IFTRUE 46100
46098: GO 46156
46100: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
46101: LD_ADDR_VAR 0 9
46105: PUSH
46106: LD_VAR 0 47
46110: PUSH
46111: LD_VAR 0 48
46115: PUSH
46116: LD_VAR 0 49
46120: PUSH
46121: LD_VAR 0 50
46125: PUSH
46126: LD_VAR 0 51
46130: PUSH
46131: LD_VAR 0 52
46135: PUSH
46136: EMPTY
46137: LIST
46138: LIST
46139: LIST
46140: LIST
46141: LIST
46142: LIST
46143: PUSH
46144: LD_VAR 0 4
46148: PUSH
46149: LD_INT 1
46151: PLUS
46152: ARRAY
46153: ST_TO_ADDR
46154: GO 46345
46156: LD_INT 4
46158: DOUBLE
46159: EQUAL
46160: IFTRUE 46182
46162: LD_INT 5
46164: DOUBLE
46165: EQUAL
46166: IFTRUE 46182
46168: LD_INT 34
46170: DOUBLE
46171: EQUAL
46172: IFTRUE 46182
46174: LD_INT 37
46176: DOUBLE
46177: EQUAL
46178: IFTRUE 46182
46180: GO 46238
46182: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
46183: LD_ADDR_VAR 0 9
46187: PUSH
46188: LD_VAR 0 53
46192: PUSH
46193: LD_VAR 0 54
46197: PUSH
46198: LD_VAR 0 55
46202: PUSH
46203: LD_VAR 0 56
46207: PUSH
46208: LD_VAR 0 57
46212: PUSH
46213: LD_VAR 0 58
46217: PUSH
46218: EMPTY
46219: LIST
46220: LIST
46221: LIST
46222: LIST
46223: LIST
46224: LIST
46225: PUSH
46226: LD_VAR 0 4
46230: PUSH
46231: LD_INT 1
46233: PLUS
46234: ARRAY
46235: ST_TO_ADDR
46236: GO 46345
46238: LD_INT 31
46240: DOUBLE
46241: EQUAL
46242: IFTRUE 46288
46244: LD_INT 32
46246: DOUBLE
46247: EQUAL
46248: IFTRUE 46288
46250: LD_INT 33
46252: DOUBLE
46253: EQUAL
46254: IFTRUE 46288
46256: LD_INT 27
46258: DOUBLE
46259: EQUAL
46260: IFTRUE 46288
46262: LD_INT 26
46264: DOUBLE
46265: EQUAL
46266: IFTRUE 46288
46268: LD_INT 28
46270: DOUBLE
46271: EQUAL
46272: IFTRUE 46288
46274: LD_INT 29
46276: DOUBLE
46277: EQUAL
46278: IFTRUE 46288
46280: LD_INT 30
46282: DOUBLE
46283: EQUAL
46284: IFTRUE 46288
46286: GO 46344
46288: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
46289: LD_ADDR_VAR 0 9
46293: PUSH
46294: LD_VAR 0 59
46298: PUSH
46299: LD_VAR 0 60
46303: PUSH
46304: LD_VAR 0 61
46308: PUSH
46309: LD_VAR 0 62
46313: PUSH
46314: LD_VAR 0 63
46318: PUSH
46319: LD_VAR 0 64
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: LIST
46328: LIST
46329: LIST
46330: LIST
46331: PUSH
46332: LD_VAR 0 4
46336: PUSH
46337: LD_INT 1
46339: PLUS
46340: ARRAY
46341: ST_TO_ADDR
46342: GO 46345
46344: POP
// temp_list2 = [ ] ;
46345: LD_ADDR_VAR 0 10
46349: PUSH
46350: EMPTY
46351: ST_TO_ADDR
// for i in temp_list do
46352: LD_ADDR_VAR 0 8
46356: PUSH
46357: LD_VAR 0 9
46361: PUSH
46362: FOR_IN
46363: IFFALSE 46415
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
46365: LD_ADDR_VAR 0 10
46369: PUSH
46370: LD_VAR 0 10
46374: PUSH
46375: LD_VAR 0 8
46379: PUSH
46380: LD_INT 1
46382: ARRAY
46383: PUSH
46384: LD_VAR 0 2
46388: PLUS
46389: PUSH
46390: LD_VAR 0 8
46394: PUSH
46395: LD_INT 2
46397: ARRAY
46398: PUSH
46399: LD_VAR 0 3
46403: PLUS
46404: PUSH
46405: EMPTY
46406: LIST
46407: LIST
46408: PUSH
46409: EMPTY
46410: LIST
46411: ADD
46412: ST_TO_ADDR
46413: GO 46362
46415: POP
46416: POP
// result = temp_list2 ;
46417: LD_ADDR_VAR 0 7
46421: PUSH
46422: LD_VAR 0 10
46426: ST_TO_ADDR
// end ;
46427: LD_VAR 0 7
46431: RET
// export function EnemyInRange ( unit , dist ) ; begin
46432: LD_INT 0
46434: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46435: LD_ADDR_VAR 0 3
46439: PUSH
46440: LD_VAR 0 1
46444: PPUSH
46445: CALL_OW 255
46449: PPUSH
46450: LD_VAR 0 1
46454: PPUSH
46455: CALL_OW 250
46459: PPUSH
46460: LD_VAR 0 1
46464: PPUSH
46465: CALL_OW 251
46469: PPUSH
46470: LD_VAR 0 2
46474: PPUSH
46475: CALL 20203 0 4
46479: PUSH
46480: LD_INT 4
46482: ARRAY
46483: ST_TO_ADDR
// end ;
46484: LD_VAR 0 3
46488: RET
// export function PlayerSeeMe ( unit ) ; begin
46489: LD_INT 0
46491: PPUSH
// result := See ( your_side , unit ) ;
46492: LD_ADDR_VAR 0 2
46496: PUSH
46497: LD_OWVAR 2
46501: PPUSH
46502: LD_VAR 0 1
46506: PPUSH
46507: CALL_OW 292
46511: ST_TO_ADDR
// end ;
46512: LD_VAR 0 2
46516: RET
// export function ReverseDir ( unit ) ; begin
46517: LD_INT 0
46519: PPUSH
// if not unit then
46520: LD_VAR 0 1
46524: NOT
46525: IFFALSE 46529
// exit ;
46527: GO 46552
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46529: LD_ADDR_VAR 0 2
46533: PUSH
46534: LD_VAR 0 1
46538: PPUSH
46539: CALL_OW 254
46543: PUSH
46544: LD_INT 3
46546: PLUS
46547: PUSH
46548: LD_INT 6
46550: MOD
46551: ST_TO_ADDR
// end ;
46552: LD_VAR 0 2
46556: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46557: LD_INT 0
46559: PPUSH
46560: PPUSH
46561: PPUSH
46562: PPUSH
46563: PPUSH
// if not hexes then
46564: LD_VAR 0 2
46568: NOT
46569: IFFALSE 46573
// exit ;
46571: GO 46721
// dist := 9999 ;
46573: LD_ADDR_VAR 0 5
46577: PUSH
46578: LD_INT 9999
46580: ST_TO_ADDR
// for i = 1 to hexes do
46581: LD_ADDR_VAR 0 4
46585: PUSH
46586: DOUBLE
46587: LD_INT 1
46589: DEC
46590: ST_TO_ADDR
46591: LD_VAR 0 2
46595: PUSH
46596: FOR_TO
46597: IFFALSE 46709
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46599: LD_VAR 0 1
46603: PPUSH
46604: LD_VAR 0 2
46608: PUSH
46609: LD_VAR 0 4
46613: ARRAY
46614: PUSH
46615: LD_INT 1
46617: ARRAY
46618: PPUSH
46619: LD_VAR 0 2
46623: PUSH
46624: LD_VAR 0 4
46628: ARRAY
46629: PUSH
46630: LD_INT 2
46632: ARRAY
46633: PPUSH
46634: CALL_OW 297
46638: PUSH
46639: LD_VAR 0 5
46643: LESS
46644: IFFALSE 46707
// begin hex := hexes [ i ] ;
46646: LD_ADDR_VAR 0 7
46650: PUSH
46651: LD_VAR 0 2
46655: PUSH
46656: LD_VAR 0 4
46660: ARRAY
46661: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46662: LD_ADDR_VAR 0 5
46666: PUSH
46667: LD_VAR 0 1
46671: PPUSH
46672: LD_VAR 0 2
46676: PUSH
46677: LD_VAR 0 4
46681: ARRAY
46682: PUSH
46683: LD_INT 1
46685: ARRAY
46686: PPUSH
46687: LD_VAR 0 2
46691: PUSH
46692: LD_VAR 0 4
46696: ARRAY
46697: PUSH
46698: LD_INT 2
46700: ARRAY
46701: PPUSH
46702: CALL_OW 297
46706: ST_TO_ADDR
// end ; end ;
46707: GO 46596
46709: POP
46710: POP
// result := hex ;
46711: LD_ADDR_VAR 0 3
46715: PUSH
46716: LD_VAR 0 7
46720: ST_TO_ADDR
// end ;
46721: LD_VAR 0 3
46725: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46726: LD_INT 0
46728: PPUSH
46729: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46730: LD_VAR 0 1
46734: NOT
46735: PUSH
46736: LD_VAR 0 1
46740: PUSH
46741: LD_INT 21
46743: PUSH
46744: LD_INT 2
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 23
46753: PUSH
46754: LD_INT 2
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: EMPTY
46762: LIST
46763: LIST
46764: PPUSH
46765: CALL_OW 69
46769: IN
46770: NOT
46771: OR
46772: IFFALSE 46776
// exit ;
46774: GO 46823
// for i = 1 to 3 do
46776: LD_ADDR_VAR 0 3
46780: PUSH
46781: DOUBLE
46782: LD_INT 1
46784: DEC
46785: ST_TO_ADDR
46786: LD_INT 3
46788: PUSH
46789: FOR_TO
46790: IFFALSE 46821
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46792: LD_VAR 0 1
46796: PPUSH
46797: CALL_OW 250
46801: PPUSH
46802: LD_VAR 0 1
46806: PPUSH
46807: CALL_OW 251
46811: PPUSH
46812: LD_INT 1
46814: PPUSH
46815: CALL_OW 453
46819: GO 46789
46821: POP
46822: POP
// end ;
46823: LD_VAR 0 2
46827: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46828: LD_INT 0
46830: PPUSH
46831: PPUSH
46832: PPUSH
46833: PPUSH
46834: PPUSH
46835: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46836: LD_VAR 0 1
46840: NOT
46841: PUSH
46842: LD_VAR 0 2
46846: NOT
46847: OR
46848: PUSH
46849: LD_VAR 0 1
46853: PPUSH
46854: CALL_OW 314
46858: OR
46859: IFFALSE 46863
// exit ;
46861: GO 47304
// x := GetX ( enemy_unit ) ;
46863: LD_ADDR_VAR 0 7
46867: PUSH
46868: LD_VAR 0 2
46872: PPUSH
46873: CALL_OW 250
46877: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46878: LD_ADDR_VAR 0 8
46882: PUSH
46883: LD_VAR 0 2
46887: PPUSH
46888: CALL_OW 251
46892: ST_TO_ADDR
// if not x or not y then
46893: LD_VAR 0 7
46897: NOT
46898: PUSH
46899: LD_VAR 0 8
46903: NOT
46904: OR
46905: IFFALSE 46909
// exit ;
46907: GO 47304
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46909: LD_ADDR_VAR 0 6
46913: PUSH
46914: LD_VAR 0 7
46918: PPUSH
46919: LD_INT 0
46921: PPUSH
46922: LD_INT 4
46924: PPUSH
46925: CALL_OW 272
46929: PUSH
46930: LD_VAR 0 8
46934: PPUSH
46935: LD_INT 0
46937: PPUSH
46938: LD_INT 4
46940: PPUSH
46941: CALL_OW 273
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_VAR 0 7
46954: PPUSH
46955: LD_INT 1
46957: PPUSH
46958: LD_INT 4
46960: PPUSH
46961: CALL_OW 272
46965: PUSH
46966: LD_VAR 0 8
46970: PPUSH
46971: LD_INT 1
46973: PPUSH
46974: LD_INT 4
46976: PPUSH
46977: CALL_OW 273
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_VAR 0 7
46990: PPUSH
46991: LD_INT 2
46993: PPUSH
46994: LD_INT 4
46996: PPUSH
46997: CALL_OW 272
47001: PUSH
47002: LD_VAR 0 8
47006: PPUSH
47007: LD_INT 2
47009: PPUSH
47010: LD_INT 4
47012: PPUSH
47013: CALL_OW 273
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_VAR 0 7
47026: PPUSH
47027: LD_INT 3
47029: PPUSH
47030: LD_INT 4
47032: PPUSH
47033: CALL_OW 272
47037: PUSH
47038: LD_VAR 0 8
47042: PPUSH
47043: LD_INT 3
47045: PPUSH
47046: LD_INT 4
47048: PPUSH
47049: CALL_OW 273
47053: PUSH
47054: EMPTY
47055: LIST
47056: LIST
47057: PUSH
47058: LD_VAR 0 7
47062: PPUSH
47063: LD_INT 4
47065: PPUSH
47066: LD_INT 4
47068: PPUSH
47069: CALL_OW 272
47073: PUSH
47074: LD_VAR 0 8
47078: PPUSH
47079: LD_INT 4
47081: PPUSH
47082: LD_INT 4
47084: PPUSH
47085: CALL_OW 273
47089: PUSH
47090: EMPTY
47091: LIST
47092: LIST
47093: PUSH
47094: LD_VAR 0 7
47098: PPUSH
47099: LD_INT 5
47101: PPUSH
47102: LD_INT 4
47104: PPUSH
47105: CALL_OW 272
47109: PUSH
47110: LD_VAR 0 8
47114: PPUSH
47115: LD_INT 5
47117: PPUSH
47118: LD_INT 4
47120: PPUSH
47121: CALL_OW 273
47125: PUSH
47126: EMPTY
47127: LIST
47128: LIST
47129: PUSH
47130: EMPTY
47131: LIST
47132: LIST
47133: LIST
47134: LIST
47135: LIST
47136: LIST
47137: ST_TO_ADDR
// for i = tmp downto 1 do
47138: LD_ADDR_VAR 0 4
47142: PUSH
47143: DOUBLE
47144: LD_VAR 0 6
47148: INC
47149: ST_TO_ADDR
47150: LD_INT 1
47152: PUSH
47153: FOR_DOWNTO
47154: IFFALSE 47255
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
47156: LD_VAR 0 6
47160: PUSH
47161: LD_VAR 0 4
47165: ARRAY
47166: PUSH
47167: LD_INT 1
47169: ARRAY
47170: PPUSH
47171: LD_VAR 0 6
47175: PUSH
47176: LD_VAR 0 4
47180: ARRAY
47181: PUSH
47182: LD_INT 2
47184: ARRAY
47185: PPUSH
47186: CALL_OW 488
47190: NOT
47191: PUSH
47192: LD_VAR 0 6
47196: PUSH
47197: LD_VAR 0 4
47201: ARRAY
47202: PUSH
47203: LD_INT 1
47205: ARRAY
47206: PPUSH
47207: LD_VAR 0 6
47211: PUSH
47212: LD_VAR 0 4
47216: ARRAY
47217: PUSH
47218: LD_INT 2
47220: ARRAY
47221: PPUSH
47222: CALL_OW 428
47226: PUSH
47227: LD_INT 0
47229: NONEQUAL
47230: OR
47231: IFFALSE 47253
// tmp := Delete ( tmp , i ) ;
47233: LD_ADDR_VAR 0 6
47237: PUSH
47238: LD_VAR 0 6
47242: PPUSH
47243: LD_VAR 0 4
47247: PPUSH
47248: CALL_OW 3
47252: ST_TO_ADDR
47253: GO 47153
47255: POP
47256: POP
// j := GetClosestHex ( unit , tmp ) ;
47257: LD_ADDR_VAR 0 5
47261: PUSH
47262: LD_VAR 0 1
47266: PPUSH
47267: LD_VAR 0 6
47271: PPUSH
47272: CALL 46557 0 2
47276: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
47277: LD_VAR 0 1
47281: PPUSH
47282: LD_VAR 0 5
47286: PUSH
47287: LD_INT 1
47289: ARRAY
47290: PPUSH
47291: LD_VAR 0 5
47295: PUSH
47296: LD_INT 2
47298: ARRAY
47299: PPUSH
47300: CALL_OW 111
// end ;
47304: LD_VAR 0 3
47308: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
47309: LD_INT 0
47311: PPUSH
47312: PPUSH
47313: PPUSH
// uc_side = 0 ;
47314: LD_ADDR_OWVAR 20
47318: PUSH
47319: LD_INT 0
47321: ST_TO_ADDR
// uc_nation = 0 ;
47322: LD_ADDR_OWVAR 21
47326: PUSH
47327: LD_INT 0
47329: ST_TO_ADDR
// InitHc_All ( ) ;
47330: CALL_OW 584
// InitVc ;
47334: CALL_OW 20
// if mastodonts then
47338: LD_VAR 0 6
47342: IFFALSE 47409
// for i = 1 to mastodonts do
47344: LD_ADDR_VAR 0 11
47348: PUSH
47349: DOUBLE
47350: LD_INT 1
47352: DEC
47353: ST_TO_ADDR
47354: LD_VAR 0 6
47358: PUSH
47359: FOR_TO
47360: IFFALSE 47407
// begin vc_chassis := 31 ;
47362: LD_ADDR_OWVAR 37
47366: PUSH
47367: LD_INT 31
47369: ST_TO_ADDR
// vc_control := control_rider ;
47370: LD_ADDR_OWVAR 38
47374: PUSH
47375: LD_INT 4
47377: ST_TO_ADDR
// animal := CreateVehicle ;
47378: LD_ADDR_VAR 0 12
47382: PUSH
47383: CALL_OW 45
47387: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47388: LD_VAR 0 12
47392: PPUSH
47393: LD_VAR 0 8
47397: PPUSH
47398: LD_INT 0
47400: PPUSH
47401: CALL 49597 0 3
// end ;
47405: GO 47359
47407: POP
47408: POP
// if horses then
47409: LD_VAR 0 5
47413: IFFALSE 47480
// for i = 1 to horses do
47415: LD_ADDR_VAR 0 11
47419: PUSH
47420: DOUBLE
47421: LD_INT 1
47423: DEC
47424: ST_TO_ADDR
47425: LD_VAR 0 5
47429: PUSH
47430: FOR_TO
47431: IFFALSE 47478
// begin hc_class := 21 ;
47433: LD_ADDR_OWVAR 28
47437: PUSH
47438: LD_INT 21
47440: ST_TO_ADDR
// hc_gallery :=  ;
47441: LD_ADDR_OWVAR 33
47445: PUSH
47446: LD_STRING 
47448: ST_TO_ADDR
// animal := CreateHuman ;
47449: LD_ADDR_VAR 0 12
47453: PUSH
47454: CALL_OW 44
47458: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47459: LD_VAR 0 12
47463: PPUSH
47464: LD_VAR 0 8
47468: PPUSH
47469: LD_INT 0
47471: PPUSH
47472: CALL 49597 0 3
// end ;
47476: GO 47430
47478: POP
47479: POP
// if birds then
47480: LD_VAR 0 1
47484: IFFALSE 47551
// for i = 1 to birds do
47486: LD_ADDR_VAR 0 11
47490: PUSH
47491: DOUBLE
47492: LD_INT 1
47494: DEC
47495: ST_TO_ADDR
47496: LD_VAR 0 1
47500: PUSH
47501: FOR_TO
47502: IFFALSE 47549
// begin hc_class = 18 ;
47504: LD_ADDR_OWVAR 28
47508: PUSH
47509: LD_INT 18
47511: ST_TO_ADDR
// hc_gallery =  ;
47512: LD_ADDR_OWVAR 33
47516: PUSH
47517: LD_STRING 
47519: ST_TO_ADDR
// animal := CreateHuman ;
47520: LD_ADDR_VAR 0 12
47524: PUSH
47525: CALL_OW 44
47529: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47530: LD_VAR 0 12
47534: PPUSH
47535: LD_VAR 0 8
47539: PPUSH
47540: LD_INT 0
47542: PPUSH
47543: CALL 49597 0 3
// end ;
47547: GO 47501
47549: POP
47550: POP
// if tigers then
47551: LD_VAR 0 2
47555: IFFALSE 47639
// for i = 1 to tigers do
47557: LD_ADDR_VAR 0 11
47561: PUSH
47562: DOUBLE
47563: LD_INT 1
47565: DEC
47566: ST_TO_ADDR
47567: LD_VAR 0 2
47571: PUSH
47572: FOR_TO
47573: IFFALSE 47637
// begin hc_class = class_tiger ;
47575: LD_ADDR_OWVAR 28
47579: PUSH
47580: LD_INT 14
47582: ST_TO_ADDR
// hc_gallery =  ;
47583: LD_ADDR_OWVAR 33
47587: PUSH
47588: LD_STRING 
47590: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47591: LD_ADDR_OWVAR 35
47595: PUSH
47596: LD_INT 7
47598: NEG
47599: PPUSH
47600: LD_INT 7
47602: PPUSH
47603: CALL_OW 12
47607: ST_TO_ADDR
// animal := CreateHuman ;
47608: LD_ADDR_VAR 0 12
47612: PUSH
47613: CALL_OW 44
47617: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47618: LD_VAR 0 12
47622: PPUSH
47623: LD_VAR 0 8
47627: PPUSH
47628: LD_INT 0
47630: PPUSH
47631: CALL 49597 0 3
// end ;
47635: GO 47572
47637: POP
47638: POP
// if apemans then
47639: LD_VAR 0 3
47643: IFFALSE 47766
// for i = 1 to apemans do
47645: LD_ADDR_VAR 0 11
47649: PUSH
47650: DOUBLE
47651: LD_INT 1
47653: DEC
47654: ST_TO_ADDR
47655: LD_VAR 0 3
47659: PUSH
47660: FOR_TO
47661: IFFALSE 47764
// begin hc_class = class_apeman ;
47663: LD_ADDR_OWVAR 28
47667: PUSH
47668: LD_INT 12
47670: ST_TO_ADDR
// hc_gallery =  ;
47671: LD_ADDR_OWVAR 33
47675: PUSH
47676: LD_STRING 
47678: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47679: LD_ADDR_OWVAR 35
47683: PUSH
47684: LD_INT 5
47686: NEG
47687: PPUSH
47688: LD_INT 5
47690: PPUSH
47691: CALL_OW 12
47695: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47696: LD_ADDR_OWVAR 31
47700: PUSH
47701: LD_INT 1
47703: PPUSH
47704: LD_INT 3
47706: PPUSH
47707: CALL_OW 12
47711: PUSH
47712: LD_INT 1
47714: PPUSH
47715: LD_INT 3
47717: PPUSH
47718: CALL_OW 12
47722: PUSH
47723: LD_INT 0
47725: PUSH
47726: LD_INT 0
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: LIST
47733: LIST
47734: ST_TO_ADDR
// animal := CreateHuman ;
47735: LD_ADDR_VAR 0 12
47739: PUSH
47740: CALL_OW 44
47744: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47745: LD_VAR 0 12
47749: PPUSH
47750: LD_VAR 0 8
47754: PPUSH
47755: LD_INT 0
47757: PPUSH
47758: CALL 49597 0 3
// end ;
47762: GO 47660
47764: POP
47765: POP
// if enchidnas then
47766: LD_VAR 0 4
47770: IFFALSE 47837
// for i = 1 to enchidnas do
47772: LD_ADDR_VAR 0 11
47776: PUSH
47777: DOUBLE
47778: LD_INT 1
47780: DEC
47781: ST_TO_ADDR
47782: LD_VAR 0 4
47786: PUSH
47787: FOR_TO
47788: IFFALSE 47835
// begin hc_class = 13 ;
47790: LD_ADDR_OWVAR 28
47794: PUSH
47795: LD_INT 13
47797: ST_TO_ADDR
// hc_gallery =  ;
47798: LD_ADDR_OWVAR 33
47802: PUSH
47803: LD_STRING 
47805: ST_TO_ADDR
// animal := CreateHuman ;
47806: LD_ADDR_VAR 0 12
47810: PUSH
47811: CALL_OW 44
47815: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47816: LD_VAR 0 12
47820: PPUSH
47821: LD_VAR 0 8
47825: PPUSH
47826: LD_INT 0
47828: PPUSH
47829: CALL 49597 0 3
// end ;
47833: GO 47787
47835: POP
47836: POP
// if fishes then
47837: LD_VAR 0 7
47841: IFFALSE 47908
// for i = 1 to fishes do
47843: LD_ADDR_VAR 0 11
47847: PUSH
47848: DOUBLE
47849: LD_INT 1
47851: DEC
47852: ST_TO_ADDR
47853: LD_VAR 0 7
47857: PUSH
47858: FOR_TO
47859: IFFALSE 47906
// begin hc_class = 20 ;
47861: LD_ADDR_OWVAR 28
47865: PUSH
47866: LD_INT 20
47868: ST_TO_ADDR
// hc_gallery =  ;
47869: LD_ADDR_OWVAR 33
47873: PUSH
47874: LD_STRING 
47876: ST_TO_ADDR
// animal := CreateHuman ;
47877: LD_ADDR_VAR 0 12
47881: PUSH
47882: CALL_OW 44
47886: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47887: LD_VAR 0 12
47891: PPUSH
47892: LD_VAR 0 9
47896: PPUSH
47897: LD_INT 0
47899: PPUSH
47900: CALL 49597 0 3
// end ;
47904: GO 47858
47906: POP
47907: POP
// end ;
47908: LD_VAR 0 10
47912: RET
// export function WantHeal ( sci , unit ) ; begin
47913: LD_INT 0
47915: PPUSH
// if GetTaskList ( sci ) > 0 then
47916: LD_VAR 0 1
47920: PPUSH
47921: CALL_OW 437
47925: PUSH
47926: LD_INT 0
47928: GREATER
47929: IFFALSE 47999
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47931: LD_VAR 0 1
47935: PPUSH
47936: CALL_OW 437
47940: PUSH
47941: LD_INT 1
47943: ARRAY
47944: PUSH
47945: LD_INT 1
47947: ARRAY
47948: PUSH
47949: LD_STRING l
47951: EQUAL
47952: PUSH
47953: LD_VAR 0 1
47957: PPUSH
47958: CALL_OW 437
47962: PUSH
47963: LD_INT 1
47965: ARRAY
47966: PUSH
47967: LD_INT 4
47969: ARRAY
47970: PUSH
47971: LD_VAR 0 2
47975: EQUAL
47976: AND
47977: IFFALSE 47989
// result := true else
47979: LD_ADDR_VAR 0 3
47983: PUSH
47984: LD_INT 1
47986: ST_TO_ADDR
47987: GO 47997
// result := false ;
47989: LD_ADDR_VAR 0 3
47993: PUSH
47994: LD_INT 0
47996: ST_TO_ADDR
// end else
47997: GO 48007
// result := false ;
47999: LD_ADDR_VAR 0 3
48003: PUSH
48004: LD_INT 0
48006: ST_TO_ADDR
// end ;
48007: LD_VAR 0 3
48011: RET
// export function HealTarget ( sci ) ; begin
48012: LD_INT 0
48014: PPUSH
// if not sci then
48015: LD_VAR 0 1
48019: NOT
48020: IFFALSE 48024
// exit ;
48022: GO 48089
// result := 0 ;
48024: LD_ADDR_VAR 0 2
48028: PUSH
48029: LD_INT 0
48031: ST_TO_ADDR
// if GetTaskList ( sci ) then
48032: LD_VAR 0 1
48036: PPUSH
48037: CALL_OW 437
48041: IFFALSE 48089
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
48043: LD_VAR 0 1
48047: PPUSH
48048: CALL_OW 437
48052: PUSH
48053: LD_INT 1
48055: ARRAY
48056: PUSH
48057: LD_INT 1
48059: ARRAY
48060: PUSH
48061: LD_STRING l
48063: EQUAL
48064: IFFALSE 48089
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
48066: LD_ADDR_VAR 0 2
48070: PUSH
48071: LD_VAR 0 1
48075: PPUSH
48076: CALL_OW 437
48080: PUSH
48081: LD_INT 1
48083: ARRAY
48084: PUSH
48085: LD_INT 4
48087: ARRAY
48088: ST_TO_ADDR
// end ;
48089: LD_VAR 0 2
48093: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
48094: LD_INT 0
48096: PPUSH
48097: PPUSH
48098: PPUSH
48099: PPUSH
// if not base_units then
48100: LD_VAR 0 1
48104: NOT
48105: IFFALSE 48109
// exit ;
48107: GO 48196
// result := false ;
48109: LD_ADDR_VAR 0 2
48113: PUSH
48114: LD_INT 0
48116: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
48117: LD_ADDR_VAR 0 5
48121: PUSH
48122: LD_VAR 0 1
48126: PPUSH
48127: LD_INT 21
48129: PUSH
48130: LD_INT 3
48132: PUSH
48133: EMPTY
48134: LIST
48135: LIST
48136: PPUSH
48137: CALL_OW 72
48141: ST_TO_ADDR
// if not tmp then
48142: LD_VAR 0 5
48146: NOT
48147: IFFALSE 48151
// exit ;
48149: GO 48196
// for i in tmp do
48151: LD_ADDR_VAR 0 3
48155: PUSH
48156: LD_VAR 0 5
48160: PUSH
48161: FOR_IN
48162: IFFALSE 48194
// begin result := EnemyInRange ( i , 22 ) ;
48164: LD_ADDR_VAR 0 2
48168: PUSH
48169: LD_VAR 0 3
48173: PPUSH
48174: LD_INT 22
48176: PPUSH
48177: CALL 46432 0 2
48181: ST_TO_ADDR
// if result then
48182: LD_VAR 0 2
48186: IFFALSE 48192
// exit ;
48188: POP
48189: POP
48190: GO 48196
// end ;
48192: GO 48161
48194: POP
48195: POP
// end ;
48196: LD_VAR 0 2
48200: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
48201: LD_INT 0
48203: PPUSH
48204: PPUSH
// if not units then
48205: LD_VAR 0 1
48209: NOT
48210: IFFALSE 48214
// exit ;
48212: GO 48284
// result := [ ] ;
48214: LD_ADDR_VAR 0 3
48218: PUSH
48219: EMPTY
48220: ST_TO_ADDR
// for i in units do
48221: LD_ADDR_VAR 0 4
48225: PUSH
48226: LD_VAR 0 1
48230: PUSH
48231: FOR_IN
48232: IFFALSE 48282
// if GetTag ( i ) = tag then
48234: LD_VAR 0 4
48238: PPUSH
48239: CALL_OW 110
48243: PUSH
48244: LD_VAR 0 2
48248: EQUAL
48249: IFFALSE 48280
// result := Insert ( result , result + 1 , i ) ;
48251: LD_ADDR_VAR 0 3
48255: PUSH
48256: LD_VAR 0 3
48260: PPUSH
48261: LD_VAR 0 3
48265: PUSH
48266: LD_INT 1
48268: PLUS
48269: PPUSH
48270: LD_VAR 0 4
48274: PPUSH
48275: CALL_OW 2
48279: ST_TO_ADDR
48280: GO 48231
48282: POP
48283: POP
// end ;
48284: LD_VAR 0 3
48288: RET
// export function IsDriver ( un ) ; begin
48289: LD_INT 0
48291: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
48292: LD_ADDR_VAR 0 2
48296: PUSH
48297: LD_VAR 0 1
48301: PUSH
48302: LD_INT 55
48304: PUSH
48305: EMPTY
48306: LIST
48307: PPUSH
48308: CALL_OW 69
48312: IN
48313: ST_TO_ADDR
// end ;
48314: LD_VAR 0 2
48318: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
48319: LD_INT 0
48321: PPUSH
48322: PPUSH
// list := [ ] ;
48323: LD_ADDR_VAR 0 5
48327: PUSH
48328: EMPTY
48329: ST_TO_ADDR
// case d of 0 :
48330: LD_VAR 0 3
48334: PUSH
48335: LD_INT 0
48337: DOUBLE
48338: EQUAL
48339: IFTRUE 48343
48341: GO 48476
48343: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
48344: LD_ADDR_VAR 0 5
48348: PUSH
48349: LD_VAR 0 1
48353: PUSH
48354: LD_INT 4
48356: MINUS
48357: PUSH
48358: LD_VAR 0 2
48362: PUSH
48363: LD_INT 4
48365: MINUS
48366: PUSH
48367: LD_INT 2
48369: PUSH
48370: EMPTY
48371: LIST
48372: LIST
48373: LIST
48374: PUSH
48375: LD_VAR 0 1
48379: PUSH
48380: LD_INT 3
48382: MINUS
48383: PUSH
48384: LD_VAR 0 2
48388: PUSH
48389: LD_INT 1
48391: PUSH
48392: EMPTY
48393: LIST
48394: LIST
48395: LIST
48396: PUSH
48397: LD_VAR 0 1
48401: PUSH
48402: LD_INT 4
48404: PLUS
48405: PUSH
48406: LD_VAR 0 2
48410: PUSH
48411: LD_INT 4
48413: PUSH
48414: EMPTY
48415: LIST
48416: LIST
48417: LIST
48418: PUSH
48419: LD_VAR 0 1
48423: PUSH
48424: LD_INT 3
48426: PLUS
48427: PUSH
48428: LD_VAR 0 2
48432: PUSH
48433: LD_INT 3
48435: PLUS
48436: PUSH
48437: LD_INT 5
48439: PUSH
48440: EMPTY
48441: LIST
48442: LIST
48443: LIST
48444: PUSH
48445: LD_VAR 0 1
48449: PUSH
48450: LD_VAR 0 2
48454: PUSH
48455: LD_INT 4
48457: PLUS
48458: PUSH
48459: LD_INT 0
48461: PUSH
48462: EMPTY
48463: LIST
48464: LIST
48465: LIST
48466: PUSH
48467: EMPTY
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: LIST
48473: ST_TO_ADDR
// end ; 1 :
48474: GO 49174
48476: LD_INT 1
48478: DOUBLE
48479: EQUAL
48480: IFTRUE 48484
48482: GO 48617
48484: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48485: LD_ADDR_VAR 0 5
48489: PUSH
48490: LD_VAR 0 1
48494: PUSH
48495: LD_VAR 0 2
48499: PUSH
48500: LD_INT 4
48502: MINUS
48503: PUSH
48504: LD_INT 3
48506: PUSH
48507: EMPTY
48508: LIST
48509: LIST
48510: LIST
48511: PUSH
48512: LD_VAR 0 1
48516: PUSH
48517: LD_INT 3
48519: MINUS
48520: PUSH
48521: LD_VAR 0 2
48525: PUSH
48526: LD_INT 3
48528: MINUS
48529: PUSH
48530: LD_INT 2
48532: PUSH
48533: EMPTY
48534: LIST
48535: LIST
48536: LIST
48537: PUSH
48538: LD_VAR 0 1
48542: PUSH
48543: LD_INT 4
48545: MINUS
48546: PUSH
48547: LD_VAR 0 2
48551: PUSH
48552: LD_INT 1
48554: PUSH
48555: EMPTY
48556: LIST
48557: LIST
48558: LIST
48559: PUSH
48560: LD_VAR 0 1
48564: PUSH
48565: LD_VAR 0 2
48569: PUSH
48570: LD_INT 3
48572: PLUS
48573: PUSH
48574: LD_INT 0
48576: PUSH
48577: EMPTY
48578: LIST
48579: LIST
48580: LIST
48581: PUSH
48582: LD_VAR 0 1
48586: PUSH
48587: LD_INT 4
48589: PLUS
48590: PUSH
48591: LD_VAR 0 2
48595: PUSH
48596: LD_INT 4
48598: PLUS
48599: PUSH
48600: LD_INT 5
48602: PUSH
48603: EMPTY
48604: LIST
48605: LIST
48606: LIST
48607: PUSH
48608: EMPTY
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: ST_TO_ADDR
// end ; 2 :
48615: GO 49174
48617: LD_INT 2
48619: DOUBLE
48620: EQUAL
48621: IFTRUE 48625
48623: GO 48754
48625: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48626: LD_ADDR_VAR 0 5
48630: PUSH
48631: LD_VAR 0 1
48635: PUSH
48636: LD_VAR 0 2
48640: PUSH
48641: LD_INT 3
48643: MINUS
48644: PUSH
48645: LD_INT 3
48647: PUSH
48648: EMPTY
48649: LIST
48650: LIST
48651: LIST
48652: PUSH
48653: LD_VAR 0 1
48657: PUSH
48658: LD_INT 4
48660: PLUS
48661: PUSH
48662: LD_VAR 0 2
48666: PUSH
48667: LD_INT 4
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: LIST
48674: PUSH
48675: LD_VAR 0 1
48679: PUSH
48680: LD_VAR 0 2
48684: PUSH
48685: LD_INT 4
48687: PLUS
48688: PUSH
48689: LD_INT 0
48691: PUSH
48692: EMPTY
48693: LIST
48694: LIST
48695: LIST
48696: PUSH
48697: LD_VAR 0 1
48701: PUSH
48702: LD_INT 3
48704: MINUS
48705: PUSH
48706: LD_VAR 0 2
48710: PUSH
48711: LD_INT 1
48713: PUSH
48714: EMPTY
48715: LIST
48716: LIST
48717: LIST
48718: PUSH
48719: LD_VAR 0 1
48723: PUSH
48724: LD_INT 4
48726: MINUS
48727: PUSH
48728: LD_VAR 0 2
48732: PUSH
48733: LD_INT 4
48735: MINUS
48736: PUSH
48737: LD_INT 2
48739: PUSH
48740: EMPTY
48741: LIST
48742: LIST
48743: LIST
48744: PUSH
48745: EMPTY
48746: LIST
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: ST_TO_ADDR
// end ; 3 :
48752: GO 49174
48754: LD_INT 3
48756: DOUBLE
48757: EQUAL
48758: IFTRUE 48762
48760: GO 48895
48762: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48763: LD_ADDR_VAR 0 5
48767: PUSH
48768: LD_VAR 0 1
48772: PUSH
48773: LD_INT 3
48775: PLUS
48776: PUSH
48777: LD_VAR 0 2
48781: PUSH
48782: LD_INT 4
48784: PUSH
48785: EMPTY
48786: LIST
48787: LIST
48788: LIST
48789: PUSH
48790: LD_VAR 0 1
48794: PUSH
48795: LD_INT 4
48797: PLUS
48798: PUSH
48799: LD_VAR 0 2
48803: PUSH
48804: LD_INT 4
48806: PLUS
48807: PUSH
48808: LD_INT 5
48810: PUSH
48811: EMPTY
48812: LIST
48813: LIST
48814: LIST
48815: PUSH
48816: LD_VAR 0 1
48820: PUSH
48821: LD_INT 4
48823: MINUS
48824: PUSH
48825: LD_VAR 0 2
48829: PUSH
48830: LD_INT 1
48832: PUSH
48833: EMPTY
48834: LIST
48835: LIST
48836: LIST
48837: PUSH
48838: LD_VAR 0 1
48842: PUSH
48843: LD_VAR 0 2
48847: PUSH
48848: LD_INT 4
48850: MINUS
48851: PUSH
48852: LD_INT 3
48854: PUSH
48855: EMPTY
48856: LIST
48857: LIST
48858: LIST
48859: PUSH
48860: LD_VAR 0 1
48864: PUSH
48865: LD_INT 3
48867: MINUS
48868: PUSH
48869: LD_VAR 0 2
48873: PUSH
48874: LD_INT 3
48876: MINUS
48877: PUSH
48878: LD_INT 2
48880: PUSH
48881: EMPTY
48882: LIST
48883: LIST
48884: LIST
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: LIST
48890: LIST
48891: LIST
48892: ST_TO_ADDR
// end ; 4 :
48893: GO 49174
48895: LD_INT 4
48897: DOUBLE
48898: EQUAL
48899: IFTRUE 48903
48901: GO 49036
48903: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48904: LD_ADDR_VAR 0 5
48908: PUSH
48909: LD_VAR 0 1
48913: PUSH
48914: LD_VAR 0 2
48918: PUSH
48919: LD_INT 4
48921: PLUS
48922: PUSH
48923: LD_INT 0
48925: PUSH
48926: EMPTY
48927: LIST
48928: LIST
48929: LIST
48930: PUSH
48931: LD_VAR 0 1
48935: PUSH
48936: LD_INT 3
48938: PLUS
48939: PUSH
48940: LD_VAR 0 2
48944: PUSH
48945: LD_INT 3
48947: PLUS
48948: PUSH
48949: LD_INT 5
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: LIST
48956: PUSH
48957: LD_VAR 0 1
48961: PUSH
48962: LD_INT 4
48964: PLUS
48965: PUSH
48966: LD_VAR 0 2
48970: PUSH
48971: LD_INT 4
48973: PUSH
48974: EMPTY
48975: LIST
48976: LIST
48977: LIST
48978: PUSH
48979: LD_VAR 0 1
48983: PUSH
48984: LD_VAR 0 2
48988: PUSH
48989: LD_INT 3
48991: MINUS
48992: PUSH
48993: LD_INT 3
48995: PUSH
48996: EMPTY
48997: LIST
48998: LIST
48999: LIST
49000: PUSH
49001: LD_VAR 0 1
49005: PUSH
49006: LD_INT 4
49008: MINUS
49009: PUSH
49010: LD_VAR 0 2
49014: PUSH
49015: LD_INT 4
49017: MINUS
49018: PUSH
49019: LD_INT 2
49021: PUSH
49022: EMPTY
49023: LIST
49024: LIST
49025: LIST
49026: PUSH
49027: EMPTY
49028: LIST
49029: LIST
49030: LIST
49031: LIST
49032: LIST
49033: ST_TO_ADDR
// end ; 5 :
49034: GO 49174
49036: LD_INT 5
49038: DOUBLE
49039: EQUAL
49040: IFTRUE 49044
49042: GO 49173
49044: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
49045: LD_ADDR_VAR 0 5
49049: PUSH
49050: LD_VAR 0 1
49054: PUSH
49055: LD_INT 4
49057: MINUS
49058: PUSH
49059: LD_VAR 0 2
49063: PUSH
49064: LD_INT 1
49066: PUSH
49067: EMPTY
49068: LIST
49069: LIST
49070: LIST
49071: PUSH
49072: LD_VAR 0 1
49076: PUSH
49077: LD_VAR 0 2
49081: PUSH
49082: LD_INT 4
49084: MINUS
49085: PUSH
49086: LD_INT 3
49088: PUSH
49089: EMPTY
49090: LIST
49091: LIST
49092: LIST
49093: PUSH
49094: LD_VAR 0 1
49098: PUSH
49099: LD_INT 4
49101: PLUS
49102: PUSH
49103: LD_VAR 0 2
49107: PUSH
49108: LD_INT 4
49110: PLUS
49111: PUSH
49112: LD_INT 5
49114: PUSH
49115: EMPTY
49116: LIST
49117: LIST
49118: LIST
49119: PUSH
49120: LD_VAR 0 1
49124: PUSH
49125: LD_INT 3
49127: PLUS
49128: PUSH
49129: LD_VAR 0 2
49133: PUSH
49134: LD_INT 4
49136: PUSH
49137: EMPTY
49138: LIST
49139: LIST
49140: LIST
49141: PUSH
49142: LD_VAR 0 1
49146: PUSH
49147: LD_VAR 0 2
49151: PUSH
49152: LD_INT 3
49154: PLUS
49155: PUSH
49156: LD_INT 0
49158: PUSH
49159: EMPTY
49160: LIST
49161: LIST
49162: LIST
49163: PUSH
49164: EMPTY
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: ST_TO_ADDR
// end ; end ;
49171: GO 49174
49173: POP
// result := list ;
49174: LD_ADDR_VAR 0 4
49178: PUSH
49179: LD_VAR 0 5
49183: ST_TO_ADDR
// end ;
49184: LD_VAR 0 4
49188: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
49189: LD_INT 0
49191: PPUSH
49192: PPUSH
49193: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
49194: LD_VAR 0 1
49198: NOT
49199: PUSH
49200: LD_VAR 0 2
49204: PUSH
49205: LD_INT 1
49207: PUSH
49208: LD_INT 2
49210: PUSH
49211: LD_INT 3
49213: PUSH
49214: LD_INT 4
49216: PUSH
49217: EMPTY
49218: LIST
49219: LIST
49220: LIST
49221: LIST
49222: IN
49223: NOT
49224: OR
49225: IFFALSE 49229
// exit ;
49227: GO 49321
// tmp := [ ] ;
49229: LD_ADDR_VAR 0 5
49233: PUSH
49234: EMPTY
49235: ST_TO_ADDR
// for i in units do
49236: LD_ADDR_VAR 0 4
49240: PUSH
49241: LD_VAR 0 1
49245: PUSH
49246: FOR_IN
49247: IFFALSE 49290
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
49249: LD_ADDR_VAR 0 5
49253: PUSH
49254: LD_VAR 0 5
49258: PPUSH
49259: LD_VAR 0 5
49263: PUSH
49264: LD_INT 1
49266: PLUS
49267: PPUSH
49268: LD_VAR 0 4
49272: PPUSH
49273: LD_VAR 0 2
49277: PPUSH
49278: CALL_OW 259
49282: PPUSH
49283: CALL_OW 2
49287: ST_TO_ADDR
49288: GO 49246
49290: POP
49291: POP
// if not tmp then
49292: LD_VAR 0 5
49296: NOT
49297: IFFALSE 49301
// exit ;
49299: GO 49321
// result := SortListByListDesc ( units , tmp ) ;
49301: LD_ADDR_VAR 0 3
49305: PUSH
49306: LD_VAR 0 1
49310: PPUSH
49311: LD_VAR 0 5
49315: PPUSH
49316: CALL_OW 77
49320: ST_TO_ADDR
// end ;
49321: LD_VAR 0 3
49325: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
49326: LD_INT 0
49328: PPUSH
49329: PPUSH
49330: PPUSH
// result := false ;
49331: LD_ADDR_VAR 0 3
49335: PUSH
49336: LD_INT 0
49338: ST_TO_ADDR
// x := GetX ( building ) ;
49339: LD_ADDR_VAR 0 4
49343: PUSH
49344: LD_VAR 0 2
49348: PPUSH
49349: CALL_OW 250
49353: ST_TO_ADDR
// y := GetY ( building ) ;
49354: LD_ADDR_VAR 0 5
49358: PUSH
49359: LD_VAR 0 2
49363: PPUSH
49364: CALL_OW 251
49368: ST_TO_ADDR
// if not building or not x or not y then
49369: LD_VAR 0 2
49373: NOT
49374: PUSH
49375: LD_VAR 0 4
49379: NOT
49380: OR
49381: PUSH
49382: LD_VAR 0 5
49386: NOT
49387: OR
49388: IFFALSE 49392
// exit ;
49390: GO 49484
// if GetTaskList ( unit ) then
49392: LD_VAR 0 1
49396: PPUSH
49397: CALL_OW 437
49401: IFFALSE 49484
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49403: LD_STRING e
49405: PUSH
49406: LD_VAR 0 1
49410: PPUSH
49411: CALL_OW 437
49415: PUSH
49416: LD_INT 1
49418: ARRAY
49419: PUSH
49420: LD_INT 1
49422: ARRAY
49423: EQUAL
49424: PUSH
49425: LD_VAR 0 4
49429: PUSH
49430: LD_VAR 0 1
49434: PPUSH
49435: CALL_OW 437
49439: PUSH
49440: LD_INT 1
49442: ARRAY
49443: PUSH
49444: LD_INT 2
49446: ARRAY
49447: EQUAL
49448: AND
49449: PUSH
49450: LD_VAR 0 5
49454: PUSH
49455: LD_VAR 0 1
49459: PPUSH
49460: CALL_OW 437
49464: PUSH
49465: LD_INT 1
49467: ARRAY
49468: PUSH
49469: LD_INT 3
49471: ARRAY
49472: EQUAL
49473: AND
49474: IFFALSE 49484
// result := true end ;
49476: LD_ADDR_VAR 0 3
49480: PUSH
49481: LD_INT 1
49483: ST_TO_ADDR
// end ;
49484: LD_VAR 0 3
49488: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49489: LD_INT 0
49491: PPUSH
// result := false ;
49492: LD_ADDR_VAR 0 4
49496: PUSH
49497: LD_INT 0
49499: ST_TO_ADDR
// if GetTaskList ( unit ) then
49500: LD_VAR 0 1
49504: PPUSH
49505: CALL_OW 437
49509: IFFALSE 49592
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49511: LD_STRING M
49513: PUSH
49514: LD_VAR 0 1
49518: PPUSH
49519: CALL_OW 437
49523: PUSH
49524: LD_INT 1
49526: ARRAY
49527: PUSH
49528: LD_INT 1
49530: ARRAY
49531: EQUAL
49532: PUSH
49533: LD_VAR 0 2
49537: PUSH
49538: LD_VAR 0 1
49542: PPUSH
49543: CALL_OW 437
49547: PUSH
49548: LD_INT 1
49550: ARRAY
49551: PUSH
49552: LD_INT 2
49554: ARRAY
49555: EQUAL
49556: AND
49557: PUSH
49558: LD_VAR 0 3
49562: PUSH
49563: LD_VAR 0 1
49567: PPUSH
49568: CALL_OW 437
49572: PUSH
49573: LD_INT 1
49575: ARRAY
49576: PUSH
49577: LD_INT 3
49579: ARRAY
49580: EQUAL
49581: AND
49582: IFFALSE 49592
// result := true ;
49584: LD_ADDR_VAR 0 4
49588: PUSH
49589: LD_INT 1
49591: ST_TO_ADDR
// end ; end ;
49592: LD_VAR 0 4
49596: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49597: LD_INT 0
49599: PPUSH
49600: PPUSH
49601: PPUSH
49602: PPUSH
// if not unit or not area then
49603: LD_VAR 0 1
49607: NOT
49608: PUSH
49609: LD_VAR 0 2
49613: NOT
49614: OR
49615: IFFALSE 49619
// exit ;
49617: GO 49783
// tmp := AreaToList ( area , i ) ;
49619: LD_ADDR_VAR 0 6
49623: PUSH
49624: LD_VAR 0 2
49628: PPUSH
49629: LD_VAR 0 5
49633: PPUSH
49634: CALL_OW 517
49638: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49639: LD_ADDR_VAR 0 5
49643: PUSH
49644: DOUBLE
49645: LD_INT 1
49647: DEC
49648: ST_TO_ADDR
49649: LD_VAR 0 6
49653: PUSH
49654: LD_INT 1
49656: ARRAY
49657: PUSH
49658: FOR_TO
49659: IFFALSE 49781
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49661: LD_ADDR_VAR 0 7
49665: PUSH
49666: LD_VAR 0 6
49670: PUSH
49671: LD_INT 1
49673: ARRAY
49674: PUSH
49675: LD_VAR 0 5
49679: ARRAY
49680: PUSH
49681: LD_VAR 0 6
49685: PUSH
49686: LD_INT 2
49688: ARRAY
49689: PUSH
49690: LD_VAR 0 5
49694: ARRAY
49695: PUSH
49696: EMPTY
49697: LIST
49698: LIST
49699: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49700: LD_VAR 0 7
49704: PUSH
49705: LD_INT 1
49707: ARRAY
49708: PPUSH
49709: LD_VAR 0 7
49713: PUSH
49714: LD_INT 2
49716: ARRAY
49717: PPUSH
49718: CALL_OW 428
49722: PUSH
49723: LD_INT 0
49725: EQUAL
49726: IFFALSE 49779
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49728: LD_VAR 0 1
49732: PPUSH
49733: LD_VAR 0 7
49737: PUSH
49738: LD_INT 1
49740: ARRAY
49741: PPUSH
49742: LD_VAR 0 7
49746: PUSH
49747: LD_INT 2
49749: ARRAY
49750: PPUSH
49751: LD_VAR 0 3
49755: PPUSH
49756: CALL_OW 48
// result := IsPlaced ( unit ) ;
49760: LD_ADDR_VAR 0 4
49764: PUSH
49765: LD_VAR 0 1
49769: PPUSH
49770: CALL_OW 305
49774: ST_TO_ADDR
// exit ;
49775: POP
49776: POP
49777: GO 49783
// end ; end ;
49779: GO 49658
49781: POP
49782: POP
// end ;
49783: LD_VAR 0 4
49787: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49788: LD_INT 0
49790: PPUSH
49791: PPUSH
49792: PPUSH
// if not side or side > 8 then
49793: LD_VAR 0 1
49797: NOT
49798: PUSH
49799: LD_VAR 0 1
49803: PUSH
49804: LD_INT 8
49806: GREATER
49807: OR
49808: IFFALSE 49812
// exit ;
49810: GO 49999
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49812: LD_ADDR_VAR 0 4
49816: PUSH
49817: LD_INT 22
49819: PUSH
49820: LD_VAR 0 1
49824: PUSH
49825: EMPTY
49826: LIST
49827: LIST
49828: PUSH
49829: LD_INT 21
49831: PUSH
49832: LD_INT 3
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: PUSH
49839: EMPTY
49840: LIST
49841: LIST
49842: PPUSH
49843: CALL_OW 69
49847: ST_TO_ADDR
// if not tmp then
49848: LD_VAR 0 4
49852: NOT
49853: IFFALSE 49857
// exit ;
49855: GO 49999
// enable_addtolog := true ;
49857: LD_ADDR_OWVAR 81
49861: PUSH
49862: LD_INT 1
49864: ST_TO_ADDR
// AddToLog ( [ ) ;
49865: LD_STRING [
49867: PPUSH
49868: CALL_OW 561
// for i in tmp do
49872: LD_ADDR_VAR 0 3
49876: PUSH
49877: LD_VAR 0 4
49881: PUSH
49882: FOR_IN
49883: IFFALSE 49990
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49885: LD_STRING [
49887: PUSH
49888: LD_VAR 0 3
49892: PPUSH
49893: CALL_OW 266
49897: STR
49898: PUSH
49899: LD_STRING , 
49901: STR
49902: PUSH
49903: LD_VAR 0 3
49907: PPUSH
49908: CALL_OW 250
49912: STR
49913: PUSH
49914: LD_STRING , 
49916: STR
49917: PUSH
49918: LD_VAR 0 3
49922: PPUSH
49923: CALL_OW 251
49927: STR
49928: PUSH
49929: LD_STRING , 
49931: STR
49932: PUSH
49933: LD_VAR 0 3
49937: PPUSH
49938: CALL_OW 254
49942: STR
49943: PUSH
49944: LD_STRING , 
49946: STR
49947: PUSH
49948: LD_VAR 0 3
49952: PPUSH
49953: LD_INT 1
49955: PPUSH
49956: CALL_OW 268
49960: STR
49961: PUSH
49962: LD_STRING , 
49964: STR
49965: PUSH
49966: LD_VAR 0 3
49970: PPUSH
49971: LD_INT 2
49973: PPUSH
49974: CALL_OW 268
49978: STR
49979: PUSH
49980: LD_STRING ],
49982: STR
49983: PPUSH
49984: CALL_OW 561
// end ;
49988: GO 49882
49990: POP
49991: POP
// AddToLog ( ]; ) ;
49992: LD_STRING ];
49994: PPUSH
49995: CALL_OW 561
// end ;
49999: LD_VAR 0 2
50003: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
50004: LD_INT 0
50006: PPUSH
50007: PPUSH
50008: PPUSH
50009: PPUSH
50010: PPUSH
// if not area or not rate or not max then
50011: LD_VAR 0 1
50015: NOT
50016: PUSH
50017: LD_VAR 0 2
50021: NOT
50022: OR
50023: PUSH
50024: LD_VAR 0 4
50028: NOT
50029: OR
50030: IFFALSE 50034
// exit ;
50032: GO 50226
// while 1 do
50034: LD_INT 1
50036: IFFALSE 50226
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
50038: LD_ADDR_VAR 0 9
50042: PUSH
50043: LD_VAR 0 1
50047: PPUSH
50048: LD_INT 1
50050: PPUSH
50051: CALL_OW 287
50055: PUSH
50056: LD_INT 10
50058: MUL
50059: ST_TO_ADDR
// r := rate / 10 ;
50060: LD_ADDR_VAR 0 7
50064: PUSH
50065: LD_VAR 0 2
50069: PUSH
50070: LD_INT 10
50072: DIVREAL
50073: ST_TO_ADDR
// time := 1 1$00 ;
50074: LD_ADDR_VAR 0 8
50078: PUSH
50079: LD_INT 2100
50081: ST_TO_ADDR
// if amount < min then
50082: LD_VAR 0 9
50086: PUSH
50087: LD_VAR 0 3
50091: LESS
50092: IFFALSE 50110
// r := r * 2 else
50094: LD_ADDR_VAR 0 7
50098: PUSH
50099: LD_VAR 0 7
50103: PUSH
50104: LD_INT 2
50106: MUL
50107: ST_TO_ADDR
50108: GO 50136
// if amount > max then
50110: LD_VAR 0 9
50114: PUSH
50115: LD_VAR 0 4
50119: GREATER
50120: IFFALSE 50136
// r := r / 2 ;
50122: LD_ADDR_VAR 0 7
50126: PUSH
50127: LD_VAR 0 7
50131: PUSH
50132: LD_INT 2
50134: DIVREAL
50135: ST_TO_ADDR
// time := time / r ;
50136: LD_ADDR_VAR 0 8
50140: PUSH
50141: LD_VAR 0 8
50145: PUSH
50146: LD_VAR 0 7
50150: DIVREAL
50151: ST_TO_ADDR
// if time < 0 then
50152: LD_VAR 0 8
50156: PUSH
50157: LD_INT 0
50159: LESS
50160: IFFALSE 50177
// time := time * - 1 ;
50162: LD_ADDR_VAR 0 8
50166: PUSH
50167: LD_VAR 0 8
50171: PUSH
50172: LD_INT 1
50174: NEG
50175: MUL
50176: ST_TO_ADDR
// wait ( time ) ;
50177: LD_VAR 0 8
50181: PPUSH
50182: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
50186: LD_INT 35
50188: PPUSH
50189: LD_INT 875
50191: PPUSH
50192: CALL_OW 12
50196: PPUSH
50197: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
50201: LD_INT 1
50203: PPUSH
50204: LD_INT 5
50206: PPUSH
50207: CALL_OW 12
50211: PPUSH
50212: LD_VAR 0 1
50216: PPUSH
50217: LD_INT 1
50219: PPUSH
50220: CALL_OW 55
// end ;
50224: GO 50034
// end ;
50226: LD_VAR 0 5
50230: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
50231: LD_INT 0
50233: PPUSH
50234: PPUSH
50235: PPUSH
50236: PPUSH
50237: PPUSH
50238: PPUSH
50239: PPUSH
50240: PPUSH
// if not turrets or not factories then
50241: LD_VAR 0 1
50245: NOT
50246: PUSH
50247: LD_VAR 0 2
50251: NOT
50252: OR
50253: IFFALSE 50257
// exit ;
50255: GO 50564
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
50257: LD_ADDR_VAR 0 10
50261: PUSH
50262: LD_INT 5
50264: PUSH
50265: LD_INT 6
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PUSH
50272: LD_INT 2
50274: PUSH
50275: LD_INT 4
50277: PUSH
50278: EMPTY
50279: LIST
50280: LIST
50281: PUSH
50282: LD_INT 3
50284: PUSH
50285: LD_INT 5
50287: PUSH
50288: EMPTY
50289: LIST
50290: LIST
50291: PUSH
50292: EMPTY
50293: LIST
50294: LIST
50295: LIST
50296: PUSH
50297: LD_INT 24
50299: PUSH
50300: LD_INT 25
50302: PUSH
50303: EMPTY
50304: LIST
50305: LIST
50306: PUSH
50307: LD_INT 23
50309: PUSH
50310: LD_INT 27
50312: PUSH
50313: EMPTY
50314: LIST
50315: LIST
50316: PUSH
50317: EMPTY
50318: LIST
50319: LIST
50320: PUSH
50321: LD_INT 42
50323: PUSH
50324: LD_INT 43
50326: PUSH
50327: EMPTY
50328: LIST
50329: LIST
50330: PUSH
50331: LD_INT 44
50333: PUSH
50334: LD_INT 46
50336: PUSH
50337: EMPTY
50338: LIST
50339: LIST
50340: PUSH
50341: LD_INT 45
50343: PUSH
50344: LD_INT 47
50346: PUSH
50347: EMPTY
50348: LIST
50349: LIST
50350: PUSH
50351: EMPTY
50352: LIST
50353: LIST
50354: LIST
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: LIST
50360: ST_TO_ADDR
// result := [ ] ;
50361: LD_ADDR_VAR 0 3
50365: PUSH
50366: EMPTY
50367: ST_TO_ADDR
// for i in turrets do
50368: LD_ADDR_VAR 0 4
50372: PUSH
50373: LD_VAR 0 1
50377: PUSH
50378: FOR_IN
50379: IFFALSE 50562
// begin nat := GetNation ( i ) ;
50381: LD_ADDR_VAR 0 7
50385: PUSH
50386: LD_VAR 0 4
50390: PPUSH
50391: CALL_OW 248
50395: ST_TO_ADDR
// weapon := 0 ;
50396: LD_ADDR_VAR 0 8
50400: PUSH
50401: LD_INT 0
50403: ST_TO_ADDR
// if not nat then
50404: LD_VAR 0 7
50408: NOT
50409: IFFALSE 50413
// continue ;
50411: GO 50378
// for j in list [ nat ] do
50413: LD_ADDR_VAR 0 5
50417: PUSH
50418: LD_VAR 0 10
50422: PUSH
50423: LD_VAR 0 7
50427: ARRAY
50428: PUSH
50429: FOR_IN
50430: IFFALSE 50471
// if GetBWeapon ( i ) = j [ 1 ] then
50432: LD_VAR 0 4
50436: PPUSH
50437: CALL_OW 269
50441: PUSH
50442: LD_VAR 0 5
50446: PUSH
50447: LD_INT 1
50449: ARRAY
50450: EQUAL
50451: IFFALSE 50469
// begin weapon := j [ 2 ] ;
50453: LD_ADDR_VAR 0 8
50457: PUSH
50458: LD_VAR 0 5
50462: PUSH
50463: LD_INT 2
50465: ARRAY
50466: ST_TO_ADDR
// break ;
50467: GO 50471
// end ;
50469: GO 50429
50471: POP
50472: POP
// if not weapon then
50473: LD_VAR 0 8
50477: NOT
50478: IFFALSE 50482
// continue ;
50480: GO 50378
// for k in factories do
50482: LD_ADDR_VAR 0 6
50486: PUSH
50487: LD_VAR 0 2
50491: PUSH
50492: FOR_IN
50493: IFFALSE 50558
// begin weapons := AvailableWeaponList ( k ) ;
50495: LD_ADDR_VAR 0 9
50499: PUSH
50500: LD_VAR 0 6
50504: PPUSH
50505: CALL_OW 478
50509: ST_TO_ADDR
// if not weapons then
50510: LD_VAR 0 9
50514: NOT
50515: IFFALSE 50519
// continue ;
50517: GO 50492
// if weapon in weapons then
50519: LD_VAR 0 8
50523: PUSH
50524: LD_VAR 0 9
50528: IN
50529: IFFALSE 50556
// begin result := [ i , weapon ] ;
50531: LD_ADDR_VAR 0 3
50535: PUSH
50536: LD_VAR 0 4
50540: PUSH
50541: LD_VAR 0 8
50545: PUSH
50546: EMPTY
50547: LIST
50548: LIST
50549: ST_TO_ADDR
// exit ;
50550: POP
50551: POP
50552: POP
50553: POP
50554: GO 50564
// end ; end ;
50556: GO 50492
50558: POP
50559: POP
// end ;
50560: GO 50378
50562: POP
50563: POP
// end ;
50564: LD_VAR 0 3
50568: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50569: LD_INT 0
50571: PPUSH
// if not side or side > 8 then
50572: LD_VAR 0 3
50576: NOT
50577: PUSH
50578: LD_VAR 0 3
50582: PUSH
50583: LD_INT 8
50585: GREATER
50586: OR
50587: IFFALSE 50591
// exit ;
50589: GO 50650
// if not range then
50591: LD_VAR 0 4
50595: NOT
50596: IFFALSE 50607
// range := - 12 ;
50598: LD_ADDR_VAR 0 4
50602: PUSH
50603: LD_INT 12
50605: NEG
50606: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50607: LD_VAR 0 1
50611: PPUSH
50612: LD_VAR 0 2
50616: PPUSH
50617: LD_VAR 0 3
50621: PPUSH
50622: LD_VAR 0 4
50626: PPUSH
50627: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50631: LD_VAR 0 1
50635: PPUSH
50636: LD_VAR 0 2
50640: PPUSH
50641: LD_VAR 0 3
50645: PPUSH
50646: CALL_OW 331
// end ;
50650: LD_VAR 0 5
50654: RET
// export function Video ( mode ) ; begin
50655: LD_INT 0
50657: PPUSH
// ingame_video = mode ;
50658: LD_ADDR_OWVAR 52
50662: PUSH
50663: LD_VAR 0 1
50667: ST_TO_ADDR
// interface_hidden = mode ;
50668: LD_ADDR_OWVAR 54
50672: PUSH
50673: LD_VAR 0 1
50677: ST_TO_ADDR
// end ;
50678: LD_VAR 0 2
50682: RET
// export function Join ( array , element ) ; begin
50683: LD_INT 0
50685: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50686: LD_ADDR_VAR 0 3
50690: PUSH
50691: LD_VAR 0 1
50695: PPUSH
50696: LD_VAR 0 1
50700: PUSH
50701: LD_INT 1
50703: PLUS
50704: PPUSH
50705: LD_VAR 0 2
50709: PPUSH
50710: CALL_OW 1
50714: ST_TO_ADDR
// end ;
50715: LD_VAR 0 3
50719: RET
// export function JoinUnion ( array , element ) ; begin
50720: LD_INT 0
50722: PPUSH
// result := array union element ;
50723: LD_ADDR_VAR 0 3
50727: PUSH
50728: LD_VAR 0 1
50732: PUSH
50733: LD_VAR 0 2
50737: UNION
50738: ST_TO_ADDR
// end ;
50739: LD_VAR 0 3
50743: RET
// export function GetBehemoths ( side ) ; begin
50744: LD_INT 0
50746: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50747: LD_ADDR_VAR 0 2
50751: PUSH
50752: LD_INT 22
50754: PUSH
50755: LD_VAR 0 1
50759: PUSH
50760: EMPTY
50761: LIST
50762: LIST
50763: PUSH
50764: LD_INT 31
50766: PUSH
50767: LD_INT 25
50769: PUSH
50770: EMPTY
50771: LIST
50772: LIST
50773: PUSH
50774: EMPTY
50775: LIST
50776: LIST
50777: PPUSH
50778: CALL_OW 69
50782: ST_TO_ADDR
// end ;
50783: LD_VAR 0 2
50787: RET
// export function Shuffle ( array ) ; var i , index ; begin
50788: LD_INT 0
50790: PPUSH
50791: PPUSH
50792: PPUSH
// result := [ ] ;
50793: LD_ADDR_VAR 0 2
50797: PUSH
50798: EMPTY
50799: ST_TO_ADDR
// if not array then
50800: LD_VAR 0 1
50804: NOT
50805: IFFALSE 50809
// exit ;
50807: GO 50908
// Randomize ;
50809: CALL_OW 10
// for i = array downto 1 do
50813: LD_ADDR_VAR 0 3
50817: PUSH
50818: DOUBLE
50819: LD_VAR 0 1
50823: INC
50824: ST_TO_ADDR
50825: LD_INT 1
50827: PUSH
50828: FOR_DOWNTO
50829: IFFALSE 50906
// begin index := rand ( 1 , array ) ;
50831: LD_ADDR_VAR 0 4
50835: PUSH
50836: LD_INT 1
50838: PPUSH
50839: LD_VAR 0 1
50843: PPUSH
50844: CALL_OW 12
50848: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50849: LD_ADDR_VAR 0 2
50853: PUSH
50854: LD_VAR 0 2
50858: PPUSH
50859: LD_VAR 0 2
50863: PUSH
50864: LD_INT 1
50866: PLUS
50867: PPUSH
50868: LD_VAR 0 1
50872: PUSH
50873: LD_VAR 0 4
50877: ARRAY
50878: PPUSH
50879: CALL_OW 2
50883: ST_TO_ADDR
// array := Delete ( array , index ) ;
50884: LD_ADDR_VAR 0 1
50888: PUSH
50889: LD_VAR 0 1
50893: PPUSH
50894: LD_VAR 0 4
50898: PPUSH
50899: CALL_OW 3
50903: ST_TO_ADDR
// end ;
50904: GO 50828
50906: POP
50907: POP
// end ;
50908: LD_VAR 0 2
50912: RET
// export function GetBaseMaterials ( base ) ; begin
50913: LD_INT 0
50915: PPUSH
// result := [ 0 , 0 , 0 ] ;
50916: LD_ADDR_VAR 0 2
50920: PUSH
50921: LD_INT 0
50923: PUSH
50924: LD_INT 0
50926: PUSH
50927: LD_INT 0
50929: PUSH
50930: EMPTY
50931: LIST
50932: LIST
50933: LIST
50934: ST_TO_ADDR
// if not base then
50935: LD_VAR 0 1
50939: NOT
50940: IFFALSE 50944
// exit ;
50942: GO 50993
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50944: LD_ADDR_VAR 0 2
50948: PUSH
50949: LD_VAR 0 1
50953: PPUSH
50954: LD_INT 1
50956: PPUSH
50957: CALL_OW 275
50961: PUSH
50962: LD_VAR 0 1
50966: PPUSH
50967: LD_INT 2
50969: PPUSH
50970: CALL_OW 275
50974: PUSH
50975: LD_VAR 0 1
50979: PPUSH
50980: LD_INT 3
50982: PPUSH
50983: CALL_OW 275
50987: PUSH
50988: EMPTY
50989: LIST
50990: LIST
50991: LIST
50992: ST_TO_ADDR
// end ;
50993: LD_VAR 0 2
50997: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50998: LD_INT 0
51000: PPUSH
51001: PPUSH
// result := array ;
51002: LD_ADDR_VAR 0 3
51006: PUSH
51007: LD_VAR 0 1
51011: ST_TO_ADDR
// if size > 0 then
51012: LD_VAR 0 2
51016: PUSH
51017: LD_INT 0
51019: GREATER
51020: IFFALSE 51066
// for i := array downto size do
51022: LD_ADDR_VAR 0 4
51026: PUSH
51027: DOUBLE
51028: LD_VAR 0 1
51032: INC
51033: ST_TO_ADDR
51034: LD_VAR 0 2
51038: PUSH
51039: FOR_DOWNTO
51040: IFFALSE 51064
// result := Delete ( result , result ) ;
51042: LD_ADDR_VAR 0 3
51046: PUSH
51047: LD_VAR 0 3
51051: PPUSH
51052: LD_VAR 0 3
51056: PPUSH
51057: CALL_OW 3
51061: ST_TO_ADDR
51062: GO 51039
51064: POP
51065: POP
// end ;
51066: LD_VAR 0 3
51070: RET
// export function ComExit ( unit ) ; var tmp ; begin
51071: LD_INT 0
51073: PPUSH
51074: PPUSH
// if not IsInUnit ( unit ) then
51075: LD_VAR 0 1
51079: PPUSH
51080: CALL_OW 310
51084: NOT
51085: IFFALSE 51089
// exit ;
51087: GO 51149
// tmp := IsInUnit ( unit ) ;
51089: LD_ADDR_VAR 0 3
51093: PUSH
51094: LD_VAR 0 1
51098: PPUSH
51099: CALL_OW 310
51103: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
51104: LD_VAR 0 3
51108: PPUSH
51109: CALL_OW 247
51113: PUSH
51114: LD_INT 2
51116: EQUAL
51117: IFFALSE 51130
// ComExitVehicle ( unit ) else
51119: LD_VAR 0 1
51123: PPUSH
51124: CALL_OW 121
51128: GO 51139
// ComExitBuilding ( unit ) ;
51130: LD_VAR 0 1
51134: PPUSH
51135: CALL_OW 122
// result := tmp ;
51139: LD_ADDR_VAR 0 2
51143: PUSH
51144: LD_VAR 0 3
51148: ST_TO_ADDR
// end ;
51149: LD_VAR 0 2
51153: RET
// export function ComExitAll ( units ) ; var i ; begin
51154: LD_INT 0
51156: PPUSH
51157: PPUSH
// if not units then
51158: LD_VAR 0 1
51162: NOT
51163: IFFALSE 51167
// exit ;
51165: GO 51193
// for i in units do
51167: LD_ADDR_VAR 0 3
51171: PUSH
51172: LD_VAR 0 1
51176: PUSH
51177: FOR_IN
51178: IFFALSE 51191
// ComExit ( i ) ;
51180: LD_VAR 0 3
51184: PPUSH
51185: CALL 51071 0 1
51189: GO 51177
51191: POP
51192: POP
// end ;
51193: LD_VAR 0 2
51197: RET
// export function ResetHc ; begin
51198: LD_INT 0
51200: PPUSH
// InitHc ;
51201: CALL_OW 19
// hc_importance := 0 ;
51205: LD_ADDR_OWVAR 32
51209: PUSH
51210: LD_INT 0
51212: ST_TO_ADDR
// end ;
51213: LD_VAR 0 1
51217: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
51218: LD_INT 0
51220: PPUSH
51221: PPUSH
51222: PPUSH
// _x := ( x1 + x2 ) div 2 ;
51223: LD_ADDR_VAR 0 6
51227: PUSH
51228: LD_VAR 0 1
51232: PUSH
51233: LD_VAR 0 3
51237: PLUS
51238: PUSH
51239: LD_INT 2
51241: DIV
51242: ST_TO_ADDR
// if _x < 0 then
51243: LD_VAR 0 6
51247: PUSH
51248: LD_INT 0
51250: LESS
51251: IFFALSE 51268
// _x := _x * - 1 ;
51253: LD_ADDR_VAR 0 6
51257: PUSH
51258: LD_VAR 0 6
51262: PUSH
51263: LD_INT 1
51265: NEG
51266: MUL
51267: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
51268: LD_ADDR_VAR 0 7
51272: PUSH
51273: LD_VAR 0 2
51277: PUSH
51278: LD_VAR 0 4
51282: PLUS
51283: PUSH
51284: LD_INT 2
51286: DIV
51287: ST_TO_ADDR
// if _y < 0 then
51288: LD_VAR 0 7
51292: PUSH
51293: LD_INT 0
51295: LESS
51296: IFFALSE 51313
// _y := _y * - 1 ;
51298: LD_ADDR_VAR 0 7
51302: PUSH
51303: LD_VAR 0 7
51307: PUSH
51308: LD_INT 1
51310: NEG
51311: MUL
51312: ST_TO_ADDR
// result := [ _x , _y ] ;
51313: LD_ADDR_VAR 0 5
51317: PUSH
51318: LD_VAR 0 6
51322: PUSH
51323: LD_VAR 0 7
51327: PUSH
51328: EMPTY
51329: LIST
51330: LIST
51331: ST_TO_ADDR
// end ;
51332: LD_VAR 0 5
51336: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
51337: LD_INT 0
51339: PPUSH
51340: PPUSH
51341: PPUSH
51342: PPUSH
// task := GetTaskList ( unit ) ;
51343: LD_ADDR_VAR 0 7
51347: PUSH
51348: LD_VAR 0 1
51352: PPUSH
51353: CALL_OW 437
51357: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
51358: LD_VAR 0 7
51362: NOT
51363: PUSH
51364: LD_VAR 0 1
51368: PPUSH
51369: LD_VAR 0 2
51373: PPUSH
51374: CALL_OW 308
51378: NOT
51379: AND
51380: IFFALSE 51384
// exit ;
51382: GO 51502
// if IsInArea ( unit , area ) then
51384: LD_VAR 0 1
51388: PPUSH
51389: LD_VAR 0 2
51393: PPUSH
51394: CALL_OW 308
51398: IFFALSE 51416
// begin ComMoveToArea ( unit , goAway ) ;
51400: LD_VAR 0 1
51404: PPUSH
51405: LD_VAR 0 3
51409: PPUSH
51410: CALL_OW 113
// exit ;
51414: GO 51502
// end ; if task [ 1 ] [ 1 ] <> M then
51416: LD_VAR 0 7
51420: PUSH
51421: LD_INT 1
51423: ARRAY
51424: PUSH
51425: LD_INT 1
51427: ARRAY
51428: PUSH
51429: LD_STRING M
51431: NONEQUAL
51432: IFFALSE 51436
// exit ;
51434: GO 51502
// x := task [ 1 ] [ 2 ] ;
51436: LD_ADDR_VAR 0 5
51440: PUSH
51441: LD_VAR 0 7
51445: PUSH
51446: LD_INT 1
51448: ARRAY
51449: PUSH
51450: LD_INT 2
51452: ARRAY
51453: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51454: LD_ADDR_VAR 0 6
51458: PUSH
51459: LD_VAR 0 7
51463: PUSH
51464: LD_INT 1
51466: ARRAY
51467: PUSH
51468: LD_INT 3
51470: ARRAY
51471: ST_TO_ADDR
// if InArea ( x , y , area ) then
51472: LD_VAR 0 5
51476: PPUSH
51477: LD_VAR 0 6
51481: PPUSH
51482: LD_VAR 0 2
51486: PPUSH
51487: CALL_OW 309
51491: IFFALSE 51502
// ComStop ( unit ) ;
51493: LD_VAR 0 1
51497: PPUSH
51498: CALL_OW 141
// end ;
51502: LD_VAR 0 4
51506: RET
// export function Abs ( value ) ; begin
51507: LD_INT 0
51509: PPUSH
// result := value ;
51510: LD_ADDR_VAR 0 2
51514: PUSH
51515: LD_VAR 0 1
51519: ST_TO_ADDR
// if value < 0 then
51520: LD_VAR 0 1
51524: PUSH
51525: LD_INT 0
51527: LESS
51528: IFFALSE 51545
// result := value * - 1 ;
51530: LD_ADDR_VAR 0 2
51534: PUSH
51535: LD_VAR 0 1
51539: PUSH
51540: LD_INT 1
51542: NEG
51543: MUL
51544: ST_TO_ADDR
// end ;
51545: LD_VAR 0 2
51549: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51550: LD_INT 0
51552: PPUSH
51553: PPUSH
51554: PPUSH
51555: PPUSH
51556: PPUSH
51557: PPUSH
51558: PPUSH
51559: PPUSH
// if not unit or not building then
51560: LD_VAR 0 1
51564: NOT
51565: PUSH
51566: LD_VAR 0 2
51570: NOT
51571: OR
51572: IFFALSE 51576
// exit ;
51574: GO 51802
// x := GetX ( building ) ;
51576: LD_ADDR_VAR 0 4
51580: PUSH
51581: LD_VAR 0 2
51585: PPUSH
51586: CALL_OW 250
51590: ST_TO_ADDR
// y := GetY ( building ) ;
51591: LD_ADDR_VAR 0 6
51595: PUSH
51596: LD_VAR 0 2
51600: PPUSH
51601: CALL_OW 251
51605: ST_TO_ADDR
// d := GetDir ( building ) ;
51606: LD_ADDR_VAR 0 8
51610: PUSH
51611: LD_VAR 0 2
51615: PPUSH
51616: CALL_OW 254
51620: ST_TO_ADDR
// r := 4 ;
51621: LD_ADDR_VAR 0 9
51625: PUSH
51626: LD_INT 4
51628: ST_TO_ADDR
// for i := 1 to 5 do
51629: LD_ADDR_VAR 0 10
51633: PUSH
51634: DOUBLE
51635: LD_INT 1
51637: DEC
51638: ST_TO_ADDR
51639: LD_INT 5
51641: PUSH
51642: FOR_TO
51643: IFFALSE 51800
// begin _x := ShiftX ( x , d , r + i ) ;
51645: LD_ADDR_VAR 0 5
51649: PUSH
51650: LD_VAR 0 4
51654: PPUSH
51655: LD_VAR 0 8
51659: PPUSH
51660: LD_VAR 0 9
51664: PUSH
51665: LD_VAR 0 10
51669: PLUS
51670: PPUSH
51671: CALL_OW 272
51675: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51676: LD_ADDR_VAR 0 7
51680: PUSH
51681: LD_VAR 0 6
51685: PPUSH
51686: LD_VAR 0 8
51690: PPUSH
51691: LD_VAR 0 9
51695: PUSH
51696: LD_VAR 0 10
51700: PLUS
51701: PPUSH
51702: CALL_OW 273
51706: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51707: LD_VAR 0 5
51711: PPUSH
51712: LD_VAR 0 7
51716: PPUSH
51717: CALL_OW 488
51721: PUSH
51722: LD_VAR 0 5
51726: PPUSH
51727: LD_VAR 0 7
51731: PPUSH
51732: CALL_OW 428
51736: PPUSH
51737: CALL_OW 247
51741: PUSH
51742: LD_INT 3
51744: PUSH
51745: LD_INT 2
51747: PUSH
51748: EMPTY
51749: LIST
51750: LIST
51751: IN
51752: NOT
51753: AND
51754: IFFALSE 51798
// begin ComMoveXY ( unit , _x , _y ) ;
51756: LD_VAR 0 1
51760: PPUSH
51761: LD_VAR 0 5
51765: PPUSH
51766: LD_VAR 0 7
51770: PPUSH
51771: CALL_OW 111
// result := [ _x , _y ] ;
51775: LD_ADDR_VAR 0 3
51779: PUSH
51780: LD_VAR 0 5
51784: PUSH
51785: LD_VAR 0 7
51789: PUSH
51790: EMPTY
51791: LIST
51792: LIST
51793: ST_TO_ADDR
// exit ;
51794: POP
51795: POP
51796: GO 51802
// end ; end ;
51798: GO 51642
51800: POP
51801: POP
// end ;
51802: LD_VAR 0 3
51806: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
51807: LD_INT 0
51809: PPUSH
51810: PPUSH
51811: PPUSH
// result := 0 ;
51812: LD_ADDR_VAR 0 3
51816: PUSH
51817: LD_INT 0
51819: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
51820: LD_VAR 0 1
51824: PUSH
51825: LD_INT 0
51827: LESS
51828: PUSH
51829: LD_VAR 0 1
51833: PUSH
51834: LD_INT 8
51836: GREATER
51837: OR
51838: PUSH
51839: LD_VAR 0 2
51843: PUSH
51844: LD_INT 0
51846: LESS
51847: OR
51848: PUSH
51849: LD_VAR 0 2
51853: PUSH
51854: LD_INT 8
51856: GREATER
51857: OR
51858: IFFALSE 51862
// exit ;
51860: GO 51937
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
51862: LD_ADDR_VAR 0 4
51866: PUSH
51867: LD_INT 22
51869: PUSH
51870: LD_VAR 0 2
51874: PUSH
51875: EMPTY
51876: LIST
51877: LIST
51878: PPUSH
51879: CALL_OW 69
51883: PUSH
51884: FOR_IN
51885: IFFALSE 51935
// begin un := UnitShoot ( i ) ;
51887: LD_ADDR_VAR 0 5
51891: PUSH
51892: LD_VAR 0 4
51896: PPUSH
51897: CALL_OW 504
51901: ST_TO_ADDR
// if GetSide ( un ) = side1 then
51902: LD_VAR 0 5
51906: PPUSH
51907: CALL_OW 255
51911: PUSH
51912: LD_VAR 0 1
51916: EQUAL
51917: IFFALSE 51933
// begin result := un ;
51919: LD_ADDR_VAR 0 3
51923: PUSH
51924: LD_VAR 0 5
51928: ST_TO_ADDR
// exit ;
51929: POP
51930: POP
51931: GO 51937
// end ; end ;
51933: GO 51884
51935: POP
51936: POP
// end ;
51937: LD_VAR 0 3
51941: RET
// export function GetCargoBay ( units ) ; begin
51942: LD_INT 0
51944: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
51945: LD_ADDR_VAR 0 2
51949: PUSH
51950: LD_VAR 0 1
51954: PPUSH
51955: LD_INT 2
51957: PUSH
51958: LD_INT 34
51960: PUSH
51961: LD_INT 12
51963: PUSH
51964: EMPTY
51965: LIST
51966: LIST
51967: PUSH
51968: LD_INT 34
51970: PUSH
51971: LD_INT 51
51973: PUSH
51974: EMPTY
51975: LIST
51976: LIST
51977: PUSH
51978: LD_INT 34
51980: PUSH
51981: LD_INT 32
51983: PUSH
51984: EMPTY
51985: LIST
51986: LIST
51987: PUSH
51988: LD_INT 34
51990: PUSH
51991: LD_EXP 104
51995: PUSH
51996: EMPTY
51997: LIST
51998: LIST
51999: PUSH
52000: EMPTY
52001: LIST
52002: LIST
52003: LIST
52004: LIST
52005: LIST
52006: PPUSH
52007: CALL_OW 72
52011: ST_TO_ADDR
// end ; end_of_file
52012: LD_VAR 0 2
52016: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
52017: LD_INT 0
52019: PPUSH
52020: PPUSH
// skirmish := false ;
52021: LD_ADDR_EXP 57
52025: PUSH
52026: LD_INT 0
52028: ST_TO_ADDR
// debug_mc := false ;
52029: LD_ADDR_EXP 58
52033: PUSH
52034: LD_INT 0
52036: ST_TO_ADDR
// mc_bases := [ ] ;
52037: LD_ADDR_EXP 59
52041: PUSH
52042: EMPTY
52043: ST_TO_ADDR
// mc_sides := [ ] ;
52044: LD_ADDR_EXP 85
52048: PUSH
52049: EMPTY
52050: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
52051: LD_ADDR_EXP 60
52055: PUSH
52056: EMPTY
52057: ST_TO_ADDR
// mc_building_repairs := [ ] ;
52058: LD_ADDR_EXP 61
52062: PUSH
52063: EMPTY
52064: ST_TO_ADDR
// mc_need_heal := [ ] ;
52065: LD_ADDR_EXP 62
52069: PUSH
52070: EMPTY
52071: ST_TO_ADDR
// mc_healers := [ ] ;
52072: LD_ADDR_EXP 63
52076: PUSH
52077: EMPTY
52078: ST_TO_ADDR
// mc_build_list := [ ] ;
52079: LD_ADDR_EXP 64
52083: PUSH
52084: EMPTY
52085: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
52086: LD_ADDR_EXP 91
52090: PUSH
52091: EMPTY
52092: ST_TO_ADDR
// mc_builders := [ ] ;
52093: LD_ADDR_EXP 65
52097: PUSH
52098: EMPTY
52099: ST_TO_ADDR
// mc_construct_list := [ ] ;
52100: LD_ADDR_EXP 66
52104: PUSH
52105: EMPTY
52106: ST_TO_ADDR
// mc_turret_list := [ ] ;
52107: LD_ADDR_EXP 67
52111: PUSH
52112: EMPTY
52113: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
52114: LD_ADDR_EXP 68
52118: PUSH
52119: EMPTY
52120: ST_TO_ADDR
// mc_miners := [ ] ;
52121: LD_ADDR_EXP 73
52125: PUSH
52126: EMPTY
52127: ST_TO_ADDR
// mc_mines := [ ] ;
52128: LD_ADDR_EXP 72
52132: PUSH
52133: EMPTY
52134: ST_TO_ADDR
// mc_minefields := [ ] ;
52135: LD_ADDR_EXP 74
52139: PUSH
52140: EMPTY
52141: ST_TO_ADDR
// mc_crates := [ ] ;
52142: LD_ADDR_EXP 75
52146: PUSH
52147: EMPTY
52148: ST_TO_ADDR
// mc_crates_collector := [ ] ;
52149: LD_ADDR_EXP 76
52153: PUSH
52154: EMPTY
52155: ST_TO_ADDR
// mc_crates_area := [ ] ;
52156: LD_ADDR_EXP 77
52160: PUSH
52161: EMPTY
52162: ST_TO_ADDR
// mc_vehicles := [ ] ;
52163: LD_ADDR_EXP 78
52167: PUSH
52168: EMPTY
52169: ST_TO_ADDR
// mc_attack := [ ] ;
52170: LD_ADDR_EXP 79
52174: PUSH
52175: EMPTY
52176: ST_TO_ADDR
// mc_produce := [ ] ;
52177: LD_ADDR_EXP 80
52181: PUSH
52182: EMPTY
52183: ST_TO_ADDR
// mc_defender := [ ] ;
52184: LD_ADDR_EXP 81
52188: PUSH
52189: EMPTY
52190: ST_TO_ADDR
// mc_parking := [ ] ;
52191: LD_ADDR_EXP 83
52195: PUSH
52196: EMPTY
52197: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
52198: LD_ADDR_EXP 69
52202: PUSH
52203: EMPTY
52204: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
52205: LD_ADDR_EXP 71
52209: PUSH
52210: EMPTY
52211: ST_TO_ADDR
// mc_scan := [ ] ;
52212: LD_ADDR_EXP 82
52216: PUSH
52217: EMPTY
52218: ST_TO_ADDR
// mc_scan_area := [ ] ;
52219: LD_ADDR_EXP 84
52223: PUSH
52224: EMPTY
52225: ST_TO_ADDR
// mc_tech := [ ] ;
52226: LD_ADDR_EXP 86
52230: PUSH
52231: EMPTY
52232: ST_TO_ADDR
// mc_class := [ ] ;
52233: LD_ADDR_EXP 100
52237: PUSH
52238: EMPTY
52239: ST_TO_ADDR
// mc_class_case_use := [ ] ;
52240: LD_ADDR_EXP 101
52244: PUSH
52245: EMPTY
52246: ST_TO_ADDR
// mc_is_defending := [ ] ;
52247: LD_ADDR_EXP 102
52251: PUSH
52252: EMPTY
52253: ST_TO_ADDR
// end ;
52254: LD_VAR 0 1
52258: RET
// export function MC_Kill ( base ) ; begin
52259: LD_INT 0
52261: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
52262: LD_ADDR_EXP 59
52266: PUSH
52267: LD_EXP 59
52271: PPUSH
52272: LD_VAR 0 1
52276: PPUSH
52277: EMPTY
52278: PPUSH
52279: CALL_OW 1
52283: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52284: LD_ADDR_EXP 60
52288: PUSH
52289: LD_EXP 60
52293: PPUSH
52294: LD_VAR 0 1
52298: PPUSH
52299: EMPTY
52300: PPUSH
52301: CALL_OW 1
52305: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52306: LD_ADDR_EXP 61
52310: PUSH
52311: LD_EXP 61
52315: PPUSH
52316: LD_VAR 0 1
52320: PPUSH
52321: EMPTY
52322: PPUSH
52323: CALL_OW 1
52327: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52328: LD_ADDR_EXP 62
52332: PUSH
52333: LD_EXP 62
52337: PPUSH
52338: LD_VAR 0 1
52342: PPUSH
52343: EMPTY
52344: PPUSH
52345: CALL_OW 1
52349: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52350: LD_ADDR_EXP 63
52354: PUSH
52355: LD_EXP 63
52359: PPUSH
52360: LD_VAR 0 1
52364: PPUSH
52365: EMPTY
52366: PPUSH
52367: CALL_OW 1
52371: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52372: LD_ADDR_EXP 64
52376: PUSH
52377: LD_EXP 64
52381: PPUSH
52382: LD_VAR 0 1
52386: PPUSH
52387: EMPTY
52388: PPUSH
52389: CALL_OW 1
52393: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52394: LD_ADDR_EXP 65
52398: PUSH
52399: LD_EXP 65
52403: PPUSH
52404: LD_VAR 0 1
52408: PPUSH
52409: EMPTY
52410: PPUSH
52411: CALL_OW 1
52415: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52416: LD_ADDR_EXP 66
52420: PUSH
52421: LD_EXP 66
52425: PPUSH
52426: LD_VAR 0 1
52430: PPUSH
52431: EMPTY
52432: PPUSH
52433: CALL_OW 1
52437: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52438: LD_ADDR_EXP 67
52442: PUSH
52443: LD_EXP 67
52447: PPUSH
52448: LD_VAR 0 1
52452: PPUSH
52453: EMPTY
52454: PPUSH
52455: CALL_OW 1
52459: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52460: LD_ADDR_EXP 68
52464: PUSH
52465: LD_EXP 68
52469: PPUSH
52470: LD_VAR 0 1
52474: PPUSH
52475: EMPTY
52476: PPUSH
52477: CALL_OW 1
52481: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52482: LD_ADDR_EXP 69
52486: PUSH
52487: LD_EXP 69
52491: PPUSH
52492: LD_VAR 0 1
52496: PPUSH
52497: EMPTY
52498: PPUSH
52499: CALL_OW 1
52503: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52504: LD_ADDR_EXP 70
52508: PUSH
52509: LD_EXP 70
52513: PPUSH
52514: LD_VAR 0 1
52518: PPUSH
52519: LD_INT 0
52521: PPUSH
52522: CALL_OW 1
52526: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52527: LD_ADDR_EXP 71
52531: PUSH
52532: LD_EXP 71
52536: PPUSH
52537: LD_VAR 0 1
52541: PPUSH
52542: EMPTY
52543: PPUSH
52544: CALL_OW 1
52548: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52549: LD_ADDR_EXP 72
52553: PUSH
52554: LD_EXP 72
52558: PPUSH
52559: LD_VAR 0 1
52563: PPUSH
52564: EMPTY
52565: PPUSH
52566: CALL_OW 1
52570: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52571: LD_ADDR_EXP 73
52575: PUSH
52576: LD_EXP 73
52580: PPUSH
52581: LD_VAR 0 1
52585: PPUSH
52586: EMPTY
52587: PPUSH
52588: CALL_OW 1
52592: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52593: LD_ADDR_EXP 74
52597: PUSH
52598: LD_EXP 74
52602: PPUSH
52603: LD_VAR 0 1
52607: PPUSH
52608: EMPTY
52609: PPUSH
52610: CALL_OW 1
52614: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52615: LD_ADDR_EXP 75
52619: PUSH
52620: LD_EXP 75
52624: PPUSH
52625: LD_VAR 0 1
52629: PPUSH
52630: EMPTY
52631: PPUSH
52632: CALL_OW 1
52636: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52637: LD_ADDR_EXP 76
52641: PUSH
52642: LD_EXP 76
52646: PPUSH
52647: LD_VAR 0 1
52651: PPUSH
52652: EMPTY
52653: PPUSH
52654: CALL_OW 1
52658: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52659: LD_ADDR_EXP 77
52663: PUSH
52664: LD_EXP 77
52668: PPUSH
52669: LD_VAR 0 1
52673: PPUSH
52674: EMPTY
52675: PPUSH
52676: CALL_OW 1
52680: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52681: LD_ADDR_EXP 78
52685: PUSH
52686: LD_EXP 78
52690: PPUSH
52691: LD_VAR 0 1
52695: PPUSH
52696: EMPTY
52697: PPUSH
52698: CALL_OW 1
52702: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52703: LD_ADDR_EXP 79
52707: PUSH
52708: LD_EXP 79
52712: PPUSH
52713: LD_VAR 0 1
52717: PPUSH
52718: EMPTY
52719: PPUSH
52720: CALL_OW 1
52724: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52725: LD_ADDR_EXP 80
52729: PUSH
52730: LD_EXP 80
52734: PPUSH
52735: LD_VAR 0 1
52739: PPUSH
52740: EMPTY
52741: PPUSH
52742: CALL_OW 1
52746: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52747: LD_ADDR_EXP 81
52751: PUSH
52752: LD_EXP 81
52756: PPUSH
52757: LD_VAR 0 1
52761: PPUSH
52762: EMPTY
52763: PPUSH
52764: CALL_OW 1
52768: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52769: LD_ADDR_EXP 82
52773: PUSH
52774: LD_EXP 82
52778: PPUSH
52779: LD_VAR 0 1
52783: PPUSH
52784: EMPTY
52785: PPUSH
52786: CALL_OW 1
52790: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52791: LD_ADDR_EXP 83
52795: PUSH
52796: LD_EXP 83
52800: PPUSH
52801: LD_VAR 0 1
52805: PPUSH
52806: EMPTY
52807: PPUSH
52808: CALL_OW 1
52812: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52813: LD_ADDR_EXP 84
52817: PUSH
52818: LD_EXP 84
52822: PPUSH
52823: LD_VAR 0 1
52827: PPUSH
52828: EMPTY
52829: PPUSH
52830: CALL_OW 1
52834: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52835: LD_ADDR_EXP 86
52839: PUSH
52840: LD_EXP 86
52844: PPUSH
52845: LD_VAR 0 1
52849: PPUSH
52850: EMPTY
52851: PPUSH
52852: CALL_OW 1
52856: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52857: LD_ADDR_EXP 88
52861: PUSH
52862: LD_EXP 88
52866: PPUSH
52867: LD_VAR 0 1
52871: PPUSH
52872: EMPTY
52873: PPUSH
52874: CALL_OW 1
52878: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52879: LD_ADDR_EXP 89
52883: PUSH
52884: LD_EXP 89
52888: PPUSH
52889: LD_VAR 0 1
52893: PPUSH
52894: EMPTY
52895: PPUSH
52896: CALL_OW 1
52900: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52901: LD_ADDR_EXP 90
52905: PUSH
52906: LD_EXP 90
52910: PPUSH
52911: LD_VAR 0 1
52915: PPUSH
52916: EMPTY
52917: PPUSH
52918: CALL_OW 1
52922: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52923: LD_ADDR_EXP 91
52927: PUSH
52928: LD_EXP 91
52932: PPUSH
52933: LD_VAR 0 1
52937: PPUSH
52938: EMPTY
52939: PPUSH
52940: CALL_OW 1
52944: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52945: LD_ADDR_EXP 92
52949: PUSH
52950: LD_EXP 92
52954: PPUSH
52955: LD_VAR 0 1
52959: PPUSH
52960: EMPTY
52961: PPUSH
52962: CALL_OW 1
52966: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52967: LD_ADDR_EXP 93
52971: PUSH
52972: LD_EXP 93
52976: PPUSH
52977: LD_VAR 0 1
52981: PPUSH
52982: EMPTY
52983: PPUSH
52984: CALL_OW 1
52988: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52989: LD_ADDR_EXP 94
52993: PUSH
52994: LD_EXP 94
52998: PPUSH
52999: LD_VAR 0 1
53003: PPUSH
53004: EMPTY
53005: PPUSH
53006: CALL_OW 1
53010: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53011: LD_ADDR_EXP 95
53015: PUSH
53016: LD_EXP 95
53020: PPUSH
53021: LD_VAR 0 1
53025: PPUSH
53026: EMPTY
53027: PPUSH
53028: CALL_OW 1
53032: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53033: LD_ADDR_EXP 96
53037: PUSH
53038: LD_EXP 96
53042: PPUSH
53043: LD_VAR 0 1
53047: PPUSH
53048: EMPTY
53049: PPUSH
53050: CALL_OW 1
53054: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53055: LD_ADDR_EXP 97
53059: PUSH
53060: LD_EXP 97
53064: PPUSH
53065: LD_VAR 0 1
53069: PPUSH
53070: EMPTY
53071: PPUSH
53072: CALL_OW 1
53076: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53077: LD_ADDR_EXP 98
53081: PUSH
53082: LD_EXP 98
53086: PPUSH
53087: LD_VAR 0 1
53091: PPUSH
53092: EMPTY
53093: PPUSH
53094: CALL_OW 1
53098: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53099: LD_ADDR_EXP 99
53103: PUSH
53104: LD_EXP 99
53108: PPUSH
53109: LD_VAR 0 1
53113: PPUSH
53114: EMPTY
53115: PPUSH
53116: CALL_OW 1
53120: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53121: LD_ADDR_EXP 100
53125: PUSH
53126: LD_EXP 100
53130: PPUSH
53131: LD_VAR 0 1
53135: PPUSH
53136: EMPTY
53137: PPUSH
53138: CALL_OW 1
53142: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53143: LD_ADDR_EXP 101
53147: PUSH
53148: LD_EXP 101
53152: PPUSH
53153: LD_VAR 0 1
53157: PPUSH
53158: LD_INT 0
53160: PPUSH
53161: CALL_OW 1
53165: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
53166: LD_ADDR_EXP 102
53170: PUSH
53171: LD_EXP 102
53175: PPUSH
53176: LD_VAR 0 1
53180: PPUSH
53181: LD_INT 0
53183: PPUSH
53184: CALL_OW 1
53188: ST_TO_ADDR
// end ;
53189: LD_VAR 0 2
53193: RET
// export function MC_Add ( side , units ) ; var base ; begin
53194: LD_INT 0
53196: PPUSH
53197: PPUSH
// base := mc_bases + 1 ;
53198: LD_ADDR_VAR 0 4
53202: PUSH
53203: LD_EXP 59
53207: PUSH
53208: LD_INT 1
53210: PLUS
53211: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
53212: LD_ADDR_EXP 85
53216: PUSH
53217: LD_EXP 85
53221: PPUSH
53222: LD_VAR 0 4
53226: PPUSH
53227: LD_VAR 0 1
53231: PPUSH
53232: CALL_OW 1
53236: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
53237: LD_ADDR_EXP 59
53241: PUSH
53242: LD_EXP 59
53246: PPUSH
53247: LD_VAR 0 4
53251: PPUSH
53252: LD_VAR 0 2
53256: PPUSH
53257: CALL_OW 1
53261: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
53262: LD_ADDR_EXP 60
53266: PUSH
53267: LD_EXP 60
53271: PPUSH
53272: LD_VAR 0 4
53276: PPUSH
53277: EMPTY
53278: PPUSH
53279: CALL_OW 1
53283: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
53284: LD_ADDR_EXP 61
53288: PUSH
53289: LD_EXP 61
53293: PPUSH
53294: LD_VAR 0 4
53298: PPUSH
53299: EMPTY
53300: PPUSH
53301: CALL_OW 1
53305: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
53306: LD_ADDR_EXP 62
53310: PUSH
53311: LD_EXP 62
53315: PPUSH
53316: LD_VAR 0 4
53320: PPUSH
53321: EMPTY
53322: PPUSH
53323: CALL_OW 1
53327: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
53328: LD_ADDR_EXP 63
53332: PUSH
53333: LD_EXP 63
53337: PPUSH
53338: LD_VAR 0 4
53342: PPUSH
53343: EMPTY
53344: PPUSH
53345: CALL_OW 1
53349: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
53350: LD_ADDR_EXP 64
53354: PUSH
53355: LD_EXP 64
53359: PPUSH
53360: LD_VAR 0 4
53364: PPUSH
53365: EMPTY
53366: PPUSH
53367: CALL_OW 1
53371: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
53372: LD_ADDR_EXP 65
53376: PUSH
53377: LD_EXP 65
53381: PPUSH
53382: LD_VAR 0 4
53386: PPUSH
53387: EMPTY
53388: PPUSH
53389: CALL_OW 1
53393: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
53394: LD_ADDR_EXP 66
53398: PUSH
53399: LD_EXP 66
53403: PPUSH
53404: LD_VAR 0 4
53408: PPUSH
53409: EMPTY
53410: PPUSH
53411: CALL_OW 1
53415: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
53416: LD_ADDR_EXP 67
53420: PUSH
53421: LD_EXP 67
53425: PPUSH
53426: LD_VAR 0 4
53430: PPUSH
53431: EMPTY
53432: PPUSH
53433: CALL_OW 1
53437: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
53438: LD_ADDR_EXP 68
53442: PUSH
53443: LD_EXP 68
53447: PPUSH
53448: LD_VAR 0 4
53452: PPUSH
53453: EMPTY
53454: PPUSH
53455: CALL_OW 1
53459: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
53460: LD_ADDR_EXP 69
53464: PUSH
53465: LD_EXP 69
53469: PPUSH
53470: LD_VAR 0 4
53474: PPUSH
53475: EMPTY
53476: PPUSH
53477: CALL_OW 1
53481: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
53482: LD_ADDR_EXP 70
53486: PUSH
53487: LD_EXP 70
53491: PPUSH
53492: LD_VAR 0 4
53496: PPUSH
53497: LD_INT 0
53499: PPUSH
53500: CALL_OW 1
53504: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
53505: LD_ADDR_EXP 71
53509: PUSH
53510: LD_EXP 71
53514: PPUSH
53515: LD_VAR 0 4
53519: PPUSH
53520: EMPTY
53521: PPUSH
53522: CALL_OW 1
53526: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
53527: LD_ADDR_EXP 72
53531: PUSH
53532: LD_EXP 72
53536: PPUSH
53537: LD_VAR 0 4
53541: PPUSH
53542: EMPTY
53543: PPUSH
53544: CALL_OW 1
53548: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
53549: LD_ADDR_EXP 73
53553: PUSH
53554: LD_EXP 73
53558: PPUSH
53559: LD_VAR 0 4
53563: PPUSH
53564: EMPTY
53565: PPUSH
53566: CALL_OW 1
53570: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
53571: LD_ADDR_EXP 74
53575: PUSH
53576: LD_EXP 74
53580: PPUSH
53581: LD_VAR 0 4
53585: PPUSH
53586: EMPTY
53587: PPUSH
53588: CALL_OW 1
53592: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
53593: LD_ADDR_EXP 75
53597: PUSH
53598: LD_EXP 75
53602: PPUSH
53603: LD_VAR 0 4
53607: PPUSH
53608: EMPTY
53609: PPUSH
53610: CALL_OW 1
53614: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
53615: LD_ADDR_EXP 76
53619: PUSH
53620: LD_EXP 76
53624: PPUSH
53625: LD_VAR 0 4
53629: PPUSH
53630: EMPTY
53631: PPUSH
53632: CALL_OW 1
53636: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
53637: LD_ADDR_EXP 77
53641: PUSH
53642: LD_EXP 77
53646: PPUSH
53647: LD_VAR 0 4
53651: PPUSH
53652: EMPTY
53653: PPUSH
53654: CALL_OW 1
53658: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
53659: LD_ADDR_EXP 78
53663: PUSH
53664: LD_EXP 78
53668: PPUSH
53669: LD_VAR 0 4
53673: PPUSH
53674: EMPTY
53675: PPUSH
53676: CALL_OW 1
53680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53681: LD_ADDR_EXP 79
53685: PUSH
53686: LD_EXP 79
53690: PPUSH
53691: LD_VAR 0 4
53695: PPUSH
53696: EMPTY
53697: PPUSH
53698: CALL_OW 1
53702: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53703: LD_ADDR_EXP 80
53707: PUSH
53708: LD_EXP 80
53712: PPUSH
53713: LD_VAR 0 4
53717: PPUSH
53718: EMPTY
53719: PPUSH
53720: CALL_OW 1
53724: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53725: LD_ADDR_EXP 81
53729: PUSH
53730: LD_EXP 81
53734: PPUSH
53735: LD_VAR 0 4
53739: PPUSH
53740: EMPTY
53741: PPUSH
53742: CALL_OW 1
53746: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53747: LD_ADDR_EXP 82
53751: PUSH
53752: LD_EXP 82
53756: PPUSH
53757: LD_VAR 0 4
53761: PPUSH
53762: EMPTY
53763: PPUSH
53764: CALL_OW 1
53768: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53769: LD_ADDR_EXP 83
53773: PUSH
53774: LD_EXP 83
53778: PPUSH
53779: LD_VAR 0 4
53783: PPUSH
53784: EMPTY
53785: PPUSH
53786: CALL_OW 1
53790: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53791: LD_ADDR_EXP 84
53795: PUSH
53796: LD_EXP 84
53800: PPUSH
53801: LD_VAR 0 4
53805: PPUSH
53806: EMPTY
53807: PPUSH
53808: CALL_OW 1
53812: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53813: LD_ADDR_EXP 86
53817: PUSH
53818: LD_EXP 86
53822: PPUSH
53823: LD_VAR 0 4
53827: PPUSH
53828: EMPTY
53829: PPUSH
53830: CALL_OW 1
53834: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53835: LD_ADDR_EXP 88
53839: PUSH
53840: LD_EXP 88
53844: PPUSH
53845: LD_VAR 0 4
53849: PPUSH
53850: EMPTY
53851: PPUSH
53852: CALL_OW 1
53856: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53857: LD_ADDR_EXP 89
53861: PUSH
53862: LD_EXP 89
53866: PPUSH
53867: LD_VAR 0 4
53871: PPUSH
53872: EMPTY
53873: PPUSH
53874: CALL_OW 1
53878: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53879: LD_ADDR_EXP 90
53883: PUSH
53884: LD_EXP 90
53888: PPUSH
53889: LD_VAR 0 4
53893: PPUSH
53894: EMPTY
53895: PPUSH
53896: CALL_OW 1
53900: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53901: LD_ADDR_EXP 91
53905: PUSH
53906: LD_EXP 91
53910: PPUSH
53911: LD_VAR 0 4
53915: PPUSH
53916: EMPTY
53917: PPUSH
53918: CALL_OW 1
53922: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53923: LD_ADDR_EXP 92
53927: PUSH
53928: LD_EXP 92
53932: PPUSH
53933: LD_VAR 0 4
53937: PPUSH
53938: EMPTY
53939: PPUSH
53940: CALL_OW 1
53944: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53945: LD_ADDR_EXP 93
53949: PUSH
53950: LD_EXP 93
53954: PPUSH
53955: LD_VAR 0 4
53959: PPUSH
53960: EMPTY
53961: PPUSH
53962: CALL_OW 1
53966: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53967: LD_ADDR_EXP 94
53971: PUSH
53972: LD_EXP 94
53976: PPUSH
53977: LD_VAR 0 4
53981: PPUSH
53982: EMPTY
53983: PPUSH
53984: CALL_OW 1
53988: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53989: LD_ADDR_EXP 95
53993: PUSH
53994: LD_EXP 95
53998: PPUSH
53999: LD_VAR 0 4
54003: PPUSH
54004: EMPTY
54005: PPUSH
54006: CALL_OW 1
54010: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
54011: LD_ADDR_EXP 96
54015: PUSH
54016: LD_EXP 96
54020: PPUSH
54021: LD_VAR 0 4
54025: PPUSH
54026: EMPTY
54027: PPUSH
54028: CALL_OW 1
54032: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
54033: LD_ADDR_EXP 97
54037: PUSH
54038: LD_EXP 97
54042: PPUSH
54043: LD_VAR 0 4
54047: PPUSH
54048: EMPTY
54049: PPUSH
54050: CALL_OW 1
54054: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
54055: LD_ADDR_EXP 98
54059: PUSH
54060: LD_EXP 98
54064: PPUSH
54065: LD_VAR 0 4
54069: PPUSH
54070: EMPTY
54071: PPUSH
54072: CALL_OW 1
54076: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
54077: LD_ADDR_EXP 99
54081: PUSH
54082: LD_EXP 99
54086: PPUSH
54087: LD_VAR 0 4
54091: PPUSH
54092: EMPTY
54093: PPUSH
54094: CALL_OW 1
54098: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
54099: LD_ADDR_EXP 100
54103: PUSH
54104: LD_EXP 100
54108: PPUSH
54109: LD_VAR 0 4
54113: PPUSH
54114: EMPTY
54115: PPUSH
54116: CALL_OW 1
54120: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
54121: LD_ADDR_EXP 101
54125: PUSH
54126: LD_EXP 101
54130: PPUSH
54131: LD_VAR 0 4
54135: PPUSH
54136: LD_INT 0
54138: PPUSH
54139: CALL_OW 1
54143: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
54144: LD_ADDR_EXP 102
54148: PUSH
54149: LD_EXP 102
54153: PPUSH
54154: LD_VAR 0 4
54158: PPUSH
54159: LD_INT 0
54161: PPUSH
54162: CALL_OW 1
54166: ST_TO_ADDR
// result := base ;
54167: LD_ADDR_VAR 0 3
54171: PUSH
54172: LD_VAR 0 4
54176: ST_TO_ADDR
// end ;
54177: LD_VAR 0 3
54181: RET
// export function MC_Start ( ) ; var i ; begin
54182: LD_INT 0
54184: PPUSH
54185: PPUSH
// for i = 1 to mc_bases do
54186: LD_ADDR_VAR 0 2
54190: PUSH
54191: DOUBLE
54192: LD_INT 1
54194: DEC
54195: ST_TO_ADDR
54196: LD_EXP 59
54200: PUSH
54201: FOR_TO
54202: IFFALSE 55279
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
54204: LD_ADDR_EXP 59
54208: PUSH
54209: LD_EXP 59
54213: PPUSH
54214: LD_VAR 0 2
54218: PPUSH
54219: LD_EXP 59
54223: PUSH
54224: LD_VAR 0 2
54228: ARRAY
54229: PUSH
54230: LD_INT 0
54232: DIFF
54233: PPUSH
54234: CALL_OW 1
54238: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
54239: LD_ADDR_EXP 60
54243: PUSH
54244: LD_EXP 60
54248: PPUSH
54249: LD_VAR 0 2
54253: PPUSH
54254: EMPTY
54255: PPUSH
54256: CALL_OW 1
54260: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
54261: LD_ADDR_EXP 61
54265: PUSH
54266: LD_EXP 61
54270: PPUSH
54271: LD_VAR 0 2
54275: PPUSH
54276: EMPTY
54277: PPUSH
54278: CALL_OW 1
54282: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
54283: LD_ADDR_EXP 62
54287: PUSH
54288: LD_EXP 62
54292: PPUSH
54293: LD_VAR 0 2
54297: PPUSH
54298: EMPTY
54299: PPUSH
54300: CALL_OW 1
54304: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
54305: LD_ADDR_EXP 63
54309: PUSH
54310: LD_EXP 63
54314: PPUSH
54315: LD_VAR 0 2
54319: PPUSH
54320: EMPTY
54321: PUSH
54322: EMPTY
54323: PUSH
54324: EMPTY
54325: LIST
54326: LIST
54327: PPUSH
54328: CALL_OW 1
54332: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
54333: LD_ADDR_EXP 64
54337: PUSH
54338: LD_EXP 64
54342: PPUSH
54343: LD_VAR 0 2
54347: PPUSH
54348: EMPTY
54349: PPUSH
54350: CALL_OW 1
54354: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
54355: LD_ADDR_EXP 91
54359: PUSH
54360: LD_EXP 91
54364: PPUSH
54365: LD_VAR 0 2
54369: PPUSH
54370: EMPTY
54371: PPUSH
54372: CALL_OW 1
54376: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
54377: LD_ADDR_EXP 65
54381: PUSH
54382: LD_EXP 65
54386: PPUSH
54387: LD_VAR 0 2
54391: PPUSH
54392: EMPTY
54393: PPUSH
54394: CALL_OW 1
54398: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
54399: LD_ADDR_EXP 66
54403: PUSH
54404: LD_EXP 66
54408: PPUSH
54409: LD_VAR 0 2
54413: PPUSH
54414: EMPTY
54415: PPUSH
54416: CALL_OW 1
54420: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
54421: LD_ADDR_EXP 67
54425: PUSH
54426: LD_EXP 67
54430: PPUSH
54431: LD_VAR 0 2
54435: PPUSH
54436: LD_EXP 59
54440: PUSH
54441: LD_VAR 0 2
54445: ARRAY
54446: PPUSH
54447: LD_INT 2
54449: PUSH
54450: LD_INT 30
54452: PUSH
54453: LD_INT 32
54455: PUSH
54456: EMPTY
54457: LIST
54458: LIST
54459: PUSH
54460: LD_INT 30
54462: PUSH
54463: LD_INT 33
54465: PUSH
54466: EMPTY
54467: LIST
54468: LIST
54469: PUSH
54470: EMPTY
54471: LIST
54472: LIST
54473: LIST
54474: PPUSH
54475: CALL_OW 72
54479: PPUSH
54480: CALL_OW 1
54484: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
54485: LD_ADDR_EXP 68
54489: PUSH
54490: LD_EXP 68
54494: PPUSH
54495: LD_VAR 0 2
54499: PPUSH
54500: LD_EXP 59
54504: PUSH
54505: LD_VAR 0 2
54509: ARRAY
54510: PPUSH
54511: LD_INT 2
54513: PUSH
54514: LD_INT 30
54516: PUSH
54517: LD_INT 32
54519: PUSH
54520: EMPTY
54521: LIST
54522: LIST
54523: PUSH
54524: LD_INT 30
54526: PUSH
54527: LD_INT 31
54529: PUSH
54530: EMPTY
54531: LIST
54532: LIST
54533: PUSH
54534: EMPTY
54535: LIST
54536: LIST
54537: LIST
54538: PUSH
54539: LD_INT 58
54541: PUSH
54542: EMPTY
54543: LIST
54544: PUSH
54545: EMPTY
54546: LIST
54547: LIST
54548: PPUSH
54549: CALL_OW 72
54553: PPUSH
54554: CALL_OW 1
54558: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
54559: LD_ADDR_EXP 69
54563: PUSH
54564: LD_EXP 69
54568: PPUSH
54569: LD_VAR 0 2
54573: PPUSH
54574: EMPTY
54575: PPUSH
54576: CALL_OW 1
54580: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
54581: LD_ADDR_EXP 73
54585: PUSH
54586: LD_EXP 73
54590: PPUSH
54591: LD_VAR 0 2
54595: PPUSH
54596: EMPTY
54597: PPUSH
54598: CALL_OW 1
54602: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
54603: LD_ADDR_EXP 72
54607: PUSH
54608: LD_EXP 72
54612: PPUSH
54613: LD_VAR 0 2
54617: PPUSH
54618: EMPTY
54619: PPUSH
54620: CALL_OW 1
54624: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
54625: LD_ADDR_EXP 74
54629: PUSH
54630: LD_EXP 74
54634: PPUSH
54635: LD_VAR 0 2
54639: PPUSH
54640: EMPTY
54641: PPUSH
54642: CALL_OW 1
54646: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
54647: LD_ADDR_EXP 75
54651: PUSH
54652: LD_EXP 75
54656: PPUSH
54657: LD_VAR 0 2
54661: PPUSH
54662: EMPTY
54663: PPUSH
54664: CALL_OW 1
54668: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
54669: LD_ADDR_EXP 76
54673: PUSH
54674: LD_EXP 76
54678: PPUSH
54679: LD_VAR 0 2
54683: PPUSH
54684: EMPTY
54685: PPUSH
54686: CALL_OW 1
54690: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54691: LD_ADDR_EXP 77
54695: PUSH
54696: LD_EXP 77
54700: PPUSH
54701: LD_VAR 0 2
54705: PPUSH
54706: EMPTY
54707: PPUSH
54708: CALL_OW 1
54712: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54713: LD_ADDR_EXP 78
54717: PUSH
54718: LD_EXP 78
54722: PPUSH
54723: LD_VAR 0 2
54727: PPUSH
54728: EMPTY
54729: PPUSH
54730: CALL_OW 1
54734: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54735: LD_ADDR_EXP 79
54739: PUSH
54740: LD_EXP 79
54744: PPUSH
54745: LD_VAR 0 2
54749: PPUSH
54750: EMPTY
54751: PPUSH
54752: CALL_OW 1
54756: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54757: LD_ADDR_EXP 80
54761: PUSH
54762: LD_EXP 80
54766: PPUSH
54767: LD_VAR 0 2
54771: PPUSH
54772: EMPTY
54773: PPUSH
54774: CALL_OW 1
54778: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54779: LD_ADDR_EXP 81
54783: PUSH
54784: LD_EXP 81
54788: PPUSH
54789: LD_VAR 0 2
54793: PPUSH
54794: EMPTY
54795: PPUSH
54796: CALL_OW 1
54800: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54801: LD_ADDR_EXP 70
54805: PUSH
54806: LD_EXP 70
54810: PPUSH
54811: LD_VAR 0 2
54815: PPUSH
54816: LD_INT 0
54818: PPUSH
54819: CALL_OW 1
54823: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54824: LD_ADDR_EXP 83
54828: PUSH
54829: LD_EXP 83
54833: PPUSH
54834: LD_VAR 0 2
54838: PPUSH
54839: LD_INT 0
54841: PPUSH
54842: CALL_OW 1
54846: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54847: LD_ADDR_EXP 71
54851: PUSH
54852: LD_EXP 71
54856: PPUSH
54857: LD_VAR 0 2
54861: PPUSH
54862: EMPTY
54863: PPUSH
54864: CALL_OW 1
54868: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54869: LD_ADDR_EXP 82
54873: PUSH
54874: LD_EXP 82
54878: PPUSH
54879: LD_VAR 0 2
54883: PPUSH
54884: LD_INT 0
54886: PPUSH
54887: CALL_OW 1
54891: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54892: LD_ADDR_EXP 84
54896: PUSH
54897: LD_EXP 84
54901: PPUSH
54902: LD_VAR 0 2
54906: PPUSH
54907: EMPTY
54908: PPUSH
54909: CALL_OW 1
54913: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54914: LD_ADDR_EXP 87
54918: PUSH
54919: LD_EXP 87
54923: PPUSH
54924: LD_VAR 0 2
54928: PPUSH
54929: LD_INT 0
54931: PPUSH
54932: CALL_OW 1
54936: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54937: LD_ADDR_EXP 88
54941: PUSH
54942: LD_EXP 88
54946: PPUSH
54947: LD_VAR 0 2
54951: PPUSH
54952: EMPTY
54953: PPUSH
54954: CALL_OW 1
54958: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54959: LD_ADDR_EXP 89
54963: PUSH
54964: LD_EXP 89
54968: PPUSH
54969: LD_VAR 0 2
54973: PPUSH
54974: EMPTY
54975: PPUSH
54976: CALL_OW 1
54980: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54981: LD_ADDR_EXP 90
54985: PUSH
54986: LD_EXP 90
54990: PPUSH
54991: LD_VAR 0 2
54995: PPUSH
54996: EMPTY
54997: PPUSH
54998: CALL_OW 1
55002: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
55003: LD_ADDR_EXP 92
55007: PUSH
55008: LD_EXP 92
55012: PPUSH
55013: LD_VAR 0 2
55017: PPUSH
55018: LD_EXP 59
55022: PUSH
55023: LD_VAR 0 2
55027: ARRAY
55028: PPUSH
55029: LD_INT 2
55031: PUSH
55032: LD_INT 30
55034: PUSH
55035: LD_INT 6
55037: PUSH
55038: EMPTY
55039: LIST
55040: LIST
55041: PUSH
55042: LD_INT 30
55044: PUSH
55045: LD_INT 7
55047: PUSH
55048: EMPTY
55049: LIST
55050: LIST
55051: PUSH
55052: LD_INT 30
55054: PUSH
55055: LD_INT 8
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: PUSH
55062: EMPTY
55063: LIST
55064: LIST
55065: LIST
55066: LIST
55067: PPUSH
55068: CALL_OW 72
55072: PPUSH
55073: CALL_OW 1
55077: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
55078: LD_ADDR_EXP 93
55082: PUSH
55083: LD_EXP 93
55087: PPUSH
55088: LD_VAR 0 2
55092: PPUSH
55093: EMPTY
55094: PPUSH
55095: CALL_OW 1
55099: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
55100: LD_ADDR_EXP 94
55104: PUSH
55105: LD_EXP 94
55109: PPUSH
55110: LD_VAR 0 2
55114: PPUSH
55115: EMPTY
55116: PPUSH
55117: CALL_OW 1
55121: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
55122: LD_ADDR_EXP 95
55126: PUSH
55127: LD_EXP 95
55131: PPUSH
55132: LD_VAR 0 2
55136: PPUSH
55137: EMPTY
55138: PPUSH
55139: CALL_OW 1
55143: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
55144: LD_ADDR_EXP 96
55148: PUSH
55149: LD_EXP 96
55153: PPUSH
55154: LD_VAR 0 2
55158: PPUSH
55159: EMPTY
55160: PPUSH
55161: CALL_OW 1
55165: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
55166: LD_ADDR_EXP 97
55170: PUSH
55171: LD_EXP 97
55175: PPUSH
55176: LD_VAR 0 2
55180: PPUSH
55181: EMPTY
55182: PPUSH
55183: CALL_OW 1
55187: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
55188: LD_ADDR_EXP 98
55192: PUSH
55193: LD_EXP 98
55197: PPUSH
55198: LD_VAR 0 2
55202: PPUSH
55203: EMPTY
55204: PPUSH
55205: CALL_OW 1
55209: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
55210: LD_ADDR_EXP 99
55214: PUSH
55215: LD_EXP 99
55219: PPUSH
55220: LD_VAR 0 2
55224: PPUSH
55225: EMPTY
55226: PPUSH
55227: CALL_OW 1
55231: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
55232: LD_ADDR_EXP 100
55236: PUSH
55237: LD_EXP 100
55241: PPUSH
55242: LD_VAR 0 2
55246: PPUSH
55247: EMPTY
55248: PPUSH
55249: CALL_OW 1
55253: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
55254: LD_ADDR_EXP 101
55258: PUSH
55259: LD_EXP 101
55263: PPUSH
55264: LD_VAR 0 2
55268: PPUSH
55269: LD_INT 0
55271: PPUSH
55272: CALL_OW 1
55276: ST_TO_ADDR
// end ;
55277: GO 54201
55279: POP
55280: POP
// MC_InitSides ( ) ;
55281: CALL 55567 0 0
// MC_InitResearch ( ) ;
55285: CALL 55306 0 0
// CustomInitMacro ( ) ;
55289: CALL 185 0 0
// skirmish := true ;
55293: LD_ADDR_EXP 57
55297: PUSH
55298: LD_INT 1
55300: ST_TO_ADDR
// end ;
55301: LD_VAR 0 1
55305: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
55306: LD_INT 0
55308: PPUSH
55309: PPUSH
55310: PPUSH
55311: PPUSH
55312: PPUSH
55313: PPUSH
// if not mc_bases then
55314: LD_EXP 59
55318: NOT
55319: IFFALSE 55323
// exit ;
55321: GO 55562
// for i = 1 to 8 do
55323: LD_ADDR_VAR 0 2
55327: PUSH
55328: DOUBLE
55329: LD_INT 1
55331: DEC
55332: ST_TO_ADDR
55333: LD_INT 8
55335: PUSH
55336: FOR_TO
55337: IFFALSE 55363
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
55339: LD_ADDR_EXP 86
55343: PUSH
55344: LD_EXP 86
55348: PPUSH
55349: LD_VAR 0 2
55353: PPUSH
55354: EMPTY
55355: PPUSH
55356: CALL_OW 1
55360: ST_TO_ADDR
55361: GO 55336
55363: POP
55364: POP
// tmp := [ ] ;
55365: LD_ADDR_VAR 0 5
55369: PUSH
55370: EMPTY
55371: ST_TO_ADDR
// for i = 1 to mc_sides do
55372: LD_ADDR_VAR 0 2
55376: PUSH
55377: DOUBLE
55378: LD_INT 1
55380: DEC
55381: ST_TO_ADDR
55382: LD_EXP 85
55386: PUSH
55387: FOR_TO
55388: IFFALSE 55446
// if not mc_sides [ i ] in tmp then
55390: LD_EXP 85
55394: PUSH
55395: LD_VAR 0 2
55399: ARRAY
55400: PUSH
55401: LD_VAR 0 5
55405: IN
55406: NOT
55407: IFFALSE 55444
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
55409: LD_ADDR_VAR 0 5
55413: PUSH
55414: LD_VAR 0 5
55418: PPUSH
55419: LD_VAR 0 5
55423: PUSH
55424: LD_INT 1
55426: PLUS
55427: PPUSH
55428: LD_EXP 85
55432: PUSH
55433: LD_VAR 0 2
55437: ARRAY
55438: PPUSH
55439: CALL_OW 2
55443: ST_TO_ADDR
55444: GO 55387
55446: POP
55447: POP
// if not tmp then
55448: LD_VAR 0 5
55452: NOT
55453: IFFALSE 55457
// exit ;
55455: GO 55562
// for j in tmp do
55457: LD_ADDR_VAR 0 3
55461: PUSH
55462: LD_VAR 0 5
55466: PUSH
55467: FOR_IN
55468: IFFALSE 55560
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
55470: LD_ADDR_VAR 0 6
55474: PUSH
55475: LD_INT 22
55477: PUSH
55478: LD_VAR 0 3
55482: PUSH
55483: EMPTY
55484: LIST
55485: LIST
55486: PPUSH
55487: CALL_OW 69
55491: ST_TO_ADDR
// if not un then
55492: LD_VAR 0 6
55496: NOT
55497: IFFALSE 55501
// continue ;
55499: GO 55467
// nation := GetNation ( un [ 1 ] ) ;
55501: LD_ADDR_VAR 0 4
55505: PUSH
55506: LD_VAR 0 6
55510: PUSH
55511: LD_INT 1
55513: ARRAY
55514: PPUSH
55515: CALL_OW 248
55519: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
55520: LD_ADDR_EXP 86
55524: PUSH
55525: LD_EXP 86
55529: PPUSH
55530: LD_VAR 0 3
55534: PPUSH
55535: LD_VAR 0 3
55539: PPUSH
55540: LD_VAR 0 4
55544: PPUSH
55545: LD_INT 1
55547: PPUSH
55548: CALL 14424 0 3
55552: PPUSH
55553: CALL_OW 1
55557: ST_TO_ADDR
// end ;
55558: GO 55467
55560: POP
55561: POP
// end ;
55562: LD_VAR 0 1
55566: RET
// export function MC_InitSides ( ) ; var i ; begin
55567: LD_INT 0
55569: PPUSH
55570: PPUSH
// if not mc_bases then
55571: LD_EXP 59
55575: NOT
55576: IFFALSE 55580
// exit ;
55578: GO 55654
// for i = 1 to mc_bases do
55580: LD_ADDR_VAR 0 2
55584: PUSH
55585: DOUBLE
55586: LD_INT 1
55588: DEC
55589: ST_TO_ADDR
55590: LD_EXP 59
55594: PUSH
55595: FOR_TO
55596: IFFALSE 55652
// if mc_bases [ i ] then
55598: LD_EXP 59
55602: PUSH
55603: LD_VAR 0 2
55607: ARRAY
55608: IFFALSE 55650
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
55610: LD_ADDR_EXP 85
55614: PUSH
55615: LD_EXP 85
55619: PPUSH
55620: LD_VAR 0 2
55624: PPUSH
55625: LD_EXP 59
55629: PUSH
55630: LD_VAR 0 2
55634: ARRAY
55635: PUSH
55636: LD_INT 1
55638: ARRAY
55639: PPUSH
55640: CALL_OW 255
55644: PPUSH
55645: CALL_OW 1
55649: ST_TO_ADDR
55650: GO 55595
55652: POP
55653: POP
// end ;
55654: LD_VAR 0 1
55658: RET
// every 0 0$03 trigger skirmish do
55659: LD_EXP 57
55663: IFFALSE 55817
55665: GO 55667
55667: DISABLE
// begin enable ;
55668: ENABLE
// MC_CheckBuildings ( ) ;
55669: CALL 60315 0 0
// MC_CheckPeopleLife ( ) ;
55673: CALL 60440 0 0
// RaiseSailEvent ( 100 ) ;
55677: LD_INT 100
55679: PPUSH
55680: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55684: LD_INT 103
55686: PPUSH
55687: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55691: LD_INT 104
55693: PPUSH
55694: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55698: LD_INT 105
55700: PPUSH
55701: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55705: LD_INT 106
55707: PPUSH
55708: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55712: LD_INT 107
55714: PPUSH
55715: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55719: LD_INT 108
55721: PPUSH
55722: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55726: LD_INT 109
55728: PPUSH
55729: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55733: LD_INT 110
55735: PPUSH
55736: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55740: LD_INT 111
55742: PPUSH
55743: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55747: LD_INT 112
55749: PPUSH
55750: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55754: LD_INT 113
55756: PPUSH
55757: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55761: LD_INT 120
55763: PPUSH
55764: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55768: LD_INT 121
55770: PPUSH
55771: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55775: LD_INT 122
55777: PPUSH
55778: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55782: LD_INT 123
55784: PPUSH
55785: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55789: LD_INT 124
55791: PPUSH
55792: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55796: LD_INT 125
55798: PPUSH
55799: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55803: LD_INT 126
55805: PPUSH
55806: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55810: LD_INT 200
55812: PPUSH
55813: CALL_OW 427
// end ;
55817: END
// on SailEvent ( event ) do begin if event < 100 then
55818: LD_VAR 0 1
55822: PUSH
55823: LD_INT 100
55825: LESS
55826: IFFALSE 55837
// CustomEvent ( event ) ;
55828: LD_VAR 0 1
55832: PPUSH
55833: CALL 13082 0 1
// if event = 100 then
55837: LD_VAR 0 1
55841: PUSH
55842: LD_INT 100
55844: EQUAL
55845: IFFALSE 55851
// MC_ClassManager ( ) ;
55847: CALL 56243 0 0
// if event = 101 then
55851: LD_VAR 0 1
55855: PUSH
55856: LD_INT 101
55858: EQUAL
55859: IFFALSE 55865
// MC_RepairBuildings ( ) ;
55861: CALL 61025 0 0
// if event = 102 then
55865: LD_VAR 0 1
55869: PUSH
55870: LD_INT 102
55872: EQUAL
55873: IFFALSE 55879
// MC_Heal ( ) ;
55875: CALL 61910 0 0
// if event = 103 then
55879: LD_VAR 0 1
55883: PUSH
55884: LD_INT 103
55886: EQUAL
55887: IFFALSE 55893
// MC_Build ( ) ;
55889: CALL 62332 0 0
// if event = 104 then
55893: LD_VAR 0 1
55897: PUSH
55898: LD_INT 104
55900: EQUAL
55901: IFFALSE 55907
// MC_TurretWeapon ( ) ;
55903: CALL 63973 0 0
// if event = 105 then
55907: LD_VAR 0 1
55911: PUSH
55912: LD_INT 105
55914: EQUAL
55915: IFFALSE 55921
// MC_BuildUpgrade ( ) ;
55917: CALL 63524 0 0
// if event = 106 then
55921: LD_VAR 0 1
55925: PUSH
55926: LD_INT 106
55928: EQUAL
55929: IFFALSE 55935
// MC_PlantMines ( ) ;
55931: CALL 64403 0 0
// if event = 107 then
55935: LD_VAR 0 1
55939: PUSH
55940: LD_INT 107
55942: EQUAL
55943: IFFALSE 55949
// MC_CollectCrates ( ) ;
55945: CALL 65194 0 0
// if event = 108 then
55949: LD_VAR 0 1
55953: PUSH
55954: LD_INT 108
55956: EQUAL
55957: IFFALSE 55963
// MC_LinkRemoteControl ( ) ;
55959: CALL 66970 0 0
// if event = 109 then
55963: LD_VAR 0 1
55967: PUSH
55968: LD_INT 109
55970: EQUAL
55971: IFFALSE 55977
// MC_ProduceVehicle ( ) ;
55973: CALL 67151 0 0
// if event = 110 then
55977: LD_VAR 0 1
55981: PUSH
55982: LD_INT 110
55984: EQUAL
55985: IFFALSE 55991
// MC_SendAttack ( ) ;
55987: CALL 67617 0 0
// if event = 111 then
55991: LD_VAR 0 1
55995: PUSH
55996: LD_INT 111
55998: EQUAL
55999: IFFALSE 56005
// MC_Defend ( ) ;
56001: CALL 67725 0 0
// if event = 112 then
56005: LD_VAR 0 1
56009: PUSH
56010: LD_INT 112
56012: EQUAL
56013: IFFALSE 56019
// MC_Research ( ) ;
56015: CALL 68447 0 0
// if event = 113 then
56019: LD_VAR 0 1
56023: PUSH
56024: LD_INT 113
56026: EQUAL
56027: IFFALSE 56033
// MC_MinesTrigger ( ) ;
56029: CALL 69561 0 0
// if event = 120 then
56033: LD_VAR 0 1
56037: PUSH
56038: LD_INT 120
56040: EQUAL
56041: IFFALSE 56047
// MC_RepairVehicle ( ) ;
56043: CALL 69660 0 0
// if event = 121 then
56047: LD_VAR 0 1
56051: PUSH
56052: LD_INT 121
56054: EQUAL
56055: IFFALSE 56061
// MC_TameApe ( ) ;
56057: CALL 70390 0 0
// if event = 122 then
56061: LD_VAR 0 1
56065: PUSH
56066: LD_INT 122
56068: EQUAL
56069: IFFALSE 56075
// MC_ChangeApeClass ( ) ;
56071: CALL 71219 0 0
// if event = 123 then
56075: LD_VAR 0 1
56079: PUSH
56080: LD_INT 123
56082: EQUAL
56083: IFFALSE 56089
// MC_Bazooka ( ) ;
56085: CALL 71869 0 0
// if event = 124 then
56089: LD_VAR 0 1
56093: PUSH
56094: LD_INT 124
56096: EQUAL
56097: IFFALSE 56103
// MC_TeleportExit ( ) ;
56099: CALL 72067 0 0
// if event = 125 then
56103: LD_VAR 0 1
56107: PUSH
56108: LD_INT 125
56110: EQUAL
56111: IFFALSE 56117
// MC_Deposits ( ) ;
56113: CALL 72714 0 0
// if event = 126 then
56117: LD_VAR 0 1
56121: PUSH
56122: LD_INT 126
56124: EQUAL
56125: IFFALSE 56131
// MC_RemoteDriver ( ) ;
56127: CALL 73339 0 0
// if event = 200 then
56131: LD_VAR 0 1
56135: PUSH
56136: LD_INT 200
56138: EQUAL
56139: IFFALSE 56145
// MC_Idle ( ) ;
56141: CALL 75288 0 0
// end ;
56145: PPOPN 1
56147: END
// export function MC_Reset ( base , tag ) ; var i ; begin
56148: LD_INT 0
56150: PPUSH
56151: PPUSH
// if not mc_bases [ base ] or not tag then
56152: LD_EXP 59
56156: PUSH
56157: LD_VAR 0 1
56161: ARRAY
56162: NOT
56163: PUSH
56164: LD_VAR 0 2
56168: NOT
56169: OR
56170: IFFALSE 56174
// exit ;
56172: GO 56238
// for i in mc_bases [ base ] union mc_ape [ base ] do
56174: LD_ADDR_VAR 0 4
56178: PUSH
56179: LD_EXP 59
56183: PUSH
56184: LD_VAR 0 1
56188: ARRAY
56189: PUSH
56190: LD_EXP 88
56194: PUSH
56195: LD_VAR 0 1
56199: ARRAY
56200: UNION
56201: PUSH
56202: FOR_IN
56203: IFFALSE 56236
// if GetTag ( i ) = tag then
56205: LD_VAR 0 4
56209: PPUSH
56210: CALL_OW 110
56214: PUSH
56215: LD_VAR 0 2
56219: EQUAL
56220: IFFALSE 56234
// SetTag ( i , 0 ) ;
56222: LD_VAR 0 4
56226: PPUSH
56227: LD_INT 0
56229: PPUSH
56230: CALL_OW 109
56234: GO 56202
56236: POP
56237: POP
// end ;
56238: LD_VAR 0 3
56242: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
56243: LD_INT 0
56245: PPUSH
56246: PPUSH
56247: PPUSH
56248: PPUSH
56249: PPUSH
56250: PPUSH
56251: PPUSH
56252: PPUSH
// if not mc_bases then
56253: LD_EXP 59
56257: NOT
56258: IFFALSE 56262
// exit ;
56260: GO 56720
// for i = 1 to mc_bases do
56262: LD_ADDR_VAR 0 2
56266: PUSH
56267: DOUBLE
56268: LD_INT 1
56270: DEC
56271: ST_TO_ADDR
56272: LD_EXP 59
56276: PUSH
56277: FOR_TO
56278: IFFALSE 56718
// begin tmp := MC_ClassCheckReq ( i ) ;
56280: LD_ADDR_VAR 0 4
56284: PUSH
56285: LD_VAR 0 2
56289: PPUSH
56290: CALL 56725 0 1
56294: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
56295: LD_ADDR_EXP 100
56299: PUSH
56300: LD_EXP 100
56304: PPUSH
56305: LD_VAR 0 2
56309: PPUSH
56310: LD_VAR 0 4
56314: PPUSH
56315: CALL_OW 1
56319: ST_TO_ADDR
// if not tmp then
56320: LD_VAR 0 4
56324: NOT
56325: IFFALSE 56329
// continue ;
56327: GO 56277
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
56329: LD_ADDR_VAR 0 6
56333: PUSH
56334: LD_EXP 59
56338: PUSH
56339: LD_VAR 0 2
56343: ARRAY
56344: PPUSH
56345: LD_INT 2
56347: PUSH
56348: LD_INT 30
56350: PUSH
56351: LD_INT 4
56353: PUSH
56354: EMPTY
56355: LIST
56356: LIST
56357: PUSH
56358: LD_INT 30
56360: PUSH
56361: LD_INT 5
56363: PUSH
56364: EMPTY
56365: LIST
56366: LIST
56367: PUSH
56368: EMPTY
56369: LIST
56370: LIST
56371: LIST
56372: PPUSH
56373: CALL_OW 72
56377: PUSH
56378: LD_EXP 59
56382: PUSH
56383: LD_VAR 0 2
56387: ARRAY
56388: PPUSH
56389: LD_INT 2
56391: PUSH
56392: LD_INT 30
56394: PUSH
56395: LD_INT 0
56397: PUSH
56398: EMPTY
56399: LIST
56400: LIST
56401: PUSH
56402: LD_INT 30
56404: PUSH
56405: LD_INT 1
56407: PUSH
56408: EMPTY
56409: LIST
56410: LIST
56411: PUSH
56412: EMPTY
56413: LIST
56414: LIST
56415: LIST
56416: PPUSH
56417: CALL_OW 72
56421: PUSH
56422: LD_EXP 59
56426: PUSH
56427: LD_VAR 0 2
56431: ARRAY
56432: PPUSH
56433: LD_INT 30
56435: PUSH
56436: LD_INT 3
56438: PUSH
56439: EMPTY
56440: LIST
56441: LIST
56442: PPUSH
56443: CALL_OW 72
56447: PUSH
56448: LD_EXP 59
56452: PUSH
56453: LD_VAR 0 2
56457: ARRAY
56458: PPUSH
56459: LD_INT 2
56461: PUSH
56462: LD_INT 30
56464: PUSH
56465: LD_INT 6
56467: PUSH
56468: EMPTY
56469: LIST
56470: LIST
56471: PUSH
56472: LD_INT 30
56474: PUSH
56475: LD_INT 7
56477: PUSH
56478: EMPTY
56479: LIST
56480: LIST
56481: PUSH
56482: LD_INT 30
56484: PUSH
56485: LD_INT 8
56487: PUSH
56488: EMPTY
56489: LIST
56490: LIST
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: LIST
56496: LIST
56497: PPUSH
56498: CALL_OW 72
56502: PUSH
56503: EMPTY
56504: LIST
56505: LIST
56506: LIST
56507: LIST
56508: ST_TO_ADDR
// for j = 1 to 4 do
56509: LD_ADDR_VAR 0 3
56513: PUSH
56514: DOUBLE
56515: LD_INT 1
56517: DEC
56518: ST_TO_ADDR
56519: LD_INT 4
56521: PUSH
56522: FOR_TO
56523: IFFALSE 56714
// begin if not tmp [ j ] then
56525: LD_VAR 0 4
56529: PUSH
56530: LD_VAR 0 3
56534: ARRAY
56535: NOT
56536: IFFALSE 56540
// continue ;
56538: GO 56522
// for p in tmp [ j ] do
56540: LD_ADDR_VAR 0 5
56544: PUSH
56545: LD_VAR 0 4
56549: PUSH
56550: LD_VAR 0 3
56554: ARRAY
56555: PUSH
56556: FOR_IN
56557: IFFALSE 56710
// begin if not b [ j ] then
56559: LD_VAR 0 6
56563: PUSH
56564: LD_VAR 0 3
56568: ARRAY
56569: NOT
56570: IFFALSE 56574
// break ;
56572: GO 56710
// e := 0 ;
56574: LD_ADDR_VAR 0 7
56578: PUSH
56579: LD_INT 0
56581: ST_TO_ADDR
// for k in b [ j ] do
56582: LD_ADDR_VAR 0 8
56586: PUSH
56587: LD_VAR 0 6
56591: PUSH
56592: LD_VAR 0 3
56596: ARRAY
56597: PUSH
56598: FOR_IN
56599: IFFALSE 56626
// if IsNotFull ( k ) then
56601: LD_VAR 0 8
56605: PPUSH
56606: CALL 16573 0 1
56610: IFFALSE 56624
// begin e := k ;
56612: LD_ADDR_VAR 0 7
56616: PUSH
56617: LD_VAR 0 8
56621: ST_TO_ADDR
// break ;
56622: GO 56626
// end ;
56624: GO 56598
56626: POP
56627: POP
// if e and not UnitGoingToBuilding ( p , e ) then
56628: LD_VAR 0 7
56632: PUSH
56633: LD_VAR 0 5
56637: PPUSH
56638: LD_VAR 0 7
56642: PPUSH
56643: CALL 49326 0 2
56647: NOT
56648: AND
56649: IFFALSE 56708
// begin if IsInUnit ( p ) then
56651: LD_VAR 0 5
56655: PPUSH
56656: CALL_OW 310
56660: IFFALSE 56671
// ComExitBuilding ( p ) ;
56662: LD_VAR 0 5
56666: PPUSH
56667: CALL_OW 122
// ComEnterUnit ( p , e ) ;
56671: LD_VAR 0 5
56675: PPUSH
56676: LD_VAR 0 7
56680: PPUSH
56681: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56685: LD_VAR 0 5
56689: PPUSH
56690: LD_VAR 0 3
56694: PPUSH
56695: CALL_OW 183
// AddComExitBuilding ( p ) ;
56699: LD_VAR 0 5
56703: PPUSH
56704: CALL_OW 182
// end ; end ;
56708: GO 56556
56710: POP
56711: POP
// end ;
56712: GO 56522
56714: POP
56715: POP
// end ;
56716: GO 56277
56718: POP
56719: POP
// end ;
56720: LD_VAR 0 1
56724: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56725: LD_INT 0
56727: PPUSH
56728: PPUSH
56729: PPUSH
56730: PPUSH
56731: PPUSH
56732: PPUSH
56733: PPUSH
56734: PPUSH
56735: PPUSH
56736: PPUSH
56737: PPUSH
56738: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56739: LD_VAR 0 1
56743: NOT
56744: PUSH
56745: LD_EXP 59
56749: PUSH
56750: LD_VAR 0 1
56754: ARRAY
56755: NOT
56756: OR
56757: PUSH
56758: LD_EXP 59
56762: PUSH
56763: LD_VAR 0 1
56767: ARRAY
56768: PPUSH
56769: LD_INT 2
56771: PUSH
56772: LD_INT 30
56774: PUSH
56775: LD_INT 0
56777: PUSH
56778: EMPTY
56779: LIST
56780: LIST
56781: PUSH
56782: LD_INT 30
56784: PUSH
56785: LD_INT 1
56787: PUSH
56788: EMPTY
56789: LIST
56790: LIST
56791: PUSH
56792: EMPTY
56793: LIST
56794: LIST
56795: LIST
56796: PPUSH
56797: CALL_OW 72
56801: NOT
56802: OR
56803: IFFALSE 56807
// exit ;
56805: GO 60310
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56807: LD_ADDR_VAR 0 4
56811: PUSH
56812: LD_EXP 59
56816: PUSH
56817: LD_VAR 0 1
56821: ARRAY
56822: PPUSH
56823: LD_INT 2
56825: PUSH
56826: LD_INT 25
56828: PUSH
56829: LD_INT 1
56831: PUSH
56832: EMPTY
56833: LIST
56834: LIST
56835: PUSH
56836: LD_INT 25
56838: PUSH
56839: LD_INT 2
56841: PUSH
56842: EMPTY
56843: LIST
56844: LIST
56845: PUSH
56846: LD_INT 25
56848: PUSH
56849: LD_INT 3
56851: PUSH
56852: EMPTY
56853: LIST
56854: LIST
56855: PUSH
56856: LD_INT 25
56858: PUSH
56859: LD_INT 4
56861: PUSH
56862: EMPTY
56863: LIST
56864: LIST
56865: PUSH
56866: LD_INT 25
56868: PUSH
56869: LD_INT 5
56871: PUSH
56872: EMPTY
56873: LIST
56874: LIST
56875: PUSH
56876: LD_INT 25
56878: PUSH
56879: LD_INT 8
56881: PUSH
56882: EMPTY
56883: LIST
56884: LIST
56885: PUSH
56886: LD_INT 25
56888: PUSH
56889: LD_INT 9
56891: PUSH
56892: EMPTY
56893: LIST
56894: LIST
56895: PUSH
56896: EMPTY
56897: LIST
56898: LIST
56899: LIST
56900: LIST
56901: LIST
56902: LIST
56903: LIST
56904: LIST
56905: PPUSH
56906: CALL_OW 72
56910: ST_TO_ADDR
// if not tmp then
56911: LD_VAR 0 4
56915: NOT
56916: IFFALSE 56920
// exit ;
56918: GO 60310
// for i in tmp do
56920: LD_ADDR_VAR 0 3
56924: PUSH
56925: LD_VAR 0 4
56929: PUSH
56930: FOR_IN
56931: IFFALSE 56962
// if GetTag ( i ) then
56933: LD_VAR 0 3
56937: PPUSH
56938: CALL_OW 110
56942: IFFALSE 56960
// tmp := tmp diff i ;
56944: LD_ADDR_VAR 0 4
56948: PUSH
56949: LD_VAR 0 4
56953: PUSH
56954: LD_VAR 0 3
56958: DIFF
56959: ST_TO_ADDR
56960: GO 56930
56962: POP
56963: POP
// if not tmp then
56964: LD_VAR 0 4
56968: NOT
56969: IFFALSE 56973
// exit ;
56971: GO 60310
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56973: LD_ADDR_VAR 0 5
56977: PUSH
56978: LD_EXP 59
56982: PUSH
56983: LD_VAR 0 1
56987: ARRAY
56988: PPUSH
56989: LD_INT 2
56991: PUSH
56992: LD_INT 25
56994: PUSH
56995: LD_INT 1
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: PUSH
57002: LD_INT 25
57004: PUSH
57005: LD_INT 5
57007: PUSH
57008: EMPTY
57009: LIST
57010: LIST
57011: PUSH
57012: LD_INT 25
57014: PUSH
57015: LD_INT 8
57017: PUSH
57018: EMPTY
57019: LIST
57020: LIST
57021: PUSH
57022: LD_INT 25
57024: PUSH
57025: LD_INT 9
57027: PUSH
57028: EMPTY
57029: LIST
57030: LIST
57031: PUSH
57032: EMPTY
57033: LIST
57034: LIST
57035: LIST
57036: LIST
57037: LIST
57038: PPUSH
57039: CALL_OW 72
57043: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
57044: LD_ADDR_VAR 0 6
57048: PUSH
57049: LD_EXP 59
57053: PUSH
57054: LD_VAR 0 1
57058: ARRAY
57059: PPUSH
57060: LD_INT 25
57062: PUSH
57063: LD_INT 2
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: PPUSH
57070: CALL_OW 72
57074: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
57075: LD_ADDR_VAR 0 7
57079: PUSH
57080: LD_EXP 59
57084: PUSH
57085: LD_VAR 0 1
57089: ARRAY
57090: PPUSH
57091: LD_INT 25
57093: PUSH
57094: LD_INT 3
57096: PUSH
57097: EMPTY
57098: LIST
57099: LIST
57100: PPUSH
57101: CALL_OW 72
57105: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
57106: LD_ADDR_VAR 0 8
57110: PUSH
57111: LD_EXP 59
57115: PUSH
57116: LD_VAR 0 1
57120: ARRAY
57121: PPUSH
57122: LD_INT 25
57124: PUSH
57125: LD_INT 4
57127: PUSH
57128: EMPTY
57129: LIST
57130: LIST
57131: PUSH
57132: LD_INT 24
57134: PUSH
57135: LD_INT 251
57137: PUSH
57138: EMPTY
57139: LIST
57140: LIST
57141: PUSH
57142: EMPTY
57143: LIST
57144: LIST
57145: PPUSH
57146: CALL_OW 72
57150: ST_TO_ADDR
// if mc_scan [ base ] then
57151: LD_EXP 82
57155: PUSH
57156: LD_VAR 0 1
57160: ARRAY
57161: IFFALSE 57622
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
57163: LD_ADDR_EXP 101
57167: PUSH
57168: LD_EXP 101
57172: PPUSH
57173: LD_VAR 0 1
57177: PPUSH
57178: LD_INT 4
57180: PPUSH
57181: CALL_OW 1
57185: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
57186: LD_ADDR_VAR 0 12
57190: PUSH
57191: LD_EXP 59
57195: PUSH
57196: LD_VAR 0 1
57200: ARRAY
57201: PPUSH
57202: LD_INT 2
57204: PUSH
57205: LD_INT 30
57207: PUSH
57208: LD_INT 4
57210: PUSH
57211: EMPTY
57212: LIST
57213: LIST
57214: PUSH
57215: LD_INT 30
57217: PUSH
57218: LD_INT 5
57220: PUSH
57221: EMPTY
57222: LIST
57223: LIST
57224: PUSH
57225: EMPTY
57226: LIST
57227: LIST
57228: LIST
57229: PPUSH
57230: CALL_OW 72
57234: ST_TO_ADDR
// if not b then
57235: LD_VAR 0 12
57239: NOT
57240: IFFALSE 57244
// exit ;
57242: GO 60310
// p := [ ] ;
57244: LD_ADDR_VAR 0 11
57248: PUSH
57249: EMPTY
57250: ST_TO_ADDR
// if sci >= 2 then
57251: LD_VAR 0 8
57255: PUSH
57256: LD_INT 2
57258: GREATEREQUAL
57259: IFFALSE 57290
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
57261: LD_ADDR_VAR 0 8
57265: PUSH
57266: LD_VAR 0 8
57270: PUSH
57271: LD_INT 1
57273: ARRAY
57274: PUSH
57275: LD_VAR 0 8
57279: PUSH
57280: LD_INT 2
57282: ARRAY
57283: PUSH
57284: EMPTY
57285: LIST
57286: LIST
57287: ST_TO_ADDR
57288: GO 57351
// if sci = 1 then
57290: LD_VAR 0 8
57294: PUSH
57295: LD_INT 1
57297: EQUAL
57298: IFFALSE 57319
// sci := [ sci [ 1 ] ] else
57300: LD_ADDR_VAR 0 8
57304: PUSH
57305: LD_VAR 0 8
57309: PUSH
57310: LD_INT 1
57312: ARRAY
57313: PUSH
57314: EMPTY
57315: LIST
57316: ST_TO_ADDR
57317: GO 57351
// if sci = 0 then
57319: LD_VAR 0 8
57323: PUSH
57324: LD_INT 0
57326: EQUAL
57327: IFFALSE 57351
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
57329: LD_ADDR_VAR 0 11
57333: PUSH
57334: LD_VAR 0 4
57338: PPUSH
57339: LD_INT 4
57341: PPUSH
57342: CALL 49189 0 2
57346: PUSH
57347: LD_INT 1
57349: ARRAY
57350: ST_TO_ADDR
// if eng > 4 then
57351: LD_VAR 0 6
57355: PUSH
57356: LD_INT 4
57358: GREATER
57359: IFFALSE 57405
// for i = eng downto 4 do
57361: LD_ADDR_VAR 0 3
57365: PUSH
57366: DOUBLE
57367: LD_VAR 0 6
57371: INC
57372: ST_TO_ADDR
57373: LD_INT 4
57375: PUSH
57376: FOR_DOWNTO
57377: IFFALSE 57403
// eng := eng diff eng [ i ] ;
57379: LD_ADDR_VAR 0 6
57383: PUSH
57384: LD_VAR 0 6
57388: PUSH
57389: LD_VAR 0 6
57393: PUSH
57394: LD_VAR 0 3
57398: ARRAY
57399: DIFF
57400: ST_TO_ADDR
57401: GO 57376
57403: POP
57404: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
57405: LD_ADDR_VAR 0 4
57409: PUSH
57410: LD_VAR 0 4
57414: PUSH
57415: LD_VAR 0 5
57419: PUSH
57420: LD_VAR 0 6
57424: UNION
57425: PUSH
57426: LD_VAR 0 7
57430: UNION
57431: PUSH
57432: LD_VAR 0 8
57436: UNION
57437: DIFF
57438: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
57439: LD_ADDR_VAR 0 13
57443: PUSH
57444: LD_EXP 59
57448: PUSH
57449: LD_VAR 0 1
57453: ARRAY
57454: PPUSH
57455: LD_INT 2
57457: PUSH
57458: LD_INT 30
57460: PUSH
57461: LD_INT 32
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: PUSH
57468: LD_INT 30
57470: PUSH
57471: LD_INT 31
57473: PUSH
57474: EMPTY
57475: LIST
57476: LIST
57477: PUSH
57478: EMPTY
57479: LIST
57480: LIST
57481: LIST
57482: PPUSH
57483: CALL_OW 72
57487: PUSH
57488: LD_EXP 59
57492: PUSH
57493: LD_VAR 0 1
57497: ARRAY
57498: PPUSH
57499: LD_INT 2
57501: PUSH
57502: LD_INT 30
57504: PUSH
57505: LD_INT 4
57507: PUSH
57508: EMPTY
57509: LIST
57510: LIST
57511: PUSH
57512: LD_INT 30
57514: PUSH
57515: LD_INT 5
57517: PUSH
57518: EMPTY
57519: LIST
57520: LIST
57521: PUSH
57522: EMPTY
57523: LIST
57524: LIST
57525: LIST
57526: PPUSH
57527: CALL_OW 72
57531: PUSH
57532: LD_INT 6
57534: MUL
57535: PLUS
57536: ST_TO_ADDR
// if bcount < tmp then
57537: LD_VAR 0 13
57541: PUSH
57542: LD_VAR 0 4
57546: LESS
57547: IFFALSE 57593
// for i = tmp downto bcount do
57549: LD_ADDR_VAR 0 3
57553: PUSH
57554: DOUBLE
57555: LD_VAR 0 4
57559: INC
57560: ST_TO_ADDR
57561: LD_VAR 0 13
57565: PUSH
57566: FOR_DOWNTO
57567: IFFALSE 57591
// tmp := Delete ( tmp , tmp ) ;
57569: LD_ADDR_VAR 0 4
57573: PUSH
57574: LD_VAR 0 4
57578: PPUSH
57579: LD_VAR 0 4
57583: PPUSH
57584: CALL_OW 3
57588: ST_TO_ADDR
57589: GO 57566
57591: POP
57592: POP
// result := [ tmp , 0 , 0 , p ] ;
57593: LD_ADDR_VAR 0 2
57597: PUSH
57598: LD_VAR 0 4
57602: PUSH
57603: LD_INT 0
57605: PUSH
57606: LD_INT 0
57608: PUSH
57609: LD_VAR 0 11
57613: PUSH
57614: EMPTY
57615: LIST
57616: LIST
57617: LIST
57618: LIST
57619: ST_TO_ADDR
// exit ;
57620: GO 60310
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57622: LD_EXP 59
57626: PUSH
57627: LD_VAR 0 1
57631: ARRAY
57632: PPUSH
57633: LD_INT 2
57635: PUSH
57636: LD_INT 30
57638: PUSH
57639: LD_INT 6
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PUSH
57646: LD_INT 30
57648: PUSH
57649: LD_INT 7
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: PUSH
57656: LD_INT 30
57658: PUSH
57659: LD_INT 8
57661: PUSH
57662: EMPTY
57663: LIST
57664: LIST
57665: PUSH
57666: EMPTY
57667: LIST
57668: LIST
57669: LIST
57670: LIST
57671: PPUSH
57672: CALL_OW 72
57676: NOT
57677: PUSH
57678: LD_EXP 59
57682: PUSH
57683: LD_VAR 0 1
57687: ARRAY
57688: PPUSH
57689: LD_INT 30
57691: PUSH
57692: LD_INT 3
57694: PUSH
57695: EMPTY
57696: LIST
57697: LIST
57698: PPUSH
57699: CALL_OW 72
57703: NOT
57704: AND
57705: IFFALSE 57777
// begin if eng = tmp then
57707: LD_VAR 0 6
57711: PUSH
57712: LD_VAR 0 4
57716: EQUAL
57717: IFFALSE 57721
// exit ;
57719: GO 60310
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57721: LD_ADDR_EXP 101
57725: PUSH
57726: LD_EXP 101
57730: PPUSH
57731: LD_VAR 0 1
57735: PPUSH
57736: LD_INT 1
57738: PPUSH
57739: CALL_OW 1
57743: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57744: LD_ADDR_VAR 0 2
57748: PUSH
57749: LD_INT 0
57751: PUSH
57752: LD_VAR 0 4
57756: PUSH
57757: LD_VAR 0 6
57761: DIFF
57762: PUSH
57763: LD_INT 0
57765: PUSH
57766: LD_INT 0
57768: PUSH
57769: EMPTY
57770: LIST
57771: LIST
57772: LIST
57773: LIST
57774: ST_TO_ADDR
// exit ;
57775: GO 60310
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57777: LD_EXP 86
57781: PUSH
57782: LD_EXP 85
57786: PUSH
57787: LD_VAR 0 1
57791: ARRAY
57792: ARRAY
57793: PUSH
57794: LD_EXP 59
57798: PUSH
57799: LD_VAR 0 1
57803: ARRAY
57804: PPUSH
57805: LD_INT 2
57807: PUSH
57808: LD_INT 30
57810: PUSH
57811: LD_INT 6
57813: PUSH
57814: EMPTY
57815: LIST
57816: LIST
57817: PUSH
57818: LD_INT 30
57820: PUSH
57821: LD_INT 7
57823: PUSH
57824: EMPTY
57825: LIST
57826: LIST
57827: PUSH
57828: LD_INT 30
57830: PUSH
57831: LD_INT 8
57833: PUSH
57834: EMPTY
57835: LIST
57836: LIST
57837: PUSH
57838: EMPTY
57839: LIST
57840: LIST
57841: LIST
57842: LIST
57843: PPUSH
57844: CALL_OW 72
57848: AND
57849: PUSH
57850: LD_EXP 59
57854: PUSH
57855: LD_VAR 0 1
57859: ARRAY
57860: PPUSH
57861: LD_INT 30
57863: PUSH
57864: LD_INT 3
57866: PUSH
57867: EMPTY
57868: LIST
57869: LIST
57870: PPUSH
57871: CALL_OW 72
57875: NOT
57876: AND
57877: IFFALSE 58091
// begin if sci >= 6 then
57879: LD_VAR 0 8
57883: PUSH
57884: LD_INT 6
57886: GREATEREQUAL
57887: IFFALSE 57891
// exit ;
57889: GO 60310
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57891: LD_ADDR_EXP 101
57895: PUSH
57896: LD_EXP 101
57900: PPUSH
57901: LD_VAR 0 1
57905: PPUSH
57906: LD_INT 2
57908: PPUSH
57909: CALL_OW 1
57913: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57914: LD_ADDR_VAR 0 9
57918: PUSH
57919: LD_VAR 0 4
57923: PUSH
57924: LD_VAR 0 8
57928: DIFF
57929: PPUSH
57930: LD_INT 4
57932: PPUSH
57933: CALL 49189 0 2
57937: ST_TO_ADDR
// p := [ ] ;
57938: LD_ADDR_VAR 0 11
57942: PUSH
57943: EMPTY
57944: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57945: LD_VAR 0 8
57949: PUSH
57950: LD_INT 6
57952: LESS
57953: PUSH
57954: LD_VAR 0 9
57958: PUSH
57959: LD_INT 6
57961: GREATER
57962: AND
57963: IFFALSE 58044
// begin for i = 1 to 6 - sci do
57965: LD_ADDR_VAR 0 3
57969: PUSH
57970: DOUBLE
57971: LD_INT 1
57973: DEC
57974: ST_TO_ADDR
57975: LD_INT 6
57977: PUSH
57978: LD_VAR 0 8
57982: MINUS
57983: PUSH
57984: FOR_TO
57985: IFFALSE 58040
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57987: LD_ADDR_VAR 0 11
57991: PUSH
57992: LD_VAR 0 11
57996: PPUSH
57997: LD_VAR 0 11
58001: PUSH
58002: LD_INT 1
58004: PLUS
58005: PPUSH
58006: LD_VAR 0 9
58010: PUSH
58011: LD_INT 1
58013: ARRAY
58014: PPUSH
58015: CALL_OW 2
58019: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
58020: LD_ADDR_VAR 0 9
58024: PUSH
58025: LD_VAR 0 9
58029: PPUSH
58030: LD_INT 1
58032: PPUSH
58033: CALL_OW 3
58037: ST_TO_ADDR
// end ;
58038: GO 57984
58040: POP
58041: POP
// end else
58042: GO 58064
// if sort then
58044: LD_VAR 0 9
58048: IFFALSE 58064
// p := sort [ 1 ] ;
58050: LD_ADDR_VAR 0 11
58054: PUSH
58055: LD_VAR 0 9
58059: PUSH
58060: LD_INT 1
58062: ARRAY
58063: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
58064: LD_ADDR_VAR 0 2
58068: PUSH
58069: LD_INT 0
58071: PUSH
58072: LD_INT 0
58074: PUSH
58075: LD_INT 0
58077: PUSH
58078: LD_VAR 0 11
58082: PUSH
58083: EMPTY
58084: LIST
58085: LIST
58086: LIST
58087: LIST
58088: ST_TO_ADDR
// exit ;
58089: GO 60310
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
58091: LD_EXP 86
58095: PUSH
58096: LD_EXP 85
58100: PUSH
58101: LD_VAR 0 1
58105: ARRAY
58106: ARRAY
58107: PUSH
58108: LD_EXP 59
58112: PUSH
58113: LD_VAR 0 1
58117: ARRAY
58118: PPUSH
58119: LD_INT 2
58121: PUSH
58122: LD_INT 30
58124: PUSH
58125: LD_INT 6
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PUSH
58132: LD_INT 30
58134: PUSH
58135: LD_INT 7
58137: PUSH
58138: EMPTY
58139: LIST
58140: LIST
58141: PUSH
58142: LD_INT 30
58144: PUSH
58145: LD_INT 8
58147: PUSH
58148: EMPTY
58149: LIST
58150: LIST
58151: PUSH
58152: EMPTY
58153: LIST
58154: LIST
58155: LIST
58156: LIST
58157: PPUSH
58158: CALL_OW 72
58162: AND
58163: PUSH
58164: LD_EXP 59
58168: PUSH
58169: LD_VAR 0 1
58173: ARRAY
58174: PPUSH
58175: LD_INT 30
58177: PUSH
58178: LD_INT 3
58180: PUSH
58181: EMPTY
58182: LIST
58183: LIST
58184: PPUSH
58185: CALL_OW 72
58189: AND
58190: IFFALSE 58924
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
58192: LD_ADDR_EXP 101
58196: PUSH
58197: LD_EXP 101
58201: PPUSH
58202: LD_VAR 0 1
58206: PPUSH
58207: LD_INT 3
58209: PPUSH
58210: CALL_OW 1
58214: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58215: LD_ADDR_VAR 0 2
58219: PUSH
58220: LD_INT 0
58222: PUSH
58223: LD_INT 0
58225: PUSH
58226: LD_INT 0
58228: PUSH
58229: LD_INT 0
58231: PUSH
58232: EMPTY
58233: LIST
58234: LIST
58235: LIST
58236: LIST
58237: ST_TO_ADDR
// if not eng then
58238: LD_VAR 0 6
58242: NOT
58243: IFFALSE 58306
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
58245: LD_ADDR_VAR 0 11
58249: PUSH
58250: LD_VAR 0 4
58254: PPUSH
58255: LD_INT 2
58257: PPUSH
58258: CALL 49189 0 2
58262: PUSH
58263: LD_INT 1
58265: ARRAY
58266: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
58267: LD_ADDR_VAR 0 2
58271: PUSH
58272: LD_VAR 0 2
58276: PPUSH
58277: LD_INT 2
58279: PPUSH
58280: LD_VAR 0 11
58284: PPUSH
58285: CALL_OW 1
58289: ST_TO_ADDR
// tmp := tmp diff p ;
58290: LD_ADDR_VAR 0 4
58294: PUSH
58295: LD_VAR 0 4
58299: PUSH
58300: LD_VAR 0 11
58304: DIFF
58305: ST_TO_ADDR
// end ; if tmp and sci < 6 then
58306: LD_VAR 0 4
58310: PUSH
58311: LD_VAR 0 8
58315: PUSH
58316: LD_INT 6
58318: LESS
58319: AND
58320: IFFALSE 58508
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
58322: LD_ADDR_VAR 0 9
58326: PUSH
58327: LD_VAR 0 4
58331: PUSH
58332: LD_VAR 0 8
58336: PUSH
58337: LD_VAR 0 7
58341: UNION
58342: DIFF
58343: PPUSH
58344: LD_INT 4
58346: PPUSH
58347: CALL 49189 0 2
58351: ST_TO_ADDR
// p := [ ] ;
58352: LD_ADDR_VAR 0 11
58356: PUSH
58357: EMPTY
58358: ST_TO_ADDR
// if sort then
58359: LD_VAR 0 9
58363: IFFALSE 58479
// for i = 1 to 6 - sci do
58365: LD_ADDR_VAR 0 3
58369: PUSH
58370: DOUBLE
58371: LD_INT 1
58373: DEC
58374: ST_TO_ADDR
58375: LD_INT 6
58377: PUSH
58378: LD_VAR 0 8
58382: MINUS
58383: PUSH
58384: FOR_TO
58385: IFFALSE 58477
// begin if i = sort then
58387: LD_VAR 0 3
58391: PUSH
58392: LD_VAR 0 9
58396: EQUAL
58397: IFFALSE 58401
// break ;
58399: GO 58477
// if GetClass ( i ) = 4 then
58401: LD_VAR 0 3
58405: PPUSH
58406: CALL_OW 257
58410: PUSH
58411: LD_INT 4
58413: EQUAL
58414: IFFALSE 58418
// continue ;
58416: GO 58384
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58418: LD_ADDR_VAR 0 11
58422: PUSH
58423: LD_VAR 0 11
58427: PPUSH
58428: LD_VAR 0 11
58432: PUSH
58433: LD_INT 1
58435: PLUS
58436: PPUSH
58437: LD_VAR 0 9
58441: PUSH
58442: LD_VAR 0 3
58446: ARRAY
58447: PPUSH
58448: CALL_OW 2
58452: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58453: LD_ADDR_VAR 0 4
58457: PUSH
58458: LD_VAR 0 4
58462: PUSH
58463: LD_VAR 0 9
58467: PUSH
58468: LD_VAR 0 3
58472: ARRAY
58473: DIFF
58474: ST_TO_ADDR
// end ;
58475: GO 58384
58477: POP
58478: POP
// if p then
58479: LD_VAR 0 11
58483: IFFALSE 58508
// result := Replace ( result , 4 , p ) ;
58485: LD_ADDR_VAR 0 2
58489: PUSH
58490: LD_VAR 0 2
58494: PPUSH
58495: LD_INT 4
58497: PPUSH
58498: LD_VAR 0 11
58502: PPUSH
58503: CALL_OW 1
58507: ST_TO_ADDR
// end ; if tmp and mech < 6 then
58508: LD_VAR 0 4
58512: PUSH
58513: LD_VAR 0 7
58517: PUSH
58518: LD_INT 6
58520: LESS
58521: AND
58522: IFFALSE 58710
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58524: LD_ADDR_VAR 0 9
58528: PUSH
58529: LD_VAR 0 4
58533: PUSH
58534: LD_VAR 0 8
58538: PUSH
58539: LD_VAR 0 7
58543: UNION
58544: DIFF
58545: PPUSH
58546: LD_INT 3
58548: PPUSH
58549: CALL 49189 0 2
58553: ST_TO_ADDR
// p := [ ] ;
58554: LD_ADDR_VAR 0 11
58558: PUSH
58559: EMPTY
58560: ST_TO_ADDR
// if sort then
58561: LD_VAR 0 9
58565: IFFALSE 58681
// for i = 1 to 6 - mech do
58567: LD_ADDR_VAR 0 3
58571: PUSH
58572: DOUBLE
58573: LD_INT 1
58575: DEC
58576: ST_TO_ADDR
58577: LD_INT 6
58579: PUSH
58580: LD_VAR 0 7
58584: MINUS
58585: PUSH
58586: FOR_TO
58587: IFFALSE 58679
// begin if i = sort then
58589: LD_VAR 0 3
58593: PUSH
58594: LD_VAR 0 9
58598: EQUAL
58599: IFFALSE 58603
// break ;
58601: GO 58679
// if GetClass ( i ) = 3 then
58603: LD_VAR 0 3
58607: PPUSH
58608: CALL_OW 257
58612: PUSH
58613: LD_INT 3
58615: EQUAL
58616: IFFALSE 58620
// continue ;
58618: GO 58586
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58620: LD_ADDR_VAR 0 11
58624: PUSH
58625: LD_VAR 0 11
58629: PPUSH
58630: LD_VAR 0 11
58634: PUSH
58635: LD_INT 1
58637: PLUS
58638: PPUSH
58639: LD_VAR 0 9
58643: PUSH
58644: LD_VAR 0 3
58648: ARRAY
58649: PPUSH
58650: CALL_OW 2
58654: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58655: LD_ADDR_VAR 0 4
58659: PUSH
58660: LD_VAR 0 4
58664: PUSH
58665: LD_VAR 0 9
58669: PUSH
58670: LD_VAR 0 3
58674: ARRAY
58675: DIFF
58676: ST_TO_ADDR
// end ;
58677: GO 58586
58679: POP
58680: POP
// if p then
58681: LD_VAR 0 11
58685: IFFALSE 58710
// result := Replace ( result , 3 , p ) ;
58687: LD_ADDR_VAR 0 2
58691: PUSH
58692: LD_VAR 0 2
58696: PPUSH
58697: LD_INT 3
58699: PPUSH
58700: LD_VAR 0 11
58704: PPUSH
58705: CALL_OW 1
58709: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58710: LD_VAR 0 4
58714: PUSH
58715: LD_INT 6
58717: GREATER
58718: PUSH
58719: LD_VAR 0 6
58723: PUSH
58724: LD_INT 6
58726: LESS
58727: AND
58728: IFFALSE 58922
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58730: LD_ADDR_VAR 0 9
58734: PUSH
58735: LD_VAR 0 4
58739: PUSH
58740: LD_VAR 0 8
58744: PUSH
58745: LD_VAR 0 7
58749: UNION
58750: PUSH
58751: LD_VAR 0 6
58755: UNION
58756: DIFF
58757: PPUSH
58758: LD_INT 2
58760: PPUSH
58761: CALL 49189 0 2
58765: ST_TO_ADDR
// p := [ ] ;
58766: LD_ADDR_VAR 0 11
58770: PUSH
58771: EMPTY
58772: ST_TO_ADDR
// if sort then
58773: LD_VAR 0 9
58777: IFFALSE 58893
// for i = 1 to 6 - eng do
58779: LD_ADDR_VAR 0 3
58783: PUSH
58784: DOUBLE
58785: LD_INT 1
58787: DEC
58788: ST_TO_ADDR
58789: LD_INT 6
58791: PUSH
58792: LD_VAR 0 6
58796: MINUS
58797: PUSH
58798: FOR_TO
58799: IFFALSE 58891
// begin if i = sort then
58801: LD_VAR 0 3
58805: PUSH
58806: LD_VAR 0 9
58810: EQUAL
58811: IFFALSE 58815
// break ;
58813: GO 58891
// if GetClass ( i ) = 2 then
58815: LD_VAR 0 3
58819: PPUSH
58820: CALL_OW 257
58824: PUSH
58825: LD_INT 2
58827: EQUAL
58828: IFFALSE 58832
// continue ;
58830: GO 58798
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58832: LD_ADDR_VAR 0 11
58836: PUSH
58837: LD_VAR 0 11
58841: PPUSH
58842: LD_VAR 0 11
58846: PUSH
58847: LD_INT 1
58849: PLUS
58850: PPUSH
58851: LD_VAR 0 9
58855: PUSH
58856: LD_VAR 0 3
58860: ARRAY
58861: PPUSH
58862: CALL_OW 2
58866: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58867: LD_ADDR_VAR 0 4
58871: PUSH
58872: LD_VAR 0 4
58876: PUSH
58877: LD_VAR 0 9
58881: PUSH
58882: LD_VAR 0 3
58886: ARRAY
58887: DIFF
58888: ST_TO_ADDR
// end ;
58889: GO 58798
58891: POP
58892: POP
// if p then
58893: LD_VAR 0 11
58897: IFFALSE 58922
// result := Replace ( result , 2 , p ) ;
58899: LD_ADDR_VAR 0 2
58903: PUSH
58904: LD_VAR 0 2
58908: PPUSH
58909: LD_INT 2
58911: PPUSH
58912: LD_VAR 0 11
58916: PPUSH
58917: CALL_OW 1
58921: ST_TO_ADDR
// end ; exit ;
58922: GO 60310
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58924: LD_EXP 86
58928: PUSH
58929: LD_EXP 85
58933: PUSH
58934: LD_VAR 0 1
58938: ARRAY
58939: ARRAY
58940: NOT
58941: PUSH
58942: LD_EXP 59
58946: PUSH
58947: LD_VAR 0 1
58951: ARRAY
58952: PPUSH
58953: LD_INT 30
58955: PUSH
58956: LD_INT 3
58958: PUSH
58959: EMPTY
58960: LIST
58961: LIST
58962: PPUSH
58963: CALL_OW 72
58967: AND
58968: PUSH
58969: LD_EXP 64
58973: PUSH
58974: LD_VAR 0 1
58978: ARRAY
58979: AND
58980: IFFALSE 59588
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58982: LD_ADDR_EXP 101
58986: PUSH
58987: LD_EXP 101
58991: PPUSH
58992: LD_VAR 0 1
58996: PPUSH
58997: LD_INT 5
58999: PPUSH
59000: CALL_OW 1
59004: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59005: LD_ADDR_VAR 0 2
59009: PUSH
59010: LD_INT 0
59012: PUSH
59013: LD_INT 0
59015: PUSH
59016: LD_INT 0
59018: PUSH
59019: LD_INT 0
59021: PUSH
59022: EMPTY
59023: LIST
59024: LIST
59025: LIST
59026: LIST
59027: ST_TO_ADDR
// if sci > 1 then
59028: LD_VAR 0 8
59032: PUSH
59033: LD_INT 1
59035: GREATER
59036: IFFALSE 59064
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
59038: LD_ADDR_VAR 0 4
59042: PUSH
59043: LD_VAR 0 4
59047: PUSH
59048: LD_VAR 0 8
59052: PUSH
59053: LD_VAR 0 8
59057: PUSH
59058: LD_INT 1
59060: ARRAY
59061: DIFF
59062: DIFF
59063: ST_TO_ADDR
// if tmp and not sci then
59064: LD_VAR 0 4
59068: PUSH
59069: LD_VAR 0 8
59073: NOT
59074: AND
59075: IFFALSE 59144
// begin sort := SortBySkill ( tmp , 4 ) ;
59077: LD_ADDR_VAR 0 9
59081: PUSH
59082: LD_VAR 0 4
59086: PPUSH
59087: LD_INT 4
59089: PPUSH
59090: CALL 49189 0 2
59094: ST_TO_ADDR
// if sort then
59095: LD_VAR 0 9
59099: IFFALSE 59115
// p := sort [ 1 ] ;
59101: LD_ADDR_VAR 0 11
59105: PUSH
59106: LD_VAR 0 9
59110: PUSH
59111: LD_INT 1
59113: ARRAY
59114: ST_TO_ADDR
// if p then
59115: LD_VAR 0 11
59119: IFFALSE 59144
// result := Replace ( result , 4 , p ) ;
59121: LD_ADDR_VAR 0 2
59125: PUSH
59126: LD_VAR 0 2
59130: PPUSH
59131: LD_INT 4
59133: PPUSH
59134: LD_VAR 0 11
59138: PPUSH
59139: CALL_OW 1
59143: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59144: LD_ADDR_VAR 0 4
59148: PUSH
59149: LD_VAR 0 4
59153: PUSH
59154: LD_VAR 0 7
59158: DIFF
59159: ST_TO_ADDR
// if tmp and mech < 6 then
59160: LD_VAR 0 4
59164: PUSH
59165: LD_VAR 0 7
59169: PUSH
59170: LD_INT 6
59172: LESS
59173: AND
59174: IFFALSE 59362
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
59176: LD_ADDR_VAR 0 9
59180: PUSH
59181: LD_VAR 0 4
59185: PUSH
59186: LD_VAR 0 8
59190: PUSH
59191: LD_VAR 0 7
59195: UNION
59196: DIFF
59197: PPUSH
59198: LD_INT 3
59200: PPUSH
59201: CALL 49189 0 2
59205: ST_TO_ADDR
// p := [ ] ;
59206: LD_ADDR_VAR 0 11
59210: PUSH
59211: EMPTY
59212: ST_TO_ADDR
// if sort then
59213: LD_VAR 0 9
59217: IFFALSE 59333
// for i = 1 to 6 - mech do
59219: LD_ADDR_VAR 0 3
59223: PUSH
59224: DOUBLE
59225: LD_INT 1
59227: DEC
59228: ST_TO_ADDR
59229: LD_INT 6
59231: PUSH
59232: LD_VAR 0 7
59236: MINUS
59237: PUSH
59238: FOR_TO
59239: IFFALSE 59331
// begin if i = sort then
59241: LD_VAR 0 3
59245: PUSH
59246: LD_VAR 0 9
59250: EQUAL
59251: IFFALSE 59255
// break ;
59253: GO 59331
// if GetClass ( i ) = 3 then
59255: LD_VAR 0 3
59259: PPUSH
59260: CALL_OW 257
59264: PUSH
59265: LD_INT 3
59267: EQUAL
59268: IFFALSE 59272
// continue ;
59270: GO 59238
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59272: LD_ADDR_VAR 0 11
59276: PUSH
59277: LD_VAR 0 11
59281: PPUSH
59282: LD_VAR 0 11
59286: PUSH
59287: LD_INT 1
59289: PLUS
59290: PPUSH
59291: LD_VAR 0 9
59295: PUSH
59296: LD_VAR 0 3
59300: ARRAY
59301: PPUSH
59302: CALL_OW 2
59306: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59307: LD_ADDR_VAR 0 4
59311: PUSH
59312: LD_VAR 0 4
59316: PUSH
59317: LD_VAR 0 9
59321: PUSH
59322: LD_VAR 0 3
59326: ARRAY
59327: DIFF
59328: ST_TO_ADDR
// end ;
59329: GO 59238
59331: POP
59332: POP
// if p then
59333: LD_VAR 0 11
59337: IFFALSE 59362
// result := Replace ( result , 3 , p ) ;
59339: LD_ADDR_VAR 0 2
59343: PUSH
59344: LD_VAR 0 2
59348: PPUSH
59349: LD_INT 3
59351: PPUSH
59352: LD_VAR 0 11
59356: PPUSH
59357: CALL_OW 1
59361: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59362: LD_ADDR_VAR 0 4
59366: PUSH
59367: LD_VAR 0 4
59371: PUSH
59372: LD_VAR 0 6
59376: DIFF
59377: ST_TO_ADDR
// if tmp and eng < 6 then
59378: LD_VAR 0 4
59382: PUSH
59383: LD_VAR 0 6
59387: PUSH
59388: LD_INT 6
59390: LESS
59391: AND
59392: IFFALSE 59586
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
59394: LD_ADDR_VAR 0 9
59398: PUSH
59399: LD_VAR 0 4
59403: PUSH
59404: LD_VAR 0 8
59408: PUSH
59409: LD_VAR 0 7
59413: UNION
59414: PUSH
59415: LD_VAR 0 6
59419: UNION
59420: DIFF
59421: PPUSH
59422: LD_INT 2
59424: PPUSH
59425: CALL 49189 0 2
59429: ST_TO_ADDR
// p := [ ] ;
59430: LD_ADDR_VAR 0 11
59434: PUSH
59435: EMPTY
59436: ST_TO_ADDR
// if sort then
59437: LD_VAR 0 9
59441: IFFALSE 59557
// for i = 1 to 6 - eng do
59443: LD_ADDR_VAR 0 3
59447: PUSH
59448: DOUBLE
59449: LD_INT 1
59451: DEC
59452: ST_TO_ADDR
59453: LD_INT 6
59455: PUSH
59456: LD_VAR 0 6
59460: MINUS
59461: PUSH
59462: FOR_TO
59463: IFFALSE 59555
// begin if i = sort then
59465: LD_VAR 0 3
59469: PUSH
59470: LD_VAR 0 9
59474: EQUAL
59475: IFFALSE 59479
// break ;
59477: GO 59555
// if GetClass ( i ) = 2 then
59479: LD_VAR 0 3
59483: PPUSH
59484: CALL_OW 257
59488: PUSH
59489: LD_INT 2
59491: EQUAL
59492: IFFALSE 59496
// continue ;
59494: GO 59462
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59496: LD_ADDR_VAR 0 11
59500: PUSH
59501: LD_VAR 0 11
59505: PPUSH
59506: LD_VAR 0 11
59510: PUSH
59511: LD_INT 1
59513: PLUS
59514: PPUSH
59515: LD_VAR 0 9
59519: PUSH
59520: LD_VAR 0 3
59524: ARRAY
59525: PPUSH
59526: CALL_OW 2
59530: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59531: LD_ADDR_VAR 0 4
59535: PUSH
59536: LD_VAR 0 4
59540: PUSH
59541: LD_VAR 0 9
59545: PUSH
59546: LD_VAR 0 3
59550: ARRAY
59551: DIFF
59552: ST_TO_ADDR
// end ;
59553: GO 59462
59555: POP
59556: POP
// if p then
59557: LD_VAR 0 11
59561: IFFALSE 59586
// result := Replace ( result , 2 , p ) ;
59563: LD_ADDR_VAR 0 2
59567: PUSH
59568: LD_VAR 0 2
59572: PPUSH
59573: LD_INT 2
59575: PPUSH
59576: LD_VAR 0 11
59580: PPUSH
59581: CALL_OW 1
59585: ST_TO_ADDR
// end ; exit ;
59586: GO 60310
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
59588: LD_EXP 86
59592: PUSH
59593: LD_EXP 85
59597: PUSH
59598: LD_VAR 0 1
59602: ARRAY
59603: ARRAY
59604: NOT
59605: PUSH
59606: LD_EXP 59
59610: PUSH
59611: LD_VAR 0 1
59615: ARRAY
59616: PPUSH
59617: LD_INT 30
59619: PUSH
59620: LD_INT 3
59622: PUSH
59623: EMPTY
59624: LIST
59625: LIST
59626: PPUSH
59627: CALL_OW 72
59631: AND
59632: PUSH
59633: LD_EXP 64
59637: PUSH
59638: LD_VAR 0 1
59642: ARRAY
59643: NOT
59644: AND
59645: IFFALSE 60310
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
59647: LD_ADDR_EXP 101
59651: PUSH
59652: LD_EXP 101
59656: PPUSH
59657: LD_VAR 0 1
59661: PPUSH
59662: LD_INT 6
59664: PPUSH
59665: CALL_OW 1
59669: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
59670: LD_ADDR_VAR 0 2
59674: PUSH
59675: LD_INT 0
59677: PUSH
59678: LD_INT 0
59680: PUSH
59681: LD_INT 0
59683: PUSH
59684: LD_INT 0
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: LIST
59691: LIST
59692: ST_TO_ADDR
// if sci >= 1 then
59693: LD_VAR 0 8
59697: PUSH
59698: LD_INT 1
59700: GREATEREQUAL
59701: IFFALSE 59723
// tmp := tmp diff sci [ 1 ] ;
59703: LD_ADDR_VAR 0 4
59707: PUSH
59708: LD_VAR 0 4
59712: PUSH
59713: LD_VAR 0 8
59717: PUSH
59718: LD_INT 1
59720: ARRAY
59721: DIFF
59722: ST_TO_ADDR
// if tmp and not sci then
59723: LD_VAR 0 4
59727: PUSH
59728: LD_VAR 0 8
59732: NOT
59733: AND
59734: IFFALSE 59803
// begin sort := SortBySkill ( tmp , 4 ) ;
59736: LD_ADDR_VAR 0 9
59740: PUSH
59741: LD_VAR 0 4
59745: PPUSH
59746: LD_INT 4
59748: PPUSH
59749: CALL 49189 0 2
59753: ST_TO_ADDR
// if sort then
59754: LD_VAR 0 9
59758: IFFALSE 59774
// p := sort [ 1 ] ;
59760: LD_ADDR_VAR 0 11
59764: PUSH
59765: LD_VAR 0 9
59769: PUSH
59770: LD_INT 1
59772: ARRAY
59773: ST_TO_ADDR
// if p then
59774: LD_VAR 0 11
59778: IFFALSE 59803
// result := Replace ( result , 4 , p ) ;
59780: LD_ADDR_VAR 0 2
59784: PUSH
59785: LD_VAR 0 2
59789: PPUSH
59790: LD_INT 4
59792: PPUSH
59793: LD_VAR 0 11
59797: PPUSH
59798: CALL_OW 1
59802: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59803: LD_ADDR_VAR 0 4
59807: PUSH
59808: LD_VAR 0 4
59812: PUSH
59813: LD_VAR 0 7
59817: DIFF
59818: ST_TO_ADDR
// if tmp and mech < 6 then
59819: LD_VAR 0 4
59823: PUSH
59824: LD_VAR 0 7
59828: PUSH
59829: LD_INT 6
59831: LESS
59832: AND
59833: IFFALSE 60015
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59835: LD_ADDR_VAR 0 9
59839: PUSH
59840: LD_VAR 0 4
59844: PUSH
59845: LD_VAR 0 7
59849: DIFF
59850: PPUSH
59851: LD_INT 3
59853: PPUSH
59854: CALL 49189 0 2
59858: ST_TO_ADDR
// p := [ ] ;
59859: LD_ADDR_VAR 0 11
59863: PUSH
59864: EMPTY
59865: ST_TO_ADDR
// if sort then
59866: LD_VAR 0 9
59870: IFFALSE 59986
// for i = 1 to 6 - mech do
59872: LD_ADDR_VAR 0 3
59876: PUSH
59877: DOUBLE
59878: LD_INT 1
59880: DEC
59881: ST_TO_ADDR
59882: LD_INT 6
59884: PUSH
59885: LD_VAR 0 7
59889: MINUS
59890: PUSH
59891: FOR_TO
59892: IFFALSE 59984
// begin if i = sort then
59894: LD_VAR 0 3
59898: PUSH
59899: LD_VAR 0 9
59903: EQUAL
59904: IFFALSE 59908
// break ;
59906: GO 59984
// if GetClass ( i ) = 3 then
59908: LD_VAR 0 3
59912: PPUSH
59913: CALL_OW 257
59917: PUSH
59918: LD_INT 3
59920: EQUAL
59921: IFFALSE 59925
// continue ;
59923: GO 59891
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59925: LD_ADDR_VAR 0 11
59929: PUSH
59930: LD_VAR 0 11
59934: PPUSH
59935: LD_VAR 0 11
59939: PUSH
59940: LD_INT 1
59942: PLUS
59943: PPUSH
59944: LD_VAR 0 9
59948: PUSH
59949: LD_VAR 0 3
59953: ARRAY
59954: PPUSH
59955: CALL_OW 2
59959: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59960: LD_ADDR_VAR 0 4
59964: PUSH
59965: LD_VAR 0 4
59969: PUSH
59970: LD_VAR 0 9
59974: PUSH
59975: LD_VAR 0 3
59979: ARRAY
59980: DIFF
59981: ST_TO_ADDR
// end ;
59982: GO 59891
59984: POP
59985: POP
// if p then
59986: LD_VAR 0 11
59990: IFFALSE 60015
// result := Replace ( result , 3 , p ) ;
59992: LD_ADDR_VAR 0 2
59996: PUSH
59997: LD_VAR 0 2
60001: PPUSH
60002: LD_INT 3
60004: PPUSH
60005: LD_VAR 0 11
60009: PPUSH
60010: CALL_OW 1
60014: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
60015: LD_ADDR_VAR 0 4
60019: PUSH
60020: LD_VAR 0 4
60024: PUSH
60025: LD_VAR 0 6
60029: DIFF
60030: ST_TO_ADDR
// if tmp and eng < 4 then
60031: LD_VAR 0 4
60035: PUSH
60036: LD_VAR 0 6
60040: PUSH
60041: LD_INT 4
60043: LESS
60044: AND
60045: IFFALSE 60235
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
60047: LD_ADDR_VAR 0 9
60051: PUSH
60052: LD_VAR 0 4
60056: PUSH
60057: LD_VAR 0 7
60061: PUSH
60062: LD_VAR 0 6
60066: UNION
60067: DIFF
60068: PPUSH
60069: LD_INT 2
60071: PPUSH
60072: CALL 49189 0 2
60076: ST_TO_ADDR
// p := [ ] ;
60077: LD_ADDR_VAR 0 11
60081: PUSH
60082: EMPTY
60083: ST_TO_ADDR
// if sort then
60084: LD_VAR 0 9
60088: IFFALSE 60204
// for i = 1 to 4 - eng do
60090: LD_ADDR_VAR 0 3
60094: PUSH
60095: DOUBLE
60096: LD_INT 1
60098: DEC
60099: ST_TO_ADDR
60100: LD_INT 4
60102: PUSH
60103: LD_VAR 0 6
60107: MINUS
60108: PUSH
60109: FOR_TO
60110: IFFALSE 60202
// begin if i = sort then
60112: LD_VAR 0 3
60116: PUSH
60117: LD_VAR 0 9
60121: EQUAL
60122: IFFALSE 60126
// break ;
60124: GO 60202
// if GetClass ( i ) = 2 then
60126: LD_VAR 0 3
60130: PPUSH
60131: CALL_OW 257
60135: PUSH
60136: LD_INT 2
60138: EQUAL
60139: IFFALSE 60143
// continue ;
60141: GO 60109
// p := Insert ( p , p + 1 , sort [ i ] ) ;
60143: LD_ADDR_VAR 0 11
60147: PUSH
60148: LD_VAR 0 11
60152: PPUSH
60153: LD_VAR 0 11
60157: PUSH
60158: LD_INT 1
60160: PLUS
60161: PPUSH
60162: LD_VAR 0 9
60166: PUSH
60167: LD_VAR 0 3
60171: ARRAY
60172: PPUSH
60173: CALL_OW 2
60177: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
60178: LD_ADDR_VAR 0 4
60182: PUSH
60183: LD_VAR 0 4
60187: PUSH
60188: LD_VAR 0 9
60192: PUSH
60193: LD_VAR 0 3
60197: ARRAY
60198: DIFF
60199: ST_TO_ADDR
// end ;
60200: GO 60109
60202: POP
60203: POP
// if p then
60204: LD_VAR 0 11
60208: IFFALSE 60233
// result := Replace ( result , 2 , p ) ;
60210: LD_ADDR_VAR 0 2
60214: PUSH
60215: LD_VAR 0 2
60219: PPUSH
60220: LD_INT 2
60222: PPUSH
60223: LD_VAR 0 11
60227: PPUSH
60228: CALL_OW 1
60232: ST_TO_ADDR
// end else
60233: GO 60279
// for i = eng downto 5 do
60235: LD_ADDR_VAR 0 3
60239: PUSH
60240: DOUBLE
60241: LD_VAR 0 6
60245: INC
60246: ST_TO_ADDR
60247: LD_INT 5
60249: PUSH
60250: FOR_DOWNTO
60251: IFFALSE 60277
// tmp := tmp union eng [ i ] ;
60253: LD_ADDR_VAR 0 4
60257: PUSH
60258: LD_VAR 0 4
60262: PUSH
60263: LD_VAR 0 6
60267: PUSH
60268: LD_VAR 0 3
60272: ARRAY
60273: UNION
60274: ST_TO_ADDR
60275: GO 60250
60277: POP
60278: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
60279: LD_ADDR_VAR 0 2
60283: PUSH
60284: LD_VAR 0 2
60288: PPUSH
60289: LD_INT 1
60291: PPUSH
60292: LD_VAR 0 4
60296: PUSH
60297: LD_VAR 0 5
60301: DIFF
60302: PPUSH
60303: CALL_OW 1
60307: ST_TO_ADDR
// exit ;
60308: GO 60310
// end ; end ;
60310: LD_VAR 0 2
60314: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
60315: LD_INT 0
60317: PPUSH
60318: PPUSH
60319: PPUSH
// if not mc_bases then
60320: LD_EXP 59
60324: NOT
60325: IFFALSE 60329
// exit ;
60327: GO 60435
// for i = 1 to mc_bases do
60329: LD_ADDR_VAR 0 2
60333: PUSH
60334: DOUBLE
60335: LD_INT 1
60337: DEC
60338: ST_TO_ADDR
60339: LD_EXP 59
60343: PUSH
60344: FOR_TO
60345: IFFALSE 60426
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
60347: LD_ADDR_VAR 0 3
60351: PUSH
60352: LD_EXP 59
60356: PUSH
60357: LD_VAR 0 2
60361: ARRAY
60362: PPUSH
60363: LD_INT 21
60365: PUSH
60366: LD_INT 3
60368: PUSH
60369: EMPTY
60370: LIST
60371: LIST
60372: PUSH
60373: LD_INT 3
60375: PUSH
60376: LD_INT 24
60378: PUSH
60379: LD_INT 1000
60381: PUSH
60382: EMPTY
60383: LIST
60384: LIST
60385: PUSH
60386: EMPTY
60387: LIST
60388: LIST
60389: PUSH
60390: EMPTY
60391: LIST
60392: LIST
60393: PPUSH
60394: CALL_OW 72
60398: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
60399: LD_ADDR_EXP 60
60403: PUSH
60404: LD_EXP 60
60408: PPUSH
60409: LD_VAR 0 2
60413: PPUSH
60414: LD_VAR 0 3
60418: PPUSH
60419: CALL_OW 1
60423: ST_TO_ADDR
// end ;
60424: GO 60344
60426: POP
60427: POP
// RaiseSailEvent ( 101 ) ;
60428: LD_INT 101
60430: PPUSH
60431: CALL_OW 427
// end ;
60435: LD_VAR 0 1
60439: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
60440: LD_INT 0
60442: PPUSH
60443: PPUSH
60444: PPUSH
60445: PPUSH
60446: PPUSH
60447: PPUSH
60448: PPUSH
// if not mc_bases then
60449: LD_EXP 59
60453: NOT
60454: IFFALSE 60458
// exit ;
60456: GO 61020
// for i = 1 to mc_bases do
60458: LD_ADDR_VAR 0 2
60462: PUSH
60463: DOUBLE
60464: LD_INT 1
60466: DEC
60467: ST_TO_ADDR
60468: LD_EXP 59
60472: PUSH
60473: FOR_TO
60474: IFFALSE 61011
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
60476: LD_ADDR_VAR 0 5
60480: PUSH
60481: LD_EXP 59
60485: PUSH
60486: LD_VAR 0 2
60490: ARRAY
60491: PUSH
60492: LD_EXP 88
60496: PUSH
60497: LD_VAR 0 2
60501: ARRAY
60502: UNION
60503: PPUSH
60504: LD_INT 21
60506: PUSH
60507: LD_INT 1
60509: PUSH
60510: EMPTY
60511: LIST
60512: LIST
60513: PUSH
60514: LD_INT 1
60516: PUSH
60517: LD_INT 3
60519: PUSH
60520: LD_INT 54
60522: PUSH
60523: EMPTY
60524: LIST
60525: PUSH
60526: EMPTY
60527: LIST
60528: LIST
60529: PUSH
60530: LD_INT 3
60532: PUSH
60533: LD_INT 24
60535: PUSH
60536: LD_INT 1000
60538: PUSH
60539: EMPTY
60540: LIST
60541: LIST
60542: PUSH
60543: EMPTY
60544: LIST
60545: LIST
60546: PUSH
60547: EMPTY
60548: LIST
60549: LIST
60550: LIST
60551: PUSH
60552: EMPTY
60553: LIST
60554: LIST
60555: PPUSH
60556: CALL_OW 72
60560: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
60561: LD_ADDR_VAR 0 6
60565: PUSH
60566: LD_EXP 59
60570: PUSH
60571: LD_VAR 0 2
60575: ARRAY
60576: PPUSH
60577: LD_INT 21
60579: PUSH
60580: LD_INT 1
60582: PUSH
60583: EMPTY
60584: LIST
60585: LIST
60586: PUSH
60587: LD_INT 1
60589: PUSH
60590: LD_INT 3
60592: PUSH
60593: LD_INT 54
60595: PUSH
60596: EMPTY
60597: LIST
60598: PUSH
60599: EMPTY
60600: LIST
60601: LIST
60602: PUSH
60603: LD_INT 3
60605: PUSH
60606: LD_INT 24
60608: PUSH
60609: LD_INT 250
60611: PUSH
60612: EMPTY
60613: LIST
60614: LIST
60615: PUSH
60616: EMPTY
60617: LIST
60618: LIST
60619: PUSH
60620: EMPTY
60621: LIST
60622: LIST
60623: LIST
60624: PUSH
60625: EMPTY
60626: LIST
60627: LIST
60628: PPUSH
60629: CALL_OW 72
60633: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
60634: LD_ADDR_VAR 0 7
60638: PUSH
60639: LD_VAR 0 5
60643: PUSH
60644: LD_VAR 0 6
60648: DIFF
60649: ST_TO_ADDR
// if not need_heal_1 then
60650: LD_VAR 0 6
60654: NOT
60655: IFFALSE 60688
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
60657: LD_ADDR_EXP 62
60661: PUSH
60662: LD_EXP 62
60666: PPUSH
60667: LD_VAR 0 2
60671: PUSH
60672: LD_INT 1
60674: PUSH
60675: EMPTY
60676: LIST
60677: LIST
60678: PPUSH
60679: EMPTY
60680: PPUSH
60681: CALL 19307 0 3
60685: ST_TO_ADDR
60686: GO 60758
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60688: LD_ADDR_EXP 62
60692: PUSH
60693: LD_EXP 62
60697: PPUSH
60698: LD_VAR 0 2
60702: PUSH
60703: LD_INT 1
60705: PUSH
60706: EMPTY
60707: LIST
60708: LIST
60709: PPUSH
60710: LD_EXP 62
60714: PUSH
60715: LD_VAR 0 2
60719: ARRAY
60720: PUSH
60721: LD_INT 1
60723: ARRAY
60724: PPUSH
60725: LD_INT 3
60727: PUSH
60728: LD_INT 24
60730: PUSH
60731: LD_INT 1000
60733: PUSH
60734: EMPTY
60735: LIST
60736: LIST
60737: PUSH
60738: EMPTY
60739: LIST
60740: LIST
60741: PPUSH
60742: CALL_OW 72
60746: PUSH
60747: LD_VAR 0 6
60751: UNION
60752: PPUSH
60753: CALL 19307 0 3
60757: ST_TO_ADDR
// if not need_heal_2 then
60758: LD_VAR 0 7
60762: NOT
60763: IFFALSE 60796
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60765: LD_ADDR_EXP 62
60769: PUSH
60770: LD_EXP 62
60774: PPUSH
60775: LD_VAR 0 2
60779: PUSH
60780: LD_INT 2
60782: PUSH
60783: EMPTY
60784: LIST
60785: LIST
60786: PPUSH
60787: EMPTY
60788: PPUSH
60789: CALL 19307 0 3
60793: ST_TO_ADDR
60794: GO 60828
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60796: LD_ADDR_EXP 62
60800: PUSH
60801: LD_EXP 62
60805: PPUSH
60806: LD_VAR 0 2
60810: PUSH
60811: LD_INT 2
60813: PUSH
60814: EMPTY
60815: LIST
60816: LIST
60817: PPUSH
60818: LD_VAR 0 7
60822: PPUSH
60823: CALL 19307 0 3
60827: ST_TO_ADDR
// if need_heal_2 then
60828: LD_VAR 0 7
60832: IFFALSE 60993
// for j in need_heal_2 do
60834: LD_ADDR_VAR 0 3
60838: PUSH
60839: LD_VAR 0 7
60843: PUSH
60844: FOR_IN
60845: IFFALSE 60991
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60847: LD_ADDR_VAR 0 5
60851: PUSH
60852: LD_EXP 59
60856: PUSH
60857: LD_VAR 0 2
60861: ARRAY
60862: PPUSH
60863: LD_INT 2
60865: PUSH
60866: LD_INT 30
60868: PUSH
60869: LD_INT 6
60871: PUSH
60872: EMPTY
60873: LIST
60874: LIST
60875: PUSH
60876: LD_INT 30
60878: PUSH
60879: LD_INT 7
60881: PUSH
60882: EMPTY
60883: LIST
60884: LIST
60885: PUSH
60886: LD_INT 30
60888: PUSH
60889: LD_INT 8
60891: PUSH
60892: EMPTY
60893: LIST
60894: LIST
60895: PUSH
60896: LD_INT 30
60898: PUSH
60899: LD_INT 0
60901: PUSH
60902: EMPTY
60903: LIST
60904: LIST
60905: PUSH
60906: LD_INT 30
60908: PUSH
60909: LD_INT 1
60911: PUSH
60912: EMPTY
60913: LIST
60914: LIST
60915: PUSH
60916: EMPTY
60917: LIST
60918: LIST
60919: LIST
60920: LIST
60921: LIST
60922: LIST
60923: PPUSH
60924: CALL_OW 72
60928: ST_TO_ADDR
// if tmp then
60929: LD_VAR 0 5
60933: IFFALSE 60989
// begin k := NearestUnitToUnit ( tmp , j ) ;
60935: LD_ADDR_VAR 0 4
60939: PUSH
60940: LD_VAR 0 5
60944: PPUSH
60945: LD_VAR 0 3
60949: PPUSH
60950: CALL_OW 74
60954: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60955: LD_VAR 0 3
60959: PPUSH
60960: LD_VAR 0 4
60964: PPUSH
60965: CALL_OW 296
60969: PUSH
60970: LD_INT 5
60972: GREATER
60973: IFFALSE 60989
// ComMoveToNearbyEntrance ( j , k ) ;
60975: LD_VAR 0 3
60979: PPUSH
60980: LD_VAR 0 4
60984: PPUSH
60985: CALL 51550 0 2
// end ; end ;
60989: GO 60844
60991: POP
60992: POP
// if not need_heal_1 and not need_heal_2 then
60993: LD_VAR 0 6
60997: NOT
60998: PUSH
60999: LD_VAR 0 7
61003: NOT
61004: AND
61005: IFFALSE 61009
// continue ;
61007: GO 60473
// end ;
61009: GO 60473
61011: POP
61012: POP
// RaiseSailEvent ( 102 ) ;
61013: LD_INT 102
61015: PPUSH
61016: CALL_OW 427
// end ;
61020: LD_VAR 0 1
61024: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
61025: LD_INT 0
61027: PPUSH
61028: PPUSH
61029: PPUSH
61030: PPUSH
61031: PPUSH
61032: PPUSH
61033: PPUSH
61034: PPUSH
// if not mc_bases then
61035: LD_EXP 59
61039: NOT
61040: IFFALSE 61044
// exit ;
61042: GO 61905
// for i = 1 to mc_bases do
61044: LD_ADDR_VAR 0 2
61048: PUSH
61049: DOUBLE
61050: LD_INT 1
61052: DEC
61053: ST_TO_ADDR
61054: LD_EXP 59
61058: PUSH
61059: FOR_TO
61060: IFFALSE 61903
// begin if not mc_building_need_repair [ i ] then
61062: LD_EXP 60
61066: PUSH
61067: LD_VAR 0 2
61071: ARRAY
61072: NOT
61073: IFFALSE 61260
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
61075: LD_ADDR_VAR 0 6
61079: PUSH
61080: LD_EXP 78
61084: PUSH
61085: LD_VAR 0 2
61089: ARRAY
61090: PPUSH
61091: LD_INT 3
61093: PUSH
61094: LD_INT 24
61096: PUSH
61097: LD_INT 1000
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PUSH
61108: LD_INT 2
61110: PUSH
61111: LD_INT 34
61113: PUSH
61114: LD_INT 13
61116: PUSH
61117: EMPTY
61118: LIST
61119: LIST
61120: PUSH
61121: LD_INT 34
61123: PUSH
61124: LD_INT 52
61126: PUSH
61127: EMPTY
61128: LIST
61129: LIST
61130: PUSH
61131: LD_INT 34
61133: PUSH
61134: LD_EXP 109
61138: PUSH
61139: EMPTY
61140: LIST
61141: LIST
61142: PUSH
61143: EMPTY
61144: LIST
61145: LIST
61146: LIST
61147: LIST
61148: PUSH
61149: EMPTY
61150: LIST
61151: LIST
61152: PPUSH
61153: CALL_OW 72
61157: ST_TO_ADDR
// if cranes then
61158: LD_VAR 0 6
61162: IFFALSE 61224
// for j in cranes do
61164: LD_ADDR_VAR 0 3
61168: PUSH
61169: LD_VAR 0 6
61173: PUSH
61174: FOR_IN
61175: IFFALSE 61222
// if not IsInArea ( j , mc_parking [ i ] ) then
61177: LD_VAR 0 3
61181: PPUSH
61182: LD_EXP 83
61186: PUSH
61187: LD_VAR 0 2
61191: ARRAY
61192: PPUSH
61193: CALL_OW 308
61197: NOT
61198: IFFALSE 61220
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61200: LD_VAR 0 3
61204: PPUSH
61205: LD_EXP 83
61209: PUSH
61210: LD_VAR 0 2
61214: ARRAY
61215: PPUSH
61216: CALL_OW 113
61220: GO 61174
61222: POP
61223: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
61224: LD_ADDR_EXP 61
61228: PUSH
61229: LD_EXP 61
61233: PPUSH
61234: LD_VAR 0 2
61238: PPUSH
61239: EMPTY
61240: PPUSH
61241: CALL_OW 1
61245: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
61246: LD_VAR 0 2
61250: PPUSH
61251: LD_INT 101
61253: PPUSH
61254: CALL 56148 0 2
// continue ;
61258: GO 61059
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
61260: LD_ADDR_EXP 65
61264: PUSH
61265: LD_EXP 65
61269: PPUSH
61270: LD_VAR 0 2
61274: PPUSH
61275: EMPTY
61276: PPUSH
61277: CALL_OW 1
61281: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61282: LD_VAR 0 2
61286: PPUSH
61287: LD_INT 103
61289: PPUSH
61290: CALL 56148 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
61294: LD_ADDR_VAR 0 5
61298: PUSH
61299: LD_EXP 59
61303: PUSH
61304: LD_VAR 0 2
61308: ARRAY
61309: PUSH
61310: LD_EXP 88
61314: PUSH
61315: LD_VAR 0 2
61319: ARRAY
61320: UNION
61321: PPUSH
61322: LD_INT 2
61324: PUSH
61325: LD_INT 25
61327: PUSH
61328: LD_INT 2
61330: PUSH
61331: EMPTY
61332: LIST
61333: LIST
61334: PUSH
61335: LD_INT 25
61337: PUSH
61338: LD_INT 16
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: LIST
61349: PUSH
61350: EMPTY
61351: LIST
61352: PPUSH
61353: CALL_OW 72
61357: PUSH
61358: LD_EXP 62
61362: PUSH
61363: LD_VAR 0 2
61367: ARRAY
61368: PUSH
61369: LD_INT 1
61371: ARRAY
61372: PUSH
61373: LD_EXP 62
61377: PUSH
61378: LD_VAR 0 2
61382: ARRAY
61383: PUSH
61384: LD_INT 2
61386: ARRAY
61387: UNION
61388: DIFF
61389: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
61390: LD_ADDR_VAR 0 6
61394: PUSH
61395: LD_EXP 78
61399: PUSH
61400: LD_VAR 0 2
61404: ARRAY
61405: PPUSH
61406: LD_INT 2
61408: PUSH
61409: LD_INT 34
61411: PUSH
61412: LD_INT 13
61414: PUSH
61415: EMPTY
61416: LIST
61417: LIST
61418: PUSH
61419: LD_INT 34
61421: PUSH
61422: LD_INT 52
61424: PUSH
61425: EMPTY
61426: LIST
61427: LIST
61428: PUSH
61429: LD_INT 34
61431: PUSH
61432: LD_EXP 109
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: LIST
61445: LIST
61446: PPUSH
61447: CALL_OW 72
61451: ST_TO_ADDR
// if cranes then
61452: LD_VAR 0 6
61456: IFFALSE 61592
// begin for j in cranes do
61458: LD_ADDR_VAR 0 3
61462: PUSH
61463: LD_VAR 0 6
61467: PUSH
61468: FOR_IN
61469: IFFALSE 61590
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
61471: LD_VAR 0 3
61475: PPUSH
61476: CALL_OW 256
61480: PUSH
61481: LD_INT 1000
61483: EQUAL
61484: PUSH
61485: LD_VAR 0 3
61489: PPUSH
61490: CALL_OW 314
61494: NOT
61495: AND
61496: IFFALSE 61530
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
61498: LD_VAR 0 3
61502: PPUSH
61503: LD_EXP 60
61507: PUSH
61508: LD_VAR 0 2
61512: ARRAY
61513: PPUSH
61514: LD_VAR 0 3
61518: PPUSH
61519: CALL_OW 74
61523: PPUSH
61524: CALL_OW 130
61528: GO 61588
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
61530: LD_VAR 0 3
61534: PPUSH
61535: CALL_OW 256
61539: PUSH
61540: LD_INT 500
61542: LESS
61543: PUSH
61544: LD_VAR 0 3
61548: PPUSH
61549: LD_EXP 83
61553: PUSH
61554: LD_VAR 0 2
61558: ARRAY
61559: PPUSH
61560: CALL_OW 308
61564: NOT
61565: AND
61566: IFFALSE 61588
// ComMoveToArea ( j , mc_parking [ i ] ) ;
61568: LD_VAR 0 3
61572: PPUSH
61573: LD_EXP 83
61577: PUSH
61578: LD_VAR 0 2
61582: ARRAY
61583: PPUSH
61584: CALL_OW 113
// end ;
61588: GO 61468
61590: POP
61591: POP
// end ; if tmp > 3 then
61592: LD_VAR 0 5
61596: PUSH
61597: LD_INT 3
61599: GREATER
61600: IFFALSE 61620
// tmp := ShrinkArray ( tmp , 4 ) ;
61602: LD_ADDR_VAR 0 5
61606: PUSH
61607: LD_VAR 0 5
61611: PPUSH
61612: LD_INT 4
61614: PPUSH
61615: CALL 50998 0 2
61619: ST_TO_ADDR
// if not tmp then
61620: LD_VAR 0 5
61624: NOT
61625: IFFALSE 61629
// continue ;
61627: GO 61059
// for j in tmp do
61629: LD_ADDR_VAR 0 3
61633: PUSH
61634: LD_VAR 0 5
61638: PUSH
61639: FOR_IN
61640: IFFALSE 61899
// begin if IsInUnit ( j ) then
61642: LD_VAR 0 3
61646: PPUSH
61647: CALL_OW 310
61651: IFFALSE 61662
// ComExitBuilding ( j ) ;
61653: LD_VAR 0 3
61657: PPUSH
61658: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
61662: LD_VAR 0 3
61666: PUSH
61667: LD_EXP 61
61671: PUSH
61672: LD_VAR 0 2
61676: ARRAY
61677: IN
61678: NOT
61679: IFFALSE 61737
// begin SetTag ( j , 101 ) ;
61681: LD_VAR 0 3
61685: PPUSH
61686: LD_INT 101
61688: PPUSH
61689: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61693: LD_ADDR_EXP 61
61697: PUSH
61698: LD_EXP 61
61702: PPUSH
61703: LD_VAR 0 2
61707: PUSH
61708: LD_EXP 61
61712: PUSH
61713: LD_VAR 0 2
61717: ARRAY
61718: PUSH
61719: LD_INT 1
61721: PLUS
61722: PUSH
61723: EMPTY
61724: LIST
61725: LIST
61726: PPUSH
61727: LD_VAR 0 3
61731: PPUSH
61732: CALL 19307 0 3
61736: ST_TO_ADDR
// end ; wait ( 1 ) ;
61737: LD_INT 1
61739: PPUSH
61740: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61744: LD_ADDR_VAR 0 7
61748: PUSH
61749: LD_EXP 60
61753: PUSH
61754: LD_VAR 0 2
61758: ARRAY
61759: ST_TO_ADDR
// if mc_scan [ i ] then
61760: LD_EXP 82
61764: PUSH
61765: LD_VAR 0 2
61769: ARRAY
61770: IFFALSE 61832
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61772: LD_ADDR_VAR 0 7
61776: PUSH
61777: LD_EXP 60
61781: PUSH
61782: LD_VAR 0 2
61786: ARRAY
61787: PPUSH
61788: LD_INT 3
61790: PUSH
61791: LD_INT 30
61793: PUSH
61794: LD_INT 32
61796: PUSH
61797: EMPTY
61798: LIST
61799: LIST
61800: PUSH
61801: LD_INT 30
61803: PUSH
61804: LD_INT 33
61806: PUSH
61807: EMPTY
61808: LIST
61809: LIST
61810: PUSH
61811: LD_INT 30
61813: PUSH
61814: LD_INT 31
61816: PUSH
61817: EMPTY
61818: LIST
61819: LIST
61820: PUSH
61821: EMPTY
61822: LIST
61823: LIST
61824: LIST
61825: LIST
61826: PPUSH
61827: CALL_OW 72
61831: ST_TO_ADDR
// if not to_repair_tmp then
61832: LD_VAR 0 7
61836: NOT
61837: IFFALSE 61841
// continue ;
61839: GO 61639
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61841: LD_ADDR_VAR 0 8
61845: PUSH
61846: LD_VAR 0 7
61850: PPUSH
61851: LD_VAR 0 3
61855: PPUSH
61856: CALL_OW 74
61860: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61861: LD_VAR 0 8
61865: PPUSH
61866: LD_INT 16
61868: PPUSH
61869: CALL 21900 0 2
61873: PUSH
61874: LD_INT 4
61876: ARRAY
61877: PUSH
61878: LD_INT 10
61880: LESS
61881: IFFALSE 61897
// ComRepairBuilding ( j , to_repair ) ;
61883: LD_VAR 0 3
61887: PPUSH
61888: LD_VAR 0 8
61892: PPUSH
61893: CALL_OW 130
// end ;
61897: GO 61639
61899: POP
61900: POP
// end ;
61901: GO 61059
61903: POP
61904: POP
// end ;
61905: LD_VAR 0 1
61909: RET
// export function MC_Heal ; var i , j , tmp ; begin
61910: LD_INT 0
61912: PPUSH
61913: PPUSH
61914: PPUSH
61915: PPUSH
// if not mc_bases then
61916: LD_EXP 59
61920: NOT
61921: IFFALSE 61925
// exit ;
61923: GO 62327
// for i = 1 to mc_bases do
61925: LD_ADDR_VAR 0 2
61929: PUSH
61930: DOUBLE
61931: LD_INT 1
61933: DEC
61934: ST_TO_ADDR
61935: LD_EXP 59
61939: PUSH
61940: FOR_TO
61941: IFFALSE 62325
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61943: LD_EXP 62
61947: PUSH
61948: LD_VAR 0 2
61952: ARRAY
61953: PUSH
61954: LD_INT 1
61956: ARRAY
61957: NOT
61958: PUSH
61959: LD_EXP 62
61963: PUSH
61964: LD_VAR 0 2
61968: ARRAY
61969: PUSH
61970: LD_INT 2
61972: ARRAY
61973: NOT
61974: AND
61975: IFFALSE 62013
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61977: LD_ADDR_EXP 63
61981: PUSH
61982: LD_EXP 63
61986: PPUSH
61987: LD_VAR 0 2
61991: PPUSH
61992: EMPTY
61993: PPUSH
61994: CALL_OW 1
61998: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61999: LD_VAR 0 2
62003: PPUSH
62004: LD_INT 102
62006: PPUSH
62007: CALL 56148 0 2
// continue ;
62011: GO 61940
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
62013: LD_ADDR_VAR 0 4
62017: PUSH
62018: LD_EXP 59
62022: PUSH
62023: LD_VAR 0 2
62027: ARRAY
62028: PPUSH
62029: LD_INT 25
62031: PUSH
62032: LD_INT 4
62034: PUSH
62035: EMPTY
62036: LIST
62037: LIST
62038: PPUSH
62039: CALL_OW 72
62043: ST_TO_ADDR
// if not tmp then
62044: LD_VAR 0 4
62048: NOT
62049: IFFALSE 62053
// continue ;
62051: GO 61940
// if mc_taming [ i ] then
62053: LD_EXP 90
62057: PUSH
62058: LD_VAR 0 2
62062: ARRAY
62063: IFFALSE 62087
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
62065: LD_ADDR_EXP 90
62069: PUSH
62070: LD_EXP 90
62074: PPUSH
62075: LD_VAR 0 2
62079: PPUSH
62080: EMPTY
62081: PPUSH
62082: CALL_OW 1
62086: ST_TO_ADDR
// for j in tmp do
62087: LD_ADDR_VAR 0 3
62091: PUSH
62092: LD_VAR 0 4
62096: PUSH
62097: FOR_IN
62098: IFFALSE 62321
// begin if IsInUnit ( j ) then
62100: LD_VAR 0 3
62104: PPUSH
62105: CALL_OW 310
62109: IFFALSE 62120
// ComExitBuilding ( j ) ;
62111: LD_VAR 0 3
62115: PPUSH
62116: CALL_OW 122
// if not j in mc_healers [ i ] then
62120: LD_VAR 0 3
62124: PUSH
62125: LD_EXP 63
62129: PUSH
62130: LD_VAR 0 2
62134: ARRAY
62135: IN
62136: NOT
62137: IFFALSE 62183
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
62139: LD_ADDR_EXP 63
62143: PUSH
62144: LD_EXP 63
62148: PPUSH
62149: LD_VAR 0 2
62153: PUSH
62154: LD_EXP 63
62158: PUSH
62159: LD_VAR 0 2
62163: ARRAY
62164: PUSH
62165: LD_INT 1
62167: PLUS
62168: PUSH
62169: EMPTY
62170: LIST
62171: LIST
62172: PPUSH
62173: LD_VAR 0 3
62177: PPUSH
62178: CALL 19307 0 3
62182: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
62183: LD_VAR 0 3
62187: PPUSH
62188: CALL_OW 110
62192: PUSH
62193: LD_INT 102
62195: NONEQUAL
62196: IFFALSE 62210
// SetTag ( j , 102 ) ;
62198: LD_VAR 0 3
62202: PPUSH
62203: LD_INT 102
62205: PPUSH
62206: CALL_OW 109
// Wait ( 3 ) ;
62210: LD_INT 3
62212: PPUSH
62213: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
62217: LD_EXP 62
62221: PUSH
62222: LD_VAR 0 2
62226: ARRAY
62227: PUSH
62228: LD_INT 1
62230: ARRAY
62231: IFFALSE 62263
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
62233: LD_VAR 0 3
62237: PPUSH
62238: LD_EXP 62
62242: PUSH
62243: LD_VAR 0 2
62247: ARRAY
62248: PUSH
62249: LD_INT 1
62251: ARRAY
62252: PUSH
62253: LD_INT 1
62255: ARRAY
62256: PPUSH
62257: CALL_OW 128
62261: GO 62319
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
62263: LD_VAR 0 3
62267: PPUSH
62268: CALL_OW 314
62272: NOT
62273: PUSH
62274: LD_EXP 62
62278: PUSH
62279: LD_VAR 0 2
62283: ARRAY
62284: PUSH
62285: LD_INT 2
62287: ARRAY
62288: AND
62289: IFFALSE 62319
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
62291: LD_VAR 0 3
62295: PPUSH
62296: LD_EXP 62
62300: PUSH
62301: LD_VAR 0 2
62305: ARRAY
62306: PUSH
62307: LD_INT 2
62309: ARRAY
62310: PUSH
62311: LD_INT 1
62313: ARRAY
62314: PPUSH
62315: CALL_OW 128
// end ;
62319: GO 62097
62321: POP
62322: POP
// end ;
62323: GO 61940
62325: POP
62326: POP
// end ;
62327: LD_VAR 0 1
62331: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
62332: LD_INT 0
62334: PPUSH
62335: PPUSH
62336: PPUSH
62337: PPUSH
62338: PPUSH
// if not mc_bases then
62339: LD_EXP 59
62343: NOT
62344: IFFALSE 62348
// exit ;
62346: GO 63519
// for i = 1 to mc_bases do
62348: LD_ADDR_VAR 0 2
62352: PUSH
62353: DOUBLE
62354: LD_INT 1
62356: DEC
62357: ST_TO_ADDR
62358: LD_EXP 59
62362: PUSH
62363: FOR_TO
62364: IFFALSE 63517
// begin if mc_scan [ i ] then
62366: LD_EXP 82
62370: PUSH
62371: LD_VAR 0 2
62375: ARRAY
62376: IFFALSE 62380
// continue ;
62378: GO 62363
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
62380: LD_EXP 64
62384: PUSH
62385: LD_VAR 0 2
62389: ARRAY
62390: NOT
62391: PUSH
62392: LD_EXP 66
62396: PUSH
62397: LD_VAR 0 2
62401: ARRAY
62402: NOT
62403: AND
62404: PUSH
62405: LD_EXP 65
62409: PUSH
62410: LD_VAR 0 2
62414: ARRAY
62415: AND
62416: IFFALSE 62454
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
62418: LD_ADDR_EXP 65
62422: PUSH
62423: LD_EXP 65
62427: PPUSH
62428: LD_VAR 0 2
62432: PPUSH
62433: EMPTY
62434: PPUSH
62435: CALL_OW 1
62439: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
62440: LD_VAR 0 2
62444: PPUSH
62445: LD_INT 103
62447: PPUSH
62448: CALL 56148 0 2
// continue ;
62452: GO 62363
// end ; if mc_construct_list [ i ] then
62454: LD_EXP 66
62458: PUSH
62459: LD_VAR 0 2
62463: ARRAY
62464: IFFALSE 62684
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62466: LD_ADDR_VAR 0 4
62470: PUSH
62471: LD_EXP 59
62475: PUSH
62476: LD_VAR 0 2
62480: ARRAY
62481: PPUSH
62482: LD_INT 25
62484: PUSH
62485: LD_INT 2
62487: PUSH
62488: EMPTY
62489: LIST
62490: LIST
62491: PPUSH
62492: CALL_OW 72
62496: PUSH
62497: LD_EXP 61
62501: PUSH
62502: LD_VAR 0 2
62506: ARRAY
62507: DIFF
62508: ST_TO_ADDR
// if not tmp then
62509: LD_VAR 0 4
62513: NOT
62514: IFFALSE 62518
// continue ;
62516: GO 62363
// for j in tmp do
62518: LD_ADDR_VAR 0 3
62522: PUSH
62523: LD_VAR 0 4
62527: PUSH
62528: FOR_IN
62529: IFFALSE 62680
// begin if not mc_builders [ i ] then
62531: LD_EXP 65
62535: PUSH
62536: LD_VAR 0 2
62540: ARRAY
62541: NOT
62542: IFFALSE 62600
// begin SetTag ( j , 103 ) ;
62544: LD_VAR 0 3
62548: PPUSH
62549: LD_INT 103
62551: PPUSH
62552: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62556: LD_ADDR_EXP 65
62560: PUSH
62561: LD_EXP 65
62565: PPUSH
62566: LD_VAR 0 2
62570: PUSH
62571: LD_EXP 65
62575: PUSH
62576: LD_VAR 0 2
62580: ARRAY
62581: PUSH
62582: LD_INT 1
62584: PLUS
62585: PUSH
62586: EMPTY
62587: LIST
62588: LIST
62589: PPUSH
62590: LD_VAR 0 3
62594: PPUSH
62595: CALL 19307 0 3
62599: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62600: LD_VAR 0 3
62604: PPUSH
62605: CALL_OW 310
62609: IFFALSE 62620
// ComExitBuilding ( j ) ;
62611: LD_VAR 0 3
62615: PPUSH
62616: CALL_OW 122
// wait ( 3 ) ;
62620: LD_INT 3
62622: PPUSH
62623: CALL_OW 67
// if not mc_construct_list [ i ] then
62627: LD_EXP 66
62631: PUSH
62632: LD_VAR 0 2
62636: ARRAY
62637: NOT
62638: IFFALSE 62642
// break ;
62640: GO 62680
// if not HasTask ( j ) then
62642: LD_VAR 0 3
62646: PPUSH
62647: CALL_OW 314
62651: NOT
62652: IFFALSE 62678
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
62654: LD_VAR 0 3
62658: PPUSH
62659: LD_EXP 66
62663: PUSH
62664: LD_VAR 0 2
62668: ARRAY
62669: PUSH
62670: LD_INT 1
62672: ARRAY
62673: PPUSH
62674: CALL 22164 0 2
// end ;
62678: GO 62528
62680: POP
62681: POP
// end else
62682: GO 63515
// if mc_build_list [ i ] then
62684: LD_EXP 64
62688: PUSH
62689: LD_VAR 0 2
62693: ARRAY
62694: IFFALSE 63515
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62696: LD_ADDR_VAR 0 5
62700: PUSH
62701: LD_EXP 59
62705: PUSH
62706: LD_VAR 0 2
62710: ARRAY
62711: PPUSH
62712: LD_INT 2
62714: PUSH
62715: LD_INT 30
62717: PUSH
62718: LD_INT 0
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: PUSH
62725: LD_INT 30
62727: PUSH
62728: LD_INT 1
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PUSH
62735: EMPTY
62736: LIST
62737: LIST
62738: LIST
62739: PPUSH
62740: CALL_OW 72
62744: ST_TO_ADDR
// if depot then
62745: LD_VAR 0 5
62749: IFFALSE 62767
// depot := depot [ 1 ] else
62751: LD_ADDR_VAR 0 5
62755: PUSH
62756: LD_VAR 0 5
62760: PUSH
62761: LD_INT 1
62763: ARRAY
62764: ST_TO_ADDR
62765: GO 62775
// depot := 0 ;
62767: LD_ADDR_VAR 0 5
62771: PUSH
62772: LD_INT 0
62774: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62775: LD_EXP 64
62779: PUSH
62780: LD_VAR 0 2
62784: ARRAY
62785: PUSH
62786: LD_INT 1
62788: ARRAY
62789: PUSH
62790: LD_INT 1
62792: ARRAY
62793: PPUSH
62794: CALL 21988 0 1
62798: PUSH
62799: LD_EXP 59
62803: PUSH
62804: LD_VAR 0 2
62808: ARRAY
62809: PPUSH
62810: LD_INT 2
62812: PUSH
62813: LD_INT 30
62815: PUSH
62816: LD_INT 2
62818: PUSH
62819: EMPTY
62820: LIST
62821: LIST
62822: PUSH
62823: LD_INT 30
62825: PUSH
62826: LD_INT 3
62828: PUSH
62829: EMPTY
62830: LIST
62831: LIST
62832: PUSH
62833: EMPTY
62834: LIST
62835: LIST
62836: LIST
62837: PPUSH
62838: CALL_OW 72
62842: NOT
62843: AND
62844: IFFALSE 62949
// begin for j = 1 to mc_build_list [ i ] do
62846: LD_ADDR_VAR 0 3
62850: PUSH
62851: DOUBLE
62852: LD_INT 1
62854: DEC
62855: ST_TO_ADDR
62856: LD_EXP 64
62860: PUSH
62861: LD_VAR 0 2
62865: ARRAY
62866: PUSH
62867: FOR_TO
62868: IFFALSE 62947
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62870: LD_EXP 64
62874: PUSH
62875: LD_VAR 0 2
62879: ARRAY
62880: PUSH
62881: LD_VAR 0 3
62885: ARRAY
62886: PUSH
62887: LD_INT 1
62889: ARRAY
62890: PUSH
62891: LD_INT 2
62893: EQUAL
62894: IFFALSE 62945
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62896: LD_ADDR_EXP 64
62900: PUSH
62901: LD_EXP 64
62905: PPUSH
62906: LD_VAR 0 2
62910: PPUSH
62911: LD_EXP 64
62915: PUSH
62916: LD_VAR 0 2
62920: ARRAY
62921: PPUSH
62922: LD_VAR 0 3
62926: PPUSH
62927: LD_INT 1
62929: PPUSH
62930: LD_INT 0
62932: PPUSH
62933: CALL 18725 0 4
62937: PPUSH
62938: CALL_OW 1
62942: ST_TO_ADDR
// break ;
62943: GO 62947
// end ;
62945: GO 62867
62947: POP
62948: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62949: LD_EXP 64
62953: PUSH
62954: LD_VAR 0 2
62958: ARRAY
62959: PUSH
62960: LD_INT 1
62962: ARRAY
62963: PUSH
62964: LD_INT 1
62966: ARRAY
62967: PUSH
62968: LD_INT 0
62970: EQUAL
62971: PUSH
62972: LD_VAR 0 5
62976: PUSH
62977: LD_VAR 0 5
62981: PPUSH
62982: LD_EXP 64
62986: PUSH
62987: LD_VAR 0 2
62991: ARRAY
62992: PUSH
62993: LD_INT 1
62995: ARRAY
62996: PUSH
62997: LD_INT 1
62999: ARRAY
63000: PPUSH
63001: LD_EXP 64
63005: PUSH
63006: LD_VAR 0 2
63010: ARRAY
63011: PUSH
63012: LD_INT 1
63014: ARRAY
63015: PUSH
63016: LD_INT 2
63018: ARRAY
63019: PPUSH
63020: LD_EXP 64
63024: PUSH
63025: LD_VAR 0 2
63029: ARRAY
63030: PUSH
63031: LD_INT 1
63033: ARRAY
63034: PUSH
63035: LD_INT 3
63037: ARRAY
63038: PPUSH
63039: LD_EXP 64
63043: PUSH
63044: LD_VAR 0 2
63048: ARRAY
63049: PUSH
63050: LD_INT 1
63052: ARRAY
63053: PUSH
63054: LD_INT 4
63056: ARRAY
63057: PPUSH
63058: CALL 27055 0 5
63062: AND
63063: OR
63064: IFFALSE 63345
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
63066: LD_ADDR_VAR 0 4
63070: PUSH
63071: LD_EXP 59
63075: PUSH
63076: LD_VAR 0 2
63080: ARRAY
63081: PPUSH
63082: LD_INT 25
63084: PUSH
63085: LD_INT 2
63087: PUSH
63088: EMPTY
63089: LIST
63090: LIST
63091: PPUSH
63092: CALL_OW 72
63096: PUSH
63097: LD_EXP 61
63101: PUSH
63102: LD_VAR 0 2
63106: ARRAY
63107: DIFF
63108: ST_TO_ADDR
// if not tmp then
63109: LD_VAR 0 4
63113: NOT
63114: IFFALSE 63118
// continue ;
63116: GO 62363
// for j in tmp do
63118: LD_ADDR_VAR 0 3
63122: PUSH
63123: LD_VAR 0 4
63127: PUSH
63128: FOR_IN
63129: IFFALSE 63341
// begin if not mc_builders [ i ] then
63131: LD_EXP 65
63135: PUSH
63136: LD_VAR 0 2
63140: ARRAY
63141: NOT
63142: IFFALSE 63200
// begin SetTag ( j , 103 ) ;
63144: LD_VAR 0 3
63148: PPUSH
63149: LD_INT 103
63151: PPUSH
63152: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
63156: LD_ADDR_EXP 65
63160: PUSH
63161: LD_EXP 65
63165: PPUSH
63166: LD_VAR 0 2
63170: PUSH
63171: LD_EXP 65
63175: PUSH
63176: LD_VAR 0 2
63180: ARRAY
63181: PUSH
63182: LD_INT 1
63184: PLUS
63185: PUSH
63186: EMPTY
63187: LIST
63188: LIST
63189: PPUSH
63190: LD_VAR 0 3
63194: PPUSH
63195: CALL 19307 0 3
63199: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
63200: LD_VAR 0 3
63204: PPUSH
63205: CALL_OW 310
63209: IFFALSE 63220
// ComExitBuilding ( j ) ;
63211: LD_VAR 0 3
63215: PPUSH
63216: CALL_OW 122
// wait ( 3 ) ;
63220: LD_INT 3
63222: PPUSH
63223: CALL_OW 67
// if not mc_build_list [ i ] then
63227: LD_EXP 64
63231: PUSH
63232: LD_VAR 0 2
63236: ARRAY
63237: NOT
63238: IFFALSE 63242
// break ;
63240: GO 63341
// if not HasTask ( j ) then
63242: LD_VAR 0 3
63246: PPUSH
63247: CALL_OW 314
63251: NOT
63252: IFFALSE 63339
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
63254: LD_VAR 0 3
63258: PPUSH
63259: LD_EXP 64
63263: PUSH
63264: LD_VAR 0 2
63268: ARRAY
63269: PUSH
63270: LD_INT 1
63272: ARRAY
63273: PUSH
63274: LD_INT 1
63276: ARRAY
63277: PPUSH
63278: LD_EXP 64
63282: PUSH
63283: LD_VAR 0 2
63287: ARRAY
63288: PUSH
63289: LD_INT 1
63291: ARRAY
63292: PUSH
63293: LD_INT 2
63295: ARRAY
63296: PPUSH
63297: LD_EXP 64
63301: PUSH
63302: LD_VAR 0 2
63306: ARRAY
63307: PUSH
63308: LD_INT 1
63310: ARRAY
63311: PUSH
63312: LD_INT 3
63314: ARRAY
63315: PPUSH
63316: LD_EXP 64
63320: PUSH
63321: LD_VAR 0 2
63325: ARRAY
63326: PUSH
63327: LD_INT 1
63329: ARRAY
63330: PUSH
63331: LD_INT 4
63333: ARRAY
63334: PPUSH
63335: CALL_OW 145
// end ;
63339: GO 63128
63341: POP
63342: POP
// end else
63343: GO 63515
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
63345: LD_EXP 59
63349: PUSH
63350: LD_VAR 0 2
63354: ARRAY
63355: PPUSH
63356: LD_EXP 64
63360: PUSH
63361: LD_VAR 0 2
63365: ARRAY
63366: PUSH
63367: LD_INT 1
63369: ARRAY
63370: PUSH
63371: LD_INT 1
63373: ARRAY
63374: PPUSH
63375: LD_EXP 64
63379: PUSH
63380: LD_VAR 0 2
63384: ARRAY
63385: PUSH
63386: LD_INT 1
63388: ARRAY
63389: PUSH
63390: LD_INT 2
63392: ARRAY
63393: PPUSH
63394: LD_EXP 64
63398: PUSH
63399: LD_VAR 0 2
63403: ARRAY
63404: PUSH
63405: LD_INT 1
63407: ARRAY
63408: PUSH
63409: LD_INT 3
63411: ARRAY
63412: PPUSH
63413: LD_EXP 64
63417: PUSH
63418: LD_VAR 0 2
63422: ARRAY
63423: PUSH
63424: LD_INT 1
63426: ARRAY
63427: PUSH
63428: LD_INT 4
63430: ARRAY
63431: PPUSH
63432: LD_EXP 59
63436: PUSH
63437: LD_VAR 0 2
63441: ARRAY
63442: PPUSH
63443: LD_INT 21
63445: PUSH
63446: LD_INT 3
63448: PUSH
63449: EMPTY
63450: LIST
63451: LIST
63452: PPUSH
63453: CALL_OW 72
63457: PPUSH
63458: EMPTY
63459: PPUSH
63460: CALL 26185 0 7
63464: NOT
63465: IFFALSE 63515
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
63467: LD_ADDR_EXP 64
63471: PUSH
63472: LD_EXP 64
63476: PPUSH
63477: LD_VAR 0 2
63481: PPUSH
63482: LD_EXP 64
63486: PUSH
63487: LD_VAR 0 2
63491: ARRAY
63492: PPUSH
63493: LD_INT 1
63495: PPUSH
63496: LD_INT 1
63498: NEG
63499: PPUSH
63500: LD_INT 0
63502: PPUSH
63503: CALL 18725 0 4
63507: PPUSH
63508: CALL_OW 1
63512: ST_TO_ADDR
// continue ;
63513: GO 62363
// end ; end ; end ;
63515: GO 62363
63517: POP
63518: POP
// end ;
63519: LD_VAR 0 1
63523: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
63524: LD_INT 0
63526: PPUSH
63527: PPUSH
63528: PPUSH
63529: PPUSH
63530: PPUSH
63531: PPUSH
// if not mc_bases then
63532: LD_EXP 59
63536: NOT
63537: IFFALSE 63541
// exit ;
63539: GO 63968
// for i = 1 to mc_bases do
63541: LD_ADDR_VAR 0 2
63545: PUSH
63546: DOUBLE
63547: LD_INT 1
63549: DEC
63550: ST_TO_ADDR
63551: LD_EXP 59
63555: PUSH
63556: FOR_TO
63557: IFFALSE 63966
// begin tmp := mc_build_upgrade [ i ] ;
63559: LD_ADDR_VAR 0 4
63563: PUSH
63564: LD_EXP 91
63568: PUSH
63569: LD_VAR 0 2
63573: ARRAY
63574: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
63575: LD_ADDR_VAR 0 6
63579: PUSH
63580: LD_EXP 92
63584: PUSH
63585: LD_VAR 0 2
63589: ARRAY
63590: PPUSH
63591: LD_INT 2
63593: PUSH
63594: LD_INT 30
63596: PUSH
63597: LD_INT 6
63599: PUSH
63600: EMPTY
63601: LIST
63602: LIST
63603: PUSH
63604: LD_INT 30
63606: PUSH
63607: LD_INT 7
63609: PUSH
63610: EMPTY
63611: LIST
63612: LIST
63613: PUSH
63614: EMPTY
63615: LIST
63616: LIST
63617: LIST
63618: PPUSH
63619: CALL_OW 72
63623: ST_TO_ADDR
// if not tmp and not lab then
63624: LD_VAR 0 4
63628: NOT
63629: PUSH
63630: LD_VAR 0 6
63634: NOT
63635: AND
63636: IFFALSE 63640
// continue ;
63638: GO 63556
// if tmp then
63640: LD_VAR 0 4
63644: IFFALSE 63764
// for j in tmp do
63646: LD_ADDR_VAR 0 3
63650: PUSH
63651: LD_VAR 0 4
63655: PUSH
63656: FOR_IN
63657: IFFALSE 63762
// begin if UpgradeCost ( j ) then
63659: LD_VAR 0 3
63663: PPUSH
63664: CALL 25845 0 1
63668: IFFALSE 63760
// begin ComUpgrade ( j ) ;
63670: LD_VAR 0 3
63674: PPUSH
63675: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
63679: LD_ADDR_EXP 91
63683: PUSH
63684: LD_EXP 91
63688: PPUSH
63689: LD_VAR 0 2
63693: PPUSH
63694: LD_EXP 91
63698: PUSH
63699: LD_VAR 0 2
63703: ARRAY
63704: PUSH
63705: LD_VAR 0 3
63709: DIFF
63710: PPUSH
63711: CALL_OW 1
63715: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63716: LD_ADDR_EXP 66
63720: PUSH
63721: LD_EXP 66
63725: PPUSH
63726: LD_VAR 0 2
63730: PUSH
63731: LD_EXP 66
63735: PUSH
63736: LD_VAR 0 2
63740: ARRAY
63741: PUSH
63742: LD_INT 1
63744: PLUS
63745: PUSH
63746: EMPTY
63747: LIST
63748: LIST
63749: PPUSH
63750: LD_VAR 0 3
63754: PPUSH
63755: CALL 19307 0 3
63759: ST_TO_ADDR
// end ; end ;
63760: GO 63656
63762: POP
63763: POP
// if not lab or not mc_lab_upgrade [ i ] then
63764: LD_VAR 0 6
63768: NOT
63769: PUSH
63770: LD_EXP 93
63774: PUSH
63775: LD_VAR 0 2
63779: ARRAY
63780: NOT
63781: OR
63782: IFFALSE 63786
// continue ;
63784: GO 63556
// for j in lab do
63786: LD_ADDR_VAR 0 3
63790: PUSH
63791: LD_VAR 0 6
63795: PUSH
63796: FOR_IN
63797: IFFALSE 63962
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63799: LD_VAR 0 3
63803: PPUSH
63804: CALL_OW 266
63808: PUSH
63809: LD_INT 6
63811: PUSH
63812: LD_INT 7
63814: PUSH
63815: EMPTY
63816: LIST
63817: LIST
63818: IN
63819: PUSH
63820: LD_VAR 0 3
63824: PPUSH
63825: CALL_OW 461
63829: PUSH
63830: LD_INT 1
63832: NONEQUAL
63833: AND
63834: IFFALSE 63960
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63836: LD_VAR 0 3
63840: PPUSH
63841: LD_EXP 93
63845: PUSH
63846: LD_VAR 0 2
63850: ARRAY
63851: PUSH
63852: LD_INT 1
63854: ARRAY
63855: PPUSH
63856: CALL 26050 0 2
63860: IFFALSE 63960
// begin ComCancel ( j ) ;
63862: LD_VAR 0 3
63866: PPUSH
63867: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63871: LD_VAR 0 3
63875: PPUSH
63876: LD_EXP 93
63880: PUSH
63881: LD_VAR 0 2
63885: ARRAY
63886: PUSH
63887: LD_INT 1
63889: ARRAY
63890: PPUSH
63891: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63895: LD_VAR 0 3
63899: PUSH
63900: LD_EXP 66
63904: PUSH
63905: LD_VAR 0 2
63909: ARRAY
63910: IN
63911: NOT
63912: IFFALSE 63958
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63914: LD_ADDR_EXP 66
63918: PUSH
63919: LD_EXP 66
63923: PPUSH
63924: LD_VAR 0 2
63928: PUSH
63929: LD_EXP 66
63933: PUSH
63934: LD_VAR 0 2
63938: ARRAY
63939: PUSH
63940: LD_INT 1
63942: PLUS
63943: PUSH
63944: EMPTY
63945: LIST
63946: LIST
63947: PPUSH
63948: LD_VAR 0 3
63952: PPUSH
63953: CALL 19307 0 3
63957: ST_TO_ADDR
// break ;
63958: GO 63962
// end ; end ; end ;
63960: GO 63796
63962: POP
63963: POP
// end ;
63964: GO 63556
63966: POP
63967: POP
// end ;
63968: LD_VAR 0 1
63972: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63973: LD_INT 0
63975: PPUSH
63976: PPUSH
63977: PPUSH
63978: PPUSH
63979: PPUSH
63980: PPUSH
63981: PPUSH
63982: PPUSH
63983: PPUSH
// if not mc_bases then
63984: LD_EXP 59
63988: NOT
63989: IFFALSE 63993
// exit ;
63991: GO 64398
// for i = 1 to mc_bases do
63993: LD_ADDR_VAR 0 2
63997: PUSH
63998: DOUBLE
63999: LD_INT 1
64001: DEC
64002: ST_TO_ADDR
64003: LD_EXP 59
64007: PUSH
64008: FOR_TO
64009: IFFALSE 64396
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
64011: LD_EXP 67
64015: PUSH
64016: LD_VAR 0 2
64020: ARRAY
64021: NOT
64022: PUSH
64023: LD_EXP 59
64027: PUSH
64028: LD_VAR 0 2
64032: ARRAY
64033: PPUSH
64034: LD_INT 30
64036: PUSH
64037: LD_INT 3
64039: PUSH
64040: EMPTY
64041: LIST
64042: LIST
64043: PPUSH
64044: CALL_OW 72
64048: NOT
64049: OR
64050: IFFALSE 64054
// continue ;
64052: GO 64008
// busy := false ;
64054: LD_ADDR_VAR 0 8
64058: PUSH
64059: LD_INT 0
64061: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
64062: LD_ADDR_VAR 0 4
64066: PUSH
64067: LD_EXP 59
64071: PUSH
64072: LD_VAR 0 2
64076: ARRAY
64077: PPUSH
64078: LD_INT 30
64080: PUSH
64081: LD_INT 3
64083: PUSH
64084: EMPTY
64085: LIST
64086: LIST
64087: PPUSH
64088: CALL_OW 72
64092: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
64093: LD_ADDR_VAR 0 6
64097: PUSH
64098: LD_EXP 67
64102: PUSH
64103: LD_VAR 0 2
64107: ARRAY
64108: PPUSH
64109: LD_INT 2
64111: PUSH
64112: LD_INT 30
64114: PUSH
64115: LD_INT 32
64117: PUSH
64118: EMPTY
64119: LIST
64120: LIST
64121: PUSH
64122: LD_INT 30
64124: PUSH
64125: LD_INT 33
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: EMPTY
64133: LIST
64134: LIST
64135: LIST
64136: PPUSH
64137: CALL_OW 72
64141: ST_TO_ADDR
// if not t then
64142: LD_VAR 0 6
64146: NOT
64147: IFFALSE 64151
// continue ;
64149: GO 64008
// for j in tmp do
64151: LD_ADDR_VAR 0 3
64155: PUSH
64156: LD_VAR 0 4
64160: PUSH
64161: FOR_IN
64162: IFFALSE 64192
// if not BuildingStatus ( j ) = bs_idle then
64164: LD_VAR 0 3
64168: PPUSH
64169: CALL_OW 461
64173: PUSH
64174: LD_INT 2
64176: EQUAL
64177: NOT
64178: IFFALSE 64190
// begin busy := true ;
64180: LD_ADDR_VAR 0 8
64184: PUSH
64185: LD_INT 1
64187: ST_TO_ADDR
// break ;
64188: GO 64192
// end ;
64190: GO 64161
64192: POP
64193: POP
// if busy then
64194: LD_VAR 0 8
64198: IFFALSE 64202
// continue ;
64200: GO 64008
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
64202: LD_ADDR_VAR 0 7
64206: PUSH
64207: LD_VAR 0 6
64211: PPUSH
64212: LD_INT 35
64214: PUSH
64215: LD_INT 0
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: PPUSH
64222: CALL_OW 72
64226: ST_TO_ADDR
// if tw then
64227: LD_VAR 0 7
64231: IFFALSE 64308
// begin tw := tw [ 1 ] ;
64233: LD_ADDR_VAR 0 7
64237: PUSH
64238: LD_VAR 0 7
64242: PUSH
64243: LD_INT 1
64245: ARRAY
64246: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
64247: LD_ADDR_VAR 0 9
64251: PUSH
64252: LD_VAR 0 7
64256: PPUSH
64257: LD_EXP 84
64261: PUSH
64262: LD_VAR 0 2
64266: ARRAY
64267: PPUSH
64268: CALL 24312 0 2
64272: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
64273: LD_EXP 98
64277: PUSH
64278: LD_VAR 0 2
64282: ARRAY
64283: IFFALSE 64306
// if not weapon in mc_allowed_tower_weapons [ i ] then
64285: LD_VAR 0 9
64289: PUSH
64290: LD_EXP 98
64294: PUSH
64295: LD_VAR 0 2
64299: ARRAY
64300: IN
64301: NOT
64302: IFFALSE 64306
// continue ;
64304: GO 64008
// end else
64306: GO 64371
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
64308: LD_ADDR_VAR 0 5
64312: PUSH
64313: LD_EXP 67
64317: PUSH
64318: LD_VAR 0 2
64322: ARRAY
64323: PPUSH
64324: LD_VAR 0 4
64328: PPUSH
64329: CALL 50231 0 2
64333: ST_TO_ADDR
// if not tmp2 then
64334: LD_VAR 0 5
64338: NOT
64339: IFFALSE 64343
// continue ;
64341: GO 64008
// tw := tmp2 [ 1 ] ;
64343: LD_ADDR_VAR 0 7
64347: PUSH
64348: LD_VAR 0 5
64352: PUSH
64353: LD_INT 1
64355: ARRAY
64356: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
64357: LD_ADDR_VAR 0 9
64361: PUSH
64362: LD_VAR 0 5
64366: PUSH
64367: LD_INT 2
64369: ARRAY
64370: ST_TO_ADDR
// end ; if not weapon then
64371: LD_VAR 0 9
64375: NOT
64376: IFFALSE 64380
// continue ;
64378: GO 64008
// ComPlaceWeapon ( tw , weapon ) ;
64380: LD_VAR 0 7
64384: PPUSH
64385: LD_VAR 0 9
64389: PPUSH
64390: CALL_OW 148
// end ;
64394: GO 64008
64396: POP
64397: POP
// end ;
64398: LD_VAR 0 1
64402: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
64403: LD_INT 0
64405: PPUSH
64406: PPUSH
64407: PPUSH
64408: PPUSH
64409: PPUSH
64410: PPUSH
64411: PPUSH
// if not mc_bases then
64412: LD_EXP 59
64416: NOT
64417: IFFALSE 64421
// exit ;
64419: GO 65189
// for i = 1 to mc_bases do
64421: LD_ADDR_VAR 0 2
64425: PUSH
64426: DOUBLE
64427: LD_INT 1
64429: DEC
64430: ST_TO_ADDR
64431: LD_EXP 59
64435: PUSH
64436: FOR_TO
64437: IFFALSE 65187
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
64439: LD_EXP 72
64443: PUSH
64444: LD_VAR 0 2
64448: ARRAY
64449: NOT
64450: PUSH
64451: LD_EXP 72
64455: PUSH
64456: LD_VAR 0 2
64460: ARRAY
64461: PUSH
64462: LD_EXP 73
64466: PUSH
64467: LD_VAR 0 2
64471: ARRAY
64472: EQUAL
64473: OR
64474: PUSH
64475: LD_EXP 82
64479: PUSH
64480: LD_VAR 0 2
64484: ARRAY
64485: OR
64486: IFFALSE 64490
// continue ;
64488: GO 64436
// if mc_miners [ i ] then
64490: LD_EXP 73
64494: PUSH
64495: LD_VAR 0 2
64499: ARRAY
64500: IFFALSE 64874
// begin for j = mc_miners [ i ] downto 1 do
64502: LD_ADDR_VAR 0 3
64506: PUSH
64507: DOUBLE
64508: LD_EXP 73
64512: PUSH
64513: LD_VAR 0 2
64517: ARRAY
64518: INC
64519: ST_TO_ADDR
64520: LD_INT 1
64522: PUSH
64523: FOR_DOWNTO
64524: IFFALSE 64872
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
64526: LD_EXP 73
64530: PUSH
64531: LD_VAR 0 2
64535: ARRAY
64536: PUSH
64537: LD_VAR 0 3
64541: ARRAY
64542: PPUSH
64543: CALL_OW 301
64547: PUSH
64548: LD_EXP 73
64552: PUSH
64553: LD_VAR 0 2
64557: ARRAY
64558: PUSH
64559: LD_VAR 0 3
64563: ARRAY
64564: PPUSH
64565: CALL_OW 257
64569: PUSH
64570: LD_INT 1
64572: NONEQUAL
64573: OR
64574: IFFALSE 64637
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
64576: LD_ADDR_VAR 0 5
64580: PUSH
64581: LD_EXP 73
64585: PUSH
64586: LD_VAR 0 2
64590: ARRAY
64591: PUSH
64592: LD_EXP 73
64596: PUSH
64597: LD_VAR 0 2
64601: ARRAY
64602: PUSH
64603: LD_VAR 0 3
64607: ARRAY
64608: DIFF
64609: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
64610: LD_ADDR_EXP 73
64614: PUSH
64615: LD_EXP 73
64619: PPUSH
64620: LD_VAR 0 2
64624: PPUSH
64625: LD_VAR 0 5
64629: PPUSH
64630: CALL_OW 1
64634: ST_TO_ADDR
// continue ;
64635: GO 64523
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
64637: LD_EXP 73
64641: PUSH
64642: LD_VAR 0 2
64646: ARRAY
64647: PUSH
64648: LD_VAR 0 3
64652: ARRAY
64653: PPUSH
64654: CALL_OW 257
64658: PUSH
64659: LD_INT 1
64661: EQUAL
64662: PUSH
64663: LD_EXP 73
64667: PUSH
64668: LD_VAR 0 2
64672: ARRAY
64673: PUSH
64674: LD_VAR 0 3
64678: ARRAY
64679: PPUSH
64680: CALL_OW 459
64684: NOT
64685: AND
64686: PUSH
64687: LD_EXP 73
64691: PUSH
64692: LD_VAR 0 2
64696: ARRAY
64697: PUSH
64698: LD_VAR 0 3
64702: ARRAY
64703: PPUSH
64704: CALL_OW 314
64708: NOT
64709: AND
64710: IFFALSE 64870
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
64712: LD_EXP 73
64716: PUSH
64717: LD_VAR 0 2
64721: ARRAY
64722: PUSH
64723: LD_VAR 0 3
64727: ARRAY
64728: PPUSH
64729: CALL_OW 310
64733: IFFALSE 64756
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64735: LD_EXP 73
64739: PUSH
64740: LD_VAR 0 2
64744: ARRAY
64745: PUSH
64746: LD_VAR 0 3
64750: ARRAY
64751: PPUSH
64752: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64756: LD_EXP 73
64760: PUSH
64761: LD_VAR 0 2
64765: ARRAY
64766: PUSH
64767: LD_VAR 0 3
64771: ARRAY
64772: PPUSH
64773: CALL_OW 314
64777: NOT
64778: IFFALSE 64870
// begin r := rand ( 1 , mc_mines [ i ] ) ;
64780: LD_ADDR_VAR 0 7
64784: PUSH
64785: LD_INT 1
64787: PPUSH
64788: LD_EXP 72
64792: PUSH
64793: LD_VAR 0 2
64797: ARRAY
64798: PPUSH
64799: CALL_OW 12
64803: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
64804: LD_EXP 73
64808: PUSH
64809: LD_VAR 0 2
64813: ARRAY
64814: PUSH
64815: LD_VAR 0 3
64819: ARRAY
64820: PPUSH
64821: LD_EXP 72
64825: PUSH
64826: LD_VAR 0 2
64830: ARRAY
64831: PUSH
64832: LD_VAR 0 7
64836: ARRAY
64837: PUSH
64838: LD_INT 1
64840: ARRAY
64841: PPUSH
64842: LD_EXP 72
64846: PUSH
64847: LD_VAR 0 2
64851: ARRAY
64852: PUSH
64853: LD_VAR 0 7
64857: ARRAY
64858: PUSH
64859: LD_INT 2
64861: ARRAY
64862: PPUSH
64863: LD_INT 0
64865: PPUSH
64866: CALL_OW 193
// end ; end ; end ;
64870: GO 64523
64872: POP
64873: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64874: LD_ADDR_VAR 0 5
64878: PUSH
64879: LD_EXP 59
64883: PUSH
64884: LD_VAR 0 2
64888: ARRAY
64889: PPUSH
64890: LD_INT 2
64892: PUSH
64893: LD_INT 30
64895: PUSH
64896: LD_INT 4
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 30
64905: PUSH
64906: LD_INT 5
64908: PUSH
64909: EMPTY
64910: LIST
64911: LIST
64912: PUSH
64913: LD_INT 30
64915: PUSH
64916: LD_INT 32
64918: PUSH
64919: EMPTY
64920: LIST
64921: LIST
64922: PUSH
64923: EMPTY
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: PPUSH
64929: CALL_OW 72
64933: ST_TO_ADDR
// if not tmp then
64934: LD_VAR 0 5
64938: NOT
64939: IFFALSE 64943
// continue ;
64941: GO 64436
// list := [ ] ;
64943: LD_ADDR_VAR 0 6
64947: PUSH
64948: EMPTY
64949: ST_TO_ADDR
// for j in tmp do
64950: LD_ADDR_VAR 0 3
64954: PUSH
64955: LD_VAR 0 5
64959: PUSH
64960: FOR_IN
64961: IFFALSE 65030
// begin for k in UnitsInside ( j ) do
64963: LD_ADDR_VAR 0 4
64967: PUSH
64968: LD_VAR 0 3
64972: PPUSH
64973: CALL_OW 313
64977: PUSH
64978: FOR_IN
64979: IFFALSE 65026
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64981: LD_VAR 0 4
64985: PPUSH
64986: CALL_OW 257
64990: PUSH
64991: LD_INT 1
64993: EQUAL
64994: PUSH
64995: LD_VAR 0 4
64999: PPUSH
65000: CALL_OW 459
65004: NOT
65005: AND
65006: IFFALSE 65024
// list := list ^ k ;
65008: LD_ADDR_VAR 0 6
65012: PUSH
65013: LD_VAR 0 6
65017: PUSH
65018: LD_VAR 0 4
65022: ADD
65023: ST_TO_ADDR
65024: GO 64978
65026: POP
65027: POP
// end ;
65028: GO 64960
65030: POP
65031: POP
// list := list diff mc_miners [ i ] ;
65032: LD_ADDR_VAR 0 6
65036: PUSH
65037: LD_VAR 0 6
65041: PUSH
65042: LD_EXP 73
65046: PUSH
65047: LD_VAR 0 2
65051: ARRAY
65052: DIFF
65053: ST_TO_ADDR
// if not list then
65054: LD_VAR 0 6
65058: NOT
65059: IFFALSE 65063
// continue ;
65061: GO 64436
// k := mc_mines [ i ] - mc_miners [ i ] ;
65063: LD_ADDR_VAR 0 4
65067: PUSH
65068: LD_EXP 72
65072: PUSH
65073: LD_VAR 0 2
65077: ARRAY
65078: PUSH
65079: LD_EXP 73
65083: PUSH
65084: LD_VAR 0 2
65088: ARRAY
65089: MINUS
65090: ST_TO_ADDR
// if k > list then
65091: LD_VAR 0 4
65095: PUSH
65096: LD_VAR 0 6
65100: GREATER
65101: IFFALSE 65113
// k := list ;
65103: LD_ADDR_VAR 0 4
65107: PUSH
65108: LD_VAR 0 6
65112: ST_TO_ADDR
// for j = 1 to k do
65113: LD_ADDR_VAR 0 3
65117: PUSH
65118: DOUBLE
65119: LD_INT 1
65121: DEC
65122: ST_TO_ADDR
65123: LD_VAR 0 4
65127: PUSH
65128: FOR_TO
65129: IFFALSE 65183
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
65131: LD_ADDR_EXP 73
65135: PUSH
65136: LD_EXP 73
65140: PPUSH
65141: LD_VAR 0 2
65145: PUSH
65146: LD_EXP 73
65150: PUSH
65151: LD_VAR 0 2
65155: ARRAY
65156: PUSH
65157: LD_INT 1
65159: PLUS
65160: PUSH
65161: EMPTY
65162: LIST
65163: LIST
65164: PPUSH
65165: LD_VAR 0 6
65169: PUSH
65170: LD_VAR 0 3
65174: ARRAY
65175: PPUSH
65176: CALL 19307 0 3
65180: ST_TO_ADDR
65181: GO 65128
65183: POP
65184: POP
// end ;
65185: GO 64436
65187: POP
65188: POP
// end ;
65189: LD_VAR 0 1
65193: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
65194: LD_INT 0
65196: PPUSH
65197: PPUSH
65198: PPUSH
65199: PPUSH
65200: PPUSH
65201: PPUSH
65202: PPUSH
65203: PPUSH
65204: PPUSH
65205: PPUSH
// if not mc_bases then
65206: LD_EXP 59
65210: NOT
65211: IFFALSE 65215
// exit ;
65213: GO 66965
// for i = 1 to mc_bases do
65215: LD_ADDR_VAR 0 2
65219: PUSH
65220: DOUBLE
65221: LD_INT 1
65223: DEC
65224: ST_TO_ADDR
65225: LD_EXP 59
65229: PUSH
65230: FOR_TO
65231: IFFALSE 66963
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
65233: LD_EXP 59
65237: PUSH
65238: LD_VAR 0 2
65242: ARRAY
65243: NOT
65244: PUSH
65245: LD_EXP 66
65249: PUSH
65250: LD_VAR 0 2
65254: ARRAY
65255: OR
65256: IFFALSE 65260
// continue ;
65258: GO 65230
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
65260: LD_EXP 75
65264: PUSH
65265: LD_VAR 0 2
65269: ARRAY
65270: NOT
65271: PUSH
65272: LD_EXP 76
65276: PUSH
65277: LD_VAR 0 2
65281: ARRAY
65282: AND
65283: IFFALSE 65321
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
65285: LD_ADDR_EXP 76
65289: PUSH
65290: LD_EXP 76
65294: PPUSH
65295: LD_VAR 0 2
65299: PPUSH
65300: EMPTY
65301: PPUSH
65302: CALL_OW 1
65306: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
65307: LD_VAR 0 2
65311: PPUSH
65312: LD_INT 107
65314: PPUSH
65315: CALL 56148 0 2
// continue ;
65319: GO 65230
// end ; target := [ ] ;
65321: LD_ADDR_VAR 0 6
65325: PUSH
65326: EMPTY
65327: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
65328: LD_ADDR_VAR 0 3
65332: PUSH
65333: DOUBLE
65334: LD_EXP 75
65338: PUSH
65339: LD_VAR 0 2
65343: ARRAY
65344: INC
65345: ST_TO_ADDR
65346: LD_INT 1
65348: PUSH
65349: FOR_DOWNTO
65350: IFFALSE 65610
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
65352: LD_EXP 75
65356: PUSH
65357: LD_VAR 0 2
65361: ARRAY
65362: PUSH
65363: LD_VAR 0 3
65367: ARRAY
65368: PUSH
65369: LD_INT 2
65371: ARRAY
65372: PPUSH
65373: LD_EXP 75
65377: PUSH
65378: LD_VAR 0 2
65382: ARRAY
65383: PUSH
65384: LD_VAR 0 3
65388: ARRAY
65389: PUSH
65390: LD_INT 3
65392: ARRAY
65393: PPUSH
65394: CALL_OW 488
65398: PUSH
65399: LD_EXP 75
65403: PUSH
65404: LD_VAR 0 2
65408: ARRAY
65409: PUSH
65410: LD_VAR 0 3
65414: ARRAY
65415: PUSH
65416: LD_INT 2
65418: ARRAY
65419: PPUSH
65420: LD_EXP 75
65424: PUSH
65425: LD_VAR 0 2
65429: ARRAY
65430: PUSH
65431: LD_VAR 0 3
65435: ARRAY
65436: PUSH
65437: LD_INT 3
65439: ARRAY
65440: PPUSH
65441: CALL_OW 284
65445: PUSH
65446: LD_INT 0
65448: EQUAL
65449: AND
65450: IFFALSE 65505
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
65452: LD_ADDR_VAR 0 5
65456: PUSH
65457: LD_EXP 75
65461: PUSH
65462: LD_VAR 0 2
65466: ARRAY
65467: PPUSH
65468: LD_VAR 0 3
65472: PPUSH
65473: CALL_OW 3
65477: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
65478: LD_ADDR_EXP 75
65482: PUSH
65483: LD_EXP 75
65487: PPUSH
65488: LD_VAR 0 2
65492: PPUSH
65493: LD_VAR 0 5
65497: PPUSH
65498: CALL_OW 1
65502: ST_TO_ADDR
// continue ;
65503: GO 65349
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
65505: LD_EXP 59
65509: PUSH
65510: LD_VAR 0 2
65514: ARRAY
65515: PUSH
65516: LD_INT 1
65518: ARRAY
65519: PPUSH
65520: CALL_OW 255
65524: PPUSH
65525: LD_EXP 75
65529: PUSH
65530: LD_VAR 0 2
65534: ARRAY
65535: PUSH
65536: LD_VAR 0 3
65540: ARRAY
65541: PUSH
65542: LD_INT 2
65544: ARRAY
65545: PPUSH
65546: LD_EXP 75
65550: PUSH
65551: LD_VAR 0 2
65555: ARRAY
65556: PUSH
65557: LD_VAR 0 3
65561: ARRAY
65562: PUSH
65563: LD_INT 3
65565: ARRAY
65566: PPUSH
65567: LD_INT 30
65569: PPUSH
65570: CALL 20203 0 4
65574: PUSH
65575: LD_INT 4
65577: ARRAY
65578: PUSH
65579: LD_INT 0
65581: EQUAL
65582: IFFALSE 65608
// begin target := mc_crates [ i ] [ j ] ;
65584: LD_ADDR_VAR 0 6
65588: PUSH
65589: LD_EXP 75
65593: PUSH
65594: LD_VAR 0 2
65598: ARRAY
65599: PUSH
65600: LD_VAR 0 3
65604: ARRAY
65605: ST_TO_ADDR
// break ;
65606: GO 65610
// end ; end ;
65608: GO 65349
65610: POP
65611: POP
// if not target then
65612: LD_VAR 0 6
65616: NOT
65617: IFFALSE 65621
// continue ;
65619: GO 65230
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
65621: LD_ADDR_VAR 0 7
65625: PUSH
65626: LD_EXP 78
65630: PUSH
65631: LD_VAR 0 2
65635: ARRAY
65636: PPUSH
65637: LD_INT 2
65639: PUSH
65640: LD_INT 3
65642: PUSH
65643: LD_INT 58
65645: PUSH
65646: EMPTY
65647: LIST
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 61
65655: PUSH
65656: EMPTY
65657: LIST
65658: PUSH
65659: LD_INT 33
65661: PUSH
65662: LD_INT 5
65664: PUSH
65665: EMPTY
65666: LIST
65667: LIST
65668: PUSH
65669: LD_INT 33
65671: PUSH
65672: LD_INT 3
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: EMPTY
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: PUSH
65686: LD_INT 2
65688: PUSH
65689: LD_INT 34
65691: PUSH
65692: LD_INT 32
65694: PUSH
65695: EMPTY
65696: LIST
65697: LIST
65698: PUSH
65699: LD_INT 34
65701: PUSH
65702: LD_INT 51
65704: PUSH
65705: EMPTY
65706: LIST
65707: LIST
65708: PUSH
65709: LD_INT 34
65711: PUSH
65712: LD_INT 12
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: EMPTY
65720: LIST
65721: LIST
65722: LIST
65723: LIST
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PPUSH
65729: CALL_OW 72
65733: ST_TO_ADDR
// if not cargo then
65734: LD_VAR 0 7
65738: NOT
65739: IFFALSE 66382
// begin if mc_crates_collector [ i ] < 5 then
65741: LD_EXP 76
65745: PUSH
65746: LD_VAR 0 2
65750: ARRAY
65751: PUSH
65752: LD_INT 5
65754: LESS
65755: IFFALSE 66121
// begin if mc_ape [ i ] then
65757: LD_EXP 88
65761: PUSH
65762: LD_VAR 0 2
65766: ARRAY
65767: IFFALSE 65814
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65769: LD_ADDR_VAR 0 5
65773: PUSH
65774: LD_EXP 88
65778: PUSH
65779: LD_VAR 0 2
65783: ARRAY
65784: PPUSH
65785: LD_INT 25
65787: PUSH
65788: LD_INT 16
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: LD_INT 24
65797: PUSH
65798: LD_INT 750
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: PUSH
65805: EMPTY
65806: LIST
65807: LIST
65808: PPUSH
65809: CALL_OW 72
65813: ST_TO_ADDR
// if not tmp then
65814: LD_VAR 0 5
65818: NOT
65819: IFFALSE 65866
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65821: LD_ADDR_VAR 0 5
65825: PUSH
65826: LD_EXP 59
65830: PUSH
65831: LD_VAR 0 2
65835: ARRAY
65836: PPUSH
65837: LD_INT 25
65839: PUSH
65840: LD_INT 2
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 24
65849: PUSH
65850: LD_INT 750
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: PPUSH
65861: CALL_OW 72
65865: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65866: LD_EXP 88
65870: PUSH
65871: LD_VAR 0 2
65875: ARRAY
65876: PUSH
65877: LD_EXP 59
65881: PUSH
65882: LD_VAR 0 2
65886: ARRAY
65887: PPUSH
65888: LD_INT 25
65890: PUSH
65891: LD_INT 2
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 24
65900: PUSH
65901: LD_INT 750
65903: PUSH
65904: EMPTY
65905: LIST
65906: LIST
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PPUSH
65912: CALL_OW 72
65916: AND
65917: PUSH
65918: LD_VAR 0 5
65922: PUSH
65923: LD_INT 5
65925: LESS
65926: AND
65927: IFFALSE 66009
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65929: LD_ADDR_VAR 0 3
65933: PUSH
65934: LD_EXP 59
65938: PUSH
65939: LD_VAR 0 2
65943: ARRAY
65944: PPUSH
65945: LD_INT 25
65947: PUSH
65948: LD_INT 2
65950: PUSH
65951: EMPTY
65952: LIST
65953: LIST
65954: PUSH
65955: LD_INT 24
65957: PUSH
65958: LD_INT 750
65960: PUSH
65961: EMPTY
65962: LIST
65963: LIST
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PPUSH
65969: CALL_OW 72
65973: PUSH
65974: FOR_IN
65975: IFFALSE 66007
// begin tmp := tmp union j ;
65977: LD_ADDR_VAR 0 5
65981: PUSH
65982: LD_VAR 0 5
65986: PUSH
65987: LD_VAR 0 3
65991: UNION
65992: ST_TO_ADDR
// if tmp >= 5 then
65993: LD_VAR 0 5
65997: PUSH
65998: LD_INT 5
66000: GREATEREQUAL
66001: IFFALSE 66005
// break ;
66003: GO 66007
// end ;
66005: GO 65974
66007: POP
66008: POP
// end ; if not tmp then
66009: LD_VAR 0 5
66013: NOT
66014: IFFALSE 66018
// continue ;
66016: GO 65230
// for j in tmp do
66018: LD_ADDR_VAR 0 3
66022: PUSH
66023: LD_VAR 0 5
66027: PUSH
66028: FOR_IN
66029: IFFALSE 66119
// if not GetTag ( j ) then
66031: LD_VAR 0 3
66035: PPUSH
66036: CALL_OW 110
66040: NOT
66041: IFFALSE 66117
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
66043: LD_ADDR_EXP 76
66047: PUSH
66048: LD_EXP 76
66052: PPUSH
66053: LD_VAR 0 2
66057: PUSH
66058: LD_EXP 76
66062: PUSH
66063: LD_VAR 0 2
66067: ARRAY
66068: PUSH
66069: LD_INT 1
66071: PLUS
66072: PUSH
66073: EMPTY
66074: LIST
66075: LIST
66076: PPUSH
66077: LD_VAR 0 3
66081: PPUSH
66082: CALL 19307 0 3
66086: ST_TO_ADDR
// SetTag ( j , 107 ) ;
66087: LD_VAR 0 3
66091: PPUSH
66092: LD_INT 107
66094: PPUSH
66095: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
66099: LD_EXP 76
66103: PUSH
66104: LD_VAR 0 2
66108: ARRAY
66109: PUSH
66110: LD_INT 5
66112: GREATEREQUAL
66113: IFFALSE 66117
// break ;
66115: GO 66119
// end ;
66117: GO 66028
66119: POP
66120: POP
// end ; if mc_crates_collector [ i ] and target then
66121: LD_EXP 76
66125: PUSH
66126: LD_VAR 0 2
66130: ARRAY
66131: PUSH
66132: LD_VAR 0 6
66136: AND
66137: IFFALSE 66380
// begin if mc_crates_collector [ i ] < target [ 1 ] then
66139: LD_EXP 76
66143: PUSH
66144: LD_VAR 0 2
66148: ARRAY
66149: PUSH
66150: LD_VAR 0 6
66154: PUSH
66155: LD_INT 1
66157: ARRAY
66158: LESS
66159: IFFALSE 66179
// tmp := mc_crates_collector [ i ] else
66161: LD_ADDR_VAR 0 5
66165: PUSH
66166: LD_EXP 76
66170: PUSH
66171: LD_VAR 0 2
66175: ARRAY
66176: ST_TO_ADDR
66177: GO 66193
// tmp := target [ 1 ] ;
66179: LD_ADDR_VAR 0 5
66183: PUSH
66184: LD_VAR 0 6
66188: PUSH
66189: LD_INT 1
66191: ARRAY
66192: ST_TO_ADDR
// k := 0 ;
66193: LD_ADDR_VAR 0 4
66197: PUSH
66198: LD_INT 0
66200: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
66201: LD_ADDR_VAR 0 3
66205: PUSH
66206: LD_EXP 76
66210: PUSH
66211: LD_VAR 0 2
66215: ARRAY
66216: PUSH
66217: FOR_IN
66218: IFFALSE 66378
// begin k := k + 1 ;
66220: LD_ADDR_VAR 0 4
66224: PUSH
66225: LD_VAR 0 4
66229: PUSH
66230: LD_INT 1
66232: PLUS
66233: ST_TO_ADDR
// if k > tmp then
66234: LD_VAR 0 4
66238: PUSH
66239: LD_VAR 0 5
66243: GREATER
66244: IFFALSE 66248
// break ;
66246: GO 66378
// if not GetClass ( j ) in [ 2 , 16 ] then
66248: LD_VAR 0 3
66252: PPUSH
66253: CALL_OW 257
66257: PUSH
66258: LD_INT 2
66260: PUSH
66261: LD_INT 16
66263: PUSH
66264: EMPTY
66265: LIST
66266: LIST
66267: IN
66268: NOT
66269: IFFALSE 66322
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
66271: LD_ADDR_EXP 76
66275: PUSH
66276: LD_EXP 76
66280: PPUSH
66281: LD_VAR 0 2
66285: PPUSH
66286: LD_EXP 76
66290: PUSH
66291: LD_VAR 0 2
66295: ARRAY
66296: PUSH
66297: LD_VAR 0 3
66301: DIFF
66302: PPUSH
66303: CALL_OW 1
66307: ST_TO_ADDR
// SetTag ( j , 0 ) ;
66308: LD_VAR 0 3
66312: PPUSH
66313: LD_INT 0
66315: PPUSH
66316: CALL_OW 109
// continue ;
66320: GO 66217
// end ; if IsInUnit ( j ) then
66322: LD_VAR 0 3
66326: PPUSH
66327: CALL_OW 310
66331: IFFALSE 66342
// ComExitBuilding ( j ) ;
66333: LD_VAR 0 3
66337: PPUSH
66338: CALL_OW 122
// wait ( 3 ) ;
66342: LD_INT 3
66344: PPUSH
66345: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66349: LD_VAR 0 3
66353: PPUSH
66354: LD_VAR 0 6
66358: PUSH
66359: LD_INT 2
66361: ARRAY
66362: PPUSH
66363: LD_VAR 0 6
66367: PUSH
66368: LD_INT 3
66370: ARRAY
66371: PPUSH
66372: CALL_OW 117
// end ;
66376: GO 66217
66378: POP
66379: POP
// end ; end else
66380: GO 66961
// begin for j in cargo do
66382: LD_ADDR_VAR 0 3
66386: PUSH
66387: LD_VAR 0 7
66391: PUSH
66392: FOR_IN
66393: IFFALSE 66959
// begin if GetTag ( j ) <> 0 then
66395: LD_VAR 0 3
66399: PPUSH
66400: CALL_OW 110
66404: PUSH
66405: LD_INT 0
66407: NONEQUAL
66408: IFFALSE 66412
// continue ;
66410: GO 66392
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
66412: LD_VAR 0 3
66416: PPUSH
66417: CALL_OW 256
66421: PUSH
66422: LD_INT 1000
66424: LESS
66425: PUSH
66426: LD_VAR 0 3
66430: PPUSH
66431: LD_EXP 83
66435: PUSH
66436: LD_VAR 0 2
66440: ARRAY
66441: PPUSH
66442: CALL_OW 308
66446: NOT
66447: AND
66448: IFFALSE 66470
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66450: LD_VAR 0 3
66454: PPUSH
66455: LD_EXP 83
66459: PUSH
66460: LD_VAR 0 2
66464: ARRAY
66465: PPUSH
66466: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
66470: LD_VAR 0 3
66474: PPUSH
66475: CALL_OW 256
66479: PUSH
66480: LD_INT 1000
66482: LESS
66483: PUSH
66484: LD_VAR 0 3
66488: PPUSH
66489: LD_EXP 83
66493: PUSH
66494: LD_VAR 0 2
66498: ARRAY
66499: PPUSH
66500: CALL_OW 308
66504: AND
66505: IFFALSE 66509
// continue ;
66507: GO 66392
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
66509: LD_VAR 0 3
66513: PPUSH
66514: CALL_OW 262
66518: PUSH
66519: LD_INT 2
66521: EQUAL
66522: PUSH
66523: LD_VAR 0 3
66527: PPUSH
66528: CALL_OW 261
66532: PUSH
66533: LD_INT 15
66535: LESS
66536: AND
66537: IFFALSE 66541
// continue ;
66539: GO 66392
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
66541: LD_VAR 0 3
66545: PPUSH
66546: CALL_OW 262
66550: PUSH
66551: LD_INT 1
66553: EQUAL
66554: PUSH
66555: LD_VAR 0 3
66559: PPUSH
66560: CALL_OW 261
66564: PUSH
66565: LD_INT 10
66567: LESS
66568: AND
66569: IFFALSE 66898
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
66571: LD_ADDR_VAR 0 8
66575: PUSH
66576: LD_EXP 59
66580: PUSH
66581: LD_VAR 0 2
66585: ARRAY
66586: PPUSH
66587: LD_INT 2
66589: PUSH
66590: LD_INT 30
66592: PUSH
66593: LD_INT 0
66595: PUSH
66596: EMPTY
66597: LIST
66598: LIST
66599: PUSH
66600: LD_INT 30
66602: PUSH
66603: LD_INT 1
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: LIST
66614: PPUSH
66615: CALL_OW 72
66619: ST_TO_ADDR
// if not depot then
66620: LD_VAR 0 8
66624: NOT
66625: IFFALSE 66629
// continue ;
66627: GO 66392
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
66629: LD_VAR 0 3
66633: PPUSH
66634: LD_VAR 0 8
66638: PPUSH
66639: LD_VAR 0 3
66643: PPUSH
66644: CALL_OW 74
66648: PPUSH
66649: CALL_OW 296
66653: PUSH
66654: LD_INT 6
66656: LESS
66657: IFFALSE 66673
// SetFuel ( j , 100 ) else
66659: LD_VAR 0 3
66663: PPUSH
66664: LD_INT 100
66666: PPUSH
66667: CALL_OW 240
66671: GO 66898
// if GetFuel ( j ) = 0 then
66673: LD_VAR 0 3
66677: PPUSH
66678: CALL_OW 261
66682: PUSH
66683: LD_INT 0
66685: EQUAL
66686: IFFALSE 66898
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
66688: LD_ADDR_EXP 78
66692: PUSH
66693: LD_EXP 78
66697: PPUSH
66698: LD_VAR 0 2
66702: PPUSH
66703: LD_EXP 78
66707: PUSH
66708: LD_VAR 0 2
66712: ARRAY
66713: PUSH
66714: LD_VAR 0 3
66718: DIFF
66719: PPUSH
66720: CALL_OW 1
66724: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66725: LD_VAR 0 3
66729: PPUSH
66730: CALL_OW 263
66734: PUSH
66735: LD_INT 1
66737: EQUAL
66738: IFFALSE 66754
// ComExitVehicle ( IsInUnit ( j ) ) ;
66740: LD_VAR 0 3
66744: PPUSH
66745: CALL_OW 310
66749: PPUSH
66750: CALL_OW 121
// if GetControl ( j ) = control_remote then
66754: LD_VAR 0 3
66758: PPUSH
66759: CALL_OW 263
66763: PUSH
66764: LD_INT 2
66766: EQUAL
66767: IFFALSE 66778
// ComUnlink ( j ) ;
66769: LD_VAR 0 3
66773: PPUSH
66774: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66778: LD_ADDR_VAR 0 9
66782: PUSH
66783: LD_VAR 0 2
66787: PPUSH
66788: LD_INT 3
66790: PPUSH
66791: CALL 76368 0 2
66795: ST_TO_ADDR
// if fac then
66796: LD_VAR 0 9
66800: IFFALSE 66896
// begin for k in fac do
66802: LD_ADDR_VAR 0 4
66806: PUSH
66807: LD_VAR 0 9
66811: PUSH
66812: FOR_IN
66813: IFFALSE 66894
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66815: LD_ADDR_VAR 0 10
66819: PUSH
66820: LD_VAR 0 9
66824: PPUSH
66825: LD_VAR 0 3
66829: PPUSH
66830: CALL_OW 265
66834: PPUSH
66835: LD_VAR 0 3
66839: PPUSH
66840: CALL_OW 262
66844: PPUSH
66845: LD_VAR 0 3
66849: PPUSH
66850: CALL_OW 263
66854: PPUSH
66855: LD_VAR 0 3
66859: PPUSH
66860: CALL_OW 264
66864: PPUSH
66865: CALL 16839 0 5
66869: ST_TO_ADDR
// if components then
66870: LD_VAR 0 10
66874: IFFALSE 66892
// begin MC_InsertProduceList ( i , components ) ;
66876: LD_VAR 0 2
66880: PPUSH
66881: LD_VAR 0 10
66885: PPUSH
66886: CALL 75913 0 2
// break ;
66890: GO 66894
// end ; end ;
66892: GO 66812
66894: POP
66895: POP
// end ; continue ;
66896: GO 66392
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66898: LD_VAR 0 3
66902: PPUSH
66903: LD_INT 1
66905: PPUSH
66906: CALL_OW 289
66910: PUSH
66911: LD_INT 100
66913: LESS
66914: PUSH
66915: LD_VAR 0 3
66919: PPUSH
66920: CALL_OW 314
66924: NOT
66925: AND
66926: IFFALSE 66955
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66928: LD_VAR 0 3
66932: PPUSH
66933: LD_VAR 0 6
66937: PUSH
66938: LD_INT 2
66940: ARRAY
66941: PPUSH
66942: LD_VAR 0 6
66946: PUSH
66947: LD_INT 3
66949: ARRAY
66950: PPUSH
66951: CALL_OW 117
// break ;
66955: GO 66959
// end ;
66957: GO 66392
66959: POP
66960: POP
// end ; end ;
66961: GO 65230
66963: POP
66964: POP
// end ;
66965: LD_VAR 0 1
66969: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66970: LD_INT 0
66972: PPUSH
66973: PPUSH
66974: PPUSH
66975: PPUSH
// if not mc_bases then
66976: LD_EXP 59
66980: NOT
66981: IFFALSE 66985
// exit ;
66983: GO 67146
// for i = 1 to mc_bases do
66985: LD_ADDR_VAR 0 2
66989: PUSH
66990: DOUBLE
66991: LD_INT 1
66993: DEC
66994: ST_TO_ADDR
66995: LD_EXP 59
66999: PUSH
67000: FOR_TO
67001: IFFALSE 67144
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
67003: LD_ADDR_VAR 0 4
67007: PUSH
67008: LD_EXP 78
67012: PUSH
67013: LD_VAR 0 2
67017: ARRAY
67018: PUSH
67019: LD_EXP 81
67023: PUSH
67024: LD_VAR 0 2
67028: ARRAY
67029: UNION
67030: PPUSH
67031: LD_INT 33
67033: PUSH
67034: LD_INT 2
67036: PUSH
67037: EMPTY
67038: LIST
67039: LIST
67040: PPUSH
67041: CALL_OW 72
67045: ST_TO_ADDR
// if tmp then
67046: LD_VAR 0 4
67050: IFFALSE 67142
// for j in tmp do
67052: LD_ADDR_VAR 0 3
67056: PUSH
67057: LD_VAR 0 4
67061: PUSH
67062: FOR_IN
67063: IFFALSE 67140
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
67065: LD_VAR 0 3
67069: PPUSH
67070: CALL_OW 312
67074: NOT
67075: PUSH
67076: LD_VAR 0 3
67080: PPUSH
67081: CALL_OW 256
67085: PUSH
67086: LD_INT 250
67088: GREATEREQUAL
67089: AND
67090: IFFALSE 67103
// Connect ( j ) else
67092: LD_VAR 0 3
67096: PPUSH
67097: CALL 22272 0 1
67101: GO 67138
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
67103: LD_VAR 0 3
67107: PPUSH
67108: CALL_OW 256
67112: PUSH
67113: LD_INT 250
67115: LESS
67116: PUSH
67117: LD_VAR 0 3
67121: PPUSH
67122: CALL_OW 312
67126: AND
67127: IFFALSE 67138
// ComUnlink ( j ) ;
67129: LD_VAR 0 3
67133: PPUSH
67134: CALL_OW 136
67138: GO 67062
67140: POP
67141: POP
// end ;
67142: GO 67000
67144: POP
67145: POP
// end ;
67146: LD_VAR 0 1
67150: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
67151: LD_INT 0
67153: PPUSH
67154: PPUSH
67155: PPUSH
67156: PPUSH
67157: PPUSH
// if not mc_bases then
67158: LD_EXP 59
67162: NOT
67163: IFFALSE 67167
// exit ;
67165: GO 67612
// for i = 1 to mc_bases do
67167: LD_ADDR_VAR 0 2
67171: PUSH
67172: DOUBLE
67173: LD_INT 1
67175: DEC
67176: ST_TO_ADDR
67177: LD_EXP 59
67181: PUSH
67182: FOR_TO
67183: IFFALSE 67610
// begin if not mc_produce [ i ] then
67185: LD_EXP 80
67189: PUSH
67190: LD_VAR 0 2
67194: ARRAY
67195: NOT
67196: IFFALSE 67200
// continue ;
67198: GO 67182
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
67200: LD_ADDR_VAR 0 5
67204: PUSH
67205: LD_EXP 59
67209: PUSH
67210: LD_VAR 0 2
67214: ARRAY
67215: PPUSH
67216: LD_INT 30
67218: PUSH
67219: LD_INT 3
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PPUSH
67226: CALL_OW 72
67230: ST_TO_ADDR
// if not fac then
67231: LD_VAR 0 5
67235: NOT
67236: IFFALSE 67240
// continue ;
67238: GO 67182
// for j in fac do
67240: LD_ADDR_VAR 0 3
67244: PUSH
67245: LD_VAR 0 5
67249: PUSH
67250: FOR_IN
67251: IFFALSE 67606
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
67253: LD_VAR 0 3
67257: PPUSH
67258: CALL_OW 461
67262: PUSH
67263: LD_INT 2
67265: NONEQUAL
67266: PUSH
67267: LD_VAR 0 3
67271: PPUSH
67272: LD_INT 15
67274: PPUSH
67275: CALL 21900 0 2
67279: PUSH
67280: LD_INT 4
67282: ARRAY
67283: OR
67284: IFFALSE 67288
// continue ;
67286: GO 67250
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
67288: LD_VAR 0 3
67292: PPUSH
67293: LD_EXP 80
67297: PUSH
67298: LD_VAR 0 2
67302: ARRAY
67303: PUSH
67304: LD_INT 1
67306: ARRAY
67307: PUSH
67308: LD_INT 1
67310: ARRAY
67311: PPUSH
67312: LD_EXP 80
67316: PUSH
67317: LD_VAR 0 2
67321: ARRAY
67322: PUSH
67323: LD_INT 1
67325: ARRAY
67326: PUSH
67327: LD_INT 2
67329: ARRAY
67330: PPUSH
67331: LD_EXP 80
67335: PUSH
67336: LD_VAR 0 2
67340: ARRAY
67341: PUSH
67342: LD_INT 1
67344: ARRAY
67345: PUSH
67346: LD_INT 3
67348: ARRAY
67349: PPUSH
67350: LD_EXP 80
67354: PUSH
67355: LD_VAR 0 2
67359: ARRAY
67360: PUSH
67361: LD_INT 1
67363: ARRAY
67364: PUSH
67365: LD_INT 4
67367: ARRAY
67368: PPUSH
67369: CALL_OW 448
67373: PUSH
67374: LD_VAR 0 3
67378: PPUSH
67379: LD_EXP 80
67383: PUSH
67384: LD_VAR 0 2
67388: ARRAY
67389: PUSH
67390: LD_INT 1
67392: ARRAY
67393: PUSH
67394: LD_INT 1
67396: ARRAY
67397: PUSH
67398: LD_EXP 80
67402: PUSH
67403: LD_VAR 0 2
67407: ARRAY
67408: PUSH
67409: LD_INT 1
67411: ARRAY
67412: PUSH
67413: LD_INT 2
67415: ARRAY
67416: PUSH
67417: LD_EXP 80
67421: PUSH
67422: LD_VAR 0 2
67426: ARRAY
67427: PUSH
67428: LD_INT 1
67430: ARRAY
67431: PUSH
67432: LD_INT 3
67434: ARRAY
67435: PUSH
67436: LD_EXP 80
67440: PUSH
67441: LD_VAR 0 2
67445: ARRAY
67446: PUSH
67447: LD_INT 1
67449: ARRAY
67450: PUSH
67451: LD_INT 4
67453: ARRAY
67454: PUSH
67455: EMPTY
67456: LIST
67457: LIST
67458: LIST
67459: LIST
67460: PPUSH
67461: CALL 25698 0 2
67465: AND
67466: IFFALSE 67604
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
67468: LD_VAR 0 3
67472: PPUSH
67473: LD_EXP 80
67477: PUSH
67478: LD_VAR 0 2
67482: ARRAY
67483: PUSH
67484: LD_INT 1
67486: ARRAY
67487: PUSH
67488: LD_INT 1
67490: ARRAY
67491: PPUSH
67492: LD_EXP 80
67496: PUSH
67497: LD_VAR 0 2
67501: ARRAY
67502: PUSH
67503: LD_INT 1
67505: ARRAY
67506: PUSH
67507: LD_INT 2
67509: ARRAY
67510: PPUSH
67511: LD_EXP 80
67515: PUSH
67516: LD_VAR 0 2
67520: ARRAY
67521: PUSH
67522: LD_INT 1
67524: ARRAY
67525: PUSH
67526: LD_INT 3
67528: ARRAY
67529: PPUSH
67530: LD_EXP 80
67534: PUSH
67535: LD_VAR 0 2
67539: ARRAY
67540: PUSH
67541: LD_INT 1
67543: ARRAY
67544: PUSH
67545: LD_INT 4
67547: ARRAY
67548: PPUSH
67549: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
67553: LD_ADDR_VAR 0 4
67557: PUSH
67558: LD_EXP 80
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: PPUSH
67569: LD_INT 1
67571: PPUSH
67572: CALL_OW 3
67576: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
67577: LD_ADDR_EXP 80
67581: PUSH
67582: LD_EXP 80
67586: PPUSH
67587: LD_VAR 0 2
67591: PPUSH
67592: LD_VAR 0 4
67596: PPUSH
67597: CALL_OW 1
67601: ST_TO_ADDR
// break ;
67602: GO 67606
// end ; end ;
67604: GO 67250
67606: POP
67607: POP
// end ;
67608: GO 67182
67610: POP
67611: POP
// end ;
67612: LD_VAR 0 1
67616: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
67617: LD_INT 0
67619: PPUSH
67620: PPUSH
67621: PPUSH
// if not mc_bases then
67622: LD_EXP 59
67626: NOT
67627: IFFALSE 67631
// exit ;
67629: GO 67720
// for i = 1 to mc_bases do
67631: LD_ADDR_VAR 0 2
67635: PUSH
67636: DOUBLE
67637: LD_INT 1
67639: DEC
67640: ST_TO_ADDR
67641: LD_EXP 59
67645: PUSH
67646: FOR_TO
67647: IFFALSE 67718
// begin if mc_attack [ i ] then
67649: LD_EXP 79
67653: PUSH
67654: LD_VAR 0 2
67658: ARRAY
67659: IFFALSE 67716
// begin tmp := mc_attack [ i ] [ 1 ] ;
67661: LD_ADDR_VAR 0 3
67665: PUSH
67666: LD_EXP 79
67670: PUSH
67671: LD_VAR 0 2
67675: ARRAY
67676: PUSH
67677: LD_INT 1
67679: ARRAY
67680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
67681: LD_ADDR_EXP 79
67685: PUSH
67686: LD_EXP 79
67690: PPUSH
67691: LD_VAR 0 2
67695: PPUSH
67696: EMPTY
67697: PPUSH
67698: CALL_OW 1
67702: ST_TO_ADDR
// Attack ( tmp ) ;
67703: LD_VAR 0 3
67707: PPUSH
67708: CALL 99623 0 1
// exit ;
67712: POP
67713: POP
67714: GO 67720
// end ; end ;
67716: GO 67646
67718: POP
67719: POP
// end ;
67720: LD_VAR 0 1
67724: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67725: LD_INT 0
67727: PPUSH
67728: PPUSH
67729: PPUSH
67730: PPUSH
67731: PPUSH
67732: PPUSH
67733: PPUSH
// if not mc_bases then
67734: LD_EXP 59
67738: NOT
67739: IFFALSE 67743
// exit ;
67741: GO 68442
// for i = 1 to mc_bases do
67743: LD_ADDR_VAR 0 2
67747: PUSH
67748: DOUBLE
67749: LD_INT 1
67751: DEC
67752: ST_TO_ADDR
67753: LD_EXP 59
67757: PUSH
67758: FOR_TO
67759: IFFALSE 68440
// begin if not mc_bases [ i ] then
67761: LD_EXP 59
67765: PUSH
67766: LD_VAR 0 2
67770: ARRAY
67771: NOT
67772: IFFALSE 67776
// continue ;
67774: GO 67758
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67776: LD_ADDR_VAR 0 7
67780: PUSH
67781: LD_EXP 59
67785: PUSH
67786: LD_VAR 0 2
67790: ARRAY
67791: PUSH
67792: LD_INT 1
67794: ARRAY
67795: PPUSH
67796: CALL 16143 0 1
67800: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67801: LD_ADDR_EXP 82
67805: PUSH
67806: LD_EXP 82
67810: PPUSH
67811: LD_VAR 0 2
67815: PPUSH
67816: LD_EXP 59
67820: PUSH
67821: LD_VAR 0 2
67825: ARRAY
67826: PUSH
67827: LD_INT 1
67829: ARRAY
67830: PPUSH
67831: CALL_OW 255
67835: PPUSH
67836: LD_EXP 84
67840: PUSH
67841: LD_VAR 0 2
67845: ARRAY
67846: PPUSH
67847: CALL 16108 0 2
67851: PPUSH
67852: CALL_OW 1
67856: ST_TO_ADDR
// if not mc_scan [ i ] then
67857: LD_EXP 82
67861: PUSH
67862: LD_VAR 0 2
67866: ARRAY
67867: NOT
67868: IFFALSE 68046
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67870: LD_ADDR_VAR 0 4
67874: PUSH
67875: LD_EXP 59
67879: PUSH
67880: LD_VAR 0 2
67884: ARRAY
67885: PPUSH
67886: LD_INT 2
67888: PUSH
67889: LD_INT 25
67891: PUSH
67892: LD_INT 5
67894: PUSH
67895: EMPTY
67896: LIST
67897: LIST
67898: PUSH
67899: LD_INT 25
67901: PUSH
67902: LD_INT 8
67904: PUSH
67905: EMPTY
67906: LIST
67907: LIST
67908: PUSH
67909: LD_INT 25
67911: PUSH
67912: LD_INT 9
67914: PUSH
67915: EMPTY
67916: LIST
67917: LIST
67918: PUSH
67919: EMPTY
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: PPUSH
67925: CALL_OW 72
67929: ST_TO_ADDR
// if not tmp then
67930: LD_VAR 0 4
67934: NOT
67935: IFFALSE 67939
// continue ;
67937: GO 67758
// for j in tmp do
67939: LD_ADDR_VAR 0 3
67943: PUSH
67944: LD_VAR 0 4
67948: PUSH
67949: FOR_IN
67950: IFFALSE 68021
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67952: LD_VAR 0 3
67956: PPUSH
67957: CALL_OW 310
67961: PPUSH
67962: CALL_OW 266
67966: PUSH
67967: LD_INT 5
67969: EQUAL
67970: PUSH
67971: LD_VAR 0 3
67975: PPUSH
67976: CALL_OW 257
67980: PUSH
67981: LD_INT 1
67983: EQUAL
67984: AND
67985: PUSH
67986: LD_VAR 0 3
67990: PPUSH
67991: CALL_OW 459
67995: NOT
67996: AND
67997: PUSH
67998: LD_VAR 0 7
68002: AND
68003: IFFALSE 68019
// ComChangeProfession ( j , class ) ;
68005: LD_VAR 0 3
68009: PPUSH
68010: LD_VAR 0 7
68014: PPUSH
68015: CALL_OW 123
68019: GO 67949
68021: POP
68022: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
68023: LD_ADDR_EXP 102
68027: PUSH
68028: LD_EXP 102
68032: PPUSH
68033: LD_VAR 0 2
68037: PPUSH
68038: LD_INT 0
68040: PPUSH
68041: CALL_OW 1
68045: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
68046: LD_EXP 82
68050: PUSH
68051: LD_VAR 0 2
68055: ARRAY
68056: PUSH
68057: LD_EXP 102
68061: PUSH
68062: LD_VAR 0 2
68066: ARRAY
68067: NOT
68068: AND
68069: PUSH
68070: LD_EXP 81
68074: PUSH
68075: LD_VAR 0 2
68079: ARRAY
68080: NOT
68081: AND
68082: PUSH
68083: LD_EXP 59
68087: PUSH
68088: LD_VAR 0 2
68092: ARRAY
68093: PPUSH
68094: LD_INT 30
68096: PUSH
68097: LD_INT 32
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PPUSH
68104: CALL_OW 72
68108: NOT
68109: AND
68110: PUSH
68111: LD_EXP 59
68115: PUSH
68116: LD_VAR 0 2
68120: ARRAY
68121: PPUSH
68122: LD_INT 2
68124: PUSH
68125: LD_INT 30
68127: PUSH
68128: LD_INT 4
68130: PUSH
68131: EMPTY
68132: LIST
68133: LIST
68134: PUSH
68135: LD_INT 30
68137: PUSH
68138: LD_INT 5
68140: PUSH
68141: EMPTY
68142: LIST
68143: LIST
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: LIST
68149: PPUSH
68150: CALL_OW 72
68154: NOT
68155: AND
68156: IFFALSE 68311
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
68158: LD_ADDR_VAR 0 4
68162: PUSH
68163: LD_EXP 59
68167: PUSH
68168: LD_VAR 0 2
68172: ARRAY
68173: PPUSH
68174: LD_INT 2
68176: PUSH
68177: LD_INT 25
68179: PUSH
68180: LD_INT 1
68182: PUSH
68183: EMPTY
68184: LIST
68185: LIST
68186: PUSH
68187: LD_INT 25
68189: PUSH
68190: LD_INT 5
68192: PUSH
68193: EMPTY
68194: LIST
68195: LIST
68196: PUSH
68197: LD_INT 25
68199: PUSH
68200: LD_INT 8
68202: PUSH
68203: EMPTY
68204: LIST
68205: LIST
68206: PUSH
68207: LD_INT 25
68209: PUSH
68210: LD_INT 9
68212: PUSH
68213: EMPTY
68214: LIST
68215: LIST
68216: PUSH
68217: EMPTY
68218: LIST
68219: LIST
68220: LIST
68221: LIST
68222: LIST
68223: PPUSH
68224: CALL_OW 72
68228: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
68229: LD_ADDR_VAR 0 4
68233: PUSH
68234: LD_VAR 0 4
68238: PUSH
68239: LD_VAR 0 4
68243: PPUSH
68244: LD_INT 18
68246: PPUSH
68247: CALL 48201 0 2
68251: DIFF
68252: ST_TO_ADDR
// if tmp then
68253: LD_VAR 0 4
68257: IFFALSE 68311
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68259: LD_ADDR_EXP 102
68263: PUSH
68264: LD_EXP 102
68268: PPUSH
68269: LD_VAR 0 2
68273: PPUSH
68274: LD_INT 1
68276: PPUSH
68277: CALL_OW 1
68281: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
68282: LD_VAR 0 2
68286: PPUSH
68287: LD_VAR 0 4
68291: PPUSH
68292: LD_EXP 84
68296: PUSH
68297: LD_VAR 0 2
68301: ARRAY
68302: PPUSH
68303: CALL 104332 0 3
// exit ;
68307: POP
68308: POP
68309: GO 68442
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
68311: LD_EXP 82
68315: PUSH
68316: LD_VAR 0 2
68320: ARRAY
68321: PUSH
68322: LD_EXP 102
68326: PUSH
68327: LD_VAR 0 2
68331: ARRAY
68332: NOT
68333: AND
68334: PUSH
68335: LD_EXP 81
68339: PUSH
68340: LD_VAR 0 2
68344: ARRAY
68345: AND
68346: IFFALSE 68438
// begin tmp := mc_defender [ i ] ;
68348: LD_ADDR_VAR 0 4
68352: PUSH
68353: LD_EXP 81
68357: PUSH
68358: LD_VAR 0 2
68362: ARRAY
68363: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
68364: LD_ADDR_EXP 81
68368: PUSH
68369: LD_EXP 81
68373: PPUSH
68374: LD_VAR 0 2
68378: PPUSH
68379: EMPTY
68380: PPUSH
68381: CALL_OW 1
68385: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
68386: LD_ADDR_EXP 102
68390: PUSH
68391: LD_EXP 102
68395: PPUSH
68396: LD_VAR 0 2
68400: PPUSH
68401: LD_INT 1
68403: PPUSH
68404: CALL_OW 1
68408: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
68409: LD_VAR 0 2
68413: PPUSH
68414: LD_VAR 0 4
68418: PPUSH
68419: LD_EXP 82
68423: PUSH
68424: LD_VAR 0 2
68428: ARRAY
68429: PPUSH
68430: CALL 104893 0 3
// exit ;
68434: POP
68435: POP
68436: GO 68442
// end ; end ;
68438: GO 67758
68440: POP
68441: POP
// end ;
68442: LD_VAR 0 1
68446: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
68447: LD_INT 0
68449: PPUSH
68450: PPUSH
68451: PPUSH
68452: PPUSH
68453: PPUSH
68454: PPUSH
68455: PPUSH
68456: PPUSH
68457: PPUSH
68458: PPUSH
68459: PPUSH
// if not mc_bases then
68460: LD_EXP 59
68464: NOT
68465: IFFALSE 68469
// exit ;
68467: GO 69556
// for i = 1 to mc_bases do
68469: LD_ADDR_VAR 0 2
68473: PUSH
68474: DOUBLE
68475: LD_INT 1
68477: DEC
68478: ST_TO_ADDR
68479: LD_EXP 59
68483: PUSH
68484: FOR_TO
68485: IFFALSE 69554
// begin tmp := mc_lab [ i ] ;
68487: LD_ADDR_VAR 0 6
68491: PUSH
68492: LD_EXP 92
68496: PUSH
68497: LD_VAR 0 2
68501: ARRAY
68502: ST_TO_ADDR
// if not tmp then
68503: LD_VAR 0 6
68507: NOT
68508: IFFALSE 68512
// continue ;
68510: GO 68484
// idle_lab := 0 ;
68512: LD_ADDR_VAR 0 11
68516: PUSH
68517: LD_INT 0
68519: ST_TO_ADDR
// for j in tmp do
68520: LD_ADDR_VAR 0 3
68524: PUSH
68525: LD_VAR 0 6
68529: PUSH
68530: FOR_IN
68531: IFFALSE 69550
// begin researching := false ;
68533: LD_ADDR_VAR 0 10
68537: PUSH
68538: LD_INT 0
68540: ST_TO_ADDR
// side := GetSide ( j ) ;
68541: LD_ADDR_VAR 0 4
68545: PUSH
68546: LD_VAR 0 3
68550: PPUSH
68551: CALL_OW 255
68555: ST_TO_ADDR
// if not mc_tech [ side ] then
68556: LD_EXP 86
68560: PUSH
68561: LD_VAR 0 4
68565: ARRAY
68566: NOT
68567: IFFALSE 68571
// continue ;
68569: GO 68530
// if BuildingStatus ( j ) = bs_idle then
68571: LD_VAR 0 3
68575: PPUSH
68576: CALL_OW 461
68580: PUSH
68581: LD_INT 2
68583: EQUAL
68584: IFFALSE 68772
// begin if idle_lab and UnitsInside ( j ) < 6 then
68586: LD_VAR 0 11
68590: PUSH
68591: LD_VAR 0 3
68595: PPUSH
68596: CALL_OW 313
68600: PUSH
68601: LD_INT 6
68603: LESS
68604: AND
68605: IFFALSE 68676
// begin tmp2 := UnitsInside ( idle_lab ) ;
68607: LD_ADDR_VAR 0 9
68611: PUSH
68612: LD_VAR 0 11
68616: PPUSH
68617: CALL_OW 313
68621: ST_TO_ADDR
// if tmp2 then
68622: LD_VAR 0 9
68626: IFFALSE 68668
// for x in tmp2 do
68628: LD_ADDR_VAR 0 7
68632: PUSH
68633: LD_VAR 0 9
68637: PUSH
68638: FOR_IN
68639: IFFALSE 68666
// begin ComExitBuilding ( x ) ;
68641: LD_VAR 0 7
68645: PPUSH
68646: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68650: LD_VAR 0 7
68654: PPUSH
68655: LD_VAR 0 3
68659: PPUSH
68660: CALL_OW 180
// end ;
68664: GO 68638
68666: POP
68667: POP
// idle_lab := 0 ;
68668: LD_ADDR_VAR 0 11
68672: PUSH
68673: LD_INT 0
68675: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
68676: LD_ADDR_VAR 0 5
68680: PUSH
68681: LD_EXP 86
68685: PUSH
68686: LD_VAR 0 4
68690: ARRAY
68691: PUSH
68692: FOR_IN
68693: IFFALSE 68753
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
68695: LD_VAR 0 3
68699: PPUSH
68700: LD_VAR 0 5
68704: PPUSH
68705: CALL_OW 430
68709: PUSH
68710: LD_VAR 0 4
68714: PPUSH
68715: LD_VAR 0 5
68719: PPUSH
68720: CALL 15213 0 2
68724: AND
68725: IFFALSE 68751
// begin researching := true ;
68727: LD_ADDR_VAR 0 10
68731: PUSH
68732: LD_INT 1
68734: ST_TO_ADDR
// ComResearch ( j , t ) ;
68735: LD_VAR 0 3
68739: PPUSH
68740: LD_VAR 0 5
68744: PPUSH
68745: CALL_OW 124
// break ;
68749: GO 68753
// end ;
68751: GO 68692
68753: POP
68754: POP
// if not researching then
68755: LD_VAR 0 10
68759: NOT
68760: IFFALSE 68772
// idle_lab := j ;
68762: LD_ADDR_VAR 0 11
68766: PUSH
68767: LD_VAR 0 3
68771: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
68772: LD_VAR 0 3
68776: PPUSH
68777: CALL_OW 461
68781: PUSH
68782: LD_INT 10
68784: EQUAL
68785: IFFALSE 69373
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
68787: LD_EXP 88
68791: PUSH
68792: LD_VAR 0 2
68796: ARRAY
68797: NOT
68798: PUSH
68799: LD_EXP 89
68803: PUSH
68804: LD_VAR 0 2
68808: ARRAY
68809: NOT
68810: AND
68811: PUSH
68812: LD_EXP 86
68816: PUSH
68817: LD_VAR 0 4
68821: ARRAY
68822: PUSH
68823: LD_INT 1
68825: GREATER
68826: AND
68827: IFFALSE 68958
// begin ComCancel ( j ) ;
68829: LD_VAR 0 3
68833: PPUSH
68834: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68838: LD_ADDR_EXP 86
68842: PUSH
68843: LD_EXP 86
68847: PPUSH
68848: LD_VAR 0 4
68852: PPUSH
68853: LD_EXP 86
68857: PUSH
68858: LD_VAR 0 4
68862: ARRAY
68863: PPUSH
68864: LD_EXP 86
68868: PUSH
68869: LD_VAR 0 4
68873: ARRAY
68874: PUSH
68875: LD_INT 1
68877: MINUS
68878: PPUSH
68879: LD_EXP 86
68883: PUSH
68884: LD_VAR 0 4
68888: ARRAY
68889: PPUSH
68890: LD_INT 0
68892: PPUSH
68893: CALL 18725 0 4
68897: PPUSH
68898: CALL_OW 1
68902: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68903: LD_ADDR_EXP 86
68907: PUSH
68908: LD_EXP 86
68912: PPUSH
68913: LD_VAR 0 4
68917: PPUSH
68918: LD_EXP 86
68922: PUSH
68923: LD_VAR 0 4
68927: ARRAY
68928: PPUSH
68929: LD_EXP 86
68933: PUSH
68934: LD_VAR 0 4
68938: ARRAY
68939: PPUSH
68940: LD_INT 1
68942: PPUSH
68943: LD_INT 0
68945: PPUSH
68946: CALL 18725 0 4
68950: PPUSH
68951: CALL_OW 1
68955: ST_TO_ADDR
// continue ;
68956: GO 68530
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68958: LD_EXP 88
68962: PUSH
68963: LD_VAR 0 2
68967: ARRAY
68968: PUSH
68969: LD_EXP 89
68973: PUSH
68974: LD_VAR 0 2
68978: ARRAY
68979: NOT
68980: AND
68981: IFFALSE 69108
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68983: LD_ADDR_EXP 89
68987: PUSH
68988: LD_EXP 89
68992: PPUSH
68993: LD_VAR 0 2
68997: PUSH
68998: LD_EXP 89
69002: PUSH
69003: LD_VAR 0 2
69007: ARRAY
69008: PUSH
69009: LD_INT 1
69011: PLUS
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PPUSH
69017: LD_EXP 88
69021: PUSH
69022: LD_VAR 0 2
69026: ARRAY
69027: PUSH
69028: LD_INT 1
69030: ARRAY
69031: PPUSH
69032: CALL 19307 0 3
69036: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
69037: LD_EXP 88
69041: PUSH
69042: LD_VAR 0 2
69046: ARRAY
69047: PUSH
69048: LD_INT 1
69050: ARRAY
69051: PPUSH
69052: LD_INT 112
69054: PPUSH
69055: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
69059: LD_ADDR_VAR 0 9
69063: PUSH
69064: LD_EXP 88
69068: PUSH
69069: LD_VAR 0 2
69073: ARRAY
69074: PPUSH
69075: LD_INT 1
69077: PPUSH
69078: CALL_OW 3
69082: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
69083: LD_ADDR_EXP 88
69087: PUSH
69088: LD_EXP 88
69092: PPUSH
69093: LD_VAR 0 2
69097: PPUSH
69098: LD_VAR 0 9
69102: PPUSH
69103: CALL_OW 1
69107: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
69108: LD_EXP 88
69112: PUSH
69113: LD_VAR 0 2
69117: ARRAY
69118: PUSH
69119: LD_EXP 89
69123: PUSH
69124: LD_VAR 0 2
69128: ARRAY
69129: AND
69130: PUSH
69131: LD_EXP 89
69135: PUSH
69136: LD_VAR 0 2
69140: ARRAY
69141: PUSH
69142: LD_INT 1
69144: ARRAY
69145: PPUSH
69146: CALL_OW 310
69150: NOT
69151: AND
69152: PUSH
69153: LD_VAR 0 3
69157: PPUSH
69158: CALL_OW 313
69162: PUSH
69163: LD_INT 6
69165: EQUAL
69166: AND
69167: IFFALSE 69223
// begin tmp2 := UnitsInside ( j ) ;
69169: LD_ADDR_VAR 0 9
69173: PUSH
69174: LD_VAR 0 3
69178: PPUSH
69179: CALL_OW 313
69183: ST_TO_ADDR
// if tmp2 = 6 then
69184: LD_VAR 0 9
69188: PUSH
69189: LD_INT 6
69191: EQUAL
69192: IFFALSE 69223
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
69194: LD_VAR 0 9
69198: PUSH
69199: LD_INT 1
69201: ARRAY
69202: PPUSH
69203: LD_INT 112
69205: PPUSH
69206: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
69210: LD_VAR 0 9
69214: PUSH
69215: LD_INT 1
69217: ARRAY
69218: PPUSH
69219: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
69223: LD_EXP 89
69227: PUSH
69228: LD_VAR 0 2
69232: ARRAY
69233: PUSH
69234: LD_EXP 89
69238: PUSH
69239: LD_VAR 0 2
69243: ARRAY
69244: PUSH
69245: LD_INT 1
69247: ARRAY
69248: PPUSH
69249: CALL_OW 314
69253: NOT
69254: AND
69255: PUSH
69256: LD_EXP 89
69260: PUSH
69261: LD_VAR 0 2
69265: ARRAY
69266: PUSH
69267: LD_INT 1
69269: ARRAY
69270: PPUSH
69271: CALL_OW 310
69275: NOT
69276: AND
69277: IFFALSE 69303
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
69279: LD_EXP 89
69283: PUSH
69284: LD_VAR 0 2
69288: ARRAY
69289: PUSH
69290: LD_INT 1
69292: ARRAY
69293: PPUSH
69294: LD_VAR 0 3
69298: PPUSH
69299: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
69303: LD_EXP 89
69307: PUSH
69308: LD_VAR 0 2
69312: ARRAY
69313: PUSH
69314: LD_INT 1
69316: ARRAY
69317: PPUSH
69318: CALL_OW 310
69322: PUSH
69323: LD_EXP 89
69327: PUSH
69328: LD_VAR 0 2
69332: ARRAY
69333: PUSH
69334: LD_INT 1
69336: ARRAY
69337: PPUSH
69338: CALL_OW 310
69342: PPUSH
69343: CALL_OW 461
69347: PUSH
69348: LD_INT 3
69350: NONEQUAL
69351: AND
69352: IFFALSE 69373
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
69354: LD_EXP 89
69358: PUSH
69359: LD_VAR 0 2
69363: ARRAY
69364: PUSH
69365: LD_INT 1
69367: ARRAY
69368: PPUSH
69369: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
69373: LD_VAR 0 3
69377: PPUSH
69378: CALL_OW 461
69382: PUSH
69383: LD_INT 6
69385: EQUAL
69386: PUSH
69387: LD_VAR 0 6
69391: PUSH
69392: LD_INT 1
69394: GREATER
69395: AND
69396: IFFALSE 69548
// begin sci := [ ] ;
69398: LD_ADDR_VAR 0 8
69402: PUSH
69403: EMPTY
69404: ST_TO_ADDR
// for x in ( tmp diff j ) do
69405: LD_ADDR_VAR 0 7
69409: PUSH
69410: LD_VAR 0 6
69414: PUSH
69415: LD_VAR 0 3
69419: DIFF
69420: PUSH
69421: FOR_IN
69422: IFFALSE 69474
// begin if sci = 6 then
69424: LD_VAR 0 8
69428: PUSH
69429: LD_INT 6
69431: EQUAL
69432: IFFALSE 69436
// break ;
69434: GO 69474
// if BuildingStatus ( x ) = bs_idle then
69436: LD_VAR 0 7
69440: PPUSH
69441: CALL_OW 461
69445: PUSH
69446: LD_INT 2
69448: EQUAL
69449: IFFALSE 69472
// sci := sci ^ UnitsInside ( x ) ;
69451: LD_ADDR_VAR 0 8
69455: PUSH
69456: LD_VAR 0 8
69460: PUSH
69461: LD_VAR 0 7
69465: PPUSH
69466: CALL_OW 313
69470: ADD
69471: ST_TO_ADDR
// end ;
69472: GO 69421
69474: POP
69475: POP
// if not sci then
69476: LD_VAR 0 8
69480: NOT
69481: IFFALSE 69485
// continue ;
69483: GO 68530
// for x in sci do
69485: LD_ADDR_VAR 0 7
69489: PUSH
69490: LD_VAR 0 8
69494: PUSH
69495: FOR_IN
69496: IFFALSE 69546
// if IsInUnit ( x ) and not HasTask ( x ) then
69498: LD_VAR 0 7
69502: PPUSH
69503: CALL_OW 310
69507: PUSH
69508: LD_VAR 0 7
69512: PPUSH
69513: CALL_OW 314
69517: NOT
69518: AND
69519: IFFALSE 69544
// begin ComExitBuilding ( x ) ;
69521: LD_VAR 0 7
69525: PPUSH
69526: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
69530: LD_VAR 0 7
69534: PPUSH
69535: LD_VAR 0 3
69539: PPUSH
69540: CALL_OW 180
// end ;
69544: GO 69495
69546: POP
69547: POP
// end ; end ;
69548: GO 68530
69550: POP
69551: POP
// end ;
69552: GO 68484
69554: POP
69555: POP
// end ;
69556: LD_VAR 0 1
69560: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
69561: LD_INT 0
69563: PPUSH
69564: PPUSH
// if not mc_bases then
69565: LD_EXP 59
69569: NOT
69570: IFFALSE 69574
// exit ;
69572: GO 69655
// for i = 1 to mc_bases do
69574: LD_ADDR_VAR 0 2
69578: PUSH
69579: DOUBLE
69580: LD_INT 1
69582: DEC
69583: ST_TO_ADDR
69584: LD_EXP 59
69588: PUSH
69589: FOR_TO
69590: IFFALSE 69653
// if mc_mines [ i ] and mc_miners [ i ] then
69592: LD_EXP 72
69596: PUSH
69597: LD_VAR 0 2
69601: ARRAY
69602: PUSH
69603: LD_EXP 73
69607: PUSH
69608: LD_VAR 0 2
69612: ARRAY
69613: AND
69614: IFFALSE 69651
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
69616: LD_EXP 73
69620: PUSH
69621: LD_VAR 0 2
69625: ARRAY
69626: PUSH
69627: LD_INT 1
69629: ARRAY
69630: PPUSH
69631: CALL_OW 255
69635: PPUSH
69636: LD_EXP 72
69640: PUSH
69641: LD_VAR 0 2
69645: ARRAY
69646: PPUSH
69647: CALL 16296 0 2
69651: GO 69589
69653: POP
69654: POP
// end ;
69655: LD_VAR 0 1
69659: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
69660: LD_INT 0
69662: PPUSH
69663: PPUSH
69664: PPUSH
69665: PPUSH
69666: PPUSH
69667: PPUSH
69668: PPUSH
69669: PPUSH
// if not mc_bases or not mc_parking then
69670: LD_EXP 59
69674: NOT
69675: PUSH
69676: LD_EXP 83
69680: NOT
69681: OR
69682: IFFALSE 69686
// exit ;
69684: GO 70385
// for i = 1 to mc_bases do
69686: LD_ADDR_VAR 0 2
69690: PUSH
69691: DOUBLE
69692: LD_INT 1
69694: DEC
69695: ST_TO_ADDR
69696: LD_EXP 59
69700: PUSH
69701: FOR_TO
69702: IFFALSE 70383
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
69704: LD_EXP 59
69708: PUSH
69709: LD_VAR 0 2
69713: ARRAY
69714: NOT
69715: PUSH
69716: LD_EXP 83
69720: PUSH
69721: LD_VAR 0 2
69725: ARRAY
69726: NOT
69727: OR
69728: IFFALSE 69732
// continue ;
69730: GO 69701
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
69732: LD_ADDR_VAR 0 5
69736: PUSH
69737: LD_EXP 59
69741: PUSH
69742: LD_VAR 0 2
69746: ARRAY
69747: PUSH
69748: LD_INT 1
69750: ARRAY
69751: PPUSH
69752: CALL_OW 255
69756: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69757: LD_ADDR_VAR 0 6
69761: PUSH
69762: LD_EXP 59
69766: PUSH
69767: LD_VAR 0 2
69771: ARRAY
69772: PPUSH
69773: LD_INT 30
69775: PUSH
69776: LD_INT 3
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PPUSH
69783: CALL_OW 72
69787: ST_TO_ADDR
// if not fac then
69788: LD_VAR 0 6
69792: NOT
69793: IFFALSE 69844
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69795: LD_ADDR_VAR 0 6
69799: PUSH
69800: LD_EXP 59
69804: PUSH
69805: LD_VAR 0 2
69809: ARRAY
69810: PPUSH
69811: LD_INT 2
69813: PUSH
69814: LD_INT 30
69816: PUSH
69817: LD_INT 0
69819: PUSH
69820: EMPTY
69821: LIST
69822: LIST
69823: PUSH
69824: LD_INT 30
69826: PUSH
69827: LD_INT 1
69829: PUSH
69830: EMPTY
69831: LIST
69832: LIST
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: LIST
69838: PPUSH
69839: CALL_OW 72
69843: ST_TO_ADDR
// if not fac then
69844: LD_VAR 0 6
69848: NOT
69849: IFFALSE 69853
// continue ;
69851: GO 69701
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69853: LD_ADDR_VAR 0 7
69857: PUSH
69858: LD_EXP 83
69862: PUSH
69863: LD_VAR 0 2
69867: ARRAY
69868: PPUSH
69869: LD_INT 22
69871: PUSH
69872: LD_VAR 0 5
69876: PUSH
69877: EMPTY
69878: LIST
69879: LIST
69880: PUSH
69881: LD_INT 21
69883: PUSH
69884: LD_INT 2
69886: PUSH
69887: EMPTY
69888: LIST
69889: LIST
69890: PUSH
69891: LD_INT 3
69893: PUSH
69894: LD_INT 24
69896: PUSH
69897: LD_INT 1000
69899: PUSH
69900: EMPTY
69901: LIST
69902: LIST
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: LIST
69912: PPUSH
69913: CALL_OW 70
69917: ST_TO_ADDR
// for j in fac do
69918: LD_ADDR_VAR 0 3
69922: PUSH
69923: LD_VAR 0 6
69927: PUSH
69928: FOR_IN
69929: IFFALSE 70010
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69931: LD_ADDR_VAR 0 7
69935: PUSH
69936: LD_VAR 0 7
69940: PUSH
69941: LD_INT 22
69943: PUSH
69944: LD_VAR 0 5
69948: PUSH
69949: EMPTY
69950: LIST
69951: LIST
69952: PUSH
69953: LD_INT 91
69955: PUSH
69956: LD_VAR 0 3
69960: PUSH
69961: LD_INT 15
69963: PUSH
69964: EMPTY
69965: LIST
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 21
69971: PUSH
69972: LD_INT 2
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 3
69981: PUSH
69982: LD_INT 24
69984: PUSH
69985: LD_INT 1000
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: EMPTY
69993: LIST
69994: LIST
69995: PUSH
69996: EMPTY
69997: LIST
69998: LIST
69999: LIST
70000: LIST
70001: PPUSH
70002: CALL_OW 69
70006: UNION
70007: ST_TO_ADDR
70008: GO 69928
70010: POP
70011: POP
// if not vehs then
70012: LD_VAR 0 7
70016: NOT
70017: IFFALSE 70043
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
70019: LD_ADDR_EXP 71
70023: PUSH
70024: LD_EXP 71
70028: PPUSH
70029: LD_VAR 0 2
70033: PPUSH
70034: EMPTY
70035: PPUSH
70036: CALL_OW 1
70040: ST_TO_ADDR
// continue ;
70041: GO 69701
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
70043: LD_ADDR_VAR 0 8
70047: PUSH
70048: LD_EXP 59
70052: PUSH
70053: LD_VAR 0 2
70057: ARRAY
70058: PPUSH
70059: LD_INT 30
70061: PUSH
70062: LD_INT 3
70064: PUSH
70065: EMPTY
70066: LIST
70067: LIST
70068: PPUSH
70069: CALL_OW 72
70073: ST_TO_ADDR
// if tmp then
70074: LD_VAR 0 8
70078: IFFALSE 70181
// begin for j in tmp do
70080: LD_ADDR_VAR 0 3
70084: PUSH
70085: LD_VAR 0 8
70089: PUSH
70090: FOR_IN
70091: IFFALSE 70179
// for k in UnitsInside ( j ) do
70093: LD_ADDR_VAR 0 4
70097: PUSH
70098: LD_VAR 0 3
70102: PPUSH
70103: CALL_OW 313
70107: PUSH
70108: FOR_IN
70109: IFFALSE 70175
// if k then
70111: LD_VAR 0 4
70115: IFFALSE 70173
// if not k in mc_repair_vehicle [ i ] then
70117: LD_VAR 0 4
70121: PUSH
70122: LD_EXP 71
70126: PUSH
70127: LD_VAR 0 2
70131: ARRAY
70132: IN
70133: NOT
70134: IFFALSE 70173
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
70136: LD_ADDR_EXP 71
70140: PUSH
70141: LD_EXP 71
70145: PPUSH
70146: LD_VAR 0 2
70150: PPUSH
70151: LD_EXP 71
70155: PUSH
70156: LD_VAR 0 2
70160: ARRAY
70161: PUSH
70162: LD_VAR 0 4
70166: UNION
70167: PPUSH
70168: CALL_OW 1
70172: ST_TO_ADDR
70173: GO 70108
70175: POP
70176: POP
70177: GO 70090
70179: POP
70180: POP
// end ; if not mc_repair_vehicle [ i ] then
70181: LD_EXP 71
70185: PUSH
70186: LD_VAR 0 2
70190: ARRAY
70191: NOT
70192: IFFALSE 70196
// continue ;
70194: GO 69701
// for j in mc_repair_vehicle [ i ] do
70196: LD_ADDR_VAR 0 3
70200: PUSH
70201: LD_EXP 71
70205: PUSH
70206: LD_VAR 0 2
70210: ARRAY
70211: PUSH
70212: FOR_IN
70213: IFFALSE 70379
// begin if GetClass ( j ) <> 3 then
70215: LD_VAR 0 3
70219: PPUSH
70220: CALL_OW 257
70224: PUSH
70225: LD_INT 3
70227: NONEQUAL
70228: IFFALSE 70269
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
70230: LD_ADDR_EXP 71
70234: PUSH
70235: LD_EXP 71
70239: PPUSH
70240: LD_VAR 0 2
70244: PPUSH
70245: LD_EXP 71
70249: PUSH
70250: LD_VAR 0 2
70254: ARRAY
70255: PUSH
70256: LD_VAR 0 3
70260: DIFF
70261: PPUSH
70262: CALL_OW 1
70266: ST_TO_ADDR
// continue ;
70267: GO 70212
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70269: LD_VAR 0 3
70273: PPUSH
70274: CALL_OW 311
70278: NOT
70279: PUSH
70280: LD_VAR 0 3
70284: PUSH
70285: LD_EXP 62
70289: PUSH
70290: LD_VAR 0 2
70294: ARRAY
70295: PUSH
70296: LD_INT 1
70298: ARRAY
70299: IN
70300: NOT
70301: AND
70302: PUSH
70303: LD_VAR 0 3
70307: PUSH
70308: LD_EXP 62
70312: PUSH
70313: LD_VAR 0 2
70317: ARRAY
70318: PUSH
70319: LD_INT 2
70321: ARRAY
70322: IN
70323: NOT
70324: AND
70325: IFFALSE 70377
// begin if IsInUnit ( j ) then
70327: LD_VAR 0 3
70331: PPUSH
70332: CALL_OW 310
70336: IFFALSE 70347
// ComExitBuilding ( j ) ;
70338: LD_VAR 0 3
70342: PPUSH
70343: CALL_OW 122
// if not HasTask ( j ) then
70347: LD_VAR 0 3
70351: PPUSH
70352: CALL_OW 314
70356: NOT
70357: IFFALSE 70377
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
70359: LD_VAR 0 3
70363: PPUSH
70364: LD_VAR 0 7
70368: PUSH
70369: LD_INT 1
70371: ARRAY
70372: PPUSH
70373: CALL_OW 189
// end ; end ;
70377: GO 70212
70379: POP
70380: POP
// end ;
70381: GO 69701
70383: POP
70384: POP
// end ;
70385: LD_VAR 0 1
70389: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
70390: LD_INT 0
70392: PPUSH
70393: PPUSH
70394: PPUSH
70395: PPUSH
70396: PPUSH
70397: PPUSH
70398: PPUSH
70399: PPUSH
70400: PPUSH
70401: PPUSH
70402: PPUSH
// if not mc_bases then
70403: LD_EXP 59
70407: NOT
70408: IFFALSE 70412
// exit ;
70410: GO 71214
// for i = 1 to mc_bases do
70412: LD_ADDR_VAR 0 2
70416: PUSH
70417: DOUBLE
70418: LD_INT 1
70420: DEC
70421: ST_TO_ADDR
70422: LD_EXP 59
70426: PUSH
70427: FOR_TO
70428: IFFALSE 71212
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
70430: LD_EXP 87
70434: PUSH
70435: LD_VAR 0 2
70439: ARRAY
70440: NOT
70441: PUSH
70442: LD_EXP 62
70446: PUSH
70447: LD_VAR 0 2
70451: ARRAY
70452: PUSH
70453: LD_INT 1
70455: ARRAY
70456: OR
70457: PUSH
70458: LD_EXP 62
70462: PUSH
70463: LD_VAR 0 2
70467: ARRAY
70468: PUSH
70469: LD_INT 2
70471: ARRAY
70472: OR
70473: PUSH
70474: LD_EXP 85
70478: PUSH
70479: LD_VAR 0 2
70483: ARRAY
70484: PPUSH
70485: LD_INT 1
70487: PPUSH
70488: CALL_OW 325
70492: NOT
70493: OR
70494: PUSH
70495: LD_EXP 82
70499: PUSH
70500: LD_VAR 0 2
70504: ARRAY
70505: OR
70506: IFFALSE 70510
// continue ;
70508: GO 70427
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
70510: LD_ADDR_VAR 0 8
70514: PUSH
70515: LD_EXP 59
70519: PUSH
70520: LD_VAR 0 2
70524: ARRAY
70525: PPUSH
70526: LD_INT 25
70528: PUSH
70529: LD_INT 4
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: LD_INT 50
70538: PUSH
70539: EMPTY
70540: LIST
70541: PUSH
70542: LD_INT 3
70544: PUSH
70545: LD_INT 60
70547: PUSH
70548: EMPTY
70549: LIST
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: LIST
70559: PPUSH
70560: CALL_OW 72
70564: PUSH
70565: LD_EXP 63
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: DIFF
70576: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70577: LD_ADDR_VAR 0 9
70581: PUSH
70582: LD_EXP 59
70586: PUSH
70587: LD_VAR 0 2
70591: ARRAY
70592: PPUSH
70593: LD_INT 2
70595: PUSH
70596: LD_INT 30
70598: PUSH
70599: LD_INT 0
70601: PUSH
70602: EMPTY
70603: LIST
70604: LIST
70605: PUSH
70606: LD_INT 30
70608: PUSH
70609: LD_INT 1
70611: PUSH
70612: EMPTY
70613: LIST
70614: LIST
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: LIST
70620: PPUSH
70621: CALL_OW 72
70625: ST_TO_ADDR
// if not tmp or not dep then
70626: LD_VAR 0 8
70630: NOT
70631: PUSH
70632: LD_VAR 0 9
70636: NOT
70637: OR
70638: IFFALSE 70642
// continue ;
70640: GO 70427
// side := GetSide ( tmp [ 1 ] ) ;
70642: LD_ADDR_VAR 0 11
70646: PUSH
70647: LD_VAR 0 8
70651: PUSH
70652: LD_INT 1
70654: ARRAY
70655: PPUSH
70656: CALL_OW 255
70660: ST_TO_ADDR
// dep := dep [ 1 ] ;
70661: LD_ADDR_VAR 0 9
70665: PUSH
70666: LD_VAR 0 9
70670: PUSH
70671: LD_INT 1
70673: ARRAY
70674: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
70675: LD_ADDR_VAR 0 7
70679: PUSH
70680: LD_EXP 87
70684: PUSH
70685: LD_VAR 0 2
70689: ARRAY
70690: PPUSH
70691: LD_INT 22
70693: PUSH
70694: LD_INT 0
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 25
70703: PUSH
70704: LD_INT 12
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: EMPTY
70712: LIST
70713: LIST
70714: PPUSH
70715: CALL_OW 70
70719: PUSH
70720: LD_INT 22
70722: PUSH
70723: LD_INT 0
70725: PUSH
70726: EMPTY
70727: LIST
70728: LIST
70729: PUSH
70730: LD_INT 25
70732: PUSH
70733: LD_INT 12
70735: PUSH
70736: EMPTY
70737: LIST
70738: LIST
70739: PUSH
70740: LD_INT 91
70742: PUSH
70743: LD_VAR 0 9
70747: PUSH
70748: LD_INT 20
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: LIST
70755: PUSH
70756: EMPTY
70757: LIST
70758: LIST
70759: LIST
70760: PPUSH
70761: CALL_OW 69
70765: UNION
70766: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
70767: LD_ADDR_VAR 0 10
70771: PUSH
70772: LD_EXP 87
70776: PUSH
70777: LD_VAR 0 2
70781: ARRAY
70782: PPUSH
70783: LD_INT 81
70785: PUSH
70786: LD_VAR 0 11
70790: PUSH
70791: EMPTY
70792: LIST
70793: LIST
70794: PPUSH
70795: CALL_OW 70
70799: ST_TO_ADDR
// if not apes or danger_at_area then
70800: LD_VAR 0 7
70804: NOT
70805: PUSH
70806: LD_VAR 0 10
70810: OR
70811: IFFALSE 70861
// begin if mc_taming [ i ] then
70813: LD_EXP 90
70817: PUSH
70818: LD_VAR 0 2
70822: ARRAY
70823: IFFALSE 70859
// begin MC_Reset ( i , 121 ) ;
70825: LD_VAR 0 2
70829: PPUSH
70830: LD_INT 121
70832: PPUSH
70833: CALL 56148 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70837: LD_ADDR_EXP 90
70841: PUSH
70842: LD_EXP 90
70846: PPUSH
70847: LD_VAR 0 2
70851: PPUSH
70852: EMPTY
70853: PPUSH
70854: CALL_OW 1
70858: ST_TO_ADDR
// end ; continue ;
70859: GO 70427
// end ; for j in tmp do
70861: LD_ADDR_VAR 0 3
70865: PUSH
70866: LD_VAR 0 8
70870: PUSH
70871: FOR_IN
70872: IFFALSE 71208
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70874: LD_VAR 0 3
70878: PUSH
70879: LD_EXP 90
70883: PUSH
70884: LD_VAR 0 2
70888: ARRAY
70889: IN
70890: NOT
70891: PUSH
70892: LD_EXP 90
70896: PUSH
70897: LD_VAR 0 2
70901: ARRAY
70902: PUSH
70903: LD_INT 3
70905: LESS
70906: AND
70907: IFFALSE 70965
// begin SetTag ( j , 121 ) ;
70909: LD_VAR 0 3
70913: PPUSH
70914: LD_INT 121
70916: PPUSH
70917: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70921: LD_ADDR_EXP 90
70925: PUSH
70926: LD_EXP 90
70930: PPUSH
70931: LD_VAR 0 2
70935: PUSH
70936: LD_EXP 90
70940: PUSH
70941: LD_VAR 0 2
70945: ARRAY
70946: PUSH
70947: LD_INT 1
70949: PLUS
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PPUSH
70955: LD_VAR 0 3
70959: PPUSH
70960: CALL 19307 0 3
70964: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70965: LD_VAR 0 3
70969: PUSH
70970: LD_EXP 90
70974: PUSH
70975: LD_VAR 0 2
70979: ARRAY
70980: IN
70981: IFFALSE 71206
// begin if GetClass ( j ) <> 4 then
70983: LD_VAR 0 3
70987: PPUSH
70988: CALL_OW 257
70992: PUSH
70993: LD_INT 4
70995: NONEQUAL
70996: IFFALSE 71049
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70998: LD_ADDR_EXP 90
71002: PUSH
71003: LD_EXP 90
71007: PPUSH
71008: LD_VAR 0 2
71012: PPUSH
71013: LD_EXP 90
71017: PUSH
71018: LD_VAR 0 2
71022: ARRAY
71023: PUSH
71024: LD_VAR 0 3
71028: DIFF
71029: PPUSH
71030: CALL_OW 1
71034: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71035: LD_VAR 0 3
71039: PPUSH
71040: LD_INT 0
71042: PPUSH
71043: CALL_OW 109
// continue ;
71047: GO 70871
// end ; if IsInUnit ( j ) then
71049: LD_VAR 0 3
71053: PPUSH
71054: CALL_OW 310
71058: IFFALSE 71069
// ComExitBuilding ( j ) ;
71060: LD_VAR 0 3
71064: PPUSH
71065: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
71069: LD_ADDR_VAR 0 6
71073: PUSH
71074: LD_VAR 0 7
71078: PPUSH
71079: LD_VAR 0 3
71083: PPUSH
71084: CALL_OW 74
71088: ST_TO_ADDR
// if not ape then
71089: LD_VAR 0 6
71093: NOT
71094: IFFALSE 71098
// break ;
71096: GO 71208
// x := GetX ( ape ) ;
71098: LD_ADDR_VAR 0 4
71102: PUSH
71103: LD_VAR 0 6
71107: PPUSH
71108: CALL_OW 250
71112: ST_TO_ADDR
// y := GetY ( ape ) ;
71113: LD_ADDR_VAR 0 5
71117: PUSH
71118: LD_VAR 0 6
71122: PPUSH
71123: CALL_OW 251
71127: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
71128: LD_VAR 0 4
71132: PPUSH
71133: LD_VAR 0 5
71137: PPUSH
71138: CALL_OW 488
71142: NOT
71143: PUSH
71144: LD_VAR 0 11
71148: PPUSH
71149: LD_VAR 0 4
71153: PPUSH
71154: LD_VAR 0 5
71158: PPUSH
71159: LD_INT 20
71161: PPUSH
71162: CALL 20203 0 4
71166: PUSH
71167: LD_INT 4
71169: ARRAY
71170: OR
71171: IFFALSE 71175
// break ;
71173: GO 71208
// if not HasTask ( j ) then
71175: LD_VAR 0 3
71179: PPUSH
71180: CALL_OW 314
71184: NOT
71185: IFFALSE 71206
// ComTameXY ( j , x , y ) ;
71187: LD_VAR 0 3
71191: PPUSH
71192: LD_VAR 0 4
71196: PPUSH
71197: LD_VAR 0 5
71201: PPUSH
71202: CALL_OW 131
// end ; end ;
71206: GO 70871
71208: POP
71209: POP
// end ;
71210: GO 70427
71212: POP
71213: POP
// end ;
71214: LD_VAR 0 1
71218: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
71219: LD_INT 0
71221: PPUSH
71222: PPUSH
71223: PPUSH
71224: PPUSH
71225: PPUSH
71226: PPUSH
71227: PPUSH
71228: PPUSH
// if not mc_bases then
71229: LD_EXP 59
71233: NOT
71234: IFFALSE 71238
// exit ;
71236: GO 71864
// for i = 1 to mc_bases do
71238: LD_ADDR_VAR 0 2
71242: PUSH
71243: DOUBLE
71244: LD_INT 1
71246: DEC
71247: ST_TO_ADDR
71248: LD_EXP 59
71252: PUSH
71253: FOR_TO
71254: IFFALSE 71862
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
71256: LD_EXP 88
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: NOT
71267: PUSH
71268: LD_EXP 88
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PPUSH
71279: LD_INT 25
71281: PUSH
71282: LD_INT 12
71284: PUSH
71285: EMPTY
71286: LIST
71287: LIST
71288: PPUSH
71289: CALL_OW 72
71293: NOT
71294: OR
71295: IFFALSE 71299
// continue ;
71297: GO 71253
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
71299: LD_ADDR_VAR 0 5
71303: PUSH
71304: LD_EXP 88
71308: PUSH
71309: LD_VAR 0 2
71313: ARRAY
71314: PUSH
71315: LD_INT 1
71317: ARRAY
71318: PPUSH
71319: CALL_OW 255
71323: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
71324: LD_VAR 0 5
71328: PPUSH
71329: LD_INT 2
71331: PPUSH
71332: CALL_OW 325
71336: IFFALSE 71589
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71338: LD_ADDR_VAR 0 4
71342: PUSH
71343: LD_EXP 88
71347: PUSH
71348: LD_VAR 0 2
71352: ARRAY
71353: PPUSH
71354: LD_INT 25
71356: PUSH
71357: LD_INT 16
71359: PUSH
71360: EMPTY
71361: LIST
71362: LIST
71363: PPUSH
71364: CALL_OW 72
71368: ST_TO_ADDR
// if tmp < 6 then
71369: LD_VAR 0 4
71373: PUSH
71374: LD_INT 6
71376: LESS
71377: IFFALSE 71589
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71379: LD_ADDR_VAR 0 6
71383: PUSH
71384: LD_EXP 59
71388: PUSH
71389: LD_VAR 0 2
71393: ARRAY
71394: PPUSH
71395: LD_INT 2
71397: PUSH
71398: LD_INT 30
71400: PUSH
71401: LD_INT 0
71403: PUSH
71404: EMPTY
71405: LIST
71406: LIST
71407: PUSH
71408: LD_INT 30
71410: PUSH
71411: LD_INT 1
71413: PUSH
71414: EMPTY
71415: LIST
71416: LIST
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: LIST
71422: PPUSH
71423: CALL_OW 72
71427: ST_TO_ADDR
// if depot then
71428: LD_VAR 0 6
71432: IFFALSE 71589
// begin selected := 0 ;
71434: LD_ADDR_VAR 0 7
71438: PUSH
71439: LD_INT 0
71441: ST_TO_ADDR
// for j in depot do
71442: LD_ADDR_VAR 0 3
71446: PUSH
71447: LD_VAR 0 6
71451: PUSH
71452: FOR_IN
71453: IFFALSE 71484
// begin if UnitsInside ( j ) < 6 then
71455: LD_VAR 0 3
71459: PPUSH
71460: CALL_OW 313
71464: PUSH
71465: LD_INT 6
71467: LESS
71468: IFFALSE 71482
// begin selected := j ;
71470: LD_ADDR_VAR 0 7
71474: PUSH
71475: LD_VAR 0 3
71479: ST_TO_ADDR
// break ;
71480: GO 71484
// end ; end ;
71482: GO 71452
71484: POP
71485: POP
// if selected then
71486: LD_VAR 0 7
71490: IFFALSE 71589
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71492: LD_ADDR_VAR 0 3
71496: PUSH
71497: LD_EXP 88
71501: PUSH
71502: LD_VAR 0 2
71506: ARRAY
71507: PPUSH
71508: LD_INT 25
71510: PUSH
71511: LD_INT 12
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PPUSH
71518: CALL_OW 72
71522: PUSH
71523: FOR_IN
71524: IFFALSE 71587
// if not HasTask ( j ) then
71526: LD_VAR 0 3
71530: PPUSH
71531: CALL_OW 314
71535: NOT
71536: IFFALSE 71585
// begin if not IsInUnit ( j ) then
71538: LD_VAR 0 3
71542: PPUSH
71543: CALL_OW 310
71547: NOT
71548: IFFALSE 71564
// ComEnterUnit ( j , selected ) ;
71550: LD_VAR 0 3
71554: PPUSH
71555: LD_VAR 0 7
71559: PPUSH
71560: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
71564: LD_VAR 0 3
71568: PPUSH
71569: LD_INT 16
71571: PPUSH
71572: CALL_OW 183
// AddComExitBuilding ( j ) ;
71576: LD_VAR 0 3
71580: PPUSH
71581: CALL_OW 182
// end ;
71585: GO 71523
71587: POP
71588: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
71589: LD_VAR 0 5
71593: PPUSH
71594: LD_INT 11
71596: PPUSH
71597: CALL_OW 325
71601: IFFALSE 71860
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
71603: LD_ADDR_VAR 0 4
71607: PUSH
71608: LD_EXP 88
71612: PUSH
71613: LD_VAR 0 2
71617: ARRAY
71618: PPUSH
71619: LD_INT 25
71621: PUSH
71622: LD_INT 16
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PPUSH
71629: CALL_OW 72
71633: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
71634: LD_VAR 0 4
71638: PUSH
71639: LD_INT 6
71641: GREATEREQUAL
71642: PUSH
71643: LD_VAR 0 5
71647: PPUSH
71648: LD_INT 2
71650: PPUSH
71651: CALL_OW 325
71655: NOT
71656: OR
71657: IFFALSE 71860
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
71659: LD_ADDR_VAR 0 8
71663: PUSH
71664: LD_EXP 59
71668: PUSH
71669: LD_VAR 0 2
71673: ARRAY
71674: PPUSH
71675: LD_INT 2
71677: PUSH
71678: LD_INT 30
71680: PUSH
71681: LD_INT 4
71683: PUSH
71684: EMPTY
71685: LIST
71686: LIST
71687: PUSH
71688: LD_INT 30
71690: PUSH
71691: LD_INT 5
71693: PUSH
71694: EMPTY
71695: LIST
71696: LIST
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: LIST
71702: PPUSH
71703: CALL_OW 72
71707: ST_TO_ADDR
// if barracks then
71708: LD_VAR 0 8
71712: IFFALSE 71860
// begin selected := 0 ;
71714: LD_ADDR_VAR 0 7
71718: PUSH
71719: LD_INT 0
71721: ST_TO_ADDR
// for j in barracks do
71722: LD_ADDR_VAR 0 3
71726: PUSH
71727: LD_VAR 0 8
71731: PUSH
71732: FOR_IN
71733: IFFALSE 71764
// begin if UnitsInside ( j ) < 6 then
71735: LD_VAR 0 3
71739: PPUSH
71740: CALL_OW 313
71744: PUSH
71745: LD_INT 6
71747: LESS
71748: IFFALSE 71762
// begin selected := j ;
71750: LD_ADDR_VAR 0 7
71754: PUSH
71755: LD_VAR 0 3
71759: ST_TO_ADDR
// break ;
71760: GO 71764
// end ; end ;
71762: GO 71732
71764: POP
71765: POP
// if selected then
71766: LD_VAR 0 7
71770: IFFALSE 71860
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
71772: LD_ADDR_VAR 0 3
71776: PUSH
71777: LD_EXP 88
71781: PUSH
71782: LD_VAR 0 2
71786: ARRAY
71787: PPUSH
71788: LD_INT 25
71790: PUSH
71791: LD_INT 12
71793: PUSH
71794: EMPTY
71795: LIST
71796: LIST
71797: PPUSH
71798: CALL_OW 72
71802: PUSH
71803: FOR_IN
71804: IFFALSE 71858
// if not IsInUnit ( j ) and not HasTask ( j ) then
71806: LD_VAR 0 3
71810: PPUSH
71811: CALL_OW 310
71815: NOT
71816: PUSH
71817: LD_VAR 0 3
71821: PPUSH
71822: CALL_OW 314
71826: NOT
71827: AND
71828: IFFALSE 71856
// begin ComEnterUnit ( j , selected ) ;
71830: LD_VAR 0 3
71834: PPUSH
71835: LD_VAR 0 7
71839: PPUSH
71840: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71844: LD_VAR 0 3
71848: PPUSH
71849: LD_INT 15
71851: PPUSH
71852: CALL_OW 183
// end ;
71856: GO 71803
71858: POP
71859: POP
// end ; end ; end ; end ; end ;
71860: GO 71253
71862: POP
71863: POP
// end ;
71864: LD_VAR 0 1
71868: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71869: LD_INT 0
71871: PPUSH
71872: PPUSH
71873: PPUSH
71874: PPUSH
// if not mc_bases then
71875: LD_EXP 59
71879: NOT
71880: IFFALSE 71884
// exit ;
71882: GO 72062
// for i = 1 to mc_bases do
71884: LD_ADDR_VAR 0 2
71888: PUSH
71889: DOUBLE
71890: LD_INT 1
71892: DEC
71893: ST_TO_ADDR
71894: LD_EXP 59
71898: PUSH
71899: FOR_TO
71900: IFFALSE 72060
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71902: LD_ADDR_VAR 0 4
71906: PUSH
71907: LD_EXP 59
71911: PUSH
71912: LD_VAR 0 2
71916: ARRAY
71917: PPUSH
71918: LD_INT 25
71920: PUSH
71921: LD_INT 9
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PPUSH
71928: CALL_OW 72
71932: ST_TO_ADDR
// if not tmp then
71933: LD_VAR 0 4
71937: NOT
71938: IFFALSE 71942
// continue ;
71940: GO 71899
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71942: LD_EXP 85
71946: PUSH
71947: LD_VAR 0 2
71951: ARRAY
71952: PPUSH
71953: LD_INT 29
71955: PPUSH
71956: CALL_OW 325
71960: NOT
71961: PUSH
71962: LD_EXP 85
71966: PUSH
71967: LD_VAR 0 2
71971: ARRAY
71972: PPUSH
71973: LD_INT 28
71975: PPUSH
71976: CALL_OW 325
71980: NOT
71981: AND
71982: IFFALSE 71986
// continue ;
71984: GO 71899
// for j in tmp do
71986: LD_ADDR_VAR 0 3
71990: PUSH
71991: LD_VAR 0 4
71995: PUSH
71996: FOR_IN
71997: IFFALSE 72056
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71999: LD_VAR 0 3
72003: PUSH
72004: LD_EXP 62
72008: PUSH
72009: LD_VAR 0 2
72013: ARRAY
72014: PUSH
72015: LD_INT 1
72017: ARRAY
72018: IN
72019: NOT
72020: PUSH
72021: LD_VAR 0 3
72025: PUSH
72026: LD_EXP 62
72030: PUSH
72031: LD_VAR 0 2
72035: ARRAY
72036: PUSH
72037: LD_INT 2
72039: ARRAY
72040: IN
72041: NOT
72042: AND
72043: IFFALSE 72054
// ComSpaceTimeShoot ( j ) ;
72045: LD_VAR 0 3
72049: PPUSH
72050: CALL 15304 0 1
72054: GO 71996
72056: POP
72057: POP
// end ;
72058: GO 71899
72060: POP
72061: POP
// end ;
72062: LD_VAR 0 1
72066: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
72067: LD_INT 0
72069: PPUSH
72070: PPUSH
72071: PPUSH
72072: PPUSH
72073: PPUSH
72074: PPUSH
72075: PPUSH
72076: PPUSH
72077: PPUSH
// if not mc_bases then
72078: LD_EXP 59
72082: NOT
72083: IFFALSE 72087
// exit ;
72085: GO 72709
// for i = 1 to mc_bases do
72087: LD_ADDR_VAR 0 2
72091: PUSH
72092: DOUBLE
72093: LD_INT 1
72095: DEC
72096: ST_TO_ADDR
72097: LD_EXP 59
72101: PUSH
72102: FOR_TO
72103: IFFALSE 72707
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
72105: LD_EXP 94
72109: PUSH
72110: LD_VAR 0 2
72114: ARRAY
72115: NOT
72116: PUSH
72117: LD_INT 38
72119: PPUSH
72120: LD_EXP 85
72124: PUSH
72125: LD_VAR 0 2
72129: ARRAY
72130: PPUSH
72131: CALL_OW 321
72135: PUSH
72136: LD_INT 2
72138: NONEQUAL
72139: OR
72140: IFFALSE 72144
// continue ;
72142: GO 72102
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
72144: LD_ADDR_VAR 0 8
72148: PUSH
72149: LD_EXP 59
72153: PUSH
72154: LD_VAR 0 2
72158: ARRAY
72159: PPUSH
72160: LD_INT 30
72162: PUSH
72163: LD_INT 34
72165: PUSH
72166: EMPTY
72167: LIST
72168: LIST
72169: PPUSH
72170: CALL_OW 72
72174: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
72175: LD_ADDR_VAR 0 9
72179: PUSH
72180: LD_EXP 59
72184: PUSH
72185: LD_VAR 0 2
72189: ARRAY
72190: PPUSH
72191: LD_INT 25
72193: PUSH
72194: LD_INT 4
72196: PUSH
72197: EMPTY
72198: LIST
72199: LIST
72200: PPUSH
72201: CALL_OW 72
72205: PPUSH
72206: LD_INT 0
72208: PPUSH
72209: CALL 48201 0 2
72213: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
72214: LD_VAR 0 9
72218: NOT
72219: PUSH
72220: LD_VAR 0 8
72224: NOT
72225: OR
72226: PUSH
72227: LD_EXP 59
72231: PUSH
72232: LD_VAR 0 2
72236: ARRAY
72237: PPUSH
72238: LD_INT 124
72240: PPUSH
72241: CALL 48201 0 2
72245: OR
72246: IFFALSE 72250
// continue ;
72248: GO 72102
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
72250: LD_EXP 95
72254: PUSH
72255: LD_VAR 0 2
72259: ARRAY
72260: PUSH
72261: LD_EXP 94
72265: PUSH
72266: LD_VAR 0 2
72270: ARRAY
72271: LESS
72272: PUSH
72273: LD_EXP 95
72277: PUSH
72278: LD_VAR 0 2
72282: ARRAY
72283: PUSH
72284: LD_VAR 0 8
72288: LESS
72289: AND
72290: IFFALSE 72705
// begin tmp := sci [ 1 ] ;
72292: LD_ADDR_VAR 0 7
72296: PUSH
72297: LD_VAR 0 9
72301: PUSH
72302: LD_INT 1
72304: ARRAY
72305: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
72306: LD_VAR 0 7
72310: PPUSH
72311: LD_INT 124
72313: PPUSH
72314: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
72318: LD_ADDR_VAR 0 3
72322: PUSH
72323: DOUBLE
72324: LD_EXP 94
72328: PUSH
72329: LD_VAR 0 2
72333: ARRAY
72334: INC
72335: ST_TO_ADDR
72336: LD_EXP 94
72340: PUSH
72341: LD_VAR 0 2
72345: ARRAY
72346: PUSH
72347: FOR_DOWNTO
72348: IFFALSE 72691
// begin if IsInUnit ( tmp ) then
72350: LD_VAR 0 7
72354: PPUSH
72355: CALL_OW 310
72359: IFFALSE 72370
// ComExitBuilding ( tmp ) ;
72361: LD_VAR 0 7
72365: PPUSH
72366: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
72370: LD_INT 35
72372: PPUSH
72373: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
72377: LD_VAR 0 7
72381: PPUSH
72382: CALL_OW 310
72386: NOT
72387: PUSH
72388: LD_VAR 0 7
72392: PPUSH
72393: CALL_OW 314
72397: NOT
72398: AND
72399: IFFALSE 72370
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
72401: LD_ADDR_VAR 0 6
72405: PUSH
72406: LD_VAR 0 7
72410: PPUSH
72411: CALL_OW 250
72415: PUSH
72416: LD_VAR 0 7
72420: PPUSH
72421: CALL_OW 251
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
72430: LD_INT 35
72432: PPUSH
72433: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
72437: LD_ADDR_VAR 0 4
72441: PUSH
72442: LD_EXP 94
72446: PUSH
72447: LD_VAR 0 2
72451: ARRAY
72452: PUSH
72453: LD_VAR 0 3
72457: ARRAY
72458: PUSH
72459: LD_INT 1
72461: ARRAY
72462: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
72463: LD_ADDR_VAR 0 5
72467: PUSH
72468: LD_EXP 94
72472: PUSH
72473: LD_VAR 0 2
72477: ARRAY
72478: PUSH
72479: LD_VAR 0 3
72483: ARRAY
72484: PUSH
72485: LD_INT 2
72487: ARRAY
72488: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
72489: LD_VAR 0 7
72493: PPUSH
72494: LD_INT 10
72496: PPUSH
72497: CALL 21900 0 2
72501: PUSH
72502: LD_INT 4
72504: ARRAY
72505: IFFALSE 72543
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
72507: LD_VAR 0 7
72511: PPUSH
72512: LD_VAR 0 6
72516: PUSH
72517: LD_INT 1
72519: ARRAY
72520: PPUSH
72521: LD_VAR 0 6
72525: PUSH
72526: LD_INT 2
72528: ARRAY
72529: PPUSH
72530: CALL_OW 111
// wait ( 0 0$10 ) ;
72534: LD_INT 350
72536: PPUSH
72537: CALL_OW 67
// end else
72541: GO 72569
// begin ComMoveXY ( tmp , x , y ) ;
72543: LD_VAR 0 7
72547: PPUSH
72548: LD_VAR 0 4
72552: PPUSH
72553: LD_VAR 0 5
72557: PPUSH
72558: CALL_OW 111
// wait ( 0 0$3 ) ;
72562: LD_INT 105
72564: PPUSH
72565: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
72569: LD_VAR 0 7
72573: PPUSH
72574: LD_VAR 0 4
72578: PPUSH
72579: LD_VAR 0 5
72583: PPUSH
72584: CALL_OW 307
72588: IFFALSE 72430
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
72590: LD_VAR 0 7
72594: PPUSH
72595: LD_VAR 0 4
72599: PPUSH
72600: LD_VAR 0 5
72604: PPUSH
72605: LD_VAR 0 8
72609: PUSH
72610: LD_VAR 0 3
72614: ARRAY
72615: PPUSH
72616: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
72620: LD_INT 35
72622: PPUSH
72623: CALL_OW 67
// until not HasTask ( tmp ) ;
72627: LD_VAR 0 7
72631: PPUSH
72632: CALL_OW 314
72636: NOT
72637: IFFALSE 72620
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
72639: LD_ADDR_EXP 95
72643: PUSH
72644: LD_EXP 95
72648: PPUSH
72649: LD_VAR 0 2
72653: PUSH
72654: LD_EXP 95
72658: PUSH
72659: LD_VAR 0 2
72663: ARRAY
72664: PUSH
72665: LD_INT 1
72667: PLUS
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PPUSH
72673: LD_VAR 0 8
72677: PUSH
72678: LD_VAR 0 3
72682: ARRAY
72683: PPUSH
72684: CALL 19307 0 3
72688: ST_TO_ADDR
// end ;
72689: GO 72347
72691: POP
72692: POP
// MC_Reset ( i , 124 ) ;
72693: LD_VAR 0 2
72697: PPUSH
72698: LD_INT 124
72700: PPUSH
72701: CALL 56148 0 2
// end ; end ;
72705: GO 72102
72707: POP
72708: POP
// end ;
72709: LD_VAR 0 1
72713: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
72714: LD_INT 0
72716: PPUSH
72717: PPUSH
72718: PPUSH
// if not mc_bases then
72719: LD_EXP 59
72723: NOT
72724: IFFALSE 72728
// exit ;
72726: GO 73334
// for i = 1 to mc_bases do
72728: LD_ADDR_VAR 0 2
72732: PUSH
72733: DOUBLE
72734: LD_INT 1
72736: DEC
72737: ST_TO_ADDR
72738: LD_EXP 59
72742: PUSH
72743: FOR_TO
72744: IFFALSE 73332
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
72746: LD_ADDR_VAR 0 3
72750: PUSH
72751: LD_EXP 59
72755: PUSH
72756: LD_VAR 0 2
72760: ARRAY
72761: PPUSH
72762: LD_INT 25
72764: PUSH
72765: LD_INT 4
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PPUSH
72772: CALL_OW 72
72776: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
72777: LD_VAR 0 3
72781: NOT
72782: PUSH
72783: LD_EXP 96
72787: PUSH
72788: LD_VAR 0 2
72792: ARRAY
72793: NOT
72794: OR
72795: PUSH
72796: LD_EXP 59
72800: PUSH
72801: LD_VAR 0 2
72805: ARRAY
72806: PPUSH
72807: LD_INT 2
72809: PUSH
72810: LD_INT 30
72812: PUSH
72813: LD_INT 0
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 30
72822: PUSH
72823: LD_INT 1
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: EMPTY
72831: LIST
72832: LIST
72833: LIST
72834: PPUSH
72835: CALL_OW 72
72839: NOT
72840: OR
72841: IFFALSE 72891
// begin if mc_deposits_finder [ i ] then
72843: LD_EXP 97
72847: PUSH
72848: LD_VAR 0 2
72852: ARRAY
72853: IFFALSE 72889
// begin MC_Reset ( i , 125 ) ;
72855: LD_VAR 0 2
72859: PPUSH
72860: LD_INT 125
72862: PPUSH
72863: CALL 56148 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72867: LD_ADDR_EXP 97
72871: PUSH
72872: LD_EXP 97
72876: PPUSH
72877: LD_VAR 0 2
72881: PPUSH
72882: EMPTY
72883: PPUSH
72884: CALL_OW 1
72888: ST_TO_ADDR
// end ; continue ;
72889: GO 72743
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72891: LD_EXP 96
72895: PUSH
72896: LD_VAR 0 2
72900: ARRAY
72901: PUSH
72902: LD_INT 1
72904: ARRAY
72905: PUSH
72906: LD_INT 3
72908: ARRAY
72909: PUSH
72910: LD_INT 1
72912: EQUAL
72913: PUSH
72914: LD_INT 20
72916: PPUSH
72917: LD_EXP 85
72921: PUSH
72922: LD_VAR 0 2
72926: ARRAY
72927: PPUSH
72928: CALL_OW 321
72932: PUSH
72933: LD_INT 2
72935: NONEQUAL
72936: AND
72937: IFFALSE 72987
// begin if mc_deposits_finder [ i ] then
72939: LD_EXP 97
72943: PUSH
72944: LD_VAR 0 2
72948: ARRAY
72949: IFFALSE 72985
// begin MC_Reset ( i , 125 ) ;
72951: LD_VAR 0 2
72955: PPUSH
72956: LD_INT 125
72958: PPUSH
72959: CALL 56148 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72963: LD_ADDR_EXP 97
72967: PUSH
72968: LD_EXP 97
72972: PPUSH
72973: LD_VAR 0 2
72977: PPUSH
72978: EMPTY
72979: PPUSH
72980: CALL_OW 1
72984: ST_TO_ADDR
// end ; continue ;
72985: GO 72743
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72987: LD_EXP 96
72991: PUSH
72992: LD_VAR 0 2
72996: ARRAY
72997: PUSH
72998: LD_INT 1
73000: ARRAY
73001: PUSH
73002: LD_INT 1
73004: ARRAY
73005: PPUSH
73006: LD_EXP 96
73010: PUSH
73011: LD_VAR 0 2
73015: ARRAY
73016: PUSH
73017: LD_INT 1
73019: ARRAY
73020: PUSH
73021: LD_INT 2
73023: ARRAY
73024: PPUSH
73025: LD_EXP 85
73029: PUSH
73030: LD_VAR 0 2
73034: ARRAY
73035: PPUSH
73036: CALL_OW 440
73040: IFFALSE 73083
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
73042: LD_ADDR_EXP 96
73046: PUSH
73047: LD_EXP 96
73051: PPUSH
73052: LD_VAR 0 2
73056: PPUSH
73057: LD_EXP 96
73061: PUSH
73062: LD_VAR 0 2
73066: ARRAY
73067: PPUSH
73068: LD_INT 1
73070: PPUSH
73071: CALL_OW 3
73075: PPUSH
73076: CALL_OW 1
73080: ST_TO_ADDR
73081: GO 73330
// begin if not mc_deposits_finder [ i ] then
73083: LD_EXP 97
73087: PUSH
73088: LD_VAR 0 2
73092: ARRAY
73093: NOT
73094: IFFALSE 73146
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
73096: LD_ADDR_EXP 97
73100: PUSH
73101: LD_EXP 97
73105: PPUSH
73106: LD_VAR 0 2
73110: PPUSH
73111: LD_VAR 0 3
73115: PUSH
73116: LD_INT 1
73118: ARRAY
73119: PUSH
73120: EMPTY
73121: LIST
73122: PPUSH
73123: CALL_OW 1
73127: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
73128: LD_VAR 0 3
73132: PUSH
73133: LD_INT 1
73135: ARRAY
73136: PPUSH
73137: LD_INT 125
73139: PPUSH
73140: CALL_OW 109
// end else
73144: GO 73330
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
73146: LD_EXP 97
73150: PUSH
73151: LD_VAR 0 2
73155: ARRAY
73156: PUSH
73157: LD_INT 1
73159: ARRAY
73160: PPUSH
73161: CALL_OW 310
73165: IFFALSE 73188
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
73167: LD_EXP 97
73171: PUSH
73172: LD_VAR 0 2
73176: ARRAY
73177: PUSH
73178: LD_INT 1
73180: ARRAY
73181: PPUSH
73182: CALL_OW 122
73186: GO 73330
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
73188: LD_EXP 97
73192: PUSH
73193: LD_VAR 0 2
73197: ARRAY
73198: PUSH
73199: LD_INT 1
73201: ARRAY
73202: PPUSH
73203: CALL_OW 314
73207: NOT
73208: PUSH
73209: LD_EXP 97
73213: PUSH
73214: LD_VAR 0 2
73218: ARRAY
73219: PUSH
73220: LD_INT 1
73222: ARRAY
73223: PPUSH
73224: LD_EXP 96
73228: PUSH
73229: LD_VAR 0 2
73233: ARRAY
73234: PUSH
73235: LD_INT 1
73237: ARRAY
73238: PUSH
73239: LD_INT 1
73241: ARRAY
73242: PPUSH
73243: LD_EXP 96
73247: PUSH
73248: LD_VAR 0 2
73252: ARRAY
73253: PUSH
73254: LD_INT 1
73256: ARRAY
73257: PUSH
73258: LD_INT 2
73260: ARRAY
73261: PPUSH
73262: CALL_OW 297
73266: PUSH
73267: LD_INT 6
73269: GREATER
73270: AND
73271: IFFALSE 73330
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
73273: LD_EXP 97
73277: PUSH
73278: LD_VAR 0 2
73282: ARRAY
73283: PUSH
73284: LD_INT 1
73286: ARRAY
73287: PPUSH
73288: LD_EXP 96
73292: PUSH
73293: LD_VAR 0 2
73297: ARRAY
73298: PUSH
73299: LD_INT 1
73301: ARRAY
73302: PUSH
73303: LD_INT 1
73305: ARRAY
73306: PPUSH
73307: LD_EXP 96
73311: PUSH
73312: LD_VAR 0 2
73316: ARRAY
73317: PUSH
73318: LD_INT 1
73320: ARRAY
73321: PUSH
73322: LD_INT 2
73324: ARRAY
73325: PPUSH
73326: CALL_OW 111
// end ; end ; end ;
73330: GO 72743
73332: POP
73333: POP
// end ;
73334: LD_VAR 0 1
73338: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
73339: LD_INT 0
73341: PPUSH
73342: PPUSH
73343: PPUSH
73344: PPUSH
73345: PPUSH
73346: PPUSH
73347: PPUSH
73348: PPUSH
73349: PPUSH
73350: PPUSH
73351: PPUSH
// if not mc_bases then
73352: LD_EXP 59
73356: NOT
73357: IFFALSE 73361
// exit ;
73359: GO 74301
// for i = 1 to mc_bases do
73361: LD_ADDR_VAR 0 2
73365: PUSH
73366: DOUBLE
73367: LD_INT 1
73369: DEC
73370: ST_TO_ADDR
73371: LD_EXP 59
73375: PUSH
73376: FOR_TO
73377: IFFALSE 74299
// begin if not mc_bases [ i ] or mc_scan [ i ] then
73379: LD_EXP 59
73383: PUSH
73384: LD_VAR 0 2
73388: ARRAY
73389: NOT
73390: PUSH
73391: LD_EXP 82
73395: PUSH
73396: LD_VAR 0 2
73400: ARRAY
73401: OR
73402: IFFALSE 73406
// continue ;
73404: GO 73376
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
73406: LD_ADDR_VAR 0 7
73410: PUSH
73411: LD_EXP 59
73415: PUSH
73416: LD_VAR 0 2
73420: ARRAY
73421: PUSH
73422: LD_INT 1
73424: ARRAY
73425: PPUSH
73426: CALL_OW 248
73430: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
73431: LD_VAR 0 7
73435: PUSH
73436: LD_INT 3
73438: EQUAL
73439: PUSH
73440: LD_EXP 78
73444: PUSH
73445: LD_VAR 0 2
73449: ARRAY
73450: PUSH
73451: LD_EXP 81
73455: PUSH
73456: LD_VAR 0 2
73460: ARRAY
73461: UNION
73462: PPUSH
73463: LD_INT 33
73465: PUSH
73466: LD_INT 2
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PPUSH
73473: CALL_OW 72
73477: NOT
73478: OR
73479: IFFALSE 73483
// continue ;
73481: GO 73376
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
73483: LD_ADDR_VAR 0 9
73487: PUSH
73488: LD_EXP 59
73492: PUSH
73493: LD_VAR 0 2
73497: ARRAY
73498: PPUSH
73499: LD_INT 30
73501: PUSH
73502: LD_INT 36
73504: PUSH
73505: EMPTY
73506: LIST
73507: LIST
73508: PPUSH
73509: CALL_OW 72
73513: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
73514: LD_ADDR_VAR 0 10
73518: PUSH
73519: LD_EXP 78
73523: PUSH
73524: LD_VAR 0 2
73528: ARRAY
73529: PPUSH
73530: LD_INT 34
73532: PUSH
73533: LD_INT 31
73535: PUSH
73536: EMPTY
73537: LIST
73538: LIST
73539: PPUSH
73540: CALL_OW 72
73544: ST_TO_ADDR
// if not cts and not mcts then
73545: LD_VAR 0 9
73549: NOT
73550: PUSH
73551: LD_VAR 0 10
73555: NOT
73556: AND
73557: IFFALSE 73561
// continue ;
73559: GO 73376
// x := cts ;
73561: LD_ADDR_VAR 0 11
73565: PUSH
73566: LD_VAR 0 9
73570: ST_TO_ADDR
// if not x then
73571: LD_VAR 0 11
73575: NOT
73576: IFFALSE 73588
// x := mcts ;
73578: LD_ADDR_VAR 0 11
73582: PUSH
73583: LD_VAR 0 10
73587: ST_TO_ADDR
// if not x then
73588: LD_VAR 0 11
73592: NOT
73593: IFFALSE 73597
// continue ;
73595: GO 73376
// if mc_remote_driver [ i ] then
73597: LD_EXP 99
73601: PUSH
73602: LD_VAR 0 2
73606: ARRAY
73607: IFFALSE 73994
// for j in mc_remote_driver [ i ] do
73609: LD_ADDR_VAR 0 3
73613: PUSH
73614: LD_EXP 99
73618: PUSH
73619: LD_VAR 0 2
73623: ARRAY
73624: PUSH
73625: FOR_IN
73626: IFFALSE 73992
// begin if GetClass ( j ) <> 3 then
73628: LD_VAR 0 3
73632: PPUSH
73633: CALL_OW 257
73637: PUSH
73638: LD_INT 3
73640: NONEQUAL
73641: IFFALSE 73694
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
73643: LD_ADDR_EXP 99
73647: PUSH
73648: LD_EXP 99
73652: PPUSH
73653: LD_VAR 0 2
73657: PPUSH
73658: LD_EXP 99
73662: PUSH
73663: LD_VAR 0 2
73667: ARRAY
73668: PUSH
73669: LD_VAR 0 3
73673: DIFF
73674: PPUSH
73675: CALL_OW 1
73679: ST_TO_ADDR
// SetTag ( j , 0 ) ;
73680: LD_VAR 0 3
73684: PPUSH
73685: LD_INT 0
73687: PPUSH
73688: CALL_OW 109
// continue ;
73692: GO 73625
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
73694: LD_EXP 78
73698: PUSH
73699: LD_VAR 0 2
73703: ARRAY
73704: PPUSH
73705: LD_INT 34
73707: PUSH
73708: LD_INT 31
73710: PUSH
73711: EMPTY
73712: LIST
73713: LIST
73714: PUSH
73715: LD_INT 58
73717: PUSH
73718: EMPTY
73719: LIST
73720: PUSH
73721: EMPTY
73722: LIST
73723: LIST
73724: PPUSH
73725: CALL_OW 72
73729: PUSH
73730: LD_VAR 0 3
73734: PPUSH
73735: CALL 48289 0 1
73739: NOT
73740: AND
73741: IFFALSE 73812
// begin if IsInUnit ( j ) then
73743: LD_VAR 0 3
73747: PPUSH
73748: CALL_OW 310
73752: IFFALSE 73763
// ComExitBuilding ( j ) ;
73754: LD_VAR 0 3
73758: PPUSH
73759: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
73763: LD_VAR 0 3
73767: PPUSH
73768: LD_EXP 78
73772: PUSH
73773: LD_VAR 0 2
73777: ARRAY
73778: PPUSH
73779: LD_INT 34
73781: PUSH
73782: LD_INT 31
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 58
73791: PUSH
73792: EMPTY
73793: LIST
73794: PUSH
73795: EMPTY
73796: LIST
73797: LIST
73798: PPUSH
73799: CALL_OW 72
73803: PUSH
73804: LD_INT 1
73806: ARRAY
73807: PPUSH
73808: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
73812: LD_VAR 0 3
73816: PPUSH
73817: CALL_OW 310
73821: NOT
73822: PUSH
73823: LD_VAR 0 3
73827: PPUSH
73828: CALL_OW 310
73832: PPUSH
73833: CALL_OW 266
73837: PUSH
73838: LD_INT 36
73840: NONEQUAL
73841: PUSH
73842: LD_VAR 0 3
73846: PPUSH
73847: CALL 48289 0 1
73851: NOT
73852: AND
73853: OR
73854: IFFALSE 73990
// begin if IsInUnit ( j ) then
73856: LD_VAR 0 3
73860: PPUSH
73861: CALL_OW 310
73865: IFFALSE 73876
// ComExitBuilding ( j ) ;
73867: LD_VAR 0 3
73871: PPUSH
73872: CALL_OW 122
// ct := 0 ;
73876: LD_ADDR_VAR 0 8
73880: PUSH
73881: LD_INT 0
73883: ST_TO_ADDR
// for k in x do
73884: LD_ADDR_VAR 0 4
73888: PUSH
73889: LD_VAR 0 11
73893: PUSH
73894: FOR_IN
73895: IFFALSE 73968
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73897: LD_VAR 0 4
73901: PPUSH
73902: CALL_OW 264
73906: PUSH
73907: LD_INT 31
73909: EQUAL
73910: PUSH
73911: LD_VAR 0 4
73915: PPUSH
73916: CALL_OW 311
73920: NOT
73921: AND
73922: PUSH
73923: LD_VAR 0 4
73927: PPUSH
73928: CALL_OW 266
73932: PUSH
73933: LD_INT 36
73935: EQUAL
73936: PUSH
73937: LD_VAR 0 4
73941: PPUSH
73942: CALL_OW 313
73946: PUSH
73947: LD_INT 3
73949: LESS
73950: AND
73951: OR
73952: IFFALSE 73966
// begin ct := k ;
73954: LD_ADDR_VAR 0 8
73958: PUSH
73959: LD_VAR 0 4
73963: ST_TO_ADDR
// break ;
73964: GO 73968
// end ;
73966: GO 73894
73968: POP
73969: POP
// if ct then
73970: LD_VAR 0 8
73974: IFFALSE 73990
// ComEnterUnit ( j , ct ) ;
73976: LD_VAR 0 3
73980: PPUSH
73981: LD_VAR 0 8
73985: PPUSH
73986: CALL_OW 120
// end ; end ;
73990: GO 73625
73992: POP
73993: POP
// places := 0 ;
73994: LD_ADDR_VAR 0 5
73998: PUSH
73999: LD_INT 0
74001: ST_TO_ADDR
// for j = 1 to x do
74002: LD_ADDR_VAR 0 3
74006: PUSH
74007: DOUBLE
74008: LD_INT 1
74010: DEC
74011: ST_TO_ADDR
74012: LD_VAR 0 11
74016: PUSH
74017: FOR_TO
74018: IFFALSE 74094
// if GetWeapon ( x [ j ] ) = ar_control_tower then
74020: LD_VAR 0 11
74024: PUSH
74025: LD_VAR 0 3
74029: ARRAY
74030: PPUSH
74031: CALL_OW 264
74035: PUSH
74036: LD_INT 31
74038: EQUAL
74039: IFFALSE 74057
// places := places + 1 else
74041: LD_ADDR_VAR 0 5
74045: PUSH
74046: LD_VAR 0 5
74050: PUSH
74051: LD_INT 1
74053: PLUS
74054: ST_TO_ADDR
74055: GO 74092
// if GetBType ( x [ j ] ) = b_control_tower then
74057: LD_VAR 0 11
74061: PUSH
74062: LD_VAR 0 3
74066: ARRAY
74067: PPUSH
74068: CALL_OW 266
74072: PUSH
74073: LD_INT 36
74075: EQUAL
74076: IFFALSE 74092
// places := places + 3 ;
74078: LD_ADDR_VAR 0 5
74082: PUSH
74083: LD_VAR 0 5
74087: PUSH
74088: LD_INT 3
74090: PLUS
74091: ST_TO_ADDR
74092: GO 74017
74094: POP
74095: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
74096: LD_VAR 0 5
74100: PUSH
74101: LD_INT 0
74103: EQUAL
74104: PUSH
74105: LD_VAR 0 5
74109: PUSH
74110: LD_EXP 99
74114: PUSH
74115: LD_VAR 0 2
74119: ARRAY
74120: LESSEQUAL
74121: OR
74122: IFFALSE 74126
// continue ;
74124: GO 73376
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
74126: LD_ADDR_VAR 0 6
74130: PUSH
74131: LD_EXP 59
74135: PUSH
74136: LD_VAR 0 2
74140: ARRAY
74141: PPUSH
74142: LD_INT 25
74144: PUSH
74145: LD_INT 3
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PPUSH
74152: CALL_OW 72
74156: PUSH
74157: LD_EXP 99
74161: PUSH
74162: LD_VAR 0 2
74166: ARRAY
74167: DIFF
74168: PPUSH
74169: LD_INT 3
74171: PPUSH
74172: CALL 49189 0 2
74176: ST_TO_ADDR
// for j in tmp do
74177: LD_ADDR_VAR 0 3
74181: PUSH
74182: LD_VAR 0 6
74186: PUSH
74187: FOR_IN
74188: IFFALSE 74223
// if GetTag ( j ) > 0 then
74190: LD_VAR 0 3
74194: PPUSH
74195: CALL_OW 110
74199: PUSH
74200: LD_INT 0
74202: GREATER
74203: IFFALSE 74221
// tmp := tmp diff j ;
74205: LD_ADDR_VAR 0 6
74209: PUSH
74210: LD_VAR 0 6
74214: PUSH
74215: LD_VAR 0 3
74219: DIFF
74220: ST_TO_ADDR
74221: GO 74187
74223: POP
74224: POP
// if not tmp then
74225: LD_VAR 0 6
74229: NOT
74230: IFFALSE 74234
// continue ;
74232: GO 73376
// if places then
74234: LD_VAR 0 5
74238: IFFALSE 74297
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
74240: LD_ADDR_EXP 99
74244: PUSH
74245: LD_EXP 99
74249: PPUSH
74250: LD_VAR 0 2
74254: PPUSH
74255: LD_EXP 99
74259: PUSH
74260: LD_VAR 0 2
74264: ARRAY
74265: PUSH
74266: LD_VAR 0 6
74270: PUSH
74271: LD_INT 1
74273: ARRAY
74274: UNION
74275: PPUSH
74276: CALL_OW 1
74280: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
74281: LD_VAR 0 6
74285: PUSH
74286: LD_INT 1
74288: ARRAY
74289: PPUSH
74290: LD_INT 126
74292: PPUSH
74293: CALL_OW 109
// end ; end ;
74297: GO 73376
74299: POP
74300: POP
// end ;
74301: LD_VAR 0 1
74305: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
74306: LD_INT 0
74308: PPUSH
74309: PPUSH
74310: PPUSH
74311: PPUSH
74312: PPUSH
74313: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
74314: LD_VAR 0 1
74318: NOT
74319: PUSH
74320: LD_VAR 0 2
74324: NOT
74325: OR
74326: PUSH
74327: LD_VAR 0 3
74331: NOT
74332: OR
74333: PUSH
74334: LD_VAR 0 4
74338: PUSH
74339: LD_INT 1
74341: PUSH
74342: LD_INT 2
74344: PUSH
74345: LD_INT 3
74347: PUSH
74348: LD_INT 4
74350: PUSH
74351: LD_INT 5
74353: PUSH
74354: LD_INT 8
74356: PUSH
74357: LD_INT 9
74359: PUSH
74360: LD_INT 15
74362: PUSH
74363: LD_INT 16
74365: PUSH
74366: EMPTY
74367: LIST
74368: LIST
74369: LIST
74370: LIST
74371: LIST
74372: LIST
74373: LIST
74374: LIST
74375: LIST
74376: IN
74377: NOT
74378: OR
74379: IFFALSE 74383
// exit ;
74381: GO 75283
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
74383: LD_ADDR_VAR 0 2
74387: PUSH
74388: LD_VAR 0 2
74392: PPUSH
74393: LD_INT 21
74395: PUSH
74396: LD_INT 3
74398: PUSH
74399: EMPTY
74400: LIST
74401: LIST
74402: PUSH
74403: LD_INT 24
74405: PUSH
74406: LD_INT 250
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PPUSH
74417: CALL_OW 72
74421: ST_TO_ADDR
// case class of 1 , 15 :
74422: LD_VAR 0 4
74426: PUSH
74427: LD_INT 1
74429: DOUBLE
74430: EQUAL
74431: IFTRUE 74441
74433: LD_INT 15
74435: DOUBLE
74436: EQUAL
74437: IFTRUE 74441
74439: GO 74526
74441: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
74442: LD_ADDR_VAR 0 8
74446: PUSH
74447: LD_VAR 0 2
74451: PPUSH
74452: LD_INT 2
74454: PUSH
74455: LD_INT 30
74457: PUSH
74458: LD_INT 32
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 30
74467: PUSH
74468: LD_INT 31
74470: PUSH
74471: EMPTY
74472: LIST
74473: LIST
74474: PUSH
74475: EMPTY
74476: LIST
74477: LIST
74478: LIST
74479: PPUSH
74480: CALL_OW 72
74484: PUSH
74485: LD_VAR 0 2
74489: PPUSH
74490: LD_INT 2
74492: PUSH
74493: LD_INT 30
74495: PUSH
74496: LD_INT 4
74498: PUSH
74499: EMPTY
74500: LIST
74501: LIST
74502: PUSH
74503: LD_INT 30
74505: PUSH
74506: LD_INT 5
74508: PUSH
74509: EMPTY
74510: LIST
74511: LIST
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: LIST
74517: PPUSH
74518: CALL_OW 72
74522: ADD
74523: ST_TO_ADDR
74524: GO 74772
74526: LD_INT 2
74528: DOUBLE
74529: EQUAL
74530: IFTRUE 74540
74532: LD_INT 16
74534: DOUBLE
74535: EQUAL
74536: IFTRUE 74540
74538: GO 74586
74540: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
74541: LD_ADDR_VAR 0 8
74545: PUSH
74546: LD_VAR 0 2
74550: PPUSH
74551: LD_INT 2
74553: PUSH
74554: LD_INT 30
74556: PUSH
74557: LD_INT 0
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: PUSH
74564: LD_INT 30
74566: PUSH
74567: LD_INT 1
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: EMPTY
74575: LIST
74576: LIST
74577: LIST
74578: PPUSH
74579: CALL_OW 72
74583: ST_TO_ADDR
74584: GO 74772
74586: LD_INT 3
74588: DOUBLE
74589: EQUAL
74590: IFTRUE 74594
74592: GO 74640
74594: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
74595: LD_ADDR_VAR 0 8
74599: PUSH
74600: LD_VAR 0 2
74604: PPUSH
74605: LD_INT 2
74607: PUSH
74608: LD_INT 30
74610: PUSH
74611: LD_INT 2
74613: PUSH
74614: EMPTY
74615: LIST
74616: LIST
74617: PUSH
74618: LD_INT 30
74620: PUSH
74621: LD_INT 3
74623: PUSH
74624: EMPTY
74625: LIST
74626: LIST
74627: PUSH
74628: EMPTY
74629: LIST
74630: LIST
74631: LIST
74632: PPUSH
74633: CALL_OW 72
74637: ST_TO_ADDR
74638: GO 74772
74640: LD_INT 4
74642: DOUBLE
74643: EQUAL
74644: IFTRUE 74648
74646: GO 74705
74648: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
74649: LD_ADDR_VAR 0 8
74653: PUSH
74654: LD_VAR 0 2
74658: PPUSH
74659: LD_INT 2
74661: PUSH
74662: LD_INT 30
74664: PUSH
74665: LD_INT 6
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 30
74674: PUSH
74675: LD_INT 7
74677: PUSH
74678: EMPTY
74679: LIST
74680: LIST
74681: PUSH
74682: LD_INT 30
74684: PUSH
74685: LD_INT 8
74687: PUSH
74688: EMPTY
74689: LIST
74690: LIST
74691: PUSH
74692: EMPTY
74693: LIST
74694: LIST
74695: LIST
74696: LIST
74697: PPUSH
74698: CALL_OW 72
74702: ST_TO_ADDR
74703: GO 74772
74705: LD_INT 5
74707: DOUBLE
74708: EQUAL
74709: IFTRUE 74725
74711: LD_INT 8
74713: DOUBLE
74714: EQUAL
74715: IFTRUE 74725
74717: LD_INT 9
74719: DOUBLE
74720: EQUAL
74721: IFTRUE 74725
74723: GO 74771
74725: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
74726: LD_ADDR_VAR 0 8
74730: PUSH
74731: LD_VAR 0 2
74735: PPUSH
74736: LD_INT 2
74738: PUSH
74739: LD_INT 30
74741: PUSH
74742: LD_INT 4
74744: PUSH
74745: EMPTY
74746: LIST
74747: LIST
74748: PUSH
74749: LD_INT 30
74751: PUSH
74752: LD_INT 5
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: EMPTY
74760: LIST
74761: LIST
74762: LIST
74763: PPUSH
74764: CALL_OW 72
74768: ST_TO_ADDR
74769: GO 74772
74771: POP
// if not tmp then
74772: LD_VAR 0 8
74776: NOT
74777: IFFALSE 74781
// exit ;
74779: GO 75283
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
74781: LD_VAR 0 4
74785: PUSH
74786: LD_INT 1
74788: PUSH
74789: LD_INT 15
74791: PUSH
74792: EMPTY
74793: LIST
74794: LIST
74795: IN
74796: PUSH
74797: LD_EXP 68
74801: PUSH
74802: LD_VAR 0 1
74806: ARRAY
74807: AND
74808: IFFALSE 74964
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
74810: LD_ADDR_VAR 0 9
74814: PUSH
74815: LD_EXP 68
74819: PUSH
74820: LD_VAR 0 1
74824: ARRAY
74825: PUSH
74826: LD_INT 1
74828: ARRAY
74829: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74830: LD_VAR 0 9
74834: PUSH
74835: LD_EXP 69
74839: PUSH
74840: LD_VAR 0 1
74844: ARRAY
74845: IN
74846: NOT
74847: IFFALSE 74962
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74849: LD_ADDR_EXP 69
74853: PUSH
74854: LD_EXP 69
74858: PPUSH
74859: LD_VAR 0 1
74863: PUSH
74864: LD_EXP 69
74868: PUSH
74869: LD_VAR 0 1
74873: ARRAY
74874: PUSH
74875: LD_INT 1
74877: PLUS
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PPUSH
74883: LD_VAR 0 9
74887: PPUSH
74888: CALL 19307 0 3
74892: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74893: LD_ADDR_EXP 68
74897: PUSH
74898: LD_EXP 68
74902: PPUSH
74903: LD_VAR 0 1
74907: PPUSH
74908: LD_EXP 68
74912: PUSH
74913: LD_VAR 0 1
74917: ARRAY
74918: PUSH
74919: LD_VAR 0 9
74923: DIFF
74924: PPUSH
74925: CALL_OW 1
74929: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74930: LD_VAR 0 3
74934: PPUSH
74935: LD_EXP 69
74939: PUSH
74940: LD_VAR 0 1
74944: ARRAY
74945: PUSH
74946: LD_EXP 69
74950: PUSH
74951: LD_VAR 0 1
74955: ARRAY
74956: ARRAY
74957: PPUSH
74958: CALL_OW 120
// end ; exit ;
74962: GO 75283
// end ; if tmp > 1 then
74964: LD_VAR 0 8
74968: PUSH
74969: LD_INT 1
74971: GREATER
74972: IFFALSE 75076
// for i = 2 to tmp do
74974: LD_ADDR_VAR 0 6
74978: PUSH
74979: DOUBLE
74980: LD_INT 2
74982: DEC
74983: ST_TO_ADDR
74984: LD_VAR 0 8
74988: PUSH
74989: FOR_TO
74990: IFFALSE 75074
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74992: LD_VAR 0 8
74996: PUSH
74997: LD_VAR 0 6
75001: ARRAY
75002: PPUSH
75003: CALL_OW 461
75007: PUSH
75008: LD_INT 6
75010: EQUAL
75011: IFFALSE 75072
// begin x := tmp [ i ] ;
75013: LD_ADDR_VAR 0 9
75017: PUSH
75018: LD_VAR 0 8
75022: PUSH
75023: LD_VAR 0 6
75027: ARRAY
75028: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
75029: LD_ADDR_VAR 0 8
75033: PUSH
75034: LD_VAR 0 8
75038: PPUSH
75039: LD_VAR 0 6
75043: PPUSH
75044: CALL_OW 3
75048: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
75049: LD_ADDR_VAR 0 8
75053: PUSH
75054: LD_VAR 0 8
75058: PPUSH
75059: LD_INT 1
75061: PPUSH
75062: LD_VAR 0 9
75066: PPUSH
75067: CALL_OW 2
75071: ST_TO_ADDR
// end ;
75072: GO 74989
75074: POP
75075: POP
// for i in tmp do
75076: LD_ADDR_VAR 0 6
75080: PUSH
75081: LD_VAR 0 8
75085: PUSH
75086: FOR_IN
75087: IFFALSE 75156
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
75089: LD_VAR 0 6
75093: PPUSH
75094: CALL_OW 313
75098: PUSH
75099: LD_INT 6
75101: LESS
75102: PUSH
75103: LD_VAR 0 6
75107: PPUSH
75108: CALL_OW 266
75112: PUSH
75113: LD_INT 31
75115: PUSH
75116: LD_INT 32
75118: PUSH
75119: EMPTY
75120: LIST
75121: LIST
75122: IN
75123: NOT
75124: AND
75125: PUSH
75126: LD_VAR 0 6
75130: PPUSH
75131: CALL_OW 313
75135: PUSH
75136: LD_INT 0
75138: EQUAL
75139: OR
75140: IFFALSE 75154
// begin j := i ;
75142: LD_ADDR_VAR 0 7
75146: PUSH
75147: LD_VAR 0 6
75151: ST_TO_ADDR
// break ;
75152: GO 75156
// end ; end ;
75154: GO 75086
75156: POP
75157: POP
// if j then
75158: LD_VAR 0 7
75162: IFFALSE 75180
// ComEnterUnit ( unit , j ) else
75164: LD_VAR 0 3
75168: PPUSH
75169: LD_VAR 0 7
75173: PPUSH
75174: CALL_OW 120
75178: GO 75283
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75180: LD_ADDR_VAR 0 10
75184: PUSH
75185: LD_VAR 0 2
75189: PPUSH
75190: LD_INT 2
75192: PUSH
75193: LD_INT 30
75195: PUSH
75196: LD_INT 0
75198: PUSH
75199: EMPTY
75200: LIST
75201: LIST
75202: PUSH
75203: LD_INT 30
75205: PUSH
75206: LD_INT 1
75208: PUSH
75209: EMPTY
75210: LIST
75211: LIST
75212: PUSH
75213: EMPTY
75214: LIST
75215: LIST
75216: LIST
75217: PPUSH
75218: CALL_OW 72
75222: ST_TO_ADDR
// if depot then
75223: LD_VAR 0 10
75227: IFFALSE 75283
// begin depot := NearestUnitToUnit ( depot , unit ) ;
75229: LD_ADDR_VAR 0 10
75233: PUSH
75234: LD_VAR 0 10
75238: PPUSH
75239: LD_VAR 0 3
75243: PPUSH
75244: CALL_OW 74
75248: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
75249: LD_VAR 0 3
75253: PPUSH
75254: LD_VAR 0 10
75258: PPUSH
75259: CALL_OW 296
75263: PUSH
75264: LD_INT 10
75266: GREATER
75267: IFFALSE 75283
// ComStandNearbyBuilding ( unit , depot ) ;
75269: LD_VAR 0 3
75273: PPUSH
75274: LD_VAR 0 10
75278: PPUSH
75279: CALL 15921 0 2
// end ; end ; end ;
75283: LD_VAR 0 5
75287: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
75288: LD_INT 0
75290: PPUSH
75291: PPUSH
75292: PPUSH
75293: PPUSH
// if not mc_bases then
75294: LD_EXP 59
75298: NOT
75299: IFFALSE 75303
// exit ;
75301: GO 75542
// for i = 1 to mc_bases do
75303: LD_ADDR_VAR 0 2
75307: PUSH
75308: DOUBLE
75309: LD_INT 1
75311: DEC
75312: ST_TO_ADDR
75313: LD_EXP 59
75317: PUSH
75318: FOR_TO
75319: IFFALSE 75540
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
75321: LD_ADDR_VAR 0 4
75325: PUSH
75326: LD_EXP 59
75330: PUSH
75331: LD_VAR 0 2
75335: ARRAY
75336: PPUSH
75337: LD_INT 21
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: EMPTY
75344: LIST
75345: LIST
75346: PPUSH
75347: CALL_OW 72
75351: PUSH
75352: LD_EXP 88
75356: PUSH
75357: LD_VAR 0 2
75361: ARRAY
75362: UNION
75363: ST_TO_ADDR
// if not tmp then
75364: LD_VAR 0 4
75368: NOT
75369: IFFALSE 75373
// continue ;
75371: GO 75318
// for j in tmp do
75373: LD_ADDR_VAR 0 3
75377: PUSH
75378: LD_VAR 0 4
75382: PUSH
75383: FOR_IN
75384: IFFALSE 75536
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
75386: LD_VAR 0 3
75390: PPUSH
75391: CALL_OW 110
75395: NOT
75396: PUSH
75397: LD_VAR 0 3
75401: PPUSH
75402: CALL_OW 314
75406: NOT
75407: AND
75408: PUSH
75409: LD_VAR 0 3
75413: PPUSH
75414: CALL_OW 311
75418: NOT
75419: AND
75420: PUSH
75421: LD_VAR 0 3
75425: PPUSH
75426: CALL_OW 310
75430: NOT
75431: AND
75432: PUSH
75433: LD_VAR 0 3
75437: PUSH
75438: LD_EXP 62
75442: PUSH
75443: LD_VAR 0 2
75447: ARRAY
75448: PUSH
75449: LD_INT 1
75451: ARRAY
75452: IN
75453: NOT
75454: AND
75455: PUSH
75456: LD_VAR 0 3
75460: PUSH
75461: LD_EXP 62
75465: PUSH
75466: LD_VAR 0 2
75470: ARRAY
75471: PUSH
75472: LD_INT 2
75474: ARRAY
75475: IN
75476: NOT
75477: AND
75478: PUSH
75479: LD_VAR 0 3
75483: PUSH
75484: LD_EXP 71
75488: PUSH
75489: LD_VAR 0 2
75493: ARRAY
75494: IN
75495: NOT
75496: AND
75497: IFFALSE 75534
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
75499: LD_VAR 0 2
75503: PPUSH
75504: LD_EXP 59
75508: PUSH
75509: LD_VAR 0 2
75513: ARRAY
75514: PPUSH
75515: LD_VAR 0 3
75519: PPUSH
75520: LD_VAR 0 3
75524: PPUSH
75525: CALL_OW 257
75529: PPUSH
75530: CALL 74306 0 4
// end ;
75534: GO 75383
75536: POP
75537: POP
// end ;
75538: GO 75318
75540: POP
75541: POP
// end ;
75542: LD_VAR 0 1
75546: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
75547: LD_INT 0
75549: PPUSH
75550: PPUSH
75551: PPUSH
75552: PPUSH
75553: PPUSH
75554: PPUSH
// if not mc_bases [ base ] then
75555: LD_EXP 59
75559: PUSH
75560: LD_VAR 0 1
75564: ARRAY
75565: NOT
75566: IFFALSE 75570
// exit ;
75568: GO 75752
// tmp := [ ] ;
75570: LD_ADDR_VAR 0 6
75574: PUSH
75575: EMPTY
75576: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
75577: LD_ADDR_VAR 0 7
75581: PUSH
75582: LD_VAR 0 3
75586: PPUSH
75587: LD_INT 0
75589: PPUSH
75590: CALL_OW 517
75594: ST_TO_ADDR
// if not list then
75595: LD_VAR 0 7
75599: NOT
75600: IFFALSE 75604
// exit ;
75602: GO 75752
// for i = 1 to amount do
75604: LD_ADDR_VAR 0 5
75608: PUSH
75609: DOUBLE
75610: LD_INT 1
75612: DEC
75613: ST_TO_ADDR
75614: LD_VAR 0 2
75618: PUSH
75619: FOR_TO
75620: IFFALSE 75700
// begin x := rand ( 1 , list [ 1 ] ) ;
75622: LD_ADDR_VAR 0 8
75626: PUSH
75627: LD_INT 1
75629: PPUSH
75630: LD_VAR 0 7
75634: PUSH
75635: LD_INT 1
75637: ARRAY
75638: PPUSH
75639: CALL_OW 12
75643: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
75644: LD_ADDR_VAR 0 6
75648: PUSH
75649: LD_VAR 0 6
75653: PPUSH
75654: LD_VAR 0 5
75658: PPUSH
75659: LD_VAR 0 7
75663: PUSH
75664: LD_INT 1
75666: ARRAY
75667: PUSH
75668: LD_VAR 0 8
75672: ARRAY
75673: PUSH
75674: LD_VAR 0 7
75678: PUSH
75679: LD_INT 2
75681: ARRAY
75682: PUSH
75683: LD_VAR 0 8
75687: ARRAY
75688: PUSH
75689: EMPTY
75690: LIST
75691: LIST
75692: PPUSH
75693: CALL_OW 1
75697: ST_TO_ADDR
// end ;
75698: GO 75619
75700: POP
75701: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
75702: LD_ADDR_EXP 72
75706: PUSH
75707: LD_EXP 72
75711: PPUSH
75712: LD_VAR 0 1
75716: PPUSH
75717: LD_VAR 0 6
75721: PPUSH
75722: CALL_OW 1
75726: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
75727: LD_ADDR_EXP 74
75731: PUSH
75732: LD_EXP 74
75736: PPUSH
75737: LD_VAR 0 1
75741: PPUSH
75742: LD_VAR 0 3
75746: PPUSH
75747: CALL_OW 1
75751: ST_TO_ADDR
// end ;
75752: LD_VAR 0 4
75756: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
75757: LD_INT 0
75759: PPUSH
// if not mc_bases [ base ] then
75760: LD_EXP 59
75764: PUSH
75765: LD_VAR 0 1
75769: ARRAY
75770: NOT
75771: IFFALSE 75775
// exit ;
75773: GO 75800
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
75775: LD_ADDR_EXP 64
75779: PUSH
75780: LD_EXP 64
75784: PPUSH
75785: LD_VAR 0 1
75789: PPUSH
75790: LD_VAR 0 2
75794: PPUSH
75795: CALL_OW 1
75799: ST_TO_ADDR
// end ;
75800: LD_VAR 0 3
75804: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
75805: LD_INT 0
75807: PPUSH
// if not mc_bases [ base ] then
75808: LD_EXP 59
75812: PUSH
75813: LD_VAR 0 1
75817: ARRAY
75818: NOT
75819: IFFALSE 75823
// exit ;
75821: GO 75860
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75823: LD_ADDR_EXP 64
75827: PUSH
75828: LD_EXP 64
75832: PPUSH
75833: LD_VAR 0 1
75837: PPUSH
75838: LD_EXP 64
75842: PUSH
75843: LD_VAR 0 1
75847: ARRAY
75848: PUSH
75849: LD_VAR 0 2
75853: UNION
75854: PPUSH
75855: CALL_OW 1
75859: ST_TO_ADDR
// end ;
75860: LD_VAR 0 3
75864: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75865: LD_INT 0
75867: PPUSH
// if not mc_bases [ base ] then
75868: LD_EXP 59
75872: PUSH
75873: LD_VAR 0 1
75877: ARRAY
75878: NOT
75879: IFFALSE 75883
// exit ;
75881: GO 75908
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75883: LD_ADDR_EXP 80
75887: PUSH
75888: LD_EXP 80
75892: PPUSH
75893: LD_VAR 0 1
75897: PPUSH
75898: LD_VAR 0 2
75902: PPUSH
75903: CALL_OW 1
75907: ST_TO_ADDR
// end ;
75908: LD_VAR 0 3
75912: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75913: LD_INT 0
75915: PPUSH
// if not mc_bases [ base ] then
75916: LD_EXP 59
75920: PUSH
75921: LD_VAR 0 1
75925: ARRAY
75926: NOT
75927: IFFALSE 75931
// exit ;
75929: GO 75968
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75931: LD_ADDR_EXP 80
75935: PUSH
75936: LD_EXP 80
75940: PPUSH
75941: LD_VAR 0 1
75945: PPUSH
75946: LD_EXP 80
75950: PUSH
75951: LD_VAR 0 1
75955: ARRAY
75956: PUSH
75957: LD_VAR 0 2
75961: ADD
75962: PPUSH
75963: CALL_OW 1
75967: ST_TO_ADDR
// end ;
75968: LD_VAR 0 3
75972: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75973: LD_INT 0
75975: PPUSH
// if not mc_bases [ base ] then
75976: LD_EXP 59
75980: PUSH
75981: LD_VAR 0 1
75985: ARRAY
75986: NOT
75987: IFFALSE 75991
// exit ;
75989: GO 76045
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75991: LD_ADDR_EXP 81
75995: PUSH
75996: LD_EXP 81
76000: PPUSH
76001: LD_VAR 0 1
76005: PPUSH
76006: LD_VAR 0 2
76010: PPUSH
76011: CALL_OW 1
76015: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
76016: LD_ADDR_EXP 70
76020: PUSH
76021: LD_EXP 70
76025: PPUSH
76026: LD_VAR 0 1
76030: PPUSH
76031: LD_VAR 0 2
76035: PUSH
76036: LD_INT 0
76038: PLUS
76039: PPUSH
76040: CALL_OW 1
76044: ST_TO_ADDR
// end ;
76045: LD_VAR 0 3
76049: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
76050: LD_INT 0
76052: PPUSH
// if not mc_bases [ base ] then
76053: LD_EXP 59
76057: PUSH
76058: LD_VAR 0 1
76062: ARRAY
76063: NOT
76064: IFFALSE 76068
// exit ;
76066: GO 76093
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
76068: LD_ADDR_EXP 70
76072: PUSH
76073: LD_EXP 70
76077: PPUSH
76078: LD_VAR 0 1
76082: PPUSH
76083: LD_VAR 0 2
76087: PPUSH
76088: CALL_OW 1
76092: ST_TO_ADDR
// end ;
76093: LD_VAR 0 3
76097: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
76098: LD_INT 0
76100: PPUSH
76101: PPUSH
76102: PPUSH
76103: PPUSH
// if not mc_bases [ base ] then
76104: LD_EXP 59
76108: PUSH
76109: LD_VAR 0 1
76113: ARRAY
76114: NOT
76115: IFFALSE 76119
// exit ;
76117: GO 76184
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
76119: LD_ADDR_EXP 79
76123: PUSH
76124: LD_EXP 79
76128: PPUSH
76129: LD_VAR 0 1
76133: PUSH
76134: LD_EXP 79
76138: PUSH
76139: LD_VAR 0 1
76143: ARRAY
76144: PUSH
76145: LD_INT 1
76147: PLUS
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PPUSH
76153: LD_VAR 0 1
76157: PUSH
76158: LD_VAR 0 2
76162: PUSH
76163: LD_VAR 0 3
76167: PUSH
76168: LD_VAR 0 4
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: LIST
76177: LIST
76178: PPUSH
76179: CALL 19307 0 3
76183: ST_TO_ADDR
// end ;
76184: LD_VAR 0 5
76188: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
76189: LD_INT 0
76191: PPUSH
// if not mc_bases [ base ] then
76192: LD_EXP 59
76196: PUSH
76197: LD_VAR 0 1
76201: ARRAY
76202: NOT
76203: IFFALSE 76207
// exit ;
76205: GO 76232
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
76207: LD_ADDR_EXP 96
76211: PUSH
76212: LD_EXP 96
76216: PPUSH
76217: LD_VAR 0 1
76221: PPUSH
76222: LD_VAR 0 2
76226: PPUSH
76227: CALL_OW 1
76231: ST_TO_ADDR
// end ;
76232: LD_VAR 0 3
76236: RET
// export function MC_GetMinesField ( base ) ; begin
76237: LD_INT 0
76239: PPUSH
// result := mc_mines [ base ] ;
76240: LD_ADDR_VAR 0 2
76244: PUSH
76245: LD_EXP 72
76249: PUSH
76250: LD_VAR 0 1
76254: ARRAY
76255: ST_TO_ADDR
// end ;
76256: LD_VAR 0 2
76260: RET
// export function MC_GetProduceList ( base ) ; begin
76261: LD_INT 0
76263: PPUSH
// result := mc_produce [ base ] ;
76264: LD_ADDR_VAR 0 2
76268: PUSH
76269: LD_EXP 80
76273: PUSH
76274: LD_VAR 0 1
76278: ARRAY
76279: ST_TO_ADDR
// end ;
76280: LD_VAR 0 2
76284: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
76285: LD_INT 0
76287: PPUSH
76288: PPUSH
// if not mc_bases then
76289: LD_EXP 59
76293: NOT
76294: IFFALSE 76298
// exit ;
76296: GO 76363
// if mc_bases [ base ] then
76298: LD_EXP 59
76302: PUSH
76303: LD_VAR 0 1
76307: ARRAY
76308: IFFALSE 76363
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76310: LD_ADDR_VAR 0 3
76314: PUSH
76315: LD_EXP 59
76319: PUSH
76320: LD_VAR 0 1
76324: ARRAY
76325: PPUSH
76326: LD_INT 30
76328: PUSH
76329: LD_VAR 0 2
76333: PUSH
76334: EMPTY
76335: LIST
76336: LIST
76337: PPUSH
76338: CALL_OW 72
76342: ST_TO_ADDR
// if result then
76343: LD_VAR 0 3
76347: IFFALSE 76363
// result := result [ 1 ] ;
76349: LD_ADDR_VAR 0 3
76353: PUSH
76354: LD_VAR 0 3
76358: PUSH
76359: LD_INT 1
76361: ARRAY
76362: ST_TO_ADDR
// end ; end ;
76363: LD_VAR 0 3
76367: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
76368: LD_INT 0
76370: PPUSH
76371: PPUSH
// if not mc_bases then
76372: LD_EXP 59
76376: NOT
76377: IFFALSE 76381
// exit ;
76379: GO 76426
// if mc_bases [ base ] then
76381: LD_EXP 59
76385: PUSH
76386: LD_VAR 0 1
76390: ARRAY
76391: IFFALSE 76426
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76393: LD_ADDR_VAR 0 3
76397: PUSH
76398: LD_EXP 59
76402: PUSH
76403: LD_VAR 0 1
76407: ARRAY
76408: PPUSH
76409: LD_INT 30
76411: PUSH
76412: LD_VAR 0 2
76416: PUSH
76417: EMPTY
76418: LIST
76419: LIST
76420: PPUSH
76421: CALL_OW 72
76425: ST_TO_ADDR
// end ;
76426: LD_VAR 0 3
76430: RET
// export function MC_SetTame ( base , area ) ; begin
76431: LD_INT 0
76433: PPUSH
// if not mc_bases or not base then
76434: LD_EXP 59
76438: NOT
76439: PUSH
76440: LD_VAR 0 1
76444: NOT
76445: OR
76446: IFFALSE 76450
// exit ;
76448: GO 76475
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
76450: LD_ADDR_EXP 87
76454: PUSH
76455: LD_EXP 87
76459: PPUSH
76460: LD_VAR 0 1
76464: PPUSH
76465: LD_VAR 0 2
76469: PPUSH
76470: CALL_OW 1
76474: ST_TO_ADDR
// end ;
76475: LD_VAR 0 3
76479: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
76480: LD_INT 0
76482: PPUSH
76483: PPUSH
// if not mc_bases or not base then
76484: LD_EXP 59
76488: NOT
76489: PUSH
76490: LD_VAR 0 1
76494: NOT
76495: OR
76496: IFFALSE 76500
// exit ;
76498: GO 76602
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
76500: LD_ADDR_VAR 0 4
76504: PUSH
76505: LD_EXP 59
76509: PUSH
76510: LD_VAR 0 1
76514: ARRAY
76515: PPUSH
76516: LD_INT 30
76518: PUSH
76519: LD_VAR 0 2
76523: PUSH
76524: EMPTY
76525: LIST
76526: LIST
76527: PPUSH
76528: CALL_OW 72
76532: ST_TO_ADDR
// if not tmp then
76533: LD_VAR 0 4
76537: NOT
76538: IFFALSE 76542
// exit ;
76540: GO 76602
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
76542: LD_ADDR_EXP 91
76546: PUSH
76547: LD_EXP 91
76551: PPUSH
76552: LD_VAR 0 1
76556: PPUSH
76557: LD_EXP 91
76561: PUSH
76562: LD_VAR 0 1
76566: ARRAY
76567: PPUSH
76568: LD_EXP 91
76572: PUSH
76573: LD_VAR 0 1
76577: ARRAY
76578: PUSH
76579: LD_INT 1
76581: PLUS
76582: PPUSH
76583: LD_VAR 0 4
76587: PUSH
76588: LD_INT 1
76590: ARRAY
76591: PPUSH
76592: CALL_OW 2
76596: PPUSH
76597: CALL_OW 1
76601: ST_TO_ADDR
// end ;
76602: LD_VAR 0 3
76606: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
76607: LD_INT 0
76609: PPUSH
76610: PPUSH
// if not mc_bases or not base or not kinds then
76611: LD_EXP 59
76615: NOT
76616: PUSH
76617: LD_VAR 0 1
76621: NOT
76622: OR
76623: PUSH
76624: LD_VAR 0 2
76628: NOT
76629: OR
76630: IFFALSE 76634
// exit ;
76632: GO 76695
// for i in kinds do
76634: LD_ADDR_VAR 0 4
76638: PUSH
76639: LD_VAR 0 2
76643: PUSH
76644: FOR_IN
76645: IFFALSE 76693
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
76647: LD_ADDR_EXP 93
76651: PUSH
76652: LD_EXP 93
76656: PPUSH
76657: LD_VAR 0 1
76661: PUSH
76662: LD_EXP 93
76666: PUSH
76667: LD_VAR 0 1
76671: ARRAY
76672: PUSH
76673: LD_INT 1
76675: PLUS
76676: PUSH
76677: EMPTY
76678: LIST
76679: LIST
76680: PPUSH
76681: LD_VAR 0 4
76685: PPUSH
76686: CALL 19307 0 3
76690: ST_TO_ADDR
76691: GO 76644
76693: POP
76694: POP
// end ;
76695: LD_VAR 0 3
76699: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
76700: LD_INT 0
76702: PPUSH
// if not mc_bases or not base or not areas then
76703: LD_EXP 59
76707: NOT
76708: PUSH
76709: LD_VAR 0 1
76713: NOT
76714: OR
76715: PUSH
76716: LD_VAR 0 2
76720: NOT
76721: OR
76722: IFFALSE 76726
// exit ;
76724: GO 76751
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
76726: LD_ADDR_EXP 77
76730: PUSH
76731: LD_EXP 77
76735: PPUSH
76736: LD_VAR 0 1
76740: PPUSH
76741: LD_VAR 0 2
76745: PPUSH
76746: CALL_OW 1
76750: ST_TO_ADDR
// end ;
76751: LD_VAR 0 3
76755: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
76756: LD_INT 0
76758: PPUSH
// if not mc_bases or not base or not teleports_exit then
76759: LD_EXP 59
76763: NOT
76764: PUSH
76765: LD_VAR 0 1
76769: NOT
76770: OR
76771: PUSH
76772: LD_VAR 0 2
76776: NOT
76777: OR
76778: IFFALSE 76782
// exit ;
76780: GO 76807
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
76782: LD_ADDR_EXP 94
76786: PUSH
76787: LD_EXP 94
76791: PPUSH
76792: LD_VAR 0 1
76796: PPUSH
76797: LD_VAR 0 2
76801: PPUSH
76802: CALL_OW 1
76806: ST_TO_ADDR
// end ;
76807: LD_VAR 0 3
76811: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
76812: LD_INT 0
76814: PPUSH
76815: PPUSH
76816: PPUSH
// if not mc_bases or not base or not ext_list then
76817: LD_EXP 59
76821: NOT
76822: PUSH
76823: LD_VAR 0 1
76827: NOT
76828: OR
76829: PUSH
76830: LD_VAR 0 5
76834: NOT
76835: OR
76836: IFFALSE 76840
// exit ;
76838: GO 77013
// tmp := GetFacExtXYD ( x , y , d ) ;
76840: LD_ADDR_VAR 0 8
76844: PUSH
76845: LD_VAR 0 2
76849: PPUSH
76850: LD_VAR 0 3
76854: PPUSH
76855: LD_VAR 0 4
76859: PPUSH
76860: CALL 48319 0 3
76864: ST_TO_ADDR
// if not tmp then
76865: LD_VAR 0 8
76869: NOT
76870: IFFALSE 76874
// exit ;
76872: GO 77013
// for i in tmp do
76874: LD_ADDR_VAR 0 7
76878: PUSH
76879: LD_VAR 0 8
76883: PUSH
76884: FOR_IN
76885: IFFALSE 77011
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76887: LD_ADDR_EXP 64
76891: PUSH
76892: LD_EXP 64
76896: PPUSH
76897: LD_VAR 0 1
76901: PPUSH
76902: LD_EXP 64
76906: PUSH
76907: LD_VAR 0 1
76911: ARRAY
76912: PPUSH
76913: LD_EXP 64
76917: PUSH
76918: LD_VAR 0 1
76922: ARRAY
76923: PUSH
76924: LD_INT 1
76926: PLUS
76927: PPUSH
76928: LD_VAR 0 5
76932: PUSH
76933: LD_INT 1
76935: ARRAY
76936: PUSH
76937: LD_VAR 0 7
76941: PUSH
76942: LD_INT 1
76944: ARRAY
76945: PUSH
76946: LD_VAR 0 7
76950: PUSH
76951: LD_INT 2
76953: ARRAY
76954: PUSH
76955: LD_VAR 0 7
76959: PUSH
76960: LD_INT 3
76962: ARRAY
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: LIST
76968: LIST
76969: PPUSH
76970: CALL_OW 2
76974: PPUSH
76975: CALL_OW 1
76979: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76980: LD_ADDR_VAR 0 5
76984: PUSH
76985: LD_VAR 0 5
76989: PPUSH
76990: LD_INT 1
76992: PPUSH
76993: CALL_OW 3
76997: ST_TO_ADDR
// if not ext_list then
76998: LD_VAR 0 5
77002: NOT
77003: IFFALSE 77009
// exit ;
77005: POP
77006: POP
77007: GO 77013
// end ;
77009: GO 76884
77011: POP
77012: POP
// end ;
77013: LD_VAR 0 6
77017: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
77018: LD_INT 0
77020: PPUSH
// if not mc_bases or not base or not weapon_list then
77021: LD_EXP 59
77025: NOT
77026: PUSH
77027: LD_VAR 0 1
77031: NOT
77032: OR
77033: PUSH
77034: LD_VAR 0 2
77038: NOT
77039: OR
77040: IFFALSE 77044
// exit ;
77042: GO 77069
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
77044: LD_ADDR_EXP 98
77048: PUSH
77049: LD_EXP 98
77053: PPUSH
77054: LD_VAR 0 1
77058: PPUSH
77059: LD_VAR 0 2
77063: PPUSH
77064: CALL_OW 1
77068: ST_TO_ADDR
// end ;
77069: LD_VAR 0 3
77073: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
77074: LD_INT 0
77076: PPUSH
// if not mc_bases or not base or not tech_list then
77077: LD_EXP 59
77081: NOT
77082: PUSH
77083: LD_VAR 0 1
77087: NOT
77088: OR
77089: PUSH
77090: LD_VAR 0 2
77094: NOT
77095: OR
77096: IFFALSE 77100
// exit ;
77098: GO 77125
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
77100: LD_ADDR_EXP 86
77104: PUSH
77105: LD_EXP 86
77109: PPUSH
77110: LD_VAR 0 1
77114: PPUSH
77115: LD_VAR 0 2
77119: PPUSH
77120: CALL_OW 1
77124: ST_TO_ADDR
// end ;
77125: LD_VAR 0 3
77129: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
77130: LD_INT 0
77132: PPUSH
// if not mc_bases or not parking_area or not base then
77133: LD_EXP 59
77137: NOT
77138: PUSH
77139: LD_VAR 0 2
77143: NOT
77144: OR
77145: PUSH
77146: LD_VAR 0 1
77150: NOT
77151: OR
77152: IFFALSE 77156
// exit ;
77154: GO 77181
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
77156: LD_ADDR_EXP 83
77160: PUSH
77161: LD_EXP 83
77165: PPUSH
77166: LD_VAR 0 1
77170: PPUSH
77171: LD_VAR 0 2
77175: PPUSH
77176: CALL_OW 1
77180: ST_TO_ADDR
// end ;
77181: LD_VAR 0 3
77185: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
77186: LD_INT 0
77188: PPUSH
// if not mc_bases or not base or not scan_area then
77189: LD_EXP 59
77193: NOT
77194: PUSH
77195: LD_VAR 0 1
77199: NOT
77200: OR
77201: PUSH
77202: LD_VAR 0 2
77206: NOT
77207: OR
77208: IFFALSE 77212
// exit ;
77210: GO 77237
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
77212: LD_ADDR_EXP 84
77216: PUSH
77217: LD_EXP 84
77221: PPUSH
77222: LD_VAR 0 1
77226: PPUSH
77227: LD_VAR 0 2
77231: PPUSH
77232: CALL_OW 1
77236: ST_TO_ADDR
// end ;
77237: LD_VAR 0 3
77241: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
77242: LD_INT 0
77244: PPUSH
77245: PPUSH
// if not mc_bases or not base then
77246: LD_EXP 59
77250: NOT
77251: PUSH
77252: LD_VAR 0 1
77256: NOT
77257: OR
77258: IFFALSE 77262
// exit ;
77260: GO 77326
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
77262: LD_ADDR_VAR 0 3
77266: PUSH
77267: LD_INT 1
77269: PUSH
77270: LD_INT 2
77272: PUSH
77273: LD_INT 3
77275: PUSH
77276: LD_INT 4
77278: PUSH
77279: LD_INT 11
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: LIST
77286: LIST
77287: LIST
77288: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
77289: LD_ADDR_EXP 86
77293: PUSH
77294: LD_EXP 86
77298: PPUSH
77299: LD_VAR 0 1
77303: PPUSH
77304: LD_EXP 86
77308: PUSH
77309: LD_VAR 0 1
77313: ARRAY
77314: PUSH
77315: LD_VAR 0 3
77319: DIFF
77320: PPUSH
77321: CALL_OW 1
77325: ST_TO_ADDR
// end ;
77326: LD_VAR 0 2
77330: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
77331: LD_INT 0
77333: PPUSH
// result := mc_vehicles [ base ] ;
77334: LD_ADDR_VAR 0 3
77338: PUSH
77339: LD_EXP 78
77343: PUSH
77344: LD_VAR 0 1
77348: ARRAY
77349: ST_TO_ADDR
// if onlyCombat then
77350: LD_VAR 0 2
77354: IFFALSE 77532
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
77356: LD_ADDR_VAR 0 3
77360: PUSH
77361: LD_VAR 0 3
77365: PUSH
77366: LD_VAR 0 3
77370: PPUSH
77371: LD_INT 2
77373: PUSH
77374: LD_INT 34
77376: PUSH
77377: LD_INT 12
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 34
77386: PUSH
77387: LD_INT 51
77389: PUSH
77390: EMPTY
77391: LIST
77392: LIST
77393: PUSH
77394: LD_INT 34
77396: PUSH
77397: LD_EXP 104
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 34
77408: PUSH
77409: LD_INT 32
77411: PUSH
77412: EMPTY
77413: LIST
77414: LIST
77415: PUSH
77416: LD_INT 34
77418: PUSH
77419: LD_INT 13
77421: PUSH
77422: EMPTY
77423: LIST
77424: LIST
77425: PUSH
77426: LD_INT 34
77428: PUSH
77429: LD_INT 52
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 34
77438: PUSH
77439: LD_EXP 109
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 34
77450: PUSH
77451: LD_INT 14
77453: PUSH
77454: EMPTY
77455: LIST
77456: LIST
77457: PUSH
77458: LD_INT 34
77460: PUSH
77461: LD_INT 53
77463: PUSH
77464: EMPTY
77465: LIST
77466: LIST
77467: PUSH
77468: LD_INT 34
77470: PUSH
77471: LD_EXP 103
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: LD_INT 34
77482: PUSH
77483: LD_INT 31
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 34
77492: PUSH
77493: LD_INT 48
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 34
77502: PUSH
77503: LD_INT 8
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: EMPTY
77511: LIST
77512: LIST
77513: LIST
77514: LIST
77515: LIST
77516: LIST
77517: LIST
77518: LIST
77519: LIST
77520: LIST
77521: LIST
77522: LIST
77523: LIST
77524: LIST
77525: PPUSH
77526: CALL_OW 72
77530: DIFF
77531: ST_TO_ADDR
// end ; end_of_file
77532: LD_VAR 0 3
77536: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
77537: LD_INT 0
77539: PPUSH
77540: PPUSH
77541: PPUSH
// if not mc_bases or not skirmish then
77542: LD_EXP 59
77546: NOT
77547: PUSH
77548: LD_EXP 57
77552: NOT
77553: OR
77554: IFFALSE 77558
// exit ;
77556: GO 77723
// for i = 1 to mc_bases do
77558: LD_ADDR_VAR 0 4
77562: PUSH
77563: DOUBLE
77564: LD_INT 1
77566: DEC
77567: ST_TO_ADDR
77568: LD_EXP 59
77572: PUSH
77573: FOR_TO
77574: IFFALSE 77721
// begin if sci in mc_bases [ i ] then
77576: LD_VAR 0 2
77580: PUSH
77581: LD_EXP 59
77585: PUSH
77586: LD_VAR 0 4
77590: ARRAY
77591: IN
77592: IFFALSE 77719
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
77594: LD_ADDR_EXP 88
77598: PUSH
77599: LD_EXP 88
77603: PPUSH
77604: LD_VAR 0 4
77608: PUSH
77609: LD_EXP 88
77613: PUSH
77614: LD_VAR 0 4
77618: ARRAY
77619: PUSH
77620: LD_INT 1
77622: PLUS
77623: PUSH
77624: EMPTY
77625: LIST
77626: LIST
77627: PPUSH
77628: LD_VAR 0 1
77632: PPUSH
77633: CALL 19307 0 3
77637: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
77638: LD_ADDR_VAR 0 5
77642: PUSH
77643: LD_EXP 59
77647: PUSH
77648: LD_VAR 0 4
77652: ARRAY
77653: PPUSH
77654: LD_INT 2
77656: PUSH
77657: LD_INT 30
77659: PUSH
77660: LD_INT 0
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 30
77669: PUSH
77670: LD_INT 1
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: EMPTY
77678: LIST
77679: LIST
77680: LIST
77681: PPUSH
77682: CALL_OW 72
77686: PPUSH
77687: LD_VAR 0 1
77691: PPUSH
77692: CALL_OW 74
77696: ST_TO_ADDR
// if tmp then
77697: LD_VAR 0 5
77701: IFFALSE 77717
// ComStandNearbyBuilding ( ape , tmp ) ;
77703: LD_VAR 0 1
77707: PPUSH
77708: LD_VAR 0 5
77712: PPUSH
77713: CALL 15921 0 2
// break ;
77717: GO 77721
// end ; end ;
77719: GO 77573
77721: POP
77722: POP
// end ;
77723: LD_VAR 0 3
77727: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
77728: LD_INT 0
77730: PPUSH
77731: PPUSH
77732: PPUSH
// if not mc_bases or not skirmish then
77733: LD_EXP 59
77737: NOT
77738: PUSH
77739: LD_EXP 57
77743: NOT
77744: OR
77745: IFFALSE 77749
// exit ;
77747: GO 77838
// for i = 1 to mc_bases do
77749: LD_ADDR_VAR 0 4
77753: PUSH
77754: DOUBLE
77755: LD_INT 1
77757: DEC
77758: ST_TO_ADDR
77759: LD_EXP 59
77763: PUSH
77764: FOR_TO
77765: IFFALSE 77836
// begin if building in mc_busy_turret_list [ i ] then
77767: LD_VAR 0 1
77771: PUSH
77772: LD_EXP 69
77776: PUSH
77777: LD_VAR 0 4
77781: ARRAY
77782: IN
77783: IFFALSE 77834
// begin tmp := mc_busy_turret_list [ i ] diff building ;
77785: LD_ADDR_VAR 0 5
77789: PUSH
77790: LD_EXP 69
77794: PUSH
77795: LD_VAR 0 4
77799: ARRAY
77800: PUSH
77801: LD_VAR 0 1
77805: DIFF
77806: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
77807: LD_ADDR_EXP 69
77811: PUSH
77812: LD_EXP 69
77816: PPUSH
77817: LD_VAR 0 4
77821: PPUSH
77822: LD_VAR 0 5
77826: PPUSH
77827: CALL_OW 1
77831: ST_TO_ADDR
// break ;
77832: GO 77836
// end ; end ;
77834: GO 77764
77836: POP
77837: POP
// end ;
77838: LD_VAR 0 3
77842: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77843: LD_INT 0
77845: PPUSH
77846: PPUSH
77847: PPUSH
// if not mc_bases or not skirmish then
77848: LD_EXP 59
77852: NOT
77853: PUSH
77854: LD_EXP 57
77858: NOT
77859: OR
77860: IFFALSE 77864
// exit ;
77862: GO 78063
// for i = 1 to mc_bases do
77864: LD_ADDR_VAR 0 5
77868: PUSH
77869: DOUBLE
77870: LD_INT 1
77872: DEC
77873: ST_TO_ADDR
77874: LD_EXP 59
77878: PUSH
77879: FOR_TO
77880: IFFALSE 78061
// if building in mc_bases [ i ] then
77882: LD_VAR 0 1
77886: PUSH
77887: LD_EXP 59
77891: PUSH
77892: LD_VAR 0 5
77896: ARRAY
77897: IN
77898: IFFALSE 78059
// begin tmp := mc_bases [ i ] diff building ;
77900: LD_ADDR_VAR 0 6
77904: PUSH
77905: LD_EXP 59
77909: PUSH
77910: LD_VAR 0 5
77914: ARRAY
77915: PUSH
77916: LD_VAR 0 1
77920: DIFF
77921: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77922: LD_ADDR_EXP 59
77926: PUSH
77927: LD_EXP 59
77931: PPUSH
77932: LD_VAR 0 5
77936: PPUSH
77937: LD_VAR 0 6
77941: PPUSH
77942: CALL_OW 1
77946: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77947: LD_VAR 0 1
77951: PUSH
77952: LD_EXP 67
77956: PUSH
77957: LD_VAR 0 5
77961: ARRAY
77962: IN
77963: IFFALSE 78002
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77965: LD_ADDR_EXP 67
77969: PUSH
77970: LD_EXP 67
77974: PPUSH
77975: LD_VAR 0 5
77979: PPUSH
77980: LD_EXP 67
77984: PUSH
77985: LD_VAR 0 5
77989: ARRAY
77990: PUSH
77991: LD_VAR 0 1
77995: DIFF
77996: PPUSH
77997: CALL_OW 1
78001: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
78002: LD_VAR 0 1
78006: PUSH
78007: LD_EXP 68
78011: PUSH
78012: LD_VAR 0 5
78016: ARRAY
78017: IN
78018: IFFALSE 78057
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
78020: LD_ADDR_EXP 68
78024: PUSH
78025: LD_EXP 68
78029: PPUSH
78030: LD_VAR 0 5
78034: PPUSH
78035: LD_EXP 68
78039: PUSH
78040: LD_VAR 0 5
78044: ARRAY
78045: PUSH
78046: LD_VAR 0 1
78050: DIFF
78051: PPUSH
78052: CALL_OW 1
78056: ST_TO_ADDR
// break ;
78057: GO 78061
// end ;
78059: GO 77879
78061: POP
78062: POP
// end ;
78063: LD_VAR 0 4
78067: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
78068: LD_INT 0
78070: PPUSH
78071: PPUSH
78072: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
78073: LD_EXP 59
78077: NOT
78078: PUSH
78079: LD_EXP 57
78083: NOT
78084: OR
78085: PUSH
78086: LD_VAR 0 3
78090: PUSH
78091: LD_EXP 85
78095: IN
78096: NOT
78097: OR
78098: IFFALSE 78102
// exit ;
78100: GO 78225
// for i = 1 to mc_vehicles do
78102: LD_ADDR_VAR 0 6
78106: PUSH
78107: DOUBLE
78108: LD_INT 1
78110: DEC
78111: ST_TO_ADDR
78112: LD_EXP 78
78116: PUSH
78117: FOR_TO
78118: IFFALSE 78223
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
78120: LD_VAR 0 2
78124: PUSH
78125: LD_EXP 78
78129: PUSH
78130: LD_VAR 0 6
78134: ARRAY
78135: IN
78136: PUSH
78137: LD_VAR 0 1
78141: PUSH
78142: LD_EXP 78
78146: PUSH
78147: LD_VAR 0 6
78151: ARRAY
78152: IN
78153: OR
78154: IFFALSE 78221
// begin tmp := mc_vehicles [ i ] diff old ;
78156: LD_ADDR_VAR 0 7
78160: PUSH
78161: LD_EXP 78
78165: PUSH
78166: LD_VAR 0 6
78170: ARRAY
78171: PUSH
78172: LD_VAR 0 2
78176: DIFF
78177: ST_TO_ADDR
// tmp := tmp diff new ;
78178: LD_ADDR_VAR 0 7
78182: PUSH
78183: LD_VAR 0 7
78187: PUSH
78188: LD_VAR 0 1
78192: DIFF
78193: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
78194: LD_ADDR_EXP 78
78198: PUSH
78199: LD_EXP 78
78203: PPUSH
78204: LD_VAR 0 6
78208: PPUSH
78209: LD_VAR 0 7
78213: PPUSH
78214: CALL_OW 1
78218: ST_TO_ADDR
// break ;
78219: GO 78223
// end ;
78221: GO 78117
78223: POP
78224: POP
// end ;
78225: LD_VAR 0 5
78229: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
78230: LD_INT 0
78232: PPUSH
78233: PPUSH
78234: PPUSH
78235: PPUSH
// if not mc_bases or not skirmish then
78236: LD_EXP 59
78240: NOT
78241: PUSH
78242: LD_EXP 57
78246: NOT
78247: OR
78248: IFFALSE 78252
// exit ;
78250: GO 78635
// side := GetSide ( vehicle ) ;
78252: LD_ADDR_VAR 0 5
78256: PUSH
78257: LD_VAR 0 1
78261: PPUSH
78262: CALL_OW 255
78266: ST_TO_ADDR
// for i = 1 to mc_bases do
78267: LD_ADDR_VAR 0 4
78271: PUSH
78272: DOUBLE
78273: LD_INT 1
78275: DEC
78276: ST_TO_ADDR
78277: LD_EXP 59
78281: PUSH
78282: FOR_TO
78283: IFFALSE 78633
// begin if factory in mc_bases [ i ] then
78285: LD_VAR 0 2
78289: PUSH
78290: LD_EXP 59
78294: PUSH
78295: LD_VAR 0 4
78299: ARRAY
78300: IN
78301: IFFALSE 78631
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
78303: LD_EXP 81
78307: PUSH
78308: LD_VAR 0 4
78312: ARRAY
78313: PUSH
78314: LD_EXP 70
78318: PUSH
78319: LD_VAR 0 4
78323: ARRAY
78324: LESS
78325: PUSH
78326: LD_VAR 0 1
78330: PPUSH
78331: CALL_OW 264
78335: PUSH
78336: LD_INT 31
78338: PUSH
78339: LD_INT 32
78341: PUSH
78342: LD_INT 51
78344: PUSH
78345: LD_EXP 104
78349: PUSH
78350: LD_INT 12
78352: PUSH
78353: LD_INT 30
78355: PUSH
78356: LD_EXP 103
78360: PUSH
78361: LD_INT 11
78363: PUSH
78364: LD_INT 53
78366: PUSH
78367: LD_INT 14
78369: PUSH
78370: LD_EXP 107
78374: PUSH
78375: LD_INT 29
78377: PUSH
78378: LD_EXP 105
78382: PUSH
78383: LD_INT 13
78385: PUSH
78386: LD_INT 52
78388: PUSH
78389: LD_EXP 109
78393: PUSH
78394: LD_INT 48
78396: PUSH
78397: LD_INT 8
78399: PUSH
78400: EMPTY
78401: LIST
78402: LIST
78403: LIST
78404: LIST
78405: LIST
78406: LIST
78407: LIST
78408: LIST
78409: LIST
78410: LIST
78411: LIST
78412: LIST
78413: LIST
78414: LIST
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: IN
78420: NOT
78421: AND
78422: IFFALSE 78470
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
78424: LD_ADDR_EXP 81
78428: PUSH
78429: LD_EXP 81
78433: PPUSH
78434: LD_VAR 0 4
78438: PUSH
78439: LD_EXP 81
78443: PUSH
78444: LD_VAR 0 4
78448: ARRAY
78449: PUSH
78450: LD_INT 1
78452: PLUS
78453: PUSH
78454: EMPTY
78455: LIST
78456: LIST
78457: PPUSH
78458: LD_VAR 0 1
78462: PPUSH
78463: CALL 19307 0 3
78467: ST_TO_ADDR
78468: GO 78514
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
78470: LD_ADDR_EXP 78
78474: PUSH
78475: LD_EXP 78
78479: PPUSH
78480: LD_VAR 0 4
78484: PUSH
78485: LD_EXP 78
78489: PUSH
78490: LD_VAR 0 4
78494: ARRAY
78495: PUSH
78496: LD_INT 1
78498: PLUS
78499: PUSH
78500: EMPTY
78501: LIST
78502: LIST
78503: PPUSH
78504: LD_VAR 0 1
78508: PPUSH
78509: CALL 19307 0 3
78513: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
78514: LD_VAR 0 1
78518: PPUSH
78519: CALL_OW 263
78523: PUSH
78524: LD_INT 2
78526: EQUAL
78527: IFFALSE 78547
// begin repeat wait ( 0 0$1 ) ;
78529: LD_INT 35
78531: PPUSH
78532: CALL_OW 67
// until IsControledBy ( vehicle ) ;
78536: LD_VAR 0 1
78540: PPUSH
78541: CALL_OW 312
78545: IFFALSE 78529
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
78547: LD_VAR 0 1
78551: PPUSH
78552: LD_EXP 83
78556: PUSH
78557: LD_VAR 0 4
78561: ARRAY
78562: PPUSH
78563: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
78567: LD_VAR 0 1
78571: PPUSH
78572: CALL_OW 263
78576: PUSH
78577: LD_INT 1
78579: NONEQUAL
78580: IFFALSE 78584
// break ;
78582: GO 78633
// repeat wait ( 0 0$1 ) ;
78584: LD_INT 35
78586: PPUSH
78587: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
78591: LD_VAR 0 1
78595: PPUSH
78596: LD_EXP 83
78600: PUSH
78601: LD_VAR 0 4
78605: ARRAY
78606: PPUSH
78607: CALL_OW 308
78611: IFFALSE 78584
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
78613: LD_VAR 0 1
78617: PPUSH
78618: CALL_OW 311
78622: PPUSH
78623: CALL_OW 121
// exit ;
78627: POP
78628: POP
78629: GO 78635
// end ; end ;
78631: GO 78282
78633: POP
78634: POP
// end ;
78635: LD_VAR 0 3
78639: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
78640: LD_INT 0
78642: PPUSH
78643: PPUSH
78644: PPUSH
78645: PPUSH
// if not mc_bases or not skirmish then
78646: LD_EXP 59
78650: NOT
78651: PUSH
78652: LD_EXP 57
78656: NOT
78657: OR
78658: IFFALSE 78662
// exit ;
78660: GO 79015
// repeat wait ( 0 0$1 ) ;
78662: LD_INT 35
78664: PPUSH
78665: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
78669: LD_VAR 0 2
78673: PPUSH
78674: LD_VAR 0 3
78678: PPUSH
78679: CALL_OW 284
78683: IFFALSE 78662
// if GetResourceTypeXY ( x , y ) = mat_artefact then
78685: LD_VAR 0 2
78689: PPUSH
78690: LD_VAR 0 3
78694: PPUSH
78695: CALL_OW 283
78699: PUSH
78700: LD_INT 4
78702: EQUAL
78703: IFFALSE 78707
// exit ;
78705: GO 79015
// for i = 1 to mc_bases do
78707: LD_ADDR_VAR 0 7
78711: PUSH
78712: DOUBLE
78713: LD_INT 1
78715: DEC
78716: ST_TO_ADDR
78717: LD_EXP 59
78721: PUSH
78722: FOR_TO
78723: IFFALSE 79013
// begin if mc_crates_area [ i ] then
78725: LD_EXP 77
78729: PUSH
78730: LD_VAR 0 7
78734: ARRAY
78735: IFFALSE 78846
// for j in mc_crates_area [ i ] do
78737: LD_ADDR_VAR 0 8
78741: PUSH
78742: LD_EXP 77
78746: PUSH
78747: LD_VAR 0 7
78751: ARRAY
78752: PUSH
78753: FOR_IN
78754: IFFALSE 78844
// if InArea ( x , y , j ) then
78756: LD_VAR 0 2
78760: PPUSH
78761: LD_VAR 0 3
78765: PPUSH
78766: LD_VAR 0 8
78770: PPUSH
78771: CALL_OW 309
78775: IFFALSE 78842
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78777: LD_ADDR_EXP 75
78781: PUSH
78782: LD_EXP 75
78786: PPUSH
78787: LD_VAR 0 7
78791: PUSH
78792: LD_EXP 75
78796: PUSH
78797: LD_VAR 0 7
78801: ARRAY
78802: PUSH
78803: LD_INT 1
78805: PLUS
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PPUSH
78811: LD_VAR 0 4
78815: PUSH
78816: LD_VAR 0 2
78820: PUSH
78821: LD_VAR 0 3
78825: PUSH
78826: EMPTY
78827: LIST
78828: LIST
78829: LIST
78830: PPUSH
78831: CALL 19307 0 3
78835: ST_TO_ADDR
// exit ;
78836: POP
78837: POP
78838: POP
78839: POP
78840: GO 79015
// end ;
78842: GO 78753
78844: POP
78845: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78846: LD_ADDR_VAR 0 9
78850: PUSH
78851: LD_EXP 59
78855: PUSH
78856: LD_VAR 0 7
78860: ARRAY
78861: PPUSH
78862: LD_INT 2
78864: PUSH
78865: LD_INT 30
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 30
78877: PUSH
78878: LD_INT 1
78880: PUSH
78881: EMPTY
78882: LIST
78883: LIST
78884: PUSH
78885: EMPTY
78886: LIST
78887: LIST
78888: LIST
78889: PPUSH
78890: CALL_OW 72
78894: ST_TO_ADDR
// if not depot then
78895: LD_VAR 0 9
78899: NOT
78900: IFFALSE 78904
// continue ;
78902: GO 78722
// for j in depot do
78904: LD_ADDR_VAR 0 8
78908: PUSH
78909: LD_VAR 0 9
78913: PUSH
78914: FOR_IN
78915: IFFALSE 79009
// if GetDistUnitXY ( j , x , y ) < 30 then
78917: LD_VAR 0 8
78921: PPUSH
78922: LD_VAR 0 2
78926: PPUSH
78927: LD_VAR 0 3
78931: PPUSH
78932: CALL_OW 297
78936: PUSH
78937: LD_INT 30
78939: LESS
78940: IFFALSE 79007
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78942: LD_ADDR_EXP 75
78946: PUSH
78947: LD_EXP 75
78951: PPUSH
78952: LD_VAR 0 7
78956: PUSH
78957: LD_EXP 75
78961: PUSH
78962: LD_VAR 0 7
78966: ARRAY
78967: PUSH
78968: LD_INT 1
78970: PLUS
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PPUSH
78976: LD_VAR 0 4
78980: PUSH
78981: LD_VAR 0 2
78985: PUSH
78986: LD_VAR 0 3
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: LIST
78995: PPUSH
78996: CALL 19307 0 3
79000: ST_TO_ADDR
// exit ;
79001: POP
79002: POP
79003: POP
79004: POP
79005: GO 79015
// end ;
79007: GO 78914
79009: POP
79010: POP
// end ;
79011: GO 78722
79013: POP
79014: POP
// end ;
79015: LD_VAR 0 6
79019: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
79020: LD_INT 0
79022: PPUSH
79023: PPUSH
79024: PPUSH
79025: PPUSH
// if not mc_bases or not skirmish then
79026: LD_EXP 59
79030: NOT
79031: PUSH
79032: LD_EXP 57
79036: NOT
79037: OR
79038: IFFALSE 79042
// exit ;
79040: GO 79319
// side := GetSide ( lab ) ;
79042: LD_ADDR_VAR 0 4
79046: PUSH
79047: LD_VAR 0 2
79051: PPUSH
79052: CALL_OW 255
79056: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
79057: LD_VAR 0 4
79061: PUSH
79062: LD_EXP 85
79066: IN
79067: NOT
79068: PUSH
79069: LD_EXP 86
79073: NOT
79074: OR
79075: PUSH
79076: LD_EXP 59
79080: NOT
79081: OR
79082: IFFALSE 79086
// exit ;
79084: GO 79319
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
79086: LD_ADDR_EXP 86
79090: PUSH
79091: LD_EXP 86
79095: PPUSH
79096: LD_VAR 0 4
79100: PPUSH
79101: LD_EXP 86
79105: PUSH
79106: LD_VAR 0 4
79110: ARRAY
79111: PUSH
79112: LD_VAR 0 1
79116: DIFF
79117: PPUSH
79118: CALL_OW 1
79122: ST_TO_ADDR
// for i = 1 to mc_bases do
79123: LD_ADDR_VAR 0 5
79127: PUSH
79128: DOUBLE
79129: LD_INT 1
79131: DEC
79132: ST_TO_ADDR
79133: LD_EXP 59
79137: PUSH
79138: FOR_TO
79139: IFFALSE 79317
// begin if lab in mc_bases [ i ] then
79141: LD_VAR 0 2
79145: PUSH
79146: LD_EXP 59
79150: PUSH
79151: LD_VAR 0 5
79155: ARRAY
79156: IN
79157: IFFALSE 79315
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
79159: LD_VAR 0 1
79163: PUSH
79164: LD_INT 11
79166: PUSH
79167: LD_INT 4
79169: PUSH
79170: LD_INT 3
79172: PUSH
79173: LD_INT 2
79175: PUSH
79176: EMPTY
79177: LIST
79178: LIST
79179: LIST
79180: LIST
79181: IN
79182: PUSH
79183: LD_EXP 89
79187: PUSH
79188: LD_VAR 0 5
79192: ARRAY
79193: AND
79194: IFFALSE 79315
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
79196: LD_ADDR_VAR 0 6
79200: PUSH
79201: LD_EXP 89
79205: PUSH
79206: LD_VAR 0 5
79210: ARRAY
79211: PUSH
79212: LD_INT 1
79214: ARRAY
79215: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79216: LD_ADDR_EXP 89
79220: PUSH
79221: LD_EXP 89
79225: PPUSH
79226: LD_VAR 0 5
79230: PPUSH
79231: EMPTY
79232: PPUSH
79233: CALL_OW 1
79237: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
79238: LD_VAR 0 6
79242: PPUSH
79243: LD_INT 0
79245: PPUSH
79246: CALL_OW 109
// ComExitBuilding ( tmp ) ;
79250: LD_VAR 0 6
79254: PPUSH
79255: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
79259: LD_ADDR_EXP 88
79263: PUSH
79264: LD_EXP 88
79268: PPUSH
79269: LD_VAR 0 5
79273: PPUSH
79274: LD_EXP 88
79278: PUSH
79279: LD_VAR 0 5
79283: ARRAY
79284: PPUSH
79285: LD_INT 1
79287: PPUSH
79288: LD_VAR 0 6
79292: PPUSH
79293: CALL_OW 2
79297: PPUSH
79298: CALL_OW 1
79302: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
79303: LD_VAR 0 5
79307: PPUSH
79308: LD_INT 112
79310: PPUSH
79311: CALL 56148 0 2
// end ; end ; end ;
79315: GO 79138
79317: POP
79318: POP
// end ;
79319: LD_VAR 0 3
79323: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
79324: LD_INT 0
79326: PPUSH
79327: PPUSH
79328: PPUSH
79329: PPUSH
79330: PPUSH
79331: PPUSH
79332: PPUSH
79333: PPUSH
// if not mc_bases or not skirmish then
79334: LD_EXP 59
79338: NOT
79339: PUSH
79340: LD_EXP 57
79344: NOT
79345: OR
79346: IFFALSE 79350
// exit ;
79348: GO 80721
// for i = 1 to mc_bases do
79350: LD_ADDR_VAR 0 3
79354: PUSH
79355: DOUBLE
79356: LD_INT 1
79358: DEC
79359: ST_TO_ADDR
79360: LD_EXP 59
79364: PUSH
79365: FOR_TO
79366: IFFALSE 80719
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
79368: LD_VAR 0 1
79372: PUSH
79373: LD_EXP 59
79377: PUSH
79378: LD_VAR 0 3
79382: ARRAY
79383: IN
79384: PUSH
79385: LD_VAR 0 1
79389: PUSH
79390: LD_EXP 66
79394: PUSH
79395: LD_VAR 0 3
79399: ARRAY
79400: IN
79401: OR
79402: PUSH
79403: LD_VAR 0 1
79407: PUSH
79408: LD_EXP 81
79412: PUSH
79413: LD_VAR 0 3
79417: ARRAY
79418: IN
79419: OR
79420: PUSH
79421: LD_VAR 0 1
79425: PUSH
79426: LD_EXP 78
79430: PUSH
79431: LD_VAR 0 3
79435: ARRAY
79436: IN
79437: OR
79438: PUSH
79439: LD_VAR 0 1
79443: PUSH
79444: LD_EXP 88
79448: PUSH
79449: LD_VAR 0 3
79453: ARRAY
79454: IN
79455: OR
79456: PUSH
79457: LD_VAR 0 1
79461: PUSH
79462: LD_EXP 89
79466: PUSH
79467: LD_VAR 0 3
79471: ARRAY
79472: IN
79473: OR
79474: IFFALSE 80717
// begin if un in mc_ape [ i ] then
79476: LD_VAR 0 1
79480: PUSH
79481: LD_EXP 88
79485: PUSH
79486: LD_VAR 0 3
79490: ARRAY
79491: IN
79492: IFFALSE 79531
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
79494: LD_ADDR_EXP 88
79498: PUSH
79499: LD_EXP 88
79503: PPUSH
79504: LD_VAR 0 3
79508: PPUSH
79509: LD_EXP 88
79513: PUSH
79514: LD_VAR 0 3
79518: ARRAY
79519: PUSH
79520: LD_VAR 0 1
79524: DIFF
79525: PPUSH
79526: CALL_OW 1
79530: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
79531: LD_VAR 0 1
79535: PUSH
79536: LD_EXP 89
79540: PUSH
79541: LD_VAR 0 3
79545: ARRAY
79546: IN
79547: IFFALSE 79571
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
79549: LD_ADDR_EXP 89
79553: PUSH
79554: LD_EXP 89
79558: PPUSH
79559: LD_VAR 0 3
79563: PPUSH
79564: EMPTY
79565: PPUSH
79566: CALL_OW 1
79570: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
79571: LD_VAR 0 1
79575: PPUSH
79576: CALL_OW 247
79580: PUSH
79581: LD_INT 2
79583: EQUAL
79584: PUSH
79585: LD_VAR 0 1
79589: PPUSH
79590: CALL_OW 110
79594: PUSH
79595: LD_INT 20
79597: EQUAL
79598: PUSH
79599: LD_VAR 0 1
79603: PUSH
79604: LD_EXP 81
79608: PUSH
79609: LD_VAR 0 3
79613: ARRAY
79614: IN
79615: OR
79616: PUSH
79617: LD_VAR 0 1
79621: PPUSH
79622: CALL_OW 264
79626: PUSH
79627: LD_INT 12
79629: PUSH
79630: LD_INT 51
79632: PUSH
79633: LD_EXP 104
79637: PUSH
79638: LD_INT 32
79640: PUSH
79641: LD_INT 13
79643: PUSH
79644: LD_INT 52
79646: PUSH
79647: LD_INT 31
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: LIST
79657: LIST
79658: IN
79659: OR
79660: AND
79661: IFFALSE 79969
// begin if un in mc_defender [ i ] then
79663: LD_VAR 0 1
79667: PUSH
79668: LD_EXP 81
79672: PUSH
79673: LD_VAR 0 3
79677: ARRAY
79678: IN
79679: IFFALSE 79718
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79681: LD_ADDR_EXP 81
79685: PUSH
79686: LD_EXP 81
79690: PPUSH
79691: LD_VAR 0 3
79695: PPUSH
79696: LD_EXP 81
79700: PUSH
79701: LD_VAR 0 3
79705: ARRAY
79706: PUSH
79707: LD_VAR 0 1
79711: DIFF
79712: PPUSH
79713: CALL_OW 1
79717: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
79718: LD_ADDR_VAR 0 8
79722: PUSH
79723: LD_VAR 0 3
79727: PPUSH
79728: LD_INT 3
79730: PPUSH
79731: CALL 76368 0 2
79735: ST_TO_ADDR
// if fac then
79736: LD_VAR 0 8
79740: IFFALSE 79969
// begin for j in fac do
79742: LD_ADDR_VAR 0 4
79746: PUSH
79747: LD_VAR 0 8
79751: PUSH
79752: FOR_IN
79753: IFFALSE 79967
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
79755: LD_ADDR_VAR 0 9
79759: PUSH
79760: LD_VAR 0 8
79764: PPUSH
79765: LD_VAR 0 1
79769: PPUSH
79770: CALL_OW 265
79774: PPUSH
79775: LD_VAR 0 1
79779: PPUSH
79780: CALL_OW 262
79784: PPUSH
79785: LD_VAR 0 1
79789: PPUSH
79790: CALL_OW 263
79794: PPUSH
79795: LD_VAR 0 1
79799: PPUSH
79800: CALL_OW 264
79804: PPUSH
79805: CALL 16839 0 5
79809: ST_TO_ADDR
// if components then
79810: LD_VAR 0 9
79814: IFFALSE 79965
// begin if GetWeapon ( un ) = ar_control_tower then
79816: LD_VAR 0 1
79820: PPUSH
79821: CALL_OW 264
79825: PUSH
79826: LD_INT 31
79828: EQUAL
79829: IFFALSE 79946
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79831: LD_VAR 0 1
79835: PPUSH
79836: CALL_OW 311
79840: PPUSH
79841: LD_INT 0
79843: PPUSH
79844: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79848: LD_ADDR_EXP 99
79852: PUSH
79853: LD_EXP 99
79857: PPUSH
79858: LD_VAR 0 3
79862: PPUSH
79863: LD_EXP 99
79867: PUSH
79868: LD_VAR 0 3
79872: ARRAY
79873: PUSH
79874: LD_VAR 0 1
79878: PPUSH
79879: CALL_OW 311
79883: DIFF
79884: PPUSH
79885: CALL_OW 1
79889: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79890: LD_ADDR_VAR 0 7
79894: PUSH
79895: LD_EXP 80
79899: PUSH
79900: LD_VAR 0 3
79904: ARRAY
79905: PPUSH
79906: LD_INT 1
79908: PPUSH
79909: LD_VAR 0 9
79913: PPUSH
79914: CALL_OW 2
79918: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79919: LD_ADDR_EXP 80
79923: PUSH
79924: LD_EXP 80
79928: PPUSH
79929: LD_VAR 0 3
79933: PPUSH
79934: LD_VAR 0 7
79938: PPUSH
79939: CALL_OW 1
79943: ST_TO_ADDR
// end else
79944: GO 79963
// MC_InsertProduceList ( i , [ components ] ) ;
79946: LD_VAR 0 3
79950: PPUSH
79951: LD_VAR 0 9
79955: PUSH
79956: EMPTY
79957: LIST
79958: PPUSH
79959: CALL 75913 0 2
// break ;
79963: GO 79967
// end ; end ;
79965: GO 79752
79967: POP
79968: POP
// end ; end ; if GetType ( un ) = unit_building then
79969: LD_VAR 0 1
79973: PPUSH
79974: CALL_OW 247
79978: PUSH
79979: LD_INT 3
79981: EQUAL
79982: IFFALSE 80385
// begin btype := GetBType ( un ) ;
79984: LD_ADDR_VAR 0 5
79988: PUSH
79989: LD_VAR 0 1
79993: PPUSH
79994: CALL_OW 266
79998: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79999: LD_VAR 0 5
80003: PUSH
80004: LD_INT 29
80006: PUSH
80007: LD_INT 30
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: IN
80014: IFFALSE 80087
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
80016: LD_VAR 0 1
80020: PPUSH
80021: CALL_OW 250
80025: PPUSH
80026: LD_VAR 0 1
80030: PPUSH
80031: CALL_OW 251
80035: PPUSH
80036: LD_VAR 0 1
80040: PPUSH
80041: CALL_OW 255
80045: PPUSH
80046: CALL_OW 440
80050: NOT
80051: IFFALSE 80087
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
80053: LD_VAR 0 1
80057: PPUSH
80058: CALL_OW 250
80062: PPUSH
80063: LD_VAR 0 1
80067: PPUSH
80068: CALL_OW 251
80072: PPUSH
80073: LD_VAR 0 1
80077: PPUSH
80078: CALL_OW 255
80082: PPUSH
80083: CALL_OW 441
// end ; if btype = b_warehouse then
80087: LD_VAR 0 5
80091: PUSH
80092: LD_INT 1
80094: EQUAL
80095: IFFALSE 80113
// begin btype := b_depot ;
80097: LD_ADDR_VAR 0 5
80101: PUSH
80102: LD_INT 0
80104: ST_TO_ADDR
// pos := 1 ;
80105: LD_ADDR_VAR 0 6
80109: PUSH
80110: LD_INT 1
80112: ST_TO_ADDR
// end ; if btype = b_factory then
80113: LD_VAR 0 5
80117: PUSH
80118: LD_INT 3
80120: EQUAL
80121: IFFALSE 80139
// begin btype := b_workshop ;
80123: LD_ADDR_VAR 0 5
80127: PUSH
80128: LD_INT 2
80130: ST_TO_ADDR
// pos := 1 ;
80131: LD_ADDR_VAR 0 6
80135: PUSH
80136: LD_INT 1
80138: ST_TO_ADDR
// end ; if btype = b_barracks then
80139: LD_VAR 0 5
80143: PUSH
80144: LD_INT 5
80146: EQUAL
80147: IFFALSE 80157
// btype := b_armoury ;
80149: LD_ADDR_VAR 0 5
80153: PUSH
80154: LD_INT 4
80156: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
80157: LD_VAR 0 5
80161: PUSH
80162: LD_INT 7
80164: PUSH
80165: LD_INT 8
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: IN
80172: IFFALSE 80182
// btype := b_lab ;
80174: LD_ADDR_VAR 0 5
80178: PUSH
80179: LD_INT 6
80181: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
80182: LD_ADDR_EXP 64
80186: PUSH
80187: LD_EXP 64
80191: PPUSH
80192: LD_VAR 0 3
80196: PUSH
80197: LD_EXP 64
80201: PUSH
80202: LD_VAR 0 3
80206: ARRAY
80207: PUSH
80208: LD_INT 1
80210: PLUS
80211: PUSH
80212: EMPTY
80213: LIST
80214: LIST
80215: PPUSH
80216: LD_VAR 0 5
80220: PUSH
80221: LD_VAR 0 1
80225: PPUSH
80226: CALL_OW 250
80230: PUSH
80231: LD_VAR 0 1
80235: PPUSH
80236: CALL_OW 251
80240: PUSH
80241: LD_VAR 0 1
80245: PPUSH
80246: CALL_OW 254
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: LIST
80255: LIST
80256: PPUSH
80257: CALL 19307 0 3
80261: ST_TO_ADDR
// if pos = 1 then
80262: LD_VAR 0 6
80266: PUSH
80267: LD_INT 1
80269: EQUAL
80270: IFFALSE 80385
// begin tmp := mc_build_list [ i ] ;
80272: LD_ADDR_VAR 0 7
80276: PUSH
80277: LD_EXP 64
80281: PUSH
80282: LD_VAR 0 3
80286: ARRAY
80287: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
80288: LD_VAR 0 7
80292: PPUSH
80293: LD_INT 2
80295: PUSH
80296: LD_INT 30
80298: PUSH
80299: LD_INT 0
80301: PUSH
80302: EMPTY
80303: LIST
80304: LIST
80305: PUSH
80306: LD_INT 30
80308: PUSH
80309: LD_INT 1
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: LIST
80320: PPUSH
80321: CALL_OW 72
80325: IFFALSE 80335
// pos := 2 ;
80327: LD_ADDR_VAR 0 6
80331: PUSH
80332: LD_INT 2
80334: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
80335: LD_ADDR_VAR 0 7
80339: PUSH
80340: LD_VAR 0 7
80344: PPUSH
80345: LD_VAR 0 6
80349: PPUSH
80350: LD_VAR 0 7
80354: PPUSH
80355: CALL 19633 0 3
80359: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
80360: LD_ADDR_EXP 64
80364: PUSH
80365: LD_EXP 64
80369: PPUSH
80370: LD_VAR 0 3
80374: PPUSH
80375: LD_VAR 0 7
80379: PPUSH
80380: CALL_OW 1
80384: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
80385: LD_VAR 0 1
80389: PUSH
80390: LD_EXP 59
80394: PUSH
80395: LD_VAR 0 3
80399: ARRAY
80400: IN
80401: IFFALSE 80440
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
80403: LD_ADDR_EXP 59
80407: PUSH
80408: LD_EXP 59
80412: PPUSH
80413: LD_VAR 0 3
80417: PPUSH
80418: LD_EXP 59
80422: PUSH
80423: LD_VAR 0 3
80427: ARRAY
80428: PUSH
80429: LD_VAR 0 1
80433: DIFF
80434: PPUSH
80435: CALL_OW 1
80439: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
80440: LD_VAR 0 1
80444: PUSH
80445: LD_EXP 66
80449: PUSH
80450: LD_VAR 0 3
80454: ARRAY
80455: IN
80456: IFFALSE 80495
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
80458: LD_ADDR_EXP 66
80462: PUSH
80463: LD_EXP 66
80467: PPUSH
80468: LD_VAR 0 3
80472: PPUSH
80473: LD_EXP 66
80477: PUSH
80478: LD_VAR 0 3
80482: ARRAY
80483: PUSH
80484: LD_VAR 0 1
80488: DIFF
80489: PPUSH
80490: CALL_OW 1
80494: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
80495: LD_VAR 0 1
80499: PUSH
80500: LD_EXP 78
80504: PUSH
80505: LD_VAR 0 3
80509: ARRAY
80510: IN
80511: IFFALSE 80550
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
80513: LD_ADDR_EXP 78
80517: PUSH
80518: LD_EXP 78
80522: PPUSH
80523: LD_VAR 0 3
80527: PPUSH
80528: LD_EXP 78
80532: PUSH
80533: LD_VAR 0 3
80537: ARRAY
80538: PUSH
80539: LD_VAR 0 1
80543: DIFF
80544: PPUSH
80545: CALL_OW 1
80549: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
80550: LD_VAR 0 1
80554: PUSH
80555: LD_EXP 81
80559: PUSH
80560: LD_VAR 0 3
80564: ARRAY
80565: IN
80566: IFFALSE 80605
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
80568: LD_ADDR_EXP 81
80572: PUSH
80573: LD_EXP 81
80577: PPUSH
80578: LD_VAR 0 3
80582: PPUSH
80583: LD_EXP 81
80587: PUSH
80588: LD_VAR 0 3
80592: ARRAY
80593: PUSH
80594: LD_VAR 0 1
80598: DIFF
80599: PPUSH
80600: CALL_OW 1
80604: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
80605: LD_VAR 0 1
80609: PUSH
80610: LD_EXP 68
80614: PUSH
80615: LD_VAR 0 3
80619: ARRAY
80620: IN
80621: IFFALSE 80660
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
80623: LD_ADDR_EXP 68
80627: PUSH
80628: LD_EXP 68
80632: PPUSH
80633: LD_VAR 0 3
80637: PPUSH
80638: LD_EXP 68
80642: PUSH
80643: LD_VAR 0 3
80647: ARRAY
80648: PUSH
80649: LD_VAR 0 1
80653: DIFF
80654: PPUSH
80655: CALL_OW 1
80659: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
80660: LD_VAR 0 1
80664: PUSH
80665: LD_EXP 67
80669: PUSH
80670: LD_VAR 0 3
80674: ARRAY
80675: IN
80676: IFFALSE 80715
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
80678: LD_ADDR_EXP 67
80682: PUSH
80683: LD_EXP 67
80687: PPUSH
80688: LD_VAR 0 3
80692: PPUSH
80693: LD_EXP 67
80697: PUSH
80698: LD_VAR 0 3
80702: ARRAY
80703: PUSH
80704: LD_VAR 0 1
80708: DIFF
80709: PPUSH
80710: CALL_OW 1
80714: ST_TO_ADDR
// end ; break ;
80715: GO 80719
// end ;
80717: GO 79365
80719: POP
80720: POP
// end ;
80721: LD_VAR 0 2
80725: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
80726: LD_INT 0
80728: PPUSH
80729: PPUSH
80730: PPUSH
// if not mc_bases or not skirmish then
80731: LD_EXP 59
80735: NOT
80736: PUSH
80737: LD_EXP 57
80741: NOT
80742: OR
80743: IFFALSE 80747
// exit ;
80745: GO 80962
// for i = 1 to mc_bases do
80747: LD_ADDR_VAR 0 3
80751: PUSH
80752: DOUBLE
80753: LD_INT 1
80755: DEC
80756: ST_TO_ADDR
80757: LD_EXP 59
80761: PUSH
80762: FOR_TO
80763: IFFALSE 80960
// begin if building in mc_construct_list [ i ] then
80765: LD_VAR 0 1
80769: PUSH
80770: LD_EXP 66
80774: PUSH
80775: LD_VAR 0 3
80779: ARRAY
80780: IN
80781: IFFALSE 80958
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80783: LD_ADDR_EXP 66
80787: PUSH
80788: LD_EXP 66
80792: PPUSH
80793: LD_VAR 0 3
80797: PPUSH
80798: LD_EXP 66
80802: PUSH
80803: LD_VAR 0 3
80807: ARRAY
80808: PUSH
80809: LD_VAR 0 1
80813: DIFF
80814: PPUSH
80815: CALL_OW 1
80819: ST_TO_ADDR
// if building in mc_lab [ i ] then
80820: LD_VAR 0 1
80824: PUSH
80825: LD_EXP 92
80829: PUSH
80830: LD_VAR 0 3
80834: ARRAY
80835: IN
80836: IFFALSE 80891
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80838: LD_ADDR_EXP 93
80842: PUSH
80843: LD_EXP 93
80847: PPUSH
80848: LD_VAR 0 3
80852: PPUSH
80853: LD_EXP 93
80857: PUSH
80858: LD_VAR 0 3
80862: ARRAY
80863: PPUSH
80864: LD_INT 1
80866: PPUSH
80867: LD_EXP 93
80871: PUSH
80872: LD_VAR 0 3
80876: ARRAY
80877: PPUSH
80878: LD_INT 0
80880: PPUSH
80881: CALL 18725 0 4
80885: PPUSH
80886: CALL_OW 1
80890: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80891: LD_VAR 0 1
80895: PUSH
80896: LD_EXP 59
80900: PUSH
80901: LD_VAR 0 3
80905: ARRAY
80906: IN
80907: NOT
80908: IFFALSE 80954
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80910: LD_ADDR_EXP 59
80914: PUSH
80915: LD_EXP 59
80919: PPUSH
80920: LD_VAR 0 3
80924: PUSH
80925: LD_EXP 59
80929: PUSH
80930: LD_VAR 0 3
80934: ARRAY
80935: PUSH
80936: LD_INT 1
80938: PLUS
80939: PUSH
80940: EMPTY
80941: LIST
80942: LIST
80943: PPUSH
80944: LD_VAR 0 1
80948: PPUSH
80949: CALL 19307 0 3
80953: ST_TO_ADDR
// exit ;
80954: POP
80955: POP
80956: GO 80962
// end ; end ;
80958: GO 80762
80960: POP
80961: POP
// end ;
80962: LD_VAR 0 2
80966: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80967: LD_INT 0
80969: PPUSH
80970: PPUSH
80971: PPUSH
80972: PPUSH
80973: PPUSH
80974: PPUSH
80975: PPUSH
// if not mc_bases or not skirmish then
80976: LD_EXP 59
80980: NOT
80981: PUSH
80982: LD_EXP 57
80986: NOT
80987: OR
80988: IFFALSE 80992
// exit ;
80990: GO 81653
// for i = 1 to mc_bases do
80992: LD_ADDR_VAR 0 3
80996: PUSH
80997: DOUBLE
80998: LD_INT 1
81000: DEC
81001: ST_TO_ADDR
81002: LD_EXP 59
81006: PUSH
81007: FOR_TO
81008: IFFALSE 81651
// begin if building in mc_construct_list [ i ] then
81010: LD_VAR 0 1
81014: PUSH
81015: LD_EXP 66
81019: PUSH
81020: LD_VAR 0 3
81024: ARRAY
81025: IN
81026: IFFALSE 81649
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
81028: LD_ADDR_EXP 66
81032: PUSH
81033: LD_EXP 66
81037: PPUSH
81038: LD_VAR 0 3
81042: PPUSH
81043: LD_EXP 66
81047: PUSH
81048: LD_VAR 0 3
81052: ARRAY
81053: PUSH
81054: LD_VAR 0 1
81058: DIFF
81059: PPUSH
81060: CALL_OW 1
81064: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
81065: LD_ADDR_EXP 59
81069: PUSH
81070: LD_EXP 59
81074: PPUSH
81075: LD_VAR 0 3
81079: PUSH
81080: LD_EXP 59
81084: PUSH
81085: LD_VAR 0 3
81089: ARRAY
81090: PUSH
81091: LD_INT 1
81093: PLUS
81094: PUSH
81095: EMPTY
81096: LIST
81097: LIST
81098: PPUSH
81099: LD_VAR 0 1
81103: PPUSH
81104: CALL 19307 0 3
81108: ST_TO_ADDR
// btype := GetBType ( building ) ;
81109: LD_ADDR_VAR 0 5
81113: PUSH
81114: LD_VAR 0 1
81118: PPUSH
81119: CALL_OW 266
81123: ST_TO_ADDR
// side := GetSide ( building ) ;
81124: LD_ADDR_VAR 0 8
81128: PUSH
81129: LD_VAR 0 1
81133: PPUSH
81134: CALL_OW 255
81138: ST_TO_ADDR
// if btype = b_lab then
81139: LD_VAR 0 5
81143: PUSH
81144: LD_INT 6
81146: EQUAL
81147: IFFALSE 81197
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
81149: LD_ADDR_EXP 92
81153: PUSH
81154: LD_EXP 92
81158: PPUSH
81159: LD_VAR 0 3
81163: PUSH
81164: LD_EXP 92
81168: PUSH
81169: LD_VAR 0 3
81173: ARRAY
81174: PUSH
81175: LD_INT 1
81177: PLUS
81178: PUSH
81179: EMPTY
81180: LIST
81181: LIST
81182: PPUSH
81183: LD_VAR 0 1
81187: PPUSH
81188: CALL 19307 0 3
81192: ST_TO_ADDR
// exit ;
81193: POP
81194: POP
81195: GO 81653
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
81197: LD_VAR 0 5
81201: PUSH
81202: LD_INT 0
81204: PUSH
81205: LD_INT 2
81207: PUSH
81208: LD_INT 4
81210: PUSH
81211: EMPTY
81212: LIST
81213: LIST
81214: LIST
81215: IN
81216: IFFALSE 81340
// begin if btype = b_armoury then
81218: LD_VAR 0 5
81222: PUSH
81223: LD_INT 4
81225: EQUAL
81226: IFFALSE 81236
// btype := b_barracks ;
81228: LD_ADDR_VAR 0 5
81232: PUSH
81233: LD_INT 5
81235: ST_TO_ADDR
// if btype = b_depot then
81236: LD_VAR 0 5
81240: PUSH
81241: LD_INT 0
81243: EQUAL
81244: IFFALSE 81254
// btype := b_warehouse ;
81246: LD_ADDR_VAR 0 5
81250: PUSH
81251: LD_INT 1
81253: ST_TO_ADDR
// if btype = b_workshop then
81254: LD_VAR 0 5
81258: PUSH
81259: LD_INT 2
81261: EQUAL
81262: IFFALSE 81272
// btype := b_factory ;
81264: LD_ADDR_VAR 0 5
81268: PUSH
81269: LD_INT 3
81271: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
81272: LD_VAR 0 5
81276: PPUSH
81277: LD_VAR 0 8
81281: PPUSH
81282: CALL_OW 323
81286: PUSH
81287: LD_INT 1
81289: EQUAL
81290: IFFALSE 81336
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
81292: LD_ADDR_EXP 91
81296: PUSH
81297: LD_EXP 91
81301: PPUSH
81302: LD_VAR 0 3
81306: PUSH
81307: LD_EXP 91
81311: PUSH
81312: LD_VAR 0 3
81316: ARRAY
81317: PUSH
81318: LD_INT 1
81320: PLUS
81321: PUSH
81322: EMPTY
81323: LIST
81324: LIST
81325: PPUSH
81326: LD_VAR 0 1
81330: PPUSH
81331: CALL 19307 0 3
81335: ST_TO_ADDR
// exit ;
81336: POP
81337: POP
81338: GO 81653
// end ; if btype in [ b_bunker , b_turret ] then
81340: LD_VAR 0 5
81344: PUSH
81345: LD_INT 32
81347: PUSH
81348: LD_INT 33
81350: PUSH
81351: EMPTY
81352: LIST
81353: LIST
81354: IN
81355: IFFALSE 81645
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
81357: LD_ADDR_EXP 67
81361: PUSH
81362: LD_EXP 67
81366: PPUSH
81367: LD_VAR 0 3
81371: PUSH
81372: LD_EXP 67
81376: PUSH
81377: LD_VAR 0 3
81381: ARRAY
81382: PUSH
81383: LD_INT 1
81385: PLUS
81386: PUSH
81387: EMPTY
81388: LIST
81389: LIST
81390: PPUSH
81391: LD_VAR 0 1
81395: PPUSH
81396: CALL 19307 0 3
81400: ST_TO_ADDR
// if btype = b_bunker then
81401: LD_VAR 0 5
81405: PUSH
81406: LD_INT 32
81408: EQUAL
81409: IFFALSE 81645
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81411: LD_ADDR_EXP 68
81415: PUSH
81416: LD_EXP 68
81420: PPUSH
81421: LD_VAR 0 3
81425: PUSH
81426: LD_EXP 68
81430: PUSH
81431: LD_VAR 0 3
81435: ARRAY
81436: PUSH
81437: LD_INT 1
81439: PLUS
81440: PUSH
81441: EMPTY
81442: LIST
81443: LIST
81444: PPUSH
81445: LD_VAR 0 1
81449: PPUSH
81450: CALL 19307 0 3
81454: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
81455: LD_ADDR_VAR 0 6
81459: PUSH
81460: LD_EXP 59
81464: PUSH
81465: LD_VAR 0 3
81469: ARRAY
81470: PPUSH
81471: LD_INT 25
81473: PUSH
81474: LD_INT 1
81476: PUSH
81477: EMPTY
81478: LIST
81479: LIST
81480: PUSH
81481: LD_INT 3
81483: PUSH
81484: LD_INT 54
81486: PUSH
81487: EMPTY
81488: LIST
81489: PUSH
81490: EMPTY
81491: LIST
81492: LIST
81493: PUSH
81494: EMPTY
81495: LIST
81496: LIST
81497: PPUSH
81498: CALL_OW 72
81502: ST_TO_ADDR
// if tmp then
81503: LD_VAR 0 6
81507: IFFALSE 81513
// exit ;
81509: POP
81510: POP
81511: GO 81653
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
81513: LD_ADDR_VAR 0 6
81517: PUSH
81518: LD_EXP 59
81522: PUSH
81523: LD_VAR 0 3
81527: ARRAY
81528: PPUSH
81529: LD_INT 2
81531: PUSH
81532: LD_INT 30
81534: PUSH
81535: LD_INT 4
81537: PUSH
81538: EMPTY
81539: LIST
81540: LIST
81541: PUSH
81542: LD_INT 30
81544: PUSH
81545: LD_INT 5
81547: PUSH
81548: EMPTY
81549: LIST
81550: LIST
81551: PUSH
81552: EMPTY
81553: LIST
81554: LIST
81555: LIST
81556: PPUSH
81557: CALL_OW 72
81561: ST_TO_ADDR
// if not tmp then
81562: LD_VAR 0 6
81566: NOT
81567: IFFALSE 81573
// exit ;
81569: POP
81570: POP
81571: GO 81653
// for j in tmp do
81573: LD_ADDR_VAR 0 4
81577: PUSH
81578: LD_VAR 0 6
81582: PUSH
81583: FOR_IN
81584: IFFALSE 81643
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
81586: LD_ADDR_VAR 0 7
81590: PUSH
81591: LD_VAR 0 4
81595: PPUSH
81596: CALL_OW 313
81600: PPUSH
81601: LD_INT 25
81603: PUSH
81604: LD_INT 1
81606: PUSH
81607: EMPTY
81608: LIST
81609: LIST
81610: PPUSH
81611: CALL_OW 72
81615: ST_TO_ADDR
// if units then
81616: LD_VAR 0 7
81620: IFFALSE 81641
// begin ComExitBuilding ( units [ 1 ] ) ;
81622: LD_VAR 0 7
81626: PUSH
81627: LD_INT 1
81629: ARRAY
81630: PPUSH
81631: CALL_OW 122
// exit ;
81635: POP
81636: POP
81637: POP
81638: POP
81639: GO 81653
// end ; end ;
81641: GO 81583
81643: POP
81644: POP
// end ; end ; exit ;
81645: POP
81646: POP
81647: GO 81653
// end ; end ;
81649: GO 81007
81651: POP
81652: POP
// end ;
81653: LD_VAR 0 2
81657: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
81658: LD_INT 0
81660: PPUSH
81661: PPUSH
81662: PPUSH
81663: PPUSH
81664: PPUSH
81665: PPUSH
81666: PPUSH
// if not mc_bases or not skirmish then
81667: LD_EXP 59
81671: NOT
81672: PUSH
81673: LD_EXP 57
81677: NOT
81678: OR
81679: IFFALSE 81683
// exit ;
81681: GO 81914
// btype := GetBType ( building ) ;
81683: LD_ADDR_VAR 0 6
81687: PUSH
81688: LD_VAR 0 1
81692: PPUSH
81693: CALL_OW 266
81697: ST_TO_ADDR
// x := GetX ( building ) ;
81698: LD_ADDR_VAR 0 7
81702: PUSH
81703: LD_VAR 0 1
81707: PPUSH
81708: CALL_OW 250
81712: ST_TO_ADDR
// y := GetY ( building ) ;
81713: LD_ADDR_VAR 0 8
81717: PUSH
81718: LD_VAR 0 1
81722: PPUSH
81723: CALL_OW 251
81727: ST_TO_ADDR
// d := GetDir ( building ) ;
81728: LD_ADDR_VAR 0 9
81732: PUSH
81733: LD_VAR 0 1
81737: PPUSH
81738: CALL_OW 254
81742: ST_TO_ADDR
// for i = 1 to mc_bases do
81743: LD_ADDR_VAR 0 4
81747: PUSH
81748: DOUBLE
81749: LD_INT 1
81751: DEC
81752: ST_TO_ADDR
81753: LD_EXP 59
81757: PUSH
81758: FOR_TO
81759: IFFALSE 81912
// begin if not mc_build_list [ i ] then
81761: LD_EXP 64
81765: PUSH
81766: LD_VAR 0 4
81770: ARRAY
81771: NOT
81772: IFFALSE 81776
// continue ;
81774: GO 81758
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
81776: LD_VAR 0 6
81780: PUSH
81781: LD_VAR 0 7
81785: PUSH
81786: LD_VAR 0 8
81790: PUSH
81791: LD_VAR 0 9
81795: PUSH
81796: EMPTY
81797: LIST
81798: LIST
81799: LIST
81800: LIST
81801: PPUSH
81802: LD_EXP 64
81806: PUSH
81807: LD_VAR 0 4
81811: ARRAY
81812: PUSH
81813: LD_INT 1
81815: ARRAY
81816: PPUSH
81817: CALL 25514 0 2
81821: IFFALSE 81910
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
81823: LD_ADDR_EXP 64
81827: PUSH
81828: LD_EXP 64
81832: PPUSH
81833: LD_VAR 0 4
81837: PPUSH
81838: LD_EXP 64
81842: PUSH
81843: LD_VAR 0 4
81847: ARRAY
81848: PPUSH
81849: LD_INT 1
81851: PPUSH
81852: CALL_OW 3
81856: PPUSH
81857: CALL_OW 1
81861: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81862: LD_ADDR_EXP 66
81866: PUSH
81867: LD_EXP 66
81871: PPUSH
81872: LD_VAR 0 4
81876: PUSH
81877: LD_EXP 66
81881: PUSH
81882: LD_VAR 0 4
81886: ARRAY
81887: PUSH
81888: LD_INT 1
81890: PLUS
81891: PUSH
81892: EMPTY
81893: LIST
81894: LIST
81895: PPUSH
81896: LD_VAR 0 1
81900: PPUSH
81901: CALL 19307 0 3
81905: ST_TO_ADDR
// exit ;
81906: POP
81907: POP
81908: GO 81914
// end ; end ;
81910: GO 81758
81912: POP
81913: POP
// end ;
81914: LD_VAR 0 3
81918: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81919: LD_INT 0
81921: PPUSH
81922: PPUSH
81923: PPUSH
// if not mc_bases or not skirmish then
81924: LD_EXP 59
81928: NOT
81929: PUSH
81930: LD_EXP 57
81934: NOT
81935: OR
81936: IFFALSE 81940
// exit ;
81938: GO 82130
// for i = 1 to mc_bases do
81940: LD_ADDR_VAR 0 4
81944: PUSH
81945: DOUBLE
81946: LD_INT 1
81948: DEC
81949: ST_TO_ADDR
81950: LD_EXP 59
81954: PUSH
81955: FOR_TO
81956: IFFALSE 82043
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81958: LD_VAR 0 1
81962: PUSH
81963: LD_EXP 67
81967: PUSH
81968: LD_VAR 0 4
81972: ARRAY
81973: IN
81974: PUSH
81975: LD_VAR 0 1
81979: PUSH
81980: LD_EXP 68
81984: PUSH
81985: LD_VAR 0 4
81989: ARRAY
81990: IN
81991: NOT
81992: AND
81993: IFFALSE 82041
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81995: LD_ADDR_EXP 68
81999: PUSH
82000: LD_EXP 68
82004: PPUSH
82005: LD_VAR 0 4
82009: PUSH
82010: LD_EXP 68
82014: PUSH
82015: LD_VAR 0 4
82019: ARRAY
82020: PUSH
82021: LD_INT 1
82023: PLUS
82024: PUSH
82025: EMPTY
82026: LIST
82027: LIST
82028: PPUSH
82029: LD_VAR 0 1
82033: PPUSH
82034: CALL 19307 0 3
82038: ST_TO_ADDR
// break ;
82039: GO 82043
// end ; end ;
82041: GO 81955
82043: POP
82044: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
82045: LD_VAR 0 1
82049: PPUSH
82050: CALL_OW 257
82054: PUSH
82055: LD_EXP 85
82059: IN
82060: PUSH
82061: LD_VAR 0 1
82065: PPUSH
82066: CALL_OW 266
82070: PUSH
82071: LD_INT 5
82073: EQUAL
82074: AND
82075: PUSH
82076: LD_VAR 0 2
82080: PPUSH
82081: CALL_OW 110
82085: PUSH
82086: LD_INT 18
82088: NONEQUAL
82089: AND
82090: IFFALSE 82130
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
82092: LD_VAR 0 2
82096: PPUSH
82097: CALL_OW 257
82101: PUSH
82102: LD_INT 5
82104: PUSH
82105: LD_INT 8
82107: PUSH
82108: LD_INT 9
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: LIST
82115: IN
82116: IFFALSE 82130
// SetClass ( unit , 1 ) ;
82118: LD_VAR 0 2
82122: PPUSH
82123: LD_INT 1
82125: PPUSH
82126: CALL_OW 336
// end ;
82130: LD_VAR 0 3
82134: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
82135: LD_INT 0
82137: PPUSH
82138: PPUSH
// if not mc_bases or not skirmish then
82139: LD_EXP 59
82143: NOT
82144: PUSH
82145: LD_EXP 57
82149: NOT
82150: OR
82151: IFFALSE 82155
// exit ;
82153: GO 82271
// if GetLives ( abandoned_vehicle ) > 250 then
82155: LD_VAR 0 2
82159: PPUSH
82160: CALL_OW 256
82164: PUSH
82165: LD_INT 250
82167: GREATER
82168: IFFALSE 82172
// exit ;
82170: GO 82271
// for i = 1 to mc_bases do
82172: LD_ADDR_VAR 0 6
82176: PUSH
82177: DOUBLE
82178: LD_INT 1
82180: DEC
82181: ST_TO_ADDR
82182: LD_EXP 59
82186: PUSH
82187: FOR_TO
82188: IFFALSE 82269
// begin if driver in mc_bases [ i ] then
82190: LD_VAR 0 1
82194: PUSH
82195: LD_EXP 59
82199: PUSH
82200: LD_VAR 0 6
82204: ARRAY
82205: IN
82206: IFFALSE 82267
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
82208: LD_VAR 0 1
82212: PPUSH
82213: LD_EXP 59
82217: PUSH
82218: LD_VAR 0 6
82222: ARRAY
82223: PPUSH
82224: LD_INT 2
82226: PUSH
82227: LD_INT 30
82229: PUSH
82230: LD_INT 0
82232: PUSH
82233: EMPTY
82234: LIST
82235: LIST
82236: PUSH
82237: LD_INT 30
82239: PUSH
82240: LD_INT 1
82242: PUSH
82243: EMPTY
82244: LIST
82245: LIST
82246: PUSH
82247: EMPTY
82248: LIST
82249: LIST
82250: LIST
82251: PPUSH
82252: CALL_OW 72
82256: PUSH
82257: LD_INT 1
82259: ARRAY
82260: PPUSH
82261: CALL 51550 0 2
// break ;
82265: GO 82269
// end ; end ;
82267: GO 82187
82269: POP
82270: POP
// end ; end_of_file
82271: LD_VAR 0 5
82275: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
82276: LD_INT 0
82278: PPUSH
// ar_miner := 81 ;
82279: LD_ADDR_EXP 110
82283: PUSH
82284: LD_INT 81
82286: ST_TO_ADDR
// ar_crane := 88 ;
82287: LD_ADDR_EXP 109
82291: PUSH
82292: LD_INT 88
82294: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
82295: LD_ADDR_EXP 104
82299: PUSH
82300: LD_INT 89
82302: ST_TO_ADDR
// us_hack := 99 ;
82303: LD_ADDR_EXP 105
82307: PUSH
82308: LD_INT 99
82310: ST_TO_ADDR
// us_artillery := 97 ;
82311: LD_ADDR_EXP 106
82315: PUSH
82316: LD_INT 97
82318: ST_TO_ADDR
// ar_bio_bomb := 91 ;
82319: LD_ADDR_EXP 107
82323: PUSH
82324: LD_INT 91
82326: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
82327: LD_ADDR_EXP 108
82331: PUSH
82332: LD_INT 92
82334: ST_TO_ADDR
// ru_radar := 98 ;
82335: LD_ADDR_EXP 103
82339: PUSH
82340: LD_INT 98
82342: ST_TO_ADDR
// tech_Artillery := 80 ;
82343: LD_ADDR_EXP 111
82347: PUSH
82348: LD_INT 80
82350: ST_TO_ADDR
// tech_RadMat := 81 ;
82351: LD_ADDR_EXP 112
82355: PUSH
82356: LD_INT 81
82358: ST_TO_ADDR
// tech_BasicTools := 82 ;
82359: LD_ADDR_EXP 113
82363: PUSH
82364: LD_INT 82
82366: ST_TO_ADDR
// tech_Cargo := 83 ;
82367: LD_ADDR_EXP 114
82371: PUSH
82372: LD_INT 83
82374: ST_TO_ADDR
// tech_Track := 84 ;
82375: LD_ADDR_EXP 115
82379: PUSH
82380: LD_INT 84
82382: ST_TO_ADDR
// tech_Crane := 85 ;
82383: LD_ADDR_EXP 116
82387: PUSH
82388: LD_INT 85
82390: ST_TO_ADDR
// tech_Bulldozer := 86 ;
82391: LD_ADDR_EXP 117
82395: PUSH
82396: LD_INT 86
82398: ST_TO_ADDR
// tech_Hovercraft := 87 ;
82399: LD_ADDR_EXP 118
82403: PUSH
82404: LD_INT 87
82406: ST_TO_ADDR
// class_mastodont := 31 ;
82407: LD_ADDR_EXP 119
82411: PUSH
82412: LD_INT 31
82414: ST_TO_ADDR
// class_horse := 21 ;
82415: LD_ADDR_EXP 120
82419: PUSH
82420: LD_INT 21
82422: ST_TO_ADDR
// end ;
82423: LD_VAR 0 1
82427: RET
// every 1 do
82428: GO 82430
82430: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
82431: CALL 82276 0 0
82435: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
82436: LD_INT 0
82438: PPUSH
// if p2 = 100 then
82439: LD_VAR 0 2
82443: PUSH
82444: LD_INT 100
82446: EQUAL
82447: IFFALSE 83396
// begin if not StreamModeActive then
82449: LD_EXP 121
82453: NOT
82454: IFFALSE 82464
// StreamModeActive := true ;
82456: LD_ADDR_EXP 121
82460: PUSH
82461: LD_INT 1
82463: ST_TO_ADDR
// if p3 = 0 then
82464: LD_VAR 0 3
82468: PUSH
82469: LD_INT 0
82471: EQUAL
82472: IFFALSE 82478
// InitStreamMode ;
82474: CALL 83556 0 0
// if p3 = 1 then
82478: LD_VAR 0 3
82482: PUSH
82483: LD_INT 1
82485: EQUAL
82486: IFFALSE 82496
// sRocket := true ;
82488: LD_ADDR_EXP 126
82492: PUSH
82493: LD_INT 1
82495: ST_TO_ADDR
// if p3 = 2 then
82496: LD_VAR 0 3
82500: PUSH
82501: LD_INT 2
82503: EQUAL
82504: IFFALSE 82514
// sSpeed := true ;
82506: LD_ADDR_EXP 125
82510: PUSH
82511: LD_INT 1
82513: ST_TO_ADDR
// if p3 = 3 then
82514: LD_VAR 0 3
82518: PUSH
82519: LD_INT 3
82521: EQUAL
82522: IFFALSE 82532
// sEngine := true ;
82524: LD_ADDR_EXP 127
82528: PUSH
82529: LD_INT 1
82531: ST_TO_ADDR
// if p3 = 4 then
82532: LD_VAR 0 3
82536: PUSH
82537: LD_INT 4
82539: EQUAL
82540: IFFALSE 82550
// sSpec := true ;
82542: LD_ADDR_EXP 124
82546: PUSH
82547: LD_INT 1
82549: ST_TO_ADDR
// if p3 = 5 then
82550: LD_VAR 0 3
82554: PUSH
82555: LD_INT 5
82557: EQUAL
82558: IFFALSE 82568
// sLevel := true ;
82560: LD_ADDR_EXP 128
82564: PUSH
82565: LD_INT 1
82567: ST_TO_ADDR
// if p3 = 6 then
82568: LD_VAR 0 3
82572: PUSH
82573: LD_INT 6
82575: EQUAL
82576: IFFALSE 82586
// sArmoury := true ;
82578: LD_ADDR_EXP 129
82582: PUSH
82583: LD_INT 1
82585: ST_TO_ADDR
// if p3 = 7 then
82586: LD_VAR 0 3
82590: PUSH
82591: LD_INT 7
82593: EQUAL
82594: IFFALSE 82604
// sRadar := true ;
82596: LD_ADDR_EXP 130
82600: PUSH
82601: LD_INT 1
82603: ST_TO_ADDR
// if p3 = 8 then
82604: LD_VAR 0 3
82608: PUSH
82609: LD_INT 8
82611: EQUAL
82612: IFFALSE 82622
// sBunker := true ;
82614: LD_ADDR_EXP 131
82618: PUSH
82619: LD_INT 1
82621: ST_TO_ADDR
// if p3 = 9 then
82622: LD_VAR 0 3
82626: PUSH
82627: LD_INT 9
82629: EQUAL
82630: IFFALSE 82640
// sHack := true ;
82632: LD_ADDR_EXP 132
82636: PUSH
82637: LD_INT 1
82639: ST_TO_ADDR
// if p3 = 10 then
82640: LD_VAR 0 3
82644: PUSH
82645: LD_INT 10
82647: EQUAL
82648: IFFALSE 82658
// sFire := true ;
82650: LD_ADDR_EXP 133
82654: PUSH
82655: LD_INT 1
82657: ST_TO_ADDR
// if p3 = 11 then
82658: LD_VAR 0 3
82662: PUSH
82663: LD_INT 11
82665: EQUAL
82666: IFFALSE 82676
// sRefresh := true ;
82668: LD_ADDR_EXP 134
82672: PUSH
82673: LD_INT 1
82675: ST_TO_ADDR
// if p3 = 12 then
82676: LD_VAR 0 3
82680: PUSH
82681: LD_INT 12
82683: EQUAL
82684: IFFALSE 82694
// sExp := true ;
82686: LD_ADDR_EXP 135
82690: PUSH
82691: LD_INT 1
82693: ST_TO_ADDR
// if p3 = 13 then
82694: LD_VAR 0 3
82698: PUSH
82699: LD_INT 13
82701: EQUAL
82702: IFFALSE 82712
// sDepot := true ;
82704: LD_ADDR_EXP 136
82708: PUSH
82709: LD_INT 1
82711: ST_TO_ADDR
// if p3 = 14 then
82712: LD_VAR 0 3
82716: PUSH
82717: LD_INT 14
82719: EQUAL
82720: IFFALSE 82730
// sFlag := true ;
82722: LD_ADDR_EXP 137
82726: PUSH
82727: LD_INT 1
82729: ST_TO_ADDR
// if p3 = 15 then
82730: LD_VAR 0 3
82734: PUSH
82735: LD_INT 15
82737: EQUAL
82738: IFFALSE 82748
// sKamikadze := true ;
82740: LD_ADDR_EXP 145
82744: PUSH
82745: LD_INT 1
82747: ST_TO_ADDR
// if p3 = 16 then
82748: LD_VAR 0 3
82752: PUSH
82753: LD_INT 16
82755: EQUAL
82756: IFFALSE 82766
// sTroll := true ;
82758: LD_ADDR_EXP 146
82762: PUSH
82763: LD_INT 1
82765: ST_TO_ADDR
// if p3 = 17 then
82766: LD_VAR 0 3
82770: PUSH
82771: LD_INT 17
82773: EQUAL
82774: IFFALSE 82784
// sSlow := true ;
82776: LD_ADDR_EXP 147
82780: PUSH
82781: LD_INT 1
82783: ST_TO_ADDR
// if p3 = 18 then
82784: LD_VAR 0 3
82788: PUSH
82789: LD_INT 18
82791: EQUAL
82792: IFFALSE 82802
// sLack := true ;
82794: LD_ADDR_EXP 148
82798: PUSH
82799: LD_INT 1
82801: ST_TO_ADDR
// if p3 = 19 then
82802: LD_VAR 0 3
82806: PUSH
82807: LD_INT 19
82809: EQUAL
82810: IFFALSE 82820
// sTank := true ;
82812: LD_ADDR_EXP 150
82816: PUSH
82817: LD_INT 1
82819: ST_TO_ADDR
// if p3 = 20 then
82820: LD_VAR 0 3
82824: PUSH
82825: LD_INT 20
82827: EQUAL
82828: IFFALSE 82838
// sRemote := true ;
82830: LD_ADDR_EXP 151
82834: PUSH
82835: LD_INT 1
82837: ST_TO_ADDR
// if p3 = 21 then
82838: LD_VAR 0 3
82842: PUSH
82843: LD_INT 21
82845: EQUAL
82846: IFFALSE 82856
// sPowell := true ;
82848: LD_ADDR_EXP 152
82852: PUSH
82853: LD_INT 1
82855: ST_TO_ADDR
// if p3 = 22 then
82856: LD_VAR 0 3
82860: PUSH
82861: LD_INT 22
82863: EQUAL
82864: IFFALSE 82874
// sTeleport := true ;
82866: LD_ADDR_EXP 155
82870: PUSH
82871: LD_INT 1
82873: ST_TO_ADDR
// if p3 = 23 then
82874: LD_VAR 0 3
82878: PUSH
82879: LD_INT 23
82881: EQUAL
82882: IFFALSE 82892
// sOilTower := true ;
82884: LD_ADDR_EXP 157
82888: PUSH
82889: LD_INT 1
82891: ST_TO_ADDR
// if p3 = 24 then
82892: LD_VAR 0 3
82896: PUSH
82897: LD_INT 24
82899: EQUAL
82900: IFFALSE 82910
// sShovel := true ;
82902: LD_ADDR_EXP 158
82906: PUSH
82907: LD_INT 1
82909: ST_TO_ADDR
// if p3 = 25 then
82910: LD_VAR 0 3
82914: PUSH
82915: LD_INT 25
82917: EQUAL
82918: IFFALSE 82928
// sSheik := true ;
82920: LD_ADDR_EXP 159
82924: PUSH
82925: LD_INT 1
82927: ST_TO_ADDR
// if p3 = 26 then
82928: LD_VAR 0 3
82932: PUSH
82933: LD_INT 26
82935: EQUAL
82936: IFFALSE 82946
// sEarthquake := true ;
82938: LD_ADDR_EXP 161
82942: PUSH
82943: LD_INT 1
82945: ST_TO_ADDR
// if p3 = 27 then
82946: LD_VAR 0 3
82950: PUSH
82951: LD_INT 27
82953: EQUAL
82954: IFFALSE 82964
// sAI := true ;
82956: LD_ADDR_EXP 162
82960: PUSH
82961: LD_INT 1
82963: ST_TO_ADDR
// if p3 = 28 then
82964: LD_VAR 0 3
82968: PUSH
82969: LD_INT 28
82971: EQUAL
82972: IFFALSE 82982
// sCargo := true ;
82974: LD_ADDR_EXP 165
82978: PUSH
82979: LD_INT 1
82981: ST_TO_ADDR
// if p3 = 29 then
82982: LD_VAR 0 3
82986: PUSH
82987: LD_INT 29
82989: EQUAL
82990: IFFALSE 83000
// sDLaser := true ;
82992: LD_ADDR_EXP 166
82996: PUSH
82997: LD_INT 1
82999: ST_TO_ADDR
// if p3 = 30 then
83000: LD_VAR 0 3
83004: PUSH
83005: LD_INT 30
83007: EQUAL
83008: IFFALSE 83018
// sExchange := true ;
83010: LD_ADDR_EXP 167
83014: PUSH
83015: LD_INT 1
83017: ST_TO_ADDR
// if p3 = 31 then
83018: LD_VAR 0 3
83022: PUSH
83023: LD_INT 31
83025: EQUAL
83026: IFFALSE 83036
// sFac := true ;
83028: LD_ADDR_EXP 168
83032: PUSH
83033: LD_INT 1
83035: ST_TO_ADDR
// if p3 = 32 then
83036: LD_VAR 0 3
83040: PUSH
83041: LD_INT 32
83043: EQUAL
83044: IFFALSE 83054
// sPower := true ;
83046: LD_ADDR_EXP 169
83050: PUSH
83051: LD_INT 1
83053: ST_TO_ADDR
// if p3 = 33 then
83054: LD_VAR 0 3
83058: PUSH
83059: LD_INT 33
83061: EQUAL
83062: IFFALSE 83072
// sRandom := true ;
83064: LD_ADDR_EXP 170
83068: PUSH
83069: LD_INT 1
83071: ST_TO_ADDR
// if p3 = 34 then
83072: LD_VAR 0 3
83076: PUSH
83077: LD_INT 34
83079: EQUAL
83080: IFFALSE 83090
// sShield := true ;
83082: LD_ADDR_EXP 171
83086: PUSH
83087: LD_INT 1
83089: ST_TO_ADDR
// if p3 = 35 then
83090: LD_VAR 0 3
83094: PUSH
83095: LD_INT 35
83097: EQUAL
83098: IFFALSE 83108
// sTime := true ;
83100: LD_ADDR_EXP 172
83104: PUSH
83105: LD_INT 1
83107: ST_TO_ADDR
// if p3 = 36 then
83108: LD_VAR 0 3
83112: PUSH
83113: LD_INT 36
83115: EQUAL
83116: IFFALSE 83126
// sTools := true ;
83118: LD_ADDR_EXP 173
83122: PUSH
83123: LD_INT 1
83125: ST_TO_ADDR
// if p3 = 101 then
83126: LD_VAR 0 3
83130: PUSH
83131: LD_INT 101
83133: EQUAL
83134: IFFALSE 83144
// sSold := true ;
83136: LD_ADDR_EXP 138
83140: PUSH
83141: LD_INT 1
83143: ST_TO_ADDR
// if p3 = 102 then
83144: LD_VAR 0 3
83148: PUSH
83149: LD_INT 102
83151: EQUAL
83152: IFFALSE 83162
// sDiff := true ;
83154: LD_ADDR_EXP 139
83158: PUSH
83159: LD_INT 1
83161: ST_TO_ADDR
// if p3 = 103 then
83162: LD_VAR 0 3
83166: PUSH
83167: LD_INT 103
83169: EQUAL
83170: IFFALSE 83180
// sFog := true ;
83172: LD_ADDR_EXP 142
83176: PUSH
83177: LD_INT 1
83179: ST_TO_ADDR
// if p3 = 104 then
83180: LD_VAR 0 3
83184: PUSH
83185: LD_INT 104
83187: EQUAL
83188: IFFALSE 83198
// sReset := true ;
83190: LD_ADDR_EXP 143
83194: PUSH
83195: LD_INT 1
83197: ST_TO_ADDR
// if p3 = 105 then
83198: LD_VAR 0 3
83202: PUSH
83203: LD_INT 105
83205: EQUAL
83206: IFFALSE 83216
// sSun := true ;
83208: LD_ADDR_EXP 144
83212: PUSH
83213: LD_INT 1
83215: ST_TO_ADDR
// if p3 = 106 then
83216: LD_VAR 0 3
83220: PUSH
83221: LD_INT 106
83223: EQUAL
83224: IFFALSE 83234
// sTiger := true ;
83226: LD_ADDR_EXP 140
83230: PUSH
83231: LD_INT 1
83233: ST_TO_ADDR
// if p3 = 107 then
83234: LD_VAR 0 3
83238: PUSH
83239: LD_INT 107
83241: EQUAL
83242: IFFALSE 83252
// sBomb := true ;
83244: LD_ADDR_EXP 141
83248: PUSH
83249: LD_INT 1
83251: ST_TO_ADDR
// if p3 = 108 then
83252: LD_VAR 0 3
83256: PUSH
83257: LD_INT 108
83259: EQUAL
83260: IFFALSE 83270
// sWound := true ;
83262: LD_ADDR_EXP 149
83266: PUSH
83267: LD_INT 1
83269: ST_TO_ADDR
// if p3 = 109 then
83270: LD_VAR 0 3
83274: PUSH
83275: LD_INT 109
83277: EQUAL
83278: IFFALSE 83288
// sBetray := true ;
83280: LD_ADDR_EXP 153
83284: PUSH
83285: LD_INT 1
83287: ST_TO_ADDR
// if p3 = 110 then
83288: LD_VAR 0 3
83292: PUSH
83293: LD_INT 110
83295: EQUAL
83296: IFFALSE 83306
// sContamin := true ;
83298: LD_ADDR_EXP 154
83302: PUSH
83303: LD_INT 1
83305: ST_TO_ADDR
// if p3 = 111 then
83306: LD_VAR 0 3
83310: PUSH
83311: LD_INT 111
83313: EQUAL
83314: IFFALSE 83324
// sOil := true ;
83316: LD_ADDR_EXP 156
83320: PUSH
83321: LD_INT 1
83323: ST_TO_ADDR
// if p3 = 112 then
83324: LD_VAR 0 3
83328: PUSH
83329: LD_INT 112
83331: EQUAL
83332: IFFALSE 83342
// sStu := true ;
83334: LD_ADDR_EXP 160
83338: PUSH
83339: LD_INT 1
83341: ST_TO_ADDR
// if p3 = 113 then
83342: LD_VAR 0 3
83346: PUSH
83347: LD_INT 113
83349: EQUAL
83350: IFFALSE 83360
// sBazooka := true ;
83352: LD_ADDR_EXP 163
83356: PUSH
83357: LD_INT 1
83359: ST_TO_ADDR
// if p3 = 114 then
83360: LD_VAR 0 3
83364: PUSH
83365: LD_INT 114
83367: EQUAL
83368: IFFALSE 83378
// sMortar := true ;
83370: LD_ADDR_EXP 164
83374: PUSH
83375: LD_INT 1
83377: ST_TO_ADDR
// if p3 = 115 then
83378: LD_VAR 0 3
83382: PUSH
83383: LD_INT 115
83385: EQUAL
83386: IFFALSE 83396
// sRanger := true ;
83388: LD_ADDR_EXP 174
83392: PUSH
83393: LD_INT 1
83395: ST_TO_ADDR
// end ; if p2 = 101 then
83396: LD_VAR 0 2
83400: PUSH
83401: LD_INT 101
83403: EQUAL
83404: IFFALSE 83532
// begin case p3 of 1 :
83406: LD_VAR 0 3
83410: PUSH
83411: LD_INT 1
83413: DOUBLE
83414: EQUAL
83415: IFTRUE 83419
83417: GO 83426
83419: POP
// hHackUnlimitedResources ; 2 :
83420: CALL 94569 0 0
83424: GO 83532
83426: LD_INT 2
83428: DOUBLE
83429: EQUAL
83430: IFTRUE 83434
83432: GO 83441
83434: POP
// hHackSetLevel10 ; 3 :
83435: CALL 94702 0 0
83439: GO 83532
83441: LD_INT 3
83443: DOUBLE
83444: EQUAL
83445: IFTRUE 83449
83447: GO 83456
83449: POP
// hHackSetLevel10YourUnits ; 4 :
83450: CALL 94787 0 0
83454: GO 83532
83456: LD_INT 4
83458: DOUBLE
83459: EQUAL
83460: IFTRUE 83464
83462: GO 83471
83464: POP
// hHackInvincible ; 5 :
83465: CALL 95235 0 0
83469: GO 83532
83471: LD_INT 5
83473: DOUBLE
83474: EQUAL
83475: IFTRUE 83479
83477: GO 83486
83479: POP
// hHackInvisible ; 6 :
83480: CALL 95346 0 0
83484: GO 83532
83486: LD_INT 6
83488: DOUBLE
83489: EQUAL
83490: IFTRUE 83494
83492: GO 83501
83494: POP
// hHackChangeYourSide ; 7 :
83495: CALL 95403 0 0
83499: GO 83532
83501: LD_INT 7
83503: DOUBLE
83504: EQUAL
83505: IFTRUE 83509
83507: GO 83516
83509: POP
// hHackChangeUnitSide ; 8 :
83510: CALL 95445 0 0
83514: GO 83532
83516: LD_INT 8
83518: DOUBLE
83519: EQUAL
83520: IFTRUE 83524
83522: GO 83531
83524: POP
// hHackFog ; end ;
83525: CALL 95546 0 0
83529: GO 83532
83531: POP
// end ; end ;
83532: LD_VAR 0 7
83536: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
83537: GO 83539
83539: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
83540: LD_STRING initStreamRollete();
83542: PPUSH
83543: CALL_OW 559
// InitStreamMode ;
83547: CALL 83556 0 0
// DefineStreamItems ( ) ;
83551: CALL 83996 0 0
// end ;
83555: END
// function InitStreamMode ; begin
83556: LD_INT 0
83558: PPUSH
// streamModeActive := false ;
83559: LD_ADDR_EXP 121
83563: PUSH
83564: LD_INT 0
83566: ST_TO_ADDR
// normalCounter := 36 ;
83567: LD_ADDR_EXP 122
83571: PUSH
83572: LD_INT 36
83574: ST_TO_ADDR
// hardcoreCounter := 16 ;
83575: LD_ADDR_EXP 123
83579: PUSH
83580: LD_INT 16
83582: ST_TO_ADDR
// sRocket := false ;
83583: LD_ADDR_EXP 126
83587: PUSH
83588: LD_INT 0
83590: ST_TO_ADDR
// sSpeed := false ;
83591: LD_ADDR_EXP 125
83595: PUSH
83596: LD_INT 0
83598: ST_TO_ADDR
// sEngine := false ;
83599: LD_ADDR_EXP 127
83603: PUSH
83604: LD_INT 0
83606: ST_TO_ADDR
// sSpec := false ;
83607: LD_ADDR_EXP 124
83611: PUSH
83612: LD_INT 0
83614: ST_TO_ADDR
// sLevel := false ;
83615: LD_ADDR_EXP 128
83619: PUSH
83620: LD_INT 0
83622: ST_TO_ADDR
// sArmoury := false ;
83623: LD_ADDR_EXP 129
83627: PUSH
83628: LD_INT 0
83630: ST_TO_ADDR
// sRadar := false ;
83631: LD_ADDR_EXP 130
83635: PUSH
83636: LD_INT 0
83638: ST_TO_ADDR
// sBunker := false ;
83639: LD_ADDR_EXP 131
83643: PUSH
83644: LD_INT 0
83646: ST_TO_ADDR
// sHack := false ;
83647: LD_ADDR_EXP 132
83651: PUSH
83652: LD_INT 0
83654: ST_TO_ADDR
// sFire := false ;
83655: LD_ADDR_EXP 133
83659: PUSH
83660: LD_INT 0
83662: ST_TO_ADDR
// sRefresh := false ;
83663: LD_ADDR_EXP 134
83667: PUSH
83668: LD_INT 0
83670: ST_TO_ADDR
// sExp := false ;
83671: LD_ADDR_EXP 135
83675: PUSH
83676: LD_INT 0
83678: ST_TO_ADDR
// sDepot := false ;
83679: LD_ADDR_EXP 136
83683: PUSH
83684: LD_INT 0
83686: ST_TO_ADDR
// sFlag := false ;
83687: LD_ADDR_EXP 137
83691: PUSH
83692: LD_INT 0
83694: ST_TO_ADDR
// sKamikadze := false ;
83695: LD_ADDR_EXP 145
83699: PUSH
83700: LD_INT 0
83702: ST_TO_ADDR
// sTroll := false ;
83703: LD_ADDR_EXP 146
83707: PUSH
83708: LD_INT 0
83710: ST_TO_ADDR
// sSlow := false ;
83711: LD_ADDR_EXP 147
83715: PUSH
83716: LD_INT 0
83718: ST_TO_ADDR
// sLack := false ;
83719: LD_ADDR_EXP 148
83723: PUSH
83724: LD_INT 0
83726: ST_TO_ADDR
// sTank := false ;
83727: LD_ADDR_EXP 150
83731: PUSH
83732: LD_INT 0
83734: ST_TO_ADDR
// sRemote := false ;
83735: LD_ADDR_EXP 151
83739: PUSH
83740: LD_INT 0
83742: ST_TO_ADDR
// sPowell := false ;
83743: LD_ADDR_EXP 152
83747: PUSH
83748: LD_INT 0
83750: ST_TO_ADDR
// sTeleport := false ;
83751: LD_ADDR_EXP 155
83755: PUSH
83756: LD_INT 0
83758: ST_TO_ADDR
// sOilTower := false ;
83759: LD_ADDR_EXP 157
83763: PUSH
83764: LD_INT 0
83766: ST_TO_ADDR
// sShovel := false ;
83767: LD_ADDR_EXP 158
83771: PUSH
83772: LD_INT 0
83774: ST_TO_ADDR
// sSheik := false ;
83775: LD_ADDR_EXP 159
83779: PUSH
83780: LD_INT 0
83782: ST_TO_ADDR
// sEarthquake := false ;
83783: LD_ADDR_EXP 161
83787: PUSH
83788: LD_INT 0
83790: ST_TO_ADDR
// sAI := false ;
83791: LD_ADDR_EXP 162
83795: PUSH
83796: LD_INT 0
83798: ST_TO_ADDR
// sCargo := false ;
83799: LD_ADDR_EXP 165
83803: PUSH
83804: LD_INT 0
83806: ST_TO_ADDR
// sDLaser := false ;
83807: LD_ADDR_EXP 166
83811: PUSH
83812: LD_INT 0
83814: ST_TO_ADDR
// sExchange := false ;
83815: LD_ADDR_EXP 167
83819: PUSH
83820: LD_INT 0
83822: ST_TO_ADDR
// sFac := false ;
83823: LD_ADDR_EXP 168
83827: PUSH
83828: LD_INT 0
83830: ST_TO_ADDR
// sPower := false ;
83831: LD_ADDR_EXP 169
83835: PUSH
83836: LD_INT 0
83838: ST_TO_ADDR
// sRandom := false ;
83839: LD_ADDR_EXP 170
83843: PUSH
83844: LD_INT 0
83846: ST_TO_ADDR
// sShield := false ;
83847: LD_ADDR_EXP 171
83851: PUSH
83852: LD_INT 0
83854: ST_TO_ADDR
// sTime := false ;
83855: LD_ADDR_EXP 172
83859: PUSH
83860: LD_INT 0
83862: ST_TO_ADDR
// sTools := false ;
83863: LD_ADDR_EXP 173
83867: PUSH
83868: LD_INT 0
83870: ST_TO_ADDR
// sSold := false ;
83871: LD_ADDR_EXP 138
83875: PUSH
83876: LD_INT 0
83878: ST_TO_ADDR
// sDiff := false ;
83879: LD_ADDR_EXP 139
83883: PUSH
83884: LD_INT 0
83886: ST_TO_ADDR
// sFog := false ;
83887: LD_ADDR_EXP 142
83891: PUSH
83892: LD_INT 0
83894: ST_TO_ADDR
// sReset := false ;
83895: LD_ADDR_EXP 143
83899: PUSH
83900: LD_INT 0
83902: ST_TO_ADDR
// sSun := false ;
83903: LD_ADDR_EXP 144
83907: PUSH
83908: LD_INT 0
83910: ST_TO_ADDR
// sTiger := false ;
83911: LD_ADDR_EXP 140
83915: PUSH
83916: LD_INT 0
83918: ST_TO_ADDR
// sBomb := false ;
83919: LD_ADDR_EXP 141
83923: PUSH
83924: LD_INT 0
83926: ST_TO_ADDR
// sWound := false ;
83927: LD_ADDR_EXP 149
83931: PUSH
83932: LD_INT 0
83934: ST_TO_ADDR
// sBetray := false ;
83935: LD_ADDR_EXP 153
83939: PUSH
83940: LD_INT 0
83942: ST_TO_ADDR
// sContamin := false ;
83943: LD_ADDR_EXP 154
83947: PUSH
83948: LD_INT 0
83950: ST_TO_ADDR
// sOil := false ;
83951: LD_ADDR_EXP 156
83955: PUSH
83956: LD_INT 0
83958: ST_TO_ADDR
// sStu := false ;
83959: LD_ADDR_EXP 160
83963: PUSH
83964: LD_INT 0
83966: ST_TO_ADDR
// sBazooka := false ;
83967: LD_ADDR_EXP 163
83971: PUSH
83972: LD_INT 0
83974: ST_TO_ADDR
// sMortar := false ;
83975: LD_ADDR_EXP 164
83979: PUSH
83980: LD_INT 0
83982: ST_TO_ADDR
// sRanger := false ;
83983: LD_ADDR_EXP 174
83987: PUSH
83988: LD_INT 0
83990: ST_TO_ADDR
// end ;
83991: LD_VAR 0 1
83995: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
83996: LD_INT 0
83998: PPUSH
83999: PPUSH
84000: PPUSH
84001: PPUSH
84002: PPUSH
// result := [ ] ;
84003: LD_ADDR_VAR 0 1
84007: PUSH
84008: EMPTY
84009: ST_TO_ADDR
// if campaign_id = 1 then
84010: LD_OWVAR 69
84014: PUSH
84015: LD_INT 1
84017: EQUAL
84018: IFFALSE 86956
// begin case mission_number of 1 :
84020: LD_OWVAR 70
84024: PUSH
84025: LD_INT 1
84027: DOUBLE
84028: EQUAL
84029: IFTRUE 84033
84031: GO 84097
84033: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
84034: LD_ADDR_VAR 0 1
84038: PUSH
84039: LD_INT 2
84041: PUSH
84042: LD_INT 4
84044: PUSH
84045: LD_INT 11
84047: PUSH
84048: LD_INT 12
84050: PUSH
84051: LD_INT 15
84053: PUSH
84054: LD_INT 16
84056: PUSH
84057: LD_INT 22
84059: PUSH
84060: LD_INT 23
84062: PUSH
84063: LD_INT 26
84065: PUSH
84066: EMPTY
84067: LIST
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: PUSH
84077: LD_INT 101
84079: PUSH
84080: LD_INT 102
84082: PUSH
84083: LD_INT 106
84085: PUSH
84086: EMPTY
84087: LIST
84088: LIST
84089: LIST
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: ST_TO_ADDR
84095: GO 86954
84097: LD_INT 2
84099: DOUBLE
84100: EQUAL
84101: IFTRUE 84105
84103: GO 84177
84105: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
84106: LD_ADDR_VAR 0 1
84110: PUSH
84111: LD_INT 2
84113: PUSH
84114: LD_INT 4
84116: PUSH
84117: LD_INT 11
84119: PUSH
84120: LD_INT 12
84122: PUSH
84123: LD_INT 15
84125: PUSH
84126: LD_INT 16
84128: PUSH
84129: LD_INT 22
84131: PUSH
84132: LD_INT 23
84134: PUSH
84135: LD_INT 26
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: PUSH
84149: LD_INT 101
84151: PUSH
84152: LD_INT 102
84154: PUSH
84155: LD_INT 105
84157: PUSH
84158: LD_INT 106
84160: PUSH
84161: LD_INT 108
84163: PUSH
84164: EMPTY
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: PUSH
84171: EMPTY
84172: LIST
84173: LIST
84174: ST_TO_ADDR
84175: GO 86954
84177: LD_INT 3
84179: DOUBLE
84180: EQUAL
84181: IFTRUE 84185
84183: GO 84261
84185: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
84186: LD_ADDR_VAR 0 1
84190: PUSH
84191: LD_INT 2
84193: PUSH
84194: LD_INT 4
84196: PUSH
84197: LD_INT 5
84199: PUSH
84200: LD_INT 11
84202: PUSH
84203: LD_INT 12
84205: PUSH
84206: LD_INT 15
84208: PUSH
84209: LD_INT 16
84211: PUSH
84212: LD_INT 22
84214: PUSH
84215: LD_INT 26
84217: PUSH
84218: LD_INT 36
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: LIST
84229: LIST
84230: LIST
84231: LIST
84232: PUSH
84233: LD_INT 101
84235: PUSH
84236: LD_INT 102
84238: PUSH
84239: LD_INT 105
84241: PUSH
84242: LD_INT 106
84244: PUSH
84245: LD_INT 108
84247: PUSH
84248: EMPTY
84249: LIST
84250: LIST
84251: LIST
84252: LIST
84253: LIST
84254: PUSH
84255: EMPTY
84256: LIST
84257: LIST
84258: ST_TO_ADDR
84259: GO 86954
84261: LD_INT 4
84263: DOUBLE
84264: EQUAL
84265: IFTRUE 84269
84267: GO 84353
84269: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
84270: LD_ADDR_VAR 0 1
84274: PUSH
84275: LD_INT 2
84277: PUSH
84278: LD_INT 4
84280: PUSH
84281: LD_INT 5
84283: PUSH
84284: LD_INT 8
84286: PUSH
84287: LD_INT 11
84289: PUSH
84290: LD_INT 12
84292: PUSH
84293: LD_INT 15
84295: PUSH
84296: LD_INT 16
84298: PUSH
84299: LD_INT 22
84301: PUSH
84302: LD_INT 23
84304: PUSH
84305: LD_INT 26
84307: PUSH
84308: LD_INT 36
84310: PUSH
84311: EMPTY
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: LIST
84320: LIST
84321: LIST
84322: LIST
84323: LIST
84324: PUSH
84325: LD_INT 101
84327: PUSH
84328: LD_INT 102
84330: PUSH
84331: LD_INT 105
84333: PUSH
84334: LD_INT 106
84336: PUSH
84337: LD_INT 108
84339: PUSH
84340: EMPTY
84341: LIST
84342: LIST
84343: LIST
84344: LIST
84345: LIST
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: ST_TO_ADDR
84351: GO 86954
84353: LD_INT 5
84355: DOUBLE
84356: EQUAL
84357: IFTRUE 84361
84359: GO 84461
84361: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
84362: LD_ADDR_VAR 0 1
84366: PUSH
84367: LD_INT 2
84369: PUSH
84370: LD_INT 4
84372: PUSH
84373: LD_INT 5
84375: PUSH
84376: LD_INT 6
84378: PUSH
84379: LD_INT 8
84381: PUSH
84382: LD_INT 11
84384: PUSH
84385: LD_INT 12
84387: PUSH
84388: LD_INT 15
84390: PUSH
84391: LD_INT 16
84393: PUSH
84394: LD_INT 22
84396: PUSH
84397: LD_INT 23
84399: PUSH
84400: LD_INT 25
84402: PUSH
84403: LD_INT 26
84405: PUSH
84406: LD_INT 36
84408: PUSH
84409: EMPTY
84410: LIST
84411: LIST
84412: LIST
84413: LIST
84414: LIST
84415: LIST
84416: LIST
84417: LIST
84418: LIST
84419: LIST
84420: LIST
84421: LIST
84422: LIST
84423: LIST
84424: PUSH
84425: LD_INT 101
84427: PUSH
84428: LD_INT 102
84430: PUSH
84431: LD_INT 105
84433: PUSH
84434: LD_INT 106
84436: PUSH
84437: LD_INT 108
84439: PUSH
84440: LD_INT 109
84442: PUSH
84443: LD_INT 112
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: PUSH
84455: EMPTY
84456: LIST
84457: LIST
84458: ST_TO_ADDR
84459: GO 86954
84461: LD_INT 6
84463: DOUBLE
84464: EQUAL
84465: IFTRUE 84469
84467: GO 84589
84469: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
84470: LD_ADDR_VAR 0 1
84474: PUSH
84475: LD_INT 2
84477: PUSH
84478: LD_INT 4
84480: PUSH
84481: LD_INT 5
84483: PUSH
84484: LD_INT 6
84486: PUSH
84487: LD_INT 8
84489: PUSH
84490: LD_INT 11
84492: PUSH
84493: LD_INT 12
84495: PUSH
84496: LD_INT 15
84498: PUSH
84499: LD_INT 16
84501: PUSH
84502: LD_INT 20
84504: PUSH
84505: LD_INT 21
84507: PUSH
84508: LD_INT 22
84510: PUSH
84511: LD_INT 23
84513: PUSH
84514: LD_INT 25
84516: PUSH
84517: LD_INT 26
84519: PUSH
84520: LD_INT 30
84522: PUSH
84523: LD_INT 31
84525: PUSH
84526: LD_INT 32
84528: PUSH
84529: LD_INT 36
84531: PUSH
84532: EMPTY
84533: LIST
84534: LIST
84535: LIST
84536: LIST
84537: LIST
84538: LIST
84539: LIST
84540: LIST
84541: LIST
84542: LIST
84543: LIST
84544: LIST
84545: LIST
84546: LIST
84547: LIST
84548: LIST
84549: LIST
84550: LIST
84551: LIST
84552: PUSH
84553: LD_INT 101
84555: PUSH
84556: LD_INT 102
84558: PUSH
84559: LD_INT 105
84561: PUSH
84562: LD_INT 106
84564: PUSH
84565: LD_INT 108
84567: PUSH
84568: LD_INT 109
84570: PUSH
84571: LD_INT 112
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: ST_TO_ADDR
84587: GO 86954
84589: LD_INT 7
84591: DOUBLE
84592: EQUAL
84593: IFTRUE 84597
84595: GO 84697
84597: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
84598: LD_ADDR_VAR 0 1
84602: PUSH
84603: LD_INT 2
84605: PUSH
84606: LD_INT 4
84608: PUSH
84609: LD_INT 5
84611: PUSH
84612: LD_INT 7
84614: PUSH
84615: LD_INT 11
84617: PUSH
84618: LD_INT 12
84620: PUSH
84621: LD_INT 15
84623: PUSH
84624: LD_INT 16
84626: PUSH
84627: LD_INT 20
84629: PUSH
84630: LD_INT 21
84632: PUSH
84633: LD_INT 22
84635: PUSH
84636: LD_INT 23
84638: PUSH
84639: LD_INT 25
84641: PUSH
84642: LD_INT 26
84644: PUSH
84645: EMPTY
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: PUSH
84661: LD_INT 101
84663: PUSH
84664: LD_INT 102
84666: PUSH
84667: LD_INT 103
84669: PUSH
84670: LD_INT 105
84672: PUSH
84673: LD_INT 106
84675: PUSH
84676: LD_INT 108
84678: PUSH
84679: LD_INT 112
84681: PUSH
84682: EMPTY
84683: LIST
84684: LIST
84685: LIST
84686: LIST
84687: LIST
84688: LIST
84689: LIST
84690: PUSH
84691: EMPTY
84692: LIST
84693: LIST
84694: ST_TO_ADDR
84695: GO 86954
84697: LD_INT 8
84699: DOUBLE
84700: EQUAL
84701: IFTRUE 84705
84703: GO 84833
84705: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
84706: LD_ADDR_VAR 0 1
84710: PUSH
84711: LD_INT 2
84713: PUSH
84714: LD_INT 4
84716: PUSH
84717: LD_INT 5
84719: PUSH
84720: LD_INT 6
84722: PUSH
84723: LD_INT 7
84725: PUSH
84726: LD_INT 8
84728: PUSH
84729: LD_INT 11
84731: PUSH
84732: LD_INT 12
84734: PUSH
84735: LD_INT 15
84737: PUSH
84738: LD_INT 16
84740: PUSH
84741: LD_INT 20
84743: PUSH
84744: LD_INT 21
84746: PUSH
84747: LD_INT 22
84749: PUSH
84750: LD_INT 23
84752: PUSH
84753: LD_INT 25
84755: PUSH
84756: LD_INT 26
84758: PUSH
84759: LD_INT 30
84761: PUSH
84762: LD_INT 31
84764: PUSH
84765: LD_INT 32
84767: PUSH
84768: LD_INT 36
84770: PUSH
84771: EMPTY
84772: LIST
84773: LIST
84774: LIST
84775: LIST
84776: LIST
84777: LIST
84778: LIST
84779: LIST
84780: LIST
84781: LIST
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: LIST
84788: LIST
84789: LIST
84790: LIST
84791: LIST
84792: PUSH
84793: LD_INT 101
84795: PUSH
84796: LD_INT 102
84798: PUSH
84799: LD_INT 103
84801: PUSH
84802: LD_INT 105
84804: PUSH
84805: LD_INT 106
84807: PUSH
84808: LD_INT 108
84810: PUSH
84811: LD_INT 109
84813: PUSH
84814: LD_INT 112
84816: PUSH
84817: EMPTY
84818: LIST
84819: LIST
84820: LIST
84821: LIST
84822: LIST
84823: LIST
84824: LIST
84825: LIST
84826: PUSH
84827: EMPTY
84828: LIST
84829: LIST
84830: ST_TO_ADDR
84831: GO 86954
84833: LD_INT 9
84835: DOUBLE
84836: EQUAL
84837: IFTRUE 84841
84839: GO 84977
84841: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
84842: LD_ADDR_VAR 0 1
84846: PUSH
84847: LD_INT 2
84849: PUSH
84850: LD_INT 4
84852: PUSH
84853: LD_INT 5
84855: PUSH
84856: LD_INT 6
84858: PUSH
84859: LD_INT 7
84861: PUSH
84862: LD_INT 8
84864: PUSH
84865: LD_INT 11
84867: PUSH
84868: LD_INT 12
84870: PUSH
84871: LD_INT 15
84873: PUSH
84874: LD_INT 16
84876: PUSH
84877: LD_INT 20
84879: PUSH
84880: LD_INT 21
84882: PUSH
84883: LD_INT 22
84885: PUSH
84886: LD_INT 23
84888: PUSH
84889: LD_INT 25
84891: PUSH
84892: LD_INT 26
84894: PUSH
84895: LD_INT 28
84897: PUSH
84898: LD_INT 30
84900: PUSH
84901: LD_INT 31
84903: PUSH
84904: LD_INT 32
84906: PUSH
84907: LD_INT 36
84909: PUSH
84910: EMPTY
84911: LIST
84912: LIST
84913: LIST
84914: LIST
84915: LIST
84916: LIST
84917: LIST
84918: LIST
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: LIST
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: PUSH
84933: LD_INT 101
84935: PUSH
84936: LD_INT 102
84938: PUSH
84939: LD_INT 103
84941: PUSH
84942: LD_INT 105
84944: PUSH
84945: LD_INT 106
84947: PUSH
84948: LD_INT 108
84950: PUSH
84951: LD_INT 109
84953: PUSH
84954: LD_INT 112
84956: PUSH
84957: LD_INT 114
84959: PUSH
84960: EMPTY
84961: LIST
84962: LIST
84963: LIST
84964: LIST
84965: LIST
84966: LIST
84967: LIST
84968: LIST
84969: LIST
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: ST_TO_ADDR
84975: GO 86954
84977: LD_INT 10
84979: DOUBLE
84980: EQUAL
84981: IFTRUE 84985
84983: GO 85169
84985: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
84986: LD_ADDR_VAR 0 1
84990: PUSH
84991: LD_INT 2
84993: PUSH
84994: LD_INT 4
84996: PUSH
84997: LD_INT 5
84999: PUSH
85000: LD_INT 6
85002: PUSH
85003: LD_INT 7
85005: PUSH
85006: LD_INT 8
85008: PUSH
85009: LD_INT 9
85011: PUSH
85012: LD_INT 10
85014: PUSH
85015: LD_INT 11
85017: PUSH
85018: LD_INT 12
85020: PUSH
85021: LD_INT 13
85023: PUSH
85024: LD_INT 14
85026: PUSH
85027: LD_INT 15
85029: PUSH
85030: LD_INT 16
85032: PUSH
85033: LD_INT 17
85035: PUSH
85036: LD_INT 18
85038: PUSH
85039: LD_INT 19
85041: PUSH
85042: LD_INT 20
85044: PUSH
85045: LD_INT 21
85047: PUSH
85048: LD_INT 22
85050: PUSH
85051: LD_INT 23
85053: PUSH
85054: LD_INT 24
85056: PUSH
85057: LD_INT 25
85059: PUSH
85060: LD_INT 26
85062: PUSH
85063: LD_INT 28
85065: PUSH
85066: LD_INT 30
85068: PUSH
85069: LD_INT 31
85071: PUSH
85072: LD_INT 32
85074: PUSH
85075: LD_INT 36
85077: PUSH
85078: EMPTY
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: LIST
85102: LIST
85103: LIST
85104: LIST
85105: LIST
85106: LIST
85107: LIST
85108: PUSH
85109: LD_INT 101
85111: PUSH
85112: LD_INT 102
85114: PUSH
85115: LD_INT 103
85117: PUSH
85118: LD_INT 104
85120: PUSH
85121: LD_INT 105
85123: PUSH
85124: LD_INT 106
85126: PUSH
85127: LD_INT 107
85129: PUSH
85130: LD_INT 108
85132: PUSH
85133: LD_INT 109
85135: PUSH
85136: LD_INT 110
85138: PUSH
85139: LD_INT 111
85141: PUSH
85142: LD_INT 112
85144: PUSH
85145: LD_INT 114
85147: PUSH
85148: EMPTY
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: PUSH
85163: EMPTY
85164: LIST
85165: LIST
85166: ST_TO_ADDR
85167: GO 86954
85169: LD_INT 11
85171: DOUBLE
85172: EQUAL
85173: IFTRUE 85177
85175: GO 85369
85177: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
85178: LD_ADDR_VAR 0 1
85182: PUSH
85183: LD_INT 2
85185: PUSH
85186: LD_INT 3
85188: PUSH
85189: LD_INT 4
85191: PUSH
85192: LD_INT 5
85194: PUSH
85195: LD_INT 6
85197: PUSH
85198: LD_INT 7
85200: PUSH
85201: LD_INT 8
85203: PUSH
85204: LD_INT 9
85206: PUSH
85207: LD_INT 10
85209: PUSH
85210: LD_INT 11
85212: PUSH
85213: LD_INT 12
85215: PUSH
85216: LD_INT 13
85218: PUSH
85219: LD_INT 14
85221: PUSH
85222: LD_INT 15
85224: PUSH
85225: LD_INT 16
85227: PUSH
85228: LD_INT 17
85230: PUSH
85231: LD_INT 18
85233: PUSH
85234: LD_INT 19
85236: PUSH
85237: LD_INT 20
85239: PUSH
85240: LD_INT 21
85242: PUSH
85243: LD_INT 22
85245: PUSH
85246: LD_INT 23
85248: PUSH
85249: LD_INT 24
85251: PUSH
85252: LD_INT 25
85254: PUSH
85255: LD_INT 26
85257: PUSH
85258: LD_INT 28
85260: PUSH
85261: LD_INT 30
85263: PUSH
85264: LD_INT 31
85266: PUSH
85267: LD_INT 32
85269: PUSH
85270: LD_INT 34
85272: PUSH
85273: LD_INT 36
85275: PUSH
85276: EMPTY
85277: LIST
85278: LIST
85279: LIST
85280: LIST
85281: LIST
85282: LIST
85283: LIST
85284: LIST
85285: LIST
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: PUSH
85309: LD_INT 101
85311: PUSH
85312: LD_INT 102
85314: PUSH
85315: LD_INT 103
85317: PUSH
85318: LD_INT 104
85320: PUSH
85321: LD_INT 105
85323: PUSH
85324: LD_INT 106
85326: PUSH
85327: LD_INT 107
85329: PUSH
85330: LD_INT 108
85332: PUSH
85333: LD_INT 109
85335: PUSH
85336: LD_INT 110
85338: PUSH
85339: LD_INT 111
85341: PUSH
85342: LD_INT 112
85344: PUSH
85345: LD_INT 114
85347: PUSH
85348: EMPTY
85349: LIST
85350: LIST
85351: LIST
85352: LIST
85353: LIST
85354: LIST
85355: LIST
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: LIST
85362: PUSH
85363: EMPTY
85364: LIST
85365: LIST
85366: ST_TO_ADDR
85367: GO 86954
85369: LD_INT 12
85371: DOUBLE
85372: EQUAL
85373: IFTRUE 85377
85375: GO 85585
85377: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
85378: LD_ADDR_VAR 0 1
85382: PUSH
85383: LD_INT 1
85385: PUSH
85386: LD_INT 2
85388: PUSH
85389: LD_INT 3
85391: PUSH
85392: LD_INT 4
85394: PUSH
85395: LD_INT 5
85397: PUSH
85398: LD_INT 6
85400: PUSH
85401: LD_INT 7
85403: PUSH
85404: LD_INT 8
85406: PUSH
85407: LD_INT 9
85409: PUSH
85410: LD_INT 10
85412: PUSH
85413: LD_INT 11
85415: PUSH
85416: LD_INT 12
85418: PUSH
85419: LD_INT 13
85421: PUSH
85422: LD_INT 14
85424: PUSH
85425: LD_INT 15
85427: PUSH
85428: LD_INT 16
85430: PUSH
85431: LD_INT 17
85433: PUSH
85434: LD_INT 18
85436: PUSH
85437: LD_INT 19
85439: PUSH
85440: LD_INT 20
85442: PUSH
85443: LD_INT 21
85445: PUSH
85446: LD_INT 22
85448: PUSH
85449: LD_INT 23
85451: PUSH
85452: LD_INT 24
85454: PUSH
85455: LD_INT 25
85457: PUSH
85458: LD_INT 26
85460: PUSH
85461: LD_INT 27
85463: PUSH
85464: LD_INT 28
85466: PUSH
85467: LD_INT 30
85469: PUSH
85470: LD_INT 31
85472: PUSH
85473: LD_INT 32
85475: PUSH
85476: LD_INT 33
85478: PUSH
85479: LD_INT 34
85481: PUSH
85482: LD_INT 36
85484: PUSH
85485: EMPTY
85486: LIST
85487: LIST
85488: LIST
85489: LIST
85490: LIST
85491: LIST
85492: LIST
85493: LIST
85494: LIST
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: LIST
85500: LIST
85501: LIST
85502: LIST
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: LIST
85512: LIST
85513: LIST
85514: LIST
85515: LIST
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: PUSH
85521: LD_INT 101
85523: PUSH
85524: LD_INT 102
85526: PUSH
85527: LD_INT 103
85529: PUSH
85530: LD_INT 104
85532: PUSH
85533: LD_INT 105
85535: PUSH
85536: LD_INT 106
85538: PUSH
85539: LD_INT 107
85541: PUSH
85542: LD_INT 108
85544: PUSH
85545: LD_INT 109
85547: PUSH
85548: LD_INT 110
85550: PUSH
85551: LD_INT 111
85553: PUSH
85554: LD_INT 112
85556: PUSH
85557: LD_INT 113
85559: PUSH
85560: LD_INT 114
85562: PUSH
85563: EMPTY
85564: LIST
85565: LIST
85566: LIST
85567: LIST
85568: LIST
85569: LIST
85570: LIST
85571: LIST
85572: LIST
85573: LIST
85574: LIST
85575: LIST
85576: LIST
85577: LIST
85578: PUSH
85579: EMPTY
85580: LIST
85581: LIST
85582: ST_TO_ADDR
85583: GO 86954
85585: LD_INT 13
85587: DOUBLE
85588: EQUAL
85589: IFTRUE 85593
85591: GO 85789
85593: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
85594: LD_ADDR_VAR 0 1
85598: PUSH
85599: LD_INT 1
85601: PUSH
85602: LD_INT 2
85604: PUSH
85605: LD_INT 3
85607: PUSH
85608: LD_INT 4
85610: PUSH
85611: LD_INT 5
85613: PUSH
85614: LD_INT 8
85616: PUSH
85617: LD_INT 9
85619: PUSH
85620: LD_INT 10
85622: PUSH
85623: LD_INT 11
85625: PUSH
85626: LD_INT 12
85628: PUSH
85629: LD_INT 14
85631: PUSH
85632: LD_INT 15
85634: PUSH
85635: LD_INT 16
85637: PUSH
85638: LD_INT 17
85640: PUSH
85641: LD_INT 18
85643: PUSH
85644: LD_INT 19
85646: PUSH
85647: LD_INT 20
85649: PUSH
85650: LD_INT 21
85652: PUSH
85653: LD_INT 22
85655: PUSH
85656: LD_INT 23
85658: PUSH
85659: LD_INT 24
85661: PUSH
85662: LD_INT 25
85664: PUSH
85665: LD_INT 26
85667: PUSH
85668: LD_INT 27
85670: PUSH
85671: LD_INT 28
85673: PUSH
85674: LD_INT 30
85676: PUSH
85677: LD_INT 31
85679: PUSH
85680: LD_INT 32
85682: PUSH
85683: LD_INT 33
85685: PUSH
85686: LD_INT 34
85688: PUSH
85689: LD_INT 36
85691: PUSH
85692: EMPTY
85693: LIST
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: LIST
85699: LIST
85700: LIST
85701: LIST
85702: LIST
85703: LIST
85704: LIST
85705: LIST
85706: LIST
85707: LIST
85708: LIST
85709: LIST
85710: LIST
85711: LIST
85712: LIST
85713: LIST
85714: LIST
85715: LIST
85716: LIST
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 101
85727: PUSH
85728: LD_INT 102
85730: PUSH
85731: LD_INT 103
85733: PUSH
85734: LD_INT 104
85736: PUSH
85737: LD_INT 105
85739: PUSH
85740: LD_INT 106
85742: PUSH
85743: LD_INT 107
85745: PUSH
85746: LD_INT 108
85748: PUSH
85749: LD_INT 109
85751: PUSH
85752: LD_INT 110
85754: PUSH
85755: LD_INT 111
85757: PUSH
85758: LD_INT 112
85760: PUSH
85761: LD_INT 113
85763: PUSH
85764: LD_INT 114
85766: PUSH
85767: EMPTY
85768: LIST
85769: LIST
85770: LIST
85771: LIST
85772: LIST
85773: LIST
85774: LIST
85775: LIST
85776: LIST
85777: LIST
85778: LIST
85779: LIST
85780: LIST
85781: LIST
85782: PUSH
85783: EMPTY
85784: LIST
85785: LIST
85786: ST_TO_ADDR
85787: GO 86954
85789: LD_INT 14
85791: DOUBLE
85792: EQUAL
85793: IFTRUE 85797
85795: GO 86009
85797: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
85798: LD_ADDR_VAR 0 1
85802: PUSH
85803: LD_INT 1
85805: PUSH
85806: LD_INT 2
85808: PUSH
85809: LD_INT 3
85811: PUSH
85812: LD_INT 4
85814: PUSH
85815: LD_INT 5
85817: PUSH
85818: LD_INT 6
85820: PUSH
85821: LD_INT 7
85823: PUSH
85824: LD_INT 8
85826: PUSH
85827: LD_INT 9
85829: PUSH
85830: LD_INT 10
85832: PUSH
85833: LD_INT 11
85835: PUSH
85836: LD_INT 12
85838: PUSH
85839: LD_INT 13
85841: PUSH
85842: LD_INT 14
85844: PUSH
85845: LD_INT 15
85847: PUSH
85848: LD_INT 16
85850: PUSH
85851: LD_INT 17
85853: PUSH
85854: LD_INT 18
85856: PUSH
85857: LD_INT 19
85859: PUSH
85860: LD_INT 20
85862: PUSH
85863: LD_INT 21
85865: PUSH
85866: LD_INT 22
85868: PUSH
85869: LD_INT 23
85871: PUSH
85872: LD_INT 24
85874: PUSH
85875: LD_INT 25
85877: PUSH
85878: LD_INT 26
85880: PUSH
85881: LD_INT 27
85883: PUSH
85884: LD_INT 28
85886: PUSH
85887: LD_INT 29
85889: PUSH
85890: LD_INT 30
85892: PUSH
85893: LD_INT 31
85895: PUSH
85896: LD_INT 32
85898: PUSH
85899: LD_INT 33
85901: PUSH
85902: LD_INT 34
85904: PUSH
85905: LD_INT 36
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: LIST
85914: LIST
85915: LIST
85916: LIST
85917: LIST
85918: LIST
85919: LIST
85920: LIST
85921: LIST
85922: LIST
85923: LIST
85924: LIST
85925: LIST
85926: LIST
85927: LIST
85928: LIST
85929: LIST
85930: LIST
85931: LIST
85932: LIST
85933: LIST
85934: LIST
85935: LIST
85936: LIST
85937: LIST
85938: LIST
85939: LIST
85940: LIST
85941: LIST
85942: LIST
85943: LIST
85944: PUSH
85945: LD_INT 101
85947: PUSH
85948: LD_INT 102
85950: PUSH
85951: LD_INT 103
85953: PUSH
85954: LD_INT 104
85956: PUSH
85957: LD_INT 105
85959: PUSH
85960: LD_INT 106
85962: PUSH
85963: LD_INT 107
85965: PUSH
85966: LD_INT 108
85968: PUSH
85969: LD_INT 109
85971: PUSH
85972: LD_INT 110
85974: PUSH
85975: LD_INT 111
85977: PUSH
85978: LD_INT 112
85980: PUSH
85981: LD_INT 113
85983: PUSH
85984: LD_INT 114
85986: PUSH
85987: EMPTY
85988: LIST
85989: LIST
85990: LIST
85991: LIST
85992: LIST
85993: LIST
85994: LIST
85995: LIST
85996: LIST
85997: LIST
85998: LIST
85999: LIST
86000: LIST
86001: LIST
86002: PUSH
86003: EMPTY
86004: LIST
86005: LIST
86006: ST_TO_ADDR
86007: GO 86954
86009: LD_INT 15
86011: DOUBLE
86012: EQUAL
86013: IFTRUE 86017
86015: GO 86229
86017: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
86018: LD_ADDR_VAR 0 1
86022: PUSH
86023: LD_INT 1
86025: PUSH
86026: LD_INT 2
86028: PUSH
86029: LD_INT 3
86031: PUSH
86032: LD_INT 4
86034: PUSH
86035: LD_INT 5
86037: PUSH
86038: LD_INT 6
86040: PUSH
86041: LD_INT 7
86043: PUSH
86044: LD_INT 8
86046: PUSH
86047: LD_INT 9
86049: PUSH
86050: LD_INT 10
86052: PUSH
86053: LD_INT 11
86055: PUSH
86056: LD_INT 12
86058: PUSH
86059: LD_INT 13
86061: PUSH
86062: LD_INT 14
86064: PUSH
86065: LD_INT 15
86067: PUSH
86068: LD_INT 16
86070: PUSH
86071: LD_INT 17
86073: PUSH
86074: LD_INT 18
86076: PUSH
86077: LD_INT 19
86079: PUSH
86080: LD_INT 20
86082: PUSH
86083: LD_INT 21
86085: PUSH
86086: LD_INT 22
86088: PUSH
86089: LD_INT 23
86091: PUSH
86092: LD_INT 24
86094: PUSH
86095: LD_INT 25
86097: PUSH
86098: LD_INT 26
86100: PUSH
86101: LD_INT 27
86103: PUSH
86104: LD_INT 28
86106: PUSH
86107: LD_INT 29
86109: PUSH
86110: LD_INT 30
86112: PUSH
86113: LD_INT 31
86115: PUSH
86116: LD_INT 32
86118: PUSH
86119: LD_INT 33
86121: PUSH
86122: LD_INT 34
86124: PUSH
86125: LD_INT 36
86127: PUSH
86128: EMPTY
86129: LIST
86130: LIST
86131: LIST
86132: LIST
86133: LIST
86134: LIST
86135: LIST
86136: LIST
86137: LIST
86138: LIST
86139: LIST
86140: LIST
86141: LIST
86142: LIST
86143: LIST
86144: LIST
86145: LIST
86146: LIST
86147: LIST
86148: LIST
86149: LIST
86150: LIST
86151: LIST
86152: LIST
86153: LIST
86154: LIST
86155: LIST
86156: LIST
86157: LIST
86158: LIST
86159: LIST
86160: LIST
86161: LIST
86162: LIST
86163: LIST
86164: PUSH
86165: LD_INT 101
86167: PUSH
86168: LD_INT 102
86170: PUSH
86171: LD_INT 103
86173: PUSH
86174: LD_INT 104
86176: PUSH
86177: LD_INT 105
86179: PUSH
86180: LD_INT 106
86182: PUSH
86183: LD_INT 107
86185: PUSH
86186: LD_INT 108
86188: PUSH
86189: LD_INT 109
86191: PUSH
86192: LD_INT 110
86194: PUSH
86195: LD_INT 111
86197: PUSH
86198: LD_INT 112
86200: PUSH
86201: LD_INT 113
86203: PUSH
86204: LD_INT 114
86206: PUSH
86207: EMPTY
86208: LIST
86209: LIST
86210: LIST
86211: LIST
86212: LIST
86213: LIST
86214: LIST
86215: LIST
86216: LIST
86217: LIST
86218: LIST
86219: LIST
86220: LIST
86221: LIST
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: ST_TO_ADDR
86227: GO 86954
86229: LD_INT 16
86231: DOUBLE
86232: EQUAL
86233: IFTRUE 86237
86235: GO 86361
86237: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
86238: LD_ADDR_VAR 0 1
86242: PUSH
86243: LD_INT 2
86245: PUSH
86246: LD_INT 4
86248: PUSH
86249: LD_INT 5
86251: PUSH
86252: LD_INT 7
86254: PUSH
86255: LD_INT 11
86257: PUSH
86258: LD_INT 12
86260: PUSH
86261: LD_INT 15
86263: PUSH
86264: LD_INT 16
86266: PUSH
86267: LD_INT 20
86269: PUSH
86270: LD_INT 21
86272: PUSH
86273: LD_INT 22
86275: PUSH
86276: LD_INT 23
86278: PUSH
86279: LD_INT 25
86281: PUSH
86282: LD_INT 26
86284: PUSH
86285: LD_INT 30
86287: PUSH
86288: LD_INT 31
86290: PUSH
86291: LD_INT 32
86293: PUSH
86294: LD_INT 33
86296: PUSH
86297: LD_INT 34
86299: PUSH
86300: EMPTY
86301: LIST
86302: LIST
86303: LIST
86304: LIST
86305: LIST
86306: LIST
86307: LIST
86308: LIST
86309: LIST
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: PUSH
86321: LD_INT 101
86323: PUSH
86324: LD_INT 102
86326: PUSH
86327: LD_INT 103
86329: PUSH
86330: LD_INT 106
86332: PUSH
86333: LD_INT 108
86335: PUSH
86336: LD_INT 112
86338: PUSH
86339: LD_INT 113
86341: PUSH
86342: LD_INT 114
86344: PUSH
86345: EMPTY
86346: LIST
86347: LIST
86348: LIST
86349: LIST
86350: LIST
86351: LIST
86352: LIST
86353: LIST
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: ST_TO_ADDR
86359: GO 86954
86361: LD_INT 17
86363: DOUBLE
86364: EQUAL
86365: IFTRUE 86369
86367: GO 86581
86369: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
86370: LD_ADDR_VAR 0 1
86374: PUSH
86375: LD_INT 1
86377: PUSH
86378: LD_INT 2
86380: PUSH
86381: LD_INT 3
86383: PUSH
86384: LD_INT 4
86386: PUSH
86387: LD_INT 5
86389: PUSH
86390: LD_INT 6
86392: PUSH
86393: LD_INT 7
86395: PUSH
86396: LD_INT 8
86398: PUSH
86399: LD_INT 9
86401: PUSH
86402: LD_INT 10
86404: PUSH
86405: LD_INT 11
86407: PUSH
86408: LD_INT 12
86410: PUSH
86411: LD_INT 13
86413: PUSH
86414: LD_INT 14
86416: PUSH
86417: LD_INT 15
86419: PUSH
86420: LD_INT 16
86422: PUSH
86423: LD_INT 17
86425: PUSH
86426: LD_INT 18
86428: PUSH
86429: LD_INT 19
86431: PUSH
86432: LD_INT 20
86434: PUSH
86435: LD_INT 21
86437: PUSH
86438: LD_INT 22
86440: PUSH
86441: LD_INT 23
86443: PUSH
86444: LD_INT 24
86446: PUSH
86447: LD_INT 25
86449: PUSH
86450: LD_INT 26
86452: PUSH
86453: LD_INT 27
86455: PUSH
86456: LD_INT 28
86458: PUSH
86459: LD_INT 29
86461: PUSH
86462: LD_INT 30
86464: PUSH
86465: LD_INT 31
86467: PUSH
86468: LD_INT 32
86470: PUSH
86471: LD_INT 33
86473: PUSH
86474: LD_INT 34
86476: PUSH
86477: LD_INT 36
86479: PUSH
86480: EMPTY
86481: LIST
86482: LIST
86483: LIST
86484: LIST
86485: LIST
86486: LIST
86487: LIST
86488: LIST
86489: LIST
86490: LIST
86491: LIST
86492: LIST
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: LIST
86501: LIST
86502: LIST
86503: LIST
86504: LIST
86505: LIST
86506: LIST
86507: LIST
86508: LIST
86509: LIST
86510: LIST
86511: LIST
86512: LIST
86513: LIST
86514: LIST
86515: LIST
86516: PUSH
86517: LD_INT 101
86519: PUSH
86520: LD_INT 102
86522: PUSH
86523: LD_INT 103
86525: PUSH
86526: LD_INT 104
86528: PUSH
86529: LD_INT 105
86531: PUSH
86532: LD_INT 106
86534: PUSH
86535: LD_INT 107
86537: PUSH
86538: LD_INT 108
86540: PUSH
86541: LD_INT 109
86543: PUSH
86544: LD_INT 110
86546: PUSH
86547: LD_INT 111
86549: PUSH
86550: LD_INT 112
86552: PUSH
86553: LD_INT 113
86555: PUSH
86556: LD_INT 114
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: LIST
86563: LIST
86564: LIST
86565: LIST
86566: LIST
86567: LIST
86568: LIST
86569: LIST
86570: LIST
86571: LIST
86572: LIST
86573: LIST
86574: PUSH
86575: EMPTY
86576: LIST
86577: LIST
86578: ST_TO_ADDR
86579: GO 86954
86581: LD_INT 18
86583: DOUBLE
86584: EQUAL
86585: IFTRUE 86589
86587: GO 86725
86589: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
86590: LD_ADDR_VAR 0 1
86594: PUSH
86595: LD_INT 2
86597: PUSH
86598: LD_INT 4
86600: PUSH
86601: LD_INT 5
86603: PUSH
86604: LD_INT 7
86606: PUSH
86607: LD_INT 11
86609: PUSH
86610: LD_INT 12
86612: PUSH
86613: LD_INT 15
86615: PUSH
86616: LD_INT 16
86618: PUSH
86619: LD_INT 20
86621: PUSH
86622: LD_INT 21
86624: PUSH
86625: LD_INT 22
86627: PUSH
86628: LD_INT 23
86630: PUSH
86631: LD_INT 25
86633: PUSH
86634: LD_INT 26
86636: PUSH
86637: LD_INT 30
86639: PUSH
86640: LD_INT 31
86642: PUSH
86643: LD_INT 32
86645: PUSH
86646: LD_INT 33
86648: PUSH
86649: LD_INT 34
86651: PUSH
86652: LD_INT 35
86654: PUSH
86655: LD_INT 36
86657: PUSH
86658: EMPTY
86659: LIST
86660: LIST
86661: LIST
86662: LIST
86663: LIST
86664: LIST
86665: LIST
86666: LIST
86667: LIST
86668: LIST
86669: LIST
86670: LIST
86671: LIST
86672: LIST
86673: LIST
86674: LIST
86675: LIST
86676: LIST
86677: LIST
86678: LIST
86679: LIST
86680: PUSH
86681: LD_INT 101
86683: PUSH
86684: LD_INT 102
86686: PUSH
86687: LD_INT 103
86689: PUSH
86690: LD_INT 106
86692: PUSH
86693: LD_INT 108
86695: PUSH
86696: LD_INT 112
86698: PUSH
86699: LD_INT 113
86701: PUSH
86702: LD_INT 114
86704: PUSH
86705: LD_INT 115
86707: PUSH
86708: EMPTY
86709: LIST
86710: LIST
86711: LIST
86712: LIST
86713: LIST
86714: LIST
86715: LIST
86716: LIST
86717: LIST
86718: PUSH
86719: EMPTY
86720: LIST
86721: LIST
86722: ST_TO_ADDR
86723: GO 86954
86725: LD_INT 19
86727: DOUBLE
86728: EQUAL
86729: IFTRUE 86733
86731: GO 86953
86733: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
86734: LD_ADDR_VAR 0 1
86738: PUSH
86739: LD_INT 1
86741: PUSH
86742: LD_INT 2
86744: PUSH
86745: LD_INT 3
86747: PUSH
86748: LD_INT 4
86750: PUSH
86751: LD_INT 5
86753: PUSH
86754: LD_INT 6
86756: PUSH
86757: LD_INT 7
86759: PUSH
86760: LD_INT 8
86762: PUSH
86763: LD_INT 9
86765: PUSH
86766: LD_INT 10
86768: PUSH
86769: LD_INT 11
86771: PUSH
86772: LD_INT 12
86774: PUSH
86775: LD_INT 13
86777: PUSH
86778: LD_INT 14
86780: PUSH
86781: LD_INT 15
86783: PUSH
86784: LD_INT 16
86786: PUSH
86787: LD_INT 17
86789: PUSH
86790: LD_INT 18
86792: PUSH
86793: LD_INT 19
86795: PUSH
86796: LD_INT 20
86798: PUSH
86799: LD_INT 21
86801: PUSH
86802: LD_INT 22
86804: PUSH
86805: LD_INT 23
86807: PUSH
86808: LD_INT 24
86810: PUSH
86811: LD_INT 25
86813: PUSH
86814: LD_INT 26
86816: PUSH
86817: LD_INT 27
86819: PUSH
86820: LD_INT 28
86822: PUSH
86823: LD_INT 29
86825: PUSH
86826: LD_INT 30
86828: PUSH
86829: LD_INT 31
86831: PUSH
86832: LD_INT 32
86834: PUSH
86835: LD_INT 33
86837: PUSH
86838: LD_INT 34
86840: PUSH
86841: LD_INT 35
86843: PUSH
86844: LD_INT 36
86846: PUSH
86847: EMPTY
86848: LIST
86849: LIST
86850: LIST
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: LIST
86862: LIST
86863: LIST
86864: LIST
86865: LIST
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: LIST
86871: LIST
86872: LIST
86873: LIST
86874: LIST
86875: LIST
86876: LIST
86877: LIST
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: LIST
86884: PUSH
86885: LD_INT 101
86887: PUSH
86888: LD_INT 102
86890: PUSH
86891: LD_INT 103
86893: PUSH
86894: LD_INT 104
86896: PUSH
86897: LD_INT 105
86899: PUSH
86900: LD_INT 106
86902: PUSH
86903: LD_INT 107
86905: PUSH
86906: LD_INT 108
86908: PUSH
86909: LD_INT 109
86911: PUSH
86912: LD_INT 110
86914: PUSH
86915: LD_INT 111
86917: PUSH
86918: LD_INT 112
86920: PUSH
86921: LD_INT 113
86923: PUSH
86924: LD_INT 114
86926: PUSH
86927: LD_INT 115
86929: PUSH
86930: EMPTY
86931: LIST
86932: LIST
86933: LIST
86934: LIST
86935: LIST
86936: LIST
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: ST_TO_ADDR
86951: GO 86954
86953: POP
// end else
86954: GO 87173
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
86956: LD_ADDR_VAR 0 1
86960: PUSH
86961: LD_INT 1
86963: PUSH
86964: LD_INT 2
86966: PUSH
86967: LD_INT 3
86969: PUSH
86970: LD_INT 4
86972: PUSH
86973: LD_INT 5
86975: PUSH
86976: LD_INT 6
86978: PUSH
86979: LD_INT 7
86981: PUSH
86982: LD_INT 8
86984: PUSH
86985: LD_INT 9
86987: PUSH
86988: LD_INT 10
86990: PUSH
86991: LD_INT 11
86993: PUSH
86994: LD_INT 12
86996: PUSH
86997: LD_INT 13
86999: PUSH
87000: LD_INT 14
87002: PUSH
87003: LD_INT 15
87005: PUSH
87006: LD_INT 16
87008: PUSH
87009: LD_INT 17
87011: PUSH
87012: LD_INT 18
87014: PUSH
87015: LD_INT 19
87017: PUSH
87018: LD_INT 20
87020: PUSH
87021: LD_INT 21
87023: PUSH
87024: LD_INT 22
87026: PUSH
87027: LD_INT 23
87029: PUSH
87030: LD_INT 24
87032: PUSH
87033: LD_INT 25
87035: PUSH
87036: LD_INT 26
87038: PUSH
87039: LD_INT 27
87041: PUSH
87042: LD_INT 28
87044: PUSH
87045: LD_INT 29
87047: PUSH
87048: LD_INT 30
87050: PUSH
87051: LD_INT 31
87053: PUSH
87054: LD_INT 32
87056: PUSH
87057: LD_INT 33
87059: PUSH
87060: LD_INT 34
87062: PUSH
87063: LD_INT 35
87065: PUSH
87066: LD_INT 36
87068: PUSH
87069: EMPTY
87070: LIST
87071: LIST
87072: LIST
87073: LIST
87074: LIST
87075: LIST
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: LIST
87084: LIST
87085: LIST
87086: LIST
87087: LIST
87088: LIST
87089: LIST
87090: LIST
87091: LIST
87092: LIST
87093: LIST
87094: LIST
87095: LIST
87096: LIST
87097: LIST
87098: LIST
87099: LIST
87100: LIST
87101: LIST
87102: LIST
87103: LIST
87104: LIST
87105: LIST
87106: PUSH
87107: LD_INT 101
87109: PUSH
87110: LD_INT 102
87112: PUSH
87113: LD_INT 103
87115: PUSH
87116: LD_INT 104
87118: PUSH
87119: LD_INT 105
87121: PUSH
87122: LD_INT 106
87124: PUSH
87125: LD_INT 107
87127: PUSH
87128: LD_INT 108
87130: PUSH
87131: LD_INT 109
87133: PUSH
87134: LD_INT 110
87136: PUSH
87137: LD_INT 111
87139: PUSH
87140: LD_INT 112
87142: PUSH
87143: LD_INT 113
87145: PUSH
87146: LD_INT 114
87148: PUSH
87149: LD_INT 115
87151: PUSH
87152: EMPTY
87153: LIST
87154: LIST
87155: LIST
87156: LIST
87157: LIST
87158: LIST
87159: LIST
87160: LIST
87161: LIST
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: LIST
87168: PUSH
87169: EMPTY
87170: LIST
87171: LIST
87172: ST_TO_ADDR
// if result then
87173: LD_VAR 0 1
87177: IFFALSE 87466
// begin normal :=  ;
87179: LD_ADDR_VAR 0 3
87183: PUSH
87184: LD_STRING 
87186: ST_TO_ADDR
// hardcore :=  ;
87187: LD_ADDR_VAR 0 4
87191: PUSH
87192: LD_STRING 
87194: ST_TO_ADDR
// for i = 1 to normalCounter do
87195: LD_ADDR_VAR 0 5
87199: PUSH
87200: DOUBLE
87201: LD_INT 1
87203: DEC
87204: ST_TO_ADDR
87205: LD_EXP 122
87209: PUSH
87210: FOR_TO
87211: IFFALSE 87312
// begin tmp := 0 ;
87213: LD_ADDR_VAR 0 2
87217: PUSH
87218: LD_STRING 0
87220: ST_TO_ADDR
// if result [ 1 ] then
87221: LD_VAR 0 1
87225: PUSH
87226: LD_INT 1
87228: ARRAY
87229: IFFALSE 87294
// if result [ 1 ] [ 1 ] = i then
87231: LD_VAR 0 1
87235: PUSH
87236: LD_INT 1
87238: ARRAY
87239: PUSH
87240: LD_INT 1
87242: ARRAY
87243: PUSH
87244: LD_VAR 0 5
87248: EQUAL
87249: IFFALSE 87294
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
87251: LD_ADDR_VAR 0 1
87255: PUSH
87256: LD_VAR 0 1
87260: PPUSH
87261: LD_INT 1
87263: PPUSH
87264: LD_VAR 0 1
87268: PUSH
87269: LD_INT 1
87271: ARRAY
87272: PPUSH
87273: LD_INT 1
87275: PPUSH
87276: CALL_OW 3
87280: PPUSH
87281: CALL_OW 1
87285: ST_TO_ADDR
// tmp := 1 ;
87286: LD_ADDR_VAR 0 2
87290: PUSH
87291: LD_STRING 1
87293: ST_TO_ADDR
// end ; normal := normal & tmp ;
87294: LD_ADDR_VAR 0 3
87298: PUSH
87299: LD_VAR 0 3
87303: PUSH
87304: LD_VAR 0 2
87308: STR
87309: ST_TO_ADDR
// end ;
87310: GO 87210
87312: POP
87313: POP
// for i = 1 to hardcoreCounter do
87314: LD_ADDR_VAR 0 5
87318: PUSH
87319: DOUBLE
87320: LD_INT 1
87322: DEC
87323: ST_TO_ADDR
87324: LD_EXP 123
87328: PUSH
87329: FOR_TO
87330: IFFALSE 87435
// begin tmp := 0 ;
87332: LD_ADDR_VAR 0 2
87336: PUSH
87337: LD_STRING 0
87339: ST_TO_ADDR
// if result [ 2 ] then
87340: LD_VAR 0 1
87344: PUSH
87345: LD_INT 2
87347: ARRAY
87348: IFFALSE 87417
// if result [ 2 ] [ 1 ] = 100 + i then
87350: LD_VAR 0 1
87354: PUSH
87355: LD_INT 2
87357: ARRAY
87358: PUSH
87359: LD_INT 1
87361: ARRAY
87362: PUSH
87363: LD_INT 100
87365: PUSH
87366: LD_VAR 0 5
87370: PLUS
87371: EQUAL
87372: IFFALSE 87417
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
87374: LD_ADDR_VAR 0 1
87378: PUSH
87379: LD_VAR 0 1
87383: PPUSH
87384: LD_INT 2
87386: PPUSH
87387: LD_VAR 0 1
87391: PUSH
87392: LD_INT 2
87394: ARRAY
87395: PPUSH
87396: LD_INT 1
87398: PPUSH
87399: CALL_OW 3
87403: PPUSH
87404: CALL_OW 1
87408: ST_TO_ADDR
// tmp := 1 ;
87409: LD_ADDR_VAR 0 2
87413: PUSH
87414: LD_STRING 1
87416: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
87417: LD_ADDR_VAR 0 4
87421: PUSH
87422: LD_VAR 0 4
87426: PUSH
87427: LD_VAR 0 2
87431: STR
87432: ST_TO_ADDR
// end ;
87433: GO 87329
87435: POP
87436: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
87437: LD_STRING getStreamItemsFromMission("
87439: PUSH
87440: LD_VAR 0 3
87444: STR
87445: PUSH
87446: LD_STRING ","
87448: STR
87449: PUSH
87450: LD_VAR 0 4
87454: STR
87455: PUSH
87456: LD_STRING ")
87458: STR
87459: PPUSH
87460: CALL_OW 559
// end else
87464: GO 87473
// ToLua ( getStreamItemsFromMission("","") ) ;
87466: LD_STRING getStreamItemsFromMission("","")
87468: PPUSH
87469: CALL_OW 559
// end ;
87473: LD_VAR 0 1
87477: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
87478: LD_EXP 121
87482: PUSH
87483: LD_EXP 126
87487: AND
87488: IFFALSE 87612
87490: GO 87492
87492: DISABLE
87493: LD_INT 0
87495: PPUSH
87496: PPUSH
// begin enable ;
87497: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
87498: LD_ADDR_VAR 0 2
87502: PUSH
87503: LD_INT 22
87505: PUSH
87506: LD_OWVAR 2
87510: PUSH
87511: EMPTY
87512: LIST
87513: LIST
87514: PUSH
87515: LD_INT 2
87517: PUSH
87518: LD_INT 34
87520: PUSH
87521: LD_INT 7
87523: PUSH
87524: EMPTY
87525: LIST
87526: LIST
87527: PUSH
87528: LD_INT 34
87530: PUSH
87531: LD_INT 45
87533: PUSH
87534: EMPTY
87535: LIST
87536: LIST
87537: PUSH
87538: LD_INT 34
87540: PUSH
87541: LD_INT 28
87543: PUSH
87544: EMPTY
87545: LIST
87546: LIST
87547: PUSH
87548: LD_INT 34
87550: PUSH
87551: LD_INT 47
87553: PUSH
87554: EMPTY
87555: LIST
87556: LIST
87557: PUSH
87558: EMPTY
87559: LIST
87560: LIST
87561: LIST
87562: LIST
87563: LIST
87564: PUSH
87565: EMPTY
87566: LIST
87567: LIST
87568: PPUSH
87569: CALL_OW 69
87573: ST_TO_ADDR
// if not tmp then
87574: LD_VAR 0 2
87578: NOT
87579: IFFALSE 87583
// exit ;
87581: GO 87612
// for i in tmp do
87583: LD_ADDR_VAR 0 1
87587: PUSH
87588: LD_VAR 0 2
87592: PUSH
87593: FOR_IN
87594: IFFALSE 87610
// begin SetLives ( i , 0 ) ;
87596: LD_VAR 0 1
87600: PPUSH
87601: LD_INT 0
87603: PPUSH
87604: CALL_OW 234
// end ;
87608: GO 87593
87610: POP
87611: POP
// end ;
87612: PPOPN 2
87614: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
87615: LD_EXP 121
87619: PUSH
87620: LD_EXP 127
87624: AND
87625: IFFALSE 87709
87627: GO 87629
87629: DISABLE
87630: LD_INT 0
87632: PPUSH
87633: PPUSH
// begin enable ;
87634: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
87635: LD_ADDR_VAR 0 2
87639: PUSH
87640: LD_INT 22
87642: PUSH
87643: LD_OWVAR 2
87647: PUSH
87648: EMPTY
87649: LIST
87650: LIST
87651: PUSH
87652: LD_INT 32
87654: PUSH
87655: LD_INT 3
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: EMPTY
87663: LIST
87664: LIST
87665: PPUSH
87666: CALL_OW 69
87670: ST_TO_ADDR
// if not tmp then
87671: LD_VAR 0 2
87675: NOT
87676: IFFALSE 87680
// exit ;
87678: GO 87709
// for i in tmp do
87680: LD_ADDR_VAR 0 1
87684: PUSH
87685: LD_VAR 0 2
87689: PUSH
87690: FOR_IN
87691: IFFALSE 87707
// begin SetLives ( i , 0 ) ;
87693: LD_VAR 0 1
87697: PPUSH
87698: LD_INT 0
87700: PPUSH
87701: CALL_OW 234
// end ;
87705: GO 87690
87707: POP
87708: POP
// end ;
87709: PPOPN 2
87711: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
87712: LD_EXP 121
87716: PUSH
87717: LD_EXP 124
87721: AND
87722: IFFALSE 87815
87724: GO 87726
87726: DISABLE
87727: LD_INT 0
87729: PPUSH
// begin enable ;
87730: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
87731: LD_ADDR_VAR 0 1
87735: PUSH
87736: LD_INT 22
87738: PUSH
87739: LD_OWVAR 2
87743: PUSH
87744: EMPTY
87745: LIST
87746: LIST
87747: PUSH
87748: LD_INT 2
87750: PUSH
87751: LD_INT 25
87753: PUSH
87754: LD_INT 5
87756: PUSH
87757: EMPTY
87758: LIST
87759: LIST
87760: PUSH
87761: LD_INT 25
87763: PUSH
87764: LD_INT 9
87766: PUSH
87767: EMPTY
87768: LIST
87769: LIST
87770: PUSH
87771: LD_INT 25
87773: PUSH
87774: LD_INT 8
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: PUSH
87781: EMPTY
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: PUSH
87787: EMPTY
87788: LIST
87789: LIST
87790: PPUSH
87791: CALL_OW 69
87795: PUSH
87796: FOR_IN
87797: IFFALSE 87813
// begin SetClass ( i , 1 ) ;
87799: LD_VAR 0 1
87803: PPUSH
87804: LD_INT 1
87806: PPUSH
87807: CALL_OW 336
// end ;
87811: GO 87796
87813: POP
87814: POP
// end ;
87815: PPOPN 1
87817: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
87818: LD_EXP 121
87822: PUSH
87823: LD_EXP 125
87827: AND
87828: PUSH
87829: LD_OWVAR 65
87833: PUSH
87834: LD_INT 7
87836: LESS
87837: AND
87838: IFFALSE 87852
87840: GO 87842
87842: DISABLE
// begin enable ;
87843: ENABLE
// game_speed := 7 ;
87844: LD_ADDR_OWVAR 65
87848: PUSH
87849: LD_INT 7
87851: ST_TO_ADDR
// end ;
87852: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
87853: LD_EXP 121
87857: PUSH
87858: LD_EXP 128
87862: AND
87863: IFFALSE 88065
87865: GO 87867
87867: DISABLE
87868: LD_INT 0
87870: PPUSH
87871: PPUSH
87872: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
87873: LD_ADDR_VAR 0 3
87877: PUSH
87878: LD_INT 81
87880: PUSH
87881: LD_OWVAR 2
87885: PUSH
87886: EMPTY
87887: LIST
87888: LIST
87889: PUSH
87890: LD_INT 21
87892: PUSH
87893: LD_INT 1
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PUSH
87900: EMPTY
87901: LIST
87902: LIST
87903: PPUSH
87904: CALL_OW 69
87908: ST_TO_ADDR
// if not tmp then
87909: LD_VAR 0 3
87913: NOT
87914: IFFALSE 87918
// exit ;
87916: GO 88065
// if tmp > 5 then
87918: LD_VAR 0 3
87922: PUSH
87923: LD_INT 5
87925: GREATER
87926: IFFALSE 87938
// k := 5 else
87928: LD_ADDR_VAR 0 2
87932: PUSH
87933: LD_INT 5
87935: ST_TO_ADDR
87936: GO 87948
// k := tmp ;
87938: LD_ADDR_VAR 0 2
87942: PUSH
87943: LD_VAR 0 3
87947: ST_TO_ADDR
// for i := 1 to k do
87948: LD_ADDR_VAR 0 1
87952: PUSH
87953: DOUBLE
87954: LD_INT 1
87956: DEC
87957: ST_TO_ADDR
87958: LD_VAR 0 2
87962: PUSH
87963: FOR_TO
87964: IFFALSE 88063
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
87966: LD_VAR 0 3
87970: PUSH
87971: LD_VAR 0 1
87975: ARRAY
87976: PPUSH
87977: LD_VAR 0 1
87981: PUSH
87982: LD_INT 4
87984: MOD
87985: PUSH
87986: LD_INT 1
87988: PLUS
87989: PPUSH
87990: CALL_OW 259
87994: PUSH
87995: LD_INT 10
87997: LESS
87998: IFFALSE 88061
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
88000: LD_VAR 0 3
88004: PUSH
88005: LD_VAR 0 1
88009: ARRAY
88010: PPUSH
88011: LD_VAR 0 1
88015: PUSH
88016: LD_INT 4
88018: MOD
88019: PUSH
88020: LD_INT 1
88022: PLUS
88023: PPUSH
88024: LD_VAR 0 3
88028: PUSH
88029: LD_VAR 0 1
88033: ARRAY
88034: PPUSH
88035: LD_VAR 0 1
88039: PUSH
88040: LD_INT 4
88042: MOD
88043: PUSH
88044: LD_INT 1
88046: PLUS
88047: PPUSH
88048: CALL_OW 259
88052: PUSH
88053: LD_INT 1
88055: PLUS
88056: PPUSH
88057: CALL_OW 237
88061: GO 87963
88063: POP
88064: POP
// end ;
88065: PPOPN 3
88067: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
88068: LD_EXP 121
88072: PUSH
88073: LD_EXP 129
88077: AND
88078: IFFALSE 88098
88080: GO 88082
88082: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
88083: LD_INT 4
88085: PPUSH
88086: LD_OWVAR 2
88090: PPUSH
88091: LD_INT 0
88093: PPUSH
88094: CALL_OW 324
88098: END
// every 0 0$1 trigger StreamModeActive and sShovel do
88099: LD_EXP 121
88103: PUSH
88104: LD_EXP 158
88108: AND
88109: IFFALSE 88129
88111: GO 88113
88113: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
88114: LD_INT 19
88116: PPUSH
88117: LD_OWVAR 2
88121: PPUSH
88122: LD_INT 0
88124: PPUSH
88125: CALL_OW 324
88129: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
88130: LD_EXP 121
88134: PUSH
88135: LD_EXP 130
88139: AND
88140: IFFALSE 88242
88142: GO 88144
88144: DISABLE
88145: LD_INT 0
88147: PPUSH
88148: PPUSH
// begin enable ;
88149: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
88150: LD_ADDR_VAR 0 2
88154: PUSH
88155: LD_INT 22
88157: PUSH
88158: LD_OWVAR 2
88162: PUSH
88163: EMPTY
88164: LIST
88165: LIST
88166: PUSH
88167: LD_INT 2
88169: PUSH
88170: LD_INT 34
88172: PUSH
88173: LD_INT 11
88175: PUSH
88176: EMPTY
88177: LIST
88178: LIST
88179: PUSH
88180: LD_INT 34
88182: PUSH
88183: LD_INT 30
88185: PUSH
88186: EMPTY
88187: LIST
88188: LIST
88189: PUSH
88190: EMPTY
88191: LIST
88192: LIST
88193: LIST
88194: PUSH
88195: EMPTY
88196: LIST
88197: LIST
88198: PPUSH
88199: CALL_OW 69
88203: ST_TO_ADDR
// if not tmp then
88204: LD_VAR 0 2
88208: NOT
88209: IFFALSE 88213
// exit ;
88211: GO 88242
// for i in tmp do
88213: LD_ADDR_VAR 0 1
88217: PUSH
88218: LD_VAR 0 2
88222: PUSH
88223: FOR_IN
88224: IFFALSE 88240
// begin SetLives ( i , 0 ) ;
88226: LD_VAR 0 1
88230: PPUSH
88231: LD_INT 0
88233: PPUSH
88234: CALL_OW 234
// end ;
88238: GO 88223
88240: POP
88241: POP
// end ;
88242: PPOPN 2
88244: END
// every 0 0$1 trigger StreamModeActive and sBunker do
88245: LD_EXP 121
88249: PUSH
88250: LD_EXP 131
88254: AND
88255: IFFALSE 88275
88257: GO 88259
88259: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
88260: LD_INT 32
88262: PPUSH
88263: LD_OWVAR 2
88267: PPUSH
88268: LD_INT 0
88270: PPUSH
88271: CALL_OW 324
88275: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
88276: LD_EXP 121
88280: PUSH
88281: LD_EXP 132
88285: AND
88286: IFFALSE 88467
88288: GO 88290
88290: DISABLE
88291: LD_INT 0
88293: PPUSH
88294: PPUSH
88295: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
88296: LD_ADDR_VAR 0 2
88300: PUSH
88301: LD_INT 22
88303: PUSH
88304: LD_OWVAR 2
88308: PUSH
88309: EMPTY
88310: LIST
88311: LIST
88312: PUSH
88313: LD_INT 33
88315: PUSH
88316: LD_INT 3
88318: PUSH
88319: EMPTY
88320: LIST
88321: LIST
88322: PUSH
88323: EMPTY
88324: LIST
88325: LIST
88326: PPUSH
88327: CALL_OW 69
88331: ST_TO_ADDR
// if not tmp then
88332: LD_VAR 0 2
88336: NOT
88337: IFFALSE 88341
// exit ;
88339: GO 88467
// side := 0 ;
88341: LD_ADDR_VAR 0 3
88345: PUSH
88346: LD_INT 0
88348: ST_TO_ADDR
// for i := 1 to 8 do
88349: LD_ADDR_VAR 0 1
88353: PUSH
88354: DOUBLE
88355: LD_INT 1
88357: DEC
88358: ST_TO_ADDR
88359: LD_INT 8
88361: PUSH
88362: FOR_TO
88363: IFFALSE 88411
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
88365: LD_OWVAR 2
88369: PUSH
88370: LD_VAR 0 1
88374: NONEQUAL
88375: PUSH
88376: LD_OWVAR 2
88380: PPUSH
88381: LD_VAR 0 1
88385: PPUSH
88386: CALL_OW 81
88390: PUSH
88391: LD_INT 2
88393: EQUAL
88394: AND
88395: IFFALSE 88409
// begin side := i ;
88397: LD_ADDR_VAR 0 3
88401: PUSH
88402: LD_VAR 0 1
88406: ST_TO_ADDR
// break ;
88407: GO 88411
// end ;
88409: GO 88362
88411: POP
88412: POP
// if not side then
88413: LD_VAR 0 3
88417: NOT
88418: IFFALSE 88422
// exit ;
88420: GO 88467
// for i := 1 to tmp do
88422: LD_ADDR_VAR 0 1
88426: PUSH
88427: DOUBLE
88428: LD_INT 1
88430: DEC
88431: ST_TO_ADDR
88432: LD_VAR 0 2
88436: PUSH
88437: FOR_TO
88438: IFFALSE 88465
// if Prob ( 60 ) then
88440: LD_INT 60
88442: PPUSH
88443: CALL_OW 13
88447: IFFALSE 88463
// SetSide ( i , side ) ;
88449: LD_VAR 0 1
88453: PPUSH
88454: LD_VAR 0 3
88458: PPUSH
88459: CALL_OW 235
88463: GO 88437
88465: POP
88466: POP
// end ;
88467: PPOPN 3
88469: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
88470: LD_EXP 121
88474: PUSH
88475: LD_EXP 134
88479: AND
88480: IFFALSE 88599
88482: GO 88484
88484: DISABLE
88485: LD_INT 0
88487: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
88488: LD_ADDR_VAR 0 1
88492: PUSH
88493: LD_INT 22
88495: PUSH
88496: LD_OWVAR 2
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 21
88507: PUSH
88508: LD_INT 1
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: LD_INT 3
88517: PUSH
88518: LD_INT 23
88520: PUSH
88521: LD_INT 0
88523: PUSH
88524: EMPTY
88525: LIST
88526: LIST
88527: PUSH
88528: EMPTY
88529: LIST
88530: LIST
88531: PUSH
88532: EMPTY
88533: LIST
88534: LIST
88535: LIST
88536: PPUSH
88537: CALL_OW 69
88541: PUSH
88542: FOR_IN
88543: IFFALSE 88597
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
88545: LD_VAR 0 1
88549: PPUSH
88550: CALL_OW 257
88554: PUSH
88555: LD_INT 1
88557: PUSH
88558: LD_INT 2
88560: PUSH
88561: LD_INT 3
88563: PUSH
88564: LD_INT 4
88566: PUSH
88567: EMPTY
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: IN
88573: IFFALSE 88595
// SetClass ( un , rand ( 1 , 4 ) ) ;
88575: LD_VAR 0 1
88579: PPUSH
88580: LD_INT 1
88582: PPUSH
88583: LD_INT 4
88585: PPUSH
88586: CALL_OW 12
88590: PPUSH
88591: CALL_OW 336
88595: GO 88542
88597: POP
88598: POP
// end ;
88599: PPOPN 1
88601: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
88602: LD_EXP 121
88606: PUSH
88607: LD_EXP 133
88611: AND
88612: IFFALSE 88691
88614: GO 88616
88616: DISABLE
88617: LD_INT 0
88619: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88620: LD_ADDR_VAR 0 1
88624: PUSH
88625: LD_INT 22
88627: PUSH
88628: LD_OWVAR 2
88632: PUSH
88633: EMPTY
88634: LIST
88635: LIST
88636: PUSH
88637: LD_INT 21
88639: PUSH
88640: LD_INT 3
88642: PUSH
88643: EMPTY
88644: LIST
88645: LIST
88646: PUSH
88647: EMPTY
88648: LIST
88649: LIST
88650: PPUSH
88651: CALL_OW 69
88655: ST_TO_ADDR
// if not tmp then
88656: LD_VAR 0 1
88660: NOT
88661: IFFALSE 88665
// exit ;
88663: GO 88691
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
88665: LD_VAR 0 1
88669: PUSH
88670: LD_INT 1
88672: PPUSH
88673: LD_VAR 0 1
88677: PPUSH
88678: CALL_OW 12
88682: ARRAY
88683: PPUSH
88684: LD_INT 100
88686: PPUSH
88687: CALL_OW 234
// end ;
88691: PPOPN 1
88693: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
88694: LD_EXP 121
88698: PUSH
88699: LD_EXP 135
88703: AND
88704: IFFALSE 88802
88706: GO 88708
88708: DISABLE
88709: LD_INT 0
88711: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
88712: LD_ADDR_VAR 0 1
88716: PUSH
88717: LD_INT 22
88719: PUSH
88720: LD_OWVAR 2
88724: PUSH
88725: EMPTY
88726: LIST
88727: LIST
88728: PUSH
88729: LD_INT 21
88731: PUSH
88732: LD_INT 1
88734: PUSH
88735: EMPTY
88736: LIST
88737: LIST
88738: PUSH
88739: EMPTY
88740: LIST
88741: LIST
88742: PPUSH
88743: CALL_OW 69
88747: ST_TO_ADDR
// if not tmp then
88748: LD_VAR 0 1
88752: NOT
88753: IFFALSE 88757
// exit ;
88755: GO 88802
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
88757: LD_VAR 0 1
88761: PUSH
88762: LD_INT 1
88764: PPUSH
88765: LD_VAR 0 1
88769: PPUSH
88770: CALL_OW 12
88774: ARRAY
88775: PPUSH
88776: LD_INT 1
88778: PPUSH
88779: LD_INT 4
88781: PPUSH
88782: CALL_OW 12
88786: PPUSH
88787: LD_INT 3000
88789: PPUSH
88790: LD_INT 9000
88792: PPUSH
88793: CALL_OW 12
88797: PPUSH
88798: CALL_OW 492
// end ;
88802: PPOPN 1
88804: END
// every 0 0$1 trigger StreamModeActive and sDepot do
88805: LD_EXP 121
88809: PUSH
88810: LD_EXP 136
88814: AND
88815: IFFALSE 88835
88817: GO 88819
88819: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
88820: LD_INT 1
88822: PPUSH
88823: LD_OWVAR 2
88827: PPUSH
88828: LD_INT 0
88830: PPUSH
88831: CALL_OW 324
88835: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
88836: LD_EXP 121
88840: PUSH
88841: LD_EXP 137
88845: AND
88846: IFFALSE 88929
88848: GO 88850
88850: DISABLE
88851: LD_INT 0
88853: PPUSH
88854: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88855: LD_ADDR_VAR 0 2
88859: PUSH
88860: LD_INT 22
88862: PUSH
88863: LD_OWVAR 2
88867: PUSH
88868: EMPTY
88869: LIST
88870: LIST
88871: PUSH
88872: LD_INT 21
88874: PUSH
88875: LD_INT 3
88877: PUSH
88878: EMPTY
88879: LIST
88880: LIST
88881: PUSH
88882: EMPTY
88883: LIST
88884: LIST
88885: PPUSH
88886: CALL_OW 69
88890: ST_TO_ADDR
// if not tmp then
88891: LD_VAR 0 2
88895: NOT
88896: IFFALSE 88900
// exit ;
88898: GO 88929
// for i in tmp do
88900: LD_ADDR_VAR 0 1
88904: PUSH
88905: LD_VAR 0 2
88909: PUSH
88910: FOR_IN
88911: IFFALSE 88927
// SetBLevel ( i , 10 ) ;
88913: LD_VAR 0 1
88917: PPUSH
88918: LD_INT 10
88920: PPUSH
88921: CALL_OW 241
88925: GO 88910
88927: POP
88928: POP
// end ;
88929: PPOPN 2
88931: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
88932: LD_EXP 121
88936: PUSH
88937: LD_EXP 138
88941: AND
88942: IFFALSE 89053
88944: GO 88946
88946: DISABLE
88947: LD_INT 0
88949: PPUSH
88950: PPUSH
88951: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
88952: LD_ADDR_VAR 0 3
88956: PUSH
88957: LD_INT 22
88959: PUSH
88960: LD_OWVAR 2
88964: PUSH
88965: EMPTY
88966: LIST
88967: LIST
88968: PUSH
88969: LD_INT 25
88971: PUSH
88972: LD_INT 1
88974: PUSH
88975: EMPTY
88976: LIST
88977: LIST
88978: PUSH
88979: EMPTY
88980: LIST
88981: LIST
88982: PPUSH
88983: CALL_OW 69
88987: ST_TO_ADDR
// if not tmp then
88988: LD_VAR 0 3
88992: NOT
88993: IFFALSE 88997
// exit ;
88995: GO 89053
// un := tmp [ rand ( 1 , tmp ) ] ;
88997: LD_ADDR_VAR 0 2
89001: PUSH
89002: LD_VAR 0 3
89006: PUSH
89007: LD_INT 1
89009: PPUSH
89010: LD_VAR 0 3
89014: PPUSH
89015: CALL_OW 12
89019: ARRAY
89020: ST_TO_ADDR
// if Crawls ( un ) then
89021: LD_VAR 0 2
89025: PPUSH
89026: CALL_OW 318
89030: IFFALSE 89041
// ComWalk ( un ) ;
89032: LD_VAR 0 2
89036: PPUSH
89037: CALL_OW 138
// SetClass ( un , class_sniper ) ;
89041: LD_VAR 0 2
89045: PPUSH
89046: LD_INT 5
89048: PPUSH
89049: CALL_OW 336
// end ;
89053: PPOPN 3
89055: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
89056: LD_EXP 121
89060: PUSH
89061: LD_EXP 139
89065: AND
89066: PUSH
89067: LD_OWVAR 67
89071: PUSH
89072: LD_INT 3
89074: LESS
89075: AND
89076: IFFALSE 89095
89078: GO 89080
89080: DISABLE
// Difficulty := Difficulty + 1 ;
89081: LD_ADDR_OWVAR 67
89085: PUSH
89086: LD_OWVAR 67
89090: PUSH
89091: LD_INT 1
89093: PLUS
89094: ST_TO_ADDR
89095: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
89096: LD_EXP 121
89100: PUSH
89101: LD_EXP 140
89105: AND
89106: IFFALSE 89209
89108: GO 89110
89110: DISABLE
89111: LD_INT 0
89113: PPUSH
// begin for i := 1 to 5 do
89114: LD_ADDR_VAR 0 1
89118: PUSH
89119: DOUBLE
89120: LD_INT 1
89122: DEC
89123: ST_TO_ADDR
89124: LD_INT 5
89126: PUSH
89127: FOR_TO
89128: IFFALSE 89207
// begin uc_nation := nation_nature ;
89130: LD_ADDR_OWVAR 21
89134: PUSH
89135: LD_INT 0
89137: ST_TO_ADDR
// uc_side := 0 ;
89138: LD_ADDR_OWVAR 20
89142: PUSH
89143: LD_INT 0
89145: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89146: LD_ADDR_OWVAR 29
89150: PUSH
89151: LD_INT 12
89153: PUSH
89154: LD_INT 12
89156: PUSH
89157: EMPTY
89158: LIST
89159: LIST
89160: ST_TO_ADDR
// hc_agressivity := 20 ;
89161: LD_ADDR_OWVAR 35
89165: PUSH
89166: LD_INT 20
89168: ST_TO_ADDR
// hc_class := class_tiger ;
89169: LD_ADDR_OWVAR 28
89173: PUSH
89174: LD_INT 14
89176: ST_TO_ADDR
// hc_gallery :=  ;
89177: LD_ADDR_OWVAR 33
89181: PUSH
89182: LD_STRING 
89184: ST_TO_ADDR
// hc_name :=  ;
89185: LD_ADDR_OWVAR 26
89189: PUSH
89190: LD_STRING 
89192: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
89193: CALL_OW 44
89197: PPUSH
89198: LD_INT 0
89200: PPUSH
89201: CALL_OW 51
// end ;
89205: GO 89127
89207: POP
89208: POP
// end ;
89209: PPOPN 1
89211: END
// every 0 0$1 trigger StreamModeActive and sBomb do
89212: LD_EXP 121
89216: PUSH
89217: LD_EXP 141
89221: AND
89222: IFFALSE 89231
89224: GO 89226
89226: DISABLE
// StreamSibBomb ;
89227: CALL 89232 0 0
89231: END
// export function StreamSibBomb ; var i , x , y ; begin
89232: LD_INT 0
89234: PPUSH
89235: PPUSH
89236: PPUSH
89237: PPUSH
// result := false ;
89238: LD_ADDR_VAR 0 1
89242: PUSH
89243: LD_INT 0
89245: ST_TO_ADDR
// for i := 1 to 16 do
89246: LD_ADDR_VAR 0 2
89250: PUSH
89251: DOUBLE
89252: LD_INT 1
89254: DEC
89255: ST_TO_ADDR
89256: LD_INT 16
89258: PUSH
89259: FOR_TO
89260: IFFALSE 89459
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89262: LD_ADDR_VAR 0 3
89266: PUSH
89267: LD_INT 10
89269: PUSH
89270: LD_INT 20
89272: PUSH
89273: LD_INT 30
89275: PUSH
89276: LD_INT 40
89278: PUSH
89279: LD_INT 50
89281: PUSH
89282: LD_INT 60
89284: PUSH
89285: LD_INT 70
89287: PUSH
89288: LD_INT 80
89290: PUSH
89291: LD_INT 90
89293: PUSH
89294: LD_INT 100
89296: PUSH
89297: LD_INT 110
89299: PUSH
89300: LD_INT 120
89302: PUSH
89303: LD_INT 130
89305: PUSH
89306: LD_INT 140
89308: PUSH
89309: LD_INT 150
89311: PUSH
89312: EMPTY
89313: LIST
89314: LIST
89315: LIST
89316: LIST
89317: LIST
89318: LIST
89319: LIST
89320: LIST
89321: LIST
89322: LIST
89323: LIST
89324: LIST
89325: LIST
89326: LIST
89327: LIST
89328: PUSH
89329: LD_INT 1
89331: PPUSH
89332: LD_INT 15
89334: PPUSH
89335: CALL_OW 12
89339: ARRAY
89340: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
89341: LD_ADDR_VAR 0 4
89345: PUSH
89346: LD_INT 10
89348: PUSH
89349: LD_INT 20
89351: PUSH
89352: LD_INT 30
89354: PUSH
89355: LD_INT 40
89357: PUSH
89358: LD_INT 50
89360: PUSH
89361: LD_INT 60
89363: PUSH
89364: LD_INT 70
89366: PUSH
89367: LD_INT 80
89369: PUSH
89370: LD_INT 90
89372: PUSH
89373: LD_INT 100
89375: PUSH
89376: LD_INT 110
89378: PUSH
89379: LD_INT 120
89381: PUSH
89382: LD_INT 130
89384: PUSH
89385: LD_INT 140
89387: PUSH
89388: LD_INT 150
89390: PUSH
89391: EMPTY
89392: LIST
89393: LIST
89394: LIST
89395: LIST
89396: LIST
89397: LIST
89398: LIST
89399: LIST
89400: LIST
89401: LIST
89402: LIST
89403: LIST
89404: LIST
89405: LIST
89406: LIST
89407: PUSH
89408: LD_INT 1
89410: PPUSH
89411: LD_INT 15
89413: PPUSH
89414: CALL_OW 12
89418: ARRAY
89419: ST_TO_ADDR
// if ValidHex ( x , y ) then
89420: LD_VAR 0 3
89424: PPUSH
89425: LD_VAR 0 4
89429: PPUSH
89430: CALL_OW 488
89434: IFFALSE 89457
// begin result := [ x , y ] ;
89436: LD_ADDR_VAR 0 1
89440: PUSH
89441: LD_VAR 0 3
89445: PUSH
89446: LD_VAR 0 4
89450: PUSH
89451: EMPTY
89452: LIST
89453: LIST
89454: ST_TO_ADDR
// break ;
89455: GO 89459
// end ; end ;
89457: GO 89259
89459: POP
89460: POP
// if result then
89461: LD_VAR 0 1
89465: IFFALSE 89525
// begin ToLua ( playSibBomb() ) ;
89467: LD_STRING playSibBomb()
89469: PPUSH
89470: CALL_OW 559
// wait ( 0 0$14 ) ;
89474: LD_INT 490
89476: PPUSH
89477: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
89481: LD_VAR 0 1
89485: PUSH
89486: LD_INT 1
89488: ARRAY
89489: PPUSH
89490: LD_VAR 0 1
89494: PUSH
89495: LD_INT 2
89497: ARRAY
89498: PPUSH
89499: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
89503: LD_VAR 0 1
89507: PUSH
89508: LD_INT 1
89510: ARRAY
89511: PPUSH
89512: LD_VAR 0 1
89516: PUSH
89517: LD_INT 2
89519: ARRAY
89520: PPUSH
89521: CALL_OW 429
// end ; end ;
89525: LD_VAR 0 1
89529: RET
// every 0 0$1 trigger StreamModeActive and sReset do
89530: LD_EXP 121
89534: PUSH
89535: LD_EXP 143
89539: AND
89540: IFFALSE 89552
89542: GO 89544
89544: DISABLE
// YouLost (  ) ;
89545: LD_STRING 
89547: PPUSH
89548: CALL_OW 104
89552: END
// every 0 0$1 trigger StreamModeActive and sFog do
89553: LD_EXP 121
89557: PUSH
89558: LD_EXP 142
89562: AND
89563: IFFALSE 89577
89565: GO 89567
89567: DISABLE
// FogOff ( your_side ) ;
89568: LD_OWVAR 2
89572: PPUSH
89573: CALL_OW 344
89577: END
// every 0 0$1 trigger StreamModeActive and sSun do
89578: LD_EXP 121
89582: PUSH
89583: LD_EXP 144
89587: AND
89588: IFFALSE 89616
89590: GO 89592
89592: DISABLE
// begin solar_recharge_percent := 0 ;
89593: LD_ADDR_OWVAR 79
89597: PUSH
89598: LD_INT 0
89600: ST_TO_ADDR
// wait ( 5 5$00 ) ;
89601: LD_INT 10500
89603: PPUSH
89604: CALL_OW 67
// solar_recharge_percent := 100 ;
89608: LD_ADDR_OWVAR 79
89612: PUSH
89613: LD_INT 100
89615: ST_TO_ADDR
// end ;
89616: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
89617: LD_EXP 121
89621: PUSH
89622: LD_EXP 145
89626: AND
89627: IFFALSE 89866
89629: GO 89631
89631: DISABLE
89632: LD_INT 0
89634: PPUSH
89635: PPUSH
89636: PPUSH
// begin tmp := [ ] ;
89637: LD_ADDR_VAR 0 3
89641: PUSH
89642: EMPTY
89643: ST_TO_ADDR
// for i := 1 to 6 do
89644: LD_ADDR_VAR 0 1
89648: PUSH
89649: DOUBLE
89650: LD_INT 1
89652: DEC
89653: ST_TO_ADDR
89654: LD_INT 6
89656: PUSH
89657: FOR_TO
89658: IFFALSE 89763
// begin uc_nation := nation_nature ;
89660: LD_ADDR_OWVAR 21
89664: PUSH
89665: LD_INT 0
89667: ST_TO_ADDR
// uc_side := 0 ;
89668: LD_ADDR_OWVAR 20
89672: PUSH
89673: LD_INT 0
89675: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
89676: LD_ADDR_OWVAR 29
89680: PUSH
89681: LD_INT 12
89683: PUSH
89684: LD_INT 12
89686: PUSH
89687: EMPTY
89688: LIST
89689: LIST
89690: ST_TO_ADDR
// hc_agressivity := 20 ;
89691: LD_ADDR_OWVAR 35
89695: PUSH
89696: LD_INT 20
89698: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
89699: LD_ADDR_OWVAR 28
89703: PUSH
89704: LD_INT 17
89706: ST_TO_ADDR
// hc_gallery :=  ;
89707: LD_ADDR_OWVAR 33
89711: PUSH
89712: LD_STRING 
89714: ST_TO_ADDR
// hc_name :=  ;
89715: LD_ADDR_OWVAR 26
89719: PUSH
89720: LD_STRING 
89722: ST_TO_ADDR
// un := CreateHuman ;
89723: LD_ADDR_VAR 0 2
89727: PUSH
89728: CALL_OW 44
89732: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
89733: LD_VAR 0 2
89737: PPUSH
89738: LD_INT 1
89740: PPUSH
89741: CALL_OW 51
// tmp := tmp ^ un ;
89745: LD_ADDR_VAR 0 3
89749: PUSH
89750: LD_VAR 0 3
89754: PUSH
89755: LD_VAR 0 2
89759: ADD
89760: ST_TO_ADDR
// end ;
89761: GO 89657
89763: POP
89764: POP
// repeat wait ( 0 0$1 ) ;
89765: LD_INT 35
89767: PPUSH
89768: CALL_OW 67
// for un in tmp do
89772: LD_ADDR_VAR 0 2
89776: PUSH
89777: LD_VAR 0 3
89781: PUSH
89782: FOR_IN
89783: IFFALSE 89857
// begin if IsDead ( un ) then
89785: LD_VAR 0 2
89789: PPUSH
89790: CALL_OW 301
89794: IFFALSE 89814
// begin tmp := tmp diff un ;
89796: LD_ADDR_VAR 0 3
89800: PUSH
89801: LD_VAR 0 3
89805: PUSH
89806: LD_VAR 0 2
89810: DIFF
89811: ST_TO_ADDR
// continue ;
89812: GO 89782
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
89814: LD_VAR 0 2
89818: PPUSH
89819: LD_INT 3
89821: PUSH
89822: LD_INT 22
89824: PUSH
89825: LD_INT 0
89827: PUSH
89828: EMPTY
89829: LIST
89830: LIST
89831: PUSH
89832: EMPTY
89833: LIST
89834: LIST
89835: PPUSH
89836: CALL_OW 69
89840: PPUSH
89841: LD_VAR 0 2
89845: PPUSH
89846: CALL_OW 74
89850: PPUSH
89851: CALL_OW 115
// end ;
89855: GO 89782
89857: POP
89858: POP
// until not tmp ;
89859: LD_VAR 0 3
89863: NOT
89864: IFFALSE 89765
// end ;
89866: PPOPN 3
89868: END
// every 0 0$1 trigger StreamModeActive and sTroll do
89869: LD_EXP 121
89873: PUSH
89874: LD_EXP 146
89878: AND
89879: IFFALSE 89933
89881: GO 89883
89883: DISABLE
// begin ToLua ( displayTroll(); ) ;
89884: LD_STRING displayTroll();
89886: PPUSH
89887: CALL_OW 559
// wait ( 3 3$00 ) ;
89891: LD_INT 6300
89893: PPUSH
89894: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89898: LD_STRING hideTroll();
89900: PPUSH
89901: CALL_OW 559
// wait ( 1 1$00 ) ;
89905: LD_INT 2100
89907: PPUSH
89908: CALL_OW 67
// ToLua ( displayTroll(); ) ;
89912: LD_STRING displayTroll();
89914: PPUSH
89915: CALL_OW 559
// wait ( 1 1$00 ) ;
89919: LD_INT 2100
89921: PPUSH
89922: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89926: LD_STRING hideTroll();
89928: PPUSH
89929: CALL_OW 559
// end ;
89933: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
89934: LD_EXP 121
89938: PUSH
89939: LD_EXP 147
89943: AND
89944: IFFALSE 90007
89946: GO 89948
89948: DISABLE
89949: LD_INT 0
89951: PPUSH
// begin p := 0 ;
89952: LD_ADDR_VAR 0 1
89956: PUSH
89957: LD_INT 0
89959: ST_TO_ADDR
// repeat game_speed := 1 ;
89960: LD_ADDR_OWVAR 65
89964: PUSH
89965: LD_INT 1
89967: ST_TO_ADDR
// wait ( 0 0$1 ) ;
89968: LD_INT 35
89970: PPUSH
89971: CALL_OW 67
// p := p + 1 ;
89975: LD_ADDR_VAR 0 1
89979: PUSH
89980: LD_VAR 0 1
89984: PUSH
89985: LD_INT 1
89987: PLUS
89988: ST_TO_ADDR
// until p >= 60 ;
89989: LD_VAR 0 1
89993: PUSH
89994: LD_INT 60
89996: GREATEREQUAL
89997: IFFALSE 89960
// game_speed := 4 ;
89999: LD_ADDR_OWVAR 65
90003: PUSH
90004: LD_INT 4
90006: ST_TO_ADDR
// end ;
90007: PPOPN 1
90009: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
90010: LD_EXP 121
90014: PUSH
90015: LD_EXP 148
90019: AND
90020: IFFALSE 90166
90022: GO 90024
90024: DISABLE
90025: LD_INT 0
90027: PPUSH
90028: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90029: LD_ADDR_VAR 0 1
90033: PUSH
90034: LD_INT 22
90036: PUSH
90037: LD_OWVAR 2
90041: PUSH
90042: EMPTY
90043: LIST
90044: LIST
90045: PUSH
90046: LD_INT 2
90048: PUSH
90049: LD_INT 30
90051: PUSH
90052: LD_INT 0
90054: PUSH
90055: EMPTY
90056: LIST
90057: LIST
90058: PUSH
90059: LD_INT 30
90061: PUSH
90062: LD_INT 1
90064: PUSH
90065: EMPTY
90066: LIST
90067: LIST
90068: PUSH
90069: EMPTY
90070: LIST
90071: LIST
90072: LIST
90073: PUSH
90074: EMPTY
90075: LIST
90076: LIST
90077: PPUSH
90078: CALL_OW 69
90082: ST_TO_ADDR
// if not depot then
90083: LD_VAR 0 1
90087: NOT
90088: IFFALSE 90092
// exit ;
90090: GO 90166
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
90092: LD_ADDR_VAR 0 2
90096: PUSH
90097: LD_VAR 0 1
90101: PUSH
90102: LD_INT 1
90104: PPUSH
90105: LD_VAR 0 1
90109: PPUSH
90110: CALL_OW 12
90114: ARRAY
90115: PPUSH
90116: CALL_OW 274
90120: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
90121: LD_VAR 0 2
90125: PPUSH
90126: LD_INT 1
90128: PPUSH
90129: LD_INT 0
90131: PPUSH
90132: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
90136: LD_VAR 0 2
90140: PPUSH
90141: LD_INT 2
90143: PPUSH
90144: LD_INT 0
90146: PPUSH
90147: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
90151: LD_VAR 0 2
90155: PPUSH
90156: LD_INT 3
90158: PPUSH
90159: LD_INT 0
90161: PPUSH
90162: CALL_OW 277
// end ;
90166: PPOPN 2
90168: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
90169: LD_EXP 121
90173: PUSH
90174: LD_EXP 149
90178: AND
90179: IFFALSE 90276
90181: GO 90183
90183: DISABLE
90184: LD_INT 0
90186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90187: LD_ADDR_VAR 0 1
90191: PUSH
90192: LD_INT 22
90194: PUSH
90195: LD_OWVAR 2
90199: PUSH
90200: EMPTY
90201: LIST
90202: LIST
90203: PUSH
90204: LD_INT 21
90206: PUSH
90207: LD_INT 1
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: PUSH
90214: LD_INT 3
90216: PUSH
90217: LD_INT 23
90219: PUSH
90220: LD_INT 0
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: PUSH
90227: EMPTY
90228: LIST
90229: LIST
90230: PUSH
90231: EMPTY
90232: LIST
90233: LIST
90234: LIST
90235: PPUSH
90236: CALL_OW 69
90240: ST_TO_ADDR
// if not tmp then
90241: LD_VAR 0 1
90245: NOT
90246: IFFALSE 90250
// exit ;
90248: GO 90276
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
90250: LD_VAR 0 1
90254: PUSH
90255: LD_INT 1
90257: PPUSH
90258: LD_VAR 0 1
90262: PPUSH
90263: CALL_OW 12
90267: ARRAY
90268: PPUSH
90269: LD_INT 200
90271: PPUSH
90272: CALL_OW 234
// end ;
90276: PPOPN 1
90278: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
90279: LD_EXP 121
90283: PUSH
90284: LD_EXP 150
90288: AND
90289: IFFALSE 90368
90291: GO 90293
90293: DISABLE
90294: LD_INT 0
90296: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
90297: LD_ADDR_VAR 0 1
90301: PUSH
90302: LD_INT 22
90304: PUSH
90305: LD_OWVAR 2
90309: PUSH
90310: EMPTY
90311: LIST
90312: LIST
90313: PUSH
90314: LD_INT 21
90316: PUSH
90317: LD_INT 2
90319: PUSH
90320: EMPTY
90321: LIST
90322: LIST
90323: PUSH
90324: EMPTY
90325: LIST
90326: LIST
90327: PPUSH
90328: CALL_OW 69
90332: ST_TO_ADDR
// if not tmp then
90333: LD_VAR 0 1
90337: NOT
90338: IFFALSE 90342
// exit ;
90340: GO 90368
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
90342: LD_VAR 0 1
90346: PUSH
90347: LD_INT 1
90349: PPUSH
90350: LD_VAR 0 1
90354: PPUSH
90355: CALL_OW 12
90359: ARRAY
90360: PPUSH
90361: LD_INT 60
90363: PPUSH
90364: CALL_OW 234
// end ;
90368: PPOPN 1
90370: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
90371: LD_EXP 121
90375: PUSH
90376: LD_EXP 151
90380: AND
90381: IFFALSE 90480
90383: GO 90385
90385: DISABLE
90386: LD_INT 0
90388: PPUSH
90389: PPUSH
// begin enable ;
90390: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
90391: LD_ADDR_VAR 0 1
90395: PUSH
90396: LD_INT 22
90398: PUSH
90399: LD_OWVAR 2
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 61
90410: PUSH
90411: EMPTY
90412: LIST
90413: PUSH
90414: LD_INT 33
90416: PUSH
90417: LD_INT 2
90419: PUSH
90420: EMPTY
90421: LIST
90422: LIST
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: LIST
90428: PPUSH
90429: CALL_OW 69
90433: ST_TO_ADDR
// if not tmp then
90434: LD_VAR 0 1
90438: NOT
90439: IFFALSE 90443
// exit ;
90441: GO 90480
// for i in tmp do
90443: LD_ADDR_VAR 0 2
90447: PUSH
90448: LD_VAR 0 1
90452: PUSH
90453: FOR_IN
90454: IFFALSE 90478
// if IsControledBy ( i ) then
90456: LD_VAR 0 2
90460: PPUSH
90461: CALL_OW 312
90465: IFFALSE 90476
// ComUnlink ( i ) ;
90467: LD_VAR 0 2
90471: PPUSH
90472: CALL_OW 136
90476: GO 90453
90478: POP
90479: POP
// end ;
90480: PPOPN 2
90482: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
90483: LD_EXP 121
90487: PUSH
90488: LD_EXP 152
90492: AND
90493: IFFALSE 90633
90495: GO 90497
90497: DISABLE
90498: LD_INT 0
90500: PPUSH
90501: PPUSH
// begin ToLua ( displayPowell(); ) ;
90502: LD_STRING displayPowell();
90504: PPUSH
90505: CALL_OW 559
// uc_side := 0 ;
90509: LD_ADDR_OWVAR 20
90513: PUSH
90514: LD_INT 0
90516: ST_TO_ADDR
// uc_nation := 2 ;
90517: LD_ADDR_OWVAR 21
90521: PUSH
90522: LD_INT 2
90524: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
90525: LD_ADDR_OWVAR 37
90529: PUSH
90530: LD_INT 14
90532: ST_TO_ADDR
// vc_engine := engine_siberite ;
90533: LD_ADDR_OWVAR 39
90537: PUSH
90538: LD_INT 3
90540: ST_TO_ADDR
// vc_control := control_apeman ;
90541: LD_ADDR_OWVAR 38
90545: PUSH
90546: LD_INT 5
90548: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
90549: LD_ADDR_OWVAR 40
90553: PUSH
90554: LD_INT 29
90556: ST_TO_ADDR
// un := CreateVehicle ;
90557: LD_ADDR_VAR 0 2
90561: PUSH
90562: CALL_OW 45
90566: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90567: LD_VAR 0 2
90571: PPUSH
90572: LD_INT 1
90574: PPUSH
90575: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90579: LD_INT 35
90581: PPUSH
90582: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90586: LD_VAR 0 2
90590: PPUSH
90591: LD_INT 22
90593: PUSH
90594: LD_OWVAR 2
90598: PUSH
90599: EMPTY
90600: LIST
90601: LIST
90602: PPUSH
90603: CALL_OW 69
90607: PPUSH
90608: LD_VAR 0 2
90612: PPUSH
90613: CALL_OW 74
90617: PPUSH
90618: CALL_OW 115
// until IsDead ( un ) ;
90622: LD_VAR 0 2
90626: PPUSH
90627: CALL_OW 301
90631: IFFALSE 90579
// end ;
90633: PPOPN 2
90635: END
// every 0 0$1 trigger StreamModeActive and sStu do
90636: LD_EXP 121
90640: PUSH
90641: LD_EXP 160
90645: AND
90646: IFFALSE 90662
90648: GO 90650
90650: DISABLE
// begin ToLua ( displayStucuk(); ) ;
90651: LD_STRING displayStucuk();
90653: PPUSH
90654: CALL_OW 559
// ResetFog ;
90658: CALL_OW 335
// end ;
90662: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
90663: LD_EXP 121
90667: PUSH
90668: LD_EXP 153
90672: AND
90673: IFFALSE 90814
90675: GO 90677
90677: DISABLE
90678: LD_INT 0
90680: PPUSH
90681: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90682: LD_ADDR_VAR 0 2
90686: PUSH
90687: LD_INT 22
90689: PUSH
90690: LD_OWVAR 2
90694: PUSH
90695: EMPTY
90696: LIST
90697: LIST
90698: PUSH
90699: LD_INT 21
90701: PUSH
90702: LD_INT 1
90704: PUSH
90705: EMPTY
90706: LIST
90707: LIST
90708: PUSH
90709: EMPTY
90710: LIST
90711: LIST
90712: PPUSH
90713: CALL_OW 69
90717: ST_TO_ADDR
// if not tmp then
90718: LD_VAR 0 2
90722: NOT
90723: IFFALSE 90727
// exit ;
90725: GO 90814
// un := tmp [ rand ( 1 , tmp ) ] ;
90727: LD_ADDR_VAR 0 1
90731: PUSH
90732: LD_VAR 0 2
90736: PUSH
90737: LD_INT 1
90739: PPUSH
90740: LD_VAR 0 2
90744: PPUSH
90745: CALL_OW 12
90749: ARRAY
90750: ST_TO_ADDR
// SetSide ( un , 0 ) ;
90751: LD_VAR 0 1
90755: PPUSH
90756: LD_INT 0
90758: PPUSH
90759: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
90763: LD_VAR 0 1
90767: PPUSH
90768: LD_OWVAR 3
90772: PUSH
90773: LD_VAR 0 1
90777: DIFF
90778: PPUSH
90779: LD_VAR 0 1
90783: PPUSH
90784: CALL_OW 74
90788: PPUSH
90789: CALL_OW 115
// wait ( 0 0$20 ) ;
90793: LD_INT 700
90795: PPUSH
90796: CALL_OW 67
// SetSide ( un , your_side ) ;
90800: LD_VAR 0 1
90804: PPUSH
90805: LD_OWVAR 2
90809: PPUSH
90810: CALL_OW 235
// end ;
90814: PPOPN 2
90816: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
90817: LD_EXP 121
90821: PUSH
90822: LD_EXP 154
90826: AND
90827: IFFALSE 90933
90829: GO 90831
90831: DISABLE
90832: LD_INT 0
90834: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
90835: LD_ADDR_VAR 0 1
90839: PUSH
90840: LD_INT 22
90842: PUSH
90843: LD_OWVAR 2
90847: PUSH
90848: EMPTY
90849: LIST
90850: LIST
90851: PUSH
90852: LD_INT 2
90854: PUSH
90855: LD_INT 30
90857: PUSH
90858: LD_INT 0
90860: PUSH
90861: EMPTY
90862: LIST
90863: LIST
90864: PUSH
90865: LD_INT 30
90867: PUSH
90868: LD_INT 1
90870: PUSH
90871: EMPTY
90872: LIST
90873: LIST
90874: PUSH
90875: EMPTY
90876: LIST
90877: LIST
90878: LIST
90879: PUSH
90880: EMPTY
90881: LIST
90882: LIST
90883: PPUSH
90884: CALL_OW 69
90888: ST_TO_ADDR
// if not depot then
90889: LD_VAR 0 1
90893: NOT
90894: IFFALSE 90898
// exit ;
90896: GO 90933
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
90898: LD_VAR 0 1
90902: PUSH
90903: LD_INT 1
90905: ARRAY
90906: PPUSH
90907: CALL_OW 250
90911: PPUSH
90912: LD_VAR 0 1
90916: PUSH
90917: LD_INT 1
90919: ARRAY
90920: PPUSH
90921: CALL_OW 251
90925: PPUSH
90926: LD_INT 70
90928: PPUSH
90929: CALL_OW 495
// end ;
90933: PPOPN 1
90935: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
90936: LD_EXP 121
90940: PUSH
90941: LD_EXP 155
90945: AND
90946: IFFALSE 91157
90948: GO 90950
90950: DISABLE
90951: LD_INT 0
90953: PPUSH
90954: PPUSH
90955: PPUSH
90956: PPUSH
90957: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90958: LD_ADDR_VAR 0 5
90962: PUSH
90963: LD_INT 22
90965: PUSH
90966: LD_OWVAR 2
90970: PUSH
90971: EMPTY
90972: LIST
90973: LIST
90974: PUSH
90975: LD_INT 21
90977: PUSH
90978: LD_INT 1
90980: PUSH
90981: EMPTY
90982: LIST
90983: LIST
90984: PUSH
90985: EMPTY
90986: LIST
90987: LIST
90988: PPUSH
90989: CALL_OW 69
90993: ST_TO_ADDR
// if not tmp then
90994: LD_VAR 0 5
90998: NOT
90999: IFFALSE 91003
// exit ;
91001: GO 91157
// for i in tmp do
91003: LD_ADDR_VAR 0 1
91007: PUSH
91008: LD_VAR 0 5
91012: PUSH
91013: FOR_IN
91014: IFFALSE 91155
// begin d := rand ( 0 , 5 ) ;
91016: LD_ADDR_VAR 0 4
91020: PUSH
91021: LD_INT 0
91023: PPUSH
91024: LD_INT 5
91026: PPUSH
91027: CALL_OW 12
91031: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
91032: LD_ADDR_VAR 0 2
91036: PUSH
91037: LD_VAR 0 1
91041: PPUSH
91042: CALL_OW 250
91046: PPUSH
91047: LD_VAR 0 4
91051: PPUSH
91052: LD_INT 3
91054: PPUSH
91055: LD_INT 12
91057: PPUSH
91058: CALL_OW 12
91062: PPUSH
91063: CALL_OW 272
91067: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
91068: LD_ADDR_VAR 0 3
91072: PUSH
91073: LD_VAR 0 1
91077: PPUSH
91078: CALL_OW 251
91082: PPUSH
91083: LD_VAR 0 4
91087: PPUSH
91088: LD_INT 3
91090: PPUSH
91091: LD_INT 12
91093: PPUSH
91094: CALL_OW 12
91098: PPUSH
91099: CALL_OW 273
91103: ST_TO_ADDR
// if ValidHex ( x , y ) then
91104: LD_VAR 0 2
91108: PPUSH
91109: LD_VAR 0 3
91113: PPUSH
91114: CALL_OW 488
91118: IFFALSE 91153
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
91120: LD_VAR 0 1
91124: PPUSH
91125: LD_VAR 0 2
91129: PPUSH
91130: LD_VAR 0 3
91134: PPUSH
91135: LD_INT 3
91137: PPUSH
91138: LD_INT 6
91140: PPUSH
91141: CALL_OW 12
91145: PPUSH
91146: LD_INT 1
91148: PPUSH
91149: CALL_OW 483
// end ;
91153: GO 91013
91155: POP
91156: POP
// end ;
91157: PPOPN 5
91159: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
91160: LD_EXP 121
91164: PUSH
91165: LD_EXP 156
91169: AND
91170: IFFALSE 91264
91172: GO 91174
91174: DISABLE
91175: LD_INT 0
91177: PPUSH
91178: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
91179: LD_ADDR_VAR 0 2
91183: PUSH
91184: LD_INT 22
91186: PUSH
91187: LD_OWVAR 2
91191: PUSH
91192: EMPTY
91193: LIST
91194: LIST
91195: PUSH
91196: LD_INT 32
91198: PUSH
91199: LD_INT 1
91201: PUSH
91202: EMPTY
91203: LIST
91204: LIST
91205: PUSH
91206: LD_INT 21
91208: PUSH
91209: LD_INT 2
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: PUSH
91216: EMPTY
91217: LIST
91218: LIST
91219: LIST
91220: PPUSH
91221: CALL_OW 69
91225: ST_TO_ADDR
// if not tmp then
91226: LD_VAR 0 2
91230: NOT
91231: IFFALSE 91235
// exit ;
91233: GO 91264
// for i in tmp do
91235: LD_ADDR_VAR 0 1
91239: PUSH
91240: LD_VAR 0 2
91244: PUSH
91245: FOR_IN
91246: IFFALSE 91262
// SetFuel ( i , 0 ) ;
91248: LD_VAR 0 1
91252: PPUSH
91253: LD_INT 0
91255: PPUSH
91256: CALL_OW 240
91260: GO 91245
91262: POP
91263: POP
// end ;
91264: PPOPN 2
91266: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
91267: LD_EXP 121
91271: PUSH
91272: LD_EXP 157
91276: AND
91277: IFFALSE 91343
91279: GO 91281
91281: DISABLE
91282: LD_INT 0
91284: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91285: LD_ADDR_VAR 0 1
91289: PUSH
91290: LD_INT 22
91292: PUSH
91293: LD_OWVAR 2
91297: PUSH
91298: EMPTY
91299: LIST
91300: LIST
91301: PUSH
91302: LD_INT 30
91304: PUSH
91305: LD_INT 29
91307: PUSH
91308: EMPTY
91309: LIST
91310: LIST
91311: PUSH
91312: EMPTY
91313: LIST
91314: LIST
91315: PPUSH
91316: CALL_OW 69
91320: ST_TO_ADDR
// if not tmp then
91321: LD_VAR 0 1
91325: NOT
91326: IFFALSE 91330
// exit ;
91328: GO 91343
// DestroyUnit ( tmp [ 1 ] ) ;
91330: LD_VAR 0 1
91334: PUSH
91335: LD_INT 1
91337: ARRAY
91338: PPUSH
91339: CALL_OW 65
// end ;
91343: PPOPN 1
91345: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
91346: LD_EXP 121
91350: PUSH
91351: LD_EXP 159
91355: AND
91356: IFFALSE 91485
91358: GO 91360
91360: DISABLE
91361: LD_INT 0
91363: PPUSH
// begin uc_side := 0 ;
91364: LD_ADDR_OWVAR 20
91368: PUSH
91369: LD_INT 0
91371: ST_TO_ADDR
// uc_nation := nation_arabian ;
91372: LD_ADDR_OWVAR 21
91376: PUSH
91377: LD_INT 2
91379: ST_TO_ADDR
// hc_gallery :=  ;
91380: LD_ADDR_OWVAR 33
91384: PUSH
91385: LD_STRING 
91387: ST_TO_ADDR
// hc_name :=  ;
91388: LD_ADDR_OWVAR 26
91392: PUSH
91393: LD_STRING 
91395: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
91396: LD_INT 1
91398: PPUSH
91399: LD_INT 11
91401: PPUSH
91402: LD_INT 10
91404: PPUSH
91405: CALL_OW 380
// un := CreateHuman ;
91409: LD_ADDR_VAR 0 1
91413: PUSH
91414: CALL_OW 44
91418: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91419: LD_VAR 0 1
91423: PPUSH
91424: LD_INT 1
91426: PPUSH
91427: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
91431: LD_INT 35
91433: PPUSH
91434: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
91438: LD_VAR 0 1
91442: PPUSH
91443: LD_INT 22
91445: PUSH
91446: LD_OWVAR 2
91450: PUSH
91451: EMPTY
91452: LIST
91453: LIST
91454: PPUSH
91455: CALL_OW 69
91459: PPUSH
91460: LD_VAR 0 1
91464: PPUSH
91465: CALL_OW 74
91469: PPUSH
91470: CALL_OW 115
// until IsDead ( un ) ;
91474: LD_VAR 0 1
91478: PPUSH
91479: CALL_OW 301
91483: IFFALSE 91431
// end ;
91485: PPOPN 1
91487: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
91488: LD_EXP 121
91492: PUSH
91493: LD_EXP 161
91497: AND
91498: IFFALSE 91510
91500: GO 91502
91502: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
91503: LD_STRING earthquake(getX(game), 0, 32)
91505: PPUSH
91506: CALL_OW 559
91510: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
91511: LD_EXP 121
91515: PUSH
91516: LD_EXP 162
91520: AND
91521: IFFALSE 91612
91523: GO 91525
91525: DISABLE
91526: LD_INT 0
91528: PPUSH
// begin enable ;
91529: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
91530: LD_ADDR_VAR 0 1
91534: PUSH
91535: LD_INT 22
91537: PUSH
91538: LD_OWVAR 2
91542: PUSH
91543: EMPTY
91544: LIST
91545: LIST
91546: PUSH
91547: LD_INT 21
91549: PUSH
91550: LD_INT 2
91552: PUSH
91553: EMPTY
91554: LIST
91555: LIST
91556: PUSH
91557: LD_INT 33
91559: PUSH
91560: LD_INT 3
91562: PUSH
91563: EMPTY
91564: LIST
91565: LIST
91566: PUSH
91567: EMPTY
91568: LIST
91569: LIST
91570: LIST
91571: PPUSH
91572: CALL_OW 69
91576: ST_TO_ADDR
// if not tmp then
91577: LD_VAR 0 1
91581: NOT
91582: IFFALSE 91586
// exit ;
91584: GO 91612
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91586: LD_VAR 0 1
91590: PUSH
91591: LD_INT 1
91593: PPUSH
91594: LD_VAR 0 1
91598: PPUSH
91599: CALL_OW 12
91603: ARRAY
91604: PPUSH
91605: LD_INT 1
91607: PPUSH
91608: CALL_OW 234
// end ;
91612: PPOPN 1
91614: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
91615: LD_EXP 121
91619: PUSH
91620: LD_EXP 163
91624: AND
91625: IFFALSE 91766
91627: GO 91629
91629: DISABLE
91630: LD_INT 0
91632: PPUSH
91633: PPUSH
91634: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91635: LD_ADDR_VAR 0 3
91639: PUSH
91640: LD_INT 22
91642: PUSH
91643: LD_OWVAR 2
91647: PUSH
91648: EMPTY
91649: LIST
91650: LIST
91651: PUSH
91652: LD_INT 25
91654: PUSH
91655: LD_INT 1
91657: PUSH
91658: EMPTY
91659: LIST
91660: LIST
91661: PUSH
91662: EMPTY
91663: LIST
91664: LIST
91665: PPUSH
91666: CALL_OW 69
91670: ST_TO_ADDR
// if not tmp then
91671: LD_VAR 0 3
91675: NOT
91676: IFFALSE 91680
// exit ;
91678: GO 91766
// un := tmp [ rand ( 1 , tmp ) ] ;
91680: LD_ADDR_VAR 0 2
91684: PUSH
91685: LD_VAR 0 3
91689: PUSH
91690: LD_INT 1
91692: PPUSH
91693: LD_VAR 0 3
91697: PPUSH
91698: CALL_OW 12
91702: ARRAY
91703: ST_TO_ADDR
// if Crawls ( un ) then
91704: LD_VAR 0 2
91708: PPUSH
91709: CALL_OW 318
91713: IFFALSE 91724
// ComWalk ( un ) ;
91715: LD_VAR 0 2
91719: PPUSH
91720: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
91724: LD_VAR 0 2
91728: PPUSH
91729: LD_INT 9
91731: PPUSH
91732: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
91736: LD_INT 28
91738: PPUSH
91739: LD_OWVAR 2
91743: PPUSH
91744: LD_INT 2
91746: PPUSH
91747: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
91751: LD_INT 29
91753: PPUSH
91754: LD_OWVAR 2
91758: PPUSH
91759: LD_INT 2
91761: PPUSH
91762: CALL_OW 322
// end ;
91766: PPOPN 3
91768: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
91769: LD_EXP 121
91773: PUSH
91774: LD_EXP 164
91778: AND
91779: IFFALSE 91890
91781: GO 91783
91783: DISABLE
91784: LD_INT 0
91786: PPUSH
91787: PPUSH
91788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91789: LD_ADDR_VAR 0 3
91793: PUSH
91794: LD_INT 22
91796: PUSH
91797: LD_OWVAR 2
91801: PUSH
91802: EMPTY
91803: LIST
91804: LIST
91805: PUSH
91806: LD_INT 25
91808: PUSH
91809: LD_INT 1
91811: PUSH
91812: EMPTY
91813: LIST
91814: LIST
91815: PUSH
91816: EMPTY
91817: LIST
91818: LIST
91819: PPUSH
91820: CALL_OW 69
91824: ST_TO_ADDR
// if not tmp then
91825: LD_VAR 0 3
91829: NOT
91830: IFFALSE 91834
// exit ;
91832: GO 91890
// un := tmp [ rand ( 1 , tmp ) ] ;
91834: LD_ADDR_VAR 0 2
91838: PUSH
91839: LD_VAR 0 3
91843: PUSH
91844: LD_INT 1
91846: PPUSH
91847: LD_VAR 0 3
91851: PPUSH
91852: CALL_OW 12
91856: ARRAY
91857: ST_TO_ADDR
// if Crawls ( un ) then
91858: LD_VAR 0 2
91862: PPUSH
91863: CALL_OW 318
91867: IFFALSE 91878
// ComWalk ( un ) ;
91869: LD_VAR 0 2
91873: PPUSH
91874: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91878: LD_VAR 0 2
91882: PPUSH
91883: LD_INT 8
91885: PPUSH
91886: CALL_OW 336
// end ;
91890: PPOPN 3
91892: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
91893: LD_EXP 121
91897: PUSH
91898: LD_EXP 165
91902: AND
91903: IFFALSE 92047
91905: GO 91907
91907: DISABLE
91908: LD_INT 0
91910: PPUSH
91911: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
91912: LD_ADDR_VAR 0 2
91916: PUSH
91917: LD_INT 22
91919: PUSH
91920: LD_OWVAR 2
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: LD_INT 21
91931: PUSH
91932: LD_INT 2
91934: PUSH
91935: EMPTY
91936: LIST
91937: LIST
91938: PUSH
91939: LD_INT 2
91941: PUSH
91942: LD_INT 34
91944: PUSH
91945: LD_INT 12
91947: PUSH
91948: EMPTY
91949: LIST
91950: LIST
91951: PUSH
91952: LD_INT 34
91954: PUSH
91955: LD_INT 51
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 34
91964: PUSH
91965: LD_INT 32
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: LIST
91976: LIST
91977: PUSH
91978: EMPTY
91979: LIST
91980: LIST
91981: LIST
91982: PPUSH
91983: CALL_OW 69
91987: ST_TO_ADDR
// if not tmp then
91988: LD_VAR 0 2
91992: NOT
91993: IFFALSE 91997
// exit ;
91995: GO 92047
// for i in tmp do
91997: LD_ADDR_VAR 0 1
92001: PUSH
92002: LD_VAR 0 2
92006: PUSH
92007: FOR_IN
92008: IFFALSE 92045
// if GetCargo ( i , mat_artifact ) = 0 then
92010: LD_VAR 0 1
92014: PPUSH
92015: LD_INT 4
92017: PPUSH
92018: CALL_OW 289
92022: PUSH
92023: LD_INT 0
92025: EQUAL
92026: IFFALSE 92043
// SetCargo ( i , mat_siberit , 100 ) ;
92028: LD_VAR 0 1
92032: PPUSH
92033: LD_INT 3
92035: PPUSH
92036: LD_INT 100
92038: PPUSH
92039: CALL_OW 290
92043: GO 92007
92045: POP
92046: POP
// end ;
92047: PPOPN 2
92049: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
92050: LD_EXP 121
92054: PUSH
92055: LD_EXP 166
92059: AND
92060: IFFALSE 92243
92062: GO 92064
92064: DISABLE
92065: LD_INT 0
92067: PPUSH
92068: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
92069: LD_ADDR_VAR 0 2
92073: PUSH
92074: LD_INT 22
92076: PUSH
92077: LD_OWVAR 2
92081: PUSH
92082: EMPTY
92083: LIST
92084: LIST
92085: PPUSH
92086: CALL_OW 69
92090: ST_TO_ADDR
// if not tmp then
92091: LD_VAR 0 2
92095: NOT
92096: IFFALSE 92100
// exit ;
92098: GO 92243
// for i := 1 to 2 do
92100: LD_ADDR_VAR 0 1
92104: PUSH
92105: DOUBLE
92106: LD_INT 1
92108: DEC
92109: ST_TO_ADDR
92110: LD_INT 2
92112: PUSH
92113: FOR_TO
92114: IFFALSE 92241
// begin uc_side := your_side ;
92116: LD_ADDR_OWVAR 20
92120: PUSH
92121: LD_OWVAR 2
92125: ST_TO_ADDR
// uc_nation := nation_american ;
92126: LD_ADDR_OWVAR 21
92130: PUSH
92131: LD_INT 1
92133: ST_TO_ADDR
// vc_chassis := us_morphling ;
92134: LD_ADDR_OWVAR 37
92138: PUSH
92139: LD_INT 5
92141: ST_TO_ADDR
// vc_engine := engine_siberite ;
92142: LD_ADDR_OWVAR 39
92146: PUSH
92147: LD_INT 3
92149: ST_TO_ADDR
// vc_control := control_computer ;
92150: LD_ADDR_OWVAR 38
92154: PUSH
92155: LD_INT 3
92157: ST_TO_ADDR
// vc_weapon := us_double_laser ;
92158: LD_ADDR_OWVAR 40
92162: PUSH
92163: LD_INT 10
92165: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
92166: LD_VAR 0 2
92170: PUSH
92171: LD_INT 1
92173: ARRAY
92174: PPUSH
92175: CALL_OW 310
92179: NOT
92180: IFFALSE 92227
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
92182: CALL_OW 45
92186: PPUSH
92187: LD_VAR 0 2
92191: PUSH
92192: LD_INT 1
92194: ARRAY
92195: PPUSH
92196: CALL_OW 250
92200: PPUSH
92201: LD_VAR 0 2
92205: PUSH
92206: LD_INT 1
92208: ARRAY
92209: PPUSH
92210: CALL_OW 251
92214: PPUSH
92215: LD_INT 12
92217: PPUSH
92218: LD_INT 1
92220: PPUSH
92221: CALL_OW 50
92225: GO 92239
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92227: CALL_OW 45
92231: PPUSH
92232: LD_INT 1
92234: PPUSH
92235: CALL_OW 51
// end ;
92239: GO 92113
92241: POP
92242: POP
// end ;
92243: PPOPN 2
92245: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
92246: LD_EXP 121
92250: PUSH
92251: LD_EXP 167
92255: AND
92256: IFFALSE 92478
92258: GO 92260
92260: DISABLE
92261: LD_INT 0
92263: PPUSH
92264: PPUSH
92265: PPUSH
92266: PPUSH
92267: PPUSH
92268: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92269: LD_ADDR_VAR 0 6
92273: PUSH
92274: LD_INT 22
92276: PUSH
92277: LD_OWVAR 2
92281: PUSH
92282: EMPTY
92283: LIST
92284: LIST
92285: PUSH
92286: LD_INT 21
92288: PUSH
92289: LD_INT 1
92291: PUSH
92292: EMPTY
92293: LIST
92294: LIST
92295: PUSH
92296: LD_INT 3
92298: PUSH
92299: LD_INT 23
92301: PUSH
92302: LD_INT 0
92304: PUSH
92305: EMPTY
92306: LIST
92307: LIST
92308: PUSH
92309: EMPTY
92310: LIST
92311: LIST
92312: PUSH
92313: EMPTY
92314: LIST
92315: LIST
92316: LIST
92317: PPUSH
92318: CALL_OW 69
92322: ST_TO_ADDR
// if not tmp then
92323: LD_VAR 0 6
92327: NOT
92328: IFFALSE 92332
// exit ;
92330: GO 92478
// s1 := rand ( 1 , 4 ) ;
92332: LD_ADDR_VAR 0 2
92336: PUSH
92337: LD_INT 1
92339: PPUSH
92340: LD_INT 4
92342: PPUSH
92343: CALL_OW 12
92347: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
92348: LD_ADDR_VAR 0 4
92352: PUSH
92353: LD_VAR 0 6
92357: PUSH
92358: LD_INT 1
92360: ARRAY
92361: PPUSH
92362: LD_VAR 0 2
92366: PPUSH
92367: CALL_OW 259
92371: ST_TO_ADDR
// if s1 = 1 then
92372: LD_VAR 0 2
92376: PUSH
92377: LD_INT 1
92379: EQUAL
92380: IFFALSE 92400
// s2 := rand ( 2 , 4 ) else
92382: LD_ADDR_VAR 0 3
92386: PUSH
92387: LD_INT 2
92389: PPUSH
92390: LD_INT 4
92392: PPUSH
92393: CALL_OW 12
92397: ST_TO_ADDR
92398: GO 92408
// s2 := 1 ;
92400: LD_ADDR_VAR 0 3
92404: PUSH
92405: LD_INT 1
92407: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
92408: LD_ADDR_VAR 0 5
92412: PUSH
92413: LD_VAR 0 6
92417: PUSH
92418: LD_INT 1
92420: ARRAY
92421: PPUSH
92422: LD_VAR 0 3
92426: PPUSH
92427: CALL_OW 259
92431: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
92432: LD_VAR 0 6
92436: PUSH
92437: LD_INT 1
92439: ARRAY
92440: PPUSH
92441: LD_VAR 0 2
92445: PPUSH
92446: LD_VAR 0 5
92450: PPUSH
92451: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
92455: LD_VAR 0 6
92459: PUSH
92460: LD_INT 1
92462: ARRAY
92463: PPUSH
92464: LD_VAR 0 3
92468: PPUSH
92469: LD_VAR 0 4
92473: PPUSH
92474: CALL_OW 237
// end ;
92478: PPOPN 6
92480: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
92481: LD_EXP 121
92485: PUSH
92486: LD_EXP 168
92490: AND
92491: IFFALSE 92570
92493: GO 92495
92495: DISABLE
92496: LD_INT 0
92498: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
92499: LD_ADDR_VAR 0 1
92503: PUSH
92504: LD_INT 22
92506: PUSH
92507: LD_OWVAR 2
92511: PUSH
92512: EMPTY
92513: LIST
92514: LIST
92515: PUSH
92516: LD_INT 30
92518: PUSH
92519: LD_INT 3
92521: PUSH
92522: EMPTY
92523: LIST
92524: LIST
92525: PUSH
92526: EMPTY
92527: LIST
92528: LIST
92529: PPUSH
92530: CALL_OW 69
92534: ST_TO_ADDR
// if not tmp then
92535: LD_VAR 0 1
92539: NOT
92540: IFFALSE 92544
// exit ;
92542: GO 92570
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
92544: LD_VAR 0 1
92548: PUSH
92549: LD_INT 1
92551: PPUSH
92552: LD_VAR 0 1
92556: PPUSH
92557: CALL_OW 12
92561: ARRAY
92562: PPUSH
92563: LD_INT 1
92565: PPUSH
92566: CALL_OW 234
// end ;
92570: PPOPN 1
92572: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
92573: LD_EXP 121
92577: PUSH
92578: LD_EXP 169
92582: AND
92583: IFFALSE 92695
92585: GO 92587
92587: DISABLE
92588: LD_INT 0
92590: PPUSH
92591: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
92592: LD_ADDR_VAR 0 2
92596: PUSH
92597: LD_INT 22
92599: PUSH
92600: LD_OWVAR 2
92604: PUSH
92605: EMPTY
92606: LIST
92607: LIST
92608: PUSH
92609: LD_INT 2
92611: PUSH
92612: LD_INT 30
92614: PUSH
92615: LD_INT 27
92617: PUSH
92618: EMPTY
92619: LIST
92620: LIST
92621: PUSH
92622: LD_INT 30
92624: PUSH
92625: LD_INT 26
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: PUSH
92632: LD_INT 30
92634: PUSH
92635: LD_INT 28
92637: PUSH
92638: EMPTY
92639: LIST
92640: LIST
92641: PUSH
92642: EMPTY
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: PUSH
92648: EMPTY
92649: LIST
92650: LIST
92651: PPUSH
92652: CALL_OW 69
92656: ST_TO_ADDR
// if not tmp then
92657: LD_VAR 0 2
92661: NOT
92662: IFFALSE 92666
// exit ;
92664: GO 92695
// for i in tmp do
92666: LD_ADDR_VAR 0 1
92670: PUSH
92671: LD_VAR 0 2
92675: PUSH
92676: FOR_IN
92677: IFFALSE 92693
// SetLives ( i , 1 ) ;
92679: LD_VAR 0 1
92683: PPUSH
92684: LD_INT 1
92686: PPUSH
92687: CALL_OW 234
92691: GO 92676
92693: POP
92694: POP
// end ;
92695: PPOPN 2
92697: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
92698: LD_EXP 121
92702: PUSH
92703: LD_EXP 170
92707: AND
92708: IFFALSE 92982
92710: GO 92712
92712: DISABLE
92713: LD_INT 0
92715: PPUSH
92716: PPUSH
92717: PPUSH
// begin i := rand ( 1 , 7 ) ;
92718: LD_ADDR_VAR 0 1
92722: PUSH
92723: LD_INT 1
92725: PPUSH
92726: LD_INT 7
92728: PPUSH
92729: CALL_OW 12
92733: ST_TO_ADDR
// case i of 1 :
92734: LD_VAR 0 1
92738: PUSH
92739: LD_INT 1
92741: DOUBLE
92742: EQUAL
92743: IFTRUE 92747
92745: GO 92757
92747: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
92748: LD_STRING earthquake(getX(game), 0, 32)
92750: PPUSH
92751: CALL_OW 559
92755: GO 92982
92757: LD_INT 2
92759: DOUBLE
92760: EQUAL
92761: IFTRUE 92765
92763: GO 92779
92765: POP
// begin ToLua ( displayStucuk(); ) ;
92766: LD_STRING displayStucuk();
92768: PPUSH
92769: CALL_OW 559
// ResetFog ;
92773: CALL_OW 335
// end ; 3 :
92777: GO 92982
92779: LD_INT 3
92781: DOUBLE
92782: EQUAL
92783: IFTRUE 92787
92785: GO 92891
92787: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
92788: LD_ADDR_VAR 0 2
92792: PUSH
92793: LD_INT 22
92795: PUSH
92796: LD_OWVAR 2
92800: PUSH
92801: EMPTY
92802: LIST
92803: LIST
92804: PUSH
92805: LD_INT 25
92807: PUSH
92808: LD_INT 1
92810: PUSH
92811: EMPTY
92812: LIST
92813: LIST
92814: PUSH
92815: EMPTY
92816: LIST
92817: LIST
92818: PPUSH
92819: CALL_OW 69
92823: ST_TO_ADDR
// if not tmp then
92824: LD_VAR 0 2
92828: NOT
92829: IFFALSE 92833
// exit ;
92831: GO 92982
// un := tmp [ rand ( 1 , tmp ) ] ;
92833: LD_ADDR_VAR 0 3
92837: PUSH
92838: LD_VAR 0 2
92842: PUSH
92843: LD_INT 1
92845: PPUSH
92846: LD_VAR 0 2
92850: PPUSH
92851: CALL_OW 12
92855: ARRAY
92856: ST_TO_ADDR
// if Crawls ( un ) then
92857: LD_VAR 0 3
92861: PPUSH
92862: CALL_OW 318
92866: IFFALSE 92877
// ComWalk ( un ) ;
92868: LD_VAR 0 3
92872: PPUSH
92873: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92877: LD_VAR 0 3
92881: PPUSH
92882: LD_INT 8
92884: PPUSH
92885: CALL_OW 336
// end ; 4 :
92889: GO 92982
92891: LD_INT 4
92893: DOUBLE
92894: EQUAL
92895: IFTRUE 92899
92897: GO 92960
92899: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92900: LD_ADDR_VAR 0 2
92904: PUSH
92905: LD_INT 22
92907: PUSH
92908: LD_OWVAR 2
92912: PUSH
92913: EMPTY
92914: LIST
92915: LIST
92916: PUSH
92917: LD_INT 30
92919: PUSH
92920: LD_INT 29
92922: PUSH
92923: EMPTY
92924: LIST
92925: LIST
92926: PUSH
92927: EMPTY
92928: LIST
92929: LIST
92930: PPUSH
92931: CALL_OW 69
92935: ST_TO_ADDR
// if not tmp then
92936: LD_VAR 0 2
92940: NOT
92941: IFFALSE 92945
// exit ;
92943: GO 92982
// DestroyUnit ( tmp [ 1 ] ) ;
92945: LD_VAR 0 2
92949: PUSH
92950: LD_INT 1
92952: ARRAY
92953: PPUSH
92954: CALL_OW 65
// end ; 5 .. 7 :
92958: GO 92982
92960: LD_INT 5
92962: DOUBLE
92963: GREATEREQUAL
92964: IFFALSE 92972
92966: LD_INT 7
92968: DOUBLE
92969: LESSEQUAL
92970: IFTRUE 92974
92972: GO 92981
92974: POP
// StreamSibBomb ; end ;
92975: CALL 89232 0 0
92979: GO 92982
92981: POP
// end ;
92982: PPOPN 3
92984: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
92985: LD_EXP 121
92989: PUSH
92990: LD_EXP 171
92994: AND
92995: IFFALSE 93151
92997: GO 92999
92999: DISABLE
93000: LD_INT 0
93002: PPUSH
93003: PPUSH
93004: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
93005: LD_ADDR_VAR 0 2
93009: PUSH
93010: LD_INT 81
93012: PUSH
93013: LD_OWVAR 2
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PUSH
93022: LD_INT 2
93024: PUSH
93025: LD_INT 21
93027: PUSH
93028: LD_INT 1
93030: PUSH
93031: EMPTY
93032: LIST
93033: LIST
93034: PUSH
93035: LD_INT 21
93037: PUSH
93038: LD_INT 2
93040: PUSH
93041: EMPTY
93042: LIST
93043: LIST
93044: PUSH
93045: EMPTY
93046: LIST
93047: LIST
93048: LIST
93049: PUSH
93050: EMPTY
93051: LIST
93052: LIST
93053: PPUSH
93054: CALL_OW 69
93058: ST_TO_ADDR
// if not tmp then
93059: LD_VAR 0 2
93063: NOT
93064: IFFALSE 93068
// exit ;
93066: GO 93151
// p := 0 ;
93068: LD_ADDR_VAR 0 3
93072: PUSH
93073: LD_INT 0
93075: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93076: LD_INT 35
93078: PPUSH
93079: CALL_OW 67
// p := p + 1 ;
93083: LD_ADDR_VAR 0 3
93087: PUSH
93088: LD_VAR 0 3
93092: PUSH
93093: LD_INT 1
93095: PLUS
93096: ST_TO_ADDR
// for i in tmp do
93097: LD_ADDR_VAR 0 1
93101: PUSH
93102: LD_VAR 0 2
93106: PUSH
93107: FOR_IN
93108: IFFALSE 93139
// if GetLives ( i ) < 1000 then
93110: LD_VAR 0 1
93114: PPUSH
93115: CALL_OW 256
93119: PUSH
93120: LD_INT 1000
93122: LESS
93123: IFFALSE 93137
// SetLives ( i , 1000 ) ;
93125: LD_VAR 0 1
93129: PPUSH
93130: LD_INT 1000
93132: PPUSH
93133: CALL_OW 234
93137: GO 93107
93139: POP
93140: POP
// until p > 20 ;
93141: LD_VAR 0 3
93145: PUSH
93146: LD_INT 20
93148: GREATER
93149: IFFALSE 93076
// end ;
93151: PPOPN 3
93153: END
// every 0 0$1 trigger StreamModeActive and sTime do
93154: LD_EXP 121
93158: PUSH
93159: LD_EXP 172
93163: AND
93164: IFFALSE 93199
93166: GO 93168
93168: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
93169: LD_INT 28
93171: PPUSH
93172: LD_OWVAR 2
93176: PPUSH
93177: LD_INT 2
93179: PPUSH
93180: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
93184: LD_INT 30
93186: PPUSH
93187: LD_OWVAR 2
93191: PPUSH
93192: LD_INT 2
93194: PPUSH
93195: CALL_OW 322
// end ;
93199: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
93200: LD_EXP 121
93204: PUSH
93205: LD_EXP 173
93209: AND
93210: IFFALSE 93331
93212: GO 93214
93214: DISABLE
93215: LD_INT 0
93217: PPUSH
93218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
93219: LD_ADDR_VAR 0 2
93223: PUSH
93224: LD_INT 22
93226: PUSH
93227: LD_OWVAR 2
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: PUSH
93236: LD_INT 21
93238: PUSH
93239: LD_INT 1
93241: PUSH
93242: EMPTY
93243: LIST
93244: LIST
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: LD_INT 23
93251: PUSH
93252: LD_INT 0
93254: PUSH
93255: EMPTY
93256: LIST
93257: LIST
93258: PUSH
93259: EMPTY
93260: LIST
93261: LIST
93262: PUSH
93263: EMPTY
93264: LIST
93265: LIST
93266: LIST
93267: PPUSH
93268: CALL_OW 69
93272: ST_TO_ADDR
// if not tmp then
93273: LD_VAR 0 2
93277: NOT
93278: IFFALSE 93282
// exit ;
93280: GO 93331
// for i in tmp do
93282: LD_ADDR_VAR 0 1
93286: PUSH
93287: LD_VAR 0 2
93291: PUSH
93292: FOR_IN
93293: IFFALSE 93329
// begin if Crawls ( i ) then
93295: LD_VAR 0 1
93299: PPUSH
93300: CALL_OW 318
93304: IFFALSE 93315
// ComWalk ( i ) ;
93306: LD_VAR 0 1
93310: PPUSH
93311: CALL_OW 138
// SetClass ( i , 2 ) ;
93315: LD_VAR 0 1
93319: PPUSH
93320: LD_INT 2
93322: PPUSH
93323: CALL_OW 336
// end ;
93327: GO 93292
93329: POP
93330: POP
// end ;
93331: PPOPN 2
93333: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
93334: LD_EXP 121
93338: PUSH
93339: LD_EXP 174
93343: AND
93344: IFFALSE 93625
93346: GO 93348
93348: DISABLE
93349: LD_INT 0
93351: PPUSH
93352: PPUSH
93353: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
93354: LD_OWVAR 2
93358: PPUSH
93359: LD_INT 9
93361: PPUSH
93362: LD_INT 1
93364: PPUSH
93365: LD_INT 1
93367: PPUSH
93368: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
93372: LD_INT 9
93374: PPUSH
93375: LD_OWVAR 2
93379: PPUSH
93380: CALL_OW 343
// uc_side := 9 ;
93384: LD_ADDR_OWVAR 20
93388: PUSH
93389: LD_INT 9
93391: ST_TO_ADDR
// uc_nation := 2 ;
93392: LD_ADDR_OWVAR 21
93396: PUSH
93397: LD_INT 2
93399: ST_TO_ADDR
// hc_name := Dark Warrior ;
93400: LD_ADDR_OWVAR 26
93404: PUSH
93405: LD_STRING Dark Warrior
93407: ST_TO_ADDR
// hc_gallery :=  ;
93408: LD_ADDR_OWVAR 33
93412: PUSH
93413: LD_STRING 
93415: ST_TO_ADDR
// hc_noskilllimit := true ;
93416: LD_ADDR_OWVAR 76
93420: PUSH
93421: LD_INT 1
93423: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
93424: LD_ADDR_OWVAR 31
93428: PUSH
93429: LD_INT 30
93431: PUSH
93432: LD_INT 30
93434: PUSH
93435: LD_INT 30
93437: PUSH
93438: LD_INT 30
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: LIST
93445: LIST
93446: ST_TO_ADDR
// un := CreateHuman ;
93447: LD_ADDR_VAR 0 3
93451: PUSH
93452: CALL_OW 44
93456: ST_TO_ADDR
// hc_noskilllimit := false ;
93457: LD_ADDR_OWVAR 76
93461: PUSH
93462: LD_INT 0
93464: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93465: LD_VAR 0 3
93469: PPUSH
93470: LD_INT 1
93472: PPUSH
93473: CALL_OW 51
// p := 0 ;
93477: LD_ADDR_VAR 0 2
93481: PUSH
93482: LD_INT 0
93484: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
93485: LD_INT 35
93487: PPUSH
93488: CALL_OW 67
// p := p + 1 ;
93492: LD_ADDR_VAR 0 2
93496: PUSH
93497: LD_VAR 0 2
93501: PUSH
93502: LD_INT 1
93504: PLUS
93505: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
93506: LD_VAR 0 3
93510: PPUSH
93511: CALL_OW 256
93515: PUSH
93516: LD_INT 1000
93518: LESS
93519: IFFALSE 93533
// SetLives ( un , 1000 ) ;
93521: LD_VAR 0 3
93525: PPUSH
93526: LD_INT 1000
93528: PPUSH
93529: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
93533: LD_VAR 0 3
93537: PPUSH
93538: LD_INT 81
93540: PUSH
93541: LD_OWVAR 2
93545: PUSH
93546: EMPTY
93547: LIST
93548: LIST
93549: PUSH
93550: LD_INT 91
93552: PUSH
93553: LD_VAR 0 3
93557: PUSH
93558: LD_INT 30
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: LIST
93565: PUSH
93566: EMPTY
93567: LIST
93568: LIST
93569: PPUSH
93570: CALL_OW 69
93574: PPUSH
93575: LD_VAR 0 3
93579: PPUSH
93580: CALL_OW 74
93584: PPUSH
93585: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
93589: LD_VAR 0 2
93593: PUSH
93594: LD_INT 60
93596: GREATER
93597: PUSH
93598: LD_VAR 0 3
93602: PPUSH
93603: CALL_OW 301
93607: OR
93608: IFFALSE 93485
// if un then
93610: LD_VAR 0 3
93614: IFFALSE 93625
// RemoveUnit ( un ) ;
93616: LD_VAR 0 3
93620: PPUSH
93621: CALL_OW 64
// end ;
93625: PPOPN 3
93627: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
93628: LD_INT 0
93630: PPUSH
// case cmd of 301 :
93631: LD_VAR 0 1
93635: PUSH
93636: LD_INT 301
93638: DOUBLE
93639: EQUAL
93640: IFTRUE 93644
93642: GO 93676
93644: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
93645: LD_VAR 0 6
93649: PPUSH
93650: LD_VAR 0 7
93654: PPUSH
93655: LD_VAR 0 8
93659: PPUSH
93660: LD_VAR 0 4
93664: PPUSH
93665: LD_VAR 0 5
93669: PPUSH
93670: CALL 94877 0 5
93674: GO 93797
93676: LD_INT 302
93678: DOUBLE
93679: EQUAL
93680: IFTRUE 93684
93682: GO 93721
93684: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
93685: LD_VAR 0 6
93689: PPUSH
93690: LD_VAR 0 7
93694: PPUSH
93695: LD_VAR 0 8
93699: PPUSH
93700: LD_VAR 0 9
93704: PPUSH
93705: LD_VAR 0 4
93709: PPUSH
93710: LD_VAR 0 5
93714: PPUSH
93715: CALL 94968 0 6
93719: GO 93797
93721: LD_INT 303
93723: DOUBLE
93724: EQUAL
93725: IFTRUE 93729
93727: GO 93766
93729: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
93730: LD_VAR 0 6
93734: PPUSH
93735: LD_VAR 0 7
93739: PPUSH
93740: LD_VAR 0 8
93744: PPUSH
93745: LD_VAR 0 9
93749: PPUSH
93750: LD_VAR 0 4
93754: PPUSH
93755: LD_VAR 0 5
93759: PPUSH
93760: CALL 93802 0 6
93764: GO 93797
93766: LD_INT 304
93768: DOUBLE
93769: EQUAL
93770: IFTRUE 93774
93772: GO 93796
93774: POP
// hHackTeleport ( unit , x , y ) ; end ;
93775: LD_VAR 0 2
93779: PPUSH
93780: LD_VAR 0 4
93784: PPUSH
93785: LD_VAR 0 5
93789: PPUSH
93790: CALL 95561 0 3
93794: GO 93797
93796: POP
// end ;
93797: LD_VAR 0 12
93801: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
93802: LD_INT 0
93804: PPUSH
93805: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
93806: LD_VAR 0 1
93810: PUSH
93811: LD_INT 1
93813: LESS
93814: PUSH
93815: LD_VAR 0 1
93819: PUSH
93820: LD_INT 3
93822: GREATER
93823: OR
93824: PUSH
93825: LD_VAR 0 5
93829: PPUSH
93830: LD_VAR 0 6
93834: PPUSH
93835: CALL_OW 428
93839: OR
93840: IFFALSE 93844
// exit ;
93842: GO 94564
// uc_side := your_side ;
93844: LD_ADDR_OWVAR 20
93848: PUSH
93849: LD_OWVAR 2
93853: ST_TO_ADDR
// uc_nation := nation ;
93854: LD_ADDR_OWVAR 21
93858: PUSH
93859: LD_VAR 0 1
93863: ST_TO_ADDR
// bc_level = 1 ;
93864: LD_ADDR_OWVAR 43
93868: PUSH
93869: LD_INT 1
93871: ST_TO_ADDR
// case btype of 1 :
93872: LD_VAR 0 2
93876: PUSH
93877: LD_INT 1
93879: DOUBLE
93880: EQUAL
93881: IFTRUE 93885
93883: GO 93896
93885: POP
// bc_type := b_depot ; 2 :
93886: LD_ADDR_OWVAR 42
93890: PUSH
93891: LD_INT 0
93893: ST_TO_ADDR
93894: GO 94508
93896: LD_INT 2
93898: DOUBLE
93899: EQUAL
93900: IFTRUE 93904
93902: GO 93915
93904: POP
// bc_type := b_warehouse ; 3 :
93905: LD_ADDR_OWVAR 42
93909: PUSH
93910: LD_INT 1
93912: ST_TO_ADDR
93913: GO 94508
93915: LD_INT 3
93917: DOUBLE
93918: EQUAL
93919: IFTRUE 93923
93921: GO 93934
93923: POP
// bc_type := b_lab ; 4 .. 9 :
93924: LD_ADDR_OWVAR 42
93928: PUSH
93929: LD_INT 6
93931: ST_TO_ADDR
93932: GO 94508
93934: LD_INT 4
93936: DOUBLE
93937: GREATEREQUAL
93938: IFFALSE 93946
93940: LD_INT 9
93942: DOUBLE
93943: LESSEQUAL
93944: IFTRUE 93948
93946: GO 94000
93948: POP
// begin bc_type := b_lab_half ;
93949: LD_ADDR_OWVAR 42
93953: PUSH
93954: LD_INT 7
93956: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
93957: LD_ADDR_OWVAR 44
93961: PUSH
93962: LD_INT 10
93964: PUSH
93965: LD_INT 11
93967: PUSH
93968: LD_INT 12
93970: PUSH
93971: LD_INT 15
93973: PUSH
93974: LD_INT 14
93976: PUSH
93977: LD_INT 13
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: LIST
93986: LIST
93987: PUSH
93988: LD_VAR 0 2
93992: PUSH
93993: LD_INT 3
93995: MINUS
93996: ARRAY
93997: ST_TO_ADDR
// end ; 10 .. 13 :
93998: GO 94508
94000: LD_INT 10
94002: DOUBLE
94003: GREATEREQUAL
94004: IFFALSE 94012
94006: LD_INT 13
94008: DOUBLE
94009: LESSEQUAL
94010: IFTRUE 94014
94012: GO 94091
94014: POP
// begin bc_type := b_lab_full ;
94015: LD_ADDR_OWVAR 42
94019: PUSH
94020: LD_INT 8
94022: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
94023: LD_ADDR_OWVAR 44
94027: PUSH
94028: LD_INT 10
94030: PUSH
94031: LD_INT 12
94033: PUSH
94034: LD_INT 14
94036: PUSH
94037: LD_INT 13
94039: PUSH
94040: EMPTY
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: PUSH
94046: LD_VAR 0 2
94050: PUSH
94051: LD_INT 9
94053: MINUS
94054: ARRAY
94055: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
94056: LD_ADDR_OWVAR 45
94060: PUSH
94061: LD_INT 11
94063: PUSH
94064: LD_INT 15
94066: PUSH
94067: LD_INT 12
94069: PUSH
94070: LD_INT 15
94072: PUSH
94073: EMPTY
94074: LIST
94075: LIST
94076: LIST
94077: LIST
94078: PUSH
94079: LD_VAR 0 2
94083: PUSH
94084: LD_INT 9
94086: MINUS
94087: ARRAY
94088: ST_TO_ADDR
// end ; 14 :
94089: GO 94508
94091: LD_INT 14
94093: DOUBLE
94094: EQUAL
94095: IFTRUE 94099
94097: GO 94110
94099: POP
// bc_type := b_workshop ; 15 :
94100: LD_ADDR_OWVAR 42
94104: PUSH
94105: LD_INT 2
94107: ST_TO_ADDR
94108: GO 94508
94110: LD_INT 15
94112: DOUBLE
94113: EQUAL
94114: IFTRUE 94118
94116: GO 94129
94118: POP
// bc_type := b_factory ; 16 :
94119: LD_ADDR_OWVAR 42
94123: PUSH
94124: LD_INT 3
94126: ST_TO_ADDR
94127: GO 94508
94129: LD_INT 16
94131: DOUBLE
94132: EQUAL
94133: IFTRUE 94137
94135: GO 94148
94137: POP
// bc_type := b_ext_gun ; 17 :
94138: LD_ADDR_OWVAR 42
94142: PUSH
94143: LD_INT 17
94145: ST_TO_ADDR
94146: GO 94508
94148: LD_INT 17
94150: DOUBLE
94151: EQUAL
94152: IFTRUE 94156
94154: GO 94184
94156: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
94157: LD_ADDR_OWVAR 42
94161: PUSH
94162: LD_INT 19
94164: PUSH
94165: LD_INT 23
94167: PUSH
94168: LD_INT 19
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: LIST
94175: PUSH
94176: LD_VAR 0 1
94180: ARRAY
94181: ST_TO_ADDR
94182: GO 94508
94184: LD_INT 18
94186: DOUBLE
94187: EQUAL
94188: IFTRUE 94192
94190: GO 94203
94192: POP
// bc_type := b_ext_radar ; 19 :
94193: LD_ADDR_OWVAR 42
94197: PUSH
94198: LD_INT 20
94200: ST_TO_ADDR
94201: GO 94508
94203: LD_INT 19
94205: DOUBLE
94206: EQUAL
94207: IFTRUE 94211
94209: GO 94222
94211: POP
// bc_type := b_ext_radio ; 20 :
94212: LD_ADDR_OWVAR 42
94216: PUSH
94217: LD_INT 22
94219: ST_TO_ADDR
94220: GO 94508
94222: LD_INT 20
94224: DOUBLE
94225: EQUAL
94226: IFTRUE 94230
94228: GO 94241
94230: POP
// bc_type := b_ext_siberium ; 21 :
94231: LD_ADDR_OWVAR 42
94235: PUSH
94236: LD_INT 21
94238: ST_TO_ADDR
94239: GO 94508
94241: LD_INT 21
94243: DOUBLE
94244: EQUAL
94245: IFTRUE 94249
94247: GO 94260
94249: POP
// bc_type := b_ext_computer ; 22 :
94250: LD_ADDR_OWVAR 42
94254: PUSH
94255: LD_INT 24
94257: ST_TO_ADDR
94258: GO 94508
94260: LD_INT 22
94262: DOUBLE
94263: EQUAL
94264: IFTRUE 94268
94266: GO 94279
94268: POP
// bc_type := b_ext_track ; 23 :
94269: LD_ADDR_OWVAR 42
94273: PUSH
94274: LD_INT 16
94276: ST_TO_ADDR
94277: GO 94508
94279: LD_INT 23
94281: DOUBLE
94282: EQUAL
94283: IFTRUE 94287
94285: GO 94298
94287: POP
// bc_type := b_ext_laser ; 24 :
94288: LD_ADDR_OWVAR 42
94292: PUSH
94293: LD_INT 25
94295: ST_TO_ADDR
94296: GO 94508
94298: LD_INT 24
94300: DOUBLE
94301: EQUAL
94302: IFTRUE 94306
94304: GO 94317
94306: POP
// bc_type := b_control_tower ; 25 :
94307: LD_ADDR_OWVAR 42
94311: PUSH
94312: LD_INT 36
94314: ST_TO_ADDR
94315: GO 94508
94317: LD_INT 25
94319: DOUBLE
94320: EQUAL
94321: IFTRUE 94325
94323: GO 94336
94325: POP
// bc_type := b_breastwork ; 26 :
94326: LD_ADDR_OWVAR 42
94330: PUSH
94331: LD_INT 31
94333: ST_TO_ADDR
94334: GO 94508
94336: LD_INT 26
94338: DOUBLE
94339: EQUAL
94340: IFTRUE 94344
94342: GO 94355
94344: POP
// bc_type := b_bunker ; 27 :
94345: LD_ADDR_OWVAR 42
94349: PUSH
94350: LD_INT 32
94352: ST_TO_ADDR
94353: GO 94508
94355: LD_INT 27
94357: DOUBLE
94358: EQUAL
94359: IFTRUE 94363
94361: GO 94374
94363: POP
// bc_type := b_turret ; 28 :
94364: LD_ADDR_OWVAR 42
94368: PUSH
94369: LD_INT 33
94371: ST_TO_ADDR
94372: GO 94508
94374: LD_INT 28
94376: DOUBLE
94377: EQUAL
94378: IFTRUE 94382
94380: GO 94393
94382: POP
// bc_type := b_armoury ; 29 :
94383: LD_ADDR_OWVAR 42
94387: PUSH
94388: LD_INT 4
94390: ST_TO_ADDR
94391: GO 94508
94393: LD_INT 29
94395: DOUBLE
94396: EQUAL
94397: IFTRUE 94401
94399: GO 94412
94401: POP
// bc_type := b_barracks ; 30 :
94402: LD_ADDR_OWVAR 42
94406: PUSH
94407: LD_INT 5
94409: ST_TO_ADDR
94410: GO 94508
94412: LD_INT 30
94414: DOUBLE
94415: EQUAL
94416: IFTRUE 94420
94418: GO 94431
94420: POP
// bc_type := b_solar_power ; 31 :
94421: LD_ADDR_OWVAR 42
94425: PUSH
94426: LD_INT 27
94428: ST_TO_ADDR
94429: GO 94508
94431: LD_INT 31
94433: DOUBLE
94434: EQUAL
94435: IFTRUE 94439
94437: GO 94450
94439: POP
// bc_type := b_oil_power ; 32 :
94440: LD_ADDR_OWVAR 42
94444: PUSH
94445: LD_INT 26
94447: ST_TO_ADDR
94448: GO 94508
94450: LD_INT 32
94452: DOUBLE
94453: EQUAL
94454: IFTRUE 94458
94456: GO 94469
94458: POP
// bc_type := b_siberite_power ; 33 :
94459: LD_ADDR_OWVAR 42
94463: PUSH
94464: LD_INT 28
94466: ST_TO_ADDR
94467: GO 94508
94469: LD_INT 33
94471: DOUBLE
94472: EQUAL
94473: IFTRUE 94477
94475: GO 94488
94477: POP
// bc_type := b_oil_mine ; 34 :
94478: LD_ADDR_OWVAR 42
94482: PUSH
94483: LD_INT 29
94485: ST_TO_ADDR
94486: GO 94508
94488: LD_INT 34
94490: DOUBLE
94491: EQUAL
94492: IFTRUE 94496
94494: GO 94507
94496: POP
// bc_type := b_siberite_mine ; end ;
94497: LD_ADDR_OWVAR 42
94501: PUSH
94502: LD_INT 30
94504: ST_TO_ADDR
94505: GO 94508
94507: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
94508: LD_ADDR_VAR 0 8
94512: PUSH
94513: LD_VAR 0 5
94517: PPUSH
94518: LD_VAR 0 6
94522: PPUSH
94523: LD_VAR 0 3
94527: PPUSH
94528: CALL_OW 47
94532: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
94533: LD_OWVAR 42
94537: PUSH
94538: LD_INT 32
94540: PUSH
94541: LD_INT 33
94543: PUSH
94544: EMPTY
94545: LIST
94546: LIST
94547: IN
94548: IFFALSE 94564
// PlaceWeaponTurret ( b , weapon ) ;
94550: LD_VAR 0 8
94554: PPUSH
94555: LD_VAR 0 4
94559: PPUSH
94560: CALL_OW 431
// end ;
94564: LD_VAR 0 7
94568: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
94569: LD_INT 0
94571: PPUSH
94572: PPUSH
94573: PPUSH
94574: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94575: LD_ADDR_VAR 0 4
94579: PUSH
94580: LD_INT 22
94582: PUSH
94583: LD_OWVAR 2
94587: PUSH
94588: EMPTY
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 2
94594: PUSH
94595: LD_INT 30
94597: PUSH
94598: LD_INT 0
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: PUSH
94605: LD_INT 30
94607: PUSH
94608: LD_INT 1
94610: PUSH
94611: EMPTY
94612: LIST
94613: LIST
94614: PUSH
94615: EMPTY
94616: LIST
94617: LIST
94618: LIST
94619: PUSH
94620: EMPTY
94621: LIST
94622: LIST
94623: PPUSH
94624: CALL_OW 69
94628: ST_TO_ADDR
// if not tmp then
94629: LD_VAR 0 4
94633: NOT
94634: IFFALSE 94638
// exit ;
94636: GO 94697
// for i in tmp do
94638: LD_ADDR_VAR 0 2
94642: PUSH
94643: LD_VAR 0 4
94647: PUSH
94648: FOR_IN
94649: IFFALSE 94695
// for j = 1 to 3 do
94651: LD_ADDR_VAR 0 3
94655: PUSH
94656: DOUBLE
94657: LD_INT 1
94659: DEC
94660: ST_TO_ADDR
94661: LD_INT 3
94663: PUSH
94664: FOR_TO
94665: IFFALSE 94691
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
94667: LD_VAR 0 2
94671: PPUSH
94672: CALL_OW 274
94676: PPUSH
94677: LD_VAR 0 3
94681: PPUSH
94682: LD_INT 99999
94684: PPUSH
94685: CALL_OW 277
94689: GO 94664
94691: POP
94692: POP
94693: GO 94648
94695: POP
94696: POP
// end ;
94697: LD_VAR 0 1
94701: RET
// export function hHackSetLevel10 ; var i , j ; begin
94702: LD_INT 0
94704: PPUSH
94705: PPUSH
94706: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94707: LD_ADDR_VAR 0 2
94711: PUSH
94712: LD_INT 21
94714: PUSH
94715: LD_INT 1
94717: PUSH
94718: EMPTY
94719: LIST
94720: LIST
94721: PPUSH
94722: CALL_OW 69
94726: PUSH
94727: FOR_IN
94728: IFFALSE 94780
// if IsSelected ( i ) then
94730: LD_VAR 0 2
94734: PPUSH
94735: CALL_OW 306
94739: IFFALSE 94778
// begin for j := 1 to 4 do
94741: LD_ADDR_VAR 0 3
94745: PUSH
94746: DOUBLE
94747: LD_INT 1
94749: DEC
94750: ST_TO_ADDR
94751: LD_INT 4
94753: PUSH
94754: FOR_TO
94755: IFFALSE 94776
// SetSkill ( i , j , 10 ) ;
94757: LD_VAR 0 2
94761: PPUSH
94762: LD_VAR 0 3
94766: PPUSH
94767: LD_INT 10
94769: PPUSH
94770: CALL_OW 237
94774: GO 94754
94776: POP
94777: POP
// end ;
94778: GO 94727
94780: POP
94781: POP
// end ;
94782: LD_VAR 0 1
94786: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
94787: LD_INT 0
94789: PPUSH
94790: PPUSH
94791: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
94792: LD_ADDR_VAR 0 2
94796: PUSH
94797: LD_INT 22
94799: PUSH
94800: LD_OWVAR 2
94804: PUSH
94805: EMPTY
94806: LIST
94807: LIST
94808: PUSH
94809: LD_INT 21
94811: PUSH
94812: LD_INT 1
94814: PUSH
94815: EMPTY
94816: LIST
94817: LIST
94818: PUSH
94819: EMPTY
94820: LIST
94821: LIST
94822: PPUSH
94823: CALL_OW 69
94827: PUSH
94828: FOR_IN
94829: IFFALSE 94870
// begin for j := 1 to 4 do
94831: LD_ADDR_VAR 0 3
94835: PUSH
94836: DOUBLE
94837: LD_INT 1
94839: DEC
94840: ST_TO_ADDR
94841: LD_INT 4
94843: PUSH
94844: FOR_TO
94845: IFFALSE 94866
// SetSkill ( i , j , 10 ) ;
94847: LD_VAR 0 2
94851: PPUSH
94852: LD_VAR 0 3
94856: PPUSH
94857: LD_INT 10
94859: PPUSH
94860: CALL_OW 237
94864: GO 94844
94866: POP
94867: POP
// end ;
94868: GO 94828
94870: POP
94871: POP
// end ;
94872: LD_VAR 0 1
94876: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
94877: LD_INT 0
94879: PPUSH
// uc_side := your_side ;
94880: LD_ADDR_OWVAR 20
94884: PUSH
94885: LD_OWVAR 2
94889: ST_TO_ADDR
// uc_nation := nation ;
94890: LD_ADDR_OWVAR 21
94894: PUSH
94895: LD_VAR 0 1
94899: ST_TO_ADDR
// InitHc ;
94900: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
94904: LD_INT 0
94906: PPUSH
94907: LD_VAR 0 2
94911: PPUSH
94912: LD_VAR 0 3
94916: PPUSH
94917: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
94921: LD_VAR 0 4
94925: PPUSH
94926: LD_VAR 0 5
94930: PPUSH
94931: CALL_OW 428
94935: PUSH
94936: LD_INT 0
94938: EQUAL
94939: IFFALSE 94963
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
94941: CALL_OW 44
94945: PPUSH
94946: LD_VAR 0 4
94950: PPUSH
94951: LD_VAR 0 5
94955: PPUSH
94956: LD_INT 1
94958: PPUSH
94959: CALL_OW 48
// end ;
94963: LD_VAR 0 6
94967: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
94968: LD_INT 0
94970: PPUSH
94971: PPUSH
// uc_side := your_side ;
94972: LD_ADDR_OWVAR 20
94976: PUSH
94977: LD_OWVAR 2
94981: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
94982: LD_VAR 0 1
94986: PUSH
94987: LD_INT 1
94989: PUSH
94990: LD_INT 2
94992: PUSH
94993: LD_INT 3
94995: PUSH
94996: LD_INT 4
94998: PUSH
94999: LD_INT 5
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: IN
95009: IFFALSE 95021
// uc_nation := nation_american else
95011: LD_ADDR_OWVAR 21
95015: PUSH
95016: LD_INT 1
95018: ST_TO_ADDR
95019: GO 95064
// if chassis in [ 11 , 12 , 13 , 14 ] then
95021: LD_VAR 0 1
95025: PUSH
95026: LD_INT 11
95028: PUSH
95029: LD_INT 12
95031: PUSH
95032: LD_INT 13
95034: PUSH
95035: LD_INT 14
95037: PUSH
95038: EMPTY
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: IN
95044: IFFALSE 95056
// uc_nation := nation_arabian else
95046: LD_ADDR_OWVAR 21
95050: PUSH
95051: LD_INT 2
95053: ST_TO_ADDR
95054: GO 95064
// uc_nation := nation_russian ;
95056: LD_ADDR_OWVAR 21
95060: PUSH
95061: LD_INT 3
95063: ST_TO_ADDR
// vc_chassis := chassis ;
95064: LD_ADDR_OWVAR 37
95068: PUSH
95069: LD_VAR 0 1
95073: ST_TO_ADDR
// vc_engine := engine ;
95074: LD_ADDR_OWVAR 39
95078: PUSH
95079: LD_VAR 0 2
95083: ST_TO_ADDR
// vc_control := control ;
95084: LD_ADDR_OWVAR 38
95088: PUSH
95089: LD_VAR 0 3
95093: ST_TO_ADDR
// vc_weapon := weapon ;
95094: LD_ADDR_OWVAR 40
95098: PUSH
95099: LD_VAR 0 4
95103: ST_TO_ADDR
// un := CreateVehicle ;
95104: LD_ADDR_VAR 0 8
95108: PUSH
95109: CALL_OW 45
95113: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
95114: LD_VAR 0 8
95118: PPUSH
95119: LD_INT 0
95121: PPUSH
95122: LD_INT 5
95124: PPUSH
95125: CALL_OW 12
95129: PPUSH
95130: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
95134: LD_VAR 0 8
95138: PPUSH
95139: LD_VAR 0 5
95143: PPUSH
95144: LD_VAR 0 6
95148: PPUSH
95149: LD_INT 1
95151: PPUSH
95152: CALL_OW 48
// end ;
95156: LD_VAR 0 7
95160: RET
// export hInvincible ; every 1 do
95161: GO 95163
95163: DISABLE
// hInvincible := [ ] ;
95164: LD_ADDR_EXP 175
95168: PUSH
95169: EMPTY
95170: ST_TO_ADDR
95171: END
// every 10 do var i ;
95172: GO 95174
95174: DISABLE
95175: LD_INT 0
95177: PPUSH
// begin enable ;
95178: ENABLE
// if not hInvincible then
95179: LD_EXP 175
95183: NOT
95184: IFFALSE 95188
// exit ;
95186: GO 95232
// for i in hInvincible do
95188: LD_ADDR_VAR 0 1
95192: PUSH
95193: LD_EXP 175
95197: PUSH
95198: FOR_IN
95199: IFFALSE 95230
// if GetLives ( i ) < 1000 then
95201: LD_VAR 0 1
95205: PPUSH
95206: CALL_OW 256
95210: PUSH
95211: LD_INT 1000
95213: LESS
95214: IFFALSE 95228
// SetLives ( i , 1000 ) ;
95216: LD_VAR 0 1
95220: PPUSH
95221: LD_INT 1000
95223: PPUSH
95224: CALL_OW 234
95228: GO 95198
95230: POP
95231: POP
// end ;
95232: PPOPN 1
95234: END
// export function hHackInvincible ; var i ; begin
95235: LD_INT 0
95237: PPUSH
95238: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
95239: LD_ADDR_VAR 0 2
95243: PUSH
95244: LD_INT 2
95246: PUSH
95247: LD_INT 21
95249: PUSH
95250: LD_INT 1
95252: PUSH
95253: EMPTY
95254: LIST
95255: LIST
95256: PUSH
95257: LD_INT 21
95259: PUSH
95260: LD_INT 2
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: LIST
95271: PPUSH
95272: CALL_OW 69
95276: PUSH
95277: FOR_IN
95278: IFFALSE 95339
// if IsSelected ( i ) then
95280: LD_VAR 0 2
95284: PPUSH
95285: CALL_OW 306
95289: IFFALSE 95337
// begin if i in hInvincible then
95291: LD_VAR 0 2
95295: PUSH
95296: LD_EXP 175
95300: IN
95301: IFFALSE 95321
// hInvincible := hInvincible diff i else
95303: LD_ADDR_EXP 175
95307: PUSH
95308: LD_EXP 175
95312: PUSH
95313: LD_VAR 0 2
95317: DIFF
95318: ST_TO_ADDR
95319: GO 95337
// hInvincible := hInvincible union i ;
95321: LD_ADDR_EXP 175
95325: PUSH
95326: LD_EXP 175
95330: PUSH
95331: LD_VAR 0 2
95335: UNION
95336: ST_TO_ADDR
// end ;
95337: GO 95277
95339: POP
95340: POP
// end ;
95341: LD_VAR 0 1
95345: RET
// export function hHackInvisible ; var i , j ; begin
95346: LD_INT 0
95348: PPUSH
95349: PPUSH
95350: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
95351: LD_ADDR_VAR 0 2
95355: PUSH
95356: LD_INT 21
95358: PUSH
95359: LD_INT 1
95361: PUSH
95362: EMPTY
95363: LIST
95364: LIST
95365: PPUSH
95366: CALL_OW 69
95370: PUSH
95371: FOR_IN
95372: IFFALSE 95396
// if IsSelected ( i ) then
95374: LD_VAR 0 2
95378: PPUSH
95379: CALL_OW 306
95383: IFFALSE 95394
// ComForceInvisible ( i ) ;
95385: LD_VAR 0 2
95389: PPUSH
95390: CALL_OW 496
95394: GO 95371
95396: POP
95397: POP
// end ;
95398: LD_VAR 0 1
95402: RET
// export function hHackChangeYourSide ; begin
95403: LD_INT 0
95405: PPUSH
// if your_side = 8 then
95406: LD_OWVAR 2
95410: PUSH
95411: LD_INT 8
95413: EQUAL
95414: IFFALSE 95426
// your_side := 0 else
95416: LD_ADDR_OWVAR 2
95420: PUSH
95421: LD_INT 0
95423: ST_TO_ADDR
95424: GO 95440
// your_side := your_side + 1 ;
95426: LD_ADDR_OWVAR 2
95430: PUSH
95431: LD_OWVAR 2
95435: PUSH
95436: LD_INT 1
95438: PLUS
95439: ST_TO_ADDR
// end ;
95440: LD_VAR 0 1
95444: RET
// export function hHackChangeUnitSide ; var i , j ; begin
95445: LD_INT 0
95447: PPUSH
95448: PPUSH
95449: PPUSH
// for i in all_units do
95450: LD_ADDR_VAR 0 2
95454: PUSH
95455: LD_OWVAR 3
95459: PUSH
95460: FOR_IN
95461: IFFALSE 95539
// if IsSelected ( i ) then
95463: LD_VAR 0 2
95467: PPUSH
95468: CALL_OW 306
95472: IFFALSE 95537
// begin j := GetSide ( i ) ;
95474: LD_ADDR_VAR 0 3
95478: PUSH
95479: LD_VAR 0 2
95483: PPUSH
95484: CALL_OW 255
95488: ST_TO_ADDR
// if j = 8 then
95489: LD_VAR 0 3
95493: PUSH
95494: LD_INT 8
95496: EQUAL
95497: IFFALSE 95509
// j := 0 else
95499: LD_ADDR_VAR 0 3
95503: PUSH
95504: LD_INT 0
95506: ST_TO_ADDR
95507: GO 95523
// j := j + 1 ;
95509: LD_ADDR_VAR 0 3
95513: PUSH
95514: LD_VAR 0 3
95518: PUSH
95519: LD_INT 1
95521: PLUS
95522: ST_TO_ADDR
// SetSide ( i , j ) ;
95523: LD_VAR 0 2
95527: PPUSH
95528: LD_VAR 0 3
95532: PPUSH
95533: CALL_OW 235
// end ;
95537: GO 95460
95539: POP
95540: POP
// end ;
95541: LD_VAR 0 1
95545: RET
// export function hHackFog ; begin
95546: LD_INT 0
95548: PPUSH
// FogOff ( true ) ;
95549: LD_INT 1
95551: PPUSH
95552: CALL_OW 344
// end ;
95556: LD_VAR 0 1
95560: RET
// export function hHackTeleport ( unit , x , y ) ; begin
95561: LD_INT 0
95563: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
95564: LD_VAR 0 1
95568: PPUSH
95569: LD_VAR 0 2
95573: PPUSH
95574: LD_VAR 0 3
95578: PPUSH
95579: LD_INT 1
95581: PPUSH
95582: LD_INT 1
95584: PPUSH
95585: CALL_OW 483
// CenterOnXY ( x , y ) ;
95589: LD_VAR 0 2
95593: PPUSH
95594: LD_VAR 0 3
95598: PPUSH
95599: CALL_OW 84
// end ; end_of_file
95603: LD_VAR 0 4
95607: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
95608: LD_INT 0
95610: PPUSH
95611: PPUSH
95612: PPUSH
95613: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
95614: LD_VAR 0 1
95618: PPUSH
95619: CALL_OW 264
95623: PUSH
95624: LD_EXP 107
95628: EQUAL
95629: IFFALSE 95701
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
95631: LD_INT 68
95633: PPUSH
95634: LD_VAR 0 1
95638: PPUSH
95639: CALL_OW 255
95643: PPUSH
95644: CALL_OW 321
95648: PUSH
95649: LD_INT 2
95651: EQUAL
95652: IFFALSE 95664
// eff := 70 else
95654: LD_ADDR_VAR 0 4
95658: PUSH
95659: LD_INT 70
95661: ST_TO_ADDR
95662: GO 95672
// eff := 30 ;
95664: LD_ADDR_VAR 0 4
95668: PUSH
95669: LD_INT 30
95671: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
95672: LD_VAR 0 1
95676: PPUSH
95677: CALL_OW 250
95681: PPUSH
95682: LD_VAR 0 1
95686: PPUSH
95687: CALL_OW 251
95691: PPUSH
95692: LD_VAR 0 4
95696: PPUSH
95697: CALL_OW 495
// end ; end ;
95701: LD_VAR 0 2
95705: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
95706: LD_INT 0
95708: PPUSH
// end ;
95709: LD_VAR 0 4
95713: RET
// export function SOS_Command ( cmd ) ; begin
95714: LD_INT 0
95716: PPUSH
// end ;
95717: LD_VAR 0 2
95721: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
95722: LD_INT 0
95724: PPUSH
// if cmd = 121 then
95725: LD_VAR 0 1
95729: PUSH
95730: LD_INT 121
95732: EQUAL
95733: IFFALSE 95735
// end ;
95735: LD_VAR 0 6
95739: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
95740: LD_INT 0
95742: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
95743: LD_VAR 0 1
95747: PUSH
95748: LD_INT 250
95750: EQUAL
95751: PUSH
95752: LD_VAR 0 2
95756: PPUSH
95757: CALL_OW 264
95761: PUSH
95762: LD_EXP 110
95766: EQUAL
95767: AND
95768: IFFALSE 95789
// MinerPlaceMine ( unit , x , y ) ;
95770: LD_VAR 0 2
95774: PPUSH
95775: LD_VAR 0 4
95779: PPUSH
95780: LD_VAR 0 5
95784: PPUSH
95785: CALL 98138 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
95789: LD_VAR 0 1
95793: PUSH
95794: LD_INT 251
95796: EQUAL
95797: PUSH
95798: LD_VAR 0 2
95802: PPUSH
95803: CALL_OW 264
95807: PUSH
95808: LD_EXP 110
95812: EQUAL
95813: AND
95814: IFFALSE 95835
// MinerDetonateMine ( unit , x , y ) ;
95816: LD_VAR 0 2
95820: PPUSH
95821: LD_VAR 0 4
95825: PPUSH
95826: LD_VAR 0 5
95830: PPUSH
95831: CALL 98415 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
95835: LD_VAR 0 1
95839: PUSH
95840: LD_INT 252
95842: EQUAL
95843: PUSH
95844: LD_VAR 0 2
95848: PPUSH
95849: CALL_OW 264
95853: PUSH
95854: LD_EXP 110
95858: EQUAL
95859: AND
95860: IFFALSE 95881
// MinerCreateMinefield ( unit , x , y ) ;
95862: LD_VAR 0 2
95866: PPUSH
95867: LD_VAR 0 4
95871: PPUSH
95872: LD_VAR 0 5
95876: PPUSH
95877: CALL 98832 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
95881: LD_VAR 0 1
95885: PUSH
95886: LD_INT 253
95888: EQUAL
95889: PUSH
95890: LD_VAR 0 2
95894: PPUSH
95895: CALL_OW 257
95899: PUSH
95900: LD_INT 5
95902: EQUAL
95903: AND
95904: IFFALSE 95925
// ComBinocular ( unit , x , y ) ;
95906: LD_VAR 0 2
95910: PPUSH
95911: LD_VAR 0 4
95915: PPUSH
95916: LD_VAR 0 5
95920: PPUSH
95921: CALL 99203 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
95925: LD_VAR 0 1
95929: PUSH
95930: LD_INT 254
95932: EQUAL
95933: PUSH
95934: LD_VAR 0 2
95938: PPUSH
95939: CALL_OW 264
95943: PUSH
95944: LD_EXP 105
95948: EQUAL
95949: AND
95950: PUSH
95951: LD_VAR 0 3
95955: PPUSH
95956: CALL_OW 263
95960: PUSH
95961: LD_INT 3
95963: EQUAL
95964: AND
95965: IFFALSE 95981
// HackDestroyVehicle ( unit , selectedUnit ) ;
95967: LD_VAR 0 2
95971: PPUSH
95972: LD_VAR 0 3
95976: PPUSH
95977: CALL 97498 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
95981: LD_VAR 0 1
95985: PUSH
95986: LD_INT 255
95988: EQUAL
95989: PUSH
95990: LD_VAR 0 2
95994: PPUSH
95995: CALL_OW 264
95999: PUSH
96000: LD_INT 14
96002: PUSH
96003: LD_INT 53
96005: PUSH
96006: EMPTY
96007: LIST
96008: LIST
96009: IN
96010: AND
96011: PUSH
96012: LD_VAR 0 4
96016: PPUSH
96017: LD_VAR 0 5
96021: PPUSH
96022: CALL_OW 488
96026: AND
96027: IFFALSE 96051
// CutTreeXYR ( unit , x , y , 12 ) ;
96029: LD_VAR 0 2
96033: PPUSH
96034: LD_VAR 0 4
96038: PPUSH
96039: LD_VAR 0 5
96043: PPUSH
96044: LD_INT 12
96046: PPUSH
96047: CALL 96064 0 4
// end ;
96051: LD_VAR 0 6
96055: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
96056: LD_INT 0
96058: PPUSH
// end ;
96059: LD_VAR 0 4
96063: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
96064: LD_INT 0
96066: PPUSH
96067: PPUSH
96068: PPUSH
96069: PPUSH
96070: PPUSH
96071: PPUSH
96072: PPUSH
96073: PPUSH
96074: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
96075: LD_VAR 0 1
96079: NOT
96080: PUSH
96081: LD_VAR 0 2
96085: PPUSH
96086: LD_VAR 0 3
96090: PPUSH
96091: CALL_OW 488
96095: NOT
96096: OR
96097: PUSH
96098: LD_VAR 0 4
96102: NOT
96103: OR
96104: IFFALSE 96108
// exit ;
96106: GO 96448
// list := [ ] ;
96108: LD_ADDR_VAR 0 13
96112: PUSH
96113: EMPTY
96114: ST_TO_ADDR
// if x - r < 0 then
96115: LD_VAR 0 2
96119: PUSH
96120: LD_VAR 0 4
96124: MINUS
96125: PUSH
96126: LD_INT 0
96128: LESS
96129: IFFALSE 96141
// min_x := 0 else
96131: LD_ADDR_VAR 0 7
96135: PUSH
96136: LD_INT 0
96138: ST_TO_ADDR
96139: GO 96157
// min_x := x - r ;
96141: LD_ADDR_VAR 0 7
96145: PUSH
96146: LD_VAR 0 2
96150: PUSH
96151: LD_VAR 0 4
96155: MINUS
96156: ST_TO_ADDR
// if y - r < 0 then
96157: LD_VAR 0 3
96161: PUSH
96162: LD_VAR 0 4
96166: MINUS
96167: PUSH
96168: LD_INT 0
96170: LESS
96171: IFFALSE 96183
// min_y := 0 else
96173: LD_ADDR_VAR 0 8
96177: PUSH
96178: LD_INT 0
96180: ST_TO_ADDR
96181: GO 96199
// min_y := y - r ;
96183: LD_ADDR_VAR 0 8
96187: PUSH
96188: LD_VAR 0 3
96192: PUSH
96193: LD_VAR 0 4
96197: MINUS
96198: ST_TO_ADDR
// max_x := x + r ;
96199: LD_ADDR_VAR 0 9
96203: PUSH
96204: LD_VAR 0 2
96208: PUSH
96209: LD_VAR 0 4
96213: PLUS
96214: ST_TO_ADDR
// max_y := y + r ;
96215: LD_ADDR_VAR 0 10
96219: PUSH
96220: LD_VAR 0 3
96224: PUSH
96225: LD_VAR 0 4
96229: PLUS
96230: ST_TO_ADDR
// for _x = min_x to max_x do
96231: LD_ADDR_VAR 0 11
96235: PUSH
96236: DOUBLE
96237: LD_VAR 0 7
96241: DEC
96242: ST_TO_ADDR
96243: LD_VAR 0 9
96247: PUSH
96248: FOR_TO
96249: IFFALSE 96366
// for _y = min_y to max_y do
96251: LD_ADDR_VAR 0 12
96255: PUSH
96256: DOUBLE
96257: LD_VAR 0 8
96261: DEC
96262: ST_TO_ADDR
96263: LD_VAR 0 10
96267: PUSH
96268: FOR_TO
96269: IFFALSE 96362
// begin if not ValidHex ( _x , _y ) then
96271: LD_VAR 0 11
96275: PPUSH
96276: LD_VAR 0 12
96280: PPUSH
96281: CALL_OW 488
96285: NOT
96286: IFFALSE 96290
// continue ;
96288: GO 96268
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
96290: LD_VAR 0 11
96294: PPUSH
96295: LD_VAR 0 12
96299: PPUSH
96300: CALL_OW 351
96304: PUSH
96305: LD_VAR 0 11
96309: PPUSH
96310: LD_VAR 0 12
96314: PPUSH
96315: CALL_OW 554
96319: AND
96320: IFFALSE 96360
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
96322: LD_ADDR_VAR 0 13
96326: PUSH
96327: LD_VAR 0 13
96331: PPUSH
96332: LD_VAR 0 13
96336: PUSH
96337: LD_INT 1
96339: PLUS
96340: PPUSH
96341: LD_VAR 0 11
96345: PUSH
96346: LD_VAR 0 12
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PPUSH
96355: CALL_OW 2
96359: ST_TO_ADDR
// end ;
96360: GO 96268
96362: POP
96363: POP
96364: GO 96248
96366: POP
96367: POP
// if not list then
96368: LD_VAR 0 13
96372: NOT
96373: IFFALSE 96377
// exit ;
96375: GO 96448
// for i in list do
96377: LD_ADDR_VAR 0 6
96381: PUSH
96382: LD_VAR 0 13
96386: PUSH
96387: FOR_IN
96388: IFFALSE 96446
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
96390: LD_VAR 0 1
96394: PPUSH
96395: LD_STRING M
96397: PUSH
96398: LD_VAR 0 6
96402: PUSH
96403: LD_INT 1
96405: ARRAY
96406: PUSH
96407: LD_VAR 0 6
96411: PUSH
96412: LD_INT 2
96414: ARRAY
96415: PUSH
96416: LD_INT 0
96418: PUSH
96419: LD_INT 0
96421: PUSH
96422: LD_INT 0
96424: PUSH
96425: LD_INT 0
96427: PUSH
96428: EMPTY
96429: LIST
96430: LIST
96431: LIST
96432: LIST
96433: LIST
96434: LIST
96435: LIST
96436: PUSH
96437: EMPTY
96438: LIST
96439: PPUSH
96440: CALL_OW 447
96444: GO 96387
96446: POP
96447: POP
// end ;
96448: LD_VAR 0 5
96452: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
96453: LD_EXP 178
96457: NOT
96458: IFFALSE 96508
96460: GO 96462
96462: DISABLE
// begin initHack := true ;
96463: LD_ADDR_EXP 178
96467: PUSH
96468: LD_INT 1
96470: ST_TO_ADDR
// hackTanks := [ ] ;
96471: LD_ADDR_EXP 179
96475: PUSH
96476: EMPTY
96477: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
96478: LD_ADDR_EXP 180
96482: PUSH
96483: EMPTY
96484: ST_TO_ADDR
// hackLimit := 3 ;
96485: LD_ADDR_EXP 181
96489: PUSH
96490: LD_INT 3
96492: ST_TO_ADDR
// hackDist := 12 ;
96493: LD_ADDR_EXP 182
96497: PUSH
96498: LD_INT 12
96500: ST_TO_ADDR
// hackCounter := [ ] ;
96501: LD_ADDR_EXP 183
96505: PUSH
96506: EMPTY
96507: ST_TO_ADDR
// end ;
96508: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
96509: LD_EXP 178
96513: PUSH
96514: LD_INT 34
96516: PUSH
96517: LD_EXP 105
96521: PUSH
96522: EMPTY
96523: LIST
96524: LIST
96525: PPUSH
96526: CALL_OW 69
96530: AND
96531: IFFALSE 96786
96533: GO 96535
96535: DISABLE
96536: LD_INT 0
96538: PPUSH
96539: PPUSH
// begin enable ;
96540: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
96541: LD_ADDR_VAR 0 1
96545: PUSH
96546: LD_INT 34
96548: PUSH
96549: LD_EXP 105
96553: PUSH
96554: EMPTY
96555: LIST
96556: LIST
96557: PPUSH
96558: CALL_OW 69
96562: PUSH
96563: FOR_IN
96564: IFFALSE 96784
// begin if not i in hackTanks then
96566: LD_VAR 0 1
96570: PUSH
96571: LD_EXP 179
96575: IN
96576: NOT
96577: IFFALSE 96660
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
96579: LD_ADDR_EXP 179
96583: PUSH
96584: LD_EXP 179
96588: PPUSH
96589: LD_EXP 179
96593: PUSH
96594: LD_INT 1
96596: PLUS
96597: PPUSH
96598: LD_VAR 0 1
96602: PPUSH
96603: CALL_OW 1
96607: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
96608: LD_ADDR_EXP 180
96612: PUSH
96613: LD_EXP 180
96617: PPUSH
96618: LD_EXP 180
96622: PUSH
96623: LD_INT 1
96625: PLUS
96626: PPUSH
96627: EMPTY
96628: PPUSH
96629: CALL_OW 1
96633: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
96634: LD_ADDR_EXP 183
96638: PUSH
96639: LD_EXP 183
96643: PPUSH
96644: LD_EXP 183
96648: PUSH
96649: LD_INT 1
96651: PLUS
96652: PPUSH
96653: EMPTY
96654: PPUSH
96655: CALL_OW 1
96659: ST_TO_ADDR
// end ; if not IsOk ( i ) then
96660: LD_VAR 0 1
96664: PPUSH
96665: CALL_OW 302
96669: NOT
96670: IFFALSE 96683
// begin HackUnlinkAll ( i ) ;
96672: LD_VAR 0 1
96676: PPUSH
96677: CALL 96789 0 1
// continue ;
96681: GO 96563
// end ; HackCheckCapturedStatus ( i ) ;
96683: LD_VAR 0 1
96687: PPUSH
96688: CALL 97232 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
96692: LD_ADDR_VAR 0 2
96696: PUSH
96697: LD_INT 81
96699: PUSH
96700: LD_VAR 0 1
96704: PPUSH
96705: CALL_OW 255
96709: PUSH
96710: EMPTY
96711: LIST
96712: LIST
96713: PUSH
96714: LD_INT 33
96716: PUSH
96717: LD_INT 3
96719: PUSH
96720: EMPTY
96721: LIST
96722: LIST
96723: PUSH
96724: LD_INT 91
96726: PUSH
96727: LD_VAR 0 1
96731: PUSH
96732: LD_EXP 182
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: LIST
96741: PUSH
96742: LD_INT 50
96744: PUSH
96745: EMPTY
96746: LIST
96747: PUSH
96748: EMPTY
96749: LIST
96750: LIST
96751: LIST
96752: LIST
96753: PPUSH
96754: CALL_OW 69
96758: ST_TO_ADDR
// if not tmp then
96759: LD_VAR 0 2
96763: NOT
96764: IFFALSE 96768
// continue ;
96766: GO 96563
// HackLink ( i , tmp ) ;
96768: LD_VAR 0 1
96772: PPUSH
96773: LD_VAR 0 2
96777: PPUSH
96778: CALL 96925 0 2
// end ;
96782: GO 96563
96784: POP
96785: POP
// end ;
96786: PPOPN 2
96788: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
96789: LD_INT 0
96791: PPUSH
96792: PPUSH
96793: PPUSH
// if not hack in hackTanks then
96794: LD_VAR 0 1
96798: PUSH
96799: LD_EXP 179
96803: IN
96804: NOT
96805: IFFALSE 96809
// exit ;
96807: GO 96920
// index := GetElementIndex ( hackTanks , hack ) ;
96809: LD_ADDR_VAR 0 4
96813: PUSH
96814: LD_EXP 179
96818: PPUSH
96819: LD_VAR 0 1
96823: PPUSH
96824: CALL 19092 0 2
96828: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
96829: LD_EXP 180
96833: PUSH
96834: LD_VAR 0 4
96838: ARRAY
96839: IFFALSE 96920
// begin for i in hackTanksCaptured [ index ] do
96841: LD_ADDR_VAR 0 3
96845: PUSH
96846: LD_EXP 180
96850: PUSH
96851: LD_VAR 0 4
96855: ARRAY
96856: PUSH
96857: FOR_IN
96858: IFFALSE 96884
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
96860: LD_VAR 0 3
96864: PUSH
96865: LD_INT 1
96867: ARRAY
96868: PPUSH
96869: LD_VAR 0 3
96873: PUSH
96874: LD_INT 2
96876: ARRAY
96877: PPUSH
96878: CALL_OW 235
96882: GO 96857
96884: POP
96885: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
96886: LD_ADDR_EXP 180
96890: PUSH
96891: LD_EXP 180
96895: PPUSH
96896: LD_VAR 0 4
96900: PPUSH
96901: EMPTY
96902: PPUSH
96903: CALL_OW 1
96907: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
96908: LD_VAR 0 1
96912: PPUSH
96913: LD_INT 0
96915: PPUSH
96916: CALL_OW 505
// end ; end ;
96920: LD_VAR 0 2
96924: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
96925: LD_INT 0
96927: PPUSH
96928: PPUSH
96929: PPUSH
// if not hack in hackTanks or not vehicles then
96930: LD_VAR 0 1
96934: PUSH
96935: LD_EXP 179
96939: IN
96940: NOT
96941: PUSH
96942: LD_VAR 0 2
96946: NOT
96947: OR
96948: IFFALSE 96952
// exit ;
96950: GO 97227
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
96952: LD_ADDR_VAR 0 2
96956: PUSH
96957: LD_VAR 0 1
96961: PPUSH
96962: LD_VAR 0 2
96966: PPUSH
96967: LD_INT 1
96969: PPUSH
96970: LD_INT 1
96972: PPUSH
96973: CALL 19742 0 4
96977: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
96978: LD_ADDR_VAR 0 5
96982: PUSH
96983: LD_EXP 179
96987: PPUSH
96988: LD_VAR 0 1
96992: PPUSH
96993: CALL 19092 0 2
96997: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96998: LD_EXP 180
97002: PUSH
97003: LD_VAR 0 5
97007: ARRAY
97008: PUSH
97009: LD_EXP 181
97013: LESS
97014: IFFALSE 97203
// begin for i := 1 to vehicles do
97016: LD_ADDR_VAR 0 4
97020: PUSH
97021: DOUBLE
97022: LD_INT 1
97024: DEC
97025: ST_TO_ADDR
97026: LD_VAR 0 2
97030: PUSH
97031: FOR_TO
97032: IFFALSE 97201
// begin if hackTanksCaptured [ index ] = hackLimit then
97034: LD_EXP 180
97038: PUSH
97039: LD_VAR 0 5
97043: ARRAY
97044: PUSH
97045: LD_EXP 181
97049: EQUAL
97050: IFFALSE 97054
// break ;
97052: GO 97201
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
97054: LD_ADDR_EXP 183
97058: PUSH
97059: LD_EXP 183
97063: PPUSH
97064: LD_VAR 0 5
97068: PPUSH
97069: LD_EXP 183
97073: PUSH
97074: LD_VAR 0 5
97078: ARRAY
97079: PUSH
97080: LD_INT 1
97082: PLUS
97083: PPUSH
97084: CALL_OW 1
97088: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
97089: LD_ADDR_EXP 180
97093: PUSH
97094: LD_EXP 180
97098: PPUSH
97099: LD_VAR 0 5
97103: PUSH
97104: LD_EXP 180
97108: PUSH
97109: LD_VAR 0 5
97113: ARRAY
97114: PUSH
97115: LD_INT 1
97117: PLUS
97118: PUSH
97119: EMPTY
97120: LIST
97121: LIST
97122: PPUSH
97123: LD_VAR 0 2
97127: PUSH
97128: LD_VAR 0 4
97132: ARRAY
97133: PUSH
97134: LD_VAR 0 2
97138: PUSH
97139: LD_VAR 0 4
97143: ARRAY
97144: PPUSH
97145: CALL_OW 255
97149: PUSH
97150: EMPTY
97151: LIST
97152: LIST
97153: PPUSH
97154: CALL 19307 0 3
97158: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
97159: LD_VAR 0 2
97163: PUSH
97164: LD_VAR 0 4
97168: ARRAY
97169: PPUSH
97170: LD_VAR 0 1
97174: PPUSH
97175: CALL_OW 255
97179: PPUSH
97180: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
97184: LD_VAR 0 2
97188: PUSH
97189: LD_VAR 0 4
97193: ARRAY
97194: PPUSH
97195: CALL_OW 141
// end ;
97199: GO 97031
97201: POP
97202: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97203: LD_VAR 0 1
97207: PPUSH
97208: LD_EXP 180
97212: PUSH
97213: LD_VAR 0 5
97217: ARRAY
97218: PUSH
97219: LD_INT 0
97221: PLUS
97222: PPUSH
97223: CALL_OW 505
// end ;
97227: LD_VAR 0 3
97231: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
97232: LD_INT 0
97234: PPUSH
97235: PPUSH
97236: PPUSH
97237: PPUSH
// if not hack in hackTanks then
97238: LD_VAR 0 1
97242: PUSH
97243: LD_EXP 179
97247: IN
97248: NOT
97249: IFFALSE 97253
// exit ;
97251: GO 97493
// index := GetElementIndex ( hackTanks , hack ) ;
97253: LD_ADDR_VAR 0 4
97257: PUSH
97258: LD_EXP 179
97262: PPUSH
97263: LD_VAR 0 1
97267: PPUSH
97268: CALL 19092 0 2
97272: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
97273: LD_ADDR_VAR 0 3
97277: PUSH
97278: DOUBLE
97279: LD_EXP 180
97283: PUSH
97284: LD_VAR 0 4
97288: ARRAY
97289: INC
97290: ST_TO_ADDR
97291: LD_INT 1
97293: PUSH
97294: FOR_DOWNTO
97295: IFFALSE 97467
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
97297: LD_ADDR_VAR 0 5
97301: PUSH
97302: LD_EXP 180
97306: PUSH
97307: LD_VAR 0 4
97311: ARRAY
97312: PUSH
97313: LD_VAR 0 3
97317: ARRAY
97318: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
97319: LD_VAR 0 5
97323: PUSH
97324: LD_INT 1
97326: ARRAY
97327: PPUSH
97328: CALL_OW 302
97332: NOT
97333: PUSH
97334: LD_VAR 0 5
97338: PUSH
97339: LD_INT 1
97341: ARRAY
97342: PPUSH
97343: CALL_OW 255
97347: PUSH
97348: LD_VAR 0 1
97352: PPUSH
97353: CALL_OW 255
97357: NONEQUAL
97358: OR
97359: IFFALSE 97465
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
97361: LD_VAR 0 5
97365: PUSH
97366: LD_INT 1
97368: ARRAY
97369: PPUSH
97370: CALL_OW 305
97374: PUSH
97375: LD_VAR 0 5
97379: PUSH
97380: LD_INT 1
97382: ARRAY
97383: PPUSH
97384: CALL_OW 255
97388: PUSH
97389: LD_VAR 0 1
97393: PPUSH
97394: CALL_OW 255
97398: EQUAL
97399: AND
97400: IFFALSE 97424
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
97402: LD_VAR 0 5
97406: PUSH
97407: LD_INT 1
97409: ARRAY
97410: PPUSH
97411: LD_VAR 0 5
97415: PUSH
97416: LD_INT 2
97418: ARRAY
97419: PPUSH
97420: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
97424: LD_ADDR_EXP 180
97428: PUSH
97429: LD_EXP 180
97433: PPUSH
97434: LD_VAR 0 4
97438: PPUSH
97439: LD_EXP 180
97443: PUSH
97444: LD_VAR 0 4
97448: ARRAY
97449: PPUSH
97450: LD_VAR 0 3
97454: PPUSH
97455: CALL_OW 3
97459: PPUSH
97460: CALL_OW 1
97464: ST_TO_ADDR
// end ; end ;
97465: GO 97294
97467: POP
97468: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
97469: LD_VAR 0 1
97473: PPUSH
97474: LD_EXP 180
97478: PUSH
97479: LD_VAR 0 4
97483: ARRAY
97484: PUSH
97485: LD_INT 0
97487: PLUS
97488: PPUSH
97489: CALL_OW 505
// end ;
97493: LD_VAR 0 2
97497: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
97498: LD_INT 0
97500: PPUSH
97501: PPUSH
97502: PPUSH
97503: PPUSH
// if not hack in hackTanks then
97504: LD_VAR 0 1
97508: PUSH
97509: LD_EXP 179
97513: IN
97514: NOT
97515: IFFALSE 97519
// exit ;
97517: GO 97604
// index := GetElementIndex ( hackTanks , hack ) ;
97519: LD_ADDR_VAR 0 5
97523: PUSH
97524: LD_EXP 179
97528: PPUSH
97529: LD_VAR 0 1
97533: PPUSH
97534: CALL 19092 0 2
97538: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
97539: LD_ADDR_VAR 0 4
97543: PUSH
97544: DOUBLE
97545: LD_INT 1
97547: DEC
97548: ST_TO_ADDR
97549: LD_EXP 180
97553: PUSH
97554: LD_VAR 0 5
97558: ARRAY
97559: PUSH
97560: FOR_TO
97561: IFFALSE 97602
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
97563: LD_EXP 180
97567: PUSH
97568: LD_VAR 0 5
97572: ARRAY
97573: PUSH
97574: LD_VAR 0 4
97578: ARRAY
97579: PUSH
97580: LD_INT 1
97582: ARRAY
97583: PUSH
97584: LD_VAR 0 2
97588: EQUAL
97589: IFFALSE 97600
// KillUnit ( vehicle ) ;
97591: LD_VAR 0 2
97595: PPUSH
97596: CALL_OW 66
97600: GO 97560
97602: POP
97603: POP
// end ;
97604: LD_VAR 0 3
97608: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
97609: LD_EXP 184
97613: NOT
97614: IFFALSE 97649
97616: GO 97618
97618: DISABLE
// begin initMiner := true ;
97619: LD_ADDR_EXP 184
97623: PUSH
97624: LD_INT 1
97626: ST_TO_ADDR
// minersList := [ ] ;
97627: LD_ADDR_EXP 185
97631: PUSH
97632: EMPTY
97633: ST_TO_ADDR
// minerMinesList := [ ] ;
97634: LD_ADDR_EXP 186
97638: PUSH
97639: EMPTY
97640: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
97641: LD_ADDR_EXP 187
97645: PUSH
97646: LD_INT 5
97648: ST_TO_ADDR
// end ;
97649: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
97650: LD_EXP 184
97654: PUSH
97655: LD_INT 34
97657: PUSH
97658: LD_EXP 110
97662: PUSH
97663: EMPTY
97664: LIST
97665: LIST
97666: PPUSH
97667: CALL_OW 69
97671: AND
97672: IFFALSE 98135
97674: GO 97676
97676: DISABLE
97677: LD_INT 0
97679: PPUSH
97680: PPUSH
97681: PPUSH
97682: PPUSH
// begin enable ;
97683: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
97684: LD_ADDR_VAR 0 1
97688: PUSH
97689: LD_INT 34
97691: PUSH
97692: LD_EXP 110
97696: PUSH
97697: EMPTY
97698: LIST
97699: LIST
97700: PPUSH
97701: CALL_OW 69
97705: PUSH
97706: FOR_IN
97707: IFFALSE 97779
// begin if not i in minersList then
97709: LD_VAR 0 1
97713: PUSH
97714: LD_EXP 185
97718: IN
97719: NOT
97720: IFFALSE 97777
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
97722: LD_ADDR_EXP 185
97726: PUSH
97727: LD_EXP 185
97731: PPUSH
97732: LD_EXP 185
97736: PUSH
97737: LD_INT 1
97739: PLUS
97740: PPUSH
97741: LD_VAR 0 1
97745: PPUSH
97746: CALL_OW 1
97750: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
97751: LD_ADDR_EXP 186
97755: PUSH
97756: LD_EXP 186
97760: PPUSH
97761: LD_EXP 186
97765: PUSH
97766: LD_INT 1
97768: PLUS
97769: PPUSH
97770: EMPTY
97771: PPUSH
97772: CALL_OW 1
97776: ST_TO_ADDR
// end end ;
97777: GO 97706
97779: POP
97780: POP
// for i := minerMinesList downto 1 do
97781: LD_ADDR_VAR 0 1
97785: PUSH
97786: DOUBLE
97787: LD_EXP 186
97791: INC
97792: ST_TO_ADDR
97793: LD_INT 1
97795: PUSH
97796: FOR_DOWNTO
97797: IFFALSE 98133
// begin if IsLive ( minersList [ i ] ) then
97799: LD_EXP 185
97803: PUSH
97804: LD_VAR 0 1
97808: ARRAY
97809: PPUSH
97810: CALL_OW 300
97814: IFFALSE 97842
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
97816: LD_EXP 185
97820: PUSH
97821: LD_VAR 0 1
97825: ARRAY
97826: PPUSH
97827: LD_EXP 186
97831: PUSH
97832: LD_VAR 0 1
97836: ARRAY
97837: PPUSH
97838: CALL_OW 505
// if not minerMinesList [ i ] then
97842: LD_EXP 186
97846: PUSH
97847: LD_VAR 0 1
97851: ARRAY
97852: NOT
97853: IFFALSE 97857
// continue ;
97855: GO 97796
// for j := minerMinesList [ i ] downto 1 do
97857: LD_ADDR_VAR 0 2
97861: PUSH
97862: DOUBLE
97863: LD_EXP 186
97867: PUSH
97868: LD_VAR 0 1
97872: ARRAY
97873: INC
97874: ST_TO_ADDR
97875: LD_INT 1
97877: PUSH
97878: FOR_DOWNTO
97879: IFFALSE 98129
// begin side := GetSide ( minersList [ i ] ) ;
97881: LD_ADDR_VAR 0 3
97885: PUSH
97886: LD_EXP 185
97890: PUSH
97891: LD_VAR 0 1
97895: ARRAY
97896: PPUSH
97897: CALL_OW 255
97901: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97902: LD_ADDR_VAR 0 4
97906: PUSH
97907: LD_EXP 186
97911: PUSH
97912: LD_VAR 0 1
97916: ARRAY
97917: PUSH
97918: LD_VAR 0 2
97922: ARRAY
97923: PUSH
97924: LD_INT 1
97926: ARRAY
97927: PPUSH
97928: LD_EXP 186
97932: PUSH
97933: LD_VAR 0 1
97937: ARRAY
97938: PUSH
97939: LD_VAR 0 2
97943: ARRAY
97944: PUSH
97945: LD_INT 2
97947: ARRAY
97948: PPUSH
97949: CALL_OW 428
97953: ST_TO_ADDR
// if not tmp then
97954: LD_VAR 0 4
97958: NOT
97959: IFFALSE 97963
// continue ;
97961: GO 97878
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97963: LD_VAR 0 4
97967: PUSH
97968: LD_INT 81
97970: PUSH
97971: LD_VAR 0 3
97975: PUSH
97976: EMPTY
97977: LIST
97978: LIST
97979: PPUSH
97980: CALL_OW 69
97984: IN
97985: PUSH
97986: LD_EXP 186
97990: PUSH
97991: LD_VAR 0 1
97995: ARRAY
97996: PUSH
97997: LD_VAR 0 2
98001: ARRAY
98002: PUSH
98003: LD_INT 1
98005: ARRAY
98006: PPUSH
98007: LD_EXP 186
98011: PUSH
98012: LD_VAR 0 1
98016: ARRAY
98017: PUSH
98018: LD_VAR 0 2
98022: ARRAY
98023: PUSH
98024: LD_INT 2
98026: ARRAY
98027: PPUSH
98028: CALL_OW 458
98032: AND
98033: IFFALSE 98127
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
98035: LD_EXP 186
98039: PUSH
98040: LD_VAR 0 1
98044: ARRAY
98045: PUSH
98046: LD_VAR 0 2
98050: ARRAY
98051: PUSH
98052: LD_INT 1
98054: ARRAY
98055: PPUSH
98056: LD_EXP 186
98060: PUSH
98061: LD_VAR 0 1
98065: ARRAY
98066: PUSH
98067: LD_VAR 0 2
98071: ARRAY
98072: PUSH
98073: LD_INT 2
98075: ARRAY
98076: PPUSH
98077: LD_VAR 0 3
98081: PPUSH
98082: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
98086: LD_ADDR_EXP 186
98090: PUSH
98091: LD_EXP 186
98095: PPUSH
98096: LD_VAR 0 1
98100: PPUSH
98101: LD_EXP 186
98105: PUSH
98106: LD_VAR 0 1
98110: ARRAY
98111: PPUSH
98112: LD_VAR 0 2
98116: PPUSH
98117: CALL_OW 3
98121: PPUSH
98122: CALL_OW 1
98126: ST_TO_ADDR
// end ; end ;
98127: GO 97878
98129: POP
98130: POP
// end ;
98131: GO 97796
98133: POP
98134: POP
// end ;
98135: PPOPN 4
98137: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
98138: LD_INT 0
98140: PPUSH
98141: PPUSH
// result := false ;
98142: LD_ADDR_VAR 0 4
98146: PUSH
98147: LD_INT 0
98149: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
98150: LD_VAR 0 1
98154: PPUSH
98155: CALL_OW 264
98159: PUSH
98160: LD_EXP 110
98164: EQUAL
98165: NOT
98166: IFFALSE 98170
// exit ;
98168: GO 98410
// index := GetElementIndex ( minersList , unit ) ;
98170: LD_ADDR_VAR 0 5
98174: PUSH
98175: LD_EXP 185
98179: PPUSH
98180: LD_VAR 0 1
98184: PPUSH
98185: CALL 19092 0 2
98189: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
98190: LD_EXP 186
98194: PUSH
98195: LD_VAR 0 5
98199: ARRAY
98200: PUSH
98201: LD_EXP 187
98205: GREATEREQUAL
98206: IFFALSE 98210
// exit ;
98208: GO 98410
// ComMoveXY ( unit , x , y ) ;
98210: LD_VAR 0 1
98214: PPUSH
98215: LD_VAR 0 2
98219: PPUSH
98220: LD_VAR 0 3
98224: PPUSH
98225: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98229: LD_INT 35
98231: PPUSH
98232: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
98236: LD_VAR 0 1
98240: PPUSH
98241: LD_VAR 0 2
98245: PPUSH
98246: LD_VAR 0 3
98250: PPUSH
98251: CALL 49489 0 3
98255: NOT
98256: PUSH
98257: LD_VAR 0 1
98261: PPUSH
98262: CALL_OW 314
98266: AND
98267: IFFALSE 98271
// exit ;
98269: GO 98410
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
98271: LD_VAR 0 2
98275: PPUSH
98276: LD_VAR 0 3
98280: PPUSH
98281: CALL_OW 428
98285: PUSH
98286: LD_VAR 0 1
98290: EQUAL
98291: PUSH
98292: LD_VAR 0 1
98296: PPUSH
98297: CALL_OW 314
98301: NOT
98302: AND
98303: IFFALSE 98229
// PlaySoundXY ( x , y , PlantMine ) ;
98305: LD_VAR 0 2
98309: PPUSH
98310: LD_VAR 0 3
98314: PPUSH
98315: LD_STRING PlantMine
98317: PPUSH
98318: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
98322: LD_VAR 0 2
98326: PPUSH
98327: LD_VAR 0 3
98331: PPUSH
98332: LD_VAR 0 1
98336: PPUSH
98337: CALL_OW 255
98341: PPUSH
98342: LD_INT 0
98344: PPUSH
98345: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
98349: LD_ADDR_EXP 186
98353: PUSH
98354: LD_EXP 186
98358: PPUSH
98359: LD_VAR 0 5
98363: PUSH
98364: LD_EXP 186
98368: PUSH
98369: LD_VAR 0 5
98373: ARRAY
98374: PUSH
98375: LD_INT 1
98377: PLUS
98378: PUSH
98379: EMPTY
98380: LIST
98381: LIST
98382: PPUSH
98383: LD_VAR 0 2
98387: PUSH
98388: LD_VAR 0 3
98392: PUSH
98393: EMPTY
98394: LIST
98395: LIST
98396: PPUSH
98397: CALL 19307 0 3
98401: ST_TO_ADDR
// result := true ;
98402: LD_ADDR_VAR 0 4
98406: PUSH
98407: LD_INT 1
98409: ST_TO_ADDR
// end ;
98410: LD_VAR 0 4
98414: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
98415: LD_INT 0
98417: PPUSH
98418: PPUSH
98419: PPUSH
// if not unit in minersList then
98420: LD_VAR 0 1
98424: PUSH
98425: LD_EXP 185
98429: IN
98430: NOT
98431: IFFALSE 98435
// exit ;
98433: GO 98827
// index := GetElementIndex ( minersList , unit ) ;
98435: LD_ADDR_VAR 0 6
98439: PUSH
98440: LD_EXP 185
98444: PPUSH
98445: LD_VAR 0 1
98449: PPUSH
98450: CALL 19092 0 2
98454: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
98455: LD_ADDR_VAR 0 5
98459: PUSH
98460: DOUBLE
98461: LD_EXP 186
98465: PUSH
98466: LD_VAR 0 6
98470: ARRAY
98471: INC
98472: ST_TO_ADDR
98473: LD_INT 1
98475: PUSH
98476: FOR_DOWNTO
98477: IFFALSE 98638
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
98479: LD_EXP 186
98483: PUSH
98484: LD_VAR 0 6
98488: ARRAY
98489: PUSH
98490: LD_VAR 0 5
98494: ARRAY
98495: PUSH
98496: LD_INT 1
98498: ARRAY
98499: PUSH
98500: LD_VAR 0 2
98504: EQUAL
98505: PUSH
98506: LD_EXP 186
98510: PUSH
98511: LD_VAR 0 6
98515: ARRAY
98516: PUSH
98517: LD_VAR 0 5
98521: ARRAY
98522: PUSH
98523: LD_INT 2
98525: ARRAY
98526: PUSH
98527: LD_VAR 0 3
98531: EQUAL
98532: AND
98533: IFFALSE 98636
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
98535: LD_EXP 186
98539: PUSH
98540: LD_VAR 0 6
98544: ARRAY
98545: PUSH
98546: LD_VAR 0 5
98550: ARRAY
98551: PUSH
98552: LD_INT 1
98554: ARRAY
98555: PPUSH
98556: LD_EXP 186
98560: PUSH
98561: LD_VAR 0 6
98565: ARRAY
98566: PUSH
98567: LD_VAR 0 5
98571: ARRAY
98572: PUSH
98573: LD_INT 2
98575: ARRAY
98576: PPUSH
98577: LD_VAR 0 1
98581: PPUSH
98582: CALL_OW 255
98586: PPUSH
98587: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98591: LD_ADDR_EXP 186
98595: PUSH
98596: LD_EXP 186
98600: PPUSH
98601: LD_VAR 0 6
98605: PPUSH
98606: LD_EXP 186
98610: PUSH
98611: LD_VAR 0 6
98615: ARRAY
98616: PPUSH
98617: LD_VAR 0 5
98621: PPUSH
98622: CALL_OW 3
98626: PPUSH
98627: CALL_OW 1
98631: ST_TO_ADDR
// exit ;
98632: POP
98633: POP
98634: GO 98827
// end ; end ;
98636: GO 98476
98638: POP
98639: POP
// for i := minerMinesList [ index ] downto 1 do
98640: LD_ADDR_VAR 0 5
98644: PUSH
98645: DOUBLE
98646: LD_EXP 186
98650: PUSH
98651: LD_VAR 0 6
98655: ARRAY
98656: INC
98657: ST_TO_ADDR
98658: LD_INT 1
98660: PUSH
98661: FOR_DOWNTO
98662: IFFALSE 98825
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
98664: LD_EXP 186
98668: PUSH
98669: LD_VAR 0 6
98673: ARRAY
98674: PUSH
98675: LD_VAR 0 5
98679: ARRAY
98680: PUSH
98681: LD_INT 1
98683: ARRAY
98684: PPUSH
98685: LD_EXP 186
98689: PUSH
98690: LD_VAR 0 6
98694: ARRAY
98695: PUSH
98696: LD_VAR 0 5
98700: ARRAY
98701: PUSH
98702: LD_INT 2
98704: ARRAY
98705: PPUSH
98706: LD_VAR 0 2
98710: PPUSH
98711: LD_VAR 0 3
98715: PPUSH
98716: CALL_OW 298
98720: PUSH
98721: LD_INT 6
98723: LESS
98724: IFFALSE 98823
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
98726: LD_EXP 186
98730: PUSH
98731: LD_VAR 0 6
98735: ARRAY
98736: PUSH
98737: LD_VAR 0 5
98741: ARRAY
98742: PUSH
98743: LD_INT 1
98745: ARRAY
98746: PPUSH
98747: LD_EXP 186
98751: PUSH
98752: LD_VAR 0 6
98756: ARRAY
98757: PUSH
98758: LD_VAR 0 5
98762: ARRAY
98763: PUSH
98764: LD_INT 2
98766: ARRAY
98767: PPUSH
98768: LD_VAR 0 1
98772: PPUSH
98773: CALL_OW 255
98777: PPUSH
98778: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
98782: LD_ADDR_EXP 186
98786: PUSH
98787: LD_EXP 186
98791: PPUSH
98792: LD_VAR 0 6
98796: PPUSH
98797: LD_EXP 186
98801: PUSH
98802: LD_VAR 0 6
98806: ARRAY
98807: PPUSH
98808: LD_VAR 0 5
98812: PPUSH
98813: CALL_OW 3
98817: PPUSH
98818: CALL_OW 1
98822: ST_TO_ADDR
// end ; end ;
98823: GO 98661
98825: POP
98826: POP
// end ;
98827: LD_VAR 0 4
98831: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
98832: LD_INT 0
98834: PPUSH
98835: PPUSH
98836: PPUSH
98837: PPUSH
98838: PPUSH
98839: PPUSH
98840: PPUSH
98841: PPUSH
98842: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
98843: LD_VAR 0 1
98847: PPUSH
98848: CALL_OW 264
98852: PUSH
98853: LD_EXP 110
98857: EQUAL
98858: NOT
98859: PUSH
98860: LD_VAR 0 1
98864: PUSH
98865: LD_EXP 185
98869: IN
98870: NOT
98871: OR
98872: IFFALSE 98876
// exit ;
98874: GO 99198
// index := GetElementIndex ( minersList , unit ) ;
98876: LD_ADDR_VAR 0 6
98880: PUSH
98881: LD_EXP 185
98885: PPUSH
98886: LD_VAR 0 1
98890: PPUSH
98891: CALL 19092 0 2
98895: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
98896: LD_ADDR_VAR 0 8
98900: PUSH
98901: LD_EXP 187
98905: PUSH
98906: LD_EXP 186
98910: PUSH
98911: LD_VAR 0 6
98915: ARRAY
98916: MINUS
98917: ST_TO_ADDR
// if not minesFreeAmount then
98918: LD_VAR 0 8
98922: NOT
98923: IFFALSE 98927
// exit ;
98925: GO 99198
// tmp := [ ] ;
98927: LD_ADDR_VAR 0 7
98931: PUSH
98932: EMPTY
98933: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98934: LD_ADDR_VAR 0 5
98938: PUSH
98939: DOUBLE
98940: LD_INT 1
98942: DEC
98943: ST_TO_ADDR
98944: LD_VAR 0 8
98948: PUSH
98949: FOR_TO
98950: IFFALSE 99145
// begin _d := rand ( 0 , 5 ) ;
98952: LD_ADDR_VAR 0 11
98956: PUSH
98957: LD_INT 0
98959: PPUSH
98960: LD_INT 5
98962: PPUSH
98963: CALL_OW 12
98967: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98968: LD_ADDR_VAR 0 12
98972: PUSH
98973: LD_INT 2
98975: PPUSH
98976: LD_INT 6
98978: PPUSH
98979: CALL_OW 12
98983: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98984: LD_ADDR_VAR 0 9
98988: PUSH
98989: LD_VAR 0 2
98993: PPUSH
98994: LD_VAR 0 11
98998: PPUSH
98999: LD_VAR 0 12
99003: PPUSH
99004: CALL_OW 272
99008: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
99009: LD_ADDR_VAR 0 10
99013: PUSH
99014: LD_VAR 0 3
99018: PPUSH
99019: LD_VAR 0 11
99023: PPUSH
99024: LD_VAR 0 12
99028: PPUSH
99029: CALL_OW 273
99033: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
99034: LD_VAR 0 9
99038: PPUSH
99039: LD_VAR 0 10
99043: PPUSH
99044: CALL_OW 488
99048: PUSH
99049: LD_VAR 0 9
99053: PUSH
99054: LD_VAR 0 10
99058: PUSH
99059: EMPTY
99060: LIST
99061: LIST
99062: PUSH
99063: LD_VAR 0 7
99067: IN
99068: NOT
99069: AND
99070: PUSH
99071: LD_VAR 0 9
99075: PPUSH
99076: LD_VAR 0 10
99080: PPUSH
99081: CALL_OW 458
99085: NOT
99086: AND
99087: IFFALSE 99129
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
99089: LD_ADDR_VAR 0 7
99093: PUSH
99094: LD_VAR 0 7
99098: PPUSH
99099: LD_VAR 0 7
99103: PUSH
99104: LD_INT 1
99106: PLUS
99107: PPUSH
99108: LD_VAR 0 9
99112: PUSH
99113: LD_VAR 0 10
99117: PUSH
99118: EMPTY
99119: LIST
99120: LIST
99121: PPUSH
99122: CALL_OW 1
99126: ST_TO_ADDR
99127: GO 99143
// i := i - 1 ;
99129: LD_ADDR_VAR 0 5
99133: PUSH
99134: LD_VAR 0 5
99138: PUSH
99139: LD_INT 1
99141: MINUS
99142: ST_TO_ADDR
// end ;
99143: GO 98949
99145: POP
99146: POP
// for i in tmp do
99147: LD_ADDR_VAR 0 5
99151: PUSH
99152: LD_VAR 0 7
99156: PUSH
99157: FOR_IN
99158: IFFALSE 99196
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
99160: LD_VAR 0 1
99164: PPUSH
99165: LD_VAR 0 5
99169: PUSH
99170: LD_INT 1
99172: ARRAY
99173: PPUSH
99174: LD_VAR 0 5
99178: PUSH
99179: LD_INT 2
99181: ARRAY
99182: PPUSH
99183: CALL 98138 0 3
99187: NOT
99188: IFFALSE 99194
// exit ;
99190: POP
99191: POP
99192: GO 99198
99194: GO 99157
99196: POP
99197: POP
// end ;
99198: LD_VAR 0 4
99202: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
99203: LD_INT 0
99205: PPUSH
99206: PPUSH
99207: PPUSH
99208: PPUSH
99209: PPUSH
99210: PPUSH
99211: PPUSH
// if not GetClass ( unit ) = class_sniper then
99212: LD_VAR 0 1
99216: PPUSH
99217: CALL_OW 257
99221: PUSH
99222: LD_INT 5
99224: EQUAL
99225: NOT
99226: IFFALSE 99230
// exit ;
99228: GO 99618
// dist := 8 ;
99230: LD_ADDR_VAR 0 5
99234: PUSH
99235: LD_INT 8
99237: ST_TO_ADDR
// viewRange := 12 ;
99238: LD_ADDR_VAR 0 7
99242: PUSH
99243: LD_INT 12
99245: ST_TO_ADDR
// side := GetSide ( unit ) ;
99246: LD_ADDR_VAR 0 6
99250: PUSH
99251: LD_VAR 0 1
99255: PPUSH
99256: CALL_OW 255
99260: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
99261: LD_INT 61
99263: PPUSH
99264: LD_VAR 0 6
99268: PPUSH
99269: CALL_OW 321
99273: PUSH
99274: LD_INT 2
99276: EQUAL
99277: IFFALSE 99287
// viewRange := 16 ;
99279: LD_ADDR_VAR 0 7
99283: PUSH
99284: LD_INT 16
99286: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
99287: LD_VAR 0 1
99291: PPUSH
99292: LD_VAR 0 2
99296: PPUSH
99297: LD_VAR 0 3
99301: PPUSH
99302: CALL_OW 297
99306: PUSH
99307: LD_VAR 0 5
99311: GREATER
99312: IFFALSE 99391
// begin ComMoveXY ( unit , x , y ) ;
99314: LD_VAR 0 1
99318: PPUSH
99319: LD_VAR 0 2
99323: PPUSH
99324: LD_VAR 0 3
99328: PPUSH
99329: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
99333: LD_INT 35
99335: PPUSH
99336: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
99340: LD_VAR 0 1
99344: PPUSH
99345: LD_VAR 0 2
99349: PPUSH
99350: LD_VAR 0 3
99354: PPUSH
99355: CALL 49489 0 3
99359: NOT
99360: IFFALSE 99364
// exit ;
99362: GO 99618
// until GetDistUnitXY ( unit , x , y ) < dist ;
99364: LD_VAR 0 1
99368: PPUSH
99369: LD_VAR 0 2
99373: PPUSH
99374: LD_VAR 0 3
99378: PPUSH
99379: CALL_OW 297
99383: PUSH
99384: LD_VAR 0 5
99388: LESS
99389: IFFALSE 99333
// end ; ComTurnXY ( unit , x , y ) ;
99391: LD_VAR 0 1
99395: PPUSH
99396: LD_VAR 0 2
99400: PPUSH
99401: LD_VAR 0 3
99405: PPUSH
99406: CALL_OW 118
// wait ( 5 ) ;
99410: LD_INT 5
99412: PPUSH
99413: CALL_OW 67
// _d := GetDir ( unit ) ;
99417: LD_ADDR_VAR 0 10
99421: PUSH
99422: LD_VAR 0 1
99426: PPUSH
99427: CALL_OW 254
99431: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
99432: LD_ADDR_VAR 0 8
99436: PUSH
99437: LD_VAR 0 1
99441: PPUSH
99442: CALL_OW 250
99446: PPUSH
99447: LD_VAR 0 10
99451: PPUSH
99452: LD_VAR 0 5
99456: PPUSH
99457: CALL_OW 272
99461: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
99462: LD_ADDR_VAR 0 9
99466: PUSH
99467: LD_VAR 0 1
99471: PPUSH
99472: CALL_OW 251
99476: PPUSH
99477: LD_VAR 0 10
99481: PPUSH
99482: LD_VAR 0 5
99486: PPUSH
99487: CALL_OW 273
99491: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
99492: LD_VAR 0 8
99496: PPUSH
99497: LD_VAR 0 9
99501: PPUSH
99502: CALL_OW 488
99506: NOT
99507: IFFALSE 99511
// exit ;
99509: GO 99618
// ComAnimCustom ( unit , 1 ) ;
99511: LD_VAR 0 1
99515: PPUSH
99516: LD_INT 1
99518: PPUSH
99519: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
99523: LD_VAR 0 8
99527: PPUSH
99528: LD_VAR 0 9
99532: PPUSH
99533: LD_VAR 0 6
99537: PPUSH
99538: LD_VAR 0 7
99542: PPUSH
99543: CALL_OW 330
// repeat wait ( 1 ) ;
99547: LD_INT 1
99549: PPUSH
99550: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
99554: LD_VAR 0 1
99558: PPUSH
99559: CALL_OW 316
99563: PUSH
99564: LD_VAR 0 1
99568: PPUSH
99569: CALL_OW 314
99573: OR
99574: PUSH
99575: LD_VAR 0 1
99579: PPUSH
99580: CALL_OW 302
99584: NOT
99585: OR
99586: PUSH
99587: LD_VAR 0 1
99591: PPUSH
99592: CALL_OW 301
99596: OR
99597: IFFALSE 99547
// RemoveSeeing ( _x , _y , side ) ;
99599: LD_VAR 0 8
99603: PPUSH
99604: LD_VAR 0 9
99608: PPUSH
99609: LD_VAR 0 6
99613: PPUSH
99614: CALL_OW 331
// end ; end_of_file
99618: LD_VAR 0 4
99622: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
99623: LD_INT 0
99625: PPUSH
99626: PPUSH
99627: PPUSH
99628: PPUSH
99629: PPUSH
99630: PPUSH
99631: PPUSH
99632: PPUSH
99633: PPUSH
99634: PPUSH
99635: PPUSH
99636: PPUSH
99637: PPUSH
99638: PPUSH
99639: PPUSH
99640: PPUSH
99641: PPUSH
99642: PPUSH
99643: PPUSH
99644: PPUSH
99645: PPUSH
99646: PPUSH
99647: PPUSH
99648: PPUSH
99649: PPUSH
99650: PPUSH
99651: PPUSH
99652: PPUSH
99653: PPUSH
99654: PPUSH
99655: PPUSH
99656: PPUSH
99657: PPUSH
99658: PPUSH
// if not list then
99659: LD_VAR 0 1
99663: NOT
99664: IFFALSE 99668
// exit ;
99666: GO 104327
// base := list [ 1 ] ;
99668: LD_ADDR_VAR 0 3
99672: PUSH
99673: LD_VAR 0 1
99677: PUSH
99678: LD_INT 1
99680: ARRAY
99681: ST_TO_ADDR
// group := list [ 2 ] ;
99682: LD_ADDR_VAR 0 4
99686: PUSH
99687: LD_VAR 0 1
99691: PUSH
99692: LD_INT 2
99694: ARRAY
99695: ST_TO_ADDR
// path := list [ 3 ] ;
99696: LD_ADDR_VAR 0 5
99700: PUSH
99701: LD_VAR 0 1
99705: PUSH
99706: LD_INT 3
99708: ARRAY
99709: ST_TO_ADDR
// flags := list [ 4 ] ;
99710: LD_ADDR_VAR 0 6
99714: PUSH
99715: LD_VAR 0 1
99719: PUSH
99720: LD_INT 4
99722: ARRAY
99723: ST_TO_ADDR
// mined := [ ] ;
99724: LD_ADDR_VAR 0 27
99728: PUSH
99729: EMPTY
99730: ST_TO_ADDR
// bombed := [ ] ;
99731: LD_ADDR_VAR 0 28
99735: PUSH
99736: EMPTY
99737: ST_TO_ADDR
// healers := [ ] ;
99738: LD_ADDR_VAR 0 31
99742: PUSH
99743: EMPTY
99744: ST_TO_ADDR
// to_heal := [ ] ;
99745: LD_ADDR_VAR 0 30
99749: PUSH
99750: EMPTY
99751: ST_TO_ADDR
// repairs := [ ] ;
99752: LD_ADDR_VAR 0 33
99756: PUSH
99757: EMPTY
99758: ST_TO_ADDR
// to_repair := [ ] ;
99759: LD_ADDR_VAR 0 32
99763: PUSH
99764: EMPTY
99765: ST_TO_ADDR
// if not group or not path then
99766: LD_VAR 0 4
99770: NOT
99771: PUSH
99772: LD_VAR 0 5
99776: NOT
99777: OR
99778: IFFALSE 99782
// exit ;
99780: GO 104327
// side := GetSide ( group [ 1 ] ) ;
99782: LD_ADDR_VAR 0 35
99786: PUSH
99787: LD_VAR 0 4
99791: PUSH
99792: LD_INT 1
99794: ARRAY
99795: PPUSH
99796: CALL_OW 255
99800: ST_TO_ADDR
// if flags then
99801: LD_VAR 0 6
99805: IFFALSE 99949
// begin f_ignore_area := flags [ 1 ] ;
99807: LD_ADDR_VAR 0 17
99811: PUSH
99812: LD_VAR 0 6
99816: PUSH
99817: LD_INT 1
99819: ARRAY
99820: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
99821: LD_ADDR_VAR 0 18
99825: PUSH
99826: LD_VAR 0 6
99830: PUSH
99831: LD_INT 2
99833: ARRAY
99834: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
99835: LD_ADDR_VAR 0 19
99839: PUSH
99840: LD_VAR 0 6
99844: PUSH
99845: LD_INT 3
99847: ARRAY
99848: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
99849: LD_ADDR_VAR 0 20
99853: PUSH
99854: LD_VAR 0 6
99858: PUSH
99859: LD_INT 4
99861: ARRAY
99862: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
99863: LD_ADDR_VAR 0 21
99867: PUSH
99868: LD_VAR 0 6
99872: PUSH
99873: LD_INT 5
99875: ARRAY
99876: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99877: LD_ADDR_VAR 0 22
99881: PUSH
99882: LD_VAR 0 6
99886: PUSH
99887: LD_INT 6
99889: ARRAY
99890: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99891: LD_ADDR_VAR 0 23
99895: PUSH
99896: LD_VAR 0 6
99900: PUSH
99901: LD_INT 7
99903: ARRAY
99904: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99905: LD_ADDR_VAR 0 24
99909: PUSH
99910: LD_VAR 0 6
99914: PUSH
99915: LD_INT 8
99917: ARRAY
99918: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99919: LD_ADDR_VAR 0 25
99923: PUSH
99924: LD_VAR 0 6
99928: PUSH
99929: LD_INT 9
99931: ARRAY
99932: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99933: LD_ADDR_VAR 0 26
99937: PUSH
99938: LD_VAR 0 6
99942: PUSH
99943: LD_INT 10
99945: ARRAY
99946: ST_TO_ADDR
// end else
99947: GO 100029
// begin f_ignore_area := false ;
99949: LD_ADDR_VAR 0 17
99953: PUSH
99954: LD_INT 0
99956: ST_TO_ADDR
// f_capture := false ;
99957: LD_ADDR_VAR 0 18
99961: PUSH
99962: LD_INT 0
99964: ST_TO_ADDR
// f_ignore_civ := false ;
99965: LD_ADDR_VAR 0 19
99969: PUSH
99970: LD_INT 0
99972: ST_TO_ADDR
// f_murder := false ;
99973: LD_ADDR_VAR 0 20
99977: PUSH
99978: LD_INT 0
99980: ST_TO_ADDR
// f_mines := false ;
99981: LD_ADDR_VAR 0 21
99985: PUSH
99986: LD_INT 0
99988: ST_TO_ADDR
// f_repair := false ;
99989: LD_ADDR_VAR 0 22
99993: PUSH
99994: LD_INT 0
99996: ST_TO_ADDR
// f_heal := false ;
99997: LD_ADDR_VAR 0 23
100001: PUSH
100002: LD_INT 0
100004: ST_TO_ADDR
// f_spacetime := false ;
100005: LD_ADDR_VAR 0 24
100009: PUSH
100010: LD_INT 0
100012: ST_TO_ADDR
// f_attack_depot := false ;
100013: LD_ADDR_VAR 0 25
100017: PUSH
100018: LD_INT 0
100020: ST_TO_ADDR
// f_crawl := false ;
100021: LD_ADDR_VAR 0 26
100025: PUSH
100026: LD_INT 0
100028: ST_TO_ADDR
// end ; if f_heal then
100029: LD_VAR 0 23
100033: IFFALSE 100060
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
100035: LD_ADDR_VAR 0 31
100039: PUSH
100040: LD_VAR 0 4
100044: PPUSH
100045: LD_INT 25
100047: PUSH
100048: LD_INT 4
100050: PUSH
100051: EMPTY
100052: LIST
100053: LIST
100054: PPUSH
100055: CALL_OW 72
100059: ST_TO_ADDR
// if f_repair then
100060: LD_VAR 0 22
100064: IFFALSE 100091
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
100066: LD_ADDR_VAR 0 33
100070: PUSH
100071: LD_VAR 0 4
100075: PPUSH
100076: LD_INT 25
100078: PUSH
100079: LD_INT 3
100081: PUSH
100082: EMPTY
100083: LIST
100084: LIST
100085: PPUSH
100086: CALL_OW 72
100090: ST_TO_ADDR
// units_path := [ ] ;
100091: LD_ADDR_VAR 0 16
100095: PUSH
100096: EMPTY
100097: ST_TO_ADDR
// for i = 1 to group do
100098: LD_ADDR_VAR 0 7
100102: PUSH
100103: DOUBLE
100104: LD_INT 1
100106: DEC
100107: ST_TO_ADDR
100108: LD_VAR 0 4
100112: PUSH
100113: FOR_TO
100114: IFFALSE 100143
// units_path := Replace ( units_path , i , path ) ;
100116: LD_ADDR_VAR 0 16
100120: PUSH
100121: LD_VAR 0 16
100125: PPUSH
100126: LD_VAR 0 7
100130: PPUSH
100131: LD_VAR 0 5
100135: PPUSH
100136: CALL_OW 1
100140: ST_TO_ADDR
100141: GO 100113
100143: POP
100144: POP
// repeat for i = group downto 1 do
100145: LD_ADDR_VAR 0 7
100149: PUSH
100150: DOUBLE
100151: LD_VAR 0 4
100155: INC
100156: ST_TO_ADDR
100157: LD_INT 1
100159: PUSH
100160: FOR_DOWNTO
100161: IFFALSE 104283
// begin wait ( 5 ) ;
100163: LD_INT 5
100165: PPUSH
100166: CALL_OW 67
// tmp := [ ] ;
100170: LD_ADDR_VAR 0 14
100174: PUSH
100175: EMPTY
100176: ST_TO_ADDR
// attacking := false ;
100177: LD_ADDR_VAR 0 29
100181: PUSH
100182: LD_INT 0
100184: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
100185: LD_VAR 0 4
100189: PUSH
100190: LD_VAR 0 7
100194: ARRAY
100195: PPUSH
100196: CALL_OW 301
100200: PUSH
100201: LD_VAR 0 4
100205: PUSH
100206: LD_VAR 0 7
100210: ARRAY
100211: NOT
100212: OR
100213: IFFALSE 100322
// begin if GetType ( group [ i ] ) = unit_human then
100215: LD_VAR 0 4
100219: PUSH
100220: LD_VAR 0 7
100224: ARRAY
100225: PPUSH
100226: CALL_OW 247
100230: PUSH
100231: LD_INT 1
100233: EQUAL
100234: IFFALSE 100280
// begin to_heal := to_heal diff group [ i ] ;
100236: LD_ADDR_VAR 0 30
100240: PUSH
100241: LD_VAR 0 30
100245: PUSH
100246: LD_VAR 0 4
100250: PUSH
100251: LD_VAR 0 7
100255: ARRAY
100256: DIFF
100257: ST_TO_ADDR
// healers := healers diff group [ i ] ;
100258: LD_ADDR_VAR 0 31
100262: PUSH
100263: LD_VAR 0 31
100267: PUSH
100268: LD_VAR 0 4
100272: PUSH
100273: LD_VAR 0 7
100277: ARRAY
100278: DIFF
100279: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
100280: LD_ADDR_VAR 0 4
100284: PUSH
100285: LD_VAR 0 4
100289: PPUSH
100290: LD_VAR 0 7
100294: PPUSH
100295: CALL_OW 3
100299: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
100300: LD_ADDR_VAR 0 16
100304: PUSH
100305: LD_VAR 0 16
100309: PPUSH
100310: LD_VAR 0 7
100314: PPUSH
100315: CALL_OW 3
100319: ST_TO_ADDR
// continue ;
100320: GO 100160
// end ; if f_repair then
100322: LD_VAR 0 22
100326: IFFALSE 100815
// begin if GetType ( group [ i ] ) = unit_vehicle then
100328: LD_VAR 0 4
100332: PUSH
100333: LD_VAR 0 7
100337: ARRAY
100338: PPUSH
100339: CALL_OW 247
100343: PUSH
100344: LD_INT 2
100346: EQUAL
100347: IFFALSE 100537
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
100349: LD_VAR 0 4
100353: PUSH
100354: LD_VAR 0 7
100358: ARRAY
100359: PPUSH
100360: CALL_OW 256
100364: PUSH
100365: LD_INT 700
100367: LESS
100368: PUSH
100369: LD_VAR 0 4
100373: PUSH
100374: LD_VAR 0 7
100378: ARRAY
100379: PUSH
100380: LD_VAR 0 32
100384: IN
100385: NOT
100386: AND
100387: IFFALSE 100411
// to_repair := to_repair union group [ i ] ;
100389: LD_ADDR_VAR 0 32
100393: PUSH
100394: LD_VAR 0 32
100398: PUSH
100399: LD_VAR 0 4
100403: PUSH
100404: LD_VAR 0 7
100408: ARRAY
100409: UNION
100410: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
100411: LD_VAR 0 4
100415: PUSH
100416: LD_VAR 0 7
100420: ARRAY
100421: PPUSH
100422: CALL_OW 256
100426: PUSH
100427: LD_INT 1000
100429: EQUAL
100430: PUSH
100431: LD_VAR 0 4
100435: PUSH
100436: LD_VAR 0 7
100440: ARRAY
100441: PUSH
100442: LD_VAR 0 32
100446: IN
100447: AND
100448: IFFALSE 100472
// to_repair := to_repair diff group [ i ] ;
100450: LD_ADDR_VAR 0 32
100454: PUSH
100455: LD_VAR 0 32
100459: PUSH
100460: LD_VAR 0 4
100464: PUSH
100465: LD_VAR 0 7
100469: ARRAY
100470: DIFF
100471: ST_TO_ADDR
// if group [ i ] in to_repair then
100472: LD_VAR 0 4
100476: PUSH
100477: LD_VAR 0 7
100481: ARRAY
100482: PUSH
100483: LD_VAR 0 32
100487: IN
100488: IFFALSE 100535
// begin if not IsInArea ( group [ i ] , f_repair ) then
100490: LD_VAR 0 4
100494: PUSH
100495: LD_VAR 0 7
100499: ARRAY
100500: PPUSH
100501: LD_VAR 0 22
100505: PPUSH
100506: CALL_OW 308
100510: NOT
100511: IFFALSE 100533
// ComMoveToArea ( group [ i ] , f_repair ) ;
100513: LD_VAR 0 4
100517: PUSH
100518: LD_VAR 0 7
100522: ARRAY
100523: PPUSH
100524: LD_VAR 0 22
100528: PPUSH
100529: CALL_OW 113
// continue ;
100533: GO 100160
// end ; end else
100535: GO 100815
// if group [ i ] in repairs then
100537: LD_VAR 0 4
100541: PUSH
100542: LD_VAR 0 7
100546: ARRAY
100547: PUSH
100548: LD_VAR 0 33
100552: IN
100553: IFFALSE 100815
// begin if IsInUnit ( group [ i ] ) then
100555: LD_VAR 0 4
100559: PUSH
100560: LD_VAR 0 7
100564: ARRAY
100565: PPUSH
100566: CALL_OW 310
100570: IFFALSE 100638
// begin z := IsInUnit ( group [ i ] ) ;
100572: LD_ADDR_VAR 0 13
100576: PUSH
100577: LD_VAR 0 4
100581: PUSH
100582: LD_VAR 0 7
100586: ARRAY
100587: PPUSH
100588: CALL_OW 310
100592: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
100593: LD_VAR 0 13
100597: PUSH
100598: LD_VAR 0 32
100602: IN
100603: PUSH
100604: LD_VAR 0 13
100608: PPUSH
100609: LD_VAR 0 22
100613: PPUSH
100614: CALL_OW 308
100618: AND
100619: IFFALSE 100636
// ComExitVehicle ( group [ i ] ) ;
100621: LD_VAR 0 4
100625: PUSH
100626: LD_VAR 0 7
100630: ARRAY
100631: PPUSH
100632: CALL_OW 121
// end else
100636: GO 100815
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
100638: LD_ADDR_VAR 0 13
100642: PUSH
100643: LD_VAR 0 4
100647: PPUSH
100648: LD_INT 95
100650: PUSH
100651: LD_VAR 0 22
100655: PUSH
100656: EMPTY
100657: LIST
100658: LIST
100659: PUSH
100660: LD_INT 58
100662: PUSH
100663: EMPTY
100664: LIST
100665: PUSH
100666: EMPTY
100667: LIST
100668: LIST
100669: PPUSH
100670: CALL_OW 72
100674: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
100675: LD_VAR 0 4
100679: PUSH
100680: LD_VAR 0 7
100684: ARRAY
100685: PPUSH
100686: CALL_OW 314
100690: NOT
100691: IFFALSE 100813
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
100693: LD_ADDR_VAR 0 10
100697: PUSH
100698: LD_VAR 0 13
100702: PPUSH
100703: LD_VAR 0 4
100707: PUSH
100708: LD_VAR 0 7
100712: ARRAY
100713: PPUSH
100714: CALL_OW 74
100718: ST_TO_ADDR
// if not x then
100719: LD_VAR 0 10
100723: NOT
100724: IFFALSE 100728
// continue ;
100726: GO 100160
// if GetLives ( x ) < 1000 then
100728: LD_VAR 0 10
100732: PPUSH
100733: CALL_OW 256
100737: PUSH
100738: LD_INT 1000
100740: LESS
100741: IFFALSE 100765
// ComRepairVehicle ( group [ i ] , x ) else
100743: LD_VAR 0 4
100747: PUSH
100748: LD_VAR 0 7
100752: ARRAY
100753: PPUSH
100754: LD_VAR 0 10
100758: PPUSH
100759: CALL_OW 129
100763: GO 100813
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
100765: LD_VAR 0 23
100769: PUSH
100770: LD_VAR 0 4
100774: PUSH
100775: LD_VAR 0 7
100779: ARRAY
100780: PPUSH
100781: CALL_OW 256
100785: PUSH
100786: LD_INT 1000
100788: LESS
100789: AND
100790: NOT
100791: IFFALSE 100813
// ComEnterUnit ( group [ i ] , x ) ;
100793: LD_VAR 0 4
100797: PUSH
100798: LD_VAR 0 7
100802: ARRAY
100803: PPUSH
100804: LD_VAR 0 10
100808: PPUSH
100809: CALL_OW 120
// end ; continue ;
100813: GO 100160
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
100815: LD_VAR 0 23
100819: PUSH
100820: LD_VAR 0 4
100824: PUSH
100825: LD_VAR 0 7
100829: ARRAY
100830: PPUSH
100831: CALL_OW 247
100835: PUSH
100836: LD_INT 1
100838: EQUAL
100839: AND
100840: IFFALSE 101318
// begin if group [ i ] in healers then
100842: LD_VAR 0 4
100846: PUSH
100847: LD_VAR 0 7
100851: ARRAY
100852: PUSH
100853: LD_VAR 0 31
100857: IN
100858: IFFALSE 101131
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
100860: LD_VAR 0 4
100864: PUSH
100865: LD_VAR 0 7
100869: ARRAY
100870: PPUSH
100871: LD_VAR 0 23
100875: PPUSH
100876: CALL_OW 308
100880: NOT
100881: PUSH
100882: LD_VAR 0 4
100886: PUSH
100887: LD_VAR 0 7
100891: ARRAY
100892: PPUSH
100893: CALL_OW 314
100897: NOT
100898: AND
100899: IFFALSE 100923
// ComMoveToArea ( group [ i ] , f_heal ) else
100901: LD_VAR 0 4
100905: PUSH
100906: LD_VAR 0 7
100910: ARRAY
100911: PPUSH
100912: LD_VAR 0 23
100916: PPUSH
100917: CALL_OW 113
100921: GO 101129
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100923: LD_VAR 0 4
100927: PUSH
100928: LD_VAR 0 7
100932: ARRAY
100933: PPUSH
100934: CALL 48012 0 1
100938: PPUSH
100939: CALL_OW 256
100943: PUSH
100944: LD_INT 1000
100946: EQUAL
100947: IFFALSE 100966
// ComStop ( group [ i ] ) else
100949: LD_VAR 0 4
100953: PUSH
100954: LD_VAR 0 7
100958: ARRAY
100959: PPUSH
100960: CALL_OW 141
100964: GO 101129
// if not HasTask ( group [ i ] ) and to_heal then
100966: LD_VAR 0 4
100970: PUSH
100971: LD_VAR 0 7
100975: ARRAY
100976: PPUSH
100977: CALL_OW 314
100981: NOT
100982: PUSH
100983: LD_VAR 0 30
100987: AND
100988: IFFALSE 101129
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100990: LD_ADDR_VAR 0 13
100994: PUSH
100995: LD_VAR 0 30
100999: PPUSH
101000: LD_INT 3
101002: PUSH
101003: LD_INT 54
101005: PUSH
101006: EMPTY
101007: LIST
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PPUSH
101013: CALL_OW 72
101017: PPUSH
101018: LD_VAR 0 4
101022: PUSH
101023: LD_VAR 0 7
101027: ARRAY
101028: PPUSH
101029: CALL_OW 74
101033: ST_TO_ADDR
// if z then
101034: LD_VAR 0 13
101038: IFFALSE 101129
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
101040: LD_INT 91
101042: PUSH
101043: LD_VAR 0 13
101047: PUSH
101048: LD_INT 10
101050: PUSH
101051: EMPTY
101052: LIST
101053: LIST
101054: LIST
101055: PUSH
101056: LD_INT 81
101058: PUSH
101059: LD_VAR 0 13
101063: PPUSH
101064: CALL_OW 255
101068: PUSH
101069: EMPTY
101070: LIST
101071: LIST
101072: PUSH
101073: EMPTY
101074: LIST
101075: LIST
101076: PPUSH
101077: CALL_OW 69
101081: PUSH
101082: LD_INT 0
101084: EQUAL
101085: IFFALSE 101109
// ComHeal ( group [ i ] , z ) else
101087: LD_VAR 0 4
101091: PUSH
101092: LD_VAR 0 7
101096: ARRAY
101097: PPUSH
101098: LD_VAR 0 13
101102: PPUSH
101103: CALL_OW 128
101107: GO 101129
// ComMoveToArea ( group [ i ] , f_heal ) ;
101109: LD_VAR 0 4
101113: PUSH
101114: LD_VAR 0 7
101118: ARRAY
101119: PPUSH
101120: LD_VAR 0 23
101124: PPUSH
101125: CALL_OW 113
// end ; continue ;
101129: GO 100160
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
101131: LD_VAR 0 4
101135: PUSH
101136: LD_VAR 0 7
101140: ARRAY
101141: PPUSH
101142: CALL_OW 256
101146: PUSH
101147: LD_INT 700
101149: LESS
101150: PUSH
101151: LD_VAR 0 4
101155: PUSH
101156: LD_VAR 0 7
101160: ARRAY
101161: PUSH
101162: LD_VAR 0 30
101166: IN
101167: NOT
101168: AND
101169: IFFALSE 101193
// to_heal := to_heal union group [ i ] ;
101171: LD_ADDR_VAR 0 30
101175: PUSH
101176: LD_VAR 0 30
101180: PUSH
101181: LD_VAR 0 4
101185: PUSH
101186: LD_VAR 0 7
101190: ARRAY
101191: UNION
101192: ST_TO_ADDR
// if group [ i ] in to_heal then
101193: LD_VAR 0 4
101197: PUSH
101198: LD_VAR 0 7
101202: ARRAY
101203: PUSH
101204: LD_VAR 0 30
101208: IN
101209: IFFALSE 101318
// begin if GetLives ( group [ i ] ) = 1000 then
101211: LD_VAR 0 4
101215: PUSH
101216: LD_VAR 0 7
101220: ARRAY
101221: PPUSH
101222: CALL_OW 256
101226: PUSH
101227: LD_INT 1000
101229: EQUAL
101230: IFFALSE 101256
// to_heal := to_heal diff group [ i ] else
101232: LD_ADDR_VAR 0 30
101236: PUSH
101237: LD_VAR 0 30
101241: PUSH
101242: LD_VAR 0 4
101246: PUSH
101247: LD_VAR 0 7
101251: ARRAY
101252: DIFF
101253: ST_TO_ADDR
101254: GO 101318
// begin if not IsInArea ( group [ i ] , to_heal ) then
101256: LD_VAR 0 4
101260: PUSH
101261: LD_VAR 0 7
101265: ARRAY
101266: PPUSH
101267: LD_VAR 0 30
101271: PPUSH
101272: CALL_OW 308
101276: NOT
101277: IFFALSE 101301
// ComMoveToArea ( group [ i ] , f_heal ) else
101279: LD_VAR 0 4
101283: PUSH
101284: LD_VAR 0 7
101288: ARRAY
101289: PPUSH
101290: LD_VAR 0 23
101294: PPUSH
101295: CALL_OW 113
101299: GO 101316
// ComHold ( group [ i ] ) ;
101301: LD_VAR 0 4
101305: PUSH
101306: LD_VAR 0 7
101310: ARRAY
101311: PPUSH
101312: CALL_OW 140
// continue ;
101316: GO 100160
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
101318: LD_VAR 0 4
101322: PUSH
101323: LD_VAR 0 7
101327: ARRAY
101328: PPUSH
101329: LD_INT 10
101331: PPUSH
101332: CALL 46432 0 2
101336: NOT
101337: PUSH
101338: LD_VAR 0 16
101342: PUSH
101343: LD_VAR 0 7
101347: ARRAY
101348: PUSH
101349: EMPTY
101350: EQUAL
101351: NOT
101352: AND
101353: IFFALSE 101619
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
101355: LD_VAR 0 4
101359: PUSH
101360: LD_VAR 0 7
101364: ARRAY
101365: PPUSH
101366: CALL_OW 262
101370: PUSH
101371: LD_INT 1
101373: PUSH
101374: LD_INT 2
101376: PUSH
101377: EMPTY
101378: LIST
101379: LIST
101380: IN
101381: IFFALSE 101422
// if GetFuel ( group [ i ] ) < 10 then
101383: LD_VAR 0 4
101387: PUSH
101388: LD_VAR 0 7
101392: ARRAY
101393: PPUSH
101394: CALL_OW 261
101398: PUSH
101399: LD_INT 10
101401: LESS
101402: IFFALSE 101422
// SetFuel ( group [ i ] , 12 ) ;
101404: LD_VAR 0 4
101408: PUSH
101409: LD_VAR 0 7
101413: ARRAY
101414: PPUSH
101415: LD_INT 12
101417: PPUSH
101418: CALL_OW 240
// if units_path [ i ] then
101422: LD_VAR 0 16
101426: PUSH
101427: LD_VAR 0 7
101431: ARRAY
101432: IFFALSE 101617
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
101434: LD_VAR 0 4
101438: PUSH
101439: LD_VAR 0 7
101443: ARRAY
101444: PPUSH
101445: LD_VAR 0 16
101449: PUSH
101450: LD_VAR 0 7
101454: ARRAY
101455: PUSH
101456: LD_INT 1
101458: ARRAY
101459: PUSH
101460: LD_INT 1
101462: ARRAY
101463: PPUSH
101464: LD_VAR 0 16
101468: PUSH
101469: LD_VAR 0 7
101473: ARRAY
101474: PUSH
101475: LD_INT 1
101477: ARRAY
101478: PUSH
101479: LD_INT 2
101481: ARRAY
101482: PPUSH
101483: CALL_OW 297
101487: PUSH
101488: LD_INT 6
101490: GREATER
101491: IFFALSE 101566
// begin if not HasTask ( group [ i ] ) then
101493: LD_VAR 0 4
101497: PUSH
101498: LD_VAR 0 7
101502: ARRAY
101503: PPUSH
101504: CALL_OW 314
101508: NOT
101509: IFFALSE 101564
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
101511: LD_VAR 0 4
101515: PUSH
101516: LD_VAR 0 7
101520: ARRAY
101521: PPUSH
101522: LD_VAR 0 16
101526: PUSH
101527: LD_VAR 0 7
101531: ARRAY
101532: PUSH
101533: LD_INT 1
101535: ARRAY
101536: PUSH
101537: LD_INT 1
101539: ARRAY
101540: PPUSH
101541: LD_VAR 0 16
101545: PUSH
101546: LD_VAR 0 7
101550: ARRAY
101551: PUSH
101552: LD_INT 1
101554: ARRAY
101555: PUSH
101556: LD_INT 2
101558: ARRAY
101559: PPUSH
101560: CALL_OW 114
// end else
101564: GO 101617
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
101566: LD_ADDR_VAR 0 15
101570: PUSH
101571: LD_VAR 0 16
101575: PUSH
101576: LD_VAR 0 7
101580: ARRAY
101581: PPUSH
101582: LD_INT 1
101584: PPUSH
101585: CALL_OW 3
101589: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
101590: LD_ADDR_VAR 0 16
101594: PUSH
101595: LD_VAR 0 16
101599: PPUSH
101600: LD_VAR 0 7
101604: PPUSH
101605: LD_VAR 0 15
101609: PPUSH
101610: CALL_OW 1
101614: ST_TO_ADDR
// continue ;
101615: GO 100160
// end ; end ; end else
101617: GO 104281
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
101619: LD_ADDR_VAR 0 14
101623: PUSH
101624: LD_INT 81
101626: PUSH
101627: LD_VAR 0 4
101631: PUSH
101632: LD_VAR 0 7
101636: ARRAY
101637: PPUSH
101638: CALL_OW 255
101642: PUSH
101643: EMPTY
101644: LIST
101645: LIST
101646: PPUSH
101647: CALL_OW 69
101651: ST_TO_ADDR
// if not tmp then
101652: LD_VAR 0 14
101656: NOT
101657: IFFALSE 101661
// continue ;
101659: GO 100160
// if f_ignore_area then
101661: LD_VAR 0 17
101665: IFFALSE 101753
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
101667: LD_ADDR_VAR 0 15
101671: PUSH
101672: LD_VAR 0 14
101676: PPUSH
101677: LD_INT 3
101679: PUSH
101680: LD_INT 92
101682: PUSH
101683: LD_VAR 0 17
101687: PUSH
101688: LD_INT 1
101690: ARRAY
101691: PUSH
101692: LD_VAR 0 17
101696: PUSH
101697: LD_INT 2
101699: ARRAY
101700: PUSH
101701: LD_VAR 0 17
101705: PUSH
101706: LD_INT 3
101708: ARRAY
101709: PUSH
101710: EMPTY
101711: LIST
101712: LIST
101713: LIST
101714: LIST
101715: PUSH
101716: EMPTY
101717: LIST
101718: LIST
101719: PPUSH
101720: CALL_OW 72
101724: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101725: LD_VAR 0 14
101729: PUSH
101730: LD_VAR 0 15
101734: DIFF
101735: IFFALSE 101753
// tmp := tmp diff tmp2 ;
101737: LD_ADDR_VAR 0 14
101741: PUSH
101742: LD_VAR 0 14
101746: PUSH
101747: LD_VAR 0 15
101751: DIFF
101752: ST_TO_ADDR
// end ; if not f_murder then
101753: LD_VAR 0 20
101757: NOT
101758: IFFALSE 101816
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
101760: LD_ADDR_VAR 0 15
101764: PUSH
101765: LD_VAR 0 14
101769: PPUSH
101770: LD_INT 3
101772: PUSH
101773: LD_INT 50
101775: PUSH
101776: EMPTY
101777: LIST
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: PPUSH
101783: CALL_OW 72
101787: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
101788: LD_VAR 0 14
101792: PUSH
101793: LD_VAR 0 15
101797: DIFF
101798: IFFALSE 101816
// tmp := tmp diff tmp2 ;
101800: LD_ADDR_VAR 0 14
101804: PUSH
101805: LD_VAR 0 14
101809: PUSH
101810: LD_VAR 0 15
101814: DIFF
101815: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
101816: LD_ADDR_VAR 0 14
101820: PUSH
101821: LD_VAR 0 4
101825: PUSH
101826: LD_VAR 0 7
101830: ARRAY
101831: PPUSH
101832: LD_VAR 0 14
101836: PPUSH
101837: LD_INT 1
101839: PPUSH
101840: LD_INT 1
101842: PPUSH
101843: CALL 19742 0 4
101847: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
101848: LD_VAR 0 4
101852: PUSH
101853: LD_VAR 0 7
101857: ARRAY
101858: PPUSH
101859: CALL_OW 257
101863: PUSH
101864: LD_INT 1
101866: EQUAL
101867: IFFALSE 102315
// begin if WantPlant ( group [ i ] ) then
101869: LD_VAR 0 4
101873: PUSH
101874: LD_VAR 0 7
101878: ARRAY
101879: PPUSH
101880: CALL 19243 0 1
101884: IFFALSE 101888
// continue ;
101886: GO 100160
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101888: LD_VAR 0 18
101892: PUSH
101893: LD_VAR 0 4
101897: PUSH
101898: LD_VAR 0 7
101902: ARRAY
101903: PPUSH
101904: CALL_OW 310
101908: NOT
101909: AND
101910: PUSH
101911: LD_VAR 0 14
101915: PUSH
101916: LD_INT 1
101918: ARRAY
101919: PUSH
101920: LD_VAR 0 14
101924: PPUSH
101925: LD_INT 21
101927: PUSH
101928: LD_INT 2
101930: PUSH
101931: EMPTY
101932: LIST
101933: LIST
101934: PUSH
101935: LD_INT 58
101937: PUSH
101938: EMPTY
101939: LIST
101940: PUSH
101941: EMPTY
101942: LIST
101943: LIST
101944: PPUSH
101945: CALL_OW 72
101949: IN
101950: AND
101951: IFFALSE 101987
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101953: LD_VAR 0 4
101957: PUSH
101958: LD_VAR 0 7
101962: ARRAY
101963: PPUSH
101964: LD_VAR 0 14
101968: PUSH
101969: LD_INT 1
101971: ARRAY
101972: PPUSH
101973: CALL_OW 120
// attacking := true ;
101977: LD_ADDR_VAR 0 29
101981: PUSH
101982: LD_INT 1
101984: ST_TO_ADDR
// continue ;
101985: GO 100160
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101987: LD_VAR 0 26
101991: PUSH
101992: LD_VAR 0 4
101996: PUSH
101997: LD_VAR 0 7
102001: ARRAY
102002: PPUSH
102003: CALL_OW 257
102007: PUSH
102008: LD_INT 1
102010: EQUAL
102011: AND
102012: PUSH
102013: LD_VAR 0 4
102017: PUSH
102018: LD_VAR 0 7
102022: ARRAY
102023: PPUSH
102024: CALL_OW 256
102028: PUSH
102029: LD_INT 800
102031: LESS
102032: AND
102033: PUSH
102034: LD_VAR 0 4
102038: PUSH
102039: LD_VAR 0 7
102043: ARRAY
102044: PPUSH
102045: CALL_OW 318
102049: NOT
102050: AND
102051: IFFALSE 102068
// ComCrawl ( group [ i ] ) ;
102053: LD_VAR 0 4
102057: PUSH
102058: LD_VAR 0 7
102062: ARRAY
102063: PPUSH
102064: CALL_OW 137
// if f_mines then
102068: LD_VAR 0 21
102072: IFFALSE 102315
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
102074: LD_VAR 0 14
102078: PUSH
102079: LD_INT 1
102081: ARRAY
102082: PPUSH
102083: CALL_OW 247
102087: PUSH
102088: LD_INT 3
102090: EQUAL
102091: PUSH
102092: LD_VAR 0 14
102096: PUSH
102097: LD_INT 1
102099: ARRAY
102100: PUSH
102101: LD_VAR 0 27
102105: IN
102106: NOT
102107: AND
102108: IFFALSE 102315
// begin x := GetX ( tmp [ 1 ] ) ;
102110: LD_ADDR_VAR 0 10
102114: PUSH
102115: LD_VAR 0 14
102119: PUSH
102120: LD_INT 1
102122: ARRAY
102123: PPUSH
102124: CALL_OW 250
102128: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
102129: LD_ADDR_VAR 0 11
102133: PUSH
102134: LD_VAR 0 14
102138: PUSH
102139: LD_INT 1
102141: ARRAY
102142: PPUSH
102143: CALL_OW 251
102147: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
102148: LD_ADDR_VAR 0 12
102152: PUSH
102153: LD_VAR 0 4
102157: PUSH
102158: LD_VAR 0 7
102162: ARRAY
102163: PPUSH
102164: CALL 46517 0 1
102168: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
102169: LD_VAR 0 4
102173: PUSH
102174: LD_VAR 0 7
102178: ARRAY
102179: PPUSH
102180: LD_VAR 0 10
102184: PPUSH
102185: LD_VAR 0 11
102189: PPUSH
102190: LD_VAR 0 14
102194: PUSH
102195: LD_INT 1
102197: ARRAY
102198: PPUSH
102199: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
102203: LD_VAR 0 4
102207: PUSH
102208: LD_VAR 0 7
102212: ARRAY
102213: PPUSH
102214: LD_VAR 0 10
102218: PPUSH
102219: LD_VAR 0 12
102223: PPUSH
102224: LD_INT 7
102226: PPUSH
102227: CALL_OW 272
102231: PPUSH
102232: LD_VAR 0 11
102236: PPUSH
102237: LD_VAR 0 12
102241: PPUSH
102242: LD_INT 7
102244: PPUSH
102245: CALL_OW 273
102249: PPUSH
102250: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
102254: LD_VAR 0 4
102258: PUSH
102259: LD_VAR 0 7
102263: ARRAY
102264: PPUSH
102265: LD_INT 71
102267: PPUSH
102268: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
102272: LD_ADDR_VAR 0 27
102276: PUSH
102277: LD_VAR 0 27
102281: PPUSH
102282: LD_VAR 0 27
102286: PUSH
102287: LD_INT 1
102289: PLUS
102290: PPUSH
102291: LD_VAR 0 14
102295: PUSH
102296: LD_INT 1
102298: ARRAY
102299: PPUSH
102300: CALL_OW 1
102304: ST_TO_ADDR
// attacking := true ;
102305: LD_ADDR_VAR 0 29
102309: PUSH
102310: LD_INT 1
102312: ST_TO_ADDR
// continue ;
102313: GO 100160
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
102315: LD_VAR 0 4
102319: PUSH
102320: LD_VAR 0 7
102324: ARRAY
102325: PPUSH
102326: CALL_OW 257
102330: PUSH
102331: LD_INT 17
102333: EQUAL
102334: PUSH
102335: LD_VAR 0 4
102339: PUSH
102340: LD_VAR 0 7
102344: ARRAY
102345: PPUSH
102346: CALL_OW 110
102350: PUSH
102351: LD_INT 71
102353: EQUAL
102354: NOT
102355: AND
102356: IFFALSE 102502
// begin attacking := false ;
102358: LD_ADDR_VAR 0 29
102362: PUSH
102363: LD_INT 0
102365: ST_TO_ADDR
// k := 5 ;
102366: LD_ADDR_VAR 0 9
102370: PUSH
102371: LD_INT 5
102373: ST_TO_ADDR
// if tmp < k then
102374: LD_VAR 0 14
102378: PUSH
102379: LD_VAR 0 9
102383: LESS
102384: IFFALSE 102396
// k := tmp ;
102386: LD_ADDR_VAR 0 9
102390: PUSH
102391: LD_VAR 0 14
102395: ST_TO_ADDR
// for j = 1 to k do
102396: LD_ADDR_VAR 0 8
102400: PUSH
102401: DOUBLE
102402: LD_INT 1
102404: DEC
102405: ST_TO_ADDR
102406: LD_VAR 0 9
102410: PUSH
102411: FOR_TO
102412: IFFALSE 102500
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
102414: LD_VAR 0 14
102418: PUSH
102419: LD_VAR 0 8
102423: ARRAY
102424: PUSH
102425: LD_VAR 0 14
102429: PPUSH
102430: LD_INT 58
102432: PUSH
102433: EMPTY
102434: LIST
102435: PPUSH
102436: CALL_OW 72
102440: IN
102441: NOT
102442: IFFALSE 102498
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102444: LD_VAR 0 4
102448: PUSH
102449: LD_VAR 0 7
102453: ARRAY
102454: PPUSH
102455: LD_VAR 0 14
102459: PUSH
102460: LD_VAR 0 8
102464: ARRAY
102465: PPUSH
102466: CALL_OW 115
// attacking := true ;
102470: LD_ADDR_VAR 0 29
102474: PUSH
102475: LD_INT 1
102477: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
102478: LD_VAR 0 4
102482: PUSH
102483: LD_VAR 0 7
102487: ARRAY
102488: PPUSH
102489: LD_INT 71
102491: PPUSH
102492: CALL_OW 109
// continue ;
102496: GO 102411
// end ; end ;
102498: GO 102411
102500: POP
102501: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
102502: LD_VAR 0 4
102506: PUSH
102507: LD_VAR 0 7
102511: ARRAY
102512: PPUSH
102513: CALL_OW 257
102517: PUSH
102518: LD_INT 8
102520: EQUAL
102521: PUSH
102522: LD_VAR 0 4
102526: PUSH
102527: LD_VAR 0 7
102531: ARRAY
102532: PPUSH
102533: CALL_OW 264
102537: PUSH
102538: LD_INT 28
102540: PUSH
102541: LD_INT 45
102543: PUSH
102544: LD_INT 7
102546: PUSH
102547: LD_INT 47
102549: PUSH
102550: EMPTY
102551: LIST
102552: LIST
102553: LIST
102554: LIST
102555: IN
102556: OR
102557: IFFALSE 102813
// begin attacking := false ;
102559: LD_ADDR_VAR 0 29
102563: PUSH
102564: LD_INT 0
102566: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
102567: LD_VAR 0 14
102571: PUSH
102572: LD_INT 1
102574: ARRAY
102575: PPUSH
102576: CALL_OW 266
102580: PUSH
102581: LD_INT 32
102583: PUSH
102584: LD_INT 31
102586: PUSH
102587: LD_INT 33
102589: PUSH
102590: LD_INT 4
102592: PUSH
102593: LD_INT 5
102595: PUSH
102596: EMPTY
102597: LIST
102598: LIST
102599: LIST
102600: LIST
102601: LIST
102602: IN
102603: IFFALSE 102789
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
102605: LD_ADDR_VAR 0 9
102609: PUSH
102610: LD_VAR 0 14
102614: PUSH
102615: LD_INT 1
102617: ARRAY
102618: PPUSH
102619: CALL_OW 266
102623: PPUSH
102624: LD_VAR 0 14
102628: PUSH
102629: LD_INT 1
102631: ARRAY
102632: PPUSH
102633: CALL_OW 250
102637: PPUSH
102638: LD_VAR 0 14
102642: PUSH
102643: LD_INT 1
102645: ARRAY
102646: PPUSH
102647: CALL_OW 251
102651: PPUSH
102652: LD_VAR 0 14
102656: PUSH
102657: LD_INT 1
102659: ARRAY
102660: PPUSH
102661: CALL_OW 254
102665: PPUSH
102666: LD_VAR 0 14
102670: PUSH
102671: LD_INT 1
102673: ARRAY
102674: PPUSH
102675: CALL_OW 248
102679: PPUSH
102680: LD_INT 0
102682: PPUSH
102683: CALL 27887 0 6
102687: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
102688: LD_ADDR_VAR 0 8
102692: PUSH
102693: LD_VAR 0 4
102697: PUSH
102698: LD_VAR 0 7
102702: ARRAY
102703: PPUSH
102704: LD_VAR 0 9
102708: PPUSH
102709: CALL 46557 0 2
102713: ST_TO_ADDR
// if j then
102714: LD_VAR 0 8
102718: IFFALSE 102787
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
102720: LD_VAR 0 8
102724: PUSH
102725: LD_INT 1
102727: ARRAY
102728: PPUSH
102729: LD_VAR 0 8
102733: PUSH
102734: LD_INT 2
102736: ARRAY
102737: PPUSH
102738: CALL_OW 488
102742: IFFALSE 102787
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
102744: LD_VAR 0 4
102748: PUSH
102749: LD_VAR 0 7
102753: ARRAY
102754: PPUSH
102755: LD_VAR 0 8
102759: PUSH
102760: LD_INT 1
102762: ARRAY
102763: PPUSH
102764: LD_VAR 0 8
102768: PUSH
102769: LD_INT 2
102771: ARRAY
102772: PPUSH
102773: CALL_OW 116
// attacking := true ;
102777: LD_ADDR_VAR 0 29
102781: PUSH
102782: LD_INT 1
102784: ST_TO_ADDR
// continue ;
102785: GO 100160
// end ; end else
102787: GO 102813
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102789: LD_VAR 0 4
102793: PUSH
102794: LD_VAR 0 7
102798: ARRAY
102799: PPUSH
102800: LD_VAR 0 14
102804: PUSH
102805: LD_INT 1
102807: ARRAY
102808: PPUSH
102809: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
102813: LD_VAR 0 4
102817: PUSH
102818: LD_VAR 0 7
102822: ARRAY
102823: PPUSH
102824: CALL_OW 265
102828: PUSH
102829: LD_INT 11
102831: EQUAL
102832: IFFALSE 103110
// begin k := 10 ;
102834: LD_ADDR_VAR 0 9
102838: PUSH
102839: LD_INT 10
102841: ST_TO_ADDR
// x := 0 ;
102842: LD_ADDR_VAR 0 10
102846: PUSH
102847: LD_INT 0
102849: ST_TO_ADDR
// if tmp < k then
102850: LD_VAR 0 14
102854: PUSH
102855: LD_VAR 0 9
102859: LESS
102860: IFFALSE 102872
// k := tmp ;
102862: LD_ADDR_VAR 0 9
102866: PUSH
102867: LD_VAR 0 14
102871: ST_TO_ADDR
// for j = k downto 1 do
102872: LD_ADDR_VAR 0 8
102876: PUSH
102877: DOUBLE
102878: LD_VAR 0 9
102882: INC
102883: ST_TO_ADDR
102884: LD_INT 1
102886: PUSH
102887: FOR_DOWNTO
102888: IFFALSE 102963
// begin if GetType ( tmp [ j ] ) = unit_human then
102890: LD_VAR 0 14
102894: PUSH
102895: LD_VAR 0 8
102899: ARRAY
102900: PPUSH
102901: CALL_OW 247
102905: PUSH
102906: LD_INT 1
102908: EQUAL
102909: IFFALSE 102961
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102911: LD_VAR 0 4
102915: PUSH
102916: LD_VAR 0 7
102920: ARRAY
102921: PPUSH
102922: LD_VAR 0 14
102926: PUSH
102927: LD_VAR 0 8
102931: ARRAY
102932: PPUSH
102933: CALL 46828 0 2
// x := tmp [ j ] ;
102937: LD_ADDR_VAR 0 10
102941: PUSH
102942: LD_VAR 0 14
102946: PUSH
102947: LD_VAR 0 8
102951: ARRAY
102952: ST_TO_ADDR
// attacking := true ;
102953: LD_ADDR_VAR 0 29
102957: PUSH
102958: LD_INT 1
102960: ST_TO_ADDR
// end ; end ;
102961: GO 102887
102963: POP
102964: POP
// if not x then
102965: LD_VAR 0 10
102969: NOT
102970: IFFALSE 103110
// begin attacking := true ;
102972: LD_ADDR_VAR 0 29
102976: PUSH
102977: LD_INT 1
102979: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102980: LD_VAR 0 4
102984: PUSH
102985: LD_VAR 0 7
102989: ARRAY
102990: PPUSH
102991: CALL_OW 250
102995: PPUSH
102996: LD_VAR 0 4
103000: PUSH
103001: LD_VAR 0 7
103005: ARRAY
103006: PPUSH
103007: CALL_OW 251
103011: PPUSH
103012: CALL_OW 546
103016: PUSH
103017: LD_INT 2
103019: ARRAY
103020: PUSH
103021: LD_VAR 0 14
103025: PUSH
103026: LD_INT 1
103028: ARRAY
103029: PPUSH
103030: CALL_OW 250
103034: PPUSH
103035: LD_VAR 0 14
103039: PUSH
103040: LD_INT 1
103042: ARRAY
103043: PPUSH
103044: CALL_OW 251
103048: PPUSH
103049: CALL_OW 546
103053: PUSH
103054: LD_INT 2
103056: ARRAY
103057: EQUAL
103058: IFFALSE 103086
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
103060: LD_VAR 0 4
103064: PUSH
103065: LD_VAR 0 7
103069: ARRAY
103070: PPUSH
103071: LD_VAR 0 14
103075: PUSH
103076: LD_INT 1
103078: ARRAY
103079: PPUSH
103080: CALL 46828 0 2
103084: GO 103110
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103086: LD_VAR 0 4
103090: PUSH
103091: LD_VAR 0 7
103095: ARRAY
103096: PPUSH
103097: LD_VAR 0 14
103101: PUSH
103102: LD_INT 1
103104: ARRAY
103105: PPUSH
103106: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
103110: LD_VAR 0 4
103114: PUSH
103115: LD_VAR 0 7
103119: ARRAY
103120: PPUSH
103121: CALL_OW 264
103125: PUSH
103126: LD_INT 29
103128: EQUAL
103129: IFFALSE 103495
// begin if WantsToAttack ( group [ i ] ) in bombed then
103131: LD_VAR 0 4
103135: PUSH
103136: LD_VAR 0 7
103140: ARRAY
103141: PPUSH
103142: CALL_OW 319
103146: PUSH
103147: LD_VAR 0 28
103151: IN
103152: IFFALSE 103156
// continue ;
103154: GO 100160
// k := 8 ;
103156: LD_ADDR_VAR 0 9
103160: PUSH
103161: LD_INT 8
103163: ST_TO_ADDR
// x := 0 ;
103164: LD_ADDR_VAR 0 10
103168: PUSH
103169: LD_INT 0
103171: ST_TO_ADDR
// if tmp < k then
103172: LD_VAR 0 14
103176: PUSH
103177: LD_VAR 0 9
103181: LESS
103182: IFFALSE 103194
// k := tmp ;
103184: LD_ADDR_VAR 0 9
103188: PUSH
103189: LD_VAR 0 14
103193: ST_TO_ADDR
// for j = 1 to k do
103194: LD_ADDR_VAR 0 8
103198: PUSH
103199: DOUBLE
103200: LD_INT 1
103202: DEC
103203: ST_TO_ADDR
103204: LD_VAR 0 9
103208: PUSH
103209: FOR_TO
103210: IFFALSE 103342
// begin if GetType ( tmp [ j ] ) = unit_building then
103212: LD_VAR 0 14
103216: PUSH
103217: LD_VAR 0 8
103221: ARRAY
103222: PPUSH
103223: CALL_OW 247
103227: PUSH
103228: LD_INT 3
103230: EQUAL
103231: IFFALSE 103340
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
103233: LD_VAR 0 14
103237: PUSH
103238: LD_VAR 0 8
103242: ARRAY
103243: PUSH
103244: LD_VAR 0 28
103248: IN
103249: NOT
103250: PUSH
103251: LD_VAR 0 14
103255: PUSH
103256: LD_VAR 0 8
103260: ARRAY
103261: PPUSH
103262: CALL_OW 313
103266: AND
103267: IFFALSE 103340
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103269: LD_VAR 0 4
103273: PUSH
103274: LD_VAR 0 7
103278: ARRAY
103279: PPUSH
103280: LD_VAR 0 14
103284: PUSH
103285: LD_VAR 0 8
103289: ARRAY
103290: PPUSH
103291: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
103295: LD_ADDR_VAR 0 28
103299: PUSH
103300: LD_VAR 0 28
103304: PPUSH
103305: LD_VAR 0 28
103309: PUSH
103310: LD_INT 1
103312: PLUS
103313: PPUSH
103314: LD_VAR 0 14
103318: PUSH
103319: LD_VAR 0 8
103323: ARRAY
103324: PPUSH
103325: CALL_OW 1
103329: ST_TO_ADDR
// attacking := true ;
103330: LD_ADDR_VAR 0 29
103334: PUSH
103335: LD_INT 1
103337: ST_TO_ADDR
// break ;
103338: GO 103342
// end ; end ;
103340: GO 103209
103342: POP
103343: POP
// if not attacking and f_attack_depot then
103344: LD_VAR 0 29
103348: NOT
103349: PUSH
103350: LD_VAR 0 25
103354: AND
103355: IFFALSE 103450
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
103357: LD_ADDR_VAR 0 13
103361: PUSH
103362: LD_VAR 0 14
103366: PPUSH
103367: LD_INT 2
103369: PUSH
103370: LD_INT 30
103372: PUSH
103373: LD_INT 0
103375: PUSH
103376: EMPTY
103377: LIST
103378: LIST
103379: PUSH
103380: LD_INT 30
103382: PUSH
103383: LD_INT 1
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PUSH
103390: EMPTY
103391: LIST
103392: LIST
103393: LIST
103394: PPUSH
103395: CALL_OW 72
103399: ST_TO_ADDR
// if z then
103400: LD_VAR 0 13
103404: IFFALSE 103450
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
103406: LD_VAR 0 4
103410: PUSH
103411: LD_VAR 0 7
103415: ARRAY
103416: PPUSH
103417: LD_VAR 0 13
103421: PPUSH
103422: LD_VAR 0 4
103426: PUSH
103427: LD_VAR 0 7
103431: ARRAY
103432: PPUSH
103433: CALL_OW 74
103437: PPUSH
103438: CALL_OW 115
// attacking := true ;
103442: LD_ADDR_VAR 0 29
103446: PUSH
103447: LD_INT 1
103449: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
103450: LD_VAR 0 4
103454: PUSH
103455: LD_VAR 0 7
103459: ARRAY
103460: PPUSH
103461: CALL_OW 256
103465: PUSH
103466: LD_INT 500
103468: LESS
103469: IFFALSE 103495
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103471: LD_VAR 0 4
103475: PUSH
103476: LD_VAR 0 7
103480: ARRAY
103481: PPUSH
103482: LD_VAR 0 14
103486: PUSH
103487: LD_INT 1
103489: ARRAY
103490: PPUSH
103491: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
103495: LD_VAR 0 4
103499: PUSH
103500: LD_VAR 0 7
103504: ARRAY
103505: PPUSH
103506: CALL_OW 264
103510: PUSH
103511: LD_INT 49
103513: EQUAL
103514: IFFALSE 103635
// begin if not HasTask ( group [ i ] ) then
103516: LD_VAR 0 4
103520: PUSH
103521: LD_VAR 0 7
103525: ARRAY
103526: PPUSH
103527: CALL_OW 314
103531: NOT
103532: IFFALSE 103635
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
103534: LD_ADDR_VAR 0 9
103538: PUSH
103539: LD_INT 81
103541: PUSH
103542: LD_VAR 0 4
103546: PUSH
103547: LD_VAR 0 7
103551: ARRAY
103552: PPUSH
103553: CALL_OW 255
103557: PUSH
103558: EMPTY
103559: LIST
103560: LIST
103561: PPUSH
103562: CALL_OW 69
103566: PPUSH
103567: LD_VAR 0 4
103571: PUSH
103572: LD_VAR 0 7
103576: ARRAY
103577: PPUSH
103578: CALL_OW 74
103582: ST_TO_ADDR
// if k then
103583: LD_VAR 0 9
103587: IFFALSE 103635
// if GetDistUnits ( group [ i ] , k ) > 10 then
103589: LD_VAR 0 4
103593: PUSH
103594: LD_VAR 0 7
103598: ARRAY
103599: PPUSH
103600: LD_VAR 0 9
103604: PPUSH
103605: CALL_OW 296
103609: PUSH
103610: LD_INT 10
103612: GREATER
103613: IFFALSE 103635
// ComMoveUnit ( group [ i ] , k ) ;
103615: LD_VAR 0 4
103619: PUSH
103620: LD_VAR 0 7
103624: ARRAY
103625: PPUSH
103626: LD_VAR 0 9
103630: PPUSH
103631: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
103635: LD_VAR 0 4
103639: PUSH
103640: LD_VAR 0 7
103644: ARRAY
103645: PPUSH
103646: CALL_OW 256
103650: PUSH
103651: LD_INT 250
103653: LESS
103654: PUSH
103655: LD_VAR 0 4
103659: PUSH
103660: LD_VAR 0 7
103664: ARRAY
103665: PUSH
103666: LD_INT 21
103668: PUSH
103669: LD_INT 2
103671: PUSH
103672: EMPTY
103673: LIST
103674: LIST
103675: PUSH
103676: LD_INT 23
103678: PUSH
103679: LD_INT 2
103681: PUSH
103682: EMPTY
103683: LIST
103684: LIST
103685: PUSH
103686: EMPTY
103687: LIST
103688: LIST
103689: PPUSH
103690: CALL_OW 69
103694: IN
103695: AND
103696: IFFALSE 103821
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
103698: LD_ADDR_VAR 0 9
103702: PUSH
103703: LD_OWVAR 3
103707: PUSH
103708: LD_VAR 0 4
103712: PUSH
103713: LD_VAR 0 7
103717: ARRAY
103718: DIFF
103719: PPUSH
103720: LD_VAR 0 4
103724: PUSH
103725: LD_VAR 0 7
103729: ARRAY
103730: PPUSH
103731: CALL_OW 74
103735: ST_TO_ADDR
// if not k then
103736: LD_VAR 0 9
103740: NOT
103741: IFFALSE 103745
// continue ;
103743: GO 100160
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
103745: LD_VAR 0 9
103749: PUSH
103750: LD_INT 81
103752: PUSH
103753: LD_VAR 0 4
103757: PUSH
103758: LD_VAR 0 7
103762: ARRAY
103763: PPUSH
103764: CALL_OW 255
103768: PUSH
103769: EMPTY
103770: LIST
103771: LIST
103772: PPUSH
103773: CALL_OW 69
103777: IN
103778: PUSH
103779: LD_VAR 0 9
103783: PPUSH
103784: LD_VAR 0 4
103788: PUSH
103789: LD_VAR 0 7
103793: ARRAY
103794: PPUSH
103795: CALL_OW 296
103799: PUSH
103800: LD_INT 5
103802: LESS
103803: AND
103804: IFFALSE 103821
// ComAutodestruct ( group [ i ] ) ;
103806: LD_VAR 0 4
103810: PUSH
103811: LD_VAR 0 7
103815: ARRAY
103816: PPUSH
103817: CALL 46726 0 1
// end ; if f_attack_depot then
103821: LD_VAR 0 25
103825: IFFALSE 103937
// begin k := 6 ;
103827: LD_ADDR_VAR 0 9
103831: PUSH
103832: LD_INT 6
103834: ST_TO_ADDR
// if tmp < k then
103835: LD_VAR 0 14
103839: PUSH
103840: LD_VAR 0 9
103844: LESS
103845: IFFALSE 103857
// k := tmp ;
103847: LD_ADDR_VAR 0 9
103851: PUSH
103852: LD_VAR 0 14
103856: ST_TO_ADDR
// for j = 1 to k do
103857: LD_ADDR_VAR 0 8
103861: PUSH
103862: DOUBLE
103863: LD_INT 1
103865: DEC
103866: ST_TO_ADDR
103867: LD_VAR 0 9
103871: PUSH
103872: FOR_TO
103873: IFFALSE 103935
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103875: LD_VAR 0 8
103879: PPUSH
103880: CALL_OW 266
103884: PUSH
103885: LD_INT 0
103887: PUSH
103888: LD_INT 1
103890: PUSH
103891: EMPTY
103892: LIST
103893: LIST
103894: IN
103895: IFFALSE 103933
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103897: LD_VAR 0 4
103901: PUSH
103902: LD_VAR 0 7
103906: ARRAY
103907: PPUSH
103908: LD_VAR 0 14
103912: PUSH
103913: LD_VAR 0 8
103917: ARRAY
103918: PPUSH
103919: CALL_OW 115
// attacking := true ;
103923: LD_ADDR_VAR 0 29
103927: PUSH
103928: LD_INT 1
103930: ST_TO_ADDR
// break ;
103931: GO 103935
// end ;
103933: GO 103872
103935: POP
103936: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103937: LD_VAR 0 4
103941: PUSH
103942: LD_VAR 0 7
103946: ARRAY
103947: PPUSH
103948: CALL_OW 302
103952: PUSH
103953: LD_VAR 0 29
103957: NOT
103958: AND
103959: IFFALSE 104281
// begin if GetTag ( group [ i ] ) = 71 then
103961: LD_VAR 0 4
103965: PUSH
103966: LD_VAR 0 7
103970: ARRAY
103971: PPUSH
103972: CALL_OW 110
103976: PUSH
103977: LD_INT 71
103979: EQUAL
103980: IFFALSE 104021
// begin if HasTask ( group [ i ] ) then
103982: LD_VAR 0 4
103986: PUSH
103987: LD_VAR 0 7
103991: ARRAY
103992: PPUSH
103993: CALL_OW 314
103997: IFFALSE 104003
// continue else
103999: GO 100160
104001: GO 104021
// SetTag ( group [ i ] , 0 ) ;
104003: LD_VAR 0 4
104007: PUSH
104008: LD_VAR 0 7
104012: ARRAY
104013: PPUSH
104014: LD_INT 0
104016: PPUSH
104017: CALL_OW 109
// end ; k := 8 ;
104021: LD_ADDR_VAR 0 9
104025: PUSH
104026: LD_INT 8
104028: ST_TO_ADDR
// x := 0 ;
104029: LD_ADDR_VAR 0 10
104033: PUSH
104034: LD_INT 0
104036: ST_TO_ADDR
// if tmp < k then
104037: LD_VAR 0 14
104041: PUSH
104042: LD_VAR 0 9
104046: LESS
104047: IFFALSE 104059
// k := tmp ;
104049: LD_ADDR_VAR 0 9
104053: PUSH
104054: LD_VAR 0 14
104058: ST_TO_ADDR
// for j = 1 to k do
104059: LD_ADDR_VAR 0 8
104063: PUSH
104064: DOUBLE
104065: LD_INT 1
104067: DEC
104068: ST_TO_ADDR
104069: LD_VAR 0 9
104073: PUSH
104074: FOR_TO
104075: IFFALSE 104173
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
104077: LD_VAR 0 14
104081: PUSH
104082: LD_VAR 0 8
104086: ARRAY
104087: PPUSH
104088: CALL_OW 247
104092: PUSH
104093: LD_INT 1
104095: EQUAL
104096: PUSH
104097: LD_VAR 0 14
104101: PUSH
104102: LD_VAR 0 8
104106: ARRAY
104107: PPUSH
104108: CALL_OW 256
104112: PUSH
104113: LD_INT 250
104115: LESS
104116: PUSH
104117: LD_VAR 0 20
104121: AND
104122: PUSH
104123: LD_VAR 0 20
104127: NOT
104128: PUSH
104129: LD_VAR 0 14
104133: PUSH
104134: LD_VAR 0 8
104138: ARRAY
104139: PPUSH
104140: CALL_OW 256
104144: PUSH
104145: LD_INT 250
104147: GREATEREQUAL
104148: AND
104149: OR
104150: AND
104151: IFFALSE 104171
// begin x := tmp [ j ] ;
104153: LD_ADDR_VAR 0 10
104157: PUSH
104158: LD_VAR 0 14
104162: PUSH
104163: LD_VAR 0 8
104167: ARRAY
104168: ST_TO_ADDR
// break ;
104169: GO 104173
// end ;
104171: GO 104074
104173: POP
104174: POP
// if x then
104175: LD_VAR 0 10
104179: IFFALSE 104203
// ComAttackUnit ( group [ i ] , x ) else
104181: LD_VAR 0 4
104185: PUSH
104186: LD_VAR 0 7
104190: ARRAY
104191: PPUSH
104192: LD_VAR 0 10
104196: PPUSH
104197: CALL_OW 115
104201: GO 104227
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
104203: LD_VAR 0 4
104207: PUSH
104208: LD_VAR 0 7
104212: ARRAY
104213: PPUSH
104214: LD_VAR 0 14
104218: PUSH
104219: LD_INT 1
104221: ARRAY
104222: PPUSH
104223: CALL_OW 115
// if not HasTask ( group [ i ] ) then
104227: LD_VAR 0 4
104231: PUSH
104232: LD_VAR 0 7
104236: ARRAY
104237: PPUSH
104238: CALL_OW 314
104242: NOT
104243: IFFALSE 104281
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
104245: LD_VAR 0 4
104249: PUSH
104250: LD_VAR 0 7
104254: ARRAY
104255: PPUSH
104256: LD_VAR 0 14
104260: PPUSH
104261: LD_VAR 0 4
104265: PUSH
104266: LD_VAR 0 7
104270: ARRAY
104271: PPUSH
104272: CALL_OW 74
104276: PPUSH
104277: CALL_OW 115
// end ; end ; end ;
104281: GO 100160
104283: POP
104284: POP
// wait ( 0 0$2 ) ;
104285: LD_INT 70
104287: PPUSH
104288: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
104292: LD_VAR 0 4
104296: NOT
104297: PUSH
104298: LD_VAR 0 4
104302: PUSH
104303: EMPTY
104304: EQUAL
104305: OR
104306: PUSH
104307: LD_INT 81
104309: PUSH
104310: LD_VAR 0 35
104314: PUSH
104315: EMPTY
104316: LIST
104317: LIST
104318: PPUSH
104319: CALL_OW 69
104323: NOT
104324: OR
104325: IFFALSE 100145
// end ;
104327: LD_VAR 0 2
104331: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
104332: LD_INT 0
104334: PPUSH
104335: PPUSH
104336: PPUSH
104337: PPUSH
104338: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
104339: LD_VAR 0 1
104343: NOT
104344: PUSH
104345: LD_EXP 59
104349: PUSH
104350: LD_VAR 0 1
104354: ARRAY
104355: NOT
104356: OR
104357: PUSH
104358: LD_VAR 0 2
104362: NOT
104363: OR
104364: PUSH
104365: LD_VAR 0 3
104369: NOT
104370: OR
104371: IFFALSE 104375
// exit ;
104373: GO 104888
// side := mc_sides [ base ] ;
104375: LD_ADDR_VAR 0 6
104379: PUSH
104380: LD_EXP 85
104384: PUSH
104385: LD_VAR 0 1
104389: ARRAY
104390: ST_TO_ADDR
// if not side then
104391: LD_VAR 0 6
104395: NOT
104396: IFFALSE 104400
// exit ;
104398: GO 104888
// for i in solds do
104400: LD_ADDR_VAR 0 7
104404: PUSH
104405: LD_VAR 0 2
104409: PUSH
104410: FOR_IN
104411: IFFALSE 104472
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
104413: LD_VAR 0 7
104417: PPUSH
104418: CALL_OW 310
104422: PPUSH
104423: CALL_OW 266
104427: PUSH
104428: LD_INT 32
104430: PUSH
104431: LD_INT 31
104433: PUSH
104434: EMPTY
104435: LIST
104436: LIST
104437: IN
104438: IFFALSE 104458
// solds := solds diff i else
104440: LD_ADDR_VAR 0 2
104444: PUSH
104445: LD_VAR 0 2
104449: PUSH
104450: LD_VAR 0 7
104454: DIFF
104455: ST_TO_ADDR
104456: GO 104470
// SetTag ( i , 18 ) ;
104458: LD_VAR 0 7
104462: PPUSH
104463: LD_INT 18
104465: PPUSH
104466: CALL_OW 109
104470: GO 104410
104472: POP
104473: POP
// if not solds then
104474: LD_VAR 0 2
104478: NOT
104479: IFFALSE 104483
// exit ;
104481: GO 104888
// repeat wait ( 0 0$2 ) ;
104483: LD_INT 70
104485: PPUSH
104486: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
104490: LD_ADDR_VAR 0 5
104494: PUSH
104495: LD_VAR 0 6
104499: PPUSH
104500: LD_VAR 0 3
104504: PPUSH
104505: CALL 16108 0 2
104509: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104510: LD_EXP 59
104514: PUSH
104515: LD_VAR 0 1
104519: ARRAY
104520: NOT
104521: PUSH
104522: LD_EXP 59
104526: PUSH
104527: LD_VAR 0 1
104531: ARRAY
104532: PUSH
104533: EMPTY
104534: EQUAL
104535: OR
104536: IFFALSE 104573
// begin for i in solds do
104538: LD_ADDR_VAR 0 7
104542: PUSH
104543: LD_VAR 0 2
104547: PUSH
104548: FOR_IN
104549: IFFALSE 104562
// ComStop ( i ) ;
104551: LD_VAR 0 7
104555: PPUSH
104556: CALL_OW 141
104560: GO 104548
104562: POP
104563: POP
// solds := [ ] ;
104564: LD_ADDR_VAR 0 2
104568: PUSH
104569: EMPTY
104570: ST_TO_ADDR
// exit ;
104571: GO 104888
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
104573: LD_VAR 0 5
104577: NOT
104578: PUSH
104579: LD_VAR 0 5
104583: PUSH
104584: LD_INT 3
104586: GREATER
104587: OR
104588: PUSH
104589: LD_EXP 81
104593: PUSH
104594: LD_VAR 0 1
104598: ARRAY
104599: OR
104600: IFFALSE 104641
// begin for i in solds do
104602: LD_ADDR_VAR 0 7
104606: PUSH
104607: LD_VAR 0 2
104611: PUSH
104612: FOR_IN
104613: IFFALSE 104637
// if HasTask ( i ) then
104615: LD_VAR 0 7
104619: PPUSH
104620: CALL_OW 314
104624: IFFALSE 104635
// ComStop ( i ) ;
104626: LD_VAR 0 7
104630: PPUSH
104631: CALL_OW 141
104635: GO 104612
104637: POP
104638: POP
// break ;
104639: GO 104876
// end ; for i in solds do
104641: LD_ADDR_VAR 0 7
104645: PUSH
104646: LD_VAR 0 2
104650: PUSH
104651: FOR_IN
104652: IFFALSE 104868
// begin if IsInUnit ( i ) then
104654: LD_VAR 0 7
104658: PPUSH
104659: CALL_OW 310
104663: IFFALSE 104674
// ComExitBuilding ( i ) ;
104665: LD_VAR 0 7
104669: PPUSH
104670: CALL_OW 122
// if GetLives ( i ) > 333 then
104674: LD_VAR 0 7
104678: PPUSH
104679: CALL_OW 256
104683: PUSH
104684: LD_INT 333
104686: GREATER
104687: IFFALSE 104715
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
104689: LD_VAR 0 7
104693: PPUSH
104694: LD_VAR 0 5
104698: PPUSH
104699: LD_VAR 0 7
104703: PPUSH
104704: CALL_OW 74
104708: PPUSH
104709: CALL_OW 115
104713: GO 104866
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
104715: LD_ADDR_VAR 0 8
104719: PUSH
104720: LD_EXP 59
104724: PUSH
104725: LD_VAR 0 1
104729: ARRAY
104730: PPUSH
104731: LD_INT 2
104733: PUSH
104734: LD_INT 30
104736: PUSH
104737: LD_INT 0
104739: PUSH
104740: EMPTY
104741: LIST
104742: LIST
104743: PUSH
104744: LD_INT 30
104746: PUSH
104747: LD_INT 1
104749: PUSH
104750: EMPTY
104751: LIST
104752: LIST
104753: PUSH
104754: LD_INT 30
104756: PUSH
104757: LD_INT 6
104759: PUSH
104760: EMPTY
104761: LIST
104762: LIST
104763: PUSH
104764: EMPTY
104765: LIST
104766: LIST
104767: LIST
104768: LIST
104769: PPUSH
104770: CALL_OW 72
104774: PPUSH
104775: LD_VAR 0 7
104779: PPUSH
104780: CALL_OW 74
104784: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
104785: LD_VAR 0 7
104789: PPUSH
104790: LD_VAR 0 8
104794: PPUSH
104795: CALL_OW 250
104799: PPUSH
104800: LD_INT 3
104802: PPUSH
104803: LD_INT 5
104805: PPUSH
104806: CALL_OW 272
104810: PPUSH
104811: LD_VAR 0 8
104815: PPUSH
104816: CALL_OW 251
104820: PPUSH
104821: LD_INT 3
104823: PPUSH
104824: LD_INT 5
104826: PPUSH
104827: CALL_OW 273
104831: PPUSH
104832: CALL_OW 111
// SetTag ( i , 0 ) ;
104836: LD_VAR 0 7
104840: PPUSH
104841: LD_INT 0
104843: PPUSH
104844: CALL_OW 109
// solds := solds diff i ;
104848: LD_ADDR_VAR 0 2
104852: PUSH
104853: LD_VAR 0 2
104857: PUSH
104858: LD_VAR 0 7
104862: DIFF
104863: ST_TO_ADDR
// continue ;
104864: GO 104651
// end ; end ;
104866: GO 104651
104868: POP
104869: POP
// until solds ;
104870: LD_VAR 0 2
104874: IFFALSE 104483
// MC_Reset ( base , 18 ) ;
104876: LD_VAR 0 1
104880: PPUSH
104881: LD_INT 18
104883: PPUSH
104884: CALL 56148 0 2
// end ;
104888: LD_VAR 0 4
104892: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
104893: LD_INT 0
104895: PPUSH
104896: PPUSH
104897: PPUSH
104898: PPUSH
104899: PPUSH
104900: PPUSH
104901: PPUSH
104902: PPUSH
104903: PPUSH
104904: PPUSH
104905: PPUSH
104906: PPUSH
104907: PPUSH
104908: PPUSH
104909: PPUSH
104910: PPUSH
104911: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
104912: LD_ADDR_VAR 0 13
104916: PUSH
104917: LD_EXP 59
104921: PUSH
104922: LD_VAR 0 1
104926: ARRAY
104927: PPUSH
104928: LD_INT 25
104930: PUSH
104931: LD_INT 3
104933: PUSH
104934: EMPTY
104935: LIST
104936: LIST
104937: PPUSH
104938: CALL_OW 72
104942: ST_TO_ADDR
// if mc_remote_driver [ base ] then
104943: LD_EXP 99
104947: PUSH
104948: LD_VAR 0 1
104952: ARRAY
104953: IFFALSE 104977
// mechs := mechs diff mc_remote_driver [ base ] ;
104955: LD_ADDR_VAR 0 13
104959: PUSH
104960: LD_VAR 0 13
104964: PUSH
104965: LD_EXP 99
104969: PUSH
104970: LD_VAR 0 1
104974: ARRAY
104975: DIFF
104976: ST_TO_ADDR
// for i in mechs do
104977: LD_ADDR_VAR 0 5
104981: PUSH
104982: LD_VAR 0 13
104986: PUSH
104987: FOR_IN
104988: IFFALSE 105023
// if GetTag ( i ) > 0 then
104990: LD_VAR 0 5
104994: PPUSH
104995: CALL_OW 110
104999: PUSH
105000: LD_INT 0
105002: GREATER
105003: IFFALSE 105021
// mechs := mechs diff i ;
105005: LD_ADDR_VAR 0 13
105009: PUSH
105010: LD_VAR 0 13
105014: PUSH
105015: LD_VAR 0 5
105019: DIFF
105020: ST_TO_ADDR
105021: GO 104987
105023: POP
105024: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105025: LD_ADDR_VAR 0 9
105029: PUSH
105030: LD_EXP 59
105034: PUSH
105035: LD_VAR 0 1
105039: ARRAY
105040: PPUSH
105041: LD_INT 2
105043: PUSH
105044: LD_INT 25
105046: PUSH
105047: LD_INT 1
105049: PUSH
105050: EMPTY
105051: LIST
105052: LIST
105053: PUSH
105054: LD_INT 25
105056: PUSH
105057: LD_INT 5
105059: PUSH
105060: EMPTY
105061: LIST
105062: LIST
105063: PUSH
105064: LD_INT 25
105066: PUSH
105067: LD_INT 8
105069: PUSH
105070: EMPTY
105071: LIST
105072: LIST
105073: PUSH
105074: LD_INT 25
105076: PUSH
105077: LD_INT 9
105079: PUSH
105080: EMPTY
105081: LIST
105082: LIST
105083: PUSH
105084: EMPTY
105085: LIST
105086: LIST
105087: LIST
105088: LIST
105089: LIST
105090: PPUSH
105091: CALL_OW 72
105095: ST_TO_ADDR
// if not defenders and not solds then
105096: LD_VAR 0 2
105100: NOT
105101: PUSH
105102: LD_VAR 0 9
105106: NOT
105107: AND
105108: IFFALSE 105112
// exit ;
105110: GO 106802
// depot_under_attack := false ;
105112: LD_ADDR_VAR 0 17
105116: PUSH
105117: LD_INT 0
105119: ST_TO_ADDR
// sold_defenders := [ ] ;
105120: LD_ADDR_VAR 0 18
105124: PUSH
105125: EMPTY
105126: ST_TO_ADDR
// if mechs then
105127: LD_VAR 0 13
105131: IFFALSE 105284
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
105133: LD_ADDR_VAR 0 5
105137: PUSH
105138: LD_VAR 0 2
105142: PPUSH
105143: LD_INT 21
105145: PUSH
105146: LD_INT 2
105148: PUSH
105149: EMPTY
105150: LIST
105151: LIST
105152: PPUSH
105153: CALL_OW 72
105157: PUSH
105158: FOR_IN
105159: IFFALSE 105282
// begin if GetTag ( i ) <> 20 then
105161: LD_VAR 0 5
105165: PPUSH
105166: CALL_OW 110
105170: PUSH
105171: LD_INT 20
105173: NONEQUAL
105174: IFFALSE 105188
// SetTag ( i , 20 ) ;
105176: LD_VAR 0 5
105180: PPUSH
105181: LD_INT 20
105183: PPUSH
105184: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
105188: LD_VAR 0 5
105192: PPUSH
105193: CALL_OW 263
105197: PUSH
105198: LD_INT 1
105200: EQUAL
105201: PUSH
105202: LD_VAR 0 5
105206: PPUSH
105207: CALL_OW 311
105211: NOT
105212: AND
105213: IFFALSE 105280
// begin un := mechs [ 1 ] ;
105215: LD_ADDR_VAR 0 11
105219: PUSH
105220: LD_VAR 0 13
105224: PUSH
105225: LD_INT 1
105227: ARRAY
105228: ST_TO_ADDR
// ComExit ( un ) ;
105229: LD_VAR 0 11
105233: PPUSH
105234: CALL 51071 0 1
// AddComEnterUnit ( un , i ) ;
105238: LD_VAR 0 11
105242: PPUSH
105243: LD_VAR 0 5
105247: PPUSH
105248: CALL_OW 180
// SetTag ( un , 19 ) ;
105252: LD_VAR 0 11
105256: PPUSH
105257: LD_INT 19
105259: PPUSH
105260: CALL_OW 109
// mechs := mechs diff un ;
105264: LD_ADDR_VAR 0 13
105268: PUSH
105269: LD_VAR 0 13
105273: PUSH
105274: LD_VAR 0 11
105278: DIFF
105279: ST_TO_ADDR
// end ; end ;
105280: GO 105158
105282: POP
105283: POP
// if solds then
105284: LD_VAR 0 9
105288: IFFALSE 105347
// for i in solds do
105290: LD_ADDR_VAR 0 5
105294: PUSH
105295: LD_VAR 0 9
105299: PUSH
105300: FOR_IN
105301: IFFALSE 105345
// if not GetTag ( i ) then
105303: LD_VAR 0 5
105307: PPUSH
105308: CALL_OW 110
105312: NOT
105313: IFFALSE 105343
// begin defenders := defenders union i ;
105315: LD_ADDR_VAR 0 2
105319: PUSH
105320: LD_VAR 0 2
105324: PUSH
105325: LD_VAR 0 5
105329: UNION
105330: ST_TO_ADDR
// SetTag ( i , 18 ) ;
105331: LD_VAR 0 5
105335: PPUSH
105336: LD_INT 18
105338: PPUSH
105339: CALL_OW 109
// end ;
105343: GO 105300
105345: POP
105346: POP
// repeat wait ( 0 0$2 ) ;
105347: LD_INT 70
105349: PPUSH
105350: CALL_OW 67
// enemy := mc_scan [ base ] ;
105354: LD_ADDR_VAR 0 3
105358: PUSH
105359: LD_EXP 82
105363: PUSH
105364: LD_VAR 0 1
105368: ARRAY
105369: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105370: LD_EXP 59
105374: PUSH
105375: LD_VAR 0 1
105379: ARRAY
105380: NOT
105381: PUSH
105382: LD_EXP 59
105386: PUSH
105387: LD_VAR 0 1
105391: ARRAY
105392: PUSH
105393: EMPTY
105394: EQUAL
105395: OR
105396: IFFALSE 105433
// begin for i in defenders do
105398: LD_ADDR_VAR 0 5
105402: PUSH
105403: LD_VAR 0 2
105407: PUSH
105408: FOR_IN
105409: IFFALSE 105422
// ComStop ( i ) ;
105411: LD_VAR 0 5
105415: PPUSH
105416: CALL_OW 141
105420: GO 105408
105422: POP
105423: POP
// defenders := [ ] ;
105424: LD_ADDR_VAR 0 2
105428: PUSH
105429: EMPTY
105430: ST_TO_ADDR
// exit ;
105431: GO 106802
// end ; for i in defenders do
105433: LD_ADDR_VAR 0 5
105437: PUSH
105438: LD_VAR 0 2
105442: PUSH
105443: FOR_IN
105444: IFFALSE 106262
// begin e := NearestUnitToUnit ( enemy , i ) ;
105446: LD_ADDR_VAR 0 14
105450: PUSH
105451: LD_VAR 0 3
105455: PPUSH
105456: LD_VAR 0 5
105460: PPUSH
105461: CALL_OW 74
105465: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105466: LD_ADDR_VAR 0 8
105470: PUSH
105471: LD_EXP 59
105475: PUSH
105476: LD_VAR 0 1
105480: ARRAY
105481: PPUSH
105482: LD_INT 2
105484: PUSH
105485: LD_INT 30
105487: PUSH
105488: LD_INT 0
105490: PUSH
105491: EMPTY
105492: LIST
105493: LIST
105494: PUSH
105495: LD_INT 30
105497: PUSH
105498: LD_INT 1
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: PUSH
105505: EMPTY
105506: LIST
105507: LIST
105508: LIST
105509: PPUSH
105510: CALL_OW 72
105514: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
105515: LD_ADDR_VAR 0 17
105519: PUSH
105520: LD_VAR 0 8
105524: NOT
105525: PUSH
105526: LD_VAR 0 8
105530: PPUSH
105531: LD_INT 3
105533: PUSH
105534: LD_INT 24
105536: PUSH
105537: LD_INT 600
105539: PUSH
105540: EMPTY
105541: LIST
105542: LIST
105543: PUSH
105544: EMPTY
105545: LIST
105546: LIST
105547: PPUSH
105548: CALL_OW 72
105552: OR
105553: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
105554: LD_VAR 0 5
105558: PPUSH
105559: CALL_OW 247
105563: PUSH
105564: LD_INT 2
105566: DOUBLE
105567: EQUAL
105568: IFTRUE 105572
105570: GO 105968
105572: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
105573: LD_VAR 0 5
105577: PPUSH
105578: CALL_OW 256
105582: PUSH
105583: LD_INT 1000
105585: EQUAL
105586: PUSH
105587: LD_VAR 0 5
105591: PPUSH
105592: LD_VAR 0 14
105596: PPUSH
105597: CALL_OW 296
105601: PUSH
105602: LD_INT 40
105604: LESS
105605: PUSH
105606: LD_VAR 0 14
105610: PPUSH
105611: LD_EXP 84
105615: PUSH
105616: LD_VAR 0 1
105620: ARRAY
105621: PPUSH
105622: CALL_OW 308
105626: OR
105627: AND
105628: IFFALSE 105750
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
105630: LD_VAR 0 5
105634: PPUSH
105635: CALL_OW 262
105639: PUSH
105640: LD_INT 1
105642: EQUAL
105643: PUSH
105644: LD_VAR 0 5
105648: PPUSH
105649: CALL_OW 261
105653: PUSH
105654: LD_INT 30
105656: LESS
105657: AND
105658: PUSH
105659: LD_VAR 0 8
105663: AND
105664: IFFALSE 105734
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
105666: LD_VAR 0 5
105670: PPUSH
105671: LD_VAR 0 8
105675: PPUSH
105676: LD_VAR 0 5
105680: PPUSH
105681: CALL_OW 74
105685: PPUSH
105686: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
105690: LD_VAR 0 5
105694: PPUSH
105695: LD_VAR 0 8
105699: PPUSH
105700: LD_VAR 0 5
105704: PPUSH
105705: CALL_OW 74
105709: PPUSH
105710: CALL_OW 296
105714: PUSH
105715: LD_INT 6
105717: LESS
105718: IFFALSE 105732
// SetFuel ( i , 100 ) ;
105720: LD_VAR 0 5
105724: PPUSH
105725: LD_INT 100
105727: PPUSH
105728: CALL_OW 240
// end else
105732: GO 105748
// ComAttackUnit ( i , e ) ;
105734: LD_VAR 0 5
105738: PPUSH
105739: LD_VAR 0 14
105743: PPUSH
105744: CALL_OW 115
// end else
105748: GO 105851
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
105750: LD_VAR 0 14
105754: PPUSH
105755: LD_EXP 84
105759: PUSH
105760: LD_VAR 0 1
105764: ARRAY
105765: PPUSH
105766: CALL_OW 308
105770: NOT
105771: PUSH
105772: LD_VAR 0 5
105776: PPUSH
105777: LD_VAR 0 14
105781: PPUSH
105782: CALL_OW 296
105786: PUSH
105787: LD_INT 40
105789: GREATEREQUAL
105790: AND
105791: PUSH
105792: LD_VAR 0 5
105796: PPUSH
105797: CALL_OW 256
105801: PUSH
105802: LD_INT 650
105804: LESSEQUAL
105805: OR
105806: PUSH
105807: LD_VAR 0 5
105811: PPUSH
105812: LD_EXP 83
105816: PUSH
105817: LD_VAR 0 1
105821: ARRAY
105822: PPUSH
105823: CALL_OW 308
105827: NOT
105828: AND
105829: IFFALSE 105851
// ComMoveToArea ( i , mc_parking [ base ] ) ;
105831: LD_VAR 0 5
105835: PPUSH
105836: LD_EXP 83
105840: PUSH
105841: LD_VAR 0 1
105845: ARRAY
105846: PPUSH
105847: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
105851: LD_VAR 0 5
105855: PPUSH
105856: CALL_OW 256
105860: PUSH
105861: LD_INT 1000
105863: LESS
105864: PUSH
105865: LD_VAR 0 5
105869: PPUSH
105870: CALL_OW 263
105874: PUSH
105875: LD_INT 1
105877: EQUAL
105878: AND
105879: PUSH
105880: LD_VAR 0 5
105884: PPUSH
105885: CALL_OW 311
105889: AND
105890: PUSH
105891: LD_VAR 0 5
105895: PPUSH
105896: LD_EXP 83
105900: PUSH
105901: LD_VAR 0 1
105905: ARRAY
105906: PPUSH
105907: CALL_OW 308
105911: AND
105912: IFFALSE 105966
// begin mech := IsDrivenBy ( i ) ;
105914: LD_ADDR_VAR 0 10
105918: PUSH
105919: LD_VAR 0 5
105923: PPUSH
105924: CALL_OW 311
105928: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
105929: LD_VAR 0 10
105933: PPUSH
105934: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
105938: LD_VAR 0 10
105942: PPUSH
105943: LD_VAR 0 5
105947: PPUSH
105948: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
105952: LD_VAR 0 10
105956: PPUSH
105957: LD_VAR 0 5
105961: PPUSH
105962: CALL_OW 180
// end ; end ; unit_human :
105966: GO 106233
105968: LD_INT 1
105970: DOUBLE
105971: EQUAL
105972: IFTRUE 105976
105974: GO 106232
105976: POP
// begin b := IsInUnit ( i ) ;
105977: LD_ADDR_VAR 0 19
105981: PUSH
105982: LD_VAR 0 5
105986: PPUSH
105987: CALL_OW 310
105991: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
105992: LD_ADDR_VAR 0 20
105996: PUSH
105997: LD_VAR 0 19
106001: NOT
106002: PUSH
106003: LD_VAR 0 19
106007: PPUSH
106008: CALL_OW 266
106012: PUSH
106013: LD_INT 32
106015: PUSH
106016: LD_INT 31
106018: PUSH
106019: EMPTY
106020: LIST
106021: LIST
106022: IN
106023: OR
106024: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
106025: LD_VAR 0 17
106029: PUSH
106030: LD_VAR 0 2
106034: PPUSH
106035: LD_INT 21
106037: PUSH
106038: LD_INT 2
106040: PUSH
106041: EMPTY
106042: LIST
106043: LIST
106044: PPUSH
106045: CALL_OW 72
106049: PUSH
106050: LD_INT 1
106052: LESSEQUAL
106053: OR
106054: PUSH
106055: LD_VAR 0 20
106059: AND
106060: PUSH
106061: LD_VAR 0 5
106065: PUSH
106066: LD_VAR 0 18
106070: IN
106071: NOT
106072: AND
106073: IFFALSE 106166
// begin if b then
106075: LD_VAR 0 19
106079: IFFALSE 106128
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
106081: LD_VAR 0 19
106085: PPUSH
106086: LD_VAR 0 3
106090: PPUSH
106091: LD_VAR 0 19
106095: PPUSH
106096: CALL_OW 74
106100: PPUSH
106101: CALL_OW 296
106105: PUSH
106106: LD_INT 10
106108: LESS
106109: PUSH
106110: LD_VAR 0 19
106114: PPUSH
106115: CALL_OW 461
106119: PUSH
106120: LD_INT 7
106122: NONEQUAL
106123: AND
106124: IFFALSE 106128
// continue ;
106126: GO 105443
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
106128: LD_ADDR_VAR 0 18
106132: PUSH
106133: LD_VAR 0 18
106137: PPUSH
106138: LD_VAR 0 18
106142: PUSH
106143: LD_INT 1
106145: PLUS
106146: PPUSH
106147: LD_VAR 0 5
106151: PPUSH
106152: CALL_OW 1
106156: ST_TO_ADDR
// ComExitBuilding ( i ) ;
106157: LD_VAR 0 5
106161: PPUSH
106162: CALL_OW 122
// end ; if sold_defenders then
106166: LD_VAR 0 18
106170: IFFALSE 106230
// if i in sold_defenders then
106172: LD_VAR 0 5
106176: PUSH
106177: LD_VAR 0 18
106181: IN
106182: IFFALSE 106230
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
106184: LD_VAR 0 5
106188: PPUSH
106189: CALL_OW 314
106193: NOT
106194: PUSH
106195: LD_VAR 0 5
106199: PPUSH
106200: LD_VAR 0 14
106204: PPUSH
106205: CALL_OW 296
106209: PUSH
106210: LD_INT 30
106212: LESS
106213: AND
106214: IFFALSE 106230
// ComAttackUnit ( i , e ) ;
106216: LD_VAR 0 5
106220: PPUSH
106221: LD_VAR 0 14
106225: PPUSH
106226: CALL_OW 115
// end ; end ; end ;
106230: GO 106233
106232: POP
// if IsDead ( i ) then
106233: LD_VAR 0 5
106237: PPUSH
106238: CALL_OW 301
106242: IFFALSE 106260
// defenders := defenders diff i ;
106244: LD_ADDR_VAR 0 2
106248: PUSH
106249: LD_VAR 0 2
106253: PUSH
106254: LD_VAR 0 5
106258: DIFF
106259: ST_TO_ADDR
// end ;
106260: GO 105443
106262: POP
106263: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
106264: LD_VAR 0 3
106268: NOT
106269: PUSH
106270: LD_VAR 0 2
106274: NOT
106275: OR
106276: PUSH
106277: LD_EXP 59
106281: PUSH
106282: LD_VAR 0 1
106286: ARRAY
106287: NOT
106288: OR
106289: IFFALSE 105347
// MC_Reset ( base , 18 ) ;
106291: LD_VAR 0 1
106295: PPUSH
106296: LD_INT 18
106298: PPUSH
106299: CALL 56148 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
106303: LD_ADDR_VAR 0 2
106307: PUSH
106308: LD_VAR 0 2
106312: PUSH
106313: LD_VAR 0 2
106317: PPUSH
106318: LD_INT 2
106320: PUSH
106321: LD_INT 25
106323: PUSH
106324: LD_INT 1
106326: PUSH
106327: EMPTY
106328: LIST
106329: LIST
106330: PUSH
106331: LD_INT 25
106333: PUSH
106334: LD_INT 5
106336: PUSH
106337: EMPTY
106338: LIST
106339: LIST
106340: PUSH
106341: LD_INT 25
106343: PUSH
106344: LD_INT 8
106346: PUSH
106347: EMPTY
106348: LIST
106349: LIST
106350: PUSH
106351: LD_INT 25
106353: PUSH
106354: LD_INT 9
106356: PUSH
106357: EMPTY
106358: LIST
106359: LIST
106360: PUSH
106361: EMPTY
106362: LIST
106363: LIST
106364: LIST
106365: LIST
106366: LIST
106367: PPUSH
106368: CALL_OW 72
106372: DIFF
106373: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
106374: LD_VAR 0 3
106378: NOT
106379: PUSH
106380: LD_VAR 0 2
106384: PPUSH
106385: LD_INT 21
106387: PUSH
106388: LD_INT 2
106390: PUSH
106391: EMPTY
106392: LIST
106393: LIST
106394: PPUSH
106395: CALL_OW 72
106399: AND
106400: IFFALSE 106738
// begin tmp := FilterByTag ( defenders , 19 ) ;
106402: LD_ADDR_VAR 0 12
106406: PUSH
106407: LD_VAR 0 2
106411: PPUSH
106412: LD_INT 19
106414: PPUSH
106415: CALL 48201 0 2
106419: ST_TO_ADDR
// if tmp then
106420: LD_VAR 0 12
106424: IFFALSE 106494
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
106426: LD_ADDR_VAR 0 12
106430: PUSH
106431: LD_VAR 0 12
106435: PPUSH
106436: LD_INT 25
106438: PUSH
106439: LD_INT 3
106441: PUSH
106442: EMPTY
106443: LIST
106444: LIST
106445: PPUSH
106446: CALL_OW 72
106450: ST_TO_ADDR
// if tmp then
106451: LD_VAR 0 12
106455: IFFALSE 106494
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
106457: LD_ADDR_EXP 71
106461: PUSH
106462: LD_EXP 71
106466: PPUSH
106467: LD_VAR 0 1
106471: PPUSH
106472: LD_EXP 71
106476: PUSH
106477: LD_VAR 0 1
106481: ARRAY
106482: PUSH
106483: LD_VAR 0 12
106487: UNION
106488: PPUSH
106489: CALL_OW 1
106493: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
106494: LD_VAR 0 1
106498: PPUSH
106499: LD_INT 19
106501: PPUSH
106502: CALL 56148 0 2
// repeat wait ( 0 0$1 ) ;
106506: LD_INT 35
106508: PPUSH
106509: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
106513: LD_EXP 59
106517: PUSH
106518: LD_VAR 0 1
106522: ARRAY
106523: NOT
106524: PUSH
106525: LD_EXP 59
106529: PUSH
106530: LD_VAR 0 1
106534: ARRAY
106535: PUSH
106536: EMPTY
106537: EQUAL
106538: OR
106539: IFFALSE 106576
// begin for i in defenders do
106541: LD_ADDR_VAR 0 5
106545: PUSH
106546: LD_VAR 0 2
106550: PUSH
106551: FOR_IN
106552: IFFALSE 106565
// ComStop ( i ) ;
106554: LD_VAR 0 5
106558: PPUSH
106559: CALL_OW 141
106563: GO 106551
106565: POP
106566: POP
// defenders := [ ] ;
106567: LD_ADDR_VAR 0 2
106571: PUSH
106572: EMPTY
106573: ST_TO_ADDR
// exit ;
106574: GO 106802
// end ; for i in defenders do
106576: LD_ADDR_VAR 0 5
106580: PUSH
106581: LD_VAR 0 2
106585: PUSH
106586: FOR_IN
106587: IFFALSE 106676
// begin if not IsInArea ( i , mc_parking [ base ] ) then
106589: LD_VAR 0 5
106593: PPUSH
106594: LD_EXP 83
106598: PUSH
106599: LD_VAR 0 1
106603: ARRAY
106604: PPUSH
106605: CALL_OW 308
106609: NOT
106610: IFFALSE 106634
// ComMoveToArea ( i , mc_parking [ base ] ) else
106612: LD_VAR 0 5
106616: PPUSH
106617: LD_EXP 83
106621: PUSH
106622: LD_VAR 0 1
106626: ARRAY
106627: PPUSH
106628: CALL_OW 113
106632: GO 106674
// if GetControl ( i ) = control_manual then
106634: LD_VAR 0 5
106638: PPUSH
106639: CALL_OW 263
106643: PUSH
106644: LD_INT 1
106646: EQUAL
106647: IFFALSE 106674
// if IsDrivenBy ( i ) then
106649: LD_VAR 0 5
106653: PPUSH
106654: CALL_OW 311
106658: IFFALSE 106674
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
106660: LD_VAR 0 5
106664: PPUSH
106665: CALL_OW 311
106669: PPUSH
106670: CALL_OW 121
// end ;
106674: GO 106586
106676: POP
106677: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
106678: LD_VAR 0 2
106682: PPUSH
106683: LD_INT 95
106685: PUSH
106686: LD_EXP 83
106690: PUSH
106691: LD_VAR 0 1
106695: ARRAY
106696: PUSH
106697: EMPTY
106698: LIST
106699: LIST
106700: PPUSH
106701: CALL_OW 72
106705: PUSH
106706: LD_VAR 0 2
106710: EQUAL
106711: PUSH
106712: LD_EXP 82
106716: PUSH
106717: LD_VAR 0 1
106721: ARRAY
106722: OR
106723: PUSH
106724: LD_EXP 59
106728: PUSH
106729: LD_VAR 0 1
106733: ARRAY
106734: NOT
106735: OR
106736: IFFALSE 106506
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
106738: LD_ADDR_EXP 81
106742: PUSH
106743: LD_EXP 81
106747: PPUSH
106748: LD_VAR 0 1
106752: PPUSH
106753: LD_VAR 0 2
106757: PPUSH
106758: LD_INT 21
106760: PUSH
106761: LD_INT 2
106763: PUSH
106764: EMPTY
106765: LIST
106766: LIST
106767: PPUSH
106768: CALL_OW 72
106772: PPUSH
106773: CALL_OW 1
106777: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
106778: LD_VAR 0 1
106782: PPUSH
106783: LD_INT 19
106785: PPUSH
106786: CALL 56148 0 2
// MC_Reset ( base , 20 ) ;
106790: LD_VAR 0 1
106794: PPUSH
106795: LD_INT 20
106797: PPUSH
106798: CALL 56148 0 2
// end ; end_of_file
106802: LD_VAR 0 4
106806: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
106807: LD_VAR 0 1
106811: PUSH
106812: LD_INT 200
106814: DOUBLE
106815: GREATEREQUAL
106816: IFFALSE 106824
106818: LD_INT 299
106820: DOUBLE
106821: LESSEQUAL
106822: IFTRUE 106826
106824: GO 106858
106826: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
106827: LD_VAR 0 1
106831: PPUSH
106832: LD_VAR 0 2
106836: PPUSH
106837: LD_VAR 0 3
106841: PPUSH
106842: LD_VAR 0 4
106846: PPUSH
106847: LD_VAR 0 5
106851: PPUSH
106852: CALL 95740 0 5
106856: GO 106935
106858: LD_INT 300
106860: DOUBLE
106861: GREATEREQUAL
106862: IFFALSE 106870
106864: LD_INT 399
106866: DOUBLE
106867: LESSEQUAL
106868: IFTRUE 106872
106870: GO 106934
106872: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
106873: LD_VAR 0 1
106877: PPUSH
106878: LD_VAR 0 2
106882: PPUSH
106883: LD_VAR 0 3
106887: PPUSH
106888: LD_VAR 0 4
106892: PPUSH
106893: LD_VAR 0 5
106897: PPUSH
106898: LD_VAR 0 6
106902: PPUSH
106903: LD_VAR 0 7
106907: PPUSH
106908: LD_VAR 0 8
106912: PPUSH
106913: LD_VAR 0 9
106917: PPUSH
106918: LD_VAR 0 10
106922: PPUSH
106923: LD_VAR 0 11
106927: PPUSH
106928: CALL 93628 0 11
106932: GO 106935
106934: POP
// end ;
106935: PPOPN 11
106937: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
106938: LD_VAR 0 1
106942: PPUSH
106943: LD_VAR 0 2
106947: PPUSH
106948: LD_VAR 0 3
106952: PPUSH
106953: LD_VAR 0 4
106957: PPUSH
106958: LD_VAR 0 5
106962: PPUSH
106963: CALL 95722 0 5
// end ; end_of_file
106967: PPOPN 5
106969: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
106970: LD_VAR 0 1
106974: PPUSH
106975: LD_VAR 0 2
106979: PPUSH
106980: LD_VAR 0 3
106984: PPUSH
106985: LD_VAR 0 4
106989: PPUSH
106990: LD_VAR 0 5
106994: PPUSH
106995: LD_VAR 0 6
106999: PPUSH
107000: CALL 82436 0 6
// end ;
107004: PPOPN 6
107006: END
