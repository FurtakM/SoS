// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 60161 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 51748 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 51748 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 51748 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 51748 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4572 0 0
// PrepareRussian ;
 189: CALL 2997 0 0
// PrepareAlliance ;
 193: CALL 919 0 0
// MC_Start ( ) ;
 197: CALL 62341 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 9322 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 87
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 88
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 84058 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 57
 294: PPUSH
 295: CALL 84503 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 84961 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 85230 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 84443 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 85137 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 54
 401: PPUSH
 402: CALL 84503 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 84961 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 85230 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 84287 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 85548 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 84443 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , ru_active_attack , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 7
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 8
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 55
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 9
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 10
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ru_active_attack := true ;
 775: LD_ADDR_EXP 6
 779: PUSH
 780: LD_INT 1
 782: ST_TO_ADDR
// ar_attackers := [ ] ;
 783: LD_ADDR_EXP 12
 787: PUSH
 788: EMPTY
 789: ST_TO_ADDR
// first_powell_attack := false ;
 790: LD_ADDR_EXP 13
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// masha_killed := false ;
 798: LD_ADDR_EXP 11
 802: PUSH
 803: LD_INT 0
 805: ST_TO_ADDR
// abdul_escaped := true ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 1
 813: ST_TO_ADDR
// loss_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// hack_counter := 0 ;
 822: LD_ADDR_EXP 16
 826: PUSH
 827: LD_INT 0
 829: ST_TO_ADDR
// end ;
 830: LD_VAR 0 1
 834: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 835: LD_EXP 51
 839: PPUSH
 840: CALL_OW 255
 844: PUSH
 845: LD_INT 7
 847: EQUAL
 848: PUSH
 849: LD_EXP 50
 853: PPUSH
 854: CALL_OW 255
 858: PUSH
 859: LD_INT 7
 861: EQUAL
 862: AND
 863: PUSH
 864: LD_EXP 51
 868: PPUSH
 869: CALL_OW 302
 873: AND
 874: PUSH
 875: LD_EXP 50
 879: PPUSH
 880: CALL_OW 302
 884: AND
 885: IFFALSE 897
 887: GO 889
 889: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 890: LD_STRING ACH_COMRADE
 892: PPUSH
 893: CALL_OW 543
 897: END
// every 0 0$1 trigger hack_counter >= 10 do
 898: LD_EXP 16
 902: PUSH
 903: LD_INT 10
 905: GREATEREQUAL
 906: IFFALSE 918
 908: GO 910
 910: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 911: LD_STRING ACH_HACK
 913: PPUSH
 914: CALL_OW 543
 918: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 919: LD_INT 0
 921: PPUSH
 922: PPUSH
 923: PPUSH
 924: PPUSH
// uc_side := 7 ;
 925: LD_ADDR_OWVAR 20
 929: PUSH
 930: LD_INT 7
 932: ST_TO_ADDR
// uc_nation := 1 ;
 933: LD_ADDR_OWVAR 21
 937: PUSH
 938: LD_INT 1
 940: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING JMM
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 17276 0 3
 962: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 963: LD_EXP 17
 967: PPUSH
 968: LD_INT 71
 970: PPUSH
 971: LD_INT 23
 973: PPUSH
 974: LD_INT 0
 976: PPUSH
 977: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 981: LD_EXP 17
 985: PPUSH
 986: LD_INT 2
 988: PPUSH
 989: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 993: LD_ADDR_EXP 18
 997: PUSH
 998: LD_STRING Roth
1000: PPUSH
1001: LD_EXP 1
1005: NOT
1006: PPUSH
1007: LD_STRING 12a_
1009: PPUSH
1010: CALL 17276 0 3
1014: ST_TO_ADDR
// if Roth then
1015: LD_EXP 18
1019: IFFALSE 1039
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1021: LD_EXP 18
1025: PPUSH
1026: LD_INT 71
1028: PPUSH
1029: LD_INT 21
1031: PPUSH
1032: LD_INT 0
1034: PPUSH
1035: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1039: LD_ADDR_EXP 34
1043: PUSH
1044: LD_STRING Mike
1046: PPUSH
1047: LD_EXP 1
1051: NOT
1052: PPUSH
1053: LD_STRING 12a_
1055: PPUSH
1056: CALL 17276 0 3
1060: ST_TO_ADDR
// if Mike then
1061: LD_EXP 34
1065: IFFALSE 1082
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1067: LD_EXP 34
1071: PPUSH
1072: LD_INT 13
1074: PPUSH
1075: LD_INT 0
1077: PPUSH
1078: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1082: LD_ADDR_EXP 19
1086: PUSH
1087: LD_STRING Lisa
1089: PPUSH
1090: LD_EXP 1
1094: NOT
1095: PPUSH
1096: LD_STRING 12a_
1098: PPUSH
1099: CALL 17276 0 3
1103: ST_TO_ADDR
// if Lisa then
1104: LD_EXP 19
1108: IFFALSE 1125
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1110: LD_EXP 19
1114: PPUSH
1115: LD_INT 13
1117: PPUSH
1118: LD_INT 0
1120: PPUSH
1121: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1125: LD_ADDR_EXP 20
1129: PUSH
1130: LD_STRING Donaldson
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_STRING 12a_
1141: PPUSH
1142: CALL 17276 0 3
1146: ST_TO_ADDR
// if Donaldson then
1147: LD_EXP 20
1151: IFFALSE 1168
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1153: LD_EXP 20
1157: PPUSH
1158: LD_INT 13
1160: PPUSH
1161: LD_INT 0
1163: PPUSH
1164: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1168: LD_ADDR_EXP 21
1172: PUSH
1173: LD_STRING Bobby
1175: PPUSH
1176: LD_EXP 1
1180: NOT
1181: PPUSH
1182: LD_STRING 12a_
1184: PPUSH
1185: CALL 17276 0 3
1189: ST_TO_ADDR
// if Bobby then
1190: LD_EXP 21
1194: IFFALSE 1211
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1196: LD_EXP 21
1200: PPUSH
1201: LD_INT 13
1203: PPUSH
1204: LD_INT 0
1206: PPUSH
1207: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1211: LD_ADDR_EXP 22
1215: PUSH
1216: LD_STRING Cyrus
1218: PPUSH
1219: LD_EXP 1
1223: NOT
1224: PPUSH
1225: LD_STRING 12a_
1227: PPUSH
1228: CALL 17276 0 3
1232: ST_TO_ADDR
// if Cyrus then
1233: LD_EXP 22
1237: IFFALSE 1254
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1239: LD_EXP 22
1243: PPUSH
1244: LD_INT 13
1246: PPUSH
1247: LD_INT 0
1249: PPUSH
1250: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1254: LD_ADDR_EXP 23
1258: PUSH
1259: LD_STRING Denis
1261: PPUSH
1262: LD_EXP 1
1266: NOT
1267: PPUSH
1268: LD_STRING 12a_
1270: PPUSH
1271: CALL 17276 0 3
1275: ST_TO_ADDR
// if Denis then
1276: LD_EXP 23
1280: IFFALSE 1297
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1282: LD_EXP 23
1286: PPUSH
1287: LD_INT 13
1289: PPUSH
1290: LD_INT 0
1292: PPUSH
1293: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1297: LD_ADDR_EXP 24
1301: PUSH
1302: LD_STRING Brown
1304: PPUSH
1305: LD_EXP 1
1309: NOT
1310: PPUSH
1311: LD_STRING 12a_
1313: PPUSH
1314: CALL 17276 0 3
1318: ST_TO_ADDR
// if Brown then
1319: LD_EXP 24
1323: IFFALSE 1340
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1325: LD_EXP 24
1329: PPUSH
1330: LD_INT 13
1332: PPUSH
1333: LD_INT 0
1335: PPUSH
1336: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1340: LD_ADDR_EXP 25
1344: PUSH
1345: LD_STRING Gladstone
1347: PPUSH
1348: LD_EXP 1
1352: NOT
1353: PPUSH
1354: LD_STRING 12a_
1356: PPUSH
1357: CALL 17276 0 3
1361: ST_TO_ADDR
// if Gladstone then
1362: LD_EXP 25
1366: IFFALSE 1383
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1368: LD_EXP 25
1372: PPUSH
1373: LD_INT 13
1375: PPUSH
1376: LD_INT 0
1378: PPUSH
1379: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1383: LD_ADDR_EXP 26
1387: PUSH
1388: LD_STRING Houten
1390: PPUSH
1391: LD_EXP 1
1395: NOT
1396: PPUSH
1397: LD_STRING 12a_
1399: PPUSH
1400: CALL 17276 0 3
1404: ST_TO_ADDR
// if Houten then
1405: LD_EXP 26
1409: IFFALSE 1426
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1411: LD_EXP 26
1415: PPUSH
1416: LD_INT 13
1418: PPUSH
1419: LD_INT 0
1421: PPUSH
1422: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1426: LD_ADDR_EXP 27
1430: PUSH
1431: LD_STRING Cornell
1433: PPUSH
1434: LD_EXP 1
1438: NOT
1439: PPUSH
1440: LD_STRING 12a_
1442: PPUSH
1443: CALL 17276 0 3
1447: ST_TO_ADDR
// if Cornel then
1448: LD_EXP 27
1452: IFFALSE 1469
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1454: LD_EXP 27
1458: PPUSH
1459: LD_INT 13
1461: PPUSH
1462: LD_INT 0
1464: PPUSH
1465: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1469: LD_ADDR_EXP 28
1473: PUSH
1474: LD_STRING Gary
1476: PPUSH
1477: LD_EXP 1
1481: NOT
1482: PPUSH
1483: LD_STRING 12a_
1485: PPUSH
1486: CALL 17276 0 3
1490: ST_TO_ADDR
// if Gary then
1491: LD_EXP 28
1495: IFFALSE 1512
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1497: LD_EXP 28
1501: PPUSH
1502: LD_INT 13
1504: PPUSH
1505: LD_INT 0
1507: PPUSH
1508: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1512: LD_ADDR_EXP 29
1516: PUSH
1517: LD_STRING Frank
1519: PPUSH
1520: LD_EXP 1
1524: NOT
1525: PPUSH
1526: LD_STRING 12a_
1528: PPUSH
1529: CALL 17276 0 3
1533: ST_TO_ADDR
// if Frank then
1534: LD_EXP 29
1538: IFFALSE 1555
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1540: LD_EXP 29
1544: PPUSH
1545: LD_INT 13
1547: PPUSH
1548: LD_INT 0
1550: PPUSH
1551: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1555: LD_ADDR_EXP 30
1559: PUSH
1560: LD_STRING Kikuchi
1562: PPUSH
1563: LD_EXP 1
1567: NOT
1568: PPUSH
1569: LD_STRING 12a_
1571: PPUSH
1572: CALL 17276 0 3
1576: ST_TO_ADDR
// if Kikuchi then
1577: LD_EXP 30
1581: IFFALSE 1598
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1583: LD_EXP 30
1587: PPUSH
1588: LD_INT 13
1590: PPUSH
1591: LD_INT 0
1593: PPUSH
1594: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1598: LD_ADDR_EXP 31
1602: PUSH
1603: LD_STRING Simms
1605: PPUSH
1606: LD_EXP 1
1610: NOT
1611: PPUSH
1612: LD_STRING 12a_
1614: PPUSH
1615: CALL 17276 0 3
1619: ST_TO_ADDR
// if Simms then
1620: LD_EXP 31
1624: IFFALSE 1641
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1626: LD_EXP 31
1630: PPUSH
1631: LD_INT 13
1633: PPUSH
1634: LD_INT 0
1636: PPUSH
1637: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1641: LD_ADDR_EXP 32
1645: PUSH
1646: LD_STRING Joan
1648: PPUSH
1649: LD_EXP 1
1653: NOT
1654: PPUSH
1655: LD_STRING 12a_
1657: PPUSH
1658: CALL 17276 0 3
1662: ST_TO_ADDR
// if Joan then
1663: LD_EXP 32
1667: IFFALSE 1684
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1669: LD_EXP 32
1673: PPUSH
1674: LD_INT 13
1676: PPUSH
1677: LD_INT 0
1679: PPUSH
1680: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1684: LD_ADDR_EXP 33
1688: PUSH
1689: LD_STRING DeltaDoctor
1691: PPUSH
1692: LD_EXP 1
1696: NOT
1697: PPUSH
1698: LD_STRING 12a_
1700: PPUSH
1701: CALL 17276 0 3
1705: ST_TO_ADDR
// if DeltaDoctor then
1706: LD_EXP 33
1710: IFFALSE 1727
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1712: LD_EXP 33
1716: PPUSH
1717: LD_INT 13
1719: PPUSH
1720: LD_INT 0
1722: PPUSH
1723: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1727: LD_ADDR_VAR 0 4
1731: PUSH
1732: LD_STRING 12a_others
1734: PPUSH
1735: CALL_OW 31
1739: ST_TO_ADDR
// if tmp then
1740: LD_VAR 0 4
1744: IFFALSE 1778
// for i in tmp do
1746: LD_ADDR_VAR 0 3
1750: PUSH
1751: LD_VAR 0 4
1755: PUSH
1756: FOR_IN
1757: IFFALSE 1776
// PlaceUnitArea ( i , alliance_start , false ) ;
1759: LD_VAR 0 3
1763: PPUSH
1764: LD_INT 13
1766: PPUSH
1767: LD_INT 0
1769: PPUSH
1770: CALL_OW 49
1774: GO 1756
1776: POP
1777: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1778: LD_INT 3
1780: PPUSH
1781: LD_INT 3
1783: PPUSH
1784: LD_INT 3
1786: PPUSH
1787: LD_INT 12
1789: PPUSH
1790: LD_INT 100
1792: PPUSH
1793: CALL 22200 0 5
// veh := CreateVehicle ;
1797: LD_ADDR_VAR 0 2
1801: PUSH
1802: CALL_OW 45
1806: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 2
1814: PPUSH
1815: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1819: LD_VAR 0 2
1823: PPUSH
1824: LD_INT 60
1826: PPUSH
1827: LD_INT 6
1829: PPUSH
1830: LD_INT 0
1832: PPUSH
1833: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1837: LD_VAR 0 2
1841: PPUSH
1842: LD_INT 4
1844: PPUSH
1845: LD_INT 30
1847: PPUSH
1848: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1852: LD_STRING 11_artifact_captured
1854: PPUSH
1855: LD_INT 0
1857: PPUSH
1858: CALL_OW 30
1862: IFFALSE 1938
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1864: LD_INT 3
1866: PPUSH
1867: LD_INT 3
1869: PPUSH
1870: LD_INT 3
1872: PPUSH
1873: LD_INT 12
1875: PPUSH
1876: LD_INT 100
1878: PPUSH
1879: CALL 22200 0 5
// veh := CreateVehicle ;
1883: LD_ADDR_VAR 0 2
1887: PUSH
1888: CALL_OW 45
1892: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1893: LD_VAR 0 2
1897: PPUSH
1898: LD_INT 3
1900: PPUSH
1901: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1905: LD_VAR 0 2
1909: PPUSH
1910: LD_INT 75
1912: PPUSH
1913: LD_INT 6
1915: PPUSH
1916: LD_INT 0
1918: PPUSH
1919: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1923: LD_VAR 0 2
1927: PPUSH
1928: LD_INT 4
1930: PPUSH
1931: LD_INT 50
1933: PPUSH
1934: CALL_OW 290
// end ; end ;
1938: LD_VAR 0 1
1942: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1943: LD_INT 0
1945: PPUSH
1946: PPUSH
1947: PPUSH
1948: PPUSH
// uc_side := 6 ;
1949: LD_ADDR_OWVAR 20
1953: PUSH
1954: LD_INT 6
1956: ST_TO_ADDR
// uc_nation := 3 ;
1957: LD_ADDR_OWVAR 21
1961: PUSH
1962: LD_INT 3
1964: ST_TO_ADDR
// InitHc ;
1965: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1969: LD_ADDR_EXP 35
1973: PUSH
1974: LD_STRING Gossudarov
1976: PPUSH
1977: CALL_OW 25
1981: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1982: LD_ADDR_EXP 36
1986: PUSH
1987: LD_STRING Kirilenkova
1989: PPUSH
1990: CALL_OW 25
1994: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1995: LD_ADDR_EXP 37
1999: PUSH
2000: LD_STRING Titov
2002: PPUSH
2003: CALL_OW 25
2007: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2008: LD_ADDR_EXP 42
2012: PUSH
2013: LD_STRING Oblukov
2015: PPUSH
2016: CALL_OW 25
2020: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2021: LD_ADDR_EXP 39
2025: PUSH
2026: LD_STRING Dolgov
2028: PPUSH
2029: CALL_OW 25
2033: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2034: LD_ADDR_EXP 40
2038: PUSH
2039: LD_STRING Petrosyan
2041: PPUSH
2042: CALL_OW 25
2046: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2047: LD_ADDR_EXP 41
2051: PUSH
2052: LD_STRING Scholtze
2054: PPUSH
2055: CALL_OW 25
2059: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2060: LD_ADDR_EXP 43
2064: PUSH
2065: LD_STRING Kapitsova
2067: PPUSH
2068: CALL_OW 25
2072: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2073: LD_ADDR_VAR 0 2
2077: PUSH
2078: LD_EXP 35
2082: PUSH
2083: LD_EXP 36
2087: PUSH
2088: LD_EXP 37
2092: PUSH
2093: LD_EXP 42
2097: PUSH
2098: LD_EXP 39
2102: PUSH
2103: LD_EXP 40
2107: PUSH
2108: LD_EXP 41
2112: PUSH
2113: LD_EXP 43
2117: PUSH
2118: EMPTY
2119: LIST
2120: LIST
2121: LIST
2122: LIST
2123: LIST
2124: LIST
2125: LIST
2126: LIST
2127: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2128: LD_INT 1
2130: PPUSH
2131: LD_INT 4
2133: PPUSH
2134: LD_INT 8
2136: PPUSH
2137: CALL_OW 380
// un := CreateHuman ;
2141: LD_ADDR_VAR 0 4
2145: PUSH
2146: CALL_OW 44
2150: ST_TO_ADDR
// tmp := tmp ^ un ;
2151: LD_ADDR_VAR 0 2
2155: PUSH
2156: LD_VAR 0 2
2160: PUSH
2161: LD_VAR 0 4
2165: ADD
2166: ST_TO_ADDR
// for i in tmp do
2167: LD_ADDR_VAR 0 3
2171: PUSH
2172: LD_VAR 0 2
2176: PUSH
2177: FOR_IN
2178: IFFALSE 2197
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2180: LD_VAR 0 3
2184: PPUSH
2185: LD_INT 14
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
2195: GO 2177
2197: POP
2198: POP
// if freedom then
2199: LD_EXP 3
2203: IFFALSE 2236
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2205: LD_VAR 0 2
2209: PPUSH
2210: LD_EXP 3
2214: PPUSH
2215: CALL_OW 250
2219: PPUSH
2220: LD_EXP 3
2224: PPUSH
2225: CALL_OW 251
2229: PPUSH
2230: CALL_OW 111
2234: GO 2251
// ComMoveXY ( tmp , 70 , 48 ) ;
2236: LD_VAR 0 2
2240: PPUSH
2241: LD_INT 70
2243: PPUSH
2244: LD_INT 48
2246: PPUSH
2247: CALL_OW 111
// end ;
2251: LD_VAR 0 1
2255: RET
// export function PrepareBelkov ; begin
2256: LD_INT 0
2258: PPUSH
// uc_side := 4 ;
2259: LD_ADDR_OWVAR 20
2263: PUSH
2264: LD_INT 4
2266: ST_TO_ADDR
// uc_nation := 3 ;
2267: LD_ADDR_OWVAR 21
2271: PUSH
2272: LD_INT 3
2274: ST_TO_ADDR
// InitHc ;
2275: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2279: LD_ADDR_EXP 50
2283: PUSH
2284: LD_STRING Belkov
2286: PPUSH
2287: CALL_OW 25
2291: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2292: LD_EXP 50
2296: PPUSH
2297: LD_INT 14
2299: PPUSH
2300: LD_INT 0
2302: PPUSH
2303: CALL_OW 49
// end ;
2307: LD_VAR 0 1
2311: RET
// export function PrepareGnyevko ; begin
2312: LD_INT 0
2314: PPUSH
// uc_side := 4 ;
2315: LD_ADDR_OWVAR 20
2319: PUSH
2320: LD_INT 4
2322: ST_TO_ADDR
// uc_nation := 3 ;
2323: LD_ADDR_OWVAR 21
2327: PUSH
2328: LD_INT 3
2330: ST_TO_ADDR
// InitHc ;
2331: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2335: LD_ADDR_EXP 51
2339: PUSH
2340: LD_STRING Gnyevko
2342: PPUSH
2343: CALL_OW 25
2347: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2348: LD_EXP 51
2352: PPUSH
2353: LD_INT 14
2355: PPUSH
2356: LD_INT 0
2358: PPUSH
2359: CALL_OW 49
// end ;
2363: LD_VAR 0 1
2367: RET
// export function PrepareBurlak ; var i , tmp ; begin
2368: LD_INT 0
2370: PPUSH
2371: PPUSH
2372: PPUSH
// uc_side := 4 ;
2373: LD_ADDR_OWVAR 20
2377: PUSH
2378: LD_INT 4
2380: ST_TO_ADDR
// uc_nation := 3 ;
2381: LD_ADDR_OWVAR 21
2385: PUSH
2386: LD_INT 3
2388: ST_TO_ADDR
// InitHc ;
2389: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2393: LD_ADDR_EXP 49
2397: PUSH
2398: LD_STRING Burlak
2400: PPUSH
2401: CALL_OW 25
2405: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2406: LD_INT 24
2408: PUSH
2409: LD_INT 23
2411: PUSH
2412: LD_INT 22
2414: PUSH
2415: LD_INT 22
2417: PUSH
2418: EMPTY
2419: LIST
2420: LIST
2421: LIST
2422: LIST
2423: PUSH
2424: LD_OWVAR 67
2428: ARRAY
2429: PPUSH
2430: LD_INT 1
2432: PPUSH
2433: LD_INT 1
2435: PPUSH
2436: LD_INT 45
2438: PUSH
2439: LD_INT 44
2441: PUSH
2442: LD_INT 43
2444: PUSH
2445: LD_INT 42
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: LD_OWVAR 67
2458: ARRAY
2459: PPUSH
2460: LD_INT 0
2462: PPUSH
2463: CALL 22200 0 5
// Masha := CreateVehicle ;
2467: LD_ADDR_EXP 52
2471: PUSH
2472: CALL_OW 45
2476: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2477: LD_EXP 52
2481: PUSH
2482: LD_EXP 49
2486: PUSH
2487: EMPTY
2488: LIST
2489: LIST
2490: PPUSH
2491: LD_INT 499
2493: PPUSH
2494: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2498: LD_EXP 52
2502: PPUSH
2503: LD_INT 3
2505: PPUSH
2506: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2510: LD_EXP 52
2514: PPUSH
2515: LD_INT 1
2517: PPUSH
2518: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2522: LD_INT 1
2524: PPUSH
2525: LD_INT 18
2527: PPUSH
2528: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2532: LD_INT 35
2534: PPUSH
2535: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2539: LD_ADDR_VAR 0 3
2543: PUSH
2544: LD_INT 18
2546: PPUSH
2547: EMPTY
2548: PPUSH
2549: CALL_OW 70
2553: ST_TO_ADDR
// if tmp then
2554: LD_VAR 0 3
2558: IFFALSE 2592
// for i in tmp do
2560: LD_ADDR_VAR 0 2
2564: PUSH
2565: LD_VAR 0 3
2569: PUSH
2570: FOR_IN
2571: IFFALSE 2590
// ComMoveXY ( i , 114 , 9 ) ;
2573: LD_VAR 0 2
2577: PPUSH
2578: LD_INT 114
2580: PPUSH
2581: LD_INT 9
2583: PPUSH
2584: CALL_OW 111
2588: GO 2570
2590: POP
2591: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2592: LD_INT 18
2594: PPUSH
2595: EMPTY
2596: PPUSH
2597: CALL_OW 70
2601: NOT
2602: PUSH
2603: LD_INT 123
2605: PPUSH
2606: LD_INT 3
2608: PPUSH
2609: CALL_OW 428
2613: PUSH
2614: LD_INT 0
2616: EQUAL
2617: AND
2618: IFFALSE 2532
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2620: LD_EXP 52
2624: PPUSH
2625: LD_INT 123
2627: PPUSH
2628: LD_INT 3
2630: PPUSH
2631: LD_INT 0
2633: PPUSH
2634: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2638: LD_EXP 49
2642: PPUSH
2643: LD_INT 125
2645: PPUSH
2646: LD_INT 1
2648: PPUSH
2649: LD_INT 0
2651: PPUSH
2652: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2656: LD_EXP 49
2660: PPUSH
2661: LD_EXP 52
2665: PPUSH
2666: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2670: LD_INT 10
2672: PPUSH
2673: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2677: LD_EXP 52
2681: PPUSH
2682: LD_INT 110
2684: PPUSH
2685: LD_INT 10
2687: PPUSH
2688: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2692: LD_ADDR_EXP 45
2696: PUSH
2697: LD_STRING Petrovova
2699: PPUSH
2700: CALL_OW 25
2704: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2705: LD_ADDR_EXP 47
2709: PUSH
2710: LD_STRING Kuzmov
2712: PPUSH
2713: CALL_OW 25
2717: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2718: LD_ADDR_EXP 46
2722: PUSH
2723: LD_STRING Kovalyuk
2725: PPUSH
2726: CALL_OW 25
2730: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2731: LD_ADDR_EXP 44
2735: PUSH
2736: LD_STRING Lipshchin
2738: PPUSH
2739: CALL_OW 25
2743: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2744: LD_ADDR_EXP 48
2748: PUSH
2749: LD_STRING Karamazov
2751: PPUSH
2752: CALL_OW 25
2756: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2757: LD_ADDR_VAR 0 3
2761: PUSH
2762: LD_EXP 45
2766: PUSH
2767: LD_EXP 47
2771: PUSH
2772: LD_EXP 46
2776: PUSH
2777: LD_EXP 44
2781: PUSH
2782: LD_EXP 48
2786: PUSH
2787: EMPTY
2788: LIST
2789: LIST
2790: LIST
2791: LIST
2792: LIST
2793: ST_TO_ADDR
// for i in tmp do
2794: LD_ADDR_VAR 0 2
2798: PUSH
2799: LD_VAR 0 3
2803: PUSH
2804: FOR_IN
2805: IFFALSE 2844
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2807: LD_VAR 0 2
2811: PPUSH
2812: LD_INT 399
2814: PPUSH
2815: LD_INT 799
2817: PPUSH
2818: CALL_OW 12
2822: PPUSH
2823: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2827: LD_VAR 0 2
2831: PPUSH
2832: LD_INT 19
2834: PPUSH
2835: LD_INT 0
2837: PPUSH
2838: CALL_OW 49
// end ;
2842: GO 2804
2844: POP
2845: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2846: LD_VAR 0 3
2850: PPUSH
2851: LD_INT 112
2853: PPUSH
2854: LD_INT 5
2856: PPUSH
2857: CALL_OW 111
// AddComHold ( tmp ) ;
2861: LD_VAR 0 3
2865: PPUSH
2866: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2870: LD_ADDR_VAR 0 2
2874: PUSH
2875: LD_VAR 0 3
2879: PPUSH
2880: LD_INT 25
2882: PUSH
2883: LD_INT 1
2885: PUSH
2886: EMPTY
2887: LIST
2888: LIST
2889: PPUSH
2890: CALL_OW 72
2894: PUSH
2895: FOR_IN
2896: IFFALSE 2936
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2898: LD_VAR 0 2
2902: PPUSH
2903: LD_INT 20
2905: PPUSH
2906: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2910: LD_VAR 0 2
2914: PPUSH
2915: LD_INT 147
2917: PPUSH
2918: LD_INT 45
2920: PPUSH
2921: CALL_OW 178
// AddComCrawl ( i ) ;
2925: LD_VAR 0 2
2929: PPUSH
2930: CALL_OW 197
// end ;
2934: GO 2895
2936: POP
2937: POP
// repeat wait ( 0 0$1 ) ;
2938: LD_INT 35
2940: PPUSH
2941: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2945: LD_EXP 52
2949: PPUSH
2950: LD_INT 110
2952: PPUSH
2953: LD_INT 10
2955: PPUSH
2956: CALL_OW 307
2960: PUSH
2961: LD_EXP 52
2965: PPUSH
2966: CALL_OW 305
2970: NOT
2971: OR
2972: IFFALSE 2938
// ComStop ( Burlak ) ;
2974: LD_EXP 49
2978: PPUSH
2979: CALL_OW 141
// AddComHold ( Burlak ) ;
2983: LD_EXP 49
2987: PPUSH
2988: CALL_OW 200
// end ; end_of_file
2992: LD_VAR 0 1
2996: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2997: LD_INT 0
2999: PPUSH
3000: PPUSH
3001: PPUSH
3002: PPUSH
3003: PPUSH
// uc_side := 3 ;
3004: LD_ADDR_OWVAR 20
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// uc_nation := 3 ;
3012: LD_ADDR_OWVAR 21
3016: PUSH
3017: LD_INT 3
3019: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3020: LD_ADDR_EXP 53
3024: PUSH
3025: LD_INT 47
3027: PPUSH
3028: LD_INT 4
3030: PPUSH
3031: LD_STRING 
3033: PPUSH
3034: LD_INT 7
3036: PUSH
3037: LD_INT 8
3039: PUSH
3040: LD_INT 9
3042: PUSH
3043: LD_INT 10
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_OWVAR 67
3056: ARRAY
3057: PPUSH
3058: LD_INT 10000
3060: PUSH
3061: LD_INT 3000
3063: PUSH
3064: LD_INT 300
3066: PUSH
3067: EMPTY
3068: LIST
3069: LIST
3070: LIST
3071: PPUSH
3072: LD_INT 9
3074: PUSH
3075: LD_INT 5
3077: PUSH
3078: LD_INT 6
3080: PUSH
3081: LD_INT 6
3083: PUSH
3084: EMPTY
3085: LIST
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: CALL 26021 0 6
3094: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3095: LD_ADDR_EXP 63
3099: PUSH
3100: LD_EXP 63
3104: PPUSH
3105: LD_INT 2
3107: PPUSH
3108: LD_EXP 53
3112: PPUSH
3113: CALL_OW 1
3117: ST_TO_ADDR
// tmp := [ ] ;
3118: LD_ADDR_VAR 0 4
3122: PUSH
3123: EMPTY
3124: ST_TO_ADDR
// for i = 1 to 4 do
3125: LD_ADDR_VAR 0 2
3129: PUSH
3130: DOUBLE
3131: LD_INT 1
3133: DEC
3134: ST_TO_ADDR
3135: LD_INT 4
3137: PUSH
3138: FOR_TO
3139: IFFALSE 3232
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3141: LD_INT 22
3143: PPUSH
3144: LD_INT 3
3146: PPUSH
3147: LD_INT 3
3149: PPUSH
3150: LD_INT 43
3152: PUSH
3153: LD_INT 45
3155: PUSH
3156: LD_INT 45
3158: PUSH
3159: LD_INT 44
3161: PUSH
3162: EMPTY
3163: LIST
3164: LIST
3165: LIST
3166: LIST
3167: PUSH
3168: LD_VAR 0 2
3172: PUSH
3173: LD_INT 4
3175: MOD
3176: PUSH
3177: LD_INT 1
3179: PLUS
3180: ARRAY
3181: PPUSH
3182: LD_INT 100
3184: PPUSH
3185: CALL 22200 0 5
// veh := CreateVehicle ;
3189: LD_ADDR_VAR 0 3
3193: PUSH
3194: CALL_OW 45
3198: ST_TO_ADDR
// tmp := tmp ^ veh ;
3199: LD_ADDR_VAR 0 4
3203: PUSH
3204: LD_VAR 0 4
3208: PUSH
3209: LD_VAR 0 3
3213: ADD
3214: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3215: LD_VAR 0 3
3219: PPUSH
3220: LD_INT 2
3222: PPUSH
3223: LD_INT 0
3225: PPUSH
3226: CALL_OW 49
// end ;
3230: GO 3138
3232: POP
3233: POP
// russian_guard := tmp ;
3234: LD_ADDR_EXP 54
3238: PUSH
3239: LD_VAR 0 4
3243: ST_TO_ADDR
// if Difficulty >= 3 then
3244: LD_OWVAR 67
3248: PUSH
3249: LD_INT 3
3251: GREATEREQUAL
3252: IFFALSE 3316
// begin bc_type := b_breastwork ;
3254: LD_ADDR_OWVAR 42
3258: PUSH
3259: LD_INT 31
3261: ST_TO_ADDR
// bc_level := 10 ;
3262: LD_ADDR_OWVAR 43
3266: PUSH
3267: LD_INT 10
3269: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3270: LD_ADDR_VAR 0 5
3274: PUSH
3275: LD_INT 96
3277: PPUSH
3278: LD_INT 105
3280: PPUSH
3281: LD_INT 3
3283: PPUSH
3284: CALL_OW 47
3288: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3289: LD_INT 0
3291: PPUSH
3292: LD_INT 9
3294: PPUSH
3295: LD_INT 10
3297: PPUSH
3298: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3302: CALL_OW 44
3306: PPUSH
3307: LD_VAR 0 5
3311: PPUSH
3312: CALL_OW 52
// end ; end ;
3316: LD_VAR 0 1
3320: RET
// every 5 5$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , _target , attackers , amount ;
3321: LD_INT 47
3323: PPUSH
3324: CALL_OW 302
3328: PUSH
3329: LD_EXP 7
3333: AND
3334: IFFALSE 4088
3336: GO 3338
3338: DISABLE
3339: LD_INT 0
3341: PPUSH
3342: PPUSH
3343: PPUSH
3344: PPUSH
3345: PPUSH
3346: PPUSH
3347: PPUSH
// begin enable ;
3348: ENABLE
// base := 2 ;
3349: LD_ADDR_VAR 0 3
3353: PUSH
3354: LD_INT 2
3356: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3357: LD_ADDR_VAR 0 4
3361: PUSH
3362: LD_INT 22
3364: PUSH
3365: LD_INT 1
3367: PUSH
3368: LD_INT 3
3370: PUSH
3371: LD_INT 45
3373: PUSH
3374: EMPTY
3375: LIST
3376: LIST
3377: LIST
3378: LIST
3379: PUSH
3380: LD_INT 21
3382: PUSH
3383: LD_INT 1
3385: PUSH
3386: LD_INT 3
3388: PUSH
3389: LD_INT 45
3391: PUSH
3392: EMPTY
3393: LIST
3394: LIST
3395: LIST
3396: LIST
3397: PUSH
3398: LD_INT 22
3400: PUSH
3401: LD_INT 1
3403: PUSH
3404: LD_INT 3
3406: PUSH
3407: LD_INT 45
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: LIST
3415: PUSH
3416: LD_INT 23
3418: PUSH
3419: LD_INT 1
3421: PUSH
3422: LD_INT 3
3424: PUSH
3425: LD_INT 46
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: LIST
3432: LIST
3433: PUSH
3434: EMPTY
3435: LIST
3436: LIST
3437: LIST
3438: LIST
3439: ST_TO_ADDR
// amount := Difficulty ;
3440: LD_ADDR_VAR 0 7
3444: PUSH
3445: LD_OWVAR 67
3449: ST_TO_ADDR
// if tick > 30 30$00 then
3450: LD_OWVAR 1
3454: PUSH
3455: LD_INT 63000
3457: GREATER
3458: IFFALSE 3495
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3460: LD_ADDR_VAR 0 7
3464: PUSH
3465: LD_VAR 0 7
3469: PUSH
3470: LD_INT 2
3472: PUSH
3473: LD_INT 3
3475: PUSH
3476: LD_INT 4
3478: PUSH
3479: LD_INT 4
3481: PUSH
3482: EMPTY
3483: LIST
3484: LIST
3485: LIST
3486: LIST
3487: PUSH
3488: LD_OWVAR 67
3492: ARRAY
3493: PLUS
3494: ST_TO_ADDR
// for i = 1 to amount do
3495: LD_ADDR_VAR 0 1
3499: PUSH
3500: DOUBLE
3501: LD_INT 1
3503: DEC
3504: ST_TO_ADDR
3505: LD_VAR 0 7
3509: PUSH
3510: FOR_TO
3511: IFFALSE 3599
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3513: LD_ADDR_VAR 0 4
3517: PUSH
3518: LD_VAR 0 4
3522: PPUSH
3523: LD_VAR 0 4
3527: PUSH
3528: LD_INT 1
3530: PLUS
3531: PPUSH
3532: LD_INT 23
3534: PUSH
3535: LD_INT 24
3537: PUSH
3538: EMPTY
3539: LIST
3540: LIST
3541: PUSH
3542: LD_INT 1
3544: PPUSH
3545: LD_INT 2
3547: PPUSH
3548: CALL_OW 12
3552: ARRAY
3553: PUSH
3554: LD_INT 1
3556: PUSH
3557: LD_INT 3
3559: PUSH
3560: LD_INT 46
3562: PUSH
3563: LD_INT 47
3565: PUSH
3566: LD_INT 45
3568: PUSH
3569: EMPTY
3570: LIST
3571: LIST
3572: LIST
3573: PUSH
3574: LD_INT 1
3576: PPUSH
3577: LD_INT 3
3579: PPUSH
3580: CALL_OW 12
3584: ARRAY
3585: PUSH
3586: EMPTY
3587: LIST
3588: LIST
3589: LIST
3590: LIST
3591: PPUSH
3592: CALL_OW 2
3596: ST_TO_ADDR
3597: GO 3510
3599: POP
3600: POP
// p := 1 ;
3601: LD_ADDR_VAR 0 2
3605: PUSH
3606: LD_INT 1
3608: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3609: LD_VAR 0 3
3613: PPUSH
3614: LD_VAR 0 4
3618: PPUSH
3619: CALL 84443 0 2
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// p := Inc ( p ) ;
3630: LD_ADDR_VAR 0 2
3634: PUSH
3635: LD_VAR 0 2
3639: PPUSH
3640: CALL 56432 0 1
3644: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 60 ;
3645: LD_VAR 0 3
3649: PPUSH
3650: LD_INT 1
3652: PPUSH
3653: CALL 85861 0 2
3657: PUSH
3658: LD_VAR 0 7
3662: GREATEREQUAL
3663: PUSH
3664: LD_VAR 0 2
3668: PUSH
3669: LD_INT 60
3671: GREATEREQUAL
3672: OR
3673: IFFALSE 3623
// wait ( 0 0$30 ) ;
3675: LD_INT 1050
3677: PPUSH
3678: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3682: LD_ADDR_VAR 0 5
3686: PUSH
3687: LD_INT 71
3689: PUSH
3690: LD_INT 19
3692: PUSH
3693: EMPTY
3694: LIST
3695: LIST
3696: PUSH
3697: LD_INT 91
3699: PUSH
3700: LD_INT 67
3702: PUSH
3703: EMPTY
3704: LIST
3705: LIST
3706: PUSH
3707: LD_INT 52
3709: PUSH
3710: LD_INT 44
3712: PUSH
3713: EMPTY
3714: LIST
3715: LIST
3716: PUSH
3717: LD_INT 68
3719: PUSH
3720: LD_INT 48
3722: PUSH
3723: EMPTY
3724: LIST
3725: LIST
3726: PUSH
3727: EMPTY
3728: LIST
3729: LIST
3730: LIST
3731: LIST
3732: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ru_crane ] , [ f_weapon , ru_cargo_bay ] ] ] ] ) diff mc_defender [ base ] ;
3733: LD_ADDR_VAR 0 6
3737: PUSH
3738: LD_INT 22
3740: PUSH
3741: LD_INT 3
3743: PUSH
3744: EMPTY
3745: LIST
3746: LIST
3747: PUSH
3748: LD_INT 21
3750: PUSH
3751: LD_INT 2
3753: PUSH
3754: EMPTY
3755: LIST
3756: LIST
3757: PUSH
3758: LD_INT 3
3760: PUSH
3761: LD_INT 2
3763: PUSH
3764: LD_INT 34
3766: PUSH
3767: LD_INT 52
3769: PUSH
3770: EMPTY
3771: LIST
3772: LIST
3773: PUSH
3774: LD_INT 34
3776: PUSH
3777: LD_INT 51
3779: PUSH
3780: EMPTY
3781: LIST
3782: LIST
3783: PUSH
3784: EMPTY
3785: LIST
3786: LIST
3787: LIST
3788: PUSH
3789: EMPTY
3790: LIST
3791: LIST
3792: PUSH
3793: EMPTY
3794: LIST
3795: LIST
3796: LIST
3797: PPUSH
3798: CALL_OW 69
3802: PUSH
3803: LD_EXP 85
3807: PUSH
3808: LD_VAR 0 3
3812: ARRAY
3813: DIFF
3814: ST_TO_ADDR
// if not attackers then
3815: LD_VAR 0 6
3819: NOT
3820: IFFALSE 3824
// exit ;
3822: GO 4088
// ru_attackers := attackers ;
3824: LD_ADDR_EXP 55
3828: PUSH
3829: LD_VAR 0 6
3833: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3834: LD_ADDR_EXP 82
3838: PUSH
3839: LD_EXP 82
3843: PPUSH
3844: LD_VAR 0 3
3848: PPUSH
3849: LD_EXP 82
3853: PUSH
3854: LD_VAR 0 3
3858: ARRAY
3859: PUSH
3860: LD_VAR 0 6
3864: DIFF
3865: PPUSH
3866: CALL_OW 1
3870: ST_TO_ADDR
// for i = 1 to attackers do
3871: LD_ADDR_VAR 0 1
3875: PUSH
3876: DOUBLE
3877: LD_INT 1
3879: DEC
3880: ST_TO_ADDR
3881: LD_VAR 0 6
3885: PUSH
3886: FOR_TO
3887: IFFALSE 3964
// begin case i mod 3 of 0 :
3889: LD_VAR 0 1
3893: PUSH
3894: LD_INT 3
3896: MOD
3897: PUSH
3898: LD_INT 0
3900: DOUBLE
3901: EQUAL
3902: IFTRUE 3906
3904: GO 3909
3906: POP
// ; 1 :
3907: GO 3962
3909: LD_INT 1
3911: DOUBLE
3912: EQUAL
3913: IFTRUE 3917
3915: GO 3935
3917: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3918: LD_VAR 0 1
3922: PPUSH
3923: LD_INT 32
3925: PPUSH
3926: LD_INT 49
3928: PPUSH
3929: CALL_OW 114
3933: GO 3962
3935: LD_INT 2
3937: DOUBLE
3938: EQUAL
3939: IFTRUE 3943
3941: GO 3961
3943: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3944: LD_VAR 0 1
3948: PPUSH
3949: LD_INT 117
3951: PPUSH
3952: LD_INT 107
3954: PPUSH
3955: CALL_OW 114
3959: GO 3962
3961: POP
// end ;
3962: GO 3886
3964: POP
3965: POP
// p := 0 ;
3966: LD_ADDR_VAR 0 2
3970: PUSH
3971: LD_INT 0
3973: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3974: LD_INT 35
3976: PPUSH
3977: CALL_OW 67
// p := Inc ( p ) ;
3981: LD_ADDR_VAR 0 2
3985: PUSH
3986: LD_VAR 0 2
3990: PPUSH
3991: CALL 56432 0 1
3995: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
3996: LD_VAR 0 6
4000: PPUSH
4001: LD_INT 60
4003: PUSH
4004: EMPTY
4005: LIST
4006: PPUSH
4007: CALL_OW 72
4011: NOT
4012: PUSH
4013: LD_VAR 0 2
4017: PUSH
4018: LD_INT 30
4020: GREATER
4021: OR
4022: IFFALSE 3974
// if not first_attack then
4024: LD_EXP 8
4028: NOT
4029: IFFALSE 4039
// first_attack := true ;
4031: LD_ADDR_EXP 8
4035: PUSH
4036: LD_INT 1
4038: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4039: LD_INT 35
4041: PPUSH
4042: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
4046: LD_ADDR_VAR 0 6
4050: PUSH
4051: LD_VAR 0 6
4055: PPUSH
4056: LD_INT 50
4058: PUSH
4059: EMPTY
4060: LIST
4061: PPUSH
4062: CALL_OW 72
4066: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
4067: LD_VAR 0 6
4071: PPUSH
4072: LD_VAR 0 5
4076: PPUSH
4077: CALL 57681 0 2
// until not attackers ;
4081: LD_VAR 0 6
4085: NOT
4086: IFFALSE 4039
// end ;
4088: PPOPN 7
4090: END
// export function PrepareRussianAttack ; var i , tmp , veh , chassis , weapon ; begin
4091: LD_INT 0
4093: PPUSH
4094: PPUSH
4095: PPUSH
4096: PPUSH
4097: PPUSH
4098: PPUSH
// uc_side := 6 ;
4099: LD_ADDR_OWVAR 20
4103: PUSH
4104: LD_INT 6
4106: ST_TO_ADDR
// uc_nation := 3 ;
4107: LD_ADDR_OWVAR 21
4111: PUSH
4112: LD_INT 3
4114: ST_TO_ADDR
// InitHc ;
4115: CALL_OW 19
// InitVc ;
4119: CALL_OW 20
// tmp := [ ] ;
4123: LD_ADDR_VAR 0 3
4127: PUSH
4128: EMPTY
4129: ST_TO_ADDR
// for i := 1 to [ 4 , 5 , 6 , 7 ] [ Difficulty ] do
4130: LD_ADDR_VAR 0 2
4134: PUSH
4135: DOUBLE
4136: LD_INT 1
4138: DEC
4139: ST_TO_ADDR
4140: LD_INT 4
4142: PUSH
4143: LD_INT 5
4145: PUSH
4146: LD_INT 6
4148: PUSH
4149: LD_INT 7
4151: PUSH
4152: EMPTY
4153: LIST
4154: LIST
4155: LIST
4156: LIST
4157: PUSH
4158: LD_OWVAR 67
4162: ARRAY
4163: PUSH
4164: FOR_TO
4165: IFFALSE 4419
// begin chassis := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 3 ) ] ;
4167: LD_ADDR_VAR 0 5
4171: PUSH
4172: LD_INT 21
4174: PUSH
4175: LD_INT 22
4177: PUSH
4178: LD_INT 24
4180: PUSH
4181: EMPTY
4182: LIST
4183: LIST
4184: LIST
4185: PUSH
4186: LD_INT 1
4188: PPUSH
4189: LD_INT 3
4191: PPUSH
4192: CALL_OW 12
4196: ARRAY
4197: ST_TO_ADDR
// case chassis of ru_medium_wheeled , ru_medium_tracked :
4198: LD_VAR 0 5
4202: PUSH
4203: LD_INT 21
4205: DOUBLE
4206: EQUAL
4207: IFTRUE 4217
4209: LD_INT 22
4211: DOUBLE
4212: EQUAL
4213: IFTRUE 4217
4215: GO 4251
4217: POP
// weapon := [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ rand ( 1 , 3 ) ] ; ru_heavy_tracked :
4218: LD_ADDR_VAR 0 6
4222: PUSH
4223: LD_INT 45
4225: PUSH
4226: LD_INT 44
4228: PUSH
4229: LD_INT 43
4231: PUSH
4232: EMPTY
4233: LIST
4234: LIST
4235: LIST
4236: PUSH
4237: LD_INT 1
4239: PPUSH
4240: LD_INT 3
4242: PPUSH
4243: CALL_OW 12
4247: ARRAY
4248: ST_TO_ADDR
4249: GO 4298
4251: LD_INT 24
4253: DOUBLE
4254: EQUAL
4255: IFTRUE 4259
4257: GO 4297
4259: POP
// weapon := [ ru_heavy_gun , ru_rocket , ru_rocket_launcher , ru_heavy_gun ] [ rand ( 1 , 4 ) ] ; end ;
4260: LD_ADDR_VAR 0 6
4264: PUSH
4265: LD_INT 46
4267: PUSH
4268: LD_INT 47
4270: PUSH
4271: LD_INT 45
4273: PUSH
4274: LD_INT 46
4276: PUSH
4277: EMPTY
4278: LIST
4279: LIST
4280: LIST
4281: LIST
4282: PUSH
4283: LD_INT 1
4285: PPUSH
4286: LD_INT 4
4288: PPUSH
4289: CALL_OW 12
4293: ARRAY
4294: ST_TO_ADDR
4295: GO 4298
4297: POP
// uc_side := 6 ;
4298: LD_ADDR_OWVAR 20
4302: PUSH
4303: LD_INT 6
4305: ST_TO_ADDR
// uc_nation := 3 ;
4306: LD_ADDR_OWVAR 21
4310: PUSH
4311: LD_INT 3
4313: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
4314: LD_VAR 0 5
4318: PPUSH
4319: LD_INT 1
4321: PUSH
4322: LD_INT 3
4324: PUSH
4325: EMPTY
4326: LIST
4327: LIST
4328: PUSH
4329: LD_INT 1
4331: PPUSH
4332: LD_INT 2
4334: PPUSH
4335: CALL_OW 12
4339: ARRAY
4340: PPUSH
4341: LD_INT 3
4343: PPUSH
4344: LD_VAR 0 6
4348: PPUSH
4349: LD_INT 70
4351: PPUSH
4352: LD_INT 90
4354: PPUSH
4355: CALL_OW 12
4359: PPUSH
4360: CALL 22200 0 5
// veh := CreateVehicle ;
4364: LD_ADDR_VAR 0 4
4368: PUSH
4369: CALL_OW 45
4373: ST_TO_ADDR
// SetDir ( veh , 5 ) ;
4374: LD_VAR 0 4
4378: PPUSH
4379: LD_INT 5
4381: PPUSH
4382: CALL_OW 233
// PlaceUnitArea ( veh , south_spawn , false ) ;
4386: LD_VAR 0 4
4390: PPUSH
4391: LD_INT 16
4393: PPUSH
4394: LD_INT 0
4396: PPUSH
4397: CALL_OW 49
// tmp := tmp ^ veh ;
4401: LD_ADDR_VAR 0 3
4405: PUSH
4406: LD_VAR 0 3
4410: PUSH
4411: LD_VAR 0 4
4415: ADD
4416: ST_TO_ADDR
// end ;
4417: GO 4164
4419: POP
4420: POP
// if not tmp then
4421: LD_VAR 0 3
4425: NOT
4426: IFFALSE 4430
// exit ;
4428: GO 4524
// repeat wait ( 0 0$2 ) ;
4430: LD_INT 70
4432: PPUSH
4433: CALL_OW 67
// for i in tmp do
4437: LD_ADDR_VAR 0 2
4441: PUSH
4442: LD_VAR 0 3
4446: PUSH
4447: FOR_IN
4448: IFFALSE 4515
// if IsOk ( i ) then
4450: LD_VAR 0 2
4454: PPUSH
4455: CALL_OW 302
4459: IFFALSE 4497
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , i ) ) else
4461: LD_VAR 0 2
4465: PPUSH
4466: LD_INT 22
4468: PUSH
4469: LD_INT 7
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PPUSH
4476: CALL_OW 69
4480: PPUSH
4481: LD_VAR 0 2
4485: PPUSH
4486: CALL_OW 74
4490: PPUSH
4491: CALL_OW 115
4495: GO 4513
// tmp := tmp diff i ;
4497: LD_ADDR_VAR 0 3
4501: PUSH
4502: LD_VAR 0 3
4506: PUSH
4507: LD_VAR 0 2
4511: DIFF
4512: ST_TO_ADDR
4513: GO 4447
4515: POP
4516: POP
// until not tmp ;
4517: LD_VAR 0 3
4521: NOT
4522: IFFALSE 4430
// end ;
4524: LD_VAR 0 1
4528: RET
// every 10 10$00 + 3 3$00 trigger first_attack and IsOk ( ru_depot ) and GetSide ( ru_depot ) = 3 and ru_active_attack do
4529: LD_EXP 8
4533: PUSH
4534: LD_INT 47
4536: PPUSH
4537: CALL_OW 302
4541: AND
4542: PUSH
4543: LD_INT 47
4545: PPUSH
4546: CALL_OW 255
4550: PUSH
4551: LD_INT 3
4553: EQUAL
4554: AND
4555: PUSH
4556: LD_EXP 6
4560: AND
4561: IFFALSE 4571
4563: GO 4565
4565: DISABLE
// begin enable ;
4566: ENABLE
// PrepareRussianAttack ;
4567: CALL 4091 0 0
// end ; end_of_file
4571: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , b , veh , area , tmp , xy , un , un2 ; begin
4572: LD_INT 0
4574: PPUSH
4575: PPUSH
4576: PPUSH
4577: PPUSH
4578: PPUSH
4579: PPUSH
4580: PPUSH
4581: PPUSH
4582: PPUSH
// uc_side := 2 ;
4583: LD_ADDR_OWVAR 20
4587: PUSH
4588: LD_INT 2
4590: ST_TO_ADDR
// uc_nation := 2 ;
4591: LD_ADDR_OWVAR 21
4595: PUSH
4596: LD_INT 2
4598: ST_TO_ADDR
// PlaceHiddenCamerasInArea ( 2 , camArea ) ;
4599: LD_INT 2
4601: PPUSH
4602: LD_INT 28
4604: PPUSH
4605: CALL 60016 0 2
// PlaceMines ( minefieldExtraNorthArea , [ 0 , 0 , 6 , 8 ] [ Difficulty ] ) ;
4609: LD_INT 25
4611: PPUSH
4612: LD_INT 0
4614: PUSH
4615: LD_INT 0
4617: PUSH
4618: LD_INT 6
4620: PUSH
4621: LD_INT 8
4623: PUSH
4624: EMPTY
4625: LIST
4626: LIST
4627: LIST
4628: LIST
4629: PUSH
4630: LD_OWVAR 67
4634: ARRAY
4635: PPUSH
4636: CALL 8103 0 2
// PlaceMines ( minefieldExtraSouthArea , [ 0 , 4 , 8 , 12 ] [ Difficulty ] ) ;
4640: LD_INT 26
4642: PPUSH
4643: LD_INT 0
4645: PUSH
4646: LD_INT 4
4648: PUSH
4649: LD_INT 8
4651: PUSH
4652: LD_INT 12
4654: PUSH
4655: EMPTY
4656: LIST
4657: LIST
4658: LIST
4659: LIST
4660: PUSH
4661: LD_OWVAR 67
4665: ARRAY
4666: PPUSH
4667: CALL 8103 0 2
// if Difficulty > 2 then
4671: LD_OWVAR 67
4675: PUSH
4676: LD_INT 2
4678: GREATER
4679: IFFALSE 4849
// begin bc_type := b_breastwork ;
4681: LD_ADDR_OWVAR 42
4685: PUSH
4686: LD_INT 31
4688: ST_TO_ADDR
// bc_level := 8 ;
4689: LD_ADDR_OWVAR 43
4693: PUSH
4694: LD_INT 8
4696: ST_TO_ADDR
// for area in [ extraBunkerArArea , extraBunkerArArea2 ] do
4697: LD_ADDR_VAR 0 5
4701: PUSH
4702: LD_INT 27
4704: PUSH
4705: LD_INT 29
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: FOR_IN
4713: IFFALSE 4847
// begin tmp := GetBuildingFromArea ( area , 1 ) ;
4715: LD_ADDR_VAR 0 6
4719: PUSH
4720: LD_VAR 0 5
4724: PPUSH
4725: LD_INT 1
4727: PPUSH
4728: CALL 59616 0 2
4732: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( tmp [ 1 ] , tmp [ 2 ] , tmp [ 3 ] ) ;
4733: LD_ADDR_VAR 0 3
4737: PUSH
4738: LD_VAR 0 6
4742: PUSH
4743: LD_INT 1
4745: ARRAY
4746: PPUSH
4747: LD_VAR 0 6
4751: PUSH
4752: LD_INT 2
4754: ARRAY
4755: PPUSH
4756: LD_VAR 0 6
4760: PUSH
4761: LD_INT 3
4763: ARRAY
4764: PPUSH
4765: CALL_OW 47
4769: ST_TO_ADDR
// PrepareSoldier ( false , 5 + Difficulty ) ;
4770: LD_INT 0
4772: PPUSH
4773: LD_INT 5
4775: PUSH
4776: LD_OWVAR 67
4780: PLUS
4781: PPUSH
4782: CALL_OW 381
// un := CreateHuman ;
4786: LD_ADDR_VAR 0 8
4790: PUSH
4791: CALL_OW 44
4795: ST_TO_ADDR
// SetDir ( un , GetDir ( b ) - 3 ) ;
4796: LD_VAR 0 8
4800: PPUSH
4801: LD_VAR 0 3
4805: PPUSH
4806: CALL_OW 254
4810: PUSH
4811: LD_INT 3
4813: MINUS
4814: PPUSH
4815: CALL_OW 233
// SetClass ( un , class_sniper ) ;
4819: LD_VAR 0 8
4823: PPUSH
4824: LD_INT 5
4826: PPUSH
4827: CALL_OW 336
// PlaceHumanInUnit ( un , b ) ;
4831: LD_VAR 0 8
4835: PPUSH
4836: LD_VAR 0 3
4840: PPUSH
4841: CALL_OW 52
// end ;
4845: GO 4712
4847: POP
4848: POP
// end ; Abdul := NewCharacter ( Abdul ) ;
4849: LD_ADDR_EXP 58
4853: PUSH
4854: LD_STRING Abdul
4856: PPUSH
4857: CALL_OW 25
4861: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4862: LD_EXP 58
4866: PPUSH
4867: LD_INT 11
4869: PPUSH
4870: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4874: LD_EXP 58
4878: PPUSH
4879: LD_INT 1
4881: PPUSH
4882: CALL_OW 52
// vc_chassis := 31 ;
4886: LD_ADDR_OWVAR 37
4890: PUSH
4891: LD_INT 31
4893: ST_TO_ADDR
// vc_control := control_rider ;
4894: LD_ADDR_OWVAR 38
4898: PUSH
4899: LD_INT 4
4901: ST_TO_ADDR
// mastodont := CreateVehicle ;
4902: LD_ADDR_EXP 59
4906: PUSH
4907: CALL_OW 45
4911: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4912: LD_EXP 59
4916: PPUSH
4917: LD_INT 153
4919: PPUSH
4920: LD_INT 71
4922: PPUSH
4923: LD_INT 0
4925: PPUSH
4926: CALL_OW 48
// InitVc ;
4930: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 11 , 5 , 6 , 7 ] ) ;
4934: LD_ADDR_EXP 56
4938: PUSH
4939: LD_INT 1
4941: PPUSH
4942: LD_INT 3
4944: PPUSH
4945: LD_STRING kaba
4947: PPUSH
4948: LD_INT 7
4950: PUSH
4951: LD_INT 8
4953: PUSH
4954: LD_INT 9
4956: PUSH
4957: LD_INT 10
4959: PUSH
4960: EMPTY
4961: LIST
4962: LIST
4963: LIST
4964: LIST
4965: PUSH
4966: LD_OWVAR 67
4970: ARRAY
4971: PPUSH
4972: LD_INT 5000
4974: PUSH
4975: LD_INT 1000
4977: PUSH
4978: LD_INT 300
4980: PUSH
4981: EMPTY
4982: LIST
4983: LIST
4984: LIST
4985: PPUSH
4986: LD_INT 11
4988: PUSH
4989: LD_INT 5
4991: PUSH
4992: LD_INT 6
4994: PUSH
4995: LD_INT 7
4997: PUSH
4998: EMPTY
4999: LIST
5000: LIST
5001: LIST
5002: LIST
5003: PPUSH
5004: CALL 26021 0 6
5008: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
5009: LD_ADDR_EXP 63
5013: PUSH
5014: LD_EXP 63
5018: PPUSH
5019: LD_INT 1
5021: PPUSH
5022: LD_EXP 56
5026: PPUSH
5027: CALL_OW 1
5031: ST_TO_ADDR
// tmp := [ ] ;
5032: LD_ADDR_VAR 0 6
5036: PUSH
5037: EMPTY
5038: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
5039: LD_ADDR_OWVAR 37
5043: PUSH
5044: LD_INT 13
5046: ST_TO_ADDR
// vc_engine := engine_siberite ;
5047: LD_ADDR_OWVAR 39
5051: PUSH
5052: LD_INT 3
5054: ST_TO_ADDR
// vc_control := control_manual ;
5055: LD_ADDR_OWVAR 38
5059: PUSH
5060: LD_INT 1
5062: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
5063: LD_ADDR_OWVAR 40
5067: PUSH
5068: LD_INT 31
5070: ST_TO_ADDR
// for i = 1 to 3 do
5071: LD_ADDR_VAR 0 2
5075: PUSH
5076: DOUBLE
5077: LD_INT 1
5079: DEC
5080: ST_TO_ADDR
5081: LD_INT 3
5083: PUSH
5084: FOR_TO
5085: IFFALSE 5333
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
5087: LD_ADDR_VAR 0 7
5091: PUSH
5092: LD_INT 153
5094: PUSH
5095: LD_INT 71
5097: PUSH
5098: EMPTY
5099: LIST
5100: LIST
5101: PUSH
5102: LD_INT 155
5104: PUSH
5105: LD_INT 81
5107: PUSH
5108: EMPTY
5109: LIST
5110: LIST
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: PUSH
5116: LD_VAR 0 2
5120: PUSH
5121: LD_INT 2
5123: MOD
5124: PUSH
5125: LD_INT 1
5127: PLUS
5128: ARRAY
5129: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
5130: LD_INT 0
5132: PPUSH
5133: LD_INT 3
5135: PPUSH
5136: LD_INT 7
5138: PUSH
5139: LD_INT 8
5141: PUSH
5142: LD_INT 10
5144: PUSH
5145: LD_INT 10
5147: PUSH
5148: EMPTY
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: PUSH
5154: LD_OWVAR 67
5158: ARRAY
5159: PPUSH
5160: CALL_OW 380
// un := CreateVehicle ;
5164: LD_ADDR_VAR 0 8
5168: PUSH
5169: CALL_OW 45
5173: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
5174: LD_VAR 0 8
5178: PPUSH
5179: LD_INT 0
5181: PPUSH
5182: LD_INT 5
5184: PPUSH
5185: CALL_OW 12
5189: PPUSH
5190: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
5194: LD_VAR 0 8
5198: PPUSH
5199: LD_VAR 0 7
5203: PUSH
5204: LD_INT 1
5206: ARRAY
5207: PPUSH
5208: LD_VAR 0 7
5212: PUSH
5213: LD_INT 2
5215: ARRAY
5216: PPUSH
5217: LD_INT 6
5219: PPUSH
5220: LD_INT 0
5222: PPUSH
5223: CALL_OW 50
// un2 := CreateHuman ;
5227: LD_ADDR_VAR 0 9
5231: PUSH
5232: CALL_OW 44
5236: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
5237: LD_VAR 0 9
5241: PPUSH
5242: LD_VAR 0 8
5246: PPUSH
5247: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
5251: LD_ADDR_EXP 63
5255: PUSH
5256: LD_EXP 63
5260: PPUSH
5261: LD_INT 1
5263: PUSH
5264: LD_EXP 63
5268: PUSH
5269: LD_INT 1
5271: ARRAY
5272: PUSH
5273: LD_INT 1
5275: PLUS
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PPUSH
5281: LD_VAR 0 8
5285: PPUSH
5286: CALL 22322 0 3
5290: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
5291: LD_ADDR_EXP 63
5295: PUSH
5296: LD_EXP 63
5300: PPUSH
5301: LD_INT 1
5303: PUSH
5304: LD_EXP 63
5308: PUSH
5309: LD_INT 1
5311: ARRAY
5312: PUSH
5313: LD_INT 1
5315: PLUS
5316: PUSH
5317: EMPTY
5318: LIST
5319: LIST
5320: PPUSH
5321: LD_VAR 0 9
5325: PPUSH
5326: CALL 22322 0 3
5330: ST_TO_ADDR
// end ;
5331: GO 5084
5333: POP
5334: POP
// for i = 1 to 5 do
5335: LD_ADDR_VAR 0 2
5339: PUSH
5340: DOUBLE
5341: LD_INT 1
5343: DEC
5344: ST_TO_ADDR
5345: LD_INT 5
5347: PUSH
5348: FOR_TO
5349: IFFALSE 5442
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
5351: LD_INT 13
5353: PPUSH
5354: LD_INT 3
5356: PPUSH
5357: LD_INT 1
5359: PPUSH
5360: LD_INT 25
5362: PUSH
5363: LD_INT 28
5365: PUSH
5366: LD_INT 28
5368: PUSH
5369: LD_INT 26
5371: PUSH
5372: EMPTY
5373: LIST
5374: LIST
5375: LIST
5376: LIST
5377: PUSH
5378: LD_VAR 0 2
5382: PUSH
5383: LD_INT 4
5385: MOD
5386: PUSH
5387: LD_INT 1
5389: PLUS
5390: ARRAY
5391: PPUSH
5392: LD_INT 100
5394: PPUSH
5395: CALL 22200 0 5
// veh := CreateVehicle ;
5399: LD_ADDR_VAR 0 4
5403: PUSH
5404: CALL_OW 45
5408: ST_TO_ADDR
// tmp := tmp ^ veh ;
5409: LD_ADDR_VAR 0 6
5413: PUSH
5414: LD_VAR 0 6
5418: PUSH
5419: LD_VAR 0 4
5423: ADD
5424: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
5425: LD_VAR 0 4
5429: PPUSH
5430: LD_INT 1
5432: PPUSH
5433: LD_INT 0
5435: PPUSH
5436: CALL_OW 49
// end ;
5440: GO 5348
5442: POP
5443: POP
// arabian_guard := tmp ;
5444: LD_ADDR_EXP 57
5448: PUSH
5449: LD_VAR 0 6
5453: ST_TO_ADDR
// end ;
5454: LD_VAR 0 1
5458: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
5459: LD_INT 22
5461: PUSH
5462: LD_INT 7
5464: PUSH
5465: EMPTY
5466: LIST
5467: LIST
5468: PUSH
5469: LD_INT 91
5471: PUSH
5472: LD_INT 1
5474: PUSH
5475: LD_INT 12
5477: PUSH
5478: EMPTY
5479: LIST
5480: LIST
5481: LIST
5482: PUSH
5483: EMPTY
5484: LIST
5485: LIST
5486: PPUSH
5487: CALL_OW 69
5491: PUSH
5492: LD_EXP 59
5496: PPUSH
5497: CALL_OW 256
5501: PUSH
5502: LD_INT 990
5504: LESS
5505: OR
5506: PUSH
5507: LD_EXP 58
5511: PPUSH
5512: CALL_OW 256
5516: PUSH
5517: LD_INT 990
5519: LESS
5520: OR
5521: IFFALSE 5664
5523: GO 5525
5525: DISABLE
// begin if IsInUnit ( Abdul ) then
5526: LD_EXP 58
5530: PPUSH
5531: CALL_OW 310
5535: IFFALSE 5546
// ComExitBuilding ( Abdul ) ;
5537: LD_EXP 58
5541: PPUSH
5542: CALL_OW 122
// if Mastodont then
5546: LD_EXP 59
5550: IFFALSE 5567
// ComMoveXY ( Mastodont , 205 , 132 ) ;
5552: LD_EXP 59
5556: PPUSH
5557: LD_INT 205
5559: PPUSH
5560: LD_INT 132
5562: PPUSH
5563: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
5567: LD_EXP 58
5571: PPUSH
5572: LD_INT 205
5574: PPUSH
5575: LD_INT 132
5577: PPUSH
5578: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
5582: LD_INT 35
5584: PPUSH
5585: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
5589: LD_EXP 58
5593: PPUSH
5594: LD_INT 21
5596: PPUSH
5597: CALL_OW 308
5601: IFFALSE 5582
// RemoveUnit ( Abdul ) ;
5603: LD_EXP 58
5607: PPUSH
5608: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
5612: LD_INT 35
5614: PPUSH
5615: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
5619: LD_EXP 59
5623: PPUSH
5624: LD_INT 21
5626: PPUSH
5627: CALL_OW 308
5631: PUSH
5632: LD_EXP 59
5636: PPUSH
5637: CALL_OW 301
5641: OR
5642: IFFALSE 5612
// if IsOk ( Mastodont ) then
5644: LD_EXP 59
5648: PPUSH
5649: CALL_OW 302
5653: IFFALSE 5664
// RemoveUnit ( Mastodont ) ;
5655: LD_EXP 59
5659: PPUSH
5660: CALL_OW 64
// end ;
5664: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
5665: LD_EXP 58
5669: PPUSH
5670: CALL_OW 301
5674: PUSH
5675: LD_INT 22
5677: PUSH
5678: LD_INT 2
5680: PUSH
5681: EMPTY
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 2
5687: PUSH
5688: LD_INT 25
5690: PUSH
5691: LD_INT 1
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 25
5700: PUSH
5701: LD_INT 2
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 25
5710: PUSH
5711: LD_INT 3
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 25
5720: PUSH
5721: LD_INT 4
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_INT 25
5730: PUSH
5731: LD_INT 8
5733: PUSH
5734: EMPTY
5735: LIST
5736: LIST
5737: PUSH
5738: EMPTY
5739: LIST
5740: LIST
5741: LIST
5742: LIST
5743: LIST
5744: LIST
5745: PUSH
5746: EMPTY
5747: LIST
5748: LIST
5749: PPUSH
5750: CALL_OW 69
5754: PUSH
5755: LD_INT 16
5757: PUSH
5758: LD_INT 19
5760: PUSH
5761: LD_INT 22
5763: PUSH
5764: LD_INT 22
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_OWVAR 67
5777: ARRAY
5778: LESS
5779: OR
5780: IFFALSE 6453
5782: GO 5784
5784: DISABLE
5785: LD_INT 0
5787: PPUSH
5788: PPUSH
5789: PPUSH
5790: PPUSH
5791: PPUSH
5792: PPUSH
// begin MC_Kill ( 1 ) ;
5793: LD_INT 1
5795: PPUSH
5796: CALL 60418 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5800: LD_ADDR_VAR 0 2
5804: PUSH
5805: LD_INT 22
5807: PUSH
5808: LD_INT 2
5810: PUSH
5811: EMPTY
5812: LIST
5813: LIST
5814: PUSH
5815: LD_INT 2
5817: PUSH
5818: LD_INT 25
5820: PUSH
5821: LD_INT 1
5823: PUSH
5824: EMPTY
5825: LIST
5826: LIST
5827: PUSH
5828: LD_INT 25
5830: PUSH
5831: LD_INT 2
5833: PUSH
5834: EMPTY
5835: LIST
5836: LIST
5837: PUSH
5838: LD_INT 25
5840: PUSH
5841: LD_INT 3
5843: PUSH
5844: EMPTY
5845: LIST
5846: LIST
5847: PUSH
5848: LD_INT 25
5850: PUSH
5851: LD_INT 4
5853: PUSH
5854: EMPTY
5855: LIST
5856: LIST
5857: PUSH
5858: LD_INT 25
5860: PUSH
5861: LD_INT 8
5863: PUSH
5864: EMPTY
5865: LIST
5866: LIST
5867: PUSH
5868: EMPTY
5869: LIST
5870: LIST
5871: LIST
5872: LIST
5873: LIST
5874: LIST
5875: PUSH
5876: EMPTY
5877: LIST
5878: LIST
5879: PPUSH
5880: CALL_OW 69
5884: ST_TO_ADDR
// for i in tmp do
5885: LD_ADDR_VAR 0 5
5889: PUSH
5890: LD_VAR 0 2
5894: PUSH
5895: FOR_IN
5896: IFFALSE 5912
// SetTag ( i , 10 ) ;
5898: LD_VAR 0 5
5902: PPUSH
5903: LD_INT 10
5905: PPUSH
5906: CALL_OW 109
5910: GO 5895
5912: POP
5913: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5914: LD_ADDR_VAR 0 3
5918: PUSH
5919: LD_INT 22
5921: PUSH
5922: LD_INT 2
5924: PUSH
5925: EMPTY
5926: LIST
5927: LIST
5928: PUSH
5929: LD_INT 21
5931: PUSH
5932: LD_INT 1
5934: PUSH
5935: EMPTY
5936: LIST
5937: LIST
5938: PUSH
5939: EMPTY
5940: LIST
5941: LIST
5942: PPUSH
5943: CALL_OW 69
5947: PUSH
5948: LD_VAR 0 2
5952: DIFF
5953: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: LD_INT 22
5961: PUSH
5962: LD_INT 2
5964: PUSH
5965: EMPTY
5966: LIST
5967: LIST
5968: PUSH
5969: LD_INT 21
5971: PUSH
5972: LD_INT 2
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PUSH
5979: LD_INT 24
5981: PUSH
5982: LD_INT 300
5984: PUSH
5985: EMPTY
5986: LIST
5987: LIST
5988: PUSH
5989: EMPTY
5990: LIST
5991: LIST
5992: LIST
5993: PPUSH
5994: CALL_OW 69
5998: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5999: LD_ADDR_VAR 0 4
6003: PUSH
6004: LD_VAR 0 1
6008: PPUSH
6009: LD_INT 33
6011: PUSH
6012: LD_INT 1
6014: PUSH
6015: EMPTY
6016: LIST
6017: LIST
6018: PUSH
6019: LD_INT 58
6021: PUSH
6022: EMPTY
6023: LIST
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: PPUSH
6029: CALL_OW 72
6033: ST_TO_ADDR
// for i in tmp do
6034: LD_ADDR_VAR 0 5
6038: PUSH
6039: LD_VAR 0 2
6043: PUSH
6044: FOR_IN
6045: IFFALSE 6229
// begin if i in FilterAllUnits ( [ f_driving ] ) then
6047: LD_VAR 0 5
6051: PUSH
6052: LD_INT 55
6054: PUSH
6055: EMPTY
6056: LIST
6057: PPUSH
6058: CALL_OW 69
6062: IN
6063: IFFALSE 6082
// begin AddComMoveXY ( i , 209 , 132 ) ;
6065: LD_VAR 0 5
6069: PPUSH
6070: LD_INT 209
6072: PPUSH
6073: LD_INT 132
6075: PPUSH
6076: CALL_OW 171
// continue ;
6080: GO 6044
// end ; if IsInUnit ( i ) then
6082: LD_VAR 0 5
6086: PPUSH
6087: CALL_OW 310
6091: IFFALSE 6109
// begin ComExitBuilding ( i ) ;
6093: LD_VAR 0 5
6097: PPUSH
6098: CALL_OW 122
// wait ( 3 ) ;
6102: LD_INT 3
6104: PPUSH
6105: CALL_OW 67
// end ; if tmp_empty then
6109: LD_VAR 0 4
6113: IFFALSE 6212
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
6115: LD_VAR 0 5
6119: PPUSH
6120: LD_VAR 0 4
6124: PPUSH
6125: LD_VAR 0 5
6129: PPUSH
6130: CALL_OW 74
6134: PPUSH
6135: CALL_OW 296
6139: PUSH
6140: LD_INT 25
6142: LESS
6143: IFFALSE 6212
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
6145: LD_ADDR_VAR 0 6
6149: PUSH
6150: LD_VAR 0 4
6154: PPUSH
6155: LD_VAR 0 5
6159: PPUSH
6160: CALL_OW 74
6164: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
6165: LD_VAR 0 5
6169: PPUSH
6170: LD_VAR 0 6
6174: PPUSH
6175: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
6179: LD_VAR 0 5
6183: PPUSH
6184: LD_INT 209
6186: PPUSH
6187: LD_INT 132
6189: PPUSH
6190: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
6194: LD_ADDR_VAR 0 4
6198: PUSH
6199: LD_VAR 0 4
6203: PUSH
6204: LD_VAR 0 6
6208: DIFF
6209: ST_TO_ADDR
// continue ;
6210: GO 6044
// end ; AddComMoveXY ( i , 201 , 132 ) ;
6212: LD_VAR 0 5
6216: PPUSH
6217: LD_INT 201
6219: PPUSH
6220: LD_INT 132
6222: PPUSH
6223: CALL_OW 171
// end ;
6227: GO 6044
6229: POP
6230: POP
// for i in tmp_ape do
6231: LD_ADDR_VAR 0 5
6235: PUSH
6236: LD_VAR 0 3
6240: PUSH
6241: FOR_IN
6242: IFFALSE 6281
// begin if IsInUnit ( i ) then
6244: LD_VAR 0 5
6248: PPUSH
6249: CALL_OW 310
6253: IFFALSE 6264
// ComExitBuilding ( i ) ;
6255: LD_VAR 0 5
6259: PPUSH
6260: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
6264: LD_VAR 0 5
6268: PPUSH
6269: LD_INT 201
6271: PPUSH
6272: LD_INT 132
6274: PPUSH
6275: CALL_OW 171
// end ;
6279: GO 6241
6281: POP
6282: POP
// repeat wait ( 0 0$1 ) ;
6283: LD_INT 35
6285: PPUSH
6286: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
6290: LD_ADDR_VAR 0 5
6294: PUSH
6295: LD_VAR 0 2
6299: PUSH
6300: LD_VAR 0 3
6304: UNION
6305: PUSH
6306: LD_VAR 0 1
6310: UNION
6311: PUSH
6312: FOR_IN
6313: IFFALSE 6344
// if not HasTask ( i ) then
6315: LD_VAR 0 5
6319: PPUSH
6320: CALL_OW 314
6324: NOT
6325: IFFALSE 6342
// ComMoveXY ( i , 201 , 132 ) ;
6327: LD_VAR 0 5
6331: PPUSH
6332: LD_INT 201
6334: PPUSH
6335: LD_INT 132
6337: PPUSH
6338: CALL_OW 111
6342: GO 6312
6344: POP
6345: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
6346: LD_INT 21
6348: PPUSH
6349: LD_INT 22
6351: PUSH
6352: LD_INT 2
6354: PUSH
6355: EMPTY
6356: LIST
6357: LIST
6358: PPUSH
6359: CALL_OW 70
6363: IFFALSE 6404
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
6365: LD_ADDR_VAR 0 5
6369: PUSH
6370: LD_INT 21
6372: PPUSH
6373: LD_INT 22
6375: PUSH
6376: LD_INT 2
6378: PUSH
6379: EMPTY
6380: LIST
6381: LIST
6382: PPUSH
6383: CALL_OW 70
6387: PUSH
6388: FOR_IN
6389: IFFALSE 6402
// RemoveUnit ( i ) ;
6391: LD_VAR 0 5
6395: PPUSH
6396: CALL_OW 64
6400: GO 6388
6402: POP
6403: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
6404: LD_INT 22
6406: PUSH
6407: LD_INT 2
6409: PUSH
6410: EMPTY
6411: LIST
6412: LIST
6413: PUSH
6414: LD_INT 2
6416: PUSH
6417: LD_INT 21
6419: PUSH
6420: LD_INT 1
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PUSH
6427: LD_INT 21
6429: PUSH
6430: LD_INT 2
6432: PUSH
6433: EMPTY
6434: LIST
6435: LIST
6436: PUSH
6437: EMPTY
6438: LIST
6439: LIST
6440: LIST
6441: PUSH
6442: EMPTY
6443: LIST
6444: LIST
6445: PPUSH
6446: CALL_OW 69
6450: NOT
6451: IFFALSE 6283
// end ;
6453: PPOPN 6
6455: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
6456: LD_EXP 10
6460: PUSH
6461: LD_INT 92
6463: PPUSH
6464: LD_INT 40
6466: PPUSH
6467: CALL_OW 428
6471: PPUSH
6472: CALL_OW 266
6476: PUSH
6477: LD_INT 30
6479: EQUAL
6480: AND
6481: IFFALSE 6677
6483: GO 6485
6485: DISABLE
6486: LD_INT 0
6488: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
6489: LD_ADDR_VAR 0 1
6493: PUSH
6494: LD_EXP 63
6498: PUSH
6499: LD_INT 1
6501: ARRAY
6502: PPUSH
6503: LD_INT 25
6505: PUSH
6506: LD_INT 4
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PPUSH
6513: CALL_OW 72
6517: ST_TO_ADDR
// if not sci then
6518: LD_VAR 0 1
6522: NOT
6523: IFFALSE 6527
// exit ;
6525: GO 6677
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
6527: LD_ADDR_EXP 63
6531: PUSH
6532: LD_EXP 63
6536: PPUSH
6537: LD_INT 1
6539: PPUSH
6540: LD_EXP 63
6544: PUSH
6545: LD_INT 1
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 1
6553: PUSH
6554: LD_INT 1
6556: ARRAY
6557: DIFF
6558: PPUSH
6559: CALL_OW 1
6563: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
6564: LD_VAR 0 1
6568: PUSH
6569: LD_INT 1
6571: ARRAY
6572: PPUSH
6573: CALL_OW 310
6577: IFFALSE 6592
// ComExitBuilding ( sci [ 1 ] ) ;
6579: LD_VAR 0 1
6583: PUSH
6584: LD_INT 1
6586: ARRAY
6587: PPUSH
6588: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
6592: LD_INT 2
6594: PPUSH
6595: LD_INT 105
6597: PPUSH
6598: LD_INT 14
6600: PPUSH
6601: LD_INT 20
6603: PPUSH
6604: CALL 23586 0 4
6608: PUSH
6609: LD_INT 4
6611: ARRAY
6612: PUSH
6613: LD_INT 10
6615: LESS
6616: IFFALSE 6639
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
6618: LD_VAR 0 1
6622: PUSH
6623: LD_INT 1
6625: ARRAY
6626: PPUSH
6627: LD_INT 105
6629: PPUSH
6630: LD_INT 14
6632: PPUSH
6633: CALL_OW 171
6637: GO 6658
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
6639: LD_VAR 0 1
6643: PUSH
6644: LD_INT 1
6646: ARRAY
6647: PPUSH
6648: LD_INT 118
6650: PPUSH
6651: LD_INT 77
6653: PPUSH
6654: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
6658: LD_VAR 0 1
6662: PUSH
6663: LD_INT 1
6665: ARRAY
6666: PPUSH
6667: LD_INT 92
6669: PPUSH
6670: LD_INT 40
6672: PPUSH
6673: CALL_OW 218
// end ;
6677: PPOPN 1
6679: END
// every 6 6$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
6680: LD_INT 1
6682: PPUSH
6683: CALL_OW 302
6687: PUSH
6688: LD_EXP 10
6692: AND
6693: IFFALSE 7582
6695: GO 6697
6697: DISABLE
6698: LD_INT 0
6700: PPUSH
6701: PPUSH
6702: PPUSH
6703: PPUSH
6704: PPUSH
6705: PPUSH
6706: PPUSH
6707: PPUSH
// begin enable ;
6708: ENABLE
// base := 1 ;
6709: LD_ADDR_VAR 0 3
6713: PUSH
6714: LD_INT 1
6716: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6717: LD_ADDR_VAR 0 5
6721: PUSH
6722: LD_INT 0
6724: PUSH
6725: LD_INT 0
6727: PUSH
6728: LD_INT 0
6730: PUSH
6731: LD_INT 0
6733: PUSH
6734: LD_INT 0
6736: PUSH
6737: LD_INT 0
6739: PUSH
6740: LD_INT 0
6742: PUSH
6743: LD_INT 0
6745: PUSH
6746: LD_INT 1
6748: PUSH
6749: LD_INT 0
6751: PUSH
6752: EMPTY
6753: LIST
6754: LIST
6755: LIST
6756: LIST
6757: LIST
6758: LIST
6759: LIST
6760: LIST
6761: LIST
6762: LIST
6763: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6764: LD_ADDR_VAR 0 4
6768: PUSH
6769: LD_INT 13
6771: PUSH
6772: LD_INT 1
6774: PUSH
6775: LD_INT 2
6777: PUSH
6778: LD_INT 26
6780: PUSH
6781: EMPTY
6782: LIST
6783: LIST
6784: LIST
6785: LIST
6786: PUSH
6787: LD_INT 13
6789: PUSH
6790: LD_INT 1
6792: PUSH
6793: LD_INT 2
6795: PUSH
6796: LD_INT 28
6798: PUSH
6799: EMPTY
6800: LIST
6801: LIST
6802: LIST
6803: LIST
6804: PUSH
6805: LD_INT 13
6807: PUSH
6808: LD_INT 1
6810: PUSH
6811: LD_INT 2
6813: PUSH
6814: LD_INT 29
6816: PUSH
6817: EMPTY
6818: LIST
6819: LIST
6820: LIST
6821: LIST
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6828: LD_ADDR_VAR 0 1
6832: PUSH
6833: DOUBLE
6834: LD_INT 1
6836: DEC
6837: ST_TO_ADDR
6838: LD_OWVAR 67
6842: PUSH
6843: LD_OWVAR 1
6847: PUSH
6848: LD_INT 21000
6850: DIV
6851: PLUS
6852: PUSH
6853: FOR_TO
6854: IFFALSE 6927
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6856: LD_ADDR_VAR 0 4
6860: PUSH
6861: LD_VAR 0 4
6865: PPUSH
6866: LD_VAR 0 4
6870: PUSH
6871: LD_INT 1
6873: PLUS
6874: PPUSH
6875: LD_INT 13
6877: PUSH
6878: LD_INT 1
6880: PUSH
6881: LD_INT 2
6883: PUSH
6884: LD_INT 28
6886: PUSH
6887: LD_INT 29
6889: PUSH
6890: LD_INT 25
6892: PUSH
6893: LD_INT 26
6895: PUSH
6896: EMPTY
6897: LIST
6898: LIST
6899: LIST
6900: LIST
6901: PUSH
6902: LD_INT 1
6904: PPUSH
6905: LD_INT 4
6907: PPUSH
6908: CALL_OW 12
6912: ARRAY
6913: PUSH
6914: EMPTY
6915: LIST
6916: LIST
6917: LIST
6918: LIST
6919: PPUSH
6920: CALL_OW 2
6924: ST_TO_ADDR
6925: GO 6853
6927: POP
6928: POP
// MC_InsertProduceList ( base , tmp ) ;
6929: LD_VAR 0 3
6933: PPUSH
6934: LD_VAR 0 4
6938: PPUSH
6939: CALL 84443 0 2
// wait ( 3 3$20 ) ;
6943: LD_INT 7000
6945: PPUSH
6946: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6950: LD_ADDR_VAR 0 6
6954: PUSH
6955: LD_INT 124
6957: PUSH
6958: LD_INT 85
6960: PUSH
6961: EMPTY
6962: LIST
6963: LIST
6964: PUSH
6965: LD_INT 90
6967: PUSH
6968: LD_INT 61
6970: PUSH
6971: EMPTY
6972: LIST
6973: LIST
6974: PUSH
6975: LD_INT 69
6977: PUSH
6978: LD_INT 48
6980: PUSH
6981: EMPTY
6982: LIST
6983: LIST
6984: PUSH
6985: LD_INT 68
6987: PUSH
6988: LD_INT 48
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PUSH
6995: EMPTY
6996: LIST
6997: LIST
6998: LIST
6999: LIST
7000: ST_TO_ADDR
// attackers := FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , 2 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_or , [ f_weapon , ar_control_tower ] , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ] ] ) diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7001: LD_ADDR_VAR 0 7
7005: PUSH
7006: LD_INT 22
7008: PUSH
7009: LD_INT 2
7011: PUSH
7012: EMPTY
7013: LIST
7014: LIST
7015: PUSH
7016: LD_INT 23
7018: PUSH
7019: LD_INT 2
7021: PUSH
7022: EMPTY
7023: LIST
7024: LIST
7025: PUSH
7026: LD_INT 21
7028: PUSH
7029: LD_INT 2
7031: PUSH
7032: EMPTY
7033: LIST
7034: LIST
7035: PUSH
7036: LD_INT 3
7038: PUSH
7039: LD_INT 2
7041: PUSH
7042: LD_INT 34
7044: PUSH
7045: LD_INT 31
7047: PUSH
7048: EMPTY
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 34
7054: PUSH
7055: LD_INT 88
7057: PUSH
7058: EMPTY
7059: LIST
7060: LIST
7061: PUSH
7062: LD_INT 34
7064: PUSH
7065: LD_INT 32
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: PUSH
7072: EMPTY
7073: LIST
7074: LIST
7075: LIST
7076: LIST
7077: PUSH
7078: EMPTY
7079: LIST
7080: LIST
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PPUSH
7088: CALL_OW 69
7092: PUSH
7093: LD_EXP 82
7097: PUSH
7098: LD_VAR 0 3
7102: ARRAY
7103: PPUSH
7104: LD_INT 2
7106: PUSH
7107: LD_INT 34
7109: PUSH
7110: LD_INT 32
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 34
7119: PUSH
7120: LD_INT 88
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: PUSH
7127: EMPTY
7128: LIST
7129: LIST
7130: LIST
7131: PPUSH
7132: CALL_OW 72
7136: DIFF
7137: ST_TO_ADDR
// if rand ( 0 , 1 ) then
7138: LD_INT 0
7140: PPUSH
7141: LD_INT 1
7143: PPUSH
7144: CALL_OW 12
7148: IFFALSE 7298
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
7150: LD_ADDR_VAR 0 1
7154: PUSH
7155: DOUBLE
7156: LD_INT 1
7158: DEC
7159: ST_TO_ADDR
7160: LD_INT 3
7162: PUSH
7163: LD_INT 4
7165: PUSH
7166: LD_INT 5
7168: PUSH
7169: LD_INT 6
7171: PUSH
7172: EMPTY
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: PUSH
7178: LD_OWVAR 67
7182: ARRAY
7183: PUSH
7184: FOR_TO
7185: IFFALSE 7294
// begin uc_side := 2 ;
7187: LD_ADDR_OWVAR 20
7191: PUSH
7192: LD_INT 2
7194: ST_TO_ADDR
// uc_nation := 2 ;
7195: LD_ADDR_OWVAR 21
7199: PUSH
7200: LD_INT 2
7202: ST_TO_ADDR
// InitHc ;
7203: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7207: LD_INT 0
7209: PPUSH
7210: LD_INT 15
7212: PUSH
7213: LD_INT 17
7215: PUSH
7216: EMPTY
7217: LIST
7218: LIST
7219: PUSH
7220: LD_INT 1
7222: PPUSH
7223: LD_INT 2
7225: PPUSH
7226: CALL_OW 12
7230: ARRAY
7231: PPUSH
7232: LD_INT 8
7234: PPUSH
7235: CALL_OW 380
// un := CreateHuman ;
7239: LD_ADDR_VAR 0 2
7243: PUSH
7244: CALL_OW 44
7248: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7249: LD_VAR 0 2
7253: PPUSH
7254: LD_INT 4
7256: PPUSH
7257: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7261: LD_VAR 0 2
7265: PPUSH
7266: LD_INT 23
7268: PPUSH
7269: LD_INT 0
7271: PPUSH
7272: CALL_OW 49
// attackers := attackers union un ;
7276: LD_ADDR_VAR 0 7
7280: PUSH
7281: LD_VAR 0 7
7285: PUSH
7286: LD_VAR 0 2
7290: UNION
7291: ST_TO_ADDR
// end ;
7292: GO 7184
7294: POP
7295: POP
// end else
7296: GO 7456
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
7298: LD_ADDR_VAR 0 1
7302: PUSH
7303: DOUBLE
7304: LD_INT 1
7306: DEC
7307: ST_TO_ADDR
7308: LD_INT 2
7310: PUSH
7311: LD_INT 3
7313: PUSH
7314: LD_INT 4
7316: PUSH
7317: LD_INT 5
7319: PUSH
7320: EMPTY
7321: LIST
7322: LIST
7323: LIST
7324: LIST
7325: PUSH
7326: LD_OWVAR 67
7330: ARRAY
7331: PUSH
7332: FOR_TO
7333: IFFALSE 7454
// begin uc_side := 2 ;
7335: LD_ADDR_OWVAR 20
7339: PUSH
7340: LD_INT 2
7342: ST_TO_ADDR
// uc_nation := 2 ;
7343: LD_ADDR_OWVAR 21
7347: PUSH
7348: LD_INT 2
7350: ST_TO_ADDR
// InitHc ;
7351: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
7355: LD_INT 14
7357: PPUSH
7358: LD_INT 3
7360: PPUSH
7361: LD_INT 5
7363: PPUSH
7364: LD_INT 29
7366: PUSH
7367: LD_INT 29
7369: PUSH
7370: LD_INT 26
7372: PUSH
7373: EMPTY
7374: LIST
7375: LIST
7376: LIST
7377: PUSH
7378: LD_VAR 0 1
7382: PUSH
7383: LD_INT 3
7385: MOD
7386: PUSH
7387: LD_INT 1
7389: PLUS
7390: ARRAY
7391: PPUSH
7392: LD_INT 100
7394: PPUSH
7395: CALL 22200 0 5
// un := CreateVehicle ;
7399: LD_ADDR_VAR 0 2
7403: PUSH
7404: CALL_OW 45
7408: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7409: LD_VAR 0 2
7413: PPUSH
7414: LD_INT 4
7416: PPUSH
7417: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
7421: LD_VAR 0 2
7425: PPUSH
7426: LD_INT 23
7428: PPUSH
7429: LD_INT 0
7431: PPUSH
7432: CALL_OW 49
// attackers := attackers union un ;
7436: LD_ADDR_VAR 0 7
7440: PUSH
7441: LD_VAR 0 7
7445: PUSH
7446: LD_VAR 0 2
7450: UNION
7451: ST_TO_ADDR
// end ;
7452: GO 7332
7454: POP
7455: POP
// end ; if not attackers then
7456: LD_VAR 0 7
7460: NOT
7461: IFFALSE 7465
// exit ;
7463: GO 7582
// ar_attackers := attackers ;
7465: LD_ADDR_EXP 12
7469: PUSH
7470: LD_VAR 0 7
7474: ST_TO_ADDR
// p := 0 ;
7475: LD_ADDR_VAR 0 8
7479: PUSH
7480: LD_INT 0
7482: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7483: LD_INT 35
7485: PPUSH
7486: CALL_OW 67
// p := Inc ( p ) ;
7490: LD_ADDR_VAR 0 8
7494: PUSH
7495: LD_VAR 0 8
7499: PPUSH
7500: CALL 56432 0 1
7504: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7505: LD_VAR 0 7
7509: PPUSH
7510: LD_INT 60
7512: PUSH
7513: EMPTY
7514: LIST
7515: PPUSH
7516: CALL_OW 72
7520: NOT
7521: PUSH
7522: LD_VAR 0 8
7526: PUSH
7527: LD_INT 30
7529: GREATER
7530: OR
7531: IFFALSE 7483
// repeat wait ( 0 0$1 ) ;
7533: LD_INT 35
7535: PPUSH
7536: CALL_OW 67
// attackers := UnitFilter ( attackers , [ f_ok ] ) ;
7540: LD_ADDR_VAR 0 7
7544: PUSH
7545: LD_VAR 0 7
7549: PPUSH
7550: LD_INT 50
7552: PUSH
7553: EMPTY
7554: LIST
7555: PPUSH
7556: CALL_OW 72
7560: ST_TO_ADDR
// AgressiveMove ( attackers , _target ) ;
7561: LD_VAR 0 7
7565: PPUSH
7566: LD_VAR 0 6
7570: PPUSH
7571: CALL 57681 0 2
// until not attackers ;
7575: LD_VAR 0 7
7579: NOT
7580: IFFALSE 7533
// end ;
7582: PPOPN 8
7584: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
7585: LD_INT 1
7587: PPUSH
7588: CALL_OW 302
7592: PUSH
7593: LD_EXP 10
7597: AND
7598: PUSH
7599: LD_EXP 52
7603: PPUSH
7604: LD_INT 22
7606: PPUSH
7607: CALL_OW 308
7611: AND
7612: IFFALSE 8100
7614: GO 7616
7616: DISABLE
7617: LD_INT 0
7619: PPUSH
7620: PPUSH
7621: PPUSH
7622: PPUSH
7623: PPUSH
7624: PPUSH
7625: PPUSH
7626: PPUSH
// begin base := 1 ;
7627: LD_ADDR_VAR 0 2
7631: PUSH
7632: LD_INT 1
7634: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
7635: LD_ADDR_VAR 0 4
7639: PUSH
7640: LD_INT 0
7642: PUSH
7643: LD_INT 0
7645: PUSH
7646: LD_INT 0
7648: PUSH
7649: LD_INT 0
7651: PUSH
7652: LD_INT 0
7654: PUSH
7655: LD_INT 0
7657: PUSH
7658: LD_INT 0
7660: PUSH
7661: LD_INT 0
7663: PUSH
7664: LD_INT 1
7666: PUSH
7667: LD_INT 0
7669: PUSH
7670: EMPTY
7671: LIST
7672: LIST
7673: LIST
7674: LIST
7675: LIST
7676: LIST
7677: LIST
7678: LIST
7679: LIST
7680: LIST
7681: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
7682: LD_ADDR_VAR 0 3
7686: PUSH
7687: LD_INT 13
7689: PUSH
7690: LD_INT 1
7692: PUSH
7693: LD_INT 2
7695: PUSH
7696: LD_INT 28
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: LIST
7703: LIST
7704: PUSH
7705: LD_INT 13
7707: PUSH
7708: LD_INT 1
7710: PUSH
7711: LD_INT 2
7713: PUSH
7714: LD_INT 27
7716: PUSH
7717: EMPTY
7718: LIST
7719: LIST
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 13
7725: PUSH
7726: LD_INT 1
7728: PUSH
7729: LD_INT 2
7731: PUSH
7732: LD_INT 25
7734: PUSH
7735: EMPTY
7736: LIST
7737: LIST
7738: LIST
7739: LIST
7740: PUSH
7741: LD_INT 11
7743: PUSH
7744: LD_INT 2
7746: PUSH
7747: LD_INT 2
7749: PUSH
7750: LD_INT 24
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: PUSH
7759: LD_INT 11
7761: PUSH
7762: LD_INT 2
7764: PUSH
7765: LD_INT 2
7767: PUSH
7768: LD_INT 24
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: LIST
7775: LIST
7776: PUSH
7777: EMPTY
7778: LIST
7779: LIST
7780: LIST
7781: LIST
7782: LIST
7783: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
7784: LD_VAR 0 2
7788: PPUSH
7789: LD_VAR 0 3
7793: PPUSH
7794: CALL 84443 0 2
// wait ( 4 4$20 ) ;
7798: LD_INT 9100
7800: PPUSH
7801: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
7805: LD_ADDR_VAR 0 5
7809: PUSH
7810: LD_INT 119
7812: PUSH
7813: LD_INT 9
7815: PUSH
7816: EMPTY
7817: LIST
7818: LIST
7819: PUSH
7820: EMPTY
7821: LIST
7822: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7823: LD_ADDR_VAR 0 6
7827: PUSH
7828: LD_EXP 82
7832: PUSH
7833: LD_VAR 0 2
7837: ARRAY
7838: PUSH
7839: LD_EXP 82
7843: PUSH
7844: LD_VAR 0 2
7848: ARRAY
7849: PPUSH
7850: LD_INT 2
7852: PUSH
7853: LD_INT 34
7855: PUSH
7856: LD_INT 32
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PUSH
7863: LD_INT 34
7865: PUSH
7866: LD_INT 88
7868: PUSH
7869: EMPTY
7870: LIST
7871: LIST
7872: PUSH
7873: EMPTY
7874: LIST
7875: LIST
7876: LIST
7877: PPUSH
7878: CALL_OW 72
7882: DIFF
7883: ST_TO_ADDR
// uc_side := 2 ;
7884: LD_ADDR_OWVAR 20
7888: PUSH
7889: LD_INT 2
7891: ST_TO_ADDR
// uc_nation := 2 ;
7892: LD_ADDR_OWVAR 21
7896: PUSH
7897: LD_INT 2
7899: ST_TO_ADDR
// InitHc ;
7900: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7904: LD_ADDR_VAR 0 1
7908: PUSH
7909: DOUBLE
7910: LD_INT 1
7912: DEC
7913: ST_TO_ADDR
7914: LD_INT 4
7916: PUSH
7917: LD_INT 5
7919: PUSH
7920: LD_INT 6
7922: PUSH
7923: LD_INT 6
7925: PUSH
7926: EMPTY
7927: LIST
7928: LIST
7929: LIST
7930: LIST
7931: PUSH
7932: LD_OWVAR 67
7936: ARRAY
7937: PUSH
7938: FOR_TO
7939: IFFALSE 8016
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7941: LD_INT 0
7943: PPUSH
7944: LD_INT 15
7946: PUSH
7947: LD_INT 17
7949: PUSH
7950: EMPTY
7951: LIST
7952: LIST
7953: PUSH
7954: LD_INT 1
7956: PPUSH
7957: LD_INT 2
7959: PPUSH
7960: CALL_OW 12
7964: ARRAY
7965: PPUSH
7966: LD_INT 8
7968: PPUSH
7969: CALL_OW 380
// un := CreateHuman ;
7973: LD_ADDR_VAR 0 7
7977: PUSH
7978: CALL_OW 44
7982: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7983: LD_VAR 0 7
7987: PPUSH
7988: LD_INT 23
7990: PPUSH
7991: LD_INT 0
7993: PPUSH
7994: CALL_OW 49
// attackers := attackers union un ;
7998: LD_ADDR_VAR 0 6
8002: PUSH
8003: LD_VAR 0 6
8007: PUSH
8008: LD_VAR 0 7
8012: UNION
8013: ST_TO_ADDR
// end ;
8014: GO 7938
8016: POP
8017: POP
// p := 0 ;
8018: LD_ADDR_VAR 0 8
8022: PUSH
8023: LD_INT 0
8025: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8026: LD_INT 35
8028: PPUSH
8029: CALL_OW 67
// p := Inc ( p ) ;
8033: LD_ADDR_VAR 0 8
8037: PUSH
8038: LD_VAR 0 8
8042: PPUSH
8043: CALL 56432 0 1
8047: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
8048: LD_VAR 0 6
8052: PPUSH
8053: LD_INT 60
8055: PUSH
8056: EMPTY
8057: LIST
8058: PPUSH
8059: CALL_OW 72
8063: NOT
8064: PUSH
8065: LD_VAR 0 8
8069: PUSH
8070: LD_INT 30
8072: GREATER
8073: OR
8074: IFFALSE 8026
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
8076: LD_VAR 0 2
8080: PPUSH
8081: LD_VAR 0 6
8085: PPUSH
8086: LD_VAR 0 5
8090: PPUSH
8091: LD_VAR 0 4
8095: PPUSH
8096: CALL 84628 0 4
// end ;
8100: PPOPN 8
8102: END
// export function PlaceMines ( area , n ) ; var i , tmp , r ; begin
8103: LD_INT 0
8105: PPUSH
8106: PPUSH
8107: PPUSH
8108: PPUSH
// tmp := AreaToList ( area , 0 ) ;
8109: LD_ADDR_VAR 0 5
8113: PUSH
8114: LD_VAR 0 1
8118: PPUSH
8119: LD_INT 0
8121: PPUSH
8122: CALL_OW 517
8126: ST_TO_ADDR
// if not tmp then
8127: LD_VAR 0 5
8131: NOT
8132: IFFALSE 8136
// exit ;
8134: GO 8386
// arMinesList := arMinesList diff 0 ;
8136: LD_ADDR_EXP 60
8140: PUSH
8141: LD_EXP 60
8145: PUSH
8146: LD_INT 0
8148: DIFF
8149: ST_TO_ADDR
// for i := 1 to n do
8150: LD_ADDR_VAR 0 4
8154: PUSH
8155: DOUBLE
8156: LD_INT 1
8158: DEC
8159: ST_TO_ADDR
8160: LD_VAR 0 2
8164: PUSH
8165: FOR_TO
8166: IFFALSE 8384
// begin r := rand ( 1 , tmp [ 1 ] ) ;
8168: LD_ADDR_VAR 0 6
8172: PUSH
8173: LD_INT 1
8175: PPUSH
8176: LD_VAR 0 5
8180: PUSH
8181: LD_INT 1
8183: ARRAY
8184: PPUSH
8185: CALL_OW 12
8189: ST_TO_ADDR
// PlaceMine ( tmp [ 1 ] [ r ] , tmp [ 2 ] [ r ] , 2 , 0 ) ;
8190: LD_VAR 0 5
8194: PUSH
8195: LD_INT 1
8197: ARRAY
8198: PUSH
8199: LD_VAR 0 6
8203: ARRAY
8204: PPUSH
8205: LD_VAR 0 5
8209: PUSH
8210: LD_INT 2
8212: ARRAY
8213: PUSH
8214: LD_VAR 0 6
8218: ARRAY
8219: PPUSH
8220: LD_INT 2
8222: PPUSH
8223: LD_INT 0
8225: PPUSH
8226: CALL_OW 454
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 1 ] [ r ] ) ;
8230: LD_ADDR_EXP 60
8234: PUSH
8235: LD_EXP 60
8239: PPUSH
8240: LD_EXP 60
8244: PUSH
8245: LD_INT 1
8247: PLUS
8248: PPUSH
8249: LD_VAR 0 5
8253: PUSH
8254: LD_INT 1
8256: ARRAY
8257: PUSH
8258: LD_VAR 0 6
8262: ARRAY
8263: PPUSH
8264: CALL_OW 2
8268: ST_TO_ADDR
// arMinesList := Insert ( arMinesList , arMinesList + 1 , tmp [ 2 ] [ r ] ) ;
8269: LD_ADDR_EXP 60
8273: PUSH
8274: LD_EXP 60
8278: PPUSH
8279: LD_EXP 60
8283: PUSH
8284: LD_INT 1
8286: PLUS
8287: PPUSH
8288: LD_VAR 0 5
8292: PUSH
8293: LD_INT 2
8295: ARRAY
8296: PUSH
8297: LD_VAR 0 6
8301: ARRAY
8302: PPUSH
8303: CALL_OW 2
8307: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , Delete ( tmp [ 1 ] , r ) ) ;
8308: LD_ADDR_VAR 0 5
8312: PUSH
8313: LD_VAR 0 5
8317: PPUSH
8318: LD_INT 1
8320: PPUSH
8321: LD_VAR 0 5
8325: PUSH
8326: LD_INT 1
8328: ARRAY
8329: PPUSH
8330: LD_VAR 0 6
8334: PPUSH
8335: CALL_OW 3
8339: PPUSH
8340: CALL_OW 1
8344: ST_TO_ADDR
// tmp := Replace ( tmp , 2 , Delete ( tmp [ 2 ] , r ) ) ;
8345: LD_ADDR_VAR 0 5
8349: PUSH
8350: LD_VAR 0 5
8354: PPUSH
8355: LD_INT 2
8357: PPUSH
8358: LD_VAR 0 5
8362: PUSH
8363: LD_INT 2
8365: ARRAY
8366: PPUSH
8367: LD_VAR 0 6
8371: PPUSH
8372: CALL_OW 3
8376: PPUSH
8377: CALL_OW 1
8381: ST_TO_ADDR
// end ;
8382: GO 8165
8384: POP
8385: POP
// end ;
8386: LD_VAR 0 3
8390: RET
// export arMinesList ; every 0 0$01 + 0 0$3 trigger arMinesList do var i , p , tmp , side ;
8391: LD_EXP 60
8395: IFFALSE 8624
8397: GO 8399
8399: DISABLE
8400: LD_INT 0
8402: PPUSH
8403: PPUSH
8404: PPUSH
8405: PPUSH
// begin enable ;
8406: ENABLE
// p := 1 ;
8407: LD_ADDR_VAR 0 2
8411: PUSH
8412: LD_INT 1
8414: ST_TO_ADDR
// for i := 1 to Count ( arMinesList ) div 2 do
8415: LD_ADDR_VAR 0 1
8419: PUSH
8420: DOUBLE
8421: LD_INT 1
8423: DEC
8424: ST_TO_ADDR
8425: LD_EXP 60
8429: PPUSH
8430: CALL 19462 0 1
8434: PUSH
8435: LD_INT 2
8437: DIV
8438: PUSH
8439: FOR_TO
8440: IFFALSE 8622
// begin tmp := HexInfo ( arMinesList [ p ] , arMinesList [ p + 1 ] ) ;
8442: LD_ADDR_VAR 0 3
8446: PUSH
8447: LD_EXP 60
8451: PUSH
8452: LD_VAR 0 2
8456: ARRAY
8457: PPUSH
8458: LD_EXP 60
8462: PUSH
8463: LD_VAR 0 2
8467: PUSH
8468: LD_INT 1
8470: PLUS
8471: ARRAY
8472: PPUSH
8473: CALL_OW 428
8477: ST_TO_ADDR
// if tmp then
8478: LD_VAR 0 3
8482: IFFALSE 8606
// begin side := GetSide ( tmp ) ;
8484: LD_ADDR_VAR 0 4
8488: PUSH
8489: LD_VAR 0 3
8493: PPUSH
8494: CALL_OW 255
8498: ST_TO_ADDR
// if side <> 2 and side > 0 then
8499: LD_VAR 0 4
8503: PUSH
8504: LD_INT 2
8506: NONEQUAL
8507: PUSH
8508: LD_VAR 0 4
8512: PUSH
8513: LD_INT 0
8515: GREATER
8516: AND
8517: IFFALSE 8606
// begin LaunchMineAtPos ( arMinesList [ p ] , arMinesList [ p + 1 ] , 2 ) ;
8519: LD_EXP 60
8523: PUSH
8524: LD_VAR 0 2
8528: ARRAY
8529: PPUSH
8530: LD_EXP 60
8534: PUSH
8535: LD_VAR 0 2
8539: PUSH
8540: LD_INT 1
8542: PLUS
8543: ARRAY
8544: PPUSH
8545: LD_INT 2
8547: PPUSH
8548: CALL_OW 456
// arMinesList := Delete ( arMinesList , p ) ;
8552: LD_ADDR_EXP 60
8556: PUSH
8557: LD_EXP 60
8561: PPUSH
8562: LD_VAR 0 2
8566: PPUSH
8567: CALL_OW 3
8571: ST_TO_ADDR
// arMinesList := Delete ( arMinesList , p ) ;
8572: LD_ADDR_EXP 60
8576: PUSH
8577: LD_EXP 60
8581: PPUSH
8582: LD_VAR 0 2
8586: PPUSH
8587: CALL_OW 3
8591: ST_TO_ADDR
// p := p - 2 ;
8592: LD_ADDR_VAR 0 2
8596: PUSH
8597: LD_VAR 0 2
8601: PUSH
8602: LD_INT 2
8604: MINUS
8605: ST_TO_ADDR
// end ; end ; p := p + 2 ;
8606: LD_ADDR_VAR 0 2
8610: PUSH
8611: LD_VAR 0 2
8615: PUSH
8616: LD_INT 2
8618: PLUS
8619: ST_TO_ADDR
// end ;
8620: GO 8439
8622: POP
8623: POP
// end ; end_of_file
8624: PPOPN 4
8626: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
8627: LD_INT 0
8629: PPUSH
8630: PPUSH
8631: PPUSH
8632: PPUSH
8633: PPUSH
8634: PPUSH
// uc_side := 1 ;
8635: LD_ADDR_OWVAR 20
8639: PUSH
8640: LD_INT 1
8642: ST_TO_ADDR
// uc_nation := 1 ;
8643: LD_ADDR_OWVAR 21
8647: PUSH
8648: LD_INT 1
8650: ST_TO_ADDR
// InitHc ;
8651: CALL_OW 19
// InitVc ;
8655: CALL_OW 20
// tmp := [ ] ;
8659: LD_ADDR_VAR 0 3
8663: PUSH
8664: EMPTY
8665: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
8666: LD_ADDR_VAR 0 2
8670: PUSH
8671: DOUBLE
8672: LD_INT 1
8674: DEC
8675: ST_TO_ADDR
8676: LD_INT 6
8678: PUSH
8679: LD_INT 8
8681: PUSH
8682: LD_INT 10
8684: PUSH
8685: LD_INT 10
8687: PUSH
8688: EMPTY
8689: LIST
8690: LIST
8691: LIST
8692: LIST
8693: PUSH
8694: LD_OWVAR 67
8698: ARRAY
8699: PUSH
8700: FOR_TO
8701: IFFALSE 8991
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
8703: LD_ADDR_VAR 0 5
8707: PUSH
8708: LD_INT 2
8710: PUSH
8711: LD_INT 4
8713: PUSH
8714: LD_INT 5
8716: PUSH
8717: EMPTY
8718: LIST
8719: LIST
8720: LIST
8721: PUSH
8722: LD_INT 1
8724: PPUSH
8725: LD_INT 3
8727: PPUSH
8728: CALL_OW 12
8732: ARRAY
8733: ST_TO_ADDR
// case chassis of us_medium_wheeled :
8734: LD_VAR 0 5
8738: PUSH
8739: LD_INT 2
8741: DOUBLE
8742: EQUAL
8743: IFTRUE 8747
8745: GO 8781
8747: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
8748: LD_ADDR_VAR 0 6
8752: PUSH
8753: LD_INT 9
8755: PUSH
8756: LD_INT 5
8758: PUSH
8759: LD_INT 7
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: LIST
8766: PUSH
8767: LD_INT 1
8769: PPUSH
8770: LD_INT 3
8772: PPUSH
8773: CALL_OW 12
8777: ARRAY
8778: ST_TO_ADDR
8779: GO 8870
8781: LD_INT 4
8783: DOUBLE
8784: EQUAL
8785: IFTRUE 8789
8787: GO 8827
8789: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
8790: LD_ADDR_VAR 0 6
8794: PUSH
8795: LD_INT 9
8797: PUSH
8798: LD_INT 6
8800: PUSH
8801: LD_INT 6
8803: PUSH
8804: LD_INT 7
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: LIST
8811: LIST
8812: PUSH
8813: LD_INT 1
8815: PPUSH
8816: LD_INT 4
8818: PPUSH
8819: CALL_OW 12
8823: ARRAY
8824: ST_TO_ADDR
8825: GO 8870
8827: LD_INT 5
8829: DOUBLE
8830: EQUAL
8831: IFTRUE 8835
8833: GO 8869
8835: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
8836: LD_ADDR_VAR 0 6
8840: PUSH
8841: LD_INT 9
8843: PUSH
8844: LD_INT 6
8846: PUSH
8847: LD_INT 7
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: LIST
8854: PUSH
8855: LD_INT 1
8857: PPUSH
8858: LD_INT 3
8860: PPUSH
8861: CALL_OW 12
8865: ARRAY
8866: ST_TO_ADDR
8867: GO 8870
8869: POP
// uc_side := 1 ;
8870: LD_ADDR_OWVAR 20
8874: PUSH
8875: LD_INT 1
8877: ST_TO_ADDR
// uc_nation := 1 ;
8878: LD_ADDR_OWVAR 21
8882: PUSH
8883: LD_INT 1
8885: ST_TO_ADDR
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
8886: LD_VAR 0 5
8890: PPUSH
8891: LD_INT 1
8893: PUSH
8894: LD_INT 3
8896: PUSH
8897: EMPTY
8898: LIST
8899: LIST
8900: PUSH
8901: LD_INT 1
8903: PPUSH
8904: LD_INT 2
8906: PPUSH
8907: CALL_OW 12
8911: ARRAY
8912: PPUSH
8913: LD_INT 3
8915: PPUSH
8916: LD_VAR 0 6
8920: PPUSH
8921: LD_INT 70
8923: PPUSH
8924: LD_INT 90
8926: PPUSH
8927: CALL_OW 12
8931: PPUSH
8932: CALL 22200 0 5
// veh := CreateVehicle ;
8936: LD_ADDR_VAR 0 4
8940: PUSH
8941: CALL_OW 45
8945: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
8946: LD_VAR 0 4
8950: PPUSH
8951: LD_INT 2
8953: PPUSH
8954: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
8958: LD_VAR 0 4
8962: PPUSH
8963: LD_INT 17
8965: PPUSH
8966: LD_INT 0
8968: PPUSH
8969: CALL_OW 49
// tmp := tmp ^ veh ;
8973: LD_ADDR_VAR 0 3
8977: PUSH
8978: LD_VAR 0 3
8982: PUSH
8983: LD_VAR 0 4
8987: ADD
8988: ST_TO_ADDR
// end ;
8989: GO 8700
8991: POP
8992: POP
// if not tmp then
8993: LD_VAR 0 3
8997: NOT
8998: IFFALSE 9002
// exit ;
9000: GO 9111
// if not first_powell_attack then
9002: LD_EXP 13
9006: NOT
9007: IFFALSE 9017
// first_powell_attack := true ;
9009: LD_ADDR_EXP 13
9013: PUSH
9014: LD_INT 1
9016: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
9017: LD_INT 70
9019: PPUSH
9020: CALL_OW 67
// for i in tmp do
9024: LD_ADDR_VAR 0 2
9028: PUSH
9029: LD_VAR 0 3
9033: PUSH
9034: FOR_IN
9035: IFFALSE 9102
// if IsOk ( i ) then
9037: LD_VAR 0 2
9041: PPUSH
9042: CALL_OW 302
9046: IFFALSE 9084
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
9048: LD_VAR 0 2
9052: PPUSH
9053: LD_INT 81
9055: PUSH
9056: LD_INT 1
9058: PUSH
9059: EMPTY
9060: LIST
9061: LIST
9062: PPUSH
9063: CALL_OW 69
9067: PPUSH
9068: LD_VAR 0 2
9072: PPUSH
9073: CALL_OW 74
9077: PPUSH
9078: CALL_OW 115
9082: GO 9100
// tmp := tmp diff i ;
9084: LD_ADDR_VAR 0 3
9088: PUSH
9089: LD_VAR 0 3
9093: PUSH
9094: LD_VAR 0 2
9098: DIFF
9099: ST_TO_ADDR
9100: GO 9034
9102: POP
9103: POP
// until not tmp ;
9104: LD_VAR 0 3
9108: NOT
9109: IFFALSE 9017
// end ;
9111: LD_VAR 0 1
9115: RET
// export function TryToStoleArtifact ( artifact ) ; var veh ; begin
9116: LD_INT 0
9118: PPUSH
9119: PPUSH
// uc_side := 1 ;
9120: LD_ADDR_OWVAR 20
9124: PUSH
9125: LD_INT 1
9127: ST_TO_ADDR
// uc_nation := 1 ;
9128: LD_ADDR_OWVAR 21
9132: PUSH
9133: LD_INT 1
9135: ST_TO_ADDR
// InitHc ;
9136: CALL_OW 19
// InitVc ;
9140: CALL_OW 20
// PrepareVehicle ( us_morphling , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
9144: LD_INT 5
9146: PPUSH
9147: LD_INT 3
9149: PPUSH
9150: LD_INT 3
9152: PPUSH
9153: LD_INT 12
9155: PPUSH
9156: LD_INT 100
9158: PPUSH
9159: CALL 22200 0 5
// veh := CreateVehicle ;
9163: LD_ADDR_VAR 0 3
9167: PUSH
9168: CALL_OW 45
9172: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
9173: LD_VAR 0 3
9177: PPUSH
9178: LD_INT 2
9180: PPUSH
9181: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
9185: LD_VAR 0 3
9189: PPUSH
9190: LD_INT 17
9192: PPUSH
9193: LD_INT 0
9195: PPUSH
9196: CALL_OW 49
// ComGet ( veh , artifact [ 1 ] , artifact [ 2 ] ) ;
9200: LD_VAR 0 3
9204: PPUSH
9205: LD_VAR 0 1
9209: PUSH
9210: LD_INT 1
9212: ARRAY
9213: PPUSH
9214: LD_VAR 0 1
9218: PUSH
9219: LD_INT 2
9221: ARRAY
9222: PPUSH
9223: CALL_OW 160
// AddComMoveXY ( veh , 59 , 2 ) ;
9227: LD_VAR 0 3
9231: PPUSH
9232: LD_INT 59
9234: PPUSH
9235: LD_INT 2
9237: PPUSH
9238: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
9242: LD_INT 35
9244: PPUSH
9245: CALL_OW 67
// if not IsOk ( veh ) then
9249: LD_VAR 0 3
9253: PPUSH
9254: CALL_OW 302
9258: NOT
9259: IFFALSE 9263
// exit ;
9261: GO 9317
// until IsAt ( veh , 59 , 2 ) ;
9263: LD_VAR 0 3
9267: PPUSH
9268: LD_INT 59
9270: PPUSH
9271: LD_INT 2
9273: PPUSH
9274: CALL_OW 307
9278: IFFALSE 9242
// RemoveUnit ( veh ) ;
9280: LD_VAR 0 3
9284: PPUSH
9285: CALL_OW 64
// if GetCargo ( veh , mat_artifact ) then
9289: LD_VAR 0 3
9293: PPUSH
9294: LD_INT 4
9296: PPUSH
9297: CALL_OW 289
9301: IFFALSE 9317
// begin wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// YouLost ( Artifact ) ;
9310: LD_STRING Artifact
9312: PPUSH
9313: CALL_OW 104
// end ; end ; end_of_file
9317: LD_VAR 0 2
9321: RET
// export function Action ; var tmp , i , un ; begin
9322: LD_INT 0
9324: PPUSH
9325: PPUSH
9326: PPUSH
9327: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
9328: LD_INT 68
9330: PPUSH
9331: LD_INT 39
9333: PPUSH
9334: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
9338: LD_ADDR_VAR 0 2
9342: PUSH
9343: LD_INT 22
9345: PUSH
9346: LD_INT 7
9348: PUSH
9349: EMPTY
9350: LIST
9351: LIST
9352: PPUSH
9353: CALL_OW 69
9357: ST_TO_ADDR
// InGameOn ;
9358: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
9362: LD_VAR 0 2
9366: PPUSH
9367: LD_INT 71
9369: PPUSH
9370: LD_INT 49
9372: PPUSH
9373: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
9377: LD_INT 35
9379: PPUSH
9380: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
9384: LD_INT 7
9386: PPUSH
9387: LD_INT 71
9389: PPUSH
9390: LD_INT 51
9392: PPUSH
9393: CALL_OW 293
9397: IFFALSE 9377
// DialogueOn ;
9399: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
9403: LD_EXP 17
9407: PPUSH
9408: LD_STRING D1-JMM-1
9410: PPUSH
9411: CALL_OW 88
// if Joan then
9415: LD_EXP 32
9419: IFFALSE 9433
// Say ( Joan , D1-Joan-1 ) ;
9421: LD_EXP 32
9425: PPUSH
9426: LD_STRING D1-Joan-1
9428: PPUSH
9429: CALL_OW 88
// if Lisa then
9433: LD_EXP 19
9437: IFFALSE 9451
// Say ( Lisa , D1-Lisa-1 ) ;
9439: LD_EXP 19
9443: PPUSH
9444: LD_STRING D1-Lisa-1
9446: PPUSH
9447: CALL_OW 88
// if Joan or Lisa then
9451: LD_EXP 32
9455: PUSH
9456: LD_EXP 19
9460: OR
9461: IFFALSE 9475
// Say ( JMM , D1-JMM-2 ) ;
9463: LD_EXP 17
9467: PPUSH
9468: LD_STRING D1-JMM-2
9470: PPUSH
9471: CALL_OW 88
// DialogueOff ;
9475: CALL_OW 7
// InGameOff ;
9479: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
9483: LD_INT 71
9485: PPUSH
9486: LD_INT 50
9488: PPUSH
9489: LD_INT 7
9491: PPUSH
9492: LD_INT 30
9494: NEG
9495: PPUSH
9496: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
9500: LD_INT 71
9502: PPUSH
9503: LD_INT 50
9505: PPUSH
9506: LD_INT 7
9508: PPUSH
9509: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
9513: LD_STRING M1
9515: PPUSH
9516: CALL_OW 337
// SaveForQuickRestart ;
9520: CALL_OW 22
// repeat wait ( 0 0$1 ) ;
9524: LD_INT 35
9526: PPUSH
9527: CALL_OW 67
// until freedom or tick > 1 1$00 ;
9531: LD_EXP 3
9535: PUSH
9536: LD_OWVAR 1
9540: PUSH
9541: LD_INT 2100
9543: GREATER
9544: OR
9545: IFFALSE 9524
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
9547: LD_INT 350
9549: PPUSH
9550: LD_INT 700
9552: PPUSH
9553: CALL_OW 12
9557: PPUSH
9558: CALL_OW 67
// PrepareGossudarov ;
9562: CALL 1943 0 0
// repeat wait ( 0 0$1 ) ;
9566: LD_INT 35
9568: PPUSH
9569: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
9573: LD_INT 22
9575: PUSH
9576: LD_INT 6
9578: PUSH
9579: EMPTY
9580: LIST
9581: LIST
9582: PUSH
9583: LD_INT 3
9585: PUSH
9586: LD_INT 24
9588: PUSH
9589: LD_INT 1000
9591: PUSH
9592: EMPTY
9593: LIST
9594: LIST
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: PPUSH
9604: CALL_OW 69
9608: PUSH
9609: LD_INT 7
9611: PPUSH
9612: LD_EXP 35
9616: PPUSH
9617: CALL_OW 292
9621: OR
9622: IFFALSE 9566
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
9624: LD_ADDR_VAR 0 2
9628: PUSH
9629: LD_INT 22
9631: PUSH
9632: LD_INT 6
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: PPUSH
9639: CALL_OW 69
9643: ST_TO_ADDR
// for i in tmp do
9644: LD_ADDR_VAR 0 3
9648: PUSH
9649: LD_VAR 0 2
9653: PUSH
9654: FOR_IN
9655: IFFALSE 9671
// SetSide ( i , 7 ) ;
9657: LD_VAR 0 3
9661: PPUSH
9662: LD_INT 7
9664: PPUSH
9665: CALL_OW 235
9669: GO 9654
9671: POP
9672: POP
// DialogueOn ;
9673: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
9677: LD_EXP 17
9681: PUSH
9682: LD_EXP 18
9686: PUSH
9687: EMPTY
9688: LIST
9689: LIST
9690: PPUSH
9691: LD_EXP 35
9695: PPUSH
9696: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
9700: LD_EXP 35
9704: PPUSH
9705: CALL_OW 87
// if not Roth then
9709: LD_EXP 18
9713: NOT
9714: IFFALSE 9806
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9716: LD_VAR 0 2
9720: PPUSH
9721: LD_INT 3
9723: PUSH
9724: LD_INT 24
9726: PUSH
9727: LD_INT 1000
9729: PUSH
9730: EMPTY
9731: LIST
9732: LIST
9733: PUSH
9734: EMPTY
9735: LIST
9736: LIST
9737: PPUSH
9738: CALL_OW 72
9742: IFFALSE 9756
// Say ( JMM , D2-JMM-1 ) ;
9744: LD_EXP 17
9748: PPUSH
9749: LD_STRING D2-JMM-1
9751: PPUSH
9752: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
9756: LD_EXP 17
9760: PPUSH
9761: LD_STRING D2-JMM-1b
9763: PPUSH
9764: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
9768: LD_EXP 35
9772: PPUSH
9773: LD_STRING D2-Gos-1
9775: PPUSH
9776: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
9780: LD_EXP 17
9784: PPUSH
9785: LD_STRING D2-JMM-2
9787: PPUSH
9788: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
9792: LD_EXP 35
9796: PPUSH
9797: LD_STRING D2-Gos-2
9799: PPUSH
9800: CALL_OW 88
// end else
9804: GO 9958
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9806: LD_VAR 0 2
9810: PPUSH
9811: LD_INT 3
9813: PUSH
9814: LD_INT 24
9816: PUSH
9817: LD_INT 1000
9819: PUSH
9820: EMPTY
9821: LIST
9822: LIST
9823: PUSH
9824: EMPTY
9825: LIST
9826: LIST
9827: PPUSH
9828: CALL_OW 72
9832: IFFALSE 9858
// begin Say ( Roth , D2-Roth-2 ) ;
9834: LD_EXP 18
9838: PPUSH
9839: LD_STRING D2-Roth-2
9841: PPUSH
9842: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
9846: LD_EXP 17
9850: PPUSH
9851: LD_STRING D2-JMM-1a
9853: PPUSH
9854: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
9858: LD_EXP 18
9862: PPUSH
9863: LD_STRING D2-Roth-2a
9865: PPUSH
9866: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
9870: LD_EXP 18
9874: PPUSH
9875: LD_STRING D2-Roth-2b
9877: PPUSH
9878: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
9882: LD_EXP 17
9886: PPUSH
9887: LD_STRING D2-JMM-3
9889: PPUSH
9890: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
9894: LD_VAR 0 2
9898: PPUSH
9899: LD_INT 3
9901: PUSH
9902: LD_INT 24
9904: PUSH
9905: LD_INT 1000
9907: PUSH
9908: EMPTY
9909: LIST
9910: LIST
9911: PUSH
9912: EMPTY
9913: LIST
9914: LIST
9915: PPUSH
9916: CALL_OW 72
9920: IFFALSE 9958
// begin Say ( Gossudarov , D2-Gos-3 ) ;
9922: LD_EXP 35
9926: PPUSH
9927: LD_STRING D2-Gos-3
9929: PPUSH
9930: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
9934: LD_EXP 17
9938: PPUSH
9939: LD_STRING D2-JMM-4
9941: PPUSH
9942: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
9946: LD_EXP 35
9950: PPUSH
9951: LD_STRING D2-Gos-4
9953: PPUSH
9954: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
9958: LD_EXP 17
9962: PPUSH
9963: LD_STRING D2-JMM-5
9965: PPUSH
9966: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
9970: LD_EXP 35
9974: PPUSH
9975: LD_STRING D2-Gos-5
9977: PPUSH
9978: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
9982: LD_EXP 17
9986: PPUSH
9987: LD_STRING D2-JMM-6
9989: PPUSH
9990: CALL_OW 88
// DialogueOff ;
9994: CALL_OW 7
// wait ( 0 0$2 ) ;
9998: LD_INT 70
10000: PPUSH
10001: CALL_OW 67
// if Kirilenkova then
10005: LD_EXP 36
10009: IFFALSE 10023
// Say ( Kirilenkova , D3-Kir-1 ) ;
10011: LD_EXP 36
10015: PPUSH
10016: LD_STRING D3-Kir-1
10018: PPUSH
10019: CALL_OW 88
// gossudarov_arrive := true ;
10023: LD_ADDR_EXP 4
10027: PUSH
10028: LD_INT 1
10030: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10031: LD_INT 35
10033: PPUSH
10034: CALL_OW 67
// until ru_lab_builded ;
10038: LD_EXP 5
10042: IFFALSE 10031
// DialogueOn ;
10044: CALL_OW 6
// if Kirilenkova then
10048: LD_EXP 36
10052: IFFALSE 10068
// Say ( Kirilenkova , D3a-Kir-1 ) else
10054: LD_EXP 36
10058: PPUSH
10059: LD_STRING D3a-Kir-1
10061: PPUSH
10062: CALL_OW 88
10066: GO 10090
// begin un := SciRu ;
10068: LD_ADDR_VAR 0 4
10072: PUSH
10073: CALL 15630 0 0
10077: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
10078: LD_VAR 0 4
10082: PPUSH
10083: LD_STRING D3a-Sci1-1
10085: PPUSH
10086: CALL_OW 88
// end ; if Kirilenkova or un then
10090: LD_EXP 36
10094: PUSH
10095: LD_VAR 0 4
10099: OR
10100: IFFALSE 10114
// Say ( JMM , D3a-JMM-1 ) ;
10102: LD_EXP 17
10106: PPUSH
10107: LD_STRING D3a-JMM-1
10109: PPUSH
10110: CALL_OW 88
// DialogueOff ;
10114: CALL_OW 7
// end ;
10118: LD_VAR 0 1
10122: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
10123: LD_EXP 4
10127: PUSH
10128: LD_INT 22
10130: PUSH
10131: LD_INT 7
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: PUSH
10138: LD_INT 2
10140: PUSH
10141: LD_INT 25
10143: PUSH
10144: LD_INT 1
10146: PUSH
10147: EMPTY
10148: LIST
10149: LIST
10150: PUSH
10151: LD_INT 25
10153: PUSH
10154: LD_INT 2
10156: PUSH
10157: EMPTY
10158: LIST
10159: LIST
10160: PUSH
10161: LD_INT 25
10163: PUSH
10164: LD_INT 3
10166: PUSH
10167: EMPTY
10168: LIST
10169: LIST
10170: PUSH
10171: LD_INT 25
10173: PUSH
10174: LD_INT 4
10176: PUSH
10177: EMPTY
10178: LIST
10179: LIST
10180: PUSH
10181: LD_INT 25
10183: PUSH
10184: LD_INT 5
10186: PUSH
10187: EMPTY
10188: LIST
10189: LIST
10190: PUSH
10191: LD_INT 25
10193: PUSH
10194: LD_INT 8
10196: PUSH
10197: EMPTY
10198: LIST
10199: LIST
10200: PUSH
10201: LD_INT 25
10203: PUSH
10204: LD_INT 9
10206: PUSH
10207: EMPTY
10208: LIST
10209: LIST
10210: PUSH
10211: EMPTY
10212: LIST
10213: LIST
10214: LIST
10215: LIST
10216: LIST
10217: LIST
10218: LIST
10219: LIST
10220: PUSH
10221: EMPTY
10222: LIST
10223: LIST
10224: PPUSH
10225: CALL_OW 69
10229: PUSH
10230: LD_INT 7
10232: LESS
10233: AND
10234: IFFALSE 10246
10236: GO 10238
10238: DISABLE
// YouLost ( TooMany ) ;
10239: LD_STRING TooMany
10241: PPUSH
10242: CALL_OW 104
10246: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
10247: LD_EXP 35
10251: PPUSH
10252: CALL_OW 255
10256: PUSH
10257: LD_INT 7
10259: EQUAL
10260: IFFALSE 10477
10262: GO 10264
10264: DISABLE
10265: LD_INT 0
10267: PPUSH
10268: PPUSH
10269: PPUSH
// begin uc_side := 3 ;
10270: LD_ADDR_OWVAR 20
10274: PUSH
10275: LD_INT 3
10277: ST_TO_ADDR
// uc_nation := 3 ;
10278: LD_ADDR_OWVAR 21
10282: PUSH
10283: LD_INT 3
10285: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
10286: LD_INT 21
10288: PPUSH
10289: LD_INT 3
10291: PPUSH
10292: LD_INT 3
10294: PPUSH
10295: LD_INT 42
10297: PPUSH
10298: LD_INT 100
10300: PPUSH
10301: CALL 22200 0 5
// un := CreateVehicle ;
10305: LD_ADDR_VAR 0 3
10309: PUSH
10310: CALL_OW 45
10314: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
10315: LD_VAR 0 3
10319: PPUSH
10320: LD_INT 15
10322: PPUSH
10323: LD_INT 0
10325: PPUSH
10326: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
10330: LD_VAR 0 3
10334: PPUSH
10335: LD_INT 67
10337: PPUSH
10338: LD_INT 45
10340: PPUSH
10341: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
10345: LD_VAR 0 3
10349: PPUSH
10350: LD_INT 70
10352: PPUSH
10353: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
10357: LD_VAR 0 3
10361: PPUSH
10362: LD_INT 69
10364: PPUSH
10365: LD_INT 18
10367: PPUSH
10368: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
10372: LD_VAR 0 3
10376: PPUSH
10377: LD_INT 60
10379: PPUSH
10380: LD_INT 3
10382: PPUSH
10383: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
10387: LD_INT 35
10389: PPUSH
10390: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
10394: LD_VAR 0 3
10398: PPUSH
10399: CALL_OW 302
10403: NOT
10404: PUSH
10405: LD_VAR 0 3
10409: PPUSH
10410: LD_INT 17
10412: PPUSH
10413: CALL_OW 308
10417: OR
10418: PUSH
10419: LD_VAR 0 3
10423: PPUSH
10424: LD_INT 60
10426: PPUSH
10427: LD_INT 3
10429: PPUSH
10430: CALL_OW 307
10434: OR
10435: IFFALSE 10387
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
10437: LD_VAR 0 3
10441: PPUSH
10442: LD_INT 17
10444: PPUSH
10445: CALL_OW 308
10449: PUSH
10450: LD_VAR 0 3
10454: PPUSH
10455: LD_INT 60
10457: PPUSH
10458: LD_INT 3
10460: PPUSH
10461: CALL_OW 307
10465: OR
10466: IFFALSE 10477
// RemoveUnit ( un ) ;
10468: LD_VAR 0 3
10472: PPUSH
10473: CALL_OW 64
// end ;
10477: PPOPN 3
10479: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
10480: LD_EXP 4
10484: IFFALSE 10726
10486: GO 10488
10488: DISABLE
10489: LD_INT 0
10491: PPUSH
10492: PPUSH
10493: PPUSH
// begin repeat wait ( 0 0$2 ) ;
10494: LD_INT 70
10496: PPUSH
10497: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
10501: LD_ADDR_VAR 0 3
10505: PUSH
10506: LD_INT 22
10508: PUSH
10509: LD_INT 7
10511: PUSH
10512: EMPTY
10513: LIST
10514: LIST
10515: PUSH
10516: LD_INT 101
10518: PUSH
10519: LD_INT 3
10521: PUSH
10522: EMPTY
10523: LIST
10524: LIST
10525: PUSH
10526: EMPTY
10527: LIST
10528: LIST
10529: PPUSH
10530: CALL_OW 69
10534: ST_TO_ADDR
// until tmp ;
10535: LD_VAR 0 3
10539: IFFALSE 10494
// un := NearestUnitToUnit ( tmp , JMM ) ;
10541: LD_ADDR_VAR 0 2
10545: PUSH
10546: LD_VAR 0 3
10550: PPUSH
10551: LD_EXP 17
10555: PPUSH
10556: CALL_OW 74
10560: ST_TO_ADDR
// player_spotted := true ;
10561: LD_ADDR_EXP 7
10565: PUSH
10566: LD_INT 1
10568: ST_TO_ADDR
// tmp := SciRu ;
10569: LD_ADDR_VAR 0 3
10573: PUSH
10574: CALL 15630 0 0
10578: ST_TO_ADDR
// if not tmp then
10579: LD_VAR 0 3
10583: NOT
10584: IFFALSE 10596
// tmp := SolRu ;
10586: LD_ADDR_VAR 0 3
10590: PUSH
10591: CALL 15777 0 0
10595: ST_TO_ADDR
// DialogueOn ;
10596: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
10600: LD_VAR 0 2
10604: PPUSH
10605: CALL_OW 250
10609: PPUSH
10610: LD_VAR 0 2
10614: PPUSH
10615: CALL_OW 251
10619: PPUSH
10620: LD_INT 7
10622: PPUSH
10623: LD_INT 8
10625: NEG
10626: PPUSH
10627: CALL_OW 330
// CenterNowOnUnits ( un ) ;
10631: LD_VAR 0 2
10635: PPUSH
10636: CALL_OW 87
// if tmp then
10640: LD_VAR 0 3
10644: IFFALSE 10658
// Say ( tmp , D4-RSci1-1 ) ;
10646: LD_VAR 0 3
10650: PPUSH
10651: LD_STRING D4-RSci1-1
10653: PPUSH
10654: CALL_OW 88
// if Gossudarov then
10658: LD_EXP 35
10662: IFFALSE 10688
// begin Say ( Gossudarov , D4-Gos-1 ) ;
10664: LD_EXP 35
10668: PPUSH
10669: LD_STRING D4-Gos-1
10671: PPUSH
10672: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
10676: LD_EXP 17
10680: PPUSH
10681: LD_STRING D4-JMM-1
10683: PPUSH
10684: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
10688: LD_VAR 0 2
10692: PPUSH
10693: CALL_OW 250
10697: PPUSH
10698: LD_VAR 0 2
10702: PPUSH
10703: CALL_OW 251
10707: PPUSH
10708: LD_INT 7
10710: PPUSH
10711: CALL_OW 331
// DialogueOff ;
10715: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
10719: LD_STRING M5
10721: PPUSH
10722: CALL_OW 337
// end ;
10726: PPOPN 3
10728: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
10729: LD_EXP 7
10733: IFFALSE 11326
10735: GO 10737
10737: DISABLE
10738: LD_INT 0
10740: PPUSH
10741: PPUSH
10742: PPUSH
// begin PrepareBelkov ;
10743: CALL 2256 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
10747: LD_EXP 50
10751: PPUSH
10752: LD_INT 118
10754: PPUSH
10755: LD_INT 106
10757: PPUSH
10758: CALL_OW 111
// AddComHold ( Belkov ) ;
10762: LD_EXP 50
10766: PPUSH
10767: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
10771: LD_INT 35
10773: PPUSH
10774: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
10778: LD_EXP 50
10782: PPUSH
10783: LD_INT 118
10785: PPUSH
10786: LD_INT 106
10788: PPUSH
10789: CALL_OW 307
10793: IFFALSE 10771
// ChangeSideFog ( 4 , 7 ) ;
10795: LD_INT 4
10797: PPUSH
10798: LD_INT 7
10800: PPUSH
10801: CALL_OW 343
// if IsOk ( Belkov ) then
10805: LD_EXP 50
10809: PPUSH
10810: CALL_OW 302
10814: IFFALSE 10898
// begin InGameOn ;
10816: CALL_OW 8
// DialogueOn ;
10820: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
10824: LD_EXP 50
10828: PPUSH
10829: LD_STRING D5-Bel-1
10831: PPUSH
10832: CALL_OW 94
// if Gossudarov then
10836: LD_EXP 35
10840: IFFALSE 10890
// begin Say ( Gossudarov , D5-Gos-1 ) ;
10842: LD_EXP 35
10846: PPUSH
10847: LD_STRING D5-Gos-1
10849: PPUSH
10850: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
10854: LD_EXP 17
10858: PPUSH
10859: LD_STRING D5-JMM-1
10861: PPUSH
10862: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
10866: LD_EXP 35
10870: PPUSH
10871: LD_STRING D5-Gos-2
10873: PPUSH
10874: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
10878: LD_EXP 17
10882: PPUSH
10883: LD_STRING D5-JMM-2
10885: PPUSH
10886: CALL_OW 88
// end ; DialogueOff ;
10890: CALL_OW 7
// InGameOff ;
10894: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
10898: LD_STRING QSaveBelkov
10900: PPUSH
10901: CALL_OW 97
10905: PUSH
10906: LD_INT 1
10908: DOUBLE
10909: EQUAL
10910: IFTRUE 10914
10912: GO 10964
10914: POP
// begin DialogueOn ;
10915: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
10919: LD_EXP 17
10923: PPUSH
10924: LD_STRING D5a-JMM-1
10926: PPUSH
10927: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
10931: LD_EXP 50
10935: PPUSH
10936: LD_STRING D5a-Bel-1
10938: PPUSH
10939: CALL_OW 94
// DialogueOff ;
10943: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
10947: LD_EXP 50
10951: PPUSH
10952: LD_INT 83
10954: PPUSH
10955: LD_INT 49
10957: PPUSH
10958: CALL_OW 111
// end ; 2 :
10962: GO 10997
10964: LD_INT 2
10966: DOUBLE
10967: EQUAL
10968: IFTRUE 10972
10970: GO 10996
10972: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
10973: LD_EXP 17
10977: PPUSH
10978: LD_STRING D5a-JMM-2
10980: PPUSH
10981: CALL_OW 88
// ComHold ( Belkov ) ;
10985: LD_EXP 50
10989: PPUSH
10990: CALL_OW 140
// end ; end ;
10994: GO 10997
10996: POP
// time := 0 0$00 ;
10997: LD_ADDR_VAR 0 1
11001: PUSH
11002: LD_INT 0
11004: ST_TO_ADDR
// vehSpawned := false ;
11005: LD_ADDR_VAR 0 3
11009: PUSH
11010: LD_INT 0
11012: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11013: LD_INT 35
11015: PPUSH
11016: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
11020: LD_VAR 0 1
11024: PUSH
11025: LD_INT 350
11027: PUSH
11028: LD_INT 175
11030: PUSH
11031: LD_INT 105
11033: PUSH
11034: LD_INT 70
11036: PUSH
11037: EMPTY
11038: LIST
11039: LIST
11040: LIST
11041: LIST
11042: PUSH
11043: LD_OWVAR 67
11047: ARRAY
11048: GREATEREQUAL
11049: PUSH
11050: LD_VAR 0 3
11054: NOT
11055: AND
11056: IFFALSE 11146
// begin vehSpawned := true ;
11058: LD_ADDR_VAR 0 3
11062: PUSH
11063: LD_INT 1
11065: ST_TO_ADDR
// uc_side := 3 ;
11066: LD_ADDR_OWVAR 20
11070: PUSH
11071: LD_INT 3
11073: ST_TO_ADDR
// uc_nation := 3 ;
11074: LD_ADDR_OWVAR 21
11078: PUSH
11079: LD_INT 3
11081: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
11082: LD_INT 22
11084: PPUSH
11085: LD_INT 3
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 43
11093: PPUSH
11094: LD_INT 100
11096: PPUSH
11097: CALL 22200 0 5
// veh := CreateVehicle ;
11101: LD_ADDR_VAR 0 2
11105: PUSH
11106: CALL_OW 45
11110: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
11111: LD_VAR 0 2
11115: PPUSH
11116: LD_INT 130
11118: PPUSH
11119: LD_INT 131
11121: PPUSH
11122: LD_INT 0
11124: PPUSH
11125: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
11129: LD_VAR 0 2
11133: PPUSH
11134: LD_INT 100
11136: PPUSH
11137: LD_INT 82
11139: PPUSH
11140: CALL_OW 114
// end else
11144: GO 11160
// time := time + 0 0$1 ;
11146: LD_ADDR_VAR 0 1
11150: PUSH
11151: LD_VAR 0 1
11155: PUSH
11156: LD_INT 35
11158: PLUS
11159: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
11160: LD_EXP 50
11164: PPUSH
11165: CALL_OW 301
11169: PUSH
11170: LD_EXP 50
11174: PPUSH
11175: CALL_OW 255
11179: PUSH
11180: LD_INT 4
11182: EQUAL
11183: AND
11184: PUSH
11185: LD_INT 22
11187: PUSH
11188: LD_INT 7
11190: PUSH
11191: EMPTY
11192: LIST
11193: LIST
11194: PPUSH
11195: CALL_OW 69
11199: PPUSH
11200: LD_EXP 50
11204: PPUSH
11205: CALL_OW 74
11209: PPUSH
11210: LD_EXP 50
11214: PPUSH
11215: CALL_OW 296
11219: PUSH
11220: LD_INT 10
11222: LESS
11223: OR
11224: IFFALSE 11013
// if IsDead ( Belkov ) then
11226: LD_EXP 50
11230: PPUSH
11231: CALL_OW 301
11235: IFFALSE 11260
// begin CenterNowOnUnits ( Belkov ) ;
11237: LD_EXP 50
11241: PPUSH
11242: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
11246: LD_EXP 17
11250: PPUSH
11251: LD_STRING D5a-JMM-2a
11253: PPUSH
11254: CALL_OW 88
// exit ;
11258: GO 11326
// end ; if See ( 7 , Belkov ) then
11260: LD_INT 7
11262: PPUSH
11263: LD_EXP 50
11267: PPUSH
11268: CALL_OW 292
11272: IFFALSE 11286
// SetSide ( Belkov , 7 ) ;
11274: LD_EXP 50
11278: PPUSH
11279: LD_INT 7
11281: PPUSH
11282: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
11286: LD_INT 35
11288: PPUSH
11289: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
11293: LD_EXP 50
11297: PPUSH
11298: LD_INT 66
11300: PPUSH
11301: LD_INT 45
11303: PPUSH
11304: CALL_OW 297
11308: PUSH
11309: LD_INT 30
11311: LESS
11312: IFFALSE 11286
// Say ( Belkov , D6-Bel-1 ) ;
11314: LD_EXP 50
11318: PPUSH
11319: LD_STRING D6-Bel-1
11321: PPUSH
11322: CALL_OW 88
// end ;
11326: PPOPN 3
11328: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
11329: LD_EXP 50
11333: PPUSH
11334: CALL_OW 302
11338: PUSH
11339: LD_EXP 50
11343: PPUSH
11344: CALL_OW 504
11348: PUSH
11349: LD_INT 2
11351: PUSH
11352: LD_INT 34
11354: PUSH
11355: LD_INT 47
11357: PUSH
11358: EMPTY
11359: LIST
11360: LIST
11361: PUSH
11362: LD_INT 34
11364: PUSH
11365: LD_INT 45
11367: PUSH
11368: EMPTY
11369: LIST
11370: LIST
11371: PUSH
11372: EMPTY
11373: LIST
11374: LIST
11375: LIST
11376: PPUSH
11377: CALL_OW 69
11381: IN
11382: AND
11383: IFFALSE 11400
11385: GO 11387
11387: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
11388: LD_EXP 50
11392: PPUSH
11393: LD_STRING D7-Bel-1
11395: PPUSH
11396: CALL_OW 88
11400: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
11401: LD_INT 22
11403: PUSH
11404: LD_INT 7
11406: PUSH
11407: EMPTY
11408: LIST
11409: LIST
11410: PUSH
11411: LD_INT 101
11413: PUSH
11414: LD_INT 2
11416: PUSH
11417: EMPTY
11418: LIST
11419: LIST
11420: PUSH
11421: EMPTY
11422: LIST
11423: LIST
11424: PPUSH
11425: CALL_OW 69
11429: PUSH
11430: LD_EXP 9
11434: NOT
11435: AND
11436: PUSH
11437: LD_EXP 49
11441: PPUSH
11442: CALL_OW 305
11446: NOT
11447: AND
11448: IFFALSE 11933
11450: GO 11452
11452: DISABLE
11453: LD_INT 0
11455: PPUSH
// begin ar_base_spotted := true ;
11456: LD_ADDR_EXP 9
11460: PUSH
11461: LD_INT 1
11463: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
11464: LD_ADDR_VAR 0 1
11468: PUSH
11469: LD_INT 22
11471: PUSH
11472: LD_INT 2
11474: PUSH
11475: EMPTY
11476: LIST
11477: LIST
11478: PUSH
11479: LD_INT 21
11481: PUSH
11482: LD_INT 3
11484: PUSH
11485: EMPTY
11486: LIST
11487: LIST
11488: PUSH
11489: EMPTY
11490: LIST
11491: LIST
11492: PPUSH
11493: CALL_OW 69
11497: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
11498: LD_ADDR_VAR 0 1
11502: PUSH
11503: LD_VAR 0 1
11507: PPUSH
11508: LD_EXP 17
11512: PPUSH
11513: CALL_OW 74
11517: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
11518: LD_INT 7
11520: PPUSH
11521: LD_INT 3
11523: PPUSH
11524: CALL_OW 332
// DialogueOn ;
11528: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
11532: LD_VAR 0 1
11536: PPUSH
11537: CALL_OW 250
11541: PPUSH
11542: LD_VAR 0 1
11546: PPUSH
11547: CALL_OW 251
11551: PPUSH
11552: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
11556: LD_ADDR_VAR 0 1
11560: PUSH
11561: LD_INT 22
11563: PUSH
11564: LD_INT 7
11566: PUSH
11567: EMPTY
11568: LIST
11569: LIST
11570: PUSH
11571: LD_INT 23
11573: PUSH
11574: LD_INT 1
11576: PUSH
11577: EMPTY
11578: LIST
11579: LIST
11580: PUSH
11581: LD_INT 26
11583: PUSH
11584: LD_INT 1
11586: PUSH
11587: EMPTY
11588: LIST
11589: LIST
11590: PUSH
11591: EMPTY
11592: LIST
11593: LIST
11594: LIST
11595: PPUSH
11596: CALL_OW 69
11600: PUSH
11601: LD_EXP 17
11605: PUSH
11606: LD_EXP 21
11610: PUSH
11611: LD_EXP 22
11615: PUSH
11616: LD_EXP 29
11620: PUSH
11621: LD_EXP 18
11625: PUSH
11626: LD_EXP 27
11630: PUSH
11631: LD_EXP 23
11635: PUSH
11636: LD_EXP 25
11640: PUSH
11641: EMPTY
11642: LIST
11643: LIST
11644: LIST
11645: LIST
11646: LIST
11647: LIST
11648: LIST
11649: LIST
11650: DIFF
11651: ST_TO_ADDR
// if not tmp then
11652: LD_VAR 0 1
11656: NOT
11657: IFFALSE 11731
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
11659: LD_ADDR_VAR 0 1
11663: PUSH
11664: LD_INT 22
11666: PUSH
11667: LD_INT 7
11669: PUSH
11670: EMPTY
11671: LIST
11672: LIST
11673: PUSH
11674: LD_INT 23
11676: PUSH
11677: LD_INT 1
11679: PUSH
11680: EMPTY
11681: LIST
11682: LIST
11683: PUSH
11684: LD_INT 26
11686: PUSH
11687: LD_INT 2
11689: PUSH
11690: EMPTY
11691: LIST
11692: LIST
11693: PUSH
11694: EMPTY
11695: LIST
11696: LIST
11697: LIST
11698: PPUSH
11699: CALL_OW 69
11703: PUSH
11704: LD_EXP 32
11708: PUSH
11709: LD_EXP 19
11713: PUSH
11714: LD_EXP 30
11718: PUSH
11719: LD_EXP 31
11723: PUSH
11724: EMPTY
11725: LIST
11726: LIST
11727: LIST
11728: LIST
11729: DIFF
11730: ST_TO_ADDR
// if tmp then
11731: LD_VAR 0 1
11735: IFFALSE 11806
// case GetSex ( tmp [ 1 ] ) of sex_male :
11737: LD_VAR 0 1
11741: PUSH
11742: LD_INT 1
11744: ARRAY
11745: PPUSH
11746: CALL_OW 258
11750: PUSH
11751: LD_INT 1
11753: DOUBLE
11754: EQUAL
11755: IFTRUE 11759
11757: GO 11778
11759: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
11760: LD_VAR 0 1
11764: PUSH
11765: LD_INT 1
11767: ARRAY
11768: PPUSH
11769: LD_STRING D9-Sol1-1
11771: PPUSH
11772: CALL_OW 88
11776: GO 11806
11778: LD_INT 2
11780: DOUBLE
11781: EQUAL
11782: IFTRUE 11786
11784: GO 11805
11786: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
11787: LD_VAR 0 1
11791: PUSH
11792: LD_INT 1
11794: ARRAY
11795: PPUSH
11796: LD_STRING D9-FSol1-1
11798: PPUSH
11799: CALL_OW 88
11803: GO 11806
11805: POP
// if Frank then
11806: LD_EXP 29
11810: IFFALSE 11914
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
11812: LD_EXP 59
11816: PPUSH
11817: CALL_OW 250
11821: PPUSH
11822: LD_EXP 59
11826: PPUSH
11827: CALL_OW 251
11831: PPUSH
11832: LD_INT 7
11834: PPUSH
11835: LD_INT 8
11837: PPUSH
11838: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
11842: LD_EXP 59
11846: PPUSH
11847: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
11851: LD_EXP 29
11855: PPUSH
11856: LD_STRING D9-Frank-1
11858: PPUSH
11859: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
11863: LD_EXP 17
11867: PPUSH
11868: LD_STRING D9-JMM-1
11870: PPUSH
11871: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
11875: LD_EXP 29
11879: PPUSH
11880: LD_STRING D9-Frank-2
11882: PPUSH
11883: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
11887: LD_EXP 59
11891: PPUSH
11892: CALL_OW 250
11896: PPUSH
11897: LD_EXP 59
11901: PPUSH
11902: CALL_OW 251
11906: PPUSH
11907: LD_INT 7
11909: PPUSH
11910: CALL_OW 331
// end ; DialogueOff ;
11914: CALL_OW 7
// wait ( 1 1$00 ) ;
11918: LD_INT 2100
11920: PPUSH
11921: CALL_OW 67
// ar_active_attack := true ;
11925: LD_ADDR_EXP 10
11929: PUSH
11930: LD_INT 1
11932: ST_TO_ADDR
// end ;
11933: PPOPN 1
11935: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
11936: LD_EXP 8
11940: PUSH
11941: LD_OWVAR 1
11945: PUSH
11946: LD_INT 42000
11948: GREATEREQUAL
11949: OR
11950: IFFALSE 13012
11952: GO 11954
11954: DISABLE
11955: LD_INT 0
11957: PPUSH
11958: PPUSH
// begin selected_option := 1 ;
11959: LD_ADDR_VAR 0 2
11963: PUSH
11964: LD_INT 1
11966: ST_TO_ADDR
// wait ( 5 5$00 ) ;
11967: LD_INT 10500
11969: PPUSH
11970: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11974: LD_INT 35
11976: PPUSH
11977: CALL_OW 67
// until not ru_attackers ;
11981: LD_EXP 55
11985: NOT
11986: IFFALSE 11974
// PrepareBurlak ;
11988: CALL 2368 0 0
// repeat wait ( 0 0$2 ) ;
11992: LD_INT 70
11994: PPUSH
11995: CALL_OW 67
// until not HasTask ( Burlak ) ;
11999: LD_EXP 49
12003: PPUSH
12004: CALL_OW 314
12008: NOT
12009: IFFALSE 11992
// InGameOn ;
12011: CALL_OW 8
// DialogueOn ;
12015: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
12019: LD_EXP 52
12023: PPUSH
12024: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
12028: LD_EXP 49
12032: PPUSH
12033: LD_STRING D10-Bur-1
12035: PPUSH
12036: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
12040: LD_EXP 50
12044: PUSH
12045: LD_EXP 50
12049: PPUSH
12050: CALL_OW 255
12054: PUSH
12055: LD_INT 7
12057: EQUAL
12058: AND
12059: IFFALSE 12073
// Say ( Belkov , D10-Bel-1 ) ;
12061: LD_EXP 50
12065: PPUSH
12066: LD_STRING D10-Bel-1
12068: PPUSH
12069: CALL_OW 88
// if Gossudarov then
12073: LD_EXP 35
12077: IFFALSE 12091
// Say ( Gossudarov , D10-Gos-1 ) ;
12079: LD_EXP 35
12083: PPUSH
12084: LD_STRING D10-Gos-1
12086: PPUSH
12087: CALL_OW 88
// if Kirilenkova then
12091: LD_EXP 36
12095: IFFALSE 12109
// Say ( Kirilenkova , D10-Kir-1 ) ;
12097: LD_EXP 36
12101: PPUSH
12102: LD_STRING D10-Kir-1
12104: PPUSH
12105: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
12109: CALL 15777 0 0
12113: PPUSH
12114: LD_STRING D10-RSol1-1
12116: PPUSH
12117: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
12121: LD_EXP 49
12125: PPUSH
12126: LD_STRING D10-Bur-2
12128: PPUSH
12129: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
12133: LD_EXP 17
12137: PPUSH
12138: LD_STRING D10-JMM-2
12140: PPUSH
12141: CALL_OW 88
// if Kirilenkova then
12145: LD_EXP 36
12149: IFFALSE 12165
// Say ( Kirilenkova , D10-Kir-2 ) else
12151: LD_EXP 36
12155: PPUSH
12156: LD_STRING D10-Kir-2
12158: PPUSH
12159: CALL_OW 88
12163: GO 12177
// Say ( SolRu , D10-RSol1-2 ) ;
12165: CALL 15777 0 0
12169: PPUSH
12170: LD_STRING D10-RSol1-2
12172: PPUSH
12173: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
12177: LD_EXP 17
12181: PPUSH
12182: LD_STRING D10-JMM-3
12184: PPUSH
12185: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
12189: LD_EXP 49
12193: PPUSH
12194: LD_STRING D10-Bur-3
12196: PPUSH
12197: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
12201: LD_EXP 17
12205: PPUSH
12206: LD_STRING D10-JMM-4
12208: PPUSH
12209: CALL_OW 88
// DialogueOff ;
12213: CALL_OW 7
// InGameOff ;
12217: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
12221: LD_STRING M2
12223: PPUSH
12224: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12228: LD_INT 35
12230: PPUSH
12231: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
12235: LD_INT 22
12237: PUSH
12238: LD_INT 7
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PUSH
12245: LD_INT 91
12247: PUSH
12248: LD_EXP 49
12252: PUSH
12253: LD_INT 8
12255: PUSH
12256: EMPTY
12257: LIST
12258: LIST
12259: LIST
12260: PUSH
12261: EMPTY
12262: LIST
12263: LIST
12264: PPUSH
12265: CALL_OW 69
12269: IFFALSE 12228
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
12271: LD_ADDR_VAR 0 1
12275: PUSH
12276: LD_INT 22
12278: PUSH
12279: LD_INT 4
12281: PUSH
12282: EMPTY
12283: LIST
12284: LIST
12285: PPUSH
12286: CALL_OW 69
12290: PUSH
12291: FOR_IN
12292: IFFALSE 12308
// SetSide ( i , 7 ) ;
12294: LD_VAR 0 1
12298: PPUSH
12299: LD_INT 7
12301: PPUSH
12302: CALL_OW 235
12306: GO 12291
12308: POP
12309: POP
// ChangeMissionObjectives ( M3 ) ;
12310: LD_STRING M3
12312: PPUSH
12313: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
12317: LD_INT 35
12319: PPUSH
12320: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
12324: LD_EXP 17
12328: PPUSH
12329: LD_EXP 49
12333: PPUSH
12334: CALL_OW 296
12338: PUSH
12339: LD_INT 8
12341: LESS
12342: IFFALSE 12317
// ComTurnUnit ( JMM , Burlak ) ;
12344: LD_EXP 17
12348: PPUSH
12349: LD_EXP 49
12353: PPUSH
12354: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
12358: LD_EXP 49
12362: PPUSH
12363: LD_EXP 17
12367: PPUSH
12368: CALL_OW 119
// wait ( 0 0$0.3 ) ;
12372: LD_INT 10
12374: PPUSH
12375: CALL_OW 67
// DialogueOn ;
12379: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
12383: LD_EXP 17
12387: PPUSH
12388: LD_STRING D11-JMM-1
12390: PPUSH
12391: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
12395: LD_EXP 49
12399: PPUSH
12400: LD_STRING D11-Bur-1
12402: PPUSH
12403: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
12407: LD_EXP 17
12411: PPUSH
12412: LD_STRING D11-JMM-2
12414: PPUSH
12415: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
12419: LD_EXP 49
12423: PPUSH
12424: LD_STRING D11-Bur-2
12426: PPUSH
12427: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
12431: LD_EXP 17
12435: PPUSH
12436: LD_STRING D11-JMM-3
12438: PPUSH
12439: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
12443: LD_EXP 49
12447: PPUSH
12448: LD_STRING D11-Bur-3
12450: PPUSH
12451: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
12455: LD_EXP 17
12459: PPUSH
12460: LD_STRING D11-JMM-4
12462: PPUSH
12463: CALL_OW 88
// if ar_base_spotted then
12467: LD_EXP 9
12471: IFFALSE 12487
// Say ( Burlak , D12-Bur-1 ) else
12473: LD_EXP 49
12477: PPUSH
12478: LD_STRING D12-Bur-1
12480: PPUSH
12481: CALL_OW 88
12485: GO 12526
// begin RevealFogArea ( 7 , area_base_arabian ) ;
12487: LD_INT 7
12489: PPUSH
12490: LD_INT 3
12492: PPUSH
12493: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
12497: LD_INT 127
12499: PPUSH
12500: LD_INT 45
12502: PPUSH
12503: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
12507: LD_EXP 49
12511: PPUSH
12512: LD_STRING D12-Bur-1a
12514: PPUSH
12515: CALL_OW 88
// dwait ( 0 0$2 ) ;
12519: LD_INT 70
12521: PPUSH
12522: CALL_OW 68
// end ; if not IsOk ( Abdul ) then
12526: LD_EXP 58
12530: PPUSH
12531: CALL_OW 302
12535: NOT
12536: IFFALSE 12544
// begin DialogueOff ;
12538: CALL_OW 7
// exit ;
12542: GO 13012
// end ; Say ( Burlak , D12-Bur-1b ) ;
12544: LD_EXP 49
12548: PPUSH
12549: LD_STRING D12-Bur-1b
12551: PPUSH
12552: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
12556: LD_EXP 17
12560: PPUSH
12561: LD_STRING D12-JMM-1
12563: PPUSH
12564: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
12568: LD_EXP 49
12572: PPUSH
12573: LD_STRING D12-Bur-2
12575: PPUSH
12576: CALL_OW 88
// if Roth then
12580: LD_EXP 18
12584: IFFALSE 12600
// Say ( Roth , D12-Roth-2 ) else
12586: LD_EXP 18
12590: PPUSH
12591: LD_STRING D12-Roth-2
12593: PPUSH
12594: CALL_OW 88
12598: GO 12612
// Say ( SciRu , D12-RSci1-2 ) ;
12600: CALL 15630 0 0
12604: PPUSH
12605: LD_STRING D12-RSci1-2
12607: PPUSH
12608: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
12612: LD_EXP 17
12616: PPUSH
12617: LD_STRING D12-JMM-2
12619: PPUSH
12620: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
12624: LD_EXP 49
12628: PPUSH
12629: LD_STRING D12-Bur-3
12631: PPUSH
12632: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
12636: LD_EXP 17
12640: PPUSH
12641: LD_STRING D12-JMM-3
12643: PPUSH
12644: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
12648: LD_EXP 49
12652: PPUSH
12653: LD_STRING D12-Bur-4
12655: PPUSH
12656: CALL_OW 88
// case Query ( QBase ) of 1 :
12660: LD_STRING QBase
12662: PPUSH
12663: CALL_OW 97
12667: PUSH
12668: LD_INT 1
12670: DOUBLE
12671: EQUAL
12672: IFTRUE 12676
12674: GO 12794
12676: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
12677: LD_EXP 17
12681: PPUSH
12682: LD_STRING D13a-JMM-1
12684: PPUSH
12685: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
12689: LD_EXP 49
12693: PPUSH
12694: LD_STRING D13a-Bur-1
12696: PPUSH
12697: CALL_OW 88
// if Roth then
12701: LD_EXP 18
12705: IFFALSE 12721
// Say ( Roth , D13a-Roth-1 ) else
12707: LD_EXP 18
12711: PPUSH
12712: LD_STRING D13a-Roth-1
12714: PPUSH
12715: CALL_OW 88
12719: GO 12733
// Say ( SciRu , D13a-RSci1-1 ) ;
12721: CALL 15630 0 0
12725: PPUSH
12726: LD_STRING D13a-RSci1-1
12728: PPUSH
12729: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
12733: LD_EXP 17
12737: PPUSH
12738: LD_STRING D13a-JMM-2
12740: PPUSH
12741: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
12745: LD_STRING QBaseAgain
12747: PPUSH
12748: CALL_OW 97
12752: PUSH
12753: LD_INT 1
12755: DOUBLE
12756: EQUAL
12757: IFTRUE 12761
12759: GO 12772
12761: POP
// selected_option := 2 ; 2 :
12762: LD_ADDR_VAR 0 2
12766: PUSH
12767: LD_INT 2
12769: ST_TO_ADDR
12770: GO 12792
12772: LD_INT 2
12774: DOUBLE
12775: EQUAL
12776: IFTRUE 12780
12778: GO 12791
12780: POP
// selected_option := 3 ; end ;
12781: LD_ADDR_VAR 0 2
12785: PUSH
12786: LD_INT 3
12788: ST_TO_ADDR
12789: GO 12792
12791: POP
// end ; 2 :
12792: GO 12833
12794: LD_INT 2
12796: DOUBLE
12797: EQUAL
12798: IFTRUE 12802
12800: GO 12813
12802: POP
// selected_option := 2 ; 3 :
12803: LD_ADDR_VAR 0 2
12807: PUSH
12808: LD_INT 2
12810: ST_TO_ADDR
12811: GO 12833
12813: LD_INT 3
12815: DOUBLE
12816: EQUAL
12817: IFTRUE 12821
12819: GO 12832
12821: POP
// selected_option := 3 ; end ;
12822: LD_ADDR_VAR 0 2
12826: PUSH
12827: LD_INT 3
12829: ST_TO_ADDR
12830: GO 12833
12832: POP
// if selected_option = 2 then
12833: LD_VAR 0 2
12837: PUSH
12838: LD_INT 2
12840: EQUAL
12841: IFFALSE 12945
// begin Say ( JMM , D13b-JMM-1 ) ;
12843: LD_EXP 17
12847: PPUSH
12848: LD_STRING D13b-JMM-1
12850: PPUSH
12851: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
12855: LD_EXP 49
12859: PPUSH
12860: LD_STRING D13b-Bur-1
12862: PPUSH
12863: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
12867: LD_EXP 17
12871: PPUSH
12872: LD_STRING D13b-JMM-2
12874: PPUSH
12875: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
12879: LD_EXP 58
12883: PPUSH
12884: LD_STRING D13b-Abd-2
12886: PPUSH
12887: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
12891: LD_EXP 17
12895: PPUSH
12896: LD_STRING D13b-JMM-3
12898: PPUSH
12899: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
12903: LD_EXP 58
12907: PPUSH
12908: LD_STRING D13b-Abd-3
12910: PPUSH
12911: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
12915: LD_EXP 17
12919: PPUSH
12920: LD_STRING D13b-JMM-4
12922: PPUSH
12923: CALL_OW 88
// ar_active_attack := true ;
12927: LD_ADDR_EXP 10
12931: PUSH
12932: LD_INT 1
12934: ST_TO_ADDR
// SaveVariable ( true , 13a_negotiationWithArabs ) ;
12935: LD_INT 1
12937: PPUSH
12938: LD_STRING 13a_negotiationWithArabs
12940: PPUSH
12941: CALL_OW 39
// end ; if selected_option = 3 then
12945: LD_VAR 0 2
12949: PUSH
12950: LD_INT 3
12952: EQUAL
12953: IFFALSE 12979
// begin Say ( JMM , D13c-JMM-1 ) ;
12955: LD_EXP 17
12959: PPUSH
12960: LD_STRING D13c-JMM-1
12962: PPUSH
12963: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
12967: LD_EXP 49
12971: PPUSH
12972: LD_STRING D13c-Bur-1
12974: PPUSH
12975: CALL_OW 88
// end ; DialogueOff ;
12979: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
12983: LD_STRING M4
12985: PPUSH
12986: CALL_OW 337
// if not ar_active_attack then
12990: LD_EXP 10
12994: NOT
12995: IFFALSE 13012
// begin wait ( 6 6$00 ) ;
12997: LD_INT 12600
12999: PPUSH
13000: CALL_OW 67
// ar_active_attack := true ;
13004: LD_ADDR_EXP 10
13008: PUSH
13009: LD_INT 1
13011: ST_TO_ADDR
// end ; end ;
13012: PPOPN 2
13014: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
13015: LD_EXP 49
13019: PPUSH
13020: CALL_OW 305
13024: PUSH
13025: LD_EXP 49
13029: PPUSH
13030: CALL_OW 255
13034: PUSH
13035: LD_INT 7
13037: EQUAL
13038: AND
13039: IFFALSE 13262
13041: GO 13043
13043: DISABLE
13044: LD_INT 0
13046: PPUSH
// begin wait ( 4 4$40 ) ;
13047: LD_INT 9800
13049: PPUSH
13050: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
13054: LD_INT 35
13056: PPUSH
13057: CALL_OW 67
// until not ru_attackers and not FilterAllUnits ( [ [ f_side , 6 ] , [ f_ok ] ] ) ;
13061: LD_EXP 55
13065: NOT
13066: PUSH
13067: LD_INT 22
13069: PUSH
13070: LD_INT 6
13072: PUSH
13073: EMPTY
13074: LIST
13075: LIST
13076: PUSH
13077: LD_INT 50
13079: PUSH
13080: EMPTY
13081: LIST
13082: PUSH
13083: EMPTY
13084: LIST
13085: LIST
13086: PPUSH
13087: CALL_OW 69
13091: NOT
13092: AND
13093: IFFALSE 13054
// PrepareGnyevko ;
13095: CALL 2312 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
13099: LD_EXP 51
13103: PPUSH
13104: LD_INT 124
13106: PPUSH
13107: LD_INT 118
13109: PPUSH
13110: CALL_OW 111
// AddComHold ( Gnyevko ) ;
13114: LD_EXP 51
13118: PPUSH
13119: CALL_OW 200
// time := 0 0$00 ;
13123: LD_ADDR_VAR 0 1
13127: PUSH
13128: LD_INT 0
13130: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
13131: LD_INT 35
13133: PPUSH
13134: CALL_OW 67
// time := time + 0 0$1 ;
13138: LD_ADDR_VAR 0 1
13142: PUSH
13143: LD_VAR 0 1
13147: PUSH
13148: LD_INT 35
13150: PLUS
13151: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
13152: LD_EXP 51
13156: PPUSH
13157: LD_INT 124
13159: PPUSH
13160: LD_INT 118
13162: PPUSH
13163: CALL_OW 307
13167: PUSH
13168: LD_VAR 0 1
13172: PUSH
13173: LD_INT 1050
13175: GREATEREQUAL
13176: OR
13177: IFFALSE 13131
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
13179: LD_EXP 51
13183: PPUSH
13184: LD_STRING DBelkov-Gny-1
13186: PPUSH
13187: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
13191: LD_EXP 49
13195: PPUSH
13196: LD_STRING DBelkov-Bur-1a
13198: PPUSH
13199: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
13203: LD_INT 35
13205: PPUSH
13206: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
13210: LD_EXP 51
13214: PPUSH
13215: LD_INT 22
13217: PUSH
13218: LD_INT 7
13220: PUSH
13221: EMPTY
13222: LIST
13223: LIST
13224: PPUSH
13225: CALL_OW 69
13229: PPUSH
13230: LD_EXP 51
13234: PPUSH
13235: CALL_OW 74
13239: PPUSH
13240: CALL_OW 296
13244: PUSH
13245: LD_INT 8
13247: LESS
13248: IFFALSE 13203
// SetSide ( Gnyevko , 7 ) ;
13250: LD_EXP 51
13254: PPUSH
13255: LD_INT 7
13257: PPUSH
13258: CALL_OW 235
// end ;
13262: PPOPN 1
13264: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
13265: LD_EXP 49
13269: PPUSH
13270: CALL_OW 255
13274: PUSH
13275: LD_INT 7
13277: EQUAL
13278: IFFALSE 13288
13280: GO 13282
13282: DISABLE
// begin enable ;
13283: ENABLE
// PrepareAmericanAttack ;
13284: CALL 8627 0 0
// end ;
13288: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
13289: LD_INT 22
13291: PUSH
13292: LD_INT 1
13294: PUSH
13295: EMPTY
13296: LIST
13297: LIST
13298: PPUSH
13299: CALL_OW 69
13303: IFFALSE 13487
13305: GO 13307
13307: DISABLE
13308: LD_INT 0
13310: PPUSH
13311: PPUSH
// begin while true do
13312: LD_INT 1
13314: IFFALSE 13371
// begin wait ( 0 0$1 ) ;
13316: LD_INT 35
13318: PPUSH
13319: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
13323: LD_ADDR_VAR 0 2
13327: PUSH
13328: LD_INT 22
13330: PUSH
13331: LD_INT 1
13333: PUSH
13334: EMPTY
13335: LIST
13336: LIST
13337: PPUSH
13338: CALL_OW 69
13342: PPUSH
13343: LD_EXP 17
13347: PPUSH
13348: CALL_OW 74
13352: ST_TO_ADDR
// if See ( 7 , tmp ) then
13353: LD_INT 7
13355: PPUSH
13356: LD_VAR 0 2
13360: PPUSH
13361: CALL_OW 292
13365: IFFALSE 13369
// break ;
13367: GO 13371
// end ;
13369: GO 13312
// DialogueOn ;
13371: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
13375: LD_VAR 0 2
13379: PPUSH
13380: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
13384: LD_VAR 0 2
13388: PPUSH
13389: CALL_OW 250
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: CALL_OW 251
13403: PPUSH
13404: LD_INT 7
13406: PPUSH
13407: LD_INT 8
13409: PPUSH
13410: CALL_OW 330
// if Denis then
13414: LD_EXP 23
13418: IFFALSE 13432
// Say ( Denis , DAmerAttack-Pet-1 ) ;
13420: LD_EXP 23
13424: PPUSH
13425: LD_STRING DAmerAttack-Pet-1
13427: PPUSH
13428: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
13432: LD_EXP 17
13436: PPUSH
13437: LD_STRING DAmerAttack-JMM-1
13439: PPUSH
13440: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
13444: LD_EXP 49
13448: PPUSH
13449: LD_STRING DStop-Bur-1
13451: PPUSH
13452: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
13456: LD_VAR 0 2
13460: PPUSH
13461: CALL_OW 250
13465: PPUSH
13466: LD_VAR 0 2
13470: PPUSH
13471: CALL_OW 251
13475: PPUSH
13476: LD_INT 7
13478: PPUSH
13479: CALL_OW 331
// DialogueOff ;
13483: CALL_OW 7
// end ;
13487: PPOPN 2
13489: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
13490: LD_INT 22
13492: PUSH
13493: LD_INT 3
13495: PUSH
13496: EMPTY
13497: LIST
13498: LIST
13499: PUSH
13500: LD_INT 21
13502: PUSH
13503: LD_INT 1
13505: PUSH
13506: EMPTY
13507: LIST
13508: LIST
13509: PUSH
13510: EMPTY
13511: LIST
13512: LIST
13513: PPUSH
13514: CALL_OW 69
13518: PUSH
13519: LD_INT 0
13521: EQUAL
13522: IFFALSE 13572
13524: GO 13526
13526: DISABLE
// begin ru_active_attack := false ;
13527: LD_ADDR_EXP 6
13531: PUSH
13532: LD_INT 0
13534: ST_TO_ADDR
// ChangeMissionObjectives ( M5a ) ;
13535: LD_STRING M5a
13537: PPUSH
13538: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
13542: LD_EXP 17
13546: PPUSH
13547: LD_STRING D8-JMM-1
13549: PPUSH
13550: CALL_OW 88
// if Gossudarov then
13554: LD_EXP 35
13558: IFFALSE 13572
// Say ( Gossudarov , D8-Gos-1 ) ;
13560: LD_EXP 35
13564: PPUSH
13565: LD_STRING D8-Gos-1
13567: PPUSH
13568: CALL_OW 88
// end ;
13572: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
13573: LD_INT 22
13575: PUSH
13576: LD_INT 2
13578: PUSH
13579: EMPTY
13580: LIST
13581: LIST
13582: PUSH
13583: LD_INT 21
13585: PUSH
13586: LD_INT 1
13588: PUSH
13589: EMPTY
13590: LIST
13591: LIST
13592: PUSH
13593: EMPTY
13594: LIST
13595: LIST
13596: PPUSH
13597: CALL_OW 69
13601: PUSH
13602: LD_INT 0
13604: EQUAL
13605: IFFALSE 13663
13607: GO 13609
13609: DISABLE
// begin ar_active_attack := false ;
13610: LD_ADDR_EXP 10
13614: PUSH
13615: LD_INT 0
13617: ST_TO_ADDR
// ChangeMissionObjectives ( M4c ) ;
13618: LD_STRING M4c
13620: PPUSH
13621: CALL_OW 337
// if Roth then
13625: LD_EXP 18
13629: IFFALSE 13645
// Say ( Roth , DStop-Roth-1 ) else
13631: LD_EXP 18
13635: PPUSH
13636: LD_STRING DStop-Roth-1
13638: PPUSH
13639: CALL_OW 88
13643: GO 13663
// if Gossudarov then
13645: LD_EXP 35
13649: IFFALSE 13663
// Say ( Gossudarov , D8-Gos-1a ) ;
13651: LD_EXP 35
13655: PPUSH
13656: LD_STRING D8-Gos-1a
13658: PPUSH
13659: CALL_OW 88
// end ;
13663: END
// every 1 1$00 trigger FindArtifact ( 3 ) and first_powell_attack do
13664: LD_INT 3
13666: PPUSH
13667: CALL_OW 469
13671: PUSH
13672: LD_EXP 13
13676: AND
13677: IFFALSE 13732
13679: GO 13681
13681: DISABLE
// begin TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13682: LD_INT 3
13684: PPUSH
13685: CALL_OW 469
13689: PPUSH
13690: CALL 9116 0 1
// if Difficulty > 2 then
13694: LD_OWVAR 67
13698: PUSH
13699: LD_INT 2
13701: GREATER
13702: IFFALSE 13732
// begin wait ( 5 5$00 ) ;
13704: LD_INT 10500
13706: PPUSH
13707: CALL_OW 67
// if FindArtifact ( 3 ) then
13711: LD_INT 3
13713: PPUSH
13714: CALL_OW 469
13718: IFFALSE 13732
// TryToStoleArtifact ( FindArtifact ( 3 ) ) ;
13720: LD_INT 3
13722: PPUSH
13723: CALL_OW 469
13727: PPUSH
13728: CALL 9116 0 1
// end ; end ;
13732: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
13733: LD_INT 7
13735: PPUSH
13736: LD_INT 1
13738: PPUSH
13739: LD_INT 1
13741: PPUSH
13742: CALL 17423 0 3
13746: PUSH
13747: LD_INT 0
13749: EQUAL
13750: PUSH
13751: LD_INT 7
13753: PPUSH
13754: LD_INT 3
13756: PPUSH
13757: LD_INT 1
13759: PPUSH
13760: CALL 17423 0 3
13764: PUSH
13765: LD_INT 0
13767: EQUAL
13768: AND
13769: IFFALSE 13781
13771: GO 13773
13773: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
13774: LD_STRING M1a
13776: PPUSH
13777: CALL_OW 337
// end ;
13781: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
13782: LD_INT 22
13784: PUSH
13785: LD_INT 2
13787: PUSH
13788: EMPTY
13789: LIST
13790: LIST
13791: PUSH
13792: LD_INT 23
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 21
13804: PUSH
13805: LD_INT 1
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: LIST
13816: PPUSH
13817: CALL_OW 69
13821: PUSH
13822: LD_INT 0
13824: EQUAL
13825: PUSH
13826: LD_INT 22
13828: PUSH
13829: LD_INT 3
13831: PUSH
13832: EMPTY
13833: LIST
13834: LIST
13835: PUSH
13836: LD_INT 23
13838: PUSH
13839: LD_INT 3
13841: PUSH
13842: EMPTY
13843: LIST
13844: LIST
13845: PUSH
13846: LD_INT 21
13848: PUSH
13849: LD_INT 1
13851: PUSH
13852: EMPTY
13853: LIST
13854: LIST
13855: PUSH
13856: EMPTY
13857: LIST
13858: LIST
13859: LIST
13860: PPUSH
13861: CALL_OW 69
13865: PUSH
13866: LD_INT 0
13868: EQUAL
13869: AND
13870: PUSH
13871: LD_INT 22
13873: PUSH
13874: LD_INT 1
13876: PUSH
13877: EMPTY
13878: LIST
13879: LIST
13880: PPUSH
13881: CALL_OW 69
13885: PUSH
13886: LD_INT 0
13888: EQUAL
13889: AND
13890: PUSH
13891: LD_INT 7
13893: PPUSH
13894: LD_INT 1
13896: PPUSH
13897: LD_INT 1
13899: PPUSH
13900: CALL 17423 0 3
13904: PUSH
13905: LD_INT 0
13907: EQUAL
13908: AND
13909: PUSH
13910: LD_INT 7
13912: PPUSH
13913: LD_INT 3
13915: PPUSH
13916: LD_INT 1
13918: PPUSH
13919: CALL 17423 0 3
13923: PUSH
13924: LD_INT 0
13926: EQUAL
13927: AND
13928: PUSH
13929: LD_EXP 49
13933: PPUSH
13934: CALL_OW 255
13938: PUSH
13939: LD_INT 7
13941: EQUAL
13942: AND
13943: PUSH
13944: LD_EXP 49
13948: PPUSH
13949: CALL_OW 302
13953: AND
13954: IFFALSE 15627
13956: GO 13958
13958: DISABLE
13959: LD_INT 0
13961: PPUSH
13962: PPUSH
13963: PPUSH
13964: PPUSH
13965: PPUSH
13966: PPUSH
// begin m1 := false ;
13967: LD_ADDR_VAR 0 4
13971: PUSH
13972: LD_INT 0
13974: ST_TO_ADDR
// m2 := false ;
13975: LD_ADDR_VAR 0 5
13979: PUSH
13980: LD_INT 0
13982: ST_TO_ADDR
// m3 := false ;
13983: LD_ADDR_VAR 0 6
13987: PUSH
13988: LD_INT 0
13990: ST_TO_ADDR
// if tick < 40 40$00 then
13991: LD_OWVAR 1
13995: PUSH
13996: LD_INT 84000
13998: LESS
13999: IFFALSE 14008
// SetAchievement ( ACH_ASPEED_17 ) ;
14001: LD_STRING ACH_ASPEED_17
14003: PPUSH
14004: CALL_OW 543
// wait ( 0 0$5 ) ;
14008: LD_INT 175
14010: PPUSH
14011: CALL_OW 67
// if not masha_killed then
14015: LD_EXP 11
14019: NOT
14020: IFFALSE 14042
// begin m1 := true ;
14022: LD_ADDR_VAR 0 4
14026: PUSH
14027: LD_INT 1
14029: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
14030: LD_STRING Masha
14032: PPUSH
14033: LD_INT 1
14035: PPUSH
14036: CALL_OW 101
// end else
14040: GO 14053
// AddMedal ( Masha , - 1 ) ;
14042: LD_STRING Masha
14044: PPUSH
14045: LD_INT 1
14047: NEG
14048: PPUSH
14049: CALL_OW 101
// if abdul_escaped then
14053: LD_EXP 14
14057: IFFALSE 14072
// AddMedal ( Abdul , - 1 ) else
14059: LD_STRING Abdul
14061: PPUSH
14062: LD_INT 1
14064: NEG
14065: PPUSH
14066: CALL_OW 101
14070: GO 14090
// begin m2 := true ;
14072: LD_ADDR_VAR 0 5
14076: PUSH
14077: LD_INT 1
14079: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
14080: LD_STRING Abdul
14082: PPUSH
14083: LD_INT 1
14085: PPUSH
14086: CALL_OW 101
// end ; if loss_counter = 0 then
14090: LD_EXP 15
14094: PUSH
14095: LD_INT 0
14097: EQUAL
14098: IFFALSE 14120
// begin m3 := true ;
14100: LD_ADDR_VAR 0 6
14104: PUSH
14105: LD_INT 1
14107: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
14108: LD_STRING People
14110: PPUSH
14111: LD_INT 2
14113: PPUSH
14114: CALL_OW 101
// end else
14118: GO 14182
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
14120: LD_EXP 15
14124: PUSH
14125: LD_INT 3
14127: PUSH
14128: LD_INT 2
14130: PUSH
14131: LD_INT 2
14133: PUSH
14134: LD_INT 1
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PUSH
14143: LD_OWVAR 67
14147: ARRAY
14148: LESSEQUAL
14149: IFFALSE 14171
// begin AddMedal ( People , 1 ) ;
14151: LD_STRING People
14153: PPUSH
14154: LD_INT 1
14156: PPUSH
14157: CALL_OW 101
// m3 := true ;
14161: LD_ADDR_VAR 0 6
14165: PUSH
14166: LD_INT 1
14168: ST_TO_ADDR
// end else
14169: GO 14182
// AddMedal ( People , - 1 ) ;
14171: LD_STRING People
14173: PPUSH
14174: LD_INT 1
14176: NEG
14177: PPUSH
14178: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
14182: LD_OWVAR 67
14186: PUSH
14187: LD_INT 3
14189: GREATEREQUAL
14190: PUSH
14191: LD_VAR 0 4
14195: AND
14196: PUSH
14197: LD_VAR 0 5
14201: AND
14202: PUSH
14203: LD_VAR 0 6
14207: AND
14208: IFFALSE 14220
// SetAchievementEX ( ACH_AMER , 17 ) ;
14210: LD_STRING ACH_AMER
14212: PPUSH
14213: LD_INT 17
14215: PPUSH
14216: CALL_OW 564
// GiveMedals ( MAIN ) ;
14220: LD_STRING MAIN
14222: PPUSH
14223: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
14227: LD_ADDR_VAR 0 2
14231: PUSH
14232: LD_INT 22
14234: PUSH
14235: LD_INT 7
14237: PUSH
14238: EMPTY
14239: LIST
14240: LIST
14241: PUSH
14242: LD_INT 50
14244: PUSH
14245: EMPTY
14246: LIST
14247: PUSH
14248: LD_INT 2
14250: PUSH
14251: LD_INT 25
14253: PUSH
14254: LD_INT 1
14256: PUSH
14257: EMPTY
14258: LIST
14259: LIST
14260: PUSH
14261: LD_INT 25
14263: PUSH
14264: LD_INT 2
14266: PUSH
14267: EMPTY
14268: LIST
14269: LIST
14270: PUSH
14271: LD_INT 25
14273: PUSH
14274: LD_INT 3
14276: PUSH
14277: EMPTY
14278: LIST
14279: LIST
14280: PUSH
14281: LD_INT 25
14283: PUSH
14284: LD_INT 4
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: PUSH
14291: LD_INT 25
14293: PUSH
14294: LD_INT 5
14296: PUSH
14297: EMPTY
14298: LIST
14299: LIST
14300: PUSH
14301: LD_INT 25
14303: PUSH
14304: LD_INT 8
14306: PUSH
14307: EMPTY
14308: LIST
14309: LIST
14310: PUSH
14311: LD_INT 25
14313: PUSH
14314: LD_INT 9
14316: PUSH
14317: EMPTY
14318: LIST
14319: LIST
14320: PUSH
14321: EMPTY
14322: LIST
14323: LIST
14324: LIST
14325: LIST
14326: LIST
14327: LIST
14328: LIST
14329: LIST
14330: PUSH
14331: EMPTY
14332: LIST
14333: LIST
14334: LIST
14335: PPUSH
14336: CALL_OW 69
14340: ST_TO_ADDR
// RewardPeople ( tmp ) ;
14341: LD_VAR 0 2
14345: PPUSH
14346: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
14350: LD_ADDR_VAR 0 3
14354: PUSH
14355: LD_EXP 17
14359: PUSH
14360: LD_EXP 18
14364: PUSH
14365: LD_EXP 19
14369: PUSH
14370: LD_EXP 20
14374: PUSH
14375: LD_EXP 21
14379: PUSH
14380: LD_EXP 22
14384: PUSH
14385: LD_EXP 23
14389: PUSH
14390: LD_EXP 24
14394: PUSH
14395: LD_EXP 25
14399: PUSH
14400: LD_EXP 26
14404: PUSH
14405: LD_EXP 27
14409: PUSH
14410: LD_EXP 28
14414: PUSH
14415: LD_EXP 29
14419: PUSH
14420: LD_EXP 30
14424: PUSH
14425: LD_EXP 31
14429: PUSH
14430: LD_EXP 32
14434: PUSH
14435: LD_EXP 33
14439: PUSH
14440: LD_EXP 35
14444: PUSH
14445: LD_EXP 36
14449: PUSH
14450: LD_EXP 37
14454: PUSH
14455: LD_EXP 39
14459: PUSH
14460: LD_EXP 40
14464: PUSH
14465: LD_EXP 41
14469: PUSH
14470: LD_EXP 42
14474: PUSH
14475: LD_EXP 43
14479: PUSH
14480: LD_EXP 44
14484: PUSH
14485: LD_EXP 45
14489: PUSH
14490: LD_EXP 46
14494: PUSH
14495: LD_EXP 47
14499: PUSH
14500: LD_EXP 48
14504: PUSH
14505: LD_EXP 49
14509: PUSH
14510: LD_EXP 50
14514: PUSH
14515: LD_EXP 51
14519: PUSH
14520: LD_EXP 34
14524: PUSH
14525: EMPTY
14526: LIST
14527: LIST
14528: LIST
14529: LIST
14530: LIST
14531: LIST
14532: LIST
14533: LIST
14534: LIST
14535: LIST
14536: LIST
14537: LIST
14538: LIST
14539: LIST
14540: LIST
14541: LIST
14542: LIST
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: ST_TO_ADDR
// if tmp diff tmp2 then
14561: LD_VAR 0 2
14565: PUSH
14566: LD_VAR 0 3
14570: DIFF
14571: IFFALSE 14591
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
14573: LD_VAR 0 2
14577: PUSH
14578: LD_VAR 0 3
14582: DIFF
14583: PPUSH
14584: LD_STRING 13a_others
14586: PPUSH
14587: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
14591: LD_EXP 17
14595: PPUSH
14596: LD_STRING 13a_JMM
14598: PPUSH
14599: CALL_OW 38
// if IsOk ( Mike ) then
14603: LD_EXP 34
14607: PPUSH
14608: CALL_OW 302
14612: IFFALSE 14626
// SaveCharacters ( Mike , 13a_Mike ) ;
14614: LD_EXP 34
14618: PPUSH
14619: LD_STRING 13a_Mike
14621: PPUSH
14622: CALL_OW 38
// if IsOk ( Titov ) then
14626: LD_EXP 37
14630: PPUSH
14631: CALL_OW 302
14635: IFFALSE 14649
// SaveCharacters ( Titov , 13a_Titov ) ;
14637: LD_EXP 37
14641: PPUSH
14642: LD_STRING 13a_Titov
14644: PPUSH
14645: CALL_OW 38
// if IsOk ( Dolgov ) then
14649: LD_EXP 39
14653: PPUSH
14654: CALL_OW 302
14658: IFFALSE 14672
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
14660: LD_EXP 39
14664: PPUSH
14665: LD_STRING 13a_Dolgov
14667: PPUSH
14668: CALL_OW 38
// if IsOk ( Petrosyan ) then
14672: LD_EXP 40
14676: PPUSH
14677: CALL_OW 302
14681: IFFALSE 14695
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
14683: LD_EXP 40
14687: PPUSH
14688: LD_STRING 13a_Petrosyan
14690: PPUSH
14691: CALL_OW 38
// if IsOk ( Scholtze ) then
14695: LD_EXP 41
14699: PPUSH
14700: CALL_OW 302
14704: IFFALSE 14718
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
14706: LD_EXP 41
14710: PPUSH
14711: LD_STRING 13a_Scholtze
14713: PPUSH
14714: CALL_OW 38
// if IsOk ( Oblukov ) then
14718: LD_EXP 42
14722: PPUSH
14723: CALL_OW 302
14727: IFFALSE 14741
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
14729: LD_EXP 42
14733: PPUSH
14734: LD_STRING 13a_Oblukov
14736: PPUSH
14737: CALL_OW 38
// if IsOk ( Kapitsova ) then
14741: LD_EXP 43
14745: PPUSH
14746: CALL_OW 302
14750: IFFALSE 14764
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
14752: LD_EXP 43
14756: PPUSH
14757: LD_STRING 13a_Kapitsova
14759: PPUSH
14760: CALL_OW 38
// if IsOk ( Lipshchin ) then
14764: LD_EXP 44
14768: PPUSH
14769: CALL_OW 302
14773: IFFALSE 14787
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
14775: LD_EXP 44
14779: PPUSH
14780: LD_STRING 13a_Lipshchin
14782: PPUSH
14783: CALL_OW 38
// if IsOk ( Petrovova ) then
14787: LD_EXP 45
14791: PPUSH
14792: CALL_OW 302
14796: IFFALSE 14810
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
14798: LD_EXP 45
14802: PPUSH
14803: LD_STRING 13a_Petrovova
14805: PPUSH
14806: CALL_OW 38
// if IsOk ( Kovalyuk ) then
14810: LD_EXP 46
14814: PPUSH
14815: CALL_OW 302
14819: IFFALSE 14833
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
14821: LD_EXP 46
14825: PPUSH
14826: LD_STRING 13a_Kovalyuk
14828: PPUSH
14829: CALL_OW 38
// if IsOk ( Kuzmov ) then
14833: LD_EXP 47
14837: PPUSH
14838: CALL_OW 302
14842: IFFALSE 14856
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
14844: LD_EXP 47
14848: PPUSH
14849: LD_STRING 13a_Kuzmov
14851: PPUSH
14852: CALL_OW 38
// if IsOk ( Karamazov ) then
14856: LD_EXP 48
14860: PPUSH
14861: CALL_OW 302
14865: IFFALSE 14879
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
14867: LD_EXP 48
14871: PPUSH
14872: LD_STRING 13a_Karamazov
14874: PPUSH
14875: CALL_OW 38
// if Burlak then
14879: LD_EXP 49
14883: IFFALSE 14904
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
14885: LD_STRING enableBioCharacter(BIO_GORKI)
14887: PPUSH
14888: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
14892: LD_EXP 49
14896: PPUSH
14897: LD_STRING 13a_Burlak
14899: PPUSH
14900: CALL_OW 38
// end ; if IsOk ( Belkov ) then
14904: LD_EXP 50
14908: PPUSH
14909: CALL_OW 302
14913: IFFALSE 14927
// SaveCharacters ( Belkov , 13a_Belkov ) ;
14915: LD_EXP 50
14919: PPUSH
14920: LD_STRING 13a_Belkov
14922: PPUSH
14923: CALL_OW 38
// if IsOk ( Gnyevko ) then
14927: LD_EXP 51
14931: PPUSH
14932: CALL_OW 302
14936: IFFALSE 14950
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
14938: LD_EXP 51
14942: PPUSH
14943: LD_STRING 13a_Gnyevko
14945: PPUSH
14946: CALL_OW 38
// if IsOk ( Lisa ) then
14950: LD_EXP 19
14954: PPUSH
14955: CALL_OW 302
14959: IFFALSE 14973
// SaveCharacters ( Lisa , 13a_Lisa ) ;
14961: LD_EXP 19
14965: PPUSH
14966: LD_STRING 13a_Lisa
14968: PPUSH
14969: CALL_OW 38
// if IsOk ( Donaldson ) then
14973: LD_EXP 20
14977: PPUSH
14978: CALL_OW 302
14982: IFFALSE 14996
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
14984: LD_EXP 20
14988: PPUSH
14989: LD_STRING 13a_Donaldson
14991: PPUSH
14992: CALL_OW 38
// if IsOk ( Bobby ) then
14996: LD_EXP 21
15000: PPUSH
15001: CALL_OW 302
15005: IFFALSE 15019
// SaveCharacters ( Bobby , 13a_Bobby ) ;
15007: LD_EXP 21
15011: PPUSH
15012: LD_STRING 13a_Bobby
15014: PPUSH
15015: CALL_OW 38
// if IsOk ( Cyrus ) then
15019: LD_EXP 22
15023: PPUSH
15024: CALL_OW 302
15028: IFFALSE 15042
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
15030: LD_EXP 22
15034: PPUSH
15035: LD_STRING 13a_Cyrus
15037: PPUSH
15038: CALL_OW 38
// if IsOk ( Denis ) then
15042: LD_EXP 23
15046: PPUSH
15047: CALL_OW 302
15051: IFFALSE 15065
// SaveCharacters ( Denis , 13a_Denis ) ;
15053: LD_EXP 23
15057: PPUSH
15058: LD_STRING 13a_Denis
15060: PPUSH
15061: CALL_OW 38
// if IsOk ( Brown ) then
15065: LD_EXP 24
15069: PPUSH
15070: CALL_OW 302
15074: IFFALSE 15088
// SaveCharacters ( Brown , 13a_Brown ) ;
15076: LD_EXP 24
15080: PPUSH
15081: LD_STRING 13a_Brown
15083: PPUSH
15084: CALL_OW 38
// if IsOk ( Gladstone ) then
15088: LD_EXP 25
15092: PPUSH
15093: CALL_OW 302
15097: IFFALSE 15111
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
15099: LD_EXP 25
15103: PPUSH
15104: LD_STRING 13a_Gladstone
15106: PPUSH
15107: CALL_OW 38
// if IsOk ( Houten ) then
15111: LD_EXP 26
15115: PPUSH
15116: CALL_OW 302
15120: IFFALSE 15134
// SaveCharacters ( Houten , 13a_Houten ) ;
15122: LD_EXP 26
15126: PPUSH
15127: LD_STRING 13a_Houten
15129: PPUSH
15130: CALL_OW 38
// if IsOk ( Cornel ) then
15134: LD_EXP 27
15138: PPUSH
15139: CALL_OW 302
15143: IFFALSE 15157
// SaveCharacters ( Cornel , 13a_Cornel ) ;
15145: LD_EXP 27
15149: PPUSH
15150: LD_STRING 13a_Cornel
15152: PPUSH
15153: CALL_OW 38
// if IsOk ( Gary ) then
15157: LD_EXP 28
15161: PPUSH
15162: CALL_OW 302
15166: IFFALSE 15180
// SaveCharacters ( Gary , 13a_Gary ) ;
15168: LD_EXP 28
15172: PPUSH
15173: LD_STRING 13a_Gary
15175: PPUSH
15176: CALL_OW 38
// if IsOk ( Frank ) then
15180: LD_EXP 29
15184: PPUSH
15185: CALL_OW 302
15189: IFFALSE 15203
// SaveCharacters ( Frank , 13a_Frank ) ;
15191: LD_EXP 29
15195: PPUSH
15196: LD_STRING 13a_Frank
15198: PPUSH
15199: CALL_OW 38
// if IsOk ( Kikuchi ) then
15203: LD_EXP 30
15207: PPUSH
15208: CALL_OW 302
15212: IFFALSE 15226
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
15214: LD_EXP 30
15218: PPUSH
15219: LD_STRING 13a_Kikuchi
15221: PPUSH
15222: CALL_OW 38
// if IsOk ( Simms ) then
15226: LD_EXP 31
15230: PPUSH
15231: CALL_OW 302
15235: IFFALSE 15249
// SaveCharacters ( Simms , 13a_Simms ) ;
15237: LD_EXP 31
15241: PPUSH
15242: LD_STRING 13a_Simms
15244: PPUSH
15245: CALL_OW 38
// if IsOk ( Joan ) then
15249: LD_EXP 32
15253: PPUSH
15254: CALL_OW 302
15258: IFFALSE 15272
// SaveCharacters ( Joan , 13a_Joan ) ;
15260: LD_EXP 32
15264: PPUSH
15265: LD_STRING 13a_Joan
15267: PPUSH
15268: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
15272: LD_EXP 33
15276: PPUSH
15277: CALL_OW 302
15281: IFFALSE 15295
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
15283: LD_EXP 33
15287: PPUSH
15288: LD_STRING 13a_DeltaDoctor
15290: PPUSH
15291: CALL_OW 38
// if IsOk ( Gossudarov ) then
15295: LD_EXP 35
15299: PPUSH
15300: CALL_OW 302
15304: IFFALSE 15318
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
15306: LD_EXP 35
15310: PPUSH
15311: LD_STRING 13a_Gossudarov
15313: PPUSH
15314: CALL_OW 38
// if IsOk ( Kirilenkova ) then
15318: LD_EXP 36
15322: PPUSH
15323: CALL_OW 302
15327: IFFALSE 15341
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
15329: LD_EXP 36
15333: PPUSH
15334: LD_STRING 13a_Kirilenkova
15336: PPUSH
15337: CALL_OW 38
// if IsOk ( Roth ) then
15341: LD_EXP 18
15345: PPUSH
15346: CALL_OW 302
15350: IFFALSE 15364
// SaveCharacters ( Roth , 13a_Roth ) ;
15352: LD_EXP 18
15356: PPUSH
15357: LD_STRING 13a_Roth
15359: PPUSH
15360: CALL_OW 38
// if Masha then
15364: LD_EXP 52
15368: IFFALSE 15423
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
15370: LD_EXP 52
15374: PPUSH
15375: CALL_OW 265
15379: PUSH
15380: LD_EXP 52
15384: PPUSH
15385: CALL_OW 262
15389: PUSH
15390: LD_EXP 52
15394: PPUSH
15395: CALL_OW 263
15399: PUSH
15400: LD_EXP 52
15404: PPUSH
15405: CALL_OW 264
15409: PUSH
15410: EMPTY
15411: LIST
15412: LIST
15413: LIST
15414: LIST
15415: PPUSH
15416: LD_STRING 13a_Masha
15418: PPUSH
15419: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
15423: LD_ADDR_VAR 0 2
15427: PUSH
15428: LD_INT 21
15430: PUSH
15431: LD_INT 3
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PPUSH
15438: CALL_OW 69
15442: ST_TO_ADDR
// tmp2 := [ ] ;
15443: LD_ADDR_VAR 0 3
15447: PUSH
15448: EMPTY
15449: ST_TO_ADDR
// if tmp then
15450: LD_VAR 0 2
15454: IFFALSE 15605
// for i in tmp do
15456: LD_ADDR_VAR 0 1
15460: PUSH
15461: LD_VAR 0 2
15465: PUSH
15466: FOR_IN
15467: IFFALSE 15603
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
15469: LD_ADDR_VAR 0 3
15473: PUSH
15474: LD_VAR 0 3
15478: PUSH
15479: LD_VAR 0 1
15483: PPUSH
15484: CALL_OW 255
15488: PUSH
15489: LD_VAR 0 1
15493: PPUSH
15494: CALL_OW 248
15498: PUSH
15499: LD_VAR 0 1
15503: PPUSH
15504: CALL_OW 266
15508: PUSH
15509: LD_VAR 0 1
15513: PPUSH
15514: CALL_OW 250
15518: PUSH
15519: LD_VAR 0 1
15523: PPUSH
15524: CALL_OW 251
15528: PUSH
15529: LD_VAR 0 1
15533: PPUSH
15534: CALL_OW 254
15538: PUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 267
15548: PUSH
15549: LD_VAR 0 1
15553: PPUSH
15554: LD_INT 1
15556: PPUSH
15557: CALL_OW 268
15561: PUSH
15562: LD_VAR 0 1
15566: PPUSH
15567: LD_INT 2
15569: PPUSH
15570: CALL_OW 268
15574: PUSH
15575: LD_VAR 0 1
15579: PPUSH
15580: CALL_OW 269
15584: PUSH
15585: EMPTY
15586: LIST
15587: LIST
15588: LIST
15589: LIST
15590: LIST
15591: LIST
15592: LIST
15593: LIST
15594: LIST
15595: LIST
15596: PUSH
15597: EMPTY
15598: LIST
15599: ADD
15600: ST_TO_ADDR
15601: GO 15466
15603: POP
15604: POP
// if tmp2 then
15605: LD_VAR 0 3
15609: IFFALSE 15623
// SaveVariable ( tmp2 , 13a_buildings ) ;
15611: LD_VAR 0 3
15615: PPUSH
15616: LD_STRING 13a_buildings
15618: PPUSH
15619: CALL_OW 39
// YouWin ;
15623: CALL_OW 103
// end ;
15627: PPOPN 6
15629: END
// export function SciRu ; var tmp , t ; begin
15630: LD_INT 0
15632: PPUSH
15633: PPUSH
15634: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15635: LD_ADDR_VAR 0 3
15639: PUSH
15640: LD_EXP 35
15644: PUSH
15645: LD_EXP 49
15649: PUSH
15650: LD_EXP 37
15654: PUSH
15655: LD_EXP 50
15659: PUSH
15660: LD_EXP 51
15664: PUSH
15665: LD_EXP 40
15669: PUSH
15670: LD_EXP 41
15674: PUSH
15675: LD_EXP 39
15679: PUSH
15680: EMPTY
15681: LIST
15682: LIST
15683: LIST
15684: LIST
15685: LIST
15686: LIST
15687: LIST
15688: LIST
15689: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
15690: LD_ADDR_VAR 0 2
15694: PUSH
15695: LD_INT 22
15697: PUSH
15698: LD_INT 7
15700: PUSH
15701: EMPTY
15702: LIST
15703: LIST
15704: PUSH
15705: LD_INT 23
15707: PUSH
15708: LD_INT 3
15710: PUSH
15711: EMPTY
15712: LIST
15713: LIST
15714: PUSH
15715: LD_INT 25
15717: PUSH
15718: LD_INT 4
15720: PUSH
15721: EMPTY
15722: LIST
15723: LIST
15724: PUSH
15725: LD_INT 26
15727: PUSH
15728: LD_INT 1
15730: PUSH
15731: EMPTY
15732: LIST
15733: LIST
15734: PUSH
15735: EMPTY
15736: LIST
15737: LIST
15738: LIST
15739: LIST
15740: PPUSH
15741: CALL_OW 69
15745: PUSH
15746: LD_VAR 0 3
15750: DIFF
15751: ST_TO_ADDR
// if tmp then
15752: LD_VAR 0 2
15756: IFFALSE 15772
// result := tmp [ 1 ] ;
15758: LD_ADDR_VAR 0 1
15762: PUSH
15763: LD_VAR 0 2
15767: PUSH
15768: LD_INT 1
15770: ARRAY
15771: ST_TO_ADDR
// end ;
15772: LD_VAR 0 1
15776: RET
// export function SolRu ; var tmp , t ; begin
15777: LD_INT 0
15779: PPUSH
15780: PPUSH
15781: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
15782: LD_ADDR_VAR 0 3
15786: PUSH
15787: LD_EXP 35
15791: PUSH
15792: LD_EXP 49
15796: PUSH
15797: LD_EXP 37
15801: PUSH
15802: LD_EXP 50
15806: PUSH
15807: LD_EXP 51
15811: PUSH
15812: LD_EXP 40
15816: PUSH
15817: LD_EXP 41
15821: PUSH
15822: LD_EXP 39
15826: PUSH
15827: EMPTY
15828: LIST
15829: LIST
15830: LIST
15831: LIST
15832: LIST
15833: LIST
15834: LIST
15835: LIST
15836: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
15837: LD_ADDR_VAR 0 2
15841: PUSH
15842: LD_INT 22
15844: PUSH
15845: LD_INT 7
15847: PUSH
15848: EMPTY
15849: LIST
15850: LIST
15851: PUSH
15852: LD_INT 23
15854: PUSH
15855: LD_INT 3
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: LD_INT 25
15864: PUSH
15865: LD_INT 1
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: LD_INT 26
15874: PUSH
15875: LD_INT 1
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: PUSH
15882: EMPTY
15883: LIST
15884: LIST
15885: LIST
15886: LIST
15887: PPUSH
15888: CALL_OW 69
15892: PUSH
15893: LD_VAR 0 3
15897: DIFF
15898: ST_TO_ADDR
// if tmp then
15899: LD_VAR 0 2
15903: IFFALSE 15919
// result := tmp [ 1 ] ;
15905: LD_ADDR_VAR 0 1
15909: PUSH
15910: LD_VAR 0 2
15914: PUSH
15915: LD_INT 1
15917: ARRAY
15918: ST_TO_ADDR
// end ; end_of_file
15919: LD_VAR 0 1
15923: RET
// export function CustomEvent ( event ) ; begin
15924: LD_INT 0
15926: PPUSH
// end ;
15927: LD_VAR 0 2
15931: RET
// on UnitDestroyed ( un ) do var i , side ;
15932: LD_INT 0
15934: PPUSH
15935: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
15936: LD_VAR 0 1
15940: PPUSH
15941: CALL 106816 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
15945: LD_VAR 0 1
15949: PUSH
15950: LD_INT 22
15952: PUSH
15953: LD_INT 7
15955: PUSH
15956: EMPTY
15957: LIST
15958: LIST
15959: PUSH
15960: LD_INT 2
15962: PUSH
15963: LD_INT 25
15965: PUSH
15966: LD_INT 1
15968: PUSH
15969: EMPTY
15970: LIST
15971: LIST
15972: PUSH
15973: LD_INT 25
15975: PUSH
15976: LD_INT 2
15978: PUSH
15979: EMPTY
15980: LIST
15981: LIST
15982: PUSH
15983: LD_INT 25
15985: PUSH
15986: LD_INT 3
15988: PUSH
15989: EMPTY
15990: LIST
15991: LIST
15992: PUSH
15993: LD_INT 25
15995: PUSH
15996: LD_INT 4
15998: PUSH
15999: EMPTY
16000: LIST
16001: LIST
16002: PUSH
16003: LD_INT 25
16005: PUSH
16006: LD_INT 5
16008: PUSH
16009: EMPTY
16010: LIST
16011: LIST
16012: PUSH
16013: LD_INT 25
16015: PUSH
16016: LD_INT 8
16018: PUSH
16019: EMPTY
16020: LIST
16021: LIST
16022: PUSH
16023: LD_INT 25
16025: PUSH
16026: LD_INT 9
16028: PUSH
16029: EMPTY
16030: LIST
16031: LIST
16032: PUSH
16033: EMPTY
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: PUSH
16043: EMPTY
16044: LIST
16045: LIST
16046: PPUSH
16047: CALL_OW 69
16051: IN
16052: IFFALSE 16068
// loss_counter := loss_counter + 1 ;
16054: LD_ADDR_EXP 15
16058: PUSH
16059: LD_EXP 15
16063: PUSH
16064: LD_INT 1
16066: PLUS
16067: ST_TO_ADDR
// if un = Abdul then
16068: LD_VAR 0 1
16072: PUSH
16073: LD_EXP 58
16077: EQUAL
16078: IFFALSE 16088
// abdul_escaped := false ;
16080: LD_ADDR_EXP 14
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// if un in ru_attackers then
16088: LD_VAR 0 1
16092: PUSH
16093: LD_EXP 55
16097: IN
16098: IFFALSE 16116
// ru_attackers := ru_attackers diff un ;
16100: LD_ADDR_EXP 55
16104: PUSH
16105: LD_EXP 55
16109: PUSH
16110: LD_VAR 0 1
16114: DIFF
16115: ST_TO_ADDR
// if un in ar_attackers then
16116: LD_VAR 0 1
16120: PUSH
16121: LD_EXP 12
16125: IN
16126: IFFALSE 16144
// ar_attackers := ar_attackers diff un ;
16128: LD_ADDR_EXP 12
16132: PUSH
16133: LD_EXP 12
16137: PUSH
16138: LD_VAR 0 1
16142: DIFF
16143: ST_TO_ADDR
// if un = JMM then
16144: LD_VAR 0 1
16148: PUSH
16149: LD_EXP 17
16153: EQUAL
16154: IFFALSE 16165
// begin YouLost ( JMM ) ;
16156: LD_STRING JMM
16158: PPUSH
16159: CALL_OW 104
// exit ;
16163: GO 16262
// end ; if un = Burlak then
16165: LD_VAR 0 1
16169: PUSH
16170: LD_EXP 49
16174: EQUAL
16175: IFFALSE 16186
// begin YouLost ( Burlak ) ;
16177: LD_STRING Burlak
16179: PPUSH
16180: CALL_OW 104
// exit ;
16184: GO 16262
// end ; if un = freedom then
16186: LD_VAR 0 1
16190: PUSH
16191: LD_EXP 3
16195: EQUAL
16196: IFFALSE 16207
// begin YouLost ( Destroyed ) ;
16198: LD_STRING Destroyed
16200: PPUSH
16201: CALL_OW 104
// exit ;
16205: GO 16262
// end ; if un = Masha then
16207: LD_VAR 0 1
16211: PUSH
16212: LD_EXP 52
16216: EQUAL
16217: IFFALSE 16234
// begin ChangeMissionObjectives ( M4b ) ;
16219: LD_STRING M4b
16221: PPUSH
16222: CALL_OW 337
// masha_killed := true ;
16226: LD_ADDR_EXP 11
16230: PUSH
16231: LD_INT 1
16233: ST_TO_ADDR
// end ; if un = Mastodont then
16234: LD_VAR 0 1
16238: PUSH
16239: LD_EXP 59
16243: EQUAL
16244: IFFALSE 16253
// ChangeMissionObjectives ( M4a ) ;
16246: LD_STRING M4a
16248: PPUSH
16249: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
16253: LD_VAR 0 1
16257: PPUSH
16258: CALL 87885 0 1
// end ;
16262: PPOPN 3
16264: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
16265: LD_VAR 0 1
16269: PPUSH
16270: LD_VAR 0 2
16274: PPUSH
16275: CALL 90217 0 2
// end ;
16279: PPOPN 2
16281: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
16282: LD_VAR 0 1
16286: PPUSH
16287: CALL 89285 0 1
// end ;
16291: PPOPN 1
16293: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
16294: LD_VAR 0 1
16298: PUSH
16299: LD_INT 22
16301: PUSH
16302: LD_INT 7
16304: PUSH
16305: EMPTY
16306: LIST
16307: LIST
16308: PUSH
16309: LD_INT 30
16311: PUSH
16312: LD_INT 0
16314: PUSH
16315: EMPTY
16316: LIST
16317: LIST
16318: PUSH
16319: EMPTY
16320: LIST
16321: LIST
16322: PPUSH
16323: CALL_OW 69
16327: IN
16328: IFFALSE 16367
// begin SetBName ( building , freedom ) ;
16330: LD_VAR 0 1
16334: PPUSH
16335: LD_STRING freedom
16337: PPUSH
16338: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
16342: LD_INT 0
16344: PPUSH
16345: LD_INT 7
16347: PPUSH
16348: LD_INT 0
16350: PPUSH
16351: CALL_OW 324
// freedom := building ;
16355: LD_ADDR_EXP 3
16359: PUSH
16360: LD_VAR 0 1
16364: ST_TO_ADDR
// exit ;
16365: GO 16433
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
16367: LD_VAR 0 1
16371: PUSH
16372: LD_INT 22
16374: PUSH
16375: LD_INT 7
16377: PUSH
16378: EMPTY
16379: LIST
16380: LIST
16381: PUSH
16382: LD_INT 23
16384: PUSH
16385: LD_INT 3
16387: PUSH
16388: EMPTY
16389: LIST
16390: LIST
16391: PUSH
16392: LD_INT 30
16394: PUSH
16395: LD_INT 6
16397: PUSH
16398: EMPTY
16399: LIST
16400: LIST
16401: PUSH
16402: EMPTY
16403: LIST
16404: LIST
16405: LIST
16406: PPUSH
16407: CALL_OW 69
16411: IN
16412: IFFALSE 16424
// begin ru_lab_builded := true ;
16414: LD_ADDR_EXP 5
16418: PUSH
16419: LD_INT 1
16421: ST_TO_ADDR
// exit ;
16422: GO 16433
// end ; MCE_BuildingComplete ( building ) ;
16424: LD_VAR 0 1
16428: PPUSH
16429: CALL 89526 0 1
// end ;
16433: PPOPN 1
16435: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
16436: LD_VAR 0 1
16440: PPUSH
16441: LD_VAR 0 2
16445: PPUSH
16446: CALL 87581 0 2
// end ;
16450: PPOPN 2
16452: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
16453: LD_VAR 0 1
16457: PPUSH
16458: LD_VAR 0 2
16462: PPUSH
16463: LD_VAR 0 3
16467: PPUSH
16468: LD_VAR 0 4
16472: PPUSH
16473: LD_VAR 0 5
16477: PPUSH
16478: CALL 87201 0 5
// end ;
16482: PPOPN 5
16484: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
16485: LD_VAR 0 1
16489: PPUSH
16490: LD_VAR 0 2
16494: PPUSH
16495: CALL 106874 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
16499: LD_VAR 0 1
16503: PPUSH
16504: LD_VAR 0 2
16508: PPUSH
16509: CALL 86754 0 2
// end ;
16513: PPOPN 2
16515: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
16516: LD_VAR 0 1
16520: PPUSH
16521: CALL_OW 263
16525: PUSH
16526: LD_INT 3
16528: EQUAL
16529: PUSH
16530: LD_VAR 0 2
16534: PPUSH
16535: CALL_OW 263
16539: PUSH
16540: LD_INT 3
16542: EQUAL
16543: OR
16544: IFFALSE 16560
// hack_counter := hack_counter + 1 ;
16546: LD_ADDR_EXP 16
16550: PUSH
16551: LD_EXP 16
16555: PUSH
16556: LD_INT 1
16558: PLUS
16559: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
16560: LD_VAR 0 1
16564: PPUSH
16565: LD_VAR 0 2
16569: PPUSH
16570: LD_VAR 0 3
16574: PPUSH
16575: LD_VAR 0 4
16579: PPUSH
16580: CALL 86592 0 4
// end ;
16584: PPOPN 4
16586: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin if building = ru_depot then
16587: LD_VAR 0 1
16591: PUSH
16592: LD_INT 47
16594: EQUAL
16595: IFFALSE 16617
// SetResourceType ( GetBase ( building ) , mat_cans , 600 ) ;
16597: LD_VAR 0 1
16601: PPUSH
16602: CALL_OW 274
16606: PPUSH
16607: LD_INT 1
16609: PPUSH
16610: LD_INT 600
16612: PPUSH
16613: CALL_OW 277
// MCE_BuildingCaptured ( building , side , capturning_unit ) ;
16617: LD_VAR 0 1
16621: PPUSH
16622: LD_VAR 0 2
16626: PPUSH
16627: LD_VAR 0 3
16631: PPUSH
16632: CALL 86367 0 3
// end ;
16636: PPOPN 3
16638: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
16639: LD_VAR 0 1
16643: PPUSH
16644: LD_VAR 0 2
16648: PPUSH
16649: CALL 86252 0 2
// end ;
16653: PPOPN 2
16655: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
16656: LD_VAR 0 1
16660: PPUSH
16661: LD_VAR 0 2
16665: PPUSH
16666: CALL 90512 0 2
// end ;
16670: PPOPN 2
16672: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
16673: LD_VAR 0 1
16677: PPUSH
16678: LD_VAR 0 2
16682: PPUSH
16683: LD_VAR 0 3
16687: PPUSH
16688: LD_VAR 0 4
16692: PPUSH
16693: CALL 90728 0 4
// end ;
16697: PPOPN 4
16699: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
16700: LD_VAR 0 1
16704: PPUSH
16705: LD_VAR 0 2
16709: PPUSH
16710: CALL 86061 0 2
// end ;
16714: PPOPN 2
16716: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
16717: LD_VAR 0 1
16721: PPUSH
16722: CALL 106858 0 1
// end ; end_of_file
16726: PPOPN 1
16728: END
// every 0 0$30 do var cr , time ;
16729: GO 16731
16731: DISABLE
16732: LD_INT 0
16734: PPUSH
16735: PPUSH
// begin time := 0 0$20 ;
16736: LD_ADDR_VAR 0 2
16740: PUSH
16741: LD_INT 700
16743: ST_TO_ADDR
// while game do
16744: LD_EXP 2
16748: IFFALSE 16851
// begin wait ( time ) ;
16750: LD_VAR 0 2
16754: PPUSH
16755: CALL_OW 67
// if tick > 2 2$00 then
16759: LD_OWVAR 1
16763: PUSH
16764: LD_INT 4200
16766: GREATER
16767: IFFALSE 16804
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16769: LD_ADDR_VAR 0 2
16773: PUSH
16774: LD_VAR 0 2
16778: PUSH
16779: LD_INT 140
16781: PUSH
16782: LD_INT 140
16784: PUSH
16785: LD_INT 210
16787: PUSH
16788: LD_INT 280
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: LIST
16795: LIST
16796: PUSH
16797: LD_OWVAR 67
16801: ARRAY
16802: PLUS
16803: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
16804: LD_INT 1
16806: PPUSH
16807: LD_INT 5
16809: PPUSH
16810: CALL_OW 12
16814: PPUSH
16815: LD_INT 70
16817: PPUSH
16818: LD_INT 49
16820: PPUSH
16821: LD_INT 25
16823: PPUSH
16824: LD_INT 1
16826: PPUSH
16827: CALL_OW 56
// if time > 3 3$00 then
16831: LD_VAR 0 2
16835: PUSH
16836: LD_INT 6300
16838: GREATER
16839: IFFALSE 16849
// time := 0 0$30 ;
16841: LD_ADDR_VAR 0 2
16845: PUSH
16846: LD_INT 1050
16848: ST_TO_ADDR
// end ;
16849: GO 16744
// end ;
16851: PPOPN 2
16853: END
// every 0 0$30 do var cr , time ;
16854: GO 16856
16856: DISABLE
16857: LD_INT 0
16859: PPUSH
16860: PPUSH
// begin time := 0 0$20 ;
16861: LD_ADDR_VAR 0 2
16865: PUSH
16866: LD_INT 700
16868: ST_TO_ADDR
// while game do
16869: LD_EXP 2
16873: IFFALSE 16966
// begin wait ( time ) ;
16875: LD_VAR 0 2
16879: PPUSH
16880: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
16884: LD_ADDR_VAR 0 2
16888: PUSH
16889: LD_VAR 0 2
16893: PUSH
16894: LD_INT 140
16896: PUSH
16897: LD_INT 175
16899: PUSH
16900: LD_INT 210
16902: PUSH
16903: LD_INT 280
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: LIST
16910: LIST
16911: PUSH
16912: LD_OWVAR 67
16916: ARRAY
16917: PLUS
16918: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
16919: LD_INT 3
16921: PPUSH
16922: LD_INT 5
16924: PPUSH
16925: CALL_OW 12
16929: PPUSH
16930: LD_INT 26
16932: PPUSH
16933: LD_INT 9
16935: PPUSH
16936: LD_INT 30
16938: PPUSH
16939: LD_INT 1
16941: PPUSH
16942: CALL_OW 56
// if time > 3 3$00 then
16946: LD_VAR 0 2
16950: PUSH
16951: LD_INT 6300
16953: GREATER
16954: IFFALSE 16964
// time := 0 0$20 ;
16956: LD_ADDR_VAR 0 2
16960: PUSH
16961: LD_INT 700
16963: ST_TO_ADDR
// end ;
16964: GO 16869
// end ;
16966: PPOPN 2
16968: END
// every 0 0$30 do var cr , time ;
16969: GO 16971
16971: DISABLE
16972: LD_INT 0
16974: PPUSH
16975: PPUSH
// begin time := 0 0$20 ;
16976: LD_ADDR_VAR 0 2
16980: PUSH
16981: LD_INT 700
16983: ST_TO_ADDR
// while game do
16984: LD_EXP 2
16988: IFFALSE 17117
// begin wait ( time ) ;
16990: LD_VAR 0 2
16994: PPUSH
16995: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
16999: LD_ADDR_VAR 0 2
17003: PUSH
17004: LD_VAR 0 2
17008: PUSH
17009: LD_INT 175
17011: PUSH
17012: LD_INT 210
17014: PUSH
17015: LD_INT 280
17017: PUSH
17018: LD_INT 350
17020: PUSH
17021: EMPTY
17022: LIST
17023: LIST
17024: LIST
17025: LIST
17026: PUSH
17027: LD_OWVAR 67
17031: ARRAY
17032: PLUS
17033: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
17034: LD_INT 1
17036: PPUSH
17037: LD_INT 5
17039: PPUSH
17040: CALL_OW 12
17044: PPUSH
17045: LD_INT 179
17047: PPUSH
17048: LD_INT 101
17050: PPUSH
17051: LD_INT 20
17053: PPUSH
17054: LD_INT 1
17056: PPUSH
17057: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
17061: LD_INT 350
17063: PPUSH
17064: LD_INT 525
17066: PPUSH
17067: CALL_OW 12
17071: PPUSH
17072: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
17076: LD_INT 1
17078: PPUSH
17079: LD_INT 5
17081: PPUSH
17082: CALL_OW 12
17086: PPUSH
17087: LD_INT 9
17089: PPUSH
17090: LD_INT 1
17092: PPUSH
17093: CALL_OW 55
// if time > 4 4$00 then
17097: LD_VAR 0 2
17101: PUSH
17102: LD_INT 8400
17104: GREATER
17105: IFFALSE 17115
// time := 0 0$30 ;
17107: LD_ADDR_VAR 0 2
17111: PUSH
17112: LD_INT 1050
17114: ST_TO_ADDR
// end ;
17115: GO 16984
// end ;
17117: PPOPN 2
17119: END
// every 0 0$30 do var cr , time ;
17120: GO 17122
17122: DISABLE
17123: LD_INT 0
17125: PPUSH
17126: PPUSH
// begin time := 0 0$10 ;
17127: LD_ADDR_VAR 0 2
17131: PUSH
17132: LD_INT 350
17134: ST_TO_ADDR
// while game do
17135: LD_EXP 2
17139: IFFALSE 17273
// begin wait ( time ) ;
17141: LD_VAR 0 2
17145: PPUSH
17146: CALL_OW 67
// time := time + 0 0$10 ;
17150: LD_ADDR_VAR 0 2
17154: PUSH
17155: LD_VAR 0 2
17159: PUSH
17160: LD_INT 350
17162: PLUS
17163: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
17164: LD_INT 1
17166: PPUSH
17167: LD_INT 5
17169: PPUSH
17170: CALL_OW 12
17174: PPUSH
17175: LD_INT 11
17177: PPUSH
17178: LD_INT 1
17180: PPUSH
17181: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
17185: LD_ADDR_VAR 0 1
17189: PUSH
17190: LD_INT 1
17192: PPUSH
17193: LD_INT 3
17195: PPUSH
17196: CALL_OW 12
17200: ST_TO_ADDR
// if cr = 1 then
17201: LD_VAR 0 1
17205: PUSH
17206: LD_INT 1
17208: EQUAL
17209: IFFALSE 17253
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
17211: LD_INT 700
17213: PPUSH
17214: LD_INT 1575
17216: PPUSH
17217: CALL_OW 12
17221: PPUSH
17222: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
17226: LD_INT 1
17228: PPUSH
17229: LD_INT 5
17231: PPUSH
17232: CALL_OW 12
17236: PPUSH
17237: LD_INT 34
17239: PPUSH
17240: LD_INT 50
17242: PPUSH
17243: LD_INT 7
17245: PPUSH
17246: LD_INT 1
17248: PPUSH
17249: CALL_OW 56
// end ; if time > 4 4$00 then
17253: LD_VAR 0 2
17257: PUSH
17258: LD_INT 8400
17260: GREATER
17261: IFFALSE 17271
// time := 0 0$40 ;
17263: LD_ADDR_VAR 0 2
17267: PUSH
17268: LD_INT 1400
17270: ST_TO_ADDR
// end ;
17271: GO 17135
// end ; end_of_file
17273: PPOPN 2
17275: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
17276: LD_INT 0
17278: PPUSH
17279: PPUSH
// if exist_mode then
17280: LD_VAR 0 2
17284: IFFALSE 17330
// begin unit := CreateCharacter ( prefix & ident ) ;
17286: LD_ADDR_VAR 0 5
17290: PUSH
17291: LD_VAR 0 3
17295: PUSH
17296: LD_VAR 0 1
17300: STR
17301: PPUSH
17302: CALL_OW 34
17306: ST_TO_ADDR
// if unit then
17307: LD_VAR 0 5
17311: IFFALSE 17328
// DeleteCharacters ( prefix & ident ) ;
17313: LD_VAR 0 3
17317: PUSH
17318: LD_VAR 0 1
17322: STR
17323: PPUSH
17324: CALL_OW 40
// end else
17328: GO 17345
// unit := NewCharacter ( ident ) ;
17330: LD_ADDR_VAR 0 5
17334: PUSH
17335: LD_VAR 0 1
17339: PPUSH
17340: CALL_OW 25
17344: ST_TO_ADDR
// result := unit ;
17345: LD_ADDR_VAR 0 4
17349: PUSH
17350: LD_VAR 0 5
17354: ST_TO_ADDR
// end ;
17355: LD_VAR 0 4
17359: RET
// export function PrepareUnitForce ( ident , exist_mode , prefix ) ; var unit ; begin
17360: LD_INT 0
17362: PPUSH
17363: PPUSH
// if exist_mode then
17364: LD_VAR 0 2
17368: IFFALSE 17393
// unit := CreateCharacter ( prefix & ident ) else
17370: LD_ADDR_VAR 0 5
17374: PUSH
17375: LD_VAR 0 3
17379: PUSH
17380: LD_VAR 0 1
17384: STR
17385: PPUSH
17386: CALL_OW 34
17390: ST_TO_ADDR
17391: GO 17408
// unit := NewCharacter ( ident ) ;
17393: LD_ADDR_VAR 0 5
17397: PUSH
17398: LD_VAR 0 1
17402: PPUSH
17403: CALL_OW 25
17407: ST_TO_ADDR
// result := unit ;
17408: LD_ADDR_VAR 0 4
17412: PUSH
17413: LD_VAR 0 5
17417: ST_TO_ADDR
// end ;
17418: LD_VAR 0 4
17422: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
17423: LD_INT 0
17425: PPUSH
17426: PPUSH
// if not side or not nation then
17427: LD_VAR 0 1
17431: NOT
17432: PUSH
17433: LD_VAR 0 2
17437: NOT
17438: OR
17439: IFFALSE 17443
// exit ;
17441: GO 18211
// case nation of nation_american :
17443: LD_VAR 0 2
17447: PUSH
17448: LD_INT 1
17450: DOUBLE
17451: EQUAL
17452: IFTRUE 17456
17454: GO 17670
17456: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
17457: LD_ADDR_VAR 0 4
17461: PUSH
17462: LD_INT 35
17464: PUSH
17465: LD_INT 45
17467: PUSH
17468: LD_INT 46
17470: PUSH
17471: LD_INT 47
17473: PUSH
17474: LD_INT 82
17476: PUSH
17477: LD_INT 83
17479: PUSH
17480: LD_INT 84
17482: PUSH
17483: LD_INT 85
17485: PUSH
17486: LD_INT 86
17488: PUSH
17489: LD_INT 1
17491: PUSH
17492: LD_INT 2
17494: PUSH
17495: LD_INT 6
17497: PUSH
17498: LD_INT 15
17500: PUSH
17501: LD_INT 16
17503: PUSH
17504: LD_INT 7
17506: PUSH
17507: LD_INT 12
17509: PUSH
17510: LD_INT 13
17512: PUSH
17513: LD_INT 10
17515: PUSH
17516: LD_INT 14
17518: PUSH
17519: LD_INT 20
17521: PUSH
17522: LD_INT 21
17524: PUSH
17525: LD_INT 22
17527: PUSH
17528: LD_INT 25
17530: PUSH
17531: LD_INT 32
17533: PUSH
17534: LD_INT 27
17536: PUSH
17537: LD_INT 36
17539: PUSH
17540: LD_INT 69
17542: PUSH
17543: LD_INT 39
17545: PUSH
17546: LD_INT 34
17548: PUSH
17549: LD_INT 40
17551: PUSH
17552: LD_INT 48
17554: PUSH
17555: LD_INT 49
17557: PUSH
17558: LD_INT 50
17560: PUSH
17561: LD_INT 51
17563: PUSH
17564: LD_INT 52
17566: PUSH
17567: LD_INT 53
17569: PUSH
17570: LD_INT 54
17572: PUSH
17573: LD_INT 55
17575: PUSH
17576: LD_INT 56
17578: PUSH
17579: LD_INT 57
17581: PUSH
17582: LD_INT 58
17584: PUSH
17585: LD_INT 59
17587: PUSH
17588: LD_INT 60
17590: PUSH
17591: LD_INT 61
17593: PUSH
17594: LD_INT 62
17596: PUSH
17597: LD_INT 80
17599: PUSH
17600: LD_INT 82
17602: PUSH
17603: LD_INT 83
17605: PUSH
17606: LD_INT 84
17608: PUSH
17609: LD_INT 85
17611: PUSH
17612: LD_INT 86
17614: PUSH
17615: EMPTY
17616: LIST
17617: LIST
17618: LIST
17619: LIST
17620: LIST
17621: LIST
17622: LIST
17623: LIST
17624: LIST
17625: LIST
17626: LIST
17627: LIST
17628: LIST
17629: LIST
17630: LIST
17631: LIST
17632: LIST
17633: LIST
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: LIST
17639: LIST
17640: LIST
17641: LIST
17642: LIST
17643: LIST
17644: LIST
17645: LIST
17646: LIST
17647: LIST
17648: LIST
17649: LIST
17650: LIST
17651: LIST
17652: LIST
17653: LIST
17654: LIST
17655: LIST
17656: LIST
17657: LIST
17658: LIST
17659: LIST
17660: LIST
17661: LIST
17662: LIST
17663: LIST
17664: LIST
17665: LIST
17666: LIST
17667: ST_TO_ADDR
17668: GO 18135
17670: LD_INT 2
17672: DOUBLE
17673: EQUAL
17674: IFTRUE 17678
17676: GO 17904
17678: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
17679: LD_ADDR_VAR 0 4
17683: PUSH
17684: LD_INT 35
17686: PUSH
17687: LD_INT 45
17689: PUSH
17690: LD_INT 46
17692: PUSH
17693: LD_INT 47
17695: PUSH
17696: LD_INT 82
17698: PUSH
17699: LD_INT 83
17701: PUSH
17702: LD_INT 84
17704: PUSH
17705: LD_INT 85
17707: PUSH
17708: LD_INT 87
17710: PUSH
17711: LD_INT 70
17713: PUSH
17714: LD_INT 1
17716: PUSH
17717: LD_INT 11
17719: PUSH
17720: LD_INT 3
17722: PUSH
17723: LD_INT 4
17725: PUSH
17726: LD_INT 5
17728: PUSH
17729: LD_INT 6
17731: PUSH
17732: LD_INT 15
17734: PUSH
17735: LD_INT 18
17737: PUSH
17738: LD_INT 7
17740: PUSH
17741: LD_INT 17
17743: PUSH
17744: LD_INT 8
17746: PUSH
17747: LD_INT 20
17749: PUSH
17750: LD_INT 21
17752: PUSH
17753: LD_INT 22
17755: PUSH
17756: LD_INT 72
17758: PUSH
17759: LD_INT 26
17761: PUSH
17762: LD_INT 69
17764: PUSH
17765: LD_INT 39
17767: PUSH
17768: LD_INT 40
17770: PUSH
17771: LD_INT 41
17773: PUSH
17774: LD_INT 42
17776: PUSH
17777: LD_INT 43
17779: PUSH
17780: LD_INT 48
17782: PUSH
17783: LD_INT 49
17785: PUSH
17786: LD_INT 50
17788: PUSH
17789: LD_INT 51
17791: PUSH
17792: LD_INT 52
17794: PUSH
17795: LD_INT 53
17797: PUSH
17798: LD_INT 54
17800: PUSH
17801: LD_INT 55
17803: PUSH
17804: LD_INT 56
17806: PUSH
17807: LD_INT 60
17809: PUSH
17810: LD_INT 61
17812: PUSH
17813: LD_INT 62
17815: PUSH
17816: LD_INT 66
17818: PUSH
17819: LD_INT 67
17821: PUSH
17822: LD_INT 68
17824: PUSH
17825: LD_INT 81
17827: PUSH
17828: LD_INT 82
17830: PUSH
17831: LD_INT 83
17833: PUSH
17834: LD_INT 84
17836: PUSH
17837: LD_INT 85
17839: PUSH
17840: LD_INT 87
17842: PUSH
17843: LD_INT 88
17845: PUSH
17846: EMPTY
17847: LIST
17848: LIST
17849: LIST
17850: LIST
17851: LIST
17852: LIST
17853: LIST
17854: LIST
17855: LIST
17856: LIST
17857: LIST
17858: LIST
17859: LIST
17860: LIST
17861: LIST
17862: LIST
17863: LIST
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: LIST
17869: LIST
17870: LIST
17871: LIST
17872: LIST
17873: LIST
17874: LIST
17875: LIST
17876: LIST
17877: LIST
17878: LIST
17879: LIST
17880: LIST
17881: LIST
17882: LIST
17883: LIST
17884: LIST
17885: LIST
17886: LIST
17887: LIST
17888: LIST
17889: LIST
17890: LIST
17891: LIST
17892: LIST
17893: LIST
17894: LIST
17895: LIST
17896: LIST
17897: LIST
17898: LIST
17899: LIST
17900: LIST
17901: ST_TO_ADDR
17902: GO 18135
17904: LD_INT 3
17906: DOUBLE
17907: EQUAL
17908: IFTRUE 17912
17910: GO 18134
17912: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
17913: LD_ADDR_VAR 0 4
17917: PUSH
17918: LD_INT 46
17920: PUSH
17921: LD_INT 47
17923: PUSH
17924: LD_INT 1
17926: PUSH
17927: LD_INT 2
17929: PUSH
17930: LD_INT 82
17932: PUSH
17933: LD_INT 83
17935: PUSH
17936: LD_INT 84
17938: PUSH
17939: LD_INT 85
17941: PUSH
17942: LD_INT 86
17944: PUSH
17945: LD_INT 11
17947: PUSH
17948: LD_INT 9
17950: PUSH
17951: LD_INT 20
17953: PUSH
17954: LD_INT 19
17956: PUSH
17957: LD_INT 21
17959: PUSH
17960: LD_INT 24
17962: PUSH
17963: LD_INT 22
17965: PUSH
17966: LD_INT 25
17968: PUSH
17969: LD_INT 28
17971: PUSH
17972: LD_INT 29
17974: PUSH
17975: LD_INT 30
17977: PUSH
17978: LD_INT 31
17980: PUSH
17981: LD_INT 37
17983: PUSH
17984: LD_INT 38
17986: PUSH
17987: LD_INT 32
17989: PUSH
17990: LD_INT 27
17992: PUSH
17993: LD_INT 33
17995: PUSH
17996: LD_INT 69
17998: PUSH
17999: LD_INT 39
18001: PUSH
18002: LD_INT 34
18004: PUSH
18005: LD_INT 40
18007: PUSH
18008: LD_INT 71
18010: PUSH
18011: LD_INT 23
18013: PUSH
18014: LD_INT 44
18016: PUSH
18017: LD_INT 48
18019: PUSH
18020: LD_INT 49
18022: PUSH
18023: LD_INT 50
18025: PUSH
18026: LD_INT 51
18028: PUSH
18029: LD_INT 52
18031: PUSH
18032: LD_INT 53
18034: PUSH
18035: LD_INT 54
18037: PUSH
18038: LD_INT 55
18040: PUSH
18041: LD_INT 56
18043: PUSH
18044: LD_INT 57
18046: PUSH
18047: LD_INT 58
18049: PUSH
18050: LD_INT 59
18052: PUSH
18053: LD_INT 63
18055: PUSH
18056: LD_INT 64
18058: PUSH
18059: LD_INT 65
18061: PUSH
18062: LD_INT 82
18064: PUSH
18065: LD_INT 83
18067: PUSH
18068: LD_INT 84
18070: PUSH
18071: LD_INT 85
18073: PUSH
18074: LD_INT 86
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: LIST
18083: LIST
18084: LIST
18085: LIST
18086: LIST
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: LIST
18092: LIST
18093: LIST
18094: LIST
18095: LIST
18096: LIST
18097: LIST
18098: LIST
18099: LIST
18100: LIST
18101: LIST
18102: LIST
18103: LIST
18104: LIST
18105: LIST
18106: LIST
18107: LIST
18108: LIST
18109: LIST
18110: LIST
18111: LIST
18112: LIST
18113: LIST
18114: LIST
18115: LIST
18116: LIST
18117: LIST
18118: LIST
18119: LIST
18120: LIST
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: LIST
18126: LIST
18127: LIST
18128: LIST
18129: LIST
18130: LIST
18131: ST_TO_ADDR
18132: GO 18135
18134: POP
// if state > - 1 and state < 3 then
18135: LD_VAR 0 3
18139: PUSH
18140: LD_INT 1
18142: NEG
18143: GREATER
18144: PUSH
18145: LD_VAR 0 3
18149: PUSH
18150: LD_INT 3
18152: LESS
18153: AND
18154: IFFALSE 18211
// for i in result do
18156: LD_ADDR_VAR 0 5
18160: PUSH
18161: LD_VAR 0 4
18165: PUSH
18166: FOR_IN
18167: IFFALSE 18209
// if GetTech ( i , side ) <> state then
18169: LD_VAR 0 5
18173: PPUSH
18174: LD_VAR 0 1
18178: PPUSH
18179: CALL_OW 321
18183: PUSH
18184: LD_VAR 0 3
18188: NONEQUAL
18189: IFFALSE 18207
// result := result diff i ;
18191: LD_ADDR_VAR 0 4
18195: PUSH
18196: LD_VAR 0 4
18200: PUSH
18201: LD_VAR 0 5
18205: DIFF
18206: ST_TO_ADDR
18207: GO 18166
18209: POP
18210: POP
// end ;
18211: LD_VAR 0 4
18215: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
18216: LD_INT 0
18218: PPUSH
18219: PPUSH
18220: PPUSH
// result := true ;
18221: LD_ADDR_VAR 0 3
18225: PUSH
18226: LD_INT 1
18228: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
18229: LD_ADDR_VAR 0 5
18233: PUSH
18234: LD_VAR 0 2
18238: PPUSH
18239: CALL_OW 480
18243: ST_TO_ADDR
// if not tmp then
18244: LD_VAR 0 5
18248: NOT
18249: IFFALSE 18253
// exit ;
18251: GO 18302
// for i in tmp do
18253: LD_ADDR_VAR 0 4
18257: PUSH
18258: LD_VAR 0 5
18262: PUSH
18263: FOR_IN
18264: IFFALSE 18300
// if GetTech ( i , side ) <> state_researched then
18266: LD_VAR 0 4
18270: PPUSH
18271: LD_VAR 0 1
18275: PPUSH
18276: CALL_OW 321
18280: PUSH
18281: LD_INT 2
18283: NONEQUAL
18284: IFFALSE 18298
// begin result := false ;
18286: LD_ADDR_VAR 0 3
18290: PUSH
18291: LD_INT 0
18293: ST_TO_ADDR
// exit ;
18294: POP
18295: POP
18296: GO 18302
// end ;
18298: GO 18263
18300: POP
18301: POP
// end ;
18302: LD_VAR 0 3
18306: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
18307: LD_INT 0
18309: PPUSH
18310: PPUSH
18311: PPUSH
18312: PPUSH
18313: PPUSH
18314: PPUSH
18315: PPUSH
18316: PPUSH
18317: PPUSH
18318: PPUSH
18319: PPUSH
18320: PPUSH
18321: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
18322: LD_VAR 0 1
18326: NOT
18327: PUSH
18328: LD_VAR 0 1
18332: PPUSH
18333: CALL_OW 257
18337: PUSH
18338: LD_INT 9
18340: NONEQUAL
18341: OR
18342: IFFALSE 18346
// exit ;
18344: GO 18919
// side := GetSide ( unit ) ;
18346: LD_ADDR_VAR 0 9
18350: PUSH
18351: LD_VAR 0 1
18355: PPUSH
18356: CALL_OW 255
18360: ST_TO_ADDR
// tech_space := tech_spacanom ;
18361: LD_ADDR_VAR 0 12
18365: PUSH
18366: LD_INT 29
18368: ST_TO_ADDR
// tech_time := tech_taurad ;
18369: LD_ADDR_VAR 0 13
18373: PUSH
18374: LD_INT 28
18376: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
18377: LD_ADDR_VAR 0 11
18381: PUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: CALL_OW 310
18391: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
18392: LD_VAR 0 11
18396: PPUSH
18397: CALL_OW 247
18401: PUSH
18402: LD_INT 2
18404: EQUAL
18405: IFFALSE 18409
// exit ;
18407: GO 18919
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18409: LD_ADDR_VAR 0 8
18413: PUSH
18414: LD_INT 81
18416: PUSH
18417: LD_VAR 0 9
18421: PUSH
18422: EMPTY
18423: LIST
18424: LIST
18425: PUSH
18426: LD_INT 3
18428: PUSH
18429: LD_INT 21
18431: PUSH
18432: LD_INT 3
18434: PUSH
18435: EMPTY
18436: LIST
18437: LIST
18438: PUSH
18439: EMPTY
18440: LIST
18441: LIST
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PPUSH
18447: CALL_OW 69
18451: ST_TO_ADDR
// if not tmp then
18452: LD_VAR 0 8
18456: NOT
18457: IFFALSE 18461
// exit ;
18459: GO 18919
// if in_unit then
18461: LD_VAR 0 11
18465: IFFALSE 18489
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
18467: LD_ADDR_VAR 0 10
18471: PUSH
18472: LD_VAR 0 8
18476: PPUSH
18477: LD_VAR 0 11
18481: PPUSH
18482: CALL_OW 74
18486: ST_TO_ADDR
18487: GO 18509
// enemy := NearestUnitToUnit ( tmp , unit ) ;
18489: LD_ADDR_VAR 0 10
18493: PUSH
18494: LD_VAR 0 8
18498: PPUSH
18499: LD_VAR 0 1
18503: PPUSH
18504: CALL_OW 74
18508: ST_TO_ADDR
// if not enemy then
18509: LD_VAR 0 10
18513: NOT
18514: IFFALSE 18518
// exit ;
18516: GO 18919
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
18518: LD_VAR 0 11
18522: PUSH
18523: LD_VAR 0 11
18527: PPUSH
18528: LD_VAR 0 10
18532: PPUSH
18533: CALL_OW 296
18537: PUSH
18538: LD_INT 13
18540: GREATER
18541: AND
18542: PUSH
18543: LD_VAR 0 1
18547: PPUSH
18548: LD_VAR 0 10
18552: PPUSH
18553: CALL_OW 296
18557: PUSH
18558: LD_INT 12
18560: GREATER
18561: OR
18562: IFFALSE 18566
// exit ;
18564: GO 18919
// missile := [ 1 ] ;
18566: LD_ADDR_VAR 0 14
18570: PUSH
18571: LD_INT 1
18573: PUSH
18574: EMPTY
18575: LIST
18576: ST_TO_ADDR
// if Researched ( side , tech_space ) then
18577: LD_VAR 0 9
18581: PPUSH
18582: LD_VAR 0 12
18586: PPUSH
18587: CALL_OW 325
18591: IFFALSE 18620
// missile := Replace ( missile , missile + 1 , 2 ) ;
18593: LD_ADDR_VAR 0 14
18597: PUSH
18598: LD_VAR 0 14
18602: PPUSH
18603: LD_VAR 0 14
18607: PUSH
18608: LD_INT 1
18610: PLUS
18611: PPUSH
18612: LD_INT 2
18614: PPUSH
18615: CALL_OW 1
18619: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
18620: LD_VAR 0 9
18624: PPUSH
18625: LD_VAR 0 13
18629: PPUSH
18630: CALL_OW 325
18634: PUSH
18635: LD_VAR 0 10
18639: PPUSH
18640: CALL_OW 255
18644: PPUSH
18645: LD_VAR 0 13
18649: PPUSH
18650: CALL_OW 325
18654: NOT
18655: AND
18656: IFFALSE 18685
// missile := Replace ( missile , missile + 1 , 3 ) ;
18658: LD_ADDR_VAR 0 14
18662: PUSH
18663: LD_VAR 0 14
18667: PPUSH
18668: LD_VAR 0 14
18672: PUSH
18673: LD_INT 1
18675: PLUS
18676: PPUSH
18677: LD_INT 3
18679: PPUSH
18680: CALL_OW 1
18684: ST_TO_ADDR
// if missile < 2 then
18685: LD_VAR 0 14
18689: PUSH
18690: LD_INT 2
18692: LESS
18693: IFFALSE 18697
// exit ;
18695: GO 18919
// x := GetX ( enemy ) ;
18697: LD_ADDR_VAR 0 4
18701: PUSH
18702: LD_VAR 0 10
18706: PPUSH
18707: CALL_OW 250
18711: ST_TO_ADDR
// y := GetY ( enemy ) ;
18712: LD_ADDR_VAR 0 5
18716: PUSH
18717: LD_VAR 0 10
18721: PPUSH
18722: CALL_OW 251
18726: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
18727: LD_ADDR_VAR 0 6
18731: PUSH
18732: LD_VAR 0 4
18736: PUSH
18737: LD_INT 1
18739: NEG
18740: PPUSH
18741: LD_INT 1
18743: PPUSH
18744: CALL_OW 12
18748: PLUS
18749: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
18750: LD_ADDR_VAR 0 7
18754: PUSH
18755: LD_VAR 0 5
18759: PUSH
18760: LD_INT 1
18762: NEG
18763: PPUSH
18764: LD_INT 1
18766: PPUSH
18767: CALL_OW 12
18771: PLUS
18772: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
18773: LD_VAR 0 6
18777: PPUSH
18778: LD_VAR 0 7
18782: PPUSH
18783: CALL_OW 488
18787: NOT
18788: IFFALSE 18810
// begin _x := x ;
18790: LD_ADDR_VAR 0 6
18794: PUSH
18795: LD_VAR 0 4
18799: ST_TO_ADDR
// _y := y ;
18800: LD_ADDR_VAR 0 7
18804: PUSH
18805: LD_VAR 0 5
18809: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
18810: LD_ADDR_VAR 0 3
18814: PUSH
18815: LD_INT 1
18817: PPUSH
18818: LD_VAR 0 14
18822: PPUSH
18823: CALL_OW 12
18827: ST_TO_ADDR
// case i of 1 :
18828: LD_VAR 0 3
18832: PUSH
18833: LD_INT 1
18835: DOUBLE
18836: EQUAL
18837: IFTRUE 18841
18839: GO 18858
18841: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
18842: LD_VAR 0 1
18846: PPUSH
18847: LD_VAR 0 10
18851: PPUSH
18852: CALL_OW 115
18856: GO 18919
18858: LD_INT 2
18860: DOUBLE
18861: EQUAL
18862: IFTRUE 18866
18864: GO 18888
18866: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
18867: LD_VAR 0 1
18871: PPUSH
18872: LD_VAR 0 6
18876: PPUSH
18877: LD_VAR 0 7
18881: PPUSH
18882: CALL_OW 153
18886: GO 18919
18888: LD_INT 3
18890: DOUBLE
18891: EQUAL
18892: IFTRUE 18896
18894: GO 18918
18896: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
18897: LD_VAR 0 1
18901: PPUSH
18902: LD_VAR 0 6
18906: PPUSH
18907: LD_VAR 0 7
18911: PPUSH
18912: CALL_OW 154
18916: GO 18919
18918: POP
// end ;
18919: LD_VAR 0 2
18923: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
18924: LD_INT 0
18926: PPUSH
18927: PPUSH
18928: PPUSH
18929: PPUSH
18930: PPUSH
18931: PPUSH
// if not unit or not building then
18932: LD_VAR 0 1
18936: NOT
18937: PUSH
18938: LD_VAR 0 2
18942: NOT
18943: OR
18944: IFFALSE 18948
// exit ;
18946: GO 19106
// x := GetX ( building ) ;
18948: LD_ADDR_VAR 0 5
18952: PUSH
18953: LD_VAR 0 2
18957: PPUSH
18958: CALL_OW 250
18962: ST_TO_ADDR
// y := GetY ( building ) ;
18963: LD_ADDR_VAR 0 6
18967: PUSH
18968: LD_VAR 0 2
18972: PPUSH
18973: CALL_OW 251
18977: ST_TO_ADDR
// for i = 0 to 5 do
18978: LD_ADDR_VAR 0 4
18982: PUSH
18983: DOUBLE
18984: LD_INT 0
18986: DEC
18987: ST_TO_ADDR
18988: LD_INT 5
18990: PUSH
18991: FOR_TO
18992: IFFALSE 19104
// begin _x := ShiftX ( x , i , 3 ) ;
18994: LD_ADDR_VAR 0 7
18998: PUSH
18999: LD_VAR 0 5
19003: PPUSH
19004: LD_VAR 0 4
19008: PPUSH
19009: LD_INT 3
19011: PPUSH
19012: CALL_OW 272
19016: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
19017: LD_ADDR_VAR 0 8
19021: PUSH
19022: LD_VAR 0 6
19026: PPUSH
19027: LD_VAR 0 4
19031: PPUSH
19032: LD_INT 3
19034: PPUSH
19035: CALL_OW 273
19039: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
19040: LD_VAR 0 7
19044: PPUSH
19045: LD_VAR 0 8
19049: PPUSH
19050: CALL_OW 488
19054: NOT
19055: IFFALSE 19059
// continue ;
19057: GO 18991
// if HexInfo ( _x , _y ) = 0 then
19059: LD_VAR 0 7
19063: PPUSH
19064: LD_VAR 0 8
19068: PPUSH
19069: CALL_OW 428
19073: PUSH
19074: LD_INT 0
19076: EQUAL
19077: IFFALSE 19102
// begin ComMoveXY ( unit , _x , _y ) ;
19079: LD_VAR 0 1
19083: PPUSH
19084: LD_VAR 0 7
19088: PPUSH
19089: LD_VAR 0 8
19093: PPUSH
19094: CALL_OW 111
// exit ;
19098: POP
19099: POP
19100: GO 19106
// end ; end ;
19102: GO 18991
19104: POP
19105: POP
// end ;
19106: LD_VAR 0 3
19110: RET
// export function ScanBase ( side , base_area ) ; begin
19111: LD_INT 0
19113: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_VAR 0 2
19123: PPUSH
19124: LD_INT 81
19126: PUSH
19127: LD_VAR 0 1
19131: PUSH
19132: EMPTY
19133: LIST
19134: LIST
19135: PPUSH
19136: CALL_OW 70
19140: ST_TO_ADDR
// end ;
19141: LD_VAR 0 3
19145: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
19146: LD_INT 0
19148: PPUSH
19149: PPUSH
19150: PPUSH
19151: PPUSH
// result := false ;
19152: LD_ADDR_VAR 0 2
19156: PUSH
19157: LD_INT 0
19159: ST_TO_ADDR
// side := GetSide ( unit ) ;
19160: LD_ADDR_VAR 0 3
19164: PUSH
19165: LD_VAR 0 1
19169: PPUSH
19170: CALL_OW 255
19174: ST_TO_ADDR
// nat := GetNation ( unit ) ;
19175: LD_ADDR_VAR 0 4
19179: PUSH
19180: LD_VAR 0 1
19184: PPUSH
19185: CALL_OW 248
19189: ST_TO_ADDR
// case nat of 1 :
19190: LD_VAR 0 4
19194: PUSH
19195: LD_INT 1
19197: DOUBLE
19198: EQUAL
19199: IFTRUE 19203
19201: GO 19214
19203: POP
// tech := tech_lassight ; 2 :
19204: LD_ADDR_VAR 0 5
19208: PUSH
19209: LD_INT 12
19211: ST_TO_ADDR
19212: GO 19253
19214: LD_INT 2
19216: DOUBLE
19217: EQUAL
19218: IFTRUE 19222
19220: GO 19233
19222: POP
// tech := tech_mortar ; 3 :
19223: LD_ADDR_VAR 0 5
19227: PUSH
19228: LD_INT 41
19230: ST_TO_ADDR
19231: GO 19253
19233: LD_INT 3
19235: DOUBLE
19236: EQUAL
19237: IFTRUE 19241
19239: GO 19252
19241: POP
// tech := tech_bazooka ; end ;
19242: LD_ADDR_VAR 0 5
19246: PUSH
19247: LD_INT 44
19249: ST_TO_ADDR
19250: GO 19253
19252: POP
// if Researched ( side , tech ) then
19253: LD_VAR 0 3
19257: PPUSH
19258: LD_VAR 0 5
19262: PPUSH
19263: CALL_OW 325
19267: IFFALSE 19294
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
19269: LD_ADDR_VAR 0 2
19273: PUSH
19274: LD_INT 5
19276: PUSH
19277: LD_INT 8
19279: PUSH
19280: LD_INT 9
19282: PUSH
19283: EMPTY
19284: LIST
19285: LIST
19286: LIST
19287: PUSH
19288: LD_VAR 0 4
19292: ARRAY
19293: ST_TO_ADDR
// end ;
19294: LD_VAR 0 2
19298: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
19299: LD_INT 0
19301: PPUSH
19302: PPUSH
19303: PPUSH
// if not mines then
19304: LD_VAR 0 2
19308: NOT
19309: IFFALSE 19313
// exit ;
19311: GO 19457
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
19313: LD_ADDR_VAR 0 5
19317: PUSH
19318: LD_INT 81
19320: PUSH
19321: LD_VAR 0 1
19325: PUSH
19326: EMPTY
19327: LIST
19328: LIST
19329: PUSH
19330: LD_INT 3
19332: PUSH
19333: LD_INT 21
19335: PUSH
19336: LD_INT 3
19338: PUSH
19339: EMPTY
19340: LIST
19341: LIST
19342: PUSH
19343: EMPTY
19344: LIST
19345: LIST
19346: PUSH
19347: EMPTY
19348: LIST
19349: LIST
19350: PPUSH
19351: CALL_OW 69
19355: ST_TO_ADDR
// for i in mines do
19356: LD_ADDR_VAR 0 4
19360: PUSH
19361: LD_VAR 0 2
19365: PUSH
19366: FOR_IN
19367: IFFALSE 19455
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
19369: LD_VAR 0 4
19373: PUSH
19374: LD_INT 1
19376: ARRAY
19377: PPUSH
19378: LD_VAR 0 4
19382: PUSH
19383: LD_INT 2
19385: ARRAY
19386: PPUSH
19387: CALL_OW 458
19391: NOT
19392: IFFALSE 19396
// continue ;
19394: GO 19366
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
19396: LD_VAR 0 4
19400: PUSH
19401: LD_INT 1
19403: ARRAY
19404: PPUSH
19405: LD_VAR 0 4
19409: PUSH
19410: LD_INT 2
19412: ARRAY
19413: PPUSH
19414: CALL_OW 428
19418: PUSH
19419: LD_VAR 0 5
19423: IN
19424: IFFALSE 19453
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
19426: LD_VAR 0 4
19430: PUSH
19431: LD_INT 1
19433: ARRAY
19434: PPUSH
19435: LD_VAR 0 4
19439: PUSH
19440: LD_INT 2
19442: ARRAY
19443: PPUSH
19444: LD_VAR 0 1
19448: PPUSH
19449: CALL_OW 456
// end ;
19453: GO 19366
19455: POP
19456: POP
// end ;
19457: LD_VAR 0 3
19461: RET
// export function Count ( array ) ; begin
19462: LD_INT 0
19464: PPUSH
// result := array + 0 ;
19465: LD_ADDR_VAR 0 2
19469: PUSH
19470: LD_VAR 0 1
19474: PUSH
19475: LD_INT 0
19477: PLUS
19478: ST_TO_ADDR
// end ;
19479: LD_VAR 0 2
19483: RET
// export function IsEmpty ( building ) ; begin
19484: LD_INT 0
19486: PPUSH
// if not building then
19487: LD_VAR 0 1
19491: NOT
19492: IFFALSE 19496
// exit ;
19494: GO 19539
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
19496: LD_ADDR_VAR 0 2
19500: PUSH
19501: LD_VAR 0 1
19505: PUSH
19506: LD_INT 22
19508: PUSH
19509: LD_VAR 0 1
19513: PPUSH
19514: CALL_OW 255
19518: PUSH
19519: EMPTY
19520: LIST
19521: LIST
19522: PUSH
19523: LD_INT 58
19525: PUSH
19526: EMPTY
19527: LIST
19528: PUSH
19529: EMPTY
19530: LIST
19531: LIST
19532: PPUSH
19533: CALL_OW 69
19537: IN
19538: ST_TO_ADDR
// end ;
19539: LD_VAR 0 2
19543: RET
// export function IsNotFull ( building ) ; var places ; begin
19544: LD_INT 0
19546: PPUSH
19547: PPUSH
// if not building then
19548: LD_VAR 0 1
19552: NOT
19553: IFFALSE 19557
// exit ;
19555: GO 19585
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
19557: LD_ADDR_VAR 0 2
19561: PUSH
19562: LD_VAR 0 1
19566: PPUSH
19567: LD_INT 3
19569: PUSH
19570: LD_INT 62
19572: PUSH
19573: EMPTY
19574: LIST
19575: PUSH
19576: EMPTY
19577: LIST
19578: LIST
19579: PPUSH
19580: CALL_OW 72
19584: ST_TO_ADDR
// end ;
19585: LD_VAR 0 2
19589: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
19590: LD_INT 0
19592: PPUSH
19593: PPUSH
19594: PPUSH
19595: PPUSH
// tmp := [ ] ;
19596: LD_ADDR_VAR 0 3
19600: PUSH
19601: EMPTY
19602: ST_TO_ADDR
// list := [ ] ;
19603: LD_ADDR_VAR 0 5
19607: PUSH
19608: EMPTY
19609: ST_TO_ADDR
// for i = 16 to 25 do
19610: LD_ADDR_VAR 0 4
19614: PUSH
19615: DOUBLE
19616: LD_INT 16
19618: DEC
19619: ST_TO_ADDR
19620: LD_INT 25
19622: PUSH
19623: FOR_TO
19624: IFFALSE 19697
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
19626: LD_ADDR_VAR 0 3
19630: PUSH
19631: LD_VAR 0 3
19635: PUSH
19636: LD_INT 22
19638: PUSH
19639: LD_VAR 0 1
19643: PPUSH
19644: CALL_OW 255
19648: PUSH
19649: EMPTY
19650: LIST
19651: LIST
19652: PUSH
19653: LD_INT 91
19655: PUSH
19656: LD_VAR 0 1
19660: PUSH
19661: LD_INT 6
19663: PUSH
19664: EMPTY
19665: LIST
19666: LIST
19667: LIST
19668: PUSH
19669: LD_INT 30
19671: PUSH
19672: LD_VAR 0 4
19676: PUSH
19677: EMPTY
19678: LIST
19679: LIST
19680: PUSH
19681: EMPTY
19682: LIST
19683: LIST
19684: LIST
19685: PUSH
19686: EMPTY
19687: LIST
19688: PPUSH
19689: CALL_OW 69
19693: ADD
19694: ST_TO_ADDR
19695: GO 19623
19697: POP
19698: POP
// for i = 1 to tmp do
19699: LD_ADDR_VAR 0 4
19703: PUSH
19704: DOUBLE
19705: LD_INT 1
19707: DEC
19708: ST_TO_ADDR
19709: LD_VAR 0 3
19713: PUSH
19714: FOR_TO
19715: IFFALSE 19803
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
19717: LD_ADDR_VAR 0 5
19721: PUSH
19722: LD_VAR 0 5
19726: PUSH
19727: LD_VAR 0 3
19731: PUSH
19732: LD_VAR 0 4
19736: ARRAY
19737: PPUSH
19738: CALL_OW 266
19742: PUSH
19743: LD_VAR 0 3
19747: PUSH
19748: LD_VAR 0 4
19752: ARRAY
19753: PPUSH
19754: CALL_OW 250
19758: PUSH
19759: LD_VAR 0 3
19763: PUSH
19764: LD_VAR 0 4
19768: ARRAY
19769: PPUSH
19770: CALL_OW 251
19774: PUSH
19775: LD_VAR 0 3
19779: PUSH
19780: LD_VAR 0 4
19784: ARRAY
19785: PPUSH
19786: CALL_OW 254
19790: PUSH
19791: EMPTY
19792: LIST
19793: LIST
19794: LIST
19795: LIST
19796: PUSH
19797: EMPTY
19798: LIST
19799: ADD
19800: ST_TO_ADDR
19801: GO 19714
19803: POP
19804: POP
// result := list ;
19805: LD_ADDR_VAR 0 2
19809: PUSH
19810: LD_VAR 0 5
19814: ST_TO_ADDR
// end ;
19815: LD_VAR 0 2
19819: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
19820: LD_INT 0
19822: PPUSH
19823: PPUSH
19824: PPUSH
19825: PPUSH
19826: PPUSH
19827: PPUSH
19828: PPUSH
// if not factory then
19829: LD_VAR 0 1
19833: NOT
19834: IFFALSE 19838
// exit ;
19836: GO 20431
// if control = control_apeman then
19838: LD_VAR 0 4
19842: PUSH
19843: LD_INT 5
19845: EQUAL
19846: IFFALSE 19955
// begin tmp := UnitsInside ( factory ) ;
19848: LD_ADDR_VAR 0 8
19852: PUSH
19853: LD_VAR 0 1
19857: PPUSH
19858: CALL_OW 313
19862: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
19863: LD_VAR 0 8
19867: PPUSH
19868: LD_INT 25
19870: PUSH
19871: LD_INT 12
19873: PUSH
19874: EMPTY
19875: LIST
19876: LIST
19877: PPUSH
19878: CALL_OW 72
19882: NOT
19883: IFFALSE 19893
// control := control_manual ;
19885: LD_ADDR_VAR 0 4
19889: PUSH
19890: LD_INT 1
19892: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
19893: LD_ADDR_VAR 0 8
19897: PUSH
19898: LD_VAR 0 1
19902: PPUSH
19903: CALL 19590 0 1
19907: ST_TO_ADDR
// if tmp then
19908: LD_VAR 0 8
19912: IFFALSE 19955
// begin for i in tmp do
19914: LD_ADDR_VAR 0 7
19918: PUSH
19919: LD_VAR 0 8
19923: PUSH
19924: FOR_IN
19925: IFFALSE 19953
// if i [ 1 ] = b_ext_radio then
19927: LD_VAR 0 7
19931: PUSH
19932: LD_INT 1
19934: ARRAY
19935: PUSH
19936: LD_INT 22
19938: EQUAL
19939: IFFALSE 19951
// begin control := control_remote ;
19941: LD_ADDR_VAR 0 4
19945: PUSH
19946: LD_INT 2
19948: ST_TO_ADDR
// break ;
19949: GO 19953
// end ;
19951: GO 19924
19953: POP
19954: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19955: LD_VAR 0 1
19959: PPUSH
19960: LD_VAR 0 2
19964: PPUSH
19965: LD_VAR 0 3
19969: PPUSH
19970: LD_VAR 0 4
19974: PPUSH
19975: LD_VAR 0 5
19979: PPUSH
19980: CALL_OW 448
19984: IFFALSE 20019
// begin result := [ chassis , engine , control , weapon ] ;
19986: LD_ADDR_VAR 0 6
19990: PUSH
19991: LD_VAR 0 2
19995: PUSH
19996: LD_VAR 0 3
20000: PUSH
20001: LD_VAR 0 4
20005: PUSH
20006: LD_VAR 0 5
20010: PUSH
20011: EMPTY
20012: LIST
20013: LIST
20014: LIST
20015: LIST
20016: ST_TO_ADDR
// exit ;
20017: GO 20431
// end ; _chassis := AvailableChassisList ( factory ) ;
20019: LD_ADDR_VAR 0 9
20023: PUSH
20024: LD_VAR 0 1
20028: PPUSH
20029: CALL_OW 475
20033: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
20034: LD_ADDR_VAR 0 11
20038: PUSH
20039: LD_VAR 0 1
20043: PPUSH
20044: CALL_OW 476
20048: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
20049: LD_ADDR_VAR 0 12
20053: PUSH
20054: LD_VAR 0 1
20058: PPUSH
20059: CALL_OW 477
20063: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
20064: LD_ADDR_VAR 0 10
20068: PUSH
20069: LD_VAR 0 1
20073: PPUSH
20074: CALL_OW 478
20078: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
20079: LD_VAR 0 9
20083: NOT
20084: PUSH
20085: LD_VAR 0 11
20089: NOT
20090: OR
20091: PUSH
20092: LD_VAR 0 12
20096: NOT
20097: OR
20098: PUSH
20099: LD_VAR 0 10
20103: NOT
20104: OR
20105: IFFALSE 20140
// begin result := [ chassis , engine , control , weapon ] ;
20107: LD_ADDR_VAR 0 6
20111: PUSH
20112: LD_VAR 0 2
20116: PUSH
20117: LD_VAR 0 3
20121: PUSH
20122: LD_VAR 0 4
20126: PUSH
20127: LD_VAR 0 5
20131: PUSH
20132: EMPTY
20133: LIST
20134: LIST
20135: LIST
20136: LIST
20137: ST_TO_ADDR
// exit ;
20138: GO 20431
// end ; if not chassis in _chassis then
20140: LD_VAR 0 2
20144: PUSH
20145: LD_VAR 0 9
20149: IN
20150: NOT
20151: IFFALSE 20177
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
20153: LD_ADDR_VAR 0 2
20157: PUSH
20158: LD_VAR 0 9
20162: PUSH
20163: LD_INT 1
20165: PPUSH
20166: LD_VAR 0 9
20170: PPUSH
20171: CALL_OW 12
20175: ARRAY
20176: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
20177: LD_VAR 0 2
20181: PPUSH
20182: LD_VAR 0 3
20186: PPUSH
20187: CALL 20436 0 2
20191: NOT
20192: IFFALSE 20251
// repeat engine := _engine [ 1 ] ;
20194: LD_ADDR_VAR 0 3
20198: PUSH
20199: LD_VAR 0 11
20203: PUSH
20204: LD_INT 1
20206: ARRAY
20207: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
20208: LD_ADDR_VAR 0 11
20212: PUSH
20213: LD_VAR 0 11
20217: PPUSH
20218: LD_INT 1
20220: PPUSH
20221: CALL_OW 3
20225: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
20226: LD_VAR 0 2
20230: PPUSH
20231: LD_VAR 0 3
20235: PPUSH
20236: CALL 20436 0 2
20240: PUSH
20241: LD_VAR 0 11
20245: PUSH
20246: EMPTY
20247: EQUAL
20248: OR
20249: IFFALSE 20194
// if not control in _control then
20251: LD_VAR 0 4
20255: PUSH
20256: LD_VAR 0 12
20260: IN
20261: NOT
20262: IFFALSE 20288
// control := _control [ rand ( 1 , _control ) ] ;
20264: LD_ADDR_VAR 0 4
20268: PUSH
20269: LD_VAR 0 12
20273: PUSH
20274: LD_INT 1
20276: PPUSH
20277: LD_VAR 0 12
20281: PPUSH
20282: CALL_OW 12
20286: ARRAY
20287: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
20288: LD_VAR 0 2
20292: PPUSH
20293: LD_VAR 0 5
20297: PPUSH
20298: CALL 20656 0 2
20302: NOT
20303: IFFALSE 20362
// repeat weapon := _weapon [ 1 ] ;
20305: LD_ADDR_VAR 0 5
20309: PUSH
20310: LD_VAR 0 10
20314: PUSH
20315: LD_INT 1
20317: ARRAY
20318: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
20319: LD_ADDR_VAR 0 10
20323: PUSH
20324: LD_VAR 0 10
20328: PPUSH
20329: LD_INT 1
20331: PPUSH
20332: CALL_OW 3
20336: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
20337: LD_VAR 0 2
20341: PPUSH
20342: LD_VAR 0 5
20346: PPUSH
20347: CALL 20656 0 2
20351: PUSH
20352: LD_VAR 0 10
20356: PUSH
20357: EMPTY
20358: EQUAL
20359: OR
20360: IFFALSE 20305
// result := [ ] ;
20362: LD_ADDR_VAR 0 6
20366: PUSH
20367: EMPTY
20368: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
20369: LD_VAR 0 1
20373: PPUSH
20374: LD_VAR 0 2
20378: PPUSH
20379: LD_VAR 0 3
20383: PPUSH
20384: LD_VAR 0 4
20388: PPUSH
20389: LD_VAR 0 5
20393: PPUSH
20394: CALL_OW 448
20398: IFFALSE 20431
// result := [ chassis , engine , control , weapon ] ;
20400: LD_ADDR_VAR 0 6
20404: PUSH
20405: LD_VAR 0 2
20409: PUSH
20410: LD_VAR 0 3
20414: PUSH
20415: LD_VAR 0 4
20419: PUSH
20420: LD_VAR 0 5
20424: PUSH
20425: EMPTY
20426: LIST
20427: LIST
20428: LIST
20429: LIST
20430: ST_TO_ADDR
// end ;
20431: LD_VAR 0 6
20435: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
20436: LD_INT 0
20438: PPUSH
// if not chassis or not engine then
20439: LD_VAR 0 1
20443: NOT
20444: PUSH
20445: LD_VAR 0 2
20449: NOT
20450: OR
20451: IFFALSE 20455
// exit ;
20453: GO 20651
// case engine of engine_solar :
20455: LD_VAR 0 2
20459: PUSH
20460: LD_INT 2
20462: DOUBLE
20463: EQUAL
20464: IFTRUE 20468
20466: GO 20506
20468: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
20469: LD_ADDR_VAR 0 3
20473: PUSH
20474: LD_INT 11
20476: PUSH
20477: LD_INT 12
20479: PUSH
20480: LD_INT 13
20482: PUSH
20483: LD_INT 14
20485: PUSH
20486: LD_INT 1
20488: PUSH
20489: LD_INT 2
20491: PUSH
20492: LD_INT 3
20494: PUSH
20495: EMPTY
20496: LIST
20497: LIST
20498: LIST
20499: LIST
20500: LIST
20501: LIST
20502: LIST
20503: ST_TO_ADDR
20504: GO 20635
20506: LD_INT 1
20508: DOUBLE
20509: EQUAL
20510: IFTRUE 20514
20512: GO 20576
20514: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
20515: LD_ADDR_VAR 0 3
20519: PUSH
20520: LD_INT 11
20522: PUSH
20523: LD_INT 12
20525: PUSH
20526: LD_INT 13
20528: PUSH
20529: LD_INT 14
20531: PUSH
20532: LD_INT 1
20534: PUSH
20535: LD_INT 2
20537: PUSH
20538: LD_INT 3
20540: PUSH
20541: LD_INT 4
20543: PUSH
20544: LD_INT 5
20546: PUSH
20547: LD_INT 21
20549: PUSH
20550: LD_INT 23
20552: PUSH
20553: LD_INT 22
20555: PUSH
20556: LD_INT 24
20558: PUSH
20559: EMPTY
20560: LIST
20561: LIST
20562: LIST
20563: LIST
20564: LIST
20565: LIST
20566: LIST
20567: LIST
20568: LIST
20569: LIST
20570: LIST
20571: LIST
20572: LIST
20573: ST_TO_ADDR
20574: GO 20635
20576: LD_INT 3
20578: DOUBLE
20579: EQUAL
20580: IFTRUE 20584
20582: GO 20634
20584: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20585: LD_ADDR_VAR 0 3
20589: PUSH
20590: LD_INT 13
20592: PUSH
20593: LD_INT 14
20595: PUSH
20596: LD_INT 2
20598: PUSH
20599: LD_INT 3
20601: PUSH
20602: LD_INT 4
20604: PUSH
20605: LD_INT 5
20607: PUSH
20608: LD_INT 21
20610: PUSH
20611: LD_INT 22
20613: PUSH
20614: LD_INT 23
20616: PUSH
20617: LD_INT 24
20619: PUSH
20620: EMPTY
20621: LIST
20622: LIST
20623: LIST
20624: LIST
20625: LIST
20626: LIST
20627: LIST
20628: LIST
20629: LIST
20630: LIST
20631: ST_TO_ADDR
20632: GO 20635
20634: POP
// result := ( chassis in result ) ;
20635: LD_ADDR_VAR 0 3
20639: PUSH
20640: LD_VAR 0 1
20644: PUSH
20645: LD_VAR 0 3
20649: IN
20650: ST_TO_ADDR
// end ;
20651: LD_VAR 0 3
20655: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
20656: LD_INT 0
20658: PPUSH
// if not chassis or not weapon then
20659: LD_VAR 0 1
20663: NOT
20664: PUSH
20665: LD_VAR 0 2
20669: NOT
20670: OR
20671: IFFALSE 20675
// exit ;
20673: GO 21735
// case weapon of us_machine_gun :
20675: LD_VAR 0 2
20679: PUSH
20680: LD_INT 2
20682: DOUBLE
20683: EQUAL
20684: IFTRUE 20688
20686: GO 20718
20688: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
20689: LD_ADDR_VAR 0 3
20693: PUSH
20694: LD_INT 1
20696: PUSH
20697: LD_INT 2
20699: PUSH
20700: LD_INT 3
20702: PUSH
20703: LD_INT 4
20705: PUSH
20706: LD_INT 5
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: LIST
20713: LIST
20714: LIST
20715: ST_TO_ADDR
20716: GO 21719
20718: LD_INT 3
20720: DOUBLE
20721: EQUAL
20722: IFTRUE 20726
20724: GO 20756
20726: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
20727: LD_ADDR_VAR 0 3
20731: PUSH
20732: LD_INT 1
20734: PUSH
20735: LD_INT 2
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: LD_INT 4
20743: PUSH
20744: LD_INT 5
20746: PUSH
20747: EMPTY
20748: LIST
20749: LIST
20750: LIST
20751: LIST
20752: LIST
20753: ST_TO_ADDR
20754: GO 21719
20756: LD_INT 11
20758: DOUBLE
20759: EQUAL
20760: IFTRUE 20764
20762: GO 20794
20764: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
20765: LD_ADDR_VAR 0 3
20769: PUSH
20770: LD_INT 1
20772: PUSH
20773: LD_INT 2
20775: PUSH
20776: LD_INT 3
20778: PUSH
20779: LD_INT 4
20781: PUSH
20782: LD_INT 5
20784: PUSH
20785: EMPTY
20786: LIST
20787: LIST
20788: LIST
20789: LIST
20790: LIST
20791: ST_TO_ADDR
20792: GO 21719
20794: LD_INT 4
20796: DOUBLE
20797: EQUAL
20798: IFTRUE 20802
20800: GO 20828
20802: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
20803: LD_ADDR_VAR 0 3
20807: PUSH
20808: LD_INT 2
20810: PUSH
20811: LD_INT 3
20813: PUSH
20814: LD_INT 4
20816: PUSH
20817: LD_INT 5
20819: PUSH
20820: EMPTY
20821: LIST
20822: LIST
20823: LIST
20824: LIST
20825: ST_TO_ADDR
20826: GO 21719
20828: LD_INT 5
20830: DOUBLE
20831: EQUAL
20832: IFTRUE 20836
20834: GO 20862
20836: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
20837: LD_ADDR_VAR 0 3
20841: PUSH
20842: LD_INT 2
20844: PUSH
20845: LD_INT 3
20847: PUSH
20848: LD_INT 4
20850: PUSH
20851: LD_INT 5
20853: PUSH
20854: EMPTY
20855: LIST
20856: LIST
20857: LIST
20858: LIST
20859: ST_TO_ADDR
20860: GO 21719
20862: LD_INT 9
20864: DOUBLE
20865: EQUAL
20866: IFTRUE 20870
20868: GO 20896
20870: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
20871: LD_ADDR_VAR 0 3
20875: PUSH
20876: LD_INT 2
20878: PUSH
20879: LD_INT 3
20881: PUSH
20882: LD_INT 4
20884: PUSH
20885: LD_INT 5
20887: PUSH
20888: EMPTY
20889: LIST
20890: LIST
20891: LIST
20892: LIST
20893: ST_TO_ADDR
20894: GO 21719
20896: LD_INT 7
20898: DOUBLE
20899: EQUAL
20900: IFTRUE 20904
20902: GO 20930
20904: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
20905: LD_ADDR_VAR 0 3
20909: PUSH
20910: LD_INT 2
20912: PUSH
20913: LD_INT 3
20915: PUSH
20916: LD_INT 4
20918: PUSH
20919: LD_INT 5
20921: PUSH
20922: EMPTY
20923: LIST
20924: LIST
20925: LIST
20926: LIST
20927: ST_TO_ADDR
20928: GO 21719
20930: LD_INT 12
20932: DOUBLE
20933: EQUAL
20934: IFTRUE 20938
20936: GO 20964
20938: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
20939: LD_ADDR_VAR 0 3
20943: PUSH
20944: LD_INT 2
20946: PUSH
20947: LD_INT 3
20949: PUSH
20950: LD_INT 4
20952: PUSH
20953: LD_INT 5
20955: PUSH
20956: EMPTY
20957: LIST
20958: LIST
20959: LIST
20960: LIST
20961: ST_TO_ADDR
20962: GO 21719
20964: LD_INT 13
20966: DOUBLE
20967: EQUAL
20968: IFTRUE 20972
20970: GO 20998
20972: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
20973: LD_ADDR_VAR 0 3
20977: PUSH
20978: LD_INT 2
20980: PUSH
20981: LD_INT 3
20983: PUSH
20984: LD_INT 4
20986: PUSH
20987: LD_INT 5
20989: PUSH
20990: EMPTY
20991: LIST
20992: LIST
20993: LIST
20994: LIST
20995: ST_TO_ADDR
20996: GO 21719
20998: LD_INT 14
21000: DOUBLE
21001: EQUAL
21002: IFTRUE 21006
21004: GO 21024
21006: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
21007: LD_ADDR_VAR 0 3
21011: PUSH
21012: LD_INT 4
21014: PUSH
21015: LD_INT 5
21017: PUSH
21018: EMPTY
21019: LIST
21020: LIST
21021: ST_TO_ADDR
21022: GO 21719
21024: LD_INT 6
21026: DOUBLE
21027: EQUAL
21028: IFTRUE 21032
21030: GO 21050
21032: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
21033: LD_ADDR_VAR 0 3
21037: PUSH
21038: LD_INT 4
21040: PUSH
21041: LD_INT 5
21043: PUSH
21044: EMPTY
21045: LIST
21046: LIST
21047: ST_TO_ADDR
21048: GO 21719
21050: LD_INT 10
21052: DOUBLE
21053: EQUAL
21054: IFTRUE 21058
21056: GO 21076
21058: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
21059: LD_ADDR_VAR 0 3
21063: PUSH
21064: LD_INT 4
21066: PUSH
21067: LD_INT 5
21069: PUSH
21070: EMPTY
21071: LIST
21072: LIST
21073: ST_TO_ADDR
21074: GO 21719
21076: LD_INT 22
21078: DOUBLE
21079: EQUAL
21080: IFTRUE 21084
21082: GO 21110
21084: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
21085: LD_ADDR_VAR 0 3
21089: PUSH
21090: LD_INT 11
21092: PUSH
21093: LD_INT 12
21095: PUSH
21096: LD_INT 13
21098: PUSH
21099: LD_INT 14
21101: PUSH
21102: EMPTY
21103: LIST
21104: LIST
21105: LIST
21106: LIST
21107: ST_TO_ADDR
21108: GO 21719
21110: LD_INT 23
21112: DOUBLE
21113: EQUAL
21114: IFTRUE 21118
21116: GO 21144
21118: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
21119: LD_ADDR_VAR 0 3
21123: PUSH
21124: LD_INT 11
21126: PUSH
21127: LD_INT 12
21129: PUSH
21130: LD_INT 13
21132: PUSH
21133: LD_INT 14
21135: PUSH
21136: EMPTY
21137: LIST
21138: LIST
21139: LIST
21140: LIST
21141: ST_TO_ADDR
21142: GO 21719
21144: LD_INT 24
21146: DOUBLE
21147: EQUAL
21148: IFTRUE 21152
21150: GO 21178
21152: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
21153: LD_ADDR_VAR 0 3
21157: PUSH
21158: LD_INT 11
21160: PUSH
21161: LD_INT 12
21163: PUSH
21164: LD_INT 13
21166: PUSH
21167: LD_INT 14
21169: PUSH
21170: EMPTY
21171: LIST
21172: LIST
21173: LIST
21174: LIST
21175: ST_TO_ADDR
21176: GO 21719
21178: LD_INT 30
21180: DOUBLE
21181: EQUAL
21182: IFTRUE 21186
21184: GO 21212
21186: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
21187: LD_ADDR_VAR 0 3
21191: PUSH
21192: LD_INT 11
21194: PUSH
21195: LD_INT 12
21197: PUSH
21198: LD_INT 13
21200: PUSH
21201: LD_INT 14
21203: PUSH
21204: EMPTY
21205: LIST
21206: LIST
21207: LIST
21208: LIST
21209: ST_TO_ADDR
21210: GO 21719
21212: LD_INT 25
21214: DOUBLE
21215: EQUAL
21216: IFTRUE 21220
21218: GO 21238
21220: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
21221: LD_ADDR_VAR 0 3
21225: PUSH
21226: LD_INT 13
21228: PUSH
21229: LD_INT 14
21231: PUSH
21232: EMPTY
21233: LIST
21234: LIST
21235: ST_TO_ADDR
21236: GO 21719
21238: LD_INT 27
21240: DOUBLE
21241: EQUAL
21242: IFTRUE 21246
21244: GO 21264
21246: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
21247: LD_ADDR_VAR 0 3
21251: PUSH
21252: LD_INT 13
21254: PUSH
21255: LD_INT 14
21257: PUSH
21258: EMPTY
21259: LIST
21260: LIST
21261: ST_TO_ADDR
21262: GO 21719
21264: LD_INT 92
21266: DOUBLE
21267: EQUAL
21268: IFTRUE 21272
21270: GO 21298
21272: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
21273: LD_ADDR_VAR 0 3
21277: PUSH
21278: LD_INT 11
21280: PUSH
21281: LD_INT 12
21283: PUSH
21284: LD_INT 13
21286: PUSH
21287: LD_INT 14
21289: PUSH
21290: EMPTY
21291: LIST
21292: LIST
21293: LIST
21294: LIST
21295: ST_TO_ADDR
21296: GO 21719
21298: LD_INT 28
21300: DOUBLE
21301: EQUAL
21302: IFTRUE 21306
21304: GO 21324
21306: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
21307: LD_ADDR_VAR 0 3
21311: PUSH
21312: LD_INT 13
21314: PUSH
21315: LD_INT 14
21317: PUSH
21318: EMPTY
21319: LIST
21320: LIST
21321: ST_TO_ADDR
21322: GO 21719
21324: LD_INT 29
21326: DOUBLE
21327: EQUAL
21328: IFTRUE 21332
21330: GO 21350
21332: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
21333: LD_ADDR_VAR 0 3
21337: PUSH
21338: LD_INT 13
21340: PUSH
21341: LD_INT 14
21343: PUSH
21344: EMPTY
21345: LIST
21346: LIST
21347: ST_TO_ADDR
21348: GO 21719
21350: LD_INT 31
21352: DOUBLE
21353: EQUAL
21354: IFTRUE 21358
21356: GO 21376
21358: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
21359: LD_ADDR_VAR 0 3
21363: PUSH
21364: LD_INT 13
21366: PUSH
21367: LD_INT 14
21369: PUSH
21370: EMPTY
21371: LIST
21372: LIST
21373: ST_TO_ADDR
21374: GO 21719
21376: LD_INT 26
21378: DOUBLE
21379: EQUAL
21380: IFTRUE 21384
21382: GO 21402
21384: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
21385: LD_ADDR_VAR 0 3
21389: PUSH
21390: LD_INT 13
21392: PUSH
21393: LD_INT 14
21395: PUSH
21396: EMPTY
21397: LIST
21398: LIST
21399: ST_TO_ADDR
21400: GO 21719
21402: LD_INT 42
21404: DOUBLE
21405: EQUAL
21406: IFTRUE 21410
21408: GO 21436
21410: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
21411: LD_ADDR_VAR 0 3
21415: PUSH
21416: LD_INT 21
21418: PUSH
21419: LD_INT 22
21421: PUSH
21422: LD_INT 23
21424: PUSH
21425: LD_INT 24
21427: PUSH
21428: EMPTY
21429: LIST
21430: LIST
21431: LIST
21432: LIST
21433: ST_TO_ADDR
21434: GO 21719
21436: LD_INT 43
21438: DOUBLE
21439: EQUAL
21440: IFTRUE 21444
21442: GO 21470
21444: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
21445: LD_ADDR_VAR 0 3
21449: PUSH
21450: LD_INT 21
21452: PUSH
21453: LD_INT 22
21455: PUSH
21456: LD_INT 23
21458: PUSH
21459: LD_INT 24
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: LIST
21466: LIST
21467: ST_TO_ADDR
21468: GO 21719
21470: LD_INT 44
21472: DOUBLE
21473: EQUAL
21474: IFTRUE 21478
21476: GO 21504
21478: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
21479: LD_ADDR_VAR 0 3
21483: PUSH
21484: LD_INT 21
21486: PUSH
21487: LD_INT 22
21489: PUSH
21490: LD_INT 23
21492: PUSH
21493: LD_INT 24
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: LIST
21500: LIST
21501: ST_TO_ADDR
21502: GO 21719
21504: LD_INT 45
21506: DOUBLE
21507: EQUAL
21508: IFTRUE 21512
21510: GO 21538
21512: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
21513: LD_ADDR_VAR 0 3
21517: PUSH
21518: LD_INT 21
21520: PUSH
21521: LD_INT 22
21523: PUSH
21524: LD_INT 23
21526: PUSH
21527: LD_INT 24
21529: PUSH
21530: EMPTY
21531: LIST
21532: LIST
21533: LIST
21534: LIST
21535: ST_TO_ADDR
21536: GO 21719
21538: LD_INT 49
21540: DOUBLE
21541: EQUAL
21542: IFTRUE 21546
21544: GO 21572
21546: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
21547: LD_ADDR_VAR 0 3
21551: PUSH
21552: LD_INT 21
21554: PUSH
21555: LD_INT 22
21557: PUSH
21558: LD_INT 23
21560: PUSH
21561: LD_INT 24
21563: PUSH
21564: EMPTY
21565: LIST
21566: LIST
21567: LIST
21568: LIST
21569: ST_TO_ADDR
21570: GO 21719
21572: LD_INT 51
21574: DOUBLE
21575: EQUAL
21576: IFTRUE 21580
21578: GO 21606
21580: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
21581: LD_ADDR_VAR 0 3
21585: PUSH
21586: LD_INT 21
21588: PUSH
21589: LD_INT 22
21591: PUSH
21592: LD_INT 23
21594: PUSH
21595: LD_INT 24
21597: PUSH
21598: EMPTY
21599: LIST
21600: LIST
21601: LIST
21602: LIST
21603: ST_TO_ADDR
21604: GO 21719
21606: LD_INT 52
21608: DOUBLE
21609: EQUAL
21610: IFTRUE 21614
21612: GO 21640
21614: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
21615: LD_ADDR_VAR 0 3
21619: PUSH
21620: LD_INT 21
21622: PUSH
21623: LD_INT 22
21625: PUSH
21626: LD_INT 23
21628: PUSH
21629: LD_INT 24
21631: PUSH
21632: EMPTY
21633: LIST
21634: LIST
21635: LIST
21636: LIST
21637: ST_TO_ADDR
21638: GO 21719
21640: LD_INT 53
21642: DOUBLE
21643: EQUAL
21644: IFTRUE 21648
21646: GO 21666
21648: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
21649: LD_ADDR_VAR 0 3
21653: PUSH
21654: LD_INT 23
21656: PUSH
21657: LD_INT 24
21659: PUSH
21660: EMPTY
21661: LIST
21662: LIST
21663: ST_TO_ADDR
21664: GO 21719
21666: LD_INT 46
21668: DOUBLE
21669: EQUAL
21670: IFTRUE 21674
21672: GO 21692
21674: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
21675: LD_ADDR_VAR 0 3
21679: PUSH
21680: LD_INT 23
21682: PUSH
21683: LD_INT 24
21685: PUSH
21686: EMPTY
21687: LIST
21688: LIST
21689: ST_TO_ADDR
21690: GO 21719
21692: LD_INT 47
21694: DOUBLE
21695: EQUAL
21696: IFTRUE 21700
21698: GO 21718
21700: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
21701: LD_ADDR_VAR 0 3
21705: PUSH
21706: LD_INT 23
21708: PUSH
21709: LD_INT 24
21711: PUSH
21712: EMPTY
21713: LIST
21714: LIST
21715: ST_TO_ADDR
21716: GO 21719
21718: POP
// result := ( chassis in result ) ;
21719: LD_ADDR_VAR 0 3
21723: PUSH
21724: LD_VAR 0 1
21728: PUSH
21729: LD_VAR 0 3
21733: IN
21734: ST_TO_ADDR
// end ;
21735: LD_VAR 0 3
21739: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
21740: LD_INT 0
21742: PPUSH
21743: PPUSH
21744: PPUSH
21745: PPUSH
21746: PPUSH
21747: PPUSH
21748: PPUSH
// result := array ;
21749: LD_ADDR_VAR 0 5
21753: PUSH
21754: LD_VAR 0 1
21758: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
21759: LD_VAR 0 1
21763: NOT
21764: PUSH
21765: LD_VAR 0 2
21769: NOT
21770: OR
21771: PUSH
21772: LD_VAR 0 3
21776: NOT
21777: OR
21778: PUSH
21779: LD_VAR 0 2
21783: PUSH
21784: LD_VAR 0 1
21788: GREATER
21789: OR
21790: PUSH
21791: LD_VAR 0 3
21795: PUSH
21796: LD_VAR 0 1
21800: GREATER
21801: OR
21802: IFFALSE 21806
// exit ;
21804: GO 22102
// if direction then
21806: LD_VAR 0 4
21810: IFFALSE 21874
// begin d := 1 ;
21812: LD_ADDR_VAR 0 9
21816: PUSH
21817: LD_INT 1
21819: ST_TO_ADDR
// if i_from > i_to then
21820: LD_VAR 0 2
21824: PUSH
21825: LD_VAR 0 3
21829: GREATER
21830: IFFALSE 21856
// length := ( array - i_from ) + i_to else
21832: LD_ADDR_VAR 0 11
21836: PUSH
21837: LD_VAR 0 1
21841: PUSH
21842: LD_VAR 0 2
21846: MINUS
21847: PUSH
21848: LD_VAR 0 3
21852: PLUS
21853: ST_TO_ADDR
21854: GO 21872
// length := i_to - i_from ;
21856: LD_ADDR_VAR 0 11
21860: PUSH
21861: LD_VAR 0 3
21865: PUSH
21866: LD_VAR 0 2
21870: MINUS
21871: ST_TO_ADDR
// end else
21872: GO 21935
// begin d := - 1 ;
21874: LD_ADDR_VAR 0 9
21878: PUSH
21879: LD_INT 1
21881: NEG
21882: ST_TO_ADDR
// if i_from > i_to then
21883: LD_VAR 0 2
21887: PUSH
21888: LD_VAR 0 3
21892: GREATER
21893: IFFALSE 21913
// length := i_from - i_to else
21895: LD_ADDR_VAR 0 11
21899: PUSH
21900: LD_VAR 0 2
21904: PUSH
21905: LD_VAR 0 3
21909: MINUS
21910: ST_TO_ADDR
21911: GO 21935
// length := ( array - i_to ) + i_from ;
21913: LD_ADDR_VAR 0 11
21917: PUSH
21918: LD_VAR 0 1
21922: PUSH
21923: LD_VAR 0 3
21927: MINUS
21928: PUSH
21929: LD_VAR 0 2
21933: PLUS
21934: ST_TO_ADDR
// end ; if not length then
21935: LD_VAR 0 11
21939: NOT
21940: IFFALSE 21944
// exit ;
21942: GO 22102
// tmp := array ;
21944: LD_ADDR_VAR 0 10
21948: PUSH
21949: LD_VAR 0 1
21953: ST_TO_ADDR
// for i = 1 to length do
21954: LD_ADDR_VAR 0 6
21958: PUSH
21959: DOUBLE
21960: LD_INT 1
21962: DEC
21963: ST_TO_ADDR
21964: LD_VAR 0 11
21968: PUSH
21969: FOR_TO
21970: IFFALSE 22090
// begin for j = 1 to array do
21972: LD_ADDR_VAR 0 7
21976: PUSH
21977: DOUBLE
21978: LD_INT 1
21980: DEC
21981: ST_TO_ADDR
21982: LD_VAR 0 1
21986: PUSH
21987: FOR_TO
21988: IFFALSE 22076
// begin k := j + d ;
21990: LD_ADDR_VAR 0 8
21994: PUSH
21995: LD_VAR 0 7
21999: PUSH
22000: LD_VAR 0 9
22004: PLUS
22005: ST_TO_ADDR
// if k > array then
22006: LD_VAR 0 8
22010: PUSH
22011: LD_VAR 0 1
22015: GREATER
22016: IFFALSE 22026
// k := 1 ;
22018: LD_ADDR_VAR 0 8
22022: PUSH
22023: LD_INT 1
22025: ST_TO_ADDR
// if not k then
22026: LD_VAR 0 8
22030: NOT
22031: IFFALSE 22043
// k := array ;
22033: LD_ADDR_VAR 0 8
22037: PUSH
22038: LD_VAR 0 1
22042: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
22043: LD_ADDR_VAR 0 10
22047: PUSH
22048: LD_VAR 0 10
22052: PPUSH
22053: LD_VAR 0 8
22057: PPUSH
22058: LD_VAR 0 1
22062: PUSH
22063: LD_VAR 0 7
22067: ARRAY
22068: PPUSH
22069: CALL_OW 1
22073: ST_TO_ADDR
// end ;
22074: GO 21987
22076: POP
22077: POP
// array := tmp ;
22078: LD_ADDR_VAR 0 1
22082: PUSH
22083: LD_VAR 0 10
22087: ST_TO_ADDR
// end ;
22088: GO 21969
22090: POP
22091: POP
// result := array ;
22092: LD_ADDR_VAR 0 5
22096: PUSH
22097: LD_VAR 0 1
22101: ST_TO_ADDR
// end ;
22102: LD_VAR 0 5
22106: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
22107: LD_INT 0
22109: PPUSH
22110: PPUSH
// result := 0 ;
22111: LD_ADDR_VAR 0 3
22115: PUSH
22116: LD_INT 0
22118: ST_TO_ADDR
// if not array or not value in array then
22119: LD_VAR 0 1
22123: NOT
22124: PUSH
22125: LD_VAR 0 2
22129: PUSH
22130: LD_VAR 0 1
22134: IN
22135: NOT
22136: OR
22137: IFFALSE 22141
// exit ;
22139: GO 22195
// for i = 1 to array do
22141: LD_ADDR_VAR 0 4
22145: PUSH
22146: DOUBLE
22147: LD_INT 1
22149: DEC
22150: ST_TO_ADDR
22151: LD_VAR 0 1
22155: PUSH
22156: FOR_TO
22157: IFFALSE 22193
// if value = array [ i ] then
22159: LD_VAR 0 2
22163: PUSH
22164: LD_VAR 0 1
22168: PUSH
22169: LD_VAR 0 4
22173: ARRAY
22174: EQUAL
22175: IFFALSE 22191
// begin result := i ;
22177: LD_ADDR_VAR 0 3
22181: PUSH
22182: LD_VAR 0 4
22186: ST_TO_ADDR
// exit ;
22187: POP
22188: POP
22189: GO 22195
// end ;
22191: GO 22156
22193: POP
22194: POP
// end ;
22195: LD_VAR 0 3
22199: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
22200: LD_INT 0
22202: PPUSH
// vc_chassis := chassis ;
22203: LD_ADDR_OWVAR 37
22207: PUSH
22208: LD_VAR 0 1
22212: ST_TO_ADDR
// vc_engine := engine ;
22213: LD_ADDR_OWVAR 39
22217: PUSH
22218: LD_VAR 0 2
22222: ST_TO_ADDR
// vc_control := control ;
22223: LD_ADDR_OWVAR 38
22227: PUSH
22228: LD_VAR 0 3
22232: ST_TO_ADDR
// vc_weapon := weapon ;
22233: LD_ADDR_OWVAR 40
22237: PUSH
22238: LD_VAR 0 4
22242: ST_TO_ADDR
// vc_fuel_battery := fuel ;
22243: LD_ADDR_OWVAR 41
22247: PUSH
22248: LD_VAR 0 5
22252: ST_TO_ADDR
// end ;
22253: LD_VAR 0 6
22257: RET
// export function WantPlant ( unit ) ; var task ; begin
22258: LD_INT 0
22260: PPUSH
22261: PPUSH
// result := false ;
22262: LD_ADDR_VAR 0 2
22266: PUSH
22267: LD_INT 0
22269: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
22270: LD_ADDR_VAR 0 3
22274: PUSH
22275: LD_VAR 0 1
22279: PPUSH
22280: CALL_OW 437
22284: ST_TO_ADDR
// if task then
22285: LD_VAR 0 3
22289: IFFALSE 22317
// if task [ 1 ] [ 1 ] = p then
22291: LD_VAR 0 3
22295: PUSH
22296: LD_INT 1
22298: ARRAY
22299: PUSH
22300: LD_INT 1
22302: ARRAY
22303: PUSH
22304: LD_STRING p
22306: EQUAL
22307: IFFALSE 22317
// result := true ;
22309: LD_ADDR_VAR 0 2
22313: PUSH
22314: LD_INT 1
22316: ST_TO_ADDR
// end ;
22317: LD_VAR 0 2
22321: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
22322: LD_INT 0
22324: PPUSH
22325: PPUSH
22326: PPUSH
22327: PPUSH
// if pos < 1 then
22328: LD_VAR 0 2
22332: PUSH
22333: LD_INT 1
22335: LESS
22336: IFFALSE 22340
// exit ;
22338: GO 22643
// if pos = 1 then
22340: LD_VAR 0 2
22344: PUSH
22345: LD_INT 1
22347: EQUAL
22348: IFFALSE 22381
// result := Replace ( arr , pos [ 1 ] , value ) else
22350: LD_ADDR_VAR 0 4
22354: PUSH
22355: LD_VAR 0 1
22359: PPUSH
22360: LD_VAR 0 2
22364: PUSH
22365: LD_INT 1
22367: ARRAY
22368: PPUSH
22369: LD_VAR 0 3
22373: PPUSH
22374: CALL_OW 1
22378: ST_TO_ADDR
22379: GO 22643
// begin tmp := arr ;
22381: LD_ADDR_VAR 0 6
22385: PUSH
22386: LD_VAR 0 1
22390: ST_TO_ADDR
// s_arr := [ tmp ] ;
22391: LD_ADDR_VAR 0 7
22395: PUSH
22396: LD_VAR 0 6
22400: PUSH
22401: EMPTY
22402: LIST
22403: ST_TO_ADDR
// for i = 1 to pos - 1 do
22404: LD_ADDR_VAR 0 5
22408: PUSH
22409: DOUBLE
22410: LD_INT 1
22412: DEC
22413: ST_TO_ADDR
22414: LD_VAR 0 2
22418: PUSH
22419: LD_INT 1
22421: MINUS
22422: PUSH
22423: FOR_TO
22424: IFFALSE 22469
// begin tmp := tmp [ pos [ i ] ] ;
22426: LD_ADDR_VAR 0 6
22430: PUSH
22431: LD_VAR 0 6
22435: PUSH
22436: LD_VAR 0 2
22440: PUSH
22441: LD_VAR 0 5
22445: ARRAY
22446: ARRAY
22447: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
22448: LD_ADDR_VAR 0 7
22452: PUSH
22453: LD_VAR 0 7
22457: PUSH
22458: LD_VAR 0 6
22462: PUSH
22463: EMPTY
22464: LIST
22465: ADD
22466: ST_TO_ADDR
// end ;
22467: GO 22423
22469: POP
22470: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
22471: LD_ADDR_VAR 0 6
22475: PUSH
22476: LD_VAR 0 6
22480: PPUSH
22481: LD_VAR 0 2
22485: PUSH
22486: LD_VAR 0 2
22490: ARRAY
22491: PPUSH
22492: LD_VAR 0 3
22496: PPUSH
22497: CALL_OW 1
22501: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
22502: LD_ADDR_VAR 0 7
22506: PUSH
22507: LD_VAR 0 7
22511: PPUSH
22512: LD_VAR 0 7
22516: PPUSH
22517: LD_VAR 0 6
22521: PPUSH
22522: CALL_OW 1
22526: ST_TO_ADDR
// for i = s_arr downto 2 do
22527: LD_ADDR_VAR 0 5
22531: PUSH
22532: DOUBLE
22533: LD_VAR 0 7
22537: INC
22538: ST_TO_ADDR
22539: LD_INT 2
22541: PUSH
22542: FOR_DOWNTO
22543: IFFALSE 22627
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
22545: LD_ADDR_VAR 0 6
22549: PUSH
22550: LD_VAR 0 7
22554: PUSH
22555: LD_VAR 0 5
22559: PUSH
22560: LD_INT 1
22562: MINUS
22563: ARRAY
22564: PPUSH
22565: LD_VAR 0 2
22569: PUSH
22570: LD_VAR 0 5
22574: PUSH
22575: LD_INT 1
22577: MINUS
22578: ARRAY
22579: PPUSH
22580: LD_VAR 0 7
22584: PUSH
22585: LD_VAR 0 5
22589: ARRAY
22590: PPUSH
22591: CALL_OW 1
22595: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
22596: LD_ADDR_VAR 0 7
22600: PUSH
22601: LD_VAR 0 7
22605: PPUSH
22606: LD_VAR 0 5
22610: PUSH
22611: LD_INT 1
22613: MINUS
22614: PPUSH
22615: LD_VAR 0 6
22619: PPUSH
22620: CALL_OW 1
22624: ST_TO_ADDR
// end ;
22625: GO 22542
22627: POP
22628: POP
// result := s_arr [ 1 ] ;
22629: LD_ADDR_VAR 0 4
22633: PUSH
22634: LD_VAR 0 7
22638: PUSH
22639: LD_INT 1
22641: ARRAY
22642: ST_TO_ADDR
// end ; end ;
22643: LD_VAR 0 4
22647: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
22648: LD_INT 0
22650: PPUSH
22651: PPUSH
// if not list then
22652: LD_VAR 0 1
22656: NOT
22657: IFFALSE 22661
// exit ;
22659: GO 22752
// i := list [ pos1 ] ;
22661: LD_ADDR_VAR 0 5
22665: PUSH
22666: LD_VAR 0 1
22670: PUSH
22671: LD_VAR 0 2
22675: ARRAY
22676: ST_TO_ADDR
// if not i then
22677: LD_VAR 0 5
22681: NOT
22682: IFFALSE 22686
// exit ;
22684: GO 22752
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
22686: LD_ADDR_VAR 0 1
22690: PUSH
22691: LD_VAR 0 1
22695: PPUSH
22696: LD_VAR 0 2
22700: PPUSH
22701: LD_VAR 0 1
22705: PUSH
22706: LD_VAR 0 3
22710: ARRAY
22711: PPUSH
22712: CALL_OW 1
22716: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
22717: LD_ADDR_VAR 0 1
22721: PUSH
22722: LD_VAR 0 1
22726: PPUSH
22727: LD_VAR 0 3
22731: PPUSH
22732: LD_VAR 0 5
22736: PPUSH
22737: CALL_OW 1
22741: ST_TO_ADDR
// result := list ;
22742: LD_ADDR_VAR 0 4
22746: PUSH
22747: LD_VAR 0 1
22751: ST_TO_ADDR
// end ;
22752: LD_VAR 0 4
22756: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
22757: LD_INT 0
22759: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
22760: LD_ADDR_VAR 0 5
22764: PUSH
22765: LD_VAR 0 1
22769: PPUSH
22770: CALL_OW 250
22774: PPUSH
22775: LD_VAR 0 1
22779: PPUSH
22780: CALL_OW 251
22784: PPUSH
22785: LD_VAR 0 2
22789: PPUSH
22790: LD_VAR 0 3
22794: PPUSH
22795: LD_VAR 0 4
22799: PPUSH
22800: CALL 23178 0 5
22804: ST_TO_ADDR
// end ;
22805: LD_VAR 0 5
22809: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
22810: LD_INT 0
22812: PPUSH
22813: PPUSH
22814: PPUSH
22815: PPUSH
// if not list or not unit then
22816: LD_VAR 0 2
22820: NOT
22821: PUSH
22822: LD_VAR 0 1
22826: NOT
22827: OR
22828: IFFALSE 22832
// exit ;
22830: GO 23173
// result := [ ] ;
22832: LD_ADDR_VAR 0 5
22836: PUSH
22837: EMPTY
22838: ST_TO_ADDR
// for i in list do
22839: LD_ADDR_VAR 0 6
22843: PUSH
22844: LD_VAR 0 2
22848: PUSH
22849: FOR_IN
22850: IFFALSE 23068
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
22852: LD_ADDR_VAR 0 8
22856: PUSH
22857: LD_VAR 0 1
22861: PPUSH
22862: LD_VAR 0 6
22866: PUSH
22867: LD_INT 1
22869: ARRAY
22870: PPUSH
22871: LD_VAR 0 6
22875: PUSH
22876: LD_INT 2
22878: ARRAY
22879: PPUSH
22880: CALL_OW 297
22884: ST_TO_ADDR
// if not Count ( result ) then
22885: LD_VAR 0 5
22889: PPUSH
22890: CALL 19462 0 1
22894: NOT
22895: IFFALSE 22928
// begin result := Join ( result , [ i , tmp ] ) ;
22897: LD_ADDR_VAR 0 5
22901: PUSH
22902: LD_VAR 0 5
22906: PPUSH
22907: LD_VAR 0 6
22911: PUSH
22912: LD_VAR 0 8
22916: PUSH
22917: EMPTY
22918: LIST
22919: LIST
22920: PPUSH
22921: CALL 55071 0 2
22925: ST_TO_ADDR
// continue ;
22926: GO 22849
// end ; if result [ result ] [ 2 ] <= tmp then
22928: LD_VAR 0 5
22932: PUSH
22933: LD_VAR 0 5
22937: ARRAY
22938: PUSH
22939: LD_INT 2
22941: ARRAY
22942: PUSH
22943: LD_VAR 0 8
22947: LESSEQUAL
22948: IFFALSE 22981
// result := Join ( result , [ i , tmp ] ) else
22950: LD_ADDR_VAR 0 5
22954: PUSH
22955: LD_VAR 0 5
22959: PPUSH
22960: LD_VAR 0 6
22964: PUSH
22965: LD_VAR 0 8
22969: PUSH
22970: EMPTY
22971: LIST
22972: LIST
22973: PPUSH
22974: CALL 55071 0 2
22978: ST_TO_ADDR
22979: GO 23066
// begin for j := 1 to Count ( result ) do
22981: LD_ADDR_VAR 0 7
22985: PUSH
22986: DOUBLE
22987: LD_INT 1
22989: DEC
22990: ST_TO_ADDR
22991: LD_VAR 0 5
22995: PPUSH
22996: CALL 19462 0 1
23000: PUSH
23001: FOR_TO
23002: IFFALSE 23064
// begin if tmp < result [ j ] [ 2 ] then
23004: LD_VAR 0 8
23008: PUSH
23009: LD_VAR 0 5
23013: PUSH
23014: LD_VAR 0 7
23018: ARRAY
23019: PUSH
23020: LD_INT 2
23022: ARRAY
23023: LESS
23024: IFFALSE 23062
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23026: LD_ADDR_VAR 0 5
23030: PUSH
23031: LD_VAR 0 5
23035: PPUSH
23036: LD_VAR 0 7
23040: PPUSH
23041: LD_VAR 0 6
23045: PUSH
23046: LD_VAR 0 8
23050: PUSH
23051: EMPTY
23052: LIST
23053: LIST
23054: PPUSH
23055: CALL_OW 2
23059: ST_TO_ADDR
// break ;
23060: GO 23064
// end ; end ;
23062: GO 23001
23064: POP
23065: POP
// end ; end ;
23066: GO 22849
23068: POP
23069: POP
// if result and not asc then
23070: LD_VAR 0 5
23074: PUSH
23075: LD_VAR 0 3
23079: NOT
23080: AND
23081: IFFALSE 23098
// result := ReverseArray ( result ) ;
23083: LD_ADDR_VAR 0 5
23087: PUSH
23088: LD_VAR 0 5
23092: PPUSH
23093: CALL 50338 0 1
23097: ST_TO_ADDR
// tmp := [ ] ;
23098: LD_ADDR_VAR 0 8
23102: PUSH
23103: EMPTY
23104: ST_TO_ADDR
// if mode then
23105: LD_VAR 0 4
23109: IFFALSE 23173
// begin for i := 1 to result do
23111: LD_ADDR_VAR 0 6
23115: PUSH
23116: DOUBLE
23117: LD_INT 1
23119: DEC
23120: ST_TO_ADDR
23121: LD_VAR 0 5
23125: PUSH
23126: FOR_TO
23127: IFFALSE 23161
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
23129: LD_ADDR_VAR 0 8
23133: PUSH
23134: LD_VAR 0 8
23138: PPUSH
23139: LD_VAR 0 5
23143: PUSH
23144: LD_VAR 0 6
23148: ARRAY
23149: PUSH
23150: LD_INT 1
23152: ARRAY
23153: PPUSH
23154: CALL 55071 0 2
23158: ST_TO_ADDR
23159: GO 23126
23161: POP
23162: POP
// result := tmp ;
23163: LD_ADDR_VAR 0 5
23167: PUSH
23168: LD_VAR 0 8
23172: ST_TO_ADDR
// end ; end ;
23173: LD_VAR 0 5
23177: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
23178: LD_INT 0
23180: PPUSH
23181: PPUSH
23182: PPUSH
23183: PPUSH
// if not list then
23184: LD_VAR 0 3
23188: NOT
23189: IFFALSE 23193
// exit ;
23191: GO 23581
// result := [ ] ;
23193: LD_ADDR_VAR 0 6
23197: PUSH
23198: EMPTY
23199: ST_TO_ADDR
// for i in list do
23200: LD_ADDR_VAR 0 7
23204: PUSH
23205: LD_VAR 0 3
23209: PUSH
23210: FOR_IN
23211: IFFALSE 23413
// begin tmp := GetDistUnitXY ( i , x , y ) ;
23213: LD_ADDR_VAR 0 9
23217: PUSH
23218: LD_VAR 0 7
23222: PPUSH
23223: LD_VAR 0 1
23227: PPUSH
23228: LD_VAR 0 2
23232: PPUSH
23233: CALL_OW 297
23237: ST_TO_ADDR
// if not result then
23238: LD_VAR 0 6
23242: NOT
23243: IFFALSE 23269
// result := [ [ i , tmp ] ] else
23245: LD_ADDR_VAR 0 6
23249: PUSH
23250: LD_VAR 0 7
23254: PUSH
23255: LD_VAR 0 9
23259: PUSH
23260: EMPTY
23261: LIST
23262: LIST
23263: PUSH
23264: EMPTY
23265: LIST
23266: ST_TO_ADDR
23267: GO 23411
// begin if result [ result ] [ 2 ] <= tmp then
23269: LD_VAR 0 6
23273: PUSH
23274: LD_VAR 0 6
23278: ARRAY
23279: PUSH
23280: LD_INT 2
23282: ARRAY
23283: PUSH
23284: LD_VAR 0 9
23288: LESSEQUAL
23289: IFFALSE 23331
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
23291: LD_ADDR_VAR 0 6
23295: PUSH
23296: LD_VAR 0 6
23300: PPUSH
23301: LD_VAR 0 6
23305: PUSH
23306: LD_INT 1
23308: PLUS
23309: PPUSH
23310: LD_VAR 0 7
23314: PUSH
23315: LD_VAR 0 9
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: PPUSH
23324: CALL_OW 2
23328: ST_TO_ADDR
23329: GO 23411
// for j := 1 to result do
23331: LD_ADDR_VAR 0 8
23335: PUSH
23336: DOUBLE
23337: LD_INT 1
23339: DEC
23340: ST_TO_ADDR
23341: LD_VAR 0 6
23345: PUSH
23346: FOR_TO
23347: IFFALSE 23409
// begin if tmp < result [ j ] [ 2 ] then
23349: LD_VAR 0 9
23353: PUSH
23354: LD_VAR 0 6
23358: PUSH
23359: LD_VAR 0 8
23363: ARRAY
23364: PUSH
23365: LD_INT 2
23367: ARRAY
23368: LESS
23369: IFFALSE 23407
// begin result := Insert ( result , j , [ i , tmp ] ) ;
23371: LD_ADDR_VAR 0 6
23375: PUSH
23376: LD_VAR 0 6
23380: PPUSH
23381: LD_VAR 0 8
23385: PPUSH
23386: LD_VAR 0 7
23390: PUSH
23391: LD_VAR 0 9
23395: PUSH
23396: EMPTY
23397: LIST
23398: LIST
23399: PPUSH
23400: CALL_OW 2
23404: ST_TO_ADDR
// break ;
23405: GO 23409
// end ; end ;
23407: GO 23346
23409: POP
23410: POP
// end ; end ;
23411: GO 23210
23413: POP
23414: POP
// if result and not asc then
23415: LD_VAR 0 6
23419: PUSH
23420: LD_VAR 0 4
23424: NOT
23425: AND
23426: IFFALSE 23501
// begin tmp := result ;
23428: LD_ADDR_VAR 0 9
23432: PUSH
23433: LD_VAR 0 6
23437: ST_TO_ADDR
// for i = tmp downto 1 do
23438: LD_ADDR_VAR 0 7
23442: PUSH
23443: DOUBLE
23444: LD_VAR 0 9
23448: INC
23449: ST_TO_ADDR
23450: LD_INT 1
23452: PUSH
23453: FOR_DOWNTO
23454: IFFALSE 23499
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
23456: LD_ADDR_VAR 0 6
23460: PUSH
23461: LD_VAR 0 6
23465: PPUSH
23466: LD_VAR 0 9
23470: PUSH
23471: LD_VAR 0 7
23475: MINUS
23476: PUSH
23477: LD_INT 1
23479: PLUS
23480: PPUSH
23481: LD_VAR 0 9
23485: PUSH
23486: LD_VAR 0 7
23490: ARRAY
23491: PPUSH
23492: CALL_OW 1
23496: ST_TO_ADDR
23497: GO 23453
23499: POP
23500: POP
// end ; tmp := [ ] ;
23501: LD_ADDR_VAR 0 9
23505: PUSH
23506: EMPTY
23507: ST_TO_ADDR
// if mode then
23508: LD_VAR 0 5
23512: IFFALSE 23581
// begin for i = 1 to result do
23514: LD_ADDR_VAR 0 7
23518: PUSH
23519: DOUBLE
23520: LD_INT 1
23522: DEC
23523: ST_TO_ADDR
23524: LD_VAR 0 6
23528: PUSH
23529: FOR_TO
23530: IFFALSE 23569
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
23532: LD_ADDR_VAR 0 9
23536: PUSH
23537: LD_VAR 0 9
23541: PPUSH
23542: LD_VAR 0 7
23546: PPUSH
23547: LD_VAR 0 6
23551: PUSH
23552: LD_VAR 0 7
23556: ARRAY
23557: PUSH
23558: LD_INT 1
23560: ARRAY
23561: PPUSH
23562: CALL_OW 1
23566: ST_TO_ADDR
23567: GO 23529
23569: POP
23570: POP
// result := tmp ;
23571: LD_ADDR_VAR 0 6
23575: PUSH
23576: LD_VAR 0 9
23580: ST_TO_ADDR
// end ; end ;
23581: LD_VAR 0 6
23585: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
23586: LD_INT 0
23588: PPUSH
23589: PPUSH
23590: PPUSH
23591: PPUSH
23592: PPUSH
23593: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
23594: LD_ADDR_VAR 0 5
23598: PUSH
23599: LD_INT 0
23601: PUSH
23602: LD_INT 0
23604: PUSH
23605: LD_INT 0
23607: PUSH
23608: EMPTY
23609: PUSH
23610: EMPTY
23611: LIST
23612: LIST
23613: LIST
23614: LIST
23615: ST_TO_ADDR
// if not x or not y then
23616: LD_VAR 0 2
23620: NOT
23621: PUSH
23622: LD_VAR 0 3
23626: NOT
23627: OR
23628: IFFALSE 23632
// exit ;
23630: GO 25282
// if not range then
23632: LD_VAR 0 4
23636: NOT
23637: IFFALSE 23647
// range := 10 ;
23639: LD_ADDR_VAR 0 4
23643: PUSH
23644: LD_INT 10
23646: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
23647: LD_ADDR_VAR 0 8
23651: PUSH
23652: LD_INT 81
23654: PUSH
23655: LD_VAR 0 1
23659: PUSH
23660: EMPTY
23661: LIST
23662: LIST
23663: PUSH
23664: LD_INT 92
23666: PUSH
23667: LD_VAR 0 2
23671: PUSH
23672: LD_VAR 0 3
23676: PUSH
23677: LD_VAR 0 4
23681: PUSH
23682: EMPTY
23683: LIST
23684: LIST
23685: LIST
23686: LIST
23687: PUSH
23688: LD_INT 3
23690: PUSH
23691: LD_INT 21
23693: PUSH
23694: LD_INT 3
23696: PUSH
23697: EMPTY
23698: LIST
23699: LIST
23700: PUSH
23701: EMPTY
23702: LIST
23703: LIST
23704: PUSH
23705: EMPTY
23706: LIST
23707: LIST
23708: LIST
23709: PPUSH
23710: CALL_OW 69
23714: ST_TO_ADDR
// if not tmp then
23715: LD_VAR 0 8
23719: NOT
23720: IFFALSE 23724
// exit ;
23722: GO 25282
// for i in tmp do
23724: LD_ADDR_VAR 0 6
23728: PUSH
23729: LD_VAR 0 8
23733: PUSH
23734: FOR_IN
23735: IFFALSE 25257
// begin points := [ 0 , 0 , 0 ] ;
23737: LD_ADDR_VAR 0 9
23741: PUSH
23742: LD_INT 0
23744: PUSH
23745: LD_INT 0
23747: PUSH
23748: LD_INT 0
23750: PUSH
23751: EMPTY
23752: LIST
23753: LIST
23754: LIST
23755: ST_TO_ADDR
// bpoints := 1 ;
23756: LD_ADDR_VAR 0 10
23760: PUSH
23761: LD_INT 1
23763: ST_TO_ADDR
// case GetType ( i ) of unit_human :
23764: LD_VAR 0 6
23768: PPUSH
23769: CALL_OW 247
23773: PUSH
23774: LD_INT 1
23776: DOUBLE
23777: EQUAL
23778: IFTRUE 23782
23780: GO 24360
23782: POP
// begin if GetClass ( i ) = 1 then
23783: LD_VAR 0 6
23787: PPUSH
23788: CALL_OW 257
23792: PUSH
23793: LD_INT 1
23795: EQUAL
23796: IFFALSE 23817
// points := [ 10 , 5 , 3 ] ;
23798: LD_ADDR_VAR 0 9
23802: PUSH
23803: LD_INT 10
23805: PUSH
23806: LD_INT 5
23808: PUSH
23809: LD_INT 3
23811: PUSH
23812: EMPTY
23813: LIST
23814: LIST
23815: LIST
23816: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
23817: LD_VAR 0 6
23821: PPUSH
23822: CALL_OW 257
23826: PUSH
23827: LD_INT 2
23829: PUSH
23830: LD_INT 3
23832: PUSH
23833: LD_INT 4
23835: PUSH
23836: EMPTY
23837: LIST
23838: LIST
23839: LIST
23840: IN
23841: IFFALSE 23862
// points := [ 3 , 2 , 1 ] ;
23843: LD_ADDR_VAR 0 9
23847: PUSH
23848: LD_INT 3
23850: PUSH
23851: LD_INT 2
23853: PUSH
23854: LD_INT 1
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: LIST
23861: ST_TO_ADDR
// if GetClass ( i ) = 5 then
23862: LD_VAR 0 6
23866: PPUSH
23867: CALL_OW 257
23871: PUSH
23872: LD_INT 5
23874: EQUAL
23875: IFFALSE 23896
// points := [ 130 , 5 , 2 ] ;
23877: LD_ADDR_VAR 0 9
23881: PUSH
23882: LD_INT 130
23884: PUSH
23885: LD_INT 5
23887: PUSH
23888: LD_INT 2
23890: PUSH
23891: EMPTY
23892: LIST
23893: LIST
23894: LIST
23895: ST_TO_ADDR
// if GetClass ( i ) = 8 then
23896: LD_VAR 0 6
23900: PPUSH
23901: CALL_OW 257
23905: PUSH
23906: LD_INT 8
23908: EQUAL
23909: IFFALSE 23930
// points := [ 35 , 35 , 30 ] ;
23911: LD_ADDR_VAR 0 9
23915: PUSH
23916: LD_INT 35
23918: PUSH
23919: LD_INT 35
23921: PUSH
23922: LD_INT 30
23924: PUSH
23925: EMPTY
23926: LIST
23927: LIST
23928: LIST
23929: ST_TO_ADDR
// if GetClass ( i ) = 9 then
23930: LD_VAR 0 6
23934: PPUSH
23935: CALL_OW 257
23939: PUSH
23940: LD_INT 9
23942: EQUAL
23943: IFFALSE 23964
// points := [ 20 , 55 , 40 ] ;
23945: LD_ADDR_VAR 0 9
23949: PUSH
23950: LD_INT 20
23952: PUSH
23953: LD_INT 55
23955: PUSH
23956: LD_INT 40
23958: PUSH
23959: EMPTY
23960: LIST
23961: LIST
23962: LIST
23963: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
23964: LD_VAR 0 6
23968: PPUSH
23969: CALL_OW 257
23973: PUSH
23974: LD_INT 12
23976: PUSH
23977: LD_INT 16
23979: PUSH
23980: EMPTY
23981: LIST
23982: LIST
23983: IN
23984: IFFALSE 24005
// points := [ 5 , 3 , 2 ] ;
23986: LD_ADDR_VAR 0 9
23990: PUSH
23991: LD_INT 5
23993: PUSH
23994: LD_INT 3
23996: PUSH
23997: LD_INT 2
23999: PUSH
24000: EMPTY
24001: LIST
24002: LIST
24003: LIST
24004: ST_TO_ADDR
// if GetClass ( i ) = 17 then
24005: LD_VAR 0 6
24009: PPUSH
24010: CALL_OW 257
24014: PUSH
24015: LD_INT 17
24017: EQUAL
24018: IFFALSE 24039
// points := [ 100 , 50 , 75 ] ;
24020: LD_ADDR_VAR 0 9
24024: PUSH
24025: LD_INT 100
24027: PUSH
24028: LD_INT 50
24030: PUSH
24031: LD_INT 75
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: ST_TO_ADDR
// if GetClass ( i ) = 15 then
24039: LD_VAR 0 6
24043: PPUSH
24044: CALL_OW 257
24048: PUSH
24049: LD_INT 15
24051: EQUAL
24052: IFFALSE 24073
// points := [ 10 , 5 , 3 ] ;
24054: LD_ADDR_VAR 0 9
24058: PUSH
24059: LD_INT 10
24061: PUSH
24062: LD_INT 5
24064: PUSH
24065: LD_INT 3
24067: PUSH
24068: EMPTY
24069: LIST
24070: LIST
24071: LIST
24072: ST_TO_ADDR
// if GetClass ( i ) = 14 then
24073: LD_VAR 0 6
24077: PPUSH
24078: CALL_OW 257
24082: PUSH
24083: LD_INT 14
24085: EQUAL
24086: IFFALSE 24107
// points := [ 10 , 0 , 0 ] ;
24088: LD_ADDR_VAR 0 9
24092: PUSH
24093: LD_INT 10
24095: PUSH
24096: LD_INT 0
24098: PUSH
24099: LD_INT 0
24101: PUSH
24102: EMPTY
24103: LIST
24104: LIST
24105: LIST
24106: ST_TO_ADDR
// if GetClass ( i ) = 11 then
24107: LD_VAR 0 6
24111: PPUSH
24112: CALL_OW 257
24116: PUSH
24117: LD_INT 11
24119: EQUAL
24120: IFFALSE 24141
// points := [ 30 , 10 , 5 ] ;
24122: LD_ADDR_VAR 0 9
24126: PUSH
24127: LD_INT 30
24129: PUSH
24130: LD_INT 10
24132: PUSH
24133: LD_INT 5
24135: PUSH
24136: EMPTY
24137: LIST
24138: LIST
24139: LIST
24140: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
24141: LD_VAR 0 1
24145: PPUSH
24146: LD_INT 5
24148: PPUSH
24149: CALL_OW 321
24153: PUSH
24154: LD_INT 2
24156: EQUAL
24157: IFFALSE 24174
// bpoints := bpoints * 1.8 ;
24159: LD_ADDR_VAR 0 10
24163: PUSH
24164: LD_VAR 0 10
24168: PUSH
24169: LD_REAL  1.80000000000000E+0000
24172: MUL
24173: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
24174: LD_VAR 0 6
24178: PPUSH
24179: CALL_OW 257
24183: PUSH
24184: LD_INT 1
24186: PUSH
24187: LD_INT 2
24189: PUSH
24190: LD_INT 3
24192: PUSH
24193: LD_INT 4
24195: PUSH
24196: EMPTY
24197: LIST
24198: LIST
24199: LIST
24200: LIST
24201: IN
24202: PUSH
24203: LD_VAR 0 1
24207: PPUSH
24208: LD_INT 51
24210: PPUSH
24211: CALL_OW 321
24215: PUSH
24216: LD_INT 2
24218: EQUAL
24219: AND
24220: IFFALSE 24237
// bpoints := bpoints * 1.2 ;
24222: LD_ADDR_VAR 0 10
24226: PUSH
24227: LD_VAR 0 10
24231: PUSH
24232: LD_REAL  1.20000000000000E+0000
24235: MUL
24236: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
24237: LD_VAR 0 6
24241: PPUSH
24242: CALL_OW 257
24246: PUSH
24247: LD_INT 5
24249: PUSH
24250: LD_INT 7
24252: PUSH
24253: LD_INT 9
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: LIST
24260: IN
24261: PUSH
24262: LD_VAR 0 1
24266: PPUSH
24267: LD_INT 52
24269: PPUSH
24270: CALL_OW 321
24274: PUSH
24275: LD_INT 2
24277: EQUAL
24278: AND
24279: IFFALSE 24296
// bpoints := bpoints * 1.5 ;
24281: LD_ADDR_VAR 0 10
24285: PUSH
24286: LD_VAR 0 10
24290: PUSH
24291: LD_REAL  1.50000000000000E+0000
24294: MUL
24295: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
24296: LD_VAR 0 1
24300: PPUSH
24301: LD_INT 66
24303: PPUSH
24304: CALL_OW 321
24308: PUSH
24309: LD_INT 2
24311: EQUAL
24312: IFFALSE 24329
// bpoints := bpoints * 1.1 ;
24314: LD_ADDR_VAR 0 10
24318: PUSH
24319: LD_VAR 0 10
24323: PUSH
24324: LD_REAL  1.10000000000000E+0000
24327: MUL
24328: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
24329: LD_ADDR_VAR 0 10
24333: PUSH
24334: LD_VAR 0 10
24338: PUSH
24339: LD_VAR 0 6
24343: PPUSH
24344: LD_INT 1
24346: PPUSH
24347: CALL_OW 259
24351: PUSH
24352: LD_REAL  1.15000000000000E+0000
24355: MUL
24356: MUL
24357: ST_TO_ADDR
// end ; unit_vehicle :
24358: GO 25186
24360: LD_INT 2
24362: DOUBLE
24363: EQUAL
24364: IFTRUE 24368
24366: GO 25174
24368: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
24369: LD_VAR 0 6
24373: PPUSH
24374: CALL_OW 264
24378: PUSH
24379: LD_INT 2
24381: PUSH
24382: LD_INT 42
24384: PUSH
24385: LD_INT 24
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: LIST
24392: IN
24393: IFFALSE 24414
// points := [ 25 , 5 , 3 ] ;
24395: LD_ADDR_VAR 0 9
24399: PUSH
24400: LD_INT 25
24402: PUSH
24403: LD_INT 5
24405: PUSH
24406: LD_INT 3
24408: PUSH
24409: EMPTY
24410: LIST
24411: LIST
24412: LIST
24413: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
24414: LD_VAR 0 6
24418: PPUSH
24419: CALL_OW 264
24423: PUSH
24424: LD_INT 4
24426: PUSH
24427: LD_INT 43
24429: PUSH
24430: LD_INT 25
24432: PUSH
24433: EMPTY
24434: LIST
24435: LIST
24436: LIST
24437: IN
24438: IFFALSE 24459
// points := [ 40 , 15 , 5 ] ;
24440: LD_ADDR_VAR 0 9
24444: PUSH
24445: LD_INT 40
24447: PUSH
24448: LD_INT 15
24450: PUSH
24451: LD_INT 5
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: LIST
24458: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
24459: LD_VAR 0 6
24463: PPUSH
24464: CALL_OW 264
24468: PUSH
24469: LD_INT 3
24471: PUSH
24472: LD_INT 23
24474: PUSH
24475: EMPTY
24476: LIST
24477: LIST
24478: IN
24479: IFFALSE 24500
// points := [ 7 , 25 , 8 ] ;
24481: LD_ADDR_VAR 0 9
24485: PUSH
24486: LD_INT 7
24488: PUSH
24489: LD_INT 25
24491: PUSH
24492: LD_INT 8
24494: PUSH
24495: EMPTY
24496: LIST
24497: LIST
24498: LIST
24499: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
24500: LD_VAR 0 6
24504: PPUSH
24505: CALL_OW 264
24509: PUSH
24510: LD_INT 5
24512: PUSH
24513: LD_INT 27
24515: PUSH
24516: LD_INT 44
24518: PUSH
24519: EMPTY
24520: LIST
24521: LIST
24522: LIST
24523: IN
24524: IFFALSE 24545
// points := [ 14 , 50 , 16 ] ;
24526: LD_ADDR_VAR 0 9
24530: PUSH
24531: LD_INT 14
24533: PUSH
24534: LD_INT 50
24536: PUSH
24537: LD_INT 16
24539: PUSH
24540: EMPTY
24541: LIST
24542: LIST
24543: LIST
24544: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
24545: LD_VAR 0 6
24549: PPUSH
24550: CALL_OW 264
24554: PUSH
24555: LD_INT 6
24557: PUSH
24558: LD_INT 46
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: IN
24565: IFFALSE 24586
// points := [ 32 , 120 , 70 ] ;
24567: LD_ADDR_VAR 0 9
24571: PUSH
24572: LD_INT 32
24574: PUSH
24575: LD_INT 120
24577: PUSH
24578: LD_INT 70
24580: PUSH
24581: EMPTY
24582: LIST
24583: LIST
24584: LIST
24585: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
24586: LD_VAR 0 6
24590: PPUSH
24591: CALL_OW 264
24595: PUSH
24596: LD_INT 7
24598: PUSH
24599: LD_INT 28
24601: PUSH
24602: LD_INT 45
24604: PUSH
24605: LD_INT 92
24607: PUSH
24608: EMPTY
24609: LIST
24610: LIST
24611: LIST
24612: LIST
24613: IN
24614: IFFALSE 24635
// points := [ 35 , 20 , 45 ] ;
24616: LD_ADDR_VAR 0 9
24620: PUSH
24621: LD_INT 35
24623: PUSH
24624: LD_INT 20
24626: PUSH
24627: LD_INT 45
24629: PUSH
24630: EMPTY
24631: LIST
24632: LIST
24633: LIST
24634: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
24635: LD_VAR 0 6
24639: PPUSH
24640: CALL_OW 264
24644: PUSH
24645: LD_INT 47
24647: PUSH
24648: EMPTY
24649: LIST
24650: IN
24651: IFFALSE 24672
// points := [ 67 , 45 , 75 ] ;
24653: LD_ADDR_VAR 0 9
24657: PUSH
24658: LD_INT 67
24660: PUSH
24661: LD_INT 45
24663: PUSH
24664: LD_INT 75
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: LIST
24671: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
24672: LD_VAR 0 6
24676: PPUSH
24677: CALL_OW 264
24681: PUSH
24682: LD_INT 26
24684: PUSH
24685: EMPTY
24686: LIST
24687: IN
24688: IFFALSE 24709
// points := [ 120 , 30 , 80 ] ;
24690: LD_ADDR_VAR 0 9
24694: PUSH
24695: LD_INT 120
24697: PUSH
24698: LD_INT 30
24700: PUSH
24701: LD_INT 80
24703: PUSH
24704: EMPTY
24705: LIST
24706: LIST
24707: LIST
24708: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
24709: LD_VAR 0 6
24713: PPUSH
24714: CALL_OW 264
24718: PUSH
24719: LD_INT 22
24721: PUSH
24722: EMPTY
24723: LIST
24724: IN
24725: IFFALSE 24746
// points := [ 40 , 1 , 1 ] ;
24727: LD_ADDR_VAR 0 9
24731: PUSH
24732: LD_INT 40
24734: PUSH
24735: LD_INT 1
24737: PUSH
24738: LD_INT 1
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: LIST
24745: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
24746: LD_VAR 0 6
24750: PPUSH
24751: CALL_OW 264
24755: PUSH
24756: LD_INT 29
24758: PUSH
24759: EMPTY
24760: LIST
24761: IN
24762: IFFALSE 24783
// points := [ 70 , 200 , 400 ] ;
24764: LD_ADDR_VAR 0 9
24768: PUSH
24769: LD_INT 70
24771: PUSH
24772: LD_INT 200
24774: PUSH
24775: LD_INT 400
24777: PUSH
24778: EMPTY
24779: LIST
24780: LIST
24781: LIST
24782: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
24783: LD_VAR 0 6
24787: PPUSH
24788: CALL_OW 264
24792: PUSH
24793: LD_INT 14
24795: PUSH
24796: LD_INT 53
24798: PUSH
24799: EMPTY
24800: LIST
24801: LIST
24802: IN
24803: IFFALSE 24824
// points := [ 40 , 10 , 20 ] ;
24805: LD_ADDR_VAR 0 9
24809: PUSH
24810: LD_INT 40
24812: PUSH
24813: LD_INT 10
24815: PUSH
24816: LD_INT 20
24818: PUSH
24819: EMPTY
24820: LIST
24821: LIST
24822: LIST
24823: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
24824: LD_VAR 0 6
24828: PPUSH
24829: CALL_OW 264
24833: PUSH
24834: LD_INT 9
24836: PUSH
24837: EMPTY
24838: LIST
24839: IN
24840: IFFALSE 24861
// points := [ 5 , 70 , 20 ] ;
24842: LD_ADDR_VAR 0 9
24846: PUSH
24847: LD_INT 5
24849: PUSH
24850: LD_INT 70
24852: PUSH
24853: LD_INT 20
24855: PUSH
24856: EMPTY
24857: LIST
24858: LIST
24859: LIST
24860: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
24861: LD_VAR 0 6
24865: PPUSH
24866: CALL_OW 264
24870: PUSH
24871: LD_INT 10
24873: PUSH
24874: EMPTY
24875: LIST
24876: IN
24877: IFFALSE 24898
// points := [ 35 , 110 , 70 ] ;
24879: LD_ADDR_VAR 0 9
24883: PUSH
24884: LD_INT 35
24886: PUSH
24887: LD_INT 110
24889: PUSH
24890: LD_INT 70
24892: PUSH
24893: EMPTY
24894: LIST
24895: LIST
24896: LIST
24897: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
24898: LD_VAR 0 6
24902: PPUSH
24903: CALL_OW 265
24907: PUSH
24908: LD_INT 25
24910: EQUAL
24911: IFFALSE 24932
// points := [ 80 , 65 , 100 ] ;
24913: LD_ADDR_VAR 0 9
24917: PUSH
24918: LD_INT 80
24920: PUSH
24921: LD_INT 65
24923: PUSH
24924: LD_INT 100
24926: PUSH
24927: EMPTY
24928: LIST
24929: LIST
24930: LIST
24931: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
24932: LD_VAR 0 6
24936: PPUSH
24937: CALL_OW 263
24941: PUSH
24942: LD_INT 1
24944: EQUAL
24945: IFFALSE 24980
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
24947: LD_ADDR_VAR 0 10
24951: PUSH
24952: LD_VAR 0 10
24956: PUSH
24957: LD_VAR 0 6
24961: PPUSH
24962: CALL_OW 311
24966: PPUSH
24967: LD_INT 3
24969: PPUSH
24970: CALL_OW 259
24974: PUSH
24975: LD_INT 4
24977: MUL
24978: MUL
24979: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
24980: LD_VAR 0 6
24984: PPUSH
24985: CALL_OW 263
24989: PUSH
24990: LD_INT 2
24992: EQUAL
24993: IFFALSE 25044
// begin j := IsControledBy ( i ) ;
24995: LD_ADDR_VAR 0 7
24999: PUSH
25000: LD_VAR 0 6
25004: PPUSH
25005: CALL_OW 312
25009: ST_TO_ADDR
// if j then
25010: LD_VAR 0 7
25014: IFFALSE 25044
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
25016: LD_ADDR_VAR 0 10
25020: PUSH
25021: LD_VAR 0 10
25025: PUSH
25026: LD_VAR 0 7
25030: PPUSH
25031: LD_INT 3
25033: PPUSH
25034: CALL_OW 259
25038: PUSH
25039: LD_INT 3
25041: MUL
25042: MUL
25043: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
25044: LD_VAR 0 6
25048: PPUSH
25049: CALL_OW 264
25053: PUSH
25054: LD_INT 5
25056: PUSH
25057: LD_INT 6
25059: PUSH
25060: LD_INT 46
25062: PUSH
25063: LD_INT 44
25065: PUSH
25066: LD_INT 47
25068: PUSH
25069: LD_INT 45
25071: PUSH
25072: LD_INT 28
25074: PUSH
25075: LD_INT 7
25077: PUSH
25078: LD_INT 27
25080: PUSH
25081: LD_INT 29
25083: PUSH
25084: EMPTY
25085: LIST
25086: LIST
25087: LIST
25088: LIST
25089: LIST
25090: LIST
25091: LIST
25092: LIST
25093: LIST
25094: LIST
25095: IN
25096: PUSH
25097: LD_VAR 0 1
25101: PPUSH
25102: LD_INT 52
25104: PPUSH
25105: CALL_OW 321
25109: PUSH
25110: LD_INT 2
25112: EQUAL
25113: AND
25114: IFFALSE 25131
// bpoints := bpoints * 1.2 ;
25116: LD_ADDR_VAR 0 10
25120: PUSH
25121: LD_VAR 0 10
25125: PUSH
25126: LD_REAL  1.20000000000000E+0000
25129: MUL
25130: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
25131: LD_VAR 0 6
25135: PPUSH
25136: CALL_OW 264
25140: PUSH
25141: LD_INT 6
25143: PUSH
25144: LD_INT 46
25146: PUSH
25147: LD_INT 47
25149: PUSH
25150: EMPTY
25151: LIST
25152: LIST
25153: LIST
25154: IN
25155: IFFALSE 25172
// bpoints := bpoints * 1.2 ;
25157: LD_ADDR_VAR 0 10
25161: PUSH
25162: LD_VAR 0 10
25166: PUSH
25167: LD_REAL  1.20000000000000E+0000
25170: MUL
25171: ST_TO_ADDR
// end ; unit_building :
25172: GO 25186
25174: LD_INT 3
25176: DOUBLE
25177: EQUAL
25178: IFTRUE 25182
25180: GO 25185
25182: POP
// ; end ;
25183: GO 25186
25185: POP
// for j = 1 to 3 do
25186: LD_ADDR_VAR 0 7
25190: PUSH
25191: DOUBLE
25192: LD_INT 1
25194: DEC
25195: ST_TO_ADDR
25196: LD_INT 3
25198: PUSH
25199: FOR_TO
25200: IFFALSE 25253
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
25202: LD_ADDR_VAR 0 5
25206: PUSH
25207: LD_VAR 0 5
25211: PPUSH
25212: LD_VAR 0 7
25216: PPUSH
25217: LD_VAR 0 5
25221: PUSH
25222: LD_VAR 0 7
25226: ARRAY
25227: PUSH
25228: LD_VAR 0 9
25232: PUSH
25233: LD_VAR 0 7
25237: ARRAY
25238: PUSH
25239: LD_VAR 0 10
25243: MUL
25244: PLUS
25245: PPUSH
25246: CALL_OW 1
25250: ST_TO_ADDR
25251: GO 25199
25253: POP
25254: POP
// end ;
25255: GO 23734
25257: POP
25258: POP
// result := Replace ( result , 4 , tmp ) ;
25259: LD_ADDR_VAR 0 5
25263: PUSH
25264: LD_VAR 0 5
25268: PPUSH
25269: LD_INT 4
25271: PPUSH
25272: LD_VAR 0 8
25276: PPUSH
25277: CALL_OW 1
25281: ST_TO_ADDR
// end ;
25282: LD_VAR 0 5
25286: RET
// export function DangerAtRange ( unit , range ) ; begin
25287: LD_INT 0
25289: PPUSH
// if not unit then
25290: LD_VAR 0 1
25294: NOT
25295: IFFALSE 25299
// exit ;
25297: GO 25344
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
25299: LD_ADDR_VAR 0 3
25303: PUSH
25304: LD_VAR 0 1
25308: PPUSH
25309: CALL_OW 255
25313: PPUSH
25314: LD_VAR 0 1
25318: PPUSH
25319: CALL_OW 250
25323: PPUSH
25324: LD_VAR 0 1
25328: PPUSH
25329: CALL_OW 251
25333: PPUSH
25334: LD_VAR 0 2
25338: PPUSH
25339: CALL 23586 0 4
25343: ST_TO_ADDR
// end ;
25344: LD_VAR 0 3
25348: RET
// export function DangerInArea ( side , area ) ; begin
25349: LD_INT 0
25351: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
25352: LD_ADDR_VAR 0 3
25356: PUSH
25357: LD_VAR 0 2
25361: PPUSH
25362: LD_INT 81
25364: PUSH
25365: LD_VAR 0 1
25369: PUSH
25370: EMPTY
25371: LIST
25372: LIST
25373: PPUSH
25374: CALL_OW 70
25378: ST_TO_ADDR
// end ;
25379: LD_VAR 0 3
25383: RET
// export function IsExtension ( b ) ; begin
25384: LD_INT 0
25386: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
25387: LD_ADDR_VAR 0 2
25391: PUSH
25392: LD_VAR 0 1
25396: PUSH
25397: LD_INT 23
25399: PUSH
25400: LD_INT 20
25402: PUSH
25403: LD_INT 22
25405: PUSH
25406: LD_INT 17
25408: PUSH
25409: LD_INT 24
25411: PUSH
25412: LD_INT 21
25414: PUSH
25415: LD_INT 19
25417: PUSH
25418: LD_INT 16
25420: PUSH
25421: LD_INT 25
25423: PUSH
25424: LD_INT 18
25426: PUSH
25427: EMPTY
25428: LIST
25429: LIST
25430: LIST
25431: LIST
25432: LIST
25433: LIST
25434: LIST
25435: LIST
25436: LIST
25437: LIST
25438: IN
25439: ST_TO_ADDR
// end ;
25440: LD_VAR 0 2
25444: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
25445: LD_INT 0
25447: PPUSH
25448: PPUSH
25449: PPUSH
// result := [ ] ;
25450: LD_ADDR_VAR 0 4
25454: PUSH
25455: EMPTY
25456: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
25457: LD_ADDR_VAR 0 5
25461: PUSH
25462: LD_VAR 0 2
25466: PPUSH
25467: LD_INT 21
25469: PUSH
25470: LD_INT 3
25472: PUSH
25473: EMPTY
25474: LIST
25475: LIST
25476: PPUSH
25477: CALL_OW 70
25481: ST_TO_ADDR
// if not tmp then
25482: LD_VAR 0 5
25486: NOT
25487: IFFALSE 25491
// exit ;
25489: GO 25555
// if checkLink then
25491: LD_VAR 0 3
25495: IFFALSE 25545
// begin for i in tmp do
25497: LD_ADDR_VAR 0 6
25501: PUSH
25502: LD_VAR 0 5
25506: PUSH
25507: FOR_IN
25508: IFFALSE 25543
// if GetBase ( i ) <> base then
25510: LD_VAR 0 6
25514: PPUSH
25515: CALL_OW 274
25519: PUSH
25520: LD_VAR 0 1
25524: NONEQUAL
25525: IFFALSE 25541
// ComLinkToBase ( base , i ) ;
25527: LD_VAR 0 1
25531: PPUSH
25532: LD_VAR 0 6
25536: PPUSH
25537: CALL_OW 169
25541: GO 25507
25543: POP
25544: POP
// end ; result := tmp ;
25545: LD_ADDR_VAR 0 4
25549: PUSH
25550: LD_VAR 0 5
25554: ST_TO_ADDR
// end ;
25555: LD_VAR 0 4
25559: RET
// export function ComComplete ( units , b ) ; var i ; begin
25560: LD_INT 0
25562: PPUSH
25563: PPUSH
// if not units then
25564: LD_VAR 0 1
25568: NOT
25569: IFFALSE 25573
// exit ;
25571: GO 25663
// for i in units do
25573: LD_ADDR_VAR 0 4
25577: PUSH
25578: LD_VAR 0 1
25582: PUSH
25583: FOR_IN
25584: IFFALSE 25661
// if BuildingStatus ( b ) = bs_build then
25586: LD_VAR 0 2
25590: PPUSH
25591: CALL_OW 461
25595: PUSH
25596: LD_INT 1
25598: EQUAL
25599: IFFALSE 25659
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
25601: LD_VAR 0 4
25605: PPUSH
25606: LD_STRING h
25608: PUSH
25609: LD_VAR 0 2
25613: PPUSH
25614: CALL_OW 250
25618: PUSH
25619: LD_VAR 0 2
25623: PPUSH
25624: CALL_OW 251
25628: PUSH
25629: LD_VAR 0 2
25633: PUSH
25634: LD_INT 0
25636: PUSH
25637: LD_INT 0
25639: PUSH
25640: LD_INT 0
25642: PUSH
25643: EMPTY
25644: LIST
25645: LIST
25646: LIST
25647: LIST
25648: LIST
25649: LIST
25650: LIST
25651: PUSH
25652: EMPTY
25653: LIST
25654: PPUSH
25655: CALL_OW 446
25659: GO 25583
25661: POP
25662: POP
// end ;
25663: LD_VAR 0 3
25667: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
25668: LD_INT 0
25670: PPUSH
25671: PPUSH
25672: PPUSH
25673: PPUSH
25674: PPUSH
25675: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
25676: LD_VAR 0 1
25680: NOT
25681: PUSH
25682: LD_VAR 0 1
25686: PPUSH
25687: CALL_OW 263
25691: PUSH
25692: LD_INT 2
25694: NONEQUAL
25695: OR
25696: IFFALSE 25700
// exit ;
25698: GO 26016
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
25700: LD_ADDR_VAR 0 6
25704: PUSH
25705: LD_INT 22
25707: PUSH
25708: LD_VAR 0 1
25712: PPUSH
25713: CALL_OW 255
25717: PUSH
25718: EMPTY
25719: LIST
25720: LIST
25721: PUSH
25722: LD_INT 2
25724: PUSH
25725: LD_INT 30
25727: PUSH
25728: LD_INT 36
25730: PUSH
25731: EMPTY
25732: LIST
25733: LIST
25734: PUSH
25735: LD_INT 34
25737: PUSH
25738: LD_INT 31
25740: PUSH
25741: EMPTY
25742: LIST
25743: LIST
25744: PUSH
25745: EMPTY
25746: LIST
25747: LIST
25748: LIST
25749: PUSH
25750: EMPTY
25751: LIST
25752: LIST
25753: PPUSH
25754: CALL_OW 69
25758: ST_TO_ADDR
// if not tmp then
25759: LD_VAR 0 6
25763: NOT
25764: IFFALSE 25768
// exit ;
25766: GO 26016
// result := [ ] ;
25768: LD_ADDR_VAR 0 2
25772: PUSH
25773: EMPTY
25774: ST_TO_ADDR
// for i in tmp do
25775: LD_ADDR_VAR 0 3
25779: PUSH
25780: LD_VAR 0 6
25784: PUSH
25785: FOR_IN
25786: IFFALSE 25857
// begin t := UnitsInside ( i ) ;
25788: LD_ADDR_VAR 0 4
25792: PUSH
25793: LD_VAR 0 3
25797: PPUSH
25798: CALL_OW 313
25802: ST_TO_ADDR
// if t then
25803: LD_VAR 0 4
25807: IFFALSE 25855
// for j in t do
25809: LD_ADDR_VAR 0 7
25813: PUSH
25814: LD_VAR 0 4
25818: PUSH
25819: FOR_IN
25820: IFFALSE 25853
// result := Replace ( result , result + 1 , j ) ;
25822: LD_ADDR_VAR 0 2
25826: PUSH
25827: LD_VAR 0 2
25831: PPUSH
25832: LD_VAR 0 2
25836: PUSH
25837: LD_INT 1
25839: PLUS
25840: PPUSH
25841: LD_VAR 0 7
25845: PPUSH
25846: CALL_OW 1
25850: ST_TO_ADDR
25851: GO 25819
25853: POP
25854: POP
// end ;
25855: GO 25785
25857: POP
25858: POP
// if not result then
25859: LD_VAR 0 2
25863: NOT
25864: IFFALSE 25868
// exit ;
25866: GO 26016
// mech := result [ 1 ] ;
25868: LD_ADDR_VAR 0 5
25872: PUSH
25873: LD_VAR 0 2
25877: PUSH
25878: LD_INT 1
25880: ARRAY
25881: ST_TO_ADDR
// if result > 1 then
25882: LD_VAR 0 2
25886: PUSH
25887: LD_INT 1
25889: GREATER
25890: IFFALSE 26002
// begin for i = 2 to result do
25892: LD_ADDR_VAR 0 3
25896: PUSH
25897: DOUBLE
25898: LD_INT 2
25900: DEC
25901: ST_TO_ADDR
25902: LD_VAR 0 2
25906: PUSH
25907: FOR_TO
25908: IFFALSE 26000
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
25910: LD_ADDR_VAR 0 4
25914: PUSH
25915: LD_VAR 0 2
25919: PUSH
25920: LD_VAR 0 3
25924: ARRAY
25925: PPUSH
25926: LD_INT 3
25928: PPUSH
25929: CALL_OW 259
25933: PUSH
25934: LD_VAR 0 2
25938: PUSH
25939: LD_VAR 0 3
25943: ARRAY
25944: PPUSH
25945: CALL_OW 432
25949: MINUS
25950: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
25951: LD_VAR 0 4
25955: PUSH
25956: LD_VAR 0 5
25960: PPUSH
25961: LD_INT 3
25963: PPUSH
25964: CALL_OW 259
25968: PUSH
25969: LD_VAR 0 5
25973: PPUSH
25974: CALL_OW 432
25978: MINUS
25979: GREATEREQUAL
25980: IFFALSE 25998
// mech := result [ i ] ;
25982: LD_ADDR_VAR 0 5
25986: PUSH
25987: LD_VAR 0 2
25991: PUSH
25992: LD_VAR 0 3
25996: ARRAY
25997: ST_TO_ADDR
// end ;
25998: GO 25907
26000: POP
26001: POP
// end ; ComLinkTo ( vehicle , mech ) ;
26002: LD_VAR 0 1
26006: PPUSH
26007: LD_VAR 0 5
26011: PPUSH
26012: CALL_OW 135
// end ;
26016: LD_VAR 0 2
26020: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
26021: LD_INT 0
26023: PPUSH
26024: PPUSH
26025: PPUSH
26026: PPUSH
26027: PPUSH
26028: PPUSH
26029: PPUSH
26030: PPUSH
26031: PPUSH
26032: PPUSH
26033: PPUSH
26034: PPUSH
26035: PPUSH
// result := [ ] ;
26036: LD_ADDR_VAR 0 7
26040: PUSH
26041: EMPTY
26042: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
26043: LD_VAR 0 1
26047: PPUSH
26048: CALL_OW 266
26052: PUSH
26053: LD_INT 0
26055: PUSH
26056: LD_INT 1
26058: PUSH
26059: EMPTY
26060: LIST
26061: LIST
26062: IN
26063: NOT
26064: IFFALSE 26068
// exit ;
26066: GO 27702
// if name then
26068: LD_VAR 0 3
26072: IFFALSE 26088
// SetBName ( base_dep , name ) ;
26074: LD_VAR 0 1
26078: PPUSH
26079: LD_VAR 0 3
26083: PPUSH
26084: CALL_OW 500
// base := GetBase ( base_dep ) ;
26088: LD_ADDR_VAR 0 15
26092: PUSH
26093: LD_VAR 0 1
26097: PPUSH
26098: CALL_OW 274
26102: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
26103: LD_ADDR_VAR 0 16
26107: PUSH
26108: LD_VAR 0 1
26112: PPUSH
26113: CALL_OW 255
26117: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
26118: LD_ADDR_VAR 0 17
26122: PUSH
26123: LD_VAR 0 1
26127: PPUSH
26128: CALL_OW 248
26132: ST_TO_ADDR
// if sources then
26133: LD_VAR 0 5
26137: IFFALSE 26184
// for i = 1 to 3 do
26139: LD_ADDR_VAR 0 8
26143: PUSH
26144: DOUBLE
26145: LD_INT 1
26147: DEC
26148: ST_TO_ADDR
26149: LD_INT 3
26151: PUSH
26152: FOR_TO
26153: IFFALSE 26182
// AddResourceType ( base , i , sources [ i ] ) ;
26155: LD_VAR 0 15
26159: PPUSH
26160: LD_VAR 0 8
26164: PPUSH
26165: LD_VAR 0 5
26169: PUSH
26170: LD_VAR 0 8
26174: ARRAY
26175: PPUSH
26176: CALL_OW 276
26180: GO 26152
26182: POP
26183: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
26184: LD_ADDR_VAR 0 18
26188: PUSH
26189: LD_VAR 0 15
26193: PPUSH
26194: LD_VAR 0 2
26198: PPUSH
26199: LD_INT 1
26201: PPUSH
26202: CALL 25445 0 3
26206: ST_TO_ADDR
// InitHc ;
26207: CALL_OW 19
// InitUc ;
26211: CALL_OW 18
// uc_side := side ;
26215: LD_ADDR_OWVAR 20
26219: PUSH
26220: LD_VAR 0 16
26224: ST_TO_ADDR
// uc_nation := nation ;
26225: LD_ADDR_OWVAR 21
26229: PUSH
26230: LD_VAR 0 17
26234: ST_TO_ADDR
// if buildings then
26235: LD_VAR 0 18
26239: IFFALSE 27561
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
26241: LD_ADDR_VAR 0 19
26245: PUSH
26246: LD_VAR 0 18
26250: PPUSH
26251: LD_INT 2
26253: PUSH
26254: LD_INT 30
26256: PUSH
26257: LD_INT 29
26259: PUSH
26260: EMPTY
26261: LIST
26262: LIST
26263: PUSH
26264: LD_INT 30
26266: PUSH
26267: LD_INT 30
26269: PUSH
26270: EMPTY
26271: LIST
26272: LIST
26273: PUSH
26274: EMPTY
26275: LIST
26276: LIST
26277: LIST
26278: PPUSH
26279: CALL_OW 72
26283: ST_TO_ADDR
// if tmp then
26284: LD_VAR 0 19
26288: IFFALSE 26336
// for i in tmp do
26290: LD_ADDR_VAR 0 8
26294: PUSH
26295: LD_VAR 0 19
26299: PUSH
26300: FOR_IN
26301: IFFALSE 26334
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
26303: LD_VAR 0 8
26307: PPUSH
26308: CALL_OW 250
26312: PPUSH
26313: LD_VAR 0 8
26317: PPUSH
26318: CALL_OW 251
26322: PPUSH
26323: LD_VAR 0 16
26327: PPUSH
26328: CALL_OW 441
26332: GO 26300
26334: POP
26335: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
26336: LD_VAR 0 18
26340: PPUSH
26341: LD_INT 2
26343: PUSH
26344: LD_INT 30
26346: PUSH
26347: LD_INT 32
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: PUSH
26354: LD_INT 30
26356: PUSH
26357: LD_INT 33
26359: PUSH
26360: EMPTY
26361: LIST
26362: LIST
26363: PUSH
26364: EMPTY
26365: LIST
26366: LIST
26367: LIST
26368: PPUSH
26369: CALL_OW 72
26373: IFFALSE 26461
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
26375: LD_ADDR_VAR 0 8
26379: PUSH
26380: LD_VAR 0 18
26384: PPUSH
26385: LD_INT 2
26387: PUSH
26388: LD_INT 30
26390: PUSH
26391: LD_INT 32
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: LD_INT 30
26400: PUSH
26401: LD_INT 33
26403: PUSH
26404: EMPTY
26405: LIST
26406: LIST
26407: PUSH
26408: EMPTY
26409: LIST
26410: LIST
26411: LIST
26412: PPUSH
26413: CALL_OW 72
26417: PUSH
26418: FOR_IN
26419: IFFALSE 26459
// begin if not GetBWeapon ( i ) then
26421: LD_VAR 0 8
26425: PPUSH
26426: CALL_OW 269
26430: NOT
26431: IFFALSE 26457
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
26433: LD_VAR 0 8
26437: PPUSH
26438: LD_VAR 0 8
26442: PPUSH
26443: LD_VAR 0 2
26447: PPUSH
26448: CALL 27707 0 2
26452: PPUSH
26453: CALL_OW 431
// end ;
26457: GO 26418
26459: POP
26460: POP
// end ; for i = 1 to personel do
26461: LD_ADDR_VAR 0 8
26465: PUSH
26466: DOUBLE
26467: LD_INT 1
26469: DEC
26470: ST_TO_ADDR
26471: LD_VAR 0 6
26475: PUSH
26476: FOR_TO
26477: IFFALSE 27541
// begin if i > 4 then
26479: LD_VAR 0 8
26483: PUSH
26484: LD_INT 4
26486: GREATER
26487: IFFALSE 26491
// break ;
26489: GO 27541
// case i of 1 :
26491: LD_VAR 0 8
26495: PUSH
26496: LD_INT 1
26498: DOUBLE
26499: EQUAL
26500: IFTRUE 26504
26502: GO 26584
26504: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
26505: LD_ADDR_VAR 0 12
26509: PUSH
26510: LD_VAR 0 18
26514: PPUSH
26515: LD_INT 22
26517: PUSH
26518: LD_VAR 0 16
26522: PUSH
26523: EMPTY
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 58
26529: PUSH
26530: EMPTY
26531: LIST
26532: PUSH
26533: LD_INT 2
26535: PUSH
26536: LD_INT 30
26538: PUSH
26539: LD_INT 32
26541: PUSH
26542: EMPTY
26543: LIST
26544: LIST
26545: PUSH
26546: LD_INT 30
26548: PUSH
26549: LD_INT 4
26551: PUSH
26552: EMPTY
26553: LIST
26554: LIST
26555: PUSH
26556: LD_INT 30
26558: PUSH
26559: LD_INT 5
26561: PUSH
26562: EMPTY
26563: LIST
26564: LIST
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: LIST
26570: LIST
26571: PUSH
26572: EMPTY
26573: LIST
26574: LIST
26575: LIST
26576: PPUSH
26577: CALL_OW 72
26581: ST_TO_ADDR
26582: GO 26806
26584: LD_INT 2
26586: DOUBLE
26587: EQUAL
26588: IFTRUE 26592
26590: GO 26654
26592: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
26593: LD_ADDR_VAR 0 12
26597: PUSH
26598: LD_VAR 0 18
26602: PPUSH
26603: LD_INT 22
26605: PUSH
26606: LD_VAR 0 16
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 2
26617: PUSH
26618: LD_INT 30
26620: PUSH
26621: LD_INT 0
26623: PUSH
26624: EMPTY
26625: LIST
26626: LIST
26627: PUSH
26628: LD_INT 30
26630: PUSH
26631: LD_INT 1
26633: PUSH
26634: EMPTY
26635: LIST
26636: LIST
26637: PUSH
26638: EMPTY
26639: LIST
26640: LIST
26641: LIST
26642: PUSH
26643: EMPTY
26644: LIST
26645: LIST
26646: PPUSH
26647: CALL_OW 72
26651: ST_TO_ADDR
26652: GO 26806
26654: LD_INT 3
26656: DOUBLE
26657: EQUAL
26658: IFTRUE 26662
26660: GO 26724
26662: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
26663: LD_ADDR_VAR 0 12
26667: PUSH
26668: LD_VAR 0 18
26672: PPUSH
26673: LD_INT 22
26675: PUSH
26676: LD_VAR 0 16
26680: PUSH
26681: EMPTY
26682: LIST
26683: LIST
26684: PUSH
26685: LD_INT 2
26687: PUSH
26688: LD_INT 30
26690: PUSH
26691: LD_INT 2
26693: PUSH
26694: EMPTY
26695: LIST
26696: LIST
26697: PUSH
26698: LD_INT 30
26700: PUSH
26701: LD_INT 3
26703: PUSH
26704: EMPTY
26705: LIST
26706: LIST
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: LIST
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: PPUSH
26717: CALL_OW 72
26721: ST_TO_ADDR
26722: GO 26806
26724: LD_INT 4
26726: DOUBLE
26727: EQUAL
26728: IFTRUE 26732
26730: GO 26805
26732: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
26733: LD_ADDR_VAR 0 12
26737: PUSH
26738: LD_VAR 0 18
26742: PPUSH
26743: LD_INT 22
26745: PUSH
26746: LD_VAR 0 16
26750: PUSH
26751: EMPTY
26752: LIST
26753: LIST
26754: PUSH
26755: LD_INT 2
26757: PUSH
26758: LD_INT 30
26760: PUSH
26761: LD_INT 6
26763: PUSH
26764: EMPTY
26765: LIST
26766: LIST
26767: PUSH
26768: LD_INT 30
26770: PUSH
26771: LD_INT 7
26773: PUSH
26774: EMPTY
26775: LIST
26776: LIST
26777: PUSH
26778: LD_INT 30
26780: PUSH
26781: LD_INT 8
26783: PUSH
26784: EMPTY
26785: LIST
26786: LIST
26787: PUSH
26788: EMPTY
26789: LIST
26790: LIST
26791: LIST
26792: LIST
26793: PUSH
26794: EMPTY
26795: LIST
26796: LIST
26797: PPUSH
26798: CALL_OW 72
26802: ST_TO_ADDR
26803: GO 26806
26805: POP
// if i = 1 then
26806: LD_VAR 0 8
26810: PUSH
26811: LD_INT 1
26813: EQUAL
26814: IFFALSE 26925
// begin tmp := [ ] ;
26816: LD_ADDR_VAR 0 19
26820: PUSH
26821: EMPTY
26822: ST_TO_ADDR
// for j in f do
26823: LD_ADDR_VAR 0 9
26827: PUSH
26828: LD_VAR 0 12
26832: PUSH
26833: FOR_IN
26834: IFFALSE 26907
// if GetBType ( j ) = b_bunker then
26836: LD_VAR 0 9
26840: PPUSH
26841: CALL_OW 266
26845: PUSH
26846: LD_INT 32
26848: EQUAL
26849: IFFALSE 26876
// tmp := Insert ( tmp , 1 , j ) else
26851: LD_ADDR_VAR 0 19
26855: PUSH
26856: LD_VAR 0 19
26860: PPUSH
26861: LD_INT 1
26863: PPUSH
26864: LD_VAR 0 9
26868: PPUSH
26869: CALL_OW 2
26873: ST_TO_ADDR
26874: GO 26905
// tmp := Insert ( tmp , tmp + 1 , j ) ;
26876: LD_ADDR_VAR 0 19
26880: PUSH
26881: LD_VAR 0 19
26885: PPUSH
26886: LD_VAR 0 19
26890: PUSH
26891: LD_INT 1
26893: PLUS
26894: PPUSH
26895: LD_VAR 0 9
26899: PPUSH
26900: CALL_OW 2
26904: ST_TO_ADDR
26905: GO 26833
26907: POP
26908: POP
// if tmp then
26909: LD_VAR 0 19
26913: IFFALSE 26925
// f := tmp ;
26915: LD_ADDR_VAR 0 12
26919: PUSH
26920: LD_VAR 0 19
26924: ST_TO_ADDR
// end ; x := personel [ i ] ;
26925: LD_ADDR_VAR 0 13
26929: PUSH
26930: LD_VAR 0 6
26934: PUSH
26935: LD_VAR 0 8
26939: ARRAY
26940: ST_TO_ADDR
// if x = - 1 then
26941: LD_VAR 0 13
26945: PUSH
26946: LD_INT 1
26948: NEG
26949: EQUAL
26950: IFFALSE 27159
// begin for j in f do
26952: LD_ADDR_VAR 0 9
26956: PUSH
26957: LD_VAR 0 12
26961: PUSH
26962: FOR_IN
26963: IFFALSE 27155
// repeat InitHc ;
26965: CALL_OW 19
// if GetBType ( j ) = b_barracks then
26969: LD_VAR 0 9
26973: PPUSH
26974: CALL_OW 266
26978: PUSH
26979: LD_INT 5
26981: EQUAL
26982: IFFALSE 27052
// begin if UnitsInside ( j ) < 3 then
26984: LD_VAR 0 9
26988: PPUSH
26989: CALL_OW 313
26993: PUSH
26994: LD_INT 3
26996: LESS
26997: IFFALSE 27033
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
26999: LD_INT 0
27001: PPUSH
27002: LD_INT 5
27004: PUSH
27005: LD_INT 8
27007: PUSH
27008: LD_INT 9
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: LIST
27015: PUSH
27016: LD_VAR 0 17
27020: ARRAY
27021: PPUSH
27022: LD_VAR 0 4
27026: PPUSH
27027: CALL_OW 380
27031: GO 27050
// PrepareHuman ( false , i , skill ) ;
27033: LD_INT 0
27035: PPUSH
27036: LD_VAR 0 8
27040: PPUSH
27041: LD_VAR 0 4
27045: PPUSH
27046: CALL_OW 380
// end else
27050: GO 27069
// PrepareHuman ( false , i , skill ) ;
27052: LD_INT 0
27054: PPUSH
27055: LD_VAR 0 8
27059: PPUSH
27060: LD_VAR 0 4
27064: PPUSH
27065: CALL_OW 380
// un := CreateHuman ;
27069: LD_ADDR_VAR 0 14
27073: PUSH
27074: CALL_OW 44
27078: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27079: LD_ADDR_VAR 0 7
27083: PUSH
27084: LD_VAR 0 7
27088: PPUSH
27089: LD_INT 1
27091: PPUSH
27092: LD_VAR 0 14
27096: PPUSH
27097: CALL_OW 2
27101: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
27102: LD_VAR 0 14
27106: PPUSH
27107: LD_VAR 0 9
27111: PPUSH
27112: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
27116: LD_VAR 0 9
27120: PPUSH
27121: CALL_OW 313
27125: PUSH
27126: LD_INT 6
27128: EQUAL
27129: PUSH
27130: LD_VAR 0 9
27134: PPUSH
27135: CALL_OW 266
27139: PUSH
27140: LD_INT 32
27142: PUSH
27143: LD_INT 31
27145: PUSH
27146: EMPTY
27147: LIST
27148: LIST
27149: IN
27150: OR
27151: IFFALSE 26965
27153: GO 26962
27155: POP
27156: POP
// end else
27157: GO 27539
// for j = 1 to x do
27159: LD_ADDR_VAR 0 9
27163: PUSH
27164: DOUBLE
27165: LD_INT 1
27167: DEC
27168: ST_TO_ADDR
27169: LD_VAR 0 13
27173: PUSH
27174: FOR_TO
27175: IFFALSE 27537
// begin InitHc ;
27177: CALL_OW 19
// if not f then
27181: LD_VAR 0 12
27185: NOT
27186: IFFALSE 27275
// begin PrepareHuman ( false , i , skill ) ;
27188: LD_INT 0
27190: PPUSH
27191: LD_VAR 0 8
27195: PPUSH
27196: LD_VAR 0 4
27200: PPUSH
27201: CALL_OW 380
// un := CreateHuman ;
27205: LD_ADDR_VAR 0 14
27209: PUSH
27210: CALL_OW 44
27214: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27215: LD_ADDR_VAR 0 7
27219: PUSH
27220: LD_VAR 0 7
27224: PPUSH
27225: LD_INT 1
27227: PPUSH
27228: LD_VAR 0 14
27232: PPUSH
27233: CALL_OW 2
27237: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27238: LD_VAR 0 14
27242: PPUSH
27243: LD_VAR 0 1
27247: PPUSH
27248: CALL_OW 250
27252: PPUSH
27253: LD_VAR 0 1
27257: PPUSH
27258: CALL_OW 251
27262: PPUSH
27263: LD_INT 10
27265: PPUSH
27266: LD_INT 0
27268: PPUSH
27269: CALL_OW 50
// continue ;
27273: GO 27174
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
27275: LD_VAR 0 12
27279: PUSH
27280: LD_INT 1
27282: ARRAY
27283: PPUSH
27284: CALL_OW 313
27288: PUSH
27289: LD_VAR 0 12
27293: PUSH
27294: LD_INT 1
27296: ARRAY
27297: PPUSH
27298: CALL_OW 266
27302: PUSH
27303: LD_INT 32
27305: PUSH
27306: LD_INT 31
27308: PUSH
27309: EMPTY
27310: LIST
27311: LIST
27312: IN
27313: AND
27314: PUSH
27315: LD_VAR 0 12
27319: PUSH
27320: LD_INT 1
27322: ARRAY
27323: PPUSH
27324: CALL_OW 313
27328: PUSH
27329: LD_INT 6
27331: EQUAL
27332: OR
27333: IFFALSE 27353
// f := Delete ( f , 1 ) ;
27335: LD_ADDR_VAR 0 12
27339: PUSH
27340: LD_VAR 0 12
27344: PPUSH
27345: LD_INT 1
27347: PPUSH
27348: CALL_OW 3
27352: ST_TO_ADDR
// if not f then
27353: LD_VAR 0 12
27357: NOT
27358: IFFALSE 27376
// begin x := x + 2 ;
27360: LD_ADDR_VAR 0 13
27364: PUSH
27365: LD_VAR 0 13
27369: PUSH
27370: LD_INT 2
27372: PLUS
27373: ST_TO_ADDR
// continue ;
27374: GO 27174
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
27376: LD_VAR 0 12
27380: PUSH
27381: LD_INT 1
27383: ARRAY
27384: PPUSH
27385: CALL_OW 266
27389: PUSH
27390: LD_INT 5
27392: EQUAL
27393: IFFALSE 27467
// begin if UnitsInside ( f [ 1 ] ) < 3 then
27395: LD_VAR 0 12
27399: PUSH
27400: LD_INT 1
27402: ARRAY
27403: PPUSH
27404: CALL_OW 313
27408: PUSH
27409: LD_INT 3
27411: LESS
27412: IFFALSE 27448
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
27414: LD_INT 0
27416: PPUSH
27417: LD_INT 5
27419: PUSH
27420: LD_INT 8
27422: PUSH
27423: LD_INT 9
27425: PUSH
27426: EMPTY
27427: LIST
27428: LIST
27429: LIST
27430: PUSH
27431: LD_VAR 0 17
27435: ARRAY
27436: PPUSH
27437: LD_VAR 0 4
27441: PPUSH
27442: CALL_OW 380
27446: GO 27465
// PrepareHuman ( false , i , skill ) ;
27448: LD_INT 0
27450: PPUSH
27451: LD_VAR 0 8
27455: PPUSH
27456: LD_VAR 0 4
27460: PPUSH
27461: CALL_OW 380
// end else
27465: GO 27484
// PrepareHuman ( false , i , skill ) ;
27467: LD_INT 0
27469: PPUSH
27470: LD_VAR 0 8
27474: PPUSH
27475: LD_VAR 0 4
27479: PPUSH
27480: CALL_OW 380
// un := CreateHuman ;
27484: LD_ADDR_VAR 0 14
27488: PUSH
27489: CALL_OW 44
27493: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
27494: LD_ADDR_VAR 0 7
27498: PUSH
27499: LD_VAR 0 7
27503: PPUSH
27504: LD_INT 1
27506: PPUSH
27507: LD_VAR 0 14
27511: PPUSH
27512: CALL_OW 2
27516: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
27517: LD_VAR 0 14
27521: PPUSH
27522: LD_VAR 0 12
27526: PUSH
27527: LD_INT 1
27529: ARRAY
27530: PPUSH
27531: CALL_OW 52
// end ;
27535: GO 27174
27537: POP
27538: POP
// end ;
27539: GO 26476
27541: POP
27542: POP
// result := result ^ buildings ;
27543: LD_ADDR_VAR 0 7
27547: PUSH
27548: LD_VAR 0 7
27552: PUSH
27553: LD_VAR 0 18
27557: ADD
27558: ST_TO_ADDR
// end else
27559: GO 27702
// begin for i = 1 to personel do
27561: LD_ADDR_VAR 0 8
27565: PUSH
27566: DOUBLE
27567: LD_INT 1
27569: DEC
27570: ST_TO_ADDR
27571: LD_VAR 0 6
27575: PUSH
27576: FOR_TO
27577: IFFALSE 27700
// begin if i > 4 then
27579: LD_VAR 0 8
27583: PUSH
27584: LD_INT 4
27586: GREATER
27587: IFFALSE 27591
// break ;
27589: GO 27700
// x := personel [ i ] ;
27591: LD_ADDR_VAR 0 13
27595: PUSH
27596: LD_VAR 0 6
27600: PUSH
27601: LD_VAR 0 8
27605: ARRAY
27606: ST_TO_ADDR
// if x = - 1 then
27607: LD_VAR 0 13
27611: PUSH
27612: LD_INT 1
27614: NEG
27615: EQUAL
27616: IFFALSE 27620
// continue ;
27618: GO 27576
// PrepareHuman ( false , i , skill ) ;
27620: LD_INT 0
27622: PPUSH
27623: LD_VAR 0 8
27627: PPUSH
27628: LD_VAR 0 4
27632: PPUSH
27633: CALL_OW 380
// un := CreateHuman ;
27637: LD_ADDR_VAR 0 14
27641: PUSH
27642: CALL_OW 44
27646: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
27647: LD_VAR 0 14
27651: PPUSH
27652: LD_VAR 0 1
27656: PPUSH
27657: CALL_OW 250
27661: PPUSH
27662: LD_VAR 0 1
27666: PPUSH
27667: CALL_OW 251
27671: PPUSH
27672: LD_INT 10
27674: PPUSH
27675: LD_INT 0
27677: PPUSH
27678: CALL_OW 50
// result := result ^ un ;
27682: LD_ADDR_VAR 0 7
27686: PUSH
27687: LD_VAR 0 7
27691: PUSH
27692: LD_VAR 0 14
27696: ADD
27697: ST_TO_ADDR
// end ;
27698: GO 27576
27700: POP
27701: POP
// end ; end ;
27702: LD_VAR 0 7
27706: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
27707: LD_INT 0
27709: PPUSH
27710: PPUSH
27711: PPUSH
27712: PPUSH
27713: PPUSH
27714: PPUSH
27715: PPUSH
27716: PPUSH
27717: PPUSH
27718: PPUSH
27719: PPUSH
27720: PPUSH
27721: PPUSH
27722: PPUSH
27723: PPUSH
27724: PPUSH
// result := false ;
27725: LD_ADDR_VAR 0 3
27729: PUSH
27730: LD_INT 0
27732: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
27733: LD_VAR 0 1
27737: NOT
27738: PUSH
27739: LD_VAR 0 1
27743: PPUSH
27744: CALL_OW 266
27748: PUSH
27749: LD_INT 32
27751: PUSH
27752: LD_INT 33
27754: PUSH
27755: EMPTY
27756: LIST
27757: LIST
27758: IN
27759: NOT
27760: OR
27761: IFFALSE 27765
// exit ;
27763: GO 28874
// nat := GetNation ( tower ) ;
27765: LD_ADDR_VAR 0 12
27769: PUSH
27770: LD_VAR 0 1
27774: PPUSH
27775: CALL_OW 248
27779: ST_TO_ADDR
// side := GetSide ( tower ) ;
27780: LD_ADDR_VAR 0 16
27784: PUSH
27785: LD_VAR 0 1
27789: PPUSH
27790: CALL_OW 255
27794: ST_TO_ADDR
// x := GetX ( tower ) ;
27795: LD_ADDR_VAR 0 10
27799: PUSH
27800: LD_VAR 0 1
27804: PPUSH
27805: CALL_OW 250
27809: ST_TO_ADDR
// y := GetY ( tower ) ;
27810: LD_ADDR_VAR 0 11
27814: PUSH
27815: LD_VAR 0 1
27819: PPUSH
27820: CALL_OW 251
27824: ST_TO_ADDR
// if not x or not y then
27825: LD_VAR 0 10
27829: NOT
27830: PUSH
27831: LD_VAR 0 11
27835: NOT
27836: OR
27837: IFFALSE 27841
// exit ;
27839: GO 28874
// weapon := 0 ;
27841: LD_ADDR_VAR 0 18
27845: PUSH
27846: LD_INT 0
27848: ST_TO_ADDR
// fac_list := [ ] ;
27849: LD_ADDR_VAR 0 17
27853: PUSH
27854: EMPTY
27855: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
27856: LD_ADDR_VAR 0 6
27860: PUSH
27861: LD_VAR 0 1
27865: PPUSH
27866: CALL_OW 274
27870: PPUSH
27871: LD_VAR 0 2
27875: PPUSH
27876: LD_INT 0
27878: PPUSH
27879: CALL 25445 0 3
27883: PPUSH
27884: LD_INT 30
27886: PUSH
27887: LD_INT 3
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PPUSH
27894: CALL_OW 72
27898: ST_TO_ADDR
// if not factories then
27899: LD_VAR 0 6
27903: NOT
27904: IFFALSE 27908
// exit ;
27906: GO 28874
// for i in factories do
27908: LD_ADDR_VAR 0 8
27912: PUSH
27913: LD_VAR 0 6
27917: PUSH
27918: FOR_IN
27919: IFFALSE 27944
// fac_list := fac_list union AvailableWeaponList ( i ) ;
27921: LD_ADDR_VAR 0 17
27925: PUSH
27926: LD_VAR 0 17
27930: PUSH
27931: LD_VAR 0 8
27935: PPUSH
27936: CALL_OW 478
27940: UNION
27941: ST_TO_ADDR
27942: GO 27918
27944: POP
27945: POP
// if not fac_list then
27946: LD_VAR 0 17
27950: NOT
27951: IFFALSE 27955
// exit ;
27953: GO 28874
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
27955: LD_ADDR_VAR 0 5
27959: PUSH
27960: LD_INT 4
27962: PUSH
27963: LD_INT 5
27965: PUSH
27966: LD_INT 9
27968: PUSH
27969: LD_INT 10
27971: PUSH
27972: LD_INT 6
27974: PUSH
27975: LD_INT 7
27977: PUSH
27978: LD_INT 11
27980: PUSH
27981: EMPTY
27982: LIST
27983: LIST
27984: LIST
27985: LIST
27986: LIST
27987: LIST
27988: LIST
27989: PUSH
27990: LD_INT 27
27992: PUSH
27993: LD_INT 28
27995: PUSH
27996: LD_INT 26
27998: PUSH
27999: LD_INT 30
28001: PUSH
28002: EMPTY
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: PUSH
28008: LD_INT 43
28010: PUSH
28011: LD_INT 44
28013: PUSH
28014: LD_INT 46
28016: PUSH
28017: LD_INT 45
28019: PUSH
28020: LD_INT 47
28022: PUSH
28023: LD_INT 49
28025: PUSH
28026: EMPTY
28027: LIST
28028: LIST
28029: LIST
28030: LIST
28031: LIST
28032: LIST
28033: PUSH
28034: EMPTY
28035: LIST
28036: LIST
28037: LIST
28038: PUSH
28039: LD_VAR 0 12
28043: ARRAY
28044: ST_TO_ADDR
// list := list isect fac_list ;
28045: LD_ADDR_VAR 0 5
28049: PUSH
28050: LD_VAR 0 5
28054: PUSH
28055: LD_VAR 0 17
28059: ISECT
28060: ST_TO_ADDR
// if not list then
28061: LD_VAR 0 5
28065: NOT
28066: IFFALSE 28070
// exit ;
28068: GO 28874
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
28070: LD_VAR 0 12
28074: PUSH
28075: LD_INT 3
28077: EQUAL
28078: PUSH
28079: LD_INT 49
28081: PUSH
28082: LD_VAR 0 5
28086: IN
28087: AND
28088: PUSH
28089: LD_INT 31
28091: PPUSH
28092: LD_VAR 0 16
28096: PPUSH
28097: CALL_OW 321
28101: PUSH
28102: LD_INT 2
28104: EQUAL
28105: AND
28106: IFFALSE 28166
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
28108: LD_INT 22
28110: PUSH
28111: LD_VAR 0 16
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 35
28122: PUSH
28123: LD_INT 49
28125: PUSH
28126: EMPTY
28127: LIST
28128: LIST
28129: PUSH
28130: LD_INT 91
28132: PUSH
28133: LD_VAR 0 1
28137: PUSH
28138: LD_INT 10
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: LIST
28145: PUSH
28146: EMPTY
28147: LIST
28148: LIST
28149: LIST
28150: PPUSH
28151: CALL_OW 69
28155: NOT
28156: IFFALSE 28166
// weapon := ru_time_lapser ;
28158: LD_ADDR_VAR 0 18
28162: PUSH
28163: LD_INT 49
28165: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
28166: LD_VAR 0 12
28170: PUSH
28171: LD_INT 1
28173: PUSH
28174: LD_INT 2
28176: PUSH
28177: EMPTY
28178: LIST
28179: LIST
28180: IN
28181: PUSH
28182: LD_INT 11
28184: PUSH
28185: LD_VAR 0 5
28189: IN
28190: PUSH
28191: LD_INT 30
28193: PUSH
28194: LD_VAR 0 5
28198: IN
28199: OR
28200: AND
28201: PUSH
28202: LD_INT 6
28204: PPUSH
28205: LD_VAR 0 16
28209: PPUSH
28210: CALL_OW 321
28214: PUSH
28215: LD_INT 2
28217: EQUAL
28218: AND
28219: IFFALSE 28384
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
28221: LD_INT 22
28223: PUSH
28224: LD_VAR 0 16
28228: PUSH
28229: EMPTY
28230: LIST
28231: LIST
28232: PUSH
28233: LD_INT 2
28235: PUSH
28236: LD_INT 35
28238: PUSH
28239: LD_INT 11
28241: PUSH
28242: EMPTY
28243: LIST
28244: LIST
28245: PUSH
28246: LD_INT 35
28248: PUSH
28249: LD_INT 30
28251: PUSH
28252: EMPTY
28253: LIST
28254: LIST
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: LIST
28260: PUSH
28261: LD_INT 91
28263: PUSH
28264: LD_VAR 0 1
28268: PUSH
28269: LD_INT 18
28271: PUSH
28272: EMPTY
28273: LIST
28274: LIST
28275: LIST
28276: PUSH
28277: EMPTY
28278: LIST
28279: LIST
28280: LIST
28281: PPUSH
28282: CALL_OW 69
28286: NOT
28287: PUSH
28288: LD_INT 22
28290: PUSH
28291: LD_VAR 0 16
28295: PUSH
28296: EMPTY
28297: LIST
28298: LIST
28299: PUSH
28300: LD_INT 2
28302: PUSH
28303: LD_INT 30
28305: PUSH
28306: LD_INT 32
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 30
28315: PUSH
28316: LD_INT 33
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: EMPTY
28324: LIST
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 91
28330: PUSH
28331: LD_VAR 0 1
28335: PUSH
28336: LD_INT 12
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: LIST
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: LIST
28348: PUSH
28349: EMPTY
28350: LIST
28351: PPUSH
28352: CALL_OW 69
28356: PUSH
28357: LD_INT 2
28359: GREATER
28360: AND
28361: IFFALSE 28384
// weapon := [ us_radar , ar_radar ] [ nat ] ;
28363: LD_ADDR_VAR 0 18
28367: PUSH
28368: LD_INT 11
28370: PUSH
28371: LD_INT 30
28373: PUSH
28374: EMPTY
28375: LIST
28376: LIST
28377: PUSH
28378: LD_VAR 0 12
28382: ARRAY
28383: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
28384: LD_VAR 0 18
28388: NOT
28389: PUSH
28390: LD_INT 40
28392: PPUSH
28393: LD_VAR 0 16
28397: PPUSH
28398: CALL_OW 321
28402: PUSH
28403: LD_INT 2
28405: EQUAL
28406: AND
28407: PUSH
28408: LD_INT 7
28410: PUSH
28411: LD_VAR 0 5
28415: IN
28416: PUSH
28417: LD_INT 28
28419: PUSH
28420: LD_VAR 0 5
28424: IN
28425: OR
28426: PUSH
28427: LD_INT 45
28429: PUSH
28430: LD_VAR 0 5
28434: IN
28435: OR
28436: AND
28437: IFFALSE 28691
// begin hex := GetHexInfo ( x , y ) ;
28439: LD_ADDR_VAR 0 4
28443: PUSH
28444: LD_VAR 0 10
28448: PPUSH
28449: LD_VAR 0 11
28453: PPUSH
28454: CALL_OW 546
28458: ST_TO_ADDR
// if hex [ 1 ] then
28459: LD_VAR 0 4
28463: PUSH
28464: LD_INT 1
28466: ARRAY
28467: IFFALSE 28471
// exit ;
28469: GO 28874
// height := hex [ 2 ] ;
28471: LD_ADDR_VAR 0 15
28475: PUSH
28476: LD_VAR 0 4
28480: PUSH
28481: LD_INT 2
28483: ARRAY
28484: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
28485: LD_ADDR_VAR 0 14
28489: PUSH
28490: LD_INT 0
28492: PUSH
28493: LD_INT 2
28495: PUSH
28496: LD_INT 3
28498: PUSH
28499: LD_INT 5
28501: PUSH
28502: EMPTY
28503: LIST
28504: LIST
28505: LIST
28506: LIST
28507: ST_TO_ADDR
// for i in tmp do
28508: LD_ADDR_VAR 0 8
28512: PUSH
28513: LD_VAR 0 14
28517: PUSH
28518: FOR_IN
28519: IFFALSE 28689
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
28521: LD_ADDR_VAR 0 9
28525: PUSH
28526: LD_VAR 0 10
28530: PPUSH
28531: LD_VAR 0 8
28535: PPUSH
28536: LD_INT 5
28538: PPUSH
28539: CALL_OW 272
28543: PUSH
28544: LD_VAR 0 11
28548: PPUSH
28549: LD_VAR 0 8
28553: PPUSH
28554: LD_INT 5
28556: PPUSH
28557: CALL_OW 273
28561: PUSH
28562: EMPTY
28563: LIST
28564: LIST
28565: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
28566: LD_VAR 0 9
28570: PUSH
28571: LD_INT 1
28573: ARRAY
28574: PPUSH
28575: LD_VAR 0 9
28579: PUSH
28580: LD_INT 2
28582: ARRAY
28583: PPUSH
28584: CALL_OW 488
28588: IFFALSE 28687
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
28590: LD_ADDR_VAR 0 4
28594: PUSH
28595: LD_VAR 0 9
28599: PUSH
28600: LD_INT 1
28602: ARRAY
28603: PPUSH
28604: LD_VAR 0 9
28608: PUSH
28609: LD_INT 2
28611: ARRAY
28612: PPUSH
28613: CALL_OW 546
28617: ST_TO_ADDR
// if hex [ 1 ] then
28618: LD_VAR 0 4
28622: PUSH
28623: LD_INT 1
28625: ARRAY
28626: IFFALSE 28630
// continue ;
28628: GO 28518
// h := hex [ 2 ] ;
28630: LD_ADDR_VAR 0 13
28634: PUSH
28635: LD_VAR 0 4
28639: PUSH
28640: LD_INT 2
28642: ARRAY
28643: ST_TO_ADDR
// if h + 7 < height then
28644: LD_VAR 0 13
28648: PUSH
28649: LD_INT 7
28651: PLUS
28652: PUSH
28653: LD_VAR 0 15
28657: LESS
28658: IFFALSE 28687
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
28660: LD_ADDR_VAR 0 18
28664: PUSH
28665: LD_INT 7
28667: PUSH
28668: LD_INT 28
28670: PUSH
28671: LD_INT 45
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: LIST
28678: PUSH
28679: LD_VAR 0 12
28683: ARRAY
28684: ST_TO_ADDR
// break ;
28685: GO 28689
// end ; end ; end ;
28687: GO 28518
28689: POP
28690: POP
// end ; if not weapon then
28691: LD_VAR 0 18
28695: NOT
28696: IFFALSE 28756
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
28698: LD_ADDR_VAR 0 5
28702: PUSH
28703: LD_VAR 0 5
28707: PUSH
28708: LD_INT 11
28710: PUSH
28711: LD_INT 30
28713: PUSH
28714: LD_INT 49
28716: PUSH
28717: EMPTY
28718: LIST
28719: LIST
28720: LIST
28721: DIFF
28722: ST_TO_ADDR
// if not list then
28723: LD_VAR 0 5
28727: NOT
28728: IFFALSE 28732
// exit ;
28730: GO 28874
// weapon := list [ rand ( 1 , list ) ] ;
28732: LD_ADDR_VAR 0 18
28736: PUSH
28737: LD_VAR 0 5
28741: PUSH
28742: LD_INT 1
28744: PPUSH
28745: LD_VAR 0 5
28749: PPUSH
28750: CALL_OW 12
28754: ARRAY
28755: ST_TO_ADDR
// end ; if weapon then
28756: LD_VAR 0 18
28760: IFFALSE 28874
// begin tmp := CostOfWeapon ( weapon ) ;
28762: LD_ADDR_VAR 0 14
28766: PUSH
28767: LD_VAR 0 18
28771: PPUSH
28772: CALL_OW 451
28776: ST_TO_ADDR
// j := GetBase ( tower ) ;
28777: LD_ADDR_VAR 0 9
28781: PUSH
28782: LD_VAR 0 1
28786: PPUSH
28787: CALL_OW 274
28791: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
28792: LD_VAR 0 9
28796: PPUSH
28797: LD_INT 1
28799: PPUSH
28800: CALL_OW 275
28804: PUSH
28805: LD_VAR 0 14
28809: PUSH
28810: LD_INT 1
28812: ARRAY
28813: GREATEREQUAL
28814: PUSH
28815: LD_VAR 0 9
28819: PPUSH
28820: LD_INT 2
28822: PPUSH
28823: CALL_OW 275
28827: PUSH
28828: LD_VAR 0 14
28832: PUSH
28833: LD_INT 2
28835: ARRAY
28836: GREATEREQUAL
28837: AND
28838: PUSH
28839: LD_VAR 0 9
28843: PPUSH
28844: LD_INT 3
28846: PPUSH
28847: CALL_OW 275
28851: PUSH
28852: LD_VAR 0 14
28856: PUSH
28857: LD_INT 3
28859: ARRAY
28860: GREATEREQUAL
28861: AND
28862: IFFALSE 28874
// result := weapon ;
28864: LD_ADDR_VAR 0 3
28868: PUSH
28869: LD_VAR 0 18
28873: ST_TO_ADDR
// end ; end ;
28874: LD_VAR 0 3
28878: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
28879: LD_INT 0
28881: PPUSH
28882: PPUSH
// result := true ;
28883: LD_ADDR_VAR 0 3
28887: PUSH
28888: LD_INT 1
28890: ST_TO_ADDR
// if array1 = array2 then
28891: LD_VAR 0 1
28895: PUSH
28896: LD_VAR 0 2
28900: EQUAL
28901: IFFALSE 28961
// begin for i = 1 to array1 do
28903: LD_ADDR_VAR 0 4
28907: PUSH
28908: DOUBLE
28909: LD_INT 1
28911: DEC
28912: ST_TO_ADDR
28913: LD_VAR 0 1
28917: PUSH
28918: FOR_TO
28919: IFFALSE 28957
// if array1 [ i ] <> array2 [ i ] then
28921: LD_VAR 0 1
28925: PUSH
28926: LD_VAR 0 4
28930: ARRAY
28931: PUSH
28932: LD_VAR 0 2
28936: PUSH
28937: LD_VAR 0 4
28941: ARRAY
28942: NONEQUAL
28943: IFFALSE 28955
// begin result := false ;
28945: LD_ADDR_VAR 0 3
28949: PUSH
28950: LD_INT 0
28952: ST_TO_ADDR
// break ;
28953: GO 28957
// end ;
28955: GO 28918
28957: POP
28958: POP
// end else
28959: GO 28969
// result := false ;
28961: LD_ADDR_VAR 0 3
28965: PUSH
28966: LD_INT 0
28968: ST_TO_ADDR
// end ;
28969: LD_VAR 0 3
28973: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
28974: LD_INT 0
28976: PPUSH
28977: PPUSH
// if not array1 or not array2 then
28978: LD_VAR 0 1
28982: NOT
28983: PUSH
28984: LD_VAR 0 2
28988: NOT
28989: OR
28990: IFFALSE 28994
// exit ;
28992: GO 29058
// result := true ;
28994: LD_ADDR_VAR 0 3
28998: PUSH
28999: LD_INT 1
29001: ST_TO_ADDR
// for i = 1 to array1 do
29002: LD_ADDR_VAR 0 4
29006: PUSH
29007: DOUBLE
29008: LD_INT 1
29010: DEC
29011: ST_TO_ADDR
29012: LD_VAR 0 1
29016: PUSH
29017: FOR_TO
29018: IFFALSE 29056
// if array1 [ i ] <> array2 [ i ] then
29020: LD_VAR 0 1
29024: PUSH
29025: LD_VAR 0 4
29029: ARRAY
29030: PUSH
29031: LD_VAR 0 2
29035: PUSH
29036: LD_VAR 0 4
29040: ARRAY
29041: NONEQUAL
29042: IFFALSE 29054
// begin result := false ;
29044: LD_ADDR_VAR 0 3
29048: PUSH
29049: LD_INT 0
29051: ST_TO_ADDR
// break ;
29052: GO 29056
// end ;
29054: GO 29017
29056: POP
29057: POP
// end ;
29058: LD_VAR 0 3
29062: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
29063: LD_INT 0
29065: PPUSH
29066: PPUSH
29067: PPUSH
// pom := GetBase ( fac ) ;
29068: LD_ADDR_VAR 0 5
29072: PUSH
29073: LD_VAR 0 1
29077: PPUSH
29078: CALL_OW 274
29082: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
29083: LD_ADDR_VAR 0 4
29087: PUSH
29088: LD_VAR 0 2
29092: PUSH
29093: LD_INT 1
29095: ARRAY
29096: PPUSH
29097: LD_VAR 0 2
29101: PUSH
29102: LD_INT 2
29104: ARRAY
29105: PPUSH
29106: LD_VAR 0 2
29110: PUSH
29111: LD_INT 3
29113: ARRAY
29114: PPUSH
29115: LD_VAR 0 2
29119: PUSH
29120: LD_INT 4
29122: ARRAY
29123: PPUSH
29124: CALL_OW 449
29128: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29129: LD_ADDR_VAR 0 3
29133: PUSH
29134: LD_VAR 0 5
29138: PPUSH
29139: LD_INT 1
29141: PPUSH
29142: CALL_OW 275
29146: PUSH
29147: LD_VAR 0 4
29151: PUSH
29152: LD_INT 1
29154: ARRAY
29155: GREATEREQUAL
29156: PUSH
29157: LD_VAR 0 5
29161: PPUSH
29162: LD_INT 2
29164: PPUSH
29165: CALL_OW 275
29169: PUSH
29170: LD_VAR 0 4
29174: PUSH
29175: LD_INT 2
29177: ARRAY
29178: GREATEREQUAL
29179: AND
29180: PUSH
29181: LD_VAR 0 5
29185: PPUSH
29186: LD_INT 3
29188: PPUSH
29189: CALL_OW 275
29193: PUSH
29194: LD_VAR 0 4
29198: PUSH
29199: LD_INT 3
29201: ARRAY
29202: GREATEREQUAL
29203: AND
29204: ST_TO_ADDR
// end ;
29205: LD_VAR 0 3
29209: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
29210: LD_INT 0
29212: PPUSH
29213: PPUSH
29214: PPUSH
29215: PPUSH
// pom := GetBase ( building ) ;
29216: LD_ADDR_VAR 0 3
29220: PUSH
29221: LD_VAR 0 1
29225: PPUSH
29226: CALL_OW 274
29230: ST_TO_ADDR
// if not pom then
29231: LD_VAR 0 3
29235: NOT
29236: IFFALSE 29240
// exit ;
29238: GO 29410
// btype := GetBType ( building ) ;
29240: LD_ADDR_VAR 0 5
29244: PUSH
29245: LD_VAR 0 1
29249: PPUSH
29250: CALL_OW 266
29254: ST_TO_ADDR
// if btype = b_armoury then
29255: LD_VAR 0 5
29259: PUSH
29260: LD_INT 4
29262: EQUAL
29263: IFFALSE 29273
// btype := b_barracks ;
29265: LD_ADDR_VAR 0 5
29269: PUSH
29270: LD_INT 5
29272: ST_TO_ADDR
// if btype = b_depot then
29273: LD_VAR 0 5
29277: PUSH
29278: LD_INT 0
29280: EQUAL
29281: IFFALSE 29291
// btype := b_warehouse ;
29283: LD_ADDR_VAR 0 5
29287: PUSH
29288: LD_INT 1
29290: ST_TO_ADDR
// if btype = b_workshop then
29291: LD_VAR 0 5
29295: PUSH
29296: LD_INT 2
29298: EQUAL
29299: IFFALSE 29309
// btype := b_factory ;
29301: LD_ADDR_VAR 0 5
29305: PUSH
29306: LD_INT 3
29308: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29309: LD_ADDR_VAR 0 4
29313: PUSH
29314: LD_VAR 0 5
29318: PPUSH
29319: LD_VAR 0 1
29323: PPUSH
29324: CALL_OW 248
29328: PPUSH
29329: CALL_OW 450
29333: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29334: LD_ADDR_VAR 0 2
29338: PUSH
29339: LD_VAR 0 3
29343: PPUSH
29344: LD_INT 1
29346: PPUSH
29347: CALL_OW 275
29351: PUSH
29352: LD_VAR 0 4
29356: PUSH
29357: LD_INT 1
29359: ARRAY
29360: GREATEREQUAL
29361: PUSH
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 2
29369: PPUSH
29370: CALL_OW 275
29374: PUSH
29375: LD_VAR 0 4
29379: PUSH
29380: LD_INT 2
29382: ARRAY
29383: GREATEREQUAL
29384: AND
29385: PUSH
29386: LD_VAR 0 3
29390: PPUSH
29391: LD_INT 3
29393: PPUSH
29394: CALL_OW 275
29398: PUSH
29399: LD_VAR 0 4
29403: PUSH
29404: LD_INT 3
29406: ARRAY
29407: GREATEREQUAL
29408: AND
29409: ST_TO_ADDR
// end ;
29410: LD_VAR 0 2
29414: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
29415: LD_INT 0
29417: PPUSH
29418: PPUSH
29419: PPUSH
// pom := GetBase ( building ) ;
29420: LD_ADDR_VAR 0 4
29424: PUSH
29425: LD_VAR 0 1
29429: PPUSH
29430: CALL_OW 274
29434: ST_TO_ADDR
// if not pom then
29435: LD_VAR 0 4
29439: NOT
29440: IFFALSE 29444
// exit ;
29442: GO 29545
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
29444: LD_ADDR_VAR 0 5
29448: PUSH
29449: LD_VAR 0 2
29453: PPUSH
29454: LD_VAR 0 1
29458: PPUSH
29459: CALL_OW 248
29463: PPUSH
29464: CALL_OW 450
29468: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
29469: LD_ADDR_VAR 0 3
29473: PUSH
29474: LD_VAR 0 4
29478: PPUSH
29479: LD_INT 1
29481: PPUSH
29482: CALL_OW 275
29486: PUSH
29487: LD_VAR 0 5
29491: PUSH
29492: LD_INT 1
29494: ARRAY
29495: GREATEREQUAL
29496: PUSH
29497: LD_VAR 0 4
29501: PPUSH
29502: LD_INT 2
29504: PPUSH
29505: CALL_OW 275
29509: PUSH
29510: LD_VAR 0 5
29514: PUSH
29515: LD_INT 2
29517: ARRAY
29518: GREATEREQUAL
29519: AND
29520: PUSH
29521: LD_VAR 0 4
29525: PPUSH
29526: LD_INT 3
29528: PPUSH
29529: CALL_OW 275
29533: PUSH
29534: LD_VAR 0 5
29538: PUSH
29539: LD_INT 3
29541: ARRAY
29542: GREATEREQUAL
29543: AND
29544: ST_TO_ADDR
// end ;
29545: LD_VAR 0 3
29549: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
29550: LD_INT 0
29552: PPUSH
29553: PPUSH
29554: PPUSH
29555: PPUSH
29556: PPUSH
29557: PPUSH
29558: PPUSH
29559: PPUSH
29560: PPUSH
29561: PPUSH
29562: PPUSH
// result := false ;
29563: LD_ADDR_VAR 0 8
29567: PUSH
29568: LD_INT 0
29570: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
29571: LD_VAR 0 5
29575: NOT
29576: PUSH
29577: LD_VAR 0 1
29581: NOT
29582: OR
29583: PUSH
29584: LD_VAR 0 2
29588: NOT
29589: OR
29590: PUSH
29591: LD_VAR 0 3
29595: NOT
29596: OR
29597: IFFALSE 29601
// exit ;
29599: GO 30415
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
29601: LD_ADDR_VAR 0 14
29605: PUSH
29606: LD_VAR 0 1
29610: PPUSH
29611: LD_VAR 0 2
29615: PPUSH
29616: LD_VAR 0 3
29620: PPUSH
29621: LD_VAR 0 4
29625: PPUSH
29626: LD_VAR 0 5
29630: PUSH
29631: LD_INT 1
29633: ARRAY
29634: PPUSH
29635: CALL_OW 248
29639: PPUSH
29640: LD_INT 0
29642: PPUSH
29643: CALL 31668 0 6
29647: ST_TO_ADDR
// if not hexes then
29648: LD_VAR 0 14
29652: NOT
29653: IFFALSE 29657
// exit ;
29655: GO 30415
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
29657: LD_ADDR_VAR 0 17
29661: PUSH
29662: LD_VAR 0 5
29666: PPUSH
29667: LD_INT 22
29669: PUSH
29670: LD_VAR 0 13
29674: PPUSH
29675: CALL_OW 255
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 2
29686: PUSH
29687: LD_INT 30
29689: PUSH
29690: LD_INT 0
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PUSH
29697: LD_INT 30
29699: PUSH
29700: LD_INT 1
29702: PUSH
29703: EMPTY
29704: LIST
29705: LIST
29706: PUSH
29707: EMPTY
29708: LIST
29709: LIST
29710: LIST
29711: PUSH
29712: EMPTY
29713: LIST
29714: LIST
29715: PPUSH
29716: CALL_OW 72
29720: ST_TO_ADDR
// for i = 1 to hexes do
29721: LD_ADDR_VAR 0 9
29725: PUSH
29726: DOUBLE
29727: LD_INT 1
29729: DEC
29730: ST_TO_ADDR
29731: LD_VAR 0 14
29735: PUSH
29736: FOR_TO
29737: IFFALSE 30413
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29739: LD_ADDR_VAR 0 13
29743: PUSH
29744: LD_VAR 0 14
29748: PUSH
29749: LD_VAR 0 9
29753: ARRAY
29754: PUSH
29755: LD_INT 1
29757: ARRAY
29758: PPUSH
29759: LD_VAR 0 14
29763: PUSH
29764: LD_VAR 0 9
29768: ARRAY
29769: PUSH
29770: LD_INT 2
29772: ARRAY
29773: PPUSH
29774: CALL_OW 428
29778: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
29779: LD_VAR 0 14
29783: PUSH
29784: LD_VAR 0 9
29788: ARRAY
29789: PUSH
29790: LD_INT 1
29792: ARRAY
29793: PPUSH
29794: LD_VAR 0 14
29798: PUSH
29799: LD_VAR 0 9
29803: ARRAY
29804: PUSH
29805: LD_INT 2
29807: ARRAY
29808: PPUSH
29809: CALL_OW 351
29813: PUSH
29814: LD_VAR 0 14
29818: PUSH
29819: LD_VAR 0 9
29823: ARRAY
29824: PUSH
29825: LD_INT 1
29827: ARRAY
29828: PPUSH
29829: LD_VAR 0 14
29833: PUSH
29834: LD_VAR 0 9
29838: ARRAY
29839: PUSH
29840: LD_INT 2
29842: ARRAY
29843: PPUSH
29844: CALL_OW 488
29848: NOT
29849: OR
29850: PUSH
29851: LD_VAR 0 13
29855: PPUSH
29856: CALL_OW 247
29860: PUSH
29861: LD_INT 3
29863: EQUAL
29864: OR
29865: IFFALSE 29871
// exit ;
29867: POP
29868: POP
29869: GO 30415
// if not tmp then
29871: LD_VAR 0 13
29875: NOT
29876: IFFALSE 29880
// continue ;
29878: GO 29736
// result := true ;
29880: LD_ADDR_VAR 0 8
29884: PUSH
29885: LD_INT 1
29887: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
29888: LD_VAR 0 6
29892: PUSH
29893: LD_VAR 0 13
29897: PPUSH
29898: CALL_OW 247
29902: PUSH
29903: LD_INT 2
29905: EQUAL
29906: AND
29907: PUSH
29908: LD_VAR 0 13
29912: PPUSH
29913: CALL_OW 263
29917: PUSH
29918: LD_INT 1
29920: EQUAL
29921: AND
29922: IFFALSE 30086
// begin if IsDrivenBy ( tmp ) then
29924: LD_VAR 0 13
29928: PPUSH
29929: CALL_OW 311
29933: IFFALSE 29937
// continue ;
29935: GO 29736
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
29937: LD_VAR 0 6
29941: PPUSH
29942: LD_INT 3
29944: PUSH
29945: LD_INT 60
29947: PUSH
29948: EMPTY
29949: LIST
29950: PUSH
29951: EMPTY
29952: LIST
29953: LIST
29954: PUSH
29955: LD_INT 3
29957: PUSH
29958: LD_INT 55
29960: PUSH
29961: EMPTY
29962: LIST
29963: PUSH
29964: EMPTY
29965: LIST
29966: LIST
29967: PUSH
29968: EMPTY
29969: LIST
29970: LIST
29971: PPUSH
29972: CALL_OW 72
29976: IFFALSE 30084
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
29978: LD_ADDR_VAR 0 18
29982: PUSH
29983: LD_VAR 0 6
29987: PPUSH
29988: LD_INT 3
29990: PUSH
29991: LD_INT 60
29993: PUSH
29994: EMPTY
29995: LIST
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PUSH
30001: LD_INT 3
30003: PUSH
30004: LD_INT 55
30006: PUSH
30007: EMPTY
30008: LIST
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PPUSH
30018: CALL_OW 72
30022: PUSH
30023: LD_INT 1
30025: ARRAY
30026: ST_TO_ADDR
// if IsInUnit ( driver ) then
30027: LD_VAR 0 18
30031: PPUSH
30032: CALL_OW 310
30036: IFFALSE 30047
// ComExit ( driver ) ;
30038: LD_VAR 0 18
30042: PPUSH
30043: CALL 55469 0 1
// AddComEnterUnit ( driver , tmp ) ;
30047: LD_VAR 0 18
30051: PPUSH
30052: LD_VAR 0 13
30056: PPUSH
30057: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
30061: LD_VAR 0 18
30065: PPUSH
30066: LD_VAR 0 7
30070: PPUSH
30071: CALL_OW 173
// AddComExitVehicle ( driver ) ;
30075: LD_VAR 0 18
30079: PPUSH
30080: CALL_OW 181
// end ; continue ;
30084: GO 29736
// end ; if not cleaners or not tmp in cleaners then
30086: LD_VAR 0 6
30090: NOT
30091: PUSH
30092: LD_VAR 0 13
30096: PUSH
30097: LD_VAR 0 6
30101: IN
30102: NOT
30103: OR
30104: IFFALSE 30411
// begin if dep then
30106: LD_VAR 0 17
30110: IFFALSE 30246
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
30112: LD_ADDR_VAR 0 16
30116: PUSH
30117: LD_VAR 0 17
30121: PUSH
30122: LD_INT 1
30124: ARRAY
30125: PPUSH
30126: CALL_OW 250
30130: PPUSH
30131: LD_VAR 0 17
30135: PUSH
30136: LD_INT 1
30138: ARRAY
30139: PPUSH
30140: CALL_OW 254
30144: PPUSH
30145: LD_INT 5
30147: PPUSH
30148: CALL_OW 272
30152: PUSH
30153: LD_VAR 0 17
30157: PUSH
30158: LD_INT 1
30160: ARRAY
30161: PPUSH
30162: CALL_OW 251
30166: PPUSH
30167: LD_VAR 0 17
30171: PUSH
30172: LD_INT 1
30174: ARRAY
30175: PPUSH
30176: CALL_OW 254
30180: PPUSH
30181: LD_INT 5
30183: PPUSH
30184: CALL_OW 273
30188: PUSH
30189: EMPTY
30190: LIST
30191: LIST
30192: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
30193: LD_VAR 0 16
30197: PUSH
30198: LD_INT 1
30200: ARRAY
30201: PPUSH
30202: LD_VAR 0 16
30206: PUSH
30207: LD_INT 2
30209: ARRAY
30210: PPUSH
30211: CALL_OW 488
30215: IFFALSE 30246
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
30217: LD_VAR 0 13
30221: PPUSH
30222: LD_VAR 0 16
30226: PUSH
30227: LD_INT 1
30229: ARRAY
30230: PPUSH
30231: LD_VAR 0 16
30235: PUSH
30236: LD_INT 2
30238: ARRAY
30239: PPUSH
30240: CALL_OW 111
// continue ;
30244: GO 29736
// end ; end ; r := GetDir ( tmp ) ;
30246: LD_ADDR_VAR 0 15
30250: PUSH
30251: LD_VAR 0 13
30255: PPUSH
30256: CALL_OW 254
30260: ST_TO_ADDR
// if r = 5 then
30261: LD_VAR 0 15
30265: PUSH
30266: LD_INT 5
30268: EQUAL
30269: IFFALSE 30279
// r := 0 ;
30271: LD_ADDR_VAR 0 15
30275: PUSH
30276: LD_INT 0
30278: ST_TO_ADDR
// for j = r to 5 do
30279: LD_ADDR_VAR 0 10
30283: PUSH
30284: DOUBLE
30285: LD_VAR 0 15
30289: DEC
30290: ST_TO_ADDR
30291: LD_INT 5
30293: PUSH
30294: FOR_TO
30295: IFFALSE 30409
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
30297: LD_ADDR_VAR 0 11
30301: PUSH
30302: LD_VAR 0 13
30306: PPUSH
30307: CALL_OW 250
30311: PPUSH
30312: LD_VAR 0 10
30316: PPUSH
30317: LD_INT 2
30319: PPUSH
30320: CALL_OW 272
30324: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
30325: LD_ADDR_VAR 0 12
30329: PUSH
30330: LD_VAR 0 13
30334: PPUSH
30335: CALL_OW 251
30339: PPUSH
30340: LD_VAR 0 10
30344: PPUSH
30345: LD_INT 2
30347: PPUSH
30348: CALL_OW 273
30352: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
30353: LD_VAR 0 11
30357: PPUSH
30358: LD_VAR 0 12
30362: PPUSH
30363: CALL_OW 488
30367: PUSH
30368: LD_VAR 0 11
30372: PPUSH
30373: LD_VAR 0 12
30377: PPUSH
30378: CALL_OW 428
30382: NOT
30383: AND
30384: IFFALSE 30407
// begin ComMoveXY ( tmp , _x , _y ) ;
30386: LD_VAR 0 13
30390: PPUSH
30391: LD_VAR 0 11
30395: PPUSH
30396: LD_VAR 0 12
30400: PPUSH
30401: CALL_OW 111
// break ;
30405: GO 30409
// end ; end ;
30407: GO 30294
30409: POP
30410: POP
// end ; end ;
30411: GO 29736
30413: POP
30414: POP
// end ;
30415: LD_VAR 0 8
30419: RET
// export function BuildingTechInvented ( side , btype ) ; begin
30420: LD_INT 0
30422: PPUSH
// result := true ;
30423: LD_ADDR_VAR 0 3
30427: PUSH
30428: LD_INT 1
30430: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
30431: LD_VAR 0 2
30435: PUSH
30436: LD_INT 24
30438: DOUBLE
30439: EQUAL
30440: IFTRUE 30450
30442: LD_INT 33
30444: DOUBLE
30445: EQUAL
30446: IFTRUE 30450
30448: GO 30475
30450: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
30451: LD_ADDR_VAR 0 3
30455: PUSH
30456: LD_INT 32
30458: PPUSH
30459: LD_VAR 0 1
30463: PPUSH
30464: CALL_OW 321
30468: PUSH
30469: LD_INT 2
30471: EQUAL
30472: ST_TO_ADDR
30473: GO 30791
30475: LD_INT 20
30477: DOUBLE
30478: EQUAL
30479: IFTRUE 30483
30481: GO 30508
30483: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
30484: LD_ADDR_VAR 0 3
30488: PUSH
30489: LD_INT 6
30491: PPUSH
30492: LD_VAR 0 1
30496: PPUSH
30497: CALL_OW 321
30501: PUSH
30502: LD_INT 2
30504: EQUAL
30505: ST_TO_ADDR
30506: GO 30791
30508: LD_INT 22
30510: DOUBLE
30511: EQUAL
30512: IFTRUE 30522
30514: LD_INT 36
30516: DOUBLE
30517: EQUAL
30518: IFTRUE 30522
30520: GO 30547
30522: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
30523: LD_ADDR_VAR 0 3
30527: PUSH
30528: LD_INT 15
30530: PPUSH
30531: LD_VAR 0 1
30535: PPUSH
30536: CALL_OW 321
30540: PUSH
30541: LD_INT 2
30543: EQUAL
30544: ST_TO_ADDR
30545: GO 30791
30547: LD_INT 30
30549: DOUBLE
30550: EQUAL
30551: IFTRUE 30555
30553: GO 30580
30555: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
30556: LD_ADDR_VAR 0 3
30560: PUSH
30561: LD_INT 20
30563: PPUSH
30564: LD_VAR 0 1
30568: PPUSH
30569: CALL_OW 321
30573: PUSH
30574: LD_INT 2
30576: EQUAL
30577: ST_TO_ADDR
30578: GO 30791
30580: LD_INT 28
30582: DOUBLE
30583: EQUAL
30584: IFTRUE 30594
30586: LD_INT 21
30588: DOUBLE
30589: EQUAL
30590: IFTRUE 30594
30592: GO 30619
30594: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
30595: LD_ADDR_VAR 0 3
30599: PUSH
30600: LD_INT 21
30602: PPUSH
30603: LD_VAR 0 1
30607: PPUSH
30608: CALL_OW 321
30612: PUSH
30613: LD_INT 2
30615: EQUAL
30616: ST_TO_ADDR
30617: GO 30791
30619: LD_INT 16
30621: DOUBLE
30622: EQUAL
30623: IFTRUE 30627
30625: GO 30652
30627: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
30628: LD_ADDR_VAR 0 3
30632: PUSH
30633: LD_INT 84
30635: PPUSH
30636: LD_VAR 0 1
30640: PPUSH
30641: CALL_OW 321
30645: PUSH
30646: LD_INT 2
30648: EQUAL
30649: ST_TO_ADDR
30650: GO 30791
30652: LD_INT 19
30654: DOUBLE
30655: EQUAL
30656: IFTRUE 30666
30658: LD_INT 23
30660: DOUBLE
30661: EQUAL
30662: IFTRUE 30666
30664: GO 30691
30666: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
30667: LD_ADDR_VAR 0 3
30671: PUSH
30672: LD_INT 83
30674: PPUSH
30675: LD_VAR 0 1
30679: PPUSH
30680: CALL_OW 321
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: ST_TO_ADDR
30689: GO 30791
30691: LD_INT 17
30693: DOUBLE
30694: EQUAL
30695: IFTRUE 30699
30697: GO 30724
30699: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
30700: LD_ADDR_VAR 0 3
30704: PUSH
30705: LD_INT 39
30707: PPUSH
30708: LD_VAR 0 1
30712: PPUSH
30713: CALL_OW 321
30717: PUSH
30718: LD_INT 2
30720: EQUAL
30721: ST_TO_ADDR
30722: GO 30791
30724: LD_INT 18
30726: DOUBLE
30727: EQUAL
30728: IFTRUE 30732
30730: GO 30757
30732: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
30733: LD_ADDR_VAR 0 3
30737: PUSH
30738: LD_INT 40
30740: PPUSH
30741: LD_VAR 0 1
30745: PPUSH
30746: CALL_OW 321
30750: PUSH
30751: LD_INT 2
30753: EQUAL
30754: ST_TO_ADDR
30755: GO 30791
30757: LD_INT 27
30759: DOUBLE
30760: EQUAL
30761: IFTRUE 30765
30763: GO 30790
30765: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
30766: LD_ADDR_VAR 0 3
30770: PUSH
30771: LD_INT 35
30773: PPUSH
30774: LD_VAR 0 1
30778: PPUSH
30779: CALL_OW 321
30783: PUSH
30784: LD_INT 2
30786: EQUAL
30787: ST_TO_ADDR
30788: GO 30791
30790: POP
// end ;
30791: LD_VAR 0 3
30795: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
30796: LD_INT 0
30798: PPUSH
30799: PPUSH
30800: PPUSH
30801: PPUSH
30802: PPUSH
30803: PPUSH
30804: PPUSH
30805: PPUSH
30806: PPUSH
30807: PPUSH
30808: PPUSH
// result := false ;
30809: LD_ADDR_VAR 0 6
30813: PUSH
30814: LD_INT 0
30816: ST_TO_ADDR
// if btype = b_depot then
30817: LD_VAR 0 2
30821: PUSH
30822: LD_INT 0
30824: EQUAL
30825: IFFALSE 30837
// begin result := true ;
30827: LD_ADDR_VAR 0 6
30831: PUSH
30832: LD_INT 1
30834: ST_TO_ADDR
// exit ;
30835: GO 31663
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
30837: LD_VAR 0 1
30841: NOT
30842: PUSH
30843: LD_VAR 0 1
30847: PPUSH
30848: CALL_OW 266
30852: PUSH
30853: LD_INT 0
30855: PUSH
30856: LD_INT 1
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: IN
30863: NOT
30864: OR
30865: PUSH
30866: LD_VAR 0 2
30870: NOT
30871: OR
30872: PUSH
30873: LD_VAR 0 5
30877: PUSH
30878: LD_INT 0
30880: PUSH
30881: LD_INT 1
30883: PUSH
30884: LD_INT 2
30886: PUSH
30887: LD_INT 3
30889: PUSH
30890: LD_INT 4
30892: PUSH
30893: LD_INT 5
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: LIST
30900: LIST
30901: LIST
30902: LIST
30903: IN
30904: NOT
30905: OR
30906: PUSH
30907: LD_VAR 0 3
30911: PPUSH
30912: LD_VAR 0 4
30916: PPUSH
30917: CALL_OW 488
30921: NOT
30922: OR
30923: IFFALSE 30927
// exit ;
30925: GO 31663
// side := GetSide ( depot ) ;
30927: LD_ADDR_VAR 0 9
30931: PUSH
30932: LD_VAR 0 1
30936: PPUSH
30937: CALL_OW 255
30941: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
30942: LD_VAR 0 9
30946: PPUSH
30947: LD_VAR 0 2
30951: PPUSH
30952: CALL 30420 0 2
30956: NOT
30957: IFFALSE 30961
// exit ;
30959: GO 31663
// pom := GetBase ( depot ) ;
30961: LD_ADDR_VAR 0 10
30965: PUSH
30966: LD_VAR 0 1
30970: PPUSH
30971: CALL_OW 274
30975: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
30976: LD_ADDR_VAR 0 11
30980: PUSH
30981: LD_VAR 0 2
30985: PPUSH
30986: LD_VAR 0 1
30990: PPUSH
30991: CALL_OW 248
30995: PPUSH
30996: CALL_OW 450
31000: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
31001: LD_VAR 0 10
31005: PPUSH
31006: LD_INT 1
31008: PPUSH
31009: CALL_OW 275
31013: PUSH
31014: LD_VAR 0 11
31018: PUSH
31019: LD_INT 1
31021: ARRAY
31022: GREATEREQUAL
31023: PUSH
31024: LD_VAR 0 10
31028: PPUSH
31029: LD_INT 2
31031: PPUSH
31032: CALL_OW 275
31036: PUSH
31037: LD_VAR 0 11
31041: PUSH
31042: LD_INT 2
31044: ARRAY
31045: GREATEREQUAL
31046: AND
31047: PUSH
31048: LD_VAR 0 10
31052: PPUSH
31053: LD_INT 3
31055: PPUSH
31056: CALL_OW 275
31060: PUSH
31061: LD_VAR 0 11
31065: PUSH
31066: LD_INT 3
31068: ARRAY
31069: GREATEREQUAL
31070: AND
31071: NOT
31072: IFFALSE 31076
// exit ;
31074: GO 31663
// if GetBType ( depot ) = b_depot then
31076: LD_VAR 0 1
31080: PPUSH
31081: CALL_OW 266
31085: PUSH
31086: LD_INT 0
31088: EQUAL
31089: IFFALSE 31101
// dist := 28 else
31091: LD_ADDR_VAR 0 14
31095: PUSH
31096: LD_INT 28
31098: ST_TO_ADDR
31099: GO 31109
// dist := 36 ;
31101: LD_ADDR_VAR 0 14
31105: PUSH
31106: LD_INT 36
31108: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
31109: LD_VAR 0 1
31113: PPUSH
31114: LD_VAR 0 3
31118: PPUSH
31119: LD_VAR 0 4
31123: PPUSH
31124: CALL_OW 297
31128: PUSH
31129: LD_VAR 0 14
31133: GREATER
31134: IFFALSE 31138
// exit ;
31136: GO 31663
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
31138: LD_ADDR_VAR 0 12
31142: PUSH
31143: LD_VAR 0 2
31147: PPUSH
31148: LD_VAR 0 3
31152: PPUSH
31153: LD_VAR 0 4
31157: PPUSH
31158: LD_VAR 0 5
31162: PPUSH
31163: LD_VAR 0 1
31167: PPUSH
31168: CALL_OW 248
31172: PPUSH
31173: LD_INT 0
31175: PPUSH
31176: CALL 31668 0 6
31180: ST_TO_ADDR
// if not hexes then
31181: LD_VAR 0 12
31185: NOT
31186: IFFALSE 31190
// exit ;
31188: GO 31663
// hex := GetHexInfo ( x , y ) ;
31190: LD_ADDR_VAR 0 15
31194: PUSH
31195: LD_VAR 0 3
31199: PPUSH
31200: LD_VAR 0 4
31204: PPUSH
31205: CALL_OW 546
31209: ST_TO_ADDR
// if hex [ 1 ] then
31210: LD_VAR 0 15
31214: PUSH
31215: LD_INT 1
31217: ARRAY
31218: IFFALSE 31222
// exit ;
31220: GO 31663
// height := hex [ 2 ] ;
31222: LD_ADDR_VAR 0 13
31226: PUSH
31227: LD_VAR 0 15
31231: PUSH
31232: LD_INT 2
31234: ARRAY
31235: ST_TO_ADDR
// for i = 1 to hexes do
31236: LD_ADDR_VAR 0 7
31240: PUSH
31241: DOUBLE
31242: LD_INT 1
31244: DEC
31245: ST_TO_ADDR
31246: LD_VAR 0 12
31250: PUSH
31251: FOR_TO
31252: IFFALSE 31582
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
31254: LD_VAR 0 12
31258: PUSH
31259: LD_VAR 0 7
31263: ARRAY
31264: PUSH
31265: LD_INT 1
31267: ARRAY
31268: PPUSH
31269: LD_VAR 0 12
31273: PUSH
31274: LD_VAR 0 7
31278: ARRAY
31279: PUSH
31280: LD_INT 2
31282: ARRAY
31283: PPUSH
31284: CALL_OW 488
31288: NOT
31289: PUSH
31290: LD_VAR 0 12
31294: PUSH
31295: LD_VAR 0 7
31299: ARRAY
31300: PUSH
31301: LD_INT 1
31303: ARRAY
31304: PPUSH
31305: LD_VAR 0 12
31309: PUSH
31310: LD_VAR 0 7
31314: ARRAY
31315: PUSH
31316: LD_INT 2
31318: ARRAY
31319: PPUSH
31320: CALL_OW 428
31324: PUSH
31325: LD_INT 0
31327: GREATER
31328: OR
31329: PUSH
31330: LD_VAR 0 12
31334: PUSH
31335: LD_VAR 0 7
31339: ARRAY
31340: PUSH
31341: LD_INT 1
31343: ARRAY
31344: PPUSH
31345: LD_VAR 0 12
31349: PUSH
31350: LD_VAR 0 7
31354: ARRAY
31355: PUSH
31356: LD_INT 2
31358: ARRAY
31359: PPUSH
31360: CALL_OW 351
31364: OR
31365: IFFALSE 31371
// exit ;
31367: POP
31368: POP
31369: GO 31663
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
31371: LD_ADDR_VAR 0 8
31375: PUSH
31376: LD_VAR 0 12
31380: PUSH
31381: LD_VAR 0 7
31385: ARRAY
31386: PUSH
31387: LD_INT 1
31389: ARRAY
31390: PPUSH
31391: LD_VAR 0 12
31395: PUSH
31396: LD_VAR 0 7
31400: ARRAY
31401: PUSH
31402: LD_INT 2
31404: ARRAY
31405: PPUSH
31406: CALL_OW 546
31410: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
31411: LD_VAR 0 8
31415: PUSH
31416: LD_INT 1
31418: ARRAY
31419: PUSH
31420: LD_VAR 0 8
31424: PUSH
31425: LD_INT 2
31427: ARRAY
31428: PUSH
31429: LD_VAR 0 13
31433: PUSH
31434: LD_INT 2
31436: PLUS
31437: GREATER
31438: OR
31439: PUSH
31440: LD_VAR 0 8
31444: PUSH
31445: LD_INT 2
31447: ARRAY
31448: PUSH
31449: LD_VAR 0 13
31453: PUSH
31454: LD_INT 2
31456: MINUS
31457: LESS
31458: OR
31459: PUSH
31460: LD_VAR 0 8
31464: PUSH
31465: LD_INT 3
31467: ARRAY
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: LD_INT 8
31474: PUSH
31475: LD_INT 9
31477: PUSH
31478: LD_INT 10
31480: PUSH
31481: LD_INT 11
31483: PUSH
31484: LD_INT 12
31486: PUSH
31487: LD_INT 13
31489: PUSH
31490: LD_INT 16
31492: PUSH
31493: LD_INT 17
31495: PUSH
31496: LD_INT 18
31498: PUSH
31499: LD_INT 19
31501: PUSH
31502: LD_INT 20
31504: PUSH
31505: LD_INT 21
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: LIST
31512: LIST
31513: LIST
31514: LIST
31515: LIST
31516: LIST
31517: LIST
31518: LIST
31519: LIST
31520: LIST
31521: LIST
31522: IN
31523: NOT
31524: OR
31525: PUSH
31526: LD_VAR 0 8
31530: PUSH
31531: LD_INT 5
31533: ARRAY
31534: NOT
31535: OR
31536: PUSH
31537: LD_VAR 0 8
31541: PUSH
31542: LD_INT 6
31544: ARRAY
31545: PUSH
31546: LD_INT 1
31548: PUSH
31549: LD_INT 2
31551: PUSH
31552: LD_INT 7
31554: PUSH
31555: LD_INT 9
31557: PUSH
31558: LD_INT 10
31560: PUSH
31561: LD_INT 11
31563: PUSH
31564: EMPTY
31565: LIST
31566: LIST
31567: LIST
31568: LIST
31569: LIST
31570: LIST
31571: IN
31572: NOT
31573: OR
31574: IFFALSE 31580
// exit ;
31576: POP
31577: POP
31578: GO 31663
// end ;
31580: GO 31251
31582: POP
31583: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
31584: LD_VAR 0 9
31588: PPUSH
31589: LD_VAR 0 3
31593: PPUSH
31594: LD_VAR 0 4
31598: PPUSH
31599: LD_INT 20
31601: PPUSH
31602: CALL 23586 0 4
31606: PUSH
31607: LD_INT 4
31609: ARRAY
31610: IFFALSE 31614
// exit ;
31612: GO 31663
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
31614: LD_VAR 0 2
31618: PUSH
31619: LD_INT 29
31621: PUSH
31622: LD_INT 30
31624: PUSH
31625: EMPTY
31626: LIST
31627: LIST
31628: IN
31629: PUSH
31630: LD_VAR 0 3
31634: PPUSH
31635: LD_VAR 0 4
31639: PPUSH
31640: LD_VAR 0 9
31644: PPUSH
31645: CALL_OW 440
31649: NOT
31650: AND
31651: IFFALSE 31655
// exit ;
31653: GO 31663
// result := true ;
31655: LD_ADDR_VAR 0 6
31659: PUSH
31660: LD_INT 1
31662: ST_TO_ADDR
// end ;
31663: LD_VAR 0 6
31667: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
31668: LD_INT 0
31670: PPUSH
31671: PPUSH
31672: PPUSH
31673: PPUSH
31674: PPUSH
31675: PPUSH
31676: PPUSH
31677: PPUSH
31678: PPUSH
31679: PPUSH
31680: PPUSH
31681: PPUSH
31682: PPUSH
31683: PPUSH
31684: PPUSH
31685: PPUSH
31686: PPUSH
31687: PPUSH
31688: PPUSH
31689: PPUSH
31690: PPUSH
31691: PPUSH
31692: PPUSH
31693: PPUSH
31694: PPUSH
31695: PPUSH
31696: PPUSH
31697: PPUSH
31698: PPUSH
31699: PPUSH
31700: PPUSH
31701: PPUSH
31702: PPUSH
31703: PPUSH
31704: PPUSH
31705: PPUSH
31706: PPUSH
31707: PPUSH
31708: PPUSH
31709: PPUSH
31710: PPUSH
31711: PPUSH
31712: PPUSH
31713: PPUSH
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
31724: PPUSH
31725: PPUSH
31726: PPUSH
31727: PPUSH
// result = [ ] ;
31728: LD_ADDR_VAR 0 7
31732: PUSH
31733: EMPTY
31734: ST_TO_ADDR
// temp_list = [ ] ;
31735: LD_ADDR_VAR 0 9
31739: PUSH
31740: EMPTY
31741: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
31742: LD_VAR 0 4
31746: PUSH
31747: LD_INT 0
31749: PUSH
31750: LD_INT 1
31752: PUSH
31753: LD_INT 2
31755: PUSH
31756: LD_INT 3
31758: PUSH
31759: LD_INT 4
31761: PUSH
31762: LD_INT 5
31764: PUSH
31765: EMPTY
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: IN
31773: NOT
31774: PUSH
31775: LD_VAR 0 1
31779: PUSH
31780: LD_INT 0
31782: PUSH
31783: LD_INT 1
31785: PUSH
31786: EMPTY
31787: LIST
31788: LIST
31789: IN
31790: PUSH
31791: LD_VAR 0 5
31795: PUSH
31796: LD_INT 1
31798: PUSH
31799: LD_INT 2
31801: PUSH
31802: LD_INT 3
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: LIST
31809: IN
31810: NOT
31811: AND
31812: OR
31813: IFFALSE 31817
// exit ;
31815: GO 50208
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
31817: LD_VAR 0 1
31821: PUSH
31822: LD_INT 6
31824: PUSH
31825: LD_INT 7
31827: PUSH
31828: LD_INT 8
31830: PUSH
31831: LD_INT 13
31833: PUSH
31834: LD_INT 12
31836: PUSH
31837: LD_INT 15
31839: PUSH
31840: LD_INT 11
31842: PUSH
31843: LD_INT 14
31845: PUSH
31846: LD_INT 10
31848: PUSH
31849: EMPTY
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: IN
31860: IFFALSE 31870
// btype = b_lab ;
31862: LD_ADDR_VAR 0 1
31866: PUSH
31867: LD_INT 6
31869: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
31870: LD_VAR 0 6
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: LD_INT 1
31880: PUSH
31881: LD_INT 2
31883: PUSH
31884: EMPTY
31885: LIST
31886: LIST
31887: LIST
31888: IN
31889: NOT
31890: PUSH
31891: LD_VAR 0 1
31895: PUSH
31896: LD_INT 0
31898: PUSH
31899: LD_INT 1
31901: PUSH
31902: LD_INT 2
31904: PUSH
31905: LD_INT 3
31907: PUSH
31908: LD_INT 6
31910: PUSH
31911: LD_INT 36
31913: PUSH
31914: LD_INT 4
31916: PUSH
31917: LD_INT 5
31919: PUSH
31920: LD_INT 31
31922: PUSH
31923: LD_INT 32
31925: PUSH
31926: LD_INT 33
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: IN
31942: NOT
31943: PUSH
31944: LD_VAR 0 6
31948: PUSH
31949: LD_INT 1
31951: EQUAL
31952: AND
31953: OR
31954: PUSH
31955: LD_VAR 0 1
31959: PUSH
31960: LD_INT 2
31962: PUSH
31963: LD_INT 3
31965: PUSH
31966: EMPTY
31967: LIST
31968: LIST
31969: IN
31970: NOT
31971: PUSH
31972: LD_VAR 0 6
31976: PUSH
31977: LD_INT 2
31979: EQUAL
31980: AND
31981: OR
31982: IFFALSE 31992
// mode = 0 ;
31984: LD_ADDR_VAR 0 6
31988: PUSH
31989: LD_INT 0
31991: ST_TO_ADDR
// case mode of 0 :
31992: LD_VAR 0 6
31996: PUSH
31997: LD_INT 0
31999: DOUBLE
32000: EQUAL
32001: IFTRUE 32005
32003: GO 43458
32005: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
32006: LD_ADDR_VAR 0 11
32010: PUSH
32011: LD_INT 0
32013: PUSH
32014: LD_INT 0
32016: PUSH
32017: EMPTY
32018: LIST
32019: LIST
32020: PUSH
32021: LD_INT 0
32023: PUSH
32024: LD_INT 1
32026: NEG
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 1
32034: PUSH
32035: LD_INT 0
32037: PUSH
32038: EMPTY
32039: LIST
32040: LIST
32041: PUSH
32042: LD_INT 1
32044: PUSH
32045: LD_INT 1
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PUSH
32052: LD_INT 0
32054: PUSH
32055: LD_INT 1
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: PUSH
32062: LD_INT 1
32064: NEG
32065: PUSH
32066: LD_INT 0
32068: PUSH
32069: EMPTY
32070: LIST
32071: LIST
32072: PUSH
32073: LD_INT 1
32075: NEG
32076: PUSH
32077: LD_INT 1
32079: NEG
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 1
32087: NEG
32088: PUSH
32089: LD_INT 2
32091: NEG
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 0
32099: PUSH
32100: LD_INT 2
32102: NEG
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: PUSH
32111: LD_INT 1
32113: NEG
32114: PUSH
32115: EMPTY
32116: LIST
32117: LIST
32118: PUSH
32119: LD_INT 1
32121: PUSH
32122: LD_INT 2
32124: PUSH
32125: EMPTY
32126: LIST
32127: LIST
32128: PUSH
32129: LD_INT 0
32131: PUSH
32132: LD_INT 2
32134: PUSH
32135: EMPTY
32136: LIST
32137: LIST
32138: PUSH
32139: LD_INT 1
32141: NEG
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: EMPTY
32147: LIST
32148: LIST
32149: PUSH
32150: LD_INT 1
32152: PUSH
32153: LD_INT 3
32155: PUSH
32156: EMPTY
32157: LIST
32158: LIST
32159: PUSH
32160: LD_INT 0
32162: PUSH
32163: LD_INT 3
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: LD_INT 2
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: EMPTY
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: LIST
32189: LIST
32190: LIST
32191: LIST
32192: LIST
32193: LIST
32194: LIST
32195: LIST
32196: LIST
32197: LIST
32198: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
32199: LD_ADDR_VAR 0 12
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: LD_INT 0
32209: PUSH
32210: EMPTY
32211: LIST
32212: LIST
32213: PUSH
32214: LD_INT 0
32216: PUSH
32217: LD_INT 1
32219: NEG
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: LD_INT 0
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 1
32237: PUSH
32238: LD_INT 1
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 0
32247: PUSH
32248: LD_INT 1
32250: PUSH
32251: EMPTY
32252: LIST
32253: LIST
32254: PUSH
32255: LD_INT 1
32257: NEG
32258: PUSH
32259: LD_INT 0
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 1
32268: NEG
32269: PUSH
32270: LD_INT 1
32272: NEG
32273: PUSH
32274: EMPTY
32275: LIST
32276: LIST
32277: PUSH
32278: LD_INT 1
32280: PUSH
32281: LD_INT 1
32283: NEG
32284: PUSH
32285: EMPTY
32286: LIST
32287: LIST
32288: PUSH
32289: LD_INT 2
32291: PUSH
32292: LD_INT 0
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: PUSH
32299: LD_INT 2
32301: PUSH
32302: LD_INT 1
32304: PUSH
32305: EMPTY
32306: LIST
32307: LIST
32308: PUSH
32309: LD_INT 1
32311: NEG
32312: PUSH
32313: LD_INT 1
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: LD_INT 2
32322: NEG
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: EMPTY
32328: LIST
32329: LIST
32330: PUSH
32331: LD_INT 2
32333: NEG
32334: PUSH
32335: LD_INT 1
32337: NEG
32338: PUSH
32339: EMPTY
32340: LIST
32341: LIST
32342: PUSH
32343: LD_INT 2
32345: NEG
32346: PUSH
32347: LD_INT 1
32349: PUSH
32350: EMPTY
32351: LIST
32352: LIST
32353: PUSH
32354: LD_INT 3
32356: NEG
32357: PUSH
32358: LD_INT 0
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 3
32367: NEG
32368: PUSH
32369: LD_INT 1
32371: NEG
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: LIST
32383: LIST
32384: LIST
32385: LIST
32386: LIST
32387: LIST
32388: LIST
32389: LIST
32390: LIST
32391: LIST
32392: LIST
32393: LIST
32394: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
32395: LD_ADDR_VAR 0 13
32399: PUSH
32400: LD_INT 0
32402: PUSH
32403: LD_INT 0
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 0
32412: PUSH
32413: LD_INT 1
32415: NEG
32416: PUSH
32417: EMPTY
32418: LIST
32419: LIST
32420: PUSH
32421: LD_INT 1
32423: PUSH
32424: LD_INT 0
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PUSH
32431: LD_INT 1
32433: PUSH
32434: LD_INT 1
32436: PUSH
32437: EMPTY
32438: LIST
32439: LIST
32440: PUSH
32441: LD_INT 0
32443: PUSH
32444: LD_INT 1
32446: PUSH
32447: EMPTY
32448: LIST
32449: LIST
32450: PUSH
32451: LD_INT 1
32453: NEG
32454: PUSH
32455: LD_INT 0
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 1
32464: NEG
32465: PUSH
32466: LD_INT 1
32468: NEG
32469: PUSH
32470: EMPTY
32471: LIST
32472: LIST
32473: PUSH
32474: LD_INT 1
32476: NEG
32477: PUSH
32478: LD_INT 2
32480: NEG
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: LD_INT 2
32488: PUSH
32489: LD_INT 1
32491: PUSH
32492: EMPTY
32493: LIST
32494: LIST
32495: PUSH
32496: LD_INT 2
32498: PUSH
32499: LD_INT 2
32501: PUSH
32502: EMPTY
32503: LIST
32504: LIST
32505: PUSH
32506: LD_INT 1
32508: PUSH
32509: LD_INT 2
32511: PUSH
32512: EMPTY
32513: LIST
32514: LIST
32515: PUSH
32516: LD_INT 2
32518: NEG
32519: PUSH
32520: LD_INT 1
32522: NEG
32523: PUSH
32524: EMPTY
32525: LIST
32526: LIST
32527: PUSH
32528: LD_INT 2
32530: NEG
32531: PUSH
32532: LD_INT 2
32534: NEG
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 2
32542: NEG
32543: PUSH
32544: LD_INT 3
32546: NEG
32547: PUSH
32548: EMPTY
32549: LIST
32550: LIST
32551: PUSH
32552: LD_INT 3
32554: NEG
32555: PUSH
32556: LD_INT 2
32558: NEG
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: LD_INT 3
32566: NEG
32567: PUSH
32568: LD_INT 3
32570: NEG
32571: PUSH
32572: EMPTY
32573: LIST
32574: LIST
32575: PUSH
32576: EMPTY
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
32594: LD_ADDR_VAR 0 14
32598: PUSH
32599: LD_INT 0
32601: PUSH
32602: LD_INT 0
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 0
32611: PUSH
32612: LD_INT 1
32614: NEG
32615: PUSH
32616: EMPTY
32617: LIST
32618: LIST
32619: PUSH
32620: LD_INT 1
32622: PUSH
32623: LD_INT 0
32625: PUSH
32626: EMPTY
32627: LIST
32628: LIST
32629: PUSH
32630: LD_INT 1
32632: PUSH
32633: LD_INT 1
32635: PUSH
32636: EMPTY
32637: LIST
32638: LIST
32639: PUSH
32640: LD_INT 0
32642: PUSH
32643: LD_INT 1
32645: PUSH
32646: EMPTY
32647: LIST
32648: LIST
32649: PUSH
32650: LD_INT 1
32652: NEG
32653: PUSH
32654: LD_INT 0
32656: PUSH
32657: EMPTY
32658: LIST
32659: LIST
32660: PUSH
32661: LD_INT 1
32663: NEG
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: EMPTY
32670: LIST
32671: LIST
32672: PUSH
32673: LD_INT 1
32675: NEG
32676: PUSH
32677: LD_INT 2
32679: NEG
32680: PUSH
32681: EMPTY
32682: LIST
32683: LIST
32684: PUSH
32685: LD_INT 0
32687: PUSH
32688: LD_INT 2
32690: NEG
32691: PUSH
32692: EMPTY
32693: LIST
32694: LIST
32695: PUSH
32696: LD_INT 1
32698: PUSH
32699: LD_INT 1
32701: NEG
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 1
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: EMPTY
32714: LIST
32715: LIST
32716: PUSH
32717: LD_INT 0
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: EMPTY
32724: LIST
32725: LIST
32726: PUSH
32727: LD_INT 1
32729: NEG
32730: PUSH
32731: LD_INT 1
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 1
32740: NEG
32741: PUSH
32742: LD_INT 3
32744: NEG
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: LD_INT 3
32755: NEG
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 1
32763: PUSH
32764: LD_INT 2
32766: NEG
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: EMPTY
32773: LIST
32774: LIST
32775: LIST
32776: LIST
32777: LIST
32778: LIST
32779: LIST
32780: LIST
32781: LIST
32782: LIST
32783: LIST
32784: LIST
32785: LIST
32786: LIST
32787: LIST
32788: LIST
32789: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
32790: LD_ADDR_VAR 0 15
32794: PUSH
32795: LD_INT 0
32797: PUSH
32798: LD_INT 0
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: LD_INT 1
32810: NEG
32811: PUSH
32812: EMPTY
32813: LIST
32814: LIST
32815: PUSH
32816: LD_INT 1
32818: PUSH
32819: LD_INT 0
32821: PUSH
32822: EMPTY
32823: LIST
32824: LIST
32825: PUSH
32826: LD_INT 1
32828: PUSH
32829: LD_INT 1
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 0
32838: PUSH
32839: LD_INT 1
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: PUSH
32846: LD_INT 1
32848: NEG
32849: PUSH
32850: LD_INT 0
32852: PUSH
32853: EMPTY
32854: LIST
32855: LIST
32856: PUSH
32857: LD_INT 1
32859: NEG
32860: PUSH
32861: LD_INT 1
32863: NEG
32864: PUSH
32865: EMPTY
32866: LIST
32867: LIST
32868: PUSH
32869: LD_INT 1
32871: PUSH
32872: LD_INT 1
32874: NEG
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 2
32882: PUSH
32883: LD_INT 0
32885: PUSH
32886: EMPTY
32887: LIST
32888: LIST
32889: PUSH
32890: LD_INT 2
32892: PUSH
32893: LD_INT 1
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 1
32902: NEG
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 2
32913: NEG
32914: PUSH
32915: LD_INT 0
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 2
32924: NEG
32925: PUSH
32926: LD_INT 1
32928: NEG
32929: PUSH
32930: EMPTY
32931: LIST
32932: LIST
32933: PUSH
32934: LD_INT 2
32936: PUSH
32937: LD_INT 1
32939: NEG
32940: PUSH
32941: EMPTY
32942: LIST
32943: LIST
32944: PUSH
32945: LD_INT 3
32947: PUSH
32948: LD_INT 0
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 3
32957: PUSH
32958: LD_INT 1
32960: PUSH
32961: EMPTY
32962: LIST
32963: LIST
32964: PUSH
32965: EMPTY
32966: LIST
32967: LIST
32968: LIST
32969: LIST
32970: LIST
32971: LIST
32972: LIST
32973: LIST
32974: LIST
32975: LIST
32976: LIST
32977: LIST
32978: LIST
32979: LIST
32980: LIST
32981: LIST
32982: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
32983: LD_ADDR_VAR 0 16
32987: PUSH
32988: LD_INT 0
32990: PUSH
32991: LD_INT 0
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 0
33000: PUSH
33001: LD_INT 1
33003: NEG
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: LD_INT 0
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 1
33021: PUSH
33022: LD_INT 1
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 0
33031: PUSH
33032: LD_INT 1
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 1
33041: NEG
33042: PUSH
33043: LD_INT 0
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 1
33052: NEG
33053: PUSH
33054: LD_INT 1
33056: NEG
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 1
33064: NEG
33065: PUSH
33066: LD_INT 2
33068: NEG
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 2
33076: PUSH
33077: LD_INT 1
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 2
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: LD_INT 2
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 2
33106: NEG
33107: PUSH
33108: LD_INT 1
33110: NEG
33111: PUSH
33112: EMPTY
33113: LIST
33114: LIST
33115: PUSH
33116: LD_INT 2
33118: NEG
33119: PUSH
33120: LD_INT 2
33122: NEG
33123: PUSH
33124: EMPTY
33125: LIST
33126: LIST
33127: PUSH
33128: LD_INT 3
33130: PUSH
33131: LD_INT 2
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: PUSH
33138: LD_INT 3
33140: PUSH
33141: LD_INT 3
33143: PUSH
33144: EMPTY
33145: LIST
33146: LIST
33147: PUSH
33148: LD_INT 2
33150: PUSH
33151: LD_INT 3
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33176: LD_ADDR_VAR 0 17
33180: PUSH
33181: LD_INT 0
33183: PUSH
33184: LD_INT 0
33186: PUSH
33187: EMPTY
33188: LIST
33189: LIST
33190: PUSH
33191: LD_INT 0
33193: PUSH
33194: LD_INT 1
33196: NEG
33197: PUSH
33198: EMPTY
33199: LIST
33200: LIST
33201: PUSH
33202: LD_INT 1
33204: PUSH
33205: LD_INT 0
33207: PUSH
33208: EMPTY
33209: LIST
33210: LIST
33211: PUSH
33212: LD_INT 1
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: EMPTY
33219: LIST
33220: LIST
33221: PUSH
33222: LD_INT 0
33224: PUSH
33225: LD_INT 1
33227: PUSH
33228: EMPTY
33229: LIST
33230: LIST
33231: PUSH
33232: LD_INT 1
33234: NEG
33235: PUSH
33236: LD_INT 0
33238: PUSH
33239: EMPTY
33240: LIST
33241: LIST
33242: PUSH
33243: LD_INT 1
33245: NEG
33246: PUSH
33247: LD_INT 1
33249: NEG
33250: PUSH
33251: EMPTY
33252: LIST
33253: LIST
33254: PUSH
33255: LD_INT 1
33257: NEG
33258: PUSH
33259: LD_INT 2
33261: NEG
33262: PUSH
33263: EMPTY
33264: LIST
33265: LIST
33266: PUSH
33267: LD_INT 0
33269: PUSH
33270: LD_INT 2
33272: NEG
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: LD_INT 1
33283: NEG
33284: PUSH
33285: EMPTY
33286: LIST
33287: LIST
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: LD_INT 0
33294: PUSH
33295: EMPTY
33296: LIST
33297: LIST
33298: PUSH
33299: LD_INT 2
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 2
33311: PUSH
33312: LD_INT 2
33314: PUSH
33315: EMPTY
33316: LIST
33317: LIST
33318: PUSH
33319: LD_INT 1
33321: PUSH
33322: LD_INT 2
33324: PUSH
33325: EMPTY
33326: LIST
33327: LIST
33328: PUSH
33329: LD_INT 0
33331: PUSH
33332: LD_INT 2
33334: PUSH
33335: EMPTY
33336: LIST
33337: LIST
33338: PUSH
33339: LD_INT 1
33341: NEG
33342: PUSH
33343: LD_INT 1
33345: PUSH
33346: EMPTY
33347: LIST
33348: LIST
33349: PUSH
33350: LD_INT 2
33352: NEG
33353: PUSH
33354: LD_INT 0
33356: PUSH
33357: EMPTY
33358: LIST
33359: LIST
33360: PUSH
33361: LD_INT 2
33363: NEG
33364: PUSH
33365: LD_INT 1
33367: NEG
33368: PUSH
33369: EMPTY
33370: LIST
33371: LIST
33372: PUSH
33373: LD_INT 2
33375: NEG
33376: PUSH
33377: LD_INT 2
33379: NEG
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: EMPTY
33386: LIST
33387: LIST
33388: LIST
33389: LIST
33390: LIST
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33406: LD_ADDR_VAR 0 18
33410: PUSH
33411: LD_INT 0
33413: PUSH
33414: LD_INT 0
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 0
33423: PUSH
33424: LD_INT 1
33426: NEG
33427: PUSH
33428: EMPTY
33429: LIST
33430: LIST
33431: PUSH
33432: LD_INT 1
33434: PUSH
33435: LD_INT 0
33437: PUSH
33438: EMPTY
33439: LIST
33440: LIST
33441: PUSH
33442: LD_INT 1
33444: PUSH
33445: LD_INT 1
33447: PUSH
33448: EMPTY
33449: LIST
33450: LIST
33451: PUSH
33452: LD_INT 0
33454: PUSH
33455: LD_INT 1
33457: PUSH
33458: EMPTY
33459: LIST
33460: LIST
33461: PUSH
33462: LD_INT 1
33464: NEG
33465: PUSH
33466: LD_INT 0
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 1
33475: NEG
33476: PUSH
33477: LD_INT 1
33479: NEG
33480: PUSH
33481: EMPTY
33482: LIST
33483: LIST
33484: PUSH
33485: LD_INT 1
33487: NEG
33488: PUSH
33489: LD_INT 2
33491: NEG
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: PUSH
33497: LD_INT 0
33499: PUSH
33500: LD_INT 2
33502: NEG
33503: PUSH
33504: EMPTY
33505: LIST
33506: LIST
33507: PUSH
33508: LD_INT 1
33510: PUSH
33511: LD_INT 1
33513: NEG
33514: PUSH
33515: EMPTY
33516: LIST
33517: LIST
33518: PUSH
33519: LD_INT 2
33521: PUSH
33522: LD_INT 0
33524: PUSH
33525: EMPTY
33526: LIST
33527: LIST
33528: PUSH
33529: LD_INT 2
33531: PUSH
33532: LD_INT 1
33534: PUSH
33535: EMPTY
33536: LIST
33537: LIST
33538: PUSH
33539: LD_INT 2
33541: PUSH
33542: LD_INT 2
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: LD_INT 2
33554: PUSH
33555: EMPTY
33556: LIST
33557: LIST
33558: PUSH
33559: LD_INT 0
33561: PUSH
33562: LD_INT 2
33564: PUSH
33565: EMPTY
33566: LIST
33567: LIST
33568: PUSH
33569: LD_INT 1
33571: NEG
33572: PUSH
33573: LD_INT 1
33575: PUSH
33576: EMPTY
33577: LIST
33578: LIST
33579: PUSH
33580: LD_INT 2
33582: NEG
33583: PUSH
33584: LD_INT 0
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 2
33593: NEG
33594: PUSH
33595: LD_INT 1
33597: NEG
33598: PUSH
33599: EMPTY
33600: LIST
33601: LIST
33602: PUSH
33603: LD_INT 2
33605: NEG
33606: PUSH
33607: LD_INT 2
33609: NEG
33610: PUSH
33611: EMPTY
33612: LIST
33613: LIST
33614: PUSH
33615: EMPTY
33616: LIST
33617: LIST
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: LIST
33623: LIST
33624: LIST
33625: LIST
33626: LIST
33627: LIST
33628: LIST
33629: LIST
33630: LIST
33631: LIST
33632: LIST
33633: LIST
33634: LIST
33635: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33636: LD_ADDR_VAR 0 19
33640: PUSH
33641: LD_INT 0
33643: PUSH
33644: LD_INT 0
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 0
33653: PUSH
33654: LD_INT 1
33656: NEG
33657: PUSH
33658: EMPTY
33659: LIST
33660: LIST
33661: PUSH
33662: LD_INT 1
33664: PUSH
33665: LD_INT 0
33667: PUSH
33668: EMPTY
33669: LIST
33670: LIST
33671: PUSH
33672: LD_INT 1
33674: PUSH
33675: LD_INT 1
33677: PUSH
33678: EMPTY
33679: LIST
33680: LIST
33681: PUSH
33682: LD_INT 0
33684: PUSH
33685: LD_INT 1
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 1
33694: NEG
33695: PUSH
33696: LD_INT 0
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 1
33705: NEG
33706: PUSH
33707: LD_INT 1
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 1
33717: NEG
33718: PUSH
33719: LD_INT 2
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 0
33729: PUSH
33730: LD_INT 2
33732: NEG
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 1
33740: PUSH
33741: LD_INT 1
33743: NEG
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 2
33751: PUSH
33752: LD_INT 0
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 2
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 2
33771: PUSH
33772: LD_INT 2
33774: PUSH
33775: EMPTY
33776: LIST
33777: LIST
33778: PUSH
33779: LD_INT 1
33781: PUSH
33782: LD_INT 2
33784: PUSH
33785: EMPTY
33786: LIST
33787: LIST
33788: PUSH
33789: LD_INT 0
33791: PUSH
33792: LD_INT 2
33794: PUSH
33795: EMPTY
33796: LIST
33797: LIST
33798: PUSH
33799: LD_INT 1
33801: NEG
33802: PUSH
33803: LD_INT 1
33805: PUSH
33806: EMPTY
33807: LIST
33808: LIST
33809: PUSH
33810: LD_INT 2
33812: NEG
33813: PUSH
33814: LD_INT 0
33816: PUSH
33817: EMPTY
33818: LIST
33819: LIST
33820: PUSH
33821: LD_INT 2
33823: NEG
33824: PUSH
33825: LD_INT 1
33827: NEG
33828: PUSH
33829: EMPTY
33830: LIST
33831: LIST
33832: PUSH
33833: LD_INT 2
33835: NEG
33836: PUSH
33837: LD_INT 2
33839: NEG
33840: PUSH
33841: EMPTY
33842: LIST
33843: LIST
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: LIST
33857: LIST
33858: LIST
33859: LIST
33860: LIST
33861: LIST
33862: LIST
33863: LIST
33864: LIST
33865: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
33866: LD_ADDR_VAR 0 20
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 0
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 0
33883: PUSH
33884: LD_INT 1
33886: NEG
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: PUSH
33895: LD_INT 0
33897: PUSH
33898: EMPTY
33899: LIST
33900: LIST
33901: PUSH
33902: LD_INT 1
33904: PUSH
33905: LD_INT 1
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 0
33914: PUSH
33915: LD_INT 1
33917: PUSH
33918: EMPTY
33919: LIST
33920: LIST
33921: PUSH
33922: LD_INT 1
33924: NEG
33925: PUSH
33926: LD_INT 0
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: PUSH
33933: LD_INT 1
33935: NEG
33936: PUSH
33937: LD_INT 1
33939: NEG
33940: PUSH
33941: EMPTY
33942: LIST
33943: LIST
33944: PUSH
33945: LD_INT 1
33947: NEG
33948: PUSH
33949: LD_INT 2
33951: NEG
33952: PUSH
33953: EMPTY
33954: LIST
33955: LIST
33956: PUSH
33957: LD_INT 0
33959: PUSH
33960: LD_INT 2
33962: NEG
33963: PUSH
33964: EMPTY
33965: LIST
33966: LIST
33967: PUSH
33968: LD_INT 1
33970: PUSH
33971: LD_INT 1
33973: NEG
33974: PUSH
33975: EMPTY
33976: LIST
33977: LIST
33978: PUSH
33979: LD_INT 2
33981: PUSH
33982: LD_INT 0
33984: PUSH
33985: EMPTY
33986: LIST
33987: LIST
33988: PUSH
33989: LD_INT 2
33991: PUSH
33992: LD_INT 1
33994: PUSH
33995: EMPTY
33996: LIST
33997: LIST
33998: PUSH
33999: LD_INT 2
34001: PUSH
34002: LD_INT 2
34004: PUSH
34005: EMPTY
34006: LIST
34007: LIST
34008: PUSH
34009: LD_INT 1
34011: PUSH
34012: LD_INT 2
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 0
34021: PUSH
34022: LD_INT 2
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 1
34031: NEG
34032: PUSH
34033: LD_INT 1
34035: PUSH
34036: EMPTY
34037: LIST
34038: LIST
34039: PUSH
34040: LD_INT 2
34042: NEG
34043: PUSH
34044: LD_INT 0
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: PUSH
34051: LD_INT 2
34053: NEG
34054: PUSH
34055: LD_INT 1
34057: NEG
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: LD_INT 2
34065: NEG
34066: PUSH
34067: LD_INT 2
34069: NEG
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: LIST
34079: LIST
34080: LIST
34081: LIST
34082: LIST
34083: LIST
34084: LIST
34085: LIST
34086: LIST
34087: LIST
34088: LIST
34089: LIST
34090: LIST
34091: LIST
34092: LIST
34093: LIST
34094: LIST
34095: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34096: LD_ADDR_VAR 0 21
34100: PUSH
34101: LD_INT 0
34103: PUSH
34104: LD_INT 0
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: LD_INT 0
34113: PUSH
34114: LD_INT 1
34116: NEG
34117: PUSH
34118: EMPTY
34119: LIST
34120: LIST
34121: PUSH
34122: LD_INT 1
34124: PUSH
34125: LD_INT 0
34127: PUSH
34128: EMPTY
34129: LIST
34130: LIST
34131: PUSH
34132: LD_INT 1
34134: PUSH
34135: LD_INT 1
34137: PUSH
34138: EMPTY
34139: LIST
34140: LIST
34141: PUSH
34142: LD_INT 0
34144: PUSH
34145: LD_INT 1
34147: PUSH
34148: EMPTY
34149: LIST
34150: LIST
34151: PUSH
34152: LD_INT 1
34154: NEG
34155: PUSH
34156: LD_INT 0
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 1
34165: NEG
34166: PUSH
34167: LD_INT 1
34169: NEG
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: LD_INT 1
34177: NEG
34178: PUSH
34179: LD_INT 2
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 0
34189: PUSH
34190: LD_INT 2
34192: NEG
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: LD_INT 1
34203: NEG
34204: PUSH
34205: EMPTY
34206: LIST
34207: LIST
34208: PUSH
34209: LD_INT 2
34211: PUSH
34212: LD_INT 0
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 2
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: LD_INT 2
34231: PUSH
34232: LD_INT 2
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 1
34241: PUSH
34242: LD_INT 2
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 0
34251: PUSH
34252: LD_INT 2
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 1
34261: NEG
34262: PUSH
34263: LD_INT 1
34265: PUSH
34266: EMPTY
34267: LIST
34268: LIST
34269: PUSH
34270: LD_INT 2
34272: NEG
34273: PUSH
34274: LD_INT 0
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 2
34283: NEG
34284: PUSH
34285: LD_INT 1
34287: NEG
34288: PUSH
34289: EMPTY
34290: LIST
34291: LIST
34292: PUSH
34293: LD_INT 2
34295: NEG
34296: PUSH
34297: LD_INT 2
34299: NEG
34300: PUSH
34301: EMPTY
34302: LIST
34303: LIST
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: LIST
34309: LIST
34310: LIST
34311: LIST
34312: LIST
34313: LIST
34314: LIST
34315: LIST
34316: LIST
34317: LIST
34318: LIST
34319: LIST
34320: LIST
34321: LIST
34322: LIST
34323: LIST
34324: LIST
34325: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
34326: LD_ADDR_VAR 0 22
34330: PUSH
34331: LD_INT 0
34333: PUSH
34334: LD_INT 0
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: LD_INT 0
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 0
34357: PUSH
34358: EMPTY
34359: LIST
34360: LIST
34361: PUSH
34362: LD_INT 1
34364: PUSH
34365: LD_INT 1
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: PUSH
34372: LD_INT 0
34374: PUSH
34375: LD_INT 1
34377: PUSH
34378: EMPTY
34379: LIST
34380: LIST
34381: PUSH
34382: LD_INT 1
34384: NEG
34385: PUSH
34386: LD_INT 0
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: PUSH
34393: LD_INT 1
34395: NEG
34396: PUSH
34397: LD_INT 1
34399: NEG
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 1
34407: NEG
34408: PUSH
34409: LD_INT 2
34411: NEG
34412: PUSH
34413: EMPTY
34414: LIST
34415: LIST
34416: PUSH
34417: LD_INT 0
34419: PUSH
34420: LD_INT 2
34422: NEG
34423: PUSH
34424: EMPTY
34425: LIST
34426: LIST
34427: PUSH
34428: LD_INT 1
34430: PUSH
34431: LD_INT 1
34433: NEG
34434: PUSH
34435: EMPTY
34436: LIST
34437: LIST
34438: PUSH
34439: LD_INT 2
34441: PUSH
34442: LD_INT 0
34444: PUSH
34445: EMPTY
34446: LIST
34447: LIST
34448: PUSH
34449: LD_INT 2
34451: PUSH
34452: LD_INT 1
34454: PUSH
34455: EMPTY
34456: LIST
34457: LIST
34458: PUSH
34459: LD_INT 2
34461: PUSH
34462: LD_INT 2
34464: PUSH
34465: EMPTY
34466: LIST
34467: LIST
34468: PUSH
34469: LD_INT 1
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: EMPTY
34476: LIST
34477: LIST
34478: PUSH
34479: LD_INT 0
34481: PUSH
34482: LD_INT 2
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 1
34495: PUSH
34496: EMPTY
34497: LIST
34498: LIST
34499: PUSH
34500: LD_INT 2
34502: NEG
34503: PUSH
34504: LD_INT 0
34506: PUSH
34507: EMPTY
34508: LIST
34509: LIST
34510: PUSH
34511: LD_INT 2
34513: NEG
34514: PUSH
34515: LD_INT 1
34517: NEG
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 2
34525: NEG
34526: PUSH
34527: LD_INT 2
34529: NEG
34530: PUSH
34531: EMPTY
34532: LIST
34533: LIST
34534: PUSH
34535: EMPTY
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: LIST
34554: LIST
34555: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
34556: LD_ADDR_VAR 0 23
34560: PUSH
34561: LD_INT 0
34563: PUSH
34564: LD_INT 0
34566: PUSH
34567: EMPTY
34568: LIST
34569: LIST
34570: PUSH
34571: LD_INT 0
34573: PUSH
34574: LD_INT 1
34576: NEG
34577: PUSH
34578: EMPTY
34579: LIST
34580: LIST
34581: PUSH
34582: LD_INT 1
34584: PUSH
34585: LD_INT 0
34587: PUSH
34588: EMPTY
34589: LIST
34590: LIST
34591: PUSH
34592: LD_INT 1
34594: PUSH
34595: LD_INT 1
34597: PUSH
34598: EMPTY
34599: LIST
34600: LIST
34601: PUSH
34602: LD_INT 0
34604: PUSH
34605: LD_INT 1
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: LD_INT 1
34614: NEG
34615: PUSH
34616: LD_INT 0
34618: PUSH
34619: EMPTY
34620: LIST
34621: LIST
34622: PUSH
34623: LD_INT 1
34625: NEG
34626: PUSH
34627: LD_INT 1
34629: NEG
34630: PUSH
34631: EMPTY
34632: LIST
34633: LIST
34634: PUSH
34635: LD_INT 1
34637: NEG
34638: PUSH
34639: LD_INT 2
34641: NEG
34642: PUSH
34643: EMPTY
34644: LIST
34645: LIST
34646: PUSH
34647: LD_INT 0
34649: PUSH
34650: LD_INT 2
34652: NEG
34653: PUSH
34654: EMPTY
34655: LIST
34656: LIST
34657: PUSH
34658: LD_INT 1
34660: PUSH
34661: LD_INT 1
34663: NEG
34664: PUSH
34665: EMPTY
34666: LIST
34667: LIST
34668: PUSH
34669: LD_INT 2
34671: PUSH
34672: LD_INT 0
34674: PUSH
34675: EMPTY
34676: LIST
34677: LIST
34678: PUSH
34679: LD_INT 2
34681: PUSH
34682: LD_INT 1
34684: PUSH
34685: EMPTY
34686: LIST
34687: LIST
34688: PUSH
34689: LD_INT 2
34691: PUSH
34692: LD_INT 2
34694: PUSH
34695: EMPTY
34696: LIST
34697: LIST
34698: PUSH
34699: LD_INT 1
34701: PUSH
34702: LD_INT 2
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 0
34711: PUSH
34712: LD_INT 2
34714: PUSH
34715: EMPTY
34716: LIST
34717: LIST
34718: PUSH
34719: LD_INT 1
34721: NEG
34722: PUSH
34723: LD_INT 1
34725: PUSH
34726: EMPTY
34727: LIST
34728: LIST
34729: PUSH
34730: LD_INT 2
34732: NEG
34733: PUSH
34734: LD_INT 0
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 2
34743: NEG
34744: PUSH
34745: LD_INT 1
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 2
34755: NEG
34756: PUSH
34757: LD_INT 2
34759: NEG
34760: PUSH
34761: EMPTY
34762: LIST
34763: LIST
34764: PUSH
34765: LD_INT 2
34767: NEG
34768: PUSH
34769: LD_INT 3
34771: NEG
34772: PUSH
34773: EMPTY
34774: LIST
34775: LIST
34776: PUSH
34777: LD_INT 1
34779: NEG
34780: PUSH
34781: LD_INT 3
34783: NEG
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 1
34791: PUSH
34792: LD_INT 2
34794: NEG
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 2
34802: PUSH
34803: LD_INT 1
34805: NEG
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: LIST
34832: LIST
34833: LIST
34834: LIST
34835: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
34836: LD_ADDR_VAR 0 24
34840: PUSH
34841: LD_INT 0
34843: PUSH
34844: LD_INT 0
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: LD_INT 1
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 0
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PUSH
34872: LD_INT 1
34874: PUSH
34875: LD_INT 1
34877: PUSH
34878: EMPTY
34879: LIST
34880: LIST
34881: PUSH
34882: LD_INT 0
34884: PUSH
34885: LD_INT 1
34887: PUSH
34888: EMPTY
34889: LIST
34890: LIST
34891: PUSH
34892: LD_INT 1
34894: NEG
34895: PUSH
34896: LD_INT 0
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: LD_INT 1
34909: NEG
34910: PUSH
34911: EMPTY
34912: LIST
34913: LIST
34914: PUSH
34915: LD_INT 1
34917: NEG
34918: PUSH
34919: LD_INT 2
34921: NEG
34922: PUSH
34923: EMPTY
34924: LIST
34925: LIST
34926: PUSH
34927: LD_INT 0
34929: PUSH
34930: LD_INT 2
34932: NEG
34933: PUSH
34934: EMPTY
34935: LIST
34936: LIST
34937: PUSH
34938: LD_INT 1
34940: PUSH
34941: LD_INT 1
34943: NEG
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: PUSH
34949: LD_INT 2
34951: PUSH
34952: LD_INT 0
34954: PUSH
34955: EMPTY
34956: LIST
34957: LIST
34958: PUSH
34959: LD_INT 2
34961: PUSH
34962: LD_INT 1
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 2
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 1
34981: PUSH
34982: LD_INT 2
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 0
34991: PUSH
34992: LD_INT 2
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: LD_INT 1
35005: PUSH
35006: EMPTY
35007: LIST
35008: LIST
35009: PUSH
35010: LD_INT 2
35012: NEG
35013: PUSH
35014: LD_INT 0
35016: PUSH
35017: EMPTY
35018: LIST
35019: LIST
35020: PUSH
35021: LD_INT 2
35023: NEG
35024: PUSH
35025: LD_INT 1
35027: NEG
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 2
35035: NEG
35036: PUSH
35037: LD_INT 2
35039: NEG
35040: PUSH
35041: EMPTY
35042: LIST
35043: LIST
35044: PUSH
35045: LD_INT 1
35047: PUSH
35048: LD_INT 2
35050: NEG
35051: PUSH
35052: EMPTY
35053: LIST
35054: LIST
35055: PUSH
35056: LD_INT 2
35058: PUSH
35059: LD_INT 1
35061: NEG
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 3
35069: PUSH
35070: LD_INT 1
35072: PUSH
35073: EMPTY
35074: LIST
35075: LIST
35076: PUSH
35077: LD_INT 3
35079: PUSH
35080: LD_INT 2
35082: PUSH
35083: EMPTY
35084: LIST
35085: LIST
35086: PUSH
35087: EMPTY
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: LIST
35110: LIST
35111: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
35112: LD_ADDR_VAR 0 25
35116: PUSH
35117: LD_INT 0
35119: PUSH
35120: LD_INT 0
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: LD_INT 1
35132: NEG
35133: PUSH
35134: EMPTY
35135: LIST
35136: LIST
35137: PUSH
35138: LD_INT 1
35140: PUSH
35141: LD_INT 0
35143: PUSH
35144: EMPTY
35145: LIST
35146: LIST
35147: PUSH
35148: LD_INT 1
35150: PUSH
35151: LD_INT 1
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 0
35160: PUSH
35161: LD_INT 1
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: LD_INT 1
35170: NEG
35171: PUSH
35172: LD_INT 0
35174: PUSH
35175: EMPTY
35176: LIST
35177: LIST
35178: PUSH
35179: LD_INT 1
35181: NEG
35182: PUSH
35183: LD_INT 1
35185: NEG
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: NEG
35194: PUSH
35195: LD_INT 2
35197: NEG
35198: PUSH
35199: EMPTY
35200: LIST
35201: LIST
35202: PUSH
35203: LD_INT 0
35205: PUSH
35206: LD_INT 2
35208: NEG
35209: PUSH
35210: EMPTY
35211: LIST
35212: LIST
35213: PUSH
35214: LD_INT 1
35216: PUSH
35217: LD_INT 1
35219: NEG
35220: PUSH
35221: EMPTY
35222: LIST
35223: LIST
35224: PUSH
35225: LD_INT 2
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: EMPTY
35232: LIST
35233: LIST
35234: PUSH
35235: LD_INT 2
35237: PUSH
35238: LD_INT 1
35240: PUSH
35241: EMPTY
35242: LIST
35243: LIST
35244: PUSH
35245: LD_INT 2
35247: PUSH
35248: LD_INT 2
35250: PUSH
35251: EMPTY
35252: LIST
35253: LIST
35254: PUSH
35255: LD_INT 1
35257: PUSH
35258: LD_INT 2
35260: PUSH
35261: EMPTY
35262: LIST
35263: LIST
35264: PUSH
35265: LD_INT 0
35267: PUSH
35268: LD_INT 2
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 1
35277: NEG
35278: PUSH
35279: LD_INT 1
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 2
35288: NEG
35289: PUSH
35290: LD_INT 0
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 2
35299: NEG
35300: PUSH
35301: LD_INT 1
35303: NEG
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 2
35311: NEG
35312: PUSH
35313: LD_INT 2
35315: NEG
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 3
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 3
35333: PUSH
35334: LD_INT 2
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 2
35343: PUSH
35344: LD_INT 3
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: LD_INT 3
35356: PUSH
35357: EMPTY
35358: LIST
35359: LIST
35360: PUSH
35361: EMPTY
35362: LIST
35363: LIST
35364: LIST
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
35386: LD_ADDR_VAR 0 26
35390: PUSH
35391: LD_INT 0
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: EMPTY
35398: LIST
35399: LIST
35400: PUSH
35401: LD_INT 0
35403: PUSH
35404: LD_INT 1
35406: NEG
35407: PUSH
35408: EMPTY
35409: LIST
35410: LIST
35411: PUSH
35412: LD_INT 1
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: EMPTY
35419: LIST
35420: LIST
35421: PUSH
35422: LD_INT 1
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: EMPTY
35429: LIST
35430: LIST
35431: PUSH
35432: LD_INT 0
35434: PUSH
35435: LD_INT 1
35437: PUSH
35438: EMPTY
35439: LIST
35440: LIST
35441: PUSH
35442: LD_INT 1
35444: NEG
35445: PUSH
35446: LD_INT 0
35448: PUSH
35449: EMPTY
35450: LIST
35451: LIST
35452: PUSH
35453: LD_INT 1
35455: NEG
35456: PUSH
35457: LD_INT 1
35459: NEG
35460: PUSH
35461: EMPTY
35462: LIST
35463: LIST
35464: PUSH
35465: LD_INT 1
35467: NEG
35468: PUSH
35469: LD_INT 2
35471: NEG
35472: PUSH
35473: EMPTY
35474: LIST
35475: LIST
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: LD_INT 2
35482: NEG
35483: PUSH
35484: EMPTY
35485: LIST
35486: LIST
35487: PUSH
35488: LD_INT 1
35490: PUSH
35491: LD_INT 1
35493: NEG
35494: PUSH
35495: EMPTY
35496: LIST
35497: LIST
35498: PUSH
35499: LD_INT 2
35501: PUSH
35502: LD_INT 0
35504: PUSH
35505: EMPTY
35506: LIST
35507: LIST
35508: PUSH
35509: LD_INT 2
35511: PUSH
35512: LD_INT 1
35514: PUSH
35515: EMPTY
35516: LIST
35517: LIST
35518: PUSH
35519: LD_INT 2
35521: PUSH
35522: LD_INT 2
35524: PUSH
35525: EMPTY
35526: LIST
35527: LIST
35528: PUSH
35529: LD_INT 1
35531: PUSH
35532: LD_INT 2
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 0
35541: PUSH
35542: LD_INT 2
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: NEG
35552: PUSH
35553: LD_INT 1
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: NEG
35563: PUSH
35564: LD_INT 0
35566: PUSH
35567: EMPTY
35568: LIST
35569: LIST
35570: PUSH
35571: LD_INT 2
35573: NEG
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: EMPTY
35580: LIST
35581: LIST
35582: PUSH
35583: LD_INT 2
35585: NEG
35586: PUSH
35587: LD_INT 2
35589: NEG
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 2
35597: PUSH
35598: LD_INT 3
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 1
35607: PUSH
35608: LD_INT 3
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: LD_INT 2
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 2
35628: NEG
35629: PUSH
35630: LD_INT 1
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: EMPTY
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35662: LD_ADDR_VAR 0 27
35666: PUSH
35667: LD_INT 0
35669: PUSH
35670: LD_INT 0
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: LD_INT 0
35679: PUSH
35680: LD_INT 1
35682: NEG
35683: PUSH
35684: EMPTY
35685: LIST
35686: LIST
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: LD_INT 0
35693: PUSH
35694: EMPTY
35695: LIST
35696: LIST
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: LD_INT 1
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 0
35710: PUSH
35711: LD_INT 1
35713: PUSH
35714: EMPTY
35715: LIST
35716: LIST
35717: PUSH
35718: LD_INT 1
35720: NEG
35721: PUSH
35722: LD_INT 0
35724: PUSH
35725: EMPTY
35726: LIST
35727: LIST
35728: PUSH
35729: LD_INT 1
35731: NEG
35732: PUSH
35733: LD_INT 1
35735: NEG
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 1
35743: NEG
35744: PUSH
35745: LD_INT 2
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 0
35755: PUSH
35756: LD_INT 2
35758: NEG
35759: PUSH
35760: EMPTY
35761: LIST
35762: LIST
35763: PUSH
35764: LD_INT 1
35766: PUSH
35767: LD_INT 1
35769: NEG
35770: PUSH
35771: EMPTY
35772: LIST
35773: LIST
35774: PUSH
35775: LD_INT 2
35777: PUSH
35778: LD_INT 0
35780: PUSH
35781: EMPTY
35782: LIST
35783: LIST
35784: PUSH
35785: LD_INT 2
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: EMPTY
35792: LIST
35793: LIST
35794: PUSH
35795: LD_INT 2
35797: PUSH
35798: LD_INT 2
35800: PUSH
35801: EMPTY
35802: LIST
35803: LIST
35804: PUSH
35805: LD_INT 1
35807: PUSH
35808: LD_INT 2
35810: PUSH
35811: EMPTY
35812: LIST
35813: LIST
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: LD_INT 2
35820: PUSH
35821: EMPTY
35822: LIST
35823: LIST
35824: PUSH
35825: LD_INT 1
35827: NEG
35828: PUSH
35829: LD_INT 1
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: PUSH
35836: LD_INT 2
35838: NEG
35839: PUSH
35840: LD_INT 0
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: LD_INT 2
35849: NEG
35850: PUSH
35851: LD_INT 1
35853: NEG
35854: PUSH
35855: EMPTY
35856: LIST
35857: LIST
35858: PUSH
35859: LD_INT 2
35861: NEG
35862: PUSH
35863: LD_INT 2
35865: NEG
35866: PUSH
35867: EMPTY
35868: LIST
35869: LIST
35870: PUSH
35871: LD_INT 1
35873: NEG
35874: PUSH
35875: LD_INT 2
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: LD_INT 2
35884: NEG
35885: PUSH
35886: LD_INT 1
35888: PUSH
35889: EMPTY
35890: LIST
35891: LIST
35892: PUSH
35893: LD_INT 3
35895: NEG
35896: PUSH
35897: LD_INT 1
35899: NEG
35900: PUSH
35901: EMPTY
35902: LIST
35903: LIST
35904: PUSH
35905: LD_INT 3
35907: NEG
35908: PUSH
35909: LD_INT 2
35911: NEG
35912: PUSH
35913: EMPTY
35914: LIST
35915: LIST
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: LIST
35921: LIST
35922: LIST
35923: LIST
35924: LIST
35925: LIST
35926: LIST
35927: LIST
35928: LIST
35929: LIST
35930: LIST
35931: LIST
35932: LIST
35933: LIST
35934: LIST
35935: LIST
35936: LIST
35937: LIST
35938: LIST
35939: LIST
35940: LIST
35941: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
35942: LD_ADDR_VAR 0 28
35946: PUSH
35947: LD_INT 0
35949: PUSH
35950: LD_INT 0
35952: PUSH
35953: EMPTY
35954: LIST
35955: LIST
35956: PUSH
35957: LD_INT 0
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: EMPTY
35965: LIST
35966: LIST
35967: PUSH
35968: LD_INT 1
35970: PUSH
35971: LD_INT 0
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: PUSH
35978: LD_INT 1
35980: PUSH
35981: LD_INT 1
35983: PUSH
35984: EMPTY
35985: LIST
35986: LIST
35987: PUSH
35988: LD_INT 0
35990: PUSH
35991: LD_INT 1
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: PUSH
35998: LD_INT 1
36000: NEG
36001: PUSH
36002: LD_INT 0
36004: PUSH
36005: EMPTY
36006: LIST
36007: LIST
36008: PUSH
36009: LD_INT 1
36011: NEG
36012: PUSH
36013: LD_INT 1
36015: NEG
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: NEG
36024: PUSH
36025: LD_INT 2
36027: NEG
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 0
36035: PUSH
36036: LD_INT 2
36038: NEG
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 2
36057: PUSH
36058: LD_INT 0
36060: PUSH
36061: EMPTY
36062: LIST
36063: LIST
36064: PUSH
36065: LD_INT 2
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: EMPTY
36072: LIST
36073: LIST
36074: PUSH
36075: LD_INT 2
36077: PUSH
36078: LD_INT 2
36080: PUSH
36081: EMPTY
36082: LIST
36083: LIST
36084: PUSH
36085: LD_INT 1
36087: PUSH
36088: LD_INT 2
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PUSH
36095: LD_INT 0
36097: PUSH
36098: LD_INT 2
36100: PUSH
36101: EMPTY
36102: LIST
36103: LIST
36104: PUSH
36105: LD_INT 1
36107: NEG
36108: PUSH
36109: LD_INT 1
36111: PUSH
36112: EMPTY
36113: LIST
36114: LIST
36115: PUSH
36116: LD_INT 2
36118: NEG
36119: PUSH
36120: LD_INT 0
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: LD_INT 2
36129: NEG
36130: PUSH
36131: LD_INT 1
36133: NEG
36134: PUSH
36135: EMPTY
36136: LIST
36137: LIST
36138: PUSH
36139: LD_INT 2
36141: NEG
36142: PUSH
36143: LD_INT 2
36145: NEG
36146: PUSH
36147: EMPTY
36148: LIST
36149: LIST
36150: PUSH
36151: LD_INT 2
36153: NEG
36154: PUSH
36155: LD_INT 3
36157: NEG
36158: PUSH
36159: EMPTY
36160: LIST
36161: LIST
36162: PUSH
36163: LD_INT 1
36165: NEG
36166: PUSH
36167: LD_INT 3
36169: NEG
36170: PUSH
36171: EMPTY
36172: LIST
36173: LIST
36174: PUSH
36175: LD_INT 3
36177: NEG
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 3
36189: NEG
36190: PUSH
36191: LD_INT 2
36193: NEG
36194: PUSH
36195: EMPTY
36196: LIST
36197: LIST
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: LIST
36208: LIST
36209: LIST
36210: LIST
36211: LIST
36212: LIST
36213: LIST
36214: LIST
36215: LIST
36216: LIST
36217: LIST
36218: LIST
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36224: LD_ADDR_VAR 0 29
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: LD_INT 0
36234: PUSH
36235: EMPTY
36236: LIST
36237: LIST
36238: PUSH
36239: LD_INT 0
36241: PUSH
36242: LD_INT 1
36244: NEG
36245: PUSH
36246: EMPTY
36247: LIST
36248: LIST
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: LD_INT 0
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: LD_INT 1
36265: PUSH
36266: EMPTY
36267: LIST
36268: LIST
36269: PUSH
36270: LD_INT 0
36272: PUSH
36273: LD_INT 1
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 1
36282: NEG
36283: PUSH
36284: LD_INT 0
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 1
36293: NEG
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 1
36305: NEG
36306: PUSH
36307: LD_INT 2
36309: NEG
36310: PUSH
36311: EMPTY
36312: LIST
36313: LIST
36314: PUSH
36315: LD_INT 0
36317: PUSH
36318: LD_INT 2
36320: NEG
36321: PUSH
36322: EMPTY
36323: LIST
36324: LIST
36325: PUSH
36326: LD_INT 1
36328: PUSH
36329: LD_INT 1
36331: NEG
36332: PUSH
36333: EMPTY
36334: LIST
36335: LIST
36336: PUSH
36337: LD_INT 2
36339: PUSH
36340: LD_INT 0
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 2
36349: PUSH
36350: LD_INT 1
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 1
36359: PUSH
36360: LD_INT 2
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 0
36369: PUSH
36370: LD_INT 2
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: NEG
36380: PUSH
36381: LD_INT 1
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 2
36390: NEG
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 2
36402: NEG
36403: PUSH
36404: LD_INT 2
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 2
36414: NEG
36415: PUSH
36416: LD_INT 3
36418: NEG
36419: PUSH
36420: EMPTY
36421: LIST
36422: LIST
36423: PUSH
36424: LD_INT 2
36426: PUSH
36427: LD_INT 1
36429: NEG
36430: PUSH
36431: EMPTY
36432: LIST
36433: LIST
36434: PUSH
36435: LD_INT 3
36437: PUSH
36438: LD_INT 1
36440: PUSH
36441: EMPTY
36442: LIST
36443: LIST
36444: PUSH
36445: LD_INT 1
36447: PUSH
36448: LD_INT 3
36450: PUSH
36451: EMPTY
36452: LIST
36453: LIST
36454: PUSH
36455: LD_INT 1
36457: NEG
36458: PUSH
36459: LD_INT 2
36461: PUSH
36462: EMPTY
36463: LIST
36464: LIST
36465: PUSH
36466: LD_INT 3
36468: NEG
36469: PUSH
36470: LD_INT 2
36472: NEG
36473: PUSH
36474: EMPTY
36475: LIST
36476: LIST
36477: PUSH
36478: EMPTY
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
36503: LD_ADDR_VAR 0 30
36507: PUSH
36508: LD_INT 0
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: EMPTY
36515: LIST
36516: LIST
36517: PUSH
36518: LD_INT 0
36520: PUSH
36521: LD_INT 1
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 1
36531: PUSH
36532: LD_INT 0
36534: PUSH
36535: EMPTY
36536: LIST
36537: LIST
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: EMPTY
36546: LIST
36547: LIST
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: LD_INT 1
36554: PUSH
36555: EMPTY
36556: LIST
36557: LIST
36558: PUSH
36559: LD_INT 1
36561: NEG
36562: PUSH
36563: LD_INT 0
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PUSH
36570: LD_INT 1
36572: NEG
36573: PUSH
36574: LD_INT 1
36576: NEG
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 1
36584: NEG
36585: PUSH
36586: LD_INT 2
36588: NEG
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 0
36596: PUSH
36597: LD_INT 2
36599: NEG
36600: PUSH
36601: EMPTY
36602: LIST
36603: LIST
36604: PUSH
36605: LD_INT 1
36607: PUSH
36608: LD_INT 1
36610: NEG
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 2
36618: PUSH
36619: LD_INT 0
36621: PUSH
36622: EMPTY
36623: LIST
36624: LIST
36625: PUSH
36626: LD_INT 2
36628: PUSH
36629: LD_INT 1
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 2
36638: PUSH
36639: LD_INT 2
36641: PUSH
36642: EMPTY
36643: LIST
36644: LIST
36645: PUSH
36646: LD_INT 1
36648: PUSH
36649: LD_INT 2
36651: PUSH
36652: EMPTY
36653: LIST
36654: LIST
36655: PUSH
36656: LD_INT 1
36658: NEG
36659: PUSH
36660: LD_INT 1
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: LD_INT 2
36669: NEG
36670: PUSH
36671: LD_INT 0
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 2
36680: NEG
36681: PUSH
36682: LD_INT 1
36684: NEG
36685: PUSH
36686: EMPTY
36687: LIST
36688: LIST
36689: PUSH
36690: LD_INT 1
36692: NEG
36693: PUSH
36694: LD_INT 3
36696: NEG
36697: PUSH
36698: EMPTY
36699: LIST
36700: LIST
36701: PUSH
36702: LD_INT 1
36704: PUSH
36705: LD_INT 2
36707: NEG
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 3
36715: PUSH
36716: LD_INT 2
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 2
36725: PUSH
36726: LD_INT 3
36728: PUSH
36729: EMPTY
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 2
36735: NEG
36736: PUSH
36737: LD_INT 1
36739: PUSH
36740: EMPTY
36741: LIST
36742: LIST
36743: PUSH
36744: LD_INT 3
36746: NEG
36747: PUSH
36748: LD_INT 1
36750: NEG
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: EMPTY
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: LIST
36762: LIST
36763: LIST
36764: LIST
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: LIST
36780: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
36781: LD_ADDR_VAR 0 31
36785: PUSH
36786: LD_INT 0
36788: PUSH
36789: LD_INT 0
36791: PUSH
36792: EMPTY
36793: LIST
36794: LIST
36795: PUSH
36796: LD_INT 0
36798: PUSH
36799: LD_INT 1
36801: NEG
36802: PUSH
36803: EMPTY
36804: LIST
36805: LIST
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: LD_INT 0
36812: PUSH
36813: EMPTY
36814: LIST
36815: LIST
36816: PUSH
36817: LD_INT 1
36819: PUSH
36820: LD_INT 1
36822: PUSH
36823: EMPTY
36824: LIST
36825: LIST
36826: PUSH
36827: LD_INT 0
36829: PUSH
36830: LD_INT 1
36832: PUSH
36833: EMPTY
36834: LIST
36835: LIST
36836: PUSH
36837: LD_INT 1
36839: NEG
36840: PUSH
36841: LD_INT 0
36843: PUSH
36844: EMPTY
36845: LIST
36846: LIST
36847: PUSH
36848: LD_INT 1
36850: NEG
36851: PUSH
36852: LD_INT 1
36854: NEG
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: LD_INT 2
36866: NEG
36867: PUSH
36868: EMPTY
36869: LIST
36870: LIST
36871: PUSH
36872: LD_INT 1
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 2
36885: PUSH
36886: LD_INT 0
36888: PUSH
36889: EMPTY
36890: LIST
36891: LIST
36892: PUSH
36893: LD_INT 2
36895: PUSH
36896: LD_INT 1
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 2
36905: PUSH
36906: LD_INT 2
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: PUSH
36913: LD_INT 1
36915: PUSH
36916: LD_INT 2
36918: PUSH
36919: EMPTY
36920: LIST
36921: LIST
36922: PUSH
36923: LD_INT 0
36925: PUSH
36926: LD_INT 2
36928: PUSH
36929: EMPTY
36930: LIST
36931: LIST
36932: PUSH
36933: LD_INT 1
36935: NEG
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: EMPTY
36941: LIST
36942: LIST
36943: PUSH
36944: LD_INT 2
36946: NEG
36947: PUSH
36948: LD_INT 1
36950: NEG
36951: PUSH
36952: EMPTY
36953: LIST
36954: LIST
36955: PUSH
36956: LD_INT 2
36958: NEG
36959: PUSH
36960: LD_INT 2
36962: NEG
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 2
36970: NEG
36971: PUSH
36972: LD_INT 3
36974: NEG
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 2
36982: PUSH
36983: LD_INT 1
36985: NEG
36986: PUSH
36987: EMPTY
36988: LIST
36989: LIST
36990: PUSH
36991: LD_INT 3
36993: PUSH
36994: LD_INT 1
36996: PUSH
36997: EMPTY
36998: LIST
36999: LIST
37000: PUSH
37001: LD_INT 1
37003: PUSH
37004: LD_INT 3
37006: PUSH
37007: EMPTY
37008: LIST
37009: LIST
37010: PUSH
37011: LD_INT 1
37013: NEG
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 3
37024: NEG
37025: PUSH
37026: LD_INT 2
37028: NEG
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: LIST
37041: LIST
37042: LIST
37043: LIST
37044: LIST
37045: LIST
37046: LIST
37047: LIST
37048: LIST
37049: LIST
37050: LIST
37051: LIST
37052: LIST
37053: LIST
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37059: LD_ADDR_VAR 0 32
37063: PUSH
37064: LD_INT 0
37066: PUSH
37067: LD_INT 0
37069: PUSH
37070: EMPTY
37071: LIST
37072: LIST
37073: PUSH
37074: LD_INT 0
37076: PUSH
37077: LD_INT 1
37079: NEG
37080: PUSH
37081: EMPTY
37082: LIST
37083: LIST
37084: PUSH
37085: LD_INT 1
37087: PUSH
37088: LD_INT 0
37090: PUSH
37091: EMPTY
37092: LIST
37093: LIST
37094: PUSH
37095: LD_INT 1
37097: PUSH
37098: LD_INT 1
37100: PUSH
37101: EMPTY
37102: LIST
37103: LIST
37104: PUSH
37105: LD_INT 0
37107: PUSH
37108: LD_INT 1
37110: PUSH
37111: EMPTY
37112: LIST
37113: LIST
37114: PUSH
37115: LD_INT 1
37117: NEG
37118: PUSH
37119: LD_INT 0
37121: PUSH
37122: EMPTY
37123: LIST
37124: LIST
37125: PUSH
37126: LD_INT 1
37128: NEG
37129: PUSH
37130: LD_INT 1
37132: NEG
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: LD_INT 2
37144: NEG
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 0
37152: PUSH
37153: LD_INT 2
37155: NEG
37156: PUSH
37157: EMPTY
37158: LIST
37159: LIST
37160: PUSH
37161: LD_INT 1
37163: PUSH
37164: LD_INT 1
37166: NEG
37167: PUSH
37168: EMPTY
37169: LIST
37170: LIST
37171: PUSH
37172: LD_INT 2
37174: PUSH
37175: LD_INT 1
37177: PUSH
37178: EMPTY
37179: LIST
37180: LIST
37181: PUSH
37182: LD_INT 2
37184: PUSH
37185: LD_INT 2
37187: PUSH
37188: EMPTY
37189: LIST
37190: LIST
37191: PUSH
37192: LD_INT 1
37194: PUSH
37195: LD_INT 2
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 0
37204: PUSH
37205: LD_INT 2
37207: PUSH
37208: EMPTY
37209: LIST
37210: LIST
37211: PUSH
37212: LD_INT 1
37214: NEG
37215: PUSH
37216: LD_INT 1
37218: PUSH
37219: EMPTY
37220: LIST
37221: LIST
37222: PUSH
37223: LD_INT 2
37225: NEG
37226: PUSH
37227: LD_INT 0
37229: PUSH
37230: EMPTY
37231: LIST
37232: LIST
37233: PUSH
37234: LD_INT 2
37236: NEG
37237: PUSH
37238: LD_INT 1
37240: NEG
37241: PUSH
37242: EMPTY
37243: LIST
37244: LIST
37245: PUSH
37246: LD_INT 1
37248: NEG
37249: PUSH
37250: LD_INT 3
37252: NEG
37253: PUSH
37254: EMPTY
37255: LIST
37256: LIST
37257: PUSH
37258: LD_INT 1
37260: PUSH
37261: LD_INT 2
37263: NEG
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 3
37271: PUSH
37272: LD_INT 2
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: LD_INT 2
37281: PUSH
37282: LD_INT 3
37284: PUSH
37285: EMPTY
37286: LIST
37287: LIST
37288: PUSH
37289: LD_INT 2
37291: NEG
37292: PUSH
37293: LD_INT 1
37295: PUSH
37296: EMPTY
37297: LIST
37298: LIST
37299: PUSH
37300: LD_INT 3
37302: NEG
37303: PUSH
37304: LD_INT 1
37306: NEG
37307: PUSH
37308: EMPTY
37309: LIST
37310: LIST
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: LIST
37316: LIST
37317: LIST
37318: LIST
37319: LIST
37320: LIST
37321: LIST
37322: LIST
37323: LIST
37324: LIST
37325: LIST
37326: LIST
37327: LIST
37328: LIST
37329: LIST
37330: LIST
37331: LIST
37332: LIST
37333: LIST
37334: LIST
37335: LIST
37336: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
37337: LD_ADDR_VAR 0 33
37341: PUSH
37342: LD_INT 0
37344: PUSH
37345: LD_INT 0
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 0
37354: PUSH
37355: LD_INT 1
37357: NEG
37358: PUSH
37359: EMPTY
37360: LIST
37361: LIST
37362: PUSH
37363: LD_INT 1
37365: PUSH
37366: LD_INT 0
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PUSH
37373: LD_INT 1
37375: PUSH
37376: LD_INT 1
37378: PUSH
37379: EMPTY
37380: LIST
37381: LIST
37382: PUSH
37383: LD_INT 0
37385: PUSH
37386: LD_INT 1
37388: PUSH
37389: EMPTY
37390: LIST
37391: LIST
37392: PUSH
37393: LD_INT 1
37395: NEG
37396: PUSH
37397: LD_INT 0
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 1
37406: NEG
37407: PUSH
37408: LD_INT 1
37410: NEG
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 1
37418: NEG
37419: PUSH
37420: LD_INT 2
37422: NEG
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: PUSH
37428: LD_INT 1
37430: PUSH
37431: LD_INT 1
37433: NEG
37434: PUSH
37435: EMPTY
37436: LIST
37437: LIST
37438: PUSH
37439: LD_INT 2
37441: PUSH
37442: LD_INT 0
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 2
37451: PUSH
37452: LD_INT 1
37454: PUSH
37455: EMPTY
37456: LIST
37457: LIST
37458: PUSH
37459: LD_INT 1
37461: PUSH
37462: LD_INT 2
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 0
37471: PUSH
37472: LD_INT 2
37474: PUSH
37475: EMPTY
37476: LIST
37477: LIST
37478: PUSH
37479: LD_INT 1
37481: NEG
37482: PUSH
37483: LD_INT 1
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 2
37492: NEG
37493: PUSH
37494: LD_INT 0
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 2
37503: NEG
37504: PUSH
37505: LD_INT 1
37507: NEG
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 2
37515: NEG
37516: PUSH
37517: LD_INT 2
37519: NEG
37520: PUSH
37521: EMPTY
37522: LIST
37523: LIST
37524: PUSH
37525: LD_INT 2
37527: NEG
37528: PUSH
37529: LD_INT 3
37531: NEG
37532: PUSH
37533: EMPTY
37534: LIST
37535: LIST
37536: PUSH
37537: LD_INT 2
37539: PUSH
37540: LD_INT 1
37542: NEG
37543: PUSH
37544: EMPTY
37545: LIST
37546: LIST
37547: PUSH
37548: LD_INT 3
37550: PUSH
37551: LD_INT 1
37553: PUSH
37554: EMPTY
37555: LIST
37556: LIST
37557: PUSH
37558: LD_INT 1
37560: PUSH
37561: LD_INT 3
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: LD_INT 1
37570: NEG
37571: PUSH
37572: LD_INT 2
37574: PUSH
37575: EMPTY
37576: LIST
37577: LIST
37578: PUSH
37579: LD_INT 3
37581: NEG
37582: PUSH
37583: LD_INT 2
37585: NEG
37586: PUSH
37587: EMPTY
37588: LIST
37589: LIST
37590: PUSH
37591: EMPTY
37592: LIST
37593: LIST
37594: LIST
37595: LIST
37596: LIST
37597: LIST
37598: LIST
37599: LIST
37600: LIST
37601: LIST
37602: LIST
37603: LIST
37604: LIST
37605: LIST
37606: LIST
37607: LIST
37608: LIST
37609: LIST
37610: LIST
37611: LIST
37612: LIST
37613: LIST
37614: LIST
37615: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
37616: LD_ADDR_VAR 0 34
37620: PUSH
37621: LD_INT 0
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 0
37633: PUSH
37634: LD_INT 1
37636: NEG
37637: PUSH
37638: EMPTY
37639: LIST
37640: LIST
37641: PUSH
37642: LD_INT 1
37644: PUSH
37645: LD_INT 0
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 1
37654: PUSH
37655: LD_INT 1
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 0
37664: PUSH
37665: LD_INT 1
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 1
37674: NEG
37675: PUSH
37676: LD_INT 0
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 1
37685: NEG
37686: PUSH
37687: LD_INT 1
37689: NEG
37690: PUSH
37691: EMPTY
37692: LIST
37693: LIST
37694: PUSH
37695: LD_INT 1
37697: NEG
37698: PUSH
37699: LD_INT 2
37701: NEG
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: LD_INT 0
37709: PUSH
37710: LD_INT 2
37712: NEG
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 1
37720: PUSH
37721: LD_INT 1
37723: NEG
37724: PUSH
37725: EMPTY
37726: LIST
37727: LIST
37728: PUSH
37729: LD_INT 2
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: EMPTY
37736: LIST
37737: LIST
37738: PUSH
37739: LD_INT 2
37741: PUSH
37742: LD_INT 2
37744: PUSH
37745: EMPTY
37746: LIST
37747: LIST
37748: PUSH
37749: LD_INT 1
37751: PUSH
37752: LD_INT 2
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: EMPTY
37767: LIST
37768: LIST
37769: PUSH
37770: LD_INT 2
37772: NEG
37773: PUSH
37774: LD_INT 0
37776: PUSH
37777: EMPTY
37778: LIST
37779: LIST
37780: PUSH
37781: LD_INT 2
37783: NEG
37784: PUSH
37785: LD_INT 1
37787: NEG
37788: PUSH
37789: EMPTY
37790: LIST
37791: LIST
37792: PUSH
37793: LD_INT 2
37795: NEG
37796: PUSH
37797: LD_INT 2
37799: NEG
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 1
37807: NEG
37808: PUSH
37809: LD_INT 3
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 1
37819: PUSH
37820: LD_INT 2
37822: NEG
37823: PUSH
37824: EMPTY
37825: LIST
37826: LIST
37827: PUSH
37828: LD_INT 3
37830: PUSH
37831: LD_INT 2
37833: PUSH
37834: EMPTY
37835: LIST
37836: LIST
37837: PUSH
37838: LD_INT 2
37840: PUSH
37841: LD_INT 3
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 2
37850: NEG
37851: PUSH
37852: LD_INT 1
37854: PUSH
37855: EMPTY
37856: LIST
37857: LIST
37858: PUSH
37859: LD_INT 3
37861: NEG
37862: PUSH
37863: LD_INT 1
37865: NEG
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: EMPTY
37872: LIST
37873: LIST
37874: LIST
37875: LIST
37876: LIST
37877: LIST
37878: LIST
37879: LIST
37880: LIST
37881: LIST
37882: LIST
37883: LIST
37884: LIST
37885: LIST
37886: LIST
37887: LIST
37888: LIST
37889: LIST
37890: LIST
37891: LIST
37892: LIST
37893: LIST
37894: LIST
37895: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
37896: LD_ADDR_VAR 0 35
37900: PUSH
37901: LD_INT 0
37903: PUSH
37904: LD_INT 0
37906: PUSH
37907: EMPTY
37908: LIST
37909: LIST
37910: PUSH
37911: LD_INT 0
37913: PUSH
37914: LD_INT 1
37916: NEG
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: PUSH
37922: LD_INT 1
37924: PUSH
37925: LD_INT 0
37927: PUSH
37928: EMPTY
37929: LIST
37930: LIST
37931: PUSH
37932: LD_INT 1
37934: PUSH
37935: LD_INT 1
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 0
37944: PUSH
37945: LD_INT 1
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: NEG
37955: PUSH
37956: LD_INT 0
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 1
37965: NEG
37966: PUSH
37967: LD_INT 1
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 2
37977: PUSH
37978: LD_INT 1
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 2
37987: NEG
37988: PUSH
37989: LD_INT 1
37991: NEG
37992: PUSH
37993: EMPTY
37994: LIST
37995: LIST
37996: PUSH
37997: EMPTY
37998: LIST
37999: LIST
38000: LIST
38001: LIST
38002: LIST
38003: LIST
38004: LIST
38005: LIST
38006: LIST
38007: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38008: LD_ADDR_VAR 0 36
38012: PUSH
38013: LD_INT 0
38015: PUSH
38016: LD_INT 0
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 0
38025: PUSH
38026: LD_INT 1
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 1
38036: PUSH
38037: LD_INT 0
38039: PUSH
38040: EMPTY
38041: LIST
38042: LIST
38043: PUSH
38044: LD_INT 1
38046: PUSH
38047: LD_INT 1
38049: PUSH
38050: EMPTY
38051: LIST
38052: LIST
38053: PUSH
38054: LD_INT 0
38056: PUSH
38057: LD_INT 1
38059: PUSH
38060: EMPTY
38061: LIST
38062: LIST
38063: PUSH
38064: LD_INT 1
38066: NEG
38067: PUSH
38068: LD_INT 0
38070: PUSH
38071: EMPTY
38072: LIST
38073: LIST
38074: PUSH
38075: LD_INT 1
38077: NEG
38078: PUSH
38079: LD_INT 1
38081: NEG
38082: PUSH
38083: EMPTY
38084: LIST
38085: LIST
38086: PUSH
38087: LD_INT 1
38089: NEG
38090: PUSH
38091: LD_INT 2
38093: NEG
38094: PUSH
38095: EMPTY
38096: LIST
38097: LIST
38098: PUSH
38099: LD_INT 1
38101: PUSH
38102: LD_INT 2
38104: PUSH
38105: EMPTY
38106: LIST
38107: LIST
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: LIST
38113: LIST
38114: LIST
38115: LIST
38116: LIST
38117: LIST
38118: LIST
38119: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38120: LD_ADDR_VAR 0 37
38124: PUSH
38125: LD_INT 0
38127: PUSH
38128: LD_INT 0
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: LD_INT 1
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 1
38148: PUSH
38149: LD_INT 0
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PUSH
38156: LD_INT 1
38158: PUSH
38159: LD_INT 1
38161: PUSH
38162: EMPTY
38163: LIST
38164: LIST
38165: PUSH
38166: LD_INT 0
38168: PUSH
38169: LD_INT 1
38171: PUSH
38172: EMPTY
38173: LIST
38174: LIST
38175: PUSH
38176: LD_INT 1
38178: NEG
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 1
38189: NEG
38190: PUSH
38191: LD_INT 1
38193: NEG
38194: PUSH
38195: EMPTY
38196: LIST
38197: LIST
38198: PUSH
38199: LD_INT 1
38201: PUSH
38202: LD_INT 1
38204: NEG
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PUSH
38210: LD_INT 1
38212: NEG
38213: PUSH
38214: LD_INT 1
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: EMPTY
38222: LIST
38223: LIST
38224: LIST
38225: LIST
38226: LIST
38227: LIST
38228: LIST
38229: LIST
38230: LIST
38231: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
38232: LD_ADDR_VAR 0 38
38236: PUSH
38237: LD_INT 0
38239: PUSH
38240: LD_INT 0
38242: PUSH
38243: EMPTY
38244: LIST
38245: LIST
38246: PUSH
38247: LD_INT 0
38249: PUSH
38250: LD_INT 1
38252: NEG
38253: PUSH
38254: EMPTY
38255: LIST
38256: LIST
38257: PUSH
38258: LD_INT 1
38260: PUSH
38261: LD_INT 0
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 1
38270: PUSH
38271: LD_INT 1
38273: PUSH
38274: EMPTY
38275: LIST
38276: LIST
38277: PUSH
38278: LD_INT 0
38280: PUSH
38281: LD_INT 1
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 1
38290: NEG
38291: PUSH
38292: LD_INT 0
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 1
38301: NEG
38302: PUSH
38303: LD_INT 1
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 2
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 2
38323: NEG
38324: PUSH
38325: LD_INT 1
38327: NEG
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: EMPTY
38334: LIST
38335: LIST
38336: LIST
38337: LIST
38338: LIST
38339: LIST
38340: LIST
38341: LIST
38342: LIST
38343: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
38344: LD_ADDR_VAR 0 39
38348: PUSH
38349: LD_INT 0
38351: PUSH
38352: LD_INT 0
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 0
38361: PUSH
38362: LD_INT 1
38364: NEG
38365: PUSH
38366: EMPTY
38367: LIST
38368: LIST
38369: PUSH
38370: LD_INT 1
38372: PUSH
38373: LD_INT 0
38375: PUSH
38376: EMPTY
38377: LIST
38378: LIST
38379: PUSH
38380: LD_INT 1
38382: PUSH
38383: LD_INT 1
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: PUSH
38390: LD_INT 0
38392: PUSH
38393: LD_INT 1
38395: PUSH
38396: EMPTY
38397: LIST
38398: LIST
38399: PUSH
38400: LD_INT 1
38402: NEG
38403: PUSH
38404: LD_INT 0
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: LD_INT 1
38413: NEG
38414: PUSH
38415: LD_INT 1
38417: NEG
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 1
38425: NEG
38426: PUSH
38427: LD_INT 2
38429: NEG
38430: PUSH
38431: EMPTY
38432: LIST
38433: LIST
38434: PUSH
38435: LD_INT 1
38437: PUSH
38438: LD_INT 2
38440: PUSH
38441: EMPTY
38442: LIST
38443: LIST
38444: PUSH
38445: EMPTY
38446: LIST
38447: LIST
38448: LIST
38449: LIST
38450: LIST
38451: LIST
38452: LIST
38453: LIST
38454: LIST
38455: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
38456: LD_ADDR_VAR 0 40
38460: PUSH
38461: LD_INT 0
38463: PUSH
38464: LD_INT 0
38466: PUSH
38467: EMPTY
38468: LIST
38469: LIST
38470: PUSH
38471: LD_INT 0
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 1
38484: PUSH
38485: LD_INT 0
38487: PUSH
38488: EMPTY
38489: LIST
38490: LIST
38491: PUSH
38492: LD_INT 1
38494: PUSH
38495: LD_INT 1
38497: PUSH
38498: EMPTY
38499: LIST
38500: LIST
38501: PUSH
38502: LD_INT 0
38504: PUSH
38505: LD_INT 1
38507: PUSH
38508: EMPTY
38509: LIST
38510: LIST
38511: PUSH
38512: LD_INT 1
38514: NEG
38515: PUSH
38516: LD_INT 0
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: PUSH
38523: LD_INT 1
38525: NEG
38526: PUSH
38527: LD_INT 1
38529: NEG
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 1
38537: PUSH
38538: LD_INT 1
38540: NEG
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 1
38548: NEG
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38568: LD_ADDR_VAR 0 41
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 0
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 1
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 1
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 1
38649: NEG
38650: PUSH
38651: LD_INT 2
38653: NEG
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 1
38661: PUSH
38662: LD_INT 1
38664: NEG
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: LD_INT 2
38672: PUSH
38673: LD_INT 0
38675: PUSH
38676: EMPTY
38677: LIST
38678: LIST
38679: PUSH
38680: LD_INT 2
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 2
38692: PUSH
38693: LD_INT 2
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 1
38702: PUSH
38703: LD_INT 2
38705: PUSH
38706: EMPTY
38707: LIST
38708: LIST
38709: PUSH
38710: LD_INT 1
38712: NEG
38713: PUSH
38714: LD_INT 1
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: LD_INT 2
38723: NEG
38724: PUSH
38725: LD_INT 0
38727: PUSH
38728: EMPTY
38729: LIST
38730: LIST
38731: PUSH
38732: LD_INT 2
38734: NEG
38735: PUSH
38736: LD_INT 1
38738: NEG
38739: PUSH
38740: EMPTY
38741: LIST
38742: LIST
38743: PUSH
38744: LD_INT 2
38746: NEG
38747: PUSH
38748: LD_INT 2
38750: NEG
38751: PUSH
38752: EMPTY
38753: LIST
38754: LIST
38755: PUSH
38756: LD_INT 2
38758: NEG
38759: PUSH
38760: LD_INT 3
38762: NEG
38763: PUSH
38764: EMPTY
38765: LIST
38766: LIST
38767: PUSH
38768: LD_INT 2
38770: PUSH
38771: LD_INT 1
38773: NEG
38774: PUSH
38775: EMPTY
38776: LIST
38777: LIST
38778: PUSH
38779: LD_INT 3
38781: PUSH
38782: LD_INT 0
38784: PUSH
38785: EMPTY
38786: LIST
38787: LIST
38788: PUSH
38789: LD_INT 3
38791: PUSH
38792: LD_INT 1
38794: PUSH
38795: EMPTY
38796: LIST
38797: LIST
38798: PUSH
38799: LD_INT 3
38801: PUSH
38802: LD_INT 2
38804: PUSH
38805: EMPTY
38806: LIST
38807: LIST
38808: PUSH
38809: LD_INT 3
38811: PUSH
38812: LD_INT 3
38814: PUSH
38815: EMPTY
38816: LIST
38817: LIST
38818: PUSH
38819: LD_INT 2
38821: PUSH
38822: LD_INT 3
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 2
38831: NEG
38832: PUSH
38833: LD_INT 1
38835: PUSH
38836: EMPTY
38837: LIST
38838: LIST
38839: PUSH
38840: LD_INT 3
38842: NEG
38843: PUSH
38844: LD_INT 0
38846: PUSH
38847: EMPTY
38848: LIST
38849: LIST
38850: PUSH
38851: LD_INT 3
38853: NEG
38854: PUSH
38855: LD_INT 1
38857: NEG
38858: PUSH
38859: EMPTY
38860: LIST
38861: LIST
38862: PUSH
38863: LD_INT 3
38865: NEG
38866: PUSH
38867: LD_INT 2
38869: NEG
38870: PUSH
38871: EMPTY
38872: LIST
38873: LIST
38874: PUSH
38875: LD_INT 3
38877: NEG
38878: PUSH
38879: LD_INT 3
38881: NEG
38882: PUSH
38883: EMPTY
38884: LIST
38885: LIST
38886: PUSH
38887: EMPTY
38888: LIST
38889: LIST
38890: LIST
38891: LIST
38892: LIST
38893: LIST
38894: LIST
38895: LIST
38896: LIST
38897: LIST
38898: LIST
38899: LIST
38900: LIST
38901: LIST
38902: LIST
38903: LIST
38904: LIST
38905: LIST
38906: LIST
38907: LIST
38908: LIST
38909: LIST
38910: LIST
38911: LIST
38912: LIST
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
38918: LD_ADDR_VAR 0 42
38922: PUSH
38923: LD_INT 0
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: EMPTY
38930: LIST
38931: LIST
38932: PUSH
38933: LD_INT 0
38935: PUSH
38936: LD_INT 1
38938: NEG
38939: PUSH
38940: EMPTY
38941: LIST
38942: LIST
38943: PUSH
38944: LD_INT 1
38946: PUSH
38947: LD_INT 0
38949: PUSH
38950: EMPTY
38951: LIST
38952: LIST
38953: PUSH
38954: LD_INT 1
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: EMPTY
38961: LIST
38962: LIST
38963: PUSH
38964: LD_INT 0
38966: PUSH
38967: LD_INT 1
38969: PUSH
38970: EMPTY
38971: LIST
38972: LIST
38973: PUSH
38974: LD_INT 1
38976: NEG
38977: PUSH
38978: LD_INT 0
38980: PUSH
38981: EMPTY
38982: LIST
38983: LIST
38984: PUSH
38985: LD_INT 1
38987: NEG
38988: PUSH
38989: LD_INT 1
38991: NEG
38992: PUSH
38993: EMPTY
38994: LIST
38995: LIST
38996: PUSH
38997: LD_INT 1
38999: NEG
39000: PUSH
39001: LD_INT 2
39003: NEG
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: LD_INT 0
39011: PUSH
39012: LD_INT 2
39014: NEG
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: PUSH
39020: LD_INT 1
39022: PUSH
39023: LD_INT 1
39025: NEG
39026: PUSH
39027: EMPTY
39028: LIST
39029: LIST
39030: PUSH
39031: LD_INT 2
39033: PUSH
39034: LD_INT 1
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: LD_INT 2
39043: PUSH
39044: LD_INT 2
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 1
39053: PUSH
39054: LD_INT 2
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 0
39063: PUSH
39064: LD_INT 2
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 1
39073: NEG
39074: PUSH
39075: LD_INT 1
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 2
39084: NEG
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: EMPTY
39091: LIST
39092: LIST
39093: PUSH
39094: LD_INT 2
39096: NEG
39097: PUSH
39098: LD_INT 2
39100: NEG
39101: PUSH
39102: EMPTY
39103: LIST
39104: LIST
39105: PUSH
39106: LD_INT 2
39108: NEG
39109: PUSH
39110: LD_INT 3
39112: NEG
39113: PUSH
39114: EMPTY
39115: LIST
39116: LIST
39117: PUSH
39118: LD_INT 1
39120: NEG
39121: PUSH
39122: LD_INT 3
39124: NEG
39125: PUSH
39126: EMPTY
39127: LIST
39128: LIST
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: LD_INT 3
39135: NEG
39136: PUSH
39137: EMPTY
39138: LIST
39139: LIST
39140: PUSH
39141: LD_INT 1
39143: PUSH
39144: LD_INT 2
39146: NEG
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 3
39154: PUSH
39155: LD_INT 2
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 3
39164: PUSH
39165: LD_INT 3
39167: PUSH
39168: EMPTY
39169: LIST
39170: LIST
39171: PUSH
39172: LD_INT 2
39174: PUSH
39175: LD_INT 3
39177: PUSH
39178: EMPTY
39179: LIST
39180: LIST
39181: PUSH
39182: LD_INT 1
39184: PUSH
39185: LD_INT 3
39187: PUSH
39188: EMPTY
39189: LIST
39190: LIST
39191: PUSH
39192: LD_INT 0
39194: PUSH
39195: LD_INT 3
39197: PUSH
39198: EMPTY
39199: LIST
39200: LIST
39201: PUSH
39202: LD_INT 1
39204: NEG
39205: PUSH
39206: LD_INT 2
39208: PUSH
39209: EMPTY
39210: LIST
39211: LIST
39212: PUSH
39213: LD_INT 3
39215: NEG
39216: PUSH
39217: LD_INT 2
39219: NEG
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 3
39227: NEG
39228: PUSH
39229: LD_INT 3
39231: NEG
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: LIST
39253: LIST
39254: LIST
39255: LIST
39256: LIST
39257: LIST
39258: LIST
39259: LIST
39260: LIST
39261: LIST
39262: LIST
39263: LIST
39264: LIST
39265: LIST
39266: LIST
39267: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39268: LD_ADDR_VAR 0 43
39272: PUSH
39273: LD_INT 0
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 0
39285: PUSH
39286: LD_INT 1
39288: NEG
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 1
39296: PUSH
39297: LD_INT 0
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 1
39306: PUSH
39307: LD_INT 1
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 0
39316: PUSH
39317: LD_INT 1
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 1
39326: NEG
39327: PUSH
39328: LD_INT 0
39330: PUSH
39331: EMPTY
39332: LIST
39333: LIST
39334: PUSH
39335: LD_INT 1
39337: NEG
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 1
39349: NEG
39350: PUSH
39351: LD_INT 2
39353: NEG
39354: PUSH
39355: EMPTY
39356: LIST
39357: LIST
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: LD_INT 2
39364: NEG
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: LD_INT 1
39375: NEG
39376: PUSH
39377: EMPTY
39378: LIST
39379: LIST
39380: PUSH
39381: LD_INT 2
39383: PUSH
39384: LD_INT 0
39386: PUSH
39387: EMPTY
39388: LIST
39389: LIST
39390: PUSH
39391: LD_INT 2
39393: PUSH
39394: LD_INT 1
39396: PUSH
39397: EMPTY
39398: LIST
39399: LIST
39400: PUSH
39401: LD_INT 1
39403: PUSH
39404: LD_INT 2
39406: PUSH
39407: EMPTY
39408: LIST
39409: LIST
39410: PUSH
39411: LD_INT 0
39413: PUSH
39414: LD_INT 2
39416: PUSH
39417: EMPTY
39418: LIST
39419: LIST
39420: PUSH
39421: LD_INT 1
39423: NEG
39424: PUSH
39425: LD_INT 1
39427: PUSH
39428: EMPTY
39429: LIST
39430: LIST
39431: PUSH
39432: LD_INT 2
39434: NEG
39435: PUSH
39436: LD_INT 0
39438: PUSH
39439: EMPTY
39440: LIST
39441: LIST
39442: PUSH
39443: LD_INT 2
39445: NEG
39446: PUSH
39447: LD_INT 1
39449: NEG
39450: PUSH
39451: EMPTY
39452: LIST
39453: LIST
39454: PUSH
39455: LD_INT 1
39457: NEG
39458: PUSH
39459: LD_INT 3
39461: NEG
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 0
39469: PUSH
39470: LD_INT 3
39472: NEG
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 1
39480: PUSH
39481: LD_INT 2
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: LD_INT 2
39491: PUSH
39492: LD_INT 1
39494: NEG
39495: PUSH
39496: EMPTY
39497: LIST
39498: LIST
39499: PUSH
39500: LD_INT 3
39502: PUSH
39503: LD_INT 0
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: LD_INT 3
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: EMPTY
39517: LIST
39518: LIST
39519: PUSH
39520: LD_INT 1
39522: PUSH
39523: LD_INT 3
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: LD_INT 0
39532: PUSH
39533: LD_INT 3
39535: PUSH
39536: EMPTY
39537: LIST
39538: LIST
39539: PUSH
39540: LD_INT 1
39542: NEG
39543: PUSH
39544: LD_INT 2
39546: PUSH
39547: EMPTY
39548: LIST
39549: LIST
39550: PUSH
39551: LD_INT 2
39553: NEG
39554: PUSH
39555: LD_INT 1
39557: PUSH
39558: EMPTY
39559: LIST
39560: LIST
39561: PUSH
39562: LD_INT 3
39564: NEG
39565: PUSH
39566: LD_INT 0
39568: PUSH
39569: EMPTY
39570: LIST
39571: LIST
39572: PUSH
39573: LD_INT 3
39575: NEG
39576: PUSH
39577: LD_INT 1
39579: NEG
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: LIST
39589: LIST
39590: LIST
39591: LIST
39592: LIST
39593: LIST
39594: LIST
39595: LIST
39596: LIST
39597: LIST
39598: LIST
39599: LIST
39600: LIST
39601: LIST
39602: LIST
39603: LIST
39604: LIST
39605: LIST
39606: LIST
39607: LIST
39608: LIST
39609: LIST
39610: LIST
39611: LIST
39612: LIST
39613: LIST
39614: LIST
39615: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39616: LD_ADDR_VAR 0 44
39620: PUSH
39621: LD_INT 0
39623: PUSH
39624: LD_INT 0
39626: PUSH
39627: EMPTY
39628: LIST
39629: LIST
39630: PUSH
39631: LD_INT 0
39633: PUSH
39634: LD_INT 1
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 1
39644: PUSH
39645: LD_INT 0
39647: PUSH
39648: EMPTY
39649: LIST
39650: LIST
39651: PUSH
39652: LD_INT 1
39654: PUSH
39655: LD_INT 1
39657: PUSH
39658: EMPTY
39659: LIST
39660: LIST
39661: PUSH
39662: LD_INT 0
39664: PUSH
39665: LD_INT 1
39667: PUSH
39668: EMPTY
39669: LIST
39670: LIST
39671: PUSH
39672: LD_INT 1
39674: NEG
39675: PUSH
39676: LD_INT 0
39678: PUSH
39679: EMPTY
39680: LIST
39681: LIST
39682: PUSH
39683: LD_INT 1
39685: NEG
39686: PUSH
39687: LD_INT 1
39689: NEG
39690: PUSH
39691: EMPTY
39692: LIST
39693: LIST
39694: PUSH
39695: LD_INT 1
39697: NEG
39698: PUSH
39699: LD_INT 2
39701: NEG
39702: PUSH
39703: EMPTY
39704: LIST
39705: LIST
39706: PUSH
39707: LD_INT 1
39709: PUSH
39710: LD_INT 1
39712: NEG
39713: PUSH
39714: EMPTY
39715: LIST
39716: LIST
39717: PUSH
39718: LD_INT 2
39720: PUSH
39721: LD_INT 0
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 2
39730: PUSH
39731: LD_INT 1
39733: PUSH
39734: EMPTY
39735: LIST
39736: LIST
39737: PUSH
39738: LD_INT 2
39740: PUSH
39741: LD_INT 2
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 1
39750: PUSH
39751: LD_INT 2
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 1
39760: NEG
39761: PUSH
39762: LD_INT 1
39764: PUSH
39765: EMPTY
39766: LIST
39767: LIST
39768: PUSH
39769: LD_INT 2
39771: NEG
39772: PUSH
39773: LD_INT 0
39775: PUSH
39776: EMPTY
39777: LIST
39778: LIST
39779: PUSH
39780: LD_INT 2
39782: NEG
39783: PUSH
39784: LD_INT 1
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 2
39794: NEG
39795: PUSH
39796: LD_INT 2
39798: NEG
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 2
39806: NEG
39807: PUSH
39808: LD_INT 3
39810: NEG
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: LD_INT 2
39818: PUSH
39819: LD_INT 1
39821: NEG
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 3
39829: PUSH
39830: LD_INT 0
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 3
39839: PUSH
39840: LD_INT 1
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: PUSH
39847: LD_INT 3
39849: PUSH
39850: LD_INT 2
39852: PUSH
39853: EMPTY
39854: LIST
39855: LIST
39856: PUSH
39857: LD_INT 3
39859: PUSH
39860: LD_INT 3
39862: PUSH
39863: EMPTY
39864: LIST
39865: LIST
39866: PUSH
39867: LD_INT 2
39869: PUSH
39870: LD_INT 3
39872: PUSH
39873: EMPTY
39874: LIST
39875: LIST
39876: PUSH
39877: LD_INT 2
39879: NEG
39880: PUSH
39881: LD_INT 1
39883: PUSH
39884: EMPTY
39885: LIST
39886: LIST
39887: PUSH
39888: LD_INT 3
39890: NEG
39891: PUSH
39892: LD_INT 0
39894: PUSH
39895: EMPTY
39896: LIST
39897: LIST
39898: PUSH
39899: LD_INT 3
39901: NEG
39902: PUSH
39903: LD_INT 1
39905: NEG
39906: PUSH
39907: EMPTY
39908: LIST
39909: LIST
39910: PUSH
39911: LD_INT 3
39913: NEG
39914: PUSH
39915: LD_INT 2
39917: NEG
39918: PUSH
39919: EMPTY
39920: LIST
39921: LIST
39922: PUSH
39923: LD_INT 3
39925: NEG
39926: PUSH
39927: LD_INT 3
39929: NEG
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: EMPTY
39936: LIST
39937: LIST
39938: LIST
39939: LIST
39940: LIST
39941: LIST
39942: LIST
39943: LIST
39944: LIST
39945: LIST
39946: LIST
39947: LIST
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: LIST
39958: LIST
39959: LIST
39960: LIST
39961: LIST
39962: LIST
39963: LIST
39964: LIST
39965: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39966: LD_ADDR_VAR 0 45
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: LD_INT 0
39976: PUSH
39977: EMPTY
39978: LIST
39979: LIST
39980: PUSH
39981: LD_INT 0
39983: PUSH
39984: LD_INT 1
39986: NEG
39987: PUSH
39988: EMPTY
39989: LIST
39990: LIST
39991: PUSH
39992: LD_INT 1
39994: PUSH
39995: LD_INT 0
39997: PUSH
39998: EMPTY
39999: LIST
40000: LIST
40001: PUSH
40002: LD_INT 1
40004: PUSH
40005: LD_INT 1
40007: PUSH
40008: EMPTY
40009: LIST
40010: LIST
40011: PUSH
40012: LD_INT 0
40014: PUSH
40015: LD_INT 1
40017: PUSH
40018: EMPTY
40019: LIST
40020: LIST
40021: PUSH
40022: LD_INT 1
40024: NEG
40025: PUSH
40026: LD_INT 0
40028: PUSH
40029: EMPTY
40030: LIST
40031: LIST
40032: PUSH
40033: LD_INT 1
40035: NEG
40036: PUSH
40037: LD_INT 1
40039: NEG
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 1
40047: NEG
40048: PUSH
40049: LD_INT 2
40051: NEG
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: LD_INT 2
40062: NEG
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 1
40070: PUSH
40071: LD_INT 1
40073: NEG
40074: PUSH
40075: EMPTY
40076: LIST
40077: LIST
40078: PUSH
40079: LD_INT 2
40081: PUSH
40082: LD_INT 1
40084: PUSH
40085: EMPTY
40086: LIST
40087: LIST
40088: PUSH
40089: LD_INT 2
40091: PUSH
40092: LD_INT 2
40094: PUSH
40095: EMPTY
40096: LIST
40097: LIST
40098: PUSH
40099: LD_INT 1
40101: PUSH
40102: LD_INT 2
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: LD_INT 2
40114: PUSH
40115: EMPTY
40116: LIST
40117: LIST
40118: PUSH
40119: LD_INT 1
40121: NEG
40122: PUSH
40123: LD_INT 1
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 2
40132: NEG
40133: PUSH
40134: LD_INT 1
40136: NEG
40137: PUSH
40138: EMPTY
40139: LIST
40140: LIST
40141: PUSH
40142: LD_INT 2
40144: NEG
40145: PUSH
40146: LD_INT 2
40148: NEG
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 2
40156: NEG
40157: PUSH
40158: LD_INT 3
40160: NEG
40161: PUSH
40162: EMPTY
40163: LIST
40164: LIST
40165: PUSH
40166: LD_INT 1
40168: NEG
40169: PUSH
40170: LD_INT 3
40172: NEG
40173: PUSH
40174: EMPTY
40175: LIST
40176: LIST
40177: PUSH
40178: LD_INT 0
40180: PUSH
40181: LD_INT 3
40183: NEG
40184: PUSH
40185: EMPTY
40186: LIST
40187: LIST
40188: PUSH
40189: LD_INT 1
40191: PUSH
40192: LD_INT 2
40194: NEG
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: LD_INT 3
40202: PUSH
40203: LD_INT 2
40205: PUSH
40206: EMPTY
40207: LIST
40208: LIST
40209: PUSH
40210: LD_INT 3
40212: PUSH
40213: LD_INT 3
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: PUSH
40220: LD_INT 2
40222: PUSH
40223: LD_INT 3
40225: PUSH
40226: EMPTY
40227: LIST
40228: LIST
40229: PUSH
40230: LD_INT 1
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: EMPTY
40237: LIST
40238: LIST
40239: PUSH
40240: LD_INT 0
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: EMPTY
40247: LIST
40248: LIST
40249: PUSH
40250: LD_INT 1
40252: NEG
40253: PUSH
40254: LD_INT 2
40256: PUSH
40257: EMPTY
40258: LIST
40259: LIST
40260: PUSH
40261: LD_INT 3
40263: NEG
40264: PUSH
40265: LD_INT 2
40267: NEG
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: LD_INT 3
40275: NEG
40276: PUSH
40277: LD_INT 3
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: LIST
40289: LIST
40290: LIST
40291: LIST
40292: LIST
40293: LIST
40294: LIST
40295: LIST
40296: LIST
40297: LIST
40298: LIST
40299: LIST
40300: LIST
40301: LIST
40302: LIST
40303: LIST
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: LIST
40310: LIST
40311: LIST
40312: LIST
40313: LIST
40314: LIST
40315: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
40316: LD_ADDR_VAR 0 46
40320: PUSH
40321: LD_INT 0
40323: PUSH
40324: LD_INT 0
40326: PUSH
40327: EMPTY
40328: LIST
40329: LIST
40330: PUSH
40331: LD_INT 0
40333: PUSH
40334: LD_INT 1
40336: NEG
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PUSH
40342: LD_INT 1
40344: PUSH
40345: LD_INT 0
40347: PUSH
40348: EMPTY
40349: LIST
40350: LIST
40351: PUSH
40352: LD_INT 1
40354: PUSH
40355: LD_INT 1
40357: PUSH
40358: EMPTY
40359: LIST
40360: LIST
40361: PUSH
40362: LD_INT 0
40364: PUSH
40365: LD_INT 1
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: PUSH
40372: LD_INT 1
40374: NEG
40375: PUSH
40376: LD_INT 0
40378: PUSH
40379: EMPTY
40380: LIST
40381: LIST
40382: PUSH
40383: LD_INT 1
40385: NEG
40386: PUSH
40387: LD_INT 1
40389: NEG
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 1
40397: NEG
40398: PUSH
40399: LD_INT 2
40401: NEG
40402: PUSH
40403: EMPTY
40404: LIST
40405: LIST
40406: PUSH
40407: LD_INT 0
40409: PUSH
40410: LD_INT 2
40412: NEG
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: LD_INT 1
40420: PUSH
40421: LD_INT 1
40423: NEG
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: LD_INT 2
40431: PUSH
40432: LD_INT 0
40434: PUSH
40435: EMPTY
40436: LIST
40437: LIST
40438: PUSH
40439: LD_INT 2
40441: PUSH
40442: LD_INT 1
40444: PUSH
40445: EMPTY
40446: LIST
40447: LIST
40448: PUSH
40449: LD_INT 1
40451: PUSH
40452: LD_INT 2
40454: PUSH
40455: EMPTY
40456: LIST
40457: LIST
40458: PUSH
40459: LD_INT 0
40461: PUSH
40462: LD_INT 2
40464: PUSH
40465: EMPTY
40466: LIST
40467: LIST
40468: PUSH
40469: LD_INT 1
40471: NEG
40472: PUSH
40473: LD_INT 1
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 2
40482: NEG
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: EMPTY
40488: LIST
40489: LIST
40490: PUSH
40491: LD_INT 2
40493: NEG
40494: PUSH
40495: LD_INT 1
40497: NEG
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PUSH
40503: LD_INT 1
40505: NEG
40506: PUSH
40507: LD_INT 3
40509: NEG
40510: PUSH
40511: EMPTY
40512: LIST
40513: LIST
40514: PUSH
40515: LD_INT 0
40517: PUSH
40518: LD_INT 3
40520: NEG
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: PUSH
40526: LD_INT 1
40528: PUSH
40529: LD_INT 2
40531: NEG
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 2
40539: PUSH
40540: LD_INT 1
40542: NEG
40543: PUSH
40544: EMPTY
40545: LIST
40546: LIST
40547: PUSH
40548: LD_INT 3
40550: PUSH
40551: LD_INT 0
40553: PUSH
40554: EMPTY
40555: LIST
40556: LIST
40557: PUSH
40558: LD_INT 3
40560: PUSH
40561: LD_INT 1
40563: PUSH
40564: EMPTY
40565: LIST
40566: LIST
40567: PUSH
40568: LD_INT 1
40570: PUSH
40571: LD_INT 3
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 0
40580: PUSH
40581: LD_INT 3
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PUSH
40588: LD_INT 1
40590: NEG
40591: PUSH
40592: LD_INT 2
40594: PUSH
40595: EMPTY
40596: LIST
40597: LIST
40598: PUSH
40599: LD_INT 2
40601: NEG
40602: PUSH
40603: LD_INT 1
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 3
40612: NEG
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 3
40623: NEG
40624: PUSH
40625: LD_INT 1
40627: NEG
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: LIST
40637: LIST
40638: LIST
40639: LIST
40640: LIST
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: LIST
40657: LIST
40658: LIST
40659: LIST
40660: LIST
40661: LIST
40662: LIST
40663: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40664: LD_ADDR_VAR 0 47
40668: PUSH
40669: LD_INT 0
40671: PUSH
40672: LD_INT 0
40674: PUSH
40675: EMPTY
40676: LIST
40677: LIST
40678: PUSH
40679: LD_INT 0
40681: PUSH
40682: LD_INT 1
40684: NEG
40685: PUSH
40686: EMPTY
40687: LIST
40688: LIST
40689: PUSH
40690: LD_INT 1
40692: PUSH
40693: LD_INT 0
40695: PUSH
40696: EMPTY
40697: LIST
40698: LIST
40699: PUSH
40700: LD_INT 1
40702: PUSH
40703: LD_INT 1
40705: PUSH
40706: EMPTY
40707: LIST
40708: LIST
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: LD_INT 1
40715: PUSH
40716: EMPTY
40717: LIST
40718: LIST
40719: PUSH
40720: LD_INT 1
40722: NEG
40723: PUSH
40724: LD_INT 0
40726: PUSH
40727: EMPTY
40728: LIST
40729: LIST
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: LD_INT 1
40737: NEG
40738: PUSH
40739: EMPTY
40740: LIST
40741: LIST
40742: PUSH
40743: LD_INT 1
40745: NEG
40746: PUSH
40747: LD_INT 2
40749: NEG
40750: PUSH
40751: EMPTY
40752: LIST
40753: LIST
40754: PUSH
40755: LD_INT 0
40757: PUSH
40758: LD_INT 2
40760: NEG
40761: PUSH
40762: EMPTY
40763: LIST
40764: LIST
40765: PUSH
40766: LD_INT 1
40768: PUSH
40769: LD_INT 1
40771: NEG
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: PUSH
40777: LD_INT 2
40779: NEG
40780: PUSH
40781: LD_INT 1
40783: NEG
40784: PUSH
40785: EMPTY
40786: LIST
40787: LIST
40788: PUSH
40789: LD_INT 2
40791: NEG
40792: PUSH
40793: LD_INT 2
40795: NEG
40796: PUSH
40797: EMPTY
40798: LIST
40799: LIST
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: LIST
40805: LIST
40806: LIST
40807: LIST
40808: LIST
40809: LIST
40810: LIST
40811: LIST
40812: LIST
40813: LIST
40814: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
40815: LD_ADDR_VAR 0 48
40819: PUSH
40820: LD_INT 0
40822: PUSH
40823: LD_INT 0
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 0
40832: PUSH
40833: LD_INT 1
40835: NEG
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 1
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 1
40853: PUSH
40854: LD_INT 1
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: LD_INT 0
40863: PUSH
40864: LD_INT 1
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 1
40873: NEG
40874: PUSH
40875: LD_INT 0
40877: PUSH
40878: EMPTY
40879: LIST
40880: LIST
40881: PUSH
40882: LD_INT 1
40884: NEG
40885: PUSH
40886: LD_INT 1
40888: NEG
40889: PUSH
40890: EMPTY
40891: LIST
40892: LIST
40893: PUSH
40894: LD_INT 1
40896: NEG
40897: PUSH
40898: LD_INT 2
40900: NEG
40901: PUSH
40902: EMPTY
40903: LIST
40904: LIST
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: LD_INT 2
40911: NEG
40912: PUSH
40913: EMPTY
40914: LIST
40915: LIST
40916: PUSH
40917: LD_INT 1
40919: PUSH
40920: LD_INT 1
40922: NEG
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 2
40930: PUSH
40931: LD_INT 0
40933: PUSH
40934: EMPTY
40935: LIST
40936: LIST
40937: PUSH
40938: LD_INT 2
40940: PUSH
40941: LD_INT 1
40943: PUSH
40944: EMPTY
40945: LIST
40946: LIST
40947: PUSH
40948: EMPTY
40949: LIST
40950: LIST
40951: LIST
40952: LIST
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: LIST
40960: LIST
40961: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
40962: LD_ADDR_VAR 0 49
40966: PUSH
40967: LD_INT 0
40969: PUSH
40970: LD_INT 0
40972: PUSH
40973: EMPTY
40974: LIST
40975: LIST
40976: PUSH
40977: LD_INT 0
40979: PUSH
40980: LD_INT 1
40982: NEG
40983: PUSH
40984: EMPTY
40985: LIST
40986: LIST
40987: PUSH
40988: LD_INT 1
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: EMPTY
40995: LIST
40996: LIST
40997: PUSH
40998: LD_INT 1
41000: PUSH
41001: LD_INT 1
41003: PUSH
41004: EMPTY
41005: LIST
41006: LIST
41007: PUSH
41008: LD_INT 0
41010: PUSH
41011: LD_INT 1
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: PUSH
41018: LD_INT 1
41020: NEG
41021: PUSH
41022: LD_INT 0
41024: PUSH
41025: EMPTY
41026: LIST
41027: LIST
41028: PUSH
41029: LD_INT 1
41031: NEG
41032: PUSH
41033: LD_INT 1
41035: NEG
41036: PUSH
41037: EMPTY
41038: LIST
41039: LIST
41040: PUSH
41041: LD_INT 1
41043: PUSH
41044: LD_INT 1
41046: NEG
41047: PUSH
41048: EMPTY
41049: LIST
41050: LIST
41051: PUSH
41052: LD_INT 2
41054: PUSH
41055: LD_INT 0
41057: PUSH
41058: EMPTY
41059: LIST
41060: LIST
41061: PUSH
41062: LD_INT 2
41064: PUSH
41065: LD_INT 1
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: PUSH
41072: LD_INT 2
41074: PUSH
41075: LD_INT 2
41077: PUSH
41078: EMPTY
41079: LIST
41080: LIST
41081: PUSH
41082: LD_INT 1
41084: PUSH
41085: LD_INT 2
41087: PUSH
41088: EMPTY
41089: LIST
41090: LIST
41091: PUSH
41092: EMPTY
41093: LIST
41094: LIST
41095: LIST
41096: LIST
41097: LIST
41098: LIST
41099: LIST
41100: LIST
41101: LIST
41102: LIST
41103: LIST
41104: LIST
41105: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41106: LD_ADDR_VAR 0 50
41110: PUSH
41111: LD_INT 0
41113: PUSH
41114: LD_INT 0
41116: PUSH
41117: EMPTY
41118: LIST
41119: LIST
41120: PUSH
41121: LD_INT 0
41123: PUSH
41124: LD_INT 1
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 1
41134: PUSH
41135: LD_INT 0
41137: PUSH
41138: EMPTY
41139: LIST
41140: LIST
41141: PUSH
41142: LD_INT 1
41144: PUSH
41145: LD_INT 1
41147: PUSH
41148: EMPTY
41149: LIST
41150: LIST
41151: PUSH
41152: LD_INT 0
41154: PUSH
41155: LD_INT 1
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: NEG
41165: PUSH
41166: LD_INT 0
41168: PUSH
41169: EMPTY
41170: LIST
41171: LIST
41172: PUSH
41173: LD_INT 1
41175: NEG
41176: PUSH
41177: LD_INT 1
41179: NEG
41180: PUSH
41181: EMPTY
41182: LIST
41183: LIST
41184: PUSH
41185: LD_INT 2
41187: PUSH
41188: LD_INT 1
41190: PUSH
41191: EMPTY
41192: LIST
41193: LIST
41194: PUSH
41195: LD_INT 2
41197: PUSH
41198: LD_INT 2
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: PUSH
41205: LD_INT 1
41207: PUSH
41208: LD_INT 2
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: LD_INT 0
41217: PUSH
41218: LD_INT 2
41220: PUSH
41221: EMPTY
41222: LIST
41223: LIST
41224: PUSH
41225: LD_INT 1
41227: NEG
41228: PUSH
41229: LD_INT 1
41231: PUSH
41232: EMPTY
41233: LIST
41234: LIST
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: LIST
41246: LIST
41247: LIST
41248: LIST
41249: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41250: LD_ADDR_VAR 0 51
41254: PUSH
41255: LD_INT 0
41257: PUSH
41258: LD_INT 0
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: PUSH
41265: LD_INT 0
41267: PUSH
41268: LD_INT 1
41270: NEG
41271: PUSH
41272: EMPTY
41273: LIST
41274: LIST
41275: PUSH
41276: LD_INT 1
41278: PUSH
41279: LD_INT 0
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PUSH
41286: LD_INT 1
41288: PUSH
41289: LD_INT 1
41291: PUSH
41292: EMPTY
41293: LIST
41294: LIST
41295: PUSH
41296: LD_INT 0
41298: PUSH
41299: LD_INT 1
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: PUSH
41306: LD_INT 1
41308: NEG
41309: PUSH
41310: LD_INT 0
41312: PUSH
41313: EMPTY
41314: LIST
41315: LIST
41316: PUSH
41317: LD_INT 1
41319: NEG
41320: PUSH
41321: LD_INT 1
41323: NEG
41324: PUSH
41325: EMPTY
41326: LIST
41327: LIST
41328: PUSH
41329: LD_INT 1
41331: PUSH
41332: LD_INT 2
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 0
41341: PUSH
41342: LD_INT 2
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: LD_INT 1
41351: NEG
41352: PUSH
41353: LD_INT 1
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 2
41362: NEG
41363: PUSH
41364: LD_INT 0
41366: PUSH
41367: EMPTY
41368: LIST
41369: LIST
41370: PUSH
41371: LD_INT 2
41373: NEG
41374: PUSH
41375: LD_INT 1
41377: NEG
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: EMPTY
41384: LIST
41385: LIST
41386: LIST
41387: LIST
41388: LIST
41389: LIST
41390: LIST
41391: LIST
41392: LIST
41393: LIST
41394: LIST
41395: LIST
41396: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41397: LD_ADDR_VAR 0 52
41401: PUSH
41402: LD_INT 0
41404: PUSH
41405: LD_INT 0
41407: PUSH
41408: EMPTY
41409: LIST
41410: LIST
41411: PUSH
41412: LD_INT 0
41414: PUSH
41415: LD_INT 1
41417: NEG
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 1
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 1
41435: PUSH
41436: LD_INT 1
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: LD_INT 0
41445: PUSH
41446: LD_INT 1
41448: PUSH
41449: EMPTY
41450: LIST
41451: LIST
41452: PUSH
41453: LD_INT 1
41455: NEG
41456: PUSH
41457: LD_INT 0
41459: PUSH
41460: EMPTY
41461: LIST
41462: LIST
41463: PUSH
41464: LD_INT 1
41466: NEG
41467: PUSH
41468: LD_INT 1
41470: NEG
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: LD_INT 1
41478: NEG
41479: PUSH
41480: LD_INT 2
41482: NEG
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: PUSH
41488: LD_INT 1
41490: NEG
41491: PUSH
41492: LD_INT 1
41494: PUSH
41495: EMPTY
41496: LIST
41497: LIST
41498: PUSH
41499: LD_INT 2
41501: NEG
41502: PUSH
41503: LD_INT 0
41505: PUSH
41506: EMPTY
41507: LIST
41508: LIST
41509: PUSH
41510: LD_INT 2
41512: NEG
41513: PUSH
41514: LD_INT 1
41516: NEG
41517: PUSH
41518: EMPTY
41519: LIST
41520: LIST
41521: PUSH
41522: LD_INT 2
41524: NEG
41525: PUSH
41526: LD_INT 2
41528: NEG
41529: PUSH
41530: EMPTY
41531: LIST
41532: LIST
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: LIST
41538: LIST
41539: LIST
41540: LIST
41541: LIST
41542: LIST
41543: LIST
41544: LIST
41545: LIST
41546: LIST
41547: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41548: LD_ADDR_VAR 0 53
41552: PUSH
41553: LD_INT 0
41555: PUSH
41556: LD_INT 0
41558: PUSH
41559: EMPTY
41560: LIST
41561: LIST
41562: PUSH
41563: LD_INT 0
41565: PUSH
41566: LD_INT 1
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 1
41576: PUSH
41577: LD_INT 0
41579: PUSH
41580: EMPTY
41581: LIST
41582: LIST
41583: PUSH
41584: LD_INT 1
41586: PUSH
41587: LD_INT 1
41589: PUSH
41590: EMPTY
41591: LIST
41592: LIST
41593: PUSH
41594: LD_INT 0
41596: PUSH
41597: LD_INT 1
41599: PUSH
41600: EMPTY
41601: LIST
41602: LIST
41603: PUSH
41604: LD_INT 1
41606: NEG
41607: PUSH
41608: LD_INT 0
41610: PUSH
41611: EMPTY
41612: LIST
41613: LIST
41614: PUSH
41615: LD_INT 1
41617: NEG
41618: PUSH
41619: LD_INT 1
41621: NEG
41622: PUSH
41623: EMPTY
41624: LIST
41625: LIST
41626: PUSH
41627: LD_INT 1
41629: NEG
41630: PUSH
41631: LD_INT 2
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 0
41641: PUSH
41642: LD_INT 2
41644: NEG
41645: PUSH
41646: EMPTY
41647: LIST
41648: LIST
41649: PUSH
41650: LD_INT 1
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: PUSH
41661: LD_INT 2
41663: PUSH
41664: LD_INT 0
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 2
41673: PUSH
41674: LD_INT 1
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: LD_INT 2
41683: PUSH
41684: LD_INT 2
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: LD_INT 2
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 0
41703: PUSH
41704: LD_INT 2
41706: PUSH
41707: EMPTY
41708: LIST
41709: LIST
41710: PUSH
41711: LD_INT 1
41713: NEG
41714: PUSH
41715: LD_INT 1
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 2
41724: NEG
41725: PUSH
41726: LD_INT 0
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: LD_INT 2
41735: NEG
41736: PUSH
41737: LD_INT 1
41739: NEG
41740: PUSH
41741: EMPTY
41742: LIST
41743: LIST
41744: PUSH
41745: LD_INT 2
41747: NEG
41748: PUSH
41749: LD_INT 2
41751: NEG
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: LIST
41761: LIST
41762: LIST
41763: LIST
41764: LIST
41765: LIST
41766: LIST
41767: LIST
41768: LIST
41769: LIST
41770: LIST
41771: LIST
41772: LIST
41773: LIST
41774: LIST
41775: LIST
41776: LIST
41777: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41778: LD_ADDR_VAR 0 54
41782: PUSH
41783: LD_INT 0
41785: PUSH
41786: LD_INT 0
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: LD_INT 0
41795: PUSH
41796: LD_INT 1
41798: NEG
41799: PUSH
41800: EMPTY
41801: LIST
41802: LIST
41803: PUSH
41804: LD_INT 1
41806: PUSH
41807: LD_INT 0
41809: PUSH
41810: EMPTY
41811: LIST
41812: LIST
41813: PUSH
41814: LD_INT 1
41816: PUSH
41817: LD_INT 1
41819: PUSH
41820: EMPTY
41821: LIST
41822: LIST
41823: PUSH
41824: LD_INT 0
41826: PUSH
41827: LD_INT 1
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: LD_INT 1
41836: NEG
41837: PUSH
41838: LD_INT 0
41840: PUSH
41841: EMPTY
41842: LIST
41843: LIST
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: LD_INT 1
41851: NEG
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: PUSH
41857: LD_INT 1
41859: NEG
41860: PUSH
41861: LD_INT 2
41863: NEG
41864: PUSH
41865: EMPTY
41866: LIST
41867: LIST
41868: PUSH
41869: LD_INT 0
41871: PUSH
41872: LD_INT 2
41874: NEG
41875: PUSH
41876: EMPTY
41877: LIST
41878: LIST
41879: PUSH
41880: LD_INT 1
41882: PUSH
41883: LD_INT 1
41885: NEG
41886: PUSH
41887: EMPTY
41888: LIST
41889: LIST
41890: PUSH
41891: LD_INT 2
41893: PUSH
41894: LD_INT 0
41896: PUSH
41897: EMPTY
41898: LIST
41899: LIST
41900: PUSH
41901: LD_INT 2
41903: PUSH
41904: LD_INT 1
41906: PUSH
41907: EMPTY
41908: LIST
41909: LIST
41910: PUSH
41911: LD_INT 2
41913: PUSH
41914: LD_INT 2
41916: PUSH
41917: EMPTY
41918: LIST
41919: LIST
41920: PUSH
41921: LD_INT 1
41923: PUSH
41924: LD_INT 2
41926: PUSH
41927: EMPTY
41928: LIST
41929: LIST
41930: PUSH
41931: LD_INT 0
41933: PUSH
41934: LD_INT 2
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 1
41943: NEG
41944: PUSH
41945: LD_INT 1
41947: PUSH
41948: EMPTY
41949: LIST
41950: LIST
41951: PUSH
41952: LD_INT 2
41954: NEG
41955: PUSH
41956: LD_INT 0
41958: PUSH
41959: EMPTY
41960: LIST
41961: LIST
41962: PUSH
41963: LD_INT 2
41965: NEG
41966: PUSH
41967: LD_INT 1
41969: NEG
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 2
41977: NEG
41978: PUSH
41979: LD_INT 2
41981: NEG
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: LIST
41991: LIST
41992: LIST
41993: LIST
41994: LIST
41995: LIST
41996: LIST
41997: LIST
41998: LIST
41999: LIST
42000: LIST
42001: LIST
42002: LIST
42003: LIST
42004: LIST
42005: LIST
42006: LIST
42007: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42008: LD_ADDR_VAR 0 55
42012: PUSH
42013: LD_INT 0
42015: PUSH
42016: LD_INT 0
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: LD_INT 1
42028: NEG
42029: PUSH
42030: EMPTY
42031: LIST
42032: LIST
42033: PUSH
42034: LD_INT 1
42036: PUSH
42037: LD_INT 0
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PUSH
42044: LD_INT 1
42046: PUSH
42047: LD_INT 1
42049: PUSH
42050: EMPTY
42051: LIST
42052: LIST
42053: PUSH
42054: LD_INT 0
42056: PUSH
42057: LD_INT 1
42059: PUSH
42060: EMPTY
42061: LIST
42062: LIST
42063: PUSH
42064: LD_INT 1
42066: NEG
42067: PUSH
42068: LD_INT 0
42070: PUSH
42071: EMPTY
42072: LIST
42073: LIST
42074: PUSH
42075: LD_INT 1
42077: NEG
42078: PUSH
42079: LD_INT 1
42081: NEG
42082: PUSH
42083: EMPTY
42084: LIST
42085: LIST
42086: PUSH
42087: LD_INT 1
42089: NEG
42090: PUSH
42091: LD_INT 2
42093: NEG
42094: PUSH
42095: EMPTY
42096: LIST
42097: LIST
42098: PUSH
42099: LD_INT 0
42101: PUSH
42102: LD_INT 2
42104: NEG
42105: PUSH
42106: EMPTY
42107: LIST
42108: LIST
42109: PUSH
42110: LD_INT 1
42112: PUSH
42113: LD_INT 1
42115: NEG
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 2
42123: PUSH
42124: LD_INT 0
42126: PUSH
42127: EMPTY
42128: LIST
42129: LIST
42130: PUSH
42131: LD_INT 2
42133: PUSH
42134: LD_INT 1
42136: PUSH
42137: EMPTY
42138: LIST
42139: LIST
42140: PUSH
42141: LD_INT 2
42143: PUSH
42144: LD_INT 2
42146: PUSH
42147: EMPTY
42148: LIST
42149: LIST
42150: PUSH
42151: LD_INT 1
42153: PUSH
42154: LD_INT 2
42156: PUSH
42157: EMPTY
42158: LIST
42159: LIST
42160: PUSH
42161: LD_INT 0
42163: PUSH
42164: LD_INT 2
42166: PUSH
42167: EMPTY
42168: LIST
42169: LIST
42170: PUSH
42171: LD_INT 1
42173: NEG
42174: PUSH
42175: LD_INT 1
42177: PUSH
42178: EMPTY
42179: LIST
42180: LIST
42181: PUSH
42182: LD_INT 2
42184: NEG
42185: PUSH
42186: LD_INT 0
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PUSH
42193: LD_INT 2
42195: NEG
42196: PUSH
42197: LD_INT 1
42199: NEG
42200: PUSH
42201: EMPTY
42202: LIST
42203: LIST
42204: PUSH
42205: LD_INT 2
42207: NEG
42208: PUSH
42209: LD_INT 2
42211: NEG
42212: PUSH
42213: EMPTY
42214: LIST
42215: LIST
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: LIST
42221: LIST
42222: LIST
42223: LIST
42224: LIST
42225: LIST
42226: LIST
42227: LIST
42228: LIST
42229: LIST
42230: LIST
42231: LIST
42232: LIST
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42238: LD_ADDR_VAR 0 56
42242: PUSH
42243: LD_INT 0
42245: PUSH
42246: LD_INT 0
42248: PUSH
42249: EMPTY
42250: LIST
42251: LIST
42252: PUSH
42253: LD_INT 0
42255: PUSH
42256: LD_INT 1
42258: NEG
42259: PUSH
42260: EMPTY
42261: LIST
42262: LIST
42263: PUSH
42264: LD_INT 1
42266: PUSH
42267: LD_INT 0
42269: PUSH
42270: EMPTY
42271: LIST
42272: LIST
42273: PUSH
42274: LD_INT 1
42276: PUSH
42277: LD_INT 1
42279: PUSH
42280: EMPTY
42281: LIST
42282: LIST
42283: PUSH
42284: LD_INT 0
42286: PUSH
42287: LD_INT 1
42289: PUSH
42290: EMPTY
42291: LIST
42292: LIST
42293: PUSH
42294: LD_INT 1
42296: NEG
42297: PUSH
42298: LD_INT 0
42300: PUSH
42301: EMPTY
42302: LIST
42303: LIST
42304: PUSH
42305: LD_INT 1
42307: NEG
42308: PUSH
42309: LD_INT 1
42311: NEG
42312: PUSH
42313: EMPTY
42314: LIST
42315: LIST
42316: PUSH
42317: LD_INT 1
42319: NEG
42320: PUSH
42321: LD_INT 2
42323: NEG
42324: PUSH
42325: EMPTY
42326: LIST
42327: LIST
42328: PUSH
42329: LD_INT 0
42331: PUSH
42332: LD_INT 2
42334: NEG
42335: PUSH
42336: EMPTY
42337: LIST
42338: LIST
42339: PUSH
42340: LD_INT 1
42342: PUSH
42343: LD_INT 1
42345: NEG
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 2
42353: PUSH
42354: LD_INT 0
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 2
42363: PUSH
42364: LD_INT 1
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 2
42373: PUSH
42374: LD_INT 2
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 1
42383: PUSH
42384: LD_INT 2
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 0
42393: PUSH
42394: LD_INT 2
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 1
42403: NEG
42404: PUSH
42405: LD_INT 1
42407: PUSH
42408: EMPTY
42409: LIST
42410: LIST
42411: PUSH
42412: LD_INT 2
42414: NEG
42415: PUSH
42416: LD_INT 0
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 2
42425: NEG
42426: PUSH
42427: LD_INT 1
42429: NEG
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: PUSH
42435: LD_INT 2
42437: NEG
42438: PUSH
42439: LD_INT 2
42441: NEG
42442: PUSH
42443: EMPTY
42444: LIST
42445: LIST
42446: PUSH
42447: EMPTY
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42468: LD_ADDR_VAR 0 57
42472: PUSH
42473: LD_INT 0
42475: PUSH
42476: LD_INT 0
42478: PUSH
42479: EMPTY
42480: LIST
42481: LIST
42482: PUSH
42483: LD_INT 0
42485: PUSH
42486: LD_INT 1
42488: NEG
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 1
42496: PUSH
42497: LD_INT 0
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PUSH
42504: LD_INT 1
42506: PUSH
42507: LD_INT 1
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: LD_INT 0
42516: PUSH
42517: LD_INT 1
42519: PUSH
42520: EMPTY
42521: LIST
42522: LIST
42523: PUSH
42524: LD_INT 1
42526: NEG
42527: PUSH
42528: LD_INT 0
42530: PUSH
42531: EMPTY
42532: LIST
42533: LIST
42534: PUSH
42535: LD_INT 1
42537: NEG
42538: PUSH
42539: LD_INT 1
42541: NEG
42542: PUSH
42543: EMPTY
42544: LIST
42545: LIST
42546: PUSH
42547: LD_INT 1
42549: NEG
42550: PUSH
42551: LD_INT 2
42553: NEG
42554: PUSH
42555: EMPTY
42556: LIST
42557: LIST
42558: PUSH
42559: LD_INT 0
42561: PUSH
42562: LD_INT 2
42564: NEG
42565: PUSH
42566: EMPTY
42567: LIST
42568: LIST
42569: PUSH
42570: LD_INT 1
42572: PUSH
42573: LD_INT 1
42575: NEG
42576: PUSH
42577: EMPTY
42578: LIST
42579: LIST
42580: PUSH
42581: LD_INT 2
42583: PUSH
42584: LD_INT 0
42586: PUSH
42587: EMPTY
42588: LIST
42589: LIST
42590: PUSH
42591: LD_INT 2
42593: PUSH
42594: LD_INT 1
42596: PUSH
42597: EMPTY
42598: LIST
42599: LIST
42600: PUSH
42601: LD_INT 2
42603: PUSH
42604: LD_INT 2
42606: PUSH
42607: EMPTY
42608: LIST
42609: LIST
42610: PUSH
42611: LD_INT 1
42613: PUSH
42614: LD_INT 2
42616: PUSH
42617: EMPTY
42618: LIST
42619: LIST
42620: PUSH
42621: LD_INT 0
42623: PUSH
42624: LD_INT 2
42626: PUSH
42627: EMPTY
42628: LIST
42629: LIST
42630: PUSH
42631: LD_INT 1
42633: NEG
42634: PUSH
42635: LD_INT 1
42637: PUSH
42638: EMPTY
42639: LIST
42640: LIST
42641: PUSH
42642: LD_INT 2
42644: NEG
42645: PUSH
42646: LD_INT 0
42648: PUSH
42649: EMPTY
42650: LIST
42651: LIST
42652: PUSH
42653: LD_INT 2
42655: NEG
42656: PUSH
42657: LD_INT 1
42659: NEG
42660: PUSH
42661: EMPTY
42662: LIST
42663: LIST
42664: PUSH
42665: LD_INT 2
42667: NEG
42668: PUSH
42669: LD_INT 2
42671: NEG
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: EMPTY
42678: LIST
42679: LIST
42680: LIST
42681: LIST
42682: LIST
42683: LIST
42684: LIST
42685: LIST
42686: LIST
42687: LIST
42688: LIST
42689: LIST
42690: LIST
42691: LIST
42692: LIST
42693: LIST
42694: LIST
42695: LIST
42696: LIST
42697: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
42698: LD_ADDR_VAR 0 58
42702: PUSH
42703: LD_INT 0
42705: PUSH
42706: LD_INT 0
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: PUSH
42713: LD_INT 0
42715: PUSH
42716: LD_INT 1
42718: NEG
42719: PUSH
42720: EMPTY
42721: LIST
42722: LIST
42723: PUSH
42724: LD_INT 1
42726: PUSH
42727: LD_INT 0
42729: PUSH
42730: EMPTY
42731: LIST
42732: LIST
42733: PUSH
42734: LD_INT 1
42736: PUSH
42737: LD_INT 1
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 0
42746: PUSH
42747: LD_INT 1
42749: PUSH
42750: EMPTY
42751: LIST
42752: LIST
42753: PUSH
42754: LD_INT 1
42756: NEG
42757: PUSH
42758: LD_INT 0
42760: PUSH
42761: EMPTY
42762: LIST
42763: LIST
42764: PUSH
42765: LD_INT 1
42767: NEG
42768: PUSH
42769: LD_INT 1
42771: NEG
42772: PUSH
42773: EMPTY
42774: LIST
42775: LIST
42776: PUSH
42777: LD_INT 1
42779: NEG
42780: PUSH
42781: LD_INT 2
42783: NEG
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 0
42791: PUSH
42792: LD_INT 2
42794: NEG
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: LD_INT 1
42802: PUSH
42803: LD_INT 1
42805: NEG
42806: PUSH
42807: EMPTY
42808: LIST
42809: LIST
42810: PUSH
42811: LD_INT 2
42813: PUSH
42814: LD_INT 0
42816: PUSH
42817: EMPTY
42818: LIST
42819: LIST
42820: PUSH
42821: LD_INT 2
42823: PUSH
42824: LD_INT 1
42826: PUSH
42827: EMPTY
42828: LIST
42829: LIST
42830: PUSH
42831: LD_INT 2
42833: PUSH
42834: LD_INT 2
42836: PUSH
42837: EMPTY
42838: LIST
42839: LIST
42840: PUSH
42841: LD_INT 1
42843: PUSH
42844: LD_INT 2
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: LD_INT 2
42856: PUSH
42857: EMPTY
42858: LIST
42859: LIST
42860: PUSH
42861: LD_INT 1
42863: NEG
42864: PUSH
42865: LD_INT 1
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: PUSH
42872: LD_INT 2
42874: NEG
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: EMPTY
42880: LIST
42881: LIST
42882: PUSH
42883: LD_INT 2
42885: NEG
42886: PUSH
42887: LD_INT 1
42889: NEG
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 2
42897: NEG
42898: PUSH
42899: LD_INT 2
42901: NEG
42902: PUSH
42903: EMPTY
42904: LIST
42905: LIST
42906: PUSH
42907: EMPTY
42908: LIST
42909: LIST
42910: LIST
42911: LIST
42912: LIST
42913: LIST
42914: LIST
42915: LIST
42916: LIST
42917: LIST
42918: LIST
42919: LIST
42920: LIST
42921: LIST
42922: LIST
42923: LIST
42924: LIST
42925: LIST
42926: LIST
42927: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
42928: LD_ADDR_VAR 0 59
42932: PUSH
42933: LD_INT 0
42935: PUSH
42936: LD_INT 0
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: LD_INT 0
42945: PUSH
42946: LD_INT 1
42948: NEG
42949: PUSH
42950: EMPTY
42951: LIST
42952: LIST
42953: PUSH
42954: LD_INT 1
42956: PUSH
42957: LD_INT 0
42959: PUSH
42960: EMPTY
42961: LIST
42962: LIST
42963: PUSH
42964: LD_INT 1
42966: PUSH
42967: LD_INT 1
42969: PUSH
42970: EMPTY
42971: LIST
42972: LIST
42973: PUSH
42974: LD_INT 0
42976: PUSH
42977: LD_INT 1
42979: PUSH
42980: EMPTY
42981: LIST
42982: LIST
42983: PUSH
42984: LD_INT 1
42986: NEG
42987: PUSH
42988: LD_INT 0
42990: PUSH
42991: EMPTY
42992: LIST
42993: LIST
42994: PUSH
42995: LD_INT 1
42997: NEG
42998: PUSH
42999: LD_INT 1
43001: NEG
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: EMPTY
43008: LIST
43009: LIST
43010: LIST
43011: LIST
43012: LIST
43013: LIST
43014: LIST
43015: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43016: LD_ADDR_VAR 0 60
43020: PUSH
43021: LD_INT 0
43023: PUSH
43024: LD_INT 0
43026: PUSH
43027: EMPTY
43028: LIST
43029: LIST
43030: PUSH
43031: LD_INT 0
43033: PUSH
43034: LD_INT 1
43036: NEG
43037: PUSH
43038: EMPTY
43039: LIST
43040: LIST
43041: PUSH
43042: LD_INT 1
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: EMPTY
43049: LIST
43050: LIST
43051: PUSH
43052: LD_INT 1
43054: PUSH
43055: LD_INT 1
43057: PUSH
43058: EMPTY
43059: LIST
43060: LIST
43061: PUSH
43062: LD_INT 0
43064: PUSH
43065: LD_INT 1
43067: PUSH
43068: EMPTY
43069: LIST
43070: LIST
43071: PUSH
43072: LD_INT 1
43074: NEG
43075: PUSH
43076: LD_INT 0
43078: PUSH
43079: EMPTY
43080: LIST
43081: LIST
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: LD_INT 1
43089: NEG
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43104: LD_ADDR_VAR 0 61
43108: PUSH
43109: LD_INT 0
43111: PUSH
43112: LD_INT 0
43114: PUSH
43115: EMPTY
43116: LIST
43117: LIST
43118: PUSH
43119: LD_INT 0
43121: PUSH
43122: LD_INT 1
43124: NEG
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: LD_INT 0
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: PUSH
43140: LD_INT 1
43142: PUSH
43143: LD_INT 1
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: LD_INT 0
43152: PUSH
43153: LD_INT 1
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: LD_INT 1
43162: NEG
43163: PUSH
43164: LD_INT 0
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: LD_INT 1
43173: NEG
43174: PUSH
43175: LD_INT 1
43177: NEG
43178: PUSH
43179: EMPTY
43180: LIST
43181: LIST
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: LIST
43187: LIST
43188: LIST
43189: LIST
43190: LIST
43191: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43192: LD_ADDR_VAR 0 62
43196: PUSH
43197: LD_INT 0
43199: PUSH
43200: LD_INT 0
43202: PUSH
43203: EMPTY
43204: LIST
43205: LIST
43206: PUSH
43207: LD_INT 0
43209: PUSH
43210: LD_INT 1
43212: NEG
43213: PUSH
43214: EMPTY
43215: LIST
43216: LIST
43217: PUSH
43218: LD_INT 1
43220: PUSH
43221: LD_INT 0
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 1
43230: PUSH
43231: LD_INT 1
43233: PUSH
43234: EMPTY
43235: LIST
43236: LIST
43237: PUSH
43238: LD_INT 0
43240: PUSH
43241: LD_INT 1
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 1
43250: NEG
43251: PUSH
43252: LD_INT 0
43254: PUSH
43255: EMPTY
43256: LIST
43257: LIST
43258: PUSH
43259: LD_INT 1
43261: NEG
43262: PUSH
43263: LD_INT 1
43265: NEG
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: EMPTY
43272: LIST
43273: LIST
43274: LIST
43275: LIST
43276: LIST
43277: LIST
43278: LIST
43279: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43280: LD_ADDR_VAR 0 63
43284: PUSH
43285: LD_INT 0
43287: PUSH
43288: LD_INT 0
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: PUSH
43295: LD_INT 0
43297: PUSH
43298: LD_INT 1
43300: NEG
43301: PUSH
43302: EMPTY
43303: LIST
43304: LIST
43305: PUSH
43306: LD_INT 1
43308: PUSH
43309: LD_INT 0
43311: PUSH
43312: EMPTY
43313: LIST
43314: LIST
43315: PUSH
43316: LD_INT 1
43318: PUSH
43319: LD_INT 1
43321: PUSH
43322: EMPTY
43323: LIST
43324: LIST
43325: PUSH
43326: LD_INT 0
43328: PUSH
43329: LD_INT 1
43331: PUSH
43332: EMPTY
43333: LIST
43334: LIST
43335: PUSH
43336: LD_INT 1
43338: NEG
43339: PUSH
43340: LD_INT 0
43342: PUSH
43343: EMPTY
43344: LIST
43345: LIST
43346: PUSH
43347: LD_INT 1
43349: NEG
43350: PUSH
43351: LD_INT 1
43353: NEG
43354: PUSH
43355: EMPTY
43356: LIST
43357: LIST
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: LIST
43363: LIST
43364: LIST
43365: LIST
43366: LIST
43367: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
43368: LD_ADDR_VAR 0 64
43372: PUSH
43373: LD_INT 0
43375: PUSH
43376: LD_INT 0
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 0
43385: PUSH
43386: LD_INT 1
43388: NEG
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: LD_INT 1
43396: PUSH
43397: LD_INT 0
43399: PUSH
43400: EMPTY
43401: LIST
43402: LIST
43403: PUSH
43404: LD_INT 1
43406: PUSH
43407: LD_INT 1
43409: PUSH
43410: EMPTY
43411: LIST
43412: LIST
43413: PUSH
43414: LD_INT 0
43416: PUSH
43417: LD_INT 1
43419: PUSH
43420: EMPTY
43421: LIST
43422: LIST
43423: PUSH
43424: LD_INT 1
43426: NEG
43427: PUSH
43428: LD_INT 0
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 1
43437: NEG
43438: PUSH
43439: LD_INT 1
43441: NEG
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: LIST
43451: LIST
43452: LIST
43453: LIST
43454: LIST
43455: ST_TO_ADDR
// end ; 1 :
43456: GO 49353
43458: LD_INT 1
43460: DOUBLE
43461: EQUAL
43462: IFTRUE 43466
43464: GO 46089
43466: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43467: LD_ADDR_VAR 0 11
43471: PUSH
43472: LD_INT 1
43474: NEG
43475: PUSH
43476: LD_INT 3
43478: NEG
43479: PUSH
43480: EMPTY
43481: LIST
43482: LIST
43483: PUSH
43484: LD_INT 0
43486: PUSH
43487: LD_INT 3
43489: NEG
43490: PUSH
43491: EMPTY
43492: LIST
43493: LIST
43494: PUSH
43495: LD_INT 1
43497: PUSH
43498: LD_INT 2
43500: NEG
43501: PUSH
43502: EMPTY
43503: LIST
43504: LIST
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: LIST
43510: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43511: LD_ADDR_VAR 0 12
43515: PUSH
43516: LD_INT 2
43518: PUSH
43519: LD_INT 1
43521: NEG
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PUSH
43527: LD_INT 3
43529: PUSH
43530: LD_INT 0
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: PUSH
43537: LD_INT 3
43539: PUSH
43540: LD_INT 1
43542: PUSH
43543: EMPTY
43544: LIST
43545: LIST
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: LIST
43551: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43552: LD_ADDR_VAR 0 13
43556: PUSH
43557: LD_INT 3
43559: PUSH
43560: LD_INT 2
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 3
43569: PUSH
43570: LD_INT 3
43572: PUSH
43573: EMPTY
43574: LIST
43575: LIST
43576: PUSH
43577: LD_INT 2
43579: PUSH
43580: LD_INT 3
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: LIST
43591: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43592: LD_ADDR_VAR 0 14
43596: PUSH
43597: LD_INT 1
43599: PUSH
43600: LD_INT 3
43602: PUSH
43603: EMPTY
43604: LIST
43605: LIST
43606: PUSH
43607: LD_INT 0
43609: PUSH
43610: LD_INT 3
43612: PUSH
43613: EMPTY
43614: LIST
43615: LIST
43616: PUSH
43617: LD_INT 1
43619: NEG
43620: PUSH
43621: LD_INT 2
43623: PUSH
43624: EMPTY
43625: LIST
43626: LIST
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: LIST
43632: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43633: LD_ADDR_VAR 0 15
43637: PUSH
43638: LD_INT 2
43640: NEG
43641: PUSH
43642: LD_INT 1
43644: PUSH
43645: EMPTY
43646: LIST
43647: LIST
43648: PUSH
43649: LD_INT 3
43651: NEG
43652: PUSH
43653: LD_INT 0
43655: PUSH
43656: EMPTY
43657: LIST
43658: LIST
43659: PUSH
43660: LD_INT 3
43662: NEG
43663: PUSH
43664: LD_INT 1
43666: NEG
43667: PUSH
43668: EMPTY
43669: LIST
43670: LIST
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: LIST
43676: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43677: LD_ADDR_VAR 0 16
43681: PUSH
43682: LD_INT 2
43684: NEG
43685: PUSH
43686: LD_INT 3
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 3
43696: NEG
43697: PUSH
43698: LD_INT 2
43700: NEG
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 3
43708: NEG
43709: PUSH
43710: LD_INT 3
43712: NEG
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: EMPTY
43719: LIST
43720: LIST
43721: LIST
43722: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43723: LD_ADDR_VAR 0 17
43727: PUSH
43728: LD_INT 1
43730: NEG
43731: PUSH
43732: LD_INT 3
43734: NEG
43735: PUSH
43736: EMPTY
43737: LIST
43738: LIST
43739: PUSH
43740: LD_INT 0
43742: PUSH
43743: LD_INT 3
43745: NEG
43746: PUSH
43747: EMPTY
43748: LIST
43749: LIST
43750: PUSH
43751: LD_INT 1
43753: PUSH
43754: LD_INT 2
43756: NEG
43757: PUSH
43758: EMPTY
43759: LIST
43760: LIST
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: LIST
43766: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43767: LD_ADDR_VAR 0 18
43771: PUSH
43772: LD_INT 2
43774: PUSH
43775: LD_INT 1
43777: NEG
43778: PUSH
43779: EMPTY
43780: LIST
43781: LIST
43782: PUSH
43783: LD_INT 3
43785: PUSH
43786: LD_INT 0
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: PUSH
43793: LD_INT 3
43795: PUSH
43796: LD_INT 1
43798: PUSH
43799: EMPTY
43800: LIST
43801: LIST
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: LIST
43807: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43808: LD_ADDR_VAR 0 19
43812: PUSH
43813: LD_INT 3
43815: PUSH
43816: LD_INT 2
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 3
43825: PUSH
43826: LD_INT 3
43828: PUSH
43829: EMPTY
43830: LIST
43831: LIST
43832: PUSH
43833: LD_INT 2
43835: PUSH
43836: LD_INT 3
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: EMPTY
43844: LIST
43845: LIST
43846: LIST
43847: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43848: LD_ADDR_VAR 0 20
43852: PUSH
43853: LD_INT 1
43855: PUSH
43856: LD_INT 3
43858: PUSH
43859: EMPTY
43860: LIST
43861: LIST
43862: PUSH
43863: LD_INT 0
43865: PUSH
43866: LD_INT 3
43868: PUSH
43869: EMPTY
43870: LIST
43871: LIST
43872: PUSH
43873: LD_INT 1
43875: NEG
43876: PUSH
43877: LD_INT 2
43879: PUSH
43880: EMPTY
43881: LIST
43882: LIST
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: LIST
43888: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43889: LD_ADDR_VAR 0 21
43893: PUSH
43894: LD_INT 2
43896: NEG
43897: PUSH
43898: LD_INT 1
43900: PUSH
43901: EMPTY
43902: LIST
43903: LIST
43904: PUSH
43905: LD_INT 3
43907: NEG
43908: PUSH
43909: LD_INT 0
43911: PUSH
43912: EMPTY
43913: LIST
43914: LIST
43915: PUSH
43916: LD_INT 3
43918: NEG
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: EMPTY
43929: LIST
43930: LIST
43931: LIST
43932: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43933: LD_ADDR_VAR 0 22
43937: PUSH
43938: LD_INT 2
43940: NEG
43941: PUSH
43942: LD_INT 3
43944: NEG
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 3
43952: NEG
43953: PUSH
43954: LD_INT 2
43956: NEG
43957: PUSH
43958: EMPTY
43959: LIST
43960: LIST
43961: PUSH
43962: LD_INT 3
43964: NEG
43965: PUSH
43966: LD_INT 3
43968: NEG
43969: PUSH
43970: EMPTY
43971: LIST
43972: LIST
43973: PUSH
43974: EMPTY
43975: LIST
43976: LIST
43977: LIST
43978: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
43979: LD_ADDR_VAR 0 23
43983: PUSH
43984: LD_INT 0
43986: PUSH
43987: LD_INT 3
43989: NEG
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 1
43997: NEG
43998: PUSH
43999: LD_INT 4
44001: NEG
44002: PUSH
44003: EMPTY
44004: LIST
44005: LIST
44006: PUSH
44007: LD_INT 1
44009: PUSH
44010: LD_INT 3
44012: NEG
44013: PUSH
44014: EMPTY
44015: LIST
44016: LIST
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: LIST
44022: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
44023: LD_ADDR_VAR 0 24
44027: PUSH
44028: LD_INT 3
44030: PUSH
44031: LD_INT 0
44033: PUSH
44034: EMPTY
44035: LIST
44036: LIST
44037: PUSH
44038: LD_INT 3
44040: PUSH
44041: LD_INT 1
44043: NEG
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 4
44051: PUSH
44052: LD_INT 1
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: EMPTY
44060: LIST
44061: LIST
44062: LIST
44063: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
44064: LD_ADDR_VAR 0 25
44068: PUSH
44069: LD_INT 3
44071: PUSH
44072: LD_INT 3
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 4
44081: PUSH
44082: LD_INT 3
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 3
44091: PUSH
44092: LD_INT 4
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: LIST
44103: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
44104: LD_ADDR_VAR 0 26
44108: PUSH
44109: LD_INT 0
44111: PUSH
44112: LD_INT 3
44114: PUSH
44115: EMPTY
44116: LIST
44117: LIST
44118: PUSH
44119: LD_INT 1
44121: PUSH
44122: LD_INT 4
44124: PUSH
44125: EMPTY
44126: LIST
44127: LIST
44128: PUSH
44129: LD_INT 1
44131: NEG
44132: PUSH
44133: LD_INT 3
44135: PUSH
44136: EMPTY
44137: LIST
44138: LIST
44139: PUSH
44140: EMPTY
44141: LIST
44142: LIST
44143: LIST
44144: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
44145: LD_ADDR_VAR 0 27
44149: PUSH
44150: LD_INT 3
44152: NEG
44153: PUSH
44154: LD_INT 0
44156: PUSH
44157: EMPTY
44158: LIST
44159: LIST
44160: PUSH
44161: LD_INT 3
44163: NEG
44164: PUSH
44165: LD_INT 1
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 4
44174: NEG
44175: PUSH
44176: LD_INT 1
44178: NEG
44179: PUSH
44180: EMPTY
44181: LIST
44182: LIST
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: LIST
44188: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
44189: LD_ADDR_VAR 0 28
44193: PUSH
44194: LD_INT 3
44196: NEG
44197: PUSH
44198: LD_INT 3
44200: NEG
44201: PUSH
44202: EMPTY
44203: LIST
44204: LIST
44205: PUSH
44206: LD_INT 3
44208: NEG
44209: PUSH
44210: LD_INT 4
44212: NEG
44213: PUSH
44214: EMPTY
44215: LIST
44216: LIST
44217: PUSH
44218: LD_INT 4
44220: NEG
44221: PUSH
44222: LD_INT 3
44224: NEG
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: LIST
44234: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
44235: LD_ADDR_VAR 0 29
44239: PUSH
44240: LD_INT 1
44242: NEG
44243: PUSH
44244: LD_INT 3
44246: NEG
44247: PUSH
44248: EMPTY
44249: LIST
44250: LIST
44251: PUSH
44252: LD_INT 0
44254: PUSH
44255: LD_INT 3
44257: NEG
44258: PUSH
44259: EMPTY
44260: LIST
44261: LIST
44262: PUSH
44263: LD_INT 1
44265: PUSH
44266: LD_INT 2
44268: NEG
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: PUSH
44274: LD_INT 1
44276: NEG
44277: PUSH
44278: LD_INT 4
44280: NEG
44281: PUSH
44282: EMPTY
44283: LIST
44284: LIST
44285: PUSH
44286: LD_INT 0
44288: PUSH
44289: LD_INT 4
44291: NEG
44292: PUSH
44293: EMPTY
44294: LIST
44295: LIST
44296: PUSH
44297: LD_INT 1
44299: PUSH
44300: LD_INT 3
44302: NEG
44303: PUSH
44304: EMPTY
44305: LIST
44306: LIST
44307: PUSH
44308: LD_INT 1
44310: NEG
44311: PUSH
44312: LD_INT 5
44314: NEG
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 0
44322: PUSH
44323: LD_INT 5
44325: NEG
44326: PUSH
44327: EMPTY
44328: LIST
44329: LIST
44330: PUSH
44331: LD_INT 1
44333: PUSH
44334: LD_INT 4
44336: NEG
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PUSH
44342: LD_INT 1
44344: NEG
44345: PUSH
44346: LD_INT 6
44348: NEG
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: LD_INT 0
44356: PUSH
44357: LD_INT 6
44359: NEG
44360: PUSH
44361: EMPTY
44362: LIST
44363: LIST
44364: PUSH
44365: LD_INT 1
44367: PUSH
44368: LD_INT 5
44370: NEG
44371: PUSH
44372: EMPTY
44373: LIST
44374: LIST
44375: PUSH
44376: EMPTY
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
44390: LD_ADDR_VAR 0 30
44394: PUSH
44395: LD_INT 2
44397: PUSH
44398: LD_INT 1
44400: NEG
44401: PUSH
44402: EMPTY
44403: LIST
44404: LIST
44405: PUSH
44406: LD_INT 3
44408: PUSH
44409: LD_INT 0
44411: PUSH
44412: EMPTY
44413: LIST
44414: LIST
44415: PUSH
44416: LD_INT 3
44418: PUSH
44419: LD_INT 1
44421: PUSH
44422: EMPTY
44423: LIST
44424: LIST
44425: PUSH
44426: LD_INT 3
44428: PUSH
44429: LD_INT 1
44431: NEG
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: LD_INT 4
44439: PUSH
44440: LD_INT 0
44442: PUSH
44443: EMPTY
44444: LIST
44445: LIST
44446: PUSH
44447: LD_INT 4
44449: PUSH
44450: LD_INT 1
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 4
44459: PUSH
44460: LD_INT 1
44462: NEG
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 5
44470: PUSH
44471: LD_INT 0
44473: PUSH
44474: EMPTY
44475: LIST
44476: LIST
44477: PUSH
44478: LD_INT 5
44480: PUSH
44481: LD_INT 1
44483: PUSH
44484: EMPTY
44485: LIST
44486: LIST
44487: PUSH
44488: LD_INT 5
44490: PUSH
44491: LD_INT 1
44493: NEG
44494: PUSH
44495: EMPTY
44496: LIST
44497: LIST
44498: PUSH
44499: LD_INT 6
44501: PUSH
44502: LD_INT 0
44504: PUSH
44505: EMPTY
44506: LIST
44507: LIST
44508: PUSH
44509: LD_INT 6
44511: PUSH
44512: LD_INT 1
44514: PUSH
44515: EMPTY
44516: LIST
44517: LIST
44518: PUSH
44519: EMPTY
44520: LIST
44521: LIST
44522: LIST
44523: LIST
44524: LIST
44525: LIST
44526: LIST
44527: LIST
44528: LIST
44529: LIST
44530: LIST
44531: LIST
44532: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
44533: LD_ADDR_VAR 0 31
44537: PUSH
44538: LD_INT 3
44540: PUSH
44541: LD_INT 2
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 3
44550: PUSH
44551: LD_INT 3
44553: PUSH
44554: EMPTY
44555: LIST
44556: LIST
44557: PUSH
44558: LD_INT 2
44560: PUSH
44561: LD_INT 3
44563: PUSH
44564: EMPTY
44565: LIST
44566: LIST
44567: PUSH
44568: LD_INT 4
44570: PUSH
44571: LD_INT 3
44573: PUSH
44574: EMPTY
44575: LIST
44576: LIST
44577: PUSH
44578: LD_INT 4
44580: PUSH
44581: LD_INT 4
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 3
44590: PUSH
44591: LD_INT 4
44593: PUSH
44594: EMPTY
44595: LIST
44596: LIST
44597: PUSH
44598: LD_INT 5
44600: PUSH
44601: LD_INT 4
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 5
44610: PUSH
44611: LD_INT 5
44613: PUSH
44614: EMPTY
44615: LIST
44616: LIST
44617: PUSH
44618: LD_INT 4
44620: PUSH
44621: LD_INT 5
44623: PUSH
44624: EMPTY
44625: LIST
44626: LIST
44627: PUSH
44628: LD_INT 6
44630: PUSH
44631: LD_INT 5
44633: PUSH
44634: EMPTY
44635: LIST
44636: LIST
44637: PUSH
44638: LD_INT 6
44640: PUSH
44641: LD_INT 6
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 5
44650: PUSH
44651: LD_INT 6
44653: PUSH
44654: EMPTY
44655: LIST
44656: LIST
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: LIST
44662: LIST
44663: LIST
44664: LIST
44665: LIST
44666: LIST
44667: LIST
44668: LIST
44669: LIST
44670: LIST
44671: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
44672: LD_ADDR_VAR 0 32
44676: PUSH
44677: LD_INT 1
44679: PUSH
44680: LD_INT 3
44682: PUSH
44683: EMPTY
44684: LIST
44685: LIST
44686: PUSH
44687: LD_INT 0
44689: PUSH
44690: LD_INT 3
44692: PUSH
44693: EMPTY
44694: LIST
44695: LIST
44696: PUSH
44697: LD_INT 1
44699: NEG
44700: PUSH
44701: LD_INT 2
44703: PUSH
44704: EMPTY
44705: LIST
44706: LIST
44707: PUSH
44708: LD_INT 1
44710: PUSH
44711: LD_INT 4
44713: PUSH
44714: EMPTY
44715: LIST
44716: LIST
44717: PUSH
44718: LD_INT 0
44720: PUSH
44721: LD_INT 4
44723: PUSH
44724: EMPTY
44725: LIST
44726: LIST
44727: PUSH
44728: LD_INT 1
44730: NEG
44731: PUSH
44732: LD_INT 3
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 1
44741: PUSH
44742: LD_INT 5
44744: PUSH
44745: EMPTY
44746: LIST
44747: LIST
44748: PUSH
44749: LD_INT 0
44751: PUSH
44752: LD_INT 5
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: LD_INT 1
44761: NEG
44762: PUSH
44763: LD_INT 4
44765: PUSH
44766: EMPTY
44767: LIST
44768: LIST
44769: PUSH
44770: LD_INT 1
44772: PUSH
44773: LD_INT 6
44775: PUSH
44776: EMPTY
44777: LIST
44778: LIST
44779: PUSH
44780: LD_INT 0
44782: PUSH
44783: LD_INT 6
44785: PUSH
44786: EMPTY
44787: LIST
44788: LIST
44789: PUSH
44790: LD_INT 1
44792: NEG
44793: PUSH
44794: LD_INT 5
44796: PUSH
44797: EMPTY
44798: LIST
44799: LIST
44800: PUSH
44801: EMPTY
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
44815: LD_ADDR_VAR 0 33
44819: PUSH
44820: LD_INT 2
44822: NEG
44823: PUSH
44824: LD_INT 1
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 3
44833: NEG
44834: PUSH
44835: LD_INT 0
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 3
44844: NEG
44845: PUSH
44846: LD_INT 1
44848: NEG
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PUSH
44854: LD_INT 3
44856: NEG
44857: PUSH
44858: LD_INT 1
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 4
44867: NEG
44868: PUSH
44869: LD_INT 0
44871: PUSH
44872: EMPTY
44873: LIST
44874: LIST
44875: PUSH
44876: LD_INT 4
44878: NEG
44879: PUSH
44880: LD_INT 1
44882: NEG
44883: PUSH
44884: EMPTY
44885: LIST
44886: LIST
44887: PUSH
44888: LD_INT 4
44890: NEG
44891: PUSH
44892: LD_INT 1
44894: PUSH
44895: EMPTY
44896: LIST
44897: LIST
44898: PUSH
44899: LD_INT 5
44901: NEG
44902: PUSH
44903: LD_INT 0
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 5
44912: NEG
44913: PUSH
44914: LD_INT 1
44916: NEG
44917: PUSH
44918: EMPTY
44919: LIST
44920: LIST
44921: PUSH
44922: LD_INT 5
44924: NEG
44925: PUSH
44926: LD_INT 1
44928: PUSH
44929: EMPTY
44930: LIST
44931: LIST
44932: PUSH
44933: LD_INT 6
44935: NEG
44936: PUSH
44937: LD_INT 0
44939: PUSH
44940: EMPTY
44941: LIST
44942: LIST
44943: PUSH
44944: LD_INT 6
44946: NEG
44947: PUSH
44948: LD_INT 1
44950: NEG
44951: PUSH
44952: EMPTY
44953: LIST
44954: LIST
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: LIST
44960: LIST
44961: LIST
44962: LIST
44963: LIST
44964: LIST
44965: LIST
44966: LIST
44967: LIST
44968: LIST
44969: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
44970: LD_ADDR_VAR 0 34
44974: PUSH
44975: LD_INT 2
44977: NEG
44978: PUSH
44979: LD_INT 3
44981: NEG
44982: PUSH
44983: EMPTY
44984: LIST
44985: LIST
44986: PUSH
44987: LD_INT 3
44989: NEG
44990: PUSH
44991: LD_INT 2
44993: NEG
44994: PUSH
44995: EMPTY
44996: LIST
44997: LIST
44998: PUSH
44999: LD_INT 3
45001: NEG
45002: PUSH
45003: LD_INT 3
45005: NEG
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 3
45013: NEG
45014: PUSH
45015: LD_INT 4
45017: NEG
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 4
45025: NEG
45026: PUSH
45027: LD_INT 3
45029: NEG
45030: PUSH
45031: EMPTY
45032: LIST
45033: LIST
45034: PUSH
45035: LD_INT 4
45037: NEG
45038: PUSH
45039: LD_INT 4
45041: NEG
45042: PUSH
45043: EMPTY
45044: LIST
45045: LIST
45046: PUSH
45047: LD_INT 4
45049: NEG
45050: PUSH
45051: LD_INT 5
45053: NEG
45054: PUSH
45055: EMPTY
45056: LIST
45057: LIST
45058: PUSH
45059: LD_INT 5
45061: NEG
45062: PUSH
45063: LD_INT 4
45065: NEG
45066: PUSH
45067: EMPTY
45068: LIST
45069: LIST
45070: PUSH
45071: LD_INT 5
45073: NEG
45074: PUSH
45075: LD_INT 5
45077: NEG
45078: PUSH
45079: EMPTY
45080: LIST
45081: LIST
45082: PUSH
45083: LD_INT 5
45085: NEG
45086: PUSH
45087: LD_INT 6
45089: NEG
45090: PUSH
45091: EMPTY
45092: LIST
45093: LIST
45094: PUSH
45095: LD_INT 6
45097: NEG
45098: PUSH
45099: LD_INT 5
45101: NEG
45102: PUSH
45103: EMPTY
45104: LIST
45105: LIST
45106: PUSH
45107: LD_INT 6
45109: NEG
45110: PUSH
45111: LD_INT 6
45113: NEG
45114: PUSH
45115: EMPTY
45116: LIST
45117: LIST
45118: PUSH
45119: EMPTY
45120: LIST
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
45133: LD_ADDR_VAR 0 41
45137: PUSH
45138: LD_INT 0
45140: PUSH
45141: LD_INT 2
45143: NEG
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: PUSH
45149: LD_INT 1
45151: NEG
45152: PUSH
45153: LD_INT 3
45155: NEG
45156: PUSH
45157: EMPTY
45158: LIST
45159: LIST
45160: PUSH
45161: LD_INT 1
45163: PUSH
45164: LD_INT 2
45166: NEG
45167: PUSH
45168: EMPTY
45169: LIST
45170: LIST
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: LIST
45176: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
45177: LD_ADDR_VAR 0 42
45181: PUSH
45182: LD_INT 2
45184: PUSH
45185: LD_INT 0
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 2
45194: PUSH
45195: LD_INT 1
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 3
45205: PUSH
45206: LD_INT 1
45208: PUSH
45209: EMPTY
45210: LIST
45211: LIST
45212: PUSH
45213: EMPTY
45214: LIST
45215: LIST
45216: LIST
45217: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
45218: LD_ADDR_VAR 0 43
45222: PUSH
45223: LD_INT 2
45225: PUSH
45226: LD_INT 2
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: PUSH
45233: LD_INT 3
45235: PUSH
45236: LD_INT 2
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: PUSH
45243: LD_INT 2
45245: PUSH
45246: LD_INT 3
45248: PUSH
45249: EMPTY
45250: LIST
45251: LIST
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: LIST
45257: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
45258: LD_ADDR_VAR 0 44
45262: PUSH
45263: LD_INT 0
45265: PUSH
45266: LD_INT 2
45268: PUSH
45269: EMPTY
45270: LIST
45271: LIST
45272: PUSH
45273: LD_INT 1
45275: PUSH
45276: LD_INT 3
45278: PUSH
45279: EMPTY
45280: LIST
45281: LIST
45282: PUSH
45283: LD_INT 1
45285: NEG
45286: PUSH
45287: LD_INT 2
45289: PUSH
45290: EMPTY
45291: LIST
45292: LIST
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: LIST
45298: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
45299: LD_ADDR_VAR 0 45
45303: PUSH
45304: LD_INT 2
45306: NEG
45307: PUSH
45308: LD_INT 0
45310: PUSH
45311: EMPTY
45312: LIST
45313: LIST
45314: PUSH
45315: LD_INT 2
45317: NEG
45318: PUSH
45319: LD_INT 1
45321: PUSH
45322: EMPTY
45323: LIST
45324: LIST
45325: PUSH
45326: LD_INT 3
45328: NEG
45329: PUSH
45330: LD_INT 1
45332: NEG
45333: PUSH
45334: EMPTY
45335: LIST
45336: LIST
45337: PUSH
45338: EMPTY
45339: LIST
45340: LIST
45341: LIST
45342: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
45343: LD_ADDR_VAR 0 46
45347: PUSH
45348: LD_INT 2
45350: NEG
45351: PUSH
45352: LD_INT 2
45354: NEG
45355: PUSH
45356: EMPTY
45357: LIST
45358: LIST
45359: PUSH
45360: LD_INT 2
45362: NEG
45363: PUSH
45364: LD_INT 3
45366: NEG
45367: PUSH
45368: EMPTY
45369: LIST
45370: LIST
45371: PUSH
45372: LD_INT 3
45374: NEG
45375: PUSH
45376: LD_INT 2
45378: NEG
45379: PUSH
45380: EMPTY
45381: LIST
45382: LIST
45383: PUSH
45384: EMPTY
45385: LIST
45386: LIST
45387: LIST
45388: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
45389: LD_ADDR_VAR 0 47
45393: PUSH
45394: LD_INT 2
45396: NEG
45397: PUSH
45398: LD_INT 3
45400: NEG
45401: PUSH
45402: EMPTY
45403: LIST
45404: LIST
45405: PUSH
45406: LD_INT 1
45408: NEG
45409: PUSH
45410: LD_INT 3
45412: NEG
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PUSH
45418: EMPTY
45419: LIST
45420: LIST
45421: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
45422: LD_ADDR_VAR 0 48
45426: PUSH
45427: LD_INT 1
45429: PUSH
45430: LD_INT 2
45432: NEG
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: LD_INT 2
45440: PUSH
45441: LD_INT 1
45443: NEG
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: EMPTY
45450: LIST
45451: LIST
45452: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
45453: LD_ADDR_VAR 0 49
45457: PUSH
45458: LD_INT 3
45460: PUSH
45461: LD_INT 1
45463: PUSH
45464: EMPTY
45465: LIST
45466: LIST
45467: PUSH
45468: LD_INT 3
45470: PUSH
45471: LD_INT 2
45473: PUSH
45474: EMPTY
45475: LIST
45476: LIST
45477: PUSH
45478: EMPTY
45479: LIST
45480: LIST
45481: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
45482: LD_ADDR_VAR 0 50
45486: PUSH
45487: LD_INT 2
45489: PUSH
45490: LD_INT 3
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: PUSH
45497: LD_INT 1
45499: PUSH
45500: LD_INT 3
45502: PUSH
45503: EMPTY
45504: LIST
45505: LIST
45506: PUSH
45507: EMPTY
45508: LIST
45509: LIST
45510: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
45511: LD_ADDR_VAR 0 51
45515: PUSH
45516: LD_INT 1
45518: NEG
45519: PUSH
45520: LD_INT 2
45522: PUSH
45523: EMPTY
45524: LIST
45525: LIST
45526: PUSH
45527: LD_INT 2
45529: NEG
45530: PUSH
45531: LD_INT 1
45533: PUSH
45534: EMPTY
45535: LIST
45536: LIST
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
45542: LD_ADDR_VAR 0 52
45546: PUSH
45547: LD_INT 3
45549: NEG
45550: PUSH
45551: LD_INT 1
45553: NEG
45554: PUSH
45555: EMPTY
45556: LIST
45557: LIST
45558: PUSH
45559: LD_INT 3
45561: NEG
45562: PUSH
45563: LD_INT 2
45565: NEG
45566: PUSH
45567: EMPTY
45568: LIST
45569: LIST
45570: PUSH
45571: EMPTY
45572: LIST
45573: LIST
45574: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
45575: LD_ADDR_VAR 0 53
45579: PUSH
45580: LD_INT 1
45582: NEG
45583: PUSH
45584: LD_INT 3
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 0
45594: PUSH
45595: LD_INT 3
45597: NEG
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: PUSH
45603: LD_INT 1
45605: PUSH
45606: LD_INT 2
45608: NEG
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: EMPTY
45615: LIST
45616: LIST
45617: LIST
45618: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
45619: LD_ADDR_VAR 0 54
45623: PUSH
45624: LD_INT 2
45626: PUSH
45627: LD_INT 1
45629: NEG
45630: PUSH
45631: EMPTY
45632: LIST
45633: LIST
45634: PUSH
45635: LD_INT 3
45637: PUSH
45638: LD_INT 0
45640: PUSH
45641: EMPTY
45642: LIST
45643: LIST
45644: PUSH
45645: LD_INT 3
45647: PUSH
45648: LD_INT 1
45650: PUSH
45651: EMPTY
45652: LIST
45653: LIST
45654: PUSH
45655: EMPTY
45656: LIST
45657: LIST
45658: LIST
45659: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
45660: LD_ADDR_VAR 0 55
45664: PUSH
45665: LD_INT 3
45667: PUSH
45668: LD_INT 2
45670: PUSH
45671: EMPTY
45672: LIST
45673: LIST
45674: PUSH
45675: LD_INT 3
45677: PUSH
45678: LD_INT 3
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 2
45687: PUSH
45688: LD_INT 3
45690: PUSH
45691: EMPTY
45692: LIST
45693: LIST
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: LIST
45699: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
45700: LD_ADDR_VAR 0 56
45704: PUSH
45705: LD_INT 1
45707: PUSH
45708: LD_INT 3
45710: PUSH
45711: EMPTY
45712: LIST
45713: LIST
45714: PUSH
45715: LD_INT 0
45717: PUSH
45718: LD_INT 3
45720: PUSH
45721: EMPTY
45722: LIST
45723: LIST
45724: PUSH
45725: LD_INT 1
45727: NEG
45728: PUSH
45729: LD_INT 2
45731: PUSH
45732: EMPTY
45733: LIST
45734: LIST
45735: PUSH
45736: EMPTY
45737: LIST
45738: LIST
45739: LIST
45740: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
45741: LD_ADDR_VAR 0 57
45745: PUSH
45746: LD_INT 2
45748: NEG
45749: PUSH
45750: LD_INT 1
45752: PUSH
45753: EMPTY
45754: LIST
45755: LIST
45756: PUSH
45757: LD_INT 3
45759: NEG
45760: PUSH
45761: LD_INT 0
45763: PUSH
45764: EMPTY
45765: LIST
45766: LIST
45767: PUSH
45768: LD_INT 3
45770: NEG
45771: PUSH
45772: LD_INT 1
45774: NEG
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: EMPTY
45781: LIST
45782: LIST
45783: LIST
45784: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
45785: LD_ADDR_VAR 0 58
45789: PUSH
45790: LD_INT 2
45792: NEG
45793: PUSH
45794: LD_INT 3
45796: NEG
45797: PUSH
45798: EMPTY
45799: LIST
45800: LIST
45801: PUSH
45802: LD_INT 3
45804: NEG
45805: PUSH
45806: LD_INT 2
45808: NEG
45809: PUSH
45810: EMPTY
45811: LIST
45812: LIST
45813: PUSH
45814: LD_INT 3
45816: NEG
45817: PUSH
45818: LD_INT 3
45820: NEG
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: EMPTY
45827: LIST
45828: LIST
45829: LIST
45830: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
45831: LD_ADDR_VAR 0 59
45835: PUSH
45836: LD_INT 1
45838: NEG
45839: PUSH
45840: LD_INT 2
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 0
45850: PUSH
45851: LD_INT 2
45853: NEG
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 1
45861: PUSH
45862: LD_INT 1
45864: NEG
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: LIST
45874: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
45875: LD_ADDR_VAR 0 60
45879: PUSH
45880: LD_INT 1
45882: PUSH
45883: LD_INT 1
45885: NEG
45886: PUSH
45887: EMPTY
45888: LIST
45889: LIST
45890: PUSH
45891: LD_INT 2
45893: PUSH
45894: LD_INT 0
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: PUSH
45901: LD_INT 2
45903: PUSH
45904: LD_INT 1
45906: PUSH
45907: EMPTY
45908: LIST
45909: LIST
45910: PUSH
45911: EMPTY
45912: LIST
45913: LIST
45914: LIST
45915: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
45916: LD_ADDR_VAR 0 61
45920: PUSH
45921: LD_INT 2
45923: PUSH
45924: LD_INT 1
45926: PUSH
45927: EMPTY
45928: LIST
45929: LIST
45930: PUSH
45931: LD_INT 2
45933: PUSH
45934: LD_INT 2
45936: PUSH
45937: EMPTY
45938: LIST
45939: LIST
45940: PUSH
45941: LD_INT 1
45943: PUSH
45944: LD_INT 2
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: PUSH
45951: EMPTY
45952: LIST
45953: LIST
45954: LIST
45955: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
45956: LD_ADDR_VAR 0 62
45960: PUSH
45961: LD_INT 1
45963: PUSH
45964: LD_INT 2
45966: PUSH
45967: EMPTY
45968: LIST
45969: LIST
45970: PUSH
45971: LD_INT 0
45973: PUSH
45974: LD_INT 2
45976: PUSH
45977: EMPTY
45978: LIST
45979: LIST
45980: PUSH
45981: LD_INT 1
45983: NEG
45984: PUSH
45985: LD_INT 1
45987: PUSH
45988: EMPTY
45989: LIST
45990: LIST
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: LIST
45996: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
45997: LD_ADDR_VAR 0 63
46001: PUSH
46002: LD_INT 1
46004: NEG
46005: PUSH
46006: LD_INT 1
46008: PUSH
46009: EMPTY
46010: LIST
46011: LIST
46012: PUSH
46013: LD_INT 2
46015: NEG
46016: PUSH
46017: LD_INT 0
46019: PUSH
46020: EMPTY
46021: LIST
46022: LIST
46023: PUSH
46024: LD_INT 2
46026: NEG
46027: PUSH
46028: LD_INT 1
46030: NEG
46031: PUSH
46032: EMPTY
46033: LIST
46034: LIST
46035: PUSH
46036: EMPTY
46037: LIST
46038: LIST
46039: LIST
46040: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
46041: LD_ADDR_VAR 0 64
46045: PUSH
46046: LD_INT 1
46048: NEG
46049: PUSH
46050: LD_INT 2
46052: NEG
46053: PUSH
46054: EMPTY
46055: LIST
46056: LIST
46057: PUSH
46058: LD_INT 2
46060: NEG
46061: PUSH
46062: LD_INT 1
46064: NEG
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 2
46072: NEG
46073: PUSH
46074: LD_INT 2
46076: NEG
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: LIST
46086: ST_TO_ADDR
// end ; 2 :
46087: GO 49353
46089: LD_INT 2
46091: DOUBLE
46092: EQUAL
46093: IFTRUE 46097
46095: GO 49352
46097: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
46098: LD_ADDR_VAR 0 29
46102: PUSH
46103: LD_INT 4
46105: PUSH
46106: LD_INT 0
46108: PUSH
46109: EMPTY
46110: LIST
46111: LIST
46112: PUSH
46113: LD_INT 4
46115: PUSH
46116: LD_INT 1
46118: NEG
46119: PUSH
46120: EMPTY
46121: LIST
46122: LIST
46123: PUSH
46124: LD_INT 5
46126: PUSH
46127: LD_INT 0
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 5
46136: PUSH
46137: LD_INT 1
46139: PUSH
46140: EMPTY
46141: LIST
46142: LIST
46143: PUSH
46144: LD_INT 4
46146: PUSH
46147: LD_INT 1
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: PUSH
46154: LD_INT 3
46156: PUSH
46157: LD_INT 0
46159: PUSH
46160: EMPTY
46161: LIST
46162: LIST
46163: PUSH
46164: LD_INT 3
46166: PUSH
46167: LD_INT 1
46169: NEG
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: PUSH
46175: LD_INT 3
46177: PUSH
46178: LD_INT 2
46180: NEG
46181: PUSH
46182: EMPTY
46183: LIST
46184: LIST
46185: PUSH
46186: LD_INT 5
46188: PUSH
46189: LD_INT 2
46191: PUSH
46192: EMPTY
46193: LIST
46194: LIST
46195: PUSH
46196: LD_INT 3
46198: PUSH
46199: LD_INT 3
46201: PUSH
46202: EMPTY
46203: LIST
46204: LIST
46205: PUSH
46206: LD_INT 3
46208: PUSH
46209: LD_INT 2
46211: PUSH
46212: EMPTY
46213: LIST
46214: LIST
46215: PUSH
46216: LD_INT 4
46218: PUSH
46219: LD_INT 3
46221: PUSH
46222: EMPTY
46223: LIST
46224: LIST
46225: PUSH
46226: LD_INT 4
46228: PUSH
46229: LD_INT 4
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 3
46238: PUSH
46239: LD_INT 4
46241: PUSH
46242: EMPTY
46243: LIST
46244: LIST
46245: PUSH
46246: LD_INT 2
46248: PUSH
46249: LD_INT 3
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 2
46258: PUSH
46259: LD_INT 2
46261: PUSH
46262: EMPTY
46263: LIST
46264: LIST
46265: PUSH
46266: LD_INT 4
46268: PUSH
46269: LD_INT 2
46271: PUSH
46272: EMPTY
46273: LIST
46274: LIST
46275: PUSH
46276: LD_INT 2
46278: PUSH
46279: LD_INT 4
46281: PUSH
46282: EMPTY
46283: LIST
46284: LIST
46285: PUSH
46286: LD_INT 0
46288: PUSH
46289: LD_INT 4
46291: PUSH
46292: EMPTY
46293: LIST
46294: LIST
46295: PUSH
46296: LD_INT 0
46298: PUSH
46299: LD_INT 3
46301: PUSH
46302: EMPTY
46303: LIST
46304: LIST
46305: PUSH
46306: LD_INT 1
46308: PUSH
46309: LD_INT 4
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 1
46318: PUSH
46319: LD_INT 5
46321: PUSH
46322: EMPTY
46323: LIST
46324: LIST
46325: PUSH
46326: LD_INT 0
46328: PUSH
46329: LD_INT 5
46331: PUSH
46332: EMPTY
46333: LIST
46334: LIST
46335: PUSH
46336: LD_INT 1
46338: NEG
46339: PUSH
46340: LD_INT 4
46342: PUSH
46343: EMPTY
46344: LIST
46345: LIST
46346: PUSH
46347: LD_INT 1
46349: NEG
46350: PUSH
46351: LD_INT 3
46353: PUSH
46354: EMPTY
46355: LIST
46356: LIST
46357: PUSH
46358: LD_INT 2
46360: PUSH
46361: LD_INT 5
46363: PUSH
46364: EMPTY
46365: LIST
46366: LIST
46367: PUSH
46368: LD_INT 2
46370: NEG
46371: PUSH
46372: LD_INT 3
46374: PUSH
46375: EMPTY
46376: LIST
46377: LIST
46378: PUSH
46379: LD_INT 3
46381: NEG
46382: PUSH
46383: LD_INT 0
46385: PUSH
46386: EMPTY
46387: LIST
46388: LIST
46389: PUSH
46390: LD_INT 3
46392: NEG
46393: PUSH
46394: LD_INT 1
46396: NEG
46397: PUSH
46398: EMPTY
46399: LIST
46400: LIST
46401: PUSH
46402: LD_INT 2
46404: NEG
46405: PUSH
46406: LD_INT 0
46408: PUSH
46409: EMPTY
46410: LIST
46411: LIST
46412: PUSH
46413: LD_INT 2
46415: NEG
46416: PUSH
46417: LD_INT 1
46419: PUSH
46420: EMPTY
46421: LIST
46422: LIST
46423: PUSH
46424: LD_INT 3
46426: NEG
46427: PUSH
46428: LD_INT 1
46430: PUSH
46431: EMPTY
46432: LIST
46433: LIST
46434: PUSH
46435: LD_INT 4
46437: NEG
46438: PUSH
46439: LD_INT 0
46441: PUSH
46442: EMPTY
46443: LIST
46444: LIST
46445: PUSH
46446: LD_INT 4
46448: NEG
46449: PUSH
46450: LD_INT 1
46452: NEG
46453: PUSH
46454: EMPTY
46455: LIST
46456: LIST
46457: PUSH
46458: LD_INT 4
46460: NEG
46461: PUSH
46462: LD_INT 2
46464: NEG
46465: PUSH
46466: EMPTY
46467: LIST
46468: LIST
46469: PUSH
46470: LD_INT 2
46472: NEG
46473: PUSH
46474: LD_INT 2
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 4
46483: NEG
46484: PUSH
46485: LD_INT 4
46487: NEG
46488: PUSH
46489: EMPTY
46490: LIST
46491: LIST
46492: PUSH
46493: LD_INT 4
46495: NEG
46496: PUSH
46497: LD_INT 5
46499: NEG
46500: PUSH
46501: EMPTY
46502: LIST
46503: LIST
46504: PUSH
46505: LD_INT 3
46507: NEG
46508: PUSH
46509: LD_INT 4
46511: NEG
46512: PUSH
46513: EMPTY
46514: LIST
46515: LIST
46516: PUSH
46517: LD_INT 3
46519: NEG
46520: PUSH
46521: LD_INT 3
46523: NEG
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: PUSH
46529: LD_INT 4
46531: NEG
46532: PUSH
46533: LD_INT 3
46535: NEG
46536: PUSH
46537: EMPTY
46538: LIST
46539: LIST
46540: PUSH
46541: LD_INT 5
46543: NEG
46544: PUSH
46545: LD_INT 4
46547: NEG
46548: PUSH
46549: EMPTY
46550: LIST
46551: LIST
46552: PUSH
46553: LD_INT 5
46555: NEG
46556: PUSH
46557: LD_INT 5
46559: NEG
46560: PUSH
46561: EMPTY
46562: LIST
46563: LIST
46564: PUSH
46565: LD_INT 3
46567: NEG
46568: PUSH
46569: LD_INT 5
46571: NEG
46572: PUSH
46573: EMPTY
46574: LIST
46575: LIST
46576: PUSH
46577: LD_INT 5
46579: NEG
46580: PUSH
46581: LD_INT 3
46583: NEG
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: PUSH
46589: EMPTY
46590: LIST
46591: LIST
46592: LIST
46593: LIST
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: LIST
46599: LIST
46600: LIST
46601: LIST
46602: LIST
46603: LIST
46604: LIST
46605: LIST
46606: LIST
46607: LIST
46608: LIST
46609: LIST
46610: LIST
46611: LIST
46612: LIST
46613: LIST
46614: LIST
46615: LIST
46616: LIST
46617: LIST
46618: LIST
46619: LIST
46620: LIST
46621: LIST
46622: LIST
46623: LIST
46624: LIST
46625: LIST
46626: LIST
46627: LIST
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: LIST
46635: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
46636: LD_ADDR_VAR 0 30
46640: PUSH
46641: LD_INT 4
46643: PUSH
46644: LD_INT 4
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 4
46653: PUSH
46654: LD_INT 3
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: LD_INT 5
46663: PUSH
46664: LD_INT 4
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: PUSH
46671: LD_INT 5
46673: PUSH
46674: LD_INT 5
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: LD_INT 4
46683: PUSH
46684: LD_INT 5
46686: PUSH
46687: EMPTY
46688: LIST
46689: LIST
46690: PUSH
46691: LD_INT 3
46693: PUSH
46694: LD_INT 4
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 3
46703: PUSH
46704: LD_INT 3
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: PUSH
46711: LD_INT 5
46713: PUSH
46714: LD_INT 3
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 3
46723: PUSH
46724: LD_INT 5
46726: PUSH
46727: EMPTY
46728: LIST
46729: LIST
46730: PUSH
46731: LD_INT 0
46733: PUSH
46734: LD_INT 3
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: PUSH
46741: LD_INT 0
46743: PUSH
46744: LD_INT 2
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 1
46753: PUSH
46754: LD_INT 3
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: LD_INT 1
46763: PUSH
46764: LD_INT 4
46766: PUSH
46767: EMPTY
46768: LIST
46769: LIST
46770: PUSH
46771: LD_INT 0
46773: PUSH
46774: LD_INT 4
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 1
46783: NEG
46784: PUSH
46785: LD_INT 3
46787: PUSH
46788: EMPTY
46789: LIST
46790: LIST
46791: PUSH
46792: LD_INT 1
46794: NEG
46795: PUSH
46796: LD_INT 2
46798: PUSH
46799: EMPTY
46800: LIST
46801: LIST
46802: PUSH
46803: LD_INT 2
46805: PUSH
46806: LD_INT 4
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: PUSH
46813: LD_INT 2
46815: NEG
46816: PUSH
46817: LD_INT 2
46819: PUSH
46820: EMPTY
46821: LIST
46822: LIST
46823: PUSH
46824: LD_INT 4
46826: NEG
46827: PUSH
46828: LD_INT 0
46830: PUSH
46831: EMPTY
46832: LIST
46833: LIST
46834: PUSH
46835: LD_INT 4
46837: NEG
46838: PUSH
46839: LD_INT 1
46841: NEG
46842: PUSH
46843: EMPTY
46844: LIST
46845: LIST
46846: PUSH
46847: LD_INT 3
46849: NEG
46850: PUSH
46851: LD_INT 0
46853: PUSH
46854: EMPTY
46855: LIST
46856: LIST
46857: PUSH
46858: LD_INT 3
46860: NEG
46861: PUSH
46862: LD_INT 1
46864: PUSH
46865: EMPTY
46866: LIST
46867: LIST
46868: PUSH
46869: LD_INT 4
46871: NEG
46872: PUSH
46873: LD_INT 1
46875: PUSH
46876: EMPTY
46877: LIST
46878: LIST
46879: PUSH
46880: LD_INT 5
46882: NEG
46883: PUSH
46884: LD_INT 0
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 5
46893: NEG
46894: PUSH
46895: LD_INT 1
46897: NEG
46898: PUSH
46899: EMPTY
46900: LIST
46901: LIST
46902: PUSH
46903: LD_INT 5
46905: NEG
46906: PUSH
46907: LD_INT 2
46909: NEG
46910: PUSH
46911: EMPTY
46912: LIST
46913: LIST
46914: PUSH
46915: LD_INT 3
46917: NEG
46918: PUSH
46919: LD_INT 2
46921: PUSH
46922: EMPTY
46923: LIST
46924: LIST
46925: PUSH
46926: LD_INT 3
46928: NEG
46929: PUSH
46930: LD_INT 3
46932: NEG
46933: PUSH
46934: EMPTY
46935: LIST
46936: LIST
46937: PUSH
46938: LD_INT 3
46940: NEG
46941: PUSH
46942: LD_INT 4
46944: NEG
46945: PUSH
46946: EMPTY
46947: LIST
46948: LIST
46949: PUSH
46950: LD_INT 2
46952: NEG
46953: PUSH
46954: LD_INT 3
46956: NEG
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: PUSH
46962: LD_INT 2
46964: NEG
46965: PUSH
46966: LD_INT 2
46968: NEG
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: PUSH
46974: LD_INT 3
46976: NEG
46977: PUSH
46978: LD_INT 2
46980: NEG
46981: PUSH
46982: EMPTY
46983: LIST
46984: LIST
46985: PUSH
46986: LD_INT 4
46988: NEG
46989: PUSH
46990: LD_INT 3
46992: NEG
46993: PUSH
46994: EMPTY
46995: LIST
46996: LIST
46997: PUSH
46998: LD_INT 4
47000: NEG
47001: PUSH
47002: LD_INT 4
47004: NEG
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 2
47012: NEG
47013: PUSH
47014: LD_INT 4
47016: NEG
47017: PUSH
47018: EMPTY
47019: LIST
47020: LIST
47021: PUSH
47022: LD_INT 4
47024: NEG
47025: PUSH
47026: LD_INT 2
47028: NEG
47029: PUSH
47030: EMPTY
47031: LIST
47032: LIST
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: LD_INT 4
47039: NEG
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PUSH
47045: LD_INT 0
47047: PUSH
47048: LD_INT 5
47050: NEG
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: LD_INT 1
47058: PUSH
47059: LD_INT 4
47061: NEG
47062: PUSH
47063: EMPTY
47064: LIST
47065: LIST
47066: PUSH
47067: LD_INT 1
47069: PUSH
47070: LD_INT 3
47072: NEG
47073: PUSH
47074: EMPTY
47075: LIST
47076: LIST
47077: PUSH
47078: LD_INT 0
47080: PUSH
47081: LD_INT 3
47083: NEG
47084: PUSH
47085: EMPTY
47086: LIST
47087: LIST
47088: PUSH
47089: LD_INT 1
47091: NEG
47092: PUSH
47093: LD_INT 4
47095: NEG
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 1
47103: NEG
47104: PUSH
47105: LD_INT 5
47107: NEG
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 2
47115: PUSH
47116: LD_INT 3
47118: NEG
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: PUSH
47124: LD_INT 2
47126: NEG
47127: PUSH
47128: LD_INT 5
47130: NEG
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PUSH
47136: EMPTY
47137: LIST
47138: LIST
47139: LIST
47140: LIST
47141: LIST
47142: LIST
47143: LIST
47144: LIST
47145: LIST
47146: LIST
47147: LIST
47148: LIST
47149: LIST
47150: LIST
47151: LIST
47152: LIST
47153: LIST
47154: LIST
47155: LIST
47156: LIST
47157: LIST
47158: LIST
47159: LIST
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: LIST
47166: LIST
47167: LIST
47168: LIST
47169: LIST
47170: LIST
47171: LIST
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
47183: LD_ADDR_VAR 0 31
47187: PUSH
47188: LD_INT 0
47190: PUSH
47191: LD_INT 4
47193: PUSH
47194: EMPTY
47195: LIST
47196: LIST
47197: PUSH
47198: LD_INT 0
47200: PUSH
47201: LD_INT 3
47203: PUSH
47204: EMPTY
47205: LIST
47206: LIST
47207: PUSH
47208: LD_INT 1
47210: PUSH
47211: LD_INT 4
47213: PUSH
47214: EMPTY
47215: LIST
47216: LIST
47217: PUSH
47218: LD_INT 1
47220: PUSH
47221: LD_INT 5
47223: PUSH
47224: EMPTY
47225: LIST
47226: LIST
47227: PUSH
47228: LD_INT 0
47230: PUSH
47231: LD_INT 5
47233: PUSH
47234: EMPTY
47235: LIST
47236: LIST
47237: PUSH
47238: LD_INT 1
47240: NEG
47241: PUSH
47242: LD_INT 4
47244: PUSH
47245: EMPTY
47246: LIST
47247: LIST
47248: PUSH
47249: LD_INT 1
47251: NEG
47252: PUSH
47253: LD_INT 3
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: PUSH
47260: LD_INT 2
47262: PUSH
47263: LD_INT 5
47265: PUSH
47266: EMPTY
47267: LIST
47268: LIST
47269: PUSH
47270: LD_INT 2
47272: NEG
47273: PUSH
47274: LD_INT 3
47276: PUSH
47277: EMPTY
47278: LIST
47279: LIST
47280: PUSH
47281: LD_INT 3
47283: NEG
47284: PUSH
47285: LD_INT 0
47287: PUSH
47288: EMPTY
47289: LIST
47290: LIST
47291: PUSH
47292: LD_INT 3
47294: NEG
47295: PUSH
47296: LD_INT 1
47298: NEG
47299: PUSH
47300: EMPTY
47301: LIST
47302: LIST
47303: PUSH
47304: LD_INT 2
47306: NEG
47307: PUSH
47308: LD_INT 0
47310: PUSH
47311: EMPTY
47312: LIST
47313: LIST
47314: PUSH
47315: LD_INT 2
47317: NEG
47318: PUSH
47319: LD_INT 1
47321: PUSH
47322: EMPTY
47323: LIST
47324: LIST
47325: PUSH
47326: LD_INT 3
47328: NEG
47329: PUSH
47330: LD_INT 1
47332: PUSH
47333: EMPTY
47334: LIST
47335: LIST
47336: PUSH
47337: LD_INT 4
47339: NEG
47340: PUSH
47341: LD_INT 0
47343: PUSH
47344: EMPTY
47345: LIST
47346: LIST
47347: PUSH
47348: LD_INT 4
47350: NEG
47351: PUSH
47352: LD_INT 1
47354: NEG
47355: PUSH
47356: EMPTY
47357: LIST
47358: LIST
47359: PUSH
47360: LD_INT 4
47362: NEG
47363: PUSH
47364: LD_INT 2
47366: NEG
47367: PUSH
47368: EMPTY
47369: LIST
47370: LIST
47371: PUSH
47372: LD_INT 2
47374: NEG
47375: PUSH
47376: LD_INT 2
47378: PUSH
47379: EMPTY
47380: LIST
47381: LIST
47382: PUSH
47383: LD_INT 4
47385: NEG
47386: PUSH
47387: LD_INT 4
47389: NEG
47390: PUSH
47391: EMPTY
47392: LIST
47393: LIST
47394: PUSH
47395: LD_INT 4
47397: NEG
47398: PUSH
47399: LD_INT 5
47401: NEG
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: LD_INT 3
47409: NEG
47410: PUSH
47411: LD_INT 4
47413: NEG
47414: PUSH
47415: EMPTY
47416: LIST
47417: LIST
47418: PUSH
47419: LD_INT 3
47421: NEG
47422: PUSH
47423: LD_INT 3
47425: NEG
47426: PUSH
47427: EMPTY
47428: LIST
47429: LIST
47430: PUSH
47431: LD_INT 4
47433: NEG
47434: PUSH
47435: LD_INT 3
47437: NEG
47438: PUSH
47439: EMPTY
47440: LIST
47441: LIST
47442: PUSH
47443: LD_INT 5
47445: NEG
47446: PUSH
47447: LD_INT 4
47449: NEG
47450: PUSH
47451: EMPTY
47452: LIST
47453: LIST
47454: PUSH
47455: LD_INT 5
47457: NEG
47458: PUSH
47459: LD_INT 5
47461: NEG
47462: PUSH
47463: EMPTY
47464: LIST
47465: LIST
47466: PUSH
47467: LD_INT 3
47469: NEG
47470: PUSH
47471: LD_INT 5
47473: NEG
47474: PUSH
47475: EMPTY
47476: LIST
47477: LIST
47478: PUSH
47479: LD_INT 5
47481: NEG
47482: PUSH
47483: LD_INT 3
47485: NEG
47486: PUSH
47487: EMPTY
47488: LIST
47489: LIST
47490: PUSH
47491: LD_INT 0
47493: PUSH
47494: LD_INT 3
47496: NEG
47497: PUSH
47498: EMPTY
47499: LIST
47500: LIST
47501: PUSH
47502: LD_INT 0
47504: PUSH
47505: LD_INT 4
47507: NEG
47508: PUSH
47509: EMPTY
47510: LIST
47511: LIST
47512: PUSH
47513: LD_INT 1
47515: PUSH
47516: LD_INT 3
47518: NEG
47519: PUSH
47520: EMPTY
47521: LIST
47522: LIST
47523: PUSH
47524: LD_INT 1
47526: PUSH
47527: LD_INT 2
47529: NEG
47530: PUSH
47531: EMPTY
47532: LIST
47533: LIST
47534: PUSH
47535: LD_INT 0
47537: PUSH
47538: LD_INT 2
47540: NEG
47541: PUSH
47542: EMPTY
47543: LIST
47544: LIST
47545: PUSH
47546: LD_INT 1
47548: NEG
47549: PUSH
47550: LD_INT 3
47552: NEG
47553: PUSH
47554: EMPTY
47555: LIST
47556: LIST
47557: PUSH
47558: LD_INT 1
47560: NEG
47561: PUSH
47562: LD_INT 4
47564: NEG
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: LD_INT 2
47572: PUSH
47573: LD_INT 2
47575: NEG
47576: PUSH
47577: EMPTY
47578: LIST
47579: LIST
47580: PUSH
47581: LD_INT 2
47583: NEG
47584: PUSH
47585: LD_INT 4
47587: NEG
47588: PUSH
47589: EMPTY
47590: LIST
47591: LIST
47592: PUSH
47593: LD_INT 4
47595: PUSH
47596: LD_INT 0
47598: PUSH
47599: EMPTY
47600: LIST
47601: LIST
47602: PUSH
47603: LD_INT 4
47605: PUSH
47606: LD_INT 1
47608: NEG
47609: PUSH
47610: EMPTY
47611: LIST
47612: LIST
47613: PUSH
47614: LD_INT 5
47616: PUSH
47617: LD_INT 0
47619: PUSH
47620: EMPTY
47621: LIST
47622: LIST
47623: PUSH
47624: LD_INT 5
47626: PUSH
47627: LD_INT 1
47629: PUSH
47630: EMPTY
47631: LIST
47632: LIST
47633: PUSH
47634: LD_INT 4
47636: PUSH
47637: LD_INT 1
47639: PUSH
47640: EMPTY
47641: LIST
47642: LIST
47643: PUSH
47644: LD_INT 3
47646: PUSH
47647: LD_INT 0
47649: PUSH
47650: EMPTY
47651: LIST
47652: LIST
47653: PUSH
47654: LD_INT 3
47656: PUSH
47657: LD_INT 1
47659: NEG
47660: PUSH
47661: EMPTY
47662: LIST
47663: LIST
47664: PUSH
47665: LD_INT 3
47667: PUSH
47668: LD_INT 2
47670: NEG
47671: PUSH
47672: EMPTY
47673: LIST
47674: LIST
47675: PUSH
47676: LD_INT 5
47678: PUSH
47679: LD_INT 2
47681: PUSH
47682: EMPTY
47683: LIST
47684: LIST
47685: PUSH
47686: EMPTY
47687: LIST
47688: LIST
47689: LIST
47690: LIST
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: LIST
47698: LIST
47699: LIST
47700: LIST
47701: LIST
47702: LIST
47703: LIST
47704: LIST
47705: LIST
47706: LIST
47707: LIST
47708: LIST
47709: LIST
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: LIST
47717: LIST
47718: LIST
47719: LIST
47720: LIST
47721: LIST
47722: LIST
47723: LIST
47724: LIST
47725: LIST
47726: LIST
47727: LIST
47728: LIST
47729: LIST
47730: LIST
47731: LIST
47732: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
47733: LD_ADDR_VAR 0 32
47737: PUSH
47738: LD_INT 4
47740: NEG
47741: PUSH
47742: LD_INT 0
47744: PUSH
47745: EMPTY
47746: LIST
47747: LIST
47748: PUSH
47749: LD_INT 4
47751: NEG
47752: PUSH
47753: LD_INT 1
47755: NEG
47756: PUSH
47757: EMPTY
47758: LIST
47759: LIST
47760: PUSH
47761: LD_INT 3
47763: NEG
47764: PUSH
47765: LD_INT 0
47767: PUSH
47768: EMPTY
47769: LIST
47770: LIST
47771: PUSH
47772: LD_INT 3
47774: NEG
47775: PUSH
47776: LD_INT 1
47778: PUSH
47779: EMPTY
47780: LIST
47781: LIST
47782: PUSH
47783: LD_INT 4
47785: NEG
47786: PUSH
47787: LD_INT 1
47789: PUSH
47790: EMPTY
47791: LIST
47792: LIST
47793: PUSH
47794: LD_INT 5
47796: NEG
47797: PUSH
47798: LD_INT 0
47800: PUSH
47801: EMPTY
47802: LIST
47803: LIST
47804: PUSH
47805: LD_INT 5
47807: NEG
47808: PUSH
47809: LD_INT 1
47811: NEG
47812: PUSH
47813: EMPTY
47814: LIST
47815: LIST
47816: PUSH
47817: LD_INT 5
47819: NEG
47820: PUSH
47821: LD_INT 2
47823: NEG
47824: PUSH
47825: EMPTY
47826: LIST
47827: LIST
47828: PUSH
47829: LD_INT 3
47831: NEG
47832: PUSH
47833: LD_INT 2
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PUSH
47840: LD_INT 3
47842: NEG
47843: PUSH
47844: LD_INT 3
47846: NEG
47847: PUSH
47848: EMPTY
47849: LIST
47850: LIST
47851: PUSH
47852: LD_INT 3
47854: NEG
47855: PUSH
47856: LD_INT 4
47858: NEG
47859: PUSH
47860: EMPTY
47861: LIST
47862: LIST
47863: PUSH
47864: LD_INT 2
47866: NEG
47867: PUSH
47868: LD_INT 3
47870: NEG
47871: PUSH
47872: EMPTY
47873: LIST
47874: LIST
47875: PUSH
47876: LD_INT 2
47878: NEG
47879: PUSH
47880: LD_INT 2
47882: NEG
47883: PUSH
47884: EMPTY
47885: LIST
47886: LIST
47887: PUSH
47888: LD_INT 3
47890: NEG
47891: PUSH
47892: LD_INT 2
47894: NEG
47895: PUSH
47896: EMPTY
47897: LIST
47898: LIST
47899: PUSH
47900: LD_INT 4
47902: NEG
47903: PUSH
47904: LD_INT 3
47906: NEG
47907: PUSH
47908: EMPTY
47909: LIST
47910: LIST
47911: PUSH
47912: LD_INT 4
47914: NEG
47915: PUSH
47916: LD_INT 4
47918: NEG
47919: PUSH
47920: EMPTY
47921: LIST
47922: LIST
47923: PUSH
47924: LD_INT 2
47926: NEG
47927: PUSH
47928: LD_INT 4
47930: NEG
47931: PUSH
47932: EMPTY
47933: LIST
47934: LIST
47935: PUSH
47936: LD_INT 4
47938: NEG
47939: PUSH
47940: LD_INT 2
47942: NEG
47943: PUSH
47944: EMPTY
47945: LIST
47946: LIST
47947: PUSH
47948: LD_INT 0
47950: PUSH
47951: LD_INT 4
47953: NEG
47954: PUSH
47955: EMPTY
47956: LIST
47957: LIST
47958: PUSH
47959: LD_INT 0
47961: PUSH
47962: LD_INT 5
47964: NEG
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: PUSH
47970: LD_INT 1
47972: PUSH
47973: LD_INT 4
47975: NEG
47976: PUSH
47977: EMPTY
47978: LIST
47979: LIST
47980: PUSH
47981: LD_INT 1
47983: PUSH
47984: LD_INT 3
47986: NEG
47987: PUSH
47988: EMPTY
47989: LIST
47990: LIST
47991: PUSH
47992: LD_INT 0
47994: PUSH
47995: LD_INT 3
47997: NEG
47998: PUSH
47999: EMPTY
48000: LIST
48001: LIST
48002: PUSH
48003: LD_INT 1
48005: NEG
48006: PUSH
48007: LD_INT 4
48009: NEG
48010: PUSH
48011: EMPTY
48012: LIST
48013: LIST
48014: PUSH
48015: LD_INT 1
48017: NEG
48018: PUSH
48019: LD_INT 5
48021: NEG
48022: PUSH
48023: EMPTY
48024: LIST
48025: LIST
48026: PUSH
48027: LD_INT 2
48029: PUSH
48030: LD_INT 3
48032: NEG
48033: PUSH
48034: EMPTY
48035: LIST
48036: LIST
48037: PUSH
48038: LD_INT 2
48040: NEG
48041: PUSH
48042: LD_INT 5
48044: NEG
48045: PUSH
48046: EMPTY
48047: LIST
48048: LIST
48049: PUSH
48050: LD_INT 3
48052: PUSH
48053: LD_INT 0
48055: PUSH
48056: EMPTY
48057: LIST
48058: LIST
48059: PUSH
48060: LD_INT 3
48062: PUSH
48063: LD_INT 1
48065: NEG
48066: PUSH
48067: EMPTY
48068: LIST
48069: LIST
48070: PUSH
48071: LD_INT 4
48073: PUSH
48074: LD_INT 0
48076: PUSH
48077: EMPTY
48078: LIST
48079: LIST
48080: PUSH
48081: LD_INT 4
48083: PUSH
48084: LD_INT 1
48086: PUSH
48087: EMPTY
48088: LIST
48089: LIST
48090: PUSH
48091: LD_INT 3
48093: PUSH
48094: LD_INT 1
48096: PUSH
48097: EMPTY
48098: LIST
48099: LIST
48100: PUSH
48101: LD_INT 2
48103: PUSH
48104: LD_INT 0
48106: PUSH
48107: EMPTY
48108: LIST
48109: LIST
48110: PUSH
48111: LD_INT 2
48113: PUSH
48114: LD_INT 1
48116: NEG
48117: PUSH
48118: EMPTY
48119: LIST
48120: LIST
48121: PUSH
48122: LD_INT 2
48124: PUSH
48125: LD_INT 2
48127: NEG
48128: PUSH
48129: EMPTY
48130: LIST
48131: LIST
48132: PUSH
48133: LD_INT 4
48135: PUSH
48136: LD_INT 2
48138: PUSH
48139: EMPTY
48140: LIST
48141: LIST
48142: PUSH
48143: LD_INT 4
48145: PUSH
48146: LD_INT 4
48148: PUSH
48149: EMPTY
48150: LIST
48151: LIST
48152: PUSH
48153: LD_INT 4
48155: PUSH
48156: LD_INT 3
48158: PUSH
48159: EMPTY
48160: LIST
48161: LIST
48162: PUSH
48163: LD_INT 5
48165: PUSH
48166: LD_INT 4
48168: PUSH
48169: EMPTY
48170: LIST
48171: LIST
48172: PUSH
48173: LD_INT 5
48175: PUSH
48176: LD_INT 5
48178: PUSH
48179: EMPTY
48180: LIST
48181: LIST
48182: PUSH
48183: LD_INT 4
48185: PUSH
48186: LD_INT 5
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: PUSH
48193: LD_INT 3
48195: PUSH
48196: LD_INT 4
48198: PUSH
48199: EMPTY
48200: LIST
48201: LIST
48202: PUSH
48203: LD_INT 3
48205: PUSH
48206: LD_INT 3
48208: PUSH
48209: EMPTY
48210: LIST
48211: LIST
48212: PUSH
48213: LD_INT 5
48215: PUSH
48216: LD_INT 3
48218: PUSH
48219: EMPTY
48220: LIST
48221: LIST
48222: PUSH
48223: LD_INT 3
48225: PUSH
48226: LD_INT 5
48228: PUSH
48229: EMPTY
48230: LIST
48231: LIST
48232: PUSH
48233: EMPTY
48234: LIST
48235: LIST
48236: LIST
48237: LIST
48238: LIST
48239: LIST
48240: LIST
48241: LIST
48242: LIST
48243: LIST
48244: LIST
48245: LIST
48246: LIST
48247: LIST
48248: LIST
48249: LIST
48250: LIST
48251: LIST
48252: LIST
48253: LIST
48254: LIST
48255: LIST
48256: LIST
48257: LIST
48258: LIST
48259: LIST
48260: LIST
48261: LIST
48262: LIST
48263: LIST
48264: LIST
48265: LIST
48266: LIST
48267: LIST
48268: LIST
48269: LIST
48270: LIST
48271: LIST
48272: LIST
48273: LIST
48274: LIST
48275: LIST
48276: LIST
48277: LIST
48278: LIST
48279: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
48280: LD_ADDR_VAR 0 33
48284: PUSH
48285: LD_INT 4
48287: NEG
48288: PUSH
48289: LD_INT 4
48291: NEG
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: PUSH
48297: LD_INT 4
48299: NEG
48300: PUSH
48301: LD_INT 5
48303: NEG
48304: PUSH
48305: EMPTY
48306: LIST
48307: LIST
48308: PUSH
48309: LD_INT 3
48311: NEG
48312: PUSH
48313: LD_INT 4
48315: NEG
48316: PUSH
48317: EMPTY
48318: LIST
48319: LIST
48320: PUSH
48321: LD_INT 3
48323: NEG
48324: PUSH
48325: LD_INT 3
48327: NEG
48328: PUSH
48329: EMPTY
48330: LIST
48331: LIST
48332: PUSH
48333: LD_INT 4
48335: NEG
48336: PUSH
48337: LD_INT 3
48339: NEG
48340: PUSH
48341: EMPTY
48342: LIST
48343: LIST
48344: PUSH
48345: LD_INT 5
48347: NEG
48348: PUSH
48349: LD_INT 4
48351: NEG
48352: PUSH
48353: EMPTY
48354: LIST
48355: LIST
48356: PUSH
48357: LD_INT 5
48359: NEG
48360: PUSH
48361: LD_INT 5
48363: NEG
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PUSH
48369: LD_INT 3
48371: NEG
48372: PUSH
48373: LD_INT 5
48375: NEG
48376: PUSH
48377: EMPTY
48378: LIST
48379: LIST
48380: PUSH
48381: LD_INT 5
48383: NEG
48384: PUSH
48385: LD_INT 3
48387: NEG
48388: PUSH
48389: EMPTY
48390: LIST
48391: LIST
48392: PUSH
48393: LD_INT 0
48395: PUSH
48396: LD_INT 3
48398: NEG
48399: PUSH
48400: EMPTY
48401: LIST
48402: LIST
48403: PUSH
48404: LD_INT 0
48406: PUSH
48407: LD_INT 4
48409: NEG
48410: PUSH
48411: EMPTY
48412: LIST
48413: LIST
48414: PUSH
48415: LD_INT 1
48417: PUSH
48418: LD_INT 3
48420: NEG
48421: PUSH
48422: EMPTY
48423: LIST
48424: LIST
48425: PUSH
48426: LD_INT 1
48428: PUSH
48429: LD_INT 2
48431: NEG
48432: PUSH
48433: EMPTY
48434: LIST
48435: LIST
48436: PUSH
48437: LD_INT 0
48439: PUSH
48440: LD_INT 2
48442: NEG
48443: PUSH
48444: EMPTY
48445: LIST
48446: LIST
48447: PUSH
48448: LD_INT 1
48450: NEG
48451: PUSH
48452: LD_INT 3
48454: NEG
48455: PUSH
48456: EMPTY
48457: LIST
48458: LIST
48459: PUSH
48460: LD_INT 1
48462: NEG
48463: PUSH
48464: LD_INT 4
48466: NEG
48467: PUSH
48468: EMPTY
48469: LIST
48470: LIST
48471: PUSH
48472: LD_INT 2
48474: PUSH
48475: LD_INT 2
48477: NEG
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: PUSH
48483: LD_INT 2
48485: NEG
48486: PUSH
48487: LD_INT 4
48489: NEG
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_INT 4
48497: PUSH
48498: LD_INT 0
48500: PUSH
48501: EMPTY
48502: LIST
48503: LIST
48504: PUSH
48505: LD_INT 4
48507: PUSH
48508: LD_INT 1
48510: NEG
48511: PUSH
48512: EMPTY
48513: LIST
48514: LIST
48515: PUSH
48516: LD_INT 5
48518: PUSH
48519: LD_INT 0
48521: PUSH
48522: EMPTY
48523: LIST
48524: LIST
48525: PUSH
48526: LD_INT 5
48528: PUSH
48529: LD_INT 1
48531: PUSH
48532: EMPTY
48533: LIST
48534: LIST
48535: PUSH
48536: LD_INT 4
48538: PUSH
48539: LD_INT 1
48541: PUSH
48542: EMPTY
48543: LIST
48544: LIST
48545: PUSH
48546: LD_INT 3
48548: PUSH
48549: LD_INT 0
48551: PUSH
48552: EMPTY
48553: LIST
48554: LIST
48555: PUSH
48556: LD_INT 3
48558: PUSH
48559: LD_INT 1
48561: NEG
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: PUSH
48567: LD_INT 3
48569: PUSH
48570: LD_INT 2
48572: NEG
48573: PUSH
48574: EMPTY
48575: LIST
48576: LIST
48577: PUSH
48578: LD_INT 5
48580: PUSH
48581: LD_INT 2
48583: PUSH
48584: EMPTY
48585: LIST
48586: LIST
48587: PUSH
48588: LD_INT 3
48590: PUSH
48591: LD_INT 3
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: PUSH
48598: LD_INT 3
48600: PUSH
48601: LD_INT 2
48603: PUSH
48604: EMPTY
48605: LIST
48606: LIST
48607: PUSH
48608: LD_INT 4
48610: PUSH
48611: LD_INT 3
48613: PUSH
48614: EMPTY
48615: LIST
48616: LIST
48617: PUSH
48618: LD_INT 4
48620: PUSH
48621: LD_INT 4
48623: PUSH
48624: EMPTY
48625: LIST
48626: LIST
48627: PUSH
48628: LD_INT 3
48630: PUSH
48631: LD_INT 4
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_INT 2
48640: PUSH
48641: LD_INT 3
48643: PUSH
48644: EMPTY
48645: LIST
48646: LIST
48647: PUSH
48648: LD_INT 2
48650: PUSH
48651: LD_INT 2
48653: PUSH
48654: EMPTY
48655: LIST
48656: LIST
48657: PUSH
48658: LD_INT 4
48660: PUSH
48661: LD_INT 2
48663: PUSH
48664: EMPTY
48665: LIST
48666: LIST
48667: PUSH
48668: LD_INT 2
48670: PUSH
48671: LD_INT 4
48673: PUSH
48674: EMPTY
48675: LIST
48676: LIST
48677: PUSH
48678: LD_INT 0
48680: PUSH
48681: LD_INT 4
48683: PUSH
48684: EMPTY
48685: LIST
48686: LIST
48687: PUSH
48688: LD_INT 0
48690: PUSH
48691: LD_INT 3
48693: PUSH
48694: EMPTY
48695: LIST
48696: LIST
48697: PUSH
48698: LD_INT 1
48700: PUSH
48701: LD_INT 4
48703: PUSH
48704: EMPTY
48705: LIST
48706: LIST
48707: PUSH
48708: LD_INT 1
48710: PUSH
48711: LD_INT 5
48713: PUSH
48714: EMPTY
48715: LIST
48716: LIST
48717: PUSH
48718: LD_INT 0
48720: PUSH
48721: LD_INT 5
48723: PUSH
48724: EMPTY
48725: LIST
48726: LIST
48727: PUSH
48728: LD_INT 1
48730: NEG
48731: PUSH
48732: LD_INT 4
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: PUSH
48739: LD_INT 1
48741: NEG
48742: PUSH
48743: LD_INT 3
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: PUSH
48750: LD_INT 2
48752: PUSH
48753: LD_INT 5
48755: PUSH
48756: EMPTY
48757: LIST
48758: LIST
48759: PUSH
48760: LD_INT 2
48762: NEG
48763: PUSH
48764: LD_INT 3
48766: PUSH
48767: EMPTY
48768: LIST
48769: LIST
48770: PUSH
48771: EMPTY
48772: LIST
48773: LIST
48774: LIST
48775: LIST
48776: LIST
48777: LIST
48778: LIST
48779: LIST
48780: LIST
48781: LIST
48782: LIST
48783: LIST
48784: LIST
48785: LIST
48786: LIST
48787: LIST
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: LIST
48798: LIST
48799: LIST
48800: LIST
48801: LIST
48802: LIST
48803: LIST
48804: LIST
48805: LIST
48806: LIST
48807: LIST
48808: LIST
48809: LIST
48810: LIST
48811: LIST
48812: LIST
48813: LIST
48814: LIST
48815: LIST
48816: LIST
48817: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
48818: LD_ADDR_VAR 0 34
48822: PUSH
48823: LD_INT 0
48825: PUSH
48826: LD_INT 4
48828: NEG
48829: PUSH
48830: EMPTY
48831: LIST
48832: LIST
48833: PUSH
48834: LD_INT 0
48836: PUSH
48837: LD_INT 5
48839: NEG
48840: PUSH
48841: EMPTY
48842: LIST
48843: LIST
48844: PUSH
48845: LD_INT 1
48847: PUSH
48848: LD_INT 4
48850: NEG
48851: PUSH
48852: EMPTY
48853: LIST
48854: LIST
48855: PUSH
48856: LD_INT 1
48858: PUSH
48859: LD_INT 3
48861: NEG
48862: PUSH
48863: EMPTY
48864: LIST
48865: LIST
48866: PUSH
48867: LD_INT 0
48869: PUSH
48870: LD_INT 3
48872: NEG
48873: PUSH
48874: EMPTY
48875: LIST
48876: LIST
48877: PUSH
48878: LD_INT 1
48880: NEG
48881: PUSH
48882: LD_INT 4
48884: NEG
48885: PUSH
48886: EMPTY
48887: LIST
48888: LIST
48889: PUSH
48890: LD_INT 1
48892: NEG
48893: PUSH
48894: LD_INT 5
48896: NEG
48897: PUSH
48898: EMPTY
48899: LIST
48900: LIST
48901: PUSH
48902: LD_INT 2
48904: PUSH
48905: LD_INT 3
48907: NEG
48908: PUSH
48909: EMPTY
48910: LIST
48911: LIST
48912: PUSH
48913: LD_INT 2
48915: NEG
48916: PUSH
48917: LD_INT 5
48919: NEG
48920: PUSH
48921: EMPTY
48922: LIST
48923: LIST
48924: PUSH
48925: LD_INT 3
48927: PUSH
48928: LD_INT 0
48930: PUSH
48931: EMPTY
48932: LIST
48933: LIST
48934: PUSH
48935: LD_INT 3
48937: PUSH
48938: LD_INT 1
48940: NEG
48941: PUSH
48942: EMPTY
48943: LIST
48944: LIST
48945: PUSH
48946: LD_INT 4
48948: PUSH
48949: LD_INT 0
48951: PUSH
48952: EMPTY
48953: LIST
48954: LIST
48955: PUSH
48956: LD_INT 4
48958: PUSH
48959: LD_INT 1
48961: PUSH
48962: EMPTY
48963: LIST
48964: LIST
48965: PUSH
48966: LD_INT 3
48968: PUSH
48969: LD_INT 1
48971: PUSH
48972: EMPTY
48973: LIST
48974: LIST
48975: PUSH
48976: LD_INT 2
48978: PUSH
48979: LD_INT 0
48981: PUSH
48982: EMPTY
48983: LIST
48984: LIST
48985: PUSH
48986: LD_INT 2
48988: PUSH
48989: LD_INT 1
48991: NEG
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: PUSH
48997: LD_INT 2
48999: PUSH
49000: LD_INT 2
49002: NEG
49003: PUSH
49004: EMPTY
49005: LIST
49006: LIST
49007: PUSH
49008: LD_INT 4
49010: PUSH
49011: LD_INT 2
49013: PUSH
49014: EMPTY
49015: LIST
49016: LIST
49017: PUSH
49018: LD_INT 4
49020: PUSH
49021: LD_INT 4
49023: PUSH
49024: EMPTY
49025: LIST
49026: LIST
49027: PUSH
49028: LD_INT 4
49030: PUSH
49031: LD_INT 3
49033: PUSH
49034: EMPTY
49035: LIST
49036: LIST
49037: PUSH
49038: LD_INT 5
49040: PUSH
49041: LD_INT 4
49043: PUSH
49044: EMPTY
49045: LIST
49046: LIST
49047: PUSH
49048: LD_INT 5
49050: PUSH
49051: LD_INT 5
49053: PUSH
49054: EMPTY
49055: LIST
49056: LIST
49057: PUSH
49058: LD_INT 4
49060: PUSH
49061: LD_INT 5
49063: PUSH
49064: EMPTY
49065: LIST
49066: LIST
49067: PUSH
49068: LD_INT 3
49070: PUSH
49071: LD_INT 4
49073: PUSH
49074: EMPTY
49075: LIST
49076: LIST
49077: PUSH
49078: LD_INT 3
49080: PUSH
49081: LD_INT 3
49083: PUSH
49084: EMPTY
49085: LIST
49086: LIST
49087: PUSH
49088: LD_INT 5
49090: PUSH
49091: LD_INT 3
49093: PUSH
49094: EMPTY
49095: LIST
49096: LIST
49097: PUSH
49098: LD_INT 3
49100: PUSH
49101: LD_INT 5
49103: PUSH
49104: EMPTY
49105: LIST
49106: LIST
49107: PUSH
49108: LD_INT 0
49110: PUSH
49111: LD_INT 3
49113: PUSH
49114: EMPTY
49115: LIST
49116: LIST
49117: PUSH
49118: LD_INT 0
49120: PUSH
49121: LD_INT 2
49123: PUSH
49124: EMPTY
49125: LIST
49126: LIST
49127: PUSH
49128: LD_INT 1
49130: PUSH
49131: LD_INT 3
49133: PUSH
49134: EMPTY
49135: LIST
49136: LIST
49137: PUSH
49138: LD_INT 1
49140: PUSH
49141: LD_INT 4
49143: PUSH
49144: EMPTY
49145: LIST
49146: LIST
49147: PUSH
49148: LD_INT 0
49150: PUSH
49151: LD_INT 4
49153: PUSH
49154: EMPTY
49155: LIST
49156: LIST
49157: PUSH
49158: LD_INT 1
49160: NEG
49161: PUSH
49162: LD_INT 3
49164: PUSH
49165: EMPTY
49166: LIST
49167: LIST
49168: PUSH
49169: LD_INT 1
49171: NEG
49172: PUSH
49173: LD_INT 2
49175: PUSH
49176: EMPTY
49177: LIST
49178: LIST
49179: PUSH
49180: LD_INT 2
49182: PUSH
49183: LD_INT 4
49185: PUSH
49186: EMPTY
49187: LIST
49188: LIST
49189: PUSH
49190: LD_INT 2
49192: NEG
49193: PUSH
49194: LD_INT 2
49196: PUSH
49197: EMPTY
49198: LIST
49199: LIST
49200: PUSH
49201: LD_INT 4
49203: NEG
49204: PUSH
49205: LD_INT 0
49207: PUSH
49208: EMPTY
49209: LIST
49210: LIST
49211: PUSH
49212: LD_INT 4
49214: NEG
49215: PUSH
49216: LD_INT 1
49218: NEG
49219: PUSH
49220: EMPTY
49221: LIST
49222: LIST
49223: PUSH
49224: LD_INT 3
49226: NEG
49227: PUSH
49228: LD_INT 0
49230: PUSH
49231: EMPTY
49232: LIST
49233: LIST
49234: PUSH
49235: LD_INT 3
49237: NEG
49238: PUSH
49239: LD_INT 1
49241: PUSH
49242: EMPTY
49243: LIST
49244: LIST
49245: PUSH
49246: LD_INT 4
49248: NEG
49249: PUSH
49250: LD_INT 1
49252: PUSH
49253: EMPTY
49254: LIST
49255: LIST
49256: PUSH
49257: LD_INT 5
49259: NEG
49260: PUSH
49261: LD_INT 0
49263: PUSH
49264: EMPTY
49265: LIST
49266: LIST
49267: PUSH
49268: LD_INT 5
49270: NEG
49271: PUSH
49272: LD_INT 1
49274: NEG
49275: PUSH
49276: EMPTY
49277: LIST
49278: LIST
49279: PUSH
49280: LD_INT 5
49282: NEG
49283: PUSH
49284: LD_INT 2
49286: NEG
49287: PUSH
49288: EMPTY
49289: LIST
49290: LIST
49291: PUSH
49292: LD_INT 3
49294: NEG
49295: PUSH
49296: LD_INT 2
49298: PUSH
49299: EMPTY
49300: LIST
49301: LIST
49302: PUSH
49303: EMPTY
49304: LIST
49305: LIST
49306: LIST
49307: LIST
49308: LIST
49309: LIST
49310: LIST
49311: LIST
49312: LIST
49313: LIST
49314: LIST
49315: LIST
49316: LIST
49317: LIST
49318: LIST
49319: LIST
49320: LIST
49321: LIST
49322: LIST
49323: LIST
49324: LIST
49325: LIST
49326: LIST
49327: LIST
49328: LIST
49329: LIST
49330: LIST
49331: LIST
49332: LIST
49333: LIST
49334: LIST
49335: LIST
49336: LIST
49337: LIST
49338: LIST
49339: LIST
49340: LIST
49341: LIST
49342: LIST
49343: LIST
49344: LIST
49345: LIST
49346: LIST
49347: LIST
49348: LIST
49349: ST_TO_ADDR
// end ; end ;
49350: GO 49353
49352: POP
// case btype of b_depot , b_warehouse :
49353: LD_VAR 0 1
49357: PUSH
49358: LD_INT 0
49360: DOUBLE
49361: EQUAL
49362: IFTRUE 49372
49364: LD_INT 1
49366: DOUBLE
49367: EQUAL
49368: IFTRUE 49372
49370: GO 49573
49372: POP
// case nation of nation_american :
49373: LD_VAR 0 5
49377: PUSH
49378: LD_INT 1
49380: DOUBLE
49381: EQUAL
49382: IFTRUE 49386
49384: GO 49442
49386: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
49387: LD_ADDR_VAR 0 9
49391: PUSH
49392: LD_VAR 0 11
49396: PUSH
49397: LD_VAR 0 12
49401: PUSH
49402: LD_VAR 0 13
49406: PUSH
49407: LD_VAR 0 14
49411: PUSH
49412: LD_VAR 0 15
49416: PUSH
49417: LD_VAR 0 16
49421: PUSH
49422: EMPTY
49423: LIST
49424: LIST
49425: LIST
49426: LIST
49427: LIST
49428: LIST
49429: PUSH
49430: LD_VAR 0 4
49434: PUSH
49435: LD_INT 1
49437: PLUS
49438: ARRAY
49439: ST_TO_ADDR
49440: GO 49571
49442: LD_INT 2
49444: DOUBLE
49445: EQUAL
49446: IFTRUE 49450
49448: GO 49506
49450: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
49451: LD_ADDR_VAR 0 9
49455: PUSH
49456: LD_VAR 0 17
49460: PUSH
49461: LD_VAR 0 18
49465: PUSH
49466: LD_VAR 0 19
49470: PUSH
49471: LD_VAR 0 20
49475: PUSH
49476: LD_VAR 0 21
49480: PUSH
49481: LD_VAR 0 22
49485: PUSH
49486: EMPTY
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: LIST
49493: PUSH
49494: LD_VAR 0 4
49498: PUSH
49499: LD_INT 1
49501: PLUS
49502: ARRAY
49503: ST_TO_ADDR
49504: GO 49571
49506: LD_INT 3
49508: DOUBLE
49509: EQUAL
49510: IFTRUE 49514
49512: GO 49570
49514: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
49515: LD_ADDR_VAR 0 9
49519: PUSH
49520: LD_VAR 0 23
49524: PUSH
49525: LD_VAR 0 24
49529: PUSH
49530: LD_VAR 0 25
49534: PUSH
49535: LD_VAR 0 26
49539: PUSH
49540: LD_VAR 0 27
49544: PUSH
49545: LD_VAR 0 28
49549: PUSH
49550: EMPTY
49551: LIST
49552: LIST
49553: LIST
49554: LIST
49555: LIST
49556: LIST
49557: PUSH
49558: LD_VAR 0 4
49562: PUSH
49563: LD_INT 1
49565: PLUS
49566: ARRAY
49567: ST_TO_ADDR
49568: GO 49571
49570: POP
49571: GO 50126
49573: LD_INT 2
49575: DOUBLE
49576: EQUAL
49577: IFTRUE 49587
49579: LD_INT 3
49581: DOUBLE
49582: EQUAL
49583: IFTRUE 49587
49585: GO 49643
49587: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
49588: LD_ADDR_VAR 0 9
49592: PUSH
49593: LD_VAR 0 29
49597: PUSH
49598: LD_VAR 0 30
49602: PUSH
49603: LD_VAR 0 31
49607: PUSH
49608: LD_VAR 0 32
49612: PUSH
49613: LD_VAR 0 33
49617: PUSH
49618: LD_VAR 0 34
49622: PUSH
49623: EMPTY
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: PUSH
49631: LD_VAR 0 4
49635: PUSH
49636: LD_INT 1
49638: PLUS
49639: ARRAY
49640: ST_TO_ADDR
49641: GO 50126
49643: LD_INT 16
49645: DOUBLE
49646: EQUAL
49647: IFTRUE 49705
49649: LD_INT 17
49651: DOUBLE
49652: EQUAL
49653: IFTRUE 49705
49655: LD_INT 18
49657: DOUBLE
49658: EQUAL
49659: IFTRUE 49705
49661: LD_INT 19
49663: DOUBLE
49664: EQUAL
49665: IFTRUE 49705
49667: LD_INT 22
49669: DOUBLE
49670: EQUAL
49671: IFTRUE 49705
49673: LD_INT 20
49675: DOUBLE
49676: EQUAL
49677: IFTRUE 49705
49679: LD_INT 21
49681: DOUBLE
49682: EQUAL
49683: IFTRUE 49705
49685: LD_INT 23
49687: DOUBLE
49688: EQUAL
49689: IFTRUE 49705
49691: LD_INT 24
49693: DOUBLE
49694: EQUAL
49695: IFTRUE 49705
49697: LD_INT 25
49699: DOUBLE
49700: EQUAL
49701: IFTRUE 49705
49703: GO 49761
49705: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
49706: LD_ADDR_VAR 0 9
49710: PUSH
49711: LD_VAR 0 35
49715: PUSH
49716: LD_VAR 0 36
49720: PUSH
49721: LD_VAR 0 37
49725: PUSH
49726: LD_VAR 0 38
49730: PUSH
49731: LD_VAR 0 39
49735: PUSH
49736: LD_VAR 0 40
49740: PUSH
49741: EMPTY
49742: LIST
49743: LIST
49744: LIST
49745: LIST
49746: LIST
49747: LIST
49748: PUSH
49749: LD_VAR 0 4
49753: PUSH
49754: LD_INT 1
49756: PLUS
49757: ARRAY
49758: ST_TO_ADDR
49759: GO 50126
49761: LD_INT 6
49763: DOUBLE
49764: EQUAL
49765: IFTRUE 49817
49767: LD_INT 7
49769: DOUBLE
49770: EQUAL
49771: IFTRUE 49817
49773: LD_INT 8
49775: DOUBLE
49776: EQUAL
49777: IFTRUE 49817
49779: LD_INT 13
49781: DOUBLE
49782: EQUAL
49783: IFTRUE 49817
49785: LD_INT 12
49787: DOUBLE
49788: EQUAL
49789: IFTRUE 49817
49791: LD_INT 15
49793: DOUBLE
49794: EQUAL
49795: IFTRUE 49817
49797: LD_INT 11
49799: DOUBLE
49800: EQUAL
49801: IFTRUE 49817
49803: LD_INT 14
49805: DOUBLE
49806: EQUAL
49807: IFTRUE 49817
49809: LD_INT 10
49811: DOUBLE
49812: EQUAL
49813: IFTRUE 49817
49815: GO 49873
49817: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
49818: LD_ADDR_VAR 0 9
49822: PUSH
49823: LD_VAR 0 41
49827: PUSH
49828: LD_VAR 0 42
49832: PUSH
49833: LD_VAR 0 43
49837: PUSH
49838: LD_VAR 0 44
49842: PUSH
49843: LD_VAR 0 45
49847: PUSH
49848: LD_VAR 0 46
49852: PUSH
49853: EMPTY
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: PUSH
49861: LD_VAR 0 4
49865: PUSH
49866: LD_INT 1
49868: PLUS
49869: ARRAY
49870: ST_TO_ADDR
49871: GO 50126
49873: LD_INT 36
49875: DOUBLE
49876: EQUAL
49877: IFTRUE 49881
49879: GO 49937
49881: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
49882: LD_ADDR_VAR 0 9
49886: PUSH
49887: LD_VAR 0 47
49891: PUSH
49892: LD_VAR 0 48
49896: PUSH
49897: LD_VAR 0 49
49901: PUSH
49902: LD_VAR 0 50
49906: PUSH
49907: LD_VAR 0 51
49911: PUSH
49912: LD_VAR 0 52
49916: PUSH
49917: EMPTY
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: PUSH
49925: LD_VAR 0 4
49929: PUSH
49930: LD_INT 1
49932: PLUS
49933: ARRAY
49934: ST_TO_ADDR
49935: GO 50126
49937: LD_INT 4
49939: DOUBLE
49940: EQUAL
49941: IFTRUE 49963
49943: LD_INT 5
49945: DOUBLE
49946: EQUAL
49947: IFTRUE 49963
49949: LD_INT 34
49951: DOUBLE
49952: EQUAL
49953: IFTRUE 49963
49955: LD_INT 37
49957: DOUBLE
49958: EQUAL
49959: IFTRUE 49963
49961: GO 50019
49963: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
49964: LD_ADDR_VAR 0 9
49968: PUSH
49969: LD_VAR 0 53
49973: PUSH
49974: LD_VAR 0 54
49978: PUSH
49979: LD_VAR 0 55
49983: PUSH
49984: LD_VAR 0 56
49988: PUSH
49989: LD_VAR 0 57
49993: PUSH
49994: LD_VAR 0 58
49998: PUSH
49999: EMPTY
50000: LIST
50001: LIST
50002: LIST
50003: LIST
50004: LIST
50005: LIST
50006: PUSH
50007: LD_VAR 0 4
50011: PUSH
50012: LD_INT 1
50014: PLUS
50015: ARRAY
50016: ST_TO_ADDR
50017: GO 50126
50019: LD_INT 31
50021: DOUBLE
50022: EQUAL
50023: IFTRUE 50069
50025: LD_INT 32
50027: DOUBLE
50028: EQUAL
50029: IFTRUE 50069
50031: LD_INT 33
50033: DOUBLE
50034: EQUAL
50035: IFTRUE 50069
50037: LD_INT 27
50039: DOUBLE
50040: EQUAL
50041: IFTRUE 50069
50043: LD_INT 26
50045: DOUBLE
50046: EQUAL
50047: IFTRUE 50069
50049: LD_INT 28
50051: DOUBLE
50052: EQUAL
50053: IFTRUE 50069
50055: LD_INT 29
50057: DOUBLE
50058: EQUAL
50059: IFTRUE 50069
50061: LD_INT 30
50063: DOUBLE
50064: EQUAL
50065: IFTRUE 50069
50067: GO 50125
50069: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
50070: LD_ADDR_VAR 0 9
50074: PUSH
50075: LD_VAR 0 59
50079: PUSH
50080: LD_VAR 0 60
50084: PUSH
50085: LD_VAR 0 61
50089: PUSH
50090: LD_VAR 0 62
50094: PUSH
50095: LD_VAR 0 63
50099: PUSH
50100: LD_VAR 0 64
50104: PUSH
50105: EMPTY
50106: LIST
50107: LIST
50108: LIST
50109: LIST
50110: LIST
50111: LIST
50112: PUSH
50113: LD_VAR 0 4
50117: PUSH
50118: LD_INT 1
50120: PLUS
50121: ARRAY
50122: ST_TO_ADDR
50123: GO 50126
50125: POP
// temp_list2 = [ ] ;
50126: LD_ADDR_VAR 0 10
50130: PUSH
50131: EMPTY
50132: ST_TO_ADDR
// for i in temp_list do
50133: LD_ADDR_VAR 0 8
50137: PUSH
50138: LD_VAR 0 9
50142: PUSH
50143: FOR_IN
50144: IFFALSE 50196
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
50146: LD_ADDR_VAR 0 10
50150: PUSH
50151: LD_VAR 0 10
50155: PUSH
50156: LD_VAR 0 8
50160: PUSH
50161: LD_INT 1
50163: ARRAY
50164: PUSH
50165: LD_VAR 0 2
50169: PLUS
50170: PUSH
50171: LD_VAR 0 8
50175: PUSH
50176: LD_INT 2
50178: ARRAY
50179: PUSH
50180: LD_VAR 0 3
50184: PLUS
50185: PUSH
50186: EMPTY
50187: LIST
50188: LIST
50189: PUSH
50190: EMPTY
50191: LIST
50192: ADD
50193: ST_TO_ADDR
50194: GO 50143
50196: POP
50197: POP
// result = temp_list2 ;
50198: LD_ADDR_VAR 0 7
50202: PUSH
50203: LD_VAR 0 10
50207: ST_TO_ADDR
// end ;
50208: LD_VAR 0 7
50212: RET
// export function EnemyInRange ( unit , dist ) ; begin
50213: LD_INT 0
50215: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
50216: LD_ADDR_VAR 0 3
50220: PUSH
50221: LD_VAR 0 1
50225: PPUSH
50226: CALL_OW 255
50230: PPUSH
50231: LD_VAR 0 1
50235: PPUSH
50236: CALL_OW 250
50240: PPUSH
50241: LD_VAR 0 1
50245: PPUSH
50246: CALL_OW 251
50250: PPUSH
50251: LD_VAR 0 2
50255: PPUSH
50256: CALL 23586 0 4
50260: PUSH
50261: LD_INT 4
50263: ARRAY
50264: ST_TO_ADDR
// end ;
50265: LD_VAR 0 3
50269: RET
// export function PlayerSeeMe ( unit ) ; begin
50270: LD_INT 0
50272: PPUSH
// result := See ( your_side , unit ) ;
50273: LD_ADDR_VAR 0 2
50277: PUSH
50278: LD_OWVAR 2
50282: PPUSH
50283: LD_VAR 0 1
50287: PPUSH
50288: CALL_OW 292
50292: ST_TO_ADDR
// end ;
50293: LD_VAR 0 2
50297: RET
// export function ReverseDir ( unit ) ; begin
50298: LD_INT 0
50300: PPUSH
// if not unit then
50301: LD_VAR 0 1
50305: NOT
50306: IFFALSE 50310
// exit ;
50308: GO 50333
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
50310: LD_ADDR_VAR 0 2
50314: PUSH
50315: LD_VAR 0 1
50319: PPUSH
50320: CALL_OW 254
50324: PUSH
50325: LD_INT 3
50327: PLUS
50328: PUSH
50329: LD_INT 6
50331: MOD
50332: ST_TO_ADDR
// end ;
50333: LD_VAR 0 2
50337: RET
// export function ReverseArray ( array ) ; var i ; begin
50338: LD_INT 0
50340: PPUSH
50341: PPUSH
// if not array then
50342: LD_VAR 0 1
50346: NOT
50347: IFFALSE 50351
// exit ;
50349: GO 50406
// result := [ ] ;
50351: LD_ADDR_VAR 0 2
50355: PUSH
50356: EMPTY
50357: ST_TO_ADDR
// for i := array downto 1 do
50358: LD_ADDR_VAR 0 3
50362: PUSH
50363: DOUBLE
50364: LD_VAR 0 1
50368: INC
50369: ST_TO_ADDR
50370: LD_INT 1
50372: PUSH
50373: FOR_DOWNTO
50374: IFFALSE 50404
// result := Join ( result , array [ i ] ) ;
50376: LD_ADDR_VAR 0 2
50380: PUSH
50381: LD_VAR 0 2
50385: PPUSH
50386: LD_VAR 0 1
50390: PUSH
50391: LD_VAR 0 3
50395: ARRAY
50396: PPUSH
50397: CALL 55071 0 2
50401: ST_TO_ADDR
50402: GO 50373
50404: POP
50405: POP
// end ;
50406: LD_VAR 0 2
50410: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
50411: LD_INT 0
50413: PPUSH
50414: PPUSH
50415: PPUSH
50416: PPUSH
50417: PPUSH
50418: PPUSH
// if not unit or not hexes then
50419: LD_VAR 0 1
50423: NOT
50424: PUSH
50425: LD_VAR 0 2
50429: NOT
50430: OR
50431: IFFALSE 50435
// exit ;
50433: GO 50558
// dist := 9999 ;
50435: LD_ADDR_VAR 0 5
50439: PUSH
50440: LD_INT 9999
50442: ST_TO_ADDR
// for i = 1 to hexes do
50443: LD_ADDR_VAR 0 4
50447: PUSH
50448: DOUBLE
50449: LD_INT 1
50451: DEC
50452: ST_TO_ADDR
50453: LD_VAR 0 2
50457: PUSH
50458: FOR_TO
50459: IFFALSE 50546
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
50461: LD_ADDR_VAR 0 6
50465: PUSH
50466: LD_VAR 0 1
50470: PPUSH
50471: LD_VAR 0 2
50475: PUSH
50476: LD_VAR 0 4
50480: ARRAY
50481: PUSH
50482: LD_INT 1
50484: ARRAY
50485: PPUSH
50486: LD_VAR 0 2
50490: PUSH
50491: LD_VAR 0 4
50495: ARRAY
50496: PUSH
50497: LD_INT 2
50499: ARRAY
50500: PPUSH
50501: CALL_OW 297
50505: ST_TO_ADDR
// if tdist < dist then
50506: LD_VAR 0 6
50510: PUSH
50511: LD_VAR 0 5
50515: LESS
50516: IFFALSE 50544
// begin hex := hexes [ i ] ;
50518: LD_ADDR_VAR 0 8
50522: PUSH
50523: LD_VAR 0 2
50527: PUSH
50528: LD_VAR 0 4
50532: ARRAY
50533: ST_TO_ADDR
// dist := tdist ;
50534: LD_ADDR_VAR 0 5
50538: PUSH
50539: LD_VAR 0 6
50543: ST_TO_ADDR
// end ; end ;
50544: GO 50458
50546: POP
50547: POP
// result := hex ;
50548: LD_ADDR_VAR 0 3
50552: PUSH
50553: LD_VAR 0 8
50557: ST_TO_ADDR
// end ;
50558: LD_VAR 0 3
50562: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
50563: LD_INT 0
50565: PPUSH
50566: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
50567: LD_VAR 0 1
50571: NOT
50572: PUSH
50573: LD_VAR 0 1
50577: PUSH
50578: LD_INT 21
50580: PUSH
50581: LD_INT 2
50583: PUSH
50584: EMPTY
50585: LIST
50586: LIST
50587: PUSH
50588: LD_INT 23
50590: PUSH
50591: LD_INT 2
50593: PUSH
50594: EMPTY
50595: LIST
50596: LIST
50597: PUSH
50598: EMPTY
50599: LIST
50600: LIST
50601: PPUSH
50602: CALL_OW 69
50606: IN
50607: NOT
50608: OR
50609: IFFALSE 50613
// exit ;
50611: GO 50660
// for i = 1 to 3 do
50613: LD_ADDR_VAR 0 3
50617: PUSH
50618: DOUBLE
50619: LD_INT 1
50621: DEC
50622: ST_TO_ADDR
50623: LD_INT 3
50625: PUSH
50626: FOR_TO
50627: IFFALSE 50658
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
50629: LD_VAR 0 1
50633: PPUSH
50634: CALL_OW 250
50638: PPUSH
50639: LD_VAR 0 1
50643: PPUSH
50644: CALL_OW 251
50648: PPUSH
50649: LD_INT 1
50651: PPUSH
50652: CALL_OW 453
50656: GO 50626
50658: POP
50659: POP
// end ;
50660: LD_VAR 0 2
50664: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
50665: LD_INT 0
50667: PPUSH
50668: PPUSH
50669: PPUSH
50670: PPUSH
50671: PPUSH
50672: PPUSH
// if not unit or not enemy_unit then
50673: LD_VAR 0 1
50677: NOT
50678: PUSH
50679: LD_VAR 0 2
50683: NOT
50684: OR
50685: IFFALSE 50689
// exit ;
50687: GO 51156
// if GetLives ( i ) < 250 then
50689: LD_VAR 0 4
50693: PPUSH
50694: CALL_OW 256
50698: PUSH
50699: LD_INT 250
50701: LESS
50702: IFFALSE 50715
// begin ComAutodestruct ( i ) ;
50704: LD_VAR 0 4
50708: PPUSH
50709: CALL 50563 0 1
// exit ;
50713: GO 51156
// end ; x := GetX ( enemy_unit ) ;
50715: LD_ADDR_VAR 0 7
50719: PUSH
50720: LD_VAR 0 2
50724: PPUSH
50725: CALL_OW 250
50729: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
50730: LD_ADDR_VAR 0 8
50734: PUSH
50735: LD_VAR 0 2
50739: PPUSH
50740: CALL_OW 251
50744: ST_TO_ADDR
// if not x or not y then
50745: LD_VAR 0 7
50749: NOT
50750: PUSH
50751: LD_VAR 0 8
50755: NOT
50756: OR
50757: IFFALSE 50761
// exit ;
50759: GO 51156
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
50761: LD_ADDR_VAR 0 6
50765: PUSH
50766: LD_VAR 0 7
50770: PPUSH
50771: LD_INT 0
50773: PPUSH
50774: LD_INT 4
50776: PPUSH
50777: CALL_OW 272
50781: PUSH
50782: LD_VAR 0 8
50786: PPUSH
50787: LD_INT 0
50789: PPUSH
50790: LD_INT 4
50792: PPUSH
50793: CALL_OW 273
50797: PUSH
50798: EMPTY
50799: LIST
50800: LIST
50801: PUSH
50802: LD_VAR 0 7
50806: PPUSH
50807: LD_INT 1
50809: PPUSH
50810: LD_INT 4
50812: PPUSH
50813: CALL_OW 272
50817: PUSH
50818: LD_VAR 0 8
50822: PPUSH
50823: LD_INT 1
50825: PPUSH
50826: LD_INT 4
50828: PPUSH
50829: CALL_OW 273
50833: PUSH
50834: EMPTY
50835: LIST
50836: LIST
50837: PUSH
50838: LD_VAR 0 7
50842: PPUSH
50843: LD_INT 2
50845: PPUSH
50846: LD_INT 4
50848: PPUSH
50849: CALL_OW 272
50853: PUSH
50854: LD_VAR 0 8
50858: PPUSH
50859: LD_INT 2
50861: PPUSH
50862: LD_INT 4
50864: PPUSH
50865: CALL_OW 273
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: PUSH
50874: LD_VAR 0 7
50878: PPUSH
50879: LD_INT 3
50881: PPUSH
50882: LD_INT 4
50884: PPUSH
50885: CALL_OW 272
50889: PUSH
50890: LD_VAR 0 8
50894: PPUSH
50895: LD_INT 3
50897: PPUSH
50898: LD_INT 4
50900: PPUSH
50901: CALL_OW 273
50905: PUSH
50906: EMPTY
50907: LIST
50908: LIST
50909: PUSH
50910: LD_VAR 0 7
50914: PPUSH
50915: LD_INT 4
50917: PPUSH
50918: LD_INT 4
50920: PPUSH
50921: CALL_OW 272
50925: PUSH
50926: LD_VAR 0 8
50930: PPUSH
50931: LD_INT 4
50933: PPUSH
50934: LD_INT 4
50936: PPUSH
50937: CALL_OW 273
50941: PUSH
50942: EMPTY
50943: LIST
50944: LIST
50945: PUSH
50946: LD_VAR 0 7
50950: PPUSH
50951: LD_INT 5
50953: PPUSH
50954: LD_INT 4
50956: PPUSH
50957: CALL_OW 272
50961: PUSH
50962: LD_VAR 0 8
50966: PPUSH
50967: LD_INT 5
50969: PPUSH
50970: LD_INT 4
50972: PPUSH
50973: CALL_OW 273
50977: PUSH
50978: EMPTY
50979: LIST
50980: LIST
50981: PUSH
50982: EMPTY
50983: LIST
50984: LIST
50985: LIST
50986: LIST
50987: LIST
50988: LIST
50989: ST_TO_ADDR
// for i = tmp downto 1 do
50990: LD_ADDR_VAR 0 4
50994: PUSH
50995: DOUBLE
50996: LD_VAR 0 6
51000: INC
51001: ST_TO_ADDR
51002: LD_INT 1
51004: PUSH
51005: FOR_DOWNTO
51006: IFFALSE 51107
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
51008: LD_VAR 0 6
51012: PUSH
51013: LD_VAR 0 4
51017: ARRAY
51018: PUSH
51019: LD_INT 1
51021: ARRAY
51022: PPUSH
51023: LD_VAR 0 6
51027: PUSH
51028: LD_VAR 0 4
51032: ARRAY
51033: PUSH
51034: LD_INT 2
51036: ARRAY
51037: PPUSH
51038: CALL_OW 488
51042: NOT
51043: PUSH
51044: LD_VAR 0 6
51048: PUSH
51049: LD_VAR 0 4
51053: ARRAY
51054: PUSH
51055: LD_INT 1
51057: ARRAY
51058: PPUSH
51059: LD_VAR 0 6
51063: PUSH
51064: LD_VAR 0 4
51068: ARRAY
51069: PUSH
51070: LD_INT 2
51072: ARRAY
51073: PPUSH
51074: CALL_OW 428
51078: PUSH
51079: LD_INT 0
51081: NONEQUAL
51082: OR
51083: IFFALSE 51105
// tmp := Delete ( tmp , i ) ;
51085: LD_ADDR_VAR 0 6
51089: PUSH
51090: LD_VAR 0 6
51094: PPUSH
51095: LD_VAR 0 4
51099: PPUSH
51100: CALL_OW 3
51104: ST_TO_ADDR
51105: GO 51005
51107: POP
51108: POP
// j := GetClosestHex ( unit , tmp ) ;
51109: LD_ADDR_VAR 0 5
51113: PUSH
51114: LD_VAR 0 1
51118: PPUSH
51119: LD_VAR 0 6
51123: PPUSH
51124: CALL 50411 0 2
51128: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
51129: LD_VAR 0 1
51133: PPUSH
51134: LD_VAR 0 5
51138: PUSH
51139: LD_INT 1
51141: ARRAY
51142: PPUSH
51143: LD_VAR 0 5
51147: PUSH
51148: LD_INT 2
51150: ARRAY
51151: PPUSH
51152: CALL_OW 111
// end ;
51156: LD_VAR 0 3
51160: RET
// export function PrepareApemanSoldier ( ) ; begin
51161: LD_INT 0
51163: PPUSH
// uc_nation := 0 ;
51164: LD_ADDR_OWVAR 21
51168: PUSH
51169: LD_INT 0
51171: ST_TO_ADDR
// hc_sex := sex_male ;
51172: LD_ADDR_OWVAR 27
51176: PUSH
51177: LD_INT 1
51179: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
51180: LD_ADDR_OWVAR 28
51184: PUSH
51185: LD_INT 15
51187: ST_TO_ADDR
// hc_gallery :=  ;
51188: LD_ADDR_OWVAR 33
51192: PUSH
51193: LD_STRING 
51195: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51196: LD_ADDR_OWVAR 31
51200: PUSH
51201: LD_INT 0
51203: PPUSH
51204: LD_INT 3
51206: PPUSH
51207: CALL_OW 12
51211: PUSH
51212: LD_INT 0
51214: PPUSH
51215: LD_INT 3
51217: PPUSH
51218: CALL_OW 12
51222: PUSH
51223: LD_INT 0
51225: PUSH
51226: LD_INT 0
51228: PUSH
51229: EMPTY
51230: LIST
51231: LIST
51232: LIST
51233: LIST
51234: ST_TO_ADDR
// end ;
51235: LD_VAR 0 1
51239: RET
// export function PrepareApemanEngineer ( ) ; begin
51240: LD_INT 0
51242: PPUSH
// uc_nation := 0 ;
51243: LD_ADDR_OWVAR 21
51247: PUSH
51248: LD_INT 0
51250: ST_TO_ADDR
// hc_sex := sex_male ;
51251: LD_ADDR_OWVAR 27
51255: PUSH
51256: LD_INT 1
51258: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
51259: LD_ADDR_OWVAR 28
51263: PUSH
51264: LD_INT 16
51266: ST_TO_ADDR
// hc_gallery :=  ;
51267: LD_ADDR_OWVAR 33
51271: PUSH
51272: LD_STRING 
51274: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51275: LD_ADDR_OWVAR 31
51279: PUSH
51280: LD_INT 0
51282: PPUSH
51283: LD_INT 3
51285: PPUSH
51286: CALL_OW 12
51290: PUSH
51291: LD_INT 0
51293: PPUSH
51294: LD_INT 3
51296: PPUSH
51297: CALL_OW 12
51301: PUSH
51302: LD_INT 0
51304: PUSH
51305: LD_INT 0
51307: PUSH
51308: EMPTY
51309: LIST
51310: LIST
51311: LIST
51312: LIST
51313: ST_TO_ADDR
// end ;
51314: LD_VAR 0 1
51318: RET
// export function PrepareApeman ( agressivity ) ; begin
51319: LD_INT 0
51321: PPUSH
// uc_side := 0 ;
51322: LD_ADDR_OWVAR 20
51326: PUSH
51327: LD_INT 0
51329: ST_TO_ADDR
// uc_nation := 0 ;
51330: LD_ADDR_OWVAR 21
51334: PUSH
51335: LD_INT 0
51337: ST_TO_ADDR
// hc_sex := sex_male ;
51338: LD_ADDR_OWVAR 27
51342: PUSH
51343: LD_INT 1
51345: ST_TO_ADDR
// hc_class := class_apeman ;
51346: LD_ADDR_OWVAR 28
51350: PUSH
51351: LD_INT 12
51353: ST_TO_ADDR
// hc_gallery :=  ;
51354: LD_ADDR_OWVAR 33
51358: PUSH
51359: LD_STRING 
51361: ST_TO_ADDR
// if agressivity = 0 then
51362: LD_VAR 0 1
51366: PUSH
51367: LD_INT 0
51369: EQUAL
51370: IFFALSE 51382
// hc_agressivity := 0 else
51372: LD_ADDR_OWVAR 35
51376: PUSH
51377: LD_INT 0
51379: ST_TO_ADDR
51380: GO 51403
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51382: LD_ADDR_OWVAR 35
51386: PUSH
51387: LD_VAR 0 1
51391: NEG
51392: PPUSH
51393: LD_VAR 0 1
51397: PPUSH
51398: CALL_OW 12
51402: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
51403: LD_ADDR_OWVAR 31
51407: PUSH
51408: LD_INT 0
51410: PPUSH
51411: LD_INT 3
51413: PPUSH
51414: CALL_OW 12
51418: PUSH
51419: LD_INT 0
51421: PPUSH
51422: LD_INT 3
51424: PPUSH
51425: CALL_OW 12
51429: PUSH
51430: LD_INT 0
51432: PUSH
51433: LD_INT 0
51435: PUSH
51436: EMPTY
51437: LIST
51438: LIST
51439: LIST
51440: LIST
51441: ST_TO_ADDR
// end ;
51442: LD_VAR 0 2
51446: RET
// export function PrepareTiger ( agressivity ) ; begin
51447: LD_INT 0
51449: PPUSH
// uc_side := 0 ;
51450: LD_ADDR_OWVAR 20
51454: PUSH
51455: LD_INT 0
51457: ST_TO_ADDR
// uc_nation := 0 ;
51458: LD_ADDR_OWVAR 21
51462: PUSH
51463: LD_INT 0
51465: ST_TO_ADDR
// hc_class := class_tiger ;
51466: LD_ADDR_OWVAR 28
51470: PUSH
51471: LD_INT 14
51473: ST_TO_ADDR
// hc_gallery :=  ;
51474: LD_ADDR_OWVAR 33
51478: PUSH
51479: LD_STRING 
51481: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
51482: LD_ADDR_OWVAR 35
51486: PUSH
51487: LD_VAR 0 1
51491: NEG
51492: PPUSH
51493: LD_VAR 0 1
51497: PPUSH
51498: CALL_OW 12
51502: ST_TO_ADDR
// end ;
51503: LD_VAR 0 2
51507: RET
// export function PrepareEnchidna ( ) ; begin
51508: LD_INT 0
51510: PPUSH
// uc_side := 0 ;
51511: LD_ADDR_OWVAR 20
51515: PUSH
51516: LD_INT 0
51518: ST_TO_ADDR
// uc_nation := 0 ;
51519: LD_ADDR_OWVAR 21
51523: PUSH
51524: LD_INT 0
51526: ST_TO_ADDR
// hc_class := class_baggie ;
51527: LD_ADDR_OWVAR 28
51531: PUSH
51532: LD_INT 13
51534: ST_TO_ADDR
// hc_gallery :=  ;
51535: LD_ADDR_OWVAR 33
51539: PUSH
51540: LD_STRING 
51542: ST_TO_ADDR
// end ;
51543: LD_VAR 0 1
51547: RET
// export function PrepareFrog ( ) ; begin
51548: LD_INT 0
51550: PPUSH
// uc_side := 0 ;
51551: LD_ADDR_OWVAR 20
51555: PUSH
51556: LD_INT 0
51558: ST_TO_ADDR
// uc_nation := 0 ;
51559: LD_ADDR_OWVAR 21
51563: PUSH
51564: LD_INT 0
51566: ST_TO_ADDR
// hc_class := class_frog ;
51567: LD_ADDR_OWVAR 28
51571: PUSH
51572: LD_INT 19
51574: ST_TO_ADDR
// hc_gallery :=  ;
51575: LD_ADDR_OWVAR 33
51579: PUSH
51580: LD_STRING 
51582: ST_TO_ADDR
// end ;
51583: LD_VAR 0 1
51587: RET
// export function PrepareFish ( ) ; begin
51588: LD_INT 0
51590: PPUSH
// uc_side := 0 ;
51591: LD_ADDR_OWVAR 20
51595: PUSH
51596: LD_INT 0
51598: ST_TO_ADDR
// uc_nation := 0 ;
51599: LD_ADDR_OWVAR 21
51603: PUSH
51604: LD_INT 0
51606: ST_TO_ADDR
// hc_class := class_fish ;
51607: LD_ADDR_OWVAR 28
51611: PUSH
51612: LD_INT 20
51614: ST_TO_ADDR
// hc_gallery :=  ;
51615: LD_ADDR_OWVAR 33
51619: PUSH
51620: LD_STRING 
51622: ST_TO_ADDR
// end ;
51623: LD_VAR 0 1
51627: RET
// export function PrepareBird ( ) ; begin
51628: LD_INT 0
51630: PPUSH
// uc_side := 0 ;
51631: LD_ADDR_OWVAR 20
51635: PUSH
51636: LD_INT 0
51638: ST_TO_ADDR
// uc_nation := 0 ;
51639: LD_ADDR_OWVAR 21
51643: PUSH
51644: LD_INT 0
51646: ST_TO_ADDR
// hc_class := class_phororhacos ;
51647: LD_ADDR_OWVAR 28
51651: PUSH
51652: LD_INT 18
51654: ST_TO_ADDR
// hc_gallery :=  ;
51655: LD_ADDR_OWVAR 33
51659: PUSH
51660: LD_STRING 
51662: ST_TO_ADDR
// end ;
51663: LD_VAR 0 1
51667: RET
// export function PrepareHorse ( ) ; begin
51668: LD_INT 0
51670: PPUSH
// uc_side := 0 ;
51671: LD_ADDR_OWVAR 20
51675: PUSH
51676: LD_INT 0
51678: ST_TO_ADDR
// uc_nation := 0 ;
51679: LD_ADDR_OWVAR 21
51683: PUSH
51684: LD_INT 0
51686: ST_TO_ADDR
// hc_class := class_horse ;
51687: LD_ADDR_OWVAR 28
51691: PUSH
51692: LD_INT 21
51694: ST_TO_ADDR
// hc_gallery :=  ;
51695: LD_ADDR_OWVAR 33
51699: PUSH
51700: LD_STRING 
51702: ST_TO_ADDR
// end ;
51703: LD_VAR 0 1
51707: RET
// export function PrepareMastodont ( ) ; begin
51708: LD_INT 0
51710: PPUSH
// uc_side := 0 ;
51711: LD_ADDR_OWVAR 20
51715: PUSH
51716: LD_INT 0
51718: ST_TO_ADDR
// uc_nation := 0 ;
51719: LD_ADDR_OWVAR 21
51723: PUSH
51724: LD_INT 0
51726: ST_TO_ADDR
// vc_chassis := class_mastodont ;
51727: LD_ADDR_OWVAR 37
51731: PUSH
51732: LD_INT 31
51734: ST_TO_ADDR
// vc_control := control_rider ;
51735: LD_ADDR_OWVAR 38
51739: PUSH
51740: LD_INT 4
51742: ST_TO_ADDR
// end ;
51743: LD_VAR 0 1
51747: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
51748: LD_INT 0
51750: PPUSH
51751: PPUSH
51752: PPUSH
// uc_side = 0 ;
51753: LD_ADDR_OWVAR 20
51757: PUSH
51758: LD_INT 0
51760: ST_TO_ADDR
// uc_nation = 0 ;
51761: LD_ADDR_OWVAR 21
51765: PUSH
51766: LD_INT 0
51768: ST_TO_ADDR
// InitHc_All ( ) ;
51769: CALL_OW 584
// InitVc ;
51773: CALL_OW 20
// if mastodonts then
51777: LD_VAR 0 6
51781: IFFALSE 51848
// for i = 1 to mastodonts do
51783: LD_ADDR_VAR 0 11
51787: PUSH
51788: DOUBLE
51789: LD_INT 1
51791: DEC
51792: ST_TO_ADDR
51793: LD_VAR 0 6
51797: PUSH
51798: FOR_TO
51799: IFFALSE 51846
// begin vc_chassis := 31 ;
51801: LD_ADDR_OWVAR 37
51805: PUSH
51806: LD_INT 31
51808: ST_TO_ADDR
// vc_control := control_rider ;
51809: LD_ADDR_OWVAR 38
51813: PUSH
51814: LD_INT 4
51816: ST_TO_ADDR
// animal := CreateVehicle ;
51817: LD_ADDR_VAR 0 12
51821: PUSH
51822: CALL_OW 45
51826: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51827: LD_VAR 0 12
51831: PPUSH
51832: LD_VAR 0 8
51836: PPUSH
51837: LD_INT 0
51839: PPUSH
51840: CALL 53976 0 3
// end ;
51844: GO 51798
51846: POP
51847: POP
// if horses then
51848: LD_VAR 0 5
51852: IFFALSE 51919
// for i = 1 to horses do
51854: LD_ADDR_VAR 0 11
51858: PUSH
51859: DOUBLE
51860: LD_INT 1
51862: DEC
51863: ST_TO_ADDR
51864: LD_VAR 0 5
51868: PUSH
51869: FOR_TO
51870: IFFALSE 51917
// begin hc_class := 21 ;
51872: LD_ADDR_OWVAR 28
51876: PUSH
51877: LD_INT 21
51879: ST_TO_ADDR
// hc_gallery :=  ;
51880: LD_ADDR_OWVAR 33
51884: PUSH
51885: LD_STRING 
51887: ST_TO_ADDR
// animal := CreateHuman ;
51888: LD_ADDR_VAR 0 12
51892: PUSH
51893: CALL_OW 44
51897: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51898: LD_VAR 0 12
51902: PPUSH
51903: LD_VAR 0 8
51907: PPUSH
51908: LD_INT 0
51910: PPUSH
51911: CALL 53976 0 3
// end ;
51915: GO 51869
51917: POP
51918: POP
// if birds then
51919: LD_VAR 0 1
51923: IFFALSE 51990
// for i = 1 to birds do
51925: LD_ADDR_VAR 0 11
51929: PUSH
51930: DOUBLE
51931: LD_INT 1
51933: DEC
51934: ST_TO_ADDR
51935: LD_VAR 0 1
51939: PUSH
51940: FOR_TO
51941: IFFALSE 51988
// begin hc_class := 18 ;
51943: LD_ADDR_OWVAR 28
51947: PUSH
51948: LD_INT 18
51950: ST_TO_ADDR
// hc_gallery =  ;
51951: LD_ADDR_OWVAR 33
51955: PUSH
51956: LD_STRING 
51958: ST_TO_ADDR
// animal := CreateHuman ;
51959: LD_ADDR_VAR 0 12
51963: PUSH
51964: CALL_OW 44
51968: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
51969: LD_VAR 0 12
51973: PPUSH
51974: LD_VAR 0 8
51978: PPUSH
51979: LD_INT 0
51981: PPUSH
51982: CALL 53976 0 3
// end ;
51986: GO 51940
51988: POP
51989: POP
// if tigers then
51990: LD_VAR 0 2
51994: IFFALSE 52078
// for i = 1 to tigers do
51996: LD_ADDR_VAR 0 11
52000: PUSH
52001: DOUBLE
52002: LD_INT 1
52004: DEC
52005: ST_TO_ADDR
52006: LD_VAR 0 2
52010: PUSH
52011: FOR_TO
52012: IFFALSE 52076
// begin hc_class = class_tiger ;
52014: LD_ADDR_OWVAR 28
52018: PUSH
52019: LD_INT 14
52021: ST_TO_ADDR
// hc_gallery =  ;
52022: LD_ADDR_OWVAR 33
52026: PUSH
52027: LD_STRING 
52029: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
52030: LD_ADDR_OWVAR 35
52034: PUSH
52035: LD_INT 7
52037: NEG
52038: PPUSH
52039: LD_INT 7
52041: PPUSH
52042: CALL_OW 12
52046: ST_TO_ADDR
// animal := CreateHuman ;
52047: LD_ADDR_VAR 0 12
52051: PUSH
52052: CALL_OW 44
52056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52057: LD_VAR 0 12
52061: PPUSH
52062: LD_VAR 0 8
52066: PPUSH
52067: LD_INT 0
52069: PPUSH
52070: CALL 53976 0 3
// end ;
52074: GO 52011
52076: POP
52077: POP
// if apemans then
52078: LD_VAR 0 3
52082: IFFALSE 52205
// for i = 1 to apemans do
52084: LD_ADDR_VAR 0 11
52088: PUSH
52089: DOUBLE
52090: LD_INT 1
52092: DEC
52093: ST_TO_ADDR
52094: LD_VAR 0 3
52098: PUSH
52099: FOR_TO
52100: IFFALSE 52203
// begin hc_class = class_apeman ;
52102: LD_ADDR_OWVAR 28
52106: PUSH
52107: LD_INT 12
52109: ST_TO_ADDR
// hc_gallery =  ;
52110: LD_ADDR_OWVAR 33
52114: PUSH
52115: LD_STRING 
52117: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
52118: LD_ADDR_OWVAR 35
52122: PUSH
52123: LD_INT 2
52125: NEG
52126: PPUSH
52127: LD_INT 2
52129: PPUSH
52130: CALL_OW 12
52134: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
52135: LD_ADDR_OWVAR 31
52139: PUSH
52140: LD_INT 1
52142: PPUSH
52143: LD_INT 3
52145: PPUSH
52146: CALL_OW 12
52150: PUSH
52151: LD_INT 1
52153: PPUSH
52154: LD_INT 3
52156: PPUSH
52157: CALL_OW 12
52161: PUSH
52162: LD_INT 0
52164: PUSH
52165: LD_INT 0
52167: PUSH
52168: EMPTY
52169: LIST
52170: LIST
52171: LIST
52172: LIST
52173: ST_TO_ADDR
// animal := CreateHuman ;
52174: LD_ADDR_VAR 0 12
52178: PUSH
52179: CALL_OW 44
52183: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52184: LD_VAR 0 12
52188: PPUSH
52189: LD_VAR 0 8
52193: PPUSH
52194: LD_INT 0
52196: PPUSH
52197: CALL 53976 0 3
// end ;
52201: GO 52099
52203: POP
52204: POP
// if enchidnas then
52205: LD_VAR 0 4
52209: IFFALSE 52276
// for i = 1 to enchidnas do
52211: LD_ADDR_VAR 0 11
52215: PUSH
52216: DOUBLE
52217: LD_INT 1
52219: DEC
52220: ST_TO_ADDR
52221: LD_VAR 0 4
52225: PUSH
52226: FOR_TO
52227: IFFALSE 52274
// begin hc_class = 13 ;
52229: LD_ADDR_OWVAR 28
52233: PUSH
52234: LD_INT 13
52236: ST_TO_ADDR
// hc_gallery =  ;
52237: LD_ADDR_OWVAR 33
52241: PUSH
52242: LD_STRING 
52244: ST_TO_ADDR
// animal := CreateHuman ;
52245: LD_ADDR_VAR 0 12
52249: PUSH
52250: CALL_OW 44
52254: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
52255: LD_VAR 0 12
52259: PPUSH
52260: LD_VAR 0 8
52264: PPUSH
52265: LD_INT 0
52267: PPUSH
52268: CALL 53976 0 3
// end ;
52272: GO 52226
52274: POP
52275: POP
// if fishes then
52276: LD_VAR 0 7
52280: IFFALSE 52347
// for i = 1 to fishes do
52282: LD_ADDR_VAR 0 11
52286: PUSH
52287: DOUBLE
52288: LD_INT 1
52290: DEC
52291: ST_TO_ADDR
52292: LD_VAR 0 7
52296: PUSH
52297: FOR_TO
52298: IFFALSE 52345
// begin hc_class = 20 ;
52300: LD_ADDR_OWVAR 28
52304: PUSH
52305: LD_INT 20
52307: ST_TO_ADDR
// hc_gallery =  ;
52308: LD_ADDR_OWVAR 33
52312: PUSH
52313: LD_STRING 
52315: ST_TO_ADDR
// animal := CreateHuman ;
52316: LD_ADDR_VAR 0 12
52320: PUSH
52321: CALL_OW 44
52325: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
52326: LD_VAR 0 12
52330: PPUSH
52331: LD_VAR 0 9
52335: PPUSH
52336: LD_INT 0
52338: PPUSH
52339: CALL 53976 0 3
// end ;
52343: GO 52297
52345: POP
52346: POP
// end ;
52347: LD_VAR 0 10
52351: RET
// export function WantHeal ( sci , unit ) ; begin
52352: LD_INT 0
52354: PPUSH
// if GetTaskList ( sci ) > 0 then
52355: LD_VAR 0 1
52359: PPUSH
52360: CALL_OW 437
52364: PUSH
52365: LD_INT 0
52367: GREATER
52368: IFFALSE 52438
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
52370: LD_VAR 0 1
52374: PPUSH
52375: CALL_OW 437
52379: PUSH
52380: LD_INT 1
52382: ARRAY
52383: PUSH
52384: LD_INT 1
52386: ARRAY
52387: PUSH
52388: LD_STRING l
52390: EQUAL
52391: PUSH
52392: LD_VAR 0 1
52396: PPUSH
52397: CALL_OW 437
52401: PUSH
52402: LD_INT 1
52404: ARRAY
52405: PUSH
52406: LD_INT 4
52408: ARRAY
52409: PUSH
52410: LD_VAR 0 2
52414: EQUAL
52415: AND
52416: IFFALSE 52428
// result := true else
52418: LD_ADDR_VAR 0 3
52422: PUSH
52423: LD_INT 1
52425: ST_TO_ADDR
52426: GO 52436
// result := false ;
52428: LD_ADDR_VAR 0 3
52432: PUSH
52433: LD_INT 0
52435: ST_TO_ADDR
// end else
52436: GO 52446
// result := false ;
52438: LD_ADDR_VAR 0 3
52442: PUSH
52443: LD_INT 0
52445: ST_TO_ADDR
// end ;
52446: LD_VAR 0 3
52450: RET
// export function HealTarget ( sci ) ; begin
52451: LD_INT 0
52453: PPUSH
// if not sci then
52454: LD_VAR 0 1
52458: NOT
52459: IFFALSE 52463
// exit ;
52461: GO 52528
// result := 0 ;
52463: LD_ADDR_VAR 0 2
52467: PUSH
52468: LD_INT 0
52470: ST_TO_ADDR
// if GetTaskList ( sci ) then
52471: LD_VAR 0 1
52475: PPUSH
52476: CALL_OW 437
52480: IFFALSE 52528
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
52482: LD_VAR 0 1
52486: PPUSH
52487: CALL_OW 437
52491: PUSH
52492: LD_INT 1
52494: ARRAY
52495: PUSH
52496: LD_INT 1
52498: ARRAY
52499: PUSH
52500: LD_STRING l
52502: EQUAL
52503: IFFALSE 52528
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
52505: LD_ADDR_VAR 0 2
52509: PUSH
52510: LD_VAR 0 1
52514: PPUSH
52515: CALL_OW 437
52519: PUSH
52520: LD_INT 1
52522: ARRAY
52523: PUSH
52524: LD_INT 4
52526: ARRAY
52527: ST_TO_ADDR
// end ;
52528: LD_VAR 0 2
52532: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
52533: LD_INT 0
52535: PPUSH
52536: PPUSH
52537: PPUSH
52538: PPUSH
// if not base_units then
52539: LD_VAR 0 1
52543: NOT
52544: IFFALSE 52548
// exit ;
52546: GO 52635
// result := false ;
52548: LD_ADDR_VAR 0 2
52552: PUSH
52553: LD_INT 0
52555: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
52556: LD_ADDR_VAR 0 5
52560: PUSH
52561: LD_VAR 0 1
52565: PPUSH
52566: LD_INT 21
52568: PUSH
52569: LD_INT 3
52571: PUSH
52572: EMPTY
52573: LIST
52574: LIST
52575: PPUSH
52576: CALL_OW 72
52580: ST_TO_ADDR
// if not tmp then
52581: LD_VAR 0 5
52585: NOT
52586: IFFALSE 52590
// exit ;
52588: GO 52635
// for i in tmp do
52590: LD_ADDR_VAR 0 3
52594: PUSH
52595: LD_VAR 0 5
52599: PUSH
52600: FOR_IN
52601: IFFALSE 52633
// begin result := EnemyInRange ( i , 22 ) ;
52603: LD_ADDR_VAR 0 2
52607: PUSH
52608: LD_VAR 0 3
52612: PPUSH
52613: LD_INT 22
52615: PPUSH
52616: CALL 50213 0 2
52620: ST_TO_ADDR
// if result then
52621: LD_VAR 0 2
52625: IFFALSE 52631
// exit ;
52627: POP
52628: POP
52629: GO 52635
// end ;
52631: GO 52600
52633: POP
52634: POP
// end ;
52635: LD_VAR 0 2
52639: RET
// export function FilterByTag ( units , tag ) ; begin
52640: LD_INT 0
52642: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
52643: LD_ADDR_VAR 0 3
52647: PUSH
52648: LD_VAR 0 1
52652: PPUSH
52653: LD_INT 120
52655: PUSH
52656: LD_VAR 0 2
52660: PUSH
52661: EMPTY
52662: LIST
52663: LIST
52664: PPUSH
52665: CALL_OW 72
52669: ST_TO_ADDR
// end ;
52670: LD_VAR 0 3
52674: RET
// export function IsDriver ( un ) ; begin
52675: LD_INT 0
52677: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
52678: LD_ADDR_VAR 0 2
52682: PUSH
52683: LD_VAR 0 1
52687: PUSH
52688: LD_INT 55
52690: PUSH
52691: EMPTY
52692: LIST
52693: PPUSH
52694: CALL_OW 69
52698: IN
52699: ST_TO_ADDR
// end ;
52700: LD_VAR 0 2
52704: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
52705: LD_INT 0
52707: PPUSH
52708: PPUSH
// list := [ ] ;
52709: LD_ADDR_VAR 0 5
52713: PUSH
52714: EMPTY
52715: ST_TO_ADDR
// case d of 0 :
52716: LD_VAR 0 3
52720: PUSH
52721: LD_INT 0
52723: DOUBLE
52724: EQUAL
52725: IFTRUE 52729
52727: GO 52862
52729: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
52730: LD_ADDR_VAR 0 5
52734: PUSH
52735: LD_VAR 0 1
52739: PUSH
52740: LD_INT 4
52742: MINUS
52743: PUSH
52744: LD_VAR 0 2
52748: PUSH
52749: LD_INT 4
52751: MINUS
52752: PUSH
52753: LD_INT 2
52755: PUSH
52756: EMPTY
52757: LIST
52758: LIST
52759: LIST
52760: PUSH
52761: LD_VAR 0 1
52765: PUSH
52766: LD_INT 3
52768: MINUS
52769: PUSH
52770: LD_VAR 0 2
52774: PUSH
52775: LD_INT 1
52777: PUSH
52778: EMPTY
52779: LIST
52780: LIST
52781: LIST
52782: PUSH
52783: LD_VAR 0 1
52787: PUSH
52788: LD_INT 4
52790: PLUS
52791: PUSH
52792: LD_VAR 0 2
52796: PUSH
52797: LD_INT 4
52799: PUSH
52800: EMPTY
52801: LIST
52802: LIST
52803: LIST
52804: PUSH
52805: LD_VAR 0 1
52809: PUSH
52810: LD_INT 3
52812: PLUS
52813: PUSH
52814: LD_VAR 0 2
52818: PUSH
52819: LD_INT 3
52821: PLUS
52822: PUSH
52823: LD_INT 5
52825: PUSH
52826: EMPTY
52827: LIST
52828: LIST
52829: LIST
52830: PUSH
52831: LD_VAR 0 1
52835: PUSH
52836: LD_VAR 0 2
52840: PUSH
52841: LD_INT 4
52843: PLUS
52844: PUSH
52845: LD_INT 0
52847: PUSH
52848: EMPTY
52849: LIST
52850: LIST
52851: LIST
52852: PUSH
52853: EMPTY
52854: LIST
52855: LIST
52856: LIST
52857: LIST
52858: LIST
52859: ST_TO_ADDR
// end ; 1 :
52860: GO 53560
52862: LD_INT 1
52864: DOUBLE
52865: EQUAL
52866: IFTRUE 52870
52868: GO 53003
52870: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
52871: LD_ADDR_VAR 0 5
52875: PUSH
52876: LD_VAR 0 1
52880: PUSH
52881: LD_VAR 0 2
52885: PUSH
52886: LD_INT 4
52888: MINUS
52889: PUSH
52890: LD_INT 3
52892: PUSH
52893: EMPTY
52894: LIST
52895: LIST
52896: LIST
52897: PUSH
52898: LD_VAR 0 1
52902: PUSH
52903: LD_INT 3
52905: MINUS
52906: PUSH
52907: LD_VAR 0 2
52911: PUSH
52912: LD_INT 3
52914: MINUS
52915: PUSH
52916: LD_INT 2
52918: PUSH
52919: EMPTY
52920: LIST
52921: LIST
52922: LIST
52923: PUSH
52924: LD_VAR 0 1
52928: PUSH
52929: LD_INT 4
52931: MINUS
52932: PUSH
52933: LD_VAR 0 2
52937: PUSH
52938: LD_INT 1
52940: PUSH
52941: EMPTY
52942: LIST
52943: LIST
52944: LIST
52945: PUSH
52946: LD_VAR 0 1
52950: PUSH
52951: LD_VAR 0 2
52955: PUSH
52956: LD_INT 3
52958: PLUS
52959: PUSH
52960: LD_INT 0
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: LIST
52967: PUSH
52968: LD_VAR 0 1
52972: PUSH
52973: LD_INT 4
52975: PLUS
52976: PUSH
52977: LD_VAR 0 2
52981: PUSH
52982: LD_INT 4
52984: PLUS
52985: PUSH
52986: LD_INT 5
52988: PUSH
52989: EMPTY
52990: LIST
52991: LIST
52992: LIST
52993: PUSH
52994: EMPTY
52995: LIST
52996: LIST
52997: LIST
52998: LIST
52999: LIST
53000: ST_TO_ADDR
// end ; 2 :
53001: GO 53560
53003: LD_INT 2
53005: DOUBLE
53006: EQUAL
53007: IFTRUE 53011
53009: GO 53140
53011: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
53012: LD_ADDR_VAR 0 5
53016: PUSH
53017: LD_VAR 0 1
53021: PUSH
53022: LD_VAR 0 2
53026: PUSH
53027: LD_INT 3
53029: MINUS
53030: PUSH
53031: LD_INT 3
53033: PUSH
53034: EMPTY
53035: LIST
53036: LIST
53037: LIST
53038: PUSH
53039: LD_VAR 0 1
53043: PUSH
53044: LD_INT 4
53046: PLUS
53047: PUSH
53048: LD_VAR 0 2
53052: PUSH
53053: LD_INT 4
53055: PUSH
53056: EMPTY
53057: LIST
53058: LIST
53059: LIST
53060: PUSH
53061: LD_VAR 0 1
53065: PUSH
53066: LD_VAR 0 2
53070: PUSH
53071: LD_INT 4
53073: PLUS
53074: PUSH
53075: LD_INT 0
53077: PUSH
53078: EMPTY
53079: LIST
53080: LIST
53081: LIST
53082: PUSH
53083: LD_VAR 0 1
53087: PUSH
53088: LD_INT 3
53090: MINUS
53091: PUSH
53092: LD_VAR 0 2
53096: PUSH
53097: LD_INT 1
53099: PUSH
53100: EMPTY
53101: LIST
53102: LIST
53103: LIST
53104: PUSH
53105: LD_VAR 0 1
53109: PUSH
53110: LD_INT 4
53112: MINUS
53113: PUSH
53114: LD_VAR 0 2
53118: PUSH
53119: LD_INT 4
53121: MINUS
53122: PUSH
53123: LD_INT 2
53125: PUSH
53126: EMPTY
53127: LIST
53128: LIST
53129: LIST
53130: PUSH
53131: EMPTY
53132: LIST
53133: LIST
53134: LIST
53135: LIST
53136: LIST
53137: ST_TO_ADDR
// end ; 3 :
53138: GO 53560
53140: LD_INT 3
53142: DOUBLE
53143: EQUAL
53144: IFTRUE 53148
53146: GO 53281
53148: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
53149: LD_ADDR_VAR 0 5
53153: PUSH
53154: LD_VAR 0 1
53158: PUSH
53159: LD_INT 3
53161: PLUS
53162: PUSH
53163: LD_VAR 0 2
53167: PUSH
53168: LD_INT 4
53170: PUSH
53171: EMPTY
53172: LIST
53173: LIST
53174: LIST
53175: PUSH
53176: LD_VAR 0 1
53180: PUSH
53181: LD_INT 4
53183: PLUS
53184: PUSH
53185: LD_VAR 0 2
53189: PUSH
53190: LD_INT 4
53192: PLUS
53193: PUSH
53194: LD_INT 5
53196: PUSH
53197: EMPTY
53198: LIST
53199: LIST
53200: LIST
53201: PUSH
53202: LD_VAR 0 1
53206: PUSH
53207: LD_INT 4
53209: MINUS
53210: PUSH
53211: LD_VAR 0 2
53215: PUSH
53216: LD_INT 1
53218: PUSH
53219: EMPTY
53220: LIST
53221: LIST
53222: LIST
53223: PUSH
53224: LD_VAR 0 1
53228: PUSH
53229: LD_VAR 0 2
53233: PUSH
53234: LD_INT 4
53236: MINUS
53237: PUSH
53238: LD_INT 3
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: LIST
53245: PUSH
53246: LD_VAR 0 1
53250: PUSH
53251: LD_INT 3
53253: MINUS
53254: PUSH
53255: LD_VAR 0 2
53259: PUSH
53260: LD_INT 3
53262: MINUS
53263: PUSH
53264: LD_INT 2
53266: PUSH
53267: EMPTY
53268: LIST
53269: LIST
53270: LIST
53271: PUSH
53272: EMPTY
53273: LIST
53274: LIST
53275: LIST
53276: LIST
53277: LIST
53278: ST_TO_ADDR
// end ; 4 :
53279: GO 53560
53281: LD_INT 4
53283: DOUBLE
53284: EQUAL
53285: IFTRUE 53289
53287: GO 53422
53289: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
53290: LD_ADDR_VAR 0 5
53294: PUSH
53295: LD_VAR 0 1
53299: PUSH
53300: LD_VAR 0 2
53304: PUSH
53305: LD_INT 4
53307: PLUS
53308: PUSH
53309: LD_INT 0
53311: PUSH
53312: EMPTY
53313: LIST
53314: LIST
53315: LIST
53316: PUSH
53317: LD_VAR 0 1
53321: PUSH
53322: LD_INT 3
53324: PLUS
53325: PUSH
53326: LD_VAR 0 2
53330: PUSH
53331: LD_INT 3
53333: PLUS
53334: PUSH
53335: LD_INT 5
53337: PUSH
53338: EMPTY
53339: LIST
53340: LIST
53341: LIST
53342: PUSH
53343: LD_VAR 0 1
53347: PUSH
53348: LD_INT 4
53350: PLUS
53351: PUSH
53352: LD_VAR 0 2
53356: PUSH
53357: LD_INT 4
53359: PUSH
53360: EMPTY
53361: LIST
53362: LIST
53363: LIST
53364: PUSH
53365: LD_VAR 0 1
53369: PUSH
53370: LD_VAR 0 2
53374: PUSH
53375: LD_INT 3
53377: MINUS
53378: PUSH
53379: LD_INT 3
53381: PUSH
53382: EMPTY
53383: LIST
53384: LIST
53385: LIST
53386: PUSH
53387: LD_VAR 0 1
53391: PUSH
53392: LD_INT 4
53394: MINUS
53395: PUSH
53396: LD_VAR 0 2
53400: PUSH
53401: LD_INT 4
53403: MINUS
53404: PUSH
53405: LD_INT 2
53407: PUSH
53408: EMPTY
53409: LIST
53410: LIST
53411: LIST
53412: PUSH
53413: EMPTY
53414: LIST
53415: LIST
53416: LIST
53417: LIST
53418: LIST
53419: ST_TO_ADDR
// end ; 5 :
53420: GO 53560
53422: LD_INT 5
53424: DOUBLE
53425: EQUAL
53426: IFTRUE 53430
53428: GO 53559
53430: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
53431: LD_ADDR_VAR 0 5
53435: PUSH
53436: LD_VAR 0 1
53440: PUSH
53441: LD_INT 4
53443: MINUS
53444: PUSH
53445: LD_VAR 0 2
53449: PUSH
53450: LD_INT 1
53452: PUSH
53453: EMPTY
53454: LIST
53455: LIST
53456: LIST
53457: PUSH
53458: LD_VAR 0 1
53462: PUSH
53463: LD_VAR 0 2
53467: PUSH
53468: LD_INT 4
53470: MINUS
53471: PUSH
53472: LD_INT 3
53474: PUSH
53475: EMPTY
53476: LIST
53477: LIST
53478: LIST
53479: PUSH
53480: LD_VAR 0 1
53484: PUSH
53485: LD_INT 4
53487: PLUS
53488: PUSH
53489: LD_VAR 0 2
53493: PUSH
53494: LD_INT 4
53496: PLUS
53497: PUSH
53498: LD_INT 5
53500: PUSH
53501: EMPTY
53502: LIST
53503: LIST
53504: LIST
53505: PUSH
53506: LD_VAR 0 1
53510: PUSH
53511: LD_INT 3
53513: PLUS
53514: PUSH
53515: LD_VAR 0 2
53519: PUSH
53520: LD_INT 4
53522: PUSH
53523: EMPTY
53524: LIST
53525: LIST
53526: LIST
53527: PUSH
53528: LD_VAR 0 1
53532: PUSH
53533: LD_VAR 0 2
53537: PUSH
53538: LD_INT 3
53540: PLUS
53541: PUSH
53542: LD_INT 0
53544: PUSH
53545: EMPTY
53546: LIST
53547: LIST
53548: LIST
53549: PUSH
53550: EMPTY
53551: LIST
53552: LIST
53553: LIST
53554: LIST
53555: LIST
53556: ST_TO_ADDR
// end ; end ;
53557: GO 53560
53559: POP
// result := list ;
53560: LD_ADDR_VAR 0 4
53564: PUSH
53565: LD_VAR 0 5
53569: ST_TO_ADDR
// end ;
53570: LD_VAR 0 4
53574: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
53575: LD_INT 0
53577: PPUSH
53578: PPUSH
53579: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
53580: LD_VAR 0 1
53584: NOT
53585: PUSH
53586: LD_VAR 0 2
53590: PUSH
53591: LD_INT 1
53593: PUSH
53594: LD_INT 2
53596: PUSH
53597: LD_INT 3
53599: PUSH
53600: LD_INT 4
53602: PUSH
53603: EMPTY
53604: LIST
53605: LIST
53606: LIST
53607: LIST
53608: IN
53609: NOT
53610: OR
53611: IFFALSE 53615
// exit ;
53613: GO 53698
// tmp := [ ] ;
53615: LD_ADDR_VAR 0 5
53619: PUSH
53620: EMPTY
53621: ST_TO_ADDR
// for i in units do
53622: LD_ADDR_VAR 0 4
53626: PUSH
53627: LD_VAR 0 1
53631: PUSH
53632: FOR_IN
53633: IFFALSE 53667
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
53635: LD_ADDR_VAR 0 5
53639: PUSH
53640: LD_VAR 0 5
53644: PPUSH
53645: LD_VAR 0 4
53649: PPUSH
53650: LD_VAR 0 2
53654: PPUSH
53655: CALL_OW 259
53659: PPUSH
53660: CALL 55071 0 2
53664: ST_TO_ADDR
53665: GO 53632
53667: POP
53668: POP
// if not tmp then
53669: LD_VAR 0 5
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53698
// result := SortListByListDesc ( units , tmp ) ;
53678: LD_ADDR_VAR 0 3
53682: PUSH
53683: LD_VAR 0 1
53687: PPUSH
53688: LD_VAR 0 5
53692: PPUSH
53693: CALL_OW 77
53697: ST_TO_ADDR
// end ;
53698: LD_VAR 0 3
53702: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
53703: LD_INT 0
53705: PPUSH
53706: PPUSH
53707: PPUSH
// result := false ;
53708: LD_ADDR_VAR 0 3
53712: PUSH
53713: LD_INT 0
53715: ST_TO_ADDR
// if not building then
53716: LD_VAR 0 2
53720: NOT
53721: IFFALSE 53725
// exit ;
53723: GO 53863
// x := GetX ( building ) ;
53725: LD_ADDR_VAR 0 4
53729: PUSH
53730: LD_VAR 0 2
53734: PPUSH
53735: CALL_OW 250
53739: ST_TO_ADDR
// y := GetY ( building ) ;
53740: LD_ADDR_VAR 0 5
53744: PUSH
53745: LD_VAR 0 2
53749: PPUSH
53750: CALL_OW 251
53754: ST_TO_ADDR
// if not x or not y then
53755: LD_VAR 0 4
53759: NOT
53760: PUSH
53761: LD_VAR 0 5
53765: NOT
53766: OR
53767: IFFALSE 53771
// exit ;
53769: GO 53863
// if GetTaskList ( unit ) then
53771: LD_VAR 0 1
53775: PPUSH
53776: CALL_OW 437
53780: IFFALSE 53863
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53782: LD_STRING e
53784: PUSH
53785: LD_VAR 0 1
53789: PPUSH
53790: CALL_OW 437
53794: PUSH
53795: LD_INT 1
53797: ARRAY
53798: PUSH
53799: LD_INT 1
53801: ARRAY
53802: EQUAL
53803: PUSH
53804: LD_VAR 0 4
53808: PUSH
53809: LD_VAR 0 1
53813: PPUSH
53814: CALL_OW 437
53818: PUSH
53819: LD_INT 1
53821: ARRAY
53822: PUSH
53823: LD_INT 2
53825: ARRAY
53826: EQUAL
53827: AND
53828: PUSH
53829: LD_VAR 0 5
53833: PUSH
53834: LD_VAR 0 1
53838: PPUSH
53839: CALL_OW 437
53843: PUSH
53844: LD_INT 1
53846: ARRAY
53847: PUSH
53848: LD_INT 3
53850: ARRAY
53851: EQUAL
53852: AND
53853: IFFALSE 53863
// result := true end ;
53855: LD_ADDR_VAR 0 3
53859: PUSH
53860: LD_INT 1
53862: ST_TO_ADDR
// end ;
53863: LD_VAR 0 3
53867: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
53868: LD_INT 0
53870: PPUSH
// result := false ;
53871: LD_ADDR_VAR 0 4
53875: PUSH
53876: LD_INT 0
53878: ST_TO_ADDR
// if GetTaskList ( unit ) then
53879: LD_VAR 0 1
53883: PPUSH
53884: CALL_OW 437
53888: IFFALSE 53971
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
53890: LD_STRING M
53892: PUSH
53893: LD_VAR 0 1
53897: PPUSH
53898: CALL_OW 437
53902: PUSH
53903: LD_INT 1
53905: ARRAY
53906: PUSH
53907: LD_INT 1
53909: ARRAY
53910: EQUAL
53911: PUSH
53912: LD_VAR 0 2
53916: PUSH
53917: LD_VAR 0 1
53921: PPUSH
53922: CALL_OW 437
53926: PUSH
53927: LD_INT 1
53929: ARRAY
53930: PUSH
53931: LD_INT 2
53933: ARRAY
53934: EQUAL
53935: AND
53936: PUSH
53937: LD_VAR 0 3
53941: PUSH
53942: LD_VAR 0 1
53946: PPUSH
53947: CALL_OW 437
53951: PUSH
53952: LD_INT 1
53954: ARRAY
53955: PUSH
53956: LD_INT 3
53958: ARRAY
53959: EQUAL
53960: AND
53961: IFFALSE 53971
// result := true ;
53963: LD_ADDR_VAR 0 4
53967: PUSH
53968: LD_INT 1
53970: ST_TO_ADDR
// end ; end ;
53971: LD_VAR 0 4
53975: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
53976: LD_INT 0
53978: PPUSH
53979: PPUSH
53980: PPUSH
53981: PPUSH
// if not unit or not area then
53982: LD_VAR 0 1
53986: NOT
53987: PUSH
53988: LD_VAR 0 2
53992: NOT
53993: OR
53994: IFFALSE 53998
// exit ;
53996: GO 54174
// tmp := AreaToList ( area , i ) ;
53998: LD_ADDR_VAR 0 6
54002: PUSH
54003: LD_VAR 0 2
54007: PPUSH
54008: LD_VAR 0 5
54012: PPUSH
54013: CALL_OW 517
54017: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
54018: LD_ADDR_VAR 0 5
54022: PUSH
54023: DOUBLE
54024: LD_INT 1
54026: DEC
54027: ST_TO_ADDR
54028: LD_VAR 0 6
54032: PUSH
54033: LD_INT 1
54035: ARRAY
54036: PUSH
54037: FOR_TO
54038: IFFALSE 54172
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
54040: LD_ADDR_VAR 0 7
54044: PUSH
54045: LD_VAR 0 6
54049: PUSH
54050: LD_INT 1
54052: ARRAY
54053: PUSH
54054: LD_VAR 0 5
54058: ARRAY
54059: PUSH
54060: LD_VAR 0 6
54064: PUSH
54065: LD_INT 2
54067: ARRAY
54068: PUSH
54069: LD_VAR 0 5
54073: ARRAY
54074: PUSH
54075: EMPTY
54076: LIST
54077: LIST
54078: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
54079: LD_INT 92
54081: PUSH
54082: LD_VAR 0 7
54086: PUSH
54087: LD_INT 1
54089: ARRAY
54090: PUSH
54091: LD_VAR 0 7
54095: PUSH
54096: LD_INT 2
54098: ARRAY
54099: PUSH
54100: LD_INT 2
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: LIST
54107: LIST
54108: PPUSH
54109: CALL_OW 69
54113: PUSH
54114: LD_INT 0
54116: EQUAL
54117: IFFALSE 54170
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
54119: LD_VAR 0 1
54123: PPUSH
54124: LD_VAR 0 7
54128: PUSH
54129: LD_INT 1
54131: ARRAY
54132: PPUSH
54133: LD_VAR 0 7
54137: PUSH
54138: LD_INT 2
54140: ARRAY
54141: PPUSH
54142: LD_VAR 0 3
54146: PPUSH
54147: CALL_OW 48
// result := IsPlaced ( unit ) ;
54151: LD_ADDR_VAR 0 4
54155: PUSH
54156: LD_VAR 0 1
54160: PPUSH
54161: CALL_OW 305
54165: ST_TO_ADDR
// exit ;
54166: POP
54167: POP
54168: GO 54174
// end ; end ;
54170: GO 54037
54172: POP
54173: POP
// end ;
54174: LD_VAR 0 4
54178: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
54179: LD_INT 0
54181: PPUSH
54182: PPUSH
54183: PPUSH
// if not side or side > 8 then
54184: LD_VAR 0 1
54188: NOT
54189: PUSH
54190: LD_VAR 0 1
54194: PUSH
54195: LD_INT 8
54197: GREATER
54198: OR
54199: IFFALSE 54203
// exit ;
54201: GO 54390
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
54203: LD_ADDR_VAR 0 4
54207: PUSH
54208: LD_INT 22
54210: PUSH
54211: LD_VAR 0 1
54215: PUSH
54216: EMPTY
54217: LIST
54218: LIST
54219: PUSH
54220: LD_INT 21
54222: PUSH
54223: LD_INT 3
54225: PUSH
54226: EMPTY
54227: LIST
54228: LIST
54229: PUSH
54230: EMPTY
54231: LIST
54232: LIST
54233: PPUSH
54234: CALL_OW 69
54238: ST_TO_ADDR
// if not tmp then
54239: LD_VAR 0 4
54243: NOT
54244: IFFALSE 54248
// exit ;
54246: GO 54390
// enable_addtolog := true ;
54248: LD_ADDR_OWVAR 81
54252: PUSH
54253: LD_INT 1
54255: ST_TO_ADDR
// AddToLog ( [ ) ;
54256: LD_STRING [
54258: PPUSH
54259: CALL_OW 561
// for i in tmp do
54263: LD_ADDR_VAR 0 3
54267: PUSH
54268: LD_VAR 0 4
54272: PUSH
54273: FOR_IN
54274: IFFALSE 54381
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
54276: LD_STRING [
54278: PUSH
54279: LD_VAR 0 3
54283: PPUSH
54284: CALL_OW 266
54288: STR
54289: PUSH
54290: LD_STRING , 
54292: STR
54293: PUSH
54294: LD_VAR 0 3
54298: PPUSH
54299: CALL_OW 250
54303: STR
54304: PUSH
54305: LD_STRING , 
54307: STR
54308: PUSH
54309: LD_VAR 0 3
54313: PPUSH
54314: CALL_OW 251
54318: STR
54319: PUSH
54320: LD_STRING , 
54322: STR
54323: PUSH
54324: LD_VAR 0 3
54328: PPUSH
54329: CALL_OW 254
54333: STR
54334: PUSH
54335: LD_STRING , 
54337: STR
54338: PUSH
54339: LD_VAR 0 3
54343: PPUSH
54344: LD_INT 1
54346: PPUSH
54347: CALL_OW 268
54351: STR
54352: PUSH
54353: LD_STRING , 
54355: STR
54356: PUSH
54357: LD_VAR 0 3
54361: PPUSH
54362: LD_INT 2
54364: PPUSH
54365: CALL_OW 268
54369: STR
54370: PUSH
54371: LD_STRING ],
54373: STR
54374: PPUSH
54375: CALL_OW 561
// end ;
54379: GO 54273
54381: POP
54382: POP
// AddToLog ( ]; ) ;
54383: LD_STRING ];
54385: PPUSH
54386: CALL_OW 561
// end ;
54390: LD_VAR 0 2
54394: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
54395: LD_INT 0
54397: PPUSH
54398: PPUSH
54399: PPUSH
54400: PPUSH
54401: PPUSH
// if not area or not rate or not max then
54402: LD_VAR 0 1
54406: NOT
54407: PUSH
54408: LD_VAR 0 2
54412: NOT
54413: OR
54414: PUSH
54415: LD_VAR 0 4
54419: NOT
54420: OR
54421: IFFALSE 54425
// exit ;
54423: GO 54614
// while 1 do
54425: LD_INT 1
54427: IFFALSE 54614
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
54429: LD_ADDR_VAR 0 9
54433: PUSH
54434: LD_VAR 0 1
54438: PPUSH
54439: LD_INT 1
54441: PPUSH
54442: CALL_OW 287
54446: PUSH
54447: LD_INT 10
54449: MUL
54450: ST_TO_ADDR
// r := rate / 10 ;
54451: LD_ADDR_VAR 0 7
54455: PUSH
54456: LD_VAR 0 2
54460: PUSH
54461: LD_INT 10
54463: DIVREAL
54464: ST_TO_ADDR
// time := 1 1$00 ;
54465: LD_ADDR_VAR 0 8
54469: PUSH
54470: LD_INT 2100
54472: ST_TO_ADDR
// if amount < min then
54473: LD_VAR 0 9
54477: PUSH
54478: LD_VAR 0 3
54482: LESS
54483: IFFALSE 54501
// r := r * 2 else
54485: LD_ADDR_VAR 0 7
54489: PUSH
54490: LD_VAR 0 7
54494: PUSH
54495: LD_INT 2
54497: MUL
54498: ST_TO_ADDR
54499: GO 54527
// if amount > max then
54501: LD_VAR 0 9
54505: PUSH
54506: LD_VAR 0 4
54510: GREATER
54511: IFFALSE 54527
// r := r / 2 ;
54513: LD_ADDR_VAR 0 7
54517: PUSH
54518: LD_VAR 0 7
54522: PUSH
54523: LD_INT 2
54525: DIVREAL
54526: ST_TO_ADDR
// time := time / r ;
54527: LD_ADDR_VAR 0 8
54531: PUSH
54532: LD_VAR 0 8
54536: PUSH
54537: LD_VAR 0 7
54541: DIVREAL
54542: ST_TO_ADDR
// if time < 0 then
54543: LD_VAR 0 8
54547: PUSH
54548: LD_INT 0
54550: LESS
54551: IFFALSE 54568
// time := time * - 1 ;
54553: LD_ADDR_VAR 0 8
54557: PUSH
54558: LD_VAR 0 8
54562: PUSH
54563: LD_INT 1
54565: NEG
54566: MUL
54567: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
54568: LD_VAR 0 8
54572: PUSH
54573: LD_INT 35
54575: PPUSH
54576: LD_INT 875
54578: PPUSH
54579: CALL_OW 12
54583: PLUS
54584: PPUSH
54585: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
54589: LD_INT 1
54591: PPUSH
54592: LD_INT 5
54594: PPUSH
54595: CALL_OW 12
54599: PPUSH
54600: LD_VAR 0 1
54604: PPUSH
54605: LD_INT 1
54607: PPUSH
54608: CALL_OW 55
// end ;
54612: GO 54425
// end ;
54614: LD_VAR 0 5
54618: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
54619: LD_INT 0
54621: PPUSH
54622: PPUSH
54623: PPUSH
54624: PPUSH
54625: PPUSH
54626: PPUSH
54627: PPUSH
54628: PPUSH
// if not turrets or not factories then
54629: LD_VAR 0 1
54633: NOT
54634: PUSH
54635: LD_VAR 0 2
54639: NOT
54640: OR
54641: IFFALSE 54645
// exit ;
54643: GO 54952
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
54645: LD_ADDR_VAR 0 10
54649: PUSH
54650: LD_INT 5
54652: PUSH
54653: LD_INT 6
54655: PUSH
54656: EMPTY
54657: LIST
54658: LIST
54659: PUSH
54660: LD_INT 2
54662: PUSH
54663: LD_INT 4
54665: PUSH
54666: EMPTY
54667: LIST
54668: LIST
54669: PUSH
54670: LD_INT 3
54672: PUSH
54673: LD_INT 5
54675: PUSH
54676: EMPTY
54677: LIST
54678: LIST
54679: PUSH
54680: EMPTY
54681: LIST
54682: LIST
54683: LIST
54684: PUSH
54685: LD_INT 24
54687: PUSH
54688: LD_INT 25
54690: PUSH
54691: EMPTY
54692: LIST
54693: LIST
54694: PUSH
54695: LD_INT 23
54697: PUSH
54698: LD_INT 27
54700: PUSH
54701: EMPTY
54702: LIST
54703: LIST
54704: PUSH
54705: EMPTY
54706: LIST
54707: LIST
54708: PUSH
54709: LD_INT 42
54711: PUSH
54712: LD_INT 43
54714: PUSH
54715: EMPTY
54716: LIST
54717: LIST
54718: PUSH
54719: LD_INT 44
54721: PUSH
54722: LD_INT 46
54724: PUSH
54725: EMPTY
54726: LIST
54727: LIST
54728: PUSH
54729: LD_INT 45
54731: PUSH
54732: LD_INT 47
54734: PUSH
54735: EMPTY
54736: LIST
54737: LIST
54738: PUSH
54739: EMPTY
54740: LIST
54741: LIST
54742: LIST
54743: PUSH
54744: EMPTY
54745: LIST
54746: LIST
54747: LIST
54748: ST_TO_ADDR
// result := [ ] ;
54749: LD_ADDR_VAR 0 3
54753: PUSH
54754: EMPTY
54755: ST_TO_ADDR
// for i in turrets do
54756: LD_ADDR_VAR 0 4
54760: PUSH
54761: LD_VAR 0 1
54765: PUSH
54766: FOR_IN
54767: IFFALSE 54950
// begin nat := GetNation ( i ) ;
54769: LD_ADDR_VAR 0 7
54773: PUSH
54774: LD_VAR 0 4
54778: PPUSH
54779: CALL_OW 248
54783: ST_TO_ADDR
// weapon := 0 ;
54784: LD_ADDR_VAR 0 8
54788: PUSH
54789: LD_INT 0
54791: ST_TO_ADDR
// if not nat then
54792: LD_VAR 0 7
54796: NOT
54797: IFFALSE 54801
// continue ;
54799: GO 54766
// for j in list [ nat ] do
54801: LD_ADDR_VAR 0 5
54805: PUSH
54806: LD_VAR 0 10
54810: PUSH
54811: LD_VAR 0 7
54815: ARRAY
54816: PUSH
54817: FOR_IN
54818: IFFALSE 54859
// if GetBWeapon ( i ) = j [ 1 ] then
54820: LD_VAR 0 4
54824: PPUSH
54825: CALL_OW 269
54829: PUSH
54830: LD_VAR 0 5
54834: PUSH
54835: LD_INT 1
54837: ARRAY
54838: EQUAL
54839: IFFALSE 54857
// begin weapon := j [ 2 ] ;
54841: LD_ADDR_VAR 0 8
54845: PUSH
54846: LD_VAR 0 5
54850: PUSH
54851: LD_INT 2
54853: ARRAY
54854: ST_TO_ADDR
// break ;
54855: GO 54859
// end ;
54857: GO 54817
54859: POP
54860: POP
// if not weapon then
54861: LD_VAR 0 8
54865: NOT
54866: IFFALSE 54870
// continue ;
54868: GO 54766
// for k in factories do
54870: LD_ADDR_VAR 0 6
54874: PUSH
54875: LD_VAR 0 2
54879: PUSH
54880: FOR_IN
54881: IFFALSE 54946
// begin weapons := AvailableWeaponList ( k ) ;
54883: LD_ADDR_VAR 0 9
54887: PUSH
54888: LD_VAR 0 6
54892: PPUSH
54893: CALL_OW 478
54897: ST_TO_ADDR
// if not weapons then
54898: LD_VAR 0 9
54902: NOT
54903: IFFALSE 54907
// continue ;
54905: GO 54880
// if weapon in weapons then
54907: LD_VAR 0 8
54911: PUSH
54912: LD_VAR 0 9
54916: IN
54917: IFFALSE 54944
// begin result := [ i , weapon ] ;
54919: LD_ADDR_VAR 0 3
54923: PUSH
54924: LD_VAR 0 4
54928: PUSH
54929: LD_VAR 0 8
54933: PUSH
54934: EMPTY
54935: LIST
54936: LIST
54937: ST_TO_ADDR
// exit ;
54938: POP
54939: POP
54940: POP
54941: POP
54942: GO 54952
// end ; end ;
54944: GO 54880
54946: POP
54947: POP
// end ;
54948: GO 54766
54950: POP
54951: POP
// end ;
54952: LD_VAR 0 3
54956: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
54957: LD_INT 0
54959: PPUSH
// if not side or side > 8 then
54960: LD_VAR 0 3
54964: NOT
54965: PUSH
54966: LD_VAR 0 3
54970: PUSH
54971: LD_INT 8
54973: GREATER
54974: OR
54975: IFFALSE 54979
// exit ;
54977: GO 55038
// if not range then
54979: LD_VAR 0 4
54983: NOT
54984: IFFALSE 54995
// range := - 12 ;
54986: LD_ADDR_VAR 0 4
54990: PUSH
54991: LD_INT 12
54993: NEG
54994: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
54995: LD_VAR 0 1
54999: PPUSH
55000: LD_VAR 0 2
55004: PPUSH
55005: LD_VAR 0 3
55009: PPUSH
55010: LD_VAR 0 4
55014: PPUSH
55015: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
55019: LD_VAR 0 1
55023: PPUSH
55024: LD_VAR 0 2
55028: PPUSH
55029: LD_VAR 0 3
55033: PPUSH
55034: CALL_OW 331
// end ;
55038: LD_VAR 0 5
55042: RET
// export function Video ( mode ) ; begin
55043: LD_INT 0
55045: PPUSH
// ingame_video = mode ;
55046: LD_ADDR_OWVAR 52
55050: PUSH
55051: LD_VAR 0 1
55055: ST_TO_ADDR
// interface_hidden = mode ;
55056: LD_ADDR_OWVAR 54
55060: PUSH
55061: LD_VAR 0 1
55065: ST_TO_ADDR
// end ;
55066: LD_VAR 0 2
55070: RET
// export function Join ( array , element ) ; begin
55071: LD_INT 0
55073: PPUSH
// result := Replace ( array , array + 1 , element ) ;
55074: LD_ADDR_VAR 0 3
55078: PUSH
55079: LD_VAR 0 1
55083: PPUSH
55084: LD_VAR 0 1
55088: PUSH
55089: LD_INT 1
55091: PLUS
55092: PPUSH
55093: LD_VAR 0 2
55097: PPUSH
55098: CALL_OW 1
55102: ST_TO_ADDR
// end ;
55103: LD_VAR 0 3
55107: RET
// export function JoinUnion ( array , element ) ; begin
55108: LD_INT 0
55110: PPUSH
// result := array union element ;
55111: LD_ADDR_VAR 0 3
55115: PUSH
55116: LD_VAR 0 1
55120: PUSH
55121: LD_VAR 0 2
55125: UNION
55126: ST_TO_ADDR
// end ;
55127: LD_VAR 0 3
55131: RET
// export function GetBehemoths ( side ) ; begin
55132: LD_INT 0
55134: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
55135: LD_ADDR_VAR 0 2
55139: PUSH
55140: LD_INT 22
55142: PUSH
55143: LD_VAR 0 1
55147: PUSH
55148: EMPTY
55149: LIST
55150: LIST
55151: PUSH
55152: LD_INT 31
55154: PUSH
55155: LD_INT 25
55157: PUSH
55158: EMPTY
55159: LIST
55160: LIST
55161: PUSH
55162: EMPTY
55163: LIST
55164: LIST
55165: PPUSH
55166: CALL_OW 69
55170: ST_TO_ADDR
// end ;
55171: LD_VAR 0 2
55175: RET
// export function Shuffle ( array ) ; var i , index ; begin
55176: LD_INT 0
55178: PPUSH
55179: PPUSH
55180: PPUSH
// result := [ ] ;
55181: LD_ADDR_VAR 0 2
55185: PUSH
55186: EMPTY
55187: ST_TO_ADDR
// if not array then
55188: LD_VAR 0 1
55192: NOT
55193: IFFALSE 55197
// exit ;
55195: GO 55296
// Randomize ;
55197: CALL_OW 10
// for i = array downto 1 do
55201: LD_ADDR_VAR 0 3
55205: PUSH
55206: DOUBLE
55207: LD_VAR 0 1
55211: INC
55212: ST_TO_ADDR
55213: LD_INT 1
55215: PUSH
55216: FOR_DOWNTO
55217: IFFALSE 55294
// begin index := rand ( 1 , array ) ;
55219: LD_ADDR_VAR 0 4
55223: PUSH
55224: LD_INT 1
55226: PPUSH
55227: LD_VAR 0 1
55231: PPUSH
55232: CALL_OW 12
55236: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
55237: LD_ADDR_VAR 0 2
55241: PUSH
55242: LD_VAR 0 2
55246: PPUSH
55247: LD_VAR 0 2
55251: PUSH
55252: LD_INT 1
55254: PLUS
55255: PPUSH
55256: LD_VAR 0 1
55260: PUSH
55261: LD_VAR 0 4
55265: ARRAY
55266: PPUSH
55267: CALL_OW 2
55271: ST_TO_ADDR
// array := Delete ( array , index ) ;
55272: LD_ADDR_VAR 0 1
55276: PUSH
55277: LD_VAR 0 1
55281: PPUSH
55282: LD_VAR 0 4
55286: PPUSH
55287: CALL_OW 3
55291: ST_TO_ADDR
// end ;
55292: GO 55216
55294: POP
55295: POP
// end ;
55296: LD_VAR 0 2
55300: RET
// export function GetBaseMaterials ( base ) ; begin
55301: LD_INT 0
55303: PPUSH
// result := [ 0 , 0 , 0 ] ;
55304: LD_ADDR_VAR 0 2
55308: PUSH
55309: LD_INT 0
55311: PUSH
55312: LD_INT 0
55314: PUSH
55315: LD_INT 0
55317: PUSH
55318: EMPTY
55319: LIST
55320: LIST
55321: LIST
55322: ST_TO_ADDR
// if not base then
55323: LD_VAR 0 1
55327: NOT
55328: IFFALSE 55332
// exit ;
55330: GO 55381
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
55332: LD_ADDR_VAR 0 2
55336: PUSH
55337: LD_VAR 0 1
55341: PPUSH
55342: LD_INT 1
55344: PPUSH
55345: CALL_OW 275
55349: PUSH
55350: LD_VAR 0 1
55354: PPUSH
55355: LD_INT 2
55357: PPUSH
55358: CALL_OW 275
55362: PUSH
55363: LD_VAR 0 1
55367: PPUSH
55368: LD_INT 3
55370: PPUSH
55371: CALL_OW 275
55375: PUSH
55376: EMPTY
55377: LIST
55378: LIST
55379: LIST
55380: ST_TO_ADDR
// end ;
55381: LD_VAR 0 2
55385: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
55386: LD_INT 0
55388: PPUSH
55389: PPUSH
// result := array ;
55390: LD_ADDR_VAR 0 3
55394: PUSH
55395: LD_VAR 0 1
55399: ST_TO_ADDR
// if size >= result then
55400: LD_VAR 0 2
55404: PUSH
55405: LD_VAR 0 3
55409: GREATEREQUAL
55410: IFFALSE 55414
// exit ;
55412: GO 55464
// if size then
55414: LD_VAR 0 2
55418: IFFALSE 55464
// for i := array downto size do
55420: LD_ADDR_VAR 0 4
55424: PUSH
55425: DOUBLE
55426: LD_VAR 0 1
55430: INC
55431: ST_TO_ADDR
55432: LD_VAR 0 2
55436: PUSH
55437: FOR_DOWNTO
55438: IFFALSE 55462
// result := Delete ( result , result ) ;
55440: LD_ADDR_VAR 0 3
55444: PUSH
55445: LD_VAR 0 3
55449: PPUSH
55450: LD_VAR 0 3
55454: PPUSH
55455: CALL_OW 3
55459: ST_TO_ADDR
55460: GO 55437
55462: POP
55463: POP
// end ;
55464: LD_VAR 0 3
55468: RET
// export function ComExit ( unit ) ; var tmp ; begin
55469: LD_INT 0
55471: PPUSH
55472: PPUSH
// if not IsInUnit ( unit ) then
55473: LD_VAR 0 1
55477: PPUSH
55478: CALL_OW 310
55482: NOT
55483: IFFALSE 55487
// exit ;
55485: GO 55547
// tmp := IsInUnit ( unit ) ;
55487: LD_ADDR_VAR 0 3
55491: PUSH
55492: LD_VAR 0 1
55496: PPUSH
55497: CALL_OW 310
55501: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
55502: LD_VAR 0 3
55506: PPUSH
55507: CALL_OW 247
55511: PUSH
55512: LD_INT 2
55514: EQUAL
55515: IFFALSE 55528
// ComExitVehicle ( unit ) else
55517: LD_VAR 0 1
55521: PPUSH
55522: CALL_OW 121
55526: GO 55537
// ComExitBuilding ( unit ) ;
55528: LD_VAR 0 1
55532: PPUSH
55533: CALL_OW 122
// result := tmp ;
55537: LD_ADDR_VAR 0 2
55541: PUSH
55542: LD_VAR 0 3
55546: ST_TO_ADDR
// end ;
55547: LD_VAR 0 2
55551: RET
// export function ComExitAll ( units ) ; var i ; begin
55552: LD_INT 0
55554: PPUSH
55555: PPUSH
// if not units then
55556: LD_VAR 0 1
55560: NOT
55561: IFFALSE 55565
// exit ;
55563: GO 55591
// for i in units do
55565: LD_ADDR_VAR 0 3
55569: PUSH
55570: LD_VAR 0 1
55574: PUSH
55575: FOR_IN
55576: IFFALSE 55589
// ComExit ( i ) ;
55578: LD_VAR 0 3
55582: PPUSH
55583: CALL 55469 0 1
55587: GO 55575
55589: POP
55590: POP
// end ;
55591: LD_VAR 0 2
55595: RET
// export function ResetHc ; begin
55596: LD_INT 0
55598: PPUSH
// InitHc ;
55599: CALL_OW 19
// hc_importance := 0 ;
55603: LD_ADDR_OWVAR 32
55607: PUSH
55608: LD_INT 0
55610: ST_TO_ADDR
// end ;
55611: LD_VAR 0 1
55615: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
55616: LD_INT 0
55618: PPUSH
55619: PPUSH
55620: PPUSH
// _x := ( x1 + x2 ) div 2 ;
55621: LD_ADDR_VAR 0 6
55625: PUSH
55626: LD_VAR 0 1
55630: PUSH
55631: LD_VAR 0 3
55635: PLUS
55636: PUSH
55637: LD_INT 2
55639: DIV
55640: ST_TO_ADDR
// if _x < 0 then
55641: LD_VAR 0 6
55645: PUSH
55646: LD_INT 0
55648: LESS
55649: IFFALSE 55666
// _x := _x * - 1 ;
55651: LD_ADDR_VAR 0 6
55655: PUSH
55656: LD_VAR 0 6
55660: PUSH
55661: LD_INT 1
55663: NEG
55664: MUL
55665: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
55666: LD_ADDR_VAR 0 7
55670: PUSH
55671: LD_VAR 0 2
55675: PUSH
55676: LD_VAR 0 4
55680: PLUS
55681: PUSH
55682: LD_INT 2
55684: DIV
55685: ST_TO_ADDR
// if _y < 0 then
55686: LD_VAR 0 7
55690: PUSH
55691: LD_INT 0
55693: LESS
55694: IFFALSE 55711
// _y := _y * - 1 ;
55696: LD_ADDR_VAR 0 7
55700: PUSH
55701: LD_VAR 0 7
55705: PUSH
55706: LD_INT 1
55708: NEG
55709: MUL
55710: ST_TO_ADDR
// result := [ _x , _y ] ;
55711: LD_ADDR_VAR 0 5
55715: PUSH
55716: LD_VAR 0 6
55720: PUSH
55721: LD_VAR 0 7
55725: PUSH
55726: EMPTY
55727: LIST
55728: LIST
55729: ST_TO_ADDR
// end ;
55730: LD_VAR 0 5
55734: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
55735: LD_INT 0
55737: PPUSH
55738: PPUSH
55739: PPUSH
55740: PPUSH
// task := GetTaskList ( unit ) ;
55741: LD_ADDR_VAR 0 7
55745: PUSH
55746: LD_VAR 0 1
55750: PPUSH
55751: CALL_OW 437
55755: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
55756: LD_VAR 0 7
55760: NOT
55761: PUSH
55762: LD_VAR 0 1
55766: PPUSH
55767: LD_VAR 0 2
55771: PPUSH
55772: CALL_OW 308
55776: NOT
55777: AND
55778: IFFALSE 55782
// exit ;
55780: GO 55900
// if IsInArea ( unit , area ) then
55782: LD_VAR 0 1
55786: PPUSH
55787: LD_VAR 0 2
55791: PPUSH
55792: CALL_OW 308
55796: IFFALSE 55814
// begin ComMoveToArea ( unit , goAway ) ;
55798: LD_VAR 0 1
55802: PPUSH
55803: LD_VAR 0 3
55807: PPUSH
55808: CALL_OW 113
// exit ;
55812: GO 55900
// end ; if task [ 1 ] [ 1 ] <> M then
55814: LD_VAR 0 7
55818: PUSH
55819: LD_INT 1
55821: ARRAY
55822: PUSH
55823: LD_INT 1
55825: ARRAY
55826: PUSH
55827: LD_STRING M
55829: NONEQUAL
55830: IFFALSE 55834
// exit ;
55832: GO 55900
// x := task [ 1 ] [ 2 ] ;
55834: LD_ADDR_VAR 0 5
55838: PUSH
55839: LD_VAR 0 7
55843: PUSH
55844: LD_INT 1
55846: ARRAY
55847: PUSH
55848: LD_INT 2
55850: ARRAY
55851: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
55852: LD_ADDR_VAR 0 6
55856: PUSH
55857: LD_VAR 0 7
55861: PUSH
55862: LD_INT 1
55864: ARRAY
55865: PUSH
55866: LD_INT 3
55868: ARRAY
55869: ST_TO_ADDR
// if InArea ( x , y , area ) then
55870: LD_VAR 0 5
55874: PPUSH
55875: LD_VAR 0 6
55879: PPUSH
55880: LD_VAR 0 2
55884: PPUSH
55885: CALL_OW 309
55889: IFFALSE 55900
// ComStop ( unit ) ;
55891: LD_VAR 0 1
55895: PPUSH
55896: CALL_OW 141
// end ;
55900: LD_VAR 0 4
55904: RET
// export function Abs ( value ) ; begin
55905: LD_INT 0
55907: PPUSH
// result := value ;
55908: LD_ADDR_VAR 0 2
55912: PUSH
55913: LD_VAR 0 1
55917: ST_TO_ADDR
// if value < 0 then
55918: LD_VAR 0 1
55922: PUSH
55923: LD_INT 0
55925: LESS
55926: IFFALSE 55943
// result := value * - 1 ;
55928: LD_ADDR_VAR 0 2
55932: PUSH
55933: LD_VAR 0 1
55937: PUSH
55938: LD_INT 1
55940: NEG
55941: MUL
55942: ST_TO_ADDR
// end ;
55943: LD_VAR 0 2
55947: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
55948: LD_INT 0
55950: PPUSH
55951: PPUSH
55952: PPUSH
55953: PPUSH
55954: PPUSH
55955: PPUSH
55956: PPUSH
55957: PPUSH
// if not unit or not building then
55958: LD_VAR 0 1
55962: NOT
55963: PUSH
55964: LD_VAR 0 2
55968: NOT
55969: OR
55970: IFFALSE 55974
// exit ;
55972: GO 56200
// x := GetX ( building ) ;
55974: LD_ADDR_VAR 0 4
55978: PUSH
55979: LD_VAR 0 2
55983: PPUSH
55984: CALL_OW 250
55988: ST_TO_ADDR
// y := GetY ( building ) ;
55989: LD_ADDR_VAR 0 6
55993: PUSH
55994: LD_VAR 0 2
55998: PPUSH
55999: CALL_OW 251
56003: ST_TO_ADDR
// d := GetDir ( building ) ;
56004: LD_ADDR_VAR 0 8
56008: PUSH
56009: LD_VAR 0 2
56013: PPUSH
56014: CALL_OW 254
56018: ST_TO_ADDR
// r := 4 ;
56019: LD_ADDR_VAR 0 9
56023: PUSH
56024: LD_INT 4
56026: ST_TO_ADDR
// for i := 1 to 5 do
56027: LD_ADDR_VAR 0 10
56031: PUSH
56032: DOUBLE
56033: LD_INT 1
56035: DEC
56036: ST_TO_ADDR
56037: LD_INT 5
56039: PUSH
56040: FOR_TO
56041: IFFALSE 56198
// begin _x := ShiftX ( x , d , r + i ) ;
56043: LD_ADDR_VAR 0 5
56047: PUSH
56048: LD_VAR 0 4
56052: PPUSH
56053: LD_VAR 0 8
56057: PPUSH
56058: LD_VAR 0 9
56062: PUSH
56063: LD_VAR 0 10
56067: PLUS
56068: PPUSH
56069: CALL_OW 272
56073: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
56074: LD_ADDR_VAR 0 7
56078: PUSH
56079: LD_VAR 0 6
56083: PPUSH
56084: LD_VAR 0 8
56088: PPUSH
56089: LD_VAR 0 9
56093: PUSH
56094: LD_VAR 0 10
56098: PLUS
56099: PPUSH
56100: CALL_OW 273
56104: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
56105: LD_VAR 0 5
56109: PPUSH
56110: LD_VAR 0 7
56114: PPUSH
56115: CALL_OW 488
56119: PUSH
56120: LD_VAR 0 5
56124: PPUSH
56125: LD_VAR 0 7
56129: PPUSH
56130: CALL_OW 428
56134: PPUSH
56135: CALL_OW 247
56139: PUSH
56140: LD_INT 3
56142: PUSH
56143: LD_INT 2
56145: PUSH
56146: EMPTY
56147: LIST
56148: LIST
56149: IN
56150: NOT
56151: AND
56152: IFFALSE 56196
// begin ComMoveXY ( unit , _x , _y ) ;
56154: LD_VAR 0 1
56158: PPUSH
56159: LD_VAR 0 5
56163: PPUSH
56164: LD_VAR 0 7
56168: PPUSH
56169: CALL_OW 111
// result := [ _x , _y ] ;
56173: LD_ADDR_VAR 0 3
56177: PUSH
56178: LD_VAR 0 5
56182: PUSH
56183: LD_VAR 0 7
56187: PUSH
56188: EMPTY
56189: LIST
56190: LIST
56191: ST_TO_ADDR
// exit ;
56192: POP
56193: POP
56194: GO 56200
// end ; end ;
56196: GO 56040
56198: POP
56199: POP
// end ;
56200: LD_VAR 0 3
56204: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
56205: LD_INT 0
56207: PPUSH
56208: PPUSH
56209: PPUSH
// result := 0 ;
56210: LD_ADDR_VAR 0 3
56214: PUSH
56215: LD_INT 0
56217: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
56218: LD_VAR 0 1
56222: PUSH
56223: LD_INT 0
56225: LESS
56226: PUSH
56227: LD_VAR 0 1
56231: PUSH
56232: LD_INT 8
56234: GREATER
56235: OR
56236: PUSH
56237: LD_VAR 0 2
56241: PUSH
56242: LD_INT 0
56244: LESS
56245: OR
56246: PUSH
56247: LD_VAR 0 2
56251: PUSH
56252: LD_INT 8
56254: GREATER
56255: OR
56256: IFFALSE 56260
// exit ;
56258: GO 56335
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
56260: LD_ADDR_VAR 0 4
56264: PUSH
56265: LD_INT 22
56267: PUSH
56268: LD_VAR 0 2
56272: PUSH
56273: EMPTY
56274: LIST
56275: LIST
56276: PPUSH
56277: CALL_OW 69
56281: PUSH
56282: FOR_IN
56283: IFFALSE 56333
// begin un := UnitShoot ( i ) ;
56285: LD_ADDR_VAR 0 5
56289: PUSH
56290: LD_VAR 0 4
56294: PPUSH
56295: CALL_OW 504
56299: ST_TO_ADDR
// if GetSide ( un ) = side1 then
56300: LD_VAR 0 5
56304: PPUSH
56305: CALL_OW 255
56309: PUSH
56310: LD_VAR 0 1
56314: EQUAL
56315: IFFALSE 56331
// begin result := un ;
56317: LD_ADDR_VAR 0 3
56321: PUSH
56322: LD_VAR 0 5
56326: ST_TO_ADDR
// exit ;
56327: POP
56328: POP
56329: GO 56335
// end ; end ;
56331: GO 56282
56333: POP
56334: POP
// end ;
56335: LD_VAR 0 3
56339: RET
// export function GetCargoBay ( units ) ; begin
56340: LD_INT 0
56342: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
56343: LD_ADDR_VAR 0 2
56347: PUSH
56348: LD_VAR 0 1
56352: PPUSH
56353: LD_INT 2
56355: PUSH
56356: LD_INT 34
56358: PUSH
56359: LD_INT 12
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: PUSH
56366: LD_INT 34
56368: PUSH
56369: LD_INT 51
56371: PUSH
56372: EMPTY
56373: LIST
56374: LIST
56375: PUSH
56376: LD_INT 34
56378: PUSH
56379: LD_INT 32
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PUSH
56386: LD_INT 34
56388: PUSH
56389: LD_INT 89
56391: PUSH
56392: EMPTY
56393: LIST
56394: LIST
56395: PUSH
56396: EMPTY
56397: LIST
56398: LIST
56399: LIST
56400: LIST
56401: LIST
56402: PPUSH
56403: CALL_OW 72
56407: ST_TO_ADDR
// end ;
56408: LD_VAR 0 2
56412: RET
// export function Negate ( value ) ; begin
56413: LD_INT 0
56415: PPUSH
// result := not value ;
56416: LD_ADDR_VAR 0 2
56420: PUSH
56421: LD_VAR 0 1
56425: NOT
56426: ST_TO_ADDR
// end ;
56427: LD_VAR 0 2
56431: RET
// export function Inc ( value ) ; begin
56432: LD_INT 0
56434: PPUSH
// result := value + 1 ;
56435: LD_ADDR_VAR 0 2
56439: PUSH
56440: LD_VAR 0 1
56444: PUSH
56445: LD_INT 1
56447: PLUS
56448: ST_TO_ADDR
// end ;
56449: LD_VAR 0 2
56453: RET
// export function Dec ( value ) ; begin
56454: LD_INT 0
56456: PPUSH
// result := value - 1 ;
56457: LD_ADDR_VAR 0 2
56461: PUSH
56462: LD_VAR 0 1
56466: PUSH
56467: LD_INT 1
56469: MINUS
56470: ST_TO_ADDR
// end ;
56471: LD_VAR 0 2
56475: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
56476: LD_INT 0
56478: PPUSH
56479: PPUSH
56480: PPUSH
56481: PPUSH
56482: PPUSH
56483: PPUSH
56484: PPUSH
56485: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
56486: LD_VAR 0 1
56490: PPUSH
56491: LD_VAR 0 2
56495: PPUSH
56496: CALL_OW 488
56500: NOT
56501: PUSH
56502: LD_VAR 0 3
56506: PPUSH
56507: LD_VAR 0 4
56511: PPUSH
56512: CALL_OW 488
56516: NOT
56517: OR
56518: IFFALSE 56531
// begin result := - 1 ;
56520: LD_ADDR_VAR 0 5
56524: PUSH
56525: LD_INT 1
56527: NEG
56528: ST_TO_ADDR
// exit ;
56529: GO 56766
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
56531: LD_ADDR_VAR 0 12
56535: PUSH
56536: LD_VAR 0 1
56540: PPUSH
56541: LD_VAR 0 2
56545: PPUSH
56546: LD_VAR 0 3
56550: PPUSH
56551: LD_VAR 0 4
56555: PPUSH
56556: CALL 55616 0 4
56560: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
56561: LD_ADDR_VAR 0 11
56565: PUSH
56566: LD_VAR 0 1
56570: PPUSH
56571: LD_VAR 0 2
56575: PPUSH
56576: LD_VAR 0 12
56580: PUSH
56581: LD_INT 1
56583: ARRAY
56584: PPUSH
56585: LD_VAR 0 12
56589: PUSH
56590: LD_INT 2
56592: ARRAY
56593: PPUSH
56594: CALL_OW 298
56598: ST_TO_ADDR
// distance := 9999 ;
56599: LD_ADDR_VAR 0 10
56603: PUSH
56604: LD_INT 9999
56606: ST_TO_ADDR
// for i := 0 to 5 do
56607: LD_ADDR_VAR 0 6
56611: PUSH
56612: DOUBLE
56613: LD_INT 0
56615: DEC
56616: ST_TO_ADDR
56617: LD_INT 5
56619: PUSH
56620: FOR_TO
56621: IFFALSE 56764
// begin _x := ShiftX ( x1 , i , centerDist ) ;
56623: LD_ADDR_VAR 0 7
56627: PUSH
56628: LD_VAR 0 1
56632: PPUSH
56633: LD_VAR 0 6
56637: PPUSH
56638: LD_VAR 0 11
56642: PPUSH
56643: CALL_OW 272
56647: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
56648: LD_ADDR_VAR 0 8
56652: PUSH
56653: LD_VAR 0 2
56657: PPUSH
56658: LD_VAR 0 6
56662: PPUSH
56663: LD_VAR 0 11
56667: PPUSH
56668: CALL_OW 273
56672: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
56673: LD_VAR 0 7
56677: PPUSH
56678: LD_VAR 0 8
56682: PPUSH
56683: CALL_OW 488
56687: NOT
56688: IFFALSE 56692
// continue ;
56690: GO 56620
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
56692: LD_ADDR_VAR 0 9
56696: PUSH
56697: LD_VAR 0 12
56701: PUSH
56702: LD_INT 1
56704: ARRAY
56705: PPUSH
56706: LD_VAR 0 12
56710: PUSH
56711: LD_INT 2
56713: ARRAY
56714: PPUSH
56715: LD_VAR 0 7
56719: PPUSH
56720: LD_VAR 0 8
56724: PPUSH
56725: CALL_OW 298
56729: ST_TO_ADDR
// if tmp < distance then
56730: LD_VAR 0 9
56734: PUSH
56735: LD_VAR 0 10
56739: LESS
56740: IFFALSE 56762
// begin result := i ;
56742: LD_ADDR_VAR 0 5
56746: PUSH
56747: LD_VAR 0 6
56751: ST_TO_ADDR
// distance := tmp ;
56752: LD_ADDR_VAR 0 10
56756: PUSH
56757: LD_VAR 0 9
56761: ST_TO_ADDR
// end ; end ;
56762: GO 56620
56764: POP
56765: POP
// end ;
56766: LD_VAR 0 5
56770: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56771: LD_INT 0
56773: PPUSH
56774: PPUSH
// if not driver or not IsInUnit ( driver ) then
56775: LD_VAR 0 1
56779: NOT
56780: PUSH
56781: LD_VAR 0 1
56785: PPUSH
56786: CALL_OW 310
56790: NOT
56791: OR
56792: IFFALSE 56796
// exit ;
56794: GO 56886
// vehicle := IsInUnit ( driver ) ;
56796: LD_ADDR_VAR 0 3
56800: PUSH
56801: LD_VAR 0 1
56805: PPUSH
56806: CALL_OW 310
56810: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56811: LD_VAR 0 1
56815: PPUSH
56816: LD_STRING \
56818: PUSH
56819: LD_INT 0
56821: PUSH
56822: LD_INT 0
56824: PUSH
56825: LD_INT 0
56827: PUSH
56828: LD_INT 0
56830: PUSH
56831: LD_INT 0
56833: PUSH
56834: LD_INT 0
56836: PUSH
56837: EMPTY
56838: LIST
56839: LIST
56840: LIST
56841: LIST
56842: LIST
56843: LIST
56844: LIST
56845: PUSH
56846: LD_STRING E
56848: PUSH
56849: LD_INT 0
56851: PUSH
56852: LD_INT 0
56854: PUSH
56855: LD_VAR 0 3
56859: PUSH
56860: LD_INT 0
56862: PUSH
56863: LD_INT 0
56865: PUSH
56866: LD_INT 0
56868: PUSH
56869: EMPTY
56870: LIST
56871: LIST
56872: LIST
56873: LIST
56874: LIST
56875: LIST
56876: LIST
56877: PUSH
56878: EMPTY
56879: LIST
56880: LIST
56881: PPUSH
56882: CALL_OW 446
// end ;
56886: LD_VAR 0 2
56890: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
56891: LD_INT 0
56893: PPUSH
56894: PPUSH
// if not driver or not IsInUnit ( driver ) then
56895: LD_VAR 0 1
56899: NOT
56900: PUSH
56901: LD_VAR 0 1
56905: PPUSH
56906: CALL_OW 310
56910: NOT
56911: OR
56912: IFFALSE 56916
// exit ;
56914: GO 57006
// vehicle := IsInUnit ( driver ) ;
56916: LD_ADDR_VAR 0 3
56920: PUSH
56921: LD_VAR 0 1
56925: PPUSH
56926: CALL_OW 310
56930: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
56931: LD_VAR 0 1
56935: PPUSH
56936: LD_STRING \
56938: PUSH
56939: LD_INT 0
56941: PUSH
56942: LD_INT 0
56944: PUSH
56945: LD_INT 0
56947: PUSH
56948: LD_INT 0
56950: PUSH
56951: LD_INT 0
56953: PUSH
56954: LD_INT 0
56956: PUSH
56957: EMPTY
56958: LIST
56959: LIST
56960: LIST
56961: LIST
56962: LIST
56963: LIST
56964: LIST
56965: PUSH
56966: LD_STRING E
56968: PUSH
56969: LD_INT 0
56971: PUSH
56972: LD_INT 0
56974: PUSH
56975: LD_VAR 0 3
56979: PUSH
56980: LD_INT 0
56982: PUSH
56983: LD_INT 0
56985: PUSH
56986: LD_INT 0
56988: PUSH
56989: EMPTY
56990: LIST
56991: LIST
56992: LIST
56993: LIST
56994: LIST
56995: LIST
56996: LIST
56997: PUSH
56998: EMPTY
56999: LIST
57000: LIST
57001: PPUSH
57002: CALL_OW 447
// end ;
57006: LD_VAR 0 2
57010: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
57011: LD_INT 0
57013: PPUSH
57014: PPUSH
57015: PPUSH
// tmp := [ ] ;
57016: LD_ADDR_VAR 0 5
57020: PUSH
57021: EMPTY
57022: ST_TO_ADDR
// for i in units do
57023: LD_ADDR_VAR 0 4
57027: PUSH
57028: LD_VAR 0 1
57032: PUSH
57033: FOR_IN
57034: IFFALSE 57072
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
57036: LD_ADDR_VAR 0 5
57040: PUSH
57041: LD_VAR 0 5
57045: PPUSH
57046: LD_VAR 0 5
57050: PUSH
57051: LD_INT 1
57053: PLUS
57054: PPUSH
57055: LD_VAR 0 4
57059: PPUSH
57060: CALL_OW 256
57064: PPUSH
57065: CALL_OW 2
57069: ST_TO_ADDR
57070: GO 57033
57072: POP
57073: POP
// if not tmp then
57074: LD_VAR 0 5
57078: NOT
57079: IFFALSE 57083
// exit ;
57081: GO 57131
// if asc then
57083: LD_VAR 0 2
57087: IFFALSE 57111
// result := SortListByListAsc ( units , tmp ) else
57089: LD_ADDR_VAR 0 3
57093: PUSH
57094: LD_VAR 0 1
57098: PPUSH
57099: LD_VAR 0 5
57103: PPUSH
57104: CALL_OW 76
57108: ST_TO_ADDR
57109: GO 57131
// result := SortListByListDesc ( units , tmp ) ;
57111: LD_ADDR_VAR 0 3
57115: PUSH
57116: LD_VAR 0 1
57120: PPUSH
57121: LD_VAR 0 5
57125: PPUSH
57126: CALL_OW 77
57130: ST_TO_ADDR
// end ;
57131: LD_VAR 0 3
57135: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
57136: LD_INT 0
57138: PPUSH
57139: PPUSH
// task := GetTaskList ( mech ) ;
57140: LD_ADDR_VAR 0 4
57144: PUSH
57145: LD_VAR 0 1
57149: PPUSH
57150: CALL_OW 437
57154: ST_TO_ADDR
// if not task then
57155: LD_VAR 0 4
57159: NOT
57160: IFFALSE 57164
// exit ;
57162: GO 57206
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
57164: LD_ADDR_VAR 0 3
57168: PUSH
57169: LD_VAR 0 4
57173: PUSH
57174: LD_INT 1
57176: ARRAY
57177: PUSH
57178: LD_INT 1
57180: ARRAY
57181: PUSH
57182: LD_STRING r
57184: EQUAL
57185: PUSH
57186: LD_VAR 0 4
57190: PUSH
57191: LD_INT 1
57193: ARRAY
57194: PUSH
57195: LD_INT 4
57197: ARRAY
57198: PUSH
57199: LD_VAR 0 2
57203: EQUAL
57204: AND
57205: ST_TO_ADDR
// end ;
57206: LD_VAR 0 3
57210: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
57211: LD_INT 0
57213: PPUSH
// SetDir ( unit , d ) ;
57214: LD_VAR 0 1
57218: PPUSH
57219: LD_VAR 0 4
57223: PPUSH
57224: CALL_OW 233
// result := PlaceUnitXY ( unit , x , y , mode ) ;
57228: LD_ADDR_VAR 0 6
57232: PUSH
57233: LD_VAR 0 1
57237: PPUSH
57238: LD_VAR 0 2
57242: PPUSH
57243: LD_VAR 0 3
57247: PPUSH
57248: LD_VAR 0 5
57252: PPUSH
57253: CALL_OW 48
57257: ST_TO_ADDR
// end ;
57258: LD_VAR 0 6
57262: RET
// export function ToNaturalNumber ( number ) ; begin
57263: LD_INT 0
57265: PPUSH
// result := number div 1 ;
57266: LD_ADDR_VAR 0 2
57270: PUSH
57271: LD_VAR 0 1
57275: PUSH
57276: LD_INT 1
57278: DIV
57279: ST_TO_ADDR
// if number < 0 then
57280: LD_VAR 0 1
57284: PUSH
57285: LD_INT 0
57287: LESS
57288: IFFALSE 57298
// result := 0 ;
57290: LD_ADDR_VAR 0 2
57294: PUSH
57295: LD_INT 0
57297: ST_TO_ADDR
// end ;
57298: LD_VAR 0 2
57302: RET
// export function SortByClass ( units , class ) ; var un ; begin
57303: LD_INT 0
57305: PPUSH
57306: PPUSH
// if not units or not class then
57307: LD_VAR 0 1
57311: NOT
57312: PUSH
57313: LD_VAR 0 2
57317: NOT
57318: OR
57319: IFFALSE 57323
// exit ;
57321: GO 57418
// result := [ ] ;
57323: LD_ADDR_VAR 0 3
57327: PUSH
57328: EMPTY
57329: ST_TO_ADDR
// for un in units do
57330: LD_ADDR_VAR 0 4
57334: PUSH
57335: LD_VAR 0 1
57339: PUSH
57340: FOR_IN
57341: IFFALSE 57416
// if GetClass ( un ) = class then
57343: LD_VAR 0 4
57347: PPUSH
57348: CALL_OW 257
57352: PUSH
57353: LD_VAR 0 2
57357: EQUAL
57358: IFFALSE 57385
// result := Insert ( result , 1 , un ) else
57360: LD_ADDR_VAR 0 3
57364: PUSH
57365: LD_VAR 0 3
57369: PPUSH
57370: LD_INT 1
57372: PPUSH
57373: LD_VAR 0 4
57377: PPUSH
57378: CALL_OW 2
57382: ST_TO_ADDR
57383: GO 57414
// result := Replace ( result , result + 1 , un ) ;
57385: LD_ADDR_VAR 0 3
57389: PUSH
57390: LD_VAR 0 3
57394: PPUSH
57395: LD_VAR 0 3
57399: PUSH
57400: LD_INT 1
57402: PLUS
57403: PPUSH
57404: LD_VAR 0 4
57408: PPUSH
57409: CALL_OW 1
57413: ST_TO_ADDR
57414: GO 57340
57416: POP
57417: POP
// end ;
57418: LD_VAR 0 3
57422: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
57423: LD_INT 0
57425: PPUSH
57426: PPUSH
57427: PPUSH
57428: PPUSH
57429: PPUSH
57430: PPUSH
57431: PPUSH
// result := [ ] ;
57432: LD_ADDR_VAR 0 4
57436: PUSH
57437: EMPTY
57438: ST_TO_ADDR
// if x - r < 0 then
57439: LD_VAR 0 1
57443: PUSH
57444: LD_VAR 0 3
57448: MINUS
57449: PUSH
57450: LD_INT 0
57452: LESS
57453: IFFALSE 57465
// min_x := 0 else
57455: LD_ADDR_VAR 0 8
57459: PUSH
57460: LD_INT 0
57462: ST_TO_ADDR
57463: GO 57481
// min_x := x - r ;
57465: LD_ADDR_VAR 0 8
57469: PUSH
57470: LD_VAR 0 1
57474: PUSH
57475: LD_VAR 0 3
57479: MINUS
57480: ST_TO_ADDR
// if y - r < 0 then
57481: LD_VAR 0 2
57485: PUSH
57486: LD_VAR 0 3
57490: MINUS
57491: PUSH
57492: LD_INT 0
57494: LESS
57495: IFFALSE 57507
// min_y := 0 else
57497: LD_ADDR_VAR 0 7
57501: PUSH
57502: LD_INT 0
57504: ST_TO_ADDR
57505: GO 57523
// min_y := y - r ;
57507: LD_ADDR_VAR 0 7
57511: PUSH
57512: LD_VAR 0 2
57516: PUSH
57517: LD_VAR 0 3
57521: MINUS
57522: ST_TO_ADDR
// max_x := x + r ;
57523: LD_ADDR_VAR 0 9
57527: PUSH
57528: LD_VAR 0 1
57532: PUSH
57533: LD_VAR 0 3
57537: PLUS
57538: ST_TO_ADDR
// max_y := y + r ;
57539: LD_ADDR_VAR 0 10
57543: PUSH
57544: LD_VAR 0 2
57548: PUSH
57549: LD_VAR 0 3
57553: PLUS
57554: ST_TO_ADDR
// for _x = min_x to max_x do
57555: LD_ADDR_VAR 0 5
57559: PUSH
57560: DOUBLE
57561: LD_VAR 0 8
57565: DEC
57566: ST_TO_ADDR
57567: LD_VAR 0 9
57571: PUSH
57572: FOR_TO
57573: IFFALSE 57674
// for _y = min_y to max_y do
57575: LD_ADDR_VAR 0 6
57579: PUSH
57580: DOUBLE
57581: LD_VAR 0 7
57585: DEC
57586: ST_TO_ADDR
57587: LD_VAR 0 10
57591: PUSH
57592: FOR_TO
57593: IFFALSE 57670
// begin if not ValidHex ( _x , _y ) then
57595: LD_VAR 0 5
57599: PPUSH
57600: LD_VAR 0 6
57604: PPUSH
57605: CALL_OW 488
57609: NOT
57610: IFFALSE 57614
// continue ;
57612: GO 57592
// if GetResourceTypeXY ( _x , _y ) then
57614: LD_VAR 0 5
57618: PPUSH
57619: LD_VAR 0 6
57623: PPUSH
57624: CALL_OW 283
57628: IFFALSE 57668
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
57630: LD_ADDR_VAR 0 4
57634: PUSH
57635: LD_VAR 0 4
57639: PPUSH
57640: LD_VAR 0 4
57644: PUSH
57645: LD_INT 1
57647: PLUS
57648: PPUSH
57649: LD_VAR 0 5
57653: PUSH
57654: LD_VAR 0 6
57658: PUSH
57659: EMPTY
57660: LIST
57661: LIST
57662: PPUSH
57663: CALL_OW 1
57667: ST_TO_ADDR
// end ;
57668: GO 57592
57670: POP
57671: POP
57672: GO 57572
57674: POP
57675: POP
// end ;
57676: LD_VAR 0 4
57680: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
57681: LD_INT 0
57683: PPUSH
57684: PPUSH
57685: PPUSH
57686: PPUSH
57687: PPUSH
57688: PPUSH
57689: PPUSH
57690: PPUSH
// if not units then
57691: LD_VAR 0 1
57695: NOT
57696: IFFALSE 57700
// exit ;
57698: GO 58228
// result := UnitFilter ( units , [ f_ok ] ) ;
57700: LD_ADDR_VAR 0 3
57704: PUSH
57705: LD_VAR 0 1
57709: PPUSH
57710: LD_INT 50
57712: PUSH
57713: EMPTY
57714: LIST
57715: PPUSH
57716: CALL_OW 72
57720: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
57721: LD_ADDR_VAR 0 8
57725: PUSH
57726: LD_VAR 0 1
57730: PUSH
57731: LD_INT 1
57733: ARRAY
57734: PPUSH
57735: CALL_OW 255
57739: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
57740: LD_ADDR_VAR 0 10
57744: PUSH
57745: LD_INT 29
57747: PUSH
57748: LD_INT 91
57750: PUSH
57751: LD_INT 49
57753: PUSH
57754: EMPTY
57755: LIST
57756: LIST
57757: LIST
57758: ST_TO_ADDR
// if not result then
57759: LD_VAR 0 3
57763: NOT
57764: IFFALSE 57768
// exit ;
57766: GO 58228
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
57768: LD_ADDR_VAR 0 5
57772: PUSH
57773: LD_INT 81
57775: PUSH
57776: LD_VAR 0 8
57780: PUSH
57781: EMPTY
57782: LIST
57783: LIST
57784: PPUSH
57785: CALL_OW 69
57789: ST_TO_ADDR
// for i in result do
57790: LD_ADDR_VAR 0 4
57794: PUSH
57795: LD_VAR 0 3
57799: PUSH
57800: FOR_IN
57801: IFFALSE 58226
// begin tag := GetTag ( i ) + 1 ;
57803: LD_ADDR_VAR 0 9
57807: PUSH
57808: LD_VAR 0 4
57812: PPUSH
57813: CALL_OW 110
57817: PUSH
57818: LD_INT 1
57820: PLUS
57821: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 4 ) ;
57822: LD_ADDR_VAR 0 7
57826: PUSH
57827: LD_VAR 0 4
57831: PPUSH
57832: CALL_OW 250
57836: PPUSH
57837: LD_VAR 0 4
57841: PPUSH
57842: CALL_OW 251
57846: PPUSH
57847: LD_INT 4
57849: PPUSH
57850: CALL 57423 0 3
57854: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr > 2 and not GetWeapon ( i ) in ignoreCratesWeapon then
57855: LD_VAR 0 4
57859: PPUSH
57860: CALL_OW 247
57864: PUSH
57865: LD_INT 2
57867: EQUAL
57868: PUSH
57869: LD_VAR 0 7
57873: PUSH
57874: LD_INT 2
57876: GREATER
57877: AND
57878: PUSH
57879: LD_VAR 0 4
57883: PPUSH
57884: CALL_OW 264
57888: PUSH
57889: LD_VAR 0 10
57893: IN
57894: NOT
57895: AND
57896: IFFALSE 57935
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
57898: LD_VAR 0 4
57902: PPUSH
57903: LD_VAR 0 7
57907: PUSH
57908: LD_INT 1
57910: ARRAY
57911: PUSH
57912: LD_INT 1
57914: ARRAY
57915: PPUSH
57916: LD_VAR 0 7
57920: PUSH
57921: LD_INT 1
57923: ARRAY
57924: PUSH
57925: LD_INT 2
57927: ARRAY
57928: PPUSH
57929: CALL_OW 116
57933: GO 58224
// if path > tag then
57935: LD_VAR 0 2
57939: PUSH
57940: LD_VAR 0 9
57944: GREATER
57945: IFFALSE 58153
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
57947: LD_ADDR_VAR 0 6
57951: PUSH
57952: LD_VAR 0 5
57956: PPUSH
57957: LD_INT 91
57959: PUSH
57960: LD_VAR 0 4
57964: PUSH
57965: LD_INT 8
57967: PUSH
57968: EMPTY
57969: LIST
57970: LIST
57971: LIST
57972: PPUSH
57973: CALL_OW 72
57977: ST_TO_ADDR
// if nearEnemy then
57978: LD_VAR 0 6
57982: IFFALSE 58051
// begin if GetWeapon ( i ) = ru_time_lapser then
57984: LD_VAR 0 4
57988: PPUSH
57989: CALL_OW 264
57993: PUSH
57994: LD_INT 49
57996: EQUAL
57997: IFFALSE 58025
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
57999: LD_VAR 0 4
58003: PPUSH
58004: LD_VAR 0 6
58008: PPUSH
58009: LD_VAR 0 4
58013: PPUSH
58014: CALL_OW 74
58018: PPUSH
58019: CALL_OW 112
58023: GO 58049
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
58025: LD_VAR 0 4
58029: PPUSH
58030: LD_VAR 0 6
58034: PPUSH
58035: LD_VAR 0 4
58039: PPUSH
58040: CALL_OW 74
58044: PPUSH
58045: CALL 59299 0 2
// end else
58049: GO 58151
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
58051: LD_VAR 0 4
58055: PPUSH
58056: LD_VAR 0 2
58060: PUSH
58061: LD_VAR 0 9
58065: ARRAY
58066: PUSH
58067: LD_INT 1
58069: ARRAY
58070: PPUSH
58071: LD_VAR 0 2
58075: PUSH
58076: LD_VAR 0 9
58080: ARRAY
58081: PUSH
58082: LD_INT 2
58084: ARRAY
58085: PPUSH
58086: CALL_OW 297
58090: PUSH
58091: LD_INT 6
58093: GREATER
58094: IFFALSE 58137
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
58096: LD_VAR 0 4
58100: PPUSH
58101: LD_VAR 0 2
58105: PUSH
58106: LD_VAR 0 9
58110: ARRAY
58111: PUSH
58112: LD_INT 1
58114: ARRAY
58115: PPUSH
58116: LD_VAR 0 2
58120: PUSH
58121: LD_VAR 0 9
58125: ARRAY
58126: PUSH
58127: LD_INT 2
58129: ARRAY
58130: PPUSH
58131: CALL_OW 114
58135: GO 58151
// SetTag ( i , tag ) ;
58137: LD_VAR 0 4
58141: PPUSH
58142: LD_VAR 0 9
58146: PPUSH
58147: CALL_OW 109
// end else
58151: GO 58224
// if enemy then
58153: LD_VAR 0 5
58157: IFFALSE 58224
// begin if GetWeapon ( i ) = ru_time_lapser then
58159: LD_VAR 0 4
58163: PPUSH
58164: CALL_OW 264
58168: PUSH
58169: LD_INT 49
58171: EQUAL
58172: IFFALSE 58200
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
58174: LD_VAR 0 4
58178: PPUSH
58179: LD_VAR 0 5
58183: PPUSH
58184: LD_VAR 0 4
58188: PPUSH
58189: CALL_OW 74
58193: PPUSH
58194: CALL_OW 112
58198: GO 58224
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
58200: LD_VAR 0 4
58204: PPUSH
58205: LD_VAR 0 5
58209: PPUSH
58210: LD_VAR 0 4
58214: PPUSH
58215: CALL_OW 74
58219: PPUSH
58220: CALL 59299 0 2
// end ; end ;
58224: GO 57800
58226: POP
58227: POP
// end ;
58228: LD_VAR 0 3
58232: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
58233: LD_INT 0
58235: PPUSH
58236: PPUSH
58237: PPUSH
// if not unit or IsInUnit ( unit ) then
58238: LD_VAR 0 1
58242: NOT
58243: PUSH
58244: LD_VAR 0 1
58248: PPUSH
58249: CALL_OW 310
58253: OR
58254: IFFALSE 58258
// exit ;
58256: GO 58349
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
58258: LD_ADDR_VAR 0 4
58262: PUSH
58263: LD_VAR 0 1
58267: PPUSH
58268: CALL_OW 250
58272: PPUSH
58273: LD_VAR 0 2
58277: PPUSH
58278: LD_INT 1
58280: PPUSH
58281: CALL_OW 272
58285: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
58286: LD_ADDR_VAR 0 5
58290: PUSH
58291: LD_VAR 0 1
58295: PPUSH
58296: CALL_OW 251
58300: PPUSH
58301: LD_VAR 0 2
58305: PPUSH
58306: LD_INT 1
58308: PPUSH
58309: CALL_OW 273
58313: ST_TO_ADDR
// if ValidHex ( x , y ) then
58314: LD_VAR 0 4
58318: PPUSH
58319: LD_VAR 0 5
58323: PPUSH
58324: CALL_OW 488
58328: IFFALSE 58349
// ComTurnXY ( unit , x , y ) ;
58330: LD_VAR 0 1
58334: PPUSH
58335: LD_VAR 0 4
58339: PPUSH
58340: LD_VAR 0 5
58344: PPUSH
58345: CALL_OW 118
// end ;
58349: LD_VAR 0 3
58353: RET
// export function SeeUnits ( side , units ) ; var i ; begin
58354: LD_INT 0
58356: PPUSH
58357: PPUSH
// result := false ;
58358: LD_ADDR_VAR 0 3
58362: PUSH
58363: LD_INT 0
58365: ST_TO_ADDR
// if not units then
58366: LD_VAR 0 2
58370: NOT
58371: IFFALSE 58375
// exit ;
58373: GO 58420
// for i in units do
58375: LD_ADDR_VAR 0 4
58379: PUSH
58380: LD_VAR 0 2
58384: PUSH
58385: FOR_IN
58386: IFFALSE 58418
// if See ( side , i ) then
58388: LD_VAR 0 1
58392: PPUSH
58393: LD_VAR 0 4
58397: PPUSH
58398: CALL_OW 292
58402: IFFALSE 58416
// begin result := true ;
58404: LD_ADDR_VAR 0 3
58408: PUSH
58409: LD_INT 1
58411: ST_TO_ADDR
// exit ;
58412: POP
58413: POP
58414: GO 58420
// end ;
58416: GO 58385
58418: POP
58419: POP
// end ;
58420: LD_VAR 0 3
58424: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
58425: LD_INT 0
58427: PPUSH
58428: PPUSH
58429: PPUSH
58430: PPUSH
// if not unit or not points then
58431: LD_VAR 0 1
58435: NOT
58436: PUSH
58437: LD_VAR 0 2
58441: NOT
58442: OR
58443: IFFALSE 58447
// exit ;
58445: GO 58537
// dist := 99999 ;
58447: LD_ADDR_VAR 0 5
58451: PUSH
58452: LD_INT 99999
58454: ST_TO_ADDR
// for i in points do
58455: LD_ADDR_VAR 0 4
58459: PUSH
58460: LD_VAR 0 2
58464: PUSH
58465: FOR_IN
58466: IFFALSE 58535
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
58468: LD_ADDR_VAR 0 6
58472: PUSH
58473: LD_VAR 0 1
58477: PPUSH
58478: LD_VAR 0 4
58482: PUSH
58483: LD_INT 1
58485: ARRAY
58486: PPUSH
58487: LD_VAR 0 4
58491: PUSH
58492: LD_INT 2
58494: ARRAY
58495: PPUSH
58496: CALL_OW 297
58500: ST_TO_ADDR
// if tmpDist < dist then
58501: LD_VAR 0 6
58505: PUSH
58506: LD_VAR 0 5
58510: LESS
58511: IFFALSE 58533
// begin result := i ;
58513: LD_ADDR_VAR 0 3
58517: PUSH
58518: LD_VAR 0 4
58522: ST_TO_ADDR
// dist := tmpDist ;
58523: LD_ADDR_VAR 0 5
58527: PUSH
58528: LD_VAR 0 6
58532: ST_TO_ADDR
// end ; end ;
58533: GO 58465
58535: POP
58536: POP
// end ;
58537: LD_VAR 0 3
58541: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
58542: LD_INT 0
58544: PPUSH
// uc_side := side ;
58545: LD_ADDR_OWVAR 20
58549: PUSH
58550: LD_VAR 0 1
58554: ST_TO_ADDR
// uc_nation := 3 ;
58555: LD_ADDR_OWVAR 21
58559: PUSH
58560: LD_INT 3
58562: ST_TO_ADDR
// vc_chassis := 25 ;
58563: LD_ADDR_OWVAR 37
58567: PUSH
58568: LD_INT 25
58570: ST_TO_ADDR
// vc_engine := engine_siberite ;
58571: LD_ADDR_OWVAR 39
58575: PUSH
58576: LD_INT 3
58578: ST_TO_ADDR
// vc_control := control_computer ;
58579: LD_ADDR_OWVAR 38
58583: PUSH
58584: LD_INT 3
58586: ST_TO_ADDR
// vc_weapon := 59 ;
58587: LD_ADDR_OWVAR 40
58591: PUSH
58592: LD_INT 59
58594: ST_TO_ADDR
// result := CreateVehicle ;
58595: LD_ADDR_VAR 0 5
58599: PUSH
58600: CALL_OW 45
58604: ST_TO_ADDR
// SetDir ( result , d ) ;
58605: LD_VAR 0 5
58609: PPUSH
58610: LD_VAR 0 4
58614: PPUSH
58615: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
58619: LD_VAR 0 5
58623: PPUSH
58624: LD_VAR 0 2
58628: PPUSH
58629: LD_VAR 0 3
58633: PPUSH
58634: LD_INT 0
58636: PPUSH
58637: CALL_OW 48
// end ;
58641: LD_VAR 0 5
58645: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
58646: LD_INT 0
58648: PPUSH
58649: PPUSH
58650: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
58651: LD_ADDR_VAR 0 2
58655: PUSH
58656: LD_INT 0
58658: PUSH
58659: LD_INT 0
58661: PUSH
58662: LD_INT 0
58664: PUSH
58665: LD_INT 0
58667: PUSH
58668: EMPTY
58669: LIST
58670: LIST
58671: LIST
58672: LIST
58673: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
58674: LD_VAR 0 1
58678: NOT
58679: PUSH
58680: LD_VAR 0 1
58684: PPUSH
58685: CALL_OW 264
58689: PUSH
58690: LD_INT 12
58692: PUSH
58693: LD_INT 51
58695: PUSH
58696: LD_INT 32
58698: PUSH
58699: LD_INT 89
58701: PUSH
58702: EMPTY
58703: LIST
58704: LIST
58705: LIST
58706: LIST
58707: IN
58708: NOT
58709: OR
58710: IFFALSE 58714
// exit ;
58712: GO 58812
// for i := 1 to 3 do
58714: LD_ADDR_VAR 0 3
58718: PUSH
58719: DOUBLE
58720: LD_INT 1
58722: DEC
58723: ST_TO_ADDR
58724: LD_INT 3
58726: PUSH
58727: FOR_TO
58728: IFFALSE 58810
// begin tmp := GetCargo ( cargo , i ) ;
58730: LD_ADDR_VAR 0 4
58734: PUSH
58735: LD_VAR 0 1
58739: PPUSH
58740: LD_VAR 0 3
58744: PPUSH
58745: CALL_OW 289
58749: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
58750: LD_ADDR_VAR 0 2
58754: PUSH
58755: LD_VAR 0 2
58759: PPUSH
58760: LD_VAR 0 3
58764: PPUSH
58765: LD_VAR 0 4
58769: PPUSH
58770: CALL_OW 1
58774: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
58775: LD_ADDR_VAR 0 2
58779: PUSH
58780: LD_VAR 0 2
58784: PPUSH
58785: LD_INT 4
58787: PPUSH
58788: LD_VAR 0 2
58792: PUSH
58793: LD_INT 4
58795: ARRAY
58796: PUSH
58797: LD_VAR 0 4
58801: PLUS
58802: PPUSH
58803: CALL_OW 1
58807: ST_TO_ADDR
// end ;
58808: GO 58727
58810: POP
58811: POP
// end ;
58812: LD_VAR 0 2
58816: RET
// export function Length ( array ) ; begin
58817: LD_INT 0
58819: PPUSH
// result := array + 0 ;
58820: LD_ADDR_VAR 0 2
58824: PUSH
58825: LD_VAR 0 1
58829: PUSH
58830: LD_INT 0
58832: PLUS
58833: ST_TO_ADDR
// end ;
58834: LD_VAR 0 2
58838: RET
// export function PrepareArray ( array ) ; begin
58839: LD_INT 0
58841: PPUSH
// result := array diff 0 ;
58842: LD_ADDR_VAR 0 2
58846: PUSH
58847: LD_VAR 0 1
58851: PUSH
58852: LD_INT 0
58854: DIFF
58855: ST_TO_ADDR
// if not result [ 1 ] then
58856: LD_VAR 0 2
58860: PUSH
58861: LD_INT 1
58863: ARRAY
58864: NOT
58865: IFFALSE 58885
// result := Delete ( result , 1 ) ;
58867: LD_ADDR_VAR 0 2
58871: PUSH
58872: LD_VAR 0 2
58876: PPUSH
58877: LD_INT 1
58879: PPUSH
58880: CALL_OW 3
58884: ST_TO_ADDR
// end ;
58885: LD_VAR 0 2
58889: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
58890: LD_INT 0
58892: PPUSH
58893: PPUSH
58894: PPUSH
58895: PPUSH
// sibRocketRange := 25 ;
58896: LD_ADDR_VAR 0 6
58900: PUSH
58901: LD_INT 25
58903: ST_TO_ADDR
// result := false ;
58904: LD_ADDR_VAR 0 4
58908: PUSH
58909: LD_INT 0
58911: ST_TO_ADDR
// for i := 0 to 5 do
58912: LD_ADDR_VAR 0 5
58916: PUSH
58917: DOUBLE
58918: LD_INT 0
58920: DEC
58921: ST_TO_ADDR
58922: LD_INT 5
58924: PUSH
58925: FOR_TO
58926: IFFALSE 58993
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
58928: LD_VAR 0 1
58932: PPUSH
58933: LD_VAR 0 5
58937: PPUSH
58938: LD_VAR 0 6
58942: PPUSH
58943: CALL_OW 272
58947: PPUSH
58948: LD_VAR 0 2
58952: PPUSH
58953: LD_VAR 0 5
58957: PPUSH
58958: LD_VAR 0 6
58962: PPUSH
58963: CALL_OW 273
58967: PPUSH
58968: LD_VAR 0 3
58972: PPUSH
58973: CALL_OW 309
58977: IFFALSE 58991
// begin result := true ;
58979: LD_ADDR_VAR 0 4
58983: PUSH
58984: LD_INT 1
58986: ST_TO_ADDR
// exit ;
58987: POP
58988: POP
58989: GO 58995
// end ;
58991: GO 58925
58993: POP
58994: POP
// end ;
58995: LD_VAR 0 4
58999: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
59000: LD_INT 0
59002: PPUSH
59003: PPUSH
59004: PPUSH
// if btype = b_depot then
59005: LD_VAR 0 2
59009: PUSH
59010: LD_INT 0
59012: EQUAL
59013: IFFALSE 59025
// begin result := true ;
59015: LD_ADDR_VAR 0 3
59019: PUSH
59020: LD_INT 1
59022: ST_TO_ADDR
// exit ;
59023: GO 59141
// end ; pom := GetBase ( depot ) ;
59025: LD_ADDR_VAR 0 4
59029: PUSH
59030: LD_VAR 0 1
59034: PPUSH
59035: CALL_OW 274
59039: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
59040: LD_ADDR_VAR 0 5
59044: PUSH
59045: LD_VAR 0 2
59049: PPUSH
59050: LD_VAR 0 1
59054: PPUSH
59055: CALL_OW 248
59059: PPUSH
59060: CALL_OW 450
59064: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
59065: LD_ADDR_VAR 0 3
59069: PUSH
59070: LD_VAR 0 4
59074: PPUSH
59075: LD_INT 1
59077: PPUSH
59078: CALL_OW 275
59082: PUSH
59083: LD_VAR 0 5
59087: PUSH
59088: LD_INT 1
59090: ARRAY
59091: GREATEREQUAL
59092: PUSH
59093: LD_VAR 0 4
59097: PPUSH
59098: LD_INT 2
59100: PPUSH
59101: CALL_OW 275
59105: PUSH
59106: LD_VAR 0 5
59110: PUSH
59111: LD_INT 2
59113: ARRAY
59114: GREATEREQUAL
59115: AND
59116: PUSH
59117: LD_VAR 0 4
59121: PPUSH
59122: LD_INT 3
59124: PPUSH
59125: CALL_OW 275
59129: PUSH
59130: LD_VAR 0 5
59134: PUSH
59135: LD_INT 3
59137: ARRAY
59138: GREATEREQUAL
59139: AND
59140: ST_TO_ADDR
// end ;
59141: LD_VAR 0 3
59145: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
59146: LD_INT 0
59148: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
59149: LD_VAR 0 1
59153: PPUSH
59154: LD_VAR 0 2
59158: PPUSH
59159: LD_INT 0
59161: PPUSH
59162: LD_INT 0
59164: PPUSH
59165: LD_INT 1
59167: PPUSH
59168: LD_INT 0
59170: PPUSH
59171: CALL_OW 587
// end ;
59175: LD_VAR 0 3
59179: RET
// export function CenterOnNow ( unit ) ; begin
59180: LD_INT 0
59182: PPUSH
// result := IsInUnit ( unit ) ;
59183: LD_ADDR_VAR 0 2
59187: PUSH
59188: LD_VAR 0 1
59192: PPUSH
59193: CALL_OW 310
59197: ST_TO_ADDR
// if not result then
59198: LD_VAR 0 2
59202: NOT
59203: IFFALSE 59215
// result := unit ;
59205: LD_ADDR_VAR 0 2
59209: PUSH
59210: LD_VAR 0 1
59214: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
59215: LD_VAR 0 1
59219: PPUSH
59220: CALL_OW 87
// end ;
59224: LD_VAR 0 2
59228: RET
// export function ComMoveHex ( unit , hex ) ; begin
59229: LD_INT 0
59231: PPUSH
// if not hex then
59232: LD_VAR 0 2
59236: NOT
59237: IFFALSE 59241
// exit ;
59239: GO 59294
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
59241: LD_VAR 0 2
59245: PUSH
59246: LD_INT 1
59248: ARRAY
59249: PPUSH
59250: LD_VAR 0 2
59254: PUSH
59255: LD_INT 2
59257: ARRAY
59258: PPUSH
59259: CALL_OW 428
59263: IFFALSE 59267
// exit ;
59265: GO 59294
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
59267: LD_VAR 0 1
59271: PPUSH
59272: LD_VAR 0 2
59276: PUSH
59277: LD_INT 1
59279: ARRAY
59280: PPUSH
59281: LD_VAR 0 2
59285: PUSH
59286: LD_INT 2
59288: ARRAY
59289: PPUSH
59290: CALL_OW 111
// end ;
59294: LD_VAR 0 3
59298: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
59299: LD_INT 0
59301: PPUSH
59302: PPUSH
59303: PPUSH
// if not unit or not enemy then
59304: LD_VAR 0 1
59308: NOT
59309: PUSH
59310: LD_VAR 0 2
59314: NOT
59315: OR
59316: IFFALSE 59320
// exit ;
59318: GO 59444
// x := GetX ( enemy ) ;
59320: LD_ADDR_VAR 0 4
59324: PUSH
59325: LD_VAR 0 2
59329: PPUSH
59330: CALL_OW 250
59334: ST_TO_ADDR
// y := GetY ( enemy ) ;
59335: LD_ADDR_VAR 0 5
59339: PUSH
59340: LD_VAR 0 2
59344: PPUSH
59345: CALL_OW 251
59349: ST_TO_ADDR
// if ValidHex ( x , y ) then
59350: LD_VAR 0 4
59354: PPUSH
59355: LD_VAR 0 5
59359: PPUSH
59360: CALL_OW 488
59364: IFFALSE 59444
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
59366: LD_VAR 0 2
59370: PPUSH
59371: CALL_OW 247
59375: PUSH
59376: LD_INT 3
59378: PUSH
59379: LD_INT 2
59381: PUSH
59382: EMPTY
59383: LIST
59384: LIST
59385: IN
59386: PUSH
59387: LD_VAR 0 1
59391: PPUSH
59392: CALL_OW 255
59396: PPUSH
59397: LD_VAR 0 2
59401: PPUSH
59402: CALL_OW 292
59406: OR
59407: IFFALSE 59425
// ComAttackUnit ( unit , enemy ) else
59409: LD_VAR 0 1
59413: PPUSH
59414: LD_VAR 0 2
59418: PPUSH
59419: CALL_OW 115
59423: GO 59444
// ComAgressiveMove ( unit , x , y ) ;
59425: LD_VAR 0 1
59429: PPUSH
59430: LD_VAR 0 4
59434: PPUSH
59435: LD_VAR 0 5
59439: PPUSH
59440: CALL_OW 114
// end ;
59444: LD_VAR 0 3
59448: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
59449: LD_INT 0
59451: PPUSH
59452: PPUSH
59453: PPUSH
// list := AreaToList ( area , 0 ) ;
59454: LD_ADDR_VAR 0 5
59458: PUSH
59459: LD_VAR 0 1
59463: PPUSH
59464: LD_INT 0
59466: PPUSH
59467: CALL_OW 517
59471: ST_TO_ADDR
// if not list then
59472: LD_VAR 0 5
59476: NOT
59477: IFFALSE 59481
// exit ;
59479: GO 59611
// if all then
59481: LD_VAR 0 2
59485: IFFALSE 59573
// begin for i := 1 to list [ 1 ] do
59487: LD_ADDR_VAR 0 4
59491: PUSH
59492: DOUBLE
59493: LD_INT 1
59495: DEC
59496: ST_TO_ADDR
59497: LD_VAR 0 5
59501: PUSH
59502: LD_INT 1
59504: ARRAY
59505: PUSH
59506: FOR_TO
59507: IFFALSE 59569
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
59509: LD_ADDR_VAR 0 3
59513: PUSH
59514: LD_VAR 0 3
59518: PPUSH
59519: LD_VAR 0 3
59523: PUSH
59524: LD_INT 1
59526: PLUS
59527: PPUSH
59528: LD_VAR 0 5
59532: PUSH
59533: LD_INT 1
59535: ARRAY
59536: PUSH
59537: LD_VAR 0 4
59541: ARRAY
59542: PUSH
59543: LD_VAR 0 5
59547: PUSH
59548: LD_INT 2
59550: ARRAY
59551: PUSH
59552: LD_VAR 0 4
59556: ARRAY
59557: PUSH
59558: EMPTY
59559: LIST
59560: LIST
59561: PPUSH
59562: CALL_OW 1
59566: ST_TO_ADDR
59567: GO 59506
59569: POP
59570: POP
// exit ;
59571: GO 59611
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
59573: LD_ADDR_VAR 0 3
59577: PUSH
59578: LD_VAR 0 5
59582: PUSH
59583: LD_INT 1
59585: ARRAY
59586: PUSH
59587: LD_INT 1
59589: ARRAY
59590: PUSH
59591: LD_VAR 0 5
59595: PUSH
59596: LD_INT 2
59598: ARRAY
59599: PUSH
59600: LD_INT 1
59602: ARRAY
59603: PUSH
59604: EMPTY
59605: LIST
59606: LIST
59607: PUSH
59608: EMPTY
59609: LIST
59610: ST_TO_ADDR
// end ;
59611: LD_VAR 0 3
59615: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
59616: LD_INT 0
59618: PPUSH
59619: PPUSH
// list := AreaToList ( area , 0 ) ;
59620: LD_ADDR_VAR 0 4
59624: PUSH
59625: LD_VAR 0 1
59629: PPUSH
59630: LD_INT 0
59632: PPUSH
59633: CALL_OW 517
59637: ST_TO_ADDR
// if not list then
59638: LD_VAR 0 4
59642: NOT
59643: IFFALSE 59647
// exit ;
59645: GO 59688
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
59647: LD_ADDR_VAR 0 3
59651: PUSH
59652: LD_VAR 0 4
59656: PUSH
59657: LD_INT 1
59659: ARRAY
59660: PUSH
59661: LD_INT 1
59663: ARRAY
59664: PUSH
59665: LD_VAR 0 4
59669: PUSH
59670: LD_INT 2
59672: ARRAY
59673: PUSH
59674: LD_INT 1
59676: ARRAY
59677: PUSH
59678: LD_VAR 0 2
59682: PUSH
59683: EMPTY
59684: LIST
59685: LIST
59686: LIST
59687: ST_TO_ADDR
// end ;
59688: LD_VAR 0 3
59692: RET
// export function First ( array ) ; begin
59693: LD_INT 0
59695: PPUSH
// if not array then
59696: LD_VAR 0 1
59700: NOT
59701: IFFALSE 59705
// exit ;
59703: GO 59719
// result := array [ 1 ] ;
59705: LD_ADDR_VAR 0 2
59709: PUSH
59710: LD_VAR 0 1
59714: PUSH
59715: LD_INT 1
59717: ARRAY
59718: ST_TO_ADDR
// end ;
59719: LD_VAR 0 2
59723: RET
// export function Last ( array ) ; begin
59724: LD_INT 0
59726: PPUSH
// if not array then
59727: LD_VAR 0 1
59731: NOT
59732: IFFALSE 59736
// exit ;
59734: GO 59752
// result := array [ array ] ;
59736: LD_ADDR_VAR 0 2
59740: PUSH
59741: LD_VAR 0 1
59745: PUSH
59746: LD_VAR 0 1
59750: ARRAY
59751: ST_TO_ADDR
// end ;
59752: LD_VAR 0 2
59756: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
59757: LD_INT 0
59759: PPUSH
59760: PPUSH
// result := [ ] ;
59761: LD_ADDR_VAR 0 5
59765: PUSH
59766: EMPTY
59767: ST_TO_ADDR
// if not array then
59768: LD_VAR 0 1
59772: NOT
59773: IFFALSE 59777
// exit ;
59775: GO 59889
// for i := 1 to array do
59777: LD_ADDR_VAR 0 6
59781: PUSH
59782: DOUBLE
59783: LD_INT 1
59785: DEC
59786: ST_TO_ADDR
59787: LD_VAR 0 1
59791: PUSH
59792: FOR_TO
59793: IFFALSE 59887
// if array [ i ] [ index ] = value then
59795: LD_VAR 0 1
59799: PUSH
59800: LD_VAR 0 6
59804: ARRAY
59805: PUSH
59806: LD_VAR 0 2
59810: ARRAY
59811: PUSH
59812: LD_VAR 0 3
59816: EQUAL
59817: IFFALSE 59885
// begin if indexColumn then
59819: LD_VAR 0 4
59823: IFFALSE 59859
// result := Join ( result , array [ i ] [ indexColumn ] ) else
59825: LD_ADDR_VAR 0 5
59829: PUSH
59830: LD_VAR 0 5
59834: PPUSH
59835: LD_VAR 0 1
59839: PUSH
59840: LD_VAR 0 6
59844: ARRAY
59845: PUSH
59846: LD_VAR 0 4
59850: ARRAY
59851: PPUSH
59852: CALL 55071 0 2
59856: ST_TO_ADDR
59857: GO 59885
// result := Join ( result , array [ i ] ) ;
59859: LD_ADDR_VAR 0 5
59863: PUSH
59864: LD_VAR 0 5
59868: PPUSH
59869: LD_VAR 0 1
59873: PUSH
59874: LD_VAR 0 6
59878: ARRAY
59879: PPUSH
59880: CALL 55071 0 2
59884: ST_TO_ADDR
// end ;
59885: GO 59792
59887: POP
59888: POP
// end ;
59889: LD_VAR 0 5
59893: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
59894: LD_INT 0
59896: PPUSH
// if not vehicles or not parkingPoint then
59897: LD_VAR 0 1
59901: NOT
59902: PUSH
59903: LD_VAR 0 2
59907: NOT
59908: OR
59909: IFFALSE 59913
// exit ;
59911: GO 60011
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
59913: LD_ADDR_VAR 0 1
59917: PUSH
59918: LD_VAR 0 1
59922: PPUSH
59923: LD_INT 50
59925: PUSH
59926: EMPTY
59927: LIST
59928: PUSH
59929: LD_INT 3
59931: PUSH
59932: LD_INT 92
59934: PUSH
59935: LD_VAR 0 2
59939: PUSH
59940: LD_INT 1
59942: ARRAY
59943: PUSH
59944: LD_VAR 0 2
59948: PUSH
59949: LD_INT 2
59951: ARRAY
59952: PUSH
59953: LD_INT 8
59955: PUSH
59956: EMPTY
59957: LIST
59958: LIST
59959: LIST
59960: LIST
59961: PUSH
59962: EMPTY
59963: LIST
59964: LIST
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: PPUSH
59970: CALL_OW 72
59974: ST_TO_ADDR
// if not vehicles then
59975: LD_VAR 0 1
59979: NOT
59980: IFFALSE 59984
// exit ;
59982: GO 60011
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
59984: LD_VAR 0 1
59988: PPUSH
59989: LD_VAR 0 2
59993: PUSH
59994: LD_INT 1
59996: ARRAY
59997: PPUSH
59998: LD_VAR 0 2
60002: PUSH
60003: LD_INT 2
60005: ARRAY
60006: PPUSH
60007: CALL_OW 111
// end ;
60011: LD_VAR 0 3
60015: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
60016: LD_INT 0
60018: PPUSH
60019: PPUSH
60020: PPUSH
// if not side or not area then
60021: LD_VAR 0 1
60025: NOT
60026: PUSH
60027: LD_VAR 0 2
60031: NOT
60032: OR
60033: IFFALSE 60037
// exit ;
60035: GO 60156
// tmp := AreaToList ( area , 0 ) ;
60037: LD_ADDR_VAR 0 5
60041: PUSH
60042: LD_VAR 0 2
60046: PPUSH
60047: LD_INT 0
60049: PPUSH
60050: CALL_OW 517
60054: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
60055: LD_ADDR_VAR 0 4
60059: PUSH
60060: DOUBLE
60061: LD_INT 1
60063: DEC
60064: ST_TO_ADDR
60065: LD_VAR 0 5
60069: PUSH
60070: LD_INT 1
60072: ARRAY
60073: PUSH
60074: FOR_TO
60075: IFFALSE 60154
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
60077: LD_VAR 0 5
60081: PUSH
60082: LD_INT 1
60084: ARRAY
60085: PUSH
60086: LD_VAR 0 4
60090: ARRAY
60091: PPUSH
60092: LD_VAR 0 5
60096: PUSH
60097: LD_INT 2
60099: ARRAY
60100: PUSH
60101: LD_VAR 0 4
60105: ARRAY
60106: PPUSH
60107: CALL_OW 351
60111: IFFALSE 60152
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
60113: LD_VAR 0 5
60117: PUSH
60118: LD_INT 1
60120: ARRAY
60121: PUSH
60122: LD_VAR 0 4
60126: ARRAY
60127: PPUSH
60128: LD_VAR 0 5
60132: PUSH
60133: LD_INT 2
60135: ARRAY
60136: PUSH
60137: LD_VAR 0 4
60141: ARRAY
60142: PPUSH
60143: LD_VAR 0 1
60147: PPUSH
60148: CALL_OW 244
// end ;
60152: GO 60074
60154: POP
60155: POP
// end ; end_of_file
60156: LD_VAR 0 3
60160: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
60161: LD_INT 0
60163: PPUSH
60164: PPUSH
// skirmish := false ;
60165: LD_ADDR_EXP 61
60169: PUSH
60170: LD_INT 0
60172: ST_TO_ADDR
// debug_mc := false ;
60173: LD_ADDR_EXP 62
60177: PUSH
60178: LD_INT 0
60180: ST_TO_ADDR
// mc_bases := [ ] ;
60181: LD_ADDR_EXP 63
60185: PUSH
60186: EMPTY
60187: ST_TO_ADDR
// mc_sides := [ ] ;
60188: LD_ADDR_EXP 89
60192: PUSH
60193: EMPTY
60194: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
60195: LD_ADDR_EXP 64
60199: PUSH
60200: EMPTY
60201: ST_TO_ADDR
// mc_building_repairs := [ ] ;
60202: LD_ADDR_EXP 65
60206: PUSH
60207: EMPTY
60208: ST_TO_ADDR
// mc_need_heal := [ ] ;
60209: LD_ADDR_EXP 66
60213: PUSH
60214: EMPTY
60215: ST_TO_ADDR
// mc_healers := [ ] ;
60216: LD_ADDR_EXP 67
60220: PUSH
60221: EMPTY
60222: ST_TO_ADDR
// mc_build_list := [ ] ;
60223: LD_ADDR_EXP 68
60227: PUSH
60228: EMPTY
60229: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
60230: LD_ADDR_EXP 95
60234: PUSH
60235: EMPTY
60236: ST_TO_ADDR
// mc_builders := [ ] ;
60237: LD_ADDR_EXP 69
60241: PUSH
60242: EMPTY
60243: ST_TO_ADDR
// mc_construct_list := [ ] ;
60244: LD_ADDR_EXP 70
60248: PUSH
60249: EMPTY
60250: ST_TO_ADDR
// mc_turret_list := [ ] ;
60251: LD_ADDR_EXP 71
60255: PUSH
60256: EMPTY
60257: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
60258: LD_ADDR_EXP 72
60262: PUSH
60263: EMPTY
60264: ST_TO_ADDR
// mc_miners := [ ] ;
60265: LD_ADDR_EXP 77
60269: PUSH
60270: EMPTY
60271: ST_TO_ADDR
// mc_mines := [ ] ;
60272: LD_ADDR_EXP 76
60276: PUSH
60277: EMPTY
60278: ST_TO_ADDR
// mc_minefields := [ ] ;
60279: LD_ADDR_EXP 78
60283: PUSH
60284: EMPTY
60285: ST_TO_ADDR
// mc_crates := [ ] ;
60286: LD_ADDR_EXP 79
60290: PUSH
60291: EMPTY
60292: ST_TO_ADDR
// mc_crates_collector := [ ] ;
60293: LD_ADDR_EXP 80
60297: PUSH
60298: EMPTY
60299: ST_TO_ADDR
// mc_crates_area := [ ] ;
60300: LD_ADDR_EXP 81
60304: PUSH
60305: EMPTY
60306: ST_TO_ADDR
// mc_vehicles := [ ] ;
60307: LD_ADDR_EXP 82
60311: PUSH
60312: EMPTY
60313: ST_TO_ADDR
// mc_attack := [ ] ;
60314: LD_ADDR_EXP 83
60318: PUSH
60319: EMPTY
60320: ST_TO_ADDR
// mc_produce := [ ] ;
60321: LD_ADDR_EXP 84
60325: PUSH
60326: EMPTY
60327: ST_TO_ADDR
// mc_defender := [ ] ;
60328: LD_ADDR_EXP 85
60332: PUSH
60333: EMPTY
60334: ST_TO_ADDR
// mc_parking := [ ] ;
60335: LD_ADDR_EXP 87
60339: PUSH
60340: EMPTY
60341: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
60342: LD_ADDR_EXP 73
60346: PUSH
60347: EMPTY
60348: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
60349: LD_ADDR_EXP 75
60353: PUSH
60354: EMPTY
60355: ST_TO_ADDR
// mc_scan := [ ] ;
60356: LD_ADDR_EXP 86
60360: PUSH
60361: EMPTY
60362: ST_TO_ADDR
// mc_scan_area := [ ] ;
60363: LD_ADDR_EXP 88
60367: PUSH
60368: EMPTY
60369: ST_TO_ADDR
// mc_tech := [ ] ;
60370: LD_ADDR_EXP 90
60374: PUSH
60375: EMPTY
60376: ST_TO_ADDR
// mc_class := [ ] ;
60377: LD_ADDR_EXP 104
60381: PUSH
60382: EMPTY
60383: ST_TO_ADDR
// mc_class_case_use := [ ] ;
60384: LD_ADDR_EXP 105
60388: PUSH
60389: EMPTY
60390: ST_TO_ADDR
// mc_is_defending := [ ] ;
60391: LD_ADDR_EXP 106
60395: PUSH
60396: EMPTY
60397: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
60398: LD_ADDR_EXP 97
60402: PUSH
60403: EMPTY
60404: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
60405: LD_ADDR_EXP 107
60409: PUSH
60410: LD_INT 0
60412: ST_TO_ADDR
// end ;
60413: LD_VAR 0 1
60417: RET
// export function MC_Kill ( base ) ; begin
60418: LD_INT 0
60420: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
60421: LD_ADDR_EXP 63
60425: PUSH
60426: LD_EXP 63
60430: PPUSH
60431: LD_VAR 0 1
60435: PPUSH
60436: EMPTY
60437: PPUSH
60438: CALL_OW 1
60442: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
60443: LD_ADDR_EXP 64
60447: PUSH
60448: LD_EXP 64
60452: PPUSH
60453: LD_VAR 0 1
60457: PPUSH
60458: EMPTY
60459: PPUSH
60460: CALL_OW 1
60464: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
60465: LD_ADDR_EXP 65
60469: PUSH
60470: LD_EXP 65
60474: PPUSH
60475: LD_VAR 0 1
60479: PPUSH
60480: EMPTY
60481: PPUSH
60482: CALL_OW 1
60486: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
60487: LD_ADDR_EXP 66
60491: PUSH
60492: LD_EXP 66
60496: PPUSH
60497: LD_VAR 0 1
60501: PPUSH
60502: EMPTY
60503: PPUSH
60504: CALL_OW 1
60508: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
60509: LD_ADDR_EXP 67
60513: PUSH
60514: LD_EXP 67
60518: PPUSH
60519: LD_VAR 0 1
60523: PPUSH
60524: EMPTY
60525: PPUSH
60526: CALL_OW 1
60530: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
60531: LD_ADDR_EXP 68
60535: PUSH
60536: LD_EXP 68
60540: PPUSH
60541: LD_VAR 0 1
60545: PPUSH
60546: EMPTY
60547: PPUSH
60548: CALL_OW 1
60552: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
60553: LD_ADDR_EXP 69
60557: PUSH
60558: LD_EXP 69
60562: PPUSH
60563: LD_VAR 0 1
60567: PPUSH
60568: EMPTY
60569: PPUSH
60570: CALL_OW 1
60574: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
60575: LD_ADDR_EXP 70
60579: PUSH
60580: LD_EXP 70
60584: PPUSH
60585: LD_VAR 0 1
60589: PPUSH
60590: EMPTY
60591: PPUSH
60592: CALL_OW 1
60596: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
60597: LD_ADDR_EXP 71
60601: PUSH
60602: LD_EXP 71
60606: PPUSH
60607: LD_VAR 0 1
60611: PPUSH
60612: EMPTY
60613: PPUSH
60614: CALL_OW 1
60618: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
60619: LD_ADDR_EXP 72
60623: PUSH
60624: LD_EXP 72
60628: PPUSH
60629: LD_VAR 0 1
60633: PPUSH
60634: EMPTY
60635: PPUSH
60636: CALL_OW 1
60640: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
60641: LD_ADDR_EXP 73
60645: PUSH
60646: LD_EXP 73
60650: PPUSH
60651: LD_VAR 0 1
60655: PPUSH
60656: EMPTY
60657: PPUSH
60658: CALL_OW 1
60662: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
60663: LD_ADDR_EXP 74
60667: PUSH
60668: LD_EXP 74
60672: PPUSH
60673: LD_VAR 0 1
60677: PPUSH
60678: LD_INT 0
60680: PPUSH
60681: CALL_OW 1
60685: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
60686: LD_ADDR_EXP 75
60690: PUSH
60691: LD_EXP 75
60695: PPUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: EMPTY
60702: PPUSH
60703: CALL_OW 1
60707: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
60708: LD_ADDR_EXP 76
60712: PUSH
60713: LD_EXP 76
60717: PPUSH
60718: LD_VAR 0 1
60722: PPUSH
60723: EMPTY
60724: PPUSH
60725: CALL_OW 1
60729: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
60730: LD_ADDR_EXP 77
60734: PUSH
60735: LD_EXP 77
60739: PPUSH
60740: LD_VAR 0 1
60744: PPUSH
60745: EMPTY
60746: PPUSH
60747: CALL_OW 1
60751: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
60752: LD_ADDR_EXP 78
60756: PUSH
60757: LD_EXP 78
60761: PPUSH
60762: LD_VAR 0 1
60766: PPUSH
60767: EMPTY
60768: PPUSH
60769: CALL_OW 1
60773: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
60774: LD_ADDR_EXP 79
60778: PUSH
60779: LD_EXP 79
60783: PPUSH
60784: LD_VAR 0 1
60788: PPUSH
60789: EMPTY
60790: PPUSH
60791: CALL_OW 1
60795: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
60796: LD_ADDR_EXP 80
60800: PUSH
60801: LD_EXP 80
60805: PPUSH
60806: LD_VAR 0 1
60810: PPUSH
60811: EMPTY
60812: PPUSH
60813: CALL_OW 1
60817: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
60818: LD_ADDR_EXP 81
60822: PUSH
60823: LD_EXP 81
60827: PPUSH
60828: LD_VAR 0 1
60832: PPUSH
60833: EMPTY
60834: PPUSH
60835: CALL_OW 1
60839: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
60840: LD_ADDR_EXP 82
60844: PUSH
60845: LD_EXP 82
60849: PPUSH
60850: LD_VAR 0 1
60854: PPUSH
60855: EMPTY
60856: PPUSH
60857: CALL_OW 1
60861: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
60862: LD_ADDR_EXP 83
60866: PUSH
60867: LD_EXP 83
60871: PPUSH
60872: LD_VAR 0 1
60876: PPUSH
60877: EMPTY
60878: PPUSH
60879: CALL_OW 1
60883: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
60884: LD_ADDR_EXP 84
60888: PUSH
60889: LD_EXP 84
60893: PPUSH
60894: LD_VAR 0 1
60898: PPUSH
60899: EMPTY
60900: PPUSH
60901: CALL_OW 1
60905: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
60906: LD_ADDR_EXP 85
60910: PUSH
60911: LD_EXP 85
60915: PPUSH
60916: LD_VAR 0 1
60920: PPUSH
60921: EMPTY
60922: PPUSH
60923: CALL_OW 1
60927: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
60928: LD_ADDR_EXP 86
60932: PUSH
60933: LD_EXP 86
60937: PPUSH
60938: LD_VAR 0 1
60942: PPUSH
60943: EMPTY
60944: PPUSH
60945: CALL_OW 1
60949: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
60950: LD_ADDR_EXP 87
60954: PUSH
60955: LD_EXP 87
60959: PPUSH
60960: LD_VAR 0 1
60964: PPUSH
60965: EMPTY
60966: PPUSH
60967: CALL_OW 1
60971: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
60972: LD_ADDR_EXP 88
60976: PUSH
60977: LD_EXP 88
60981: PPUSH
60982: LD_VAR 0 1
60986: PPUSH
60987: EMPTY
60988: PPUSH
60989: CALL_OW 1
60993: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
60994: LD_ADDR_EXP 90
60998: PUSH
60999: LD_EXP 90
61003: PPUSH
61004: LD_VAR 0 1
61008: PPUSH
61009: EMPTY
61010: PPUSH
61011: CALL_OW 1
61015: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61016: LD_ADDR_EXP 92
61020: PUSH
61021: LD_EXP 92
61025: PPUSH
61026: LD_VAR 0 1
61030: PPUSH
61031: EMPTY
61032: PPUSH
61033: CALL_OW 1
61037: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
61038: LD_ADDR_EXP 93
61042: PUSH
61043: LD_EXP 93
61047: PPUSH
61048: LD_VAR 0 1
61052: PPUSH
61053: EMPTY
61054: PPUSH
61055: CALL_OW 1
61059: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
61060: LD_ADDR_EXP 94
61064: PUSH
61065: LD_EXP 94
61069: PPUSH
61070: LD_VAR 0 1
61074: PPUSH
61075: EMPTY
61076: PPUSH
61077: CALL_OW 1
61081: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
61082: LD_ADDR_EXP 95
61086: PUSH
61087: LD_EXP 95
61091: PPUSH
61092: LD_VAR 0 1
61096: PPUSH
61097: EMPTY
61098: PPUSH
61099: CALL_OW 1
61103: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
61104: LD_ADDR_EXP 96
61108: PUSH
61109: LD_EXP 96
61113: PPUSH
61114: LD_VAR 0 1
61118: PPUSH
61119: EMPTY
61120: PPUSH
61121: CALL_OW 1
61125: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
61126: LD_ADDR_EXP 97
61130: PUSH
61131: LD_EXP 97
61135: PPUSH
61136: LD_VAR 0 1
61140: PPUSH
61141: EMPTY
61142: PPUSH
61143: CALL_OW 1
61147: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
61148: LD_ADDR_EXP 98
61152: PUSH
61153: LD_EXP 98
61157: PPUSH
61158: LD_VAR 0 1
61162: PPUSH
61163: EMPTY
61164: PPUSH
61165: CALL_OW 1
61169: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
61170: LD_ADDR_EXP 99
61174: PUSH
61175: LD_EXP 99
61179: PPUSH
61180: LD_VAR 0 1
61184: PPUSH
61185: EMPTY
61186: PPUSH
61187: CALL_OW 1
61191: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
61192: LD_ADDR_EXP 100
61196: PUSH
61197: LD_EXP 100
61201: PPUSH
61202: LD_VAR 0 1
61206: PPUSH
61207: EMPTY
61208: PPUSH
61209: CALL_OW 1
61213: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
61214: LD_ADDR_EXP 101
61218: PUSH
61219: LD_EXP 101
61223: PPUSH
61224: LD_VAR 0 1
61228: PPUSH
61229: EMPTY
61230: PPUSH
61231: CALL_OW 1
61235: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
61236: LD_ADDR_EXP 102
61240: PUSH
61241: LD_EXP 102
61245: PPUSH
61246: LD_VAR 0 1
61250: PPUSH
61251: EMPTY
61252: PPUSH
61253: CALL_OW 1
61257: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
61258: LD_ADDR_EXP 103
61262: PUSH
61263: LD_EXP 103
61267: PPUSH
61268: LD_VAR 0 1
61272: PPUSH
61273: EMPTY
61274: PPUSH
61275: CALL_OW 1
61279: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
61280: LD_ADDR_EXP 104
61284: PUSH
61285: LD_EXP 104
61289: PPUSH
61290: LD_VAR 0 1
61294: PPUSH
61295: EMPTY
61296: PPUSH
61297: CALL_OW 1
61301: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
61302: LD_ADDR_EXP 105
61306: PUSH
61307: LD_EXP 105
61311: PPUSH
61312: LD_VAR 0 1
61316: PPUSH
61317: LD_INT 0
61319: PPUSH
61320: CALL_OW 1
61324: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
61325: LD_ADDR_EXP 106
61329: PUSH
61330: LD_EXP 106
61334: PPUSH
61335: LD_VAR 0 1
61339: PPUSH
61340: LD_INT 0
61342: PPUSH
61343: CALL_OW 1
61347: ST_TO_ADDR
// end ;
61348: LD_VAR 0 2
61352: RET
// export function MC_Add ( side , units ) ; var base ; begin
61353: LD_INT 0
61355: PPUSH
61356: PPUSH
// base := mc_bases + 1 ;
61357: LD_ADDR_VAR 0 4
61361: PUSH
61362: LD_EXP 63
61366: PUSH
61367: LD_INT 1
61369: PLUS
61370: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
61371: LD_ADDR_EXP 89
61375: PUSH
61376: LD_EXP 89
61380: PPUSH
61381: LD_VAR 0 4
61385: PPUSH
61386: LD_VAR 0 1
61390: PPUSH
61391: CALL_OW 1
61395: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
61396: LD_ADDR_EXP 63
61400: PUSH
61401: LD_EXP 63
61405: PPUSH
61406: LD_VAR 0 4
61410: PPUSH
61411: LD_VAR 0 2
61415: PPUSH
61416: CALL_OW 1
61420: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
61421: LD_ADDR_EXP 64
61425: PUSH
61426: LD_EXP 64
61430: PPUSH
61431: LD_VAR 0 4
61435: PPUSH
61436: EMPTY
61437: PPUSH
61438: CALL_OW 1
61442: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
61443: LD_ADDR_EXP 65
61447: PUSH
61448: LD_EXP 65
61452: PPUSH
61453: LD_VAR 0 4
61457: PPUSH
61458: EMPTY
61459: PPUSH
61460: CALL_OW 1
61464: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
61465: LD_ADDR_EXP 66
61469: PUSH
61470: LD_EXP 66
61474: PPUSH
61475: LD_VAR 0 4
61479: PPUSH
61480: EMPTY
61481: PPUSH
61482: CALL_OW 1
61486: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
61487: LD_ADDR_EXP 67
61491: PUSH
61492: LD_EXP 67
61496: PPUSH
61497: LD_VAR 0 4
61501: PPUSH
61502: EMPTY
61503: PPUSH
61504: CALL_OW 1
61508: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
61509: LD_ADDR_EXP 68
61513: PUSH
61514: LD_EXP 68
61518: PPUSH
61519: LD_VAR 0 4
61523: PPUSH
61524: EMPTY
61525: PPUSH
61526: CALL_OW 1
61530: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
61531: LD_ADDR_EXP 69
61535: PUSH
61536: LD_EXP 69
61540: PPUSH
61541: LD_VAR 0 4
61545: PPUSH
61546: EMPTY
61547: PPUSH
61548: CALL_OW 1
61552: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
61553: LD_ADDR_EXP 70
61557: PUSH
61558: LD_EXP 70
61562: PPUSH
61563: LD_VAR 0 4
61567: PPUSH
61568: EMPTY
61569: PPUSH
61570: CALL_OW 1
61574: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
61575: LD_ADDR_EXP 71
61579: PUSH
61580: LD_EXP 71
61584: PPUSH
61585: LD_VAR 0 4
61589: PPUSH
61590: EMPTY
61591: PPUSH
61592: CALL_OW 1
61596: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
61597: LD_ADDR_EXP 72
61601: PUSH
61602: LD_EXP 72
61606: PPUSH
61607: LD_VAR 0 4
61611: PPUSH
61612: EMPTY
61613: PPUSH
61614: CALL_OW 1
61618: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
61619: LD_ADDR_EXP 73
61623: PUSH
61624: LD_EXP 73
61628: PPUSH
61629: LD_VAR 0 4
61633: PPUSH
61634: EMPTY
61635: PPUSH
61636: CALL_OW 1
61640: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
61641: LD_ADDR_EXP 74
61645: PUSH
61646: LD_EXP 74
61650: PPUSH
61651: LD_VAR 0 4
61655: PPUSH
61656: LD_INT 0
61658: PPUSH
61659: CALL_OW 1
61663: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
61664: LD_ADDR_EXP 75
61668: PUSH
61669: LD_EXP 75
61673: PPUSH
61674: LD_VAR 0 4
61678: PPUSH
61679: EMPTY
61680: PPUSH
61681: CALL_OW 1
61685: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
61686: LD_ADDR_EXP 76
61690: PUSH
61691: LD_EXP 76
61695: PPUSH
61696: LD_VAR 0 4
61700: PPUSH
61701: EMPTY
61702: PPUSH
61703: CALL_OW 1
61707: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
61708: LD_ADDR_EXP 77
61712: PUSH
61713: LD_EXP 77
61717: PPUSH
61718: LD_VAR 0 4
61722: PPUSH
61723: EMPTY
61724: PPUSH
61725: CALL_OW 1
61729: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
61730: LD_ADDR_EXP 78
61734: PUSH
61735: LD_EXP 78
61739: PPUSH
61740: LD_VAR 0 4
61744: PPUSH
61745: EMPTY
61746: PPUSH
61747: CALL_OW 1
61751: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
61752: LD_ADDR_EXP 79
61756: PUSH
61757: LD_EXP 79
61761: PPUSH
61762: LD_VAR 0 4
61766: PPUSH
61767: EMPTY
61768: PPUSH
61769: CALL_OW 1
61773: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
61774: LD_ADDR_EXP 80
61778: PUSH
61779: LD_EXP 80
61783: PPUSH
61784: LD_VAR 0 4
61788: PPUSH
61789: EMPTY
61790: PPUSH
61791: CALL_OW 1
61795: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
61796: LD_ADDR_EXP 81
61800: PUSH
61801: LD_EXP 81
61805: PPUSH
61806: LD_VAR 0 4
61810: PPUSH
61811: EMPTY
61812: PPUSH
61813: CALL_OW 1
61817: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
61818: LD_ADDR_EXP 82
61822: PUSH
61823: LD_EXP 82
61827: PPUSH
61828: LD_VAR 0 4
61832: PPUSH
61833: EMPTY
61834: PPUSH
61835: CALL_OW 1
61839: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
61840: LD_ADDR_EXP 83
61844: PUSH
61845: LD_EXP 83
61849: PPUSH
61850: LD_VAR 0 4
61854: PPUSH
61855: EMPTY
61856: PPUSH
61857: CALL_OW 1
61861: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
61862: LD_ADDR_EXP 84
61866: PUSH
61867: LD_EXP 84
61871: PPUSH
61872: LD_VAR 0 4
61876: PPUSH
61877: EMPTY
61878: PPUSH
61879: CALL_OW 1
61883: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
61884: LD_ADDR_EXP 85
61888: PUSH
61889: LD_EXP 85
61893: PPUSH
61894: LD_VAR 0 4
61898: PPUSH
61899: EMPTY
61900: PPUSH
61901: CALL_OW 1
61905: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
61906: LD_ADDR_EXP 86
61910: PUSH
61911: LD_EXP 86
61915: PPUSH
61916: LD_VAR 0 4
61920: PPUSH
61921: EMPTY
61922: PPUSH
61923: CALL_OW 1
61927: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
61928: LD_ADDR_EXP 87
61932: PUSH
61933: LD_EXP 87
61937: PPUSH
61938: LD_VAR 0 4
61942: PPUSH
61943: EMPTY
61944: PPUSH
61945: CALL_OW 1
61949: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
61950: LD_ADDR_EXP 88
61954: PUSH
61955: LD_EXP 88
61959: PPUSH
61960: LD_VAR 0 4
61964: PPUSH
61965: EMPTY
61966: PPUSH
61967: CALL_OW 1
61971: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
61972: LD_ADDR_EXP 90
61976: PUSH
61977: LD_EXP 90
61981: PPUSH
61982: LD_VAR 0 4
61986: PPUSH
61987: EMPTY
61988: PPUSH
61989: CALL_OW 1
61993: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
61994: LD_ADDR_EXP 92
61998: PUSH
61999: LD_EXP 92
62003: PPUSH
62004: LD_VAR 0 4
62008: PPUSH
62009: EMPTY
62010: PPUSH
62011: CALL_OW 1
62015: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
62016: LD_ADDR_EXP 93
62020: PUSH
62021: LD_EXP 93
62025: PPUSH
62026: LD_VAR 0 4
62030: PPUSH
62031: EMPTY
62032: PPUSH
62033: CALL_OW 1
62037: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
62038: LD_ADDR_EXP 94
62042: PUSH
62043: LD_EXP 94
62047: PPUSH
62048: LD_VAR 0 4
62052: PPUSH
62053: EMPTY
62054: PPUSH
62055: CALL_OW 1
62059: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
62060: LD_ADDR_EXP 95
62064: PUSH
62065: LD_EXP 95
62069: PPUSH
62070: LD_VAR 0 4
62074: PPUSH
62075: EMPTY
62076: PPUSH
62077: CALL_OW 1
62081: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
62082: LD_ADDR_EXP 96
62086: PUSH
62087: LD_EXP 96
62091: PPUSH
62092: LD_VAR 0 4
62096: PPUSH
62097: EMPTY
62098: PPUSH
62099: CALL_OW 1
62103: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
62104: LD_ADDR_EXP 97
62108: PUSH
62109: LD_EXP 97
62113: PPUSH
62114: LD_VAR 0 4
62118: PPUSH
62119: EMPTY
62120: PPUSH
62121: CALL_OW 1
62125: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
62126: LD_ADDR_EXP 98
62130: PUSH
62131: LD_EXP 98
62135: PPUSH
62136: LD_VAR 0 4
62140: PPUSH
62141: EMPTY
62142: PPUSH
62143: CALL_OW 1
62147: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
62148: LD_ADDR_EXP 99
62152: PUSH
62153: LD_EXP 99
62157: PPUSH
62158: LD_VAR 0 4
62162: PPUSH
62163: EMPTY
62164: PPUSH
62165: CALL_OW 1
62169: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
62170: LD_ADDR_EXP 100
62174: PUSH
62175: LD_EXP 100
62179: PPUSH
62180: LD_VAR 0 4
62184: PPUSH
62185: EMPTY
62186: PPUSH
62187: CALL_OW 1
62191: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
62192: LD_ADDR_EXP 101
62196: PUSH
62197: LD_EXP 101
62201: PPUSH
62202: LD_VAR 0 4
62206: PPUSH
62207: EMPTY
62208: PPUSH
62209: CALL_OW 1
62213: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
62214: LD_ADDR_EXP 102
62218: PUSH
62219: LD_EXP 102
62223: PPUSH
62224: LD_VAR 0 4
62228: PPUSH
62229: EMPTY
62230: PPUSH
62231: CALL_OW 1
62235: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
62236: LD_ADDR_EXP 103
62240: PUSH
62241: LD_EXP 103
62245: PPUSH
62246: LD_VAR 0 4
62250: PPUSH
62251: EMPTY
62252: PPUSH
62253: CALL_OW 1
62257: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
62258: LD_ADDR_EXP 104
62262: PUSH
62263: LD_EXP 104
62267: PPUSH
62268: LD_VAR 0 4
62272: PPUSH
62273: EMPTY
62274: PPUSH
62275: CALL_OW 1
62279: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
62280: LD_ADDR_EXP 105
62284: PUSH
62285: LD_EXP 105
62289: PPUSH
62290: LD_VAR 0 4
62294: PPUSH
62295: LD_INT 0
62297: PPUSH
62298: CALL_OW 1
62302: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
62303: LD_ADDR_EXP 106
62307: PUSH
62308: LD_EXP 106
62312: PPUSH
62313: LD_VAR 0 4
62317: PPUSH
62318: LD_INT 0
62320: PPUSH
62321: CALL_OW 1
62325: ST_TO_ADDR
// result := base ;
62326: LD_ADDR_VAR 0 3
62330: PUSH
62331: LD_VAR 0 4
62335: ST_TO_ADDR
// end ;
62336: LD_VAR 0 3
62340: RET
// export function MC_Start ( ) ; var i ; begin
62341: LD_INT 0
62343: PPUSH
62344: PPUSH
// for i = 1 to mc_bases do
62345: LD_ADDR_VAR 0 2
62349: PUSH
62350: DOUBLE
62351: LD_INT 1
62353: DEC
62354: ST_TO_ADDR
62355: LD_EXP 63
62359: PUSH
62360: FOR_TO
62361: IFFALSE 63461
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
62363: LD_ADDR_EXP 63
62367: PUSH
62368: LD_EXP 63
62372: PPUSH
62373: LD_VAR 0 2
62377: PPUSH
62378: LD_EXP 63
62382: PUSH
62383: LD_VAR 0 2
62387: ARRAY
62388: PUSH
62389: LD_INT 0
62391: DIFF
62392: PPUSH
62393: CALL_OW 1
62397: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
62398: LD_ADDR_EXP 64
62402: PUSH
62403: LD_EXP 64
62407: PPUSH
62408: LD_VAR 0 2
62412: PPUSH
62413: EMPTY
62414: PPUSH
62415: CALL_OW 1
62419: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
62420: LD_ADDR_EXP 65
62424: PUSH
62425: LD_EXP 65
62429: PPUSH
62430: LD_VAR 0 2
62434: PPUSH
62435: EMPTY
62436: PPUSH
62437: CALL_OW 1
62441: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
62442: LD_ADDR_EXP 66
62446: PUSH
62447: LD_EXP 66
62451: PPUSH
62452: LD_VAR 0 2
62456: PPUSH
62457: EMPTY
62458: PPUSH
62459: CALL_OW 1
62463: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
62464: LD_ADDR_EXP 67
62468: PUSH
62469: LD_EXP 67
62473: PPUSH
62474: LD_VAR 0 2
62478: PPUSH
62479: EMPTY
62480: PUSH
62481: EMPTY
62482: PUSH
62483: EMPTY
62484: LIST
62485: LIST
62486: PPUSH
62487: CALL_OW 1
62491: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
62492: LD_ADDR_EXP 68
62496: PUSH
62497: LD_EXP 68
62501: PPUSH
62502: LD_VAR 0 2
62506: PPUSH
62507: EMPTY
62508: PPUSH
62509: CALL_OW 1
62513: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
62514: LD_ADDR_EXP 95
62518: PUSH
62519: LD_EXP 95
62523: PPUSH
62524: LD_VAR 0 2
62528: PPUSH
62529: EMPTY
62530: PPUSH
62531: CALL_OW 1
62535: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
62536: LD_ADDR_EXP 69
62540: PUSH
62541: LD_EXP 69
62545: PPUSH
62546: LD_VAR 0 2
62550: PPUSH
62551: EMPTY
62552: PPUSH
62553: CALL_OW 1
62557: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
62558: LD_ADDR_EXP 70
62562: PUSH
62563: LD_EXP 70
62567: PPUSH
62568: LD_VAR 0 2
62572: PPUSH
62573: EMPTY
62574: PPUSH
62575: CALL_OW 1
62579: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
62580: LD_ADDR_EXP 71
62584: PUSH
62585: LD_EXP 71
62589: PPUSH
62590: LD_VAR 0 2
62594: PPUSH
62595: LD_EXP 63
62599: PUSH
62600: LD_VAR 0 2
62604: ARRAY
62605: PPUSH
62606: LD_INT 2
62608: PUSH
62609: LD_INT 30
62611: PUSH
62612: LD_INT 32
62614: PUSH
62615: EMPTY
62616: LIST
62617: LIST
62618: PUSH
62619: LD_INT 30
62621: PUSH
62622: LD_INT 33
62624: PUSH
62625: EMPTY
62626: LIST
62627: LIST
62628: PUSH
62629: EMPTY
62630: LIST
62631: LIST
62632: LIST
62633: PPUSH
62634: CALL_OW 72
62638: PPUSH
62639: CALL_OW 1
62643: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
62644: LD_ADDR_EXP 72
62648: PUSH
62649: LD_EXP 72
62653: PPUSH
62654: LD_VAR 0 2
62658: PPUSH
62659: LD_EXP 63
62663: PUSH
62664: LD_VAR 0 2
62668: ARRAY
62669: PPUSH
62670: LD_INT 2
62672: PUSH
62673: LD_INT 30
62675: PUSH
62676: LD_INT 32
62678: PUSH
62679: EMPTY
62680: LIST
62681: LIST
62682: PUSH
62683: LD_INT 30
62685: PUSH
62686: LD_INT 31
62688: PUSH
62689: EMPTY
62690: LIST
62691: LIST
62692: PUSH
62693: EMPTY
62694: LIST
62695: LIST
62696: LIST
62697: PUSH
62698: LD_INT 58
62700: PUSH
62701: EMPTY
62702: LIST
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PPUSH
62708: CALL_OW 72
62712: PPUSH
62713: CALL_OW 1
62717: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
62718: LD_ADDR_EXP 73
62722: PUSH
62723: LD_EXP 73
62727: PPUSH
62728: LD_VAR 0 2
62732: PPUSH
62733: EMPTY
62734: PPUSH
62735: CALL_OW 1
62739: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
62740: LD_ADDR_EXP 77
62744: PUSH
62745: LD_EXP 77
62749: PPUSH
62750: LD_VAR 0 2
62754: PPUSH
62755: EMPTY
62756: PPUSH
62757: CALL_OW 1
62761: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
62762: LD_ADDR_EXP 76
62766: PUSH
62767: LD_EXP 76
62771: PPUSH
62772: LD_VAR 0 2
62776: PPUSH
62777: EMPTY
62778: PPUSH
62779: CALL_OW 1
62783: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
62784: LD_ADDR_EXP 78
62788: PUSH
62789: LD_EXP 78
62793: PPUSH
62794: LD_VAR 0 2
62798: PPUSH
62799: EMPTY
62800: PPUSH
62801: CALL_OW 1
62805: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
62806: LD_ADDR_EXP 79
62810: PUSH
62811: LD_EXP 79
62815: PPUSH
62816: LD_VAR 0 2
62820: PPUSH
62821: EMPTY
62822: PPUSH
62823: CALL_OW 1
62827: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
62828: LD_ADDR_EXP 80
62832: PUSH
62833: LD_EXP 80
62837: PPUSH
62838: LD_VAR 0 2
62842: PPUSH
62843: EMPTY
62844: PPUSH
62845: CALL_OW 1
62849: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
62850: LD_ADDR_EXP 81
62854: PUSH
62855: LD_EXP 81
62859: PPUSH
62860: LD_VAR 0 2
62864: PPUSH
62865: EMPTY
62866: PPUSH
62867: CALL_OW 1
62871: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
62872: LD_ADDR_EXP 82
62876: PUSH
62877: LD_EXP 82
62881: PPUSH
62882: LD_VAR 0 2
62886: PPUSH
62887: EMPTY
62888: PPUSH
62889: CALL_OW 1
62893: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
62894: LD_ADDR_EXP 83
62898: PUSH
62899: LD_EXP 83
62903: PPUSH
62904: LD_VAR 0 2
62908: PPUSH
62909: EMPTY
62910: PPUSH
62911: CALL_OW 1
62915: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
62916: LD_ADDR_EXP 84
62920: PUSH
62921: LD_EXP 84
62925: PPUSH
62926: LD_VAR 0 2
62930: PPUSH
62931: EMPTY
62932: PPUSH
62933: CALL_OW 1
62937: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
62938: LD_ADDR_EXP 85
62942: PUSH
62943: LD_EXP 85
62947: PPUSH
62948: LD_VAR 0 2
62952: PPUSH
62953: EMPTY
62954: PPUSH
62955: CALL_OW 1
62959: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
62960: LD_ADDR_EXP 74
62964: PUSH
62965: LD_EXP 74
62969: PPUSH
62970: LD_VAR 0 2
62974: PPUSH
62975: LD_INT 0
62977: PPUSH
62978: CALL_OW 1
62982: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
62983: LD_ADDR_EXP 87
62987: PUSH
62988: LD_EXP 87
62992: PPUSH
62993: LD_VAR 0 2
62997: PPUSH
62998: LD_INT 0
63000: PPUSH
63001: CALL_OW 1
63005: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
63006: LD_ADDR_EXP 75
63010: PUSH
63011: LD_EXP 75
63015: PPUSH
63016: LD_VAR 0 2
63020: PPUSH
63021: EMPTY
63022: PPUSH
63023: CALL_OW 1
63027: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
63028: LD_ADDR_EXP 86
63032: PUSH
63033: LD_EXP 86
63037: PPUSH
63038: LD_VAR 0 2
63042: PPUSH
63043: LD_INT 0
63045: PPUSH
63046: CALL_OW 1
63050: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
63051: LD_ADDR_EXP 88
63055: PUSH
63056: LD_EXP 88
63060: PPUSH
63061: LD_VAR 0 2
63065: PPUSH
63066: EMPTY
63067: PPUSH
63068: CALL_OW 1
63072: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
63073: LD_ADDR_EXP 91
63077: PUSH
63078: LD_EXP 91
63082: PPUSH
63083: LD_VAR 0 2
63087: PPUSH
63088: LD_INT 0
63090: PPUSH
63091: CALL_OW 1
63095: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
63096: LD_ADDR_EXP 92
63100: PUSH
63101: LD_EXP 92
63105: PPUSH
63106: LD_VAR 0 2
63110: PPUSH
63111: EMPTY
63112: PPUSH
63113: CALL_OW 1
63117: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
63118: LD_ADDR_EXP 93
63122: PUSH
63123: LD_EXP 93
63127: PPUSH
63128: LD_VAR 0 2
63132: PPUSH
63133: EMPTY
63134: PPUSH
63135: CALL_OW 1
63139: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
63140: LD_ADDR_EXP 94
63144: PUSH
63145: LD_EXP 94
63149: PPUSH
63150: LD_VAR 0 2
63154: PPUSH
63155: EMPTY
63156: PPUSH
63157: CALL_OW 1
63161: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
63162: LD_ADDR_EXP 96
63166: PUSH
63167: LD_EXP 96
63171: PPUSH
63172: LD_VAR 0 2
63176: PPUSH
63177: LD_EXP 63
63181: PUSH
63182: LD_VAR 0 2
63186: ARRAY
63187: PPUSH
63188: LD_INT 2
63190: PUSH
63191: LD_INT 30
63193: PUSH
63194: LD_INT 6
63196: PUSH
63197: EMPTY
63198: LIST
63199: LIST
63200: PUSH
63201: LD_INT 30
63203: PUSH
63204: LD_INT 7
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 30
63213: PUSH
63214: LD_INT 8
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: EMPTY
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: PPUSH
63227: CALL_OW 72
63231: PPUSH
63232: CALL_OW 1
63236: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
63237: LD_ADDR_EXP 97
63241: PUSH
63242: LD_EXP 97
63246: PPUSH
63247: LD_VAR 0 2
63251: PPUSH
63252: EMPTY
63253: PPUSH
63254: CALL_OW 1
63258: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
63259: LD_ADDR_EXP 98
63263: PUSH
63264: LD_EXP 98
63268: PPUSH
63269: LD_VAR 0 2
63273: PPUSH
63274: EMPTY
63275: PPUSH
63276: CALL_OW 1
63280: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
63281: LD_ADDR_EXP 99
63285: PUSH
63286: LD_EXP 99
63290: PPUSH
63291: LD_VAR 0 2
63295: PPUSH
63296: EMPTY
63297: PPUSH
63298: CALL_OW 1
63302: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
63303: LD_ADDR_EXP 100
63307: PUSH
63308: LD_EXP 100
63312: PPUSH
63313: LD_VAR 0 2
63317: PPUSH
63318: EMPTY
63319: PPUSH
63320: CALL_OW 1
63324: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
63325: LD_ADDR_EXP 101
63329: PUSH
63330: LD_EXP 101
63334: PPUSH
63335: LD_VAR 0 2
63339: PPUSH
63340: EMPTY
63341: PPUSH
63342: CALL_OW 1
63346: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
63347: LD_ADDR_EXP 102
63351: PUSH
63352: LD_EXP 102
63356: PPUSH
63357: LD_VAR 0 2
63361: PPUSH
63362: EMPTY
63363: PPUSH
63364: CALL_OW 1
63368: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
63369: LD_ADDR_EXP 103
63373: PUSH
63374: LD_EXP 103
63378: PPUSH
63379: LD_VAR 0 2
63383: PPUSH
63384: EMPTY
63385: PPUSH
63386: CALL_OW 1
63390: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
63391: LD_ADDR_EXP 104
63395: PUSH
63396: LD_EXP 104
63400: PPUSH
63401: LD_VAR 0 2
63405: PPUSH
63406: EMPTY
63407: PPUSH
63408: CALL_OW 1
63412: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
63413: LD_ADDR_EXP 105
63417: PUSH
63418: LD_EXP 105
63422: PPUSH
63423: LD_VAR 0 2
63427: PPUSH
63428: LD_INT 0
63430: PPUSH
63431: CALL_OW 1
63435: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
63436: LD_ADDR_EXP 106
63440: PUSH
63441: LD_EXP 106
63445: PPUSH
63446: LD_VAR 0 2
63450: PPUSH
63451: LD_INT 0
63453: PPUSH
63454: CALL_OW 1
63458: ST_TO_ADDR
// end ;
63459: GO 62360
63461: POP
63462: POP
// MC_InitSides ( ) ;
63463: CALL 63749 0 0
// MC_InitResearch ( ) ;
63467: CALL 63488 0 0
// CustomInitMacro ( ) ;
63471: CALL 219 0 0
// skirmish := true ;
63475: LD_ADDR_EXP 61
63479: PUSH
63480: LD_INT 1
63482: ST_TO_ADDR
// end ;
63483: LD_VAR 0 1
63487: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
63488: LD_INT 0
63490: PPUSH
63491: PPUSH
63492: PPUSH
63493: PPUSH
63494: PPUSH
63495: PPUSH
// if not mc_bases then
63496: LD_EXP 63
63500: NOT
63501: IFFALSE 63505
// exit ;
63503: GO 63744
// for i = 1 to 8 do
63505: LD_ADDR_VAR 0 2
63509: PUSH
63510: DOUBLE
63511: LD_INT 1
63513: DEC
63514: ST_TO_ADDR
63515: LD_INT 8
63517: PUSH
63518: FOR_TO
63519: IFFALSE 63545
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
63521: LD_ADDR_EXP 90
63525: PUSH
63526: LD_EXP 90
63530: PPUSH
63531: LD_VAR 0 2
63535: PPUSH
63536: EMPTY
63537: PPUSH
63538: CALL_OW 1
63542: ST_TO_ADDR
63543: GO 63518
63545: POP
63546: POP
// tmp := [ ] ;
63547: LD_ADDR_VAR 0 5
63551: PUSH
63552: EMPTY
63553: ST_TO_ADDR
// for i = 1 to mc_sides do
63554: LD_ADDR_VAR 0 2
63558: PUSH
63559: DOUBLE
63560: LD_INT 1
63562: DEC
63563: ST_TO_ADDR
63564: LD_EXP 89
63568: PUSH
63569: FOR_TO
63570: IFFALSE 63628
// if not mc_sides [ i ] in tmp then
63572: LD_EXP 89
63576: PUSH
63577: LD_VAR 0 2
63581: ARRAY
63582: PUSH
63583: LD_VAR 0 5
63587: IN
63588: NOT
63589: IFFALSE 63626
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
63591: LD_ADDR_VAR 0 5
63595: PUSH
63596: LD_VAR 0 5
63600: PPUSH
63601: LD_VAR 0 5
63605: PUSH
63606: LD_INT 1
63608: PLUS
63609: PPUSH
63610: LD_EXP 89
63614: PUSH
63615: LD_VAR 0 2
63619: ARRAY
63620: PPUSH
63621: CALL_OW 2
63625: ST_TO_ADDR
63626: GO 63569
63628: POP
63629: POP
// if not tmp then
63630: LD_VAR 0 5
63634: NOT
63635: IFFALSE 63639
// exit ;
63637: GO 63744
// for j in tmp do
63639: LD_ADDR_VAR 0 3
63643: PUSH
63644: LD_VAR 0 5
63648: PUSH
63649: FOR_IN
63650: IFFALSE 63742
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
63652: LD_ADDR_VAR 0 6
63656: PUSH
63657: LD_INT 22
63659: PUSH
63660: LD_VAR 0 3
63664: PUSH
63665: EMPTY
63666: LIST
63667: LIST
63668: PPUSH
63669: CALL_OW 69
63673: ST_TO_ADDR
// if not un then
63674: LD_VAR 0 6
63678: NOT
63679: IFFALSE 63683
// continue ;
63681: GO 63649
// nation := GetNation ( un [ 1 ] ) ;
63683: LD_ADDR_VAR 0 4
63687: PUSH
63688: LD_VAR 0 6
63692: PUSH
63693: LD_INT 1
63695: ARRAY
63696: PPUSH
63697: CALL_OW 248
63701: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
63702: LD_ADDR_EXP 90
63706: PUSH
63707: LD_EXP 90
63711: PPUSH
63712: LD_VAR 0 3
63716: PPUSH
63717: LD_VAR 0 3
63721: PPUSH
63722: LD_VAR 0 4
63726: PPUSH
63727: LD_INT 1
63729: PPUSH
63730: CALL 17423 0 3
63734: PPUSH
63735: CALL_OW 1
63739: ST_TO_ADDR
// end ;
63740: GO 63649
63742: POP
63743: POP
// end ;
63744: LD_VAR 0 1
63748: RET
// export function MC_InitSides ( ) ; var i ; begin
63749: LD_INT 0
63751: PPUSH
63752: PPUSH
// if not mc_bases then
63753: LD_EXP 63
63757: NOT
63758: IFFALSE 63762
// exit ;
63760: GO 63836
// for i = 1 to mc_bases do
63762: LD_ADDR_VAR 0 2
63766: PUSH
63767: DOUBLE
63768: LD_INT 1
63770: DEC
63771: ST_TO_ADDR
63772: LD_EXP 63
63776: PUSH
63777: FOR_TO
63778: IFFALSE 63834
// if mc_bases [ i ] then
63780: LD_EXP 63
63784: PUSH
63785: LD_VAR 0 2
63789: ARRAY
63790: IFFALSE 63832
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
63792: LD_ADDR_EXP 89
63796: PUSH
63797: LD_EXP 89
63801: PPUSH
63802: LD_VAR 0 2
63806: PPUSH
63807: LD_EXP 63
63811: PUSH
63812: LD_VAR 0 2
63816: ARRAY
63817: PUSH
63818: LD_INT 1
63820: ARRAY
63821: PPUSH
63822: CALL_OW 255
63826: PPUSH
63827: CALL_OW 1
63831: ST_TO_ADDR
63832: GO 63777
63834: POP
63835: POP
// end ;
63836: LD_VAR 0 1
63840: RET
// every 0 0$03 trigger skirmish do
63841: LD_EXP 61
63845: IFFALSE 63999
63847: GO 63849
63849: DISABLE
// begin enable ;
63850: ENABLE
// MC_CheckBuildings ( ) ;
63851: CALL 68511 0 0
// MC_CheckPeopleLife ( ) ;
63855: CALL 68672 0 0
// RaiseSailEvent ( 100 ) ;
63859: LD_INT 100
63861: PPUSH
63862: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
63866: LD_INT 103
63868: PPUSH
63869: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
63873: LD_INT 104
63875: PPUSH
63876: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
63880: LD_INT 105
63882: PPUSH
63883: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
63887: LD_INT 106
63889: PPUSH
63890: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
63894: LD_INT 107
63896: PPUSH
63897: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
63901: LD_INT 108
63903: PPUSH
63904: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
63908: LD_INT 109
63910: PPUSH
63911: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
63915: LD_INT 110
63917: PPUSH
63918: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
63922: LD_INT 111
63924: PPUSH
63925: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
63929: LD_INT 112
63931: PPUSH
63932: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
63936: LD_INT 113
63938: PPUSH
63939: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
63943: LD_INT 120
63945: PPUSH
63946: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
63950: LD_INT 121
63952: PPUSH
63953: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
63957: LD_INT 122
63959: PPUSH
63960: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
63964: LD_INT 123
63966: PPUSH
63967: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
63971: LD_INT 124
63973: PPUSH
63974: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
63978: LD_INT 125
63980: PPUSH
63981: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
63985: LD_INT 126
63987: PPUSH
63988: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
63992: LD_INT 200
63994: PPUSH
63995: CALL_OW 427
// end ;
63999: END
// on SailEvent ( event ) do begin if event < 100 then
64000: LD_VAR 0 1
64004: PUSH
64005: LD_INT 100
64007: LESS
64008: IFFALSE 64019
// CustomEvent ( event ) ;
64010: LD_VAR 0 1
64014: PPUSH
64015: CALL 15924 0 1
// if event = 100 then
64019: LD_VAR 0 1
64023: PUSH
64024: LD_INT 100
64026: EQUAL
64027: IFFALSE 64033
// MC_ClassManager ( ) ;
64029: CALL 64425 0 0
// if event = 101 then
64033: LD_VAR 0 1
64037: PUSH
64038: LD_INT 101
64040: EQUAL
64041: IFFALSE 64047
// MC_RepairBuildings ( ) ;
64043: CALL 69257 0 0
// if event = 102 then
64047: LD_VAR 0 1
64051: PUSH
64052: LD_INT 102
64054: EQUAL
64055: IFFALSE 64061
// MC_Heal ( ) ;
64057: CALL 70192 0 0
// if event = 103 then
64061: LD_VAR 0 1
64065: PUSH
64066: LD_INT 103
64068: EQUAL
64069: IFFALSE 64075
// MC_Build ( ) ;
64071: CALL 70614 0 0
// if event = 104 then
64075: LD_VAR 0 1
64079: PUSH
64080: LD_INT 104
64082: EQUAL
64083: IFFALSE 64089
// MC_TurretWeapon ( ) ;
64085: CALL 72248 0 0
// if event = 105 then
64089: LD_VAR 0 1
64093: PUSH
64094: LD_INT 105
64096: EQUAL
64097: IFFALSE 64103
// MC_BuildUpgrade ( ) ;
64099: CALL 71799 0 0
// if event = 106 then
64103: LD_VAR 0 1
64107: PUSH
64108: LD_INT 106
64110: EQUAL
64111: IFFALSE 64117
// MC_PlantMines ( ) ;
64113: CALL 72678 0 0
// if event = 107 then
64117: LD_VAR 0 1
64121: PUSH
64122: LD_INT 107
64124: EQUAL
64125: IFFALSE 64131
// MC_CollectCrates ( ) ;
64127: CALL 73476 0 0
// if event = 108 then
64131: LD_VAR 0 1
64135: PUSH
64136: LD_INT 108
64138: EQUAL
64139: IFFALSE 64145
// MC_LinkRemoteControl ( ) ;
64141: CALL 75326 0 0
// if event = 109 then
64145: LD_VAR 0 1
64149: PUSH
64150: LD_INT 109
64152: EQUAL
64153: IFFALSE 64159
// MC_ProduceVehicle ( ) ;
64155: CALL 75507 0 0
// if event = 110 then
64159: LD_VAR 0 1
64163: PUSH
64164: LD_INT 110
64166: EQUAL
64167: IFFALSE 64173
// MC_SendAttack ( ) ;
64169: CALL 75973 0 0
// if event = 111 then
64173: LD_VAR 0 1
64177: PUSH
64178: LD_INT 111
64180: EQUAL
64181: IFFALSE 64187
// MC_Defend ( ) ;
64183: CALL 76081 0 0
// if event = 112 then
64187: LD_VAR 0 1
64191: PUSH
64192: LD_INT 112
64194: EQUAL
64195: IFFALSE 64201
// MC_Research ( ) ;
64197: CALL 76961 0 0
// if event = 113 then
64201: LD_VAR 0 1
64205: PUSH
64206: LD_INT 113
64208: EQUAL
64209: IFFALSE 64215
// MC_MinesTrigger ( ) ;
64211: CALL 78075 0 0
// if event = 120 then
64215: LD_VAR 0 1
64219: PUSH
64220: LD_INT 120
64222: EQUAL
64223: IFFALSE 64229
// MC_RepairVehicle ( ) ;
64225: CALL 78174 0 0
// if event = 121 then
64229: LD_VAR 0 1
64233: PUSH
64234: LD_INT 121
64236: EQUAL
64237: IFFALSE 64243
// MC_TameApe ( ) ;
64239: CALL 78943 0 0
// if event = 122 then
64243: LD_VAR 0 1
64247: PUSH
64248: LD_INT 122
64250: EQUAL
64251: IFFALSE 64257
// MC_ChangeApeClass ( ) ;
64253: CALL 79772 0 0
// if event = 123 then
64257: LD_VAR 0 1
64261: PUSH
64262: LD_INT 123
64264: EQUAL
64265: IFFALSE 64271
// MC_Bazooka ( ) ;
64267: CALL 80422 0 0
// if event = 124 then
64271: LD_VAR 0 1
64275: PUSH
64276: LD_INT 124
64278: EQUAL
64279: IFFALSE 64285
// MC_TeleportExit ( ) ;
64281: CALL 80620 0 0
// if event = 125 then
64285: LD_VAR 0 1
64289: PUSH
64290: LD_INT 125
64292: EQUAL
64293: IFFALSE 64299
// MC_Deposits ( ) ;
64295: CALL 81267 0 0
// if event = 126 then
64299: LD_VAR 0 1
64303: PUSH
64304: LD_INT 126
64306: EQUAL
64307: IFFALSE 64313
// MC_RemoteDriver ( ) ;
64309: CALL 81892 0 0
// if event = 200 then
64313: LD_VAR 0 1
64317: PUSH
64318: LD_INT 200
64320: EQUAL
64321: IFFALSE 64327
// MC_Idle ( ) ;
64323: CALL 83799 0 0
// end ;
64327: PPOPN 1
64329: END
// export function MC_Reset ( base , tag ) ; var i ; begin
64330: LD_INT 0
64332: PPUSH
64333: PPUSH
// if not mc_bases [ base ] or not tag then
64334: LD_EXP 63
64338: PUSH
64339: LD_VAR 0 1
64343: ARRAY
64344: NOT
64345: PUSH
64346: LD_VAR 0 2
64350: NOT
64351: OR
64352: IFFALSE 64356
// exit ;
64354: GO 64420
// for i in mc_bases [ base ] union mc_ape [ base ] do
64356: LD_ADDR_VAR 0 4
64360: PUSH
64361: LD_EXP 63
64365: PUSH
64366: LD_VAR 0 1
64370: ARRAY
64371: PUSH
64372: LD_EXP 92
64376: PUSH
64377: LD_VAR 0 1
64381: ARRAY
64382: UNION
64383: PUSH
64384: FOR_IN
64385: IFFALSE 64418
// if GetTag ( i ) = tag then
64387: LD_VAR 0 4
64391: PPUSH
64392: CALL_OW 110
64396: PUSH
64397: LD_VAR 0 2
64401: EQUAL
64402: IFFALSE 64416
// SetTag ( i , 0 ) ;
64404: LD_VAR 0 4
64408: PPUSH
64409: LD_INT 0
64411: PPUSH
64412: CALL_OW 109
64416: GO 64384
64418: POP
64419: POP
// end ;
64420: LD_VAR 0 3
64424: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
64425: LD_INT 0
64427: PPUSH
64428: PPUSH
64429: PPUSH
64430: PPUSH
64431: PPUSH
64432: PPUSH
64433: PPUSH
64434: PPUSH
// if not mc_bases then
64435: LD_EXP 63
64439: NOT
64440: IFFALSE 64444
// exit ;
64442: GO 64893
// for i = 1 to mc_bases do
64444: LD_ADDR_VAR 0 2
64448: PUSH
64449: DOUBLE
64450: LD_INT 1
64452: DEC
64453: ST_TO_ADDR
64454: LD_EXP 63
64458: PUSH
64459: FOR_TO
64460: IFFALSE 64891
// begin tmp := MC_ClassCheckReq ( i ) ;
64462: LD_ADDR_VAR 0 4
64466: PUSH
64467: LD_VAR 0 2
64471: PPUSH
64472: CALL 64898 0 1
64476: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
64477: LD_ADDR_EXP 104
64481: PUSH
64482: LD_EXP 104
64486: PPUSH
64487: LD_VAR 0 2
64491: PPUSH
64492: LD_VAR 0 4
64496: PPUSH
64497: CALL_OW 1
64501: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
64502: LD_ADDR_VAR 0 6
64506: PUSH
64507: LD_EXP 63
64511: PUSH
64512: LD_VAR 0 2
64516: ARRAY
64517: PPUSH
64518: LD_INT 2
64520: PUSH
64521: LD_INT 30
64523: PUSH
64524: LD_INT 4
64526: PUSH
64527: EMPTY
64528: LIST
64529: LIST
64530: PUSH
64531: LD_INT 30
64533: PUSH
64534: LD_INT 5
64536: PUSH
64537: EMPTY
64538: LIST
64539: LIST
64540: PUSH
64541: EMPTY
64542: LIST
64543: LIST
64544: LIST
64545: PPUSH
64546: CALL_OW 72
64550: PUSH
64551: LD_EXP 63
64555: PUSH
64556: LD_VAR 0 2
64560: ARRAY
64561: PPUSH
64562: LD_INT 2
64564: PUSH
64565: LD_INT 30
64567: PUSH
64568: LD_INT 0
64570: PUSH
64571: EMPTY
64572: LIST
64573: LIST
64574: PUSH
64575: LD_INT 30
64577: PUSH
64578: LD_INT 1
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: LIST
64589: PPUSH
64590: CALL_OW 72
64594: PUSH
64595: LD_EXP 63
64599: PUSH
64600: LD_VAR 0 2
64604: ARRAY
64605: PPUSH
64606: LD_INT 30
64608: PUSH
64609: LD_INT 3
64611: PUSH
64612: EMPTY
64613: LIST
64614: LIST
64615: PPUSH
64616: CALL_OW 72
64620: PUSH
64621: LD_EXP 63
64625: PUSH
64626: LD_VAR 0 2
64630: ARRAY
64631: PPUSH
64632: LD_INT 2
64634: PUSH
64635: LD_INT 30
64637: PUSH
64638: LD_INT 6
64640: PUSH
64641: EMPTY
64642: LIST
64643: LIST
64644: PUSH
64645: LD_INT 30
64647: PUSH
64648: LD_INT 7
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PUSH
64655: LD_INT 30
64657: PUSH
64658: LD_INT 8
64660: PUSH
64661: EMPTY
64662: LIST
64663: LIST
64664: PUSH
64665: EMPTY
64666: LIST
64667: LIST
64668: LIST
64669: LIST
64670: PPUSH
64671: CALL_OW 72
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: ST_TO_ADDR
// for j := 1 to 4 do
64682: LD_ADDR_VAR 0 3
64686: PUSH
64687: DOUBLE
64688: LD_INT 1
64690: DEC
64691: ST_TO_ADDR
64692: LD_INT 4
64694: PUSH
64695: FOR_TO
64696: IFFALSE 64887
// begin if not tmp [ j ] then
64698: LD_VAR 0 4
64702: PUSH
64703: LD_VAR 0 3
64707: ARRAY
64708: NOT
64709: IFFALSE 64713
// continue ;
64711: GO 64695
// for p in tmp [ j ] do
64713: LD_ADDR_VAR 0 5
64717: PUSH
64718: LD_VAR 0 4
64722: PUSH
64723: LD_VAR 0 3
64727: ARRAY
64728: PUSH
64729: FOR_IN
64730: IFFALSE 64883
// begin if not b [ j ] then
64732: LD_VAR 0 6
64736: PUSH
64737: LD_VAR 0 3
64741: ARRAY
64742: NOT
64743: IFFALSE 64747
// break ;
64745: GO 64883
// e := 0 ;
64747: LD_ADDR_VAR 0 7
64751: PUSH
64752: LD_INT 0
64754: ST_TO_ADDR
// for k in b [ j ] do
64755: LD_ADDR_VAR 0 8
64759: PUSH
64760: LD_VAR 0 6
64764: PUSH
64765: LD_VAR 0 3
64769: ARRAY
64770: PUSH
64771: FOR_IN
64772: IFFALSE 64799
// if IsNotFull ( k ) then
64774: LD_VAR 0 8
64778: PPUSH
64779: CALL 19544 0 1
64783: IFFALSE 64797
// begin e := k ;
64785: LD_ADDR_VAR 0 7
64789: PUSH
64790: LD_VAR 0 8
64794: ST_TO_ADDR
// break ;
64795: GO 64799
// end ;
64797: GO 64771
64799: POP
64800: POP
// if e and not UnitGoingToBuilding ( p , e ) then
64801: LD_VAR 0 7
64805: PUSH
64806: LD_VAR 0 5
64810: PPUSH
64811: LD_VAR 0 7
64815: PPUSH
64816: CALL 53703 0 2
64820: NOT
64821: AND
64822: IFFALSE 64881
// begin if IsInUnit ( p ) then
64824: LD_VAR 0 5
64828: PPUSH
64829: CALL_OW 310
64833: IFFALSE 64844
// ComExitBuilding ( p ) ;
64835: LD_VAR 0 5
64839: PPUSH
64840: CALL_OW 122
// ComEnterUnit ( p , e ) ;
64844: LD_VAR 0 5
64848: PPUSH
64849: LD_VAR 0 7
64853: PPUSH
64854: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
64858: LD_VAR 0 5
64862: PPUSH
64863: LD_VAR 0 3
64867: PPUSH
64868: CALL_OW 183
// AddComExitBuilding ( p ) ;
64872: LD_VAR 0 5
64876: PPUSH
64877: CALL_OW 182
// end ; end ;
64881: GO 64729
64883: POP
64884: POP
// end ;
64885: GO 64695
64887: POP
64888: POP
// end ;
64889: GO 64459
64891: POP
64892: POP
// end ;
64893: LD_VAR 0 1
64897: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
64898: LD_INT 0
64900: PPUSH
64901: PPUSH
64902: PPUSH
64903: PPUSH
64904: PPUSH
64905: PPUSH
64906: PPUSH
64907: PPUSH
64908: PPUSH
64909: PPUSH
64910: PPUSH
64911: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
64912: LD_ADDR_VAR 0 2
64916: PUSH
64917: LD_INT 0
64919: PUSH
64920: LD_INT 0
64922: PUSH
64923: LD_INT 0
64925: PUSH
64926: LD_INT 0
64928: PUSH
64929: EMPTY
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
64935: LD_VAR 0 1
64939: NOT
64940: PUSH
64941: LD_EXP 63
64945: PUSH
64946: LD_VAR 0 1
64950: ARRAY
64951: NOT
64952: OR
64953: PUSH
64954: LD_EXP 63
64958: PUSH
64959: LD_VAR 0 1
64963: ARRAY
64964: PPUSH
64965: LD_INT 2
64967: PUSH
64968: LD_INT 30
64970: PUSH
64971: LD_INT 0
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: PUSH
64978: LD_INT 30
64980: PUSH
64981: LD_INT 1
64983: PUSH
64984: EMPTY
64985: LIST
64986: LIST
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: LIST
64992: PPUSH
64993: CALL_OW 72
64997: NOT
64998: OR
64999: IFFALSE 65003
// exit ;
65001: GO 68506
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65003: LD_ADDR_VAR 0 4
65007: PUSH
65008: LD_EXP 63
65012: PUSH
65013: LD_VAR 0 1
65017: ARRAY
65018: PPUSH
65019: LD_INT 2
65021: PUSH
65022: LD_INT 25
65024: PUSH
65025: LD_INT 1
65027: PUSH
65028: EMPTY
65029: LIST
65030: LIST
65031: PUSH
65032: LD_INT 25
65034: PUSH
65035: LD_INT 2
65037: PUSH
65038: EMPTY
65039: LIST
65040: LIST
65041: PUSH
65042: LD_INT 25
65044: PUSH
65045: LD_INT 3
65047: PUSH
65048: EMPTY
65049: LIST
65050: LIST
65051: PUSH
65052: LD_INT 25
65054: PUSH
65055: LD_INT 4
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 25
65064: PUSH
65065: LD_INT 5
65067: PUSH
65068: EMPTY
65069: LIST
65070: LIST
65071: PUSH
65072: LD_INT 25
65074: PUSH
65075: LD_INT 8
65077: PUSH
65078: EMPTY
65079: LIST
65080: LIST
65081: PUSH
65082: LD_INT 25
65084: PUSH
65085: LD_INT 9
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: EMPTY
65093: LIST
65094: LIST
65095: LIST
65096: LIST
65097: LIST
65098: LIST
65099: LIST
65100: LIST
65101: PPUSH
65102: CALL_OW 72
65106: ST_TO_ADDR
// if not tmp then
65107: LD_VAR 0 4
65111: NOT
65112: IFFALSE 65116
// exit ;
65114: GO 68506
// for i in tmp do
65116: LD_ADDR_VAR 0 3
65120: PUSH
65121: LD_VAR 0 4
65125: PUSH
65126: FOR_IN
65127: IFFALSE 65158
// if GetTag ( i ) then
65129: LD_VAR 0 3
65133: PPUSH
65134: CALL_OW 110
65138: IFFALSE 65156
// tmp := tmp diff i ;
65140: LD_ADDR_VAR 0 4
65144: PUSH
65145: LD_VAR 0 4
65149: PUSH
65150: LD_VAR 0 3
65154: DIFF
65155: ST_TO_ADDR
65156: GO 65126
65158: POP
65159: POP
// if not tmp then
65160: LD_VAR 0 4
65164: NOT
65165: IFFALSE 65169
// exit ;
65167: GO 68506
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
65169: LD_ADDR_VAR 0 5
65173: PUSH
65174: LD_EXP 63
65178: PUSH
65179: LD_VAR 0 1
65183: ARRAY
65184: PPUSH
65185: LD_INT 2
65187: PUSH
65188: LD_INT 25
65190: PUSH
65191: LD_INT 1
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 25
65200: PUSH
65201: LD_INT 5
65203: PUSH
65204: EMPTY
65205: LIST
65206: LIST
65207: PUSH
65208: LD_INT 25
65210: PUSH
65211: LD_INT 8
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 25
65220: PUSH
65221: LD_INT 9
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: EMPTY
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: PPUSH
65235: CALL_OW 72
65239: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
65240: LD_ADDR_VAR 0 6
65244: PUSH
65245: LD_EXP 63
65249: PUSH
65250: LD_VAR 0 1
65254: ARRAY
65255: PPUSH
65256: LD_INT 25
65258: PUSH
65259: LD_INT 2
65261: PUSH
65262: EMPTY
65263: LIST
65264: LIST
65265: PPUSH
65266: CALL_OW 72
65270: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
65271: LD_ADDR_VAR 0 7
65275: PUSH
65276: LD_EXP 63
65280: PUSH
65281: LD_VAR 0 1
65285: ARRAY
65286: PPUSH
65287: LD_INT 25
65289: PUSH
65290: LD_INT 3
65292: PUSH
65293: EMPTY
65294: LIST
65295: LIST
65296: PPUSH
65297: CALL_OW 72
65301: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
65302: LD_ADDR_VAR 0 8
65306: PUSH
65307: LD_EXP 63
65311: PUSH
65312: LD_VAR 0 1
65316: ARRAY
65317: PPUSH
65318: LD_INT 25
65320: PUSH
65321: LD_INT 4
65323: PUSH
65324: EMPTY
65325: LIST
65326: LIST
65327: PUSH
65328: LD_INT 24
65330: PUSH
65331: LD_INT 251
65333: PUSH
65334: EMPTY
65335: LIST
65336: LIST
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PPUSH
65342: CALL_OW 72
65346: ST_TO_ADDR
// if mc_is_defending [ base ] then
65347: LD_EXP 106
65351: PUSH
65352: LD_VAR 0 1
65356: ARRAY
65357: IFFALSE 65818
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
65359: LD_ADDR_EXP 105
65363: PUSH
65364: LD_EXP 105
65368: PPUSH
65369: LD_VAR 0 1
65373: PPUSH
65374: LD_INT 4
65376: PPUSH
65377: CALL_OW 1
65381: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
65382: LD_ADDR_VAR 0 12
65386: PUSH
65387: LD_EXP 63
65391: PUSH
65392: LD_VAR 0 1
65396: ARRAY
65397: PPUSH
65398: LD_INT 2
65400: PUSH
65401: LD_INT 30
65403: PUSH
65404: LD_INT 4
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PUSH
65411: LD_INT 30
65413: PUSH
65414: LD_INT 5
65416: PUSH
65417: EMPTY
65418: LIST
65419: LIST
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: LIST
65425: PPUSH
65426: CALL_OW 72
65430: ST_TO_ADDR
// if not b then
65431: LD_VAR 0 12
65435: NOT
65436: IFFALSE 65440
// exit ;
65438: GO 68506
// p := [ ] ;
65440: LD_ADDR_VAR 0 11
65444: PUSH
65445: EMPTY
65446: ST_TO_ADDR
// if sci >= 2 then
65447: LD_VAR 0 8
65451: PUSH
65452: LD_INT 2
65454: GREATEREQUAL
65455: IFFALSE 65486
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
65457: LD_ADDR_VAR 0 8
65461: PUSH
65462: LD_VAR 0 8
65466: PUSH
65467: LD_INT 1
65469: ARRAY
65470: PUSH
65471: LD_VAR 0 8
65475: PUSH
65476: LD_INT 2
65478: ARRAY
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: ST_TO_ADDR
65484: GO 65547
// if sci = 1 then
65486: LD_VAR 0 8
65490: PUSH
65491: LD_INT 1
65493: EQUAL
65494: IFFALSE 65515
// sci := [ sci [ 1 ] ] else
65496: LD_ADDR_VAR 0 8
65500: PUSH
65501: LD_VAR 0 8
65505: PUSH
65506: LD_INT 1
65508: ARRAY
65509: PUSH
65510: EMPTY
65511: LIST
65512: ST_TO_ADDR
65513: GO 65547
// if sci = 0 then
65515: LD_VAR 0 8
65519: PUSH
65520: LD_INT 0
65522: EQUAL
65523: IFFALSE 65547
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
65525: LD_ADDR_VAR 0 11
65529: PUSH
65530: LD_VAR 0 4
65534: PPUSH
65535: LD_INT 4
65537: PPUSH
65538: CALL 53575 0 2
65542: PUSH
65543: LD_INT 1
65545: ARRAY
65546: ST_TO_ADDR
// if eng > 4 then
65547: LD_VAR 0 6
65551: PUSH
65552: LD_INT 4
65554: GREATER
65555: IFFALSE 65601
// for i = eng downto 4 do
65557: LD_ADDR_VAR 0 3
65561: PUSH
65562: DOUBLE
65563: LD_VAR 0 6
65567: INC
65568: ST_TO_ADDR
65569: LD_INT 4
65571: PUSH
65572: FOR_DOWNTO
65573: IFFALSE 65599
// eng := eng diff eng [ i ] ;
65575: LD_ADDR_VAR 0 6
65579: PUSH
65580: LD_VAR 0 6
65584: PUSH
65585: LD_VAR 0 6
65589: PUSH
65590: LD_VAR 0 3
65594: ARRAY
65595: DIFF
65596: ST_TO_ADDR
65597: GO 65572
65599: POP
65600: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
65601: LD_ADDR_VAR 0 4
65605: PUSH
65606: LD_VAR 0 4
65610: PUSH
65611: LD_VAR 0 5
65615: PUSH
65616: LD_VAR 0 6
65620: UNION
65621: PUSH
65622: LD_VAR 0 7
65626: UNION
65627: PUSH
65628: LD_VAR 0 8
65632: UNION
65633: DIFF
65634: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
65635: LD_ADDR_VAR 0 13
65639: PUSH
65640: LD_EXP 63
65644: PUSH
65645: LD_VAR 0 1
65649: ARRAY
65650: PPUSH
65651: LD_INT 2
65653: PUSH
65654: LD_INT 30
65656: PUSH
65657: LD_INT 32
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 30
65666: PUSH
65667: LD_INT 31
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: LIST
65678: PPUSH
65679: CALL_OW 72
65683: PUSH
65684: LD_EXP 63
65688: PUSH
65689: LD_VAR 0 1
65693: ARRAY
65694: PPUSH
65695: LD_INT 2
65697: PUSH
65698: LD_INT 30
65700: PUSH
65701: LD_INT 4
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 30
65710: PUSH
65711: LD_INT 5
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PUSH
65718: EMPTY
65719: LIST
65720: LIST
65721: LIST
65722: PPUSH
65723: CALL_OW 72
65727: PUSH
65728: LD_INT 6
65730: MUL
65731: PLUS
65732: ST_TO_ADDR
// if bcount < tmp then
65733: LD_VAR 0 13
65737: PUSH
65738: LD_VAR 0 4
65742: LESS
65743: IFFALSE 65789
// for i = tmp downto bcount do
65745: LD_ADDR_VAR 0 3
65749: PUSH
65750: DOUBLE
65751: LD_VAR 0 4
65755: INC
65756: ST_TO_ADDR
65757: LD_VAR 0 13
65761: PUSH
65762: FOR_DOWNTO
65763: IFFALSE 65787
// tmp := Delete ( tmp , tmp ) ;
65765: LD_ADDR_VAR 0 4
65769: PUSH
65770: LD_VAR 0 4
65774: PPUSH
65775: LD_VAR 0 4
65779: PPUSH
65780: CALL_OW 3
65784: ST_TO_ADDR
65785: GO 65762
65787: POP
65788: POP
// result := [ tmp , 0 , 0 , p ] ;
65789: LD_ADDR_VAR 0 2
65793: PUSH
65794: LD_VAR 0 4
65798: PUSH
65799: LD_INT 0
65801: PUSH
65802: LD_INT 0
65804: PUSH
65805: LD_VAR 0 11
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: ST_TO_ADDR
// exit ;
65816: GO 68506
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65818: LD_EXP 63
65822: PUSH
65823: LD_VAR 0 1
65827: ARRAY
65828: PPUSH
65829: LD_INT 2
65831: PUSH
65832: LD_INT 30
65834: PUSH
65835: LD_INT 6
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PUSH
65842: LD_INT 30
65844: PUSH
65845: LD_INT 7
65847: PUSH
65848: EMPTY
65849: LIST
65850: LIST
65851: PUSH
65852: LD_INT 30
65854: PUSH
65855: LD_INT 8
65857: PUSH
65858: EMPTY
65859: LIST
65860: LIST
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: PPUSH
65868: CALL_OW 72
65872: NOT
65873: PUSH
65874: LD_EXP 63
65878: PUSH
65879: LD_VAR 0 1
65883: ARRAY
65884: PPUSH
65885: LD_INT 30
65887: PUSH
65888: LD_INT 3
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PPUSH
65895: CALL_OW 72
65899: NOT
65900: AND
65901: IFFALSE 65973
// begin if eng = tmp then
65903: LD_VAR 0 6
65907: PUSH
65908: LD_VAR 0 4
65912: EQUAL
65913: IFFALSE 65917
// exit ;
65915: GO 68506
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
65917: LD_ADDR_EXP 105
65921: PUSH
65922: LD_EXP 105
65926: PPUSH
65927: LD_VAR 0 1
65931: PPUSH
65932: LD_INT 1
65934: PPUSH
65935: CALL_OW 1
65939: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
65940: LD_ADDR_VAR 0 2
65944: PUSH
65945: LD_INT 0
65947: PUSH
65948: LD_VAR 0 4
65952: PUSH
65953: LD_VAR 0 6
65957: DIFF
65958: PUSH
65959: LD_INT 0
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: ST_TO_ADDR
// exit ;
65971: GO 68506
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
65973: LD_EXP 90
65977: PUSH
65978: LD_EXP 89
65982: PUSH
65983: LD_VAR 0 1
65987: ARRAY
65988: ARRAY
65989: PUSH
65990: LD_EXP 63
65994: PUSH
65995: LD_VAR 0 1
65999: ARRAY
66000: PPUSH
66001: LD_INT 2
66003: PUSH
66004: LD_INT 30
66006: PUSH
66007: LD_INT 6
66009: PUSH
66010: EMPTY
66011: LIST
66012: LIST
66013: PUSH
66014: LD_INT 30
66016: PUSH
66017: LD_INT 7
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 30
66026: PUSH
66027: LD_INT 8
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: LIST
66038: LIST
66039: PPUSH
66040: CALL_OW 72
66044: AND
66045: PUSH
66046: LD_EXP 63
66050: PUSH
66051: LD_VAR 0 1
66055: ARRAY
66056: PPUSH
66057: LD_INT 30
66059: PUSH
66060: LD_INT 3
66062: PUSH
66063: EMPTY
66064: LIST
66065: LIST
66066: PPUSH
66067: CALL_OW 72
66071: NOT
66072: AND
66073: IFFALSE 66287
// begin if sci >= 6 then
66075: LD_VAR 0 8
66079: PUSH
66080: LD_INT 6
66082: GREATEREQUAL
66083: IFFALSE 66087
// exit ;
66085: GO 68506
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
66087: LD_ADDR_EXP 105
66091: PUSH
66092: LD_EXP 105
66096: PPUSH
66097: LD_VAR 0 1
66101: PPUSH
66102: LD_INT 2
66104: PPUSH
66105: CALL_OW 1
66109: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
66110: LD_ADDR_VAR 0 9
66114: PUSH
66115: LD_VAR 0 4
66119: PUSH
66120: LD_VAR 0 8
66124: DIFF
66125: PPUSH
66126: LD_INT 4
66128: PPUSH
66129: CALL 53575 0 2
66133: ST_TO_ADDR
// p := [ ] ;
66134: LD_ADDR_VAR 0 11
66138: PUSH
66139: EMPTY
66140: ST_TO_ADDR
// if sci < 6 and sort > 6 then
66141: LD_VAR 0 8
66145: PUSH
66146: LD_INT 6
66148: LESS
66149: PUSH
66150: LD_VAR 0 9
66154: PUSH
66155: LD_INT 6
66157: GREATER
66158: AND
66159: IFFALSE 66240
// begin for i = 1 to 6 - sci do
66161: LD_ADDR_VAR 0 3
66165: PUSH
66166: DOUBLE
66167: LD_INT 1
66169: DEC
66170: ST_TO_ADDR
66171: LD_INT 6
66173: PUSH
66174: LD_VAR 0 8
66178: MINUS
66179: PUSH
66180: FOR_TO
66181: IFFALSE 66236
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
66183: LD_ADDR_VAR 0 11
66187: PUSH
66188: LD_VAR 0 11
66192: PPUSH
66193: LD_VAR 0 11
66197: PUSH
66198: LD_INT 1
66200: PLUS
66201: PPUSH
66202: LD_VAR 0 9
66206: PUSH
66207: LD_INT 1
66209: ARRAY
66210: PPUSH
66211: CALL_OW 2
66215: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
66216: LD_ADDR_VAR 0 9
66220: PUSH
66221: LD_VAR 0 9
66225: PPUSH
66226: LD_INT 1
66228: PPUSH
66229: CALL_OW 3
66233: ST_TO_ADDR
// end ;
66234: GO 66180
66236: POP
66237: POP
// end else
66238: GO 66260
// if sort then
66240: LD_VAR 0 9
66244: IFFALSE 66260
// p := sort [ 1 ] ;
66246: LD_ADDR_VAR 0 11
66250: PUSH
66251: LD_VAR 0 9
66255: PUSH
66256: LD_INT 1
66258: ARRAY
66259: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
66260: LD_ADDR_VAR 0 2
66264: PUSH
66265: LD_INT 0
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: LD_INT 0
66273: PUSH
66274: LD_VAR 0 11
66278: PUSH
66279: EMPTY
66280: LIST
66281: LIST
66282: LIST
66283: LIST
66284: ST_TO_ADDR
// exit ;
66285: GO 68506
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
66287: LD_EXP 90
66291: PUSH
66292: LD_EXP 89
66296: PUSH
66297: LD_VAR 0 1
66301: ARRAY
66302: ARRAY
66303: PUSH
66304: LD_EXP 63
66308: PUSH
66309: LD_VAR 0 1
66313: ARRAY
66314: PPUSH
66315: LD_INT 2
66317: PUSH
66318: LD_INT 30
66320: PUSH
66321: LD_INT 6
66323: PUSH
66324: EMPTY
66325: LIST
66326: LIST
66327: PUSH
66328: LD_INT 30
66330: PUSH
66331: LD_INT 7
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 30
66340: PUSH
66341: LD_INT 8
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: EMPTY
66349: LIST
66350: LIST
66351: LIST
66352: LIST
66353: PPUSH
66354: CALL_OW 72
66358: AND
66359: PUSH
66360: LD_EXP 63
66364: PUSH
66365: LD_VAR 0 1
66369: ARRAY
66370: PPUSH
66371: LD_INT 30
66373: PUSH
66374: LD_INT 3
66376: PUSH
66377: EMPTY
66378: LIST
66379: LIST
66380: PPUSH
66381: CALL_OW 72
66385: AND
66386: IFFALSE 67120
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
66388: LD_ADDR_EXP 105
66392: PUSH
66393: LD_EXP 105
66397: PPUSH
66398: LD_VAR 0 1
66402: PPUSH
66403: LD_INT 3
66405: PPUSH
66406: CALL_OW 1
66410: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
66411: LD_ADDR_VAR 0 2
66415: PUSH
66416: LD_INT 0
66418: PUSH
66419: LD_INT 0
66421: PUSH
66422: LD_INT 0
66424: PUSH
66425: LD_INT 0
66427: PUSH
66428: EMPTY
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: ST_TO_ADDR
// if not eng then
66434: LD_VAR 0 6
66438: NOT
66439: IFFALSE 66502
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
66441: LD_ADDR_VAR 0 11
66445: PUSH
66446: LD_VAR 0 4
66450: PPUSH
66451: LD_INT 2
66453: PPUSH
66454: CALL 53575 0 2
66458: PUSH
66459: LD_INT 1
66461: ARRAY
66462: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
66463: LD_ADDR_VAR 0 2
66467: PUSH
66468: LD_VAR 0 2
66472: PPUSH
66473: LD_INT 2
66475: PPUSH
66476: LD_VAR 0 11
66480: PPUSH
66481: CALL_OW 1
66485: ST_TO_ADDR
// tmp := tmp diff p ;
66486: LD_ADDR_VAR 0 4
66490: PUSH
66491: LD_VAR 0 4
66495: PUSH
66496: LD_VAR 0 11
66500: DIFF
66501: ST_TO_ADDR
// end ; if tmp and sci < 6 then
66502: LD_VAR 0 4
66506: PUSH
66507: LD_VAR 0 8
66511: PUSH
66512: LD_INT 6
66514: LESS
66515: AND
66516: IFFALSE 66704
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
66518: LD_ADDR_VAR 0 9
66522: PUSH
66523: LD_VAR 0 4
66527: PUSH
66528: LD_VAR 0 8
66532: PUSH
66533: LD_VAR 0 7
66537: UNION
66538: DIFF
66539: PPUSH
66540: LD_INT 4
66542: PPUSH
66543: CALL 53575 0 2
66547: ST_TO_ADDR
// p := [ ] ;
66548: LD_ADDR_VAR 0 11
66552: PUSH
66553: EMPTY
66554: ST_TO_ADDR
// if sort then
66555: LD_VAR 0 9
66559: IFFALSE 66675
// for i = 1 to 6 - sci do
66561: LD_ADDR_VAR 0 3
66565: PUSH
66566: DOUBLE
66567: LD_INT 1
66569: DEC
66570: ST_TO_ADDR
66571: LD_INT 6
66573: PUSH
66574: LD_VAR 0 8
66578: MINUS
66579: PUSH
66580: FOR_TO
66581: IFFALSE 66673
// begin if i = sort then
66583: LD_VAR 0 3
66587: PUSH
66588: LD_VAR 0 9
66592: EQUAL
66593: IFFALSE 66597
// break ;
66595: GO 66673
// if GetClass ( i ) = 4 then
66597: LD_VAR 0 3
66601: PPUSH
66602: CALL_OW 257
66606: PUSH
66607: LD_INT 4
66609: EQUAL
66610: IFFALSE 66614
// continue ;
66612: GO 66580
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66614: LD_ADDR_VAR 0 11
66618: PUSH
66619: LD_VAR 0 11
66623: PPUSH
66624: LD_VAR 0 11
66628: PUSH
66629: LD_INT 1
66631: PLUS
66632: PPUSH
66633: LD_VAR 0 9
66637: PUSH
66638: LD_VAR 0 3
66642: ARRAY
66643: PPUSH
66644: CALL_OW 2
66648: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66649: LD_ADDR_VAR 0 4
66653: PUSH
66654: LD_VAR 0 4
66658: PUSH
66659: LD_VAR 0 9
66663: PUSH
66664: LD_VAR 0 3
66668: ARRAY
66669: DIFF
66670: ST_TO_ADDR
// end ;
66671: GO 66580
66673: POP
66674: POP
// if p then
66675: LD_VAR 0 11
66679: IFFALSE 66704
// result := Replace ( result , 4 , p ) ;
66681: LD_ADDR_VAR 0 2
66685: PUSH
66686: LD_VAR 0 2
66690: PPUSH
66691: LD_INT 4
66693: PPUSH
66694: LD_VAR 0 11
66698: PPUSH
66699: CALL_OW 1
66703: ST_TO_ADDR
// end ; if tmp and mech < 6 then
66704: LD_VAR 0 4
66708: PUSH
66709: LD_VAR 0 7
66713: PUSH
66714: LD_INT 6
66716: LESS
66717: AND
66718: IFFALSE 66906
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
66720: LD_ADDR_VAR 0 9
66724: PUSH
66725: LD_VAR 0 4
66729: PUSH
66730: LD_VAR 0 8
66734: PUSH
66735: LD_VAR 0 7
66739: UNION
66740: DIFF
66741: PPUSH
66742: LD_INT 3
66744: PPUSH
66745: CALL 53575 0 2
66749: ST_TO_ADDR
// p := [ ] ;
66750: LD_ADDR_VAR 0 11
66754: PUSH
66755: EMPTY
66756: ST_TO_ADDR
// if sort then
66757: LD_VAR 0 9
66761: IFFALSE 66877
// for i = 1 to 6 - mech do
66763: LD_ADDR_VAR 0 3
66767: PUSH
66768: DOUBLE
66769: LD_INT 1
66771: DEC
66772: ST_TO_ADDR
66773: LD_INT 6
66775: PUSH
66776: LD_VAR 0 7
66780: MINUS
66781: PUSH
66782: FOR_TO
66783: IFFALSE 66875
// begin if i = sort then
66785: LD_VAR 0 3
66789: PUSH
66790: LD_VAR 0 9
66794: EQUAL
66795: IFFALSE 66799
// break ;
66797: GO 66875
// if GetClass ( i ) = 3 then
66799: LD_VAR 0 3
66803: PPUSH
66804: CALL_OW 257
66808: PUSH
66809: LD_INT 3
66811: EQUAL
66812: IFFALSE 66816
// continue ;
66814: GO 66782
// p := Insert ( p , p + 1 , sort [ i ] ) ;
66816: LD_ADDR_VAR 0 11
66820: PUSH
66821: LD_VAR 0 11
66825: PPUSH
66826: LD_VAR 0 11
66830: PUSH
66831: LD_INT 1
66833: PLUS
66834: PPUSH
66835: LD_VAR 0 9
66839: PUSH
66840: LD_VAR 0 3
66844: ARRAY
66845: PPUSH
66846: CALL_OW 2
66850: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
66851: LD_ADDR_VAR 0 4
66855: PUSH
66856: LD_VAR 0 4
66860: PUSH
66861: LD_VAR 0 9
66865: PUSH
66866: LD_VAR 0 3
66870: ARRAY
66871: DIFF
66872: ST_TO_ADDR
// end ;
66873: GO 66782
66875: POP
66876: POP
// if p then
66877: LD_VAR 0 11
66881: IFFALSE 66906
// result := Replace ( result , 3 , p ) ;
66883: LD_ADDR_VAR 0 2
66887: PUSH
66888: LD_VAR 0 2
66892: PPUSH
66893: LD_INT 3
66895: PPUSH
66896: LD_VAR 0 11
66900: PPUSH
66901: CALL_OW 1
66905: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
66906: LD_VAR 0 4
66910: PUSH
66911: LD_INT 6
66913: GREATER
66914: PUSH
66915: LD_VAR 0 6
66919: PUSH
66920: LD_INT 6
66922: LESS
66923: AND
66924: IFFALSE 67118
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
66926: LD_ADDR_VAR 0 9
66930: PUSH
66931: LD_VAR 0 4
66935: PUSH
66936: LD_VAR 0 8
66940: PUSH
66941: LD_VAR 0 7
66945: UNION
66946: PUSH
66947: LD_VAR 0 6
66951: UNION
66952: DIFF
66953: PPUSH
66954: LD_INT 2
66956: PPUSH
66957: CALL 53575 0 2
66961: ST_TO_ADDR
// p := [ ] ;
66962: LD_ADDR_VAR 0 11
66966: PUSH
66967: EMPTY
66968: ST_TO_ADDR
// if sort then
66969: LD_VAR 0 9
66973: IFFALSE 67089
// for i = 1 to 6 - eng do
66975: LD_ADDR_VAR 0 3
66979: PUSH
66980: DOUBLE
66981: LD_INT 1
66983: DEC
66984: ST_TO_ADDR
66985: LD_INT 6
66987: PUSH
66988: LD_VAR 0 6
66992: MINUS
66993: PUSH
66994: FOR_TO
66995: IFFALSE 67087
// begin if i = sort then
66997: LD_VAR 0 3
67001: PUSH
67002: LD_VAR 0 9
67006: EQUAL
67007: IFFALSE 67011
// break ;
67009: GO 67087
// if GetClass ( i ) = 2 then
67011: LD_VAR 0 3
67015: PPUSH
67016: CALL_OW 257
67020: PUSH
67021: LD_INT 2
67023: EQUAL
67024: IFFALSE 67028
// continue ;
67026: GO 66994
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67028: LD_ADDR_VAR 0 11
67032: PUSH
67033: LD_VAR 0 11
67037: PPUSH
67038: LD_VAR 0 11
67042: PUSH
67043: LD_INT 1
67045: PLUS
67046: PPUSH
67047: LD_VAR 0 9
67051: PUSH
67052: LD_VAR 0 3
67056: ARRAY
67057: PPUSH
67058: CALL_OW 2
67062: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67063: LD_ADDR_VAR 0 4
67067: PUSH
67068: LD_VAR 0 4
67072: PUSH
67073: LD_VAR 0 9
67077: PUSH
67078: LD_VAR 0 3
67082: ARRAY
67083: DIFF
67084: ST_TO_ADDR
// end ;
67085: GO 66994
67087: POP
67088: POP
// if p then
67089: LD_VAR 0 11
67093: IFFALSE 67118
// result := Replace ( result , 2 , p ) ;
67095: LD_ADDR_VAR 0 2
67099: PUSH
67100: LD_VAR 0 2
67104: PPUSH
67105: LD_INT 2
67107: PPUSH
67108: LD_VAR 0 11
67112: PPUSH
67113: CALL_OW 1
67117: ST_TO_ADDR
// end ; exit ;
67118: GO 68506
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
67120: LD_EXP 90
67124: PUSH
67125: LD_EXP 89
67129: PUSH
67130: LD_VAR 0 1
67134: ARRAY
67135: ARRAY
67136: NOT
67137: PUSH
67138: LD_EXP 63
67142: PUSH
67143: LD_VAR 0 1
67147: ARRAY
67148: PPUSH
67149: LD_INT 30
67151: PUSH
67152: LD_INT 3
67154: PUSH
67155: EMPTY
67156: LIST
67157: LIST
67158: PPUSH
67159: CALL_OW 72
67163: AND
67164: PUSH
67165: LD_EXP 68
67169: PUSH
67170: LD_VAR 0 1
67174: ARRAY
67175: AND
67176: IFFALSE 67784
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
67178: LD_ADDR_EXP 105
67182: PUSH
67183: LD_EXP 105
67187: PPUSH
67188: LD_VAR 0 1
67192: PPUSH
67193: LD_INT 5
67195: PPUSH
67196: CALL_OW 1
67200: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67201: LD_ADDR_VAR 0 2
67205: PUSH
67206: LD_INT 0
67208: PUSH
67209: LD_INT 0
67211: PUSH
67212: LD_INT 0
67214: PUSH
67215: LD_INT 0
67217: PUSH
67218: EMPTY
67219: LIST
67220: LIST
67221: LIST
67222: LIST
67223: ST_TO_ADDR
// if sci > 1 then
67224: LD_VAR 0 8
67228: PUSH
67229: LD_INT 1
67231: GREATER
67232: IFFALSE 67260
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
67234: LD_ADDR_VAR 0 4
67238: PUSH
67239: LD_VAR 0 4
67243: PUSH
67244: LD_VAR 0 8
67248: PUSH
67249: LD_VAR 0 8
67253: PUSH
67254: LD_INT 1
67256: ARRAY
67257: DIFF
67258: DIFF
67259: ST_TO_ADDR
// if tmp and not sci then
67260: LD_VAR 0 4
67264: PUSH
67265: LD_VAR 0 8
67269: NOT
67270: AND
67271: IFFALSE 67340
// begin sort := SortBySkill ( tmp , 4 ) ;
67273: LD_ADDR_VAR 0 9
67277: PUSH
67278: LD_VAR 0 4
67282: PPUSH
67283: LD_INT 4
67285: PPUSH
67286: CALL 53575 0 2
67290: ST_TO_ADDR
// if sort then
67291: LD_VAR 0 9
67295: IFFALSE 67311
// p := sort [ 1 ] ;
67297: LD_ADDR_VAR 0 11
67301: PUSH
67302: LD_VAR 0 9
67306: PUSH
67307: LD_INT 1
67309: ARRAY
67310: ST_TO_ADDR
// if p then
67311: LD_VAR 0 11
67315: IFFALSE 67340
// result := Replace ( result , 4 , p ) ;
67317: LD_ADDR_VAR 0 2
67321: PUSH
67322: LD_VAR 0 2
67326: PPUSH
67327: LD_INT 4
67329: PPUSH
67330: LD_VAR 0 11
67334: PPUSH
67335: CALL_OW 1
67339: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67340: LD_ADDR_VAR 0 4
67344: PUSH
67345: LD_VAR 0 4
67349: PUSH
67350: LD_VAR 0 7
67354: DIFF
67355: ST_TO_ADDR
// if tmp and mech < 6 then
67356: LD_VAR 0 4
67360: PUSH
67361: LD_VAR 0 7
67365: PUSH
67366: LD_INT 6
67368: LESS
67369: AND
67370: IFFALSE 67558
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
67372: LD_ADDR_VAR 0 9
67376: PUSH
67377: LD_VAR 0 4
67381: PUSH
67382: LD_VAR 0 8
67386: PUSH
67387: LD_VAR 0 7
67391: UNION
67392: DIFF
67393: PPUSH
67394: LD_INT 3
67396: PPUSH
67397: CALL 53575 0 2
67401: ST_TO_ADDR
// p := [ ] ;
67402: LD_ADDR_VAR 0 11
67406: PUSH
67407: EMPTY
67408: ST_TO_ADDR
// if sort then
67409: LD_VAR 0 9
67413: IFFALSE 67529
// for i = 1 to 6 - mech do
67415: LD_ADDR_VAR 0 3
67419: PUSH
67420: DOUBLE
67421: LD_INT 1
67423: DEC
67424: ST_TO_ADDR
67425: LD_INT 6
67427: PUSH
67428: LD_VAR 0 7
67432: MINUS
67433: PUSH
67434: FOR_TO
67435: IFFALSE 67527
// begin if i = sort then
67437: LD_VAR 0 3
67441: PUSH
67442: LD_VAR 0 9
67446: EQUAL
67447: IFFALSE 67451
// break ;
67449: GO 67527
// if GetClass ( i ) = 3 then
67451: LD_VAR 0 3
67455: PPUSH
67456: CALL_OW 257
67460: PUSH
67461: LD_INT 3
67463: EQUAL
67464: IFFALSE 67468
// continue ;
67466: GO 67434
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67468: LD_ADDR_VAR 0 11
67472: PUSH
67473: LD_VAR 0 11
67477: PPUSH
67478: LD_VAR 0 11
67482: PUSH
67483: LD_INT 1
67485: PLUS
67486: PPUSH
67487: LD_VAR 0 9
67491: PUSH
67492: LD_VAR 0 3
67496: ARRAY
67497: PPUSH
67498: CALL_OW 2
67502: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67503: LD_ADDR_VAR 0 4
67507: PUSH
67508: LD_VAR 0 4
67512: PUSH
67513: LD_VAR 0 9
67517: PUSH
67518: LD_VAR 0 3
67522: ARRAY
67523: DIFF
67524: ST_TO_ADDR
// end ;
67525: GO 67434
67527: POP
67528: POP
// if p then
67529: LD_VAR 0 11
67533: IFFALSE 67558
// result := Replace ( result , 3 , p ) ;
67535: LD_ADDR_VAR 0 2
67539: PUSH
67540: LD_VAR 0 2
67544: PPUSH
67545: LD_INT 3
67547: PPUSH
67548: LD_VAR 0 11
67552: PPUSH
67553: CALL_OW 1
67557: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
67558: LD_ADDR_VAR 0 4
67562: PUSH
67563: LD_VAR 0 4
67567: PUSH
67568: LD_VAR 0 6
67572: DIFF
67573: ST_TO_ADDR
// if tmp and eng < 6 then
67574: LD_VAR 0 4
67578: PUSH
67579: LD_VAR 0 6
67583: PUSH
67584: LD_INT 6
67586: LESS
67587: AND
67588: IFFALSE 67782
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
67590: LD_ADDR_VAR 0 9
67594: PUSH
67595: LD_VAR 0 4
67599: PUSH
67600: LD_VAR 0 8
67604: PUSH
67605: LD_VAR 0 7
67609: UNION
67610: PUSH
67611: LD_VAR 0 6
67615: UNION
67616: DIFF
67617: PPUSH
67618: LD_INT 2
67620: PPUSH
67621: CALL 53575 0 2
67625: ST_TO_ADDR
// p := [ ] ;
67626: LD_ADDR_VAR 0 11
67630: PUSH
67631: EMPTY
67632: ST_TO_ADDR
// if sort then
67633: LD_VAR 0 9
67637: IFFALSE 67753
// for i = 1 to 6 - eng do
67639: LD_ADDR_VAR 0 3
67643: PUSH
67644: DOUBLE
67645: LD_INT 1
67647: DEC
67648: ST_TO_ADDR
67649: LD_INT 6
67651: PUSH
67652: LD_VAR 0 6
67656: MINUS
67657: PUSH
67658: FOR_TO
67659: IFFALSE 67751
// begin if i = sort then
67661: LD_VAR 0 3
67665: PUSH
67666: LD_VAR 0 9
67670: EQUAL
67671: IFFALSE 67675
// break ;
67673: GO 67751
// if GetClass ( i ) = 2 then
67675: LD_VAR 0 3
67679: PPUSH
67680: CALL_OW 257
67684: PUSH
67685: LD_INT 2
67687: EQUAL
67688: IFFALSE 67692
// continue ;
67690: GO 67658
// p := Insert ( p , p + 1 , sort [ i ] ) ;
67692: LD_ADDR_VAR 0 11
67696: PUSH
67697: LD_VAR 0 11
67701: PPUSH
67702: LD_VAR 0 11
67706: PUSH
67707: LD_INT 1
67709: PLUS
67710: PPUSH
67711: LD_VAR 0 9
67715: PUSH
67716: LD_VAR 0 3
67720: ARRAY
67721: PPUSH
67722: CALL_OW 2
67726: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
67727: LD_ADDR_VAR 0 4
67731: PUSH
67732: LD_VAR 0 4
67736: PUSH
67737: LD_VAR 0 9
67741: PUSH
67742: LD_VAR 0 3
67746: ARRAY
67747: DIFF
67748: ST_TO_ADDR
// end ;
67749: GO 67658
67751: POP
67752: POP
// if p then
67753: LD_VAR 0 11
67757: IFFALSE 67782
// result := Replace ( result , 2 , p ) ;
67759: LD_ADDR_VAR 0 2
67763: PUSH
67764: LD_VAR 0 2
67768: PPUSH
67769: LD_INT 2
67771: PPUSH
67772: LD_VAR 0 11
67776: PPUSH
67777: CALL_OW 1
67781: ST_TO_ADDR
// end ; exit ;
67782: GO 68506
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
67784: LD_EXP 90
67788: PUSH
67789: LD_EXP 89
67793: PUSH
67794: LD_VAR 0 1
67798: ARRAY
67799: ARRAY
67800: NOT
67801: PUSH
67802: LD_EXP 63
67806: PUSH
67807: LD_VAR 0 1
67811: ARRAY
67812: PPUSH
67813: LD_INT 30
67815: PUSH
67816: LD_INT 3
67818: PUSH
67819: EMPTY
67820: LIST
67821: LIST
67822: PPUSH
67823: CALL_OW 72
67827: AND
67828: PUSH
67829: LD_EXP 68
67833: PUSH
67834: LD_VAR 0 1
67838: ARRAY
67839: NOT
67840: AND
67841: IFFALSE 68506
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
67843: LD_ADDR_EXP 105
67847: PUSH
67848: LD_EXP 105
67852: PPUSH
67853: LD_VAR 0 1
67857: PPUSH
67858: LD_INT 6
67860: PPUSH
67861: CALL_OW 1
67865: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
67866: LD_ADDR_VAR 0 2
67870: PUSH
67871: LD_INT 0
67873: PUSH
67874: LD_INT 0
67876: PUSH
67877: LD_INT 0
67879: PUSH
67880: LD_INT 0
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: LIST
67887: LIST
67888: ST_TO_ADDR
// if sci >= 1 then
67889: LD_VAR 0 8
67893: PUSH
67894: LD_INT 1
67896: GREATEREQUAL
67897: IFFALSE 67919
// tmp := tmp diff sci [ 1 ] ;
67899: LD_ADDR_VAR 0 4
67903: PUSH
67904: LD_VAR 0 4
67908: PUSH
67909: LD_VAR 0 8
67913: PUSH
67914: LD_INT 1
67916: ARRAY
67917: DIFF
67918: ST_TO_ADDR
// if tmp and not sci then
67919: LD_VAR 0 4
67923: PUSH
67924: LD_VAR 0 8
67928: NOT
67929: AND
67930: IFFALSE 67999
// begin sort := SortBySkill ( tmp , 4 ) ;
67932: LD_ADDR_VAR 0 9
67936: PUSH
67937: LD_VAR 0 4
67941: PPUSH
67942: LD_INT 4
67944: PPUSH
67945: CALL 53575 0 2
67949: ST_TO_ADDR
// if sort then
67950: LD_VAR 0 9
67954: IFFALSE 67970
// p := sort [ 1 ] ;
67956: LD_ADDR_VAR 0 11
67960: PUSH
67961: LD_VAR 0 9
67965: PUSH
67966: LD_INT 1
67968: ARRAY
67969: ST_TO_ADDR
// if p then
67970: LD_VAR 0 11
67974: IFFALSE 67999
// result := Replace ( result , 4 , p ) ;
67976: LD_ADDR_VAR 0 2
67980: PUSH
67981: LD_VAR 0 2
67985: PPUSH
67986: LD_INT 4
67988: PPUSH
67989: LD_VAR 0 11
67993: PPUSH
67994: CALL_OW 1
67998: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
67999: LD_ADDR_VAR 0 4
68003: PUSH
68004: LD_VAR 0 4
68008: PUSH
68009: LD_VAR 0 7
68013: DIFF
68014: ST_TO_ADDR
// if tmp and mech < 6 then
68015: LD_VAR 0 4
68019: PUSH
68020: LD_VAR 0 7
68024: PUSH
68025: LD_INT 6
68027: LESS
68028: AND
68029: IFFALSE 68211
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
68031: LD_ADDR_VAR 0 9
68035: PUSH
68036: LD_VAR 0 4
68040: PUSH
68041: LD_VAR 0 7
68045: DIFF
68046: PPUSH
68047: LD_INT 3
68049: PPUSH
68050: CALL 53575 0 2
68054: ST_TO_ADDR
// p := [ ] ;
68055: LD_ADDR_VAR 0 11
68059: PUSH
68060: EMPTY
68061: ST_TO_ADDR
// if sort then
68062: LD_VAR 0 9
68066: IFFALSE 68182
// for i = 1 to 6 - mech do
68068: LD_ADDR_VAR 0 3
68072: PUSH
68073: DOUBLE
68074: LD_INT 1
68076: DEC
68077: ST_TO_ADDR
68078: LD_INT 6
68080: PUSH
68081: LD_VAR 0 7
68085: MINUS
68086: PUSH
68087: FOR_TO
68088: IFFALSE 68180
// begin if i = sort then
68090: LD_VAR 0 3
68094: PUSH
68095: LD_VAR 0 9
68099: EQUAL
68100: IFFALSE 68104
// break ;
68102: GO 68180
// if GetClass ( i ) = 3 then
68104: LD_VAR 0 3
68108: PPUSH
68109: CALL_OW 257
68113: PUSH
68114: LD_INT 3
68116: EQUAL
68117: IFFALSE 68121
// continue ;
68119: GO 68087
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68121: LD_ADDR_VAR 0 11
68125: PUSH
68126: LD_VAR 0 11
68130: PPUSH
68131: LD_VAR 0 11
68135: PUSH
68136: LD_INT 1
68138: PLUS
68139: PPUSH
68140: LD_VAR 0 9
68144: PUSH
68145: LD_VAR 0 3
68149: ARRAY
68150: PPUSH
68151: CALL_OW 2
68155: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68156: LD_ADDR_VAR 0 4
68160: PUSH
68161: LD_VAR 0 4
68165: PUSH
68166: LD_VAR 0 9
68170: PUSH
68171: LD_VAR 0 3
68175: ARRAY
68176: DIFF
68177: ST_TO_ADDR
// end ;
68178: GO 68087
68180: POP
68181: POP
// if p then
68182: LD_VAR 0 11
68186: IFFALSE 68211
// result := Replace ( result , 3 , p ) ;
68188: LD_ADDR_VAR 0 2
68192: PUSH
68193: LD_VAR 0 2
68197: PPUSH
68198: LD_INT 3
68200: PPUSH
68201: LD_VAR 0 11
68205: PPUSH
68206: CALL_OW 1
68210: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
68211: LD_ADDR_VAR 0 4
68215: PUSH
68216: LD_VAR 0 4
68220: PUSH
68221: LD_VAR 0 6
68225: DIFF
68226: ST_TO_ADDR
// if tmp and eng < 4 then
68227: LD_VAR 0 4
68231: PUSH
68232: LD_VAR 0 6
68236: PUSH
68237: LD_INT 4
68239: LESS
68240: AND
68241: IFFALSE 68431
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
68243: LD_ADDR_VAR 0 9
68247: PUSH
68248: LD_VAR 0 4
68252: PUSH
68253: LD_VAR 0 7
68257: PUSH
68258: LD_VAR 0 6
68262: UNION
68263: DIFF
68264: PPUSH
68265: LD_INT 2
68267: PPUSH
68268: CALL 53575 0 2
68272: ST_TO_ADDR
// p := [ ] ;
68273: LD_ADDR_VAR 0 11
68277: PUSH
68278: EMPTY
68279: ST_TO_ADDR
// if sort then
68280: LD_VAR 0 9
68284: IFFALSE 68400
// for i = 1 to 4 - eng do
68286: LD_ADDR_VAR 0 3
68290: PUSH
68291: DOUBLE
68292: LD_INT 1
68294: DEC
68295: ST_TO_ADDR
68296: LD_INT 4
68298: PUSH
68299: LD_VAR 0 6
68303: MINUS
68304: PUSH
68305: FOR_TO
68306: IFFALSE 68398
// begin if i = sort then
68308: LD_VAR 0 3
68312: PUSH
68313: LD_VAR 0 9
68317: EQUAL
68318: IFFALSE 68322
// break ;
68320: GO 68398
// if GetClass ( i ) = 2 then
68322: LD_VAR 0 3
68326: PPUSH
68327: CALL_OW 257
68331: PUSH
68332: LD_INT 2
68334: EQUAL
68335: IFFALSE 68339
// continue ;
68337: GO 68305
// p := Insert ( p , p + 1 , sort [ i ] ) ;
68339: LD_ADDR_VAR 0 11
68343: PUSH
68344: LD_VAR 0 11
68348: PPUSH
68349: LD_VAR 0 11
68353: PUSH
68354: LD_INT 1
68356: PLUS
68357: PPUSH
68358: LD_VAR 0 9
68362: PUSH
68363: LD_VAR 0 3
68367: ARRAY
68368: PPUSH
68369: CALL_OW 2
68373: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
68374: LD_ADDR_VAR 0 4
68378: PUSH
68379: LD_VAR 0 4
68383: PUSH
68384: LD_VAR 0 9
68388: PUSH
68389: LD_VAR 0 3
68393: ARRAY
68394: DIFF
68395: ST_TO_ADDR
// end ;
68396: GO 68305
68398: POP
68399: POP
// if p then
68400: LD_VAR 0 11
68404: IFFALSE 68429
// result := Replace ( result , 2 , p ) ;
68406: LD_ADDR_VAR 0 2
68410: PUSH
68411: LD_VAR 0 2
68415: PPUSH
68416: LD_INT 2
68418: PPUSH
68419: LD_VAR 0 11
68423: PPUSH
68424: CALL_OW 1
68428: ST_TO_ADDR
// end else
68429: GO 68475
// for i = eng downto 5 do
68431: LD_ADDR_VAR 0 3
68435: PUSH
68436: DOUBLE
68437: LD_VAR 0 6
68441: INC
68442: ST_TO_ADDR
68443: LD_INT 5
68445: PUSH
68446: FOR_DOWNTO
68447: IFFALSE 68473
// tmp := tmp union eng [ i ] ;
68449: LD_ADDR_VAR 0 4
68453: PUSH
68454: LD_VAR 0 4
68458: PUSH
68459: LD_VAR 0 6
68463: PUSH
68464: LD_VAR 0 3
68468: ARRAY
68469: UNION
68470: ST_TO_ADDR
68471: GO 68446
68473: POP
68474: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
68475: LD_ADDR_VAR 0 2
68479: PUSH
68480: LD_VAR 0 2
68484: PPUSH
68485: LD_INT 1
68487: PPUSH
68488: LD_VAR 0 4
68492: PUSH
68493: LD_VAR 0 5
68497: DIFF
68498: PPUSH
68499: CALL_OW 1
68503: ST_TO_ADDR
// exit ;
68504: GO 68506
// end ; end ;
68506: LD_VAR 0 2
68510: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
68511: LD_INT 0
68513: PPUSH
68514: PPUSH
68515: PPUSH
// if not mc_bases then
68516: LD_EXP 63
68520: NOT
68521: IFFALSE 68525
// exit ;
68523: GO 68667
// for i = 1 to mc_bases do
68525: LD_ADDR_VAR 0 2
68529: PUSH
68530: DOUBLE
68531: LD_INT 1
68533: DEC
68534: ST_TO_ADDR
68535: LD_EXP 63
68539: PUSH
68540: FOR_TO
68541: IFFALSE 68658
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68543: LD_ADDR_VAR 0 3
68547: PUSH
68548: LD_EXP 63
68552: PUSH
68553: LD_VAR 0 2
68557: ARRAY
68558: PPUSH
68559: LD_INT 21
68561: PUSH
68562: LD_INT 3
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 3
68571: PUSH
68572: LD_INT 2
68574: PUSH
68575: LD_INT 30
68577: PUSH
68578: LD_INT 29
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 30
68587: PUSH
68588: LD_INT 30
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: EMPTY
68596: LIST
68597: LIST
68598: LIST
68599: PUSH
68600: EMPTY
68601: LIST
68602: LIST
68603: PUSH
68604: LD_INT 3
68606: PUSH
68607: LD_INT 24
68609: PUSH
68610: LD_INT 1000
68612: PUSH
68613: EMPTY
68614: LIST
68615: LIST
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: EMPTY
68622: LIST
68623: LIST
68624: LIST
68625: PPUSH
68626: CALL_OW 72
68630: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
68631: LD_ADDR_EXP 64
68635: PUSH
68636: LD_EXP 64
68640: PPUSH
68641: LD_VAR 0 2
68645: PPUSH
68646: LD_VAR 0 3
68650: PPUSH
68651: CALL_OW 1
68655: ST_TO_ADDR
// end ;
68656: GO 68540
68658: POP
68659: POP
// RaiseSailEvent ( 101 ) ;
68660: LD_INT 101
68662: PPUSH
68663: CALL_OW 427
// end ;
68667: LD_VAR 0 1
68671: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
68672: LD_INT 0
68674: PPUSH
68675: PPUSH
68676: PPUSH
68677: PPUSH
68678: PPUSH
68679: PPUSH
68680: PPUSH
// if not mc_bases then
68681: LD_EXP 63
68685: NOT
68686: IFFALSE 68690
// exit ;
68688: GO 69252
// for i = 1 to mc_bases do
68690: LD_ADDR_VAR 0 2
68694: PUSH
68695: DOUBLE
68696: LD_INT 1
68698: DEC
68699: ST_TO_ADDR
68700: LD_EXP 63
68704: PUSH
68705: FOR_TO
68706: IFFALSE 69243
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
68708: LD_ADDR_VAR 0 5
68712: PUSH
68713: LD_EXP 63
68717: PUSH
68718: LD_VAR 0 2
68722: ARRAY
68723: PUSH
68724: LD_EXP 92
68728: PUSH
68729: LD_VAR 0 2
68733: ARRAY
68734: UNION
68735: PPUSH
68736: LD_INT 21
68738: PUSH
68739: LD_INT 1
68741: PUSH
68742: EMPTY
68743: LIST
68744: LIST
68745: PUSH
68746: LD_INT 1
68748: PUSH
68749: LD_INT 3
68751: PUSH
68752: LD_INT 54
68754: PUSH
68755: EMPTY
68756: LIST
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 3
68764: PUSH
68765: LD_INT 24
68767: PUSH
68768: LD_INT 1000
68770: PUSH
68771: EMPTY
68772: LIST
68773: LIST
68774: PUSH
68775: EMPTY
68776: LIST
68777: LIST
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: LIST
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PPUSH
68788: CALL_OW 72
68792: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
68793: LD_ADDR_VAR 0 6
68797: PUSH
68798: LD_EXP 63
68802: PUSH
68803: LD_VAR 0 2
68807: ARRAY
68808: PPUSH
68809: LD_INT 21
68811: PUSH
68812: LD_INT 1
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: LD_INT 3
68824: PUSH
68825: LD_INT 54
68827: PUSH
68828: EMPTY
68829: LIST
68830: PUSH
68831: EMPTY
68832: LIST
68833: LIST
68834: PUSH
68835: LD_INT 3
68837: PUSH
68838: LD_INT 24
68840: PUSH
68841: LD_INT 250
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: EMPTY
68849: LIST
68850: LIST
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: LIST
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PPUSH
68861: CALL_OW 72
68865: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
68866: LD_ADDR_VAR 0 7
68870: PUSH
68871: LD_VAR 0 5
68875: PUSH
68876: LD_VAR 0 6
68880: DIFF
68881: ST_TO_ADDR
// if not need_heal_1 then
68882: LD_VAR 0 6
68886: NOT
68887: IFFALSE 68920
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
68889: LD_ADDR_EXP 66
68893: PUSH
68894: LD_EXP 66
68898: PPUSH
68899: LD_VAR 0 2
68903: PUSH
68904: LD_INT 1
68906: PUSH
68907: EMPTY
68908: LIST
68909: LIST
68910: PPUSH
68911: EMPTY
68912: PPUSH
68913: CALL 22322 0 3
68917: ST_TO_ADDR
68918: GO 68990
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
68920: LD_ADDR_EXP 66
68924: PUSH
68925: LD_EXP 66
68929: PPUSH
68930: LD_VAR 0 2
68934: PUSH
68935: LD_INT 1
68937: PUSH
68938: EMPTY
68939: LIST
68940: LIST
68941: PPUSH
68942: LD_EXP 66
68946: PUSH
68947: LD_VAR 0 2
68951: ARRAY
68952: PUSH
68953: LD_INT 1
68955: ARRAY
68956: PPUSH
68957: LD_INT 3
68959: PUSH
68960: LD_INT 24
68962: PUSH
68963: LD_INT 1000
68965: PUSH
68966: EMPTY
68967: LIST
68968: LIST
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PPUSH
68974: CALL_OW 72
68978: PUSH
68979: LD_VAR 0 6
68983: UNION
68984: PPUSH
68985: CALL 22322 0 3
68989: ST_TO_ADDR
// if not need_heal_2 then
68990: LD_VAR 0 7
68994: NOT
68995: IFFALSE 69028
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
68997: LD_ADDR_EXP 66
69001: PUSH
69002: LD_EXP 66
69006: PPUSH
69007: LD_VAR 0 2
69011: PUSH
69012: LD_INT 2
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PPUSH
69019: EMPTY
69020: PPUSH
69021: CALL 22322 0 3
69025: ST_TO_ADDR
69026: GO 69060
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
69028: LD_ADDR_EXP 66
69032: PUSH
69033: LD_EXP 66
69037: PPUSH
69038: LD_VAR 0 2
69042: PUSH
69043: LD_INT 2
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PPUSH
69050: LD_VAR 0 7
69054: PPUSH
69055: CALL 22322 0 3
69059: ST_TO_ADDR
// if need_heal_2 then
69060: LD_VAR 0 7
69064: IFFALSE 69225
// for j in need_heal_2 do
69066: LD_ADDR_VAR 0 3
69070: PUSH
69071: LD_VAR 0 7
69075: PUSH
69076: FOR_IN
69077: IFFALSE 69223
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69079: LD_ADDR_VAR 0 5
69083: PUSH
69084: LD_EXP 63
69088: PUSH
69089: LD_VAR 0 2
69093: ARRAY
69094: PPUSH
69095: LD_INT 2
69097: PUSH
69098: LD_INT 30
69100: PUSH
69101: LD_INT 6
69103: PUSH
69104: EMPTY
69105: LIST
69106: LIST
69107: PUSH
69108: LD_INT 30
69110: PUSH
69111: LD_INT 7
69113: PUSH
69114: EMPTY
69115: LIST
69116: LIST
69117: PUSH
69118: LD_INT 30
69120: PUSH
69121: LD_INT 8
69123: PUSH
69124: EMPTY
69125: LIST
69126: LIST
69127: PUSH
69128: LD_INT 30
69130: PUSH
69131: LD_INT 0
69133: PUSH
69134: EMPTY
69135: LIST
69136: LIST
69137: PUSH
69138: LD_INT 30
69140: PUSH
69141: LD_INT 1
69143: PUSH
69144: EMPTY
69145: LIST
69146: LIST
69147: PUSH
69148: EMPTY
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: PPUSH
69156: CALL_OW 72
69160: ST_TO_ADDR
// if tmp then
69161: LD_VAR 0 5
69165: IFFALSE 69221
// begin k := NearestUnitToUnit ( tmp , j ) ;
69167: LD_ADDR_VAR 0 4
69171: PUSH
69172: LD_VAR 0 5
69176: PPUSH
69177: LD_VAR 0 3
69181: PPUSH
69182: CALL_OW 74
69186: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
69187: LD_VAR 0 3
69191: PPUSH
69192: LD_VAR 0 4
69196: PPUSH
69197: CALL_OW 296
69201: PUSH
69202: LD_INT 5
69204: GREATER
69205: IFFALSE 69221
// ComMoveToNearbyEntrance ( j , k ) ;
69207: LD_VAR 0 3
69211: PPUSH
69212: LD_VAR 0 4
69216: PPUSH
69217: CALL 55948 0 2
// end ; end ;
69221: GO 69076
69223: POP
69224: POP
// if not need_heal_1 and not need_heal_2 then
69225: LD_VAR 0 6
69229: NOT
69230: PUSH
69231: LD_VAR 0 7
69235: NOT
69236: AND
69237: IFFALSE 69241
// continue ;
69239: GO 68705
// end ;
69241: GO 68705
69243: POP
69244: POP
// RaiseSailEvent ( 102 ) ;
69245: LD_INT 102
69247: PPUSH
69248: CALL_OW 427
// end ;
69252: LD_VAR 0 1
69256: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
69257: LD_INT 0
69259: PPUSH
69260: PPUSH
69261: PPUSH
69262: PPUSH
69263: PPUSH
69264: PPUSH
69265: PPUSH
69266: PPUSH
// if not mc_bases then
69267: LD_EXP 63
69271: NOT
69272: IFFALSE 69276
// exit ;
69274: GO 70187
// for i = 1 to mc_bases do
69276: LD_ADDR_VAR 0 2
69280: PUSH
69281: DOUBLE
69282: LD_INT 1
69284: DEC
69285: ST_TO_ADDR
69286: LD_EXP 63
69290: PUSH
69291: FOR_TO
69292: IFFALSE 70185
// begin if not mc_building_need_repair [ i ] then
69294: LD_EXP 64
69298: PUSH
69299: LD_VAR 0 2
69303: ARRAY
69304: NOT
69305: IFFALSE 69490
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
69307: LD_ADDR_VAR 0 6
69311: PUSH
69312: LD_EXP 82
69316: PUSH
69317: LD_VAR 0 2
69321: ARRAY
69322: PPUSH
69323: LD_INT 3
69325: PUSH
69326: LD_INT 24
69328: PUSH
69329: LD_INT 1000
69331: PUSH
69332: EMPTY
69333: LIST
69334: LIST
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 2
69342: PUSH
69343: LD_INT 34
69345: PUSH
69346: LD_INT 13
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PUSH
69353: LD_INT 34
69355: PUSH
69356: LD_INT 52
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 34
69365: PUSH
69366: LD_INT 88
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: EMPTY
69374: LIST
69375: LIST
69376: LIST
69377: LIST
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PPUSH
69383: CALL_OW 72
69387: ST_TO_ADDR
// if cranes then
69388: LD_VAR 0 6
69392: IFFALSE 69454
// for j in cranes do
69394: LD_ADDR_VAR 0 3
69398: PUSH
69399: LD_VAR 0 6
69403: PUSH
69404: FOR_IN
69405: IFFALSE 69452
// if not IsInArea ( j , mc_parking [ i ] ) then
69407: LD_VAR 0 3
69411: PPUSH
69412: LD_EXP 87
69416: PUSH
69417: LD_VAR 0 2
69421: ARRAY
69422: PPUSH
69423: CALL_OW 308
69427: NOT
69428: IFFALSE 69450
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69430: LD_VAR 0 3
69434: PPUSH
69435: LD_EXP 87
69439: PUSH
69440: LD_VAR 0 2
69444: ARRAY
69445: PPUSH
69446: CALL_OW 113
69450: GO 69404
69452: POP
69453: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
69454: LD_ADDR_EXP 65
69458: PUSH
69459: LD_EXP 65
69463: PPUSH
69464: LD_VAR 0 2
69468: PPUSH
69469: EMPTY
69470: PPUSH
69471: CALL_OW 1
69475: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
69476: LD_VAR 0 2
69480: PPUSH
69481: LD_INT 101
69483: PPUSH
69484: CALL 64330 0 2
// continue ;
69488: GO 69291
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
69490: LD_ADDR_EXP 69
69494: PUSH
69495: LD_EXP 69
69499: PPUSH
69500: LD_VAR 0 2
69504: PPUSH
69505: EMPTY
69506: PPUSH
69507: CALL_OW 1
69511: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
69512: LD_VAR 0 2
69516: PPUSH
69517: LD_INT 103
69519: PPUSH
69520: CALL 64330 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
69524: LD_ADDR_VAR 0 5
69528: PUSH
69529: LD_EXP 63
69533: PUSH
69534: LD_VAR 0 2
69538: ARRAY
69539: PUSH
69540: LD_EXP 92
69544: PUSH
69545: LD_VAR 0 2
69549: ARRAY
69550: UNION
69551: PPUSH
69552: LD_INT 2
69554: PUSH
69555: LD_INT 25
69557: PUSH
69558: LD_INT 2
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 25
69567: PUSH
69568: LD_INT 16
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: EMPTY
69576: LIST
69577: LIST
69578: LIST
69579: PUSH
69580: EMPTY
69581: LIST
69582: PPUSH
69583: CALL_OW 72
69587: ST_TO_ADDR
// if mc_need_heal [ i ] then
69588: LD_EXP 66
69592: PUSH
69593: LD_VAR 0 2
69597: ARRAY
69598: IFFALSE 69642
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
69600: LD_ADDR_VAR 0 5
69604: PUSH
69605: LD_VAR 0 5
69609: PUSH
69610: LD_EXP 66
69614: PUSH
69615: LD_VAR 0 2
69619: ARRAY
69620: PUSH
69621: LD_INT 1
69623: ARRAY
69624: PUSH
69625: LD_EXP 66
69629: PUSH
69630: LD_VAR 0 2
69634: ARRAY
69635: PUSH
69636: LD_INT 2
69638: ARRAY
69639: UNION
69640: DIFF
69641: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
69642: LD_ADDR_VAR 0 6
69646: PUSH
69647: LD_EXP 82
69651: PUSH
69652: LD_VAR 0 2
69656: ARRAY
69657: PPUSH
69658: LD_INT 2
69660: PUSH
69661: LD_INT 34
69663: PUSH
69664: LD_INT 13
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: PUSH
69671: LD_INT 34
69673: PUSH
69674: LD_INT 52
69676: PUSH
69677: EMPTY
69678: LIST
69679: LIST
69680: PUSH
69681: LD_INT 34
69683: PUSH
69684: LD_INT 88
69686: PUSH
69687: EMPTY
69688: LIST
69689: LIST
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: PPUSH
69697: CALL_OW 72
69701: ST_TO_ADDR
// if cranes then
69702: LD_VAR 0 6
69706: IFFALSE 69874
// begin for j in cranes do
69708: LD_ADDR_VAR 0 3
69712: PUSH
69713: LD_VAR 0 6
69717: PUSH
69718: FOR_IN
69719: IFFALSE 69872
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
69721: LD_VAR 0 3
69725: PPUSH
69726: CALL_OW 256
69730: PUSH
69731: LD_INT 1000
69733: EQUAL
69734: PUSH
69735: LD_VAR 0 3
69739: PPUSH
69740: CALL_OW 314
69744: NOT
69745: AND
69746: IFFALSE 69812
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
69748: LD_ADDR_VAR 0 8
69752: PUSH
69753: LD_EXP 64
69757: PUSH
69758: LD_VAR 0 2
69762: ARRAY
69763: PPUSH
69764: LD_VAR 0 3
69768: PPUSH
69769: CALL_OW 74
69773: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
69774: LD_VAR 0 8
69778: PPUSH
69779: LD_INT 16
69781: PPUSH
69782: CALL 25287 0 2
69786: PUSH
69787: LD_INT 4
69789: ARRAY
69790: PUSH
69791: LD_INT 10
69793: LESS
69794: IFFALSE 69810
// ComRepairBuilding ( j , to_repair ) ;
69796: LD_VAR 0 3
69800: PPUSH
69801: LD_VAR 0 8
69805: PPUSH
69806: CALL_OW 130
// end else
69810: GO 69870
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
69812: LD_VAR 0 3
69816: PPUSH
69817: CALL_OW 256
69821: PUSH
69822: LD_INT 500
69824: LESS
69825: PUSH
69826: LD_VAR 0 3
69830: PPUSH
69831: LD_EXP 87
69835: PUSH
69836: LD_VAR 0 2
69840: ARRAY
69841: PPUSH
69842: CALL_OW 308
69846: NOT
69847: AND
69848: IFFALSE 69870
// ComMoveToArea ( j , mc_parking [ i ] ) ;
69850: LD_VAR 0 3
69854: PPUSH
69855: LD_EXP 87
69859: PUSH
69860: LD_VAR 0 2
69864: ARRAY
69865: PPUSH
69866: CALL_OW 113
// end ;
69870: GO 69718
69872: POP
69873: POP
// end ; if tmp > 3 then
69874: LD_VAR 0 5
69878: PUSH
69879: LD_INT 3
69881: GREATER
69882: IFFALSE 69902
// tmp := ShrinkArray ( tmp , 4 ) ;
69884: LD_ADDR_VAR 0 5
69888: PUSH
69889: LD_VAR 0 5
69893: PPUSH
69894: LD_INT 4
69896: PPUSH
69897: CALL 55386 0 2
69901: ST_TO_ADDR
// if not tmp then
69902: LD_VAR 0 5
69906: NOT
69907: IFFALSE 69911
// continue ;
69909: GO 69291
// for j in tmp do
69911: LD_ADDR_VAR 0 3
69915: PUSH
69916: LD_VAR 0 5
69920: PUSH
69921: FOR_IN
69922: IFFALSE 70181
// begin if IsInUnit ( j ) then
69924: LD_VAR 0 3
69928: PPUSH
69929: CALL_OW 310
69933: IFFALSE 69944
// ComExitBuilding ( j ) ;
69935: LD_VAR 0 3
69939: PPUSH
69940: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
69944: LD_VAR 0 3
69948: PUSH
69949: LD_EXP 65
69953: PUSH
69954: LD_VAR 0 2
69958: ARRAY
69959: IN
69960: NOT
69961: IFFALSE 70019
// begin SetTag ( j , 101 ) ;
69963: LD_VAR 0 3
69967: PPUSH
69968: LD_INT 101
69970: PPUSH
69971: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
69975: LD_ADDR_EXP 65
69979: PUSH
69980: LD_EXP 65
69984: PPUSH
69985: LD_VAR 0 2
69989: PUSH
69990: LD_EXP 65
69994: PUSH
69995: LD_VAR 0 2
69999: ARRAY
70000: PUSH
70001: LD_INT 1
70003: PLUS
70004: PUSH
70005: EMPTY
70006: LIST
70007: LIST
70008: PPUSH
70009: LD_VAR 0 3
70013: PPUSH
70014: CALL 22322 0 3
70018: ST_TO_ADDR
// end ; wait ( 1 ) ;
70019: LD_INT 1
70021: PPUSH
70022: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
70026: LD_ADDR_VAR 0 7
70030: PUSH
70031: LD_EXP 64
70035: PUSH
70036: LD_VAR 0 2
70040: ARRAY
70041: ST_TO_ADDR
// if mc_scan [ i ] then
70042: LD_EXP 86
70046: PUSH
70047: LD_VAR 0 2
70051: ARRAY
70052: IFFALSE 70114
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
70054: LD_ADDR_VAR 0 7
70058: PUSH
70059: LD_EXP 64
70063: PUSH
70064: LD_VAR 0 2
70068: ARRAY
70069: PPUSH
70070: LD_INT 3
70072: PUSH
70073: LD_INT 30
70075: PUSH
70076: LD_INT 32
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 30
70085: PUSH
70086: LD_INT 33
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 30
70095: PUSH
70096: LD_INT 31
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: LIST
70107: LIST
70108: PPUSH
70109: CALL_OW 72
70113: ST_TO_ADDR
// if not to_repair_tmp then
70114: LD_VAR 0 7
70118: NOT
70119: IFFALSE 70123
// continue ;
70121: GO 69921
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
70123: LD_ADDR_VAR 0 8
70127: PUSH
70128: LD_VAR 0 7
70132: PPUSH
70133: LD_VAR 0 3
70137: PPUSH
70138: CALL_OW 74
70142: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
70143: LD_VAR 0 8
70147: PPUSH
70148: LD_INT 16
70150: PPUSH
70151: CALL 25287 0 2
70155: PUSH
70156: LD_INT 4
70158: ARRAY
70159: PUSH
70160: LD_INT 14
70162: LESS
70163: IFFALSE 70179
// ComRepairBuilding ( j , to_repair ) ;
70165: LD_VAR 0 3
70169: PPUSH
70170: LD_VAR 0 8
70174: PPUSH
70175: CALL_OW 130
// end ;
70179: GO 69921
70181: POP
70182: POP
// end ;
70183: GO 69291
70185: POP
70186: POP
// end ;
70187: LD_VAR 0 1
70191: RET
// export function MC_Heal ; var i , j , tmp ; begin
70192: LD_INT 0
70194: PPUSH
70195: PPUSH
70196: PPUSH
70197: PPUSH
// if not mc_bases then
70198: LD_EXP 63
70202: NOT
70203: IFFALSE 70207
// exit ;
70205: GO 70609
// for i = 1 to mc_bases do
70207: LD_ADDR_VAR 0 2
70211: PUSH
70212: DOUBLE
70213: LD_INT 1
70215: DEC
70216: ST_TO_ADDR
70217: LD_EXP 63
70221: PUSH
70222: FOR_TO
70223: IFFALSE 70607
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
70225: LD_EXP 66
70229: PUSH
70230: LD_VAR 0 2
70234: ARRAY
70235: PUSH
70236: LD_INT 1
70238: ARRAY
70239: NOT
70240: PUSH
70241: LD_EXP 66
70245: PUSH
70246: LD_VAR 0 2
70250: ARRAY
70251: PUSH
70252: LD_INT 2
70254: ARRAY
70255: NOT
70256: AND
70257: IFFALSE 70295
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
70259: LD_ADDR_EXP 67
70263: PUSH
70264: LD_EXP 67
70268: PPUSH
70269: LD_VAR 0 2
70273: PPUSH
70274: EMPTY
70275: PPUSH
70276: CALL_OW 1
70280: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
70281: LD_VAR 0 2
70285: PPUSH
70286: LD_INT 102
70288: PPUSH
70289: CALL 64330 0 2
// continue ;
70293: GO 70222
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
70295: LD_ADDR_VAR 0 4
70299: PUSH
70300: LD_EXP 63
70304: PUSH
70305: LD_VAR 0 2
70309: ARRAY
70310: PPUSH
70311: LD_INT 25
70313: PUSH
70314: LD_INT 4
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PPUSH
70321: CALL_OW 72
70325: ST_TO_ADDR
// if not tmp then
70326: LD_VAR 0 4
70330: NOT
70331: IFFALSE 70335
// continue ;
70333: GO 70222
// if mc_taming [ i ] then
70335: LD_EXP 94
70339: PUSH
70340: LD_VAR 0 2
70344: ARRAY
70345: IFFALSE 70369
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70347: LD_ADDR_EXP 94
70351: PUSH
70352: LD_EXP 94
70356: PPUSH
70357: LD_VAR 0 2
70361: PPUSH
70362: EMPTY
70363: PPUSH
70364: CALL_OW 1
70368: ST_TO_ADDR
// for j in tmp do
70369: LD_ADDR_VAR 0 3
70373: PUSH
70374: LD_VAR 0 4
70378: PUSH
70379: FOR_IN
70380: IFFALSE 70603
// begin if IsInUnit ( j ) then
70382: LD_VAR 0 3
70386: PPUSH
70387: CALL_OW 310
70391: IFFALSE 70402
// ComExitBuilding ( j ) ;
70393: LD_VAR 0 3
70397: PPUSH
70398: CALL_OW 122
// if not j in mc_healers [ i ] then
70402: LD_VAR 0 3
70406: PUSH
70407: LD_EXP 67
70411: PUSH
70412: LD_VAR 0 2
70416: ARRAY
70417: IN
70418: NOT
70419: IFFALSE 70465
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
70421: LD_ADDR_EXP 67
70425: PUSH
70426: LD_EXP 67
70430: PPUSH
70431: LD_VAR 0 2
70435: PUSH
70436: LD_EXP 67
70440: PUSH
70441: LD_VAR 0 2
70445: ARRAY
70446: PUSH
70447: LD_INT 1
70449: PLUS
70450: PUSH
70451: EMPTY
70452: LIST
70453: LIST
70454: PPUSH
70455: LD_VAR 0 3
70459: PPUSH
70460: CALL 22322 0 3
70464: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
70465: LD_VAR 0 3
70469: PPUSH
70470: CALL_OW 110
70474: PUSH
70475: LD_INT 102
70477: NONEQUAL
70478: IFFALSE 70492
// SetTag ( j , 102 ) ;
70480: LD_VAR 0 3
70484: PPUSH
70485: LD_INT 102
70487: PPUSH
70488: CALL_OW 109
// Wait ( 3 ) ;
70492: LD_INT 3
70494: PPUSH
70495: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
70499: LD_EXP 66
70503: PUSH
70504: LD_VAR 0 2
70508: ARRAY
70509: PUSH
70510: LD_INT 1
70512: ARRAY
70513: IFFALSE 70545
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
70515: LD_VAR 0 3
70519: PPUSH
70520: LD_EXP 66
70524: PUSH
70525: LD_VAR 0 2
70529: ARRAY
70530: PUSH
70531: LD_INT 1
70533: ARRAY
70534: PUSH
70535: LD_INT 1
70537: ARRAY
70538: PPUSH
70539: CALL_OW 128
70543: GO 70601
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
70545: LD_VAR 0 3
70549: PPUSH
70550: CALL_OW 314
70554: NOT
70555: PUSH
70556: LD_EXP 66
70560: PUSH
70561: LD_VAR 0 2
70565: ARRAY
70566: PUSH
70567: LD_INT 2
70569: ARRAY
70570: AND
70571: IFFALSE 70601
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
70573: LD_VAR 0 3
70577: PPUSH
70578: LD_EXP 66
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: PUSH
70589: LD_INT 2
70591: ARRAY
70592: PUSH
70593: LD_INT 1
70595: ARRAY
70596: PPUSH
70597: CALL_OW 128
// end ;
70601: GO 70379
70603: POP
70604: POP
// end ;
70605: GO 70222
70607: POP
70608: POP
// end ;
70609: LD_VAR 0 1
70613: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
70614: LD_INT 0
70616: PPUSH
70617: PPUSH
70618: PPUSH
70619: PPUSH
70620: PPUSH
70621: PPUSH
// if not mc_bases then
70622: LD_EXP 63
70626: NOT
70627: IFFALSE 70631
// exit ;
70629: GO 71794
// for i = 1 to mc_bases do
70631: LD_ADDR_VAR 0 2
70635: PUSH
70636: DOUBLE
70637: LD_INT 1
70639: DEC
70640: ST_TO_ADDR
70641: LD_EXP 63
70645: PUSH
70646: FOR_TO
70647: IFFALSE 71792
// begin if mc_scan [ i ] then
70649: LD_EXP 86
70653: PUSH
70654: LD_VAR 0 2
70658: ARRAY
70659: IFFALSE 70663
// continue ;
70661: GO 70646
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
70663: LD_EXP 68
70667: PUSH
70668: LD_VAR 0 2
70672: ARRAY
70673: NOT
70674: PUSH
70675: LD_EXP 70
70679: PUSH
70680: LD_VAR 0 2
70684: ARRAY
70685: NOT
70686: AND
70687: PUSH
70688: LD_EXP 69
70692: PUSH
70693: LD_VAR 0 2
70697: ARRAY
70698: AND
70699: IFFALSE 70737
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
70701: LD_ADDR_EXP 69
70705: PUSH
70706: LD_EXP 69
70710: PPUSH
70711: LD_VAR 0 2
70715: PPUSH
70716: EMPTY
70717: PPUSH
70718: CALL_OW 1
70722: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
70723: LD_VAR 0 2
70727: PPUSH
70728: LD_INT 103
70730: PPUSH
70731: CALL 64330 0 2
// continue ;
70735: GO 70646
// end ; if mc_construct_list [ i ] then
70737: LD_EXP 70
70741: PUSH
70742: LD_VAR 0 2
70746: ARRAY
70747: IFFALSE 70967
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
70749: LD_ADDR_VAR 0 5
70753: PUSH
70754: LD_EXP 63
70758: PUSH
70759: LD_VAR 0 2
70763: ARRAY
70764: PPUSH
70765: LD_INT 25
70767: PUSH
70768: LD_INT 2
70770: PUSH
70771: EMPTY
70772: LIST
70773: LIST
70774: PPUSH
70775: CALL_OW 72
70779: PUSH
70780: LD_EXP 65
70784: PUSH
70785: LD_VAR 0 2
70789: ARRAY
70790: DIFF
70791: ST_TO_ADDR
// if not tmp then
70792: LD_VAR 0 5
70796: NOT
70797: IFFALSE 70801
// continue ;
70799: GO 70646
// for j in tmp do
70801: LD_ADDR_VAR 0 3
70805: PUSH
70806: LD_VAR 0 5
70810: PUSH
70811: FOR_IN
70812: IFFALSE 70963
// begin if not mc_builders [ i ] then
70814: LD_EXP 69
70818: PUSH
70819: LD_VAR 0 2
70823: ARRAY
70824: NOT
70825: IFFALSE 70883
// begin SetTag ( j , 103 ) ;
70827: LD_VAR 0 3
70831: PPUSH
70832: LD_INT 103
70834: PPUSH
70835: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
70839: LD_ADDR_EXP 69
70843: PUSH
70844: LD_EXP 69
70848: PPUSH
70849: LD_VAR 0 2
70853: PUSH
70854: LD_EXP 69
70858: PUSH
70859: LD_VAR 0 2
70863: ARRAY
70864: PUSH
70865: LD_INT 1
70867: PLUS
70868: PUSH
70869: EMPTY
70870: LIST
70871: LIST
70872: PPUSH
70873: LD_VAR 0 3
70877: PPUSH
70878: CALL 22322 0 3
70882: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
70883: LD_VAR 0 3
70887: PPUSH
70888: CALL_OW 310
70892: IFFALSE 70903
// ComExitBuilding ( j ) ;
70894: LD_VAR 0 3
70898: PPUSH
70899: CALL_OW 122
// wait ( 3 ) ;
70903: LD_INT 3
70905: PPUSH
70906: CALL_OW 67
// if not mc_construct_list [ i ] then
70910: LD_EXP 70
70914: PUSH
70915: LD_VAR 0 2
70919: ARRAY
70920: NOT
70921: IFFALSE 70925
// break ;
70923: GO 70963
// if not HasTask ( j ) then
70925: LD_VAR 0 3
70929: PPUSH
70930: CALL_OW 314
70934: NOT
70935: IFFALSE 70961
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
70937: LD_VAR 0 3
70941: PPUSH
70942: LD_EXP 70
70946: PUSH
70947: LD_VAR 0 2
70951: ARRAY
70952: PUSH
70953: LD_INT 1
70955: ARRAY
70956: PPUSH
70957: CALL 25560 0 2
// end ;
70961: GO 70811
70963: POP
70964: POP
// end else
70965: GO 71790
// if mc_build_list [ i ] then
70967: LD_EXP 68
70971: PUSH
70972: LD_VAR 0 2
70976: ARRAY
70977: IFFALSE 71790
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
70979: LD_EXP 68
70983: PUSH
70984: LD_VAR 0 2
70988: ARRAY
70989: PUSH
70990: LD_INT 1
70992: ARRAY
70993: PUSH
70994: LD_INT 1
70996: ARRAY
70997: PPUSH
70998: CALL 25384 0 1
71002: PUSH
71003: LD_EXP 63
71007: PUSH
71008: LD_VAR 0 2
71012: ARRAY
71013: PPUSH
71014: LD_INT 2
71016: PUSH
71017: LD_INT 30
71019: PUSH
71020: LD_INT 2
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 30
71029: PUSH
71030: LD_INT 3
71032: PUSH
71033: EMPTY
71034: LIST
71035: LIST
71036: PUSH
71037: EMPTY
71038: LIST
71039: LIST
71040: LIST
71041: PPUSH
71042: CALL_OW 72
71046: NOT
71047: AND
71048: IFFALSE 71153
// begin for j = 1 to mc_build_list [ i ] do
71050: LD_ADDR_VAR 0 3
71054: PUSH
71055: DOUBLE
71056: LD_INT 1
71058: DEC
71059: ST_TO_ADDR
71060: LD_EXP 68
71064: PUSH
71065: LD_VAR 0 2
71069: ARRAY
71070: PUSH
71071: FOR_TO
71072: IFFALSE 71151
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
71074: LD_EXP 68
71078: PUSH
71079: LD_VAR 0 2
71083: ARRAY
71084: PUSH
71085: LD_VAR 0 3
71089: ARRAY
71090: PUSH
71091: LD_INT 1
71093: ARRAY
71094: PUSH
71095: LD_INT 2
71097: EQUAL
71098: IFFALSE 71149
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
71100: LD_ADDR_EXP 68
71104: PUSH
71105: LD_EXP 68
71109: PPUSH
71110: LD_VAR 0 2
71114: PPUSH
71115: LD_EXP 68
71119: PUSH
71120: LD_VAR 0 2
71124: ARRAY
71125: PPUSH
71126: LD_VAR 0 3
71130: PPUSH
71131: LD_INT 1
71133: PPUSH
71134: LD_INT 0
71136: PPUSH
71137: CALL 21740 0 4
71141: PPUSH
71142: CALL_OW 1
71146: ST_TO_ADDR
// break ;
71147: GO 71151
// end ;
71149: GO 71071
71151: POP
71152: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71153: LD_ADDR_VAR 0 6
71157: PUSH
71158: LD_EXP 63
71162: PUSH
71163: LD_VAR 0 2
71167: ARRAY
71168: PPUSH
71169: LD_INT 2
71171: PUSH
71172: LD_INT 30
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 30
71184: PUSH
71185: LD_INT 1
71187: PUSH
71188: EMPTY
71189: LIST
71190: LIST
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: LIST
71196: PPUSH
71197: CALL_OW 72
71201: ST_TO_ADDR
// for k := 1 to depot do
71202: LD_ADDR_VAR 0 4
71206: PUSH
71207: DOUBLE
71208: LD_INT 1
71210: DEC
71211: ST_TO_ADDR
71212: LD_VAR 0 6
71216: PUSH
71217: FOR_TO
71218: IFFALSE 71788
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
71220: LD_EXP 68
71224: PUSH
71225: LD_VAR 0 2
71229: ARRAY
71230: PUSH
71231: LD_INT 1
71233: ARRAY
71234: PUSH
71235: LD_INT 1
71237: ARRAY
71238: PUSH
71239: LD_INT 0
71241: EQUAL
71242: PUSH
71243: LD_VAR 0 6
71247: PUSH
71248: LD_VAR 0 4
71252: ARRAY
71253: PPUSH
71254: LD_EXP 68
71258: PUSH
71259: LD_VAR 0 2
71263: ARRAY
71264: PUSH
71265: LD_INT 1
71267: ARRAY
71268: PUSH
71269: LD_INT 1
71271: ARRAY
71272: PPUSH
71273: LD_EXP 68
71277: PUSH
71278: LD_VAR 0 2
71282: ARRAY
71283: PUSH
71284: LD_INT 1
71286: ARRAY
71287: PUSH
71288: LD_INT 2
71290: ARRAY
71291: PPUSH
71292: LD_EXP 68
71296: PUSH
71297: LD_VAR 0 2
71301: ARRAY
71302: PUSH
71303: LD_INT 1
71305: ARRAY
71306: PUSH
71307: LD_INT 3
71309: ARRAY
71310: PPUSH
71311: LD_EXP 68
71315: PUSH
71316: LD_VAR 0 2
71320: ARRAY
71321: PUSH
71322: LD_INT 1
71324: ARRAY
71325: PUSH
71326: LD_INT 4
71328: ARRAY
71329: PPUSH
71330: CALL 30796 0 5
71334: OR
71335: IFFALSE 71616
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
71337: LD_ADDR_VAR 0 5
71341: PUSH
71342: LD_EXP 63
71346: PUSH
71347: LD_VAR 0 2
71351: ARRAY
71352: PPUSH
71353: LD_INT 25
71355: PUSH
71356: LD_INT 2
71358: PUSH
71359: EMPTY
71360: LIST
71361: LIST
71362: PPUSH
71363: CALL_OW 72
71367: PUSH
71368: LD_EXP 65
71372: PUSH
71373: LD_VAR 0 2
71377: ARRAY
71378: DIFF
71379: ST_TO_ADDR
// if not tmp then
71380: LD_VAR 0 5
71384: NOT
71385: IFFALSE 71389
// continue ;
71387: GO 71217
// for j in tmp do
71389: LD_ADDR_VAR 0 3
71393: PUSH
71394: LD_VAR 0 5
71398: PUSH
71399: FOR_IN
71400: IFFALSE 71612
// begin if not mc_builders [ i ] then
71402: LD_EXP 69
71406: PUSH
71407: LD_VAR 0 2
71411: ARRAY
71412: NOT
71413: IFFALSE 71471
// begin SetTag ( j , 103 ) ;
71415: LD_VAR 0 3
71419: PPUSH
71420: LD_INT 103
71422: PPUSH
71423: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
71427: LD_ADDR_EXP 69
71431: PUSH
71432: LD_EXP 69
71436: PPUSH
71437: LD_VAR 0 2
71441: PUSH
71442: LD_EXP 69
71446: PUSH
71447: LD_VAR 0 2
71451: ARRAY
71452: PUSH
71453: LD_INT 1
71455: PLUS
71456: PUSH
71457: EMPTY
71458: LIST
71459: LIST
71460: PPUSH
71461: LD_VAR 0 3
71465: PPUSH
71466: CALL 22322 0 3
71470: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
71471: LD_VAR 0 3
71475: PPUSH
71476: CALL_OW 310
71480: IFFALSE 71491
// ComExitBuilding ( j ) ;
71482: LD_VAR 0 3
71486: PPUSH
71487: CALL_OW 122
// wait ( 3 ) ;
71491: LD_INT 3
71493: PPUSH
71494: CALL_OW 67
// if not mc_build_list [ i ] then
71498: LD_EXP 68
71502: PUSH
71503: LD_VAR 0 2
71507: ARRAY
71508: NOT
71509: IFFALSE 71513
// break ;
71511: GO 71612
// if not HasTask ( j ) then
71513: LD_VAR 0 3
71517: PPUSH
71518: CALL_OW 314
71522: NOT
71523: IFFALSE 71610
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
71525: LD_VAR 0 3
71529: PPUSH
71530: LD_EXP 68
71534: PUSH
71535: LD_VAR 0 2
71539: ARRAY
71540: PUSH
71541: LD_INT 1
71543: ARRAY
71544: PUSH
71545: LD_INT 1
71547: ARRAY
71548: PPUSH
71549: LD_EXP 68
71553: PUSH
71554: LD_VAR 0 2
71558: ARRAY
71559: PUSH
71560: LD_INT 1
71562: ARRAY
71563: PUSH
71564: LD_INT 2
71566: ARRAY
71567: PPUSH
71568: LD_EXP 68
71572: PUSH
71573: LD_VAR 0 2
71577: ARRAY
71578: PUSH
71579: LD_INT 1
71581: ARRAY
71582: PUSH
71583: LD_INT 3
71585: ARRAY
71586: PPUSH
71587: LD_EXP 68
71591: PUSH
71592: LD_VAR 0 2
71596: ARRAY
71597: PUSH
71598: LD_INT 1
71600: ARRAY
71601: PUSH
71602: LD_INT 4
71604: ARRAY
71605: PPUSH
71606: CALL_OW 145
// end ;
71610: GO 71399
71612: POP
71613: POP
// end else
71614: GO 71786
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
71616: LD_EXP 63
71620: PUSH
71621: LD_VAR 0 2
71625: ARRAY
71626: PPUSH
71627: LD_EXP 68
71631: PUSH
71632: LD_VAR 0 2
71636: ARRAY
71637: PUSH
71638: LD_INT 1
71640: ARRAY
71641: PUSH
71642: LD_INT 1
71644: ARRAY
71645: PPUSH
71646: LD_EXP 68
71650: PUSH
71651: LD_VAR 0 2
71655: ARRAY
71656: PUSH
71657: LD_INT 1
71659: ARRAY
71660: PUSH
71661: LD_INT 2
71663: ARRAY
71664: PPUSH
71665: LD_EXP 68
71669: PUSH
71670: LD_VAR 0 2
71674: ARRAY
71675: PUSH
71676: LD_INT 1
71678: ARRAY
71679: PUSH
71680: LD_INT 3
71682: ARRAY
71683: PPUSH
71684: LD_EXP 68
71688: PUSH
71689: LD_VAR 0 2
71693: ARRAY
71694: PUSH
71695: LD_INT 1
71697: ARRAY
71698: PUSH
71699: LD_INT 4
71701: ARRAY
71702: PPUSH
71703: LD_EXP 63
71707: PUSH
71708: LD_VAR 0 2
71712: ARRAY
71713: PPUSH
71714: LD_INT 21
71716: PUSH
71717: LD_INT 3
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PPUSH
71724: CALL_OW 72
71728: PPUSH
71729: EMPTY
71730: PPUSH
71731: CALL 29550 0 7
71735: NOT
71736: IFFALSE 71786
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
71738: LD_ADDR_EXP 68
71742: PUSH
71743: LD_EXP 68
71747: PPUSH
71748: LD_VAR 0 2
71752: PPUSH
71753: LD_EXP 68
71757: PUSH
71758: LD_VAR 0 2
71762: ARRAY
71763: PPUSH
71764: LD_INT 1
71766: PPUSH
71767: LD_INT 1
71769: NEG
71770: PPUSH
71771: LD_INT 0
71773: PPUSH
71774: CALL 21740 0 4
71778: PPUSH
71779: CALL_OW 1
71783: ST_TO_ADDR
// continue ;
71784: GO 71217
// end ; end ;
71786: GO 71217
71788: POP
71789: POP
// end ; end ;
71790: GO 70646
71792: POP
71793: POP
// end ;
71794: LD_VAR 0 1
71798: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
71799: LD_INT 0
71801: PPUSH
71802: PPUSH
71803: PPUSH
71804: PPUSH
71805: PPUSH
71806: PPUSH
// if not mc_bases then
71807: LD_EXP 63
71811: NOT
71812: IFFALSE 71816
// exit ;
71814: GO 72243
// for i = 1 to mc_bases do
71816: LD_ADDR_VAR 0 2
71820: PUSH
71821: DOUBLE
71822: LD_INT 1
71824: DEC
71825: ST_TO_ADDR
71826: LD_EXP 63
71830: PUSH
71831: FOR_TO
71832: IFFALSE 72241
// begin tmp := mc_build_upgrade [ i ] ;
71834: LD_ADDR_VAR 0 4
71838: PUSH
71839: LD_EXP 95
71843: PUSH
71844: LD_VAR 0 2
71848: ARRAY
71849: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
71850: LD_ADDR_VAR 0 6
71854: PUSH
71855: LD_EXP 96
71859: PUSH
71860: LD_VAR 0 2
71864: ARRAY
71865: PPUSH
71866: LD_INT 2
71868: PUSH
71869: LD_INT 30
71871: PUSH
71872: LD_INT 6
71874: PUSH
71875: EMPTY
71876: LIST
71877: LIST
71878: PUSH
71879: LD_INT 30
71881: PUSH
71882: LD_INT 7
71884: PUSH
71885: EMPTY
71886: LIST
71887: LIST
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: LIST
71893: PPUSH
71894: CALL_OW 72
71898: ST_TO_ADDR
// if not tmp and not lab then
71899: LD_VAR 0 4
71903: NOT
71904: PUSH
71905: LD_VAR 0 6
71909: NOT
71910: AND
71911: IFFALSE 71915
// continue ;
71913: GO 71831
// if tmp then
71915: LD_VAR 0 4
71919: IFFALSE 72039
// for j in tmp do
71921: LD_ADDR_VAR 0 3
71925: PUSH
71926: LD_VAR 0 4
71930: PUSH
71931: FOR_IN
71932: IFFALSE 72037
// begin if UpgradeCost ( j ) then
71934: LD_VAR 0 3
71938: PPUSH
71939: CALL 29210 0 1
71943: IFFALSE 72035
// begin ComUpgrade ( j ) ;
71945: LD_VAR 0 3
71949: PPUSH
71950: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
71954: LD_ADDR_EXP 95
71958: PUSH
71959: LD_EXP 95
71963: PPUSH
71964: LD_VAR 0 2
71968: PPUSH
71969: LD_EXP 95
71973: PUSH
71974: LD_VAR 0 2
71978: ARRAY
71979: PUSH
71980: LD_VAR 0 3
71984: DIFF
71985: PPUSH
71986: CALL_OW 1
71990: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
71991: LD_ADDR_EXP 70
71995: PUSH
71996: LD_EXP 70
72000: PPUSH
72001: LD_VAR 0 2
72005: PUSH
72006: LD_EXP 70
72010: PUSH
72011: LD_VAR 0 2
72015: ARRAY
72016: PUSH
72017: LD_INT 1
72019: PLUS
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PPUSH
72025: LD_VAR 0 3
72029: PPUSH
72030: CALL 22322 0 3
72034: ST_TO_ADDR
// end ; end ;
72035: GO 71931
72037: POP
72038: POP
// if not lab or not mc_lab_upgrade [ i ] then
72039: LD_VAR 0 6
72043: NOT
72044: PUSH
72045: LD_EXP 97
72049: PUSH
72050: LD_VAR 0 2
72054: ARRAY
72055: NOT
72056: OR
72057: IFFALSE 72061
// continue ;
72059: GO 71831
// for j in lab do
72061: LD_ADDR_VAR 0 3
72065: PUSH
72066: LD_VAR 0 6
72070: PUSH
72071: FOR_IN
72072: IFFALSE 72237
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
72074: LD_VAR 0 3
72078: PPUSH
72079: CALL_OW 266
72083: PUSH
72084: LD_INT 6
72086: PUSH
72087: LD_INT 7
72089: PUSH
72090: EMPTY
72091: LIST
72092: LIST
72093: IN
72094: PUSH
72095: LD_VAR 0 3
72099: PPUSH
72100: CALL_OW 461
72104: PUSH
72105: LD_INT 1
72107: NONEQUAL
72108: AND
72109: IFFALSE 72235
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
72111: LD_VAR 0 3
72115: PPUSH
72116: LD_EXP 97
72120: PUSH
72121: LD_VAR 0 2
72125: ARRAY
72126: PUSH
72127: LD_INT 1
72129: ARRAY
72130: PPUSH
72131: CALL 29415 0 2
72135: IFFALSE 72235
// begin ComCancel ( j ) ;
72137: LD_VAR 0 3
72141: PPUSH
72142: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
72146: LD_VAR 0 3
72150: PPUSH
72151: LD_EXP 97
72155: PUSH
72156: LD_VAR 0 2
72160: ARRAY
72161: PUSH
72162: LD_INT 1
72164: ARRAY
72165: PPUSH
72166: CALL_OW 207
// if not j in mc_construct_list [ i ] then
72170: LD_VAR 0 3
72174: PUSH
72175: LD_EXP 70
72179: PUSH
72180: LD_VAR 0 2
72184: ARRAY
72185: IN
72186: NOT
72187: IFFALSE 72233
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
72189: LD_ADDR_EXP 70
72193: PUSH
72194: LD_EXP 70
72198: PPUSH
72199: LD_VAR 0 2
72203: PUSH
72204: LD_EXP 70
72208: PUSH
72209: LD_VAR 0 2
72213: ARRAY
72214: PUSH
72215: LD_INT 1
72217: PLUS
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PPUSH
72223: LD_VAR 0 3
72227: PPUSH
72228: CALL 22322 0 3
72232: ST_TO_ADDR
// break ;
72233: GO 72237
// end ; end ; end ;
72235: GO 72071
72237: POP
72238: POP
// end ;
72239: GO 71831
72241: POP
72242: POP
// end ;
72243: LD_VAR 0 1
72247: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
72248: LD_INT 0
72250: PPUSH
72251: PPUSH
72252: PPUSH
72253: PPUSH
72254: PPUSH
72255: PPUSH
72256: PPUSH
72257: PPUSH
72258: PPUSH
// if not mc_bases then
72259: LD_EXP 63
72263: NOT
72264: IFFALSE 72268
// exit ;
72266: GO 72673
// for i = 1 to mc_bases do
72268: LD_ADDR_VAR 0 2
72272: PUSH
72273: DOUBLE
72274: LD_INT 1
72276: DEC
72277: ST_TO_ADDR
72278: LD_EXP 63
72282: PUSH
72283: FOR_TO
72284: IFFALSE 72671
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
72286: LD_EXP 71
72290: PUSH
72291: LD_VAR 0 2
72295: ARRAY
72296: NOT
72297: PUSH
72298: LD_EXP 63
72302: PUSH
72303: LD_VAR 0 2
72307: ARRAY
72308: PPUSH
72309: LD_INT 30
72311: PUSH
72312: LD_INT 3
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PPUSH
72319: CALL_OW 72
72323: NOT
72324: OR
72325: IFFALSE 72329
// continue ;
72327: GO 72283
// busy := false ;
72329: LD_ADDR_VAR 0 8
72333: PUSH
72334: LD_INT 0
72336: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72337: LD_ADDR_VAR 0 4
72341: PUSH
72342: LD_EXP 63
72346: PUSH
72347: LD_VAR 0 2
72351: ARRAY
72352: PPUSH
72353: LD_INT 30
72355: PUSH
72356: LD_INT 3
72358: PUSH
72359: EMPTY
72360: LIST
72361: LIST
72362: PPUSH
72363: CALL_OW 72
72367: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
72368: LD_ADDR_VAR 0 6
72372: PUSH
72373: LD_EXP 71
72377: PUSH
72378: LD_VAR 0 2
72382: ARRAY
72383: PPUSH
72384: LD_INT 2
72386: PUSH
72387: LD_INT 30
72389: PUSH
72390: LD_INT 32
72392: PUSH
72393: EMPTY
72394: LIST
72395: LIST
72396: PUSH
72397: LD_INT 30
72399: PUSH
72400: LD_INT 33
72402: PUSH
72403: EMPTY
72404: LIST
72405: LIST
72406: PUSH
72407: EMPTY
72408: LIST
72409: LIST
72410: LIST
72411: PPUSH
72412: CALL_OW 72
72416: ST_TO_ADDR
// if not t then
72417: LD_VAR 0 6
72421: NOT
72422: IFFALSE 72426
// continue ;
72424: GO 72283
// for j in tmp do
72426: LD_ADDR_VAR 0 3
72430: PUSH
72431: LD_VAR 0 4
72435: PUSH
72436: FOR_IN
72437: IFFALSE 72467
// if not BuildingStatus ( j ) = bs_idle then
72439: LD_VAR 0 3
72443: PPUSH
72444: CALL_OW 461
72448: PUSH
72449: LD_INT 2
72451: EQUAL
72452: NOT
72453: IFFALSE 72465
// begin busy := true ;
72455: LD_ADDR_VAR 0 8
72459: PUSH
72460: LD_INT 1
72462: ST_TO_ADDR
// break ;
72463: GO 72467
// end ;
72465: GO 72436
72467: POP
72468: POP
// if busy then
72469: LD_VAR 0 8
72473: IFFALSE 72477
// continue ;
72475: GO 72283
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
72477: LD_ADDR_VAR 0 7
72481: PUSH
72482: LD_VAR 0 6
72486: PPUSH
72487: LD_INT 35
72489: PUSH
72490: LD_INT 0
72492: PUSH
72493: EMPTY
72494: LIST
72495: LIST
72496: PPUSH
72497: CALL_OW 72
72501: ST_TO_ADDR
// if tw then
72502: LD_VAR 0 7
72506: IFFALSE 72583
// begin tw := tw [ 1 ] ;
72508: LD_ADDR_VAR 0 7
72512: PUSH
72513: LD_VAR 0 7
72517: PUSH
72518: LD_INT 1
72520: ARRAY
72521: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
72522: LD_ADDR_VAR 0 9
72526: PUSH
72527: LD_VAR 0 7
72531: PPUSH
72532: LD_EXP 88
72536: PUSH
72537: LD_VAR 0 2
72541: ARRAY
72542: PPUSH
72543: CALL 27707 0 2
72547: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
72548: LD_EXP 102
72552: PUSH
72553: LD_VAR 0 2
72557: ARRAY
72558: IFFALSE 72581
// if not weapon in mc_allowed_tower_weapons [ i ] then
72560: LD_VAR 0 9
72564: PUSH
72565: LD_EXP 102
72569: PUSH
72570: LD_VAR 0 2
72574: ARRAY
72575: IN
72576: NOT
72577: IFFALSE 72581
// continue ;
72579: GO 72283
// end else
72581: GO 72646
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
72583: LD_ADDR_VAR 0 5
72587: PUSH
72588: LD_EXP 71
72592: PUSH
72593: LD_VAR 0 2
72597: ARRAY
72598: PPUSH
72599: LD_VAR 0 4
72603: PPUSH
72604: CALL 54619 0 2
72608: ST_TO_ADDR
// if not tmp2 then
72609: LD_VAR 0 5
72613: NOT
72614: IFFALSE 72618
// continue ;
72616: GO 72283
// tw := tmp2 [ 1 ] ;
72618: LD_ADDR_VAR 0 7
72622: PUSH
72623: LD_VAR 0 5
72627: PUSH
72628: LD_INT 1
72630: ARRAY
72631: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
72632: LD_ADDR_VAR 0 9
72636: PUSH
72637: LD_VAR 0 5
72641: PUSH
72642: LD_INT 2
72644: ARRAY
72645: ST_TO_ADDR
// end ; if not weapon then
72646: LD_VAR 0 9
72650: NOT
72651: IFFALSE 72655
// continue ;
72653: GO 72283
// ComPlaceWeapon ( tw , weapon ) ;
72655: LD_VAR 0 7
72659: PPUSH
72660: LD_VAR 0 9
72664: PPUSH
72665: CALL_OW 148
// end ;
72669: GO 72283
72671: POP
72672: POP
// end ;
72673: LD_VAR 0 1
72677: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
72678: LD_INT 0
72680: PPUSH
72681: PPUSH
72682: PPUSH
72683: PPUSH
72684: PPUSH
72685: PPUSH
72686: PPUSH
// if not mc_bases then
72687: LD_EXP 63
72691: NOT
72692: IFFALSE 72696
// exit ;
72694: GO 73471
// for i = 1 to mc_bases do
72696: LD_ADDR_VAR 0 2
72700: PUSH
72701: DOUBLE
72702: LD_INT 1
72704: DEC
72705: ST_TO_ADDR
72706: LD_EXP 63
72710: PUSH
72711: FOR_TO
72712: IFFALSE 73469
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
72714: LD_EXP 76
72718: PUSH
72719: LD_VAR 0 2
72723: ARRAY
72724: NOT
72725: PUSH
72726: LD_EXP 76
72730: PUSH
72731: LD_VAR 0 2
72735: ARRAY
72736: PUSH
72737: LD_EXP 77
72741: PUSH
72742: LD_VAR 0 2
72746: ARRAY
72747: EQUAL
72748: OR
72749: PUSH
72750: LD_EXP 86
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: OR
72761: IFFALSE 72765
// continue ;
72763: GO 72711
// if mc_miners [ i ] then
72765: LD_EXP 77
72769: PUSH
72770: LD_VAR 0 2
72774: ARRAY
72775: IFFALSE 73156
// begin for j = mc_miners [ i ] downto 1 do
72777: LD_ADDR_VAR 0 3
72781: PUSH
72782: DOUBLE
72783: LD_EXP 77
72787: PUSH
72788: LD_VAR 0 2
72792: ARRAY
72793: INC
72794: ST_TO_ADDR
72795: LD_INT 1
72797: PUSH
72798: FOR_DOWNTO
72799: IFFALSE 73154
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
72801: LD_EXP 77
72805: PUSH
72806: LD_VAR 0 2
72810: ARRAY
72811: PUSH
72812: LD_VAR 0 3
72816: ARRAY
72817: PPUSH
72818: CALL_OW 301
72822: PUSH
72823: LD_EXP 77
72827: PUSH
72828: LD_VAR 0 2
72832: ARRAY
72833: PUSH
72834: LD_VAR 0 3
72838: ARRAY
72839: PPUSH
72840: CALL_OW 257
72844: PUSH
72845: LD_INT 1
72847: NONEQUAL
72848: OR
72849: IFFALSE 72912
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
72851: LD_ADDR_VAR 0 5
72855: PUSH
72856: LD_EXP 77
72860: PUSH
72861: LD_VAR 0 2
72865: ARRAY
72866: PUSH
72867: LD_EXP 77
72871: PUSH
72872: LD_VAR 0 2
72876: ARRAY
72877: PUSH
72878: LD_VAR 0 3
72882: ARRAY
72883: DIFF
72884: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
72885: LD_ADDR_EXP 77
72889: PUSH
72890: LD_EXP 77
72894: PPUSH
72895: LD_VAR 0 2
72899: PPUSH
72900: LD_VAR 0 5
72904: PPUSH
72905: CALL_OW 1
72909: ST_TO_ADDR
// continue ;
72910: GO 72798
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
72912: LD_EXP 77
72916: PUSH
72917: LD_VAR 0 2
72921: ARRAY
72922: PUSH
72923: LD_VAR 0 3
72927: ARRAY
72928: PPUSH
72929: CALL_OW 257
72933: PUSH
72934: LD_INT 1
72936: EQUAL
72937: PUSH
72938: LD_EXP 77
72942: PUSH
72943: LD_VAR 0 2
72947: ARRAY
72948: PUSH
72949: LD_VAR 0 3
72953: ARRAY
72954: PPUSH
72955: CALL_OW 459
72959: NOT
72960: AND
72961: PUSH
72962: LD_EXP 77
72966: PUSH
72967: LD_VAR 0 2
72971: ARRAY
72972: PUSH
72973: LD_VAR 0 3
72977: ARRAY
72978: PPUSH
72979: CALL_OW 314
72983: NOT
72984: AND
72985: IFFALSE 73152
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
72987: LD_EXP 77
72991: PUSH
72992: LD_VAR 0 2
72996: ARRAY
72997: PUSH
72998: LD_VAR 0 3
73002: ARRAY
73003: PPUSH
73004: CALL_OW 310
73008: IFFALSE 73031
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
73010: LD_EXP 77
73014: PUSH
73015: LD_VAR 0 2
73019: ARRAY
73020: PUSH
73021: LD_VAR 0 3
73025: ARRAY
73026: PPUSH
73027: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
73031: LD_EXP 77
73035: PUSH
73036: LD_VAR 0 2
73040: ARRAY
73041: PUSH
73042: LD_VAR 0 3
73046: ARRAY
73047: PPUSH
73048: CALL_OW 314
73052: NOT
73053: IFFALSE 73152
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
73055: LD_ADDR_VAR 0 7
73059: PUSH
73060: LD_VAR 0 3
73064: PUSH
73065: LD_EXP 76
73069: PUSH
73070: LD_VAR 0 2
73074: ARRAY
73075: PPUSH
73076: CALL 19462 0 1
73080: MOD
73081: PUSH
73082: LD_INT 1
73084: PLUS
73085: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
73086: LD_EXP 77
73090: PUSH
73091: LD_VAR 0 2
73095: ARRAY
73096: PUSH
73097: LD_VAR 0 3
73101: ARRAY
73102: PPUSH
73103: LD_EXP 76
73107: PUSH
73108: LD_VAR 0 2
73112: ARRAY
73113: PUSH
73114: LD_VAR 0 7
73118: ARRAY
73119: PUSH
73120: LD_INT 1
73122: ARRAY
73123: PPUSH
73124: LD_EXP 76
73128: PUSH
73129: LD_VAR 0 2
73133: ARRAY
73134: PUSH
73135: LD_VAR 0 7
73139: ARRAY
73140: PUSH
73141: LD_INT 2
73143: ARRAY
73144: PPUSH
73145: LD_INT 0
73147: PPUSH
73148: CALL_OW 193
// end ; end ; end ;
73152: GO 72798
73154: POP
73155: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
73156: LD_ADDR_VAR 0 5
73160: PUSH
73161: LD_EXP 63
73165: PUSH
73166: LD_VAR 0 2
73170: ARRAY
73171: PPUSH
73172: LD_INT 2
73174: PUSH
73175: LD_INT 30
73177: PUSH
73178: LD_INT 4
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 30
73187: PUSH
73188: LD_INT 5
73190: PUSH
73191: EMPTY
73192: LIST
73193: LIST
73194: PUSH
73195: LD_INT 30
73197: PUSH
73198: LD_INT 32
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: EMPTY
73206: LIST
73207: LIST
73208: LIST
73209: LIST
73210: PPUSH
73211: CALL_OW 72
73215: ST_TO_ADDR
// if not tmp then
73216: LD_VAR 0 5
73220: NOT
73221: IFFALSE 73225
// continue ;
73223: GO 72711
// list := [ ] ;
73225: LD_ADDR_VAR 0 6
73229: PUSH
73230: EMPTY
73231: ST_TO_ADDR
// for j in tmp do
73232: LD_ADDR_VAR 0 3
73236: PUSH
73237: LD_VAR 0 5
73241: PUSH
73242: FOR_IN
73243: IFFALSE 73312
// begin for k in UnitsInside ( j ) do
73245: LD_ADDR_VAR 0 4
73249: PUSH
73250: LD_VAR 0 3
73254: PPUSH
73255: CALL_OW 313
73259: PUSH
73260: FOR_IN
73261: IFFALSE 73308
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
73263: LD_VAR 0 4
73267: PPUSH
73268: CALL_OW 257
73272: PUSH
73273: LD_INT 1
73275: EQUAL
73276: PUSH
73277: LD_VAR 0 4
73281: PPUSH
73282: CALL_OW 459
73286: NOT
73287: AND
73288: IFFALSE 73306
// list := list ^ k ;
73290: LD_ADDR_VAR 0 6
73294: PUSH
73295: LD_VAR 0 6
73299: PUSH
73300: LD_VAR 0 4
73304: ADD
73305: ST_TO_ADDR
73306: GO 73260
73308: POP
73309: POP
// end ;
73310: GO 73242
73312: POP
73313: POP
// list := list diff mc_miners [ i ] ;
73314: LD_ADDR_VAR 0 6
73318: PUSH
73319: LD_VAR 0 6
73323: PUSH
73324: LD_EXP 77
73328: PUSH
73329: LD_VAR 0 2
73333: ARRAY
73334: DIFF
73335: ST_TO_ADDR
// if not list then
73336: LD_VAR 0 6
73340: NOT
73341: IFFALSE 73345
// continue ;
73343: GO 72711
// k := mc_mines [ i ] - mc_miners [ i ] ;
73345: LD_ADDR_VAR 0 4
73349: PUSH
73350: LD_EXP 76
73354: PUSH
73355: LD_VAR 0 2
73359: ARRAY
73360: PUSH
73361: LD_EXP 77
73365: PUSH
73366: LD_VAR 0 2
73370: ARRAY
73371: MINUS
73372: ST_TO_ADDR
// if k > list then
73373: LD_VAR 0 4
73377: PUSH
73378: LD_VAR 0 6
73382: GREATER
73383: IFFALSE 73395
// k := list ;
73385: LD_ADDR_VAR 0 4
73389: PUSH
73390: LD_VAR 0 6
73394: ST_TO_ADDR
// for j = 1 to k do
73395: LD_ADDR_VAR 0 3
73399: PUSH
73400: DOUBLE
73401: LD_INT 1
73403: DEC
73404: ST_TO_ADDR
73405: LD_VAR 0 4
73409: PUSH
73410: FOR_TO
73411: IFFALSE 73465
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
73413: LD_ADDR_EXP 77
73417: PUSH
73418: LD_EXP 77
73422: PPUSH
73423: LD_VAR 0 2
73427: PUSH
73428: LD_EXP 77
73432: PUSH
73433: LD_VAR 0 2
73437: ARRAY
73438: PUSH
73439: LD_INT 1
73441: PLUS
73442: PUSH
73443: EMPTY
73444: LIST
73445: LIST
73446: PPUSH
73447: LD_VAR 0 6
73451: PUSH
73452: LD_VAR 0 3
73456: ARRAY
73457: PPUSH
73458: CALL 22322 0 3
73462: ST_TO_ADDR
73463: GO 73410
73465: POP
73466: POP
// end ;
73467: GO 72711
73469: POP
73470: POP
// end ;
73471: LD_VAR 0 1
73475: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
73476: LD_INT 0
73478: PPUSH
73479: PPUSH
73480: PPUSH
73481: PPUSH
73482: PPUSH
73483: PPUSH
73484: PPUSH
73485: PPUSH
73486: PPUSH
73487: PPUSH
73488: PPUSH
// if not mc_bases then
73489: LD_EXP 63
73493: NOT
73494: IFFALSE 73498
// exit ;
73496: GO 75321
// for i = 1 to mc_bases do
73498: LD_ADDR_VAR 0 2
73502: PUSH
73503: DOUBLE
73504: LD_INT 1
73506: DEC
73507: ST_TO_ADDR
73508: LD_EXP 63
73512: PUSH
73513: FOR_TO
73514: IFFALSE 75319
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
73516: LD_EXP 63
73520: PUSH
73521: LD_VAR 0 2
73525: ARRAY
73526: NOT
73527: PUSH
73528: LD_EXP 70
73532: PUSH
73533: LD_VAR 0 2
73537: ARRAY
73538: OR
73539: IFFALSE 73543
// continue ;
73541: GO 73513
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
73543: LD_EXP 79
73547: PUSH
73548: LD_VAR 0 2
73552: ARRAY
73553: NOT
73554: PUSH
73555: LD_EXP 80
73559: PUSH
73560: LD_VAR 0 2
73564: ARRAY
73565: AND
73566: IFFALSE 73604
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
73568: LD_ADDR_EXP 80
73572: PUSH
73573: LD_EXP 80
73577: PPUSH
73578: LD_VAR 0 2
73582: PPUSH
73583: EMPTY
73584: PPUSH
73585: CALL_OW 1
73589: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
73590: LD_VAR 0 2
73594: PPUSH
73595: LD_INT 107
73597: PPUSH
73598: CALL 64330 0 2
// continue ;
73602: GO 73513
// end ; target := [ ] ;
73604: LD_ADDR_VAR 0 7
73608: PUSH
73609: EMPTY
73610: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
73611: LD_ADDR_VAR 0 6
73615: PUSH
73616: LD_EXP 63
73620: PUSH
73621: LD_VAR 0 2
73625: ARRAY
73626: PUSH
73627: LD_INT 1
73629: ARRAY
73630: PPUSH
73631: CALL_OW 255
73635: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73636: LD_ADDR_VAR 0 9
73640: PUSH
73641: LD_EXP 63
73645: PUSH
73646: LD_VAR 0 2
73650: ARRAY
73651: PPUSH
73652: LD_INT 2
73654: PUSH
73655: LD_INT 30
73657: PUSH
73658: LD_INT 0
73660: PUSH
73661: EMPTY
73662: LIST
73663: LIST
73664: PUSH
73665: LD_INT 30
73667: PUSH
73668: LD_INT 1
73670: PUSH
73671: EMPTY
73672: LIST
73673: LIST
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: LIST
73679: PPUSH
73680: CALL_OW 72
73684: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
73685: LD_ADDR_VAR 0 3
73689: PUSH
73690: DOUBLE
73691: LD_EXP 79
73695: PUSH
73696: LD_VAR 0 2
73700: ARRAY
73701: INC
73702: ST_TO_ADDR
73703: LD_INT 1
73705: PUSH
73706: FOR_DOWNTO
73707: IFFALSE 73952
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
73709: LD_EXP 79
73713: PUSH
73714: LD_VAR 0 2
73718: ARRAY
73719: PUSH
73720: LD_VAR 0 3
73724: ARRAY
73725: PUSH
73726: LD_INT 2
73728: ARRAY
73729: PPUSH
73730: LD_EXP 79
73734: PUSH
73735: LD_VAR 0 2
73739: ARRAY
73740: PUSH
73741: LD_VAR 0 3
73745: ARRAY
73746: PUSH
73747: LD_INT 3
73749: ARRAY
73750: PPUSH
73751: CALL_OW 488
73755: PUSH
73756: LD_EXP 79
73760: PUSH
73761: LD_VAR 0 2
73765: ARRAY
73766: PUSH
73767: LD_VAR 0 3
73771: ARRAY
73772: PUSH
73773: LD_INT 2
73775: ARRAY
73776: PPUSH
73777: LD_EXP 79
73781: PUSH
73782: LD_VAR 0 2
73786: ARRAY
73787: PUSH
73788: LD_VAR 0 3
73792: ARRAY
73793: PUSH
73794: LD_INT 3
73796: ARRAY
73797: PPUSH
73798: CALL_OW 284
73802: PUSH
73803: LD_INT 0
73805: EQUAL
73806: AND
73807: IFFALSE 73862
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
73809: LD_ADDR_VAR 0 5
73813: PUSH
73814: LD_EXP 79
73818: PUSH
73819: LD_VAR 0 2
73823: ARRAY
73824: PPUSH
73825: LD_VAR 0 3
73829: PPUSH
73830: CALL_OW 3
73834: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
73835: LD_ADDR_EXP 79
73839: PUSH
73840: LD_EXP 79
73844: PPUSH
73845: LD_VAR 0 2
73849: PPUSH
73850: LD_VAR 0 5
73854: PPUSH
73855: CALL_OW 1
73859: ST_TO_ADDR
// continue ;
73860: GO 73706
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
73862: LD_VAR 0 6
73866: PPUSH
73867: LD_EXP 79
73871: PUSH
73872: LD_VAR 0 2
73876: ARRAY
73877: PUSH
73878: LD_VAR 0 3
73882: ARRAY
73883: PUSH
73884: LD_INT 2
73886: ARRAY
73887: PPUSH
73888: LD_EXP 79
73892: PUSH
73893: LD_VAR 0 2
73897: ARRAY
73898: PUSH
73899: LD_VAR 0 3
73903: ARRAY
73904: PUSH
73905: LD_INT 3
73907: ARRAY
73908: PPUSH
73909: LD_INT 30
73911: PPUSH
73912: CALL 23586 0 4
73916: PUSH
73917: LD_INT 4
73919: ARRAY
73920: PUSH
73921: LD_INT 0
73923: EQUAL
73924: IFFALSE 73950
// begin target := mc_crates [ i ] [ j ] ;
73926: LD_ADDR_VAR 0 7
73930: PUSH
73931: LD_EXP 79
73935: PUSH
73936: LD_VAR 0 2
73940: ARRAY
73941: PUSH
73942: LD_VAR 0 3
73946: ARRAY
73947: ST_TO_ADDR
// break ;
73948: GO 73952
// end ; end ;
73950: GO 73706
73952: POP
73953: POP
// if not target then
73954: LD_VAR 0 7
73958: NOT
73959: IFFALSE 73963
// continue ;
73961: GO 73513
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
73963: LD_ADDR_VAR 0 8
73967: PUSH
73968: LD_EXP 82
73972: PUSH
73973: LD_VAR 0 2
73977: ARRAY
73978: PPUSH
73979: LD_INT 2
73981: PUSH
73982: LD_INT 3
73984: PUSH
73985: LD_INT 58
73987: PUSH
73988: EMPTY
73989: LIST
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 61
73997: PUSH
73998: EMPTY
73999: LIST
74000: PUSH
74001: LD_INT 33
74003: PUSH
74004: LD_INT 5
74006: PUSH
74007: EMPTY
74008: LIST
74009: LIST
74010: PUSH
74011: LD_INT 33
74013: PUSH
74014: LD_INT 3
74016: PUSH
74017: EMPTY
74018: LIST
74019: LIST
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: LIST
74025: LIST
74026: LIST
74027: PUSH
74028: LD_INT 2
74030: PUSH
74031: LD_INT 34
74033: PUSH
74034: LD_INT 32
74036: PUSH
74037: EMPTY
74038: LIST
74039: LIST
74040: PUSH
74041: LD_INT 34
74043: PUSH
74044: LD_INT 51
74046: PUSH
74047: EMPTY
74048: LIST
74049: LIST
74050: PUSH
74051: LD_INT 34
74053: PUSH
74054: LD_INT 12
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: PPUSH
74071: CALL_OW 72
74075: ST_TO_ADDR
// if not cargo then
74076: LD_VAR 0 8
74080: NOT
74081: IFFALSE 74787
// begin if mc_crates_collector [ i ] < 5 then
74083: LD_EXP 80
74087: PUSH
74088: LD_VAR 0 2
74092: ARRAY
74093: PUSH
74094: LD_INT 5
74096: LESS
74097: IFFALSE 74463
// begin if mc_ape [ i ] then
74099: LD_EXP 92
74103: PUSH
74104: LD_VAR 0 2
74108: ARRAY
74109: IFFALSE 74156
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
74111: LD_ADDR_VAR 0 5
74115: PUSH
74116: LD_EXP 92
74120: PUSH
74121: LD_VAR 0 2
74125: ARRAY
74126: PPUSH
74127: LD_INT 25
74129: PUSH
74130: LD_INT 16
74132: PUSH
74133: EMPTY
74134: LIST
74135: LIST
74136: PUSH
74137: LD_INT 24
74139: PUSH
74140: LD_INT 750
74142: PUSH
74143: EMPTY
74144: LIST
74145: LIST
74146: PUSH
74147: EMPTY
74148: LIST
74149: LIST
74150: PPUSH
74151: CALL_OW 72
74155: ST_TO_ADDR
// if not tmp then
74156: LD_VAR 0 5
74160: NOT
74161: IFFALSE 74208
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
74163: LD_ADDR_VAR 0 5
74167: PUSH
74168: LD_EXP 63
74172: PUSH
74173: LD_VAR 0 2
74177: ARRAY
74178: PPUSH
74179: LD_INT 25
74181: PUSH
74182: LD_INT 2
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 24
74191: PUSH
74192: LD_INT 750
74194: PUSH
74195: EMPTY
74196: LIST
74197: LIST
74198: PUSH
74199: EMPTY
74200: LIST
74201: LIST
74202: PPUSH
74203: CALL_OW 72
74207: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
74208: LD_EXP 92
74212: PUSH
74213: LD_VAR 0 2
74217: ARRAY
74218: PUSH
74219: LD_EXP 63
74223: PUSH
74224: LD_VAR 0 2
74228: ARRAY
74229: PPUSH
74230: LD_INT 25
74232: PUSH
74233: LD_INT 2
74235: PUSH
74236: EMPTY
74237: LIST
74238: LIST
74239: PUSH
74240: LD_INT 24
74242: PUSH
74243: LD_INT 750
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: EMPTY
74251: LIST
74252: LIST
74253: PPUSH
74254: CALL_OW 72
74258: AND
74259: PUSH
74260: LD_VAR 0 5
74264: PUSH
74265: LD_INT 5
74267: LESS
74268: AND
74269: IFFALSE 74351
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
74271: LD_ADDR_VAR 0 3
74275: PUSH
74276: LD_EXP 63
74280: PUSH
74281: LD_VAR 0 2
74285: ARRAY
74286: PPUSH
74287: LD_INT 25
74289: PUSH
74290: LD_INT 2
74292: PUSH
74293: EMPTY
74294: LIST
74295: LIST
74296: PUSH
74297: LD_INT 24
74299: PUSH
74300: LD_INT 750
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: EMPTY
74308: LIST
74309: LIST
74310: PPUSH
74311: CALL_OW 72
74315: PUSH
74316: FOR_IN
74317: IFFALSE 74349
// begin tmp := tmp union j ;
74319: LD_ADDR_VAR 0 5
74323: PUSH
74324: LD_VAR 0 5
74328: PUSH
74329: LD_VAR 0 3
74333: UNION
74334: ST_TO_ADDR
// if tmp >= 5 then
74335: LD_VAR 0 5
74339: PUSH
74340: LD_INT 5
74342: GREATEREQUAL
74343: IFFALSE 74347
// break ;
74345: GO 74349
// end ;
74347: GO 74316
74349: POP
74350: POP
// end ; if not tmp then
74351: LD_VAR 0 5
74355: NOT
74356: IFFALSE 74360
// continue ;
74358: GO 73513
// for j in tmp do
74360: LD_ADDR_VAR 0 3
74364: PUSH
74365: LD_VAR 0 5
74369: PUSH
74370: FOR_IN
74371: IFFALSE 74461
// if not GetTag ( j ) then
74373: LD_VAR 0 3
74377: PPUSH
74378: CALL_OW 110
74382: NOT
74383: IFFALSE 74459
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
74385: LD_ADDR_EXP 80
74389: PUSH
74390: LD_EXP 80
74394: PPUSH
74395: LD_VAR 0 2
74399: PUSH
74400: LD_EXP 80
74404: PUSH
74405: LD_VAR 0 2
74409: ARRAY
74410: PUSH
74411: LD_INT 1
74413: PLUS
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PPUSH
74419: LD_VAR 0 3
74423: PPUSH
74424: CALL 22322 0 3
74428: ST_TO_ADDR
// SetTag ( j , 107 ) ;
74429: LD_VAR 0 3
74433: PPUSH
74434: LD_INT 107
74436: PPUSH
74437: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
74441: LD_EXP 80
74445: PUSH
74446: LD_VAR 0 2
74450: ARRAY
74451: PUSH
74452: LD_INT 5
74454: GREATEREQUAL
74455: IFFALSE 74459
// break ;
74457: GO 74461
// end ;
74459: GO 74370
74461: POP
74462: POP
// end ; if mc_crates_collector [ i ] and target then
74463: LD_EXP 80
74467: PUSH
74468: LD_VAR 0 2
74472: ARRAY
74473: PUSH
74474: LD_VAR 0 7
74478: AND
74479: IFFALSE 74785
// begin if mc_crates_collector [ i ] < target [ 1 ] then
74481: LD_EXP 80
74485: PUSH
74486: LD_VAR 0 2
74490: ARRAY
74491: PUSH
74492: LD_VAR 0 7
74496: PUSH
74497: LD_INT 1
74499: ARRAY
74500: LESS
74501: IFFALSE 74521
// tmp := mc_crates_collector [ i ] else
74503: LD_ADDR_VAR 0 5
74507: PUSH
74508: LD_EXP 80
74512: PUSH
74513: LD_VAR 0 2
74517: ARRAY
74518: ST_TO_ADDR
74519: GO 74535
// tmp := target [ 1 ] ;
74521: LD_ADDR_VAR 0 5
74525: PUSH
74526: LD_VAR 0 7
74530: PUSH
74531: LD_INT 1
74533: ARRAY
74534: ST_TO_ADDR
// k := 0 ;
74535: LD_ADDR_VAR 0 4
74539: PUSH
74540: LD_INT 0
74542: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
74543: LD_ADDR_VAR 0 3
74547: PUSH
74548: LD_EXP 80
74552: PUSH
74553: LD_VAR 0 2
74557: ARRAY
74558: PUSH
74559: FOR_IN
74560: IFFALSE 74783
// begin k := k + 1 ;
74562: LD_ADDR_VAR 0 4
74566: PUSH
74567: LD_VAR 0 4
74571: PUSH
74572: LD_INT 1
74574: PLUS
74575: ST_TO_ADDR
// if k > tmp then
74576: LD_VAR 0 4
74580: PUSH
74581: LD_VAR 0 5
74585: GREATER
74586: IFFALSE 74590
// break ;
74588: GO 74783
// if not GetClass ( j ) in [ 2 , 16 ] then
74590: LD_VAR 0 3
74594: PPUSH
74595: CALL_OW 257
74599: PUSH
74600: LD_INT 2
74602: PUSH
74603: LD_INT 16
74605: PUSH
74606: EMPTY
74607: LIST
74608: LIST
74609: IN
74610: NOT
74611: IFFALSE 74664
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
74613: LD_ADDR_EXP 80
74617: PUSH
74618: LD_EXP 80
74622: PPUSH
74623: LD_VAR 0 2
74627: PPUSH
74628: LD_EXP 80
74632: PUSH
74633: LD_VAR 0 2
74637: ARRAY
74638: PUSH
74639: LD_VAR 0 3
74643: DIFF
74644: PPUSH
74645: CALL_OW 1
74649: ST_TO_ADDR
// SetTag ( j , 0 ) ;
74650: LD_VAR 0 3
74654: PPUSH
74655: LD_INT 0
74657: PPUSH
74658: CALL_OW 109
// continue ;
74662: GO 74559
// end ; if IsInUnit ( j ) then
74664: LD_VAR 0 3
74668: PPUSH
74669: CALL_OW 310
74673: IFFALSE 74684
// ComExitBuilding ( j ) ;
74675: LD_VAR 0 3
74679: PPUSH
74680: CALL_OW 122
// wait ( 3 ) ;
74684: LD_INT 3
74686: PPUSH
74687: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
74691: LD_VAR 0 3
74695: PPUSH
74696: CALL_OW 314
74700: PUSH
74701: LD_VAR 0 6
74705: PPUSH
74706: LD_VAR 0 7
74710: PUSH
74711: LD_INT 2
74713: ARRAY
74714: PPUSH
74715: LD_VAR 0 7
74719: PUSH
74720: LD_INT 3
74722: ARRAY
74723: PPUSH
74724: LD_INT 30
74726: PPUSH
74727: CALL 23586 0 4
74731: PUSH
74732: LD_INT 4
74734: ARRAY
74735: AND
74736: IFFALSE 74754
// ComStandNearbyBuilding ( j , depot ) else
74738: LD_VAR 0 3
74742: PPUSH
74743: LD_VAR 0 9
74747: PPUSH
74748: CALL 18924 0 2
74752: GO 74781
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
74754: LD_VAR 0 3
74758: PPUSH
74759: LD_VAR 0 7
74763: PUSH
74764: LD_INT 2
74766: ARRAY
74767: PPUSH
74768: LD_VAR 0 7
74772: PUSH
74773: LD_INT 3
74775: ARRAY
74776: PPUSH
74777: CALL_OW 117
// end ;
74781: GO 74559
74783: POP
74784: POP
// end ; end else
74785: GO 75317
// begin for j in cargo do
74787: LD_ADDR_VAR 0 3
74791: PUSH
74792: LD_VAR 0 8
74796: PUSH
74797: FOR_IN
74798: IFFALSE 75315
// begin if GetTag ( j ) <> 0 then
74800: LD_VAR 0 3
74804: PPUSH
74805: CALL_OW 110
74809: PUSH
74810: LD_INT 0
74812: NONEQUAL
74813: IFFALSE 74817
// continue ;
74815: GO 74797
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
74817: LD_VAR 0 3
74821: PPUSH
74822: CALL_OW 256
74826: PUSH
74827: LD_INT 1000
74829: LESS
74830: PUSH
74831: LD_VAR 0 3
74835: PPUSH
74836: LD_EXP 87
74840: PUSH
74841: LD_VAR 0 2
74845: ARRAY
74846: PPUSH
74847: CALL_OW 308
74851: NOT
74852: AND
74853: IFFALSE 74875
// ComMoveToArea ( j , mc_parking [ i ] ) ;
74855: LD_VAR 0 3
74859: PPUSH
74860: LD_EXP 87
74864: PUSH
74865: LD_VAR 0 2
74869: ARRAY
74870: PPUSH
74871: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
74875: LD_VAR 0 3
74879: PPUSH
74880: CALL_OW 256
74884: PUSH
74885: LD_INT 1000
74887: LESS
74888: PUSH
74889: LD_VAR 0 3
74893: PPUSH
74894: LD_EXP 87
74898: PUSH
74899: LD_VAR 0 2
74903: ARRAY
74904: PPUSH
74905: CALL_OW 308
74909: AND
74910: IFFALSE 74914
// continue ;
74912: GO 74797
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
74914: LD_VAR 0 3
74918: PPUSH
74919: CALL_OW 262
74923: PUSH
74924: LD_INT 2
74926: EQUAL
74927: PUSH
74928: LD_VAR 0 3
74932: PPUSH
74933: CALL_OW 261
74937: PUSH
74938: LD_INT 15
74940: LESS
74941: AND
74942: IFFALSE 74946
// continue ;
74944: GO 74797
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
74946: LD_VAR 0 3
74950: PPUSH
74951: CALL_OW 262
74955: PUSH
74956: LD_INT 1
74958: EQUAL
74959: PUSH
74960: LD_VAR 0 3
74964: PPUSH
74965: CALL_OW 261
74969: PUSH
74970: LD_INT 10
74972: LESS
74973: AND
74974: IFFALSE 75254
// begin if not depot then
74976: LD_VAR 0 9
74980: NOT
74981: IFFALSE 74985
// continue ;
74983: GO 74797
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
74985: LD_VAR 0 3
74989: PPUSH
74990: LD_VAR 0 9
74994: PPUSH
74995: LD_VAR 0 3
74999: PPUSH
75000: CALL_OW 74
75004: PPUSH
75005: CALL_OW 296
75009: PUSH
75010: LD_INT 6
75012: LESS
75013: IFFALSE 75029
// SetFuel ( j , 100 ) else
75015: LD_VAR 0 3
75019: PPUSH
75020: LD_INT 100
75022: PPUSH
75023: CALL_OW 240
75027: GO 75254
// if GetFuel ( j ) = 0 then
75029: LD_VAR 0 3
75033: PPUSH
75034: CALL_OW 261
75038: PUSH
75039: LD_INT 0
75041: EQUAL
75042: IFFALSE 75254
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
75044: LD_ADDR_EXP 82
75048: PUSH
75049: LD_EXP 82
75053: PPUSH
75054: LD_VAR 0 2
75058: PPUSH
75059: LD_EXP 82
75063: PUSH
75064: LD_VAR 0 2
75068: ARRAY
75069: PUSH
75070: LD_VAR 0 3
75074: DIFF
75075: PPUSH
75076: CALL_OW 1
75080: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
75081: LD_VAR 0 3
75085: PPUSH
75086: CALL_OW 263
75090: PUSH
75091: LD_INT 1
75093: EQUAL
75094: IFFALSE 75110
// ComExitVehicle ( IsInUnit ( j ) ) ;
75096: LD_VAR 0 3
75100: PPUSH
75101: CALL_OW 310
75105: PPUSH
75106: CALL_OW 121
// if GetControl ( j ) = control_remote then
75110: LD_VAR 0 3
75114: PPUSH
75115: CALL_OW 263
75119: PUSH
75120: LD_INT 2
75122: EQUAL
75123: IFFALSE 75134
// ComUnlink ( j ) ;
75125: LD_VAR 0 3
75129: PPUSH
75130: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
75134: LD_ADDR_VAR 0 10
75138: PUSH
75139: LD_VAR 0 2
75143: PPUSH
75144: LD_INT 3
75146: PPUSH
75147: CALL 84898 0 2
75151: ST_TO_ADDR
// if fac then
75152: LD_VAR 0 10
75156: IFFALSE 75252
// begin for k in fac do
75158: LD_ADDR_VAR 0 4
75162: PUSH
75163: LD_VAR 0 10
75167: PUSH
75168: FOR_IN
75169: IFFALSE 75250
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
75171: LD_ADDR_VAR 0 11
75175: PUSH
75176: LD_VAR 0 10
75180: PPUSH
75181: LD_VAR 0 3
75185: PPUSH
75186: CALL_OW 265
75190: PPUSH
75191: LD_VAR 0 3
75195: PPUSH
75196: CALL_OW 262
75200: PPUSH
75201: LD_VAR 0 3
75205: PPUSH
75206: CALL_OW 263
75210: PPUSH
75211: LD_VAR 0 3
75215: PPUSH
75216: CALL_OW 264
75220: PPUSH
75221: CALL 19820 0 5
75225: ST_TO_ADDR
// if components then
75226: LD_VAR 0 11
75230: IFFALSE 75248
// begin MC_InsertProduceList ( i , components ) ;
75232: LD_VAR 0 2
75236: PPUSH
75237: LD_VAR 0 11
75241: PPUSH
75242: CALL 84443 0 2
// break ;
75246: GO 75250
// end ; end ;
75248: GO 75168
75250: POP
75251: POP
// end ; continue ;
75252: GO 74797
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
75254: LD_VAR 0 3
75258: PPUSH
75259: LD_INT 1
75261: PPUSH
75262: CALL_OW 289
75266: PUSH
75267: LD_INT 100
75269: LESS
75270: PUSH
75271: LD_VAR 0 3
75275: PPUSH
75276: CALL_OW 314
75280: NOT
75281: AND
75282: IFFALSE 75311
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
75284: LD_VAR 0 3
75288: PPUSH
75289: LD_VAR 0 7
75293: PUSH
75294: LD_INT 2
75296: ARRAY
75297: PPUSH
75298: LD_VAR 0 7
75302: PUSH
75303: LD_INT 3
75305: ARRAY
75306: PPUSH
75307: CALL_OW 117
// break ;
75311: GO 75315
// end ;
75313: GO 74797
75315: POP
75316: POP
// end ; end ;
75317: GO 73513
75319: POP
75320: POP
// end ;
75321: LD_VAR 0 1
75325: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
75326: LD_INT 0
75328: PPUSH
75329: PPUSH
75330: PPUSH
75331: PPUSH
// if not mc_bases then
75332: LD_EXP 63
75336: NOT
75337: IFFALSE 75341
// exit ;
75339: GO 75502
// for i = 1 to mc_bases do
75341: LD_ADDR_VAR 0 2
75345: PUSH
75346: DOUBLE
75347: LD_INT 1
75349: DEC
75350: ST_TO_ADDR
75351: LD_EXP 63
75355: PUSH
75356: FOR_TO
75357: IFFALSE 75500
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
75359: LD_ADDR_VAR 0 4
75363: PUSH
75364: LD_EXP 82
75368: PUSH
75369: LD_VAR 0 2
75373: ARRAY
75374: PUSH
75375: LD_EXP 85
75379: PUSH
75380: LD_VAR 0 2
75384: ARRAY
75385: UNION
75386: PPUSH
75387: LD_INT 33
75389: PUSH
75390: LD_INT 2
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: PPUSH
75397: CALL_OW 72
75401: ST_TO_ADDR
// if tmp then
75402: LD_VAR 0 4
75406: IFFALSE 75498
// for j in tmp do
75408: LD_ADDR_VAR 0 3
75412: PUSH
75413: LD_VAR 0 4
75417: PUSH
75418: FOR_IN
75419: IFFALSE 75496
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
75421: LD_VAR 0 3
75425: PPUSH
75426: CALL_OW 312
75430: NOT
75431: PUSH
75432: LD_VAR 0 3
75436: PPUSH
75437: CALL_OW 256
75441: PUSH
75442: LD_INT 250
75444: GREATEREQUAL
75445: AND
75446: IFFALSE 75459
// Connect ( j ) else
75448: LD_VAR 0 3
75452: PPUSH
75453: CALL 25668 0 1
75457: GO 75494
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
75459: LD_VAR 0 3
75463: PPUSH
75464: CALL_OW 256
75468: PUSH
75469: LD_INT 250
75471: LESS
75472: PUSH
75473: LD_VAR 0 3
75477: PPUSH
75478: CALL_OW 312
75482: AND
75483: IFFALSE 75494
// ComUnlink ( j ) ;
75485: LD_VAR 0 3
75489: PPUSH
75490: CALL_OW 136
75494: GO 75418
75496: POP
75497: POP
// end ;
75498: GO 75356
75500: POP
75501: POP
// end ;
75502: LD_VAR 0 1
75506: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
75507: LD_INT 0
75509: PPUSH
75510: PPUSH
75511: PPUSH
75512: PPUSH
75513: PPUSH
// if not mc_bases then
75514: LD_EXP 63
75518: NOT
75519: IFFALSE 75523
// exit ;
75521: GO 75968
// for i = 1 to mc_bases do
75523: LD_ADDR_VAR 0 2
75527: PUSH
75528: DOUBLE
75529: LD_INT 1
75531: DEC
75532: ST_TO_ADDR
75533: LD_EXP 63
75537: PUSH
75538: FOR_TO
75539: IFFALSE 75966
// begin if not mc_produce [ i ] then
75541: LD_EXP 84
75545: PUSH
75546: LD_VAR 0 2
75550: ARRAY
75551: NOT
75552: IFFALSE 75556
// continue ;
75554: GO 75538
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75556: LD_ADDR_VAR 0 5
75560: PUSH
75561: LD_EXP 63
75565: PUSH
75566: LD_VAR 0 2
75570: ARRAY
75571: PPUSH
75572: LD_INT 30
75574: PUSH
75575: LD_INT 3
75577: PUSH
75578: EMPTY
75579: LIST
75580: LIST
75581: PPUSH
75582: CALL_OW 72
75586: ST_TO_ADDR
// if not fac then
75587: LD_VAR 0 5
75591: NOT
75592: IFFALSE 75596
// continue ;
75594: GO 75538
// for j in fac do
75596: LD_ADDR_VAR 0 3
75600: PUSH
75601: LD_VAR 0 5
75605: PUSH
75606: FOR_IN
75607: IFFALSE 75962
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
75609: LD_VAR 0 3
75613: PPUSH
75614: CALL_OW 461
75618: PUSH
75619: LD_INT 2
75621: NONEQUAL
75622: PUSH
75623: LD_VAR 0 3
75627: PPUSH
75628: LD_INT 15
75630: PPUSH
75631: CALL 25287 0 2
75635: PUSH
75636: LD_INT 4
75638: ARRAY
75639: OR
75640: IFFALSE 75644
// continue ;
75642: GO 75606
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
75644: LD_VAR 0 3
75648: PPUSH
75649: LD_EXP 84
75653: PUSH
75654: LD_VAR 0 2
75658: ARRAY
75659: PUSH
75660: LD_INT 1
75662: ARRAY
75663: PUSH
75664: LD_INT 1
75666: ARRAY
75667: PPUSH
75668: LD_EXP 84
75672: PUSH
75673: LD_VAR 0 2
75677: ARRAY
75678: PUSH
75679: LD_INT 1
75681: ARRAY
75682: PUSH
75683: LD_INT 2
75685: ARRAY
75686: PPUSH
75687: LD_EXP 84
75691: PUSH
75692: LD_VAR 0 2
75696: ARRAY
75697: PUSH
75698: LD_INT 1
75700: ARRAY
75701: PUSH
75702: LD_INT 3
75704: ARRAY
75705: PPUSH
75706: LD_EXP 84
75710: PUSH
75711: LD_VAR 0 2
75715: ARRAY
75716: PUSH
75717: LD_INT 1
75719: ARRAY
75720: PUSH
75721: LD_INT 4
75723: ARRAY
75724: PPUSH
75725: CALL_OW 448
75729: PUSH
75730: LD_VAR 0 3
75734: PPUSH
75735: LD_EXP 84
75739: PUSH
75740: LD_VAR 0 2
75744: ARRAY
75745: PUSH
75746: LD_INT 1
75748: ARRAY
75749: PUSH
75750: LD_INT 1
75752: ARRAY
75753: PUSH
75754: LD_EXP 84
75758: PUSH
75759: LD_VAR 0 2
75763: ARRAY
75764: PUSH
75765: LD_INT 1
75767: ARRAY
75768: PUSH
75769: LD_INT 2
75771: ARRAY
75772: PUSH
75773: LD_EXP 84
75777: PUSH
75778: LD_VAR 0 2
75782: ARRAY
75783: PUSH
75784: LD_INT 1
75786: ARRAY
75787: PUSH
75788: LD_INT 3
75790: ARRAY
75791: PUSH
75792: LD_EXP 84
75796: PUSH
75797: LD_VAR 0 2
75801: ARRAY
75802: PUSH
75803: LD_INT 1
75805: ARRAY
75806: PUSH
75807: LD_INT 4
75809: ARRAY
75810: PUSH
75811: EMPTY
75812: LIST
75813: LIST
75814: LIST
75815: LIST
75816: PPUSH
75817: CALL 29063 0 2
75821: AND
75822: IFFALSE 75960
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
75824: LD_VAR 0 3
75828: PPUSH
75829: LD_EXP 84
75833: PUSH
75834: LD_VAR 0 2
75838: ARRAY
75839: PUSH
75840: LD_INT 1
75842: ARRAY
75843: PUSH
75844: LD_INT 1
75846: ARRAY
75847: PPUSH
75848: LD_EXP 84
75852: PUSH
75853: LD_VAR 0 2
75857: ARRAY
75858: PUSH
75859: LD_INT 1
75861: ARRAY
75862: PUSH
75863: LD_INT 2
75865: ARRAY
75866: PPUSH
75867: LD_EXP 84
75871: PUSH
75872: LD_VAR 0 2
75876: ARRAY
75877: PUSH
75878: LD_INT 1
75880: ARRAY
75881: PUSH
75882: LD_INT 3
75884: ARRAY
75885: PPUSH
75886: LD_EXP 84
75890: PUSH
75891: LD_VAR 0 2
75895: ARRAY
75896: PUSH
75897: LD_INT 1
75899: ARRAY
75900: PUSH
75901: LD_INT 4
75903: ARRAY
75904: PPUSH
75905: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
75909: LD_ADDR_VAR 0 4
75913: PUSH
75914: LD_EXP 84
75918: PUSH
75919: LD_VAR 0 2
75923: ARRAY
75924: PPUSH
75925: LD_INT 1
75927: PPUSH
75928: CALL_OW 3
75932: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
75933: LD_ADDR_EXP 84
75937: PUSH
75938: LD_EXP 84
75942: PPUSH
75943: LD_VAR 0 2
75947: PPUSH
75948: LD_VAR 0 4
75952: PPUSH
75953: CALL_OW 1
75957: ST_TO_ADDR
// break ;
75958: GO 75962
// end ; end ;
75960: GO 75606
75962: POP
75963: POP
// end ;
75964: GO 75538
75966: POP
75967: POP
// end ;
75968: LD_VAR 0 1
75972: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
75973: LD_INT 0
75975: PPUSH
75976: PPUSH
75977: PPUSH
// if not mc_bases then
75978: LD_EXP 63
75982: NOT
75983: IFFALSE 75987
// exit ;
75985: GO 76076
// for i = 1 to mc_bases do
75987: LD_ADDR_VAR 0 2
75991: PUSH
75992: DOUBLE
75993: LD_INT 1
75995: DEC
75996: ST_TO_ADDR
75997: LD_EXP 63
76001: PUSH
76002: FOR_TO
76003: IFFALSE 76074
// begin if mc_attack [ i ] then
76005: LD_EXP 83
76009: PUSH
76010: LD_VAR 0 2
76014: ARRAY
76015: IFFALSE 76072
// begin tmp := mc_attack [ i ] [ 1 ] ;
76017: LD_ADDR_VAR 0 3
76021: PUSH
76022: LD_EXP 83
76026: PUSH
76027: LD_VAR 0 2
76031: ARRAY
76032: PUSH
76033: LD_INT 1
76035: ARRAY
76036: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
76037: LD_ADDR_EXP 83
76041: PUSH
76042: LD_EXP 83
76046: PPUSH
76047: LD_VAR 0 2
76051: PPUSH
76052: EMPTY
76053: PPUSH
76054: CALL_OW 1
76058: ST_TO_ADDR
// Attack ( tmp ) ;
76059: LD_VAR 0 3
76063: PPUSH
76064: CALL 112180 0 1
// exit ;
76068: POP
76069: POP
76070: GO 76076
// end ; end ;
76072: GO 76002
76074: POP
76075: POP
// end ;
76076: LD_VAR 0 1
76080: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
76081: LD_INT 0
76083: PPUSH
76084: PPUSH
76085: PPUSH
76086: PPUSH
76087: PPUSH
76088: PPUSH
76089: PPUSH
// if not mc_bases then
76090: LD_EXP 63
76094: NOT
76095: IFFALSE 76099
// exit ;
76097: GO 76956
// for i = 1 to mc_bases do
76099: LD_ADDR_VAR 0 2
76103: PUSH
76104: DOUBLE
76105: LD_INT 1
76107: DEC
76108: ST_TO_ADDR
76109: LD_EXP 63
76113: PUSH
76114: FOR_TO
76115: IFFALSE 76954
// begin if not mc_bases [ i ] then
76117: LD_EXP 63
76121: PUSH
76122: LD_VAR 0 2
76126: ARRAY
76127: NOT
76128: IFFALSE 76132
// continue ;
76130: GO 76114
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
76132: LD_ADDR_VAR 0 7
76136: PUSH
76137: LD_EXP 63
76141: PUSH
76142: LD_VAR 0 2
76146: ARRAY
76147: PUSH
76148: LD_INT 1
76150: ARRAY
76151: PPUSH
76152: CALL 19146 0 1
76156: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
76157: LD_ADDR_EXP 86
76161: PUSH
76162: LD_EXP 86
76166: PPUSH
76167: LD_VAR 0 2
76171: PPUSH
76172: LD_EXP 63
76176: PUSH
76177: LD_VAR 0 2
76181: ARRAY
76182: PUSH
76183: LD_INT 1
76185: ARRAY
76186: PPUSH
76187: CALL_OW 255
76191: PPUSH
76192: LD_EXP 88
76196: PUSH
76197: LD_VAR 0 2
76201: ARRAY
76202: PPUSH
76203: CALL 19111 0 2
76207: PPUSH
76208: CALL_OW 1
76212: ST_TO_ADDR
// if not mc_scan [ i ] then
76213: LD_EXP 86
76217: PUSH
76218: LD_VAR 0 2
76222: ARRAY
76223: NOT
76224: IFFALSE 76402
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
76226: LD_ADDR_EXP 106
76230: PUSH
76231: LD_EXP 106
76235: PPUSH
76236: LD_VAR 0 2
76240: PPUSH
76241: LD_INT 0
76243: PPUSH
76244: CALL_OW 1
76248: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76249: LD_ADDR_VAR 0 4
76253: PUSH
76254: LD_EXP 63
76258: PUSH
76259: LD_VAR 0 2
76263: ARRAY
76264: PPUSH
76265: LD_INT 2
76267: PUSH
76268: LD_INT 25
76270: PUSH
76271: LD_INT 5
76273: PUSH
76274: EMPTY
76275: LIST
76276: LIST
76277: PUSH
76278: LD_INT 25
76280: PUSH
76281: LD_INT 8
76283: PUSH
76284: EMPTY
76285: LIST
76286: LIST
76287: PUSH
76288: LD_INT 25
76290: PUSH
76291: LD_INT 9
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: EMPTY
76299: LIST
76300: LIST
76301: LIST
76302: LIST
76303: PPUSH
76304: CALL_OW 72
76308: ST_TO_ADDR
// if not tmp then
76309: LD_VAR 0 4
76313: NOT
76314: IFFALSE 76318
// continue ;
76316: GO 76114
// for j in tmp do
76318: LD_ADDR_VAR 0 3
76322: PUSH
76323: LD_VAR 0 4
76327: PUSH
76328: FOR_IN
76329: IFFALSE 76400
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
76331: LD_VAR 0 3
76335: PPUSH
76336: CALL_OW 310
76340: PPUSH
76341: CALL_OW 266
76345: PUSH
76346: LD_INT 5
76348: EQUAL
76349: PUSH
76350: LD_VAR 0 3
76354: PPUSH
76355: CALL_OW 257
76359: PUSH
76360: LD_INT 1
76362: EQUAL
76363: AND
76364: PUSH
76365: LD_VAR 0 3
76369: PPUSH
76370: CALL_OW 459
76374: NOT
76375: AND
76376: PUSH
76377: LD_VAR 0 7
76381: AND
76382: IFFALSE 76398
// ComChangeProfession ( j , class ) ;
76384: LD_VAR 0 3
76388: PPUSH
76389: LD_VAR 0 7
76393: PPUSH
76394: CALL_OW 123
76398: GO 76328
76400: POP
76401: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
76402: LD_EXP 86
76406: PUSH
76407: LD_VAR 0 2
76411: ARRAY
76412: PUSH
76413: LD_EXP 106
76417: PUSH
76418: LD_VAR 0 2
76422: ARRAY
76423: NOT
76424: AND
76425: PUSH
76426: LD_EXP 85
76430: PUSH
76431: LD_VAR 0 2
76435: ARRAY
76436: NOT
76437: AND
76438: PUSH
76439: LD_EXP 63
76443: PUSH
76444: LD_VAR 0 2
76448: ARRAY
76449: PPUSH
76450: LD_INT 50
76452: PUSH
76453: EMPTY
76454: LIST
76455: PUSH
76456: LD_INT 2
76458: PUSH
76459: LD_INT 30
76461: PUSH
76462: LD_INT 32
76464: PUSH
76465: EMPTY
76466: LIST
76467: LIST
76468: PUSH
76469: LD_INT 30
76471: PUSH
76472: LD_INT 33
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: PUSH
76479: LD_INT 30
76481: PUSH
76482: LD_INT 4
76484: PUSH
76485: EMPTY
76486: LIST
76487: LIST
76488: PUSH
76489: LD_INT 30
76491: PUSH
76492: LD_INT 5
76494: PUSH
76495: EMPTY
76496: LIST
76497: LIST
76498: PUSH
76499: EMPTY
76500: LIST
76501: LIST
76502: LIST
76503: LIST
76504: LIST
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: PPUSH
76510: CALL_OW 72
76514: PUSH
76515: LD_INT 4
76517: LESS
76518: PUSH
76519: LD_EXP 63
76523: PUSH
76524: LD_VAR 0 2
76528: ARRAY
76529: PPUSH
76530: LD_INT 3
76532: PUSH
76533: LD_INT 24
76535: PUSH
76536: LD_INT 1000
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: EMPTY
76544: LIST
76545: LIST
76546: PUSH
76547: LD_INT 2
76549: PUSH
76550: LD_INT 30
76552: PUSH
76553: LD_INT 0
76555: PUSH
76556: EMPTY
76557: LIST
76558: LIST
76559: PUSH
76560: LD_INT 30
76562: PUSH
76563: LD_INT 1
76565: PUSH
76566: EMPTY
76567: LIST
76568: LIST
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: LIST
76574: PUSH
76575: EMPTY
76576: LIST
76577: LIST
76578: PPUSH
76579: CALL_OW 72
76583: OR
76584: AND
76585: IFFALSE 76836
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76587: LD_ADDR_EXP 106
76591: PUSH
76592: LD_EXP 106
76596: PPUSH
76597: LD_VAR 0 2
76601: PPUSH
76602: LD_INT 1
76604: PPUSH
76605: CALL_OW 1
76609: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
76610: LD_ADDR_VAR 0 4
76614: PUSH
76615: LD_EXP 63
76619: PUSH
76620: LD_VAR 0 2
76624: ARRAY
76625: PPUSH
76626: LD_INT 2
76628: PUSH
76629: LD_INT 25
76631: PUSH
76632: LD_INT 1
76634: PUSH
76635: EMPTY
76636: LIST
76637: LIST
76638: PUSH
76639: LD_INT 25
76641: PUSH
76642: LD_INT 5
76644: PUSH
76645: EMPTY
76646: LIST
76647: LIST
76648: PUSH
76649: LD_INT 25
76651: PUSH
76652: LD_INT 8
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 25
76661: PUSH
76662: LD_INT 9
76664: PUSH
76665: EMPTY
76666: LIST
76667: LIST
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: LIST
76673: LIST
76674: LIST
76675: PPUSH
76676: CALL_OW 72
76680: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
76681: LD_ADDR_VAR 0 4
76685: PUSH
76686: LD_VAR 0 4
76690: PUSH
76691: LD_VAR 0 4
76695: PPUSH
76696: LD_INT 18
76698: PPUSH
76699: CALL 52640 0 2
76703: DIFF
76704: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
76705: LD_VAR 0 4
76709: NOT
76710: PUSH
76711: LD_EXP 63
76715: PUSH
76716: LD_VAR 0 2
76720: ARRAY
76721: PPUSH
76722: LD_INT 2
76724: PUSH
76725: LD_INT 30
76727: PUSH
76728: LD_INT 4
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 30
76737: PUSH
76738: LD_INT 5
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: LIST
76749: PPUSH
76750: CALL_OW 72
76754: NOT
76755: AND
76756: IFFALSE 76818
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
76758: LD_ADDR_VAR 0 4
76762: PUSH
76763: LD_EXP 63
76767: PUSH
76768: LD_VAR 0 2
76772: ARRAY
76773: PPUSH
76774: LD_INT 2
76776: PUSH
76777: LD_INT 25
76779: PUSH
76780: LD_INT 2
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 25
76789: PUSH
76790: LD_INT 3
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 25
76799: PUSH
76800: LD_INT 4
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: EMPTY
76808: LIST
76809: LIST
76810: LIST
76811: LIST
76812: PPUSH
76813: CALL_OW 72
76817: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
76818: LD_VAR 0 2
76822: PPUSH
76823: LD_VAR 0 4
76827: PPUSH
76828: CALL 116889 0 2
// exit ;
76832: POP
76833: POP
76834: GO 76956
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
76836: LD_EXP 86
76840: PUSH
76841: LD_VAR 0 2
76845: ARRAY
76846: PUSH
76847: LD_EXP 106
76851: PUSH
76852: LD_VAR 0 2
76856: ARRAY
76857: NOT
76858: AND
76859: PUSH
76860: LD_EXP 85
76864: PUSH
76865: LD_VAR 0 2
76869: ARRAY
76870: AND
76871: IFFALSE 76952
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
76873: LD_ADDR_EXP 106
76877: PUSH
76878: LD_EXP 106
76882: PPUSH
76883: LD_VAR 0 2
76887: PPUSH
76888: LD_INT 1
76890: PPUSH
76891: CALL_OW 1
76895: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
76896: LD_ADDR_VAR 0 4
76900: PUSH
76901: LD_EXP 85
76905: PUSH
76906: LD_VAR 0 2
76910: ARRAY
76911: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
76912: LD_ADDR_EXP 85
76916: PUSH
76917: LD_EXP 85
76921: PPUSH
76922: LD_VAR 0 2
76926: PPUSH
76927: EMPTY
76928: PPUSH
76929: CALL_OW 1
76933: ST_TO_ADDR
// Defend ( i , tmp ) ;
76934: LD_VAR 0 2
76938: PPUSH
76939: LD_VAR 0 4
76943: PPUSH
76944: CALL 117485 0 2
// exit ;
76948: POP
76949: POP
76950: GO 76956
// end ; end ;
76952: GO 76114
76954: POP
76955: POP
// end ;
76956: LD_VAR 0 1
76960: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
76961: LD_INT 0
76963: PPUSH
76964: PPUSH
76965: PPUSH
76966: PPUSH
76967: PPUSH
76968: PPUSH
76969: PPUSH
76970: PPUSH
76971: PPUSH
76972: PPUSH
76973: PPUSH
// if not mc_bases then
76974: LD_EXP 63
76978: NOT
76979: IFFALSE 76983
// exit ;
76981: GO 78070
// for i = 1 to mc_bases do
76983: LD_ADDR_VAR 0 2
76987: PUSH
76988: DOUBLE
76989: LD_INT 1
76991: DEC
76992: ST_TO_ADDR
76993: LD_EXP 63
76997: PUSH
76998: FOR_TO
76999: IFFALSE 78068
// begin tmp := mc_lab [ i ] ;
77001: LD_ADDR_VAR 0 6
77005: PUSH
77006: LD_EXP 96
77010: PUSH
77011: LD_VAR 0 2
77015: ARRAY
77016: ST_TO_ADDR
// if not tmp then
77017: LD_VAR 0 6
77021: NOT
77022: IFFALSE 77026
// continue ;
77024: GO 76998
// idle_lab := 0 ;
77026: LD_ADDR_VAR 0 11
77030: PUSH
77031: LD_INT 0
77033: ST_TO_ADDR
// for j in tmp do
77034: LD_ADDR_VAR 0 3
77038: PUSH
77039: LD_VAR 0 6
77043: PUSH
77044: FOR_IN
77045: IFFALSE 78064
// begin researching := false ;
77047: LD_ADDR_VAR 0 10
77051: PUSH
77052: LD_INT 0
77054: ST_TO_ADDR
// side := GetSide ( j ) ;
77055: LD_ADDR_VAR 0 4
77059: PUSH
77060: LD_VAR 0 3
77064: PPUSH
77065: CALL_OW 255
77069: ST_TO_ADDR
// if not mc_tech [ side ] then
77070: LD_EXP 90
77074: PUSH
77075: LD_VAR 0 4
77079: ARRAY
77080: NOT
77081: IFFALSE 77085
// continue ;
77083: GO 77044
// if BuildingStatus ( j ) = bs_idle then
77085: LD_VAR 0 3
77089: PPUSH
77090: CALL_OW 461
77094: PUSH
77095: LD_INT 2
77097: EQUAL
77098: IFFALSE 77286
// begin if idle_lab and UnitsInside ( j ) < 6 then
77100: LD_VAR 0 11
77104: PUSH
77105: LD_VAR 0 3
77109: PPUSH
77110: CALL_OW 313
77114: PUSH
77115: LD_INT 6
77117: LESS
77118: AND
77119: IFFALSE 77190
// begin tmp2 := UnitsInside ( idle_lab ) ;
77121: LD_ADDR_VAR 0 9
77125: PUSH
77126: LD_VAR 0 11
77130: PPUSH
77131: CALL_OW 313
77135: ST_TO_ADDR
// if tmp2 then
77136: LD_VAR 0 9
77140: IFFALSE 77182
// for x in tmp2 do
77142: LD_ADDR_VAR 0 7
77146: PUSH
77147: LD_VAR 0 9
77151: PUSH
77152: FOR_IN
77153: IFFALSE 77180
// begin ComExitBuilding ( x ) ;
77155: LD_VAR 0 7
77159: PPUSH
77160: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
77164: LD_VAR 0 7
77168: PPUSH
77169: LD_VAR 0 3
77173: PPUSH
77174: CALL_OW 180
// end ;
77178: GO 77152
77180: POP
77181: POP
// idle_lab := 0 ;
77182: LD_ADDR_VAR 0 11
77186: PUSH
77187: LD_INT 0
77189: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
77190: LD_ADDR_VAR 0 5
77194: PUSH
77195: LD_EXP 90
77199: PUSH
77200: LD_VAR 0 4
77204: ARRAY
77205: PUSH
77206: FOR_IN
77207: IFFALSE 77267
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
77209: LD_VAR 0 3
77213: PPUSH
77214: LD_VAR 0 5
77218: PPUSH
77219: CALL_OW 430
77223: PUSH
77224: LD_VAR 0 4
77228: PPUSH
77229: LD_VAR 0 5
77233: PPUSH
77234: CALL 18216 0 2
77238: AND
77239: IFFALSE 77265
// begin researching := true ;
77241: LD_ADDR_VAR 0 10
77245: PUSH
77246: LD_INT 1
77248: ST_TO_ADDR
// ComResearch ( j , t ) ;
77249: LD_VAR 0 3
77253: PPUSH
77254: LD_VAR 0 5
77258: PPUSH
77259: CALL_OW 124
// break ;
77263: GO 77267
// end ;
77265: GO 77206
77267: POP
77268: POP
// if not researching then
77269: LD_VAR 0 10
77273: NOT
77274: IFFALSE 77286
// idle_lab := j ;
77276: LD_ADDR_VAR 0 11
77280: PUSH
77281: LD_VAR 0 3
77285: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
77286: LD_VAR 0 3
77290: PPUSH
77291: CALL_OW 461
77295: PUSH
77296: LD_INT 10
77298: EQUAL
77299: IFFALSE 77887
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
77301: LD_EXP 92
77305: PUSH
77306: LD_VAR 0 2
77310: ARRAY
77311: NOT
77312: PUSH
77313: LD_EXP 93
77317: PUSH
77318: LD_VAR 0 2
77322: ARRAY
77323: NOT
77324: AND
77325: PUSH
77326: LD_EXP 90
77330: PUSH
77331: LD_VAR 0 4
77335: ARRAY
77336: PUSH
77337: LD_INT 1
77339: GREATER
77340: AND
77341: IFFALSE 77472
// begin ComCancel ( j ) ;
77343: LD_VAR 0 3
77347: PPUSH
77348: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
77352: LD_ADDR_EXP 90
77356: PUSH
77357: LD_EXP 90
77361: PPUSH
77362: LD_VAR 0 4
77366: PPUSH
77367: LD_EXP 90
77371: PUSH
77372: LD_VAR 0 4
77376: ARRAY
77377: PPUSH
77378: LD_EXP 90
77382: PUSH
77383: LD_VAR 0 4
77387: ARRAY
77388: PUSH
77389: LD_INT 1
77391: MINUS
77392: PPUSH
77393: LD_EXP 90
77397: PUSH
77398: LD_VAR 0 4
77402: ARRAY
77403: PPUSH
77404: LD_INT 0
77406: PPUSH
77407: CALL 21740 0 4
77411: PPUSH
77412: CALL_OW 1
77416: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
77417: LD_ADDR_EXP 90
77421: PUSH
77422: LD_EXP 90
77426: PPUSH
77427: LD_VAR 0 4
77431: PPUSH
77432: LD_EXP 90
77436: PUSH
77437: LD_VAR 0 4
77441: ARRAY
77442: PPUSH
77443: LD_EXP 90
77447: PUSH
77448: LD_VAR 0 4
77452: ARRAY
77453: PPUSH
77454: LD_INT 1
77456: PPUSH
77457: LD_INT 0
77459: PPUSH
77460: CALL 21740 0 4
77464: PPUSH
77465: CALL_OW 1
77469: ST_TO_ADDR
// continue ;
77470: GO 77044
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
77472: LD_EXP 92
77476: PUSH
77477: LD_VAR 0 2
77481: ARRAY
77482: PUSH
77483: LD_EXP 93
77487: PUSH
77488: LD_VAR 0 2
77492: ARRAY
77493: NOT
77494: AND
77495: IFFALSE 77622
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
77497: LD_ADDR_EXP 93
77501: PUSH
77502: LD_EXP 93
77506: PPUSH
77507: LD_VAR 0 2
77511: PUSH
77512: LD_EXP 93
77516: PUSH
77517: LD_VAR 0 2
77521: ARRAY
77522: PUSH
77523: LD_INT 1
77525: PLUS
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PPUSH
77531: LD_EXP 92
77535: PUSH
77536: LD_VAR 0 2
77540: ARRAY
77541: PUSH
77542: LD_INT 1
77544: ARRAY
77545: PPUSH
77546: CALL 22322 0 3
77550: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
77551: LD_EXP 92
77555: PUSH
77556: LD_VAR 0 2
77560: ARRAY
77561: PUSH
77562: LD_INT 1
77564: ARRAY
77565: PPUSH
77566: LD_INT 112
77568: PPUSH
77569: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
77573: LD_ADDR_VAR 0 9
77577: PUSH
77578: LD_EXP 92
77582: PUSH
77583: LD_VAR 0 2
77587: ARRAY
77588: PPUSH
77589: LD_INT 1
77591: PPUSH
77592: CALL_OW 3
77596: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
77597: LD_ADDR_EXP 92
77601: PUSH
77602: LD_EXP 92
77606: PPUSH
77607: LD_VAR 0 2
77611: PPUSH
77612: LD_VAR 0 9
77616: PPUSH
77617: CALL_OW 1
77621: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
77622: LD_EXP 92
77626: PUSH
77627: LD_VAR 0 2
77631: ARRAY
77632: PUSH
77633: LD_EXP 93
77637: PUSH
77638: LD_VAR 0 2
77642: ARRAY
77643: AND
77644: PUSH
77645: LD_EXP 93
77649: PUSH
77650: LD_VAR 0 2
77654: ARRAY
77655: PUSH
77656: LD_INT 1
77658: ARRAY
77659: PPUSH
77660: CALL_OW 310
77664: NOT
77665: AND
77666: PUSH
77667: LD_VAR 0 3
77671: PPUSH
77672: CALL_OW 313
77676: PUSH
77677: LD_INT 6
77679: EQUAL
77680: AND
77681: IFFALSE 77737
// begin tmp2 := UnitsInside ( j ) ;
77683: LD_ADDR_VAR 0 9
77687: PUSH
77688: LD_VAR 0 3
77692: PPUSH
77693: CALL_OW 313
77697: ST_TO_ADDR
// if tmp2 = 6 then
77698: LD_VAR 0 9
77702: PUSH
77703: LD_INT 6
77705: EQUAL
77706: IFFALSE 77737
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
77708: LD_VAR 0 9
77712: PUSH
77713: LD_INT 1
77715: ARRAY
77716: PPUSH
77717: LD_INT 112
77719: PPUSH
77720: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
77724: LD_VAR 0 9
77728: PUSH
77729: LD_INT 1
77731: ARRAY
77732: PPUSH
77733: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
77737: LD_EXP 93
77741: PUSH
77742: LD_VAR 0 2
77746: ARRAY
77747: PUSH
77748: LD_EXP 93
77752: PUSH
77753: LD_VAR 0 2
77757: ARRAY
77758: PUSH
77759: LD_INT 1
77761: ARRAY
77762: PPUSH
77763: CALL_OW 314
77767: NOT
77768: AND
77769: PUSH
77770: LD_EXP 93
77774: PUSH
77775: LD_VAR 0 2
77779: ARRAY
77780: PUSH
77781: LD_INT 1
77783: ARRAY
77784: PPUSH
77785: CALL_OW 310
77789: NOT
77790: AND
77791: IFFALSE 77817
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
77793: LD_EXP 93
77797: PUSH
77798: LD_VAR 0 2
77802: ARRAY
77803: PUSH
77804: LD_INT 1
77806: ARRAY
77807: PPUSH
77808: LD_VAR 0 3
77812: PPUSH
77813: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
77817: LD_EXP 93
77821: PUSH
77822: LD_VAR 0 2
77826: ARRAY
77827: PUSH
77828: LD_INT 1
77830: ARRAY
77831: PPUSH
77832: CALL_OW 310
77836: PUSH
77837: LD_EXP 93
77841: PUSH
77842: LD_VAR 0 2
77846: ARRAY
77847: PUSH
77848: LD_INT 1
77850: ARRAY
77851: PPUSH
77852: CALL_OW 310
77856: PPUSH
77857: CALL_OW 461
77861: PUSH
77862: LD_INT 3
77864: NONEQUAL
77865: AND
77866: IFFALSE 77887
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
77868: LD_EXP 93
77872: PUSH
77873: LD_VAR 0 2
77877: ARRAY
77878: PUSH
77879: LD_INT 1
77881: ARRAY
77882: PPUSH
77883: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
77887: LD_VAR 0 3
77891: PPUSH
77892: CALL_OW 461
77896: PUSH
77897: LD_INT 6
77899: EQUAL
77900: PUSH
77901: LD_VAR 0 6
77905: PUSH
77906: LD_INT 1
77908: GREATER
77909: AND
77910: IFFALSE 78062
// begin sci := [ ] ;
77912: LD_ADDR_VAR 0 8
77916: PUSH
77917: EMPTY
77918: ST_TO_ADDR
// for x in ( tmp diff j ) do
77919: LD_ADDR_VAR 0 7
77923: PUSH
77924: LD_VAR 0 6
77928: PUSH
77929: LD_VAR 0 3
77933: DIFF
77934: PUSH
77935: FOR_IN
77936: IFFALSE 77988
// begin if sci = 6 then
77938: LD_VAR 0 8
77942: PUSH
77943: LD_INT 6
77945: EQUAL
77946: IFFALSE 77950
// break ;
77948: GO 77988
// if BuildingStatus ( x ) = bs_idle then
77950: LD_VAR 0 7
77954: PPUSH
77955: CALL_OW 461
77959: PUSH
77960: LD_INT 2
77962: EQUAL
77963: IFFALSE 77986
// sci := sci ^ UnitsInside ( x ) ;
77965: LD_ADDR_VAR 0 8
77969: PUSH
77970: LD_VAR 0 8
77974: PUSH
77975: LD_VAR 0 7
77979: PPUSH
77980: CALL_OW 313
77984: ADD
77985: ST_TO_ADDR
// end ;
77986: GO 77935
77988: POP
77989: POP
// if not sci then
77990: LD_VAR 0 8
77994: NOT
77995: IFFALSE 77999
// continue ;
77997: GO 77044
// for x in sci do
77999: LD_ADDR_VAR 0 7
78003: PUSH
78004: LD_VAR 0 8
78008: PUSH
78009: FOR_IN
78010: IFFALSE 78060
// if IsInUnit ( x ) and not HasTask ( x ) then
78012: LD_VAR 0 7
78016: PPUSH
78017: CALL_OW 310
78021: PUSH
78022: LD_VAR 0 7
78026: PPUSH
78027: CALL_OW 314
78031: NOT
78032: AND
78033: IFFALSE 78058
// begin ComExitBuilding ( x ) ;
78035: LD_VAR 0 7
78039: PPUSH
78040: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
78044: LD_VAR 0 7
78048: PPUSH
78049: LD_VAR 0 3
78053: PPUSH
78054: CALL_OW 180
// end ;
78058: GO 78009
78060: POP
78061: POP
// end ; end ;
78062: GO 77044
78064: POP
78065: POP
// end ;
78066: GO 76998
78068: POP
78069: POP
// end ;
78070: LD_VAR 0 1
78074: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
78075: LD_INT 0
78077: PPUSH
78078: PPUSH
// if not mc_bases then
78079: LD_EXP 63
78083: NOT
78084: IFFALSE 78088
// exit ;
78086: GO 78169
// for i = 1 to mc_bases do
78088: LD_ADDR_VAR 0 2
78092: PUSH
78093: DOUBLE
78094: LD_INT 1
78096: DEC
78097: ST_TO_ADDR
78098: LD_EXP 63
78102: PUSH
78103: FOR_TO
78104: IFFALSE 78167
// if mc_mines [ i ] and mc_miners [ i ] then
78106: LD_EXP 76
78110: PUSH
78111: LD_VAR 0 2
78115: ARRAY
78116: PUSH
78117: LD_EXP 77
78121: PUSH
78122: LD_VAR 0 2
78126: ARRAY
78127: AND
78128: IFFALSE 78165
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
78130: LD_EXP 77
78134: PUSH
78135: LD_VAR 0 2
78139: ARRAY
78140: PUSH
78141: LD_INT 1
78143: ARRAY
78144: PPUSH
78145: CALL_OW 255
78149: PPUSH
78150: LD_EXP 76
78154: PUSH
78155: LD_VAR 0 2
78159: ARRAY
78160: PPUSH
78161: CALL 19299 0 2
78165: GO 78103
78167: POP
78168: POP
// end ;
78169: LD_VAR 0 1
78173: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
78174: LD_INT 0
78176: PPUSH
78177: PPUSH
78178: PPUSH
78179: PPUSH
78180: PPUSH
78181: PPUSH
78182: PPUSH
78183: PPUSH
// if not mc_bases or not mc_parking then
78184: LD_EXP 63
78188: NOT
78189: PUSH
78190: LD_EXP 87
78194: NOT
78195: OR
78196: IFFALSE 78200
// exit ;
78198: GO 78938
// for i = 1 to mc_bases do
78200: LD_ADDR_VAR 0 2
78204: PUSH
78205: DOUBLE
78206: LD_INT 1
78208: DEC
78209: ST_TO_ADDR
78210: LD_EXP 63
78214: PUSH
78215: FOR_TO
78216: IFFALSE 78936
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
78218: LD_EXP 63
78222: PUSH
78223: LD_VAR 0 2
78227: ARRAY
78228: NOT
78229: PUSH
78230: LD_EXP 87
78234: PUSH
78235: LD_VAR 0 2
78239: ARRAY
78240: NOT
78241: OR
78242: IFFALSE 78246
// continue ;
78244: GO 78215
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
78246: LD_ADDR_VAR 0 5
78250: PUSH
78251: LD_EXP 63
78255: PUSH
78256: LD_VAR 0 2
78260: ARRAY
78261: PUSH
78262: LD_INT 1
78264: ARRAY
78265: PPUSH
78266: CALL_OW 255
78270: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78271: LD_ADDR_VAR 0 6
78275: PUSH
78276: LD_EXP 63
78280: PUSH
78281: LD_VAR 0 2
78285: ARRAY
78286: PPUSH
78287: LD_INT 30
78289: PUSH
78290: LD_INT 3
78292: PUSH
78293: EMPTY
78294: LIST
78295: LIST
78296: PPUSH
78297: CALL_OW 72
78301: ST_TO_ADDR
// if not fac then
78302: LD_VAR 0 6
78306: NOT
78307: IFFALSE 78358
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78309: LD_ADDR_VAR 0 6
78313: PUSH
78314: LD_EXP 63
78318: PUSH
78319: LD_VAR 0 2
78323: ARRAY
78324: PPUSH
78325: LD_INT 2
78327: PUSH
78328: LD_INT 30
78330: PUSH
78331: LD_INT 0
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 30
78340: PUSH
78341: LD_INT 1
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: EMPTY
78349: LIST
78350: LIST
78351: LIST
78352: PPUSH
78353: CALL_OW 72
78357: ST_TO_ADDR
// if not fac then
78358: LD_VAR 0 6
78362: NOT
78363: IFFALSE 78367
// continue ;
78365: GO 78215
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78367: LD_ADDR_VAR 0 7
78371: PUSH
78372: LD_EXP 87
78376: PUSH
78377: LD_VAR 0 2
78381: ARRAY
78382: PPUSH
78383: LD_INT 22
78385: PUSH
78386: LD_VAR 0 5
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 21
78397: PUSH
78398: LD_INT 2
78400: PUSH
78401: EMPTY
78402: LIST
78403: LIST
78404: PUSH
78405: LD_INT 3
78407: PUSH
78408: LD_INT 60
78410: PUSH
78411: EMPTY
78412: LIST
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 3
78420: PUSH
78421: LD_INT 24
78423: PUSH
78424: LD_INT 1000
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: EMPTY
78432: LIST
78433: LIST
78434: PUSH
78435: EMPTY
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: PPUSH
78441: CALL_OW 70
78445: ST_TO_ADDR
// for j in fac do
78446: LD_ADDR_VAR 0 3
78450: PUSH
78451: LD_VAR 0 6
78455: PUSH
78456: FOR_IN
78457: IFFALSE 78552
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
78459: LD_ADDR_VAR 0 7
78463: PUSH
78464: LD_VAR 0 7
78468: PUSH
78469: LD_INT 22
78471: PUSH
78472: LD_VAR 0 5
78476: PUSH
78477: EMPTY
78478: LIST
78479: LIST
78480: PUSH
78481: LD_INT 91
78483: PUSH
78484: LD_VAR 0 3
78488: PUSH
78489: LD_INT 15
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: LIST
78496: PUSH
78497: LD_INT 21
78499: PUSH
78500: LD_INT 2
78502: PUSH
78503: EMPTY
78504: LIST
78505: LIST
78506: PUSH
78507: LD_INT 3
78509: PUSH
78510: LD_INT 60
78512: PUSH
78513: EMPTY
78514: LIST
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 3
78522: PUSH
78523: LD_INT 24
78525: PUSH
78526: LD_INT 1000
78528: PUSH
78529: EMPTY
78530: LIST
78531: LIST
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: EMPTY
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: PPUSH
78544: CALL_OW 69
78548: UNION
78549: ST_TO_ADDR
78550: GO 78456
78552: POP
78553: POP
// if not vehs then
78554: LD_VAR 0 7
78558: NOT
78559: IFFALSE 78585
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
78561: LD_ADDR_EXP 75
78565: PUSH
78566: LD_EXP 75
78570: PPUSH
78571: LD_VAR 0 2
78575: PPUSH
78576: EMPTY
78577: PPUSH
78578: CALL_OW 1
78582: ST_TO_ADDR
// continue ;
78583: GO 78215
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
78585: LD_ADDR_VAR 0 8
78589: PUSH
78590: LD_EXP 63
78594: PUSH
78595: LD_VAR 0 2
78599: ARRAY
78600: PPUSH
78601: LD_INT 30
78603: PUSH
78604: LD_INT 3
78606: PUSH
78607: EMPTY
78608: LIST
78609: LIST
78610: PPUSH
78611: CALL_OW 72
78615: ST_TO_ADDR
// if tmp then
78616: LD_VAR 0 8
78620: IFFALSE 78723
// begin for j in tmp do
78622: LD_ADDR_VAR 0 3
78626: PUSH
78627: LD_VAR 0 8
78631: PUSH
78632: FOR_IN
78633: IFFALSE 78721
// for k in UnitsInside ( j ) do
78635: LD_ADDR_VAR 0 4
78639: PUSH
78640: LD_VAR 0 3
78644: PPUSH
78645: CALL_OW 313
78649: PUSH
78650: FOR_IN
78651: IFFALSE 78717
// if k then
78653: LD_VAR 0 4
78657: IFFALSE 78715
// if not k in mc_repair_vehicle [ i ] then
78659: LD_VAR 0 4
78663: PUSH
78664: LD_EXP 75
78668: PUSH
78669: LD_VAR 0 2
78673: ARRAY
78674: IN
78675: NOT
78676: IFFALSE 78715
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
78678: LD_ADDR_EXP 75
78682: PUSH
78683: LD_EXP 75
78687: PPUSH
78688: LD_VAR 0 2
78692: PPUSH
78693: LD_EXP 75
78697: PUSH
78698: LD_VAR 0 2
78702: ARRAY
78703: PUSH
78704: LD_VAR 0 4
78708: UNION
78709: PPUSH
78710: CALL_OW 1
78714: ST_TO_ADDR
78715: GO 78650
78717: POP
78718: POP
78719: GO 78632
78721: POP
78722: POP
// end ; if not mc_repair_vehicle [ i ] then
78723: LD_EXP 75
78727: PUSH
78728: LD_VAR 0 2
78732: ARRAY
78733: NOT
78734: IFFALSE 78738
// continue ;
78736: GO 78215
// for j in mc_repair_vehicle [ i ] do
78738: LD_ADDR_VAR 0 3
78742: PUSH
78743: LD_EXP 75
78747: PUSH
78748: LD_VAR 0 2
78752: ARRAY
78753: PUSH
78754: FOR_IN
78755: IFFALSE 78932
// begin if GetClass ( j ) <> 3 then
78757: LD_VAR 0 3
78761: PPUSH
78762: CALL_OW 257
78766: PUSH
78767: LD_INT 3
78769: NONEQUAL
78770: IFFALSE 78811
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
78772: LD_ADDR_EXP 75
78776: PUSH
78777: LD_EXP 75
78781: PPUSH
78782: LD_VAR 0 2
78786: PPUSH
78787: LD_EXP 75
78791: PUSH
78792: LD_VAR 0 2
78796: ARRAY
78797: PUSH
78798: LD_VAR 0 3
78802: DIFF
78803: PPUSH
78804: CALL_OW 1
78808: ST_TO_ADDR
// continue ;
78809: GO 78754
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
78811: LD_VAR 0 3
78815: PPUSH
78816: CALL_OW 311
78820: NOT
78821: PUSH
78822: LD_VAR 0 3
78826: PUSH
78827: LD_EXP 66
78831: PUSH
78832: LD_VAR 0 2
78836: ARRAY
78837: PUSH
78838: LD_INT 1
78840: ARRAY
78841: IN
78842: NOT
78843: AND
78844: PUSH
78845: LD_VAR 0 3
78849: PUSH
78850: LD_EXP 66
78854: PUSH
78855: LD_VAR 0 2
78859: ARRAY
78860: PUSH
78861: LD_INT 2
78863: ARRAY
78864: IN
78865: NOT
78866: AND
78867: IFFALSE 78930
// begin if IsInUnit ( j ) then
78869: LD_VAR 0 3
78873: PPUSH
78874: CALL_OW 310
78878: IFFALSE 78891
// ComExitBuilding ( j ) else
78880: LD_VAR 0 3
78884: PPUSH
78885: CALL_OW 122
78889: GO 78930
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
78891: LD_VAR 0 3
78895: PPUSH
78896: LD_VAR 0 7
78900: PUSH
78901: LD_INT 1
78903: ARRAY
78904: PPUSH
78905: CALL 57136 0 2
78909: NOT
78910: IFFALSE 78930
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
78912: LD_VAR 0 3
78916: PPUSH
78917: LD_VAR 0 7
78921: PUSH
78922: LD_INT 1
78924: ARRAY
78925: PPUSH
78926: CALL_OW 129
// end ; end ;
78930: GO 78754
78932: POP
78933: POP
// end ;
78934: GO 78215
78936: POP
78937: POP
// end ;
78938: LD_VAR 0 1
78942: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
78943: LD_INT 0
78945: PPUSH
78946: PPUSH
78947: PPUSH
78948: PPUSH
78949: PPUSH
78950: PPUSH
78951: PPUSH
78952: PPUSH
78953: PPUSH
78954: PPUSH
78955: PPUSH
// if not mc_bases then
78956: LD_EXP 63
78960: NOT
78961: IFFALSE 78965
// exit ;
78963: GO 79767
// for i = 1 to mc_bases do
78965: LD_ADDR_VAR 0 2
78969: PUSH
78970: DOUBLE
78971: LD_INT 1
78973: DEC
78974: ST_TO_ADDR
78975: LD_EXP 63
78979: PUSH
78980: FOR_TO
78981: IFFALSE 79765
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
78983: LD_EXP 91
78987: PUSH
78988: LD_VAR 0 2
78992: ARRAY
78993: NOT
78994: PUSH
78995: LD_EXP 66
78999: PUSH
79000: LD_VAR 0 2
79004: ARRAY
79005: PUSH
79006: LD_INT 1
79008: ARRAY
79009: OR
79010: PUSH
79011: LD_EXP 66
79015: PUSH
79016: LD_VAR 0 2
79020: ARRAY
79021: PUSH
79022: LD_INT 2
79024: ARRAY
79025: OR
79026: PUSH
79027: LD_EXP 89
79031: PUSH
79032: LD_VAR 0 2
79036: ARRAY
79037: PPUSH
79038: LD_INT 1
79040: PPUSH
79041: CALL_OW 325
79045: NOT
79046: OR
79047: PUSH
79048: LD_EXP 86
79052: PUSH
79053: LD_VAR 0 2
79057: ARRAY
79058: OR
79059: IFFALSE 79063
// continue ;
79061: GO 78980
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
79063: LD_ADDR_VAR 0 8
79067: PUSH
79068: LD_EXP 63
79072: PUSH
79073: LD_VAR 0 2
79077: ARRAY
79078: PPUSH
79079: LD_INT 25
79081: PUSH
79082: LD_INT 4
79084: PUSH
79085: EMPTY
79086: LIST
79087: LIST
79088: PUSH
79089: LD_INT 50
79091: PUSH
79092: EMPTY
79093: LIST
79094: PUSH
79095: LD_INT 3
79097: PUSH
79098: LD_INT 60
79100: PUSH
79101: EMPTY
79102: LIST
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: EMPTY
79109: LIST
79110: LIST
79111: LIST
79112: PPUSH
79113: CALL_OW 72
79117: PUSH
79118: LD_EXP 67
79122: PUSH
79123: LD_VAR 0 2
79127: ARRAY
79128: DIFF
79129: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79130: LD_ADDR_VAR 0 9
79134: PUSH
79135: LD_EXP 63
79139: PUSH
79140: LD_VAR 0 2
79144: ARRAY
79145: PPUSH
79146: LD_INT 2
79148: PUSH
79149: LD_INT 30
79151: PUSH
79152: LD_INT 0
79154: PUSH
79155: EMPTY
79156: LIST
79157: LIST
79158: PUSH
79159: LD_INT 30
79161: PUSH
79162: LD_INT 1
79164: PUSH
79165: EMPTY
79166: LIST
79167: LIST
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: LIST
79173: PPUSH
79174: CALL_OW 72
79178: ST_TO_ADDR
// if not tmp or not dep then
79179: LD_VAR 0 8
79183: NOT
79184: PUSH
79185: LD_VAR 0 9
79189: NOT
79190: OR
79191: IFFALSE 79195
// continue ;
79193: GO 78980
// side := GetSide ( tmp [ 1 ] ) ;
79195: LD_ADDR_VAR 0 11
79199: PUSH
79200: LD_VAR 0 8
79204: PUSH
79205: LD_INT 1
79207: ARRAY
79208: PPUSH
79209: CALL_OW 255
79213: ST_TO_ADDR
// dep := dep [ 1 ] ;
79214: LD_ADDR_VAR 0 9
79218: PUSH
79219: LD_VAR 0 9
79223: PUSH
79224: LD_INT 1
79226: ARRAY
79227: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
79228: LD_ADDR_VAR 0 7
79232: PUSH
79233: LD_EXP 91
79237: PUSH
79238: LD_VAR 0 2
79242: ARRAY
79243: PPUSH
79244: LD_INT 22
79246: PUSH
79247: LD_INT 0
79249: PUSH
79250: EMPTY
79251: LIST
79252: LIST
79253: PUSH
79254: LD_INT 25
79256: PUSH
79257: LD_INT 12
79259: PUSH
79260: EMPTY
79261: LIST
79262: LIST
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PPUSH
79268: CALL_OW 70
79272: PUSH
79273: LD_INT 22
79275: PUSH
79276: LD_INT 0
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 25
79285: PUSH
79286: LD_INT 12
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 91
79295: PUSH
79296: LD_VAR 0 9
79300: PUSH
79301: LD_INT 20
79303: PUSH
79304: EMPTY
79305: LIST
79306: LIST
79307: LIST
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: LIST
79313: PPUSH
79314: CALL_OW 69
79318: UNION
79319: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
79320: LD_ADDR_VAR 0 10
79324: PUSH
79325: LD_EXP 91
79329: PUSH
79330: LD_VAR 0 2
79334: ARRAY
79335: PPUSH
79336: LD_INT 81
79338: PUSH
79339: LD_VAR 0 11
79343: PUSH
79344: EMPTY
79345: LIST
79346: LIST
79347: PPUSH
79348: CALL_OW 70
79352: ST_TO_ADDR
// if not apes or danger_at_area then
79353: LD_VAR 0 7
79357: NOT
79358: PUSH
79359: LD_VAR 0 10
79363: OR
79364: IFFALSE 79414
// begin if mc_taming [ i ] then
79366: LD_EXP 94
79370: PUSH
79371: LD_VAR 0 2
79375: ARRAY
79376: IFFALSE 79412
// begin MC_Reset ( i , 121 ) ;
79378: LD_VAR 0 2
79382: PPUSH
79383: LD_INT 121
79385: PPUSH
79386: CALL 64330 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
79390: LD_ADDR_EXP 94
79394: PUSH
79395: LD_EXP 94
79399: PPUSH
79400: LD_VAR 0 2
79404: PPUSH
79405: EMPTY
79406: PPUSH
79407: CALL_OW 1
79411: ST_TO_ADDR
// end ; continue ;
79412: GO 78980
// end ; for j in tmp do
79414: LD_ADDR_VAR 0 3
79418: PUSH
79419: LD_VAR 0 8
79423: PUSH
79424: FOR_IN
79425: IFFALSE 79761
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
79427: LD_VAR 0 3
79431: PUSH
79432: LD_EXP 94
79436: PUSH
79437: LD_VAR 0 2
79441: ARRAY
79442: IN
79443: NOT
79444: PUSH
79445: LD_EXP 94
79449: PUSH
79450: LD_VAR 0 2
79454: ARRAY
79455: PUSH
79456: LD_INT 3
79458: LESS
79459: AND
79460: IFFALSE 79518
// begin SetTag ( j , 121 ) ;
79462: LD_VAR 0 3
79466: PPUSH
79467: LD_INT 121
79469: PPUSH
79470: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
79474: LD_ADDR_EXP 94
79478: PUSH
79479: LD_EXP 94
79483: PPUSH
79484: LD_VAR 0 2
79488: PUSH
79489: LD_EXP 94
79493: PUSH
79494: LD_VAR 0 2
79498: ARRAY
79499: PUSH
79500: LD_INT 1
79502: PLUS
79503: PUSH
79504: EMPTY
79505: LIST
79506: LIST
79507: PPUSH
79508: LD_VAR 0 3
79512: PPUSH
79513: CALL 22322 0 3
79517: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
79518: LD_VAR 0 3
79522: PUSH
79523: LD_EXP 94
79527: PUSH
79528: LD_VAR 0 2
79532: ARRAY
79533: IN
79534: IFFALSE 79759
// begin if GetClass ( j ) <> 4 then
79536: LD_VAR 0 3
79540: PPUSH
79541: CALL_OW 257
79545: PUSH
79546: LD_INT 4
79548: NONEQUAL
79549: IFFALSE 79602
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
79551: LD_ADDR_EXP 94
79555: PUSH
79556: LD_EXP 94
79560: PPUSH
79561: LD_VAR 0 2
79565: PPUSH
79566: LD_EXP 94
79570: PUSH
79571: LD_VAR 0 2
79575: ARRAY
79576: PUSH
79577: LD_VAR 0 3
79581: DIFF
79582: PPUSH
79583: CALL_OW 1
79587: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79588: LD_VAR 0 3
79592: PPUSH
79593: LD_INT 0
79595: PPUSH
79596: CALL_OW 109
// continue ;
79600: GO 79424
// end ; if IsInUnit ( j ) then
79602: LD_VAR 0 3
79606: PPUSH
79607: CALL_OW 310
79611: IFFALSE 79622
// ComExitBuilding ( j ) ;
79613: LD_VAR 0 3
79617: PPUSH
79618: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
79622: LD_ADDR_VAR 0 6
79626: PUSH
79627: LD_VAR 0 7
79631: PPUSH
79632: LD_VAR 0 3
79636: PPUSH
79637: CALL_OW 74
79641: ST_TO_ADDR
// if not ape then
79642: LD_VAR 0 6
79646: NOT
79647: IFFALSE 79651
// break ;
79649: GO 79761
// x := GetX ( ape ) ;
79651: LD_ADDR_VAR 0 4
79655: PUSH
79656: LD_VAR 0 6
79660: PPUSH
79661: CALL_OW 250
79665: ST_TO_ADDR
// y := GetY ( ape ) ;
79666: LD_ADDR_VAR 0 5
79670: PUSH
79671: LD_VAR 0 6
79675: PPUSH
79676: CALL_OW 251
79680: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
79681: LD_VAR 0 4
79685: PPUSH
79686: LD_VAR 0 5
79690: PPUSH
79691: CALL_OW 488
79695: NOT
79696: PUSH
79697: LD_VAR 0 11
79701: PPUSH
79702: LD_VAR 0 4
79706: PPUSH
79707: LD_VAR 0 5
79711: PPUSH
79712: LD_INT 20
79714: PPUSH
79715: CALL 23586 0 4
79719: PUSH
79720: LD_INT 4
79722: ARRAY
79723: OR
79724: IFFALSE 79728
// break ;
79726: GO 79761
// if not HasTask ( j ) then
79728: LD_VAR 0 3
79732: PPUSH
79733: CALL_OW 314
79737: NOT
79738: IFFALSE 79759
// ComTameXY ( j , x , y ) ;
79740: LD_VAR 0 3
79744: PPUSH
79745: LD_VAR 0 4
79749: PPUSH
79750: LD_VAR 0 5
79754: PPUSH
79755: CALL_OW 131
// end ; end ;
79759: GO 79424
79761: POP
79762: POP
// end ;
79763: GO 78980
79765: POP
79766: POP
// end ;
79767: LD_VAR 0 1
79771: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
79772: LD_INT 0
79774: PPUSH
79775: PPUSH
79776: PPUSH
79777: PPUSH
79778: PPUSH
79779: PPUSH
79780: PPUSH
79781: PPUSH
// if not mc_bases then
79782: LD_EXP 63
79786: NOT
79787: IFFALSE 79791
// exit ;
79789: GO 80417
// for i = 1 to mc_bases do
79791: LD_ADDR_VAR 0 2
79795: PUSH
79796: DOUBLE
79797: LD_INT 1
79799: DEC
79800: ST_TO_ADDR
79801: LD_EXP 63
79805: PUSH
79806: FOR_TO
79807: IFFALSE 80415
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
79809: LD_EXP 92
79813: PUSH
79814: LD_VAR 0 2
79818: ARRAY
79819: NOT
79820: PUSH
79821: LD_EXP 92
79825: PUSH
79826: LD_VAR 0 2
79830: ARRAY
79831: PPUSH
79832: LD_INT 25
79834: PUSH
79835: LD_INT 12
79837: PUSH
79838: EMPTY
79839: LIST
79840: LIST
79841: PPUSH
79842: CALL_OW 72
79846: NOT
79847: OR
79848: IFFALSE 79852
// continue ;
79850: GO 79806
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
79852: LD_ADDR_VAR 0 5
79856: PUSH
79857: LD_EXP 92
79861: PUSH
79862: LD_VAR 0 2
79866: ARRAY
79867: PUSH
79868: LD_INT 1
79870: ARRAY
79871: PPUSH
79872: CALL_OW 255
79876: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
79877: LD_VAR 0 5
79881: PPUSH
79882: LD_INT 2
79884: PPUSH
79885: CALL_OW 325
79889: IFFALSE 80142
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
79891: LD_ADDR_VAR 0 4
79895: PUSH
79896: LD_EXP 92
79900: PUSH
79901: LD_VAR 0 2
79905: ARRAY
79906: PPUSH
79907: LD_INT 25
79909: PUSH
79910: LD_INT 16
79912: PUSH
79913: EMPTY
79914: LIST
79915: LIST
79916: PPUSH
79917: CALL_OW 72
79921: ST_TO_ADDR
// if tmp < 6 then
79922: LD_VAR 0 4
79926: PUSH
79927: LD_INT 6
79929: LESS
79930: IFFALSE 80142
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79932: LD_ADDR_VAR 0 6
79936: PUSH
79937: LD_EXP 63
79941: PUSH
79942: LD_VAR 0 2
79946: ARRAY
79947: PPUSH
79948: LD_INT 2
79950: PUSH
79951: LD_INT 30
79953: PUSH
79954: LD_INT 0
79956: PUSH
79957: EMPTY
79958: LIST
79959: LIST
79960: PUSH
79961: LD_INT 30
79963: PUSH
79964: LD_INT 1
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: LIST
79975: PPUSH
79976: CALL_OW 72
79980: ST_TO_ADDR
// if depot then
79981: LD_VAR 0 6
79985: IFFALSE 80142
// begin selected := 0 ;
79987: LD_ADDR_VAR 0 7
79991: PUSH
79992: LD_INT 0
79994: ST_TO_ADDR
// for j in depot do
79995: LD_ADDR_VAR 0 3
79999: PUSH
80000: LD_VAR 0 6
80004: PUSH
80005: FOR_IN
80006: IFFALSE 80037
// begin if UnitsInside ( j ) < 6 then
80008: LD_VAR 0 3
80012: PPUSH
80013: CALL_OW 313
80017: PUSH
80018: LD_INT 6
80020: LESS
80021: IFFALSE 80035
// begin selected := j ;
80023: LD_ADDR_VAR 0 7
80027: PUSH
80028: LD_VAR 0 3
80032: ST_TO_ADDR
// break ;
80033: GO 80037
// end ; end ;
80035: GO 80005
80037: POP
80038: POP
// if selected then
80039: LD_VAR 0 7
80043: IFFALSE 80142
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80045: LD_ADDR_VAR 0 3
80049: PUSH
80050: LD_EXP 92
80054: PUSH
80055: LD_VAR 0 2
80059: ARRAY
80060: PPUSH
80061: LD_INT 25
80063: PUSH
80064: LD_INT 12
80066: PUSH
80067: EMPTY
80068: LIST
80069: LIST
80070: PPUSH
80071: CALL_OW 72
80075: PUSH
80076: FOR_IN
80077: IFFALSE 80140
// if not HasTask ( j ) then
80079: LD_VAR 0 3
80083: PPUSH
80084: CALL_OW 314
80088: NOT
80089: IFFALSE 80138
// begin if not IsInUnit ( j ) then
80091: LD_VAR 0 3
80095: PPUSH
80096: CALL_OW 310
80100: NOT
80101: IFFALSE 80117
// ComEnterUnit ( j , selected ) ;
80103: LD_VAR 0 3
80107: PPUSH
80108: LD_VAR 0 7
80112: PPUSH
80113: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
80117: LD_VAR 0 3
80121: PPUSH
80122: LD_INT 16
80124: PPUSH
80125: CALL_OW 183
// AddComExitBuilding ( j ) ;
80129: LD_VAR 0 3
80133: PPUSH
80134: CALL_OW 182
// end ;
80138: GO 80076
80140: POP
80141: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
80142: LD_VAR 0 5
80146: PPUSH
80147: LD_INT 11
80149: PPUSH
80150: CALL_OW 325
80154: IFFALSE 80413
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
80156: LD_ADDR_VAR 0 4
80160: PUSH
80161: LD_EXP 92
80165: PUSH
80166: LD_VAR 0 2
80170: ARRAY
80171: PPUSH
80172: LD_INT 25
80174: PUSH
80175: LD_INT 16
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PPUSH
80182: CALL_OW 72
80186: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
80187: LD_VAR 0 4
80191: PUSH
80192: LD_INT 6
80194: GREATEREQUAL
80195: PUSH
80196: LD_VAR 0 5
80200: PPUSH
80201: LD_INT 2
80203: PPUSH
80204: CALL_OW 325
80208: NOT
80209: OR
80210: IFFALSE 80413
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80212: LD_ADDR_VAR 0 8
80216: PUSH
80217: LD_EXP 63
80221: PUSH
80222: LD_VAR 0 2
80226: ARRAY
80227: PPUSH
80228: LD_INT 2
80230: PUSH
80231: LD_INT 30
80233: PUSH
80234: LD_INT 4
80236: PUSH
80237: EMPTY
80238: LIST
80239: LIST
80240: PUSH
80241: LD_INT 30
80243: PUSH
80244: LD_INT 5
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: LIST
80255: PPUSH
80256: CALL_OW 72
80260: ST_TO_ADDR
// if barracks then
80261: LD_VAR 0 8
80265: IFFALSE 80413
// begin selected := 0 ;
80267: LD_ADDR_VAR 0 7
80271: PUSH
80272: LD_INT 0
80274: ST_TO_ADDR
// for j in barracks do
80275: LD_ADDR_VAR 0 3
80279: PUSH
80280: LD_VAR 0 8
80284: PUSH
80285: FOR_IN
80286: IFFALSE 80317
// begin if UnitsInside ( j ) < 6 then
80288: LD_VAR 0 3
80292: PPUSH
80293: CALL_OW 313
80297: PUSH
80298: LD_INT 6
80300: LESS
80301: IFFALSE 80315
// begin selected := j ;
80303: LD_ADDR_VAR 0 7
80307: PUSH
80308: LD_VAR 0 3
80312: ST_TO_ADDR
// break ;
80313: GO 80317
// end ; end ;
80315: GO 80285
80317: POP
80318: POP
// if selected then
80319: LD_VAR 0 7
80323: IFFALSE 80413
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
80325: LD_ADDR_VAR 0 3
80329: PUSH
80330: LD_EXP 92
80334: PUSH
80335: LD_VAR 0 2
80339: ARRAY
80340: PPUSH
80341: LD_INT 25
80343: PUSH
80344: LD_INT 12
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PPUSH
80351: CALL_OW 72
80355: PUSH
80356: FOR_IN
80357: IFFALSE 80411
// if not IsInUnit ( j ) and not HasTask ( j ) then
80359: LD_VAR 0 3
80363: PPUSH
80364: CALL_OW 310
80368: NOT
80369: PUSH
80370: LD_VAR 0 3
80374: PPUSH
80375: CALL_OW 314
80379: NOT
80380: AND
80381: IFFALSE 80409
// begin ComEnterUnit ( j , selected ) ;
80383: LD_VAR 0 3
80387: PPUSH
80388: LD_VAR 0 7
80392: PPUSH
80393: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
80397: LD_VAR 0 3
80401: PPUSH
80402: LD_INT 15
80404: PPUSH
80405: CALL_OW 183
// end ;
80409: GO 80356
80411: POP
80412: POP
// end ; end ; end ; end ; end ;
80413: GO 79806
80415: POP
80416: POP
// end ;
80417: LD_VAR 0 1
80421: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
80422: LD_INT 0
80424: PPUSH
80425: PPUSH
80426: PPUSH
80427: PPUSH
// if not mc_bases then
80428: LD_EXP 63
80432: NOT
80433: IFFALSE 80437
// exit ;
80435: GO 80615
// for i = 1 to mc_bases do
80437: LD_ADDR_VAR 0 2
80441: PUSH
80442: DOUBLE
80443: LD_INT 1
80445: DEC
80446: ST_TO_ADDR
80447: LD_EXP 63
80451: PUSH
80452: FOR_TO
80453: IFFALSE 80613
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
80455: LD_ADDR_VAR 0 4
80459: PUSH
80460: LD_EXP 63
80464: PUSH
80465: LD_VAR 0 2
80469: ARRAY
80470: PPUSH
80471: LD_INT 25
80473: PUSH
80474: LD_INT 9
80476: PUSH
80477: EMPTY
80478: LIST
80479: LIST
80480: PPUSH
80481: CALL_OW 72
80485: ST_TO_ADDR
// if not tmp then
80486: LD_VAR 0 4
80490: NOT
80491: IFFALSE 80495
// continue ;
80493: GO 80452
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
80495: LD_EXP 89
80499: PUSH
80500: LD_VAR 0 2
80504: ARRAY
80505: PPUSH
80506: LD_INT 29
80508: PPUSH
80509: CALL_OW 325
80513: NOT
80514: PUSH
80515: LD_EXP 89
80519: PUSH
80520: LD_VAR 0 2
80524: ARRAY
80525: PPUSH
80526: LD_INT 28
80528: PPUSH
80529: CALL_OW 325
80533: NOT
80534: AND
80535: IFFALSE 80539
// continue ;
80537: GO 80452
// for j in tmp do
80539: LD_ADDR_VAR 0 3
80543: PUSH
80544: LD_VAR 0 4
80548: PUSH
80549: FOR_IN
80550: IFFALSE 80609
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
80552: LD_VAR 0 3
80556: PUSH
80557: LD_EXP 66
80561: PUSH
80562: LD_VAR 0 2
80566: ARRAY
80567: PUSH
80568: LD_INT 1
80570: ARRAY
80571: IN
80572: NOT
80573: PUSH
80574: LD_VAR 0 3
80578: PUSH
80579: LD_EXP 66
80583: PUSH
80584: LD_VAR 0 2
80588: ARRAY
80589: PUSH
80590: LD_INT 2
80592: ARRAY
80593: IN
80594: NOT
80595: AND
80596: IFFALSE 80607
// ComSpaceTimeShoot ( j ) ;
80598: LD_VAR 0 3
80602: PPUSH
80603: CALL 18307 0 1
80607: GO 80549
80609: POP
80610: POP
// end ;
80611: GO 80452
80613: POP
80614: POP
// end ;
80615: LD_VAR 0 1
80619: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
80620: LD_INT 0
80622: PPUSH
80623: PPUSH
80624: PPUSH
80625: PPUSH
80626: PPUSH
80627: PPUSH
80628: PPUSH
80629: PPUSH
80630: PPUSH
// if not mc_bases then
80631: LD_EXP 63
80635: NOT
80636: IFFALSE 80640
// exit ;
80638: GO 81262
// for i = 1 to mc_bases do
80640: LD_ADDR_VAR 0 2
80644: PUSH
80645: DOUBLE
80646: LD_INT 1
80648: DEC
80649: ST_TO_ADDR
80650: LD_EXP 63
80654: PUSH
80655: FOR_TO
80656: IFFALSE 81260
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
80658: LD_EXP 98
80662: PUSH
80663: LD_VAR 0 2
80667: ARRAY
80668: NOT
80669: PUSH
80670: LD_INT 38
80672: PPUSH
80673: LD_EXP 89
80677: PUSH
80678: LD_VAR 0 2
80682: ARRAY
80683: PPUSH
80684: CALL_OW 321
80688: PUSH
80689: LD_INT 2
80691: NONEQUAL
80692: OR
80693: IFFALSE 80697
// continue ;
80695: GO 80655
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
80697: LD_ADDR_VAR 0 8
80701: PUSH
80702: LD_EXP 63
80706: PUSH
80707: LD_VAR 0 2
80711: ARRAY
80712: PPUSH
80713: LD_INT 30
80715: PUSH
80716: LD_INT 34
80718: PUSH
80719: EMPTY
80720: LIST
80721: LIST
80722: PPUSH
80723: CALL_OW 72
80727: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
80728: LD_ADDR_VAR 0 9
80732: PUSH
80733: LD_EXP 63
80737: PUSH
80738: LD_VAR 0 2
80742: ARRAY
80743: PPUSH
80744: LD_INT 25
80746: PUSH
80747: LD_INT 4
80749: PUSH
80750: EMPTY
80751: LIST
80752: LIST
80753: PPUSH
80754: CALL_OW 72
80758: PPUSH
80759: LD_INT 0
80761: PPUSH
80762: CALL 52640 0 2
80766: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
80767: LD_VAR 0 9
80771: NOT
80772: PUSH
80773: LD_VAR 0 8
80777: NOT
80778: OR
80779: PUSH
80780: LD_EXP 63
80784: PUSH
80785: LD_VAR 0 2
80789: ARRAY
80790: PPUSH
80791: LD_INT 124
80793: PPUSH
80794: CALL 52640 0 2
80798: OR
80799: IFFALSE 80803
// continue ;
80801: GO 80655
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
80803: LD_EXP 99
80807: PUSH
80808: LD_VAR 0 2
80812: ARRAY
80813: PUSH
80814: LD_EXP 98
80818: PUSH
80819: LD_VAR 0 2
80823: ARRAY
80824: LESS
80825: PUSH
80826: LD_EXP 99
80830: PUSH
80831: LD_VAR 0 2
80835: ARRAY
80836: PUSH
80837: LD_VAR 0 8
80841: LESS
80842: AND
80843: IFFALSE 81258
// begin tmp := sci [ 1 ] ;
80845: LD_ADDR_VAR 0 7
80849: PUSH
80850: LD_VAR 0 9
80854: PUSH
80855: LD_INT 1
80857: ARRAY
80858: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
80859: LD_VAR 0 7
80863: PPUSH
80864: LD_INT 124
80866: PPUSH
80867: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
80871: LD_ADDR_VAR 0 3
80875: PUSH
80876: DOUBLE
80877: LD_EXP 98
80881: PUSH
80882: LD_VAR 0 2
80886: ARRAY
80887: INC
80888: ST_TO_ADDR
80889: LD_EXP 98
80893: PUSH
80894: LD_VAR 0 2
80898: ARRAY
80899: PUSH
80900: FOR_DOWNTO
80901: IFFALSE 81244
// begin if IsInUnit ( tmp ) then
80903: LD_VAR 0 7
80907: PPUSH
80908: CALL_OW 310
80912: IFFALSE 80923
// ComExitBuilding ( tmp ) ;
80914: LD_VAR 0 7
80918: PPUSH
80919: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
80923: LD_INT 35
80925: PPUSH
80926: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
80930: LD_VAR 0 7
80934: PPUSH
80935: CALL_OW 310
80939: NOT
80940: PUSH
80941: LD_VAR 0 7
80945: PPUSH
80946: CALL_OW 314
80950: NOT
80951: AND
80952: IFFALSE 80923
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
80954: LD_ADDR_VAR 0 6
80958: PUSH
80959: LD_VAR 0 7
80963: PPUSH
80964: CALL_OW 250
80968: PUSH
80969: LD_VAR 0 7
80973: PPUSH
80974: CALL_OW 251
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
80983: LD_INT 35
80985: PPUSH
80986: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
80990: LD_ADDR_VAR 0 4
80994: PUSH
80995: LD_EXP 98
80999: PUSH
81000: LD_VAR 0 2
81004: ARRAY
81005: PUSH
81006: LD_VAR 0 3
81010: ARRAY
81011: PUSH
81012: LD_INT 1
81014: ARRAY
81015: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
81016: LD_ADDR_VAR 0 5
81020: PUSH
81021: LD_EXP 98
81025: PUSH
81026: LD_VAR 0 2
81030: ARRAY
81031: PUSH
81032: LD_VAR 0 3
81036: ARRAY
81037: PUSH
81038: LD_INT 2
81040: ARRAY
81041: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
81042: LD_VAR 0 7
81046: PPUSH
81047: LD_INT 10
81049: PPUSH
81050: CALL 25287 0 2
81054: PUSH
81055: LD_INT 4
81057: ARRAY
81058: IFFALSE 81096
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
81060: LD_VAR 0 7
81064: PPUSH
81065: LD_VAR 0 6
81069: PUSH
81070: LD_INT 1
81072: ARRAY
81073: PPUSH
81074: LD_VAR 0 6
81078: PUSH
81079: LD_INT 2
81081: ARRAY
81082: PPUSH
81083: CALL_OW 111
// wait ( 0 0$10 ) ;
81087: LD_INT 350
81089: PPUSH
81090: CALL_OW 67
// end else
81094: GO 81122
// begin ComMoveXY ( tmp , x , y ) ;
81096: LD_VAR 0 7
81100: PPUSH
81101: LD_VAR 0 4
81105: PPUSH
81106: LD_VAR 0 5
81110: PPUSH
81111: CALL_OW 111
// wait ( 0 0$3 ) ;
81115: LD_INT 105
81117: PPUSH
81118: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
81122: LD_VAR 0 7
81126: PPUSH
81127: LD_VAR 0 4
81131: PPUSH
81132: LD_VAR 0 5
81136: PPUSH
81137: CALL_OW 307
81141: IFFALSE 80983
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
81143: LD_VAR 0 7
81147: PPUSH
81148: LD_VAR 0 4
81152: PPUSH
81153: LD_VAR 0 5
81157: PPUSH
81158: LD_VAR 0 8
81162: PUSH
81163: LD_VAR 0 3
81167: ARRAY
81168: PPUSH
81169: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
81173: LD_INT 35
81175: PPUSH
81176: CALL_OW 67
// until not HasTask ( tmp ) ;
81180: LD_VAR 0 7
81184: PPUSH
81185: CALL_OW 314
81189: NOT
81190: IFFALSE 81173
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
81192: LD_ADDR_EXP 99
81196: PUSH
81197: LD_EXP 99
81201: PPUSH
81202: LD_VAR 0 2
81206: PUSH
81207: LD_EXP 99
81211: PUSH
81212: LD_VAR 0 2
81216: ARRAY
81217: PUSH
81218: LD_INT 1
81220: PLUS
81221: PUSH
81222: EMPTY
81223: LIST
81224: LIST
81225: PPUSH
81226: LD_VAR 0 8
81230: PUSH
81231: LD_VAR 0 3
81235: ARRAY
81236: PPUSH
81237: CALL 22322 0 3
81241: ST_TO_ADDR
// end ;
81242: GO 80900
81244: POP
81245: POP
// MC_Reset ( i , 124 ) ;
81246: LD_VAR 0 2
81250: PPUSH
81251: LD_INT 124
81253: PPUSH
81254: CALL 64330 0 2
// end ; end ;
81258: GO 80655
81260: POP
81261: POP
// end ;
81262: LD_VAR 0 1
81266: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
81267: LD_INT 0
81269: PPUSH
81270: PPUSH
81271: PPUSH
// if not mc_bases then
81272: LD_EXP 63
81276: NOT
81277: IFFALSE 81281
// exit ;
81279: GO 81887
// for i = 1 to mc_bases do
81281: LD_ADDR_VAR 0 2
81285: PUSH
81286: DOUBLE
81287: LD_INT 1
81289: DEC
81290: ST_TO_ADDR
81291: LD_EXP 63
81295: PUSH
81296: FOR_TO
81297: IFFALSE 81885
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
81299: LD_ADDR_VAR 0 3
81303: PUSH
81304: LD_EXP 63
81308: PUSH
81309: LD_VAR 0 2
81313: ARRAY
81314: PPUSH
81315: LD_INT 25
81317: PUSH
81318: LD_INT 4
81320: PUSH
81321: EMPTY
81322: LIST
81323: LIST
81324: PPUSH
81325: CALL_OW 72
81329: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
81330: LD_VAR 0 3
81334: NOT
81335: PUSH
81336: LD_EXP 100
81340: PUSH
81341: LD_VAR 0 2
81345: ARRAY
81346: NOT
81347: OR
81348: PUSH
81349: LD_EXP 63
81353: PUSH
81354: LD_VAR 0 2
81358: ARRAY
81359: PPUSH
81360: LD_INT 2
81362: PUSH
81363: LD_INT 30
81365: PUSH
81366: LD_INT 0
81368: PUSH
81369: EMPTY
81370: LIST
81371: LIST
81372: PUSH
81373: LD_INT 30
81375: PUSH
81376: LD_INT 1
81378: PUSH
81379: EMPTY
81380: LIST
81381: LIST
81382: PUSH
81383: EMPTY
81384: LIST
81385: LIST
81386: LIST
81387: PPUSH
81388: CALL_OW 72
81392: NOT
81393: OR
81394: IFFALSE 81444
// begin if mc_deposits_finder [ i ] then
81396: LD_EXP 101
81400: PUSH
81401: LD_VAR 0 2
81405: ARRAY
81406: IFFALSE 81442
// begin MC_Reset ( i , 125 ) ;
81408: LD_VAR 0 2
81412: PPUSH
81413: LD_INT 125
81415: PPUSH
81416: CALL 64330 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81420: LD_ADDR_EXP 101
81424: PUSH
81425: LD_EXP 101
81429: PPUSH
81430: LD_VAR 0 2
81434: PPUSH
81435: EMPTY
81436: PPUSH
81437: CALL_OW 1
81441: ST_TO_ADDR
// end ; continue ;
81442: GO 81296
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
81444: LD_EXP 100
81448: PUSH
81449: LD_VAR 0 2
81453: ARRAY
81454: PUSH
81455: LD_INT 1
81457: ARRAY
81458: PUSH
81459: LD_INT 3
81461: ARRAY
81462: PUSH
81463: LD_INT 1
81465: EQUAL
81466: PUSH
81467: LD_INT 20
81469: PPUSH
81470: LD_EXP 89
81474: PUSH
81475: LD_VAR 0 2
81479: ARRAY
81480: PPUSH
81481: CALL_OW 321
81485: PUSH
81486: LD_INT 2
81488: NONEQUAL
81489: AND
81490: IFFALSE 81540
// begin if mc_deposits_finder [ i ] then
81492: LD_EXP 101
81496: PUSH
81497: LD_VAR 0 2
81501: ARRAY
81502: IFFALSE 81538
// begin MC_Reset ( i , 125 ) ;
81504: LD_VAR 0 2
81508: PPUSH
81509: LD_INT 125
81511: PPUSH
81512: CALL 64330 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
81516: LD_ADDR_EXP 101
81520: PUSH
81521: LD_EXP 101
81525: PPUSH
81526: LD_VAR 0 2
81530: PPUSH
81531: EMPTY
81532: PPUSH
81533: CALL_OW 1
81537: ST_TO_ADDR
// end ; continue ;
81538: GO 81296
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
81540: LD_EXP 100
81544: PUSH
81545: LD_VAR 0 2
81549: ARRAY
81550: PUSH
81551: LD_INT 1
81553: ARRAY
81554: PUSH
81555: LD_INT 1
81557: ARRAY
81558: PPUSH
81559: LD_EXP 100
81563: PUSH
81564: LD_VAR 0 2
81568: ARRAY
81569: PUSH
81570: LD_INT 1
81572: ARRAY
81573: PUSH
81574: LD_INT 2
81576: ARRAY
81577: PPUSH
81578: LD_EXP 89
81582: PUSH
81583: LD_VAR 0 2
81587: ARRAY
81588: PPUSH
81589: CALL_OW 440
81593: IFFALSE 81636
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
81595: LD_ADDR_EXP 100
81599: PUSH
81600: LD_EXP 100
81604: PPUSH
81605: LD_VAR 0 2
81609: PPUSH
81610: LD_EXP 100
81614: PUSH
81615: LD_VAR 0 2
81619: ARRAY
81620: PPUSH
81621: LD_INT 1
81623: PPUSH
81624: CALL_OW 3
81628: PPUSH
81629: CALL_OW 1
81633: ST_TO_ADDR
81634: GO 81883
// begin if not mc_deposits_finder [ i ] then
81636: LD_EXP 101
81640: PUSH
81641: LD_VAR 0 2
81645: ARRAY
81646: NOT
81647: IFFALSE 81699
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
81649: LD_ADDR_EXP 101
81653: PUSH
81654: LD_EXP 101
81658: PPUSH
81659: LD_VAR 0 2
81663: PPUSH
81664: LD_VAR 0 3
81668: PUSH
81669: LD_INT 1
81671: ARRAY
81672: PUSH
81673: EMPTY
81674: LIST
81675: PPUSH
81676: CALL_OW 1
81680: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
81681: LD_VAR 0 3
81685: PUSH
81686: LD_INT 1
81688: ARRAY
81689: PPUSH
81690: LD_INT 125
81692: PPUSH
81693: CALL_OW 109
// end else
81697: GO 81883
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
81699: LD_EXP 101
81703: PUSH
81704: LD_VAR 0 2
81708: ARRAY
81709: PUSH
81710: LD_INT 1
81712: ARRAY
81713: PPUSH
81714: CALL_OW 310
81718: IFFALSE 81741
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
81720: LD_EXP 101
81724: PUSH
81725: LD_VAR 0 2
81729: ARRAY
81730: PUSH
81731: LD_INT 1
81733: ARRAY
81734: PPUSH
81735: CALL_OW 122
81739: GO 81883
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
81741: LD_EXP 101
81745: PUSH
81746: LD_VAR 0 2
81750: ARRAY
81751: PUSH
81752: LD_INT 1
81754: ARRAY
81755: PPUSH
81756: CALL_OW 314
81760: NOT
81761: PUSH
81762: LD_EXP 101
81766: PUSH
81767: LD_VAR 0 2
81771: ARRAY
81772: PUSH
81773: LD_INT 1
81775: ARRAY
81776: PPUSH
81777: LD_EXP 100
81781: PUSH
81782: LD_VAR 0 2
81786: ARRAY
81787: PUSH
81788: LD_INT 1
81790: ARRAY
81791: PUSH
81792: LD_INT 1
81794: ARRAY
81795: PPUSH
81796: LD_EXP 100
81800: PUSH
81801: LD_VAR 0 2
81805: ARRAY
81806: PUSH
81807: LD_INT 1
81809: ARRAY
81810: PUSH
81811: LD_INT 2
81813: ARRAY
81814: PPUSH
81815: CALL_OW 297
81819: PUSH
81820: LD_INT 6
81822: GREATER
81823: AND
81824: IFFALSE 81883
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
81826: LD_EXP 101
81830: PUSH
81831: LD_VAR 0 2
81835: ARRAY
81836: PUSH
81837: LD_INT 1
81839: ARRAY
81840: PPUSH
81841: LD_EXP 100
81845: PUSH
81846: LD_VAR 0 2
81850: ARRAY
81851: PUSH
81852: LD_INT 1
81854: ARRAY
81855: PUSH
81856: LD_INT 1
81858: ARRAY
81859: PPUSH
81860: LD_EXP 100
81864: PUSH
81865: LD_VAR 0 2
81869: ARRAY
81870: PUSH
81871: LD_INT 1
81873: ARRAY
81874: PUSH
81875: LD_INT 2
81877: ARRAY
81878: PPUSH
81879: CALL_OW 111
// end ; end ; end ;
81883: GO 81296
81885: POP
81886: POP
// end ;
81887: LD_VAR 0 1
81891: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
81892: LD_INT 0
81894: PPUSH
81895: PPUSH
81896: PPUSH
81897: PPUSH
81898: PPUSH
81899: PPUSH
81900: PPUSH
81901: PPUSH
81902: PPUSH
81903: PPUSH
81904: PPUSH
// if not mc_bases then
81905: LD_EXP 63
81909: NOT
81910: IFFALSE 81914
// exit ;
81912: GO 82854
// for i = 1 to mc_bases do
81914: LD_ADDR_VAR 0 2
81918: PUSH
81919: DOUBLE
81920: LD_INT 1
81922: DEC
81923: ST_TO_ADDR
81924: LD_EXP 63
81928: PUSH
81929: FOR_TO
81930: IFFALSE 82852
// begin if not mc_bases [ i ] or mc_scan [ i ] then
81932: LD_EXP 63
81936: PUSH
81937: LD_VAR 0 2
81941: ARRAY
81942: NOT
81943: PUSH
81944: LD_EXP 86
81948: PUSH
81949: LD_VAR 0 2
81953: ARRAY
81954: OR
81955: IFFALSE 81959
// continue ;
81957: GO 81929
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
81959: LD_ADDR_VAR 0 7
81963: PUSH
81964: LD_EXP 63
81968: PUSH
81969: LD_VAR 0 2
81973: ARRAY
81974: PUSH
81975: LD_INT 1
81977: ARRAY
81978: PPUSH
81979: CALL_OW 248
81983: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
81984: LD_VAR 0 7
81988: PUSH
81989: LD_INT 3
81991: EQUAL
81992: PUSH
81993: LD_EXP 82
81997: PUSH
81998: LD_VAR 0 2
82002: ARRAY
82003: PUSH
82004: LD_EXP 85
82008: PUSH
82009: LD_VAR 0 2
82013: ARRAY
82014: UNION
82015: PPUSH
82016: LD_INT 33
82018: PUSH
82019: LD_INT 2
82021: PUSH
82022: EMPTY
82023: LIST
82024: LIST
82025: PPUSH
82026: CALL_OW 72
82030: NOT
82031: OR
82032: IFFALSE 82036
// continue ;
82034: GO 81929
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
82036: LD_ADDR_VAR 0 9
82040: PUSH
82041: LD_EXP 63
82045: PUSH
82046: LD_VAR 0 2
82050: ARRAY
82051: PPUSH
82052: LD_INT 30
82054: PUSH
82055: LD_INT 36
82057: PUSH
82058: EMPTY
82059: LIST
82060: LIST
82061: PPUSH
82062: CALL_OW 72
82066: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
82067: LD_ADDR_VAR 0 10
82071: PUSH
82072: LD_EXP 82
82076: PUSH
82077: LD_VAR 0 2
82081: ARRAY
82082: PPUSH
82083: LD_INT 34
82085: PUSH
82086: LD_INT 31
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: PPUSH
82093: CALL_OW 72
82097: ST_TO_ADDR
// if not cts and not mcts then
82098: LD_VAR 0 9
82102: NOT
82103: PUSH
82104: LD_VAR 0 10
82108: NOT
82109: AND
82110: IFFALSE 82114
// continue ;
82112: GO 81929
// x := cts ;
82114: LD_ADDR_VAR 0 11
82118: PUSH
82119: LD_VAR 0 9
82123: ST_TO_ADDR
// if not x then
82124: LD_VAR 0 11
82128: NOT
82129: IFFALSE 82141
// x := mcts ;
82131: LD_ADDR_VAR 0 11
82135: PUSH
82136: LD_VAR 0 10
82140: ST_TO_ADDR
// if not x then
82141: LD_VAR 0 11
82145: NOT
82146: IFFALSE 82150
// continue ;
82148: GO 81929
// if mc_remote_driver [ i ] then
82150: LD_EXP 103
82154: PUSH
82155: LD_VAR 0 2
82159: ARRAY
82160: IFFALSE 82547
// for j in mc_remote_driver [ i ] do
82162: LD_ADDR_VAR 0 3
82166: PUSH
82167: LD_EXP 103
82171: PUSH
82172: LD_VAR 0 2
82176: ARRAY
82177: PUSH
82178: FOR_IN
82179: IFFALSE 82545
// begin if GetClass ( j ) <> 3 then
82181: LD_VAR 0 3
82185: PPUSH
82186: CALL_OW 257
82190: PUSH
82191: LD_INT 3
82193: NONEQUAL
82194: IFFALSE 82247
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
82196: LD_ADDR_EXP 103
82200: PUSH
82201: LD_EXP 103
82205: PPUSH
82206: LD_VAR 0 2
82210: PPUSH
82211: LD_EXP 103
82215: PUSH
82216: LD_VAR 0 2
82220: ARRAY
82221: PUSH
82222: LD_VAR 0 3
82226: DIFF
82227: PPUSH
82228: CALL_OW 1
82232: ST_TO_ADDR
// SetTag ( j , 0 ) ;
82233: LD_VAR 0 3
82237: PPUSH
82238: LD_INT 0
82240: PPUSH
82241: CALL_OW 109
// continue ;
82245: GO 82178
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
82247: LD_EXP 82
82251: PUSH
82252: LD_VAR 0 2
82256: ARRAY
82257: PPUSH
82258: LD_INT 34
82260: PUSH
82261: LD_INT 31
82263: PUSH
82264: EMPTY
82265: LIST
82266: LIST
82267: PUSH
82268: LD_INT 58
82270: PUSH
82271: EMPTY
82272: LIST
82273: PUSH
82274: EMPTY
82275: LIST
82276: LIST
82277: PPUSH
82278: CALL_OW 72
82282: PUSH
82283: LD_VAR 0 3
82287: PPUSH
82288: CALL 52675 0 1
82292: NOT
82293: AND
82294: IFFALSE 82365
// begin if IsInUnit ( j ) then
82296: LD_VAR 0 3
82300: PPUSH
82301: CALL_OW 310
82305: IFFALSE 82316
// ComExitBuilding ( j ) ;
82307: LD_VAR 0 3
82311: PPUSH
82312: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
82316: LD_VAR 0 3
82320: PPUSH
82321: LD_EXP 82
82325: PUSH
82326: LD_VAR 0 2
82330: ARRAY
82331: PPUSH
82332: LD_INT 34
82334: PUSH
82335: LD_INT 31
82337: PUSH
82338: EMPTY
82339: LIST
82340: LIST
82341: PUSH
82342: LD_INT 58
82344: PUSH
82345: EMPTY
82346: LIST
82347: PUSH
82348: EMPTY
82349: LIST
82350: LIST
82351: PPUSH
82352: CALL_OW 72
82356: PUSH
82357: LD_INT 1
82359: ARRAY
82360: PPUSH
82361: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
82365: LD_VAR 0 3
82369: PPUSH
82370: CALL_OW 310
82374: NOT
82375: PUSH
82376: LD_VAR 0 3
82380: PPUSH
82381: CALL_OW 310
82385: PPUSH
82386: CALL_OW 266
82390: PUSH
82391: LD_INT 36
82393: NONEQUAL
82394: PUSH
82395: LD_VAR 0 3
82399: PPUSH
82400: CALL 52675 0 1
82404: NOT
82405: AND
82406: OR
82407: IFFALSE 82543
// begin if IsInUnit ( j ) then
82409: LD_VAR 0 3
82413: PPUSH
82414: CALL_OW 310
82418: IFFALSE 82429
// ComExitBuilding ( j ) ;
82420: LD_VAR 0 3
82424: PPUSH
82425: CALL_OW 122
// ct := 0 ;
82429: LD_ADDR_VAR 0 8
82433: PUSH
82434: LD_INT 0
82436: ST_TO_ADDR
// for k in x do
82437: LD_ADDR_VAR 0 4
82441: PUSH
82442: LD_VAR 0 11
82446: PUSH
82447: FOR_IN
82448: IFFALSE 82521
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
82450: LD_VAR 0 4
82454: PPUSH
82455: CALL_OW 264
82459: PUSH
82460: LD_INT 31
82462: EQUAL
82463: PUSH
82464: LD_VAR 0 4
82468: PPUSH
82469: CALL_OW 311
82473: NOT
82474: AND
82475: PUSH
82476: LD_VAR 0 4
82480: PPUSH
82481: CALL_OW 266
82485: PUSH
82486: LD_INT 36
82488: EQUAL
82489: PUSH
82490: LD_VAR 0 4
82494: PPUSH
82495: CALL_OW 313
82499: PUSH
82500: LD_INT 3
82502: LESS
82503: AND
82504: OR
82505: IFFALSE 82519
// begin ct := k ;
82507: LD_ADDR_VAR 0 8
82511: PUSH
82512: LD_VAR 0 4
82516: ST_TO_ADDR
// break ;
82517: GO 82521
// end ;
82519: GO 82447
82521: POP
82522: POP
// if ct then
82523: LD_VAR 0 8
82527: IFFALSE 82543
// ComEnterUnit ( j , ct ) ;
82529: LD_VAR 0 3
82533: PPUSH
82534: LD_VAR 0 8
82538: PPUSH
82539: CALL_OW 120
// end ; end ;
82543: GO 82178
82545: POP
82546: POP
// places := 0 ;
82547: LD_ADDR_VAR 0 5
82551: PUSH
82552: LD_INT 0
82554: ST_TO_ADDR
// for j = 1 to x do
82555: LD_ADDR_VAR 0 3
82559: PUSH
82560: DOUBLE
82561: LD_INT 1
82563: DEC
82564: ST_TO_ADDR
82565: LD_VAR 0 11
82569: PUSH
82570: FOR_TO
82571: IFFALSE 82647
// if GetWeapon ( x [ j ] ) = ar_control_tower then
82573: LD_VAR 0 11
82577: PUSH
82578: LD_VAR 0 3
82582: ARRAY
82583: PPUSH
82584: CALL_OW 264
82588: PUSH
82589: LD_INT 31
82591: EQUAL
82592: IFFALSE 82610
// places := places + 1 else
82594: LD_ADDR_VAR 0 5
82598: PUSH
82599: LD_VAR 0 5
82603: PUSH
82604: LD_INT 1
82606: PLUS
82607: ST_TO_ADDR
82608: GO 82645
// if GetBType ( x [ j ] ) = b_control_tower then
82610: LD_VAR 0 11
82614: PUSH
82615: LD_VAR 0 3
82619: ARRAY
82620: PPUSH
82621: CALL_OW 266
82625: PUSH
82626: LD_INT 36
82628: EQUAL
82629: IFFALSE 82645
// places := places + 3 ;
82631: LD_ADDR_VAR 0 5
82635: PUSH
82636: LD_VAR 0 5
82640: PUSH
82641: LD_INT 3
82643: PLUS
82644: ST_TO_ADDR
82645: GO 82570
82647: POP
82648: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
82649: LD_VAR 0 5
82653: PUSH
82654: LD_INT 0
82656: EQUAL
82657: PUSH
82658: LD_VAR 0 5
82662: PUSH
82663: LD_EXP 103
82667: PUSH
82668: LD_VAR 0 2
82672: ARRAY
82673: LESSEQUAL
82674: OR
82675: IFFALSE 82679
// continue ;
82677: GO 81929
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
82679: LD_ADDR_VAR 0 6
82683: PUSH
82684: LD_EXP 63
82688: PUSH
82689: LD_VAR 0 2
82693: ARRAY
82694: PPUSH
82695: LD_INT 25
82697: PUSH
82698: LD_INT 3
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: PPUSH
82705: CALL_OW 72
82709: PUSH
82710: LD_EXP 103
82714: PUSH
82715: LD_VAR 0 2
82719: ARRAY
82720: DIFF
82721: PPUSH
82722: LD_INT 3
82724: PPUSH
82725: CALL 53575 0 2
82729: ST_TO_ADDR
// for j in tmp do
82730: LD_ADDR_VAR 0 3
82734: PUSH
82735: LD_VAR 0 6
82739: PUSH
82740: FOR_IN
82741: IFFALSE 82776
// if GetTag ( j ) > 0 then
82743: LD_VAR 0 3
82747: PPUSH
82748: CALL_OW 110
82752: PUSH
82753: LD_INT 0
82755: GREATER
82756: IFFALSE 82774
// tmp := tmp diff j ;
82758: LD_ADDR_VAR 0 6
82762: PUSH
82763: LD_VAR 0 6
82767: PUSH
82768: LD_VAR 0 3
82772: DIFF
82773: ST_TO_ADDR
82774: GO 82740
82776: POP
82777: POP
// if not tmp then
82778: LD_VAR 0 6
82782: NOT
82783: IFFALSE 82787
// continue ;
82785: GO 81929
// if places then
82787: LD_VAR 0 5
82791: IFFALSE 82850
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
82793: LD_ADDR_EXP 103
82797: PUSH
82798: LD_EXP 103
82802: PPUSH
82803: LD_VAR 0 2
82807: PPUSH
82808: LD_EXP 103
82812: PUSH
82813: LD_VAR 0 2
82817: ARRAY
82818: PUSH
82819: LD_VAR 0 6
82823: PUSH
82824: LD_INT 1
82826: ARRAY
82827: UNION
82828: PPUSH
82829: CALL_OW 1
82833: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
82834: LD_VAR 0 6
82838: PUSH
82839: LD_INT 1
82841: ARRAY
82842: PPUSH
82843: LD_INT 126
82845: PPUSH
82846: CALL_OW 109
// end ; end ;
82850: GO 81929
82852: POP
82853: POP
// end ;
82854: LD_VAR 0 1
82858: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
82859: LD_INT 0
82861: PPUSH
82862: PPUSH
82863: PPUSH
82864: PPUSH
82865: PPUSH
82866: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
82867: LD_VAR 0 1
82871: NOT
82872: PUSH
82873: LD_VAR 0 2
82877: NOT
82878: OR
82879: PUSH
82880: LD_VAR 0 3
82884: NOT
82885: OR
82886: PUSH
82887: LD_VAR 0 4
82891: PUSH
82892: LD_INT 1
82894: PUSH
82895: LD_INT 2
82897: PUSH
82898: LD_INT 3
82900: PUSH
82901: LD_INT 4
82903: PUSH
82904: LD_INT 5
82906: PUSH
82907: LD_INT 8
82909: PUSH
82910: LD_INT 9
82912: PUSH
82913: LD_INT 15
82915: PUSH
82916: LD_INT 16
82918: PUSH
82919: EMPTY
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: IN
82930: NOT
82931: OR
82932: IFFALSE 82936
// exit ;
82934: GO 83794
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
82936: LD_ADDR_VAR 0 2
82940: PUSH
82941: LD_VAR 0 2
82945: PPUSH
82946: LD_INT 21
82948: PUSH
82949: LD_INT 3
82951: PUSH
82952: EMPTY
82953: LIST
82954: LIST
82955: PUSH
82956: LD_INT 24
82958: PUSH
82959: LD_INT 250
82961: PUSH
82962: EMPTY
82963: LIST
82964: LIST
82965: PUSH
82966: EMPTY
82967: LIST
82968: LIST
82969: PPUSH
82970: CALL_OW 72
82974: ST_TO_ADDR
// case class of 1 , 15 :
82975: LD_VAR 0 4
82979: PUSH
82980: LD_INT 1
82982: DOUBLE
82983: EQUAL
82984: IFTRUE 82994
82986: LD_INT 15
82988: DOUBLE
82989: EQUAL
82990: IFTRUE 82994
82992: GO 83079
82994: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
82995: LD_ADDR_VAR 0 8
82999: PUSH
83000: LD_VAR 0 2
83004: PPUSH
83005: LD_INT 2
83007: PUSH
83008: LD_INT 30
83010: PUSH
83011: LD_INT 32
83013: PUSH
83014: EMPTY
83015: LIST
83016: LIST
83017: PUSH
83018: LD_INT 30
83020: PUSH
83021: LD_INT 31
83023: PUSH
83024: EMPTY
83025: LIST
83026: LIST
83027: PUSH
83028: EMPTY
83029: LIST
83030: LIST
83031: LIST
83032: PPUSH
83033: CALL_OW 72
83037: PUSH
83038: LD_VAR 0 2
83042: PPUSH
83043: LD_INT 2
83045: PUSH
83046: LD_INT 30
83048: PUSH
83049: LD_INT 4
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: PUSH
83056: LD_INT 30
83058: PUSH
83059: LD_INT 5
83061: PUSH
83062: EMPTY
83063: LIST
83064: LIST
83065: PUSH
83066: EMPTY
83067: LIST
83068: LIST
83069: LIST
83070: PPUSH
83071: CALL_OW 72
83075: ADD
83076: ST_TO_ADDR
83077: GO 83325
83079: LD_INT 2
83081: DOUBLE
83082: EQUAL
83083: IFTRUE 83093
83085: LD_INT 16
83087: DOUBLE
83088: EQUAL
83089: IFTRUE 83093
83091: GO 83139
83093: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
83094: LD_ADDR_VAR 0 8
83098: PUSH
83099: LD_VAR 0 2
83103: PPUSH
83104: LD_INT 2
83106: PUSH
83107: LD_INT 30
83109: PUSH
83110: LD_INT 0
83112: PUSH
83113: EMPTY
83114: LIST
83115: LIST
83116: PUSH
83117: LD_INT 30
83119: PUSH
83120: LD_INT 1
83122: PUSH
83123: EMPTY
83124: LIST
83125: LIST
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: LIST
83131: PPUSH
83132: CALL_OW 72
83136: ST_TO_ADDR
83137: GO 83325
83139: LD_INT 3
83141: DOUBLE
83142: EQUAL
83143: IFTRUE 83147
83145: GO 83193
83147: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
83148: LD_ADDR_VAR 0 8
83152: PUSH
83153: LD_VAR 0 2
83157: PPUSH
83158: LD_INT 2
83160: PUSH
83161: LD_INT 30
83163: PUSH
83164: LD_INT 2
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: PUSH
83171: LD_INT 30
83173: PUSH
83174: LD_INT 3
83176: PUSH
83177: EMPTY
83178: LIST
83179: LIST
83180: PUSH
83181: EMPTY
83182: LIST
83183: LIST
83184: LIST
83185: PPUSH
83186: CALL_OW 72
83190: ST_TO_ADDR
83191: GO 83325
83193: LD_INT 4
83195: DOUBLE
83196: EQUAL
83197: IFTRUE 83201
83199: GO 83258
83201: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
83202: LD_ADDR_VAR 0 8
83206: PUSH
83207: LD_VAR 0 2
83211: PPUSH
83212: LD_INT 2
83214: PUSH
83215: LD_INT 30
83217: PUSH
83218: LD_INT 6
83220: PUSH
83221: EMPTY
83222: LIST
83223: LIST
83224: PUSH
83225: LD_INT 30
83227: PUSH
83228: LD_INT 7
83230: PUSH
83231: EMPTY
83232: LIST
83233: LIST
83234: PUSH
83235: LD_INT 30
83237: PUSH
83238: LD_INT 8
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: PUSH
83245: EMPTY
83246: LIST
83247: LIST
83248: LIST
83249: LIST
83250: PPUSH
83251: CALL_OW 72
83255: ST_TO_ADDR
83256: GO 83325
83258: LD_INT 5
83260: DOUBLE
83261: EQUAL
83262: IFTRUE 83278
83264: LD_INT 8
83266: DOUBLE
83267: EQUAL
83268: IFTRUE 83278
83270: LD_INT 9
83272: DOUBLE
83273: EQUAL
83274: IFTRUE 83278
83276: GO 83324
83278: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
83279: LD_ADDR_VAR 0 8
83283: PUSH
83284: LD_VAR 0 2
83288: PPUSH
83289: LD_INT 2
83291: PUSH
83292: LD_INT 30
83294: PUSH
83295: LD_INT 4
83297: PUSH
83298: EMPTY
83299: LIST
83300: LIST
83301: PUSH
83302: LD_INT 30
83304: PUSH
83305: LD_INT 5
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: PUSH
83312: EMPTY
83313: LIST
83314: LIST
83315: LIST
83316: PPUSH
83317: CALL_OW 72
83321: ST_TO_ADDR
83322: GO 83325
83324: POP
// if not tmp then
83325: LD_VAR 0 8
83329: NOT
83330: IFFALSE 83334
// exit ;
83332: GO 83794
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
83334: LD_VAR 0 4
83338: PUSH
83339: LD_INT 1
83341: PUSH
83342: LD_INT 15
83344: PUSH
83345: EMPTY
83346: LIST
83347: LIST
83348: IN
83349: PUSH
83350: LD_EXP 72
83354: PUSH
83355: LD_VAR 0 1
83359: ARRAY
83360: AND
83361: IFFALSE 83517
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
83363: LD_ADDR_VAR 0 9
83367: PUSH
83368: LD_EXP 72
83372: PUSH
83373: LD_VAR 0 1
83377: ARRAY
83378: PUSH
83379: LD_INT 1
83381: ARRAY
83382: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
83383: LD_VAR 0 9
83387: PUSH
83388: LD_EXP 73
83392: PUSH
83393: LD_VAR 0 1
83397: ARRAY
83398: IN
83399: NOT
83400: IFFALSE 83515
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
83402: LD_ADDR_EXP 73
83406: PUSH
83407: LD_EXP 73
83411: PPUSH
83412: LD_VAR 0 1
83416: PUSH
83417: LD_EXP 73
83421: PUSH
83422: LD_VAR 0 1
83426: ARRAY
83427: PUSH
83428: LD_INT 1
83430: PLUS
83431: PUSH
83432: EMPTY
83433: LIST
83434: LIST
83435: PPUSH
83436: LD_VAR 0 9
83440: PPUSH
83441: CALL 22322 0 3
83445: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
83446: LD_ADDR_EXP 72
83450: PUSH
83451: LD_EXP 72
83455: PPUSH
83456: LD_VAR 0 1
83460: PPUSH
83461: LD_EXP 72
83465: PUSH
83466: LD_VAR 0 1
83470: ARRAY
83471: PUSH
83472: LD_VAR 0 9
83476: DIFF
83477: PPUSH
83478: CALL_OW 1
83482: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
83483: LD_VAR 0 3
83487: PPUSH
83488: LD_EXP 73
83492: PUSH
83493: LD_VAR 0 1
83497: ARRAY
83498: PUSH
83499: LD_EXP 73
83503: PUSH
83504: LD_VAR 0 1
83508: ARRAY
83509: ARRAY
83510: PPUSH
83511: CALL_OW 120
// end ; exit ;
83515: GO 83794
// end ; if tmp > 1 then
83517: LD_VAR 0 8
83521: PUSH
83522: LD_INT 1
83524: GREATER
83525: IFFALSE 83629
// for i = 2 to tmp do
83527: LD_ADDR_VAR 0 6
83531: PUSH
83532: DOUBLE
83533: LD_INT 2
83535: DEC
83536: ST_TO_ADDR
83537: LD_VAR 0 8
83541: PUSH
83542: FOR_TO
83543: IFFALSE 83627
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
83545: LD_VAR 0 8
83549: PUSH
83550: LD_VAR 0 6
83554: ARRAY
83555: PPUSH
83556: CALL_OW 461
83560: PUSH
83561: LD_INT 6
83563: EQUAL
83564: IFFALSE 83625
// begin x := tmp [ i ] ;
83566: LD_ADDR_VAR 0 9
83570: PUSH
83571: LD_VAR 0 8
83575: PUSH
83576: LD_VAR 0 6
83580: ARRAY
83581: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
83582: LD_ADDR_VAR 0 8
83586: PUSH
83587: LD_VAR 0 8
83591: PPUSH
83592: LD_VAR 0 6
83596: PPUSH
83597: CALL_OW 3
83601: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
83602: LD_ADDR_VAR 0 8
83606: PUSH
83607: LD_VAR 0 8
83611: PPUSH
83612: LD_INT 1
83614: PPUSH
83615: LD_VAR 0 9
83619: PPUSH
83620: CALL_OW 2
83624: ST_TO_ADDR
// end ;
83625: GO 83542
83627: POP
83628: POP
// for i in tmp do
83629: LD_ADDR_VAR 0 6
83633: PUSH
83634: LD_VAR 0 8
83638: PUSH
83639: FOR_IN
83640: IFFALSE 83667
// begin if IsNotFull ( i ) then
83642: LD_VAR 0 6
83646: PPUSH
83647: CALL 19544 0 1
83651: IFFALSE 83665
// begin j := i ;
83653: LD_ADDR_VAR 0 7
83657: PUSH
83658: LD_VAR 0 6
83662: ST_TO_ADDR
// break ;
83663: GO 83667
// end ; end ;
83665: GO 83639
83667: POP
83668: POP
// if j then
83669: LD_VAR 0 7
83673: IFFALSE 83691
// ComEnterUnit ( unit , j ) else
83675: LD_VAR 0 3
83679: PPUSH
83680: LD_VAR 0 7
83684: PPUSH
83685: CALL_OW 120
83689: GO 83794
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83691: LD_ADDR_VAR 0 10
83695: PUSH
83696: LD_VAR 0 2
83700: PPUSH
83701: LD_INT 2
83703: PUSH
83704: LD_INT 30
83706: PUSH
83707: LD_INT 0
83709: PUSH
83710: EMPTY
83711: LIST
83712: LIST
83713: PUSH
83714: LD_INT 30
83716: PUSH
83717: LD_INT 1
83719: PUSH
83720: EMPTY
83721: LIST
83722: LIST
83723: PUSH
83724: EMPTY
83725: LIST
83726: LIST
83727: LIST
83728: PPUSH
83729: CALL_OW 72
83733: ST_TO_ADDR
// if depot then
83734: LD_VAR 0 10
83738: IFFALSE 83794
// begin depot := NearestUnitToUnit ( depot , unit ) ;
83740: LD_ADDR_VAR 0 10
83744: PUSH
83745: LD_VAR 0 10
83749: PPUSH
83750: LD_VAR 0 3
83754: PPUSH
83755: CALL_OW 74
83759: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
83760: LD_VAR 0 3
83764: PPUSH
83765: LD_VAR 0 10
83769: PPUSH
83770: CALL_OW 296
83774: PUSH
83775: LD_INT 10
83777: GREATER
83778: IFFALSE 83794
// ComStandNearbyBuilding ( unit , depot ) ;
83780: LD_VAR 0 3
83784: PPUSH
83785: LD_VAR 0 10
83789: PPUSH
83790: CALL 18924 0 2
// end ; end ; end ;
83794: LD_VAR 0 5
83798: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
83799: LD_INT 0
83801: PPUSH
83802: PPUSH
83803: PPUSH
83804: PPUSH
// if not mc_bases then
83805: LD_EXP 63
83809: NOT
83810: IFFALSE 83814
// exit ;
83812: GO 84053
// for i = 1 to mc_bases do
83814: LD_ADDR_VAR 0 2
83818: PUSH
83819: DOUBLE
83820: LD_INT 1
83822: DEC
83823: ST_TO_ADDR
83824: LD_EXP 63
83828: PUSH
83829: FOR_TO
83830: IFFALSE 84051
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
83832: LD_ADDR_VAR 0 4
83836: PUSH
83837: LD_EXP 63
83841: PUSH
83842: LD_VAR 0 2
83846: ARRAY
83847: PPUSH
83848: LD_INT 21
83850: PUSH
83851: LD_INT 1
83853: PUSH
83854: EMPTY
83855: LIST
83856: LIST
83857: PPUSH
83858: CALL_OW 72
83862: PUSH
83863: LD_EXP 92
83867: PUSH
83868: LD_VAR 0 2
83872: ARRAY
83873: UNION
83874: ST_TO_ADDR
// if not tmp then
83875: LD_VAR 0 4
83879: NOT
83880: IFFALSE 83884
// continue ;
83882: GO 83829
// for j in tmp do
83884: LD_ADDR_VAR 0 3
83888: PUSH
83889: LD_VAR 0 4
83893: PUSH
83894: FOR_IN
83895: IFFALSE 84047
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
83897: LD_VAR 0 3
83901: PPUSH
83902: CALL_OW 110
83906: NOT
83907: PUSH
83908: LD_VAR 0 3
83912: PPUSH
83913: CALL_OW 314
83917: NOT
83918: AND
83919: PUSH
83920: LD_VAR 0 3
83924: PPUSH
83925: CALL_OW 311
83929: NOT
83930: AND
83931: PUSH
83932: LD_VAR 0 3
83936: PPUSH
83937: CALL_OW 310
83941: NOT
83942: AND
83943: PUSH
83944: LD_VAR 0 3
83948: PUSH
83949: LD_EXP 66
83953: PUSH
83954: LD_VAR 0 2
83958: ARRAY
83959: PUSH
83960: LD_INT 1
83962: ARRAY
83963: IN
83964: NOT
83965: AND
83966: PUSH
83967: LD_VAR 0 3
83971: PUSH
83972: LD_EXP 66
83976: PUSH
83977: LD_VAR 0 2
83981: ARRAY
83982: PUSH
83983: LD_INT 2
83985: ARRAY
83986: IN
83987: NOT
83988: AND
83989: PUSH
83990: LD_VAR 0 3
83994: PUSH
83995: LD_EXP 75
83999: PUSH
84000: LD_VAR 0 2
84004: ARRAY
84005: IN
84006: NOT
84007: AND
84008: IFFALSE 84045
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
84010: LD_VAR 0 2
84014: PPUSH
84015: LD_EXP 63
84019: PUSH
84020: LD_VAR 0 2
84024: ARRAY
84025: PPUSH
84026: LD_VAR 0 3
84030: PPUSH
84031: LD_VAR 0 3
84035: PPUSH
84036: CALL_OW 257
84040: PPUSH
84041: CALL 82859 0 4
// end ;
84045: GO 83894
84047: POP
84048: POP
// end ;
84049: GO 83829
84051: POP
84052: POP
// end ;
84053: LD_VAR 0 1
84057: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
84058: LD_INT 0
84060: PPUSH
84061: PPUSH
84062: PPUSH
84063: PPUSH
84064: PPUSH
84065: PPUSH
// if not mc_bases [ base ] then
84066: LD_EXP 63
84070: PUSH
84071: LD_VAR 0 1
84075: ARRAY
84076: NOT
84077: IFFALSE 84081
// exit ;
84079: GO 84282
// tmp := [ ] ;
84081: LD_ADDR_VAR 0 6
84085: PUSH
84086: EMPTY
84087: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
84088: LD_ADDR_VAR 0 7
84092: PUSH
84093: LD_VAR 0 3
84097: PPUSH
84098: LD_INT 0
84100: PPUSH
84101: CALL_OW 517
84105: ST_TO_ADDR
// if not list then
84106: LD_VAR 0 7
84110: NOT
84111: IFFALSE 84115
// exit ;
84113: GO 84282
// c := Count ( list [ 1 ] ) ;
84115: LD_ADDR_VAR 0 9
84119: PUSH
84120: LD_VAR 0 7
84124: PUSH
84125: LD_INT 1
84127: ARRAY
84128: PPUSH
84129: CALL 19462 0 1
84133: ST_TO_ADDR
// if amount > c then
84134: LD_VAR 0 2
84138: PUSH
84139: LD_VAR 0 9
84143: GREATER
84144: IFFALSE 84156
// amount := c ;
84146: LD_ADDR_VAR 0 2
84150: PUSH
84151: LD_VAR 0 9
84155: ST_TO_ADDR
// for i := 1 to amount do
84156: LD_ADDR_VAR 0 5
84160: PUSH
84161: DOUBLE
84162: LD_INT 1
84164: DEC
84165: ST_TO_ADDR
84166: LD_VAR 0 2
84170: PUSH
84171: FOR_TO
84172: IFFALSE 84230
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
84174: LD_ADDR_VAR 0 6
84178: PUSH
84179: LD_VAR 0 6
84183: PPUSH
84184: LD_VAR 0 5
84188: PPUSH
84189: LD_VAR 0 7
84193: PUSH
84194: LD_INT 1
84196: ARRAY
84197: PUSH
84198: LD_VAR 0 5
84202: ARRAY
84203: PUSH
84204: LD_VAR 0 7
84208: PUSH
84209: LD_INT 2
84211: ARRAY
84212: PUSH
84213: LD_VAR 0 5
84217: ARRAY
84218: PUSH
84219: EMPTY
84220: LIST
84221: LIST
84222: PPUSH
84223: CALL_OW 1
84227: ST_TO_ADDR
84228: GO 84171
84230: POP
84231: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
84232: LD_ADDR_EXP 76
84236: PUSH
84237: LD_EXP 76
84241: PPUSH
84242: LD_VAR 0 1
84246: PPUSH
84247: LD_VAR 0 6
84251: PPUSH
84252: CALL_OW 1
84256: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
84257: LD_ADDR_EXP 78
84261: PUSH
84262: LD_EXP 78
84266: PPUSH
84267: LD_VAR 0 1
84271: PPUSH
84272: LD_VAR 0 3
84276: PPUSH
84277: CALL_OW 1
84281: ST_TO_ADDR
// end ;
84282: LD_VAR 0 4
84286: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
84287: LD_INT 0
84289: PPUSH
// if not mc_bases [ base ] then
84290: LD_EXP 63
84294: PUSH
84295: LD_VAR 0 1
84299: ARRAY
84300: NOT
84301: IFFALSE 84305
// exit ;
84303: GO 84330
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
84305: LD_ADDR_EXP 68
84309: PUSH
84310: LD_EXP 68
84314: PPUSH
84315: LD_VAR 0 1
84319: PPUSH
84320: LD_VAR 0 2
84324: PPUSH
84325: CALL_OW 1
84329: ST_TO_ADDR
// end ;
84330: LD_VAR 0 3
84334: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
84335: LD_INT 0
84337: PPUSH
// if not mc_bases [ base ] then
84338: LD_EXP 63
84342: PUSH
84343: LD_VAR 0 1
84347: ARRAY
84348: NOT
84349: IFFALSE 84353
// exit ;
84351: GO 84390
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
84353: LD_ADDR_EXP 68
84357: PUSH
84358: LD_EXP 68
84362: PPUSH
84363: LD_VAR 0 1
84367: PPUSH
84368: LD_EXP 68
84372: PUSH
84373: LD_VAR 0 1
84377: ARRAY
84378: PUSH
84379: LD_VAR 0 2
84383: UNION
84384: PPUSH
84385: CALL_OW 1
84389: ST_TO_ADDR
// end ;
84390: LD_VAR 0 3
84394: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
84395: LD_INT 0
84397: PPUSH
// if not mc_bases [ base ] then
84398: LD_EXP 63
84402: PUSH
84403: LD_VAR 0 1
84407: ARRAY
84408: NOT
84409: IFFALSE 84413
// exit ;
84411: GO 84438
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
84413: LD_ADDR_EXP 84
84417: PUSH
84418: LD_EXP 84
84422: PPUSH
84423: LD_VAR 0 1
84427: PPUSH
84428: LD_VAR 0 2
84432: PPUSH
84433: CALL_OW 1
84437: ST_TO_ADDR
// end ;
84438: LD_VAR 0 3
84442: RET
// export function MC_InsertProduceList ( base , components ) ; begin
84443: LD_INT 0
84445: PPUSH
// if not mc_bases [ base ] then
84446: LD_EXP 63
84450: PUSH
84451: LD_VAR 0 1
84455: ARRAY
84456: NOT
84457: IFFALSE 84461
// exit ;
84459: GO 84498
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
84461: LD_ADDR_EXP 84
84465: PUSH
84466: LD_EXP 84
84470: PPUSH
84471: LD_VAR 0 1
84475: PPUSH
84476: LD_EXP 84
84480: PUSH
84481: LD_VAR 0 1
84485: ARRAY
84486: PUSH
84487: LD_VAR 0 2
84491: ADD
84492: PPUSH
84493: CALL_OW 1
84497: ST_TO_ADDR
// end ;
84498: LD_VAR 0 3
84502: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
84503: LD_INT 0
84505: PPUSH
// if not mc_bases [ base ] then
84506: LD_EXP 63
84510: PUSH
84511: LD_VAR 0 1
84515: ARRAY
84516: NOT
84517: IFFALSE 84521
// exit ;
84519: GO 84575
// mc_defender := Replace ( mc_defender , base , deflist ) ;
84521: LD_ADDR_EXP 85
84525: PUSH
84526: LD_EXP 85
84530: PPUSH
84531: LD_VAR 0 1
84535: PPUSH
84536: LD_VAR 0 2
84540: PPUSH
84541: CALL_OW 1
84545: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
84546: LD_ADDR_EXP 74
84550: PUSH
84551: LD_EXP 74
84555: PPUSH
84556: LD_VAR 0 1
84560: PPUSH
84561: LD_VAR 0 2
84565: PUSH
84566: LD_INT 0
84568: PLUS
84569: PPUSH
84570: CALL_OW 1
84574: ST_TO_ADDR
// end ;
84575: LD_VAR 0 3
84579: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
84580: LD_INT 0
84582: PPUSH
// if not mc_bases [ base ] then
84583: LD_EXP 63
84587: PUSH
84588: LD_VAR 0 1
84592: ARRAY
84593: NOT
84594: IFFALSE 84598
// exit ;
84596: GO 84623
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
84598: LD_ADDR_EXP 74
84602: PUSH
84603: LD_EXP 74
84607: PPUSH
84608: LD_VAR 0 1
84612: PPUSH
84613: LD_VAR 0 2
84617: PPUSH
84618: CALL_OW 1
84622: ST_TO_ADDR
// end ;
84623: LD_VAR 0 3
84627: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
84628: LD_INT 0
84630: PPUSH
84631: PPUSH
84632: PPUSH
84633: PPUSH
// if not mc_bases [ base ] then
84634: LD_EXP 63
84638: PUSH
84639: LD_VAR 0 1
84643: ARRAY
84644: NOT
84645: IFFALSE 84649
// exit ;
84647: GO 84714
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
84649: LD_ADDR_EXP 83
84653: PUSH
84654: LD_EXP 83
84658: PPUSH
84659: LD_VAR 0 1
84663: PUSH
84664: LD_EXP 83
84668: PUSH
84669: LD_VAR 0 1
84673: ARRAY
84674: PUSH
84675: LD_INT 1
84677: PLUS
84678: PUSH
84679: EMPTY
84680: LIST
84681: LIST
84682: PPUSH
84683: LD_VAR 0 1
84687: PUSH
84688: LD_VAR 0 2
84692: PUSH
84693: LD_VAR 0 3
84697: PUSH
84698: LD_VAR 0 4
84702: PUSH
84703: EMPTY
84704: LIST
84705: LIST
84706: LIST
84707: LIST
84708: PPUSH
84709: CALL 22322 0 3
84713: ST_TO_ADDR
// end ;
84714: LD_VAR 0 5
84718: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
84719: LD_INT 0
84721: PPUSH
// if not mc_bases [ base ] then
84722: LD_EXP 63
84726: PUSH
84727: LD_VAR 0 1
84731: ARRAY
84732: NOT
84733: IFFALSE 84737
// exit ;
84735: GO 84762
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
84737: LD_ADDR_EXP 100
84741: PUSH
84742: LD_EXP 100
84746: PPUSH
84747: LD_VAR 0 1
84751: PPUSH
84752: LD_VAR 0 2
84756: PPUSH
84757: CALL_OW 1
84761: ST_TO_ADDR
// end ;
84762: LD_VAR 0 3
84766: RET
// export function MC_GetMinesField ( base ) ; begin
84767: LD_INT 0
84769: PPUSH
// result := mc_mines [ base ] ;
84770: LD_ADDR_VAR 0 2
84774: PUSH
84775: LD_EXP 76
84779: PUSH
84780: LD_VAR 0 1
84784: ARRAY
84785: ST_TO_ADDR
// end ;
84786: LD_VAR 0 2
84790: RET
// export function MC_GetProduceList ( base ) ; begin
84791: LD_INT 0
84793: PPUSH
// result := mc_produce [ base ] ;
84794: LD_ADDR_VAR 0 2
84798: PUSH
84799: LD_EXP 84
84803: PUSH
84804: LD_VAR 0 1
84808: ARRAY
84809: ST_TO_ADDR
// end ;
84810: LD_VAR 0 2
84814: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
84815: LD_INT 0
84817: PPUSH
84818: PPUSH
// if not mc_bases then
84819: LD_EXP 63
84823: NOT
84824: IFFALSE 84828
// exit ;
84826: GO 84893
// if mc_bases [ base ] then
84828: LD_EXP 63
84832: PUSH
84833: LD_VAR 0 1
84837: ARRAY
84838: IFFALSE 84893
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84840: LD_ADDR_VAR 0 3
84844: PUSH
84845: LD_EXP 63
84849: PUSH
84850: LD_VAR 0 1
84854: ARRAY
84855: PPUSH
84856: LD_INT 30
84858: PUSH
84859: LD_VAR 0 2
84863: PUSH
84864: EMPTY
84865: LIST
84866: LIST
84867: PPUSH
84868: CALL_OW 72
84872: ST_TO_ADDR
// if result then
84873: LD_VAR 0 3
84877: IFFALSE 84893
// result := result [ 1 ] ;
84879: LD_ADDR_VAR 0 3
84883: PUSH
84884: LD_VAR 0 3
84888: PUSH
84889: LD_INT 1
84891: ARRAY
84892: ST_TO_ADDR
// end ; end ;
84893: LD_VAR 0 3
84897: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
84898: LD_INT 0
84900: PPUSH
84901: PPUSH
// if not mc_bases then
84902: LD_EXP 63
84906: NOT
84907: IFFALSE 84911
// exit ;
84909: GO 84956
// if mc_bases [ base ] then
84911: LD_EXP 63
84915: PUSH
84916: LD_VAR 0 1
84920: ARRAY
84921: IFFALSE 84956
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
84923: LD_ADDR_VAR 0 3
84927: PUSH
84928: LD_EXP 63
84932: PUSH
84933: LD_VAR 0 1
84937: ARRAY
84938: PPUSH
84939: LD_INT 30
84941: PUSH
84942: LD_VAR 0 2
84946: PUSH
84947: EMPTY
84948: LIST
84949: LIST
84950: PPUSH
84951: CALL_OW 72
84955: ST_TO_ADDR
// end ;
84956: LD_VAR 0 3
84960: RET
// export function MC_SetTame ( base , area ) ; begin
84961: LD_INT 0
84963: PPUSH
// if not mc_bases or not base then
84964: LD_EXP 63
84968: NOT
84969: PUSH
84970: LD_VAR 0 1
84974: NOT
84975: OR
84976: IFFALSE 84980
// exit ;
84978: GO 85005
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
84980: LD_ADDR_EXP 91
84984: PUSH
84985: LD_EXP 91
84989: PPUSH
84990: LD_VAR 0 1
84994: PPUSH
84995: LD_VAR 0 2
84999: PPUSH
85000: CALL_OW 1
85004: ST_TO_ADDR
// end ;
85005: LD_VAR 0 3
85009: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
85010: LD_INT 0
85012: PPUSH
85013: PPUSH
// if not mc_bases or not base then
85014: LD_EXP 63
85018: NOT
85019: PUSH
85020: LD_VAR 0 1
85024: NOT
85025: OR
85026: IFFALSE 85030
// exit ;
85028: GO 85132
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
85030: LD_ADDR_VAR 0 4
85034: PUSH
85035: LD_EXP 63
85039: PUSH
85040: LD_VAR 0 1
85044: ARRAY
85045: PPUSH
85046: LD_INT 30
85048: PUSH
85049: LD_VAR 0 2
85053: PUSH
85054: EMPTY
85055: LIST
85056: LIST
85057: PPUSH
85058: CALL_OW 72
85062: ST_TO_ADDR
// if not tmp then
85063: LD_VAR 0 4
85067: NOT
85068: IFFALSE 85072
// exit ;
85070: GO 85132
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
85072: LD_ADDR_EXP 95
85076: PUSH
85077: LD_EXP 95
85081: PPUSH
85082: LD_VAR 0 1
85086: PPUSH
85087: LD_EXP 95
85091: PUSH
85092: LD_VAR 0 1
85096: ARRAY
85097: PPUSH
85098: LD_EXP 95
85102: PUSH
85103: LD_VAR 0 1
85107: ARRAY
85108: PUSH
85109: LD_INT 1
85111: PLUS
85112: PPUSH
85113: LD_VAR 0 4
85117: PUSH
85118: LD_INT 1
85120: ARRAY
85121: PPUSH
85122: CALL_OW 2
85126: PPUSH
85127: CALL_OW 1
85131: ST_TO_ADDR
// end ;
85132: LD_VAR 0 3
85136: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
85137: LD_INT 0
85139: PPUSH
85140: PPUSH
// if not mc_bases or not base or not kinds then
85141: LD_EXP 63
85145: NOT
85146: PUSH
85147: LD_VAR 0 1
85151: NOT
85152: OR
85153: PUSH
85154: LD_VAR 0 2
85158: NOT
85159: OR
85160: IFFALSE 85164
// exit ;
85162: GO 85225
// for i in kinds do
85164: LD_ADDR_VAR 0 4
85168: PUSH
85169: LD_VAR 0 2
85173: PUSH
85174: FOR_IN
85175: IFFALSE 85223
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
85177: LD_ADDR_EXP 97
85181: PUSH
85182: LD_EXP 97
85186: PPUSH
85187: LD_VAR 0 1
85191: PUSH
85192: LD_EXP 97
85196: PUSH
85197: LD_VAR 0 1
85201: ARRAY
85202: PUSH
85203: LD_INT 1
85205: PLUS
85206: PUSH
85207: EMPTY
85208: LIST
85209: LIST
85210: PPUSH
85211: LD_VAR 0 4
85215: PPUSH
85216: CALL 22322 0 3
85220: ST_TO_ADDR
85221: GO 85174
85223: POP
85224: POP
// end ;
85225: LD_VAR 0 3
85229: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
85230: LD_INT 0
85232: PPUSH
// if not mc_bases or not base or not areas then
85233: LD_EXP 63
85237: NOT
85238: PUSH
85239: LD_VAR 0 1
85243: NOT
85244: OR
85245: PUSH
85246: LD_VAR 0 2
85250: NOT
85251: OR
85252: IFFALSE 85256
// exit ;
85254: GO 85281
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
85256: LD_ADDR_EXP 81
85260: PUSH
85261: LD_EXP 81
85265: PPUSH
85266: LD_VAR 0 1
85270: PPUSH
85271: LD_VAR 0 2
85275: PPUSH
85276: CALL_OW 1
85280: ST_TO_ADDR
// end ;
85281: LD_VAR 0 3
85285: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
85286: LD_INT 0
85288: PPUSH
// if not mc_bases or not base or not teleports_exit then
85289: LD_EXP 63
85293: NOT
85294: PUSH
85295: LD_VAR 0 1
85299: NOT
85300: OR
85301: PUSH
85302: LD_VAR 0 2
85306: NOT
85307: OR
85308: IFFALSE 85312
// exit ;
85310: GO 85337
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
85312: LD_ADDR_EXP 98
85316: PUSH
85317: LD_EXP 98
85321: PPUSH
85322: LD_VAR 0 1
85326: PPUSH
85327: LD_VAR 0 2
85331: PPUSH
85332: CALL_OW 1
85336: ST_TO_ADDR
// end ;
85337: LD_VAR 0 3
85341: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
85342: LD_INT 0
85344: PPUSH
85345: PPUSH
85346: PPUSH
// if not mc_bases or not base or not ext_list then
85347: LD_EXP 63
85351: NOT
85352: PUSH
85353: LD_VAR 0 1
85357: NOT
85358: OR
85359: PUSH
85360: LD_VAR 0 5
85364: NOT
85365: OR
85366: IFFALSE 85370
// exit ;
85368: GO 85543
// tmp := GetFacExtXYD ( x , y , d ) ;
85370: LD_ADDR_VAR 0 8
85374: PUSH
85375: LD_VAR 0 2
85379: PPUSH
85380: LD_VAR 0 3
85384: PPUSH
85385: LD_VAR 0 4
85389: PPUSH
85390: CALL 52705 0 3
85394: ST_TO_ADDR
// if not tmp then
85395: LD_VAR 0 8
85399: NOT
85400: IFFALSE 85404
// exit ;
85402: GO 85543
// for i in tmp do
85404: LD_ADDR_VAR 0 7
85408: PUSH
85409: LD_VAR 0 8
85413: PUSH
85414: FOR_IN
85415: IFFALSE 85541
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
85417: LD_ADDR_EXP 68
85421: PUSH
85422: LD_EXP 68
85426: PPUSH
85427: LD_VAR 0 1
85431: PPUSH
85432: LD_EXP 68
85436: PUSH
85437: LD_VAR 0 1
85441: ARRAY
85442: PPUSH
85443: LD_EXP 68
85447: PUSH
85448: LD_VAR 0 1
85452: ARRAY
85453: PUSH
85454: LD_INT 1
85456: PLUS
85457: PPUSH
85458: LD_VAR 0 5
85462: PUSH
85463: LD_INT 1
85465: ARRAY
85466: PUSH
85467: LD_VAR 0 7
85471: PUSH
85472: LD_INT 1
85474: ARRAY
85475: PUSH
85476: LD_VAR 0 7
85480: PUSH
85481: LD_INT 2
85483: ARRAY
85484: PUSH
85485: LD_VAR 0 7
85489: PUSH
85490: LD_INT 3
85492: ARRAY
85493: PUSH
85494: EMPTY
85495: LIST
85496: LIST
85497: LIST
85498: LIST
85499: PPUSH
85500: CALL_OW 2
85504: PPUSH
85505: CALL_OW 1
85509: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
85510: LD_ADDR_VAR 0 5
85514: PUSH
85515: LD_VAR 0 5
85519: PPUSH
85520: LD_INT 1
85522: PPUSH
85523: CALL_OW 3
85527: ST_TO_ADDR
// if not ext_list then
85528: LD_VAR 0 5
85532: NOT
85533: IFFALSE 85539
// exit ;
85535: POP
85536: POP
85537: GO 85543
// end ;
85539: GO 85414
85541: POP
85542: POP
// end ;
85543: LD_VAR 0 6
85547: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
85548: LD_INT 0
85550: PPUSH
// if not mc_bases or not base or not weapon_list then
85551: LD_EXP 63
85555: NOT
85556: PUSH
85557: LD_VAR 0 1
85561: NOT
85562: OR
85563: PUSH
85564: LD_VAR 0 2
85568: NOT
85569: OR
85570: IFFALSE 85574
// exit ;
85572: GO 85599
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
85574: LD_ADDR_EXP 102
85578: PUSH
85579: LD_EXP 102
85583: PPUSH
85584: LD_VAR 0 1
85588: PPUSH
85589: LD_VAR 0 2
85593: PPUSH
85594: CALL_OW 1
85598: ST_TO_ADDR
// end ;
85599: LD_VAR 0 3
85603: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
85604: LD_INT 0
85606: PPUSH
// if not mc_bases or not base or not tech_list then
85607: LD_EXP 63
85611: NOT
85612: PUSH
85613: LD_VAR 0 1
85617: NOT
85618: OR
85619: PUSH
85620: LD_VAR 0 2
85624: NOT
85625: OR
85626: IFFALSE 85630
// exit ;
85628: GO 85655
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
85630: LD_ADDR_EXP 90
85634: PUSH
85635: LD_EXP 90
85639: PPUSH
85640: LD_VAR 0 1
85644: PPUSH
85645: LD_VAR 0 2
85649: PPUSH
85650: CALL_OW 1
85654: ST_TO_ADDR
// end ;
85655: LD_VAR 0 3
85659: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
85660: LD_INT 0
85662: PPUSH
// if not mc_bases or not parking_area or not base then
85663: LD_EXP 63
85667: NOT
85668: PUSH
85669: LD_VAR 0 2
85673: NOT
85674: OR
85675: PUSH
85676: LD_VAR 0 1
85680: NOT
85681: OR
85682: IFFALSE 85686
// exit ;
85684: GO 85711
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
85686: LD_ADDR_EXP 87
85690: PUSH
85691: LD_EXP 87
85695: PPUSH
85696: LD_VAR 0 1
85700: PPUSH
85701: LD_VAR 0 2
85705: PPUSH
85706: CALL_OW 1
85710: ST_TO_ADDR
// end ;
85711: LD_VAR 0 3
85715: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
85716: LD_INT 0
85718: PPUSH
// if not mc_bases or not base or not scan_area then
85719: LD_EXP 63
85723: NOT
85724: PUSH
85725: LD_VAR 0 1
85729: NOT
85730: OR
85731: PUSH
85732: LD_VAR 0 2
85736: NOT
85737: OR
85738: IFFALSE 85742
// exit ;
85740: GO 85767
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
85742: LD_ADDR_EXP 88
85746: PUSH
85747: LD_EXP 88
85751: PPUSH
85752: LD_VAR 0 1
85756: PPUSH
85757: LD_VAR 0 2
85761: PPUSH
85762: CALL_OW 1
85766: ST_TO_ADDR
// end ;
85767: LD_VAR 0 3
85771: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
85772: LD_INT 0
85774: PPUSH
85775: PPUSH
// if not mc_bases or not base then
85776: LD_EXP 63
85780: NOT
85781: PUSH
85782: LD_VAR 0 1
85786: NOT
85787: OR
85788: IFFALSE 85792
// exit ;
85790: GO 85856
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
85792: LD_ADDR_VAR 0 3
85796: PUSH
85797: LD_INT 1
85799: PUSH
85800: LD_INT 2
85802: PUSH
85803: LD_INT 3
85805: PUSH
85806: LD_INT 4
85808: PUSH
85809: LD_INT 11
85811: PUSH
85812: EMPTY
85813: LIST
85814: LIST
85815: LIST
85816: LIST
85817: LIST
85818: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
85819: LD_ADDR_EXP 90
85823: PUSH
85824: LD_EXP 90
85828: PPUSH
85829: LD_VAR 0 1
85833: PPUSH
85834: LD_EXP 90
85838: PUSH
85839: LD_VAR 0 1
85843: ARRAY
85844: PUSH
85845: LD_VAR 0 3
85849: DIFF
85850: PPUSH
85851: CALL_OW 1
85855: ST_TO_ADDR
// end ;
85856: LD_VAR 0 2
85860: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
85861: LD_INT 0
85863: PPUSH
// result := mc_vehicles [ base ] ;
85864: LD_ADDR_VAR 0 3
85868: PUSH
85869: LD_EXP 82
85873: PUSH
85874: LD_VAR 0 1
85878: ARRAY
85879: ST_TO_ADDR
// if onlyCombat then
85880: LD_VAR 0 2
85884: IFFALSE 86056
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
85886: LD_ADDR_VAR 0 3
85890: PUSH
85891: LD_VAR 0 3
85895: PUSH
85896: LD_VAR 0 3
85900: PPUSH
85901: LD_INT 2
85903: PUSH
85904: LD_INT 34
85906: PUSH
85907: LD_INT 12
85909: PUSH
85910: EMPTY
85911: LIST
85912: LIST
85913: PUSH
85914: LD_INT 34
85916: PUSH
85917: LD_INT 51
85919: PUSH
85920: EMPTY
85921: LIST
85922: LIST
85923: PUSH
85924: LD_INT 34
85926: PUSH
85927: LD_INT 89
85929: PUSH
85930: EMPTY
85931: LIST
85932: LIST
85933: PUSH
85934: LD_INT 34
85936: PUSH
85937: LD_INT 32
85939: PUSH
85940: EMPTY
85941: LIST
85942: LIST
85943: PUSH
85944: LD_INT 34
85946: PUSH
85947: LD_INT 13
85949: PUSH
85950: EMPTY
85951: LIST
85952: LIST
85953: PUSH
85954: LD_INT 34
85956: PUSH
85957: LD_INT 52
85959: PUSH
85960: EMPTY
85961: LIST
85962: LIST
85963: PUSH
85964: LD_INT 34
85966: PUSH
85967: LD_INT 88
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 34
85976: PUSH
85977: LD_INT 14
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 34
85986: PUSH
85987: LD_INT 53
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 34
85996: PUSH
85997: LD_INT 98
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: LD_INT 34
86006: PUSH
86007: LD_INT 31
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: PUSH
86014: LD_INT 34
86016: PUSH
86017: LD_INT 48
86019: PUSH
86020: EMPTY
86021: LIST
86022: LIST
86023: PUSH
86024: LD_INT 34
86026: PUSH
86027: LD_INT 8
86029: PUSH
86030: EMPTY
86031: LIST
86032: LIST
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: LIST
86042: LIST
86043: LIST
86044: LIST
86045: LIST
86046: LIST
86047: LIST
86048: LIST
86049: PPUSH
86050: CALL_OW 72
86054: DIFF
86055: ST_TO_ADDR
// end ; end_of_file
86056: LD_VAR 0 3
86060: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
86061: LD_INT 0
86063: PPUSH
86064: PPUSH
86065: PPUSH
// if not mc_bases or not skirmish then
86066: LD_EXP 63
86070: NOT
86071: PUSH
86072: LD_EXP 61
86076: NOT
86077: OR
86078: IFFALSE 86082
// exit ;
86080: GO 86247
// for i = 1 to mc_bases do
86082: LD_ADDR_VAR 0 4
86086: PUSH
86087: DOUBLE
86088: LD_INT 1
86090: DEC
86091: ST_TO_ADDR
86092: LD_EXP 63
86096: PUSH
86097: FOR_TO
86098: IFFALSE 86245
// begin if sci in mc_bases [ i ] then
86100: LD_VAR 0 2
86104: PUSH
86105: LD_EXP 63
86109: PUSH
86110: LD_VAR 0 4
86114: ARRAY
86115: IN
86116: IFFALSE 86243
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
86118: LD_ADDR_EXP 92
86122: PUSH
86123: LD_EXP 92
86127: PPUSH
86128: LD_VAR 0 4
86132: PUSH
86133: LD_EXP 92
86137: PUSH
86138: LD_VAR 0 4
86142: ARRAY
86143: PUSH
86144: LD_INT 1
86146: PLUS
86147: PUSH
86148: EMPTY
86149: LIST
86150: LIST
86151: PPUSH
86152: LD_VAR 0 1
86156: PPUSH
86157: CALL 22322 0 3
86161: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
86162: LD_ADDR_VAR 0 5
86166: PUSH
86167: LD_EXP 63
86171: PUSH
86172: LD_VAR 0 4
86176: ARRAY
86177: PPUSH
86178: LD_INT 2
86180: PUSH
86181: LD_INT 30
86183: PUSH
86184: LD_INT 0
86186: PUSH
86187: EMPTY
86188: LIST
86189: LIST
86190: PUSH
86191: LD_INT 30
86193: PUSH
86194: LD_INT 1
86196: PUSH
86197: EMPTY
86198: LIST
86199: LIST
86200: PUSH
86201: EMPTY
86202: LIST
86203: LIST
86204: LIST
86205: PPUSH
86206: CALL_OW 72
86210: PPUSH
86211: LD_VAR 0 1
86215: PPUSH
86216: CALL_OW 74
86220: ST_TO_ADDR
// if tmp then
86221: LD_VAR 0 5
86225: IFFALSE 86241
// ComStandNearbyBuilding ( ape , tmp ) ;
86227: LD_VAR 0 1
86231: PPUSH
86232: LD_VAR 0 5
86236: PPUSH
86237: CALL 18924 0 2
// break ;
86241: GO 86245
// end ; end ;
86243: GO 86097
86245: POP
86246: POP
// end ;
86247: LD_VAR 0 3
86251: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
86252: LD_INT 0
86254: PPUSH
86255: PPUSH
86256: PPUSH
// if not mc_bases or not skirmish then
86257: LD_EXP 63
86261: NOT
86262: PUSH
86263: LD_EXP 61
86267: NOT
86268: OR
86269: IFFALSE 86273
// exit ;
86271: GO 86362
// for i = 1 to mc_bases do
86273: LD_ADDR_VAR 0 4
86277: PUSH
86278: DOUBLE
86279: LD_INT 1
86281: DEC
86282: ST_TO_ADDR
86283: LD_EXP 63
86287: PUSH
86288: FOR_TO
86289: IFFALSE 86360
// begin if building in mc_busy_turret_list [ i ] then
86291: LD_VAR 0 1
86295: PUSH
86296: LD_EXP 73
86300: PUSH
86301: LD_VAR 0 4
86305: ARRAY
86306: IN
86307: IFFALSE 86358
// begin tmp := mc_busy_turret_list [ i ] diff building ;
86309: LD_ADDR_VAR 0 5
86313: PUSH
86314: LD_EXP 73
86318: PUSH
86319: LD_VAR 0 4
86323: ARRAY
86324: PUSH
86325: LD_VAR 0 1
86329: DIFF
86330: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
86331: LD_ADDR_EXP 73
86335: PUSH
86336: LD_EXP 73
86340: PPUSH
86341: LD_VAR 0 4
86345: PPUSH
86346: LD_VAR 0 5
86350: PPUSH
86351: CALL_OW 1
86355: ST_TO_ADDR
// break ;
86356: GO 86360
// end ; end ;
86358: GO 86288
86360: POP
86361: POP
// end ;
86362: LD_VAR 0 3
86366: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
86367: LD_INT 0
86369: PPUSH
86370: PPUSH
86371: PPUSH
// if not mc_bases or not skirmish then
86372: LD_EXP 63
86376: NOT
86377: PUSH
86378: LD_EXP 61
86382: NOT
86383: OR
86384: IFFALSE 86388
// exit ;
86386: GO 86587
// for i = 1 to mc_bases do
86388: LD_ADDR_VAR 0 5
86392: PUSH
86393: DOUBLE
86394: LD_INT 1
86396: DEC
86397: ST_TO_ADDR
86398: LD_EXP 63
86402: PUSH
86403: FOR_TO
86404: IFFALSE 86585
// if building in mc_bases [ i ] then
86406: LD_VAR 0 1
86410: PUSH
86411: LD_EXP 63
86415: PUSH
86416: LD_VAR 0 5
86420: ARRAY
86421: IN
86422: IFFALSE 86583
// begin tmp := mc_bases [ i ] diff building ;
86424: LD_ADDR_VAR 0 6
86428: PUSH
86429: LD_EXP 63
86433: PUSH
86434: LD_VAR 0 5
86438: ARRAY
86439: PUSH
86440: LD_VAR 0 1
86444: DIFF
86445: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
86446: LD_ADDR_EXP 63
86450: PUSH
86451: LD_EXP 63
86455: PPUSH
86456: LD_VAR 0 5
86460: PPUSH
86461: LD_VAR 0 6
86465: PPUSH
86466: CALL_OW 1
86470: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
86471: LD_VAR 0 1
86475: PUSH
86476: LD_EXP 71
86480: PUSH
86481: LD_VAR 0 5
86485: ARRAY
86486: IN
86487: IFFALSE 86526
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
86489: LD_ADDR_EXP 71
86493: PUSH
86494: LD_EXP 71
86498: PPUSH
86499: LD_VAR 0 5
86503: PPUSH
86504: LD_EXP 71
86508: PUSH
86509: LD_VAR 0 5
86513: ARRAY
86514: PUSH
86515: LD_VAR 0 1
86519: DIFF
86520: PPUSH
86521: CALL_OW 1
86525: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
86526: LD_VAR 0 1
86530: PUSH
86531: LD_EXP 72
86535: PUSH
86536: LD_VAR 0 5
86540: ARRAY
86541: IN
86542: IFFALSE 86581
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
86544: LD_ADDR_EXP 72
86548: PUSH
86549: LD_EXP 72
86553: PPUSH
86554: LD_VAR 0 5
86558: PPUSH
86559: LD_EXP 72
86563: PUSH
86564: LD_VAR 0 5
86568: ARRAY
86569: PUSH
86570: LD_VAR 0 1
86574: DIFF
86575: PPUSH
86576: CALL_OW 1
86580: ST_TO_ADDR
// break ;
86581: GO 86585
// end ;
86583: GO 86403
86585: POP
86586: POP
// end ;
86587: LD_VAR 0 4
86591: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
86592: LD_INT 0
86594: PPUSH
86595: PPUSH
86596: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
86597: LD_EXP 63
86601: NOT
86602: PUSH
86603: LD_EXP 61
86607: NOT
86608: OR
86609: PUSH
86610: LD_VAR 0 3
86614: PUSH
86615: LD_EXP 89
86619: IN
86620: NOT
86621: OR
86622: IFFALSE 86626
// exit ;
86624: GO 86749
// for i = 1 to mc_vehicles do
86626: LD_ADDR_VAR 0 6
86630: PUSH
86631: DOUBLE
86632: LD_INT 1
86634: DEC
86635: ST_TO_ADDR
86636: LD_EXP 82
86640: PUSH
86641: FOR_TO
86642: IFFALSE 86747
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
86644: LD_VAR 0 2
86648: PUSH
86649: LD_EXP 82
86653: PUSH
86654: LD_VAR 0 6
86658: ARRAY
86659: IN
86660: PUSH
86661: LD_VAR 0 1
86665: PUSH
86666: LD_EXP 82
86670: PUSH
86671: LD_VAR 0 6
86675: ARRAY
86676: IN
86677: OR
86678: IFFALSE 86745
// begin tmp := mc_vehicles [ i ] diff old ;
86680: LD_ADDR_VAR 0 7
86684: PUSH
86685: LD_EXP 82
86689: PUSH
86690: LD_VAR 0 6
86694: ARRAY
86695: PUSH
86696: LD_VAR 0 2
86700: DIFF
86701: ST_TO_ADDR
// tmp := tmp diff new ;
86702: LD_ADDR_VAR 0 7
86706: PUSH
86707: LD_VAR 0 7
86711: PUSH
86712: LD_VAR 0 1
86716: DIFF
86717: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
86718: LD_ADDR_EXP 82
86722: PUSH
86723: LD_EXP 82
86727: PPUSH
86728: LD_VAR 0 6
86732: PPUSH
86733: LD_VAR 0 7
86737: PPUSH
86738: CALL_OW 1
86742: ST_TO_ADDR
// break ;
86743: GO 86747
// end ;
86745: GO 86641
86747: POP
86748: POP
// end ;
86749: LD_VAR 0 5
86753: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
86754: LD_INT 0
86756: PPUSH
86757: PPUSH
86758: PPUSH
86759: PPUSH
// if not mc_bases or not skirmish then
86760: LD_EXP 63
86764: NOT
86765: PUSH
86766: LD_EXP 61
86770: NOT
86771: OR
86772: IFFALSE 86776
// exit ;
86774: GO 87196
// repeat wait ( 0 0$1 ) ;
86776: LD_INT 35
86778: PPUSH
86779: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
86783: LD_EXP 107
86787: NOT
86788: IFFALSE 86776
// mc_block_vehicle_constructed_thread := true ;
86790: LD_ADDR_EXP 107
86794: PUSH
86795: LD_INT 1
86797: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
86798: LD_ADDR_VAR 0 5
86802: PUSH
86803: LD_VAR 0 1
86807: PPUSH
86808: CALL_OW 255
86812: ST_TO_ADDR
// for i = 1 to mc_bases do
86813: LD_ADDR_VAR 0 4
86817: PUSH
86818: DOUBLE
86819: LD_INT 1
86821: DEC
86822: ST_TO_ADDR
86823: LD_EXP 63
86827: PUSH
86828: FOR_TO
86829: IFFALSE 87186
// begin if factory in mc_bases [ i ] then
86831: LD_VAR 0 2
86835: PUSH
86836: LD_EXP 63
86840: PUSH
86841: LD_VAR 0 4
86845: ARRAY
86846: IN
86847: IFFALSE 87184
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
86849: LD_EXP 85
86853: PUSH
86854: LD_VAR 0 4
86858: ARRAY
86859: PUSH
86860: LD_EXP 74
86864: PUSH
86865: LD_VAR 0 4
86869: ARRAY
86870: LESS
86871: PUSH
86872: LD_VAR 0 1
86876: PPUSH
86877: CALL_OW 264
86881: PUSH
86882: LD_INT 31
86884: PUSH
86885: LD_INT 32
86887: PUSH
86888: LD_INT 51
86890: PUSH
86891: LD_INT 89
86893: PUSH
86894: LD_INT 12
86896: PUSH
86897: LD_INT 30
86899: PUSH
86900: LD_INT 98
86902: PUSH
86903: LD_INT 11
86905: PUSH
86906: LD_INT 53
86908: PUSH
86909: LD_INT 14
86911: PUSH
86912: LD_INT 91
86914: PUSH
86915: LD_INT 29
86917: PUSH
86918: LD_INT 99
86920: PUSH
86921: LD_INT 13
86923: PUSH
86924: LD_INT 52
86926: PUSH
86927: LD_INT 88
86929: PUSH
86930: LD_INT 48
86932: PUSH
86933: LD_INT 8
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: LIST
86953: LIST
86954: LIST
86955: IN
86956: NOT
86957: AND
86958: IFFALSE 87006
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
86960: LD_ADDR_EXP 85
86964: PUSH
86965: LD_EXP 85
86969: PPUSH
86970: LD_VAR 0 4
86974: PUSH
86975: LD_EXP 85
86979: PUSH
86980: LD_VAR 0 4
86984: ARRAY
86985: PUSH
86986: LD_INT 1
86988: PLUS
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PPUSH
86994: LD_VAR 0 1
86998: PPUSH
86999: CALL 22322 0 3
87003: ST_TO_ADDR
87004: GO 87050
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
87006: LD_ADDR_EXP 82
87010: PUSH
87011: LD_EXP 82
87015: PPUSH
87016: LD_VAR 0 4
87020: PUSH
87021: LD_EXP 82
87025: PUSH
87026: LD_VAR 0 4
87030: ARRAY
87031: PUSH
87032: LD_INT 1
87034: PLUS
87035: PUSH
87036: EMPTY
87037: LIST
87038: LIST
87039: PPUSH
87040: LD_VAR 0 1
87044: PPUSH
87045: CALL 22322 0 3
87049: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
87050: LD_ADDR_EXP 107
87054: PUSH
87055: LD_INT 0
87057: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
87058: LD_VAR 0 1
87062: PPUSH
87063: CALL_OW 263
87067: PUSH
87068: LD_INT 2
87070: EQUAL
87071: IFFALSE 87100
// begin repeat wait ( 0 0$3 ) ;
87073: LD_INT 105
87075: PPUSH
87076: CALL_OW 67
// Connect ( vehicle ) ;
87080: LD_VAR 0 1
87084: PPUSH
87085: CALL 25668 0 1
// until IsControledBy ( vehicle ) ;
87089: LD_VAR 0 1
87093: PPUSH
87094: CALL_OW 312
87098: IFFALSE 87073
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
87100: LD_VAR 0 1
87104: PPUSH
87105: LD_EXP 87
87109: PUSH
87110: LD_VAR 0 4
87114: ARRAY
87115: PPUSH
87116: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
87120: LD_VAR 0 1
87124: PPUSH
87125: CALL_OW 263
87129: PUSH
87130: LD_INT 1
87132: NONEQUAL
87133: IFFALSE 87137
// break ;
87135: GO 87186
// repeat wait ( 0 0$1 ) ;
87137: LD_INT 35
87139: PPUSH
87140: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
87144: LD_VAR 0 1
87148: PPUSH
87149: LD_EXP 87
87153: PUSH
87154: LD_VAR 0 4
87158: ARRAY
87159: PPUSH
87160: CALL_OW 308
87164: IFFALSE 87137
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
87166: LD_VAR 0 1
87170: PPUSH
87171: CALL_OW 311
87175: PPUSH
87176: CALL_OW 121
// exit ;
87180: POP
87181: POP
87182: GO 87196
// end ; end ;
87184: GO 86828
87186: POP
87187: POP
// mc_block_vehicle_constructed_thread := false ;
87188: LD_ADDR_EXP 107
87192: PUSH
87193: LD_INT 0
87195: ST_TO_ADDR
// end ;
87196: LD_VAR 0 3
87200: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
87201: LD_INT 0
87203: PPUSH
87204: PPUSH
87205: PPUSH
87206: PPUSH
// if not mc_bases or not skirmish then
87207: LD_EXP 63
87211: NOT
87212: PUSH
87213: LD_EXP 61
87217: NOT
87218: OR
87219: IFFALSE 87223
// exit ;
87221: GO 87576
// repeat wait ( 0 0$1 ) ;
87223: LD_INT 35
87225: PPUSH
87226: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
87230: LD_VAR 0 2
87234: PPUSH
87235: LD_VAR 0 3
87239: PPUSH
87240: CALL_OW 284
87244: IFFALSE 87223
// if GetResourceTypeXY ( x , y ) = mat_artefact then
87246: LD_VAR 0 2
87250: PPUSH
87251: LD_VAR 0 3
87255: PPUSH
87256: CALL_OW 283
87260: PUSH
87261: LD_INT 4
87263: EQUAL
87264: IFFALSE 87268
// exit ;
87266: GO 87576
// for i = 1 to mc_bases do
87268: LD_ADDR_VAR 0 7
87272: PUSH
87273: DOUBLE
87274: LD_INT 1
87276: DEC
87277: ST_TO_ADDR
87278: LD_EXP 63
87282: PUSH
87283: FOR_TO
87284: IFFALSE 87574
// begin if mc_crates_area [ i ] then
87286: LD_EXP 81
87290: PUSH
87291: LD_VAR 0 7
87295: ARRAY
87296: IFFALSE 87407
// for j in mc_crates_area [ i ] do
87298: LD_ADDR_VAR 0 8
87302: PUSH
87303: LD_EXP 81
87307: PUSH
87308: LD_VAR 0 7
87312: ARRAY
87313: PUSH
87314: FOR_IN
87315: IFFALSE 87405
// if InArea ( x , y , j ) then
87317: LD_VAR 0 2
87321: PPUSH
87322: LD_VAR 0 3
87326: PPUSH
87327: LD_VAR 0 8
87331: PPUSH
87332: CALL_OW 309
87336: IFFALSE 87403
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87338: LD_ADDR_EXP 79
87342: PUSH
87343: LD_EXP 79
87347: PPUSH
87348: LD_VAR 0 7
87352: PUSH
87353: LD_EXP 79
87357: PUSH
87358: LD_VAR 0 7
87362: ARRAY
87363: PUSH
87364: LD_INT 1
87366: PLUS
87367: PUSH
87368: EMPTY
87369: LIST
87370: LIST
87371: PPUSH
87372: LD_VAR 0 4
87376: PUSH
87377: LD_VAR 0 2
87381: PUSH
87382: LD_VAR 0 3
87386: PUSH
87387: EMPTY
87388: LIST
87389: LIST
87390: LIST
87391: PPUSH
87392: CALL 22322 0 3
87396: ST_TO_ADDR
// exit ;
87397: POP
87398: POP
87399: POP
87400: POP
87401: GO 87576
// end ;
87403: GO 87314
87405: POP
87406: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
87407: LD_ADDR_VAR 0 9
87411: PUSH
87412: LD_EXP 63
87416: PUSH
87417: LD_VAR 0 7
87421: ARRAY
87422: PPUSH
87423: LD_INT 2
87425: PUSH
87426: LD_INT 30
87428: PUSH
87429: LD_INT 0
87431: PUSH
87432: EMPTY
87433: LIST
87434: LIST
87435: PUSH
87436: LD_INT 30
87438: PUSH
87439: LD_INT 1
87441: PUSH
87442: EMPTY
87443: LIST
87444: LIST
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: LIST
87450: PPUSH
87451: CALL_OW 72
87455: ST_TO_ADDR
// if not depot then
87456: LD_VAR 0 9
87460: NOT
87461: IFFALSE 87465
// continue ;
87463: GO 87283
// for j in depot do
87465: LD_ADDR_VAR 0 8
87469: PUSH
87470: LD_VAR 0 9
87474: PUSH
87475: FOR_IN
87476: IFFALSE 87570
// if GetDistUnitXY ( j , x , y ) < 30 then
87478: LD_VAR 0 8
87482: PPUSH
87483: LD_VAR 0 2
87487: PPUSH
87488: LD_VAR 0 3
87492: PPUSH
87493: CALL_OW 297
87497: PUSH
87498: LD_INT 30
87500: LESS
87501: IFFALSE 87568
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
87503: LD_ADDR_EXP 79
87507: PUSH
87508: LD_EXP 79
87512: PPUSH
87513: LD_VAR 0 7
87517: PUSH
87518: LD_EXP 79
87522: PUSH
87523: LD_VAR 0 7
87527: ARRAY
87528: PUSH
87529: LD_INT 1
87531: PLUS
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: PPUSH
87537: LD_VAR 0 4
87541: PUSH
87542: LD_VAR 0 2
87546: PUSH
87547: LD_VAR 0 3
87551: PUSH
87552: EMPTY
87553: LIST
87554: LIST
87555: LIST
87556: PPUSH
87557: CALL 22322 0 3
87561: ST_TO_ADDR
// exit ;
87562: POP
87563: POP
87564: POP
87565: POP
87566: GO 87576
// end ;
87568: GO 87475
87570: POP
87571: POP
// end ;
87572: GO 87283
87574: POP
87575: POP
// end ;
87576: LD_VAR 0 6
87580: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
87581: LD_INT 0
87583: PPUSH
87584: PPUSH
87585: PPUSH
87586: PPUSH
// if not mc_bases or not skirmish then
87587: LD_EXP 63
87591: NOT
87592: PUSH
87593: LD_EXP 61
87597: NOT
87598: OR
87599: IFFALSE 87603
// exit ;
87601: GO 87880
// side := GetSide ( lab ) ;
87603: LD_ADDR_VAR 0 4
87607: PUSH
87608: LD_VAR 0 2
87612: PPUSH
87613: CALL_OW 255
87617: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
87618: LD_VAR 0 4
87622: PUSH
87623: LD_EXP 89
87627: IN
87628: NOT
87629: PUSH
87630: LD_EXP 90
87634: NOT
87635: OR
87636: PUSH
87637: LD_EXP 63
87641: NOT
87642: OR
87643: IFFALSE 87647
// exit ;
87645: GO 87880
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
87647: LD_ADDR_EXP 90
87651: PUSH
87652: LD_EXP 90
87656: PPUSH
87657: LD_VAR 0 4
87661: PPUSH
87662: LD_EXP 90
87666: PUSH
87667: LD_VAR 0 4
87671: ARRAY
87672: PUSH
87673: LD_VAR 0 1
87677: DIFF
87678: PPUSH
87679: CALL_OW 1
87683: ST_TO_ADDR
// for i = 1 to mc_bases do
87684: LD_ADDR_VAR 0 5
87688: PUSH
87689: DOUBLE
87690: LD_INT 1
87692: DEC
87693: ST_TO_ADDR
87694: LD_EXP 63
87698: PUSH
87699: FOR_TO
87700: IFFALSE 87878
// begin if lab in mc_bases [ i ] then
87702: LD_VAR 0 2
87706: PUSH
87707: LD_EXP 63
87711: PUSH
87712: LD_VAR 0 5
87716: ARRAY
87717: IN
87718: IFFALSE 87876
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
87720: LD_VAR 0 1
87724: PUSH
87725: LD_INT 11
87727: PUSH
87728: LD_INT 4
87730: PUSH
87731: LD_INT 3
87733: PUSH
87734: LD_INT 2
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: LIST
87741: LIST
87742: IN
87743: PUSH
87744: LD_EXP 93
87748: PUSH
87749: LD_VAR 0 5
87753: ARRAY
87754: AND
87755: IFFALSE 87876
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
87757: LD_ADDR_VAR 0 6
87761: PUSH
87762: LD_EXP 93
87766: PUSH
87767: LD_VAR 0 5
87771: ARRAY
87772: PUSH
87773: LD_INT 1
87775: ARRAY
87776: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
87777: LD_ADDR_EXP 93
87781: PUSH
87782: LD_EXP 93
87786: PPUSH
87787: LD_VAR 0 5
87791: PPUSH
87792: EMPTY
87793: PPUSH
87794: CALL_OW 1
87798: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
87799: LD_VAR 0 6
87803: PPUSH
87804: LD_INT 0
87806: PPUSH
87807: CALL_OW 109
// ComExitBuilding ( tmp ) ;
87811: LD_VAR 0 6
87815: PPUSH
87816: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
87820: LD_ADDR_EXP 92
87824: PUSH
87825: LD_EXP 92
87829: PPUSH
87830: LD_VAR 0 5
87834: PPUSH
87835: LD_EXP 92
87839: PUSH
87840: LD_VAR 0 5
87844: ARRAY
87845: PPUSH
87846: LD_INT 1
87848: PPUSH
87849: LD_VAR 0 6
87853: PPUSH
87854: CALL_OW 2
87858: PPUSH
87859: CALL_OW 1
87863: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
87864: LD_VAR 0 5
87868: PPUSH
87869: LD_INT 112
87871: PPUSH
87872: CALL 64330 0 2
// end ; end ; end ;
87876: GO 87699
87878: POP
87879: POP
// end ;
87880: LD_VAR 0 3
87884: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
87885: LD_INT 0
87887: PPUSH
87888: PPUSH
87889: PPUSH
87890: PPUSH
87891: PPUSH
87892: PPUSH
87893: PPUSH
87894: PPUSH
// if not mc_bases or not skirmish then
87895: LD_EXP 63
87899: NOT
87900: PUSH
87901: LD_EXP 61
87905: NOT
87906: OR
87907: IFFALSE 87911
// exit ;
87909: GO 89280
// for i = 1 to mc_bases do
87911: LD_ADDR_VAR 0 3
87915: PUSH
87916: DOUBLE
87917: LD_INT 1
87919: DEC
87920: ST_TO_ADDR
87921: LD_EXP 63
87925: PUSH
87926: FOR_TO
87927: IFFALSE 89278
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
87929: LD_VAR 0 1
87933: PUSH
87934: LD_EXP 63
87938: PUSH
87939: LD_VAR 0 3
87943: ARRAY
87944: IN
87945: PUSH
87946: LD_VAR 0 1
87950: PUSH
87951: LD_EXP 70
87955: PUSH
87956: LD_VAR 0 3
87960: ARRAY
87961: IN
87962: OR
87963: PUSH
87964: LD_VAR 0 1
87968: PUSH
87969: LD_EXP 85
87973: PUSH
87974: LD_VAR 0 3
87978: ARRAY
87979: IN
87980: OR
87981: PUSH
87982: LD_VAR 0 1
87986: PUSH
87987: LD_EXP 82
87991: PUSH
87992: LD_VAR 0 3
87996: ARRAY
87997: IN
87998: OR
87999: PUSH
88000: LD_VAR 0 1
88004: PUSH
88005: LD_EXP 92
88009: PUSH
88010: LD_VAR 0 3
88014: ARRAY
88015: IN
88016: OR
88017: PUSH
88018: LD_VAR 0 1
88022: PUSH
88023: LD_EXP 93
88027: PUSH
88028: LD_VAR 0 3
88032: ARRAY
88033: IN
88034: OR
88035: IFFALSE 89276
// begin if un in mc_ape [ i ] then
88037: LD_VAR 0 1
88041: PUSH
88042: LD_EXP 92
88046: PUSH
88047: LD_VAR 0 3
88051: ARRAY
88052: IN
88053: IFFALSE 88092
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
88055: LD_ADDR_EXP 92
88059: PUSH
88060: LD_EXP 92
88064: PPUSH
88065: LD_VAR 0 3
88069: PPUSH
88070: LD_EXP 92
88074: PUSH
88075: LD_VAR 0 3
88079: ARRAY
88080: PUSH
88081: LD_VAR 0 1
88085: DIFF
88086: PPUSH
88087: CALL_OW 1
88091: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
88092: LD_VAR 0 1
88096: PUSH
88097: LD_EXP 93
88101: PUSH
88102: LD_VAR 0 3
88106: ARRAY
88107: IN
88108: IFFALSE 88132
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
88110: LD_ADDR_EXP 93
88114: PUSH
88115: LD_EXP 93
88119: PPUSH
88120: LD_VAR 0 3
88124: PPUSH
88125: EMPTY
88126: PPUSH
88127: CALL_OW 1
88131: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
88132: LD_VAR 0 1
88136: PPUSH
88137: CALL_OW 247
88141: PUSH
88142: LD_INT 2
88144: EQUAL
88145: PUSH
88146: LD_VAR 0 1
88150: PPUSH
88151: CALL_OW 110
88155: PUSH
88156: LD_INT 20
88158: EQUAL
88159: PUSH
88160: LD_VAR 0 1
88164: PUSH
88165: LD_EXP 85
88169: PUSH
88170: LD_VAR 0 3
88174: ARRAY
88175: IN
88176: OR
88177: PUSH
88178: LD_VAR 0 1
88182: PPUSH
88183: CALL_OW 264
88187: PUSH
88188: LD_INT 12
88190: PUSH
88191: LD_INT 51
88193: PUSH
88194: LD_INT 89
88196: PUSH
88197: LD_INT 32
88199: PUSH
88200: LD_INT 13
88202: PUSH
88203: LD_INT 52
88205: PUSH
88206: LD_INT 31
88208: PUSH
88209: EMPTY
88210: LIST
88211: LIST
88212: LIST
88213: LIST
88214: LIST
88215: LIST
88216: LIST
88217: IN
88218: OR
88219: AND
88220: IFFALSE 88528
// begin if un in mc_defender [ i ] then
88222: LD_VAR 0 1
88226: PUSH
88227: LD_EXP 85
88231: PUSH
88232: LD_VAR 0 3
88236: ARRAY
88237: IN
88238: IFFALSE 88277
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
88240: LD_ADDR_EXP 85
88244: PUSH
88245: LD_EXP 85
88249: PPUSH
88250: LD_VAR 0 3
88254: PPUSH
88255: LD_EXP 85
88259: PUSH
88260: LD_VAR 0 3
88264: ARRAY
88265: PUSH
88266: LD_VAR 0 1
88270: DIFF
88271: PPUSH
88272: CALL_OW 1
88276: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
88277: LD_ADDR_VAR 0 8
88281: PUSH
88282: LD_VAR 0 3
88286: PPUSH
88287: LD_INT 3
88289: PPUSH
88290: CALL 84898 0 2
88294: ST_TO_ADDR
// if fac then
88295: LD_VAR 0 8
88299: IFFALSE 88528
// begin for j in fac do
88301: LD_ADDR_VAR 0 4
88305: PUSH
88306: LD_VAR 0 8
88310: PUSH
88311: FOR_IN
88312: IFFALSE 88526
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
88314: LD_ADDR_VAR 0 9
88318: PUSH
88319: LD_VAR 0 8
88323: PPUSH
88324: LD_VAR 0 1
88328: PPUSH
88329: CALL_OW 265
88333: PPUSH
88334: LD_VAR 0 1
88338: PPUSH
88339: CALL_OW 262
88343: PPUSH
88344: LD_VAR 0 1
88348: PPUSH
88349: CALL_OW 263
88353: PPUSH
88354: LD_VAR 0 1
88358: PPUSH
88359: CALL_OW 264
88363: PPUSH
88364: CALL 19820 0 5
88368: ST_TO_ADDR
// if components then
88369: LD_VAR 0 9
88373: IFFALSE 88524
// begin if GetWeapon ( un ) = ar_control_tower then
88375: LD_VAR 0 1
88379: PPUSH
88380: CALL_OW 264
88384: PUSH
88385: LD_INT 31
88387: EQUAL
88388: IFFALSE 88505
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
88390: LD_VAR 0 1
88394: PPUSH
88395: CALL_OW 311
88399: PPUSH
88400: LD_INT 0
88402: PPUSH
88403: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
88407: LD_ADDR_EXP 103
88411: PUSH
88412: LD_EXP 103
88416: PPUSH
88417: LD_VAR 0 3
88421: PPUSH
88422: LD_EXP 103
88426: PUSH
88427: LD_VAR 0 3
88431: ARRAY
88432: PUSH
88433: LD_VAR 0 1
88437: PPUSH
88438: CALL_OW 311
88442: DIFF
88443: PPUSH
88444: CALL_OW 1
88448: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
88449: LD_ADDR_VAR 0 7
88453: PUSH
88454: LD_EXP 84
88458: PUSH
88459: LD_VAR 0 3
88463: ARRAY
88464: PPUSH
88465: LD_INT 1
88467: PPUSH
88468: LD_VAR 0 9
88472: PPUSH
88473: CALL_OW 2
88477: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
88478: LD_ADDR_EXP 84
88482: PUSH
88483: LD_EXP 84
88487: PPUSH
88488: LD_VAR 0 3
88492: PPUSH
88493: LD_VAR 0 7
88497: PPUSH
88498: CALL_OW 1
88502: ST_TO_ADDR
// end else
88503: GO 88522
// MC_InsertProduceList ( i , [ components ] ) ;
88505: LD_VAR 0 3
88509: PPUSH
88510: LD_VAR 0 9
88514: PUSH
88515: EMPTY
88516: LIST
88517: PPUSH
88518: CALL 84443 0 2
// break ;
88522: GO 88526
// end ; end ;
88524: GO 88311
88526: POP
88527: POP
// end ; end ; if GetType ( un ) = unit_building then
88528: LD_VAR 0 1
88532: PPUSH
88533: CALL_OW 247
88537: PUSH
88538: LD_INT 3
88540: EQUAL
88541: IFFALSE 88944
// begin btype := GetBType ( un ) ;
88543: LD_ADDR_VAR 0 5
88547: PUSH
88548: LD_VAR 0 1
88552: PPUSH
88553: CALL_OW 266
88557: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
88558: LD_VAR 0 5
88562: PUSH
88563: LD_INT 29
88565: PUSH
88566: LD_INT 30
88568: PUSH
88569: EMPTY
88570: LIST
88571: LIST
88572: IN
88573: IFFALSE 88646
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
88575: LD_VAR 0 1
88579: PPUSH
88580: CALL_OW 250
88584: PPUSH
88585: LD_VAR 0 1
88589: PPUSH
88590: CALL_OW 251
88594: PPUSH
88595: LD_VAR 0 1
88599: PPUSH
88600: CALL_OW 255
88604: PPUSH
88605: CALL_OW 440
88609: NOT
88610: IFFALSE 88646
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
88612: LD_VAR 0 1
88616: PPUSH
88617: CALL_OW 250
88621: PPUSH
88622: LD_VAR 0 1
88626: PPUSH
88627: CALL_OW 251
88631: PPUSH
88632: LD_VAR 0 1
88636: PPUSH
88637: CALL_OW 255
88641: PPUSH
88642: CALL_OW 441
// end ; if btype = b_warehouse then
88646: LD_VAR 0 5
88650: PUSH
88651: LD_INT 1
88653: EQUAL
88654: IFFALSE 88672
// begin btype := b_depot ;
88656: LD_ADDR_VAR 0 5
88660: PUSH
88661: LD_INT 0
88663: ST_TO_ADDR
// pos := 1 ;
88664: LD_ADDR_VAR 0 6
88668: PUSH
88669: LD_INT 1
88671: ST_TO_ADDR
// end ; if btype = b_factory then
88672: LD_VAR 0 5
88676: PUSH
88677: LD_INT 3
88679: EQUAL
88680: IFFALSE 88698
// begin btype := b_workshop ;
88682: LD_ADDR_VAR 0 5
88686: PUSH
88687: LD_INT 2
88689: ST_TO_ADDR
// pos := 1 ;
88690: LD_ADDR_VAR 0 6
88694: PUSH
88695: LD_INT 1
88697: ST_TO_ADDR
// end ; if btype = b_barracks then
88698: LD_VAR 0 5
88702: PUSH
88703: LD_INT 5
88705: EQUAL
88706: IFFALSE 88716
// btype := b_armoury ;
88708: LD_ADDR_VAR 0 5
88712: PUSH
88713: LD_INT 4
88715: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
88716: LD_VAR 0 5
88720: PUSH
88721: LD_INT 7
88723: PUSH
88724: LD_INT 8
88726: PUSH
88727: EMPTY
88728: LIST
88729: LIST
88730: IN
88731: IFFALSE 88741
// btype := b_lab ;
88733: LD_ADDR_VAR 0 5
88737: PUSH
88738: LD_INT 6
88740: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
88741: LD_ADDR_EXP 68
88745: PUSH
88746: LD_EXP 68
88750: PPUSH
88751: LD_VAR 0 3
88755: PUSH
88756: LD_EXP 68
88760: PUSH
88761: LD_VAR 0 3
88765: ARRAY
88766: PUSH
88767: LD_INT 1
88769: PLUS
88770: PUSH
88771: EMPTY
88772: LIST
88773: LIST
88774: PPUSH
88775: LD_VAR 0 5
88779: PUSH
88780: LD_VAR 0 1
88784: PPUSH
88785: CALL_OW 250
88789: PUSH
88790: LD_VAR 0 1
88794: PPUSH
88795: CALL_OW 251
88799: PUSH
88800: LD_VAR 0 1
88804: PPUSH
88805: CALL_OW 254
88809: PUSH
88810: EMPTY
88811: LIST
88812: LIST
88813: LIST
88814: LIST
88815: PPUSH
88816: CALL 22322 0 3
88820: ST_TO_ADDR
// if pos = 1 then
88821: LD_VAR 0 6
88825: PUSH
88826: LD_INT 1
88828: EQUAL
88829: IFFALSE 88944
// begin tmp := mc_build_list [ i ] ;
88831: LD_ADDR_VAR 0 7
88835: PUSH
88836: LD_EXP 68
88840: PUSH
88841: LD_VAR 0 3
88845: ARRAY
88846: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
88847: LD_VAR 0 7
88851: PPUSH
88852: LD_INT 2
88854: PUSH
88855: LD_INT 30
88857: PUSH
88858: LD_INT 0
88860: PUSH
88861: EMPTY
88862: LIST
88863: LIST
88864: PUSH
88865: LD_INT 30
88867: PUSH
88868: LD_INT 1
88870: PUSH
88871: EMPTY
88872: LIST
88873: LIST
88874: PUSH
88875: EMPTY
88876: LIST
88877: LIST
88878: LIST
88879: PPUSH
88880: CALL_OW 72
88884: IFFALSE 88894
// pos := 2 ;
88886: LD_ADDR_VAR 0 6
88890: PUSH
88891: LD_INT 2
88893: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
88894: LD_ADDR_VAR 0 7
88898: PUSH
88899: LD_VAR 0 7
88903: PPUSH
88904: LD_VAR 0 6
88908: PPUSH
88909: LD_VAR 0 7
88913: PPUSH
88914: CALL 22648 0 3
88918: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
88919: LD_ADDR_EXP 68
88923: PUSH
88924: LD_EXP 68
88928: PPUSH
88929: LD_VAR 0 3
88933: PPUSH
88934: LD_VAR 0 7
88938: PPUSH
88939: CALL_OW 1
88943: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
88944: LD_VAR 0 1
88948: PUSH
88949: LD_EXP 63
88953: PUSH
88954: LD_VAR 0 3
88958: ARRAY
88959: IN
88960: IFFALSE 88999
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
88962: LD_ADDR_EXP 63
88966: PUSH
88967: LD_EXP 63
88971: PPUSH
88972: LD_VAR 0 3
88976: PPUSH
88977: LD_EXP 63
88981: PUSH
88982: LD_VAR 0 3
88986: ARRAY
88987: PUSH
88988: LD_VAR 0 1
88992: DIFF
88993: PPUSH
88994: CALL_OW 1
88998: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
88999: LD_VAR 0 1
89003: PUSH
89004: LD_EXP 70
89008: PUSH
89009: LD_VAR 0 3
89013: ARRAY
89014: IN
89015: IFFALSE 89054
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
89017: LD_ADDR_EXP 70
89021: PUSH
89022: LD_EXP 70
89026: PPUSH
89027: LD_VAR 0 3
89031: PPUSH
89032: LD_EXP 70
89036: PUSH
89037: LD_VAR 0 3
89041: ARRAY
89042: PUSH
89043: LD_VAR 0 1
89047: DIFF
89048: PPUSH
89049: CALL_OW 1
89053: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
89054: LD_VAR 0 1
89058: PUSH
89059: LD_EXP 82
89063: PUSH
89064: LD_VAR 0 3
89068: ARRAY
89069: IN
89070: IFFALSE 89109
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
89072: LD_ADDR_EXP 82
89076: PUSH
89077: LD_EXP 82
89081: PPUSH
89082: LD_VAR 0 3
89086: PPUSH
89087: LD_EXP 82
89091: PUSH
89092: LD_VAR 0 3
89096: ARRAY
89097: PUSH
89098: LD_VAR 0 1
89102: DIFF
89103: PPUSH
89104: CALL_OW 1
89108: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
89109: LD_VAR 0 1
89113: PUSH
89114: LD_EXP 85
89118: PUSH
89119: LD_VAR 0 3
89123: ARRAY
89124: IN
89125: IFFALSE 89164
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
89127: LD_ADDR_EXP 85
89131: PUSH
89132: LD_EXP 85
89136: PPUSH
89137: LD_VAR 0 3
89141: PPUSH
89142: LD_EXP 85
89146: PUSH
89147: LD_VAR 0 3
89151: ARRAY
89152: PUSH
89153: LD_VAR 0 1
89157: DIFF
89158: PPUSH
89159: CALL_OW 1
89163: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
89164: LD_VAR 0 1
89168: PUSH
89169: LD_EXP 72
89173: PUSH
89174: LD_VAR 0 3
89178: ARRAY
89179: IN
89180: IFFALSE 89219
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
89182: LD_ADDR_EXP 72
89186: PUSH
89187: LD_EXP 72
89191: PPUSH
89192: LD_VAR 0 3
89196: PPUSH
89197: LD_EXP 72
89201: PUSH
89202: LD_VAR 0 3
89206: ARRAY
89207: PUSH
89208: LD_VAR 0 1
89212: DIFF
89213: PPUSH
89214: CALL_OW 1
89218: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
89219: LD_VAR 0 1
89223: PUSH
89224: LD_EXP 71
89228: PUSH
89229: LD_VAR 0 3
89233: ARRAY
89234: IN
89235: IFFALSE 89274
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
89237: LD_ADDR_EXP 71
89241: PUSH
89242: LD_EXP 71
89246: PPUSH
89247: LD_VAR 0 3
89251: PPUSH
89252: LD_EXP 71
89256: PUSH
89257: LD_VAR 0 3
89261: ARRAY
89262: PUSH
89263: LD_VAR 0 1
89267: DIFF
89268: PPUSH
89269: CALL_OW 1
89273: ST_TO_ADDR
// end ; break ;
89274: GO 89278
// end ;
89276: GO 87926
89278: POP
89279: POP
// end ;
89280: LD_VAR 0 2
89284: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
89285: LD_INT 0
89287: PPUSH
89288: PPUSH
89289: PPUSH
// if not mc_bases or not skirmish then
89290: LD_EXP 63
89294: NOT
89295: PUSH
89296: LD_EXP 61
89300: NOT
89301: OR
89302: IFFALSE 89306
// exit ;
89304: GO 89521
// for i = 1 to mc_bases do
89306: LD_ADDR_VAR 0 3
89310: PUSH
89311: DOUBLE
89312: LD_INT 1
89314: DEC
89315: ST_TO_ADDR
89316: LD_EXP 63
89320: PUSH
89321: FOR_TO
89322: IFFALSE 89519
// begin if building in mc_construct_list [ i ] then
89324: LD_VAR 0 1
89328: PUSH
89329: LD_EXP 70
89333: PUSH
89334: LD_VAR 0 3
89338: ARRAY
89339: IN
89340: IFFALSE 89517
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89342: LD_ADDR_EXP 70
89346: PUSH
89347: LD_EXP 70
89351: PPUSH
89352: LD_VAR 0 3
89356: PPUSH
89357: LD_EXP 70
89361: PUSH
89362: LD_VAR 0 3
89366: ARRAY
89367: PUSH
89368: LD_VAR 0 1
89372: DIFF
89373: PPUSH
89374: CALL_OW 1
89378: ST_TO_ADDR
// if building in mc_lab [ i ] then
89379: LD_VAR 0 1
89383: PUSH
89384: LD_EXP 96
89388: PUSH
89389: LD_VAR 0 3
89393: ARRAY
89394: IN
89395: IFFALSE 89450
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
89397: LD_ADDR_EXP 97
89401: PUSH
89402: LD_EXP 97
89406: PPUSH
89407: LD_VAR 0 3
89411: PPUSH
89412: LD_EXP 97
89416: PUSH
89417: LD_VAR 0 3
89421: ARRAY
89422: PPUSH
89423: LD_INT 1
89425: PPUSH
89426: LD_EXP 97
89430: PUSH
89431: LD_VAR 0 3
89435: ARRAY
89436: PPUSH
89437: LD_INT 0
89439: PPUSH
89440: CALL 21740 0 4
89444: PPUSH
89445: CALL_OW 1
89449: ST_TO_ADDR
// if not building in mc_bases [ i ] then
89450: LD_VAR 0 1
89454: PUSH
89455: LD_EXP 63
89459: PUSH
89460: LD_VAR 0 3
89464: ARRAY
89465: IN
89466: NOT
89467: IFFALSE 89513
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89469: LD_ADDR_EXP 63
89473: PUSH
89474: LD_EXP 63
89478: PPUSH
89479: LD_VAR 0 3
89483: PUSH
89484: LD_EXP 63
89488: PUSH
89489: LD_VAR 0 3
89493: ARRAY
89494: PUSH
89495: LD_INT 1
89497: PLUS
89498: PUSH
89499: EMPTY
89500: LIST
89501: LIST
89502: PPUSH
89503: LD_VAR 0 1
89507: PPUSH
89508: CALL 22322 0 3
89512: ST_TO_ADDR
// exit ;
89513: POP
89514: POP
89515: GO 89521
// end ; end ;
89517: GO 89321
89519: POP
89520: POP
// end ;
89521: LD_VAR 0 2
89525: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
89526: LD_INT 0
89528: PPUSH
89529: PPUSH
89530: PPUSH
89531: PPUSH
89532: PPUSH
89533: PPUSH
89534: PPUSH
// if not mc_bases or not skirmish then
89535: LD_EXP 63
89539: NOT
89540: PUSH
89541: LD_EXP 61
89545: NOT
89546: OR
89547: IFFALSE 89551
// exit ;
89549: GO 90212
// for i = 1 to mc_bases do
89551: LD_ADDR_VAR 0 3
89555: PUSH
89556: DOUBLE
89557: LD_INT 1
89559: DEC
89560: ST_TO_ADDR
89561: LD_EXP 63
89565: PUSH
89566: FOR_TO
89567: IFFALSE 90210
// begin if building in mc_construct_list [ i ] then
89569: LD_VAR 0 1
89573: PUSH
89574: LD_EXP 70
89578: PUSH
89579: LD_VAR 0 3
89583: ARRAY
89584: IN
89585: IFFALSE 90208
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
89587: LD_ADDR_EXP 70
89591: PUSH
89592: LD_EXP 70
89596: PPUSH
89597: LD_VAR 0 3
89601: PPUSH
89602: LD_EXP 70
89606: PUSH
89607: LD_VAR 0 3
89611: ARRAY
89612: PUSH
89613: LD_VAR 0 1
89617: DIFF
89618: PPUSH
89619: CALL_OW 1
89623: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
89624: LD_ADDR_EXP 63
89628: PUSH
89629: LD_EXP 63
89633: PPUSH
89634: LD_VAR 0 3
89638: PUSH
89639: LD_EXP 63
89643: PUSH
89644: LD_VAR 0 3
89648: ARRAY
89649: PUSH
89650: LD_INT 1
89652: PLUS
89653: PUSH
89654: EMPTY
89655: LIST
89656: LIST
89657: PPUSH
89658: LD_VAR 0 1
89662: PPUSH
89663: CALL 22322 0 3
89667: ST_TO_ADDR
// btype := GetBType ( building ) ;
89668: LD_ADDR_VAR 0 5
89672: PUSH
89673: LD_VAR 0 1
89677: PPUSH
89678: CALL_OW 266
89682: ST_TO_ADDR
// side := GetSide ( building ) ;
89683: LD_ADDR_VAR 0 8
89687: PUSH
89688: LD_VAR 0 1
89692: PPUSH
89693: CALL_OW 255
89697: ST_TO_ADDR
// if btype = b_lab then
89698: LD_VAR 0 5
89702: PUSH
89703: LD_INT 6
89705: EQUAL
89706: IFFALSE 89756
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
89708: LD_ADDR_EXP 96
89712: PUSH
89713: LD_EXP 96
89717: PPUSH
89718: LD_VAR 0 3
89722: PUSH
89723: LD_EXP 96
89727: PUSH
89728: LD_VAR 0 3
89732: ARRAY
89733: PUSH
89734: LD_INT 1
89736: PLUS
89737: PUSH
89738: EMPTY
89739: LIST
89740: LIST
89741: PPUSH
89742: LD_VAR 0 1
89746: PPUSH
89747: CALL 22322 0 3
89751: ST_TO_ADDR
// exit ;
89752: POP
89753: POP
89754: GO 90212
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
89756: LD_VAR 0 5
89760: PUSH
89761: LD_INT 0
89763: PUSH
89764: LD_INT 2
89766: PUSH
89767: LD_INT 4
89769: PUSH
89770: EMPTY
89771: LIST
89772: LIST
89773: LIST
89774: IN
89775: IFFALSE 89899
// begin if btype = b_armoury then
89777: LD_VAR 0 5
89781: PUSH
89782: LD_INT 4
89784: EQUAL
89785: IFFALSE 89795
// btype := b_barracks ;
89787: LD_ADDR_VAR 0 5
89791: PUSH
89792: LD_INT 5
89794: ST_TO_ADDR
// if btype = b_depot then
89795: LD_VAR 0 5
89799: PUSH
89800: LD_INT 0
89802: EQUAL
89803: IFFALSE 89813
// btype := b_warehouse ;
89805: LD_ADDR_VAR 0 5
89809: PUSH
89810: LD_INT 1
89812: ST_TO_ADDR
// if btype = b_workshop then
89813: LD_VAR 0 5
89817: PUSH
89818: LD_INT 2
89820: EQUAL
89821: IFFALSE 89831
// btype := b_factory ;
89823: LD_ADDR_VAR 0 5
89827: PUSH
89828: LD_INT 3
89830: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
89831: LD_VAR 0 5
89835: PPUSH
89836: LD_VAR 0 8
89840: PPUSH
89841: CALL_OW 323
89845: PUSH
89846: LD_INT 1
89848: EQUAL
89849: IFFALSE 89895
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
89851: LD_ADDR_EXP 95
89855: PUSH
89856: LD_EXP 95
89860: PPUSH
89861: LD_VAR 0 3
89865: PUSH
89866: LD_EXP 95
89870: PUSH
89871: LD_VAR 0 3
89875: ARRAY
89876: PUSH
89877: LD_INT 1
89879: PLUS
89880: PUSH
89881: EMPTY
89882: LIST
89883: LIST
89884: PPUSH
89885: LD_VAR 0 1
89889: PPUSH
89890: CALL 22322 0 3
89894: ST_TO_ADDR
// exit ;
89895: POP
89896: POP
89897: GO 90212
// end ; if btype in [ b_bunker , b_turret ] then
89899: LD_VAR 0 5
89903: PUSH
89904: LD_INT 32
89906: PUSH
89907: LD_INT 33
89909: PUSH
89910: EMPTY
89911: LIST
89912: LIST
89913: IN
89914: IFFALSE 90204
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
89916: LD_ADDR_EXP 71
89920: PUSH
89921: LD_EXP 71
89925: PPUSH
89926: LD_VAR 0 3
89930: PUSH
89931: LD_EXP 71
89935: PUSH
89936: LD_VAR 0 3
89940: ARRAY
89941: PUSH
89942: LD_INT 1
89944: PLUS
89945: PUSH
89946: EMPTY
89947: LIST
89948: LIST
89949: PPUSH
89950: LD_VAR 0 1
89954: PPUSH
89955: CALL 22322 0 3
89959: ST_TO_ADDR
// if btype = b_bunker then
89960: LD_VAR 0 5
89964: PUSH
89965: LD_INT 32
89967: EQUAL
89968: IFFALSE 90204
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
89970: LD_ADDR_EXP 72
89974: PUSH
89975: LD_EXP 72
89979: PPUSH
89980: LD_VAR 0 3
89984: PUSH
89985: LD_EXP 72
89989: PUSH
89990: LD_VAR 0 3
89994: ARRAY
89995: PUSH
89996: LD_INT 1
89998: PLUS
89999: PUSH
90000: EMPTY
90001: LIST
90002: LIST
90003: PPUSH
90004: LD_VAR 0 1
90008: PPUSH
90009: CALL 22322 0 3
90013: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
90014: LD_ADDR_VAR 0 6
90018: PUSH
90019: LD_EXP 63
90023: PUSH
90024: LD_VAR 0 3
90028: ARRAY
90029: PPUSH
90030: LD_INT 25
90032: PUSH
90033: LD_INT 1
90035: PUSH
90036: EMPTY
90037: LIST
90038: LIST
90039: PUSH
90040: LD_INT 3
90042: PUSH
90043: LD_INT 54
90045: PUSH
90046: EMPTY
90047: LIST
90048: PUSH
90049: EMPTY
90050: LIST
90051: LIST
90052: PUSH
90053: EMPTY
90054: LIST
90055: LIST
90056: PPUSH
90057: CALL_OW 72
90061: ST_TO_ADDR
// if tmp then
90062: LD_VAR 0 6
90066: IFFALSE 90072
// exit ;
90068: POP
90069: POP
90070: GO 90212
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
90072: LD_ADDR_VAR 0 6
90076: PUSH
90077: LD_EXP 63
90081: PUSH
90082: LD_VAR 0 3
90086: ARRAY
90087: PPUSH
90088: LD_INT 2
90090: PUSH
90091: LD_INT 30
90093: PUSH
90094: LD_INT 4
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: PUSH
90101: LD_INT 30
90103: PUSH
90104: LD_INT 5
90106: PUSH
90107: EMPTY
90108: LIST
90109: LIST
90110: PUSH
90111: EMPTY
90112: LIST
90113: LIST
90114: LIST
90115: PPUSH
90116: CALL_OW 72
90120: ST_TO_ADDR
// if not tmp then
90121: LD_VAR 0 6
90125: NOT
90126: IFFALSE 90132
// exit ;
90128: POP
90129: POP
90130: GO 90212
// for j in tmp do
90132: LD_ADDR_VAR 0 4
90136: PUSH
90137: LD_VAR 0 6
90141: PUSH
90142: FOR_IN
90143: IFFALSE 90202
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
90145: LD_ADDR_VAR 0 7
90149: PUSH
90150: LD_VAR 0 4
90154: PPUSH
90155: CALL_OW 313
90159: PPUSH
90160: LD_INT 25
90162: PUSH
90163: LD_INT 1
90165: PUSH
90166: EMPTY
90167: LIST
90168: LIST
90169: PPUSH
90170: CALL_OW 72
90174: ST_TO_ADDR
// if units then
90175: LD_VAR 0 7
90179: IFFALSE 90200
// begin ComExitBuilding ( units [ 1 ] ) ;
90181: LD_VAR 0 7
90185: PUSH
90186: LD_INT 1
90188: ARRAY
90189: PPUSH
90190: CALL_OW 122
// exit ;
90194: POP
90195: POP
90196: POP
90197: POP
90198: GO 90212
// end ; end ;
90200: GO 90142
90202: POP
90203: POP
// end ; end ; exit ;
90204: POP
90205: POP
90206: GO 90212
// end ; end ;
90208: GO 89566
90210: POP
90211: POP
// end ;
90212: LD_VAR 0 2
90216: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
90217: LD_INT 0
90219: PPUSH
90220: PPUSH
90221: PPUSH
90222: PPUSH
90223: PPUSH
90224: PPUSH
90225: PPUSH
// if not mc_bases or not skirmish then
90226: LD_EXP 63
90230: NOT
90231: PUSH
90232: LD_EXP 61
90236: NOT
90237: OR
90238: IFFALSE 90242
// exit ;
90240: GO 90507
// btype := GetBType ( building ) ;
90242: LD_ADDR_VAR 0 6
90246: PUSH
90247: LD_VAR 0 1
90251: PPUSH
90252: CALL_OW 266
90256: ST_TO_ADDR
// x := GetX ( building ) ;
90257: LD_ADDR_VAR 0 7
90261: PUSH
90262: LD_VAR 0 1
90266: PPUSH
90267: CALL_OW 250
90271: ST_TO_ADDR
// y := GetY ( building ) ;
90272: LD_ADDR_VAR 0 8
90276: PUSH
90277: LD_VAR 0 1
90281: PPUSH
90282: CALL_OW 251
90286: ST_TO_ADDR
// d := GetDir ( building ) ;
90287: LD_ADDR_VAR 0 9
90291: PUSH
90292: LD_VAR 0 1
90296: PPUSH
90297: CALL_OW 254
90301: ST_TO_ADDR
// for i = 1 to mc_bases do
90302: LD_ADDR_VAR 0 4
90306: PUSH
90307: DOUBLE
90308: LD_INT 1
90310: DEC
90311: ST_TO_ADDR
90312: LD_EXP 63
90316: PUSH
90317: FOR_TO
90318: IFFALSE 90505
// begin if not mc_build_list [ i ] then
90320: LD_EXP 68
90324: PUSH
90325: LD_VAR 0 4
90329: ARRAY
90330: NOT
90331: IFFALSE 90335
// continue ;
90333: GO 90317
// for j := 1 to mc_build_list [ i ] do
90335: LD_ADDR_VAR 0 5
90339: PUSH
90340: DOUBLE
90341: LD_INT 1
90343: DEC
90344: ST_TO_ADDR
90345: LD_EXP 68
90349: PUSH
90350: LD_VAR 0 4
90354: ARRAY
90355: PUSH
90356: FOR_TO
90357: IFFALSE 90501
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
90359: LD_VAR 0 6
90363: PUSH
90364: LD_VAR 0 7
90368: PUSH
90369: LD_VAR 0 8
90373: PUSH
90374: LD_VAR 0 9
90378: PUSH
90379: EMPTY
90380: LIST
90381: LIST
90382: LIST
90383: LIST
90384: PPUSH
90385: LD_EXP 68
90389: PUSH
90390: LD_VAR 0 4
90394: ARRAY
90395: PUSH
90396: LD_VAR 0 5
90400: ARRAY
90401: PPUSH
90402: CALL 28879 0 2
90406: IFFALSE 90499
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
90408: LD_ADDR_EXP 68
90412: PUSH
90413: LD_EXP 68
90417: PPUSH
90418: LD_VAR 0 4
90422: PPUSH
90423: LD_EXP 68
90427: PUSH
90428: LD_VAR 0 4
90432: ARRAY
90433: PPUSH
90434: LD_VAR 0 5
90438: PPUSH
90439: CALL_OW 3
90443: PPUSH
90444: CALL_OW 1
90448: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
90449: LD_ADDR_EXP 70
90453: PUSH
90454: LD_EXP 70
90458: PPUSH
90459: LD_VAR 0 4
90463: PUSH
90464: LD_EXP 70
90468: PUSH
90469: LD_VAR 0 4
90473: ARRAY
90474: PUSH
90475: LD_INT 1
90477: PLUS
90478: PUSH
90479: EMPTY
90480: LIST
90481: LIST
90482: PPUSH
90483: LD_VAR 0 1
90487: PPUSH
90488: CALL 22322 0 3
90492: ST_TO_ADDR
// exit ;
90493: POP
90494: POP
90495: POP
90496: POP
90497: GO 90507
// end ;
90499: GO 90356
90501: POP
90502: POP
// end ;
90503: GO 90317
90505: POP
90506: POP
// end ;
90507: LD_VAR 0 3
90511: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
90512: LD_INT 0
90514: PPUSH
90515: PPUSH
90516: PPUSH
// if not mc_bases or not skirmish then
90517: LD_EXP 63
90521: NOT
90522: PUSH
90523: LD_EXP 61
90527: NOT
90528: OR
90529: IFFALSE 90533
// exit ;
90531: GO 90723
// for i = 1 to mc_bases do
90533: LD_ADDR_VAR 0 4
90537: PUSH
90538: DOUBLE
90539: LD_INT 1
90541: DEC
90542: ST_TO_ADDR
90543: LD_EXP 63
90547: PUSH
90548: FOR_TO
90549: IFFALSE 90636
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
90551: LD_VAR 0 1
90555: PUSH
90556: LD_EXP 71
90560: PUSH
90561: LD_VAR 0 4
90565: ARRAY
90566: IN
90567: PUSH
90568: LD_VAR 0 1
90572: PUSH
90573: LD_EXP 72
90577: PUSH
90578: LD_VAR 0 4
90582: ARRAY
90583: IN
90584: NOT
90585: AND
90586: IFFALSE 90634
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
90588: LD_ADDR_EXP 72
90592: PUSH
90593: LD_EXP 72
90597: PPUSH
90598: LD_VAR 0 4
90602: PUSH
90603: LD_EXP 72
90607: PUSH
90608: LD_VAR 0 4
90612: ARRAY
90613: PUSH
90614: LD_INT 1
90616: PLUS
90617: PUSH
90618: EMPTY
90619: LIST
90620: LIST
90621: PPUSH
90622: LD_VAR 0 1
90626: PPUSH
90627: CALL 22322 0 3
90631: ST_TO_ADDR
// break ;
90632: GO 90636
// end ; end ;
90634: GO 90548
90636: POP
90637: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
90638: LD_VAR 0 1
90642: PPUSH
90643: CALL_OW 257
90647: PUSH
90648: LD_EXP 89
90652: IN
90653: PUSH
90654: LD_VAR 0 1
90658: PPUSH
90659: CALL_OW 266
90663: PUSH
90664: LD_INT 5
90666: EQUAL
90667: AND
90668: PUSH
90669: LD_VAR 0 2
90673: PPUSH
90674: CALL_OW 110
90678: PUSH
90679: LD_INT 18
90681: NONEQUAL
90682: AND
90683: IFFALSE 90723
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
90685: LD_VAR 0 2
90689: PPUSH
90690: CALL_OW 257
90694: PUSH
90695: LD_INT 5
90697: PUSH
90698: LD_INT 8
90700: PUSH
90701: LD_INT 9
90703: PUSH
90704: EMPTY
90705: LIST
90706: LIST
90707: LIST
90708: IN
90709: IFFALSE 90723
// SetClass ( unit , 1 ) ;
90711: LD_VAR 0 2
90715: PPUSH
90716: LD_INT 1
90718: PPUSH
90719: CALL_OW 336
// end ;
90723: LD_VAR 0 3
90727: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
90728: LD_INT 0
90730: PPUSH
90731: PPUSH
// if not mc_bases or not skirmish then
90732: LD_EXP 63
90736: NOT
90737: PUSH
90738: LD_EXP 61
90742: NOT
90743: OR
90744: IFFALSE 90748
// exit ;
90746: GO 90864
// if GetLives ( abandoned_vehicle ) > 250 then
90748: LD_VAR 0 2
90752: PPUSH
90753: CALL_OW 256
90757: PUSH
90758: LD_INT 250
90760: GREATER
90761: IFFALSE 90765
// exit ;
90763: GO 90864
// for i = 1 to mc_bases do
90765: LD_ADDR_VAR 0 6
90769: PUSH
90770: DOUBLE
90771: LD_INT 1
90773: DEC
90774: ST_TO_ADDR
90775: LD_EXP 63
90779: PUSH
90780: FOR_TO
90781: IFFALSE 90862
// begin if driver in mc_bases [ i ] then
90783: LD_VAR 0 1
90787: PUSH
90788: LD_EXP 63
90792: PUSH
90793: LD_VAR 0 6
90797: ARRAY
90798: IN
90799: IFFALSE 90860
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
90801: LD_VAR 0 1
90805: PPUSH
90806: LD_EXP 63
90810: PUSH
90811: LD_VAR 0 6
90815: ARRAY
90816: PPUSH
90817: LD_INT 2
90819: PUSH
90820: LD_INT 30
90822: PUSH
90823: LD_INT 0
90825: PUSH
90826: EMPTY
90827: LIST
90828: LIST
90829: PUSH
90830: LD_INT 30
90832: PUSH
90833: LD_INT 1
90835: PUSH
90836: EMPTY
90837: LIST
90838: LIST
90839: PUSH
90840: EMPTY
90841: LIST
90842: LIST
90843: LIST
90844: PPUSH
90845: CALL_OW 72
90849: PUSH
90850: LD_INT 1
90852: ARRAY
90853: PPUSH
90854: CALL 55948 0 2
// break ;
90858: GO 90862
// end ; end ;
90860: GO 90780
90862: POP
90863: POP
// end ; end_of_file end_of_file
90864: LD_VAR 0 5
90868: RET
// export globalGameSaveCounter ; every 0 0$1 do
90869: GO 90871
90871: DISABLE
// begin enable ;
90872: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90873: LD_STRING updateTimer(
90875: PUSH
90876: LD_OWVAR 1
90880: STR
90881: PUSH
90882: LD_STRING );
90884: STR
90885: PPUSH
90886: CALL_OW 559
// end ;
90890: END
// every 0 0$1 do
90891: GO 90893
90893: DISABLE
// begin globalGameSaveCounter := 0 ;
90894: LD_ADDR_EXP 108
90898: PUSH
90899: LD_INT 0
90901: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90902: LD_STRING setGameSaveCounter(0)
90904: PPUSH
90905: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90909: LD_STRING initStreamRollete();
90911: PPUSH
90912: CALL_OW 559
// InitStreamMode ;
90916: CALL 92259 0 0
// DefineStreamItems ( false ) ;
90920: LD_INT 0
90922: PPUSH
90923: CALL 92723 0 1
// end ;
90927: END
// export function SOS_MapStart ( ) ; begin
90928: LD_INT 0
90930: PPUSH
// if streamModeActive then
90931: LD_EXP 109
90935: IFFALSE 90944
// DefineStreamItems ( true ) ;
90937: LD_INT 1
90939: PPUSH
90940: CALL 92723 0 1
// UpdateLuaVariables ( ) ;
90944: CALL 90961 0 0
// UpdateFactoryWaypoints ( ) ;
90948: CALL 105725 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90952: CALL 105977 0 0
// end ;
90956: LD_VAR 0 1
90960: RET
// function UpdateLuaVariables ( ) ; begin
90961: LD_INT 0
90963: PPUSH
// if globalGameSaveCounter then
90964: LD_EXP 108
90968: IFFALSE 91002
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90970: LD_ADDR_EXP 108
90974: PUSH
90975: LD_EXP 108
90979: PPUSH
90980: CALL 56432 0 1
90984: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90985: LD_STRING setGameSaveCounter(
90987: PUSH
90988: LD_EXP 108
90992: STR
90993: PUSH
90994: LD_STRING )
90996: STR
90997: PPUSH
90998: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
91002: LD_STRING setGameDifficulty(
91004: PUSH
91005: LD_OWVAR 67
91009: STR
91010: PUSH
91011: LD_STRING )
91013: STR
91014: PPUSH
91015: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
91019: LD_STRING displayDifficulty(
91021: PUSH
91022: LD_OWVAR 67
91026: STR
91027: PUSH
91028: LD_STRING )
91030: STR
91031: PPUSH
91032: CALL_OW 559
// end ;
91036: LD_VAR 0 1
91040: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
91041: LD_INT 0
91043: PPUSH
// if p2 = stream_mode then
91044: LD_VAR 0 2
91048: PUSH
91049: LD_INT 100
91051: EQUAL
91052: IFFALSE 92055
// begin if not StreamModeActive then
91054: LD_EXP 109
91058: NOT
91059: IFFALSE 91069
// StreamModeActive := true ;
91061: LD_ADDR_EXP 109
91065: PUSH
91066: LD_INT 1
91068: ST_TO_ADDR
// if p3 = 0 then
91069: LD_VAR 0 3
91073: PUSH
91074: LD_INT 0
91076: EQUAL
91077: IFFALSE 91083
// InitStreamMode ;
91079: CALL 92259 0 0
// if p3 = 1 then
91083: LD_VAR 0 3
91087: PUSH
91088: LD_INT 1
91090: EQUAL
91091: IFFALSE 91101
// sRocket := true ;
91093: LD_ADDR_EXP 114
91097: PUSH
91098: LD_INT 1
91100: ST_TO_ADDR
// if p3 = 2 then
91101: LD_VAR 0 3
91105: PUSH
91106: LD_INT 2
91108: EQUAL
91109: IFFALSE 91119
// sSpeed := true ;
91111: LD_ADDR_EXP 113
91115: PUSH
91116: LD_INT 1
91118: ST_TO_ADDR
// if p3 = 3 then
91119: LD_VAR 0 3
91123: PUSH
91124: LD_INT 3
91126: EQUAL
91127: IFFALSE 91137
// sEngine := true ;
91129: LD_ADDR_EXP 115
91133: PUSH
91134: LD_INT 1
91136: ST_TO_ADDR
// if p3 = 4 then
91137: LD_VAR 0 3
91141: PUSH
91142: LD_INT 4
91144: EQUAL
91145: IFFALSE 91155
// sSpec := true ;
91147: LD_ADDR_EXP 112
91151: PUSH
91152: LD_INT 1
91154: ST_TO_ADDR
// if p3 = 5 then
91155: LD_VAR 0 3
91159: PUSH
91160: LD_INT 5
91162: EQUAL
91163: IFFALSE 91173
// sLevel := true ;
91165: LD_ADDR_EXP 116
91169: PUSH
91170: LD_INT 1
91172: ST_TO_ADDR
// if p3 = 6 then
91173: LD_VAR 0 3
91177: PUSH
91178: LD_INT 6
91180: EQUAL
91181: IFFALSE 91191
// sArmoury := true ;
91183: LD_ADDR_EXP 117
91187: PUSH
91188: LD_INT 1
91190: ST_TO_ADDR
// if p3 = 7 then
91191: LD_VAR 0 3
91195: PUSH
91196: LD_INT 7
91198: EQUAL
91199: IFFALSE 91209
// sRadar := true ;
91201: LD_ADDR_EXP 118
91205: PUSH
91206: LD_INT 1
91208: ST_TO_ADDR
// if p3 = 8 then
91209: LD_VAR 0 3
91213: PUSH
91214: LD_INT 8
91216: EQUAL
91217: IFFALSE 91227
// sBunker := true ;
91219: LD_ADDR_EXP 119
91223: PUSH
91224: LD_INT 1
91226: ST_TO_ADDR
// if p3 = 9 then
91227: LD_VAR 0 3
91231: PUSH
91232: LD_INT 9
91234: EQUAL
91235: IFFALSE 91245
// sHack := true ;
91237: LD_ADDR_EXP 120
91241: PUSH
91242: LD_INT 1
91244: ST_TO_ADDR
// if p3 = 10 then
91245: LD_VAR 0 3
91249: PUSH
91250: LD_INT 10
91252: EQUAL
91253: IFFALSE 91263
// sFire := true ;
91255: LD_ADDR_EXP 121
91259: PUSH
91260: LD_INT 1
91262: ST_TO_ADDR
// if p3 = 11 then
91263: LD_VAR 0 3
91267: PUSH
91268: LD_INT 11
91270: EQUAL
91271: IFFALSE 91281
// sRefresh := true ;
91273: LD_ADDR_EXP 122
91277: PUSH
91278: LD_INT 1
91280: ST_TO_ADDR
// if p3 = 12 then
91281: LD_VAR 0 3
91285: PUSH
91286: LD_INT 12
91288: EQUAL
91289: IFFALSE 91299
// sExp := true ;
91291: LD_ADDR_EXP 123
91295: PUSH
91296: LD_INT 1
91298: ST_TO_ADDR
// if p3 = 13 then
91299: LD_VAR 0 3
91303: PUSH
91304: LD_INT 13
91306: EQUAL
91307: IFFALSE 91317
// sDepot := true ;
91309: LD_ADDR_EXP 124
91313: PUSH
91314: LD_INT 1
91316: ST_TO_ADDR
// if p3 = 14 then
91317: LD_VAR 0 3
91321: PUSH
91322: LD_INT 14
91324: EQUAL
91325: IFFALSE 91335
// sFlag := true ;
91327: LD_ADDR_EXP 125
91331: PUSH
91332: LD_INT 1
91334: ST_TO_ADDR
// if p3 = 15 then
91335: LD_VAR 0 3
91339: PUSH
91340: LD_INT 15
91342: EQUAL
91343: IFFALSE 91353
// sKamikadze := true ;
91345: LD_ADDR_EXP 133
91349: PUSH
91350: LD_INT 1
91352: ST_TO_ADDR
// if p3 = 16 then
91353: LD_VAR 0 3
91357: PUSH
91358: LD_INT 16
91360: EQUAL
91361: IFFALSE 91371
// sTroll := true ;
91363: LD_ADDR_EXP 134
91367: PUSH
91368: LD_INT 1
91370: ST_TO_ADDR
// if p3 = 17 then
91371: LD_VAR 0 3
91375: PUSH
91376: LD_INT 17
91378: EQUAL
91379: IFFALSE 91389
// sSlow := true ;
91381: LD_ADDR_EXP 135
91385: PUSH
91386: LD_INT 1
91388: ST_TO_ADDR
// if p3 = 18 then
91389: LD_VAR 0 3
91393: PUSH
91394: LD_INT 18
91396: EQUAL
91397: IFFALSE 91407
// sLack := true ;
91399: LD_ADDR_EXP 136
91403: PUSH
91404: LD_INT 1
91406: ST_TO_ADDR
// if p3 = 19 then
91407: LD_VAR 0 3
91411: PUSH
91412: LD_INT 19
91414: EQUAL
91415: IFFALSE 91425
// sTank := true ;
91417: LD_ADDR_EXP 138
91421: PUSH
91422: LD_INT 1
91424: ST_TO_ADDR
// if p3 = 20 then
91425: LD_VAR 0 3
91429: PUSH
91430: LD_INT 20
91432: EQUAL
91433: IFFALSE 91443
// sRemote := true ;
91435: LD_ADDR_EXP 139
91439: PUSH
91440: LD_INT 1
91442: ST_TO_ADDR
// if p3 = 21 then
91443: LD_VAR 0 3
91447: PUSH
91448: LD_INT 21
91450: EQUAL
91451: IFFALSE 91461
// sPowell := true ;
91453: LD_ADDR_EXP 140
91457: PUSH
91458: LD_INT 1
91460: ST_TO_ADDR
// if p3 = 22 then
91461: LD_VAR 0 3
91465: PUSH
91466: LD_INT 22
91468: EQUAL
91469: IFFALSE 91479
// sTeleport := true ;
91471: LD_ADDR_EXP 143
91475: PUSH
91476: LD_INT 1
91478: ST_TO_ADDR
// if p3 = 23 then
91479: LD_VAR 0 3
91483: PUSH
91484: LD_INT 23
91486: EQUAL
91487: IFFALSE 91497
// sOilTower := true ;
91489: LD_ADDR_EXP 145
91493: PUSH
91494: LD_INT 1
91496: ST_TO_ADDR
// if p3 = 24 then
91497: LD_VAR 0 3
91501: PUSH
91502: LD_INT 24
91504: EQUAL
91505: IFFALSE 91515
// sShovel := true ;
91507: LD_ADDR_EXP 146
91511: PUSH
91512: LD_INT 1
91514: ST_TO_ADDR
// if p3 = 25 then
91515: LD_VAR 0 3
91519: PUSH
91520: LD_INT 25
91522: EQUAL
91523: IFFALSE 91533
// sSheik := true ;
91525: LD_ADDR_EXP 147
91529: PUSH
91530: LD_INT 1
91532: ST_TO_ADDR
// if p3 = 26 then
91533: LD_VAR 0 3
91537: PUSH
91538: LD_INT 26
91540: EQUAL
91541: IFFALSE 91551
// sEarthquake := true ;
91543: LD_ADDR_EXP 149
91547: PUSH
91548: LD_INT 1
91550: ST_TO_ADDR
// if p3 = 27 then
91551: LD_VAR 0 3
91555: PUSH
91556: LD_INT 27
91558: EQUAL
91559: IFFALSE 91569
// sAI := true ;
91561: LD_ADDR_EXP 150
91565: PUSH
91566: LD_INT 1
91568: ST_TO_ADDR
// if p3 = 28 then
91569: LD_VAR 0 3
91573: PUSH
91574: LD_INT 28
91576: EQUAL
91577: IFFALSE 91587
// sCargo := true ;
91579: LD_ADDR_EXP 153
91583: PUSH
91584: LD_INT 1
91586: ST_TO_ADDR
// if p3 = 29 then
91587: LD_VAR 0 3
91591: PUSH
91592: LD_INT 29
91594: EQUAL
91595: IFFALSE 91605
// sDLaser := true ;
91597: LD_ADDR_EXP 154
91601: PUSH
91602: LD_INT 1
91604: ST_TO_ADDR
// if p3 = 30 then
91605: LD_VAR 0 3
91609: PUSH
91610: LD_INT 30
91612: EQUAL
91613: IFFALSE 91623
// sExchange := true ;
91615: LD_ADDR_EXP 155
91619: PUSH
91620: LD_INT 1
91622: ST_TO_ADDR
// if p3 = 31 then
91623: LD_VAR 0 3
91627: PUSH
91628: LD_INT 31
91630: EQUAL
91631: IFFALSE 91641
// sFac := true ;
91633: LD_ADDR_EXP 156
91637: PUSH
91638: LD_INT 1
91640: ST_TO_ADDR
// if p3 = 32 then
91641: LD_VAR 0 3
91645: PUSH
91646: LD_INT 32
91648: EQUAL
91649: IFFALSE 91659
// sPower := true ;
91651: LD_ADDR_EXP 157
91655: PUSH
91656: LD_INT 1
91658: ST_TO_ADDR
// if p3 = 33 then
91659: LD_VAR 0 3
91663: PUSH
91664: LD_INT 33
91666: EQUAL
91667: IFFALSE 91677
// sRandom := true ;
91669: LD_ADDR_EXP 158
91673: PUSH
91674: LD_INT 1
91676: ST_TO_ADDR
// if p3 = 34 then
91677: LD_VAR 0 3
91681: PUSH
91682: LD_INT 34
91684: EQUAL
91685: IFFALSE 91695
// sShield := true ;
91687: LD_ADDR_EXP 159
91691: PUSH
91692: LD_INT 1
91694: ST_TO_ADDR
// if p3 = 35 then
91695: LD_VAR 0 3
91699: PUSH
91700: LD_INT 35
91702: EQUAL
91703: IFFALSE 91713
// sTime := true ;
91705: LD_ADDR_EXP 160
91709: PUSH
91710: LD_INT 1
91712: ST_TO_ADDR
// if p3 = 36 then
91713: LD_VAR 0 3
91717: PUSH
91718: LD_INT 36
91720: EQUAL
91721: IFFALSE 91731
// sTools := true ;
91723: LD_ADDR_EXP 161
91727: PUSH
91728: LD_INT 1
91730: ST_TO_ADDR
// if p3 = 101 then
91731: LD_VAR 0 3
91735: PUSH
91736: LD_INT 101
91738: EQUAL
91739: IFFALSE 91749
// sSold := true ;
91741: LD_ADDR_EXP 126
91745: PUSH
91746: LD_INT 1
91748: ST_TO_ADDR
// if p3 = 102 then
91749: LD_VAR 0 3
91753: PUSH
91754: LD_INT 102
91756: EQUAL
91757: IFFALSE 91767
// sDiff := true ;
91759: LD_ADDR_EXP 127
91763: PUSH
91764: LD_INT 1
91766: ST_TO_ADDR
// if p3 = 103 then
91767: LD_VAR 0 3
91771: PUSH
91772: LD_INT 103
91774: EQUAL
91775: IFFALSE 91785
// sFog := true ;
91777: LD_ADDR_EXP 130
91781: PUSH
91782: LD_INT 1
91784: ST_TO_ADDR
// if p3 = 104 then
91785: LD_VAR 0 3
91789: PUSH
91790: LD_INT 104
91792: EQUAL
91793: IFFALSE 91803
// sReset := true ;
91795: LD_ADDR_EXP 131
91799: PUSH
91800: LD_INT 1
91802: ST_TO_ADDR
// if p3 = 105 then
91803: LD_VAR 0 3
91807: PUSH
91808: LD_INT 105
91810: EQUAL
91811: IFFALSE 91821
// sSun := true ;
91813: LD_ADDR_EXP 132
91817: PUSH
91818: LD_INT 1
91820: ST_TO_ADDR
// if p3 = 106 then
91821: LD_VAR 0 3
91825: PUSH
91826: LD_INT 106
91828: EQUAL
91829: IFFALSE 91839
// sTiger := true ;
91831: LD_ADDR_EXP 128
91835: PUSH
91836: LD_INT 1
91838: ST_TO_ADDR
// if p3 = 107 then
91839: LD_VAR 0 3
91843: PUSH
91844: LD_INT 107
91846: EQUAL
91847: IFFALSE 91857
// sBomb := true ;
91849: LD_ADDR_EXP 129
91853: PUSH
91854: LD_INT 1
91856: ST_TO_ADDR
// if p3 = 108 then
91857: LD_VAR 0 3
91861: PUSH
91862: LD_INT 108
91864: EQUAL
91865: IFFALSE 91875
// sWound := true ;
91867: LD_ADDR_EXP 137
91871: PUSH
91872: LD_INT 1
91874: ST_TO_ADDR
// if p3 = 109 then
91875: LD_VAR 0 3
91879: PUSH
91880: LD_INT 109
91882: EQUAL
91883: IFFALSE 91893
// sBetray := true ;
91885: LD_ADDR_EXP 141
91889: PUSH
91890: LD_INT 1
91892: ST_TO_ADDR
// if p3 = 110 then
91893: LD_VAR 0 3
91897: PUSH
91898: LD_INT 110
91900: EQUAL
91901: IFFALSE 91911
// sContamin := true ;
91903: LD_ADDR_EXP 142
91907: PUSH
91908: LD_INT 1
91910: ST_TO_ADDR
// if p3 = 111 then
91911: LD_VAR 0 3
91915: PUSH
91916: LD_INT 111
91918: EQUAL
91919: IFFALSE 91929
// sOil := true ;
91921: LD_ADDR_EXP 144
91925: PUSH
91926: LD_INT 1
91928: ST_TO_ADDR
// if p3 = 112 then
91929: LD_VAR 0 3
91933: PUSH
91934: LD_INT 112
91936: EQUAL
91937: IFFALSE 91947
// sStu := true ;
91939: LD_ADDR_EXP 148
91943: PUSH
91944: LD_INT 1
91946: ST_TO_ADDR
// if p3 = 113 then
91947: LD_VAR 0 3
91951: PUSH
91952: LD_INT 113
91954: EQUAL
91955: IFFALSE 91965
// sBazooka := true ;
91957: LD_ADDR_EXP 151
91961: PUSH
91962: LD_INT 1
91964: ST_TO_ADDR
// if p3 = 114 then
91965: LD_VAR 0 3
91969: PUSH
91970: LD_INT 114
91972: EQUAL
91973: IFFALSE 91983
// sMortar := true ;
91975: LD_ADDR_EXP 152
91979: PUSH
91980: LD_INT 1
91982: ST_TO_ADDR
// if p3 = 115 then
91983: LD_VAR 0 3
91987: PUSH
91988: LD_INT 115
91990: EQUAL
91991: IFFALSE 92001
// sRanger := true ;
91993: LD_ADDR_EXP 162
91997: PUSH
91998: LD_INT 1
92000: ST_TO_ADDR
// if p3 = 116 then
92001: LD_VAR 0 3
92005: PUSH
92006: LD_INT 116
92008: EQUAL
92009: IFFALSE 92019
// sComputer := true ;
92011: LD_ADDR_EXP 163
92015: PUSH
92016: LD_INT 1
92018: ST_TO_ADDR
// if p3 = 117 then
92019: LD_VAR 0 3
92023: PUSH
92024: LD_INT 117
92026: EQUAL
92027: IFFALSE 92037
// s30 := true ;
92029: LD_ADDR_EXP 164
92033: PUSH
92034: LD_INT 1
92036: ST_TO_ADDR
// if p3 = 118 then
92037: LD_VAR 0 3
92041: PUSH
92042: LD_INT 118
92044: EQUAL
92045: IFFALSE 92055
// s60 := true ;
92047: LD_ADDR_EXP 165
92051: PUSH
92052: LD_INT 1
92054: ST_TO_ADDR
// end ; if p2 = hack_mode then
92055: LD_VAR 0 2
92059: PUSH
92060: LD_INT 101
92062: EQUAL
92063: IFFALSE 92191
// begin case p3 of 1 :
92065: LD_VAR 0 3
92069: PUSH
92070: LD_INT 1
92072: DOUBLE
92073: EQUAL
92074: IFTRUE 92078
92076: GO 92085
92078: POP
// hHackUnlimitedResources ; 2 :
92079: CALL 104338 0 0
92083: GO 92191
92085: LD_INT 2
92087: DOUBLE
92088: EQUAL
92089: IFTRUE 92093
92091: GO 92100
92093: POP
// hHackSetLevel10 ; 3 :
92094: CALL 104471 0 0
92098: GO 92191
92100: LD_INT 3
92102: DOUBLE
92103: EQUAL
92104: IFTRUE 92108
92106: GO 92115
92108: POP
// hHackSetLevel10YourUnits ; 4 :
92109: CALL 104556 0 0
92113: GO 92191
92115: LD_INT 4
92117: DOUBLE
92118: EQUAL
92119: IFTRUE 92123
92121: GO 92130
92123: POP
// hHackInvincible ; 5 :
92124: CALL 105004 0 0
92128: GO 92191
92130: LD_INT 5
92132: DOUBLE
92133: EQUAL
92134: IFTRUE 92138
92136: GO 92145
92138: POP
// hHackInvisible ; 6 :
92139: CALL 105115 0 0
92143: GO 92191
92145: LD_INT 6
92147: DOUBLE
92148: EQUAL
92149: IFTRUE 92153
92151: GO 92160
92153: POP
// hHackChangeYourSide ; 7 :
92154: CALL 105172 0 0
92158: GO 92191
92160: LD_INT 7
92162: DOUBLE
92163: EQUAL
92164: IFTRUE 92168
92166: GO 92175
92168: POP
// hHackChangeUnitSide ; 8 :
92169: CALL 105214 0 0
92173: GO 92191
92175: LD_INT 8
92177: DOUBLE
92178: EQUAL
92179: IFTRUE 92183
92181: GO 92190
92183: POP
// hHackFog ; end ;
92184: CALL 105315 0 0
92188: GO 92191
92190: POP
// end ; if p2 = game_save_mode then
92191: LD_VAR 0 2
92195: PUSH
92196: LD_INT 102
92198: EQUAL
92199: IFFALSE 92254
// begin if p3 = 1 then
92201: LD_VAR 0 3
92205: PUSH
92206: LD_INT 1
92208: EQUAL
92209: IFFALSE 92221
// globalGameSaveCounter := p4 ;
92211: LD_ADDR_EXP 108
92215: PUSH
92216: LD_VAR 0 4
92220: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
92221: LD_VAR 0 3
92225: PUSH
92226: LD_INT 2
92228: EQUAL
92229: PUSH
92230: LD_EXP 108
92234: AND
92235: IFFALSE 92254
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92237: LD_STRING setGameSaveCounter(
92239: PUSH
92240: LD_EXP 108
92244: STR
92245: PUSH
92246: LD_STRING )
92248: STR
92249: PPUSH
92250: CALL_OW 559
// end ; end ;
92254: LD_VAR 0 7
92258: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92259: LD_INT 0
92261: PPUSH
// streamModeActive := false ;
92262: LD_ADDR_EXP 109
92266: PUSH
92267: LD_INT 0
92269: ST_TO_ADDR
// normalCounter := 36 ;
92270: LD_ADDR_EXP 110
92274: PUSH
92275: LD_INT 36
92277: ST_TO_ADDR
// hardcoreCounter := 18 ;
92278: LD_ADDR_EXP 111
92282: PUSH
92283: LD_INT 18
92285: ST_TO_ADDR
// sRocket := false ;
92286: LD_ADDR_EXP 114
92290: PUSH
92291: LD_INT 0
92293: ST_TO_ADDR
// sSpeed := false ;
92294: LD_ADDR_EXP 113
92298: PUSH
92299: LD_INT 0
92301: ST_TO_ADDR
// sEngine := false ;
92302: LD_ADDR_EXP 115
92306: PUSH
92307: LD_INT 0
92309: ST_TO_ADDR
// sSpec := false ;
92310: LD_ADDR_EXP 112
92314: PUSH
92315: LD_INT 0
92317: ST_TO_ADDR
// sLevel := false ;
92318: LD_ADDR_EXP 116
92322: PUSH
92323: LD_INT 0
92325: ST_TO_ADDR
// sArmoury := false ;
92326: LD_ADDR_EXP 117
92330: PUSH
92331: LD_INT 0
92333: ST_TO_ADDR
// sRadar := false ;
92334: LD_ADDR_EXP 118
92338: PUSH
92339: LD_INT 0
92341: ST_TO_ADDR
// sBunker := false ;
92342: LD_ADDR_EXP 119
92346: PUSH
92347: LD_INT 0
92349: ST_TO_ADDR
// sHack := false ;
92350: LD_ADDR_EXP 120
92354: PUSH
92355: LD_INT 0
92357: ST_TO_ADDR
// sFire := false ;
92358: LD_ADDR_EXP 121
92362: PUSH
92363: LD_INT 0
92365: ST_TO_ADDR
// sRefresh := false ;
92366: LD_ADDR_EXP 122
92370: PUSH
92371: LD_INT 0
92373: ST_TO_ADDR
// sExp := false ;
92374: LD_ADDR_EXP 123
92378: PUSH
92379: LD_INT 0
92381: ST_TO_ADDR
// sDepot := false ;
92382: LD_ADDR_EXP 124
92386: PUSH
92387: LD_INT 0
92389: ST_TO_ADDR
// sFlag := false ;
92390: LD_ADDR_EXP 125
92394: PUSH
92395: LD_INT 0
92397: ST_TO_ADDR
// sKamikadze := false ;
92398: LD_ADDR_EXP 133
92402: PUSH
92403: LD_INT 0
92405: ST_TO_ADDR
// sTroll := false ;
92406: LD_ADDR_EXP 134
92410: PUSH
92411: LD_INT 0
92413: ST_TO_ADDR
// sSlow := false ;
92414: LD_ADDR_EXP 135
92418: PUSH
92419: LD_INT 0
92421: ST_TO_ADDR
// sLack := false ;
92422: LD_ADDR_EXP 136
92426: PUSH
92427: LD_INT 0
92429: ST_TO_ADDR
// sTank := false ;
92430: LD_ADDR_EXP 138
92434: PUSH
92435: LD_INT 0
92437: ST_TO_ADDR
// sRemote := false ;
92438: LD_ADDR_EXP 139
92442: PUSH
92443: LD_INT 0
92445: ST_TO_ADDR
// sPowell := false ;
92446: LD_ADDR_EXP 140
92450: PUSH
92451: LD_INT 0
92453: ST_TO_ADDR
// sTeleport := false ;
92454: LD_ADDR_EXP 143
92458: PUSH
92459: LD_INT 0
92461: ST_TO_ADDR
// sOilTower := false ;
92462: LD_ADDR_EXP 145
92466: PUSH
92467: LD_INT 0
92469: ST_TO_ADDR
// sShovel := false ;
92470: LD_ADDR_EXP 146
92474: PUSH
92475: LD_INT 0
92477: ST_TO_ADDR
// sSheik := false ;
92478: LD_ADDR_EXP 147
92482: PUSH
92483: LD_INT 0
92485: ST_TO_ADDR
// sEarthquake := false ;
92486: LD_ADDR_EXP 149
92490: PUSH
92491: LD_INT 0
92493: ST_TO_ADDR
// sAI := false ;
92494: LD_ADDR_EXP 150
92498: PUSH
92499: LD_INT 0
92501: ST_TO_ADDR
// sCargo := false ;
92502: LD_ADDR_EXP 153
92506: PUSH
92507: LD_INT 0
92509: ST_TO_ADDR
// sDLaser := false ;
92510: LD_ADDR_EXP 154
92514: PUSH
92515: LD_INT 0
92517: ST_TO_ADDR
// sExchange := false ;
92518: LD_ADDR_EXP 155
92522: PUSH
92523: LD_INT 0
92525: ST_TO_ADDR
// sFac := false ;
92526: LD_ADDR_EXP 156
92530: PUSH
92531: LD_INT 0
92533: ST_TO_ADDR
// sPower := false ;
92534: LD_ADDR_EXP 157
92538: PUSH
92539: LD_INT 0
92541: ST_TO_ADDR
// sRandom := false ;
92542: LD_ADDR_EXP 158
92546: PUSH
92547: LD_INT 0
92549: ST_TO_ADDR
// sShield := false ;
92550: LD_ADDR_EXP 159
92554: PUSH
92555: LD_INT 0
92557: ST_TO_ADDR
// sTime := false ;
92558: LD_ADDR_EXP 160
92562: PUSH
92563: LD_INT 0
92565: ST_TO_ADDR
// sTools := false ;
92566: LD_ADDR_EXP 161
92570: PUSH
92571: LD_INT 0
92573: ST_TO_ADDR
// sSold := false ;
92574: LD_ADDR_EXP 126
92578: PUSH
92579: LD_INT 0
92581: ST_TO_ADDR
// sDiff := false ;
92582: LD_ADDR_EXP 127
92586: PUSH
92587: LD_INT 0
92589: ST_TO_ADDR
// sFog := false ;
92590: LD_ADDR_EXP 130
92594: PUSH
92595: LD_INT 0
92597: ST_TO_ADDR
// sReset := false ;
92598: LD_ADDR_EXP 131
92602: PUSH
92603: LD_INT 0
92605: ST_TO_ADDR
// sSun := false ;
92606: LD_ADDR_EXP 132
92610: PUSH
92611: LD_INT 0
92613: ST_TO_ADDR
// sTiger := false ;
92614: LD_ADDR_EXP 128
92618: PUSH
92619: LD_INT 0
92621: ST_TO_ADDR
// sBomb := false ;
92622: LD_ADDR_EXP 129
92626: PUSH
92627: LD_INT 0
92629: ST_TO_ADDR
// sWound := false ;
92630: LD_ADDR_EXP 137
92634: PUSH
92635: LD_INT 0
92637: ST_TO_ADDR
// sBetray := false ;
92638: LD_ADDR_EXP 141
92642: PUSH
92643: LD_INT 0
92645: ST_TO_ADDR
// sContamin := false ;
92646: LD_ADDR_EXP 142
92650: PUSH
92651: LD_INT 0
92653: ST_TO_ADDR
// sOil := false ;
92654: LD_ADDR_EXP 144
92658: PUSH
92659: LD_INT 0
92661: ST_TO_ADDR
// sStu := false ;
92662: LD_ADDR_EXP 148
92666: PUSH
92667: LD_INT 0
92669: ST_TO_ADDR
// sBazooka := false ;
92670: LD_ADDR_EXP 151
92674: PUSH
92675: LD_INT 0
92677: ST_TO_ADDR
// sMortar := false ;
92678: LD_ADDR_EXP 152
92682: PUSH
92683: LD_INT 0
92685: ST_TO_ADDR
// sRanger := false ;
92686: LD_ADDR_EXP 162
92690: PUSH
92691: LD_INT 0
92693: ST_TO_ADDR
// sComputer := false ;
92694: LD_ADDR_EXP 163
92698: PUSH
92699: LD_INT 0
92701: ST_TO_ADDR
// s30 := false ;
92702: LD_ADDR_EXP 164
92706: PUSH
92707: LD_INT 0
92709: ST_TO_ADDR
// s60 := false ;
92710: LD_ADDR_EXP 165
92714: PUSH
92715: LD_INT 0
92717: ST_TO_ADDR
// end ;
92718: LD_VAR 0 1
92722: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92723: LD_INT 0
92725: PPUSH
92726: PPUSH
92727: PPUSH
92728: PPUSH
92729: PPUSH
92730: PPUSH
92731: PPUSH
// result := [ ] ;
92732: LD_ADDR_VAR 0 2
92736: PUSH
92737: EMPTY
92738: ST_TO_ADDR
// if campaign_id = 1 then
92739: LD_OWVAR 69
92743: PUSH
92744: LD_INT 1
92746: EQUAL
92747: IFFALSE 95913
// begin case mission_number of 1 :
92749: LD_OWVAR 70
92753: PUSH
92754: LD_INT 1
92756: DOUBLE
92757: EQUAL
92758: IFTRUE 92762
92760: GO 92838
92762: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92763: LD_ADDR_VAR 0 2
92767: PUSH
92768: LD_INT 2
92770: PUSH
92771: LD_INT 4
92773: PUSH
92774: LD_INT 11
92776: PUSH
92777: LD_INT 12
92779: PUSH
92780: LD_INT 15
92782: PUSH
92783: LD_INT 16
92785: PUSH
92786: LD_INT 22
92788: PUSH
92789: LD_INT 23
92791: PUSH
92792: LD_INT 26
92794: PUSH
92795: EMPTY
92796: LIST
92797: LIST
92798: LIST
92799: LIST
92800: LIST
92801: LIST
92802: LIST
92803: LIST
92804: LIST
92805: PUSH
92806: LD_INT 101
92808: PUSH
92809: LD_INT 102
92811: PUSH
92812: LD_INT 106
92814: PUSH
92815: LD_INT 116
92817: PUSH
92818: LD_INT 117
92820: PUSH
92821: LD_INT 118
92823: PUSH
92824: EMPTY
92825: LIST
92826: LIST
92827: LIST
92828: LIST
92829: LIST
92830: LIST
92831: PUSH
92832: EMPTY
92833: LIST
92834: LIST
92835: ST_TO_ADDR
92836: GO 95911
92838: LD_INT 2
92840: DOUBLE
92841: EQUAL
92842: IFTRUE 92846
92844: GO 92930
92846: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92847: LD_ADDR_VAR 0 2
92851: PUSH
92852: LD_INT 2
92854: PUSH
92855: LD_INT 4
92857: PUSH
92858: LD_INT 11
92860: PUSH
92861: LD_INT 12
92863: PUSH
92864: LD_INT 15
92866: PUSH
92867: LD_INT 16
92869: PUSH
92870: LD_INT 22
92872: PUSH
92873: LD_INT 23
92875: PUSH
92876: LD_INT 26
92878: PUSH
92879: EMPTY
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: PUSH
92890: LD_INT 101
92892: PUSH
92893: LD_INT 102
92895: PUSH
92896: LD_INT 105
92898: PUSH
92899: LD_INT 106
92901: PUSH
92902: LD_INT 108
92904: PUSH
92905: LD_INT 116
92907: PUSH
92908: LD_INT 117
92910: PUSH
92911: LD_INT 118
92913: PUSH
92914: EMPTY
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: PUSH
92924: EMPTY
92925: LIST
92926: LIST
92927: ST_TO_ADDR
92928: GO 95911
92930: LD_INT 3
92932: DOUBLE
92933: EQUAL
92934: IFTRUE 92938
92936: GO 93026
92938: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92939: LD_ADDR_VAR 0 2
92943: PUSH
92944: LD_INT 2
92946: PUSH
92947: LD_INT 4
92949: PUSH
92950: LD_INT 5
92952: PUSH
92953: LD_INT 11
92955: PUSH
92956: LD_INT 12
92958: PUSH
92959: LD_INT 15
92961: PUSH
92962: LD_INT 16
92964: PUSH
92965: LD_INT 22
92967: PUSH
92968: LD_INT 26
92970: PUSH
92971: LD_INT 36
92973: PUSH
92974: EMPTY
92975: LIST
92976: LIST
92977: LIST
92978: LIST
92979: LIST
92980: LIST
92981: LIST
92982: LIST
92983: LIST
92984: LIST
92985: PUSH
92986: LD_INT 101
92988: PUSH
92989: LD_INT 102
92991: PUSH
92992: LD_INT 105
92994: PUSH
92995: LD_INT 106
92997: PUSH
92998: LD_INT 108
93000: PUSH
93001: LD_INT 116
93003: PUSH
93004: LD_INT 117
93006: PUSH
93007: LD_INT 118
93009: PUSH
93010: EMPTY
93011: LIST
93012: LIST
93013: LIST
93014: LIST
93015: LIST
93016: LIST
93017: LIST
93018: LIST
93019: PUSH
93020: EMPTY
93021: LIST
93022: LIST
93023: ST_TO_ADDR
93024: GO 95911
93026: LD_INT 4
93028: DOUBLE
93029: EQUAL
93030: IFTRUE 93034
93032: GO 93130
93034: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
93035: LD_ADDR_VAR 0 2
93039: PUSH
93040: LD_INT 2
93042: PUSH
93043: LD_INT 4
93045: PUSH
93046: LD_INT 5
93048: PUSH
93049: LD_INT 8
93051: PUSH
93052: LD_INT 11
93054: PUSH
93055: LD_INT 12
93057: PUSH
93058: LD_INT 15
93060: PUSH
93061: LD_INT 16
93063: PUSH
93064: LD_INT 22
93066: PUSH
93067: LD_INT 23
93069: PUSH
93070: LD_INT 26
93072: PUSH
93073: LD_INT 36
93075: PUSH
93076: EMPTY
93077: LIST
93078: LIST
93079: LIST
93080: LIST
93081: LIST
93082: LIST
93083: LIST
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: PUSH
93090: LD_INT 101
93092: PUSH
93093: LD_INT 102
93095: PUSH
93096: LD_INT 105
93098: PUSH
93099: LD_INT 106
93101: PUSH
93102: LD_INT 108
93104: PUSH
93105: LD_INT 116
93107: PUSH
93108: LD_INT 117
93110: PUSH
93111: LD_INT 118
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: PUSH
93124: EMPTY
93125: LIST
93126: LIST
93127: ST_TO_ADDR
93128: GO 95911
93130: LD_INT 5
93132: DOUBLE
93133: EQUAL
93134: IFTRUE 93138
93136: GO 93250
93138: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
93139: LD_ADDR_VAR 0 2
93143: PUSH
93144: LD_INT 2
93146: PUSH
93147: LD_INT 4
93149: PUSH
93150: LD_INT 5
93152: PUSH
93153: LD_INT 6
93155: PUSH
93156: LD_INT 8
93158: PUSH
93159: LD_INT 11
93161: PUSH
93162: LD_INT 12
93164: PUSH
93165: LD_INT 15
93167: PUSH
93168: LD_INT 16
93170: PUSH
93171: LD_INT 22
93173: PUSH
93174: LD_INT 23
93176: PUSH
93177: LD_INT 25
93179: PUSH
93180: LD_INT 26
93182: PUSH
93183: LD_INT 36
93185: PUSH
93186: EMPTY
93187: LIST
93188: LIST
93189: LIST
93190: LIST
93191: LIST
93192: LIST
93193: LIST
93194: LIST
93195: LIST
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: PUSH
93202: LD_INT 101
93204: PUSH
93205: LD_INT 102
93207: PUSH
93208: LD_INT 105
93210: PUSH
93211: LD_INT 106
93213: PUSH
93214: LD_INT 108
93216: PUSH
93217: LD_INT 109
93219: PUSH
93220: LD_INT 112
93222: PUSH
93223: LD_INT 116
93225: PUSH
93226: LD_INT 117
93228: PUSH
93229: LD_INT 118
93231: PUSH
93232: EMPTY
93233: LIST
93234: LIST
93235: LIST
93236: LIST
93237: LIST
93238: LIST
93239: LIST
93240: LIST
93241: LIST
93242: LIST
93243: PUSH
93244: EMPTY
93245: LIST
93246: LIST
93247: ST_TO_ADDR
93248: GO 95911
93250: LD_INT 6
93252: DOUBLE
93253: EQUAL
93254: IFTRUE 93258
93256: GO 93390
93258: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93259: LD_ADDR_VAR 0 2
93263: PUSH
93264: LD_INT 2
93266: PUSH
93267: LD_INT 4
93269: PUSH
93270: LD_INT 5
93272: PUSH
93273: LD_INT 6
93275: PUSH
93276: LD_INT 8
93278: PUSH
93279: LD_INT 11
93281: PUSH
93282: LD_INT 12
93284: PUSH
93285: LD_INT 15
93287: PUSH
93288: LD_INT 16
93290: PUSH
93291: LD_INT 20
93293: PUSH
93294: LD_INT 21
93296: PUSH
93297: LD_INT 22
93299: PUSH
93300: LD_INT 23
93302: PUSH
93303: LD_INT 25
93305: PUSH
93306: LD_INT 26
93308: PUSH
93309: LD_INT 30
93311: PUSH
93312: LD_INT 31
93314: PUSH
93315: LD_INT 32
93317: PUSH
93318: LD_INT 36
93320: PUSH
93321: EMPTY
93322: LIST
93323: LIST
93324: LIST
93325: LIST
93326: LIST
93327: LIST
93328: LIST
93329: LIST
93330: LIST
93331: LIST
93332: LIST
93333: LIST
93334: LIST
93335: LIST
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: PUSH
93342: LD_INT 101
93344: PUSH
93345: LD_INT 102
93347: PUSH
93348: LD_INT 105
93350: PUSH
93351: LD_INT 106
93353: PUSH
93354: LD_INT 108
93356: PUSH
93357: LD_INT 109
93359: PUSH
93360: LD_INT 112
93362: PUSH
93363: LD_INT 116
93365: PUSH
93366: LD_INT 117
93368: PUSH
93369: LD_INT 118
93371: PUSH
93372: EMPTY
93373: LIST
93374: LIST
93375: LIST
93376: LIST
93377: LIST
93378: LIST
93379: LIST
93380: LIST
93381: LIST
93382: LIST
93383: PUSH
93384: EMPTY
93385: LIST
93386: LIST
93387: ST_TO_ADDR
93388: GO 95911
93390: LD_INT 7
93392: DOUBLE
93393: EQUAL
93394: IFTRUE 93398
93396: GO 93510
93398: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93399: LD_ADDR_VAR 0 2
93403: PUSH
93404: LD_INT 2
93406: PUSH
93407: LD_INT 4
93409: PUSH
93410: LD_INT 5
93412: PUSH
93413: LD_INT 7
93415: PUSH
93416: LD_INT 11
93418: PUSH
93419: LD_INT 12
93421: PUSH
93422: LD_INT 15
93424: PUSH
93425: LD_INT 16
93427: PUSH
93428: LD_INT 20
93430: PUSH
93431: LD_INT 21
93433: PUSH
93434: LD_INT 22
93436: PUSH
93437: LD_INT 23
93439: PUSH
93440: LD_INT 25
93442: PUSH
93443: LD_INT 26
93445: PUSH
93446: EMPTY
93447: LIST
93448: LIST
93449: LIST
93450: LIST
93451: LIST
93452: LIST
93453: LIST
93454: LIST
93455: LIST
93456: LIST
93457: LIST
93458: LIST
93459: LIST
93460: LIST
93461: PUSH
93462: LD_INT 101
93464: PUSH
93465: LD_INT 102
93467: PUSH
93468: LD_INT 103
93470: PUSH
93471: LD_INT 105
93473: PUSH
93474: LD_INT 106
93476: PUSH
93477: LD_INT 108
93479: PUSH
93480: LD_INT 112
93482: PUSH
93483: LD_INT 116
93485: PUSH
93486: LD_INT 117
93488: PUSH
93489: LD_INT 118
93491: PUSH
93492: EMPTY
93493: LIST
93494: LIST
93495: LIST
93496: LIST
93497: LIST
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: ST_TO_ADDR
93508: GO 95911
93510: LD_INT 8
93512: DOUBLE
93513: EQUAL
93514: IFTRUE 93518
93516: GO 93658
93518: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93519: LD_ADDR_VAR 0 2
93523: PUSH
93524: LD_INT 2
93526: PUSH
93527: LD_INT 4
93529: PUSH
93530: LD_INT 5
93532: PUSH
93533: LD_INT 6
93535: PUSH
93536: LD_INT 7
93538: PUSH
93539: LD_INT 8
93541: PUSH
93542: LD_INT 11
93544: PUSH
93545: LD_INT 12
93547: PUSH
93548: LD_INT 15
93550: PUSH
93551: LD_INT 16
93553: PUSH
93554: LD_INT 20
93556: PUSH
93557: LD_INT 21
93559: PUSH
93560: LD_INT 22
93562: PUSH
93563: LD_INT 23
93565: PUSH
93566: LD_INT 25
93568: PUSH
93569: LD_INT 26
93571: PUSH
93572: LD_INT 30
93574: PUSH
93575: LD_INT 31
93577: PUSH
93578: LD_INT 32
93580: PUSH
93581: LD_INT 36
93583: PUSH
93584: EMPTY
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: PUSH
93606: LD_INT 101
93608: PUSH
93609: LD_INT 102
93611: PUSH
93612: LD_INT 103
93614: PUSH
93615: LD_INT 105
93617: PUSH
93618: LD_INT 106
93620: PUSH
93621: LD_INT 108
93623: PUSH
93624: LD_INT 109
93626: PUSH
93627: LD_INT 112
93629: PUSH
93630: LD_INT 116
93632: PUSH
93633: LD_INT 117
93635: PUSH
93636: LD_INT 118
93638: PUSH
93639: EMPTY
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: PUSH
93652: EMPTY
93653: LIST
93654: LIST
93655: ST_TO_ADDR
93656: GO 95911
93658: LD_INT 9
93660: DOUBLE
93661: EQUAL
93662: IFTRUE 93666
93664: GO 93814
93666: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93667: LD_ADDR_VAR 0 2
93671: PUSH
93672: LD_INT 2
93674: PUSH
93675: LD_INT 4
93677: PUSH
93678: LD_INT 5
93680: PUSH
93681: LD_INT 6
93683: PUSH
93684: LD_INT 7
93686: PUSH
93687: LD_INT 8
93689: PUSH
93690: LD_INT 11
93692: PUSH
93693: LD_INT 12
93695: PUSH
93696: LD_INT 15
93698: PUSH
93699: LD_INT 16
93701: PUSH
93702: LD_INT 20
93704: PUSH
93705: LD_INT 21
93707: PUSH
93708: LD_INT 22
93710: PUSH
93711: LD_INT 23
93713: PUSH
93714: LD_INT 25
93716: PUSH
93717: LD_INT 26
93719: PUSH
93720: LD_INT 28
93722: PUSH
93723: LD_INT 30
93725: PUSH
93726: LD_INT 31
93728: PUSH
93729: LD_INT 32
93731: PUSH
93732: LD_INT 36
93734: PUSH
93735: EMPTY
93736: LIST
93737: LIST
93738: LIST
93739: LIST
93740: LIST
93741: LIST
93742: LIST
93743: LIST
93744: LIST
93745: LIST
93746: LIST
93747: LIST
93748: LIST
93749: LIST
93750: LIST
93751: LIST
93752: LIST
93753: LIST
93754: LIST
93755: LIST
93756: LIST
93757: PUSH
93758: LD_INT 101
93760: PUSH
93761: LD_INT 102
93763: PUSH
93764: LD_INT 103
93766: PUSH
93767: LD_INT 105
93769: PUSH
93770: LD_INT 106
93772: PUSH
93773: LD_INT 108
93775: PUSH
93776: LD_INT 109
93778: PUSH
93779: LD_INT 112
93781: PUSH
93782: LD_INT 114
93784: PUSH
93785: LD_INT 116
93787: PUSH
93788: LD_INT 117
93790: PUSH
93791: LD_INT 118
93793: PUSH
93794: EMPTY
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: PUSH
93808: EMPTY
93809: LIST
93810: LIST
93811: ST_TO_ADDR
93812: GO 95911
93814: LD_INT 10
93816: DOUBLE
93817: EQUAL
93818: IFTRUE 93822
93820: GO 94018
93822: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93823: LD_ADDR_VAR 0 2
93827: PUSH
93828: LD_INT 2
93830: PUSH
93831: LD_INT 4
93833: PUSH
93834: LD_INT 5
93836: PUSH
93837: LD_INT 6
93839: PUSH
93840: LD_INT 7
93842: PUSH
93843: LD_INT 8
93845: PUSH
93846: LD_INT 9
93848: PUSH
93849: LD_INT 10
93851: PUSH
93852: LD_INT 11
93854: PUSH
93855: LD_INT 12
93857: PUSH
93858: LD_INT 13
93860: PUSH
93861: LD_INT 14
93863: PUSH
93864: LD_INT 15
93866: PUSH
93867: LD_INT 16
93869: PUSH
93870: LD_INT 17
93872: PUSH
93873: LD_INT 18
93875: PUSH
93876: LD_INT 19
93878: PUSH
93879: LD_INT 20
93881: PUSH
93882: LD_INT 21
93884: PUSH
93885: LD_INT 22
93887: PUSH
93888: LD_INT 23
93890: PUSH
93891: LD_INT 24
93893: PUSH
93894: LD_INT 25
93896: PUSH
93897: LD_INT 26
93899: PUSH
93900: LD_INT 28
93902: PUSH
93903: LD_INT 30
93905: PUSH
93906: LD_INT 31
93908: PUSH
93909: LD_INT 32
93911: PUSH
93912: LD_INT 36
93914: PUSH
93915: EMPTY
93916: LIST
93917: LIST
93918: LIST
93919: LIST
93920: LIST
93921: LIST
93922: LIST
93923: LIST
93924: LIST
93925: LIST
93926: LIST
93927: LIST
93928: LIST
93929: LIST
93930: LIST
93931: LIST
93932: LIST
93933: LIST
93934: LIST
93935: LIST
93936: LIST
93937: LIST
93938: LIST
93939: LIST
93940: LIST
93941: LIST
93942: LIST
93943: LIST
93944: LIST
93945: PUSH
93946: LD_INT 101
93948: PUSH
93949: LD_INT 102
93951: PUSH
93952: LD_INT 103
93954: PUSH
93955: LD_INT 104
93957: PUSH
93958: LD_INT 105
93960: PUSH
93961: LD_INT 106
93963: PUSH
93964: LD_INT 107
93966: PUSH
93967: LD_INT 108
93969: PUSH
93970: LD_INT 109
93972: PUSH
93973: LD_INT 110
93975: PUSH
93976: LD_INT 111
93978: PUSH
93979: LD_INT 112
93981: PUSH
93982: LD_INT 114
93984: PUSH
93985: LD_INT 116
93987: PUSH
93988: LD_INT 117
93990: PUSH
93991: LD_INT 118
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: LIST
93998: LIST
93999: LIST
94000: LIST
94001: LIST
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: LIST
94011: PUSH
94012: EMPTY
94013: LIST
94014: LIST
94015: ST_TO_ADDR
94016: GO 95911
94018: LD_INT 11
94020: DOUBLE
94021: EQUAL
94022: IFTRUE 94026
94024: GO 94230
94026: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
94027: LD_ADDR_VAR 0 2
94031: PUSH
94032: LD_INT 2
94034: PUSH
94035: LD_INT 3
94037: PUSH
94038: LD_INT 4
94040: PUSH
94041: LD_INT 5
94043: PUSH
94044: LD_INT 6
94046: PUSH
94047: LD_INT 7
94049: PUSH
94050: LD_INT 8
94052: PUSH
94053: LD_INT 9
94055: PUSH
94056: LD_INT 10
94058: PUSH
94059: LD_INT 11
94061: PUSH
94062: LD_INT 12
94064: PUSH
94065: LD_INT 13
94067: PUSH
94068: LD_INT 14
94070: PUSH
94071: LD_INT 15
94073: PUSH
94074: LD_INT 16
94076: PUSH
94077: LD_INT 17
94079: PUSH
94080: LD_INT 18
94082: PUSH
94083: LD_INT 19
94085: PUSH
94086: LD_INT 20
94088: PUSH
94089: LD_INT 21
94091: PUSH
94092: LD_INT 22
94094: PUSH
94095: LD_INT 23
94097: PUSH
94098: LD_INT 24
94100: PUSH
94101: LD_INT 25
94103: PUSH
94104: LD_INT 26
94106: PUSH
94107: LD_INT 28
94109: PUSH
94110: LD_INT 30
94112: PUSH
94113: LD_INT 31
94115: PUSH
94116: LD_INT 32
94118: PUSH
94119: LD_INT 34
94121: PUSH
94122: LD_INT 36
94124: PUSH
94125: EMPTY
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: LIST
94144: LIST
94145: LIST
94146: LIST
94147: LIST
94148: LIST
94149: LIST
94150: LIST
94151: LIST
94152: LIST
94153: LIST
94154: LIST
94155: LIST
94156: LIST
94157: PUSH
94158: LD_INT 101
94160: PUSH
94161: LD_INT 102
94163: PUSH
94164: LD_INT 103
94166: PUSH
94167: LD_INT 104
94169: PUSH
94170: LD_INT 105
94172: PUSH
94173: LD_INT 106
94175: PUSH
94176: LD_INT 107
94178: PUSH
94179: LD_INT 108
94181: PUSH
94182: LD_INT 109
94184: PUSH
94185: LD_INT 110
94187: PUSH
94188: LD_INT 111
94190: PUSH
94191: LD_INT 112
94193: PUSH
94194: LD_INT 114
94196: PUSH
94197: LD_INT 116
94199: PUSH
94200: LD_INT 117
94202: PUSH
94203: LD_INT 118
94205: PUSH
94206: EMPTY
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: LIST
94219: LIST
94220: LIST
94221: LIST
94222: LIST
94223: PUSH
94224: EMPTY
94225: LIST
94226: LIST
94227: ST_TO_ADDR
94228: GO 95911
94230: LD_INT 12
94232: DOUBLE
94233: EQUAL
94234: IFTRUE 94238
94236: GO 94458
94238: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94239: LD_ADDR_VAR 0 2
94243: PUSH
94244: LD_INT 1
94246: PUSH
94247: LD_INT 2
94249: PUSH
94250: LD_INT 3
94252: PUSH
94253: LD_INT 4
94255: PUSH
94256: LD_INT 5
94258: PUSH
94259: LD_INT 6
94261: PUSH
94262: LD_INT 7
94264: PUSH
94265: LD_INT 8
94267: PUSH
94268: LD_INT 9
94270: PUSH
94271: LD_INT 10
94273: PUSH
94274: LD_INT 11
94276: PUSH
94277: LD_INT 12
94279: PUSH
94280: LD_INT 13
94282: PUSH
94283: LD_INT 14
94285: PUSH
94286: LD_INT 15
94288: PUSH
94289: LD_INT 16
94291: PUSH
94292: LD_INT 17
94294: PUSH
94295: LD_INT 18
94297: PUSH
94298: LD_INT 19
94300: PUSH
94301: LD_INT 20
94303: PUSH
94304: LD_INT 21
94306: PUSH
94307: LD_INT 22
94309: PUSH
94310: LD_INT 23
94312: PUSH
94313: LD_INT 24
94315: PUSH
94316: LD_INT 25
94318: PUSH
94319: LD_INT 26
94321: PUSH
94322: LD_INT 27
94324: PUSH
94325: LD_INT 28
94327: PUSH
94328: LD_INT 30
94330: PUSH
94331: LD_INT 31
94333: PUSH
94334: LD_INT 32
94336: PUSH
94337: LD_INT 33
94339: PUSH
94340: LD_INT 34
94342: PUSH
94343: LD_INT 36
94345: PUSH
94346: EMPTY
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: LIST
94360: LIST
94361: LIST
94362: LIST
94363: LIST
94364: LIST
94365: LIST
94366: LIST
94367: LIST
94368: LIST
94369: LIST
94370: LIST
94371: LIST
94372: LIST
94373: LIST
94374: LIST
94375: LIST
94376: LIST
94377: LIST
94378: LIST
94379: LIST
94380: LIST
94381: PUSH
94382: LD_INT 101
94384: PUSH
94385: LD_INT 102
94387: PUSH
94388: LD_INT 103
94390: PUSH
94391: LD_INT 104
94393: PUSH
94394: LD_INT 105
94396: PUSH
94397: LD_INT 106
94399: PUSH
94400: LD_INT 107
94402: PUSH
94403: LD_INT 108
94405: PUSH
94406: LD_INT 109
94408: PUSH
94409: LD_INT 110
94411: PUSH
94412: LD_INT 111
94414: PUSH
94415: LD_INT 112
94417: PUSH
94418: LD_INT 113
94420: PUSH
94421: LD_INT 114
94423: PUSH
94424: LD_INT 116
94426: PUSH
94427: LD_INT 117
94429: PUSH
94430: LD_INT 118
94432: PUSH
94433: EMPTY
94434: LIST
94435: LIST
94436: LIST
94437: LIST
94438: LIST
94439: LIST
94440: LIST
94441: LIST
94442: LIST
94443: LIST
94444: LIST
94445: LIST
94446: LIST
94447: LIST
94448: LIST
94449: LIST
94450: LIST
94451: PUSH
94452: EMPTY
94453: LIST
94454: LIST
94455: ST_TO_ADDR
94456: GO 95911
94458: LD_INT 13
94460: DOUBLE
94461: EQUAL
94462: IFTRUE 94466
94464: GO 94674
94466: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94467: LD_ADDR_VAR 0 2
94471: PUSH
94472: LD_INT 1
94474: PUSH
94475: LD_INT 2
94477: PUSH
94478: LD_INT 3
94480: PUSH
94481: LD_INT 4
94483: PUSH
94484: LD_INT 5
94486: PUSH
94487: LD_INT 8
94489: PUSH
94490: LD_INT 9
94492: PUSH
94493: LD_INT 10
94495: PUSH
94496: LD_INT 11
94498: PUSH
94499: LD_INT 12
94501: PUSH
94502: LD_INT 14
94504: PUSH
94505: LD_INT 15
94507: PUSH
94508: LD_INT 16
94510: PUSH
94511: LD_INT 17
94513: PUSH
94514: LD_INT 18
94516: PUSH
94517: LD_INT 19
94519: PUSH
94520: LD_INT 20
94522: PUSH
94523: LD_INT 21
94525: PUSH
94526: LD_INT 22
94528: PUSH
94529: LD_INT 23
94531: PUSH
94532: LD_INT 24
94534: PUSH
94535: LD_INT 25
94537: PUSH
94538: LD_INT 26
94540: PUSH
94541: LD_INT 27
94543: PUSH
94544: LD_INT 28
94546: PUSH
94547: LD_INT 30
94549: PUSH
94550: LD_INT 31
94552: PUSH
94553: LD_INT 32
94555: PUSH
94556: LD_INT 33
94558: PUSH
94559: LD_INT 34
94561: PUSH
94562: LD_INT 36
94564: PUSH
94565: EMPTY
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: PUSH
94598: LD_INT 101
94600: PUSH
94601: LD_INT 102
94603: PUSH
94604: LD_INT 103
94606: PUSH
94607: LD_INT 104
94609: PUSH
94610: LD_INT 105
94612: PUSH
94613: LD_INT 106
94615: PUSH
94616: LD_INT 107
94618: PUSH
94619: LD_INT 108
94621: PUSH
94622: LD_INT 109
94624: PUSH
94625: LD_INT 110
94627: PUSH
94628: LD_INT 111
94630: PUSH
94631: LD_INT 112
94633: PUSH
94634: LD_INT 113
94636: PUSH
94637: LD_INT 114
94639: PUSH
94640: LD_INT 116
94642: PUSH
94643: LD_INT 117
94645: PUSH
94646: LD_INT 118
94648: PUSH
94649: EMPTY
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: LIST
94662: LIST
94663: LIST
94664: LIST
94665: LIST
94666: LIST
94667: PUSH
94668: EMPTY
94669: LIST
94670: LIST
94671: ST_TO_ADDR
94672: GO 95911
94674: LD_INT 14
94676: DOUBLE
94677: EQUAL
94678: IFTRUE 94682
94680: GO 94906
94682: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94683: LD_ADDR_VAR 0 2
94687: PUSH
94688: LD_INT 1
94690: PUSH
94691: LD_INT 2
94693: PUSH
94694: LD_INT 3
94696: PUSH
94697: LD_INT 4
94699: PUSH
94700: LD_INT 5
94702: PUSH
94703: LD_INT 6
94705: PUSH
94706: LD_INT 7
94708: PUSH
94709: LD_INT 8
94711: PUSH
94712: LD_INT 9
94714: PUSH
94715: LD_INT 10
94717: PUSH
94718: LD_INT 11
94720: PUSH
94721: LD_INT 12
94723: PUSH
94724: LD_INT 13
94726: PUSH
94727: LD_INT 14
94729: PUSH
94730: LD_INT 15
94732: PUSH
94733: LD_INT 16
94735: PUSH
94736: LD_INT 17
94738: PUSH
94739: LD_INT 18
94741: PUSH
94742: LD_INT 19
94744: PUSH
94745: LD_INT 20
94747: PUSH
94748: LD_INT 21
94750: PUSH
94751: LD_INT 22
94753: PUSH
94754: LD_INT 23
94756: PUSH
94757: LD_INT 24
94759: PUSH
94760: LD_INT 25
94762: PUSH
94763: LD_INT 26
94765: PUSH
94766: LD_INT 27
94768: PUSH
94769: LD_INT 28
94771: PUSH
94772: LD_INT 29
94774: PUSH
94775: LD_INT 30
94777: PUSH
94778: LD_INT 31
94780: PUSH
94781: LD_INT 32
94783: PUSH
94784: LD_INT 33
94786: PUSH
94787: LD_INT 34
94789: PUSH
94790: LD_INT 36
94792: PUSH
94793: EMPTY
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: PUSH
94830: LD_INT 101
94832: PUSH
94833: LD_INT 102
94835: PUSH
94836: LD_INT 103
94838: PUSH
94839: LD_INT 104
94841: PUSH
94842: LD_INT 105
94844: PUSH
94845: LD_INT 106
94847: PUSH
94848: LD_INT 107
94850: PUSH
94851: LD_INT 108
94853: PUSH
94854: LD_INT 109
94856: PUSH
94857: LD_INT 110
94859: PUSH
94860: LD_INT 111
94862: PUSH
94863: LD_INT 112
94865: PUSH
94866: LD_INT 113
94868: PUSH
94869: LD_INT 114
94871: PUSH
94872: LD_INT 116
94874: PUSH
94875: LD_INT 117
94877: PUSH
94878: LD_INT 118
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: LIST
94895: LIST
94896: LIST
94897: LIST
94898: LIST
94899: PUSH
94900: EMPTY
94901: LIST
94902: LIST
94903: ST_TO_ADDR
94904: GO 95911
94906: LD_INT 15
94908: DOUBLE
94909: EQUAL
94910: IFTRUE 94914
94912: GO 95138
94914: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94915: LD_ADDR_VAR 0 2
94919: PUSH
94920: LD_INT 1
94922: PUSH
94923: LD_INT 2
94925: PUSH
94926: LD_INT 3
94928: PUSH
94929: LD_INT 4
94931: PUSH
94932: LD_INT 5
94934: PUSH
94935: LD_INT 6
94937: PUSH
94938: LD_INT 7
94940: PUSH
94941: LD_INT 8
94943: PUSH
94944: LD_INT 9
94946: PUSH
94947: LD_INT 10
94949: PUSH
94950: LD_INT 11
94952: PUSH
94953: LD_INT 12
94955: PUSH
94956: LD_INT 13
94958: PUSH
94959: LD_INT 14
94961: PUSH
94962: LD_INT 15
94964: PUSH
94965: LD_INT 16
94967: PUSH
94968: LD_INT 17
94970: PUSH
94971: LD_INT 18
94973: PUSH
94974: LD_INT 19
94976: PUSH
94977: LD_INT 20
94979: PUSH
94980: LD_INT 21
94982: PUSH
94983: LD_INT 22
94985: PUSH
94986: LD_INT 23
94988: PUSH
94989: LD_INT 24
94991: PUSH
94992: LD_INT 25
94994: PUSH
94995: LD_INT 26
94997: PUSH
94998: LD_INT 27
95000: PUSH
95001: LD_INT 28
95003: PUSH
95004: LD_INT 29
95006: PUSH
95007: LD_INT 30
95009: PUSH
95010: LD_INT 31
95012: PUSH
95013: LD_INT 32
95015: PUSH
95016: LD_INT 33
95018: PUSH
95019: LD_INT 34
95021: PUSH
95022: LD_INT 36
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: LIST
95053: LIST
95054: LIST
95055: LIST
95056: LIST
95057: LIST
95058: LIST
95059: LIST
95060: LIST
95061: PUSH
95062: LD_INT 101
95064: PUSH
95065: LD_INT 102
95067: PUSH
95068: LD_INT 103
95070: PUSH
95071: LD_INT 104
95073: PUSH
95074: LD_INT 105
95076: PUSH
95077: LD_INT 106
95079: PUSH
95080: LD_INT 107
95082: PUSH
95083: LD_INT 108
95085: PUSH
95086: LD_INT 109
95088: PUSH
95089: LD_INT 110
95091: PUSH
95092: LD_INT 111
95094: PUSH
95095: LD_INT 112
95097: PUSH
95098: LD_INT 113
95100: PUSH
95101: LD_INT 114
95103: PUSH
95104: LD_INT 116
95106: PUSH
95107: LD_INT 117
95109: PUSH
95110: LD_INT 118
95112: PUSH
95113: EMPTY
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: LIST
95127: LIST
95128: LIST
95129: LIST
95130: LIST
95131: PUSH
95132: EMPTY
95133: LIST
95134: LIST
95135: ST_TO_ADDR
95136: GO 95911
95138: LD_INT 16
95140: DOUBLE
95141: EQUAL
95142: IFTRUE 95146
95144: GO 95282
95146: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
95147: LD_ADDR_VAR 0 2
95151: PUSH
95152: LD_INT 2
95154: PUSH
95155: LD_INT 4
95157: PUSH
95158: LD_INT 5
95160: PUSH
95161: LD_INT 7
95163: PUSH
95164: LD_INT 11
95166: PUSH
95167: LD_INT 12
95169: PUSH
95170: LD_INT 15
95172: PUSH
95173: LD_INT 16
95175: PUSH
95176: LD_INT 20
95178: PUSH
95179: LD_INT 21
95181: PUSH
95182: LD_INT 22
95184: PUSH
95185: LD_INT 23
95187: PUSH
95188: LD_INT 25
95190: PUSH
95191: LD_INT 26
95193: PUSH
95194: LD_INT 30
95196: PUSH
95197: LD_INT 31
95199: PUSH
95200: LD_INT 32
95202: PUSH
95203: LD_INT 33
95205: PUSH
95206: LD_INT 34
95208: PUSH
95209: EMPTY
95210: LIST
95211: LIST
95212: LIST
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: PUSH
95230: LD_INT 101
95232: PUSH
95233: LD_INT 102
95235: PUSH
95236: LD_INT 103
95238: PUSH
95239: LD_INT 106
95241: PUSH
95242: LD_INT 108
95244: PUSH
95245: LD_INT 112
95247: PUSH
95248: LD_INT 113
95250: PUSH
95251: LD_INT 114
95253: PUSH
95254: LD_INT 116
95256: PUSH
95257: LD_INT 117
95259: PUSH
95260: LD_INT 118
95262: PUSH
95263: EMPTY
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: LIST
95270: LIST
95271: LIST
95272: LIST
95273: LIST
95274: LIST
95275: PUSH
95276: EMPTY
95277: LIST
95278: LIST
95279: ST_TO_ADDR
95280: GO 95911
95282: LD_INT 17
95284: DOUBLE
95285: EQUAL
95286: IFTRUE 95290
95288: GO 95514
95290: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95291: LD_ADDR_VAR 0 2
95295: PUSH
95296: LD_INT 1
95298: PUSH
95299: LD_INT 2
95301: PUSH
95302: LD_INT 3
95304: PUSH
95305: LD_INT 4
95307: PUSH
95308: LD_INT 5
95310: PUSH
95311: LD_INT 6
95313: PUSH
95314: LD_INT 7
95316: PUSH
95317: LD_INT 8
95319: PUSH
95320: LD_INT 9
95322: PUSH
95323: LD_INT 10
95325: PUSH
95326: LD_INT 11
95328: PUSH
95329: LD_INT 12
95331: PUSH
95332: LD_INT 13
95334: PUSH
95335: LD_INT 14
95337: PUSH
95338: LD_INT 15
95340: PUSH
95341: LD_INT 16
95343: PUSH
95344: LD_INT 17
95346: PUSH
95347: LD_INT 18
95349: PUSH
95350: LD_INT 19
95352: PUSH
95353: LD_INT 20
95355: PUSH
95356: LD_INT 21
95358: PUSH
95359: LD_INT 22
95361: PUSH
95362: LD_INT 23
95364: PUSH
95365: LD_INT 24
95367: PUSH
95368: LD_INT 25
95370: PUSH
95371: LD_INT 26
95373: PUSH
95374: LD_INT 27
95376: PUSH
95377: LD_INT 28
95379: PUSH
95380: LD_INT 29
95382: PUSH
95383: LD_INT 30
95385: PUSH
95386: LD_INT 31
95388: PUSH
95389: LD_INT 32
95391: PUSH
95392: LD_INT 33
95394: PUSH
95395: LD_INT 34
95397: PUSH
95398: LD_INT 36
95400: PUSH
95401: EMPTY
95402: LIST
95403: LIST
95404: LIST
95405: LIST
95406: LIST
95407: LIST
95408: LIST
95409: LIST
95410: LIST
95411: LIST
95412: LIST
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: LIST
95426: LIST
95427: LIST
95428: LIST
95429: LIST
95430: LIST
95431: LIST
95432: LIST
95433: LIST
95434: LIST
95435: LIST
95436: LIST
95437: PUSH
95438: LD_INT 101
95440: PUSH
95441: LD_INT 102
95443: PUSH
95444: LD_INT 103
95446: PUSH
95447: LD_INT 104
95449: PUSH
95450: LD_INT 105
95452: PUSH
95453: LD_INT 106
95455: PUSH
95456: LD_INT 107
95458: PUSH
95459: LD_INT 108
95461: PUSH
95462: LD_INT 109
95464: PUSH
95465: LD_INT 110
95467: PUSH
95468: LD_INT 111
95470: PUSH
95471: LD_INT 112
95473: PUSH
95474: LD_INT 113
95476: PUSH
95477: LD_INT 114
95479: PUSH
95480: LD_INT 116
95482: PUSH
95483: LD_INT 117
95485: PUSH
95486: LD_INT 118
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: LIST
95493: LIST
95494: LIST
95495: LIST
95496: LIST
95497: LIST
95498: LIST
95499: LIST
95500: LIST
95501: LIST
95502: LIST
95503: LIST
95504: LIST
95505: LIST
95506: LIST
95507: PUSH
95508: EMPTY
95509: LIST
95510: LIST
95511: ST_TO_ADDR
95512: GO 95911
95514: LD_INT 18
95516: DOUBLE
95517: EQUAL
95518: IFTRUE 95522
95520: GO 95670
95522: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95523: LD_ADDR_VAR 0 2
95527: PUSH
95528: LD_INT 2
95530: PUSH
95531: LD_INT 4
95533: PUSH
95534: LD_INT 5
95536: PUSH
95537: LD_INT 7
95539: PUSH
95540: LD_INT 11
95542: PUSH
95543: LD_INT 12
95545: PUSH
95546: LD_INT 15
95548: PUSH
95549: LD_INT 16
95551: PUSH
95552: LD_INT 20
95554: PUSH
95555: LD_INT 21
95557: PUSH
95558: LD_INT 22
95560: PUSH
95561: LD_INT 23
95563: PUSH
95564: LD_INT 25
95566: PUSH
95567: LD_INT 26
95569: PUSH
95570: LD_INT 30
95572: PUSH
95573: LD_INT 31
95575: PUSH
95576: LD_INT 32
95578: PUSH
95579: LD_INT 33
95581: PUSH
95582: LD_INT 34
95584: PUSH
95585: LD_INT 35
95587: PUSH
95588: LD_INT 36
95590: PUSH
95591: EMPTY
95592: LIST
95593: LIST
95594: LIST
95595: LIST
95596: LIST
95597: LIST
95598: LIST
95599: LIST
95600: LIST
95601: LIST
95602: LIST
95603: LIST
95604: LIST
95605: LIST
95606: LIST
95607: LIST
95608: LIST
95609: LIST
95610: LIST
95611: LIST
95612: LIST
95613: PUSH
95614: LD_INT 101
95616: PUSH
95617: LD_INT 102
95619: PUSH
95620: LD_INT 103
95622: PUSH
95623: LD_INT 106
95625: PUSH
95626: LD_INT 108
95628: PUSH
95629: LD_INT 112
95631: PUSH
95632: LD_INT 113
95634: PUSH
95635: LD_INT 114
95637: PUSH
95638: LD_INT 115
95640: PUSH
95641: LD_INT 116
95643: PUSH
95644: LD_INT 117
95646: PUSH
95647: LD_INT 118
95649: PUSH
95650: EMPTY
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: PUSH
95664: EMPTY
95665: LIST
95666: LIST
95667: ST_TO_ADDR
95668: GO 95911
95670: LD_INT 19
95672: DOUBLE
95673: EQUAL
95674: IFTRUE 95678
95676: GO 95910
95678: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95679: LD_ADDR_VAR 0 2
95683: PUSH
95684: LD_INT 1
95686: PUSH
95687: LD_INT 2
95689: PUSH
95690: LD_INT 3
95692: PUSH
95693: LD_INT 4
95695: PUSH
95696: LD_INT 5
95698: PUSH
95699: LD_INT 6
95701: PUSH
95702: LD_INT 7
95704: PUSH
95705: LD_INT 8
95707: PUSH
95708: LD_INT 9
95710: PUSH
95711: LD_INT 10
95713: PUSH
95714: LD_INT 11
95716: PUSH
95717: LD_INT 12
95719: PUSH
95720: LD_INT 13
95722: PUSH
95723: LD_INT 14
95725: PUSH
95726: LD_INT 15
95728: PUSH
95729: LD_INT 16
95731: PUSH
95732: LD_INT 17
95734: PUSH
95735: LD_INT 18
95737: PUSH
95738: LD_INT 19
95740: PUSH
95741: LD_INT 20
95743: PUSH
95744: LD_INT 21
95746: PUSH
95747: LD_INT 22
95749: PUSH
95750: LD_INT 23
95752: PUSH
95753: LD_INT 24
95755: PUSH
95756: LD_INT 25
95758: PUSH
95759: LD_INT 26
95761: PUSH
95762: LD_INT 27
95764: PUSH
95765: LD_INT 28
95767: PUSH
95768: LD_INT 29
95770: PUSH
95771: LD_INT 30
95773: PUSH
95774: LD_INT 31
95776: PUSH
95777: LD_INT 32
95779: PUSH
95780: LD_INT 33
95782: PUSH
95783: LD_INT 34
95785: PUSH
95786: LD_INT 35
95788: PUSH
95789: LD_INT 36
95791: PUSH
95792: EMPTY
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: LIST
95826: LIST
95827: LIST
95828: LIST
95829: PUSH
95830: LD_INT 101
95832: PUSH
95833: LD_INT 102
95835: PUSH
95836: LD_INT 103
95838: PUSH
95839: LD_INT 104
95841: PUSH
95842: LD_INT 105
95844: PUSH
95845: LD_INT 106
95847: PUSH
95848: LD_INT 107
95850: PUSH
95851: LD_INT 108
95853: PUSH
95854: LD_INT 109
95856: PUSH
95857: LD_INT 110
95859: PUSH
95860: LD_INT 111
95862: PUSH
95863: LD_INT 112
95865: PUSH
95866: LD_INT 113
95868: PUSH
95869: LD_INT 114
95871: PUSH
95872: LD_INT 115
95874: PUSH
95875: LD_INT 116
95877: PUSH
95878: LD_INT 117
95880: PUSH
95881: LD_INT 118
95883: PUSH
95884: EMPTY
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: PUSH
95904: EMPTY
95905: LIST
95906: LIST
95907: ST_TO_ADDR
95908: GO 95911
95910: POP
// end else
95911: GO 96142
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95913: LD_ADDR_VAR 0 2
95917: PUSH
95918: LD_INT 1
95920: PUSH
95921: LD_INT 2
95923: PUSH
95924: LD_INT 3
95926: PUSH
95927: LD_INT 4
95929: PUSH
95930: LD_INT 5
95932: PUSH
95933: LD_INT 6
95935: PUSH
95936: LD_INT 7
95938: PUSH
95939: LD_INT 8
95941: PUSH
95942: LD_INT 9
95944: PUSH
95945: LD_INT 10
95947: PUSH
95948: LD_INT 11
95950: PUSH
95951: LD_INT 12
95953: PUSH
95954: LD_INT 13
95956: PUSH
95957: LD_INT 14
95959: PUSH
95960: LD_INT 15
95962: PUSH
95963: LD_INT 16
95965: PUSH
95966: LD_INT 17
95968: PUSH
95969: LD_INT 18
95971: PUSH
95972: LD_INT 19
95974: PUSH
95975: LD_INT 20
95977: PUSH
95978: LD_INT 21
95980: PUSH
95981: LD_INT 22
95983: PUSH
95984: LD_INT 23
95986: PUSH
95987: LD_INT 24
95989: PUSH
95990: LD_INT 25
95992: PUSH
95993: LD_INT 26
95995: PUSH
95996: LD_INT 27
95998: PUSH
95999: LD_INT 28
96001: PUSH
96002: LD_INT 29
96004: PUSH
96005: LD_INT 30
96007: PUSH
96008: LD_INT 31
96010: PUSH
96011: LD_INT 32
96013: PUSH
96014: LD_INT 33
96016: PUSH
96017: LD_INT 34
96019: PUSH
96020: LD_INT 35
96022: PUSH
96023: LD_INT 36
96025: PUSH
96026: EMPTY
96027: LIST
96028: LIST
96029: LIST
96030: LIST
96031: LIST
96032: LIST
96033: LIST
96034: LIST
96035: LIST
96036: LIST
96037: LIST
96038: LIST
96039: LIST
96040: LIST
96041: LIST
96042: LIST
96043: LIST
96044: LIST
96045: LIST
96046: LIST
96047: LIST
96048: LIST
96049: LIST
96050: LIST
96051: LIST
96052: LIST
96053: LIST
96054: LIST
96055: LIST
96056: LIST
96057: LIST
96058: LIST
96059: LIST
96060: LIST
96061: LIST
96062: LIST
96063: PUSH
96064: LD_INT 101
96066: PUSH
96067: LD_INT 102
96069: PUSH
96070: LD_INT 103
96072: PUSH
96073: LD_INT 104
96075: PUSH
96076: LD_INT 105
96078: PUSH
96079: LD_INT 106
96081: PUSH
96082: LD_INT 107
96084: PUSH
96085: LD_INT 108
96087: PUSH
96088: LD_INT 109
96090: PUSH
96091: LD_INT 110
96093: PUSH
96094: LD_INT 111
96096: PUSH
96097: LD_INT 112
96099: PUSH
96100: LD_INT 113
96102: PUSH
96103: LD_INT 114
96105: PUSH
96106: LD_INT 115
96108: PUSH
96109: LD_INT 116
96111: PUSH
96112: LD_INT 117
96114: PUSH
96115: LD_INT 118
96117: PUSH
96118: EMPTY
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: PUSH
96138: EMPTY
96139: LIST
96140: LIST
96141: ST_TO_ADDR
// if result then
96142: LD_VAR 0 2
96146: IFFALSE 96932
// begin normal :=  ;
96148: LD_ADDR_VAR 0 5
96152: PUSH
96153: LD_STRING 
96155: ST_TO_ADDR
// hardcore :=  ;
96156: LD_ADDR_VAR 0 6
96160: PUSH
96161: LD_STRING 
96163: ST_TO_ADDR
// active :=  ;
96164: LD_ADDR_VAR 0 7
96168: PUSH
96169: LD_STRING 
96171: ST_TO_ADDR
// for i = 1 to normalCounter do
96172: LD_ADDR_VAR 0 8
96176: PUSH
96177: DOUBLE
96178: LD_INT 1
96180: DEC
96181: ST_TO_ADDR
96182: LD_EXP 110
96186: PUSH
96187: FOR_TO
96188: IFFALSE 96289
// begin tmp := 0 ;
96190: LD_ADDR_VAR 0 3
96194: PUSH
96195: LD_STRING 0
96197: ST_TO_ADDR
// if result [ 1 ] then
96198: LD_VAR 0 2
96202: PUSH
96203: LD_INT 1
96205: ARRAY
96206: IFFALSE 96271
// if result [ 1 ] [ 1 ] = i then
96208: LD_VAR 0 2
96212: PUSH
96213: LD_INT 1
96215: ARRAY
96216: PUSH
96217: LD_INT 1
96219: ARRAY
96220: PUSH
96221: LD_VAR 0 8
96225: EQUAL
96226: IFFALSE 96271
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
96228: LD_ADDR_VAR 0 2
96232: PUSH
96233: LD_VAR 0 2
96237: PPUSH
96238: LD_INT 1
96240: PPUSH
96241: LD_VAR 0 2
96245: PUSH
96246: LD_INT 1
96248: ARRAY
96249: PPUSH
96250: LD_INT 1
96252: PPUSH
96253: CALL_OW 3
96257: PPUSH
96258: CALL_OW 1
96262: ST_TO_ADDR
// tmp := 1 ;
96263: LD_ADDR_VAR 0 3
96267: PUSH
96268: LD_STRING 1
96270: ST_TO_ADDR
// end ; normal := normal & tmp ;
96271: LD_ADDR_VAR 0 5
96275: PUSH
96276: LD_VAR 0 5
96280: PUSH
96281: LD_VAR 0 3
96285: STR
96286: ST_TO_ADDR
// end ;
96287: GO 96187
96289: POP
96290: POP
// for i = 1 to hardcoreCounter do
96291: LD_ADDR_VAR 0 8
96295: PUSH
96296: DOUBLE
96297: LD_INT 1
96299: DEC
96300: ST_TO_ADDR
96301: LD_EXP 111
96305: PUSH
96306: FOR_TO
96307: IFFALSE 96412
// begin tmp := 0 ;
96309: LD_ADDR_VAR 0 3
96313: PUSH
96314: LD_STRING 0
96316: ST_TO_ADDR
// if result [ 2 ] then
96317: LD_VAR 0 2
96321: PUSH
96322: LD_INT 2
96324: ARRAY
96325: IFFALSE 96394
// if result [ 2 ] [ 1 ] = 100 + i then
96327: LD_VAR 0 2
96331: PUSH
96332: LD_INT 2
96334: ARRAY
96335: PUSH
96336: LD_INT 1
96338: ARRAY
96339: PUSH
96340: LD_INT 100
96342: PUSH
96343: LD_VAR 0 8
96347: PLUS
96348: EQUAL
96349: IFFALSE 96394
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96351: LD_ADDR_VAR 0 2
96355: PUSH
96356: LD_VAR 0 2
96360: PPUSH
96361: LD_INT 2
96363: PPUSH
96364: LD_VAR 0 2
96368: PUSH
96369: LD_INT 2
96371: ARRAY
96372: PPUSH
96373: LD_INT 1
96375: PPUSH
96376: CALL_OW 3
96380: PPUSH
96381: CALL_OW 1
96385: ST_TO_ADDR
// tmp := 1 ;
96386: LD_ADDR_VAR 0 3
96390: PUSH
96391: LD_STRING 1
96393: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96394: LD_ADDR_VAR 0 6
96398: PUSH
96399: LD_VAR 0 6
96403: PUSH
96404: LD_VAR 0 3
96408: STR
96409: ST_TO_ADDR
// end ;
96410: GO 96306
96412: POP
96413: POP
// if isGameLoad then
96414: LD_VAR 0 1
96418: IFFALSE 96893
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96420: LD_ADDR_VAR 0 4
96424: PUSH
96425: LD_EXP 114
96429: PUSH
96430: LD_EXP 113
96434: PUSH
96435: LD_EXP 115
96439: PUSH
96440: LD_EXP 112
96444: PUSH
96445: LD_EXP 116
96449: PUSH
96450: LD_EXP 117
96454: PUSH
96455: LD_EXP 118
96459: PUSH
96460: LD_EXP 119
96464: PUSH
96465: LD_EXP 120
96469: PUSH
96470: LD_EXP 121
96474: PUSH
96475: LD_EXP 122
96479: PUSH
96480: LD_EXP 123
96484: PUSH
96485: LD_EXP 124
96489: PUSH
96490: LD_EXP 125
96494: PUSH
96495: LD_EXP 133
96499: PUSH
96500: LD_EXP 134
96504: PUSH
96505: LD_EXP 135
96509: PUSH
96510: LD_EXP 136
96514: PUSH
96515: LD_EXP 138
96519: PUSH
96520: LD_EXP 139
96524: PUSH
96525: LD_EXP 140
96529: PUSH
96530: LD_EXP 143
96534: PUSH
96535: LD_EXP 145
96539: PUSH
96540: LD_EXP 146
96544: PUSH
96545: LD_EXP 147
96549: PUSH
96550: LD_EXP 149
96554: PUSH
96555: LD_EXP 150
96559: PUSH
96560: LD_EXP 153
96564: PUSH
96565: LD_EXP 154
96569: PUSH
96570: LD_EXP 155
96574: PUSH
96575: LD_EXP 156
96579: PUSH
96580: LD_EXP 157
96584: PUSH
96585: LD_EXP 158
96589: PUSH
96590: LD_EXP 159
96594: PUSH
96595: LD_EXP 160
96599: PUSH
96600: LD_EXP 161
96604: PUSH
96605: LD_EXP 126
96609: PUSH
96610: LD_EXP 127
96614: PUSH
96615: LD_EXP 130
96619: PUSH
96620: LD_EXP 131
96624: PUSH
96625: LD_EXP 132
96629: PUSH
96630: LD_EXP 128
96634: PUSH
96635: LD_EXP 129
96639: PUSH
96640: LD_EXP 137
96644: PUSH
96645: LD_EXP 141
96649: PUSH
96650: LD_EXP 142
96654: PUSH
96655: LD_EXP 144
96659: PUSH
96660: LD_EXP 148
96664: PUSH
96665: LD_EXP 151
96669: PUSH
96670: LD_EXP 152
96674: PUSH
96675: LD_EXP 162
96679: PUSH
96680: LD_EXP 163
96684: PUSH
96685: LD_EXP 164
96689: PUSH
96690: LD_EXP 165
96694: PUSH
96695: EMPTY
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: LIST
96701: LIST
96702: LIST
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: LIST
96708: LIST
96709: LIST
96710: LIST
96711: LIST
96712: LIST
96713: LIST
96714: LIST
96715: LIST
96716: LIST
96717: LIST
96718: LIST
96719: LIST
96720: LIST
96721: LIST
96722: LIST
96723: LIST
96724: LIST
96725: LIST
96726: LIST
96727: LIST
96728: LIST
96729: LIST
96730: LIST
96731: LIST
96732: LIST
96733: LIST
96734: LIST
96735: LIST
96736: LIST
96737: LIST
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: ST_TO_ADDR
// tmp :=  ;
96751: LD_ADDR_VAR 0 3
96755: PUSH
96756: LD_STRING 
96758: ST_TO_ADDR
// for i = 1 to normalCounter do
96759: LD_ADDR_VAR 0 8
96763: PUSH
96764: DOUBLE
96765: LD_INT 1
96767: DEC
96768: ST_TO_ADDR
96769: LD_EXP 110
96773: PUSH
96774: FOR_TO
96775: IFFALSE 96811
// begin if flags [ i ] then
96777: LD_VAR 0 4
96781: PUSH
96782: LD_VAR 0 8
96786: ARRAY
96787: IFFALSE 96809
// tmp := tmp & i & ; ;
96789: LD_ADDR_VAR 0 3
96793: PUSH
96794: LD_VAR 0 3
96798: PUSH
96799: LD_VAR 0 8
96803: STR
96804: PUSH
96805: LD_STRING ;
96807: STR
96808: ST_TO_ADDR
// end ;
96809: GO 96774
96811: POP
96812: POP
// for i = 1 to hardcoreCounter do
96813: LD_ADDR_VAR 0 8
96817: PUSH
96818: DOUBLE
96819: LD_INT 1
96821: DEC
96822: ST_TO_ADDR
96823: LD_EXP 111
96827: PUSH
96828: FOR_TO
96829: IFFALSE 96875
// begin if flags [ normalCounter + i ] then
96831: LD_VAR 0 4
96835: PUSH
96836: LD_EXP 110
96840: PUSH
96841: LD_VAR 0 8
96845: PLUS
96846: ARRAY
96847: IFFALSE 96873
// tmp := tmp & ( 100 + i ) & ; ;
96849: LD_ADDR_VAR 0 3
96853: PUSH
96854: LD_VAR 0 3
96858: PUSH
96859: LD_INT 100
96861: PUSH
96862: LD_VAR 0 8
96866: PLUS
96867: STR
96868: PUSH
96869: LD_STRING ;
96871: STR
96872: ST_TO_ADDR
// end ;
96873: GO 96828
96875: POP
96876: POP
// if tmp then
96877: LD_VAR 0 3
96881: IFFALSE 96893
// active := tmp ;
96883: LD_ADDR_VAR 0 7
96887: PUSH
96888: LD_VAR 0 3
96892: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96893: LD_STRING getStreamItemsFromMission("
96895: PUSH
96896: LD_VAR 0 5
96900: STR
96901: PUSH
96902: LD_STRING ","
96904: STR
96905: PUSH
96906: LD_VAR 0 6
96910: STR
96911: PUSH
96912: LD_STRING ","
96914: STR
96915: PUSH
96916: LD_VAR 0 7
96920: STR
96921: PUSH
96922: LD_STRING ")
96924: STR
96925: PPUSH
96926: CALL_OW 559
// end else
96930: GO 96939
// ToLua ( getStreamItemsFromMission("","","") ) ;
96932: LD_STRING getStreamItemsFromMission("","","")
96934: PPUSH
96935: CALL_OW 559
// end ;
96939: LD_VAR 0 2
96943: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96944: LD_EXP 109
96948: PUSH
96949: LD_EXP 114
96953: AND
96954: IFFALSE 97078
96956: GO 96958
96958: DISABLE
96959: LD_INT 0
96961: PPUSH
96962: PPUSH
// begin enable ;
96963: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96964: LD_ADDR_VAR 0 2
96968: PUSH
96969: LD_INT 22
96971: PUSH
96972: LD_OWVAR 2
96976: PUSH
96977: EMPTY
96978: LIST
96979: LIST
96980: PUSH
96981: LD_INT 2
96983: PUSH
96984: LD_INT 34
96986: PUSH
96987: LD_INT 7
96989: PUSH
96990: EMPTY
96991: LIST
96992: LIST
96993: PUSH
96994: LD_INT 34
96996: PUSH
96997: LD_INT 45
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 34
97006: PUSH
97007: LD_INT 28
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: LD_INT 34
97016: PUSH
97017: LD_INT 47
97019: PUSH
97020: EMPTY
97021: LIST
97022: LIST
97023: PUSH
97024: EMPTY
97025: LIST
97026: LIST
97027: LIST
97028: LIST
97029: LIST
97030: PUSH
97031: EMPTY
97032: LIST
97033: LIST
97034: PPUSH
97035: CALL_OW 69
97039: ST_TO_ADDR
// if not tmp then
97040: LD_VAR 0 2
97044: NOT
97045: IFFALSE 97049
// exit ;
97047: GO 97078
// for i in tmp do
97049: LD_ADDR_VAR 0 1
97053: PUSH
97054: LD_VAR 0 2
97058: PUSH
97059: FOR_IN
97060: IFFALSE 97076
// begin SetLives ( i , 0 ) ;
97062: LD_VAR 0 1
97066: PPUSH
97067: LD_INT 0
97069: PPUSH
97070: CALL_OW 234
// end ;
97074: GO 97059
97076: POP
97077: POP
// end ;
97078: PPOPN 2
97080: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
97081: LD_EXP 109
97085: PUSH
97086: LD_EXP 115
97090: AND
97091: IFFALSE 97175
97093: GO 97095
97095: DISABLE
97096: LD_INT 0
97098: PPUSH
97099: PPUSH
// begin enable ;
97100: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
97101: LD_ADDR_VAR 0 2
97105: PUSH
97106: LD_INT 22
97108: PUSH
97109: LD_OWVAR 2
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 32
97120: PUSH
97121: LD_INT 3
97123: PUSH
97124: EMPTY
97125: LIST
97126: LIST
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PPUSH
97132: CALL_OW 69
97136: ST_TO_ADDR
// if not tmp then
97137: LD_VAR 0 2
97141: NOT
97142: IFFALSE 97146
// exit ;
97144: GO 97175
// for i in tmp do
97146: LD_ADDR_VAR 0 1
97150: PUSH
97151: LD_VAR 0 2
97155: PUSH
97156: FOR_IN
97157: IFFALSE 97173
// begin SetLives ( i , 0 ) ;
97159: LD_VAR 0 1
97163: PPUSH
97164: LD_INT 0
97166: PPUSH
97167: CALL_OW 234
// end ;
97171: GO 97156
97173: POP
97174: POP
// end ;
97175: PPOPN 2
97177: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
97178: LD_EXP 109
97182: PUSH
97183: LD_EXP 112
97187: AND
97188: IFFALSE 97281
97190: GO 97192
97192: DISABLE
97193: LD_INT 0
97195: PPUSH
// begin enable ;
97196: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
97197: LD_ADDR_VAR 0 1
97201: PUSH
97202: LD_INT 22
97204: PUSH
97205: LD_OWVAR 2
97209: PUSH
97210: EMPTY
97211: LIST
97212: LIST
97213: PUSH
97214: LD_INT 2
97216: PUSH
97217: LD_INT 25
97219: PUSH
97220: LD_INT 5
97222: PUSH
97223: EMPTY
97224: LIST
97225: LIST
97226: PUSH
97227: LD_INT 25
97229: PUSH
97230: LD_INT 9
97232: PUSH
97233: EMPTY
97234: LIST
97235: LIST
97236: PUSH
97237: LD_INT 25
97239: PUSH
97240: LD_INT 8
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: LIST
97251: LIST
97252: PUSH
97253: EMPTY
97254: LIST
97255: LIST
97256: PPUSH
97257: CALL_OW 69
97261: PUSH
97262: FOR_IN
97263: IFFALSE 97279
// begin SetClass ( i , 1 ) ;
97265: LD_VAR 0 1
97269: PPUSH
97270: LD_INT 1
97272: PPUSH
97273: CALL_OW 336
// end ;
97277: GO 97262
97279: POP
97280: POP
// end ;
97281: PPOPN 1
97283: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97284: LD_EXP 109
97288: PUSH
97289: LD_EXP 113
97293: AND
97294: PUSH
97295: LD_OWVAR 65
97299: PUSH
97300: LD_INT 7
97302: LESS
97303: AND
97304: IFFALSE 97318
97306: GO 97308
97308: DISABLE
// begin enable ;
97309: ENABLE
// game_speed := 7 ;
97310: LD_ADDR_OWVAR 65
97314: PUSH
97315: LD_INT 7
97317: ST_TO_ADDR
// end ;
97318: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97319: LD_EXP 109
97323: PUSH
97324: LD_EXP 116
97328: AND
97329: IFFALSE 97531
97331: GO 97333
97333: DISABLE
97334: LD_INT 0
97336: PPUSH
97337: PPUSH
97338: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97339: LD_ADDR_VAR 0 3
97343: PUSH
97344: LD_INT 81
97346: PUSH
97347: LD_OWVAR 2
97351: PUSH
97352: EMPTY
97353: LIST
97354: LIST
97355: PUSH
97356: LD_INT 21
97358: PUSH
97359: LD_INT 1
97361: PUSH
97362: EMPTY
97363: LIST
97364: LIST
97365: PUSH
97366: EMPTY
97367: LIST
97368: LIST
97369: PPUSH
97370: CALL_OW 69
97374: ST_TO_ADDR
// if not tmp then
97375: LD_VAR 0 3
97379: NOT
97380: IFFALSE 97384
// exit ;
97382: GO 97531
// if tmp > 5 then
97384: LD_VAR 0 3
97388: PUSH
97389: LD_INT 5
97391: GREATER
97392: IFFALSE 97404
// k := 5 else
97394: LD_ADDR_VAR 0 2
97398: PUSH
97399: LD_INT 5
97401: ST_TO_ADDR
97402: GO 97414
// k := tmp ;
97404: LD_ADDR_VAR 0 2
97408: PUSH
97409: LD_VAR 0 3
97413: ST_TO_ADDR
// for i := 1 to k do
97414: LD_ADDR_VAR 0 1
97418: PUSH
97419: DOUBLE
97420: LD_INT 1
97422: DEC
97423: ST_TO_ADDR
97424: LD_VAR 0 2
97428: PUSH
97429: FOR_TO
97430: IFFALSE 97529
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97432: LD_VAR 0 3
97436: PUSH
97437: LD_VAR 0 1
97441: ARRAY
97442: PPUSH
97443: LD_VAR 0 1
97447: PUSH
97448: LD_INT 4
97450: MOD
97451: PUSH
97452: LD_INT 1
97454: PLUS
97455: PPUSH
97456: CALL_OW 259
97460: PUSH
97461: LD_INT 10
97463: LESS
97464: IFFALSE 97527
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97466: LD_VAR 0 3
97470: PUSH
97471: LD_VAR 0 1
97475: ARRAY
97476: PPUSH
97477: LD_VAR 0 1
97481: PUSH
97482: LD_INT 4
97484: MOD
97485: PUSH
97486: LD_INT 1
97488: PLUS
97489: PPUSH
97490: LD_VAR 0 3
97494: PUSH
97495: LD_VAR 0 1
97499: ARRAY
97500: PPUSH
97501: LD_VAR 0 1
97505: PUSH
97506: LD_INT 4
97508: MOD
97509: PUSH
97510: LD_INT 1
97512: PLUS
97513: PPUSH
97514: CALL_OW 259
97518: PUSH
97519: LD_INT 1
97521: PLUS
97522: PPUSH
97523: CALL_OW 237
97527: GO 97429
97529: POP
97530: POP
// end ;
97531: PPOPN 3
97533: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97534: LD_EXP 109
97538: PUSH
97539: LD_EXP 117
97543: AND
97544: IFFALSE 97564
97546: GO 97548
97548: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97549: LD_INT 4
97551: PPUSH
97552: LD_OWVAR 2
97556: PPUSH
97557: LD_INT 0
97559: PPUSH
97560: CALL_OW 324
97564: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97565: LD_EXP 109
97569: PUSH
97570: LD_EXP 146
97574: AND
97575: IFFALSE 97595
97577: GO 97579
97579: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97580: LD_INT 19
97582: PPUSH
97583: LD_OWVAR 2
97587: PPUSH
97588: LD_INT 0
97590: PPUSH
97591: CALL_OW 324
97595: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97596: LD_EXP 109
97600: PUSH
97601: LD_EXP 118
97605: AND
97606: IFFALSE 97708
97608: GO 97610
97610: DISABLE
97611: LD_INT 0
97613: PPUSH
97614: PPUSH
// begin enable ;
97615: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97616: LD_ADDR_VAR 0 2
97620: PUSH
97621: LD_INT 22
97623: PUSH
97624: LD_OWVAR 2
97628: PUSH
97629: EMPTY
97630: LIST
97631: LIST
97632: PUSH
97633: LD_INT 2
97635: PUSH
97636: LD_INT 34
97638: PUSH
97639: LD_INT 11
97641: PUSH
97642: EMPTY
97643: LIST
97644: LIST
97645: PUSH
97646: LD_INT 34
97648: PUSH
97649: LD_INT 30
97651: PUSH
97652: EMPTY
97653: LIST
97654: LIST
97655: PUSH
97656: EMPTY
97657: LIST
97658: LIST
97659: LIST
97660: PUSH
97661: EMPTY
97662: LIST
97663: LIST
97664: PPUSH
97665: CALL_OW 69
97669: ST_TO_ADDR
// if not tmp then
97670: LD_VAR 0 2
97674: NOT
97675: IFFALSE 97679
// exit ;
97677: GO 97708
// for i in tmp do
97679: LD_ADDR_VAR 0 1
97683: PUSH
97684: LD_VAR 0 2
97688: PUSH
97689: FOR_IN
97690: IFFALSE 97706
// begin SetLives ( i , 0 ) ;
97692: LD_VAR 0 1
97696: PPUSH
97697: LD_INT 0
97699: PPUSH
97700: CALL_OW 234
// end ;
97704: GO 97689
97706: POP
97707: POP
// end ;
97708: PPOPN 2
97710: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97711: LD_EXP 109
97715: PUSH
97716: LD_EXP 119
97720: AND
97721: IFFALSE 97741
97723: GO 97725
97725: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97726: LD_INT 32
97728: PPUSH
97729: LD_OWVAR 2
97733: PPUSH
97734: LD_INT 0
97736: PPUSH
97737: CALL_OW 324
97741: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97742: LD_EXP 109
97746: PUSH
97747: LD_EXP 120
97751: AND
97752: IFFALSE 97933
97754: GO 97756
97756: DISABLE
97757: LD_INT 0
97759: PPUSH
97760: PPUSH
97761: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97762: LD_ADDR_VAR 0 2
97766: PUSH
97767: LD_INT 22
97769: PUSH
97770: LD_OWVAR 2
97774: PUSH
97775: EMPTY
97776: LIST
97777: LIST
97778: PUSH
97779: LD_INT 33
97781: PUSH
97782: LD_INT 3
97784: PUSH
97785: EMPTY
97786: LIST
97787: LIST
97788: PUSH
97789: EMPTY
97790: LIST
97791: LIST
97792: PPUSH
97793: CALL_OW 69
97797: ST_TO_ADDR
// if not tmp then
97798: LD_VAR 0 2
97802: NOT
97803: IFFALSE 97807
// exit ;
97805: GO 97933
// side := 0 ;
97807: LD_ADDR_VAR 0 3
97811: PUSH
97812: LD_INT 0
97814: ST_TO_ADDR
// for i := 1 to 8 do
97815: LD_ADDR_VAR 0 1
97819: PUSH
97820: DOUBLE
97821: LD_INT 1
97823: DEC
97824: ST_TO_ADDR
97825: LD_INT 8
97827: PUSH
97828: FOR_TO
97829: IFFALSE 97877
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97831: LD_OWVAR 2
97835: PUSH
97836: LD_VAR 0 1
97840: NONEQUAL
97841: PUSH
97842: LD_OWVAR 2
97846: PPUSH
97847: LD_VAR 0 1
97851: PPUSH
97852: CALL_OW 81
97856: PUSH
97857: LD_INT 2
97859: EQUAL
97860: AND
97861: IFFALSE 97875
// begin side := i ;
97863: LD_ADDR_VAR 0 3
97867: PUSH
97868: LD_VAR 0 1
97872: ST_TO_ADDR
// break ;
97873: GO 97877
// end ;
97875: GO 97828
97877: POP
97878: POP
// if not side then
97879: LD_VAR 0 3
97883: NOT
97884: IFFALSE 97888
// exit ;
97886: GO 97933
// for i := 1 to tmp do
97888: LD_ADDR_VAR 0 1
97892: PUSH
97893: DOUBLE
97894: LD_INT 1
97896: DEC
97897: ST_TO_ADDR
97898: LD_VAR 0 2
97902: PUSH
97903: FOR_TO
97904: IFFALSE 97931
// if Prob ( 60 ) then
97906: LD_INT 60
97908: PPUSH
97909: CALL_OW 13
97913: IFFALSE 97929
// SetSide ( i , side ) ;
97915: LD_VAR 0 1
97919: PPUSH
97920: LD_VAR 0 3
97924: PPUSH
97925: CALL_OW 235
97929: GO 97903
97931: POP
97932: POP
// end ;
97933: PPOPN 3
97935: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97936: LD_EXP 109
97940: PUSH
97941: LD_EXP 122
97945: AND
97946: IFFALSE 98065
97948: GO 97950
97950: DISABLE
97951: LD_INT 0
97953: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97954: LD_ADDR_VAR 0 1
97958: PUSH
97959: LD_INT 22
97961: PUSH
97962: LD_OWVAR 2
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: PUSH
97971: LD_INT 21
97973: PUSH
97974: LD_INT 1
97976: PUSH
97977: EMPTY
97978: LIST
97979: LIST
97980: PUSH
97981: LD_INT 3
97983: PUSH
97984: LD_INT 23
97986: PUSH
97987: LD_INT 0
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: EMPTY
97995: LIST
97996: LIST
97997: PUSH
97998: EMPTY
97999: LIST
98000: LIST
98001: LIST
98002: PPUSH
98003: CALL_OW 69
98007: PUSH
98008: FOR_IN
98009: IFFALSE 98063
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
98011: LD_VAR 0 1
98015: PPUSH
98016: CALL_OW 257
98020: PUSH
98021: LD_INT 1
98023: PUSH
98024: LD_INT 2
98026: PUSH
98027: LD_INT 3
98029: PUSH
98030: LD_INT 4
98032: PUSH
98033: EMPTY
98034: LIST
98035: LIST
98036: LIST
98037: LIST
98038: IN
98039: IFFALSE 98061
// SetClass ( un , rand ( 1 , 4 ) ) ;
98041: LD_VAR 0 1
98045: PPUSH
98046: LD_INT 1
98048: PPUSH
98049: LD_INT 4
98051: PPUSH
98052: CALL_OW 12
98056: PPUSH
98057: CALL_OW 336
98061: GO 98008
98063: POP
98064: POP
// end ;
98065: PPOPN 1
98067: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
98068: LD_EXP 109
98072: PUSH
98073: LD_EXP 121
98077: AND
98078: IFFALSE 98157
98080: GO 98082
98082: DISABLE
98083: LD_INT 0
98085: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98086: LD_ADDR_VAR 0 1
98090: PUSH
98091: LD_INT 22
98093: PUSH
98094: LD_OWVAR 2
98098: PUSH
98099: EMPTY
98100: LIST
98101: LIST
98102: PUSH
98103: LD_INT 21
98105: PUSH
98106: LD_INT 3
98108: PUSH
98109: EMPTY
98110: LIST
98111: LIST
98112: PUSH
98113: EMPTY
98114: LIST
98115: LIST
98116: PPUSH
98117: CALL_OW 69
98121: ST_TO_ADDR
// if not tmp then
98122: LD_VAR 0 1
98126: NOT
98127: IFFALSE 98131
// exit ;
98129: GO 98157
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
98131: LD_VAR 0 1
98135: PUSH
98136: LD_INT 1
98138: PPUSH
98139: LD_VAR 0 1
98143: PPUSH
98144: CALL_OW 12
98148: ARRAY
98149: PPUSH
98150: LD_INT 100
98152: PPUSH
98153: CALL_OW 234
// end ;
98157: PPOPN 1
98159: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
98160: LD_EXP 109
98164: PUSH
98165: LD_EXP 123
98169: AND
98170: IFFALSE 98268
98172: GO 98174
98174: DISABLE
98175: LD_INT 0
98177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
98178: LD_ADDR_VAR 0 1
98182: PUSH
98183: LD_INT 22
98185: PUSH
98186: LD_OWVAR 2
98190: PUSH
98191: EMPTY
98192: LIST
98193: LIST
98194: PUSH
98195: LD_INT 21
98197: PUSH
98198: LD_INT 1
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PUSH
98205: EMPTY
98206: LIST
98207: LIST
98208: PPUSH
98209: CALL_OW 69
98213: ST_TO_ADDR
// if not tmp then
98214: LD_VAR 0 1
98218: NOT
98219: IFFALSE 98223
// exit ;
98221: GO 98268
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
98223: LD_VAR 0 1
98227: PUSH
98228: LD_INT 1
98230: PPUSH
98231: LD_VAR 0 1
98235: PPUSH
98236: CALL_OW 12
98240: ARRAY
98241: PPUSH
98242: LD_INT 1
98244: PPUSH
98245: LD_INT 4
98247: PPUSH
98248: CALL_OW 12
98252: PPUSH
98253: LD_INT 3000
98255: PPUSH
98256: LD_INT 9000
98258: PPUSH
98259: CALL_OW 12
98263: PPUSH
98264: CALL_OW 492
// end ;
98268: PPOPN 1
98270: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98271: LD_EXP 109
98275: PUSH
98276: LD_EXP 124
98280: AND
98281: IFFALSE 98301
98283: GO 98285
98285: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98286: LD_INT 1
98288: PPUSH
98289: LD_OWVAR 2
98293: PPUSH
98294: LD_INT 0
98296: PPUSH
98297: CALL_OW 324
98301: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98302: LD_EXP 109
98306: PUSH
98307: LD_EXP 125
98311: AND
98312: IFFALSE 98395
98314: GO 98316
98316: DISABLE
98317: LD_INT 0
98319: PPUSH
98320: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98321: LD_ADDR_VAR 0 2
98325: PUSH
98326: LD_INT 22
98328: PUSH
98329: LD_OWVAR 2
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: PUSH
98338: LD_INT 21
98340: PUSH
98341: LD_INT 3
98343: PUSH
98344: EMPTY
98345: LIST
98346: LIST
98347: PUSH
98348: EMPTY
98349: LIST
98350: LIST
98351: PPUSH
98352: CALL_OW 69
98356: ST_TO_ADDR
// if not tmp then
98357: LD_VAR 0 2
98361: NOT
98362: IFFALSE 98366
// exit ;
98364: GO 98395
// for i in tmp do
98366: LD_ADDR_VAR 0 1
98370: PUSH
98371: LD_VAR 0 2
98375: PUSH
98376: FOR_IN
98377: IFFALSE 98393
// SetBLevel ( i , 10 ) ;
98379: LD_VAR 0 1
98383: PPUSH
98384: LD_INT 10
98386: PPUSH
98387: CALL_OW 241
98391: GO 98376
98393: POP
98394: POP
// end ;
98395: PPOPN 2
98397: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98398: LD_EXP 109
98402: PUSH
98403: LD_EXP 126
98407: AND
98408: IFFALSE 98519
98410: GO 98412
98412: DISABLE
98413: LD_INT 0
98415: PPUSH
98416: PPUSH
98417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98418: LD_ADDR_VAR 0 3
98422: PUSH
98423: LD_INT 22
98425: PUSH
98426: LD_OWVAR 2
98430: PUSH
98431: EMPTY
98432: LIST
98433: LIST
98434: PUSH
98435: LD_INT 25
98437: PUSH
98438: LD_INT 1
98440: PUSH
98441: EMPTY
98442: LIST
98443: LIST
98444: PUSH
98445: EMPTY
98446: LIST
98447: LIST
98448: PPUSH
98449: CALL_OW 69
98453: ST_TO_ADDR
// if not tmp then
98454: LD_VAR 0 3
98458: NOT
98459: IFFALSE 98463
// exit ;
98461: GO 98519
// un := tmp [ rand ( 1 , tmp ) ] ;
98463: LD_ADDR_VAR 0 2
98467: PUSH
98468: LD_VAR 0 3
98472: PUSH
98473: LD_INT 1
98475: PPUSH
98476: LD_VAR 0 3
98480: PPUSH
98481: CALL_OW 12
98485: ARRAY
98486: ST_TO_ADDR
// if Crawls ( un ) then
98487: LD_VAR 0 2
98491: PPUSH
98492: CALL_OW 318
98496: IFFALSE 98507
// ComWalk ( un ) ;
98498: LD_VAR 0 2
98502: PPUSH
98503: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98507: LD_VAR 0 2
98511: PPUSH
98512: LD_INT 5
98514: PPUSH
98515: CALL_OW 336
// end ;
98519: PPOPN 3
98521: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98522: LD_EXP 109
98526: PUSH
98527: LD_EXP 127
98531: AND
98532: PUSH
98533: LD_OWVAR 67
98537: PUSH
98538: LD_INT 4
98540: LESS
98541: AND
98542: IFFALSE 98561
98544: GO 98546
98546: DISABLE
// begin Difficulty := Difficulty + 1 ;
98547: LD_ADDR_OWVAR 67
98551: PUSH
98552: LD_OWVAR 67
98556: PUSH
98557: LD_INT 1
98559: PLUS
98560: ST_TO_ADDR
// end ;
98561: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98562: LD_EXP 109
98566: PUSH
98567: LD_EXP 128
98571: AND
98572: IFFALSE 98675
98574: GO 98576
98576: DISABLE
98577: LD_INT 0
98579: PPUSH
// begin for i := 1 to 5 do
98580: LD_ADDR_VAR 0 1
98584: PUSH
98585: DOUBLE
98586: LD_INT 1
98588: DEC
98589: ST_TO_ADDR
98590: LD_INT 5
98592: PUSH
98593: FOR_TO
98594: IFFALSE 98673
// begin uc_nation := nation_nature ;
98596: LD_ADDR_OWVAR 21
98600: PUSH
98601: LD_INT 0
98603: ST_TO_ADDR
// uc_side := 0 ;
98604: LD_ADDR_OWVAR 20
98608: PUSH
98609: LD_INT 0
98611: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98612: LD_ADDR_OWVAR 29
98616: PUSH
98617: LD_INT 12
98619: PUSH
98620: LD_INT 12
98622: PUSH
98623: EMPTY
98624: LIST
98625: LIST
98626: ST_TO_ADDR
// hc_agressivity := 20 ;
98627: LD_ADDR_OWVAR 35
98631: PUSH
98632: LD_INT 20
98634: ST_TO_ADDR
// hc_class := class_tiger ;
98635: LD_ADDR_OWVAR 28
98639: PUSH
98640: LD_INT 14
98642: ST_TO_ADDR
// hc_gallery :=  ;
98643: LD_ADDR_OWVAR 33
98647: PUSH
98648: LD_STRING 
98650: ST_TO_ADDR
// hc_name :=  ;
98651: LD_ADDR_OWVAR 26
98655: PUSH
98656: LD_STRING 
98658: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98659: CALL_OW 44
98663: PPUSH
98664: LD_INT 0
98666: PPUSH
98667: CALL_OW 51
// end ;
98671: GO 98593
98673: POP
98674: POP
// end ;
98675: PPOPN 1
98677: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98678: LD_EXP 109
98682: PUSH
98683: LD_EXP 129
98687: AND
98688: IFFALSE 98697
98690: GO 98692
98692: DISABLE
// StreamSibBomb ;
98693: CALL 98698 0 0
98697: END
// export function StreamSibBomb ; var i , x , y ; begin
98698: LD_INT 0
98700: PPUSH
98701: PPUSH
98702: PPUSH
98703: PPUSH
// result := false ;
98704: LD_ADDR_VAR 0 1
98708: PUSH
98709: LD_INT 0
98711: ST_TO_ADDR
// for i := 1 to 16 do
98712: LD_ADDR_VAR 0 2
98716: PUSH
98717: DOUBLE
98718: LD_INT 1
98720: DEC
98721: ST_TO_ADDR
98722: LD_INT 16
98724: PUSH
98725: FOR_TO
98726: IFFALSE 98925
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98728: LD_ADDR_VAR 0 3
98732: PUSH
98733: LD_INT 10
98735: PUSH
98736: LD_INT 20
98738: PUSH
98739: LD_INT 30
98741: PUSH
98742: LD_INT 40
98744: PUSH
98745: LD_INT 50
98747: PUSH
98748: LD_INT 60
98750: PUSH
98751: LD_INT 70
98753: PUSH
98754: LD_INT 80
98756: PUSH
98757: LD_INT 90
98759: PUSH
98760: LD_INT 100
98762: PUSH
98763: LD_INT 110
98765: PUSH
98766: LD_INT 120
98768: PUSH
98769: LD_INT 130
98771: PUSH
98772: LD_INT 140
98774: PUSH
98775: LD_INT 150
98777: PUSH
98778: EMPTY
98779: LIST
98780: LIST
98781: LIST
98782: LIST
98783: LIST
98784: LIST
98785: LIST
98786: LIST
98787: LIST
98788: LIST
98789: LIST
98790: LIST
98791: LIST
98792: LIST
98793: LIST
98794: PUSH
98795: LD_INT 1
98797: PPUSH
98798: LD_INT 15
98800: PPUSH
98801: CALL_OW 12
98805: ARRAY
98806: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98807: LD_ADDR_VAR 0 4
98811: PUSH
98812: LD_INT 10
98814: PUSH
98815: LD_INT 20
98817: PUSH
98818: LD_INT 30
98820: PUSH
98821: LD_INT 40
98823: PUSH
98824: LD_INT 50
98826: PUSH
98827: LD_INT 60
98829: PUSH
98830: LD_INT 70
98832: PUSH
98833: LD_INT 80
98835: PUSH
98836: LD_INT 90
98838: PUSH
98839: LD_INT 100
98841: PUSH
98842: LD_INT 110
98844: PUSH
98845: LD_INT 120
98847: PUSH
98848: LD_INT 130
98850: PUSH
98851: LD_INT 140
98853: PUSH
98854: LD_INT 150
98856: PUSH
98857: EMPTY
98858: LIST
98859: LIST
98860: LIST
98861: LIST
98862: LIST
98863: LIST
98864: LIST
98865: LIST
98866: LIST
98867: LIST
98868: LIST
98869: LIST
98870: LIST
98871: LIST
98872: LIST
98873: PUSH
98874: LD_INT 1
98876: PPUSH
98877: LD_INT 15
98879: PPUSH
98880: CALL_OW 12
98884: ARRAY
98885: ST_TO_ADDR
// if ValidHex ( x , y ) then
98886: LD_VAR 0 3
98890: PPUSH
98891: LD_VAR 0 4
98895: PPUSH
98896: CALL_OW 488
98900: IFFALSE 98923
// begin result := [ x , y ] ;
98902: LD_ADDR_VAR 0 1
98906: PUSH
98907: LD_VAR 0 3
98911: PUSH
98912: LD_VAR 0 4
98916: PUSH
98917: EMPTY
98918: LIST
98919: LIST
98920: ST_TO_ADDR
// break ;
98921: GO 98925
// end ; end ;
98923: GO 98725
98925: POP
98926: POP
// if result then
98927: LD_VAR 0 1
98931: IFFALSE 98991
// begin ToLua ( playSibBomb() ) ;
98933: LD_STRING playSibBomb()
98935: PPUSH
98936: CALL_OW 559
// wait ( 0 0$14 ) ;
98940: LD_INT 490
98942: PPUSH
98943: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98947: LD_VAR 0 1
98951: PUSH
98952: LD_INT 1
98954: ARRAY
98955: PPUSH
98956: LD_VAR 0 1
98960: PUSH
98961: LD_INT 2
98963: ARRAY
98964: PPUSH
98965: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98969: LD_VAR 0 1
98973: PUSH
98974: LD_INT 1
98976: ARRAY
98977: PPUSH
98978: LD_VAR 0 1
98982: PUSH
98983: LD_INT 2
98985: ARRAY
98986: PPUSH
98987: CALL_OW 429
// end ; end ;
98991: LD_VAR 0 1
98995: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98996: LD_EXP 109
99000: PUSH
99001: LD_EXP 131
99005: AND
99006: IFFALSE 99018
99008: GO 99010
99010: DISABLE
// YouLost (  ) ;
99011: LD_STRING 
99013: PPUSH
99014: CALL_OW 104
99018: END
// every 0 0$1 trigger StreamModeActive and sFog do
99019: LD_EXP 109
99023: PUSH
99024: LD_EXP 130
99028: AND
99029: IFFALSE 99043
99031: GO 99033
99033: DISABLE
// FogOff ( your_side ) ;
99034: LD_OWVAR 2
99038: PPUSH
99039: CALL_OW 344
99043: END
// every 0 0$1 trigger StreamModeActive and sSun do
99044: LD_EXP 109
99048: PUSH
99049: LD_EXP 132
99053: AND
99054: IFFALSE 99082
99056: GO 99058
99058: DISABLE
// begin solar_recharge_percent := 0 ;
99059: LD_ADDR_OWVAR 79
99063: PUSH
99064: LD_INT 0
99066: ST_TO_ADDR
// wait ( 5 5$00 ) ;
99067: LD_INT 10500
99069: PPUSH
99070: CALL_OW 67
// solar_recharge_percent := 100 ;
99074: LD_ADDR_OWVAR 79
99078: PUSH
99079: LD_INT 100
99081: ST_TO_ADDR
// end ;
99082: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
99083: LD_EXP 109
99087: PUSH
99088: LD_EXP 133
99092: AND
99093: IFFALSE 99332
99095: GO 99097
99097: DISABLE
99098: LD_INT 0
99100: PPUSH
99101: PPUSH
99102: PPUSH
// begin tmp := [ ] ;
99103: LD_ADDR_VAR 0 3
99107: PUSH
99108: EMPTY
99109: ST_TO_ADDR
// for i := 1 to 6 do
99110: LD_ADDR_VAR 0 1
99114: PUSH
99115: DOUBLE
99116: LD_INT 1
99118: DEC
99119: ST_TO_ADDR
99120: LD_INT 6
99122: PUSH
99123: FOR_TO
99124: IFFALSE 99229
// begin uc_nation := nation_nature ;
99126: LD_ADDR_OWVAR 21
99130: PUSH
99131: LD_INT 0
99133: ST_TO_ADDR
// uc_side := 0 ;
99134: LD_ADDR_OWVAR 20
99138: PUSH
99139: LD_INT 0
99141: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99142: LD_ADDR_OWVAR 29
99146: PUSH
99147: LD_INT 12
99149: PUSH
99150: LD_INT 12
99152: PUSH
99153: EMPTY
99154: LIST
99155: LIST
99156: ST_TO_ADDR
// hc_agressivity := 20 ;
99157: LD_ADDR_OWVAR 35
99161: PUSH
99162: LD_INT 20
99164: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
99165: LD_ADDR_OWVAR 28
99169: PUSH
99170: LD_INT 17
99172: ST_TO_ADDR
// hc_gallery :=  ;
99173: LD_ADDR_OWVAR 33
99177: PUSH
99178: LD_STRING 
99180: ST_TO_ADDR
// hc_name :=  ;
99181: LD_ADDR_OWVAR 26
99185: PUSH
99186: LD_STRING 
99188: ST_TO_ADDR
// un := CreateHuman ;
99189: LD_ADDR_VAR 0 2
99193: PUSH
99194: CALL_OW 44
99198: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
99199: LD_VAR 0 2
99203: PPUSH
99204: LD_INT 1
99206: PPUSH
99207: CALL_OW 51
// tmp := tmp ^ un ;
99211: LD_ADDR_VAR 0 3
99215: PUSH
99216: LD_VAR 0 3
99220: PUSH
99221: LD_VAR 0 2
99225: ADD
99226: ST_TO_ADDR
// end ;
99227: GO 99123
99229: POP
99230: POP
// repeat wait ( 0 0$1 ) ;
99231: LD_INT 35
99233: PPUSH
99234: CALL_OW 67
// for un in tmp do
99238: LD_ADDR_VAR 0 2
99242: PUSH
99243: LD_VAR 0 3
99247: PUSH
99248: FOR_IN
99249: IFFALSE 99323
// begin if IsDead ( un ) then
99251: LD_VAR 0 2
99255: PPUSH
99256: CALL_OW 301
99260: IFFALSE 99280
// begin tmp := tmp diff un ;
99262: LD_ADDR_VAR 0 3
99266: PUSH
99267: LD_VAR 0 3
99271: PUSH
99272: LD_VAR 0 2
99276: DIFF
99277: ST_TO_ADDR
// continue ;
99278: GO 99248
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99280: LD_VAR 0 2
99284: PPUSH
99285: LD_INT 3
99287: PUSH
99288: LD_INT 22
99290: PUSH
99291: LD_INT 0
99293: PUSH
99294: EMPTY
99295: LIST
99296: LIST
99297: PUSH
99298: EMPTY
99299: LIST
99300: LIST
99301: PPUSH
99302: CALL_OW 69
99306: PPUSH
99307: LD_VAR 0 2
99311: PPUSH
99312: CALL_OW 74
99316: PPUSH
99317: CALL_OW 115
// end ;
99321: GO 99248
99323: POP
99324: POP
// until not tmp ;
99325: LD_VAR 0 3
99329: NOT
99330: IFFALSE 99231
// end ;
99332: PPOPN 3
99334: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99335: LD_EXP 109
99339: PUSH
99340: LD_EXP 134
99344: AND
99345: IFFALSE 99399
99347: GO 99349
99349: DISABLE
// begin ToLua ( displayTroll(); ) ;
99350: LD_STRING displayTroll();
99352: PPUSH
99353: CALL_OW 559
// wait ( 3 3$00 ) ;
99357: LD_INT 6300
99359: PPUSH
99360: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99364: LD_STRING hideTroll();
99366: PPUSH
99367: CALL_OW 559
// wait ( 1 1$00 ) ;
99371: LD_INT 2100
99373: PPUSH
99374: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99378: LD_STRING displayTroll();
99380: PPUSH
99381: CALL_OW 559
// wait ( 1 1$00 ) ;
99385: LD_INT 2100
99387: PPUSH
99388: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99392: LD_STRING hideTroll();
99394: PPUSH
99395: CALL_OW 559
// end ;
99399: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99400: LD_EXP 109
99404: PUSH
99405: LD_EXP 135
99409: AND
99410: IFFALSE 99473
99412: GO 99414
99414: DISABLE
99415: LD_INT 0
99417: PPUSH
// begin p := 0 ;
99418: LD_ADDR_VAR 0 1
99422: PUSH
99423: LD_INT 0
99425: ST_TO_ADDR
// repeat game_speed := 1 ;
99426: LD_ADDR_OWVAR 65
99430: PUSH
99431: LD_INT 1
99433: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99434: LD_INT 35
99436: PPUSH
99437: CALL_OW 67
// p := p + 1 ;
99441: LD_ADDR_VAR 0 1
99445: PUSH
99446: LD_VAR 0 1
99450: PUSH
99451: LD_INT 1
99453: PLUS
99454: ST_TO_ADDR
// until p >= 60 ;
99455: LD_VAR 0 1
99459: PUSH
99460: LD_INT 60
99462: GREATEREQUAL
99463: IFFALSE 99426
// game_speed := 4 ;
99465: LD_ADDR_OWVAR 65
99469: PUSH
99470: LD_INT 4
99472: ST_TO_ADDR
// end ;
99473: PPOPN 1
99475: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99476: LD_EXP 109
99480: PUSH
99481: LD_EXP 136
99485: AND
99486: IFFALSE 99632
99488: GO 99490
99490: DISABLE
99491: LD_INT 0
99493: PPUSH
99494: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99495: LD_ADDR_VAR 0 1
99499: PUSH
99500: LD_INT 22
99502: PUSH
99503: LD_OWVAR 2
99507: PUSH
99508: EMPTY
99509: LIST
99510: LIST
99511: PUSH
99512: LD_INT 2
99514: PUSH
99515: LD_INT 30
99517: PUSH
99518: LD_INT 0
99520: PUSH
99521: EMPTY
99522: LIST
99523: LIST
99524: PUSH
99525: LD_INT 30
99527: PUSH
99528: LD_INT 1
99530: PUSH
99531: EMPTY
99532: LIST
99533: LIST
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: LIST
99539: PUSH
99540: EMPTY
99541: LIST
99542: LIST
99543: PPUSH
99544: CALL_OW 69
99548: ST_TO_ADDR
// if not depot then
99549: LD_VAR 0 1
99553: NOT
99554: IFFALSE 99558
// exit ;
99556: GO 99632
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99558: LD_ADDR_VAR 0 2
99562: PUSH
99563: LD_VAR 0 1
99567: PUSH
99568: LD_INT 1
99570: PPUSH
99571: LD_VAR 0 1
99575: PPUSH
99576: CALL_OW 12
99580: ARRAY
99581: PPUSH
99582: CALL_OW 274
99586: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99587: LD_VAR 0 2
99591: PPUSH
99592: LD_INT 1
99594: PPUSH
99595: LD_INT 0
99597: PPUSH
99598: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99602: LD_VAR 0 2
99606: PPUSH
99607: LD_INT 2
99609: PPUSH
99610: LD_INT 0
99612: PPUSH
99613: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99617: LD_VAR 0 2
99621: PPUSH
99622: LD_INT 3
99624: PPUSH
99625: LD_INT 0
99627: PPUSH
99628: CALL_OW 277
// end ;
99632: PPOPN 2
99634: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99635: LD_EXP 109
99639: PUSH
99640: LD_EXP 137
99644: AND
99645: IFFALSE 99742
99647: GO 99649
99649: DISABLE
99650: LD_INT 0
99652: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99653: LD_ADDR_VAR 0 1
99657: PUSH
99658: LD_INT 22
99660: PUSH
99661: LD_OWVAR 2
99665: PUSH
99666: EMPTY
99667: LIST
99668: LIST
99669: PUSH
99670: LD_INT 21
99672: PUSH
99673: LD_INT 1
99675: PUSH
99676: EMPTY
99677: LIST
99678: LIST
99679: PUSH
99680: LD_INT 3
99682: PUSH
99683: LD_INT 23
99685: PUSH
99686: LD_INT 0
99688: PUSH
99689: EMPTY
99690: LIST
99691: LIST
99692: PUSH
99693: EMPTY
99694: LIST
99695: LIST
99696: PUSH
99697: EMPTY
99698: LIST
99699: LIST
99700: LIST
99701: PPUSH
99702: CALL_OW 69
99706: ST_TO_ADDR
// if not tmp then
99707: LD_VAR 0 1
99711: NOT
99712: IFFALSE 99716
// exit ;
99714: GO 99742
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99716: LD_VAR 0 1
99720: PUSH
99721: LD_INT 1
99723: PPUSH
99724: LD_VAR 0 1
99728: PPUSH
99729: CALL_OW 12
99733: ARRAY
99734: PPUSH
99735: LD_INT 200
99737: PPUSH
99738: CALL_OW 234
// end ;
99742: PPOPN 1
99744: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99745: LD_EXP 109
99749: PUSH
99750: LD_EXP 138
99754: AND
99755: IFFALSE 99834
99757: GO 99759
99759: DISABLE
99760: LD_INT 0
99762: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99763: LD_ADDR_VAR 0 1
99767: PUSH
99768: LD_INT 22
99770: PUSH
99771: LD_OWVAR 2
99775: PUSH
99776: EMPTY
99777: LIST
99778: LIST
99779: PUSH
99780: LD_INT 21
99782: PUSH
99783: LD_INT 2
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: PUSH
99790: EMPTY
99791: LIST
99792: LIST
99793: PPUSH
99794: CALL_OW 69
99798: ST_TO_ADDR
// if not tmp then
99799: LD_VAR 0 1
99803: NOT
99804: IFFALSE 99808
// exit ;
99806: GO 99834
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99808: LD_VAR 0 1
99812: PUSH
99813: LD_INT 1
99815: PPUSH
99816: LD_VAR 0 1
99820: PPUSH
99821: CALL_OW 12
99825: ARRAY
99826: PPUSH
99827: LD_INT 60
99829: PPUSH
99830: CALL_OW 234
// end ;
99834: PPOPN 1
99836: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99837: LD_EXP 109
99841: PUSH
99842: LD_EXP 139
99846: AND
99847: IFFALSE 99946
99849: GO 99851
99851: DISABLE
99852: LD_INT 0
99854: PPUSH
99855: PPUSH
// begin enable ;
99856: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99857: LD_ADDR_VAR 0 1
99861: PUSH
99862: LD_INT 22
99864: PUSH
99865: LD_OWVAR 2
99869: PUSH
99870: EMPTY
99871: LIST
99872: LIST
99873: PUSH
99874: LD_INT 61
99876: PUSH
99877: EMPTY
99878: LIST
99879: PUSH
99880: LD_INT 33
99882: PUSH
99883: LD_INT 2
99885: PUSH
99886: EMPTY
99887: LIST
99888: LIST
99889: PUSH
99890: EMPTY
99891: LIST
99892: LIST
99893: LIST
99894: PPUSH
99895: CALL_OW 69
99899: ST_TO_ADDR
// if not tmp then
99900: LD_VAR 0 1
99904: NOT
99905: IFFALSE 99909
// exit ;
99907: GO 99946
// for i in tmp do
99909: LD_ADDR_VAR 0 2
99913: PUSH
99914: LD_VAR 0 1
99918: PUSH
99919: FOR_IN
99920: IFFALSE 99944
// if IsControledBy ( i ) then
99922: LD_VAR 0 2
99926: PPUSH
99927: CALL_OW 312
99931: IFFALSE 99942
// ComUnlink ( i ) ;
99933: LD_VAR 0 2
99937: PPUSH
99938: CALL_OW 136
99942: GO 99919
99944: POP
99945: POP
// end ;
99946: PPOPN 2
99948: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99949: LD_EXP 109
99953: PUSH
99954: LD_EXP 140
99958: AND
99959: IFFALSE 100099
99961: GO 99963
99963: DISABLE
99964: LD_INT 0
99966: PPUSH
99967: PPUSH
// begin ToLua ( displayPowell(); ) ;
99968: LD_STRING displayPowell();
99970: PPUSH
99971: CALL_OW 559
// uc_side := 0 ;
99975: LD_ADDR_OWVAR 20
99979: PUSH
99980: LD_INT 0
99982: ST_TO_ADDR
// uc_nation := 2 ;
99983: LD_ADDR_OWVAR 21
99987: PUSH
99988: LD_INT 2
99990: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99991: LD_ADDR_OWVAR 37
99995: PUSH
99996: LD_INT 14
99998: ST_TO_ADDR
// vc_engine := engine_siberite ;
99999: LD_ADDR_OWVAR 39
100003: PUSH
100004: LD_INT 3
100006: ST_TO_ADDR
// vc_control := control_apeman ;
100007: LD_ADDR_OWVAR 38
100011: PUSH
100012: LD_INT 5
100014: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
100015: LD_ADDR_OWVAR 40
100019: PUSH
100020: LD_INT 29
100022: ST_TO_ADDR
// un := CreateVehicle ;
100023: LD_ADDR_VAR 0 2
100027: PUSH
100028: CALL_OW 45
100032: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100033: LD_VAR 0 2
100037: PPUSH
100038: LD_INT 1
100040: PPUSH
100041: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100045: LD_INT 35
100047: PPUSH
100048: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100052: LD_VAR 0 2
100056: PPUSH
100057: LD_INT 22
100059: PUSH
100060: LD_OWVAR 2
100064: PUSH
100065: EMPTY
100066: LIST
100067: LIST
100068: PPUSH
100069: CALL_OW 69
100073: PPUSH
100074: LD_VAR 0 2
100078: PPUSH
100079: CALL_OW 74
100083: PPUSH
100084: CALL_OW 115
// until IsDead ( un ) ;
100088: LD_VAR 0 2
100092: PPUSH
100093: CALL_OW 301
100097: IFFALSE 100045
// end ;
100099: PPOPN 2
100101: END
// every 0 0$1 trigger StreamModeActive and sStu do
100102: LD_EXP 109
100106: PUSH
100107: LD_EXP 148
100111: AND
100112: IFFALSE 100128
100114: GO 100116
100116: DISABLE
// begin ToLua ( displayStucuk(); ) ;
100117: LD_STRING displayStucuk();
100119: PPUSH
100120: CALL_OW 559
// ResetFog ;
100124: CALL_OW 335
// end ;
100128: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
100129: LD_EXP 109
100133: PUSH
100134: LD_EXP 141
100138: AND
100139: IFFALSE 100280
100141: GO 100143
100143: DISABLE
100144: LD_INT 0
100146: PPUSH
100147: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100148: LD_ADDR_VAR 0 2
100152: PUSH
100153: LD_INT 22
100155: PUSH
100156: LD_OWVAR 2
100160: PUSH
100161: EMPTY
100162: LIST
100163: LIST
100164: PUSH
100165: LD_INT 21
100167: PUSH
100168: LD_INT 1
100170: PUSH
100171: EMPTY
100172: LIST
100173: LIST
100174: PUSH
100175: EMPTY
100176: LIST
100177: LIST
100178: PPUSH
100179: CALL_OW 69
100183: ST_TO_ADDR
// if not tmp then
100184: LD_VAR 0 2
100188: NOT
100189: IFFALSE 100193
// exit ;
100191: GO 100280
// un := tmp [ rand ( 1 , tmp ) ] ;
100193: LD_ADDR_VAR 0 1
100197: PUSH
100198: LD_VAR 0 2
100202: PUSH
100203: LD_INT 1
100205: PPUSH
100206: LD_VAR 0 2
100210: PPUSH
100211: CALL_OW 12
100215: ARRAY
100216: ST_TO_ADDR
// SetSide ( un , 0 ) ;
100217: LD_VAR 0 1
100221: PPUSH
100222: LD_INT 0
100224: PPUSH
100225: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
100229: LD_VAR 0 1
100233: PPUSH
100234: LD_OWVAR 3
100238: PUSH
100239: LD_VAR 0 1
100243: DIFF
100244: PPUSH
100245: LD_VAR 0 1
100249: PPUSH
100250: CALL_OW 74
100254: PPUSH
100255: CALL_OW 115
// wait ( 0 0$20 ) ;
100259: LD_INT 700
100261: PPUSH
100262: CALL_OW 67
// SetSide ( un , your_side ) ;
100266: LD_VAR 0 1
100270: PPUSH
100271: LD_OWVAR 2
100275: PPUSH
100276: CALL_OW 235
// end ;
100280: PPOPN 2
100282: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100283: LD_EXP 109
100287: PUSH
100288: LD_EXP 142
100292: AND
100293: IFFALSE 100399
100295: GO 100297
100297: DISABLE
100298: LD_INT 0
100300: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100301: LD_ADDR_VAR 0 1
100305: PUSH
100306: LD_INT 22
100308: PUSH
100309: LD_OWVAR 2
100313: PUSH
100314: EMPTY
100315: LIST
100316: LIST
100317: PUSH
100318: LD_INT 2
100320: PUSH
100321: LD_INT 30
100323: PUSH
100324: LD_INT 0
100326: PUSH
100327: EMPTY
100328: LIST
100329: LIST
100330: PUSH
100331: LD_INT 30
100333: PUSH
100334: LD_INT 1
100336: PUSH
100337: EMPTY
100338: LIST
100339: LIST
100340: PUSH
100341: EMPTY
100342: LIST
100343: LIST
100344: LIST
100345: PUSH
100346: EMPTY
100347: LIST
100348: LIST
100349: PPUSH
100350: CALL_OW 69
100354: ST_TO_ADDR
// if not depot then
100355: LD_VAR 0 1
100359: NOT
100360: IFFALSE 100364
// exit ;
100362: GO 100399
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100364: LD_VAR 0 1
100368: PUSH
100369: LD_INT 1
100371: ARRAY
100372: PPUSH
100373: CALL_OW 250
100377: PPUSH
100378: LD_VAR 0 1
100382: PUSH
100383: LD_INT 1
100385: ARRAY
100386: PPUSH
100387: CALL_OW 251
100391: PPUSH
100392: LD_INT 70
100394: PPUSH
100395: CALL_OW 495
// end ;
100399: PPOPN 1
100401: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100402: LD_EXP 109
100406: PUSH
100407: LD_EXP 143
100411: AND
100412: IFFALSE 100623
100414: GO 100416
100416: DISABLE
100417: LD_INT 0
100419: PPUSH
100420: PPUSH
100421: PPUSH
100422: PPUSH
100423: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100424: LD_ADDR_VAR 0 5
100428: PUSH
100429: LD_INT 22
100431: PUSH
100432: LD_OWVAR 2
100436: PUSH
100437: EMPTY
100438: LIST
100439: LIST
100440: PUSH
100441: LD_INT 21
100443: PUSH
100444: LD_INT 1
100446: PUSH
100447: EMPTY
100448: LIST
100449: LIST
100450: PUSH
100451: EMPTY
100452: LIST
100453: LIST
100454: PPUSH
100455: CALL_OW 69
100459: ST_TO_ADDR
// if not tmp then
100460: LD_VAR 0 5
100464: NOT
100465: IFFALSE 100469
// exit ;
100467: GO 100623
// for i in tmp do
100469: LD_ADDR_VAR 0 1
100473: PUSH
100474: LD_VAR 0 5
100478: PUSH
100479: FOR_IN
100480: IFFALSE 100621
// begin d := rand ( 0 , 5 ) ;
100482: LD_ADDR_VAR 0 4
100486: PUSH
100487: LD_INT 0
100489: PPUSH
100490: LD_INT 5
100492: PPUSH
100493: CALL_OW 12
100497: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100498: LD_ADDR_VAR 0 2
100502: PUSH
100503: LD_VAR 0 1
100507: PPUSH
100508: CALL_OW 250
100512: PPUSH
100513: LD_VAR 0 4
100517: PPUSH
100518: LD_INT 3
100520: PPUSH
100521: LD_INT 12
100523: PPUSH
100524: CALL_OW 12
100528: PPUSH
100529: CALL_OW 272
100533: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100534: LD_ADDR_VAR 0 3
100538: PUSH
100539: LD_VAR 0 1
100543: PPUSH
100544: CALL_OW 251
100548: PPUSH
100549: LD_VAR 0 4
100553: PPUSH
100554: LD_INT 3
100556: PPUSH
100557: LD_INT 12
100559: PPUSH
100560: CALL_OW 12
100564: PPUSH
100565: CALL_OW 273
100569: ST_TO_ADDR
// if ValidHex ( x , y ) then
100570: LD_VAR 0 2
100574: PPUSH
100575: LD_VAR 0 3
100579: PPUSH
100580: CALL_OW 488
100584: IFFALSE 100619
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100586: LD_VAR 0 1
100590: PPUSH
100591: LD_VAR 0 2
100595: PPUSH
100596: LD_VAR 0 3
100600: PPUSH
100601: LD_INT 3
100603: PPUSH
100604: LD_INT 6
100606: PPUSH
100607: CALL_OW 12
100611: PPUSH
100612: LD_INT 1
100614: PPUSH
100615: CALL_OW 483
// end ;
100619: GO 100479
100621: POP
100622: POP
// end ;
100623: PPOPN 5
100625: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100626: LD_EXP 109
100630: PUSH
100631: LD_EXP 144
100635: AND
100636: IFFALSE 100730
100638: GO 100640
100640: DISABLE
100641: LD_INT 0
100643: PPUSH
100644: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100645: LD_ADDR_VAR 0 2
100649: PUSH
100650: LD_INT 22
100652: PUSH
100653: LD_OWVAR 2
100657: PUSH
100658: EMPTY
100659: LIST
100660: LIST
100661: PUSH
100662: LD_INT 32
100664: PUSH
100665: LD_INT 1
100667: PUSH
100668: EMPTY
100669: LIST
100670: LIST
100671: PUSH
100672: LD_INT 21
100674: PUSH
100675: LD_INT 2
100677: PUSH
100678: EMPTY
100679: LIST
100680: LIST
100681: PUSH
100682: EMPTY
100683: LIST
100684: LIST
100685: LIST
100686: PPUSH
100687: CALL_OW 69
100691: ST_TO_ADDR
// if not tmp then
100692: LD_VAR 0 2
100696: NOT
100697: IFFALSE 100701
// exit ;
100699: GO 100730
// for i in tmp do
100701: LD_ADDR_VAR 0 1
100705: PUSH
100706: LD_VAR 0 2
100710: PUSH
100711: FOR_IN
100712: IFFALSE 100728
// SetFuel ( i , 0 ) ;
100714: LD_VAR 0 1
100718: PPUSH
100719: LD_INT 0
100721: PPUSH
100722: CALL_OW 240
100726: GO 100711
100728: POP
100729: POP
// end ;
100730: PPOPN 2
100732: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100733: LD_EXP 109
100737: PUSH
100738: LD_EXP 145
100742: AND
100743: IFFALSE 100809
100745: GO 100747
100747: DISABLE
100748: LD_INT 0
100750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100751: LD_ADDR_VAR 0 1
100755: PUSH
100756: LD_INT 22
100758: PUSH
100759: LD_OWVAR 2
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: PUSH
100768: LD_INT 30
100770: PUSH
100771: LD_INT 29
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: PUSH
100778: EMPTY
100779: LIST
100780: LIST
100781: PPUSH
100782: CALL_OW 69
100786: ST_TO_ADDR
// if not tmp then
100787: LD_VAR 0 1
100791: NOT
100792: IFFALSE 100796
// exit ;
100794: GO 100809
// DestroyUnit ( tmp [ 1 ] ) ;
100796: LD_VAR 0 1
100800: PUSH
100801: LD_INT 1
100803: ARRAY
100804: PPUSH
100805: CALL_OW 65
// end ;
100809: PPOPN 1
100811: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100812: LD_EXP 109
100816: PUSH
100817: LD_EXP 147
100821: AND
100822: IFFALSE 100951
100824: GO 100826
100826: DISABLE
100827: LD_INT 0
100829: PPUSH
// begin uc_side := 0 ;
100830: LD_ADDR_OWVAR 20
100834: PUSH
100835: LD_INT 0
100837: ST_TO_ADDR
// uc_nation := nation_arabian ;
100838: LD_ADDR_OWVAR 21
100842: PUSH
100843: LD_INT 2
100845: ST_TO_ADDR
// hc_gallery :=  ;
100846: LD_ADDR_OWVAR 33
100850: PUSH
100851: LD_STRING 
100853: ST_TO_ADDR
// hc_name :=  ;
100854: LD_ADDR_OWVAR 26
100858: PUSH
100859: LD_STRING 
100861: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100862: LD_INT 1
100864: PPUSH
100865: LD_INT 11
100867: PPUSH
100868: LD_INT 10
100870: PPUSH
100871: CALL_OW 380
// un := CreateHuman ;
100875: LD_ADDR_VAR 0 1
100879: PUSH
100880: CALL_OW 44
100884: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100885: LD_VAR 0 1
100889: PPUSH
100890: LD_INT 1
100892: PPUSH
100893: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100897: LD_INT 35
100899: PPUSH
100900: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100904: LD_VAR 0 1
100908: PPUSH
100909: LD_INT 22
100911: PUSH
100912: LD_OWVAR 2
100916: PUSH
100917: EMPTY
100918: LIST
100919: LIST
100920: PPUSH
100921: CALL_OW 69
100925: PPUSH
100926: LD_VAR 0 1
100930: PPUSH
100931: CALL_OW 74
100935: PPUSH
100936: CALL_OW 115
// until IsDead ( un ) ;
100940: LD_VAR 0 1
100944: PPUSH
100945: CALL_OW 301
100949: IFFALSE 100897
// end ;
100951: PPOPN 1
100953: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100954: LD_EXP 109
100958: PUSH
100959: LD_EXP 149
100963: AND
100964: IFFALSE 100976
100966: GO 100968
100968: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100969: LD_STRING earthquake(getX(game), 0, 32)
100971: PPUSH
100972: CALL_OW 559
100976: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100977: LD_EXP 109
100981: PUSH
100982: LD_EXP 150
100986: AND
100987: IFFALSE 101078
100989: GO 100991
100991: DISABLE
100992: LD_INT 0
100994: PPUSH
// begin enable ;
100995: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100996: LD_ADDR_VAR 0 1
101000: PUSH
101001: LD_INT 22
101003: PUSH
101004: LD_OWVAR 2
101008: PUSH
101009: EMPTY
101010: LIST
101011: LIST
101012: PUSH
101013: LD_INT 21
101015: PUSH
101016: LD_INT 2
101018: PUSH
101019: EMPTY
101020: LIST
101021: LIST
101022: PUSH
101023: LD_INT 33
101025: PUSH
101026: LD_INT 3
101028: PUSH
101029: EMPTY
101030: LIST
101031: LIST
101032: PUSH
101033: EMPTY
101034: LIST
101035: LIST
101036: LIST
101037: PPUSH
101038: CALL_OW 69
101042: ST_TO_ADDR
// if not tmp then
101043: LD_VAR 0 1
101047: NOT
101048: IFFALSE 101052
// exit ;
101050: GO 101078
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101052: LD_VAR 0 1
101056: PUSH
101057: LD_INT 1
101059: PPUSH
101060: LD_VAR 0 1
101064: PPUSH
101065: CALL_OW 12
101069: ARRAY
101070: PPUSH
101071: LD_INT 1
101073: PPUSH
101074: CALL_OW 234
// end ;
101078: PPOPN 1
101080: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
101081: LD_EXP 109
101085: PUSH
101086: LD_EXP 151
101090: AND
101091: IFFALSE 101232
101093: GO 101095
101095: DISABLE
101096: LD_INT 0
101098: PPUSH
101099: PPUSH
101100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101101: LD_ADDR_VAR 0 3
101105: PUSH
101106: LD_INT 22
101108: PUSH
101109: LD_OWVAR 2
101113: PUSH
101114: EMPTY
101115: LIST
101116: LIST
101117: PUSH
101118: LD_INT 25
101120: PUSH
101121: LD_INT 1
101123: PUSH
101124: EMPTY
101125: LIST
101126: LIST
101127: PUSH
101128: EMPTY
101129: LIST
101130: LIST
101131: PPUSH
101132: CALL_OW 69
101136: ST_TO_ADDR
// if not tmp then
101137: LD_VAR 0 3
101141: NOT
101142: IFFALSE 101146
// exit ;
101144: GO 101232
// un := tmp [ rand ( 1 , tmp ) ] ;
101146: LD_ADDR_VAR 0 2
101150: PUSH
101151: LD_VAR 0 3
101155: PUSH
101156: LD_INT 1
101158: PPUSH
101159: LD_VAR 0 3
101163: PPUSH
101164: CALL_OW 12
101168: ARRAY
101169: ST_TO_ADDR
// if Crawls ( un ) then
101170: LD_VAR 0 2
101174: PPUSH
101175: CALL_OW 318
101179: IFFALSE 101190
// ComWalk ( un ) ;
101181: LD_VAR 0 2
101185: PPUSH
101186: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
101190: LD_VAR 0 2
101194: PPUSH
101195: LD_INT 9
101197: PPUSH
101198: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
101202: LD_INT 28
101204: PPUSH
101205: LD_OWVAR 2
101209: PPUSH
101210: LD_INT 2
101212: PPUSH
101213: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
101217: LD_INT 29
101219: PPUSH
101220: LD_OWVAR 2
101224: PPUSH
101225: LD_INT 2
101227: PPUSH
101228: CALL_OW 322
// end ;
101232: PPOPN 3
101234: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
101235: LD_EXP 109
101239: PUSH
101240: LD_EXP 152
101244: AND
101245: IFFALSE 101356
101247: GO 101249
101249: DISABLE
101250: LD_INT 0
101252: PPUSH
101253: PPUSH
101254: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101255: LD_ADDR_VAR 0 3
101259: PUSH
101260: LD_INT 22
101262: PUSH
101263: LD_OWVAR 2
101267: PUSH
101268: EMPTY
101269: LIST
101270: LIST
101271: PUSH
101272: LD_INT 25
101274: PUSH
101275: LD_INT 1
101277: PUSH
101278: EMPTY
101279: LIST
101280: LIST
101281: PUSH
101282: EMPTY
101283: LIST
101284: LIST
101285: PPUSH
101286: CALL_OW 69
101290: ST_TO_ADDR
// if not tmp then
101291: LD_VAR 0 3
101295: NOT
101296: IFFALSE 101300
// exit ;
101298: GO 101356
// un := tmp [ rand ( 1 , tmp ) ] ;
101300: LD_ADDR_VAR 0 2
101304: PUSH
101305: LD_VAR 0 3
101309: PUSH
101310: LD_INT 1
101312: PPUSH
101313: LD_VAR 0 3
101317: PPUSH
101318: CALL_OW 12
101322: ARRAY
101323: ST_TO_ADDR
// if Crawls ( un ) then
101324: LD_VAR 0 2
101328: PPUSH
101329: CALL_OW 318
101333: IFFALSE 101344
// ComWalk ( un ) ;
101335: LD_VAR 0 2
101339: PPUSH
101340: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101344: LD_VAR 0 2
101348: PPUSH
101349: LD_INT 8
101351: PPUSH
101352: CALL_OW 336
// end ;
101356: PPOPN 3
101358: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101359: LD_EXP 109
101363: PUSH
101364: LD_EXP 153
101368: AND
101369: IFFALSE 101513
101371: GO 101373
101373: DISABLE
101374: LD_INT 0
101376: PPUSH
101377: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101378: LD_ADDR_VAR 0 2
101382: PUSH
101383: LD_INT 22
101385: PUSH
101386: LD_OWVAR 2
101390: PUSH
101391: EMPTY
101392: LIST
101393: LIST
101394: PUSH
101395: LD_INT 21
101397: PUSH
101398: LD_INT 2
101400: PUSH
101401: EMPTY
101402: LIST
101403: LIST
101404: PUSH
101405: LD_INT 2
101407: PUSH
101408: LD_INT 34
101410: PUSH
101411: LD_INT 12
101413: PUSH
101414: EMPTY
101415: LIST
101416: LIST
101417: PUSH
101418: LD_INT 34
101420: PUSH
101421: LD_INT 51
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: LD_INT 34
101430: PUSH
101431: LD_INT 32
101433: PUSH
101434: EMPTY
101435: LIST
101436: LIST
101437: PUSH
101438: EMPTY
101439: LIST
101440: LIST
101441: LIST
101442: LIST
101443: PUSH
101444: EMPTY
101445: LIST
101446: LIST
101447: LIST
101448: PPUSH
101449: CALL_OW 69
101453: ST_TO_ADDR
// if not tmp then
101454: LD_VAR 0 2
101458: NOT
101459: IFFALSE 101463
// exit ;
101461: GO 101513
// for i in tmp do
101463: LD_ADDR_VAR 0 1
101467: PUSH
101468: LD_VAR 0 2
101472: PUSH
101473: FOR_IN
101474: IFFALSE 101511
// if GetCargo ( i , mat_artifact ) = 0 then
101476: LD_VAR 0 1
101480: PPUSH
101481: LD_INT 4
101483: PPUSH
101484: CALL_OW 289
101488: PUSH
101489: LD_INT 0
101491: EQUAL
101492: IFFALSE 101509
// SetCargo ( i , mat_siberit , 100 ) ;
101494: LD_VAR 0 1
101498: PPUSH
101499: LD_INT 3
101501: PPUSH
101502: LD_INT 100
101504: PPUSH
101505: CALL_OW 290
101509: GO 101473
101511: POP
101512: POP
// end ;
101513: PPOPN 2
101515: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101516: LD_EXP 109
101520: PUSH
101521: LD_EXP 154
101525: AND
101526: IFFALSE 101709
101528: GO 101530
101530: DISABLE
101531: LD_INT 0
101533: PPUSH
101534: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101535: LD_ADDR_VAR 0 2
101539: PUSH
101540: LD_INT 22
101542: PUSH
101543: LD_OWVAR 2
101547: PUSH
101548: EMPTY
101549: LIST
101550: LIST
101551: PPUSH
101552: CALL_OW 69
101556: ST_TO_ADDR
// if not tmp then
101557: LD_VAR 0 2
101561: NOT
101562: IFFALSE 101566
// exit ;
101564: GO 101709
// for i := 1 to 2 do
101566: LD_ADDR_VAR 0 1
101570: PUSH
101571: DOUBLE
101572: LD_INT 1
101574: DEC
101575: ST_TO_ADDR
101576: LD_INT 2
101578: PUSH
101579: FOR_TO
101580: IFFALSE 101707
// begin uc_side := your_side ;
101582: LD_ADDR_OWVAR 20
101586: PUSH
101587: LD_OWVAR 2
101591: ST_TO_ADDR
// uc_nation := nation_american ;
101592: LD_ADDR_OWVAR 21
101596: PUSH
101597: LD_INT 1
101599: ST_TO_ADDR
// vc_chassis := us_morphling ;
101600: LD_ADDR_OWVAR 37
101604: PUSH
101605: LD_INT 5
101607: ST_TO_ADDR
// vc_engine := engine_siberite ;
101608: LD_ADDR_OWVAR 39
101612: PUSH
101613: LD_INT 3
101615: ST_TO_ADDR
// vc_control := control_computer ;
101616: LD_ADDR_OWVAR 38
101620: PUSH
101621: LD_INT 3
101623: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101624: LD_ADDR_OWVAR 40
101628: PUSH
101629: LD_INT 10
101631: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101632: LD_VAR 0 2
101636: PUSH
101637: LD_INT 1
101639: ARRAY
101640: PPUSH
101641: CALL_OW 310
101645: NOT
101646: IFFALSE 101693
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101648: CALL_OW 45
101652: PPUSH
101653: LD_VAR 0 2
101657: PUSH
101658: LD_INT 1
101660: ARRAY
101661: PPUSH
101662: CALL_OW 250
101666: PPUSH
101667: LD_VAR 0 2
101671: PUSH
101672: LD_INT 1
101674: ARRAY
101675: PPUSH
101676: CALL_OW 251
101680: PPUSH
101681: LD_INT 12
101683: PPUSH
101684: LD_INT 1
101686: PPUSH
101687: CALL_OW 50
101691: GO 101705
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101693: CALL_OW 45
101697: PPUSH
101698: LD_INT 1
101700: PPUSH
101701: CALL_OW 51
// end ;
101705: GO 101579
101707: POP
101708: POP
// end ;
101709: PPOPN 2
101711: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101712: LD_EXP 109
101716: PUSH
101717: LD_EXP 155
101721: AND
101722: IFFALSE 101944
101724: GO 101726
101726: DISABLE
101727: LD_INT 0
101729: PPUSH
101730: PPUSH
101731: PPUSH
101732: PPUSH
101733: PPUSH
101734: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101735: LD_ADDR_VAR 0 6
101739: PUSH
101740: LD_INT 22
101742: PUSH
101743: LD_OWVAR 2
101747: PUSH
101748: EMPTY
101749: LIST
101750: LIST
101751: PUSH
101752: LD_INT 21
101754: PUSH
101755: LD_INT 1
101757: PUSH
101758: EMPTY
101759: LIST
101760: LIST
101761: PUSH
101762: LD_INT 3
101764: PUSH
101765: LD_INT 23
101767: PUSH
101768: LD_INT 0
101770: PUSH
101771: EMPTY
101772: LIST
101773: LIST
101774: PUSH
101775: EMPTY
101776: LIST
101777: LIST
101778: PUSH
101779: EMPTY
101780: LIST
101781: LIST
101782: LIST
101783: PPUSH
101784: CALL_OW 69
101788: ST_TO_ADDR
// if not tmp then
101789: LD_VAR 0 6
101793: NOT
101794: IFFALSE 101798
// exit ;
101796: GO 101944
// s1 := rand ( 1 , 4 ) ;
101798: LD_ADDR_VAR 0 2
101802: PUSH
101803: LD_INT 1
101805: PPUSH
101806: LD_INT 4
101808: PPUSH
101809: CALL_OW 12
101813: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101814: LD_ADDR_VAR 0 4
101818: PUSH
101819: LD_VAR 0 6
101823: PUSH
101824: LD_INT 1
101826: ARRAY
101827: PPUSH
101828: LD_VAR 0 2
101832: PPUSH
101833: CALL_OW 259
101837: ST_TO_ADDR
// if s1 = 1 then
101838: LD_VAR 0 2
101842: PUSH
101843: LD_INT 1
101845: EQUAL
101846: IFFALSE 101866
// s2 := rand ( 2 , 4 ) else
101848: LD_ADDR_VAR 0 3
101852: PUSH
101853: LD_INT 2
101855: PPUSH
101856: LD_INT 4
101858: PPUSH
101859: CALL_OW 12
101863: ST_TO_ADDR
101864: GO 101874
// s2 := 1 ;
101866: LD_ADDR_VAR 0 3
101870: PUSH
101871: LD_INT 1
101873: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101874: LD_ADDR_VAR 0 5
101878: PUSH
101879: LD_VAR 0 6
101883: PUSH
101884: LD_INT 1
101886: ARRAY
101887: PPUSH
101888: LD_VAR 0 3
101892: PPUSH
101893: CALL_OW 259
101897: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101898: LD_VAR 0 6
101902: PUSH
101903: LD_INT 1
101905: ARRAY
101906: PPUSH
101907: LD_VAR 0 2
101911: PPUSH
101912: LD_VAR 0 5
101916: PPUSH
101917: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101921: LD_VAR 0 6
101925: PUSH
101926: LD_INT 1
101928: ARRAY
101929: PPUSH
101930: LD_VAR 0 3
101934: PPUSH
101935: LD_VAR 0 4
101939: PPUSH
101940: CALL_OW 237
// end ;
101944: PPOPN 6
101946: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101947: LD_EXP 109
101951: PUSH
101952: LD_EXP 156
101956: AND
101957: IFFALSE 102036
101959: GO 101961
101961: DISABLE
101962: LD_INT 0
101964: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101965: LD_ADDR_VAR 0 1
101969: PUSH
101970: LD_INT 22
101972: PUSH
101973: LD_OWVAR 2
101977: PUSH
101978: EMPTY
101979: LIST
101980: LIST
101981: PUSH
101982: LD_INT 30
101984: PUSH
101985: LD_INT 3
101987: PUSH
101988: EMPTY
101989: LIST
101990: LIST
101991: PUSH
101992: EMPTY
101993: LIST
101994: LIST
101995: PPUSH
101996: CALL_OW 69
102000: ST_TO_ADDR
// if not tmp then
102001: LD_VAR 0 1
102005: NOT
102006: IFFALSE 102010
// exit ;
102008: GO 102036
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102010: LD_VAR 0 1
102014: PUSH
102015: LD_INT 1
102017: PPUSH
102018: LD_VAR 0 1
102022: PPUSH
102023: CALL_OW 12
102027: ARRAY
102028: PPUSH
102029: LD_INT 1
102031: PPUSH
102032: CALL_OW 234
// end ;
102036: PPOPN 1
102038: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
102039: LD_EXP 109
102043: PUSH
102044: LD_EXP 157
102048: AND
102049: IFFALSE 102161
102051: GO 102053
102053: DISABLE
102054: LD_INT 0
102056: PPUSH
102057: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
102058: LD_ADDR_VAR 0 2
102062: PUSH
102063: LD_INT 22
102065: PUSH
102066: LD_OWVAR 2
102070: PUSH
102071: EMPTY
102072: LIST
102073: LIST
102074: PUSH
102075: LD_INT 2
102077: PUSH
102078: LD_INT 30
102080: PUSH
102081: LD_INT 27
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: PUSH
102088: LD_INT 30
102090: PUSH
102091: LD_INT 26
102093: PUSH
102094: EMPTY
102095: LIST
102096: LIST
102097: PUSH
102098: LD_INT 30
102100: PUSH
102101: LD_INT 28
102103: PUSH
102104: EMPTY
102105: LIST
102106: LIST
102107: PUSH
102108: EMPTY
102109: LIST
102110: LIST
102111: LIST
102112: LIST
102113: PUSH
102114: EMPTY
102115: LIST
102116: LIST
102117: PPUSH
102118: CALL_OW 69
102122: ST_TO_ADDR
// if not tmp then
102123: LD_VAR 0 2
102127: NOT
102128: IFFALSE 102132
// exit ;
102130: GO 102161
// for i in tmp do
102132: LD_ADDR_VAR 0 1
102136: PUSH
102137: LD_VAR 0 2
102141: PUSH
102142: FOR_IN
102143: IFFALSE 102159
// SetLives ( i , 1 ) ;
102145: LD_VAR 0 1
102149: PPUSH
102150: LD_INT 1
102152: PPUSH
102153: CALL_OW 234
102157: GO 102142
102159: POP
102160: POP
// end ;
102161: PPOPN 2
102163: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
102164: LD_EXP 109
102168: PUSH
102169: LD_EXP 158
102173: AND
102174: IFFALSE 102461
102176: GO 102178
102178: DISABLE
102179: LD_INT 0
102181: PPUSH
102182: PPUSH
102183: PPUSH
// begin i := rand ( 1 , 7 ) ;
102184: LD_ADDR_VAR 0 1
102188: PUSH
102189: LD_INT 1
102191: PPUSH
102192: LD_INT 7
102194: PPUSH
102195: CALL_OW 12
102199: ST_TO_ADDR
// case i of 1 :
102200: LD_VAR 0 1
102204: PUSH
102205: LD_INT 1
102207: DOUBLE
102208: EQUAL
102209: IFTRUE 102213
102211: GO 102223
102213: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
102214: LD_STRING earthquake(getX(game), 0, 32)
102216: PPUSH
102217: CALL_OW 559
102221: GO 102461
102223: LD_INT 2
102225: DOUBLE
102226: EQUAL
102227: IFTRUE 102231
102229: GO 102245
102231: POP
// begin ToLua ( displayStucuk(); ) ;
102232: LD_STRING displayStucuk();
102234: PPUSH
102235: CALL_OW 559
// ResetFog ;
102239: CALL_OW 335
// end ; 3 :
102243: GO 102461
102245: LD_INT 3
102247: DOUBLE
102248: EQUAL
102249: IFTRUE 102253
102251: GO 102357
102253: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102254: LD_ADDR_VAR 0 2
102258: PUSH
102259: LD_INT 22
102261: PUSH
102262: LD_OWVAR 2
102266: PUSH
102267: EMPTY
102268: LIST
102269: LIST
102270: PUSH
102271: LD_INT 25
102273: PUSH
102274: LD_INT 1
102276: PUSH
102277: EMPTY
102278: LIST
102279: LIST
102280: PUSH
102281: EMPTY
102282: LIST
102283: LIST
102284: PPUSH
102285: CALL_OW 69
102289: ST_TO_ADDR
// if not tmp then
102290: LD_VAR 0 2
102294: NOT
102295: IFFALSE 102299
// exit ;
102297: GO 102461
// un := tmp [ rand ( 1 , tmp ) ] ;
102299: LD_ADDR_VAR 0 3
102303: PUSH
102304: LD_VAR 0 2
102308: PUSH
102309: LD_INT 1
102311: PPUSH
102312: LD_VAR 0 2
102316: PPUSH
102317: CALL_OW 12
102321: ARRAY
102322: ST_TO_ADDR
// if Crawls ( un ) then
102323: LD_VAR 0 3
102327: PPUSH
102328: CALL_OW 318
102332: IFFALSE 102343
// ComWalk ( un ) ;
102334: LD_VAR 0 3
102338: PPUSH
102339: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102343: LD_VAR 0 3
102347: PPUSH
102348: LD_INT 8
102350: PPUSH
102351: CALL_OW 336
// end ; 4 :
102355: GO 102461
102357: LD_INT 4
102359: DOUBLE
102360: EQUAL
102361: IFTRUE 102365
102363: GO 102439
102365: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102366: LD_ADDR_VAR 0 2
102370: PUSH
102371: LD_INT 22
102373: PUSH
102374: LD_OWVAR 2
102378: PUSH
102379: EMPTY
102380: LIST
102381: LIST
102382: PUSH
102383: LD_INT 30
102385: PUSH
102386: LD_INT 29
102388: PUSH
102389: EMPTY
102390: LIST
102391: LIST
102392: PUSH
102393: EMPTY
102394: LIST
102395: LIST
102396: PPUSH
102397: CALL_OW 69
102401: ST_TO_ADDR
// if not tmp then
102402: LD_VAR 0 2
102406: NOT
102407: IFFALSE 102411
// exit ;
102409: GO 102461
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102411: LD_VAR 0 2
102415: PUSH
102416: LD_INT 1
102418: ARRAY
102419: PPUSH
102420: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102424: LD_VAR 0 2
102428: PUSH
102429: LD_INT 1
102431: ARRAY
102432: PPUSH
102433: CALL_OW 65
// end ; 5 .. 7 :
102437: GO 102461
102439: LD_INT 5
102441: DOUBLE
102442: GREATEREQUAL
102443: IFFALSE 102451
102445: LD_INT 7
102447: DOUBLE
102448: LESSEQUAL
102449: IFTRUE 102453
102451: GO 102460
102453: POP
// StreamSibBomb ; end ;
102454: CALL 98698 0 0
102458: GO 102461
102460: POP
// end ;
102461: PPOPN 3
102463: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102464: LD_EXP 109
102468: PUSH
102469: LD_EXP 159
102473: AND
102474: IFFALSE 102630
102476: GO 102478
102478: DISABLE
102479: LD_INT 0
102481: PPUSH
102482: PPUSH
102483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102484: LD_ADDR_VAR 0 2
102488: PUSH
102489: LD_INT 81
102491: PUSH
102492: LD_OWVAR 2
102496: PUSH
102497: EMPTY
102498: LIST
102499: LIST
102500: PUSH
102501: LD_INT 2
102503: PUSH
102504: LD_INT 21
102506: PUSH
102507: LD_INT 1
102509: PUSH
102510: EMPTY
102511: LIST
102512: LIST
102513: PUSH
102514: LD_INT 21
102516: PUSH
102517: LD_INT 2
102519: PUSH
102520: EMPTY
102521: LIST
102522: LIST
102523: PUSH
102524: EMPTY
102525: LIST
102526: LIST
102527: LIST
102528: PUSH
102529: EMPTY
102530: LIST
102531: LIST
102532: PPUSH
102533: CALL_OW 69
102537: ST_TO_ADDR
// if not tmp then
102538: LD_VAR 0 2
102542: NOT
102543: IFFALSE 102547
// exit ;
102545: GO 102630
// p := 0 ;
102547: LD_ADDR_VAR 0 3
102551: PUSH
102552: LD_INT 0
102554: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102555: LD_INT 35
102557: PPUSH
102558: CALL_OW 67
// p := p + 1 ;
102562: LD_ADDR_VAR 0 3
102566: PUSH
102567: LD_VAR 0 3
102571: PUSH
102572: LD_INT 1
102574: PLUS
102575: ST_TO_ADDR
// for i in tmp do
102576: LD_ADDR_VAR 0 1
102580: PUSH
102581: LD_VAR 0 2
102585: PUSH
102586: FOR_IN
102587: IFFALSE 102618
// if GetLives ( i ) < 1000 then
102589: LD_VAR 0 1
102593: PPUSH
102594: CALL_OW 256
102598: PUSH
102599: LD_INT 1000
102601: LESS
102602: IFFALSE 102616
// SetLives ( i , 1000 ) ;
102604: LD_VAR 0 1
102608: PPUSH
102609: LD_INT 1000
102611: PPUSH
102612: CALL_OW 234
102616: GO 102586
102618: POP
102619: POP
// until p > 20 ;
102620: LD_VAR 0 3
102624: PUSH
102625: LD_INT 20
102627: GREATER
102628: IFFALSE 102555
// end ;
102630: PPOPN 3
102632: END
// every 0 0$1 trigger StreamModeActive and sTime do
102633: LD_EXP 109
102637: PUSH
102638: LD_EXP 160
102642: AND
102643: IFFALSE 102678
102645: GO 102647
102647: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102648: LD_INT 28
102650: PPUSH
102651: LD_OWVAR 2
102655: PPUSH
102656: LD_INT 2
102658: PPUSH
102659: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102663: LD_INT 30
102665: PPUSH
102666: LD_OWVAR 2
102670: PPUSH
102671: LD_INT 2
102673: PPUSH
102674: CALL_OW 322
// end ;
102678: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102679: LD_EXP 109
102683: PUSH
102684: LD_EXP 161
102688: AND
102689: IFFALSE 102810
102691: GO 102693
102693: DISABLE
102694: LD_INT 0
102696: PPUSH
102697: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102698: LD_ADDR_VAR 0 2
102702: PUSH
102703: LD_INT 22
102705: PUSH
102706: LD_OWVAR 2
102710: PUSH
102711: EMPTY
102712: LIST
102713: LIST
102714: PUSH
102715: LD_INT 21
102717: PUSH
102718: LD_INT 1
102720: PUSH
102721: EMPTY
102722: LIST
102723: LIST
102724: PUSH
102725: LD_INT 3
102727: PUSH
102728: LD_INT 23
102730: PUSH
102731: LD_INT 0
102733: PUSH
102734: EMPTY
102735: LIST
102736: LIST
102737: PUSH
102738: EMPTY
102739: LIST
102740: LIST
102741: PUSH
102742: EMPTY
102743: LIST
102744: LIST
102745: LIST
102746: PPUSH
102747: CALL_OW 69
102751: ST_TO_ADDR
// if not tmp then
102752: LD_VAR 0 2
102756: NOT
102757: IFFALSE 102761
// exit ;
102759: GO 102810
// for i in tmp do
102761: LD_ADDR_VAR 0 1
102765: PUSH
102766: LD_VAR 0 2
102770: PUSH
102771: FOR_IN
102772: IFFALSE 102808
// begin if Crawls ( i ) then
102774: LD_VAR 0 1
102778: PPUSH
102779: CALL_OW 318
102783: IFFALSE 102794
// ComWalk ( i ) ;
102785: LD_VAR 0 1
102789: PPUSH
102790: CALL_OW 138
// SetClass ( i , 2 ) ;
102794: LD_VAR 0 1
102798: PPUSH
102799: LD_INT 2
102801: PPUSH
102802: CALL_OW 336
// end ;
102806: GO 102771
102808: POP
102809: POP
// end ;
102810: PPOPN 2
102812: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102813: LD_EXP 109
102817: PUSH
102818: LD_EXP 162
102822: AND
102823: IFFALSE 103111
102825: GO 102827
102827: DISABLE
102828: LD_INT 0
102830: PPUSH
102831: PPUSH
102832: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102833: LD_OWVAR 2
102837: PPUSH
102838: LD_INT 9
102840: PPUSH
102841: LD_INT 1
102843: PPUSH
102844: LD_INT 1
102846: PPUSH
102847: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102851: LD_INT 9
102853: PPUSH
102854: LD_OWVAR 2
102858: PPUSH
102859: CALL_OW 343
// uc_side := 9 ;
102863: LD_ADDR_OWVAR 20
102867: PUSH
102868: LD_INT 9
102870: ST_TO_ADDR
// uc_nation := 2 ;
102871: LD_ADDR_OWVAR 21
102875: PUSH
102876: LD_INT 2
102878: ST_TO_ADDR
// hc_name := Dark Warrior ;
102879: LD_ADDR_OWVAR 26
102883: PUSH
102884: LD_STRING Dark Warrior
102886: ST_TO_ADDR
// hc_gallery :=  ;
102887: LD_ADDR_OWVAR 33
102891: PUSH
102892: LD_STRING 
102894: ST_TO_ADDR
// hc_noskilllimit := true ;
102895: LD_ADDR_OWVAR 76
102899: PUSH
102900: LD_INT 1
102902: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102903: LD_ADDR_OWVAR 31
102907: PUSH
102908: LD_INT 30
102910: PUSH
102911: LD_INT 30
102913: PUSH
102914: LD_INT 30
102916: PUSH
102917: LD_INT 30
102919: PUSH
102920: EMPTY
102921: LIST
102922: LIST
102923: LIST
102924: LIST
102925: ST_TO_ADDR
// un := CreateHuman ;
102926: LD_ADDR_VAR 0 3
102930: PUSH
102931: CALL_OW 44
102935: ST_TO_ADDR
// hc_noskilllimit := false ;
102936: LD_ADDR_OWVAR 76
102940: PUSH
102941: LD_INT 0
102943: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102944: LD_VAR 0 3
102948: PPUSH
102949: LD_INT 1
102951: PPUSH
102952: CALL_OW 51
// ToLua ( playRanger() ) ;
102956: LD_STRING playRanger()
102958: PPUSH
102959: CALL_OW 559
// p := 0 ;
102963: LD_ADDR_VAR 0 2
102967: PUSH
102968: LD_INT 0
102970: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102971: LD_INT 35
102973: PPUSH
102974: CALL_OW 67
// p := p + 1 ;
102978: LD_ADDR_VAR 0 2
102982: PUSH
102983: LD_VAR 0 2
102987: PUSH
102988: LD_INT 1
102990: PLUS
102991: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102992: LD_VAR 0 3
102996: PPUSH
102997: CALL_OW 256
103001: PUSH
103002: LD_INT 1000
103004: LESS
103005: IFFALSE 103019
// SetLives ( un , 1000 ) ;
103007: LD_VAR 0 3
103011: PPUSH
103012: LD_INT 1000
103014: PPUSH
103015: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
103019: LD_VAR 0 3
103023: PPUSH
103024: LD_INT 81
103026: PUSH
103027: LD_OWVAR 2
103031: PUSH
103032: EMPTY
103033: LIST
103034: LIST
103035: PUSH
103036: LD_INT 91
103038: PUSH
103039: LD_VAR 0 3
103043: PUSH
103044: LD_INT 30
103046: PUSH
103047: EMPTY
103048: LIST
103049: LIST
103050: LIST
103051: PUSH
103052: EMPTY
103053: LIST
103054: LIST
103055: PPUSH
103056: CALL_OW 69
103060: PPUSH
103061: LD_VAR 0 3
103065: PPUSH
103066: CALL_OW 74
103070: PPUSH
103071: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
103075: LD_VAR 0 2
103079: PUSH
103080: LD_INT 80
103082: GREATER
103083: PUSH
103084: LD_VAR 0 3
103088: PPUSH
103089: CALL_OW 301
103093: OR
103094: IFFALSE 102971
// if un then
103096: LD_VAR 0 3
103100: IFFALSE 103111
// RemoveUnit ( un ) ;
103102: LD_VAR 0 3
103106: PPUSH
103107: CALL_OW 64
// end ;
103111: PPOPN 3
103113: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
103114: LD_EXP 163
103118: IFFALSE 103234
103120: GO 103122
103122: DISABLE
103123: LD_INT 0
103125: PPUSH
103126: PPUSH
103127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
103128: LD_ADDR_VAR 0 2
103132: PUSH
103133: LD_INT 81
103135: PUSH
103136: LD_OWVAR 2
103140: PUSH
103141: EMPTY
103142: LIST
103143: LIST
103144: PUSH
103145: LD_INT 21
103147: PUSH
103148: LD_INT 1
103150: PUSH
103151: EMPTY
103152: LIST
103153: LIST
103154: PUSH
103155: EMPTY
103156: LIST
103157: LIST
103158: PPUSH
103159: CALL_OW 69
103163: ST_TO_ADDR
// ToLua ( playComputer() ) ;
103164: LD_STRING playComputer()
103166: PPUSH
103167: CALL_OW 559
// if not tmp then
103171: LD_VAR 0 2
103175: NOT
103176: IFFALSE 103180
// exit ;
103178: GO 103234
// for i in tmp do
103180: LD_ADDR_VAR 0 1
103184: PUSH
103185: LD_VAR 0 2
103189: PUSH
103190: FOR_IN
103191: IFFALSE 103232
// for j := 1 to 4 do
103193: LD_ADDR_VAR 0 3
103197: PUSH
103198: DOUBLE
103199: LD_INT 1
103201: DEC
103202: ST_TO_ADDR
103203: LD_INT 4
103205: PUSH
103206: FOR_TO
103207: IFFALSE 103228
// SetSkill ( i , j , 10 ) ;
103209: LD_VAR 0 1
103213: PPUSH
103214: LD_VAR 0 3
103218: PPUSH
103219: LD_INT 10
103221: PPUSH
103222: CALL_OW 237
103226: GO 103206
103228: POP
103229: POP
103230: GO 103190
103232: POP
103233: POP
// end ;
103234: PPOPN 3
103236: END
// every 0 0$1 trigger s30 do var i , tmp ;
103237: LD_EXP 164
103241: IFFALSE 103310
103243: GO 103245
103245: DISABLE
103246: LD_INT 0
103248: PPUSH
103249: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103250: LD_ADDR_VAR 0 2
103254: PUSH
103255: LD_INT 22
103257: PUSH
103258: LD_OWVAR 2
103262: PUSH
103263: EMPTY
103264: LIST
103265: LIST
103266: PPUSH
103267: CALL_OW 69
103271: ST_TO_ADDR
// if not tmp then
103272: LD_VAR 0 2
103276: NOT
103277: IFFALSE 103281
// exit ;
103279: GO 103310
// for i in tmp do
103281: LD_ADDR_VAR 0 1
103285: PUSH
103286: LD_VAR 0 2
103290: PUSH
103291: FOR_IN
103292: IFFALSE 103308
// SetLives ( i , 300 ) ;
103294: LD_VAR 0 1
103298: PPUSH
103299: LD_INT 300
103301: PPUSH
103302: CALL_OW 234
103306: GO 103291
103308: POP
103309: POP
// end ;
103310: PPOPN 2
103312: END
// every 0 0$1 trigger s60 do var i , tmp ;
103313: LD_EXP 165
103317: IFFALSE 103386
103319: GO 103321
103321: DISABLE
103322: LD_INT 0
103324: PPUSH
103325: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103326: LD_ADDR_VAR 0 2
103330: PUSH
103331: LD_INT 22
103333: PUSH
103334: LD_OWVAR 2
103338: PUSH
103339: EMPTY
103340: LIST
103341: LIST
103342: PPUSH
103343: CALL_OW 69
103347: ST_TO_ADDR
// if not tmp then
103348: LD_VAR 0 2
103352: NOT
103353: IFFALSE 103357
// exit ;
103355: GO 103386
// for i in tmp do
103357: LD_ADDR_VAR 0 1
103361: PUSH
103362: LD_VAR 0 2
103366: PUSH
103367: FOR_IN
103368: IFFALSE 103384
// SetLives ( i , 600 ) ;
103370: LD_VAR 0 1
103374: PPUSH
103375: LD_INT 600
103377: PPUSH
103378: CALL_OW 234
103382: GO 103367
103384: POP
103385: POP
// end ;
103386: PPOPN 2
103388: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103389: LD_INT 0
103391: PPUSH
// case cmd of 301 :
103392: LD_VAR 0 1
103396: PUSH
103397: LD_INT 301
103399: DOUBLE
103400: EQUAL
103401: IFTRUE 103405
103403: GO 103437
103405: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103406: LD_VAR 0 6
103410: PPUSH
103411: LD_VAR 0 7
103415: PPUSH
103416: LD_VAR 0 8
103420: PPUSH
103421: LD_VAR 0 4
103425: PPUSH
103426: LD_VAR 0 5
103430: PPUSH
103431: CALL 104646 0 5
103435: GO 103558
103437: LD_INT 302
103439: DOUBLE
103440: EQUAL
103441: IFTRUE 103445
103443: GO 103482
103445: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103446: LD_VAR 0 6
103450: PPUSH
103451: LD_VAR 0 7
103455: PPUSH
103456: LD_VAR 0 8
103460: PPUSH
103461: LD_VAR 0 9
103465: PPUSH
103466: LD_VAR 0 4
103470: PPUSH
103471: LD_VAR 0 5
103475: PPUSH
103476: CALL 104737 0 6
103480: GO 103558
103482: LD_INT 303
103484: DOUBLE
103485: EQUAL
103486: IFTRUE 103490
103488: GO 103527
103490: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103491: LD_VAR 0 6
103495: PPUSH
103496: LD_VAR 0 7
103500: PPUSH
103501: LD_VAR 0 8
103505: PPUSH
103506: LD_VAR 0 9
103510: PPUSH
103511: LD_VAR 0 4
103515: PPUSH
103516: LD_VAR 0 5
103520: PPUSH
103521: CALL 103563 0 6
103525: GO 103558
103527: LD_INT 304
103529: DOUBLE
103530: EQUAL
103531: IFTRUE 103535
103533: GO 103557
103535: POP
// hHackTeleport ( unit , x , y ) ; end ;
103536: LD_VAR 0 2
103540: PPUSH
103541: LD_VAR 0 4
103545: PPUSH
103546: LD_VAR 0 5
103550: PPUSH
103551: CALL 105330 0 3
103555: GO 103558
103557: POP
// end ;
103558: LD_VAR 0 12
103562: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103563: LD_INT 0
103565: PPUSH
103566: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103567: LD_VAR 0 1
103571: PUSH
103572: LD_INT 1
103574: LESS
103575: PUSH
103576: LD_VAR 0 1
103580: PUSH
103581: LD_INT 3
103583: GREATER
103584: OR
103585: PUSH
103586: LD_VAR 0 5
103590: PPUSH
103591: LD_VAR 0 6
103595: PPUSH
103596: CALL_OW 428
103600: OR
103601: IFFALSE 103605
// exit ;
103603: GO 104333
// uc_side := your_side ;
103605: LD_ADDR_OWVAR 20
103609: PUSH
103610: LD_OWVAR 2
103614: ST_TO_ADDR
// uc_nation := nation ;
103615: LD_ADDR_OWVAR 21
103619: PUSH
103620: LD_VAR 0 1
103624: ST_TO_ADDR
// bc_level = 1 ;
103625: LD_ADDR_OWVAR 43
103629: PUSH
103630: LD_INT 1
103632: ST_TO_ADDR
// case btype of 1 :
103633: LD_VAR 0 2
103637: PUSH
103638: LD_INT 1
103640: DOUBLE
103641: EQUAL
103642: IFTRUE 103646
103644: GO 103657
103646: POP
// bc_type := b_depot ; 2 :
103647: LD_ADDR_OWVAR 42
103651: PUSH
103652: LD_INT 0
103654: ST_TO_ADDR
103655: GO 104277
103657: LD_INT 2
103659: DOUBLE
103660: EQUAL
103661: IFTRUE 103665
103663: GO 103676
103665: POP
// bc_type := b_warehouse ; 3 :
103666: LD_ADDR_OWVAR 42
103670: PUSH
103671: LD_INT 1
103673: ST_TO_ADDR
103674: GO 104277
103676: LD_INT 3
103678: DOUBLE
103679: EQUAL
103680: IFTRUE 103684
103682: GO 103695
103684: POP
// bc_type := b_lab ; 4 .. 9 :
103685: LD_ADDR_OWVAR 42
103689: PUSH
103690: LD_INT 6
103692: ST_TO_ADDR
103693: GO 104277
103695: LD_INT 4
103697: DOUBLE
103698: GREATEREQUAL
103699: IFFALSE 103707
103701: LD_INT 9
103703: DOUBLE
103704: LESSEQUAL
103705: IFTRUE 103709
103707: GO 103769
103709: POP
// begin bc_type := b_lab_half ;
103710: LD_ADDR_OWVAR 42
103714: PUSH
103715: LD_INT 7
103717: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103718: LD_ADDR_OWVAR 44
103722: PUSH
103723: LD_INT 10
103725: PUSH
103726: LD_INT 11
103728: PUSH
103729: LD_INT 12
103731: PUSH
103732: LD_INT 15
103734: PUSH
103735: LD_INT 14
103737: PUSH
103738: LD_INT 13
103740: PUSH
103741: EMPTY
103742: LIST
103743: LIST
103744: LIST
103745: LIST
103746: LIST
103747: LIST
103748: PUSH
103749: LD_VAR 0 2
103753: PUSH
103754: LD_INT 3
103756: MINUS
103757: ARRAY
103758: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
103759: LD_ADDR_OWVAR 45
103763: PUSH
103764: LD_INT 9
103766: ST_TO_ADDR
// end ; 10 .. 13 :
103767: GO 104277
103769: LD_INT 10
103771: DOUBLE
103772: GREATEREQUAL
103773: IFFALSE 103781
103775: LD_INT 13
103777: DOUBLE
103778: LESSEQUAL
103779: IFTRUE 103783
103781: GO 103860
103783: POP
// begin bc_type := b_lab_full ;
103784: LD_ADDR_OWVAR 42
103788: PUSH
103789: LD_INT 8
103791: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103792: LD_ADDR_OWVAR 44
103796: PUSH
103797: LD_INT 10
103799: PUSH
103800: LD_INT 12
103802: PUSH
103803: LD_INT 14
103805: PUSH
103806: LD_INT 13
103808: PUSH
103809: EMPTY
103810: LIST
103811: LIST
103812: LIST
103813: LIST
103814: PUSH
103815: LD_VAR 0 2
103819: PUSH
103820: LD_INT 9
103822: MINUS
103823: ARRAY
103824: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103825: LD_ADDR_OWVAR 45
103829: PUSH
103830: LD_INT 11
103832: PUSH
103833: LD_INT 15
103835: PUSH
103836: LD_INT 12
103838: PUSH
103839: LD_INT 15
103841: PUSH
103842: EMPTY
103843: LIST
103844: LIST
103845: LIST
103846: LIST
103847: PUSH
103848: LD_VAR 0 2
103852: PUSH
103853: LD_INT 9
103855: MINUS
103856: ARRAY
103857: ST_TO_ADDR
// end ; 14 :
103858: GO 104277
103860: LD_INT 14
103862: DOUBLE
103863: EQUAL
103864: IFTRUE 103868
103866: GO 103879
103868: POP
// bc_type := b_workshop ; 15 :
103869: LD_ADDR_OWVAR 42
103873: PUSH
103874: LD_INT 2
103876: ST_TO_ADDR
103877: GO 104277
103879: LD_INT 15
103881: DOUBLE
103882: EQUAL
103883: IFTRUE 103887
103885: GO 103898
103887: POP
// bc_type := b_factory ; 16 :
103888: LD_ADDR_OWVAR 42
103892: PUSH
103893: LD_INT 3
103895: ST_TO_ADDR
103896: GO 104277
103898: LD_INT 16
103900: DOUBLE
103901: EQUAL
103902: IFTRUE 103906
103904: GO 103917
103906: POP
// bc_type := b_ext_gun ; 17 :
103907: LD_ADDR_OWVAR 42
103911: PUSH
103912: LD_INT 17
103914: ST_TO_ADDR
103915: GO 104277
103917: LD_INT 17
103919: DOUBLE
103920: EQUAL
103921: IFTRUE 103925
103923: GO 103953
103925: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103926: LD_ADDR_OWVAR 42
103930: PUSH
103931: LD_INT 19
103933: PUSH
103934: LD_INT 23
103936: PUSH
103937: LD_INT 19
103939: PUSH
103940: EMPTY
103941: LIST
103942: LIST
103943: LIST
103944: PUSH
103945: LD_VAR 0 1
103949: ARRAY
103950: ST_TO_ADDR
103951: GO 104277
103953: LD_INT 18
103955: DOUBLE
103956: EQUAL
103957: IFTRUE 103961
103959: GO 103972
103961: POP
// bc_type := b_ext_radar ; 19 :
103962: LD_ADDR_OWVAR 42
103966: PUSH
103967: LD_INT 20
103969: ST_TO_ADDR
103970: GO 104277
103972: LD_INT 19
103974: DOUBLE
103975: EQUAL
103976: IFTRUE 103980
103978: GO 103991
103980: POP
// bc_type := b_ext_radio ; 20 :
103981: LD_ADDR_OWVAR 42
103985: PUSH
103986: LD_INT 22
103988: ST_TO_ADDR
103989: GO 104277
103991: LD_INT 20
103993: DOUBLE
103994: EQUAL
103995: IFTRUE 103999
103997: GO 104010
103999: POP
// bc_type := b_ext_siberium ; 21 :
104000: LD_ADDR_OWVAR 42
104004: PUSH
104005: LD_INT 21
104007: ST_TO_ADDR
104008: GO 104277
104010: LD_INT 21
104012: DOUBLE
104013: EQUAL
104014: IFTRUE 104018
104016: GO 104029
104018: POP
// bc_type := b_ext_computer ; 22 :
104019: LD_ADDR_OWVAR 42
104023: PUSH
104024: LD_INT 24
104026: ST_TO_ADDR
104027: GO 104277
104029: LD_INT 22
104031: DOUBLE
104032: EQUAL
104033: IFTRUE 104037
104035: GO 104048
104037: POP
// bc_type := b_ext_track ; 23 :
104038: LD_ADDR_OWVAR 42
104042: PUSH
104043: LD_INT 16
104045: ST_TO_ADDR
104046: GO 104277
104048: LD_INT 23
104050: DOUBLE
104051: EQUAL
104052: IFTRUE 104056
104054: GO 104067
104056: POP
// bc_type := b_ext_laser ; 24 :
104057: LD_ADDR_OWVAR 42
104061: PUSH
104062: LD_INT 25
104064: ST_TO_ADDR
104065: GO 104277
104067: LD_INT 24
104069: DOUBLE
104070: EQUAL
104071: IFTRUE 104075
104073: GO 104086
104075: POP
// bc_type := b_control_tower ; 25 :
104076: LD_ADDR_OWVAR 42
104080: PUSH
104081: LD_INT 36
104083: ST_TO_ADDR
104084: GO 104277
104086: LD_INT 25
104088: DOUBLE
104089: EQUAL
104090: IFTRUE 104094
104092: GO 104105
104094: POP
// bc_type := b_breastwork ; 26 :
104095: LD_ADDR_OWVAR 42
104099: PUSH
104100: LD_INT 31
104102: ST_TO_ADDR
104103: GO 104277
104105: LD_INT 26
104107: DOUBLE
104108: EQUAL
104109: IFTRUE 104113
104111: GO 104124
104113: POP
// bc_type := b_bunker ; 27 :
104114: LD_ADDR_OWVAR 42
104118: PUSH
104119: LD_INT 32
104121: ST_TO_ADDR
104122: GO 104277
104124: LD_INT 27
104126: DOUBLE
104127: EQUAL
104128: IFTRUE 104132
104130: GO 104143
104132: POP
// bc_type := b_turret ; 28 :
104133: LD_ADDR_OWVAR 42
104137: PUSH
104138: LD_INT 33
104140: ST_TO_ADDR
104141: GO 104277
104143: LD_INT 28
104145: DOUBLE
104146: EQUAL
104147: IFTRUE 104151
104149: GO 104162
104151: POP
// bc_type := b_armoury ; 29 :
104152: LD_ADDR_OWVAR 42
104156: PUSH
104157: LD_INT 4
104159: ST_TO_ADDR
104160: GO 104277
104162: LD_INT 29
104164: DOUBLE
104165: EQUAL
104166: IFTRUE 104170
104168: GO 104181
104170: POP
// bc_type := b_barracks ; 30 :
104171: LD_ADDR_OWVAR 42
104175: PUSH
104176: LD_INT 5
104178: ST_TO_ADDR
104179: GO 104277
104181: LD_INT 30
104183: DOUBLE
104184: EQUAL
104185: IFTRUE 104189
104187: GO 104200
104189: POP
// bc_type := b_solar_power ; 31 :
104190: LD_ADDR_OWVAR 42
104194: PUSH
104195: LD_INT 27
104197: ST_TO_ADDR
104198: GO 104277
104200: LD_INT 31
104202: DOUBLE
104203: EQUAL
104204: IFTRUE 104208
104206: GO 104219
104208: POP
// bc_type := b_oil_power ; 32 :
104209: LD_ADDR_OWVAR 42
104213: PUSH
104214: LD_INT 26
104216: ST_TO_ADDR
104217: GO 104277
104219: LD_INT 32
104221: DOUBLE
104222: EQUAL
104223: IFTRUE 104227
104225: GO 104238
104227: POP
// bc_type := b_siberite_power ; 33 :
104228: LD_ADDR_OWVAR 42
104232: PUSH
104233: LD_INT 28
104235: ST_TO_ADDR
104236: GO 104277
104238: LD_INT 33
104240: DOUBLE
104241: EQUAL
104242: IFTRUE 104246
104244: GO 104257
104246: POP
// bc_type := b_oil_mine ; 34 :
104247: LD_ADDR_OWVAR 42
104251: PUSH
104252: LD_INT 29
104254: ST_TO_ADDR
104255: GO 104277
104257: LD_INT 34
104259: DOUBLE
104260: EQUAL
104261: IFTRUE 104265
104263: GO 104276
104265: POP
// bc_type := b_siberite_mine ; end ;
104266: LD_ADDR_OWVAR 42
104270: PUSH
104271: LD_INT 30
104273: ST_TO_ADDR
104274: GO 104277
104276: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104277: LD_ADDR_VAR 0 8
104281: PUSH
104282: LD_VAR 0 5
104286: PPUSH
104287: LD_VAR 0 6
104291: PPUSH
104292: LD_VAR 0 3
104296: PPUSH
104297: CALL_OW 47
104301: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104302: LD_OWVAR 42
104306: PUSH
104307: LD_INT 32
104309: PUSH
104310: LD_INT 33
104312: PUSH
104313: EMPTY
104314: LIST
104315: LIST
104316: IN
104317: IFFALSE 104333
// PlaceWeaponTurret ( b , weapon ) ;
104319: LD_VAR 0 8
104323: PPUSH
104324: LD_VAR 0 4
104328: PPUSH
104329: CALL_OW 431
// end ;
104333: LD_VAR 0 7
104337: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104338: LD_INT 0
104340: PPUSH
104341: PPUSH
104342: PPUSH
104343: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104344: LD_ADDR_VAR 0 4
104348: PUSH
104349: LD_INT 22
104351: PUSH
104352: LD_OWVAR 2
104356: PUSH
104357: EMPTY
104358: LIST
104359: LIST
104360: PUSH
104361: LD_INT 2
104363: PUSH
104364: LD_INT 30
104366: PUSH
104367: LD_INT 0
104369: PUSH
104370: EMPTY
104371: LIST
104372: LIST
104373: PUSH
104374: LD_INT 30
104376: PUSH
104377: LD_INT 1
104379: PUSH
104380: EMPTY
104381: LIST
104382: LIST
104383: PUSH
104384: EMPTY
104385: LIST
104386: LIST
104387: LIST
104388: PUSH
104389: EMPTY
104390: LIST
104391: LIST
104392: PPUSH
104393: CALL_OW 69
104397: ST_TO_ADDR
// if not tmp then
104398: LD_VAR 0 4
104402: NOT
104403: IFFALSE 104407
// exit ;
104405: GO 104466
// for i in tmp do
104407: LD_ADDR_VAR 0 2
104411: PUSH
104412: LD_VAR 0 4
104416: PUSH
104417: FOR_IN
104418: IFFALSE 104464
// for j = 1 to 3 do
104420: LD_ADDR_VAR 0 3
104424: PUSH
104425: DOUBLE
104426: LD_INT 1
104428: DEC
104429: ST_TO_ADDR
104430: LD_INT 3
104432: PUSH
104433: FOR_TO
104434: IFFALSE 104460
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104436: LD_VAR 0 2
104440: PPUSH
104441: CALL_OW 274
104445: PPUSH
104446: LD_VAR 0 3
104450: PPUSH
104451: LD_INT 99999
104453: PPUSH
104454: CALL_OW 277
104458: GO 104433
104460: POP
104461: POP
104462: GO 104417
104464: POP
104465: POP
// end ;
104466: LD_VAR 0 1
104470: RET
// export function hHackSetLevel10 ; var i , j ; begin
104471: LD_INT 0
104473: PPUSH
104474: PPUSH
104475: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104476: LD_ADDR_VAR 0 2
104480: PUSH
104481: LD_INT 21
104483: PUSH
104484: LD_INT 1
104486: PUSH
104487: EMPTY
104488: LIST
104489: LIST
104490: PPUSH
104491: CALL_OW 69
104495: PUSH
104496: FOR_IN
104497: IFFALSE 104549
// if IsSelected ( i ) then
104499: LD_VAR 0 2
104503: PPUSH
104504: CALL_OW 306
104508: IFFALSE 104547
// begin for j := 1 to 4 do
104510: LD_ADDR_VAR 0 3
104514: PUSH
104515: DOUBLE
104516: LD_INT 1
104518: DEC
104519: ST_TO_ADDR
104520: LD_INT 4
104522: PUSH
104523: FOR_TO
104524: IFFALSE 104545
// SetSkill ( i , j , 10 ) ;
104526: LD_VAR 0 2
104530: PPUSH
104531: LD_VAR 0 3
104535: PPUSH
104536: LD_INT 10
104538: PPUSH
104539: CALL_OW 237
104543: GO 104523
104545: POP
104546: POP
// end ;
104547: GO 104496
104549: POP
104550: POP
// end ;
104551: LD_VAR 0 1
104555: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104556: LD_INT 0
104558: PPUSH
104559: PPUSH
104560: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104561: LD_ADDR_VAR 0 2
104565: PUSH
104566: LD_INT 22
104568: PUSH
104569: LD_OWVAR 2
104573: PUSH
104574: EMPTY
104575: LIST
104576: LIST
104577: PUSH
104578: LD_INT 21
104580: PUSH
104581: LD_INT 1
104583: PUSH
104584: EMPTY
104585: LIST
104586: LIST
104587: PUSH
104588: EMPTY
104589: LIST
104590: LIST
104591: PPUSH
104592: CALL_OW 69
104596: PUSH
104597: FOR_IN
104598: IFFALSE 104639
// begin for j := 1 to 4 do
104600: LD_ADDR_VAR 0 3
104604: PUSH
104605: DOUBLE
104606: LD_INT 1
104608: DEC
104609: ST_TO_ADDR
104610: LD_INT 4
104612: PUSH
104613: FOR_TO
104614: IFFALSE 104635
// SetSkill ( i , j , 10 ) ;
104616: LD_VAR 0 2
104620: PPUSH
104621: LD_VAR 0 3
104625: PPUSH
104626: LD_INT 10
104628: PPUSH
104629: CALL_OW 237
104633: GO 104613
104635: POP
104636: POP
// end ;
104637: GO 104597
104639: POP
104640: POP
// end ;
104641: LD_VAR 0 1
104645: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104646: LD_INT 0
104648: PPUSH
// uc_side := your_side ;
104649: LD_ADDR_OWVAR 20
104653: PUSH
104654: LD_OWVAR 2
104658: ST_TO_ADDR
// uc_nation := nation ;
104659: LD_ADDR_OWVAR 21
104663: PUSH
104664: LD_VAR 0 1
104668: ST_TO_ADDR
// InitHc ;
104669: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104673: LD_INT 0
104675: PPUSH
104676: LD_VAR 0 2
104680: PPUSH
104681: LD_VAR 0 3
104685: PPUSH
104686: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104690: LD_VAR 0 4
104694: PPUSH
104695: LD_VAR 0 5
104699: PPUSH
104700: CALL_OW 428
104704: PUSH
104705: LD_INT 0
104707: EQUAL
104708: IFFALSE 104732
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104710: CALL_OW 44
104714: PPUSH
104715: LD_VAR 0 4
104719: PPUSH
104720: LD_VAR 0 5
104724: PPUSH
104725: LD_INT 1
104727: PPUSH
104728: CALL_OW 48
// end ;
104732: LD_VAR 0 6
104736: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104737: LD_INT 0
104739: PPUSH
104740: PPUSH
// uc_side := your_side ;
104741: LD_ADDR_OWVAR 20
104745: PUSH
104746: LD_OWVAR 2
104750: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104751: LD_VAR 0 1
104755: PUSH
104756: LD_INT 1
104758: PUSH
104759: LD_INT 2
104761: PUSH
104762: LD_INT 3
104764: PUSH
104765: LD_INT 4
104767: PUSH
104768: LD_INT 5
104770: PUSH
104771: EMPTY
104772: LIST
104773: LIST
104774: LIST
104775: LIST
104776: LIST
104777: IN
104778: IFFALSE 104790
// uc_nation := nation_american else
104780: LD_ADDR_OWVAR 21
104784: PUSH
104785: LD_INT 1
104787: ST_TO_ADDR
104788: GO 104833
// if chassis in [ 11 , 12 , 13 , 14 ] then
104790: LD_VAR 0 1
104794: PUSH
104795: LD_INT 11
104797: PUSH
104798: LD_INT 12
104800: PUSH
104801: LD_INT 13
104803: PUSH
104804: LD_INT 14
104806: PUSH
104807: EMPTY
104808: LIST
104809: LIST
104810: LIST
104811: LIST
104812: IN
104813: IFFALSE 104825
// uc_nation := nation_arabian else
104815: LD_ADDR_OWVAR 21
104819: PUSH
104820: LD_INT 2
104822: ST_TO_ADDR
104823: GO 104833
// uc_nation := nation_russian ;
104825: LD_ADDR_OWVAR 21
104829: PUSH
104830: LD_INT 3
104832: ST_TO_ADDR
// vc_chassis := chassis ;
104833: LD_ADDR_OWVAR 37
104837: PUSH
104838: LD_VAR 0 1
104842: ST_TO_ADDR
// vc_engine := engine ;
104843: LD_ADDR_OWVAR 39
104847: PUSH
104848: LD_VAR 0 2
104852: ST_TO_ADDR
// vc_control := control ;
104853: LD_ADDR_OWVAR 38
104857: PUSH
104858: LD_VAR 0 3
104862: ST_TO_ADDR
// vc_weapon := weapon ;
104863: LD_ADDR_OWVAR 40
104867: PUSH
104868: LD_VAR 0 4
104872: ST_TO_ADDR
// un := CreateVehicle ;
104873: LD_ADDR_VAR 0 8
104877: PUSH
104878: CALL_OW 45
104882: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104883: LD_VAR 0 8
104887: PPUSH
104888: LD_INT 0
104890: PPUSH
104891: LD_INT 5
104893: PPUSH
104894: CALL_OW 12
104898: PPUSH
104899: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104903: LD_VAR 0 8
104907: PPUSH
104908: LD_VAR 0 5
104912: PPUSH
104913: LD_VAR 0 6
104917: PPUSH
104918: LD_INT 1
104920: PPUSH
104921: CALL_OW 48
// end ;
104925: LD_VAR 0 7
104929: RET
// export hInvincible ; every 1 do
104930: GO 104932
104932: DISABLE
// hInvincible := [ ] ;
104933: LD_ADDR_EXP 166
104937: PUSH
104938: EMPTY
104939: ST_TO_ADDR
104940: END
// every 10 do var i ;
104941: GO 104943
104943: DISABLE
104944: LD_INT 0
104946: PPUSH
// begin enable ;
104947: ENABLE
// if not hInvincible then
104948: LD_EXP 166
104952: NOT
104953: IFFALSE 104957
// exit ;
104955: GO 105001
// for i in hInvincible do
104957: LD_ADDR_VAR 0 1
104961: PUSH
104962: LD_EXP 166
104966: PUSH
104967: FOR_IN
104968: IFFALSE 104999
// if GetLives ( i ) < 1000 then
104970: LD_VAR 0 1
104974: PPUSH
104975: CALL_OW 256
104979: PUSH
104980: LD_INT 1000
104982: LESS
104983: IFFALSE 104997
// SetLives ( i , 1000 ) ;
104985: LD_VAR 0 1
104989: PPUSH
104990: LD_INT 1000
104992: PPUSH
104993: CALL_OW 234
104997: GO 104967
104999: POP
105000: POP
// end ;
105001: PPOPN 1
105003: END
// export function hHackInvincible ; var i ; begin
105004: LD_INT 0
105006: PPUSH
105007: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
105008: LD_ADDR_VAR 0 2
105012: PUSH
105013: LD_INT 2
105015: PUSH
105016: LD_INT 21
105018: PUSH
105019: LD_INT 1
105021: PUSH
105022: EMPTY
105023: LIST
105024: LIST
105025: PUSH
105026: LD_INT 21
105028: PUSH
105029: LD_INT 2
105031: PUSH
105032: EMPTY
105033: LIST
105034: LIST
105035: PUSH
105036: EMPTY
105037: LIST
105038: LIST
105039: LIST
105040: PPUSH
105041: CALL_OW 69
105045: PUSH
105046: FOR_IN
105047: IFFALSE 105108
// if IsSelected ( i ) then
105049: LD_VAR 0 2
105053: PPUSH
105054: CALL_OW 306
105058: IFFALSE 105106
// begin if i in hInvincible then
105060: LD_VAR 0 2
105064: PUSH
105065: LD_EXP 166
105069: IN
105070: IFFALSE 105090
// hInvincible := hInvincible diff i else
105072: LD_ADDR_EXP 166
105076: PUSH
105077: LD_EXP 166
105081: PUSH
105082: LD_VAR 0 2
105086: DIFF
105087: ST_TO_ADDR
105088: GO 105106
// hInvincible := hInvincible union i ;
105090: LD_ADDR_EXP 166
105094: PUSH
105095: LD_EXP 166
105099: PUSH
105100: LD_VAR 0 2
105104: UNION
105105: ST_TO_ADDR
// end ;
105106: GO 105046
105108: POP
105109: POP
// end ;
105110: LD_VAR 0 1
105114: RET
// export function hHackInvisible ; var i , j ; begin
105115: LD_INT 0
105117: PPUSH
105118: PPUSH
105119: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105120: LD_ADDR_VAR 0 2
105124: PUSH
105125: LD_INT 21
105127: PUSH
105128: LD_INT 1
105130: PUSH
105131: EMPTY
105132: LIST
105133: LIST
105134: PPUSH
105135: CALL_OW 69
105139: PUSH
105140: FOR_IN
105141: IFFALSE 105165
// if IsSelected ( i ) then
105143: LD_VAR 0 2
105147: PPUSH
105148: CALL_OW 306
105152: IFFALSE 105163
// ComForceInvisible ( i ) ;
105154: LD_VAR 0 2
105158: PPUSH
105159: CALL_OW 496
105163: GO 105140
105165: POP
105166: POP
// end ;
105167: LD_VAR 0 1
105171: RET
// export function hHackChangeYourSide ; begin
105172: LD_INT 0
105174: PPUSH
// if your_side = 8 then
105175: LD_OWVAR 2
105179: PUSH
105180: LD_INT 8
105182: EQUAL
105183: IFFALSE 105195
// your_side := 0 else
105185: LD_ADDR_OWVAR 2
105189: PUSH
105190: LD_INT 0
105192: ST_TO_ADDR
105193: GO 105209
// your_side := your_side + 1 ;
105195: LD_ADDR_OWVAR 2
105199: PUSH
105200: LD_OWVAR 2
105204: PUSH
105205: LD_INT 1
105207: PLUS
105208: ST_TO_ADDR
// end ;
105209: LD_VAR 0 1
105213: RET
// export function hHackChangeUnitSide ; var i , j ; begin
105214: LD_INT 0
105216: PPUSH
105217: PPUSH
105218: PPUSH
// for i in all_units do
105219: LD_ADDR_VAR 0 2
105223: PUSH
105224: LD_OWVAR 3
105228: PUSH
105229: FOR_IN
105230: IFFALSE 105308
// if IsSelected ( i ) then
105232: LD_VAR 0 2
105236: PPUSH
105237: CALL_OW 306
105241: IFFALSE 105306
// begin j := GetSide ( i ) ;
105243: LD_ADDR_VAR 0 3
105247: PUSH
105248: LD_VAR 0 2
105252: PPUSH
105253: CALL_OW 255
105257: ST_TO_ADDR
// if j = 8 then
105258: LD_VAR 0 3
105262: PUSH
105263: LD_INT 8
105265: EQUAL
105266: IFFALSE 105278
// j := 0 else
105268: LD_ADDR_VAR 0 3
105272: PUSH
105273: LD_INT 0
105275: ST_TO_ADDR
105276: GO 105292
// j := j + 1 ;
105278: LD_ADDR_VAR 0 3
105282: PUSH
105283: LD_VAR 0 3
105287: PUSH
105288: LD_INT 1
105290: PLUS
105291: ST_TO_ADDR
// SetSide ( i , j ) ;
105292: LD_VAR 0 2
105296: PPUSH
105297: LD_VAR 0 3
105301: PPUSH
105302: CALL_OW 235
// end ;
105306: GO 105229
105308: POP
105309: POP
// end ;
105310: LD_VAR 0 1
105314: RET
// export function hHackFog ; begin
105315: LD_INT 0
105317: PPUSH
// FogOff ( true ) ;
105318: LD_INT 1
105320: PPUSH
105321: CALL_OW 344
// end ;
105325: LD_VAR 0 1
105329: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105330: LD_INT 0
105332: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105333: LD_VAR 0 1
105337: PPUSH
105338: LD_VAR 0 2
105342: PPUSH
105343: LD_VAR 0 3
105347: PPUSH
105348: LD_INT 1
105350: PPUSH
105351: LD_INT 1
105353: PPUSH
105354: CALL_OW 483
// CenterOnXY ( x , y ) ;
105358: LD_VAR 0 2
105362: PPUSH
105363: LD_VAR 0 3
105367: PPUSH
105368: CALL_OW 84
// end ;
105372: LD_VAR 0 4
105376: RET
// export factoryWaypoints , factoryWaypointsDrivers ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105377: LD_INT 0
105379: PPUSH
105380: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105381: LD_VAR 0 1
105385: NOT
105386: PUSH
105387: LD_VAR 0 2
105391: PPUSH
105392: LD_VAR 0 3
105396: PPUSH
105397: CALL_OW 488
105401: NOT
105402: OR
105403: PUSH
105404: LD_VAR 0 1
105408: PPUSH
105409: CALL_OW 266
105413: PUSH
105414: LD_INT 3
105416: NONEQUAL
105417: PUSH
105418: LD_VAR 0 1
105422: PPUSH
105423: CALL_OW 247
105427: PUSH
105428: LD_INT 1
105430: EQUAL
105431: NOT
105432: AND
105433: OR
105434: IFFALSE 105438
// exit ;
105436: GO 105720
// if GetType ( factory ) = unit_human then
105438: LD_VAR 0 1
105442: PPUSH
105443: CALL_OW 247
105447: PUSH
105448: LD_INT 1
105450: EQUAL
105451: IFFALSE 105468
// factory := IsInUnit ( factory ) ;
105453: LD_ADDR_VAR 0 1
105457: PUSH
105458: LD_VAR 0 1
105462: PPUSH
105463: CALL_OW 310
105467: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105468: LD_VAR 0 1
105472: PPUSH
105473: CALL_OW 266
105477: PUSH
105478: LD_INT 3
105480: NONEQUAL
105481: IFFALSE 105485
// exit ;
105483: GO 105720
// for i := 1 to Count ( factoryWaypoints ) do
105485: LD_ADDR_VAR 0 5
105489: PUSH
105490: DOUBLE
105491: LD_INT 1
105493: DEC
105494: ST_TO_ADDR
105495: LD_EXP 167
105499: PPUSH
105500: CALL 19462 0 1
105504: PUSH
105505: FOR_TO
105506: IFFALSE 105668
// begin if HexInfo ( x , y ) = factoryWaypoints [ i ] [ 2 ] then
105508: LD_VAR 0 2
105512: PPUSH
105513: LD_VAR 0 3
105517: PPUSH
105518: CALL_OW 428
105522: PUSH
105523: LD_EXP 167
105527: PUSH
105528: LD_VAR 0 5
105532: ARRAY
105533: PUSH
105534: LD_INT 2
105536: ARRAY
105537: EQUAL
105538: IFFALSE 105570
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
105540: LD_ADDR_EXP 167
105544: PUSH
105545: LD_EXP 167
105549: PPUSH
105550: LD_VAR 0 5
105554: PPUSH
105555: CALL_OW 3
105559: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105560: CALL 105725 0 0
// exit ;
105564: POP
105565: POP
105566: GO 105720
// end else
105568: GO 105666
// if factory = factoryWaypoints [ i ] [ 2 ] then
105570: LD_VAR 0 1
105574: PUSH
105575: LD_EXP 167
105579: PUSH
105580: LD_VAR 0 5
105584: ARRAY
105585: PUSH
105586: LD_INT 2
105588: ARRAY
105589: EQUAL
105590: IFFALSE 105666
// begin factoryWaypoints := Delete ( factoryWaypoints , i ) ;
105592: LD_ADDR_EXP 167
105596: PUSH
105597: LD_EXP 167
105601: PPUSH
105602: LD_VAR 0 5
105606: PPUSH
105607: CALL_OW 3
105611: ST_TO_ADDR
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
105612: LD_ADDR_EXP 167
105616: PUSH
105617: LD_EXP 167
105621: PPUSH
105622: LD_VAR 0 1
105626: PPUSH
105627: CALL_OW 255
105631: PUSH
105632: LD_VAR 0 1
105636: PUSH
105637: LD_VAR 0 2
105641: PUSH
105642: LD_VAR 0 3
105646: PUSH
105647: EMPTY
105648: LIST
105649: LIST
105650: LIST
105651: LIST
105652: PPUSH
105653: CALL 55071 0 2
105657: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105658: CALL 105725 0 0
// exit ;
105662: POP
105663: POP
105664: GO 105720
// end ; end ;
105666: GO 105505
105668: POP
105669: POP
// factoryWaypoints := Join ( factoryWaypoints , [ GetSide ( factory ) , factory , x , y ] ) ;
105670: LD_ADDR_EXP 167
105674: PUSH
105675: LD_EXP 167
105679: PPUSH
105680: LD_VAR 0 1
105684: PPUSH
105685: CALL_OW 255
105689: PUSH
105690: LD_VAR 0 1
105694: PUSH
105695: LD_VAR 0 2
105699: PUSH
105700: LD_VAR 0 3
105704: PUSH
105705: EMPTY
105706: LIST
105707: LIST
105708: LIST
105709: LIST
105710: PPUSH
105711: CALL 55071 0 2
105715: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105716: CALL 105725 0 0
// end ;
105720: LD_VAR 0 4
105724: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105725: LD_INT 0
105727: PPUSH
105728: PPUSH
105729: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105730: LD_STRING resetFactoryWaypoint();
105732: PPUSH
105733: CALL_OW 559
// if factoryWaypoints then
105737: LD_EXP 167
105741: IFFALSE 105862
// begin list := factoryWaypoints ;
105743: LD_ADDR_VAR 0 3
105747: PUSH
105748: LD_EXP 167
105752: ST_TO_ADDR
// for i := 1 to list do
105753: LD_ADDR_VAR 0 2
105757: PUSH
105758: DOUBLE
105759: LD_INT 1
105761: DEC
105762: ST_TO_ADDR
105763: LD_VAR 0 3
105767: PUSH
105768: FOR_TO
105769: IFFALSE 105860
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105771: LD_STRING setFactoryWaypointXY(
105773: PUSH
105774: LD_VAR 0 3
105778: PUSH
105779: LD_VAR 0 2
105783: ARRAY
105784: PUSH
105785: LD_INT 1
105787: ARRAY
105788: STR
105789: PUSH
105790: LD_STRING ,
105792: STR
105793: PUSH
105794: LD_VAR 0 3
105798: PUSH
105799: LD_VAR 0 2
105803: ARRAY
105804: PUSH
105805: LD_INT 2
105807: ARRAY
105808: STR
105809: PUSH
105810: LD_STRING ,
105812: STR
105813: PUSH
105814: LD_VAR 0 3
105818: PUSH
105819: LD_VAR 0 2
105823: ARRAY
105824: PUSH
105825: LD_INT 3
105827: ARRAY
105828: STR
105829: PUSH
105830: LD_STRING ,
105832: STR
105833: PUSH
105834: LD_VAR 0 3
105838: PUSH
105839: LD_VAR 0 2
105843: ARRAY
105844: PUSH
105845: LD_INT 4
105847: ARRAY
105848: STR
105849: PUSH
105850: LD_STRING )
105852: STR
105853: PPUSH
105854: CALL_OW 559
105858: GO 105768
105860: POP
105861: POP
// end ; end ;
105862: LD_VAR 0 1
105866: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105867: LD_INT 0
105869: PPUSH
// if HexInfo ( x , y ) = warehouse then
105870: LD_VAR 0 2
105874: PPUSH
105875: LD_VAR 0 3
105879: PPUSH
105880: CALL_OW 428
105884: PUSH
105885: LD_VAR 0 1
105889: EQUAL
105890: IFFALSE 105917
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105892: LD_ADDR_EXP 169
105896: PUSH
105897: LD_EXP 169
105901: PPUSH
105902: LD_VAR 0 1
105906: PPUSH
105907: LD_INT 0
105909: PPUSH
105910: CALL_OW 1
105914: ST_TO_ADDR
105915: GO 105968
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105917: LD_ADDR_EXP 169
105921: PUSH
105922: LD_EXP 169
105926: PPUSH
105927: LD_VAR 0 1
105931: PPUSH
105932: LD_VAR 0 1
105936: PPUSH
105937: CALL_OW 255
105941: PUSH
105942: LD_VAR 0 1
105946: PUSH
105947: LD_VAR 0 2
105951: PUSH
105952: LD_VAR 0 3
105956: PUSH
105957: EMPTY
105958: LIST
105959: LIST
105960: LIST
105961: LIST
105962: PPUSH
105963: CALL_OW 1
105967: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105968: CALL 105977 0 0
// end ;
105972: LD_VAR 0 4
105976: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105977: LD_INT 0
105979: PPUSH
105980: PPUSH
105981: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105982: LD_STRING resetWarehouseGatheringPoints();
105984: PPUSH
105985: CALL_OW 559
// if warehouseGatheringPoints then
105989: LD_EXP 169
105993: IFFALSE 106119
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105995: LD_ADDR_VAR 0 3
105999: PUSH
106000: LD_EXP 169
106004: PPUSH
106005: CALL 58839 0 1
106009: ST_TO_ADDR
// for i := 1 to list do
106010: LD_ADDR_VAR 0 2
106014: PUSH
106015: DOUBLE
106016: LD_INT 1
106018: DEC
106019: ST_TO_ADDR
106020: LD_VAR 0 3
106024: PUSH
106025: FOR_TO
106026: IFFALSE 106117
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106028: LD_STRING setWarehouseGatheringPointXY(
106030: PUSH
106031: LD_VAR 0 3
106035: PUSH
106036: LD_VAR 0 2
106040: ARRAY
106041: PUSH
106042: LD_INT 1
106044: ARRAY
106045: STR
106046: PUSH
106047: LD_STRING ,
106049: STR
106050: PUSH
106051: LD_VAR 0 3
106055: PUSH
106056: LD_VAR 0 2
106060: ARRAY
106061: PUSH
106062: LD_INT 2
106064: ARRAY
106065: STR
106066: PUSH
106067: LD_STRING ,
106069: STR
106070: PUSH
106071: LD_VAR 0 3
106075: PUSH
106076: LD_VAR 0 2
106080: ARRAY
106081: PUSH
106082: LD_INT 3
106084: ARRAY
106085: STR
106086: PUSH
106087: LD_STRING ,
106089: STR
106090: PUSH
106091: LD_VAR 0 3
106095: PUSH
106096: LD_VAR 0 2
106100: ARRAY
106101: PUSH
106102: LD_INT 4
106104: ARRAY
106105: STR
106106: PUSH
106107: LD_STRING )
106109: STR
106110: PPUSH
106111: CALL_OW 559
106115: GO 106025
106117: POP
106118: POP
// end ; end ;
106119: LD_VAR 0 1
106123: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
106124: LD_EXP 169
106128: IFFALSE 106813
106130: GO 106132
106132: DISABLE
106133: LD_INT 0
106135: PPUSH
106136: PPUSH
106137: PPUSH
106138: PPUSH
106139: PPUSH
106140: PPUSH
106141: PPUSH
106142: PPUSH
106143: PPUSH
// begin enable ;
106144: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
106145: LD_ADDR_VAR 0 3
106149: PUSH
106150: LD_EXP 169
106154: PPUSH
106155: CALL 58839 0 1
106159: ST_TO_ADDR
// if not list then
106160: LD_VAR 0 3
106164: NOT
106165: IFFALSE 106169
// exit ;
106167: GO 106813
// for i := 1 to list do
106169: LD_ADDR_VAR 0 1
106173: PUSH
106174: DOUBLE
106175: LD_INT 1
106177: DEC
106178: ST_TO_ADDR
106179: LD_VAR 0 3
106183: PUSH
106184: FOR_TO
106185: IFFALSE 106811
// begin depot := list [ i ] [ 2 ] ;
106187: LD_ADDR_VAR 0 8
106191: PUSH
106192: LD_VAR 0 3
106196: PUSH
106197: LD_VAR 0 1
106201: ARRAY
106202: PUSH
106203: LD_INT 2
106205: ARRAY
106206: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
106207: LD_ADDR_VAR 0 5
106211: PUSH
106212: LD_VAR 0 3
106216: PUSH
106217: LD_VAR 0 1
106221: ARRAY
106222: PUSH
106223: LD_INT 1
106225: ARRAY
106226: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
106227: LD_VAR 0 8
106231: PPUSH
106232: CALL_OW 301
106236: PUSH
106237: LD_VAR 0 5
106241: PUSH
106242: LD_VAR 0 8
106246: PPUSH
106247: CALL_OW 255
106251: NONEQUAL
106252: OR
106253: IFFALSE 106282
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
106255: LD_ADDR_EXP 169
106259: PUSH
106260: LD_EXP 169
106264: PPUSH
106265: LD_VAR 0 8
106269: PPUSH
106270: LD_INT 0
106272: PPUSH
106273: CALL_OW 1
106277: ST_TO_ADDR
// exit ;
106278: POP
106279: POP
106280: GO 106813
// end ; x := list [ i ] [ 3 ] ;
106282: LD_ADDR_VAR 0 6
106286: PUSH
106287: LD_VAR 0 3
106291: PUSH
106292: LD_VAR 0 1
106296: ARRAY
106297: PUSH
106298: LD_INT 3
106300: ARRAY
106301: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
106302: LD_ADDR_VAR 0 7
106306: PUSH
106307: LD_VAR 0 3
106311: PUSH
106312: LD_VAR 0 1
106316: ARRAY
106317: PUSH
106318: LD_INT 4
106320: ARRAY
106321: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
106322: LD_ADDR_VAR 0 9
106326: PUSH
106327: LD_VAR 0 6
106331: PPUSH
106332: LD_VAR 0 7
106336: PPUSH
106337: LD_INT 16
106339: PPUSH
106340: CALL 57423 0 3
106344: ST_TO_ADDR
// if not cratesNearbyPoint then
106345: LD_VAR 0 9
106349: NOT
106350: IFFALSE 106356
// exit ;
106352: POP
106353: POP
106354: GO 106813
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
106356: LD_ADDR_VAR 0 4
106360: PUSH
106361: LD_INT 22
106363: PUSH
106364: LD_VAR 0 5
106368: PUSH
106369: EMPTY
106370: LIST
106371: LIST
106372: PUSH
106373: LD_INT 3
106375: PUSH
106376: LD_INT 60
106378: PUSH
106379: EMPTY
106380: LIST
106381: PUSH
106382: EMPTY
106383: LIST
106384: LIST
106385: PUSH
106386: LD_INT 91
106388: PUSH
106389: LD_VAR 0 8
106393: PUSH
106394: LD_INT 6
106396: PUSH
106397: EMPTY
106398: LIST
106399: LIST
106400: LIST
106401: PUSH
106402: LD_INT 2
106404: PUSH
106405: LD_INT 25
106407: PUSH
106408: LD_INT 2
106410: PUSH
106411: EMPTY
106412: LIST
106413: LIST
106414: PUSH
106415: LD_INT 25
106417: PUSH
106418: LD_INT 16
106420: PUSH
106421: EMPTY
106422: LIST
106423: LIST
106424: PUSH
106425: EMPTY
106426: LIST
106427: LIST
106428: LIST
106429: PUSH
106430: EMPTY
106431: LIST
106432: LIST
106433: LIST
106434: LIST
106435: PPUSH
106436: CALL_OW 69
106440: PUSH
106441: LD_VAR 0 8
106445: PPUSH
106446: CALL_OW 313
106450: PPUSH
106451: LD_INT 3
106453: PUSH
106454: LD_INT 60
106456: PUSH
106457: EMPTY
106458: LIST
106459: PUSH
106460: EMPTY
106461: LIST
106462: LIST
106463: PUSH
106464: LD_INT 2
106466: PUSH
106467: LD_INT 25
106469: PUSH
106470: LD_INT 2
106472: PUSH
106473: EMPTY
106474: LIST
106475: LIST
106476: PUSH
106477: LD_INT 25
106479: PUSH
106480: LD_INT 16
106482: PUSH
106483: EMPTY
106484: LIST
106485: LIST
106486: PUSH
106487: EMPTY
106488: LIST
106489: LIST
106490: LIST
106491: PUSH
106492: EMPTY
106493: LIST
106494: LIST
106495: PPUSH
106496: CALL_OW 72
106500: UNION
106501: ST_TO_ADDR
// if tmp then
106502: LD_VAR 0 4
106506: IFFALSE 106586
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106508: LD_ADDR_VAR 0 4
106512: PUSH
106513: LD_VAR 0 4
106517: PPUSH
106518: LD_INT 3
106520: PPUSH
106521: CALL 55386 0 2
106525: ST_TO_ADDR
// for j in tmp do
106526: LD_ADDR_VAR 0 2
106530: PUSH
106531: LD_VAR 0 4
106535: PUSH
106536: FOR_IN
106537: IFFALSE 106580
// begin if IsInUnit ( j ) then
106539: LD_VAR 0 2
106543: PPUSH
106544: CALL_OW 310
106548: IFFALSE 106559
// ComExit ( j ) ;
106550: LD_VAR 0 2
106554: PPUSH
106555: CALL 55469 0 1
// AddComCollect ( j , x , y ) ;
106559: LD_VAR 0 2
106563: PPUSH
106564: LD_VAR 0 6
106568: PPUSH
106569: LD_VAR 0 7
106573: PPUSH
106574: CALL_OW 177
// end ;
106578: GO 106536
106580: POP
106581: POP
// exit ;
106582: POP
106583: POP
106584: GO 106813
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106586: LD_ADDR_VAR 0 4
106590: PUSH
106591: LD_INT 22
106593: PUSH
106594: LD_VAR 0 5
106598: PUSH
106599: EMPTY
106600: LIST
106601: LIST
106602: PUSH
106603: LD_INT 91
106605: PUSH
106606: LD_VAR 0 8
106610: PUSH
106611: LD_INT 8
106613: PUSH
106614: EMPTY
106615: LIST
106616: LIST
106617: LIST
106618: PUSH
106619: LD_INT 2
106621: PUSH
106622: LD_INT 34
106624: PUSH
106625: LD_INT 12
106627: PUSH
106628: EMPTY
106629: LIST
106630: LIST
106631: PUSH
106632: LD_INT 34
106634: PUSH
106635: LD_INT 51
106637: PUSH
106638: EMPTY
106639: LIST
106640: LIST
106641: PUSH
106642: LD_INT 34
106644: PUSH
106645: LD_INT 32
106647: PUSH
106648: EMPTY
106649: LIST
106650: LIST
106651: PUSH
106652: LD_INT 34
106654: PUSH
106655: LD_INT 89
106657: PUSH
106658: EMPTY
106659: LIST
106660: LIST
106661: PUSH
106662: EMPTY
106663: LIST
106664: LIST
106665: LIST
106666: LIST
106667: LIST
106668: PUSH
106669: EMPTY
106670: LIST
106671: LIST
106672: LIST
106673: PPUSH
106674: CALL_OW 69
106678: ST_TO_ADDR
// if tmp then
106679: LD_VAR 0 4
106683: IFFALSE 106809
// begin for j in tmp do
106685: LD_ADDR_VAR 0 2
106689: PUSH
106690: LD_VAR 0 4
106694: PUSH
106695: FOR_IN
106696: IFFALSE 106807
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106698: LD_VAR 0 2
106702: PPUSH
106703: CALL_OW 262
106707: PUSH
106708: LD_INT 3
106710: EQUAL
106711: PUSH
106712: LD_VAR 0 2
106716: PPUSH
106717: CALL_OW 261
106721: PUSH
106722: LD_INT 20
106724: GREATER
106725: OR
106726: PUSH
106727: LD_VAR 0 2
106731: PPUSH
106732: CALL_OW 314
106736: NOT
106737: AND
106738: PUSH
106739: LD_VAR 0 2
106743: PPUSH
106744: CALL_OW 263
106748: PUSH
106749: LD_INT 1
106751: NONEQUAL
106752: PUSH
106753: LD_VAR 0 2
106757: PPUSH
106758: CALL_OW 311
106762: OR
106763: AND
106764: IFFALSE 106805
// begin ComCollect ( j , x , y ) ;
106766: LD_VAR 0 2
106770: PPUSH
106771: LD_VAR 0 6
106775: PPUSH
106776: LD_VAR 0 7
106780: PPUSH
106781: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106785: LD_VAR 0 2
106789: PPUSH
106790: LD_VAR 0 8
106794: PPUSH
106795: CALL_OW 172
// exit ;
106799: POP
106800: POP
106801: POP
106802: POP
106803: GO 106813
// end ;
106805: GO 106695
106807: POP
106808: POP
// end ; end ;
106809: GO 106184
106811: POP
106812: POP
// end ; end_of_file
106813: PPOPN 9
106815: END
// export function SOS_UnitDestroyed ( un ) ; begin
106816: LD_INT 0
106818: PPUSH
// ComRadiation ( un ) ;
106819: LD_VAR 0 1
106823: PPUSH
106824: CALL 107885 0 1
// end ;
106828: LD_VAR 0 2
106832: RET
// export function SOS_UnitKamikazed ( un ) ; begin
106833: LD_INT 0
106835: PPUSH
// ComRadiation ( un ) ;
106836: LD_VAR 0 1
106840: PPUSH
106841: CALL 107885 0 1
// end ;
106845: LD_VAR 0 2
106849: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106850: LD_INT 0
106852: PPUSH
// end ;
106853: LD_VAR 0 4
106857: RET
// export function SOS_Command ( cmd ) ; begin
106858: LD_INT 0
106860: PPUSH
// end ;
106861: LD_VAR 0 2
106865: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106866: LD_INT 0
106868: PPUSH
// end ;
106869: LD_VAR 0 6
106873: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var i , driver , hex ; begin
106874: LD_INT 0
106876: PPUSH
106877: PPUSH
106878: PPUSH
106879: PPUSH
// if not vehicle or not factory then
106880: LD_VAR 0 1
106884: NOT
106885: PUSH
106886: LD_VAR 0 2
106890: NOT
106891: OR
106892: IFFALSE 106896
// exit ;
106894: GO 107476
// if not factoryWaypoints then
106896: LD_EXP 167
106900: NOT
106901: IFFALSE 106905
// exit ;
106903: GO 107476
// for i := 1 to Count ( factoryWaypoints ) do
106905: LD_ADDR_VAR 0 4
106909: PUSH
106910: DOUBLE
106911: LD_INT 1
106913: DEC
106914: ST_TO_ADDR
106915: LD_EXP 167
106919: PPUSH
106920: CALL 19462 0 1
106924: PUSH
106925: FOR_TO
106926: IFFALSE 107474
// if factoryWaypoints [ i ] [ 2 ] = factory then
106928: LD_EXP 167
106932: PUSH
106933: LD_VAR 0 4
106937: ARRAY
106938: PUSH
106939: LD_INT 2
106941: ARRAY
106942: PUSH
106943: LD_VAR 0 2
106947: EQUAL
106948: IFFALSE 107472
// begin if GetControl ( vehicle ) = control_manual then
106950: LD_VAR 0 1
106954: PPUSH
106955: CALL_OW 263
106959: PUSH
106960: LD_INT 1
106962: EQUAL
106963: IFFALSE 107325
// begin driver := IsDrivenBy ( vehicle ) ;
106965: LD_ADDR_VAR 0 5
106969: PUSH
106970: LD_VAR 0 1
106974: PPUSH
106975: CALL_OW 311
106979: ST_TO_ADDR
// if driver in factoryWaypointsDrivers or vehicle in factoryWaypointsDrivers then
106980: LD_VAR 0 5
106984: PUSH
106985: LD_EXP 168
106989: IN
106990: PUSH
106991: LD_VAR 0 1
106995: PUSH
106996: LD_EXP 168
107000: IN
107001: OR
107002: IFFALSE 107008
// exit ;
107004: POP
107005: POP
107006: GO 107476
// if not HasTask ( driver ) then
107008: LD_VAR 0 5
107012: PPUSH
107013: CALL_OW 314
107017: NOT
107018: IFFALSE 107323
// begin factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , driver ) ;
107020: LD_ADDR_EXP 168
107024: PUSH
107025: LD_EXP 168
107029: PPUSH
107030: LD_VAR 0 5
107034: PPUSH
107035: CALL 55071 0 2
107039: ST_TO_ADDR
// factoryWaypointsDrivers := Join ( factoryWaypointsDrivers , vehicle ) ;
107040: LD_ADDR_EXP 168
107044: PUSH
107045: LD_EXP 168
107049: PPUSH
107050: LD_VAR 0 1
107054: PPUSH
107055: CALL 55071 0 2
107059: ST_TO_ADDR
// hex := HexInfo ( factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107060: LD_ADDR_VAR 0 6
107064: PUSH
107065: LD_EXP 167
107069: PUSH
107070: LD_VAR 0 4
107074: ARRAY
107075: PUSH
107076: LD_INT 3
107078: ARRAY
107079: PPUSH
107080: LD_EXP 167
107084: PUSH
107085: LD_VAR 0 4
107089: ARRAY
107090: PUSH
107091: LD_INT 4
107093: ARRAY
107094: PPUSH
107095: CALL_OW 428
107099: ST_TO_ADDR
// if hex then
107100: LD_VAR 0 6
107104: IFFALSE 107122
// ComMoveUnit ( driver , hex ) else
107106: LD_VAR 0 5
107110: PPUSH
107111: LD_VAR 0 6
107115: PPUSH
107116: CALL_OW 112
107120: GO 107206
// if GetDistUnitXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) > 0 then
107122: LD_VAR 0 1
107126: PPUSH
107127: LD_EXP 167
107131: PUSH
107132: LD_VAR 0 4
107136: ARRAY
107137: PUSH
107138: LD_INT 3
107140: ARRAY
107141: PPUSH
107142: LD_EXP 167
107146: PUSH
107147: LD_VAR 0 4
107151: ARRAY
107152: PUSH
107153: LD_INT 4
107155: ARRAY
107156: PPUSH
107157: CALL_OW 297
107161: PUSH
107162: LD_INT 0
107164: GREATER
107165: IFFALSE 107206
// ComMoveXY ( driver , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107167: LD_VAR 0 5
107171: PPUSH
107172: LD_EXP 167
107176: PUSH
107177: LD_VAR 0 4
107181: ARRAY
107182: PUSH
107183: LD_INT 3
107185: ARRAY
107186: PPUSH
107187: LD_EXP 167
107191: PUSH
107192: LD_VAR 0 4
107196: ARRAY
107197: PUSH
107198: LD_INT 4
107200: ARRAY
107201: PPUSH
107202: CALL_OW 111
// AddComExitVehicle ( driver ) ;
107206: LD_VAR 0 5
107210: PPUSH
107211: CALL_OW 181
// if Multiplayer then
107215: LD_OWVAR 4
107219: IFFALSE 107268
// begin repeat wait ( 10 ) ;
107221: LD_INT 10
107223: PPUSH
107224: CALL_OW 67
// until not IsInUnit ( driver ) ;
107228: LD_VAR 0 5
107232: PPUSH
107233: CALL_OW 310
107237: NOT
107238: IFFALSE 107221
// if not HasTask ( driver ) then
107240: LD_VAR 0 5
107244: PPUSH
107245: CALL_OW 314
107249: NOT
107250: IFFALSE 107266
// ComEnterUnit ( driver , factory ) ;
107252: LD_VAR 0 5
107256: PPUSH
107257: LD_VAR 0 2
107261: PPUSH
107262: CALL_OW 120
// end else
107266: GO 107282
// AddComEnterUnit ( driver , factory ) ;
107268: LD_VAR 0 5
107272: PPUSH
107273: LD_VAR 0 2
107277: PPUSH
107278: CALL_OW 180
// wait ( 0 0$1 ) ;
107282: LD_INT 35
107284: PPUSH
107285: CALL_OW 67
// factoryWaypointsDrivers := factoryWaypointsDrivers diff driver ;
107289: LD_ADDR_EXP 168
107293: PUSH
107294: LD_EXP 168
107298: PUSH
107299: LD_VAR 0 5
107303: DIFF
107304: ST_TO_ADDR
// factoryWaypointsDrivers := factoryWaypointsDrivers diff vehicle ;
107305: LD_ADDR_EXP 168
107309: PUSH
107310: LD_EXP 168
107314: PUSH
107315: LD_VAR 0 1
107319: DIFF
107320: ST_TO_ADDR
// break ;
107321: GO 107474
// end ; end else
107323: GO 107472
// if GetControl ( vehicle ) = control_remote then
107325: LD_VAR 0 1
107329: PPUSH
107330: CALL_OW 263
107334: PUSH
107335: LD_INT 2
107337: EQUAL
107338: IFFALSE 107424
// begin wait ( 0 0$2 ) ;
107340: LD_INT 70
107342: PPUSH
107343: CALL_OW 67
// repeat wait ( 10 ) ;
107347: LD_INT 10
107349: PPUSH
107350: CALL_OW 67
// Connect ( vehicle ) ;
107354: LD_VAR 0 1
107358: PPUSH
107359: CALL 25668 0 1
// until IsControledBy ( vehicle ) ;
107363: LD_VAR 0 1
107367: PPUSH
107368: CALL_OW 312
107372: IFFALSE 107347
// wait ( 10 ) ;
107374: LD_INT 10
107376: PPUSH
107377: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107381: LD_VAR 0 1
107385: PPUSH
107386: LD_EXP 167
107390: PUSH
107391: LD_VAR 0 4
107395: ARRAY
107396: PUSH
107397: LD_INT 3
107399: ARRAY
107400: PPUSH
107401: LD_EXP 167
107405: PUSH
107406: LD_VAR 0 4
107410: ARRAY
107411: PUSH
107412: LD_INT 4
107414: ARRAY
107415: PPUSH
107416: CALL_OW 111
// break ;
107420: GO 107474
// end else
107422: GO 107472
// begin wait ( 0 0$3 ) ;
107424: LD_INT 105
107426: PPUSH
107427: CALL_OW 67
// ComMoveXY ( vehicle , factoryWaypoints [ i ] [ 3 ] , factoryWaypoints [ i ] [ 4 ] ) ;
107431: LD_VAR 0 1
107435: PPUSH
107436: LD_EXP 167
107440: PUSH
107441: LD_VAR 0 4
107445: ARRAY
107446: PUSH
107447: LD_INT 3
107449: ARRAY
107450: PPUSH
107451: LD_EXP 167
107455: PUSH
107456: LD_VAR 0 4
107460: ARRAY
107461: PUSH
107462: LD_INT 4
107464: ARRAY
107465: PPUSH
107466: CALL_OW 111
// break ;
107470: GO 107474
// end ; end ;
107472: GO 106925
107474: POP
107475: POP
// end ;
107476: LD_VAR 0 3
107480: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
107481: LD_INT 0
107483: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
107484: LD_VAR 0 1
107488: PUSH
107489: LD_INT 250
107491: EQUAL
107492: PUSH
107493: LD_VAR 0 2
107497: PPUSH
107498: CALL_OW 264
107502: PUSH
107503: LD_INT 81
107505: EQUAL
107506: AND
107507: IFFALSE 107528
// MinerPlaceMine ( unit , x , y ) ;
107509: LD_VAR 0 2
107513: PPUSH
107514: LD_VAR 0 4
107518: PPUSH
107519: LD_VAR 0 5
107523: PPUSH
107524: CALL 110620 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
107528: LD_VAR 0 1
107532: PUSH
107533: LD_INT 251
107535: EQUAL
107536: PUSH
107537: LD_VAR 0 2
107541: PPUSH
107542: CALL_OW 264
107546: PUSH
107547: LD_INT 81
107549: EQUAL
107550: AND
107551: IFFALSE 107572
// MinerDetonateMine ( unit , x , y ) ;
107553: LD_VAR 0 2
107557: PPUSH
107558: LD_VAR 0 4
107562: PPUSH
107563: LD_VAR 0 5
107567: PPUSH
107568: CALL 110895 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
107572: LD_VAR 0 1
107576: PUSH
107577: LD_INT 252
107579: EQUAL
107580: PUSH
107581: LD_VAR 0 2
107585: PPUSH
107586: CALL_OW 264
107590: PUSH
107591: LD_INT 81
107593: EQUAL
107594: AND
107595: IFFALSE 107616
// MinerCreateMinefield ( unit , x , y ) ;
107597: LD_VAR 0 2
107601: PPUSH
107602: LD_VAR 0 4
107606: PPUSH
107607: LD_VAR 0 5
107611: PPUSH
107612: CALL 111312 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
107616: LD_VAR 0 1
107620: PUSH
107621: LD_INT 253
107623: EQUAL
107624: PUSH
107625: LD_VAR 0 2
107629: PPUSH
107630: CALL_OW 257
107634: PUSH
107635: LD_INT 5
107637: EQUAL
107638: AND
107639: IFFALSE 107660
// ComBinocular ( unit , x , y ) ;
107641: LD_VAR 0 2
107645: PPUSH
107646: LD_VAR 0 4
107650: PPUSH
107651: LD_VAR 0 5
107655: PPUSH
107656: CALL 111681 0 3
// if selectedUnit then
107660: LD_VAR 0 3
107664: IFFALSE 107720
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107666: LD_VAR 0 1
107670: PUSH
107671: LD_INT 254
107673: EQUAL
107674: PUSH
107675: LD_VAR 0 2
107679: PPUSH
107680: CALL_OW 264
107684: PUSH
107685: LD_INT 99
107687: EQUAL
107688: AND
107689: PUSH
107690: LD_VAR 0 3
107694: PPUSH
107695: CALL_OW 263
107699: PUSH
107700: LD_INT 3
107702: EQUAL
107703: AND
107704: IFFALSE 107720
// HackDestroyVehicle ( unit , selectedUnit ) ;
107706: LD_VAR 0 2
107710: PPUSH
107711: LD_VAR 0 3
107715: PPUSH
107716: CALL 109984 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107720: LD_VAR 0 1
107724: PUSH
107725: LD_INT 255
107727: EQUAL
107728: PUSH
107729: LD_VAR 0 2
107733: PPUSH
107734: CALL_OW 264
107738: PUSH
107739: LD_INT 14
107741: PUSH
107742: LD_INT 53
107744: PUSH
107745: EMPTY
107746: LIST
107747: LIST
107748: IN
107749: AND
107750: PUSH
107751: LD_VAR 0 4
107755: PPUSH
107756: LD_VAR 0 5
107760: PPUSH
107761: CALL_OW 488
107765: AND
107766: IFFALSE 107790
// CutTreeXYR ( unit , x , y , 12 ) ;
107768: LD_VAR 0 2
107772: PPUSH
107773: LD_VAR 0 4
107777: PPUSH
107778: LD_VAR 0 5
107782: PPUSH
107783: LD_INT 12
107785: PPUSH
107786: CALL 107981 0 4
// if cmd = 256 then
107790: LD_VAR 0 1
107794: PUSH
107795: LD_INT 256
107797: EQUAL
107798: IFFALSE 107819
// SetFactoryWaypoint ( unit , x , y ) ;
107800: LD_VAR 0 2
107804: PPUSH
107805: LD_VAR 0 4
107809: PPUSH
107810: LD_VAR 0 5
107814: PPUSH
107815: CALL 105377 0 3
// if cmd = 257 then
107819: LD_VAR 0 1
107823: PUSH
107824: LD_INT 257
107826: EQUAL
107827: IFFALSE 107848
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107829: LD_VAR 0 2
107833: PPUSH
107834: LD_VAR 0 4
107838: PPUSH
107839: LD_VAR 0 5
107843: PPUSH
107844: CALL 105867 0 3
// if cmd = 258 then
107848: LD_VAR 0 1
107852: PUSH
107853: LD_INT 258
107855: EQUAL
107856: IFFALSE 107880
// BurnTreeXYR ( unit , x , y , 8 ) ;
107858: LD_VAR 0 2
107862: PPUSH
107863: LD_VAR 0 4
107867: PPUSH
107868: LD_VAR 0 5
107872: PPUSH
107873: LD_INT 8
107875: PPUSH
107876: CALL 108375 0 4
// end ;
107880: LD_VAR 0 6
107884: RET
// export function ComRadiation ( un ) ; var eff ; begin
107885: LD_INT 0
107887: PPUSH
107888: PPUSH
// if GetWeapon ( un ) <> ar_bio_bomb then
107889: LD_VAR 0 1
107893: PPUSH
107894: CALL_OW 264
107898: PUSH
107899: LD_INT 91
107901: NONEQUAL
107902: IFFALSE 107906
// exit ;
107904: GO 107976
// if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107906: LD_INT 68
107908: PPUSH
107909: LD_VAR 0 1
107913: PPUSH
107914: CALL_OW 255
107918: PPUSH
107919: CALL_OW 321
107923: PUSH
107924: LD_INT 2
107926: EQUAL
107927: IFFALSE 107939
// eff := 50 else
107929: LD_ADDR_VAR 0 3
107933: PUSH
107934: LD_INT 50
107936: ST_TO_ADDR
107937: GO 107947
// eff := 25 ;
107939: LD_ADDR_VAR 0 3
107943: PUSH
107944: LD_INT 25
107946: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107947: LD_VAR 0 1
107951: PPUSH
107952: CALL_OW 250
107956: PPUSH
107957: LD_VAR 0 1
107961: PPUSH
107962: CALL_OW 251
107966: PPUSH
107967: LD_VAR 0 3
107971: PPUSH
107972: CALL_OW 495
// end ;
107976: LD_VAR 0 2
107980: RET
// export function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107981: LD_INT 0
107983: PPUSH
107984: PPUSH
107985: PPUSH
107986: PPUSH
107987: PPUSH
107988: PPUSH
107989: PPUSH
107990: PPUSH
107991: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
107992: LD_VAR 0 1
107996: PPUSH
107997: CALL_OW 302
108001: NOT
108002: PUSH
108003: LD_VAR 0 2
108007: PPUSH
108008: LD_VAR 0 3
108012: PPUSH
108013: CALL_OW 488
108017: NOT
108018: OR
108019: PUSH
108020: LD_VAR 0 4
108024: NOT
108025: OR
108026: IFFALSE 108030
// exit ;
108028: GO 108370
// list := [ ] ;
108030: LD_ADDR_VAR 0 13
108034: PUSH
108035: EMPTY
108036: ST_TO_ADDR
// if x - r < 0 then
108037: LD_VAR 0 2
108041: PUSH
108042: LD_VAR 0 4
108046: MINUS
108047: PUSH
108048: LD_INT 0
108050: LESS
108051: IFFALSE 108063
// min_x := 0 else
108053: LD_ADDR_VAR 0 7
108057: PUSH
108058: LD_INT 0
108060: ST_TO_ADDR
108061: GO 108079
// min_x := x - r ;
108063: LD_ADDR_VAR 0 7
108067: PUSH
108068: LD_VAR 0 2
108072: PUSH
108073: LD_VAR 0 4
108077: MINUS
108078: ST_TO_ADDR
// if y - r < 0 then
108079: LD_VAR 0 3
108083: PUSH
108084: LD_VAR 0 4
108088: MINUS
108089: PUSH
108090: LD_INT 0
108092: LESS
108093: IFFALSE 108105
// min_y := 0 else
108095: LD_ADDR_VAR 0 8
108099: PUSH
108100: LD_INT 0
108102: ST_TO_ADDR
108103: GO 108121
// min_y := y - r ;
108105: LD_ADDR_VAR 0 8
108109: PUSH
108110: LD_VAR 0 3
108114: PUSH
108115: LD_VAR 0 4
108119: MINUS
108120: ST_TO_ADDR
// max_x := x + r ;
108121: LD_ADDR_VAR 0 9
108125: PUSH
108126: LD_VAR 0 2
108130: PUSH
108131: LD_VAR 0 4
108135: PLUS
108136: ST_TO_ADDR
// max_y := y + r ;
108137: LD_ADDR_VAR 0 10
108141: PUSH
108142: LD_VAR 0 3
108146: PUSH
108147: LD_VAR 0 4
108151: PLUS
108152: ST_TO_ADDR
// for _x = min_x to max_x do
108153: LD_ADDR_VAR 0 11
108157: PUSH
108158: DOUBLE
108159: LD_VAR 0 7
108163: DEC
108164: ST_TO_ADDR
108165: LD_VAR 0 9
108169: PUSH
108170: FOR_TO
108171: IFFALSE 108288
// for _y = min_y to max_y do
108173: LD_ADDR_VAR 0 12
108177: PUSH
108178: DOUBLE
108179: LD_VAR 0 8
108183: DEC
108184: ST_TO_ADDR
108185: LD_VAR 0 10
108189: PUSH
108190: FOR_TO
108191: IFFALSE 108284
// begin if not ValidHex ( _x , _y ) then
108193: LD_VAR 0 11
108197: PPUSH
108198: LD_VAR 0 12
108202: PPUSH
108203: CALL_OW 488
108207: NOT
108208: IFFALSE 108212
// continue ;
108210: GO 108190
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108212: LD_VAR 0 11
108216: PPUSH
108217: LD_VAR 0 12
108221: PPUSH
108222: CALL_OW 351
108226: PUSH
108227: LD_VAR 0 11
108231: PPUSH
108232: LD_VAR 0 12
108236: PPUSH
108237: CALL_OW 554
108241: AND
108242: IFFALSE 108282
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108244: LD_ADDR_VAR 0 13
108248: PUSH
108249: LD_VAR 0 13
108253: PPUSH
108254: LD_VAR 0 13
108258: PUSH
108259: LD_INT 1
108261: PLUS
108262: PPUSH
108263: LD_VAR 0 11
108267: PUSH
108268: LD_VAR 0 12
108272: PUSH
108273: EMPTY
108274: LIST
108275: LIST
108276: PPUSH
108277: CALL_OW 2
108281: ST_TO_ADDR
// end ;
108282: GO 108190
108284: POP
108285: POP
108286: GO 108170
108288: POP
108289: POP
// if not list then
108290: LD_VAR 0 13
108294: NOT
108295: IFFALSE 108299
// exit ;
108297: GO 108370
// for i in list do
108299: LD_ADDR_VAR 0 6
108303: PUSH
108304: LD_VAR 0 13
108308: PUSH
108309: FOR_IN
108310: IFFALSE 108368
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108312: LD_VAR 0 1
108316: PPUSH
108317: LD_STRING M
108319: PUSH
108320: LD_VAR 0 6
108324: PUSH
108325: LD_INT 1
108327: ARRAY
108328: PUSH
108329: LD_VAR 0 6
108333: PUSH
108334: LD_INT 2
108336: ARRAY
108337: PUSH
108338: LD_INT 0
108340: PUSH
108341: LD_INT 0
108343: PUSH
108344: LD_INT 0
108346: PUSH
108347: LD_INT 0
108349: PUSH
108350: EMPTY
108351: LIST
108352: LIST
108353: LIST
108354: LIST
108355: LIST
108356: LIST
108357: LIST
108358: PUSH
108359: EMPTY
108360: LIST
108361: PPUSH
108362: CALL_OW 447
108366: GO 108309
108368: POP
108369: POP
// end ;
108370: LD_VAR 0 5
108374: RET
// export function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
108375: LD_INT 0
108377: PPUSH
108378: PPUSH
108379: PPUSH
108380: PPUSH
108381: PPUSH
108382: PPUSH
108383: PPUSH
108384: PPUSH
108385: PPUSH
108386: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108387: LD_VAR 0 1
108391: PPUSH
108392: CALL_OW 302
108396: NOT
108397: PUSH
108398: LD_VAR 0 2
108402: PPUSH
108403: LD_VAR 0 3
108407: PPUSH
108408: CALL_OW 488
108412: NOT
108413: OR
108414: PUSH
108415: LD_VAR 0 4
108419: NOT
108420: OR
108421: IFFALSE 108425
// exit ;
108423: GO 108938
// list := [ ] ;
108425: LD_ADDR_VAR 0 13
108429: PUSH
108430: EMPTY
108431: ST_TO_ADDR
// if x - r < 0 then
108432: LD_VAR 0 2
108436: PUSH
108437: LD_VAR 0 4
108441: MINUS
108442: PUSH
108443: LD_INT 0
108445: LESS
108446: IFFALSE 108458
// min_x := 0 else
108448: LD_ADDR_VAR 0 7
108452: PUSH
108453: LD_INT 0
108455: ST_TO_ADDR
108456: GO 108474
// min_x := x - r ;
108458: LD_ADDR_VAR 0 7
108462: PUSH
108463: LD_VAR 0 2
108467: PUSH
108468: LD_VAR 0 4
108472: MINUS
108473: ST_TO_ADDR
// if y - r < 0 then
108474: LD_VAR 0 3
108478: PUSH
108479: LD_VAR 0 4
108483: MINUS
108484: PUSH
108485: LD_INT 0
108487: LESS
108488: IFFALSE 108500
// min_y := 0 else
108490: LD_ADDR_VAR 0 8
108494: PUSH
108495: LD_INT 0
108497: ST_TO_ADDR
108498: GO 108516
// min_y := y - r ;
108500: LD_ADDR_VAR 0 8
108504: PUSH
108505: LD_VAR 0 3
108509: PUSH
108510: LD_VAR 0 4
108514: MINUS
108515: ST_TO_ADDR
// max_x := x + r ;
108516: LD_ADDR_VAR 0 9
108520: PUSH
108521: LD_VAR 0 2
108525: PUSH
108526: LD_VAR 0 4
108530: PLUS
108531: ST_TO_ADDR
// max_y := y + r ;
108532: LD_ADDR_VAR 0 10
108536: PUSH
108537: LD_VAR 0 3
108541: PUSH
108542: LD_VAR 0 4
108546: PLUS
108547: ST_TO_ADDR
// for _x = min_x to max_x do
108548: LD_ADDR_VAR 0 11
108552: PUSH
108553: DOUBLE
108554: LD_VAR 0 7
108558: DEC
108559: ST_TO_ADDR
108560: LD_VAR 0 9
108564: PUSH
108565: FOR_TO
108566: IFFALSE 108683
// for _y = min_y to max_y do
108568: LD_ADDR_VAR 0 12
108572: PUSH
108573: DOUBLE
108574: LD_VAR 0 8
108578: DEC
108579: ST_TO_ADDR
108580: LD_VAR 0 10
108584: PUSH
108585: FOR_TO
108586: IFFALSE 108679
// begin if not ValidHex ( _x , _y ) then
108588: LD_VAR 0 11
108592: PPUSH
108593: LD_VAR 0 12
108597: PPUSH
108598: CALL_OW 488
108602: NOT
108603: IFFALSE 108607
// continue ;
108605: GO 108585
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108607: LD_VAR 0 11
108611: PPUSH
108612: LD_VAR 0 12
108616: PPUSH
108617: CALL_OW 351
108621: PUSH
108622: LD_VAR 0 11
108626: PPUSH
108627: LD_VAR 0 12
108631: PPUSH
108632: CALL_OW 554
108636: AND
108637: IFFALSE 108677
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108639: LD_ADDR_VAR 0 13
108643: PUSH
108644: LD_VAR 0 13
108648: PPUSH
108649: LD_VAR 0 13
108653: PUSH
108654: LD_INT 1
108656: PLUS
108657: PPUSH
108658: LD_VAR 0 11
108662: PUSH
108663: LD_VAR 0 12
108667: PUSH
108668: EMPTY
108669: LIST
108670: LIST
108671: PPUSH
108672: CALL_OW 2
108676: ST_TO_ADDR
// end ;
108677: GO 108585
108679: POP
108680: POP
108681: GO 108565
108683: POP
108684: POP
// if not list then
108685: LD_VAR 0 13
108689: NOT
108690: IFFALSE 108694
// exit ;
108692: GO 108938
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
108694: LD_ADDR_VAR 0 13
108698: PUSH
108699: LD_VAR 0 1
108703: PPUSH
108704: LD_VAR 0 13
108708: PPUSH
108709: LD_INT 1
108711: PPUSH
108712: LD_INT 1
108714: PPUSH
108715: CALL 22810 0 4
108719: ST_TO_ADDR
// ComStop ( flame ) ;
108720: LD_VAR 0 1
108724: PPUSH
108725: CALL_OW 141
// for i in list do
108729: LD_ADDR_VAR 0 6
108733: PUSH
108734: LD_VAR 0 13
108738: PUSH
108739: FOR_IN
108740: IFFALSE 108771
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
108742: LD_VAR 0 1
108746: PPUSH
108747: LD_VAR 0 6
108751: PUSH
108752: LD_INT 1
108754: ARRAY
108755: PPUSH
108756: LD_VAR 0 6
108760: PUSH
108761: LD_INT 2
108763: ARRAY
108764: PPUSH
108765: CALL_OW 176
108769: GO 108739
108771: POP
108772: POP
// repeat wait ( 0 0$1 ) ;
108773: LD_INT 35
108775: PPUSH
108776: CALL_OW 67
// task := GetTaskList ( flame ) ;
108780: LD_ADDR_VAR 0 14
108784: PUSH
108785: LD_VAR 0 1
108789: PPUSH
108790: CALL_OW 437
108794: ST_TO_ADDR
// if not task then
108795: LD_VAR 0 14
108799: NOT
108800: IFFALSE 108804
// exit ;
108802: GO 108938
// if task [ 1 ] [ 1 ] <> | then
108804: LD_VAR 0 14
108808: PUSH
108809: LD_INT 1
108811: ARRAY
108812: PUSH
108813: LD_INT 1
108815: ARRAY
108816: PUSH
108817: LD_STRING |
108819: NONEQUAL
108820: IFFALSE 108824
// exit ;
108822: GO 108938
// _x := task [ 1 ] [ 2 ] ;
108824: LD_ADDR_VAR 0 11
108828: PUSH
108829: LD_VAR 0 14
108833: PUSH
108834: LD_INT 1
108836: ARRAY
108837: PUSH
108838: LD_INT 2
108840: ARRAY
108841: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
108842: LD_ADDR_VAR 0 12
108846: PUSH
108847: LD_VAR 0 14
108851: PUSH
108852: LD_INT 1
108854: ARRAY
108855: PUSH
108856: LD_INT 3
108858: ARRAY
108859: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
108860: LD_VAR 0 11
108864: PPUSH
108865: LD_VAR 0 12
108869: PPUSH
108870: CALL_OW 351
108874: NOT
108875: PUSH
108876: LD_VAR 0 11
108880: PPUSH
108881: LD_VAR 0 12
108885: PPUSH
108886: CALL_OW 554
108890: NOT
108891: OR
108892: IFFALSE 108926
// begin task := Delete ( task , 1 ) ;
108894: LD_ADDR_VAR 0 14
108898: PUSH
108899: LD_VAR 0 14
108903: PPUSH
108904: LD_INT 1
108906: PPUSH
108907: CALL_OW 3
108911: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
108912: LD_VAR 0 1
108916: PPUSH
108917: LD_VAR 0 14
108921: PPUSH
108922: CALL_OW 446
// end ; until not HasTask ( flame ) ;
108926: LD_VAR 0 1
108930: PPUSH
108931: CALL_OW 314
108935: NOT
108936: IFFALSE 108773
// end ;
108938: LD_VAR 0 5
108942: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
108943: LD_EXP 171
108947: NOT
108948: IFFALSE 108998
108950: GO 108952
108952: DISABLE
// begin initHack := true ;
108953: LD_ADDR_EXP 171
108957: PUSH
108958: LD_INT 1
108960: ST_TO_ADDR
// hackTanks := [ ] ;
108961: LD_ADDR_EXP 172
108965: PUSH
108966: EMPTY
108967: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
108968: LD_ADDR_EXP 173
108972: PUSH
108973: EMPTY
108974: ST_TO_ADDR
// hackLimit := 3 ;
108975: LD_ADDR_EXP 174
108979: PUSH
108980: LD_INT 3
108982: ST_TO_ADDR
// hackDist := 12 ;
108983: LD_ADDR_EXP 175
108987: PUSH
108988: LD_INT 12
108990: ST_TO_ADDR
// hackCounter := [ ] ;
108991: LD_ADDR_EXP 176
108995: PUSH
108996: EMPTY
108997: ST_TO_ADDR
// end ;
108998: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
108999: LD_EXP 171
109003: PUSH
109004: LD_INT 34
109006: PUSH
109007: LD_INT 99
109009: PUSH
109010: EMPTY
109011: LIST
109012: LIST
109013: PPUSH
109014: CALL_OW 69
109018: AND
109019: IFFALSE 109272
109021: GO 109023
109023: DISABLE
109024: LD_INT 0
109026: PPUSH
109027: PPUSH
// begin enable ;
109028: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109029: LD_ADDR_VAR 0 1
109033: PUSH
109034: LD_INT 34
109036: PUSH
109037: LD_INT 99
109039: PUSH
109040: EMPTY
109041: LIST
109042: LIST
109043: PPUSH
109044: CALL_OW 69
109048: PUSH
109049: FOR_IN
109050: IFFALSE 109270
// begin if not i in hackTanks then
109052: LD_VAR 0 1
109056: PUSH
109057: LD_EXP 172
109061: IN
109062: NOT
109063: IFFALSE 109146
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109065: LD_ADDR_EXP 172
109069: PUSH
109070: LD_EXP 172
109074: PPUSH
109075: LD_EXP 172
109079: PUSH
109080: LD_INT 1
109082: PLUS
109083: PPUSH
109084: LD_VAR 0 1
109088: PPUSH
109089: CALL_OW 1
109093: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109094: LD_ADDR_EXP 173
109098: PUSH
109099: LD_EXP 173
109103: PPUSH
109104: LD_EXP 173
109108: PUSH
109109: LD_INT 1
109111: PLUS
109112: PPUSH
109113: EMPTY
109114: PPUSH
109115: CALL_OW 1
109119: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109120: LD_ADDR_EXP 176
109124: PUSH
109125: LD_EXP 176
109129: PPUSH
109130: LD_EXP 176
109134: PUSH
109135: LD_INT 1
109137: PLUS
109138: PPUSH
109139: EMPTY
109140: PPUSH
109141: CALL_OW 1
109145: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109146: LD_VAR 0 1
109150: PPUSH
109151: CALL_OW 302
109155: NOT
109156: IFFALSE 109169
// begin HackUnlinkAll ( i ) ;
109158: LD_VAR 0 1
109162: PPUSH
109163: CALL 109275 0 1
// continue ;
109167: GO 109049
// end ; HackCheckCapturedStatus ( i ) ;
109169: LD_VAR 0 1
109173: PPUSH
109174: CALL 109718 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109178: LD_ADDR_VAR 0 2
109182: PUSH
109183: LD_INT 81
109185: PUSH
109186: LD_VAR 0 1
109190: PPUSH
109191: CALL_OW 255
109195: PUSH
109196: EMPTY
109197: LIST
109198: LIST
109199: PUSH
109200: LD_INT 33
109202: PUSH
109203: LD_INT 3
109205: PUSH
109206: EMPTY
109207: LIST
109208: LIST
109209: PUSH
109210: LD_INT 91
109212: PUSH
109213: LD_VAR 0 1
109217: PUSH
109218: LD_EXP 175
109222: PUSH
109223: EMPTY
109224: LIST
109225: LIST
109226: LIST
109227: PUSH
109228: LD_INT 50
109230: PUSH
109231: EMPTY
109232: LIST
109233: PUSH
109234: EMPTY
109235: LIST
109236: LIST
109237: LIST
109238: LIST
109239: PPUSH
109240: CALL_OW 69
109244: ST_TO_ADDR
// if not tmp then
109245: LD_VAR 0 2
109249: NOT
109250: IFFALSE 109254
// continue ;
109252: GO 109049
// HackLink ( i , tmp ) ;
109254: LD_VAR 0 1
109258: PPUSH
109259: LD_VAR 0 2
109263: PPUSH
109264: CALL 109411 0 2
// end ;
109268: GO 109049
109270: POP
109271: POP
// end ;
109272: PPOPN 2
109274: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109275: LD_INT 0
109277: PPUSH
109278: PPUSH
109279: PPUSH
// if not hack in hackTanks then
109280: LD_VAR 0 1
109284: PUSH
109285: LD_EXP 172
109289: IN
109290: NOT
109291: IFFALSE 109295
// exit ;
109293: GO 109406
// index := GetElementIndex ( hackTanks , hack ) ;
109295: LD_ADDR_VAR 0 4
109299: PUSH
109300: LD_EXP 172
109304: PPUSH
109305: LD_VAR 0 1
109309: PPUSH
109310: CALL 22107 0 2
109314: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109315: LD_EXP 173
109319: PUSH
109320: LD_VAR 0 4
109324: ARRAY
109325: IFFALSE 109406
// begin for i in hackTanksCaptured [ index ] do
109327: LD_ADDR_VAR 0 3
109331: PUSH
109332: LD_EXP 173
109336: PUSH
109337: LD_VAR 0 4
109341: ARRAY
109342: PUSH
109343: FOR_IN
109344: IFFALSE 109370
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109346: LD_VAR 0 3
109350: PUSH
109351: LD_INT 1
109353: ARRAY
109354: PPUSH
109355: LD_VAR 0 3
109359: PUSH
109360: LD_INT 2
109362: ARRAY
109363: PPUSH
109364: CALL_OW 235
109368: GO 109343
109370: POP
109371: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109372: LD_ADDR_EXP 173
109376: PUSH
109377: LD_EXP 173
109381: PPUSH
109382: LD_VAR 0 4
109386: PPUSH
109387: EMPTY
109388: PPUSH
109389: CALL_OW 1
109393: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109394: LD_VAR 0 1
109398: PPUSH
109399: LD_INT 0
109401: PPUSH
109402: CALL_OW 505
// end ; end ;
109406: LD_VAR 0 2
109410: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109411: LD_INT 0
109413: PPUSH
109414: PPUSH
109415: PPUSH
// if not hack in hackTanks or not vehicles then
109416: LD_VAR 0 1
109420: PUSH
109421: LD_EXP 172
109425: IN
109426: NOT
109427: PUSH
109428: LD_VAR 0 2
109432: NOT
109433: OR
109434: IFFALSE 109438
// exit ;
109436: GO 109713
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
109438: LD_ADDR_VAR 0 2
109442: PUSH
109443: LD_VAR 0 1
109447: PPUSH
109448: LD_VAR 0 2
109452: PPUSH
109453: LD_INT 1
109455: PPUSH
109456: LD_INT 1
109458: PPUSH
109459: CALL 22757 0 4
109463: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
109464: LD_ADDR_VAR 0 5
109468: PUSH
109469: LD_EXP 172
109473: PPUSH
109474: LD_VAR 0 1
109478: PPUSH
109479: CALL 22107 0 2
109483: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
109484: LD_EXP 173
109488: PUSH
109489: LD_VAR 0 5
109493: ARRAY
109494: PUSH
109495: LD_EXP 174
109499: LESS
109500: IFFALSE 109689
// begin for i := 1 to vehicles do
109502: LD_ADDR_VAR 0 4
109506: PUSH
109507: DOUBLE
109508: LD_INT 1
109510: DEC
109511: ST_TO_ADDR
109512: LD_VAR 0 2
109516: PUSH
109517: FOR_TO
109518: IFFALSE 109687
// begin if hackTanksCaptured [ index ] = hackLimit then
109520: LD_EXP 173
109524: PUSH
109525: LD_VAR 0 5
109529: ARRAY
109530: PUSH
109531: LD_EXP 174
109535: EQUAL
109536: IFFALSE 109540
// break ;
109538: GO 109687
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
109540: LD_ADDR_EXP 176
109544: PUSH
109545: LD_EXP 176
109549: PPUSH
109550: LD_VAR 0 5
109554: PPUSH
109555: LD_EXP 176
109559: PUSH
109560: LD_VAR 0 5
109564: ARRAY
109565: PUSH
109566: LD_INT 1
109568: PLUS
109569: PPUSH
109570: CALL_OW 1
109574: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
109575: LD_ADDR_EXP 173
109579: PUSH
109580: LD_EXP 173
109584: PPUSH
109585: LD_VAR 0 5
109589: PUSH
109590: LD_EXP 173
109594: PUSH
109595: LD_VAR 0 5
109599: ARRAY
109600: PUSH
109601: LD_INT 1
109603: PLUS
109604: PUSH
109605: EMPTY
109606: LIST
109607: LIST
109608: PPUSH
109609: LD_VAR 0 2
109613: PUSH
109614: LD_VAR 0 4
109618: ARRAY
109619: PUSH
109620: LD_VAR 0 2
109624: PUSH
109625: LD_VAR 0 4
109629: ARRAY
109630: PPUSH
109631: CALL_OW 255
109635: PUSH
109636: EMPTY
109637: LIST
109638: LIST
109639: PPUSH
109640: CALL 22322 0 3
109644: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
109645: LD_VAR 0 2
109649: PUSH
109650: LD_VAR 0 4
109654: ARRAY
109655: PPUSH
109656: LD_VAR 0 1
109660: PPUSH
109661: CALL_OW 255
109665: PPUSH
109666: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
109670: LD_VAR 0 2
109674: PUSH
109675: LD_VAR 0 4
109679: ARRAY
109680: PPUSH
109681: CALL_OW 141
// end ;
109685: GO 109517
109687: POP
109688: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109689: LD_VAR 0 1
109693: PPUSH
109694: LD_EXP 173
109698: PUSH
109699: LD_VAR 0 5
109703: ARRAY
109704: PUSH
109705: LD_INT 0
109707: PLUS
109708: PPUSH
109709: CALL_OW 505
// end ;
109713: LD_VAR 0 3
109717: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
109718: LD_INT 0
109720: PPUSH
109721: PPUSH
109722: PPUSH
109723: PPUSH
// if not hack in hackTanks then
109724: LD_VAR 0 1
109728: PUSH
109729: LD_EXP 172
109733: IN
109734: NOT
109735: IFFALSE 109739
// exit ;
109737: GO 109979
// index := GetElementIndex ( hackTanks , hack ) ;
109739: LD_ADDR_VAR 0 4
109743: PUSH
109744: LD_EXP 172
109748: PPUSH
109749: LD_VAR 0 1
109753: PPUSH
109754: CALL 22107 0 2
109758: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
109759: LD_ADDR_VAR 0 3
109763: PUSH
109764: DOUBLE
109765: LD_EXP 173
109769: PUSH
109770: LD_VAR 0 4
109774: ARRAY
109775: INC
109776: ST_TO_ADDR
109777: LD_INT 1
109779: PUSH
109780: FOR_DOWNTO
109781: IFFALSE 109953
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
109783: LD_ADDR_VAR 0 5
109787: PUSH
109788: LD_EXP 173
109792: PUSH
109793: LD_VAR 0 4
109797: ARRAY
109798: PUSH
109799: LD_VAR 0 3
109803: ARRAY
109804: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
109805: LD_VAR 0 5
109809: PUSH
109810: LD_INT 1
109812: ARRAY
109813: PPUSH
109814: CALL_OW 302
109818: NOT
109819: PUSH
109820: LD_VAR 0 5
109824: PUSH
109825: LD_INT 1
109827: ARRAY
109828: PPUSH
109829: CALL_OW 255
109833: PUSH
109834: LD_VAR 0 1
109838: PPUSH
109839: CALL_OW 255
109843: NONEQUAL
109844: OR
109845: IFFALSE 109951
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
109847: LD_VAR 0 5
109851: PUSH
109852: LD_INT 1
109854: ARRAY
109855: PPUSH
109856: CALL_OW 305
109860: PUSH
109861: LD_VAR 0 5
109865: PUSH
109866: LD_INT 1
109868: ARRAY
109869: PPUSH
109870: CALL_OW 255
109874: PUSH
109875: LD_VAR 0 1
109879: PPUSH
109880: CALL_OW 255
109884: EQUAL
109885: AND
109886: IFFALSE 109910
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
109888: LD_VAR 0 5
109892: PUSH
109893: LD_INT 1
109895: ARRAY
109896: PPUSH
109897: LD_VAR 0 5
109901: PUSH
109902: LD_INT 2
109904: ARRAY
109905: PPUSH
109906: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
109910: LD_ADDR_EXP 173
109914: PUSH
109915: LD_EXP 173
109919: PPUSH
109920: LD_VAR 0 4
109924: PPUSH
109925: LD_EXP 173
109929: PUSH
109930: LD_VAR 0 4
109934: ARRAY
109935: PPUSH
109936: LD_VAR 0 3
109940: PPUSH
109941: CALL_OW 3
109945: PPUSH
109946: CALL_OW 1
109950: ST_TO_ADDR
// end ; end ;
109951: GO 109780
109953: POP
109954: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
109955: LD_VAR 0 1
109959: PPUSH
109960: LD_EXP 173
109964: PUSH
109965: LD_VAR 0 4
109969: ARRAY
109970: PUSH
109971: LD_INT 0
109973: PLUS
109974: PPUSH
109975: CALL_OW 505
// end ;
109979: LD_VAR 0 2
109983: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
109984: LD_INT 0
109986: PPUSH
109987: PPUSH
109988: PPUSH
109989: PPUSH
// if not hack in hackTanks then
109990: LD_VAR 0 1
109994: PUSH
109995: LD_EXP 172
109999: IN
110000: NOT
110001: IFFALSE 110005
// exit ;
110003: GO 110090
// index := GetElementIndex ( hackTanks , hack ) ;
110005: LD_ADDR_VAR 0 5
110009: PUSH
110010: LD_EXP 172
110014: PPUSH
110015: LD_VAR 0 1
110019: PPUSH
110020: CALL 22107 0 2
110024: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110025: LD_ADDR_VAR 0 4
110029: PUSH
110030: DOUBLE
110031: LD_INT 1
110033: DEC
110034: ST_TO_ADDR
110035: LD_EXP 173
110039: PUSH
110040: LD_VAR 0 5
110044: ARRAY
110045: PUSH
110046: FOR_TO
110047: IFFALSE 110088
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110049: LD_EXP 173
110053: PUSH
110054: LD_VAR 0 5
110058: ARRAY
110059: PUSH
110060: LD_VAR 0 4
110064: ARRAY
110065: PUSH
110066: LD_INT 1
110068: ARRAY
110069: PUSH
110070: LD_VAR 0 2
110074: EQUAL
110075: IFFALSE 110086
// KillUnit ( vehicle ) ;
110077: LD_VAR 0 2
110081: PPUSH
110082: CALL_OW 66
110086: GO 110046
110088: POP
110089: POP
// end ;
110090: LD_VAR 0 3
110094: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110095: LD_EXP 177
110099: NOT
110100: IFFALSE 110135
110102: GO 110104
110104: DISABLE
// begin initMiner := true ;
110105: LD_ADDR_EXP 177
110109: PUSH
110110: LD_INT 1
110112: ST_TO_ADDR
// minersList := [ ] ;
110113: LD_ADDR_EXP 178
110117: PUSH
110118: EMPTY
110119: ST_TO_ADDR
// minerMinesList := [ ] ;
110120: LD_ADDR_EXP 179
110124: PUSH
110125: EMPTY
110126: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110127: LD_ADDR_EXP 180
110131: PUSH
110132: LD_INT 5
110134: ST_TO_ADDR
// end ;
110135: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110136: LD_EXP 177
110140: PUSH
110141: LD_INT 34
110143: PUSH
110144: LD_INT 81
110146: PUSH
110147: EMPTY
110148: LIST
110149: LIST
110150: PPUSH
110151: CALL_OW 69
110155: AND
110156: IFFALSE 110617
110158: GO 110160
110160: DISABLE
110161: LD_INT 0
110163: PPUSH
110164: PPUSH
110165: PPUSH
110166: PPUSH
// begin enable ;
110167: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110168: LD_ADDR_VAR 0 1
110172: PUSH
110173: LD_INT 34
110175: PUSH
110176: LD_INT 81
110178: PUSH
110179: EMPTY
110180: LIST
110181: LIST
110182: PPUSH
110183: CALL_OW 69
110187: PUSH
110188: FOR_IN
110189: IFFALSE 110261
// begin if not i in minersList then
110191: LD_VAR 0 1
110195: PUSH
110196: LD_EXP 178
110200: IN
110201: NOT
110202: IFFALSE 110259
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110204: LD_ADDR_EXP 178
110208: PUSH
110209: LD_EXP 178
110213: PPUSH
110214: LD_EXP 178
110218: PUSH
110219: LD_INT 1
110221: PLUS
110222: PPUSH
110223: LD_VAR 0 1
110227: PPUSH
110228: CALL_OW 1
110232: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110233: LD_ADDR_EXP 179
110237: PUSH
110238: LD_EXP 179
110242: PPUSH
110243: LD_EXP 179
110247: PUSH
110248: LD_INT 1
110250: PLUS
110251: PPUSH
110252: EMPTY
110253: PPUSH
110254: CALL_OW 1
110258: ST_TO_ADDR
// end end ;
110259: GO 110188
110261: POP
110262: POP
// for i := minerMinesList downto 1 do
110263: LD_ADDR_VAR 0 1
110267: PUSH
110268: DOUBLE
110269: LD_EXP 179
110273: INC
110274: ST_TO_ADDR
110275: LD_INT 1
110277: PUSH
110278: FOR_DOWNTO
110279: IFFALSE 110615
// begin if IsLive ( minersList [ i ] ) then
110281: LD_EXP 178
110285: PUSH
110286: LD_VAR 0 1
110290: ARRAY
110291: PPUSH
110292: CALL_OW 300
110296: IFFALSE 110324
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110298: LD_EXP 178
110302: PUSH
110303: LD_VAR 0 1
110307: ARRAY
110308: PPUSH
110309: LD_EXP 179
110313: PUSH
110314: LD_VAR 0 1
110318: ARRAY
110319: PPUSH
110320: CALL_OW 505
// if not minerMinesList [ i ] then
110324: LD_EXP 179
110328: PUSH
110329: LD_VAR 0 1
110333: ARRAY
110334: NOT
110335: IFFALSE 110339
// continue ;
110337: GO 110278
// for j := minerMinesList [ i ] downto 1 do
110339: LD_ADDR_VAR 0 2
110343: PUSH
110344: DOUBLE
110345: LD_EXP 179
110349: PUSH
110350: LD_VAR 0 1
110354: ARRAY
110355: INC
110356: ST_TO_ADDR
110357: LD_INT 1
110359: PUSH
110360: FOR_DOWNTO
110361: IFFALSE 110611
// begin side := GetSide ( minersList [ i ] ) ;
110363: LD_ADDR_VAR 0 3
110367: PUSH
110368: LD_EXP 178
110372: PUSH
110373: LD_VAR 0 1
110377: ARRAY
110378: PPUSH
110379: CALL_OW 255
110383: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110384: LD_ADDR_VAR 0 4
110388: PUSH
110389: LD_EXP 179
110393: PUSH
110394: LD_VAR 0 1
110398: ARRAY
110399: PUSH
110400: LD_VAR 0 2
110404: ARRAY
110405: PUSH
110406: LD_INT 1
110408: ARRAY
110409: PPUSH
110410: LD_EXP 179
110414: PUSH
110415: LD_VAR 0 1
110419: ARRAY
110420: PUSH
110421: LD_VAR 0 2
110425: ARRAY
110426: PUSH
110427: LD_INT 2
110429: ARRAY
110430: PPUSH
110431: CALL_OW 428
110435: ST_TO_ADDR
// if not tmp then
110436: LD_VAR 0 4
110440: NOT
110441: IFFALSE 110445
// continue ;
110443: GO 110360
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
110445: LD_VAR 0 4
110449: PUSH
110450: LD_INT 81
110452: PUSH
110453: LD_VAR 0 3
110457: PUSH
110458: EMPTY
110459: LIST
110460: LIST
110461: PPUSH
110462: CALL_OW 69
110466: IN
110467: PUSH
110468: LD_EXP 179
110472: PUSH
110473: LD_VAR 0 1
110477: ARRAY
110478: PUSH
110479: LD_VAR 0 2
110483: ARRAY
110484: PUSH
110485: LD_INT 1
110487: ARRAY
110488: PPUSH
110489: LD_EXP 179
110493: PUSH
110494: LD_VAR 0 1
110498: ARRAY
110499: PUSH
110500: LD_VAR 0 2
110504: ARRAY
110505: PUSH
110506: LD_INT 2
110508: ARRAY
110509: PPUSH
110510: CALL_OW 458
110514: AND
110515: IFFALSE 110609
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
110517: LD_EXP 179
110521: PUSH
110522: LD_VAR 0 1
110526: ARRAY
110527: PUSH
110528: LD_VAR 0 2
110532: ARRAY
110533: PUSH
110534: LD_INT 1
110536: ARRAY
110537: PPUSH
110538: LD_EXP 179
110542: PUSH
110543: LD_VAR 0 1
110547: ARRAY
110548: PUSH
110549: LD_VAR 0 2
110553: ARRAY
110554: PUSH
110555: LD_INT 2
110557: ARRAY
110558: PPUSH
110559: LD_VAR 0 3
110563: PPUSH
110564: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
110568: LD_ADDR_EXP 179
110572: PUSH
110573: LD_EXP 179
110577: PPUSH
110578: LD_VAR 0 1
110582: PPUSH
110583: LD_EXP 179
110587: PUSH
110588: LD_VAR 0 1
110592: ARRAY
110593: PPUSH
110594: LD_VAR 0 2
110598: PPUSH
110599: CALL_OW 3
110603: PPUSH
110604: CALL_OW 1
110608: ST_TO_ADDR
// end ; end ;
110609: GO 110360
110611: POP
110612: POP
// end ;
110613: GO 110278
110615: POP
110616: POP
// end ;
110617: PPOPN 4
110619: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
110620: LD_INT 0
110622: PPUSH
110623: PPUSH
// result := false ;
110624: LD_ADDR_VAR 0 4
110628: PUSH
110629: LD_INT 0
110631: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
110632: LD_VAR 0 1
110636: PPUSH
110637: CALL_OW 264
110641: PUSH
110642: LD_INT 81
110644: EQUAL
110645: NOT
110646: IFFALSE 110650
// exit ;
110648: GO 110890
// index := GetElementIndex ( minersList , unit ) ;
110650: LD_ADDR_VAR 0 5
110654: PUSH
110655: LD_EXP 178
110659: PPUSH
110660: LD_VAR 0 1
110664: PPUSH
110665: CALL 22107 0 2
110669: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
110670: LD_EXP 179
110674: PUSH
110675: LD_VAR 0 5
110679: ARRAY
110680: PUSH
110681: LD_EXP 180
110685: GREATEREQUAL
110686: IFFALSE 110690
// exit ;
110688: GO 110890
// ComMoveXY ( unit , x , y ) ;
110690: LD_VAR 0 1
110694: PPUSH
110695: LD_VAR 0 2
110699: PPUSH
110700: LD_VAR 0 3
110704: PPUSH
110705: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110709: LD_INT 35
110711: PPUSH
110712: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
110716: LD_VAR 0 1
110720: PPUSH
110721: LD_VAR 0 2
110725: PPUSH
110726: LD_VAR 0 3
110730: PPUSH
110731: CALL 53868 0 3
110735: NOT
110736: PUSH
110737: LD_VAR 0 1
110741: PPUSH
110742: CALL_OW 314
110746: AND
110747: IFFALSE 110751
// exit ;
110749: GO 110890
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
110751: LD_VAR 0 2
110755: PPUSH
110756: LD_VAR 0 3
110760: PPUSH
110761: CALL_OW 428
110765: PUSH
110766: LD_VAR 0 1
110770: EQUAL
110771: PUSH
110772: LD_VAR 0 1
110776: PPUSH
110777: CALL_OW 314
110781: NOT
110782: AND
110783: IFFALSE 110709
// PlaySoundXY ( x , y , PlantMine ) ;
110785: LD_VAR 0 2
110789: PPUSH
110790: LD_VAR 0 3
110794: PPUSH
110795: LD_STRING PlantMine
110797: PPUSH
110798: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
110802: LD_VAR 0 2
110806: PPUSH
110807: LD_VAR 0 3
110811: PPUSH
110812: LD_VAR 0 1
110816: PPUSH
110817: CALL_OW 255
110821: PPUSH
110822: LD_INT 0
110824: PPUSH
110825: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
110829: LD_ADDR_EXP 179
110833: PUSH
110834: LD_EXP 179
110838: PPUSH
110839: LD_VAR 0 5
110843: PUSH
110844: LD_EXP 179
110848: PUSH
110849: LD_VAR 0 5
110853: ARRAY
110854: PUSH
110855: LD_INT 1
110857: PLUS
110858: PUSH
110859: EMPTY
110860: LIST
110861: LIST
110862: PPUSH
110863: LD_VAR 0 2
110867: PUSH
110868: LD_VAR 0 3
110872: PUSH
110873: EMPTY
110874: LIST
110875: LIST
110876: PPUSH
110877: CALL 22322 0 3
110881: ST_TO_ADDR
// result := true ;
110882: LD_ADDR_VAR 0 4
110886: PUSH
110887: LD_INT 1
110889: ST_TO_ADDR
// end ;
110890: LD_VAR 0 4
110894: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
110895: LD_INT 0
110897: PPUSH
110898: PPUSH
110899: PPUSH
// if not unit in minersList then
110900: LD_VAR 0 1
110904: PUSH
110905: LD_EXP 178
110909: IN
110910: NOT
110911: IFFALSE 110915
// exit ;
110913: GO 111307
// index := GetElementIndex ( minersList , unit ) ;
110915: LD_ADDR_VAR 0 6
110919: PUSH
110920: LD_EXP 178
110924: PPUSH
110925: LD_VAR 0 1
110929: PPUSH
110930: CALL 22107 0 2
110934: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
110935: LD_ADDR_VAR 0 5
110939: PUSH
110940: DOUBLE
110941: LD_EXP 179
110945: PUSH
110946: LD_VAR 0 6
110950: ARRAY
110951: INC
110952: ST_TO_ADDR
110953: LD_INT 1
110955: PUSH
110956: FOR_DOWNTO
110957: IFFALSE 111118
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
110959: LD_EXP 179
110963: PUSH
110964: LD_VAR 0 6
110968: ARRAY
110969: PUSH
110970: LD_VAR 0 5
110974: ARRAY
110975: PUSH
110976: LD_INT 1
110978: ARRAY
110979: PUSH
110980: LD_VAR 0 2
110984: EQUAL
110985: PUSH
110986: LD_EXP 179
110990: PUSH
110991: LD_VAR 0 6
110995: ARRAY
110996: PUSH
110997: LD_VAR 0 5
111001: ARRAY
111002: PUSH
111003: LD_INT 2
111005: ARRAY
111006: PUSH
111007: LD_VAR 0 3
111011: EQUAL
111012: AND
111013: IFFALSE 111116
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111015: LD_EXP 179
111019: PUSH
111020: LD_VAR 0 6
111024: ARRAY
111025: PUSH
111026: LD_VAR 0 5
111030: ARRAY
111031: PUSH
111032: LD_INT 1
111034: ARRAY
111035: PPUSH
111036: LD_EXP 179
111040: PUSH
111041: LD_VAR 0 6
111045: ARRAY
111046: PUSH
111047: LD_VAR 0 5
111051: ARRAY
111052: PUSH
111053: LD_INT 2
111055: ARRAY
111056: PPUSH
111057: LD_VAR 0 1
111061: PPUSH
111062: CALL_OW 255
111066: PPUSH
111067: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111071: LD_ADDR_EXP 179
111075: PUSH
111076: LD_EXP 179
111080: PPUSH
111081: LD_VAR 0 6
111085: PPUSH
111086: LD_EXP 179
111090: PUSH
111091: LD_VAR 0 6
111095: ARRAY
111096: PPUSH
111097: LD_VAR 0 5
111101: PPUSH
111102: CALL_OW 3
111106: PPUSH
111107: CALL_OW 1
111111: ST_TO_ADDR
// exit ;
111112: POP
111113: POP
111114: GO 111307
// end ; end ;
111116: GO 110956
111118: POP
111119: POP
// for i := minerMinesList [ index ] downto 1 do
111120: LD_ADDR_VAR 0 5
111124: PUSH
111125: DOUBLE
111126: LD_EXP 179
111130: PUSH
111131: LD_VAR 0 6
111135: ARRAY
111136: INC
111137: ST_TO_ADDR
111138: LD_INT 1
111140: PUSH
111141: FOR_DOWNTO
111142: IFFALSE 111305
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111144: LD_EXP 179
111148: PUSH
111149: LD_VAR 0 6
111153: ARRAY
111154: PUSH
111155: LD_VAR 0 5
111159: ARRAY
111160: PUSH
111161: LD_INT 1
111163: ARRAY
111164: PPUSH
111165: LD_EXP 179
111169: PUSH
111170: LD_VAR 0 6
111174: ARRAY
111175: PUSH
111176: LD_VAR 0 5
111180: ARRAY
111181: PUSH
111182: LD_INT 2
111184: ARRAY
111185: PPUSH
111186: LD_VAR 0 2
111190: PPUSH
111191: LD_VAR 0 3
111195: PPUSH
111196: CALL_OW 298
111200: PUSH
111201: LD_INT 6
111203: LESS
111204: IFFALSE 111303
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111206: LD_EXP 179
111210: PUSH
111211: LD_VAR 0 6
111215: ARRAY
111216: PUSH
111217: LD_VAR 0 5
111221: ARRAY
111222: PUSH
111223: LD_INT 1
111225: ARRAY
111226: PPUSH
111227: LD_EXP 179
111231: PUSH
111232: LD_VAR 0 6
111236: ARRAY
111237: PUSH
111238: LD_VAR 0 5
111242: ARRAY
111243: PUSH
111244: LD_INT 2
111246: ARRAY
111247: PPUSH
111248: LD_VAR 0 1
111252: PPUSH
111253: CALL_OW 255
111257: PPUSH
111258: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111262: LD_ADDR_EXP 179
111266: PUSH
111267: LD_EXP 179
111271: PPUSH
111272: LD_VAR 0 6
111276: PPUSH
111277: LD_EXP 179
111281: PUSH
111282: LD_VAR 0 6
111286: ARRAY
111287: PPUSH
111288: LD_VAR 0 5
111292: PPUSH
111293: CALL_OW 3
111297: PPUSH
111298: CALL_OW 1
111302: ST_TO_ADDR
// end ; end ;
111303: GO 111141
111305: POP
111306: POP
// end ;
111307: LD_VAR 0 4
111311: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111312: LD_INT 0
111314: PPUSH
111315: PPUSH
111316: PPUSH
111317: PPUSH
111318: PPUSH
111319: PPUSH
111320: PPUSH
111321: PPUSH
111322: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111323: LD_VAR 0 1
111327: PPUSH
111328: CALL_OW 264
111332: PUSH
111333: LD_INT 81
111335: EQUAL
111336: NOT
111337: PUSH
111338: LD_VAR 0 1
111342: PUSH
111343: LD_EXP 178
111347: IN
111348: NOT
111349: OR
111350: IFFALSE 111354
// exit ;
111352: GO 111676
// index := GetElementIndex ( minersList , unit ) ;
111354: LD_ADDR_VAR 0 6
111358: PUSH
111359: LD_EXP 178
111363: PPUSH
111364: LD_VAR 0 1
111368: PPUSH
111369: CALL 22107 0 2
111373: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111374: LD_ADDR_VAR 0 8
111378: PUSH
111379: LD_EXP 180
111383: PUSH
111384: LD_EXP 179
111388: PUSH
111389: LD_VAR 0 6
111393: ARRAY
111394: MINUS
111395: ST_TO_ADDR
// if not minesFreeAmount then
111396: LD_VAR 0 8
111400: NOT
111401: IFFALSE 111405
// exit ;
111403: GO 111676
// tmp := [ ] ;
111405: LD_ADDR_VAR 0 7
111409: PUSH
111410: EMPTY
111411: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111412: LD_ADDR_VAR 0 5
111416: PUSH
111417: DOUBLE
111418: LD_INT 1
111420: DEC
111421: ST_TO_ADDR
111422: LD_VAR 0 8
111426: PUSH
111427: FOR_TO
111428: IFFALSE 111623
// begin _d := rand ( 0 , 5 ) ;
111430: LD_ADDR_VAR 0 11
111434: PUSH
111435: LD_INT 0
111437: PPUSH
111438: LD_INT 5
111440: PPUSH
111441: CALL_OW 12
111445: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
111446: LD_ADDR_VAR 0 12
111450: PUSH
111451: LD_INT 2
111453: PPUSH
111454: LD_INT 6
111456: PPUSH
111457: CALL_OW 12
111461: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
111462: LD_ADDR_VAR 0 9
111466: PUSH
111467: LD_VAR 0 2
111471: PPUSH
111472: LD_VAR 0 11
111476: PPUSH
111477: LD_VAR 0 12
111481: PPUSH
111482: CALL_OW 272
111486: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
111487: LD_ADDR_VAR 0 10
111491: PUSH
111492: LD_VAR 0 3
111496: PPUSH
111497: LD_VAR 0 11
111501: PPUSH
111502: LD_VAR 0 12
111506: PPUSH
111507: CALL_OW 273
111511: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
111512: LD_VAR 0 9
111516: PPUSH
111517: LD_VAR 0 10
111521: PPUSH
111522: CALL_OW 488
111526: PUSH
111527: LD_VAR 0 9
111531: PUSH
111532: LD_VAR 0 10
111536: PUSH
111537: EMPTY
111538: LIST
111539: LIST
111540: PUSH
111541: LD_VAR 0 7
111545: IN
111546: NOT
111547: AND
111548: PUSH
111549: LD_VAR 0 9
111553: PPUSH
111554: LD_VAR 0 10
111558: PPUSH
111559: CALL_OW 458
111563: NOT
111564: AND
111565: IFFALSE 111607
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
111567: LD_ADDR_VAR 0 7
111571: PUSH
111572: LD_VAR 0 7
111576: PPUSH
111577: LD_VAR 0 7
111581: PUSH
111582: LD_INT 1
111584: PLUS
111585: PPUSH
111586: LD_VAR 0 9
111590: PUSH
111591: LD_VAR 0 10
111595: PUSH
111596: EMPTY
111597: LIST
111598: LIST
111599: PPUSH
111600: CALL_OW 1
111604: ST_TO_ADDR
111605: GO 111621
// i := i - 1 ;
111607: LD_ADDR_VAR 0 5
111611: PUSH
111612: LD_VAR 0 5
111616: PUSH
111617: LD_INT 1
111619: MINUS
111620: ST_TO_ADDR
// end ;
111621: GO 111427
111623: POP
111624: POP
// for i in tmp do
111625: LD_ADDR_VAR 0 5
111629: PUSH
111630: LD_VAR 0 7
111634: PUSH
111635: FOR_IN
111636: IFFALSE 111674
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
111638: LD_VAR 0 1
111642: PPUSH
111643: LD_VAR 0 5
111647: PUSH
111648: LD_INT 1
111650: ARRAY
111651: PPUSH
111652: LD_VAR 0 5
111656: PUSH
111657: LD_INT 2
111659: ARRAY
111660: PPUSH
111661: CALL 110620 0 3
111665: NOT
111666: IFFALSE 111672
// exit ;
111668: POP
111669: POP
111670: GO 111676
111672: GO 111635
111674: POP
111675: POP
// end ;
111676: LD_VAR 0 4
111680: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , dir , viewRange , _x , _y , _d , p ; begin
111681: LD_INT 0
111683: PPUSH
111684: PPUSH
111685: PPUSH
111686: PPUSH
111687: PPUSH
111688: PPUSH
111689: PPUSH
111690: PPUSH
111691: PPUSH
// if GetClass ( unit ) <> class_sniper then
111692: LD_VAR 0 1
111696: PPUSH
111697: CALL_OW 257
111701: PUSH
111702: LD_INT 5
111704: NONEQUAL
111705: IFFALSE 111709
// exit ;
111707: GO 112175
// dist := 8 ;
111709: LD_ADDR_VAR 0 5
111713: PUSH
111714: LD_INT 8
111716: ST_TO_ADDR
// viewRange := 12 ;
111717: LD_ADDR_VAR 0 8
111721: PUSH
111722: LD_INT 12
111724: ST_TO_ADDR
// side := GetSide ( unit ) ;
111725: LD_ADDR_VAR 0 6
111729: PUSH
111730: LD_VAR 0 1
111734: PPUSH
111735: CALL_OW 255
111739: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
111740: LD_INT 61
111742: PPUSH
111743: LD_VAR 0 6
111747: PPUSH
111748: CALL_OW 321
111752: PUSH
111753: LD_INT 2
111755: EQUAL
111756: IFFALSE 111766
// viewRange := 16 ;
111758: LD_ADDR_VAR 0 8
111762: PUSH
111763: LD_INT 16
111765: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
111766: LD_VAR 0 1
111770: PPUSH
111771: LD_VAR 0 2
111775: PPUSH
111776: LD_VAR 0 3
111780: PPUSH
111781: CALL_OW 297
111785: PUSH
111786: LD_VAR 0 5
111790: GREATER
111791: IFFALSE 111870
// begin ComMoveXY ( unit , x , y ) ;
111793: LD_VAR 0 1
111797: PPUSH
111798: LD_VAR 0 2
111802: PPUSH
111803: LD_VAR 0 3
111807: PPUSH
111808: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111812: LD_INT 35
111814: PPUSH
111815: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
111819: LD_VAR 0 1
111823: PPUSH
111824: LD_VAR 0 2
111828: PPUSH
111829: LD_VAR 0 3
111833: PPUSH
111834: CALL 53868 0 3
111838: NOT
111839: IFFALSE 111843
// exit ;
111841: GO 112175
// until GetDistUnitXY ( unit , x , y ) < dist ;
111843: LD_VAR 0 1
111847: PPUSH
111848: LD_VAR 0 2
111852: PPUSH
111853: LD_VAR 0 3
111857: PPUSH
111858: CALL_OW 297
111862: PUSH
111863: LD_VAR 0 5
111867: LESS
111868: IFFALSE 111812
// end ; ComTurnXY ( unit , x , y ) ;
111870: LD_VAR 0 1
111874: PPUSH
111875: LD_VAR 0 2
111879: PPUSH
111880: LD_VAR 0 3
111884: PPUSH
111885: CALL_OW 118
// repeat if Multiplayer then
111889: LD_OWVAR 4
111893: IFFALSE 111904
// wait ( 35 ) else
111895: LD_INT 35
111897: PPUSH
111898: CALL_OW 67
111902: GO 111911
// wait ( 5 ) ;
111904: LD_INT 5
111906: PPUSH
111907: CALL_OW 67
// _d := GetDir ( unit ) ;
111911: LD_ADDR_VAR 0 11
111915: PUSH
111916: LD_VAR 0 1
111920: PPUSH
111921: CALL_OW 254
111925: ST_TO_ADDR
// dir := GetDirFromHex ( GetX ( unit ) , GetY ( unit ) , x , y ) ;
111926: LD_ADDR_VAR 0 7
111930: PUSH
111931: LD_VAR 0 1
111935: PPUSH
111936: CALL_OW 250
111940: PPUSH
111941: LD_VAR 0 1
111945: PPUSH
111946: CALL_OW 251
111950: PPUSH
111951: LD_VAR 0 2
111955: PPUSH
111956: LD_VAR 0 3
111960: PPUSH
111961: CALL 56476 0 4
111965: ST_TO_ADDR
// until dir = _d ;
111966: LD_VAR 0 7
111970: PUSH
111971: LD_VAR 0 11
111975: EQUAL
111976: IFFALSE 111889
// _x := ShiftX ( GetX ( unit ) , dir , dist ) ;
111978: LD_ADDR_VAR 0 9
111982: PUSH
111983: LD_VAR 0 1
111987: PPUSH
111988: CALL_OW 250
111992: PPUSH
111993: LD_VAR 0 7
111997: PPUSH
111998: LD_VAR 0 5
112002: PPUSH
112003: CALL_OW 272
112007: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , dir , dist ) ;
112008: LD_ADDR_VAR 0 10
112012: PUSH
112013: LD_VAR 0 1
112017: PPUSH
112018: CALL_OW 251
112022: PPUSH
112023: LD_VAR 0 7
112027: PPUSH
112028: LD_VAR 0 5
112032: PPUSH
112033: CALL_OW 273
112037: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112038: LD_VAR 0 9
112042: PPUSH
112043: LD_VAR 0 10
112047: PPUSH
112048: CALL_OW 488
112052: NOT
112053: IFFALSE 112057
// exit ;
112055: GO 112175
// ComAnimCustom ( unit , 1 ) ;
112057: LD_VAR 0 1
112061: PPUSH
112062: LD_INT 1
112064: PPUSH
112065: CALL_OW 592
// p := 0 ;
112069: LD_ADDR_VAR 0 12
112073: PUSH
112074: LD_INT 0
112076: ST_TO_ADDR
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112077: LD_VAR 0 9
112081: PPUSH
112082: LD_VAR 0 10
112086: PPUSH
112087: LD_VAR 0 6
112091: PPUSH
112092: LD_VAR 0 8
112096: PPUSH
112097: CALL_OW 330
// repeat wait ( 0 0$1 ) ;
112101: LD_INT 35
112103: PPUSH
112104: CALL_OW 67
// p := Inc ( p ) ;
112108: LD_ADDR_VAR 0 12
112112: PUSH
112113: LD_VAR 0 12
112117: PPUSH
112118: CALL 56432 0 1
112122: ST_TO_ADDR
// until p = 3 or not IsOk ( unit ) or IsDead ( unit ) ;
112123: LD_VAR 0 12
112127: PUSH
112128: LD_INT 3
112130: EQUAL
112131: PUSH
112132: LD_VAR 0 1
112136: PPUSH
112137: CALL_OW 302
112141: NOT
112142: OR
112143: PUSH
112144: LD_VAR 0 1
112148: PPUSH
112149: CALL_OW 301
112153: OR
112154: IFFALSE 112101
// RemoveSeeing ( _x , _y , side ) ;
112156: LD_VAR 0 9
112160: PPUSH
112161: LD_VAR 0 10
112165: PPUSH
112166: LD_VAR 0 6
112170: PPUSH
112171: CALL_OW 331
// end ; end_of_file
112175: LD_VAR 0 4
112179: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112180: LD_INT 0
112182: PPUSH
112183: PPUSH
112184: PPUSH
112185: PPUSH
112186: PPUSH
112187: PPUSH
112188: PPUSH
112189: PPUSH
112190: PPUSH
112191: PPUSH
112192: PPUSH
112193: PPUSH
112194: PPUSH
112195: PPUSH
112196: PPUSH
112197: PPUSH
112198: PPUSH
112199: PPUSH
112200: PPUSH
112201: PPUSH
112202: PPUSH
112203: PPUSH
112204: PPUSH
112205: PPUSH
112206: PPUSH
112207: PPUSH
112208: PPUSH
112209: PPUSH
112210: PPUSH
112211: PPUSH
112212: PPUSH
112213: PPUSH
112214: PPUSH
112215: PPUSH
// if not list then
112216: LD_VAR 0 1
112220: NOT
112221: IFFALSE 112225
// exit ;
112223: GO 116884
// base := list [ 1 ] ;
112225: LD_ADDR_VAR 0 3
112229: PUSH
112230: LD_VAR 0 1
112234: PUSH
112235: LD_INT 1
112237: ARRAY
112238: ST_TO_ADDR
// group := list [ 2 ] ;
112239: LD_ADDR_VAR 0 4
112243: PUSH
112244: LD_VAR 0 1
112248: PUSH
112249: LD_INT 2
112251: ARRAY
112252: ST_TO_ADDR
// path := list [ 3 ] ;
112253: LD_ADDR_VAR 0 5
112257: PUSH
112258: LD_VAR 0 1
112262: PUSH
112263: LD_INT 3
112265: ARRAY
112266: ST_TO_ADDR
// flags := list [ 4 ] ;
112267: LD_ADDR_VAR 0 6
112271: PUSH
112272: LD_VAR 0 1
112276: PUSH
112277: LD_INT 4
112279: ARRAY
112280: ST_TO_ADDR
// mined := [ ] ;
112281: LD_ADDR_VAR 0 27
112285: PUSH
112286: EMPTY
112287: ST_TO_ADDR
// bombed := [ ] ;
112288: LD_ADDR_VAR 0 28
112292: PUSH
112293: EMPTY
112294: ST_TO_ADDR
// healers := [ ] ;
112295: LD_ADDR_VAR 0 31
112299: PUSH
112300: EMPTY
112301: ST_TO_ADDR
// to_heal := [ ] ;
112302: LD_ADDR_VAR 0 30
112306: PUSH
112307: EMPTY
112308: ST_TO_ADDR
// repairs := [ ] ;
112309: LD_ADDR_VAR 0 33
112313: PUSH
112314: EMPTY
112315: ST_TO_ADDR
// to_repair := [ ] ;
112316: LD_ADDR_VAR 0 32
112320: PUSH
112321: EMPTY
112322: ST_TO_ADDR
// if not group or not path then
112323: LD_VAR 0 4
112327: NOT
112328: PUSH
112329: LD_VAR 0 5
112333: NOT
112334: OR
112335: IFFALSE 112339
// exit ;
112337: GO 116884
// side := GetSide ( group [ 1 ] ) ;
112339: LD_ADDR_VAR 0 35
112343: PUSH
112344: LD_VAR 0 4
112348: PUSH
112349: LD_INT 1
112351: ARRAY
112352: PPUSH
112353: CALL_OW 255
112357: ST_TO_ADDR
// if flags then
112358: LD_VAR 0 6
112362: IFFALSE 112506
// begin f_ignore_area := flags [ 1 ] ;
112364: LD_ADDR_VAR 0 17
112368: PUSH
112369: LD_VAR 0 6
112373: PUSH
112374: LD_INT 1
112376: ARRAY
112377: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112378: LD_ADDR_VAR 0 18
112382: PUSH
112383: LD_VAR 0 6
112387: PUSH
112388: LD_INT 2
112390: ARRAY
112391: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112392: LD_ADDR_VAR 0 19
112396: PUSH
112397: LD_VAR 0 6
112401: PUSH
112402: LD_INT 3
112404: ARRAY
112405: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112406: LD_ADDR_VAR 0 20
112410: PUSH
112411: LD_VAR 0 6
112415: PUSH
112416: LD_INT 4
112418: ARRAY
112419: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112420: LD_ADDR_VAR 0 21
112424: PUSH
112425: LD_VAR 0 6
112429: PUSH
112430: LD_INT 5
112432: ARRAY
112433: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112434: LD_ADDR_VAR 0 22
112438: PUSH
112439: LD_VAR 0 6
112443: PUSH
112444: LD_INT 6
112446: ARRAY
112447: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112448: LD_ADDR_VAR 0 23
112452: PUSH
112453: LD_VAR 0 6
112457: PUSH
112458: LD_INT 7
112460: ARRAY
112461: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112462: LD_ADDR_VAR 0 24
112466: PUSH
112467: LD_VAR 0 6
112471: PUSH
112472: LD_INT 8
112474: ARRAY
112475: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112476: LD_ADDR_VAR 0 25
112480: PUSH
112481: LD_VAR 0 6
112485: PUSH
112486: LD_INT 9
112488: ARRAY
112489: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112490: LD_ADDR_VAR 0 26
112494: PUSH
112495: LD_VAR 0 6
112499: PUSH
112500: LD_INT 10
112502: ARRAY
112503: ST_TO_ADDR
// end else
112504: GO 112586
// begin f_ignore_area := false ;
112506: LD_ADDR_VAR 0 17
112510: PUSH
112511: LD_INT 0
112513: ST_TO_ADDR
// f_capture := false ;
112514: LD_ADDR_VAR 0 18
112518: PUSH
112519: LD_INT 0
112521: ST_TO_ADDR
// f_ignore_civ := false ;
112522: LD_ADDR_VAR 0 19
112526: PUSH
112527: LD_INT 0
112529: ST_TO_ADDR
// f_murder := false ;
112530: LD_ADDR_VAR 0 20
112534: PUSH
112535: LD_INT 0
112537: ST_TO_ADDR
// f_mines := false ;
112538: LD_ADDR_VAR 0 21
112542: PUSH
112543: LD_INT 0
112545: ST_TO_ADDR
// f_repair := false ;
112546: LD_ADDR_VAR 0 22
112550: PUSH
112551: LD_INT 0
112553: ST_TO_ADDR
// f_heal := false ;
112554: LD_ADDR_VAR 0 23
112558: PUSH
112559: LD_INT 0
112561: ST_TO_ADDR
// f_spacetime := false ;
112562: LD_ADDR_VAR 0 24
112566: PUSH
112567: LD_INT 0
112569: ST_TO_ADDR
// f_attack_depot := false ;
112570: LD_ADDR_VAR 0 25
112574: PUSH
112575: LD_INT 0
112577: ST_TO_ADDR
// f_crawl := false ;
112578: LD_ADDR_VAR 0 26
112582: PUSH
112583: LD_INT 0
112585: ST_TO_ADDR
// end ; if f_heal then
112586: LD_VAR 0 23
112590: IFFALSE 112617
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
112592: LD_ADDR_VAR 0 31
112596: PUSH
112597: LD_VAR 0 4
112601: PPUSH
112602: LD_INT 25
112604: PUSH
112605: LD_INT 4
112607: PUSH
112608: EMPTY
112609: LIST
112610: LIST
112611: PPUSH
112612: CALL_OW 72
112616: ST_TO_ADDR
// if f_repair then
112617: LD_VAR 0 22
112621: IFFALSE 112648
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
112623: LD_ADDR_VAR 0 33
112627: PUSH
112628: LD_VAR 0 4
112632: PPUSH
112633: LD_INT 25
112635: PUSH
112636: LD_INT 3
112638: PUSH
112639: EMPTY
112640: LIST
112641: LIST
112642: PPUSH
112643: CALL_OW 72
112647: ST_TO_ADDR
// units_path := [ ] ;
112648: LD_ADDR_VAR 0 16
112652: PUSH
112653: EMPTY
112654: ST_TO_ADDR
// for i = 1 to group do
112655: LD_ADDR_VAR 0 7
112659: PUSH
112660: DOUBLE
112661: LD_INT 1
112663: DEC
112664: ST_TO_ADDR
112665: LD_VAR 0 4
112669: PUSH
112670: FOR_TO
112671: IFFALSE 112700
// units_path := Replace ( units_path , i , path ) ;
112673: LD_ADDR_VAR 0 16
112677: PUSH
112678: LD_VAR 0 16
112682: PPUSH
112683: LD_VAR 0 7
112687: PPUSH
112688: LD_VAR 0 5
112692: PPUSH
112693: CALL_OW 1
112697: ST_TO_ADDR
112698: GO 112670
112700: POP
112701: POP
// repeat for i = group downto 1 do
112702: LD_ADDR_VAR 0 7
112706: PUSH
112707: DOUBLE
112708: LD_VAR 0 4
112712: INC
112713: ST_TO_ADDR
112714: LD_INT 1
112716: PUSH
112717: FOR_DOWNTO
112718: IFFALSE 116840
// begin wait ( 5 ) ;
112720: LD_INT 5
112722: PPUSH
112723: CALL_OW 67
// tmp := [ ] ;
112727: LD_ADDR_VAR 0 14
112731: PUSH
112732: EMPTY
112733: ST_TO_ADDR
// attacking := false ;
112734: LD_ADDR_VAR 0 29
112738: PUSH
112739: LD_INT 0
112741: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
112742: LD_VAR 0 4
112746: PUSH
112747: LD_VAR 0 7
112751: ARRAY
112752: PPUSH
112753: CALL_OW 301
112757: PUSH
112758: LD_VAR 0 4
112762: PUSH
112763: LD_VAR 0 7
112767: ARRAY
112768: NOT
112769: OR
112770: IFFALSE 112879
// begin if GetType ( group [ i ] ) = unit_human then
112772: LD_VAR 0 4
112776: PUSH
112777: LD_VAR 0 7
112781: ARRAY
112782: PPUSH
112783: CALL_OW 247
112787: PUSH
112788: LD_INT 1
112790: EQUAL
112791: IFFALSE 112837
// begin to_heal := to_heal diff group [ i ] ;
112793: LD_ADDR_VAR 0 30
112797: PUSH
112798: LD_VAR 0 30
112802: PUSH
112803: LD_VAR 0 4
112807: PUSH
112808: LD_VAR 0 7
112812: ARRAY
112813: DIFF
112814: ST_TO_ADDR
// healers := healers diff group [ i ] ;
112815: LD_ADDR_VAR 0 31
112819: PUSH
112820: LD_VAR 0 31
112824: PUSH
112825: LD_VAR 0 4
112829: PUSH
112830: LD_VAR 0 7
112834: ARRAY
112835: DIFF
112836: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
112837: LD_ADDR_VAR 0 4
112841: PUSH
112842: LD_VAR 0 4
112846: PPUSH
112847: LD_VAR 0 7
112851: PPUSH
112852: CALL_OW 3
112856: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
112857: LD_ADDR_VAR 0 16
112861: PUSH
112862: LD_VAR 0 16
112866: PPUSH
112867: LD_VAR 0 7
112871: PPUSH
112872: CALL_OW 3
112876: ST_TO_ADDR
// continue ;
112877: GO 112717
// end ; if f_repair then
112879: LD_VAR 0 22
112883: IFFALSE 113372
// begin if GetType ( group [ i ] ) = unit_vehicle then
112885: LD_VAR 0 4
112889: PUSH
112890: LD_VAR 0 7
112894: ARRAY
112895: PPUSH
112896: CALL_OW 247
112900: PUSH
112901: LD_INT 2
112903: EQUAL
112904: IFFALSE 113094
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
112906: LD_VAR 0 4
112910: PUSH
112911: LD_VAR 0 7
112915: ARRAY
112916: PPUSH
112917: CALL_OW 256
112921: PUSH
112922: LD_INT 700
112924: LESS
112925: PUSH
112926: LD_VAR 0 4
112930: PUSH
112931: LD_VAR 0 7
112935: ARRAY
112936: PUSH
112937: LD_VAR 0 32
112941: IN
112942: NOT
112943: AND
112944: IFFALSE 112968
// to_repair := to_repair union group [ i ] ;
112946: LD_ADDR_VAR 0 32
112950: PUSH
112951: LD_VAR 0 32
112955: PUSH
112956: LD_VAR 0 4
112960: PUSH
112961: LD_VAR 0 7
112965: ARRAY
112966: UNION
112967: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
112968: LD_VAR 0 4
112972: PUSH
112973: LD_VAR 0 7
112977: ARRAY
112978: PPUSH
112979: CALL_OW 256
112983: PUSH
112984: LD_INT 1000
112986: EQUAL
112987: PUSH
112988: LD_VAR 0 4
112992: PUSH
112993: LD_VAR 0 7
112997: ARRAY
112998: PUSH
112999: LD_VAR 0 32
113003: IN
113004: AND
113005: IFFALSE 113029
// to_repair := to_repair diff group [ i ] ;
113007: LD_ADDR_VAR 0 32
113011: PUSH
113012: LD_VAR 0 32
113016: PUSH
113017: LD_VAR 0 4
113021: PUSH
113022: LD_VAR 0 7
113026: ARRAY
113027: DIFF
113028: ST_TO_ADDR
// if group [ i ] in to_repair then
113029: LD_VAR 0 4
113033: PUSH
113034: LD_VAR 0 7
113038: ARRAY
113039: PUSH
113040: LD_VAR 0 32
113044: IN
113045: IFFALSE 113092
// begin if not IsInArea ( group [ i ] , f_repair ) then
113047: LD_VAR 0 4
113051: PUSH
113052: LD_VAR 0 7
113056: ARRAY
113057: PPUSH
113058: LD_VAR 0 22
113062: PPUSH
113063: CALL_OW 308
113067: NOT
113068: IFFALSE 113090
// ComMoveToArea ( group [ i ] , f_repair ) ;
113070: LD_VAR 0 4
113074: PUSH
113075: LD_VAR 0 7
113079: ARRAY
113080: PPUSH
113081: LD_VAR 0 22
113085: PPUSH
113086: CALL_OW 113
// continue ;
113090: GO 112717
// end ; end else
113092: GO 113372
// if group [ i ] in repairs then
113094: LD_VAR 0 4
113098: PUSH
113099: LD_VAR 0 7
113103: ARRAY
113104: PUSH
113105: LD_VAR 0 33
113109: IN
113110: IFFALSE 113372
// begin if IsInUnit ( group [ i ] ) then
113112: LD_VAR 0 4
113116: PUSH
113117: LD_VAR 0 7
113121: ARRAY
113122: PPUSH
113123: CALL_OW 310
113127: IFFALSE 113195
// begin z := IsInUnit ( group [ i ] ) ;
113129: LD_ADDR_VAR 0 13
113133: PUSH
113134: LD_VAR 0 4
113138: PUSH
113139: LD_VAR 0 7
113143: ARRAY
113144: PPUSH
113145: CALL_OW 310
113149: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113150: LD_VAR 0 13
113154: PUSH
113155: LD_VAR 0 32
113159: IN
113160: PUSH
113161: LD_VAR 0 13
113165: PPUSH
113166: LD_VAR 0 22
113170: PPUSH
113171: CALL_OW 308
113175: AND
113176: IFFALSE 113193
// ComExitVehicle ( group [ i ] ) ;
113178: LD_VAR 0 4
113182: PUSH
113183: LD_VAR 0 7
113187: ARRAY
113188: PPUSH
113189: CALL_OW 121
// end else
113193: GO 113372
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113195: LD_ADDR_VAR 0 13
113199: PUSH
113200: LD_VAR 0 4
113204: PPUSH
113205: LD_INT 95
113207: PUSH
113208: LD_VAR 0 22
113212: PUSH
113213: EMPTY
113214: LIST
113215: LIST
113216: PUSH
113217: LD_INT 58
113219: PUSH
113220: EMPTY
113221: LIST
113222: PUSH
113223: EMPTY
113224: LIST
113225: LIST
113226: PPUSH
113227: CALL_OW 72
113231: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113232: LD_VAR 0 4
113236: PUSH
113237: LD_VAR 0 7
113241: ARRAY
113242: PPUSH
113243: CALL_OW 314
113247: NOT
113248: IFFALSE 113370
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113250: LD_ADDR_VAR 0 10
113254: PUSH
113255: LD_VAR 0 13
113259: PPUSH
113260: LD_VAR 0 4
113264: PUSH
113265: LD_VAR 0 7
113269: ARRAY
113270: PPUSH
113271: CALL_OW 74
113275: ST_TO_ADDR
// if not x then
113276: LD_VAR 0 10
113280: NOT
113281: IFFALSE 113285
// continue ;
113283: GO 112717
// if GetLives ( x ) < 1000 then
113285: LD_VAR 0 10
113289: PPUSH
113290: CALL_OW 256
113294: PUSH
113295: LD_INT 1000
113297: LESS
113298: IFFALSE 113322
// ComRepairVehicle ( group [ i ] , x ) else
113300: LD_VAR 0 4
113304: PUSH
113305: LD_VAR 0 7
113309: ARRAY
113310: PPUSH
113311: LD_VAR 0 10
113315: PPUSH
113316: CALL_OW 129
113320: GO 113370
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113322: LD_VAR 0 23
113326: PUSH
113327: LD_VAR 0 4
113331: PUSH
113332: LD_VAR 0 7
113336: ARRAY
113337: PPUSH
113338: CALL_OW 256
113342: PUSH
113343: LD_INT 1000
113345: LESS
113346: AND
113347: NOT
113348: IFFALSE 113370
// ComEnterUnit ( group [ i ] , x ) ;
113350: LD_VAR 0 4
113354: PUSH
113355: LD_VAR 0 7
113359: ARRAY
113360: PPUSH
113361: LD_VAR 0 10
113365: PPUSH
113366: CALL_OW 120
// end ; continue ;
113370: GO 112717
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113372: LD_VAR 0 23
113376: PUSH
113377: LD_VAR 0 4
113381: PUSH
113382: LD_VAR 0 7
113386: ARRAY
113387: PPUSH
113388: CALL_OW 247
113392: PUSH
113393: LD_INT 1
113395: EQUAL
113396: AND
113397: IFFALSE 113875
// begin if group [ i ] in healers then
113399: LD_VAR 0 4
113403: PUSH
113404: LD_VAR 0 7
113408: ARRAY
113409: PUSH
113410: LD_VAR 0 31
113414: IN
113415: IFFALSE 113688
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113417: LD_VAR 0 4
113421: PUSH
113422: LD_VAR 0 7
113426: ARRAY
113427: PPUSH
113428: LD_VAR 0 23
113432: PPUSH
113433: CALL_OW 308
113437: NOT
113438: PUSH
113439: LD_VAR 0 4
113443: PUSH
113444: LD_VAR 0 7
113448: ARRAY
113449: PPUSH
113450: CALL_OW 314
113454: NOT
113455: AND
113456: IFFALSE 113480
// ComMoveToArea ( group [ i ] , f_heal ) else
113458: LD_VAR 0 4
113462: PUSH
113463: LD_VAR 0 7
113467: ARRAY
113468: PPUSH
113469: LD_VAR 0 23
113473: PPUSH
113474: CALL_OW 113
113478: GO 113686
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113480: LD_VAR 0 4
113484: PUSH
113485: LD_VAR 0 7
113489: ARRAY
113490: PPUSH
113491: CALL 52451 0 1
113495: PPUSH
113496: CALL_OW 256
113500: PUSH
113501: LD_INT 1000
113503: EQUAL
113504: IFFALSE 113523
// ComStop ( group [ i ] ) else
113506: LD_VAR 0 4
113510: PUSH
113511: LD_VAR 0 7
113515: ARRAY
113516: PPUSH
113517: CALL_OW 141
113521: GO 113686
// if not HasTask ( group [ i ] ) and to_heal then
113523: LD_VAR 0 4
113527: PUSH
113528: LD_VAR 0 7
113532: ARRAY
113533: PPUSH
113534: CALL_OW 314
113538: NOT
113539: PUSH
113540: LD_VAR 0 30
113544: AND
113545: IFFALSE 113686
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
113547: LD_ADDR_VAR 0 13
113551: PUSH
113552: LD_VAR 0 30
113556: PPUSH
113557: LD_INT 3
113559: PUSH
113560: LD_INT 54
113562: PUSH
113563: EMPTY
113564: LIST
113565: PUSH
113566: EMPTY
113567: LIST
113568: LIST
113569: PPUSH
113570: CALL_OW 72
113574: PPUSH
113575: LD_VAR 0 4
113579: PUSH
113580: LD_VAR 0 7
113584: ARRAY
113585: PPUSH
113586: CALL_OW 74
113590: ST_TO_ADDR
// if z then
113591: LD_VAR 0 13
113595: IFFALSE 113686
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
113597: LD_INT 91
113599: PUSH
113600: LD_VAR 0 13
113604: PUSH
113605: LD_INT 10
113607: PUSH
113608: EMPTY
113609: LIST
113610: LIST
113611: LIST
113612: PUSH
113613: LD_INT 81
113615: PUSH
113616: LD_VAR 0 13
113620: PPUSH
113621: CALL_OW 255
113625: PUSH
113626: EMPTY
113627: LIST
113628: LIST
113629: PUSH
113630: EMPTY
113631: LIST
113632: LIST
113633: PPUSH
113634: CALL_OW 69
113638: PUSH
113639: LD_INT 0
113641: EQUAL
113642: IFFALSE 113666
// ComHeal ( group [ i ] , z ) else
113644: LD_VAR 0 4
113648: PUSH
113649: LD_VAR 0 7
113653: ARRAY
113654: PPUSH
113655: LD_VAR 0 13
113659: PPUSH
113660: CALL_OW 128
113664: GO 113686
// ComMoveToArea ( group [ i ] , f_heal ) ;
113666: LD_VAR 0 4
113670: PUSH
113671: LD_VAR 0 7
113675: ARRAY
113676: PPUSH
113677: LD_VAR 0 23
113681: PPUSH
113682: CALL_OW 113
// end ; continue ;
113686: GO 112717
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
113688: LD_VAR 0 4
113692: PUSH
113693: LD_VAR 0 7
113697: ARRAY
113698: PPUSH
113699: CALL_OW 256
113703: PUSH
113704: LD_INT 700
113706: LESS
113707: PUSH
113708: LD_VAR 0 4
113712: PUSH
113713: LD_VAR 0 7
113717: ARRAY
113718: PUSH
113719: LD_VAR 0 30
113723: IN
113724: NOT
113725: AND
113726: IFFALSE 113750
// to_heal := to_heal union group [ i ] ;
113728: LD_ADDR_VAR 0 30
113732: PUSH
113733: LD_VAR 0 30
113737: PUSH
113738: LD_VAR 0 4
113742: PUSH
113743: LD_VAR 0 7
113747: ARRAY
113748: UNION
113749: ST_TO_ADDR
// if group [ i ] in to_heal then
113750: LD_VAR 0 4
113754: PUSH
113755: LD_VAR 0 7
113759: ARRAY
113760: PUSH
113761: LD_VAR 0 30
113765: IN
113766: IFFALSE 113875
// begin if GetLives ( group [ i ] ) = 1000 then
113768: LD_VAR 0 4
113772: PUSH
113773: LD_VAR 0 7
113777: ARRAY
113778: PPUSH
113779: CALL_OW 256
113783: PUSH
113784: LD_INT 1000
113786: EQUAL
113787: IFFALSE 113813
// to_heal := to_heal diff group [ i ] else
113789: LD_ADDR_VAR 0 30
113793: PUSH
113794: LD_VAR 0 30
113798: PUSH
113799: LD_VAR 0 4
113803: PUSH
113804: LD_VAR 0 7
113808: ARRAY
113809: DIFF
113810: ST_TO_ADDR
113811: GO 113875
// begin if not IsInArea ( group [ i ] , to_heal ) then
113813: LD_VAR 0 4
113817: PUSH
113818: LD_VAR 0 7
113822: ARRAY
113823: PPUSH
113824: LD_VAR 0 30
113828: PPUSH
113829: CALL_OW 308
113833: NOT
113834: IFFALSE 113858
// ComMoveToArea ( group [ i ] , f_heal ) else
113836: LD_VAR 0 4
113840: PUSH
113841: LD_VAR 0 7
113845: ARRAY
113846: PPUSH
113847: LD_VAR 0 23
113851: PPUSH
113852: CALL_OW 113
113856: GO 113873
// ComHold ( group [ i ] ) ;
113858: LD_VAR 0 4
113862: PUSH
113863: LD_VAR 0 7
113867: ARRAY
113868: PPUSH
113869: CALL_OW 140
// continue ;
113873: GO 112717
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
113875: LD_VAR 0 4
113879: PUSH
113880: LD_VAR 0 7
113884: ARRAY
113885: PPUSH
113886: LD_INT 10
113888: PPUSH
113889: CALL 50213 0 2
113893: NOT
113894: PUSH
113895: LD_VAR 0 16
113899: PUSH
113900: LD_VAR 0 7
113904: ARRAY
113905: PUSH
113906: EMPTY
113907: EQUAL
113908: NOT
113909: AND
113910: IFFALSE 114176
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
113912: LD_VAR 0 4
113916: PUSH
113917: LD_VAR 0 7
113921: ARRAY
113922: PPUSH
113923: CALL_OW 262
113927: PUSH
113928: LD_INT 1
113930: PUSH
113931: LD_INT 2
113933: PUSH
113934: EMPTY
113935: LIST
113936: LIST
113937: IN
113938: IFFALSE 113979
// if GetFuel ( group [ i ] ) < 10 then
113940: LD_VAR 0 4
113944: PUSH
113945: LD_VAR 0 7
113949: ARRAY
113950: PPUSH
113951: CALL_OW 261
113955: PUSH
113956: LD_INT 10
113958: LESS
113959: IFFALSE 113979
// SetFuel ( group [ i ] , 12 ) ;
113961: LD_VAR 0 4
113965: PUSH
113966: LD_VAR 0 7
113970: ARRAY
113971: PPUSH
113972: LD_INT 12
113974: PPUSH
113975: CALL_OW 240
// if units_path [ i ] then
113979: LD_VAR 0 16
113983: PUSH
113984: LD_VAR 0 7
113988: ARRAY
113989: IFFALSE 114174
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
113991: LD_VAR 0 4
113995: PUSH
113996: LD_VAR 0 7
114000: ARRAY
114001: PPUSH
114002: LD_VAR 0 16
114006: PUSH
114007: LD_VAR 0 7
114011: ARRAY
114012: PUSH
114013: LD_INT 1
114015: ARRAY
114016: PUSH
114017: LD_INT 1
114019: ARRAY
114020: PPUSH
114021: LD_VAR 0 16
114025: PUSH
114026: LD_VAR 0 7
114030: ARRAY
114031: PUSH
114032: LD_INT 1
114034: ARRAY
114035: PUSH
114036: LD_INT 2
114038: ARRAY
114039: PPUSH
114040: CALL_OW 297
114044: PUSH
114045: LD_INT 6
114047: GREATER
114048: IFFALSE 114123
// begin if not HasTask ( group [ i ] ) then
114050: LD_VAR 0 4
114054: PUSH
114055: LD_VAR 0 7
114059: ARRAY
114060: PPUSH
114061: CALL_OW 314
114065: NOT
114066: IFFALSE 114121
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114068: LD_VAR 0 4
114072: PUSH
114073: LD_VAR 0 7
114077: ARRAY
114078: PPUSH
114079: LD_VAR 0 16
114083: PUSH
114084: LD_VAR 0 7
114088: ARRAY
114089: PUSH
114090: LD_INT 1
114092: ARRAY
114093: PUSH
114094: LD_INT 1
114096: ARRAY
114097: PPUSH
114098: LD_VAR 0 16
114102: PUSH
114103: LD_VAR 0 7
114107: ARRAY
114108: PUSH
114109: LD_INT 1
114111: ARRAY
114112: PUSH
114113: LD_INT 2
114115: ARRAY
114116: PPUSH
114117: CALL_OW 114
// end else
114121: GO 114174
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114123: LD_ADDR_VAR 0 15
114127: PUSH
114128: LD_VAR 0 16
114132: PUSH
114133: LD_VAR 0 7
114137: ARRAY
114138: PPUSH
114139: LD_INT 1
114141: PPUSH
114142: CALL_OW 3
114146: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114147: LD_ADDR_VAR 0 16
114151: PUSH
114152: LD_VAR 0 16
114156: PPUSH
114157: LD_VAR 0 7
114161: PPUSH
114162: LD_VAR 0 15
114166: PPUSH
114167: CALL_OW 1
114171: ST_TO_ADDR
// continue ;
114172: GO 112717
// end ; end ; end else
114174: GO 116838
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114176: LD_ADDR_VAR 0 14
114180: PUSH
114181: LD_INT 81
114183: PUSH
114184: LD_VAR 0 4
114188: PUSH
114189: LD_VAR 0 7
114193: ARRAY
114194: PPUSH
114195: CALL_OW 255
114199: PUSH
114200: EMPTY
114201: LIST
114202: LIST
114203: PPUSH
114204: CALL_OW 69
114208: ST_TO_ADDR
// if not tmp then
114209: LD_VAR 0 14
114213: NOT
114214: IFFALSE 114218
// continue ;
114216: GO 112717
// if f_ignore_area then
114218: LD_VAR 0 17
114222: IFFALSE 114310
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114224: LD_ADDR_VAR 0 15
114228: PUSH
114229: LD_VAR 0 14
114233: PPUSH
114234: LD_INT 3
114236: PUSH
114237: LD_INT 92
114239: PUSH
114240: LD_VAR 0 17
114244: PUSH
114245: LD_INT 1
114247: ARRAY
114248: PUSH
114249: LD_VAR 0 17
114253: PUSH
114254: LD_INT 2
114256: ARRAY
114257: PUSH
114258: LD_VAR 0 17
114262: PUSH
114263: LD_INT 3
114265: ARRAY
114266: PUSH
114267: EMPTY
114268: LIST
114269: LIST
114270: LIST
114271: LIST
114272: PUSH
114273: EMPTY
114274: LIST
114275: LIST
114276: PPUSH
114277: CALL_OW 72
114281: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114282: LD_VAR 0 14
114286: PUSH
114287: LD_VAR 0 15
114291: DIFF
114292: IFFALSE 114310
// tmp := tmp diff tmp2 ;
114294: LD_ADDR_VAR 0 14
114298: PUSH
114299: LD_VAR 0 14
114303: PUSH
114304: LD_VAR 0 15
114308: DIFF
114309: ST_TO_ADDR
// end ; if not f_murder then
114310: LD_VAR 0 20
114314: NOT
114315: IFFALSE 114373
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114317: LD_ADDR_VAR 0 15
114321: PUSH
114322: LD_VAR 0 14
114326: PPUSH
114327: LD_INT 3
114329: PUSH
114330: LD_INT 50
114332: PUSH
114333: EMPTY
114334: LIST
114335: PUSH
114336: EMPTY
114337: LIST
114338: LIST
114339: PPUSH
114340: CALL_OW 72
114344: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114345: LD_VAR 0 14
114349: PUSH
114350: LD_VAR 0 15
114354: DIFF
114355: IFFALSE 114373
// tmp := tmp diff tmp2 ;
114357: LD_ADDR_VAR 0 14
114361: PUSH
114362: LD_VAR 0 14
114366: PUSH
114367: LD_VAR 0 15
114371: DIFF
114372: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114373: LD_ADDR_VAR 0 14
114377: PUSH
114378: LD_VAR 0 4
114382: PUSH
114383: LD_VAR 0 7
114387: ARRAY
114388: PPUSH
114389: LD_VAR 0 14
114393: PPUSH
114394: LD_INT 1
114396: PPUSH
114397: LD_INT 1
114399: PPUSH
114400: CALL 22757 0 4
114404: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114405: LD_VAR 0 4
114409: PUSH
114410: LD_VAR 0 7
114414: ARRAY
114415: PPUSH
114416: CALL_OW 257
114420: PUSH
114421: LD_INT 1
114423: EQUAL
114424: IFFALSE 114872
// begin if WantPlant ( group [ i ] ) then
114426: LD_VAR 0 4
114430: PUSH
114431: LD_VAR 0 7
114435: ARRAY
114436: PPUSH
114437: CALL 22258 0 1
114441: IFFALSE 114445
// continue ;
114443: GO 112717
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114445: LD_VAR 0 18
114449: PUSH
114450: LD_VAR 0 4
114454: PUSH
114455: LD_VAR 0 7
114459: ARRAY
114460: PPUSH
114461: CALL_OW 310
114465: NOT
114466: AND
114467: PUSH
114468: LD_VAR 0 14
114472: PUSH
114473: LD_INT 1
114475: ARRAY
114476: PUSH
114477: LD_VAR 0 14
114481: PPUSH
114482: LD_INT 21
114484: PUSH
114485: LD_INT 2
114487: PUSH
114488: EMPTY
114489: LIST
114490: LIST
114491: PUSH
114492: LD_INT 58
114494: PUSH
114495: EMPTY
114496: LIST
114497: PUSH
114498: EMPTY
114499: LIST
114500: LIST
114501: PPUSH
114502: CALL_OW 72
114506: IN
114507: AND
114508: IFFALSE 114544
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114510: LD_VAR 0 4
114514: PUSH
114515: LD_VAR 0 7
114519: ARRAY
114520: PPUSH
114521: LD_VAR 0 14
114525: PUSH
114526: LD_INT 1
114528: ARRAY
114529: PPUSH
114530: CALL_OW 120
// attacking := true ;
114534: LD_ADDR_VAR 0 29
114538: PUSH
114539: LD_INT 1
114541: ST_TO_ADDR
// continue ;
114542: GO 112717
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
114544: LD_VAR 0 26
114548: PUSH
114549: LD_VAR 0 4
114553: PUSH
114554: LD_VAR 0 7
114558: ARRAY
114559: PPUSH
114560: CALL_OW 257
114564: PUSH
114565: LD_INT 1
114567: EQUAL
114568: AND
114569: PUSH
114570: LD_VAR 0 4
114574: PUSH
114575: LD_VAR 0 7
114579: ARRAY
114580: PPUSH
114581: CALL_OW 256
114585: PUSH
114586: LD_INT 800
114588: LESS
114589: AND
114590: PUSH
114591: LD_VAR 0 4
114595: PUSH
114596: LD_VAR 0 7
114600: ARRAY
114601: PPUSH
114602: CALL_OW 318
114606: NOT
114607: AND
114608: IFFALSE 114625
// ComCrawl ( group [ i ] ) ;
114610: LD_VAR 0 4
114614: PUSH
114615: LD_VAR 0 7
114619: ARRAY
114620: PPUSH
114621: CALL_OW 137
// if f_mines then
114625: LD_VAR 0 21
114629: IFFALSE 114872
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
114631: LD_VAR 0 14
114635: PUSH
114636: LD_INT 1
114638: ARRAY
114639: PPUSH
114640: CALL_OW 247
114644: PUSH
114645: LD_INT 3
114647: EQUAL
114648: PUSH
114649: LD_VAR 0 14
114653: PUSH
114654: LD_INT 1
114656: ARRAY
114657: PUSH
114658: LD_VAR 0 27
114662: IN
114663: NOT
114664: AND
114665: IFFALSE 114872
// begin x := GetX ( tmp [ 1 ] ) ;
114667: LD_ADDR_VAR 0 10
114671: PUSH
114672: LD_VAR 0 14
114676: PUSH
114677: LD_INT 1
114679: ARRAY
114680: PPUSH
114681: CALL_OW 250
114685: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
114686: LD_ADDR_VAR 0 11
114690: PUSH
114691: LD_VAR 0 14
114695: PUSH
114696: LD_INT 1
114698: ARRAY
114699: PPUSH
114700: CALL_OW 251
114704: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
114705: LD_ADDR_VAR 0 12
114709: PUSH
114710: LD_VAR 0 4
114714: PUSH
114715: LD_VAR 0 7
114719: ARRAY
114720: PPUSH
114721: CALL 50298 0 1
114725: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
114726: LD_VAR 0 4
114730: PUSH
114731: LD_VAR 0 7
114735: ARRAY
114736: PPUSH
114737: LD_VAR 0 10
114741: PPUSH
114742: LD_VAR 0 11
114746: PPUSH
114747: LD_VAR 0 14
114751: PUSH
114752: LD_INT 1
114754: ARRAY
114755: PPUSH
114756: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
114760: LD_VAR 0 4
114764: PUSH
114765: LD_VAR 0 7
114769: ARRAY
114770: PPUSH
114771: LD_VAR 0 10
114775: PPUSH
114776: LD_VAR 0 12
114780: PPUSH
114781: LD_INT 7
114783: PPUSH
114784: CALL_OW 272
114788: PPUSH
114789: LD_VAR 0 11
114793: PPUSH
114794: LD_VAR 0 12
114798: PPUSH
114799: LD_INT 7
114801: PPUSH
114802: CALL_OW 273
114806: PPUSH
114807: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
114811: LD_VAR 0 4
114815: PUSH
114816: LD_VAR 0 7
114820: ARRAY
114821: PPUSH
114822: LD_INT 71
114824: PPUSH
114825: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
114829: LD_ADDR_VAR 0 27
114833: PUSH
114834: LD_VAR 0 27
114838: PPUSH
114839: LD_VAR 0 27
114843: PUSH
114844: LD_INT 1
114846: PLUS
114847: PPUSH
114848: LD_VAR 0 14
114852: PUSH
114853: LD_INT 1
114855: ARRAY
114856: PPUSH
114857: CALL_OW 1
114861: ST_TO_ADDR
// attacking := true ;
114862: LD_ADDR_VAR 0 29
114866: PUSH
114867: LD_INT 1
114869: ST_TO_ADDR
// continue ;
114870: GO 112717
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
114872: LD_VAR 0 4
114876: PUSH
114877: LD_VAR 0 7
114881: ARRAY
114882: PPUSH
114883: CALL_OW 257
114887: PUSH
114888: LD_INT 17
114890: EQUAL
114891: PUSH
114892: LD_VAR 0 4
114896: PUSH
114897: LD_VAR 0 7
114901: ARRAY
114902: PPUSH
114903: CALL_OW 110
114907: PUSH
114908: LD_INT 71
114910: EQUAL
114911: NOT
114912: AND
114913: IFFALSE 115059
// begin attacking := false ;
114915: LD_ADDR_VAR 0 29
114919: PUSH
114920: LD_INT 0
114922: ST_TO_ADDR
// k := 5 ;
114923: LD_ADDR_VAR 0 9
114927: PUSH
114928: LD_INT 5
114930: ST_TO_ADDR
// if tmp < k then
114931: LD_VAR 0 14
114935: PUSH
114936: LD_VAR 0 9
114940: LESS
114941: IFFALSE 114953
// k := tmp ;
114943: LD_ADDR_VAR 0 9
114947: PUSH
114948: LD_VAR 0 14
114952: ST_TO_ADDR
// for j = 1 to k do
114953: LD_ADDR_VAR 0 8
114957: PUSH
114958: DOUBLE
114959: LD_INT 1
114961: DEC
114962: ST_TO_ADDR
114963: LD_VAR 0 9
114967: PUSH
114968: FOR_TO
114969: IFFALSE 115057
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
114971: LD_VAR 0 14
114975: PUSH
114976: LD_VAR 0 8
114980: ARRAY
114981: PUSH
114982: LD_VAR 0 14
114986: PPUSH
114987: LD_INT 58
114989: PUSH
114990: EMPTY
114991: LIST
114992: PPUSH
114993: CALL_OW 72
114997: IN
114998: NOT
114999: IFFALSE 115055
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115001: LD_VAR 0 4
115005: PUSH
115006: LD_VAR 0 7
115010: ARRAY
115011: PPUSH
115012: LD_VAR 0 14
115016: PUSH
115017: LD_VAR 0 8
115021: ARRAY
115022: PPUSH
115023: CALL_OW 115
// attacking := true ;
115027: LD_ADDR_VAR 0 29
115031: PUSH
115032: LD_INT 1
115034: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115035: LD_VAR 0 4
115039: PUSH
115040: LD_VAR 0 7
115044: ARRAY
115045: PPUSH
115046: LD_INT 71
115048: PPUSH
115049: CALL_OW 109
// continue ;
115053: GO 114968
// end ; end ;
115055: GO 114968
115057: POP
115058: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115059: LD_VAR 0 4
115063: PUSH
115064: LD_VAR 0 7
115068: ARRAY
115069: PPUSH
115070: CALL_OW 257
115074: PUSH
115075: LD_INT 8
115077: EQUAL
115078: PUSH
115079: LD_VAR 0 4
115083: PUSH
115084: LD_VAR 0 7
115088: ARRAY
115089: PPUSH
115090: CALL_OW 264
115094: PUSH
115095: LD_INT 28
115097: PUSH
115098: LD_INT 45
115100: PUSH
115101: LD_INT 7
115103: PUSH
115104: LD_INT 47
115106: PUSH
115107: EMPTY
115108: LIST
115109: LIST
115110: LIST
115111: LIST
115112: IN
115113: OR
115114: IFFALSE 115370
// begin attacking := false ;
115116: LD_ADDR_VAR 0 29
115120: PUSH
115121: LD_INT 0
115123: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115124: LD_VAR 0 14
115128: PUSH
115129: LD_INT 1
115131: ARRAY
115132: PPUSH
115133: CALL_OW 266
115137: PUSH
115138: LD_INT 32
115140: PUSH
115141: LD_INT 31
115143: PUSH
115144: LD_INT 33
115146: PUSH
115147: LD_INT 4
115149: PUSH
115150: LD_INT 5
115152: PUSH
115153: EMPTY
115154: LIST
115155: LIST
115156: LIST
115157: LIST
115158: LIST
115159: IN
115160: IFFALSE 115346
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115162: LD_ADDR_VAR 0 9
115166: PUSH
115167: LD_VAR 0 14
115171: PUSH
115172: LD_INT 1
115174: ARRAY
115175: PPUSH
115176: CALL_OW 266
115180: PPUSH
115181: LD_VAR 0 14
115185: PUSH
115186: LD_INT 1
115188: ARRAY
115189: PPUSH
115190: CALL_OW 250
115194: PPUSH
115195: LD_VAR 0 14
115199: PUSH
115200: LD_INT 1
115202: ARRAY
115203: PPUSH
115204: CALL_OW 251
115208: PPUSH
115209: LD_VAR 0 14
115213: PUSH
115214: LD_INT 1
115216: ARRAY
115217: PPUSH
115218: CALL_OW 254
115222: PPUSH
115223: LD_VAR 0 14
115227: PUSH
115228: LD_INT 1
115230: ARRAY
115231: PPUSH
115232: CALL_OW 248
115236: PPUSH
115237: LD_INT 0
115239: PPUSH
115240: CALL 31668 0 6
115244: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115245: LD_ADDR_VAR 0 8
115249: PUSH
115250: LD_VAR 0 4
115254: PUSH
115255: LD_VAR 0 7
115259: ARRAY
115260: PPUSH
115261: LD_VAR 0 9
115265: PPUSH
115266: CALL 50411 0 2
115270: ST_TO_ADDR
// if j then
115271: LD_VAR 0 8
115275: IFFALSE 115344
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115277: LD_VAR 0 8
115281: PUSH
115282: LD_INT 1
115284: ARRAY
115285: PPUSH
115286: LD_VAR 0 8
115290: PUSH
115291: LD_INT 2
115293: ARRAY
115294: PPUSH
115295: CALL_OW 488
115299: IFFALSE 115344
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115301: LD_VAR 0 4
115305: PUSH
115306: LD_VAR 0 7
115310: ARRAY
115311: PPUSH
115312: LD_VAR 0 8
115316: PUSH
115317: LD_INT 1
115319: ARRAY
115320: PPUSH
115321: LD_VAR 0 8
115325: PUSH
115326: LD_INT 2
115328: ARRAY
115329: PPUSH
115330: CALL_OW 116
// attacking := true ;
115334: LD_ADDR_VAR 0 29
115338: PUSH
115339: LD_INT 1
115341: ST_TO_ADDR
// continue ;
115342: GO 112717
// end ; end else
115344: GO 115370
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115346: LD_VAR 0 4
115350: PUSH
115351: LD_VAR 0 7
115355: ARRAY
115356: PPUSH
115357: LD_VAR 0 14
115361: PUSH
115362: LD_INT 1
115364: ARRAY
115365: PPUSH
115366: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115370: LD_VAR 0 4
115374: PUSH
115375: LD_VAR 0 7
115379: ARRAY
115380: PPUSH
115381: CALL_OW 265
115385: PUSH
115386: LD_INT 11
115388: EQUAL
115389: IFFALSE 115667
// begin k := 10 ;
115391: LD_ADDR_VAR 0 9
115395: PUSH
115396: LD_INT 10
115398: ST_TO_ADDR
// x := 0 ;
115399: LD_ADDR_VAR 0 10
115403: PUSH
115404: LD_INT 0
115406: ST_TO_ADDR
// if tmp < k then
115407: LD_VAR 0 14
115411: PUSH
115412: LD_VAR 0 9
115416: LESS
115417: IFFALSE 115429
// k := tmp ;
115419: LD_ADDR_VAR 0 9
115423: PUSH
115424: LD_VAR 0 14
115428: ST_TO_ADDR
// for j = k downto 1 do
115429: LD_ADDR_VAR 0 8
115433: PUSH
115434: DOUBLE
115435: LD_VAR 0 9
115439: INC
115440: ST_TO_ADDR
115441: LD_INT 1
115443: PUSH
115444: FOR_DOWNTO
115445: IFFALSE 115520
// begin if GetType ( tmp [ j ] ) = unit_human then
115447: LD_VAR 0 14
115451: PUSH
115452: LD_VAR 0 8
115456: ARRAY
115457: PPUSH
115458: CALL_OW 247
115462: PUSH
115463: LD_INT 1
115465: EQUAL
115466: IFFALSE 115518
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115468: LD_VAR 0 4
115472: PUSH
115473: LD_VAR 0 7
115477: ARRAY
115478: PPUSH
115479: LD_VAR 0 14
115483: PUSH
115484: LD_VAR 0 8
115488: ARRAY
115489: PPUSH
115490: CALL 50665 0 2
// x := tmp [ j ] ;
115494: LD_ADDR_VAR 0 10
115498: PUSH
115499: LD_VAR 0 14
115503: PUSH
115504: LD_VAR 0 8
115508: ARRAY
115509: ST_TO_ADDR
// attacking := true ;
115510: LD_ADDR_VAR 0 29
115514: PUSH
115515: LD_INT 1
115517: ST_TO_ADDR
// end ; end ;
115518: GO 115444
115520: POP
115521: POP
// if not x then
115522: LD_VAR 0 10
115526: NOT
115527: IFFALSE 115667
// begin attacking := true ;
115529: LD_ADDR_VAR 0 29
115533: PUSH
115534: LD_INT 1
115536: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
115537: LD_VAR 0 4
115541: PUSH
115542: LD_VAR 0 7
115546: ARRAY
115547: PPUSH
115548: CALL_OW 250
115552: PPUSH
115553: LD_VAR 0 4
115557: PUSH
115558: LD_VAR 0 7
115562: ARRAY
115563: PPUSH
115564: CALL_OW 251
115568: PPUSH
115569: CALL_OW 546
115573: PUSH
115574: LD_INT 2
115576: ARRAY
115577: PUSH
115578: LD_VAR 0 14
115582: PUSH
115583: LD_INT 1
115585: ARRAY
115586: PPUSH
115587: CALL_OW 250
115591: PPUSH
115592: LD_VAR 0 14
115596: PUSH
115597: LD_INT 1
115599: ARRAY
115600: PPUSH
115601: CALL_OW 251
115605: PPUSH
115606: CALL_OW 546
115610: PUSH
115611: LD_INT 2
115613: ARRAY
115614: EQUAL
115615: IFFALSE 115643
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
115617: LD_VAR 0 4
115621: PUSH
115622: LD_VAR 0 7
115626: ARRAY
115627: PPUSH
115628: LD_VAR 0 14
115632: PUSH
115633: LD_INT 1
115635: ARRAY
115636: PPUSH
115637: CALL 50665 0 2
115641: GO 115667
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115643: LD_VAR 0 4
115647: PUSH
115648: LD_VAR 0 7
115652: ARRAY
115653: PPUSH
115654: LD_VAR 0 14
115658: PUSH
115659: LD_INT 1
115661: ARRAY
115662: PPUSH
115663: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
115667: LD_VAR 0 4
115671: PUSH
115672: LD_VAR 0 7
115676: ARRAY
115677: PPUSH
115678: CALL_OW 264
115682: PUSH
115683: LD_INT 29
115685: EQUAL
115686: IFFALSE 116052
// begin if WantsToAttack ( group [ i ] ) in bombed then
115688: LD_VAR 0 4
115692: PUSH
115693: LD_VAR 0 7
115697: ARRAY
115698: PPUSH
115699: CALL_OW 319
115703: PUSH
115704: LD_VAR 0 28
115708: IN
115709: IFFALSE 115713
// continue ;
115711: GO 112717
// k := 8 ;
115713: LD_ADDR_VAR 0 9
115717: PUSH
115718: LD_INT 8
115720: ST_TO_ADDR
// x := 0 ;
115721: LD_ADDR_VAR 0 10
115725: PUSH
115726: LD_INT 0
115728: ST_TO_ADDR
// if tmp < k then
115729: LD_VAR 0 14
115733: PUSH
115734: LD_VAR 0 9
115738: LESS
115739: IFFALSE 115751
// k := tmp ;
115741: LD_ADDR_VAR 0 9
115745: PUSH
115746: LD_VAR 0 14
115750: ST_TO_ADDR
// for j = 1 to k do
115751: LD_ADDR_VAR 0 8
115755: PUSH
115756: DOUBLE
115757: LD_INT 1
115759: DEC
115760: ST_TO_ADDR
115761: LD_VAR 0 9
115765: PUSH
115766: FOR_TO
115767: IFFALSE 115899
// begin if GetType ( tmp [ j ] ) = unit_building then
115769: LD_VAR 0 14
115773: PUSH
115774: LD_VAR 0 8
115778: ARRAY
115779: PPUSH
115780: CALL_OW 247
115784: PUSH
115785: LD_INT 3
115787: EQUAL
115788: IFFALSE 115897
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
115790: LD_VAR 0 14
115794: PUSH
115795: LD_VAR 0 8
115799: ARRAY
115800: PUSH
115801: LD_VAR 0 28
115805: IN
115806: NOT
115807: PUSH
115808: LD_VAR 0 14
115812: PUSH
115813: LD_VAR 0 8
115817: ARRAY
115818: PPUSH
115819: CALL_OW 313
115823: AND
115824: IFFALSE 115897
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115826: LD_VAR 0 4
115830: PUSH
115831: LD_VAR 0 7
115835: ARRAY
115836: PPUSH
115837: LD_VAR 0 14
115841: PUSH
115842: LD_VAR 0 8
115846: ARRAY
115847: PPUSH
115848: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
115852: LD_ADDR_VAR 0 28
115856: PUSH
115857: LD_VAR 0 28
115861: PPUSH
115862: LD_VAR 0 28
115866: PUSH
115867: LD_INT 1
115869: PLUS
115870: PPUSH
115871: LD_VAR 0 14
115875: PUSH
115876: LD_VAR 0 8
115880: ARRAY
115881: PPUSH
115882: CALL_OW 1
115886: ST_TO_ADDR
// attacking := true ;
115887: LD_ADDR_VAR 0 29
115891: PUSH
115892: LD_INT 1
115894: ST_TO_ADDR
// break ;
115895: GO 115899
// end ; end ;
115897: GO 115766
115899: POP
115900: POP
// if not attacking and f_attack_depot then
115901: LD_VAR 0 29
115905: NOT
115906: PUSH
115907: LD_VAR 0 25
115911: AND
115912: IFFALSE 116007
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115914: LD_ADDR_VAR 0 13
115918: PUSH
115919: LD_VAR 0 14
115923: PPUSH
115924: LD_INT 2
115926: PUSH
115927: LD_INT 30
115929: PUSH
115930: LD_INT 0
115932: PUSH
115933: EMPTY
115934: LIST
115935: LIST
115936: PUSH
115937: LD_INT 30
115939: PUSH
115940: LD_INT 1
115942: PUSH
115943: EMPTY
115944: LIST
115945: LIST
115946: PUSH
115947: EMPTY
115948: LIST
115949: LIST
115950: LIST
115951: PPUSH
115952: CALL_OW 72
115956: ST_TO_ADDR
// if z then
115957: LD_VAR 0 13
115961: IFFALSE 116007
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
115963: LD_VAR 0 4
115967: PUSH
115968: LD_VAR 0 7
115972: ARRAY
115973: PPUSH
115974: LD_VAR 0 13
115978: PPUSH
115979: LD_VAR 0 4
115983: PUSH
115984: LD_VAR 0 7
115988: ARRAY
115989: PPUSH
115990: CALL_OW 74
115994: PPUSH
115995: CALL_OW 115
// attacking := true ;
115999: LD_ADDR_VAR 0 29
116003: PUSH
116004: LD_INT 1
116006: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116007: LD_VAR 0 4
116011: PUSH
116012: LD_VAR 0 7
116016: ARRAY
116017: PPUSH
116018: CALL_OW 256
116022: PUSH
116023: LD_INT 500
116025: LESS
116026: IFFALSE 116052
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116028: LD_VAR 0 4
116032: PUSH
116033: LD_VAR 0 7
116037: ARRAY
116038: PPUSH
116039: LD_VAR 0 14
116043: PUSH
116044: LD_INT 1
116046: ARRAY
116047: PPUSH
116048: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116052: LD_VAR 0 4
116056: PUSH
116057: LD_VAR 0 7
116061: ARRAY
116062: PPUSH
116063: CALL_OW 264
116067: PUSH
116068: LD_INT 49
116070: EQUAL
116071: IFFALSE 116192
// begin if not HasTask ( group [ i ] ) then
116073: LD_VAR 0 4
116077: PUSH
116078: LD_VAR 0 7
116082: ARRAY
116083: PPUSH
116084: CALL_OW 314
116088: NOT
116089: IFFALSE 116192
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116091: LD_ADDR_VAR 0 9
116095: PUSH
116096: LD_INT 81
116098: PUSH
116099: LD_VAR 0 4
116103: PUSH
116104: LD_VAR 0 7
116108: ARRAY
116109: PPUSH
116110: CALL_OW 255
116114: PUSH
116115: EMPTY
116116: LIST
116117: LIST
116118: PPUSH
116119: CALL_OW 69
116123: PPUSH
116124: LD_VAR 0 4
116128: PUSH
116129: LD_VAR 0 7
116133: ARRAY
116134: PPUSH
116135: CALL_OW 74
116139: ST_TO_ADDR
// if k then
116140: LD_VAR 0 9
116144: IFFALSE 116192
// if GetDistUnits ( group [ i ] , k ) > 10 then
116146: LD_VAR 0 4
116150: PUSH
116151: LD_VAR 0 7
116155: ARRAY
116156: PPUSH
116157: LD_VAR 0 9
116161: PPUSH
116162: CALL_OW 296
116166: PUSH
116167: LD_INT 10
116169: GREATER
116170: IFFALSE 116192
// ComMoveUnit ( group [ i ] , k ) ;
116172: LD_VAR 0 4
116176: PUSH
116177: LD_VAR 0 7
116181: ARRAY
116182: PPUSH
116183: LD_VAR 0 9
116187: PPUSH
116188: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116192: LD_VAR 0 4
116196: PUSH
116197: LD_VAR 0 7
116201: ARRAY
116202: PPUSH
116203: CALL_OW 256
116207: PUSH
116208: LD_INT 250
116210: LESS
116211: PUSH
116212: LD_VAR 0 4
116216: PUSH
116217: LD_VAR 0 7
116221: ARRAY
116222: PUSH
116223: LD_INT 21
116225: PUSH
116226: LD_INT 2
116228: PUSH
116229: EMPTY
116230: LIST
116231: LIST
116232: PUSH
116233: LD_INT 23
116235: PUSH
116236: LD_INT 2
116238: PUSH
116239: EMPTY
116240: LIST
116241: LIST
116242: PUSH
116243: EMPTY
116244: LIST
116245: LIST
116246: PPUSH
116247: CALL_OW 69
116251: IN
116252: AND
116253: IFFALSE 116378
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116255: LD_ADDR_VAR 0 9
116259: PUSH
116260: LD_OWVAR 3
116264: PUSH
116265: LD_VAR 0 4
116269: PUSH
116270: LD_VAR 0 7
116274: ARRAY
116275: DIFF
116276: PPUSH
116277: LD_VAR 0 4
116281: PUSH
116282: LD_VAR 0 7
116286: ARRAY
116287: PPUSH
116288: CALL_OW 74
116292: ST_TO_ADDR
// if not k then
116293: LD_VAR 0 9
116297: NOT
116298: IFFALSE 116302
// continue ;
116300: GO 112717
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116302: LD_VAR 0 9
116306: PUSH
116307: LD_INT 81
116309: PUSH
116310: LD_VAR 0 4
116314: PUSH
116315: LD_VAR 0 7
116319: ARRAY
116320: PPUSH
116321: CALL_OW 255
116325: PUSH
116326: EMPTY
116327: LIST
116328: LIST
116329: PPUSH
116330: CALL_OW 69
116334: IN
116335: PUSH
116336: LD_VAR 0 9
116340: PPUSH
116341: LD_VAR 0 4
116345: PUSH
116346: LD_VAR 0 7
116350: ARRAY
116351: PPUSH
116352: CALL_OW 296
116356: PUSH
116357: LD_INT 5
116359: LESS
116360: AND
116361: IFFALSE 116378
// ComAutodestruct ( group [ i ] ) ;
116363: LD_VAR 0 4
116367: PUSH
116368: LD_VAR 0 7
116372: ARRAY
116373: PPUSH
116374: CALL 50563 0 1
// end ; if f_attack_depot then
116378: LD_VAR 0 25
116382: IFFALSE 116494
// begin k := 6 ;
116384: LD_ADDR_VAR 0 9
116388: PUSH
116389: LD_INT 6
116391: ST_TO_ADDR
// if tmp < k then
116392: LD_VAR 0 14
116396: PUSH
116397: LD_VAR 0 9
116401: LESS
116402: IFFALSE 116414
// k := tmp ;
116404: LD_ADDR_VAR 0 9
116408: PUSH
116409: LD_VAR 0 14
116413: ST_TO_ADDR
// for j = 1 to k do
116414: LD_ADDR_VAR 0 8
116418: PUSH
116419: DOUBLE
116420: LD_INT 1
116422: DEC
116423: ST_TO_ADDR
116424: LD_VAR 0 9
116428: PUSH
116429: FOR_TO
116430: IFFALSE 116492
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116432: LD_VAR 0 8
116436: PPUSH
116437: CALL_OW 266
116441: PUSH
116442: LD_INT 0
116444: PUSH
116445: LD_INT 1
116447: PUSH
116448: EMPTY
116449: LIST
116450: LIST
116451: IN
116452: IFFALSE 116490
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116454: LD_VAR 0 4
116458: PUSH
116459: LD_VAR 0 7
116463: ARRAY
116464: PPUSH
116465: LD_VAR 0 14
116469: PUSH
116470: LD_VAR 0 8
116474: ARRAY
116475: PPUSH
116476: CALL_OW 115
// attacking := true ;
116480: LD_ADDR_VAR 0 29
116484: PUSH
116485: LD_INT 1
116487: ST_TO_ADDR
// break ;
116488: GO 116492
// end ;
116490: GO 116429
116492: POP
116493: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116494: LD_VAR 0 4
116498: PUSH
116499: LD_VAR 0 7
116503: ARRAY
116504: PPUSH
116505: CALL_OW 302
116509: PUSH
116510: LD_VAR 0 29
116514: NOT
116515: AND
116516: IFFALSE 116838
// begin if GetTag ( group [ i ] ) = 71 then
116518: LD_VAR 0 4
116522: PUSH
116523: LD_VAR 0 7
116527: ARRAY
116528: PPUSH
116529: CALL_OW 110
116533: PUSH
116534: LD_INT 71
116536: EQUAL
116537: IFFALSE 116578
// begin if HasTask ( group [ i ] ) then
116539: LD_VAR 0 4
116543: PUSH
116544: LD_VAR 0 7
116548: ARRAY
116549: PPUSH
116550: CALL_OW 314
116554: IFFALSE 116560
// continue else
116556: GO 112717
116558: GO 116578
// SetTag ( group [ i ] , 0 ) ;
116560: LD_VAR 0 4
116564: PUSH
116565: LD_VAR 0 7
116569: ARRAY
116570: PPUSH
116571: LD_INT 0
116573: PPUSH
116574: CALL_OW 109
// end ; k := 8 ;
116578: LD_ADDR_VAR 0 9
116582: PUSH
116583: LD_INT 8
116585: ST_TO_ADDR
// x := 0 ;
116586: LD_ADDR_VAR 0 10
116590: PUSH
116591: LD_INT 0
116593: ST_TO_ADDR
// if tmp < k then
116594: LD_VAR 0 14
116598: PUSH
116599: LD_VAR 0 9
116603: LESS
116604: IFFALSE 116616
// k := tmp ;
116606: LD_ADDR_VAR 0 9
116610: PUSH
116611: LD_VAR 0 14
116615: ST_TO_ADDR
// for j = 1 to k do
116616: LD_ADDR_VAR 0 8
116620: PUSH
116621: DOUBLE
116622: LD_INT 1
116624: DEC
116625: ST_TO_ADDR
116626: LD_VAR 0 9
116630: PUSH
116631: FOR_TO
116632: IFFALSE 116730
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
116634: LD_VAR 0 14
116638: PUSH
116639: LD_VAR 0 8
116643: ARRAY
116644: PPUSH
116645: CALL_OW 247
116649: PUSH
116650: LD_INT 1
116652: EQUAL
116653: PUSH
116654: LD_VAR 0 14
116658: PUSH
116659: LD_VAR 0 8
116663: ARRAY
116664: PPUSH
116665: CALL_OW 256
116669: PUSH
116670: LD_INT 250
116672: LESS
116673: PUSH
116674: LD_VAR 0 20
116678: AND
116679: PUSH
116680: LD_VAR 0 20
116684: NOT
116685: PUSH
116686: LD_VAR 0 14
116690: PUSH
116691: LD_VAR 0 8
116695: ARRAY
116696: PPUSH
116697: CALL_OW 256
116701: PUSH
116702: LD_INT 250
116704: GREATEREQUAL
116705: AND
116706: OR
116707: AND
116708: IFFALSE 116728
// begin x := tmp [ j ] ;
116710: LD_ADDR_VAR 0 10
116714: PUSH
116715: LD_VAR 0 14
116719: PUSH
116720: LD_VAR 0 8
116724: ARRAY
116725: ST_TO_ADDR
// break ;
116726: GO 116730
// end ;
116728: GO 116631
116730: POP
116731: POP
// if x then
116732: LD_VAR 0 10
116736: IFFALSE 116760
// ComAttackUnit ( group [ i ] , x ) else
116738: LD_VAR 0 4
116742: PUSH
116743: LD_VAR 0 7
116747: ARRAY
116748: PPUSH
116749: LD_VAR 0 10
116753: PPUSH
116754: CALL_OW 115
116758: GO 116784
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116760: LD_VAR 0 4
116764: PUSH
116765: LD_VAR 0 7
116769: ARRAY
116770: PPUSH
116771: LD_VAR 0 14
116775: PUSH
116776: LD_INT 1
116778: ARRAY
116779: PPUSH
116780: CALL_OW 115
// if not HasTask ( group [ i ] ) then
116784: LD_VAR 0 4
116788: PUSH
116789: LD_VAR 0 7
116793: ARRAY
116794: PPUSH
116795: CALL_OW 314
116799: NOT
116800: IFFALSE 116838
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
116802: LD_VAR 0 4
116806: PUSH
116807: LD_VAR 0 7
116811: ARRAY
116812: PPUSH
116813: LD_VAR 0 14
116817: PPUSH
116818: LD_VAR 0 4
116822: PUSH
116823: LD_VAR 0 7
116827: ARRAY
116828: PPUSH
116829: CALL_OW 74
116833: PPUSH
116834: CALL_OW 115
// end ; end ; end ;
116838: GO 112717
116840: POP
116841: POP
// wait ( 0 0$2 ) ;
116842: LD_INT 70
116844: PPUSH
116845: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
116849: LD_VAR 0 4
116853: NOT
116854: PUSH
116855: LD_VAR 0 4
116859: PUSH
116860: EMPTY
116861: EQUAL
116862: OR
116863: PUSH
116864: LD_INT 81
116866: PUSH
116867: LD_VAR 0 35
116871: PUSH
116872: EMPTY
116873: LIST
116874: LIST
116875: PPUSH
116876: CALL_OW 69
116880: NOT
116881: OR
116882: IFFALSE 112702
// end ;
116884: LD_VAR 0 2
116888: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
116889: LD_INT 0
116891: PPUSH
116892: PPUSH
116893: PPUSH
116894: PPUSH
116895: PPUSH
116896: PPUSH
// if not base or not mc_bases [ base ] or not solds then
116897: LD_VAR 0 1
116901: NOT
116902: PUSH
116903: LD_EXP 63
116907: PUSH
116908: LD_VAR 0 1
116912: ARRAY
116913: NOT
116914: OR
116915: PUSH
116916: LD_VAR 0 2
116920: NOT
116921: OR
116922: IFFALSE 116926
// exit ;
116924: GO 117480
// side := mc_sides [ base ] ;
116926: LD_ADDR_VAR 0 6
116930: PUSH
116931: LD_EXP 89
116935: PUSH
116936: LD_VAR 0 1
116940: ARRAY
116941: ST_TO_ADDR
// if not side then
116942: LD_VAR 0 6
116946: NOT
116947: IFFALSE 116951
// exit ;
116949: GO 117480
// for i in solds do
116951: LD_ADDR_VAR 0 7
116955: PUSH
116956: LD_VAR 0 2
116960: PUSH
116961: FOR_IN
116962: IFFALSE 117023
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
116964: LD_VAR 0 7
116968: PPUSH
116969: CALL_OW 310
116973: PPUSH
116974: CALL_OW 266
116978: PUSH
116979: LD_INT 32
116981: PUSH
116982: LD_INT 31
116984: PUSH
116985: EMPTY
116986: LIST
116987: LIST
116988: IN
116989: IFFALSE 117009
// solds := solds diff i else
116991: LD_ADDR_VAR 0 2
116995: PUSH
116996: LD_VAR 0 2
117000: PUSH
117001: LD_VAR 0 7
117005: DIFF
117006: ST_TO_ADDR
117007: GO 117021
// SetTag ( i , 18 ) ;
117009: LD_VAR 0 7
117013: PPUSH
117014: LD_INT 18
117016: PPUSH
117017: CALL_OW 109
117021: GO 116961
117023: POP
117024: POP
// if not solds then
117025: LD_VAR 0 2
117029: NOT
117030: IFFALSE 117034
// exit ;
117032: GO 117480
// repeat wait ( 0 0$2 ) ;
117034: LD_INT 70
117036: PPUSH
117037: CALL_OW 67
// enemy := mc_scan [ base ] ;
117041: LD_ADDR_VAR 0 4
117045: PUSH
117046: LD_EXP 86
117050: PUSH
117051: LD_VAR 0 1
117055: ARRAY
117056: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117057: LD_EXP 63
117061: PUSH
117062: LD_VAR 0 1
117066: ARRAY
117067: NOT
117068: PUSH
117069: LD_EXP 63
117073: PUSH
117074: LD_VAR 0 1
117078: ARRAY
117079: PUSH
117080: EMPTY
117081: EQUAL
117082: OR
117083: IFFALSE 117120
// begin for i in solds do
117085: LD_ADDR_VAR 0 7
117089: PUSH
117090: LD_VAR 0 2
117094: PUSH
117095: FOR_IN
117096: IFFALSE 117109
// ComStop ( i ) ;
117098: LD_VAR 0 7
117102: PPUSH
117103: CALL_OW 141
117107: GO 117095
117109: POP
117110: POP
// solds := [ ] ;
117111: LD_ADDR_VAR 0 2
117115: PUSH
117116: EMPTY
117117: ST_TO_ADDR
// exit ;
117118: GO 117480
// end ; for i in solds do
117120: LD_ADDR_VAR 0 7
117124: PUSH
117125: LD_VAR 0 2
117129: PUSH
117130: FOR_IN
117131: IFFALSE 117452
// begin if IsInUnit ( i ) then
117133: LD_VAR 0 7
117137: PPUSH
117138: CALL_OW 310
117142: IFFALSE 117153
// ComExitBuilding ( i ) ;
117144: LD_VAR 0 7
117148: PPUSH
117149: CALL_OW 122
// if GetLives ( i ) > 500 then
117153: LD_VAR 0 7
117157: PPUSH
117158: CALL_OW 256
117162: PUSH
117163: LD_INT 500
117165: GREATER
117166: IFFALSE 117219
// begin e := NearestUnitToUnit ( enemy , i ) ;
117168: LD_ADDR_VAR 0 5
117172: PUSH
117173: LD_VAR 0 4
117177: PPUSH
117178: LD_VAR 0 7
117182: PPUSH
117183: CALL_OW 74
117187: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117188: LD_VAR 0 7
117192: PPUSH
117193: LD_VAR 0 5
117197: PPUSH
117198: CALL_OW 250
117202: PPUSH
117203: LD_VAR 0 5
117207: PPUSH
117208: CALL_OW 251
117212: PPUSH
117213: CALL_OW 114
// end else
117217: GO 117450
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117219: LD_VAR 0 7
117223: PPUSH
117224: LD_EXP 63
117228: PUSH
117229: LD_VAR 0 1
117233: ARRAY
117234: PPUSH
117235: LD_INT 2
117237: PUSH
117238: LD_INT 30
117240: PUSH
117241: LD_INT 0
117243: PUSH
117244: EMPTY
117245: LIST
117246: LIST
117247: PUSH
117248: LD_INT 30
117250: PUSH
117251: LD_INT 1
117253: PUSH
117254: EMPTY
117255: LIST
117256: LIST
117257: PUSH
117258: LD_INT 30
117260: PUSH
117261: LD_INT 6
117263: PUSH
117264: EMPTY
117265: LIST
117266: LIST
117267: PUSH
117268: EMPTY
117269: LIST
117270: LIST
117271: LIST
117272: LIST
117273: PPUSH
117274: CALL_OW 72
117278: PPUSH
117279: LD_VAR 0 7
117283: PPUSH
117284: CALL_OW 74
117288: PPUSH
117289: CALL_OW 296
117293: PUSH
117294: LD_INT 10
117296: GREATER
117297: IFFALSE 117450
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117299: LD_ADDR_VAR 0 8
117303: PUSH
117304: LD_EXP 63
117308: PUSH
117309: LD_VAR 0 1
117313: ARRAY
117314: PPUSH
117315: LD_INT 2
117317: PUSH
117318: LD_INT 30
117320: PUSH
117321: LD_INT 0
117323: PUSH
117324: EMPTY
117325: LIST
117326: LIST
117327: PUSH
117328: LD_INT 30
117330: PUSH
117331: LD_INT 1
117333: PUSH
117334: EMPTY
117335: LIST
117336: LIST
117337: PUSH
117338: LD_INT 30
117340: PUSH
117341: LD_INT 6
117343: PUSH
117344: EMPTY
117345: LIST
117346: LIST
117347: PUSH
117348: EMPTY
117349: LIST
117350: LIST
117351: LIST
117352: LIST
117353: PPUSH
117354: CALL_OW 72
117358: PPUSH
117359: LD_VAR 0 7
117363: PPUSH
117364: CALL_OW 74
117368: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117369: LD_VAR 0 7
117373: PPUSH
117374: LD_VAR 0 8
117378: PPUSH
117379: CALL_OW 250
117383: PPUSH
117384: LD_INT 3
117386: PPUSH
117387: LD_INT 5
117389: PPUSH
117390: CALL_OW 272
117394: PPUSH
117395: LD_VAR 0 8
117399: PPUSH
117400: CALL_OW 251
117404: PPUSH
117405: LD_INT 3
117407: PPUSH
117408: LD_INT 5
117410: PPUSH
117411: CALL_OW 273
117415: PPUSH
117416: CALL_OW 111
// SetTag ( i , 0 ) ;
117420: LD_VAR 0 7
117424: PPUSH
117425: LD_INT 0
117427: PPUSH
117428: CALL_OW 109
// solds := solds diff i ;
117432: LD_ADDR_VAR 0 2
117436: PUSH
117437: LD_VAR 0 2
117441: PUSH
117442: LD_VAR 0 7
117446: DIFF
117447: ST_TO_ADDR
// continue ;
117448: GO 117130
// end ; end ;
117450: GO 117130
117452: POP
117453: POP
// until not solds or not enemy ;
117454: LD_VAR 0 2
117458: NOT
117459: PUSH
117460: LD_VAR 0 4
117464: NOT
117465: OR
117466: IFFALSE 117034
// MC_Reset ( base , 18 ) ;
117468: LD_VAR 0 1
117472: PPUSH
117473: LD_INT 18
117475: PPUSH
117476: CALL 64330 0 2
// end ;
117480: LD_VAR 0 3
117484: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117485: LD_INT 0
117487: PPUSH
117488: PPUSH
117489: PPUSH
117490: PPUSH
117491: PPUSH
117492: PPUSH
117493: PPUSH
117494: PPUSH
117495: PPUSH
117496: PPUSH
117497: PPUSH
117498: PPUSH
117499: PPUSH
117500: PPUSH
117501: PPUSH
117502: PPUSH
117503: PPUSH
117504: PPUSH
117505: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117506: LD_ADDR_VAR 0 12
117510: PUSH
117511: LD_EXP 63
117515: PUSH
117516: LD_VAR 0 1
117520: ARRAY
117521: PPUSH
117522: LD_INT 25
117524: PUSH
117525: LD_INT 3
117527: PUSH
117528: EMPTY
117529: LIST
117530: LIST
117531: PPUSH
117532: CALL_OW 72
117536: ST_TO_ADDR
// if mc_remote_driver [ base ] then
117537: LD_EXP 103
117541: PUSH
117542: LD_VAR 0 1
117546: ARRAY
117547: IFFALSE 117571
// mechs := mechs diff mc_remote_driver [ base ] ;
117549: LD_ADDR_VAR 0 12
117553: PUSH
117554: LD_VAR 0 12
117558: PUSH
117559: LD_EXP 103
117563: PUSH
117564: LD_VAR 0 1
117568: ARRAY
117569: DIFF
117570: ST_TO_ADDR
// for i in mechs do
117571: LD_ADDR_VAR 0 4
117575: PUSH
117576: LD_VAR 0 12
117580: PUSH
117581: FOR_IN
117582: IFFALSE 117617
// if GetTag ( i ) > 0 then
117584: LD_VAR 0 4
117588: PPUSH
117589: CALL_OW 110
117593: PUSH
117594: LD_INT 0
117596: GREATER
117597: IFFALSE 117615
// mechs := mechs diff i ;
117599: LD_ADDR_VAR 0 12
117603: PUSH
117604: LD_VAR 0 12
117608: PUSH
117609: LD_VAR 0 4
117613: DIFF
117614: ST_TO_ADDR
117615: GO 117581
117617: POP
117618: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117619: LD_ADDR_VAR 0 8
117623: PUSH
117624: LD_EXP 63
117628: PUSH
117629: LD_VAR 0 1
117633: ARRAY
117634: PPUSH
117635: LD_INT 2
117637: PUSH
117638: LD_INT 25
117640: PUSH
117641: LD_INT 1
117643: PUSH
117644: EMPTY
117645: LIST
117646: LIST
117647: PUSH
117648: LD_INT 25
117650: PUSH
117651: LD_INT 5
117653: PUSH
117654: EMPTY
117655: LIST
117656: LIST
117657: PUSH
117658: LD_INT 25
117660: PUSH
117661: LD_INT 8
117663: PUSH
117664: EMPTY
117665: LIST
117666: LIST
117667: PUSH
117668: LD_INT 25
117670: PUSH
117671: LD_INT 9
117673: PUSH
117674: EMPTY
117675: LIST
117676: LIST
117677: PUSH
117678: EMPTY
117679: LIST
117680: LIST
117681: LIST
117682: LIST
117683: LIST
117684: PPUSH
117685: CALL_OW 72
117689: ST_TO_ADDR
// if not defenders and not solds then
117690: LD_VAR 0 2
117694: NOT
117695: PUSH
117696: LD_VAR 0 8
117700: NOT
117701: AND
117702: IFFALSE 117706
// exit ;
117704: GO 119476
// depot_under_attack := false ;
117706: LD_ADDR_VAR 0 16
117710: PUSH
117711: LD_INT 0
117713: ST_TO_ADDR
// sold_defenders := [ ] ;
117714: LD_ADDR_VAR 0 17
117718: PUSH
117719: EMPTY
117720: ST_TO_ADDR
// if mechs then
117721: LD_VAR 0 12
117725: IFFALSE 117878
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
117727: LD_ADDR_VAR 0 4
117731: PUSH
117732: LD_VAR 0 2
117736: PPUSH
117737: LD_INT 21
117739: PUSH
117740: LD_INT 2
117742: PUSH
117743: EMPTY
117744: LIST
117745: LIST
117746: PPUSH
117747: CALL_OW 72
117751: PUSH
117752: FOR_IN
117753: IFFALSE 117876
// begin if GetTag ( i ) <> 20 then
117755: LD_VAR 0 4
117759: PPUSH
117760: CALL_OW 110
117764: PUSH
117765: LD_INT 20
117767: NONEQUAL
117768: IFFALSE 117782
// SetTag ( i , 20 ) ;
117770: LD_VAR 0 4
117774: PPUSH
117775: LD_INT 20
117777: PPUSH
117778: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
117782: LD_VAR 0 4
117786: PPUSH
117787: CALL_OW 263
117791: PUSH
117792: LD_INT 1
117794: EQUAL
117795: PUSH
117796: LD_VAR 0 4
117800: PPUSH
117801: CALL_OW 311
117805: NOT
117806: AND
117807: IFFALSE 117874
// begin un := mechs [ 1 ] ;
117809: LD_ADDR_VAR 0 10
117813: PUSH
117814: LD_VAR 0 12
117818: PUSH
117819: LD_INT 1
117821: ARRAY
117822: ST_TO_ADDR
// ComExit ( un ) ;
117823: LD_VAR 0 10
117827: PPUSH
117828: CALL 55469 0 1
// AddComEnterUnit ( un , i ) ;
117832: LD_VAR 0 10
117836: PPUSH
117837: LD_VAR 0 4
117841: PPUSH
117842: CALL_OW 180
// SetTag ( un , 19 ) ;
117846: LD_VAR 0 10
117850: PPUSH
117851: LD_INT 19
117853: PPUSH
117854: CALL_OW 109
// mechs := mechs diff un ;
117858: LD_ADDR_VAR 0 12
117862: PUSH
117863: LD_VAR 0 12
117867: PUSH
117868: LD_VAR 0 10
117872: DIFF
117873: ST_TO_ADDR
// end ; end ;
117874: GO 117752
117876: POP
117877: POP
// if solds then
117878: LD_VAR 0 8
117882: IFFALSE 117941
// for i in solds do
117884: LD_ADDR_VAR 0 4
117888: PUSH
117889: LD_VAR 0 8
117893: PUSH
117894: FOR_IN
117895: IFFALSE 117939
// if not GetTag ( i ) then
117897: LD_VAR 0 4
117901: PPUSH
117902: CALL_OW 110
117906: NOT
117907: IFFALSE 117937
// begin defenders := defenders union i ;
117909: LD_ADDR_VAR 0 2
117913: PUSH
117914: LD_VAR 0 2
117918: PUSH
117919: LD_VAR 0 4
117923: UNION
117924: ST_TO_ADDR
// SetTag ( i , 18 ) ;
117925: LD_VAR 0 4
117929: PPUSH
117930: LD_INT 18
117932: PPUSH
117933: CALL_OW 109
// end ;
117937: GO 117894
117939: POP
117940: POP
// repeat wait ( 0 0$2 ) ;
117941: LD_INT 70
117943: PPUSH
117944: CALL_OW 67
// enemy := mc_scan [ base ] ;
117948: LD_ADDR_VAR 0 21
117952: PUSH
117953: LD_EXP 86
117957: PUSH
117958: LD_VAR 0 1
117962: ARRAY
117963: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117964: LD_EXP 63
117968: PUSH
117969: LD_VAR 0 1
117973: ARRAY
117974: NOT
117975: PUSH
117976: LD_EXP 63
117980: PUSH
117981: LD_VAR 0 1
117985: ARRAY
117986: PUSH
117987: EMPTY
117988: EQUAL
117989: OR
117990: IFFALSE 118027
// begin for i in defenders do
117992: LD_ADDR_VAR 0 4
117996: PUSH
117997: LD_VAR 0 2
118001: PUSH
118002: FOR_IN
118003: IFFALSE 118016
// ComStop ( i ) ;
118005: LD_VAR 0 4
118009: PPUSH
118010: CALL_OW 141
118014: GO 118002
118016: POP
118017: POP
// defenders := [ ] ;
118018: LD_ADDR_VAR 0 2
118022: PUSH
118023: EMPTY
118024: ST_TO_ADDR
// exit ;
118025: GO 119476
// end ; for i in defenders do
118027: LD_ADDR_VAR 0 4
118031: PUSH
118032: LD_VAR 0 2
118036: PUSH
118037: FOR_IN
118038: IFFALSE 118936
// begin e := NearestUnitToUnit ( enemy , i ) ;
118040: LD_ADDR_VAR 0 13
118044: PUSH
118045: LD_VAR 0 21
118049: PPUSH
118050: LD_VAR 0 4
118054: PPUSH
118055: CALL_OW 74
118059: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118060: LD_ADDR_VAR 0 7
118064: PUSH
118065: LD_EXP 63
118069: PUSH
118070: LD_VAR 0 1
118074: ARRAY
118075: PPUSH
118076: LD_INT 2
118078: PUSH
118079: LD_INT 30
118081: PUSH
118082: LD_INT 0
118084: PUSH
118085: EMPTY
118086: LIST
118087: LIST
118088: PUSH
118089: LD_INT 30
118091: PUSH
118092: LD_INT 1
118094: PUSH
118095: EMPTY
118096: LIST
118097: LIST
118098: PUSH
118099: EMPTY
118100: LIST
118101: LIST
118102: LIST
118103: PPUSH
118104: CALL_OW 72
118108: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118109: LD_ADDR_VAR 0 16
118113: PUSH
118114: LD_VAR 0 7
118118: NOT
118119: PUSH
118120: LD_VAR 0 7
118124: PPUSH
118125: LD_INT 3
118127: PUSH
118128: LD_INT 24
118130: PUSH
118131: LD_INT 600
118133: PUSH
118134: EMPTY
118135: LIST
118136: LIST
118137: PUSH
118138: EMPTY
118139: LIST
118140: LIST
118141: PPUSH
118142: CALL_OW 72
118146: OR
118147: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118148: LD_VAR 0 4
118152: PPUSH
118153: CALL_OW 247
118157: PUSH
118158: LD_INT 2
118160: DOUBLE
118161: EQUAL
118162: IFTRUE 118166
118164: GO 118562
118166: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118167: LD_VAR 0 4
118171: PPUSH
118172: CALL_OW 256
118176: PUSH
118177: LD_INT 1000
118179: EQUAL
118180: PUSH
118181: LD_VAR 0 4
118185: PPUSH
118186: LD_VAR 0 13
118190: PPUSH
118191: CALL_OW 296
118195: PUSH
118196: LD_INT 40
118198: LESS
118199: PUSH
118200: LD_VAR 0 13
118204: PPUSH
118205: LD_EXP 88
118209: PUSH
118210: LD_VAR 0 1
118214: ARRAY
118215: PPUSH
118216: CALL_OW 308
118220: OR
118221: AND
118222: IFFALSE 118344
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118224: LD_VAR 0 4
118228: PPUSH
118229: CALL_OW 262
118233: PUSH
118234: LD_INT 1
118236: EQUAL
118237: PUSH
118238: LD_VAR 0 4
118242: PPUSH
118243: CALL_OW 261
118247: PUSH
118248: LD_INT 30
118250: LESS
118251: AND
118252: PUSH
118253: LD_VAR 0 7
118257: AND
118258: IFFALSE 118328
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118260: LD_VAR 0 4
118264: PPUSH
118265: LD_VAR 0 7
118269: PPUSH
118270: LD_VAR 0 4
118274: PPUSH
118275: CALL_OW 74
118279: PPUSH
118280: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118284: LD_VAR 0 4
118288: PPUSH
118289: LD_VAR 0 7
118293: PPUSH
118294: LD_VAR 0 4
118298: PPUSH
118299: CALL_OW 74
118303: PPUSH
118304: CALL_OW 296
118308: PUSH
118309: LD_INT 6
118311: LESS
118312: IFFALSE 118326
// SetFuel ( i , 100 ) ;
118314: LD_VAR 0 4
118318: PPUSH
118319: LD_INT 100
118321: PPUSH
118322: CALL_OW 240
// end else
118326: GO 118342
// ComAttackUnit ( i , e ) ;
118328: LD_VAR 0 4
118332: PPUSH
118333: LD_VAR 0 13
118337: PPUSH
118338: CALL_OW 115
// end else
118342: GO 118445
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118344: LD_VAR 0 13
118348: PPUSH
118349: LD_EXP 88
118353: PUSH
118354: LD_VAR 0 1
118358: ARRAY
118359: PPUSH
118360: CALL_OW 308
118364: NOT
118365: PUSH
118366: LD_VAR 0 4
118370: PPUSH
118371: LD_VAR 0 13
118375: PPUSH
118376: CALL_OW 296
118380: PUSH
118381: LD_INT 40
118383: GREATEREQUAL
118384: AND
118385: PUSH
118386: LD_VAR 0 4
118390: PPUSH
118391: CALL_OW 256
118395: PUSH
118396: LD_INT 650
118398: LESSEQUAL
118399: OR
118400: PUSH
118401: LD_VAR 0 4
118405: PPUSH
118406: LD_EXP 87
118410: PUSH
118411: LD_VAR 0 1
118415: ARRAY
118416: PPUSH
118417: CALL_OW 308
118421: NOT
118422: AND
118423: IFFALSE 118445
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118425: LD_VAR 0 4
118429: PPUSH
118430: LD_EXP 87
118434: PUSH
118435: LD_VAR 0 1
118439: ARRAY
118440: PPUSH
118441: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118445: LD_VAR 0 4
118449: PPUSH
118450: CALL_OW 256
118454: PUSH
118455: LD_INT 1000
118457: LESS
118458: PUSH
118459: LD_VAR 0 4
118463: PPUSH
118464: CALL_OW 263
118468: PUSH
118469: LD_INT 1
118471: EQUAL
118472: AND
118473: PUSH
118474: LD_VAR 0 4
118478: PPUSH
118479: CALL_OW 311
118483: AND
118484: PUSH
118485: LD_VAR 0 4
118489: PPUSH
118490: LD_EXP 87
118494: PUSH
118495: LD_VAR 0 1
118499: ARRAY
118500: PPUSH
118501: CALL_OW 308
118505: AND
118506: IFFALSE 118560
// begin mech := IsDrivenBy ( i ) ;
118508: LD_ADDR_VAR 0 9
118512: PUSH
118513: LD_VAR 0 4
118517: PPUSH
118518: CALL_OW 311
118522: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
118523: LD_VAR 0 9
118527: PPUSH
118528: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
118532: LD_VAR 0 9
118536: PPUSH
118537: LD_VAR 0 4
118541: PPUSH
118542: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
118546: LD_VAR 0 9
118550: PPUSH
118551: LD_VAR 0 4
118555: PPUSH
118556: CALL_OW 180
// end ; end ; unit_human :
118560: GO 118907
118562: LD_INT 1
118564: DOUBLE
118565: EQUAL
118566: IFTRUE 118570
118568: GO 118906
118570: POP
// begin b := IsInUnit ( i ) ;
118571: LD_ADDR_VAR 0 18
118575: PUSH
118576: LD_VAR 0 4
118580: PPUSH
118581: CALL_OW 310
118585: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
118586: LD_ADDR_VAR 0 19
118590: PUSH
118591: LD_VAR 0 18
118595: NOT
118596: PUSH
118597: LD_VAR 0 18
118601: PPUSH
118602: CALL_OW 266
118606: PUSH
118607: LD_INT 32
118609: PUSH
118610: LD_INT 31
118612: PUSH
118613: EMPTY
118614: LIST
118615: LIST
118616: IN
118617: OR
118618: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
118619: LD_VAR 0 18
118623: PPUSH
118624: CALL_OW 266
118628: PUSH
118629: LD_INT 5
118631: EQUAL
118632: PUSH
118633: LD_VAR 0 4
118637: PPUSH
118638: CALL_OW 257
118642: PUSH
118643: LD_INT 1
118645: PUSH
118646: LD_INT 2
118648: PUSH
118649: LD_INT 3
118651: PUSH
118652: LD_INT 4
118654: PUSH
118655: EMPTY
118656: LIST
118657: LIST
118658: LIST
118659: LIST
118660: IN
118661: AND
118662: IFFALSE 118699
// begin class := AllowSpecClass ( i ) ;
118664: LD_ADDR_VAR 0 20
118668: PUSH
118669: LD_VAR 0 4
118673: PPUSH
118674: CALL 19146 0 1
118678: ST_TO_ADDR
// if class then
118679: LD_VAR 0 20
118683: IFFALSE 118699
// ComChangeProfession ( i , class ) ;
118685: LD_VAR 0 4
118689: PPUSH
118690: LD_VAR 0 20
118694: PPUSH
118695: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
118699: LD_VAR 0 16
118703: PUSH
118704: LD_VAR 0 2
118708: PPUSH
118709: LD_INT 21
118711: PUSH
118712: LD_INT 2
118714: PUSH
118715: EMPTY
118716: LIST
118717: LIST
118718: PPUSH
118719: CALL_OW 72
118723: PUSH
118724: LD_INT 1
118726: LESSEQUAL
118727: OR
118728: PUSH
118729: LD_VAR 0 19
118733: AND
118734: PUSH
118735: LD_VAR 0 4
118739: PUSH
118740: LD_VAR 0 17
118744: IN
118745: NOT
118746: AND
118747: IFFALSE 118840
// begin if b then
118749: LD_VAR 0 18
118753: IFFALSE 118802
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
118755: LD_VAR 0 18
118759: PPUSH
118760: LD_VAR 0 21
118764: PPUSH
118765: LD_VAR 0 18
118769: PPUSH
118770: CALL_OW 74
118774: PPUSH
118775: CALL_OW 296
118779: PUSH
118780: LD_INT 10
118782: LESS
118783: PUSH
118784: LD_VAR 0 18
118788: PPUSH
118789: CALL_OW 461
118793: PUSH
118794: LD_INT 7
118796: NONEQUAL
118797: AND
118798: IFFALSE 118802
// continue ;
118800: GO 118037
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
118802: LD_ADDR_VAR 0 17
118806: PUSH
118807: LD_VAR 0 17
118811: PPUSH
118812: LD_VAR 0 17
118816: PUSH
118817: LD_INT 1
118819: PLUS
118820: PPUSH
118821: LD_VAR 0 4
118825: PPUSH
118826: CALL_OW 1
118830: ST_TO_ADDR
// ComExitBuilding ( i ) ;
118831: LD_VAR 0 4
118835: PPUSH
118836: CALL_OW 122
// end ; if sold_defenders then
118840: LD_VAR 0 17
118844: IFFALSE 118904
// if i in sold_defenders then
118846: LD_VAR 0 4
118850: PUSH
118851: LD_VAR 0 17
118855: IN
118856: IFFALSE 118904
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
118858: LD_VAR 0 4
118862: PPUSH
118863: CALL_OW 314
118867: NOT
118868: PUSH
118869: LD_VAR 0 4
118873: PPUSH
118874: LD_VAR 0 13
118878: PPUSH
118879: CALL_OW 296
118883: PUSH
118884: LD_INT 30
118886: LESS
118887: AND
118888: IFFALSE 118904
// ComAttackUnit ( i , e ) ;
118890: LD_VAR 0 4
118894: PPUSH
118895: LD_VAR 0 13
118899: PPUSH
118900: CALL_OW 115
// end ; end ; end ;
118904: GO 118907
118906: POP
// if IsDead ( i ) then
118907: LD_VAR 0 4
118911: PPUSH
118912: CALL_OW 301
118916: IFFALSE 118934
// defenders := defenders diff i ;
118918: LD_ADDR_VAR 0 2
118922: PUSH
118923: LD_VAR 0 2
118927: PUSH
118928: LD_VAR 0 4
118932: DIFF
118933: ST_TO_ADDR
// end ;
118934: GO 118037
118936: POP
118937: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
118938: LD_VAR 0 21
118942: NOT
118943: PUSH
118944: LD_VAR 0 2
118948: NOT
118949: OR
118950: PUSH
118951: LD_EXP 63
118955: PUSH
118956: LD_VAR 0 1
118960: ARRAY
118961: NOT
118962: OR
118963: IFFALSE 117941
// MC_Reset ( base , 18 ) ;
118965: LD_VAR 0 1
118969: PPUSH
118970: LD_INT 18
118972: PPUSH
118973: CALL 64330 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118977: LD_ADDR_VAR 0 2
118981: PUSH
118982: LD_VAR 0 2
118986: PUSH
118987: LD_VAR 0 2
118991: PPUSH
118992: LD_INT 2
118994: PUSH
118995: LD_INT 25
118997: PUSH
118998: LD_INT 1
119000: PUSH
119001: EMPTY
119002: LIST
119003: LIST
119004: PUSH
119005: LD_INT 25
119007: PUSH
119008: LD_INT 5
119010: PUSH
119011: EMPTY
119012: LIST
119013: LIST
119014: PUSH
119015: LD_INT 25
119017: PUSH
119018: LD_INT 8
119020: PUSH
119021: EMPTY
119022: LIST
119023: LIST
119024: PUSH
119025: LD_INT 25
119027: PUSH
119028: LD_INT 9
119030: PUSH
119031: EMPTY
119032: LIST
119033: LIST
119034: PUSH
119035: EMPTY
119036: LIST
119037: LIST
119038: LIST
119039: LIST
119040: LIST
119041: PPUSH
119042: CALL_OW 72
119046: DIFF
119047: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119048: LD_VAR 0 21
119052: NOT
119053: PUSH
119054: LD_VAR 0 2
119058: PPUSH
119059: LD_INT 21
119061: PUSH
119062: LD_INT 2
119064: PUSH
119065: EMPTY
119066: LIST
119067: LIST
119068: PPUSH
119069: CALL_OW 72
119073: AND
119074: IFFALSE 119412
// begin tmp := FilterByTag ( defenders , 19 ) ;
119076: LD_ADDR_VAR 0 11
119080: PUSH
119081: LD_VAR 0 2
119085: PPUSH
119086: LD_INT 19
119088: PPUSH
119089: CALL 52640 0 2
119093: ST_TO_ADDR
// if tmp then
119094: LD_VAR 0 11
119098: IFFALSE 119168
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119100: LD_ADDR_VAR 0 11
119104: PUSH
119105: LD_VAR 0 11
119109: PPUSH
119110: LD_INT 25
119112: PUSH
119113: LD_INT 3
119115: PUSH
119116: EMPTY
119117: LIST
119118: LIST
119119: PPUSH
119120: CALL_OW 72
119124: ST_TO_ADDR
// if tmp then
119125: LD_VAR 0 11
119129: IFFALSE 119168
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119131: LD_ADDR_EXP 75
119135: PUSH
119136: LD_EXP 75
119140: PPUSH
119141: LD_VAR 0 1
119145: PPUSH
119146: LD_EXP 75
119150: PUSH
119151: LD_VAR 0 1
119155: ARRAY
119156: PUSH
119157: LD_VAR 0 11
119161: UNION
119162: PPUSH
119163: CALL_OW 1
119167: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119168: LD_VAR 0 1
119172: PPUSH
119173: LD_INT 19
119175: PPUSH
119176: CALL 64330 0 2
// repeat wait ( 0 0$1 ) ;
119180: LD_INT 35
119182: PPUSH
119183: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119187: LD_EXP 63
119191: PUSH
119192: LD_VAR 0 1
119196: ARRAY
119197: NOT
119198: PUSH
119199: LD_EXP 63
119203: PUSH
119204: LD_VAR 0 1
119208: ARRAY
119209: PUSH
119210: EMPTY
119211: EQUAL
119212: OR
119213: IFFALSE 119250
// begin for i in defenders do
119215: LD_ADDR_VAR 0 4
119219: PUSH
119220: LD_VAR 0 2
119224: PUSH
119225: FOR_IN
119226: IFFALSE 119239
// ComStop ( i ) ;
119228: LD_VAR 0 4
119232: PPUSH
119233: CALL_OW 141
119237: GO 119225
119239: POP
119240: POP
// defenders := [ ] ;
119241: LD_ADDR_VAR 0 2
119245: PUSH
119246: EMPTY
119247: ST_TO_ADDR
// exit ;
119248: GO 119476
// end ; for i in defenders do
119250: LD_ADDR_VAR 0 4
119254: PUSH
119255: LD_VAR 0 2
119259: PUSH
119260: FOR_IN
119261: IFFALSE 119350
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119263: LD_VAR 0 4
119267: PPUSH
119268: LD_EXP 87
119272: PUSH
119273: LD_VAR 0 1
119277: ARRAY
119278: PPUSH
119279: CALL_OW 308
119283: NOT
119284: IFFALSE 119308
// ComMoveToArea ( i , mc_parking [ base ] ) else
119286: LD_VAR 0 4
119290: PPUSH
119291: LD_EXP 87
119295: PUSH
119296: LD_VAR 0 1
119300: ARRAY
119301: PPUSH
119302: CALL_OW 113
119306: GO 119348
// if GetControl ( i ) = control_manual then
119308: LD_VAR 0 4
119312: PPUSH
119313: CALL_OW 263
119317: PUSH
119318: LD_INT 1
119320: EQUAL
119321: IFFALSE 119348
// if IsDrivenBy ( i ) then
119323: LD_VAR 0 4
119327: PPUSH
119328: CALL_OW 311
119332: IFFALSE 119348
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119334: LD_VAR 0 4
119338: PPUSH
119339: CALL_OW 311
119343: PPUSH
119344: CALL_OW 121
// end ;
119348: GO 119260
119350: POP
119351: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119352: LD_VAR 0 2
119356: PPUSH
119357: LD_INT 95
119359: PUSH
119360: LD_EXP 87
119364: PUSH
119365: LD_VAR 0 1
119369: ARRAY
119370: PUSH
119371: EMPTY
119372: LIST
119373: LIST
119374: PPUSH
119375: CALL_OW 72
119379: PUSH
119380: LD_VAR 0 2
119384: EQUAL
119385: PUSH
119386: LD_EXP 86
119390: PUSH
119391: LD_VAR 0 1
119395: ARRAY
119396: OR
119397: PUSH
119398: LD_EXP 63
119402: PUSH
119403: LD_VAR 0 1
119407: ARRAY
119408: NOT
119409: OR
119410: IFFALSE 119180
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119412: LD_ADDR_EXP 85
119416: PUSH
119417: LD_EXP 85
119421: PPUSH
119422: LD_VAR 0 1
119426: PPUSH
119427: LD_VAR 0 2
119431: PPUSH
119432: LD_INT 21
119434: PUSH
119435: LD_INT 2
119437: PUSH
119438: EMPTY
119439: LIST
119440: LIST
119441: PPUSH
119442: CALL_OW 72
119446: PPUSH
119447: CALL_OW 1
119451: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119452: LD_VAR 0 1
119456: PPUSH
119457: LD_INT 19
119459: PPUSH
119460: CALL 64330 0 2
// MC_Reset ( base , 20 ) ;
119464: LD_VAR 0 1
119468: PPUSH
119469: LD_INT 20
119471: PPUSH
119472: CALL 64330 0 2
// end ; end_of_file
119476: LD_VAR 0 3
119480: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119481: LD_VAR 0 1
119485: PUSH
119486: LD_INT 200
119488: DOUBLE
119489: GREATEREQUAL
119490: IFFALSE 119498
119492: LD_INT 299
119494: DOUBLE
119495: LESSEQUAL
119496: IFTRUE 119500
119498: GO 119532
119500: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119501: LD_VAR 0 1
119505: PPUSH
119506: LD_VAR 0 2
119510: PPUSH
119511: LD_VAR 0 3
119515: PPUSH
119516: LD_VAR 0 4
119520: PPUSH
119521: LD_VAR 0 5
119525: PPUSH
119526: CALL 107481 0 5
119530: GO 119609
119532: LD_INT 300
119534: DOUBLE
119535: GREATEREQUAL
119536: IFFALSE 119544
119538: LD_INT 399
119540: DOUBLE
119541: LESSEQUAL
119542: IFTRUE 119546
119544: GO 119608
119546: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
119547: LD_VAR 0 1
119551: PPUSH
119552: LD_VAR 0 2
119556: PPUSH
119557: LD_VAR 0 3
119561: PPUSH
119562: LD_VAR 0 4
119566: PPUSH
119567: LD_VAR 0 5
119571: PPUSH
119572: LD_VAR 0 6
119576: PPUSH
119577: LD_VAR 0 7
119581: PPUSH
119582: LD_VAR 0 8
119586: PPUSH
119587: LD_VAR 0 9
119591: PPUSH
119592: LD_VAR 0 10
119596: PPUSH
119597: LD_VAR 0 11
119601: PPUSH
119602: CALL 103389 0 11
119606: GO 119609
119608: POP
// end ;
119609: PPOPN 11
119611: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
119612: LD_VAR 0 1
119616: PPUSH
119617: LD_VAR 0 2
119621: PPUSH
119622: LD_VAR 0 3
119626: PPUSH
119627: LD_VAR 0 4
119631: PPUSH
119632: LD_VAR 0 5
119636: PPUSH
119637: CALL 106866 0 5
// end ; end_of_file
119641: PPOPN 5
119643: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
119644: LD_VAR 0 1
119648: PPUSH
119649: LD_VAR 0 2
119653: PPUSH
119654: LD_VAR 0 3
119658: PPUSH
119659: LD_VAR 0 4
119663: PPUSH
119664: LD_VAR 0 5
119668: PPUSH
119669: LD_VAR 0 6
119673: PPUSH
119674: CALL 91041 0 6
// end ;
119678: PPOPN 6
119680: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
119681: LD_INT 0
119683: PPUSH
// begin if not units then
119684: LD_VAR 0 1
119688: NOT
119689: IFFALSE 119693
// exit ;
119691: GO 119693
// end ;
119693: PPOPN 7
119695: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
119696: CALL 90928 0 0
// end ;
119700: PPOPN 1
119702: END
