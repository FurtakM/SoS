// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 56979 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48746 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48746 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48746 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48746 0 9
// PrepareArabian ;
 147: CALL 3529 0 0
// PrepareRussian ;
 151: CALL 2664 0 0
// PrepareAlliance ;
 155: CALL 729 0 0
// MC_Start ( ) ;
 159: CALL 59091 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6692 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 82
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 83
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 80196 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 53
 252: PPUSH
 253: CALL 80622 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 81080 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 81349 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 80562 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 81256 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 50
 340: PPUSH
 341: CALL 80622 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 81080 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 81349 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 80406 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 80562 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := false ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 51
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// end ; end_of_file
 724: LD_VAR 0 1
 728: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 729: LD_INT 0
 731: PPUSH
 732: PPUSH
 733: PPUSH
 734: PPUSH
// uc_side := 7 ;
 735: LD_ADDR_OWVAR 20
 739: PUSH
 740: LD_INT 7
 742: ST_TO_ADDR
// uc_nation := 1 ;
 743: LD_ADDR_OWVAR 21
 747: PUSH
 748: LD_INT 1
 750: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 751: LD_ADDR_EXP 14
 755: PUSH
 756: LD_STRING JMM
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_STRING 12a_
 767: PPUSH
 768: CALL 13966 0 3
 772: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 773: LD_EXP 14
 777: PPUSH
 778: LD_INT 71
 780: PPUSH
 781: LD_INT 23
 783: PPUSH
 784: LD_INT 0
 786: PPUSH
 787: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 791: LD_EXP 14
 795: PPUSH
 796: LD_INT 2
 798: PPUSH
 799: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 803: LD_ADDR_EXP 15
 807: PUSH
 808: LD_STRING Roth
 810: PPUSH
 811: LD_EXP 1
 815: NOT
 816: PPUSH
 817: LD_STRING 12a_
 819: PPUSH
 820: CALL 13966 0 3
 824: ST_TO_ADDR
// if Roth then
 825: LD_EXP 15
 829: IFFALSE 849
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 831: LD_EXP 15
 835: PPUSH
 836: LD_INT 71
 838: PPUSH
 839: LD_INT 21
 841: PPUSH
 842: LD_INT 0
 844: PPUSH
 845: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 849: LD_ADDR_EXP 16
 853: PUSH
 854: LD_STRING Lisa
 856: PPUSH
 857: LD_EXP 1
 861: NOT
 862: PPUSH
 863: LD_STRING 12a_
 865: PPUSH
 866: CALL 13966 0 3
 870: ST_TO_ADDR
// if Lisa then
 871: LD_EXP 16
 875: IFFALSE 892
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 877: LD_EXP 16
 881: PPUSH
 882: LD_INT 13
 884: PPUSH
 885: LD_INT 0
 887: PPUSH
 888: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 892: LD_ADDR_EXP 17
 896: PUSH
 897: LD_STRING Donaldson
 899: PPUSH
 900: LD_EXP 1
 904: NOT
 905: PPUSH
 906: LD_STRING 12a_
 908: PPUSH
 909: CALL 13966 0 3
 913: ST_TO_ADDR
// if Donaldson then
 914: LD_EXP 17
 918: IFFALSE 935
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 920: LD_EXP 17
 924: PPUSH
 925: LD_INT 13
 927: PPUSH
 928: LD_INT 0
 930: PPUSH
 931: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 935: LD_ADDR_EXP 18
 939: PUSH
 940: LD_STRING Bobby
 942: PPUSH
 943: LD_EXP 1
 947: NOT
 948: PPUSH
 949: LD_STRING 12a_
 951: PPUSH
 952: CALL 13966 0 3
 956: ST_TO_ADDR
// if Bobby then
 957: LD_EXP 18
 961: IFFALSE 978
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 963: LD_EXP 18
 967: PPUSH
 968: LD_INT 13
 970: PPUSH
 971: LD_INT 0
 973: PPUSH
 974: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 978: LD_ADDR_EXP 19
 982: PUSH
 983: LD_STRING Cyrus
 985: PPUSH
 986: LD_EXP 1
 990: NOT
 991: PPUSH
 992: LD_STRING 12a_
 994: PPUSH
 995: CALL 13966 0 3
 999: ST_TO_ADDR
// if Cyrus then
1000: LD_EXP 19
1004: IFFALSE 1021
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1006: LD_EXP 19
1010: PPUSH
1011: LD_INT 13
1013: PPUSH
1014: LD_INT 0
1016: PPUSH
1017: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1021: LD_ADDR_EXP 20
1025: PUSH
1026: LD_STRING Denis
1028: PPUSH
1029: LD_EXP 1
1033: NOT
1034: PPUSH
1035: LD_STRING 12a_
1037: PPUSH
1038: CALL 13966 0 3
1042: ST_TO_ADDR
// if Denis then
1043: LD_EXP 20
1047: IFFALSE 1064
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1049: LD_EXP 20
1053: PPUSH
1054: LD_INT 13
1056: PPUSH
1057: LD_INT 0
1059: PPUSH
1060: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1064: LD_ADDR_EXP 21
1068: PUSH
1069: LD_STRING Brown
1071: PPUSH
1072: LD_EXP 1
1076: NOT
1077: PPUSH
1078: LD_STRING 12a_
1080: PPUSH
1081: CALL 13966 0 3
1085: ST_TO_ADDR
// if Brown then
1086: LD_EXP 21
1090: IFFALSE 1107
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1092: LD_EXP 21
1096: PPUSH
1097: LD_INT 13
1099: PPUSH
1100: LD_INT 0
1102: PPUSH
1103: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1107: LD_ADDR_EXP 22
1111: PUSH
1112: LD_STRING Gladstone
1114: PPUSH
1115: LD_EXP 1
1119: NOT
1120: PPUSH
1121: LD_STRING 12a_
1123: PPUSH
1124: CALL 13966 0 3
1128: ST_TO_ADDR
// if Gladstone then
1129: LD_EXP 22
1133: IFFALSE 1150
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1135: LD_EXP 22
1139: PPUSH
1140: LD_INT 13
1142: PPUSH
1143: LD_INT 0
1145: PPUSH
1146: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1150: LD_ADDR_EXP 23
1154: PUSH
1155: LD_STRING Houten
1157: PPUSH
1158: LD_EXP 1
1162: NOT
1163: PPUSH
1164: LD_STRING 12a_
1166: PPUSH
1167: CALL 13966 0 3
1171: ST_TO_ADDR
// if Houten then
1172: LD_EXP 23
1176: IFFALSE 1193
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1178: LD_EXP 23
1182: PPUSH
1183: LD_INT 13
1185: PPUSH
1186: LD_INT 0
1188: PPUSH
1189: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1193: LD_ADDR_EXP 24
1197: PUSH
1198: LD_STRING Cornell
1200: PPUSH
1201: LD_EXP 1
1205: NOT
1206: PPUSH
1207: LD_STRING 12a_
1209: PPUSH
1210: CALL 13966 0 3
1214: ST_TO_ADDR
// if Cornel then
1215: LD_EXP 24
1219: IFFALSE 1236
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1221: LD_EXP 24
1225: PPUSH
1226: LD_INT 13
1228: PPUSH
1229: LD_INT 0
1231: PPUSH
1232: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1236: LD_ADDR_EXP 25
1240: PUSH
1241: LD_STRING Gary
1243: PPUSH
1244: LD_EXP 1
1248: NOT
1249: PPUSH
1250: LD_STRING 12a_
1252: PPUSH
1253: CALL 13966 0 3
1257: ST_TO_ADDR
// if Gary then
1258: LD_EXP 25
1262: IFFALSE 1279
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1264: LD_EXP 25
1268: PPUSH
1269: LD_INT 13
1271: PPUSH
1272: LD_INT 0
1274: PPUSH
1275: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1279: LD_ADDR_EXP 26
1283: PUSH
1284: LD_STRING Frank
1286: PPUSH
1287: LD_EXP 1
1291: NOT
1292: PPUSH
1293: LD_STRING 12a_
1295: PPUSH
1296: CALL 13966 0 3
1300: ST_TO_ADDR
// if Frank then
1301: LD_EXP 26
1305: IFFALSE 1322
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1307: LD_EXP 26
1311: PPUSH
1312: LD_INT 13
1314: PPUSH
1315: LD_INT 0
1317: PPUSH
1318: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1322: LD_ADDR_EXP 27
1326: PUSH
1327: LD_STRING Kikuchi
1329: PPUSH
1330: LD_EXP 1
1334: NOT
1335: PPUSH
1336: LD_STRING 12a_
1338: PPUSH
1339: CALL 13966 0 3
1343: ST_TO_ADDR
// if Kikuchi then
1344: LD_EXP 27
1348: IFFALSE 1365
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1350: LD_EXP 27
1354: PPUSH
1355: LD_INT 13
1357: PPUSH
1358: LD_INT 0
1360: PPUSH
1361: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1365: LD_ADDR_EXP 28
1369: PUSH
1370: LD_STRING Simms
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_STRING 12a_
1381: PPUSH
1382: CALL 13966 0 3
1386: ST_TO_ADDR
// if Simms then
1387: LD_EXP 28
1391: IFFALSE 1408
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1393: LD_EXP 28
1397: PPUSH
1398: LD_INT 13
1400: PPUSH
1401: LD_INT 0
1403: PPUSH
1404: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1408: LD_ADDR_EXP 29
1412: PUSH
1413: LD_STRING Joan
1415: PPUSH
1416: LD_EXP 1
1420: NOT
1421: PPUSH
1422: LD_STRING 12a_
1424: PPUSH
1425: CALL 13966 0 3
1429: ST_TO_ADDR
// if Joan then
1430: LD_EXP 29
1434: IFFALSE 1451
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1436: LD_EXP 29
1440: PPUSH
1441: LD_INT 13
1443: PPUSH
1444: LD_INT 0
1446: PPUSH
1447: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1451: LD_ADDR_EXP 30
1455: PUSH
1456: LD_STRING DeltaDoctor
1458: PPUSH
1459: LD_EXP 1
1463: NOT
1464: PPUSH
1465: LD_STRING 12a_
1467: PPUSH
1468: CALL 13966 0 3
1472: ST_TO_ADDR
// if DeltaDoctor then
1473: LD_EXP 30
1477: IFFALSE 1494
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1479: LD_EXP 30
1483: PPUSH
1484: LD_INT 13
1486: PPUSH
1487: LD_INT 0
1489: PPUSH
1490: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1494: LD_ADDR_VAR 0 4
1498: PUSH
1499: LD_STRING 12a_others
1501: PPUSH
1502: CALL_OW 31
1506: ST_TO_ADDR
// if tmp then
1507: LD_VAR 0 4
1511: IFFALSE 1545
// for i in tmp do
1513: LD_ADDR_VAR 0 3
1517: PUSH
1518: LD_VAR 0 4
1522: PUSH
1523: FOR_IN
1524: IFFALSE 1543
// PlaceUnitArea ( i , alliance_start , false ) ;
1526: LD_VAR 0 3
1530: PPUSH
1531: LD_INT 13
1533: PPUSH
1534: LD_INT 0
1536: PPUSH
1537: CALL_OW 49
1541: GO 1523
1543: POP
1544: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1545: LD_INT 3
1547: PPUSH
1548: LD_INT 3
1550: PPUSH
1551: LD_INT 3
1553: PPUSH
1554: LD_INT 12
1556: PPUSH
1557: LD_INT 100
1559: PPUSH
1560: CALL 20932 0 5
// veh := CreateVehicle ;
1564: LD_ADDR_VAR 0 2
1568: PUSH
1569: CALL_OW 45
1573: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1574: LD_VAR 0 2
1578: PPUSH
1579: LD_INT 2
1581: PPUSH
1582: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1586: LD_VAR 0 2
1590: PPUSH
1591: LD_INT 60
1593: PPUSH
1594: LD_INT 6
1596: PPUSH
1597: LD_INT 0
1599: PPUSH
1600: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1604: LD_VAR 0 2
1608: PPUSH
1609: LD_INT 4
1611: PPUSH
1612: LD_INT 30
1614: PPUSH
1615: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1619: LD_STRING 11_artifact_captured
1621: PPUSH
1622: LD_INT 0
1624: PPUSH
1625: CALL_OW 30
1629: IFFALSE 1705
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1631: LD_INT 3
1633: PPUSH
1634: LD_INT 3
1636: PPUSH
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 12
1642: PPUSH
1643: LD_INT 100
1645: PPUSH
1646: CALL 20932 0 5
// veh := CreateVehicle ;
1650: LD_ADDR_VAR 0 2
1654: PUSH
1655: CALL_OW 45
1659: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1660: LD_VAR 0 2
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1672: LD_VAR 0 2
1676: PPUSH
1677: LD_INT 75
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: LD_INT 0
1685: PPUSH
1686: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1690: LD_VAR 0 2
1694: PPUSH
1695: LD_INT 4
1697: PPUSH
1698: LD_INT 50
1700: PPUSH
1701: CALL_OW 290
// end ; end ;
1705: LD_VAR 0 1
1709: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1710: LD_INT 0
1712: PPUSH
1713: PPUSH
1714: PPUSH
1715: PPUSH
// uc_side := 6 ;
1716: LD_ADDR_OWVAR 20
1720: PUSH
1721: LD_INT 6
1723: ST_TO_ADDR
// uc_nation := 3 ;
1724: LD_ADDR_OWVAR 21
1728: PUSH
1729: LD_INT 3
1731: ST_TO_ADDR
// InitHc ;
1732: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1736: LD_ADDR_EXP 31
1740: PUSH
1741: LD_STRING Gossudarov
1743: PPUSH
1744: CALL_OW 25
1748: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1749: LD_ADDR_EXP 32
1753: PUSH
1754: LD_STRING Kirilenkova
1756: PPUSH
1757: CALL_OW 25
1761: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1762: LD_ADDR_EXP 33
1766: PUSH
1767: LD_STRING Titov
1769: PPUSH
1770: CALL_OW 25
1774: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1775: LD_ADDR_EXP 38
1779: PUSH
1780: LD_STRING Oblukov
1782: PPUSH
1783: CALL_OW 25
1787: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1788: LD_ADDR_EXP 35
1792: PUSH
1793: LD_STRING Dolgov
1795: PPUSH
1796: CALL_OW 25
1800: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1801: LD_ADDR_EXP 36
1805: PUSH
1806: LD_STRING Petrosyan
1808: PPUSH
1809: CALL_OW 25
1813: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1814: LD_ADDR_EXP 37
1818: PUSH
1819: LD_STRING Scholtze
1821: PPUSH
1822: CALL_OW 25
1826: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1827: LD_ADDR_EXP 39
1831: PUSH
1832: LD_STRING Kapitsova
1834: PPUSH
1835: CALL_OW 25
1839: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1840: LD_ADDR_VAR 0 2
1844: PUSH
1845: LD_EXP 31
1849: PUSH
1850: LD_EXP 32
1854: PUSH
1855: LD_EXP 33
1859: PUSH
1860: LD_EXP 38
1864: PUSH
1865: LD_EXP 35
1869: PUSH
1870: LD_EXP 36
1874: PUSH
1875: LD_EXP 37
1879: PUSH
1880: LD_EXP 39
1884: PUSH
1885: EMPTY
1886: LIST
1887: LIST
1888: LIST
1889: LIST
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1895: LD_INT 1
1897: PPUSH
1898: LD_INT 4
1900: PPUSH
1901: LD_INT 8
1903: PPUSH
1904: CALL_OW 380
// un := CreateHuman ;
1908: LD_ADDR_VAR 0 4
1912: PUSH
1913: CALL_OW 44
1917: ST_TO_ADDR
// tmp := tmp ^ un ;
1918: LD_ADDR_VAR 0 2
1922: PUSH
1923: LD_VAR 0 2
1927: PUSH
1928: LD_VAR 0 4
1932: ADD
1933: ST_TO_ADDR
// for i in tmp do
1934: LD_ADDR_VAR 0 3
1938: PUSH
1939: LD_VAR 0 2
1943: PUSH
1944: FOR_IN
1945: IFFALSE 1964
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1947: LD_VAR 0 3
1951: PPUSH
1952: LD_INT 14
1954: PPUSH
1955: LD_INT 0
1957: PPUSH
1958: CALL_OW 49
1962: GO 1944
1964: POP
1965: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1966: LD_VAR 0 2
1970: PPUSH
1971: LD_EXP 3
1975: PPUSH
1976: CALL_OW 250
1980: PPUSH
1981: LD_EXP 3
1985: PPUSH
1986: CALL_OW 251
1990: PPUSH
1991: CALL_OW 111
// end ;
1995: LD_VAR 0 1
1999: RET
// export function PrepareBelkov ; begin
2000: LD_INT 0
2002: PPUSH
// uc_side := 4 ;
2003: LD_ADDR_OWVAR 20
2007: PUSH
2008: LD_INT 4
2010: ST_TO_ADDR
// uc_nation := 3 ;
2011: LD_ADDR_OWVAR 21
2015: PUSH
2016: LD_INT 3
2018: ST_TO_ADDR
// InitHc ;
2019: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2023: LD_ADDR_EXP 46
2027: PUSH
2028: LD_STRING Belkov
2030: PPUSH
2031: CALL_OW 25
2035: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2036: LD_EXP 46
2040: PPUSH
2041: LD_INT 14
2043: PPUSH
2044: LD_INT 0
2046: PPUSH
2047: CALL_OW 49
// end ;
2051: LD_VAR 0 1
2055: RET
// export function PrepareGnyevko ; begin
2056: LD_INT 0
2058: PPUSH
// uc_side := 4 ;
2059: LD_ADDR_OWVAR 20
2063: PUSH
2064: LD_INT 4
2066: ST_TO_ADDR
// uc_nation := 3 ;
2067: LD_ADDR_OWVAR 21
2071: PUSH
2072: LD_INT 3
2074: ST_TO_ADDR
// InitHc ;
2075: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2079: LD_ADDR_EXP 47
2083: PUSH
2084: LD_STRING Gnyevko
2086: PPUSH
2087: CALL_OW 25
2091: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2092: LD_EXP 47
2096: PPUSH
2097: LD_INT 14
2099: PPUSH
2100: LD_INT 0
2102: PPUSH
2103: CALL_OW 49
// end ;
2107: LD_VAR 0 1
2111: RET
// export function PrepareBurlak ; var i , tmp ; begin
2112: LD_INT 0
2114: PPUSH
2115: PPUSH
2116: PPUSH
// uc_side := 4 ;
2117: LD_ADDR_OWVAR 20
2121: PUSH
2122: LD_INT 4
2124: ST_TO_ADDR
// uc_nation := 3 ;
2125: LD_ADDR_OWVAR 21
2129: PUSH
2130: LD_INT 3
2132: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
2133: LD_INT 35
2135: PPUSH
2136: CALL_OW 67
// until not FilterAllUnits ( [ f_distxy , 123 , 3 , 3 ] ) ;
2140: LD_INT 92
2142: PUSH
2143: LD_INT 123
2145: PUSH
2146: LD_INT 3
2148: PUSH
2149: LD_INT 3
2151: PUSH
2152: EMPTY
2153: LIST
2154: LIST
2155: LIST
2156: LIST
2157: PPUSH
2158: CALL_OW 69
2162: NOT
2163: IFFALSE 2133
// InitHc ;
2165: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2169: LD_ADDR_EXP 45
2173: PUSH
2174: LD_STRING Burlak
2176: PPUSH
2177: CALL_OW 25
2181: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2182: LD_INT 24
2184: PUSH
2185: LD_INT 23
2187: PUSH
2188: LD_INT 22
2190: PUSH
2191: EMPTY
2192: LIST
2193: LIST
2194: LIST
2195: PUSH
2196: LD_OWVAR 67
2200: ARRAY
2201: PPUSH
2202: LD_INT 1
2204: PPUSH
2205: LD_INT 1
2207: PPUSH
2208: LD_INT 45
2210: PUSH
2211: LD_INT 44
2213: PUSH
2214: LD_INT 43
2216: PUSH
2217: EMPTY
2218: LIST
2219: LIST
2220: LIST
2221: PUSH
2222: LD_OWVAR 67
2226: ARRAY
2227: PPUSH
2228: LD_INT 0
2230: PPUSH
2231: CALL 20932 0 5
// Masha := CreateVehicle ;
2235: LD_ADDR_EXP 48
2239: PUSH
2240: CALL_OW 45
2244: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2245: LD_EXP 48
2249: PUSH
2250: LD_EXP 45
2254: PUSH
2255: EMPTY
2256: LIST
2257: LIST
2258: PPUSH
2259: LD_INT 499
2261: PPUSH
2262: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2266: LD_EXP 48
2270: PPUSH
2271: LD_INT 3
2273: PPUSH
2274: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2278: LD_EXP 48
2282: PPUSH
2283: LD_INT 1
2285: PPUSH
2286: CALL_OW 242
// PlaceUnitArea ( Masha , burlak_spawn , false ) ;
2290: LD_EXP 48
2294: PPUSH
2295: LD_INT 18
2297: PPUSH
2298: LD_INT 0
2300: PPUSH
2301: CALL_OW 49
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2305: LD_EXP 45
2309: PPUSH
2310: LD_INT 125
2312: PPUSH
2313: LD_INT 1
2315: PPUSH
2316: LD_INT 0
2318: PPUSH
2319: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2323: LD_EXP 45
2327: PPUSH
2328: LD_EXP 48
2332: PPUSH
2333: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2337: LD_INT 10
2339: PPUSH
2340: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2344: LD_EXP 48
2348: PPUSH
2349: LD_INT 110
2351: PPUSH
2352: LD_INT 10
2354: PPUSH
2355: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2359: LD_ADDR_EXP 41
2363: PUSH
2364: LD_STRING Petrovova
2366: PPUSH
2367: CALL_OW 25
2371: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2372: LD_ADDR_EXP 43
2376: PUSH
2377: LD_STRING Kuzmov
2379: PPUSH
2380: CALL_OW 25
2384: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2385: LD_ADDR_EXP 42
2389: PUSH
2390: LD_STRING Kovalyuk
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2398: LD_ADDR_EXP 40
2402: PUSH
2403: LD_STRING Lipshchin
2405: PPUSH
2406: CALL_OW 25
2410: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2411: LD_ADDR_EXP 44
2415: PUSH
2416: LD_STRING Karamazov
2418: PPUSH
2419: CALL_OW 25
2423: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2424: LD_ADDR_VAR 0 3
2428: PUSH
2429: LD_EXP 41
2433: PUSH
2434: LD_EXP 43
2438: PUSH
2439: LD_EXP 42
2443: PUSH
2444: LD_EXP 40
2448: PUSH
2449: LD_EXP 44
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: ST_TO_ADDR
// for i in tmp do
2461: LD_ADDR_VAR 0 2
2465: PUSH
2466: LD_VAR 0 3
2470: PUSH
2471: FOR_IN
2472: IFFALSE 2511
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2474: LD_VAR 0 2
2478: PPUSH
2479: LD_INT 399
2481: PPUSH
2482: LD_INT 799
2484: PPUSH
2485: CALL_OW 12
2489: PPUSH
2490: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2494: LD_VAR 0 2
2498: PPUSH
2499: LD_INT 19
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 49
// end ;
2509: GO 2471
2511: POP
2512: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2513: LD_VAR 0 3
2517: PPUSH
2518: LD_INT 116
2520: PPUSH
2521: LD_INT 8
2523: PPUSH
2524: CALL_OW 111
// AddComHold ( tmp ) ;
2528: LD_VAR 0 3
2532: PPUSH
2533: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2537: LD_ADDR_VAR 0 2
2541: PUSH
2542: LD_VAR 0 3
2546: PPUSH
2547: LD_INT 25
2549: PUSH
2550: LD_INT 1
2552: PUSH
2553: EMPTY
2554: LIST
2555: LIST
2556: PPUSH
2557: CALL_OW 72
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2603
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 20
2572: PPUSH
2573: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2577: LD_VAR 0 2
2581: PPUSH
2582: LD_INT 147
2584: PPUSH
2585: LD_INT 45
2587: PPUSH
2588: CALL_OW 178
// AddComCrawl ( i ) ;
2592: LD_VAR 0 2
2596: PPUSH
2597: CALL_OW 197
// end ;
2601: GO 2562
2603: POP
2604: POP
// repeat wait ( 0 0$1 ) ;
2605: LD_INT 35
2607: PPUSH
2608: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2612: LD_EXP 48
2616: PPUSH
2617: LD_INT 110
2619: PPUSH
2620: LD_INT 10
2622: PPUSH
2623: CALL_OW 307
2627: PUSH
2628: LD_EXP 48
2632: PPUSH
2633: CALL_OW 305
2637: NOT
2638: OR
2639: IFFALSE 2605
// ComStop ( Burlak ) ;
2641: LD_EXP 45
2645: PPUSH
2646: CALL_OW 141
// AddComHold ( Burlak ) ;
2650: LD_EXP 45
2654: PPUSH
2655: CALL_OW 200
// end ; end_of_file
2659: LD_VAR 0 1
2663: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2664: LD_INT 0
2666: PPUSH
2667: PPUSH
2668: PPUSH
2669: PPUSH
// uc_side := 3 ;
2670: LD_ADDR_OWVAR 20
2674: PUSH
2675: LD_INT 3
2677: ST_TO_ADDR
// uc_nation := 3 ;
2678: LD_ADDR_OWVAR 21
2682: PUSH
2683: LD_INT 3
2685: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2686: LD_ADDR_EXP 49
2690: PUSH
2691: LD_INT 47
2693: PPUSH
2694: LD_INT 4
2696: PPUSH
2697: LD_STRING 
2699: PPUSH
2700: LD_INT 7
2702: PUSH
2703: LD_INT 8
2705: PUSH
2706: LD_INT 9
2708: PUSH
2709: EMPTY
2710: LIST
2711: LIST
2712: LIST
2713: PUSH
2714: LD_OWVAR 67
2718: ARRAY
2719: PPUSH
2720: LD_INT 10000
2722: PUSH
2723: LD_INT 3000
2725: PUSH
2726: LD_INT 300
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: LIST
2733: PPUSH
2734: LD_INT 9
2736: PUSH
2737: LD_INT 5
2739: PUSH
2740: LD_INT 6
2742: PUSH
2743: LD_INT 6
2745: PUSH
2746: EMPTY
2747: LIST
2748: LIST
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL 24341 0 6
2756: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2757: LD_ADDR_EXP 58
2761: PUSH
2762: LD_EXP 58
2766: PPUSH
2767: LD_INT 2
2769: PPUSH
2770: LD_EXP 49
2774: PPUSH
2775: CALL_OW 1
2779: ST_TO_ADDR
// tmp := [ ] ;
2780: LD_ADDR_VAR 0 4
2784: PUSH
2785: EMPTY
2786: ST_TO_ADDR
// for i = 1 to 4 do
2787: LD_ADDR_VAR 0 2
2791: PUSH
2792: DOUBLE
2793: LD_INT 1
2795: DEC
2796: ST_TO_ADDR
2797: LD_INT 4
2799: PUSH
2800: FOR_TO
2801: IFFALSE 2894
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2803: LD_INT 22
2805: PPUSH
2806: LD_INT 3
2808: PPUSH
2809: LD_INT 3
2811: PPUSH
2812: LD_INT 43
2814: PUSH
2815: LD_INT 45
2817: PUSH
2818: LD_INT 45
2820: PUSH
2821: LD_INT 44
2823: PUSH
2824: EMPTY
2825: LIST
2826: LIST
2827: LIST
2828: LIST
2829: PUSH
2830: LD_VAR 0 2
2834: PUSH
2835: LD_INT 4
2837: MOD
2838: PUSH
2839: LD_INT 1
2841: PLUS
2842: ARRAY
2843: PPUSH
2844: LD_INT 100
2846: PPUSH
2847: CALL 20932 0 5
// veh := CreateVehicle ;
2851: LD_ADDR_VAR 0 3
2855: PUSH
2856: CALL_OW 45
2860: ST_TO_ADDR
// tmp := tmp ^ veh ;
2861: LD_ADDR_VAR 0 4
2865: PUSH
2866: LD_VAR 0 4
2870: PUSH
2871: LD_VAR 0 3
2875: ADD
2876: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2877: LD_VAR 0 3
2881: PPUSH
2882: LD_INT 2
2884: PPUSH
2885: LD_INT 0
2887: PPUSH
2888: CALL_OW 49
// end ;
2892: GO 2800
2894: POP
2895: POP
// russian_guard := tmp ;
2896: LD_ADDR_EXP 50
2900: PUSH
2901: LD_VAR 0 4
2905: ST_TO_ADDR
// end ;
2906: LD_VAR 0 1
2910: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2911: LD_INT 47
2913: PPUSH
2914: CALL_OW 302
2918: PUSH
2919: LD_EXP 6
2923: AND
2924: IFFALSE 3526
2926: GO 2928
2928: DISABLE
2929: LD_INT 0
2931: PPUSH
2932: PPUSH
2933: PPUSH
2934: PPUSH
2935: PPUSH
2936: PPUSH
// begin enable ;
2937: ENABLE
// base := 2 ;
2938: LD_ADDR_VAR 0 2
2942: PUSH
2943: LD_INT 2
2945: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
2946: LD_ADDR_VAR 0 4
2950: PUSH
2951: LD_INT 0
2953: PUSH
2954: LD_INT 0
2956: PUSH
2957: LD_INT 0
2959: PUSH
2960: LD_INT 0
2962: PUSH
2963: LD_INT 0
2965: PUSH
2966: LD_INT 0
2968: PUSH
2969: LD_INT 0
2971: PUSH
2972: LD_INT 0
2974: PUSH
2975: LD_INT 1
2977: PUSH
2978: LD_INT 0
2980: PUSH
2981: EMPTY
2982: LIST
2983: LIST
2984: LIST
2985: LIST
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: LIST
2991: LIST
2992: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
2993: LD_ADDR_VAR 0 3
2997: PUSH
2998: LD_INT 22
3000: PUSH
3001: LD_INT 1
3003: PUSH
3004: LD_INT 3
3006: PUSH
3007: LD_INT 45
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_INT 21
3018: PUSH
3019: LD_INT 1
3021: PUSH
3022: LD_INT 3
3024: PUSH
3025: LD_INT 45
3027: PUSH
3028: EMPTY
3029: LIST
3030: LIST
3031: LIST
3032: LIST
3033: PUSH
3034: LD_INT 22
3036: PUSH
3037: LD_INT 1
3039: PUSH
3040: LD_INT 3
3042: PUSH
3043: LD_INT 45
3045: PUSH
3046: EMPTY
3047: LIST
3048: LIST
3049: LIST
3050: LIST
3051: PUSH
3052: LD_INT 23
3054: PUSH
3055: LD_INT 1
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 46
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: LIST
3069: PUSH
3070: EMPTY
3071: LIST
3072: LIST
3073: LIST
3074: LIST
3075: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3076: LD_ADDR_VAR 0 1
3080: PUSH
3081: DOUBLE
3082: LD_INT 1
3084: DEC
3085: ST_TO_ADDR
3086: LD_OWVAR 67
3090: PUSH
3091: LD_OWVAR 1
3095: PUSH
3096: LD_INT 21000
3098: DIV
3099: PLUS
3100: PUSH
3101: FOR_TO
3102: IFFALSE 3190
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3104: LD_ADDR_VAR 0 3
3108: PUSH
3109: LD_VAR 0 3
3113: PPUSH
3114: LD_VAR 0 3
3118: PUSH
3119: LD_INT 1
3121: PLUS
3122: PPUSH
3123: LD_INT 23
3125: PUSH
3126: LD_INT 24
3128: PUSH
3129: EMPTY
3130: LIST
3131: LIST
3132: PUSH
3133: LD_INT 1
3135: PPUSH
3136: LD_INT 2
3138: PPUSH
3139: CALL_OW 12
3143: ARRAY
3144: PUSH
3145: LD_INT 1
3147: PUSH
3148: LD_INT 3
3150: PUSH
3151: LD_INT 46
3153: PUSH
3154: LD_INT 47
3156: PUSH
3157: LD_INT 45
3159: PUSH
3160: EMPTY
3161: LIST
3162: LIST
3163: LIST
3164: PUSH
3165: LD_INT 1
3167: PPUSH
3168: LD_INT 3
3170: PPUSH
3171: CALL_OW 12
3175: ARRAY
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: LIST
3182: PPUSH
3183: CALL_OW 2
3187: ST_TO_ADDR
3188: GO 3101
3190: POP
3191: POP
// MC_InsertProduceList ( base , tmp ) ;
3192: LD_VAR 0 2
3196: PPUSH
3197: LD_VAR 0 3
3201: PPUSH
3202: CALL 80562 0 2
// repeat wait ( 0 0$1 ) ;
3206: LD_INT 35
3208: PPUSH
3209: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3213: LD_EXP 77
3217: PUSH
3218: LD_VAR 0 2
3222: ARRAY
3223: PUSH
3224: LD_INT 6
3226: GREATER
3227: IFFALSE 3206
// wait ( 0 0$20 ) ;
3229: LD_INT 700
3231: PPUSH
3232: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3236: LD_ADDR_VAR 0 5
3240: PUSH
3241: LD_INT 71
3243: PUSH
3244: LD_INT 19
3246: PUSH
3247: EMPTY
3248: LIST
3249: LIST
3250: PUSH
3251: LD_INT 91
3253: PUSH
3254: LD_INT 67
3256: PUSH
3257: EMPTY
3258: LIST
3259: LIST
3260: PUSH
3261: LD_INT 52
3263: PUSH
3264: LD_INT 44
3266: PUSH
3267: EMPTY
3268: LIST
3269: LIST
3270: PUSH
3271: LD_INT 68
3273: PUSH
3274: LD_INT 48
3276: PUSH
3277: EMPTY
3278: LIST
3279: LIST
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: LIST
3286: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3287: LD_ADDR_VAR 0 6
3291: PUSH
3292: LD_EXP 77
3296: PUSH
3297: LD_VAR 0 2
3301: ARRAY
3302: PUSH
3303: LD_EXP 77
3307: PUSH
3308: LD_VAR 0 2
3312: ARRAY
3313: PPUSH
3314: LD_INT 2
3316: PUSH
3317: LD_INT 34
3319: PUSH
3320: LD_INT 51
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: PUSH
3327: LD_INT 34
3329: PUSH
3330: LD_INT 52
3332: PUSH
3333: EMPTY
3334: LIST
3335: LIST
3336: PUSH
3337: EMPTY
3338: LIST
3339: LIST
3340: LIST
3341: PPUSH
3342: CALL_OW 72
3346: DIFF
3347: ST_TO_ADDR
// if not attackers then
3348: LD_VAR 0 6
3352: NOT
3353: IFFALSE 3357
// exit ;
3355: GO 3526
// ru_attackers := attackers ;
3357: LD_ADDR_EXP 51
3361: PUSH
3362: LD_VAR 0 6
3366: ST_TO_ADDR
// for i = 1 to attackers do
3367: LD_ADDR_VAR 0 1
3371: PUSH
3372: DOUBLE
3373: LD_INT 1
3375: DEC
3376: ST_TO_ADDR
3377: LD_VAR 0 6
3381: PUSH
3382: FOR_TO
3383: IFFALSE 3460
// begin case i mod 3 of 0 :
3385: LD_VAR 0 1
3389: PUSH
3390: LD_INT 3
3392: MOD
3393: PUSH
3394: LD_INT 0
3396: DOUBLE
3397: EQUAL
3398: IFTRUE 3402
3400: GO 3405
3402: POP
// ; 1 :
3403: GO 3458
3405: LD_INT 1
3407: DOUBLE
3408: EQUAL
3409: IFTRUE 3413
3411: GO 3431
3413: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3414: LD_VAR 0 1
3418: PPUSH
3419: LD_INT 32
3421: PPUSH
3422: LD_INT 49
3424: PPUSH
3425: CALL_OW 114
3429: GO 3458
3431: LD_INT 2
3433: DOUBLE
3434: EQUAL
3435: IFTRUE 3439
3437: GO 3457
3439: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3440: LD_VAR 0 1
3444: PPUSH
3445: LD_INT 117
3447: PPUSH
3448: LD_INT 107
3450: PPUSH
3451: CALL_OW 114
3455: GO 3458
3457: POP
// end ;
3458: GO 3382
3460: POP
3461: POP
// repeat wait ( 0 0$1 ) ;
3462: LD_INT 35
3464: PPUSH
3465: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3469: LD_VAR 0 6
3473: PPUSH
3474: LD_INT 60
3476: PUSH
3477: EMPTY
3478: LIST
3479: PPUSH
3480: CALL_OW 72
3484: NOT
3485: IFFALSE 3462
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3487: LD_VAR 0 2
3491: PPUSH
3492: LD_VAR 0 6
3496: PPUSH
3497: LD_VAR 0 5
3501: PPUSH
3502: LD_VAR 0 4
3506: PPUSH
3507: CALL 80747 0 4
// if not first_attack then
3511: LD_EXP 7
3515: NOT
3516: IFFALSE 3526
// first_attack := true ;
3518: LD_ADDR_EXP 7
3522: PUSH
3523: LD_INT 1
3525: ST_TO_ADDR
// end ; end_of_file
3526: PPOPN 6
3528: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3529: LD_INT 0
3531: PPUSH
3532: PPUSH
3533: PPUSH
3534: PPUSH
3535: PPUSH
3536: PPUSH
3537: PPUSH
// uc_side := 2 ;
3538: LD_ADDR_OWVAR 20
3542: PUSH
3543: LD_INT 2
3545: ST_TO_ADDR
// uc_nation := 2 ;
3546: LD_ADDR_OWVAR 21
3550: PUSH
3551: LD_INT 2
3553: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3554: LD_ADDR_EXP 54
3558: PUSH
3559: LD_STRING Abdul
3561: PPUSH
3562: CALL_OW 25
3566: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3567: LD_EXP 54
3571: PPUSH
3572: LD_INT 11
3574: PPUSH
3575: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3579: LD_EXP 54
3583: PPUSH
3584: LD_INT 1
3586: PPUSH
3587: CALL_OW 52
// vc_chassis := 31 ;
3591: LD_ADDR_OWVAR 37
3595: PUSH
3596: LD_INT 31
3598: ST_TO_ADDR
// vc_control := control_rider ;
3599: LD_ADDR_OWVAR 38
3603: PUSH
3604: LD_INT 4
3606: ST_TO_ADDR
// mastodont := CreateVehicle ;
3607: LD_ADDR_EXP 55
3611: PUSH
3612: CALL_OW 45
3616: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3617: LD_EXP 55
3621: PPUSH
3622: LD_INT 153
3624: PPUSH
3625: LD_INT 71
3627: PPUSH
3628: LD_INT 0
3630: PPUSH
3631: CALL_OW 48
// InitVc ;
3635: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3639: LD_ADDR_EXP 52
3643: PUSH
3644: LD_INT 1
3646: PPUSH
3647: LD_INT 3
3649: PPUSH
3650: LD_STRING 
3652: PPUSH
3653: LD_INT 7
3655: PUSH
3656: LD_INT 8
3658: PUSH
3659: LD_INT 9
3661: PUSH
3662: EMPTY
3663: LIST
3664: LIST
3665: LIST
3666: PUSH
3667: LD_OWVAR 67
3671: ARRAY
3672: PPUSH
3673: LD_INT 5000
3675: PUSH
3676: LD_INT 1000
3678: PUSH
3679: LD_INT 300
3681: PUSH
3682: EMPTY
3683: LIST
3684: LIST
3685: LIST
3686: PPUSH
3687: LD_INT 22
3689: PUSH
3690: LD_INT 5
3692: PUSH
3693: LD_INT 6
3695: PUSH
3696: LD_INT 9
3698: PUSH
3699: EMPTY
3700: LIST
3701: LIST
3702: LIST
3703: LIST
3704: PPUSH
3705: CALL 24341 0 6
3709: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3710: LD_ADDR_EXP 58
3714: PUSH
3715: LD_EXP 58
3719: PPUSH
3720: LD_INT 1
3722: PPUSH
3723: LD_EXP 52
3727: PPUSH
3728: CALL_OW 1
3732: ST_TO_ADDR
// tmp := [ ] ;
3733: LD_ADDR_VAR 0 4
3737: PUSH
3738: EMPTY
3739: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3740: LD_ADDR_OWVAR 37
3744: PUSH
3745: LD_INT 14
3747: ST_TO_ADDR
// vc_engine := engine_siberite ;
3748: LD_ADDR_OWVAR 39
3752: PUSH
3753: LD_INT 3
3755: ST_TO_ADDR
// vc_control := control_manual ;
3756: LD_ADDR_OWVAR 38
3760: PUSH
3761: LD_INT 1
3763: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3764: LD_ADDR_OWVAR 40
3768: PUSH
3769: LD_INT 31
3771: ST_TO_ADDR
// for i = 1 to 3 do
3772: LD_ADDR_VAR 0 2
3776: PUSH
3777: DOUBLE
3778: LD_INT 1
3780: DEC
3781: ST_TO_ADDR
3782: LD_INT 3
3784: PUSH
3785: FOR_TO
3786: IFFALSE 4030
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3788: LD_ADDR_VAR 0 5
3792: PUSH
3793: LD_INT 153
3795: PUSH
3796: LD_INT 71
3798: PUSH
3799: EMPTY
3800: LIST
3801: LIST
3802: PUSH
3803: LD_INT 155
3805: PUSH
3806: LD_INT 81
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: EMPTY
3814: LIST
3815: LIST
3816: PUSH
3817: LD_VAR 0 2
3821: PUSH
3822: LD_INT 2
3824: MOD
3825: PUSH
3826: LD_INT 1
3828: PLUS
3829: ARRAY
3830: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3831: LD_INT 0
3833: PPUSH
3834: LD_INT 3
3836: PPUSH
3837: LD_INT 7
3839: PUSH
3840: LD_INT 8
3842: PUSH
3843: LD_INT 9
3845: PUSH
3846: EMPTY
3847: LIST
3848: LIST
3849: LIST
3850: PUSH
3851: LD_OWVAR 67
3855: ARRAY
3856: PPUSH
3857: CALL_OW 380
// un := CreateVehicle ;
3861: LD_ADDR_VAR 0 6
3865: PUSH
3866: CALL_OW 45
3870: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3871: LD_VAR 0 6
3875: PPUSH
3876: LD_INT 0
3878: PPUSH
3879: LD_INT 5
3881: PPUSH
3882: CALL_OW 12
3886: PPUSH
3887: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3891: LD_VAR 0 6
3895: PPUSH
3896: LD_VAR 0 5
3900: PUSH
3901: LD_INT 1
3903: ARRAY
3904: PPUSH
3905: LD_VAR 0 5
3909: PUSH
3910: LD_INT 2
3912: ARRAY
3913: PPUSH
3914: LD_INT 6
3916: PPUSH
3917: LD_INT 0
3919: PPUSH
3920: CALL_OW 50
// un2 := CreateHuman ;
3924: LD_ADDR_VAR 0 7
3928: PUSH
3929: CALL_OW 44
3933: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
3934: LD_VAR 0 7
3938: PPUSH
3939: LD_VAR 0 6
3943: PPUSH
3944: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
3948: LD_ADDR_EXP 58
3952: PUSH
3953: LD_EXP 58
3957: PPUSH
3958: LD_INT 1
3960: PUSH
3961: LD_EXP 58
3965: PUSH
3966: LD_INT 1
3968: ARRAY
3969: PUSH
3970: LD_INT 1
3972: PLUS
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PPUSH
3978: LD_VAR 0 6
3982: PPUSH
3983: CALL 21054 0 3
3987: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
3988: LD_ADDR_EXP 58
3992: PUSH
3993: LD_EXP 58
3997: PPUSH
3998: LD_INT 1
4000: PUSH
4001: LD_EXP 58
4005: PUSH
4006: LD_INT 1
4008: ARRAY
4009: PUSH
4010: LD_INT 1
4012: PLUS
4013: PUSH
4014: EMPTY
4015: LIST
4016: LIST
4017: PPUSH
4018: LD_VAR 0 7
4022: PPUSH
4023: CALL 21054 0 3
4027: ST_TO_ADDR
// end ;
4028: GO 3785
4030: POP
4031: POP
// for i = 1 to 5 do
4032: LD_ADDR_VAR 0 2
4036: PUSH
4037: DOUBLE
4038: LD_INT 1
4040: DEC
4041: ST_TO_ADDR
4042: LD_INT 5
4044: PUSH
4045: FOR_TO
4046: IFFALSE 4139
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4048: LD_INT 14
4050: PPUSH
4051: LD_INT 3
4053: PPUSH
4054: LD_INT 1
4056: PPUSH
4057: LD_INT 25
4059: PUSH
4060: LD_INT 28
4062: PUSH
4063: LD_INT 28
4065: PUSH
4066: LD_INT 26
4068: PUSH
4069: EMPTY
4070: LIST
4071: LIST
4072: LIST
4073: LIST
4074: PUSH
4075: LD_VAR 0 2
4079: PUSH
4080: LD_INT 4
4082: MOD
4083: PUSH
4084: LD_INT 1
4086: PLUS
4087: ARRAY
4088: PPUSH
4089: LD_INT 100
4091: PPUSH
4092: CALL 20932 0 5
// veh := CreateVehicle ;
4096: LD_ADDR_VAR 0 3
4100: PUSH
4101: CALL_OW 45
4105: ST_TO_ADDR
// tmp := tmp ^ veh ;
4106: LD_ADDR_VAR 0 4
4110: PUSH
4111: LD_VAR 0 4
4115: PUSH
4116: LD_VAR 0 3
4120: ADD
4121: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4122: LD_VAR 0 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 0
4132: PPUSH
4133: CALL_OW 49
// end ;
4137: GO 4045
4139: POP
4140: POP
// arabian_guard := tmp ;
4141: LD_ADDR_EXP 53
4145: PUSH
4146: LD_VAR 0 4
4150: ST_TO_ADDR
// end ;
4151: LD_VAR 0 1
4155: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4156: LD_INT 22
4158: PUSH
4159: LD_INT 7
4161: PUSH
4162: EMPTY
4163: LIST
4164: LIST
4165: PUSH
4166: LD_INT 91
4168: PUSH
4169: LD_INT 1
4171: PUSH
4172: LD_INT 12
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: LIST
4179: PUSH
4180: EMPTY
4181: LIST
4182: LIST
4183: PPUSH
4184: CALL_OW 69
4188: PUSH
4189: LD_EXP 55
4193: PPUSH
4194: CALL_OW 256
4198: PUSH
4199: LD_INT 990
4201: LESS
4202: OR
4203: PUSH
4204: LD_EXP 54
4208: PPUSH
4209: CALL_OW 256
4213: PUSH
4214: LD_INT 990
4216: LESS
4217: OR
4218: IFFALSE 4361
4220: GO 4222
4222: DISABLE
// begin if IsInUnit ( Abdul ) then
4223: LD_EXP 54
4227: PPUSH
4228: CALL_OW 310
4232: IFFALSE 4243
// ComExitBuilding ( Abdul ) ;
4234: LD_EXP 54
4238: PPUSH
4239: CALL_OW 122
// if Mastodont then
4243: LD_EXP 55
4247: IFFALSE 4264
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4249: LD_EXP 55
4253: PPUSH
4254: LD_INT 205
4256: PPUSH
4257: LD_INT 132
4259: PPUSH
4260: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4264: LD_EXP 54
4268: PPUSH
4269: LD_INT 205
4271: PPUSH
4272: LD_INT 132
4274: PPUSH
4275: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4279: LD_INT 35
4281: PPUSH
4282: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4286: LD_EXP 54
4290: PPUSH
4291: LD_INT 21
4293: PPUSH
4294: CALL_OW 308
4298: IFFALSE 4279
// RemoveUnit ( Abdul ) ;
4300: LD_EXP 54
4304: PPUSH
4305: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4309: LD_INT 35
4311: PPUSH
4312: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4316: LD_EXP 55
4320: PPUSH
4321: LD_INT 21
4323: PPUSH
4324: CALL_OW 308
4328: PUSH
4329: LD_EXP 55
4333: PPUSH
4334: CALL_OW 301
4338: OR
4339: IFFALSE 4309
// if IsOk ( Mastodont ) then
4341: LD_EXP 55
4345: PPUSH
4346: CALL_OW 302
4350: IFFALSE 4361
// RemoveUnit ( Mastodont ) ;
4352: LD_EXP 55
4356: PPUSH
4357: CALL_OW 64
// end ;
4361: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4362: LD_EXP 54
4366: PPUSH
4367: CALL_OW 301
4371: PUSH
4372: LD_INT 22
4374: PUSH
4375: LD_INT 2
4377: PUSH
4378: EMPTY
4379: LIST
4380: LIST
4381: PUSH
4382: LD_INT 2
4384: PUSH
4385: LD_INT 25
4387: PUSH
4388: LD_INT 1
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: PUSH
4395: LD_INT 25
4397: PUSH
4398: LD_INT 2
4400: PUSH
4401: EMPTY
4402: LIST
4403: LIST
4404: PUSH
4405: LD_INT 25
4407: PUSH
4408: LD_INT 3
4410: PUSH
4411: EMPTY
4412: LIST
4413: LIST
4414: PUSH
4415: LD_INT 25
4417: PUSH
4418: LD_INT 4
4420: PUSH
4421: EMPTY
4422: LIST
4423: LIST
4424: PUSH
4425: LD_INT 25
4427: PUSH
4428: LD_INT 8
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: EMPTY
4436: LIST
4437: LIST
4438: LIST
4439: LIST
4440: LIST
4441: LIST
4442: PUSH
4443: EMPTY
4444: LIST
4445: LIST
4446: PPUSH
4447: CALL_OW 69
4451: PUSH
4452: LD_INT 16
4454: PUSH
4455: LD_INT 19
4457: PUSH
4458: LD_INT 22
4460: PUSH
4461: EMPTY
4462: LIST
4463: LIST
4464: LIST
4465: PUSH
4466: LD_OWVAR 67
4470: ARRAY
4471: LESS
4472: OR
4473: IFFALSE 5146
4475: GO 4477
4477: DISABLE
4478: LD_INT 0
4480: PPUSH
4481: PPUSH
4482: PPUSH
4483: PPUSH
4484: PPUSH
4485: PPUSH
// begin MC_Kill ( 1 ) ;
4486: LD_INT 1
4488: PPUSH
4489: CALL 57214 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4493: LD_ADDR_VAR 0 2
4497: PUSH
4498: LD_INT 22
4500: PUSH
4501: LD_INT 2
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: LD_INT 2
4510: PUSH
4511: LD_INT 25
4513: PUSH
4514: LD_INT 1
4516: PUSH
4517: EMPTY
4518: LIST
4519: LIST
4520: PUSH
4521: LD_INT 25
4523: PUSH
4524: LD_INT 2
4526: PUSH
4527: EMPTY
4528: LIST
4529: LIST
4530: PUSH
4531: LD_INT 25
4533: PUSH
4534: LD_INT 3
4536: PUSH
4537: EMPTY
4538: LIST
4539: LIST
4540: PUSH
4541: LD_INT 25
4543: PUSH
4544: LD_INT 4
4546: PUSH
4547: EMPTY
4548: LIST
4549: LIST
4550: PUSH
4551: LD_INT 25
4553: PUSH
4554: LD_INT 8
4556: PUSH
4557: EMPTY
4558: LIST
4559: LIST
4560: PUSH
4561: EMPTY
4562: LIST
4563: LIST
4564: LIST
4565: LIST
4566: LIST
4567: LIST
4568: PUSH
4569: EMPTY
4570: LIST
4571: LIST
4572: PPUSH
4573: CALL_OW 69
4577: ST_TO_ADDR
// for i in tmp do
4578: LD_ADDR_VAR 0 5
4582: PUSH
4583: LD_VAR 0 2
4587: PUSH
4588: FOR_IN
4589: IFFALSE 4605
// SetTag ( i , 10 ) ;
4591: LD_VAR 0 5
4595: PPUSH
4596: LD_INT 10
4598: PPUSH
4599: CALL_OW 109
4603: GO 4588
4605: POP
4606: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4607: LD_ADDR_VAR 0 3
4611: PUSH
4612: LD_INT 22
4614: PUSH
4615: LD_INT 2
4617: PUSH
4618: EMPTY
4619: LIST
4620: LIST
4621: PUSH
4622: LD_INT 21
4624: PUSH
4625: LD_INT 1
4627: PUSH
4628: EMPTY
4629: LIST
4630: LIST
4631: PUSH
4632: EMPTY
4633: LIST
4634: LIST
4635: PPUSH
4636: CALL_OW 69
4640: PUSH
4641: LD_VAR 0 2
4645: DIFF
4646: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4647: LD_ADDR_VAR 0 1
4651: PUSH
4652: LD_INT 22
4654: PUSH
4655: LD_INT 2
4657: PUSH
4658: EMPTY
4659: LIST
4660: LIST
4661: PUSH
4662: LD_INT 21
4664: PUSH
4665: LD_INT 2
4667: PUSH
4668: EMPTY
4669: LIST
4670: LIST
4671: PUSH
4672: LD_INT 24
4674: PUSH
4675: LD_INT 300
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: EMPTY
4683: LIST
4684: LIST
4685: LIST
4686: PPUSH
4687: CALL_OW 69
4691: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4692: LD_ADDR_VAR 0 4
4696: PUSH
4697: LD_VAR 0 1
4701: PPUSH
4702: LD_INT 33
4704: PUSH
4705: LD_INT 1
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 58
4714: PUSH
4715: EMPTY
4716: LIST
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 72
4726: ST_TO_ADDR
// for i in tmp do
4727: LD_ADDR_VAR 0 5
4731: PUSH
4732: LD_VAR 0 2
4736: PUSH
4737: FOR_IN
4738: IFFALSE 4922
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4740: LD_VAR 0 5
4744: PUSH
4745: LD_INT 55
4747: PUSH
4748: EMPTY
4749: LIST
4750: PPUSH
4751: CALL_OW 69
4755: IN
4756: IFFALSE 4775
// begin AddComMoveXY ( i , 209 , 132 ) ;
4758: LD_VAR 0 5
4762: PPUSH
4763: LD_INT 209
4765: PPUSH
4766: LD_INT 132
4768: PPUSH
4769: CALL_OW 171
// continue ;
4773: GO 4737
// end ; if IsInUnit ( i ) then
4775: LD_VAR 0 5
4779: PPUSH
4780: CALL_OW 310
4784: IFFALSE 4802
// begin ComExitBuilding ( i ) ;
4786: LD_VAR 0 5
4790: PPUSH
4791: CALL_OW 122
// wait ( 3 ) ;
4795: LD_INT 3
4797: PPUSH
4798: CALL_OW 67
// end ; if tmp_empty then
4802: LD_VAR 0 4
4806: IFFALSE 4905
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4808: LD_VAR 0 5
4812: PPUSH
4813: LD_VAR 0 4
4817: PPUSH
4818: LD_VAR 0 5
4822: PPUSH
4823: CALL_OW 74
4827: PPUSH
4828: CALL_OW 296
4832: PUSH
4833: LD_INT 25
4835: LESS
4836: IFFALSE 4905
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4838: LD_ADDR_VAR 0 6
4842: PUSH
4843: LD_VAR 0 4
4847: PPUSH
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 74
4857: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4858: LD_VAR 0 5
4862: PPUSH
4863: LD_VAR 0 6
4867: PPUSH
4868: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4872: LD_VAR 0 5
4876: PPUSH
4877: LD_INT 209
4879: PPUSH
4880: LD_INT 132
4882: PPUSH
4883: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4887: LD_ADDR_VAR 0 4
4891: PUSH
4892: LD_VAR 0 4
4896: PUSH
4897: LD_VAR 0 6
4901: DIFF
4902: ST_TO_ADDR
// continue ;
4903: GO 4737
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4905: LD_VAR 0 5
4909: PPUSH
4910: LD_INT 201
4912: PPUSH
4913: LD_INT 132
4915: PPUSH
4916: CALL_OW 171
// end ;
4920: GO 4737
4922: POP
4923: POP
// for i in tmp_ape do
4924: LD_ADDR_VAR 0 5
4928: PUSH
4929: LD_VAR 0 3
4933: PUSH
4934: FOR_IN
4935: IFFALSE 4974
// begin if IsInUnit ( i ) then
4937: LD_VAR 0 5
4941: PPUSH
4942: CALL_OW 310
4946: IFFALSE 4957
// ComExitBuilding ( i ) ;
4948: LD_VAR 0 5
4952: PPUSH
4953: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
4957: LD_VAR 0 5
4961: PPUSH
4962: LD_INT 201
4964: PPUSH
4965: LD_INT 132
4967: PPUSH
4968: CALL_OW 171
// end ;
4972: GO 4934
4974: POP
4975: POP
// repeat wait ( 0 0$1 ) ;
4976: LD_INT 35
4978: PPUSH
4979: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
4983: LD_ADDR_VAR 0 5
4987: PUSH
4988: LD_VAR 0 2
4992: PUSH
4993: LD_VAR 0 3
4997: UNION
4998: PUSH
4999: LD_VAR 0 1
5003: UNION
5004: PUSH
5005: FOR_IN
5006: IFFALSE 5037
// if not HasTask ( i ) then
5008: LD_VAR 0 5
5012: PPUSH
5013: CALL_OW 314
5017: NOT
5018: IFFALSE 5035
// ComMoveXY ( i , 201 , 132 ) ;
5020: LD_VAR 0 5
5024: PPUSH
5025: LD_INT 201
5027: PPUSH
5028: LD_INT 132
5030: PPUSH
5031: CALL_OW 111
5035: GO 5005
5037: POP
5038: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5039: LD_INT 21
5041: PPUSH
5042: LD_INT 22
5044: PUSH
5045: LD_INT 2
5047: PUSH
5048: EMPTY
5049: LIST
5050: LIST
5051: PPUSH
5052: CALL_OW 70
5056: IFFALSE 5097
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5058: LD_ADDR_VAR 0 5
5062: PUSH
5063: LD_INT 21
5065: PPUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PPUSH
5076: CALL_OW 70
5080: PUSH
5081: FOR_IN
5082: IFFALSE 5095
// RemoveUnit ( i ) ;
5084: LD_VAR 0 5
5088: PPUSH
5089: CALL_OW 64
5093: GO 5081
5095: POP
5096: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5097: LD_INT 22
5099: PUSH
5100: LD_INT 2
5102: PUSH
5103: EMPTY
5104: LIST
5105: LIST
5106: PUSH
5107: LD_INT 2
5109: PUSH
5110: LD_INT 21
5112: PUSH
5113: LD_INT 1
5115: PUSH
5116: EMPTY
5117: LIST
5118: LIST
5119: PUSH
5120: LD_INT 21
5122: PUSH
5123: LD_INT 2
5125: PUSH
5126: EMPTY
5127: LIST
5128: LIST
5129: PUSH
5130: EMPTY
5131: LIST
5132: LIST
5133: LIST
5134: PUSH
5135: EMPTY
5136: LIST
5137: LIST
5138: PPUSH
5139: CALL_OW 69
5143: NOT
5144: IFFALSE 4976
// end ;
5146: PPOPN 6
5148: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5149: LD_EXP 9
5153: PUSH
5154: LD_INT 92
5156: PPUSH
5157: LD_INT 40
5159: PPUSH
5160: CALL_OW 428
5164: PPUSH
5165: CALL_OW 266
5169: PUSH
5170: LD_INT 30
5172: EQUAL
5173: AND
5174: IFFALSE 5370
5176: GO 5178
5178: DISABLE
5179: LD_INT 0
5181: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5182: LD_ADDR_VAR 0 1
5186: PUSH
5187: LD_EXP 58
5191: PUSH
5192: LD_INT 1
5194: ARRAY
5195: PPUSH
5196: LD_INT 25
5198: PUSH
5199: LD_INT 4
5201: PUSH
5202: EMPTY
5203: LIST
5204: LIST
5205: PPUSH
5206: CALL_OW 72
5210: ST_TO_ADDR
// if not sci then
5211: LD_VAR 0 1
5215: NOT
5216: IFFALSE 5220
// exit ;
5218: GO 5370
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5220: LD_ADDR_EXP 58
5224: PUSH
5225: LD_EXP 58
5229: PPUSH
5230: LD_INT 1
5232: PPUSH
5233: LD_EXP 58
5237: PUSH
5238: LD_INT 1
5240: ARRAY
5241: PUSH
5242: LD_VAR 0 1
5246: PUSH
5247: LD_INT 1
5249: ARRAY
5250: DIFF
5251: PPUSH
5252: CALL_OW 1
5256: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5257: LD_VAR 0 1
5261: PUSH
5262: LD_INT 1
5264: ARRAY
5265: PPUSH
5266: CALL_OW 310
5270: IFFALSE 5285
// ComExitBuilding ( sci [ 1 ] ) ;
5272: LD_VAR 0 1
5276: PUSH
5277: LD_INT 1
5279: ARRAY
5280: PPUSH
5281: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5285: LD_INT 2
5287: PPUSH
5288: LD_INT 105
5290: PPUSH
5291: LD_INT 14
5293: PPUSH
5294: LD_INT 20
5296: PPUSH
5297: CALL 21950 0 4
5301: PUSH
5302: LD_INT 4
5304: ARRAY
5305: PUSH
5306: LD_INT 10
5308: LESS
5309: IFFALSE 5332
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5311: LD_VAR 0 1
5315: PUSH
5316: LD_INT 1
5318: ARRAY
5319: PPUSH
5320: LD_INT 105
5322: PPUSH
5323: LD_INT 14
5325: PPUSH
5326: CALL_OW 171
5330: GO 5351
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5332: LD_VAR 0 1
5336: PUSH
5337: LD_INT 1
5339: ARRAY
5340: PPUSH
5341: LD_INT 118
5343: PPUSH
5344: LD_INT 77
5346: PPUSH
5347: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5351: LD_VAR 0 1
5355: PUSH
5356: LD_INT 1
5358: ARRAY
5359: PPUSH
5360: LD_INT 92
5362: PPUSH
5363: LD_INT 40
5365: PPUSH
5366: CALL_OW 218
// end ;
5370: PPOPN 1
5372: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5373: LD_INT 1
5375: PPUSH
5376: CALL_OW 302
5380: PUSH
5381: LD_EXP 9
5385: AND
5386: IFFALSE 5845
5388: GO 5390
5390: DISABLE
5391: LD_INT 0
5393: PPUSH
5394: PPUSH
5395: PPUSH
5396: PPUSH
5397: PPUSH
5398: PPUSH
// begin enable ;
5399: ENABLE
// base := 1 ;
5400: LD_ADDR_VAR 0 2
5404: PUSH
5405: LD_INT 1
5407: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5408: LD_ADDR_VAR 0 4
5412: PUSH
5413: LD_INT 0
5415: PUSH
5416: LD_INT 0
5418: PUSH
5419: LD_INT 0
5421: PUSH
5422: LD_INT 0
5424: PUSH
5425: LD_INT 0
5427: PUSH
5428: LD_INT 0
5430: PUSH
5431: LD_INT 0
5433: PUSH
5434: LD_INT 0
5436: PUSH
5437: LD_INT 1
5439: PUSH
5440: LD_INT 0
5442: PUSH
5443: EMPTY
5444: LIST
5445: LIST
5446: LIST
5447: LIST
5448: LIST
5449: LIST
5450: LIST
5451: LIST
5452: LIST
5453: LIST
5454: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5455: LD_ADDR_VAR 0 3
5459: PUSH
5460: LD_INT 14
5462: PUSH
5463: LD_INT 1
5465: PUSH
5466: LD_INT 2
5468: PUSH
5469: LD_INT 26
5471: PUSH
5472: EMPTY
5473: LIST
5474: LIST
5475: LIST
5476: LIST
5477: PUSH
5478: LD_INT 14
5480: PUSH
5481: LD_INT 1
5483: PUSH
5484: LD_INT 2
5486: PUSH
5487: LD_INT 28
5489: PUSH
5490: EMPTY
5491: LIST
5492: LIST
5493: LIST
5494: LIST
5495: PUSH
5496: LD_INT 13
5498: PUSH
5499: LD_INT 1
5501: PUSH
5502: LD_INT 2
5504: PUSH
5505: LD_INT 29
5507: PUSH
5508: EMPTY
5509: LIST
5510: LIST
5511: LIST
5512: LIST
5513: PUSH
5514: EMPTY
5515: LIST
5516: LIST
5517: LIST
5518: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5519: LD_ADDR_VAR 0 1
5523: PUSH
5524: DOUBLE
5525: LD_INT 1
5527: DEC
5528: ST_TO_ADDR
5529: LD_OWVAR 67
5533: PUSH
5534: LD_OWVAR 1
5538: PUSH
5539: LD_INT 21000
5541: DIV
5542: PLUS
5543: PUSH
5544: FOR_TO
5545: IFFALSE 5637
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5547: LD_ADDR_VAR 0 3
5551: PUSH
5552: LD_VAR 0 3
5556: PPUSH
5557: LD_VAR 0 3
5561: PUSH
5562: LD_INT 1
5564: PLUS
5565: PPUSH
5566: LD_INT 13
5568: PUSH
5569: LD_INT 14
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: PUSH
5576: LD_INT 1
5578: PPUSH
5579: LD_INT 2
5581: PPUSH
5582: CALL_OW 12
5586: ARRAY
5587: PUSH
5588: LD_INT 1
5590: PUSH
5591: LD_INT 2
5593: PUSH
5594: LD_INT 28
5596: PUSH
5597: LD_INT 29
5599: PUSH
5600: LD_INT 25
5602: PUSH
5603: LD_INT 26
5605: PUSH
5606: EMPTY
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: PUSH
5612: LD_INT 1
5614: PPUSH
5615: LD_INT 4
5617: PPUSH
5618: CALL_OW 12
5622: ARRAY
5623: PUSH
5624: EMPTY
5625: LIST
5626: LIST
5627: LIST
5628: LIST
5629: PPUSH
5630: CALL_OW 2
5634: ST_TO_ADDR
5635: GO 5544
5637: POP
5638: POP
// MC_InsertProduceList ( base , tmp ) ;
5639: LD_VAR 0 2
5643: PPUSH
5644: LD_VAR 0 3
5648: PPUSH
5649: CALL 80562 0 2
// repeat wait ( 0 0$1 ) ;
5653: LD_INT 35
5655: PPUSH
5656: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5660: LD_EXP 77
5664: PUSH
5665: LD_VAR 0 2
5669: ARRAY
5670: PUSH
5671: LD_INT 6
5673: GREATER
5674: IFFALSE 5653
// wait ( 0 0$20 ) ;
5676: LD_INT 700
5678: PPUSH
5679: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5683: LD_ADDR_VAR 0 5
5687: PUSH
5688: LD_INT 124
5690: PUSH
5691: LD_INT 85
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: LD_INT 90
5700: PUSH
5701: LD_INT 61
5703: PUSH
5704: EMPTY
5705: LIST
5706: LIST
5707: PUSH
5708: LD_INT 69
5710: PUSH
5711: LD_INT 48
5713: PUSH
5714: EMPTY
5715: LIST
5716: LIST
5717: PUSH
5718: LD_INT 68
5720: PUSH
5721: LD_INT 48
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: EMPTY
5729: LIST
5730: LIST
5731: LIST
5732: LIST
5733: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5734: LD_ADDR_VAR 0 6
5738: PUSH
5739: LD_EXP 77
5743: PUSH
5744: LD_VAR 0 2
5748: ARRAY
5749: PUSH
5750: LD_EXP 77
5754: PUSH
5755: LD_VAR 0 2
5759: ARRAY
5760: PPUSH
5761: LD_INT 34
5763: PUSH
5764: LD_INT 32
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PPUSH
5771: CALL_OW 72
5775: DIFF
5776: ST_TO_ADDR
// if not attackers then
5777: LD_VAR 0 6
5781: NOT
5782: IFFALSE 5786
// exit ;
5784: GO 5845
// ar_attackers := attackers ;
5786: LD_ADDR_EXP 10
5790: PUSH
5791: LD_VAR 0 6
5795: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5796: LD_INT 35
5798: PPUSH
5799: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5803: LD_VAR 0 6
5807: PPUSH
5808: LD_INT 60
5810: PUSH
5811: EMPTY
5812: LIST
5813: PPUSH
5814: CALL_OW 72
5818: NOT
5819: IFFALSE 5796
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_VAR 0 6
5830: PPUSH
5831: LD_VAR 0 5
5835: PPUSH
5836: LD_VAR 0 4
5840: PPUSH
5841: CALL 80747 0 4
// end ;
5845: PPOPN 6
5847: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5848: LD_INT 1
5850: PPUSH
5851: CALL_OW 302
5855: PUSH
5856: LD_EXP 9
5860: AND
5861: PUSH
5862: LD_EXP 48
5866: PPUSH
5867: LD_INT 22
5869: PPUSH
5870: CALL_OW 308
5874: AND
5875: PUSH
5876: LD_INT 1
5878: PPUSH
5879: CALL 80910 0 1
5883: PUSH
5884: LD_INT 0
5886: EQUAL
5887: AND
5888: PUSH
5889: LD_EXP 10
5893: NOT
5894: AND
5895: IFFALSE 6359
5897: GO 5899
5899: DISABLE
5900: LD_INT 0
5902: PPUSH
5903: PPUSH
5904: PPUSH
5905: PPUSH
5906: PPUSH
5907: PPUSH
5908: PPUSH
// begin base := 1 ;
5909: LD_ADDR_VAR 0 2
5913: PUSH
5914: LD_INT 1
5916: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5917: LD_ADDR_VAR 0 4
5921: PUSH
5922: LD_INT 0
5924: PUSH
5925: LD_INT 0
5927: PUSH
5928: LD_INT 0
5930: PUSH
5931: LD_INT 0
5933: PUSH
5934: LD_INT 0
5936: PUSH
5937: LD_INT 0
5939: PUSH
5940: LD_INT 0
5942: PUSH
5943: LD_INT 0
5945: PUSH
5946: LD_INT 1
5948: PUSH
5949: LD_INT 0
5951: PUSH
5952: EMPTY
5953: LIST
5954: LIST
5955: LIST
5956: LIST
5957: LIST
5958: LIST
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
5964: LD_ADDR_VAR 0 3
5968: PUSH
5969: LD_INT 13
5971: PUSH
5972: LD_INT 1
5974: PUSH
5975: LD_INT 2
5977: PUSH
5978: LD_INT 28
5980: PUSH
5981: EMPTY
5982: LIST
5983: LIST
5984: LIST
5985: LIST
5986: PUSH
5987: LD_INT 13
5989: PUSH
5990: LD_INT 1
5992: PUSH
5993: LD_INT 2
5995: PUSH
5996: LD_INT 27
5998: PUSH
5999: EMPTY
6000: LIST
6001: LIST
6002: LIST
6003: LIST
6004: PUSH
6005: LD_INT 13
6007: PUSH
6008: LD_INT 1
6010: PUSH
6011: LD_INT 2
6013: PUSH
6014: LD_INT 25
6016: PUSH
6017: EMPTY
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 11
6025: PUSH
6026: LD_INT 2
6028: PUSH
6029: LD_INT 2
6031: PUSH
6032: LD_INT 24
6034: PUSH
6035: EMPTY
6036: LIST
6037: LIST
6038: LIST
6039: LIST
6040: PUSH
6041: LD_INT 11
6043: PUSH
6044: LD_INT 2
6046: PUSH
6047: LD_INT 2
6049: PUSH
6050: LD_INT 24
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: LIST
6057: LIST
6058: PUSH
6059: EMPTY
6060: LIST
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6066: LD_VAR 0 2
6070: PPUSH
6071: LD_VAR 0 3
6075: PPUSH
6076: CALL 80562 0 2
// repeat wait ( 0 0$1 ) ;
6080: LD_INT 35
6082: PPUSH
6083: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6087: LD_EXP 77
6091: PUSH
6092: LD_VAR 0 2
6096: ARRAY
6097: PUSH
6098: LD_INT 6
6100: GREATEREQUAL
6101: IFFALSE 6080
// wait ( 0 0$20 ) ;
6103: LD_INT 700
6105: PPUSH
6106: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6110: LD_ADDR_VAR 0 5
6114: PUSH
6115: LD_INT 119
6117: PUSH
6118: LD_INT 9
6120: PUSH
6121: EMPTY
6122: LIST
6123: LIST
6124: PUSH
6125: EMPTY
6126: LIST
6127: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6128: LD_ADDR_VAR 0 6
6132: PUSH
6133: LD_EXP 77
6137: PUSH
6138: LD_VAR 0 2
6142: ARRAY
6143: PUSH
6144: LD_EXP 77
6148: PUSH
6149: LD_VAR 0 2
6153: ARRAY
6154: PPUSH
6155: LD_INT 34
6157: PUSH
6158: LD_INT 32
6160: PUSH
6161: EMPTY
6162: LIST
6163: LIST
6164: PPUSH
6165: CALL_OW 72
6169: DIFF
6170: ST_TO_ADDR
// if not attackers then
6171: LD_VAR 0 6
6175: NOT
6176: IFFALSE 6180
// exit ;
6178: GO 6359
// uc_side := 2 ;
6180: LD_ADDR_OWVAR 20
6184: PUSH
6185: LD_INT 2
6187: ST_TO_ADDR
// uc_nation := 2 ;
6188: LD_ADDR_OWVAR 21
6192: PUSH
6193: LD_INT 2
6195: ST_TO_ADDR
// InitHc ;
6196: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6200: LD_ADDR_VAR 0 1
6204: PUSH
6205: DOUBLE
6206: LD_INT 1
6208: DEC
6209: ST_TO_ADDR
6210: LD_INT 4
6212: PUSH
6213: LD_INT 5
6215: PUSH
6216: LD_INT 6
6218: PUSH
6219: EMPTY
6220: LIST
6221: LIST
6222: LIST
6223: PUSH
6224: LD_OWVAR 67
6228: ARRAY
6229: PUSH
6230: FOR_TO
6231: IFFALSE 6308
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6233: LD_INT 0
6235: PPUSH
6236: LD_INT 15
6238: PUSH
6239: LD_INT 17
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 1
6248: PPUSH
6249: LD_INT 2
6251: PPUSH
6252: CALL_OW 12
6256: ARRAY
6257: PPUSH
6258: LD_INT 8
6260: PPUSH
6261: CALL_OW 380
// un := CreateHuman ;
6265: LD_ADDR_VAR 0 7
6269: PUSH
6270: CALL_OW 44
6274: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6275: LD_VAR 0 7
6279: PPUSH
6280: LD_INT 23
6282: PPUSH
6283: LD_INT 0
6285: PPUSH
6286: CALL_OW 49
// attackers := attackers union un ;
6290: LD_ADDR_VAR 0 6
6294: PUSH
6295: LD_VAR 0 6
6299: PUSH
6300: LD_VAR 0 7
6304: UNION
6305: ST_TO_ADDR
// end ;
6306: GO 6230
6308: POP
6309: POP
// repeat wait ( 0 0$1 ) ;
6310: LD_INT 35
6312: PPUSH
6313: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6317: LD_VAR 0 6
6321: PPUSH
6322: LD_INT 60
6324: PUSH
6325: EMPTY
6326: LIST
6327: PPUSH
6328: CALL_OW 72
6332: NOT
6333: IFFALSE 6310
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6335: LD_VAR 0 2
6339: PPUSH
6340: LD_VAR 0 6
6344: PPUSH
6345: LD_VAR 0 5
6349: PPUSH
6350: LD_VAR 0 4
6354: PPUSH
6355: CALL 80747 0 4
// end ; end_of_file
6359: PPOPN 7
6361: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6362: LD_INT 0
6364: PPUSH
6365: PPUSH
6366: PPUSH
6367: PPUSH
// uc_side := 1 ;
6368: LD_ADDR_OWVAR 20
6372: PUSH
6373: LD_INT 1
6375: ST_TO_ADDR
// uc_nation := 1 ;
6376: LD_ADDR_OWVAR 21
6380: PUSH
6381: LD_INT 1
6383: ST_TO_ADDR
// InitHc ;
6384: CALL_OW 19
// InitVc ;
6388: CALL_OW 20
// tmp := [ ] ;
6392: LD_ADDR_VAR 0 3
6396: PUSH
6397: EMPTY
6398: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6399: LD_ADDR_VAR 0 2
6403: PUSH
6404: DOUBLE
6405: LD_INT 1
6407: DEC
6408: ST_TO_ADDR
6409: LD_INT 5
6411: PUSH
6412: LD_INT 6
6414: PUSH
6415: LD_INT 6
6417: PUSH
6418: EMPTY
6419: LIST
6420: LIST
6421: LIST
6422: PUSH
6423: LD_OWVAR 67
6427: ARRAY
6428: PUSH
6429: FOR_TO
6430: IFFALSE 6567
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6432: LD_INT 2
6434: PUSH
6435: LD_INT 4
6437: PUSH
6438: LD_INT 5
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: LIST
6445: PUSH
6446: LD_INT 1
6448: PPUSH
6449: LD_INT 3
6451: PPUSH
6452: CALL_OW 12
6456: ARRAY
6457: PPUSH
6458: LD_INT 1
6460: PUSH
6461: LD_INT 3
6463: PUSH
6464: EMPTY
6465: LIST
6466: LIST
6467: PUSH
6468: LD_INT 1
6470: PPUSH
6471: LD_INT 2
6473: PPUSH
6474: CALL_OW 12
6478: ARRAY
6479: PPUSH
6480: LD_INT 3
6482: PPUSH
6483: LD_INT 9
6485: PUSH
6486: LD_INT 7
6488: PUSH
6489: EMPTY
6490: LIST
6491: LIST
6492: PUSH
6493: LD_INT 1
6495: PPUSH
6496: LD_INT 2
6498: PPUSH
6499: CALL_OW 12
6503: ARRAY
6504: PPUSH
6505: LD_INT 78
6507: PPUSH
6508: CALL 20932 0 5
// veh := CreateVehicle ;
6512: LD_ADDR_VAR 0 4
6516: PUSH
6517: CALL_OW 45
6521: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6522: LD_VAR 0 4
6526: PPUSH
6527: LD_INT 2
6529: PPUSH
6530: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6534: LD_VAR 0 4
6538: PPUSH
6539: LD_INT 17
6541: PPUSH
6542: LD_INT 0
6544: PPUSH
6545: CALL_OW 49
// tmp := tmp ^ veh ;
6549: LD_ADDR_VAR 0 3
6553: PUSH
6554: LD_VAR 0 3
6558: PUSH
6559: LD_VAR 0 4
6563: ADD
6564: ST_TO_ADDR
// end ;
6565: GO 6429
6567: POP
6568: POP
// if not tmp then
6569: LD_VAR 0 3
6573: NOT
6574: IFFALSE 6578
// exit ;
6576: GO 6687
// if not first_powell_attack then
6578: LD_EXP 11
6582: NOT
6583: IFFALSE 6593
// first_powell_attack := true ;
6585: LD_ADDR_EXP 11
6589: PUSH
6590: LD_INT 1
6592: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6593: LD_INT 70
6595: PPUSH
6596: CALL_OW 67
// for i in tmp do
6600: LD_ADDR_VAR 0 2
6604: PUSH
6605: LD_VAR 0 3
6609: PUSH
6610: FOR_IN
6611: IFFALSE 6678
// if IsOk ( i ) then
6613: LD_VAR 0 2
6617: PPUSH
6618: CALL_OW 302
6622: IFFALSE 6660
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6624: LD_VAR 0 2
6628: PPUSH
6629: LD_INT 81
6631: PUSH
6632: LD_INT 1
6634: PUSH
6635: EMPTY
6636: LIST
6637: LIST
6638: PPUSH
6639: CALL_OW 69
6643: PPUSH
6644: LD_VAR 0 2
6648: PPUSH
6649: CALL_OW 74
6653: PPUSH
6654: CALL_OW 115
6658: GO 6676
// tmp := tmp diff i ;
6660: LD_ADDR_VAR 0 3
6664: PUSH
6665: LD_VAR 0 3
6669: PUSH
6670: LD_VAR 0 2
6674: DIFF
6675: ST_TO_ADDR
6676: GO 6610
6678: POP
6679: POP
// until not tmp ;
6680: LD_VAR 0 3
6684: NOT
6685: IFFALSE 6593
// end ; end_of_file
6687: LD_VAR 0 1
6691: RET
// export function Action ; var tmp , i , un ; begin
6692: LD_INT 0
6694: PPUSH
6695: PPUSH
6696: PPUSH
6697: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6698: LD_INT 68
6700: PPUSH
6701: LD_INT 39
6703: PPUSH
6704: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6708: LD_ADDR_VAR 0 2
6712: PUSH
6713: LD_INT 22
6715: PUSH
6716: LD_INT 7
6718: PUSH
6719: EMPTY
6720: LIST
6721: LIST
6722: PPUSH
6723: CALL_OW 69
6727: ST_TO_ADDR
// InGameOn ;
6728: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6732: LD_VAR 0 2
6736: PPUSH
6737: LD_INT 71
6739: PPUSH
6740: LD_INT 49
6742: PPUSH
6743: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6747: LD_INT 35
6749: PPUSH
6750: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6754: LD_INT 7
6756: PPUSH
6757: LD_INT 71
6759: PPUSH
6760: LD_INT 51
6762: PPUSH
6763: CALL_OW 293
6767: IFFALSE 6747
// DialogueOn ;
6769: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6773: LD_EXP 14
6777: PPUSH
6778: LD_STRING D1-JMM-1
6780: PPUSH
6781: CALL_OW 88
// if Joan then
6785: LD_EXP 29
6789: IFFALSE 6803
// Say ( Joan , D1-Joan-1 ) ;
6791: LD_EXP 29
6795: PPUSH
6796: LD_STRING D1-Joan-1
6798: PPUSH
6799: CALL_OW 88
// if Lisa then
6803: LD_EXP 16
6807: IFFALSE 6821
// Say ( Lisa , D1-Lisa-1 ) ;
6809: LD_EXP 16
6813: PPUSH
6814: LD_STRING D1-Lisa-1
6816: PPUSH
6817: CALL_OW 88
// if Joan or Lisa then
6821: LD_EXP 29
6825: PUSH
6826: LD_EXP 16
6830: OR
6831: IFFALSE 6845
// Say ( JMM , D1-JMM-2 ) ;
6833: LD_EXP 14
6837: PPUSH
6838: LD_STRING D1-JMM-2
6840: PPUSH
6841: CALL_OW 88
// DialogueOff ;
6845: CALL_OW 7
// InGameOff ;
6849: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6853: LD_INT 71
6855: PPUSH
6856: LD_INT 50
6858: PPUSH
6859: LD_INT 7
6861: PPUSH
6862: LD_INT 30
6864: NEG
6865: PPUSH
6866: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6870: LD_INT 71
6872: PPUSH
6873: LD_INT 50
6875: PPUSH
6876: LD_INT 7
6878: PPUSH
6879: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6883: LD_STRING M1
6885: PPUSH
6886: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6890: LD_INT 35
6892: PPUSH
6893: CALL_OW 67
// until freedom ;
6897: LD_EXP 3
6901: IFFALSE 6890
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6903: LD_INT 350
6905: PPUSH
6906: LD_INT 700
6908: PPUSH
6909: CALL_OW 12
6913: PPUSH
6914: CALL_OW 67
// PrepareGossudarov ;
6918: CALL 1710 0 0
// repeat wait ( 0 0$1 ) ;
6922: LD_INT 35
6924: PPUSH
6925: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
6929: LD_INT 22
6931: PUSH
6932: LD_INT 6
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: LD_INT 3
6941: PUSH
6942: LD_INT 24
6944: PUSH
6945: LD_INT 1000
6947: PUSH
6948: EMPTY
6949: LIST
6950: LIST
6951: PUSH
6952: EMPTY
6953: LIST
6954: LIST
6955: PUSH
6956: EMPTY
6957: LIST
6958: LIST
6959: PPUSH
6960: CALL_OW 69
6964: PUSH
6965: LD_INT 7
6967: PPUSH
6968: LD_EXP 31
6972: PPUSH
6973: CALL_OW 292
6977: OR
6978: IFFALSE 6922
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
6980: LD_ADDR_VAR 0 2
6984: PUSH
6985: LD_INT 22
6987: PUSH
6988: LD_INT 6
6990: PUSH
6991: EMPTY
6992: LIST
6993: LIST
6994: PPUSH
6995: CALL_OW 69
6999: ST_TO_ADDR
// for i in tmp do
7000: LD_ADDR_VAR 0 3
7004: PUSH
7005: LD_VAR 0 2
7009: PUSH
7010: FOR_IN
7011: IFFALSE 7027
// SetSide ( i , 7 ) ;
7013: LD_VAR 0 3
7017: PPUSH
7018: LD_INT 7
7020: PPUSH
7021: CALL_OW 235
7025: GO 7010
7027: POP
7028: POP
// DialogueOn ;
7029: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7033: LD_EXP 14
7037: PUSH
7038: LD_EXP 15
7042: PUSH
7043: EMPTY
7044: LIST
7045: LIST
7046: PPUSH
7047: LD_EXP 31
7051: PPUSH
7052: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7056: LD_EXP 31
7060: PPUSH
7061: CALL_OW 87
// if not Roth then
7065: LD_EXP 15
7069: NOT
7070: IFFALSE 7162
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7072: LD_VAR 0 2
7076: PPUSH
7077: LD_INT 3
7079: PUSH
7080: LD_INT 24
7082: PUSH
7083: LD_INT 1000
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: PUSH
7090: EMPTY
7091: LIST
7092: LIST
7093: PPUSH
7094: CALL_OW 72
7098: IFFALSE 7112
// Say ( JMM , D2-JMM-1 ) ;
7100: LD_EXP 14
7104: PPUSH
7105: LD_STRING D2-JMM-1
7107: PPUSH
7108: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7112: LD_EXP 14
7116: PPUSH
7117: LD_STRING D2-JMM-1b
7119: PPUSH
7120: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7124: LD_EXP 31
7128: PPUSH
7129: LD_STRING D2-Gos-1
7131: PPUSH
7132: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7136: LD_EXP 14
7140: PPUSH
7141: LD_STRING D2-JMM-2
7143: PPUSH
7144: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7148: LD_EXP 31
7152: PPUSH
7153: LD_STRING D2-Gos-2
7155: PPUSH
7156: CALL_OW 88
// end else
7160: GO 7314
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7162: LD_VAR 0 2
7166: PPUSH
7167: LD_INT 3
7169: PUSH
7170: LD_INT 24
7172: PUSH
7173: LD_INT 1000
7175: PUSH
7176: EMPTY
7177: LIST
7178: LIST
7179: PUSH
7180: EMPTY
7181: LIST
7182: LIST
7183: PPUSH
7184: CALL_OW 72
7188: IFFALSE 7214
// begin Say ( Roth , D2-Roth-2 ) ;
7190: LD_EXP 15
7194: PPUSH
7195: LD_STRING D2-Roth-2
7197: PPUSH
7198: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7202: LD_EXP 14
7206: PPUSH
7207: LD_STRING D2-JMM-1a
7209: PPUSH
7210: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7214: LD_EXP 15
7218: PPUSH
7219: LD_STRING D2-Roth-2a
7221: PPUSH
7222: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7226: LD_EXP 15
7230: PPUSH
7231: LD_STRING D2-Roth-2b
7233: PPUSH
7234: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7238: LD_EXP 14
7242: PPUSH
7243: LD_STRING D2-JMM-3
7245: PPUSH
7246: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7250: LD_VAR 0 2
7254: PPUSH
7255: LD_INT 3
7257: PUSH
7258: LD_INT 24
7260: PUSH
7261: LD_INT 1000
7263: PUSH
7264: EMPTY
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: PPUSH
7272: CALL_OW 72
7276: IFFALSE 7314
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7278: LD_EXP 31
7282: PPUSH
7283: LD_STRING D2-Gos-3
7285: PPUSH
7286: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7290: LD_EXP 14
7294: PPUSH
7295: LD_STRING D2-JMM-4
7297: PPUSH
7298: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7302: LD_EXP 31
7306: PPUSH
7307: LD_STRING D2-Gos-4
7309: PPUSH
7310: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7314: LD_EXP 14
7318: PPUSH
7319: LD_STRING D2-JMM-5
7321: PPUSH
7322: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7326: LD_EXP 31
7330: PPUSH
7331: LD_STRING D2-Gos-5
7333: PPUSH
7334: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7338: LD_EXP 14
7342: PPUSH
7343: LD_STRING D2-JMM-6
7345: PPUSH
7346: CALL_OW 88
// DialogueOff ;
7350: CALL_OW 7
// wait ( 0 0$2 ) ;
7354: LD_INT 70
7356: PPUSH
7357: CALL_OW 67
// if Kirilenkova then
7361: LD_EXP 32
7365: IFFALSE 7379
// Say ( Kirilenkova , D3-Kir-1 ) ;
7367: LD_EXP 32
7371: PPUSH
7372: LD_STRING D3-Kir-1
7374: PPUSH
7375: CALL_OW 88
// gossudarov_arrive := true ;
7379: LD_ADDR_EXP 4
7383: PUSH
7384: LD_INT 1
7386: ST_TO_ADDR
// Hint ( CombinedForces ) ;
7387: LD_STRING CombinedForces
7389: PPUSH
7390: CALL_OW 339
// repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until ru_lab_builded ;
7401: LD_EXP 5
7405: IFFALSE 7394
// if Kirilenkova then
7407: LD_EXP 32
7411: IFFALSE 7427
// Say ( Kirilenkova , D3a-Kir-1 ) else
7413: LD_EXP 32
7417: PPUSH
7418: LD_STRING D3a-Kir-1
7420: PPUSH
7421: CALL_OW 88
7425: GO 7449
// begin un := SciRu ;
7427: LD_ADDR_VAR 0 4
7431: PUSH
7432: CALL 12437 0 0
7436: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7437: LD_VAR 0 4
7441: PPUSH
7442: LD_STRING D3a-Sci1-1
7444: PPUSH
7445: CALL_OW 88
// end ; if Kirilenkova or un then
7449: LD_EXP 32
7453: PUSH
7454: LD_VAR 0 4
7458: OR
7459: IFFALSE 7473
// Say ( JMM , D3a-JMM-1 ) ;
7461: LD_EXP 14
7465: PPUSH
7466: LD_STRING D3a-JMM-1
7468: PPUSH
7469: CALL_OW 88
// end ;
7473: LD_VAR 0 1
7477: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7478: LD_EXP 4
7482: PUSH
7483: LD_INT 22
7485: PUSH
7486: LD_INT 7
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: PUSH
7493: LD_INT 2
7495: PUSH
7496: LD_INT 25
7498: PUSH
7499: LD_INT 1
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: LD_INT 25
7508: PUSH
7509: LD_INT 2
7511: PUSH
7512: EMPTY
7513: LIST
7514: LIST
7515: PUSH
7516: LD_INT 25
7518: PUSH
7519: LD_INT 3
7521: PUSH
7522: EMPTY
7523: LIST
7524: LIST
7525: PUSH
7526: LD_INT 25
7528: PUSH
7529: LD_INT 4
7531: PUSH
7532: EMPTY
7533: LIST
7534: LIST
7535: PUSH
7536: LD_INT 25
7538: PUSH
7539: LD_INT 5
7541: PUSH
7542: EMPTY
7543: LIST
7544: LIST
7545: PUSH
7546: LD_INT 25
7548: PUSH
7549: LD_INT 8
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: PUSH
7556: LD_INT 25
7558: PUSH
7559: LD_INT 9
7561: PUSH
7562: EMPTY
7563: LIST
7564: LIST
7565: PUSH
7566: EMPTY
7567: LIST
7568: LIST
7569: LIST
7570: LIST
7571: LIST
7572: LIST
7573: LIST
7574: LIST
7575: PUSH
7576: EMPTY
7577: LIST
7578: LIST
7579: PPUSH
7580: CALL_OW 69
7584: PUSH
7585: LD_INT 7
7587: LESS
7588: AND
7589: IFFALSE 7601
7591: GO 7593
7593: DISABLE
// YouLost ( TooMany ) ;
7594: LD_STRING TooMany
7596: PPUSH
7597: CALL_OW 104
7601: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7602: LD_EXP 31
7606: PPUSH
7607: CALL_OW 255
7611: PUSH
7612: LD_INT 7
7614: EQUAL
7615: IFFALSE 7815
7617: GO 7619
7619: DISABLE
7620: LD_INT 0
7622: PPUSH
7623: PPUSH
7624: PPUSH
// begin uc_side := 3 ;
7625: LD_ADDR_OWVAR 20
7629: PUSH
7630: LD_INT 3
7632: ST_TO_ADDR
// uc_nation := 3 ;
7633: LD_ADDR_OWVAR 21
7637: PUSH
7638: LD_INT 3
7640: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7641: LD_INT 21
7643: PPUSH
7644: LD_INT 3
7646: PPUSH
7647: LD_INT 3
7649: PPUSH
7650: LD_INT 42
7652: PPUSH
7653: LD_INT 100
7655: PPUSH
7656: CALL 20932 0 5
// un := CreateVehicle ;
7660: LD_ADDR_VAR 0 3
7664: PUSH
7665: CALL_OW 45
7669: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 15
7677: PPUSH
7678: LD_INT 0
7680: PPUSH
7681: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_INT 67
7692: PPUSH
7693: LD_INT 45
7695: PPUSH
7696: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7700: LD_VAR 0 3
7704: PPUSH
7705: LD_INT 70
7707: PPUSH
7708: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7712: LD_VAR 0 3
7716: PPUSH
7717: LD_INT 69
7719: PPUSH
7720: LD_INT 18
7722: PPUSH
7723: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7727: LD_VAR 0 3
7731: PPUSH
7732: LD_INT 60
7734: PPUSH
7735: LD_INT 2
7737: PPUSH
7738: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7742: LD_INT 35
7744: PPUSH
7745: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7749: LD_VAR 0 3
7753: PPUSH
7754: CALL_OW 302
7758: NOT
7759: PUSH
7760: LD_VAR 0 3
7764: PPUSH
7765: LD_INT 17
7767: PPUSH
7768: CALL_OW 308
7772: OR
7773: IFFALSE 7742
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7775: LD_VAR 0 3
7779: PPUSH
7780: LD_INT 17
7782: PPUSH
7783: CALL_OW 308
7787: PUSH
7788: LD_VAR 0 3
7792: PPUSH
7793: LD_INT 60
7795: PPUSH
7796: LD_INT 2
7798: PPUSH
7799: CALL_OW 307
7803: OR
7804: IFFALSE 7815
// RemoveUnit ( un ) ;
7806: LD_VAR 0 3
7810: PPUSH
7811: CALL_OW 64
// end ;
7815: PPOPN 3
7817: END
// every 0 0$2 do var i , un , tmp ;
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7826: LD_INT 70
7828: PPUSH
7829: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7833: LD_ADDR_VAR 0 3
7837: PUSH
7838: LD_INT 22
7840: PUSH
7841: LD_INT 7
7843: PUSH
7844: EMPTY
7845: LIST
7846: LIST
7847: PUSH
7848: LD_INT 101
7850: PUSH
7851: LD_INT 3
7853: PUSH
7854: EMPTY
7855: LIST
7856: LIST
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 69
7866: ST_TO_ADDR
// until tmp ;
7867: LD_VAR 0 3
7871: IFFALSE 7826
// un := NearestUnitToUnit ( tmp , JMM ) ;
7873: LD_ADDR_VAR 0 2
7877: PUSH
7878: LD_VAR 0 3
7882: PPUSH
7883: LD_EXP 14
7887: PPUSH
7888: CALL_OW 74
7892: ST_TO_ADDR
// player_spotted := true ;
7893: LD_ADDR_EXP 6
7897: PUSH
7898: LD_INT 1
7900: ST_TO_ADDR
// tmp := SciRu ;
7901: LD_ADDR_VAR 0 3
7905: PUSH
7906: CALL 12437 0 0
7910: ST_TO_ADDR
// if not tmp then
7911: LD_VAR 0 3
7915: NOT
7916: IFFALSE 7928
// tmp := SolRu ;
7918: LD_ADDR_VAR 0 3
7922: PUSH
7923: CALL 12584 0 0
7927: ST_TO_ADDR
// DialogueOn ;
7928: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7932: LD_VAR 0 2
7936: PPUSH
7937: CALL_OW 250
7941: PPUSH
7942: LD_VAR 0 2
7946: PPUSH
7947: CALL_OW 251
7951: PPUSH
7952: LD_INT 7
7954: PPUSH
7955: LD_INT 8
7957: NEG
7958: PPUSH
7959: CALL_OW 330
// CenterNowOnUnits ( un ) ;
7963: LD_VAR 0 2
7967: PPUSH
7968: CALL_OW 87
// if tmp then
7972: LD_VAR 0 3
7976: IFFALSE 7990
// Say ( tmp , D4-RSci1-1 ) ;
7978: LD_VAR 0 3
7982: PPUSH
7983: LD_STRING D4-RSci1-1
7985: PPUSH
7986: CALL_OW 88
// if Gossudarov then
7990: LD_EXP 31
7994: IFFALSE 8020
// begin Say ( Gossudarov , D4-Gos-1 ) ;
7996: LD_EXP 31
8000: PPUSH
8001: LD_STRING D4-Gos-1
8003: PPUSH
8004: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8008: LD_EXP 14
8012: PPUSH
8013: LD_STRING D4-JMM-1
8015: PPUSH
8016: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8020: LD_VAR 0 2
8024: PPUSH
8025: CALL_OW 250
8029: PPUSH
8030: LD_VAR 0 2
8034: PPUSH
8035: CALL_OW 251
8039: PPUSH
8040: LD_INT 7
8042: PPUSH
8043: CALL_OW 331
// DialogueOff ;
8047: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8051: LD_STRING M5
8053: PPUSH
8054: CALL_OW 337
// end ;
8058: PPOPN 3
8060: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8061: LD_EXP 6
8065: IFFALSE 8654
8067: GO 8069
8069: DISABLE
8070: LD_INT 0
8072: PPUSH
8073: PPUSH
8074: PPUSH
// begin PrepareBelkov ;
8075: CALL 2000 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8079: LD_EXP 46
8083: PPUSH
8084: LD_INT 118
8086: PPUSH
8087: LD_INT 106
8089: PPUSH
8090: CALL_OW 111
// AddComHold ( Belkov ) ;
8094: LD_EXP 46
8098: PPUSH
8099: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8103: LD_INT 35
8105: PPUSH
8106: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8110: LD_EXP 46
8114: PPUSH
8115: LD_INT 118
8117: PPUSH
8118: LD_INT 106
8120: PPUSH
8121: CALL_OW 307
8125: IFFALSE 8103
// ChangeSideFog ( 4 , 7 ) ;
8127: LD_INT 4
8129: PPUSH
8130: LD_INT 7
8132: PPUSH
8133: CALL_OW 343
// if IsOk ( Belkov ) then
8137: LD_EXP 46
8141: PPUSH
8142: CALL_OW 302
8146: IFFALSE 8230
// begin InGameOn ;
8148: CALL_OW 8
// DialogueOn ;
8152: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8156: LD_EXP 46
8160: PPUSH
8161: LD_STRING D5-Bel-1
8163: PPUSH
8164: CALL_OW 94
// if Gossudarov then
8168: LD_EXP 31
8172: IFFALSE 8222
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8174: LD_EXP 31
8178: PPUSH
8179: LD_STRING D5-Gos-1
8181: PPUSH
8182: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8186: LD_EXP 14
8190: PPUSH
8191: LD_STRING D5-JMM-1
8193: PPUSH
8194: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8198: LD_EXP 31
8202: PPUSH
8203: LD_STRING D5-Gos-2
8205: PPUSH
8206: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8210: LD_EXP 14
8214: PPUSH
8215: LD_STRING D5-JMM-2
8217: PPUSH
8218: CALL_OW 88
// end ; DialogueOff ;
8222: CALL_OW 7
// InGameOff ;
8226: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8230: LD_STRING QSaveBelkov
8232: PPUSH
8233: CALL_OW 97
8237: PUSH
8238: LD_INT 1
8240: DOUBLE
8241: EQUAL
8242: IFTRUE 8246
8244: GO 8296
8246: POP
// begin DialogueOn ;
8247: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8251: LD_EXP 14
8255: PPUSH
8256: LD_STRING D5a-JMM-1
8258: PPUSH
8259: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8263: LD_EXP 46
8267: PPUSH
8268: LD_STRING D5a-Bel-1
8270: PPUSH
8271: CALL_OW 94
// DialogueOff ;
8275: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8279: LD_EXP 46
8283: PPUSH
8284: LD_INT 83
8286: PPUSH
8287: LD_INT 49
8289: PPUSH
8290: CALL_OW 111
// end ; 2 :
8294: GO 8329
8296: LD_INT 2
8298: DOUBLE
8299: EQUAL
8300: IFTRUE 8304
8302: GO 8328
8304: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8305: LD_EXP 14
8309: PPUSH
8310: LD_STRING D5a-JMM-2
8312: PPUSH
8313: CALL_OW 88
// ComHold ( Belkov ) ;
8317: LD_EXP 46
8321: PPUSH
8322: CALL_OW 140
// end ; end ;
8326: GO 8329
8328: POP
// time := 0 0$00 ;
8329: LD_ADDR_VAR 0 1
8333: PUSH
8334: LD_INT 0
8336: ST_TO_ADDR
// vehSpawned := false ;
8337: LD_ADDR_VAR 0 3
8341: PUSH
8342: LD_INT 0
8344: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8345: LD_INT 35
8347: PPUSH
8348: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8352: LD_VAR 0 1
8356: PUSH
8357: LD_INT 350
8359: PUSH
8360: LD_INT 175
8362: PUSH
8363: LD_INT 70
8365: PUSH
8366: EMPTY
8367: LIST
8368: LIST
8369: LIST
8370: PUSH
8371: LD_OWVAR 67
8375: ARRAY
8376: GREATEREQUAL
8377: PUSH
8378: LD_VAR 0 3
8382: NOT
8383: AND
8384: IFFALSE 8474
// begin vehSpawned := true ;
8386: LD_ADDR_VAR 0 3
8390: PUSH
8391: LD_INT 1
8393: ST_TO_ADDR
// uc_side := 3 ;
8394: LD_ADDR_OWVAR 20
8398: PUSH
8399: LD_INT 3
8401: ST_TO_ADDR
// uc_nation := 3 ;
8402: LD_ADDR_OWVAR 21
8406: PUSH
8407: LD_INT 3
8409: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8410: LD_INT 22
8412: PPUSH
8413: LD_INT 3
8415: PPUSH
8416: LD_INT 3
8418: PPUSH
8419: LD_INT 43
8421: PPUSH
8422: LD_INT 100
8424: PPUSH
8425: CALL 20932 0 5
// veh := CreateVehicle ;
8429: LD_ADDR_VAR 0 2
8433: PUSH
8434: CALL_OW 45
8438: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8439: LD_VAR 0 2
8443: PPUSH
8444: LD_INT 130
8446: PPUSH
8447: LD_INT 131
8449: PPUSH
8450: LD_INT 0
8452: PPUSH
8453: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8457: LD_VAR 0 2
8461: PPUSH
8462: LD_INT 100
8464: PPUSH
8465: LD_INT 82
8467: PPUSH
8468: CALL_OW 114
// end else
8472: GO 8488
// time := time + 0 0$1 ;
8474: LD_ADDR_VAR 0 1
8478: PUSH
8479: LD_VAR 0 1
8483: PUSH
8484: LD_INT 35
8486: PLUS
8487: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8488: LD_EXP 46
8492: PPUSH
8493: CALL_OW 301
8497: PUSH
8498: LD_EXP 46
8502: PPUSH
8503: CALL_OW 255
8507: PUSH
8508: LD_INT 4
8510: EQUAL
8511: AND
8512: PUSH
8513: LD_INT 22
8515: PUSH
8516: LD_INT 7
8518: PUSH
8519: EMPTY
8520: LIST
8521: LIST
8522: PPUSH
8523: CALL_OW 69
8527: PPUSH
8528: LD_EXP 46
8532: PPUSH
8533: CALL_OW 74
8537: PPUSH
8538: LD_EXP 46
8542: PPUSH
8543: CALL_OW 296
8547: PUSH
8548: LD_INT 10
8550: LESS
8551: OR
8552: IFFALSE 8345
// if IsDead ( Belkov ) then
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: IFFALSE 8588
// begin CenterNowOnUnits ( Belkov ) ;
8565: LD_EXP 46
8569: PPUSH
8570: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8574: LD_EXP 14
8578: PPUSH
8579: LD_STRING D5a-JMM-2a
8581: PPUSH
8582: CALL_OW 88
// exit ;
8586: GO 8654
// end ; if See ( 7 , Belkov ) then
8588: LD_INT 7
8590: PPUSH
8591: LD_EXP 46
8595: PPUSH
8596: CALL_OW 292
8600: IFFALSE 8614
// SetSide ( Belkov , 7 ) ;
8602: LD_EXP 46
8606: PPUSH
8607: LD_INT 7
8609: PPUSH
8610: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8614: LD_INT 35
8616: PPUSH
8617: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8621: LD_EXP 46
8625: PPUSH
8626: LD_INT 66
8628: PPUSH
8629: LD_INT 45
8631: PPUSH
8632: CALL_OW 297
8636: PUSH
8637: LD_INT 30
8639: LESS
8640: IFFALSE 8614
// Say ( Belkov , D6-Bel-1 ) ;
8642: LD_EXP 46
8646: PPUSH
8647: LD_STRING D6-Bel-1
8649: PPUSH
8650: CALL_OW 88
// end ;
8654: PPOPN 3
8656: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 302
8666: PUSH
8667: LD_EXP 46
8671: PPUSH
8672: CALL_OW 504
8676: PUSH
8677: LD_INT 2
8679: PUSH
8680: LD_INT 34
8682: PUSH
8683: LD_INT 47
8685: PUSH
8686: EMPTY
8687: LIST
8688: LIST
8689: PUSH
8690: LD_INT 34
8692: PUSH
8693: LD_INT 45
8695: PUSH
8696: EMPTY
8697: LIST
8698: LIST
8699: PUSH
8700: EMPTY
8701: LIST
8702: LIST
8703: LIST
8704: PPUSH
8705: CALL_OW 69
8709: IN
8710: AND
8711: IFFALSE 8728
8713: GO 8715
8715: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8716: LD_EXP 46
8720: PPUSH
8721: LD_STRING D7-Bel-1
8723: PPUSH
8724: CALL_OW 88
8728: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8729: LD_INT 22
8731: PUSH
8732: LD_INT 7
8734: PUSH
8735: EMPTY
8736: LIST
8737: LIST
8738: PUSH
8739: LD_INT 101
8741: PUSH
8742: LD_INT 2
8744: PUSH
8745: EMPTY
8746: LIST
8747: LIST
8748: PUSH
8749: EMPTY
8750: LIST
8751: LIST
8752: PPUSH
8753: CALL_OW 69
8757: PUSH
8758: LD_EXP 8
8762: NOT
8763: AND
8764: PUSH
8765: LD_EXP 45
8769: PPUSH
8770: CALL_OW 305
8774: NOT
8775: AND
8776: IFFALSE 9246
8778: GO 8780
8780: DISABLE
8781: LD_INT 0
8783: PPUSH
// begin ar_base_spotted := true ;
8784: LD_ADDR_EXP 8
8788: PUSH
8789: LD_INT 1
8791: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8792: LD_ADDR_VAR 0 1
8796: PUSH
8797: LD_INT 22
8799: PUSH
8800: LD_INT 2
8802: PUSH
8803: EMPTY
8804: LIST
8805: LIST
8806: PUSH
8807: LD_INT 21
8809: PUSH
8810: LD_INT 3
8812: PUSH
8813: EMPTY
8814: LIST
8815: LIST
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PPUSH
8821: CALL_OW 69
8825: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8826: LD_ADDR_VAR 0 1
8830: PUSH
8831: LD_VAR 0 1
8835: PPUSH
8836: LD_EXP 14
8840: PPUSH
8841: CALL_OW 74
8845: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8846: LD_INT 7
8848: PPUSH
8849: LD_INT 3
8851: PPUSH
8852: CALL_OW 332
// DialogueOn ;
8856: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8860: LD_VAR 0 1
8864: PPUSH
8865: CALL_OW 250
8869: PPUSH
8870: LD_VAR 0 1
8874: PPUSH
8875: CALL_OW 251
8879: PPUSH
8880: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8884: LD_ADDR_VAR 0 1
8888: PUSH
8889: LD_INT 22
8891: PUSH
8892: LD_INT 7
8894: PUSH
8895: EMPTY
8896: LIST
8897: LIST
8898: PUSH
8899: LD_INT 23
8901: PUSH
8902: LD_INT 1
8904: PUSH
8905: EMPTY
8906: LIST
8907: LIST
8908: PUSH
8909: LD_INT 26
8911: PUSH
8912: LD_INT 1
8914: PUSH
8915: EMPTY
8916: LIST
8917: LIST
8918: PUSH
8919: EMPTY
8920: LIST
8921: LIST
8922: LIST
8923: PPUSH
8924: CALL_OW 69
8928: PUSH
8929: LD_EXP 14
8933: PUSH
8934: LD_EXP 18
8938: PUSH
8939: LD_EXP 19
8943: PUSH
8944: LD_EXP 26
8948: PUSH
8949: LD_EXP 15
8953: PUSH
8954: LD_EXP 24
8958: PUSH
8959: LD_EXP 20
8963: PUSH
8964: LD_EXP 22
8968: PUSH
8969: EMPTY
8970: LIST
8971: LIST
8972: LIST
8973: LIST
8974: LIST
8975: LIST
8976: LIST
8977: LIST
8978: DIFF
8979: ST_TO_ADDR
// if not tmp then
8980: LD_VAR 0 1
8984: NOT
8985: IFFALSE 9059
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
8987: LD_ADDR_VAR 0 1
8991: PUSH
8992: LD_INT 22
8994: PUSH
8995: LD_INT 7
8997: PUSH
8998: EMPTY
8999: LIST
9000: LIST
9001: PUSH
9002: LD_INT 23
9004: PUSH
9005: LD_INT 1
9007: PUSH
9008: EMPTY
9009: LIST
9010: LIST
9011: PUSH
9012: LD_INT 26
9014: PUSH
9015: LD_INT 2
9017: PUSH
9018: EMPTY
9019: LIST
9020: LIST
9021: PUSH
9022: EMPTY
9023: LIST
9024: LIST
9025: LIST
9026: PPUSH
9027: CALL_OW 69
9031: PUSH
9032: LD_EXP 29
9036: PUSH
9037: LD_EXP 16
9041: PUSH
9042: LD_EXP 27
9046: PUSH
9047: LD_EXP 28
9051: PUSH
9052: EMPTY
9053: LIST
9054: LIST
9055: LIST
9056: LIST
9057: DIFF
9058: ST_TO_ADDR
// if tmp then
9059: LD_VAR 0 1
9063: IFFALSE 9134
// case GetSex ( tmp [ 1 ] ) of sex_male :
9065: LD_VAR 0 1
9069: PUSH
9070: LD_INT 1
9072: ARRAY
9073: PPUSH
9074: CALL_OW 258
9078: PUSH
9079: LD_INT 1
9081: DOUBLE
9082: EQUAL
9083: IFTRUE 9087
9085: GO 9106
9087: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9088: LD_VAR 0 1
9092: PUSH
9093: LD_INT 1
9095: ARRAY
9096: PPUSH
9097: LD_STRING D9-Sol1-1
9099: PPUSH
9100: CALL_OW 88
9104: GO 9134
9106: LD_INT 2
9108: DOUBLE
9109: EQUAL
9110: IFTRUE 9114
9112: GO 9133
9114: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9115: LD_VAR 0 1
9119: PUSH
9120: LD_INT 1
9122: ARRAY
9123: PPUSH
9124: LD_STRING D9-FSol1-1
9126: PPUSH
9127: CALL_OW 88
9131: GO 9134
9133: POP
// if Frank then
9134: LD_EXP 26
9138: IFFALSE 9242
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9140: LD_EXP 55
9144: PPUSH
9145: CALL_OW 250
9149: PPUSH
9150: LD_EXP 55
9154: PPUSH
9155: CALL_OW 251
9159: PPUSH
9160: LD_INT 7
9162: PPUSH
9163: LD_INT 8
9165: PPUSH
9166: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9170: LD_EXP 55
9174: PPUSH
9175: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9179: LD_EXP 26
9183: PPUSH
9184: LD_STRING D9-Frank-1
9186: PPUSH
9187: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9191: LD_EXP 14
9195: PPUSH
9196: LD_STRING D9-JMM-1
9198: PPUSH
9199: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9203: LD_EXP 26
9207: PPUSH
9208: LD_STRING D9-Frank-2
9210: PPUSH
9211: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9215: LD_EXP 55
9219: PPUSH
9220: CALL_OW 250
9224: PPUSH
9225: LD_EXP 55
9229: PPUSH
9230: CALL_OW 251
9234: PPUSH
9235: LD_INT 7
9237: PPUSH
9238: CALL_OW 331
// end ; DialogueOff ;
9242: CALL_OW 7
// end ;
9246: PPOPN 1
9248: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9249: LD_EXP 7
9253: PUSH
9254: LD_OWVAR 1
9258: PUSH
9259: LD_INT 42000
9261: GREATEREQUAL
9262: OR
9263: IFFALSE 10290
9265: GO 9267
9267: DISABLE
9268: LD_INT 0
9270: PPUSH
9271: PPUSH
// begin selected_option := 1 ;
9272: LD_ADDR_VAR 0 2
9276: PUSH
9277: LD_INT 1
9279: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9280: LD_INT 10500
9282: PPUSH
9283: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9287: LD_INT 35
9289: PPUSH
9290: CALL_OW 67
// until not ru_attackers ;
9294: LD_EXP 51
9298: NOT
9299: IFFALSE 9287
// PrepareBurlak ;
9301: CALL 2112 0 0
// repeat wait ( 0 0$2 ) ;
9305: LD_INT 70
9307: PPUSH
9308: CALL_OW 67
// until not HasTask ( Burlak ) ;
9312: LD_EXP 45
9316: PPUSH
9317: CALL_OW 314
9321: NOT
9322: IFFALSE 9305
// InGameOn ;
9324: CALL_OW 8
// DialogueOn ;
9328: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9332: LD_EXP 48
9336: PPUSH
9337: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9341: LD_EXP 45
9345: PPUSH
9346: LD_STRING D10-Bur-1
9348: PPUSH
9349: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9353: LD_EXP 46
9357: PUSH
9358: LD_EXP 46
9362: PPUSH
9363: CALL_OW 255
9367: PUSH
9368: LD_INT 7
9370: EQUAL
9371: AND
9372: IFFALSE 9386
// Say ( Belkov , D10-Bel-1 ) ;
9374: LD_EXP 46
9378: PPUSH
9379: LD_STRING D10-Bel-1
9381: PPUSH
9382: CALL_OW 88
// if Gossudarov then
9386: LD_EXP 31
9390: IFFALSE 9404
// Say ( Gossudarov , D10-Gos-1 ) ;
9392: LD_EXP 31
9396: PPUSH
9397: LD_STRING D10-Gos-1
9399: PPUSH
9400: CALL_OW 88
// if Kirilenkova then
9404: LD_EXP 32
9408: IFFALSE 9422
// Say ( Kirilenkova , D10-Kir-1 ) ;
9410: LD_EXP 32
9414: PPUSH
9415: LD_STRING D10-Kir-1
9417: PPUSH
9418: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9422: CALL 12584 0 0
9426: PPUSH
9427: LD_STRING D10-RSol1-1
9429: PPUSH
9430: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9434: LD_EXP 45
9438: PPUSH
9439: LD_STRING D10-Bur-2
9441: PPUSH
9442: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9446: LD_EXP 14
9450: PPUSH
9451: LD_STRING D10-JMM-2
9453: PPUSH
9454: CALL_OW 88
// if Kirilenkova then
9458: LD_EXP 32
9462: IFFALSE 9478
// Say ( Kirilenkova , D10-Kir-2 ) else
9464: LD_EXP 32
9468: PPUSH
9469: LD_STRING D10-Kir-2
9471: PPUSH
9472: CALL_OW 88
9476: GO 9490
// Say ( SolRu , D10-RSol1-2 ) ;
9478: CALL 12584 0 0
9482: PPUSH
9483: LD_STRING D10-RSol1-2
9485: PPUSH
9486: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9490: LD_EXP 14
9494: PPUSH
9495: LD_STRING D10-JMM-3
9497: PPUSH
9498: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9502: LD_EXP 45
9506: PPUSH
9507: LD_STRING D10-Bur-3
9509: PPUSH
9510: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9514: LD_EXP 14
9518: PPUSH
9519: LD_STRING D10-JMM-4
9521: PPUSH
9522: CALL_OW 88
// DialogueOff ;
9526: CALL_OW 7
// InGameOff ;
9530: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9534: LD_STRING M2
9536: PPUSH
9537: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9541: LD_INT 35
9543: PPUSH
9544: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9548: LD_INT 22
9550: PUSH
9551: LD_INT 7
9553: PUSH
9554: EMPTY
9555: LIST
9556: LIST
9557: PUSH
9558: LD_INT 91
9560: PUSH
9561: LD_EXP 45
9565: PUSH
9566: LD_INT 8
9568: PUSH
9569: EMPTY
9570: LIST
9571: LIST
9572: LIST
9573: PUSH
9574: EMPTY
9575: LIST
9576: LIST
9577: PPUSH
9578: CALL_OW 69
9582: IFFALSE 9541
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9584: LD_ADDR_VAR 0 1
9588: PUSH
9589: LD_INT 22
9591: PUSH
9592: LD_INT 4
9594: PUSH
9595: EMPTY
9596: LIST
9597: LIST
9598: PPUSH
9599: CALL_OW 69
9603: PUSH
9604: FOR_IN
9605: IFFALSE 9621
// SetSide ( i , 7 ) ;
9607: LD_VAR 0 1
9611: PPUSH
9612: LD_INT 7
9614: PPUSH
9615: CALL_OW 235
9619: GO 9604
9621: POP
9622: POP
// ChangeMissionObjectives ( M3 ) ;
9623: LD_STRING M3
9625: PPUSH
9626: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9630: LD_INT 35
9632: PPUSH
9633: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9637: LD_EXP 14
9641: PPUSH
9642: LD_EXP 45
9646: PPUSH
9647: CALL_OW 296
9651: PUSH
9652: LD_INT 8
9654: LESS
9655: IFFALSE 9630
// ComTurnUnit ( JMM , Burlak ) ;
9657: LD_EXP 14
9661: PPUSH
9662: LD_EXP 45
9666: PPUSH
9667: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9671: LD_EXP 45
9675: PPUSH
9676: LD_EXP 14
9680: PPUSH
9681: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9685: LD_INT 10
9687: PPUSH
9688: CALL_OW 67
// DialogueOn ;
9692: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9696: LD_EXP 14
9700: PPUSH
9701: LD_STRING D11-JMM-1
9703: PPUSH
9704: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9708: LD_EXP 45
9712: PPUSH
9713: LD_STRING D11-Bur-1
9715: PPUSH
9716: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9720: LD_EXP 14
9724: PPUSH
9725: LD_STRING D11-JMM-2
9727: PPUSH
9728: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9732: LD_EXP 45
9736: PPUSH
9737: LD_STRING D11-Bur-2
9739: PPUSH
9740: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9744: LD_EXP 14
9748: PPUSH
9749: LD_STRING D11-JMM-3
9751: PPUSH
9752: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9756: LD_EXP 45
9760: PPUSH
9761: LD_STRING D11-Bur-3
9763: PPUSH
9764: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9768: LD_EXP 14
9772: PPUSH
9773: LD_STRING D11-JMM-4
9775: PPUSH
9776: CALL_OW 88
// if ar_base_spotted then
9780: LD_EXP 8
9784: IFFALSE 9800
// Say ( Burlak , D12-Bur-1 ) else
9786: LD_EXP 45
9790: PPUSH
9791: LD_STRING D12-Bur-1
9793: PPUSH
9794: CALL_OW 88
9798: GO 9839
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9800: LD_INT 7
9802: PPUSH
9803: LD_INT 3
9805: PPUSH
9806: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9810: LD_INT 127
9812: PPUSH
9813: LD_INT 45
9815: PPUSH
9816: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9820: LD_EXP 45
9824: PPUSH
9825: LD_STRING D12-Bur-1a
9827: PPUSH
9828: CALL_OW 88
// dwait ( 0 0$2 ) ;
9832: LD_INT 70
9834: PPUSH
9835: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9839: LD_EXP 45
9843: PPUSH
9844: LD_STRING D12-Bur-1b
9846: PPUSH
9847: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9851: LD_EXP 14
9855: PPUSH
9856: LD_STRING D12-JMM-1
9858: PPUSH
9859: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9863: LD_EXP 45
9867: PPUSH
9868: LD_STRING D12-Bur-2
9870: PPUSH
9871: CALL_OW 88
// if Roth then
9875: LD_EXP 15
9879: IFFALSE 9895
// Say ( Roth , D12-Roth-2 ) else
9881: LD_EXP 15
9885: PPUSH
9886: LD_STRING D12-Roth-2
9888: PPUSH
9889: CALL_OW 88
9893: GO 9907
// Say ( SciRu , D12-RSci1-2 ) ;
9895: CALL 12437 0 0
9899: PPUSH
9900: LD_STRING D12-RSci1-2
9902: PPUSH
9903: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9907: LD_EXP 14
9911: PPUSH
9912: LD_STRING D12-JMM-2
9914: PPUSH
9915: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9919: LD_EXP 45
9923: PPUSH
9924: LD_STRING D12-Bur-3
9926: PPUSH
9927: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9931: LD_EXP 14
9935: PPUSH
9936: LD_STRING D12-JMM-3
9938: PPUSH
9939: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
9943: LD_EXP 45
9947: PPUSH
9948: LD_STRING D12-Bur-4
9950: PPUSH
9951: CALL_OW 88
// case Query ( QBase ) of 1 :
9955: LD_STRING QBase
9957: PPUSH
9958: CALL_OW 97
9962: PUSH
9963: LD_INT 1
9965: DOUBLE
9966: EQUAL
9967: IFTRUE 9971
9969: GO 10089
9971: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
9972: LD_EXP 14
9976: PPUSH
9977: LD_STRING D13a-JMM-1
9979: PPUSH
9980: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
9984: LD_EXP 45
9988: PPUSH
9989: LD_STRING D13a-Bur-1
9991: PPUSH
9992: CALL_OW 88
// if Roth then
9996: LD_EXP 15
10000: IFFALSE 10016
// Say ( Roth , D13a-Roth-1 ) else
10002: LD_EXP 15
10006: PPUSH
10007: LD_STRING D13a-Roth-1
10009: PPUSH
10010: CALL_OW 88
10014: GO 10028
// Say ( SciRu , D13a-RSci1-1 ) ;
10016: CALL 12437 0 0
10020: PPUSH
10021: LD_STRING D13a-RSci1-1
10023: PPUSH
10024: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10028: LD_EXP 14
10032: PPUSH
10033: LD_STRING D13a-JMM-2
10035: PPUSH
10036: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10040: LD_STRING QBaseAgain
10042: PPUSH
10043: CALL_OW 97
10047: PUSH
10048: LD_INT 1
10050: DOUBLE
10051: EQUAL
10052: IFTRUE 10056
10054: GO 10067
10056: POP
// selected_option := 2 ; 2 :
10057: LD_ADDR_VAR 0 2
10061: PUSH
10062: LD_INT 2
10064: ST_TO_ADDR
10065: GO 10087
10067: LD_INT 2
10069: DOUBLE
10070: EQUAL
10071: IFTRUE 10075
10073: GO 10086
10075: POP
// selected_option := 3 ; end ;
10076: LD_ADDR_VAR 0 2
10080: PUSH
10081: LD_INT 3
10083: ST_TO_ADDR
10084: GO 10087
10086: POP
// end ; 2 :
10087: GO 10128
10089: LD_INT 2
10091: DOUBLE
10092: EQUAL
10093: IFTRUE 10097
10095: GO 10108
10097: POP
// selected_option := 2 ; 3 :
10098: LD_ADDR_VAR 0 2
10102: PUSH
10103: LD_INT 2
10105: ST_TO_ADDR
10106: GO 10128
10108: LD_INT 3
10110: DOUBLE
10111: EQUAL
10112: IFTRUE 10116
10114: GO 10127
10116: POP
// selected_option := 3 ; end ;
10117: LD_ADDR_VAR 0 2
10121: PUSH
10122: LD_INT 3
10124: ST_TO_ADDR
10125: GO 10128
10127: POP
// if selected_option = 2 then
10128: LD_VAR 0 2
10132: PUSH
10133: LD_INT 2
10135: EQUAL
10136: IFFALSE 10230
// begin Say ( JMM , D13b-JMM-1 ) ;
10138: LD_EXP 14
10142: PPUSH
10143: LD_STRING D13b-JMM-1
10145: PPUSH
10146: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10150: LD_EXP 45
10154: PPUSH
10155: LD_STRING D13b-Bur-1
10157: PPUSH
10158: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10162: LD_EXP 14
10166: PPUSH
10167: LD_STRING D13b-JMM-2
10169: PPUSH
10170: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10174: LD_EXP 54
10178: PPUSH
10179: LD_STRING D13b-Abd-2
10181: PPUSH
10182: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10186: LD_EXP 14
10190: PPUSH
10191: LD_STRING D13b-JMM-3
10193: PPUSH
10194: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10198: LD_EXP 54
10202: PPUSH
10203: LD_STRING D13b-Abd-3
10205: PPUSH
10206: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10210: LD_EXP 14
10214: PPUSH
10215: LD_STRING D13b-JMM-4
10217: PPUSH
10218: CALL_OW 88
// ar_active_attack := true ;
10222: LD_ADDR_EXP 9
10226: PUSH
10227: LD_INT 1
10229: ST_TO_ADDR
// end ; if selected_option = 3 then
10230: LD_VAR 0 2
10234: PUSH
10235: LD_INT 3
10237: EQUAL
10238: IFFALSE 10264
// begin Say ( JMM , D13c-JMM-1 ) ;
10240: LD_EXP 14
10244: PPUSH
10245: LD_STRING D13c-JMM-1
10247: PPUSH
10248: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10252: LD_EXP 45
10256: PPUSH
10257: LD_STRING D13c-Bur-1
10259: PPUSH
10260: CALL_OW 88
// end ; DialogueOff ;
10264: CALL_OW 7
// if not ar_active_attack then
10268: LD_EXP 9
10272: NOT
10273: IFFALSE 10290
// begin wait ( 6 6$00 ) ;
10275: LD_INT 12600
10277: PPUSH
10278: CALL_OW 67
// ar_active_attack := true ;
10282: LD_ADDR_EXP 9
10286: PUSH
10287: LD_INT 1
10289: ST_TO_ADDR
// end ; end ;
10290: PPOPN 2
10292: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10293: LD_EXP 45
10297: PPUSH
10298: CALL_OW 305
10302: PUSH
10303: LD_EXP 45
10307: PPUSH
10308: CALL_OW 255
10312: PUSH
10313: LD_INT 7
10315: EQUAL
10316: AND
10317: IFFALSE 10513
10319: GO 10321
10321: DISABLE
10322: LD_INT 0
10324: PPUSH
// begin wait ( 4 4$40 ) ;
10325: LD_INT 9800
10327: PPUSH
10328: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10332: LD_INT 35
10334: PPUSH
10335: CALL_OW 67
// until not ru_attackers ;
10339: LD_EXP 51
10343: NOT
10344: IFFALSE 10332
// PrepareGnyevko ;
10346: CALL 2056 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10350: LD_EXP 47
10354: PPUSH
10355: LD_INT 124
10357: PPUSH
10358: LD_INT 118
10360: PPUSH
10361: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10365: LD_EXP 47
10369: PPUSH
10370: CALL_OW 200
// time := 0 0$00 ;
10374: LD_ADDR_VAR 0 1
10378: PUSH
10379: LD_INT 0
10381: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10382: LD_INT 35
10384: PPUSH
10385: CALL_OW 67
// time := time + 0 0$1 ;
10389: LD_ADDR_VAR 0 1
10393: PUSH
10394: LD_VAR 0 1
10398: PUSH
10399: LD_INT 35
10401: PLUS
10402: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10403: LD_EXP 47
10407: PPUSH
10408: LD_INT 124
10410: PPUSH
10411: LD_INT 118
10413: PPUSH
10414: CALL_OW 307
10418: PUSH
10419: LD_VAR 0 1
10423: PUSH
10424: LD_INT 1050
10426: GREATEREQUAL
10427: OR
10428: IFFALSE 10382
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10430: LD_EXP 47
10434: PPUSH
10435: LD_STRING DBelkov-Gny-1
10437: PPUSH
10438: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10442: LD_EXP 45
10446: PPUSH
10447: LD_STRING DBelkov-Bur-1a
10449: PPUSH
10450: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10454: LD_INT 35
10456: PPUSH
10457: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10461: LD_EXP 47
10465: PPUSH
10466: LD_INT 22
10468: PUSH
10469: LD_INT 7
10471: PUSH
10472: EMPTY
10473: LIST
10474: LIST
10475: PPUSH
10476: CALL_OW 69
10480: PPUSH
10481: LD_EXP 47
10485: PPUSH
10486: CALL_OW 74
10490: PPUSH
10491: CALL_OW 296
10495: PUSH
10496: LD_INT 8
10498: LESS
10499: IFFALSE 10454
// SetSide ( Gnyevko , 7 ) ;
10501: LD_EXP 47
10505: PPUSH
10506: LD_INT 7
10508: PPUSH
10509: CALL_OW 235
// end ;
10513: PPOPN 1
10515: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10516: LD_EXP 45
10520: PPUSH
10521: CALL_OW 255
10525: PUSH
10526: LD_INT 7
10528: EQUAL
10529: IFFALSE 10539
10531: GO 10533
10533: DISABLE
// begin enable ;
10534: ENABLE
// PrepareAmericanAttack ;
10535: CALL 6362 0 0
// end ;
10539: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10540: LD_INT 22
10542: PUSH
10543: LD_INT 1
10545: PUSH
10546: EMPTY
10547: LIST
10548: LIST
10549: PPUSH
10550: CALL_OW 69
10554: IFFALSE 10738
10556: GO 10558
10558: DISABLE
10559: LD_INT 0
10561: PPUSH
10562: PPUSH
// begin while true do
10563: LD_INT 1
10565: IFFALSE 10622
// begin wait ( 0 0$1 ) ;
10567: LD_INT 35
10569: PPUSH
10570: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10574: LD_ADDR_VAR 0 2
10578: PUSH
10579: LD_INT 22
10581: PUSH
10582: LD_INT 1
10584: PUSH
10585: EMPTY
10586: LIST
10587: LIST
10588: PPUSH
10589: CALL_OW 69
10593: PPUSH
10594: LD_EXP 14
10598: PPUSH
10599: CALL_OW 74
10603: ST_TO_ADDR
// if See ( 7 , tmp ) then
10604: LD_INT 7
10606: PPUSH
10607: LD_VAR 0 2
10611: PPUSH
10612: CALL_OW 292
10616: IFFALSE 10620
// break ;
10618: GO 10622
// end ;
10620: GO 10563
// DialogueOn ;
10622: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10626: LD_VAR 0 2
10630: PPUSH
10631: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10635: LD_VAR 0 2
10639: PPUSH
10640: CALL_OW 250
10644: PPUSH
10645: LD_VAR 0 2
10649: PPUSH
10650: CALL_OW 251
10654: PPUSH
10655: LD_INT 7
10657: PPUSH
10658: LD_INT 8
10660: PPUSH
10661: CALL_OW 330
// if Denis then
10665: LD_EXP 20
10669: IFFALSE 10683
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10671: LD_EXP 20
10675: PPUSH
10676: LD_STRING DAmerAttack-Pet-1
10678: PPUSH
10679: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10683: LD_EXP 14
10687: PPUSH
10688: LD_STRING DAmerAttack-JMM-1
10690: PPUSH
10691: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10695: LD_EXP 45
10699: PPUSH
10700: LD_STRING DStop-Bur-1
10702: PPUSH
10703: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10707: LD_VAR 0 2
10711: PPUSH
10712: CALL_OW 250
10716: PPUSH
10717: LD_VAR 0 2
10721: PPUSH
10722: CALL_OW 251
10726: PPUSH
10727: LD_INT 7
10729: PPUSH
10730: CALL_OW 331
// DialogueOff ;
10734: CALL_OW 7
// end ;
10738: PPOPN 2
10740: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10741: LD_INT 22
10743: PUSH
10744: LD_INT 3
10746: PUSH
10747: EMPTY
10748: LIST
10749: LIST
10750: PUSH
10751: LD_INT 21
10753: PUSH
10754: LD_INT 1
10756: PUSH
10757: EMPTY
10758: LIST
10759: LIST
10760: PUSH
10761: EMPTY
10762: LIST
10763: LIST
10764: PPUSH
10765: CALL_OW 69
10769: PUSH
10770: LD_INT 0
10772: EQUAL
10773: IFFALSE 10815
10775: GO 10777
10777: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10778: LD_STRING M5a
10780: PPUSH
10781: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10785: LD_EXP 14
10789: PPUSH
10790: LD_STRING D8-JMM-1
10792: PPUSH
10793: CALL_OW 88
// if Gossudarov then
10797: LD_EXP 31
10801: IFFALSE 10815
// Say ( Gossudarov , D8-Gos-1 ) ;
10803: LD_EXP 31
10807: PPUSH
10808: LD_STRING D8-Gos-1
10810: PPUSH
10811: CALL_OW 88
// end ;
10815: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10816: LD_INT 22
10818: PUSH
10819: LD_INT 2
10821: PUSH
10822: EMPTY
10823: LIST
10824: LIST
10825: PUSH
10826: LD_INT 21
10828: PUSH
10829: LD_INT 1
10831: PUSH
10832: EMPTY
10833: LIST
10834: LIST
10835: PUSH
10836: EMPTY
10837: LIST
10838: LIST
10839: PPUSH
10840: CALL_OW 69
10844: PUSH
10845: LD_INT 0
10847: EQUAL
10848: IFFALSE 10898
10850: GO 10852
10852: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10853: LD_STRING M4c
10855: PPUSH
10856: CALL_OW 337
// if Roth then
10860: LD_EXP 15
10864: IFFALSE 10880
// Say ( Roth , DStop-Roth-1 ) else
10866: LD_EXP 15
10870: PPUSH
10871: LD_STRING DStop-Roth-1
10873: PPUSH
10874: CALL_OW 88
10878: GO 10898
// if Gossudarov then
10880: LD_EXP 31
10884: IFFALSE 10898
// Say ( Gossudarov , D8-Gos-1a ) ;
10886: LD_EXP 31
10890: PPUSH
10891: LD_STRING D8-Gos-1a
10893: PPUSH
10894: CALL_OW 88
// end ;
10898: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10899: LD_INT 7
10901: PPUSH
10902: LD_INT 1
10904: PPUSH
10905: LD_INT 1
10907: PPUSH
10908: CALL 14029 0 3
10912: PUSH
10913: LD_INT 0
10915: EQUAL
10916: PUSH
10917: LD_INT 7
10919: PPUSH
10920: LD_INT 3
10922: PPUSH
10923: LD_INT 1
10925: PPUSH
10926: CALL 14029 0 3
10930: PUSH
10931: LD_INT 0
10933: EQUAL
10934: AND
10935: IFFALSE 10947
10937: GO 10939
10939: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
10940: LD_STRING M1a
10942: PPUSH
10943: CALL_OW 337
// end ;
10947: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 ;
10948: LD_INT 22
10950: PUSH
10951: LD_INT 2
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PUSH
10958: LD_INT 21
10960: PUSH
10961: LD_INT 1
10963: PUSH
10964: EMPTY
10965: LIST
10966: LIST
10967: PUSH
10968: EMPTY
10969: LIST
10970: LIST
10971: PPUSH
10972: CALL_OW 69
10976: PUSH
10977: LD_INT 0
10979: EQUAL
10980: PUSH
10981: LD_INT 22
10983: PUSH
10984: LD_INT 3
10986: PUSH
10987: EMPTY
10988: LIST
10989: LIST
10990: PUSH
10991: LD_INT 21
10993: PUSH
10994: LD_INT 1
10996: PUSH
10997: EMPTY
10998: LIST
10999: LIST
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: PPUSH
11005: CALL_OW 69
11009: PUSH
11010: LD_INT 0
11012: EQUAL
11013: AND
11014: PUSH
11015: LD_INT 22
11017: PUSH
11018: LD_INT 1
11020: PUSH
11021: EMPTY
11022: LIST
11023: LIST
11024: PPUSH
11025: CALL_OW 69
11029: PUSH
11030: LD_INT 0
11032: EQUAL
11033: AND
11034: PUSH
11035: LD_INT 7
11037: PPUSH
11038: LD_INT 1
11040: PPUSH
11041: LD_INT 1
11043: PPUSH
11044: CALL 14029 0 3
11048: PUSH
11049: LD_INT 0
11051: EQUAL
11052: AND
11053: PUSH
11054: LD_INT 7
11056: PPUSH
11057: LD_INT 3
11059: PPUSH
11060: LD_INT 1
11062: PPUSH
11063: CALL 14029 0 3
11067: PUSH
11068: LD_INT 0
11070: EQUAL
11071: AND
11072: IFFALSE 12434
11074: GO 11076
11076: DISABLE
11077: LD_INT 0
11079: PPUSH
11080: PPUSH
11081: PPUSH
// begin wait ( 0 0$3 ) ;
11082: LD_INT 105
11084: PPUSH
11085: CALL_OW 67
// if not IsDead ( Masha ) then
11089: LD_EXP 48
11093: PPUSH
11094: CALL_OW 301
11098: NOT
11099: IFFALSE 11113
// AddMedal ( Masha , 1 ) else
11101: LD_STRING Masha
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: CALL_OW 101
11111: GO 11124
// AddMedal ( Masha , - 1 ) ;
11113: LD_STRING Masha
11115: PPUSH
11116: LD_INT 1
11118: NEG
11119: PPUSH
11120: CALL_OW 101
// if abdul_escaped then
11124: LD_EXP 12
11128: IFFALSE 11143
// AddMedal ( Abdul , - 1 ) else
11130: LD_STRING Abdul
11132: PPUSH
11133: LD_INT 1
11135: NEG
11136: PPUSH
11137: CALL_OW 101
11141: GO 11153
// AddMedal ( Abdul , 1 ) ;
11143: LD_STRING Abdul
11145: PPUSH
11146: LD_INT 1
11148: PPUSH
11149: CALL_OW 101
// if loss_counter = 0 then
11153: LD_EXP 13
11157: PUSH
11158: LD_INT 0
11160: EQUAL
11161: IFFALSE 11175
// AddMedal ( People , 2 ) else
11163: LD_STRING People
11165: PPUSH
11166: LD_INT 2
11168: PPUSH
11169: CALL_OW 101
11173: GO 11225
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11175: LD_EXP 13
11179: PUSH
11180: LD_INT 3
11182: PUSH
11183: LD_INT 2
11185: PUSH
11186: LD_INT 2
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: LIST
11193: PUSH
11194: LD_OWVAR 67
11198: ARRAY
11199: LESSEQUAL
11200: IFFALSE 11214
// AddMedal ( People , 1 ) else
11202: LD_STRING People
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL_OW 101
11212: GO 11225
// AddMedal ( People , - 1 ) ;
11214: LD_STRING People
11216: PPUSH
11217: LD_INT 1
11219: NEG
11220: PPUSH
11221: CALL_OW 101
// GiveMedals ( MAIN ) ;
11225: LD_STRING MAIN
11227: PPUSH
11228: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11232: LD_ADDR_VAR 0 2
11236: PUSH
11237: LD_INT 22
11239: PUSH
11240: LD_INT 7
11242: PUSH
11243: EMPTY
11244: LIST
11245: LIST
11246: PUSH
11247: LD_INT 2
11249: PUSH
11250: LD_INT 25
11252: PUSH
11253: LD_INT 1
11255: PUSH
11256: EMPTY
11257: LIST
11258: LIST
11259: PUSH
11260: LD_INT 25
11262: PUSH
11263: LD_INT 2
11265: PUSH
11266: EMPTY
11267: LIST
11268: LIST
11269: PUSH
11270: LD_INT 25
11272: PUSH
11273: LD_INT 3
11275: PUSH
11276: EMPTY
11277: LIST
11278: LIST
11279: PUSH
11280: LD_INT 25
11282: PUSH
11283: LD_INT 4
11285: PUSH
11286: EMPTY
11287: LIST
11288: LIST
11289: PUSH
11290: LD_INT 25
11292: PUSH
11293: LD_INT 5
11295: PUSH
11296: EMPTY
11297: LIST
11298: LIST
11299: PUSH
11300: LD_INT 25
11302: PUSH
11303: LD_INT 8
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: PUSH
11310: LD_INT 25
11312: PUSH
11313: LD_INT 9
11315: PUSH
11316: EMPTY
11317: LIST
11318: LIST
11319: PUSH
11320: EMPTY
11321: LIST
11322: LIST
11323: LIST
11324: LIST
11325: LIST
11326: LIST
11327: LIST
11328: LIST
11329: PUSH
11330: EMPTY
11331: LIST
11332: LIST
11333: PPUSH
11334: CALL_OW 69
11338: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11339: LD_VAR 0 2
11343: PPUSH
11344: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11348: LD_ADDR_VAR 0 3
11352: PUSH
11353: LD_EXP 14
11357: PUSH
11358: LD_EXP 15
11362: PUSH
11363: LD_EXP 16
11367: PUSH
11368: LD_EXP 17
11372: PUSH
11373: LD_EXP 18
11377: PUSH
11378: LD_EXP 19
11382: PUSH
11383: LD_EXP 20
11387: PUSH
11388: LD_EXP 21
11392: PUSH
11393: LD_EXP 22
11397: PUSH
11398: LD_EXP 23
11402: PUSH
11403: LD_EXP 24
11407: PUSH
11408: LD_EXP 25
11412: PUSH
11413: LD_EXP 26
11417: PUSH
11418: LD_EXP 27
11422: PUSH
11423: LD_EXP 28
11427: PUSH
11428: LD_EXP 29
11432: PUSH
11433: LD_EXP 30
11437: PUSH
11438: LD_EXP 31
11442: PUSH
11443: LD_EXP 32
11447: PUSH
11448: LD_EXP 33
11452: PUSH
11453: LD_EXP 35
11457: PUSH
11458: LD_EXP 36
11462: PUSH
11463: LD_EXP 37
11467: PUSH
11468: LD_EXP 38
11472: PUSH
11473: LD_EXP 39
11477: PUSH
11478: LD_EXP 40
11482: PUSH
11483: LD_EXP 41
11487: PUSH
11488: LD_EXP 42
11492: PUSH
11493: LD_EXP 43
11497: PUSH
11498: LD_EXP 44
11502: PUSH
11503: LD_EXP 45
11507: PUSH
11508: LD_EXP 46
11512: PUSH
11513: LD_EXP 47
11517: PUSH
11518: EMPTY
11519: LIST
11520: LIST
11521: LIST
11522: LIST
11523: LIST
11524: LIST
11525: LIST
11526: LIST
11527: LIST
11528: LIST
11529: LIST
11530: LIST
11531: LIST
11532: LIST
11533: LIST
11534: LIST
11535: LIST
11536: LIST
11537: LIST
11538: LIST
11539: LIST
11540: LIST
11541: LIST
11542: LIST
11543: LIST
11544: LIST
11545: LIST
11546: LIST
11547: LIST
11548: LIST
11549: LIST
11550: LIST
11551: LIST
11552: ST_TO_ADDR
// if tmp diff tmp2 then
11553: LD_VAR 0 2
11557: PUSH
11558: LD_VAR 0 3
11562: DIFF
11563: IFFALSE 11583
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11565: LD_VAR 0 2
11569: PUSH
11570: LD_VAR 0 3
11574: DIFF
11575: PPUSH
11576: LD_STRING 13a_others
11578: PPUSH
11579: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11583: LD_EXP 14
11587: PPUSH
11588: LD_STRING 13a_JMM
11590: PPUSH
11591: CALL_OW 38
// if Titov then
11595: LD_EXP 33
11599: IFFALSE 11613
// SaveCharacters ( Titov , 13a_Titov ) ;
11601: LD_EXP 33
11605: PPUSH
11606: LD_STRING 13a_Titov
11608: PPUSH
11609: CALL_OW 38
// if Dolgov then
11613: LD_EXP 35
11617: IFFALSE 11631
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11619: LD_EXP 35
11623: PPUSH
11624: LD_STRING 13a_Dolgov
11626: PPUSH
11627: CALL_OW 38
// if Petrosyan then
11631: LD_EXP 36
11635: IFFALSE 11649
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11637: LD_EXP 36
11641: PPUSH
11642: LD_STRING 13a_Petrosyan
11644: PPUSH
11645: CALL_OW 38
// if Scholtze then
11649: LD_EXP 37
11653: IFFALSE 11667
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11655: LD_EXP 37
11659: PPUSH
11660: LD_STRING 13a_Scholtze
11662: PPUSH
11663: CALL_OW 38
// if Oblukov then
11667: LD_EXP 38
11671: IFFALSE 11685
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11673: LD_EXP 38
11677: PPUSH
11678: LD_STRING 13a_Oblukov
11680: PPUSH
11681: CALL_OW 38
// if Kapitsova then
11685: LD_EXP 39
11689: IFFALSE 11703
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11691: LD_EXP 39
11695: PPUSH
11696: LD_STRING 13a_Kapitsova
11698: PPUSH
11699: CALL_OW 38
// if Lipshchin then
11703: LD_EXP 40
11707: IFFALSE 11721
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11709: LD_EXP 40
11713: PPUSH
11714: LD_STRING 13a_Lipshchin
11716: PPUSH
11717: CALL_OW 38
// if Petrovova then
11721: LD_EXP 41
11725: IFFALSE 11739
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11727: LD_EXP 41
11731: PPUSH
11732: LD_STRING 13a_Petrovova
11734: PPUSH
11735: CALL_OW 38
// if Kovalyuk then
11739: LD_EXP 42
11743: IFFALSE 11757
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11745: LD_EXP 42
11749: PPUSH
11750: LD_STRING 13a_Kovalyuk
11752: PPUSH
11753: CALL_OW 38
// if Kuzmov then
11757: LD_EXP 43
11761: IFFALSE 11775
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11763: LD_EXP 43
11767: PPUSH
11768: LD_STRING 13a_Kuzmov
11770: PPUSH
11771: CALL_OW 38
// if Karamazov then
11775: LD_EXP 44
11779: IFFALSE 11793
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11781: LD_EXP 44
11785: PPUSH
11786: LD_STRING 13a_Karamazov
11788: PPUSH
11789: CALL_OW 38
// if Burlak then
11793: LD_EXP 45
11797: IFFALSE 11811
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11799: LD_EXP 45
11803: PPUSH
11804: LD_STRING 13a_Burlak
11806: PPUSH
11807: CALL_OW 38
// if Belkov then
11811: LD_EXP 46
11815: IFFALSE 11829
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11817: LD_EXP 46
11821: PPUSH
11822: LD_STRING 13a_Belkov
11824: PPUSH
11825: CALL_OW 38
// if Gnyevko then
11829: LD_EXP 47
11833: IFFALSE 11847
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11835: LD_EXP 47
11839: PPUSH
11840: LD_STRING 13a_Gnyevko
11842: PPUSH
11843: CALL_OW 38
// if Lisa then
11847: LD_EXP 16
11851: IFFALSE 11865
// SaveCharacters ( Lisa , 13a_Lisa ) ;
11853: LD_EXP 16
11857: PPUSH
11858: LD_STRING 13a_Lisa
11860: PPUSH
11861: CALL_OW 38
// if Donaldson then
11865: LD_EXP 17
11869: IFFALSE 11883
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
11871: LD_EXP 17
11875: PPUSH
11876: LD_STRING 13a_Donaldson
11878: PPUSH
11879: CALL_OW 38
// if Bobby then
11883: LD_EXP 18
11887: IFFALSE 11901
// SaveCharacters ( Bobby , 13a_Bobby ) ;
11889: LD_EXP 18
11893: PPUSH
11894: LD_STRING 13a_Bobby
11896: PPUSH
11897: CALL_OW 38
// if Cyrus then
11901: LD_EXP 19
11905: IFFALSE 11919
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
11907: LD_EXP 19
11911: PPUSH
11912: LD_STRING 13a_Cyrus
11914: PPUSH
11915: CALL_OW 38
// if Denis then
11919: LD_EXP 20
11923: IFFALSE 11937
// SaveCharacters ( Denis , 13a_Denis ) ;
11925: LD_EXP 20
11929: PPUSH
11930: LD_STRING 13a_Denis
11932: PPUSH
11933: CALL_OW 38
// if Brown then
11937: LD_EXP 21
11941: IFFALSE 11955
// SaveCharacters ( Brown , 13a_Brown ) ;
11943: LD_EXP 21
11947: PPUSH
11948: LD_STRING 13a_Brown
11950: PPUSH
11951: CALL_OW 38
// if Gladstone then
11955: LD_EXP 22
11959: IFFALSE 11973
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
11961: LD_EXP 22
11965: PPUSH
11966: LD_STRING 13a_Gladstone
11968: PPUSH
11969: CALL_OW 38
// if Houten then
11973: LD_EXP 23
11977: IFFALSE 11991
// SaveCharacters ( Houten , 13a_Houten ) ;
11979: LD_EXP 23
11983: PPUSH
11984: LD_STRING 13a_Houten
11986: PPUSH
11987: CALL_OW 38
// if Cornel then
11991: LD_EXP 24
11995: IFFALSE 12009
// SaveCharacters ( Cornel , 13a_Cornel ) ;
11997: LD_EXP 24
12001: PPUSH
12002: LD_STRING 13a_Cornel
12004: PPUSH
12005: CALL_OW 38
// if Gary then
12009: LD_EXP 25
12013: IFFALSE 12027
// SaveCharacters ( Gary , 13a_Gary ) ;
12015: LD_EXP 25
12019: PPUSH
12020: LD_STRING 13a_Gary
12022: PPUSH
12023: CALL_OW 38
// if Frank then
12027: LD_EXP 26
12031: IFFALSE 12045
// SaveCharacters ( Frank , 13a_Frank ) ;
12033: LD_EXP 26
12037: PPUSH
12038: LD_STRING 13a_Frank
12040: PPUSH
12041: CALL_OW 38
// if Kikuchi then
12045: LD_EXP 27
12049: IFFALSE 12063
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12051: LD_EXP 27
12055: PPUSH
12056: LD_STRING 13a_Kikuchi
12058: PPUSH
12059: CALL_OW 38
// if Simms then
12063: LD_EXP 28
12067: IFFALSE 12081
// SaveCharacters ( Simms , 13a_Simms ) ;
12069: LD_EXP 28
12073: PPUSH
12074: LD_STRING 13a_Simms
12076: PPUSH
12077: CALL_OW 38
// if Joan then
12081: LD_EXP 29
12085: IFFALSE 12099
// SaveCharacters ( Joan , 13a_Joan ) ;
12087: LD_EXP 29
12091: PPUSH
12092: LD_STRING 13a_Joan
12094: PPUSH
12095: CALL_OW 38
// if DeltaDoctor then
12099: LD_EXP 30
12103: IFFALSE 12117
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12105: LD_EXP 30
12109: PPUSH
12110: LD_STRING 13a_DeltaDoctor
12112: PPUSH
12113: CALL_OW 38
// if Gossudarov then
12117: LD_EXP 31
12121: IFFALSE 12135
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12123: LD_EXP 31
12127: PPUSH
12128: LD_STRING 13a_Gossudarov
12130: PPUSH
12131: CALL_OW 38
// if Kirilenkova then
12135: LD_EXP 32
12139: IFFALSE 12153
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12141: LD_EXP 32
12145: PPUSH
12146: LD_STRING 13a_Kirilenkova
12148: PPUSH
12149: CALL_OW 38
// if Roth then
12153: LD_EXP 15
12157: IFFALSE 12171
// SaveCharacters ( Roth , 13a_Roth ) ;
12159: LD_EXP 15
12163: PPUSH
12164: LD_STRING 13a_Roth
12166: PPUSH
12167: CALL_OW 38
// if Masha then
12171: LD_EXP 48
12175: IFFALSE 12230
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12177: LD_EXP 48
12181: PPUSH
12182: CALL_OW 265
12186: PUSH
12187: LD_EXP 48
12191: PPUSH
12192: CALL_OW 262
12196: PUSH
12197: LD_EXP 48
12201: PPUSH
12202: CALL_OW 263
12206: PUSH
12207: LD_EXP 48
12211: PPUSH
12212: CALL_OW 264
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: LIST
12221: LIST
12222: PPUSH
12223: LD_STRING 13a_Masha
12225: PPUSH
12226: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12230: LD_ADDR_VAR 0 2
12234: PUSH
12235: LD_INT 21
12237: PUSH
12238: LD_INT 3
12240: PUSH
12241: EMPTY
12242: LIST
12243: LIST
12244: PPUSH
12245: CALL_OW 69
12249: ST_TO_ADDR
// tmp2 := [ ] ;
12250: LD_ADDR_VAR 0 3
12254: PUSH
12255: EMPTY
12256: ST_TO_ADDR
// if tmp then
12257: LD_VAR 0 2
12261: IFFALSE 12412
// for i in tmp do
12263: LD_ADDR_VAR 0 1
12267: PUSH
12268: LD_VAR 0 2
12272: PUSH
12273: FOR_IN
12274: IFFALSE 12410
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12276: LD_ADDR_VAR 0 3
12280: PUSH
12281: LD_VAR 0 3
12285: PUSH
12286: LD_VAR 0 1
12290: PPUSH
12291: CALL_OW 255
12295: PUSH
12296: LD_VAR 0 1
12300: PPUSH
12301: CALL_OW 248
12305: PUSH
12306: LD_VAR 0 1
12310: PPUSH
12311: CALL_OW 266
12315: PUSH
12316: LD_VAR 0 1
12320: PPUSH
12321: CALL_OW 250
12325: PUSH
12326: LD_VAR 0 1
12330: PPUSH
12331: CALL_OW 251
12335: PUSH
12336: LD_VAR 0 1
12340: PPUSH
12341: CALL_OW 254
12345: PUSH
12346: LD_VAR 0 1
12350: PPUSH
12351: CALL_OW 267
12355: PUSH
12356: LD_VAR 0 1
12360: PPUSH
12361: LD_INT 1
12363: PPUSH
12364: CALL_OW 268
12368: PUSH
12369: LD_VAR 0 1
12373: PPUSH
12374: LD_INT 2
12376: PPUSH
12377: CALL_OW 268
12381: PUSH
12382: LD_VAR 0 1
12386: PPUSH
12387: CALL_OW 269
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: LIST
12398: LIST
12399: LIST
12400: LIST
12401: LIST
12402: LIST
12403: PUSH
12404: EMPTY
12405: LIST
12406: ADD
12407: ST_TO_ADDR
12408: GO 12273
12410: POP
12411: POP
// if tmp2 then
12412: LD_VAR 0 3
12416: IFFALSE 12430
// SaveVariable ( tmp2 , 13a_buildings ) ;
12418: LD_VAR 0 3
12422: PPUSH
12423: LD_STRING 13a_buildings
12425: PPUSH
12426: CALL_OW 39
// YouWin ;
12430: CALL_OW 103
// end ;
12434: PPOPN 3
12436: END
// export function SciRu ; var tmp , t ; begin
12437: LD_INT 0
12439: PPUSH
12440: PPUSH
12441: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12442: LD_ADDR_VAR 0 3
12446: PUSH
12447: LD_EXP 31
12451: PUSH
12452: LD_EXP 45
12456: PUSH
12457: LD_EXP 33
12461: PUSH
12462: LD_EXP 46
12466: PUSH
12467: LD_EXP 47
12471: PUSH
12472: LD_EXP 36
12476: PUSH
12477: LD_EXP 37
12481: PUSH
12482: LD_EXP 35
12486: PUSH
12487: EMPTY
12488: LIST
12489: LIST
12490: LIST
12491: LIST
12492: LIST
12493: LIST
12494: LIST
12495: LIST
12496: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12497: LD_ADDR_VAR 0 2
12501: PUSH
12502: LD_INT 22
12504: PUSH
12505: LD_INT 7
12507: PUSH
12508: EMPTY
12509: LIST
12510: LIST
12511: PUSH
12512: LD_INT 23
12514: PUSH
12515: LD_INT 3
12517: PUSH
12518: EMPTY
12519: LIST
12520: LIST
12521: PUSH
12522: LD_INT 25
12524: PUSH
12525: LD_INT 4
12527: PUSH
12528: EMPTY
12529: LIST
12530: LIST
12531: PUSH
12532: LD_INT 26
12534: PUSH
12535: LD_INT 1
12537: PUSH
12538: EMPTY
12539: LIST
12540: LIST
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: LIST
12546: LIST
12547: PPUSH
12548: CALL_OW 69
12552: PUSH
12553: LD_VAR 0 3
12557: DIFF
12558: ST_TO_ADDR
// if tmp then
12559: LD_VAR 0 2
12563: IFFALSE 12579
// result := tmp [ 1 ] ;
12565: LD_ADDR_VAR 0 1
12569: PUSH
12570: LD_VAR 0 2
12574: PUSH
12575: LD_INT 1
12577: ARRAY
12578: ST_TO_ADDR
// end ;
12579: LD_VAR 0 1
12583: RET
// export function SolRu ; var tmp , t ; begin
12584: LD_INT 0
12586: PPUSH
12587: PPUSH
12588: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12589: LD_ADDR_VAR 0 3
12593: PUSH
12594: LD_EXP 31
12598: PUSH
12599: LD_EXP 45
12603: PUSH
12604: LD_EXP 33
12608: PUSH
12609: LD_EXP 46
12613: PUSH
12614: LD_EXP 47
12618: PUSH
12619: LD_EXP 36
12623: PUSH
12624: LD_EXP 37
12628: PUSH
12629: LD_EXP 35
12633: PUSH
12634: EMPTY
12635: LIST
12636: LIST
12637: LIST
12638: LIST
12639: LIST
12640: LIST
12641: LIST
12642: LIST
12643: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12644: LD_ADDR_VAR 0 2
12648: PUSH
12649: LD_INT 22
12651: PUSH
12652: LD_INT 7
12654: PUSH
12655: EMPTY
12656: LIST
12657: LIST
12658: PUSH
12659: LD_INT 23
12661: PUSH
12662: LD_INT 3
12664: PUSH
12665: EMPTY
12666: LIST
12667: LIST
12668: PUSH
12669: LD_INT 25
12671: PUSH
12672: LD_INT 1
12674: PUSH
12675: EMPTY
12676: LIST
12677: LIST
12678: PUSH
12679: LD_INT 26
12681: PUSH
12682: LD_INT 1
12684: PUSH
12685: EMPTY
12686: LIST
12687: LIST
12688: PUSH
12689: EMPTY
12690: LIST
12691: LIST
12692: LIST
12693: LIST
12694: PPUSH
12695: CALL_OW 69
12699: PUSH
12700: LD_VAR 0 3
12704: DIFF
12705: ST_TO_ADDR
// if tmp then
12706: LD_VAR 0 2
12710: IFFALSE 12726
// result := tmp [ 1 ] ;
12712: LD_ADDR_VAR 0 1
12716: PUSH
12717: LD_VAR 0 2
12721: PUSH
12722: LD_INT 1
12724: ARRAY
12725: ST_TO_ADDR
// end ; end_of_file
12726: LD_VAR 0 1
12730: RET
// export function CustomEvent ( event ) ; begin
12731: LD_INT 0
12733: PPUSH
// end ;
12734: LD_VAR 0 2
12738: RET
// on UnitDestroyed ( un ) do var i , side ;
12739: LD_INT 0
12741: PPUSH
12742: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12743: LD_VAR 0 1
12747: PUSH
12748: LD_INT 22
12750: PUSH
12751: LD_INT 7
12753: PUSH
12754: EMPTY
12755: LIST
12756: LIST
12757: PUSH
12758: LD_INT 2
12760: PUSH
12761: LD_INT 25
12763: PUSH
12764: LD_INT 1
12766: PUSH
12767: EMPTY
12768: LIST
12769: LIST
12770: PUSH
12771: LD_INT 25
12773: PUSH
12774: LD_INT 2
12776: PUSH
12777: EMPTY
12778: LIST
12779: LIST
12780: PUSH
12781: LD_INT 25
12783: PUSH
12784: LD_INT 3
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 25
12793: PUSH
12794: LD_INT 4
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: PUSH
12801: LD_INT 25
12803: PUSH
12804: LD_INT 5
12806: PUSH
12807: EMPTY
12808: LIST
12809: LIST
12810: PUSH
12811: LD_INT 25
12813: PUSH
12814: LD_INT 8
12816: PUSH
12817: EMPTY
12818: LIST
12819: LIST
12820: PUSH
12821: LD_INT 25
12823: PUSH
12824: LD_INT 9
12826: PUSH
12827: EMPTY
12828: LIST
12829: LIST
12830: PUSH
12831: EMPTY
12832: LIST
12833: LIST
12834: LIST
12835: LIST
12836: LIST
12837: LIST
12838: LIST
12839: LIST
12840: PUSH
12841: EMPTY
12842: LIST
12843: LIST
12844: PPUSH
12845: CALL_OW 69
12849: IN
12850: IFFALSE 12866
// loss_counter := loss_counter + 1 ;
12852: LD_ADDR_EXP 13
12856: PUSH
12857: LD_EXP 13
12861: PUSH
12862: LD_INT 1
12864: PLUS
12865: ST_TO_ADDR
// if un = Abdul then
12866: LD_VAR 0 1
12870: PUSH
12871: LD_EXP 54
12875: EQUAL
12876: IFFALSE 12886
// abdul_escaped := false ;
12878: LD_ADDR_EXP 12
12882: PUSH
12883: LD_INT 0
12885: ST_TO_ADDR
// if un in ru_attackers then
12886: LD_VAR 0 1
12890: PUSH
12891: LD_EXP 51
12895: IN
12896: IFFALSE 12914
// ru_attackers := ru_attackers diff un ;
12898: LD_ADDR_EXP 51
12902: PUSH
12903: LD_EXP 51
12907: PUSH
12908: LD_VAR 0 1
12912: DIFF
12913: ST_TO_ADDR
// if un in ar_attackers then
12914: LD_VAR 0 1
12918: PUSH
12919: LD_EXP 10
12923: IN
12924: IFFALSE 12942
// ar_attackers := ar_attackers diff un ;
12926: LD_ADDR_EXP 10
12930: PUSH
12931: LD_EXP 10
12935: PUSH
12936: LD_VAR 0 1
12940: DIFF
12941: ST_TO_ADDR
// if un = JMM then
12942: LD_VAR 0 1
12946: PUSH
12947: LD_EXP 14
12951: EQUAL
12952: IFFALSE 12963
// begin YouLost ( JMM ) ;
12954: LD_STRING JMM
12956: PPUSH
12957: CALL_OW 104
// exit ;
12961: GO 13052
// end ; if un = Burlak then
12963: LD_VAR 0 1
12967: PUSH
12968: LD_EXP 45
12972: EQUAL
12973: IFFALSE 12984
// begin YouLost ( Burlak ) ;
12975: LD_STRING Burlak
12977: PPUSH
12978: CALL_OW 104
// exit ;
12982: GO 13052
// end ; if un = freedom then
12984: LD_VAR 0 1
12988: PUSH
12989: LD_EXP 3
12993: EQUAL
12994: IFFALSE 13005
// begin YouLost ( Destroyed ) ;
12996: LD_STRING Destroyed
12998: PPUSH
12999: CALL_OW 104
// exit ;
13003: GO 13052
// end ; if un = Masha then
13005: LD_VAR 0 1
13009: PUSH
13010: LD_EXP 48
13014: EQUAL
13015: IFFALSE 13024
// ChangeMissionObjectives ( M4b ) ;
13017: LD_STRING M4b
13019: PPUSH
13020: CALL_OW 337
// if un = Mastodont then
13024: LD_VAR 0 1
13028: PUSH
13029: LD_EXP 55
13033: EQUAL
13034: IFFALSE 13043
// ChangeMissionObjectives ( M4a ) ;
13036: LD_STRING M4a
13038: PPUSH
13039: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13043: LD_VAR 0 1
13047: PPUSH
13048: CALL 83954 0 1
// end ;
13052: PPOPN 3
13054: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13055: LD_VAR 0 1
13059: PPUSH
13060: LD_VAR 0 2
13064: PPUSH
13065: CALL 86154 0 2
// end ;
13069: PPOPN 2
13071: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13072: LD_VAR 0 1
13076: PPUSH
13077: CALL 85222 0 1
// end ;
13081: PPOPN 1
13083: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13084: LD_VAR 0 1
13088: PUSH
13089: LD_INT 22
13091: PUSH
13092: LD_INT 7
13094: PUSH
13095: EMPTY
13096: LIST
13097: LIST
13098: PUSH
13099: LD_INT 30
13101: PUSH
13102: LD_INT 0
13104: PUSH
13105: EMPTY
13106: LIST
13107: LIST
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PPUSH
13113: CALL_OW 69
13117: IN
13118: IFFALSE 13157
// begin SetBName ( building , freedom ) ;
13120: LD_VAR 0 1
13124: PPUSH
13125: LD_STRING freedom
13127: PPUSH
13128: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13132: LD_INT 0
13134: PPUSH
13135: LD_INT 7
13137: PPUSH
13138: LD_INT 0
13140: PPUSH
13141: CALL_OW 324
// freedom := building ;
13145: LD_ADDR_EXP 3
13149: PUSH
13150: LD_VAR 0 1
13154: ST_TO_ADDR
// exit ;
13155: GO 13223
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13157: LD_VAR 0 1
13161: PUSH
13162: LD_INT 22
13164: PUSH
13165: LD_INT 7
13167: PUSH
13168: EMPTY
13169: LIST
13170: LIST
13171: PUSH
13172: LD_INT 23
13174: PUSH
13175: LD_INT 3
13177: PUSH
13178: EMPTY
13179: LIST
13180: LIST
13181: PUSH
13182: LD_INT 30
13184: PUSH
13185: LD_INT 6
13187: PUSH
13188: EMPTY
13189: LIST
13190: LIST
13191: PUSH
13192: EMPTY
13193: LIST
13194: LIST
13195: LIST
13196: PPUSH
13197: CALL_OW 69
13201: IN
13202: IFFALSE 13214
// begin ru_lab_builded := true ;
13204: LD_ADDR_EXP 5
13208: PUSH
13209: LD_INT 1
13211: ST_TO_ADDR
// exit ;
13212: GO 13223
// end ; MCE_BuildingComplete ( building ) ;
13214: LD_VAR 0 1
13218: PPUSH
13219: CALL 85463 0 1
// end ;
13223: PPOPN 1
13225: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13226: LD_VAR 0 1
13230: PPUSH
13231: LD_VAR 0 2
13235: PPUSH
13236: CALL 83650 0 2
// end ;
13240: PPOPN 2
13242: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13243: LD_VAR 0 1
13247: PPUSH
13248: LD_VAR 0 2
13252: PPUSH
13253: LD_VAR 0 3
13257: PPUSH
13258: LD_VAR 0 4
13262: PPUSH
13263: LD_VAR 0 5
13267: PPUSH
13268: CALL 83270 0 5
// end ;
13272: PPOPN 5
13274: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13275: LD_VAR 0 1
13279: PPUSH
13280: LD_VAR 0 2
13284: PPUSH
13285: CALL 82866 0 2
// end ;
13289: PPOPN 2
13291: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13292: LD_VAR 0 1
13296: PPUSH
13297: LD_VAR 0 2
13301: PPUSH
13302: LD_VAR 0 3
13306: PPUSH
13307: LD_VAR 0 4
13311: PPUSH
13312: CALL 82704 0 4
// end ;
13316: PPOPN 4
13318: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13319: LD_VAR 0 1
13323: PPUSH
13324: LD_VAR 0 2
13328: PPUSH
13329: LD_VAR 0 3
13333: PPUSH
13334: CALL 82479 0 3
// end ;
13338: PPOPN 3
13340: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13341: LD_VAR 0 1
13345: PPUSH
13346: LD_VAR 0 2
13350: PPUSH
13351: CALL 82364 0 2
// end ;
13355: PPOPN 2
13357: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13358: LD_VAR 0 1
13362: PPUSH
13363: LD_VAR 0 2
13367: PPUSH
13368: CALL 86415 0 2
// end ;
13372: PPOPN 2
13374: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13375: LD_VAR 0 1
13379: PPUSH
13380: LD_VAR 0 2
13384: PPUSH
13385: LD_VAR 0 3
13389: PPUSH
13390: LD_VAR 0 4
13394: PPUSH
13395: CALL 86631 0 4
// end ;
13399: PPOPN 4
13401: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_VAR 0 2
13411: PPUSH
13412: CALL 82173 0 2
// end ;
13416: PPOPN 2
13418: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13419: LD_VAR 0 1
13423: PPUSH
13424: CALL 86914 0 1
// end ; end_of_file
13428: PPOPN 1
13430: END
// every 0 0$30 do var cr , time ;
13431: GO 13433
13433: DISABLE
13434: LD_INT 0
13436: PPUSH
13437: PPUSH
// begin time := 0 0$30 ;
13438: LD_ADDR_VAR 0 2
13442: PUSH
13443: LD_INT 1050
13445: ST_TO_ADDR
// while game do
13446: LD_EXP 2
13450: IFFALSE 13549
// begin wait ( time ) ;
13452: LD_VAR 0 2
13456: PPUSH
13457: CALL_OW 67
// if tick > 2 2$00 then
13461: LD_OWVAR 1
13465: PUSH
13466: LD_INT 4200
13468: GREATER
13469: IFFALSE 13502
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13471: LD_ADDR_VAR 0 2
13475: PUSH
13476: LD_VAR 0 2
13480: PUSH
13481: LD_INT 280
13483: PUSH
13484: LD_INT 420
13486: PUSH
13487: LD_INT 630
13489: PUSH
13490: EMPTY
13491: LIST
13492: LIST
13493: LIST
13494: PUSH
13495: LD_OWVAR 67
13499: ARRAY
13500: PLUS
13501: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13502: LD_INT 1
13504: PPUSH
13505: LD_INT 5
13507: PPUSH
13508: CALL_OW 12
13512: PPUSH
13513: LD_INT 70
13515: PPUSH
13516: LD_INT 49
13518: PPUSH
13519: LD_INT 25
13521: PPUSH
13522: LD_INT 1
13524: PPUSH
13525: CALL_OW 56
// if time > 5 5$00 then
13529: LD_VAR 0 2
13533: PUSH
13534: LD_INT 10500
13536: GREATER
13537: IFFALSE 13547
// time := 0 0$30 ;
13539: LD_ADDR_VAR 0 2
13543: PUSH
13544: LD_INT 1050
13546: ST_TO_ADDR
// end ;
13547: GO 13446
// end ;
13549: PPOPN 2
13551: END
// every 0 0$30 do var cr , time ;
13552: GO 13554
13554: DISABLE
13555: LD_INT 0
13557: PPUSH
13558: PPUSH
// begin time := 0 0$20 ;
13559: LD_ADDR_VAR 0 2
13563: PUSH
13564: LD_INT 700
13566: ST_TO_ADDR
// while game do
13567: LD_EXP 2
13571: IFFALSE 13660
// begin wait ( time ) ;
13573: LD_VAR 0 2
13577: PPUSH
13578: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13582: LD_ADDR_VAR 0 2
13586: PUSH
13587: LD_VAR 0 2
13591: PUSH
13592: LD_INT 490
13594: PUSH
13595: LD_INT 525
13597: PUSH
13598: LD_INT 560
13600: PUSH
13601: EMPTY
13602: LIST
13603: LIST
13604: LIST
13605: PUSH
13606: LD_OWVAR 67
13610: ARRAY
13611: PLUS
13612: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13613: LD_INT 3
13615: PPUSH
13616: LD_INT 5
13618: PPUSH
13619: CALL_OW 12
13623: PPUSH
13624: LD_INT 26
13626: PPUSH
13627: LD_INT 9
13629: PPUSH
13630: LD_INT 30
13632: PPUSH
13633: LD_INT 1
13635: PPUSH
13636: CALL_OW 56
// if time > 3 3$00 then
13640: LD_VAR 0 2
13644: PUSH
13645: LD_INT 6300
13647: GREATER
13648: IFFALSE 13658
// time := 0 0$20 ;
13650: LD_ADDR_VAR 0 2
13654: PUSH
13655: LD_INT 700
13657: ST_TO_ADDR
// end ;
13658: GO 13567
// end ;
13660: PPOPN 2
13662: END
// every 0 0$30 do var cr , time ;
13663: GO 13665
13665: DISABLE
13666: LD_INT 0
13668: PPUSH
13669: PPUSH
// begin time := 0 0$20 ;
13670: LD_ADDR_VAR 0 2
13674: PUSH
13675: LD_INT 700
13677: ST_TO_ADDR
// while game do
13678: LD_EXP 2
13682: IFFALSE 13807
// begin wait ( time ) ;
13684: LD_VAR 0 2
13688: PPUSH
13689: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13693: LD_ADDR_VAR 0 2
13697: PUSH
13698: LD_VAR 0 2
13702: PUSH
13703: LD_INT 175
13705: PUSH
13706: LD_INT 210
13708: PUSH
13709: LD_INT 280
13711: PUSH
13712: EMPTY
13713: LIST
13714: LIST
13715: LIST
13716: PUSH
13717: LD_OWVAR 67
13721: ARRAY
13722: PLUS
13723: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13724: LD_INT 1
13726: PPUSH
13727: LD_INT 5
13729: PPUSH
13730: CALL_OW 12
13734: PPUSH
13735: LD_INT 179
13737: PPUSH
13738: LD_INT 101
13740: PPUSH
13741: LD_INT 20
13743: PPUSH
13744: LD_INT 1
13746: PPUSH
13747: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13751: LD_INT 350
13753: PPUSH
13754: LD_INT 525
13756: PPUSH
13757: CALL_OW 12
13761: PPUSH
13762: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13766: LD_INT 1
13768: PPUSH
13769: LD_INT 5
13771: PPUSH
13772: CALL_OW 12
13776: PPUSH
13777: LD_INT 9
13779: PPUSH
13780: LD_INT 1
13782: PPUSH
13783: CALL_OW 55
// if time > 4 4$00 then
13787: LD_VAR 0 2
13791: PUSH
13792: LD_INT 8400
13794: GREATER
13795: IFFALSE 13805
// time := 0 0$30 ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_INT 1050
13804: ST_TO_ADDR
// end ;
13805: GO 13678
// end ;
13807: PPOPN 2
13809: END
// every 0 0$30 do var cr , time ;
13810: GO 13812
13812: DISABLE
13813: LD_INT 0
13815: PPUSH
13816: PPUSH
// begin time := 0 0$10 ;
13817: LD_ADDR_VAR 0 2
13821: PUSH
13822: LD_INT 350
13824: ST_TO_ADDR
// while game do
13825: LD_EXP 2
13829: IFFALSE 13963
// begin wait ( time ) ;
13831: LD_VAR 0 2
13835: PPUSH
13836: CALL_OW 67
// time := time + 0 0$10 ;
13840: LD_ADDR_VAR 0 2
13844: PUSH
13845: LD_VAR 0 2
13849: PUSH
13850: LD_INT 350
13852: PLUS
13853: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
13854: LD_INT 1
13856: PPUSH
13857: LD_INT 5
13859: PPUSH
13860: CALL_OW 12
13864: PPUSH
13865: LD_INT 11
13867: PPUSH
13868: LD_INT 1
13870: PPUSH
13871: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
13875: LD_ADDR_VAR 0 1
13879: PUSH
13880: LD_INT 1
13882: PPUSH
13883: LD_INT 3
13885: PPUSH
13886: CALL_OW 12
13890: ST_TO_ADDR
// if cr = 1 then
13891: LD_VAR 0 1
13895: PUSH
13896: LD_INT 1
13898: EQUAL
13899: IFFALSE 13943
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
13901: LD_INT 700
13903: PPUSH
13904: LD_INT 1575
13906: PPUSH
13907: CALL_OW 12
13911: PPUSH
13912: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
13916: LD_INT 1
13918: PPUSH
13919: LD_INT 5
13921: PPUSH
13922: CALL_OW 12
13926: PPUSH
13927: LD_INT 34
13929: PPUSH
13930: LD_INT 50
13932: PPUSH
13933: LD_INT 7
13935: PPUSH
13936: LD_INT 1
13938: PPUSH
13939: CALL_OW 56
// end ; if time > 8 8$00 then
13943: LD_VAR 0 2
13947: PUSH
13948: LD_INT 16800
13950: GREATER
13951: IFFALSE 13961
// time := 0 0$40 ;
13953: LD_ADDR_VAR 0 2
13957: PUSH
13958: LD_INT 1400
13960: ST_TO_ADDR
// end ;
13961: GO 13825
// end ; end_of_file
13963: PPOPN 2
13965: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
13966: LD_INT 0
13968: PPUSH
13969: PPUSH
// if exist_mode then
13970: LD_VAR 0 2
13974: IFFALSE 13999
// unit := CreateCharacter ( prefix & ident ) else
13976: LD_ADDR_VAR 0 5
13980: PUSH
13981: LD_VAR 0 3
13985: PUSH
13986: LD_VAR 0 1
13990: STR
13991: PPUSH
13992: CALL_OW 34
13996: ST_TO_ADDR
13997: GO 14014
// unit := NewCharacter ( ident ) ;
13999: LD_ADDR_VAR 0 5
14003: PUSH
14004: LD_VAR 0 1
14008: PPUSH
14009: CALL_OW 25
14013: ST_TO_ADDR
// result := unit ;
14014: LD_ADDR_VAR 0 4
14018: PUSH
14019: LD_VAR 0 5
14023: ST_TO_ADDR
// end ;
14024: LD_VAR 0 4
14028: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14029: LD_INT 0
14031: PPUSH
14032: PPUSH
// if not side or not nation then
14033: LD_VAR 0 1
14037: NOT
14038: PUSH
14039: LD_VAR 0 2
14043: NOT
14044: OR
14045: IFFALSE 14049
// exit ;
14047: GO 14693
// case nation of nation_american :
14049: LD_VAR 0 2
14053: PUSH
14054: LD_INT 1
14056: DOUBLE
14057: EQUAL
14058: IFTRUE 14062
14060: GO 14236
14062: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14063: LD_ADDR_VAR 0 4
14067: PUSH
14068: LD_INT 35
14070: PUSH
14071: LD_INT 45
14073: PUSH
14074: LD_INT 46
14076: PUSH
14077: LD_INT 47
14079: PUSH
14080: LD_INT 1
14082: PUSH
14083: LD_INT 2
14085: PUSH
14086: LD_INT 6
14088: PUSH
14089: LD_INT 15
14091: PUSH
14092: LD_INT 16
14094: PUSH
14095: LD_INT 7
14097: PUSH
14098: LD_INT 12
14100: PUSH
14101: LD_INT 13
14103: PUSH
14104: LD_INT 10
14106: PUSH
14107: LD_INT 14
14109: PUSH
14110: LD_INT 20
14112: PUSH
14113: LD_INT 21
14115: PUSH
14116: LD_INT 22
14118: PUSH
14119: LD_INT 25
14121: PUSH
14122: LD_INT 32
14124: PUSH
14125: LD_INT 27
14127: PUSH
14128: LD_INT 36
14130: PUSH
14131: LD_INT 69
14133: PUSH
14134: LD_INT 39
14136: PUSH
14137: LD_INT 34
14139: PUSH
14140: LD_INT 40
14142: PUSH
14143: LD_INT 48
14145: PUSH
14146: LD_INT 49
14148: PUSH
14149: LD_INT 50
14151: PUSH
14152: LD_INT 51
14154: PUSH
14155: LD_INT 52
14157: PUSH
14158: LD_INT 53
14160: PUSH
14161: LD_INT 54
14163: PUSH
14164: LD_INT 55
14166: PUSH
14167: LD_INT 56
14169: PUSH
14170: LD_INT 57
14172: PUSH
14173: LD_INT 58
14175: PUSH
14176: LD_INT 59
14178: PUSH
14179: LD_INT 60
14181: PUSH
14182: LD_INT 61
14184: PUSH
14185: LD_INT 62
14187: PUSH
14188: LD_INT 80
14190: PUSH
14191: EMPTY
14192: LIST
14193: LIST
14194: LIST
14195: LIST
14196: LIST
14197: LIST
14198: LIST
14199: LIST
14200: LIST
14201: LIST
14202: LIST
14203: LIST
14204: LIST
14205: LIST
14206: LIST
14207: LIST
14208: LIST
14209: LIST
14210: LIST
14211: LIST
14212: LIST
14213: LIST
14214: LIST
14215: LIST
14216: LIST
14217: LIST
14218: LIST
14219: LIST
14220: LIST
14221: LIST
14222: LIST
14223: LIST
14224: LIST
14225: LIST
14226: LIST
14227: LIST
14228: LIST
14229: LIST
14230: LIST
14231: LIST
14232: LIST
14233: ST_TO_ADDR
14234: GO 14617
14236: LD_INT 2
14238: DOUBLE
14239: EQUAL
14240: IFTRUE 14244
14242: GO 14426
14244: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14245: LD_ADDR_VAR 0 4
14249: PUSH
14250: LD_INT 35
14252: PUSH
14253: LD_INT 45
14255: PUSH
14256: LD_INT 46
14258: PUSH
14259: LD_INT 47
14261: PUSH
14262: LD_INT 70
14264: PUSH
14265: LD_INT 1
14267: PUSH
14268: LD_INT 11
14270: PUSH
14271: LD_INT 3
14273: PUSH
14274: LD_INT 4
14276: PUSH
14277: LD_INT 5
14279: PUSH
14280: LD_INT 6
14282: PUSH
14283: LD_INT 15
14285: PUSH
14286: LD_INT 18
14288: PUSH
14289: LD_INT 7
14291: PUSH
14292: LD_INT 17
14294: PUSH
14295: LD_INT 8
14297: PUSH
14298: LD_INT 20
14300: PUSH
14301: LD_INT 21
14303: PUSH
14304: LD_INT 22
14306: PUSH
14307: LD_INT 72
14309: PUSH
14310: LD_INT 26
14312: PUSH
14313: LD_INT 69
14315: PUSH
14316: LD_INT 39
14318: PUSH
14319: LD_INT 40
14321: PUSH
14322: LD_INT 41
14324: PUSH
14325: LD_INT 42
14327: PUSH
14328: LD_INT 43
14330: PUSH
14331: LD_INT 48
14333: PUSH
14334: LD_INT 49
14336: PUSH
14337: LD_INT 50
14339: PUSH
14340: LD_INT 51
14342: PUSH
14343: LD_INT 52
14345: PUSH
14346: LD_INT 53
14348: PUSH
14349: LD_INT 54
14351: PUSH
14352: LD_INT 55
14354: PUSH
14355: LD_INT 56
14357: PUSH
14358: LD_INT 60
14360: PUSH
14361: LD_INT 61
14363: PUSH
14364: LD_INT 62
14366: PUSH
14367: LD_INT 66
14369: PUSH
14370: LD_INT 67
14372: PUSH
14373: LD_INT 68
14375: PUSH
14376: LD_INT 81
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: LIST
14397: LIST
14398: LIST
14399: LIST
14400: LIST
14401: LIST
14402: LIST
14403: LIST
14404: LIST
14405: LIST
14406: LIST
14407: LIST
14408: LIST
14409: LIST
14410: LIST
14411: LIST
14412: LIST
14413: LIST
14414: LIST
14415: LIST
14416: LIST
14417: LIST
14418: LIST
14419: LIST
14420: LIST
14421: LIST
14422: LIST
14423: ST_TO_ADDR
14424: GO 14617
14426: LD_INT 3
14428: DOUBLE
14429: EQUAL
14430: IFTRUE 14434
14432: GO 14616
14434: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14435: LD_ADDR_VAR 0 4
14439: PUSH
14440: LD_INT 46
14442: PUSH
14443: LD_INT 47
14445: PUSH
14446: LD_INT 1
14448: PUSH
14449: LD_INT 2
14451: PUSH
14452: LD_INT 11
14454: PUSH
14455: LD_INT 9
14457: PUSH
14458: LD_INT 20
14460: PUSH
14461: LD_INT 19
14463: PUSH
14464: LD_INT 21
14466: PUSH
14467: LD_INT 24
14469: PUSH
14470: LD_INT 22
14472: PUSH
14473: LD_INT 25
14475: PUSH
14476: LD_INT 28
14478: PUSH
14479: LD_INT 29
14481: PUSH
14482: LD_INT 30
14484: PUSH
14485: LD_INT 31
14487: PUSH
14488: LD_INT 37
14490: PUSH
14491: LD_INT 38
14493: PUSH
14494: LD_INT 32
14496: PUSH
14497: LD_INT 27
14499: PUSH
14500: LD_INT 33
14502: PUSH
14503: LD_INT 69
14505: PUSH
14506: LD_INT 39
14508: PUSH
14509: LD_INT 34
14511: PUSH
14512: LD_INT 40
14514: PUSH
14515: LD_INT 71
14517: PUSH
14518: LD_INT 23
14520: PUSH
14521: LD_INT 44
14523: PUSH
14524: LD_INT 48
14526: PUSH
14527: LD_INT 49
14529: PUSH
14530: LD_INT 50
14532: PUSH
14533: LD_INT 51
14535: PUSH
14536: LD_INT 52
14538: PUSH
14539: LD_INT 53
14541: PUSH
14542: LD_INT 54
14544: PUSH
14545: LD_INT 55
14547: PUSH
14548: LD_INT 56
14550: PUSH
14551: LD_INT 57
14553: PUSH
14554: LD_INT 58
14556: PUSH
14557: LD_INT 59
14559: PUSH
14560: LD_INT 63
14562: PUSH
14563: LD_INT 64
14565: PUSH
14566: LD_INT 65
14568: PUSH
14569: EMPTY
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: ST_TO_ADDR
14614: GO 14617
14616: POP
// if state > - 1 and state < 3 then
14617: LD_VAR 0 3
14621: PUSH
14622: LD_INT 1
14624: NEG
14625: GREATER
14626: PUSH
14627: LD_VAR 0 3
14631: PUSH
14632: LD_INT 3
14634: LESS
14635: AND
14636: IFFALSE 14693
// for i in result do
14638: LD_ADDR_VAR 0 5
14642: PUSH
14643: LD_VAR 0 4
14647: PUSH
14648: FOR_IN
14649: IFFALSE 14691
// if GetTech ( i , side ) <> state then
14651: LD_VAR 0 5
14655: PPUSH
14656: LD_VAR 0 1
14660: PPUSH
14661: CALL_OW 321
14665: PUSH
14666: LD_VAR 0 3
14670: NONEQUAL
14671: IFFALSE 14689
// result := result diff i ;
14673: LD_ADDR_VAR 0 4
14677: PUSH
14678: LD_VAR 0 4
14682: PUSH
14683: LD_VAR 0 5
14687: DIFF
14688: ST_TO_ADDR
14689: GO 14648
14691: POP
14692: POP
// end ;
14693: LD_VAR 0 4
14697: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14698: LD_INT 0
14700: PPUSH
14701: PPUSH
14702: PPUSH
// result := true ;
14703: LD_ADDR_VAR 0 3
14707: PUSH
14708: LD_INT 1
14710: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14711: LD_ADDR_VAR 0 5
14715: PUSH
14716: LD_VAR 0 2
14720: PPUSH
14721: CALL_OW 480
14725: ST_TO_ADDR
// if not tmp then
14726: LD_VAR 0 5
14730: NOT
14731: IFFALSE 14735
// exit ;
14733: GO 14784
// for i in tmp do
14735: LD_ADDR_VAR 0 4
14739: PUSH
14740: LD_VAR 0 5
14744: PUSH
14745: FOR_IN
14746: IFFALSE 14782
// if GetTech ( i , side ) <> state_researched then
14748: LD_VAR 0 4
14752: PPUSH
14753: LD_VAR 0 1
14757: PPUSH
14758: CALL_OW 321
14762: PUSH
14763: LD_INT 2
14765: NONEQUAL
14766: IFFALSE 14780
// begin result := false ;
14768: LD_ADDR_VAR 0 3
14772: PUSH
14773: LD_INT 0
14775: ST_TO_ADDR
// exit ;
14776: POP
14777: POP
14778: GO 14784
// end ;
14780: GO 14745
14782: POP
14783: POP
// end ;
14784: LD_VAR 0 3
14788: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14789: LD_INT 0
14791: PPUSH
14792: PPUSH
14793: PPUSH
14794: PPUSH
14795: PPUSH
14796: PPUSH
14797: PPUSH
14798: PPUSH
14799: PPUSH
14800: PPUSH
14801: PPUSH
14802: PPUSH
14803: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14804: LD_VAR 0 1
14808: NOT
14809: PUSH
14810: LD_VAR 0 1
14814: PPUSH
14815: CALL_OW 257
14819: PUSH
14820: LD_INT 9
14822: NONEQUAL
14823: OR
14824: IFFALSE 14828
// exit ;
14826: GO 15401
// side := GetSide ( unit ) ;
14828: LD_ADDR_VAR 0 9
14832: PUSH
14833: LD_VAR 0 1
14837: PPUSH
14838: CALL_OW 255
14842: ST_TO_ADDR
// tech_space := tech_spacanom ;
14843: LD_ADDR_VAR 0 12
14847: PUSH
14848: LD_INT 29
14850: ST_TO_ADDR
// tech_time := tech_taurad ;
14851: LD_ADDR_VAR 0 13
14855: PUSH
14856: LD_INT 28
14858: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
14859: LD_ADDR_VAR 0 11
14863: PUSH
14864: LD_VAR 0 1
14868: PPUSH
14869: CALL_OW 310
14873: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
14874: LD_VAR 0 11
14878: PPUSH
14879: CALL_OW 247
14883: PUSH
14884: LD_INT 2
14886: EQUAL
14887: IFFALSE 14891
// exit ;
14889: GO 15401
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
14891: LD_ADDR_VAR 0 8
14895: PUSH
14896: LD_INT 81
14898: PUSH
14899: LD_VAR 0 9
14903: PUSH
14904: EMPTY
14905: LIST
14906: LIST
14907: PUSH
14908: LD_INT 3
14910: PUSH
14911: LD_INT 21
14913: PUSH
14914: LD_INT 3
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PUSH
14921: EMPTY
14922: LIST
14923: LIST
14924: PUSH
14925: EMPTY
14926: LIST
14927: LIST
14928: PPUSH
14929: CALL_OW 69
14933: ST_TO_ADDR
// if not tmp then
14934: LD_VAR 0 8
14938: NOT
14939: IFFALSE 14943
// exit ;
14941: GO 15401
// if in_unit then
14943: LD_VAR 0 11
14947: IFFALSE 14971
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
14949: LD_ADDR_VAR 0 10
14953: PUSH
14954: LD_VAR 0 8
14958: PPUSH
14959: LD_VAR 0 11
14963: PPUSH
14964: CALL_OW 74
14968: ST_TO_ADDR
14969: GO 14991
// enemy := NearestUnitToUnit ( tmp , unit ) ;
14971: LD_ADDR_VAR 0 10
14975: PUSH
14976: LD_VAR 0 8
14980: PPUSH
14981: LD_VAR 0 1
14985: PPUSH
14986: CALL_OW 74
14990: ST_TO_ADDR
// if not enemy then
14991: LD_VAR 0 10
14995: NOT
14996: IFFALSE 15000
// exit ;
14998: GO 15401
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15000: LD_VAR 0 11
15004: PUSH
15005: LD_VAR 0 11
15009: PPUSH
15010: LD_VAR 0 10
15014: PPUSH
15015: CALL_OW 296
15019: PUSH
15020: LD_INT 13
15022: GREATER
15023: AND
15024: PUSH
15025: LD_VAR 0 1
15029: PPUSH
15030: LD_VAR 0 10
15034: PPUSH
15035: CALL_OW 296
15039: PUSH
15040: LD_INT 12
15042: GREATER
15043: OR
15044: IFFALSE 15048
// exit ;
15046: GO 15401
// missile := [ 1 ] ;
15048: LD_ADDR_VAR 0 14
15052: PUSH
15053: LD_INT 1
15055: PUSH
15056: EMPTY
15057: LIST
15058: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15059: LD_VAR 0 9
15063: PPUSH
15064: LD_VAR 0 12
15068: PPUSH
15069: CALL_OW 325
15073: IFFALSE 15102
// missile := Insert ( missile , missile + 1 , 2 ) ;
15075: LD_ADDR_VAR 0 14
15079: PUSH
15080: LD_VAR 0 14
15084: PPUSH
15085: LD_VAR 0 14
15089: PUSH
15090: LD_INT 1
15092: PLUS
15093: PPUSH
15094: LD_INT 2
15096: PPUSH
15097: CALL_OW 2
15101: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15102: LD_VAR 0 9
15106: PPUSH
15107: LD_VAR 0 13
15111: PPUSH
15112: CALL_OW 325
15116: PUSH
15117: LD_VAR 0 10
15121: PPUSH
15122: CALL_OW 255
15126: PPUSH
15127: LD_VAR 0 13
15131: PPUSH
15132: CALL_OW 325
15136: NOT
15137: AND
15138: IFFALSE 15167
// missile := Insert ( missile , missile + 1 , 3 ) ;
15140: LD_ADDR_VAR 0 14
15144: PUSH
15145: LD_VAR 0 14
15149: PPUSH
15150: LD_VAR 0 14
15154: PUSH
15155: LD_INT 1
15157: PLUS
15158: PPUSH
15159: LD_INT 3
15161: PPUSH
15162: CALL_OW 2
15166: ST_TO_ADDR
// if missile < 2 then
15167: LD_VAR 0 14
15171: PUSH
15172: LD_INT 2
15174: LESS
15175: IFFALSE 15179
// exit ;
15177: GO 15401
// x := GetX ( enemy ) ;
15179: LD_ADDR_VAR 0 4
15183: PUSH
15184: LD_VAR 0 10
15188: PPUSH
15189: CALL_OW 250
15193: ST_TO_ADDR
// y := GetY ( enemy ) ;
15194: LD_ADDR_VAR 0 5
15198: PUSH
15199: LD_VAR 0 10
15203: PPUSH
15204: CALL_OW 251
15208: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15209: LD_ADDR_VAR 0 6
15213: PUSH
15214: LD_VAR 0 4
15218: PUSH
15219: LD_INT 1
15221: NEG
15222: PPUSH
15223: LD_INT 1
15225: PPUSH
15226: CALL_OW 12
15230: PLUS
15231: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15232: LD_ADDR_VAR 0 7
15236: PUSH
15237: LD_VAR 0 5
15241: PUSH
15242: LD_INT 1
15244: NEG
15245: PPUSH
15246: LD_INT 1
15248: PPUSH
15249: CALL_OW 12
15253: PLUS
15254: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15255: LD_VAR 0 6
15259: PPUSH
15260: LD_VAR 0 7
15264: PPUSH
15265: CALL_OW 488
15269: NOT
15270: IFFALSE 15292
// begin _x := x ;
15272: LD_ADDR_VAR 0 6
15276: PUSH
15277: LD_VAR 0 4
15281: ST_TO_ADDR
// _y := y ;
15282: LD_ADDR_VAR 0 7
15286: PUSH
15287: LD_VAR 0 5
15291: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15292: LD_ADDR_VAR 0 3
15296: PUSH
15297: LD_INT 1
15299: PPUSH
15300: LD_VAR 0 14
15304: PPUSH
15305: CALL_OW 12
15309: ST_TO_ADDR
// case i of 1 :
15310: LD_VAR 0 3
15314: PUSH
15315: LD_INT 1
15317: DOUBLE
15318: EQUAL
15319: IFTRUE 15323
15321: GO 15340
15323: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15324: LD_VAR 0 1
15328: PPUSH
15329: LD_VAR 0 10
15333: PPUSH
15334: CALL_OW 115
15338: GO 15401
15340: LD_INT 2
15342: DOUBLE
15343: EQUAL
15344: IFTRUE 15348
15346: GO 15370
15348: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15349: LD_VAR 0 1
15353: PPUSH
15354: LD_VAR 0 6
15358: PPUSH
15359: LD_VAR 0 7
15363: PPUSH
15364: CALL_OW 153
15368: GO 15401
15370: LD_INT 3
15372: DOUBLE
15373: EQUAL
15374: IFTRUE 15378
15376: GO 15400
15378: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15379: LD_VAR 0 1
15383: PPUSH
15384: LD_VAR 0 6
15388: PPUSH
15389: LD_VAR 0 7
15393: PPUSH
15394: CALL_OW 154
15398: GO 15401
15400: POP
// end ;
15401: LD_VAR 0 2
15405: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15406: LD_INT 0
15408: PPUSH
15409: PPUSH
15410: PPUSH
15411: PPUSH
15412: PPUSH
15413: PPUSH
// if not unit or not building then
15414: LD_VAR 0 1
15418: NOT
15419: PUSH
15420: LD_VAR 0 2
15424: NOT
15425: OR
15426: IFFALSE 15430
// exit ;
15428: GO 15588
// x := GetX ( building ) ;
15430: LD_ADDR_VAR 0 5
15434: PUSH
15435: LD_VAR 0 2
15439: PPUSH
15440: CALL_OW 250
15444: ST_TO_ADDR
// y := GetY ( building ) ;
15445: LD_ADDR_VAR 0 6
15449: PUSH
15450: LD_VAR 0 2
15454: PPUSH
15455: CALL_OW 251
15459: ST_TO_ADDR
// for i = 0 to 5 do
15460: LD_ADDR_VAR 0 4
15464: PUSH
15465: DOUBLE
15466: LD_INT 0
15468: DEC
15469: ST_TO_ADDR
15470: LD_INT 5
15472: PUSH
15473: FOR_TO
15474: IFFALSE 15586
// begin _x := ShiftX ( x , i , 3 ) ;
15476: LD_ADDR_VAR 0 7
15480: PUSH
15481: LD_VAR 0 5
15485: PPUSH
15486: LD_VAR 0 4
15490: PPUSH
15491: LD_INT 3
15493: PPUSH
15494: CALL_OW 272
15498: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15499: LD_ADDR_VAR 0 8
15503: PUSH
15504: LD_VAR 0 6
15508: PPUSH
15509: LD_VAR 0 4
15513: PPUSH
15514: LD_INT 3
15516: PPUSH
15517: CALL_OW 273
15521: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15522: LD_VAR 0 7
15526: PPUSH
15527: LD_VAR 0 8
15531: PPUSH
15532: CALL_OW 488
15536: NOT
15537: IFFALSE 15541
// continue ;
15539: GO 15473
// if HexInfo ( _x , _y ) = 0 then
15541: LD_VAR 0 7
15545: PPUSH
15546: LD_VAR 0 8
15550: PPUSH
15551: CALL_OW 428
15555: PUSH
15556: LD_INT 0
15558: EQUAL
15559: IFFALSE 15584
// begin ComMoveXY ( unit , _x , _y ) ;
15561: LD_VAR 0 1
15565: PPUSH
15566: LD_VAR 0 7
15570: PPUSH
15571: LD_VAR 0 8
15575: PPUSH
15576: CALL_OW 111
// exit ;
15580: POP
15581: POP
15582: GO 15588
// end ; end ;
15584: GO 15473
15586: POP
15587: POP
// end ;
15588: LD_VAR 0 3
15592: RET
// export function ScanBase ( side , base_area ) ; begin
15593: LD_INT 0
15595: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15596: LD_ADDR_VAR 0 3
15600: PUSH
15601: LD_VAR 0 2
15605: PPUSH
15606: LD_INT 81
15608: PUSH
15609: LD_VAR 0 1
15613: PUSH
15614: EMPTY
15615: LIST
15616: LIST
15617: PPUSH
15618: CALL_OW 70
15622: ST_TO_ADDR
// end ;
15623: LD_VAR 0 3
15627: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15628: LD_INT 0
15630: PPUSH
15631: PPUSH
15632: PPUSH
15633: PPUSH
15634: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15635: LD_VAR 0 1
15639: NOT
15640: PUSH
15641: LD_EXP 58
15645: PUSH
15646: LD_VAR 0 1
15650: ARRAY
15651: NOT
15652: OR
15653: PUSH
15654: LD_VAR 0 2
15658: NOT
15659: OR
15660: PUSH
15661: LD_VAR 0 3
15665: NOT
15666: OR
15667: IFFALSE 15671
// exit ;
15669: GO 16184
// side := mc_sides [ base ] ;
15671: LD_ADDR_VAR 0 6
15675: PUSH
15676: LD_EXP 84
15680: PUSH
15681: LD_VAR 0 1
15685: ARRAY
15686: ST_TO_ADDR
// if not side then
15687: LD_VAR 0 6
15691: NOT
15692: IFFALSE 15696
// exit ;
15694: GO 16184
// for i in solds do
15696: LD_ADDR_VAR 0 7
15700: PUSH
15701: LD_VAR 0 2
15705: PUSH
15706: FOR_IN
15707: IFFALSE 15768
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15709: LD_VAR 0 7
15713: PPUSH
15714: CALL_OW 310
15718: PPUSH
15719: CALL_OW 266
15723: PUSH
15724: LD_INT 32
15726: PUSH
15727: LD_INT 31
15729: PUSH
15730: EMPTY
15731: LIST
15732: LIST
15733: IN
15734: IFFALSE 15754
// solds := solds diff i else
15736: LD_ADDR_VAR 0 2
15740: PUSH
15741: LD_VAR 0 2
15745: PUSH
15746: LD_VAR 0 7
15750: DIFF
15751: ST_TO_ADDR
15752: GO 15766
// SetTag ( i , 18 ) ;
15754: LD_VAR 0 7
15758: PPUSH
15759: LD_INT 18
15761: PPUSH
15762: CALL_OW 109
15766: GO 15706
15768: POP
15769: POP
// if not solds then
15770: LD_VAR 0 2
15774: NOT
15775: IFFALSE 15779
// exit ;
15777: GO 16184
// repeat wait ( 0 0$1 ) ;
15779: LD_INT 35
15781: PPUSH
15782: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15786: LD_ADDR_VAR 0 5
15790: PUSH
15791: LD_VAR 0 6
15795: PPUSH
15796: LD_VAR 0 3
15800: PPUSH
15801: CALL 15593 0 2
15805: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
15806: LD_EXP 58
15810: PUSH
15811: LD_VAR 0 1
15815: ARRAY
15816: NOT
15817: PUSH
15818: LD_EXP 58
15822: PUSH
15823: LD_VAR 0 1
15827: ARRAY
15828: PUSH
15829: EMPTY
15830: EQUAL
15831: OR
15832: IFFALSE 15869
// begin for i in solds do
15834: LD_ADDR_VAR 0 7
15838: PUSH
15839: LD_VAR 0 2
15843: PUSH
15844: FOR_IN
15845: IFFALSE 15858
// ComStop ( i ) ;
15847: LD_VAR 0 7
15851: PPUSH
15852: CALL_OW 141
15856: GO 15844
15858: POP
15859: POP
// solds := [ ] ;
15860: LD_ADDR_VAR 0 2
15864: PUSH
15865: EMPTY
15866: ST_TO_ADDR
// exit ;
15867: GO 16184
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
15869: LD_VAR 0 5
15873: NOT
15874: PUSH
15875: LD_VAR 0 5
15879: PUSH
15880: LD_INT 3
15882: GREATER
15883: OR
15884: PUSH
15885: LD_EXP 80
15889: PUSH
15890: LD_VAR 0 1
15894: ARRAY
15895: OR
15896: IFFALSE 15937
// begin for i in solds do
15898: LD_ADDR_VAR 0 7
15902: PUSH
15903: LD_VAR 0 2
15907: PUSH
15908: FOR_IN
15909: IFFALSE 15933
// if HasTask ( i ) then
15911: LD_VAR 0 7
15915: PPUSH
15916: CALL_OW 314
15920: IFFALSE 15931
// ComStop ( i ) ;
15922: LD_VAR 0 7
15926: PPUSH
15927: CALL_OW 141
15931: GO 15908
15933: POP
15934: POP
// break ;
15935: GO 16172
// end ; for i in solds do
15937: LD_ADDR_VAR 0 7
15941: PUSH
15942: LD_VAR 0 2
15946: PUSH
15947: FOR_IN
15948: IFFALSE 16164
// begin if IsInUnit ( i ) then
15950: LD_VAR 0 7
15954: PPUSH
15955: CALL_OW 310
15959: IFFALSE 15970
// ComExitBuilding ( i ) ;
15961: LD_VAR 0 7
15965: PPUSH
15966: CALL_OW 122
// if GetLives ( i ) > 333 then
15970: LD_VAR 0 7
15974: PPUSH
15975: CALL_OW 256
15979: PUSH
15980: LD_INT 333
15982: GREATER
15983: IFFALSE 16011
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
15985: LD_VAR 0 7
15989: PPUSH
15990: LD_VAR 0 5
15994: PPUSH
15995: LD_VAR 0 7
15999: PPUSH
16000: CALL_OW 74
16004: PPUSH
16005: CALL_OW 115
16009: GO 16162
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16011: LD_ADDR_VAR 0 8
16015: PUSH
16016: LD_EXP 58
16020: PUSH
16021: LD_VAR 0 1
16025: ARRAY
16026: PPUSH
16027: LD_INT 2
16029: PUSH
16030: LD_INT 30
16032: PUSH
16033: LD_INT 0
16035: PUSH
16036: EMPTY
16037: LIST
16038: LIST
16039: PUSH
16040: LD_INT 30
16042: PUSH
16043: LD_INT 1
16045: PUSH
16046: EMPTY
16047: LIST
16048: LIST
16049: PUSH
16050: LD_INT 30
16052: PUSH
16053: LD_INT 6
16055: PUSH
16056: EMPTY
16057: LIST
16058: LIST
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: LIST
16064: LIST
16065: PPUSH
16066: CALL_OW 72
16070: PPUSH
16071: LD_VAR 0 7
16075: PPUSH
16076: CALL_OW 74
16080: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16081: LD_VAR 0 7
16085: PPUSH
16086: LD_VAR 0 8
16090: PPUSH
16091: CALL_OW 250
16095: PPUSH
16096: LD_INT 3
16098: PPUSH
16099: LD_INT 5
16101: PPUSH
16102: CALL_OW 272
16106: PPUSH
16107: LD_VAR 0 8
16111: PPUSH
16112: CALL_OW 251
16116: PPUSH
16117: LD_INT 3
16119: PPUSH
16120: LD_INT 5
16122: PPUSH
16123: CALL_OW 273
16127: PPUSH
16128: CALL_OW 111
// SetTag ( i , 0 ) ;
16132: LD_VAR 0 7
16136: PPUSH
16137: LD_INT 0
16139: PPUSH
16140: CALL_OW 109
// solds := solds diff i ;
16144: LD_ADDR_VAR 0 2
16148: PUSH
16149: LD_VAR 0 2
16153: PUSH
16154: LD_VAR 0 7
16158: DIFF
16159: ST_TO_ADDR
// continue ;
16160: GO 15947
// end ; end ;
16162: GO 15947
16164: POP
16165: POP
// until solds ;
16166: LD_VAR 0 2
16170: IFFALSE 15779
// MC_Reset ( base , 18 ) ;
16172: LD_VAR 0 1
16176: PPUSH
16177: LD_INT 18
16179: PPUSH
16180: CALL 61057 0 2
// end ;
16184: LD_VAR 0 4
16188: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16189: LD_INT 0
16191: PPUSH
16192: PPUSH
16193: PPUSH
16194: PPUSH
16195: PPUSH
16196: PPUSH
16197: PPUSH
16198: PPUSH
16199: PPUSH
16200: PPUSH
16201: PPUSH
16202: PPUSH
16203: PPUSH
16204: PPUSH
16205: PPUSH
16206: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16207: LD_ADDR_VAR 0 12
16211: PUSH
16212: LD_EXP 58
16216: PUSH
16217: LD_VAR 0 1
16221: ARRAY
16222: PPUSH
16223: LD_INT 25
16225: PUSH
16226: LD_INT 3
16228: PUSH
16229: EMPTY
16230: LIST
16231: LIST
16232: PPUSH
16233: CALL_OW 72
16237: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16238: LD_EXP 98
16242: PUSH
16243: LD_VAR 0 1
16247: ARRAY
16248: IFFALSE 16272
// mechs := mechs diff mc_remote_driver [ base ] ;
16250: LD_ADDR_VAR 0 12
16254: PUSH
16255: LD_VAR 0 12
16259: PUSH
16260: LD_EXP 98
16264: PUSH
16265: LD_VAR 0 1
16269: ARRAY
16270: DIFF
16271: ST_TO_ADDR
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16272: LD_ADDR_VAR 0 8
16276: PUSH
16277: LD_EXP 58
16281: PUSH
16282: LD_VAR 0 1
16286: ARRAY
16287: PPUSH
16288: LD_INT 2
16290: PUSH
16291: LD_INT 25
16293: PUSH
16294: LD_INT 1
16296: PUSH
16297: EMPTY
16298: LIST
16299: LIST
16300: PUSH
16301: LD_INT 25
16303: PUSH
16304: LD_INT 5
16306: PUSH
16307: EMPTY
16308: LIST
16309: LIST
16310: PUSH
16311: LD_INT 25
16313: PUSH
16314: LD_INT 8
16316: PUSH
16317: EMPTY
16318: LIST
16319: LIST
16320: PUSH
16321: LD_INT 25
16323: PUSH
16324: LD_INT 9
16326: PUSH
16327: EMPTY
16328: LIST
16329: LIST
16330: PUSH
16331: EMPTY
16332: LIST
16333: LIST
16334: LIST
16335: LIST
16336: LIST
16337: PPUSH
16338: CALL_OW 72
16342: ST_TO_ADDR
// if not defenders and not solds then
16343: LD_VAR 0 2
16347: NOT
16348: PUSH
16349: LD_VAR 0 8
16353: NOT
16354: AND
16355: IFFALSE 16359
// exit ;
16357: GO 17885
// depot_under_attack := false ;
16359: LD_ADDR_VAR 0 16
16363: PUSH
16364: LD_INT 0
16366: ST_TO_ADDR
// sold_defenders := [ ] ;
16367: LD_ADDR_VAR 0 17
16371: PUSH
16372: EMPTY
16373: ST_TO_ADDR
// if mechs then
16374: LD_VAR 0 12
16378: IFFALSE 16507
// for i in defenders do
16380: LD_ADDR_VAR 0 5
16384: PUSH
16385: LD_VAR 0 2
16389: PUSH
16390: FOR_IN
16391: IFFALSE 16505
// begin SetTag ( i , 20 ) ;
16393: LD_VAR 0 5
16397: PPUSH
16398: LD_INT 20
16400: PPUSH
16401: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16405: LD_VAR 0 5
16409: PPUSH
16410: CALL_OW 263
16414: PUSH
16415: LD_INT 1
16417: EQUAL
16418: PUSH
16419: LD_VAR 0 5
16423: PPUSH
16424: CALL_OW 311
16428: NOT
16429: AND
16430: PUSH
16431: LD_VAR 0 12
16435: AND
16436: IFFALSE 16503
// begin un := mechs [ 1 ] ;
16438: LD_ADDR_VAR 0 10
16442: PUSH
16443: LD_VAR 0 12
16447: PUSH
16448: LD_INT 1
16450: ARRAY
16451: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16452: LD_VAR 0 10
16456: PPUSH
16457: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16461: LD_VAR 0 10
16465: PPUSH
16466: LD_VAR 0 5
16470: PPUSH
16471: CALL_OW 180
// SetTag ( un , 19 ) ;
16475: LD_VAR 0 10
16479: PPUSH
16480: LD_INT 19
16482: PPUSH
16483: CALL_OW 109
// mechs := mechs diff un ;
16487: LD_ADDR_VAR 0 12
16491: PUSH
16492: LD_VAR 0 12
16496: PUSH
16497: LD_VAR 0 10
16501: DIFF
16502: ST_TO_ADDR
// end ; end ;
16503: GO 16390
16505: POP
16506: POP
// if solds then
16507: LD_VAR 0 8
16511: IFFALSE 16570
// for i in solds do
16513: LD_ADDR_VAR 0 5
16517: PUSH
16518: LD_VAR 0 8
16522: PUSH
16523: FOR_IN
16524: IFFALSE 16568
// if not GetTag ( i ) then
16526: LD_VAR 0 5
16530: PPUSH
16531: CALL_OW 110
16535: NOT
16536: IFFALSE 16566
// begin defenders := defenders union i ;
16538: LD_ADDR_VAR 0 2
16542: PUSH
16543: LD_VAR 0 2
16547: PUSH
16548: LD_VAR 0 5
16552: UNION
16553: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16554: LD_VAR 0 5
16558: PPUSH
16559: LD_INT 18
16561: PPUSH
16562: CALL_OW 109
// end ;
16566: GO 16523
16568: POP
16569: POP
// repeat wait ( 0 0$1 ) ;
16570: LD_INT 35
16572: PPUSH
16573: CALL_OW 67
// enemy := mc_scan [ base ] ;
16577: LD_ADDR_VAR 0 3
16581: PUSH
16582: LD_EXP 81
16586: PUSH
16587: LD_VAR 0 1
16591: ARRAY
16592: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16593: LD_EXP 58
16597: PUSH
16598: LD_VAR 0 1
16602: ARRAY
16603: NOT
16604: PUSH
16605: LD_EXP 58
16609: PUSH
16610: LD_VAR 0 1
16614: ARRAY
16615: PUSH
16616: EMPTY
16617: EQUAL
16618: OR
16619: IFFALSE 16656
// begin for i in defenders do
16621: LD_ADDR_VAR 0 5
16625: PUSH
16626: LD_VAR 0 2
16630: PUSH
16631: FOR_IN
16632: IFFALSE 16645
// ComStop ( i ) ;
16634: LD_VAR 0 5
16638: PPUSH
16639: CALL_OW 141
16643: GO 16631
16645: POP
16646: POP
// defenders := [ ] ;
16647: LD_ADDR_VAR 0 2
16651: PUSH
16652: EMPTY
16653: ST_TO_ADDR
// exit ;
16654: GO 17885
// end ; for i in defenders do
16656: LD_ADDR_VAR 0 5
16660: PUSH
16661: LD_VAR 0 2
16665: PUSH
16666: FOR_IN
16667: IFFALSE 17397
// begin e := NearestUnitToUnit ( enemy , i ) ;
16669: LD_ADDR_VAR 0 13
16673: PUSH
16674: LD_VAR 0 3
16678: PPUSH
16679: LD_VAR 0 5
16683: PPUSH
16684: CALL_OW 74
16688: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16689: LD_ADDR_VAR 0 16
16693: PUSH
16694: LD_EXP 58
16698: PUSH
16699: LD_VAR 0 1
16703: ARRAY
16704: PPUSH
16705: LD_INT 2
16707: PUSH
16708: LD_INT 30
16710: PUSH
16711: LD_INT 0
16713: PUSH
16714: EMPTY
16715: LIST
16716: LIST
16717: PUSH
16718: LD_INT 30
16720: PUSH
16721: LD_INT 1
16723: PUSH
16724: EMPTY
16725: LIST
16726: LIST
16727: PUSH
16728: EMPTY
16729: LIST
16730: LIST
16731: LIST
16732: PPUSH
16733: CALL_OW 72
16737: NOT
16738: PUSH
16739: LD_EXP 58
16743: PUSH
16744: LD_VAR 0 1
16748: ARRAY
16749: PPUSH
16750: LD_INT 2
16752: PUSH
16753: LD_INT 30
16755: PUSH
16756: LD_INT 0
16758: PUSH
16759: EMPTY
16760: LIST
16761: LIST
16762: PUSH
16763: LD_INT 30
16765: PUSH
16766: LD_INT 1
16768: PUSH
16769: EMPTY
16770: LIST
16771: LIST
16772: PUSH
16773: EMPTY
16774: LIST
16775: LIST
16776: LIST
16777: PPUSH
16778: CALL_OW 72
16782: PPUSH
16783: CALL_OW 256
16787: PUSH
16788: LD_INT 600
16790: LESS
16791: OR
16792: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
16793: LD_VAR 0 5
16797: PPUSH
16798: CALL_OW 247
16802: PUSH
16803: LD_INT 2
16805: DOUBLE
16806: EQUAL
16807: IFTRUE 16811
16809: GO 17103
16811: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
16812: LD_VAR 0 5
16816: PPUSH
16817: CALL_OW 256
16821: PUSH
16822: LD_INT 650
16824: GREATER
16825: PUSH
16826: LD_VAR 0 5
16830: PPUSH
16831: LD_VAR 0 13
16835: PPUSH
16836: CALL_OW 296
16840: PUSH
16841: LD_INT 40
16843: LESS
16844: PUSH
16845: LD_VAR 0 13
16849: PPUSH
16850: LD_EXP 83
16854: PUSH
16855: LD_VAR 0 1
16859: ARRAY
16860: PPUSH
16861: CALL_OW 308
16865: OR
16866: AND
16867: IFFALSE 16885
// ComAttackUnit ( i , e ) else
16869: LD_VAR 0 5
16873: PPUSH
16874: LD_VAR 0 13
16878: PPUSH
16879: CALL_OW 115
16883: GO 16986
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
16885: LD_VAR 0 13
16889: PPUSH
16890: LD_EXP 83
16894: PUSH
16895: LD_VAR 0 1
16899: ARRAY
16900: PPUSH
16901: CALL_OW 308
16905: NOT
16906: PUSH
16907: LD_VAR 0 5
16911: PPUSH
16912: LD_VAR 0 13
16916: PPUSH
16917: CALL_OW 296
16921: PUSH
16922: LD_INT 40
16924: GREATEREQUAL
16925: AND
16926: PUSH
16927: LD_VAR 0 5
16931: PPUSH
16932: CALL_OW 256
16936: PUSH
16937: LD_INT 650
16939: LESSEQUAL
16940: OR
16941: PUSH
16942: LD_VAR 0 5
16946: PPUSH
16947: LD_EXP 82
16951: PUSH
16952: LD_VAR 0 1
16956: ARRAY
16957: PPUSH
16958: CALL_OW 308
16962: NOT
16963: AND
16964: IFFALSE 16986
// ComMoveToArea ( i , mc_parking [ base ] ) ;
16966: LD_VAR 0 5
16970: PPUSH
16971: LD_EXP 82
16975: PUSH
16976: LD_VAR 0 1
16980: ARRAY
16981: PPUSH
16982: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
16986: LD_VAR 0 5
16990: PPUSH
16991: CALL_OW 256
16995: PUSH
16996: LD_INT 998
16998: LESS
16999: PUSH
17000: LD_VAR 0 5
17004: PPUSH
17005: CALL_OW 263
17009: PUSH
17010: LD_INT 1
17012: EQUAL
17013: AND
17014: PUSH
17015: LD_VAR 0 5
17019: PPUSH
17020: CALL_OW 311
17024: AND
17025: PUSH
17026: LD_VAR 0 5
17030: PPUSH
17031: LD_EXP 82
17035: PUSH
17036: LD_VAR 0 1
17040: ARRAY
17041: PPUSH
17042: CALL_OW 308
17046: AND
17047: IFFALSE 17101
// begin mech := IsDrivenBy ( i ) ;
17049: LD_ADDR_VAR 0 9
17053: PUSH
17054: LD_VAR 0 5
17058: PPUSH
17059: CALL_OW 311
17063: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17064: LD_VAR 0 9
17068: PPUSH
17069: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17073: LD_VAR 0 9
17077: PPUSH
17078: LD_VAR 0 5
17082: PPUSH
17083: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17087: LD_VAR 0 9
17091: PPUSH
17092: LD_VAR 0 5
17096: PPUSH
17097: CALL_OW 180
// end ; end ; unit_human :
17101: GO 17368
17103: LD_INT 1
17105: DOUBLE
17106: EQUAL
17107: IFTRUE 17111
17109: GO 17367
17111: POP
// begin b := IsInUnit ( i ) ;
17112: LD_ADDR_VAR 0 18
17116: PUSH
17117: LD_VAR 0 5
17121: PPUSH
17122: CALL_OW 310
17126: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17127: LD_ADDR_VAR 0 19
17131: PUSH
17132: LD_VAR 0 18
17136: NOT
17137: PUSH
17138: LD_VAR 0 18
17142: PPUSH
17143: CALL_OW 266
17147: PUSH
17148: LD_INT 32
17150: PUSH
17151: LD_INT 31
17153: PUSH
17154: EMPTY
17155: LIST
17156: LIST
17157: IN
17158: OR
17159: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17160: LD_VAR 0 16
17164: PUSH
17165: LD_VAR 0 2
17169: PPUSH
17170: LD_INT 21
17172: PUSH
17173: LD_INT 2
17175: PUSH
17176: EMPTY
17177: LIST
17178: LIST
17179: PPUSH
17180: CALL_OW 72
17184: PUSH
17185: LD_INT 1
17187: LESSEQUAL
17188: OR
17189: PUSH
17190: LD_VAR 0 19
17194: AND
17195: PUSH
17196: LD_VAR 0 5
17200: PUSH
17201: LD_VAR 0 17
17205: IN
17206: NOT
17207: AND
17208: IFFALSE 17301
// begin if b then
17210: LD_VAR 0 18
17214: IFFALSE 17263
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17216: LD_VAR 0 18
17220: PPUSH
17221: LD_VAR 0 3
17225: PPUSH
17226: LD_VAR 0 18
17230: PPUSH
17231: CALL_OW 74
17235: PPUSH
17236: CALL_OW 296
17240: PUSH
17241: LD_INT 10
17243: LESS
17244: PUSH
17245: LD_VAR 0 18
17249: PPUSH
17250: CALL_OW 461
17254: PUSH
17255: LD_INT 7
17257: NONEQUAL
17258: AND
17259: IFFALSE 17263
// continue ;
17261: GO 16666
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17263: LD_ADDR_VAR 0 17
17267: PUSH
17268: LD_VAR 0 17
17272: PPUSH
17273: LD_VAR 0 17
17277: PUSH
17278: LD_INT 1
17280: PLUS
17281: PPUSH
17282: LD_VAR 0 5
17286: PPUSH
17287: CALL_OW 1
17291: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17292: LD_VAR 0 5
17296: PPUSH
17297: CALL_OW 122
// end ; if sold_defenders then
17301: LD_VAR 0 17
17305: IFFALSE 17365
// if i in sold_defenders then
17307: LD_VAR 0 5
17311: PUSH
17312: LD_VAR 0 17
17316: IN
17317: IFFALSE 17365
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17319: LD_VAR 0 5
17323: PPUSH
17324: CALL_OW 314
17328: NOT
17329: PUSH
17330: LD_VAR 0 5
17334: PPUSH
17335: LD_VAR 0 13
17339: PPUSH
17340: CALL_OW 296
17344: PUSH
17345: LD_INT 30
17347: LESS
17348: AND
17349: IFFALSE 17365
// ComAttackUnit ( i , e ) ;
17351: LD_VAR 0 5
17355: PPUSH
17356: LD_VAR 0 13
17360: PPUSH
17361: CALL_OW 115
// end ; end ; end ;
17365: GO 17368
17367: POP
// if IsDead ( i ) then
17368: LD_VAR 0 5
17372: PPUSH
17373: CALL_OW 301
17377: IFFALSE 17395
// defenders := defenders diff i ;
17379: LD_ADDR_VAR 0 2
17383: PUSH
17384: LD_VAR 0 2
17388: PUSH
17389: LD_VAR 0 5
17393: DIFF
17394: ST_TO_ADDR
// end ;
17395: GO 16666
17397: POP
17398: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17399: LD_VAR 0 3
17403: NOT
17404: PUSH
17405: LD_VAR 0 2
17409: NOT
17410: OR
17411: PUSH
17412: LD_EXP 58
17416: PUSH
17417: LD_VAR 0 1
17421: ARRAY
17422: NOT
17423: OR
17424: IFFALSE 16570
// MC_Reset ( base , 18 ) ;
17426: LD_VAR 0 1
17430: PPUSH
17431: LD_INT 18
17433: PPUSH
17434: CALL 61057 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17438: LD_ADDR_VAR 0 2
17442: PUSH
17443: LD_VAR 0 2
17447: PUSH
17448: LD_VAR 0 2
17452: PPUSH
17453: LD_INT 2
17455: PUSH
17456: LD_INT 25
17458: PUSH
17459: LD_INT 1
17461: PUSH
17462: EMPTY
17463: LIST
17464: LIST
17465: PUSH
17466: LD_INT 25
17468: PUSH
17469: LD_INT 5
17471: PUSH
17472: EMPTY
17473: LIST
17474: LIST
17475: PUSH
17476: LD_INT 25
17478: PUSH
17479: LD_INT 8
17481: PUSH
17482: EMPTY
17483: LIST
17484: LIST
17485: PUSH
17486: LD_INT 25
17488: PUSH
17489: LD_INT 9
17491: PUSH
17492: EMPTY
17493: LIST
17494: LIST
17495: PUSH
17496: EMPTY
17497: LIST
17498: LIST
17499: LIST
17500: LIST
17501: LIST
17502: PPUSH
17503: CALL_OW 72
17507: DIFF
17508: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17509: LD_VAR 0 3
17513: NOT
17514: PUSH
17515: LD_VAR 0 2
17519: PPUSH
17520: LD_INT 21
17522: PUSH
17523: LD_INT 2
17525: PUSH
17526: EMPTY
17527: LIST
17528: LIST
17529: PPUSH
17530: CALL_OW 72
17534: AND
17535: IFFALSE 17873
// begin tmp := FilterByTag ( defenders , 19 ) ;
17537: LD_ADDR_VAR 0 11
17541: PUSH
17542: LD_VAR 0 2
17546: PPUSH
17547: LD_INT 19
17549: PPUSH
17550: CALL 54314 0 2
17554: ST_TO_ADDR
// if tmp then
17555: LD_VAR 0 11
17559: IFFALSE 17629
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17561: LD_ADDR_VAR 0 11
17565: PUSH
17566: LD_VAR 0 11
17570: PPUSH
17571: LD_INT 25
17573: PUSH
17574: LD_INT 3
17576: PUSH
17577: EMPTY
17578: LIST
17579: LIST
17580: PPUSH
17581: CALL_OW 72
17585: ST_TO_ADDR
// if tmp then
17586: LD_VAR 0 11
17590: IFFALSE 17629
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17592: LD_ADDR_EXP 70
17596: PUSH
17597: LD_EXP 70
17601: PPUSH
17602: LD_VAR 0 1
17606: PPUSH
17607: LD_EXP 70
17611: PUSH
17612: LD_VAR 0 1
17616: ARRAY
17617: PUSH
17618: LD_VAR 0 11
17622: UNION
17623: PPUSH
17624: CALL_OW 1
17628: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17629: LD_VAR 0 1
17633: PPUSH
17634: LD_INT 19
17636: PPUSH
17637: CALL 61057 0 2
// repeat wait ( 0 0$1 ) ;
17641: LD_INT 35
17643: PPUSH
17644: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17648: LD_EXP 58
17652: PUSH
17653: LD_VAR 0 1
17657: ARRAY
17658: NOT
17659: PUSH
17660: LD_EXP 58
17664: PUSH
17665: LD_VAR 0 1
17669: ARRAY
17670: PUSH
17671: EMPTY
17672: EQUAL
17673: OR
17674: IFFALSE 17711
// begin for i in defenders do
17676: LD_ADDR_VAR 0 5
17680: PUSH
17681: LD_VAR 0 2
17685: PUSH
17686: FOR_IN
17687: IFFALSE 17700
// ComStop ( i ) ;
17689: LD_VAR 0 5
17693: PPUSH
17694: CALL_OW 141
17698: GO 17686
17700: POP
17701: POP
// defenders := [ ] ;
17702: LD_ADDR_VAR 0 2
17706: PUSH
17707: EMPTY
17708: ST_TO_ADDR
// exit ;
17709: GO 17885
// end ; for i in defenders do
17711: LD_ADDR_VAR 0 5
17715: PUSH
17716: LD_VAR 0 2
17720: PUSH
17721: FOR_IN
17722: IFFALSE 17811
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17724: LD_VAR 0 5
17728: PPUSH
17729: LD_EXP 82
17733: PUSH
17734: LD_VAR 0 1
17738: ARRAY
17739: PPUSH
17740: CALL_OW 308
17744: NOT
17745: IFFALSE 17769
// ComMoveToArea ( i , mc_parking [ base ] ) else
17747: LD_VAR 0 5
17751: PPUSH
17752: LD_EXP 82
17756: PUSH
17757: LD_VAR 0 1
17761: ARRAY
17762: PPUSH
17763: CALL_OW 113
17767: GO 17809
// if GetControl ( i ) = control_manual then
17769: LD_VAR 0 5
17773: PPUSH
17774: CALL_OW 263
17778: PUSH
17779: LD_INT 1
17781: EQUAL
17782: IFFALSE 17809
// if IsDrivenBy ( i ) then
17784: LD_VAR 0 5
17788: PPUSH
17789: CALL_OW 311
17793: IFFALSE 17809
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
17795: LD_VAR 0 5
17799: PPUSH
17800: CALL_OW 311
17804: PPUSH
17805: CALL_OW 121
// end ;
17809: GO 17721
17811: POP
17812: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
17813: LD_VAR 0 2
17817: PPUSH
17818: LD_INT 95
17820: PUSH
17821: LD_EXP 82
17825: PUSH
17826: LD_VAR 0 1
17830: ARRAY
17831: PUSH
17832: EMPTY
17833: LIST
17834: LIST
17835: PPUSH
17836: CALL_OW 72
17840: PUSH
17841: LD_VAR 0 2
17845: EQUAL
17846: PUSH
17847: LD_EXP 81
17851: PUSH
17852: LD_VAR 0 1
17856: ARRAY
17857: OR
17858: PUSH
17859: LD_EXP 58
17863: PUSH
17864: LD_VAR 0 1
17868: ARRAY
17869: NOT
17870: OR
17871: IFFALSE 17641
// end ; MC_Reset ( base , 20 ) ;
17873: LD_VAR 0 1
17877: PPUSH
17878: LD_INT 20
17880: PPUSH
17881: CALL 61057 0 2
// end ;
17885: LD_VAR 0 4
17889: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17890: LD_INT 0
17892: PPUSH
17893: PPUSH
17894: PPUSH
17895: PPUSH
// result := false ;
17896: LD_ADDR_VAR 0 2
17900: PUSH
17901: LD_INT 0
17903: ST_TO_ADDR
// side := GetSide ( unit ) ;
17904: LD_ADDR_VAR 0 3
17908: PUSH
17909: LD_VAR 0 1
17913: PPUSH
17914: CALL_OW 255
17918: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17919: LD_ADDR_VAR 0 4
17923: PUSH
17924: LD_VAR 0 1
17928: PPUSH
17929: CALL_OW 248
17933: ST_TO_ADDR
// case nat of 1 :
17934: LD_VAR 0 4
17938: PUSH
17939: LD_INT 1
17941: DOUBLE
17942: EQUAL
17943: IFTRUE 17947
17945: GO 17958
17947: POP
// tech := tech_lassight ; 2 :
17948: LD_ADDR_VAR 0 5
17952: PUSH
17953: LD_INT 12
17955: ST_TO_ADDR
17956: GO 17997
17958: LD_INT 2
17960: DOUBLE
17961: EQUAL
17962: IFTRUE 17966
17964: GO 17977
17966: POP
// tech := tech_mortar ; 3 :
17967: LD_ADDR_VAR 0 5
17971: PUSH
17972: LD_INT 41
17974: ST_TO_ADDR
17975: GO 17997
17977: LD_INT 3
17979: DOUBLE
17980: EQUAL
17981: IFTRUE 17985
17983: GO 17996
17985: POP
// tech := tech_bazooka ; end ;
17986: LD_ADDR_VAR 0 5
17990: PUSH
17991: LD_INT 44
17993: ST_TO_ADDR
17994: GO 17997
17996: POP
// if Researched ( side , tech ) then
17997: LD_VAR 0 3
18001: PPUSH
18002: LD_VAR 0 5
18006: PPUSH
18007: CALL_OW 325
18011: IFFALSE 18038
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18013: LD_ADDR_VAR 0 2
18017: PUSH
18018: LD_INT 5
18020: PUSH
18021: LD_INT 8
18023: PUSH
18024: LD_INT 9
18026: PUSH
18027: EMPTY
18028: LIST
18029: LIST
18030: LIST
18031: PUSH
18032: LD_VAR 0 4
18036: ARRAY
18037: ST_TO_ADDR
// end ;
18038: LD_VAR 0 2
18042: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18043: LD_INT 0
18045: PPUSH
18046: PPUSH
18047: PPUSH
// if not mines then
18048: LD_VAR 0 2
18052: NOT
18053: IFFALSE 18057
// exit ;
18055: GO 18201
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18057: LD_ADDR_VAR 0 5
18061: PUSH
18062: LD_INT 81
18064: PUSH
18065: LD_VAR 0 1
18069: PUSH
18070: EMPTY
18071: LIST
18072: LIST
18073: PUSH
18074: LD_INT 3
18076: PUSH
18077: LD_INT 21
18079: PUSH
18080: LD_INT 3
18082: PUSH
18083: EMPTY
18084: LIST
18085: LIST
18086: PUSH
18087: EMPTY
18088: LIST
18089: LIST
18090: PUSH
18091: EMPTY
18092: LIST
18093: LIST
18094: PPUSH
18095: CALL_OW 69
18099: ST_TO_ADDR
// for i in mines do
18100: LD_ADDR_VAR 0 4
18104: PUSH
18105: LD_VAR 0 2
18109: PUSH
18110: FOR_IN
18111: IFFALSE 18199
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18113: LD_VAR 0 4
18117: PUSH
18118: LD_INT 1
18120: ARRAY
18121: PPUSH
18122: LD_VAR 0 4
18126: PUSH
18127: LD_INT 2
18129: ARRAY
18130: PPUSH
18131: CALL_OW 458
18135: NOT
18136: IFFALSE 18140
// continue ;
18138: GO 18110
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18140: LD_VAR 0 4
18144: PUSH
18145: LD_INT 1
18147: ARRAY
18148: PPUSH
18149: LD_VAR 0 4
18153: PUSH
18154: LD_INT 2
18156: ARRAY
18157: PPUSH
18158: CALL_OW 428
18162: PUSH
18163: LD_VAR 0 5
18167: IN
18168: IFFALSE 18197
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18170: LD_VAR 0 4
18174: PUSH
18175: LD_INT 1
18177: ARRAY
18178: PPUSH
18179: LD_VAR 0 4
18183: PUSH
18184: LD_INT 2
18186: ARRAY
18187: PPUSH
18188: LD_VAR 0 1
18192: PPUSH
18193: CALL_OW 456
// end ;
18197: GO 18110
18199: POP
18200: POP
// end ;
18201: LD_VAR 0 3
18205: RET
// export function Count ( array ) ; var i ; begin
18206: LD_INT 0
18208: PPUSH
18209: PPUSH
// result := 0 ;
18210: LD_ADDR_VAR 0 2
18214: PUSH
18215: LD_INT 0
18217: ST_TO_ADDR
// for i in array do
18218: LD_ADDR_VAR 0 3
18222: PUSH
18223: LD_VAR 0 1
18227: PUSH
18228: FOR_IN
18229: IFFALSE 18253
// if i then
18231: LD_VAR 0 3
18235: IFFALSE 18251
// result := result + 1 ;
18237: LD_ADDR_VAR 0 2
18241: PUSH
18242: LD_VAR 0 2
18246: PUSH
18247: LD_INT 1
18249: PLUS
18250: ST_TO_ADDR
18251: GO 18228
18253: POP
18254: POP
// end ;
18255: LD_VAR 0 2
18259: RET
// export function IsEmpty ( building ) ; begin
18260: LD_INT 0
18262: PPUSH
// if not building then
18263: LD_VAR 0 1
18267: NOT
18268: IFFALSE 18272
// exit ;
18270: GO 18315
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18272: LD_ADDR_VAR 0 2
18276: PUSH
18277: LD_VAR 0 1
18281: PUSH
18282: LD_INT 22
18284: PUSH
18285: LD_VAR 0 1
18289: PPUSH
18290: CALL_OW 255
18294: PUSH
18295: EMPTY
18296: LIST
18297: LIST
18298: PUSH
18299: LD_INT 58
18301: PUSH
18302: EMPTY
18303: LIST
18304: PUSH
18305: EMPTY
18306: LIST
18307: LIST
18308: PPUSH
18309: CALL_OW 69
18313: IN
18314: ST_TO_ADDR
// end ;
18315: LD_VAR 0 2
18319: RET
// export function IsNotFull ( building ) ; begin
18320: LD_INT 0
18322: PPUSH
// if not building then
18323: LD_VAR 0 1
18327: NOT
18328: IFFALSE 18332
// exit ;
18330: GO 18351
// result := UnitsInside ( building ) < 6 ;
18332: LD_ADDR_VAR 0 2
18336: PUSH
18337: LD_VAR 0 1
18341: PPUSH
18342: CALL_OW 313
18346: PUSH
18347: LD_INT 6
18349: LESS
18350: ST_TO_ADDR
// end ;
18351: LD_VAR 0 2
18355: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18356: LD_INT 0
18358: PPUSH
18359: PPUSH
18360: PPUSH
18361: PPUSH
// tmp := [ ] ;
18362: LD_ADDR_VAR 0 3
18366: PUSH
18367: EMPTY
18368: ST_TO_ADDR
// list := [ ] ;
18369: LD_ADDR_VAR 0 5
18373: PUSH
18374: EMPTY
18375: ST_TO_ADDR
// for i = 16 to 25 do
18376: LD_ADDR_VAR 0 4
18380: PUSH
18381: DOUBLE
18382: LD_INT 16
18384: DEC
18385: ST_TO_ADDR
18386: LD_INT 25
18388: PUSH
18389: FOR_TO
18390: IFFALSE 18463
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18392: LD_ADDR_VAR 0 3
18396: PUSH
18397: LD_VAR 0 3
18401: PUSH
18402: LD_INT 22
18404: PUSH
18405: LD_VAR 0 1
18409: PPUSH
18410: CALL_OW 255
18414: PUSH
18415: EMPTY
18416: LIST
18417: LIST
18418: PUSH
18419: LD_INT 91
18421: PUSH
18422: LD_VAR 0 1
18426: PUSH
18427: LD_INT 6
18429: PUSH
18430: EMPTY
18431: LIST
18432: LIST
18433: LIST
18434: PUSH
18435: LD_INT 30
18437: PUSH
18438: LD_VAR 0 4
18442: PUSH
18443: EMPTY
18444: LIST
18445: LIST
18446: PUSH
18447: EMPTY
18448: LIST
18449: LIST
18450: LIST
18451: PUSH
18452: EMPTY
18453: LIST
18454: PPUSH
18455: CALL_OW 69
18459: ADD
18460: ST_TO_ADDR
18461: GO 18389
18463: POP
18464: POP
// for i = 1 to tmp do
18465: LD_ADDR_VAR 0 4
18469: PUSH
18470: DOUBLE
18471: LD_INT 1
18473: DEC
18474: ST_TO_ADDR
18475: LD_VAR 0 3
18479: PUSH
18480: FOR_TO
18481: IFFALSE 18569
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18483: LD_ADDR_VAR 0 5
18487: PUSH
18488: LD_VAR 0 5
18492: PUSH
18493: LD_VAR 0 3
18497: PUSH
18498: LD_VAR 0 4
18502: ARRAY
18503: PPUSH
18504: CALL_OW 266
18508: PUSH
18509: LD_VAR 0 3
18513: PUSH
18514: LD_VAR 0 4
18518: ARRAY
18519: PPUSH
18520: CALL_OW 250
18524: PUSH
18525: LD_VAR 0 3
18529: PUSH
18530: LD_VAR 0 4
18534: ARRAY
18535: PPUSH
18536: CALL_OW 251
18540: PUSH
18541: LD_VAR 0 3
18545: PUSH
18546: LD_VAR 0 4
18550: ARRAY
18551: PPUSH
18552: CALL_OW 254
18556: PUSH
18557: EMPTY
18558: LIST
18559: LIST
18560: LIST
18561: LIST
18562: PUSH
18563: EMPTY
18564: LIST
18565: ADD
18566: ST_TO_ADDR
18567: GO 18480
18569: POP
18570: POP
// result := list ;
18571: LD_ADDR_VAR 0 2
18575: PUSH
18576: LD_VAR 0 5
18580: ST_TO_ADDR
// end ;
18581: LD_VAR 0 2
18585: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18586: LD_INT 0
18588: PPUSH
18589: PPUSH
18590: PPUSH
18591: PPUSH
18592: PPUSH
18593: PPUSH
18594: PPUSH
// if not factory then
18595: LD_VAR 0 1
18599: NOT
18600: IFFALSE 18604
// exit ;
18602: GO 19197
// if control = control_apeman then
18604: LD_VAR 0 4
18608: PUSH
18609: LD_INT 5
18611: EQUAL
18612: IFFALSE 18721
// begin tmp := UnitsInside ( factory ) ;
18614: LD_ADDR_VAR 0 8
18618: PUSH
18619: LD_VAR 0 1
18623: PPUSH
18624: CALL_OW 313
18628: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18629: LD_VAR 0 8
18633: PPUSH
18634: LD_INT 25
18636: PUSH
18637: LD_INT 12
18639: PUSH
18640: EMPTY
18641: LIST
18642: LIST
18643: PPUSH
18644: CALL_OW 72
18648: NOT
18649: IFFALSE 18659
// control := control_manual ;
18651: LD_ADDR_VAR 0 4
18655: PUSH
18656: LD_INT 1
18658: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18659: LD_ADDR_VAR 0 8
18663: PUSH
18664: LD_VAR 0 1
18668: PPUSH
18669: CALL 18356 0 1
18673: ST_TO_ADDR
// if tmp then
18674: LD_VAR 0 8
18678: IFFALSE 18721
// begin for i in tmp do
18680: LD_ADDR_VAR 0 7
18684: PUSH
18685: LD_VAR 0 8
18689: PUSH
18690: FOR_IN
18691: IFFALSE 18719
// if i [ 1 ] = b_ext_radio then
18693: LD_VAR 0 7
18697: PUSH
18698: LD_INT 1
18700: ARRAY
18701: PUSH
18702: LD_INT 22
18704: EQUAL
18705: IFFALSE 18717
// begin control := control_remote ;
18707: LD_ADDR_VAR 0 4
18711: PUSH
18712: LD_INT 2
18714: ST_TO_ADDR
// break ;
18715: GO 18719
// end ;
18717: GO 18690
18719: POP
18720: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18721: LD_VAR 0 1
18725: PPUSH
18726: LD_VAR 0 2
18730: PPUSH
18731: LD_VAR 0 3
18735: PPUSH
18736: LD_VAR 0 4
18740: PPUSH
18741: LD_VAR 0 5
18745: PPUSH
18746: CALL_OW 448
18750: IFFALSE 18785
// begin result := [ chassis , engine , control , weapon ] ;
18752: LD_ADDR_VAR 0 6
18756: PUSH
18757: LD_VAR 0 2
18761: PUSH
18762: LD_VAR 0 3
18766: PUSH
18767: LD_VAR 0 4
18771: PUSH
18772: LD_VAR 0 5
18776: PUSH
18777: EMPTY
18778: LIST
18779: LIST
18780: LIST
18781: LIST
18782: ST_TO_ADDR
// exit ;
18783: GO 19197
// end ; _chassis := AvailableChassisList ( factory ) ;
18785: LD_ADDR_VAR 0 9
18789: PUSH
18790: LD_VAR 0 1
18794: PPUSH
18795: CALL_OW 475
18799: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18800: LD_ADDR_VAR 0 11
18804: PUSH
18805: LD_VAR 0 1
18809: PPUSH
18810: CALL_OW 476
18814: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18815: LD_ADDR_VAR 0 12
18819: PUSH
18820: LD_VAR 0 1
18824: PPUSH
18825: CALL_OW 477
18829: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18830: LD_ADDR_VAR 0 10
18834: PUSH
18835: LD_VAR 0 1
18839: PPUSH
18840: CALL_OW 478
18844: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18845: LD_VAR 0 9
18849: NOT
18850: PUSH
18851: LD_VAR 0 11
18855: NOT
18856: OR
18857: PUSH
18858: LD_VAR 0 12
18862: NOT
18863: OR
18864: PUSH
18865: LD_VAR 0 10
18869: NOT
18870: OR
18871: IFFALSE 18906
// begin result := [ chassis , engine , control , weapon ] ;
18873: LD_ADDR_VAR 0 6
18877: PUSH
18878: LD_VAR 0 2
18882: PUSH
18883: LD_VAR 0 3
18887: PUSH
18888: LD_VAR 0 4
18892: PUSH
18893: LD_VAR 0 5
18897: PUSH
18898: EMPTY
18899: LIST
18900: LIST
18901: LIST
18902: LIST
18903: ST_TO_ADDR
// exit ;
18904: GO 19197
// end ; if not chassis in _chassis then
18906: LD_VAR 0 2
18910: PUSH
18911: LD_VAR 0 9
18915: IN
18916: NOT
18917: IFFALSE 18943
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18919: LD_ADDR_VAR 0 2
18923: PUSH
18924: LD_VAR 0 9
18928: PUSH
18929: LD_INT 1
18931: PPUSH
18932: LD_VAR 0 9
18936: PPUSH
18937: CALL_OW 12
18941: ARRAY
18942: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18943: LD_VAR 0 2
18947: PPUSH
18948: LD_VAR 0 3
18952: PPUSH
18953: CALL 19202 0 2
18957: NOT
18958: IFFALSE 19017
// repeat engine := _engine [ 1 ] ;
18960: LD_ADDR_VAR 0 3
18964: PUSH
18965: LD_VAR 0 11
18969: PUSH
18970: LD_INT 1
18972: ARRAY
18973: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18974: LD_ADDR_VAR 0 11
18978: PUSH
18979: LD_VAR 0 11
18983: PPUSH
18984: LD_INT 1
18986: PPUSH
18987: CALL_OW 3
18991: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18992: LD_VAR 0 2
18996: PPUSH
18997: LD_VAR 0 3
19001: PPUSH
19002: CALL 19202 0 2
19006: PUSH
19007: LD_VAR 0 11
19011: PUSH
19012: EMPTY
19013: EQUAL
19014: OR
19015: IFFALSE 18960
// if not control in _control then
19017: LD_VAR 0 4
19021: PUSH
19022: LD_VAR 0 12
19026: IN
19027: NOT
19028: IFFALSE 19054
// control := _control [ rand ( 1 , _control ) ] ;
19030: LD_ADDR_VAR 0 4
19034: PUSH
19035: LD_VAR 0 12
19039: PUSH
19040: LD_INT 1
19042: PPUSH
19043: LD_VAR 0 12
19047: PPUSH
19048: CALL_OW 12
19052: ARRAY
19053: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19054: LD_VAR 0 2
19058: PPUSH
19059: LD_VAR 0 5
19063: PPUSH
19064: CALL 19422 0 2
19068: NOT
19069: IFFALSE 19128
// repeat weapon := _weapon [ 1 ] ;
19071: LD_ADDR_VAR 0 5
19075: PUSH
19076: LD_VAR 0 10
19080: PUSH
19081: LD_INT 1
19083: ARRAY
19084: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19085: LD_ADDR_VAR 0 10
19089: PUSH
19090: LD_VAR 0 10
19094: PPUSH
19095: LD_INT 1
19097: PPUSH
19098: CALL_OW 3
19102: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19103: LD_VAR 0 2
19107: PPUSH
19108: LD_VAR 0 5
19112: PPUSH
19113: CALL 19422 0 2
19117: PUSH
19118: LD_VAR 0 10
19122: PUSH
19123: EMPTY
19124: EQUAL
19125: OR
19126: IFFALSE 19071
// result := [ ] ;
19128: LD_ADDR_VAR 0 6
19132: PUSH
19133: EMPTY
19134: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19135: LD_VAR 0 1
19139: PPUSH
19140: LD_VAR 0 2
19144: PPUSH
19145: LD_VAR 0 3
19149: PPUSH
19150: LD_VAR 0 4
19154: PPUSH
19155: LD_VAR 0 5
19159: PPUSH
19160: CALL_OW 448
19164: IFFALSE 19197
// result := [ chassis , engine , control , weapon ] ;
19166: LD_ADDR_VAR 0 6
19170: PUSH
19171: LD_VAR 0 2
19175: PUSH
19176: LD_VAR 0 3
19180: PUSH
19181: LD_VAR 0 4
19185: PUSH
19186: LD_VAR 0 5
19190: PUSH
19191: EMPTY
19192: LIST
19193: LIST
19194: LIST
19195: LIST
19196: ST_TO_ADDR
// end ;
19197: LD_VAR 0 6
19201: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19202: LD_INT 0
19204: PPUSH
// if not chassis or not engine then
19205: LD_VAR 0 1
19209: NOT
19210: PUSH
19211: LD_VAR 0 2
19215: NOT
19216: OR
19217: IFFALSE 19221
// exit ;
19219: GO 19417
// case engine of engine_solar :
19221: LD_VAR 0 2
19225: PUSH
19226: LD_INT 2
19228: DOUBLE
19229: EQUAL
19230: IFTRUE 19234
19232: GO 19272
19234: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19235: LD_ADDR_VAR 0 3
19239: PUSH
19240: LD_INT 11
19242: PUSH
19243: LD_INT 12
19245: PUSH
19246: LD_INT 13
19248: PUSH
19249: LD_INT 14
19251: PUSH
19252: LD_INT 1
19254: PUSH
19255: LD_INT 2
19257: PUSH
19258: LD_INT 3
19260: PUSH
19261: EMPTY
19262: LIST
19263: LIST
19264: LIST
19265: LIST
19266: LIST
19267: LIST
19268: LIST
19269: ST_TO_ADDR
19270: GO 19401
19272: LD_INT 1
19274: DOUBLE
19275: EQUAL
19276: IFTRUE 19280
19278: GO 19342
19280: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19281: LD_ADDR_VAR 0 3
19285: PUSH
19286: LD_INT 11
19288: PUSH
19289: LD_INT 12
19291: PUSH
19292: LD_INT 13
19294: PUSH
19295: LD_INT 14
19297: PUSH
19298: LD_INT 1
19300: PUSH
19301: LD_INT 2
19303: PUSH
19304: LD_INT 3
19306: PUSH
19307: LD_INT 4
19309: PUSH
19310: LD_INT 5
19312: PUSH
19313: LD_INT 21
19315: PUSH
19316: LD_INT 23
19318: PUSH
19319: LD_INT 22
19321: PUSH
19322: LD_INT 24
19324: PUSH
19325: EMPTY
19326: LIST
19327: LIST
19328: LIST
19329: LIST
19330: LIST
19331: LIST
19332: LIST
19333: LIST
19334: LIST
19335: LIST
19336: LIST
19337: LIST
19338: LIST
19339: ST_TO_ADDR
19340: GO 19401
19342: LD_INT 3
19344: DOUBLE
19345: EQUAL
19346: IFTRUE 19350
19348: GO 19400
19350: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19351: LD_ADDR_VAR 0 3
19355: PUSH
19356: LD_INT 13
19358: PUSH
19359: LD_INT 14
19361: PUSH
19362: LD_INT 2
19364: PUSH
19365: LD_INT 3
19367: PUSH
19368: LD_INT 4
19370: PUSH
19371: LD_INT 5
19373: PUSH
19374: LD_INT 21
19376: PUSH
19377: LD_INT 22
19379: PUSH
19380: LD_INT 23
19382: PUSH
19383: LD_INT 24
19385: PUSH
19386: EMPTY
19387: LIST
19388: LIST
19389: LIST
19390: LIST
19391: LIST
19392: LIST
19393: LIST
19394: LIST
19395: LIST
19396: LIST
19397: ST_TO_ADDR
19398: GO 19401
19400: POP
// result := ( chassis in result ) ;
19401: LD_ADDR_VAR 0 3
19405: PUSH
19406: LD_VAR 0 1
19410: PUSH
19411: LD_VAR 0 3
19415: IN
19416: ST_TO_ADDR
// end ;
19417: LD_VAR 0 3
19421: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19422: LD_INT 0
19424: PPUSH
// if not chassis or not weapon then
19425: LD_VAR 0 1
19429: NOT
19430: PUSH
19431: LD_VAR 0 2
19435: NOT
19436: OR
19437: IFFALSE 19441
// exit ;
19439: GO 20467
// case weapon of us_machine_gun :
19441: LD_VAR 0 2
19445: PUSH
19446: LD_INT 2
19448: DOUBLE
19449: EQUAL
19450: IFTRUE 19454
19452: GO 19484
19454: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19455: LD_ADDR_VAR 0 3
19459: PUSH
19460: LD_INT 1
19462: PUSH
19463: LD_INT 2
19465: PUSH
19466: LD_INT 3
19468: PUSH
19469: LD_INT 4
19471: PUSH
19472: LD_INT 5
19474: PUSH
19475: EMPTY
19476: LIST
19477: LIST
19478: LIST
19479: LIST
19480: LIST
19481: ST_TO_ADDR
19482: GO 20451
19484: LD_INT 3
19486: DOUBLE
19487: EQUAL
19488: IFTRUE 19492
19490: GO 19522
19492: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19493: LD_ADDR_VAR 0 3
19497: PUSH
19498: LD_INT 1
19500: PUSH
19501: LD_INT 2
19503: PUSH
19504: LD_INT 3
19506: PUSH
19507: LD_INT 4
19509: PUSH
19510: LD_INT 5
19512: PUSH
19513: EMPTY
19514: LIST
19515: LIST
19516: LIST
19517: LIST
19518: LIST
19519: ST_TO_ADDR
19520: GO 20451
19522: LD_INT 11
19524: DOUBLE
19525: EQUAL
19526: IFTRUE 19530
19528: GO 19560
19530: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19531: LD_ADDR_VAR 0 3
19535: PUSH
19536: LD_INT 1
19538: PUSH
19539: LD_INT 2
19541: PUSH
19542: LD_INT 3
19544: PUSH
19545: LD_INT 4
19547: PUSH
19548: LD_INT 5
19550: PUSH
19551: EMPTY
19552: LIST
19553: LIST
19554: LIST
19555: LIST
19556: LIST
19557: ST_TO_ADDR
19558: GO 20451
19560: LD_INT 4
19562: DOUBLE
19563: EQUAL
19564: IFTRUE 19568
19566: GO 19594
19568: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19569: LD_ADDR_VAR 0 3
19573: PUSH
19574: LD_INT 2
19576: PUSH
19577: LD_INT 3
19579: PUSH
19580: LD_INT 4
19582: PUSH
19583: LD_INT 5
19585: PUSH
19586: EMPTY
19587: LIST
19588: LIST
19589: LIST
19590: LIST
19591: ST_TO_ADDR
19592: GO 20451
19594: LD_INT 5
19596: DOUBLE
19597: EQUAL
19598: IFTRUE 19602
19600: GO 19628
19602: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19603: LD_ADDR_VAR 0 3
19607: PUSH
19608: LD_INT 2
19610: PUSH
19611: LD_INT 3
19613: PUSH
19614: LD_INT 4
19616: PUSH
19617: LD_INT 5
19619: PUSH
19620: EMPTY
19621: LIST
19622: LIST
19623: LIST
19624: LIST
19625: ST_TO_ADDR
19626: GO 20451
19628: LD_INT 9
19630: DOUBLE
19631: EQUAL
19632: IFTRUE 19636
19634: GO 19662
19636: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19637: LD_ADDR_VAR 0 3
19641: PUSH
19642: LD_INT 2
19644: PUSH
19645: LD_INT 3
19647: PUSH
19648: LD_INT 4
19650: PUSH
19651: LD_INT 5
19653: PUSH
19654: EMPTY
19655: LIST
19656: LIST
19657: LIST
19658: LIST
19659: ST_TO_ADDR
19660: GO 20451
19662: LD_INT 7
19664: DOUBLE
19665: EQUAL
19666: IFTRUE 19670
19668: GO 19696
19670: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19671: LD_ADDR_VAR 0 3
19675: PUSH
19676: LD_INT 2
19678: PUSH
19679: LD_INT 3
19681: PUSH
19682: LD_INT 4
19684: PUSH
19685: LD_INT 5
19687: PUSH
19688: EMPTY
19689: LIST
19690: LIST
19691: LIST
19692: LIST
19693: ST_TO_ADDR
19694: GO 20451
19696: LD_INT 12
19698: DOUBLE
19699: EQUAL
19700: IFTRUE 19704
19702: GO 19730
19704: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19705: LD_ADDR_VAR 0 3
19709: PUSH
19710: LD_INT 2
19712: PUSH
19713: LD_INT 3
19715: PUSH
19716: LD_INT 4
19718: PUSH
19719: LD_INT 5
19721: PUSH
19722: EMPTY
19723: LIST
19724: LIST
19725: LIST
19726: LIST
19727: ST_TO_ADDR
19728: GO 20451
19730: LD_INT 13
19732: DOUBLE
19733: EQUAL
19734: IFTRUE 19738
19736: GO 19764
19738: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19739: LD_ADDR_VAR 0 3
19743: PUSH
19744: LD_INT 2
19746: PUSH
19747: LD_INT 3
19749: PUSH
19750: LD_INT 4
19752: PUSH
19753: LD_INT 5
19755: PUSH
19756: EMPTY
19757: LIST
19758: LIST
19759: LIST
19760: LIST
19761: ST_TO_ADDR
19762: GO 20451
19764: LD_INT 14
19766: DOUBLE
19767: EQUAL
19768: IFTRUE 19772
19770: GO 19790
19772: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19773: LD_ADDR_VAR 0 3
19777: PUSH
19778: LD_INT 4
19780: PUSH
19781: LD_INT 5
19783: PUSH
19784: EMPTY
19785: LIST
19786: LIST
19787: ST_TO_ADDR
19788: GO 20451
19790: LD_INT 6
19792: DOUBLE
19793: EQUAL
19794: IFTRUE 19798
19796: GO 19816
19798: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19799: LD_ADDR_VAR 0 3
19803: PUSH
19804: LD_INT 4
19806: PUSH
19807: LD_INT 5
19809: PUSH
19810: EMPTY
19811: LIST
19812: LIST
19813: ST_TO_ADDR
19814: GO 20451
19816: LD_INT 10
19818: DOUBLE
19819: EQUAL
19820: IFTRUE 19824
19822: GO 19842
19824: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19825: LD_ADDR_VAR 0 3
19829: PUSH
19830: LD_INT 4
19832: PUSH
19833: LD_INT 5
19835: PUSH
19836: EMPTY
19837: LIST
19838: LIST
19839: ST_TO_ADDR
19840: GO 20451
19842: LD_INT 22
19844: DOUBLE
19845: EQUAL
19846: IFTRUE 19850
19848: GO 19876
19850: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19851: LD_ADDR_VAR 0 3
19855: PUSH
19856: LD_INT 11
19858: PUSH
19859: LD_INT 12
19861: PUSH
19862: LD_INT 13
19864: PUSH
19865: LD_INT 14
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: LIST
19872: LIST
19873: ST_TO_ADDR
19874: GO 20451
19876: LD_INT 23
19878: DOUBLE
19879: EQUAL
19880: IFTRUE 19884
19882: GO 19910
19884: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19885: LD_ADDR_VAR 0 3
19889: PUSH
19890: LD_INT 11
19892: PUSH
19893: LD_INT 12
19895: PUSH
19896: LD_INT 13
19898: PUSH
19899: LD_INT 14
19901: PUSH
19902: EMPTY
19903: LIST
19904: LIST
19905: LIST
19906: LIST
19907: ST_TO_ADDR
19908: GO 20451
19910: LD_INT 24
19912: DOUBLE
19913: EQUAL
19914: IFTRUE 19918
19916: GO 19944
19918: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19919: LD_ADDR_VAR 0 3
19923: PUSH
19924: LD_INT 11
19926: PUSH
19927: LD_INT 12
19929: PUSH
19930: LD_INT 13
19932: PUSH
19933: LD_INT 14
19935: PUSH
19936: EMPTY
19937: LIST
19938: LIST
19939: LIST
19940: LIST
19941: ST_TO_ADDR
19942: GO 20451
19944: LD_INT 30
19946: DOUBLE
19947: EQUAL
19948: IFTRUE 19952
19950: GO 19978
19952: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19953: LD_ADDR_VAR 0 3
19957: PUSH
19958: LD_INT 11
19960: PUSH
19961: LD_INT 12
19963: PUSH
19964: LD_INT 13
19966: PUSH
19967: LD_INT 14
19969: PUSH
19970: EMPTY
19971: LIST
19972: LIST
19973: LIST
19974: LIST
19975: ST_TO_ADDR
19976: GO 20451
19978: LD_INT 25
19980: DOUBLE
19981: EQUAL
19982: IFTRUE 19986
19984: GO 20004
19986: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19987: LD_ADDR_VAR 0 3
19991: PUSH
19992: LD_INT 13
19994: PUSH
19995: LD_INT 14
19997: PUSH
19998: EMPTY
19999: LIST
20000: LIST
20001: ST_TO_ADDR
20002: GO 20451
20004: LD_INT 27
20006: DOUBLE
20007: EQUAL
20008: IFTRUE 20012
20010: GO 20030
20012: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20013: LD_ADDR_VAR 0 3
20017: PUSH
20018: LD_INT 13
20020: PUSH
20021: LD_INT 14
20023: PUSH
20024: EMPTY
20025: LIST
20026: LIST
20027: ST_TO_ADDR
20028: GO 20451
20030: LD_INT 28
20032: DOUBLE
20033: EQUAL
20034: IFTRUE 20038
20036: GO 20056
20038: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20039: LD_ADDR_VAR 0 3
20043: PUSH
20044: LD_INT 13
20046: PUSH
20047: LD_INT 14
20049: PUSH
20050: EMPTY
20051: LIST
20052: LIST
20053: ST_TO_ADDR
20054: GO 20451
20056: LD_INT 29
20058: DOUBLE
20059: EQUAL
20060: IFTRUE 20064
20062: GO 20082
20064: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20065: LD_ADDR_VAR 0 3
20069: PUSH
20070: LD_INT 13
20072: PUSH
20073: LD_INT 14
20075: PUSH
20076: EMPTY
20077: LIST
20078: LIST
20079: ST_TO_ADDR
20080: GO 20451
20082: LD_INT 31
20084: DOUBLE
20085: EQUAL
20086: IFTRUE 20090
20088: GO 20108
20090: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20091: LD_ADDR_VAR 0 3
20095: PUSH
20096: LD_INT 13
20098: PUSH
20099: LD_INT 14
20101: PUSH
20102: EMPTY
20103: LIST
20104: LIST
20105: ST_TO_ADDR
20106: GO 20451
20108: LD_INT 26
20110: DOUBLE
20111: EQUAL
20112: IFTRUE 20116
20114: GO 20134
20116: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20117: LD_ADDR_VAR 0 3
20121: PUSH
20122: LD_INT 13
20124: PUSH
20125: LD_INT 14
20127: PUSH
20128: EMPTY
20129: LIST
20130: LIST
20131: ST_TO_ADDR
20132: GO 20451
20134: LD_INT 42
20136: DOUBLE
20137: EQUAL
20138: IFTRUE 20142
20140: GO 20168
20142: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20143: LD_ADDR_VAR 0 3
20147: PUSH
20148: LD_INT 21
20150: PUSH
20151: LD_INT 22
20153: PUSH
20154: LD_INT 23
20156: PUSH
20157: LD_INT 24
20159: PUSH
20160: EMPTY
20161: LIST
20162: LIST
20163: LIST
20164: LIST
20165: ST_TO_ADDR
20166: GO 20451
20168: LD_INT 43
20170: DOUBLE
20171: EQUAL
20172: IFTRUE 20176
20174: GO 20202
20176: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20177: LD_ADDR_VAR 0 3
20181: PUSH
20182: LD_INT 21
20184: PUSH
20185: LD_INT 22
20187: PUSH
20188: LD_INT 23
20190: PUSH
20191: LD_INT 24
20193: PUSH
20194: EMPTY
20195: LIST
20196: LIST
20197: LIST
20198: LIST
20199: ST_TO_ADDR
20200: GO 20451
20202: LD_INT 44
20204: DOUBLE
20205: EQUAL
20206: IFTRUE 20210
20208: GO 20236
20210: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20211: LD_ADDR_VAR 0 3
20215: PUSH
20216: LD_INT 21
20218: PUSH
20219: LD_INT 22
20221: PUSH
20222: LD_INT 23
20224: PUSH
20225: LD_INT 24
20227: PUSH
20228: EMPTY
20229: LIST
20230: LIST
20231: LIST
20232: LIST
20233: ST_TO_ADDR
20234: GO 20451
20236: LD_INT 45
20238: DOUBLE
20239: EQUAL
20240: IFTRUE 20244
20242: GO 20270
20244: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20245: LD_ADDR_VAR 0 3
20249: PUSH
20250: LD_INT 21
20252: PUSH
20253: LD_INT 22
20255: PUSH
20256: LD_INT 23
20258: PUSH
20259: LD_INT 24
20261: PUSH
20262: EMPTY
20263: LIST
20264: LIST
20265: LIST
20266: LIST
20267: ST_TO_ADDR
20268: GO 20451
20270: LD_INT 49
20272: DOUBLE
20273: EQUAL
20274: IFTRUE 20278
20276: GO 20304
20278: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20279: LD_ADDR_VAR 0 3
20283: PUSH
20284: LD_INT 21
20286: PUSH
20287: LD_INT 22
20289: PUSH
20290: LD_INT 23
20292: PUSH
20293: LD_INT 24
20295: PUSH
20296: EMPTY
20297: LIST
20298: LIST
20299: LIST
20300: LIST
20301: ST_TO_ADDR
20302: GO 20451
20304: LD_INT 51
20306: DOUBLE
20307: EQUAL
20308: IFTRUE 20312
20310: GO 20338
20312: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20313: LD_ADDR_VAR 0 3
20317: PUSH
20318: LD_INT 21
20320: PUSH
20321: LD_INT 22
20323: PUSH
20324: LD_INT 23
20326: PUSH
20327: LD_INT 24
20329: PUSH
20330: EMPTY
20331: LIST
20332: LIST
20333: LIST
20334: LIST
20335: ST_TO_ADDR
20336: GO 20451
20338: LD_INT 52
20340: DOUBLE
20341: EQUAL
20342: IFTRUE 20346
20344: GO 20372
20346: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20347: LD_ADDR_VAR 0 3
20351: PUSH
20352: LD_INT 21
20354: PUSH
20355: LD_INT 22
20357: PUSH
20358: LD_INT 23
20360: PUSH
20361: LD_INT 24
20363: PUSH
20364: EMPTY
20365: LIST
20366: LIST
20367: LIST
20368: LIST
20369: ST_TO_ADDR
20370: GO 20451
20372: LD_INT 53
20374: DOUBLE
20375: EQUAL
20376: IFTRUE 20380
20378: GO 20398
20380: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20381: LD_ADDR_VAR 0 3
20385: PUSH
20386: LD_INT 23
20388: PUSH
20389: LD_INT 24
20391: PUSH
20392: EMPTY
20393: LIST
20394: LIST
20395: ST_TO_ADDR
20396: GO 20451
20398: LD_INT 46
20400: DOUBLE
20401: EQUAL
20402: IFTRUE 20406
20404: GO 20424
20406: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20407: LD_ADDR_VAR 0 3
20411: PUSH
20412: LD_INT 23
20414: PUSH
20415: LD_INT 24
20417: PUSH
20418: EMPTY
20419: LIST
20420: LIST
20421: ST_TO_ADDR
20422: GO 20451
20424: LD_INT 47
20426: DOUBLE
20427: EQUAL
20428: IFTRUE 20432
20430: GO 20450
20432: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20433: LD_ADDR_VAR 0 3
20437: PUSH
20438: LD_INT 23
20440: PUSH
20441: LD_INT 24
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: ST_TO_ADDR
20448: GO 20451
20450: POP
// result := ( chassis in result ) ;
20451: LD_ADDR_VAR 0 3
20455: PUSH
20456: LD_VAR 0 1
20460: PUSH
20461: LD_VAR 0 3
20465: IN
20466: ST_TO_ADDR
// end ;
20467: LD_VAR 0 3
20471: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20472: LD_INT 0
20474: PPUSH
20475: PPUSH
20476: PPUSH
20477: PPUSH
20478: PPUSH
20479: PPUSH
20480: PPUSH
// result := array ;
20481: LD_ADDR_VAR 0 5
20485: PUSH
20486: LD_VAR 0 1
20490: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20491: LD_VAR 0 1
20495: NOT
20496: PUSH
20497: LD_VAR 0 2
20501: NOT
20502: OR
20503: PUSH
20504: LD_VAR 0 3
20508: NOT
20509: OR
20510: PUSH
20511: LD_VAR 0 2
20515: PUSH
20516: LD_VAR 0 1
20520: GREATER
20521: OR
20522: PUSH
20523: LD_VAR 0 3
20527: PUSH
20528: LD_VAR 0 1
20532: GREATER
20533: OR
20534: IFFALSE 20538
// exit ;
20536: GO 20834
// if direction then
20538: LD_VAR 0 4
20542: IFFALSE 20606
// begin d := 1 ;
20544: LD_ADDR_VAR 0 9
20548: PUSH
20549: LD_INT 1
20551: ST_TO_ADDR
// if i_from > i_to then
20552: LD_VAR 0 2
20556: PUSH
20557: LD_VAR 0 3
20561: GREATER
20562: IFFALSE 20588
// length := ( array - i_from ) + i_to else
20564: LD_ADDR_VAR 0 11
20568: PUSH
20569: LD_VAR 0 1
20573: PUSH
20574: LD_VAR 0 2
20578: MINUS
20579: PUSH
20580: LD_VAR 0 3
20584: PLUS
20585: ST_TO_ADDR
20586: GO 20604
// length := i_to - i_from ;
20588: LD_ADDR_VAR 0 11
20592: PUSH
20593: LD_VAR 0 3
20597: PUSH
20598: LD_VAR 0 2
20602: MINUS
20603: ST_TO_ADDR
// end else
20604: GO 20667
// begin d := - 1 ;
20606: LD_ADDR_VAR 0 9
20610: PUSH
20611: LD_INT 1
20613: NEG
20614: ST_TO_ADDR
// if i_from > i_to then
20615: LD_VAR 0 2
20619: PUSH
20620: LD_VAR 0 3
20624: GREATER
20625: IFFALSE 20645
// length := i_from - i_to else
20627: LD_ADDR_VAR 0 11
20631: PUSH
20632: LD_VAR 0 2
20636: PUSH
20637: LD_VAR 0 3
20641: MINUS
20642: ST_TO_ADDR
20643: GO 20667
// length := ( array - i_to ) + i_from ;
20645: LD_ADDR_VAR 0 11
20649: PUSH
20650: LD_VAR 0 1
20654: PUSH
20655: LD_VAR 0 3
20659: MINUS
20660: PUSH
20661: LD_VAR 0 2
20665: PLUS
20666: ST_TO_ADDR
// end ; if not length then
20667: LD_VAR 0 11
20671: NOT
20672: IFFALSE 20676
// exit ;
20674: GO 20834
// tmp := array ;
20676: LD_ADDR_VAR 0 10
20680: PUSH
20681: LD_VAR 0 1
20685: ST_TO_ADDR
// for i = 1 to length do
20686: LD_ADDR_VAR 0 6
20690: PUSH
20691: DOUBLE
20692: LD_INT 1
20694: DEC
20695: ST_TO_ADDR
20696: LD_VAR 0 11
20700: PUSH
20701: FOR_TO
20702: IFFALSE 20822
// begin for j = 1 to array do
20704: LD_ADDR_VAR 0 7
20708: PUSH
20709: DOUBLE
20710: LD_INT 1
20712: DEC
20713: ST_TO_ADDR
20714: LD_VAR 0 1
20718: PUSH
20719: FOR_TO
20720: IFFALSE 20808
// begin k := j + d ;
20722: LD_ADDR_VAR 0 8
20726: PUSH
20727: LD_VAR 0 7
20731: PUSH
20732: LD_VAR 0 9
20736: PLUS
20737: ST_TO_ADDR
// if k > array then
20738: LD_VAR 0 8
20742: PUSH
20743: LD_VAR 0 1
20747: GREATER
20748: IFFALSE 20758
// k := 1 ;
20750: LD_ADDR_VAR 0 8
20754: PUSH
20755: LD_INT 1
20757: ST_TO_ADDR
// if not k then
20758: LD_VAR 0 8
20762: NOT
20763: IFFALSE 20775
// k := array ;
20765: LD_ADDR_VAR 0 8
20769: PUSH
20770: LD_VAR 0 1
20774: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20775: LD_ADDR_VAR 0 10
20779: PUSH
20780: LD_VAR 0 10
20784: PPUSH
20785: LD_VAR 0 8
20789: PPUSH
20790: LD_VAR 0 1
20794: PUSH
20795: LD_VAR 0 7
20799: ARRAY
20800: PPUSH
20801: CALL_OW 1
20805: ST_TO_ADDR
// end ;
20806: GO 20719
20808: POP
20809: POP
// array := tmp ;
20810: LD_ADDR_VAR 0 1
20814: PUSH
20815: LD_VAR 0 10
20819: ST_TO_ADDR
// end ;
20820: GO 20701
20822: POP
20823: POP
// result := array ;
20824: LD_ADDR_VAR 0 5
20828: PUSH
20829: LD_VAR 0 1
20833: ST_TO_ADDR
// end ;
20834: LD_VAR 0 5
20838: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20839: LD_INT 0
20841: PPUSH
20842: PPUSH
// result := 0 ;
20843: LD_ADDR_VAR 0 3
20847: PUSH
20848: LD_INT 0
20850: ST_TO_ADDR
// if not array or not value in array then
20851: LD_VAR 0 1
20855: NOT
20856: PUSH
20857: LD_VAR 0 2
20861: PUSH
20862: LD_VAR 0 1
20866: IN
20867: NOT
20868: OR
20869: IFFALSE 20873
// exit ;
20871: GO 20927
// for i = 1 to array do
20873: LD_ADDR_VAR 0 4
20877: PUSH
20878: DOUBLE
20879: LD_INT 1
20881: DEC
20882: ST_TO_ADDR
20883: LD_VAR 0 1
20887: PUSH
20888: FOR_TO
20889: IFFALSE 20925
// if value = array [ i ] then
20891: LD_VAR 0 2
20895: PUSH
20896: LD_VAR 0 1
20900: PUSH
20901: LD_VAR 0 4
20905: ARRAY
20906: EQUAL
20907: IFFALSE 20923
// begin result := i ;
20909: LD_ADDR_VAR 0 3
20913: PUSH
20914: LD_VAR 0 4
20918: ST_TO_ADDR
// exit ;
20919: POP
20920: POP
20921: GO 20927
// end ;
20923: GO 20888
20925: POP
20926: POP
// end ;
20927: LD_VAR 0 3
20931: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20932: LD_INT 0
20934: PPUSH
// vc_chassis := chassis ;
20935: LD_ADDR_OWVAR 37
20939: PUSH
20940: LD_VAR 0 1
20944: ST_TO_ADDR
// vc_engine := engine ;
20945: LD_ADDR_OWVAR 39
20949: PUSH
20950: LD_VAR 0 2
20954: ST_TO_ADDR
// vc_control := control ;
20955: LD_ADDR_OWVAR 38
20959: PUSH
20960: LD_VAR 0 3
20964: ST_TO_ADDR
// vc_weapon := weapon ;
20965: LD_ADDR_OWVAR 40
20969: PUSH
20970: LD_VAR 0 4
20974: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20975: LD_ADDR_OWVAR 41
20979: PUSH
20980: LD_VAR 0 5
20984: ST_TO_ADDR
// end ;
20985: LD_VAR 0 6
20989: RET
// export function WantPlant ( unit ) ; var task ; begin
20990: LD_INT 0
20992: PPUSH
20993: PPUSH
// result := false ;
20994: LD_ADDR_VAR 0 2
20998: PUSH
20999: LD_INT 0
21001: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21002: LD_ADDR_VAR 0 3
21006: PUSH
21007: LD_VAR 0 1
21011: PPUSH
21012: CALL_OW 437
21016: ST_TO_ADDR
// if task then
21017: LD_VAR 0 3
21021: IFFALSE 21049
// if task [ 1 ] [ 1 ] = p then
21023: LD_VAR 0 3
21027: PUSH
21028: LD_INT 1
21030: ARRAY
21031: PUSH
21032: LD_INT 1
21034: ARRAY
21035: PUSH
21036: LD_STRING p
21038: EQUAL
21039: IFFALSE 21049
// result := true ;
21041: LD_ADDR_VAR 0 2
21045: PUSH
21046: LD_INT 1
21048: ST_TO_ADDR
// end ;
21049: LD_VAR 0 2
21053: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21054: LD_INT 0
21056: PPUSH
21057: PPUSH
21058: PPUSH
21059: PPUSH
// if pos < 1 then
21060: LD_VAR 0 2
21064: PUSH
21065: LD_INT 1
21067: LESS
21068: IFFALSE 21072
// exit ;
21070: GO 21375
// if pos = 1 then
21072: LD_VAR 0 2
21076: PUSH
21077: LD_INT 1
21079: EQUAL
21080: IFFALSE 21113
// result := Replace ( arr , pos [ 1 ] , value ) else
21082: LD_ADDR_VAR 0 4
21086: PUSH
21087: LD_VAR 0 1
21091: PPUSH
21092: LD_VAR 0 2
21096: PUSH
21097: LD_INT 1
21099: ARRAY
21100: PPUSH
21101: LD_VAR 0 3
21105: PPUSH
21106: CALL_OW 1
21110: ST_TO_ADDR
21111: GO 21375
// begin tmp := arr ;
21113: LD_ADDR_VAR 0 6
21117: PUSH
21118: LD_VAR 0 1
21122: ST_TO_ADDR
// s_arr := [ tmp ] ;
21123: LD_ADDR_VAR 0 7
21127: PUSH
21128: LD_VAR 0 6
21132: PUSH
21133: EMPTY
21134: LIST
21135: ST_TO_ADDR
// for i = 1 to pos - 1 do
21136: LD_ADDR_VAR 0 5
21140: PUSH
21141: DOUBLE
21142: LD_INT 1
21144: DEC
21145: ST_TO_ADDR
21146: LD_VAR 0 2
21150: PUSH
21151: LD_INT 1
21153: MINUS
21154: PUSH
21155: FOR_TO
21156: IFFALSE 21201
// begin tmp := tmp [ pos [ i ] ] ;
21158: LD_ADDR_VAR 0 6
21162: PUSH
21163: LD_VAR 0 6
21167: PUSH
21168: LD_VAR 0 2
21172: PUSH
21173: LD_VAR 0 5
21177: ARRAY
21178: ARRAY
21179: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21180: LD_ADDR_VAR 0 7
21184: PUSH
21185: LD_VAR 0 7
21189: PUSH
21190: LD_VAR 0 6
21194: PUSH
21195: EMPTY
21196: LIST
21197: ADD
21198: ST_TO_ADDR
// end ;
21199: GO 21155
21201: POP
21202: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21203: LD_ADDR_VAR 0 6
21207: PUSH
21208: LD_VAR 0 6
21212: PPUSH
21213: LD_VAR 0 2
21217: PUSH
21218: LD_VAR 0 2
21222: ARRAY
21223: PPUSH
21224: LD_VAR 0 3
21228: PPUSH
21229: CALL_OW 1
21233: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21234: LD_ADDR_VAR 0 7
21238: PUSH
21239: LD_VAR 0 7
21243: PPUSH
21244: LD_VAR 0 7
21248: PPUSH
21249: LD_VAR 0 6
21253: PPUSH
21254: CALL_OW 1
21258: ST_TO_ADDR
// for i = s_arr downto 2 do
21259: LD_ADDR_VAR 0 5
21263: PUSH
21264: DOUBLE
21265: LD_VAR 0 7
21269: INC
21270: ST_TO_ADDR
21271: LD_INT 2
21273: PUSH
21274: FOR_DOWNTO
21275: IFFALSE 21359
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21277: LD_ADDR_VAR 0 6
21281: PUSH
21282: LD_VAR 0 7
21286: PUSH
21287: LD_VAR 0 5
21291: PUSH
21292: LD_INT 1
21294: MINUS
21295: ARRAY
21296: PPUSH
21297: LD_VAR 0 2
21301: PUSH
21302: LD_VAR 0 5
21306: PUSH
21307: LD_INT 1
21309: MINUS
21310: ARRAY
21311: PPUSH
21312: LD_VAR 0 7
21316: PUSH
21317: LD_VAR 0 5
21321: ARRAY
21322: PPUSH
21323: CALL_OW 1
21327: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21328: LD_ADDR_VAR 0 7
21332: PUSH
21333: LD_VAR 0 7
21337: PPUSH
21338: LD_VAR 0 5
21342: PUSH
21343: LD_INT 1
21345: MINUS
21346: PPUSH
21347: LD_VAR 0 6
21351: PPUSH
21352: CALL_OW 1
21356: ST_TO_ADDR
// end ;
21357: GO 21274
21359: POP
21360: POP
// result := s_arr [ 1 ] ;
21361: LD_ADDR_VAR 0 4
21365: PUSH
21366: LD_VAR 0 7
21370: PUSH
21371: LD_INT 1
21373: ARRAY
21374: ST_TO_ADDR
// end ; end ;
21375: LD_VAR 0 4
21379: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21380: LD_INT 0
21382: PPUSH
21383: PPUSH
// if not list then
21384: LD_VAR 0 1
21388: NOT
21389: IFFALSE 21393
// exit ;
21391: GO 21484
// i := list [ pos1 ] ;
21393: LD_ADDR_VAR 0 5
21397: PUSH
21398: LD_VAR 0 1
21402: PUSH
21403: LD_VAR 0 2
21407: ARRAY
21408: ST_TO_ADDR
// if not i then
21409: LD_VAR 0 5
21413: NOT
21414: IFFALSE 21418
// exit ;
21416: GO 21484
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21418: LD_ADDR_VAR 0 1
21422: PUSH
21423: LD_VAR 0 1
21427: PPUSH
21428: LD_VAR 0 2
21432: PPUSH
21433: LD_VAR 0 1
21437: PUSH
21438: LD_VAR 0 3
21442: ARRAY
21443: PPUSH
21444: CALL_OW 1
21448: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21449: LD_ADDR_VAR 0 1
21453: PUSH
21454: LD_VAR 0 1
21458: PPUSH
21459: LD_VAR 0 3
21463: PPUSH
21464: LD_VAR 0 5
21468: PPUSH
21469: CALL_OW 1
21473: ST_TO_ADDR
// result := list ;
21474: LD_ADDR_VAR 0 4
21478: PUSH
21479: LD_VAR 0 1
21483: ST_TO_ADDR
// end ;
21484: LD_VAR 0 4
21488: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21489: LD_INT 0
21491: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21492: LD_ADDR_VAR 0 5
21496: PUSH
21497: LD_VAR 0 1
21501: PPUSH
21502: CALL_OW 250
21506: PPUSH
21507: LD_VAR 0 1
21511: PPUSH
21512: CALL_OW 251
21516: PPUSH
21517: LD_VAR 0 2
21521: PPUSH
21522: LD_VAR 0 3
21526: PPUSH
21527: LD_VAR 0 4
21531: PPUSH
21532: CALL 21542 0 5
21536: ST_TO_ADDR
// end ;
21537: LD_VAR 0 5
21541: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21542: LD_INT 0
21544: PPUSH
21545: PPUSH
21546: PPUSH
21547: PPUSH
// if not list then
21548: LD_VAR 0 3
21552: NOT
21553: IFFALSE 21557
// exit ;
21555: GO 21945
// result := [ ] ;
21557: LD_ADDR_VAR 0 6
21561: PUSH
21562: EMPTY
21563: ST_TO_ADDR
// for i in list do
21564: LD_ADDR_VAR 0 7
21568: PUSH
21569: LD_VAR 0 3
21573: PUSH
21574: FOR_IN
21575: IFFALSE 21777
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21577: LD_ADDR_VAR 0 9
21581: PUSH
21582: LD_VAR 0 7
21586: PPUSH
21587: LD_VAR 0 1
21591: PPUSH
21592: LD_VAR 0 2
21596: PPUSH
21597: CALL_OW 297
21601: ST_TO_ADDR
// if not result then
21602: LD_VAR 0 6
21606: NOT
21607: IFFALSE 21633
// result := [ [ i , tmp ] ] else
21609: LD_ADDR_VAR 0 6
21613: PUSH
21614: LD_VAR 0 7
21618: PUSH
21619: LD_VAR 0 9
21623: PUSH
21624: EMPTY
21625: LIST
21626: LIST
21627: PUSH
21628: EMPTY
21629: LIST
21630: ST_TO_ADDR
21631: GO 21775
// begin if result [ result ] [ 2 ] < tmp then
21633: LD_VAR 0 6
21637: PUSH
21638: LD_VAR 0 6
21642: ARRAY
21643: PUSH
21644: LD_INT 2
21646: ARRAY
21647: PUSH
21648: LD_VAR 0 9
21652: LESS
21653: IFFALSE 21695
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21655: LD_ADDR_VAR 0 6
21659: PUSH
21660: LD_VAR 0 6
21664: PPUSH
21665: LD_VAR 0 6
21669: PUSH
21670: LD_INT 1
21672: PLUS
21673: PPUSH
21674: LD_VAR 0 7
21678: PUSH
21679: LD_VAR 0 9
21683: PUSH
21684: EMPTY
21685: LIST
21686: LIST
21687: PPUSH
21688: CALL_OW 2
21692: ST_TO_ADDR
21693: GO 21775
// for j = 1 to result do
21695: LD_ADDR_VAR 0 8
21699: PUSH
21700: DOUBLE
21701: LD_INT 1
21703: DEC
21704: ST_TO_ADDR
21705: LD_VAR 0 6
21709: PUSH
21710: FOR_TO
21711: IFFALSE 21773
// begin if tmp < result [ j ] [ 2 ] then
21713: LD_VAR 0 9
21717: PUSH
21718: LD_VAR 0 6
21722: PUSH
21723: LD_VAR 0 8
21727: ARRAY
21728: PUSH
21729: LD_INT 2
21731: ARRAY
21732: LESS
21733: IFFALSE 21771
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21735: LD_ADDR_VAR 0 6
21739: PUSH
21740: LD_VAR 0 6
21744: PPUSH
21745: LD_VAR 0 8
21749: PPUSH
21750: LD_VAR 0 7
21754: PUSH
21755: LD_VAR 0 9
21759: PUSH
21760: EMPTY
21761: LIST
21762: LIST
21763: PPUSH
21764: CALL_OW 2
21768: ST_TO_ADDR
// break ;
21769: GO 21773
// end ; end ;
21771: GO 21710
21773: POP
21774: POP
// end ; end ;
21775: GO 21574
21777: POP
21778: POP
// if result and not asc then
21779: LD_VAR 0 6
21783: PUSH
21784: LD_VAR 0 4
21788: NOT
21789: AND
21790: IFFALSE 21865
// begin tmp := result ;
21792: LD_ADDR_VAR 0 9
21796: PUSH
21797: LD_VAR 0 6
21801: ST_TO_ADDR
// for i = tmp downto 1 do
21802: LD_ADDR_VAR 0 7
21806: PUSH
21807: DOUBLE
21808: LD_VAR 0 9
21812: INC
21813: ST_TO_ADDR
21814: LD_INT 1
21816: PUSH
21817: FOR_DOWNTO
21818: IFFALSE 21863
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21820: LD_ADDR_VAR 0 6
21824: PUSH
21825: LD_VAR 0 6
21829: PPUSH
21830: LD_VAR 0 9
21834: PUSH
21835: LD_VAR 0 7
21839: MINUS
21840: PUSH
21841: LD_INT 1
21843: PLUS
21844: PPUSH
21845: LD_VAR 0 9
21849: PUSH
21850: LD_VAR 0 7
21854: ARRAY
21855: PPUSH
21856: CALL_OW 1
21860: ST_TO_ADDR
21861: GO 21817
21863: POP
21864: POP
// end ; tmp := [ ] ;
21865: LD_ADDR_VAR 0 9
21869: PUSH
21870: EMPTY
21871: ST_TO_ADDR
// if mode then
21872: LD_VAR 0 5
21876: IFFALSE 21945
// begin for i = 1 to result do
21878: LD_ADDR_VAR 0 7
21882: PUSH
21883: DOUBLE
21884: LD_INT 1
21886: DEC
21887: ST_TO_ADDR
21888: LD_VAR 0 6
21892: PUSH
21893: FOR_TO
21894: IFFALSE 21933
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21896: LD_ADDR_VAR 0 9
21900: PUSH
21901: LD_VAR 0 9
21905: PPUSH
21906: LD_VAR 0 7
21910: PPUSH
21911: LD_VAR 0 6
21915: PUSH
21916: LD_VAR 0 7
21920: ARRAY
21921: PUSH
21922: LD_INT 1
21924: ARRAY
21925: PPUSH
21926: CALL_OW 1
21930: ST_TO_ADDR
21931: GO 21893
21933: POP
21934: POP
// result := tmp ;
21935: LD_ADDR_VAR 0 6
21939: PUSH
21940: LD_VAR 0 9
21944: ST_TO_ADDR
// end ; end ;
21945: LD_VAR 0 6
21949: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21950: LD_INT 0
21952: PPUSH
21953: PPUSH
21954: PPUSH
21955: PPUSH
21956: PPUSH
21957: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21958: LD_ADDR_VAR 0 5
21962: PUSH
21963: LD_INT 0
21965: PUSH
21966: LD_INT 0
21968: PUSH
21969: LD_INT 0
21971: PUSH
21972: EMPTY
21973: PUSH
21974: EMPTY
21975: LIST
21976: LIST
21977: LIST
21978: LIST
21979: ST_TO_ADDR
// if not x or not y then
21980: LD_VAR 0 2
21984: NOT
21985: PUSH
21986: LD_VAR 0 3
21990: NOT
21991: OR
21992: IFFALSE 21996
// exit ;
21994: GO 23642
// if not range then
21996: LD_VAR 0 4
22000: NOT
22001: IFFALSE 22011
// range := 10 ;
22003: LD_ADDR_VAR 0 4
22007: PUSH
22008: LD_INT 10
22010: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22011: LD_ADDR_VAR 0 8
22015: PUSH
22016: LD_INT 81
22018: PUSH
22019: LD_VAR 0 1
22023: PUSH
22024: EMPTY
22025: LIST
22026: LIST
22027: PUSH
22028: LD_INT 92
22030: PUSH
22031: LD_VAR 0 2
22035: PUSH
22036: LD_VAR 0 3
22040: PUSH
22041: LD_VAR 0 4
22045: PUSH
22046: EMPTY
22047: LIST
22048: LIST
22049: LIST
22050: LIST
22051: PUSH
22052: LD_INT 3
22054: PUSH
22055: LD_INT 21
22057: PUSH
22058: LD_INT 3
22060: PUSH
22061: EMPTY
22062: LIST
22063: LIST
22064: PUSH
22065: EMPTY
22066: LIST
22067: LIST
22068: PUSH
22069: EMPTY
22070: LIST
22071: LIST
22072: LIST
22073: PPUSH
22074: CALL_OW 69
22078: ST_TO_ADDR
// if not tmp then
22079: LD_VAR 0 8
22083: NOT
22084: IFFALSE 22088
// exit ;
22086: GO 23642
// for i in tmp do
22088: LD_ADDR_VAR 0 6
22092: PUSH
22093: LD_VAR 0 8
22097: PUSH
22098: FOR_IN
22099: IFFALSE 23617
// begin points := [ 0 , 0 , 0 ] ;
22101: LD_ADDR_VAR 0 9
22105: PUSH
22106: LD_INT 0
22108: PUSH
22109: LD_INT 0
22111: PUSH
22112: LD_INT 0
22114: PUSH
22115: EMPTY
22116: LIST
22117: LIST
22118: LIST
22119: ST_TO_ADDR
// bpoints := 1 ;
22120: LD_ADDR_VAR 0 10
22124: PUSH
22125: LD_INT 1
22127: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22128: LD_VAR 0 6
22132: PPUSH
22133: CALL_OW 247
22137: PUSH
22138: LD_INT 1
22140: DOUBLE
22141: EQUAL
22142: IFTRUE 22146
22144: GO 22724
22146: POP
// begin if GetClass ( i ) = 1 then
22147: LD_VAR 0 6
22151: PPUSH
22152: CALL_OW 257
22156: PUSH
22157: LD_INT 1
22159: EQUAL
22160: IFFALSE 22181
// points := [ 10 , 5 , 3 ] ;
22162: LD_ADDR_VAR 0 9
22166: PUSH
22167: LD_INT 10
22169: PUSH
22170: LD_INT 5
22172: PUSH
22173: LD_INT 3
22175: PUSH
22176: EMPTY
22177: LIST
22178: LIST
22179: LIST
22180: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22181: LD_VAR 0 6
22185: PPUSH
22186: CALL_OW 257
22190: PUSH
22191: LD_INT 2
22193: PUSH
22194: LD_INT 3
22196: PUSH
22197: LD_INT 4
22199: PUSH
22200: EMPTY
22201: LIST
22202: LIST
22203: LIST
22204: IN
22205: IFFALSE 22226
// points := [ 3 , 2 , 1 ] ;
22207: LD_ADDR_VAR 0 9
22211: PUSH
22212: LD_INT 3
22214: PUSH
22215: LD_INT 2
22217: PUSH
22218: LD_INT 1
22220: PUSH
22221: EMPTY
22222: LIST
22223: LIST
22224: LIST
22225: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22226: LD_VAR 0 6
22230: PPUSH
22231: CALL_OW 257
22235: PUSH
22236: LD_INT 5
22238: EQUAL
22239: IFFALSE 22260
// points := [ 130 , 5 , 2 ] ;
22241: LD_ADDR_VAR 0 9
22245: PUSH
22246: LD_INT 130
22248: PUSH
22249: LD_INT 5
22251: PUSH
22252: LD_INT 2
22254: PUSH
22255: EMPTY
22256: LIST
22257: LIST
22258: LIST
22259: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22260: LD_VAR 0 6
22264: PPUSH
22265: CALL_OW 257
22269: PUSH
22270: LD_INT 8
22272: EQUAL
22273: IFFALSE 22294
// points := [ 35 , 35 , 30 ] ;
22275: LD_ADDR_VAR 0 9
22279: PUSH
22280: LD_INT 35
22282: PUSH
22283: LD_INT 35
22285: PUSH
22286: LD_INT 30
22288: PUSH
22289: EMPTY
22290: LIST
22291: LIST
22292: LIST
22293: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22294: LD_VAR 0 6
22298: PPUSH
22299: CALL_OW 257
22303: PUSH
22304: LD_INT 9
22306: EQUAL
22307: IFFALSE 22328
// points := [ 20 , 55 , 40 ] ;
22309: LD_ADDR_VAR 0 9
22313: PUSH
22314: LD_INT 20
22316: PUSH
22317: LD_INT 55
22319: PUSH
22320: LD_INT 40
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: LIST
22327: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22328: LD_VAR 0 6
22332: PPUSH
22333: CALL_OW 257
22337: PUSH
22338: LD_INT 12
22340: PUSH
22341: LD_INT 16
22343: PUSH
22344: EMPTY
22345: LIST
22346: LIST
22347: IN
22348: IFFALSE 22369
// points := [ 5 , 3 , 2 ] ;
22350: LD_ADDR_VAR 0 9
22354: PUSH
22355: LD_INT 5
22357: PUSH
22358: LD_INT 3
22360: PUSH
22361: LD_INT 2
22363: PUSH
22364: EMPTY
22365: LIST
22366: LIST
22367: LIST
22368: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22369: LD_VAR 0 6
22373: PPUSH
22374: CALL_OW 257
22378: PUSH
22379: LD_INT 17
22381: EQUAL
22382: IFFALSE 22403
// points := [ 100 , 50 , 75 ] ;
22384: LD_ADDR_VAR 0 9
22388: PUSH
22389: LD_INT 100
22391: PUSH
22392: LD_INT 50
22394: PUSH
22395: LD_INT 75
22397: PUSH
22398: EMPTY
22399: LIST
22400: LIST
22401: LIST
22402: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22403: LD_VAR 0 6
22407: PPUSH
22408: CALL_OW 257
22412: PUSH
22413: LD_INT 15
22415: EQUAL
22416: IFFALSE 22437
// points := [ 10 , 5 , 3 ] ;
22418: LD_ADDR_VAR 0 9
22422: PUSH
22423: LD_INT 10
22425: PUSH
22426: LD_INT 5
22428: PUSH
22429: LD_INT 3
22431: PUSH
22432: EMPTY
22433: LIST
22434: LIST
22435: LIST
22436: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22437: LD_VAR 0 6
22441: PPUSH
22442: CALL_OW 257
22446: PUSH
22447: LD_INT 14
22449: EQUAL
22450: IFFALSE 22471
// points := [ 10 , 0 , 0 ] ;
22452: LD_ADDR_VAR 0 9
22456: PUSH
22457: LD_INT 10
22459: PUSH
22460: LD_INT 0
22462: PUSH
22463: LD_INT 0
22465: PUSH
22466: EMPTY
22467: LIST
22468: LIST
22469: LIST
22470: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22471: LD_VAR 0 6
22475: PPUSH
22476: CALL_OW 257
22480: PUSH
22481: LD_INT 11
22483: EQUAL
22484: IFFALSE 22505
// points := [ 30 , 10 , 5 ] ;
22486: LD_ADDR_VAR 0 9
22490: PUSH
22491: LD_INT 30
22493: PUSH
22494: LD_INT 10
22496: PUSH
22497: LD_INT 5
22499: PUSH
22500: EMPTY
22501: LIST
22502: LIST
22503: LIST
22504: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22505: LD_VAR 0 1
22509: PPUSH
22510: LD_INT 5
22512: PPUSH
22513: CALL_OW 321
22517: PUSH
22518: LD_INT 2
22520: EQUAL
22521: IFFALSE 22538
// bpoints := bpoints * 1.8 ;
22523: LD_ADDR_VAR 0 10
22527: PUSH
22528: LD_VAR 0 10
22532: PUSH
22533: LD_REAL  1.80000000000000E+0000
22536: MUL
22537: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22538: LD_VAR 0 6
22542: PPUSH
22543: CALL_OW 257
22547: PUSH
22548: LD_INT 1
22550: PUSH
22551: LD_INT 2
22553: PUSH
22554: LD_INT 3
22556: PUSH
22557: LD_INT 4
22559: PUSH
22560: EMPTY
22561: LIST
22562: LIST
22563: LIST
22564: LIST
22565: IN
22566: PUSH
22567: LD_VAR 0 1
22571: PPUSH
22572: LD_INT 51
22574: PPUSH
22575: CALL_OW 321
22579: PUSH
22580: LD_INT 2
22582: EQUAL
22583: AND
22584: IFFALSE 22601
// bpoints := bpoints * 1.2 ;
22586: LD_ADDR_VAR 0 10
22590: PUSH
22591: LD_VAR 0 10
22595: PUSH
22596: LD_REAL  1.20000000000000E+0000
22599: MUL
22600: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22601: LD_VAR 0 6
22605: PPUSH
22606: CALL_OW 257
22610: PUSH
22611: LD_INT 5
22613: PUSH
22614: LD_INT 7
22616: PUSH
22617: LD_INT 9
22619: PUSH
22620: EMPTY
22621: LIST
22622: LIST
22623: LIST
22624: IN
22625: PUSH
22626: LD_VAR 0 1
22630: PPUSH
22631: LD_INT 52
22633: PPUSH
22634: CALL_OW 321
22638: PUSH
22639: LD_INT 2
22641: EQUAL
22642: AND
22643: IFFALSE 22660
// bpoints := bpoints * 1.5 ;
22645: LD_ADDR_VAR 0 10
22649: PUSH
22650: LD_VAR 0 10
22654: PUSH
22655: LD_REAL  1.50000000000000E+0000
22658: MUL
22659: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22660: LD_VAR 0 1
22664: PPUSH
22665: LD_INT 66
22667: PPUSH
22668: CALL_OW 321
22672: PUSH
22673: LD_INT 2
22675: EQUAL
22676: IFFALSE 22693
// bpoints := bpoints * 1.1 ;
22678: LD_ADDR_VAR 0 10
22682: PUSH
22683: LD_VAR 0 10
22687: PUSH
22688: LD_REAL  1.10000000000000E+0000
22691: MUL
22692: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22693: LD_ADDR_VAR 0 10
22697: PUSH
22698: LD_VAR 0 10
22702: PUSH
22703: LD_VAR 0 6
22707: PPUSH
22708: LD_INT 1
22710: PPUSH
22711: CALL_OW 259
22715: PUSH
22716: LD_REAL  1.15000000000000E+0000
22719: MUL
22720: MUL
22721: ST_TO_ADDR
// end ; unit_vehicle :
22722: GO 23546
22724: LD_INT 2
22726: DOUBLE
22727: EQUAL
22728: IFTRUE 22732
22730: GO 23534
22732: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22733: LD_VAR 0 6
22737: PPUSH
22738: CALL_OW 264
22742: PUSH
22743: LD_INT 2
22745: PUSH
22746: LD_INT 42
22748: PUSH
22749: LD_INT 24
22751: PUSH
22752: EMPTY
22753: LIST
22754: LIST
22755: LIST
22756: IN
22757: IFFALSE 22778
// points := [ 25 , 5 , 3 ] ;
22759: LD_ADDR_VAR 0 9
22763: PUSH
22764: LD_INT 25
22766: PUSH
22767: LD_INT 5
22769: PUSH
22770: LD_INT 3
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: LIST
22777: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22778: LD_VAR 0 6
22782: PPUSH
22783: CALL_OW 264
22787: PUSH
22788: LD_INT 4
22790: PUSH
22791: LD_INT 43
22793: PUSH
22794: LD_INT 25
22796: PUSH
22797: EMPTY
22798: LIST
22799: LIST
22800: LIST
22801: IN
22802: IFFALSE 22823
// points := [ 40 , 15 , 5 ] ;
22804: LD_ADDR_VAR 0 9
22808: PUSH
22809: LD_INT 40
22811: PUSH
22812: LD_INT 15
22814: PUSH
22815: LD_INT 5
22817: PUSH
22818: EMPTY
22819: LIST
22820: LIST
22821: LIST
22822: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22823: LD_VAR 0 6
22827: PPUSH
22828: CALL_OW 264
22832: PUSH
22833: LD_INT 3
22835: PUSH
22836: LD_INT 23
22838: PUSH
22839: EMPTY
22840: LIST
22841: LIST
22842: IN
22843: IFFALSE 22864
// points := [ 7 , 25 , 8 ] ;
22845: LD_ADDR_VAR 0 9
22849: PUSH
22850: LD_INT 7
22852: PUSH
22853: LD_INT 25
22855: PUSH
22856: LD_INT 8
22858: PUSH
22859: EMPTY
22860: LIST
22861: LIST
22862: LIST
22863: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22864: LD_VAR 0 6
22868: PPUSH
22869: CALL_OW 264
22873: PUSH
22874: LD_INT 5
22876: PUSH
22877: LD_INT 27
22879: PUSH
22880: LD_INT 44
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: LIST
22887: IN
22888: IFFALSE 22909
// points := [ 14 , 50 , 16 ] ;
22890: LD_ADDR_VAR 0 9
22894: PUSH
22895: LD_INT 14
22897: PUSH
22898: LD_INT 50
22900: PUSH
22901: LD_INT 16
22903: PUSH
22904: EMPTY
22905: LIST
22906: LIST
22907: LIST
22908: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22909: LD_VAR 0 6
22913: PPUSH
22914: CALL_OW 264
22918: PUSH
22919: LD_INT 6
22921: PUSH
22922: LD_INT 46
22924: PUSH
22925: EMPTY
22926: LIST
22927: LIST
22928: IN
22929: IFFALSE 22950
// points := [ 32 , 120 , 70 ] ;
22931: LD_ADDR_VAR 0 9
22935: PUSH
22936: LD_INT 32
22938: PUSH
22939: LD_INT 120
22941: PUSH
22942: LD_INT 70
22944: PUSH
22945: EMPTY
22946: LIST
22947: LIST
22948: LIST
22949: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
22950: LD_VAR 0 6
22954: PPUSH
22955: CALL_OW 264
22959: PUSH
22960: LD_INT 7
22962: PUSH
22963: LD_INT 28
22965: PUSH
22966: LD_INT 45
22968: PUSH
22969: EMPTY
22970: LIST
22971: LIST
22972: LIST
22973: IN
22974: IFFALSE 22995
// points := [ 35 , 20 , 45 ] ;
22976: LD_ADDR_VAR 0 9
22980: PUSH
22981: LD_INT 35
22983: PUSH
22984: LD_INT 20
22986: PUSH
22987: LD_INT 45
22989: PUSH
22990: EMPTY
22991: LIST
22992: LIST
22993: LIST
22994: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22995: LD_VAR 0 6
22999: PPUSH
23000: CALL_OW 264
23004: PUSH
23005: LD_INT 47
23007: PUSH
23008: EMPTY
23009: LIST
23010: IN
23011: IFFALSE 23032
// points := [ 67 , 45 , 75 ] ;
23013: LD_ADDR_VAR 0 9
23017: PUSH
23018: LD_INT 67
23020: PUSH
23021: LD_INT 45
23023: PUSH
23024: LD_INT 75
23026: PUSH
23027: EMPTY
23028: LIST
23029: LIST
23030: LIST
23031: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23032: LD_VAR 0 6
23036: PPUSH
23037: CALL_OW 264
23041: PUSH
23042: LD_INT 26
23044: PUSH
23045: EMPTY
23046: LIST
23047: IN
23048: IFFALSE 23069
// points := [ 120 , 30 , 80 ] ;
23050: LD_ADDR_VAR 0 9
23054: PUSH
23055: LD_INT 120
23057: PUSH
23058: LD_INT 30
23060: PUSH
23061: LD_INT 80
23063: PUSH
23064: EMPTY
23065: LIST
23066: LIST
23067: LIST
23068: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23069: LD_VAR 0 6
23073: PPUSH
23074: CALL_OW 264
23078: PUSH
23079: LD_INT 22
23081: PUSH
23082: EMPTY
23083: LIST
23084: IN
23085: IFFALSE 23106
// points := [ 40 , 1 , 1 ] ;
23087: LD_ADDR_VAR 0 9
23091: PUSH
23092: LD_INT 40
23094: PUSH
23095: LD_INT 1
23097: PUSH
23098: LD_INT 1
23100: PUSH
23101: EMPTY
23102: LIST
23103: LIST
23104: LIST
23105: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23106: LD_VAR 0 6
23110: PPUSH
23111: CALL_OW 264
23115: PUSH
23116: LD_INT 29
23118: PUSH
23119: EMPTY
23120: LIST
23121: IN
23122: IFFALSE 23143
// points := [ 70 , 200 , 400 ] ;
23124: LD_ADDR_VAR 0 9
23128: PUSH
23129: LD_INT 70
23131: PUSH
23132: LD_INT 200
23134: PUSH
23135: LD_INT 400
23137: PUSH
23138: EMPTY
23139: LIST
23140: LIST
23141: LIST
23142: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23143: LD_VAR 0 6
23147: PPUSH
23148: CALL_OW 264
23152: PUSH
23153: LD_INT 14
23155: PUSH
23156: LD_INT 53
23158: PUSH
23159: EMPTY
23160: LIST
23161: LIST
23162: IN
23163: IFFALSE 23184
// points := [ 40 , 10 , 20 ] ;
23165: LD_ADDR_VAR 0 9
23169: PUSH
23170: LD_INT 40
23172: PUSH
23173: LD_INT 10
23175: PUSH
23176: LD_INT 20
23178: PUSH
23179: EMPTY
23180: LIST
23181: LIST
23182: LIST
23183: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23184: LD_VAR 0 6
23188: PPUSH
23189: CALL_OW 264
23193: PUSH
23194: LD_INT 9
23196: PUSH
23197: EMPTY
23198: LIST
23199: IN
23200: IFFALSE 23221
// points := [ 5 , 70 , 20 ] ;
23202: LD_ADDR_VAR 0 9
23206: PUSH
23207: LD_INT 5
23209: PUSH
23210: LD_INT 70
23212: PUSH
23213: LD_INT 20
23215: PUSH
23216: EMPTY
23217: LIST
23218: LIST
23219: LIST
23220: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23221: LD_VAR 0 6
23225: PPUSH
23226: CALL_OW 264
23230: PUSH
23231: LD_INT 10
23233: PUSH
23234: EMPTY
23235: LIST
23236: IN
23237: IFFALSE 23258
// points := [ 35 , 110 , 70 ] ;
23239: LD_ADDR_VAR 0 9
23243: PUSH
23244: LD_INT 35
23246: PUSH
23247: LD_INT 110
23249: PUSH
23250: LD_INT 70
23252: PUSH
23253: EMPTY
23254: LIST
23255: LIST
23256: LIST
23257: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23258: LD_VAR 0 6
23262: PPUSH
23263: CALL_OW 265
23267: PUSH
23268: LD_INT 25
23270: EQUAL
23271: IFFALSE 23292
// points := [ 80 , 65 , 100 ] ;
23273: LD_ADDR_VAR 0 9
23277: PUSH
23278: LD_INT 80
23280: PUSH
23281: LD_INT 65
23283: PUSH
23284: LD_INT 100
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: LIST
23291: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23292: LD_VAR 0 6
23296: PPUSH
23297: CALL_OW 263
23301: PUSH
23302: LD_INT 1
23304: EQUAL
23305: IFFALSE 23340
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23307: LD_ADDR_VAR 0 10
23311: PUSH
23312: LD_VAR 0 10
23316: PUSH
23317: LD_VAR 0 6
23321: PPUSH
23322: CALL_OW 311
23326: PPUSH
23327: LD_INT 3
23329: PPUSH
23330: CALL_OW 259
23334: PUSH
23335: LD_INT 4
23337: MUL
23338: MUL
23339: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23340: LD_VAR 0 6
23344: PPUSH
23345: CALL_OW 263
23349: PUSH
23350: LD_INT 2
23352: EQUAL
23353: IFFALSE 23404
// begin j := IsControledBy ( i ) ;
23355: LD_ADDR_VAR 0 7
23359: PUSH
23360: LD_VAR 0 6
23364: PPUSH
23365: CALL_OW 312
23369: ST_TO_ADDR
// if j then
23370: LD_VAR 0 7
23374: IFFALSE 23404
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23376: LD_ADDR_VAR 0 10
23380: PUSH
23381: LD_VAR 0 10
23385: PUSH
23386: LD_VAR 0 7
23390: PPUSH
23391: LD_INT 3
23393: PPUSH
23394: CALL_OW 259
23398: PUSH
23399: LD_INT 3
23401: MUL
23402: MUL
23403: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23404: LD_VAR 0 6
23408: PPUSH
23409: CALL_OW 264
23413: PUSH
23414: LD_INT 5
23416: PUSH
23417: LD_INT 6
23419: PUSH
23420: LD_INT 46
23422: PUSH
23423: LD_INT 44
23425: PUSH
23426: LD_INT 47
23428: PUSH
23429: LD_INT 45
23431: PUSH
23432: LD_INT 28
23434: PUSH
23435: LD_INT 7
23437: PUSH
23438: LD_INT 27
23440: PUSH
23441: LD_INT 29
23443: PUSH
23444: EMPTY
23445: LIST
23446: LIST
23447: LIST
23448: LIST
23449: LIST
23450: LIST
23451: LIST
23452: LIST
23453: LIST
23454: LIST
23455: IN
23456: PUSH
23457: LD_VAR 0 1
23461: PPUSH
23462: LD_INT 52
23464: PPUSH
23465: CALL_OW 321
23469: PUSH
23470: LD_INT 2
23472: EQUAL
23473: AND
23474: IFFALSE 23491
// bpoints := bpoints * 1.2 ;
23476: LD_ADDR_VAR 0 10
23480: PUSH
23481: LD_VAR 0 10
23485: PUSH
23486: LD_REAL  1.20000000000000E+0000
23489: MUL
23490: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23491: LD_VAR 0 6
23495: PPUSH
23496: CALL_OW 264
23500: PUSH
23501: LD_INT 6
23503: PUSH
23504: LD_INT 46
23506: PUSH
23507: LD_INT 47
23509: PUSH
23510: EMPTY
23511: LIST
23512: LIST
23513: LIST
23514: IN
23515: IFFALSE 23532
// bpoints := bpoints * 1.2 ;
23517: LD_ADDR_VAR 0 10
23521: PUSH
23522: LD_VAR 0 10
23526: PUSH
23527: LD_REAL  1.20000000000000E+0000
23530: MUL
23531: ST_TO_ADDR
// end ; unit_building :
23532: GO 23546
23534: LD_INT 3
23536: DOUBLE
23537: EQUAL
23538: IFTRUE 23542
23540: GO 23545
23542: POP
// ; end ;
23543: GO 23546
23545: POP
// for j = 1 to 3 do
23546: LD_ADDR_VAR 0 7
23550: PUSH
23551: DOUBLE
23552: LD_INT 1
23554: DEC
23555: ST_TO_ADDR
23556: LD_INT 3
23558: PUSH
23559: FOR_TO
23560: IFFALSE 23613
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23562: LD_ADDR_VAR 0 5
23566: PUSH
23567: LD_VAR 0 5
23571: PPUSH
23572: LD_VAR 0 7
23576: PPUSH
23577: LD_VAR 0 5
23581: PUSH
23582: LD_VAR 0 7
23586: ARRAY
23587: PUSH
23588: LD_VAR 0 9
23592: PUSH
23593: LD_VAR 0 7
23597: ARRAY
23598: PUSH
23599: LD_VAR 0 10
23603: MUL
23604: PLUS
23605: PPUSH
23606: CALL_OW 1
23610: ST_TO_ADDR
23611: GO 23559
23613: POP
23614: POP
// end ;
23615: GO 22098
23617: POP
23618: POP
// result := Replace ( result , 4 , tmp ) ;
23619: LD_ADDR_VAR 0 5
23623: PUSH
23624: LD_VAR 0 5
23628: PPUSH
23629: LD_INT 4
23631: PPUSH
23632: LD_VAR 0 8
23636: PPUSH
23637: CALL_OW 1
23641: ST_TO_ADDR
// end ;
23642: LD_VAR 0 5
23646: RET
// export function DangerAtRange ( unit , range ) ; begin
23647: LD_INT 0
23649: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23650: LD_ADDR_VAR 0 3
23654: PUSH
23655: LD_VAR 0 1
23659: PPUSH
23660: CALL_OW 255
23664: PPUSH
23665: LD_VAR 0 1
23669: PPUSH
23670: CALL_OW 250
23674: PPUSH
23675: LD_VAR 0 1
23679: PPUSH
23680: CALL_OW 251
23684: PPUSH
23685: LD_VAR 0 2
23689: PPUSH
23690: CALL 21950 0 4
23694: ST_TO_ADDR
// end ;
23695: LD_VAR 0 3
23699: RET
// export function DangerInArea ( side , area ) ; begin
23700: LD_INT 0
23702: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23703: LD_ADDR_VAR 0 3
23707: PUSH
23708: LD_VAR 0 2
23712: PPUSH
23713: LD_INT 81
23715: PUSH
23716: LD_VAR 0 1
23720: PUSH
23721: EMPTY
23722: LIST
23723: LIST
23724: PPUSH
23725: CALL_OW 70
23729: ST_TO_ADDR
// end ;
23730: LD_VAR 0 3
23734: RET
// export function IsExtension ( b ) ; begin
23735: LD_INT 0
23737: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23738: LD_ADDR_VAR 0 2
23742: PUSH
23743: LD_VAR 0 1
23747: PUSH
23748: LD_INT 23
23750: PUSH
23751: LD_INT 20
23753: PUSH
23754: LD_INT 22
23756: PUSH
23757: LD_INT 17
23759: PUSH
23760: LD_INT 24
23762: PUSH
23763: LD_INT 21
23765: PUSH
23766: LD_INT 19
23768: PUSH
23769: LD_INT 16
23771: PUSH
23772: LD_INT 25
23774: PUSH
23775: LD_INT 18
23777: PUSH
23778: EMPTY
23779: LIST
23780: LIST
23781: LIST
23782: LIST
23783: LIST
23784: LIST
23785: LIST
23786: LIST
23787: LIST
23788: LIST
23789: IN
23790: ST_TO_ADDR
// end ;
23791: LD_VAR 0 2
23795: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
23796: LD_INT 0
23798: PPUSH
23799: PPUSH
23800: PPUSH
// result := [ ] ;
23801: LD_ADDR_VAR 0 3
23805: PUSH
23806: EMPTY
23807: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23808: LD_ADDR_VAR 0 4
23812: PUSH
23813: LD_VAR 0 2
23817: PPUSH
23818: LD_INT 21
23820: PUSH
23821: LD_INT 3
23823: PUSH
23824: EMPTY
23825: LIST
23826: LIST
23827: PPUSH
23828: CALL_OW 70
23832: ST_TO_ADDR
// if not tmp then
23833: LD_VAR 0 4
23837: NOT
23838: IFFALSE 23842
// exit ;
23840: GO 23900
// for i in tmp do
23842: LD_ADDR_VAR 0 5
23846: PUSH
23847: LD_VAR 0 4
23851: PUSH
23852: FOR_IN
23853: IFFALSE 23888
// if GetBase ( i ) <> base then
23855: LD_VAR 0 5
23859: PPUSH
23860: CALL_OW 274
23864: PUSH
23865: LD_VAR 0 1
23869: NONEQUAL
23870: IFFALSE 23886
// ComLinkToBase ( base , i ) ;
23872: LD_VAR 0 1
23876: PPUSH
23877: LD_VAR 0 5
23881: PPUSH
23882: CALL_OW 169
23886: GO 23852
23888: POP
23889: POP
// result := tmp ;
23890: LD_ADDR_VAR 0 3
23894: PUSH
23895: LD_VAR 0 4
23899: ST_TO_ADDR
// end ;
23900: LD_VAR 0 3
23904: RET
// export function ComComplete ( unit , b ) ; var i ; begin
23905: LD_INT 0
23907: PPUSH
23908: PPUSH
// if BuildingStatus ( b ) = bs_build then
23909: LD_VAR 0 2
23913: PPUSH
23914: CALL_OW 461
23918: PUSH
23919: LD_INT 1
23921: EQUAL
23922: IFFALSE 23982
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23924: LD_VAR 0 1
23928: PPUSH
23929: LD_STRING h
23931: PUSH
23932: LD_VAR 0 2
23936: PPUSH
23937: CALL_OW 250
23941: PUSH
23942: LD_VAR 0 2
23946: PPUSH
23947: CALL_OW 251
23951: PUSH
23952: LD_VAR 0 2
23956: PUSH
23957: LD_INT 0
23959: PUSH
23960: LD_INT 0
23962: PUSH
23963: LD_INT 0
23965: PUSH
23966: EMPTY
23967: LIST
23968: LIST
23969: LIST
23970: LIST
23971: LIST
23972: LIST
23973: LIST
23974: PUSH
23975: EMPTY
23976: LIST
23977: PPUSH
23978: CALL_OW 446
// end ;
23982: LD_VAR 0 3
23986: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23987: LD_INT 0
23989: PPUSH
23990: PPUSH
23991: PPUSH
23992: PPUSH
23993: PPUSH
23994: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
23995: LD_VAR 0 1
23999: NOT
24000: PUSH
24001: LD_VAR 0 1
24005: PPUSH
24006: CALL_OW 263
24010: PUSH
24011: LD_INT 2
24013: EQUAL
24014: NOT
24015: OR
24016: IFFALSE 24020
// exit ;
24018: GO 24336
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24020: LD_ADDR_VAR 0 6
24024: PUSH
24025: LD_INT 22
24027: PUSH
24028: LD_VAR 0 1
24032: PPUSH
24033: CALL_OW 255
24037: PUSH
24038: EMPTY
24039: LIST
24040: LIST
24041: PUSH
24042: LD_INT 2
24044: PUSH
24045: LD_INT 30
24047: PUSH
24048: LD_INT 36
24050: PUSH
24051: EMPTY
24052: LIST
24053: LIST
24054: PUSH
24055: LD_INT 34
24057: PUSH
24058: LD_INT 31
24060: PUSH
24061: EMPTY
24062: LIST
24063: LIST
24064: PUSH
24065: EMPTY
24066: LIST
24067: LIST
24068: LIST
24069: PUSH
24070: EMPTY
24071: LIST
24072: LIST
24073: PPUSH
24074: CALL_OW 69
24078: ST_TO_ADDR
// if not tmp then
24079: LD_VAR 0 6
24083: NOT
24084: IFFALSE 24088
// exit ;
24086: GO 24336
// result := [ ] ;
24088: LD_ADDR_VAR 0 2
24092: PUSH
24093: EMPTY
24094: ST_TO_ADDR
// for i in tmp do
24095: LD_ADDR_VAR 0 3
24099: PUSH
24100: LD_VAR 0 6
24104: PUSH
24105: FOR_IN
24106: IFFALSE 24177
// begin t := UnitsInside ( i ) ;
24108: LD_ADDR_VAR 0 4
24112: PUSH
24113: LD_VAR 0 3
24117: PPUSH
24118: CALL_OW 313
24122: ST_TO_ADDR
// if t then
24123: LD_VAR 0 4
24127: IFFALSE 24175
// for j in t do
24129: LD_ADDR_VAR 0 7
24133: PUSH
24134: LD_VAR 0 4
24138: PUSH
24139: FOR_IN
24140: IFFALSE 24173
// result := Insert ( result , result + 1 , j ) ;
24142: LD_ADDR_VAR 0 2
24146: PUSH
24147: LD_VAR 0 2
24151: PPUSH
24152: LD_VAR 0 2
24156: PUSH
24157: LD_INT 1
24159: PLUS
24160: PPUSH
24161: LD_VAR 0 7
24165: PPUSH
24166: CALL_OW 2
24170: ST_TO_ADDR
24171: GO 24139
24173: POP
24174: POP
// end ;
24175: GO 24105
24177: POP
24178: POP
// if not result then
24179: LD_VAR 0 2
24183: NOT
24184: IFFALSE 24188
// exit ;
24186: GO 24336
// mech := result [ 1 ] ;
24188: LD_ADDR_VAR 0 5
24192: PUSH
24193: LD_VAR 0 2
24197: PUSH
24198: LD_INT 1
24200: ARRAY
24201: ST_TO_ADDR
// if result > 1 then
24202: LD_VAR 0 2
24206: PUSH
24207: LD_INT 1
24209: GREATER
24210: IFFALSE 24322
// for i = 2 to result do
24212: LD_ADDR_VAR 0 3
24216: PUSH
24217: DOUBLE
24218: LD_INT 2
24220: DEC
24221: ST_TO_ADDR
24222: LD_VAR 0 2
24226: PUSH
24227: FOR_TO
24228: IFFALSE 24320
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24230: LD_ADDR_VAR 0 4
24234: PUSH
24235: LD_VAR 0 2
24239: PUSH
24240: LD_VAR 0 3
24244: ARRAY
24245: PPUSH
24246: LD_INT 3
24248: PPUSH
24249: CALL_OW 259
24253: PUSH
24254: LD_VAR 0 2
24258: PUSH
24259: LD_VAR 0 3
24263: ARRAY
24264: PPUSH
24265: CALL_OW 432
24269: MINUS
24270: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24271: LD_VAR 0 4
24275: PUSH
24276: LD_VAR 0 5
24280: PPUSH
24281: LD_INT 3
24283: PPUSH
24284: CALL_OW 259
24288: PUSH
24289: LD_VAR 0 5
24293: PPUSH
24294: CALL_OW 432
24298: MINUS
24299: GREATEREQUAL
24300: IFFALSE 24318
// mech := result [ i ] ;
24302: LD_ADDR_VAR 0 5
24306: PUSH
24307: LD_VAR 0 2
24311: PUSH
24312: LD_VAR 0 3
24316: ARRAY
24317: ST_TO_ADDR
// end ;
24318: GO 24227
24320: POP
24321: POP
// ComLinkTo ( vehicle , mech ) ;
24322: LD_VAR 0 1
24326: PPUSH
24327: LD_VAR 0 5
24331: PPUSH
24332: CALL_OW 135
// end ;
24336: LD_VAR 0 2
24340: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24341: LD_INT 0
24343: PPUSH
24344: PPUSH
24345: PPUSH
24346: PPUSH
24347: PPUSH
24348: PPUSH
24349: PPUSH
24350: PPUSH
24351: PPUSH
24352: PPUSH
24353: PPUSH
24354: PPUSH
24355: PPUSH
// result := [ ] ;
24356: LD_ADDR_VAR 0 7
24360: PUSH
24361: EMPTY
24362: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24363: LD_VAR 0 1
24367: PPUSH
24368: CALL_OW 266
24372: PUSH
24373: LD_INT 0
24375: PUSH
24376: LD_INT 1
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: IN
24383: NOT
24384: IFFALSE 24388
// exit ;
24386: GO 26019
// if name then
24388: LD_VAR 0 3
24392: IFFALSE 24408
// SetBName ( base_dep , name ) ;
24394: LD_VAR 0 1
24398: PPUSH
24399: LD_VAR 0 3
24403: PPUSH
24404: CALL_OW 500
// base := GetBase ( base_dep ) ;
24408: LD_ADDR_VAR 0 15
24412: PUSH
24413: LD_VAR 0 1
24417: PPUSH
24418: CALL_OW 274
24422: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24423: LD_ADDR_VAR 0 16
24427: PUSH
24428: LD_VAR 0 1
24432: PPUSH
24433: CALL_OW 255
24437: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24438: LD_ADDR_VAR 0 17
24442: PUSH
24443: LD_VAR 0 1
24447: PPUSH
24448: CALL_OW 248
24452: ST_TO_ADDR
// if sources then
24453: LD_VAR 0 5
24457: IFFALSE 24504
// for i = 1 to 3 do
24459: LD_ADDR_VAR 0 8
24463: PUSH
24464: DOUBLE
24465: LD_INT 1
24467: DEC
24468: ST_TO_ADDR
24469: LD_INT 3
24471: PUSH
24472: FOR_TO
24473: IFFALSE 24502
// AddResourceType ( base , i , sources [ i ] ) ;
24475: LD_VAR 0 15
24479: PPUSH
24480: LD_VAR 0 8
24484: PPUSH
24485: LD_VAR 0 5
24489: PUSH
24490: LD_VAR 0 8
24494: ARRAY
24495: PPUSH
24496: CALL_OW 276
24500: GO 24472
24502: POP
24503: POP
// buildings := GetBaseBuildings ( base , area ) ;
24504: LD_ADDR_VAR 0 18
24508: PUSH
24509: LD_VAR 0 15
24513: PPUSH
24514: LD_VAR 0 2
24518: PPUSH
24519: CALL 23796 0 2
24523: ST_TO_ADDR
// InitHc ;
24524: CALL_OW 19
// InitUc ;
24528: CALL_OW 18
// uc_side := side ;
24532: LD_ADDR_OWVAR 20
24536: PUSH
24537: LD_VAR 0 16
24541: ST_TO_ADDR
// uc_nation := nation ;
24542: LD_ADDR_OWVAR 21
24546: PUSH
24547: LD_VAR 0 17
24551: ST_TO_ADDR
// if buildings then
24552: LD_VAR 0 18
24556: IFFALSE 25878
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24558: LD_ADDR_VAR 0 19
24562: PUSH
24563: LD_VAR 0 18
24567: PPUSH
24568: LD_INT 2
24570: PUSH
24571: LD_INT 30
24573: PUSH
24574: LD_INT 29
24576: PUSH
24577: EMPTY
24578: LIST
24579: LIST
24580: PUSH
24581: LD_INT 30
24583: PUSH
24584: LD_INT 30
24586: PUSH
24587: EMPTY
24588: LIST
24589: LIST
24590: PUSH
24591: EMPTY
24592: LIST
24593: LIST
24594: LIST
24595: PPUSH
24596: CALL_OW 72
24600: ST_TO_ADDR
// if tmp then
24601: LD_VAR 0 19
24605: IFFALSE 24653
// for i in tmp do
24607: LD_ADDR_VAR 0 8
24611: PUSH
24612: LD_VAR 0 19
24616: PUSH
24617: FOR_IN
24618: IFFALSE 24651
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24620: LD_VAR 0 8
24624: PPUSH
24625: CALL_OW 250
24629: PPUSH
24630: LD_VAR 0 8
24634: PPUSH
24635: CALL_OW 251
24639: PPUSH
24640: LD_VAR 0 16
24644: PPUSH
24645: CALL_OW 441
24649: GO 24617
24651: POP
24652: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24653: LD_VAR 0 18
24657: PPUSH
24658: LD_INT 2
24660: PUSH
24661: LD_INT 30
24663: PUSH
24664: LD_INT 32
24666: PUSH
24667: EMPTY
24668: LIST
24669: LIST
24670: PUSH
24671: LD_INT 30
24673: PUSH
24674: LD_INT 33
24676: PUSH
24677: EMPTY
24678: LIST
24679: LIST
24680: PUSH
24681: EMPTY
24682: LIST
24683: LIST
24684: LIST
24685: PPUSH
24686: CALL_OW 72
24690: IFFALSE 24778
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24692: LD_ADDR_VAR 0 8
24696: PUSH
24697: LD_VAR 0 18
24701: PPUSH
24702: LD_INT 2
24704: PUSH
24705: LD_INT 30
24707: PUSH
24708: LD_INT 32
24710: PUSH
24711: EMPTY
24712: LIST
24713: LIST
24714: PUSH
24715: LD_INT 30
24717: PUSH
24718: LD_INT 33
24720: PUSH
24721: EMPTY
24722: LIST
24723: LIST
24724: PUSH
24725: EMPTY
24726: LIST
24727: LIST
24728: LIST
24729: PPUSH
24730: CALL_OW 72
24734: PUSH
24735: FOR_IN
24736: IFFALSE 24776
// begin if not GetBWeapon ( i ) then
24738: LD_VAR 0 8
24742: PPUSH
24743: CALL_OW 269
24747: NOT
24748: IFFALSE 24774
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24750: LD_VAR 0 8
24754: PPUSH
24755: LD_VAR 0 8
24759: PPUSH
24760: LD_VAR 0 2
24764: PPUSH
24765: CALL 26024 0 2
24769: PPUSH
24770: CALL_OW 431
// end ;
24774: GO 24735
24776: POP
24777: POP
// end ; for i = 1 to personel do
24778: LD_ADDR_VAR 0 8
24782: PUSH
24783: DOUBLE
24784: LD_INT 1
24786: DEC
24787: ST_TO_ADDR
24788: LD_VAR 0 6
24792: PUSH
24793: FOR_TO
24794: IFFALSE 25858
// begin if i > 4 then
24796: LD_VAR 0 8
24800: PUSH
24801: LD_INT 4
24803: GREATER
24804: IFFALSE 24808
// break ;
24806: GO 25858
// case i of 1 :
24808: LD_VAR 0 8
24812: PUSH
24813: LD_INT 1
24815: DOUBLE
24816: EQUAL
24817: IFTRUE 24821
24819: GO 24901
24821: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24822: LD_ADDR_VAR 0 12
24826: PUSH
24827: LD_VAR 0 18
24831: PPUSH
24832: LD_INT 22
24834: PUSH
24835: LD_VAR 0 16
24839: PUSH
24840: EMPTY
24841: LIST
24842: LIST
24843: PUSH
24844: LD_INT 58
24846: PUSH
24847: EMPTY
24848: LIST
24849: PUSH
24850: LD_INT 2
24852: PUSH
24853: LD_INT 30
24855: PUSH
24856: LD_INT 32
24858: PUSH
24859: EMPTY
24860: LIST
24861: LIST
24862: PUSH
24863: LD_INT 30
24865: PUSH
24866: LD_INT 4
24868: PUSH
24869: EMPTY
24870: LIST
24871: LIST
24872: PUSH
24873: LD_INT 30
24875: PUSH
24876: LD_INT 5
24878: PUSH
24879: EMPTY
24880: LIST
24881: LIST
24882: PUSH
24883: EMPTY
24884: LIST
24885: LIST
24886: LIST
24887: LIST
24888: PUSH
24889: EMPTY
24890: LIST
24891: LIST
24892: LIST
24893: PPUSH
24894: CALL_OW 72
24898: ST_TO_ADDR
24899: GO 25123
24901: LD_INT 2
24903: DOUBLE
24904: EQUAL
24905: IFTRUE 24909
24907: GO 24971
24909: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24910: LD_ADDR_VAR 0 12
24914: PUSH
24915: LD_VAR 0 18
24919: PPUSH
24920: LD_INT 22
24922: PUSH
24923: LD_VAR 0 16
24927: PUSH
24928: EMPTY
24929: LIST
24930: LIST
24931: PUSH
24932: LD_INT 2
24934: PUSH
24935: LD_INT 30
24937: PUSH
24938: LD_INT 0
24940: PUSH
24941: EMPTY
24942: LIST
24943: LIST
24944: PUSH
24945: LD_INT 30
24947: PUSH
24948: LD_INT 1
24950: PUSH
24951: EMPTY
24952: LIST
24953: LIST
24954: PUSH
24955: EMPTY
24956: LIST
24957: LIST
24958: LIST
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PPUSH
24964: CALL_OW 72
24968: ST_TO_ADDR
24969: GO 25123
24971: LD_INT 3
24973: DOUBLE
24974: EQUAL
24975: IFTRUE 24979
24977: GO 25041
24979: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24980: LD_ADDR_VAR 0 12
24984: PUSH
24985: LD_VAR 0 18
24989: PPUSH
24990: LD_INT 22
24992: PUSH
24993: LD_VAR 0 16
24997: PUSH
24998: EMPTY
24999: LIST
25000: LIST
25001: PUSH
25002: LD_INT 2
25004: PUSH
25005: LD_INT 30
25007: PUSH
25008: LD_INT 2
25010: PUSH
25011: EMPTY
25012: LIST
25013: LIST
25014: PUSH
25015: LD_INT 30
25017: PUSH
25018: LD_INT 3
25020: PUSH
25021: EMPTY
25022: LIST
25023: LIST
25024: PUSH
25025: EMPTY
25026: LIST
25027: LIST
25028: LIST
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: PPUSH
25034: CALL_OW 72
25038: ST_TO_ADDR
25039: GO 25123
25041: LD_INT 4
25043: DOUBLE
25044: EQUAL
25045: IFTRUE 25049
25047: GO 25122
25049: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25050: LD_ADDR_VAR 0 12
25054: PUSH
25055: LD_VAR 0 18
25059: PPUSH
25060: LD_INT 22
25062: PUSH
25063: LD_VAR 0 16
25067: PUSH
25068: EMPTY
25069: LIST
25070: LIST
25071: PUSH
25072: LD_INT 2
25074: PUSH
25075: LD_INT 30
25077: PUSH
25078: LD_INT 6
25080: PUSH
25081: EMPTY
25082: LIST
25083: LIST
25084: PUSH
25085: LD_INT 30
25087: PUSH
25088: LD_INT 7
25090: PUSH
25091: EMPTY
25092: LIST
25093: LIST
25094: PUSH
25095: LD_INT 30
25097: PUSH
25098: LD_INT 8
25100: PUSH
25101: EMPTY
25102: LIST
25103: LIST
25104: PUSH
25105: EMPTY
25106: LIST
25107: LIST
25108: LIST
25109: LIST
25110: PUSH
25111: EMPTY
25112: LIST
25113: LIST
25114: PPUSH
25115: CALL_OW 72
25119: ST_TO_ADDR
25120: GO 25123
25122: POP
// if i = 1 then
25123: LD_VAR 0 8
25127: PUSH
25128: LD_INT 1
25130: EQUAL
25131: IFFALSE 25242
// begin tmp := [ ] ;
25133: LD_ADDR_VAR 0 19
25137: PUSH
25138: EMPTY
25139: ST_TO_ADDR
// for j in f do
25140: LD_ADDR_VAR 0 9
25144: PUSH
25145: LD_VAR 0 12
25149: PUSH
25150: FOR_IN
25151: IFFALSE 25224
// if GetBType ( j ) = b_bunker then
25153: LD_VAR 0 9
25157: PPUSH
25158: CALL_OW 266
25162: PUSH
25163: LD_INT 32
25165: EQUAL
25166: IFFALSE 25193
// tmp := Insert ( tmp , 1 , j ) else
25168: LD_ADDR_VAR 0 19
25172: PUSH
25173: LD_VAR 0 19
25177: PPUSH
25178: LD_INT 1
25180: PPUSH
25181: LD_VAR 0 9
25185: PPUSH
25186: CALL_OW 2
25190: ST_TO_ADDR
25191: GO 25222
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25193: LD_ADDR_VAR 0 19
25197: PUSH
25198: LD_VAR 0 19
25202: PPUSH
25203: LD_VAR 0 19
25207: PUSH
25208: LD_INT 1
25210: PLUS
25211: PPUSH
25212: LD_VAR 0 9
25216: PPUSH
25217: CALL_OW 2
25221: ST_TO_ADDR
25222: GO 25150
25224: POP
25225: POP
// if tmp then
25226: LD_VAR 0 19
25230: IFFALSE 25242
// f := tmp ;
25232: LD_ADDR_VAR 0 12
25236: PUSH
25237: LD_VAR 0 19
25241: ST_TO_ADDR
// end ; x := personel [ i ] ;
25242: LD_ADDR_VAR 0 13
25246: PUSH
25247: LD_VAR 0 6
25251: PUSH
25252: LD_VAR 0 8
25256: ARRAY
25257: ST_TO_ADDR
// if x = - 1 then
25258: LD_VAR 0 13
25262: PUSH
25263: LD_INT 1
25265: NEG
25266: EQUAL
25267: IFFALSE 25476
// begin for j in f do
25269: LD_ADDR_VAR 0 9
25273: PUSH
25274: LD_VAR 0 12
25278: PUSH
25279: FOR_IN
25280: IFFALSE 25472
// repeat InitHc ;
25282: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25286: LD_VAR 0 9
25290: PPUSH
25291: CALL_OW 266
25295: PUSH
25296: LD_INT 5
25298: EQUAL
25299: IFFALSE 25369
// begin if UnitsInside ( j ) < 3 then
25301: LD_VAR 0 9
25305: PPUSH
25306: CALL_OW 313
25310: PUSH
25311: LD_INT 3
25313: LESS
25314: IFFALSE 25350
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25316: LD_INT 0
25318: PPUSH
25319: LD_INT 5
25321: PUSH
25322: LD_INT 8
25324: PUSH
25325: LD_INT 9
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: LIST
25332: PUSH
25333: LD_VAR 0 17
25337: ARRAY
25338: PPUSH
25339: LD_VAR 0 4
25343: PPUSH
25344: CALL_OW 380
25348: GO 25367
// PrepareHuman ( false , i , skill ) ;
25350: LD_INT 0
25352: PPUSH
25353: LD_VAR 0 8
25357: PPUSH
25358: LD_VAR 0 4
25362: PPUSH
25363: CALL_OW 380
// end else
25367: GO 25386
// PrepareHuman ( false , i , skill ) ;
25369: LD_INT 0
25371: PPUSH
25372: LD_VAR 0 8
25376: PPUSH
25377: LD_VAR 0 4
25381: PPUSH
25382: CALL_OW 380
// un := CreateHuman ;
25386: LD_ADDR_VAR 0 14
25390: PUSH
25391: CALL_OW 44
25395: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25396: LD_ADDR_VAR 0 7
25400: PUSH
25401: LD_VAR 0 7
25405: PPUSH
25406: LD_INT 1
25408: PPUSH
25409: LD_VAR 0 14
25413: PPUSH
25414: CALL_OW 2
25418: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25419: LD_VAR 0 14
25423: PPUSH
25424: LD_VAR 0 9
25428: PPUSH
25429: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25433: LD_VAR 0 9
25437: PPUSH
25438: CALL_OW 313
25442: PUSH
25443: LD_INT 6
25445: EQUAL
25446: PUSH
25447: LD_VAR 0 9
25451: PPUSH
25452: CALL_OW 266
25456: PUSH
25457: LD_INT 32
25459: PUSH
25460: LD_INT 31
25462: PUSH
25463: EMPTY
25464: LIST
25465: LIST
25466: IN
25467: OR
25468: IFFALSE 25282
25470: GO 25279
25472: POP
25473: POP
// end else
25474: GO 25856
// for j = 1 to x do
25476: LD_ADDR_VAR 0 9
25480: PUSH
25481: DOUBLE
25482: LD_INT 1
25484: DEC
25485: ST_TO_ADDR
25486: LD_VAR 0 13
25490: PUSH
25491: FOR_TO
25492: IFFALSE 25854
// begin InitHc ;
25494: CALL_OW 19
// if not f then
25498: LD_VAR 0 12
25502: NOT
25503: IFFALSE 25592
// begin PrepareHuman ( false , i , skill ) ;
25505: LD_INT 0
25507: PPUSH
25508: LD_VAR 0 8
25512: PPUSH
25513: LD_VAR 0 4
25517: PPUSH
25518: CALL_OW 380
// un := CreateHuman ;
25522: LD_ADDR_VAR 0 14
25526: PUSH
25527: CALL_OW 44
25531: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25532: LD_ADDR_VAR 0 7
25536: PUSH
25537: LD_VAR 0 7
25541: PPUSH
25542: LD_INT 1
25544: PPUSH
25545: LD_VAR 0 14
25549: PPUSH
25550: CALL_OW 2
25554: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25555: LD_VAR 0 14
25559: PPUSH
25560: LD_VAR 0 1
25564: PPUSH
25565: CALL_OW 250
25569: PPUSH
25570: LD_VAR 0 1
25574: PPUSH
25575: CALL_OW 251
25579: PPUSH
25580: LD_INT 10
25582: PPUSH
25583: LD_INT 0
25585: PPUSH
25586: CALL_OW 50
// continue ;
25590: GO 25491
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25592: LD_VAR 0 12
25596: PUSH
25597: LD_INT 1
25599: ARRAY
25600: PPUSH
25601: CALL_OW 313
25605: PUSH
25606: LD_VAR 0 12
25610: PUSH
25611: LD_INT 1
25613: ARRAY
25614: PPUSH
25615: CALL_OW 266
25619: PUSH
25620: LD_INT 32
25622: PUSH
25623: LD_INT 31
25625: PUSH
25626: EMPTY
25627: LIST
25628: LIST
25629: IN
25630: AND
25631: PUSH
25632: LD_VAR 0 12
25636: PUSH
25637: LD_INT 1
25639: ARRAY
25640: PPUSH
25641: CALL_OW 313
25645: PUSH
25646: LD_INT 6
25648: EQUAL
25649: OR
25650: IFFALSE 25670
// f := Delete ( f , 1 ) ;
25652: LD_ADDR_VAR 0 12
25656: PUSH
25657: LD_VAR 0 12
25661: PPUSH
25662: LD_INT 1
25664: PPUSH
25665: CALL_OW 3
25669: ST_TO_ADDR
// if not f then
25670: LD_VAR 0 12
25674: NOT
25675: IFFALSE 25693
// begin x := x + 2 ;
25677: LD_ADDR_VAR 0 13
25681: PUSH
25682: LD_VAR 0 13
25686: PUSH
25687: LD_INT 2
25689: PLUS
25690: ST_TO_ADDR
// continue ;
25691: GO 25491
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25693: LD_VAR 0 12
25697: PUSH
25698: LD_INT 1
25700: ARRAY
25701: PPUSH
25702: CALL_OW 266
25706: PUSH
25707: LD_INT 5
25709: EQUAL
25710: IFFALSE 25784
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25712: LD_VAR 0 12
25716: PUSH
25717: LD_INT 1
25719: ARRAY
25720: PPUSH
25721: CALL_OW 313
25725: PUSH
25726: LD_INT 3
25728: LESS
25729: IFFALSE 25765
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25731: LD_INT 0
25733: PPUSH
25734: LD_INT 5
25736: PUSH
25737: LD_INT 8
25739: PUSH
25740: LD_INT 9
25742: PUSH
25743: EMPTY
25744: LIST
25745: LIST
25746: LIST
25747: PUSH
25748: LD_VAR 0 17
25752: ARRAY
25753: PPUSH
25754: LD_VAR 0 4
25758: PPUSH
25759: CALL_OW 380
25763: GO 25782
// PrepareHuman ( false , i , skill ) ;
25765: LD_INT 0
25767: PPUSH
25768: LD_VAR 0 8
25772: PPUSH
25773: LD_VAR 0 4
25777: PPUSH
25778: CALL_OW 380
// end else
25782: GO 25801
// PrepareHuman ( false , i , skill ) ;
25784: LD_INT 0
25786: PPUSH
25787: LD_VAR 0 8
25791: PPUSH
25792: LD_VAR 0 4
25796: PPUSH
25797: CALL_OW 380
// un := CreateHuman ;
25801: LD_ADDR_VAR 0 14
25805: PUSH
25806: CALL_OW 44
25810: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25811: LD_ADDR_VAR 0 7
25815: PUSH
25816: LD_VAR 0 7
25820: PPUSH
25821: LD_INT 1
25823: PPUSH
25824: LD_VAR 0 14
25828: PPUSH
25829: CALL_OW 2
25833: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25834: LD_VAR 0 14
25838: PPUSH
25839: LD_VAR 0 12
25843: PUSH
25844: LD_INT 1
25846: ARRAY
25847: PPUSH
25848: CALL_OW 52
// end ;
25852: GO 25491
25854: POP
25855: POP
// end ;
25856: GO 24793
25858: POP
25859: POP
// result := result ^ buildings ;
25860: LD_ADDR_VAR 0 7
25864: PUSH
25865: LD_VAR 0 7
25869: PUSH
25870: LD_VAR 0 18
25874: ADD
25875: ST_TO_ADDR
// end else
25876: GO 26019
// begin for i = 1 to personel do
25878: LD_ADDR_VAR 0 8
25882: PUSH
25883: DOUBLE
25884: LD_INT 1
25886: DEC
25887: ST_TO_ADDR
25888: LD_VAR 0 6
25892: PUSH
25893: FOR_TO
25894: IFFALSE 26017
// begin if i > 4 then
25896: LD_VAR 0 8
25900: PUSH
25901: LD_INT 4
25903: GREATER
25904: IFFALSE 25908
// break ;
25906: GO 26017
// x := personel [ i ] ;
25908: LD_ADDR_VAR 0 13
25912: PUSH
25913: LD_VAR 0 6
25917: PUSH
25918: LD_VAR 0 8
25922: ARRAY
25923: ST_TO_ADDR
// if x = - 1 then
25924: LD_VAR 0 13
25928: PUSH
25929: LD_INT 1
25931: NEG
25932: EQUAL
25933: IFFALSE 25937
// continue ;
25935: GO 25893
// PrepareHuman ( false , i , skill ) ;
25937: LD_INT 0
25939: PPUSH
25940: LD_VAR 0 8
25944: PPUSH
25945: LD_VAR 0 4
25949: PPUSH
25950: CALL_OW 380
// un := CreateHuman ;
25954: LD_ADDR_VAR 0 14
25958: PUSH
25959: CALL_OW 44
25963: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25964: LD_VAR 0 14
25968: PPUSH
25969: LD_VAR 0 1
25973: PPUSH
25974: CALL_OW 250
25978: PPUSH
25979: LD_VAR 0 1
25983: PPUSH
25984: CALL_OW 251
25988: PPUSH
25989: LD_INT 10
25991: PPUSH
25992: LD_INT 0
25994: PPUSH
25995: CALL_OW 50
// result := result ^ un ;
25999: LD_ADDR_VAR 0 7
26003: PUSH
26004: LD_VAR 0 7
26008: PUSH
26009: LD_VAR 0 14
26013: ADD
26014: ST_TO_ADDR
// end ;
26015: GO 25893
26017: POP
26018: POP
// end ; end ;
26019: LD_VAR 0 7
26023: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26024: LD_INT 0
26026: PPUSH
26027: PPUSH
26028: PPUSH
26029: PPUSH
26030: PPUSH
26031: PPUSH
26032: PPUSH
26033: PPUSH
26034: PPUSH
26035: PPUSH
26036: PPUSH
26037: PPUSH
26038: PPUSH
26039: PPUSH
26040: PPUSH
26041: PPUSH
// result := false ;
26042: LD_ADDR_VAR 0 3
26046: PUSH
26047: LD_INT 0
26049: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26050: LD_VAR 0 1
26054: NOT
26055: PUSH
26056: LD_VAR 0 1
26060: PPUSH
26061: CALL_OW 266
26065: PUSH
26066: LD_INT 32
26068: PUSH
26069: LD_INT 33
26071: PUSH
26072: EMPTY
26073: LIST
26074: LIST
26075: IN
26076: NOT
26077: OR
26078: IFFALSE 26082
// exit ;
26080: GO 27218
// nat := GetNation ( tower ) ;
26082: LD_ADDR_VAR 0 12
26086: PUSH
26087: LD_VAR 0 1
26091: PPUSH
26092: CALL_OW 248
26096: ST_TO_ADDR
// side := GetSide ( tower ) ;
26097: LD_ADDR_VAR 0 16
26101: PUSH
26102: LD_VAR 0 1
26106: PPUSH
26107: CALL_OW 255
26111: ST_TO_ADDR
// x := GetX ( tower ) ;
26112: LD_ADDR_VAR 0 10
26116: PUSH
26117: LD_VAR 0 1
26121: PPUSH
26122: CALL_OW 250
26126: ST_TO_ADDR
// y := GetY ( tower ) ;
26127: LD_ADDR_VAR 0 11
26131: PUSH
26132: LD_VAR 0 1
26136: PPUSH
26137: CALL_OW 251
26141: ST_TO_ADDR
// if not x or not y then
26142: LD_VAR 0 10
26146: NOT
26147: PUSH
26148: LD_VAR 0 11
26152: NOT
26153: OR
26154: IFFALSE 26158
// exit ;
26156: GO 27218
// weapon := 0 ;
26158: LD_ADDR_VAR 0 18
26162: PUSH
26163: LD_INT 0
26165: ST_TO_ADDR
// fac_list := [ ] ;
26166: LD_ADDR_VAR 0 17
26170: PUSH
26171: EMPTY
26172: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26173: LD_ADDR_VAR 0 6
26177: PUSH
26178: LD_VAR 0 1
26182: PPUSH
26183: CALL_OW 274
26187: PPUSH
26188: LD_VAR 0 2
26192: PPUSH
26193: CALL 23796 0 2
26197: PPUSH
26198: LD_INT 30
26200: PUSH
26201: LD_INT 3
26203: PUSH
26204: EMPTY
26205: LIST
26206: LIST
26207: PPUSH
26208: CALL_OW 72
26212: ST_TO_ADDR
// if not factories then
26213: LD_VAR 0 6
26217: NOT
26218: IFFALSE 26222
// exit ;
26220: GO 27218
// for i in factories do
26222: LD_ADDR_VAR 0 8
26226: PUSH
26227: LD_VAR 0 6
26231: PUSH
26232: FOR_IN
26233: IFFALSE 26258
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26235: LD_ADDR_VAR 0 17
26239: PUSH
26240: LD_VAR 0 17
26244: PUSH
26245: LD_VAR 0 8
26249: PPUSH
26250: CALL_OW 478
26254: UNION
26255: ST_TO_ADDR
26256: GO 26232
26258: POP
26259: POP
// if not fac_list then
26260: LD_VAR 0 17
26264: NOT
26265: IFFALSE 26269
// exit ;
26267: GO 27218
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26269: LD_ADDR_VAR 0 5
26273: PUSH
26274: LD_INT 4
26276: PUSH
26277: LD_INT 5
26279: PUSH
26280: LD_INT 9
26282: PUSH
26283: LD_INT 10
26285: PUSH
26286: LD_INT 6
26288: PUSH
26289: LD_INT 7
26291: PUSH
26292: LD_INT 11
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: LIST
26299: LIST
26300: LIST
26301: LIST
26302: LIST
26303: PUSH
26304: LD_INT 27
26306: PUSH
26307: LD_INT 28
26309: PUSH
26310: LD_INT 26
26312: PUSH
26313: LD_INT 30
26315: PUSH
26316: EMPTY
26317: LIST
26318: LIST
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 43
26324: PUSH
26325: LD_INT 44
26327: PUSH
26328: LD_INT 46
26330: PUSH
26331: LD_INT 45
26333: PUSH
26334: LD_INT 47
26336: PUSH
26337: LD_INT 49
26339: PUSH
26340: EMPTY
26341: LIST
26342: LIST
26343: LIST
26344: LIST
26345: LIST
26346: LIST
26347: PUSH
26348: EMPTY
26349: LIST
26350: LIST
26351: LIST
26352: PUSH
26353: LD_VAR 0 12
26357: ARRAY
26358: ST_TO_ADDR
// for i in list do
26359: LD_ADDR_VAR 0 8
26363: PUSH
26364: LD_VAR 0 5
26368: PUSH
26369: FOR_IN
26370: IFFALSE 26403
// if not i in fac_list then
26372: LD_VAR 0 8
26376: PUSH
26377: LD_VAR 0 17
26381: IN
26382: NOT
26383: IFFALSE 26401
// list := list diff i ;
26385: LD_ADDR_VAR 0 5
26389: PUSH
26390: LD_VAR 0 5
26394: PUSH
26395: LD_VAR 0 8
26399: DIFF
26400: ST_TO_ADDR
26401: GO 26369
26403: POP
26404: POP
// if not list then
26405: LD_VAR 0 5
26409: NOT
26410: IFFALSE 26414
// exit ;
26412: GO 27218
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26414: LD_VAR 0 12
26418: PUSH
26419: LD_INT 3
26421: EQUAL
26422: PUSH
26423: LD_INT 49
26425: PUSH
26426: LD_VAR 0 5
26430: IN
26431: AND
26432: PUSH
26433: LD_INT 31
26435: PPUSH
26436: LD_VAR 0 16
26440: PPUSH
26441: CALL_OW 321
26445: PUSH
26446: LD_INT 2
26448: EQUAL
26449: AND
26450: IFFALSE 26510
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26452: LD_INT 22
26454: PUSH
26455: LD_VAR 0 16
26459: PUSH
26460: EMPTY
26461: LIST
26462: LIST
26463: PUSH
26464: LD_INT 35
26466: PUSH
26467: LD_INT 49
26469: PUSH
26470: EMPTY
26471: LIST
26472: LIST
26473: PUSH
26474: LD_INT 91
26476: PUSH
26477: LD_VAR 0 1
26481: PUSH
26482: LD_INT 10
26484: PUSH
26485: EMPTY
26486: LIST
26487: LIST
26488: LIST
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: LIST
26494: PPUSH
26495: CALL_OW 69
26499: NOT
26500: IFFALSE 26510
// weapon := ru_time_lapser ;
26502: LD_ADDR_VAR 0 18
26506: PUSH
26507: LD_INT 49
26509: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26510: LD_VAR 0 12
26514: PUSH
26515: LD_INT 1
26517: PUSH
26518: LD_INT 2
26520: PUSH
26521: EMPTY
26522: LIST
26523: LIST
26524: IN
26525: PUSH
26526: LD_INT 11
26528: PUSH
26529: LD_VAR 0 5
26533: IN
26534: PUSH
26535: LD_INT 30
26537: PUSH
26538: LD_VAR 0 5
26542: IN
26543: OR
26544: AND
26545: PUSH
26546: LD_INT 6
26548: PPUSH
26549: LD_VAR 0 16
26553: PPUSH
26554: CALL_OW 321
26558: PUSH
26559: LD_INT 2
26561: EQUAL
26562: AND
26563: IFFALSE 26728
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26565: LD_INT 22
26567: PUSH
26568: LD_VAR 0 16
26572: PUSH
26573: EMPTY
26574: LIST
26575: LIST
26576: PUSH
26577: LD_INT 2
26579: PUSH
26580: LD_INT 35
26582: PUSH
26583: LD_INT 11
26585: PUSH
26586: EMPTY
26587: LIST
26588: LIST
26589: PUSH
26590: LD_INT 35
26592: PUSH
26593: LD_INT 30
26595: PUSH
26596: EMPTY
26597: LIST
26598: LIST
26599: PUSH
26600: EMPTY
26601: LIST
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 91
26607: PUSH
26608: LD_VAR 0 1
26612: PUSH
26613: LD_INT 18
26615: PUSH
26616: EMPTY
26617: LIST
26618: LIST
26619: LIST
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: LIST
26625: PPUSH
26626: CALL_OW 69
26630: NOT
26631: PUSH
26632: LD_INT 22
26634: PUSH
26635: LD_VAR 0 16
26639: PUSH
26640: EMPTY
26641: LIST
26642: LIST
26643: PUSH
26644: LD_INT 2
26646: PUSH
26647: LD_INT 30
26649: PUSH
26650: LD_INT 32
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: LD_INT 30
26659: PUSH
26660: LD_INT 33
26662: PUSH
26663: EMPTY
26664: LIST
26665: LIST
26666: PUSH
26667: EMPTY
26668: LIST
26669: LIST
26670: LIST
26671: PUSH
26672: LD_INT 91
26674: PUSH
26675: LD_VAR 0 1
26679: PUSH
26680: LD_INT 12
26682: PUSH
26683: EMPTY
26684: LIST
26685: LIST
26686: LIST
26687: PUSH
26688: EMPTY
26689: LIST
26690: LIST
26691: LIST
26692: PUSH
26693: EMPTY
26694: LIST
26695: PPUSH
26696: CALL_OW 69
26700: PUSH
26701: LD_INT 2
26703: GREATER
26704: AND
26705: IFFALSE 26728
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26707: LD_ADDR_VAR 0 18
26711: PUSH
26712: LD_INT 11
26714: PUSH
26715: LD_INT 30
26717: PUSH
26718: EMPTY
26719: LIST
26720: LIST
26721: PUSH
26722: LD_VAR 0 12
26726: ARRAY
26727: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26728: LD_VAR 0 18
26732: NOT
26733: PUSH
26734: LD_INT 40
26736: PPUSH
26737: LD_VAR 0 16
26741: PPUSH
26742: CALL_OW 321
26746: PUSH
26747: LD_INT 2
26749: EQUAL
26750: AND
26751: PUSH
26752: LD_INT 7
26754: PUSH
26755: LD_VAR 0 5
26759: IN
26760: PUSH
26761: LD_INT 28
26763: PUSH
26764: LD_VAR 0 5
26768: IN
26769: OR
26770: PUSH
26771: LD_INT 45
26773: PUSH
26774: LD_VAR 0 5
26778: IN
26779: OR
26780: AND
26781: IFFALSE 27035
// begin hex := GetHexInfo ( x , y ) ;
26783: LD_ADDR_VAR 0 4
26787: PUSH
26788: LD_VAR 0 10
26792: PPUSH
26793: LD_VAR 0 11
26797: PPUSH
26798: CALL_OW 546
26802: ST_TO_ADDR
// if hex [ 1 ] then
26803: LD_VAR 0 4
26807: PUSH
26808: LD_INT 1
26810: ARRAY
26811: IFFALSE 26815
// exit ;
26813: GO 27218
// height := hex [ 2 ] ;
26815: LD_ADDR_VAR 0 15
26819: PUSH
26820: LD_VAR 0 4
26824: PUSH
26825: LD_INT 2
26827: ARRAY
26828: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26829: LD_ADDR_VAR 0 14
26833: PUSH
26834: LD_INT 0
26836: PUSH
26837: LD_INT 2
26839: PUSH
26840: LD_INT 3
26842: PUSH
26843: LD_INT 5
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: LIST
26850: LIST
26851: ST_TO_ADDR
// for i in tmp do
26852: LD_ADDR_VAR 0 8
26856: PUSH
26857: LD_VAR 0 14
26861: PUSH
26862: FOR_IN
26863: IFFALSE 27033
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26865: LD_ADDR_VAR 0 9
26869: PUSH
26870: LD_VAR 0 10
26874: PPUSH
26875: LD_VAR 0 8
26879: PPUSH
26880: LD_INT 5
26882: PPUSH
26883: CALL_OW 272
26887: PUSH
26888: LD_VAR 0 11
26892: PPUSH
26893: LD_VAR 0 8
26897: PPUSH
26898: LD_INT 5
26900: PPUSH
26901: CALL_OW 273
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26910: LD_VAR 0 9
26914: PUSH
26915: LD_INT 1
26917: ARRAY
26918: PPUSH
26919: LD_VAR 0 9
26923: PUSH
26924: LD_INT 2
26926: ARRAY
26927: PPUSH
26928: CALL_OW 488
26932: IFFALSE 27031
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26934: LD_ADDR_VAR 0 4
26938: PUSH
26939: LD_VAR 0 9
26943: PUSH
26944: LD_INT 1
26946: ARRAY
26947: PPUSH
26948: LD_VAR 0 9
26952: PUSH
26953: LD_INT 2
26955: ARRAY
26956: PPUSH
26957: CALL_OW 546
26961: ST_TO_ADDR
// if hex [ 1 ] then
26962: LD_VAR 0 4
26966: PUSH
26967: LD_INT 1
26969: ARRAY
26970: IFFALSE 26974
// continue ;
26972: GO 26862
// h := hex [ 2 ] ;
26974: LD_ADDR_VAR 0 13
26978: PUSH
26979: LD_VAR 0 4
26983: PUSH
26984: LD_INT 2
26986: ARRAY
26987: ST_TO_ADDR
// if h + 7 < height then
26988: LD_VAR 0 13
26992: PUSH
26993: LD_INT 7
26995: PLUS
26996: PUSH
26997: LD_VAR 0 15
27001: LESS
27002: IFFALSE 27031
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27004: LD_ADDR_VAR 0 18
27008: PUSH
27009: LD_INT 7
27011: PUSH
27012: LD_INT 28
27014: PUSH
27015: LD_INT 45
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: LIST
27022: PUSH
27023: LD_VAR 0 12
27027: ARRAY
27028: ST_TO_ADDR
// break ;
27029: GO 27033
// end ; end ; end ;
27031: GO 26862
27033: POP
27034: POP
// end ; if not weapon then
27035: LD_VAR 0 18
27039: NOT
27040: IFFALSE 27100
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27042: LD_ADDR_VAR 0 5
27046: PUSH
27047: LD_VAR 0 5
27051: PUSH
27052: LD_INT 11
27054: PUSH
27055: LD_INT 30
27057: PUSH
27058: LD_INT 49
27060: PUSH
27061: EMPTY
27062: LIST
27063: LIST
27064: LIST
27065: DIFF
27066: ST_TO_ADDR
// if not list then
27067: LD_VAR 0 5
27071: NOT
27072: IFFALSE 27076
// exit ;
27074: GO 27218
// weapon := list [ rand ( 1 , list ) ] ;
27076: LD_ADDR_VAR 0 18
27080: PUSH
27081: LD_VAR 0 5
27085: PUSH
27086: LD_INT 1
27088: PPUSH
27089: LD_VAR 0 5
27093: PPUSH
27094: CALL_OW 12
27098: ARRAY
27099: ST_TO_ADDR
// end ; if weapon then
27100: LD_VAR 0 18
27104: IFFALSE 27218
// begin tmp := CostOfWeapon ( weapon ) ;
27106: LD_ADDR_VAR 0 14
27110: PUSH
27111: LD_VAR 0 18
27115: PPUSH
27116: CALL_OW 451
27120: ST_TO_ADDR
// j := GetBase ( tower ) ;
27121: LD_ADDR_VAR 0 9
27125: PUSH
27126: LD_VAR 0 1
27130: PPUSH
27131: CALL_OW 274
27135: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27136: LD_VAR 0 9
27140: PPUSH
27141: LD_INT 1
27143: PPUSH
27144: CALL_OW 275
27148: PUSH
27149: LD_VAR 0 14
27153: PUSH
27154: LD_INT 1
27156: ARRAY
27157: GREATEREQUAL
27158: PUSH
27159: LD_VAR 0 9
27163: PPUSH
27164: LD_INT 2
27166: PPUSH
27167: CALL_OW 275
27171: PUSH
27172: LD_VAR 0 14
27176: PUSH
27177: LD_INT 2
27179: ARRAY
27180: GREATEREQUAL
27181: AND
27182: PUSH
27183: LD_VAR 0 9
27187: PPUSH
27188: LD_INT 3
27190: PPUSH
27191: CALL_OW 275
27195: PUSH
27196: LD_VAR 0 14
27200: PUSH
27201: LD_INT 3
27203: ARRAY
27204: GREATEREQUAL
27205: AND
27206: IFFALSE 27218
// result := weapon ;
27208: LD_ADDR_VAR 0 3
27212: PUSH
27213: LD_VAR 0 18
27217: ST_TO_ADDR
// end ; end ;
27218: LD_VAR 0 3
27222: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27223: LD_INT 0
27225: PPUSH
27226: PPUSH
// result := true ;
27227: LD_ADDR_VAR 0 3
27231: PUSH
27232: LD_INT 1
27234: ST_TO_ADDR
// if array1 = array2 then
27235: LD_VAR 0 1
27239: PUSH
27240: LD_VAR 0 2
27244: EQUAL
27245: IFFALSE 27305
// begin for i = 1 to array1 do
27247: LD_ADDR_VAR 0 4
27251: PUSH
27252: DOUBLE
27253: LD_INT 1
27255: DEC
27256: ST_TO_ADDR
27257: LD_VAR 0 1
27261: PUSH
27262: FOR_TO
27263: IFFALSE 27301
// if array1 [ i ] <> array2 [ i ] then
27265: LD_VAR 0 1
27269: PUSH
27270: LD_VAR 0 4
27274: ARRAY
27275: PUSH
27276: LD_VAR 0 2
27280: PUSH
27281: LD_VAR 0 4
27285: ARRAY
27286: NONEQUAL
27287: IFFALSE 27299
// begin result := false ;
27289: LD_ADDR_VAR 0 3
27293: PUSH
27294: LD_INT 0
27296: ST_TO_ADDR
// break ;
27297: GO 27301
// end ;
27299: GO 27262
27301: POP
27302: POP
// end else
27303: GO 27313
// result := false ;
27305: LD_ADDR_VAR 0 3
27309: PUSH
27310: LD_INT 0
27312: ST_TO_ADDR
// end ;
27313: LD_VAR 0 3
27317: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27318: LD_INT 0
27320: PPUSH
27321: PPUSH
27322: PPUSH
// pom := GetBase ( fac ) ;
27323: LD_ADDR_VAR 0 5
27327: PUSH
27328: LD_VAR 0 1
27332: PPUSH
27333: CALL_OW 274
27337: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27338: LD_ADDR_VAR 0 4
27342: PUSH
27343: LD_VAR 0 2
27347: PUSH
27348: LD_INT 1
27350: ARRAY
27351: PPUSH
27352: LD_VAR 0 2
27356: PUSH
27357: LD_INT 2
27359: ARRAY
27360: PPUSH
27361: LD_VAR 0 2
27365: PUSH
27366: LD_INT 3
27368: ARRAY
27369: PPUSH
27370: LD_VAR 0 2
27374: PUSH
27375: LD_INT 4
27377: ARRAY
27378: PPUSH
27379: CALL_OW 449
27383: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27384: LD_ADDR_VAR 0 3
27388: PUSH
27389: LD_VAR 0 5
27393: PPUSH
27394: LD_INT 1
27396: PPUSH
27397: CALL_OW 275
27401: PUSH
27402: LD_VAR 0 4
27406: PUSH
27407: LD_INT 1
27409: ARRAY
27410: GREATEREQUAL
27411: PUSH
27412: LD_VAR 0 5
27416: PPUSH
27417: LD_INT 2
27419: PPUSH
27420: CALL_OW 275
27424: PUSH
27425: LD_VAR 0 4
27429: PUSH
27430: LD_INT 2
27432: ARRAY
27433: GREATEREQUAL
27434: AND
27435: PUSH
27436: LD_VAR 0 5
27440: PPUSH
27441: LD_INT 3
27443: PPUSH
27444: CALL_OW 275
27448: PUSH
27449: LD_VAR 0 4
27453: PUSH
27454: LD_INT 3
27456: ARRAY
27457: GREATEREQUAL
27458: AND
27459: ST_TO_ADDR
// end ;
27460: LD_VAR 0 3
27464: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27465: LD_INT 0
27467: PPUSH
27468: PPUSH
27469: PPUSH
27470: PPUSH
// pom := GetBase ( building ) ;
27471: LD_ADDR_VAR 0 3
27475: PUSH
27476: LD_VAR 0 1
27480: PPUSH
27481: CALL_OW 274
27485: ST_TO_ADDR
// if not pom then
27486: LD_VAR 0 3
27490: NOT
27491: IFFALSE 27495
// exit ;
27493: GO 27665
// btype := GetBType ( building ) ;
27495: LD_ADDR_VAR 0 5
27499: PUSH
27500: LD_VAR 0 1
27504: PPUSH
27505: CALL_OW 266
27509: ST_TO_ADDR
// if btype = b_armoury then
27510: LD_VAR 0 5
27514: PUSH
27515: LD_INT 4
27517: EQUAL
27518: IFFALSE 27528
// btype := b_barracks ;
27520: LD_ADDR_VAR 0 5
27524: PUSH
27525: LD_INT 5
27527: ST_TO_ADDR
// if btype = b_depot then
27528: LD_VAR 0 5
27532: PUSH
27533: LD_INT 0
27535: EQUAL
27536: IFFALSE 27546
// btype := b_warehouse ;
27538: LD_ADDR_VAR 0 5
27542: PUSH
27543: LD_INT 1
27545: ST_TO_ADDR
// if btype = b_workshop then
27546: LD_VAR 0 5
27550: PUSH
27551: LD_INT 2
27553: EQUAL
27554: IFFALSE 27564
// btype := b_factory ;
27556: LD_ADDR_VAR 0 5
27560: PUSH
27561: LD_INT 3
27563: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27564: LD_ADDR_VAR 0 4
27568: PUSH
27569: LD_VAR 0 5
27573: PPUSH
27574: LD_VAR 0 1
27578: PPUSH
27579: CALL_OW 248
27583: PPUSH
27584: CALL_OW 450
27588: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27589: LD_ADDR_VAR 0 2
27593: PUSH
27594: LD_VAR 0 3
27598: PPUSH
27599: LD_INT 1
27601: PPUSH
27602: CALL_OW 275
27606: PUSH
27607: LD_VAR 0 4
27611: PUSH
27612: LD_INT 1
27614: ARRAY
27615: GREATEREQUAL
27616: PUSH
27617: LD_VAR 0 3
27621: PPUSH
27622: LD_INT 2
27624: PPUSH
27625: CALL_OW 275
27629: PUSH
27630: LD_VAR 0 4
27634: PUSH
27635: LD_INT 2
27637: ARRAY
27638: GREATEREQUAL
27639: AND
27640: PUSH
27641: LD_VAR 0 3
27645: PPUSH
27646: LD_INT 3
27648: PPUSH
27649: CALL_OW 275
27653: PUSH
27654: LD_VAR 0 4
27658: PUSH
27659: LD_INT 3
27661: ARRAY
27662: GREATEREQUAL
27663: AND
27664: ST_TO_ADDR
// end ;
27665: LD_VAR 0 2
27669: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27670: LD_INT 0
27672: PPUSH
27673: PPUSH
27674: PPUSH
// pom := GetBase ( building ) ;
27675: LD_ADDR_VAR 0 4
27679: PUSH
27680: LD_VAR 0 1
27684: PPUSH
27685: CALL_OW 274
27689: ST_TO_ADDR
// if not pom then
27690: LD_VAR 0 4
27694: NOT
27695: IFFALSE 27699
// exit ;
27697: GO 27800
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27699: LD_ADDR_VAR 0 5
27703: PUSH
27704: LD_VAR 0 2
27708: PPUSH
27709: LD_VAR 0 1
27713: PPUSH
27714: CALL_OW 248
27718: PPUSH
27719: CALL_OW 450
27723: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27724: LD_ADDR_VAR 0 3
27728: PUSH
27729: LD_VAR 0 4
27733: PPUSH
27734: LD_INT 1
27736: PPUSH
27737: CALL_OW 275
27741: PUSH
27742: LD_VAR 0 5
27746: PUSH
27747: LD_INT 1
27749: ARRAY
27750: GREATEREQUAL
27751: PUSH
27752: LD_VAR 0 4
27756: PPUSH
27757: LD_INT 2
27759: PPUSH
27760: CALL_OW 275
27764: PUSH
27765: LD_VAR 0 5
27769: PUSH
27770: LD_INT 2
27772: ARRAY
27773: GREATEREQUAL
27774: AND
27775: PUSH
27776: LD_VAR 0 4
27780: PPUSH
27781: LD_INT 3
27783: PPUSH
27784: CALL_OW 275
27788: PUSH
27789: LD_VAR 0 5
27793: PUSH
27794: LD_INT 3
27796: ARRAY
27797: GREATEREQUAL
27798: AND
27799: ST_TO_ADDR
// end ;
27800: LD_VAR 0 3
27804: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
27805: LD_INT 0
27807: PPUSH
27808: PPUSH
27809: PPUSH
27810: PPUSH
27811: PPUSH
27812: PPUSH
27813: PPUSH
27814: PPUSH
27815: PPUSH
27816: PPUSH
// result := false ;
27817: LD_ADDR_VAR 0 6
27821: PUSH
27822: LD_INT 0
27824: ST_TO_ADDR
// if not base or not btype or not x or not y then
27825: LD_VAR 0 1
27829: NOT
27830: PUSH
27831: LD_VAR 0 2
27835: NOT
27836: OR
27837: PUSH
27838: LD_VAR 0 3
27842: NOT
27843: OR
27844: PUSH
27845: LD_VAR 0 4
27849: NOT
27850: OR
27851: IFFALSE 27855
// exit ;
27853: GO 28464
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
27855: LD_ADDR_VAR 0 12
27859: PUSH
27860: LD_VAR 0 2
27864: PPUSH
27865: LD_VAR 0 3
27869: PPUSH
27870: LD_VAR 0 4
27874: PPUSH
27875: LD_VAR 0 5
27879: PPUSH
27880: LD_VAR 0 1
27884: PUSH
27885: LD_INT 1
27887: ARRAY
27888: PPUSH
27889: CALL_OW 248
27893: PPUSH
27894: LD_INT 0
27896: PPUSH
27897: CALL 29301 0 6
27901: ST_TO_ADDR
// if not hexes then
27902: LD_VAR 0 12
27906: NOT
27907: IFFALSE 27911
// exit ;
27909: GO 28464
// for i = 1 to hexes do
27911: LD_ADDR_VAR 0 7
27915: PUSH
27916: DOUBLE
27917: LD_INT 1
27919: DEC
27920: ST_TO_ADDR
27921: LD_VAR 0 12
27925: PUSH
27926: FOR_TO
27927: IFFALSE 28462
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27929: LD_ADDR_VAR 0 11
27933: PUSH
27934: LD_VAR 0 12
27938: PUSH
27939: LD_VAR 0 7
27943: ARRAY
27944: PUSH
27945: LD_INT 1
27947: ARRAY
27948: PPUSH
27949: LD_VAR 0 12
27953: PUSH
27954: LD_VAR 0 7
27958: ARRAY
27959: PUSH
27960: LD_INT 2
27962: ARRAY
27963: PPUSH
27964: CALL_OW 428
27968: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27969: LD_VAR 0 12
27973: PUSH
27974: LD_VAR 0 7
27978: ARRAY
27979: PUSH
27980: LD_INT 1
27982: ARRAY
27983: PPUSH
27984: LD_VAR 0 12
27988: PUSH
27989: LD_VAR 0 7
27993: ARRAY
27994: PUSH
27995: LD_INT 2
27997: ARRAY
27998: PPUSH
27999: CALL_OW 351
28003: PUSH
28004: LD_VAR 0 12
28008: PUSH
28009: LD_VAR 0 7
28013: ARRAY
28014: PUSH
28015: LD_INT 1
28017: ARRAY
28018: PPUSH
28019: LD_VAR 0 12
28023: PUSH
28024: LD_VAR 0 7
28028: ARRAY
28029: PUSH
28030: LD_INT 2
28032: ARRAY
28033: PPUSH
28034: CALL_OW 488
28038: NOT
28039: OR
28040: PUSH
28041: LD_VAR 0 11
28045: PPUSH
28046: CALL_OW 247
28050: PUSH
28051: LD_INT 3
28053: EQUAL
28054: OR
28055: IFFALSE 28061
// exit ;
28057: POP
28058: POP
28059: GO 28464
// if not tmp or not tmp in base then
28061: LD_VAR 0 11
28065: NOT
28066: PUSH
28067: LD_VAR 0 11
28071: PUSH
28072: LD_VAR 0 1
28076: IN
28077: NOT
28078: OR
28079: IFFALSE 28083
// continue ;
28081: GO 27926
// result := true ;
28083: LD_ADDR_VAR 0 6
28087: PUSH
28088: LD_INT 1
28090: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28091: LD_ADDR_VAR 0 15
28095: PUSH
28096: LD_VAR 0 1
28100: PPUSH
28101: LD_INT 22
28103: PUSH
28104: LD_VAR 0 11
28108: PPUSH
28109: CALL_OW 255
28113: PUSH
28114: EMPTY
28115: LIST
28116: LIST
28117: PUSH
28118: LD_INT 2
28120: PUSH
28121: LD_INT 30
28123: PUSH
28124: LD_INT 0
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PUSH
28131: LD_INT 30
28133: PUSH
28134: LD_INT 1
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: EMPTY
28142: LIST
28143: LIST
28144: LIST
28145: PUSH
28146: EMPTY
28147: LIST
28148: LIST
28149: PPUSH
28150: CALL_OW 72
28154: ST_TO_ADDR
// if dep then
28155: LD_VAR 0 15
28159: IFFALSE 28295
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28161: LD_ADDR_VAR 0 14
28165: PUSH
28166: LD_VAR 0 15
28170: PUSH
28171: LD_INT 1
28173: ARRAY
28174: PPUSH
28175: CALL_OW 250
28179: PPUSH
28180: LD_VAR 0 15
28184: PUSH
28185: LD_INT 1
28187: ARRAY
28188: PPUSH
28189: CALL_OW 254
28193: PPUSH
28194: LD_INT 5
28196: PPUSH
28197: CALL_OW 272
28201: PUSH
28202: LD_VAR 0 15
28206: PUSH
28207: LD_INT 1
28209: ARRAY
28210: PPUSH
28211: CALL_OW 251
28215: PPUSH
28216: LD_VAR 0 15
28220: PUSH
28221: LD_INT 1
28223: ARRAY
28224: PPUSH
28225: CALL_OW 254
28229: PPUSH
28230: LD_INT 5
28232: PPUSH
28233: CALL_OW 273
28237: PUSH
28238: EMPTY
28239: LIST
28240: LIST
28241: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28242: LD_VAR 0 14
28246: PUSH
28247: LD_INT 1
28249: ARRAY
28250: PPUSH
28251: LD_VAR 0 14
28255: PUSH
28256: LD_INT 2
28258: ARRAY
28259: PPUSH
28260: CALL_OW 488
28264: IFFALSE 28295
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28266: LD_VAR 0 11
28270: PPUSH
28271: LD_VAR 0 14
28275: PUSH
28276: LD_INT 1
28278: ARRAY
28279: PPUSH
28280: LD_VAR 0 14
28284: PUSH
28285: LD_INT 2
28287: ARRAY
28288: PPUSH
28289: CALL_OW 111
// continue ;
28293: GO 27926
// end ; end ; r := GetDir ( tmp ) ;
28295: LD_ADDR_VAR 0 13
28299: PUSH
28300: LD_VAR 0 11
28304: PPUSH
28305: CALL_OW 254
28309: ST_TO_ADDR
// if r = 5 then
28310: LD_VAR 0 13
28314: PUSH
28315: LD_INT 5
28317: EQUAL
28318: IFFALSE 28328
// r := 0 ;
28320: LD_ADDR_VAR 0 13
28324: PUSH
28325: LD_INT 0
28327: ST_TO_ADDR
// for j = r to 5 do
28328: LD_ADDR_VAR 0 8
28332: PUSH
28333: DOUBLE
28334: LD_VAR 0 13
28338: DEC
28339: ST_TO_ADDR
28340: LD_INT 5
28342: PUSH
28343: FOR_TO
28344: IFFALSE 28458
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28346: LD_ADDR_VAR 0 9
28350: PUSH
28351: LD_VAR 0 11
28355: PPUSH
28356: CALL_OW 250
28360: PPUSH
28361: LD_VAR 0 8
28365: PPUSH
28366: LD_INT 2
28368: PPUSH
28369: CALL_OW 272
28373: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28374: LD_ADDR_VAR 0 10
28378: PUSH
28379: LD_VAR 0 11
28383: PPUSH
28384: CALL_OW 251
28388: PPUSH
28389: LD_VAR 0 8
28393: PPUSH
28394: LD_INT 2
28396: PPUSH
28397: CALL_OW 273
28401: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28402: LD_VAR 0 9
28406: PPUSH
28407: LD_VAR 0 10
28411: PPUSH
28412: CALL_OW 488
28416: PUSH
28417: LD_VAR 0 9
28421: PPUSH
28422: LD_VAR 0 10
28426: PPUSH
28427: CALL_OW 428
28431: NOT
28432: AND
28433: IFFALSE 28456
// begin ComMoveXY ( tmp , _x , _y ) ;
28435: LD_VAR 0 11
28439: PPUSH
28440: LD_VAR 0 9
28444: PPUSH
28445: LD_VAR 0 10
28449: PPUSH
28450: CALL_OW 111
// break ;
28454: GO 28458
// end ; end ;
28456: GO 28343
28458: POP
28459: POP
// end ;
28460: GO 27926
28462: POP
28463: POP
// end ;
28464: LD_VAR 0 6
28468: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28469: LD_INT 0
28471: PPUSH
28472: PPUSH
28473: PPUSH
28474: PPUSH
28475: PPUSH
28476: PPUSH
28477: PPUSH
28478: PPUSH
28479: PPUSH
28480: PPUSH
// result := false ;
28481: LD_ADDR_VAR 0 6
28485: PUSH
28486: LD_INT 0
28488: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28489: LD_VAR 0 1
28493: NOT
28494: PUSH
28495: LD_VAR 0 1
28499: PPUSH
28500: CALL_OW 266
28504: PUSH
28505: LD_INT 0
28507: PUSH
28508: LD_INT 1
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: IN
28515: NOT
28516: OR
28517: PUSH
28518: LD_VAR 0 2
28522: NOT
28523: OR
28524: PUSH
28525: LD_VAR 0 5
28529: PUSH
28530: LD_INT 0
28532: PUSH
28533: LD_INT 1
28535: PUSH
28536: LD_INT 2
28538: PUSH
28539: LD_INT 3
28541: PUSH
28542: LD_INT 4
28544: PUSH
28545: LD_INT 5
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: LIST
28552: LIST
28553: LIST
28554: LIST
28555: IN
28556: NOT
28557: OR
28558: PUSH
28559: LD_VAR 0 3
28563: PPUSH
28564: LD_VAR 0 4
28568: PPUSH
28569: CALL_OW 488
28573: NOT
28574: OR
28575: IFFALSE 28579
// exit ;
28577: GO 29296
// pom := GetBase ( depot ) ;
28579: LD_ADDR_VAR 0 10
28583: PUSH
28584: LD_VAR 0 1
28588: PPUSH
28589: CALL_OW 274
28593: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28594: LD_ADDR_VAR 0 11
28598: PUSH
28599: LD_VAR 0 2
28603: PPUSH
28604: LD_VAR 0 1
28608: PPUSH
28609: CALL_OW 248
28613: PPUSH
28614: CALL_OW 450
28618: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28619: LD_VAR 0 10
28623: PPUSH
28624: LD_INT 1
28626: PPUSH
28627: CALL_OW 275
28631: PUSH
28632: LD_VAR 0 11
28636: PUSH
28637: LD_INT 1
28639: ARRAY
28640: GREATEREQUAL
28641: PUSH
28642: LD_VAR 0 10
28646: PPUSH
28647: LD_INT 2
28649: PPUSH
28650: CALL_OW 275
28654: PUSH
28655: LD_VAR 0 11
28659: PUSH
28660: LD_INT 2
28662: ARRAY
28663: GREATEREQUAL
28664: AND
28665: PUSH
28666: LD_VAR 0 10
28670: PPUSH
28671: LD_INT 3
28673: PPUSH
28674: CALL_OW 275
28678: PUSH
28679: LD_VAR 0 11
28683: PUSH
28684: LD_INT 3
28686: ARRAY
28687: GREATEREQUAL
28688: AND
28689: NOT
28690: IFFALSE 28694
// exit ;
28692: GO 29296
// if GetBType ( depot ) = b_depot then
28694: LD_VAR 0 1
28698: PPUSH
28699: CALL_OW 266
28703: PUSH
28704: LD_INT 0
28706: EQUAL
28707: IFFALSE 28719
// dist := 28 else
28709: LD_ADDR_VAR 0 14
28713: PUSH
28714: LD_INT 28
28716: ST_TO_ADDR
28717: GO 28727
// dist := 36 ;
28719: LD_ADDR_VAR 0 14
28723: PUSH
28724: LD_INT 36
28726: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28727: LD_VAR 0 1
28731: PPUSH
28732: LD_VAR 0 3
28736: PPUSH
28737: LD_VAR 0 4
28741: PPUSH
28742: CALL_OW 297
28746: PUSH
28747: LD_VAR 0 14
28751: GREATER
28752: IFFALSE 28756
// exit ;
28754: GO 29296
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28756: LD_ADDR_VAR 0 12
28760: PUSH
28761: LD_VAR 0 2
28765: PPUSH
28766: LD_VAR 0 3
28770: PPUSH
28771: LD_VAR 0 4
28775: PPUSH
28776: LD_VAR 0 5
28780: PPUSH
28781: LD_VAR 0 1
28785: PPUSH
28786: CALL_OW 248
28790: PPUSH
28791: LD_INT 0
28793: PPUSH
28794: CALL 29301 0 6
28798: ST_TO_ADDR
// if not hexes then
28799: LD_VAR 0 12
28803: NOT
28804: IFFALSE 28808
// exit ;
28806: GO 29296
// hex := GetHexInfo ( x , y ) ;
28808: LD_ADDR_VAR 0 15
28812: PUSH
28813: LD_VAR 0 3
28817: PPUSH
28818: LD_VAR 0 4
28822: PPUSH
28823: CALL_OW 546
28827: ST_TO_ADDR
// if hex [ 1 ] then
28828: LD_VAR 0 15
28832: PUSH
28833: LD_INT 1
28835: ARRAY
28836: IFFALSE 28840
// exit ;
28838: GO 29296
// height := hex [ 2 ] ;
28840: LD_ADDR_VAR 0 13
28844: PUSH
28845: LD_VAR 0 15
28849: PUSH
28850: LD_INT 2
28852: ARRAY
28853: ST_TO_ADDR
// for i = 1 to hexes do
28854: LD_ADDR_VAR 0 7
28858: PUSH
28859: DOUBLE
28860: LD_INT 1
28862: DEC
28863: ST_TO_ADDR
28864: LD_VAR 0 12
28868: PUSH
28869: FOR_TO
28870: IFFALSE 29200
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
28872: LD_VAR 0 12
28876: PUSH
28877: LD_VAR 0 7
28881: ARRAY
28882: PUSH
28883: LD_INT 1
28885: ARRAY
28886: PPUSH
28887: LD_VAR 0 12
28891: PUSH
28892: LD_VAR 0 7
28896: ARRAY
28897: PUSH
28898: LD_INT 2
28900: ARRAY
28901: PPUSH
28902: CALL_OW 488
28906: NOT
28907: PUSH
28908: LD_VAR 0 12
28912: PUSH
28913: LD_VAR 0 7
28917: ARRAY
28918: PUSH
28919: LD_INT 1
28921: ARRAY
28922: PPUSH
28923: LD_VAR 0 12
28927: PUSH
28928: LD_VAR 0 7
28932: ARRAY
28933: PUSH
28934: LD_INT 2
28936: ARRAY
28937: PPUSH
28938: CALL_OW 428
28942: PUSH
28943: LD_INT 0
28945: GREATER
28946: OR
28947: PUSH
28948: LD_VAR 0 12
28952: PUSH
28953: LD_VAR 0 7
28957: ARRAY
28958: PUSH
28959: LD_INT 1
28961: ARRAY
28962: PPUSH
28963: LD_VAR 0 12
28967: PUSH
28968: LD_VAR 0 7
28972: ARRAY
28973: PUSH
28974: LD_INT 2
28976: ARRAY
28977: PPUSH
28978: CALL_OW 351
28982: OR
28983: IFFALSE 28989
// exit ;
28985: POP
28986: POP
28987: GO 29296
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28989: LD_ADDR_VAR 0 8
28993: PUSH
28994: LD_VAR 0 12
28998: PUSH
28999: LD_VAR 0 7
29003: ARRAY
29004: PUSH
29005: LD_INT 1
29007: ARRAY
29008: PPUSH
29009: LD_VAR 0 12
29013: PUSH
29014: LD_VAR 0 7
29018: ARRAY
29019: PUSH
29020: LD_INT 2
29022: ARRAY
29023: PPUSH
29024: CALL_OW 546
29028: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29029: LD_VAR 0 8
29033: PUSH
29034: LD_INT 1
29036: ARRAY
29037: PUSH
29038: LD_VAR 0 8
29042: PUSH
29043: LD_INT 2
29045: ARRAY
29046: PUSH
29047: LD_VAR 0 13
29051: PUSH
29052: LD_INT 2
29054: PLUS
29055: GREATER
29056: OR
29057: PUSH
29058: LD_VAR 0 8
29062: PUSH
29063: LD_INT 2
29065: ARRAY
29066: PUSH
29067: LD_VAR 0 13
29071: PUSH
29072: LD_INT 2
29074: MINUS
29075: LESS
29076: OR
29077: PUSH
29078: LD_VAR 0 8
29082: PUSH
29083: LD_INT 3
29085: ARRAY
29086: PUSH
29087: LD_INT 0
29089: PUSH
29090: LD_INT 8
29092: PUSH
29093: LD_INT 9
29095: PUSH
29096: LD_INT 10
29098: PUSH
29099: LD_INT 11
29101: PUSH
29102: LD_INT 12
29104: PUSH
29105: LD_INT 13
29107: PUSH
29108: LD_INT 16
29110: PUSH
29111: LD_INT 17
29113: PUSH
29114: LD_INT 18
29116: PUSH
29117: LD_INT 19
29119: PUSH
29120: LD_INT 20
29122: PUSH
29123: LD_INT 21
29125: PUSH
29126: EMPTY
29127: LIST
29128: LIST
29129: LIST
29130: LIST
29131: LIST
29132: LIST
29133: LIST
29134: LIST
29135: LIST
29136: LIST
29137: LIST
29138: LIST
29139: LIST
29140: IN
29141: NOT
29142: OR
29143: PUSH
29144: LD_VAR 0 8
29148: PUSH
29149: LD_INT 5
29151: ARRAY
29152: NOT
29153: OR
29154: PUSH
29155: LD_VAR 0 8
29159: PUSH
29160: LD_INT 6
29162: ARRAY
29163: PUSH
29164: LD_INT 1
29166: PUSH
29167: LD_INT 2
29169: PUSH
29170: LD_INT 7
29172: PUSH
29173: LD_INT 9
29175: PUSH
29176: LD_INT 10
29178: PUSH
29179: LD_INT 11
29181: PUSH
29182: EMPTY
29183: LIST
29184: LIST
29185: LIST
29186: LIST
29187: LIST
29188: LIST
29189: IN
29190: NOT
29191: OR
29192: IFFALSE 29198
// exit ;
29194: POP
29195: POP
29196: GO 29296
// end ;
29198: GO 28869
29200: POP
29201: POP
// side := GetSide ( depot ) ;
29202: LD_ADDR_VAR 0 9
29206: PUSH
29207: LD_VAR 0 1
29211: PPUSH
29212: CALL_OW 255
29216: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29217: LD_VAR 0 9
29221: PPUSH
29222: LD_VAR 0 3
29226: PPUSH
29227: LD_VAR 0 4
29231: PPUSH
29232: LD_INT 20
29234: PPUSH
29235: CALL 21950 0 4
29239: PUSH
29240: LD_INT 4
29242: ARRAY
29243: IFFALSE 29247
// exit ;
29245: GO 29296
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29247: LD_VAR 0 2
29251: PUSH
29252: LD_INT 29
29254: PUSH
29255: LD_INT 30
29257: PUSH
29258: EMPTY
29259: LIST
29260: LIST
29261: IN
29262: PUSH
29263: LD_VAR 0 3
29267: PPUSH
29268: LD_VAR 0 4
29272: PPUSH
29273: LD_VAR 0 9
29277: PPUSH
29278: CALL_OW 440
29282: NOT
29283: AND
29284: IFFALSE 29288
// exit ;
29286: GO 29296
// result := true ;
29288: LD_ADDR_VAR 0 6
29292: PUSH
29293: LD_INT 1
29295: ST_TO_ADDR
// end ;
29296: LD_VAR 0 6
29300: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29301: LD_INT 0
29303: PPUSH
29304: PPUSH
29305: PPUSH
29306: PPUSH
29307: PPUSH
29308: PPUSH
29309: PPUSH
29310: PPUSH
29311: PPUSH
29312: PPUSH
29313: PPUSH
29314: PPUSH
29315: PPUSH
29316: PPUSH
29317: PPUSH
29318: PPUSH
29319: PPUSH
29320: PPUSH
29321: PPUSH
29322: PPUSH
29323: PPUSH
29324: PPUSH
29325: PPUSH
29326: PPUSH
29327: PPUSH
29328: PPUSH
29329: PPUSH
29330: PPUSH
29331: PPUSH
29332: PPUSH
29333: PPUSH
29334: PPUSH
29335: PPUSH
29336: PPUSH
29337: PPUSH
29338: PPUSH
29339: PPUSH
29340: PPUSH
29341: PPUSH
29342: PPUSH
29343: PPUSH
29344: PPUSH
29345: PPUSH
29346: PPUSH
29347: PPUSH
29348: PPUSH
29349: PPUSH
29350: PPUSH
29351: PPUSH
29352: PPUSH
29353: PPUSH
29354: PPUSH
29355: PPUSH
29356: PPUSH
29357: PPUSH
29358: PPUSH
29359: PPUSH
29360: PPUSH
// result = [ ] ;
29361: LD_ADDR_VAR 0 7
29365: PUSH
29366: EMPTY
29367: ST_TO_ADDR
// temp_list = [ ] ;
29368: LD_ADDR_VAR 0 9
29372: PUSH
29373: EMPTY
29374: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29375: LD_VAR 0 4
29379: PUSH
29380: LD_INT 0
29382: PUSH
29383: LD_INT 1
29385: PUSH
29386: LD_INT 2
29388: PUSH
29389: LD_INT 3
29391: PUSH
29392: LD_INT 4
29394: PUSH
29395: LD_INT 5
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: LIST
29402: LIST
29403: LIST
29404: LIST
29405: IN
29406: NOT
29407: PUSH
29408: LD_VAR 0 1
29412: PUSH
29413: LD_INT 0
29415: PUSH
29416: LD_INT 1
29418: PUSH
29419: EMPTY
29420: LIST
29421: LIST
29422: IN
29423: PUSH
29424: LD_VAR 0 5
29428: PUSH
29429: LD_INT 1
29431: PUSH
29432: LD_INT 2
29434: PUSH
29435: LD_INT 3
29437: PUSH
29438: EMPTY
29439: LIST
29440: LIST
29441: LIST
29442: IN
29443: NOT
29444: AND
29445: OR
29446: IFFALSE 29450
// exit ;
29448: GO 47841
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29450: LD_VAR 0 1
29454: PUSH
29455: LD_INT 6
29457: PUSH
29458: LD_INT 7
29460: PUSH
29461: LD_INT 8
29463: PUSH
29464: LD_INT 13
29466: PUSH
29467: LD_INT 12
29469: PUSH
29470: LD_INT 15
29472: PUSH
29473: LD_INT 11
29475: PUSH
29476: LD_INT 14
29478: PUSH
29479: LD_INT 10
29481: PUSH
29482: EMPTY
29483: LIST
29484: LIST
29485: LIST
29486: LIST
29487: LIST
29488: LIST
29489: LIST
29490: LIST
29491: LIST
29492: IN
29493: IFFALSE 29503
// btype = b_lab ;
29495: LD_ADDR_VAR 0 1
29499: PUSH
29500: LD_INT 6
29502: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29503: LD_VAR 0 6
29507: PUSH
29508: LD_INT 0
29510: PUSH
29511: LD_INT 1
29513: PUSH
29514: LD_INT 2
29516: PUSH
29517: EMPTY
29518: LIST
29519: LIST
29520: LIST
29521: IN
29522: NOT
29523: PUSH
29524: LD_VAR 0 1
29528: PUSH
29529: LD_INT 0
29531: PUSH
29532: LD_INT 1
29534: PUSH
29535: LD_INT 2
29537: PUSH
29538: LD_INT 3
29540: PUSH
29541: LD_INT 6
29543: PUSH
29544: LD_INT 36
29546: PUSH
29547: LD_INT 4
29549: PUSH
29550: LD_INT 5
29552: PUSH
29553: LD_INT 31
29555: PUSH
29556: LD_INT 32
29558: PUSH
29559: LD_INT 33
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: LIST
29566: LIST
29567: LIST
29568: LIST
29569: LIST
29570: LIST
29571: LIST
29572: LIST
29573: LIST
29574: IN
29575: NOT
29576: PUSH
29577: LD_VAR 0 6
29581: PUSH
29582: LD_INT 1
29584: EQUAL
29585: AND
29586: OR
29587: PUSH
29588: LD_VAR 0 1
29592: PUSH
29593: LD_INT 2
29595: PUSH
29596: LD_INT 3
29598: PUSH
29599: EMPTY
29600: LIST
29601: LIST
29602: IN
29603: NOT
29604: PUSH
29605: LD_VAR 0 6
29609: PUSH
29610: LD_INT 2
29612: EQUAL
29613: AND
29614: OR
29615: IFFALSE 29625
// mode = 0 ;
29617: LD_ADDR_VAR 0 6
29621: PUSH
29622: LD_INT 0
29624: ST_TO_ADDR
// case mode of 0 :
29625: LD_VAR 0 6
29629: PUSH
29630: LD_INT 0
29632: DOUBLE
29633: EQUAL
29634: IFTRUE 29638
29636: GO 41091
29638: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29639: LD_ADDR_VAR 0 11
29643: PUSH
29644: LD_INT 0
29646: PUSH
29647: LD_INT 0
29649: PUSH
29650: EMPTY
29651: LIST
29652: LIST
29653: PUSH
29654: LD_INT 0
29656: PUSH
29657: LD_INT 1
29659: NEG
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: PUSH
29665: LD_INT 1
29667: PUSH
29668: LD_INT 0
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 1
29677: PUSH
29678: LD_INT 1
29680: PUSH
29681: EMPTY
29682: LIST
29683: LIST
29684: PUSH
29685: LD_INT 0
29687: PUSH
29688: LD_INT 1
29690: PUSH
29691: EMPTY
29692: LIST
29693: LIST
29694: PUSH
29695: LD_INT 1
29697: NEG
29698: PUSH
29699: LD_INT 0
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: PUSH
29706: LD_INT 1
29708: NEG
29709: PUSH
29710: LD_INT 1
29712: NEG
29713: PUSH
29714: EMPTY
29715: LIST
29716: LIST
29717: PUSH
29718: LD_INT 1
29720: NEG
29721: PUSH
29722: LD_INT 2
29724: NEG
29725: PUSH
29726: EMPTY
29727: LIST
29728: LIST
29729: PUSH
29730: LD_INT 0
29732: PUSH
29733: LD_INT 2
29735: NEG
29736: PUSH
29737: EMPTY
29738: LIST
29739: LIST
29740: PUSH
29741: LD_INT 1
29743: PUSH
29744: LD_INT 1
29746: NEG
29747: PUSH
29748: EMPTY
29749: LIST
29750: LIST
29751: PUSH
29752: LD_INT 1
29754: PUSH
29755: LD_INT 2
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 0
29764: PUSH
29765: LD_INT 2
29767: PUSH
29768: EMPTY
29769: LIST
29770: LIST
29771: PUSH
29772: LD_INT 1
29774: NEG
29775: PUSH
29776: LD_INT 1
29778: PUSH
29779: EMPTY
29780: LIST
29781: LIST
29782: PUSH
29783: LD_INT 1
29785: PUSH
29786: LD_INT 3
29788: PUSH
29789: EMPTY
29790: LIST
29791: LIST
29792: PUSH
29793: LD_INT 0
29795: PUSH
29796: LD_INT 3
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PUSH
29803: LD_INT 1
29805: NEG
29806: PUSH
29807: LD_INT 2
29809: PUSH
29810: EMPTY
29811: LIST
29812: LIST
29813: PUSH
29814: EMPTY
29815: LIST
29816: LIST
29817: LIST
29818: LIST
29819: LIST
29820: LIST
29821: LIST
29822: LIST
29823: LIST
29824: LIST
29825: LIST
29826: LIST
29827: LIST
29828: LIST
29829: LIST
29830: LIST
29831: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29832: LD_ADDR_VAR 0 12
29836: PUSH
29837: LD_INT 0
29839: PUSH
29840: LD_INT 0
29842: PUSH
29843: EMPTY
29844: LIST
29845: LIST
29846: PUSH
29847: LD_INT 0
29849: PUSH
29850: LD_INT 1
29852: NEG
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PUSH
29858: LD_INT 1
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 1
29870: PUSH
29871: LD_INT 1
29873: PUSH
29874: EMPTY
29875: LIST
29876: LIST
29877: PUSH
29878: LD_INT 0
29880: PUSH
29881: LD_INT 1
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: NEG
29891: PUSH
29892: LD_INT 0
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PUSH
29899: LD_INT 1
29901: NEG
29902: PUSH
29903: LD_INT 1
29905: NEG
29906: PUSH
29907: EMPTY
29908: LIST
29909: LIST
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: LD_INT 1
29916: NEG
29917: PUSH
29918: EMPTY
29919: LIST
29920: LIST
29921: PUSH
29922: LD_INT 2
29924: PUSH
29925: LD_INT 0
29927: PUSH
29928: EMPTY
29929: LIST
29930: LIST
29931: PUSH
29932: LD_INT 2
29934: PUSH
29935: LD_INT 1
29937: PUSH
29938: EMPTY
29939: LIST
29940: LIST
29941: PUSH
29942: LD_INT 1
29944: NEG
29945: PUSH
29946: LD_INT 1
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 2
29955: NEG
29956: PUSH
29957: LD_INT 0
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 2
29966: NEG
29967: PUSH
29968: LD_INT 1
29970: NEG
29971: PUSH
29972: EMPTY
29973: LIST
29974: LIST
29975: PUSH
29976: LD_INT 2
29978: NEG
29979: PUSH
29980: LD_INT 1
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 3
29989: NEG
29990: PUSH
29991: LD_INT 0
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 3
30000: NEG
30001: PUSH
30002: LD_INT 1
30004: NEG
30005: PUSH
30006: EMPTY
30007: LIST
30008: LIST
30009: PUSH
30010: EMPTY
30011: LIST
30012: LIST
30013: LIST
30014: LIST
30015: LIST
30016: LIST
30017: LIST
30018: LIST
30019: LIST
30020: LIST
30021: LIST
30022: LIST
30023: LIST
30024: LIST
30025: LIST
30026: LIST
30027: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30028: LD_ADDR_VAR 0 13
30032: PUSH
30033: LD_INT 0
30035: PUSH
30036: LD_INT 0
30038: PUSH
30039: EMPTY
30040: LIST
30041: LIST
30042: PUSH
30043: LD_INT 0
30045: PUSH
30046: LD_INT 1
30048: NEG
30049: PUSH
30050: EMPTY
30051: LIST
30052: LIST
30053: PUSH
30054: LD_INT 1
30056: PUSH
30057: LD_INT 0
30059: PUSH
30060: EMPTY
30061: LIST
30062: LIST
30063: PUSH
30064: LD_INT 1
30066: PUSH
30067: LD_INT 1
30069: PUSH
30070: EMPTY
30071: LIST
30072: LIST
30073: PUSH
30074: LD_INT 0
30076: PUSH
30077: LD_INT 1
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 1
30086: NEG
30087: PUSH
30088: LD_INT 0
30090: PUSH
30091: EMPTY
30092: LIST
30093: LIST
30094: PUSH
30095: LD_INT 1
30097: NEG
30098: PUSH
30099: LD_INT 1
30101: NEG
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 1
30109: NEG
30110: PUSH
30111: LD_INT 2
30113: NEG
30114: PUSH
30115: EMPTY
30116: LIST
30117: LIST
30118: PUSH
30119: LD_INT 2
30121: PUSH
30122: LD_INT 1
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: PUSH
30129: LD_INT 2
30131: PUSH
30132: LD_INT 2
30134: PUSH
30135: EMPTY
30136: LIST
30137: LIST
30138: PUSH
30139: LD_INT 1
30141: PUSH
30142: LD_INT 2
30144: PUSH
30145: EMPTY
30146: LIST
30147: LIST
30148: PUSH
30149: LD_INT 2
30151: NEG
30152: PUSH
30153: LD_INT 1
30155: NEG
30156: PUSH
30157: EMPTY
30158: LIST
30159: LIST
30160: PUSH
30161: LD_INT 2
30163: NEG
30164: PUSH
30165: LD_INT 2
30167: NEG
30168: PUSH
30169: EMPTY
30170: LIST
30171: LIST
30172: PUSH
30173: LD_INT 2
30175: NEG
30176: PUSH
30177: LD_INT 3
30179: NEG
30180: PUSH
30181: EMPTY
30182: LIST
30183: LIST
30184: PUSH
30185: LD_INT 3
30187: NEG
30188: PUSH
30189: LD_INT 2
30191: NEG
30192: PUSH
30193: EMPTY
30194: LIST
30195: LIST
30196: PUSH
30197: LD_INT 3
30199: NEG
30200: PUSH
30201: LD_INT 3
30203: NEG
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: PUSH
30209: EMPTY
30210: LIST
30211: LIST
30212: LIST
30213: LIST
30214: LIST
30215: LIST
30216: LIST
30217: LIST
30218: LIST
30219: LIST
30220: LIST
30221: LIST
30222: LIST
30223: LIST
30224: LIST
30225: LIST
30226: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30227: LD_ADDR_VAR 0 14
30231: PUSH
30232: LD_INT 0
30234: PUSH
30235: LD_INT 0
30237: PUSH
30238: EMPTY
30239: LIST
30240: LIST
30241: PUSH
30242: LD_INT 0
30244: PUSH
30245: LD_INT 1
30247: NEG
30248: PUSH
30249: EMPTY
30250: LIST
30251: LIST
30252: PUSH
30253: LD_INT 1
30255: PUSH
30256: LD_INT 0
30258: PUSH
30259: EMPTY
30260: LIST
30261: LIST
30262: PUSH
30263: LD_INT 1
30265: PUSH
30266: LD_INT 1
30268: PUSH
30269: EMPTY
30270: LIST
30271: LIST
30272: PUSH
30273: LD_INT 0
30275: PUSH
30276: LD_INT 1
30278: PUSH
30279: EMPTY
30280: LIST
30281: LIST
30282: PUSH
30283: LD_INT 1
30285: NEG
30286: PUSH
30287: LD_INT 0
30289: PUSH
30290: EMPTY
30291: LIST
30292: LIST
30293: PUSH
30294: LD_INT 1
30296: NEG
30297: PUSH
30298: LD_INT 1
30300: NEG
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 2
30312: NEG
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 0
30320: PUSH
30321: LD_INT 2
30323: NEG
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: LD_INT 1
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 1
30342: PUSH
30343: LD_INT 2
30345: PUSH
30346: EMPTY
30347: LIST
30348: LIST
30349: PUSH
30350: LD_INT 0
30352: PUSH
30353: LD_INT 2
30355: PUSH
30356: EMPTY
30357: LIST
30358: LIST
30359: PUSH
30360: LD_INT 1
30362: NEG
30363: PUSH
30364: LD_INT 1
30366: PUSH
30367: EMPTY
30368: LIST
30369: LIST
30370: PUSH
30371: LD_INT 1
30373: NEG
30374: PUSH
30375: LD_INT 3
30377: NEG
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 0
30385: PUSH
30386: LD_INT 3
30388: NEG
30389: PUSH
30390: EMPTY
30391: LIST
30392: LIST
30393: PUSH
30394: LD_INT 1
30396: PUSH
30397: LD_INT 2
30399: NEG
30400: PUSH
30401: EMPTY
30402: LIST
30403: LIST
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: LIST
30409: LIST
30410: LIST
30411: LIST
30412: LIST
30413: LIST
30414: LIST
30415: LIST
30416: LIST
30417: LIST
30418: LIST
30419: LIST
30420: LIST
30421: LIST
30422: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30423: LD_ADDR_VAR 0 15
30427: PUSH
30428: LD_INT 0
30430: PUSH
30431: LD_INT 0
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 0
30440: PUSH
30441: LD_INT 1
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 1
30451: PUSH
30452: LD_INT 0
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PUSH
30459: LD_INT 1
30461: PUSH
30462: LD_INT 1
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 0
30471: PUSH
30472: LD_INT 1
30474: PUSH
30475: EMPTY
30476: LIST
30477: LIST
30478: PUSH
30479: LD_INT 1
30481: NEG
30482: PUSH
30483: LD_INT 0
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 1
30492: NEG
30493: PUSH
30494: LD_INT 1
30496: NEG
30497: PUSH
30498: EMPTY
30499: LIST
30500: LIST
30501: PUSH
30502: LD_INT 1
30504: PUSH
30505: LD_INT 1
30507: NEG
30508: PUSH
30509: EMPTY
30510: LIST
30511: LIST
30512: PUSH
30513: LD_INT 2
30515: PUSH
30516: LD_INT 0
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 2
30525: PUSH
30526: LD_INT 1
30528: PUSH
30529: EMPTY
30530: LIST
30531: LIST
30532: PUSH
30533: LD_INT 1
30535: NEG
30536: PUSH
30537: LD_INT 1
30539: PUSH
30540: EMPTY
30541: LIST
30542: LIST
30543: PUSH
30544: LD_INT 2
30546: NEG
30547: PUSH
30548: LD_INT 0
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PUSH
30555: LD_INT 2
30557: NEG
30558: PUSH
30559: LD_INT 1
30561: NEG
30562: PUSH
30563: EMPTY
30564: LIST
30565: LIST
30566: PUSH
30567: LD_INT 2
30569: PUSH
30570: LD_INT 1
30572: NEG
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 3
30580: PUSH
30581: LD_INT 0
30583: PUSH
30584: EMPTY
30585: LIST
30586: LIST
30587: PUSH
30588: LD_INT 3
30590: PUSH
30591: LD_INT 1
30593: PUSH
30594: EMPTY
30595: LIST
30596: LIST
30597: PUSH
30598: EMPTY
30599: LIST
30600: LIST
30601: LIST
30602: LIST
30603: LIST
30604: LIST
30605: LIST
30606: LIST
30607: LIST
30608: LIST
30609: LIST
30610: LIST
30611: LIST
30612: LIST
30613: LIST
30614: LIST
30615: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30616: LD_ADDR_VAR 0 16
30620: PUSH
30621: LD_INT 0
30623: PUSH
30624: LD_INT 0
30626: PUSH
30627: EMPTY
30628: LIST
30629: LIST
30630: PUSH
30631: LD_INT 0
30633: PUSH
30634: LD_INT 1
30636: NEG
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: LD_INT 0
30647: PUSH
30648: EMPTY
30649: LIST
30650: LIST
30651: PUSH
30652: LD_INT 1
30654: PUSH
30655: LD_INT 1
30657: PUSH
30658: EMPTY
30659: LIST
30660: LIST
30661: PUSH
30662: LD_INT 0
30664: PUSH
30665: LD_INT 1
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: NEG
30675: PUSH
30676: LD_INT 0
30678: PUSH
30679: EMPTY
30680: LIST
30681: LIST
30682: PUSH
30683: LD_INT 1
30685: NEG
30686: PUSH
30687: LD_INT 1
30689: NEG
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 1
30697: NEG
30698: PUSH
30699: LD_INT 2
30701: NEG
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: LD_INT 1
30712: PUSH
30713: EMPTY
30714: LIST
30715: LIST
30716: PUSH
30717: LD_INT 2
30719: PUSH
30720: LD_INT 2
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: PUSH
30727: LD_INT 1
30729: PUSH
30730: LD_INT 2
30732: PUSH
30733: EMPTY
30734: LIST
30735: LIST
30736: PUSH
30737: LD_INT 2
30739: NEG
30740: PUSH
30741: LD_INT 1
30743: NEG
30744: PUSH
30745: EMPTY
30746: LIST
30747: LIST
30748: PUSH
30749: LD_INT 2
30751: NEG
30752: PUSH
30753: LD_INT 2
30755: NEG
30756: PUSH
30757: EMPTY
30758: LIST
30759: LIST
30760: PUSH
30761: LD_INT 3
30763: PUSH
30764: LD_INT 2
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 3
30773: PUSH
30774: LD_INT 3
30776: PUSH
30777: EMPTY
30778: LIST
30779: LIST
30780: PUSH
30781: LD_INT 2
30783: PUSH
30784: LD_INT 3
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: EMPTY
30792: LIST
30793: LIST
30794: LIST
30795: LIST
30796: LIST
30797: LIST
30798: LIST
30799: LIST
30800: LIST
30801: LIST
30802: LIST
30803: LIST
30804: LIST
30805: LIST
30806: LIST
30807: LIST
30808: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30809: LD_ADDR_VAR 0 17
30813: PUSH
30814: LD_INT 0
30816: PUSH
30817: LD_INT 0
30819: PUSH
30820: EMPTY
30821: LIST
30822: LIST
30823: PUSH
30824: LD_INT 0
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: PUSH
30838: LD_INT 0
30840: PUSH
30841: EMPTY
30842: LIST
30843: LIST
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: LD_INT 1
30850: PUSH
30851: EMPTY
30852: LIST
30853: LIST
30854: PUSH
30855: LD_INT 0
30857: PUSH
30858: LD_INT 1
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: NEG
30868: PUSH
30869: LD_INT 0
30871: PUSH
30872: EMPTY
30873: LIST
30874: LIST
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: LD_INT 1
30882: NEG
30883: PUSH
30884: EMPTY
30885: LIST
30886: LIST
30887: PUSH
30888: LD_INT 1
30890: NEG
30891: PUSH
30892: LD_INT 2
30894: NEG
30895: PUSH
30896: EMPTY
30897: LIST
30898: LIST
30899: PUSH
30900: LD_INT 0
30902: PUSH
30903: LD_INT 2
30905: NEG
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 1
30913: PUSH
30914: LD_INT 1
30916: NEG
30917: PUSH
30918: EMPTY
30919: LIST
30920: LIST
30921: PUSH
30922: LD_INT 2
30924: PUSH
30925: LD_INT 0
30927: PUSH
30928: EMPTY
30929: LIST
30930: LIST
30931: PUSH
30932: LD_INT 2
30934: PUSH
30935: LD_INT 1
30937: PUSH
30938: EMPTY
30939: LIST
30940: LIST
30941: PUSH
30942: LD_INT 2
30944: PUSH
30945: LD_INT 2
30947: PUSH
30948: EMPTY
30949: LIST
30950: LIST
30951: PUSH
30952: LD_INT 1
30954: PUSH
30955: LD_INT 2
30957: PUSH
30958: EMPTY
30959: LIST
30960: LIST
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: LD_INT 2
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: LD_INT 1
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 2
30985: NEG
30986: PUSH
30987: LD_INT 0
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 2
30996: NEG
30997: PUSH
30998: LD_INT 1
31000: NEG
31001: PUSH
31002: EMPTY
31003: LIST
31004: LIST
31005: PUSH
31006: LD_INT 2
31008: NEG
31009: PUSH
31010: LD_INT 2
31012: NEG
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: PUSH
31018: EMPTY
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: LIST
31032: LIST
31033: LIST
31034: LIST
31035: LIST
31036: LIST
31037: LIST
31038: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31039: LD_ADDR_VAR 0 18
31043: PUSH
31044: LD_INT 0
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: EMPTY
31051: LIST
31052: LIST
31053: PUSH
31054: LD_INT 0
31056: PUSH
31057: LD_INT 1
31059: NEG
31060: PUSH
31061: EMPTY
31062: LIST
31063: LIST
31064: PUSH
31065: LD_INT 1
31067: PUSH
31068: LD_INT 0
31070: PUSH
31071: EMPTY
31072: LIST
31073: LIST
31074: PUSH
31075: LD_INT 1
31077: PUSH
31078: LD_INT 1
31080: PUSH
31081: EMPTY
31082: LIST
31083: LIST
31084: PUSH
31085: LD_INT 0
31087: PUSH
31088: LD_INT 1
31090: PUSH
31091: EMPTY
31092: LIST
31093: LIST
31094: PUSH
31095: LD_INT 1
31097: NEG
31098: PUSH
31099: LD_INT 0
31101: PUSH
31102: EMPTY
31103: LIST
31104: LIST
31105: PUSH
31106: LD_INT 1
31108: NEG
31109: PUSH
31110: LD_INT 1
31112: NEG
31113: PUSH
31114: EMPTY
31115: LIST
31116: LIST
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: LD_INT 2
31124: NEG
31125: PUSH
31126: EMPTY
31127: LIST
31128: LIST
31129: PUSH
31130: LD_INT 0
31132: PUSH
31133: LD_INT 2
31135: NEG
31136: PUSH
31137: EMPTY
31138: LIST
31139: LIST
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: LD_INT 1
31146: NEG
31147: PUSH
31148: EMPTY
31149: LIST
31150: LIST
31151: PUSH
31152: LD_INT 2
31154: PUSH
31155: LD_INT 0
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: PUSH
31162: LD_INT 2
31164: PUSH
31165: LD_INT 1
31167: PUSH
31168: EMPTY
31169: LIST
31170: LIST
31171: PUSH
31172: LD_INT 2
31174: PUSH
31175: LD_INT 2
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: PUSH
31182: LD_INT 1
31184: PUSH
31185: LD_INT 2
31187: PUSH
31188: EMPTY
31189: LIST
31190: LIST
31191: PUSH
31192: LD_INT 0
31194: PUSH
31195: LD_INT 2
31197: PUSH
31198: EMPTY
31199: LIST
31200: LIST
31201: PUSH
31202: LD_INT 1
31204: NEG
31205: PUSH
31206: LD_INT 1
31208: PUSH
31209: EMPTY
31210: LIST
31211: LIST
31212: PUSH
31213: LD_INT 2
31215: NEG
31216: PUSH
31217: LD_INT 0
31219: PUSH
31220: EMPTY
31221: LIST
31222: LIST
31223: PUSH
31224: LD_INT 2
31226: NEG
31227: PUSH
31228: LD_INT 1
31230: NEG
31231: PUSH
31232: EMPTY
31233: LIST
31234: LIST
31235: PUSH
31236: LD_INT 2
31238: NEG
31239: PUSH
31240: LD_INT 2
31242: NEG
31243: PUSH
31244: EMPTY
31245: LIST
31246: LIST
31247: PUSH
31248: EMPTY
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: LIST
31262: LIST
31263: LIST
31264: LIST
31265: LIST
31266: LIST
31267: LIST
31268: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31269: LD_ADDR_VAR 0 19
31273: PUSH
31274: LD_INT 0
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 0
31286: PUSH
31287: LD_INT 1
31289: NEG
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 1
31297: PUSH
31298: LD_INT 0
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: LD_INT 1
31310: PUSH
31311: EMPTY
31312: LIST
31313: LIST
31314: PUSH
31315: LD_INT 0
31317: PUSH
31318: LD_INT 1
31320: PUSH
31321: EMPTY
31322: LIST
31323: LIST
31324: PUSH
31325: LD_INT 1
31327: NEG
31328: PUSH
31329: LD_INT 0
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 1
31338: NEG
31339: PUSH
31340: LD_INT 1
31342: NEG
31343: PUSH
31344: EMPTY
31345: LIST
31346: LIST
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: LD_INT 2
31354: NEG
31355: PUSH
31356: EMPTY
31357: LIST
31358: LIST
31359: PUSH
31360: LD_INT 0
31362: PUSH
31363: LD_INT 2
31365: NEG
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 1
31376: NEG
31377: PUSH
31378: EMPTY
31379: LIST
31380: LIST
31381: PUSH
31382: LD_INT 2
31384: PUSH
31385: LD_INT 0
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: PUSH
31392: LD_INT 2
31394: PUSH
31395: LD_INT 1
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: PUSH
31405: LD_INT 2
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 1
31414: PUSH
31415: LD_INT 2
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 0
31424: PUSH
31425: LD_INT 2
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 1
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: LD_INT 0
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: LD_INT 2
31456: NEG
31457: PUSH
31458: LD_INT 1
31460: NEG
31461: PUSH
31462: EMPTY
31463: LIST
31464: LIST
31465: PUSH
31466: LD_INT 2
31468: NEG
31469: PUSH
31470: LD_INT 2
31472: NEG
31473: PUSH
31474: EMPTY
31475: LIST
31476: LIST
31477: PUSH
31478: EMPTY
31479: LIST
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31499: LD_ADDR_VAR 0 20
31503: PUSH
31504: LD_INT 0
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: EMPTY
31511: LIST
31512: LIST
31513: PUSH
31514: LD_INT 0
31516: PUSH
31517: LD_INT 1
31519: NEG
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 1
31527: PUSH
31528: LD_INT 0
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: LD_INT 1
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 0
31547: PUSH
31548: LD_INT 1
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: LD_INT 1
31557: NEG
31558: PUSH
31559: LD_INT 0
31561: PUSH
31562: EMPTY
31563: LIST
31564: LIST
31565: PUSH
31566: LD_INT 1
31568: NEG
31569: PUSH
31570: LD_INT 1
31572: NEG
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: PUSH
31578: LD_INT 1
31580: NEG
31581: PUSH
31582: LD_INT 2
31584: NEG
31585: PUSH
31586: EMPTY
31587: LIST
31588: LIST
31589: PUSH
31590: LD_INT 0
31592: PUSH
31593: LD_INT 2
31595: NEG
31596: PUSH
31597: EMPTY
31598: LIST
31599: LIST
31600: PUSH
31601: LD_INT 1
31603: PUSH
31604: LD_INT 1
31606: NEG
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 2
31614: PUSH
31615: LD_INT 0
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 2
31624: PUSH
31625: LD_INT 1
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 2
31634: PUSH
31635: LD_INT 2
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: PUSH
31645: LD_INT 2
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: LD_INT 0
31654: PUSH
31655: LD_INT 2
31657: PUSH
31658: EMPTY
31659: LIST
31660: LIST
31661: PUSH
31662: LD_INT 1
31664: NEG
31665: PUSH
31666: LD_INT 1
31668: PUSH
31669: EMPTY
31670: LIST
31671: LIST
31672: PUSH
31673: LD_INT 2
31675: NEG
31676: PUSH
31677: LD_INT 0
31679: PUSH
31680: EMPTY
31681: LIST
31682: LIST
31683: PUSH
31684: LD_INT 2
31686: NEG
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: PUSH
31696: LD_INT 2
31698: NEG
31699: PUSH
31700: LD_INT 2
31702: NEG
31703: PUSH
31704: EMPTY
31705: LIST
31706: LIST
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: LIST
31722: LIST
31723: LIST
31724: LIST
31725: LIST
31726: LIST
31727: LIST
31728: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31729: LD_ADDR_VAR 0 21
31733: PUSH
31734: LD_INT 0
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: EMPTY
31741: LIST
31742: LIST
31743: PUSH
31744: LD_INT 0
31746: PUSH
31747: LD_INT 1
31749: NEG
31750: PUSH
31751: EMPTY
31752: LIST
31753: LIST
31754: PUSH
31755: LD_INT 1
31757: PUSH
31758: LD_INT 0
31760: PUSH
31761: EMPTY
31762: LIST
31763: LIST
31764: PUSH
31765: LD_INT 1
31767: PUSH
31768: LD_INT 1
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PUSH
31775: LD_INT 0
31777: PUSH
31778: LD_INT 1
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: NEG
31788: PUSH
31789: LD_INT 0
31791: PUSH
31792: EMPTY
31793: LIST
31794: LIST
31795: PUSH
31796: LD_INT 1
31798: NEG
31799: PUSH
31800: LD_INT 1
31802: NEG
31803: PUSH
31804: EMPTY
31805: LIST
31806: LIST
31807: PUSH
31808: LD_INT 1
31810: NEG
31811: PUSH
31812: LD_INT 2
31814: NEG
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 0
31822: PUSH
31823: LD_INT 2
31825: NEG
31826: PUSH
31827: EMPTY
31828: LIST
31829: LIST
31830: PUSH
31831: LD_INT 1
31833: PUSH
31834: LD_INT 1
31836: NEG
31837: PUSH
31838: EMPTY
31839: LIST
31840: LIST
31841: PUSH
31842: LD_INT 2
31844: PUSH
31845: LD_INT 0
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: PUSH
31852: LD_INT 2
31854: PUSH
31855: LD_INT 1
31857: PUSH
31858: EMPTY
31859: LIST
31860: LIST
31861: PUSH
31862: LD_INT 2
31864: PUSH
31865: LD_INT 2
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 1
31874: PUSH
31875: LD_INT 2
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 0
31884: PUSH
31885: LD_INT 2
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 1
31894: NEG
31895: PUSH
31896: LD_INT 1
31898: PUSH
31899: EMPTY
31900: LIST
31901: LIST
31902: PUSH
31903: LD_INT 2
31905: NEG
31906: PUSH
31907: LD_INT 0
31909: PUSH
31910: EMPTY
31911: LIST
31912: LIST
31913: PUSH
31914: LD_INT 2
31916: NEG
31917: PUSH
31918: LD_INT 1
31920: NEG
31921: PUSH
31922: EMPTY
31923: LIST
31924: LIST
31925: PUSH
31926: LD_INT 2
31928: NEG
31929: PUSH
31930: LD_INT 2
31932: NEG
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: LIST
31952: LIST
31953: LIST
31954: LIST
31955: LIST
31956: LIST
31957: LIST
31958: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31959: LD_ADDR_VAR 0 22
31963: PUSH
31964: LD_INT 0
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: EMPTY
31971: LIST
31972: LIST
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: LD_INT 1
31979: NEG
31980: PUSH
31981: EMPTY
31982: LIST
31983: LIST
31984: PUSH
31985: LD_INT 1
31987: PUSH
31988: LD_INT 0
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: PUSH
31995: LD_INT 1
31997: PUSH
31998: LD_INT 1
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 0
32007: PUSH
32008: LD_INT 1
32010: PUSH
32011: EMPTY
32012: LIST
32013: LIST
32014: PUSH
32015: LD_INT 1
32017: NEG
32018: PUSH
32019: LD_INT 0
32021: PUSH
32022: EMPTY
32023: LIST
32024: LIST
32025: PUSH
32026: LD_INT 1
32028: NEG
32029: PUSH
32030: LD_INT 1
32032: NEG
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: LD_INT 2
32044: NEG
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PUSH
32050: LD_INT 0
32052: PUSH
32053: LD_INT 2
32055: NEG
32056: PUSH
32057: EMPTY
32058: LIST
32059: LIST
32060: PUSH
32061: LD_INT 1
32063: PUSH
32064: LD_INT 1
32066: NEG
32067: PUSH
32068: EMPTY
32069: LIST
32070: LIST
32071: PUSH
32072: LD_INT 2
32074: PUSH
32075: LD_INT 0
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: PUSH
32082: LD_INT 2
32084: PUSH
32085: LD_INT 1
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 2
32094: PUSH
32095: LD_INT 2
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 1
32104: PUSH
32105: LD_INT 2
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: LD_INT 2
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: NEG
32125: PUSH
32126: LD_INT 1
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 2
32135: NEG
32136: PUSH
32137: LD_INT 0
32139: PUSH
32140: EMPTY
32141: LIST
32142: LIST
32143: PUSH
32144: LD_INT 2
32146: NEG
32147: PUSH
32148: LD_INT 1
32150: NEG
32151: PUSH
32152: EMPTY
32153: LIST
32154: LIST
32155: PUSH
32156: LD_INT 2
32158: NEG
32159: PUSH
32160: LD_INT 2
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: EMPTY
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: LIST
32182: LIST
32183: LIST
32184: LIST
32185: LIST
32186: LIST
32187: LIST
32188: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32189: LD_ADDR_VAR 0 23
32193: PUSH
32194: LD_INT 0
32196: PUSH
32197: LD_INT 0
32199: PUSH
32200: EMPTY
32201: LIST
32202: LIST
32203: PUSH
32204: LD_INT 0
32206: PUSH
32207: LD_INT 1
32209: NEG
32210: PUSH
32211: EMPTY
32212: LIST
32213: LIST
32214: PUSH
32215: LD_INT 1
32217: PUSH
32218: LD_INT 0
32220: PUSH
32221: EMPTY
32222: LIST
32223: LIST
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: LD_INT 1
32230: PUSH
32231: EMPTY
32232: LIST
32233: LIST
32234: PUSH
32235: LD_INT 0
32237: PUSH
32238: LD_INT 1
32240: PUSH
32241: EMPTY
32242: LIST
32243: LIST
32244: PUSH
32245: LD_INT 1
32247: NEG
32248: PUSH
32249: LD_INT 0
32251: PUSH
32252: EMPTY
32253: LIST
32254: LIST
32255: PUSH
32256: LD_INT 1
32258: NEG
32259: PUSH
32260: LD_INT 1
32262: NEG
32263: PUSH
32264: EMPTY
32265: LIST
32266: LIST
32267: PUSH
32268: LD_INT 1
32270: NEG
32271: PUSH
32272: LD_INT 2
32274: NEG
32275: PUSH
32276: EMPTY
32277: LIST
32278: LIST
32279: PUSH
32280: LD_INT 0
32282: PUSH
32283: LD_INT 2
32285: NEG
32286: PUSH
32287: EMPTY
32288: LIST
32289: LIST
32290: PUSH
32291: LD_INT 1
32293: PUSH
32294: LD_INT 1
32296: NEG
32297: PUSH
32298: EMPTY
32299: LIST
32300: LIST
32301: PUSH
32302: LD_INT 2
32304: PUSH
32305: LD_INT 0
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: PUSH
32312: LD_INT 2
32314: PUSH
32315: LD_INT 1
32317: PUSH
32318: EMPTY
32319: LIST
32320: LIST
32321: PUSH
32322: LD_INT 2
32324: PUSH
32325: LD_INT 2
32327: PUSH
32328: EMPTY
32329: LIST
32330: LIST
32331: PUSH
32332: LD_INT 1
32334: PUSH
32335: LD_INT 2
32337: PUSH
32338: EMPTY
32339: LIST
32340: LIST
32341: PUSH
32342: LD_INT 0
32344: PUSH
32345: LD_INT 2
32347: PUSH
32348: EMPTY
32349: LIST
32350: LIST
32351: PUSH
32352: LD_INT 1
32354: NEG
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: EMPTY
32360: LIST
32361: LIST
32362: PUSH
32363: LD_INT 2
32365: NEG
32366: PUSH
32367: LD_INT 0
32369: PUSH
32370: EMPTY
32371: LIST
32372: LIST
32373: PUSH
32374: LD_INT 2
32376: NEG
32377: PUSH
32378: LD_INT 1
32380: NEG
32381: PUSH
32382: EMPTY
32383: LIST
32384: LIST
32385: PUSH
32386: LD_INT 2
32388: NEG
32389: PUSH
32390: LD_INT 2
32392: NEG
32393: PUSH
32394: EMPTY
32395: LIST
32396: LIST
32397: PUSH
32398: LD_INT 2
32400: NEG
32401: PUSH
32402: LD_INT 3
32404: NEG
32405: PUSH
32406: EMPTY
32407: LIST
32408: LIST
32409: PUSH
32410: LD_INT 1
32412: NEG
32413: PUSH
32414: LD_INT 3
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 2
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: LD_INT 1
32438: NEG
32439: PUSH
32440: EMPTY
32441: LIST
32442: LIST
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: LIST
32448: LIST
32449: LIST
32450: LIST
32451: LIST
32452: LIST
32453: LIST
32454: LIST
32455: LIST
32456: LIST
32457: LIST
32458: LIST
32459: LIST
32460: LIST
32461: LIST
32462: LIST
32463: LIST
32464: LIST
32465: LIST
32466: LIST
32467: LIST
32468: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32469: LD_ADDR_VAR 0 24
32473: PUSH
32474: LD_INT 0
32476: PUSH
32477: LD_INT 0
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 0
32486: PUSH
32487: LD_INT 1
32489: NEG
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 1
32497: PUSH
32498: LD_INT 0
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 1
32507: PUSH
32508: LD_INT 1
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: LD_INT 0
32517: PUSH
32518: LD_INT 1
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 1
32527: NEG
32528: PUSH
32529: LD_INT 0
32531: PUSH
32532: EMPTY
32533: LIST
32534: LIST
32535: PUSH
32536: LD_INT 1
32538: NEG
32539: PUSH
32540: LD_INT 1
32542: NEG
32543: PUSH
32544: EMPTY
32545: LIST
32546: LIST
32547: PUSH
32548: LD_INT 1
32550: NEG
32551: PUSH
32552: LD_INT 2
32554: NEG
32555: PUSH
32556: EMPTY
32557: LIST
32558: LIST
32559: PUSH
32560: LD_INT 0
32562: PUSH
32563: LD_INT 2
32565: NEG
32566: PUSH
32567: EMPTY
32568: LIST
32569: LIST
32570: PUSH
32571: LD_INT 1
32573: PUSH
32574: LD_INT 1
32576: NEG
32577: PUSH
32578: EMPTY
32579: LIST
32580: LIST
32581: PUSH
32582: LD_INT 2
32584: PUSH
32585: LD_INT 0
32587: PUSH
32588: EMPTY
32589: LIST
32590: LIST
32591: PUSH
32592: LD_INT 2
32594: PUSH
32595: LD_INT 1
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: PUSH
32602: LD_INT 2
32604: PUSH
32605: LD_INT 2
32607: PUSH
32608: EMPTY
32609: LIST
32610: LIST
32611: PUSH
32612: LD_INT 1
32614: PUSH
32615: LD_INT 2
32617: PUSH
32618: EMPTY
32619: LIST
32620: LIST
32621: PUSH
32622: LD_INT 0
32624: PUSH
32625: LD_INT 2
32627: PUSH
32628: EMPTY
32629: LIST
32630: LIST
32631: PUSH
32632: LD_INT 1
32634: NEG
32635: PUSH
32636: LD_INT 1
32638: PUSH
32639: EMPTY
32640: LIST
32641: LIST
32642: PUSH
32643: LD_INT 2
32645: NEG
32646: PUSH
32647: LD_INT 0
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 2
32656: NEG
32657: PUSH
32658: LD_INT 1
32660: NEG
32661: PUSH
32662: EMPTY
32663: LIST
32664: LIST
32665: PUSH
32666: LD_INT 2
32668: NEG
32669: PUSH
32670: LD_INT 2
32672: NEG
32673: PUSH
32674: EMPTY
32675: LIST
32676: LIST
32677: PUSH
32678: LD_INT 1
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 2
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 3
32702: PUSH
32703: LD_INT 1
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 3
32712: PUSH
32713: LD_INT 2
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: EMPTY
32721: LIST
32722: LIST
32723: LIST
32724: LIST
32725: LIST
32726: LIST
32727: LIST
32728: LIST
32729: LIST
32730: LIST
32731: LIST
32732: LIST
32733: LIST
32734: LIST
32735: LIST
32736: LIST
32737: LIST
32738: LIST
32739: LIST
32740: LIST
32741: LIST
32742: LIST
32743: LIST
32744: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32745: LD_ADDR_VAR 0 25
32749: PUSH
32750: LD_INT 0
32752: PUSH
32753: LD_INT 0
32755: PUSH
32756: EMPTY
32757: LIST
32758: LIST
32759: PUSH
32760: LD_INT 0
32762: PUSH
32763: LD_INT 1
32765: NEG
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 1
32773: PUSH
32774: LD_INT 0
32776: PUSH
32777: EMPTY
32778: LIST
32779: LIST
32780: PUSH
32781: LD_INT 1
32783: PUSH
32784: LD_INT 1
32786: PUSH
32787: EMPTY
32788: LIST
32789: LIST
32790: PUSH
32791: LD_INT 0
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: EMPTY
32798: LIST
32799: LIST
32800: PUSH
32801: LD_INT 1
32803: NEG
32804: PUSH
32805: LD_INT 0
32807: PUSH
32808: EMPTY
32809: LIST
32810: LIST
32811: PUSH
32812: LD_INT 1
32814: NEG
32815: PUSH
32816: LD_INT 1
32818: NEG
32819: PUSH
32820: EMPTY
32821: LIST
32822: LIST
32823: PUSH
32824: LD_INT 1
32826: NEG
32827: PUSH
32828: LD_INT 2
32830: NEG
32831: PUSH
32832: EMPTY
32833: LIST
32834: LIST
32835: PUSH
32836: LD_INT 0
32838: PUSH
32839: LD_INT 2
32841: NEG
32842: PUSH
32843: EMPTY
32844: LIST
32845: LIST
32846: PUSH
32847: LD_INT 1
32849: PUSH
32850: LD_INT 1
32852: NEG
32853: PUSH
32854: EMPTY
32855: LIST
32856: LIST
32857: PUSH
32858: LD_INT 2
32860: PUSH
32861: LD_INT 0
32863: PUSH
32864: EMPTY
32865: LIST
32866: LIST
32867: PUSH
32868: LD_INT 2
32870: PUSH
32871: LD_INT 1
32873: PUSH
32874: EMPTY
32875: LIST
32876: LIST
32877: PUSH
32878: LD_INT 2
32880: PUSH
32881: LD_INT 2
32883: PUSH
32884: EMPTY
32885: LIST
32886: LIST
32887: PUSH
32888: LD_INT 1
32890: PUSH
32891: LD_INT 2
32893: PUSH
32894: EMPTY
32895: LIST
32896: LIST
32897: PUSH
32898: LD_INT 0
32900: PUSH
32901: LD_INT 2
32903: PUSH
32904: EMPTY
32905: LIST
32906: LIST
32907: PUSH
32908: LD_INT 1
32910: NEG
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: EMPTY
32916: LIST
32917: LIST
32918: PUSH
32919: LD_INT 2
32921: NEG
32922: PUSH
32923: LD_INT 0
32925: PUSH
32926: EMPTY
32927: LIST
32928: LIST
32929: PUSH
32930: LD_INT 2
32932: NEG
32933: PUSH
32934: LD_INT 1
32936: NEG
32937: PUSH
32938: EMPTY
32939: LIST
32940: LIST
32941: PUSH
32942: LD_INT 2
32944: NEG
32945: PUSH
32946: LD_INT 2
32948: NEG
32949: PUSH
32950: EMPTY
32951: LIST
32952: LIST
32953: PUSH
32954: LD_INT 3
32956: PUSH
32957: LD_INT 1
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 3
32966: PUSH
32967: LD_INT 2
32969: PUSH
32970: EMPTY
32971: LIST
32972: LIST
32973: PUSH
32974: LD_INT 2
32976: PUSH
32977: LD_INT 3
32979: PUSH
32980: EMPTY
32981: LIST
32982: LIST
32983: PUSH
32984: LD_INT 1
32986: PUSH
32987: LD_INT 3
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: LIST
32998: LIST
32999: LIST
33000: LIST
33001: LIST
33002: LIST
33003: LIST
33004: LIST
33005: LIST
33006: LIST
33007: LIST
33008: LIST
33009: LIST
33010: LIST
33011: LIST
33012: LIST
33013: LIST
33014: LIST
33015: LIST
33016: LIST
33017: LIST
33018: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33019: LD_ADDR_VAR 0 26
33023: PUSH
33024: LD_INT 0
33026: PUSH
33027: LD_INT 0
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 0
33036: PUSH
33037: LD_INT 1
33039: NEG
33040: PUSH
33041: EMPTY
33042: LIST
33043: LIST
33044: PUSH
33045: LD_INT 1
33047: PUSH
33048: LD_INT 0
33050: PUSH
33051: EMPTY
33052: LIST
33053: LIST
33054: PUSH
33055: LD_INT 1
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 0
33067: PUSH
33068: LD_INT 1
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: NEG
33078: PUSH
33079: LD_INT 0
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 1
33088: NEG
33089: PUSH
33090: LD_INT 1
33092: NEG
33093: PUSH
33094: EMPTY
33095: LIST
33096: LIST
33097: PUSH
33098: LD_INT 1
33100: NEG
33101: PUSH
33102: LD_INT 2
33104: NEG
33105: PUSH
33106: EMPTY
33107: LIST
33108: LIST
33109: PUSH
33110: LD_INT 0
33112: PUSH
33113: LD_INT 2
33115: NEG
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 1
33123: PUSH
33124: LD_INT 1
33126: NEG
33127: PUSH
33128: EMPTY
33129: LIST
33130: LIST
33131: PUSH
33132: LD_INT 2
33134: PUSH
33135: LD_INT 0
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 2
33144: PUSH
33145: LD_INT 1
33147: PUSH
33148: EMPTY
33149: LIST
33150: LIST
33151: PUSH
33152: LD_INT 2
33154: PUSH
33155: LD_INT 2
33157: PUSH
33158: EMPTY
33159: LIST
33160: LIST
33161: PUSH
33162: LD_INT 1
33164: PUSH
33165: LD_INT 2
33167: PUSH
33168: EMPTY
33169: LIST
33170: LIST
33171: PUSH
33172: LD_INT 0
33174: PUSH
33175: LD_INT 2
33177: PUSH
33178: EMPTY
33179: LIST
33180: LIST
33181: PUSH
33182: LD_INT 1
33184: NEG
33185: PUSH
33186: LD_INT 1
33188: PUSH
33189: EMPTY
33190: LIST
33191: LIST
33192: PUSH
33193: LD_INT 2
33195: NEG
33196: PUSH
33197: LD_INT 0
33199: PUSH
33200: EMPTY
33201: LIST
33202: LIST
33203: PUSH
33204: LD_INT 2
33206: NEG
33207: PUSH
33208: LD_INT 1
33210: NEG
33211: PUSH
33212: EMPTY
33213: LIST
33214: LIST
33215: PUSH
33216: LD_INT 2
33218: NEG
33219: PUSH
33220: LD_INT 2
33222: NEG
33223: PUSH
33224: EMPTY
33225: LIST
33226: LIST
33227: PUSH
33228: LD_INT 2
33230: PUSH
33231: LD_INT 3
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: PUSH
33241: LD_INT 3
33243: PUSH
33244: EMPTY
33245: LIST
33246: LIST
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: LD_INT 2
33254: PUSH
33255: EMPTY
33256: LIST
33257: LIST
33258: PUSH
33259: LD_INT 2
33261: NEG
33262: PUSH
33263: LD_INT 1
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: EMPTY
33271: LIST
33272: LIST
33273: LIST
33274: LIST
33275: LIST
33276: LIST
33277: LIST
33278: LIST
33279: LIST
33280: LIST
33281: LIST
33282: LIST
33283: LIST
33284: LIST
33285: LIST
33286: LIST
33287: LIST
33288: LIST
33289: LIST
33290: LIST
33291: LIST
33292: LIST
33293: LIST
33294: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33295: LD_ADDR_VAR 0 27
33299: PUSH
33300: LD_INT 0
33302: PUSH
33303: LD_INT 0
33305: PUSH
33306: EMPTY
33307: LIST
33308: LIST
33309: PUSH
33310: LD_INT 0
33312: PUSH
33313: LD_INT 1
33315: NEG
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 1
33323: PUSH
33324: LD_INT 0
33326: PUSH
33327: EMPTY
33328: LIST
33329: LIST
33330: PUSH
33331: LD_INT 1
33333: PUSH
33334: LD_INT 1
33336: PUSH
33337: EMPTY
33338: LIST
33339: LIST
33340: PUSH
33341: LD_INT 0
33343: PUSH
33344: LD_INT 1
33346: PUSH
33347: EMPTY
33348: LIST
33349: LIST
33350: PUSH
33351: LD_INT 1
33353: NEG
33354: PUSH
33355: LD_INT 0
33357: PUSH
33358: EMPTY
33359: LIST
33360: LIST
33361: PUSH
33362: LD_INT 1
33364: NEG
33365: PUSH
33366: LD_INT 1
33368: NEG
33369: PUSH
33370: EMPTY
33371: LIST
33372: LIST
33373: PUSH
33374: LD_INT 1
33376: NEG
33377: PUSH
33378: LD_INT 2
33380: NEG
33381: PUSH
33382: EMPTY
33383: LIST
33384: LIST
33385: PUSH
33386: LD_INT 0
33388: PUSH
33389: LD_INT 2
33391: NEG
33392: PUSH
33393: EMPTY
33394: LIST
33395: LIST
33396: PUSH
33397: LD_INT 1
33399: PUSH
33400: LD_INT 1
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: LD_INT 2
33410: PUSH
33411: LD_INT 0
33413: PUSH
33414: EMPTY
33415: LIST
33416: LIST
33417: PUSH
33418: LD_INT 2
33420: PUSH
33421: LD_INT 1
33423: PUSH
33424: EMPTY
33425: LIST
33426: LIST
33427: PUSH
33428: LD_INT 2
33430: PUSH
33431: LD_INT 2
33433: PUSH
33434: EMPTY
33435: LIST
33436: LIST
33437: PUSH
33438: LD_INT 1
33440: PUSH
33441: LD_INT 2
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 2
33453: PUSH
33454: EMPTY
33455: LIST
33456: LIST
33457: PUSH
33458: LD_INT 1
33460: NEG
33461: PUSH
33462: LD_INT 1
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 2
33471: NEG
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: EMPTY
33477: LIST
33478: LIST
33479: PUSH
33480: LD_INT 2
33482: NEG
33483: PUSH
33484: LD_INT 1
33486: NEG
33487: PUSH
33488: EMPTY
33489: LIST
33490: LIST
33491: PUSH
33492: LD_INT 2
33494: NEG
33495: PUSH
33496: LD_INT 2
33498: NEG
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: LD_INT 2
33510: PUSH
33511: EMPTY
33512: LIST
33513: LIST
33514: PUSH
33515: LD_INT 2
33517: NEG
33518: PUSH
33519: LD_INT 1
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 3
33528: NEG
33529: PUSH
33530: LD_INT 1
33532: NEG
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 3
33540: NEG
33541: PUSH
33542: LD_INT 2
33544: NEG
33545: PUSH
33546: EMPTY
33547: LIST
33548: LIST
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: LIST
33554: LIST
33555: LIST
33556: LIST
33557: LIST
33558: LIST
33559: LIST
33560: LIST
33561: LIST
33562: LIST
33563: LIST
33564: LIST
33565: LIST
33566: LIST
33567: LIST
33568: LIST
33569: LIST
33570: LIST
33571: LIST
33572: LIST
33573: LIST
33574: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33575: LD_ADDR_VAR 0 28
33579: PUSH
33580: LD_INT 0
33582: PUSH
33583: LD_INT 0
33585: PUSH
33586: EMPTY
33587: LIST
33588: LIST
33589: PUSH
33590: LD_INT 0
33592: PUSH
33593: LD_INT 1
33595: NEG
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: PUSH
33604: LD_INT 0
33606: PUSH
33607: EMPTY
33608: LIST
33609: LIST
33610: PUSH
33611: LD_INT 1
33613: PUSH
33614: LD_INT 1
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: PUSH
33621: LD_INT 0
33623: PUSH
33624: LD_INT 1
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 1
33633: NEG
33634: PUSH
33635: LD_INT 0
33637: PUSH
33638: EMPTY
33639: LIST
33640: LIST
33641: PUSH
33642: LD_INT 1
33644: NEG
33645: PUSH
33646: LD_INT 1
33648: NEG
33649: PUSH
33650: EMPTY
33651: LIST
33652: LIST
33653: PUSH
33654: LD_INT 1
33656: NEG
33657: PUSH
33658: LD_INT 2
33660: NEG
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 0
33668: PUSH
33669: LD_INT 2
33671: NEG
33672: PUSH
33673: EMPTY
33674: LIST
33675: LIST
33676: PUSH
33677: LD_INT 1
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: LD_INT 2
33690: PUSH
33691: LD_INT 0
33693: PUSH
33694: EMPTY
33695: LIST
33696: LIST
33697: PUSH
33698: LD_INT 2
33700: PUSH
33701: LD_INT 1
33703: PUSH
33704: EMPTY
33705: LIST
33706: LIST
33707: PUSH
33708: LD_INT 2
33710: PUSH
33711: LD_INT 2
33713: PUSH
33714: EMPTY
33715: LIST
33716: LIST
33717: PUSH
33718: LD_INT 1
33720: PUSH
33721: LD_INT 2
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: LD_INT 2
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 1
33740: NEG
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 2
33751: NEG
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: EMPTY
33757: LIST
33758: LIST
33759: PUSH
33760: LD_INT 2
33762: NEG
33763: PUSH
33764: LD_INT 1
33766: NEG
33767: PUSH
33768: EMPTY
33769: LIST
33770: LIST
33771: PUSH
33772: LD_INT 2
33774: NEG
33775: PUSH
33776: LD_INT 2
33778: NEG
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 2
33786: NEG
33787: PUSH
33788: LD_INT 3
33790: NEG
33791: PUSH
33792: EMPTY
33793: LIST
33794: LIST
33795: PUSH
33796: LD_INT 1
33798: NEG
33799: PUSH
33800: LD_INT 3
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 3
33810: NEG
33811: PUSH
33812: LD_INT 1
33814: NEG
33815: PUSH
33816: EMPTY
33817: LIST
33818: LIST
33819: PUSH
33820: LD_INT 3
33822: NEG
33823: PUSH
33824: LD_INT 2
33826: NEG
33827: PUSH
33828: EMPTY
33829: LIST
33830: LIST
33831: PUSH
33832: EMPTY
33833: LIST
33834: LIST
33835: LIST
33836: LIST
33837: LIST
33838: LIST
33839: LIST
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: LIST
33850: LIST
33851: LIST
33852: LIST
33853: LIST
33854: LIST
33855: LIST
33856: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33857: LD_ADDR_VAR 0 29
33861: PUSH
33862: LD_INT 0
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: EMPTY
33869: LIST
33870: LIST
33871: PUSH
33872: LD_INT 0
33874: PUSH
33875: LD_INT 1
33877: NEG
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: PUSH
33883: LD_INT 1
33885: PUSH
33886: LD_INT 0
33888: PUSH
33889: EMPTY
33890: LIST
33891: LIST
33892: PUSH
33893: LD_INT 1
33895: PUSH
33896: LD_INT 1
33898: PUSH
33899: EMPTY
33900: LIST
33901: LIST
33902: PUSH
33903: LD_INT 0
33905: PUSH
33906: LD_INT 1
33908: PUSH
33909: EMPTY
33910: LIST
33911: LIST
33912: PUSH
33913: LD_INT 1
33915: NEG
33916: PUSH
33917: LD_INT 0
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 1
33926: NEG
33927: PUSH
33928: LD_INT 1
33930: NEG
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: LD_INT 2
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 0
33950: PUSH
33951: LD_INT 2
33953: NEG
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PUSH
33959: LD_INT 1
33961: PUSH
33962: LD_INT 1
33964: NEG
33965: PUSH
33966: EMPTY
33967: LIST
33968: LIST
33969: PUSH
33970: LD_INT 2
33972: PUSH
33973: LD_INT 0
33975: PUSH
33976: EMPTY
33977: LIST
33978: LIST
33979: PUSH
33980: LD_INT 2
33982: PUSH
33983: LD_INT 1
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 1
33992: PUSH
33993: LD_INT 2
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: LD_INT 0
34002: PUSH
34003: LD_INT 2
34005: PUSH
34006: EMPTY
34007: LIST
34008: LIST
34009: PUSH
34010: LD_INT 1
34012: NEG
34013: PUSH
34014: LD_INT 1
34016: PUSH
34017: EMPTY
34018: LIST
34019: LIST
34020: PUSH
34021: LD_INT 2
34023: NEG
34024: PUSH
34025: LD_INT 1
34027: NEG
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 2
34035: NEG
34036: PUSH
34037: LD_INT 2
34039: NEG
34040: PUSH
34041: EMPTY
34042: LIST
34043: LIST
34044: PUSH
34045: LD_INT 2
34047: NEG
34048: PUSH
34049: LD_INT 3
34051: NEG
34052: PUSH
34053: EMPTY
34054: LIST
34055: LIST
34056: PUSH
34057: LD_INT 2
34059: PUSH
34060: LD_INT 1
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 3
34070: PUSH
34071: LD_INT 1
34073: PUSH
34074: EMPTY
34075: LIST
34076: LIST
34077: PUSH
34078: LD_INT 1
34080: PUSH
34081: LD_INT 3
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 1
34090: NEG
34091: PUSH
34092: LD_INT 2
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 3
34101: NEG
34102: PUSH
34103: LD_INT 2
34105: NEG
34106: PUSH
34107: EMPTY
34108: LIST
34109: LIST
34110: PUSH
34111: EMPTY
34112: LIST
34113: LIST
34114: LIST
34115: LIST
34116: LIST
34117: LIST
34118: LIST
34119: LIST
34120: LIST
34121: LIST
34122: LIST
34123: LIST
34124: LIST
34125: LIST
34126: LIST
34127: LIST
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: LIST
34133: LIST
34134: LIST
34135: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34136: LD_ADDR_VAR 0 30
34140: PUSH
34141: LD_INT 0
34143: PUSH
34144: LD_INT 0
34146: PUSH
34147: EMPTY
34148: LIST
34149: LIST
34150: PUSH
34151: LD_INT 0
34153: PUSH
34154: LD_INT 1
34156: NEG
34157: PUSH
34158: EMPTY
34159: LIST
34160: LIST
34161: PUSH
34162: LD_INT 1
34164: PUSH
34165: LD_INT 0
34167: PUSH
34168: EMPTY
34169: LIST
34170: LIST
34171: PUSH
34172: LD_INT 1
34174: PUSH
34175: LD_INT 1
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 0
34184: PUSH
34185: LD_INT 1
34187: PUSH
34188: EMPTY
34189: LIST
34190: LIST
34191: PUSH
34192: LD_INT 1
34194: NEG
34195: PUSH
34196: LD_INT 0
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 1
34205: NEG
34206: PUSH
34207: LD_INT 1
34209: NEG
34210: PUSH
34211: EMPTY
34212: LIST
34213: LIST
34214: PUSH
34215: LD_INT 1
34217: NEG
34218: PUSH
34219: LD_INT 2
34221: NEG
34222: PUSH
34223: EMPTY
34224: LIST
34225: LIST
34226: PUSH
34227: LD_INT 0
34229: PUSH
34230: LD_INT 2
34232: NEG
34233: PUSH
34234: EMPTY
34235: LIST
34236: LIST
34237: PUSH
34238: LD_INT 1
34240: PUSH
34241: LD_INT 1
34243: NEG
34244: PUSH
34245: EMPTY
34246: LIST
34247: LIST
34248: PUSH
34249: LD_INT 2
34251: PUSH
34252: LD_INT 0
34254: PUSH
34255: EMPTY
34256: LIST
34257: LIST
34258: PUSH
34259: LD_INT 2
34261: PUSH
34262: LD_INT 1
34264: PUSH
34265: EMPTY
34266: LIST
34267: LIST
34268: PUSH
34269: LD_INT 2
34271: PUSH
34272: LD_INT 2
34274: PUSH
34275: EMPTY
34276: LIST
34277: LIST
34278: PUSH
34279: LD_INT 1
34281: PUSH
34282: LD_INT 2
34284: PUSH
34285: EMPTY
34286: LIST
34287: LIST
34288: PUSH
34289: LD_INT 1
34291: NEG
34292: PUSH
34293: LD_INT 1
34295: PUSH
34296: EMPTY
34297: LIST
34298: LIST
34299: PUSH
34300: LD_INT 2
34302: NEG
34303: PUSH
34304: LD_INT 0
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 2
34313: NEG
34314: PUSH
34315: LD_INT 1
34317: NEG
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: LD_INT 3
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: PUSH
34338: LD_INT 2
34340: NEG
34341: PUSH
34342: EMPTY
34343: LIST
34344: LIST
34345: PUSH
34346: LD_INT 3
34348: PUSH
34349: LD_INT 2
34351: PUSH
34352: EMPTY
34353: LIST
34354: LIST
34355: PUSH
34356: LD_INT 2
34358: PUSH
34359: LD_INT 3
34361: PUSH
34362: EMPTY
34363: LIST
34364: LIST
34365: PUSH
34366: LD_INT 2
34368: NEG
34369: PUSH
34370: LD_INT 1
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 3
34379: NEG
34380: PUSH
34381: LD_INT 1
34383: NEG
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: EMPTY
34390: LIST
34391: LIST
34392: LIST
34393: LIST
34394: LIST
34395: LIST
34396: LIST
34397: LIST
34398: LIST
34399: LIST
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: LIST
34410: LIST
34411: LIST
34412: LIST
34413: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34414: LD_ADDR_VAR 0 31
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: LD_INT 0
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 0
34431: PUSH
34432: LD_INT 1
34434: NEG
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 1
34442: PUSH
34443: LD_INT 0
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 1
34452: PUSH
34453: LD_INT 1
34455: PUSH
34456: EMPTY
34457: LIST
34458: LIST
34459: PUSH
34460: LD_INT 0
34462: PUSH
34463: LD_INT 1
34465: PUSH
34466: EMPTY
34467: LIST
34468: LIST
34469: PUSH
34470: LD_INT 1
34472: NEG
34473: PUSH
34474: LD_INT 0
34476: PUSH
34477: EMPTY
34478: LIST
34479: LIST
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: LD_INT 1
34487: NEG
34488: PUSH
34489: EMPTY
34490: LIST
34491: LIST
34492: PUSH
34493: LD_INT 1
34495: NEG
34496: PUSH
34497: LD_INT 2
34499: NEG
34500: PUSH
34501: EMPTY
34502: LIST
34503: LIST
34504: PUSH
34505: LD_INT 1
34507: PUSH
34508: LD_INT 1
34510: NEG
34511: PUSH
34512: EMPTY
34513: LIST
34514: LIST
34515: PUSH
34516: LD_INT 2
34518: PUSH
34519: LD_INT 0
34521: PUSH
34522: EMPTY
34523: LIST
34524: LIST
34525: PUSH
34526: LD_INT 2
34528: PUSH
34529: LD_INT 1
34531: PUSH
34532: EMPTY
34533: LIST
34534: LIST
34535: PUSH
34536: LD_INT 2
34538: PUSH
34539: LD_INT 2
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: LD_INT 1
34548: PUSH
34549: LD_INT 2
34551: PUSH
34552: EMPTY
34553: LIST
34554: LIST
34555: PUSH
34556: LD_INT 0
34558: PUSH
34559: LD_INT 2
34561: PUSH
34562: EMPTY
34563: LIST
34564: LIST
34565: PUSH
34566: LD_INT 1
34568: NEG
34569: PUSH
34570: LD_INT 1
34572: PUSH
34573: EMPTY
34574: LIST
34575: LIST
34576: PUSH
34577: LD_INT 2
34579: NEG
34580: PUSH
34581: LD_INT 1
34583: NEG
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 2
34591: NEG
34592: PUSH
34593: LD_INT 2
34595: NEG
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 2
34603: NEG
34604: PUSH
34605: LD_INT 3
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 2
34615: PUSH
34616: LD_INT 1
34618: NEG
34619: PUSH
34620: EMPTY
34621: LIST
34622: LIST
34623: PUSH
34624: LD_INT 3
34626: PUSH
34627: LD_INT 1
34629: PUSH
34630: EMPTY
34631: LIST
34632: LIST
34633: PUSH
34634: LD_INT 1
34636: PUSH
34637: LD_INT 3
34639: PUSH
34640: EMPTY
34641: LIST
34642: LIST
34643: PUSH
34644: LD_INT 1
34646: NEG
34647: PUSH
34648: LD_INT 2
34650: PUSH
34651: EMPTY
34652: LIST
34653: LIST
34654: PUSH
34655: LD_INT 3
34657: NEG
34658: PUSH
34659: LD_INT 2
34661: NEG
34662: PUSH
34663: EMPTY
34664: LIST
34665: LIST
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: LIST
34671: LIST
34672: LIST
34673: LIST
34674: LIST
34675: LIST
34676: LIST
34677: LIST
34678: LIST
34679: LIST
34680: LIST
34681: LIST
34682: LIST
34683: LIST
34684: LIST
34685: LIST
34686: LIST
34687: LIST
34688: LIST
34689: LIST
34690: LIST
34691: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34692: LD_ADDR_VAR 0 32
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: LD_INT 0
34702: PUSH
34703: EMPTY
34704: LIST
34705: LIST
34706: PUSH
34707: LD_INT 0
34709: PUSH
34710: LD_INT 1
34712: NEG
34713: PUSH
34714: EMPTY
34715: LIST
34716: LIST
34717: PUSH
34718: LD_INT 1
34720: PUSH
34721: LD_INT 0
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PUSH
34728: LD_INT 1
34730: PUSH
34731: LD_INT 1
34733: PUSH
34734: EMPTY
34735: LIST
34736: LIST
34737: PUSH
34738: LD_INT 0
34740: PUSH
34741: LD_INT 1
34743: PUSH
34744: EMPTY
34745: LIST
34746: LIST
34747: PUSH
34748: LD_INT 1
34750: NEG
34751: PUSH
34752: LD_INT 0
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 1
34761: NEG
34762: PUSH
34763: LD_INT 1
34765: NEG
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: NEG
34774: PUSH
34775: LD_INT 2
34777: NEG
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 0
34785: PUSH
34786: LD_INT 2
34788: NEG
34789: PUSH
34790: EMPTY
34791: LIST
34792: LIST
34793: PUSH
34794: LD_INT 1
34796: PUSH
34797: LD_INT 1
34799: NEG
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 2
34807: PUSH
34808: LD_INT 1
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: LD_INT 2
34817: PUSH
34818: LD_INT 2
34820: PUSH
34821: EMPTY
34822: LIST
34823: LIST
34824: PUSH
34825: LD_INT 1
34827: PUSH
34828: LD_INT 2
34830: PUSH
34831: EMPTY
34832: LIST
34833: LIST
34834: PUSH
34835: LD_INT 0
34837: PUSH
34838: LD_INT 2
34840: PUSH
34841: EMPTY
34842: LIST
34843: LIST
34844: PUSH
34845: LD_INT 1
34847: NEG
34848: PUSH
34849: LD_INT 1
34851: PUSH
34852: EMPTY
34853: LIST
34854: LIST
34855: PUSH
34856: LD_INT 2
34858: NEG
34859: PUSH
34860: LD_INT 0
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 2
34869: NEG
34870: PUSH
34871: LD_INT 1
34873: NEG
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: LD_INT 3
34885: NEG
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: PUSH
34891: LD_INT 1
34893: PUSH
34894: LD_INT 2
34896: NEG
34897: PUSH
34898: EMPTY
34899: LIST
34900: LIST
34901: PUSH
34902: LD_INT 3
34904: PUSH
34905: LD_INT 2
34907: PUSH
34908: EMPTY
34909: LIST
34910: LIST
34911: PUSH
34912: LD_INT 2
34914: PUSH
34915: LD_INT 3
34917: PUSH
34918: EMPTY
34919: LIST
34920: LIST
34921: PUSH
34922: LD_INT 2
34924: NEG
34925: PUSH
34926: LD_INT 1
34928: PUSH
34929: EMPTY
34930: LIST
34931: LIST
34932: PUSH
34933: LD_INT 3
34935: NEG
34936: PUSH
34937: LD_INT 1
34939: NEG
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: EMPTY
34946: LIST
34947: LIST
34948: LIST
34949: LIST
34950: LIST
34951: LIST
34952: LIST
34953: LIST
34954: LIST
34955: LIST
34956: LIST
34957: LIST
34958: LIST
34959: LIST
34960: LIST
34961: LIST
34962: LIST
34963: LIST
34964: LIST
34965: LIST
34966: LIST
34967: LIST
34968: LIST
34969: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34970: LD_ADDR_VAR 0 33
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: LD_INT 0
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 0
34987: PUSH
34988: LD_INT 1
34990: NEG
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 1
34998: PUSH
34999: LD_INT 0
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 1
35008: PUSH
35009: LD_INT 1
35011: PUSH
35012: EMPTY
35013: LIST
35014: LIST
35015: PUSH
35016: LD_INT 0
35018: PUSH
35019: LD_INT 1
35021: PUSH
35022: EMPTY
35023: LIST
35024: LIST
35025: PUSH
35026: LD_INT 1
35028: NEG
35029: PUSH
35030: LD_INT 0
35032: PUSH
35033: EMPTY
35034: LIST
35035: LIST
35036: PUSH
35037: LD_INT 1
35039: NEG
35040: PUSH
35041: LD_INT 1
35043: NEG
35044: PUSH
35045: EMPTY
35046: LIST
35047: LIST
35048: PUSH
35049: LD_INT 1
35051: NEG
35052: PUSH
35053: LD_INT 2
35055: NEG
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: LD_INT 1
35063: PUSH
35064: LD_INT 1
35066: NEG
35067: PUSH
35068: EMPTY
35069: LIST
35070: LIST
35071: PUSH
35072: LD_INT 2
35074: PUSH
35075: LD_INT 0
35077: PUSH
35078: EMPTY
35079: LIST
35080: LIST
35081: PUSH
35082: LD_INT 2
35084: PUSH
35085: LD_INT 1
35087: PUSH
35088: EMPTY
35089: LIST
35090: LIST
35091: PUSH
35092: LD_INT 1
35094: PUSH
35095: LD_INT 2
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 0
35104: PUSH
35105: LD_INT 2
35107: PUSH
35108: EMPTY
35109: LIST
35110: LIST
35111: PUSH
35112: LD_INT 1
35114: NEG
35115: PUSH
35116: LD_INT 1
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: LD_INT 2
35125: NEG
35126: PUSH
35127: LD_INT 0
35129: PUSH
35130: EMPTY
35131: LIST
35132: LIST
35133: PUSH
35134: LD_INT 2
35136: NEG
35137: PUSH
35138: LD_INT 1
35140: NEG
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 2
35148: NEG
35149: PUSH
35150: LD_INT 2
35152: NEG
35153: PUSH
35154: EMPTY
35155: LIST
35156: LIST
35157: PUSH
35158: LD_INT 2
35160: NEG
35161: PUSH
35162: LD_INT 3
35164: NEG
35165: PUSH
35166: EMPTY
35167: LIST
35168: LIST
35169: PUSH
35170: LD_INT 2
35172: PUSH
35173: LD_INT 1
35175: NEG
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 3
35183: PUSH
35184: LD_INT 1
35186: PUSH
35187: EMPTY
35188: LIST
35189: LIST
35190: PUSH
35191: LD_INT 1
35193: PUSH
35194: LD_INT 3
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: NEG
35204: PUSH
35205: LD_INT 2
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 3
35214: NEG
35215: PUSH
35216: LD_INT 2
35218: NEG
35219: PUSH
35220: EMPTY
35221: LIST
35222: LIST
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: LIST
35228: LIST
35229: LIST
35230: LIST
35231: LIST
35232: LIST
35233: LIST
35234: LIST
35235: LIST
35236: LIST
35237: LIST
35238: LIST
35239: LIST
35240: LIST
35241: LIST
35242: LIST
35243: LIST
35244: LIST
35245: LIST
35246: LIST
35247: LIST
35248: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35249: LD_ADDR_VAR 0 34
35253: PUSH
35254: LD_INT 0
35256: PUSH
35257: LD_INT 0
35259: PUSH
35260: EMPTY
35261: LIST
35262: LIST
35263: PUSH
35264: LD_INT 0
35266: PUSH
35267: LD_INT 1
35269: NEG
35270: PUSH
35271: EMPTY
35272: LIST
35273: LIST
35274: PUSH
35275: LD_INT 1
35277: PUSH
35278: LD_INT 0
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 1
35287: PUSH
35288: LD_INT 1
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 0
35297: PUSH
35298: LD_INT 1
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 1
35307: NEG
35308: PUSH
35309: LD_INT 0
35311: PUSH
35312: EMPTY
35313: LIST
35314: LIST
35315: PUSH
35316: LD_INT 1
35318: NEG
35319: PUSH
35320: LD_INT 1
35322: NEG
35323: PUSH
35324: EMPTY
35325: LIST
35326: LIST
35327: PUSH
35328: LD_INT 1
35330: NEG
35331: PUSH
35332: LD_INT 2
35334: NEG
35335: PUSH
35336: EMPTY
35337: LIST
35338: LIST
35339: PUSH
35340: LD_INT 0
35342: PUSH
35343: LD_INT 2
35345: NEG
35346: PUSH
35347: EMPTY
35348: LIST
35349: LIST
35350: PUSH
35351: LD_INT 1
35353: PUSH
35354: LD_INT 1
35356: NEG
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 2
35364: PUSH
35365: LD_INT 1
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 2
35374: PUSH
35375: LD_INT 2
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: PUSH
35385: LD_INT 2
35387: PUSH
35388: EMPTY
35389: LIST
35390: LIST
35391: PUSH
35392: LD_INT 1
35394: NEG
35395: PUSH
35396: LD_INT 1
35398: PUSH
35399: EMPTY
35400: LIST
35401: LIST
35402: PUSH
35403: LD_INT 2
35405: NEG
35406: PUSH
35407: LD_INT 0
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 2
35416: NEG
35417: PUSH
35418: LD_INT 1
35420: NEG
35421: PUSH
35422: EMPTY
35423: LIST
35424: LIST
35425: PUSH
35426: LD_INT 2
35428: NEG
35429: PUSH
35430: LD_INT 2
35432: NEG
35433: PUSH
35434: EMPTY
35435: LIST
35436: LIST
35437: PUSH
35438: LD_INT 1
35440: NEG
35441: PUSH
35442: LD_INT 3
35444: NEG
35445: PUSH
35446: EMPTY
35447: LIST
35448: LIST
35449: PUSH
35450: LD_INT 1
35452: PUSH
35453: LD_INT 2
35455: NEG
35456: PUSH
35457: EMPTY
35458: LIST
35459: LIST
35460: PUSH
35461: LD_INT 3
35463: PUSH
35464: LD_INT 2
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 2
35473: PUSH
35474: LD_INT 3
35476: PUSH
35477: EMPTY
35478: LIST
35479: LIST
35480: PUSH
35481: LD_INT 2
35483: NEG
35484: PUSH
35485: LD_INT 1
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 3
35494: NEG
35495: PUSH
35496: LD_INT 1
35498: NEG
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: LIST
35508: LIST
35509: LIST
35510: LIST
35511: LIST
35512: LIST
35513: LIST
35514: LIST
35515: LIST
35516: LIST
35517: LIST
35518: LIST
35519: LIST
35520: LIST
35521: LIST
35522: LIST
35523: LIST
35524: LIST
35525: LIST
35526: LIST
35527: LIST
35528: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35529: LD_ADDR_VAR 0 35
35533: PUSH
35534: LD_INT 0
35536: PUSH
35537: LD_INT 0
35539: PUSH
35540: EMPTY
35541: LIST
35542: LIST
35543: PUSH
35544: LD_INT 0
35546: PUSH
35547: LD_INT 1
35549: NEG
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 1
35557: PUSH
35558: LD_INT 0
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 1
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 0
35577: PUSH
35578: LD_INT 1
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 1
35587: NEG
35588: PUSH
35589: LD_INT 0
35591: PUSH
35592: EMPTY
35593: LIST
35594: LIST
35595: PUSH
35596: LD_INT 1
35598: NEG
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: EMPTY
35605: LIST
35606: LIST
35607: PUSH
35608: LD_INT 2
35610: PUSH
35611: LD_INT 1
35613: PUSH
35614: EMPTY
35615: LIST
35616: LIST
35617: PUSH
35618: LD_INT 2
35620: NEG
35621: PUSH
35622: LD_INT 1
35624: NEG
35625: PUSH
35626: EMPTY
35627: LIST
35628: LIST
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35641: LD_ADDR_VAR 0 36
35645: PUSH
35646: LD_INT 0
35648: PUSH
35649: LD_INT 0
35651: PUSH
35652: EMPTY
35653: LIST
35654: LIST
35655: PUSH
35656: LD_INT 0
35658: PUSH
35659: LD_INT 1
35661: NEG
35662: PUSH
35663: EMPTY
35664: LIST
35665: LIST
35666: PUSH
35667: LD_INT 1
35669: PUSH
35670: LD_INT 0
35672: PUSH
35673: EMPTY
35674: LIST
35675: LIST
35676: PUSH
35677: LD_INT 1
35679: PUSH
35680: LD_INT 1
35682: PUSH
35683: EMPTY
35684: LIST
35685: LIST
35686: PUSH
35687: LD_INT 0
35689: PUSH
35690: LD_INT 1
35692: PUSH
35693: EMPTY
35694: LIST
35695: LIST
35696: PUSH
35697: LD_INT 1
35699: NEG
35700: PUSH
35701: LD_INT 0
35703: PUSH
35704: EMPTY
35705: LIST
35706: LIST
35707: PUSH
35708: LD_INT 1
35710: NEG
35711: PUSH
35712: LD_INT 1
35714: NEG
35715: PUSH
35716: EMPTY
35717: LIST
35718: LIST
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: LD_INT 2
35726: NEG
35727: PUSH
35728: EMPTY
35729: LIST
35730: LIST
35731: PUSH
35732: LD_INT 1
35734: PUSH
35735: LD_INT 2
35737: PUSH
35738: EMPTY
35739: LIST
35740: LIST
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: LIST
35752: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35753: LD_ADDR_VAR 0 37
35757: PUSH
35758: LD_INT 0
35760: PUSH
35761: LD_INT 0
35763: PUSH
35764: EMPTY
35765: LIST
35766: LIST
35767: PUSH
35768: LD_INT 0
35770: PUSH
35771: LD_INT 1
35773: NEG
35774: PUSH
35775: EMPTY
35776: LIST
35777: LIST
35778: PUSH
35779: LD_INT 1
35781: PUSH
35782: LD_INT 0
35784: PUSH
35785: EMPTY
35786: LIST
35787: LIST
35788: PUSH
35789: LD_INT 1
35791: PUSH
35792: LD_INT 1
35794: PUSH
35795: EMPTY
35796: LIST
35797: LIST
35798: PUSH
35799: LD_INT 0
35801: PUSH
35802: LD_INT 1
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 1
35811: NEG
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: EMPTY
35817: LIST
35818: LIST
35819: PUSH
35820: LD_INT 1
35822: NEG
35823: PUSH
35824: LD_INT 1
35826: NEG
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: LD_INT 1
35837: NEG
35838: PUSH
35839: EMPTY
35840: LIST
35841: LIST
35842: PUSH
35843: LD_INT 1
35845: NEG
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: EMPTY
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: LIST
35862: LIST
35863: LIST
35864: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35865: LD_ADDR_VAR 0 38
35869: PUSH
35870: LD_INT 0
35872: PUSH
35873: LD_INT 0
35875: PUSH
35876: EMPTY
35877: LIST
35878: LIST
35879: PUSH
35880: LD_INT 0
35882: PUSH
35883: LD_INT 1
35885: NEG
35886: PUSH
35887: EMPTY
35888: LIST
35889: LIST
35890: PUSH
35891: LD_INT 1
35893: PUSH
35894: LD_INT 0
35896: PUSH
35897: EMPTY
35898: LIST
35899: LIST
35900: PUSH
35901: LD_INT 1
35903: PUSH
35904: LD_INT 1
35906: PUSH
35907: EMPTY
35908: LIST
35909: LIST
35910: PUSH
35911: LD_INT 0
35913: PUSH
35914: LD_INT 1
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 1
35923: NEG
35924: PUSH
35925: LD_INT 0
35927: PUSH
35928: EMPTY
35929: LIST
35930: LIST
35931: PUSH
35932: LD_INT 1
35934: NEG
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: EMPTY
35941: LIST
35942: LIST
35943: PUSH
35944: LD_INT 2
35946: PUSH
35947: LD_INT 1
35949: PUSH
35950: EMPTY
35951: LIST
35952: LIST
35953: PUSH
35954: LD_INT 2
35956: NEG
35957: PUSH
35958: LD_INT 1
35960: NEG
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: PUSH
35966: EMPTY
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: LIST
35976: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35977: LD_ADDR_VAR 0 39
35981: PUSH
35982: LD_INT 0
35984: PUSH
35985: LD_INT 0
35987: PUSH
35988: EMPTY
35989: LIST
35990: LIST
35991: PUSH
35992: LD_INT 0
35994: PUSH
35995: LD_INT 1
35997: NEG
35998: PUSH
35999: EMPTY
36000: LIST
36001: LIST
36002: PUSH
36003: LD_INT 1
36005: PUSH
36006: LD_INT 0
36008: PUSH
36009: EMPTY
36010: LIST
36011: LIST
36012: PUSH
36013: LD_INT 1
36015: PUSH
36016: LD_INT 1
36018: PUSH
36019: EMPTY
36020: LIST
36021: LIST
36022: PUSH
36023: LD_INT 0
36025: PUSH
36026: LD_INT 1
36028: PUSH
36029: EMPTY
36030: LIST
36031: LIST
36032: PUSH
36033: LD_INT 1
36035: NEG
36036: PUSH
36037: LD_INT 0
36039: PUSH
36040: EMPTY
36041: LIST
36042: LIST
36043: PUSH
36044: LD_INT 1
36046: NEG
36047: PUSH
36048: LD_INT 1
36050: NEG
36051: PUSH
36052: EMPTY
36053: LIST
36054: LIST
36055: PUSH
36056: LD_INT 1
36058: NEG
36059: PUSH
36060: LD_INT 2
36062: NEG
36063: PUSH
36064: EMPTY
36065: LIST
36066: LIST
36067: PUSH
36068: LD_INT 1
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: LIST
36088: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36089: LD_ADDR_VAR 0 40
36093: PUSH
36094: LD_INT 0
36096: PUSH
36097: LD_INT 0
36099: PUSH
36100: EMPTY
36101: LIST
36102: LIST
36103: PUSH
36104: LD_INT 0
36106: PUSH
36107: LD_INT 1
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 1
36117: PUSH
36118: LD_INT 0
36120: PUSH
36121: EMPTY
36122: LIST
36123: LIST
36124: PUSH
36125: LD_INT 1
36127: PUSH
36128: LD_INT 1
36130: PUSH
36131: EMPTY
36132: LIST
36133: LIST
36134: PUSH
36135: LD_INT 0
36137: PUSH
36138: LD_INT 1
36140: PUSH
36141: EMPTY
36142: LIST
36143: LIST
36144: PUSH
36145: LD_INT 1
36147: NEG
36148: PUSH
36149: LD_INT 0
36151: PUSH
36152: EMPTY
36153: LIST
36154: LIST
36155: PUSH
36156: LD_INT 1
36158: NEG
36159: PUSH
36160: LD_INT 1
36162: NEG
36163: PUSH
36164: EMPTY
36165: LIST
36166: LIST
36167: PUSH
36168: LD_INT 1
36170: PUSH
36171: LD_INT 1
36173: NEG
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 1
36181: NEG
36182: PUSH
36183: LD_INT 1
36185: PUSH
36186: EMPTY
36187: LIST
36188: LIST
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: LIST
36200: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36201: LD_ADDR_VAR 0 41
36205: PUSH
36206: LD_INT 0
36208: PUSH
36209: LD_INT 0
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 0
36218: PUSH
36219: LD_INT 1
36221: NEG
36222: PUSH
36223: EMPTY
36224: LIST
36225: LIST
36226: PUSH
36227: LD_INT 1
36229: PUSH
36230: LD_INT 0
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 1
36239: PUSH
36240: LD_INT 1
36242: PUSH
36243: EMPTY
36244: LIST
36245: LIST
36246: PUSH
36247: LD_INT 0
36249: PUSH
36250: LD_INT 1
36252: PUSH
36253: EMPTY
36254: LIST
36255: LIST
36256: PUSH
36257: LD_INT 1
36259: NEG
36260: PUSH
36261: LD_INT 0
36263: PUSH
36264: EMPTY
36265: LIST
36266: LIST
36267: PUSH
36268: LD_INT 1
36270: NEG
36271: PUSH
36272: LD_INT 1
36274: NEG
36275: PUSH
36276: EMPTY
36277: LIST
36278: LIST
36279: PUSH
36280: LD_INT 1
36282: NEG
36283: PUSH
36284: LD_INT 2
36286: NEG
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: LD_INT 1
36294: PUSH
36295: LD_INT 1
36297: NEG
36298: PUSH
36299: EMPTY
36300: LIST
36301: LIST
36302: PUSH
36303: LD_INT 2
36305: PUSH
36306: LD_INT 0
36308: PUSH
36309: EMPTY
36310: LIST
36311: LIST
36312: PUSH
36313: LD_INT 2
36315: PUSH
36316: LD_INT 1
36318: PUSH
36319: EMPTY
36320: LIST
36321: LIST
36322: PUSH
36323: LD_INT 2
36325: PUSH
36326: LD_INT 2
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 1
36335: PUSH
36336: LD_INT 2
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: NEG
36346: PUSH
36347: LD_INT 1
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: NEG
36357: PUSH
36358: LD_INT 0
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 2
36367: NEG
36368: PUSH
36369: LD_INT 1
36371: NEG
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 2
36379: NEG
36380: PUSH
36381: LD_INT 2
36383: NEG
36384: PUSH
36385: EMPTY
36386: LIST
36387: LIST
36388: PUSH
36389: LD_INT 2
36391: NEG
36392: PUSH
36393: LD_INT 3
36395: NEG
36396: PUSH
36397: EMPTY
36398: LIST
36399: LIST
36400: PUSH
36401: LD_INT 2
36403: PUSH
36404: LD_INT 1
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 3
36414: PUSH
36415: LD_INT 0
36417: PUSH
36418: EMPTY
36419: LIST
36420: LIST
36421: PUSH
36422: LD_INT 3
36424: PUSH
36425: LD_INT 1
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 3
36434: PUSH
36435: LD_INT 2
36437: PUSH
36438: EMPTY
36439: LIST
36440: LIST
36441: PUSH
36442: LD_INT 3
36444: PUSH
36445: LD_INT 3
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 2
36454: PUSH
36455: LD_INT 3
36457: PUSH
36458: EMPTY
36459: LIST
36460: LIST
36461: PUSH
36462: LD_INT 2
36464: NEG
36465: PUSH
36466: LD_INT 1
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 3
36475: NEG
36476: PUSH
36477: LD_INT 0
36479: PUSH
36480: EMPTY
36481: LIST
36482: LIST
36483: PUSH
36484: LD_INT 3
36486: NEG
36487: PUSH
36488: LD_INT 1
36490: NEG
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 3
36498: NEG
36499: PUSH
36500: LD_INT 2
36502: NEG
36503: PUSH
36504: EMPTY
36505: LIST
36506: LIST
36507: PUSH
36508: LD_INT 3
36510: NEG
36511: PUSH
36512: LD_INT 3
36514: NEG
36515: PUSH
36516: EMPTY
36517: LIST
36518: LIST
36519: PUSH
36520: EMPTY
36521: LIST
36522: LIST
36523: LIST
36524: LIST
36525: LIST
36526: LIST
36527: LIST
36528: LIST
36529: LIST
36530: LIST
36531: LIST
36532: LIST
36533: LIST
36534: LIST
36535: LIST
36536: LIST
36537: LIST
36538: LIST
36539: LIST
36540: LIST
36541: LIST
36542: LIST
36543: LIST
36544: LIST
36545: LIST
36546: LIST
36547: LIST
36548: LIST
36549: LIST
36550: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36551: LD_ADDR_VAR 0 42
36555: PUSH
36556: LD_INT 0
36558: PUSH
36559: LD_INT 0
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: LD_INT 1
36571: NEG
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 1
36579: PUSH
36580: LD_INT 0
36582: PUSH
36583: EMPTY
36584: LIST
36585: LIST
36586: PUSH
36587: LD_INT 1
36589: PUSH
36590: LD_INT 1
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: LD_INT 1
36602: PUSH
36603: EMPTY
36604: LIST
36605: LIST
36606: PUSH
36607: LD_INT 1
36609: NEG
36610: PUSH
36611: LD_INT 0
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: LD_INT 1
36620: NEG
36621: PUSH
36622: LD_INT 1
36624: NEG
36625: PUSH
36626: EMPTY
36627: LIST
36628: LIST
36629: PUSH
36630: LD_INT 1
36632: NEG
36633: PUSH
36634: LD_INT 2
36636: NEG
36637: PUSH
36638: EMPTY
36639: LIST
36640: LIST
36641: PUSH
36642: LD_INT 0
36644: PUSH
36645: LD_INT 2
36647: NEG
36648: PUSH
36649: EMPTY
36650: LIST
36651: LIST
36652: PUSH
36653: LD_INT 1
36655: PUSH
36656: LD_INT 1
36658: NEG
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: LD_INT 2
36666: PUSH
36667: LD_INT 1
36669: PUSH
36670: EMPTY
36671: LIST
36672: LIST
36673: PUSH
36674: LD_INT 2
36676: PUSH
36677: LD_INT 2
36679: PUSH
36680: EMPTY
36681: LIST
36682: LIST
36683: PUSH
36684: LD_INT 1
36686: PUSH
36687: LD_INT 2
36689: PUSH
36690: EMPTY
36691: LIST
36692: LIST
36693: PUSH
36694: LD_INT 0
36696: PUSH
36697: LD_INT 2
36699: PUSH
36700: EMPTY
36701: LIST
36702: LIST
36703: PUSH
36704: LD_INT 1
36706: NEG
36707: PUSH
36708: LD_INT 1
36710: PUSH
36711: EMPTY
36712: LIST
36713: LIST
36714: PUSH
36715: LD_INT 2
36717: NEG
36718: PUSH
36719: LD_INT 1
36721: NEG
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 2
36729: NEG
36730: PUSH
36731: LD_INT 2
36733: NEG
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 2
36741: NEG
36742: PUSH
36743: LD_INT 3
36745: NEG
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: LD_INT 1
36753: NEG
36754: PUSH
36755: LD_INT 3
36757: NEG
36758: PUSH
36759: EMPTY
36760: LIST
36761: LIST
36762: PUSH
36763: LD_INT 0
36765: PUSH
36766: LD_INT 3
36768: NEG
36769: PUSH
36770: EMPTY
36771: LIST
36772: LIST
36773: PUSH
36774: LD_INT 1
36776: PUSH
36777: LD_INT 2
36779: NEG
36780: PUSH
36781: EMPTY
36782: LIST
36783: LIST
36784: PUSH
36785: LD_INT 3
36787: PUSH
36788: LD_INT 2
36790: PUSH
36791: EMPTY
36792: LIST
36793: LIST
36794: PUSH
36795: LD_INT 3
36797: PUSH
36798: LD_INT 3
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 2
36807: PUSH
36808: LD_INT 3
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 3
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: LD_INT 3
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 2
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 3
36848: NEG
36849: PUSH
36850: LD_INT 2
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 3
36860: NEG
36861: PUSH
36862: LD_INT 3
36864: NEG
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PUSH
36870: EMPTY
36871: LIST
36872: LIST
36873: LIST
36874: LIST
36875: LIST
36876: LIST
36877: LIST
36878: LIST
36879: LIST
36880: LIST
36881: LIST
36882: LIST
36883: LIST
36884: LIST
36885: LIST
36886: LIST
36887: LIST
36888: LIST
36889: LIST
36890: LIST
36891: LIST
36892: LIST
36893: LIST
36894: LIST
36895: LIST
36896: LIST
36897: LIST
36898: LIST
36899: LIST
36900: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36901: LD_ADDR_VAR 0 43
36905: PUSH
36906: LD_INT 0
36908: PUSH
36909: LD_INT 0
36911: PUSH
36912: EMPTY
36913: LIST
36914: LIST
36915: PUSH
36916: LD_INT 0
36918: PUSH
36919: LD_INT 1
36921: NEG
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 1
36929: PUSH
36930: LD_INT 0
36932: PUSH
36933: EMPTY
36934: LIST
36935: LIST
36936: PUSH
36937: LD_INT 1
36939: PUSH
36940: LD_INT 1
36942: PUSH
36943: EMPTY
36944: LIST
36945: LIST
36946: PUSH
36947: LD_INT 0
36949: PUSH
36950: LD_INT 1
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 1
36959: NEG
36960: PUSH
36961: LD_INT 0
36963: PUSH
36964: EMPTY
36965: LIST
36966: LIST
36967: PUSH
36968: LD_INT 1
36970: NEG
36971: PUSH
36972: LD_INT 1
36974: NEG
36975: PUSH
36976: EMPTY
36977: LIST
36978: LIST
36979: PUSH
36980: LD_INT 1
36982: NEG
36983: PUSH
36984: LD_INT 2
36986: NEG
36987: PUSH
36988: EMPTY
36989: LIST
36990: LIST
36991: PUSH
36992: LD_INT 0
36994: PUSH
36995: LD_INT 2
36997: NEG
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: PUSH
37003: LD_INT 1
37005: PUSH
37006: LD_INT 1
37008: NEG
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: PUSH
37014: LD_INT 2
37016: PUSH
37017: LD_INT 0
37019: PUSH
37020: EMPTY
37021: LIST
37022: LIST
37023: PUSH
37024: LD_INT 2
37026: PUSH
37027: LD_INT 1
37029: PUSH
37030: EMPTY
37031: LIST
37032: LIST
37033: PUSH
37034: LD_INT 1
37036: PUSH
37037: LD_INT 2
37039: PUSH
37040: EMPTY
37041: LIST
37042: LIST
37043: PUSH
37044: LD_INT 0
37046: PUSH
37047: LD_INT 2
37049: PUSH
37050: EMPTY
37051: LIST
37052: LIST
37053: PUSH
37054: LD_INT 1
37056: NEG
37057: PUSH
37058: LD_INT 1
37060: PUSH
37061: EMPTY
37062: LIST
37063: LIST
37064: PUSH
37065: LD_INT 2
37067: NEG
37068: PUSH
37069: LD_INT 0
37071: PUSH
37072: EMPTY
37073: LIST
37074: LIST
37075: PUSH
37076: LD_INT 2
37078: NEG
37079: PUSH
37080: LD_INT 1
37082: NEG
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 1
37090: NEG
37091: PUSH
37092: LD_INT 3
37094: NEG
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: LD_INT 3
37105: NEG
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: PUSH
37111: LD_INT 1
37113: PUSH
37114: LD_INT 2
37116: NEG
37117: PUSH
37118: EMPTY
37119: LIST
37120: LIST
37121: PUSH
37122: LD_INT 2
37124: PUSH
37125: LD_INT 1
37127: NEG
37128: PUSH
37129: EMPTY
37130: LIST
37131: LIST
37132: PUSH
37133: LD_INT 3
37135: PUSH
37136: LD_INT 0
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 3
37145: PUSH
37146: LD_INT 1
37148: PUSH
37149: EMPTY
37150: LIST
37151: LIST
37152: PUSH
37153: LD_INT 1
37155: PUSH
37156: LD_INT 3
37158: PUSH
37159: EMPTY
37160: LIST
37161: LIST
37162: PUSH
37163: LD_INT 0
37165: PUSH
37166: LD_INT 3
37168: PUSH
37169: EMPTY
37170: LIST
37171: LIST
37172: PUSH
37173: LD_INT 1
37175: NEG
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 2
37186: NEG
37187: PUSH
37188: LD_INT 1
37190: PUSH
37191: EMPTY
37192: LIST
37193: LIST
37194: PUSH
37195: LD_INT 3
37197: NEG
37198: PUSH
37199: LD_INT 0
37201: PUSH
37202: EMPTY
37203: LIST
37204: LIST
37205: PUSH
37206: LD_INT 3
37208: NEG
37209: PUSH
37210: LD_INT 1
37212: NEG
37213: PUSH
37214: EMPTY
37215: LIST
37216: LIST
37217: PUSH
37218: EMPTY
37219: LIST
37220: LIST
37221: LIST
37222: LIST
37223: LIST
37224: LIST
37225: LIST
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: LIST
37239: LIST
37240: LIST
37241: LIST
37242: LIST
37243: LIST
37244: LIST
37245: LIST
37246: LIST
37247: LIST
37248: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37249: LD_ADDR_VAR 0 44
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 0
37259: PUSH
37260: EMPTY
37261: LIST
37262: LIST
37263: PUSH
37264: LD_INT 0
37266: PUSH
37267: LD_INT 1
37269: NEG
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 1
37277: PUSH
37278: LD_INT 0
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 1
37287: PUSH
37288: LD_INT 1
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 0
37297: PUSH
37298: LD_INT 1
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 0
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 1
37318: NEG
37319: PUSH
37320: LD_INT 1
37322: NEG
37323: PUSH
37324: EMPTY
37325: LIST
37326: LIST
37327: PUSH
37328: LD_INT 1
37330: NEG
37331: PUSH
37332: LD_INT 2
37334: NEG
37335: PUSH
37336: EMPTY
37337: LIST
37338: LIST
37339: PUSH
37340: LD_INT 1
37342: PUSH
37343: LD_INT 1
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: LD_INT 2
37353: PUSH
37354: LD_INT 0
37356: PUSH
37357: EMPTY
37358: LIST
37359: LIST
37360: PUSH
37361: LD_INT 2
37363: PUSH
37364: LD_INT 1
37366: PUSH
37367: EMPTY
37368: LIST
37369: LIST
37370: PUSH
37371: LD_INT 2
37373: PUSH
37374: LD_INT 2
37376: PUSH
37377: EMPTY
37378: LIST
37379: LIST
37380: PUSH
37381: LD_INT 1
37383: PUSH
37384: LD_INT 2
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: NEG
37394: PUSH
37395: LD_INT 1
37397: PUSH
37398: EMPTY
37399: LIST
37400: LIST
37401: PUSH
37402: LD_INT 2
37404: NEG
37405: PUSH
37406: LD_INT 0
37408: PUSH
37409: EMPTY
37410: LIST
37411: LIST
37412: PUSH
37413: LD_INT 2
37415: NEG
37416: PUSH
37417: LD_INT 1
37419: NEG
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 2
37427: NEG
37428: PUSH
37429: LD_INT 2
37431: NEG
37432: PUSH
37433: EMPTY
37434: LIST
37435: LIST
37436: PUSH
37437: LD_INT 2
37439: NEG
37440: PUSH
37441: LD_INT 3
37443: NEG
37444: PUSH
37445: EMPTY
37446: LIST
37447: LIST
37448: PUSH
37449: LD_INT 2
37451: PUSH
37452: LD_INT 1
37454: NEG
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 3
37462: PUSH
37463: LD_INT 0
37465: PUSH
37466: EMPTY
37467: LIST
37468: LIST
37469: PUSH
37470: LD_INT 3
37472: PUSH
37473: LD_INT 1
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 3
37482: PUSH
37483: LD_INT 2
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 3
37492: PUSH
37493: LD_INT 3
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: LD_INT 2
37502: PUSH
37503: LD_INT 3
37505: PUSH
37506: EMPTY
37507: LIST
37508: LIST
37509: PUSH
37510: LD_INT 2
37512: NEG
37513: PUSH
37514: LD_INT 1
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 3
37523: NEG
37524: PUSH
37525: LD_INT 0
37527: PUSH
37528: EMPTY
37529: LIST
37530: LIST
37531: PUSH
37532: LD_INT 3
37534: NEG
37535: PUSH
37536: LD_INT 1
37538: NEG
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: PUSH
37544: LD_INT 3
37546: NEG
37547: PUSH
37548: LD_INT 2
37550: NEG
37551: PUSH
37552: EMPTY
37553: LIST
37554: LIST
37555: PUSH
37556: LD_INT 3
37558: NEG
37559: PUSH
37560: LD_INT 3
37562: NEG
37563: PUSH
37564: EMPTY
37565: LIST
37566: LIST
37567: PUSH
37568: EMPTY
37569: LIST
37570: LIST
37571: LIST
37572: LIST
37573: LIST
37574: LIST
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: LIST
37595: LIST
37596: LIST
37597: LIST
37598: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37599: LD_ADDR_VAR 0 45
37603: PUSH
37604: LD_INT 0
37606: PUSH
37607: LD_INT 0
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 0
37616: PUSH
37617: LD_INT 1
37619: NEG
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 1
37627: PUSH
37628: LD_INT 0
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 1
37637: PUSH
37638: LD_INT 1
37640: PUSH
37641: EMPTY
37642: LIST
37643: LIST
37644: PUSH
37645: LD_INT 0
37647: PUSH
37648: LD_INT 1
37650: PUSH
37651: EMPTY
37652: LIST
37653: LIST
37654: PUSH
37655: LD_INT 1
37657: NEG
37658: PUSH
37659: LD_INT 0
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: LD_INT 1
37672: NEG
37673: PUSH
37674: EMPTY
37675: LIST
37676: LIST
37677: PUSH
37678: LD_INT 1
37680: NEG
37681: PUSH
37682: LD_INT 2
37684: NEG
37685: PUSH
37686: EMPTY
37687: LIST
37688: LIST
37689: PUSH
37690: LD_INT 0
37692: PUSH
37693: LD_INT 2
37695: NEG
37696: PUSH
37697: EMPTY
37698: LIST
37699: LIST
37700: PUSH
37701: LD_INT 1
37703: PUSH
37704: LD_INT 1
37706: NEG
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: PUSH
37712: LD_INT 2
37714: PUSH
37715: LD_INT 1
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 2
37724: PUSH
37725: LD_INT 2
37727: PUSH
37728: EMPTY
37729: LIST
37730: LIST
37731: PUSH
37732: LD_INT 1
37734: PUSH
37735: LD_INT 2
37737: PUSH
37738: EMPTY
37739: LIST
37740: LIST
37741: PUSH
37742: LD_INT 0
37744: PUSH
37745: LD_INT 2
37747: PUSH
37748: EMPTY
37749: LIST
37750: LIST
37751: PUSH
37752: LD_INT 1
37754: NEG
37755: PUSH
37756: LD_INT 1
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 2
37765: NEG
37766: PUSH
37767: LD_INT 1
37769: NEG
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 2
37777: NEG
37778: PUSH
37779: LD_INT 2
37781: NEG
37782: PUSH
37783: EMPTY
37784: LIST
37785: LIST
37786: PUSH
37787: LD_INT 2
37789: NEG
37790: PUSH
37791: LD_INT 3
37793: NEG
37794: PUSH
37795: EMPTY
37796: LIST
37797: LIST
37798: PUSH
37799: LD_INT 1
37801: NEG
37802: PUSH
37803: LD_INT 3
37805: NEG
37806: PUSH
37807: EMPTY
37808: LIST
37809: LIST
37810: PUSH
37811: LD_INT 0
37813: PUSH
37814: LD_INT 3
37816: NEG
37817: PUSH
37818: EMPTY
37819: LIST
37820: LIST
37821: PUSH
37822: LD_INT 1
37824: PUSH
37825: LD_INT 2
37827: NEG
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: PUSH
37833: LD_INT 3
37835: PUSH
37836: LD_INT 2
37838: PUSH
37839: EMPTY
37840: LIST
37841: LIST
37842: PUSH
37843: LD_INT 3
37845: PUSH
37846: LD_INT 3
37848: PUSH
37849: EMPTY
37850: LIST
37851: LIST
37852: PUSH
37853: LD_INT 2
37855: PUSH
37856: LD_INT 3
37858: PUSH
37859: EMPTY
37860: LIST
37861: LIST
37862: PUSH
37863: LD_INT 1
37865: PUSH
37866: LD_INT 3
37868: PUSH
37869: EMPTY
37870: LIST
37871: LIST
37872: PUSH
37873: LD_INT 0
37875: PUSH
37876: LD_INT 3
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 1
37885: NEG
37886: PUSH
37887: LD_INT 2
37889: PUSH
37890: EMPTY
37891: LIST
37892: LIST
37893: PUSH
37894: LD_INT 3
37896: NEG
37897: PUSH
37898: LD_INT 2
37900: NEG
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 3
37908: NEG
37909: PUSH
37910: LD_INT 3
37912: NEG
37913: PUSH
37914: EMPTY
37915: LIST
37916: LIST
37917: PUSH
37918: EMPTY
37919: LIST
37920: LIST
37921: LIST
37922: LIST
37923: LIST
37924: LIST
37925: LIST
37926: LIST
37927: LIST
37928: LIST
37929: LIST
37930: LIST
37931: LIST
37932: LIST
37933: LIST
37934: LIST
37935: LIST
37936: LIST
37937: LIST
37938: LIST
37939: LIST
37940: LIST
37941: LIST
37942: LIST
37943: LIST
37944: LIST
37945: LIST
37946: LIST
37947: LIST
37948: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37949: LD_ADDR_VAR 0 46
37953: PUSH
37954: LD_INT 0
37956: PUSH
37957: LD_INT 0
37959: PUSH
37960: EMPTY
37961: LIST
37962: LIST
37963: PUSH
37964: LD_INT 0
37966: PUSH
37967: LD_INT 1
37969: NEG
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 1
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: EMPTY
37982: LIST
37983: LIST
37984: PUSH
37985: LD_INT 1
37987: PUSH
37988: LD_INT 1
37990: PUSH
37991: EMPTY
37992: LIST
37993: LIST
37994: PUSH
37995: LD_INT 0
37997: PUSH
37998: LD_INT 1
38000: PUSH
38001: EMPTY
38002: LIST
38003: LIST
38004: PUSH
38005: LD_INT 1
38007: NEG
38008: PUSH
38009: LD_INT 0
38011: PUSH
38012: EMPTY
38013: LIST
38014: LIST
38015: PUSH
38016: LD_INT 1
38018: NEG
38019: PUSH
38020: LD_INT 1
38022: NEG
38023: PUSH
38024: EMPTY
38025: LIST
38026: LIST
38027: PUSH
38028: LD_INT 1
38030: NEG
38031: PUSH
38032: LD_INT 2
38034: NEG
38035: PUSH
38036: EMPTY
38037: LIST
38038: LIST
38039: PUSH
38040: LD_INT 0
38042: PUSH
38043: LD_INT 2
38045: NEG
38046: PUSH
38047: EMPTY
38048: LIST
38049: LIST
38050: PUSH
38051: LD_INT 1
38053: PUSH
38054: LD_INT 1
38056: NEG
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: PUSH
38062: LD_INT 2
38064: PUSH
38065: LD_INT 0
38067: PUSH
38068: EMPTY
38069: LIST
38070: LIST
38071: PUSH
38072: LD_INT 2
38074: PUSH
38075: LD_INT 1
38077: PUSH
38078: EMPTY
38079: LIST
38080: LIST
38081: PUSH
38082: LD_INT 1
38084: PUSH
38085: LD_INT 2
38087: PUSH
38088: EMPTY
38089: LIST
38090: LIST
38091: PUSH
38092: LD_INT 0
38094: PUSH
38095: LD_INT 2
38097: PUSH
38098: EMPTY
38099: LIST
38100: LIST
38101: PUSH
38102: LD_INT 1
38104: NEG
38105: PUSH
38106: LD_INT 1
38108: PUSH
38109: EMPTY
38110: LIST
38111: LIST
38112: PUSH
38113: LD_INT 2
38115: NEG
38116: PUSH
38117: LD_INT 0
38119: PUSH
38120: EMPTY
38121: LIST
38122: LIST
38123: PUSH
38124: LD_INT 2
38126: NEG
38127: PUSH
38128: LD_INT 1
38130: NEG
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: NEG
38139: PUSH
38140: LD_INT 3
38142: NEG
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 0
38150: PUSH
38151: LD_INT 3
38153: NEG
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 1
38161: PUSH
38162: LD_INT 2
38164: NEG
38165: PUSH
38166: EMPTY
38167: LIST
38168: LIST
38169: PUSH
38170: LD_INT 2
38172: PUSH
38173: LD_INT 1
38175: NEG
38176: PUSH
38177: EMPTY
38178: LIST
38179: LIST
38180: PUSH
38181: LD_INT 3
38183: PUSH
38184: LD_INT 0
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 3
38193: PUSH
38194: LD_INT 1
38196: PUSH
38197: EMPTY
38198: LIST
38199: LIST
38200: PUSH
38201: LD_INT 1
38203: PUSH
38204: LD_INT 3
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: PUSH
38211: LD_INT 0
38213: PUSH
38214: LD_INT 3
38216: PUSH
38217: EMPTY
38218: LIST
38219: LIST
38220: PUSH
38221: LD_INT 1
38223: NEG
38224: PUSH
38225: LD_INT 2
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 2
38234: NEG
38235: PUSH
38236: LD_INT 1
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 3
38245: NEG
38246: PUSH
38247: LD_INT 0
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 3
38256: NEG
38257: PUSH
38258: LD_INT 1
38260: NEG
38261: PUSH
38262: EMPTY
38263: LIST
38264: LIST
38265: PUSH
38266: EMPTY
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: LIST
38285: LIST
38286: LIST
38287: LIST
38288: LIST
38289: LIST
38290: LIST
38291: LIST
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38297: LD_ADDR_VAR 0 47
38301: PUSH
38302: LD_INT 0
38304: PUSH
38305: LD_INT 0
38307: PUSH
38308: EMPTY
38309: LIST
38310: LIST
38311: PUSH
38312: LD_INT 0
38314: PUSH
38315: LD_INT 1
38317: NEG
38318: PUSH
38319: EMPTY
38320: LIST
38321: LIST
38322: PUSH
38323: LD_INT 1
38325: PUSH
38326: LD_INT 0
38328: PUSH
38329: EMPTY
38330: LIST
38331: LIST
38332: PUSH
38333: LD_INT 1
38335: PUSH
38336: LD_INT 1
38338: PUSH
38339: EMPTY
38340: LIST
38341: LIST
38342: PUSH
38343: LD_INT 0
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PUSH
38353: LD_INT 1
38355: NEG
38356: PUSH
38357: LD_INT 0
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: LD_INT 1
38370: NEG
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 1
38378: NEG
38379: PUSH
38380: LD_INT 2
38382: NEG
38383: PUSH
38384: EMPTY
38385: LIST
38386: LIST
38387: PUSH
38388: LD_INT 0
38390: PUSH
38391: LD_INT 2
38393: NEG
38394: PUSH
38395: EMPTY
38396: LIST
38397: LIST
38398: PUSH
38399: LD_INT 1
38401: PUSH
38402: LD_INT 1
38404: NEG
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: PUSH
38410: LD_INT 2
38412: NEG
38413: PUSH
38414: LD_INT 1
38416: NEG
38417: PUSH
38418: EMPTY
38419: LIST
38420: LIST
38421: PUSH
38422: LD_INT 2
38424: NEG
38425: PUSH
38426: LD_INT 2
38428: NEG
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: LIST
38438: LIST
38439: LIST
38440: LIST
38441: LIST
38442: LIST
38443: LIST
38444: LIST
38445: LIST
38446: LIST
38447: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38448: LD_ADDR_VAR 0 48
38452: PUSH
38453: LD_INT 0
38455: PUSH
38456: LD_INT 0
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: LD_INT 1
38468: NEG
38469: PUSH
38470: EMPTY
38471: LIST
38472: LIST
38473: PUSH
38474: LD_INT 1
38476: PUSH
38477: LD_INT 0
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 1
38486: PUSH
38487: LD_INT 1
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: LD_INT 0
38496: PUSH
38497: LD_INT 1
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 1
38506: NEG
38507: PUSH
38508: LD_INT 0
38510: PUSH
38511: EMPTY
38512: LIST
38513: LIST
38514: PUSH
38515: LD_INT 1
38517: NEG
38518: PUSH
38519: LD_INT 1
38521: NEG
38522: PUSH
38523: EMPTY
38524: LIST
38525: LIST
38526: PUSH
38527: LD_INT 1
38529: NEG
38530: PUSH
38531: LD_INT 2
38533: NEG
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 0
38541: PUSH
38542: LD_INT 2
38544: NEG
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 1
38552: PUSH
38553: LD_INT 1
38555: NEG
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 2
38563: PUSH
38564: LD_INT 0
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 2
38573: PUSH
38574: LD_INT 1
38576: PUSH
38577: EMPTY
38578: LIST
38579: LIST
38580: PUSH
38581: EMPTY
38582: LIST
38583: LIST
38584: LIST
38585: LIST
38586: LIST
38587: LIST
38588: LIST
38589: LIST
38590: LIST
38591: LIST
38592: LIST
38593: LIST
38594: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38595: LD_ADDR_VAR 0 49
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: LD_INT 0
38605: PUSH
38606: EMPTY
38607: LIST
38608: LIST
38609: PUSH
38610: LD_INT 0
38612: PUSH
38613: LD_INT 1
38615: NEG
38616: PUSH
38617: EMPTY
38618: LIST
38619: LIST
38620: PUSH
38621: LD_INT 1
38623: PUSH
38624: LD_INT 0
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 1
38633: PUSH
38634: LD_INT 1
38636: PUSH
38637: EMPTY
38638: LIST
38639: LIST
38640: PUSH
38641: LD_INT 0
38643: PUSH
38644: LD_INT 1
38646: PUSH
38647: EMPTY
38648: LIST
38649: LIST
38650: PUSH
38651: LD_INT 1
38653: NEG
38654: PUSH
38655: LD_INT 0
38657: PUSH
38658: EMPTY
38659: LIST
38660: LIST
38661: PUSH
38662: LD_INT 1
38664: NEG
38665: PUSH
38666: LD_INT 1
38668: NEG
38669: PUSH
38670: EMPTY
38671: LIST
38672: LIST
38673: PUSH
38674: LD_INT 1
38676: PUSH
38677: LD_INT 1
38679: NEG
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: LD_INT 2
38687: PUSH
38688: LD_INT 0
38690: PUSH
38691: EMPTY
38692: LIST
38693: LIST
38694: PUSH
38695: LD_INT 2
38697: PUSH
38698: LD_INT 1
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: PUSH
38705: LD_INT 2
38707: PUSH
38708: LD_INT 2
38710: PUSH
38711: EMPTY
38712: LIST
38713: LIST
38714: PUSH
38715: LD_INT 1
38717: PUSH
38718: LD_INT 2
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: EMPTY
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38739: LD_ADDR_VAR 0 50
38743: PUSH
38744: LD_INT 0
38746: PUSH
38747: LD_INT 0
38749: PUSH
38750: EMPTY
38751: LIST
38752: LIST
38753: PUSH
38754: LD_INT 0
38756: PUSH
38757: LD_INT 1
38759: NEG
38760: PUSH
38761: EMPTY
38762: LIST
38763: LIST
38764: PUSH
38765: LD_INT 1
38767: PUSH
38768: LD_INT 0
38770: PUSH
38771: EMPTY
38772: LIST
38773: LIST
38774: PUSH
38775: LD_INT 1
38777: PUSH
38778: LD_INT 1
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 0
38787: PUSH
38788: LD_INT 1
38790: PUSH
38791: EMPTY
38792: LIST
38793: LIST
38794: PUSH
38795: LD_INT 1
38797: NEG
38798: PUSH
38799: LD_INT 0
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: LD_INT 1
38812: NEG
38813: PUSH
38814: EMPTY
38815: LIST
38816: LIST
38817: PUSH
38818: LD_INT 2
38820: PUSH
38821: LD_INT 1
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: PUSH
38828: LD_INT 2
38830: PUSH
38831: LD_INT 2
38833: PUSH
38834: EMPTY
38835: LIST
38836: LIST
38837: PUSH
38838: LD_INT 1
38840: PUSH
38841: LD_INT 2
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: LD_INT 2
38853: PUSH
38854: EMPTY
38855: LIST
38856: LIST
38857: PUSH
38858: LD_INT 1
38860: NEG
38861: PUSH
38862: LD_INT 1
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: LIST
38879: LIST
38880: LIST
38881: LIST
38882: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
38883: LD_ADDR_VAR 0 51
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: LD_INT 0
38893: PUSH
38894: EMPTY
38895: LIST
38896: LIST
38897: PUSH
38898: LD_INT 0
38900: PUSH
38901: LD_INT 1
38903: NEG
38904: PUSH
38905: EMPTY
38906: LIST
38907: LIST
38908: PUSH
38909: LD_INT 1
38911: PUSH
38912: LD_INT 0
38914: PUSH
38915: EMPTY
38916: LIST
38917: LIST
38918: PUSH
38919: LD_INT 1
38921: PUSH
38922: LD_INT 1
38924: PUSH
38925: EMPTY
38926: LIST
38927: LIST
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: LD_INT 1
38934: PUSH
38935: EMPTY
38936: LIST
38937: LIST
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: LD_INT 0
38945: PUSH
38946: EMPTY
38947: LIST
38948: LIST
38949: PUSH
38950: LD_INT 1
38952: NEG
38953: PUSH
38954: LD_INT 1
38956: NEG
38957: PUSH
38958: EMPTY
38959: LIST
38960: LIST
38961: PUSH
38962: LD_INT 1
38964: PUSH
38965: LD_INT 2
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 0
38974: PUSH
38975: LD_INT 2
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: NEG
38985: PUSH
38986: LD_INT 1
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: PUSH
38993: LD_INT 2
38995: NEG
38996: PUSH
38997: LD_INT 0
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: PUSH
39004: LD_INT 2
39006: NEG
39007: PUSH
39008: LD_INT 1
39010: NEG
39011: PUSH
39012: EMPTY
39013: LIST
39014: LIST
39015: PUSH
39016: EMPTY
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: LIST
39023: LIST
39024: LIST
39025: LIST
39026: LIST
39027: LIST
39028: LIST
39029: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39030: LD_ADDR_VAR 0 52
39034: PUSH
39035: LD_INT 0
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 0
39047: PUSH
39048: LD_INT 1
39050: NEG
39051: PUSH
39052: EMPTY
39053: LIST
39054: LIST
39055: PUSH
39056: LD_INT 1
39058: PUSH
39059: LD_INT 0
39061: PUSH
39062: EMPTY
39063: LIST
39064: LIST
39065: PUSH
39066: LD_INT 1
39068: PUSH
39069: LD_INT 1
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 0
39078: PUSH
39079: LD_INT 1
39081: PUSH
39082: EMPTY
39083: LIST
39084: LIST
39085: PUSH
39086: LD_INT 1
39088: NEG
39089: PUSH
39090: LD_INT 0
39092: PUSH
39093: EMPTY
39094: LIST
39095: LIST
39096: PUSH
39097: LD_INT 1
39099: NEG
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: EMPTY
39106: LIST
39107: LIST
39108: PUSH
39109: LD_INT 1
39111: NEG
39112: PUSH
39113: LD_INT 2
39115: NEG
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 1
39123: NEG
39124: PUSH
39125: LD_INT 1
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 2
39134: NEG
39135: PUSH
39136: LD_INT 0
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 2
39145: NEG
39146: PUSH
39147: LD_INT 1
39149: NEG
39150: PUSH
39151: EMPTY
39152: LIST
39153: LIST
39154: PUSH
39155: LD_INT 2
39157: NEG
39158: PUSH
39159: LD_INT 2
39161: NEG
39162: PUSH
39163: EMPTY
39164: LIST
39165: LIST
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: LIST
39171: LIST
39172: LIST
39173: LIST
39174: LIST
39175: LIST
39176: LIST
39177: LIST
39178: LIST
39179: LIST
39180: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39181: LD_ADDR_VAR 0 53
39185: PUSH
39186: LD_INT 0
39188: PUSH
39189: LD_INT 0
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 0
39198: PUSH
39199: LD_INT 1
39201: NEG
39202: PUSH
39203: EMPTY
39204: LIST
39205: LIST
39206: PUSH
39207: LD_INT 1
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 1
39219: PUSH
39220: LD_INT 1
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 0
39229: PUSH
39230: LD_INT 1
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 1
39239: NEG
39240: PUSH
39241: LD_INT 0
39243: PUSH
39244: EMPTY
39245: LIST
39246: LIST
39247: PUSH
39248: LD_INT 1
39250: NEG
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: EMPTY
39257: LIST
39258: LIST
39259: PUSH
39260: LD_INT 1
39262: NEG
39263: PUSH
39264: LD_INT 2
39266: NEG
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 0
39274: PUSH
39275: LD_INT 2
39277: NEG
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 1
39285: PUSH
39286: LD_INT 1
39288: NEG
39289: PUSH
39290: EMPTY
39291: LIST
39292: LIST
39293: PUSH
39294: LD_INT 2
39296: PUSH
39297: LD_INT 0
39299: PUSH
39300: EMPTY
39301: LIST
39302: LIST
39303: PUSH
39304: LD_INT 2
39306: PUSH
39307: LD_INT 1
39309: PUSH
39310: EMPTY
39311: LIST
39312: LIST
39313: PUSH
39314: LD_INT 2
39316: PUSH
39317: LD_INT 2
39319: PUSH
39320: EMPTY
39321: LIST
39322: LIST
39323: PUSH
39324: LD_INT 1
39326: PUSH
39327: LD_INT 2
39329: PUSH
39330: EMPTY
39331: LIST
39332: LIST
39333: PUSH
39334: LD_INT 0
39336: PUSH
39337: LD_INT 2
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 1
39346: NEG
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 2
39357: NEG
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 2
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 2
39380: NEG
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: LIST
39404: LIST
39405: LIST
39406: LIST
39407: LIST
39408: LIST
39409: LIST
39410: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39411: LD_ADDR_VAR 0 54
39415: PUSH
39416: LD_INT 0
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: EMPTY
39423: LIST
39424: LIST
39425: PUSH
39426: LD_INT 0
39428: PUSH
39429: LD_INT 1
39431: NEG
39432: PUSH
39433: EMPTY
39434: LIST
39435: LIST
39436: PUSH
39437: LD_INT 1
39439: PUSH
39440: LD_INT 0
39442: PUSH
39443: EMPTY
39444: LIST
39445: LIST
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: LD_INT 1
39452: PUSH
39453: EMPTY
39454: LIST
39455: LIST
39456: PUSH
39457: LD_INT 0
39459: PUSH
39460: LD_INT 1
39462: PUSH
39463: EMPTY
39464: LIST
39465: LIST
39466: PUSH
39467: LD_INT 1
39469: NEG
39470: PUSH
39471: LD_INT 0
39473: PUSH
39474: EMPTY
39475: LIST
39476: LIST
39477: PUSH
39478: LD_INT 1
39480: NEG
39481: PUSH
39482: LD_INT 1
39484: NEG
39485: PUSH
39486: EMPTY
39487: LIST
39488: LIST
39489: PUSH
39490: LD_INT 1
39492: NEG
39493: PUSH
39494: LD_INT 2
39496: NEG
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 0
39504: PUSH
39505: LD_INT 2
39507: NEG
39508: PUSH
39509: EMPTY
39510: LIST
39511: LIST
39512: PUSH
39513: LD_INT 1
39515: PUSH
39516: LD_INT 1
39518: NEG
39519: PUSH
39520: EMPTY
39521: LIST
39522: LIST
39523: PUSH
39524: LD_INT 2
39526: PUSH
39527: LD_INT 0
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: PUSH
39534: LD_INT 2
39536: PUSH
39537: LD_INT 1
39539: PUSH
39540: EMPTY
39541: LIST
39542: LIST
39543: PUSH
39544: LD_INT 2
39546: PUSH
39547: LD_INT 2
39549: PUSH
39550: EMPTY
39551: LIST
39552: LIST
39553: PUSH
39554: LD_INT 1
39556: PUSH
39557: LD_INT 2
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: PUSH
39564: LD_INT 0
39566: PUSH
39567: LD_INT 2
39569: PUSH
39570: EMPTY
39571: LIST
39572: LIST
39573: PUSH
39574: LD_INT 1
39576: NEG
39577: PUSH
39578: LD_INT 1
39580: PUSH
39581: EMPTY
39582: LIST
39583: LIST
39584: PUSH
39585: LD_INT 2
39587: NEG
39588: PUSH
39589: LD_INT 0
39591: PUSH
39592: EMPTY
39593: LIST
39594: LIST
39595: PUSH
39596: LD_INT 2
39598: NEG
39599: PUSH
39600: LD_INT 1
39602: NEG
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: PUSH
39608: LD_INT 2
39610: NEG
39611: PUSH
39612: LD_INT 2
39614: NEG
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: LIST
39634: LIST
39635: LIST
39636: LIST
39637: LIST
39638: LIST
39639: LIST
39640: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39641: LD_ADDR_VAR 0 55
39645: PUSH
39646: LD_INT 0
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: EMPTY
39653: LIST
39654: LIST
39655: PUSH
39656: LD_INT 0
39658: PUSH
39659: LD_INT 1
39661: NEG
39662: PUSH
39663: EMPTY
39664: LIST
39665: LIST
39666: PUSH
39667: LD_INT 1
39669: PUSH
39670: LD_INT 0
39672: PUSH
39673: EMPTY
39674: LIST
39675: LIST
39676: PUSH
39677: LD_INT 1
39679: PUSH
39680: LD_INT 1
39682: PUSH
39683: EMPTY
39684: LIST
39685: LIST
39686: PUSH
39687: LD_INT 0
39689: PUSH
39690: LD_INT 1
39692: PUSH
39693: EMPTY
39694: LIST
39695: LIST
39696: PUSH
39697: LD_INT 1
39699: NEG
39700: PUSH
39701: LD_INT 0
39703: PUSH
39704: EMPTY
39705: LIST
39706: LIST
39707: PUSH
39708: LD_INT 1
39710: NEG
39711: PUSH
39712: LD_INT 1
39714: NEG
39715: PUSH
39716: EMPTY
39717: LIST
39718: LIST
39719: PUSH
39720: LD_INT 1
39722: NEG
39723: PUSH
39724: LD_INT 2
39726: NEG
39727: PUSH
39728: EMPTY
39729: LIST
39730: LIST
39731: PUSH
39732: LD_INT 0
39734: PUSH
39735: LD_INT 2
39737: NEG
39738: PUSH
39739: EMPTY
39740: LIST
39741: LIST
39742: PUSH
39743: LD_INT 1
39745: PUSH
39746: LD_INT 1
39748: NEG
39749: PUSH
39750: EMPTY
39751: LIST
39752: LIST
39753: PUSH
39754: LD_INT 2
39756: PUSH
39757: LD_INT 0
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: PUSH
39764: LD_INT 2
39766: PUSH
39767: LD_INT 1
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: PUSH
39774: LD_INT 2
39776: PUSH
39777: LD_INT 2
39779: PUSH
39780: EMPTY
39781: LIST
39782: LIST
39783: PUSH
39784: LD_INT 1
39786: PUSH
39787: LD_INT 2
39789: PUSH
39790: EMPTY
39791: LIST
39792: LIST
39793: PUSH
39794: LD_INT 0
39796: PUSH
39797: LD_INT 2
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 1
39806: NEG
39807: PUSH
39808: LD_INT 1
39810: PUSH
39811: EMPTY
39812: LIST
39813: LIST
39814: PUSH
39815: LD_INT 2
39817: NEG
39818: PUSH
39819: LD_INT 0
39821: PUSH
39822: EMPTY
39823: LIST
39824: LIST
39825: PUSH
39826: LD_INT 2
39828: NEG
39829: PUSH
39830: LD_INT 1
39832: NEG
39833: PUSH
39834: EMPTY
39835: LIST
39836: LIST
39837: PUSH
39838: LD_INT 2
39840: NEG
39841: PUSH
39842: LD_INT 2
39844: NEG
39845: PUSH
39846: EMPTY
39847: LIST
39848: LIST
39849: PUSH
39850: EMPTY
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: LIST
39864: LIST
39865: LIST
39866: LIST
39867: LIST
39868: LIST
39869: LIST
39870: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39871: LD_ADDR_VAR 0 56
39875: PUSH
39876: LD_INT 0
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: EMPTY
39883: LIST
39884: LIST
39885: PUSH
39886: LD_INT 0
39888: PUSH
39889: LD_INT 1
39891: NEG
39892: PUSH
39893: EMPTY
39894: LIST
39895: LIST
39896: PUSH
39897: LD_INT 1
39899: PUSH
39900: LD_INT 0
39902: PUSH
39903: EMPTY
39904: LIST
39905: LIST
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: LD_INT 1
39912: PUSH
39913: EMPTY
39914: LIST
39915: LIST
39916: PUSH
39917: LD_INT 0
39919: PUSH
39920: LD_INT 1
39922: PUSH
39923: EMPTY
39924: LIST
39925: LIST
39926: PUSH
39927: LD_INT 1
39929: NEG
39930: PUSH
39931: LD_INT 0
39933: PUSH
39934: EMPTY
39935: LIST
39936: LIST
39937: PUSH
39938: LD_INT 1
39940: NEG
39941: PUSH
39942: LD_INT 1
39944: NEG
39945: PUSH
39946: EMPTY
39947: LIST
39948: LIST
39949: PUSH
39950: LD_INT 1
39952: NEG
39953: PUSH
39954: LD_INT 2
39956: NEG
39957: PUSH
39958: EMPTY
39959: LIST
39960: LIST
39961: PUSH
39962: LD_INT 0
39964: PUSH
39965: LD_INT 2
39967: NEG
39968: PUSH
39969: EMPTY
39970: LIST
39971: LIST
39972: PUSH
39973: LD_INT 1
39975: PUSH
39976: LD_INT 1
39978: NEG
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 2
39986: PUSH
39987: LD_INT 0
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: LD_INT 2
39996: PUSH
39997: LD_INT 1
39999: PUSH
40000: EMPTY
40001: LIST
40002: LIST
40003: PUSH
40004: LD_INT 2
40006: PUSH
40007: LD_INT 2
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 1
40016: PUSH
40017: LD_INT 2
40019: PUSH
40020: EMPTY
40021: LIST
40022: LIST
40023: PUSH
40024: LD_INT 0
40026: PUSH
40027: LD_INT 2
40029: PUSH
40030: EMPTY
40031: LIST
40032: LIST
40033: PUSH
40034: LD_INT 1
40036: NEG
40037: PUSH
40038: LD_INT 1
40040: PUSH
40041: EMPTY
40042: LIST
40043: LIST
40044: PUSH
40045: LD_INT 2
40047: NEG
40048: PUSH
40049: LD_INT 0
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: LD_INT 2
40058: NEG
40059: PUSH
40060: LD_INT 1
40062: NEG
40063: PUSH
40064: EMPTY
40065: LIST
40066: LIST
40067: PUSH
40068: LD_INT 2
40070: NEG
40071: PUSH
40072: LD_INT 2
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: LIST
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: LIST
40094: LIST
40095: LIST
40096: LIST
40097: LIST
40098: LIST
40099: LIST
40100: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40101: LD_ADDR_VAR 0 57
40105: PUSH
40106: LD_INT 0
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 0
40118: PUSH
40119: LD_INT 1
40121: NEG
40122: PUSH
40123: EMPTY
40124: LIST
40125: LIST
40126: PUSH
40127: LD_INT 1
40129: PUSH
40130: LD_INT 0
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: LD_INT 1
40142: PUSH
40143: EMPTY
40144: LIST
40145: LIST
40146: PUSH
40147: LD_INT 0
40149: PUSH
40150: LD_INT 1
40152: PUSH
40153: EMPTY
40154: LIST
40155: LIST
40156: PUSH
40157: LD_INT 1
40159: NEG
40160: PUSH
40161: LD_INT 0
40163: PUSH
40164: EMPTY
40165: LIST
40166: LIST
40167: PUSH
40168: LD_INT 1
40170: NEG
40171: PUSH
40172: LD_INT 1
40174: NEG
40175: PUSH
40176: EMPTY
40177: LIST
40178: LIST
40179: PUSH
40180: LD_INT 1
40182: NEG
40183: PUSH
40184: LD_INT 2
40186: NEG
40187: PUSH
40188: EMPTY
40189: LIST
40190: LIST
40191: PUSH
40192: LD_INT 0
40194: PUSH
40195: LD_INT 2
40197: NEG
40198: PUSH
40199: EMPTY
40200: LIST
40201: LIST
40202: PUSH
40203: LD_INT 1
40205: PUSH
40206: LD_INT 1
40208: NEG
40209: PUSH
40210: EMPTY
40211: LIST
40212: LIST
40213: PUSH
40214: LD_INT 2
40216: PUSH
40217: LD_INT 0
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: PUSH
40224: LD_INT 2
40226: PUSH
40227: LD_INT 1
40229: PUSH
40230: EMPTY
40231: LIST
40232: LIST
40233: PUSH
40234: LD_INT 2
40236: PUSH
40237: LD_INT 2
40239: PUSH
40240: EMPTY
40241: LIST
40242: LIST
40243: PUSH
40244: LD_INT 1
40246: PUSH
40247: LD_INT 2
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 0
40256: PUSH
40257: LD_INT 2
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 1
40266: NEG
40267: PUSH
40268: LD_INT 1
40270: PUSH
40271: EMPTY
40272: LIST
40273: LIST
40274: PUSH
40275: LD_INT 2
40277: NEG
40278: PUSH
40279: LD_INT 0
40281: PUSH
40282: EMPTY
40283: LIST
40284: LIST
40285: PUSH
40286: LD_INT 2
40288: NEG
40289: PUSH
40290: LD_INT 1
40292: NEG
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PUSH
40298: LD_INT 2
40300: NEG
40301: PUSH
40302: LD_INT 2
40304: NEG
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: PUSH
40310: EMPTY
40311: LIST
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: LIST
40324: LIST
40325: LIST
40326: LIST
40327: LIST
40328: LIST
40329: LIST
40330: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40331: LD_ADDR_VAR 0 58
40335: PUSH
40336: LD_INT 0
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: EMPTY
40343: LIST
40344: LIST
40345: PUSH
40346: LD_INT 0
40348: PUSH
40349: LD_INT 1
40351: NEG
40352: PUSH
40353: EMPTY
40354: LIST
40355: LIST
40356: PUSH
40357: LD_INT 1
40359: PUSH
40360: LD_INT 0
40362: PUSH
40363: EMPTY
40364: LIST
40365: LIST
40366: PUSH
40367: LD_INT 1
40369: PUSH
40370: LD_INT 1
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: PUSH
40377: LD_INT 0
40379: PUSH
40380: LD_INT 1
40382: PUSH
40383: EMPTY
40384: LIST
40385: LIST
40386: PUSH
40387: LD_INT 1
40389: NEG
40390: PUSH
40391: LD_INT 0
40393: PUSH
40394: EMPTY
40395: LIST
40396: LIST
40397: PUSH
40398: LD_INT 1
40400: NEG
40401: PUSH
40402: LD_INT 1
40404: NEG
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 1
40412: NEG
40413: PUSH
40414: LD_INT 2
40416: NEG
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: LD_INT 0
40424: PUSH
40425: LD_INT 2
40427: NEG
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: PUSH
40433: LD_INT 1
40435: PUSH
40436: LD_INT 1
40438: NEG
40439: PUSH
40440: EMPTY
40441: LIST
40442: LIST
40443: PUSH
40444: LD_INT 2
40446: PUSH
40447: LD_INT 0
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: PUSH
40454: LD_INT 2
40456: PUSH
40457: LD_INT 1
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PUSH
40464: LD_INT 2
40466: PUSH
40467: LD_INT 2
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 1
40476: PUSH
40477: LD_INT 2
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: LD_INT 0
40486: PUSH
40487: LD_INT 2
40489: PUSH
40490: EMPTY
40491: LIST
40492: LIST
40493: PUSH
40494: LD_INT 1
40496: NEG
40497: PUSH
40498: LD_INT 1
40500: PUSH
40501: EMPTY
40502: LIST
40503: LIST
40504: PUSH
40505: LD_INT 2
40507: NEG
40508: PUSH
40509: LD_INT 0
40511: PUSH
40512: EMPTY
40513: LIST
40514: LIST
40515: PUSH
40516: LD_INT 2
40518: NEG
40519: PUSH
40520: LD_INT 1
40522: NEG
40523: PUSH
40524: EMPTY
40525: LIST
40526: LIST
40527: PUSH
40528: LD_INT 2
40530: NEG
40531: PUSH
40532: LD_INT 2
40534: NEG
40535: PUSH
40536: EMPTY
40537: LIST
40538: LIST
40539: PUSH
40540: EMPTY
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: LIST
40554: LIST
40555: LIST
40556: LIST
40557: LIST
40558: LIST
40559: LIST
40560: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40561: LD_ADDR_VAR 0 59
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 0
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 0
40578: PUSH
40579: LD_INT 1
40581: NEG
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: LD_INT 0
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 1
40599: PUSH
40600: LD_INT 1
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 0
40609: PUSH
40610: LD_INT 1
40612: PUSH
40613: EMPTY
40614: LIST
40615: LIST
40616: PUSH
40617: LD_INT 1
40619: NEG
40620: PUSH
40621: LD_INT 0
40623: PUSH
40624: EMPTY
40625: LIST
40626: LIST
40627: PUSH
40628: LD_INT 1
40630: NEG
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: EMPTY
40637: LIST
40638: LIST
40639: PUSH
40640: EMPTY
40641: LIST
40642: LIST
40643: LIST
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40649: LD_ADDR_VAR 0 60
40653: PUSH
40654: LD_INT 0
40656: PUSH
40657: LD_INT 0
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: PUSH
40664: LD_INT 0
40666: PUSH
40667: LD_INT 1
40669: NEG
40670: PUSH
40671: EMPTY
40672: LIST
40673: LIST
40674: PUSH
40675: LD_INT 1
40677: PUSH
40678: LD_INT 0
40680: PUSH
40681: EMPTY
40682: LIST
40683: LIST
40684: PUSH
40685: LD_INT 1
40687: PUSH
40688: LD_INT 1
40690: PUSH
40691: EMPTY
40692: LIST
40693: LIST
40694: PUSH
40695: LD_INT 0
40697: PUSH
40698: LD_INT 1
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 1
40707: NEG
40708: PUSH
40709: LD_INT 0
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 1
40718: NEG
40719: PUSH
40720: LD_INT 1
40722: NEG
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: EMPTY
40729: LIST
40730: LIST
40731: LIST
40732: LIST
40733: LIST
40734: LIST
40735: LIST
40736: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40737: LD_ADDR_VAR 0 61
40741: PUSH
40742: LD_INT 0
40744: PUSH
40745: LD_INT 0
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 0
40754: PUSH
40755: LD_INT 1
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: LD_INT 1
40765: PUSH
40766: LD_INT 0
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: LD_INT 1
40775: PUSH
40776: LD_INT 1
40778: PUSH
40779: EMPTY
40780: LIST
40781: LIST
40782: PUSH
40783: LD_INT 0
40785: PUSH
40786: LD_INT 1
40788: PUSH
40789: EMPTY
40790: LIST
40791: LIST
40792: PUSH
40793: LD_INT 1
40795: NEG
40796: PUSH
40797: LD_INT 0
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 1
40806: NEG
40807: PUSH
40808: LD_INT 1
40810: NEG
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: LIST
40820: LIST
40821: LIST
40822: LIST
40823: LIST
40824: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40825: LD_ADDR_VAR 0 62
40829: PUSH
40830: LD_INT 0
40832: PUSH
40833: LD_INT 0
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 0
40842: PUSH
40843: LD_INT 1
40845: NEG
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 1
40853: PUSH
40854: LD_INT 0
40856: PUSH
40857: EMPTY
40858: LIST
40859: LIST
40860: PUSH
40861: LD_INT 1
40863: PUSH
40864: LD_INT 1
40866: PUSH
40867: EMPTY
40868: LIST
40869: LIST
40870: PUSH
40871: LD_INT 0
40873: PUSH
40874: LD_INT 1
40876: PUSH
40877: EMPTY
40878: LIST
40879: LIST
40880: PUSH
40881: LD_INT 1
40883: NEG
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 1
40894: NEG
40895: PUSH
40896: LD_INT 1
40898: NEG
40899: PUSH
40900: EMPTY
40901: LIST
40902: LIST
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: LIST
40908: LIST
40909: LIST
40910: LIST
40911: LIST
40912: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40913: LD_ADDR_VAR 0 63
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: LD_INT 0
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 0
40930: PUSH
40931: LD_INT 1
40933: NEG
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 1
40941: PUSH
40942: LD_INT 0
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 1
40951: PUSH
40952: LD_INT 1
40954: PUSH
40955: EMPTY
40956: LIST
40957: LIST
40958: PUSH
40959: LD_INT 0
40961: PUSH
40962: LD_INT 1
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 1
40971: NEG
40972: PUSH
40973: LD_INT 0
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 1
40982: NEG
40983: PUSH
40984: LD_INT 1
40986: NEG
40987: PUSH
40988: EMPTY
40989: LIST
40990: LIST
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: LIST
40996: LIST
40997: LIST
40998: LIST
40999: LIST
41000: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41001: LD_ADDR_VAR 0 64
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 0
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 0
41018: PUSH
41019: LD_INT 1
41021: NEG
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 1
41029: PUSH
41030: LD_INT 0
41032: PUSH
41033: EMPTY
41034: LIST
41035: LIST
41036: PUSH
41037: LD_INT 1
41039: PUSH
41040: LD_INT 1
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: PUSH
41047: LD_INT 0
41049: PUSH
41050: LD_INT 1
41052: PUSH
41053: EMPTY
41054: LIST
41055: LIST
41056: PUSH
41057: LD_INT 1
41059: NEG
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 1
41070: NEG
41071: PUSH
41072: LD_INT 1
41074: NEG
41075: PUSH
41076: EMPTY
41077: LIST
41078: LIST
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: LIST
41084: LIST
41085: LIST
41086: LIST
41087: LIST
41088: ST_TO_ADDR
// end ; 1 :
41089: GO 46986
41091: LD_INT 1
41093: DOUBLE
41094: EQUAL
41095: IFTRUE 41099
41097: GO 43722
41099: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41100: LD_ADDR_VAR 0 11
41104: PUSH
41105: LD_INT 1
41107: NEG
41108: PUSH
41109: LD_INT 3
41111: NEG
41112: PUSH
41113: EMPTY
41114: LIST
41115: LIST
41116: PUSH
41117: LD_INT 0
41119: PUSH
41120: LD_INT 3
41122: NEG
41123: PUSH
41124: EMPTY
41125: LIST
41126: LIST
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: NEG
41134: PUSH
41135: EMPTY
41136: LIST
41137: LIST
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: LIST
41143: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41144: LD_ADDR_VAR 0 12
41148: PUSH
41149: LD_INT 2
41151: PUSH
41152: LD_INT 1
41154: NEG
41155: PUSH
41156: EMPTY
41157: LIST
41158: LIST
41159: PUSH
41160: LD_INT 3
41162: PUSH
41163: LD_INT 0
41165: PUSH
41166: EMPTY
41167: LIST
41168: LIST
41169: PUSH
41170: LD_INT 3
41172: PUSH
41173: LD_INT 1
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: LIST
41184: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41185: LD_ADDR_VAR 0 13
41189: PUSH
41190: LD_INT 3
41192: PUSH
41193: LD_INT 2
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: LD_INT 3
41202: PUSH
41203: LD_INT 3
41205: PUSH
41206: EMPTY
41207: LIST
41208: LIST
41209: PUSH
41210: LD_INT 2
41212: PUSH
41213: LD_INT 3
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: LIST
41224: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41225: LD_ADDR_VAR 0 14
41229: PUSH
41230: LD_INT 1
41232: PUSH
41233: LD_INT 3
41235: PUSH
41236: EMPTY
41237: LIST
41238: LIST
41239: PUSH
41240: LD_INT 0
41242: PUSH
41243: LD_INT 3
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 1
41252: NEG
41253: PUSH
41254: LD_INT 2
41256: PUSH
41257: EMPTY
41258: LIST
41259: LIST
41260: PUSH
41261: EMPTY
41262: LIST
41263: LIST
41264: LIST
41265: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41266: LD_ADDR_VAR 0 15
41270: PUSH
41271: LD_INT 2
41273: NEG
41274: PUSH
41275: LD_INT 1
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: LD_INT 3
41284: NEG
41285: PUSH
41286: LD_INT 0
41288: PUSH
41289: EMPTY
41290: LIST
41291: LIST
41292: PUSH
41293: LD_INT 3
41295: NEG
41296: PUSH
41297: LD_INT 1
41299: NEG
41300: PUSH
41301: EMPTY
41302: LIST
41303: LIST
41304: PUSH
41305: EMPTY
41306: LIST
41307: LIST
41308: LIST
41309: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41310: LD_ADDR_VAR 0 16
41314: PUSH
41315: LD_INT 2
41317: NEG
41318: PUSH
41319: LD_INT 3
41321: NEG
41322: PUSH
41323: EMPTY
41324: LIST
41325: LIST
41326: PUSH
41327: LD_INT 3
41329: NEG
41330: PUSH
41331: LD_INT 2
41333: NEG
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 3
41341: NEG
41342: PUSH
41343: LD_INT 3
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: LIST
41355: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41356: LD_ADDR_VAR 0 17
41360: PUSH
41361: LD_INT 1
41363: NEG
41364: PUSH
41365: LD_INT 3
41367: NEG
41368: PUSH
41369: EMPTY
41370: LIST
41371: LIST
41372: PUSH
41373: LD_INT 0
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: PUSH
41384: LD_INT 1
41386: PUSH
41387: LD_INT 2
41389: NEG
41390: PUSH
41391: EMPTY
41392: LIST
41393: LIST
41394: PUSH
41395: EMPTY
41396: LIST
41397: LIST
41398: LIST
41399: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41400: LD_ADDR_VAR 0 18
41404: PUSH
41405: LD_INT 2
41407: PUSH
41408: LD_INT 1
41410: NEG
41411: PUSH
41412: EMPTY
41413: LIST
41414: LIST
41415: PUSH
41416: LD_INT 3
41418: PUSH
41419: LD_INT 0
41421: PUSH
41422: EMPTY
41423: LIST
41424: LIST
41425: PUSH
41426: LD_INT 3
41428: PUSH
41429: LD_INT 1
41431: PUSH
41432: EMPTY
41433: LIST
41434: LIST
41435: PUSH
41436: EMPTY
41437: LIST
41438: LIST
41439: LIST
41440: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41441: LD_ADDR_VAR 0 19
41445: PUSH
41446: LD_INT 3
41448: PUSH
41449: LD_INT 2
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: LD_INT 3
41458: PUSH
41459: LD_INT 3
41461: PUSH
41462: EMPTY
41463: LIST
41464: LIST
41465: PUSH
41466: LD_INT 2
41468: PUSH
41469: LD_INT 3
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: PUSH
41476: EMPTY
41477: LIST
41478: LIST
41479: LIST
41480: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41481: LD_ADDR_VAR 0 20
41485: PUSH
41486: LD_INT 1
41488: PUSH
41489: LD_INT 3
41491: PUSH
41492: EMPTY
41493: LIST
41494: LIST
41495: PUSH
41496: LD_INT 0
41498: PUSH
41499: LD_INT 3
41501: PUSH
41502: EMPTY
41503: LIST
41504: LIST
41505: PUSH
41506: LD_INT 1
41508: NEG
41509: PUSH
41510: LD_INT 2
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: EMPTY
41518: LIST
41519: LIST
41520: LIST
41521: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41522: LD_ADDR_VAR 0 21
41526: PUSH
41527: LD_INT 2
41529: NEG
41530: PUSH
41531: LD_INT 1
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 3
41540: NEG
41541: PUSH
41542: LD_INT 0
41544: PUSH
41545: EMPTY
41546: LIST
41547: LIST
41548: PUSH
41549: LD_INT 3
41551: NEG
41552: PUSH
41553: LD_INT 1
41555: NEG
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: LIST
41565: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41566: LD_ADDR_VAR 0 22
41570: PUSH
41571: LD_INT 2
41573: NEG
41574: PUSH
41575: LD_INT 3
41577: NEG
41578: PUSH
41579: EMPTY
41580: LIST
41581: LIST
41582: PUSH
41583: LD_INT 3
41585: NEG
41586: PUSH
41587: LD_INT 2
41589: NEG
41590: PUSH
41591: EMPTY
41592: LIST
41593: LIST
41594: PUSH
41595: LD_INT 3
41597: NEG
41598: PUSH
41599: LD_INT 3
41601: NEG
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: EMPTY
41608: LIST
41609: LIST
41610: LIST
41611: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41612: LD_ADDR_VAR 0 23
41616: PUSH
41617: LD_INT 0
41619: PUSH
41620: LD_INT 3
41622: NEG
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: LD_INT 1
41630: NEG
41631: PUSH
41632: LD_INT 4
41634: NEG
41635: PUSH
41636: EMPTY
41637: LIST
41638: LIST
41639: PUSH
41640: LD_INT 1
41642: PUSH
41643: LD_INT 3
41645: NEG
41646: PUSH
41647: EMPTY
41648: LIST
41649: LIST
41650: PUSH
41651: EMPTY
41652: LIST
41653: LIST
41654: LIST
41655: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41656: LD_ADDR_VAR 0 24
41660: PUSH
41661: LD_INT 3
41663: PUSH
41664: LD_INT 0
41666: PUSH
41667: EMPTY
41668: LIST
41669: LIST
41670: PUSH
41671: LD_INT 3
41673: PUSH
41674: LD_INT 1
41676: NEG
41677: PUSH
41678: EMPTY
41679: LIST
41680: LIST
41681: PUSH
41682: LD_INT 4
41684: PUSH
41685: LD_INT 1
41687: PUSH
41688: EMPTY
41689: LIST
41690: LIST
41691: PUSH
41692: EMPTY
41693: LIST
41694: LIST
41695: LIST
41696: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41697: LD_ADDR_VAR 0 25
41701: PUSH
41702: LD_INT 3
41704: PUSH
41705: LD_INT 3
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: LD_INT 4
41714: PUSH
41715: LD_INT 3
41717: PUSH
41718: EMPTY
41719: LIST
41720: LIST
41721: PUSH
41722: LD_INT 3
41724: PUSH
41725: LD_INT 4
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: PUSH
41732: EMPTY
41733: LIST
41734: LIST
41735: LIST
41736: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41737: LD_ADDR_VAR 0 26
41741: PUSH
41742: LD_INT 0
41744: PUSH
41745: LD_INT 3
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PUSH
41752: LD_INT 1
41754: PUSH
41755: LD_INT 4
41757: PUSH
41758: EMPTY
41759: LIST
41760: LIST
41761: PUSH
41762: LD_INT 1
41764: NEG
41765: PUSH
41766: LD_INT 3
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: EMPTY
41774: LIST
41775: LIST
41776: LIST
41777: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41778: LD_ADDR_VAR 0 27
41782: PUSH
41783: LD_INT 3
41785: NEG
41786: PUSH
41787: LD_INT 0
41789: PUSH
41790: EMPTY
41791: LIST
41792: LIST
41793: PUSH
41794: LD_INT 3
41796: NEG
41797: PUSH
41798: LD_INT 1
41800: PUSH
41801: EMPTY
41802: LIST
41803: LIST
41804: PUSH
41805: LD_INT 4
41807: NEG
41808: PUSH
41809: LD_INT 1
41811: NEG
41812: PUSH
41813: EMPTY
41814: LIST
41815: LIST
41816: PUSH
41817: EMPTY
41818: LIST
41819: LIST
41820: LIST
41821: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41822: LD_ADDR_VAR 0 28
41826: PUSH
41827: LD_INT 3
41829: NEG
41830: PUSH
41831: LD_INT 3
41833: NEG
41834: PUSH
41835: EMPTY
41836: LIST
41837: LIST
41838: PUSH
41839: LD_INT 3
41841: NEG
41842: PUSH
41843: LD_INT 4
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 4
41853: NEG
41854: PUSH
41855: LD_INT 3
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: EMPTY
41864: LIST
41865: LIST
41866: LIST
41867: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41868: LD_ADDR_VAR 0 29
41872: PUSH
41873: LD_INT 1
41875: NEG
41876: PUSH
41877: LD_INT 3
41879: NEG
41880: PUSH
41881: EMPTY
41882: LIST
41883: LIST
41884: PUSH
41885: LD_INT 0
41887: PUSH
41888: LD_INT 3
41890: NEG
41891: PUSH
41892: EMPTY
41893: LIST
41894: LIST
41895: PUSH
41896: LD_INT 1
41898: PUSH
41899: LD_INT 2
41901: NEG
41902: PUSH
41903: EMPTY
41904: LIST
41905: LIST
41906: PUSH
41907: LD_INT 1
41909: NEG
41910: PUSH
41911: LD_INT 4
41913: NEG
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PUSH
41919: LD_INT 0
41921: PUSH
41922: LD_INT 4
41924: NEG
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 1
41932: PUSH
41933: LD_INT 3
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 1
41943: NEG
41944: PUSH
41945: LD_INT 5
41947: NEG
41948: PUSH
41949: EMPTY
41950: LIST
41951: LIST
41952: PUSH
41953: LD_INT 0
41955: PUSH
41956: LD_INT 5
41958: NEG
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: LD_INT 4
41969: NEG
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: NEG
41978: PUSH
41979: LD_INT 6
41981: NEG
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: PUSH
41987: LD_INT 0
41989: PUSH
41990: LD_INT 6
41992: NEG
41993: PUSH
41994: EMPTY
41995: LIST
41996: LIST
41997: PUSH
41998: LD_INT 1
42000: PUSH
42001: LD_INT 5
42003: NEG
42004: PUSH
42005: EMPTY
42006: LIST
42007: LIST
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: LIST
42013: LIST
42014: LIST
42015: LIST
42016: LIST
42017: LIST
42018: LIST
42019: LIST
42020: LIST
42021: LIST
42022: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42023: LD_ADDR_VAR 0 30
42027: PUSH
42028: LD_INT 2
42030: PUSH
42031: LD_INT 1
42033: NEG
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 3
42041: PUSH
42042: LD_INT 0
42044: PUSH
42045: EMPTY
42046: LIST
42047: LIST
42048: PUSH
42049: LD_INT 3
42051: PUSH
42052: LD_INT 1
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 3
42061: PUSH
42062: LD_INT 1
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 4
42072: PUSH
42073: LD_INT 0
42075: PUSH
42076: EMPTY
42077: LIST
42078: LIST
42079: PUSH
42080: LD_INT 4
42082: PUSH
42083: LD_INT 1
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: PUSH
42090: LD_INT 4
42092: PUSH
42093: LD_INT 1
42095: NEG
42096: PUSH
42097: EMPTY
42098: LIST
42099: LIST
42100: PUSH
42101: LD_INT 5
42103: PUSH
42104: LD_INT 0
42106: PUSH
42107: EMPTY
42108: LIST
42109: LIST
42110: PUSH
42111: LD_INT 5
42113: PUSH
42114: LD_INT 1
42116: PUSH
42117: EMPTY
42118: LIST
42119: LIST
42120: PUSH
42121: LD_INT 5
42123: PUSH
42124: LD_INT 1
42126: NEG
42127: PUSH
42128: EMPTY
42129: LIST
42130: LIST
42131: PUSH
42132: LD_INT 6
42134: PUSH
42135: LD_INT 0
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 6
42144: PUSH
42145: LD_INT 1
42147: PUSH
42148: EMPTY
42149: LIST
42150: LIST
42151: PUSH
42152: EMPTY
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: LIST
42163: LIST
42164: LIST
42165: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42166: LD_ADDR_VAR 0 31
42170: PUSH
42171: LD_INT 3
42173: PUSH
42174: LD_INT 2
42176: PUSH
42177: EMPTY
42178: LIST
42179: LIST
42180: PUSH
42181: LD_INT 3
42183: PUSH
42184: LD_INT 3
42186: PUSH
42187: EMPTY
42188: LIST
42189: LIST
42190: PUSH
42191: LD_INT 2
42193: PUSH
42194: LD_INT 3
42196: PUSH
42197: EMPTY
42198: LIST
42199: LIST
42200: PUSH
42201: LD_INT 4
42203: PUSH
42204: LD_INT 3
42206: PUSH
42207: EMPTY
42208: LIST
42209: LIST
42210: PUSH
42211: LD_INT 4
42213: PUSH
42214: LD_INT 4
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 3
42223: PUSH
42224: LD_INT 4
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 5
42233: PUSH
42234: LD_INT 4
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 5
42243: PUSH
42244: LD_INT 5
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 4
42253: PUSH
42254: LD_INT 5
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 6
42263: PUSH
42264: LD_INT 5
42266: PUSH
42267: EMPTY
42268: LIST
42269: LIST
42270: PUSH
42271: LD_INT 6
42273: PUSH
42274: LD_INT 6
42276: PUSH
42277: EMPTY
42278: LIST
42279: LIST
42280: PUSH
42281: LD_INT 5
42283: PUSH
42284: LD_INT 6
42286: PUSH
42287: EMPTY
42288: LIST
42289: LIST
42290: PUSH
42291: EMPTY
42292: LIST
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42305: LD_ADDR_VAR 0 32
42309: PUSH
42310: LD_INT 1
42312: PUSH
42313: LD_INT 3
42315: PUSH
42316: EMPTY
42317: LIST
42318: LIST
42319: PUSH
42320: LD_INT 0
42322: PUSH
42323: LD_INT 3
42325: PUSH
42326: EMPTY
42327: LIST
42328: LIST
42329: PUSH
42330: LD_INT 1
42332: NEG
42333: PUSH
42334: LD_INT 2
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: LD_INT 1
42343: PUSH
42344: LD_INT 4
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 0
42353: PUSH
42354: LD_INT 4
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 1
42363: NEG
42364: PUSH
42365: LD_INT 3
42367: PUSH
42368: EMPTY
42369: LIST
42370: LIST
42371: PUSH
42372: LD_INT 1
42374: PUSH
42375: LD_INT 5
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 0
42384: PUSH
42385: LD_INT 5
42387: PUSH
42388: EMPTY
42389: LIST
42390: LIST
42391: PUSH
42392: LD_INT 1
42394: NEG
42395: PUSH
42396: LD_INT 4
42398: PUSH
42399: EMPTY
42400: LIST
42401: LIST
42402: PUSH
42403: LD_INT 1
42405: PUSH
42406: LD_INT 6
42408: PUSH
42409: EMPTY
42410: LIST
42411: LIST
42412: PUSH
42413: LD_INT 0
42415: PUSH
42416: LD_INT 6
42418: PUSH
42419: EMPTY
42420: LIST
42421: LIST
42422: PUSH
42423: LD_INT 1
42425: NEG
42426: PUSH
42427: LD_INT 5
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: EMPTY
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42448: LD_ADDR_VAR 0 33
42452: PUSH
42453: LD_INT 2
42455: NEG
42456: PUSH
42457: LD_INT 1
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 3
42466: NEG
42467: PUSH
42468: LD_INT 0
42470: PUSH
42471: EMPTY
42472: LIST
42473: LIST
42474: PUSH
42475: LD_INT 3
42477: NEG
42478: PUSH
42479: LD_INT 1
42481: NEG
42482: PUSH
42483: EMPTY
42484: LIST
42485: LIST
42486: PUSH
42487: LD_INT 3
42489: NEG
42490: PUSH
42491: LD_INT 1
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 4
42500: NEG
42501: PUSH
42502: LD_INT 0
42504: PUSH
42505: EMPTY
42506: LIST
42507: LIST
42508: PUSH
42509: LD_INT 4
42511: NEG
42512: PUSH
42513: LD_INT 1
42515: NEG
42516: PUSH
42517: EMPTY
42518: LIST
42519: LIST
42520: PUSH
42521: LD_INT 4
42523: NEG
42524: PUSH
42525: LD_INT 1
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 5
42534: NEG
42535: PUSH
42536: LD_INT 0
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 5
42545: NEG
42546: PUSH
42547: LD_INT 1
42549: NEG
42550: PUSH
42551: EMPTY
42552: LIST
42553: LIST
42554: PUSH
42555: LD_INT 5
42557: NEG
42558: PUSH
42559: LD_INT 1
42561: PUSH
42562: EMPTY
42563: LIST
42564: LIST
42565: PUSH
42566: LD_INT 6
42568: NEG
42569: PUSH
42570: LD_INT 0
42572: PUSH
42573: EMPTY
42574: LIST
42575: LIST
42576: PUSH
42577: LD_INT 6
42579: NEG
42580: PUSH
42581: LD_INT 1
42583: NEG
42584: PUSH
42585: EMPTY
42586: LIST
42587: LIST
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: LIST
42593: LIST
42594: LIST
42595: LIST
42596: LIST
42597: LIST
42598: LIST
42599: LIST
42600: LIST
42601: LIST
42602: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42603: LD_ADDR_VAR 0 34
42607: PUSH
42608: LD_INT 2
42610: NEG
42611: PUSH
42612: LD_INT 3
42614: NEG
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 3
42622: NEG
42623: PUSH
42624: LD_INT 2
42626: NEG
42627: PUSH
42628: EMPTY
42629: LIST
42630: LIST
42631: PUSH
42632: LD_INT 3
42634: NEG
42635: PUSH
42636: LD_INT 3
42638: NEG
42639: PUSH
42640: EMPTY
42641: LIST
42642: LIST
42643: PUSH
42644: LD_INT 3
42646: NEG
42647: PUSH
42648: LD_INT 4
42650: NEG
42651: PUSH
42652: EMPTY
42653: LIST
42654: LIST
42655: PUSH
42656: LD_INT 4
42658: NEG
42659: PUSH
42660: LD_INT 3
42662: NEG
42663: PUSH
42664: EMPTY
42665: LIST
42666: LIST
42667: PUSH
42668: LD_INT 4
42670: NEG
42671: PUSH
42672: LD_INT 4
42674: NEG
42675: PUSH
42676: EMPTY
42677: LIST
42678: LIST
42679: PUSH
42680: LD_INT 4
42682: NEG
42683: PUSH
42684: LD_INT 5
42686: NEG
42687: PUSH
42688: EMPTY
42689: LIST
42690: LIST
42691: PUSH
42692: LD_INT 5
42694: NEG
42695: PUSH
42696: LD_INT 4
42698: NEG
42699: PUSH
42700: EMPTY
42701: LIST
42702: LIST
42703: PUSH
42704: LD_INT 5
42706: NEG
42707: PUSH
42708: LD_INT 5
42710: NEG
42711: PUSH
42712: EMPTY
42713: LIST
42714: LIST
42715: PUSH
42716: LD_INT 5
42718: NEG
42719: PUSH
42720: LD_INT 6
42722: NEG
42723: PUSH
42724: EMPTY
42725: LIST
42726: LIST
42727: PUSH
42728: LD_INT 6
42730: NEG
42731: PUSH
42732: LD_INT 5
42734: NEG
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 6
42742: NEG
42743: PUSH
42744: LD_INT 6
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: EMPTY
42753: LIST
42754: LIST
42755: LIST
42756: LIST
42757: LIST
42758: LIST
42759: LIST
42760: LIST
42761: LIST
42762: LIST
42763: LIST
42764: LIST
42765: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42766: LD_ADDR_VAR 0 41
42770: PUSH
42771: LD_INT 0
42773: PUSH
42774: LD_INT 2
42776: NEG
42777: PUSH
42778: EMPTY
42779: LIST
42780: LIST
42781: PUSH
42782: LD_INT 1
42784: NEG
42785: PUSH
42786: LD_INT 3
42788: NEG
42789: PUSH
42790: EMPTY
42791: LIST
42792: LIST
42793: PUSH
42794: LD_INT 1
42796: PUSH
42797: LD_INT 2
42799: NEG
42800: PUSH
42801: EMPTY
42802: LIST
42803: LIST
42804: PUSH
42805: EMPTY
42806: LIST
42807: LIST
42808: LIST
42809: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42810: LD_ADDR_VAR 0 42
42814: PUSH
42815: LD_INT 2
42817: PUSH
42818: LD_INT 0
42820: PUSH
42821: EMPTY
42822: LIST
42823: LIST
42824: PUSH
42825: LD_INT 2
42827: PUSH
42828: LD_INT 1
42830: NEG
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 3
42838: PUSH
42839: LD_INT 1
42841: PUSH
42842: EMPTY
42843: LIST
42844: LIST
42845: PUSH
42846: EMPTY
42847: LIST
42848: LIST
42849: LIST
42850: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42851: LD_ADDR_VAR 0 43
42855: PUSH
42856: LD_INT 2
42858: PUSH
42859: LD_INT 2
42861: PUSH
42862: EMPTY
42863: LIST
42864: LIST
42865: PUSH
42866: LD_INT 3
42868: PUSH
42869: LD_INT 2
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 2
42878: PUSH
42879: LD_INT 3
42881: PUSH
42882: EMPTY
42883: LIST
42884: LIST
42885: PUSH
42886: EMPTY
42887: LIST
42888: LIST
42889: LIST
42890: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
42891: LD_ADDR_VAR 0 44
42895: PUSH
42896: LD_INT 0
42898: PUSH
42899: LD_INT 2
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 1
42908: PUSH
42909: LD_INT 3
42911: PUSH
42912: EMPTY
42913: LIST
42914: LIST
42915: PUSH
42916: LD_INT 1
42918: NEG
42919: PUSH
42920: LD_INT 2
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: LIST
42931: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
42932: LD_ADDR_VAR 0 45
42936: PUSH
42937: LD_INT 2
42939: NEG
42940: PUSH
42941: LD_INT 0
42943: PUSH
42944: EMPTY
42945: LIST
42946: LIST
42947: PUSH
42948: LD_INT 2
42950: NEG
42951: PUSH
42952: LD_INT 1
42954: PUSH
42955: EMPTY
42956: LIST
42957: LIST
42958: PUSH
42959: LD_INT 3
42961: NEG
42962: PUSH
42963: LD_INT 1
42965: NEG
42966: PUSH
42967: EMPTY
42968: LIST
42969: LIST
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: LIST
42975: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
42976: LD_ADDR_VAR 0 46
42980: PUSH
42981: LD_INT 2
42983: NEG
42984: PUSH
42985: LD_INT 2
42987: NEG
42988: PUSH
42989: EMPTY
42990: LIST
42991: LIST
42992: PUSH
42993: LD_INT 2
42995: NEG
42996: PUSH
42997: LD_INT 3
42999: NEG
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 3
43007: NEG
43008: PUSH
43009: LD_INT 2
43011: NEG
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: EMPTY
43018: LIST
43019: LIST
43020: LIST
43021: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43022: LD_ADDR_VAR 0 47
43026: PUSH
43027: LD_INT 2
43029: NEG
43030: PUSH
43031: LD_INT 3
43033: NEG
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 1
43041: NEG
43042: PUSH
43043: LD_INT 3
43045: NEG
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43055: LD_ADDR_VAR 0 48
43059: PUSH
43060: LD_INT 1
43062: PUSH
43063: LD_INT 2
43065: NEG
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 2
43073: PUSH
43074: LD_INT 1
43076: NEG
43077: PUSH
43078: EMPTY
43079: LIST
43080: LIST
43081: PUSH
43082: EMPTY
43083: LIST
43084: LIST
43085: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43086: LD_ADDR_VAR 0 49
43090: PUSH
43091: LD_INT 3
43093: PUSH
43094: LD_INT 1
43096: PUSH
43097: EMPTY
43098: LIST
43099: LIST
43100: PUSH
43101: LD_INT 3
43103: PUSH
43104: LD_INT 2
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43115: LD_ADDR_VAR 0 50
43119: PUSH
43120: LD_INT 2
43122: PUSH
43123: LD_INT 3
43125: PUSH
43126: EMPTY
43127: LIST
43128: LIST
43129: PUSH
43130: LD_INT 1
43132: PUSH
43133: LD_INT 3
43135: PUSH
43136: EMPTY
43137: LIST
43138: LIST
43139: PUSH
43140: EMPTY
43141: LIST
43142: LIST
43143: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43144: LD_ADDR_VAR 0 51
43148: PUSH
43149: LD_INT 1
43151: NEG
43152: PUSH
43153: LD_INT 2
43155: PUSH
43156: EMPTY
43157: LIST
43158: LIST
43159: PUSH
43160: LD_INT 2
43162: NEG
43163: PUSH
43164: LD_INT 1
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43175: LD_ADDR_VAR 0 52
43179: PUSH
43180: LD_INT 3
43182: NEG
43183: PUSH
43184: LD_INT 1
43186: NEG
43187: PUSH
43188: EMPTY
43189: LIST
43190: LIST
43191: PUSH
43192: LD_INT 3
43194: NEG
43195: PUSH
43196: LD_INT 2
43198: NEG
43199: PUSH
43200: EMPTY
43201: LIST
43202: LIST
43203: PUSH
43204: EMPTY
43205: LIST
43206: LIST
43207: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43208: LD_ADDR_VAR 0 53
43212: PUSH
43213: LD_INT 1
43215: NEG
43216: PUSH
43217: LD_INT 3
43219: NEG
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: LD_INT 0
43227: PUSH
43228: LD_INT 3
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 1
43238: PUSH
43239: LD_INT 2
43241: NEG
43242: PUSH
43243: EMPTY
43244: LIST
43245: LIST
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: LIST
43251: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43252: LD_ADDR_VAR 0 54
43256: PUSH
43257: LD_INT 2
43259: PUSH
43260: LD_INT 1
43262: NEG
43263: PUSH
43264: EMPTY
43265: LIST
43266: LIST
43267: PUSH
43268: LD_INT 3
43270: PUSH
43271: LD_INT 0
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: PUSH
43278: LD_INT 3
43280: PUSH
43281: LD_INT 1
43283: PUSH
43284: EMPTY
43285: LIST
43286: LIST
43287: PUSH
43288: EMPTY
43289: LIST
43290: LIST
43291: LIST
43292: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43293: LD_ADDR_VAR 0 55
43297: PUSH
43298: LD_INT 3
43300: PUSH
43301: LD_INT 2
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 3
43310: PUSH
43311: LD_INT 3
43313: PUSH
43314: EMPTY
43315: LIST
43316: LIST
43317: PUSH
43318: LD_INT 2
43320: PUSH
43321: LD_INT 3
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: LIST
43332: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43333: LD_ADDR_VAR 0 56
43337: PUSH
43338: LD_INT 1
43340: PUSH
43341: LD_INT 3
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: PUSH
43348: LD_INT 0
43350: PUSH
43351: LD_INT 3
43353: PUSH
43354: EMPTY
43355: LIST
43356: LIST
43357: PUSH
43358: LD_INT 1
43360: NEG
43361: PUSH
43362: LD_INT 2
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: PUSH
43369: EMPTY
43370: LIST
43371: LIST
43372: LIST
43373: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43374: LD_ADDR_VAR 0 57
43378: PUSH
43379: LD_INT 2
43381: NEG
43382: PUSH
43383: LD_INT 1
43385: PUSH
43386: EMPTY
43387: LIST
43388: LIST
43389: PUSH
43390: LD_INT 3
43392: NEG
43393: PUSH
43394: LD_INT 0
43396: PUSH
43397: EMPTY
43398: LIST
43399: LIST
43400: PUSH
43401: LD_INT 3
43403: NEG
43404: PUSH
43405: LD_INT 1
43407: NEG
43408: PUSH
43409: EMPTY
43410: LIST
43411: LIST
43412: PUSH
43413: EMPTY
43414: LIST
43415: LIST
43416: LIST
43417: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43418: LD_ADDR_VAR 0 58
43422: PUSH
43423: LD_INT 2
43425: NEG
43426: PUSH
43427: LD_INT 3
43429: NEG
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 3
43437: NEG
43438: PUSH
43439: LD_INT 2
43441: NEG
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PUSH
43447: LD_INT 3
43449: NEG
43450: PUSH
43451: LD_INT 3
43453: NEG
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: EMPTY
43460: LIST
43461: LIST
43462: LIST
43463: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43464: LD_ADDR_VAR 0 59
43468: PUSH
43469: LD_INT 1
43471: NEG
43472: PUSH
43473: LD_INT 2
43475: NEG
43476: PUSH
43477: EMPTY
43478: LIST
43479: LIST
43480: PUSH
43481: LD_INT 0
43483: PUSH
43484: LD_INT 2
43486: NEG
43487: PUSH
43488: EMPTY
43489: LIST
43490: LIST
43491: PUSH
43492: LD_INT 1
43494: PUSH
43495: LD_INT 1
43497: NEG
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43508: LD_ADDR_VAR 0 60
43512: PUSH
43513: LD_INT 1
43515: PUSH
43516: LD_INT 1
43518: NEG
43519: PUSH
43520: EMPTY
43521: LIST
43522: LIST
43523: PUSH
43524: LD_INT 2
43526: PUSH
43527: LD_INT 0
43529: PUSH
43530: EMPTY
43531: LIST
43532: LIST
43533: PUSH
43534: LD_INT 2
43536: PUSH
43537: LD_INT 1
43539: PUSH
43540: EMPTY
43541: LIST
43542: LIST
43543: PUSH
43544: EMPTY
43545: LIST
43546: LIST
43547: LIST
43548: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43549: LD_ADDR_VAR 0 61
43553: PUSH
43554: LD_INT 2
43556: PUSH
43557: LD_INT 1
43559: PUSH
43560: EMPTY
43561: LIST
43562: LIST
43563: PUSH
43564: LD_INT 2
43566: PUSH
43567: LD_INT 2
43569: PUSH
43570: EMPTY
43571: LIST
43572: LIST
43573: PUSH
43574: LD_INT 1
43576: PUSH
43577: LD_INT 2
43579: PUSH
43580: EMPTY
43581: LIST
43582: LIST
43583: PUSH
43584: EMPTY
43585: LIST
43586: LIST
43587: LIST
43588: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43589: LD_ADDR_VAR 0 62
43593: PUSH
43594: LD_INT 1
43596: PUSH
43597: LD_INT 2
43599: PUSH
43600: EMPTY
43601: LIST
43602: LIST
43603: PUSH
43604: LD_INT 0
43606: PUSH
43607: LD_INT 2
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 1
43616: NEG
43617: PUSH
43618: LD_INT 1
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: EMPTY
43626: LIST
43627: LIST
43628: LIST
43629: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43630: LD_ADDR_VAR 0 63
43634: PUSH
43635: LD_INT 1
43637: NEG
43638: PUSH
43639: LD_INT 1
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 2
43648: NEG
43649: PUSH
43650: LD_INT 0
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 2
43659: NEG
43660: PUSH
43661: LD_INT 1
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: EMPTY
43670: LIST
43671: LIST
43672: LIST
43673: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43674: LD_ADDR_VAR 0 64
43678: PUSH
43679: LD_INT 1
43681: NEG
43682: PUSH
43683: LD_INT 2
43685: NEG
43686: PUSH
43687: EMPTY
43688: LIST
43689: LIST
43690: PUSH
43691: LD_INT 2
43693: NEG
43694: PUSH
43695: LD_INT 1
43697: NEG
43698: PUSH
43699: EMPTY
43700: LIST
43701: LIST
43702: PUSH
43703: LD_INT 2
43705: NEG
43706: PUSH
43707: LD_INT 2
43709: NEG
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: EMPTY
43716: LIST
43717: LIST
43718: LIST
43719: ST_TO_ADDR
// end ; 2 :
43720: GO 46986
43722: LD_INT 2
43724: DOUBLE
43725: EQUAL
43726: IFTRUE 43730
43728: GO 46985
43730: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43731: LD_ADDR_VAR 0 29
43735: PUSH
43736: LD_INT 4
43738: PUSH
43739: LD_INT 0
43741: PUSH
43742: EMPTY
43743: LIST
43744: LIST
43745: PUSH
43746: LD_INT 4
43748: PUSH
43749: LD_INT 1
43751: NEG
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 5
43759: PUSH
43760: LD_INT 0
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: LD_INT 5
43769: PUSH
43770: LD_INT 1
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 4
43779: PUSH
43780: LD_INT 1
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 3
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 3
43799: PUSH
43800: LD_INT 1
43802: NEG
43803: PUSH
43804: EMPTY
43805: LIST
43806: LIST
43807: PUSH
43808: LD_INT 3
43810: PUSH
43811: LD_INT 2
43813: NEG
43814: PUSH
43815: EMPTY
43816: LIST
43817: LIST
43818: PUSH
43819: LD_INT 5
43821: PUSH
43822: LD_INT 2
43824: PUSH
43825: EMPTY
43826: LIST
43827: LIST
43828: PUSH
43829: LD_INT 3
43831: PUSH
43832: LD_INT 3
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: PUSH
43839: LD_INT 3
43841: PUSH
43842: LD_INT 2
43844: PUSH
43845: EMPTY
43846: LIST
43847: LIST
43848: PUSH
43849: LD_INT 4
43851: PUSH
43852: LD_INT 3
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: PUSH
43859: LD_INT 4
43861: PUSH
43862: LD_INT 4
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 3
43871: PUSH
43872: LD_INT 4
43874: PUSH
43875: EMPTY
43876: LIST
43877: LIST
43878: PUSH
43879: LD_INT 2
43881: PUSH
43882: LD_INT 3
43884: PUSH
43885: EMPTY
43886: LIST
43887: LIST
43888: PUSH
43889: LD_INT 2
43891: PUSH
43892: LD_INT 2
43894: PUSH
43895: EMPTY
43896: LIST
43897: LIST
43898: PUSH
43899: LD_INT 4
43901: PUSH
43902: LD_INT 2
43904: PUSH
43905: EMPTY
43906: LIST
43907: LIST
43908: PUSH
43909: LD_INT 2
43911: PUSH
43912: LD_INT 4
43914: PUSH
43915: EMPTY
43916: LIST
43917: LIST
43918: PUSH
43919: LD_INT 0
43921: PUSH
43922: LD_INT 4
43924: PUSH
43925: EMPTY
43926: LIST
43927: LIST
43928: PUSH
43929: LD_INT 0
43931: PUSH
43932: LD_INT 3
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 1
43941: PUSH
43942: LD_INT 4
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 1
43951: PUSH
43952: LD_INT 5
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 0
43961: PUSH
43962: LD_INT 5
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 1
43971: NEG
43972: PUSH
43973: LD_INT 4
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 1
43982: NEG
43983: PUSH
43984: LD_INT 3
43986: PUSH
43987: EMPTY
43988: LIST
43989: LIST
43990: PUSH
43991: LD_INT 2
43993: PUSH
43994: LD_INT 5
43996: PUSH
43997: EMPTY
43998: LIST
43999: LIST
44000: PUSH
44001: LD_INT 2
44003: NEG
44004: PUSH
44005: LD_INT 3
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 3
44014: NEG
44015: PUSH
44016: LD_INT 0
44018: PUSH
44019: EMPTY
44020: LIST
44021: LIST
44022: PUSH
44023: LD_INT 3
44025: NEG
44026: PUSH
44027: LD_INT 1
44029: NEG
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 2
44037: NEG
44038: PUSH
44039: LD_INT 0
44041: PUSH
44042: EMPTY
44043: LIST
44044: LIST
44045: PUSH
44046: LD_INT 2
44048: NEG
44049: PUSH
44050: LD_INT 1
44052: PUSH
44053: EMPTY
44054: LIST
44055: LIST
44056: PUSH
44057: LD_INT 3
44059: NEG
44060: PUSH
44061: LD_INT 1
44063: PUSH
44064: EMPTY
44065: LIST
44066: LIST
44067: PUSH
44068: LD_INT 4
44070: NEG
44071: PUSH
44072: LD_INT 0
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 4
44081: NEG
44082: PUSH
44083: LD_INT 1
44085: NEG
44086: PUSH
44087: EMPTY
44088: LIST
44089: LIST
44090: PUSH
44091: LD_INT 4
44093: NEG
44094: PUSH
44095: LD_INT 2
44097: NEG
44098: PUSH
44099: EMPTY
44100: LIST
44101: LIST
44102: PUSH
44103: LD_INT 2
44105: NEG
44106: PUSH
44107: LD_INT 2
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 4
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 4
44128: NEG
44129: PUSH
44130: LD_INT 5
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 3
44140: NEG
44141: PUSH
44142: LD_INT 4
44144: NEG
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 3
44152: NEG
44153: PUSH
44154: LD_INT 3
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 4
44164: NEG
44165: PUSH
44166: LD_INT 3
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: LD_INT 4
44180: NEG
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 5
44188: NEG
44189: PUSH
44190: LD_INT 5
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 3
44200: NEG
44201: PUSH
44202: LD_INT 5
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 5
44212: NEG
44213: PUSH
44214: LD_INT 3
44216: NEG
44217: PUSH
44218: EMPTY
44219: LIST
44220: LIST
44221: PUSH
44222: EMPTY
44223: LIST
44224: LIST
44225: LIST
44226: LIST
44227: LIST
44228: LIST
44229: LIST
44230: LIST
44231: LIST
44232: LIST
44233: LIST
44234: LIST
44235: LIST
44236: LIST
44237: LIST
44238: LIST
44239: LIST
44240: LIST
44241: LIST
44242: LIST
44243: LIST
44244: LIST
44245: LIST
44246: LIST
44247: LIST
44248: LIST
44249: LIST
44250: LIST
44251: LIST
44252: LIST
44253: LIST
44254: LIST
44255: LIST
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44269: LD_ADDR_VAR 0 30
44273: PUSH
44274: LD_INT 4
44276: PUSH
44277: LD_INT 4
44279: PUSH
44280: EMPTY
44281: LIST
44282: LIST
44283: PUSH
44284: LD_INT 4
44286: PUSH
44287: LD_INT 3
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 5
44296: PUSH
44297: LD_INT 4
44299: PUSH
44300: EMPTY
44301: LIST
44302: LIST
44303: PUSH
44304: LD_INT 5
44306: PUSH
44307: LD_INT 5
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 4
44316: PUSH
44317: LD_INT 5
44319: PUSH
44320: EMPTY
44321: LIST
44322: LIST
44323: PUSH
44324: LD_INT 3
44326: PUSH
44327: LD_INT 4
44329: PUSH
44330: EMPTY
44331: LIST
44332: LIST
44333: PUSH
44334: LD_INT 3
44336: PUSH
44337: LD_INT 3
44339: PUSH
44340: EMPTY
44341: LIST
44342: LIST
44343: PUSH
44344: LD_INT 5
44346: PUSH
44347: LD_INT 3
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: PUSH
44354: LD_INT 3
44356: PUSH
44357: LD_INT 5
44359: PUSH
44360: EMPTY
44361: LIST
44362: LIST
44363: PUSH
44364: LD_INT 0
44366: PUSH
44367: LD_INT 3
44369: PUSH
44370: EMPTY
44371: LIST
44372: LIST
44373: PUSH
44374: LD_INT 0
44376: PUSH
44377: LD_INT 2
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 1
44386: PUSH
44387: LD_INT 3
44389: PUSH
44390: EMPTY
44391: LIST
44392: LIST
44393: PUSH
44394: LD_INT 1
44396: PUSH
44397: LD_INT 4
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 0
44406: PUSH
44407: LD_INT 4
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 1
44416: NEG
44417: PUSH
44418: LD_INT 3
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 1
44427: NEG
44428: PUSH
44429: LD_INT 2
44431: PUSH
44432: EMPTY
44433: LIST
44434: LIST
44435: PUSH
44436: LD_INT 2
44438: PUSH
44439: LD_INT 4
44441: PUSH
44442: EMPTY
44443: LIST
44444: LIST
44445: PUSH
44446: LD_INT 2
44448: NEG
44449: PUSH
44450: LD_INT 2
44452: PUSH
44453: EMPTY
44454: LIST
44455: LIST
44456: PUSH
44457: LD_INT 4
44459: NEG
44460: PUSH
44461: LD_INT 0
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PUSH
44468: LD_INT 4
44470: NEG
44471: PUSH
44472: LD_INT 1
44474: NEG
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 3
44482: NEG
44483: PUSH
44484: LD_INT 0
44486: PUSH
44487: EMPTY
44488: LIST
44489: LIST
44490: PUSH
44491: LD_INT 3
44493: NEG
44494: PUSH
44495: LD_INT 1
44497: PUSH
44498: EMPTY
44499: LIST
44500: LIST
44501: PUSH
44502: LD_INT 4
44504: NEG
44505: PUSH
44506: LD_INT 1
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PUSH
44513: LD_INT 5
44515: NEG
44516: PUSH
44517: LD_INT 0
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 5
44526: NEG
44527: PUSH
44528: LD_INT 1
44530: NEG
44531: PUSH
44532: EMPTY
44533: LIST
44534: LIST
44535: PUSH
44536: LD_INT 5
44538: NEG
44539: PUSH
44540: LD_INT 2
44542: NEG
44543: PUSH
44544: EMPTY
44545: LIST
44546: LIST
44547: PUSH
44548: LD_INT 3
44550: NEG
44551: PUSH
44552: LD_INT 2
44554: PUSH
44555: EMPTY
44556: LIST
44557: LIST
44558: PUSH
44559: LD_INT 3
44561: NEG
44562: PUSH
44563: LD_INT 3
44565: NEG
44566: PUSH
44567: EMPTY
44568: LIST
44569: LIST
44570: PUSH
44571: LD_INT 3
44573: NEG
44574: PUSH
44575: LD_INT 4
44577: NEG
44578: PUSH
44579: EMPTY
44580: LIST
44581: LIST
44582: PUSH
44583: LD_INT 2
44585: NEG
44586: PUSH
44587: LD_INT 3
44589: NEG
44590: PUSH
44591: EMPTY
44592: LIST
44593: LIST
44594: PUSH
44595: LD_INT 2
44597: NEG
44598: PUSH
44599: LD_INT 2
44601: NEG
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 3
44609: NEG
44610: PUSH
44611: LD_INT 2
44613: NEG
44614: PUSH
44615: EMPTY
44616: LIST
44617: LIST
44618: PUSH
44619: LD_INT 4
44621: NEG
44622: PUSH
44623: LD_INT 3
44625: NEG
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 4
44633: NEG
44634: PUSH
44635: LD_INT 4
44637: NEG
44638: PUSH
44639: EMPTY
44640: LIST
44641: LIST
44642: PUSH
44643: LD_INT 2
44645: NEG
44646: PUSH
44647: LD_INT 4
44649: NEG
44650: PUSH
44651: EMPTY
44652: LIST
44653: LIST
44654: PUSH
44655: LD_INT 4
44657: NEG
44658: PUSH
44659: LD_INT 2
44661: NEG
44662: PUSH
44663: EMPTY
44664: LIST
44665: LIST
44666: PUSH
44667: LD_INT 0
44669: PUSH
44670: LD_INT 4
44672: NEG
44673: PUSH
44674: EMPTY
44675: LIST
44676: LIST
44677: PUSH
44678: LD_INT 0
44680: PUSH
44681: LD_INT 5
44683: NEG
44684: PUSH
44685: EMPTY
44686: LIST
44687: LIST
44688: PUSH
44689: LD_INT 1
44691: PUSH
44692: LD_INT 4
44694: NEG
44695: PUSH
44696: EMPTY
44697: LIST
44698: LIST
44699: PUSH
44700: LD_INT 1
44702: PUSH
44703: LD_INT 3
44705: NEG
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 0
44713: PUSH
44714: LD_INT 3
44716: NEG
44717: PUSH
44718: EMPTY
44719: LIST
44720: LIST
44721: PUSH
44722: LD_INT 1
44724: NEG
44725: PUSH
44726: LD_INT 4
44728: NEG
44729: PUSH
44730: EMPTY
44731: LIST
44732: LIST
44733: PUSH
44734: LD_INT 1
44736: NEG
44737: PUSH
44738: LD_INT 5
44740: NEG
44741: PUSH
44742: EMPTY
44743: LIST
44744: LIST
44745: PUSH
44746: LD_INT 2
44748: PUSH
44749: LD_INT 3
44751: NEG
44752: PUSH
44753: EMPTY
44754: LIST
44755: LIST
44756: PUSH
44757: LD_INT 2
44759: NEG
44760: PUSH
44761: LD_INT 5
44763: NEG
44764: PUSH
44765: EMPTY
44766: LIST
44767: LIST
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: LIST
44773: LIST
44774: LIST
44775: LIST
44776: LIST
44777: LIST
44778: LIST
44779: LIST
44780: LIST
44781: LIST
44782: LIST
44783: LIST
44784: LIST
44785: LIST
44786: LIST
44787: LIST
44788: LIST
44789: LIST
44790: LIST
44791: LIST
44792: LIST
44793: LIST
44794: LIST
44795: LIST
44796: LIST
44797: LIST
44798: LIST
44799: LIST
44800: LIST
44801: LIST
44802: LIST
44803: LIST
44804: LIST
44805: LIST
44806: LIST
44807: LIST
44808: LIST
44809: LIST
44810: LIST
44811: LIST
44812: LIST
44813: LIST
44814: LIST
44815: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44816: LD_ADDR_VAR 0 31
44820: PUSH
44821: LD_INT 0
44823: PUSH
44824: LD_INT 4
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: LD_INT 3
44836: PUSH
44837: EMPTY
44838: LIST
44839: LIST
44840: PUSH
44841: LD_INT 1
44843: PUSH
44844: LD_INT 4
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 1
44853: PUSH
44854: LD_INT 5
44856: PUSH
44857: EMPTY
44858: LIST
44859: LIST
44860: PUSH
44861: LD_INT 0
44863: PUSH
44864: LD_INT 5
44866: PUSH
44867: EMPTY
44868: LIST
44869: LIST
44870: PUSH
44871: LD_INT 1
44873: NEG
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: EMPTY
44879: LIST
44880: LIST
44881: PUSH
44882: LD_INT 1
44884: NEG
44885: PUSH
44886: LD_INT 3
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 2
44895: PUSH
44896: LD_INT 5
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: LD_INT 2
44905: NEG
44906: PUSH
44907: LD_INT 3
44909: PUSH
44910: EMPTY
44911: LIST
44912: LIST
44913: PUSH
44914: LD_INT 3
44916: NEG
44917: PUSH
44918: LD_INT 0
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 3
44927: NEG
44928: PUSH
44929: LD_INT 1
44931: NEG
44932: PUSH
44933: EMPTY
44934: LIST
44935: LIST
44936: PUSH
44937: LD_INT 2
44939: NEG
44940: PUSH
44941: LD_INT 0
44943: PUSH
44944: EMPTY
44945: LIST
44946: LIST
44947: PUSH
44948: LD_INT 2
44950: NEG
44951: PUSH
44952: LD_INT 1
44954: PUSH
44955: EMPTY
44956: LIST
44957: LIST
44958: PUSH
44959: LD_INT 3
44961: NEG
44962: PUSH
44963: LD_INT 1
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 4
44972: NEG
44973: PUSH
44974: LD_INT 0
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 4
44983: NEG
44984: PUSH
44985: LD_INT 1
44987: NEG
44988: PUSH
44989: EMPTY
44990: LIST
44991: LIST
44992: PUSH
44993: LD_INT 4
44995: NEG
44996: PUSH
44997: LD_INT 2
44999: NEG
45000: PUSH
45001: EMPTY
45002: LIST
45003: LIST
45004: PUSH
45005: LD_INT 2
45007: NEG
45008: PUSH
45009: LD_INT 2
45011: PUSH
45012: EMPTY
45013: LIST
45014: LIST
45015: PUSH
45016: LD_INT 4
45018: NEG
45019: PUSH
45020: LD_INT 4
45022: NEG
45023: PUSH
45024: EMPTY
45025: LIST
45026: LIST
45027: PUSH
45028: LD_INT 4
45030: NEG
45031: PUSH
45032: LD_INT 5
45034: NEG
45035: PUSH
45036: EMPTY
45037: LIST
45038: LIST
45039: PUSH
45040: LD_INT 3
45042: NEG
45043: PUSH
45044: LD_INT 4
45046: NEG
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 3
45054: NEG
45055: PUSH
45056: LD_INT 3
45058: NEG
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 4
45066: NEG
45067: PUSH
45068: LD_INT 3
45070: NEG
45071: PUSH
45072: EMPTY
45073: LIST
45074: LIST
45075: PUSH
45076: LD_INT 5
45078: NEG
45079: PUSH
45080: LD_INT 4
45082: NEG
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 5
45090: NEG
45091: PUSH
45092: LD_INT 5
45094: NEG
45095: PUSH
45096: EMPTY
45097: LIST
45098: LIST
45099: PUSH
45100: LD_INT 3
45102: NEG
45103: PUSH
45104: LD_INT 5
45106: NEG
45107: PUSH
45108: EMPTY
45109: LIST
45110: LIST
45111: PUSH
45112: LD_INT 5
45114: NEG
45115: PUSH
45116: LD_INT 3
45118: NEG
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: PUSH
45124: LD_INT 0
45126: PUSH
45127: LD_INT 3
45129: NEG
45130: PUSH
45131: EMPTY
45132: LIST
45133: LIST
45134: PUSH
45135: LD_INT 0
45137: PUSH
45138: LD_INT 4
45140: NEG
45141: PUSH
45142: EMPTY
45143: LIST
45144: LIST
45145: PUSH
45146: LD_INT 1
45148: PUSH
45149: LD_INT 3
45151: NEG
45152: PUSH
45153: EMPTY
45154: LIST
45155: LIST
45156: PUSH
45157: LD_INT 1
45159: PUSH
45160: LD_INT 2
45162: NEG
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 0
45170: PUSH
45171: LD_INT 2
45173: NEG
45174: PUSH
45175: EMPTY
45176: LIST
45177: LIST
45178: PUSH
45179: LD_INT 1
45181: NEG
45182: PUSH
45183: LD_INT 3
45185: NEG
45186: PUSH
45187: EMPTY
45188: LIST
45189: LIST
45190: PUSH
45191: LD_INT 1
45193: NEG
45194: PUSH
45195: LD_INT 4
45197: NEG
45198: PUSH
45199: EMPTY
45200: LIST
45201: LIST
45202: PUSH
45203: LD_INT 2
45205: PUSH
45206: LD_INT 2
45208: NEG
45209: PUSH
45210: EMPTY
45211: LIST
45212: LIST
45213: PUSH
45214: LD_INT 2
45216: NEG
45217: PUSH
45218: LD_INT 4
45220: NEG
45221: PUSH
45222: EMPTY
45223: LIST
45224: LIST
45225: PUSH
45226: LD_INT 4
45228: PUSH
45229: LD_INT 0
45231: PUSH
45232: EMPTY
45233: LIST
45234: LIST
45235: PUSH
45236: LD_INT 4
45238: PUSH
45239: LD_INT 1
45241: NEG
45242: PUSH
45243: EMPTY
45244: LIST
45245: LIST
45246: PUSH
45247: LD_INT 5
45249: PUSH
45250: LD_INT 0
45252: PUSH
45253: EMPTY
45254: LIST
45255: LIST
45256: PUSH
45257: LD_INT 5
45259: PUSH
45260: LD_INT 1
45262: PUSH
45263: EMPTY
45264: LIST
45265: LIST
45266: PUSH
45267: LD_INT 4
45269: PUSH
45270: LD_INT 1
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 3
45279: PUSH
45280: LD_INT 0
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 3
45289: PUSH
45290: LD_INT 1
45292: NEG
45293: PUSH
45294: EMPTY
45295: LIST
45296: LIST
45297: PUSH
45298: LD_INT 3
45300: PUSH
45301: LD_INT 2
45303: NEG
45304: PUSH
45305: EMPTY
45306: LIST
45307: LIST
45308: PUSH
45309: LD_INT 5
45311: PUSH
45312: LD_INT 2
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: LIST
45323: LIST
45324: LIST
45325: LIST
45326: LIST
45327: LIST
45328: LIST
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: LIST
45336: LIST
45337: LIST
45338: LIST
45339: LIST
45340: LIST
45341: LIST
45342: LIST
45343: LIST
45344: LIST
45345: LIST
45346: LIST
45347: LIST
45348: LIST
45349: LIST
45350: LIST
45351: LIST
45352: LIST
45353: LIST
45354: LIST
45355: LIST
45356: LIST
45357: LIST
45358: LIST
45359: LIST
45360: LIST
45361: LIST
45362: LIST
45363: LIST
45364: LIST
45365: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45366: LD_ADDR_VAR 0 32
45370: PUSH
45371: LD_INT 4
45373: NEG
45374: PUSH
45375: LD_INT 0
45377: PUSH
45378: EMPTY
45379: LIST
45380: LIST
45381: PUSH
45382: LD_INT 4
45384: NEG
45385: PUSH
45386: LD_INT 1
45388: NEG
45389: PUSH
45390: EMPTY
45391: LIST
45392: LIST
45393: PUSH
45394: LD_INT 3
45396: NEG
45397: PUSH
45398: LD_INT 0
45400: PUSH
45401: EMPTY
45402: LIST
45403: LIST
45404: PUSH
45405: LD_INT 3
45407: NEG
45408: PUSH
45409: LD_INT 1
45411: PUSH
45412: EMPTY
45413: LIST
45414: LIST
45415: PUSH
45416: LD_INT 4
45418: NEG
45419: PUSH
45420: LD_INT 1
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 5
45429: NEG
45430: PUSH
45431: LD_INT 0
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: LD_INT 5
45440: NEG
45441: PUSH
45442: LD_INT 1
45444: NEG
45445: PUSH
45446: EMPTY
45447: LIST
45448: LIST
45449: PUSH
45450: LD_INT 5
45452: NEG
45453: PUSH
45454: LD_INT 2
45456: NEG
45457: PUSH
45458: EMPTY
45459: LIST
45460: LIST
45461: PUSH
45462: LD_INT 3
45464: NEG
45465: PUSH
45466: LD_INT 2
45468: PUSH
45469: EMPTY
45470: LIST
45471: LIST
45472: PUSH
45473: LD_INT 3
45475: NEG
45476: PUSH
45477: LD_INT 3
45479: NEG
45480: PUSH
45481: EMPTY
45482: LIST
45483: LIST
45484: PUSH
45485: LD_INT 3
45487: NEG
45488: PUSH
45489: LD_INT 4
45491: NEG
45492: PUSH
45493: EMPTY
45494: LIST
45495: LIST
45496: PUSH
45497: LD_INT 2
45499: NEG
45500: PUSH
45501: LD_INT 3
45503: NEG
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: PUSH
45509: LD_INT 2
45511: NEG
45512: PUSH
45513: LD_INT 2
45515: NEG
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 3
45523: NEG
45524: PUSH
45525: LD_INT 2
45527: NEG
45528: PUSH
45529: EMPTY
45530: LIST
45531: LIST
45532: PUSH
45533: LD_INT 4
45535: NEG
45536: PUSH
45537: LD_INT 3
45539: NEG
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: LD_INT 4
45547: NEG
45548: PUSH
45549: LD_INT 4
45551: NEG
45552: PUSH
45553: EMPTY
45554: LIST
45555: LIST
45556: PUSH
45557: LD_INT 2
45559: NEG
45560: PUSH
45561: LD_INT 4
45563: NEG
45564: PUSH
45565: EMPTY
45566: LIST
45567: LIST
45568: PUSH
45569: LD_INT 4
45571: NEG
45572: PUSH
45573: LD_INT 2
45575: NEG
45576: PUSH
45577: EMPTY
45578: LIST
45579: LIST
45580: PUSH
45581: LD_INT 0
45583: PUSH
45584: LD_INT 4
45586: NEG
45587: PUSH
45588: EMPTY
45589: LIST
45590: LIST
45591: PUSH
45592: LD_INT 0
45594: PUSH
45595: LD_INT 5
45597: NEG
45598: PUSH
45599: EMPTY
45600: LIST
45601: LIST
45602: PUSH
45603: LD_INT 1
45605: PUSH
45606: LD_INT 4
45608: NEG
45609: PUSH
45610: EMPTY
45611: LIST
45612: LIST
45613: PUSH
45614: LD_INT 1
45616: PUSH
45617: LD_INT 3
45619: NEG
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 0
45627: PUSH
45628: LD_INT 3
45630: NEG
45631: PUSH
45632: EMPTY
45633: LIST
45634: LIST
45635: PUSH
45636: LD_INT 1
45638: NEG
45639: PUSH
45640: LD_INT 4
45642: NEG
45643: PUSH
45644: EMPTY
45645: LIST
45646: LIST
45647: PUSH
45648: LD_INT 1
45650: NEG
45651: PUSH
45652: LD_INT 5
45654: NEG
45655: PUSH
45656: EMPTY
45657: LIST
45658: LIST
45659: PUSH
45660: LD_INT 2
45662: PUSH
45663: LD_INT 3
45665: NEG
45666: PUSH
45667: EMPTY
45668: LIST
45669: LIST
45670: PUSH
45671: LD_INT 2
45673: NEG
45674: PUSH
45675: LD_INT 5
45677: NEG
45678: PUSH
45679: EMPTY
45680: LIST
45681: LIST
45682: PUSH
45683: LD_INT 3
45685: PUSH
45686: LD_INT 0
45688: PUSH
45689: EMPTY
45690: LIST
45691: LIST
45692: PUSH
45693: LD_INT 3
45695: PUSH
45696: LD_INT 1
45698: NEG
45699: PUSH
45700: EMPTY
45701: LIST
45702: LIST
45703: PUSH
45704: LD_INT 4
45706: PUSH
45707: LD_INT 0
45709: PUSH
45710: EMPTY
45711: LIST
45712: LIST
45713: PUSH
45714: LD_INT 4
45716: PUSH
45717: LD_INT 1
45719: PUSH
45720: EMPTY
45721: LIST
45722: LIST
45723: PUSH
45724: LD_INT 3
45726: PUSH
45727: LD_INT 1
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 2
45736: PUSH
45737: LD_INT 0
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 2
45746: PUSH
45747: LD_INT 1
45749: NEG
45750: PUSH
45751: EMPTY
45752: LIST
45753: LIST
45754: PUSH
45755: LD_INT 2
45757: PUSH
45758: LD_INT 2
45760: NEG
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: PUSH
45766: LD_INT 4
45768: PUSH
45769: LD_INT 2
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 4
45778: PUSH
45779: LD_INT 4
45781: PUSH
45782: EMPTY
45783: LIST
45784: LIST
45785: PUSH
45786: LD_INT 4
45788: PUSH
45789: LD_INT 3
45791: PUSH
45792: EMPTY
45793: LIST
45794: LIST
45795: PUSH
45796: LD_INT 5
45798: PUSH
45799: LD_INT 4
45801: PUSH
45802: EMPTY
45803: LIST
45804: LIST
45805: PUSH
45806: LD_INT 5
45808: PUSH
45809: LD_INT 5
45811: PUSH
45812: EMPTY
45813: LIST
45814: LIST
45815: PUSH
45816: LD_INT 4
45818: PUSH
45819: LD_INT 5
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 3
45828: PUSH
45829: LD_INT 4
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: PUSH
45836: LD_INT 3
45838: PUSH
45839: LD_INT 3
45841: PUSH
45842: EMPTY
45843: LIST
45844: LIST
45845: PUSH
45846: LD_INT 5
45848: PUSH
45849: LD_INT 3
45851: PUSH
45852: EMPTY
45853: LIST
45854: LIST
45855: PUSH
45856: LD_INT 3
45858: PUSH
45859: LD_INT 5
45861: PUSH
45862: EMPTY
45863: LIST
45864: LIST
45865: PUSH
45866: EMPTY
45867: LIST
45868: LIST
45869: LIST
45870: LIST
45871: LIST
45872: LIST
45873: LIST
45874: LIST
45875: LIST
45876: LIST
45877: LIST
45878: LIST
45879: LIST
45880: LIST
45881: LIST
45882: LIST
45883: LIST
45884: LIST
45885: LIST
45886: LIST
45887: LIST
45888: LIST
45889: LIST
45890: LIST
45891: LIST
45892: LIST
45893: LIST
45894: LIST
45895: LIST
45896: LIST
45897: LIST
45898: LIST
45899: LIST
45900: LIST
45901: LIST
45902: LIST
45903: LIST
45904: LIST
45905: LIST
45906: LIST
45907: LIST
45908: LIST
45909: LIST
45910: LIST
45911: LIST
45912: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
45913: LD_ADDR_VAR 0 33
45917: PUSH
45918: LD_INT 4
45920: NEG
45921: PUSH
45922: LD_INT 4
45924: NEG
45925: PUSH
45926: EMPTY
45927: LIST
45928: LIST
45929: PUSH
45930: LD_INT 4
45932: NEG
45933: PUSH
45934: LD_INT 5
45936: NEG
45937: PUSH
45938: EMPTY
45939: LIST
45940: LIST
45941: PUSH
45942: LD_INT 3
45944: NEG
45945: PUSH
45946: LD_INT 4
45948: NEG
45949: PUSH
45950: EMPTY
45951: LIST
45952: LIST
45953: PUSH
45954: LD_INT 3
45956: NEG
45957: PUSH
45958: LD_INT 3
45960: NEG
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 4
45968: NEG
45969: PUSH
45970: LD_INT 3
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 5
45980: NEG
45981: PUSH
45982: LD_INT 4
45984: NEG
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: PUSH
45990: LD_INT 5
45992: NEG
45993: PUSH
45994: LD_INT 5
45996: NEG
45997: PUSH
45998: EMPTY
45999: LIST
46000: LIST
46001: PUSH
46002: LD_INT 3
46004: NEG
46005: PUSH
46006: LD_INT 5
46008: NEG
46009: PUSH
46010: EMPTY
46011: LIST
46012: LIST
46013: PUSH
46014: LD_INT 5
46016: NEG
46017: PUSH
46018: LD_INT 3
46020: NEG
46021: PUSH
46022: EMPTY
46023: LIST
46024: LIST
46025: PUSH
46026: LD_INT 0
46028: PUSH
46029: LD_INT 3
46031: NEG
46032: PUSH
46033: EMPTY
46034: LIST
46035: LIST
46036: PUSH
46037: LD_INT 0
46039: PUSH
46040: LD_INT 4
46042: NEG
46043: PUSH
46044: EMPTY
46045: LIST
46046: LIST
46047: PUSH
46048: LD_INT 1
46050: PUSH
46051: LD_INT 3
46053: NEG
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 1
46061: PUSH
46062: LD_INT 2
46064: NEG
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 0
46072: PUSH
46073: LD_INT 2
46075: NEG
46076: PUSH
46077: EMPTY
46078: LIST
46079: LIST
46080: PUSH
46081: LD_INT 1
46083: NEG
46084: PUSH
46085: LD_INT 3
46087: NEG
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: PUSH
46093: LD_INT 1
46095: NEG
46096: PUSH
46097: LD_INT 4
46099: NEG
46100: PUSH
46101: EMPTY
46102: LIST
46103: LIST
46104: PUSH
46105: LD_INT 2
46107: PUSH
46108: LD_INT 2
46110: NEG
46111: PUSH
46112: EMPTY
46113: LIST
46114: LIST
46115: PUSH
46116: LD_INT 2
46118: NEG
46119: PUSH
46120: LD_INT 4
46122: NEG
46123: PUSH
46124: EMPTY
46125: LIST
46126: LIST
46127: PUSH
46128: LD_INT 4
46130: PUSH
46131: LD_INT 0
46133: PUSH
46134: EMPTY
46135: LIST
46136: LIST
46137: PUSH
46138: LD_INT 4
46140: PUSH
46141: LD_INT 1
46143: NEG
46144: PUSH
46145: EMPTY
46146: LIST
46147: LIST
46148: PUSH
46149: LD_INT 5
46151: PUSH
46152: LD_INT 0
46154: PUSH
46155: EMPTY
46156: LIST
46157: LIST
46158: PUSH
46159: LD_INT 5
46161: PUSH
46162: LD_INT 1
46164: PUSH
46165: EMPTY
46166: LIST
46167: LIST
46168: PUSH
46169: LD_INT 4
46171: PUSH
46172: LD_INT 1
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 3
46181: PUSH
46182: LD_INT 0
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 3
46191: PUSH
46192: LD_INT 1
46194: NEG
46195: PUSH
46196: EMPTY
46197: LIST
46198: LIST
46199: PUSH
46200: LD_INT 3
46202: PUSH
46203: LD_INT 2
46205: NEG
46206: PUSH
46207: EMPTY
46208: LIST
46209: LIST
46210: PUSH
46211: LD_INT 5
46213: PUSH
46214: LD_INT 2
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: LD_INT 3
46223: PUSH
46224: LD_INT 3
46226: PUSH
46227: EMPTY
46228: LIST
46229: LIST
46230: PUSH
46231: LD_INT 3
46233: PUSH
46234: LD_INT 2
46236: PUSH
46237: EMPTY
46238: LIST
46239: LIST
46240: PUSH
46241: LD_INT 4
46243: PUSH
46244: LD_INT 3
46246: PUSH
46247: EMPTY
46248: LIST
46249: LIST
46250: PUSH
46251: LD_INT 4
46253: PUSH
46254: LD_INT 4
46256: PUSH
46257: EMPTY
46258: LIST
46259: LIST
46260: PUSH
46261: LD_INT 3
46263: PUSH
46264: LD_INT 4
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 2
46273: PUSH
46274: LD_INT 3
46276: PUSH
46277: EMPTY
46278: LIST
46279: LIST
46280: PUSH
46281: LD_INT 2
46283: PUSH
46284: LD_INT 2
46286: PUSH
46287: EMPTY
46288: LIST
46289: LIST
46290: PUSH
46291: LD_INT 4
46293: PUSH
46294: LD_INT 2
46296: PUSH
46297: EMPTY
46298: LIST
46299: LIST
46300: PUSH
46301: LD_INT 2
46303: PUSH
46304: LD_INT 4
46306: PUSH
46307: EMPTY
46308: LIST
46309: LIST
46310: PUSH
46311: LD_INT 0
46313: PUSH
46314: LD_INT 4
46316: PUSH
46317: EMPTY
46318: LIST
46319: LIST
46320: PUSH
46321: LD_INT 0
46323: PUSH
46324: LD_INT 3
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 1
46333: PUSH
46334: LD_INT 4
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 1
46343: PUSH
46344: LD_INT 5
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 0
46353: PUSH
46354: LD_INT 5
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 1
46363: NEG
46364: PUSH
46365: LD_INT 4
46367: PUSH
46368: EMPTY
46369: LIST
46370: LIST
46371: PUSH
46372: LD_INT 1
46374: NEG
46375: PUSH
46376: LD_INT 3
46378: PUSH
46379: EMPTY
46380: LIST
46381: LIST
46382: PUSH
46383: LD_INT 2
46385: PUSH
46386: LD_INT 5
46388: PUSH
46389: EMPTY
46390: LIST
46391: LIST
46392: PUSH
46393: LD_INT 2
46395: NEG
46396: PUSH
46397: LD_INT 3
46399: PUSH
46400: EMPTY
46401: LIST
46402: LIST
46403: PUSH
46404: EMPTY
46405: LIST
46406: LIST
46407: LIST
46408: LIST
46409: LIST
46410: LIST
46411: LIST
46412: LIST
46413: LIST
46414: LIST
46415: LIST
46416: LIST
46417: LIST
46418: LIST
46419: LIST
46420: LIST
46421: LIST
46422: LIST
46423: LIST
46424: LIST
46425: LIST
46426: LIST
46427: LIST
46428: LIST
46429: LIST
46430: LIST
46431: LIST
46432: LIST
46433: LIST
46434: LIST
46435: LIST
46436: LIST
46437: LIST
46438: LIST
46439: LIST
46440: LIST
46441: LIST
46442: LIST
46443: LIST
46444: LIST
46445: LIST
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46451: LD_ADDR_VAR 0 34
46455: PUSH
46456: LD_INT 0
46458: PUSH
46459: LD_INT 4
46461: NEG
46462: PUSH
46463: EMPTY
46464: LIST
46465: LIST
46466: PUSH
46467: LD_INT 0
46469: PUSH
46470: LD_INT 5
46472: NEG
46473: PUSH
46474: EMPTY
46475: LIST
46476: LIST
46477: PUSH
46478: LD_INT 1
46480: PUSH
46481: LD_INT 4
46483: NEG
46484: PUSH
46485: EMPTY
46486: LIST
46487: LIST
46488: PUSH
46489: LD_INT 1
46491: PUSH
46492: LD_INT 3
46494: NEG
46495: PUSH
46496: EMPTY
46497: LIST
46498: LIST
46499: PUSH
46500: LD_INT 0
46502: PUSH
46503: LD_INT 3
46505: NEG
46506: PUSH
46507: EMPTY
46508: LIST
46509: LIST
46510: PUSH
46511: LD_INT 1
46513: NEG
46514: PUSH
46515: LD_INT 4
46517: NEG
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 1
46525: NEG
46526: PUSH
46527: LD_INT 5
46529: NEG
46530: PUSH
46531: EMPTY
46532: LIST
46533: LIST
46534: PUSH
46535: LD_INT 2
46537: PUSH
46538: LD_INT 3
46540: NEG
46541: PUSH
46542: EMPTY
46543: LIST
46544: LIST
46545: PUSH
46546: LD_INT 2
46548: NEG
46549: PUSH
46550: LD_INT 5
46552: NEG
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PUSH
46558: LD_INT 3
46560: PUSH
46561: LD_INT 0
46563: PUSH
46564: EMPTY
46565: LIST
46566: LIST
46567: PUSH
46568: LD_INT 3
46570: PUSH
46571: LD_INT 1
46573: NEG
46574: PUSH
46575: EMPTY
46576: LIST
46577: LIST
46578: PUSH
46579: LD_INT 4
46581: PUSH
46582: LD_INT 0
46584: PUSH
46585: EMPTY
46586: LIST
46587: LIST
46588: PUSH
46589: LD_INT 4
46591: PUSH
46592: LD_INT 1
46594: PUSH
46595: EMPTY
46596: LIST
46597: LIST
46598: PUSH
46599: LD_INT 3
46601: PUSH
46602: LD_INT 1
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 2
46611: PUSH
46612: LD_INT 0
46614: PUSH
46615: EMPTY
46616: LIST
46617: LIST
46618: PUSH
46619: LD_INT 2
46621: PUSH
46622: LD_INT 1
46624: NEG
46625: PUSH
46626: EMPTY
46627: LIST
46628: LIST
46629: PUSH
46630: LD_INT 2
46632: PUSH
46633: LD_INT 2
46635: NEG
46636: PUSH
46637: EMPTY
46638: LIST
46639: LIST
46640: PUSH
46641: LD_INT 4
46643: PUSH
46644: LD_INT 2
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 4
46653: PUSH
46654: LD_INT 4
46656: PUSH
46657: EMPTY
46658: LIST
46659: LIST
46660: PUSH
46661: LD_INT 4
46663: PUSH
46664: LD_INT 3
46666: PUSH
46667: EMPTY
46668: LIST
46669: LIST
46670: PUSH
46671: LD_INT 5
46673: PUSH
46674: LD_INT 4
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: LD_INT 5
46683: PUSH
46684: LD_INT 5
46686: PUSH
46687: EMPTY
46688: LIST
46689: LIST
46690: PUSH
46691: LD_INT 4
46693: PUSH
46694: LD_INT 5
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 3
46703: PUSH
46704: LD_INT 4
46706: PUSH
46707: EMPTY
46708: LIST
46709: LIST
46710: PUSH
46711: LD_INT 3
46713: PUSH
46714: LD_INT 3
46716: PUSH
46717: EMPTY
46718: LIST
46719: LIST
46720: PUSH
46721: LD_INT 5
46723: PUSH
46724: LD_INT 3
46726: PUSH
46727: EMPTY
46728: LIST
46729: LIST
46730: PUSH
46731: LD_INT 3
46733: PUSH
46734: LD_INT 5
46736: PUSH
46737: EMPTY
46738: LIST
46739: LIST
46740: PUSH
46741: LD_INT 0
46743: PUSH
46744: LD_INT 3
46746: PUSH
46747: EMPTY
46748: LIST
46749: LIST
46750: PUSH
46751: LD_INT 0
46753: PUSH
46754: LD_INT 2
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: LD_INT 1
46763: PUSH
46764: LD_INT 3
46766: PUSH
46767: EMPTY
46768: LIST
46769: LIST
46770: PUSH
46771: LD_INT 1
46773: PUSH
46774: LD_INT 4
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 0
46783: PUSH
46784: LD_INT 4
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 1
46793: NEG
46794: PUSH
46795: LD_INT 3
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: PUSH
46802: LD_INT 1
46804: NEG
46805: PUSH
46806: LD_INT 2
46808: PUSH
46809: EMPTY
46810: LIST
46811: LIST
46812: PUSH
46813: LD_INT 2
46815: PUSH
46816: LD_INT 4
46818: PUSH
46819: EMPTY
46820: LIST
46821: LIST
46822: PUSH
46823: LD_INT 2
46825: NEG
46826: PUSH
46827: LD_INT 2
46829: PUSH
46830: EMPTY
46831: LIST
46832: LIST
46833: PUSH
46834: LD_INT 4
46836: NEG
46837: PUSH
46838: LD_INT 0
46840: PUSH
46841: EMPTY
46842: LIST
46843: LIST
46844: PUSH
46845: LD_INT 4
46847: NEG
46848: PUSH
46849: LD_INT 1
46851: NEG
46852: PUSH
46853: EMPTY
46854: LIST
46855: LIST
46856: PUSH
46857: LD_INT 3
46859: NEG
46860: PUSH
46861: LD_INT 0
46863: PUSH
46864: EMPTY
46865: LIST
46866: LIST
46867: PUSH
46868: LD_INT 3
46870: NEG
46871: PUSH
46872: LD_INT 1
46874: PUSH
46875: EMPTY
46876: LIST
46877: LIST
46878: PUSH
46879: LD_INT 4
46881: NEG
46882: PUSH
46883: LD_INT 1
46885: PUSH
46886: EMPTY
46887: LIST
46888: LIST
46889: PUSH
46890: LD_INT 5
46892: NEG
46893: PUSH
46894: LD_INT 0
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 5
46903: NEG
46904: PUSH
46905: LD_INT 1
46907: NEG
46908: PUSH
46909: EMPTY
46910: LIST
46911: LIST
46912: PUSH
46913: LD_INT 5
46915: NEG
46916: PUSH
46917: LD_INT 2
46919: NEG
46920: PUSH
46921: EMPTY
46922: LIST
46923: LIST
46924: PUSH
46925: LD_INT 3
46927: NEG
46928: PUSH
46929: LD_INT 2
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: PUSH
46936: EMPTY
46937: LIST
46938: LIST
46939: LIST
46940: LIST
46941: LIST
46942: LIST
46943: LIST
46944: LIST
46945: LIST
46946: LIST
46947: LIST
46948: LIST
46949: LIST
46950: LIST
46951: LIST
46952: LIST
46953: LIST
46954: LIST
46955: LIST
46956: LIST
46957: LIST
46958: LIST
46959: LIST
46960: LIST
46961: LIST
46962: LIST
46963: LIST
46964: LIST
46965: LIST
46966: LIST
46967: LIST
46968: LIST
46969: LIST
46970: LIST
46971: LIST
46972: LIST
46973: LIST
46974: LIST
46975: LIST
46976: LIST
46977: LIST
46978: LIST
46979: LIST
46980: LIST
46981: LIST
46982: ST_TO_ADDR
// end ; end ;
46983: GO 46986
46985: POP
// case btype of b_depot , b_warehouse :
46986: LD_VAR 0 1
46990: PUSH
46991: LD_INT 0
46993: DOUBLE
46994: EQUAL
46995: IFTRUE 47005
46997: LD_INT 1
46999: DOUBLE
47000: EQUAL
47001: IFTRUE 47005
47003: GO 47206
47005: POP
// case nation of nation_american :
47006: LD_VAR 0 5
47010: PUSH
47011: LD_INT 1
47013: DOUBLE
47014: EQUAL
47015: IFTRUE 47019
47017: GO 47075
47019: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47020: LD_ADDR_VAR 0 9
47024: PUSH
47025: LD_VAR 0 11
47029: PUSH
47030: LD_VAR 0 12
47034: PUSH
47035: LD_VAR 0 13
47039: PUSH
47040: LD_VAR 0 14
47044: PUSH
47045: LD_VAR 0 15
47049: PUSH
47050: LD_VAR 0 16
47054: PUSH
47055: EMPTY
47056: LIST
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: PUSH
47063: LD_VAR 0 4
47067: PUSH
47068: LD_INT 1
47070: PLUS
47071: ARRAY
47072: ST_TO_ADDR
47073: GO 47204
47075: LD_INT 2
47077: DOUBLE
47078: EQUAL
47079: IFTRUE 47083
47081: GO 47139
47083: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47084: LD_ADDR_VAR 0 9
47088: PUSH
47089: LD_VAR 0 17
47093: PUSH
47094: LD_VAR 0 18
47098: PUSH
47099: LD_VAR 0 19
47103: PUSH
47104: LD_VAR 0 20
47108: PUSH
47109: LD_VAR 0 21
47113: PUSH
47114: LD_VAR 0 22
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: LIST
47123: LIST
47124: LIST
47125: LIST
47126: PUSH
47127: LD_VAR 0 4
47131: PUSH
47132: LD_INT 1
47134: PLUS
47135: ARRAY
47136: ST_TO_ADDR
47137: GO 47204
47139: LD_INT 3
47141: DOUBLE
47142: EQUAL
47143: IFTRUE 47147
47145: GO 47203
47147: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47148: LD_ADDR_VAR 0 9
47152: PUSH
47153: LD_VAR 0 23
47157: PUSH
47158: LD_VAR 0 24
47162: PUSH
47163: LD_VAR 0 25
47167: PUSH
47168: LD_VAR 0 26
47172: PUSH
47173: LD_VAR 0 27
47177: PUSH
47178: LD_VAR 0 28
47182: PUSH
47183: EMPTY
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: PUSH
47191: LD_VAR 0 4
47195: PUSH
47196: LD_INT 1
47198: PLUS
47199: ARRAY
47200: ST_TO_ADDR
47201: GO 47204
47203: POP
47204: GO 47759
47206: LD_INT 2
47208: DOUBLE
47209: EQUAL
47210: IFTRUE 47220
47212: LD_INT 3
47214: DOUBLE
47215: EQUAL
47216: IFTRUE 47220
47218: GO 47276
47220: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47221: LD_ADDR_VAR 0 9
47225: PUSH
47226: LD_VAR 0 29
47230: PUSH
47231: LD_VAR 0 30
47235: PUSH
47236: LD_VAR 0 31
47240: PUSH
47241: LD_VAR 0 32
47245: PUSH
47246: LD_VAR 0 33
47250: PUSH
47251: LD_VAR 0 34
47255: PUSH
47256: EMPTY
47257: LIST
47258: LIST
47259: LIST
47260: LIST
47261: LIST
47262: LIST
47263: PUSH
47264: LD_VAR 0 4
47268: PUSH
47269: LD_INT 1
47271: PLUS
47272: ARRAY
47273: ST_TO_ADDR
47274: GO 47759
47276: LD_INT 16
47278: DOUBLE
47279: EQUAL
47280: IFTRUE 47338
47282: LD_INT 17
47284: DOUBLE
47285: EQUAL
47286: IFTRUE 47338
47288: LD_INT 18
47290: DOUBLE
47291: EQUAL
47292: IFTRUE 47338
47294: LD_INT 19
47296: DOUBLE
47297: EQUAL
47298: IFTRUE 47338
47300: LD_INT 22
47302: DOUBLE
47303: EQUAL
47304: IFTRUE 47338
47306: LD_INT 20
47308: DOUBLE
47309: EQUAL
47310: IFTRUE 47338
47312: LD_INT 21
47314: DOUBLE
47315: EQUAL
47316: IFTRUE 47338
47318: LD_INT 23
47320: DOUBLE
47321: EQUAL
47322: IFTRUE 47338
47324: LD_INT 24
47326: DOUBLE
47327: EQUAL
47328: IFTRUE 47338
47330: LD_INT 25
47332: DOUBLE
47333: EQUAL
47334: IFTRUE 47338
47336: GO 47394
47338: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47339: LD_ADDR_VAR 0 9
47343: PUSH
47344: LD_VAR 0 35
47348: PUSH
47349: LD_VAR 0 36
47353: PUSH
47354: LD_VAR 0 37
47358: PUSH
47359: LD_VAR 0 38
47363: PUSH
47364: LD_VAR 0 39
47368: PUSH
47369: LD_VAR 0 40
47373: PUSH
47374: EMPTY
47375: LIST
47376: LIST
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: PUSH
47382: LD_VAR 0 4
47386: PUSH
47387: LD_INT 1
47389: PLUS
47390: ARRAY
47391: ST_TO_ADDR
47392: GO 47759
47394: LD_INT 6
47396: DOUBLE
47397: EQUAL
47398: IFTRUE 47450
47400: LD_INT 7
47402: DOUBLE
47403: EQUAL
47404: IFTRUE 47450
47406: LD_INT 8
47408: DOUBLE
47409: EQUAL
47410: IFTRUE 47450
47412: LD_INT 13
47414: DOUBLE
47415: EQUAL
47416: IFTRUE 47450
47418: LD_INT 12
47420: DOUBLE
47421: EQUAL
47422: IFTRUE 47450
47424: LD_INT 15
47426: DOUBLE
47427: EQUAL
47428: IFTRUE 47450
47430: LD_INT 11
47432: DOUBLE
47433: EQUAL
47434: IFTRUE 47450
47436: LD_INT 14
47438: DOUBLE
47439: EQUAL
47440: IFTRUE 47450
47442: LD_INT 10
47444: DOUBLE
47445: EQUAL
47446: IFTRUE 47450
47448: GO 47506
47450: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47451: LD_ADDR_VAR 0 9
47455: PUSH
47456: LD_VAR 0 41
47460: PUSH
47461: LD_VAR 0 42
47465: PUSH
47466: LD_VAR 0 43
47470: PUSH
47471: LD_VAR 0 44
47475: PUSH
47476: LD_VAR 0 45
47480: PUSH
47481: LD_VAR 0 46
47485: PUSH
47486: EMPTY
47487: LIST
47488: LIST
47489: LIST
47490: LIST
47491: LIST
47492: LIST
47493: PUSH
47494: LD_VAR 0 4
47498: PUSH
47499: LD_INT 1
47501: PLUS
47502: ARRAY
47503: ST_TO_ADDR
47504: GO 47759
47506: LD_INT 36
47508: DOUBLE
47509: EQUAL
47510: IFTRUE 47514
47512: GO 47570
47514: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47515: LD_ADDR_VAR 0 9
47519: PUSH
47520: LD_VAR 0 47
47524: PUSH
47525: LD_VAR 0 48
47529: PUSH
47530: LD_VAR 0 49
47534: PUSH
47535: LD_VAR 0 50
47539: PUSH
47540: LD_VAR 0 51
47544: PUSH
47545: LD_VAR 0 52
47549: PUSH
47550: EMPTY
47551: LIST
47552: LIST
47553: LIST
47554: LIST
47555: LIST
47556: LIST
47557: PUSH
47558: LD_VAR 0 4
47562: PUSH
47563: LD_INT 1
47565: PLUS
47566: ARRAY
47567: ST_TO_ADDR
47568: GO 47759
47570: LD_INT 4
47572: DOUBLE
47573: EQUAL
47574: IFTRUE 47596
47576: LD_INT 5
47578: DOUBLE
47579: EQUAL
47580: IFTRUE 47596
47582: LD_INT 34
47584: DOUBLE
47585: EQUAL
47586: IFTRUE 47596
47588: LD_INT 37
47590: DOUBLE
47591: EQUAL
47592: IFTRUE 47596
47594: GO 47652
47596: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47597: LD_ADDR_VAR 0 9
47601: PUSH
47602: LD_VAR 0 53
47606: PUSH
47607: LD_VAR 0 54
47611: PUSH
47612: LD_VAR 0 55
47616: PUSH
47617: LD_VAR 0 56
47621: PUSH
47622: LD_VAR 0 57
47626: PUSH
47627: LD_VAR 0 58
47631: PUSH
47632: EMPTY
47633: LIST
47634: LIST
47635: LIST
47636: LIST
47637: LIST
47638: LIST
47639: PUSH
47640: LD_VAR 0 4
47644: PUSH
47645: LD_INT 1
47647: PLUS
47648: ARRAY
47649: ST_TO_ADDR
47650: GO 47759
47652: LD_INT 31
47654: DOUBLE
47655: EQUAL
47656: IFTRUE 47702
47658: LD_INT 32
47660: DOUBLE
47661: EQUAL
47662: IFTRUE 47702
47664: LD_INT 33
47666: DOUBLE
47667: EQUAL
47668: IFTRUE 47702
47670: LD_INT 27
47672: DOUBLE
47673: EQUAL
47674: IFTRUE 47702
47676: LD_INT 26
47678: DOUBLE
47679: EQUAL
47680: IFTRUE 47702
47682: LD_INT 28
47684: DOUBLE
47685: EQUAL
47686: IFTRUE 47702
47688: LD_INT 29
47690: DOUBLE
47691: EQUAL
47692: IFTRUE 47702
47694: LD_INT 30
47696: DOUBLE
47697: EQUAL
47698: IFTRUE 47702
47700: GO 47758
47702: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47703: LD_ADDR_VAR 0 9
47707: PUSH
47708: LD_VAR 0 59
47712: PUSH
47713: LD_VAR 0 60
47717: PUSH
47718: LD_VAR 0 61
47722: PUSH
47723: LD_VAR 0 62
47727: PUSH
47728: LD_VAR 0 63
47732: PUSH
47733: LD_VAR 0 64
47737: PUSH
47738: EMPTY
47739: LIST
47740: LIST
47741: LIST
47742: LIST
47743: LIST
47744: LIST
47745: PUSH
47746: LD_VAR 0 4
47750: PUSH
47751: LD_INT 1
47753: PLUS
47754: ARRAY
47755: ST_TO_ADDR
47756: GO 47759
47758: POP
// temp_list2 = [ ] ;
47759: LD_ADDR_VAR 0 10
47763: PUSH
47764: EMPTY
47765: ST_TO_ADDR
// for i in temp_list do
47766: LD_ADDR_VAR 0 8
47770: PUSH
47771: LD_VAR 0 9
47775: PUSH
47776: FOR_IN
47777: IFFALSE 47829
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47779: LD_ADDR_VAR 0 10
47783: PUSH
47784: LD_VAR 0 10
47788: PUSH
47789: LD_VAR 0 8
47793: PUSH
47794: LD_INT 1
47796: ARRAY
47797: PUSH
47798: LD_VAR 0 2
47802: PLUS
47803: PUSH
47804: LD_VAR 0 8
47808: PUSH
47809: LD_INT 2
47811: ARRAY
47812: PUSH
47813: LD_VAR 0 3
47817: PLUS
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: EMPTY
47824: LIST
47825: ADD
47826: ST_TO_ADDR
47827: GO 47776
47829: POP
47830: POP
// result = temp_list2 ;
47831: LD_ADDR_VAR 0 7
47835: PUSH
47836: LD_VAR 0 10
47840: ST_TO_ADDR
// end ;
47841: LD_VAR 0 7
47845: RET
// export function EnemyInRange ( unit , dist ) ; begin
47846: LD_INT 0
47848: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47849: LD_ADDR_VAR 0 3
47853: PUSH
47854: LD_VAR 0 1
47858: PPUSH
47859: CALL_OW 255
47863: PPUSH
47864: LD_VAR 0 1
47868: PPUSH
47869: CALL_OW 250
47873: PPUSH
47874: LD_VAR 0 1
47878: PPUSH
47879: CALL_OW 251
47883: PPUSH
47884: LD_VAR 0 2
47888: PPUSH
47889: CALL 21950 0 4
47893: PUSH
47894: LD_INT 4
47896: ARRAY
47897: ST_TO_ADDR
// end ;
47898: LD_VAR 0 3
47902: RET
// export function PlayerSeeMe ( unit ) ; begin
47903: LD_INT 0
47905: PPUSH
// result := See ( your_side , unit ) ;
47906: LD_ADDR_VAR 0 2
47910: PUSH
47911: LD_OWVAR 2
47915: PPUSH
47916: LD_VAR 0 1
47920: PPUSH
47921: CALL_OW 292
47925: ST_TO_ADDR
// end ;
47926: LD_VAR 0 2
47930: RET
// export function ReverseDir ( unit ) ; begin
47931: LD_INT 0
47933: PPUSH
// if not unit then
47934: LD_VAR 0 1
47938: NOT
47939: IFFALSE 47943
// exit ;
47941: GO 47989
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
47943: LD_ADDR_VAR 0 2
47947: PUSH
47948: LD_INT 3
47950: PUSH
47951: LD_INT 4
47953: PUSH
47954: LD_INT 5
47956: PUSH
47957: LD_INT 0
47959: PUSH
47960: LD_INT 1
47962: PUSH
47963: LD_INT 2
47965: PUSH
47966: EMPTY
47967: LIST
47968: LIST
47969: LIST
47970: LIST
47971: LIST
47972: LIST
47973: PUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: CALL_OW 254
47983: PUSH
47984: LD_INT 1
47986: PLUS
47987: ARRAY
47988: ST_TO_ADDR
// end ;
47989: LD_VAR 0 2
47993: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
47994: LD_INT 0
47996: PPUSH
47997: PPUSH
47998: PPUSH
47999: PPUSH
48000: PPUSH
// if not hexes then
48001: LD_VAR 0 2
48005: NOT
48006: IFFALSE 48010
// exit ;
48008: GO 48158
// dist := 9999 ;
48010: LD_ADDR_VAR 0 5
48014: PUSH
48015: LD_INT 9999
48017: ST_TO_ADDR
// for i = 1 to hexes do
48018: LD_ADDR_VAR 0 4
48022: PUSH
48023: DOUBLE
48024: LD_INT 1
48026: DEC
48027: ST_TO_ADDR
48028: LD_VAR 0 2
48032: PUSH
48033: FOR_TO
48034: IFFALSE 48146
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48036: LD_VAR 0 1
48040: PPUSH
48041: LD_VAR 0 2
48045: PUSH
48046: LD_VAR 0 4
48050: ARRAY
48051: PUSH
48052: LD_INT 1
48054: ARRAY
48055: PPUSH
48056: LD_VAR 0 2
48060: PUSH
48061: LD_VAR 0 4
48065: ARRAY
48066: PUSH
48067: LD_INT 2
48069: ARRAY
48070: PPUSH
48071: CALL_OW 297
48075: PUSH
48076: LD_VAR 0 5
48080: LESS
48081: IFFALSE 48144
// begin hex := hexes [ i ] ;
48083: LD_ADDR_VAR 0 7
48087: PUSH
48088: LD_VAR 0 2
48092: PUSH
48093: LD_VAR 0 4
48097: ARRAY
48098: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48099: LD_ADDR_VAR 0 5
48103: PUSH
48104: LD_VAR 0 1
48108: PPUSH
48109: LD_VAR 0 2
48113: PUSH
48114: LD_VAR 0 4
48118: ARRAY
48119: PUSH
48120: LD_INT 1
48122: ARRAY
48123: PPUSH
48124: LD_VAR 0 2
48128: PUSH
48129: LD_VAR 0 4
48133: ARRAY
48134: PUSH
48135: LD_INT 2
48137: ARRAY
48138: PPUSH
48139: CALL_OW 297
48143: ST_TO_ADDR
// end ; end ;
48144: GO 48033
48146: POP
48147: POP
// result := hex ;
48148: LD_ADDR_VAR 0 3
48152: PUSH
48153: LD_VAR 0 7
48157: ST_TO_ADDR
// end ;
48158: LD_VAR 0 3
48162: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48163: LD_INT 0
48165: PPUSH
48166: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48167: LD_VAR 0 1
48171: NOT
48172: PUSH
48173: LD_VAR 0 1
48177: PUSH
48178: LD_INT 21
48180: PUSH
48181: LD_INT 2
48183: PUSH
48184: EMPTY
48185: LIST
48186: LIST
48187: PUSH
48188: LD_INT 23
48190: PUSH
48191: LD_INT 2
48193: PUSH
48194: EMPTY
48195: LIST
48196: LIST
48197: PUSH
48198: EMPTY
48199: LIST
48200: LIST
48201: PPUSH
48202: CALL_OW 69
48206: IN
48207: NOT
48208: OR
48209: IFFALSE 48213
// exit ;
48211: GO 48260
// for i = 1 to 3 do
48213: LD_ADDR_VAR 0 3
48217: PUSH
48218: DOUBLE
48219: LD_INT 1
48221: DEC
48222: ST_TO_ADDR
48223: LD_INT 3
48225: PUSH
48226: FOR_TO
48227: IFFALSE 48258
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48229: LD_VAR 0 1
48233: PPUSH
48234: CALL_OW 250
48238: PPUSH
48239: LD_VAR 0 1
48243: PPUSH
48244: CALL_OW 251
48248: PPUSH
48249: LD_INT 1
48251: PPUSH
48252: CALL_OW 453
48256: GO 48226
48258: POP
48259: POP
// end ;
48260: LD_VAR 0 2
48264: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48265: LD_INT 0
48267: PPUSH
48268: PPUSH
48269: PPUSH
48270: PPUSH
48271: PPUSH
48272: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48273: LD_VAR 0 1
48277: NOT
48278: PUSH
48279: LD_VAR 0 2
48283: NOT
48284: OR
48285: PUSH
48286: LD_VAR 0 1
48290: PPUSH
48291: CALL_OW 314
48295: OR
48296: IFFALSE 48300
// exit ;
48298: GO 48741
// x := GetX ( enemy_unit ) ;
48300: LD_ADDR_VAR 0 7
48304: PUSH
48305: LD_VAR 0 2
48309: PPUSH
48310: CALL_OW 250
48314: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48315: LD_ADDR_VAR 0 8
48319: PUSH
48320: LD_VAR 0 2
48324: PPUSH
48325: CALL_OW 251
48329: ST_TO_ADDR
// if not x or not y then
48330: LD_VAR 0 7
48334: NOT
48335: PUSH
48336: LD_VAR 0 8
48340: NOT
48341: OR
48342: IFFALSE 48346
// exit ;
48344: GO 48741
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48346: LD_ADDR_VAR 0 6
48350: PUSH
48351: LD_VAR 0 7
48355: PPUSH
48356: LD_INT 0
48358: PPUSH
48359: LD_INT 4
48361: PPUSH
48362: CALL_OW 272
48366: PUSH
48367: LD_VAR 0 8
48371: PPUSH
48372: LD_INT 0
48374: PPUSH
48375: LD_INT 4
48377: PPUSH
48378: CALL_OW 273
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: PUSH
48387: LD_VAR 0 7
48391: PPUSH
48392: LD_INT 1
48394: PPUSH
48395: LD_INT 4
48397: PPUSH
48398: CALL_OW 272
48402: PUSH
48403: LD_VAR 0 8
48407: PPUSH
48408: LD_INT 1
48410: PPUSH
48411: LD_INT 4
48413: PPUSH
48414: CALL_OW 273
48418: PUSH
48419: EMPTY
48420: LIST
48421: LIST
48422: PUSH
48423: LD_VAR 0 7
48427: PPUSH
48428: LD_INT 2
48430: PPUSH
48431: LD_INT 4
48433: PPUSH
48434: CALL_OW 272
48438: PUSH
48439: LD_VAR 0 8
48443: PPUSH
48444: LD_INT 2
48446: PPUSH
48447: LD_INT 4
48449: PPUSH
48450: CALL_OW 273
48454: PUSH
48455: EMPTY
48456: LIST
48457: LIST
48458: PUSH
48459: LD_VAR 0 7
48463: PPUSH
48464: LD_INT 3
48466: PPUSH
48467: LD_INT 4
48469: PPUSH
48470: CALL_OW 272
48474: PUSH
48475: LD_VAR 0 8
48479: PPUSH
48480: LD_INT 3
48482: PPUSH
48483: LD_INT 4
48485: PPUSH
48486: CALL_OW 273
48490: PUSH
48491: EMPTY
48492: LIST
48493: LIST
48494: PUSH
48495: LD_VAR 0 7
48499: PPUSH
48500: LD_INT 4
48502: PPUSH
48503: LD_INT 4
48505: PPUSH
48506: CALL_OW 272
48510: PUSH
48511: LD_VAR 0 8
48515: PPUSH
48516: LD_INT 4
48518: PPUSH
48519: LD_INT 4
48521: PPUSH
48522: CALL_OW 273
48526: PUSH
48527: EMPTY
48528: LIST
48529: LIST
48530: PUSH
48531: LD_VAR 0 7
48535: PPUSH
48536: LD_INT 5
48538: PPUSH
48539: LD_INT 4
48541: PPUSH
48542: CALL_OW 272
48546: PUSH
48547: LD_VAR 0 8
48551: PPUSH
48552: LD_INT 5
48554: PPUSH
48555: LD_INT 4
48557: PPUSH
48558: CALL_OW 273
48562: PUSH
48563: EMPTY
48564: LIST
48565: LIST
48566: PUSH
48567: EMPTY
48568: LIST
48569: LIST
48570: LIST
48571: LIST
48572: LIST
48573: LIST
48574: ST_TO_ADDR
// for i = tmp downto 1 do
48575: LD_ADDR_VAR 0 4
48579: PUSH
48580: DOUBLE
48581: LD_VAR 0 6
48585: INC
48586: ST_TO_ADDR
48587: LD_INT 1
48589: PUSH
48590: FOR_DOWNTO
48591: IFFALSE 48692
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48593: LD_VAR 0 6
48597: PUSH
48598: LD_VAR 0 4
48602: ARRAY
48603: PUSH
48604: LD_INT 1
48606: ARRAY
48607: PPUSH
48608: LD_VAR 0 6
48612: PUSH
48613: LD_VAR 0 4
48617: ARRAY
48618: PUSH
48619: LD_INT 2
48621: ARRAY
48622: PPUSH
48623: CALL_OW 488
48627: NOT
48628: PUSH
48629: LD_VAR 0 6
48633: PUSH
48634: LD_VAR 0 4
48638: ARRAY
48639: PUSH
48640: LD_INT 1
48642: ARRAY
48643: PPUSH
48644: LD_VAR 0 6
48648: PUSH
48649: LD_VAR 0 4
48653: ARRAY
48654: PUSH
48655: LD_INT 2
48657: ARRAY
48658: PPUSH
48659: CALL_OW 428
48663: PUSH
48664: LD_INT 0
48666: NONEQUAL
48667: OR
48668: IFFALSE 48690
// tmp := Delete ( tmp , i ) ;
48670: LD_ADDR_VAR 0 6
48674: PUSH
48675: LD_VAR 0 6
48679: PPUSH
48680: LD_VAR 0 4
48684: PPUSH
48685: CALL_OW 3
48689: ST_TO_ADDR
48690: GO 48590
48692: POP
48693: POP
// j := GetClosestHex ( unit , tmp ) ;
48694: LD_ADDR_VAR 0 5
48698: PUSH
48699: LD_VAR 0 1
48703: PPUSH
48704: LD_VAR 0 6
48708: PPUSH
48709: CALL 47994 0 2
48713: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48714: LD_VAR 0 1
48718: PPUSH
48719: LD_VAR 0 5
48723: PUSH
48724: LD_INT 1
48726: ARRAY
48727: PPUSH
48728: LD_VAR 0 5
48732: PUSH
48733: LD_INT 2
48735: ARRAY
48736: PPUSH
48737: CALL_OW 111
// end ;
48741: LD_VAR 0 3
48745: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48746: LD_INT 0
48748: PPUSH
48749: PPUSH
48750: PPUSH
// uc_side = 0 ;
48751: LD_ADDR_OWVAR 20
48755: PUSH
48756: LD_INT 0
48758: ST_TO_ADDR
// uc_nation = 0 ;
48759: LD_ADDR_OWVAR 21
48763: PUSH
48764: LD_INT 0
48766: ST_TO_ADDR
// InitHc ;
48767: CALL_OW 19
// InitVc ;
48771: CALL_OW 20
// if mastodonts then
48775: LD_VAR 0 6
48779: IFFALSE 48846
// for i = 1 to mastodonts do
48781: LD_ADDR_VAR 0 11
48785: PUSH
48786: DOUBLE
48787: LD_INT 1
48789: DEC
48790: ST_TO_ADDR
48791: LD_VAR 0 6
48795: PUSH
48796: FOR_TO
48797: IFFALSE 48844
// begin vc_chassis := 31 ;
48799: LD_ADDR_OWVAR 37
48803: PUSH
48804: LD_INT 31
48806: ST_TO_ADDR
// vc_control := control_rider ;
48807: LD_ADDR_OWVAR 38
48811: PUSH
48812: LD_INT 4
48814: ST_TO_ADDR
// animal := CreateVehicle ;
48815: LD_ADDR_VAR 0 12
48819: PUSH
48820: CALL_OW 45
48824: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48825: LD_VAR 0 12
48829: PPUSH
48830: LD_VAR 0 8
48834: PPUSH
48835: LD_INT 0
48837: PPUSH
48838: CALL 55591 0 3
// end ;
48842: GO 48796
48844: POP
48845: POP
// if horses then
48846: LD_VAR 0 5
48850: IFFALSE 48917
// for i = 1 to horses do
48852: LD_ADDR_VAR 0 11
48856: PUSH
48857: DOUBLE
48858: LD_INT 1
48860: DEC
48861: ST_TO_ADDR
48862: LD_VAR 0 5
48866: PUSH
48867: FOR_TO
48868: IFFALSE 48915
// begin hc_class := 21 ;
48870: LD_ADDR_OWVAR 28
48874: PUSH
48875: LD_INT 21
48877: ST_TO_ADDR
// hc_gallery :=  ;
48878: LD_ADDR_OWVAR 33
48882: PUSH
48883: LD_STRING 
48885: ST_TO_ADDR
// animal := CreateHuman ;
48886: LD_ADDR_VAR 0 12
48890: PUSH
48891: CALL_OW 44
48895: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48896: LD_VAR 0 12
48900: PPUSH
48901: LD_VAR 0 8
48905: PPUSH
48906: LD_INT 0
48908: PPUSH
48909: CALL 55591 0 3
// end ;
48913: GO 48867
48915: POP
48916: POP
// if birds then
48917: LD_VAR 0 1
48921: IFFALSE 48988
// for i = 1 to birds do
48923: LD_ADDR_VAR 0 11
48927: PUSH
48928: DOUBLE
48929: LD_INT 1
48931: DEC
48932: ST_TO_ADDR
48933: LD_VAR 0 1
48937: PUSH
48938: FOR_TO
48939: IFFALSE 48986
// begin hc_class = 18 ;
48941: LD_ADDR_OWVAR 28
48945: PUSH
48946: LD_INT 18
48948: ST_TO_ADDR
// hc_gallery =  ;
48949: LD_ADDR_OWVAR 33
48953: PUSH
48954: LD_STRING 
48956: ST_TO_ADDR
// animal := CreateHuman ;
48957: LD_ADDR_VAR 0 12
48961: PUSH
48962: CALL_OW 44
48966: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
48967: LD_VAR 0 12
48971: PPUSH
48972: LD_VAR 0 8
48976: PPUSH
48977: LD_INT 0
48979: PPUSH
48980: CALL 55591 0 3
// end ;
48984: GO 48938
48986: POP
48987: POP
// if tigers then
48988: LD_VAR 0 2
48992: IFFALSE 49076
// for i = 1 to tigers do
48994: LD_ADDR_VAR 0 11
48998: PUSH
48999: DOUBLE
49000: LD_INT 1
49002: DEC
49003: ST_TO_ADDR
49004: LD_VAR 0 2
49008: PUSH
49009: FOR_TO
49010: IFFALSE 49074
// begin hc_class = class_tiger ;
49012: LD_ADDR_OWVAR 28
49016: PUSH
49017: LD_INT 14
49019: ST_TO_ADDR
// hc_gallery =  ;
49020: LD_ADDR_OWVAR 33
49024: PUSH
49025: LD_STRING 
49027: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49028: LD_ADDR_OWVAR 35
49032: PUSH
49033: LD_INT 7
49035: NEG
49036: PPUSH
49037: LD_INT 7
49039: PPUSH
49040: CALL_OW 12
49044: ST_TO_ADDR
// animal := CreateHuman ;
49045: LD_ADDR_VAR 0 12
49049: PUSH
49050: CALL_OW 44
49054: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49055: LD_VAR 0 12
49059: PPUSH
49060: LD_VAR 0 8
49064: PPUSH
49065: LD_INT 0
49067: PPUSH
49068: CALL 55591 0 3
// end ;
49072: GO 49009
49074: POP
49075: POP
// if apemans then
49076: LD_VAR 0 3
49080: IFFALSE 49203
// for i = 1 to apemans do
49082: LD_ADDR_VAR 0 11
49086: PUSH
49087: DOUBLE
49088: LD_INT 1
49090: DEC
49091: ST_TO_ADDR
49092: LD_VAR 0 3
49096: PUSH
49097: FOR_TO
49098: IFFALSE 49201
// begin hc_class = class_apeman ;
49100: LD_ADDR_OWVAR 28
49104: PUSH
49105: LD_INT 12
49107: ST_TO_ADDR
// hc_gallery =  ;
49108: LD_ADDR_OWVAR 33
49112: PUSH
49113: LD_STRING 
49115: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49116: LD_ADDR_OWVAR 35
49120: PUSH
49121: LD_INT 5
49123: NEG
49124: PPUSH
49125: LD_INT 5
49127: PPUSH
49128: CALL_OW 12
49132: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49133: LD_ADDR_OWVAR 31
49137: PUSH
49138: LD_INT 1
49140: PPUSH
49141: LD_INT 3
49143: PPUSH
49144: CALL_OW 12
49148: PUSH
49149: LD_INT 1
49151: PPUSH
49152: LD_INT 3
49154: PPUSH
49155: CALL_OW 12
49159: PUSH
49160: LD_INT 0
49162: PUSH
49163: LD_INT 0
49165: PUSH
49166: EMPTY
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: ST_TO_ADDR
// animal := CreateHuman ;
49172: LD_ADDR_VAR 0 12
49176: PUSH
49177: CALL_OW 44
49181: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49182: LD_VAR 0 12
49186: PPUSH
49187: LD_VAR 0 8
49191: PPUSH
49192: LD_INT 0
49194: PPUSH
49195: CALL 55591 0 3
// end ;
49199: GO 49097
49201: POP
49202: POP
// if enchidnas then
49203: LD_VAR 0 4
49207: IFFALSE 49274
// for i = 1 to enchidnas do
49209: LD_ADDR_VAR 0 11
49213: PUSH
49214: DOUBLE
49215: LD_INT 1
49217: DEC
49218: ST_TO_ADDR
49219: LD_VAR 0 4
49223: PUSH
49224: FOR_TO
49225: IFFALSE 49272
// begin hc_class = 13 ;
49227: LD_ADDR_OWVAR 28
49231: PUSH
49232: LD_INT 13
49234: ST_TO_ADDR
// hc_gallery =  ;
49235: LD_ADDR_OWVAR 33
49239: PUSH
49240: LD_STRING 
49242: ST_TO_ADDR
// animal := CreateHuman ;
49243: LD_ADDR_VAR 0 12
49247: PUSH
49248: CALL_OW 44
49252: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49253: LD_VAR 0 12
49257: PPUSH
49258: LD_VAR 0 8
49262: PPUSH
49263: LD_INT 0
49265: PPUSH
49266: CALL 55591 0 3
// end ;
49270: GO 49224
49272: POP
49273: POP
// if fishes then
49274: LD_VAR 0 7
49278: IFFALSE 49345
// for i = 1 to fishes do
49280: LD_ADDR_VAR 0 11
49284: PUSH
49285: DOUBLE
49286: LD_INT 1
49288: DEC
49289: ST_TO_ADDR
49290: LD_VAR 0 7
49294: PUSH
49295: FOR_TO
49296: IFFALSE 49343
// begin hc_class = 20 ;
49298: LD_ADDR_OWVAR 28
49302: PUSH
49303: LD_INT 20
49305: ST_TO_ADDR
// hc_gallery =  ;
49306: LD_ADDR_OWVAR 33
49310: PUSH
49311: LD_STRING 
49313: ST_TO_ADDR
// animal := CreateHuman ;
49314: LD_ADDR_VAR 0 12
49318: PUSH
49319: CALL_OW 44
49323: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49324: LD_VAR 0 12
49328: PPUSH
49329: LD_VAR 0 9
49333: PPUSH
49334: LD_INT 0
49336: PPUSH
49337: CALL 55591 0 3
// end ;
49341: GO 49295
49343: POP
49344: POP
// end ;
49345: LD_VAR 0 10
49349: RET
// export function WantHeal ( sci , unit ) ; begin
49350: LD_INT 0
49352: PPUSH
// if GetTaskList ( sci ) > 0 then
49353: LD_VAR 0 1
49357: PPUSH
49358: CALL_OW 437
49362: PUSH
49363: LD_INT 0
49365: GREATER
49366: IFFALSE 49436
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49368: LD_VAR 0 1
49372: PPUSH
49373: CALL_OW 437
49377: PUSH
49378: LD_INT 1
49380: ARRAY
49381: PUSH
49382: LD_INT 1
49384: ARRAY
49385: PUSH
49386: LD_STRING l
49388: EQUAL
49389: PUSH
49390: LD_VAR 0 1
49394: PPUSH
49395: CALL_OW 437
49399: PUSH
49400: LD_INT 1
49402: ARRAY
49403: PUSH
49404: LD_INT 4
49406: ARRAY
49407: PUSH
49408: LD_VAR 0 2
49412: EQUAL
49413: AND
49414: IFFALSE 49426
// result := true else
49416: LD_ADDR_VAR 0 3
49420: PUSH
49421: LD_INT 1
49423: ST_TO_ADDR
49424: GO 49434
// result := false ;
49426: LD_ADDR_VAR 0 3
49430: PUSH
49431: LD_INT 0
49433: ST_TO_ADDR
// end else
49434: GO 49444
// result := false ;
49436: LD_ADDR_VAR 0 3
49440: PUSH
49441: LD_INT 0
49443: ST_TO_ADDR
// end ;
49444: LD_VAR 0 3
49448: RET
// export function HealTarget ( sci ) ; begin
49449: LD_INT 0
49451: PPUSH
// if not sci then
49452: LD_VAR 0 1
49456: NOT
49457: IFFALSE 49461
// exit ;
49459: GO 49526
// result := 0 ;
49461: LD_ADDR_VAR 0 2
49465: PUSH
49466: LD_INT 0
49468: ST_TO_ADDR
// if GetTaskList ( sci ) then
49469: LD_VAR 0 1
49473: PPUSH
49474: CALL_OW 437
49478: IFFALSE 49526
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49480: LD_VAR 0 1
49484: PPUSH
49485: CALL_OW 437
49489: PUSH
49490: LD_INT 1
49492: ARRAY
49493: PUSH
49494: LD_INT 1
49496: ARRAY
49497: PUSH
49498: LD_STRING l
49500: EQUAL
49501: IFFALSE 49526
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49503: LD_ADDR_VAR 0 2
49507: PUSH
49508: LD_VAR 0 1
49512: PPUSH
49513: CALL_OW 437
49517: PUSH
49518: LD_INT 1
49520: ARRAY
49521: PUSH
49522: LD_INT 4
49524: ARRAY
49525: ST_TO_ADDR
// end ;
49526: LD_VAR 0 2
49530: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49531: LD_INT 0
49533: PPUSH
49534: PPUSH
49535: PPUSH
49536: PPUSH
49537: PPUSH
49538: PPUSH
49539: PPUSH
49540: PPUSH
49541: PPUSH
49542: PPUSH
49543: PPUSH
49544: PPUSH
49545: PPUSH
49546: PPUSH
49547: PPUSH
49548: PPUSH
49549: PPUSH
49550: PPUSH
49551: PPUSH
49552: PPUSH
49553: PPUSH
49554: PPUSH
49555: PPUSH
49556: PPUSH
49557: PPUSH
49558: PPUSH
49559: PPUSH
49560: PPUSH
49561: PPUSH
49562: PPUSH
49563: PPUSH
49564: PPUSH
49565: PPUSH
49566: PPUSH
// if not list then
49567: LD_VAR 0 1
49571: NOT
49572: IFFALSE 49576
// exit ;
49574: GO 54202
// base := list [ 1 ] ;
49576: LD_ADDR_VAR 0 3
49580: PUSH
49581: LD_VAR 0 1
49585: PUSH
49586: LD_INT 1
49588: ARRAY
49589: ST_TO_ADDR
// group := list [ 2 ] ;
49590: LD_ADDR_VAR 0 4
49594: PUSH
49595: LD_VAR 0 1
49599: PUSH
49600: LD_INT 2
49602: ARRAY
49603: ST_TO_ADDR
// path := list [ 3 ] ;
49604: LD_ADDR_VAR 0 5
49608: PUSH
49609: LD_VAR 0 1
49613: PUSH
49614: LD_INT 3
49616: ARRAY
49617: ST_TO_ADDR
// flags := list [ 4 ] ;
49618: LD_ADDR_VAR 0 6
49622: PUSH
49623: LD_VAR 0 1
49627: PUSH
49628: LD_INT 4
49630: ARRAY
49631: ST_TO_ADDR
// mined := [ ] ;
49632: LD_ADDR_VAR 0 27
49636: PUSH
49637: EMPTY
49638: ST_TO_ADDR
// bombed := [ ] ;
49639: LD_ADDR_VAR 0 28
49643: PUSH
49644: EMPTY
49645: ST_TO_ADDR
// healers := [ ] ;
49646: LD_ADDR_VAR 0 31
49650: PUSH
49651: EMPTY
49652: ST_TO_ADDR
// to_heal := [ ] ;
49653: LD_ADDR_VAR 0 30
49657: PUSH
49658: EMPTY
49659: ST_TO_ADDR
// repairs := [ ] ;
49660: LD_ADDR_VAR 0 33
49664: PUSH
49665: EMPTY
49666: ST_TO_ADDR
// to_repair := [ ] ;
49667: LD_ADDR_VAR 0 32
49671: PUSH
49672: EMPTY
49673: ST_TO_ADDR
// if not group or not path then
49674: LD_VAR 0 4
49678: NOT
49679: PUSH
49680: LD_VAR 0 5
49684: NOT
49685: OR
49686: IFFALSE 49690
// exit ;
49688: GO 54202
// side := GetSide ( group [ 1 ] ) ;
49690: LD_ADDR_VAR 0 35
49694: PUSH
49695: LD_VAR 0 4
49699: PUSH
49700: LD_INT 1
49702: ARRAY
49703: PPUSH
49704: CALL_OW 255
49708: ST_TO_ADDR
// if flags then
49709: LD_VAR 0 6
49713: IFFALSE 49857
// begin f_ignore_area := flags [ 1 ] ;
49715: LD_ADDR_VAR 0 17
49719: PUSH
49720: LD_VAR 0 6
49724: PUSH
49725: LD_INT 1
49727: ARRAY
49728: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49729: LD_ADDR_VAR 0 18
49733: PUSH
49734: LD_VAR 0 6
49738: PUSH
49739: LD_INT 2
49741: ARRAY
49742: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49743: LD_ADDR_VAR 0 19
49747: PUSH
49748: LD_VAR 0 6
49752: PUSH
49753: LD_INT 3
49755: ARRAY
49756: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49757: LD_ADDR_VAR 0 20
49761: PUSH
49762: LD_VAR 0 6
49766: PUSH
49767: LD_INT 4
49769: ARRAY
49770: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49771: LD_ADDR_VAR 0 21
49775: PUSH
49776: LD_VAR 0 6
49780: PUSH
49781: LD_INT 5
49783: ARRAY
49784: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
49785: LD_ADDR_VAR 0 22
49789: PUSH
49790: LD_VAR 0 6
49794: PUSH
49795: LD_INT 6
49797: ARRAY
49798: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
49799: LD_ADDR_VAR 0 23
49803: PUSH
49804: LD_VAR 0 6
49808: PUSH
49809: LD_INT 7
49811: ARRAY
49812: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
49813: LD_ADDR_VAR 0 24
49817: PUSH
49818: LD_VAR 0 6
49822: PUSH
49823: LD_INT 8
49825: ARRAY
49826: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
49827: LD_ADDR_VAR 0 25
49831: PUSH
49832: LD_VAR 0 6
49836: PUSH
49837: LD_INT 9
49839: ARRAY
49840: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
49841: LD_ADDR_VAR 0 26
49845: PUSH
49846: LD_VAR 0 6
49850: PUSH
49851: LD_INT 10
49853: ARRAY
49854: ST_TO_ADDR
// end else
49855: GO 49937
// begin f_ignore_area := false ;
49857: LD_ADDR_VAR 0 17
49861: PUSH
49862: LD_INT 0
49864: ST_TO_ADDR
// f_capture := false ;
49865: LD_ADDR_VAR 0 18
49869: PUSH
49870: LD_INT 0
49872: ST_TO_ADDR
// f_ignore_civ := false ;
49873: LD_ADDR_VAR 0 19
49877: PUSH
49878: LD_INT 0
49880: ST_TO_ADDR
// f_murder := false ;
49881: LD_ADDR_VAR 0 20
49885: PUSH
49886: LD_INT 0
49888: ST_TO_ADDR
// f_mines := false ;
49889: LD_ADDR_VAR 0 21
49893: PUSH
49894: LD_INT 0
49896: ST_TO_ADDR
// f_repair := false ;
49897: LD_ADDR_VAR 0 22
49901: PUSH
49902: LD_INT 0
49904: ST_TO_ADDR
// f_heal := false ;
49905: LD_ADDR_VAR 0 23
49909: PUSH
49910: LD_INT 0
49912: ST_TO_ADDR
// f_spacetime := false ;
49913: LD_ADDR_VAR 0 24
49917: PUSH
49918: LD_INT 0
49920: ST_TO_ADDR
// f_attack_depot := false ;
49921: LD_ADDR_VAR 0 25
49925: PUSH
49926: LD_INT 0
49928: ST_TO_ADDR
// f_crawl := false ;
49929: LD_ADDR_VAR 0 26
49933: PUSH
49934: LD_INT 0
49936: ST_TO_ADDR
// end ; if f_heal then
49937: LD_VAR 0 23
49941: IFFALSE 49968
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
49943: LD_ADDR_VAR 0 31
49947: PUSH
49948: LD_VAR 0 4
49952: PPUSH
49953: LD_INT 25
49955: PUSH
49956: LD_INT 4
49958: PUSH
49959: EMPTY
49960: LIST
49961: LIST
49962: PPUSH
49963: CALL_OW 72
49967: ST_TO_ADDR
// if f_repair then
49968: LD_VAR 0 22
49972: IFFALSE 49999
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
49974: LD_ADDR_VAR 0 33
49978: PUSH
49979: LD_VAR 0 4
49983: PPUSH
49984: LD_INT 25
49986: PUSH
49987: LD_INT 3
49989: PUSH
49990: EMPTY
49991: LIST
49992: LIST
49993: PPUSH
49994: CALL_OW 72
49998: ST_TO_ADDR
// units_path := [ ] ;
49999: LD_ADDR_VAR 0 16
50003: PUSH
50004: EMPTY
50005: ST_TO_ADDR
// for i = 1 to group do
50006: LD_ADDR_VAR 0 7
50010: PUSH
50011: DOUBLE
50012: LD_INT 1
50014: DEC
50015: ST_TO_ADDR
50016: LD_VAR 0 4
50020: PUSH
50021: FOR_TO
50022: IFFALSE 50051
// units_path := Replace ( units_path , i , path ) ;
50024: LD_ADDR_VAR 0 16
50028: PUSH
50029: LD_VAR 0 16
50033: PPUSH
50034: LD_VAR 0 7
50038: PPUSH
50039: LD_VAR 0 5
50043: PPUSH
50044: CALL_OW 1
50048: ST_TO_ADDR
50049: GO 50021
50051: POP
50052: POP
// repeat for i = group downto 1 do
50053: LD_ADDR_VAR 0 7
50057: PUSH
50058: DOUBLE
50059: LD_VAR 0 4
50063: INC
50064: ST_TO_ADDR
50065: LD_INT 1
50067: PUSH
50068: FOR_DOWNTO
50069: IFFALSE 54165
// begin wait ( 5 ) ;
50071: LD_INT 5
50073: PPUSH
50074: CALL_OW 67
// tmp := [ ] ;
50078: LD_ADDR_VAR 0 14
50082: PUSH
50083: EMPTY
50084: ST_TO_ADDR
// attacking := false ;
50085: LD_ADDR_VAR 0 29
50089: PUSH
50090: LD_INT 0
50092: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50093: LD_VAR 0 4
50097: PUSH
50098: LD_VAR 0 7
50102: ARRAY
50103: PPUSH
50104: CALL_OW 301
50108: PUSH
50109: LD_VAR 0 4
50113: PUSH
50114: LD_VAR 0 7
50118: ARRAY
50119: NOT
50120: OR
50121: IFFALSE 50230
// begin if GetType ( group [ i ] ) = unit_human then
50123: LD_VAR 0 4
50127: PUSH
50128: LD_VAR 0 7
50132: ARRAY
50133: PPUSH
50134: CALL_OW 247
50138: PUSH
50139: LD_INT 1
50141: EQUAL
50142: IFFALSE 50188
// begin to_heal := to_heal diff group [ i ] ;
50144: LD_ADDR_VAR 0 30
50148: PUSH
50149: LD_VAR 0 30
50153: PUSH
50154: LD_VAR 0 4
50158: PUSH
50159: LD_VAR 0 7
50163: ARRAY
50164: DIFF
50165: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50166: LD_ADDR_VAR 0 31
50170: PUSH
50171: LD_VAR 0 31
50175: PUSH
50176: LD_VAR 0 4
50180: PUSH
50181: LD_VAR 0 7
50185: ARRAY
50186: DIFF
50187: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50188: LD_ADDR_VAR 0 4
50192: PUSH
50193: LD_VAR 0 4
50197: PPUSH
50198: LD_VAR 0 7
50202: PPUSH
50203: CALL_OW 3
50207: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50208: LD_ADDR_VAR 0 16
50212: PUSH
50213: LD_VAR 0 16
50217: PPUSH
50218: LD_VAR 0 7
50222: PPUSH
50223: CALL_OW 3
50227: ST_TO_ADDR
// continue ;
50228: GO 50068
// end ; if f_repair then
50230: LD_VAR 0 22
50234: IFFALSE 50723
// begin if GetType ( group [ i ] ) = unit_vehicle then
50236: LD_VAR 0 4
50240: PUSH
50241: LD_VAR 0 7
50245: ARRAY
50246: PPUSH
50247: CALL_OW 247
50251: PUSH
50252: LD_INT 2
50254: EQUAL
50255: IFFALSE 50445
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50257: LD_VAR 0 4
50261: PUSH
50262: LD_VAR 0 7
50266: ARRAY
50267: PPUSH
50268: CALL_OW 256
50272: PUSH
50273: LD_INT 700
50275: LESS
50276: PUSH
50277: LD_VAR 0 4
50281: PUSH
50282: LD_VAR 0 7
50286: ARRAY
50287: PUSH
50288: LD_VAR 0 32
50292: IN
50293: NOT
50294: AND
50295: IFFALSE 50319
// to_repair := to_repair union group [ i ] ;
50297: LD_ADDR_VAR 0 32
50301: PUSH
50302: LD_VAR 0 32
50306: PUSH
50307: LD_VAR 0 4
50311: PUSH
50312: LD_VAR 0 7
50316: ARRAY
50317: UNION
50318: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50319: LD_VAR 0 4
50323: PUSH
50324: LD_VAR 0 7
50328: ARRAY
50329: PPUSH
50330: CALL_OW 256
50334: PUSH
50335: LD_INT 1000
50337: EQUAL
50338: PUSH
50339: LD_VAR 0 4
50343: PUSH
50344: LD_VAR 0 7
50348: ARRAY
50349: PUSH
50350: LD_VAR 0 32
50354: IN
50355: AND
50356: IFFALSE 50380
// to_repair := to_repair diff group [ i ] ;
50358: LD_ADDR_VAR 0 32
50362: PUSH
50363: LD_VAR 0 32
50367: PUSH
50368: LD_VAR 0 4
50372: PUSH
50373: LD_VAR 0 7
50377: ARRAY
50378: DIFF
50379: ST_TO_ADDR
// if group [ i ] in to_repair then
50380: LD_VAR 0 4
50384: PUSH
50385: LD_VAR 0 7
50389: ARRAY
50390: PUSH
50391: LD_VAR 0 32
50395: IN
50396: IFFALSE 50443
// begin if not IsInArea ( group [ i ] , f_repair ) then
50398: LD_VAR 0 4
50402: PUSH
50403: LD_VAR 0 7
50407: ARRAY
50408: PPUSH
50409: LD_VAR 0 22
50413: PPUSH
50414: CALL_OW 308
50418: NOT
50419: IFFALSE 50441
// ComMoveToArea ( group [ i ] , f_repair ) ;
50421: LD_VAR 0 4
50425: PUSH
50426: LD_VAR 0 7
50430: ARRAY
50431: PPUSH
50432: LD_VAR 0 22
50436: PPUSH
50437: CALL_OW 113
// continue ;
50441: GO 50068
// end ; end else
50443: GO 50723
// if group [ i ] in repairs then
50445: LD_VAR 0 4
50449: PUSH
50450: LD_VAR 0 7
50454: ARRAY
50455: PUSH
50456: LD_VAR 0 33
50460: IN
50461: IFFALSE 50723
// begin if IsInUnit ( group [ i ] ) then
50463: LD_VAR 0 4
50467: PUSH
50468: LD_VAR 0 7
50472: ARRAY
50473: PPUSH
50474: CALL_OW 310
50478: IFFALSE 50546
// begin z := IsInUnit ( group [ i ] ) ;
50480: LD_ADDR_VAR 0 13
50484: PUSH
50485: LD_VAR 0 4
50489: PUSH
50490: LD_VAR 0 7
50494: ARRAY
50495: PPUSH
50496: CALL_OW 310
50500: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50501: LD_VAR 0 13
50505: PUSH
50506: LD_VAR 0 32
50510: IN
50511: PUSH
50512: LD_VAR 0 13
50516: PPUSH
50517: LD_VAR 0 22
50521: PPUSH
50522: CALL_OW 308
50526: AND
50527: IFFALSE 50544
// ComExitVehicle ( group [ i ] ) ;
50529: LD_VAR 0 4
50533: PUSH
50534: LD_VAR 0 7
50538: ARRAY
50539: PPUSH
50540: CALL_OW 121
// end else
50544: GO 50723
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50546: LD_ADDR_VAR 0 13
50550: PUSH
50551: LD_VAR 0 4
50555: PPUSH
50556: LD_INT 95
50558: PUSH
50559: LD_VAR 0 22
50563: PUSH
50564: EMPTY
50565: LIST
50566: LIST
50567: PUSH
50568: LD_INT 58
50570: PUSH
50571: EMPTY
50572: LIST
50573: PUSH
50574: EMPTY
50575: LIST
50576: LIST
50577: PPUSH
50578: CALL_OW 72
50582: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50583: LD_VAR 0 4
50587: PUSH
50588: LD_VAR 0 7
50592: ARRAY
50593: PPUSH
50594: CALL_OW 314
50598: NOT
50599: IFFALSE 50721
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50601: LD_ADDR_VAR 0 10
50605: PUSH
50606: LD_VAR 0 13
50610: PPUSH
50611: LD_VAR 0 4
50615: PUSH
50616: LD_VAR 0 7
50620: ARRAY
50621: PPUSH
50622: CALL_OW 74
50626: ST_TO_ADDR
// if not x then
50627: LD_VAR 0 10
50631: NOT
50632: IFFALSE 50636
// continue ;
50634: GO 50068
// if GetLives ( x ) < 1000 then
50636: LD_VAR 0 10
50640: PPUSH
50641: CALL_OW 256
50645: PUSH
50646: LD_INT 1000
50648: LESS
50649: IFFALSE 50673
// ComRepairVehicle ( group [ i ] , x ) else
50651: LD_VAR 0 4
50655: PUSH
50656: LD_VAR 0 7
50660: ARRAY
50661: PPUSH
50662: LD_VAR 0 10
50666: PPUSH
50667: CALL_OW 129
50671: GO 50721
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50673: LD_VAR 0 23
50677: PUSH
50678: LD_VAR 0 4
50682: PUSH
50683: LD_VAR 0 7
50687: ARRAY
50688: PPUSH
50689: CALL_OW 256
50693: PUSH
50694: LD_INT 1000
50696: LESS
50697: AND
50698: NOT
50699: IFFALSE 50721
// ComEnterUnit ( group [ i ] , x ) ;
50701: LD_VAR 0 4
50705: PUSH
50706: LD_VAR 0 7
50710: ARRAY
50711: PPUSH
50712: LD_VAR 0 10
50716: PPUSH
50717: CALL_OW 120
// end ; continue ;
50721: GO 50068
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50723: LD_VAR 0 23
50727: PUSH
50728: LD_VAR 0 4
50732: PUSH
50733: LD_VAR 0 7
50737: ARRAY
50738: PPUSH
50739: CALL_OW 247
50743: PUSH
50744: LD_INT 1
50746: EQUAL
50747: AND
50748: IFFALSE 51226
// begin if group [ i ] in healers then
50750: LD_VAR 0 4
50754: PUSH
50755: LD_VAR 0 7
50759: ARRAY
50760: PUSH
50761: LD_VAR 0 31
50765: IN
50766: IFFALSE 51039
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50768: LD_VAR 0 4
50772: PUSH
50773: LD_VAR 0 7
50777: ARRAY
50778: PPUSH
50779: LD_VAR 0 23
50783: PPUSH
50784: CALL_OW 308
50788: NOT
50789: PUSH
50790: LD_VAR 0 4
50794: PUSH
50795: LD_VAR 0 7
50799: ARRAY
50800: PPUSH
50801: CALL_OW 314
50805: NOT
50806: AND
50807: IFFALSE 50831
// ComMoveToArea ( group [ i ] , f_heal ) else
50809: LD_VAR 0 4
50813: PUSH
50814: LD_VAR 0 7
50818: ARRAY
50819: PPUSH
50820: LD_VAR 0 23
50824: PPUSH
50825: CALL_OW 113
50829: GO 51037
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
50831: LD_VAR 0 4
50835: PUSH
50836: LD_VAR 0 7
50840: ARRAY
50841: PPUSH
50842: CALL 49449 0 1
50846: PPUSH
50847: CALL_OW 256
50851: PUSH
50852: LD_INT 1000
50854: EQUAL
50855: IFFALSE 50874
// ComStop ( group [ i ] ) else
50857: LD_VAR 0 4
50861: PUSH
50862: LD_VAR 0 7
50866: ARRAY
50867: PPUSH
50868: CALL_OW 141
50872: GO 51037
// if not HasTask ( group [ i ] ) and to_heal then
50874: LD_VAR 0 4
50878: PUSH
50879: LD_VAR 0 7
50883: ARRAY
50884: PPUSH
50885: CALL_OW 314
50889: NOT
50890: PUSH
50891: LD_VAR 0 30
50895: AND
50896: IFFALSE 51037
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
50898: LD_ADDR_VAR 0 13
50902: PUSH
50903: LD_VAR 0 30
50907: PPUSH
50908: LD_INT 3
50910: PUSH
50911: LD_INT 54
50913: PUSH
50914: EMPTY
50915: LIST
50916: PUSH
50917: EMPTY
50918: LIST
50919: LIST
50920: PPUSH
50921: CALL_OW 72
50925: PPUSH
50926: LD_VAR 0 4
50930: PUSH
50931: LD_VAR 0 7
50935: ARRAY
50936: PPUSH
50937: CALL_OW 74
50941: ST_TO_ADDR
// if z then
50942: LD_VAR 0 13
50946: IFFALSE 51037
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
50948: LD_INT 91
50950: PUSH
50951: LD_VAR 0 13
50955: PUSH
50956: LD_INT 10
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: LIST
50963: PUSH
50964: LD_INT 81
50966: PUSH
50967: LD_VAR 0 13
50971: PPUSH
50972: CALL_OW 255
50976: PUSH
50977: EMPTY
50978: LIST
50979: LIST
50980: PUSH
50981: EMPTY
50982: LIST
50983: LIST
50984: PPUSH
50985: CALL_OW 69
50989: PUSH
50990: LD_INT 0
50992: EQUAL
50993: IFFALSE 51017
// ComHeal ( group [ i ] , z ) else
50995: LD_VAR 0 4
50999: PUSH
51000: LD_VAR 0 7
51004: ARRAY
51005: PPUSH
51006: LD_VAR 0 13
51010: PPUSH
51011: CALL_OW 128
51015: GO 51037
// ComMoveToArea ( group [ i ] , f_heal ) ;
51017: LD_VAR 0 4
51021: PUSH
51022: LD_VAR 0 7
51026: ARRAY
51027: PPUSH
51028: LD_VAR 0 23
51032: PPUSH
51033: CALL_OW 113
// end ; continue ;
51037: GO 50068
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51039: LD_VAR 0 4
51043: PUSH
51044: LD_VAR 0 7
51048: ARRAY
51049: PPUSH
51050: CALL_OW 256
51054: PUSH
51055: LD_INT 700
51057: LESS
51058: PUSH
51059: LD_VAR 0 4
51063: PUSH
51064: LD_VAR 0 7
51068: ARRAY
51069: PUSH
51070: LD_VAR 0 30
51074: IN
51075: NOT
51076: AND
51077: IFFALSE 51101
// to_heal := to_heal union group [ i ] ;
51079: LD_ADDR_VAR 0 30
51083: PUSH
51084: LD_VAR 0 30
51088: PUSH
51089: LD_VAR 0 4
51093: PUSH
51094: LD_VAR 0 7
51098: ARRAY
51099: UNION
51100: ST_TO_ADDR
// if group [ i ] in to_heal then
51101: LD_VAR 0 4
51105: PUSH
51106: LD_VAR 0 7
51110: ARRAY
51111: PUSH
51112: LD_VAR 0 30
51116: IN
51117: IFFALSE 51226
// begin if GetLives ( group [ i ] ) = 1000 then
51119: LD_VAR 0 4
51123: PUSH
51124: LD_VAR 0 7
51128: ARRAY
51129: PPUSH
51130: CALL_OW 256
51134: PUSH
51135: LD_INT 1000
51137: EQUAL
51138: IFFALSE 51164
// to_heal := to_heal diff group [ i ] else
51140: LD_ADDR_VAR 0 30
51144: PUSH
51145: LD_VAR 0 30
51149: PUSH
51150: LD_VAR 0 4
51154: PUSH
51155: LD_VAR 0 7
51159: ARRAY
51160: DIFF
51161: ST_TO_ADDR
51162: GO 51226
// begin if not IsInArea ( group [ i ] , to_heal ) then
51164: LD_VAR 0 4
51168: PUSH
51169: LD_VAR 0 7
51173: ARRAY
51174: PPUSH
51175: LD_VAR 0 30
51179: PPUSH
51180: CALL_OW 308
51184: NOT
51185: IFFALSE 51209
// ComMoveToArea ( group [ i ] , f_heal ) else
51187: LD_VAR 0 4
51191: PUSH
51192: LD_VAR 0 7
51196: ARRAY
51197: PPUSH
51198: LD_VAR 0 23
51202: PPUSH
51203: CALL_OW 113
51207: GO 51224
// ComHold ( group [ i ] ) ;
51209: LD_VAR 0 4
51213: PUSH
51214: LD_VAR 0 7
51218: ARRAY
51219: PPUSH
51220: CALL_OW 140
// continue ;
51224: GO 50068
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51226: LD_VAR 0 4
51230: PUSH
51231: LD_VAR 0 7
51235: ARRAY
51236: PPUSH
51237: LD_INT 10
51239: PPUSH
51240: CALL 47846 0 2
51244: NOT
51245: PUSH
51246: LD_VAR 0 16
51250: PUSH
51251: LD_VAR 0 7
51255: ARRAY
51256: PUSH
51257: EMPTY
51258: EQUAL
51259: NOT
51260: AND
51261: IFFALSE 51527
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51263: LD_VAR 0 4
51267: PUSH
51268: LD_VAR 0 7
51272: ARRAY
51273: PPUSH
51274: CALL_OW 262
51278: PUSH
51279: LD_INT 1
51281: PUSH
51282: LD_INT 2
51284: PUSH
51285: EMPTY
51286: LIST
51287: LIST
51288: IN
51289: IFFALSE 51330
// if GetFuel ( group [ i ] ) < 10 then
51291: LD_VAR 0 4
51295: PUSH
51296: LD_VAR 0 7
51300: ARRAY
51301: PPUSH
51302: CALL_OW 261
51306: PUSH
51307: LD_INT 10
51309: LESS
51310: IFFALSE 51330
// SetFuel ( group [ i ] , 12 ) ;
51312: LD_VAR 0 4
51316: PUSH
51317: LD_VAR 0 7
51321: ARRAY
51322: PPUSH
51323: LD_INT 12
51325: PPUSH
51326: CALL_OW 240
// if units_path [ i ] then
51330: LD_VAR 0 16
51334: PUSH
51335: LD_VAR 0 7
51339: ARRAY
51340: IFFALSE 51525
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51342: LD_VAR 0 4
51346: PUSH
51347: LD_VAR 0 7
51351: ARRAY
51352: PPUSH
51353: LD_VAR 0 16
51357: PUSH
51358: LD_VAR 0 7
51362: ARRAY
51363: PUSH
51364: LD_INT 1
51366: ARRAY
51367: PUSH
51368: LD_INT 1
51370: ARRAY
51371: PPUSH
51372: LD_VAR 0 16
51376: PUSH
51377: LD_VAR 0 7
51381: ARRAY
51382: PUSH
51383: LD_INT 1
51385: ARRAY
51386: PUSH
51387: LD_INT 2
51389: ARRAY
51390: PPUSH
51391: CALL_OW 297
51395: PUSH
51396: LD_INT 6
51398: GREATER
51399: IFFALSE 51474
// begin if not HasTask ( group [ i ] ) then
51401: LD_VAR 0 4
51405: PUSH
51406: LD_VAR 0 7
51410: ARRAY
51411: PPUSH
51412: CALL_OW 314
51416: NOT
51417: IFFALSE 51472
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51419: LD_VAR 0 4
51423: PUSH
51424: LD_VAR 0 7
51428: ARRAY
51429: PPUSH
51430: LD_VAR 0 16
51434: PUSH
51435: LD_VAR 0 7
51439: ARRAY
51440: PUSH
51441: LD_INT 1
51443: ARRAY
51444: PUSH
51445: LD_INT 1
51447: ARRAY
51448: PPUSH
51449: LD_VAR 0 16
51453: PUSH
51454: LD_VAR 0 7
51458: ARRAY
51459: PUSH
51460: LD_INT 1
51462: ARRAY
51463: PUSH
51464: LD_INT 2
51466: ARRAY
51467: PPUSH
51468: CALL_OW 114
// end else
51472: GO 51525
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51474: LD_ADDR_VAR 0 15
51478: PUSH
51479: LD_VAR 0 16
51483: PUSH
51484: LD_VAR 0 7
51488: ARRAY
51489: PPUSH
51490: LD_INT 1
51492: PPUSH
51493: CALL_OW 3
51497: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51498: LD_ADDR_VAR 0 16
51502: PUSH
51503: LD_VAR 0 16
51507: PPUSH
51508: LD_VAR 0 7
51512: PPUSH
51513: LD_VAR 0 15
51517: PPUSH
51518: CALL_OW 1
51522: ST_TO_ADDR
// continue ;
51523: GO 50068
// end ; end ; end else
51525: GO 54163
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51527: LD_ADDR_VAR 0 14
51531: PUSH
51532: LD_INT 81
51534: PUSH
51535: LD_VAR 0 4
51539: PUSH
51540: LD_VAR 0 7
51544: ARRAY
51545: PPUSH
51546: CALL_OW 255
51550: PUSH
51551: EMPTY
51552: LIST
51553: LIST
51554: PPUSH
51555: CALL_OW 69
51559: ST_TO_ADDR
// if not tmp then
51560: LD_VAR 0 14
51564: NOT
51565: IFFALSE 51569
// continue ;
51567: GO 50068
// if f_ignore_area then
51569: LD_VAR 0 17
51573: IFFALSE 51661
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51575: LD_ADDR_VAR 0 15
51579: PUSH
51580: LD_VAR 0 14
51584: PPUSH
51585: LD_INT 3
51587: PUSH
51588: LD_INT 92
51590: PUSH
51591: LD_VAR 0 17
51595: PUSH
51596: LD_INT 1
51598: ARRAY
51599: PUSH
51600: LD_VAR 0 17
51604: PUSH
51605: LD_INT 2
51607: ARRAY
51608: PUSH
51609: LD_VAR 0 17
51613: PUSH
51614: LD_INT 3
51616: ARRAY
51617: PUSH
51618: EMPTY
51619: LIST
51620: LIST
51621: LIST
51622: LIST
51623: PUSH
51624: EMPTY
51625: LIST
51626: LIST
51627: PPUSH
51628: CALL_OW 72
51632: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51633: LD_VAR 0 14
51637: PUSH
51638: LD_VAR 0 15
51642: DIFF
51643: IFFALSE 51661
// tmp := tmp diff tmp2 ;
51645: LD_ADDR_VAR 0 14
51649: PUSH
51650: LD_VAR 0 14
51654: PUSH
51655: LD_VAR 0 15
51659: DIFF
51660: ST_TO_ADDR
// end ; if not f_murder then
51661: LD_VAR 0 20
51665: NOT
51666: IFFALSE 51724
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51668: LD_ADDR_VAR 0 15
51672: PUSH
51673: LD_VAR 0 14
51677: PPUSH
51678: LD_INT 3
51680: PUSH
51681: LD_INT 50
51683: PUSH
51684: EMPTY
51685: LIST
51686: PUSH
51687: EMPTY
51688: LIST
51689: LIST
51690: PPUSH
51691: CALL_OW 72
51695: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51696: LD_VAR 0 14
51700: PUSH
51701: LD_VAR 0 15
51705: DIFF
51706: IFFALSE 51724
// tmp := tmp diff tmp2 ;
51708: LD_ADDR_VAR 0 14
51712: PUSH
51713: LD_VAR 0 14
51717: PUSH
51718: LD_VAR 0 15
51722: DIFF
51723: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51724: LD_ADDR_VAR 0 14
51728: PUSH
51729: LD_VAR 0 4
51733: PUSH
51734: LD_VAR 0 7
51738: ARRAY
51739: PPUSH
51740: LD_VAR 0 14
51744: PPUSH
51745: LD_INT 1
51747: PPUSH
51748: LD_INT 1
51750: PPUSH
51751: CALL 21489 0 4
51755: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51756: LD_VAR 0 4
51760: PUSH
51761: LD_VAR 0 7
51765: ARRAY
51766: PPUSH
51767: CALL_OW 257
51771: PUSH
51772: LD_INT 1
51774: EQUAL
51775: IFFALSE 52223
// begin if WantPlant ( group [ i ] ) then
51777: LD_VAR 0 4
51781: PUSH
51782: LD_VAR 0 7
51786: ARRAY
51787: PPUSH
51788: CALL 20990 0 1
51792: IFFALSE 51796
// continue ;
51794: GO 50068
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
51796: LD_VAR 0 18
51800: PUSH
51801: LD_VAR 0 4
51805: PUSH
51806: LD_VAR 0 7
51810: ARRAY
51811: PPUSH
51812: CALL_OW 310
51816: NOT
51817: AND
51818: PUSH
51819: LD_VAR 0 14
51823: PUSH
51824: LD_INT 1
51826: ARRAY
51827: PUSH
51828: LD_VAR 0 14
51832: PPUSH
51833: LD_INT 21
51835: PUSH
51836: LD_INT 2
51838: PUSH
51839: EMPTY
51840: LIST
51841: LIST
51842: PUSH
51843: LD_INT 58
51845: PUSH
51846: EMPTY
51847: LIST
51848: PUSH
51849: EMPTY
51850: LIST
51851: LIST
51852: PPUSH
51853: CALL_OW 72
51857: IN
51858: AND
51859: IFFALSE 51895
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
51861: LD_VAR 0 4
51865: PUSH
51866: LD_VAR 0 7
51870: ARRAY
51871: PPUSH
51872: LD_VAR 0 14
51876: PUSH
51877: LD_INT 1
51879: ARRAY
51880: PPUSH
51881: CALL_OW 120
// attacking := true ;
51885: LD_ADDR_VAR 0 29
51889: PUSH
51890: LD_INT 1
51892: ST_TO_ADDR
// continue ;
51893: GO 50068
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
51895: LD_VAR 0 26
51899: PUSH
51900: LD_VAR 0 4
51904: PUSH
51905: LD_VAR 0 7
51909: ARRAY
51910: PPUSH
51911: CALL_OW 257
51915: PUSH
51916: LD_INT 1
51918: EQUAL
51919: AND
51920: PUSH
51921: LD_VAR 0 4
51925: PUSH
51926: LD_VAR 0 7
51930: ARRAY
51931: PPUSH
51932: CALL_OW 256
51936: PUSH
51937: LD_INT 800
51939: LESS
51940: AND
51941: PUSH
51942: LD_VAR 0 4
51946: PUSH
51947: LD_VAR 0 7
51951: ARRAY
51952: PPUSH
51953: CALL_OW 318
51957: NOT
51958: AND
51959: IFFALSE 51976
// ComCrawl ( group [ i ] ) ;
51961: LD_VAR 0 4
51965: PUSH
51966: LD_VAR 0 7
51970: ARRAY
51971: PPUSH
51972: CALL_OW 137
// if f_mines then
51976: LD_VAR 0 21
51980: IFFALSE 52223
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
51982: LD_VAR 0 14
51986: PUSH
51987: LD_INT 1
51989: ARRAY
51990: PPUSH
51991: CALL_OW 247
51995: PUSH
51996: LD_INT 3
51998: EQUAL
51999: PUSH
52000: LD_VAR 0 14
52004: PUSH
52005: LD_INT 1
52007: ARRAY
52008: PUSH
52009: LD_VAR 0 27
52013: IN
52014: NOT
52015: AND
52016: IFFALSE 52223
// begin x := GetX ( tmp [ 1 ] ) ;
52018: LD_ADDR_VAR 0 10
52022: PUSH
52023: LD_VAR 0 14
52027: PUSH
52028: LD_INT 1
52030: ARRAY
52031: PPUSH
52032: CALL_OW 250
52036: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52037: LD_ADDR_VAR 0 11
52041: PUSH
52042: LD_VAR 0 14
52046: PUSH
52047: LD_INT 1
52049: ARRAY
52050: PPUSH
52051: CALL_OW 251
52055: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52056: LD_ADDR_VAR 0 12
52060: PUSH
52061: LD_VAR 0 4
52065: PUSH
52066: LD_VAR 0 7
52070: ARRAY
52071: PPUSH
52072: CALL 47931 0 1
52076: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52077: LD_VAR 0 4
52081: PUSH
52082: LD_VAR 0 7
52086: ARRAY
52087: PPUSH
52088: LD_VAR 0 10
52092: PPUSH
52093: LD_VAR 0 11
52097: PPUSH
52098: LD_VAR 0 14
52102: PUSH
52103: LD_INT 1
52105: ARRAY
52106: PPUSH
52107: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52111: LD_VAR 0 4
52115: PUSH
52116: LD_VAR 0 7
52120: ARRAY
52121: PPUSH
52122: LD_VAR 0 10
52126: PPUSH
52127: LD_VAR 0 12
52131: PPUSH
52132: LD_INT 7
52134: PPUSH
52135: CALL_OW 272
52139: PPUSH
52140: LD_VAR 0 11
52144: PPUSH
52145: LD_VAR 0 12
52149: PPUSH
52150: LD_INT 7
52152: PPUSH
52153: CALL_OW 273
52157: PPUSH
52158: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52162: LD_VAR 0 4
52166: PUSH
52167: LD_VAR 0 7
52171: ARRAY
52172: PPUSH
52173: LD_INT 71
52175: PPUSH
52176: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52180: LD_ADDR_VAR 0 27
52184: PUSH
52185: LD_VAR 0 27
52189: PPUSH
52190: LD_VAR 0 27
52194: PUSH
52195: LD_INT 1
52197: PLUS
52198: PPUSH
52199: LD_VAR 0 14
52203: PUSH
52204: LD_INT 1
52206: ARRAY
52207: PPUSH
52208: CALL_OW 1
52212: ST_TO_ADDR
// attacking := true ;
52213: LD_ADDR_VAR 0 29
52217: PUSH
52218: LD_INT 1
52220: ST_TO_ADDR
// continue ;
52221: GO 50068
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52223: LD_VAR 0 4
52227: PUSH
52228: LD_VAR 0 7
52232: ARRAY
52233: PPUSH
52234: CALL_OW 257
52238: PUSH
52239: LD_INT 17
52241: EQUAL
52242: PUSH
52243: LD_VAR 0 4
52247: PUSH
52248: LD_VAR 0 7
52252: ARRAY
52253: PPUSH
52254: CALL_OW 110
52258: PUSH
52259: LD_INT 71
52261: EQUAL
52262: NOT
52263: AND
52264: IFFALSE 52410
// begin attacking := false ;
52266: LD_ADDR_VAR 0 29
52270: PUSH
52271: LD_INT 0
52273: ST_TO_ADDR
// k := 5 ;
52274: LD_ADDR_VAR 0 9
52278: PUSH
52279: LD_INT 5
52281: ST_TO_ADDR
// if tmp < k then
52282: LD_VAR 0 14
52286: PUSH
52287: LD_VAR 0 9
52291: LESS
52292: IFFALSE 52304
// k := tmp ;
52294: LD_ADDR_VAR 0 9
52298: PUSH
52299: LD_VAR 0 14
52303: ST_TO_ADDR
// for j = 1 to k do
52304: LD_ADDR_VAR 0 8
52308: PUSH
52309: DOUBLE
52310: LD_INT 1
52312: DEC
52313: ST_TO_ADDR
52314: LD_VAR 0 9
52318: PUSH
52319: FOR_TO
52320: IFFALSE 52408
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52322: LD_VAR 0 14
52326: PUSH
52327: LD_VAR 0 8
52331: ARRAY
52332: PUSH
52333: LD_VAR 0 14
52337: PPUSH
52338: LD_INT 58
52340: PUSH
52341: EMPTY
52342: LIST
52343: PPUSH
52344: CALL_OW 72
52348: IN
52349: NOT
52350: IFFALSE 52406
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52352: LD_VAR 0 4
52356: PUSH
52357: LD_VAR 0 7
52361: ARRAY
52362: PPUSH
52363: LD_VAR 0 14
52367: PUSH
52368: LD_VAR 0 8
52372: ARRAY
52373: PPUSH
52374: CALL_OW 115
// attacking := true ;
52378: LD_ADDR_VAR 0 29
52382: PUSH
52383: LD_INT 1
52385: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52386: LD_VAR 0 4
52390: PUSH
52391: LD_VAR 0 7
52395: ARRAY
52396: PPUSH
52397: LD_INT 71
52399: PPUSH
52400: CALL_OW 109
// continue ;
52404: GO 52319
// end ; end ;
52406: GO 52319
52408: POP
52409: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52410: LD_VAR 0 4
52414: PUSH
52415: LD_VAR 0 7
52419: ARRAY
52420: PPUSH
52421: CALL_OW 257
52425: PUSH
52426: LD_INT 8
52428: EQUAL
52429: PUSH
52430: LD_VAR 0 4
52434: PUSH
52435: LD_VAR 0 7
52439: ARRAY
52440: PPUSH
52441: CALL_OW 264
52445: PUSH
52446: LD_INT 28
52448: PUSH
52449: LD_INT 45
52451: PUSH
52452: LD_INT 7
52454: PUSH
52455: LD_INT 47
52457: PUSH
52458: EMPTY
52459: LIST
52460: LIST
52461: LIST
52462: LIST
52463: IN
52464: OR
52465: IFFALSE 52695
// begin attacking := false ;
52467: LD_ADDR_VAR 0 29
52471: PUSH
52472: LD_INT 0
52474: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52475: LD_VAR 0 14
52479: PUSH
52480: LD_INT 1
52482: ARRAY
52483: PPUSH
52484: CALL_OW 266
52488: PUSH
52489: LD_INT 32
52491: PUSH
52492: LD_INT 31
52494: PUSH
52495: LD_INT 33
52497: PUSH
52498: LD_INT 4
52500: PUSH
52501: LD_INT 5
52503: PUSH
52504: EMPTY
52505: LIST
52506: LIST
52507: LIST
52508: LIST
52509: LIST
52510: IN
52511: IFFALSE 52695
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52513: LD_ADDR_VAR 0 9
52517: PUSH
52518: LD_VAR 0 14
52522: PUSH
52523: LD_INT 1
52525: ARRAY
52526: PPUSH
52527: CALL_OW 266
52531: PPUSH
52532: LD_VAR 0 14
52536: PUSH
52537: LD_INT 1
52539: ARRAY
52540: PPUSH
52541: CALL_OW 250
52545: PPUSH
52546: LD_VAR 0 14
52550: PUSH
52551: LD_INT 1
52553: ARRAY
52554: PPUSH
52555: CALL_OW 251
52559: PPUSH
52560: LD_VAR 0 14
52564: PUSH
52565: LD_INT 1
52567: ARRAY
52568: PPUSH
52569: CALL_OW 254
52573: PPUSH
52574: LD_VAR 0 14
52578: PUSH
52579: LD_INT 1
52581: ARRAY
52582: PPUSH
52583: CALL_OW 248
52587: PPUSH
52588: LD_INT 0
52590: PPUSH
52591: CALL 29301 0 6
52595: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52596: LD_ADDR_VAR 0 8
52600: PUSH
52601: LD_VAR 0 4
52605: PUSH
52606: LD_VAR 0 7
52610: ARRAY
52611: PPUSH
52612: LD_VAR 0 9
52616: PPUSH
52617: CALL 47994 0 2
52621: ST_TO_ADDR
// if j then
52622: LD_VAR 0 8
52626: IFFALSE 52695
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52628: LD_VAR 0 8
52632: PUSH
52633: LD_INT 1
52635: ARRAY
52636: PPUSH
52637: LD_VAR 0 8
52641: PUSH
52642: LD_INT 2
52644: ARRAY
52645: PPUSH
52646: CALL_OW 488
52650: IFFALSE 52695
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52652: LD_VAR 0 4
52656: PUSH
52657: LD_VAR 0 7
52661: ARRAY
52662: PPUSH
52663: LD_VAR 0 8
52667: PUSH
52668: LD_INT 1
52670: ARRAY
52671: PPUSH
52672: LD_VAR 0 8
52676: PUSH
52677: LD_INT 2
52679: ARRAY
52680: PPUSH
52681: CALL_OW 116
// attacking := true ;
52685: LD_ADDR_VAR 0 29
52689: PUSH
52690: LD_INT 1
52692: ST_TO_ADDR
// continue ;
52693: GO 50068
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52695: LD_VAR 0 4
52699: PUSH
52700: LD_VAR 0 7
52704: ARRAY
52705: PPUSH
52706: CALL_OW 265
52710: PUSH
52711: LD_INT 11
52713: EQUAL
52714: IFFALSE 52992
// begin k := 10 ;
52716: LD_ADDR_VAR 0 9
52720: PUSH
52721: LD_INT 10
52723: ST_TO_ADDR
// x := 0 ;
52724: LD_ADDR_VAR 0 10
52728: PUSH
52729: LD_INT 0
52731: ST_TO_ADDR
// if tmp < k then
52732: LD_VAR 0 14
52736: PUSH
52737: LD_VAR 0 9
52741: LESS
52742: IFFALSE 52754
// k := tmp ;
52744: LD_ADDR_VAR 0 9
52748: PUSH
52749: LD_VAR 0 14
52753: ST_TO_ADDR
// for j = k downto 1 do
52754: LD_ADDR_VAR 0 8
52758: PUSH
52759: DOUBLE
52760: LD_VAR 0 9
52764: INC
52765: ST_TO_ADDR
52766: LD_INT 1
52768: PUSH
52769: FOR_DOWNTO
52770: IFFALSE 52845
// begin if GetType ( tmp [ j ] ) = unit_human then
52772: LD_VAR 0 14
52776: PUSH
52777: LD_VAR 0 8
52781: ARRAY
52782: PPUSH
52783: CALL_OW 247
52787: PUSH
52788: LD_INT 1
52790: EQUAL
52791: IFFALSE 52843
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
52793: LD_VAR 0 4
52797: PUSH
52798: LD_VAR 0 7
52802: ARRAY
52803: PPUSH
52804: LD_VAR 0 14
52808: PUSH
52809: LD_VAR 0 8
52813: ARRAY
52814: PPUSH
52815: CALL 48265 0 2
// x := tmp [ j ] ;
52819: LD_ADDR_VAR 0 10
52823: PUSH
52824: LD_VAR 0 14
52828: PUSH
52829: LD_VAR 0 8
52833: ARRAY
52834: ST_TO_ADDR
// attacking := true ;
52835: LD_ADDR_VAR 0 29
52839: PUSH
52840: LD_INT 1
52842: ST_TO_ADDR
// end ; end ;
52843: GO 52769
52845: POP
52846: POP
// if not x then
52847: LD_VAR 0 10
52851: NOT
52852: IFFALSE 52992
// begin attacking := true ;
52854: LD_ADDR_VAR 0 29
52858: PUSH
52859: LD_INT 1
52861: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
52862: LD_VAR 0 4
52866: PUSH
52867: LD_VAR 0 7
52871: ARRAY
52872: PPUSH
52873: CALL_OW 250
52877: PPUSH
52878: LD_VAR 0 4
52882: PUSH
52883: LD_VAR 0 7
52887: ARRAY
52888: PPUSH
52889: CALL_OW 251
52893: PPUSH
52894: CALL_OW 546
52898: PUSH
52899: LD_INT 2
52901: ARRAY
52902: PUSH
52903: LD_VAR 0 14
52907: PUSH
52908: LD_INT 1
52910: ARRAY
52911: PPUSH
52912: CALL_OW 250
52916: PPUSH
52917: LD_VAR 0 14
52921: PUSH
52922: LD_INT 1
52924: ARRAY
52925: PPUSH
52926: CALL_OW 251
52930: PPUSH
52931: CALL_OW 546
52935: PUSH
52936: LD_INT 2
52938: ARRAY
52939: EQUAL
52940: IFFALSE 52968
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
52942: LD_VAR 0 4
52946: PUSH
52947: LD_VAR 0 7
52951: ARRAY
52952: PPUSH
52953: LD_VAR 0 14
52957: PUSH
52958: LD_INT 1
52960: ARRAY
52961: PPUSH
52962: CALL 48265 0 2
52966: GO 52992
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
52968: LD_VAR 0 4
52972: PUSH
52973: LD_VAR 0 7
52977: ARRAY
52978: PPUSH
52979: LD_VAR 0 14
52983: PUSH
52984: LD_INT 1
52986: ARRAY
52987: PPUSH
52988: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
52992: LD_VAR 0 4
52996: PUSH
52997: LD_VAR 0 7
53001: ARRAY
53002: PPUSH
53003: CALL_OW 264
53007: PUSH
53008: LD_INT 29
53010: EQUAL
53011: IFFALSE 53377
// begin if WantsToAttack ( group [ i ] ) in bombed then
53013: LD_VAR 0 4
53017: PUSH
53018: LD_VAR 0 7
53022: ARRAY
53023: PPUSH
53024: CALL_OW 319
53028: PUSH
53029: LD_VAR 0 28
53033: IN
53034: IFFALSE 53038
// continue ;
53036: GO 50068
// k := 8 ;
53038: LD_ADDR_VAR 0 9
53042: PUSH
53043: LD_INT 8
53045: ST_TO_ADDR
// x := 0 ;
53046: LD_ADDR_VAR 0 10
53050: PUSH
53051: LD_INT 0
53053: ST_TO_ADDR
// if tmp < k then
53054: LD_VAR 0 14
53058: PUSH
53059: LD_VAR 0 9
53063: LESS
53064: IFFALSE 53076
// k := tmp ;
53066: LD_ADDR_VAR 0 9
53070: PUSH
53071: LD_VAR 0 14
53075: ST_TO_ADDR
// for j = 1 to k do
53076: LD_ADDR_VAR 0 8
53080: PUSH
53081: DOUBLE
53082: LD_INT 1
53084: DEC
53085: ST_TO_ADDR
53086: LD_VAR 0 9
53090: PUSH
53091: FOR_TO
53092: IFFALSE 53224
// begin if GetType ( tmp [ j ] ) = unit_building then
53094: LD_VAR 0 14
53098: PUSH
53099: LD_VAR 0 8
53103: ARRAY
53104: PPUSH
53105: CALL_OW 247
53109: PUSH
53110: LD_INT 3
53112: EQUAL
53113: IFFALSE 53222
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53115: LD_VAR 0 14
53119: PUSH
53120: LD_VAR 0 8
53124: ARRAY
53125: PUSH
53126: LD_VAR 0 28
53130: IN
53131: NOT
53132: PUSH
53133: LD_VAR 0 14
53137: PUSH
53138: LD_VAR 0 8
53142: ARRAY
53143: PPUSH
53144: CALL_OW 313
53148: AND
53149: IFFALSE 53222
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53151: LD_VAR 0 4
53155: PUSH
53156: LD_VAR 0 7
53160: ARRAY
53161: PPUSH
53162: LD_VAR 0 14
53166: PUSH
53167: LD_VAR 0 8
53171: ARRAY
53172: PPUSH
53173: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53177: LD_ADDR_VAR 0 28
53181: PUSH
53182: LD_VAR 0 28
53186: PPUSH
53187: LD_VAR 0 28
53191: PUSH
53192: LD_INT 1
53194: PLUS
53195: PPUSH
53196: LD_VAR 0 14
53200: PUSH
53201: LD_VAR 0 8
53205: ARRAY
53206: PPUSH
53207: CALL_OW 1
53211: ST_TO_ADDR
// attacking := true ;
53212: LD_ADDR_VAR 0 29
53216: PUSH
53217: LD_INT 1
53219: ST_TO_ADDR
// break ;
53220: GO 53224
// end ; end ;
53222: GO 53091
53224: POP
53225: POP
// if not attacking and f_attack_depot then
53226: LD_VAR 0 29
53230: NOT
53231: PUSH
53232: LD_VAR 0 25
53236: AND
53237: IFFALSE 53332
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53239: LD_ADDR_VAR 0 13
53243: PUSH
53244: LD_VAR 0 14
53248: PPUSH
53249: LD_INT 2
53251: PUSH
53252: LD_INT 30
53254: PUSH
53255: LD_INT 0
53257: PUSH
53258: EMPTY
53259: LIST
53260: LIST
53261: PUSH
53262: LD_INT 30
53264: PUSH
53265: LD_INT 1
53267: PUSH
53268: EMPTY
53269: LIST
53270: LIST
53271: PUSH
53272: EMPTY
53273: LIST
53274: LIST
53275: LIST
53276: PPUSH
53277: CALL_OW 72
53281: ST_TO_ADDR
// if z then
53282: LD_VAR 0 13
53286: IFFALSE 53332
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53288: LD_VAR 0 4
53292: PUSH
53293: LD_VAR 0 7
53297: ARRAY
53298: PPUSH
53299: LD_VAR 0 13
53303: PPUSH
53304: LD_VAR 0 4
53308: PUSH
53309: LD_VAR 0 7
53313: ARRAY
53314: PPUSH
53315: CALL_OW 74
53319: PPUSH
53320: CALL_OW 115
// attacking := true ;
53324: LD_ADDR_VAR 0 29
53328: PUSH
53329: LD_INT 1
53331: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53332: LD_VAR 0 4
53336: PUSH
53337: LD_VAR 0 7
53341: ARRAY
53342: PPUSH
53343: CALL_OW 256
53347: PUSH
53348: LD_INT 500
53350: LESS
53351: IFFALSE 53377
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53353: LD_VAR 0 4
53357: PUSH
53358: LD_VAR 0 7
53362: ARRAY
53363: PPUSH
53364: LD_VAR 0 14
53368: PUSH
53369: LD_INT 1
53371: ARRAY
53372: PPUSH
53373: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53377: LD_VAR 0 4
53381: PUSH
53382: LD_VAR 0 7
53386: ARRAY
53387: PPUSH
53388: CALL_OW 264
53392: PUSH
53393: LD_INT 49
53395: EQUAL
53396: IFFALSE 53517
// begin if not HasTask ( group [ i ] ) then
53398: LD_VAR 0 4
53402: PUSH
53403: LD_VAR 0 7
53407: ARRAY
53408: PPUSH
53409: CALL_OW 314
53413: NOT
53414: IFFALSE 53517
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53416: LD_ADDR_VAR 0 9
53420: PUSH
53421: LD_INT 81
53423: PUSH
53424: LD_VAR 0 4
53428: PUSH
53429: LD_VAR 0 7
53433: ARRAY
53434: PPUSH
53435: CALL_OW 255
53439: PUSH
53440: EMPTY
53441: LIST
53442: LIST
53443: PPUSH
53444: CALL_OW 69
53448: PPUSH
53449: LD_VAR 0 4
53453: PUSH
53454: LD_VAR 0 7
53458: ARRAY
53459: PPUSH
53460: CALL_OW 74
53464: ST_TO_ADDR
// if k then
53465: LD_VAR 0 9
53469: IFFALSE 53517
// if GetDistUnits ( group [ i ] , k ) > 10 then
53471: LD_VAR 0 4
53475: PUSH
53476: LD_VAR 0 7
53480: ARRAY
53481: PPUSH
53482: LD_VAR 0 9
53486: PPUSH
53487: CALL_OW 296
53491: PUSH
53492: LD_INT 10
53494: GREATER
53495: IFFALSE 53517
// ComMoveUnit ( group [ i ] , k ) ;
53497: LD_VAR 0 4
53501: PUSH
53502: LD_VAR 0 7
53506: ARRAY
53507: PPUSH
53508: LD_VAR 0 9
53512: PPUSH
53513: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53517: LD_VAR 0 4
53521: PUSH
53522: LD_VAR 0 7
53526: ARRAY
53527: PPUSH
53528: CALL_OW 256
53532: PUSH
53533: LD_INT 250
53535: LESS
53536: PUSH
53537: LD_VAR 0 4
53541: PUSH
53542: LD_VAR 0 7
53546: ARRAY
53547: PUSH
53548: LD_INT 21
53550: PUSH
53551: LD_INT 2
53553: PUSH
53554: EMPTY
53555: LIST
53556: LIST
53557: PUSH
53558: LD_INT 23
53560: PUSH
53561: LD_INT 2
53563: PUSH
53564: EMPTY
53565: LIST
53566: LIST
53567: PUSH
53568: EMPTY
53569: LIST
53570: LIST
53571: PPUSH
53572: CALL_OW 69
53576: IN
53577: AND
53578: IFFALSE 53703
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53580: LD_ADDR_VAR 0 9
53584: PUSH
53585: LD_OWVAR 3
53589: PUSH
53590: LD_VAR 0 4
53594: PUSH
53595: LD_VAR 0 7
53599: ARRAY
53600: DIFF
53601: PPUSH
53602: LD_VAR 0 4
53606: PUSH
53607: LD_VAR 0 7
53611: ARRAY
53612: PPUSH
53613: CALL_OW 74
53617: ST_TO_ADDR
// if not k then
53618: LD_VAR 0 9
53622: NOT
53623: IFFALSE 53627
// continue ;
53625: GO 50068
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53627: LD_VAR 0 9
53631: PUSH
53632: LD_INT 81
53634: PUSH
53635: LD_VAR 0 4
53639: PUSH
53640: LD_VAR 0 7
53644: ARRAY
53645: PPUSH
53646: CALL_OW 255
53650: PUSH
53651: EMPTY
53652: LIST
53653: LIST
53654: PPUSH
53655: CALL_OW 69
53659: IN
53660: PUSH
53661: LD_VAR 0 9
53665: PPUSH
53666: LD_VAR 0 4
53670: PUSH
53671: LD_VAR 0 7
53675: ARRAY
53676: PPUSH
53677: CALL_OW 296
53681: PUSH
53682: LD_INT 5
53684: LESS
53685: AND
53686: IFFALSE 53703
// ComAutodestruct ( group [ i ] ) ;
53688: LD_VAR 0 4
53692: PUSH
53693: LD_VAR 0 7
53697: ARRAY
53698: PPUSH
53699: CALL 48163 0 1
// end ; if f_attack_depot then
53703: LD_VAR 0 25
53707: IFFALSE 53819
// begin k := 6 ;
53709: LD_ADDR_VAR 0 9
53713: PUSH
53714: LD_INT 6
53716: ST_TO_ADDR
// if tmp < k then
53717: LD_VAR 0 14
53721: PUSH
53722: LD_VAR 0 9
53726: LESS
53727: IFFALSE 53739
// k := tmp ;
53729: LD_ADDR_VAR 0 9
53733: PUSH
53734: LD_VAR 0 14
53738: ST_TO_ADDR
// for j = 1 to k do
53739: LD_ADDR_VAR 0 8
53743: PUSH
53744: DOUBLE
53745: LD_INT 1
53747: DEC
53748: ST_TO_ADDR
53749: LD_VAR 0 9
53753: PUSH
53754: FOR_TO
53755: IFFALSE 53817
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53757: LD_VAR 0 8
53761: PPUSH
53762: CALL_OW 266
53766: PUSH
53767: LD_INT 0
53769: PUSH
53770: LD_INT 1
53772: PUSH
53773: EMPTY
53774: LIST
53775: LIST
53776: IN
53777: IFFALSE 53815
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53779: LD_VAR 0 4
53783: PUSH
53784: LD_VAR 0 7
53788: ARRAY
53789: PPUSH
53790: LD_VAR 0 14
53794: PUSH
53795: LD_VAR 0 8
53799: ARRAY
53800: PPUSH
53801: CALL_OW 115
// attacking := true ;
53805: LD_ADDR_VAR 0 29
53809: PUSH
53810: LD_INT 1
53812: ST_TO_ADDR
// break ;
53813: GO 53817
// end ;
53815: GO 53754
53817: POP
53818: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
53819: LD_VAR 0 4
53823: PUSH
53824: LD_VAR 0 7
53828: ARRAY
53829: PPUSH
53830: CALL_OW 302
53834: PUSH
53835: LD_VAR 0 29
53839: NOT
53840: AND
53841: IFFALSE 54163
// begin if GetTag ( group [ i ] ) = 71 then
53843: LD_VAR 0 4
53847: PUSH
53848: LD_VAR 0 7
53852: ARRAY
53853: PPUSH
53854: CALL_OW 110
53858: PUSH
53859: LD_INT 71
53861: EQUAL
53862: IFFALSE 53903
// begin if HasTask ( group [ i ] ) then
53864: LD_VAR 0 4
53868: PUSH
53869: LD_VAR 0 7
53873: ARRAY
53874: PPUSH
53875: CALL_OW 314
53879: IFFALSE 53885
// continue else
53881: GO 50068
53883: GO 53903
// SetTag ( group [ i ] , 0 ) ;
53885: LD_VAR 0 4
53889: PUSH
53890: LD_VAR 0 7
53894: ARRAY
53895: PPUSH
53896: LD_INT 0
53898: PPUSH
53899: CALL_OW 109
// end ; k := 8 ;
53903: LD_ADDR_VAR 0 9
53907: PUSH
53908: LD_INT 8
53910: ST_TO_ADDR
// x := 0 ;
53911: LD_ADDR_VAR 0 10
53915: PUSH
53916: LD_INT 0
53918: ST_TO_ADDR
// if tmp < k then
53919: LD_VAR 0 14
53923: PUSH
53924: LD_VAR 0 9
53928: LESS
53929: IFFALSE 53941
// k := tmp ;
53931: LD_ADDR_VAR 0 9
53935: PUSH
53936: LD_VAR 0 14
53940: ST_TO_ADDR
// for j = 1 to k do
53941: LD_ADDR_VAR 0 8
53945: PUSH
53946: DOUBLE
53947: LD_INT 1
53949: DEC
53950: ST_TO_ADDR
53951: LD_VAR 0 9
53955: PUSH
53956: FOR_TO
53957: IFFALSE 54055
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
53959: LD_VAR 0 14
53963: PUSH
53964: LD_VAR 0 8
53968: ARRAY
53969: PPUSH
53970: CALL_OW 247
53974: PUSH
53975: LD_INT 1
53977: EQUAL
53978: PUSH
53979: LD_VAR 0 14
53983: PUSH
53984: LD_VAR 0 8
53988: ARRAY
53989: PPUSH
53990: CALL_OW 256
53994: PUSH
53995: LD_INT 250
53997: LESS
53998: PUSH
53999: LD_VAR 0 20
54003: AND
54004: PUSH
54005: LD_VAR 0 20
54009: NOT
54010: PUSH
54011: LD_VAR 0 14
54015: PUSH
54016: LD_VAR 0 8
54020: ARRAY
54021: PPUSH
54022: CALL_OW 256
54026: PUSH
54027: LD_INT 250
54029: GREATEREQUAL
54030: AND
54031: OR
54032: AND
54033: IFFALSE 54053
// begin x := tmp [ j ] ;
54035: LD_ADDR_VAR 0 10
54039: PUSH
54040: LD_VAR 0 14
54044: PUSH
54045: LD_VAR 0 8
54049: ARRAY
54050: ST_TO_ADDR
// break ;
54051: GO 54055
// end ;
54053: GO 53956
54055: POP
54056: POP
// if x then
54057: LD_VAR 0 10
54061: IFFALSE 54085
// ComAttackUnit ( group [ i ] , x ) else
54063: LD_VAR 0 4
54067: PUSH
54068: LD_VAR 0 7
54072: ARRAY
54073: PPUSH
54074: LD_VAR 0 10
54078: PPUSH
54079: CALL_OW 115
54083: GO 54109
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54085: LD_VAR 0 4
54089: PUSH
54090: LD_VAR 0 7
54094: ARRAY
54095: PPUSH
54096: LD_VAR 0 14
54100: PUSH
54101: LD_INT 1
54103: ARRAY
54104: PPUSH
54105: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54109: LD_VAR 0 4
54113: PUSH
54114: LD_VAR 0 7
54118: ARRAY
54119: PPUSH
54120: CALL_OW 314
54124: NOT
54125: IFFALSE 54163
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54127: LD_VAR 0 4
54131: PUSH
54132: LD_VAR 0 7
54136: ARRAY
54137: PPUSH
54138: LD_VAR 0 14
54142: PPUSH
54143: LD_VAR 0 4
54147: PUSH
54148: LD_VAR 0 7
54152: ARRAY
54153: PPUSH
54154: CALL_OW 74
54158: PPUSH
54159: CALL_OW 115
// end ; end ; end ;
54163: GO 50068
54165: POP
54166: POP
// wait ( 0 0$1 ) ;
54167: LD_INT 35
54169: PPUSH
54170: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54174: LD_VAR 0 4
54178: PUSH
54179: EMPTY
54180: EQUAL
54181: PUSH
54182: LD_INT 81
54184: PUSH
54185: LD_VAR 0 35
54189: PUSH
54190: EMPTY
54191: LIST
54192: LIST
54193: PPUSH
54194: CALL_OW 69
54198: NOT
54199: OR
54200: IFFALSE 50053
// end ;
54202: LD_VAR 0 2
54206: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54207: LD_INT 0
54209: PPUSH
54210: PPUSH
54211: PPUSH
54212: PPUSH
// if not base_units then
54213: LD_VAR 0 1
54217: NOT
54218: IFFALSE 54222
// exit ;
54220: GO 54309
// result := false ;
54222: LD_ADDR_VAR 0 2
54226: PUSH
54227: LD_INT 0
54229: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54230: LD_ADDR_VAR 0 5
54234: PUSH
54235: LD_VAR 0 1
54239: PPUSH
54240: LD_INT 21
54242: PUSH
54243: LD_INT 3
54245: PUSH
54246: EMPTY
54247: LIST
54248: LIST
54249: PPUSH
54250: CALL_OW 72
54254: ST_TO_ADDR
// if not tmp then
54255: LD_VAR 0 5
54259: NOT
54260: IFFALSE 54264
// exit ;
54262: GO 54309
// for i in tmp do
54264: LD_ADDR_VAR 0 3
54268: PUSH
54269: LD_VAR 0 5
54273: PUSH
54274: FOR_IN
54275: IFFALSE 54307
// begin result := EnemyInRange ( i , 22 ) ;
54277: LD_ADDR_VAR 0 2
54281: PUSH
54282: LD_VAR 0 3
54286: PPUSH
54287: LD_INT 22
54289: PPUSH
54290: CALL 47846 0 2
54294: ST_TO_ADDR
// if result then
54295: LD_VAR 0 2
54299: IFFALSE 54305
// exit ;
54301: POP
54302: POP
54303: GO 54309
// end ;
54305: GO 54274
54307: POP
54308: POP
// end ;
54309: LD_VAR 0 2
54313: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54314: LD_INT 0
54316: PPUSH
54317: PPUSH
// if not units then
54318: LD_VAR 0 1
54322: NOT
54323: IFFALSE 54327
// exit ;
54325: GO 54397
// result := [ ] ;
54327: LD_ADDR_VAR 0 3
54331: PUSH
54332: EMPTY
54333: ST_TO_ADDR
// for i in units do
54334: LD_ADDR_VAR 0 4
54338: PUSH
54339: LD_VAR 0 1
54343: PUSH
54344: FOR_IN
54345: IFFALSE 54395
// if GetTag ( i ) = tag then
54347: LD_VAR 0 4
54351: PPUSH
54352: CALL_OW 110
54356: PUSH
54357: LD_VAR 0 2
54361: EQUAL
54362: IFFALSE 54393
// result := Insert ( result , result + 1 , i ) ;
54364: LD_ADDR_VAR 0 3
54368: PUSH
54369: LD_VAR 0 3
54373: PPUSH
54374: LD_VAR 0 3
54378: PUSH
54379: LD_INT 1
54381: PLUS
54382: PPUSH
54383: LD_VAR 0 4
54387: PPUSH
54388: CALL_OW 2
54392: ST_TO_ADDR
54393: GO 54344
54395: POP
54396: POP
// end ;
54397: LD_VAR 0 3
54401: RET
// export function IsDriver ( un ) ; begin
54402: LD_INT 0
54404: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54405: LD_ADDR_VAR 0 2
54409: PUSH
54410: LD_VAR 0 1
54414: PUSH
54415: LD_INT 55
54417: PUSH
54418: EMPTY
54419: LIST
54420: PPUSH
54421: CALL_OW 69
54425: IN
54426: ST_TO_ADDR
// end ;
54427: LD_VAR 0 2
54431: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54432: LD_INT 0
54434: PPUSH
54435: PPUSH
// list := [ ] ;
54436: LD_ADDR_VAR 0 5
54440: PUSH
54441: EMPTY
54442: ST_TO_ADDR
// case d of 0 :
54443: LD_VAR 0 3
54447: PUSH
54448: LD_INT 0
54450: DOUBLE
54451: EQUAL
54452: IFTRUE 54456
54454: GO 54589
54456: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54457: LD_ADDR_VAR 0 5
54461: PUSH
54462: LD_VAR 0 1
54466: PUSH
54467: LD_INT 4
54469: MINUS
54470: PUSH
54471: LD_VAR 0 2
54475: PUSH
54476: LD_INT 4
54478: MINUS
54479: PUSH
54480: LD_INT 2
54482: PUSH
54483: EMPTY
54484: LIST
54485: LIST
54486: LIST
54487: PUSH
54488: LD_VAR 0 1
54492: PUSH
54493: LD_INT 3
54495: MINUS
54496: PUSH
54497: LD_VAR 0 2
54501: PUSH
54502: LD_INT 1
54504: PUSH
54505: EMPTY
54506: LIST
54507: LIST
54508: LIST
54509: PUSH
54510: LD_VAR 0 1
54514: PUSH
54515: LD_INT 4
54517: PLUS
54518: PUSH
54519: LD_VAR 0 2
54523: PUSH
54524: LD_INT 4
54526: PUSH
54527: EMPTY
54528: LIST
54529: LIST
54530: LIST
54531: PUSH
54532: LD_VAR 0 1
54536: PUSH
54537: LD_INT 3
54539: PLUS
54540: PUSH
54541: LD_VAR 0 2
54545: PUSH
54546: LD_INT 3
54548: PLUS
54549: PUSH
54550: LD_INT 5
54552: PUSH
54553: EMPTY
54554: LIST
54555: LIST
54556: LIST
54557: PUSH
54558: LD_VAR 0 1
54562: PUSH
54563: LD_VAR 0 2
54567: PUSH
54568: LD_INT 4
54570: PLUS
54571: PUSH
54572: LD_INT 0
54574: PUSH
54575: EMPTY
54576: LIST
54577: LIST
54578: LIST
54579: PUSH
54580: EMPTY
54581: LIST
54582: LIST
54583: LIST
54584: LIST
54585: LIST
54586: ST_TO_ADDR
// end ; 1 :
54587: GO 55287
54589: LD_INT 1
54591: DOUBLE
54592: EQUAL
54593: IFTRUE 54597
54595: GO 54730
54597: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54598: LD_ADDR_VAR 0 5
54602: PUSH
54603: LD_VAR 0 1
54607: PUSH
54608: LD_VAR 0 2
54612: PUSH
54613: LD_INT 4
54615: MINUS
54616: PUSH
54617: LD_INT 3
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: LIST
54624: PUSH
54625: LD_VAR 0 1
54629: PUSH
54630: LD_INT 3
54632: MINUS
54633: PUSH
54634: LD_VAR 0 2
54638: PUSH
54639: LD_INT 3
54641: MINUS
54642: PUSH
54643: LD_INT 2
54645: PUSH
54646: EMPTY
54647: LIST
54648: LIST
54649: LIST
54650: PUSH
54651: LD_VAR 0 1
54655: PUSH
54656: LD_INT 4
54658: MINUS
54659: PUSH
54660: LD_VAR 0 2
54664: PUSH
54665: LD_INT 1
54667: PUSH
54668: EMPTY
54669: LIST
54670: LIST
54671: LIST
54672: PUSH
54673: LD_VAR 0 1
54677: PUSH
54678: LD_VAR 0 2
54682: PUSH
54683: LD_INT 3
54685: PLUS
54686: PUSH
54687: LD_INT 0
54689: PUSH
54690: EMPTY
54691: LIST
54692: LIST
54693: LIST
54694: PUSH
54695: LD_VAR 0 1
54699: PUSH
54700: LD_INT 4
54702: PLUS
54703: PUSH
54704: LD_VAR 0 2
54708: PUSH
54709: LD_INT 4
54711: PLUS
54712: PUSH
54713: LD_INT 5
54715: PUSH
54716: EMPTY
54717: LIST
54718: LIST
54719: LIST
54720: PUSH
54721: EMPTY
54722: LIST
54723: LIST
54724: LIST
54725: LIST
54726: LIST
54727: ST_TO_ADDR
// end ; 2 :
54728: GO 55287
54730: LD_INT 2
54732: DOUBLE
54733: EQUAL
54734: IFTRUE 54738
54736: GO 54867
54738: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54739: LD_ADDR_VAR 0 5
54743: PUSH
54744: LD_VAR 0 1
54748: PUSH
54749: LD_VAR 0 2
54753: PUSH
54754: LD_INT 3
54756: MINUS
54757: PUSH
54758: LD_INT 3
54760: PUSH
54761: EMPTY
54762: LIST
54763: LIST
54764: LIST
54765: PUSH
54766: LD_VAR 0 1
54770: PUSH
54771: LD_INT 4
54773: PLUS
54774: PUSH
54775: LD_VAR 0 2
54779: PUSH
54780: LD_INT 4
54782: PUSH
54783: EMPTY
54784: LIST
54785: LIST
54786: LIST
54787: PUSH
54788: LD_VAR 0 1
54792: PUSH
54793: LD_VAR 0 2
54797: PUSH
54798: LD_INT 4
54800: PLUS
54801: PUSH
54802: LD_INT 0
54804: PUSH
54805: EMPTY
54806: LIST
54807: LIST
54808: LIST
54809: PUSH
54810: LD_VAR 0 1
54814: PUSH
54815: LD_INT 3
54817: MINUS
54818: PUSH
54819: LD_VAR 0 2
54823: PUSH
54824: LD_INT 1
54826: PUSH
54827: EMPTY
54828: LIST
54829: LIST
54830: LIST
54831: PUSH
54832: LD_VAR 0 1
54836: PUSH
54837: LD_INT 4
54839: MINUS
54840: PUSH
54841: LD_VAR 0 2
54845: PUSH
54846: LD_INT 4
54848: MINUS
54849: PUSH
54850: LD_INT 2
54852: PUSH
54853: EMPTY
54854: LIST
54855: LIST
54856: LIST
54857: PUSH
54858: EMPTY
54859: LIST
54860: LIST
54861: LIST
54862: LIST
54863: LIST
54864: ST_TO_ADDR
// end ; 3 :
54865: GO 55287
54867: LD_INT 3
54869: DOUBLE
54870: EQUAL
54871: IFTRUE 54875
54873: GO 55008
54875: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
54876: LD_ADDR_VAR 0 5
54880: PUSH
54881: LD_VAR 0 1
54885: PUSH
54886: LD_INT 3
54888: PLUS
54889: PUSH
54890: LD_VAR 0 2
54894: PUSH
54895: LD_INT 4
54897: PUSH
54898: EMPTY
54899: LIST
54900: LIST
54901: LIST
54902: PUSH
54903: LD_VAR 0 1
54907: PUSH
54908: LD_INT 4
54910: PLUS
54911: PUSH
54912: LD_VAR 0 2
54916: PUSH
54917: LD_INT 4
54919: PLUS
54920: PUSH
54921: LD_INT 5
54923: PUSH
54924: EMPTY
54925: LIST
54926: LIST
54927: LIST
54928: PUSH
54929: LD_VAR 0 1
54933: PUSH
54934: LD_INT 4
54936: MINUS
54937: PUSH
54938: LD_VAR 0 2
54942: PUSH
54943: LD_INT 1
54945: PUSH
54946: EMPTY
54947: LIST
54948: LIST
54949: LIST
54950: PUSH
54951: LD_VAR 0 1
54955: PUSH
54956: LD_VAR 0 2
54960: PUSH
54961: LD_INT 4
54963: MINUS
54964: PUSH
54965: LD_INT 3
54967: PUSH
54968: EMPTY
54969: LIST
54970: LIST
54971: LIST
54972: PUSH
54973: LD_VAR 0 1
54977: PUSH
54978: LD_INT 3
54980: MINUS
54981: PUSH
54982: LD_VAR 0 2
54986: PUSH
54987: LD_INT 3
54989: MINUS
54990: PUSH
54991: LD_INT 2
54993: PUSH
54994: EMPTY
54995: LIST
54996: LIST
54997: LIST
54998: PUSH
54999: EMPTY
55000: LIST
55001: LIST
55002: LIST
55003: LIST
55004: LIST
55005: ST_TO_ADDR
// end ; 4 :
55006: GO 55287
55008: LD_INT 4
55010: DOUBLE
55011: EQUAL
55012: IFTRUE 55016
55014: GO 55149
55016: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55017: LD_ADDR_VAR 0 5
55021: PUSH
55022: LD_VAR 0 1
55026: PUSH
55027: LD_VAR 0 2
55031: PUSH
55032: LD_INT 4
55034: PLUS
55035: PUSH
55036: LD_INT 0
55038: PUSH
55039: EMPTY
55040: LIST
55041: LIST
55042: LIST
55043: PUSH
55044: LD_VAR 0 1
55048: PUSH
55049: LD_INT 3
55051: PLUS
55052: PUSH
55053: LD_VAR 0 2
55057: PUSH
55058: LD_INT 3
55060: PLUS
55061: PUSH
55062: LD_INT 5
55064: PUSH
55065: EMPTY
55066: LIST
55067: LIST
55068: LIST
55069: PUSH
55070: LD_VAR 0 1
55074: PUSH
55075: LD_INT 4
55077: PLUS
55078: PUSH
55079: LD_VAR 0 2
55083: PUSH
55084: LD_INT 4
55086: PUSH
55087: EMPTY
55088: LIST
55089: LIST
55090: LIST
55091: PUSH
55092: LD_VAR 0 1
55096: PUSH
55097: LD_VAR 0 2
55101: PUSH
55102: LD_INT 3
55104: MINUS
55105: PUSH
55106: LD_INT 3
55108: PUSH
55109: EMPTY
55110: LIST
55111: LIST
55112: LIST
55113: PUSH
55114: LD_VAR 0 1
55118: PUSH
55119: LD_INT 4
55121: MINUS
55122: PUSH
55123: LD_VAR 0 2
55127: PUSH
55128: LD_INT 4
55130: MINUS
55131: PUSH
55132: LD_INT 2
55134: PUSH
55135: EMPTY
55136: LIST
55137: LIST
55138: LIST
55139: PUSH
55140: EMPTY
55141: LIST
55142: LIST
55143: LIST
55144: LIST
55145: LIST
55146: ST_TO_ADDR
// end ; 5 :
55147: GO 55287
55149: LD_INT 5
55151: DOUBLE
55152: EQUAL
55153: IFTRUE 55157
55155: GO 55286
55157: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55158: LD_ADDR_VAR 0 5
55162: PUSH
55163: LD_VAR 0 1
55167: PUSH
55168: LD_INT 4
55170: MINUS
55171: PUSH
55172: LD_VAR 0 2
55176: PUSH
55177: LD_INT 1
55179: PUSH
55180: EMPTY
55181: LIST
55182: LIST
55183: LIST
55184: PUSH
55185: LD_VAR 0 1
55189: PUSH
55190: LD_VAR 0 2
55194: PUSH
55195: LD_INT 4
55197: MINUS
55198: PUSH
55199: LD_INT 3
55201: PUSH
55202: EMPTY
55203: LIST
55204: LIST
55205: LIST
55206: PUSH
55207: LD_VAR 0 1
55211: PUSH
55212: LD_INT 4
55214: PLUS
55215: PUSH
55216: LD_VAR 0 2
55220: PUSH
55221: LD_INT 4
55223: PLUS
55224: PUSH
55225: LD_INT 5
55227: PUSH
55228: EMPTY
55229: LIST
55230: LIST
55231: LIST
55232: PUSH
55233: LD_VAR 0 1
55237: PUSH
55238: LD_INT 3
55240: PLUS
55241: PUSH
55242: LD_VAR 0 2
55246: PUSH
55247: LD_INT 4
55249: PUSH
55250: EMPTY
55251: LIST
55252: LIST
55253: LIST
55254: PUSH
55255: LD_VAR 0 1
55259: PUSH
55260: LD_VAR 0 2
55264: PUSH
55265: LD_INT 3
55267: PLUS
55268: PUSH
55269: LD_INT 0
55271: PUSH
55272: EMPTY
55273: LIST
55274: LIST
55275: LIST
55276: PUSH
55277: EMPTY
55278: LIST
55279: LIST
55280: LIST
55281: LIST
55282: LIST
55283: ST_TO_ADDR
// end ; end ;
55284: GO 55287
55286: POP
// result := list ;
55287: LD_ADDR_VAR 0 4
55291: PUSH
55292: LD_VAR 0 5
55296: ST_TO_ADDR
// end ;
55297: LD_VAR 0 4
55301: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55302: LD_INT 0
55304: PPUSH
55305: PPUSH
55306: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55307: LD_VAR 0 1
55311: NOT
55312: PUSH
55313: LD_VAR 0 2
55317: PUSH
55318: LD_INT 1
55320: PUSH
55321: LD_INT 2
55323: PUSH
55324: LD_INT 3
55326: PUSH
55327: LD_INT 4
55329: PUSH
55330: EMPTY
55331: LIST
55332: LIST
55333: LIST
55334: LIST
55335: IN
55336: NOT
55337: OR
55338: IFFALSE 55342
// exit ;
55340: GO 55434
// tmp := [ ] ;
55342: LD_ADDR_VAR 0 5
55346: PUSH
55347: EMPTY
55348: ST_TO_ADDR
// for i in units do
55349: LD_ADDR_VAR 0 4
55353: PUSH
55354: LD_VAR 0 1
55358: PUSH
55359: FOR_IN
55360: IFFALSE 55403
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55362: LD_ADDR_VAR 0 5
55366: PUSH
55367: LD_VAR 0 5
55371: PPUSH
55372: LD_VAR 0 5
55376: PUSH
55377: LD_INT 1
55379: PLUS
55380: PPUSH
55381: LD_VAR 0 4
55385: PPUSH
55386: LD_VAR 0 2
55390: PPUSH
55391: CALL_OW 259
55395: PPUSH
55396: CALL_OW 2
55400: ST_TO_ADDR
55401: GO 55359
55403: POP
55404: POP
// if not tmp then
55405: LD_VAR 0 5
55409: NOT
55410: IFFALSE 55414
// exit ;
55412: GO 55434
// result := SortListByListDesc ( units , tmp ) ;
55414: LD_ADDR_VAR 0 3
55418: PUSH
55419: LD_VAR 0 1
55423: PPUSH
55424: LD_VAR 0 5
55428: PPUSH
55429: CALL_OW 77
55433: ST_TO_ADDR
// end ;
55434: LD_VAR 0 3
55438: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55439: LD_INT 0
55441: PPUSH
55442: PPUSH
55443: PPUSH
// x := GetX ( building ) ;
55444: LD_ADDR_VAR 0 4
55448: PUSH
55449: LD_VAR 0 2
55453: PPUSH
55454: CALL_OW 250
55458: ST_TO_ADDR
// y := GetY ( building ) ;
55459: LD_ADDR_VAR 0 5
55463: PUSH
55464: LD_VAR 0 2
55468: PPUSH
55469: CALL_OW 251
55473: ST_TO_ADDR
// if GetTaskList ( unit ) then
55474: LD_VAR 0 1
55478: PPUSH
55479: CALL_OW 437
55483: IFFALSE 55578
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55485: LD_STRING e
55487: PUSH
55488: LD_VAR 0 1
55492: PPUSH
55493: CALL_OW 437
55497: PUSH
55498: LD_INT 1
55500: ARRAY
55501: PUSH
55502: LD_INT 1
55504: ARRAY
55505: EQUAL
55506: PUSH
55507: LD_VAR 0 4
55511: PUSH
55512: LD_VAR 0 1
55516: PPUSH
55517: CALL_OW 437
55521: PUSH
55522: LD_INT 1
55524: ARRAY
55525: PUSH
55526: LD_INT 2
55528: ARRAY
55529: EQUAL
55530: AND
55531: PUSH
55532: LD_VAR 0 5
55536: PUSH
55537: LD_VAR 0 1
55541: PPUSH
55542: CALL_OW 437
55546: PUSH
55547: LD_INT 1
55549: ARRAY
55550: PUSH
55551: LD_INT 3
55553: ARRAY
55554: EQUAL
55555: AND
55556: IFFALSE 55568
// result := true else
55558: LD_ADDR_VAR 0 3
55562: PUSH
55563: LD_INT 1
55565: ST_TO_ADDR
55566: GO 55576
// result := false ;
55568: LD_ADDR_VAR 0 3
55572: PUSH
55573: LD_INT 0
55575: ST_TO_ADDR
// end else
55576: GO 55586
// result := false ;
55578: LD_ADDR_VAR 0 3
55582: PUSH
55583: LD_INT 0
55585: ST_TO_ADDR
// end ;
55586: LD_VAR 0 3
55590: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55591: LD_INT 0
55593: PPUSH
55594: PPUSH
55595: PPUSH
55596: PPUSH
// if not unit or not area then
55597: LD_VAR 0 1
55601: NOT
55602: PUSH
55603: LD_VAR 0 2
55607: NOT
55608: OR
55609: IFFALSE 55613
// exit ;
55611: GO 55777
// tmp := AreaToList ( area , i ) ;
55613: LD_ADDR_VAR 0 6
55617: PUSH
55618: LD_VAR 0 2
55622: PPUSH
55623: LD_VAR 0 5
55627: PPUSH
55628: CALL_OW 517
55632: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55633: LD_ADDR_VAR 0 5
55637: PUSH
55638: DOUBLE
55639: LD_INT 1
55641: DEC
55642: ST_TO_ADDR
55643: LD_VAR 0 6
55647: PUSH
55648: LD_INT 1
55650: ARRAY
55651: PUSH
55652: FOR_TO
55653: IFFALSE 55775
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55655: LD_ADDR_VAR 0 7
55659: PUSH
55660: LD_VAR 0 6
55664: PUSH
55665: LD_INT 1
55667: ARRAY
55668: PUSH
55669: LD_VAR 0 5
55673: ARRAY
55674: PUSH
55675: LD_VAR 0 6
55679: PUSH
55680: LD_INT 2
55682: ARRAY
55683: PUSH
55684: LD_VAR 0 5
55688: ARRAY
55689: PUSH
55690: EMPTY
55691: LIST
55692: LIST
55693: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55694: LD_VAR 0 7
55698: PUSH
55699: LD_INT 1
55701: ARRAY
55702: PPUSH
55703: LD_VAR 0 7
55707: PUSH
55708: LD_INT 2
55710: ARRAY
55711: PPUSH
55712: CALL_OW 428
55716: PUSH
55717: LD_INT 0
55719: EQUAL
55720: IFFALSE 55773
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55722: LD_VAR 0 1
55726: PPUSH
55727: LD_VAR 0 7
55731: PUSH
55732: LD_INT 1
55734: ARRAY
55735: PPUSH
55736: LD_VAR 0 7
55740: PUSH
55741: LD_INT 2
55743: ARRAY
55744: PPUSH
55745: LD_VAR 0 3
55749: PPUSH
55750: CALL_OW 48
// result := IsPlaced ( unit ) ;
55754: LD_ADDR_VAR 0 4
55758: PUSH
55759: LD_VAR 0 1
55763: PPUSH
55764: CALL_OW 305
55768: ST_TO_ADDR
// exit ;
55769: POP
55770: POP
55771: GO 55777
// end ; end ;
55773: GO 55652
55775: POP
55776: POP
// end ;
55777: LD_VAR 0 4
55781: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
55782: LD_INT 0
55784: PPUSH
55785: PPUSH
55786: PPUSH
// if not side or side > 8 then
55787: LD_VAR 0 1
55791: NOT
55792: PUSH
55793: LD_VAR 0 1
55797: PUSH
55798: LD_INT 8
55800: GREATER
55801: OR
55802: IFFALSE 55806
// exit ;
55804: GO 55993
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
55806: LD_ADDR_VAR 0 4
55810: PUSH
55811: LD_INT 22
55813: PUSH
55814: LD_VAR 0 1
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PUSH
55823: LD_INT 21
55825: PUSH
55826: LD_INT 3
55828: PUSH
55829: EMPTY
55830: LIST
55831: LIST
55832: PUSH
55833: EMPTY
55834: LIST
55835: LIST
55836: PPUSH
55837: CALL_OW 69
55841: ST_TO_ADDR
// if not tmp then
55842: LD_VAR 0 4
55846: NOT
55847: IFFALSE 55851
// exit ;
55849: GO 55993
// enable_addtolog := true ;
55851: LD_ADDR_OWVAR 81
55855: PUSH
55856: LD_INT 1
55858: ST_TO_ADDR
// AddToLog ( [ ) ;
55859: LD_STRING [
55861: PPUSH
55862: CALL_OW 561
// for i in tmp do
55866: LD_ADDR_VAR 0 3
55870: PUSH
55871: LD_VAR 0 4
55875: PUSH
55876: FOR_IN
55877: IFFALSE 55984
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
55879: LD_STRING [
55881: PUSH
55882: LD_VAR 0 3
55886: PPUSH
55887: CALL_OW 266
55891: STR
55892: PUSH
55893: LD_STRING , 
55895: STR
55896: PUSH
55897: LD_VAR 0 3
55901: PPUSH
55902: CALL_OW 250
55906: STR
55907: PUSH
55908: LD_STRING , 
55910: STR
55911: PUSH
55912: LD_VAR 0 3
55916: PPUSH
55917: CALL_OW 251
55921: STR
55922: PUSH
55923: LD_STRING , 
55925: STR
55926: PUSH
55927: LD_VAR 0 3
55931: PPUSH
55932: CALL_OW 254
55936: STR
55937: PUSH
55938: LD_STRING , 
55940: STR
55941: PUSH
55942: LD_VAR 0 3
55946: PPUSH
55947: LD_INT 1
55949: PPUSH
55950: CALL_OW 268
55954: STR
55955: PUSH
55956: LD_STRING , 
55958: STR
55959: PUSH
55960: LD_VAR 0 3
55964: PPUSH
55965: LD_INT 2
55967: PPUSH
55968: CALL_OW 268
55972: STR
55973: PUSH
55974: LD_STRING ],
55976: STR
55977: PPUSH
55978: CALL_OW 561
// end ;
55982: GO 55876
55984: POP
55985: POP
// AddToLog ( ]; ) ;
55986: LD_STRING ];
55988: PPUSH
55989: CALL_OW 561
// end ;
55993: LD_VAR 0 2
55997: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
55998: LD_INT 0
56000: PPUSH
56001: PPUSH
56002: PPUSH
56003: PPUSH
56004: PPUSH
// if not area or not rate or not max then
56005: LD_VAR 0 1
56009: NOT
56010: PUSH
56011: LD_VAR 0 2
56015: NOT
56016: OR
56017: PUSH
56018: LD_VAR 0 4
56022: NOT
56023: OR
56024: IFFALSE 56028
// exit ;
56026: GO 56220
// while 1 do
56028: LD_INT 1
56030: IFFALSE 56220
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56032: LD_ADDR_VAR 0 9
56036: PUSH
56037: LD_VAR 0 1
56041: PPUSH
56042: LD_INT 1
56044: PPUSH
56045: CALL_OW 287
56049: PUSH
56050: LD_INT 10
56052: MUL
56053: ST_TO_ADDR
// r := rate / 10 ;
56054: LD_ADDR_VAR 0 7
56058: PUSH
56059: LD_VAR 0 2
56063: PUSH
56064: LD_INT 10
56066: DIVREAL
56067: ST_TO_ADDR
// time := 1 1$00 ;
56068: LD_ADDR_VAR 0 8
56072: PUSH
56073: LD_INT 2100
56075: ST_TO_ADDR
// if amount < min then
56076: LD_VAR 0 9
56080: PUSH
56081: LD_VAR 0 3
56085: LESS
56086: IFFALSE 56104
// r := r * 2 else
56088: LD_ADDR_VAR 0 7
56092: PUSH
56093: LD_VAR 0 7
56097: PUSH
56098: LD_INT 2
56100: MUL
56101: ST_TO_ADDR
56102: GO 56130
// if amount > max then
56104: LD_VAR 0 9
56108: PUSH
56109: LD_VAR 0 4
56113: GREATER
56114: IFFALSE 56130
// r := r / 2 ;
56116: LD_ADDR_VAR 0 7
56120: PUSH
56121: LD_VAR 0 7
56125: PUSH
56126: LD_INT 2
56128: DIVREAL
56129: ST_TO_ADDR
// time := time / r ;
56130: LD_ADDR_VAR 0 8
56134: PUSH
56135: LD_VAR 0 8
56139: PUSH
56140: LD_VAR 0 7
56144: DIVREAL
56145: ST_TO_ADDR
// if time < 0 then
56146: LD_VAR 0 8
56150: PUSH
56151: LD_INT 0
56153: LESS
56154: IFFALSE 56171
// time := time * - 1 ;
56156: LD_ADDR_VAR 0 8
56160: PUSH
56161: LD_VAR 0 8
56165: PUSH
56166: LD_INT 1
56168: NEG
56169: MUL
56170: ST_TO_ADDR
// wait ( time ) ;
56171: LD_VAR 0 8
56175: PPUSH
56176: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56180: LD_INT 35
56182: PPUSH
56183: LD_INT 875
56185: PPUSH
56186: CALL_OW 12
56190: PPUSH
56191: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56195: LD_INT 1
56197: PPUSH
56198: LD_INT 5
56200: PPUSH
56201: CALL_OW 12
56205: PPUSH
56206: LD_VAR 0 1
56210: PPUSH
56211: LD_INT 1
56213: PPUSH
56214: CALL_OW 55
// end ;
56218: GO 56028
// end ;
56220: LD_VAR 0 5
56224: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56225: LD_INT 0
56227: PPUSH
56228: PPUSH
56229: PPUSH
56230: PPUSH
56231: PPUSH
56232: PPUSH
56233: PPUSH
56234: PPUSH
// if not turrets or not factories then
56235: LD_VAR 0 1
56239: NOT
56240: PUSH
56241: LD_VAR 0 2
56245: NOT
56246: OR
56247: IFFALSE 56251
// exit ;
56249: GO 56558
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56251: LD_ADDR_VAR 0 10
56255: PUSH
56256: LD_INT 5
56258: PUSH
56259: LD_INT 6
56261: PUSH
56262: EMPTY
56263: LIST
56264: LIST
56265: PUSH
56266: LD_INT 2
56268: PUSH
56269: LD_INT 4
56271: PUSH
56272: EMPTY
56273: LIST
56274: LIST
56275: PUSH
56276: LD_INT 3
56278: PUSH
56279: LD_INT 5
56281: PUSH
56282: EMPTY
56283: LIST
56284: LIST
56285: PUSH
56286: EMPTY
56287: LIST
56288: LIST
56289: LIST
56290: PUSH
56291: LD_INT 24
56293: PUSH
56294: LD_INT 25
56296: PUSH
56297: EMPTY
56298: LIST
56299: LIST
56300: PUSH
56301: LD_INT 23
56303: PUSH
56304: LD_INT 27
56306: PUSH
56307: EMPTY
56308: LIST
56309: LIST
56310: PUSH
56311: EMPTY
56312: LIST
56313: LIST
56314: PUSH
56315: LD_INT 42
56317: PUSH
56318: LD_INT 43
56320: PUSH
56321: EMPTY
56322: LIST
56323: LIST
56324: PUSH
56325: LD_INT 44
56327: PUSH
56328: LD_INT 46
56330: PUSH
56331: EMPTY
56332: LIST
56333: LIST
56334: PUSH
56335: LD_INT 45
56337: PUSH
56338: LD_INT 47
56340: PUSH
56341: EMPTY
56342: LIST
56343: LIST
56344: PUSH
56345: EMPTY
56346: LIST
56347: LIST
56348: LIST
56349: PUSH
56350: EMPTY
56351: LIST
56352: LIST
56353: LIST
56354: ST_TO_ADDR
// result := [ ] ;
56355: LD_ADDR_VAR 0 3
56359: PUSH
56360: EMPTY
56361: ST_TO_ADDR
// for i in turrets do
56362: LD_ADDR_VAR 0 4
56366: PUSH
56367: LD_VAR 0 1
56371: PUSH
56372: FOR_IN
56373: IFFALSE 56556
// begin nat := GetNation ( i ) ;
56375: LD_ADDR_VAR 0 7
56379: PUSH
56380: LD_VAR 0 4
56384: PPUSH
56385: CALL_OW 248
56389: ST_TO_ADDR
// weapon := 0 ;
56390: LD_ADDR_VAR 0 8
56394: PUSH
56395: LD_INT 0
56397: ST_TO_ADDR
// if not nat then
56398: LD_VAR 0 7
56402: NOT
56403: IFFALSE 56407
// continue ;
56405: GO 56372
// for j in list [ nat ] do
56407: LD_ADDR_VAR 0 5
56411: PUSH
56412: LD_VAR 0 10
56416: PUSH
56417: LD_VAR 0 7
56421: ARRAY
56422: PUSH
56423: FOR_IN
56424: IFFALSE 56465
// if GetBWeapon ( i ) = j [ 1 ] then
56426: LD_VAR 0 4
56430: PPUSH
56431: CALL_OW 269
56435: PUSH
56436: LD_VAR 0 5
56440: PUSH
56441: LD_INT 1
56443: ARRAY
56444: EQUAL
56445: IFFALSE 56463
// begin weapon := j [ 2 ] ;
56447: LD_ADDR_VAR 0 8
56451: PUSH
56452: LD_VAR 0 5
56456: PUSH
56457: LD_INT 2
56459: ARRAY
56460: ST_TO_ADDR
// break ;
56461: GO 56465
// end ;
56463: GO 56423
56465: POP
56466: POP
// if not weapon then
56467: LD_VAR 0 8
56471: NOT
56472: IFFALSE 56476
// continue ;
56474: GO 56372
// for k in factories do
56476: LD_ADDR_VAR 0 6
56480: PUSH
56481: LD_VAR 0 2
56485: PUSH
56486: FOR_IN
56487: IFFALSE 56552
// begin weapons := AvailableWeaponList ( k ) ;
56489: LD_ADDR_VAR 0 9
56493: PUSH
56494: LD_VAR 0 6
56498: PPUSH
56499: CALL_OW 478
56503: ST_TO_ADDR
// if not weapons then
56504: LD_VAR 0 9
56508: NOT
56509: IFFALSE 56513
// continue ;
56511: GO 56486
// if weapon in weapons then
56513: LD_VAR 0 8
56517: PUSH
56518: LD_VAR 0 9
56522: IN
56523: IFFALSE 56550
// begin result := [ i , weapon ] ;
56525: LD_ADDR_VAR 0 3
56529: PUSH
56530: LD_VAR 0 4
56534: PUSH
56535: LD_VAR 0 8
56539: PUSH
56540: EMPTY
56541: LIST
56542: LIST
56543: ST_TO_ADDR
// exit ;
56544: POP
56545: POP
56546: POP
56547: POP
56548: GO 56558
// end ; end ;
56550: GO 56486
56552: POP
56553: POP
// end ;
56554: GO 56372
56556: POP
56557: POP
// end ;
56558: LD_VAR 0 3
56562: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56563: LD_INT 0
56565: PPUSH
// if not side or side > 8 then
56566: LD_VAR 0 3
56570: NOT
56571: PUSH
56572: LD_VAR 0 3
56576: PUSH
56577: LD_INT 8
56579: GREATER
56580: OR
56581: IFFALSE 56585
// exit ;
56583: GO 56644
// if not range then
56585: LD_VAR 0 4
56589: NOT
56590: IFFALSE 56601
// range := - 12 ;
56592: LD_ADDR_VAR 0 4
56596: PUSH
56597: LD_INT 12
56599: NEG
56600: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56601: LD_VAR 0 1
56605: PPUSH
56606: LD_VAR 0 2
56610: PPUSH
56611: LD_VAR 0 3
56615: PPUSH
56616: LD_VAR 0 4
56620: PPUSH
56621: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56625: LD_VAR 0 1
56629: PPUSH
56630: LD_VAR 0 2
56634: PPUSH
56635: LD_VAR 0 3
56639: PPUSH
56640: CALL_OW 331
// end ;
56644: LD_VAR 0 5
56648: RET
// export function Video ( mode ) ; begin
56649: LD_INT 0
56651: PPUSH
// ingame_video = mode ;
56652: LD_ADDR_OWVAR 52
56656: PUSH
56657: LD_VAR 0 1
56661: ST_TO_ADDR
// interface_hidden = mode ;
56662: LD_ADDR_OWVAR 54
56666: PUSH
56667: LD_VAR 0 1
56671: ST_TO_ADDR
// end ;
56672: LD_VAR 0 2
56676: RET
// export function Join ( array , element ) ; begin
56677: LD_INT 0
56679: PPUSH
// result := array ^ element ;
56680: LD_ADDR_VAR 0 3
56684: PUSH
56685: LD_VAR 0 1
56689: PUSH
56690: LD_VAR 0 2
56694: ADD
56695: ST_TO_ADDR
// end ;
56696: LD_VAR 0 3
56700: RET
// export function JoinUnion ( array , element ) ; begin
56701: LD_INT 0
56703: PPUSH
// result := array union element ;
56704: LD_ADDR_VAR 0 3
56708: PUSH
56709: LD_VAR 0 1
56713: PUSH
56714: LD_VAR 0 2
56718: UNION
56719: ST_TO_ADDR
// end ;
56720: LD_VAR 0 3
56724: RET
// export function GetBehemoths ( side ) ; begin
56725: LD_INT 0
56727: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56728: LD_ADDR_VAR 0 2
56732: PUSH
56733: LD_INT 22
56735: PUSH
56736: LD_VAR 0 1
56740: PUSH
56741: EMPTY
56742: LIST
56743: LIST
56744: PUSH
56745: LD_INT 31
56747: PUSH
56748: LD_INT 25
56750: PUSH
56751: EMPTY
56752: LIST
56753: LIST
56754: PUSH
56755: EMPTY
56756: LIST
56757: LIST
56758: PPUSH
56759: CALL_OW 69
56763: ST_TO_ADDR
// end ;
56764: LD_VAR 0 2
56768: RET
// export function Shuffle ( array ) ; var i , index ; begin
56769: LD_INT 0
56771: PPUSH
56772: PPUSH
56773: PPUSH
// result := [ ] ;
56774: LD_ADDR_VAR 0 2
56778: PUSH
56779: EMPTY
56780: ST_TO_ADDR
// if not array then
56781: LD_VAR 0 1
56785: NOT
56786: IFFALSE 56790
// exit ;
56788: GO 56889
// Randomize ;
56790: CALL_OW 10
// for i = array downto 1 do
56794: LD_ADDR_VAR 0 3
56798: PUSH
56799: DOUBLE
56800: LD_VAR 0 1
56804: INC
56805: ST_TO_ADDR
56806: LD_INT 1
56808: PUSH
56809: FOR_DOWNTO
56810: IFFALSE 56887
// begin index := rand ( 1 , array ) ;
56812: LD_ADDR_VAR 0 4
56816: PUSH
56817: LD_INT 1
56819: PPUSH
56820: LD_VAR 0 1
56824: PPUSH
56825: CALL_OW 12
56829: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
56830: LD_ADDR_VAR 0 2
56834: PUSH
56835: LD_VAR 0 2
56839: PPUSH
56840: LD_VAR 0 2
56844: PUSH
56845: LD_INT 1
56847: PLUS
56848: PPUSH
56849: LD_VAR 0 1
56853: PUSH
56854: LD_VAR 0 4
56858: ARRAY
56859: PPUSH
56860: CALL_OW 2
56864: ST_TO_ADDR
// array := Delete ( array , index ) ;
56865: LD_ADDR_VAR 0 1
56869: PUSH
56870: LD_VAR 0 1
56874: PPUSH
56875: LD_VAR 0 4
56879: PPUSH
56880: CALL_OW 3
56884: ST_TO_ADDR
// end ;
56885: GO 56809
56887: POP
56888: POP
// end ;
56889: LD_VAR 0 2
56893: RET
// export function GetBaseMaterials ( base ) ; begin
56894: LD_INT 0
56896: PPUSH
// result := [ 0 , 0 , 0 ] ;
56897: LD_ADDR_VAR 0 2
56901: PUSH
56902: LD_INT 0
56904: PUSH
56905: LD_INT 0
56907: PUSH
56908: LD_INT 0
56910: PUSH
56911: EMPTY
56912: LIST
56913: LIST
56914: LIST
56915: ST_TO_ADDR
// if not base then
56916: LD_VAR 0 1
56920: NOT
56921: IFFALSE 56925
// exit ;
56923: GO 56974
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
56925: LD_ADDR_VAR 0 2
56929: PUSH
56930: LD_VAR 0 1
56934: PPUSH
56935: LD_INT 1
56937: PPUSH
56938: CALL_OW 275
56942: PUSH
56943: LD_VAR 0 1
56947: PPUSH
56948: LD_INT 2
56950: PPUSH
56951: CALL_OW 275
56955: PUSH
56956: LD_VAR 0 1
56960: PPUSH
56961: LD_INT 3
56963: PPUSH
56964: CALL_OW 275
56968: PUSH
56969: EMPTY
56970: LIST
56971: LIST
56972: LIST
56973: ST_TO_ADDR
// end ; end_of_file
56974: LD_VAR 0 2
56978: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
56979: LD_INT 0
56981: PPUSH
56982: PPUSH
// skirmish := false ;
56983: LD_ADDR_EXP 56
56987: PUSH
56988: LD_INT 0
56990: ST_TO_ADDR
// debug_mc := false ;
56991: LD_ADDR_EXP 57
56995: PUSH
56996: LD_INT 0
56998: ST_TO_ADDR
// mc_bases := [ ] ;
56999: LD_ADDR_EXP 58
57003: PUSH
57004: EMPTY
57005: ST_TO_ADDR
// mc_sides := [ ] ;
57006: LD_ADDR_EXP 84
57010: PUSH
57011: EMPTY
57012: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57013: LD_ADDR_EXP 59
57017: PUSH
57018: EMPTY
57019: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57020: LD_ADDR_EXP 60
57024: PUSH
57025: EMPTY
57026: ST_TO_ADDR
// mc_need_heal := [ ] ;
57027: LD_ADDR_EXP 61
57031: PUSH
57032: EMPTY
57033: ST_TO_ADDR
// mc_healers := [ ] ;
57034: LD_ADDR_EXP 62
57038: PUSH
57039: EMPTY
57040: ST_TO_ADDR
// mc_build_list := [ ] ;
57041: LD_ADDR_EXP 63
57045: PUSH
57046: EMPTY
57047: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57048: LD_ADDR_EXP 90
57052: PUSH
57053: EMPTY
57054: ST_TO_ADDR
// mc_builders := [ ] ;
57055: LD_ADDR_EXP 64
57059: PUSH
57060: EMPTY
57061: ST_TO_ADDR
// mc_construct_list := [ ] ;
57062: LD_ADDR_EXP 65
57066: PUSH
57067: EMPTY
57068: ST_TO_ADDR
// mc_turret_list := [ ] ;
57069: LD_ADDR_EXP 66
57073: PUSH
57074: EMPTY
57075: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57076: LD_ADDR_EXP 67
57080: PUSH
57081: EMPTY
57082: ST_TO_ADDR
// mc_miners := [ ] ;
57083: LD_ADDR_EXP 72
57087: PUSH
57088: EMPTY
57089: ST_TO_ADDR
// mc_mines := [ ] ;
57090: LD_ADDR_EXP 71
57094: PUSH
57095: EMPTY
57096: ST_TO_ADDR
// mc_minefields := [ ] ;
57097: LD_ADDR_EXP 73
57101: PUSH
57102: EMPTY
57103: ST_TO_ADDR
// mc_crates := [ ] ;
57104: LD_ADDR_EXP 74
57108: PUSH
57109: EMPTY
57110: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57111: LD_ADDR_EXP 75
57115: PUSH
57116: EMPTY
57117: ST_TO_ADDR
// mc_crates_area := [ ] ;
57118: LD_ADDR_EXP 76
57122: PUSH
57123: EMPTY
57124: ST_TO_ADDR
// mc_vehicles := [ ] ;
57125: LD_ADDR_EXP 77
57129: PUSH
57130: EMPTY
57131: ST_TO_ADDR
// mc_attack := [ ] ;
57132: LD_ADDR_EXP 78
57136: PUSH
57137: EMPTY
57138: ST_TO_ADDR
// mc_produce := [ ] ;
57139: LD_ADDR_EXP 79
57143: PUSH
57144: EMPTY
57145: ST_TO_ADDR
// mc_defender := [ ] ;
57146: LD_ADDR_EXP 80
57150: PUSH
57151: EMPTY
57152: ST_TO_ADDR
// mc_parking := [ ] ;
57153: LD_ADDR_EXP 82
57157: PUSH
57158: EMPTY
57159: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57160: LD_ADDR_EXP 68
57164: PUSH
57165: EMPTY
57166: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57167: LD_ADDR_EXP 70
57171: PUSH
57172: EMPTY
57173: ST_TO_ADDR
// mc_scan := [ ] ;
57174: LD_ADDR_EXP 81
57178: PUSH
57179: EMPTY
57180: ST_TO_ADDR
// mc_scan_area := [ ] ;
57181: LD_ADDR_EXP 83
57185: PUSH
57186: EMPTY
57187: ST_TO_ADDR
// mc_tech := [ ] ;
57188: LD_ADDR_EXP 85
57192: PUSH
57193: EMPTY
57194: ST_TO_ADDR
// mc_class := [ ] ;
57195: LD_ADDR_EXP 99
57199: PUSH
57200: EMPTY
57201: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57202: LD_ADDR_EXP 100
57206: PUSH
57207: EMPTY
57208: ST_TO_ADDR
// end ;
57209: LD_VAR 0 1
57213: RET
// export function MC_Kill ( base ) ; begin
57214: LD_INT 0
57216: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57217: LD_ADDR_EXP 58
57221: PUSH
57222: LD_EXP 58
57226: PPUSH
57227: LD_VAR 0 1
57231: PPUSH
57232: EMPTY
57233: PPUSH
57234: CALL_OW 1
57238: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57239: LD_ADDR_EXP 59
57243: PUSH
57244: LD_EXP 59
57248: PPUSH
57249: LD_VAR 0 1
57253: PPUSH
57254: EMPTY
57255: PPUSH
57256: CALL_OW 1
57260: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57261: LD_ADDR_EXP 60
57265: PUSH
57266: LD_EXP 60
57270: PPUSH
57271: LD_VAR 0 1
57275: PPUSH
57276: EMPTY
57277: PPUSH
57278: CALL_OW 1
57282: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57283: LD_ADDR_EXP 61
57287: PUSH
57288: LD_EXP 61
57292: PPUSH
57293: LD_VAR 0 1
57297: PPUSH
57298: EMPTY
57299: PPUSH
57300: CALL_OW 1
57304: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57305: LD_ADDR_EXP 62
57309: PUSH
57310: LD_EXP 62
57314: PPUSH
57315: LD_VAR 0 1
57319: PPUSH
57320: EMPTY
57321: PPUSH
57322: CALL_OW 1
57326: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57327: LD_ADDR_EXP 63
57331: PUSH
57332: LD_EXP 63
57336: PPUSH
57337: LD_VAR 0 1
57341: PPUSH
57342: EMPTY
57343: PPUSH
57344: CALL_OW 1
57348: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57349: LD_ADDR_EXP 64
57353: PUSH
57354: LD_EXP 64
57358: PPUSH
57359: LD_VAR 0 1
57363: PPUSH
57364: EMPTY
57365: PPUSH
57366: CALL_OW 1
57370: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57371: LD_ADDR_EXP 65
57375: PUSH
57376: LD_EXP 65
57380: PPUSH
57381: LD_VAR 0 1
57385: PPUSH
57386: EMPTY
57387: PPUSH
57388: CALL_OW 1
57392: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57393: LD_ADDR_EXP 66
57397: PUSH
57398: LD_EXP 66
57402: PPUSH
57403: LD_VAR 0 1
57407: PPUSH
57408: EMPTY
57409: PPUSH
57410: CALL_OW 1
57414: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57415: LD_ADDR_EXP 67
57419: PUSH
57420: LD_EXP 67
57424: PPUSH
57425: LD_VAR 0 1
57429: PPUSH
57430: EMPTY
57431: PPUSH
57432: CALL_OW 1
57436: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57437: LD_ADDR_EXP 68
57441: PUSH
57442: LD_EXP 68
57446: PPUSH
57447: LD_VAR 0 1
57451: PPUSH
57452: EMPTY
57453: PPUSH
57454: CALL_OW 1
57458: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57459: LD_ADDR_EXP 69
57463: PUSH
57464: LD_EXP 69
57468: PPUSH
57469: LD_VAR 0 1
57473: PPUSH
57474: LD_INT 0
57476: PPUSH
57477: CALL_OW 1
57481: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57482: LD_ADDR_EXP 70
57486: PUSH
57487: LD_EXP 70
57491: PPUSH
57492: LD_VAR 0 1
57496: PPUSH
57497: EMPTY
57498: PPUSH
57499: CALL_OW 1
57503: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57504: LD_ADDR_EXP 71
57508: PUSH
57509: LD_EXP 71
57513: PPUSH
57514: LD_VAR 0 1
57518: PPUSH
57519: EMPTY
57520: PPUSH
57521: CALL_OW 1
57525: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57526: LD_ADDR_EXP 72
57530: PUSH
57531: LD_EXP 72
57535: PPUSH
57536: LD_VAR 0 1
57540: PPUSH
57541: EMPTY
57542: PPUSH
57543: CALL_OW 1
57547: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57548: LD_ADDR_EXP 73
57552: PUSH
57553: LD_EXP 73
57557: PPUSH
57558: LD_VAR 0 1
57562: PPUSH
57563: EMPTY
57564: PPUSH
57565: CALL_OW 1
57569: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57570: LD_ADDR_EXP 74
57574: PUSH
57575: LD_EXP 74
57579: PPUSH
57580: LD_VAR 0 1
57584: PPUSH
57585: EMPTY
57586: PPUSH
57587: CALL_OW 1
57591: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57592: LD_ADDR_EXP 75
57596: PUSH
57597: LD_EXP 75
57601: PPUSH
57602: LD_VAR 0 1
57606: PPUSH
57607: EMPTY
57608: PPUSH
57609: CALL_OW 1
57613: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57614: LD_ADDR_EXP 76
57618: PUSH
57619: LD_EXP 76
57623: PPUSH
57624: LD_VAR 0 1
57628: PPUSH
57629: EMPTY
57630: PPUSH
57631: CALL_OW 1
57635: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57636: LD_ADDR_EXP 77
57640: PUSH
57641: LD_EXP 77
57645: PPUSH
57646: LD_VAR 0 1
57650: PPUSH
57651: EMPTY
57652: PPUSH
57653: CALL_OW 1
57657: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57658: LD_ADDR_EXP 78
57662: PUSH
57663: LD_EXP 78
57667: PPUSH
57668: LD_VAR 0 1
57672: PPUSH
57673: EMPTY
57674: PPUSH
57675: CALL_OW 1
57679: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57680: LD_ADDR_EXP 79
57684: PUSH
57685: LD_EXP 79
57689: PPUSH
57690: LD_VAR 0 1
57694: PPUSH
57695: EMPTY
57696: PPUSH
57697: CALL_OW 1
57701: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57702: LD_ADDR_EXP 80
57706: PUSH
57707: LD_EXP 80
57711: PPUSH
57712: LD_VAR 0 1
57716: PPUSH
57717: EMPTY
57718: PPUSH
57719: CALL_OW 1
57723: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57724: LD_ADDR_EXP 81
57728: PUSH
57729: LD_EXP 81
57733: PPUSH
57734: LD_VAR 0 1
57738: PPUSH
57739: EMPTY
57740: PPUSH
57741: CALL_OW 1
57745: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57746: LD_ADDR_EXP 82
57750: PUSH
57751: LD_EXP 82
57755: PPUSH
57756: LD_VAR 0 1
57760: PPUSH
57761: EMPTY
57762: PPUSH
57763: CALL_OW 1
57767: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57768: LD_ADDR_EXP 83
57772: PUSH
57773: LD_EXP 83
57777: PPUSH
57778: LD_VAR 0 1
57782: PPUSH
57783: EMPTY
57784: PPUSH
57785: CALL_OW 1
57789: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57790: LD_ADDR_EXP 85
57794: PUSH
57795: LD_EXP 85
57799: PPUSH
57800: LD_VAR 0 1
57804: PPUSH
57805: EMPTY
57806: PPUSH
57807: CALL_OW 1
57811: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57812: LD_ADDR_EXP 87
57816: PUSH
57817: LD_EXP 87
57821: PPUSH
57822: LD_VAR 0 1
57826: PPUSH
57827: EMPTY
57828: PPUSH
57829: CALL_OW 1
57833: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57834: LD_ADDR_EXP 88
57838: PUSH
57839: LD_EXP 88
57843: PPUSH
57844: LD_VAR 0 1
57848: PPUSH
57849: EMPTY
57850: PPUSH
57851: CALL_OW 1
57855: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57856: LD_ADDR_EXP 89
57860: PUSH
57861: LD_EXP 89
57865: PPUSH
57866: LD_VAR 0 1
57870: PPUSH
57871: EMPTY
57872: PPUSH
57873: CALL_OW 1
57877: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57878: LD_ADDR_EXP 90
57882: PUSH
57883: LD_EXP 90
57887: PPUSH
57888: LD_VAR 0 1
57892: PPUSH
57893: EMPTY
57894: PPUSH
57895: CALL_OW 1
57899: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57900: LD_ADDR_EXP 91
57904: PUSH
57905: LD_EXP 91
57909: PPUSH
57910: LD_VAR 0 1
57914: PPUSH
57915: EMPTY
57916: PPUSH
57917: CALL_OW 1
57921: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57922: LD_ADDR_EXP 92
57926: PUSH
57927: LD_EXP 92
57931: PPUSH
57932: LD_VAR 0 1
57936: PPUSH
57937: EMPTY
57938: PPUSH
57939: CALL_OW 1
57943: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
57944: LD_ADDR_EXP 93
57948: PUSH
57949: LD_EXP 93
57953: PPUSH
57954: LD_VAR 0 1
57958: PPUSH
57959: EMPTY
57960: PPUSH
57961: CALL_OW 1
57965: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
57966: LD_ADDR_EXP 94
57970: PUSH
57971: LD_EXP 94
57975: PPUSH
57976: LD_VAR 0 1
57980: PPUSH
57981: EMPTY
57982: PPUSH
57983: CALL_OW 1
57987: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
57988: LD_ADDR_EXP 95
57992: PUSH
57993: LD_EXP 95
57997: PPUSH
57998: LD_VAR 0 1
58002: PPUSH
58003: EMPTY
58004: PPUSH
58005: CALL_OW 1
58009: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58010: LD_ADDR_EXP 96
58014: PUSH
58015: LD_EXP 96
58019: PPUSH
58020: LD_VAR 0 1
58024: PPUSH
58025: EMPTY
58026: PPUSH
58027: CALL_OW 1
58031: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58032: LD_ADDR_EXP 97
58036: PUSH
58037: LD_EXP 97
58041: PPUSH
58042: LD_VAR 0 1
58046: PPUSH
58047: EMPTY
58048: PPUSH
58049: CALL_OW 1
58053: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58054: LD_ADDR_EXP 98
58058: PUSH
58059: LD_EXP 98
58063: PPUSH
58064: LD_VAR 0 1
58068: PPUSH
58069: EMPTY
58070: PPUSH
58071: CALL_OW 1
58075: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58076: LD_ADDR_EXP 99
58080: PUSH
58081: LD_EXP 99
58085: PPUSH
58086: LD_VAR 0 1
58090: PPUSH
58091: EMPTY
58092: PPUSH
58093: CALL_OW 1
58097: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58098: LD_ADDR_EXP 100
58102: PUSH
58103: LD_EXP 100
58107: PPUSH
58108: LD_VAR 0 1
58112: PPUSH
58113: LD_INT 0
58115: PPUSH
58116: CALL_OW 1
58120: ST_TO_ADDR
// end ;
58121: LD_VAR 0 2
58125: RET
// export function MC_Add ( side , units ) ; var base ; begin
58126: LD_INT 0
58128: PPUSH
58129: PPUSH
// base := mc_bases + 1 ;
58130: LD_ADDR_VAR 0 4
58134: PUSH
58135: LD_EXP 58
58139: PUSH
58140: LD_INT 1
58142: PLUS
58143: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58144: LD_ADDR_EXP 84
58148: PUSH
58149: LD_EXP 84
58153: PPUSH
58154: LD_VAR 0 4
58158: PPUSH
58159: LD_VAR 0 1
58163: PPUSH
58164: CALL_OW 1
58168: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58169: LD_ADDR_EXP 58
58173: PUSH
58174: LD_EXP 58
58178: PPUSH
58179: LD_VAR 0 4
58183: PPUSH
58184: LD_VAR 0 2
58188: PPUSH
58189: CALL_OW 1
58193: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58194: LD_ADDR_EXP 59
58198: PUSH
58199: LD_EXP 59
58203: PPUSH
58204: LD_VAR 0 4
58208: PPUSH
58209: EMPTY
58210: PPUSH
58211: CALL_OW 1
58215: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58216: LD_ADDR_EXP 60
58220: PUSH
58221: LD_EXP 60
58225: PPUSH
58226: LD_VAR 0 4
58230: PPUSH
58231: EMPTY
58232: PPUSH
58233: CALL_OW 1
58237: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58238: LD_ADDR_EXP 61
58242: PUSH
58243: LD_EXP 61
58247: PPUSH
58248: LD_VAR 0 4
58252: PPUSH
58253: EMPTY
58254: PPUSH
58255: CALL_OW 1
58259: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58260: LD_ADDR_EXP 62
58264: PUSH
58265: LD_EXP 62
58269: PPUSH
58270: LD_VAR 0 4
58274: PPUSH
58275: EMPTY
58276: PPUSH
58277: CALL_OW 1
58281: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58282: LD_ADDR_EXP 63
58286: PUSH
58287: LD_EXP 63
58291: PPUSH
58292: LD_VAR 0 4
58296: PPUSH
58297: EMPTY
58298: PPUSH
58299: CALL_OW 1
58303: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58304: LD_ADDR_EXP 64
58308: PUSH
58309: LD_EXP 64
58313: PPUSH
58314: LD_VAR 0 4
58318: PPUSH
58319: EMPTY
58320: PPUSH
58321: CALL_OW 1
58325: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58326: LD_ADDR_EXP 65
58330: PUSH
58331: LD_EXP 65
58335: PPUSH
58336: LD_VAR 0 4
58340: PPUSH
58341: EMPTY
58342: PPUSH
58343: CALL_OW 1
58347: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58348: LD_ADDR_EXP 66
58352: PUSH
58353: LD_EXP 66
58357: PPUSH
58358: LD_VAR 0 4
58362: PPUSH
58363: EMPTY
58364: PPUSH
58365: CALL_OW 1
58369: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58370: LD_ADDR_EXP 67
58374: PUSH
58375: LD_EXP 67
58379: PPUSH
58380: LD_VAR 0 4
58384: PPUSH
58385: EMPTY
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58392: LD_ADDR_EXP 68
58396: PUSH
58397: LD_EXP 68
58401: PPUSH
58402: LD_VAR 0 4
58406: PPUSH
58407: EMPTY
58408: PPUSH
58409: CALL_OW 1
58413: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58414: LD_ADDR_EXP 69
58418: PUSH
58419: LD_EXP 69
58423: PPUSH
58424: LD_VAR 0 4
58428: PPUSH
58429: LD_INT 0
58431: PPUSH
58432: CALL_OW 1
58436: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58437: LD_ADDR_EXP 70
58441: PUSH
58442: LD_EXP 70
58446: PPUSH
58447: LD_VAR 0 4
58451: PPUSH
58452: EMPTY
58453: PPUSH
58454: CALL_OW 1
58458: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58459: LD_ADDR_EXP 71
58463: PUSH
58464: LD_EXP 71
58468: PPUSH
58469: LD_VAR 0 4
58473: PPUSH
58474: EMPTY
58475: PPUSH
58476: CALL_OW 1
58480: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58481: LD_ADDR_EXP 72
58485: PUSH
58486: LD_EXP 72
58490: PPUSH
58491: LD_VAR 0 4
58495: PPUSH
58496: EMPTY
58497: PPUSH
58498: CALL_OW 1
58502: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58503: LD_ADDR_EXP 73
58507: PUSH
58508: LD_EXP 73
58512: PPUSH
58513: LD_VAR 0 4
58517: PPUSH
58518: EMPTY
58519: PPUSH
58520: CALL_OW 1
58524: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58525: LD_ADDR_EXP 74
58529: PUSH
58530: LD_EXP 74
58534: PPUSH
58535: LD_VAR 0 4
58539: PPUSH
58540: EMPTY
58541: PPUSH
58542: CALL_OW 1
58546: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58547: LD_ADDR_EXP 75
58551: PUSH
58552: LD_EXP 75
58556: PPUSH
58557: LD_VAR 0 4
58561: PPUSH
58562: EMPTY
58563: PPUSH
58564: CALL_OW 1
58568: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58569: LD_ADDR_EXP 76
58573: PUSH
58574: LD_EXP 76
58578: PPUSH
58579: LD_VAR 0 4
58583: PPUSH
58584: EMPTY
58585: PPUSH
58586: CALL_OW 1
58590: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58591: LD_ADDR_EXP 77
58595: PUSH
58596: LD_EXP 77
58600: PPUSH
58601: LD_VAR 0 4
58605: PPUSH
58606: EMPTY
58607: PPUSH
58608: CALL_OW 1
58612: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58613: LD_ADDR_EXP 78
58617: PUSH
58618: LD_EXP 78
58622: PPUSH
58623: LD_VAR 0 4
58627: PPUSH
58628: EMPTY
58629: PPUSH
58630: CALL_OW 1
58634: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58635: LD_ADDR_EXP 79
58639: PUSH
58640: LD_EXP 79
58644: PPUSH
58645: LD_VAR 0 4
58649: PPUSH
58650: EMPTY
58651: PPUSH
58652: CALL_OW 1
58656: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58657: LD_ADDR_EXP 80
58661: PUSH
58662: LD_EXP 80
58666: PPUSH
58667: LD_VAR 0 4
58671: PPUSH
58672: EMPTY
58673: PPUSH
58674: CALL_OW 1
58678: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58679: LD_ADDR_EXP 81
58683: PUSH
58684: LD_EXP 81
58688: PPUSH
58689: LD_VAR 0 4
58693: PPUSH
58694: EMPTY
58695: PPUSH
58696: CALL_OW 1
58700: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58701: LD_ADDR_EXP 82
58705: PUSH
58706: LD_EXP 82
58710: PPUSH
58711: LD_VAR 0 4
58715: PPUSH
58716: EMPTY
58717: PPUSH
58718: CALL_OW 1
58722: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58723: LD_ADDR_EXP 83
58727: PUSH
58728: LD_EXP 83
58732: PPUSH
58733: LD_VAR 0 4
58737: PPUSH
58738: EMPTY
58739: PPUSH
58740: CALL_OW 1
58744: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58745: LD_ADDR_EXP 85
58749: PUSH
58750: LD_EXP 85
58754: PPUSH
58755: LD_VAR 0 4
58759: PPUSH
58760: EMPTY
58761: PPUSH
58762: CALL_OW 1
58766: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58767: LD_ADDR_EXP 87
58771: PUSH
58772: LD_EXP 87
58776: PPUSH
58777: LD_VAR 0 4
58781: PPUSH
58782: EMPTY
58783: PPUSH
58784: CALL_OW 1
58788: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58789: LD_ADDR_EXP 88
58793: PUSH
58794: LD_EXP 88
58798: PPUSH
58799: LD_VAR 0 4
58803: PPUSH
58804: EMPTY
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58811: LD_ADDR_EXP 89
58815: PUSH
58816: LD_EXP 89
58820: PPUSH
58821: LD_VAR 0 4
58825: PPUSH
58826: EMPTY
58827: PPUSH
58828: CALL_OW 1
58832: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58833: LD_ADDR_EXP 90
58837: PUSH
58838: LD_EXP 90
58842: PPUSH
58843: LD_VAR 0 4
58847: PPUSH
58848: EMPTY
58849: PPUSH
58850: CALL_OW 1
58854: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58855: LD_ADDR_EXP 91
58859: PUSH
58860: LD_EXP 91
58864: PPUSH
58865: LD_VAR 0 4
58869: PPUSH
58870: EMPTY
58871: PPUSH
58872: CALL_OW 1
58876: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58877: LD_ADDR_EXP 92
58881: PUSH
58882: LD_EXP 92
58886: PPUSH
58887: LD_VAR 0 4
58891: PPUSH
58892: EMPTY
58893: PPUSH
58894: CALL_OW 1
58898: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58899: LD_ADDR_EXP 93
58903: PUSH
58904: LD_EXP 93
58908: PPUSH
58909: LD_VAR 0 4
58913: PPUSH
58914: EMPTY
58915: PPUSH
58916: CALL_OW 1
58920: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58921: LD_ADDR_EXP 94
58925: PUSH
58926: LD_EXP 94
58930: PPUSH
58931: LD_VAR 0 4
58935: PPUSH
58936: EMPTY
58937: PPUSH
58938: CALL_OW 1
58942: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58943: LD_ADDR_EXP 95
58947: PUSH
58948: LD_EXP 95
58952: PPUSH
58953: LD_VAR 0 4
58957: PPUSH
58958: EMPTY
58959: PPUSH
58960: CALL_OW 1
58964: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58965: LD_ADDR_EXP 96
58969: PUSH
58970: LD_EXP 96
58974: PPUSH
58975: LD_VAR 0 4
58979: PPUSH
58980: EMPTY
58981: PPUSH
58982: CALL_OW 1
58986: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58987: LD_ADDR_EXP 97
58991: PUSH
58992: LD_EXP 97
58996: PPUSH
58997: LD_VAR 0 4
59001: PPUSH
59002: EMPTY
59003: PPUSH
59004: CALL_OW 1
59008: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59009: LD_ADDR_EXP 98
59013: PUSH
59014: LD_EXP 98
59018: PPUSH
59019: LD_VAR 0 4
59023: PPUSH
59024: EMPTY
59025: PPUSH
59026: CALL_OW 1
59030: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59031: LD_ADDR_EXP 99
59035: PUSH
59036: LD_EXP 99
59040: PPUSH
59041: LD_VAR 0 4
59045: PPUSH
59046: EMPTY
59047: PPUSH
59048: CALL_OW 1
59052: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59053: LD_ADDR_EXP 100
59057: PUSH
59058: LD_EXP 100
59062: PPUSH
59063: LD_VAR 0 4
59067: PPUSH
59068: LD_INT 0
59070: PPUSH
59071: CALL_OW 1
59075: ST_TO_ADDR
// result := base ;
59076: LD_ADDR_VAR 0 3
59080: PUSH
59081: LD_VAR 0 4
59085: ST_TO_ADDR
// end ;
59086: LD_VAR 0 3
59090: RET
// export function MC_Start ( ) ; var i ; begin
59091: LD_INT 0
59093: PPUSH
59094: PPUSH
// for i = 1 to mc_bases do
59095: LD_ADDR_VAR 0 2
59099: PUSH
59100: DOUBLE
59101: LD_INT 1
59103: DEC
59104: ST_TO_ADDR
59105: LD_EXP 58
59109: PUSH
59110: FOR_TO
59111: IFFALSE 60188
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59113: LD_ADDR_EXP 58
59117: PUSH
59118: LD_EXP 58
59122: PPUSH
59123: LD_VAR 0 2
59127: PPUSH
59128: LD_EXP 58
59132: PUSH
59133: LD_VAR 0 2
59137: ARRAY
59138: PUSH
59139: LD_INT 0
59141: DIFF
59142: PPUSH
59143: CALL_OW 1
59147: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59148: LD_ADDR_EXP 59
59152: PUSH
59153: LD_EXP 59
59157: PPUSH
59158: LD_VAR 0 2
59162: PPUSH
59163: EMPTY
59164: PPUSH
59165: CALL_OW 1
59169: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59170: LD_ADDR_EXP 60
59174: PUSH
59175: LD_EXP 60
59179: PPUSH
59180: LD_VAR 0 2
59184: PPUSH
59185: EMPTY
59186: PPUSH
59187: CALL_OW 1
59191: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59192: LD_ADDR_EXP 61
59196: PUSH
59197: LD_EXP 61
59201: PPUSH
59202: LD_VAR 0 2
59206: PPUSH
59207: EMPTY
59208: PPUSH
59209: CALL_OW 1
59213: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59214: LD_ADDR_EXP 62
59218: PUSH
59219: LD_EXP 62
59223: PPUSH
59224: LD_VAR 0 2
59228: PPUSH
59229: EMPTY
59230: PUSH
59231: EMPTY
59232: PUSH
59233: EMPTY
59234: LIST
59235: LIST
59236: PPUSH
59237: CALL_OW 1
59241: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59242: LD_ADDR_EXP 63
59246: PUSH
59247: LD_EXP 63
59251: PPUSH
59252: LD_VAR 0 2
59256: PPUSH
59257: EMPTY
59258: PPUSH
59259: CALL_OW 1
59263: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59264: LD_ADDR_EXP 90
59268: PUSH
59269: LD_EXP 90
59273: PPUSH
59274: LD_VAR 0 2
59278: PPUSH
59279: EMPTY
59280: PPUSH
59281: CALL_OW 1
59285: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59286: LD_ADDR_EXP 64
59290: PUSH
59291: LD_EXP 64
59295: PPUSH
59296: LD_VAR 0 2
59300: PPUSH
59301: EMPTY
59302: PPUSH
59303: CALL_OW 1
59307: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59308: LD_ADDR_EXP 65
59312: PUSH
59313: LD_EXP 65
59317: PPUSH
59318: LD_VAR 0 2
59322: PPUSH
59323: EMPTY
59324: PPUSH
59325: CALL_OW 1
59329: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59330: LD_ADDR_EXP 66
59334: PUSH
59335: LD_EXP 66
59339: PPUSH
59340: LD_VAR 0 2
59344: PPUSH
59345: LD_EXP 58
59349: PUSH
59350: LD_VAR 0 2
59354: ARRAY
59355: PPUSH
59356: LD_INT 2
59358: PUSH
59359: LD_INT 30
59361: PUSH
59362: LD_INT 32
59364: PUSH
59365: EMPTY
59366: LIST
59367: LIST
59368: PUSH
59369: LD_INT 30
59371: PUSH
59372: LD_INT 33
59374: PUSH
59375: EMPTY
59376: LIST
59377: LIST
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: PPUSH
59384: CALL_OW 72
59388: PPUSH
59389: CALL_OW 1
59393: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59394: LD_ADDR_EXP 67
59398: PUSH
59399: LD_EXP 67
59403: PPUSH
59404: LD_VAR 0 2
59408: PPUSH
59409: LD_EXP 58
59413: PUSH
59414: LD_VAR 0 2
59418: ARRAY
59419: PPUSH
59420: LD_INT 2
59422: PUSH
59423: LD_INT 30
59425: PUSH
59426: LD_INT 32
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: PUSH
59433: LD_INT 30
59435: PUSH
59436: LD_INT 31
59438: PUSH
59439: EMPTY
59440: LIST
59441: LIST
59442: PUSH
59443: EMPTY
59444: LIST
59445: LIST
59446: LIST
59447: PUSH
59448: LD_INT 58
59450: PUSH
59451: EMPTY
59452: LIST
59453: PUSH
59454: EMPTY
59455: LIST
59456: LIST
59457: PPUSH
59458: CALL_OW 72
59462: PPUSH
59463: CALL_OW 1
59467: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59468: LD_ADDR_EXP 68
59472: PUSH
59473: LD_EXP 68
59477: PPUSH
59478: LD_VAR 0 2
59482: PPUSH
59483: EMPTY
59484: PPUSH
59485: CALL_OW 1
59489: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59490: LD_ADDR_EXP 72
59494: PUSH
59495: LD_EXP 72
59499: PPUSH
59500: LD_VAR 0 2
59504: PPUSH
59505: EMPTY
59506: PPUSH
59507: CALL_OW 1
59511: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59512: LD_ADDR_EXP 71
59516: PUSH
59517: LD_EXP 71
59521: PPUSH
59522: LD_VAR 0 2
59526: PPUSH
59527: EMPTY
59528: PPUSH
59529: CALL_OW 1
59533: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59534: LD_ADDR_EXP 73
59538: PUSH
59539: LD_EXP 73
59543: PPUSH
59544: LD_VAR 0 2
59548: PPUSH
59549: EMPTY
59550: PPUSH
59551: CALL_OW 1
59555: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59556: LD_ADDR_EXP 74
59560: PUSH
59561: LD_EXP 74
59565: PPUSH
59566: LD_VAR 0 2
59570: PPUSH
59571: EMPTY
59572: PPUSH
59573: CALL_OW 1
59577: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59578: LD_ADDR_EXP 75
59582: PUSH
59583: LD_EXP 75
59587: PPUSH
59588: LD_VAR 0 2
59592: PPUSH
59593: EMPTY
59594: PPUSH
59595: CALL_OW 1
59599: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59600: LD_ADDR_EXP 76
59604: PUSH
59605: LD_EXP 76
59609: PPUSH
59610: LD_VAR 0 2
59614: PPUSH
59615: EMPTY
59616: PPUSH
59617: CALL_OW 1
59621: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59622: LD_ADDR_EXP 77
59626: PUSH
59627: LD_EXP 77
59631: PPUSH
59632: LD_VAR 0 2
59636: PPUSH
59637: EMPTY
59638: PPUSH
59639: CALL_OW 1
59643: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59644: LD_ADDR_EXP 78
59648: PUSH
59649: LD_EXP 78
59653: PPUSH
59654: LD_VAR 0 2
59658: PPUSH
59659: EMPTY
59660: PPUSH
59661: CALL_OW 1
59665: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59666: LD_ADDR_EXP 79
59670: PUSH
59671: LD_EXP 79
59675: PPUSH
59676: LD_VAR 0 2
59680: PPUSH
59681: EMPTY
59682: PPUSH
59683: CALL_OW 1
59687: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59688: LD_ADDR_EXP 80
59692: PUSH
59693: LD_EXP 80
59697: PPUSH
59698: LD_VAR 0 2
59702: PPUSH
59703: EMPTY
59704: PPUSH
59705: CALL_OW 1
59709: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59710: LD_ADDR_EXP 69
59714: PUSH
59715: LD_EXP 69
59719: PPUSH
59720: LD_VAR 0 2
59724: PPUSH
59725: LD_INT 0
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59733: LD_ADDR_EXP 82
59737: PUSH
59738: LD_EXP 82
59742: PPUSH
59743: LD_VAR 0 2
59747: PPUSH
59748: LD_INT 0
59750: PPUSH
59751: CALL_OW 1
59755: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59756: LD_ADDR_EXP 70
59760: PUSH
59761: LD_EXP 70
59765: PPUSH
59766: LD_VAR 0 2
59770: PPUSH
59771: EMPTY
59772: PPUSH
59773: CALL_OW 1
59777: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59778: LD_ADDR_EXP 81
59782: PUSH
59783: LD_EXP 81
59787: PPUSH
59788: LD_VAR 0 2
59792: PPUSH
59793: LD_INT 0
59795: PPUSH
59796: CALL_OW 1
59800: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59801: LD_ADDR_EXP 83
59805: PUSH
59806: LD_EXP 83
59810: PPUSH
59811: LD_VAR 0 2
59815: PPUSH
59816: EMPTY
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59823: LD_ADDR_EXP 86
59827: PUSH
59828: LD_EXP 86
59832: PPUSH
59833: LD_VAR 0 2
59837: PPUSH
59838: LD_INT 0
59840: PPUSH
59841: CALL_OW 1
59845: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59846: LD_ADDR_EXP 87
59850: PUSH
59851: LD_EXP 87
59855: PPUSH
59856: LD_VAR 0 2
59860: PPUSH
59861: EMPTY
59862: PPUSH
59863: CALL_OW 1
59867: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59868: LD_ADDR_EXP 88
59872: PUSH
59873: LD_EXP 88
59877: PPUSH
59878: LD_VAR 0 2
59882: PPUSH
59883: EMPTY
59884: PPUSH
59885: CALL_OW 1
59889: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59890: LD_ADDR_EXP 89
59894: PUSH
59895: LD_EXP 89
59899: PPUSH
59900: LD_VAR 0 2
59904: PPUSH
59905: EMPTY
59906: PPUSH
59907: CALL_OW 1
59911: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
59912: LD_ADDR_EXP 91
59916: PUSH
59917: LD_EXP 91
59921: PPUSH
59922: LD_VAR 0 2
59926: PPUSH
59927: LD_EXP 58
59931: PUSH
59932: LD_VAR 0 2
59936: ARRAY
59937: PPUSH
59938: LD_INT 2
59940: PUSH
59941: LD_INT 30
59943: PUSH
59944: LD_INT 6
59946: PUSH
59947: EMPTY
59948: LIST
59949: LIST
59950: PUSH
59951: LD_INT 30
59953: PUSH
59954: LD_INT 7
59956: PUSH
59957: EMPTY
59958: LIST
59959: LIST
59960: PUSH
59961: LD_INT 30
59963: PUSH
59964: LD_INT 8
59966: PUSH
59967: EMPTY
59968: LIST
59969: LIST
59970: PUSH
59971: EMPTY
59972: LIST
59973: LIST
59974: LIST
59975: LIST
59976: PPUSH
59977: CALL_OW 72
59981: PPUSH
59982: CALL_OW 1
59986: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
59987: LD_ADDR_EXP 92
59991: PUSH
59992: LD_EXP 92
59996: PPUSH
59997: LD_VAR 0 2
60001: PPUSH
60002: EMPTY
60003: PPUSH
60004: CALL_OW 1
60008: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60009: LD_ADDR_EXP 93
60013: PUSH
60014: LD_EXP 93
60018: PPUSH
60019: LD_VAR 0 2
60023: PPUSH
60024: EMPTY
60025: PPUSH
60026: CALL_OW 1
60030: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60031: LD_ADDR_EXP 94
60035: PUSH
60036: LD_EXP 94
60040: PPUSH
60041: LD_VAR 0 2
60045: PPUSH
60046: EMPTY
60047: PPUSH
60048: CALL_OW 1
60052: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60053: LD_ADDR_EXP 95
60057: PUSH
60058: LD_EXP 95
60062: PPUSH
60063: LD_VAR 0 2
60067: PPUSH
60068: EMPTY
60069: PPUSH
60070: CALL_OW 1
60074: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60075: LD_ADDR_EXP 96
60079: PUSH
60080: LD_EXP 96
60084: PPUSH
60085: LD_VAR 0 2
60089: PPUSH
60090: EMPTY
60091: PPUSH
60092: CALL_OW 1
60096: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60097: LD_ADDR_EXP 97
60101: PUSH
60102: LD_EXP 97
60106: PPUSH
60107: LD_VAR 0 2
60111: PPUSH
60112: EMPTY
60113: PPUSH
60114: CALL_OW 1
60118: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60119: LD_ADDR_EXP 98
60123: PUSH
60124: LD_EXP 98
60128: PPUSH
60129: LD_VAR 0 2
60133: PPUSH
60134: EMPTY
60135: PPUSH
60136: CALL_OW 1
60140: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60141: LD_ADDR_EXP 99
60145: PUSH
60146: LD_EXP 99
60150: PPUSH
60151: LD_VAR 0 2
60155: PPUSH
60156: EMPTY
60157: PPUSH
60158: CALL_OW 1
60162: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60163: LD_ADDR_EXP 100
60167: PUSH
60168: LD_EXP 100
60172: PPUSH
60173: LD_VAR 0 2
60177: PPUSH
60178: LD_INT 0
60180: PPUSH
60181: CALL_OW 1
60185: ST_TO_ADDR
// end ;
60186: GO 59110
60188: POP
60189: POP
// MC_InitSides ( ) ;
60190: CALL 60476 0 0
// MC_InitResearch ( ) ;
60194: CALL 60215 0 0
// CustomInitMacro ( ) ;
60198: CALL 181 0 0
// skirmish := true ;
60202: LD_ADDR_EXP 56
60206: PUSH
60207: LD_INT 1
60209: ST_TO_ADDR
// end ;
60210: LD_VAR 0 1
60214: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60215: LD_INT 0
60217: PPUSH
60218: PPUSH
60219: PPUSH
60220: PPUSH
60221: PPUSH
60222: PPUSH
// if not mc_bases then
60223: LD_EXP 58
60227: NOT
60228: IFFALSE 60232
// exit ;
60230: GO 60471
// for i = 1 to 8 do
60232: LD_ADDR_VAR 0 2
60236: PUSH
60237: DOUBLE
60238: LD_INT 1
60240: DEC
60241: ST_TO_ADDR
60242: LD_INT 8
60244: PUSH
60245: FOR_TO
60246: IFFALSE 60272
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60248: LD_ADDR_EXP 85
60252: PUSH
60253: LD_EXP 85
60257: PPUSH
60258: LD_VAR 0 2
60262: PPUSH
60263: EMPTY
60264: PPUSH
60265: CALL_OW 1
60269: ST_TO_ADDR
60270: GO 60245
60272: POP
60273: POP
// tmp := [ ] ;
60274: LD_ADDR_VAR 0 5
60278: PUSH
60279: EMPTY
60280: ST_TO_ADDR
// for i = 1 to mc_sides do
60281: LD_ADDR_VAR 0 2
60285: PUSH
60286: DOUBLE
60287: LD_INT 1
60289: DEC
60290: ST_TO_ADDR
60291: LD_EXP 84
60295: PUSH
60296: FOR_TO
60297: IFFALSE 60355
// if not mc_sides [ i ] in tmp then
60299: LD_EXP 84
60303: PUSH
60304: LD_VAR 0 2
60308: ARRAY
60309: PUSH
60310: LD_VAR 0 5
60314: IN
60315: NOT
60316: IFFALSE 60353
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60318: LD_ADDR_VAR 0 5
60322: PUSH
60323: LD_VAR 0 5
60327: PPUSH
60328: LD_VAR 0 5
60332: PUSH
60333: LD_INT 1
60335: PLUS
60336: PPUSH
60337: LD_EXP 84
60341: PUSH
60342: LD_VAR 0 2
60346: ARRAY
60347: PPUSH
60348: CALL_OW 2
60352: ST_TO_ADDR
60353: GO 60296
60355: POP
60356: POP
// if not tmp then
60357: LD_VAR 0 5
60361: NOT
60362: IFFALSE 60366
// exit ;
60364: GO 60471
// for j in tmp do
60366: LD_ADDR_VAR 0 3
60370: PUSH
60371: LD_VAR 0 5
60375: PUSH
60376: FOR_IN
60377: IFFALSE 60469
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60379: LD_ADDR_VAR 0 6
60383: PUSH
60384: LD_INT 22
60386: PUSH
60387: LD_VAR 0 3
60391: PUSH
60392: EMPTY
60393: LIST
60394: LIST
60395: PPUSH
60396: CALL_OW 69
60400: ST_TO_ADDR
// if not un then
60401: LD_VAR 0 6
60405: NOT
60406: IFFALSE 60410
// continue ;
60408: GO 60376
// nation := GetNation ( un [ 1 ] ) ;
60410: LD_ADDR_VAR 0 4
60414: PUSH
60415: LD_VAR 0 6
60419: PUSH
60420: LD_INT 1
60422: ARRAY
60423: PPUSH
60424: CALL_OW 248
60428: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60429: LD_ADDR_EXP 85
60433: PUSH
60434: LD_EXP 85
60438: PPUSH
60439: LD_VAR 0 3
60443: PPUSH
60444: LD_VAR 0 3
60448: PPUSH
60449: LD_VAR 0 4
60453: PPUSH
60454: LD_INT 1
60456: PPUSH
60457: CALL 14029 0 3
60461: PPUSH
60462: CALL_OW 1
60466: ST_TO_ADDR
// end ;
60467: GO 60376
60469: POP
60470: POP
// end ;
60471: LD_VAR 0 1
60475: RET
// export function MC_InitSides ( ) ; var i ; begin
60476: LD_INT 0
60478: PPUSH
60479: PPUSH
// if not mc_bases then
60480: LD_EXP 58
60484: NOT
60485: IFFALSE 60489
// exit ;
60487: GO 60563
// for i = 1 to mc_bases do
60489: LD_ADDR_VAR 0 2
60493: PUSH
60494: DOUBLE
60495: LD_INT 1
60497: DEC
60498: ST_TO_ADDR
60499: LD_EXP 58
60503: PUSH
60504: FOR_TO
60505: IFFALSE 60561
// if mc_bases [ i ] then
60507: LD_EXP 58
60511: PUSH
60512: LD_VAR 0 2
60516: ARRAY
60517: IFFALSE 60559
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60519: LD_ADDR_EXP 84
60523: PUSH
60524: LD_EXP 84
60528: PPUSH
60529: LD_VAR 0 2
60533: PPUSH
60534: LD_EXP 58
60538: PUSH
60539: LD_VAR 0 2
60543: ARRAY
60544: PUSH
60545: LD_INT 1
60547: ARRAY
60548: PPUSH
60549: CALL_OW 255
60553: PPUSH
60554: CALL_OW 1
60558: ST_TO_ADDR
60559: GO 60504
60561: POP
60562: POP
// end ;
60563: LD_VAR 0 1
60567: RET
// every 0 0$01 trigger skirmish do
60568: LD_EXP 56
60572: IFFALSE 60726
60574: GO 60576
60576: DISABLE
// begin enable ;
60577: ENABLE
// MC_CheckBuildings ( ) ;
60578: CALL 65224 0 0
// MC_CheckPeopleLife ( ) ;
60582: CALL 65349 0 0
// RaiseSailEvent ( 100 ) ;
60586: LD_INT 100
60588: PPUSH
60589: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60593: LD_INT 103
60595: PPUSH
60596: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60600: LD_INT 104
60602: PPUSH
60603: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60607: LD_INT 105
60609: PPUSH
60610: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60614: LD_INT 106
60616: PPUSH
60617: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60621: LD_INT 107
60623: PPUSH
60624: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60628: LD_INT 108
60630: PPUSH
60631: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60635: LD_INT 109
60637: PPUSH
60638: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60642: LD_INT 110
60644: PPUSH
60645: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60649: LD_INT 111
60651: PPUSH
60652: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60656: LD_INT 112
60658: PPUSH
60659: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60663: LD_INT 113
60665: PPUSH
60666: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60670: LD_INT 120
60672: PPUSH
60673: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60677: LD_INT 121
60679: PPUSH
60680: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60684: LD_INT 122
60686: PPUSH
60687: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60691: LD_INT 123
60693: PPUSH
60694: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60698: LD_INT 124
60700: PPUSH
60701: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60705: LD_INT 125
60707: PPUSH
60708: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60712: LD_INT 126
60714: PPUSH
60715: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60719: LD_INT 200
60721: PPUSH
60722: CALL_OW 427
// end ;
60726: END
// on SailEvent ( event ) do begin if event < 100 then
60727: LD_VAR 0 1
60731: PUSH
60732: LD_INT 100
60734: LESS
60735: IFFALSE 60746
// CustomEvent ( event ) ;
60737: LD_VAR 0 1
60741: PPUSH
60742: CALL 12731 0 1
// if event = 100 then
60746: LD_VAR 0 1
60750: PUSH
60751: LD_INT 100
60753: EQUAL
60754: IFFALSE 60760
// MC_ClassManager ( ) ;
60756: CALL 61152 0 0
// if event = 101 then
60760: LD_VAR 0 1
60764: PUSH
60765: LD_INT 101
60767: EQUAL
60768: IFFALSE 60774
// MC_RepairBuildings ( ) ;
60770: CALL 65945 0 0
// if event = 102 then
60774: LD_VAR 0 1
60778: PUSH
60779: LD_INT 102
60781: EQUAL
60782: IFFALSE 60788
// MC_Heal ( ) ;
60784: CALL 66677 0 0
// if event = 103 then
60788: LD_VAR 0 1
60792: PUSH
60793: LD_INT 103
60795: EQUAL
60796: IFFALSE 60802
// MC_Build ( ) ;
60798: CALL 67099 0 0
// if event = 104 then
60802: LD_VAR 0 1
60806: PUSH
60807: LD_INT 104
60809: EQUAL
60810: IFFALSE 60816
// MC_TurretWeapon ( ) ;
60812: CALL 68712 0 0
// if event = 105 then
60816: LD_VAR 0 1
60820: PUSH
60821: LD_INT 105
60823: EQUAL
60824: IFFALSE 60830
// MC_BuildUpgrade ( ) ;
60826: CALL 68263 0 0
// if event = 106 then
60830: LD_VAR 0 1
60834: PUSH
60835: LD_INT 106
60837: EQUAL
60838: IFFALSE 60844
// MC_PlantMines ( ) ;
60840: CALL 69142 0 0
// if event = 107 then
60844: LD_VAR 0 1
60848: PUSH
60849: LD_INT 107
60851: EQUAL
60852: IFFALSE 60858
// MC_CollectCrates ( ) ;
60854: CALL 70176 0 0
// if event = 108 then
60858: LD_VAR 0 1
60862: PUSH
60863: LD_INT 108
60865: EQUAL
60866: IFFALSE 60872
// MC_LinkRemoteControl ( ) ;
60868: CALL 71952 0 0
// if event = 109 then
60872: LD_VAR 0 1
60876: PUSH
60877: LD_INT 109
60879: EQUAL
60880: IFFALSE 60886
// MC_ProduceVehicle ( ) ;
60882: CALL 72133 0 0
// if event = 110 then
60886: LD_VAR 0 1
60890: PUSH
60891: LD_INT 110
60893: EQUAL
60894: IFFALSE 60900
// MC_SendAttack ( ) ;
60896: CALL 72599 0 0
// if event = 111 then
60900: LD_VAR 0 1
60904: PUSH
60905: LD_INT 111
60907: EQUAL
60908: IFFALSE 60914
// MC_Defend ( ) ;
60910: CALL 72707 0 0
// if event = 112 then
60914: LD_VAR 0 1
60918: PUSH
60919: LD_INT 112
60921: EQUAL
60922: IFFALSE 60928
// MC_Research ( ) ;
60924: CALL 73312 0 0
// if event = 113 then
60928: LD_VAR 0 1
60932: PUSH
60933: LD_INT 113
60935: EQUAL
60936: IFFALSE 60942
// MC_MinesTrigger ( ) ;
60938: CALL 74426 0 0
// if event = 120 then
60942: LD_VAR 0 1
60946: PUSH
60947: LD_INT 120
60949: EQUAL
60950: IFFALSE 60956
// MC_RepairVehicle ( ) ;
60952: CALL 74525 0 0
// if event = 121 then
60956: LD_VAR 0 1
60960: PUSH
60961: LD_INT 121
60963: EQUAL
60964: IFFALSE 60970
// MC_TameApe ( ) ;
60966: CALL 75255 0 0
// if event = 122 then
60970: LD_VAR 0 1
60974: PUSH
60975: LD_INT 122
60977: EQUAL
60978: IFFALSE 60984
// MC_ChangeApeClass ( ) ;
60980: CALL 76084 0 0
// if event = 123 then
60984: LD_VAR 0 1
60988: PUSH
60989: LD_INT 123
60991: EQUAL
60992: IFFALSE 60998
// MC_Bazooka ( ) ;
60994: CALL 76734 0 0
// if event = 124 then
60998: LD_VAR 0 1
61002: PUSH
61003: LD_INT 124
61005: EQUAL
61006: IFFALSE 61012
// MC_TeleportExit ( ) ;
61008: CALL 76932 0 0
// if event = 125 then
61012: LD_VAR 0 1
61016: PUSH
61017: LD_INT 125
61019: EQUAL
61020: IFFALSE 61026
// MC_Deposits ( ) ;
61022: CALL 77579 0 0
// if event = 126 then
61026: LD_VAR 0 1
61030: PUSH
61031: LD_INT 126
61033: EQUAL
61034: IFFALSE 61040
// MC_RemoteDriver ( ) ;
61036: CALL 78204 0 0
// if event = 200 then
61040: LD_VAR 0 1
61044: PUSH
61045: LD_INT 200
61047: EQUAL
61048: IFFALSE 61054
// MC_Idle ( ) ;
61050: CALL 79937 0 0
// end ;
61054: PPOPN 1
61056: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61057: LD_INT 0
61059: PPUSH
61060: PPUSH
// if not mc_bases [ base ] or not tag then
61061: LD_EXP 58
61065: PUSH
61066: LD_VAR 0 1
61070: ARRAY
61071: NOT
61072: PUSH
61073: LD_VAR 0 2
61077: NOT
61078: OR
61079: IFFALSE 61083
// exit ;
61081: GO 61147
// for i in mc_bases [ base ] union mc_ape [ base ] do
61083: LD_ADDR_VAR 0 4
61087: PUSH
61088: LD_EXP 58
61092: PUSH
61093: LD_VAR 0 1
61097: ARRAY
61098: PUSH
61099: LD_EXP 87
61103: PUSH
61104: LD_VAR 0 1
61108: ARRAY
61109: UNION
61110: PUSH
61111: FOR_IN
61112: IFFALSE 61145
// if GetTag ( i ) = tag then
61114: LD_VAR 0 4
61118: PPUSH
61119: CALL_OW 110
61123: PUSH
61124: LD_VAR 0 2
61128: EQUAL
61129: IFFALSE 61143
// SetTag ( i , 0 ) ;
61131: LD_VAR 0 4
61135: PPUSH
61136: LD_INT 0
61138: PPUSH
61139: CALL_OW 109
61143: GO 61111
61145: POP
61146: POP
// end ;
61147: LD_VAR 0 3
61151: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61152: LD_INT 0
61154: PPUSH
61155: PPUSH
61156: PPUSH
61157: PPUSH
61158: PPUSH
61159: PPUSH
61160: PPUSH
61161: PPUSH
// if not mc_bases then
61162: LD_EXP 58
61166: NOT
61167: IFFALSE 61171
// exit ;
61169: GO 61629
// for i = 1 to mc_bases do
61171: LD_ADDR_VAR 0 2
61175: PUSH
61176: DOUBLE
61177: LD_INT 1
61179: DEC
61180: ST_TO_ADDR
61181: LD_EXP 58
61185: PUSH
61186: FOR_TO
61187: IFFALSE 61627
// begin tmp := MC_ClassCheckReq ( i ) ;
61189: LD_ADDR_VAR 0 4
61193: PUSH
61194: LD_VAR 0 2
61198: PPUSH
61199: CALL 61634 0 1
61203: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61204: LD_ADDR_EXP 99
61208: PUSH
61209: LD_EXP 99
61213: PPUSH
61214: LD_VAR 0 2
61218: PPUSH
61219: LD_VAR 0 4
61223: PPUSH
61224: CALL_OW 1
61228: ST_TO_ADDR
// if not tmp then
61229: LD_VAR 0 4
61233: NOT
61234: IFFALSE 61238
// continue ;
61236: GO 61186
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61238: LD_ADDR_VAR 0 6
61242: PUSH
61243: LD_EXP 58
61247: PUSH
61248: LD_VAR 0 2
61252: ARRAY
61253: PPUSH
61254: LD_INT 2
61256: PUSH
61257: LD_INT 30
61259: PUSH
61260: LD_INT 4
61262: PUSH
61263: EMPTY
61264: LIST
61265: LIST
61266: PUSH
61267: LD_INT 30
61269: PUSH
61270: LD_INT 5
61272: PUSH
61273: EMPTY
61274: LIST
61275: LIST
61276: PUSH
61277: EMPTY
61278: LIST
61279: LIST
61280: LIST
61281: PPUSH
61282: CALL_OW 72
61286: PUSH
61287: LD_EXP 58
61291: PUSH
61292: LD_VAR 0 2
61296: ARRAY
61297: PPUSH
61298: LD_INT 2
61300: PUSH
61301: LD_INT 30
61303: PUSH
61304: LD_INT 0
61306: PUSH
61307: EMPTY
61308: LIST
61309: LIST
61310: PUSH
61311: LD_INT 30
61313: PUSH
61314: LD_INT 1
61316: PUSH
61317: EMPTY
61318: LIST
61319: LIST
61320: PUSH
61321: EMPTY
61322: LIST
61323: LIST
61324: LIST
61325: PPUSH
61326: CALL_OW 72
61330: PUSH
61331: LD_EXP 58
61335: PUSH
61336: LD_VAR 0 2
61340: ARRAY
61341: PPUSH
61342: LD_INT 30
61344: PUSH
61345: LD_INT 3
61347: PUSH
61348: EMPTY
61349: LIST
61350: LIST
61351: PPUSH
61352: CALL_OW 72
61356: PUSH
61357: LD_EXP 58
61361: PUSH
61362: LD_VAR 0 2
61366: ARRAY
61367: PPUSH
61368: LD_INT 2
61370: PUSH
61371: LD_INT 30
61373: PUSH
61374: LD_INT 6
61376: PUSH
61377: EMPTY
61378: LIST
61379: LIST
61380: PUSH
61381: LD_INT 30
61383: PUSH
61384: LD_INT 7
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: LD_INT 30
61393: PUSH
61394: LD_INT 8
61396: PUSH
61397: EMPTY
61398: LIST
61399: LIST
61400: PUSH
61401: EMPTY
61402: LIST
61403: LIST
61404: LIST
61405: LIST
61406: PPUSH
61407: CALL_OW 72
61411: PUSH
61412: EMPTY
61413: LIST
61414: LIST
61415: LIST
61416: LIST
61417: ST_TO_ADDR
// for j = 1 to 4 do
61418: LD_ADDR_VAR 0 3
61422: PUSH
61423: DOUBLE
61424: LD_INT 1
61426: DEC
61427: ST_TO_ADDR
61428: LD_INT 4
61430: PUSH
61431: FOR_TO
61432: IFFALSE 61623
// begin if not tmp [ j ] then
61434: LD_VAR 0 4
61438: PUSH
61439: LD_VAR 0 3
61443: ARRAY
61444: NOT
61445: IFFALSE 61449
// continue ;
61447: GO 61431
// for p in tmp [ j ] do
61449: LD_ADDR_VAR 0 5
61453: PUSH
61454: LD_VAR 0 4
61458: PUSH
61459: LD_VAR 0 3
61463: ARRAY
61464: PUSH
61465: FOR_IN
61466: IFFALSE 61619
// begin if not b [ j ] then
61468: LD_VAR 0 6
61472: PUSH
61473: LD_VAR 0 3
61477: ARRAY
61478: NOT
61479: IFFALSE 61483
// break ;
61481: GO 61619
// e := 0 ;
61483: LD_ADDR_VAR 0 7
61487: PUSH
61488: LD_INT 0
61490: ST_TO_ADDR
// for k in b [ j ] do
61491: LD_ADDR_VAR 0 8
61495: PUSH
61496: LD_VAR 0 6
61500: PUSH
61501: LD_VAR 0 3
61505: ARRAY
61506: PUSH
61507: FOR_IN
61508: IFFALSE 61535
// if IsNotFull ( k ) then
61510: LD_VAR 0 8
61514: PPUSH
61515: CALL 18320 0 1
61519: IFFALSE 61533
// begin e := k ;
61521: LD_ADDR_VAR 0 7
61525: PUSH
61526: LD_VAR 0 8
61530: ST_TO_ADDR
// break ;
61531: GO 61535
// end ;
61533: GO 61507
61535: POP
61536: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61537: LD_VAR 0 7
61541: PUSH
61542: LD_VAR 0 5
61546: PPUSH
61547: LD_VAR 0 7
61551: PPUSH
61552: CALL 55439 0 2
61556: NOT
61557: AND
61558: IFFALSE 61617
// begin if IsInUnit ( p ) then
61560: LD_VAR 0 5
61564: PPUSH
61565: CALL_OW 310
61569: IFFALSE 61580
// ComExitBuilding ( p ) ;
61571: LD_VAR 0 5
61575: PPUSH
61576: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61580: LD_VAR 0 5
61584: PPUSH
61585: LD_VAR 0 7
61589: PPUSH
61590: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61594: LD_VAR 0 5
61598: PPUSH
61599: LD_VAR 0 3
61603: PPUSH
61604: CALL_OW 183
// AddComExitBuilding ( p ) ;
61608: LD_VAR 0 5
61612: PPUSH
61613: CALL_OW 182
// end ; end ;
61617: GO 61465
61619: POP
61620: POP
// end ;
61621: GO 61431
61623: POP
61624: POP
// end ;
61625: GO 61186
61627: POP
61628: POP
// end ;
61629: LD_VAR 0 1
61633: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61634: LD_INT 0
61636: PPUSH
61637: PPUSH
61638: PPUSH
61639: PPUSH
61640: PPUSH
61641: PPUSH
61642: PPUSH
61643: PPUSH
61644: PPUSH
61645: PPUSH
61646: PPUSH
61647: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61648: LD_VAR 0 1
61652: NOT
61653: PUSH
61654: LD_EXP 58
61658: PUSH
61659: LD_VAR 0 1
61663: ARRAY
61664: NOT
61665: OR
61666: PUSH
61667: LD_EXP 58
61671: PUSH
61672: LD_VAR 0 1
61676: ARRAY
61677: PPUSH
61678: LD_INT 2
61680: PUSH
61681: LD_INT 30
61683: PUSH
61684: LD_INT 0
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PUSH
61691: LD_INT 30
61693: PUSH
61694: LD_INT 1
61696: PUSH
61697: EMPTY
61698: LIST
61699: LIST
61700: PUSH
61701: EMPTY
61702: LIST
61703: LIST
61704: LIST
61705: PPUSH
61706: CALL_OW 72
61710: NOT
61711: OR
61712: IFFALSE 61716
// exit ;
61714: GO 65219
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61716: LD_ADDR_VAR 0 4
61720: PUSH
61721: LD_EXP 58
61725: PUSH
61726: LD_VAR 0 1
61730: ARRAY
61731: PPUSH
61732: LD_INT 2
61734: PUSH
61735: LD_INT 25
61737: PUSH
61738: LD_INT 1
61740: PUSH
61741: EMPTY
61742: LIST
61743: LIST
61744: PUSH
61745: LD_INT 25
61747: PUSH
61748: LD_INT 2
61750: PUSH
61751: EMPTY
61752: LIST
61753: LIST
61754: PUSH
61755: LD_INT 25
61757: PUSH
61758: LD_INT 3
61760: PUSH
61761: EMPTY
61762: LIST
61763: LIST
61764: PUSH
61765: LD_INT 25
61767: PUSH
61768: LD_INT 4
61770: PUSH
61771: EMPTY
61772: LIST
61773: LIST
61774: PUSH
61775: LD_INT 25
61777: PUSH
61778: LD_INT 5
61780: PUSH
61781: EMPTY
61782: LIST
61783: LIST
61784: PUSH
61785: LD_INT 25
61787: PUSH
61788: LD_INT 8
61790: PUSH
61791: EMPTY
61792: LIST
61793: LIST
61794: PUSH
61795: LD_INT 25
61797: PUSH
61798: LD_INT 9
61800: PUSH
61801: EMPTY
61802: LIST
61803: LIST
61804: PUSH
61805: EMPTY
61806: LIST
61807: LIST
61808: LIST
61809: LIST
61810: LIST
61811: LIST
61812: LIST
61813: LIST
61814: PPUSH
61815: CALL_OW 72
61819: ST_TO_ADDR
// if not tmp then
61820: LD_VAR 0 4
61824: NOT
61825: IFFALSE 61829
// exit ;
61827: GO 65219
// for i in tmp do
61829: LD_ADDR_VAR 0 3
61833: PUSH
61834: LD_VAR 0 4
61838: PUSH
61839: FOR_IN
61840: IFFALSE 61871
// if GetTag ( i ) then
61842: LD_VAR 0 3
61846: PPUSH
61847: CALL_OW 110
61851: IFFALSE 61869
// tmp := tmp diff i ;
61853: LD_ADDR_VAR 0 4
61857: PUSH
61858: LD_VAR 0 4
61862: PUSH
61863: LD_VAR 0 3
61867: DIFF
61868: ST_TO_ADDR
61869: GO 61839
61871: POP
61872: POP
// if not tmp then
61873: LD_VAR 0 4
61877: NOT
61878: IFFALSE 61882
// exit ;
61880: GO 65219
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61882: LD_ADDR_VAR 0 5
61886: PUSH
61887: LD_EXP 58
61891: PUSH
61892: LD_VAR 0 1
61896: ARRAY
61897: PPUSH
61898: LD_INT 2
61900: PUSH
61901: LD_INT 25
61903: PUSH
61904: LD_INT 1
61906: PUSH
61907: EMPTY
61908: LIST
61909: LIST
61910: PUSH
61911: LD_INT 25
61913: PUSH
61914: LD_INT 5
61916: PUSH
61917: EMPTY
61918: LIST
61919: LIST
61920: PUSH
61921: LD_INT 25
61923: PUSH
61924: LD_INT 8
61926: PUSH
61927: EMPTY
61928: LIST
61929: LIST
61930: PUSH
61931: LD_INT 25
61933: PUSH
61934: LD_INT 9
61936: PUSH
61937: EMPTY
61938: LIST
61939: LIST
61940: PUSH
61941: EMPTY
61942: LIST
61943: LIST
61944: LIST
61945: LIST
61946: LIST
61947: PPUSH
61948: CALL_OW 72
61952: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
61953: LD_ADDR_VAR 0 6
61957: PUSH
61958: LD_EXP 58
61962: PUSH
61963: LD_VAR 0 1
61967: ARRAY
61968: PPUSH
61969: LD_INT 25
61971: PUSH
61972: LD_INT 2
61974: PUSH
61975: EMPTY
61976: LIST
61977: LIST
61978: PPUSH
61979: CALL_OW 72
61983: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
61984: LD_ADDR_VAR 0 7
61988: PUSH
61989: LD_EXP 58
61993: PUSH
61994: LD_VAR 0 1
61998: ARRAY
61999: PPUSH
62000: LD_INT 25
62002: PUSH
62003: LD_INT 3
62005: PUSH
62006: EMPTY
62007: LIST
62008: LIST
62009: PPUSH
62010: CALL_OW 72
62014: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62015: LD_ADDR_VAR 0 8
62019: PUSH
62020: LD_EXP 58
62024: PUSH
62025: LD_VAR 0 1
62029: ARRAY
62030: PPUSH
62031: LD_INT 25
62033: PUSH
62034: LD_INT 4
62036: PUSH
62037: EMPTY
62038: LIST
62039: LIST
62040: PUSH
62041: LD_INT 24
62043: PUSH
62044: LD_INT 251
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: PUSH
62051: EMPTY
62052: LIST
62053: LIST
62054: PPUSH
62055: CALL_OW 72
62059: ST_TO_ADDR
// if mc_scan [ base ] then
62060: LD_EXP 81
62064: PUSH
62065: LD_VAR 0 1
62069: ARRAY
62070: IFFALSE 62531
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62072: LD_ADDR_EXP 100
62076: PUSH
62077: LD_EXP 100
62081: PPUSH
62082: LD_VAR 0 1
62086: PPUSH
62087: LD_INT 4
62089: PPUSH
62090: CALL_OW 1
62094: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62095: LD_ADDR_VAR 0 12
62099: PUSH
62100: LD_EXP 58
62104: PUSH
62105: LD_VAR 0 1
62109: ARRAY
62110: PPUSH
62111: LD_INT 2
62113: PUSH
62114: LD_INT 30
62116: PUSH
62117: LD_INT 4
62119: PUSH
62120: EMPTY
62121: LIST
62122: LIST
62123: PUSH
62124: LD_INT 30
62126: PUSH
62127: LD_INT 5
62129: PUSH
62130: EMPTY
62131: LIST
62132: LIST
62133: PUSH
62134: EMPTY
62135: LIST
62136: LIST
62137: LIST
62138: PPUSH
62139: CALL_OW 72
62143: ST_TO_ADDR
// if not b then
62144: LD_VAR 0 12
62148: NOT
62149: IFFALSE 62153
// exit ;
62151: GO 65219
// p := [ ] ;
62153: LD_ADDR_VAR 0 11
62157: PUSH
62158: EMPTY
62159: ST_TO_ADDR
// if sci >= 2 then
62160: LD_VAR 0 8
62164: PUSH
62165: LD_INT 2
62167: GREATEREQUAL
62168: IFFALSE 62199
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62170: LD_ADDR_VAR 0 8
62174: PUSH
62175: LD_VAR 0 8
62179: PUSH
62180: LD_INT 1
62182: ARRAY
62183: PUSH
62184: LD_VAR 0 8
62188: PUSH
62189: LD_INT 2
62191: ARRAY
62192: PUSH
62193: EMPTY
62194: LIST
62195: LIST
62196: ST_TO_ADDR
62197: GO 62260
// if sci = 1 then
62199: LD_VAR 0 8
62203: PUSH
62204: LD_INT 1
62206: EQUAL
62207: IFFALSE 62228
// sci := [ sci [ 1 ] ] else
62209: LD_ADDR_VAR 0 8
62213: PUSH
62214: LD_VAR 0 8
62218: PUSH
62219: LD_INT 1
62221: ARRAY
62222: PUSH
62223: EMPTY
62224: LIST
62225: ST_TO_ADDR
62226: GO 62260
// if sci = 0 then
62228: LD_VAR 0 8
62232: PUSH
62233: LD_INT 0
62235: EQUAL
62236: IFFALSE 62260
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62238: LD_ADDR_VAR 0 11
62242: PUSH
62243: LD_VAR 0 4
62247: PPUSH
62248: LD_INT 4
62250: PPUSH
62251: CALL 55302 0 2
62255: PUSH
62256: LD_INT 1
62258: ARRAY
62259: ST_TO_ADDR
// if eng > 4 then
62260: LD_VAR 0 6
62264: PUSH
62265: LD_INT 4
62267: GREATER
62268: IFFALSE 62314
// for i = eng downto 4 do
62270: LD_ADDR_VAR 0 3
62274: PUSH
62275: DOUBLE
62276: LD_VAR 0 6
62280: INC
62281: ST_TO_ADDR
62282: LD_INT 4
62284: PUSH
62285: FOR_DOWNTO
62286: IFFALSE 62312
// eng := eng diff eng [ i ] ;
62288: LD_ADDR_VAR 0 6
62292: PUSH
62293: LD_VAR 0 6
62297: PUSH
62298: LD_VAR 0 6
62302: PUSH
62303: LD_VAR 0 3
62307: ARRAY
62308: DIFF
62309: ST_TO_ADDR
62310: GO 62285
62312: POP
62313: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62314: LD_ADDR_VAR 0 4
62318: PUSH
62319: LD_VAR 0 4
62323: PUSH
62324: LD_VAR 0 5
62328: PUSH
62329: LD_VAR 0 6
62333: UNION
62334: PUSH
62335: LD_VAR 0 7
62339: UNION
62340: PUSH
62341: LD_VAR 0 8
62345: UNION
62346: DIFF
62347: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62348: LD_ADDR_VAR 0 13
62352: PUSH
62353: LD_EXP 58
62357: PUSH
62358: LD_VAR 0 1
62362: ARRAY
62363: PPUSH
62364: LD_INT 2
62366: PUSH
62367: LD_INT 30
62369: PUSH
62370: LD_INT 32
62372: PUSH
62373: EMPTY
62374: LIST
62375: LIST
62376: PUSH
62377: LD_INT 30
62379: PUSH
62380: LD_INT 31
62382: PUSH
62383: EMPTY
62384: LIST
62385: LIST
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: LIST
62391: PPUSH
62392: CALL_OW 72
62396: PUSH
62397: LD_EXP 58
62401: PUSH
62402: LD_VAR 0 1
62406: ARRAY
62407: PPUSH
62408: LD_INT 2
62410: PUSH
62411: LD_INT 30
62413: PUSH
62414: LD_INT 4
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PUSH
62421: LD_INT 30
62423: PUSH
62424: LD_INT 5
62426: PUSH
62427: EMPTY
62428: LIST
62429: LIST
62430: PUSH
62431: EMPTY
62432: LIST
62433: LIST
62434: LIST
62435: PPUSH
62436: CALL_OW 72
62440: PUSH
62441: LD_INT 6
62443: MUL
62444: PLUS
62445: ST_TO_ADDR
// if bcount < tmp then
62446: LD_VAR 0 13
62450: PUSH
62451: LD_VAR 0 4
62455: LESS
62456: IFFALSE 62502
// for i = tmp downto bcount do
62458: LD_ADDR_VAR 0 3
62462: PUSH
62463: DOUBLE
62464: LD_VAR 0 4
62468: INC
62469: ST_TO_ADDR
62470: LD_VAR 0 13
62474: PUSH
62475: FOR_DOWNTO
62476: IFFALSE 62500
// tmp := Delete ( tmp , tmp ) ;
62478: LD_ADDR_VAR 0 4
62482: PUSH
62483: LD_VAR 0 4
62487: PPUSH
62488: LD_VAR 0 4
62492: PPUSH
62493: CALL_OW 3
62497: ST_TO_ADDR
62498: GO 62475
62500: POP
62501: POP
// result := [ tmp , 0 , 0 , p ] ;
62502: LD_ADDR_VAR 0 2
62506: PUSH
62507: LD_VAR 0 4
62511: PUSH
62512: LD_INT 0
62514: PUSH
62515: LD_INT 0
62517: PUSH
62518: LD_VAR 0 11
62522: PUSH
62523: EMPTY
62524: LIST
62525: LIST
62526: LIST
62527: LIST
62528: ST_TO_ADDR
// exit ;
62529: GO 65219
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62531: LD_EXP 58
62535: PUSH
62536: LD_VAR 0 1
62540: ARRAY
62541: PPUSH
62542: LD_INT 2
62544: PUSH
62545: LD_INT 30
62547: PUSH
62548: LD_INT 6
62550: PUSH
62551: EMPTY
62552: LIST
62553: LIST
62554: PUSH
62555: LD_INT 30
62557: PUSH
62558: LD_INT 7
62560: PUSH
62561: EMPTY
62562: LIST
62563: LIST
62564: PUSH
62565: LD_INT 30
62567: PUSH
62568: LD_INT 8
62570: PUSH
62571: EMPTY
62572: LIST
62573: LIST
62574: PUSH
62575: EMPTY
62576: LIST
62577: LIST
62578: LIST
62579: LIST
62580: PPUSH
62581: CALL_OW 72
62585: NOT
62586: PUSH
62587: LD_EXP 58
62591: PUSH
62592: LD_VAR 0 1
62596: ARRAY
62597: PPUSH
62598: LD_INT 30
62600: PUSH
62601: LD_INT 3
62603: PUSH
62604: EMPTY
62605: LIST
62606: LIST
62607: PPUSH
62608: CALL_OW 72
62612: NOT
62613: AND
62614: IFFALSE 62686
// begin if eng = tmp then
62616: LD_VAR 0 6
62620: PUSH
62621: LD_VAR 0 4
62625: EQUAL
62626: IFFALSE 62630
// exit ;
62628: GO 65219
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62630: LD_ADDR_EXP 100
62634: PUSH
62635: LD_EXP 100
62639: PPUSH
62640: LD_VAR 0 1
62644: PPUSH
62645: LD_INT 1
62647: PPUSH
62648: CALL_OW 1
62652: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62653: LD_ADDR_VAR 0 2
62657: PUSH
62658: LD_INT 0
62660: PUSH
62661: LD_VAR 0 4
62665: PUSH
62666: LD_VAR 0 6
62670: DIFF
62671: PUSH
62672: LD_INT 0
62674: PUSH
62675: LD_INT 0
62677: PUSH
62678: EMPTY
62679: LIST
62680: LIST
62681: LIST
62682: LIST
62683: ST_TO_ADDR
// exit ;
62684: GO 65219
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62686: LD_EXP 85
62690: PUSH
62691: LD_EXP 84
62695: PUSH
62696: LD_VAR 0 1
62700: ARRAY
62701: ARRAY
62702: PUSH
62703: LD_EXP 58
62707: PUSH
62708: LD_VAR 0 1
62712: ARRAY
62713: PPUSH
62714: LD_INT 2
62716: PUSH
62717: LD_INT 30
62719: PUSH
62720: LD_INT 6
62722: PUSH
62723: EMPTY
62724: LIST
62725: LIST
62726: PUSH
62727: LD_INT 30
62729: PUSH
62730: LD_INT 7
62732: PUSH
62733: EMPTY
62734: LIST
62735: LIST
62736: PUSH
62737: LD_INT 30
62739: PUSH
62740: LD_INT 8
62742: PUSH
62743: EMPTY
62744: LIST
62745: LIST
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: LIST
62751: LIST
62752: PPUSH
62753: CALL_OW 72
62757: AND
62758: PUSH
62759: LD_EXP 58
62763: PUSH
62764: LD_VAR 0 1
62768: ARRAY
62769: PPUSH
62770: LD_INT 30
62772: PUSH
62773: LD_INT 3
62775: PUSH
62776: EMPTY
62777: LIST
62778: LIST
62779: PPUSH
62780: CALL_OW 72
62784: NOT
62785: AND
62786: IFFALSE 63000
// begin if sci >= 6 then
62788: LD_VAR 0 8
62792: PUSH
62793: LD_INT 6
62795: GREATEREQUAL
62796: IFFALSE 62800
// exit ;
62798: GO 65219
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62800: LD_ADDR_EXP 100
62804: PUSH
62805: LD_EXP 100
62809: PPUSH
62810: LD_VAR 0 1
62814: PPUSH
62815: LD_INT 2
62817: PPUSH
62818: CALL_OW 1
62822: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62823: LD_ADDR_VAR 0 9
62827: PUSH
62828: LD_VAR 0 4
62832: PUSH
62833: LD_VAR 0 8
62837: DIFF
62838: PPUSH
62839: LD_INT 4
62841: PPUSH
62842: CALL 55302 0 2
62846: ST_TO_ADDR
// p := [ ] ;
62847: LD_ADDR_VAR 0 11
62851: PUSH
62852: EMPTY
62853: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62854: LD_VAR 0 8
62858: PUSH
62859: LD_INT 6
62861: LESS
62862: PUSH
62863: LD_VAR 0 9
62867: PUSH
62868: LD_INT 6
62870: GREATER
62871: AND
62872: IFFALSE 62953
// begin for i = 1 to 6 - sci do
62874: LD_ADDR_VAR 0 3
62878: PUSH
62879: DOUBLE
62880: LD_INT 1
62882: DEC
62883: ST_TO_ADDR
62884: LD_INT 6
62886: PUSH
62887: LD_VAR 0 8
62891: MINUS
62892: PUSH
62893: FOR_TO
62894: IFFALSE 62949
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
62896: LD_ADDR_VAR 0 11
62900: PUSH
62901: LD_VAR 0 11
62905: PPUSH
62906: LD_VAR 0 11
62910: PUSH
62911: LD_INT 1
62913: PLUS
62914: PPUSH
62915: LD_VAR 0 9
62919: PUSH
62920: LD_INT 1
62922: ARRAY
62923: PPUSH
62924: CALL_OW 2
62928: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
62929: LD_ADDR_VAR 0 9
62933: PUSH
62934: LD_VAR 0 9
62938: PPUSH
62939: LD_INT 1
62941: PPUSH
62942: CALL_OW 3
62946: ST_TO_ADDR
// end ;
62947: GO 62893
62949: POP
62950: POP
// end else
62951: GO 62973
// if sort then
62953: LD_VAR 0 9
62957: IFFALSE 62973
// p := sort [ 1 ] ;
62959: LD_ADDR_VAR 0 11
62963: PUSH
62964: LD_VAR 0 9
62968: PUSH
62969: LD_INT 1
62971: ARRAY
62972: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
62973: LD_ADDR_VAR 0 2
62977: PUSH
62978: LD_INT 0
62980: PUSH
62981: LD_INT 0
62983: PUSH
62984: LD_INT 0
62986: PUSH
62987: LD_VAR 0 11
62991: PUSH
62992: EMPTY
62993: LIST
62994: LIST
62995: LIST
62996: LIST
62997: ST_TO_ADDR
// exit ;
62998: GO 65219
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63000: LD_EXP 85
63004: PUSH
63005: LD_EXP 84
63009: PUSH
63010: LD_VAR 0 1
63014: ARRAY
63015: ARRAY
63016: PUSH
63017: LD_EXP 58
63021: PUSH
63022: LD_VAR 0 1
63026: ARRAY
63027: PPUSH
63028: LD_INT 2
63030: PUSH
63031: LD_INT 30
63033: PUSH
63034: LD_INT 6
63036: PUSH
63037: EMPTY
63038: LIST
63039: LIST
63040: PUSH
63041: LD_INT 30
63043: PUSH
63044: LD_INT 7
63046: PUSH
63047: EMPTY
63048: LIST
63049: LIST
63050: PUSH
63051: LD_INT 30
63053: PUSH
63054: LD_INT 8
63056: PUSH
63057: EMPTY
63058: LIST
63059: LIST
63060: PUSH
63061: EMPTY
63062: LIST
63063: LIST
63064: LIST
63065: LIST
63066: PPUSH
63067: CALL_OW 72
63071: AND
63072: PUSH
63073: LD_EXP 58
63077: PUSH
63078: LD_VAR 0 1
63082: ARRAY
63083: PPUSH
63084: LD_INT 30
63086: PUSH
63087: LD_INT 3
63089: PUSH
63090: EMPTY
63091: LIST
63092: LIST
63093: PPUSH
63094: CALL_OW 72
63098: AND
63099: IFFALSE 63833
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63101: LD_ADDR_EXP 100
63105: PUSH
63106: LD_EXP 100
63110: PPUSH
63111: LD_VAR 0 1
63115: PPUSH
63116: LD_INT 3
63118: PPUSH
63119: CALL_OW 1
63123: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63124: LD_ADDR_VAR 0 2
63128: PUSH
63129: LD_INT 0
63131: PUSH
63132: LD_INT 0
63134: PUSH
63135: LD_INT 0
63137: PUSH
63138: LD_INT 0
63140: PUSH
63141: EMPTY
63142: LIST
63143: LIST
63144: LIST
63145: LIST
63146: ST_TO_ADDR
// if not eng then
63147: LD_VAR 0 6
63151: NOT
63152: IFFALSE 63215
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63154: LD_ADDR_VAR 0 11
63158: PUSH
63159: LD_VAR 0 4
63163: PPUSH
63164: LD_INT 2
63166: PPUSH
63167: CALL 55302 0 2
63171: PUSH
63172: LD_INT 1
63174: ARRAY
63175: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63176: LD_ADDR_VAR 0 2
63180: PUSH
63181: LD_VAR 0 2
63185: PPUSH
63186: LD_INT 2
63188: PPUSH
63189: LD_VAR 0 11
63193: PPUSH
63194: CALL_OW 1
63198: ST_TO_ADDR
// tmp := tmp diff p ;
63199: LD_ADDR_VAR 0 4
63203: PUSH
63204: LD_VAR 0 4
63208: PUSH
63209: LD_VAR 0 11
63213: DIFF
63214: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63215: LD_VAR 0 4
63219: PUSH
63220: LD_VAR 0 8
63224: PUSH
63225: LD_INT 6
63227: LESS
63228: AND
63229: IFFALSE 63417
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63231: LD_ADDR_VAR 0 9
63235: PUSH
63236: LD_VAR 0 4
63240: PUSH
63241: LD_VAR 0 8
63245: PUSH
63246: LD_VAR 0 7
63250: UNION
63251: DIFF
63252: PPUSH
63253: LD_INT 4
63255: PPUSH
63256: CALL 55302 0 2
63260: ST_TO_ADDR
// p := [ ] ;
63261: LD_ADDR_VAR 0 11
63265: PUSH
63266: EMPTY
63267: ST_TO_ADDR
// if sort then
63268: LD_VAR 0 9
63272: IFFALSE 63388
// for i = 1 to 6 - sci do
63274: LD_ADDR_VAR 0 3
63278: PUSH
63279: DOUBLE
63280: LD_INT 1
63282: DEC
63283: ST_TO_ADDR
63284: LD_INT 6
63286: PUSH
63287: LD_VAR 0 8
63291: MINUS
63292: PUSH
63293: FOR_TO
63294: IFFALSE 63386
// begin if i = sort then
63296: LD_VAR 0 3
63300: PUSH
63301: LD_VAR 0 9
63305: EQUAL
63306: IFFALSE 63310
// break ;
63308: GO 63386
// if GetClass ( i ) = 4 then
63310: LD_VAR 0 3
63314: PPUSH
63315: CALL_OW 257
63319: PUSH
63320: LD_INT 4
63322: EQUAL
63323: IFFALSE 63327
// continue ;
63325: GO 63293
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63327: LD_ADDR_VAR 0 11
63331: PUSH
63332: LD_VAR 0 11
63336: PPUSH
63337: LD_VAR 0 11
63341: PUSH
63342: LD_INT 1
63344: PLUS
63345: PPUSH
63346: LD_VAR 0 9
63350: PUSH
63351: LD_VAR 0 3
63355: ARRAY
63356: PPUSH
63357: CALL_OW 2
63361: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63362: LD_ADDR_VAR 0 4
63366: PUSH
63367: LD_VAR 0 4
63371: PUSH
63372: LD_VAR 0 9
63376: PUSH
63377: LD_VAR 0 3
63381: ARRAY
63382: DIFF
63383: ST_TO_ADDR
// end ;
63384: GO 63293
63386: POP
63387: POP
// if p then
63388: LD_VAR 0 11
63392: IFFALSE 63417
// result := Replace ( result , 4 , p ) ;
63394: LD_ADDR_VAR 0 2
63398: PUSH
63399: LD_VAR 0 2
63403: PPUSH
63404: LD_INT 4
63406: PPUSH
63407: LD_VAR 0 11
63411: PPUSH
63412: CALL_OW 1
63416: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63417: LD_VAR 0 4
63421: PUSH
63422: LD_VAR 0 7
63426: PUSH
63427: LD_INT 6
63429: LESS
63430: AND
63431: IFFALSE 63619
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63433: LD_ADDR_VAR 0 9
63437: PUSH
63438: LD_VAR 0 4
63442: PUSH
63443: LD_VAR 0 8
63447: PUSH
63448: LD_VAR 0 7
63452: UNION
63453: DIFF
63454: PPUSH
63455: LD_INT 3
63457: PPUSH
63458: CALL 55302 0 2
63462: ST_TO_ADDR
// p := [ ] ;
63463: LD_ADDR_VAR 0 11
63467: PUSH
63468: EMPTY
63469: ST_TO_ADDR
// if sort then
63470: LD_VAR 0 9
63474: IFFALSE 63590
// for i = 1 to 6 - mech do
63476: LD_ADDR_VAR 0 3
63480: PUSH
63481: DOUBLE
63482: LD_INT 1
63484: DEC
63485: ST_TO_ADDR
63486: LD_INT 6
63488: PUSH
63489: LD_VAR 0 7
63493: MINUS
63494: PUSH
63495: FOR_TO
63496: IFFALSE 63588
// begin if i = sort then
63498: LD_VAR 0 3
63502: PUSH
63503: LD_VAR 0 9
63507: EQUAL
63508: IFFALSE 63512
// break ;
63510: GO 63588
// if GetClass ( i ) = 3 then
63512: LD_VAR 0 3
63516: PPUSH
63517: CALL_OW 257
63521: PUSH
63522: LD_INT 3
63524: EQUAL
63525: IFFALSE 63529
// continue ;
63527: GO 63495
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63529: LD_ADDR_VAR 0 11
63533: PUSH
63534: LD_VAR 0 11
63538: PPUSH
63539: LD_VAR 0 11
63543: PUSH
63544: LD_INT 1
63546: PLUS
63547: PPUSH
63548: LD_VAR 0 9
63552: PUSH
63553: LD_VAR 0 3
63557: ARRAY
63558: PPUSH
63559: CALL_OW 2
63563: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63564: LD_ADDR_VAR 0 4
63568: PUSH
63569: LD_VAR 0 4
63573: PUSH
63574: LD_VAR 0 9
63578: PUSH
63579: LD_VAR 0 3
63583: ARRAY
63584: DIFF
63585: ST_TO_ADDR
// end ;
63586: GO 63495
63588: POP
63589: POP
// if p then
63590: LD_VAR 0 11
63594: IFFALSE 63619
// result := Replace ( result , 3 , p ) ;
63596: LD_ADDR_VAR 0 2
63600: PUSH
63601: LD_VAR 0 2
63605: PPUSH
63606: LD_INT 3
63608: PPUSH
63609: LD_VAR 0 11
63613: PPUSH
63614: CALL_OW 1
63618: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63619: LD_VAR 0 4
63623: PUSH
63624: LD_INT 6
63626: GREATER
63627: PUSH
63628: LD_VAR 0 6
63632: PUSH
63633: LD_INT 6
63635: LESS
63636: AND
63637: IFFALSE 63831
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63639: LD_ADDR_VAR 0 9
63643: PUSH
63644: LD_VAR 0 4
63648: PUSH
63649: LD_VAR 0 8
63653: PUSH
63654: LD_VAR 0 7
63658: UNION
63659: PUSH
63660: LD_VAR 0 6
63664: UNION
63665: DIFF
63666: PPUSH
63667: LD_INT 2
63669: PPUSH
63670: CALL 55302 0 2
63674: ST_TO_ADDR
// p := [ ] ;
63675: LD_ADDR_VAR 0 11
63679: PUSH
63680: EMPTY
63681: ST_TO_ADDR
// if sort then
63682: LD_VAR 0 9
63686: IFFALSE 63802
// for i = 1 to 6 - eng do
63688: LD_ADDR_VAR 0 3
63692: PUSH
63693: DOUBLE
63694: LD_INT 1
63696: DEC
63697: ST_TO_ADDR
63698: LD_INT 6
63700: PUSH
63701: LD_VAR 0 6
63705: MINUS
63706: PUSH
63707: FOR_TO
63708: IFFALSE 63800
// begin if i = sort then
63710: LD_VAR 0 3
63714: PUSH
63715: LD_VAR 0 9
63719: EQUAL
63720: IFFALSE 63724
// break ;
63722: GO 63800
// if GetClass ( i ) = 2 then
63724: LD_VAR 0 3
63728: PPUSH
63729: CALL_OW 257
63733: PUSH
63734: LD_INT 2
63736: EQUAL
63737: IFFALSE 63741
// continue ;
63739: GO 63707
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63741: LD_ADDR_VAR 0 11
63745: PUSH
63746: LD_VAR 0 11
63750: PPUSH
63751: LD_VAR 0 11
63755: PUSH
63756: LD_INT 1
63758: PLUS
63759: PPUSH
63760: LD_VAR 0 9
63764: PUSH
63765: LD_VAR 0 3
63769: ARRAY
63770: PPUSH
63771: CALL_OW 2
63775: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63776: LD_ADDR_VAR 0 4
63780: PUSH
63781: LD_VAR 0 4
63785: PUSH
63786: LD_VAR 0 9
63790: PUSH
63791: LD_VAR 0 3
63795: ARRAY
63796: DIFF
63797: ST_TO_ADDR
// end ;
63798: GO 63707
63800: POP
63801: POP
// if p then
63802: LD_VAR 0 11
63806: IFFALSE 63831
// result := Replace ( result , 2 , p ) ;
63808: LD_ADDR_VAR 0 2
63812: PUSH
63813: LD_VAR 0 2
63817: PPUSH
63818: LD_INT 2
63820: PPUSH
63821: LD_VAR 0 11
63825: PPUSH
63826: CALL_OW 1
63830: ST_TO_ADDR
// end ; exit ;
63831: GO 65219
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63833: LD_EXP 85
63837: PUSH
63838: LD_EXP 84
63842: PUSH
63843: LD_VAR 0 1
63847: ARRAY
63848: ARRAY
63849: NOT
63850: PUSH
63851: LD_EXP 58
63855: PUSH
63856: LD_VAR 0 1
63860: ARRAY
63861: PPUSH
63862: LD_INT 30
63864: PUSH
63865: LD_INT 3
63867: PUSH
63868: EMPTY
63869: LIST
63870: LIST
63871: PPUSH
63872: CALL_OW 72
63876: AND
63877: PUSH
63878: LD_EXP 63
63882: PUSH
63883: LD_VAR 0 1
63887: ARRAY
63888: AND
63889: IFFALSE 64497
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
63891: LD_ADDR_EXP 100
63895: PUSH
63896: LD_EXP 100
63900: PPUSH
63901: LD_VAR 0 1
63905: PPUSH
63906: LD_INT 5
63908: PPUSH
63909: CALL_OW 1
63913: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63914: LD_ADDR_VAR 0 2
63918: PUSH
63919: LD_INT 0
63921: PUSH
63922: LD_INT 0
63924: PUSH
63925: LD_INT 0
63927: PUSH
63928: LD_INT 0
63930: PUSH
63931: EMPTY
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: ST_TO_ADDR
// if sci > 1 then
63937: LD_VAR 0 8
63941: PUSH
63942: LD_INT 1
63944: GREATER
63945: IFFALSE 63973
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
63947: LD_ADDR_VAR 0 4
63951: PUSH
63952: LD_VAR 0 4
63956: PUSH
63957: LD_VAR 0 8
63961: PUSH
63962: LD_VAR 0 8
63966: PUSH
63967: LD_INT 1
63969: ARRAY
63970: DIFF
63971: DIFF
63972: ST_TO_ADDR
// if tmp and not sci then
63973: LD_VAR 0 4
63977: PUSH
63978: LD_VAR 0 8
63982: NOT
63983: AND
63984: IFFALSE 64053
// begin sort := SortBySkill ( tmp , 4 ) ;
63986: LD_ADDR_VAR 0 9
63990: PUSH
63991: LD_VAR 0 4
63995: PPUSH
63996: LD_INT 4
63998: PPUSH
63999: CALL 55302 0 2
64003: ST_TO_ADDR
// if sort then
64004: LD_VAR 0 9
64008: IFFALSE 64024
// p := sort [ 1 ] ;
64010: LD_ADDR_VAR 0 11
64014: PUSH
64015: LD_VAR 0 9
64019: PUSH
64020: LD_INT 1
64022: ARRAY
64023: ST_TO_ADDR
// if p then
64024: LD_VAR 0 11
64028: IFFALSE 64053
// result := Replace ( result , 4 , p ) ;
64030: LD_ADDR_VAR 0 2
64034: PUSH
64035: LD_VAR 0 2
64039: PPUSH
64040: LD_INT 4
64042: PPUSH
64043: LD_VAR 0 11
64047: PPUSH
64048: CALL_OW 1
64052: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64053: LD_ADDR_VAR 0 4
64057: PUSH
64058: LD_VAR 0 4
64062: PUSH
64063: LD_VAR 0 7
64067: DIFF
64068: ST_TO_ADDR
// if tmp and mech < 6 then
64069: LD_VAR 0 4
64073: PUSH
64074: LD_VAR 0 7
64078: PUSH
64079: LD_INT 6
64081: LESS
64082: AND
64083: IFFALSE 64271
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64085: LD_ADDR_VAR 0 9
64089: PUSH
64090: LD_VAR 0 4
64094: PUSH
64095: LD_VAR 0 8
64099: PUSH
64100: LD_VAR 0 7
64104: UNION
64105: DIFF
64106: PPUSH
64107: LD_INT 3
64109: PPUSH
64110: CALL 55302 0 2
64114: ST_TO_ADDR
// p := [ ] ;
64115: LD_ADDR_VAR 0 11
64119: PUSH
64120: EMPTY
64121: ST_TO_ADDR
// if sort then
64122: LD_VAR 0 9
64126: IFFALSE 64242
// for i = 1 to 6 - mech do
64128: LD_ADDR_VAR 0 3
64132: PUSH
64133: DOUBLE
64134: LD_INT 1
64136: DEC
64137: ST_TO_ADDR
64138: LD_INT 6
64140: PUSH
64141: LD_VAR 0 7
64145: MINUS
64146: PUSH
64147: FOR_TO
64148: IFFALSE 64240
// begin if i = sort then
64150: LD_VAR 0 3
64154: PUSH
64155: LD_VAR 0 9
64159: EQUAL
64160: IFFALSE 64164
// break ;
64162: GO 64240
// if GetClass ( i ) = 3 then
64164: LD_VAR 0 3
64168: PPUSH
64169: CALL_OW 257
64173: PUSH
64174: LD_INT 3
64176: EQUAL
64177: IFFALSE 64181
// continue ;
64179: GO 64147
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64181: LD_ADDR_VAR 0 11
64185: PUSH
64186: LD_VAR 0 11
64190: PPUSH
64191: LD_VAR 0 11
64195: PUSH
64196: LD_INT 1
64198: PLUS
64199: PPUSH
64200: LD_VAR 0 9
64204: PUSH
64205: LD_VAR 0 3
64209: ARRAY
64210: PPUSH
64211: CALL_OW 2
64215: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64216: LD_ADDR_VAR 0 4
64220: PUSH
64221: LD_VAR 0 4
64225: PUSH
64226: LD_VAR 0 9
64230: PUSH
64231: LD_VAR 0 3
64235: ARRAY
64236: DIFF
64237: ST_TO_ADDR
// end ;
64238: GO 64147
64240: POP
64241: POP
// if p then
64242: LD_VAR 0 11
64246: IFFALSE 64271
// result := Replace ( result , 3 , p ) ;
64248: LD_ADDR_VAR 0 2
64252: PUSH
64253: LD_VAR 0 2
64257: PPUSH
64258: LD_INT 3
64260: PPUSH
64261: LD_VAR 0 11
64265: PPUSH
64266: CALL_OW 1
64270: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64271: LD_ADDR_VAR 0 4
64275: PUSH
64276: LD_VAR 0 4
64280: PUSH
64281: LD_VAR 0 6
64285: DIFF
64286: ST_TO_ADDR
// if tmp and eng < 6 then
64287: LD_VAR 0 4
64291: PUSH
64292: LD_VAR 0 6
64296: PUSH
64297: LD_INT 6
64299: LESS
64300: AND
64301: IFFALSE 64495
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64303: LD_ADDR_VAR 0 9
64307: PUSH
64308: LD_VAR 0 4
64312: PUSH
64313: LD_VAR 0 8
64317: PUSH
64318: LD_VAR 0 7
64322: UNION
64323: PUSH
64324: LD_VAR 0 6
64328: UNION
64329: DIFF
64330: PPUSH
64331: LD_INT 2
64333: PPUSH
64334: CALL 55302 0 2
64338: ST_TO_ADDR
// p := [ ] ;
64339: LD_ADDR_VAR 0 11
64343: PUSH
64344: EMPTY
64345: ST_TO_ADDR
// if sort then
64346: LD_VAR 0 9
64350: IFFALSE 64466
// for i = 1 to 6 - eng do
64352: LD_ADDR_VAR 0 3
64356: PUSH
64357: DOUBLE
64358: LD_INT 1
64360: DEC
64361: ST_TO_ADDR
64362: LD_INT 6
64364: PUSH
64365: LD_VAR 0 6
64369: MINUS
64370: PUSH
64371: FOR_TO
64372: IFFALSE 64464
// begin if i = sort then
64374: LD_VAR 0 3
64378: PUSH
64379: LD_VAR 0 9
64383: EQUAL
64384: IFFALSE 64388
// break ;
64386: GO 64464
// if GetClass ( i ) = 2 then
64388: LD_VAR 0 3
64392: PPUSH
64393: CALL_OW 257
64397: PUSH
64398: LD_INT 2
64400: EQUAL
64401: IFFALSE 64405
// continue ;
64403: GO 64371
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64405: LD_ADDR_VAR 0 11
64409: PUSH
64410: LD_VAR 0 11
64414: PPUSH
64415: LD_VAR 0 11
64419: PUSH
64420: LD_INT 1
64422: PLUS
64423: PPUSH
64424: LD_VAR 0 9
64428: PUSH
64429: LD_VAR 0 3
64433: ARRAY
64434: PPUSH
64435: CALL_OW 2
64439: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64440: LD_ADDR_VAR 0 4
64444: PUSH
64445: LD_VAR 0 4
64449: PUSH
64450: LD_VAR 0 9
64454: PUSH
64455: LD_VAR 0 3
64459: ARRAY
64460: DIFF
64461: ST_TO_ADDR
// end ;
64462: GO 64371
64464: POP
64465: POP
// if p then
64466: LD_VAR 0 11
64470: IFFALSE 64495
// result := Replace ( result , 2 , p ) ;
64472: LD_ADDR_VAR 0 2
64476: PUSH
64477: LD_VAR 0 2
64481: PPUSH
64482: LD_INT 2
64484: PPUSH
64485: LD_VAR 0 11
64489: PPUSH
64490: CALL_OW 1
64494: ST_TO_ADDR
// end ; exit ;
64495: GO 65219
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64497: LD_EXP 85
64501: PUSH
64502: LD_EXP 84
64506: PUSH
64507: LD_VAR 0 1
64511: ARRAY
64512: ARRAY
64513: NOT
64514: PUSH
64515: LD_EXP 58
64519: PUSH
64520: LD_VAR 0 1
64524: ARRAY
64525: PPUSH
64526: LD_INT 30
64528: PUSH
64529: LD_INT 3
64531: PUSH
64532: EMPTY
64533: LIST
64534: LIST
64535: PPUSH
64536: CALL_OW 72
64540: AND
64541: PUSH
64542: LD_EXP 63
64546: PUSH
64547: LD_VAR 0 1
64551: ARRAY
64552: NOT
64553: AND
64554: IFFALSE 65219
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64556: LD_ADDR_EXP 100
64560: PUSH
64561: LD_EXP 100
64565: PPUSH
64566: LD_VAR 0 1
64570: PPUSH
64571: LD_INT 6
64573: PPUSH
64574: CALL_OW 1
64578: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64579: LD_ADDR_VAR 0 2
64583: PUSH
64584: LD_INT 0
64586: PUSH
64587: LD_INT 0
64589: PUSH
64590: LD_INT 0
64592: PUSH
64593: LD_INT 0
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: LIST
64600: LIST
64601: ST_TO_ADDR
// if sci >= 1 then
64602: LD_VAR 0 8
64606: PUSH
64607: LD_INT 1
64609: GREATEREQUAL
64610: IFFALSE 64632
// tmp := tmp diff sci [ 1 ] ;
64612: LD_ADDR_VAR 0 4
64616: PUSH
64617: LD_VAR 0 4
64621: PUSH
64622: LD_VAR 0 8
64626: PUSH
64627: LD_INT 1
64629: ARRAY
64630: DIFF
64631: ST_TO_ADDR
// if tmp and not sci then
64632: LD_VAR 0 4
64636: PUSH
64637: LD_VAR 0 8
64641: NOT
64642: AND
64643: IFFALSE 64712
// begin sort := SortBySkill ( tmp , 4 ) ;
64645: LD_ADDR_VAR 0 9
64649: PUSH
64650: LD_VAR 0 4
64654: PPUSH
64655: LD_INT 4
64657: PPUSH
64658: CALL 55302 0 2
64662: ST_TO_ADDR
// if sort then
64663: LD_VAR 0 9
64667: IFFALSE 64683
// p := sort [ 1 ] ;
64669: LD_ADDR_VAR 0 11
64673: PUSH
64674: LD_VAR 0 9
64678: PUSH
64679: LD_INT 1
64681: ARRAY
64682: ST_TO_ADDR
// if p then
64683: LD_VAR 0 11
64687: IFFALSE 64712
// result := Replace ( result , 4 , p ) ;
64689: LD_ADDR_VAR 0 2
64693: PUSH
64694: LD_VAR 0 2
64698: PPUSH
64699: LD_INT 4
64701: PPUSH
64702: LD_VAR 0 11
64706: PPUSH
64707: CALL_OW 1
64711: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64712: LD_ADDR_VAR 0 4
64716: PUSH
64717: LD_VAR 0 4
64721: PUSH
64722: LD_VAR 0 7
64726: DIFF
64727: ST_TO_ADDR
// if tmp and mech < 6 then
64728: LD_VAR 0 4
64732: PUSH
64733: LD_VAR 0 7
64737: PUSH
64738: LD_INT 6
64740: LESS
64741: AND
64742: IFFALSE 64924
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64744: LD_ADDR_VAR 0 9
64748: PUSH
64749: LD_VAR 0 4
64753: PUSH
64754: LD_VAR 0 7
64758: DIFF
64759: PPUSH
64760: LD_INT 3
64762: PPUSH
64763: CALL 55302 0 2
64767: ST_TO_ADDR
// p := [ ] ;
64768: LD_ADDR_VAR 0 11
64772: PUSH
64773: EMPTY
64774: ST_TO_ADDR
// if sort then
64775: LD_VAR 0 9
64779: IFFALSE 64895
// for i = 1 to 6 - mech do
64781: LD_ADDR_VAR 0 3
64785: PUSH
64786: DOUBLE
64787: LD_INT 1
64789: DEC
64790: ST_TO_ADDR
64791: LD_INT 6
64793: PUSH
64794: LD_VAR 0 7
64798: MINUS
64799: PUSH
64800: FOR_TO
64801: IFFALSE 64893
// begin if i = sort then
64803: LD_VAR 0 3
64807: PUSH
64808: LD_VAR 0 9
64812: EQUAL
64813: IFFALSE 64817
// break ;
64815: GO 64893
// if GetClass ( i ) = 3 then
64817: LD_VAR 0 3
64821: PPUSH
64822: CALL_OW 257
64826: PUSH
64827: LD_INT 3
64829: EQUAL
64830: IFFALSE 64834
// continue ;
64832: GO 64800
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64834: LD_ADDR_VAR 0 11
64838: PUSH
64839: LD_VAR 0 11
64843: PPUSH
64844: LD_VAR 0 11
64848: PUSH
64849: LD_INT 1
64851: PLUS
64852: PPUSH
64853: LD_VAR 0 9
64857: PUSH
64858: LD_VAR 0 3
64862: ARRAY
64863: PPUSH
64864: CALL_OW 2
64868: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64869: LD_ADDR_VAR 0 4
64873: PUSH
64874: LD_VAR 0 4
64878: PUSH
64879: LD_VAR 0 9
64883: PUSH
64884: LD_VAR 0 3
64888: ARRAY
64889: DIFF
64890: ST_TO_ADDR
// end ;
64891: GO 64800
64893: POP
64894: POP
// if p then
64895: LD_VAR 0 11
64899: IFFALSE 64924
// result := Replace ( result , 3 , p ) ;
64901: LD_ADDR_VAR 0 2
64905: PUSH
64906: LD_VAR 0 2
64910: PPUSH
64911: LD_INT 3
64913: PPUSH
64914: LD_VAR 0 11
64918: PPUSH
64919: CALL_OW 1
64923: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64924: LD_ADDR_VAR 0 4
64928: PUSH
64929: LD_VAR 0 4
64933: PUSH
64934: LD_VAR 0 6
64938: DIFF
64939: ST_TO_ADDR
// if tmp and eng < 4 then
64940: LD_VAR 0 4
64944: PUSH
64945: LD_VAR 0 6
64949: PUSH
64950: LD_INT 4
64952: LESS
64953: AND
64954: IFFALSE 65144
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
64956: LD_ADDR_VAR 0 9
64960: PUSH
64961: LD_VAR 0 4
64965: PUSH
64966: LD_VAR 0 7
64970: PUSH
64971: LD_VAR 0 6
64975: UNION
64976: DIFF
64977: PPUSH
64978: LD_INT 2
64980: PPUSH
64981: CALL 55302 0 2
64985: ST_TO_ADDR
// p := [ ] ;
64986: LD_ADDR_VAR 0 11
64990: PUSH
64991: EMPTY
64992: ST_TO_ADDR
// if sort then
64993: LD_VAR 0 9
64997: IFFALSE 65113
// for i = 1 to 4 - eng do
64999: LD_ADDR_VAR 0 3
65003: PUSH
65004: DOUBLE
65005: LD_INT 1
65007: DEC
65008: ST_TO_ADDR
65009: LD_INT 4
65011: PUSH
65012: LD_VAR 0 6
65016: MINUS
65017: PUSH
65018: FOR_TO
65019: IFFALSE 65111
// begin if i = sort then
65021: LD_VAR 0 3
65025: PUSH
65026: LD_VAR 0 9
65030: EQUAL
65031: IFFALSE 65035
// break ;
65033: GO 65111
// if GetClass ( i ) = 2 then
65035: LD_VAR 0 3
65039: PPUSH
65040: CALL_OW 257
65044: PUSH
65045: LD_INT 2
65047: EQUAL
65048: IFFALSE 65052
// continue ;
65050: GO 65018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65052: LD_ADDR_VAR 0 11
65056: PUSH
65057: LD_VAR 0 11
65061: PPUSH
65062: LD_VAR 0 11
65066: PUSH
65067: LD_INT 1
65069: PLUS
65070: PPUSH
65071: LD_VAR 0 9
65075: PUSH
65076: LD_VAR 0 3
65080: ARRAY
65081: PPUSH
65082: CALL_OW 2
65086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65087: LD_ADDR_VAR 0 4
65091: PUSH
65092: LD_VAR 0 4
65096: PUSH
65097: LD_VAR 0 9
65101: PUSH
65102: LD_VAR 0 3
65106: ARRAY
65107: DIFF
65108: ST_TO_ADDR
// end ;
65109: GO 65018
65111: POP
65112: POP
// if p then
65113: LD_VAR 0 11
65117: IFFALSE 65142
// result := Replace ( result , 2 , p ) ;
65119: LD_ADDR_VAR 0 2
65123: PUSH
65124: LD_VAR 0 2
65128: PPUSH
65129: LD_INT 2
65131: PPUSH
65132: LD_VAR 0 11
65136: PPUSH
65137: CALL_OW 1
65141: ST_TO_ADDR
// end else
65142: GO 65188
// for i = eng downto 5 do
65144: LD_ADDR_VAR 0 3
65148: PUSH
65149: DOUBLE
65150: LD_VAR 0 6
65154: INC
65155: ST_TO_ADDR
65156: LD_INT 5
65158: PUSH
65159: FOR_DOWNTO
65160: IFFALSE 65186
// tmp := tmp union eng [ i ] ;
65162: LD_ADDR_VAR 0 4
65166: PUSH
65167: LD_VAR 0 4
65171: PUSH
65172: LD_VAR 0 6
65176: PUSH
65177: LD_VAR 0 3
65181: ARRAY
65182: UNION
65183: ST_TO_ADDR
65184: GO 65159
65186: POP
65187: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65188: LD_ADDR_VAR 0 2
65192: PUSH
65193: LD_VAR 0 2
65197: PPUSH
65198: LD_INT 1
65200: PPUSH
65201: LD_VAR 0 4
65205: PUSH
65206: LD_VAR 0 5
65210: DIFF
65211: PPUSH
65212: CALL_OW 1
65216: ST_TO_ADDR
// exit ;
65217: GO 65219
// end ; end ;
65219: LD_VAR 0 2
65223: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65224: LD_INT 0
65226: PPUSH
65227: PPUSH
65228: PPUSH
// if not mc_bases then
65229: LD_EXP 58
65233: NOT
65234: IFFALSE 65238
// exit ;
65236: GO 65344
// for i = 1 to mc_bases do
65238: LD_ADDR_VAR 0 2
65242: PUSH
65243: DOUBLE
65244: LD_INT 1
65246: DEC
65247: ST_TO_ADDR
65248: LD_EXP 58
65252: PUSH
65253: FOR_TO
65254: IFFALSE 65335
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65256: LD_ADDR_VAR 0 3
65260: PUSH
65261: LD_EXP 58
65265: PUSH
65266: LD_VAR 0 2
65270: ARRAY
65271: PPUSH
65272: LD_INT 21
65274: PUSH
65275: LD_INT 3
65277: PUSH
65278: EMPTY
65279: LIST
65280: LIST
65281: PUSH
65282: LD_INT 3
65284: PUSH
65285: LD_INT 24
65287: PUSH
65288: LD_INT 1000
65290: PUSH
65291: EMPTY
65292: LIST
65293: LIST
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: PPUSH
65303: CALL_OW 72
65307: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65308: LD_ADDR_EXP 59
65312: PUSH
65313: LD_EXP 59
65317: PPUSH
65318: LD_VAR 0 2
65322: PPUSH
65323: LD_VAR 0 3
65327: PPUSH
65328: CALL_OW 1
65332: ST_TO_ADDR
// end ;
65333: GO 65253
65335: POP
65336: POP
// RaiseSailEvent ( 101 ) ;
65337: LD_INT 101
65339: PPUSH
65340: CALL_OW 427
// end ;
65344: LD_VAR 0 1
65348: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65349: LD_INT 0
65351: PPUSH
65352: PPUSH
65353: PPUSH
65354: PPUSH
65355: PPUSH
65356: PPUSH
65357: PPUSH
// if not mc_bases then
65358: LD_EXP 58
65362: NOT
65363: IFFALSE 65367
// exit ;
65365: GO 65940
// for i = 1 to mc_bases do
65367: LD_ADDR_VAR 0 2
65371: PUSH
65372: DOUBLE
65373: LD_INT 1
65375: DEC
65376: ST_TO_ADDR
65377: LD_EXP 58
65381: PUSH
65382: FOR_TO
65383: IFFALSE 65931
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65385: LD_ADDR_VAR 0 5
65389: PUSH
65390: LD_EXP 58
65394: PUSH
65395: LD_VAR 0 2
65399: ARRAY
65400: PUSH
65401: LD_EXP 87
65405: PUSH
65406: LD_VAR 0 2
65410: ARRAY
65411: UNION
65412: PPUSH
65413: LD_INT 21
65415: PUSH
65416: LD_INT 1
65418: PUSH
65419: EMPTY
65420: LIST
65421: LIST
65422: PUSH
65423: LD_INT 1
65425: PUSH
65426: LD_INT 3
65428: PUSH
65429: LD_INT 54
65431: PUSH
65432: EMPTY
65433: LIST
65434: PUSH
65435: EMPTY
65436: LIST
65437: LIST
65438: PUSH
65439: LD_INT 3
65441: PUSH
65442: LD_INT 24
65444: PUSH
65445: LD_INT 800
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: LIST
65460: PUSH
65461: EMPTY
65462: LIST
65463: LIST
65464: PPUSH
65465: CALL_OW 72
65469: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65470: LD_ADDR_VAR 0 6
65474: PUSH
65475: LD_EXP 58
65479: PUSH
65480: LD_VAR 0 2
65484: ARRAY
65485: PPUSH
65486: LD_INT 21
65488: PUSH
65489: LD_INT 1
65491: PUSH
65492: EMPTY
65493: LIST
65494: LIST
65495: PUSH
65496: LD_INT 1
65498: PUSH
65499: LD_INT 3
65501: PUSH
65502: LD_INT 54
65504: PUSH
65505: EMPTY
65506: LIST
65507: PUSH
65508: EMPTY
65509: LIST
65510: LIST
65511: PUSH
65512: LD_INT 3
65514: PUSH
65515: LD_INT 24
65517: PUSH
65518: LD_INT 250
65520: PUSH
65521: EMPTY
65522: LIST
65523: LIST
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: LIST
65533: PUSH
65534: EMPTY
65535: LIST
65536: LIST
65537: PPUSH
65538: CALL_OW 72
65542: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65543: LD_ADDR_VAR 0 7
65547: PUSH
65548: LD_VAR 0 5
65552: PUSH
65553: LD_VAR 0 6
65557: DIFF
65558: ST_TO_ADDR
// if not need_heal_1 then
65559: LD_VAR 0 6
65563: NOT
65564: IFFALSE 65597
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65566: LD_ADDR_EXP 61
65570: PUSH
65571: LD_EXP 61
65575: PPUSH
65576: LD_VAR 0 2
65580: PUSH
65581: LD_INT 1
65583: PUSH
65584: EMPTY
65585: LIST
65586: LIST
65587: PPUSH
65588: EMPTY
65589: PPUSH
65590: CALL 21054 0 3
65594: ST_TO_ADDR
65595: GO 65667
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65597: LD_ADDR_EXP 61
65601: PUSH
65602: LD_EXP 61
65606: PPUSH
65607: LD_VAR 0 2
65611: PUSH
65612: LD_INT 1
65614: PUSH
65615: EMPTY
65616: LIST
65617: LIST
65618: PPUSH
65619: LD_EXP 61
65623: PUSH
65624: LD_VAR 0 2
65628: ARRAY
65629: PUSH
65630: LD_INT 1
65632: ARRAY
65633: PPUSH
65634: LD_INT 3
65636: PUSH
65637: LD_INT 24
65639: PUSH
65640: LD_INT 1000
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: EMPTY
65648: LIST
65649: LIST
65650: PPUSH
65651: CALL_OW 72
65655: PUSH
65656: LD_VAR 0 6
65660: UNION
65661: PPUSH
65662: CALL 21054 0 3
65666: ST_TO_ADDR
// if not need_heal_2 then
65667: LD_VAR 0 7
65671: NOT
65672: IFFALSE 65705
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65674: LD_ADDR_EXP 61
65678: PUSH
65679: LD_EXP 61
65683: PPUSH
65684: LD_VAR 0 2
65688: PUSH
65689: LD_INT 2
65691: PUSH
65692: EMPTY
65693: LIST
65694: LIST
65695: PPUSH
65696: EMPTY
65697: PPUSH
65698: CALL 21054 0 3
65702: ST_TO_ADDR
65703: GO 65737
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65705: LD_ADDR_EXP 61
65709: PUSH
65710: LD_EXP 61
65714: PPUSH
65715: LD_VAR 0 2
65719: PUSH
65720: LD_INT 2
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PPUSH
65727: LD_VAR 0 7
65731: PPUSH
65732: CALL 21054 0 3
65736: ST_TO_ADDR
// if need_heal_2 then
65737: LD_VAR 0 7
65741: IFFALSE 65913
// for j in need_heal_2 do
65743: LD_ADDR_VAR 0 3
65747: PUSH
65748: LD_VAR 0 7
65752: PUSH
65753: FOR_IN
65754: IFFALSE 65911
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65756: LD_ADDR_VAR 0 5
65760: PUSH
65761: LD_EXP 58
65765: PUSH
65766: LD_VAR 0 2
65770: ARRAY
65771: PPUSH
65772: LD_INT 2
65774: PUSH
65775: LD_INT 30
65777: PUSH
65778: LD_INT 6
65780: PUSH
65781: EMPTY
65782: LIST
65783: LIST
65784: PUSH
65785: LD_INT 30
65787: PUSH
65788: LD_INT 7
65790: PUSH
65791: EMPTY
65792: LIST
65793: LIST
65794: PUSH
65795: LD_INT 30
65797: PUSH
65798: LD_INT 8
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: PUSH
65805: LD_INT 30
65807: PUSH
65808: LD_INT 0
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 30
65817: PUSH
65818: LD_INT 1
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PUSH
65825: LD_INT 25
65827: PUSH
65828: LD_INT 4
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: EMPTY
65836: LIST
65837: LIST
65838: LIST
65839: LIST
65840: LIST
65841: LIST
65842: LIST
65843: PPUSH
65844: CALL_OW 72
65848: ST_TO_ADDR
// if tmp then
65849: LD_VAR 0 5
65853: IFFALSE 65909
// begin k := NearestUnitToUnit ( tmp , j ) ;
65855: LD_ADDR_VAR 0 4
65859: PUSH
65860: LD_VAR 0 5
65864: PPUSH
65865: LD_VAR 0 3
65869: PPUSH
65870: CALL_OW 74
65874: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
65875: LD_VAR 0 3
65879: PPUSH
65880: LD_VAR 0 4
65884: PPUSH
65885: CALL_OW 296
65889: PUSH
65890: LD_INT 7
65892: GREATER
65893: IFFALSE 65909
// ComMoveUnit ( j , k ) ;
65895: LD_VAR 0 3
65899: PPUSH
65900: LD_VAR 0 4
65904: PPUSH
65905: CALL_OW 112
// end ; end ;
65909: GO 65753
65911: POP
65912: POP
// if not need_heal_1 and not need_heal_2 then
65913: LD_VAR 0 6
65917: NOT
65918: PUSH
65919: LD_VAR 0 7
65923: NOT
65924: AND
65925: IFFALSE 65929
// continue ;
65927: GO 65382
// end ;
65929: GO 65382
65931: POP
65932: POP
// RaiseSailEvent ( 102 ) ;
65933: LD_INT 102
65935: PPUSH
65936: CALL_OW 427
// end ;
65940: LD_VAR 0 1
65944: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
65945: LD_INT 0
65947: PPUSH
65948: PPUSH
65949: PPUSH
65950: PPUSH
65951: PPUSH
65952: PPUSH
// if not mc_bases then
65953: LD_EXP 58
65957: NOT
65958: IFFALSE 65962
// exit ;
65960: GO 66672
// for i = 1 to mc_bases do
65962: LD_ADDR_VAR 0 2
65966: PUSH
65967: DOUBLE
65968: LD_INT 1
65970: DEC
65971: ST_TO_ADDR
65972: LD_EXP 58
65976: PUSH
65977: FOR_TO
65978: IFFALSE 66670
// begin if not mc_building_need_repair [ i ] then
65980: LD_EXP 59
65984: PUSH
65985: LD_VAR 0 2
65989: ARRAY
65990: NOT
65991: IFFALSE 66165
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
65993: LD_ADDR_VAR 0 6
65997: PUSH
65998: LD_EXP 77
66002: PUSH
66003: LD_VAR 0 2
66007: ARRAY
66008: PPUSH
66009: LD_INT 3
66011: PUSH
66012: LD_INT 24
66014: PUSH
66015: LD_INT 1000
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: EMPTY
66023: LIST
66024: LIST
66025: PUSH
66026: LD_INT 2
66028: PUSH
66029: LD_INT 34
66031: PUSH
66032: LD_INT 13
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 34
66041: PUSH
66042: LD_INT 52
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: EMPTY
66050: LIST
66051: LIST
66052: LIST
66053: PUSH
66054: EMPTY
66055: LIST
66056: LIST
66057: PPUSH
66058: CALL_OW 72
66062: ST_TO_ADDR
// if cranes then
66063: LD_VAR 0 6
66067: IFFALSE 66129
// for j in cranes do
66069: LD_ADDR_VAR 0 3
66073: PUSH
66074: LD_VAR 0 6
66078: PUSH
66079: FOR_IN
66080: IFFALSE 66127
// if not IsInArea ( j , mc_parking [ i ] ) then
66082: LD_VAR 0 3
66086: PPUSH
66087: LD_EXP 82
66091: PUSH
66092: LD_VAR 0 2
66096: ARRAY
66097: PPUSH
66098: CALL_OW 308
66102: NOT
66103: IFFALSE 66125
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66105: LD_VAR 0 3
66109: PPUSH
66110: LD_EXP 82
66114: PUSH
66115: LD_VAR 0 2
66119: ARRAY
66120: PPUSH
66121: CALL_OW 113
66125: GO 66079
66127: POP
66128: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66129: LD_ADDR_EXP 60
66133: PUSH
66134: LD_EXP 60
66138: PPUSH
66139: LD_VAR 0 2
66143: PPUSH
66144: EMPTY
66145: PPUSH
66146: CALL_OW 1
66150: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66151: LD_VAR 0 2
66155: PPUSH
66156: LD_INT 101
66158: PPUSH
66159: CALL 61057 0 2
// continue ;
66163: GO 65977
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66165: LD_ADDR_EXP 64
66169: PUSH
66170: LD_EXP 64
66174: PPUSH
66175: LD_VAR 0 2
66179: PPUSH
66180: EMPTY
66181: PPUSH
66182: CALL_OW 1
66186: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66187: LD_VAR 0 2
66191: PPUSH
66192: LD_INT 103
66194: PPUSH
66195: CALL 61057 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66199: LD_ADDR_VAR 0 5
66203: PUSH
66204: LD_EXP 58
66208: PUSH
66209: LD_VAR 0 2
66213: ARRAY
66214: PUSH
66215: LD_EXP 87
66219: PUSH
66220: LD_VAR 0 2
66224: ARRAY
66225: UNION
66226: PPUSH
66227: LD_INT 2
66229: PUSH
66230: LD_INT 25
66232: PUSH
66233: LD_INT 2
66235: PUSH
66236: EMPTY
66237: LIST
66238: LIST
66239: PUSH
66240: LD_INT 25
66242: PUSH
66243: LD_INT 16
66245: PUSH
66246: EMPTY
66247: LIST
66248: LIST
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: LIST
66254: PUSH
66255: EMPTY
66256: LIST
66257: PPUSH
66258: CALL_OW 72
66262: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66263: LD_ADDR_VAR 0 6
66267: PUSH
66268: LD_EXP 77
66272: PUSH
66273: LD_VAR 0 2
66277: ARRAY
66278: PPUSH
66279: LD_INT 2
66281: PUSH
66282: LD_INT 34
66284: PUSH
66285: LD_INT 13
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 34
66294: PUSH
66295: LD_INT 52
66297: PUSH
66298: EMPTY
66299: LIST
66300: LIST
66301: PUSH
66302: EMPTY
66303: LIST
66304: LIST
66305: LIST
66306: PPUSH
66307: CALL_OW 72
66311: ST_TO_ADDR
// if cranes then
66312: LD_VAR 0 6
66316: IFFALSE 66452
// begin for j in cranes do
66318: LD_ADDR_VAR 0 3
66322: PUSH
66323: LD_VAR 0 6
66327: PUSH
66328: FOR_IN
66329: IFFALSE 66450
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66331: LD_VAR 0 3
66335: PPUSH
66336: CALL_OW 256
66340: PUSH
66341: LD_INT 500
66343: GREATEREQUAL
66344: PUSH
66345: LD_VAR 0 3
66349: PPUSH
66350: CALL_OW 314
66354: NOT
66355: AND
66356: IFFALSE 66390
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66358: LD_VAR 0 3
66362: PPUSH
66363: LD_EXP 59
66367: PUSH
66368: LD_VAR 0 2
66372: ARRAY
66373: PPUSH
66374: LD_VAR 0 3
66378: PPUSH
66379: CALL_OW 74
66383: PPUSH
66384: CALL_OW 130
66388: GO 66448
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66390: LD_VAR 0 3
66394: PPUSH
66395: CALL_OW 256
66399: PUSH
66400: LD_INT 500
66402: LESS
66403: PUSH
66404: LD_VAR 0 3
66408: PPUSH
66409: LD_EXP 82
66413: PUSH
66414: LD_VAR 0 2
66418: ARRAY
66419: PPUSH
66420: CALL_OW 308
66424: NOT
66425: AND
66426: IFFALSE 66448
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66428: LD_VAR 0 3
66432: PPUSH
66433: LD_EXP 82
66437: PUSH
66438: LD_VAR 0 2
66442: ARRAY
66443: PPUSH
66444: CALL_OW 113
66448: GO 66328
66450: POP
66451: POP
// end ; if not tmp then
66452: LD_VAR 0 5
66456: NOT
66457: IFFALSE 66461
// continue ;
66459: GO 65977
// for j in tmp do
66461: LD_ADDR_VAR 0 3
66465: PUSH
66466: LD_VAR 0 5
66470: PUSH
66471: FOR_IN
66472: IFFALSE 66666
// begin if mc_need_heal [ i ] then
66474: LD_EXP 61
66478: PUSH
66479: LD_VAR 0 2
66483: ARRAY
66484: IFFALSE 66532
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66486: LD_VAR 0 3
66490: PUSH
66491: LD_EXP 61
66495: PUSH
66496: LD_VAR 0 2
66500: ARRAY
66501: PUSH
66502: LD_INT 1
66504: ARRAY
66505: IN
66506: PUSH
66507: LD_VAR 0 3
66511: PUSH
66512: LD_EXP 61
66516: PUSH
66517: LD_VAR 0 2
66521: ARRAY
66522: PUSH
66523: LD_INT 2
66525: ARRAY
66526: IN
66527: OR
66528: IFFALSE 66532
// continue ;
66530: GO 66471
// if IsInUnit ( j ) then
66532: LD_VAR 0 3
66536: PPUSH
66537: CALL_OW 310
66541: IFFALSE 66552
// ComExitBuilding ( j ) ;
66543: LD_VAR 0 3
66547: PPUSH
66548: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66552: LD_VAR 0 3
66556: PUSH
66557: LD_EXP 60
66561: PUSH
66562: LD_VAR 0 2
66566: ARRAY
66567: IN
66568: NOT
66569: IFFALSE 66627
// begin SetTag ( j , 101 ) ;
66571: LD_VAR 0 3
66575: PPUSH
66576: LD_INT 101
66578: PPUSH
66579: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66583: LD_ADDR_EXP 60
66587: PUSH
66588: LD_EXP 60
66592: PPUSH
66593: LD_VAR 0 2
66597: PUSH
66598: LD_EXP 60
66602: PUSH
66603: LD_VAR 0 2
66607: ARRAY
66608: PUSH
66609: LD_INT 1
66611: PLUS
66612: PUSH
66613: EMPTY
66614: LIST
66615: LIST
66616: PPUSH
66617: LD_VAR 0 3
66621: PPUSH
66622: CALL 21054 0 3
66626: ST_TO_ADDR
// end ; wait ( 1 ) ;
66627: LD_INT 1
66629: PPUSH
66630: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66634: LD_VAR 0 3
66638: PPUSH
66639: LD_EXP 59
66643: PUSH
66644: LD_VAR 0 2
66648: ARRAY
66649: PPUSH
66650: LD_VAR 0 3
66654: PPUSH
66655: CALL_OW 74
66659: PPUSH
66660: CALL_OW 130
// end ;
66664: GO 66471
66666: POP
66667: POP
// end ;
66668: GO 65977
66670: POP
66671: POP
// end ;
66672: LD_VAR 0 1
66676: RET
// export function MC_Heal ; var i , j , tmp ; begin
66677: LD_INT 0
66679: PPUSH
66680: PPUSH
66681: PPUSH
66682: PPUSH
// if not mc_bases then
66683: LD_EXP 58
66687: NOT
66688: IFFALSE 66692
// exit ;
66690: GO 67094
// for i = 1 to mc_bases do
66692: LD_ADDR_VAR 0 2
66696: PUSH
66697: DOUBLE
66698: LD_INT 1
66700: DEC
66701: ST_TO_ADDR
66702: LD_EXP 58
66706: PUSH
66707: FOR_TO
66708: IFFALSE 67092
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66710: LD_EXP 61
66714: PUSH
66715: LD_VAR 0 2
66719: ARRAY
66720: PUSH
66721: LD_INT 1
66723: ARRAY
66724: NOT
66725: PUSH
66726: LD_EXP 61
66730: PUSH
66731: LD_VAR 0 2
66735: ARRAY
66736: PUSH
66737: LD_INT 2
66739: ARRAY
66740: NOT
66741: AND
66742: IFFALSE 66780
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66744: LD_ADDR_EXP 62
66748: PUSH
66749: LD_EXP 62
66753: PPUSH
66754: LD_VAR 0 2
66758: PPUSH
66759: EMPTY
66760: PPUSH
66761: CALL_OW 1
66765: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66766: LD_VAR 0 2
66770: PPUSH
66771: LD_INT 102
66773: PPUSH
66774: CALL 61057 0 2
// continue ;
66778: GO 66707
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
66780: LD_ADDR_VAR 0 4
66784: PUSH
66785: LD_EXP 58
66789: PUSH
66790: LD_VAR 0 2
66794: ARRAY
66795: PPUSH
66796: LD_INT 25
66798: PUSH
66799: LD_INT 4
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PPUSH
66806: CALL_OW 72
66810: ST_TO_ADDR
// if not tmp then
66811: LD_VAR 0 4
66815: NOT
66816: IFFALSE 66820
// continue ;
66818: GO 66707
// if mc_taming [ i ] then
66820: LD_EXP 89
66824: PUSH
66825: LD_VAR 0 2
66829: ARRAY
66830: IFFALSE 66854
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
66832: LD_ADDR_EXP 89
66836: PUSH
66837: LD_EXP 89
66841: PPUSH
66842: LD_VAR 0 2
66846: PPUSH
66847: EMPTY
66848: PPUSH
66849: CALL_OW 1
66853: ST_TO_ADDR
// for j in tmp do
66854: LD_ADDR_VAR 0 3
66858: PUSH
66859: LD_VAR 0 4
66863: PUSH
66864: FOR_IN
66865: IFFALSE 67088
// begin if IsInUnit ( j ) then
66867: LD_VAR 0 3
66871: PPUSH
66872: CALL_OW 310
66876: IFFALSE 66887
// ComExitBuilding ( j ) ;
66878: LD_VAR 0 3
66882: PPUSH
66883: CALL_OW 122
// if not j in mc_healers [ i ] then
66887: LD_VAR 0 3
66891: PUSH
66892: LD_EXP 62
66896: PUSH
66897: LD_VAR 0 2
66901: ARRAY
66902: IN
66903: NOT
66904: IFFALSE 66950
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
66906: LD_ADDR_EXP 62
66910: PUSH
66911: LD_EXP 62
66915: PPUSH
66916: LD_VAR 0 2
66920: PUSH
66921: LD_EXP 62
66925: PUSH
66926: LD_VAR 0 2
66930: ARRAY
66931: PUSH
66932: LD_INT 1
66934: PLUS
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PPUSH
66940: LD_VAR 0 3
66944: PPUSH
66945: CALL 21054 0 3
66949: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
66950: LD_VAR 0 3
66954: PPUSH
66955: CALL_OW 110
66959: PUSH
66960: LD_INT 102
66962: NONEQUAL
66963: IFFALSE 66977
// SetTag ( j , 102 ) ;
66965: LD_VAR 0 3
66969: PPUSH
66970: LD_INT 102
66972: PPUSH
66973: CALL_OW 109
// Wait ( 3 ) ;
66977: LD_INT 3
66979: PPUSH
66980: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
66984: LD_EXP 61
66988: PUSH
66989: LD_VAR 0 2
66993: ARRAY
66994: PUSH
66995: LD_INT 1
66997: ARRAY
66998: IFFALSE 67030
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67000: LD_VAR 0 3
67004: PPUSH
67005: LD_EXP 61
67009: PUSH
67010: LD_VAR 0 2
67014: ARRAY
67015: PUSH
67016: LD_INT 1
67018: ARRAY
67019: PUSH
67020: LD_INT 1
67022: ARRAY
67023: PPUSH
67024: CALL_OW 128
67028: GO 67086
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67030: LD_VAR 0 3
67034: PPUSH
67035: CALL_OW 314
67039: NOT
67040: PUSH
67041: LD_EXP 61
67045: PUSH
67046: LD_VAR 0 2
67050: ARRAY
67051: PUSH
67052: LD_INT 2
67054: ARRAY
67055: AND
67056: IFFALSE 67086
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67058: LD_VAR 0 3
67062: PPUSH
67063: LD_EXP 61
67067: PUSH
67068: LD_VAR 0 2
67072: ARRAY
67073: PUSH
67074: LD_INT 2
67076: ARRAY
67077: PUSH
67078: LD_INT 1
67080: ARRAY
67081: PPUSH
67082: CALL_OW 128
// end ;
67086: GO 66864
67088: POP
67089: POP
// end ;
67090: GO 66707
67092: POP
67093: POP
// end ;
67094: LD_VAR 0 1
67098: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67099: LD_INT 0
67101: PPUSH
67102: PPUSH
67103: PPUSH
67104: PPUSH
67105: PPUSH
// if not mc_bases then
67106: LD_EXP 58
67110: NOT
67111: IFFALSE 67115
// exit ;
67113: GO 68258
// for i = 1 to mc_bases do
67115: LD_ADDR_VAR 0 2
67119: PUSH
67120: DOUBLE
67121: LD_INT 1
67123: DEC
67124: ST_TO_ADDR
67125: LD_EXP 58
67129: PUSH
67130: FOR_TO
67131: IFFALSE 68256
// begin if mc_scan [ i ] then
67133: LD_EXP 81
67137: PUSH
67138: LD_VAR 0 2
67142: ARRAY
67143: IFFALSE 67147
// continue ;
67145: GO 67130
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67147: LD_EXP 63
67151: PUSH
67152: LD_VAR 0 2
67156: ARRAY
67157: NOT
67158: PUSH
67159: LD_EXP 65
67163: PUSH
67164: LD_VAR 0 2
67168: ARRAY
67169: NOT
67170: AND
67171: PUSH
67172: LD_EXP 64
67176: PUSH
67177: LD_VAR 0 2
67181: ARRAY
67182: AND
67183: IFFALSE 67221
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67185: LD_ADDR_EXP 64
67189: PUSH
67190: LD_EXP 64
67194: PPUSH
67195: LD_VAR 0 2
67199: PPUSH
67200: EMPTY
67201: PPUSH
67202: CALL_OW 1
67206: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67207: LD_VAR 0 2
67211: PPUSH
67212: LD_INT 103
67214: PPUSH
67215: CALL 61057 0 2
// continue ;
67219: GO 67130
// end ; if mc_construct_list [ i ] then
67221: LD_EXP 65
67225: PUSH
67226: LD_VAR 0 2
67230: ARRAY
67231: IFFALSE 67451
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67233: LD_ADDR_VAR 0 4
67237: PUSH
67238: LD_EXP 58
67242: PUSH
67243: LD_VAR 0 2
67247: ARRAY
67248: PPUSH
67249: LD_INT 25
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PPUSH
67259: CALL_OW 72
67263: PUSH
67264: LD_EXP 60
67268: PUSH
67269: LD_VAR 0 2
67273: ARRAY
67274: DIFF
67275: ST_TO_ADDR
// if not tmp then
67276: LD_VAR 0 4
67280: NOT
67281: IFFALSE 67285
// continue ;
67283: GO 67130
// for j in tmp do
67285: LD_ADDR_VAR 0 3
67289: PUSH
67290: LD_VAR 0 4
67294: PUSH
67295: FOR_IN
67296: IFFALSE 67447
// begin if not mc_builders [ i ] then
67298: LD_EXP 64
67302: PUSH
67303: LD_VAR 0 2
67307: ARRAY
67308: NOT
67309: IFFALSE 67367
// begin SetTag ( j , 103 ) ;
67311: LD_VAR 0 3
67315: PPUSH
67316: LD_INT 103
67318: PPUSH
67319: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67323: LD_ADDR_EXP 64
67327: PUSH
67328: LD_EXP 64
67332: PPUSH
67333: LD_VAR 0 2
67337: PUSH
67338: LD_EXP 64
67342: PUSH
67343: LD_VAR 0 2
67347: ARRAY
67348: PUSH
67349: LD_INT 1
67351: PLUS
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PPUSH
67357: LD_VAR 0 3
67361: PPUSH
67362: CALL 21054 0 3
67366: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67367: LD_VAR 0 3
67371: PPUSH
67372: CALL_OW 310
67376: IFFALSE 67387
// ComExitBuilding ( j ) ;
67378: LD_VAR 0 3
67382: PPUSH
67383: CALL_OW 122
// wait ( 3 ) ;
67387: LD_INT 3
67389: PPUSH
67390: CALL_OW 67
// if not mc_construct_list [ i ] then
67394: LD_EXP 65
67398: PUSH
67399: LD_VAR 0 2
67403: ARRAY
67404: NOT
67405: IFFALSE 67409
// break ;
67407: GO 67447
// if not HasTask ( j ) then
67409: LD_VAR 0 3
67413: PPUSH
67414: CALL_OW 314
67418: NOT
67419: IFFALSE 67445
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67421: LD_VAR 0 3
67425: PPUSH
67426: LD_EXP 65
67430: PUSH
67431: LD_VAR 0 2
67435: ARRAY
67436: PUSH
67437: LD_INT 1
67439: ARRAY
67440: PPUSH
67441: CALL 23905 0 2
// end ;
67445: GO 67295
67447: POP
67448: POP
// end else
67449: GO 68254
// if mc_build_list [ i ] then
67451: LD_EXP 63
67455: PUSH
67456: LD_VAR 0 2
67460: ARRAY
67461: IFFALSE 68254
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67463: LD_ADDR_VAR 0 5
67467: PUSH
67468: LD_EXP 58
67472: PUSH
67473: LD_VAR 0 2
67477: ARRAY
67478: PPUSH
67479: LD_INT 2
67481: PUSH
67482: LD_INT 30
67484: PUSH
67485: LD_INT 0
67487: PUSH
67488: EMPTY
67489: LIST
67490: LIST
67491: PUSH
67492: LD_INT 30
67494: PUSH
67495: LD_INT 1
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: PUSH
67502: EMPTY
67503: LIST
67504: LIST
67505: LIST
67506: PPUSH
67507: CALL_OW 72
67511: ST_TO_ADDR
// if depot then
67512: LD_VAR 0 5
67516: IFFALSE 67534
// depot := depot [ 1 ] else
67518: LD_ADDR_VAR 0 5
67522: PUSH
67523: LD_VAR 0 5
67527: PUSH
67528: LD_INT 1
67530: ARRAY
67531: ST_TO_ADDR
67532: GO 67542
// depot := 0 ;
67534: LD_ADDR_VAR 0 5
67538: PUSH
67539: LD_INT 0
67541: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67542: LD_EXP 63
67546: PUSH
67547: LD_VAR 0 2
67551: ARRAY
67552: PUSH
67553: LD_INT 1
67555: ARRAY
67556: PUSH
67557: LD_INT 1
67559: ARRAY
67560: PPUSH
67561: CALL 23735 0 1
67565: PUSH
67566: LD_EXP 58
67570: PUSH
67571: LD_VAR 0 2
67575: ARRAY
67576: PPUSH
67577: LD_INT 2
67579: PUSH
67580: LD_INT 30
67582: PUSH
67583: LD_INT 2
67585: PUSH
67586: EMPTY
67587: LIST
67588: LIST
67589: PUSH
67590: LD_INT 30
67592: PUSH
67593: LD_INT 3
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: EMPTY
67601: LIST
67602: LIST
67603: LIST
67604: PPUSH
67605: CALL_OW 72
67609: NOT
67610: AND
67611: IFFALSE 67716
// begin for j = 1 to mc_build_list [ i ] do
67613: LD_ADDR_VAR 0 3
67617: PUSH
67618: DOUBLE
67619: LD_INT 1
67621: DEC
67622: ST_TO_ADDR
67623: LD_EXP 63
67627: PUSH
67628: LD_VAR 0 2
67632: ARRAY
67633: PUSH
67634: FOR_TO
67635: IFFALSE 67714
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67637: LD_EXP 63
67641: PUSH
67642: LD_VAR 0 2
67646: ARRAY
67647: PUSH
67648: LD_VAR 0 3
67652: ARRAY
67653: PUSH
67654: LD_INT 1
67656: ARRAY
67657: PUSH
67658: LD_INT 2
67660: EQUAL
67661: IFFALSE 67712
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67663: LD_ADDR_EXP 63
67667: PUSH
67668: LD_EXP 63
67672: PPUSH
67673: LD_VAR 0 2
67677: PPUSH
67678: LD_EXP 63
67682: PUSH
67683: LD_VAR 0 2
67687: ARRAY
67688: PPUSH
67689: LD_VAR 0 3
67693: PPUSH
67694: LD_INT 1
67696: PPUSH
67697: LD_INT 0
67699: PPUSH
67700: CALL 20472 0 4
67704: PPUSH
67705: CALL_OW 1
67709: ST_TO_ADDR
// break ;
67710: GO 67714
// end ;
67712: GO 67634
67714: POP
67715: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67716: LD_EXP 63
67720: PUSH
67721: LD_VAR 0 2
67725: ARRAY
67726: PUSH
67727: LD_INT 1
67729: ARRAY
67730: PUSH
67731: LD_INT 1
67733: ARRAY
67734: PUSH
67735: LD_INT 0
67737: EQUAL
67738: PUSH
67739: LD_VAR 0 5
67743: PUSH
67744: LD_VAR 0 5
67748: PPUSH
67749: LD_EXP 63
67753: PUSH
67754: LD_VAR 0 2
67758: ARRAY
67759: PUSH
67760: LD_INT 1
67762: ARRAY
67763: PUSH
67764: LD_INT 1
67766: ARRAY
67767: PPUSH
67768: LD_EXP 63
67772: PUSH
67773: LD_VAR 0 2
67777: ARRAY
67778: PUSH
67779: LD_INT 1
67781: ARRAY
67782: PUSH
67783: LD_INT 2
67785: ARRAY
67786: PPUSH
67787: LD_EXP 63
67791: PUSH
67792: LD_VAR 0 2
67796: ARRAY
67797: PUSH
67798: LD_INT 1
67800: ARRAY
67801: PUSH
67802: LD_INT 3
67804: ARRAY
67805: PPUSH
67806: LD_EXP 63
67810: PUSH
67811: LD_VAR 0 2
67815: ARRAY
67816: PUSH
67817: LD_INT 1
67819: ARRAY
67820: PUSH
67821: LD_INT 4
67823: ARRAY
67824: PPUSH
67825: CALL 28469 0 5
67829: AND
67830: OR
67831: IFFALSE 68112
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67833: LD_ADDR_VAR 0 4
67837: PUSH
67838: LD_EXP 58
67842: PUSH
67843: LD_VAR 0 2
67847: ARRAY
67848: PPUSH
67849: LD_INT 25
67851: PUSH
67852: LD_INT 2
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PPUSH
67859: CALL_OW 72
67863: PUSH
67864: LD_EXP 60
67868: PUSH
67869: LD_VAR 0 2
67873: ARRAY
67874: DIFF
67875: ST_TO_ADDR
// if not tmp then
67876: LD_VAR 0 4
67880: NOT
67881: IFFALSE 67885
// continue ;
67883: GO 67130
// for j in tmp do
67885: LD_ADDR_VAR 0 3
67889: PUSH
67890: LD_VAR 0 4
67894: PUSH
67895: FOR_IN
67896: IFFALSE 68108
// begin if not mc_builders [ i ] then
67898: LD_EXP 64
67902: PUSH
67903: LD_VAR 0 2
67907: ARRAY
67908: NOT
67909: IFFALSE 67967
// begin SetTag ( j , 103 ) ;
67911: LD_VAR 0 3
67915: PPUSH
67916: LD_INT 103
67918: PPUSH
67919: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67923: LD_ADDR_EXP 64
67927: PUSH
67928: LD_EXP 64
67932: PPUSH
67933: LD_VAR 0 2
67937: PUSH
67938: LD_EXP 64
67942: PUSH
67943: LD_VAR 0 2
67947: ARRAY
67948: PUSH
67949: LD_INT 1
67951: PLUS
67952: PUSH
67953: EMPTY
67954: LIST
67955: LIST
67956: PPUSH
67957: LD_VAR 0 3
67961: PPUSH
67962: CALL 21054 0 3
67966: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67967: LD_VAR 0 3
67971: PPUSH
67972: CALL_OW 310
67976: IFFALSE 67987
// ComExitBuilding ( j ) ;
67978: LD_VAR 0 3
67982: PPUSH
67983: CALL_OW 122
// wait ( 3 ) ;
67987: LD_INT 3
67989: PPUSH
67990: CALL_OW 67
// if not mc_build_list [ i ] then
67994: LD_EXP 63
67998: PUSH
67999: LD_VAR 0 2
68003: ARRAY
68004: NOT
68005: IFFALSE 68009
// break ;
68007: GO 68108
// if not HasTask ( j ) then
68009: LD_VAR 0 3
68013: PPUSH
68014: CALL_OW 314
68018: NOT
68019: IFFALSE 68106
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68021: LD_VAR 0 3
68025: PPUSH
68026: LD_EXP 63
68030: PUSH
68031: LD_VAR 0 2
68035: ARRAY
68036: PUSH
68037: LD_INT 1
68039: ARRAY
68040: PUSH
68041: LD_INT 1
68043: ARRAY
68044: PPUSH
68045: LD_EXP 63
68049: PUSH
68050: LD_VAR 0 2
68054: ARRAY
68055: PUSH
68056: LD_INT 1
68058: ARRAY
68059: PUSH
68060: LD_INT 2
68062: ARRAY
68063: PPUSH
68064: LD_EXP 63
68068: PUSH
68069: LD_VAR 0 2
68073: ARRAY
68074: PUSH
68075: LD_INT 1
68077: ARRAY
68078: PUSH
68079: LD_INT 3
68081: ARRAY
68082: PPUSH
68083: LD_EXP 63
68087: PUSH
68088: LD_VAR 0 2
68092: ARRAY
68093: PUSH
68094: LD_INT 1
68096: ARRAY
68097: PUSH
68098: LD_INT 4
68100: ARRAY
68101: PPUSH
68102: CALL_OW 145
// end ;
68106: GO 67895
68108: POP
68109: POP
// end else
68110: GO 68254
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68112: LD_EXP 58
68116: PUSH
68117: LD_VAR 0 2
68121: ARRAY
68122: PPUSH
68123: LD_EXP 63
68127: PUSH
68128: LD_VAR 0 2
68132: ARRAY
68133: PUSH
68134: LD_INT 1
68136: ARRAY
68137: PUSH
68138: LD_INT 1
68140: ARRAY
68141: PPUSH
68142: LD_EXP 63
68146: PUSH
68147: LD_VAR 0 2
68151: ARRAY
68152: PUSH
68153: LD_INT 1
68155: ARRAY
68156: PUSH
68157: LD_INT 2
68159: ARRAY
68160: PPUSH
68161: LD_EXP 63
68165: PUSH
68166: LD_VAR 0 2
68170: ARRAY
68171: PUSH
68172: LD_INT 1
68174: ARRAY
68175: PUSH
68176: LD_INT 3
68178: ARRAY
68179: PPUSH
68180: LD_EXP 63
68184: PUSH
68185: LD_VAR 0 2
68189: ARRAY
68190: PUSH
68191: LD_INT 1
68193: ARRAY
68194: PUSH
68195: LD_INT 4
68197: ARRAY
68198: PPUSH
68199: CALL 27805 0 5
68203: NOT
68204: IFFALSE 68254
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68206: LD_ADDR_EXP 63
68210: PUSH
68211: LD_EXP 63
68215: PPUSH
68216: LD_VAR 0 2
68220: PPUSH
68221: LD_EXP 63
68225: PUSH
68226: LD_VAR 0 2
68230: ARRAY
68231: PPUSH
68232: LD_INT 1
68234: PPUSH
68235: LD_INT 1
68237: NEG
68238: PPUSH
68239: LD_INT 0
68241: PPUSH
68242: CALL 20472 0 4
68246: PPUSH
68247: CALL_OW 1
68251: ST_TO_ADDR
// continue ;
68252: GO 67130
// end ; end ; end ;
68254: GO 67130
68256: POP
68257: POP
// end ;
68258: LD_VAR 0 1
68262: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68263: LD_INT 0
68265: PPUSH
68266: PPUSH
68267: PPUSH
68268: PPUSH
68269: PPUSH
68270: PPUSH
// if not mc_bases then
68271: LD_EXP 58
68275: NOT
68276: IFFALSE 68280
// exit ;
68278: GO 68707
// for i = 1 to mc_bases do
68280: LD_ADDR_VAR 0 2
68284: PUSH
68285: DOUBLE
68286: LD_INT 1
68288: DEC
68289: ST_TO_ADDR
68290: LD_EXP 58
68294: PUSH
68295: FOR_TO
68296: IFFALSE 68705
// begin tmp := mc_build_upgrade [ i ] ;
68298: LD_ADDR_VAR 0 4
68302: PUSH
68303: LD_EXP 90
68307: PUSH
68308: LD_VAR 0 2
68312: ARRAY
68313: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68314: LD_ADDR_VAR 0 6
68318: PUSH
68319: LD_EXP 91
68323: PUSH
68324: LD_VAR 0 2
68328: ARRAY
68329: PPUSH
68330: LD_INT 2
68332: PUSH
68333: LD_INT 30
68335: PUSH
68336: LD_INT 6
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 30
68345: PUSH
68346: LD_INT 7
68348: PUSH
68349: EMPTY
68350: LIST
68351: LIST
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: LIST
68357: PPUSH
68358: CALL_OW 72
68362: ST_TO_ADDR
// if not tmp and not lab then
68363: LD_VAR 0 4
68367: NOT
68368: PUSH
68369: LD_VAR 0 6
68373: NOT
68374: AND
68375: IFFALSE 68379
// continue ;
68377: GO 68295
// if tmp then
68379: LD_VAR 0 4
68383: IFFALSE 68503
// for j in tmp do
68385: LD_ADDR_VAR 0 3
68389: PUSH
68390: LD_VAR 0 4
68394: PUSH
68395: FOR_IN
68396: IFFALSE 68501
// begin if UpgradeCost ( j ) then
68398: LD_VAR 0 3
68402: PPUSH
68403: CALL 27465 0 1
68407: IFFALSE 68499
// begin ComUpgrade ( j ) ;
68409: LD_VAR 0 3
68413: PPUSH
68414: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68418: LD_ADDR_EXP 90
68422: PUSH
68423: LD_EXP 90
68427: PPUSH
68428: LD_VAR 0 2
68432: PPUSH
68433: LD_EXP 90
68437: PUSH
68438: LD_VAR 0 2
68442: ARRAY
68443: PUSH
68444: LD_VAR 0 3
68448: DIFF
68449: PPUSH
68450: CALL_OW 1
68454: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68455: LD_ADDR_EXP 65
68459: PUSH
68460: LD_EXP 65
68464: PPUSH
68465: LD_VAR 0 2
68469: PUSH
68470: LD_EXP 65
68474: PUSH
68475: LD_VAR 0 2
68479: ARRAY
68480: PUSH
68481: LD_INT 1
68483: PLUS
68484: PUSH
68485: EMPTY
68486: LIST
68487: LIST
68488: PPUSH
68489: LD_VAR 0 3
68493: PPUSH
68494: CALL 21054 0 3
68498: ST_TO_ADDR
// end ; end ;
68499: GO 68395
68501: POP
68502: POP
// if not lab or not mc_lab_upgrade [ i ] then
68503: LD_VAR 0 6
68507: NOT
68508: PUSH
68509: LD_EXP 92
68513: PUSH
68514: LD_VAR 0 2
68518: ARRAY
68519: NOT
68520: OR
68521: IFFALSE 68525
// continue ;
68523: GO 68295
// for j in lab do
68525: LD_ADDR_VAR 0 3
68529: PUSH
68530: LD_VAR 0 6
68534: PUSH
68535: FOR_IN
68536: IFFALSE 68701
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68538: LD_VAR 0 3
68542: PPUSH
68543: CALL_OW 266
68547: PUSH
68548: LD_INT 6
68550: PUSH
68551: LD_INT 7
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: IN
68558: PUSH
68559: LD_VAR 0 3
68563: PPUSH
68564: CALL_OW 461
68568: PUSH
68569: LD_INT 1
68571: NONEQUAL
68572: AND
68573: IFFALSE 68699
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68575: LD_VAR 0 3
68579: PPUSH
68580: LD_EXP 92
68584: PUSH
68585: LD_VAR 0 2
68589: ARRAY
68590: PUSH
68591: LD_INT 1
68593: ARRAY
68594: PPUSH
68595: CALL 27670 0 2
68599: IFFALSE 68699
// begin ComCancel ( j ) ;
68601: LD_VAR 0 3
68605: PPUSH
68606: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68610: LD_VAR 0 3
68614: PPUSH
68615: LD_EXP 92
68619: PUSH
68620: LD_VAR 0 2
68624: ARRAY
68625: PUSH
68626: LD_INT 1
68628: ARRAY
68629: PPUSH
68630: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68634: LD_VAR 0 3
68638: PUSH
68639: LD_EXP 65
68643: PUSH
68644: LD_VAR 0 2
68648: ARRAY
68649: IN
68650: NOT
68651: IFFALSE 68697
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68653: LD_ADDR_EXP 65
68657: PUSH
68658: LD_EXP 65
68662: PPUSH
68663: LD_VAR 0 2
68667: PUSH
68668: LD_EXP 65
68672: PUSH
68673: LD_VAR 0 2
68677: ARRAY
68678: PUSH
68679: LD_INT 1
68681: PLUS
68682: PUSH
68683: EMPTY
68684: LIST
68685: LIST
68686: PPUSH
68687: LD_VAR 0 3
68691: PPUSH
68692: CALL 21054 0 3
68696: ST_TO_ADDR
// break ;
68697: GO 68701
// end ; end ; end ;
68699: GO 68535
68701: POP
68702: POP
// end ;
68703: GO 68295
68705: POP
68706: POP
// end ;
68707: LD_VAR 0 1
68711: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68712: LD_INT 0
68714: PPUSH
68715: PPUSH
68716: PPUSH
68717: PPUSH
68718: PPUSH
68719: PPUSH
68720: PPUSH
68721: PPUSH
68722: PPUSH
// if not mc_bases then
68723: LD_EXP 58
68727: NOT
68728: IFFALSE 68732
// exit ;
68730: GO 69137
// for i = 1 to mc_bases do
68732: LD_ADDR_VAR 0 2
68736: PUSH
68737: DOUBLE
68738: LD_INT 1
68740: DEC
68741: ST_TO_ADDR
68742: LD_EXP 58
68746: PUSH
68747: FOR_TO
68748: IFFALSE 69135
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68750: LD_EXP 66
68754: PUSH
68755: LD_VAR 0 2
68759: ARRAY
68760: NOT
68761: PUSH
68762: LD_EXP 58
68766: PUSH
68767: LD_VAR 0 2
68771: ARRAY
68772: PPUSH
68773: LD_INT 30
68775: PUSH
68776: LD_INT 3
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PPUSH
68783: CALL_OW 72
68787: NOT
68788: OR
68789: IFFALSE 68793
// continue ;
68791: GO 68747
// busy := false ;
68793: LD_ADDR_VAR 0 8
68797: PUSH
68798: LD_INT 0
68800: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68801: LD_ADDR_VAR 0 4
68805: PUSH
68806: LD_EXP 58
68810: PUSH
68811: LD_VAR 0 2
68815: ARRAY
68816: PPUSH
68817: LD_INT 30
68819: PUSH
68820: LD_INT 3
68822: PUSH
68823: EMPTY
68824: LIST
68825: LIST
68826: PPUSH
68827: CALL_OW 72
68831: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
68832: LD_ADDR_VAR 0 6
68836: PUSH
68837: LD_EXP 66
68841: PUSH
68842: LD_VAR 0 2
68846: ARRAY
68847: PPUSH
68848: LD_INT 2
68850: PUSH
68851: LD_INT 30
68853: PUSH
68854: LD_INT 32
68856: PUSH
68857: EMPTY
68858: LIST
68859: LIST
68860: PUSH
68861: LD_INT 30
68863: PUSH
68864: LD_INT 33
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: LIST
68875: PPUSH
68876: CALL_OW 72
68880: ST_TO_ADDR
// if not t then
68881: LD_VAR 0 6
68885: NOT
68886: IFFALSE 68890
// continue ;
68888: GO 68747
// for j in tmp do
68890: LD_ADDR_VAR 0 3
68894: PUSH
68895: LD_VAR 0 4
68899: PUSH
68900: FOR_IN
68901: IFFALSE 68931
// if not BuildingStatus ( j ) = bs_idle then
68903: LD_VAR 0 3
68907: PPUSH
68908: CALL_OW 461
68912: PUSH
68913: LD_INT 2
68915: EQUAL
68916: NOT
68917: IFFALSE 68929
// begin busy := true ;
68919: LD_ADDR_VAR 0 8
68923: PUSH
68924: LD_INT 1
68926: ST_TO_ADDR
// break ;
68927: GO 68931
// end ;
68929: GO 68900
68931: POP
68932: POP
// if busy then
68933: LD_VAR 0 8
68937: IFFALSE 68941
// continue ;
68939: GO 68747
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
68941: LD_ADDR_VAR 0 7
68945: PUSH
68946: LD_VAR 0 6
68950: PPUSH
68951: LD_INT 35
68953: PUSH
68954: LD_INT 0
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PPUSH
68961: CALL_OW 72
68965: ST_TO_ADDR
// if tw then
68966: LD_VAR 0 7
68970: IFFALSE 69047
// begin tw := tw [ 1 ] ;
68972: LD_ADDR_VAR 0 7
68976: PUSH
68977: LD_VAR 0 7
68981: PUSH
68982: LD_INT 1
68984: ARRAY
68985: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
68986: LD_ADDR_VAR 0 9
68990: PUSH
68991: LD_VAR 0 7
68995: PPUSH
68996: LD_EXP 83
69000: PUSH
69001: LD_VAR 0 2
69005: ARRAY
69006: PPUSH
69007: CALL 26024 0 2
69011: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69012: LD_EXP 97
69016: PUSH
69017: LD_VAR 0 2
69021: ARRAY
69022: IFFALSE 69045
// if not weapon in mc_allowed_tower_weapons [ i ] then
69024: LD_VAR 0 9
69028: PUSH
69029: LD_EXP 97
69033: PUSH
69034: LD_VAR 0 2
69038: ARRAY
69039: IN
69040: NOT
69041: IFFALSE 69045
// continue ;
69043: GO 68747
// end else
69045: GO 69110
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69047: LD_ADDR_VAR 0 5
69051: PUSH
69052: LD_EXP 66
69056: PUSH
69057: LD_VAR 0 2
69061: ARRAY
69062: PPUSH
69063: LD_VAR 0 4
69067: PPUSH
69068: CALL 56225 0 2
69072: ST_TO_ADDR
// if not tmp2 then
69073: LD_VAR 0 5
69077: NOT
69078: IFFALSE 69082
// continue ;
69080: GO 68747
// tw := tmp2 [ 1 ] ;
69082: LD_ADDR_VAR 0 7
69086: PUSH
69087: LD_VAR 0 5
69091: PUSH
69092: LD_INT 1
69094: ARRAY
69095: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69096: LD_ADDR_VAR 0 9
69100: PUSH
69101: LD_VAR 0 5
69105: PUSH
69106: LD_INT 2
69108: ARRAY
69109: ST_TO_ADDR
// end ; if not weapon then
69110: LD_VAR 0 9
69114: NOT
69115: IFFALSE 69119
// continue ;
69117: GO 68747
// ComPlaceWeapon ( tw , weapon ) ;
69119: LD_VAR 0 7
69123: PPUSH
69124: LD_VAR 0 9
69128: PPUSH
69129: CALL_OW 148
// end ;
69133: GO 68747
69135: POP
69136: POP
// end ;
69137: LD_VAR 0 1
69141: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69142: LD_INT 0
69144: PPUSH
69145: PPUSH
69146: PPUSH
69147: PPUSH
69148: PPUSH
69149: PPUSH
// if not mc_bases then
69150: LD_EXP 58
69154: NOT
69155: IFFALSE 69159
// exit ;
69157: GO 70171
// for i = 1 to mc_bases do
69159: LD_ADDR_VAR 0 2
69163: PUSH
69164: DOUBLE
69165: LD_INT 1
69167: DEC
69168: ST_TO_ADDR
69169: LD_EXP 58
69173: PUSH
69174: FOR_TO
69175: IFFALSE 70169
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
69177: LD_EXP 71
69181: PUSH
69182: LD_VAR 0 2
69186: ARRAY
69187: NOT
69188: PUSH
69189: LD_EXP 71
69193: PUSH
69194: LD_VAR 0 2
69198: ARRAY
69199: PUSH
69200: LD_EXP 72
69204: PUSH
69205: LD_VAR 0 2
69209: ARRAY
69210: EQUAL
69211: OR
69212: IFFALSE 69216
// continue ;
69214: GO 69174
// if mc_miners [ i ] then
69216: LD_EXP 72
69220: PUSH
69221: LD_VAR 0 2
69225: ARRAY
69226: IFFALSE 69856
// begin k := 1 ;
69228: LD_ADDR_VAR 0 4
69232: PUSH
69233: LD_INT 1
69235: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69236: LD_ADDR_VAR 0 3
69240: PUSH
69241: DOUBLE
69242: LD_EXP 72
69246: PUSH
69247: LD_VAR 0 2
69251: ARRAY
69252: INC
69253: ST_TO_ADDR
69254: LD_INT 1
69256: PUSH
69257: FOR_DOWNTO
69258: IFFALSE 69854
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69260: LD_EXP 72
69264: PUSH
69265: LD_VAR 0 2
69269: ARRAY
69270: PUSH
69271: LD_VAR 0 3
69275: ARRAY
69276: PPUSH
69277: CALL_OW 301
69281: PUSH
69282: LD_EXP 72
69286: PUSH
69287: LD_VAR 0 2
69291: ARRAY
69292: PUSH
69293: LD_VAR 0 3
69297: ARRAY
69298: PPUSH
69299: CALL_OW 257
69303: PUSH
69304: LD_INT 1
69306: NONEQUAL
69307: OR
69308: IFFALSE 69371
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69310: LD_ADDR_VAR 0 5
69314: PUSH
69315: LD_EXP 72
69319: PUSH
69320: LD_VAR 0 2
69324: ARRAY
69325: PUSH
69326: LD_EXP 72
69330: PUSH
69331: LD_VAR 0 2
69335: ARRAY
69336: PUSH
69337: LD_VAR 0 3
69341: ARRAY
69342: DIFF
69343: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69344: LD_ADDR_EXP 72
69348: PUSH
69349: LD_EXP 72
69353: PPUSH
69354: LD_VAR 0 2
69358: PPUSH
69359: LD_VAR 0 5
69363: PPUSH
69364: CALL_OW 1
69368: ST_TO_ADDR
// continue ;
69369: GO 69257
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69371: LD_EXP 72
69375: PUSH
69376: LD_VAR 0 2
69380: ARRAY
69381: PUSH
69382: LD_VAR 0 3
69386: ARRAY
69387: PPUSH
69388: CALL 20990 0 1
69392: PUSH
69393: LD_EXP 72
69397: PUSH
69398: LD_VAR 0 2
69402: ARRAY
69403: PUSH
69404: LD_VAR 0 3
69408: ARRAY
69409: PPUSH
69410: CALL_OW 255
69414: PPUSH
69415: LD_EXP 71
69419: PUSH
69420: LD_VAR 0 2
69424: ARRAY
69425: PUSH
69426: LD_VAR 0 4
69430: ARRAY
69431: PUSH
69432: LD_INT 1
69434: ARRAY
69435: PPUSH
69436: LD_EXP 71
69440: PUSH
69441: LD_VAR 0 2
69445: ARRAY
69446: PUSH
69447: LD_VAR 0 4
69451: ARRAY
69452: PUSH
69453: LD_INT 2
69455: ARRAY
69456: PPUSH
69457: LD_INT 15
69459: PPUSH
69460: CALL 21950 0 4
69464: PUSH
69465: LD_INT 4
69467: ARRAY
69468: PUSH
69469: LD_EXP 72
69473: PUSH
69474: LD_VAR 0 2
69478: ARRAY
69479: PUSH
69480: LD_VAR 0 3
69484: ARRAY
69485: PPUSH
69486: LD_INT 10
69488: PPUSH
69489: CALL 23647 0 2
69493: PUSH
69494: LD_INT 4
69496: ARRAY
69497: OR
69498: AND
69499: IFFALSE 69522
// ComStop ( mc_miners [ i ] [ j ] ) ;
69501: LD_EXP 72
69505: PUSH
69506: LD_VAR 0 2
69510: ARRAY
69511: PUSH
69512: LD_VAR 0 3
69516: ARRAY
69517: PPUSH
69518: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69522: LD_EXP 72
69526: PUSH
69527: LD_VAR 0 2
69531: ARRAY
69532: PUSH
69533: LD_VAR 0 3
69537: ARRAY
69538: PPUSH
69539: CALL_OW 257
69543: PUSH
69544: LD_INT 1
69546: EQUAL
69547: PUSH
69548: LD_EXP 72
69552: PUSH
69553: LD_VAR 0 2
69557: ARRAY
69558: PUSH
69559: LD_VAR 0 3
69563: ARRAY
69564: PPUSH
69565: CALL_OW 459
69569: NOT
69570: AND
69571: PUSH
69572: LD_EXP 72
69576: PUSH
69577: LD_VAR 0 2
69581: ARRAY
69582: PUSH
69583: LD_VAR 0 3
69587: ARRAY
69588: PPUSH
69589: CALL_OW 255
69593: PPUSH
69594: LD_EXP 71
69598: PUSH
69599: LD_VAR 0 2
69603: ARRAY
69604: PUSH
69605: LD_VAR 0 4
69609: ARRAY
69610: PUSH
69611: LD_INT 1
69613: ARRAY
69614: PPUSH
69615: LD_EXP 71
69619: PUSH
69620: LD_VAR 0 2
69624: ARRAY
69625: PUSH
69626: LD_VAR 0 4
69630: ARRAY
69631: PUSH
69632: LD_INT 2
69634: ARRAY
69635: PPUSH
69636: LD_INT 15
69638: PPUSH
69639: CALL 21950 0 4
69643: PUSH
69644: LD_INT 4
69646: ARRAY
69647: PUSH
69648: LD_INT 0
69650: EQUAL
69651: AND
69652: PUSH
69653: LD_EXP 72
69657: PUSH
69658: LD_VAR 0 2
69662: ARRAY
69663: PUSH
69664: LD_VAR 0 3
69668: ARRAY
69669: PPUSH
69670: CALL_OW 314
69674: NOT
69675: AND
69676: IFFALSE 69852
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69678: LD_EXP 72
69682: PUSH
69683: LD_VAR 0 2
69687: ARRAY
69688: PUSH
69689: LD_VAR 0 3
69693: ARRAY
69694: PPUSH
69695: CALL_OW 310
69699: IFFALSE 69722
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69701: LD_EXP 72
69705: PUSH
69706: LD_VAR 0 2
69710: ARRAY
69711: PUSH
69712: LD_VAR 0 3
69716: ARRAY
69717: PPUSH
69718: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69722: LD_EXP 72
69726: PUSH
69727: LD_VAR 0 2
69731: ARRAY
69732: PUSH
69733: LD_VAR 0 3
69737: ARRAY
69738: PPUSH
69739: CALL_OW 314
69743: NOT
69744: IFFALSE 69812
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
69746: LD_EXP 72
69750: PUSH
69751: LD_VAR 0 2
69755: ARRAY
69756: PUSH
69757: LD_VAR 0 3
69761: ARRAY
69762: PPUSH
69763: LD_EXP 71
69767: PUSH
69768: LD_VAR 0 2
69772: ARRAY
69773: PUSH
69774: LD_VAR 0 4
69778: ARRAY
69779: PUSH
69780: LD_INT 1
69782: ARRAY
69783: PPUSH
69784: LD_EXP 71
69788: PUSH
69789: LD_VAR 0 2
69793: ARRAY
69794: PUSH
69795: LD_VAR 0 4
69799: ARRAY
69800: PUSH
69801: LD_INT 2
69803: ARRAY
69804: PPUSH
69805: LD_INT 0
69807: PPUSH
69808: CALL_OW 193
// k := k + 1 ;
69812: LD_ADDR_VAR 0 4
69816: PUSH
69817: LD_VAR 0 4
69821: PUSH
69822: LD_INT 1
69824: PLUS
69825: ST_TO_ADDR
// if k > mc_mines [ i ] then
69826: LD_VAR 0 4
69830: PUSH
69831: LD_EXP 71
69835: PUSH
69836: LD_VAR 0 2
69840: ARRAY
69841: GREATER
69842: IFFALSE 69852
// k := 1 ;
69844: LD_ADDR_VAR 0 4
69848: PUSH
69849: LD_INT 1
69851: ST_TO_ADDR
// end ; end ;
69852: GO 69257
69854: POP
69855: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
69856: LD_ADDR_VAR 0 5
69860: PUSH
69861: LD_EXP 58
69865: PUSH
69866: LD_VAR 0 2
69870: ARRAY
69871: PPUSH
69872: LD_INT 2
69874: PUSH
69875: LD_INT 30
69877: PUSH
69878: LD_INT 4
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 30
69887: PUSH
69888: LD_INT 5
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 30
69897: PUSH
69898: LD_INT 32
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: EMPTY
69906: LIST
69907: LIST
69908: LIST
69909: LIST
69910: PPUSH
69911: CALL_OW 72
69915: ST_TO_ADDR
// if not tmp then
69916: LD_VAR 0 5
69920: NOT
69921: IFFALSE 69925
// continue ;
69923: GO 69174
// list := [ ] ;
69925: LD_ADDR_VAR 0 6
69929: PUSH
69930: EMPTY
69931: ST_TO_ADDR
// for j in tmp do
69932: LD_ADDR_VAR 0 3
69936: PUSH
69937: LD_VAR 0 5
69941: PUSH
69942: FOR_IN
69943: IFFALSE 70012
// begin for k in UnitsInside ( j ) do
69945: LD_ADDR_VAR 0 4
69949: PUSH
69950: LD_VAR 0 3
69954: PPUSH
69955: CALL_OW 313
69959: PUSH
69960: FOR_IN
69961: IFFALSE 70008
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
69963: LD_VAR 0 4
69967: PPUSH
69968: CALL_OW 257
69972: PUSH
69973: LD_INT 1
69975: EQUAL
69976: PUSH
69977: LD_VAR 0 4
69981: PPUSH
69982: CALL_OW 459
69986: NOT
69987: AND
69988: IFFALSE 70006
// list := list ^ k ;
69990: LD_ADDR_VAR 0 6
69994: PUSH
69995: LD_VAR 0 6
69999: PUSH
70000: LD_VAR 0 4
70004: ADD
70005: ST_TO_ADDR
70006: GO 69960
70008: POP
70009: POP
// end ;
70010: GO 69942
70012: POP
70013: POP
// list := list diff mc_miners [ i ] ;
70014: LD_ADDR_VAR 0 6
70018: PUSH
70019: LD_VAR 0 6
70023: PUSH
70024: LD_EXP 72
70028: PUSH
70029: LD_VAR 0 2
70033: ARRAY
70034: DIFF
70035: ST_TO_ADDR
// if not list then
70036: LD_VAR 0 6
70040: NOT
70041: IFFALSE 70045
// continue ;
70043: GO 69174
// k := mc_mines [ i ] - mc_miners [ i ] ;
70045: LD_ADDR_VAR 0 4
70049: PUSH
70050: LD_EXP 71
70054: PUSH
70055: LD_VAR 0 2
70059: ARRAY
70060: PUSH
70061: LD_EXP 72
70065: PUSH
70066: LD_VAR 0 2
70070: ARRAY
70071: MINUS
70072: ST_TO_ADDR
// if k > list then
70073: LD_VAR 0 4
70077: PUSH
70078: LD_VAR 0 6
70082: GREATER
70083: IFFALSE 70095
// k := list ;
70085: LD_ADDR_VAR 0 4
70089: PUSH
70090: LD_VAR 0 6
70094: ST_TO_ADDR
// for j = 1 to k do
70095: LD_ADDR_VAR 0 3
70099: PUSH
70100: DOUBLE
70101: LD_INT 1
70103: DEC
70104: ST_TO_ADDR
70105: LD_VAR 0 4
70109: PUSH
70110: FOR_TO
70111: IFFALSE 70165
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70113: LD_ADDR_EXP 72
70117: PUSH
70118: LD_EXP 72
70122: PPUSH
70123: LD_VAR 0 2
70127: PUSH
70128: LD_EXP 72
70132: PUSH
70133: LD_VAR 0 2
70137: ARRAY
70138: PUSH
70139: LD_INT 1
70141: PLUS
70142: PUSH
70143: EMPTY
70144: LIST
70145: LIST
70146: PPUSH
70147: LD_VAR 0 6
70151: PUSH
70152: LD_VAR 0 3
70156: ARRAY
70157: PPUSH
70158: CALL 21054 0 3
70162: ST_TO_ADDR
70163: GO 70110
70165: POP
70166: POP
// end ;
70167: GO 69174
70169: POP
70170: POP
// end ;
70171: LD_VAR 0 1
70175: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70176: LD_INT 0
70178: PPUSH
70179: PPUSH
70180: PPUSH
70181: PPUSH
70182: PPUSH
70183: PPUSH
70184: PPUSH
70185: PPUSH
70186: PPUSH
70187: PPUSH
// if not mc_bases then
70188: LD_EXP 58
70192: NOT
70193: IFFALSE 70197
// exit ;
70195: GO 71947
// for i = 1 to mc_bases do
70197: LD_ADDR_VAR 0 2
70201: PUSH
70202: DOUBLE
70203: LD_INT 1
70205: DEC
70206: ST_TO_ADDR
70207: LD_EXP 58
70211: PUSH
70212: FOR_TO
70213: IFFALSE 71945
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70215: LD_EXP 58
70219: PUSH
70220: LD_VAR 0 2
70224: ARRAY
70225: NOT
70226: PUSH
70227: LD_EXP 65
70231: PUSH
70232: LD_VAR 0 2
70236: ARRAY
70237: OR
70238: IFFALSE 70242
// continue ;
70240: GO 70212
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70242: LD_EXP 74
70246: PUSH
70247: LD_VAR 0 2
70251: ARRAY
70252: NOT
70253: PUSH
70254: LD_EXP 75
70258: PUSH
70259: LD_VAR 0 2
70263: ARRAY
70264: AND
70265: IFFALSE 70303
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70267: LD_ADDR_EXP 75
70271: PUSH
70272: LD_EXP 75
70276: PPUSH
70277: LD_VAR 0 2
70281: PPUSH
70282: EMPTY
70283: PPUSH
70284: CALL_OW 1
70288: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70289: LD_VAR 0 2
70293: PPUSH
70294: LD_INT 107
70296: PPUSH
70297: CALL 61057 0 2
// continue ;
70301: GO 70212
// end ; target := [ ] ;
70303: LD_ADDR_VAR 0 6
70307: PUSH
70308: EMPTY
70309: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70310: LD_ADDR_VAR 0 3
70314: PUSH
70315: DOUBLE
70316: LD_EXP 74
70320: PUSH
70321: LD_VAR 0 2
70325: ARRAY
70326: INC
70327: ST_TO_ADDR
70328: LD_INT 1
70330: PUSH
70331: FOR_DOWNTO
70332: IFFALSE 70592
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70334: LD_EXP 74
70338: PUSH
70339: LD_VAR 0 2
70343: ARRAY
70344: PUSH
70345: LD_VAR 0 3
70349: ARRAY
70350: PUSH
70351: LD_INT 2
70353: ARRAY
70354: PPUSH
70355: LD_EXP 74
70359: PUSH
70360: LD_VAR 0 2
70364: ARRAY
70365: PUSH
70366: LD_VAR 0 3
70370: ARRAY
70371: PUSH
70372: LD_INT 3
70374: ARRAY
70375: PPUSH
70376: CALL_OW 488
70380: PUSH
70381: LD_EXP 74
70385: PUSH
70386: LD_VAR 0 2
70390: ARRAY
70391: PUSH
70392: LD_VAR 0 3
70396: ARRAY
70397: PUSH
70398: LD_INT 2
70400: ARRAY
70401: PPUSH
70402: LD_EXP 74
70406: PUSH
70407: LD_VAR 0 2
70411: ARRAY
70412: PUSH
70413: LD_VAR 0 3
70417: ARRAY
70418: PUSH
70419: LD_INT 3
70421: ARRAY
70422: PPUSH
70423: CALL_OW 284
70427: PUSH
70428: LD_INT 0
70430: EQUAL
70431: AND
70432: IFFALSE 70487
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70434: LD_ADDR_VAR 0 5
70438: PUSH
70439: LD_EXP 74
70443: PUSH
70444: LD_VAR 0 2
70448: ARRAY
70449: PPUSH
70450: LD_VAR 0 3
70454: PPUSH
70455: CALL_OW 3
70459: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70460: LD_ADDR_EXP 74
70464: PUSH
70465: LD_EXP 74
70469: PPUSH
70470: LD_VAR 0 2
70474: PPUSH
70475: LD_VAR 0 5
70479: PPUSH
70480: CALL_OW 1
70484: ST_TO_ADDR
// continue ;
70485: GO 70331
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70487: LD_EXP 58
70491: PUSH
70492: LD_VAR 0 2
70496: ARRAY
70497: PUSH
70498: LD_INT 1
70500: ARRAY
70501: PPUSH
70502: CALL_OW 255
70506: PPUSH
70507: LD_EXP 74
70511: PUSH
70512: LD_VAR 0 2
70516: ARRAY
70517: PUSH
70518: LD_VAR 0 3
70522: ARRAY
70523: PUSH
70524: LD_INT 2
70526: ARRAY
70527: PPUSH
70528: LD_EXP 74
70532: PUSH
70533: LD_VAR 0 2
70537: ARRAY
70538: PUSH
70539: LD_VAR 0 3
70543: ARRAY
70544: PUSH
70545: LD_INT 3
70547: ARRAY
70548: PPUSH
70549: LD_INT 30
70551: PPUSH
70552: CALL 21950 0 4
70556: PUSH
70557: LD_INT 4
70559: ARRAY
70560: PUSH
70561: LD_INT 0
70563: EQUAL
70564: IFFALSE 70590
// begin target := mc_crates [ i ] [ j ] ;
70566: LD_ADDR_VAR 0 6
70570: PUSH
70571: LD_EXP 74
70575: PUSH
70576: LD_VAR 0 2
70580: ARRAY
70581: PUSH
70582: LD_VAR 0 3
70586: ARRAY
70587: ST_TO_ADDR
// break ;
70588: GO 70592
// end ; end ;
70590: GO 70331
70592: POP
70593: POP
// if not target then
70594: LD_VAR 0 6
70598: NOT
70599: IFFALSE 70603
// continue ;
70601: GO 70212
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70603: LD_ADDR_VAR 0 7
70607: PUSH
70608: LD_EXP 77
70612: PUSH
70613: LD_VAR 0 2
70617: ARRAY
70618: PPUSH
70619: LD_INT 2
70621: PUSH
70622: LD_INT 3
70624: PUSH
70625: LD_INT 58
70627: PUSH
70628: EMPTY
70629: LIST
70630: PUSH
70631: EMPTY
70632: LIST
70633: LIST
70634: PUSH
70635: LD_INT 61
70637: PUSH
70638: EMPTY
70639: LIST
70640: PUSH
70641: LD_INT 33
70643: PUSH
70644: LD_INT 5
70646: PUSH
70647: EMPTY
70648: LIST
70649: LIST
70650: PUSH
70651: LD_INT 33
70653: PUSH
70654: LD_INT 3
70656: PUSH
70657: EMPTY
70658: LIST
70659: LIST
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 2
70670: PUSH
70671: LD_INT 34
70673: PUSH
70674: LD_INT 32
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 34
70683: PUSH
70684: LD_INT 51
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 34
70693: PUSH
70694: LD_INT 12
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: EMPTY
70702: LIST
70703: LIST
70704: LIST
70705: LIST
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PPUSH
70711: CALL_OW 72
70715: ST_TO_ADDR
// if not cargo then
70716: LD_VAR 0 7
70720: NOT
70721: IFFALSE 71364
// begin if mc_crates_collector [ i ] < 5 then
70723: LD_EXP 75
70727: PUSH
70728: LD_VAR 0 2
70732: ARRAY
70733: PUSH
70734: LD_INT 5
70736: LESS
70737: IFFALSE 71103
// begin if mc_ape [ i ] then
70739: LD_EXP 87
70743: PUSH
70744: LD_VAR 0 2
70748: ARRAY
70749: IFFALSE 70796
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70751: LD_ADDR_VAR 0 5
70755: PUSH
70756: LD_EXP 87
70760: PUSH
70761: LD_VAR 0 2
70765: ARRAY
70766: PPUSH
70767: LD_INT 25
70769: PUSH
70770: LD_INT 16
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 24
70779: PUSH
70780: LD_INT 750
70782: PUSH
70783: EMPTY
70784: LIST
70785: LIST
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PPUSH
70791: CALL_OW 72
70795: ST_TO_ADDR
// if not tmp then
70796: LD_VAR 0 5
70800: NOT
70801: IFFALSE 70848
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
70803: LD_ADDR_VAR 0 5
70807: PUSH
70808: LD_EXP 58
70812: PUSH
70813: LD_VAR 0 2
70817: ARRAY
70818: PPUSH
70819: LD_INT 25
70821: PUSH
70822: LD_INT 2
70824: PUSH
70825: EMPTY
70826: LIST
70827: LIST
70828: PUSH
70829: LD_INT 24
70831: PUSH
70832: LD_INT 750
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: EMPTY
70840: LIST
70841: LIST
70842: PPUSH
70843: CALL_OW 72
70847: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
70848: LD_EXP 87
70852: PUSH
70853: LD_VAR 0 2
70857: ARRAY
70858: PUSH
70859: LD_EXP 58
70863: PUSH
70864: LD_VAR 0 2
70868: ARRAY
70869: PPUSH
70870: LD_INT 25
70872: PUSH
70873: LD_INT 2
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: PUSH
70880: LD_INT 24
70882: PUSH
70883: LD_INT 750
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PPUSH
70894: CALL_OW 72
70898: AND
70899: PUSH
70900: LD_VAR 0 5
70904: PUSH
70905: LD_INT 5
70907: LESS
70908: AND
70909: IFFALSE 70991
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
70911: LD_ADDR_VAR 0 3
70915: PUSH
70916: LD_EXP 58
70920: PUSH
70921: LD_VAR 0 2
70925: ARRAY
70926: PPUSH
70927: LD_INT 25
70929: PUSH
70930: LD_INT 2
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 24
70939: PUSH
70940: LD_INT 750
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: EMPTY
70948: LIST
70949: LIST
70950: PPUSH
70951: CALL_OW 72
70955: PUSH
70956: FOR_IN
70957: IFFALSE 70989
// begin tmp := tmp union j ;
70959: LD_ADDR_VAR 0 5
70963: PUSH
70964: LD_VAR 0 5
70968: PUSH
70969: LD_VAR 0 3
70973: UNION
70974: ST_TO_ADDR
// if tmp >= 5 then
70975: LD_VAR 0 5
70979: PUSH
70980: LD_INT 5
70982: GREATEREQUAL
70983: IFFALSE 70987
// break ;
70985: GO 70989
// end ;
70987: GO 70956
70989: POP
70990: POP
// end ; if not tmp then
70991: LD_VAR 0 5
70995: NOT
70996: IFFALSE 71000
// continue ;
70998: GO 70212
// for j in tmp do
71000: LD_ADDR_VAR 0 3
71004: PUSH
71005: LD_VAR 0 5
71009: PUSH
71010: FOR_IN
71011: IFFALSE 71101
// if not GetTag ( j ) then
71013: LD_VAR 0 3
71017: PPUSH
71018: CALL_OW 110
71022: NOT
71023: IFFALSE 71099
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71025: LD_ADDR_EXP 75
71029: PUSH
71030: LD_EXP 75
71034: PPUSH
71035: LD_VAR 0 2
71039: PUSH
71040: LD_EXP 75
71044: PUSH
71045: LD_VAR 0 2
71049: ARRAY
71050: PUSH
71051: LD_INT 1
71053: PLUS
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PPUSH
71059: LD_VAR 0 3
71063: PPUSH
71064: CALL 21054 0 3
71068: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71069: LD_VAR 0 3
71073: PPUSH
71074: LD_INT 107
71076: PPUSH
71077: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71081: LD_EXP 75
71085: PUSH
71086: LD_VAR 0 2
71090: ARRAY
71091: PUSH
71092: LD_INT 5
71094: GREATEREQUAL
71095: IFFALSE 71099
// break ;
71097: GO 71101
// end ;
71099: GO 71010
71101: POP
71102: POP
// end ; if mc_crates_collector [ i ] and target then
71103: LD_EXP 75
71107: PUSH
71108: LD_VAR 0 2
71112: ARRAY
71113: PUSH
71114: LD_VAR 0 6
71118: AND
71119: IFFALSE 71362
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71121: LD_EXP 75
71125: PUSH
71126: LD_VAR 0 2
71130: ARRAY
71131: PUSH
71132: LD_VAR 0 6
71136: PUSH
71137: LD_INT 1
71139: ARRAY
71140: LESS
71141: IFFALSE 71161
// tmp := mc_crates_collector [ i ] else
71143: LD_ADDR_VAR 0 5
71147: PUSH
71148: LD_EXP 75
71152: PUSH
71153: LD_VAR 0 2
71157: ARRAY
71158: ST_TO_ADDR
71159: GO 71175
// tmp := target [ 1 ] ;
71161: LD_ADDR_VAR 0 5
71165: PUSH
71166: LD_VAR 0 6
71170: PUSH
71171: LD_INT 1
71173: ARRAY
71174: ST_TO_ADDR
// k := 0 ;
71175: LD_ADDR_VAR 0 4
71179: PUSH
71180: LD_INT 0
71182: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71183: LD_ADDR_VAR 0 3
71187: PUSH
71188: LD_EXP 75
71192: PUSH
71193: LD_VAR 0 2
71197: ARRAY
71198: PUSH
71199: FOR_IN
71200: IFFALSE 71360
// begin k := k + 1 ;
71202: LD_ADDR_VAR 0 4
71206: PUSH
71207: LD_VAR 0 4
71211: PUSH
71212: LD_INT 1
71214: PLUS
71215: ST_TO_ADDR
// if k > tmp then
71216: LD_VAR 0 4
71220: PUSH
71221: LD_VAR 0 5
71225: GREATER
71226: IFFALSE 71230
// break ;
71228: GO 71360
// if not GetClass ( j ) in [ 2 , 16 ] then
71230: LD_VAR 0 3
71234: PPUSH
71235: CALL_OW 257
71239: PUSH
71240: LD_INT 2
71242: PUSH
71243: LD_INT 16
71245: PUSH
71246: EMPTY
71247: LIST
71248: LIST
71249: IN
71250: NOT
71251: IFFALSE 71304
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71253: LD_ADDR_EXP 75
71257: PUSH
71258: LD_EXP 75
71262: PPUSH
71263: LD_VAR 0 2
71267: PPUSH
71268: LD_EXP 75
71272: PUSH
71273: LD_VAR 0 2
71277: ARRAY
71278: PUSH
71279: LD_VAR 0 3
71283: DIFF
71284: PPUSH
71285: CALL_OW 1
71289: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71290: LD_VAR 0 3
71294: PPUSH
71295: LD_INT 0
71297: PPUSH
71298: CALL_OW 109
// continue ;
71302: GO 71199
// end ; if IsInUnit ( j ) then
71304: LD_VAR 0 3
71308: PPUSH
71309: CALL_OW 310
71313: IFFALSE 71324
// ComExitBuilding ( j ) ;
71315: LD_VAR 0 3
71319: PPUSH
71320: CALL_OW 122
// wait ( 3 ) ;
71324: LD_INT 3
71326: PPUSH
71327: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71331: LD_VAR 0 3
71335: PPUSH
71336: LD_VAR 0 6
71340: PUSH
71341: LD_INT 2
71343: ARRAY
71344: PPUSH
71345: LD_VAR 0 6
71349: PUSH
71350: LD_INT 3
71352: ARRAY
71353: PPUSH
71354: CALL_OW 117
// end ;
71358: GO 71199
71360: POP
71361: POP
// end ; end else
71362: GO 71943
// begin for j in cargo do
71364: LD_ADDR_VAR 0 3
71368: PUSH
71369: LD_VAR 0 7
71373: PUSH
71374: FOR_IN
71375: IFFALSE 71941
// begin if GetTag ( j ) <> 0 then
71377: LD_VAR 0 3
71381: PPUSH
71382: CALL_OW 110
71386: PUSH
71387: LD_INT 0
71389: NONEQUAL
71390: IFFALSE 71394
// continue ;
71392: GO 71374
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71394: LD_VAR 0 3
71398: PPUSH
71399: CALL_OW 256
71403: PUSH
71404: LD_INT 1000
71406: LESS
71407: PUSH
71408: LD_VAR 0 3
71412: PPUSH
71413: LD_EXP 82
71417: PUSH
71418: LD_VAR 0 2
71422: ARRAY
71423: PPUSH
71424: CALL_OW 308
71428: NOT
71429: AND
71430: IFFALSE 71452
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71432: LD_VAR 0 3
71436: PPUSH
71437: LD_EXP 82
71441: PUSH
71442: LD_VAR 0 2
71446: ARRAY
71447: PPUSH
71448: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71452: LD_VAR 0 3
71456: PPUSH
71457: CALL_OW 256
71461: PUSH
71462: LD_INT 1000
71464: LESS
71465: PUSH
71466: LD_VAR 0 3
71470: PPUSH
71471: LD_EXP 82
71475: PUSH
71476: LD_VAR 0 2
71480: ARRAY
71481: PPUSH
71482: CALL_OW 308
71486: AND
71487: IFFALSE 71491
// continue ;
71489: GO 71374
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71491: LD_VAR 0 3
71495: PPUSH
71496: CALL_OW 262
71500: PUSH
71501: LD_INT 2
71503: EQUAL
71504: PUSH
71505: LD_VAR 0 3
71509: PPUSH
71510: CALL_OW 261
71514: PUSH
71515: LD_INT 15
71517: LESS
71518: AND
71519: IFFALSE 71523
// continue ;
71521: GO 71374
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71523: LD_VAR 0 3
71527: PPUSH
71528: CALL_OW 262
71532: PUSH
71533: LD_INT 1
71535: EQUAL
71536: PUSH
71537: LD_VAR 0 3
71541: PPUSH
71542: CALL_OW 261
71546: PUSH
71547: LD_INT 10
71549: LESS
71550: AND
71551: IFFALSE 71880
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71553: LD_ADDR_VAR 0 8
71557: PUSH
71558: LD_EXP 58
71562: PUSH
71563: LD_VAR 0 2
71567: ARRAY
71568: PPUSH
71569: LD_INT 2
71571: PUSH
71572: LD_INT 30
71574: PUSH
71575: LD_INT 0
71577: PUSH
71578: EMPTY
71579: LIST
71580: LIST
71581: PUSH
71582: LD_INT 30
71584: PUSH
71585: LD_INT 1
71587: PUSH
71588: EMPTY
71589: LIST
71590: LIST
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: LIST
71596: PPUSH
71597: CALL_OW 72
71601: ST_TO_ADDR
// if not depot then
71602: LD_VAR 0 8
71606: NOT
71607: IFFALSE 71611
// continue ;
71609: GO 71374
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71611: LD_VAR 0 3
71615: PPUSH
71616: LD_VAR 0 8
71620: PPUSH
71621: LD_VAR 0 3
71625: PPUSH
71626: CALL_OW 74
71630: PPUSH
71631: CALL_OW 296
71635: PUSH
71636: LD_INT 6
71638: LESS
71639: IFFALSE 71655
// SetFuel ( j , 100 ) else
71641: LD_VAR 0 3
71645: PPUSH
71646: LD_INT 100
71648: PPUSH
71649: CALL_OW 240
71653: GO 71880
// if GetFuel ( j ) = 0 then
71655: LD_VAR 0 3
71659: PPUSH
71660: CALL_OW 261
71664: PUSH
71665: LD_INT 0
71667: EQUAL
71668: IFFALSE 71880
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71670: LD_ADDR_EXP 77
71674: PUSH
71675: LD_EXP 77
71679: PPUSH
71680: LD_VAR 0 2
71684: PPUSH
71685: LD_EXP 77
71689: PUSH
71690: LD_VAR 0 2
71694: ARRAY
71695: PUSH
71696: LD_VAR 0 3
71700: DIFF
71701: PPUSH
71702: CALL_OW 1
71706: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71707: LD_VAR 0 3
71711: PPUSH
71712: CALL_OW 263
71716: PUSH
71717: LD_INT 1
71719: EQUAL
71720: IFFALSE 71736
// ComExitVehicle ( IsInUnit ( j ) ) ;
71722: LD_VAR 0 3
71726: PPUSH
71727: CALL_OW 310
71731: PPUSH
71732: CALL_OW 121
// if GetControl ( j ) = control_remote then
71736: LD_VAR 0 3
71740: PPUSH
71741: CALL_OW 263
71745: PUSH
71746: LD_INT 2
71748: EQUAL
71749: IFFALSE 71760
// ComUnlink ( j ) ;
71751: LD_VAR 0 3
71755: PPUSH
71756: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71760: LD_ADDR_VAR 0 9
71764: PUSH
71765: LD_VAR 0 2
71769: PPUSH
71770: LD_INT 3
71772: PPUSH
71773: CALL 81017 0 2
71777: ST_TO_ADDR
// if fac then
71778: LD_VAR 0 9
71782: IFFALSE 71878
// begin for k in fac do
71784: LD_ADDR_VAR 0 4
71788: PUSH
71789: LD_VAR 0 9
71793: PUSH
71794: FOR_IN
71795: IFFALSE 71876
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
71797: LD_ADDR_VAR 0 10
71801: PUSH
71802: LD_VAR 0 9
71806: PPUSH
71807: LD_VAR 0 3
71811: PPUSH
71812: CALL_OW 265
71816: PPUSH
71817: LD_VAR 0 3
71821: PPUSH
71822: CALL_OW 262
71826: PPUSH
71827: LD_VAR 0 3
71831: PPUSH
71832: CALL_OW 263
71836: PPUSH
71837: LD_VAR 0 3
71841: PPUSH
71842: CALL_OW 264
71846: PPUSH
71847: CALL 18586 0 5
71851: ST_TO_ADDR
// if components then
71852: LD_VAR 0 10
71856: IFFALSE 71874
// begin MC_InsertProduceList ( i , components ) ;
71858: LD_VAR 0 2
71862: PPUSH
71863: LD_VAR 0 10
71867: PPUSH
71868: CALL 80562 0 2
// break ;
71872: GO 71876
// end ; end ;
71874: GO 71794
71876: POP
71877: POP
// end ; continue ;
71878: GO 71374
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
71880: LD_VAR 0 3
71884: PPUSH
71885: LD_INT 1
71887: PPUSH
71888: CALL_OW 289
71892: PUSH
71893: LD_INT 100
71895: LESS
71896: PUSH
71897: LD_VAR 0 3
71901: PPUSH
71902: CALL_OW 314
71906: NOT
71907: AND
71908: IFFALSE 71937
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71910: LD_VAR 0 3
71914: PPUSH
71915: LD_VAR 0 6
71919: PUSH
71920: LD_INT 2
71922: ARRAY
71923: PPUSH
71924: LD_VAR 0 6
71928: PUSH
71929: LD_INT 3
71931: ARRAY
71932: PPUSH
71933: CALL_OW 117
// break ;
71937: GO 71941
// end ;
71939: GO 71374
71941: POP
71942: POP
// end ; end ;
71943: GO 70212
71945: POP
71946: POP
// end ;
71947: LD_VAR 0 1
71951: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
71952: LD_INT 0
71954: PPUSH
71955: PPUSH
71956: PPUSH
71957: PPUSH
// if not mc_bases then
71958: LD_EXP 58
71962: NOT
71963: IFFALSE 71967
// exit ;
71965: GO 72128
// for i = 1 to mc_bases do
71967: LD_ADDR_VAR 0 2
71971: PUSH
71972: DOUBLE
71973: LD_INT 1
71975: DEC
71976: ST_TO_ADDR
71977: LD_EXP 58
71981: PUSH
71982: FOR_TO
71983: IFFALSE 72126
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
71985: LD_ADDR_VAR 0 4
71989: PUSH
71990: LD_EXP 77
71994: PUSH
71995: LD_VAR 0 2
71999: ARRAY
72000: PUSH
72001: LD_EXP 80
72005: PUSH
72006: LD_VAR 0 2
72010: ARRAY
72011: UNION
72012: PPUSH
72013: LD_INT 33
72015: PUSH
72016: LD_INT 2
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PPUSH
72023: CALL_OW 72
72027: ST_TO_ADDR
// if tmp then
72028: LD_VAR 0 4
72032: IFFALSE 72124
// for j in tmp do
72034: LD_ADDR_VAR 0 3
72038: PUSH
72039: LD_VAR 0 4
72043: PUSH
72044: FOR_IN
72045: IFFALSE 72122
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72047: LD_VAR 0 3
72051: PPUSH
72052: CALL_OW 312
72056: NOT
72057: PUSH
72058: LD_VAR 0 3
72062: PPUSH
72063: CALL_OW 256
72067: PUSH
72068: LD_INT 250
72070: GREATEREQUAL
72071: AND
72072: IFFALSE 72085
// Connect ( j ) else
72074: LD_VAR 0 3
72078: PPUSH
72079: CALL 23987 0 1
72083: GO 72120
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72085: LD_VAR 0 3
72089: PPUSH
72090: CALL_OW 256
72094: PUSH
72095: LD_INT 250
72097: LESS
72098: PUSH
72099: LD_VAR 0 3
72103: PPUSH
72104: CALL_OW 312
72108: AND
72109: IFFALSE 72120
// ComUnlink ( j ) ;
72111: LD_VAR 0 3
72115: PPUSH
72116: CALL_OW 136
72120: GO 72044
72122: POP
72123: POP
// end ;
72124: GO 71982
72126: POP
72127: POP
// end ;
72128: LD_VAR 0 1
72132: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72133: LD_INT 0
72135: PPUSH
72136: PPUSH
72137: PPUSH
72138: PPUSH
72139: PPUSH
// if not mc_bases then
72140: LD_EXP 58
72144: NOT
72145: IFFALSE 72149
// exit ;
72147: GO 72594
// for i = 1 to mc_bases do
72149: LD_ADDR_VAR 0 2
72153: PUSH
72154: DOUBLE
72155: LD_INT 1
72157: DEC
72158: ST_TO_ADDR
72159: LD_EXP 58
72163: PUSH
72164: FOR_TO
72165: IFFALSE 72592
// begin if not mc_produce [ i ] then
72167: LD_EXP 79
72171: PUSH
72172: LD_VAR 0 2
72176: ARRAY
72177: NOT
72178: IFFALSE 72182
// continue ;
72180: GO 72164
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72182: LD_ADDR_VAR 0 5
72186: PUSH
72187: LD_EXP 58
72191: PUSH
72192: LD_VAR 0 2
72196: ARRAY
72197: PPUSH
72198: LD_INT 30
72200: PUSH
72201: LD_INT 3
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PPUSH
72208: CALL_OW 72
72212: ST_TO_ADDR
// if not fac then
72213: LD_VAR 0 5
72217: NOT
72218: IFFALSE 72222
// continue ;
72220: GO 72164
// for j in fac do
72222: LD_ADDR_VAR 0 3
72226: PUSH
72227: LD_VAR 0 5
72231: PUSH
72232: FOR_IN
72233: IFFALSE 72588
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72235: LD_VAR 0 3
72239: PPUSH
72240: CALL_OW 461
72244: PUSH
72245: LD_INT 2
72247: NONEQUAL
72248: PUSH
72249: LD_VAR 0 3
72253: PPUSH
72254: LD_INT 15
72256: PPUSH
72257: CALL 23647 0 2
72261: PUSH
72262: LD_INT 4
72264: ARRAY
72265: OR
72266: IFFALSE 72270
// continue ;
72268: GO 72232
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72270: LD_VAR 0 3
72274: PPUSH
72275: LD_EXP 79
72279: PUSH
72280: LD_VAR 0 2
72284: ARRAY
72285: PUSH
72286: LD_INT 1
72288: ARRAY
72289: PUSH
72290: LD_INT 1
72292: ARRAY
72293: PPUSH
72294: LD_EXP 79
72298: PUSH
72299: LD_VAR 0 2
72303: ARRAY
72304: PUSH
72305: LD_INT 1
72307: ARRAY
72308: PUSH
72309: LD_INT 2
72311: ARRAY
72312: PPUSH
72313: LD_EXP 79
72317: PUSH
72318: LD_VAR 0 2
72322: ARRAY
72323: PUSH
72324: LD_INT 1
72326: ARRAY
72327: PUSH
72328: LD_INT 3
72330: ARRAY
72331: PPUSH
72332: LD_EXP 79
72336: PUSH
72337: LD_VAR 0 2
72341: ARRAY
72342: PUSH
72343: LD_INT 1
72345: ARRAY
72346: PUSH
72347: LD_INT 4
72349: ARRAY
72350: PPUSH
72351: CALL_OW 448
72355: PUSH
72356: LD_VAR 0 3
72360: PPUSH
72361: LD_EXP 79
72365: PUSH
72366: LD_VAR 0 2
72370: ARRAY
72371: PUSH
72372: LD_INT 1
72374: ARRAY
72375: PUSH
72376: LD_INT 1
72378: ARRAY
72379: PUSH
72380: LD_EXP 79
72384: PUSH
72385: LD_VAR 0 2
72389: ARRAY
72390: PUSH
72391: LD_INT 1
72393: ARRAY
72394: PUSH
72395: LD_INT 2
72397: ARRAY
72398: PUSH
72399: LD_EXP 79
72403: PUSH
72404: LD_VAR 0 2
72408: ARRAY
72409: PUSH
72410: LD_INT 1
72412: ARRAY
72413: PUSH
72414: LD_INT 3
72416: ARRAY
72417: PUSH
72418: LD_EXP 79
72422: PUSH
72423: LD_VAR 0 2
72427: ARRAY
72428: PUSH
72429: LD_INT 1
72431: ARRAY
72432: PUSH
72433: LD_INT 4
72435: ARRAY
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: PPUSH
72443: CALL 27318 0 2
72447: AND
72448: IFFALSE 72586
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72450: LD_VAR 0 3
72454: PPUSH
72455: LD_EXP 79
72459: PUSH
72460: LD_VAR 0 2
72464: ARRAY
72465: PUSH
72466: LD_INT 1
72468: ARRAY
72469: PUSH
72470: LD_INT 1
72472: ARRAY
72473: PPUSH
72474: LD_EXP 79
72478: PUSH
72479: LD_VAR 0 2
72483: ARRAY
72484: PUSH
72485: LD_INT 1
72487: ARRAY
72488: PUSH
72489: LD_INT 2
72491: ARRAY
72492: PPUSH
72493: LD_EXP 79
72497: PUSH
72498: LD_VAR 0 2
72502: ARRAY
72503: PUSH
72504: LD_INT 1
72506: ARRAY
72507: PUSH
72508: LD_INT 3
72510: ARRAY
72511: PPUSH
72512: LD_EXP 79
72516: PUSH
72517: LD_VAR 0 2
72521: ARRAY
72522: PUSH
72523: LD_INT 1
72525: ARRAY
72526: PUSH
72527: LD_INT 4
72529: ARRAY
72530: PPUSH
72531: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72535: LD_ADDR_VAR 0 4
72539: PUSH
72540: LD_EXP 79
72544: PUSH
72545: LD_VAR 0 2
72549: ARRAY
72550: PPUSH
72551: LD_INT 1
72553: PPUSH
72554: CALL_OW 3
72558: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72559: LD_ADDR_EXP 79
72563: PUSH
72564: LD_EXP 79
72568: PPUSH
72569: LD_VAR 0 2
72573: PPUSH
72574: LD_VAR 0 4
72578: PPUSH
72579: CALL_OW 1
72583: ST_TO_ADDR
// break ;
72584: GO 72588
// end ; end ;
72586: GO 72232
72588: POP
72589: POP
// end ;
72590: GO 72164
72592: POP
72593: POP
// end ;
72594: LD_VAR 0 1
72598: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72599: LD_INT 0
72601: PPUSH
72602: PPUSH
72603: PPUSH
// if not mc_bases then
72604: LD_EXP 58
72608: NOT
72609: IFFALSE 72613
// exit ;
72611: GO 72702
// for i = 1 to mc_bases do
72613: LD_ADDR_VAR 0 2
72617: PUSH
72618: DOUBLE
72619: LD_INT 1
72621: DEC
72622: ST_TO_ADDR
72623: LD_EXP 58
72627: PUSH
72628: FOR_TO
72629: IFFALSE 72700
// begin if mc_attack [ i ] then
72631: LD_EXP 78
72635: PUSH
72636: LD_VAR 0 2
72640: ARRAY
72641: IFFALSE 72698
// begin tmp := mc_attack [ i ] [ 1 ] ;
72643: LD_ADDR_VAR 0 3
72647: PUSH
72648: LD_EXP 78
72652: PUSH
72653: LD_VAR 0 2
72657: ARRAY
72658: PUSH
72659: LD_INT 1
72661: ARRAY
72662: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72663: LD_ADDR_EXP 78
72667: PUSH
72668: LD_EXP 78
72672: PPUSH
72673: LD_VAR 0 2
72677: PPUSH
72678: EMPTY
72679: PPUSH
72680: CALL_OW 1
72684: ST_TO_ADDR
// Attack ( tmp ) ;
72685: LD_VAR 0 3
72689: PPUSH
72690: CALL 49531 0 1
// exit ;
72694: POP
72695: POP
72696: GO 72702
// end ; end ;
72698: GO 72628
72700: POP
72701: POP
// end ;
72702: LD_VAR 0 1
72706: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72707: LD_INT 0
72709: PPUSH
72710: PPUSH
72711: PPUSH
72712: PPUSH
72713: PPUSH
72714: PPUSH
72715: PPUSH
// if not mc_bases then
72716: LD_EXP 58
72720: NOT
72721: IFFALSE 72725
// exit ;
72723: GO 73307
// for i = 1 to mc_bases do
72725: LD_ADDR_VAR 0 2
72729: PUSH
72730: DOUBLE
72731: LD_INT 1
72733: DEC
72734: ST_TO_ADDR
72735: LD_EXP 58
72739: PUSH
72740: FOR_TO
72741: IFFALSE 73305
// begin if not mc_bases [ i ] then
72743: LD_EXP 58
72747: PUSH
72748: LD_VAR 0 2
72752: ARRAY
72753: NOT
72754: IFFALSE 72758
// continue ;
72756: GO 72740
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72758: LD_ADDR_VAR 0 7
72762: PUSH
72763: LD_EXP 58
72767: PUSH
72768: LD_VAR 0 2
72772: ARRAY
72773: PUSH
72774: LD_INT 1
72776: ARRAY
72777: PPUSH
72778: CALL 17890 0 1
72782: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
72783: LD_ADDR_EXP 81
72787: PUSH
72788: LD_EXP 81
72792: PPUSH
72793: LD_VAR 0 2
72797: PPUSH
72798: LD_EXP 58
72802: PUSH
72803: LD_VAR 0 2
72807: ARRAY
72808: PUSH
72809: LD_INT 1
72811: ARRAY
72812: PPUSH
72813: CALL_OW 255
72817: PPUSH
72818: LD_EXP 83
72822: PUSH
72823: LD_VAR 0 2
72827: ARRAY
72828: PPUSH
72829: CALL 15593 0 2
72833: PPUSH
72834: CALL_OW 1
72838: ST_TO_ADDR
// if not mc_scan [ i ] then
72839: LD_EXP 81
72843: PUSH
72844: LD_VAR 0 2
72848: ARRAY
72849: NOT
72850: IFFALSE 73005
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
72852: LD_ADDR_VAR 0 4
72856: PUSH
72857: LD_EXP 58
72861: PUSH
72862: LD_VAR 0 2
72866: ARRAY
72867: PPUSH
72868: LD_INT 2
72870: PUSH
72871: LD_INT 25
72873: PUSH
72874: LD_INT 5
72876: PUSH
72877: EMPTY
72878: LIST
72879: LIST
72880: PUSH
72881: LD_INT 25
72883: PUSH
72884: LD_INT 8
72886: PUSH
72887: EMPTY
72888: LIST
72889: LIST
72890: PUSH
72891: LD_INT 25
72893: PUSH
72894: LD_INT 9
72896: PUSH
72897: EMPTY
72898: LIST
72899: LIST
72900: PUSH
72901: EMPTY
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: PPUSH
72907: CALL_OW 72
72911: ST_TO_ADDR
// if not tmp then
72912: LD_VAR 0 4
72916: NOT
72917: IFFALSE 72921
// continue ;
72919: GO 72740
// for j in tmp do
72921: LD_ADDR_VAR 0 3
72925: PUSH
72926: LD_VAR 0 4
72930: PUSH
72931: FOR_IN
72932: IFFALSE 73003
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
72934: LD_VAR 0 3
72938: PPUSH
72939: CALL_OW 310
72943: PPUSH
72944: CALL_OW 266
72948: PUSH
72949: LD_INT 5
72951: EQUAL
72952: PUSH
72953: LD_VAR 0 3
72957: PPUSH
72958: CALL_OW 257
72962: PUSH
72963: LD_INT 1
72965: EQUAL
72966: AND
72967: PUSH
72968: LD_VAR 0 3
72972: PPUSH
72973: CALL_OW 459
72977: NOT
72978: AND
72979: PUSH
72980: LD_VAR 0 7
72984: AND
72985: IFFALSE 73001
// ComChangeProfession ( j , class ) ;
72987: LD_VAR 0 3
72991: PPUSH
72992: LD_VAR 0 7
72996: PPUSH
72997: CALL_OW 123
73001: GO 72931
73003: POP
73004: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73005: LD_EXP 81
73009: PUSH
73010: LD_VAR 0 2
73014: ARRAY
73015: PUSH
73016: LD_EXP 80
73020: PUSH
73021: LD_VAR 0 2
73025: ARRAY
73026: NOT
73027: AND
73028: PUSH
73029: LD_EXP 58
73033: PUSH
73034: LD_VAR 0 2
73038: ARRAY
73039: PPUSH
73040: LD_INT 30
73042: PUSH
73043: LD_INT 32
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PPUSH
73050: CALL_OW 72
73054: NOT
73055: AND
73056: PUSH
73057: LD_EXP 58
73061: PUSH
73062: LD_VAR 0 2
73066: ARRAY
73067: PPUSH
73068: LD_INT 2
73070: PUSH
73071: LD_INT 30
73073: PUSH
73074: LD_INT 4
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 30
73083: PUSH
73084: LD_INT 5
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: EMPTY
73092: LIST
73093: LIST
73094: LIST
73095: PPUSH
73096: CALL_OW 72
73100: NOT
73101: AND
73102: IFFALSE 73234
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73104: LD_ADDR_VAR 0 4
73108: PUSH
73109: LD_EXP 58
73113: PUSH
73114: LD_VAR 0 2
73118: ARRAY
73119: PPUSH
73120: LD_INT 2
73122: PUSH
73123: LD_INT 25
73125: PUSH
73126: LD_INT 1
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 25
73135: PUSH
73136: LD_INT 5
73138: PUSH
73139: EMPTY
73140: LIST
73141: LIST
73142: PUSH
73143: LD_INT 25
73145: PUSH
73146: LD_INT 8
73148: PUSH
73149: EMPTY
73150: LIST
73151: LIST
73152: PUSH
73153: LD_INT 25
73155: PUSH
73156: LD_INT 9
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: EMPTY
73164: LIST
73165: LIST
73166: LIST
73167: LIST
73168: LIST
73169: PPUSH
73170: CALL_OW 72
73174: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73175: LD_ADDR_VAR 0 4
73179: PUSH
73180: LD_VAR 0 4
73184: PUSH
73185: LD_VAR 0 4
73189: PPUSH
73190: LD_INT 18
73192: PPUSH
73193: CALL 54314 0 2
73197: DIFF
73198: ST_TO_ADDR
// if tmp then
73199: LD_VAR 0 4
73203: IFFALSE 73234
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73205: LD_VAR 0 2
73209: PPUSH
73210: LD_VAR 0 4
73214: PPUSH
73215: LD_EXP 83
73219: PUSH
73220: LD_VAR 0 2
73224: ARRAY
73225: PPUSH
73226: CALL 15628 0 3
// exit ;
73230: POP
73231: POP
73232: GO 73307
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73234: LD_EXP 81
73238: PUSH
73239: LD_VAR 0 2
73243: ARRAY
73244: PUSH
73245: LD_EXP 80
73249: PUSH
73250: LD_VAR 0 2
73254: ARRAY
73255: AND
73256: IFFALSE 73303
// begin tmp := mc_defender [ i ] ;
73258: LD_ADDR_VAR 0 4
73262: PUSH
73263: LD_EXP 80
73267: PUSH
73268: LD_VAR 0 2
73272: ARRAY
73273: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73274: LD_VAR 0 2
73278: PPUSH
73279: LD_VAR 0 4
73283: PPUSH
73284: LD_EXP 81
73288: PUSH
73289: LD_VAR 0 2
73293: ARRAY
73294: PPUSH
73295: CALL 16189 0 3
// exit ;
73299: POP
73300: POP
73301: GO 73307
// end ; end ;
73303: GO 72740
73305: POP
73306: POP
// end ;
73307: LD_VAR 0 1
73311: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73312: LD_INT 0
73314: PPUSH
73315: PPUSH
73316: PPUSH
73317: PPUSH
73318: PPUSH
73319: PPUSH
73320: PPUSH
73321: PPUSH
73322: PPUSH
73323: PPUSH
73324: PPUSH
// if not mc_bases then
73325: LD_EXP 58
73329: NOT
73330: IFFALSE 73334
// exit ;
73332: GO 74421
// for i = 1 to mc_bases do
73334: LD_ADDR_VAR 0 2
73338: PUSH
73339: DOUBLE
73340: LD_INT 1
73342: DEC
73343: ST_TO_ADDR
73344: LD_EXP 58
73348: PUSH
73349: FOR_TO
73350: IFFALSE 74419
// begin tmp := mc_lab [ i ] ;
73352: LD_ADDR_VAR 0 6
73356: PUSH
73357: LD_EXP 91
73361: PUSH
73362: LD_VAR 0 2
73366: ARRAY
73367: ST_TO_ADDR
// if not tmp then
73368: LD_VAR 0 6
73372: NOT
73373: IFFALSE 73377
// continue ;
73375: GO 73349
// idle_lab := 0 ;
73377: LD_ADDR_VAR 0 11
73381: PUSH
73382: LD_INT 0
73384: ST_TO_ADDR
// for j in tmp do
73385: LD_ADDR_VAR 0 3
73389: PUSH
73390: LD_VAR 0 6
73394: PUSH
73395: FOR_IN
73396: IFFALSE 74415
// begin researching := false ;
73398: LD_ADDR_VAR 0 10
73402: PUSH
73403: LD_INT 0
73405: ST_TO_ADDR
// side := GetSide ( j ) ;
73406: LD_ADDR_VAR 0 4
73410: PUSH
73411: LD_VAR 0 3
73415: PPUSH
73416: CALL_OW 255
73420: ST_TO_ADDR
// if not mc_tech [ side ] then
73421: LD_EXP 85
73425: PUSH
73426: LD_VAR 0 4
73430: ARRAY
73431: NOT
73432: IFFALSE 73436
// continue ;
73434: GO 73395
// if BuildingStatus ( j ) = bs_idle then
73436: LD_VAR 0 3
73440: PPUSH
73441: CALL_OW 461
73445: PUSH
73446: LD_INT 2
73448: EQUAL
73449: IFFALSE 73637
// begin if idle_lab and UnitsInside ( j ) < 6 then
73451: LD_VAR 0 11
73455: PUSH
73456: LD_VAR 0 3
73460: PPUSH
73461: CALL_OW 313
73465: PUSH
73466: LD_INT 6
73468: LESS
73469: AND
73470: IFFALSE 73541
// begin tmp2 := UnitsInside ( idle_lab ) ;
73472: LD_ADDR_VAR 0 9
73476: PUSH
73477: LD_VAR 0 11
73481: PPUSH
73482: CALL_OW 313
73486: ST_TO_ADDR
// if tmp2 then
73487: LD_VAR 0 9
73491: IFFALSE 73533
// for x in tmp2 do
73493: LD_ADDR_VAR 0 7
73497: PUSH
73498: LD_VAR 0 9
73502: PUSH
73503: FOR_IN
73504: IFFALSE 73531
// begin ComExitBuilding ( x ) ;
73506: LD_VAR 0 7
73510: PPUSH
73511: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73515: LD_VAR 0 7
73519: PPUSH
73520: LD_VAR 0 3
73524: PPUSH
73525: CALL_OW 180
// end ;
73529: GO 73503
73531: POP
73532: POP
// idle_lab := 0 ;
73533: LD_ADDR_VAR 0 11
73537: PUSH
73538: LD_INT 0
73540: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73541: LD_ADDR_VAR 0 5
73545: PUSH
73546: LD_EXP 85
73550: PUSH
73551: LD_VAR 0 4
73555: ARRAY
73556: PUSH
73557: FOR_IN
73558: IFFALSE 73618
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73560: LD_VAR 0 3
73564: PPUSH
73565: LD_VAR 0 5
73569: PPUSH
73570: CALL_OW 430
73574: PUSH
73575: LD_VAR 0 4
73579: PPUSH
73580: LD_VAR 0 5
73584: PPUSH
73585: CALL 14698 0 2
73589: AND
73590: IFFALSE 73616
// begin researching := true ;
73592: LD_ADDR_VAR 0 10
73596: PUSH
73597: LD_INT 1
73599: ST_TO_ADDR
// ComResearch ( j , t ) ;
73600: LD_VAR 0 3
73604: PPUSH
73605: LD_VAR 0 5
73609: PPUSH
73610: CALL_OW 124
// break ;
73614: GO 73618
// end ;
73616: GO 73557
73618: POP
73619: POP
// if not researching then
73620: LD_VAR 0 10
73624: NOT
73625: IFFALSE 73637
// idle_lab := j ;
73627: LD_ADDR_VAR 0 11
73631: PUSH
73632: LD_VAR 0 3
73636: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73637: LD_VAR 0 3
73641: PPUSH
73642: CALL_OW 461
73646: PUSH
73647: LD_INT 10
73649: EQUAL
73650: IFFALSE 74238
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73652: LD_EXP 87
73656: PUSH
73657: LD_VAR 0 2
73661: ARRAY
73662: NOT
73663: PUSH
73664: LD_EXP 88
73668: PUSH
73669: LD_VAR 0 2
73673: ARRAY
73674: NOT
73675: AND
73676: PUSH
73677: LD_EXP 85
73681: PUSH
73682: LD_VAR 0 4
73686: ARRAY
73687: PUSH
73688: LD_INT 1
73690: GREATER
73691: AND
73692: IFFALSE 73823
// begin ComCancel ( j ) ;
73694: LD_VAR 0 3
73698: PPUSH
73699: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73703: LD_ADDR_EXP 85
73707: PUSH
73708: LD_EXP 85
73712: PPUSH
73713: LD_VAR 0 4
73717: PPUSH
73718: LD_EXP 85
73722: PUSH
73723: LD_VAR 0 4
73727: ARRAY
73728: PPUSH
73729: LD_EXP 85
73733: PUSH
73734: LD_VAR 0 4
73738: ARRAY
73739: PUSH
73740: LD_INT 1
73742: MINUS
73743: PPUSH
73744: LD_EXP 85
73748: PUSH
73749: LD_VAR 0 4
73753: ARRAY
73754: PPUSH
73755: LD_INT 0
73757: PPUSH
73758: CALL 20472 0 4
73762: PPUSH
73763: CALL_OW 1
73767: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73768: LD_ADDR_EXP 85
73772: PUSH
73773: LD_EXP 85
73777: PPUSH
73778: LD_VAR 0 4
73782: PPUSH
73783: LD_EXP 85
73787: PUSH
73788: LD_VAR 0 4
73792: ARRAY
73793: PPUSH
73794: LD_EXP 85
73798: PUSH
73799: LD_VAR 0 4
73803: ARRAY
73804: PPUSH
73805: LD_INT 1
73807: PPUSH
73808: LD_INT 0
73810: PPUSH
73811: CALL 20472 0 4
73815: PPUSH
73816: CALL_OW 1
73820: ST_TO_ADDR
// continue ;
73821: GO 73395
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
73823: LD_EXP 87
73827: PUSH
73828: LD_VAR 0 2
73832: ARRAY
73833: PUSH
73834: LD_EXP 88
73838: PUSH
73839: LD_VAR 0 2
73843: ARRAY
73844: NOT
73845: AND
73846: IFFALSE 73973
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
73848: LD_ADDR_EXP 88
73852: PUSH
73853: LD_EXP 88
73857: PPUSH
73858: LD_VAR 0 2
73862: PUSH
73863: LD_EXP 88
73867: PUSH
73868: LD_VAR 0 2
73872: ARRAY
73873: PUSH
73874: LD_INT 1
73876: PLUS
73877: PUSH
73878: EMPTY
73879: LIST
73880: LIST
73881: PPUSH
73882: LD_EXP 87
73886: PUSH
73887: LD_VAR 0 2
73891: ARRAY
73892: PUSH
73893: LD_INT 1
73895: ARRAY
73896: PPUSH
73897: CALL 21054 0 3
73901: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
73902: LD_EXP 87
73906: PUSH
73907: LD_VAR 0 2
73911: ARRAY
73912: PUSH
73913: LD_INT 1
73915: ARRAY
73916: PPUSH
73917: LD_INT 112
73919: PPUSH
73920: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
73924: LD_ADDR_VAR 0 9
73928: PUSH
73929: LD_EXP 87
73933: PUSH
73934: LD_VAR 0 2
73938: ARRAY
73939: PPUSH
73940: LD_INT 1
73942: PPUSH
73943: CALL_OW 3
73947: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
73948: LD_ADDR_EXP 87
73952: PUSH
73953: LD_EXP 87
73957: PPUSH
73958: LD_VAR 0 2
73962: PPUSH
73963: LD_VAR 0 9
73967: PPUSH
73968: CALL_OW 1
73972: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
73973: LD_EXP 87
73977: PUSH
73978: LD_VAR 0 2
73982: ARRAY
73983: PUSH
73984: LD_EXP 88
73988: PUSH
73989: LD_VAR 0 2
73993: ARRAY
73994: AND
73995: PUSH
73996: LD_EXP 88
74000: PUSH
74001: LD_VAR 0 2
74005: ARRAY
74006: PUSH
74007: LD_INT 1
74009: ARRAY
74010: PPUSH
74011: CALL_OW 310
74015: NOT
74016: AND
74017: PUSH
74018: LD_VAR 0 3
74022: PPUSH
74023: CALL_OW 313
74027: PUSH
74028: LD_INT 6
74030: EQUAL
74031: AND
74032: IFFALSE 74088
// begin tmp2 := UnitsInside ( j ) ;
74034: LD_ADDR_VAR 0 9
74038: PUSH
74039: LD_VAR 0 3
74043: PPUSH
74044: CALL_OW 313
74048: ST_TO_ADDR
// if tmp2 = 6 then
74049: LD_VAR 0 9
74053: PUSH
74054: LD_INT 6
74056: EQUAL
74057: IFFALSE 74088
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74059: LD_VAR 0 9
74063: PUSH
74064: LD_INT 1
74066: ARRAY
74067: PPUSH
74068: LD_INT 112
74070: PPUSH
74071: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74075: LD_VAR 0 9
74079: PUSH
74080: LD_INT 1
74082: ARRAY
74083: PPUSH
74084: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74088: LD_EXP 88
74092: PUSH
74093: LD_VAR 0 2
74097: ARRAY
74098: PUSH
74099: LD_EXP 88
74103: PUSH
74104: LD_VAR 0 2
74108: ARRAY
74109: PUSH
74110: LD_INT 1
74112: ARRAY
74113: PPUSH
74114: CALL_OW 314
74118: NOT
74119: AND
74120: PUSH
74121: LD_EXP 88
74125: PUSH
74126: LD_VAR 0 2
74130: ARRAY
74131: PUSH
74132: LD_INT 1
74134: ARRAY
74135: PPUSH
74136: CALL_OW 310
74140: NOT
74141: AND
74142: IFFALSE 74168
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74144: LD_EXP 88
74148: PUSH
74149: LD_VAR 0 2
74153: ARRAY
74154: PUSH
74155: LD_INT 1
74157: ARRAY
74158: PPUSH
74159: LD_VAR 0 3
74163: PPUSH
74164: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74168: LD_EXP 88
74172: PUSH
74173: LD_VAR 0 2
74177: ARRAY
74178: PUSH
74179: LD_INT 1
74181: ARRAY
74182: PPUSH
74183: CALL_OW 310
74187: PUSH
74188: LD_EXP 88
74192: PUSH
74193: LD_VAR 0 2
74197: ARRAY
74198: PUSH
74199: LD_INT 1
74201: ARRAY
74202: PPUSH
74203: CALL_OW 310
74207: PPUSH
74208: CALL_OW 461
74212: PUSH
74213: LD_INT 3
74215: NONEQUAL
74216: AND
74217: IFFALSE 74238
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74219: LD_EXP 88
74223: PUSH
74224: LD_VAR 0 2
74228: ARRAY
74229: PUSH
74230: LD_INT 1
74232: ARRAY
74233: PPUSH
74234: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74238: LD_VAR 0 3
74242: PPUSH
74243: CALL_OW 461
74247: PUSH
74248: LD_INT 6
74250: EQUAL
74251: PUSH
74252: LD_VAR 0 6
74256: PUSH
74257: LD_INT 1
74259: GREATER
74260: AND
74261: IFFALSE 74413
// begin sci := [ ] ;
74263: LD_ADDR_VAR 0 8
74267: PUSH
74268: EMPTY
74269: ST_TO_ADDR
// for x in ( tmp diff j ) do
74270: LD_ADDR_VAR 0 7
74274: PUSH
74275: LD_VAR 0 6
74279: PUSH
74280: LD_VAR 0 3
74284: DIFF
74285: PUSH
74286: FOR_IN
74287: IFFALSE 74339
// begin if sci = 6 then
74289: LD_VAR 0 8
74293: PUSH
74294: LD_INT 6
74296: EQUAL
74297: IFFALSE 74301
// break ;
74299: GO 74339
// if BuildingStatus ( x ) = bs_idle then
74301: LD_VAR 0 7
74305: PPUSH
74306: CALL_OW 461
74310: PUSH
74311: LD_INT 2
74313: EQUAL
74314: IFFALSE 74337
// sci := sci ^ UnitsInside ( x ) ;
74316: LD_ADDR_VAR 0 8
74320: PUSH
74321: LD_VAR 0 8
74325: PUSH
74326: LD_VAR 0 7
74330: PPUSH
74331: CALL_OW 313
74335: ADD
74336: ST_TO_ADDR
// end ;
74337: GO 74286
74339: POP
74340: POP
// if not sci then
74341: LD_VAR 0 8
74345: NOT
74346: IFFALSE 74350
// continue ;
74348: GO 73395
// for x in sci do
74350: LD_ADDR_VAR 0 7
74354: PUSH
74355: LD_VAR 0 8
74359: PUSH
74360: FOR_IN
74361: IFFALSE 74411
// if IsInUnit ( x ) and not HasTask ( x ) then
74363: LD_VAR 0 7
74367: PPUSH
74368: CALL_OW 310
74372: PUSH
74373: LD_VAR 0 7
74377: PPUSH
74378: CALL_OW 314
74382: NOT
74383: AND
74384: IFFALSE 74409
// begin ComExitBuilding ( x ) ;
74386: LD_VAR 0 7
74390: PPUSH
74391: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74395: LD_VAR 0 7
74399: PPUSH
74400: LD_VAR 0 3
74404: PPUSH
74405: CALL_OW 180
// end ;
74409: GO 74360
74411: POP
74412: POP
// end ; end ;
74413: GO 73395
74415: POP
74416: POP
// end ;
74417: GO 73349
74419: POP
74420: POP
// end ;
74421: LD_VAR 0 1
74425: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74426: LD_INT 0
74428: PPUSH
74429: PPUSH
// if not mc_bases then
74430: LD_EXP 58
74434: NOT
74435: IFFALSE 74439
// exit ;
74437: GO 74520
// for i = 1 to mc_bases do
74439: LD_ADDR_VAR 0 2
74443: PUSH
74444: DOUBLE
74445: LD_INT 1
74447: DEC
74448: ST_TO_ADDR
74449: LD_EXP 58
74453: PUSH
74454: FOR_TO
74455: IFFALSE 74518
// if mc_mines [ i ] and mc_miners [ i ] then
74457: LD_EXP 71
74461: PUSH
74462: LD_VAR 0 2
74466: ARRAY
74467: PUSH
74468: LD_EXP 72
74472: PUSH
74473: LD_VAR 0 2
74477: ARRAY
74478: AND
74479: IFFALSE 74516
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74481: LD_EXP 72
74485: PUSH
74486: LD_VAR 0 2
74490: ARRAY
74491: PUSH
74492: LD_INT 1
74494: ARRAY
74495: PPUSH
74496: CALL_OW 255
74500: PPUSH
74501: LD_EXP 71
74505: PUSH
74506: LD_VAR 0 2
74510: ARRAY
74511: PPUSH
74512: CALL 18043 0 2
74516: GO 74454
74518: POP
74519: POP
// end ;
74520: LD_VAR 0 1
74524: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74525: LD_INT 0
74527: PPUSH
74528: PPUSH
74529: PPUSH
74530: PPUSH
74531: PPUSH
74532: PPUSH
74533: PPUSH
74534: PPUSH
// if not mc_bases or not mc_parking then
74535: LD_EXP 58
74539: NOT
74540: PUSH
74541: LD_EXP 82
74545: NOT
74546: OR
74547: IFFALSE 74551
// exit ;
74549: GO 75250
// for i = 1 to mc_bases do
74551: LD_ADDR_VAR 0 2
74555: PUSH
74556: DOUBLE
74557: LD_INT 1
74559: DEC
74560: ST_TO_ADDR
74561: LD_EXP 58
74565: PUSH
74566: FOR_TO
74567: IFFALSE 75248
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74569: LD_EXP 58
74573: PUSH
74574: LD_VAR 0 2
74578: ARRAY
74579: NOT
74580: PUSH
74581: LD_EXP 82
74585: PUSH
74586: LD_VAR 0 2
74590: ARRAY
74591: NOT
74592: OR
74593: IFFALSE 74597
// continue ;
74595: GO 74566
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74597: LD_ADDR_VAR 0 5
74601: PUSH
74602: LD_EXP 58
74606: PUSH
74607: LD_VAR 0 2
74611: ARRAY
74612: PUSH
74613: LD_INT 1
74615: ARRAY
74616: PPUSH
74617: CALL_OW 255
74621: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74622: LD_ADDR_VAR 0 6
74626: PUSH
74627: LD_EXP 58
74631: PUSH
74632: LD_VAR 0 2
74636: ARRAY
74637: PPUSH
74638: LD_INT 30
74640: PUSH
74641: LD_INT 3
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PPUSH
74648: CALL_OW 72
74652: ST_TO_ADDR
// if not fac then
74653: LD_VAR 0 6
74657: NOT
74658: IFFALSE 74709
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74660: LD_ADDR_VAR 0 6
74664: PUSH
74665: LD_EXP 58
74669: PUSH
74670: LD_VAR 0 2
74674: ARRAY
74675: PPUSH
74676: LD_INT 2
74678: PUSH
74679: LD_INT 30
74681: PUSH
74682: LD_INT 0
74684: PUSH
74685: EMPTY
74686: LIST
74687: LIST
74688: PUSH
74689: LD_INT 30
74691: PUSH
74692: LD_INT 1
74694: PUSH
74695: EMPTY
74696: LIST
74697: LIST
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: LIST
74703: PPUSH
74704: CALL_OW 72
74708: ST_TO_ADDR
// if not fac then
74709: LD_VAR 0 6
74713: NOT
74714: IFFALSE 74718
// continue ;
74716: GO 74566
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74718: LD_ADDR_VAR 0 7
74722: PUSH
74723: LD_EXP 82
74727: PUSH
74728: LD_VAR 0 2
74732: ARRAY
74733: PPUSH
74734: LD_INT 22
74736: PUSH
74737: LD_VAR 0 5
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: PUSH
74746: LD_INT 21
74748: PUSH
74749: LD_INT 2
74751: PUSH
74752: EMPTY
74753: LIST
74754: LIST
74755: PUSH
74756: LD_INT 3
74758: PUSH
74759: LD_INT 24
74761: PUSH
74762: LD_INT 1000
74764: PUSH
74765: EMPTY
74766: LIST
74767: LIST
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: EMPTY
74774: LIST
74775: LIST
74776: LIST
74777: PPUSH
74778: CALL_OW 70
74782: ST_TO_ADDR
// for j in fac do
74783: LD_ADDR_VAR 0 3
74787: PUSH
74788: LD_VAR 0 6
74792: PUSH
74793: FOR_IN
74794: IFFALSE 74875
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74796: LD_ADDR_VAR 0 7
74800: PUSH
74801: LD_VAR 0 7
74805: PUSH
74806: LD_INT 22
74808: PUSH
74809: LD_VAR 0 5
74813: PUSH
74814: EMPTY
74815: LIST
74816: LIST
74817: PUSH
74818: LD_INT 91
74820: PUSH
74821: LD_VAR 0 3
74825: PUSH
74826: LD_INT 15
74828: PUSH
74829: EMPTY
74830: LIST
74831: LIST
74832: LIST
74833: PUSH
74834: LD_INT 21
74836: PUSH
74837: LD_INT 2
74839: PUSH
74840: EMPTY
74841: LIST
74842: LIST
74843: PUSH
74844: LD_INT 3
74846: PUSH
74847: LD_INT 24
74849: PUSH
74850: LD_INT 1000
74852: PUSH
74853: EMPTY
74854: LIST
74855: LIST
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: LIST
74865: LIST
74866: PPUSH
74867: CALL_OW 69
74871: UNION
74872: ST_TO_ADDR
74873: GO 74793
74875: POP
74876: POP
// if not vehs then
74877: LD_VAR 0 7
74881: NOT
74882: IFFALSE 74908
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
74884: LD_ADDR_EXP 70
74888: PUSH
74889: LD_EXP 70
74893: PPUSH
74894: LD_VAR 0 2
74898: PPUSH
74899: EMPTY
74900: PPUSH
74901: CALL_OW 1
74905: ST_TO_ADDR
// continue ;
74906: GO 74566
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74908: LD_ADDR_VAR 0 8
74912: PUSH
74913: LD_EXP 58
74917: PUSH
74918: LD_VAR 0 2
74922: ARRAY
74923: PPUSH
74924: LD_INT 30
74926: PUSH
74927: LD_INT 3
74929: PUSH
74930: EMPTY
74931: LIST
74932: LIST
74933: PPUSH
74934: CALL_OW 72
74938: ST_TO_ADDR
// if tmp then
74939: LD_VAR 0 8
74943: IFFALSE 75046
// begin for j in tmp do
74945: LD_ADDR_VAR 0 3
74949: PUSH
74950: LD_VAR 0 8
74954: PUSH
74955: FOR_IN
74956: IFFALSE 75044
// for k in UnitsInside ( j ) do
74958: LD_ADDR_VAR 0 4
74962: PUSH
74963: LD_VAR 0 3
74967: PPUSH
74968: CALL_OW 313
74972: PUSH
74973: FOR_IN
74974: IFFALSE 75040
// if k then
74976: LD_VAR 0 4
74980: IFFALSE 75038
// if not k in mc_repair_vehicle [ i ] then
74982: LD_VAR 0 4
74986: PUSH
74987: LD_EXP 70
74991: PUSH
74992: LD_VAR 0 2
74996: ARRAY
74997: IN
74998: NOT
74999: IFFALSE 75038
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75001: LD_ADDR_EXP 70
75005: PUSH
75006: LD_EXP 70
75010: PPUSH
75011: LD_VAR 0 2
75015: PPUSH
75016: LD_EXP 70
75020: PUSH
75021: LD_VAR 0 2
75025: ARRAY
75026: PUSH
75027: LD_VAR 0 4
75031: UNION
75032: PPUSH
75033: CALL_OW 1
75037: ST_TO_ADDR
75038: GO 74973
75040: POP
75041: POP
75042: GO 74955
75044: POP
75045: POP
// end ; if not mc_repair_vehicle [ i ] then
75046: LD_EXP 70
75050: PUSH
75051: LD_VAR 0 2
75055: ARRAY
75056: NOT
75057: IFFALSE 75061
// continue ;
75059: GO 74566
// for j in mc_repair_vehicle [ i ] do
75061: LD_ADDR_VAR 0 3
75065: PUSH
75066: LD_EXP 70
75070: PUSH
75071: LD_VAR 0 2
75075: ARRAY
75076: PUSH
75077: FOR_IN
75078: IFFALSE 75244
// begin if GetClass ( j ) <> 3 then
75080: LD_VAR 0 3
75084: PPUSH
75085: CALL_OW 257
75089: PUSH
75090: LD_INT 3
75092: NONEQUAL
75093: IFFALSE 75134
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75095: LD_ADDR_EXP 70
75099: PUSH
75100: LD_EXP 70
75104: PPUSH
75105: LD_VAR 0 2
75109: PPUSH
75110: LD_EXP 70
75114: PUSH
75115: LD_VAR 0 2
75119: ARRAY
75120: PUSH
75121: LD_VAR 0 3
75125: DIFF
75126: PPUSH
75127: CALL_OW 1
75131: ST_TO_ADDR
// continue ;
75132: GO 75077
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75134: LD_VAR 0 3
75138: PPUSH
75139: CALL_OW 311
75143: NOT
75144: PUSH
75145: LD_VAR 0 3
75149: PUSH
75150: LD_EXP 61
75154: PUSH
75155: LD_VAR 0 2
75159: ARRAY
75160: PUSH
75161: LD_INT 1
75163: ARRAY
75164: IN
75165: NOT
75166: AND
75167: PUSH
75168: LD_VAR 0 3
75172: PUSH
75173: LD_EXP 61
75177: PUSH
75178: LD_VAR 0 2
75182: ARRAY
75183: PUSH
75184: LD_INT 2
75186: ARRAY
75187: IN
75188: NOT
75189: AND
75190: IFFALSE 75242
// begin if IsInUnit ( j ) then
75192: LD_VAR 0 3
75196: PPUSH
75197: CALL_OW 310
75201: IFFALSE 75212
// ComExitBuilding ( j ) ;
75203: LD_VAR 0 3
75207: PPUSH
75208: CALL_OW 122
// if not HasTask ( j ) then
75212: LD_VAR 0 3
75216: PPUSH
75217: CALL_OW 314
75221: NOT
75222: IFFALSE 75242
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75224: LD_VAR 0 3
75228: PPUSH
75229: LD_VAR 0 7
75233: PUSH
75234: LD_INT 1
75236: ARRAY
75237: PPUSH
75238: CALL_OW 189
// end ; end ;
75242: GO 75077
75244: POP
75245: POP
// end ;
75246: GO 74566
75248: POP
75249: POP
// end ;
75250: LD_VAR 0 1
75254: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75255: LD_INT 0
75257: PPUSH
75258: PPUSH
75259: PPUSH
75260: PPUSH
75261: PPUSH
75262: PPUSH
75263: PPUSH
75264: PPUSH
75265: PPUSH
75266: PPUSH
75267: PPUSH
// if not mc_bases then
75268: LD_EXP 58
75272: NOT
75273: IFFALSE 75277
// exit ;
75275: GO 76079
// for i = 1 to mc_bases do
75277: LD_ADDR_VAR 0 2
75281: PUSH
75282: DOUBLE
75283: LD_INT 1
75285: DEC
75286: ST_TO_ADDR
75287: LD_EXP 58
75291: PUSH
75292: FOR_TO
75293: IFFALSE 76077
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75295: LD_EXP 86
75299: PUSH
75300: LD_VAR 0 2
75304: ARRAY
75305: NOT
75306: PUSH
75307: LD_EXP 61
75311: PUSH
75312: LD_VAR 0 2
75316: ARRAY
75317: PUSH
75318: LD_INT 1
75320: ARRAY
75321: OR
75322: PUSH
75323: LD_EXP 61
75327: PUSH
75328: LD_VAR 0 2
75332: ARRAY
75333: PUSH
75334: LD_INT 2
75336: ARRAY
75337: OR
75338: PUSH
75339: LD_EXP 84
75343: PUSH
75344: LD_VAR 0 2
75348: ARRAY
75349: PPUSH
75350: LD_INT 1
75352: PPUSH
75353: CALL_OW 325
75357: NOT
75358: OR
75359: PUSH
75360: LD_EXP 81
75364: PUSH
75365: LD_VAR 0 2
75369: ARRAY
75370: OR
75371: IFFALSE 75375
// continue ;
75373: GO 75292
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75375: LD_ADDR_VAR 0 8
75379: PUSH
75380: LD_EXP 58
75384: PUSH
75385: LD_VAR 0 2
75389: ARRAY
75390: PPUSH
75391: LD_INT 25
75393: PUSH
75394: LD_INT 4
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 50
75403: PUSH
75404: EMPTY
75405: LIST
75406: PUSH
75407: LD_INT 3
75409: PUSH
75410: LD_INT 60
75412: PUSH
75413: EMPTY
75414: LIST
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: LIST
75424: PPUSH
75425: CALL_OW 72
75429: PUSH
75430: LD_EXP 62
75434: PUSH
75435: LD_VAR 0 2
75439: ARRAY
75440: DIFF
75441: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75442: LD_ADDR_VAR 0 9
75446: PUSH
75447: LD_EXP 58
75451: PUSH
75452: LD_VAR 0 2
75456: ARRAY
75457: PPUSH
75458: LD_INT 2
75460: PUSH
75461: LD_INT 30
75463: PUSH
75464: LD_INT 0
75466: PUSH
75467: EMPTY
75468: LIST
75469: LIST
75470: PUSH
75471: LD_INT 30
75473: PUSH
75474: LD_INT 1
75476: PUSH
75477: EMPTY
75478: LIST
75479: LIST
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: LIST
75485: PPUSH
75486: CALL_OW 72
75490: ST_TO_ADDR
// if not tmp or not dep then
75491: LD_VAR 0 8
75495: NOT
75496: PUSH
75497: LD_VAR 0 9
75501: NOT
75502: OR
75503: IFFALSE 75507
// continue ;
75505: GO 75292
// side := GetSide ( tmp [ 1 ] ) ;
75507: LD_ADDR_VAR 0 11
75511: PUSH
75512: LD_VAR 0 8
75516: PUSH
75517: LD_INT 1
75519: ARRAY
75520: PPUSH
75521: CALL_OW 255
75525: ST_TO_ADDR
// dep := dep [ 1 ] ;
75526: LD_ADDR_VAR 0 9
75530: PUSH
75531: LD_VAR 0 9
75535: PUSH
75536: LD_INT 1
75538: ARRAY
75539: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75540: LD_ADDR_VAR 0 7
75544: PUSH
75545: LD_EXP 86
75549: PUSH
75550: LD_VAR 0 2
75554: ARRAY
75555: PPUSH
75556: LD_INT 22
75558: PUSH
75559: LD_INT 0
75561: PUSH
75562: EMPTY
75563: LIST
75564: LIST
75565: PUSH
75566: LD_INT 25
75568: PUSH
75569: LD_INT 12
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: EMPTY
75577: LIST
75578: LIST
75579: PPUSH
75580: CALL_OW 70
75584: PUSH
75585: LD_INT 22
75587: PUSH
75588: LD_INT 0
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 25
75597: PUSH
75598: LD_INT 12
75600: PUSH
75601: EMPTY
75602: LIST
75603: LIST
75604: PUSH
75605: LD_INT 91
75607: PUSH
75608: LD_VAR 0 9
75612: PUSH
75613: LD_INT 20
75615: PUSH
75616: EMPTY
75617: LIST
75618: LIST
75619: LIST
75620: PUSH
75621: EMPTY
75622: LIST
75623: LIST
75624: LIST
75625: PPUSH
75626: CALL_OW 69
75630: UNION
75631: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75632: LD_ADDR_VAR 0 10
75636: PUSH
75637: LD_EXP 86
75641: PUSH
75642: LD_VAR 0 2
75646: ARRAY
75647: PPUSH
75648: LD_INT 81
75650: PUSH
75651: LD_VAR 0 11
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PPUSH
75660: CALL_OW 70
75664: ST_TO_ADDR
// if not apes or danger_at_area then
75665: LD_VAR 0 7
75669: NOT
75670: PUSH
75671: LD_VAR 0 10
75675: OR
75676: IFFALSE 75726
// begin if mc_taming [ i ] then
75678: LD_EXP 89
75682: PUSH
75683: LD_VAR 0 2
75687: ARRAY
75688: IFFALSE 75724
// begin MC_Reset ( i , 121 ) ;
75690: LD_VAR 0 2
75694: PPUSH
75695: LD_INT 121
75697: PPUSH
75698: CALL 61057 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75702: LD_ADDR_EXP 89
75706: PUSH
75707: LD_EXP 89
75711: PPUSH
75712: LD_VAR 0 2
75716: PPUSH
75717: EMPTY
75718: PPUSH
75719: CALL_OW 1
75723: ST_TO_ADDR
// end ; continue ;
75724: GO 75292
// end ; for j in tmp do
75726: LD_ADDR_VAR 0 3
75730: PUSH
75731: LD_VAR 0 8
75735: PUSH
75736: FOR_IN
75737: IFFALSE 76073
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75739: LD_VAR 0 3
75743: PUSH
75744: LD_EXP 89
75748: PUSH
75749: LD_VAR 0 2
75753: ARRAY
75754: IN
75755: NOT
75756: PUSH
75757: LD_EXP 89
75761: PUSH
75762: LD_VAR 0 2
75766: ARRAY
75767: PUSH
75768: LD_INT 3
75770: LESS
75771: AND
75772: IFFALSE 75830
// begin SetTag ( j , 121 ) ;
75774: LD_VAR 0 3
75778: PPUSH
75779: LD_INT 121
75781: PPUSH
75782: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
75786: LD_ADDR_EXP 89
75790: PUSH
75791: LD_EXP 89
75795: PPUSH
75796: LD_VAR 0 2
75800: PUSH
75801: LD_EXP 89
75805: PUSH
75806: LD_VAR 0 2
75810: ARRAY
75811: PUSH
75812: LD_INT 1
75814: PLUS
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PPUSH
75820: LD_VAR 0 3
75824: PPUSH
75825: CALL 21054 0 3
75829: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
75830: LD_VAR 0 3
75834: PUSH
75835: LD_EXP 89
75839: PUSH
75840: LD_VAR 0 2
75844: ARRAY
75845: IN
75846: IFFALSE 76071
// begin if GetClass ( j ) <> 4 then
75848: LD_VAR 0 3
75852: PPUSH
75853: CALL_OW 257
75857: PUSH
75858: LD_INT 4
75860: NONEQUAL
75861: IFFALSE 75914
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
75863: LD_ADDR_EXP 89
75867: PUSH
75868: LD_EXP 89
75872: PPUSH
75873: LD_VAR 0 2
75877: PPUSH
75878: LD_EXP 89
75882: PUSH
75883: LD_VAR 0 2
75887: ARRAY
75888: PUSH
75889: LD_VAR 0 3
75893: DIFF
75894: PPUSH
75895: CALL_OW 1
75899: ST_TO_ADDR
// SetTag ( j , 0 ) ;
75900: LD_VAR 0 3
75904: PPUSH
75905: LD_INT 0
75907: PPUSH
75908: CALL_OW 109
// continue ;
75912: GO 75736
// end ; if IsInUnit ( j ) then
75914: LD_VAR 0 3
75918: PPUSH
75919: CALL_OW 310
75923: IFFALSE 75934
// ComExitBuilding ( j ) ;
75925: LD_VAR 0 3
75929: PPUSH
75930: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
75934: LD_ADDR_VAR 0 6
75938: PUSH
75939: LD_VAR 0 7
75943: PPUSH
75944: LD_VAR 0 3
75948: PPUSH
75949: CALL_OW 74
75953: ST_TO_ADDR
// if not ape then
75954: LD_VAR 0 6
75958: NOT
75959: IFFALSE 75963
// break ;
75961: GO 76073
// x := GetX ( ape ) ;
75963: LD_ADDR_VAR 0 4
75967: PUSH
75968: LD_VAR 0 6
75972: PPUSH
75973: CALL_OW 250
75977: ST_TO_ADDR
// y := GetY ( ape ) ;
75978: LD_ADDR_VAR 0 5
75982: PUSH
75983: LD_VAR 0 6
75987: PPUSH
75988: CALL_OW 251
75992: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
75993: LD_VAR 0 4
75997: PPUSH
75998: LD_VAR 0 5
76002: PPUSH
76003: CALL_OW 488
76007: NOT
76008: PUSH
76009: LD_VAR 0 11
76013: PPUSH
76014: LD_VAR 0 4
76018: PPUSH
76019: LD_VAR 0 5
76023: PPUSH
76024: LD_INT 20
76026: PPUSH
76027: CALL 21950 0 4
76031: PUSH
76032: LD_INT 4
76034: ARRAY
76035: OR
76036: IFFALSE 76040
// break ;
76038: GO 76073
// if not HasTask ( j ) then
76040: LD_VAR 0 3
76044: PPUSH
76045: CALL_OW 314
76049: NOT
76050: IFFALSE 76071
// ComTameXY ( j , x , y ) ;
76052: LD_VAR 0 3
76056: PPUSH
76057: LD_VAR 0 4
76061: PPUSH
76062: LD_VAR 0 5
76066: PPUSH
76067: CALL_OW 131
// end ; end ;
76071: GO 75736
76073: POP
76074: POP
// end ;
76075: GO 75292
76077: POP
76078: POP
// end ;
76079: LD_VAR 0 1
76083: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76084: LD_INT 0
76086: PPUSH
76087: PPUSH
76088: PPUSH
76089: PPUSH
76090: PPUSH
76091: PPUSH
76092: PPUSH
76093: PPUSH
// if not mc_bases then
76094: LD_EXP 58
76098: NOT
76099: IFFALSE 76103
// exit ;
76101: GO 76729
// for i = 1 to mc_bases do
76103: LD_ADDR_VAR 0 2
76107: PUSH
76108: DOUBLE
76109: LD_INT 1
76111: DEC
76112: ST_TO_ADDR
76113: LD_EXP 58
76117: PUSH
76118: FOR_TO
76119: IFFALSE 76727
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76121: LD_EXP 87
76125: PUSH
76126: LD_VAR 0 2
76130: ARRAY
76131: NOT
76132: PUSH
76133: LD_EXP 87
76137: PUSH
76138: LD_VAR 0 2
76142: ARRAY
76143: PPUSH
76144: LD_INT 25
76146: PUSH
76147: LD_INT 12
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PPUSH
76154: CALL_OW 72
76158: NOT
76159: OR
76160: IFFALSE 76164
// continue ;
76162: GO 76118
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76164: LD_ADDR_VAR 0 5
76168: PUSH
76169: LD_EXP 87
76173: PUSH
76174: LD_VAR 0 2
76178: ARRAY
76179: PUSH
76180: LD_INT 1
76182: ARRAY
76183: PPUSH
76184: CALL_OW 255
76188: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76189: LD_VAR 0 5
76193: PPUSH
76194: LD_INT 2
76196: PPUSH
76197: CALL_OW 325
76201: IFFALSE 76454
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76203: LD_ADDR_VAR 0 4
76207: PUSH
76208: LD_EXP 87
76212: PUSH
76213: LD_VAR 0 2
76217: ARRAY
76218: PPUSH
76219: LD_INT 25
76221: PUSH
76222: LD_INT 16
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PPUSH
76229: CALL_OW 72
76233: ST_TO_ADDR
// if tmp < 6 then
76234: LD_VAR 0 4
76238: PUSH
76239: LD_INT 6
76241: LESS
76242: IFFALSE 76454
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76244: LD_ADDR_VAR 0 6
76248: PUSH
76249: LD_EXP 58
76253: PUSH
76254: LD_VAR 0 2
76258: ARRAY
76259: PPUSH
76260: LD_INT 2
76262: PUSH
76263: LD_INT 30
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 30
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: LIST
76287: PPUSH
76288: CALL_OW 72
76292: ST_TO_ADDR
// if depot then
76293: LD_VAR 0 6
76297: IFFALSE 76454
// begin selected := 0 ;
76299: LD_ADDR_VAR 0 7
76303: PUSH
76304: LD_INT 0
76306: ST_TO_ADDR
// for j in depot do
76307: LD_ADDR_VAR 0 3
76311: PUSH
76312: LD_VAR 0 6
76316: PUSH
76317: FOR_IN
76318: IFFALSE 76349
// begin if UnitsInside ( j ) < 6 then
76320: LD_VAR 0 3
76324: PPUSH
76325: CALL_OW 313
76329: PUSH
76330: LD_INT 6
76332: LESS
76333: IFFALSE 76347
// begin selected := j ;
76335: LD_ADDR_VAR 0 7
76339: PUSH
76340: LD_VAR 0 3
76344: ST_TO_ADDR
// break ;
76345: GO 76349
// end ; end ;
76347: GO 76317
76349: POP
76350: POP
// if selected then
76351: LD_VAR 0 7
76355: IFFALSE 76454
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76357: LD_ADDR_VAR 0 3
76361: PUSH
76362: LD_EXP 87
76366: PUSH
76367: LD_VAR 0 2
76371: ARRAY
76372: PPUSH
76373: LD_INT 25
76375: PUSH
76376: LD_INT 12
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PPUSH
76383: CALL_OW 72
76387: PUSH
76388: FOR_IN
76389: IFFALSE 76452
// if not HasTask ( j ) then
76391: LD_VAR 0 3
76395: PPUSH
76396: CALL_OW 314
76400: NOT
76401: IFFALSE 76450
// begin if not IsInUnit ( j ) then
76403: LD_VAR 0 3
76407: PPUSH
76408: CALL_OW 310
76412: NOT
76413: IFFALSE 76429
// ComEnterUnit ( j , selected ) ;
76415: LD_VAR 0 3
76419: PPUSH
76420: LD_VAR 0 7
76424: PPUSH
76425: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76429: LD_VAR 0 3
76433: PPUSH
76434: LD_INT 16
76436: PPUSH
76437: CALL_OW 183
// AddComExitBuilding ( j ) ;
76441: LD_VAR 0 3
76445: PPUSH
76446: CALL_OW 182
// end ;
76450: GO 76388
76452: POP
76453: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76454: LD_VAR 0 5
76458: PPUSH
76459: LD_INT 11
76461: PPUSH
76462: CALL_OW 325
76466: IFFALSE 76725
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76468: LD_ADDR_VAR 0 4
76472: PUSH
76473: LD_EXP 87
76477: PUSH
76478: LD_VAR 0 2
76482: ARRAY
76483: PPUSH
76484: LD_INT 25
76486: PUSH
76487: LD_INT 16
76489: PUSH
76490: EMPTY
76491: LIST
76492: LIST
76493: PPUSH
76494: CALL_OW 72
76498: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76499: LD_VAR 0 4
76503: PUSH
76504: LD_INT 6
76506: GREATEREQUAL
76507: PUSH
76508: LD_VAR 0 5
76512: PPUSH
76513: LD_INT 2
76515: PPUSH
76516: CALL_OW 325
76520: NOT
76521: OR
76522: IFFALSE 76725
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76524: LD_ADDR_VAR 0 8
76528: PUSH
76529: LD_EXP 58
76533: PUSH
76534: LD_VAR 0 2
76538: ARRAY
76539: PPUSH
76540: LD_INT 2
76542: PUSH
76543: LD_INT 30
76545: PUSH
76546: LD_INT 4
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 30
76555: PUSH
76556: LD_INT 5
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: LIST
76567: PPUSH
76568: CALL_OW 72
76572: ST_TO_ADDR
// if barracks then
76573: LD_VAR 0 8
76577: IFFALSE 76725
// begin selected := 0 ;
76579: LD_ADDR_VAR 0 7
76583: PUSH
76584: LD_INT 0
76586: ST_TO_ADDR
// for j in barracks do
76587: LD_ADDR_VAR 0 3
76591: PUSH
76592: LD_VAR 0 8
76596: PUSH
76597: FOR_IN
76598: IFFALSE 76629
// begin if UnitsInside ( j ) < 6 then
76600: LD_VAR 0 3
76604: PPUSH
76605: CALL_OW 313
76609: PUSH
76610: LD_INT 6
76612: LESS
76613: IFFALSE 76627
// begin selected := j ;
76615: LD_ADDR_VAR 0 7
76619: PUSH
76620: LD_VAR 0 3
76624: ST_TO_ADDR
// break ;
76625: GO 76629
// end ; end ;
76627: GO 76597
76629: POP
76630: POP
// if selected then
76631: LD_VAR 0 7
76635: IFFALSE 76725
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76637: LD_ADDR_VAR 0 3
76641: PUSH
76642: LD_EXP 87
76646: PUSH
76647: LD_VAR 0 2
76651: ARRAY
76652: PPUSH
76653: LD_INT 25
76655: PUSH
76656: LD_INT 12
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PPUSH
76663: CALL_OW 72
76667: PUSH
76668: FOR_IN
76669: IFFALSE 76723
// if not IsInUnit ( j ) and not HasTask ( j ) then
76671: LD_VAR 0 3
76675: PPUSH
76676: CALL_OW 310
76680: NOT
76681: PUSH
76682: LD_VAR 0 3
76686: PPUSH
76687: CALL_OW 314
76691: NOT
76692: AND
76693: IFFALSE 76721
// begin ComEnterUnit ( j , selected ) ;
76695: LD_VAR 0 3
76699: PPUSH
76700: LD_VAR 0 7
76704: PPUSH
76705: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76709: LD_VAR 0 3
76713: PPUSH
76714: LD_INT 15
76716: PPUSH
76717: CALL_OW 183
// end ;
76721: GO 76668
76723: POP
76724: POP
// end ; end ; end ; end ; end ;
76725: GO 76118
76727: POP
76728: POP
// end ;
76729: LD_VAR 0 1
76733: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76734: LD_INT 0
76736: PPUSH
76737: PPUSH
76738: PPUSH
76739: PPUSH
// if not mc_bases then
76740: LD_EXP 58
76744: NOT
76745: IFFALSE 76749
// exit ;
76747: GO 76927
// for i = 1 to mc_bases do
76749: LD_ADDR_VAR 0 2
76753: PUSH
76754: DOUBLE
76755: LD_INT 1
76757: DEC
76758: ST_TO_ADDR
76759: LD_EXP 58
76763: PUSH
76764: FOR_TO
76765: IFFALSE 76925
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76767: LD_ADDR_VAR 0 4
76771: PUSH
76772: LD_EXP 58
76776: PUSH
76777: LD_VAR 0 2
76781: ARRAY
76782: PPUSH
76783: LD_INT 25
76785: PUSH
76786: LD_INT 9
76788: PUSH
76789: EMPTY
76790: LIST
76791: LIST
76792: PPUSH
76793: CALL_OW 72
76797: ST_TO_ADDR
// if not tmp then
76798: LD_VAR 0 4
76802: NOT
76803: IFFALSE 76807
// continue ;
76805: GO 76764
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
76807: LD_EXP 84
76811: PUSH
76812: LD_VAR 0 2
76816: ARRAY
76817: PPUSH
76818: LD_INT 29
76820: PPUSH
76821: CALL_OW 325
76825: NOT
76826: PUSH
76827: LD_EXP 84
76831: PUSH
76832: LD_VAR 0 2
76836: ARRAY
76837: PPUSH
76838: LD_INT 28
76840: PPUSH
76841: CALL_OW 325
76845: NOT
76846: AND
76847: IFFALSE 76851
// continue ;
76849: GO 76764
// for j in tmp do
76851: LD_ADDR_VAR 0 3
76855: PUSH
76856: LD_VAR 0 4
76860: PUSH
76861: FOR_IN
76862: IFFALSE 76921
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
76864: LD_VAR 0 3
76868: PUSH
76869: LD_EXP 61
76873: PUSH
76874: LD_VAR 0 2
76878: ARRAY
76879: PUSH
76880: LD_INT 1
76882: ARRAY
76883: IN
76884: NOT
76885: PUSH
76886: LD_VAR 0 3
76890: PUSH
76891: LD_EXP 61
76895: PUSH
76896: LD_VAR 0 2
76900: ARRAY
76901: PUSH
76902: LD_INT 2
76904: ARRAY
76905: IN
76906: NOT
76907: AND
76908: IFFALSE 76919
// ComSpaceTimeShoot ( j ) ;
76910: LD_VAR 0 3
76914: PPUSH
76915: CALL 14789 0 1
76919: GO 76861
76921: POP
76922: POP
// end ;
76923: GO 76764
76925: POP
76926: POP
// end ;
76927: LD_VAR 0 1
76931: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
76932: LD_INT 0
76934: PPUSH
76935: PPUSH
76936: PPUSH
76937: PPUSH
76938: PPUSH
76939: PPUSH
76940: PPUSH
76941: PPUSH
76942: PPUSH
// if not mc_bases then
76943: LD_EXP 58
76947: NOT
76948: IFFALSE 76952
// exit ;
76950: GO 77574
// for i = 1 to mc_bases do
76952: LD_ADDR_VAR 0 2
76956: PUSH
76957: DOUBLE
76958: LD_INT 1
76960: DEC
76961: ST_TO_ADDR
76962: LD_EXP 58
76966: PUSH
76967: FOR_TO
76968: IFFALSE 77572
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
76970: LD_EXP 93
76974: PUSH
76975: LD_VAR 0 2
76979: ARRAY
76980: NOT
76981: PUSH
76982: LD_INT 38
76984: PPUSH
76985: LD_EXP 84
76989: PUSH
76990: LD_VAR 0 2
76994: ARRAY
76995: PPUSH
76996: CALL_OW 321
77000: PUSH
77001: LD_INT 2
77003: NONEQUAL
77004: OR
77005: IFFALSE 77009
// continue ;
77007: GO 76967
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77009: LD_ADDR_VAR 0 8
77013: PUSH
77014: LD_EXP 58
77018: PUSH
77019: LD_VAR 0 2
77023: ARRAY
77024: PPUSH
77025: LD_INT 30
77027: PUSH
77028: LD_INT 34
77030: PUSH
77031: EMPTY
77032: LIST
77033: LIST
77034: PPUSH
77035: CALL_OW 72
77039: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77040: LD_ADDR_VAR 0 9
77044: PUSH
77045: LD_EXP 58
77049: PUSH
77050: LD_VAR 0 2
77054: ARRAY
77055: PPUSH
77056: LD_INT 25
77058: PUSH
77059: LD_INT 4
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: PPUSH
77066: CALL_OW 72
77070: PPUSH
77071: LD_INT 0
77073: PPUSH
77074: CALL 54314 0 2
77078: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77079: LD_VAR 0 9
77083: NOT
77084: PUSH
77085: LD_VAR 0 8
77089: NOT
77090: OR
77091: PUSH
77092: LD_EXP 58
77096: PUSH
77097: LD_VAR 0 2
77101: ARRAY
77102: PPUSH
77103: LD_INT 124
77105: PPUSH
77106: CALL 54314 0 2
77110: OR
77111: IFFALSE 77115
// continue ;
77113: GO 76967
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77115: LD_EXP 94
77119: PUSH
77120: LD_VAR 0 2
77124: ARRAY
77125: PUSH
77126: LD_EXP 93
77130: PUSH
77131: LD_VAR 0 2
77135: ARRAY
77136: LESS
77137: PUSH
77138: LD_EXP 94
77142: PUSH
77143: LD_VAR 0 2
77147: ARRAY
77148: PUSH
77149: LD_VAR 0 8
77153: LESS
77154: AND
77155: IFFALSE 77570
// begin tmp := sci [ 1 ] ;
77157: LD_ADDR_VAR 0 7
77161: PUSH
77162: LD_VAR 0 9
77166: PUSH
77167: LD_INT 1
77169: ARRAY
77170: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77171: LD_VAR 0 7
77175: PPUSH
77176: LD_INT 124
77178: PPUSH
77179: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77183: LD_ADDR_VAR 0 3
77187: PUSH
77188: DOUBLE
77189: LD_EXP 93
77193: PUSH
77194: LD_VAR 0 2
77198: ARRAY
77199: INC
77200: ST_TO_ADDR
77201: LD_EXP 93
77205: PUSH
77206: LD_VAR 0 2
77210: ARRAY
77211: PUSH
77212: FOR_DOWNTO
77213: IFFALSE 77556
// begin if IsInUnit ( tmp ) then
77215: LD_VAR 0 7
77219: PPUSH
77220: CALL_OW 310
77224: IFFALSE 77235
// ComExitBuilding ( tmp ) ;
77226: LD_VAR 0 7
77230: PPUSH
77231: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77235: LD_INT 35
77237: PPUSH
77238: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77242: LD_VAR 0 7
77246: PPUSH
77247: CALL_OW 310
77251: NOT
77252: PUSH
77253: LD_VAR 0 7
77257: PPUSH
77258: CALL_OW 314
77262: NOT
77263: AND
77264: IFFALSE 77235
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77266: LD_ADDR_VAR 0 6
77270: PUSH
77271: LD_VAR 0 7
77275: PPUSH
77276: CALL_OW 250
77280: PUSH
77281: LD_VAR 0 7
77285: PPUSH
77286: CALL_OW 251
77290: PUSH
77291: EMPTY
77292: LIST
77293: LIST
77294: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77295: LD_INT 35
77297: PPUSH
77298: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77302: LD_ADDR_VAR 0 4
77306: PUSH
77307: LD_EXP 93
77311: PUSH
77312: LD_VAR 0 2
77316: ARRAY
77317: PUSH
77318: LD_VAR 0 3
77322: ARRAY
77323: PUSH
77324: LD_INT 1
77326: ARRAY
77327: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77328: LD_ADDR_VAR 0 5
77332: PUSH
77333: LD_EXP 93
77337: PUSH
77338: LD_VAR 0 2
77342: ARRAY
77343: PUSH
77344: LD_VAR 0 3
77348: ARRAY
77349: PUSH
77350: LD_INT 2
77352: ARRAY
77353: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77354: LD_VAR 0 7
77358: PPUSH
77359: LD_INT 10
77361: PPUSH
77362: CALL 23647 0 2
77366: PUSH
77367: LD_INT 4
77369: ARRAY
77370: IFFALSE 77408
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77372: LD_VAR 0 7
77376: PPUSH
77377: LD_VAR 0 6
77381: PUSH
77382: LD_INT 1
77384: ARRAY
77385: PPUSH
77386: LD_VAR 0 6
77390: PUSH
77391: LD_INT 2
77393: ARRAY
77394: PPUSH
77395: CALL_OW 111
// wait ( 0 0$10 ) ;
77399: LD_INT 350
77401: PPUSH
77402: CALL_OW 67
// end else
77406: GO 77434
// begin ComMoveXY ( tmp , x , y ) ;
77408: LD_VAR 0 7
77412: PPUSH
77413: LD_VAR 0 4
77417: PPUSH
77418: LD_VAR 0 5
77422: PPUSH
77423: CALL_OW 111
// wait ( 0 0$3 ) ;
77427: LD_INT 105
77429: PPUSH
77430: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77434: LD_VAR 0 7
77438: PPUSH
77439: LD_VAR 0 4
77443: PPUSH
77444: LD_VAR 0 5
77448: PPUSH
77449: CALL_OW 307
77453: IFFALSE 77295
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77455: LD_VAR 0 7
77459: PPUSH
77460: LD_VAR 0 4
77464: PPUSH
77465: LD_VAR 0 5
77469: PPUSH
77470: LD_VAR 0 8
77474: PUSH
77475: LD_VAR 0 3
77479: ARRAY
77480: PPUSH
77481: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77485: LD_INT 35
77487: PPUSH
77488: CALL_OW 67
// until not HasTask ( tmp ) ;
77492: LD_VAR 0 7
77496: PPUSH
77497: CALL_OW 314
77501: NOT
77502: IFFALSE 77485
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77504: LD_ADDR_EXP 94
77508: PUSH
77509: LD_EXP 94
77513: PPUSH
77514: LD_VAR 0 2
77518: PUSH
77519: LD_EXP 94
77523: PUSH
77524: LD_VAR 0 2
77528: ARRAY
77529: PUSH
77530: LD_INT 1
77532: PLUS
77533: PUSH
77534: EMPTY
77535: LIST
77536: LIST
77537: PPUSH
77538: LD_VAR 0 8
77542: PUSH
77543: LD_VAR 0 3
77547: ARRAY
77548: PPUSH
77549: CALL 21054 0 3
77553: ST_TO_ADDR
// end ;
77554: GO 77212
77556: POP
77557: POP
// MC_Reset ( i , 124 ) ;
77558: LD_VAR 0 2
77562: PPUSH
77563: LD_INT 124
77565: PPUSH
77566: CALL 61057 0 2
// end ; end ;
77570: GO 76967
77572: POP
77573: POP
// end ;
77574: LD_VAR 0 1
77578: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77579: LD_INT 0
77581: PPUSH
77582: PPUSH
77583: PPUSH
// if not mc_bases then
77584: LD_EXP 58
77588: NOT
77589: IFFALSE 77593
// exit ;
77591: GO 78199
// for i = 1 to mc_bases do
77593: LD_ADDR_VAR 0 2
77597: PUSH
77598: DOUBLE
77599: LD_INT 1
77601: DEC
77602: ST_TO_ADDR
77603: LD_EXP 58
77607: PUSH
77608: FOR_TO
77609: IFFALSE 78197
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77611: LD_ADDR_VAR 0 3
77615: PUSH
77616: LD_EXP 58
77620: PUSH
77621: LD_VAR 0 2
77625: ARRAY
77626: PPUSH
77627: LD_INT 25
77629: PUSH
77630: LD_INT 4
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PPUSH
77637: CALL_OW 72
77641: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77642: LD_VAR 0 3
77646: NOT
77647: PUSH
77648: LD_EXP 95
77652: PUSH
77653: LD_VAR 0 2
77657: ARRAY
77658: NOT
77659: OR
77660: PUSH
77661: LD_EXP 58
77665: PUSH
77666: LD_VAR 0 2
77670: ARRAY
77671: PPUSH
77672: LD_INT 2
77674: PUSH
77675: LD_INT 30
77677: PUSH
77678: LD_INT 0
77680: PUSH
77681: EMPTY
77682: LIST
77683: LIST
77684: PUSH
77685: LD_INT 30
77687: PUSH
77688: LD_INT 1
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: LIST
77699: PPUSH
77700: CALL_OW 72
77704: NOT
77705: OR
77706: IFFALSE 77756
// begin if mc_deposits_finder [ i ] then
77708: LD_EXP 96
77712: PUSH
77713: LD_VAR 0 2
77717: ARRAY
77718: IFFALSE 77754
// begin MC_Reset ( i , 125 ) ;
77720: LD_VAR 0 2
77724: PPUSH
77725: LD_INT 125
77727: PPUSH
77728: CALL 61057 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77732: LD_ADDR_EXP 96
77736: PUSH
77737: LD_EXP 96
77741: PPUSH
77742: LD_VAR 0 2
77746: PPUSH
77747: EMPTY
77748: PPUSH
77749: CALL_OW 1
77753: ST_TO_ADDR
// end ; continue ;
77754: GO 77608
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77756: LD_EXP 95
77760: PUSH
77761: LD_VAR 0 2
77765: ARRAY
77766: PUSH
77767: LD_INT 1
77769: ARRAY
77770: PUSH
77771: LD_INT 3
77773: ARRAY
77774: PUSH
77775: LD_INT 1
77777: EQUAL
77778: PUSH
77779: LD_INT 20
77781: PPUSH
77782: LD_EXP 84
77786: PUSH
77787: LD_VAR 0 2
77791: ARRAY
77792: PPUSH
77793: CALL_OW 321
77797: PUSH
77798: LD_INT 2
77800: NONEQUAL
77801: AND
77802: IFFALSE 77852
// begin if mc_deposits_finder [ i ] then
77804: LD_EXP 96
77808: PUSH
77809: LD_VAR 0 2
77813: ARRAY
77814: IFFALSE 77850
// begin MC_Reset ( i , 125 ) ;
77816: LD_VAR 0 2
77820: PPUSH
77821: LD_INT 125
77823: PPUSH
77824: CALL 61057 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77828: LD_ADDR_EXP 96
77832: PUSH
77833: LD_EXP 96
77837: PPUSH
77838: LD_VAR 0 2
77842: PPUSH
77843: EMPTY
77844: PPUSH
77845: CALL_OW 1
77849: ST_TO_ADDR
// end ; continue ;
77850: GO 77608
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
77852: LD_EXP 95
77856: PUSH
77857: LD_VAR 0 2
77861: ARRAY
77862: PUSH
77863: LD_INT 1
77865: ARRAY
77866: PUSH
77867: LD_INT 1
77869: ARRAY
77870: PPUSH
77871: LD_EXP 95
77875: PUSH
77876: LD_VAR 0 2
77880: ARRAY
77881: PUSH
77882: LD_INT 1
77884: ARRAY
77885: PUSH
77886: LD_INT 2
77888: ARRAY
77889: PPUSH
77890: LD_EXP 84
77894: PUSH
77895: LD_VAR 0 2
77899: ARRAY
77900: PPUSH
77901: CALL_OW 440
77905: IFFALSE 77948
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
77907: LD_ADDR_EXP 95
77911: PUSH
77912: LD_EXP 95
77916: PPUSH
77917: LD_VAR 0 2
77921: PPUSH
77922: LD_EXP 95
77926: PUSH
77927: LD_VAR 0 2
77931: ARRAY
77932: PPUSH
77933: LD_INT 1
77935: PPUSH
77936: CALL_OW 3
77940: PPUSH
77941: CALL_OW 1
77945: ST_TO_ADDR
77946: GO 78195
// begin if not mc_deposits_finder [ i ] then
77948: LD_EXP 96
77952: PUSH
77953: LD_VAR 0 2
77957: ARRAY
77958: NOT
77959: IFFALSE 78011
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
77961: LD_ADDR_EXP 96
77965: PUSH
77966: LD_EXP 96
77970: PPUSH
77971: LD_VAR 0 2
77975: PPUSH
77976: LD_VAR 0 3
77980: PUSH
77981: LD_INT 1
77983: ARRAY
77984: PUSH
77985: EMPTY
77986: LIST
77987: PPUSH
77988: CALL_OW 1
77992: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
77993: LD_VAR 0 3
77997: PUSH
77998: LD_INT 1
78000: ARRAY
78001: PPUSH
78002: LD_INT 125
78004: PPUSH
78005: CALL_OW 109
// end else
78009: GO 78195
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78011: LD_EXP 96
78015: PUSH
78016: LD_VAR 0 2
78020: ARRAY
78021: PUSH
78022: LD_INT 1
78024: ARRAY
78025: PPUSH
78026: CALL_OW 310
78030: IFFALSE 78053
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78032: LD_EXP 96
78036: PUSH
78037: LD_VAR 0 2
78041: ARRAY
78042: PUSH
78043: LD_INT 1
78045: ARRAY
78046: PPUSH
78047: CALL_OW 122
78051: GO 78195
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78053: LD_EXP 96
78057: PUSH
78058: LD_VAR 0 2
78062: ARRAY
78063: PUSH
78064: LD_INT 1
78066: ARRAY
78067: PPUSH
78068: CALL_OW 314
78072: NOT
78073: PUSH
78074: LD_EXP 96
78078: PUSH
78079: LD_VAR 0 2
78083: ARRAY
78084: PUSH
78085: LD_INT 1
78087: ARRAY
78088: PPUSH
78089: LD_EXP 95
78093: PUSH
78094: LD_VAR 0 2
78098: ARRAY
78099: PUSH
78100: LD_INT 1
78102: ARRAY
78103: PUSH
78104: LD_INT 1
78106: ARRAY
78107: PPUSH
78108: LD_EXP 95
78112: PUSH
78113: LD_VAR 0 2
78117: ARRAY
78118: PUSH
78119: LD_INT 1
78121: ARRAY
78122: PUSH
78123: LD_INT 2
78125: ARRAY
78126: PPUSH
78127: CALL_OW 297
78131: PUSH
78132: LD_INT 6
78134: GREATER
78135: AND
78136: IFFALSE 78195
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78138: LD_EXP 96
78142: PUSH
78143: LD_VAR 0 2
78147: ARRAY
78148: PUSH
78149: LD_INT 1
78151: ARRAY
78152: PPUSH
78153: LD_EXP 95
78157: PUSH
78158: LD_VAR 0 2
78162: ARRAY
78163: PUSH
78164: LD_INT 1
78166: ARRAY
78167: PUSH
78168: LD_INT 1
78170: ARRAY
78171: PPUSH
78172: LD_EXP 95
78176: PUSH
78177: LD_VAR 0 2
78181: ARRAY
78182: PUSH
78183: LD_INT 1
78185: ARRAY
78186: PUSH
78187: LD_INT 2
78189: ARRAY
78190: PPUSH
78191: CALL_OW 111
// end ; end ; end ;
78195: GO 77608
78197: POP
78198: POP
// end ;
78199: LD_VAR 0 1
78203: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78204: LD_INT 0
78206: PPUSH
78207: PPUSH
78208: PPUSH
78209: PPUSH
78210: PPUSH
78211: PPUSH
78212: PPUSH
78213: PPUSH
78214: PPUSH
78215: PPUSH
78216: PPUSH
// if not mc_bases then
78217: LD_EXP 58
78221: NOT
78222: IFFALSE 78226
// exit ;
78224: GO 78950
// for i = 1 to mc_bases do
78226: LD_ADDR_VAR 0 2
78230: PUSH
78231: DOUBLE
78232: LD_INT 1
78234: DEC
78235: ST_TO_ADDR
78236: LD_EXP 58
78240: PUSH
78241: FOR_TO
78242: IFFALSE 78948
// begin if not mc_bases [ i ] then
78244: LD_EXP 58
78248: PUSH
78249: LD_VAR 0 2
78253: ARRAY
78254: NOT
78255: IFFALSE 78259
// continue ;
78257: GO 78241
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78259: LD_ADDR_VAR 0 7
78263: PUSH
78264: LD_EXP 58
78268: PUSH
78269: LD_VAR 0 2
78273: ARRAY
78274: PUSH
78275: LD_INT 1
78277: ARRAY
78278: PPUSH
78279: CALL_OW 248
78283: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78284: LD_VAR 0 7
78288: PUSH
78289: LD_INT 3
78291: EQUAL
78292: PUSH
78293: LD_EXP 77
78297: PUSH
78298: LD_VAR 0 2
78302: ARRAY
78303: PUSH
78304: LD_EXP 80
78308: PUSH
78309: LD_VAR 0 2
78313: ARRAY
78314: UNION
78315: PPUSH
78316: LD_INT 33
78318: PUSH
78319: LD_INT 2
78321: PUSH
78322: EMPTY
78323: LIST
78324: LIST
78325: PPUSH
78326: CALL_OW 72
78330: NOT
78331: OR
78332: IFFALSE 78336
// continue ;
78334: GO 78241
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78336: LD_ADDR_VAR 0 9
78340: PUSH
78341: LD_EXP 58
78345: PUSH
78346: LD_VAR 0 2
78350: ARRAY
78351: PPUSH
78352: LD_INT 30
78354: PUSH
78355: LD_INT 36
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PPUSH
78362: CALL_OW 72
78366: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78367: LD_ADDR_VAR 0 10
78371: PUSH
78372: LD_EXP 77
78376: PUSH
78377: LD_VAR 0 2
78381: ARRAY
78382: PPUSH
78383: LD_INT 34
78385: PUSH
78386: LD_INT 31
78388: PUSH
78389: EMPTY
78390: LIST
78391: LIST
78392: PPUSH
78393: CALL_OW 72
78397: ST_TO_ADDR
// if not cts and not mcts then
78398: LD_VAR 0 9
78402: NOT
78403: PUSH
78404: LD_VAR 0 10
78408: NOT
78409: AND
78410: IFFALSE 78414
// continue ;
78412: GO 78241
// x := cts ;
78414: LD_ADDR_VAR 0 11
78418: PUSH
78419: LD_VAR 0 9
78423: ST_TO_ADDR
// if not x then
78424: LD_VAR 0 11
78428: NOT
78429: IFFALSE 78441
// x := mcts ;
78431: LD_ADDR_VAR 0 11
78435: PUSH
78436: LD_VAR 0 10
78440: ST_TO_ADDR
// if mc_remote_driver [ i ] then
78441: LD_EXP 98
78445: PUSH
78446: LD_VAR 0 2
78450: ARRAY
78451: IFFALSE 78720
// for j in mc_remote_driver [ i ] do
78453: LD_ADDR_VAR 0 3
78457: PUSH
78458: LD_EXP 98
78462: PUSH
78463: LD_VAR 0 2
78467: ARRAY
78468: PUSH
78469: FOR_IN
78470: IFFALSE 78718
// begin if GetClass ( j ) <> 3 then
78472: LD_VAR 0 3
78476: PPUSH
78477: CALL_OW 257
78481: PUSH
78482: LD_INT 3
78484: NONEQUAL
78485: IFFALSE 78538
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78487: LD_ADDR_EXP 98
78491: PUSH
78492: LD_EXP 98
78496: PPUSH
78497: LD_VAR 0 2
78501: PPUSH
78502: LD_EXP 98
78506: PUSH
78507: LD_VAR 0 2
78511: ARRAY
78512: PUSH
78513: LD_VAR 0 3
78517: DIFF
78518: PPUSH
78519: CALL_OW 1
78523: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78524: LD_VAR 0 3
78528: PPUSH
78529: LD_INT 0
78531: PPUSH
78532: CALL_OW 109
// continue ;
78536: GO 78469
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78538: LD_VAR 0 3
78542: PPUSH
78543: CALL_OW 310
78547: NOT
78548: PUSH
78549: LD_VAR 0 3
78553: PPUSH
78554: CALL_OW 310
78558: PPUSH
78559: CALL_OW 266
78563: PUSH
78564: LD_INT 36
78566: NONEQUAL
78567: PUSH
78568: LD_VAR 0 3
78572: PPUSH
78573: CALL 54402 0 1
78577: NOT
78578: AND
78579: OR
78580: IFFALSE 78716
// begin if IsInUnit ( j ) then
78582: LD_VAR 0 3
78586: PPUSH
78587: CALL_OW 310
78591: IFFALSE 78602
// ComExitBuilding ( j ) ;
78593: LD_VAR 0 3
78597: PPUSH
78598: CALL_OW 122
// ct := 0 ;
78602: LD_ADDR_VAR 0 8
78606: PUSH
78607: LD_INT 0
78609: ST_TO_ADDR
// for k in x do
78610: LD_ADDR_VAR 0 4
78614: PUSH
78615: LD_VAR 0 11
78619: PUSH
78620: FOR_IN
78621: IFFALSE 78694
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78623: LD_VAR 0 4
78627: PPUSH
78628: CALL_OW 264
78632: PUSH
78633: LD_INT 31
78635: EQUAL
78636: PUSH
78637: LD_VAR 0 4
78641: PPUSH
78642: CALL_OW 311
78646: NOT
78647: AND
78648: PUSH
78649: LD_VAR 0 4
78653: PPUSH
78654: CALL_OW 266
78658: PUSH
78659: LD_INT 36
78661: EQUAL
78662: PUSH
78663: LD_VAR 0 4
78667: PPUSH
78668: CALL_OW 313
78672: PUSH
78673: LD_INT 3
78675: LESS
78676: AND
78677: OR
78678: IFFALSE 78692
// begin ct := k ;
78680: LD_ADDR_VAR 0 8
78684: PUSH
78685: LD_VAR 0 4
78689: ST_TO_ADDR
// break ;
78690: GO 78694
// end ;
78692: GO 78620
78694: POP
78695: POP
// if ct then
78696: LD_VAR 0 8
78700: IFFALSE 78716
// ComEnterUnit ( j , ct ) ;
78702: LD_VAR 0 3
78706: PPUSH
78707: LD_VAR 0 8
78711: PPUSH
78712: CALL_OW 120
// end ; end ;
78716: GO 78469
78718: POP
78719: POP
// places := 0 ;
78720: LD_ADDR_VAR 0 5
78724: PUSH
78725: LD_INT 0
78727: ST_TO_ADDR
// for j = 1 to x do
78728: LD_ADDR_VAR 0 3
78732: PUSH
78733: DOUBLE
78734: LD_INT 1
78736: DEC
78737: ST_TO_ADDR
78738: LD_VAR 0 11
78742: PUSH
78743: FOR_TO
78744: IFFALSE 78799
// if GetWeapon ( x [ j ] ) = ar_control_tower then
78746: LD_VAR 0 11
78750: PUSH
78751: LD_VAR 0 3
78755: ARRAY
78756: PPUSH
78757: CALL_OW 264
78761: PUSH
78762: LD_INT 31
78764: EQUAL
78765: IFFALSE 78783
// places := places + 1 else
78767: LD_ADDR_VAR 0 5
78771: PUSH
78772: LD_VAR 0 5
78776: PUSH
78777: LD_INT 1
78779: PLUS
78780: ST_TO_ADDR
78781: GO 78797
// places := places + 3 ;
78783: LD_ADDR_VAR 0 5
78787: PUSH
78788: LD_VAR 0 5
78792: PUSH
78793: LD_INT 3
78795: PLUS
78796: ST_TO_ADDR
78797: GO 78743
78799: POP
78800: POP
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
78801: LD_ADDR_VAR 0 6
78805: PUSH
78806: LD_EXP 58
78810: PUSH
78811: LD_VAR 0 2
78815: ARRAY
78816: PPUSH
78817: LD_INT 25
78819: PUSH
78820: LD_INT 3
78822: PUSH
78823: EMPTY
78824: LIST
78825: LIST
78826: PPUSH
78827: CALL_OW 72
78831: PUSH
78832: LD_EXP 98
78836: PUSH
78837: LD_VAR 0 2
78841: ARRAY
78842: DIFF
78843: PPUSH
78844: LD_INT 3
78846: PPUSH
78847: CALL 55302 0 2
78851: ST_TO_ADDR
// if not tmp then
78852: LD_VAR 0 6
78856: NOT
78857: IFFALSE 78861
// continue ;
78859: GO 78241
// places := places - mc_remote_driver [ i ] ;
78861: LD_ADDR_VAR 0 5
78865: PUSH
78866: LD_VAR 0 5
78870: PUSH
78871: LD_EXP 98
78875: PUSH
78876: LD_VAR 0 2
78880: ARRAY
78881: MINUS
78882: ST_TO_ADDR
// if places then
78883: LD_VAR 0 5
78887: IFFALSE 78946
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
78889: LD_ADDR_EXP 98
78893: PUSH
78894: LD_EXP 98
78898: PPUSH
78899: LD_VAR 0 2
78903: PPUSH
78904: LD_EXP 98
78908: PUSH
78909: LD_VAR 0 2
78913: ARRAY
78914: PUSH
78915: LD_VAR 0 6
78919: PUSH
78920: LD_INT 1
78922: ARRAY
78923: UNION
78924: PPUSH
78925: CALL_OW 1
78929: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
78930: LD_VAR 0 6
78934: PUSH
78935: LD_INT 1
78937: ARRAY
78938: PPUSH
78939: LD_INT 126
78941: PPUSH
78942: CALL_OW 109
// end ; end ;
78946: GO 78241
78948: POP
78949: POP
// end ;
78950: LD_VAR 0 1
78954: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
78955: LD_INT 0
78957: PPUSH
78958: PPUSH
78959: PPUSH
78960: PPUSH
78961: PPUSH
78962: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
78963: LD_VAR 0 1
78967: NOT
78968: PUSH
78969: LD_VAR 0 2
78973: NOT
78974: OR
78975: PUSH
78976: LD_VAR 0 3
78980: NOT
78981: OR
78982: PUSH
78983: LD_VAR 0 4
78987: PUSH
78988: LD_INT 1
78990: PUSH
78991: LD_INT 2
78993: PUSH
78994: LD_INT 3
78996: PUSH
78997: LD_INT 4
78999: PUSH
79000: LD_INT 5
79002: PUSH
79003: LD_INT 8
79005: PUSH
79006: LD_INT 9
79008: PUSH
79009: LD_INT 15
79011: PUSH
79012: LD_INT 16
79014: PUSH
79015: EMPTY
79016: LIST
79017: LIST
79018: LIST
79019: LIST
79020: LIST
79021: LIST
79022: LIST
79023: LIST
79024: LIST
79025: IN
79026: NOT
79027: OR
79028: IFFALSE 79032
// exit ;
79030: GO 79932
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79032: LD_ADDR_VAR 0 2
79036: PUSH
79037: LD_VAR 0 2
79041: PPUSH
79042: LD_INT 21
79044: PUSH
79045: LD_INT 3
79047: PUSH
79048: EMPTY
79049: LIST
79050: LIST
79051: PUSH
79052: LD_INT 24
79054: PUSH
79055: LD_INT 250
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: EMPTY
79063: LIST
79064: LIST
79065: PPUSH
79066: CALL_OW 72
79070: ST_TO_ADDR
// case class of 1 , 15 :
79071: LD_VAR 0 4
79075: PUSH
79076: LD_INT 1
79078: DOUBLE
79079: EQUAL
79080: IFTRUE 79090
79082: LD_INT 15
79084: DOUBLE
79085: EQUAL
79086: IFTRUE 79090
79088: GO 79175
79090: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79091: LD_ADDR_VAR 0 8
79095: PUSH
79096: LD_VAR 0 2
79100: PPUSH
79101: LD_INT 2
79103: PUSH
79104: LD_INT 30
79106: PUSH
79107: LD_INT 32
79109: PUSH
79110: EMPTY
79111: LIST
79112: LIST
79113: PUSH
79114: LD_INT 30
79116: PUSH
79117: LD_INT 31
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: EMPTY
79125: LIST
79126: LIST
79127: LIST
79128: PPUSH
79129: CALL_OW 72
79133: PUSH
79134: LD_VAR 0 2
79138: PPUSH
79139: LD_INT 2
79141: PUSH
79142: LD_INT 30
79144: PUSH
79145: LD_INT 4
79147: PUSH
79148: EMPTY
79149: LIST
79150: LIST
79151: PUSH
79152: LD_INT 30
79154: PUSH
79155: LD_INT 5
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: EMPTY
79163: LIST
79164: LIST
79165: LIST
79166: PPUSH
79167: CALL_OW 72
79171: ADD
79172: ST_TO_ADDR
79173: GO 79421
79175: LD_INT 2
79177: DOUBLE
79178: EQUAL
79179: IFTRUE 79189
79181: LD_INT 16
79183: DOUBLE
79184: EQUAL
79185: IFTRUE 79189
79187: GO 79235
79189: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79190: LD_ADDR_VAR 0 8
79194: PUSH
79195: LD_VAR 0 2
79199: PPUSH
79200: LD_INT 2
79202: PUSH
79203: LD_INT 30
79205: PUSH
79206: LD_INT 0
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 30
79215: PUSH
79216: LD_INT 1
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: EMPTY
79224: LIST
79225: LIST
79226: LIST
79227: PPUSH
79228: CALL_OW 72
79232: ST_TO_ADDR
79233: GO 79421
79235: LD_INT 3
79237: DOUBLE
79238: EQUAL
79239: IFTRUE 79243
79241: GO 79289
79243: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79244: LD_ADDR_VAR 0 8
79248: PUSH
79249: LD_VAR 0 2
79253: PPUSH
79254: LD_INT 2
79256: PUSH
79257: LD_INT 30
79259: PUSH
79260: LD_INT 2
79262: PUSH
79263: EMPTY
79264: LIST
79265: LIST
79266: PUSH
79267: LD_INT 30
79269: PUSH
79270: LD_INT 3
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: EMPTY
79278: LIST
79279: LIST
79280: LIST
79281: PPUSH
79282: CALL_OW 72
79286: ST_TO_ADDR
79287: GO 79421
79289: LD_INT 4
79291: DOUBLE
79292: EQUAL
79293: IFTRUE 79297
79295: GO 79354
79297: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79298: LD_ADDR_VAR 0 8
79302: PUSH
79303: LD_VAR 0 2
79307: PPUSH
79308: LD_INT 2
79310: PUSH
79311: LD_INT 30
79313: PUSH
79314: LD_INT 6
79316: PUSH
79317: EMPTY
79318: LIST
79319: LIST
79320: PUSH
79321: LD_INT 30
79323: PUSH
79324: LD_INT 7
79326: PUSH
79327: EMPTY
79328: LIST
79329: LIST
79330: PUSH
79331: LD_INT 30
79333: PUSH
79334: LD_INT 8
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: EMPTY
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: PPUSH
79347: CALL_OW 72
79351: ST_TO_ADDR
79352: GO 79421
79354: LD_INT 5
79356: DOUBLE
79357: EQUAL
79358: IFTRUE 79374
79360: LD_INT 8
79362: DOUBLE
79363: EQUAL
79364: IFTRUE 79374
79366: LD_INT 9
79368: DOUBLE
79369: EQUAL
79370: IFTRUE 79374
79372: GO 79420
79374: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79375: LD_ADDR_VAR 0 8
79379: PUSH
79380: LD_VAR 0 2
79384: PPUSH
79385: LD_INT 2
79387: PUSH
79388: LD_INT 30
79390: PUSH
79391: LD_INT 4
79393: PUSH
79394: EMPTY
79395: LIST
79396: LIST
79397: PUSH
79398: LD_INT 30
79400: PUSH
79401: LD_INT 5
79403: PUSH
79404: EMPTY
79405: LIST
79406: LIST
79407: PUSH
79408: EMPTY
79409: LIST
79410: LIST
79411: LIST
79412: PPUSH
79413: CALL_OW 72
79417: ST_TO_ADDR
79418: GO 79421
79420: POP
// if not tmp then
79421: LD_VAR 0 8
79425: NOT
79426: IFFALSE 79430
// exit ;
79428: GO 79932
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79430: LD_VAR 0 4
79434: PUSH
79435: LD_INT 1
79437: PUSH
79438: LD_INT 15
79440: PUSH
79441: EMPTY
79442: LIST
79443: LIST
79444: IN
79445: PUSH
79446: LD_EXP 67
79450: PUSH
79451: LD_VAR 0 1
79455: ARRAY
79456: AND
79457: IFFALSE 79613
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79459: LD_ADDR_VAR 0 9
79463: PUSH
79464: LD_EXP 67
79468: PUSH
79469: LD_VAR 0 1
79473: ARRAY
79474: PUSH
79475: LD_INT 1
79477: ARRAY
79478: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79479: LD_VAR 0 9
79483: PUSH
79484: LD_EXP 68
79488: PUSH
79489: LD_VAR 0 1
79493: ARRAY
79494: IN
79495: NOT
79496: IFFALSE 79611
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79498: LD_ADDR_EXP 68
79502: PUSH
79503: LD_EXP 68
79507: PPUSH
79508: LD_VAR 0 1
79512: PUSH
79513: LD_EXP 68
79517: PUSH
79518: LD_VAR 0 1
79522: ARRAY
79523: PUSH
79524: LD_INT 1
79526: PLUS
79527: PUSH
79528: EMPTY
79529: LIST
79530: LIST
79531: PPUSH
79532: LD_VAR 0 9
79536: PPUSH
79537: CALL 21054 0 3
79541: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79542: LD_ADDR_EXP 67
79546: PUSH
79547: LD_EXP 67
79551: PPUSH
79552: LD_VAR 0 1
79556: PPUSH
79557: LD_EXP 67
79561: PUSH
79562: LD_VAR 0 1
79566: ARRAY
79567: PUSH
79568: LD_VAR 0 9
79572: DIFF
79573: PPUSH
79574: CALL_OW 1
79578: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
79579: LD_VAR 0 3
79583: PPUSH
79584: LD_EXP 68
79588: PUSH
79589: LD_VAR 0 1
79593: ARRAY
79594: PUSH
79595: LD_EXP 68
79599: PUSH
79600: LD_VAR 0 1
79604: ARRAY
79605: ARRAY
79606: PPUSH
79607: CALL_OW 120
// end ; exit ;
79611: GO 79932
// end ; if tmp > 1 then
79613: LD_VAR 0 8
79617: PUSH
79618: LD_INT 1
79620: GREATER
79621: IFFALSE 79725
// for i = 2 to tmp do
79623: LD_ADDR_VAR 0 6
79627: PUSH
79628: DOUBLE
79629: LD_INT 2
79631: DEC
79632: ST_TO_ADDR
79633: LD_VAR 0 8
79637: PUSH
79638: FOR_TO
79639: IFFALSE 79723
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
79641: LD_VAR 0 8
79645: PUSH
79646: LD_VAR 0 6
79650: ARRAY
79651: PPUSH
79652: CALL_OW 461
79656: PUSH
79657: LD_INT 6
79659: EQUAL
79660: IFFALSE 79721
// begin x := tmp [ i ] ;
79662: LD_ADDR_VAR 0 9
79666: PUSH
79667: LD_VAR 0 8
79671: PUSH
79672: LD_VAR 0 6
79676: ARRAY
79677: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
79678: LD_ADDR_VAR 0 8
79682: PUSH
79683: LD_VAR 0 8
79687: PPUSH
79688: LD_VAR 0 6
79692: PPUSH
79693: CALL_OW 3
79697: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
79698: LD_ADDR_VAR 0 8
79702: PUSH
79703: LD_VAR 0 8
79707: PPUSH
79708: LD_INT 1
79710: PPUSH
79711: LD_VAR 0 9
79715: PPUSH
79716: CALL_OW 2
79720: ST_TO_ADDR
// end ;
79721: GO 79638
79723: POP
79724: POP
// for i in tmp do
79725: LD_ADDR_VAR 0 6
79729: PUSH
79730: LD_VAR 0 8
79734: PUSH
79735: FOR_IN
79736: IFFALSE 79805
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
79738: LD_VAR 0 6
79742: PPUSH
79743: CALL_OW 313
79747: PUSH
79748: LD_INT 6
79750: LESS
79751: PUSH
79752: LD_VAR 0 6
79756: PPUSH
79757: CALL_OW 266
79761: PUSH
79762: LD_INT 31
79764: PUSH
79765: LD_INT 32
79767: PUSH
79768: EMPTY
79769: LIST
79770: LIST
79771: IN
79772: NOT
79773: AND
79774: PUSH
79775: LD_VAR 0 6
79779: PPUSH
79780: CALL_OW 313
79784: PUSH
79785: LD_INT 0
79787: EQUAL
79788: OR
79789: IFFALSE 79803
// begin j := i ;
79791: LD_ADDR_VAR 0 7
79795: PUSH
79796: LD_VAR 0 6
79800: ST_TO_ADDR
// break ;
79801: GO 79805
// end ; end ;
79803: GO 79735
79805: POP
79806: POP
// if j then
79807: LD_VAR 0 7
79811: IFFALSE 79829
// ComEnterUnit ( unit , j ) else
79813: LD_VAR 0 3
79817: PPUSH
79818: LD_VAR 0 7
79822: PPUSH
79823: CALL_OW 120
79827: GO 79932
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
79829: LD_ADDR_VAR 0 10
79833: PUSH
79834: LD_VAR 0 2
79838: PPUSH
79839: LD_INT 2
79841: PUSH
79842: LD_INT 30
79844: PUSH
79845: LD_INT 0
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 30
79854: PUSH
79855: LD_INT 1
79857: PUSH
79858: EMPTY
79859: LIST
79860: LIST
79861: PUSH
79862: EMPTY
79863: LIST
79864: LIST
79865: LIST
79866: PPUSH
79867: CALL_OW 72
79871: ST_TO_ADDR
// if depot then
79872: LD_VAR 0 10
79876: IFFALSE 79932
// begin depot := NearestUnitToUnit ( depot , unit ) ;
79878: LD_ADDR_VAR 0 10
79882: PUSH
79883: LD_VAR 0 10
79887: PPUSH
79888: LD_VAR 0 3
79892: PPUSH
79893: CALL_OW 74
79897: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
79898: LD_VAR 0 3
79902: PPUSH
79903: LD_VAR 0 10
79907: PPUSH
79908: CALL_OW 296
79912: PUSH
79913: LD_INT 10
79915: GREATER
79916: IFFALSE 79932
// ComStandNearbyBuilding ( unit , depot ) ;
79918: LD_VAR 0 3
79922: PPUSH
79923: LD_VAR 0 10
79927: PPUSH
79928: CALL 15406 0 2
// end ; end ; end ;
79932: LD_VAR 0 5
79936: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
79937: LD_INT 0
79939: PPUSH
79940: PPUSH
79941: PPUSH
79942: PPUSH
// if not mc_bases then
79943: LD_EXP 58
79947: NOT
79948: IFFALSE 79952
// exit ;
79950: GO 80191
// for i = 1 to mc_bases do
79952: LD_ADDR_VAR 0 2
79956: PUSH
79957: DOUBLE
79958: LD_INT 1
79960: DEC
79961: ST_TO_ADDR
79962: LD_EXP 58
79966: PUSH
79967: FOR_TO
79968: IFFALSE 80189
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
79970: LD_ADDR_VAR 0 4
79974: PUSH
79975: LD_EXP 58
79979: PUSH
79980: LD_VAR 0 2
79984: ARRAY
79985: PPUSH
79986: LD_INT 21
79988: PUSH
79989: LD_INT 1
79991: PUSH
79992: EMPTY
79993: LIST
79994: LIST
79995: PPUSH
79996: CALL_OW 72
80000: PUSH
80001: LD_EXP 87
80005: PUSH
80006: LD_VAR 0 2
80010: ARRAY
80011: UNION
80012: ST_TO_ADDR
// if not tmp then
80013: LD_VAR 0 4
80017: NOT
80018: IFFALSE 80022
// continue ;
80020: GO 79967
// for j in tmp do
80022: LD_ADDR_VAR 0 3
80026: PUSH
80027: LD_VAR 0 4
80031: PUSH
80032: FOR_IN
80033: IFFALSE 80185
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80035: LD_VAR 0 3
80039: PPUSH
80040: CALL_OW 110
80044: NOT
80045: PUSH
80046: LD_VAR 0 3
80050: PPUSH
80051: CALL_OW 314
80055: NOT
80056: AND
80057: PUSH
80058: LD_VAR 0 3
80062: PPUSH
80063: CALL_OW 311
80067: NOT
80068: AND
80069: PUSH
80070: LD_VAR 0 3
80074: PPUSH
80075: CALL_OW 310
80079: NOT
80080: AND
80081: PUSH
80082: LD_VAR 0 3
80086: PUSH
80087: LD_EXP 61
80091: PUSH
80092: LD_VAR 0 2
80096: ARRAY
80097: PUSH
80098: LD_INT 1
80100: ARRAY
80101: IN
80102: NOT
80103: AND
80104: PUSH
80105: LD_VAR 0 3
80109: PUSH
80110: LD_EXP 61
80114: PUSH
80115: LD_VAR 0 2
80119: ARRAY
80120: PUSH
80121: LD_INT 2
80123: ARRAY
80124: IN
80125: NOT
80126: AND
80127: PUSH
80128: LD_VAR 0 3
80132: PUSH
80133: LD_EXP 70
80137: PUSH
80138: LD_VAR 0 2
80142: ARRAY
80143: IN
80144: NOT
80145: AND
80146: IFFALSE 80183
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80148: LD_VAR 0 2
80152: PPUSH
80153: LD_EXP 58
80157: PUSH
80158: LD_VAR 0 2
80162: ARRAY
80163: PPUSH
80164: LD_VAR 0 3
80168: PPUSH
80169: LD_VAR 0 3
80173: PPUSH
80174: CALL_OW 257
80178: PPUSH
80179: CALL 78955 0 4
// end ;
80183: GO 80032
80185: POP
80186: POP
// end ;
80187: GO 79967
80189: POP
80190: POP
// end ;
80191: LD_VAR 0 1
80195: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80196: LD_INT 0
80198: PPUSH
80199: PPUSH
80200: PPUSH
80201: PPUSH
80202: PPUSH
80203: PPUSH
// if not mc_bases [ base ] then
80204: LD_EXP 58
80208: PUSH
80209: LD_VAR 0 1
80213: ARRAY
80214: NOT
80215: IFFALSE 80219
// exit ;
80217: GO 80401
// tmp := [ ] ;
80219: LD_ADDR_VAR 0 6
80223: PUSH
80224: EMPTY
80225: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80226: LD_ADDR_VAR 0 7
80230: PUSH
80231: LD_VAR 0 3
80235: PPUSH
80236: LD_INT 0
80238: PPUSH
80239: CALL_OW 517
80243: ST_TO_ADDR
// if not list then
80244: LD_VAR 0 7
80248: NOT
80249: IFFALSE 80253
// exit ;
80251: GO 80401
// for i = 1 to amount do
80253: LD_ADDR_VAR 0 5
80257: PUSH
80258: DOUBLE
80259: LD_INT 1
80261: DEC
80262: ST_TO_ADDR
80263: LD_VAR 0 2
80267: PUSH
80268: FOR_TO
80269: IFFALSE 80349
// begin x := rand ( 1 , list [ 1 ] ) ;
80271: LD_ADDR_VAR 0 8
80275: PUSH
80276: LD_INT 1
80278: PPUSH
80279: LD_VAR 0 7
80283: PUSH
80284: LD_INT 1
80286: ARRAY
80287: PPUSH
80288: CALL_OW 12
80292: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80293: LD_ADDR_VAR 0 6
80297: PUSH
80298: LD_VAR 0 6
80302: PPUSH
80303: LD_VAR 0 5
80307: PPUSH
80308: LD_VAR 0 7
80312: PUSH
80313: LD_INT 1
80315: ARRAY
80316: PUSH
80317: LD_VAR 0 8
80321: ARRAY
80322: PUSH
80323: LD_VAR 0 7
80327: PUSH
80328: LD_INT 2
80330: ARRAY
80331: PUSH
80332: LD_VAR 0 8
80336: ARRAY
80337: PUSH
80338: EMPTY
80339: LIST
80340: LIST
80341: PPUSH
80342: CALL_OW 1
80346: ST_TO_ADDR
// end ;
80347: GO 80268
80349: POP
80350: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80351: LD_ADDR_EXP 71
80355: PUSH
80356: LD_EXP 71
80360: PPUSH
80361: LD_VAR 0 1
80365: PPUSH
80366: LD_VAR 0 6
80370: PPUSH
80371: CALL_OW 1
80375: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80376: LD_ADDR_EXP 73
80380: PUSH
80381: LD_EXP 73
80385: PPUSH
80386: LD_VAR 0 1
80390: PPUSH
80391: LD_VAR 0 3
80395: PPUSH
80396: CALL_OW 1
80400: ST_TO_ADDR
// end ;
80401: LD_VAR 0 4
80405: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80406: LD_INT 0
80408: PPUSH
// if not mc_bases [ base ] then
80409: LD_EXP 58
80413: PUSH
80414: LD_VAR 0 1
80418: ARRAY
80419: NOT
80420: IFFALSE 80424
// exit ;
80422: GO 80449
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80424: LD_ADDR_EXP 63
80428: PUSH
80429: LD_EXP 63
80433: PPUSH
80434: LD_VAR 0 1
80438: PPUSH
80439: LD_VAR 0 2
80443: PPUSH
80444: CALL_OW 1
80448: ST_TO_ADDR
// end ;
80449: LD_VAR 0 3
80453: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80454: LD_INT 0
80456: PPUSH
// if not mc_bases [ base ] then
80457: LD_EXP 58
80461: PUSH
80462: LD_VAR 0 1
80466: ARRAY
80467: NOT
80468: IFFALSE 80472
// exit ;
80470: GO 80509
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80472: LD_ADDR_EXP 63
80476: PUSH
80477: LD_EXP 63
80481: PPUSH
80482: LD_VAR 0 1
80486: PPUSH
80487: LD_EXP 63
80491: PUSH
80492: LD_VAR 0 1
80496: ARRAY
80497: PUSH
80498: LD_VAR 0 2
80502: UNION
80503: PPUSH
80504: CALL_OW 1
80508: ST_TO_ADDR
// end ;
80509: LD_VAR 0 3
80513: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80514: LD_INT 0
80516: PPUSH
// if not mc_bases [ base ] then
80517: LD_EXP 58
80521: PUSH
80522: LD_VAR 0 1
80526: ARRAY
80527: NOT
80528: IFFALSE 80532
// exit ;
80530: GO 80557
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80532: LD_ADDR_EXP 79
80536: PUSH
80537: LD_EXP 79
80541: PPUSH
80542: LD_VAR 0 1
80546: PPUSH
80547: LD_VAR 0 2
80551: PPUSH
80552: CALL_OW 1
80556: ST_TO_ADDR
// end ;
80557: LD_VAR 0 3
80561: RET
// export function MC_InsertProduceList ( base , components ) ; begin
80562: LD_INT 0
80564: PPUSH
// if not mc_bases [ base ] then
80565: LD_EXP 58
80569: PUSH
80570: LD_VAR 0 1
80574: ARRAY
80575: NOT
80576: IFFALSE 80580
// exit ;
80578: GO 80617
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
80580: LD_ADDR_EXP 79
80584: PUSH
80585: LD_EXP 79
80589: PPUSH
80590: LD_VAR 0 1
80594: PPUSH
80595: LD_EXP 79
80599: PUSH
80600: LD_VAR 0 1
80604: ARRAY
80605: PUSH
80606: LD_VAR 0 2
80610: ADD
80611: PPUSH
80612: CALL_OW 1
80616: ST_TO_ADDR
// end ;
80617: LD_VAR 0 3
80621: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
80622: LD_INT 0
80624: PPUSH
// if not mc_bases [ base ] then
80625: LD_EXP 58
80629: PUSH
80630: LD_VAR 0 1
80634: ARRAY
80635: NOT
80636: IFFALSE 80640
// exit ;
80638: GO 80694
// mc_defender := Replace ( mc_defender , base , deflist ) ;
80640: LD_ADDR_EXP 80
80644: PUSH
80645: LD_EXP 80
80649: PPUSH
80650: LD_VAR 0 1
80654: PPUSH
80655: LD_VAR 0 2
80659: PPUSH
80660: CALL_OW 1
80664: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
80665: LD_ADDR_EXP 69
80669: PUSH
80670: LD_EXP 69
80674: PPUSH
80675: LD_VAR 0 1
80679: PPUSH
80680: LD_VAR 0 2
80684: PUSH
80685: LD_INT 0
80687: PLUS
80688: PPUSH
80689: CALL_OW 1
80693: ST_TO_ADDR
// end ;
80694: LD_VAR 0 3
80698: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
80699: LD_INT 0
80701: PPUSH
// if not mc_bases [ base ] then
80702: LD_EXP 58
80706: PUSH
80707: LD_VAR 0 1
80711: ARRAY
80712: NOT
80713: IFFALSE 80717
// exit ;
80715: GO 80742
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
80717: LD_ADDR_EXP 69
80721: PUSH
80722: LD_EXP 69
80726: PPUSH
80727: LD_VAR 0 1
80731: PPUSH
80732: LD_VAR 0 2
80736: PPUSH
80737: CALL_OW 1
80741: ST_TO_ADDR
// end ;
80742: LD_VAR 0 3
80746: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
80747: LD_INT 0
80749: PPUSH
80750: PPUSH
80751: PPUSH
80752: PPUSH
// if not mc_bases [ base ] then
80753: LD_EXP 58
80757: PUSH
80758: LD_VAR 0 1
80762: ARRAY
80763: NOT
80764: IFFALSE 80768
// exit ;
80766: GO 80833
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
80768: LD_ADDR_EXP 78
80772: PUSH
80773: LD_EXP 78
80777: PPUSH
80778: LD_VAR 0 1
80782: PUSH
80783: LD_EXP 78
80787: PUSH
80788: LD_VAR 0 1
80792: ARRAY
80793: PUSH
80794: LD_INT 1
80796: PLUS
80797: PUSH
80798: EMPTY
80799: LIST
80800: LIST
80801: PPUSH
80802: LD_VAR 0 1
80806: PUSH
80807: LD_VAR 0 2
80811: PUSH
80812: LD_VAR 0 3
80816: PUSH
80817: LD_VAR 0 4
80821: PUSH
80822: EMPTY
80823: LIST
80824: LIST
80825: LIST
80826: LIST
80827: PPUSH
80828: CALL 21054 0 3
80832: ST_TO_ADDR
// end ;
80833: LD_VAR 0 5
80837: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
80838: LD_INT 0
80840: PPUSH
// if not mc_bases [ base ] then
80841: LD_EXP 58
80845: PUSH
80846: LD_VAR 0 1
80850: ARRAY
80851: NOT
80852: IFFALSE 80856
// exit ;
80854: GO 80881
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
80856: LD_ADDR_EXP 95
80860: PUSH
80861: LD_EXP 95
80865: PPUSH
80866: LD_VAR 0 1
80870: PPUSH
80871: LD_VAR 0 2
80875: PPUSH
80876: CALL_OW 1
80880: ST_TO_ADDR
// end ;
80881: LD_VAR 0 3
80885: RET
// export function MC_GetMinesField ( base ) ; begin
80886: LD_INT 0
80888: PPUSH
// result := mc_mines [ base ] ;
80889: LD_ADDR_VAR 0 2
80893: PUSH
80894: LD_EXP 71
80898: PUSH
80899: LD_VAR 0 1
80903: ARRAY
80904: ST_TO_ADDR
// end ;
80905: LD_VAR 0 2
80909: RET
// export function MC_GetProduceList ( base ) ; begin
80910: LD_INT 0
80912: PPUSH
// result := mc_produce [ base ] ;
80913: LD_ADDR_VAR 0 2
80917: PUSH
80918: LD_EXP 79
80922: PUSH
80923: LD_VAR 0 1
80927: ARRAY
80928: ST_TO_ADDR
// end ;
80929: LD_VAR 0 2
80933: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
80934: LD_INT 0
80936: PPUSH
80937: PPUSH
// if not mc_bases then
80938: LD_EXP 58
80942: NOT
80943: IFFALSE 80947
// exit ;
80945: GO 81012
// if mc_bases [ base ] then
80947: LD_EXP 58
80951: PUSH
80952: LD_VAR 0 1
80956: ARRAY
80957: IFFALSE 81012
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
80959: LD_ADDR_VAR 0 3
80963: PUSH
80964: LD_EXP 58
80968: PUSH
80969: LD_VAR 0 1
80973: ARRAY
80974: PPUSH
80975: LD_INT 30
80977: PUSH
80978: LD_VAR 0 2
80982: PUSH
80983: EMPTY
80984: LIST
80985: LIST
80986: PPUSH
80987: CALL_OW 72
80991: ST_TO_ADDR
// if result then
80992: LD_VAR 0 3
80996: IFFALSE 81012
// result := result [ 1 ] ;
80998: LD_ADDR_VAR 0 3
81002: PUSH
81003: LD_VAR 0 3
81007: PUSH
81008: LD_INT 1
81010: ARRAY
81011: ST_TO_ADDR
// end ; end ;
81012: LD_VAR 0 3
81016: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81017: LD_INT 0
81019: PPUSH
81020: PPUSH
// if not mc_bases then
81021: LD_EXP 58
81025: NOT
81026: IFFALSE 81030
// exit ;
81028: GO 81075
// if mc_bases [ base ] then
81030: LD_EXP 58
81034: PUSH
81035: LD_VAR 0 1
81039: ARRAY
81040: IFFALSE 81075
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81042: LD_ADDR_VAR 0 3
81046: PUSH
81047: LD_EXP 58
81051: PUSH
81052: LD_VAR 0 1
81056: ARRAY
81057: PPUSH
81058: LD_INT 30
81060: PUSH
81061: LD_VAR 0 2
81065: PUSH
81066: EMPTY
81067: LIST
81068: LIST
81069: PPUSH
81070: CALL_OW 72
81074: ST_TO_ADDR
// end ;
81075: LD_VAR 0 3
81079: RET
// export function MC_SetTame ( base , area ) ; begin
81080: LD_INT 0
81082: PPUSH
// if not mc_bases or not base then
81083: LD_EXP 58
81087: NOT
81088: PUSH
81089: LD_VAR 0 1
81093: NOT
81094: OR
81095: IFFALSE 81099
// exit ;
81097: GO 81124
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81099: LD_ADDR_EXP 86
81103: PUSH
81104: LD_EXP 86
81108: PPUSH
81109: LD_VAR 0 1
81113: PPUSH
81114: LD_VAR 0 2
81118: PPUSH
81119: CALL_OW 1
81123: ST_TO_ADDR
// end ;
81124: LD_VAR 0 3
81128: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81129: LD_INT 0
81131: PPUSH
81132: PPUSH
// if not mc_bases or not base then
81133: LD_EXP 58
81137: NOT
81138: PUSH
81139: LD_VAR 0 1
81143: NOT
81144: OR
81145: IFFALSE 81149
// exit ;
81147: GO 81251
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81149: LD_ADDR_VAR 0 4
81153: PUSH
81154: LD_EXP 58
81158: PUSH
81159: LD_VAR 0 1
81163: ARRAY
81164: PPUSH
81165: LD_INT 30
81167: PUSH
81168: LD_VAR 0 2
81172: PUSH
81173: EMPTY
81174: LIST
81175: LIST
81176: PPUSH
81177: CALL_OW 72
81181: ST_TO_ADDR
// if not tmp then
81182: LD_VAR 0 4
81186: NOT
81187: IFFALSE 81191
// exit ;
81189: GO 81251
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81191: LD_ADDR_EXP 90
81195: PUSH
81196: LD_EXP 90
81200: PPUSH
81201: LD_VAR 0 1
81205: PPUSH
81206: LD_EXP 90
81210: PUSH
81211: LD_VAR 0 1
81215: ARRAY
81216: PPUSH
81217: LD_EXP 90
81221: PUSH
81222: LD_VAR 0 1
81226: ARRAY
81227: PUSH
81228: LD_INT 1
81230: PLUS
81231: PPUSH
81232: LD_VAR 0 4
81236: PUSH
81237: LD_INT 1
81239: ARRAY
81240: PPUSH
81241: CALL_OW 2
81245: PPUSH
81246: CALL_OW 1
81250: ST_TO_ADDR
// end ;
81251: LD_VAR 0 3
81255: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81256: LD_INT 0
81258: PPUSH
81259: PPUSH
// if not mc_bases or not base or not kinds then
81260: LD_EXP 58
81264: NOT
81265: PUSH
81266: LD_VAR 0 1
81270: NOT
81271: OR
81272: PUSH
81273: LD_VAR 0 2
81277: NOT
81278: OR
81279: IFFALSE 81283
// exit ;
81281: GO 81344
// for i in kinds do
81283: LD_ADDR_VAR 0 4
81287: PUSH
81288: LD_VAR 0 2
81292: PUSH
81293: FOR_IN
81294: IFFALSE 81342
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81296: LD_ADDR_EXP 92
81300: PUSH
81301: LD_EXP 92
81305: PPUSH
81306: LD_VAR 0 1
81310: PUSH
81311: LD_EXP 92
81315: PUSH
81316: LD_VAR 0 1
81320: ARRAY
81321: PUSH
81322: LD_INT 1
81324: PLUS
81325: PUSH
81326: EMPTY
81327: LIST
81328: LIST
81329: PPUSH
81330: LD_VAR 0 4
81334: PPUSH
81335: CALL 21054 0 3
81339: ST_TO_ADDR
81340: GO 81293
81342: POP
81343: POP
// end ;
81344: LD_VAR 0 3
81348: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81349: LD_INT 0
81351: PPUSH
// if not mc_bases or not base or not areas then
81352: LD_EXP 58
81356: NOT
81357: PUSH
81358: LD_VAR 0 1
81362: NOT
81363: OR
81364: PUSH
81365: LD_VAR 0 2
81369: NOT
81370: OR
81371: IFFALSE 81375
// exit ;
81373: GO 81400
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81375: LD_ADDR_EXP 76
81379: PUSH
81380: LD_EXP 76
81384: PPUSH
81385: LD_VAR 0 1
81389: PPUSH
81390: LD_VAR 0 2
81394: PPUSH
81395: CALL_OW 1
81399: ST_TO_ADDR
// end ;
81400: LD_VAR 0 3
81404: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81405: LD_INT 0
81407: PPUSH
// if not mc_bases or not base or not teleports_exit then
81408: LD_EXP 58
81412: NOT
81413: PUSH
81414: LD_VAR 0 1
81418: NOT
81419: OR
81420: PUSH
81421: LD_VAR 0 2
81425: NOT
81426: OR
81427: IFFALSE 81431
// exit ;
81429: GO 81456
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81431: LD_ADDR_EXP 93
81435: PUSH
81436: LD_EXP 93
81440: PPUSH
81441: LD_VAR 0 1
81445: PPUSH
81446: LD_VAR 0 2
81450: PPUSH
81451: CALL_OW 1
81455: ST_TO_ADDR
// end ;
81456: LD_VAR 0 3
81460: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81461: LD_INT 0
81463: PPUSH
81464: PPUSH
81465: PPUSH
// if not mc_bases or not base or not ext_list then
81466: LD_EXP 58
81470: NOT
81471: PUSH
81472: LD_VAR 0 1
81476: NOT
81477: OR
81478: PUSH
81479: LD_VAR 0 5
81483: NOT
81484: OR
81485: IFFALSE 81489
// exit ;
81487: GO 81662
// tmp := GetFacExtXYD ( x , y , d ) ;
81489: LD_ADDR_VAR 0 8
81493: PUSH
81494: LD_VAR 0 2
81498: PPUSH
81499: LD_VAR 0 3
81503: PPUSH
81504: LD_VAR 0 4
81508: PPUSH
81509: CALL 54432 0 3
81513: ST_TO_ADDR
// if not tmp then
81514: LD_VAR 0 8
81518: NOT
81519: IFFALSE 81523
// exit ;
81521: GO 81662
// for i in tmp do
81523: LD_ADDR_VAR 0 7
81527: PUSH
81528: LD_VAR 0 8
81532: PUSH
81533: FOR_IN
81534: IFFALSE 81660
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81536: LD_ADDR_EXP 63
81540: PUSH
81541: LD_EXP 63
81545: PPUSH
81546: LD_VAR 0 1
81550: PPUSH
81551: LD_EXP 63
81555: PUSH
81556: LD_VAR 0 1
81560: ARRAY
81561: PPUSH
81562: LD_EXP 63
81566: PUSH
81567: LD_VAR 0 1
81571: ARRAY
81572: PUSH
81573: LD_INT 1
81575: PLUS
81576: PPUSH
81577: LD_VAR 0 5
81581: PUSH
81582: LD_INT 1
81584: ARRAY
81585: PUSH
81586: LD_VAR 0 7
81590: PUSH
81591: LD_INT 1
81593: ARRAY
81594: PUSH
81595: LD_VAR 0 7
81599: PUSH
81600: LD_INT 2
81602: ARRAY
81603: PUSH
81604: LD_VAR 0 7
81608: PUSH
81609: LD_INT 3
81611: ARRAY
81612: PUSH
81613: EMPTY
81614: LIST
81615: LIST
81616: LIST
81617: LIST
81618: PPUSH
81619: CALL_OW 2
81623: PPUSH
81624: CALL_OW 1
81628: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
81629: LD_ADDR_VAR 0 5
81633: PUSH
81634: LD_VAR 0 5
81638: PPUSH
81639: LD_INT 1
81641: PPUSH
81642: CALL_OW 3
81646: ST_TO_ADDR
// if not ext_list then
81647: LD_VAR 0 5
81651: NOT
81652: IFFALSE 81658
// exit ;
81654: POP
81655: POP
81656: GO 81662
// end ;
81658: GO 81533
81660: POP
81661: POP
// end ;
81662: LD_VAR 0 6
81666: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
81667: LD_INT 0
81669: PPUSH
// if not mc_bases or not base or not weapon_list then
81670: LD_EXP 58
81674: NOT
81675: PUSH
81676: LD_VAR 0 1
81680: NOT
81681: OR
81682: PUSH
81683: LD_VAR 0 2
81687: NOT
81688: OR
81689: IFFALSE 81693
// exit ;
81691: GO 81718
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
81693: LD_ADDR_EXP 97
81697: PUSH
81698: LD_EXP 97
81702: PPUSH
81703: LD_VAR 0 1
81707: PPUSH
81708: LD_VAR 0 2
81712: PPUSH
81713: CALL_OW 1
81717: ST_TO_ADDR
// end ;
81718: LD_VAR 0 3
81722: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
81723: LD_INT 0
81725: PPUSH
// if not mc_bases or not base or not tech_list then
81726: LD_EXP 58
81730: NOT
81731: PUSH
81732: LD_VAR 0 1
81736: NOT
81737: OR
81738: PUSH
81739: LD_VAR 0 2
81743: NOT
81744: OR
81745: IFFALSE 81749
// exit ;
81747: GO 81774
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
81749: LD_ADDR_EXP 85
81753: PUSH
81754: LD_EXP 85
81758: PPUSH
81759: LD_VAR 0 1
81763: PPUSH
81764: LD_VAR 0 2
81768: PPUSH
81769: CALL_OW 1
81773: ST_TO_ADDR
// end ;
81774: LD_VAR 0 3
81778: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
81779: LD_INT 0
81781: PPUSH
// if not mc_bases or not parking_area or not base then
81782: LD_EXP 58
81786: NOT
81787: PUSH
81788: LD_VAR 0 2
81792: NOT
81793: OR
81794: PUSH
81795: LD_VAR 0 1
81799: NOT
81800: OR
81801: IFFALSE 81805
// exit ;
81803: GO 81830
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
81805: LD_ADDR_EXP 82
81809: PUSH
81810: LD_EXP 82
81814: PPUSH
81815: LD_VAR 0 1
81819: PPUSH
81820: LD_VAR 0 2
81824: PPUSH
81825: CALL_OW 1
81829: ST_TO_ADDR
// end ;
81830: LD_VAR 0 3
81834: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
81835: LD_INT 0
81837: PPUSH
// if not mc_bases or not base or not scan_area then
81838: LD_EXP 58
81842: NOT
81843: PUSH
81844: LD_VAR 0 1
81848: NOT
81849: OR
81850: PUSH
81851: LD_VAR 0 2
81855: NOT
81856: OR
81857: IFFALSE 81861
// exit ;
81859: GO 81886
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
81861: LD_ADDR_EXP 83
81865: PUSH
81866: LD_EXP 83
81870: PPUSH
81871: LD_VAR 0 1
81875: PPUSH
81876: LD_VAR 0 2
81880: PPUSH
81881: CALL_OW 1
81885: ST_TO_ADDR
// end ;
81886: LD_VAR 0 3
81890: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
81891: LD_INT 0
81893: PPUSH
81894: PPUSH
// if not mc_bases or not base then
81895: LD_EXP 58
81899: NOT
81900: PUSH
81901: LD_VAR 0 1
81905: NOT
81906: OR
81907: IFFALSE 81911
// exit ;
81909: GO 81975
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
81911: LD_ADDR_VAR 0 3
81915: PUSH
81916: LD_INT 1
81918: PUSH
81919: LD_INT 2
81921: PUSH
81922: LD_INT 3
81924: PUSH
81925: LD_INT 4
81927: PUSH
81928: LD_INT 11
81930: PUSH
81931: EMPTY
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
81938: LD_ADDR_EXP 85
81942: PUSH
81943: LD_EXP 85
81947: PPUSH
81948: LD_VAR 0 1
81952: PPUSH
81953: LD_EXP 85
81957: PUSH
81958: LD_VAR 0 1
81962: ARRAY
81963: PUSH
81964: LD_VAR 0 3
81968: DIFF
81969: PPUSH
81970: CALL_OW 1
81974: ST_TO_ADDR
// end ;
81975: LD_VAR 0 2
81979: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
81980: LD_INT 0
81982: PPUSH
// result := mc_vehicles [ base ] ;
81983: LD_ADDR_VAR 0 3
81987: PUSH
81988: LD_EXP 77
81992: PUSH
81993: LD_VAR 0 1
81997: ARRAY
81998: ST_TO_ADDR
// if onlyCombat then
81999: LD_VAR 0 2
82003: IFFALSE 82168
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82005: LD_ADDR_VAR 0 3
82009: PUSH
82010: LD_VAR 0 3
82014: PUSH
82015: LD_VAR 0 3
82019: PPUSH
82020: LD_INT 2
82022: PUSH
82023: LD_INT 34
82025: PUSH
82026: LD_INT 12
82028: PUSH
82029: EMPTY
82030: LIST
82031: LIST
82032: PUSH
82033: LD_INT 34
82035: PUSH
82036: LD_INT 51
82038: PUSH
82039: EMPTY
82040: LIST
82041: LIST
82042: PUSH
82043: LD_INT 34
82045: PUSH
82046: LD_EXP 102
82050: PUSH
82051: EMPTY
82052: LIST
82053: LIST
82054: PUSH
82055: LD_INT 34
82057: PUSH
82058: LD_INT 32
82060: PUSH
82061: EMPTY
82062: LIST
82063: LIST
82064: PUSH
82065: LD_INT 34
82067: PUSH
82068: LD_INT 13
82070: PUSH
82071: EMPTY
82072: LIST
82073: LIST
82074: PUSH
82075: LD_INT 34
82077: PUSH
82078: LD_INT 52
82080: PUSH
82081: EMPTY
82082: LIST
82083: LIST
82084: PUSH
82085: LD_INT 34
82087: PUSH
82088: LD_INT 14
82090: PUSH
82091: EMPTY
82092: LIST
82093: LIST
82094: PUSH
82095: LD_INT 34
82097: PUSH
82098: LD_INT 53
82100: PUSH
82101: EMPTY
82102: LIST
82103: LIST
82104: PUSH
82105: LD_INT 34
82107: PUSH
82108: LD_EXP 101
82112: PUSH
82113: EMPTY
82114: LIST
82115: LIST
82116: PUSH
82117: LD_INT 34
82119: PUSH
82120: LD_INT 31
82122: PUSH
82123: EMPTY
82124: LIST
82125: LIST
82126: PUSH
82127: LD_INT 34
82129: PUSH
82130: LD_INT 48
82132: PUSH
82133: EMPTY
82134: LIST
82135: LIST
82136: PUSH
82137: LD_INT 34
82139: PUSH
82140: LD_INT 8
82142: PUSH
82143: EMPTY
82144: LIST
82145: LIST
82146: PUSH
82147: EMPTY
82148: LIST
82149: LIST
82150: LIST
82151: LIST
82152: LIST
82153: LIST
82154: LIST
82155: LIST
82156: LIST
82157: LIST
82158: LIST
82159: LIST
82160: LIST
82161: PPUSH
82162: CALL_OW 72
82166: DIFF
82167: ST_TO_ADDR
// end ; end_of_file
82168: LD_VAR 0 3
82172: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82173: LD_INT 0
82175: PPUSH
82176: PPUSH
82177: PPUSH
// if not mc_bases or not skirmish then
82178: LD_EXP 58
82182: NOT
82183: PUSH
82184: LD_EXP 56
82188: NOT
82189: OR
82190: IFFALSE 82194
// exit ;
82192: GO 82359
// for i = 1 to mc_bases do
82194: LD_ADDR_VAR 0 4
82198: PUSH
82199: DOUBLE
82200: LD_INT 1
82202: DEC
82203: ST_TO_ADDR
82204: LD_EXP 58
82208: PUSH
82209: FOR_TO
82210: IFFALSE 82357
// begin if sci in mc_bases [ i ] then
82212: LD_VAR 0 2
82216: PUSH
82217: LD_EXP 58
82221: PUSH
82222: LD_VAR 0 4
82226: ARRAY
82227: IN
82228: IFFALSE 82355
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82230: LD_ADDR_EXP 87
82234: PUSH
82235: LD_EXP 87
82239: PPUSH
82240: LD_VAR 0 4
82244: PUSH
82245: LD_EXP 87
82249: PUSH
82250: LD_VAR 0 4
82254: ARRAY
82255: PUSH
82256: LD_INT 1
82258: PLUS
82259: PUSH
82260: EMPTY
82261: LIST
82262: LIST
82263: PPUSH
82264: LD_VAR 0 1
82268: PPUSH
82269: CALL 21054 0 3
82273: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82274: LD_ADDR_VAR 0 5
82278: PUSH
82279: LD_EXP 58
82283: PUSH
82284: LD_VAR 0 4
82288: ARRAY
82289: PPUSH
82290: LD_INT 2
82292: PUSH
82293: LD_INT 30
82295: PUSH
82296: LD_INT 0
82298: PUSH
82299: EMPTY
82300: LIST
82301: LIST
82302: PUSH
82303: LD_INT 30
82305: PUSH
82306: LD_INT 1
82308: PUSH
82309: EMPTY
82310: LIST
82311: LIST
82312: PUSH
82313: EMPTY
82314: LIST
82315: LIST
82316: LIST
82317: PPUSH
82318: CALL_OW 72
82322: PPUSH
82323: LD_VAR 0 1
82327: PPUSH
82328: CALL_OW 74
82332: ST_TO_ADDR
// if tmp then
82333: LD_VAR 0 5
82337: IFFALSE 82353
// ComStandNearbyBuilding ( ape , tmp ) ;
82339: LD_VAR 0 1
82343: PPUSH
82344: LD_VAR 0 5
82348: PPUSH
82349: CALL 15406 0 2
// break ;
82353: GO 82357
// end ; end ;
82355: GO 82209
82357: POP
82358: POP
// end ;
82359: LD_VAR 0 3
82363: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82364: LD_INT 0
82366: PPUSH
82367: PPUSH
82368: PPUSH
// if not mc_bases or not skirmish then
82369: LD_EXP 58
82373: NOT
82374: PUSH
82375: LD_EXP 56
82379: NOT
82380: OR
82381: IFFALSE 82385
// exit ;
82383: GO 82474
// for i = 1 to mc_bases do
82385: LD_ADDR_VAR 0 4
82389: PUSH
82390: DOUBLE
82391: LD_INT 1
82393: DEC
82394: ST_TO_ADDR
82395: LD_EXP 58
82399: PUSH
82400: FOR_TO
82401: IFFALSE 82472
// begin if building in mc_busy_turret_list [ i ] then
82403: LD_VAR 0 1
82407: PUSH
82408: LD_EXP 68
82412: PUSH
82413: LD_VAR 0 4
82417: ARRAY
82418: IN
82419: IFFALSE 82470
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82421: LD_ADDR_VAR 0 5
82425: PUSH
82426: LD_EXP 68
82430: PUSH
82431: LD_VAR 0 4
82435: ARRAY
82436: PUSH
82437: LD_VAR 0 1
82441: DIFF
82442: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82443: LD_ADDR_EXP 68
82447: PUSH
82448: LD_EXP 68
82452: PPUSH
82453: LD_VAR 0 4
82457: PPUSH
82458: LD_VAR 0 5
82462: PPUSH
82463: CALL_OW 1
82467: ST_TO_ADDR
// break ;
82468: GO 82472
// end ; end ;
82470: GO 82400
82472: POP
82473: POP
// end ;
82474: LD_VAR 0 3
82478: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82479: LD_INT 0
82481: PPUSH
82482: PPUSH
82483: PPUSH
// if not mc_bases or not skirmish then
82484: LD_EXP 58
82488: NOT
82489: PUSH
82490: LD_EXP 56
82494: NOT
82495: OR
82496: IFFALSE 82500
// exit ;
82498: GO 82699
// for i = 1 to mc_bases do
82500: LD_ADDR_VAR 0 5
82504: PUSH
82505: DOUBLE
82506: LD_INT 1
82508: DEC
82509: ST_TO_ADDR
82510: LD_EXP 58
82514: PUSH
82515: FOR_TO
82516: IFFALSE 82697
// if building in mc_bases [ i ] then
82518: LD_VAR 0 1
82522: PUSH
82523: LD_EXP 58
82527: PUSH
82528: LD_VAR 0 5
82532: ARRAY
82533: IN
82534: IFFALSE 82695
// begin tmp := mc_bases [ i ] diff building ;
82536: LD_ADDR_VAR 0 6
82540: PUSH
82541: LD_EXP 58
82545: PUSH
82546: LD_VAR 0 5
82550: ARRAY
82551: PUSH
82552: LD_VAR 0 1
82556: DIFF
82557: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82558: LD_ADDR_EXP 58
82562: PUSH
82563: LD_EXP 58
82567: PPUSH
82568: LD_VAR 0 5
82572: PPUSH
82573: LD_VAR 0 6
82577: PPUSH
82578: CALL_OW 1
82582: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
82583: LD_VAR 0 1
82587: PUSH
82588: LD_EXP 66
82592: PUSH
82593: LD_VAR 0 5
82597: ARRAY
82598: IN
82599: IFFALSE 82638
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
82601: LD_ADDR_EXP 66
82605: PUSH
82606: LD_EXP 66
82610: PPUSH
82611: LD_VAR 0 5
82615: PPUSH
82616: LD_EXP 66
82620: PUSH
82621: LD_VAR 0 5
82625: ARRAY
82626: PUSH
82627: LD_VAR 0 1
82631: DIFF
82632: PPUSH
82633: CALL_OW 1
82637: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
82638: LD_VAR 0 1
82642: PUSH
82643: LD_EXP 67
82647: PUSH
82648: LD_VAR 0 5
82652: ARRAY
82653: IN
82654: IFFALSE 82693
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
82656: LD_ADDR_EXP 67
82660: PUSH
82661: LD_EXP 67
82665: PPUSH
82666: LD_VAR 0 5
82670: PPUSH
82671: LD_EXP 67
82675: PUSH
82676: LD_VAR 0 5
82680: ARRAY
82681: PUSH
82682: LD_VAR 0 1
82686: DIFF
82687: PPUSH
82688: CALL_OW 1
82692: ST_TO_ADDR
// break ;
82693: GO 82697
// end ;
82695: GO 82515
82697: POP
82698: POP
// end ;
82699: LD_VAR 0 4
82703: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
82704: LD_INT 0
82706: PPUSH
82707: PPUSH
82708: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
82709: LD_EXP 58
82713: NOT
82714: PUSH
82715: LD_EXP 56
82719: NOT
82720: OR
82721: PUSH
82722: LD_VAR 0 3
82726: PUSH
82727: LD_EXP 84
82731: IN
82732: NOT
82733: OR
82734: IFFALSE 82738
// exit ;
82736: GO 82861
// for i = 1 to mc_vehicles do
82738: LD_ADDR_VAR 0 6
82742: PUSH
82743: DOUBLE
82744: LD_INT 1
82746: DEC
82747: ST_TO_ADDR
82748: LD_EXP 77
82752: PUSH
82753: FOR_TO
82754: IFFALSE 82859
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
82756: LD_VAR 0 2
82760: PUSH
82761: LD_EXP 77
82765: PUSH
82766: LD_VAR 0 6
82770: ARRAY
82771: IN
82772: PUSH
82773: LD_VAR 0 1
82777: PUSH
82778: LD_EXP 77
82782: PUSH
82783: LD_VAR 0 6
82787: ARRAY
82788: IN
82789: OR
82790: IFFALSE 82857
// begin tmp := mc_vehicles [ i ] diff old ;
82792: LD_ADDR_VAR 0 7
82796: PUSH
82797: LD_EXP 77
82801: PUSH
82802: LD_VAR 0 6
82806: ARRAY
82807: PUSH
82808: LD_VAR 0 2
82812: DIFF
82813: ST_TO_ADDR
// tmp := tmp diff new ;
82814: LD_ADDR_VAR 0 7
82818: PUSH
82819: LD_VAR 0 7
82823: PUSH
82824: LD_VAR 0 1
82828: DIFF
82829: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
82830: LD_ADDR_EXP 77
82834: PUSH
82835: LD_EXP 77
82839: PPUSH
82840: LD_VAR 0 6
82844: PPUSH
82845: LD_VAR 0 7
82849: PPUSH
82850: CALL_OW 1
82854: ST_TO_ADDR
// break ;
82855: GO 82859
// end ;
82857: GO 82753
82859: POP
82860: POP
// end ;
82861: LD_VAR 0 5
82865: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
82866: LD_INT 0
82868: PPUSH
82869: PPUSH
82870: PPUSH
82871: PPUSH
// if not mc_bases or not skirmish then
82872: LD_EXP 58
82876: NOT
82877: PUSH
82878: LD_EXP 56
82882: NOT
82883: OR
82884: IFFALSE 82888
// exit ;
82886: GO 83265
// side := GetSide ( vehicle ) ;
82888: LD_ADDR_VAR 0 5
82892: PUSH
82893: LD_VAR 0 1
82897: PPUSH
82898: CALL_OW 255
82902: ST_TO_ADDR
// for i = 1 to mc_bases do
82903: LD_ADDR_VAR 0 4
82907: PUSH
82908: DOUBLE
82909: LD_INT 1
82911: DEC
82912: ST_TO_ADDR
82913: LD_EXP 58
82917: PUSH
82918: FOR_TO
82919: IFFALSE 83263
// begin if factory in mc_bases [ i ] then
82921: LD_VAR 0 2
82925: PUSH
82926: LD_EXP 58
82930: PUSH
82931: LD_VAR 0 4
82935: ARRAY
82936: IN
82937: IFFALSE 83261
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
82939: LD_EXP 80
82943: PUSH
82944: LD_VAR 0 4
82948: ARRAY
82949: PUSH
82950: LD_EXP 69
82954: PUSH
82955: LD_VAR 0 4
82959: ARRAY
82960: LESS
82961: PUSH
82962: LD_VAR 0 1
82966: PPUSH
82967: CALL_OW 264
82971: PUSH
82972: LD_INT 31
82974: PUSH
82975: LD_INT 32
82977: PUSH
82978: LD_INT 51
82980: PUSH
82981: LD_EXP 102
82985: PUSH
82986: LD_INT 12
82988: PUSH
82989: LD_INT 30
82991: PUSH
82992: LD_EXP 101
82996: PUSH
82997: LD_INT 11
82999: PUSH
83000: LD_INT 53
83002: PUSH
83003: LD_INT 14
83005: PUSH
83006: LD_EXP 105
83010: PUSH
83011: LD_INT 29
83013: PUSH
83014: LD_EXP 103
83018: PUSH
83019: LD_INT 13
83021: PUSH
83022: LD_INT 52
83024: PUSH
83025: LD_INT 48
83027: PUSH
83028: LD_INT 8
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: LIST
83035: LIST
83036: LIST
83037: LIST
83038: LIST
83039: LIST
83040: LIST
83041: LIST
83042: LIST
83043: LIST
83044: LIST
83045: LIST
83046: LIST
83047: LIST
83048: LIST
83049: IN
83050: NOT
83051: AND
83052: IFFALSE 83100
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83054: LD_ADDR_EXP 80
83058: PUSH
83059: LD_EXP 80
83063: PPUSH
83064: LD_VAR 0 4
83068: PUSH
83069: LD_EXP 80
83073: PUSH
83074: LD_VAR 0 4
83078: ARRAY
83079: PUSH
83080: LD_INT 1
83082: PLUS
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: PPUSH
83088: LD_VAR 0 1
83092: PPUSH
83093: CALL 21054 0 3
83097: ST_TO_ADDR
83098: GO 83144
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83100: LD_ADDR_EXP 77
83104: PUSH
83105: LD_EXP 77
83109: PPUSH
83110: LD_VAR 0 4
83114: PUSH
83115: LD_EXP 77
83119: PUSH
83120: LD_VAR 0 4
83124: ARRAY
83125: PUSH
83126: LD_INT 1
83128: PLUS
83129: PUSH
83130: EMPTY
83131: LIST
83132: LIST
83133: PPUSH
83134: LD_VAR 0 1
83138: PPUSH
83139: CALL 21054 0 3
83143: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83144: LD_VAR 0 1
83148: PPUSH
83149: CALL_OW 263
83153: PUSH
83154: LD_INT 2
83156: EQUAL
83157: IFFALSE 83177
// begin repeat wait ( 0 0$1 ) ;
83159: LD_INT 35
83161: PPUSH
83162: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83166: LD_VAR 0 1
83170: PPUSH
83171: CALL_OW 312
83175: IFFALSE 83159
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83177: LD_VAR 0 1
83181: PPUSH
83182: LD_EXP 82
83186: PUSH
83187: LD_VAR 0 4
83191: ARRAY
83192: PPUSH
83193: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83197: LD_VAR 0 1
83201: PPUSH
83202: CALL_OW 263
83206: PUSH
83207: LD_INT 1
83209: NONEQUAL
83210: IFFALSE 83214
// break ;
83212: GO 83263
// repeat wait ( 0 0$1 ) ;
83214: LD_INT 35
83216: PPUSH
83217: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83221: LD_VAR 0 1
83225: PPUSH
83226: LD_EXP 82
83230: PUSH
83231: LD_VAR 0 4
83235: ARRAY
83236: PPUSH
83237: CALL_OW 308
83241: IFFALSE 83214
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83243: LD_VAR 0 1
83247: PPUSH
83248: CALL_OW 311
83252: PPUSH
83253: CALL_OW 121
// exit ;
83257: POP
83258: POP
83259: GO 83265
// end ; end ;
83261: GO 82918
83263: POP
83264: POP
// end ;
83265: LD_VAR 0 3
83269: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83270: LD_INT 0
83272: PPUSH
83273: PPUSH
83274: PPUSH
83275: PPUSH
// if not mc_bases or not skirmish then
83276: LD_EXP 58
83280: NOT
83281: PUSH
83282: LD_EXP 56
83286: NOT
83287: OR
83288: IFFALSE 83292
// exit ;
83290: GO 83645
// repeat wait ( 0 0$1 ) ;
83292: LD_INT 35
83294: PPUSH
83295: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83299: LD_VAR 0 2
83303: PPUSH
83304: LD_VAR 0 3
83308: PPUSH
83309: CALL_OW 284
83313: IFFALSE 83292
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83315: LD_VAR 0 2
83319: PPUSH
83320: LD_VAR 0 3
83324: PPUSH
83325: CALL_OW 283
83329: PUSH
83330: LD_INT 4
83332: EQUAL
83333: IFFALSE 83337
// exit ;
83335: GO 83645
// for i = 1 to mc_bases do
83337: LD_ADDR_VAR 0 7
83341: PUSH
83342: DOUBLE
83343: LD_INT 1
83345: DEC
83346: ST_TO_ADDR
83347: LD_EXP 58
83351: PUSH
83352: FOR_TO
83353: IFFALSE 83643
// begin if mc_crates_area [ i ] then
83355: LD_EXP 76
83359: PUSH
83360: LD_VAR 0 7
83364: ARRAY
83365: IFFALSE 83476
// for j in mc_crates_area [ i ] do
83367: LD_ADDR_VAR 0 8
83371: PUSH
83372: LD_EXP 76
83376: PUSH
83377: LD_VAR 0 7
83381: ARRAY
83382: PUSH
83383: FOR_IN
83384: IFFALSE 83474
// if InArea ( x , y , j ) then
83386: LD_VAR 0 2
83390: PPUSH
83391: LD_VAR 0 3
83395: PPUSH
83396: LD_VAR 0 8
83400: PPUSH
83401: CALL_OW 309
83405: IFFALSE 83472
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83407: LD_ADDR_EXP 74
83411: PUSH
83412: LD_EXP 74
83416: PPUSH
83417: LD_VAR 0 7
83421: PUSH
83422: LD_EXP 74
83426: PUSH
83427: LD_VAR 0 7
83431: ARRAY
83432: PUSH
83433: LD_INT 1
83435: PLUS
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: PPUSH
83441: LD_VAR 0 4
83445: PUSH
83446: LD_VAR 0 2
83450: PUSH
83451: LD_VAR 0 3
83455: PUSH
83456: EMPTY
83457: LIST
83458: LIST
83459: LIST
83460: PPUSH
83461: CALL 21054 0 3
83465: ST_TO_ADDR
// exit ;
83466: POP
83467: POP
83468: POP
83469: POP
83470: GO 83645
// end ;
83472: GO 83383
83474: POP
83475: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83476: LD_ADDR_VAR 0 9
83480: PUSH
83481: LD_EXP 58
83485: PUSH
83486: LD_VAR 0 7
83490: ARRAY
83491: PPUSH
83492: LD_INT 2
83494: PUSH
83495: LD_INT 30
83497: PUSH
83498: LD_INT 0
83500: PUSH
83501: EMPTY
83502: LIST
83503: LIST
83504: PUSH
83505: LD_INT 30
83507: PUSH
83508: LD_INT 1
83510: PUSH
83511: EMPTY
83512: LIST
83513: LIST
83514: PUSH
83515: EMPTY
83516: LIST
83517: LIST
83518: LIST
83519: PPUSH
83520: CALL_OW 72
83524: ST_TO_ADDR
// if not depot then
83525: LD_VAR 0 9
83529: NOT
83530: IFFALSE 83534
// continue ;
83532: GO 83352
// for j in depot do
83534: LD_ADDR_VAR 0 8
83538: PUSH
83539: LD_VAR 0 9
83543: PUSH
83544: FOR_IN
83545: IFFALSE 83639
// if GetDistUnitXY ( j , x , y ) < 30 then
83547: LD_VAR 0 8
83551: PPUSH
83552: LD_VAR 0 2
83556: PPUSH
83557: LD_VAR 0 3
83561: PPUSH
83562: CALL_OW 297
83566: PUSH
83567: LD_INT 30
83569: LESS
83570: IFFALSE 83637
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83572: LD_ADDR_EXP 74
83576: PUSH
83577: LD_EXP 74
83581: PPUSH
83582: LD_VAR 0 7
83586: PUSH
83587: LD_EXP 74
83591: PUSH
83592: LD_VAR 0 7
83596: ARRAY
83597: PUSH
83598: LD_INT 1
83600: PLUS
83601: PUSH
83602: EMPTY
83603: LIST
83604: LIST
83605: PPUSH
83606: LD_VAR 0 4
83610: PUSH
83611: LD_VAR 0 2
83615: PUSH
83616: LD_VAR 0 3
83620: PUSH
83621: EMPTY
83622: LIST
83623: LIST
83624: LIST
83625: PPUSH
83626: CALL 21054 0 3
83630: ST_TO_ADDR
// exit ;
83631: POP
83632: POP
83633: POP
83634: POP
83635: GO 83645
// end ;
83637: GO 83544
83639: POP
83640: POP
// end ;
83641: GO 83352
83643: POP
83644: POP
// end ;
83645: LD_VAR 0 6
83649: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
83650: LD_INT 0
83652: PPUSH
83653: PPUSH
83654: PPUSH
83655: PPUSH
// if not mc_bases or not skirmish then
83656: LD_EXP 58
83660: NOT
83661: PUSH
83662: LD_EXP 56
83666: NOT
83667: OR
83668: IFFALSE 83672
// exit ;
83670: GO 83949
// side := GetSide ( lab ) ;
83672: LD_ADDR_VAR 0 4
83676: PUSH
83677: LD_VAR 0 2
83681: PPUSH
83682: CALL_OW 255
83686: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
83687: LD_VAR 0 4
83691: PUSH
83692: LD_EXP 84
83696: IN
83697: NOT
83698: PUSH
83699: LD_EXP 85
83703: NOT
83704: OR
83705: PUSH
83706: LD_EXP 58
83710: NOT
83711: OR
83712: IFFALSE 83716
// exit ;
83714: GO 83949
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
83716: LD_ADDR_EXP 85
83720: PUSH
83721: LD_EXP 85
83725: PPUSH
83726: LD_VAR 0 4
83730: PPUSH
83731: LD_EXP 85
83735: PUSH
83736: LD_VAR 0 4
83740: ARRAY
83741: PUSH
83742: LD_VAR 0 1
83746: DIFF
83747: PPUSH
83748: CALL_OW 1
83752: ST_TO_ADDR
// for i = 1 to mc_bases do
83753: LD_ADDR_VAR 0 5
83757: PUSH
83758: DOUBLE
83759: LD_INT 1
83761: DEC
83762: ST_TO_ADDR
83763: LD_EXP 58
83767: PUSH
83768: FOR_TO
83769: IFFALSE 83947
// begin if lab in mc_bases [ i ] then
83771: LD_VAR 0 2
83775: PUSH
83776: LD_EXP 58
83780: PUSH
83781: LD_VAR 0 5
83785: ARRAY
83786: IN
83787: IFFALSE 83945
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
83789: LD_VAR 0 1
83793: PUSH
83794: LD_INT 11
83796: PUSH
83797: LD_INT 4
83799: PUSH
83800: LD_INT 3
83802: PUSH
83803: LD_INT 2
83805: PUSH
83806: EMPTY
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: IN
83812: PUSH
83813: LD_EXP 88
83817: PUSH
83818: LD_VAR 0 5
83822: ARRAY
83823: AND
83824: IFFALSE 83945
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
83826: LD_ADDR_VAR 0 6
83830: PUSH
83831: LD_EXP 88
83835: PUSH
83836: LD_VAR 0 5
83840: ARRAY
83841: PUSH
83842: LD_INT 1
83844: ARRAY
83845: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
83846: LD_ADDR_EXP 88
83850: PUSH
83851: LD_EXP 88
83855: PPUSH
83856: LD_VAR 0 5
83860: PPUSH
83861: EMPTY
83862: PPUSH
83863: CALL_OW 1
83867: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
83868: LD_VAR 0 6
83872: PPUSH
83873: LD_INT 0
83875: PPUSH
83876: CALL_OW 109
// ComExitBuilding ( tmp ) ;
83880: LD_VAR 0 6
83884: PPUSH
83885: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
83889: LD_ADDR_EXP 87
83893: PUSH
83894: LD_EXP 87
83898: PPUSH
83899: LD_VAR 0 5
83903: PPUSH
83904: LD_EXP 87
83908: PUSH
83909: LD_VAR 0 5
83913: ARRAY
83914: PPUSH
83915: LD_INT 1
83917: PPUSH
83918: LD_VAR 0 6
83922: PPUSH
83923: CALL_OW 2
83927: PPUSH
83928: CALL_OW 1
83932: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
83933: LD_VAR 0 5
83937: PPUSH
83938: LD_INT 112
83940: PPUSH
83941: CALL 61057 0 2
// end ; end ; end ;
83945: GO 83768
83947: POP
83948: POP
// end ;
83949: LD_VAR 0 3
83953: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
83954: LD_INT 0
83956: PPUSH
83957: PPUSH
83958: PPUSH
83959: PPUSH
83960: PPUSH
83961: PPUSH
83962: PPUSH
83963: PPUSH
// if not mc_bases or not skirmish then
83964: LD_EXP 58
83968: NOT
83969: PUSH
83970: LD_EXP 56
83974: NOT
83975: OR
83976: IFFALSE 83980
// exit ;
83978: GO 85217
// for i = 1 to mc_bases do
83980: LD_ADDR_VAR 0 3
83984: PUSH
83985: DOUBLE
83986: LD_INT 1
83988: DEC
83989: ST_TO_ADDR
83990: LD_EXP 58
83994: PUSH
83995: FOR_TO
83996: IFFALSE 85215
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
83998: LD_VAR 0 1
84002: PUSH
84003: LD_EXP 58
84007: PUSH
84008: LD_VAR 0 3
84012: ARRAY
84013: IN
84014: PUSH
84015: LD_VAR 0 1
84019: PUSH
84020: LD_EXP 65
84024: PUSH
84025: LD_VAR 0 3
84029: ARRAY
84030: IN
84031: OR
84032: PUSH
84033: LD_VAR 0 1
84037: PUSH
84038: LD_EXP 80
84042: PUSH
84043: LD_VAR 0 3
84047: ARRAY
84048: IN
84049: OR
84050: PUSH
84051: LD_VAR 0 1
84055: PUSH
84056: LD_EXP 77
84060: PUSH
84061: LD_VAR 0 3
84065: ARRAY
84066: IN
84067: OR
84068: PUSH
84069: LD_VAR 0 1
84073: PUSH
84074: LD_EXP 87
84078: PUSH
84079: LD_VAR 0 3
84083: ARRAY
84084: IN
84085: OR
84086: PUSH
84087: LD_VAR 0 1
84091: PUSH
84092: LD_EXP 88
84096: PUSH
84097: LD_VAR 0 3
84101: ARRAY
84102: IN
84103: OR
84104: IFFALSE 85213
// begin if un in mc_ape [ i ] then
84106: LD_VAR 0 1
84110: PUSH
84111: LD_EXP 87
84115: PUSH
84116: LD_VAR 0 3
84120: ARRAY
84121: IN
84122: IFFALSE 84161
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84124: LD_ADDR_EXP 87
84128: PUSH
84129: LD_EXP 87
84133: PPUSH
84134: LD_VAR 0 3
84138: PPUSH
84139: LD_EXP 87
84143: PUSH
84144: LD_VAR 0 3
84148: ARRAY
84149: PUSH
84150: LD_VAR 0 1
84154: DIFF
84155: PPUSH
84156: CALL_OW 1
84160: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84161: LD_VAR 0 1
84165: PUSH
84166: LD_EXP 88
84170: PUSH
84171: LD_VAR 0 3
84175: ARRAY
84176: IN
84177: IFFALSE 84201
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84179: LD_ADDR_EXP 88
84183: PUSH
84184: LD_EXP 88
84188: PPUSH
84189: LD_VAR 0 3
84193: PPUSH
84194: EMPTY
84195: PPUSH
84196: CALL_OW 1
84200: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane ] ) then
84201: LD_VAR 0 1
84205: PPUSH
84206: CALL_OW 247
84210: PUSH
84211: LD_INT 2
84213: EQUAL
84214: PUSH
84215: LD_VAR 0 1
84219: PPUSH
84220: CALL_OW 110
84224: PUSH
84225: LD_INT 20
84227: EQUAL
84228: PUSH
84229: LD_VAR 0 1
84233: PUSH
84234: LD_EXP 80
84238: PUSH
84239: LD_VAR 0 3
84243: ARRAY
84244: IN
84245: OR
84246: PUSH
84247: LD_VAR 0 1
84251: PPUSH
84252: CALL_OW 264
84256: PUSH
84257: LD_INT 12
84259: PUSH
84260: LD_INT 51
84262: PUSH
84263: LD_EXP 102
84267: PUSH
84268: LD_INT 32
84270: PUSH
84271: LD_INT 13
84273: PUSH
84274: LD_INT 52
84276: PUSH
84277: EMPTY
84278: LIST
84279: LIST
84280: LIST
84281: LIST
84282: LIST
84283: LIST
84284: IN
84285: OR
84286: AND
84287: IFFALSE 84465
// begin if un in mc_defender [ i ] then
84289: LD_VAR 0 1
84293: PUSH
84294: LD_EXP 80
84298: PUSH
84299: LD_VAR 0 3
84303: ARRAY
84304: IN
84305: IFFALSE 84344
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84307: LD_ADDR_EXP 80
84311: PUSH
84312: LD_EXP 80
84316: PPUSH
84317: LD_VAR 0 3
84321: PPUSH
84322: LD_EXP 80
84326: PUSH
84327: LD_VAR 0 3
84331: ARRAY
84332: PUSH
84333: LD_VAR 0 1
84337: DIFF
84338: PPUSH
84339: CALL_OW 1
84343: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84344: LD_ADDR_VAR 0 8
84348: PUSH
84349: LD_VAR 0 3
84353: PPUSH
84354: LD_INT 3
84356: PPUSH
84357: CALL 81017 0 2
84361: ST_TO_ADDR
// if fac then
84362: LD_VAR 0 8
84366: IFFALSE 84465
// begin for j in fac do
84368: LD_ADDR_VAR 0 4
84372: PUSH
84373: LD_VAR 0 8
84377: PUSH
84378: FOR_IN
84379: IFFALSE 84463
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84381: LD_ADDR_VAR 0 9
84385: PUSH
84386: LD_VAR 0 8
84390: PPUSH
84391: LD_VAR 0 1
84395: PPUSH
84396: CALL_OW 265
84400: PPUSH
84401: LD_VAR 0 1
84405: PPUSH
84406: CALL_OW 262
84410: PPUSH
84411: LD_VAR 0 1
84415: PPUSH
84416: CALL_OW 263
84420: PPUSH
84421: LD_VAR 0 1
84425: PPUSH
84426: CALL_OW 264
84430: PPUSH
84431: CALL 18586 0 5
84435: ST_TO_ADDR
// if components then
84436: LD_VAR 0 9
84440: IFFALSE 84461
// begin MC_InsertProduceList ( i , [ components ] ) ;
84442: LD_VAR 0 3
84446: PPUSH
84447: LD_VAR 0 9
84451: PUSH
84452: EMPTY
84453: LIST
84454: PPUSH
84455: CALL 80562 0 2
// break ;
84459: GO 84463
// end ; end ;
84461: GO 84378
84463: POP
84464: POP
// end ; end ; if GetType ( un ) = unit_building then
84465: LD_VAR 0 1
84469: PPUSH
84470: CALL_OW 247
84474: PUSH
84475: LD_INT 3
84477: EQUAL
84478: IFFALSE 84881
// begin btype := GetBType ( un ) ;
84480: LD_ADDR_VAR 0 5
84484: PUSH
84485: LD_VAR 0 1
84489: PPUSH
84490: CALL_OW 266
84494: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
84495: LD_VAR 0 5
84499: PUSH
84500: LD_INT 29
84502: PUSH
84503: LD_INT 30
84505: PUSH
84506: EMPTY
84507: LIST
84508: LIST
84509: IN
84510: IFFALSE 84583
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
84512: LD_VAR 0 1
84516: PPUSH
84517: CALL_OW 250
84521: PPUSH
84522: LD_VAR 0 1
84526: PPUSH
84527: CALL_OW 251
84531: PPUSH
84532: LD_VAR 0 1
84536: PPUSH
84537: CALL_OW 255
84541: PPUSH
84542: CALL_OW 440
84546: NOT
84547: IFFALSE 84583
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
84549: LD_VAR 0 1
84553: PPUSH
84554: CALL_OW 250
84558: PPUSH
84559: LD_VAR 0 1
84563: PPUSH
84564: CALL_OW 251
84568: PPUSH
84569: LD_VAR 0 1
84573: PPUSH
84574: CALL_OW 255
84578: PPUSH
84579: CALL_OW 441
// end ; if btype = b_warehouse then
84583: LD_VAR 0 5
84587: PUSH
84588: LD_INT 1
84590: EQUAL
84591: IFFALSE 84609
// begin btype := b_depot ;
84593: LD_ADDR_VAR 0 5
84597: PUSH
84598: LD_INT 0
84600: ST_TO_ADDR
// pos := 1 ;
84601: LD_ADDR_VAR 0 6
84605: PUSH
84606: LD_INT 1
84608: ST_TO_ADDR
// end ; if btype = b_factory then
84609: LD_VAR 0 5
84613: PUSH
84614: LD_INT 3
84616: EQUAL
84617: IFFALSE 84635
// begin btype := b_workshop ;
84619: LD_ADDR_VAR 0 5
84623: PUSH
84624: LD_INT 2
84626: ST_TO_ADDR
// pos := 1 ;
84627: LD_ADDR_VAR 0 6
84631: PUSH
84632: LD_INT 1
84634: ST_TO_ADDR
// end ; if btype = b_barracks then
84635: LD_VAR 0 5
84639: PUSH
84640: LD_INT 5
84642: EQUAL
84643: IFFALSE 84653
// btype := b_armoury ;
84645: LD_ADDR_VAR 0 5
84649: PUSH
84650: LD_INT 4
84652: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
84653: LD_VAR 0 5
84657: PUSH
84658: LD_INT 7
84660: PUSH
84661: LD_INT 8
84663: PUSH
84664: EMPTY
84665: LIST
84666: LIST
84667: IN
84668: IFFALSE 84678
// btype := b_lab ;
84670: LD_ADDR_VAR 0 5
84674: PUSH
84675: LD_INT 6
84677: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
84678: LD_ADDR_EXP 63
84682: PUSH
84683: LD_EXP 63
84687: PPUSH
84688: LD_VAR 0 3
84692: PUSH
84693: LD_EXP 63
84697: PUSH
84698: LD_VAR 0 3
84702: ARRAY
84703: PUSH
84704: LD_INT 1
84706: PLUS
84707: PUSH
84708: EMPTY
84709: LIST
84710: LIST
84711: PPUSH
84712: LD_VAR 0 5
84716: PUSH
84717: LD_VAR 0 1
84721: PPUSH
84722: CALL_OW 250
84726: PUSH
84727: LD_VAR 0 1
84731: PPUSH
84732: CALL_OW 251
84736: PUSH
84737: LD_VAR 0 1
84741: PPUSH
84742: CALL_OW 254
84746: PUSH
84747: EMPTY
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: PPUSH
84753: CALL 21054 0 3
84757: ST_TO_ADDR
// if pos = 1 then
84758: LD_VAR 0 6
84762: PUSH
84763: LD_INT 1
84765: EQUAL
84766: IFFALSE 84881
// begin tmp := mc_build_list [ i ] ;
84768: LD_ADDR_VAR 0 7
84772: PUSH
84773: LD_EXP 63
84777: PUSH
84778: LD_VAR 0 3
84782: ARRAY
84783: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
84784: LD_VAR 0 7
84788: PPUSH
84789: LD_INT 2
84791: PUSH
84792: LD_INT 30
84794: PUSH
84795: LD_INT 0
84797: PUSH
84798: EMPTY
84799: LIST
84800: LIST
84801: PUSH
84802: LD_INT 30
84804: PUSH
84805: LD_INT 1
84807: PUSH
84808: EMPTY
84809: LIST
84810: LIST
84811: PUSH
84812: EMPTY
84813: LIST
84814: LIST
84815: LIST
84816: PPUSH
84817: CALL_OW 72
84821: IFFALSE 84831
// pos := 2 ;
84823: LD_ADDR_VAR 0 6
84827: PUSH
84828: LD_INT 2
84830: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
84831: LD_ADDR_VAR 0 7
84835: PUSH
84836: LD_VAR 0 7
84840: PPUSH
84841: LD_VAR 0 6
84845: PPUSH
84846: LD_VAR 0 7
84850: PPUSH
84851: CALL 21380 0 3
84855: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
84856: LD_ADDR_EXP 63
84860: PUSH
84861: LD_EXP 63
84865: PPUSH
84866: LD_VAR 0 3
84870: PPUSH
84871: LD_VAR 0 7
84875: PPUSH
84876: CALL_OW 1
84880: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
84881: LD_VAR 0 1
84885: PUSH
84886: LD_EXP 58
84890: PUSH
84891: LD_VAR 0 3
84895: ARRAY
84896: IN
84897: IFFALSE 84936
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
84899: LD_ADDR_EXP 58
84903: PUSH
84904: LD_EXP 58
84908: PPUSH
84909: LD_VAR 0 3
84913: PPUSH
84914: LD_EXP 58
84918: PUSH
84919: LD_VAR 0 3
84923: ARRAY
84924: PUSH
84925: LD_VAR 0 1
84929: DIFF
84930: PPUSH
84931: CALL_OW 1
84935: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
84936: LD_VAR 0 1
84940: PUSH
84941: LD_EXP 65
84945: PUSH
84946: LD_VAR 0 3
84950: ARRAY
84951: IN
84952: IFFALSE 84991
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
84954: LD_ADDR_EXP 65
84958: PUSH
84959: LD_EXP 65
84963: PPUSH
84964: LD_VAR 0 3
84968: PPUSH
84969: LD_EXP 65
84973: PUSH
84974: LD_VAR 0 3
84978: ARRAY
84979: PUSH
84980: LD_VAR 0 1
84984: DIFF
84985: PPUSH
84986: CALL_OW 1
84990: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
84991: LD_VAR 0 1
84995: PUSH
84996: LD_EXP 77
85000: PUSH
85001: LD_VAR 0 3
85005: ARRAY
85006: IN
85007: IFFALSE 85046
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85009: LD_ADDR_EXP 77
85013: PUSH
85014: LD_EXP 77
85018: PPUSH
85019: LD_VAR 0 3
85023: PPUSH
85024: LD_EXP 77
85028: PUSH
85029: LD_VAR 0 3
85033: ARRAY
85034: PUSH
85035: LD_VAR 0 1
85039: DIFF
85040: PPUSH
85041: CALL_OW 1
85045: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85046: LD_VAR 0 1
85050: PUSH
85051: LD_EXP 80
85055: PUSH
85056: LD_VAR 0 3
85060: ARRAY
85061: IN
85062: IFFALSE 85101
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85064: LD_ADDR_EXP 80
85068: PUSH
85069: LD_EXP 80
85073: PPUSH
85074: LD_VAR 0 3
85078: PPUSH
85079: LD_EXP 80
85083: PUSH
85084: LD_VAR 0 3
85088: ARRAY
85089: PUSH
85090: LD_VAR 0 1
85094: DIFF
85095: PPUSH
85096: CALL_OW 1
85100: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85101: LD_VAR 0 1
85105: PUSH
85106: LD_EXP 67
85110: PUSH
85111: LD_VAR 0 3
85115: ARRAY
85116: IN
85117: IFFALSE 85156
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85119: LD_ADDR_EXP 67
85123: PUSH
85124: LD_EXP 67
85128: PPUSH
85129: LD_VAR 0 3
85133: PPUSH
85134: LD_EXP 67
85138: PUSH
85139: LD_VAR 0 3
85143: ARRAY
85144: PUSH
85145: LD_VAR 0 1
85149: DIFF
85150: PPUSH
85151: CALL_OW 1
85155: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85156: LD_VAR 0 1
85160: PUSH
85161: LD_EXP 66
85165: PUSH
85166: LD_VAR 0 3
85170: ARRAY
85171: IN
85172: IFFALSE 85211
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85174: LD_ADDR_EXP 66
85178: PUSH
85179: LD_EXP 66
85183: PPUSH
85184: LD_VAR 0 3
85188: PPUSH
85189: LD_EXP 66
85193: PUSH
85194: LD_VAR 0 3
85198: ARRAY
85199: PUSH
85200: LD_VAR 0 1
85204: DIFF
85205: PPUSH
85206: CALL_OW 1
85210: ST_TO_ADDR
// end ; break ;
85211: GO 85215
// end ;
85213: GO 83995
85215: POP
85216: POP
// end ;
85217: LD_VAR 0 2
85221: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85222: LD_INT 0
85224: PPUSH
85225: PPUSH
85226: PPUSH
// if not mc_bases or not skirmish then
85227: LD_EXP 58
85231: NOT
85232: PUSH
85233: LD_EXP 56
85237: NOT
85238: OR
85239: IFFALSE 85243
// exit ;
85241: GO 85458
// for i = 1 to mc_bases do
85243: LD_ADDR_VAR 0 3
85247: PUSH
85248: DOUBLE
85249: LD_INT 1
85251: DEC
85252: ST_TO_ADDR
85253: LD_EXP 58
85257: PUSH
85258: FOR_TO
85259: IFFALSE 85456
// begin if building in mc_construct_list [ i ] then
85261: LD_VAR 0 1
85265: PUSH
85266: LD_EXP 65
85270: PUSH
85271: LD_VAR 0 3
85275: ARRAY
85276: IN
85277: IFFALSE 85454
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85279: LD_ADDR_EXP 65
85283: PUSH
85284: LD_EXP 65
85288: PPUSH
85289: LD_VAR 0 3
85293: PPUSH
85294: LD_EXP 65
85298: PUSH
85299: LD_VAR 0 3
85303: ARRAY
85304: PUSH
85305: LD_VAR 0 1
85309: DIFF
85310: PPUSH
85311: CALL_OW 1
85315: ST_TO_ADDR
// if building in mc_lab [ i ] then
85316: LD_VAR 0 1
85320: PUSH
85321: LD_EXP 91
85325: PUSH
85326: LD_VAR 0 3
85330: ARRAY
85331: IN
85332: IFFALSE 85387
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85334: LD_ADDR_EXP 92
85338: PUSH
85339: LD_EXP 92
85343: PPUSH
85344: LD_VAR 0 3
85348: PPUSH
85349: LD_EXP 92
85353: PUSH
85354: LD_VAR 0 3
85358: ARRAY
85359: PPUSH
85360: LD_INT 1
85362: PPUSH
85363: LD_EXP 92
85367: PUSH
85368: LD_VAR 0 3
85372: ARRAY
85373: PPUSH
85374: LD_INT 0
85376: PPUSH
85377: CALL 20472 0 4
85381: PPUSH
85382: CALL_OW 1
85386: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85387: LD_VAR 0 1
85391: PUSH
85392: LD_EXP 58
85396: PUSH
85397: LD_VAR 0 3
85401: ARRAY
85402: IN
85403: NOT
85404: IFFALSE 85450
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85406: LD_ADDR_EXP 58
85410: PUSH
85411: LD_EXP 58
85415: PPUSH
85416: LD_VAR 0 3
85420: PUSH
85421: LD_EXP 58
85425: PUSH
85426: LD_VAR 0 3
85430: ARRAY
85431: PUSH
85432: LD_INT 1
85434: PLUS
85435: PUSH
85436: EMPTY
85437: LIST
85438: LIST
85439: PPUSH
85440: LD_VAR 0 1
85444: PPUSH
85445: CALL 21054 0 3
85449: ST_TO_ADDR
// exit ;
85450: POP
85451: POP
85452: GO 85458
// end ; end ;
85454: GO 85258
85456: POP
85457: POP
// end ;
85458: LD_VAR 0 2
85462: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
85463: LD_INT 0
85465: PPUSH
85466: PPUSH
85467: PPUSH
85468: PPUSH
85469: PPUSH
85470: PPUSH
85471: PPUSH
// if not mc_bases or not skirmish then
85472: LD_EXP 58
85476: NOT
85477: PUSH
85478: LD_EXP 56
85482: NOT
85483: OR
85484: IFFALSE 85488
// exit ;
85486: GO 86149
// for i = 1 to mc_bases do
85488: LD_ADDR_VAR 0 3
85492: PUSH
85493: DOUBLE
85494: LD_INT 1
85496: DEC
85497: ST_TO_ADDR
85498: LD_EXP 58
85502: PUSH
85503: FOR_TO
85504: IFFALSE 86147
// begin if building in mc_construct_list [ i ] then
85506: LD_VAR 0 1
85510: PUSH
85511: LD_EXP 65
85515: PUSH
85516: LD_VAR 0 3
85520: ARRAY
85521: IN
85522: IFFALSE 86145
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85524: LD_ADDR_EXP 65
85528: PUSH
85529: LD_EXP 65
85533: PPUSH
85534: LD_VAR 0 3
85538: PPUSH
85539: LD_EXP 65
85543: PUSH
85544: LD_VAR 0 3
85548: ARRAY
85549: PUSH
85550: LD_VAR 0 1
85554: DIFF
85555: PPUSH
85556: CALL_OW 1
85560: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85561: LD_ADDR_EXP 58
85565: PUSH
85566: LD_EXP 58
85570: PPUSH
85571: LD_VAR 0 3
85575: PUSH
85576: LD_EXP 58
85580: PUSH
85581: LD_VAR 0 3
85585: ARRAY
85586: PUSH
85587: LD_INT 1
85589: PLUS
85590: PUSH
85591: EMPTY
85592: LIST
85593: LIST
85594: PPUSH
85595: LD_VAR 0 1
85599: PPUSH
85600: CALL 21054 0 3
85604: ST_TO_ADDR
// btype := GetBType ( building ) ;
85605: LD_ADDR_VAR 0 5
85609: PUSH
85610: LD_VAR 0 1
85614: PPUSH
85615: CALL_OW 266
85619: ST_TO_ADDR
// side := GetSide ( building ) ;
85620: LD_ADDR_VAR 0 8
85624: PUSH
85625: LD_VAR 0 1
85629: PPUSH
85630: CALL_OW 255
85634: ST_TO_ADDR
// if btype = b_lab then
85635: LD_VAR 0 5
85639: PUSH
85640: LD_INT 6
85642: EQUAL
85643: IFFALSE 85693
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
85645: LD_ADDR_EXP 91
85649: PUSH
85650: LD_EXP 91
85654: PPUSH
85655: LD_VAR 0 3
85659: PUSH
85660: LD_EXP 91
85664: PUSH
85665: LD_VAR 0 3
85669: ARRAY
85670: PUSH
85671: LD_INT 1
85673: PLUS
85674: PUSH
85675: EMPTY
85676: LIST
85677: LIST
85678: PPUSH
85679: LD_VAR 0 1
85683: PPUSH
85684: CALL 21054 0 3
85688: ST_TO_ADDR
// exit ;
85689: POP
85690: POP
85691: GO 86149
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
85693: LD_VAR 0 5
85697: PUSH
85698: LD_INT 0
85700: PUSH
85701: LD_INT 2
85703: PUSH
85704: LD_INT 4
85706: PUSH
85707: EMPTY
85708: LIST
85709: LIST
85710: LIST
85711: IN
85712: IFFALSE 85836
// begin if btype = b_armoury then
85714: LD_VAR 0 5
85718: PUSH
85719: LD_INT 4
85721: EQUAL
85722: IFFALSE 85732
// btype := b_barracks ;
85724: LD_ADDR_VAR 0 5
85728: PUSH
85729: LD_INT 5
85731: ST_TO_ADDR
// if btype = b_depot then
85732: LD_VAR 0 5
85736: PUSH
85737: LD_INT 0
85739: EQUAL
85740: IFFALSE 85750
// btype := b_warehouse ;
85742: LD_ADDR_VAR 0 5
85746: PUSH
85747: LD_INT 1
85749: ST_TO_ADDR
// if btype = b_workshop then
85750: LD_VAR 0 5
85754: PUSH
85755: LD_INT 2
85757: EQUAL
85758: IFFALSE 85768
// btype := b_factory ;
85760: LD_ADDR_VAR 0 5
85764: PUSH
85765: LD_INT 3
85767: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
85768: LD_VAR 0 5
85772: PPUSH
85773: LD_VAR 0 8
85777: PPUSH
85778: CALL_OW 323
85782: PUSH
85783: LD_INT 1
85785: EQUAL
85786: IFFALSE 85832
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
85788: LD_ADDR_EXP 90
85792: PUSH
85793: LD_EXP 90
85797: PPUSH
85798: LD_VAR 0 3
85802: PUSH
85803: LD_EXP 90
85807: PUSH
85808: LD_VAR 0 3
85812: ARRAY
85813: PUSH
85814: LD_INT 1
85816: PLUS
85817: PUSH
85818: EMPTY
85819: LIST
85820: LIST
85821: PPUSH
85822: LD_VAR 0 1
85826: PPUSH
85827: CALL 21054 0 3
85831: ST_TO_ADDR
// exit ;
85832: POP
85833: POP
85834: GO 86149
// end ; if btype in [ b_bunker , b_turret ] then
85836: LD_VAR 0 5
85840: PUSH
85841: LD_INT 32
85843: PUSH
85844: LD_INT 33
85846: PUSH
85847: EMPTY
85848: LIST
85849: LIST
85850: IN
85851: IFFALSE 86141
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
85853: LD_ADDR_EXP 66
85857: PUSH
85858: LD_EXP 66
85862: PPUSH
85863: LD_VAR 0 3
85867: PUSH
85868: LD_EXP 66
85872: PUSH
85873: LD_VAR 0 3
85877: ARRAY
85878: PUSH
85879: LD_INT 1
85881: PLUS
85882: PUSH
85883: EMPTY
85884: LIST
85885: LIST
85886: PPUSH
85887: LD_VAR 0 1
85891: PPUSH
85892: CALL 21054 0 3
85896: ST_TO_ADDR
// if btype = b_bunker then
85897: LD_VAR 0 5
85901: PUSH
85902: LD_INT 32
85904: EQUAL
85905: IFFALSE 86141
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
85907: LD_ADDR_EXP 67
85911: PUSH
85912: LD_EXP 67
85916: PPUSH
85917: LD_VAR 0 3
85921: PUSH
85922: LD_EXP 67
85926: PUSH
85927: LD_VAR 0 3
85931: ARRAY
85932: PUSH
85933: LD_INT 1
85935: PLUS
85936: PUSH
85937: EMPTY
85938: LIST
85939: LIST
85940: PPUSH
85941: LD_VAR 0 1
85945: PPUSH
85946: CALL 21054 0 3
85950: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
85951: LD_ADDR_VAR 0 6
85955: PUSH
85956: LD_EXP 58
85960: PUSH
85961: LD_VAR 0 3
85965: ARRAY
85966: PPUSH
85967: LD_INT 25
85969: PUSH
85970: LD_INT 1
85972: PUSH
85973: EMPTY
85974: LIST
85975: LIST
85976: PUSH
85977: LD_INT 3
85979: PUSH
85980: LD_INT 54
85982: PUSH
85983: EMPTY
85984: LIST
85985: PUSH
85986: EMPTY
85987: LIST
85988: LIST
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PPUSH
85994: CALL_OW 72
85998: ST_TO_ADDR
// if tmp then
85999: LD_VAR 0 6
86003: IFFALSE 86009
// exit ;
86005: POP
86006: POP
86007: GO 86149
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86009: LD_ADDR_VAR 0 6
86013: PUSH
86014: LD_EXP 58
86018: PUSH
86019: LD_VAR 0 3
86023: ARRAY
86024: PPUSH
86025: LD_INT 2
86027: PUSH
86028: LD_INT 30
86030: PUSH
86031: LD_INT 4
86033: PUSH
86034: EMPTY
86035: LIST
86036: LIST
86037: PUSH
86038: LD_INT 30
86040: PUSH
86041: LD_INT 5
86043: PUSH
86044: EMPTY
86045: LIST
86046: LIST
86047: PUSH
86048: EMPTY
86049: LIST
86050: LIST
86051: LIST
86052: PPUSH
86053: CALL_OW 72
86057: ST_TO_ADDR
// if not tmp then
86058: LD_VAR 0 6
86062: NOT
86063: IFFALSE 86069
// exit ;
86065: POP
86066: POP
86067: GO 86149
// for j in tmp do
86069: LD_ADDR_VAR 0 4
86073: PUSH
86074: LD_VAR 0 6
86078: PUSH
86079: FOR_IN
86080: IFFALSE 86139
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86082: LD_ADDR_VAR 0 7
86086: PUSH
86087: LD_VAR 0 4
86091: PPUSH
86092: CALL_OW 313
86096: PPUSH
86097: LD_INT 25
86099: PUSH
86100: LD_INT 1
86102: PUSH
86103: EMPTY
86104: LIST
86105: LIST
86106: PPUSH
86107: CALL_OW 72
86111: ST_TO_ADDR
// if units then
86112: LD_VAR 0 7
86116: IFFALSE 86137
// begin ComExitBuilding ( units [ 1 ] ) ;
86118: LD_VAR 0 7
86122: PUSH
86123: LD_INT 1
86125: ARRAY
86126: PPUSH
86127: CALL_OW 122
// exit ;
86131: POP
86132: POP
86133: POP
86134: POP
86135: GO 86149
// end ; end ;
86137: GO 86079
86139: POP
86140: POP
// end ; end ; exit ;
86141: POP
86142: POP
86143: GO 86149
// end ; end ;
86145: GO 85503
86147: POP
86148: POP
// end ;
86149: LD_VAR 0 2
86153: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86154: LD_INT 0
86156: PPUSH
86157: PPUSH
86158: PPUSH
86159: PPUSH
86160: PPUSH
86161: PPUSH
86162: PPUSH
// if not mc_bases or not skirmish then
86163: LD_EXP 58
86167: NOT
86168: PUSH
86169: LD_EXP 56
86173: NOT
86174: OR
86175: IFFALSE 86179
// exit ;
86177: GO 86410
// btype := GetBType ( building ) ;
86179: LD_ADDR_VAR 0 6
86183: PUSH
86184: LD_VAR 0 1
86188: PPUSH
86189: CALL_OW 266
86193: ST_TO_ADDR
// x := GetX ( building ) ;
86194: LD_ADDR_VAR 0 7
86198: PUSH
86199: LD_VAR 0 1
86203: PPUSH
86204: CALL_OW 250
86208: ST_TO_ADDR
// y := GetY ( building ) ;
86209: LD_ADDR_VAR 0 8
86213: PUSH
86214: LD_VAR 0 1
86218: PPUSH
86219: CALL_OW 251
86223: ST_TO_ADDR
// d := GetDir ( building ) ;
86224: LD_ADDR_VAR 0 9
86228: PUSH
86229: LD_VAR 0 1
86233: PPUSH
86234: CALL_OW 254
86238: ST_TO_ADDR
// for i = 1 to mc_bases do
86239: LD_ADDR_VAR 0 4
86243: PUSH
86244: DOUBLE
86245: LD_INT 1
86247: DEC
86248: ST_TO_ADDR
86249: LD_EXP 58
86253: PUSH
86254: FOR_TO
86255: IFFALSE 86408
// begin if not mc_build_list [ i ] then
86257: LD_EXP 63
86261: PUSH
86262: LD_VAR 0 4
86266: ARRAY
86267: NOT
86268: IFFALSE 86272
// continue ;
86270: GO 86254
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86272: LD_VAR 0 6
86276: PUSH
86277: LD_VAR 0 7
86281: PUSH
86282: LD_VAR 0 8
86286: PUSH
86287: LD_VAR 0 9
86291: PUSH
86292: EMPTY
86293: LIST
86294: LIST
86295: LIST
86296: LIST
86297: PPUSH
86298: LD_EXP 63
86302: PUSH
86303: LD_VAR 0 4
86307: ARRAY
86308: PUSH
86309: LD_INT 1
86311: ARRAY
86312: PPUSH
86313: CALL 27223 0 2
86317: IFFALSE 86406
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
86319: LD_ADDR_EXP 63
86323: PUSH
86324: LD_EXP 63
86328: PPUSH
86329: LD_VAR 0 4
86333: PPUSH
86334: LD_EXP 63
86338: PUSH
86339: LD_VAR 0 4
86343: ARRAY
86344: PPUSH
86345: LD_INT 1
86347: PPUSH
86348: CALL_OW 3
86352: PPUSH
86353: CALL_OW 1
86357: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86358: LD_ADDR_EXP 65
86362: PUSH
86363: LD_EXP 65
86367: PPUSH
86368: LD_VAR 0 4
86372: PUSH
86373: LD_EXP 65
86377: PUSH
86378: LD_VAR 0 4
86382: ARRAY
86383: PUSH
86384: LD_INT 1
86386: PLUS
86387: PUSH
86388: EMPTY
86389: LIST
86390: LIST
86391: PPUSH
86392: LD_VAR 0 1
86396: PPUSH
86397: CALL 21054 0 3
86401: ST_TO_ADDR
// exit ;
86402: POP
86403: POP
86404: GO 86410
// end ; end ;
86406: GO 86254
86408: POP
86409: POP
// end ;
86410: LD_VAR 0 3
86414: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86415: LD_INT 0
86417: PPUSH
86418: PPUSH
86419: PPUSH
// if not mc_bases or not skirmish then
86420: LD_EXP 58
86424: NOT
86425: PUSH
86426: LD_EXP 56
86430: NOT
86431: OR
86432: IFFALSE 86436
// exit ;
86434: GO 86626
// for i = 1 to mc_bases do
86436: LD_ADDR_VAR 0 4
86440: PUSH
86441: DOUBLE
86442: LD_INT 1
86444: DEC
86445: ST_TO_ADDR
86446: LD_EXP 58
86450: PUSH
86451: FOR_TO
86452: IFFALSE 86539
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
86454: LD_VAR 0 1
86458: PUSH
86459: LD_EXP 66
86463: PUSH
86464: LD_VAR 0 4
86468: ARRAY
86469: IN
86470: PUSH
86471: LD_VAR 0 1
86475: PUSH
86476: LD_EXP 67
86480: PUSH
86481: LD_VAR 0 4
86485: ARRAY
86486: IN
86487: NOT
86488: AND
86489: IFFALSE 86537
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86491: LD_ADDR_EXP 67
86495: PUSH
86496: LD_EXP 67
86500: PPUSH
86501: LD_VAR 0 4
86505: PUSH
86506: LD_EXP 67
86510: PUSH
86511: LD_VAR 0 4
86515: ARRAY
86516: PUSH
86517: LD_INT 1
86519: PLUS
86520: PUSH
86521: EMPTY
86522: LIST
86523: LIST
86524: PPUSH
86525: LD_VAR 0 1
86529: PPUSH
86530: CALL 21054 0 3
86534: ST_TO_ADDR
// break ;
86535: GO 86539
// end ; end ;
86537: GO 86451
86539: POP
86540: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
86541: LD_VAR 0 1
86545: PPUSH
86546: CALL_OW 257
86550: PUSH
86551: LD_EXP 84
86555: IN
86556: PUSH
86557: LD_VAR 0 1
86561: PPUSH
86562: CALL_OW 266
86566: PUSH
86567: LD_INT 5
86569: EQUAL
86570: AND
86571: PUSH
86572: LD_VAR 0 2
86576: PPUSH
86577: CALL_OW 110
86581: PUSH
86582: LD_INT 18
86584: NONEQUAL
86585: AND
86586: IFFALSE 86626
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
86588: LD_VAR 0 2
86592: PPUSH
86593: CALL_OW 257
86597: PUSH
86598: LD_INT 5
86600: PUSH
86601: LD_INT 8
86603: PUSH
86604: LD_INT 9
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: LIST
86611: IN
86612: IFFALSE 86626
// SetClass ( unit , 1 ) ;
86614: LD_VAR 0 2
86618: PPUSH
86619: LD_INT 1
86621: PPUSH
86622: CALL_OW 336
// end ;
86626: LD_VAR 0 3
86630: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
86631: LD_INT 0
86633: PPUSH
86634: PPUSH
// if not mc_bases or not skirmish then
86635: LD_EXP 58
86639: NOT
86640: PUSH
86641: LD_EXP 56
86645: NOT
86646: OR
86647: IFFALSE 86651
// exit ;
86649: GO 86767
// if GetLives ( abandoned_vehicle ) > 250 then
86651: LD_VAR 0 2
86655: PPUSH
86656: CALL_OW 256
86660: PUSH
86661: LD_INT 250
86663: GREATER
86664: IFFALSE 86668
// exit ;
86666: GO 86767
// for i = 1 to mc_bases do
86668: LD_ADDR_VAR 0 6
86672: PUSH
86673: DOUBLE
86674: LD_INT 1
86676: DEC
86677: ST_TO_ADDR
86678: LD_EXP 58
86682: PUSH
86683: FOR_TO
86684: IFFALSE 86765
// begin if driver in mc_bases [ i ] then
86686: LD_VAR 0 1
86690: PUSH
86691: LD_EXP 58
86695: PUSH
86696: LD_VAR 0 6
86700: ARRAY
86701: IN
86702: IFFALSE 86763
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
86704: LD_VAR 0 1
86708: PPUSH
86709: LD_EXP 58
86713: PUSH
86714: LD_VAR 0 6
86718: ARRAY
86719: PPUSH
86720: LD_INT 2
86722: PUSH
86723: LD_INT 30
86725: PUSH
86726: LD_INT 0
86728: PUSH
86729: EMPTY
86730: LIST
86731: LIST
86732: PUSH
86733: LD_INT 30
86735: PUSH
86736: LD_INT 1
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: PUSH
86743: EMPTY
86744: LIST
86745: LIST
86746: LIST
86747: PPUSH
86748: CALL_OW 72
86752: PUSH
86753: LD_INT 1
86755: ARRAY
86756: PPUSH
86757: CALL_OW 112
// break ;
86761: GO 86765
// end ; end ;
86763: GO 86683
86765: POP
86766: POP
// end ; end_of_file
86767: LD_VAR 0 5
86771: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
86772: GO 86774
86774: DISABLE
// begin ru_radar := 98 ;
86775: LD_ADDR_EXP 101
86779: PUSH
86780: LD_INT 98
86782: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86783: LD_ADDR_EXP 102
86787: PUSH
86788: LD_INT 89
86790: ST_TO_ADDR
// us_hack := 99 ;
86791: LD_ADDR_EXP 103
86795: PUSH
86796: LD_INT 99
86798: ST_TO_ADDR
// us_artillery := 97 ;
86799: LD_ADDR_EXP 104
86803: PUSH
86804: LD_INT 97
86806: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86807: LD_ADDR_EXP 105
86811: PUSH
86812: LD_INT 91
86814: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
86815: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
86816: LD_INT 0
86818: PPUSH
86819: PPUSH
86820: PPUSH
86821: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
86822: LD_VAR 0 1
86826: PPUSH
86827: CALL_OW 264
86831: PUSH
86832: LD_EXP 105
86836: EQUAL
86837: IFFALSE 86909
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
86839: LD_INT 68
86841: PPUSH
86842: LD_VAR 0 1
86846: PPUSH
86847: CALL_OW 255
86851: PPUSH
86852: CALL_OW 321
86856: PUSH
86857: LD_INT 2
86859: EQUAL
86860: IFFALSE 86872
// eff := 70 else
86862: LD_ADDR_VAR 0 6
86866: PUSH
86867: LD_INT 70
86869: ST_TO_ADDR
86870: GO 86880
// eff := 30 ;
86872: LD_ADDR_VAR 0 6
86876: PUSH
86877: LD_INT 30
86879: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
86880: LD_VAR 0 1
86884: PPUSH
86885: CALL_OW 250
86889: PPUSH
86890: LD_VAR 0 1
86894: PPUSH
86895: CALL_OW 251
86899: PPUSH
86900: LD_VAR 0 6
86904: PPUSH
86905: CALL_OW 495
// end ; end ;
86909: LD_VAR 0 4
86913: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
86914: LD_INT 0
86916: PPUSH
86917: PPUSH
86918: PPUSH
86919: PPUSH
86920: PPUSH
86921: PPUSH
// if cmd = 124 then
86922: LD_VAR 0 1
86926: PUSH
86927: LD_INT 124
86929: EQUAL
86930: IFFALSE 87136
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
86932: LD_ADDR_VAR 0 5
86936: PUSH
86937: LD_INT 2
86939: PUSH
86940: LD_INT 34
86942: PUSH
86943: LD_INT 53
86945: PUSH
86946: EMPTY
86947: LIST
86948: LIST
86949: PUSH
86950: LD_INT 34
86952: PUSH
86953: LD_INT 14
86955: PUSH
86956: EMPTY
86957: LIST
86958: LIST
86959: PUSH
86960: EMPTY
86961: LIST
86962: LIST
86963: LIST
86964: PPUSH
86965: CALL_OW 69
86969: ST_TO_ADDR
// if not tmp then
86970: LD_VAR 0 5
86974: NOT
86975: IFFALSE 86979
// exit ;
86977: GO 87136
// for i in tmp do
86979: LD_ADDR_VAR 0 3
86983: PUSH
86984: LD_VAR 0 5
86988: PUSH
86989: FOR_IN
86990: IFFALSE 87134
// begin taskList := GetTaskList ( i ) ;
86992: LD_ADDR_VAR 0 6
86996: PUSH
86997: LD_VAR 0 3
87001: PPUSH
87002: CALL_OW 437
87006: ST_TO_ADDR
// if not taskList then
87007: LD_VAR 0 6
87011: NOT
87012: IFFALSE 87016
// continue ;
87014: GO 86989
// for j = 1 to taskList do
87016: LD_ADDR_VAR 0 4
87020: PUSH
87021: DOUBLE
87022: LD_INT 1
87024: DEC
87025: ST_TO_ADDR
87026: LD_VAR 0 6
87030: PUSH
87031: FOR_TO
87032: IFFALSE 87130
// if taskList [ j ] [ 1 ] = | then
87034: LD_VAR 0 6
87038: PUSH
87039: LD_VAR 0 4
87043: ARRAY
87044: PUSH
87045: LD_INT 1
87047: ARRAY
87048: PUSH
87049: LD_STRING |
87051: EQUAL
87052: IFFALSE 87128
// begin _taskList := Delete ( taskList , 1 ) ;
87054: LD_ADDR_VAR 0 7
87058: PUSH
87059: LD_VAR 0 6
87063: PPUSH
87064: LD_INT 1
87066: PPUSH
87067: CALL_OW 3
87071: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87072: LD_VAR 0 3
87076: PPUSH
87077: LD_VAR 0 7
87081: PPUSH
87082: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87086: LD_VAR 0 3
87090: PPUSH
87091: LD_VAR 0 6
87095: PUSH
87096: LD_VAR 0 4
87100: ARRAY
87101: PUSH
87102: LD_INT 2
87104: ARRAY
87105: PPUSH
87106: LD_VAR 0 6
87110: PUSH
87111: LD_VAR 0 4
87115: ARRAY
87116: PUSH
87117: LD_INT 3
87119: ARRAY
87120: PPUSH
87121: LD_INT 8
87123: PPUSH
87124: CALL 87141 0 4
// end ;
87128: GO 87031
87130: POP
87131: POP
// end ;
87132: GO 86989
87134: POP
87135: POP
// end ; end ;
87136: LD_VAR 0 2
87140: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87141: LD_INT 0
87143: PPUSH
87144: PPUSH
87145: PPUSH
87146: PPUSH
87147: PPUSH
87148: PPUSH
87149: PPUSH
87150: PPUSH
87151: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87152: LD_VAR 0 1
87156: NOT
87157: PUSH
87158: LD_VAR 0 2
87162: PPUSH
87163: LD_VAR 0 3
87167: PPUSH
87168: CALL_OW 488
87172: NOT
87173: OR
87174: PUSH
87175: LD_VAR 0 4
87179: NOT
87180: OR
87181: IFFALSE 87185
// exit ;
87183: GO 87525
// list := [ ] ;
87185: LD_ADDR_VAR 0 13
87189: PUSH
87190: EMPTY
87191: ST_TO_ADDR
// if x - r < 0 then
87192: LD_VAR 0 2
87196: PUSH
87197: LD_VAR 0 4
87201: MINUS
87202: PUSH
87203: LD_INT 0
87205: LESS
87206: IFFALSE 87218
// min_x := 0 else
87208: LD_ADDR_VAR 0 7
87212: PUSH
87213: LD_INT 0
87215: ST_TO_ADDR
87216: GO 87234
// min_x := x - r ;
87218: LD_ADDR_VAR 0 7
87222: PUSH
87223: LD_VAR 0 2
87227: PUSH
87228: LD_VAR 0 4
87232: MINUS
87233: ST_TO_ADDR
// if y - r < 0 then
87234: LD_VAR 0 3
87238: PUSH
87239: LD_VAR 0 4
87243: MINUS
87244: PUSH
87245: LD_INT 0
87247: LESS
87248: IFFALSE 87260
// min_y := 0 else
87250: LD_ADDR_VAR 0 8
87254: PUSH
87255: LD_INT 0
87257: ST_TO_ADDR
87258: GO 87276
// min_y := y - r ;
87260: LD_ADDR_VAR 0 8
87264: PUSH
87265: LD_VAR 0 3
87269: PUSH
87270: LD_VAR 0 4
87274: MINUS
87275: ST_TO_ADDR
// max_x := x + r ;
87276: LD_ADDR_VAR 0 9
87280: PUSH
87281: LD_VAR 0 2
87285: PUSH
87286: LD_VAR 0 4
87290: PLUS
87291: ST_TO_ADDR
// max_y := y + r ;
87292: LD_ADDR_VAR 0 10
87296: PUSH
87297: LD_VAR 0 3
87301: PUSH
87302: LD_VAR 0 4
87306: PLUS
87307: ST_TO_ADDR
// for _x = min_x to max_x do
87308: LD_ADDR_VAR 0 11
87312: PUSH
87313: DOUBLE
87314: LD_VAR 0 7
87318: DEC
87319: ST_TO_ADDR
87320: LD_VAR 0 9
87324: PUSH
87325: FOR_TO
87326: IFFALSE 87443
// for _y = min_y to max_y do
87328: LD_ADDR_VAR 0 12
87332: PUSH
87333: DOUBLE
87334: LD_VAR 0 8
87338: DEC
87339: ST_TO_ADDR
87340: LD_VAR 0 10
87344: PUSH
87345: FOR_TO
87346: IFFALSE 87439
// begin if not ValidHex ( _x , _y ) then
87348: LD_VAR 0 11
87352: PPUSH
87353: LD_VAR 0 12
87357: PPUSH
87358: CALL_OW 488
87362: NOT
87363: IFFALSE 87367
// continue ;
87365: GO 87345
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87367: LD_VAR 0 11
87371: PPUSH
87372: LD_VAR 0 12
87376: PPUSH
87377: CALL_OW 351
87381: PUSH
87382: LD_VAR 0 11
87386: PPUSH
87387: LD_VAR 0 12
87391: PPUSH
87392: CALL_OW 554
87396: AND
87397: IFFALSE 87437
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87399: LD_ADDR_VAR 0 13
87403: PUSH
87404: LD_VAR 0 13
87408: PPUSH
87409: LD_VAR 0 13
87413: PUSH
87414: LD_INT 1
87416: PLUS
87417: PPUSH
87418: LD_VAR 0 11
87422: PUSH
87423: LD_VAR 0 12
87427: PUSH
87428: EMPTY
87429: LIST
87430: LIST
87431: PPUSH
87432: CALL_OW 2
87436: ST_TO_ADDR
// end ;
87437: GO 87345
87439: POP
87440: POP
87441: GO 87325
87443: POP
87444: POP
// if not list then
87445: LD_VAR 0 13
87449: NOT
87450: IFFALSE 87454
// exit ;
87452: GO 87525
// for i in list do
87454: LD_ADDR_VAR 0 6
87458: PUSH
87459: LD_VAR 0 13
87463: PUSH
87464: FOR_IN
87465: IFFALSE 87523
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
87467: LD_VAR 0 1
87471: PPUSH
87472: LD_STRING M
87474: PUSH
87475: LD_VAR 0 6
87479: PUSH
87480: LD_INT 1
87482: ARRAY
87483: PUSH
87484: LD_VAR 0 6
87488: PUSH
87489: LD_INT 2
87491: ARRAY
87492: PUSH
87493: LD_INT 0
87495: PUSH
87496: LD_INT 0
87498: PUSH
87499: LD_INT 0
87501: PUSH
87502: LD_INT 0
87504: PUSH
87505: EMPTY
87506: LIST
87507: LIST
87508: LIST
87509: LIST
87510: LIST
87511: LIST
87512: LIST
87513: PUSH
87514: EMPTY
87515: LIST
87516: PPUSH
87517: CALL_OW 447
87521: GO 87464
87523: POP
87524: POP
// end ;
87525: LD_VAR 0 5
87529: RET
