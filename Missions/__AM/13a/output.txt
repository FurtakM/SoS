// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 57044 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49512 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49512 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49512 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49512 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4085 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 59224 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 7736 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 80941 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 81386 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 81844 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 82113 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 81326 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 82020 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 81386 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 81844 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 82113 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 81170 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 82431 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 81326 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 15501 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 15501 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 15501 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 15501 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 15501 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 15501 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 15501 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 15501 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 15501 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 15501 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 15501 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 15501 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 15501 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 15501 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 15501 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 15501 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 15501 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 15501 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 20341 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 20341 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 20341 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 23794 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 20341 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 7 7$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4082
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
// begin enable ;
3341: ENABLE
// base := 2 ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 2
3349: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 0
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: LD_INT 0
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: LD_INT 0
3375: PUSH
3376: LD_INT 0
3378: PUSH
3379: LD_INT 1
3381: PUSH
3382: LD_INT 0
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3397: LD_ADDR_VAR 0 4
3401: PUSH
3402: LD_INT 22
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 21
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 22
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 45
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: LD_INT 23
3458: PUSH
3459: LD_INT 1
3461: PUSH
3462: LD_INT 3
3464: PUSH
3465: LD_INT 46
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: ST_TO_ADDR
// amount := Difficulty ;
3480: LD_ADDR_VAR 0 8
3484: PUSH
3485: LD_OWVAR 67
3489: ST_TO_ADDR
// if tick > 30 30$00 then
3490: LD_OWVAR 1
3494: PUSH
3495: LD_INT 63000
3497: GREATER
3498: IFFALSE 3535
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3500: LD_ADDR_VAR 0 8
3504: PUSH
3505: LD_VAR 0 8
3509: PUSH
3510: LD_INT 2
3512: PUSH
3513: LD_INT 3
3515: PUSH
3516: LD_INT 4
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_OWVAR 67
3532: ARRAY
3533: PLUS
3534: ST_TO_ADDR
// for i = 1 to amount do
3535: LD_ADDR_VAR 0 1
3539: PUSH
3540: DOUBLE
3541: LD_INT 1
3543: DEC
3544: ST_TO_ADDR
3545: LD_VAR 0 8
3549: PUSH
3550: FOR_TO
3551: IFFALSE 3639
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3553: LD_ADDR_VAR 0 4
3557: PUSH
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_VAR 0 4
3567: PUSH
3568: LD_INT 1
3570: PLUS
3571: PPUSH
3572: LD_INT 23
3574: PUSH
3575: LD_INT 24
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 1
3584: PPUSH
3585: LD_INT 2
3587: PPUSH
3588: CALL_OW 12
3592: ARRAY
3593: PUSH
3594: LD_INT 1
3596: PUSH
3597: LD_INT 3
3599: PUSH
3600: LD_INT 46
3602: PUSH
3603: LD_INT 47
3605: PUSH
3606: LD_INT 45
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 3
3619: PPUSH
3620: CALL_OW 12
3624: ARRAY
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 2
3636: ST_TO_ADDR
3637: GO 3550
3639: POP
3640: POP
// p := 1 ;
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: LD_INT 1
3648: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3649: LD_VAR 0 3
3653: PPUSH
3654: LD_VAR 0 4
3658: PPUSH
3659: CALL 81326 0 2
// repeat wait ( 0 0$1 ) ;
3663: LD_INT 35
3665: PPUSH
3666: CALL_OW 67
// p := Inc ( p ) ;
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 2
3679: PPUSH
3680: CALL 54183 0 1
3684: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 100 ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 1
3692: PPUSH
3693: CALL 82744 0 2
3697: PUSH
3698: LD_VAR 0 8
3702: GREATEREQUAL
3703: PUSH
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 100
3711: GREATEREQUAL
3712: OR
3713: IFFALSE 3663
// wait ( 0 0$30 ) ;
3715: LD_INT 1050
3717: PPUSH
3718: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_INT 71
3729: PUSH
3730: LD_INT 19
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: LD_INT 91
3739: PUSH
3740: LD_INT 67
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 52
3749: PUSH
3750: LD_INT 44
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 68
3759: PUSH
3760: LD_INT 48
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_EXP 80
3782: PUSH
3783: LD_VAR 0 3
3787: ARRAY
3788: PUSH
3789: LD_EXP 80
3793: PUSH
3794: LD_VAR 0 3
3798: ARRAY
3799: PPUSH
3800: LD_INT 2
3802: PUSH
3803: LD_INT 34
3805: PUSH
3806: LD_INT 51
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 34
3815: PUSH
3816: LD_INT 52
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 72
3832: DIFF
3833: ST_TO_ADDR
// if not attackers then
3834: LD_VAR 0 7
3838: NOT
3839: IFFALSE 3843
// exit ;
3841: GO 4082
// ru_attackers := attackers ;
3843: LD_ADDR_EXP 54
3847: PUSH
3848: LD_VAR 0 7
3852: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3853: LD_ADDR_EXP 80
3857: PUSH
3858: LD_EXP 80
3862: PPUSH
3863: LD_VAR 0 3
3867: PPUSH
3868: LD_EXP 80
3872: PUSH
3873: LD_VAR 0 3
3877: ARRAY
3878: PUSH
3879: LD_VAR 0 7
3883: DIFF
3884: PPUSH
3885: CALL_OW 1
3889: ST_TO_ADDR
// for i = 1 to attackers do
3890: LD_ADDR_VAR 0 1
3894: PUSH
3895: DOUBLE
3896: LD_INT 1
3898: DEC
3899: ST_TO_ADDR
3900: LD_VAR 0 7
3904: PUSH
3905: FOR_TO
3906: IFFALSE 3983
// begin case i mod 3 of 0 :
3908: LD_VAR 0 1
3912: PUSH
3913: LD_INT 3
3915: MOD
3916: PUSH
3917: LD_INT 0
3919: DOUBLE
3920: EQUAL
3921: IFTRUE 3925
3923: GO 3928
3925: POP
// ; 1 :
3926: GO 3981
3928: LD_INT 1
3930: DOUBLE
3931: EQUAL
3932: IFTRUE 3936
3934: GO 3954
3936: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3937: LD_VAR 0 1
3941: PPUSH
3942: LD_INT 32
3944: PPUSH
3945: LD_INT 49
3947: PPUSH
3948: CALL_OW 114
3952: GO 3981
3954: LD_INT 2
3956: DOUBLE
3957: EQUAL
3958: IFTRUE 3962
3960: GO 3980
3962: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3963: LD_VAR 0 1
3967: PPUSH
3968: LD_INT 117
3970: PPUSH
3971: LD_INT 107
3973: PPUSH
3974: CALL_OW 114
3978: GO 3981
3980: POP
// end ;
3981: GO 3905
3983: POP
3984: POP
// p := 0 ;
3985: LD_ADDR_VAR 0 2
3989: PUSH
3990: LD_INT 0
3992: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3993: LD_INT 35
3995: PPUSH
3996: CALL_OW 67
// p := Inc ( p ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_VAR 0 2
4009: PPUSH
4010: CALL 54183 0 1
4014: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4015: LD_VAR 0 7
4019: PPUSH
4020: LD_INT 60
4022: PUSH
4023: EMPTY
4024: LIST
4025: PPUSH
4026: CALL_OW 72
4030: NOT
4031: PUSH
4032: LD_VAR 0 2
4036: PUSH
4037: LD_INT 30
4039: GREATER
4040: OR
4041: IFFALSE 3993
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
4043: LD_VAR 0 3
4047: PPUSH
4048: LD_VAR 0 7
4052: PPUSH
4053: LD_VAR 0 6
4057: PPUSH
4058: LD_VAR 0 5
4062: PPUSH
4063: CALL 81511 0 4
// if not first_attack then
4067: LD_EXP 7
4071: NOT
4072: IFFALSE 4082
// first_attack := true ;
4074: LD_ADDR_EXP 7
4078: PUSH
4079: LD_INT 1
4081: ST_TO_ADDR
// end ; end_of_file
4082: PPOPN 8
4084: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
4093: PPUSH
// uc_side := 2 ;
4094: LD_ADDR_OWVAR 20
4098: PUSH
4099: LD_INT 2
4101: ST_TO_ADDR
// uc_nation := 2 ;
4102: LD_ADDR_OWVAR 21
4106: PUSH
4107: LD_INT 2
4109: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4110: LD_ADDR_EXP 57
4114: PUSH
4115: LD_STRING Abdul
4117: PPUSH
4118: CALL_OW 25
4122: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4123: LD_EXP 57
4127: PPUSH
4128: LD_INT 11
4130: PPUSH
4131: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4135: LD_EXP 57
4139: PPUSH
4140: LD_INT 1
4142: PPUSH
4143: CALL_OW 52
// vc_chassis := 31 ;
4147: LD_ADDR_OWVAR 37
4151: PUSH
4152: LD_INT 31
4154: ST_TO_ADDR
// vc_control := control_rider ;
4155: LD_ADDR_OWVAR 38
4159: PUSH
4160: LD_INT 4
4162: ST_TO_ADDR
// mastodont := CreateVehicle ;
4163: LD_ADDR_EXP 58
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4173: LD_EXP 58
4177: PPUSH
4178: LD_INT 153
4180: PPUSH
4181: LD_INT 71
4183: PPUSH
4184: LD_INT 0
4186: PPUSH
4187: CALL_OW 48
// InitVc ;
4191: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian , kaba , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4195: LD_ADDR_EXP 55
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 3
4205: PPUSH
4206: LD_STRING kaba
4208: PPUSH
4209: LD_INT 7
4211: PUSH
4212: LD_INT 8
4214: PUSH
4215: LD_INT 9
4217: PUSH
4218: LD_INT 10
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: LD_OWVAR 67
4231: ARRAY
4232: PPUSH
4233: LD_INT 5000
4235: PUSH
4236: LD_INT 1000
4238: PUSH
4239: LD_INT 300
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: LIST
4246: PPUSH
4247: LD_INT 18
4249: PUSH
4250: LD_INT 5
4252: PUSH
4253: LD_INT 6
4255: PUSH
4256: LD_INT 9
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: PPUSH
4265: CALL 23794 0 6
4269: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4270: LD_ADDR_EXP 61
4274: PUSH
4275: LD_EXP 61
4279: PPUSH
4280: LD_INT 1
4282: PPUSH
4283: LD_EXP 55
4287: PPUSH
4288: CALL_OW 1
4292: ST_TO_ADDR
// tmp := [ ] ;
4293: LD_ADDR_VAR 0 4
4297: PUSH
4298: EMPTY
4299: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4300: LD_ADDR_OWVAR 37
4304: PUSH
4305: LD_INT 13
4307: ST_TO_ADDR
// vc_engine := engine_siberite ;
4308: LD_ADDR_OWVAR 39
4312: PUSH
4313: LD_INT 3
4315: ST_TO_ADDR
// vc_control := control_manual ;
4316: LD_ADDR_OWVAR 38
4320: PUSH
4321: LD_INT 1
4323: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4324: LD_ADDR_OWVAR 40
4328: PUSH
4329: LD_INT 31
4331: ST_TO_ADDR
// for i = 1 to 3 do
4332: LD_ADDR_VAR 0 2
4336: PUSH
4337: DOUBLE
4338: LD_INT 1
4340: DEC
4341: ST_TO_ADDR
4342: LD_INT 3
4344: PUSH
4345: FOR_TO
4346: IFFALSE 4594
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4348: LD_ADDR_VAR 0 5
4352: PUSH
4353: LD_INT 153
4355: PUSH
4356: LD_INT 71
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 155
4365: PUSH
4366: LD_INT 81
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: LD_VAR 0 2
4381: PUSH
4382: LD_INT 2
4384: MOD
4385: PUSH
4386: LD_INT 1
4388: PLUS
4389: ARRAY
4390: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4391: LD_INT 0
4393: PPUSH
4394: LD_INT 3
4396: PPUSH
4397: LD_INT 7
4399: PUSH
4400: LD_INT 8
4402: PUSH
4403: LD_INT 10
4405: PUSH
4406: LD_INT 10
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: PUSH
4415: LD_OWVAR 67
4419: ARRAY
4420: PPUSH
4421: CALL_OW 380
// un := CreateVehicle ;
4425: LD_ADDR_VAR 0 6
4429: PUSH
4430: CALL_OW 45
4434: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4435: LD_VAR 0 6
4439: PPUSH
4440: LD_INT 0
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 12
4450: PPUSH
4451: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4455: LD_VAR 0 6
4459: PPUSH
4460: LD_VAR 0 5
4464: PUSH
4465: LD_INT 1
4467: ARRAY
4468: PPUSH
4469: LD_VAR 0 5
4473: PUSH
4474: LD_INT 2
4476: ARRAY
4477: PPUSH
4478: LD_INT 6
4480: PPUSH
4481: LD_INT 0
4483: PPUSH
4484: CALL_OW 50
// un2 := CreateHuman ;
4488: LD_ADDR_VAR 0 7
4492: PUSH
4493: CALL_OW 44
4497: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4498: LD_VAR 0 7
4502: PPUSH
4503: LD_VAR 0 6
4507: PPUSH
4508: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4512: LD_ADDR_EXP 61
4516: PUSH
4517: LD_EXP 61
4521: PPUSH
4522: LD_INT 1
4524: PUSH
4525: LD_EXP 61
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PUSH
4534: LD_INT 1
4536: PLUS
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: LD_VAR 0 6
4546: PPUSH
4547: CALL 20463 0 3
4551: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4552: LD_ADDR_EXP 61
4556: PUSH
4557: LD_EXP 61
4561: PPUSH
4562: LD_INT 1
4564: PUSH
4565: LD_EXP 61
4569: PUSH
4570: LD_INT 1
4572: ARRAY
4573: PUSH
4574: LD_INT 1
4576: PLUS
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: LD_VAR 0 7
4586: PPUSH
4587: CALL 20463 0 3
4591: ST_TO_ADDR
// end ;
4592: GO 4345
4594: POP
4595: POP
// for i = 1 to 5 do
4596: LD_ADDR_VAR 0 2
4600: PUSH
4601: DOUBLE
4602: LD_INT 1
4604: DEC
4605: ST_TO_ADDR
4606: LD_INT 5
4608: PUSH
4609: FOR_TO
4610: IFFALSE 4703
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4612: LD_INT 13
4614: PPUSH
4615: LD_INT 3
4617: PPUSH
4618: LD_INT 1
4620: PPUSH
4621: LD_INT 25
4623: PUSH
4624: LD_INT 28
4626: PUSH
4627: LD_INT 28
4629: PUSH
4630: LD_INT 26
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: PUSH
4639: LD_VAR 0 2
4643: PUSH
4644: LD_INT 4
4646: MOD
4647: PUSH
4648: LD_INT 1
4650: PLUS
4651: ARRAY
4652: PPUSH
4653: LD_INT 100
4655: PPUSH
4656: CALL 20341 0 5
// veh := CreateVehicle ;
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: CALL_OW 45
4669: ST_TO_ADDR
// tmp := tmp ^ veh ;
4670: LD_ADDR_VAR 0 4
4674: PUSH
4675: LD_VAR 0 4
4679: PUSH
4680: LD_VAR 0 3
4684: ADD
4685: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4686: LD_VAR 0 3
4690: PPUSH
4691: LD_INT 1
4693: PPUSH
4694: LD_INT 0
4696: PPUSH
4697: CALL_OW 49
// end ;
4701: GO 4609
4703: POP
4704: POP
// arabian_guard := tmp ;
4705: LD_ADDR_EXP 56
4709: PUSH
4710: LD_VAR 0 4
4714: ST_TO_ADDR
// end ;
4715: LD_VAR 0 1
4719: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4720: LD_INT 22
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 91
4732: PUSH
4733: LD_INT 1
4735: PUSH
4736: LD_INT 12
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: LD_EXP 58
4757: PPUSH
4758: CALL_OW 256
4762: PUSH
4763: LD_INT 990
4765: LESS
4766: OR
4767: PUSH
4768: LD_EXP 57
4772: PPUSH
4773: CALL_OW 256
4777: PUSH
4778: LD_INT 990
4780: LESS
4781: OR
4782: IFFALSE 4925
4784: GO 4786
4786: DISABLE
// begin if IsInUnit ( Abdul ) then
4787: LD_EXP 57
4791: PPUSH
4792: CALL_OW 310
4796: IFFALSE 4807
// ComExitBuilding ( Abdul ) ;
4798: LD_EXP 57
4802: PPUSH
4803: CALL_OW 122
// if Mastodont then
4807: LD_EXP 58
4811: IFFALSE 4828
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 205
4820: PPUSH
4821: LD_INT 132
4823: PPUSH
4824: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4828: LD_EXP 57
4832: PPUSH
4833: LD_INT 205
4835: PPUSH
4836: LD_INT 132
4838: PPUSH
4839: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4850: LD_EXP 57
4854: PPUSH
4855: LD_INT 21
4857: PPUSH
4858: CALL_OW 308
4862: IFFALSE 4843
// RemoveUnit ( Abdul ) ;
4864: LD_EXP 57
4868: PPUSH
4869: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4873: LD_INT 35
4875: PPUSH
4876: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4880: LD_EXP 58
4884: PPUSH
4885: LD_INT 21
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_EXP 58
4897: PPUSH
4898: CALL_OW 301
4902: OR
4903: IFFALSE 4873
// if IsOk ( Mastodont ) then
4905: LD_EXP 58
4909: PPUSH
4910: CALL_OW 302
4914: IFFALSE 4925
// RemoveUnit ( Mastodont ) ;
4916: LD_EXP 58
4920: PPUSH
4921: CALL_OW 64
// end ;
4925: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4926: LD_EXP 57
4930: PPUSH
4931: CALL_OW 301
4935: PUSH
4936: LD_INT 22
4938: PUSH
4939: LD_INT 2
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: LD_INT 25
4951: PUSH
4952: LD_INT 1
4954: PUSH
4955: EMPTY
4956: LIST
4957: LIST
4958: PUSH
4959: LD_INT 25
4961: PUSH
4962: LD_INT 2
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 25
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 25
4981: PUSH
4982: LD_INT 4
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 25
4991: PUSH
4992: LD_INT 8
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PPUSH
5011: CALL_OW 69
5015: PUSH
5016: LD_INT 16
5018: PUSH
5019: LD_INT 19
5021: PUSH
5022: LD_INT 22
5024: PUSH
5025: LD_INT 22
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: PUSH
5034: LD_OWVAR 67
5038: ARRAY
5039: LESS
5040: OR
5041: IFFALSE 5714
5043: GO 5045
5045: DISABLE
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
// begin MC_Kill ( 1 ) ;
5054: LD_INT 1
5056: PPUSH
5057: CALL 57301 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5061: LD_ADDR_VAR 0 2
5065: PUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 2
5078: PUSH
5079: LD_INT 25
5081: PUSH
5082: LD_INT 1
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PUSH
5089: LD_INT 25
5091: PUSH
5092: LD_INT 2
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: PUSH
5099: LD_INT 25
5101: PUSH
5102: LD_INT 3
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 25
5111: PUSH
5112: LD_INT 4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 25
5121: PUSH
5122: LD_INT 8
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PPUSH
5141: CALL_OW 69
5145: ST_TO_ADDR
// for i in tmp do
5146: LD_ADDR_VAR 0 5
5150: PUSH
5151: LD_VAR 0 2
5155: PUSH
5156: FOR_IN
5157: IFFALSE 5173
// SetTag ( i , 10 ) ;
5159: LD_VAR 0 5
5163: PPUSH
5164: LD_INT 10
5166: PPUSH
5167: CALL_OW 109
5171: GO 5156
5173: POP
5174: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: LD_INT 22
5182: PUSH
5183: LD_INT 2
5185: PUSH
5186: EMPTY
5187: LIST
5188: LIST
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 1
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PPUSH
5204: CALL_OW 69
5208: PUSH
5209: LD_VAR 0 2
5213: DIFF
5214: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5215: LD_ADDR_VAR 0 1
5219: PUSH
5220: LD_INT 22
5222: PUSH
5223: LD_INT 2
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 21
5232: PUSH
5233: LD_INT 2
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 24
5242: PUSH
5243: LD_INT 300
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: PPUSH
5255: CALL_OW 69
5259: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5260: LD_ADDR_VAR 0 4
5264: PUSH
5265: LD_VAR 0 1
5269: PPUSH
5270: LD_INT 33
5272: PUSH
5273: LD_INT 1
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PUSH
5280: LD_INT 58
5282: PUSH
5283: EMPTY
5284: LIST
5285: PUSH
5286: EMPTY
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 72
5294: ST_TO_ADDR
// for i in tmp do
5295: LD_ADDR_VAR 0 5
5299: PUSH
5300: LD_VAR 0 2
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5490
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5308: LD_VAR 0 5
5312: PUSH
5313: LD_INT 55
5315: PUSH
5316: EMPTY
5317: LIST
5318: PPUSH
5319: CALL_OW 69
5323: IN
5324: IFFALSE 5343
// begin AddComMoveXY ( i , 209 , 132 ) ;
5326: LD_VAR 0 5
5330: PPUSH
5331: LD_INT 209
5333: PPUSH
5334: LD_INT 132
5336: PPUSH
5337: CALL_OW 171
// continue ;
5341: GO 5305
// end ; if IsInUnit ( i ) then
5343: LD_VAR 0 5
5347: PPUSH
5348: CALL_OW 310
5352: IFFALSE 5370
// begin ComExitBuilding ( i ) ;
5354: LD_VAR 0 5
5358: PPUSH
5359: CALL_OW 122
// wait ( 3 ) ;
5363: LD_INT 3
5365: PPUSH
5366: CALL_OW 67
// end ; if tmp_empty then
5370: LD_VAR 0 4
5374: IFFALSE 5473
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: LD_VAR 0 5
5390: PPUSH
5391: CALL_OW 74
5395: PPUSH
5396: CALL_OW 296
5400: PUSH
5401: LD_INT 25
5403: LESS
5404: IFFALSE 5473
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5406: LD_ADDR_VAR 0 6
5410: PUSH
5411: LD_VAR 0 4
5415: PPUSH
5416: LD_VAR 0 5
5420: PPUSH
5421: CALL_OW 74
5425: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5426: LD_VAR 0 5
5430: PPUSH
5431: LD_VAR 0 6
5435: PPUSH
5436: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5440: LD_VAR 0 5
5444: PPUSH
5445: LD_INT 209
5447: PPUSH
5448: LD_INT 132
5450: PPUSH
5451: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5455: LD_ADDR_VAR 0 4
5459: PUSH
5460: LD_VAR 0 4
5464: PUSH
5465: LD_VAR 0 6
5469: DIFF
5470: ST_TO_ADDR
// continue ;
5471: GO 5305
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5473: LD_VAR 0 5
5477: PPUSH
5478: LD_INT 201
5480: PPUSH
5481: LD_INT 132
5483: PPUSH
5484: CALL_OW 171
// end ;
5488: GO 5305
5490: POP
5491: POP
// for i in tmp_ape do
5492: LD_ADDR_VAR 0 5
5496: PUSH
5497: LD_VAR 0 3
5501: PUSH
5502: FOR_IN
5503: IFFALSE 5542
// begin if IsInUnit ( i ) then
5505: LD_VAR 0 5
5509: PPUSH
5510: CALL_OW 310
5514: IFFALSE 5525
// ComExitBuilding ( i ) ;
5516: LD_VAR 0 5
5520: PPUSH
5521: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5525: LD_VAR 0 5
5529: PPUSH
5530: LD_INT 201
5532: PPUSH
5533: LD_INT 132
5535: PPUSH
5536: CALL_OW 171
// end ;
5540: GO 5502
5542: POP
5543: POP
// repeat wait ( 0 0$1 ) ;
5544: LD_INT 35
5546: PPUSH
5547: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5551: LD_ADDR_VAR 0 5
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 3
5565: UNION
5566: PUSH
5567: LD_VAR 0 1
5571: UNION
5572: PUSH
5573: FOR_IN
5574: IFFALSE 5605
// if not HasTask ( i ) then
5576: LD_VAR 0 5
5580: PPUSH
5581: CALL_OW 314
5585: NOT
5586: IFFALSE 5603
// ComMoveXY ( i , 201 , 132 ) ;
5588: LD_VAR 0 5
5592: PPUSH
5593: LD_INT 201
5595: PPUSH
5596: LD_INT 132
5598: PPUSH
5599: CALL_OW 111
5603: GO 5573
5605: POP
5606: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5607: LD_INT 21
5609: PPUSH
5610: LD_INT 22
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 70
5624: IFFALSE 5665
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5626: LD_ADDR_VAR 0 5
5630: PUSH
5631: LD_INT 21
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_INT 2
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PPUSH
5644: CALL_OW 70
5648: PUSH
5649: FOR_IN
5650: IFFALSE 5663
// RemoveUnit ( i ) ;
5652: LD_VAR 0 5
5656: PPUSH
5657: CALL_OW 64
5661: GO 5649
5663: POP
5664: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5665: LD_INT 22
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 21
5690: PUSH
5691: LD_INT 2
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 69
5711: NOT
5712: IFFALSE 5544
// end ;
5714: PPOPN 6
5716: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5717: LD_EXP 9
5721: PUSH
5722: LD_INT 92
5724: PPUSH
5725: LD_INT 40
5727: PPUSH
5728: CALL_OW 428
5732: PPUSH
5733: CALL_OW 266
5737: PUSH
5738: LD_INT 30
5740: EQUAL
5741: AND
5742: IFFALSE 5938
5744: GO 5746
5746: DISABLE
5747: LD_INT 0
5749: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5750: LD_ADDR_VAR 0 1
5754: PUSH
5755: LD_EXP 61
5759: PUSH
5760: LD_INT 1
5762: ARRAY
5763: PPUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 72
5778: ST_TO_ADDR
// if not sci then
5779: LD_VAR 0 1
5783: NOT
5784: IFFALSE 5788
// exit ;
5786: GO 5938
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5788: LD_ADDR_EXP 61
5792: PUSH
5793: LD_EXP 61
5797: PPUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_EXP 61
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 1
5814: PUSH
5815: LD_INT 1
5817: ARRAY
5818: DIFF
5819: PPUSH
5820: CALL_OW 1
5824: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5825: LD_VAR 0 1
5829: PUSH
5830: LD_INT 1
5832: ARRAY
5833: PPUSH
5834: CALL_OW 310
5838: IFFALSE 5853
// ComExitBuilding ( sci [ 1 ] ) ;
5840: LD_VAR 0 1
5844: PUSH
5845: LD_INT 1
5847: ARRAY
5848: PPUSH
5849: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5853: LD_INT 2
5855: PPUSH
5856: LD_INT 105
5858: PPUSH
5859: LD_INT 14
5861: PPUSH
5862: LD_INT 20
5864: PPUSH
5865: CALL 21359 0 4
5869: PUSH
5870: LD_INT 4
5872: ARRAY
5873: PUSH
5874: LD_INT 10
5876: LESS
5877: IFFALSE 5900
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5879: LD_VAR 0 1
5883: PUSH
5884: LD_INT 1
5886: ARRAY
5887: PPUSH
5888: LD_INT 105
5890: PPUSH
5891: LD_INT 14
5893: PPUSH
5894: CALL_OW 171
5898: GO 5919
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5900: LD_VAR 0 1
5904: PUSH
5905: LD_INT 1
5907: ARRAY
5908: PPUSH
5909: LD_INT 118
5911: PPUSH
5912: LD_INT 77
5914: PPUSH
5915: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5919: LD_VAR 0 1
5923: PUSH
5924: LD_INT 1
5926: ARRAY
5927: PPUSH
5928: LD_INT 92
5930: PPUSH
5931: LD_INT 40
5933: PPUSH
5934: CALL_OW 218
// end ;
5938: PPOPN 1
5940: END
// every 9 9$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
5941: LD_INT 1
5943: PPUSH
5944: CALL_OW 302
5948: PUSH
5949: LD_EXP 9
5953: AND
5954: IFFALSE 6742
5956: GO 5958
5958: DISABLE
5959: LD_INT 0
5961: PPUSH
5962: PPUSH
5963: PPUSH
5964: PPUSH
5965: PPUSH
5966: PPUSH
5967: PPUSH
5968: PPUSH
// begin enable ;
5969: ENABLE
// base := 1 ;
5970: LD_ADDR_VAR 0 3
5974: PUSH
5975: LD_INT 1
5977: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5978: LD_ADDR_VAR 0 5
5982: PUSH
5983: LD_INT 0
5985: PUSH
5986: LD_INT 0
5988: PUSH
5989: LD_INT 0
5991: PUSH
5992: LD_INT 0
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: LD_INT 0
6000: PUSH
6001: LD_INT 0
6003: PUSH
6004: LD_INT 0
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 0
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6025: LD_ADDR_VAR 0 4
6029: PUSH
6030: LD_INT 13
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 2
6038: PUSH
6039: LD_INT 26
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 13
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 28
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 13
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 29
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: LIST
6088: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6089: LD_ADDR_VAR 0 1
6093: PUSH
6094: DOUBLE
6095: LD_INT 1
6097: DEC
6098: ST_TO_ADDR
6099: LD_OWVAR 67
6103: PUSH
6104: LD_OWVAR 1
6108: PUSH
6109: LD_INT 21000
6111: DIV
6112: PLUS
6113: PUSH
6114: FOR_TO
6115: IFFALSE 6188
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6117: LD_ADDR_VAR 0 4
6121: PUSH
6122: LD_VAR 0 4
6126: PPUSH
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: PLUS
6135: PPUSH
6136: LD_INT 13
6138: PUSH
6139: LD_INT 1
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: LD_INT 28
6147: PUSH
6148: LD_INT 29
6150: PUSH
6151: LD_INT 25
6153: PUSH
6154: LD_INT 26
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_INT 4
6168: PPUSH
6169: CALL_OW 12
6173: ARRAY
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: PPUSH
6181: CALL_OW 2
6185: ST_TO_ADDR
6186: GO 6114
6188: POP
6189: POP
// MC_InsertProduceList ( base , tmp ) ;
6190: LD_VAR 0 3
6194: PPUSH
6195: LD_VAR 0 4
6199: PPUSH
6200: CALL 81326 0 2
// wait ( 4 4$20 ) ;
6204: LD_INT 9100
6206: PPUSH
6207: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6211: LD_ADDR_VAR 0 6
6215: PUSH
6216: LD_INT 124
6218: PUSH
6219: LD_INT 85
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 90
6228: PUSH
6229: LD_INT 61
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 69
6238: PUSH
6239: LD_INT 48
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 68
6248: PUSH
6249: LD_INT 48
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6262: LD_ADDR_VAR 0 7
6266: PUSH
6267: LD_EXP 80
6271: PUSH
6272: LD_VAR 0 3
6276: ARRAY
6277: PUSH
6278: LD_EXP 80
6282: PUSH
6283: LD_VAR 0 3
6287: ARRAY
6288: PPUSH
6289: LD_INT 2
6291: PUSH
6292: LD_INT 34
6294: PUSH
6295: LD_INT 32
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 88
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 72
6321: DIFF
6322: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6323: LD_INT 0
6325: PPUSH
6326: LD_INT 1
6328: PPUSH
6329: CALL_OW 12
6333: IFFALSE 6483
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6335: LD_ADDR_VAR 0 1
6339: PUSH
6340: DOUBLE
6341: LD_INT 1
6343: DEC
6344: ST_TO_ADDR
6345: LD_INT 3
6347: PUSH
6348: LD_INT 4
6350: PUSH
6351: LD_INT 5
6353: PUSH
6354: LD_INT 6
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: FOR_TO
6370: IFFALSE 6479
// begin uc_side := 2 ;
6372: LD_ADDR_OWVAR 20
6376: PUSH
6377: LD_INT 2
6379: ST_TO_ADDR
// uc_nation := 2 ;
6380: LD_ADDR_OWVAR 21
6384: PUSH
6385: LD_INT 2
6387: ST_TO_ADDR
// InitHc ;
6388: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6392: LD_INT 0
6394: PPUSH
6395: LD_INT 15
6397: PUSH
6398: LD_INT 17
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 2
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_INT 8
6419: PPUSH
6420: CALL_OW 380
// un := CreateHuman ;
6424: LD_ADDR_VAR 0 2
6428: PUSH
6429: CALL_OW 44
6433: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6434: LD_VAR 0 2
6438: PPUSH
6439: LD_INT 4
6441: PPUSH
6442: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6446: LD_VAR 0 2
6450: PPUSH
6451: LD_INT 23
6453: PPUSH
6454: LD_INT 0
6456: PPUSH
6457: CALL_OW 49
// attackers := attackers union un ;
6461: LD_ADDR_VAR 0 7
6465: PUSH
6466: LD_VAR 0 7
6470: PUSH
6471: LD_VAR 0 2
6475: UNION
6476: ST_TO_ADDR
// end ;
6477: GO 6369
6479: POP
6480: POP
// end else
6481: GO 6641
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6483: LD_ADDR_VAR 0 1
6487: PUSH
6488: DOUBLE
6489: LD_INT 1
6491: DEC
6492: ST_TO_ADDR
6493: LD_INT 2
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 4
6501: PUSH
6502: LD_INT 5
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: PUSH
6511: LD_OWVAR 67
6515: ARRAY
6516: PUSH
6517: FOR_TO
6518: IFFALSE 6639
// begin uc_side := 2 ;
6520: LD_ADDR_OWVAR 20
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// uc_nation := 2 ;
6528: LD_ADDR_OWVAR 21
6532: PUSH
6533: LD_INT 2
6535: ST_TO_ADDR
// InitHc ;
6536: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
6540: LD_INT 14
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 5
6548: PPUSH
6549: LD_INT 29
6551: PUSH
6552: LD_INT 29
6554: PUSH
6555: LD_INT 26
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: LD_VAR 0 1
6567: PUSH
6568: LD_INT 3
6570: MOD
6571: PUSH
6572: LD_INT 1
6574: PLUS
6575: ARRAY
6576: PPUSH
6577: LD_INT 100
6579: PPUSH
6580: CALL 20341 0 5
// un := CreateVehicle ;
6584: LD_ADDR_VAR 0 2
6588: PUSH
6589: CALL_OW 45
6593: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 4
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 23
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// attackers := attackers union un ;
6621: LD_ADDR_VAR 0 7
6625: PUSH
6626: LD_VAR 0 7
6630: PUSH
6631: LD_VAR 0 2
6635: UNION
6636: ST_TO_ADDR
// end ;
6637: GO 6517
6639: POP
6640: POP
// end ; if not attackers then
6641: LD_VAR 0 7
6645: NOT
6646: IFFALSE 6650
// exit ;
6648: GO 6742
// ar_attackers := attackers ;
6650: LD_ADDR_EXP 11
6654: PUSH
6655: LD_VAR 0 7
6659: ST_TO_ADDR
// p := 0 ;
6660: LD_ADDR_VAR 0 8
6664: PUSH
6665: LD_INT 0
6667: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6668: LD_INT 35
6670: PPUSH
6671: CALL_OW 67
// p := Inc ( p ) ;
6675: LD_ADDR_VAR 0 8
6679: PUSH
6680: LD_VAR 0 8
6684: PPUSH
6685: CALL 54183 0 1
6689: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
6690: LD_VAR 0 7
6694: PPUSH
6695: LD_INT 60
6697: PUSH
6698: EMPTY
6699: LIST
6700: PPUSH
6701: CALL_OW 72
6705: NOT
6706: PUSH
6707: LD_VAR 0 8
6711: PUSH
6712: LD_INT 30
6714: GREATER
6715: OR
6716: IFFALSE 6668
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6718: LD_VAR 0 3
6722: PPUSH
6723: LD_VAR 0 7
6727: PPUSH
6728: LD_VAR 0 6
6732: PPUSH
6733: LD_VAR 0 5
6737: PPUSH
6738: CALL 81511 0 4
// end ;
6742: PPOPN 8
6744: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
6745: LD_INT 1
6747: PPUSH
6748: CALL_OW 302
6752: PUSH
6753: LD_EXP 9
6757: AND
6758: PUSH
6759: LD_EXP 51
6763: PPUSH
6764: LD_INT 22
6766: PPUSH
6767: CALL_OW 308
6771: AND
6772: IFFALSE 7260
6774: GO 6776
6776: DISABLE
6777: LD_INT 0
6779: PPUSH
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
// begin base := 1 ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: LD_INT 1
6794: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6795: LD_ADDR_VAR 0 4
6799: PUSH
6800: LD_INT 0
6802: PUSH
6803: LD_INT 0
6805: PUSH
6806: LD_INT 0
6808: PUSH
6809: LD_INT 0
6811: PUSH
6812: LD_INT 0
6814: PUSH
6815: LD_INT 0
6817: PUSH
6818: LD_INT 0
6820: PUSH
6821: LD_INT 0
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 0
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: LIST
6840: LIST
6841: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6842: LD_ADDR_VAR 0 3
6846: PUSH
6847: LD_INT 13
6849: PUSH
6850: LD_INT 1
6852: PUSH
6853: LD_INT 2
6855: PUSH
6856: LD_INT 28
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 13
6867: PUSH
6868: LD_INT 1
6870: PUSH
6871: LD_INT 2
6873: PUSH
6874: LD_INT 27
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 13
6885: PUSH
6886: LD_INT 1
6888: PUSH
6889: LD_INT 2
6891: PUSH
6892: LD_INT 25
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 11
6903: PUSH
6904: LD_INT 2
6906: PUSH
6907: LD_INT 2
6909: PUSH
6910: LD_INT 24
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 11
6921: PUSH
6922: LD_INT 2
6924: PUSH
6925: LD_INT 2
6927: PUSH
6928: LD_INT 24
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: LIST
6942: LIST
6943: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6944: LD_VAR 0 2
6948: PPUSH
6949: LD_VAR 0 3
6953: PPUSH
6954: CALL 81326 0 2
// wait ( 4 4$20 ) ;
6958: LD_INT 9100
6960: PPUSH
6961: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6965: LD_ADDR_VAR 0 5
6969: PUSH
6970: LD_INT 119
6972: PUSH
6973: LD_INT 9
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6983: LD_ADDR_VAR 0 6
6987: PUSH
6988: LD_EXP 80
6992: PUSH
6993: LD_VAR 0 2
6997: ARRAY
6998: PUSH
6999: LD_EXP 80
7003: PUSH
7004: LD_VAR 0 2
7008: ARRAY
7009: PPUSH
7010: LD_INT 2
7012: PUSH
7013: LD_INT 34
7015: PUSH
7016: LD_INT 32
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 34
7025: PUSH
7026: LD_INT 88
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: DIFF
7043: ST_TO_ADDR
// uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7064: LD_ADDR_VAR 0 1
7068: PUSH
7069: DOUBLE
7070: LD_INT 1
7072: DEC
7073: ST_TO_ADDR
7074: LD_INT 4
7076: PUSH
7077: LD_INT 5
7079: PUSH
7080: LD_INT 6
7082: PUSH
7083: LD_INT 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_OWVAR 67
7096: ARRAY
7097: PUSH
7098: FOR_TO
7099: IFFALSE 7176
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7101: LD_INT 0
7103: PPUSH
7104: LD_INT 15
7106: PUSH
7107: LD_INT 17
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: PUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 2
7119: PPUSH
7120: CALL_OW 12
7124: ARRAY
7125: PPUSH
7126: LD_INT 8
7128: PPUSH
7129: CALL_OW 380
// un := CreateHuman ;
7133: LD_ADDR_VAR 0 7
7137: PUSH
7138: CALL_OW 44
7142: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7143: LD_VAR 0 7
7147: PPUSH
7148: LD_INT 23
7150: PPUSH
7151: LD_INT 0
7153: PPUSH
7154: CALL_OW 49
// attackers := attackers union un ;
7158: LD_ADDR_VAR 0 6
7162: PUSH
7163: LD_VAR 0 6
7167: PUSH
7168: LD_VAR 0 7
7172: UNION
7173: ST_TO_ADDR
// end ;
7174: GO 7098
7176: POP
7177: POP
// p := 0 ;
7178: LD_ADDR_VAR 0 8
7182: PUSH
7183: LD_INT 0
7185: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7186: LD_INT 35
7188: PPUSH
7189: CALL_OW 67
// p := Inc ( p ) ;
7193: LD_ADDR_VAR 0 8
7197: PUSH
7198: LD_VAR 0 8
7202: PPUSH
7203: CALL 54183 0 1
7207: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7208: LD_VAR 0 6
7212: PPUSH
7213: LD_INT 60
7215: PUSH
7216: EMPTY
7217: LIST
7218: PPUSH
7219: CALL_OW 72
7223: NOT
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_INT 30
7232: GREATER
7233: OR
7234: IFFALSE 7186
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_VAR 0 6
7245: PPUSH
7246: LD_VAR 0 5
7250: PPUSH
7251: LD_VAR 0 4
7255: PPUSH
7256: CALL 81511 0 4
// end ; end_of_file
7260: PPOPN 8
7262: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7263: LD_INT 0
7265: PPUSH
7266: PPUSH
7267: PPUSH
7268: PPUSH
7269: PPUSH
7270: PPUSH
// uc_side := 1 ;
7271: LD_ADDR_OWVAR 20
7275: PUSH
7276: LD_INT 1
7278: ST_TO_ADDR
// uc_nation := 1 ;
7279: LD_ADDR_OWVAR 21
7283: PUSH
7284: LD_INT 1
7286: ST_TO_ADDR
// InitHc ;
7287: CALL_OW 19
// InitVc ;
7291: CALL_OW 20
// tmp := [ ] ;
7295: LD_ADDR_VAR 0 3
7299: PUSH
7300: EMPTY
7301: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7302: LD_ADDR_VAR 0 2
7306: PUSH
7307: DOUBLE
7308: LD_INT 1
7310: DEC
7311: ST_TO_ADDR
7312: LD_INT 6
7314: PUSH
7315: LD_INT 8
7317: PUSH
7318: LD_INT 10
7320: PUSH
7321: LD_INT 10
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: LIST
7329: PUSH
7330: LD_OWVAR 67
7334: ARRAY
7335: PUSH
7336: FOR_TO
7337: IFFALSE 7611
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7339: LD_ADDR_VAR 0 5
7343: PUSH
7344: LD_INT 2
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: LD_INT 5
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 3
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7370: LD_VAR 0 5
7374: PUSH
7375: LD_INT 2
7377: DOUBLE
7378: EQUAL
7379: IFTRUE 7383
7381: GO 7417
7383: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7384: LD_ADDR_VAR 0 6
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: LD_INT 5
7394: PUSH
7395: LD_INT 7
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: PUSH
7403: LD_INT 1
7405: PPUSH
7406: LD_INT 3
7408: PPUSH
7409: CALL_OW 12
7413: ARRAY
7414: ST_TO_ADDR
7415: GO 7506
7417: LD_INT 4
7419: DOUBLE
7420: EQUAL
7421: IFTRUE 7425
7423: GO 7463
7425: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 9
7433: PUSH
7434: LD_INT 6
7436: PUSH
7437: LD_INT 6
7439: PUSH
7440: LD_INT 7
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: LIST
7447: LIST
7448: PUSH
7449: LD_INT 1
7451: PPUSH
7452: LD_INT 4
7454: PPUSH
7455: CALL_OW 12
7459: ARRAY
7460: ST_TO_ADDR
7461: GO 7506
7463: LD_INT 5
7465: DOUBLE
7466: EQUAL
7467: IFTRUE 7471
7469: GO 7505
7471: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7472: LD_ADDR_VAR 0 6
7476: PUSH
7477: LD_INT 9
7479: PUSH
7480: LD_INT 6
7482: PUSH
7483: LD_INT 7
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 1
7493: PPUSH
7494: LD_INT 3
7496: PPUSH
7497: CALL_OW 12
7501: ARRAY
7502: ST_TO_ADDR
7503: GO 7506
7505: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7506: LD_VAR 0 5
7510: PPUSH
7511: LD_INT 1
7513: PUSH
7514: LD_INT 3
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: LD_INT 1
7523: PPUSH
7524: LD_INT 2
7526: PPUSH
7527: CALL_OW 12
7531: ARRAY
7532: PPUSH
7533: LD_INT 3
7535: PPUSH
7536: LD_VAR 0 6
7540: PPUSH
7541: LD_INT 70
7543: PPUSH
7544: LD_INT 90
7546: PPUSH
7547: CALL_OW 12
7551: PPUSH
7552: CALL 20341 0 5
// veh := CreateVehicle ;
7556: LD_ADDR_VAR 0 4
7560: PUSH
7561: CALL_OW 45
7565: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7566: LD_VAR 0 4
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7578: LD_VAR 0 4
7582: PPUSH
7583: LD_INT 17
7585: PPUSH
7586: LD_INT 0
7588: PPUSH
7589: CALL_OW 49
// tmp := tmp ^ veh ;
7593: LD_ADDR_VAR 0 3
7597: PUSH
7598: LD_VAR 0 3
7602: PUSH
7603: LD_VAR 0 4
7607: ADD
7608: ST_TO_ADDR
// end ;
7609: GO 7336
7611: POP
7612: POP
// if not tmp then
7613: LD_VAR 0 3
7617: NOT
7618: IFFALSE 7622
// exit ;
7620: GO 7731
// if not first_powell_attack then
7622: LD_EXP 12
7626: NOT
7627: IFFALSE 7637
// first_powell_attack := true ;
7629: LD_ADDR_EXP 12
7633: PUSH
7634: LD_INT 1
7636: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7637: LD_INT 70
7639: PPUSH
7640: CALL_OW 67
// for i in tmp do
7644: LD_ADDR_VAR 0 2
7648: PUSH
7649: LD_VAR 0 3
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7722
// if IsOk ( i ) then
7657: LD_VAR 0 2
7661: PPUSH
7662: CALL_OW 302
7666: IFFALSE 7704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7668: LD_VAR 0 2
7672: PPUSH
7673: LD_INT 81
7675: PUSH
7676: LD_INT 1
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PPUSH
7683: CALL_OW 69
7687: PPUSH
7688: LD_VAR 0 2
7692: PPUSH
7693: CALL_OW 74
7697: PPUSH
7698: CALL_OW 115
7702: GO 7720
// tmp := tmp diff i ;
7704: LD_ADDR_VAR 0 3
7708: PUSH
7709: LD_VAR 0 3
7713: PUSH
7714: LD_VAR 0 2
7718: DIFF
7719: ST_TO_ADDR
7720: GO 7654
7722: POP
7723: POP
// until not tmp ;
7724: LD_VAR 0 3
7728: NOT
7729: IFFALSE 7637
// end ; end_of_file
7731: LD_VAR 0 1
7735: RET
// export function Action ; var tmp , i , un ; begin
7736: LD_INT 0
7738: PPUSH
7739: PPUSH
7740: PPUSH
7741: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7742: LD_INT 68
7744: PPUSH
7745: LD_INT 39
7747: PPUSH
7748: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7752: LD_ADDR_VAR 0 2
7756: PUSH
7757: LD_INT 22
7759: PUSH
7760: LD_INT 7
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: ST_TO_ADDR
// InGameOn ;
7772: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 71
7783: PPUSH
7784: LD_INT 49
7786: PPUSH
7787: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7791: LD_INT 35
7793: PPUSH
7794: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7798: LD_INT 7
7800: PPUSH
7801: LD_INT 71
7803: PPUSH
7804: LD_INT 51
7806: PPUSH
7807: CALL_OW 293
7811: IFFALSE 7791
// DialogueOn ;
7813: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7817: LD_EXP 16
7821: PPUSH
7822: LD_STRING D1-JMM-1
7824: PPUSH
7825: CALL_OW 88
// if Joan then
7829: LD_EXP 31
7833: IFFALSE 7847
// Say ( Joan , D1-Joan-1 ) ;
7835: LD_EXP 31
7839: PPUSH
7840: LD_STRING D1-Joan-1
7842: PPUSH
7843: CALL_OW 88
// if Lisa then
7847: LD_EXP 18
7851: IFFALSE 7865
// Say ( Lisa , D1-Lisa-1 ) ;
7853: LD_EXP 18
7857: PPUSH
7858: LD_STRING D1-Lisa-1
7860: PPUSH
7861: CALL_OW 88
// if Joan or Lisa then
7865: LD_EXP 31
7869: PUSH
7870: LD_EXP 18
7874: OR
7875: IFFALSE 7889
// Say ( JMM , D1-JMM-2 ) ;
7877: LD_EXP 16
7881: PPUSH
7882: LD_STRING D1-JMM-2
7884: PPUSH
7885: CALL_OW 88
// DialogueOff ;
7889: CALL_OW 7
// InGameOff ;
7893: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7897: LD_INT 71
7899: PPUSH
7900: LD_INT 50
7902: PPUSH
7903: LD_INT 7
7905: PPUSH
7906: LD_INT 30
7908: NEG
7909: PPUSH
7910: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7914: LD_INT 71
7916: PPUSH
7917: LD_INT 50
7919: PPUSH
7920: LD_INT 7
7922: PPUSH
7923: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7927: LD_STRING M1
7929: PPUSH
7930: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7934: LD_INT 35
7936: PPUSH
7937: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7941: LD_EXP 3
7945: PUSH
7946: LD_OWVAR 1
7950: PUSH
7951: LD_INT 2100
7953: GREATER
7954: OR
7955: IFFALSE 7934
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7957: LD_INT 350
7959: PPUSH
7960: LD_INT 700
7962: PPUSH
7963: CALL_OW 12
7967: PPUSH
7968: CALL_OW 67
// PrepareGossudarov ;
7972: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
7976: LD_INT 35
7978: PPUSH
7979: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7983: LD_INT 22
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 3
7995: PUSH
7996: LD_INT 24
7998: PUSH
7999: LD_INT 1000
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PPUSH
8014: CALL_OW 69
8018: PUSH
8019: LD_INT 7
8021: PPUSH
8022: LD_EXP 34
8026: PPUSH
8027: CALL_OW 292
8031: OR
8032: IFFALSE 7976
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8034: LD_ADDR_VAR 0 2
8038: PUSH
8039: LD_INT 22
8041: PUSH
8042: LD_INT 6
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PPUSH
8049: CALL_OW 69
8053: ST_TO_ADDR
// for i in tmp do
8054: LD_ADDR_VAR 0 3
8058: PUSH
8059: LD_VAR 0 2
8063: PUSH
8064: FOR_IN
8065: IFFALSE 8081
// SetSide ( i , 7 ) ;
8067: LD_VAR 0 3
8071: PPUSH
8072: LD_INT 7
8074: PPUSH
8075: CALL_OW 235
8079: GO 8064
8081: POP
8082: POP
// DialogueOn ;
8083: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8087: LD_EXP 16
8091: PUSH
8092: LD_EXP 17
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: LD_EXP 34
8105: PPUSH
8106: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8110: LD_EXP 34
8114: PPUSH
8115: CALL_OW 87
// if not Roth then
8119: LD_EXP 17
8123: NOT
8124: IFFALSE 8216
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8126: LD_VAR 0 2
8130: PPUSH
8131: LD_INT 3
8133: PUSH
8134: LD_INT 24
8136: PUSH
8137: LD_INT 1000
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 72
8152: IFFALSE 8166
// Say ( JMM , D2-JMM-1 ) ;
8154: LD_EXP 16
8158: PPUSH
8159: LD_STRING D2-JMM-1
8161: PPUSH
8162: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8166: LD_EXP 16
8170: PPUSH
8171: LD_STRING D2-JMM-1b
8173: PPUSH
8174: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8178: LD_EXP 34
8182: PPUSH
8183: LD_STRING D2-Gos-1
8185: PPUSH
8186: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8190: LD_EXP 16
8194: PPUSH
8195: LD_STRING D2-JMM-2
8197: PPUSH
8198: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8202: LD_EXP 34
8206: PPUSH
8207: LD_STRING D2-Gos-2
8209: PPUSH
8210: CALL_OW 88
// end else
8214: GO 8368
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8216: LD_VAR 0 2
8220: PPUSH
8221: LD_INT 3
8223: PUSH
8224: LD_INT 24
8226: PUSH
8227: LD_INT 1000
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 72
8242: IFFALSE 8268
// begin Say ( Roth , D2-Roth-2 ) ;
8244: LD_EXP 17
8248: PPUSH
8249: LD_STRING D2-Roth-2
8251: PPUSH
8252: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
8256: LD_EXP 16
8260: PPUSH
8261: LD_STRING D2-JMM-1a
8263: PPUSH
8264: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
8268: LD_EXP 17
8272: PPUSH
8273: LD_STRING D2-Roth-2a
8275: PPUSH
8276: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
8280: LD_EXP 17
8284: PPUSH
8285: LD_STRING D2-Roth-2b
8287: PPUSH
8288: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
8292: LD_EXP 16
8296: PPUSH
8297: LD_STRING D2-JMM-3
8299: PPUSH
8300: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8304: LD_VAR 0 2
8308: PPUSH
8309: LD_INT 3
8311: PUSH
8312: LD_INT 24
8314: PUSH
8315: LD_INT 1000
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 72
8330: IFFALSE 8368
// begin Say ( Gossudarov , D2-Gos-3 ) ;
8332: LD_EXP 34
8336: PPUSH
8337: LD_STRING D2-Gos-3
8339: PPUSH
8340: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
8344: LD_EXP 16
8348: PPUSH
8349: LD_STRING D2-JMM-4
8351: PPUSH
8352: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
8356: LD_EXP 34
8360: PPUSH
8361: LD_STRING D2-Gos-4
8363: PPUSH
8364: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8368: LD_EXP 16
8372: PPUSH
8373: LD_STRING D2-JMM-5
8375: PPUSH
8376: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8380: LD_EXP 34
8384: PPUSH
8385: LD_STRING D2-Gos-5
8387: PPUSH
8388: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8392: LD_EXP 16
8396: PPUSH
8397: LD_STRING D2-JMM-6
8399: PPUSH
8400: CALL_OW 88
// DialogueOff ;
8404: CALL_OW 7
// wait ( 0 0$2 ) ;
8408: LD_INT 70
8410: PPUSH
8411: CALL_OW 67
// if Kirilenkova then
8415: LD_EXP 35
8419: IFFALSE 8433
// Say ( Kirilenkova , D3-Kir-1 ) ;
8421: LD_EXP 35
8425: PPUSH
8426: LD_STRING D3-Kir-1
8428: PPUSH
8429: CALL_OW 88
// gossudarov_arrive := true ;
8433: LD_ADDR_EXP 4
8437: PUSH
8438: LD_INT 1
8440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// until ru_lab_builded ;
8448: LD_EXP 5
8452: IFFALSE 8441
// DialogueOn ;
8454: CALL_OW 6
// if Kirilenkova then
8458: LD_EXP 35
8462: IFFALSE 8478
// Say ( Kirilenkova , D3a-Kir-1 ) else
8464: LD_EXP 35
8468: PPUSH
8469: LD_STRING D3a-Kir-1
8471: PPUSH
8472: CALL_OW 88
8476: GO 8500
// begin un := SciRu ;
8478: LD_ADDR_VAR 0 4
8482: PUSH
8483: CALL 13885 0 0
8487: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8488: LD_VAR 0 4
8492: PPUSH
8493: LD_STRING D3a-Sci1-1
8495: PPUSH
8496: CALL_OW 88
// end ; if Kirilenkova or un then
8500: LD_EXP 35
8504: PUSH
8505: LD_VAR 0 4
8509: OR
8510: IFFALSE 8524
// Say ( JMM , D3a-JMM-1 ) ;
8512: LD_EXP 16
8516: PPUSH
8517: LD_STRING D3a-JMM-1
8519: PPUSH
8520: CALL_OW 88
// DialogueOff ;
8524: CALL_OW 7
// end ;
8528: LD_VAR 0 1
8532: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8533: LD_EXP 4
8537: PUSH
8538: LD_INT 22
8540: PUSH
8541: LD_INT 7
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: LD_INT 2
8550: PUSH
8551: LD_INT 25
8553: PUSH
8554: LD_INT 1
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PUSH
8561: LD_INT 25
8563: PUSH
8564: LD_INT 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 25
8573: PUSH
8574: LD_INT 3
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 25
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: LD_INT 25
8593: PUSH
8594: LD_INT 5
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: PUSH
8601: LD_INT 25
8603: PUSH
8604: LD_INT 8
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 9
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: PUSH
8640: LD_INT 7
8642: LESS
8643: AND
8644: IFFALSE 8656
8646: GO 8648
8648: DISABLE
// YouLost ( TooMany ) ;
8649: LD_STRING TooMany
8651: PPUSH
8652: CALL_OW 104
8656: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8657: LD_EXP 34
8661: PPUSH
8662: CALL_OW 255
8666: PUSH
8667: LD_INT 7
8669: EQUAL
8670: IFFALSE 8887
8672: GO 8674
8674: DISABLE
8675: LD_INT 0
8677: PPUSH
8678: PPUSH
8679: PPUSH
// begin uc_side := 3 ;
8680: LD_ADDR_OWVAR 20
8684: PUSH
8685: LD_INT 3
8687: ST_TO_ADDR
// uc_nation := 3 ;
8688: LD_ADDR_OWVAR 21
8692: PUSH
8693: LD_INT 3
8695: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8696: LD_INT 21
8698: PPUSH
8699: LD_INT 3
8701: PPUSH
8702: LD_INT 3
8704: PPUSH
8705: LD_INT 42
8707: PPUSH
8708: LD_INT 100
8710: PPUSH
8711: CALL 20341 0 5
// un := CreateVehicle ;
8715: LD_ADDR_VAR 0 3
8719: PUSH
8720: CALL_OW 45
8724: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8725: LD_VAR 0 3
8729: PPUSH
8730: LD_INT 15
8732: PPUSH
8733: LD_INT 0
8735: PPUSH
8736: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8740: LD_VAR 0 3
8744: PPUSH
8745: LD_INT 67
8747: PPUSH
8748: LD_INT 45
8750: PPUSH
8751: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_INT 70
8762: PPUSH
8763: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8767: LD_VAR 0 3
8771: PPUSH
8772: LD_INT 69
8774: PPUSH
8775: LD_INT 18
8777: PPUSH
8778: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8782: LD_VAR 0 3
8786: PPUSH
8787: LD_INT 60
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8797: LD_INT 35
8799: PPUSH
8800: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8804: LD_VAR 0 3
8808: PPUSH
8809: CALL_OW 302
8813: NOT
8814: PUSH
8815: LD_VAR 0 3
8819: PPUSH
8820: LD_INT 17
8822: PPUSH
8823: CALL_OW 308
8827: OR
8828: PUSH
8829: LD_VAR 0 3
8833: PPUSH
8834: LD_INT 60
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 307
8844: OR
8845: IFFALSE 8797
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8847: LD_VAR 0 3
8851: PPUSH
8852: LD_INT 17
8854: PPUSH
8855: CALL_OW 308
8859: PUSH
8860: LD_VAR 0 3
8864: PPUSH
8865: LD_INT 60
8867: PPUSH
8868: LD_INT 3
8870: PPUSH
8871: CALL_OW 307
8875: OR
8876: IFFALSE 8887
// RemoveUnit ( un ) ;
8878: LD_VAR 0 3
8882: PPUSH
8883: CALL_OW 64
// end ;
8887: PPOPN 3
8889: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8890: LD_EXP 4
8894: IFFALSE 9136
8896: GO 8898
8898: DISABLE
8899: LD_INT 0
8901: PPUSH
8902: PPUSH
8903: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8904: LD_INT 70
8906: PPUSH
8907: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8911: LD_ADDR_VAR 0 3
8915: PUSH
8916: LD_INT 22
8918: PUSH
8919: LD_INT 7
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 101
8928: PUSH
8929: LD_INT 3
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: ST_TO_ADDR
// until tmp ;
8945: LD_VAR 0 3
8949: IFFALSE 8904
// un := NearestUnitToUnit ( tmp , JMM ) ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 3
8960: PPUSH
8961: LD_EXP 16
8965: PPUSH
8966: CALL_OW 74
8970: ST_TO_ADDR
// player_spotted := true ;
8971: LD_ADDR_EXP 6
8975: PUSH
8976: LD_INT 1
8978: ST_TO_ADDR
// tmp := SciRu ;
8979: LD_ADDR_VAR 0 3
8983: PUSH
8984: CALL 13885 0 0
8988: ST_TO_ADDR
// if not tmp then
8989: LD_VAR 0 3
8993: NOT
8994: IFFALSE 9006
// tmp := SolRu ;
8996: LD_ADDR_VAR 0 3
9000: PUSH
9001: CALL 14032 0 0
9005: ST_TO_ADDR
// DialogueOn ;
9006: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9010: LD_VAR 0 2
9014: PPUSH
9015: CALL_OW 250
9019: PPUSH
9020: LD_VAR 0 2
9024: PPUSH
9025: CALL_OW 251
9029: PPUSH
9030: LD_INT 7
9032: PPUSH
9033: LD_INT 8
9035: NEG
9036: PPUSH
9037: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9041: LD_VAR 0 2
9045: PPUSH
9046: CALL_OW 87
// if tmp then
9050: LD_VAR 0 3
9054: IFFALSE 9068
// Say ( tmp , D4-RSci1-1 ) ;
9056: LD_VAR 0 3
9060: PPUSH
9061: LD_STRING D4-RSci1-1
9063: PPUSH
9064: CALL_OW 88
// if Gossudarov then
9068: LD_EXP 34
9072: IFFALSE 9098
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9074: LD_EXP 34
9078: PPUSH
9079: LD_STRING D4-Gos-1
9081: PPUSH
9082: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9086: LD_EXP 16
9090: PPUSH
9091: LD_STRING D4-JMM-1
9093: PPUSH
9094: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9098: LD_VAR 0 2
9102: PPUSH
9103: CALL_OW 250
9107: PPUSH
9108: LD_VAR 0 2
9112: PPUSH
9113: CALL_OW 251
9117: PPUSH
9118: LD_INT 7
9120: PPUSH
9121: CALL_OW 331
// DialogueOff ;
9125: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9129: LD_STRING M5
9131: PPUSH
9132: CALL_OW 337
// end ;
9136: PPOPN 3
9138: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9139: LD_EXP 6
9143: IFFALSE 9736
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
// begin PrepareBelkov ;
9153: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9157: LD_EXP 49
9161: PPUSH
9162: LD_INT 118
9164: PPUSH
9165: LD_INT 106
9167: PPUSH
9168: CALL_OW 111
// AddComHold ( Belkov ) ;
9172: LD_EXP 49
9176: PPUSH
9177: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9181: LD_INT 35
9183: PPUSH
9184: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9188: LD_EXP 49
9192: PPUSH
9193: LD_INT 118
9195: PPUSH
9196: LD_INT 106
9198: PPUSH
9199: CALL_OW 307
9203: IFFALSE 9181
// ChangeSideFog ( 4 , 7 ) ;
9205: LD_INT 4
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: CALL_OW 343
// if IsOk ( Belkov ) then
9215: LD_EXP 49
9219: PPUSH
9220: CALL_OW 302
9224: IFFALSE 9308
// begin InGameOn ;
9226: CALL_OW 8
// DialogueOn ;
9230: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
9234: LD_EXP 49
9238: PPUSH
9239: LD_STRING D5-Bel-1
9241: PPUSH
9242: CALL_OW 94
// if Gossudarov then
9246: LD_EXP 34
9250: IFFALSE 9300
// begin Say ( Gossudarov , D5-Gos-1 ) ;
9252: LD_EXP 34
9256: PPUSH
9257: LD_STRING D5-Gos-1
9259: PPUSH
9260: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
9264: LD_EXP 16
9268: PPUSH
9269: LD_STRING D5-JMM-1
9271: PPUSH
9272: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
9276: LD_EXP 34
9280: PPUSH
9281: LD_STRING D5-Gos-2
9283: PPUSH
9284: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
9288: LD_EXP 16
9292: PPUSH
9293: LD_STRING D5-JMM-2
9295: PPUSH
9296: CALL_OW 88
// end ; DialogueOff ;
9300: CALL_OW 7
// InGameOff ;
9304: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
9308: LD_STRING QSaveBelkov
9310: PPUSH
9311: CALL_OW 97
9315: PUSH
9316: LD_INT 1
9318: DOUBLE
9319: EQUAL
9320: IFTRUE 9324
9322: GO 9374
9324: POP
// begin DialogueOn ;
9325: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
9329: LD_EXP 16
9333: PPUSH
9334: LD_STRING D5a-JMM-1
9336: PPUSH
9337: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
9341: LD_EXP 49
9345: PPUSH
9346: LD_STRING D5a-Bel-1
9348: PPUSH
9349: CALL_OW 94
// DialogueOff ;
9353: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
9357: LD_EXP 49
9361: PPUSH
9362: LD_INT 83
9364: PPUSH
9365: LD_INT 49
9367: PPUSH
9368: CALL_OW 111
// end ; 2 :
9372: GO 9407
9374: LD_INT 2
9376: DOUBLE
9377: EQUAL
9378: IFTRUE 9382
9380: GO 9406
9382: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9383: LD_EXP 16
9387: PPUSH
9388: LD_STRING D5a-JMM-2
9390: PPUSH
9391: CALL_OW 88
// ComHold ( Belkov ) ;
9395: LD_EXP 49
9399: PPUSH
9400: CALL_OW 140
// end ; end ;
9404: GO 9407
9406: POP
// time := 0 0$00 ;
9407: LD_ADDR_VAR 0 1
9411: PUSH
9412: LD_INT 0
9414: ST_TO_ADDR
// vehSpawned := false ;
9415: LD_ADDR_VAR 0 3
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9423: LD_INT 35
9425: PPUSH
9426: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9430: LD_VAR 0 1
9434: PUSH
9435: LD_INT 350
9437: PUSH
9438: LD_INT 175
9440: PUSH
9441: LD_INT 105
9443: PUSH
9444: LD_INT 70
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: LD_OWVAR 67
9457: ARRAY
9458: GREATEREQUAL
9459: PUSH
9460: LD_VAR 0 3
9464: NOT
9465: AND
9466: IFFALSE 9556
// begin vehSpawned := true ;
9468: LD_ADDR_VAR 0 3
9472: PUSH
9473: LD_INT 1
9475: ST_TO_ADDR
// uc_side := 3 ;
9476: LD_ADDR_OWVAR 20
9480: PUSH
9481: LD_INT 3
9483: ST_TO_ADDR
// uc_nation := 3 ;
9484: LD_ADDR_OWVAR 21
9488: PUSH
9489: LD_INT 3
9491: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9492: LD_INT 22
9494: PPUSH
9495: LD_INT 3
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 43
9503: PPUSH
9504: LD_INT 100
9506: PPUSH
9507: CALL 20341 0 5
// veh := CreateVehicle ;
9511: LD_ADDR_VAR 0 2
9515: PUSH
9516: CALL_OW 45
9520: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9521: LD_VAR 0 2
9525: PPUSH
9526: LD_INT 130
9528: PPUSH
9529: LD_INT 131
9531: PPUSH
9532: LD_INT 0
9534: PPUSH
9535: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9539: LD_VAR 0 2
9543: PPUSH
9544: LD_INT 100
9546: PPUSH
9547: LD_INT 82
9549: PPUSH
9550: CALL_OW 114
// end else
9554: GO 9570
// time := time + 0 0$1 ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_VAR 0 1
9565: PUSH
9566: LD_INT 35
9568: PLUS
9569: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9570: LD_EXP 49
9574: PPUSH
9575: CALL_OW 301
9579: PUSH
9580: LD_EXP 49
9584: PPUSH
9585: CALL_OW 255
9589: PUSH
9590: LD_INT 4
9592: EQUAL
9593: AND
9594: PUSH
9595: LD_INT 22
9597: PUSH
9598: LD_INT 7
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 69
9609: PPUSH
9610: LD_EXP 49
9614: PPUSH
9615: CALL_OW 74
9619: PPUSH
9620: LD_EXP 49
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 10
9632: LESS
9633: OR
9634: IFFALSE 9423
// if IsDead ( Belkov ) then
9636: LD_EXP 49
9640: PPUSH
9641: CALL_OW 301
9645: IFFALSE 9670
// begin CenterNowOnUnits ( Belkov ) ;
9647: LD_EXP 49
9651: PPUSH
9652: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9656: LD_EXP 16
9660: PPUSH
9661: LD_STRING D5a-JMM-2a
9663: PPUSH
9664: CALL_OW 88
// exit ;
9668: GO 9736
// end ; if See ( 7 , Belkov ) then
9670: LD_INT 7
9672: PPUSH
9673: LD_EXP 49
9677: PPUSH
9678: CALL_OW 292
9682: IFFALSE 9696
// SetSide ( Belkov , 7 ) ;
9684: LD_EXP 49
9688: PPUSH
9689: LD_INT 7
9691: PPUSH
9692: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9703: LD_EXP 49
9707: PPUSH
9708: LD_INT 66
9710: PPUSH
9711: LD_INT 45
9713: PPUSH
9714: CALL_OW 297
9718: PUSH
9719: LD_INT 30
9721: LESS
9722: IFFALSE 9696
// Say ( Belkov , D6-Bel-1 ) ;
9724: LD_EXP 49
9728: PPUSH
9729: LD_STRING D6-Bel-1
9731: PPUSH
9732: CALL_OW 88
// end ;
9736: PPOPN 3
9738: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9739: LD_EXP 49
9743: PPUSH
9744: CALL_OW 302
9748: PUSH
9749: LD_EXP 49
9753: PPUSH
9754: CALL_OW 504
9758: PUSH
9759: LD_INT 2
9761: PUSH
9762: LD_INT 34
9764: PUSH
9765: LD_INT 47
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 34
9774: PUSH
9775: LD_INT 45
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: LIST
9786: PPUSH
9787: CALL_OW 69
9791: IN
9792: AND
9793: IFFALSE 9810
9795: GO 9797
9797: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9798: LD_EXP 49
9802: PPUSH
9803: LD_STRING D7-Bel-1
9805: PPUSH
9806: CALL_OW 88
9810: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9811: LD_INT 22
9813: PUSH
9814: LD_INT 7
9816: PUSH
9817: EMPTY
9818: LIST
9819: LIST
9820: PUSH
9821: LD_INT 101
9823: PUSH
9824: LD_INT 2
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: PUSH
9831: EMPTY
9832: LIST
9833: LIST
9834: PPUSH
9835: CALL_OW 69
9839: PUSH
9840: LD_EXP 8
9844: NOT
9845: AND
9846: PUSH
9847: LD_EXP 48
9851: PPUSH
9852: CALL_OW 305
9856: NOT
9857: AND
9858: IFFALSE 10328
9860: GO 9862
9862: DISABLE
9863: LD_INT 0
9865: PPUSH
// begin ar_base_spotted := true ;
9866: LD_ADDR_EXP 8
9870: PUSH
9871: LD_INT 1
9873: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9874: LD_ADDR_VAR 0 1
9878: PUSH
9879: LD_INT 22
9881: PUSH
9882: LD_INT 2
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 21
9891: PUSH
9892: LD_INT 3
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 69
9907: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9908: LD_ADDR_VAR 0 1
9912: PUSH
9913: LD_VAR 0 1
9917: PPUSH
9918: LD_EXP 16
9922: PPUSH
9923: CALL_OW 74
9927: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9928: LD_INT 7
9930: PPUSH
9931: LD_INT 3
9933: PPUSH
9934: CALL_OW 332
// DialogueOn ;
9938: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9942: LD_VAR 0 1
9946: PPUSH
9947: CALL_OW 250
9951: PPUSH
9952: LD_VAR 0 1
9956: PPUSH
9957: CALL_OW 251
9961: PPUSH
9962: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9966: LD_ADDR_VAR 0 1
9970: PUSH
9971: LD_INT 22
9973: PUSH
9974: LD_INT 7
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PUSH
9981: LD_INT 23
9983: PUSH
9984: LD_INT 1
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 26
9993: PUSH
9994: LD_INT 1
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: PUSH
10011: LD_EXP 16
10015: PUSH
10016: LD_EXP 20
10020: PUSH
10021: LD_EXP 21
10025: PUSH
10026: LD_EXP 28
10030: PUSH
10031: LD_EXP 17
10035: PUSH
10036: LD_EXP 26
10040: PUSH
10041: LD_EXP 22
10045: PUSH
10046: LD_EXP 24
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: DIFF
10061: ST_TO_ADDR
// if not tmp then
10062: LD_VAR 0 1
10066: NOT
10067: IFFALSE 10141
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10069: LD_ADDR_VAR 0 1
10073: PUSH
10074: LD_INT 22
10076: PUSH
10077: LD_INT 7
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 23
10086: PUSH
10087: LD_INT 1
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 26
10096: PUSH
10097: LD_INT 2
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PPUSH
10109: CALL_OW 69
10113: PUSH
10114: LD_EXP 31
10118: PUSH
10119: LD_EXP 18
10123: PUSH
10124: LD_EXP 29
10128: PUSH
10129: LD_EXP 30
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: DIFF
10140: ST_TO_ADDR
// if tmp then
10141: LD_VAR 0 1
10145: IFFALSE 10216
// case GetSex ( tmp [ 1 ] ) of sex_male :
10147: LD_VAR 0 1
10151: PUSH
10152: LD_INT 1
10154: ARRAY
10155: PPUSH
10156: CALL_OW 258
10160: PUSH
10161: LD_INT 1
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10188
10169: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10170: LD_VAR 0 1
10174: PUSH
10175: LD_INT 1
10177: ARRAY
10178: PPUSH
10179: LD_STRING D9-Sol1-1
10181: PPUSH
10182: CALL_OW 88
10186: GO 10216
10188: LD_INT 2
10190: DOUBLE
10191: EQUAL
10192: IFTRUE 10196
10194: GO 10215
10196: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10197: LD_VAR 0 1
10201: PUSH
10202: LD_INT 1
10204: ARRAY
10205: PPUSH
10206: LD_STRING D9-FSol1-1
10208: PPUSH
10209: CALL_OW 88
10213: GO 10216
10215: POP
// if Frank then
10216: LD_EXP 28
10220: IFFALSE 10324
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10222: LD_EXP 58
10226: PPUSH
10227: CALL_OW 250
10231: PPUSH
10232: LD_EXP 58
10236: PPUSH
10237: CALL_OW 251
10241: PPUSH
10242: LD_INT 7
10244: PPUSH
10245: LD_INT 8
10247: PPUSH
10248: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
10252: LD_EXP 58
10256: PPUSH
10257: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
10261: LD_EXP 28
10265: PPUSH
10266: LD_STRING D9-Frank-1
10268: PPUSH
10269: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
10273: LD_EXP 16
10277: PPUSH
10278: LD_STRING D9-JMM-1
10280: PPUSH
10281: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
10285: LD_EXP 28
10289: PPUSH
10290: LD_STRING D9-Frank-2
10292: PPUSH
10293: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
10297: LD_EXP 58
10301: PPUSH
10302: CALL_OW 250
10306: PPUSH
10307: LD_EXP 58
10311: PPUSH
10312: CALL_OW 251
10316: PPUSH
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 331
// end ; DialogueOff ;
10324: CALL_OW 7
// end ;
10328: PPOPN 1
10330: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
10331: LD_EXP 7
10335: PUSH
10336: LD_OWVAR 1
10340: PUSH
10341: LD_INT 42000
10343: GREATEREQUAL
10344: OR
10345: IFFALSE 11379
10347: GO 10349
10349: DISABLE
10350: LD_INT 0
10352: PPUSH
10353: PPUSH
// begin selected_option := 1 ;
10354: LD_ADDR_VAR 0 2
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10362: LD_INT 10500
10364: PPUSH
10365: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10369: LD_INT 35
10371: PPUSH
10372: CALL_OW 67
// until not ru_attackers ;
10376: LD_EXP 54
10380: NOT
10381: IFFALSE 10369
// PrepareBurlak ;
10383: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10387: LD_INT 70
10389: PPUSH
10390: CALL_OW 67
// until not HasTask ( Burlak ) ;
10394: LD_EXP 48
10398: PPUSH
10399: CALL_OW 314
10403: NOT
10404: IFFALSE 10387
// InGameOn ;
10406: CALL_OW 8
// DialogueOn ;
10410: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10414: LD_EXP 51
10418: PPUSH
10419: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10423: LD_EXP 48
10427: PPUSH
10428: LD_STRING D10-Bur-1
10430: PPUSH
10431: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10435: LD_EXP 49
10439: PUSH
10440: LD_EXP 49
10444: PPUSH
10445: CALL_OW 255
10449: PUSH
10450: LD_INT 7
10452: EQUAL
10453: AND
10454: IFFALSE 10468
// Say ( Belkov , D10-Bel-1 ) ;
10456: LD_EXP 49
10460: PPUSH
10461: LD_STRING D10-Bel-1
10463: PPUSH
10464: CALL_OW 88
// if Gossudarov then
10468: LD_EXP 34
10472: IFFALSE 10486
// Say ( Gossudarov , D10-Gos-1 ) ;
10474: LD_EXP 34
10478: PPUSH
10479: LD_STRING D10-Gos-1
10481: PPUSH
10482: CALL_OW 88
// if Kirilenkova then
10486: LD_EXP 35
10490: IFFALSE 10504
// Say ( Kirilenkova , D10-Kir-1 ) ;
10492: LD_EXP 35
10496: PPUSH
10497: LD_STRING D10-Kir-1
10499: PPUSH
10500: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10504: CALL 14032 0 0
10508: PPUSH
10509: LD_STRING D10-RSol1-1
10511: PPUSH
10512: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10516: LD_EXP 48
10520: PPUSH
10521: LD_STRING D10-Bur-2
10523: PPUSH
10524: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10528: LD_EXP 16
10532: PPUSH
10533: LD_STRING D10-JMM-2
10535: PPUSH
10536: CALL_OW 88
// if Kirilenkova then
10540: LD_EXP 35
10544: IFFALSE 10560
// Say ( Kirilenkova , D10-Kir-2 ) else
10546: LD_EXP 35
10550: PPUSH
10551: LD_STRING D10-Kir-2
10553: PPUSH
10554: CALL_OW 88
10558: GO 10572
// Say ( SolRu , D10-RSol1-2 ) ;
10560: CALL 14032 0 0
10564: PPUSH
10565: LD_STRING D10-RSol1-2
10567: PPUSH
10568: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10572: LD_EXP 16
10576: PPUSH
10577: LD_STRING D10-JMM-3
10579: PPUSH
10580: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10584: LD_EXP 48
10588: PPUSH
10589: LD_STRING D10-Bur-3
10591: PPUSH
10592: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10596: LD_EXP 16
10600: PPUSH
10601: LD_STRING D10-JMM-4
10603: PPUSH
10604: CALL_OW 88
// DialogueOff ;
10608: CALL_OW 7
// InGameOff ;
10612: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10616: LD_STRING M2
10618: PPUSH
10619: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10623: LD_INT 35
10625: PPUSH
10626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10630: LD_INT 22
10632: PUSH
10633: LD_INT 7
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 91
10642: PUSH
10643: LD_EXP 48
10647: PUSH
10648: LD_INT 8
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: LIST
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 69
10664: IFFALSE 10623
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10666: LD_ADDR_VAR 0 1
10670: PUSH
10671: LD_INT 22
10673: PUSH
10674: LD_INT 4
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: PPUSH
10681: CALL_OW 69
10685: PUSH
10686: FOR_IN
10687: IFFALSE 10703
// SetSide ( i , 7 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 7
10696: PPUSH
10697: CALL_OW 235
10701: GO 10686
10703: POP
10704: POP
// ChangeMissionObjectives ( M3 ) ;
10705: LD_STRING M3
10707: PPUSH
10708: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10712: LD_INT 35
10714: PPUSH
10715: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10719: LD_EXP 16
10723: PPUSH
10724: LD_EXP 48
10728: PPUSH
10729: CALL_OW 296
10733: PUSH
10734: LD_INT 8
10736: LESS
10737: IFFALSE 10712
// ComTurnUnit ( JMM , Burlak ) ;
10739: LD_EXP 16
10743: PPUSH
10744: LD_EXP 48
10748: PPUSH
10749: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10753: LD_EXP 48
10757: PPUSH
10758: LD_EXP 16
10762: PPUSH
10763: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10767: LD_INT 10
10769: PPUSH
10770: CALL_OW 67
// DialogueOn ;
10774: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10778: LD_EXP 16
10782: PPUSH
10783: LD_STRING D11-JMM-1
10785: PPUSH
10786: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10790: LD_EXP 48
10794: PPUSH
10795: LD_STRING D11-Bur-1
10797: PPUSH
10798: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10802: LD_EXP 16
10806: PPUSH
10807: LD_STRING D11-JMM-2
10809: PPUSH
10810: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10814: LD_EXP 48
10818: PPUSH
10819: LD_STRING D11-Bur-2
10821: PPUSH
10822: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10826: LD_EXP 16
10830: PPUSH
10831: LD_STRING D11-JMM-3
10833: PPUSH
10834: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10838: LD_EXP 48
10842: PPUSH
10843: LD_STRING D11-Bur-3
10845: PPUSH
10846: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10850: LD_EXP 16
10854: PPUSH
10855: LD_STRING D11-JMM-4
10857: PPUSH
10858: CALL_OW 88
// if ar_base_spotted then
10862: LD_EXP 8
10866: IFFALSE 10882
// Say ( Burlak , D12-Bur-1 ) else
10868: LD_EXP 48
10872: PPUSH
10873: LD_STRING D12-Bur-1
10875: PPUSH
10876: CALL_OW 88
10880: GO 10921
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10882: LD_INT 7
10884: PPUSH
10885: LD_INT 3
10887: PPUSH
10888: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10892: LD_INT 127
10894: PPUSH
10895: LD_INT 45
10897: PPUSH
10898: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10902: LD_EXP 48
10906: PPUSH
10907: LD_STRING D12-Bur-1a
10909: PPUSH
10910: CALL_OW 88
// dwait ( 0 0$2 ) ;
10914: LD_INT 70
10916: PPUSH
10917: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10921: LD_EXP 48
10925: PPUSH
10926: LD_STRING D12-Bur-1b
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10933: LD_EXP 16
10937: PPUSH
10938: LD_STRING D12-JMM-1
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10945: LD_EXP 48
10949: PPUSH
10950: LD_STRING D12-Bur-2
10952: PPUSH
10953: CALL_OW 88
// if Roth then
10957: LD_EXP 17
10961: IFFALSE 10977
// Say ( Roth , D12-Roth-2 ) else
10963: LD_EXP 17
10967: PPUSH
10968: LD_STRING D12-Roth-2
10970: PPUSH
10971: CALL_OW 88
10975: GO 10989
// Say ( SciRu , D12-RSci1-2 ) ;
10977: CALL 13885 0 0
10981: PPUSH
10982: LD_STRING D12-RSci1-2
10984: PPUSH
10985: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10989: LD_EXP 16
10993: PPUSH
10994: LD_STRING D12-JMM-2
10996: PPUSH
10997: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11001: LD_EXP 48
11005: PPUSH
11006: LD_STRING D12-Bur-3
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11013: LD_EXP 16
11017: PPUSH
11018: LD_STRING D12-JMM-3
11020: PPUSH
11021: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11025: LD_EXP 48
11029: PPUSH
11030: LD_STRING D12-Bur-4
11032: PPUSH
11033: CALL_OW 88
// case Query ( QBase ) of 1 :
11037: LD_STRING QBase
11039: PPUSH
11040: CALL_OW 97
11044: PUSH
11045: LD_INT 1
11047: DOUBLE
11048: EQUAL
11049: IFTRUE 11053
11051: GO 11171
11053: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11054: LD_EXP 16
11058: PPUSH
11059: LD_STRING D13a-JMM-1
11061: PPUSH
11062: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11066: LD_EXP 48
11070: PPUSH
11071: LD_STRING D13a-Bur-1
11073: PPUSH
11074: CALL_OW 88
// if Roth then
11078: LD_EXP 17
11082: IFFALSE 11098
// Say ( Roth , D13a-Roth-1 ) else
11084: LD_EXP 17
11088: PPUSH
11089: LD_STRING D13a-Roth-1
11091: PPUSH
11092: CALL_OW 88
11096: GO 11110
// Say ( SciRu , D13a-RSci1-1 ) ;
11098: CALL 13885 0 0
11102: PPUSH
11103: LD_STRING D13a-RSci1-1
11105: PPUSH
11106: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11110: LD_EXP 16
11114: PPUSH
11115: LD_STRING D13a-JMM-2
11117: PPUSH
11118: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11122: LD_STRING QBaseAgain
11124: PPUSH
11125: CALL_OW 97
11129: PUSH
11130: LD_INT 1
11132: DOUBLE
11133: EQUAL
11134: IFTRUE 11138
11136: GO 11149
11138: POP
// selected_option := 2 ; 2 :
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_INT 2
11146: ST_TO_ADDR
11147: GO 11169
11149: LD_INT 2
11151: DOUBLE
11152: EQUAL
11153: IFTRUE 11157
11155: GO 11168
11157: POP
// selected_option := 3 ; end ;
11158: LD_ADDR_VAR 0 2
11162: PUSH
11163: LD_INT 3
11165: ST_TO_ADDR
11166: GO 11169
11168: POP
// end ; 2 :
11169: GO 11210
11171: LD_INT 2
11173: DOUBLE
11174: EQUAL
11175: IFTRUE 11179
11177: GO 11190
11179: POP
// selected_option := 2 ; 3 :
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 2
11187: ST_TO_ADDR
11188: GO 11210
11190: LD_INT 3
11192: DOUBLE
11193: EQUAL
11194: IFTRUE 11198
11196: GO 11209
11198: POP
// selected_option := 3 ; end ;
11199: LD_ADDR_VAR 0 2
11203: PUSH
11204: LD_INT 3
11206: ST_TO_ADDR
11207: GO 11210
11209: POP
// if selected_option = 2 then
11210: LD_VAR 0 2
11214: PUSH
11215: LD_INT 2
11217: EQUAL
11218: IFFALSE 11312
// begin Say ( JMM , D13b-JMM-1 ) ;
11220: LD_EXP 16
11224: PPUSH
11225: LD_STRING D13b-JMM-1
11227: PPUSH
11228: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
11232: LD_EXP 48
11236: PPUSH
11237: LD_STRING D13b-Bur-1
11239: PPUSH
11240: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
11244: LD_EXP 16
11248: PPUSH
11249: LD_STRING D13b-JMM-2
11251: PPUSH
11252: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
11256: LD_EXP 57
11260: PPUSH
11261: LD_STRING D13b-Abd-2
11263: PPUSH
11264: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
11268: LD_EXP 16
11272: PPUSH
11273: LD_STRING D13b-JMM-3
11275: PPUSH
11276: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
11280: LD_EXP 57
11284: PPUSH
11285: LD_STRING D13b-Abd-3
11287: PPUSH
11288: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
11292: LD_EXP 16
11296: PPUSH
11297: LD_STRING D13b-JMM-4
11299: PPUSH
11300: CALL_OW 88
// ar_active_attack := true ;
11304: LD_ADDR_EXP 9
11308: PUSH
11309: LD_INT 1
11311: ST_TO_ADDR
// end ; if selected_option = 3 then
11312: LD_VAR 0 2
11316: PUSH
11317: LD_INT 3
11319: EQUAL
11320: IFFALSE 11346
// begin Say ( JMM , D13c-JMM-1 ) ;
11322: LD_EXP 16
11326: PPUSH
11327: LD_STRING D13c-JMM-1
11329: PPUSH
11330: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
11334: LD_EXP 48
11338: PPUSH
11339: LD_STRING D13c-Bur-1
11341: PPUSH
11342: CALL_OW 88
// end ; DialogueOff ;
11346: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
11350: LD_STRING M4
11352: PPUSH
11353: CALL_OW 337
// if not ar_active_attack then
11357: LD_EXP 9
11361: NOT
11362: IFFALSE 11379
// begin wait ( 6 6$00 ) ;
11364: LD_INT 12600
11366: PPUSH
11367: CALL_OW 67
// ar_active_attack := true ;
11371: LD_ADDR_EXP 9
11375: PUSH
11376: LD_INT 1
11378: ST_TO_ADDR
// end ; end ;
11379: PPOPN 2
11381: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11382: LD_EXP 48
11386: PPUSH
11387: CALL_OW 305
11391: PUSH
11392: LD_EXP 48
11396: PPUSH
11397: CALL_OW 255
11401: PUSH
11402: LD_INT 7
11404: EQUAL
11405: AND
11406: IFFALSE 11602
11408: GO 11410
11410: DISABLE
11411: LD_INT 0
11413: PPUSH
// begin wait ( 4 4$40 ) ;
11414: LD_INT 9800
11416: PPUSH
11417: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11421: LD_INT 35
11423: PPUSH
11424: CALL_OW 67
// until not ru_attackers ;
11428: LD_EXP 54
11432: NOT
11433: IFFALSE 11421
// PrepareGnyevko ;
11435: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11439: LD_EXP 50
11443: PPUSH
11444: LD_INT 124
11446: PPUSH
11447: LD_INT 118
11449: PPUSH
11450: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11454: LD_EXP 50
11458: PPUSH
11459: CALL_OW 200
// time := 0 0$00 ;
11463: LD_ADDR_VAR 0 1
11467: PUSH
11468: LD_INT 0
11470: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11471: LD_INT 35
11473: PPUSH
11474: CALL_OW 67
// time := time + 0 0$1 ;
11478: LD_ADDR_VAR 0 1
11482: PUSH
11483: LD_VAR 0 1
11487: PUSH
11488: LD_INT 35
11490: PLUS
11491: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11492: LD_EXP 50
11496: PPUSH
11497: LD_INT 124
11499: PPUSH
11500: LD_INT 118
11502: PPUSH
11503: CALL_OW 307
11507: PUSH
11508: LD_VAR 0 1
11512: PUSH
11513: LD_INT 1050
11515: GREATEREQUAL
11516: OR
11517: IFFALSE 11471
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11519: LD_EXP 50
11523: PPUSH
11524: LD_STRING DBelkov-Gny-1
11526: PPUSH
11527: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11531: LD_EXP 48
11535: PPUSH
11536: LD_STRING DBelkov-Bur-1a
11538: PPUSH
11539: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11543: LD_INT 35
11545: PPUSH
11546: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11550: LD_EXP 50
11554: PPUSH
11555: LD_INT 22
11557: PUSH
11558: LD_INT 7
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PPUSH
11565: CALL_OW 69
11569: PPUSH
11570: LD_EXP 50
11574: PPUSH
11575: CALL_OW 74
11579: PPUSH
11580: CALL_OW 296
11584: PUSH
11585: LD_INT 8
11587: LESS
11588: IFFALSE 11543
// SetSide ( Gnyevko , 7 ) ;
11590: LD_EXP 50
11594: PPUSH
11595: LD_INT 7
11597: PPUSH
11598: CALL_OW 235
// end ;
11602: PPOPN 1
11604: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11605: LD_EXP 48
11609: PPUSH
11610: CALL_OW 255
11614: PUSH
11615: LD_INT 7
11617: EQUAL
11618: IFFALSE 11628
11620: GO 11622
11622: DISABLE
// begin enable ;
11623: ENABLE
// PrepareAmericanAttack ;
11624: CALL 7263 0 0
// end ;
11628: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11629: LD_INT 22
11631: PUSH
11632: LD_INT 1
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PPUSH
11639: CALL_OW 69
11643: IFFALSE 11827
11645: GO 11647
11647: DISABLE
11648: LD_INT 0
11650: PPUSH
11651: PPUSH
// begin while true do
11652: LD_INT 1
11654: IFFALSE 11711
// begin wait ( 0 0$1 ) ;
11656: LD_INT 35
11658: PPUSH
11659: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11663: LD_ADDR_VAR 0 2
11667: PUSH
11668: LD_INT 22
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PPUSH
11678: CALL_OW 69
11682: PPUSH
11683: LD_EXP 16
11687: PPUSH
11688: CALL_OW 74
11692: ST_TO_ADDR
// if See ( 7 , tmp ) then
11693: LD_INT 7
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL_OW 292
11705: IFFALSE 11709
// break ;
11707: GO 11711
// end ;
11709: GO 11652
// DialogueOn ;
11711: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11715: LD_VAR 0 2
11719: PPUSH
11720: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 250
11733: PPUSH
11734: LD_VAR 0 2
11738: PPUSH
11739: CALL_OW 251
11743: PPUSH
11744: LD_INT 7
11746: PPUSH
11747: LD_INT 8
11749: PPUSH
11750: CALL_OW 330
// if Denis then
11754: LD_EXP 22
11758: IFFALSE 11772
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11760: LD_EXP 22
11764: PPUSH
11765: LD_STRING DAmerAttack-Pet-1
11767: PPUSH
11768: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11772: LD_EXP 16
11776: PPUSH
11777: LD_STRING DAmerAttack-JMM-1
11779: PPUSH
11780: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11784: LD_EXP 48
11788: PPUSH
11789: LD_STRING DStop-Bur-1
11791: PPUSH
11792: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11796: LD_VAR 0 2
11800: PPUSH
11801: CALL_OW 250
11805: PPUSH
11806: LD_VAR 0 2
11810: PPUSH
11811: CALL_OW 251
11815: PPUSH
11816: LD_INT 7
11818: PPUSH
11819: CALL_OW 331
// DialogueOff ;
11823: CALL_OW 7
// end ;
11827: PPOPN 2
11829: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11830: LD_INT 22
11832: PUSH
11833: LD_INT 3
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: PUSH
11859: LD_INT 0
11861: EQUAL
11862: IFFALSE 11904
11864: GO 11866
11866: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11867: LD_STRING M5a
11869: PPUSH
11870: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11874: LD_EXP 16
11878: PPUSH
11879: LD_STRING D8-JMM-1
11881: PPUSH
11882: CALL_OW 88
// if Gossudarov then
11886: LD_EXP 34
11890: IFFALSE 11904
// Say ( Gossudarov , D8-Gos-1 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_STRING D8-Gos-1
11899: PPUSH
11900: CALL_OW 88
// end ;
11904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11905: LD_INT 22
11907: PUSH
11908: LD_INT 2
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 21
11917: PUSH
11918: LD_INT 1
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 69
11933: PUSH
11934: LD_INT 0
11936: EQUAL
11937: IFFALSE 11987
11939: GO 11941
11941: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11942: LD_STRING M4c
11944: PPUSH
11945: CALL_OW 337
// if Roth then
11949: LD_EXP 17
11953: IFFALSE 11969
// Say ( Roth , DStop-Roth-1 ) else
11955: LD_EXP 17
11959: PPUSH
11960: LD_STRING DStop-Roth-1
11962: PPUSH
11963: CALL_OW 88
11967: GO 11987
// if Gossudarov then
11969: LD_EXP 34
11973: IFFALSE 11987
// Say ( Gossudarov , D8-Gos-1a ) ;
11975: LD_EXP 34
11979: PPUSH
11980: LD_STRING D8-Gos-1a
11982: PPUSH
11983: CALL_OW 88
// end ;
11987: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11988: LD_INT 7
11990: PPUSH
11991: LD_INT 1
11993: PPUSH
11994: LD_INT 1
11996: PPUSH
11997: CALL 15564 0 3
12001: PUSH
12002: LD_INT 0
12004: EQUAL
12005: PUSH
12006: LD_INT 7
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_INT 1
12014: PPUSH
12015: CALL 15564 0 3
12019: PUSH
12020: LD_INT 0
12022: EQUAL
12023: AND
12024: IFFALSE 12036
12026: GO 12028
12028: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12029: LD_STRING M1a
12031: PPUSH
12032: CALL_OW 337
// end ;
12036: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12037: LD_INT 22
12039: PUSH
12040: LD_INT 2
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PUSH
12047: LD_INT 23
12049: PUSH
12050: LD_INT 2
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: LIST
12071: PPUSH
12072: CALL_OW 69
12076: PUSH
12077: LD_INT 0
12079: EQUAL
12080: PUSH
12081: LD_INT 22
12083: PUSH
12084: LD_INT 3
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 23
12093: PUSH
12094: LD_INT 3
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 21
12103: PUSH
12104: LD_INT 1
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 69
12120: PUSH
12121: LD_INT 0
12123: EQUAL
12124: AND
12125: PUSH
12126: LD_INT 22
12128: PUSH
12129: LD_INT 1
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: PPUSH
12136: CALL_OW 69
12140: PUSH
12141: LD_INT 0
12143: EQUAL
12144: AND
12145: PUSH
12146: LD_INT 7
12148: PPUSH
12149: LD_INT 1
12151: PPUSH
12152: LD_INT 1
12154: PPUSH
12155: CALL 15564 0 3
12159: PUSH
12160: LD_INT 0
12162: EQUAL
12163: AND
12164: PUSH
12165: LD_INT 7
12167: PPUSH
12168: LD_INT 3
12170: PPUSH
12171: LD_INT 1
12173: PPUSH
12174: CALL 15564 0 3
12178: PUSH
12179: LD_INT 0
12181: EQUAL
12182: AND
12183: PUSH
12184: LD_EXP 48
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 7
12196: EQUAL
12197: AND
12198: PUSH
12199: LD_EXP 48
12203: PPUSH
12204: CALL_OW 302
12208: AND
12209: IFFALSE 13882
12211: GO 12213
12213: DISABLE
12214: LD_INT 0
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
// begin m1 := false ;
12222: LD_ADDR_VAR 0 4
12226: PUSH
12227: LD_INT 0
12229: ST_TO_ADDR
// m2 := false ;
12230: LD_ADDR_VAR 0 5
12234: PUSH
12235: LD_INT 0
12237: ST_TO_ADDR
// m3 := false ;
12238: LD_ADDR_VAR 0 6
12242: PUSH
12243: LD_INT 0
12245: ST_TO_ADDR
// if tick < 40 40$00 then
12246: LD_OWVAR 1
12250: PUSH
12251: LD_INT 84000
12253: LESS
12254: IFFALSE 12263
// SetAchievement ( ACH_ASPEED_17 ) ;
12256: LD_STRING ACH_ASPEED_17
12258: PPUSH
12259: CALL_OW 543
// wait ( 0 0$5 ) ;
12263: LD_INT 175
12265: PPUSH
12266: CALL_OW 67
// if not masha_killed then
12270: LD_EXP 10
12274: NOT
12275: IFFALSE 12297
// begin m1 := true ;
12277: LD_ADDR_VAR 0 4
12281: PUSH
12282: LD_INT 1
12284: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
12285: LD_STRING Masha
12287: PPUSH
12288: LD_INT 1
12290: PPUSH
12291: CALL_OW 101
// end else
12295: GO 12308
// AddMedal ( Masha , - 1 ) ;
12297: LD_STRING Masha
12299: PPUSH
12300: LD_INT 1
12302: NEG
12303: PPUSH
12304: CALL_OW 101
// if abdul_escaped then
12308: LD_EXP 13
12312: IFFALSE 12327
// AddMedal ( Abdul , - 1 ) else
12314: LD_STRING Abdul
12316: PPUSH
12317: LD_INT 1
12319: NEG
12320: PPUSH
12321: CALL_OW 101
12325: GO 12345
// begin m2 := true ;
12327: LD_ADDR_VAR 0 5
12331: PUSH
12332: LD_INT 1
12334: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
12335: LD_STRING Abdul
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 101
// end ; if loss_counter = 0 then
12345: LD_EXP 14
12349: PUSH
12350: LD_INT 0
12352: EQUAL
12353: IFFALSE 12375
// begin m3 := true ;
12355: LD_ADDR_VAR 0 6
12359: PUSH
12360: LD_INT 1
12362: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
12363: LD_STRING People
12365: PPUSH
12366: LD_INT 2
12368: PPUSH
12369: CALL_OW 101
// end else
12373: GO 12437
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
12375: LD_EXP 14
12379: PUSH
12380: LD_INT 3
12382: PUSH
12383: LD_INT 2
12385: PUSH
12386: LD_INT 2
12388: PUSH
12389: LD_INT 1
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: PUSH
12398: LD_OWVAR 67
12402: ARRAY
12403: LESSEQUAL
12404: IFFALSE 12426
// begin AddMedal ( People , 1 ) ;
12406: LD_STRING People
12408: PPUSH
12409: LD_INT 1
12411: PPUSH
12412: CALL_OW 101
// m3 := true ;
12416: LD_ADDR_VAR 0 6
12420: PUSH
12421: LD_INT 1
12423: ST_TO_ADDR
// end else
12424: GO 12437
// AddMedal ( People , - 1 ) ;
12426: LD_STRING People
12428: PPUSH
12429: LD_INT 1
12431: NEG
12432: PPUSH
12433: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12437: LD_OWVAR 67
12441: PUSH
12442: LD_INT 3
12444: GREATEREQUAL
12445: PUSH
12446: LD_VAR 0 4
12450: AND
12451: PUSH
12452: LD_VAR 0 5
12456: AND
12457: PUSH
12458: LD_VAR 0 6
12462: AND
12463: IFFALSE 12475
// SetAchievementEX ( ACH_AMER , 17 ) ;
12465: LD_STRING ACH_AMER
12467: PPUSH
12468: LD_INT 17
12470: PPUSH
12471: CALL_OW 564
// GiveMedals ( MAIN ) ;
12475: LD_STRING MAIN
12477: PPUSH
12478: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: LD_INT 22
12489: PUSH
12490: LD_INT 7
12492: PUSH
12493: EMPTY
12494: LIST
12495: LIST
12496: PUSH
12497: LD_INT 50
12499: PUSH
12500: EMPTY
12501: LIST
12502: PUSH
12503: LD_INT 2
12505: PUSH
12506: LD_INT 25
12508: PUSH
12509: LD_INT 1
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 25
12518: PUSH
12519: LD_INT 2
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 25
12528: PUSH
12529: LD_INT 3
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 25
12538: PUSH
12539: LD_INT 4
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 25
12548: PUSH
12549: LD_INT 5
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 25
12558: PUSH
12559: LD_INT 8
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 9
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PPUSH
12591: CALL_OW 69
12595: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12596: LD_VAR 0 2
12600: PPUSH
12601: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_EXP 16
12614: PUSH
12615: LD_EXP 17
12619: PUSH
12620: LD_EXP 18
12624: PUSH
12625: LD_EXP 19
12629: PUSH
12630: LD_EXP 20
12634: PUSH
12635: LD_EXP 21
12639: PUSH
12640: LD_EXP 22
12644: PUSH
12645: LD_EXP 23
12649: PUSH
12650: LD_EXP 24
12654: PUSH
12655: LD_EXP 25
12659: PUSH
12660: LD_EXP 26
12664: PUSH
12665: LD_EXP 27
12669: PUSH
12670: LD_EXP 28
12674: PUSH
12675: LD_EXP 29
12679: PUSH
12680: LD_EXP 30
12684: PUSH
12685: LD_EXP 31
12689: PUSH
12690: LD_EXP 32
12694: PUSH
12695: LD_EXP 34
12699: PUSH
12700: LD_EXP 35
12704: PUSH
12705: LD_EXP 36
12709: PUSH
12710: LD_EXP 38
12714: PUSH
12715: LD_EXP 39
12719: PUSH
12720: LD_EXP 40
12724: PUSH
12725: LD_EXP 41
12729: PUSH
12730: LD_EXP 42
12734: PUSH
12735: LD_EXP 43
12739: PUSH
12740: LD_EXP 44
12744: PUSH
12745: LD_EXP 45
12749: PUSH
12750: LD_EXP 46
12754: PUSH
12755: LD_EXP 47
12759: PUSH
12760: LD_EXP 48
12764: PUSH
12765: LD_EXP 49
12769: PUSH
12770: LD_EXP 50
12774: PUSH
12775: LD_EXP 33
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: ST_TO_ADDR
// if tmp diff tmp2 then
12816: LD_VAR 0 2
12820: PUSH
12821: LD_VAR 0 3
12825: DIFF
12826: IFFALSE 12846
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12828: LD_VAR 0 2
12832: PUSH
12833: LD_VAR 0 3
12837: DIFF
12838: PPUSH
12839: LD_STRING 13a_others
12841: PPUSH
12842: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12846: LD_EXP 16
12850: PPUSH
12851: LD_STRING 13a_JMM
12853: PPUSH
12854: CALL_OW 38
// if IsOk ( Mike ) then
12858: LD_EXP 33
12862: PPUSH
12863: CALL_OW 302
12867: IFFALSE 12881
// SaveCharacters ( Mike , 13a_Mike ) ;
12869: LD_EXP 33
12873: PPUSH
12874: LD_STRING 13a_Mike
12876: PPUSH
12877: CALL_OW 38
// if IsOk ( Titov ) then
12881: LD_EXP 36
12885: PPUSH
12886: CALL_OW 302
12890: IFFALSE 12904
// SaveCharacters ( Titov , 13a_Titov ) ;
12892: LD_EXP 36
12896: PPUSH
12897: LD_STRING 13a_Titov
12899: PPUSH
12900: CALL_OW 38
// if IsOk ( Dolgov ) then
12904: LD_EXP 38
12908: PPUSH
12909: CALL_OW 302
12913: IFFALSE 12927
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12915: LD_EXP 38
12919: PPUSH
12920: LD_STRING 13a_Dolgov
12922: PPUSH
12923: CALL_OW 38
// if IsOk ( Petrosyan ) then
12927: LD_EXP 39
12931: PPUSH
12932: CALL_OW 302
12936: IFFALSE 12950
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12938: LD_EXP 39
12942: PPUSH
12943: LD_STRING 13a_Petrosyan
12945: PPUSH
12946: CALL_OW 38
// if IsOk ( Scholtze ) then
12950: LD_EXP 40
12954: PPUSH
12955: CALL_OW 302
12959: IFFALSE 12973
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12961: LD_EXP 40
12965: PPUSH
12966: LD_STRING 13a_Scholtze
12968: PPUSH
12969: CALL_OW 38
// if IsOk ( Oblukov ) then
12973: LD_EXP 41
12977: PPUSH
12978: CALL_OW 302
12982: IFFALSE 12996
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12984: LD_EXP 41
12988: PPUSH
12989: LD_STRING 13a_Oblukov
12991: PPUSH
12992: CALL_OW 38
// if IsOk ( Kapitsova ) then
12996: LD_EXP 42
13000: PPUSH
13001: CALL_OW 302
13005: IFFALSE 13019
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13007: LD_EXP 42
13011: PPUSH
13012: LD_STRING 13a_Kapitsova
13014: PPUSH
13015: CALL_OW 38
// if IsOk ( Lipshchin ) then
13019: LD_EXP 43
13023: PPUSH
13024: CALL_OW 302
13028: IFFALSE 13042
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13030: LD_EXP 43
13034: PPUSH
13035: LD_STRING 13a_Lipshchin
13037: PPUSH
13038: CALL_OW 38
// if IsOk ( Petrovova ) then
13042: LD_EXP 44
13046: PPUSH
13047: CALL_OW 302
13051: IFFALSE 13065
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13053: LD_EXP 44
13057: PPUSH
13058: LD_STRING 13a_Petrovova
13060: PPUSH
13061: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13065: LD_EXP 45
13069: PPUSH
13070: CALL_OW 302
13074: IFFALSE 13088
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13076: LD_EXP 45
13080: PPUSH
13081: LD_STRING 13a_Kovalyuk
13083: PPUSH
13084: CALL_OW 38
// if IsOk ( Kuzmov ) then
13088: LD_EXP 46
13092: PPUSH
13093: CALL_OW 302
13097: IFFALSE 13111
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
13099: LD_EXP 46
13103: PPUSH
13104: LD_STRING 13a_Kuzmov
13106: PPUSH
13107: CALL_OW 38
// if IsOk ( Karamazov ) then
13111: LD_EXP 47
13115: PPUSH
13116: CALL_OW 302
13120: IFFALSE 13134
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
13122: LD_EXP 47
13126: PPUSH
13127: LD_STRING 13a_Karamazov
13129: PPUSH
13130: CALL_OW 38
// if Burlak then
13134: LD_EXP 48
13138: IFFALSE 13159
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
13140: LD_STRING enableBioCharacter(BIO_GORKI)
13142: PPUSH
13143: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
13147: LD_EXP 48
13151: PPUSH
13152: LD_STRING 13a_Burlak
13154: PPUSH
13155: CALL_OW 38
// end ; if IsOk ( Belkov ) then
13159: LD_EXP 49
13163: PPUSH
13164: CALL_OW 302
13168: IFFALSE 13182
// SaveCharacters ( Belkov , 13a_Belkov ) ;
13170: LD_EXP 49
13174: PPUSH
13175: LD_STRING 13a_Belkov
13177: PPUSH
13178: CALL_OW 38
// if IsOk ( Gnyevko ) then
13182: LD_EXP 50
13186: PPUSH
13187: CALL_OW 302
13191: IFFALSE 13205
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
13193: LD_EXP 50
13197: PPUSH
13198: LD_STRING 13a_Gnyevko
13200: PPUSH
13201: CALL_OW 38
// if IsOk ( Lisa ) then
13205: LD_EXP 18
13209: PPUSH
13210: CALL_OW 302
13214: IFFALSE 13228
// SaveCharacters ( Lisa , 13a_Lisa ) ;
13216: LD_EXP 18
13220: PPUSH
13221: LD_STRING 13a_Lisa
13223: PPUSH
13224: CALL_OW 38
// if IsOk ( Donaldson ) then
13228: LD_EXP 19
13232: PPUSH
13233: CALL_OW 302
13237: IFFALSE 13251
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
13239: LD_EXP 19
13243: PPUSH
13244: LD_STRING 13a_Donaldson
13246: PPUSH
13247: CALL_OW 38
// if IsOk ( Bobby ) then
13251: LD_EXP 20
13255: PPUSH
13256: CALL_OW 302
13260: IFFALSE 13274
// SaveCharacters ( Bobby , 13a_Bobby ) ;
13262: LD_EXP 20
13266: PPUSH
13267: LD_STRING 13a_Bobby
13269: PPUSH
13270: CALL_OW 38
// if IsOk ( Cyrus ) then
13274: LD_EXP 21
13278: PPUSH
13279: CALL_OW 302
13283: IFFALSE 13297
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
13285: LD_EXP 21
13289: PPUSH
13290: LD_STRING 13a_Cyrus
13292: PPUSH
13293: CALL_OW 38
// if IsOk ( Denis ) then
13297: LD_EXP 22
13301: PPUSH
13302: CALL_OW 302
13306: IFFALSE 13320
// SaveCharacters ( Denis , 13a_Denis ) ;
13308: LD_EXP 22
13312: PPUSH
13313: LD_STRING 13a_Denis
13315: PPUSH
13316: CALL_OW 38
// if IsOk ( Brown ) then
13320: LD_EXP 23
13324: PPUSH
13325: CALL_OW 302
13329: IFFALSE 13343
// SaveCharacters ( Brown , 13a_Brown ) ;
13331: LD_EXP 23
13335: PPUSH
13336: LD_STRING 13a_Brown
13338: PPUSH
13339: CALL_OW 38
// if IsOk ( Gladstone ) then
13343: LD_EXP 24
13347: PPUSH
13348: CALL_OW 302
13352: IFFALSE 13366
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
13354: LD_EXP 24
13358: PPUSH
13359: LD_STRING 13a_Gladstone
13361: PPUSH
13362: CALL_OW 38
// if IsOk ( Houten ) then
13366: LD_EXP 25
13370: PPUSH
13371: CALL_OW 302
13375: IFFALSE 13389
// SaveCharacters ( Houten , 13a_Houten ) ;
13377: LD_EXP 25
13381: PPUSH
13382: LD_STRING 13a_Houten
13384: PPUSH
13385: CALL_OW 38
// if IsOk ( Cornel ) then
13389: LD_EXP 26
13393: PPUSH
13394: CALL_OW 302
13398: IFFALSE 13412
// SaveCharacters ( Cornel , 13a_Cornel ) ;
13400: LD_EXP 26
13404: PPUSH
13405: LD_STRING 13a_Cornel
13407: PPUSH
13408: CALL_OW 38
// if IsOk ( Gary ) then
13412: LD_EXP 27
13416: PPUSH
13417: CALL_OW 302
13421: IFFALSE 13435
// SaveCharacters ( Gary , 13a_Gary ) ;
13423: LD_EXP 27
13427: PPUSH
13428: LD_STRING 13a_Gary
13430: PPUSH
13431: CALL_OW 38
// if IsOk ( Frank ) then
13435: LD_EXP 28
13439: PPUSH
13440: CALL_OW 302
13444: IFFALSE 13458
// SaveCharacters ( Frank , 13a_Frank ) ;
13446: LD_EXP 28
13450: PPUSH
13451: LD_STRING 13a_Frank
13453: PPUSH
13454: CALL_OW 38
// if IsOk ( Kikuchi ) then
13458: LD_EXP 29
13462: PPUSH
13463: CALL_OW 302
13467: IFFALSE 13481
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
13469: LD_EXP 29
13473: PPUSH
13474: LD_STRING 13a_Kikuchi
13476: PPUSH
13477: CALL_OW 38
// if IsOk ( Simms ) then
13481: LD_EXP 30
13485: PPUSH
13486: CALL_OW 302
13490: IFFALSE 13504
// SaveCharacters ( Simms , 13a_Simms ) ;
13492: LD_EXP 30
13496: PPUSH
13497: LD_STRING 13a_Simms
13499: PPUSH
13500: CALL_OW 38
// if IsOk ( Joan ) then
13504: LD_EXP 31
13508: PPUSH
13509: CALL_OW 302
13513: IFFALSE 13527
// SaveCharacters ( Joan , 13a_Joan ) ;
13515: LD_EXP 31
13519: PPUSH
13520: LD_STRING 13a_Joan
13522: PPUSH
13523: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
13527: LD_EXP 32
13531: PPUSH
13532: CALL_OW 302
13536: IFFALSE 13550
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
13538: LD_EXP 32
13542: PPUSH
13543: LD_STRING 13a_DeltaDoctor
13545: PPUSH
13546: CALL_OW 38
// if IsOk ( Gossudarov ) then
13550: LD_EXP 34
13554: PPUSH
13555: CALL_OW 302
13559: IFFALSE 13573
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13561: LD_EXP 34
13565: PPUSH
13566: LD_STRING 13a_Gossudarov
13568: PPUSH
13569: CALL_OW 38
// if IsOk ( Kirilenkova ) then
13573: LD_EXP 35
13577: PPUSH
13578: CALL_OW 302
13582: IFFALSE 13596
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13584: LD_EXP 35
13588: PPUSH
13589: LD_STRING 13a_Kirilenkova
13591: PPUSH
13592: CALL_OW 38
// if IsOk ( Roth ) then
13596: LD_EXP 17
13600: PPUSH
13601: CALL_OW 302
13605: IFFALSE 13619
// SaveCharacters ( Roth , 13a_Roth ) ;
13607: LD_EXP 17
13611: PPUSH
13612: LD_STRING 13a_Roth
13614: PPUSH
13615: CALL_OW 38
// if Masha then
13619: LD_EXP 51
13623: IFFALSE 13678
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13625: LD_EXP 51
13629: PPUSH
13630: CALL_OW 265
13634: PUSH
13635: LD_EXP 51
13639: PPUSH
13640: CALL_OW 262
13644: PUSH
13645: LD_EXP 51
13649: PPUSH
13650: CALL_OW 263
13654: PUSH
13655: LD_EXP 51
13659: PPUSH
13660: CALL_OW 264
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: PPUSH
13671: LD_STRING 13a_Masha
13673: PPUSH
13674: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13678: LD_ADDR_VAR 0 2
13682: PUSH
13683: LD_INT 21
13685: PUSH
13686: LD_INT 3
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: ST_TO_ADDR
// tmp2 := [ ] ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: EMPTY
13704: ST_TO_ADDR
// if tmp then
13705: LD_VAR 0 2
13709: IFFALSE 13860
// for i in tmp do
13711: LD_ADDR_VAR 0 1
13715: PUSH
13716: LD_VAR 0 2
13720: PUSH
13721: FOR_IN
13722: IFFALSE 13858
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13724: LD_ADDR_VAR 0 3
13728: PUSH
13729: LD_VAR 0 3
13733: PUSH
13734: LD_VAR 0 1
13738: PPUSH
13739: CALL_OW 255
13743: PUSH
13744: LD_VAR 0 1
13748: PPUSH
13749: CALL_OW 248
13753: PUSH
13754: LD_VAR 0 1
13758: PPUSH
13759: CALL_OW 266
13763: PUSH
13764: LD_VAR 0 1
13768: PPUSH
13769: CALL_OW 250
13773: PUSH
13774: LD_VAR 0 1
13778: PPUSH
13779: CALL_OW 251
13783: PUSH
13784: LD_VAR 0 1
13788: PPUSH
13789: CALL_OW 254
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 267
13803: PUSH
13804: LD_VAR 0 1
13808: PPUSH
13809: LD_INT 1
13811: PPUSH
13812: CALL_OW 268
13816: PUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: LD_INT 2
13824: PPUSH
13825: CALL_OW 268
13829: PUSH
13830: LD_VAR 0 1
13834: PPUSH
13835: CALL_OW 269
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: PUSH
13852: EMPTY
13853: LIST
13854: ADD
13855: ST_TO_ADDR
13856: GO 13721
13858: POP
13859: POP
// if tmp2 then
13860: LD_VAR 0 3
13864: IFFALSE 13878
// SaveVariable ( tmp2 , 13a_buildings ) ;
13866: LD_VAR 0 3
13870: PPUSH
13871: LD_STRING 13a_buildings
13873: PPUSH
13874: CALL_OW 39
// YouWin ;
13878: CALL_OW 103
// end ;
13882: PPOPN 6
13884: END
// export function SciRu ; var tmp , t ; begin
13885: LD_INT 0
13887: PPUSH
13888: PPUSH
13889: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13890: LD_ADDR_VAR 0 3
13894: PUSH
13895: LD_EXP 34
13899: PUSH
13900: LD_EXP 48
13904: PUSH
13905: LD_EXP 36
13909: PUSH
13910: LD_EXP 49
13914: PUSH
13915: LD_EXP 50
13919: PUSH
13920: LD_EXP 39
13924: PUSH
13925: LD_EXP 40
13929: PUSH
13930: LD_EXP 38
13934: PUSH
13935: EMPTY
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13945: LD_ADDR_VAR 0 2
13949: PUSH
13950: LD_INT 22
13952: PUSH
13953: LD_INT 7
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: PUSH
13960: LD_INT 23
13962: PUSH
13963: LD_INT 3
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: PUSH
13970: LD_INT 25
13972: PUSH
13973: LD_INT 4
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PUSH
13980: LD_INT 26
13982: PUSH
13983: LD_INT 1
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: PPUSH
13996: CALL_OW 69
14000: PUSH
14001: LD_VAR 0 3
14005: DIFF
14006: ST_TO_ADDR
// if tmp then
14007: LD_VAR 0 2
14011: IFFALSE 14027
// result := tmp [ 1 ] ;
14013: LD_ADDR_VAR 0 1
14017: PUSH
14018: LD_VAR 0 2
14022: PUSH
14023: LD_INT 1
14025: ARRAY
14026: ST_TO_ADDR
// end ;
14027: LD_VAR 0 1
14031: RET
// export function SolRu ; var tmp , t ; begin
14032: LD_INT 0
14034: PPUSH
14035: PPUSH
14036: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14037: LD_ADDR_VAR 0 3
14041: PUSH
14042: LD_EXP 34
14046: PUSH
14047: LD_EXP 48
14051: PUSH
14052: LD_EXP 36
14056: PUSH
14057: LD_EXP 49
14061: PUSH
14062: LD_EXP 50
14066: PUSH
14067: LD_EXP 39
14071: PUSH
14072: LD_EXP 40
14076: PUSH
14077: LD_EXP 38
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14092: LD_ADDR_VAR 0 2
14096: PUSH
14097: LD_INT 22
14099: PUSH
14100: LD_INT 7
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 23
14109: PUSH
14110: LD_INT 3
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: LD_INT 25
14119: PUSH
14120: LD_INT 1
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: PUSH
14127: LD_INT 26
14129: PUSH
14130: LD_INT 1
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PPUSH
14143: CALL_OW 69
14147: PUSH
14148: LD_VAR 0 3
14152: DIFF
14153: ST_TO_ADDR
// if tmp then
14154: LD_VAR 0 2
14158: IFFALSE 14174
// result := tmp [ 1 ] ;
14160: LD_ADDR_VAR 0 1
14164: PUSH
14165: LD_VAR 0 2
14169: PUSH
14170: LD_INT 1
14172: ARRAY
14173: ST_TO_ADDR
// end ; end_of_file
14174: LD_VAR 0 1
14178: RET
// export function CustomEvent ( event ) ; begin
14179: LD_INT 0
14181: PPUSH
// end ;
14182: LD_VAR 0 2
14186: RET
// on UnitDestroyed ( un ) do var i , side ;
14187: LD_INT 0
14189: PPUSH
14190: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
14191: LD_VAR 0 1
14195: PPUSH
14196: CALL 103554 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
14200: LD_VAR 0 1
14204: PUSH
14205: LD_INT 22
14207: PUSH
14208: LD_INT 7
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: LD_INT 2
14217: PUSH
14218: LD_INT 25
14220: PUSH
14221: LD_INT 1
14223: PUSH
14224: EMPTY
14225: LIST
14226: LIST
14227: PUSH
14228: LD_INT 25
14230: PUSH
14231: LD_INT 2
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 25
14240: PUSH
14241: LD_INT 3
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 25
14250: PUSH
14251: LD_INT 4
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: LD_INT 25
14260: PUSH
14261: LD_INT 5
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_INT 25
14270: PUSH
14271: LD_INT 8
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: PUSH
14278: LD_INT 25
14280: PUSH
14281: LD_INT 9
14283: PUSH
14284: EMPTY
14285: LIST
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PPUSH
14302: CALL_OW 69
14306: IN
14307: IFFALSE 14323
// loss_counter := loss_counter + 1 ;
14309: LD_ADDR_EXP 14
14313: PUSH
14314: LD_EXP 14
14318: PUSH
14319: LD_INT 1
14321: PLUS
14322: ST_TO_ADDR
// if un = Abdul then
14323: LD_VAR 0 1
14327: PUSH
14328: LD_EXP 57
14332: EQUAL
14333: IFFALSE 14343
// abdul_escaped := false ;
14335: LD_ADDR_EXP 13
14339: PUSH
14340: LD_INT 0
14342: ST_TO_ADDR
// if un in ru_attackers then
14343: LD_VAR 0 1
14347: PUSH
14348: LD_EXP 54
14352: IN
14353: IFFALSE 14371
// ru_attackers := ru_attackers diff un ;
14355: LD_ADDR_EXP 54
14359: PUSH
14360: LD_EXP 54
14364: PUSH
14365: LD_VAR 0 1
14369: DIFF
14370: ST_TO_ADDR
// if un in ar_attackers then
14371: LD_VAR 0 1
14375: PUSH
14376: LD_EXP 11
14380: IN
14381: IFFALSE 14399
// ar_attackers := ar_attackers diff un ;
14383: LD_ADDR_EXP 11
14387: PUSH
14388: LD_EXP 11
14392: PUSH
14393: LD_VAR 0 1
14397: DIFF
14398: ST_TO_ADDR
// if un = JMM then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 16
14408: EQUAL
14409: IFFALSE 14420
// begin YouLost ( JMM ) ;
14411: LD_STRING JMM
14413: PPUSH
14414: CALL_OW 104
// exit ;
14418: GO 14517
// end ; if un = Burlak then
14420: LD_VAR 0 1
14424: PUSH
14425: LD_EXP 48
14429: EQUAL
14430: IFFALSE 14441
// begin YouLost ( Burlak ) ;
14432: LD_STRING Burlak
14434: PPUSH
14435: CALL_OW 104
// exit ;
14439: GO 14517
// end ; if un = freedom then
14441: LD_VAR 0 1
14445: PUSH
14446: LD_EXP 3
14450: EQUAL
14451: IFFALSE 14462
// begin YouLost ( Destroyed ) ;
14453: LD_STRING Destroyed
14455: PPUSH
14456: CALL_OW 104
// exit ;
14460: GO 14517
// end ; if un = Masha then
14462: LD_VAR 0 1
14466: PUSH
14467: LD_EXP 51
14471: EQUAL
14472: IFFALSE 14489
// begin ChangeMissionObjectives ( M4b ) ;
14474: LD_STRING M4b
14476: PPUSH
14477: CALL_OW 337
// masha_killed := true ;
14481: LD_ADDR_EXP 10
14485: PUSH
14486: LD_INT 1
14488: ST_TO_ADDR
// end ; if un = Mastodont then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 58
14498: EQUAL
14499: IFFALSE 14508
// ChangeMissionObjectives ( M4a ) ;
14501: LD_STRING M4a
14503: PPUSH
14504: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
14508: LD_VAR 0 1
14512: PPUSH
14513: CALL 84768 0 1
// end ;
14517: PPOPN 3
14519: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
14520: LD_VAR 0 1
14524: PPUSH
14525: LD_VAR 0 2
14529: PPUSH
14530: CALL 87100 0 2
// end ;
14534: PPOPN 2
14536: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
14537: LD_VAR 0 1
14541: PPUSH
14542: CALL 86168 0 1
// end ;
14546: PPOPN 1
14548: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
14549: LD_VAR 0 1
14553: PUSH
14554: LD_INT 22
14556: PUSH
14557: LD_INT 7
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: PUSH
14564: LD_INT 30
14566: PUSH
14567: LD_INT 0
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PPUSH
14578: CALL_OW 69
14582: IN
14583: IFFALSE 14622
// begin SetBName ( building , freedom ) ;
14585: LD_VAR 0 1
14589: PPUSH
14590: LD_STRING freedom
14592: PPUSH
14593: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14597: LD_INT 0
14599: PPUSH
14600: LD_INT 7
14602: PPUSH
14603: LD_INT 0
14605: PPUSH
14606: CALL_OW 324
// freedom := building ;
14610: LD_ADDR_EXP 3
14614: PUSH
14615: LD_VAR 0 1
14619: ST_TO_ADDR
// exit ;
14620: GO 14688
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14622: LD_VAR 0 1
14626: PUSH
14627: LD_INT 22
14629: PUSH
14630: LD_INT 7
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: LD_INT 23
14639: PUSH
14640: LD_INT 3
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 30
14649: PUSH
14650: LD_INT 6
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 69
14666: IN
14667: IFFALSE 14679
// begin ru_lab_builded := true ;
14669: LD_ADDR_EXP 5
14673: PUSH
14674: LD_INT 1
14676: ST_TO_ADDR
// exit ;
14677: GO 14688
// end ; MCE_BuildingComplete ( building ) ;
14679: LD_VAR 0 1
14683: PPUSH
14684: CALL 86409 0 1
// end ;
14688: PPOPN 1
14690: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14691: LD_VAR 0 1
14695: PPUSH
14696: LD_VAR 0 2
14700: PPUSH
14701: CALL 84464 0 2
// end ;
14705: PPOPN 2
14707: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_VAR 0 2
14717: PPUSH
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_VAR 0 4
14727: PPUSH
14728: LD_VAR 0 5
14732: PPUSH
14733: CALL 84084 0 5
// end ;
14737: PPOPN 5
14739: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_VAR 0 2
14749: PPUSH
14750: CALL 103674 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14754: LD_VAR 0 1
14758: PPUSH
14759: LD_VAR 0 2
14763: PPUSH
14764: CALL 83637 0 2
// end ;
14768: PPOPN 2
14770: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14771: LD_VAR 0 1
14775: PPUSH
14776: CALL_OW 263
14780: PUSH
14781: LD_INT 3
14783: EQUAL
14784: PUSH
14785: LD_VAR 0 2
14789: PPUSH
14790: CALL_OW 263
14794: PUSH
14795: LD_INT 3
14797: EQUAL
14798: OR
14799: IFFALSE 14815
// hack_counter := hack_counter + 1 ;
14801: LD_ADDR_EXP 15
14805: PUSH
14806: LD_EXP 15
14810: PUSH
14811: LD_INT 1
14813: PLUS
14814: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14815: LD_VAR 0 1
14819: PPUSH
14820: LD_VAR 0 2
14824: PPUSH
14825: LD_VAR 0 3
14829: PPUSH
14830: LD_VAR 0 4
14834: PPUSH
14835: CALL 83475 0 4
// end ;
14839: PPOPN 4
14841: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14842: LD_VAR 0 1
14846: PPUSH
14847: LD_VAR 0 2
14851: PPUSH
14852: LD_VAR 0 3
14856: PPUSH
14857: CALL 83250 0 3
// end ;
14861: PPOPN 3
14863: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14864: LD_VAR 0 1
14868: PPUSH
14869: LD_VAR 0 2
14873: PPUSH
14874: CALL 83135 0 2
// end ;
14878: PPOPN 2
14880: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14881: LD_VAR 0 1
14885: PPUSH
14886: LD_VAR 0 2
14890: PPUSH
14891: CALL 87395 0 2
// end ;
14895: PPOPN 2
14897: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14898: LD_VAR 0 1
14902: PPUSH
14903: LD_VAR 0 2
14907: PPUSH
14908: LD_VAR 0 3
14912: PPUSH
14913: LD_VAR 0 4
14917: PPUSH
14918: CALL 87611 0 4
// end ;
14922: PPOPN 4
14924: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14925: LD_VAR 0 1
14929: PPUSH
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 82944 0 2
// end ;
14939: PPOPN 2
14941: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14942: LD_VAR 0 1
14946: PPUSH
14947: CALL 103658 0 1
// end ; end_of_file
14951: PPOPN 1
14953: END
// every 0 0$30 do var cr , time ;
14954: GO 14956
14956: DISABLE
14957: LD_INT 0
14959: PPUSH
14960: PPUSH
// begin time := 0 0$20 ;
14961: LD_ADDR_VAR 0 2
14965: PUSH
14966: LD_INT 700
14968: ST_TO_ADDR
// while game do
14969: LD_EXP 2
14973: IFFALSE 15076
// begin wait ( time ) ;
14975: LD_VAR 0 2
14979: PPUSH
14980: CALL_OW 67
// if tick > 2 2$00 then
14984: LD_OWVAR 1
14988: PUSH
14989: LD_INT 4200
14991: GREATER
14992: IFFALSE 15029
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14994: LD_ADDR_VAR 0 2
14998: PUSH
14999: LD_VAR 0 2
15003: PUSH
15004: LD_INT 140
15006: PUSH
15007: LD_INT 140
15009: PUSH
15010: LD_INT 210
15012: PUSH
15013: LD_INT 280
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: PUSH
15022: LD_OWVAR 67
15026: ARRAY
15027: PLUS
15028: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15029: LD_INT 1
15031: PPUSH
15032: LD_INT 5
15034: PPUSH
15035: CALL_OW 12
15039: PPUSH
15040: LD_INT 70
15042: PPUSH
15043: LD_INT 49
15045: PPUSH
15046: LD_INT 25
15048: PPUSH
15049: LD_INT 1
15051: PPUSH
15052: CALL_OW 56
// if time > 3 3$00 then
15056: LD_VAR 0 2
15060: PUSH
15061: LD_INT 6300
15063: GREATER
15064: IFFALSE 15074
// time := 0 0$30 ;
15066: LD_ADDR_VAR 0 2
15070: PUSH
15071: LD_INT 1050
15073: ST_TO_ADDR
// end ;
15074: GO 14969
// end ;
15076: PPOPN 2
15078: END
// every 0 0$30 do var cr , time ;
15079: GO 15081
15081: DISABLE
15082: LD_INT 0
15084: PPUSH
15085: PPUSH
// begin time := 0 0$20 ;
15086: LD_ADDR_VAR 0 2
15090: PUSH
15091: LD_INT 700
15093: ST_TO_ADDR
// while game do
15094: LD_EXP 2
15098: IFFALSE 15191
// begin wait ( time ) ;
15100: LD_VAR 0 2
15104: PPUSH
15105: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15109: LD_ADDR_VAR 0 2
15113: PUSH
15114: LD_VAR 0 2
15118: PUSH
15119: LD_INT 140
15121: PUSH
15122: LD_INT 175
15124: PUSH
15125: LD_INT 210
15127: PUSH
15128: LD_INT 280
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: PUSH
15137: LD_OWVAR 67
15141: ARRAY
15142: PLUS
15143: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
15144: LD_INT 3
15146: PPUSH
15147: LD_INT 5
15149: PPUSH
15150: CALL_OW 12
15154: PPUSH
15155: LD_INT 26
15157: PPUSH
15158: LD_INT 9
15160: PPUSH
15161: LD_INT 30
15163: PPUSH
15164: LD_INT 1
15166: PPUSH
15167: CALL_OW 56
// if time > 3 3$00 then
15171: LD_VAR 0 2
15175: PUSH
15176: LD_INT 6300
15178: GREATER
15179: IFFALSE 15189
// time := 0 0$20 ;
15181: LD_ADDR_VAR 0 2
15185: PUSH
15186: LD_INT 700
15188: ST_TO_ADDR
// end ;
15189: GO 15094
// end ;
15191: PPOPN 2
15193: END
// every 0 0$30 do var cr , time ;
15194: GO 15196
15196: DISABLE
15197: LD_INT 0
15199: PPUSH
15200: PPUSH
// begin time := 0 0$20 ;
15201: LD_ADDR_VAR 0 2
15205: PUSH
15206: LD_INT 700
15208: ST_TO_ADDR
// while game do
15209: LD_EXP 2
15213: IFFALSE 15342
// begin wait ( time ) ;
15215: LD_VAR 0 2
15219: PPUSH
15220: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
15224: LD_ADDR_VAR 0 2
15228: PUSH
15229: LD_VAR 0 2
15233: PUSH
15234: LD_INT 175
15236: PUSH
15237: LD_INT 210
15239: PUSH
15240: LD_INT 280
15242: PUSH
15243: LD_INT 350
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: PUSH
15252: LD_OWVAR 67
15256: ARRAY
15257: PLUS
15258: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
15259: LD_INT 1
15261: PPUSH
15262: LD_INT 5
15264: PPUSH
15265: CALL_OW 12
15269: PPUSH
15270: LD_INT 179
15272: PPUSH
15273: LD_INT 101
15275: PPUSH
15276: LD_INT 20
15278: PPUSH
15279: LD_INT 1
15281: PPUSH
15282: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
15286: LD_INT 350
15288: PPUSH
15289: LD_INT 525
15291: PPUSH
15292: CALL_OW 12
15296: PPUSH
15297: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
15301: LD_INT 1
15303: PPUSH
15304: LD_INT 5
15306: PPUSH
15307: CALL_OW 12
15311: PPUSH
15312: LD_INT 9
15314: PPUSH
15315: LD_INT 1
15317: PPUSH
15318: CALL_OW 55
// if time > 4 4$00 then
15322: LD_VAR 0 2
15326: PUSH
15327: LD_INT 8400
15329: GREATER
15330: IFFALSE 15340
// time := 0 0$30 ;
15332: LD_ADDR_VAR 0 2
15336: PUSH
15337: LD_INT 1050
15339: ST_TO_ADDR
// end ;
15340: GO 15209
// end ;
15342: PPOPN 2
15344: END
// every 0 0$30 do var cr , time ;
15345: GO 15347
15347: DISABLE
15348: LD_INT 0
15350: PPUSH
15351: PPUSH
// begin time := 0 0$10 ;
15352: LD_ADDR_VAR 0 2
15356: PUSH
15357: LD_INT 350
15359: ST_TO_ADDR
// while game do
15360: LD_EXP 2
15364: IFFALSE 15498
// begin wait ( time ) ;
15366: LD_VAR 0 2
15370: PPUSH
15371: CALL_OW 67
// time := time + 0 0$10 ;
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 2
15384: PUSH
15385: LD_INT 350
15387: PLUS
15388: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
15389: LD_INT 1
15391: PPUSH
15392: LD_INT 5
15394: PPUSH
15395: CALL_OW 12
15399: PPUSH
15400: LD_INT 11
15402: PPUSH
15403: LD_INT 1
15405: PPUSH
15406: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
15410: LD_ADDR_VAR 0 1
15414: PUSH
15415: LD_INT 1
15417: PPUSH
15418: LD_INT 3
15420: PPUSH
15421: CALL_OW 12
15425: ST_TO_ADDR
// if cr = 1 then
15426: LD_VAR 0 1
15430: PUSH
15431: LD_INT 1
15433: EQUAL
15434: IFFALSE 15478
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
15436: LD_INT 700
15438: PPUSH
15439: LD_INT 1575
15441: PPUSH
15442: CALL_OW 12
15446: PPUSH
15447: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
15451: LD_INT 1
15453: PPUSH
15454: LD_INT 5
15456: PPUSH
15457: CALL_OW 12
15461: PPUSH
15462: LD_INT 34
15464: PPUSH
15465: LD_INT 50
15467: PPUSH
15468: LD_INT 7
15470: PPUSH
15471: LD_INT 1
15473: PPUSH
15474: CALL_OW 56
// end ; if time > 4 4$00 then
15478: LD_VAR 0 2
15482: PUSH
15483: LD_INT 8400
15485: GREATER
15486: IFFALSE 15496
// time := 0 0$40 ;
15488: LD_ADDR_VAR 0 2
15492: PUSH
15493: LD_INT 1400
15495: ST_TO_ADDR
// end ;
15496: GO 15360
// end ; end_of_file
15498: PPOPN 2
15500: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
15501: LD_INT 0
15503: PPUSH
15504: PPUSH
// if exist_mode then
15505: LD_VAR 0 2
15509: IFFALSE 15534
// unit := CreateCharacter ( prefix & ident ) else
15511: LD_ADDR_VAR 0 5
15515: PUSH
15516: LD_VAR 0 3
15520: PUSH
15521: LD_VAR 0 1
15525: STR
15526: PPUSH
15527: CALL_OW 34
15531: ST_TO_ADDR
15532: GO 15549
// unit := NewCharacter ( ident ) ;
15534: LD_ADDR_VAR 0 5
15538: PUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 25
15548: ST_TO_ADDR
// result := unit ;
15549: LD_ADDR_VAR 0 4
15553: PUSH
15554: LD_VAR 0 5
15558: ST_TO_ADDR
// end ;
15559: LD_VAR 0 4
15563: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
15564: LD_INT 0
15566: PPUSH
15567: PPUSH
// if not side or not nation then
15568: LD_VAR 0 1
15572: NOT
15573: PUSH
15574: LD_VAR 0 2
15578: NOT
15579: OR
15580: IFFALSE 15584
// exit ;
15582: GO 16352
// case nation of nation_american :
15584: LD_VAR 0 2
15588: PUSH
15589: LD_INT 1
15591: DOUBLE
15592: EQUAL
15593: IFTRUE 15597
15595: GO 15811
15597: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15598: LD_ADDR_VAR 0 4
15602: PUSH
15603: LD_INT 35
15605: PUSH
15606: LD_INT 45
15608: PUSH
15609: LD_INT 46
15611: PUSH
15612: LD_INT 47
15614: PUSH
15615: LD_INT 82
15617: PUSH
15618: LD_INT 83
15620: PUSH
15621: LD_INT 84
15623: PUSH
15624: LD_INT 85
15626: PUSH
15627: LD_INT 86
15629: PUSH
15630: LD_INT 1
15632: PUSH
15633: LD_INT 2
15635: PUSH
15636: LD_INT 6
15638: PUSH
15639: LD_INT 15
15641: PUSH
15642: LD_INT 16
15644: PUSH
15645: LD_INT 7
15647: PUSH
15648: LD_INT 12
15650: PUSH
15651: LD_INT 13
15653: PUSH
15654: LD_INT 10
15656: PUSH
15657: LD_INT 14
15659: PUSH
15660: LD_INT 20
15662: PUSH
15663: LD_INT 21
15665: PUSH
15666: LD_INT 22
15668: PUSH
15669: LD_INT 25
15671: PUSH
15672: LD_INT 32
15674: PUSH
15675: LD_INT 27
15677: PUSH
15678: LD_INT 36
15680: PUSH
15681: LD_INT 69
15683: PUSH
15684: LD_INT 39
15686: PUSH
15687: LD_INT 34
15689: PUSH
15690: LD_INT 40
15692: PUSH
15693: LD_INT 48
15695: PUSH
15696: LD_INT 49
15698: PUSH
15699: LD_INT 50
15701: PUSH
15702: LD_INT 51
15704: PUSH
15705: LD_INT 52
15707: PUSH
15708: LD_INT 53
15710: PUSH
15711: LD_INT 54
15713: PUSH
15714: LD_INT 55
15716: PUSH
15717: LD_INT 56
15719: PUSH
15720: LD_INT 57
15722: PUSH
15723: LD_INT 58
15725: PUSH
15726: LD_INT 59
15728: PUSH
15729: LD_INT 60
15731: PUSH
15732: LD_INT 61
15734: PUSH
15735: LD_INT 62
15737: PUSH
15738: LD_INT 80
15740: PUSH
15741: LD_INT 82
15743: PUSH
15744: LD_INT 83
15746: PUSH
15747: LD_INT 84
15749: PUSH
15750: LD_INT 85
15752: PUSH
15753: LD_INT 86
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: LIST
15763: LIST
15764: LIST
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: LIST
15782: LIST
15783: LIST
15784: LIST
15785: LIST
15786: LIST
15787: LIST
15788: LIST
15789: LIST
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: LIST
15795: LIST
15796: LIST
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: LIST
15802: LIST
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: ST_TO_ADDR
15809: GO 16276
15811: LD_INT 2
15813: DOUBLE
15814: EQUAL
15815: IFTRUE 15819
15817: GO 16045
15819: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15820: LD_ADDR_VAR 0 4
15824: PUSH
15825: LD_INT 35
15827: PUSH
15828: LD_INT 45
15830: PUSH
15831: LD_INT 46
15833: PUSH
15834: LD_INT 47
15836: PUSH
15837: LD_INT 82
15839: PUSH
15840: LD_INT 83
15842: PUSH
15843: LD_INT 84
15845: PUSH
15846: LD_INT 85
15848: PUSH
15849: LD_INT 87
15851: PUSH
15852: LD_INT 70
15854: PUSH
15855: LD_INT 1
15857: PUSH
15858: LD_INT 11
15860: PUSH
15861: LD_INT 3
15863: PUSH
15864: LD_INT 4
15866: PUSH
15867: LD_INT 5
15869: PUSH
15870: LD_INT 6
15872: PUSH
15873: LD_INT 15
15875: PUSH
15876: LD_INT 18
15878: PUSH
15879: LD_INT 7
15881: PUSH
15882: LD_INT 17
15884: PUSH
15885: LD_INT 8
15887: PUSH
15888: LD_INT 20
15890: PUSH
15891: LD_INT 21
15893: PUSH
15894: LD_INT 22
15896: PUSH
15897: LD_INT 72
15899: PUSH
15900: LD_INT 26
15902: PUSH
15903: LD_INT 69
15905: PUSH
15906: LD_INT 39
15908: PUSH
15909: LD_INT 40
15911: PUSH
15912: LD_INT 41
15914: PUSH
15915: LD_INT 42
15917: PUSH
15918: LD_INT 43
15920: PUSH
15921: LD_INT 48
15923: PUSH
15924: LD_INT 49
15926: PUSH
15927: LD_INT 50
15929: PUSH
15930: LD_INT 51
15932: PUSH
15933: LD_INT 52
15935: PUSH
15936: LD_INT 53
15938: PUSH
15939: LD_INT 54
15941: PUSH
15942: LD_INT 55
15944: PUSH
15945: LD_INT 56
15947: PUSH
15948: LD_INT 60
15950: PUSH
15951: LD_INT 61
15953: PUSH
15954: LD_INT 62
15956: PUSH
15957: LD_INT 66
15959: PUSH
15960: LD_INT 67
15962: PUSH
15963: LD_INT 68
15965: PUSH
15966: LD_INT 81
15968: PUSH
15969: LD_INT 82
15971: PUSH
15972: LD_INT 83
15974: PUSH
15975: LD_INT 84
15977: PUSH
15978: LD_INT 85
15980: PUSH
15981: LD_INT 87
15983: PUSH
15984: LD_INT 88
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: LIST
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: LIST
16008: LIST
16009: LIST
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: LIST
16015: LIST
16016: LIST
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: LIST
16027: LIST
16028: LIST
16029: LIST
16030: LIST
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
16043: GO 16276
16045: LD_INT 3
16047: DOUBLE
16048: EQUAL
16049: IFTRUE 16053
16051: GO 16275
16053: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16054: LD_ADDR_VAR 0 4
16058: PUSH
16059: LD_INT 46
16061: PUSH
16062: LD_INT 47
16064: PUSH
16065: LD_INT 1
16067: PUSH
16068: LD_INT 2
16070: PUSH
16071: LD_INT 82
16073: PUSH
16074: LD_INT 83
16076: PUSH
16077: LD_INT 84
16079: PUSH
16080: LD_INT 85
16082: PUSH
16083: LD_INT 86
16085: PUSH
16086: LD_INT 11
16088: PUSH
16089: LD_INT 9
16091: PUSH
16092: LD_INT 20
16094: PUSH
16095: LD_INT 19
16097: PUSH
16098: LD_INT 21
16100: PUSH
16101: LD_INT 24
16103: PUSH
16104: LD_INT 22
16106: PUSH
16107: LD_INT 25
16109: PUSH
16110: LD_INT 28
16112: PUSH
16113: LD_INT 29
16115: PUSH
16116: LD_INT 30
16118: PUSH
16119: LD_INT 31
16121: PUSH
16122: LD_INT 37
16124: PUSH
16125: LD_INT 38
16127: PUSH
16128: LD_INT 32
16130: PUSH
16131: LD_INT 27
16133: PUSH
16134: LD_INT 33
16136: PUSH
16137: LD_INT 69
16139: PUSH
16140: LD_INT 39
16142: PUSH
16143: LD_INT 34
16145: PUSH
16146: LD_INT 40
16148: PUSH
16149: LD_INT 71
16151: PUSH
16152: LD_INT 23
16154: PUSH
16155: LD_INT 44
16157: PUSH
16158: LD_INT 48
16160: PUSH
16161: LD_INT 49
16163: PUSH
16164: LD_INT 50
16166: PUSH
16167: LD_INT 51
16169: PUSH
16170: LD_INT 52
16172: PUSH
16173: LD_INT 53
16175: PUSH
16176: LD_INT 54
16178: PUSH
16179: LD_INT 55
16181: PUSH
16182: LD_INT 56
16184: PUSH
16185: LD_INT 57
16187: PUSH
16188: LD_INT 58
16190: PUSH
16191: LD_INT 59
16193: PUSH
16194: LD_INT 63
16196: PUSH
16197: LD_INT 64
16199: PUSH
16200: LD_INT 65
16202: PUSH
16203: LD_INT 82
16205: PUSH
16206: LD_INT 83
16208: PUSH
16209: LD_INT 84
16211: PUSH
16212: LD_INT 85
16214: PUSH
16215: LD_INT 86
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: LIST
16230: LIST
16231: LIST
16232: LIST
16233: LIST
16234: LIST
16235: LIST
16236: LIST
16237: LIST
16238: LIST
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: LIST
16251: LIST
16252: LIST
16253: LIST
16254: LIST
16255: LIST
16256: LIST
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: LIST
16262: LIST
16263: LIST
16264: LIST
16265: LIST
16266: LIST
16267: LIST
16268: LIST
16269: LIST
16270: LIST
16271: LIST
16272: ST_TO_ADDR
16273: GO 16276
16275: POP
// if state > - 1 and state < 3 then
16276: LD_VAR 0 3
16280: PUSH
16281: LD_INT 1
16283: NEG
16284: GREATER
16285: PUSH
16286: LD_VAR 0 3
16290: PUSH
16291: LD_INT 3
16293: LESS
16294: AND
16295: IFFALSE 16352
// for i in result do
16297: LD_ADDR_VAR 0 5
16301: PUSH
16302: LD_VAR 0 4
16306: PUSH
16307: FOR_IN
16308: IFFALSE 16350
// if GetTech ( i , side ) <> state then
16310: LD_VAR 0 5
16314: PPUSH
16315: LD_VAR 0 1
16319: PPUSH
16320: CALL_OW 321
16324: PUSH
16325: LD_VAR 0 3
16329: NONEQUAL
16330: IFFALSE 16348
// result := result diff i ;
16332: LD_ADDR_VAR 0 4
16336: PUSH
16337: LD_VAR 0 4
16341: PUSH
16342: LD_VAR 0 5
16346: DIFF
16347: ST_TO_ADDR
16348: GO 16307
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 4
16356: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
// result := true ;
16362: LD_ADDR_VAR 0 3
16366: PUSH
16367: LD_INT 1
16369: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
16370: LD_ADDR_VAR 0 5
16374: PUSH
16375: LD_VAR 0 2
16379: PPUSH
16380: CALL_OW 480
16384: ST_TO_ADDR
// if not tmp then
16385: LD_VAR 0 5
16389: NOT
16390: IFFALSE 16394
// exit ;
16392: GO 16443
// for i in tmp do
16394: LD_ADDR_VAR 0 4
16398: PUSH
16399: LD_VAR 0 5
16403: PUSH
16404: FOR_IN
16405: IFFALSE 16441
// if GetTech ( i , side ) <> state_researched then
16407: LD_VAR 0 4
16411: PPUSH
16412: LD_VAR 0 1
16416: PPUSH
16417: CALL_OW 321
16421: PUSH
16422: LD_INT 2
16424: NONEQUAL
16425: IFFALSE 16439
// begin result := false ;
16427: LD_ADDR_VAR 0 3
16431: PUSH
16432: LD_INT 0
16434: ST_TO_ADDR
// exit ;
16435: POP
16436: POP
16437: GO 16443
// end ;
16439: GO 16404
16441: POP
16442: POP
// end ;
16443: LD_VAR 0 3
16447: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
16448: LD_INT 0
16450: PPUSH
16451: PPUSH
16452: PPUSH
16453: PPUSH
16454: PPUSH
16455: PPUSH
16456: PPUSH
16457: PPUSH
16458: PPUSH
16459: PPUSH
16460: PPUSH
16461: PPUSH
16462: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
16463: LD_VAR 0 1
16467: NOT
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 257
16478: PUSH
16479: LD_INT 9
16481: NONEQUAL
16482: OR
16483: IFFALSE 16487
// exit ;
16485: GO 17060
// side := GetSide ( unit ) ;
16487: LD_ADDR_VAR 0 9
16491: PUSH
16492: LD_VAR 0 1
16496: PPUSH
16497: CALL_OW 255
16501: ST_TO_ADDR
// tech_space := tech_spacanom ;
16502: LD_ADDR_VAR 0 12
16506: PUSH
16507: LD_INT 29
16509: ST_TO_ADDR
// tech_time := tech_taurad ;
16510: LD_ADDR_VAR 0 13
16514: PUSH
16515: LD_INT 28
16517: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
16518: LD_ADDR_VAR 0 11
16522: PUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: CALL_OW 310
16532: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
16533: LD_VAR 0 11
16537: PPUSH
16538: CALL_OW 247
16542: PUSH
16543: LD_INT 2
16545: EQUAL
16546: IFFALSE 16550
// exit ;
16548: GO 17060
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16550: LD_ADDR_VAR 0 8
16554: PUSH
16555: LD_INT 81
16557: PUSH
16558: LD_VAR 0 9
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_INT 3
16569: PUSH
16570: LD_INT 21
16572: PUSH
16573: LD_INT 3
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PPUSH
16588: CALL_OW 69
16592: ST_TO_ADDR
// if not tmp then
16593: LD_VAR 0 8
16597: NOT
16598: IFFALSE 16602
// exit ;
16600: GO 17060
// if in_unit then
16602: LD_VAR 0 11
16606: IFFALSE 16630
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16608: LD_ADDR_VAR 0 10
16612: PUSH
16613: LD_VAR 0 8
16617: PPUSH
16618: LD_VAR 0 11
16622: PPUSH
16623: CALL_OW 74
16627: ST_TO_ADDR
16628: GO 16650
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16630: LD_ADDR_VAR 0 10
16634: PUSH
16635: LD_VAR 0 8
16639: PPUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: CALL_OW 74
16649: ST_TO_ADDR
// if not enemy then
16650: LD_VAR 0 10
16654: NOT
16655: IFFALSE 16659
// exit ;
16657: GO 17060
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16659: LD_VAR 0 11
16663: PUSH
16664: LD_VAR 0 11
16668: PPUSH
16669: LD_VAR 0 10
16673: PPUSH
16674: CALL_OW 296
16678: PUSH
16679: LD_INT 13
16681: GREATER
16682: AND
16683: PUSH
16684: LD_VAR 0 1
16688: PPUSH
16689: LD_VAR 0 10
16693: PPUSH
16694: CALL_OW 296
16698: PUSH
16699: LD_INT 12
16701: GREATER
16702: OR
16703: IFFALSE 16707
// exit ;
16705: GO 17060
// missile := [ 1 ] ;
16707: LD_ADDR_VAR 0 14
16711: PUSH
16712: LD_INT 1
16714: PUSH
16715: EMPTY
16716: LIST
16717: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16718: LD_VAR 0 9
16722: PPUSH
16723: LD_VAR 0 12
16727: PPUSH
16728: CALL_OW 325
16732: IFFALSE 16761
// missile := Replace ( missile , missile + 1 , 2 ) ;
16734: LD_ADDR_VAR 0 14
16738: PUSH
16739: LD_VAR 0 14
16743: PPUSH
16744: LD_VAR 0 14
16748: PUSH
16749: LD_INT 1
16751: PLUS
16752: PPUSH
16753: LD_INT 2
16755: PPUSH
16756: CALL_OW 1
16760: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16761: LD_VAR 0 9
16765: PPUSH
16766: LD_VAR 0 13
16770: PPUSH
16771: CALL_OW 325
16775: PUSH
16776: LD_VAR 0 10
16780: PPUSH
16781: CALL_OW 255
16785: PPUSH
16786: LD_VAR 0 13
16790: PPUSH
16791: CALL_OW 325
16795: NOT
16796: AND
16797: IFFALSE 16826
// missile := Replace ( missile , missile + 1 , 3 ) ;
16799: LD_ADDR_VAR 0 14
16803: PUSH
16804: LD_VAR 0 14
16808: PPUSH
16809: LD_VAR 0 14
16813: PUSH
16814: LD_INT 1
16816: PLUS
16817: PPUSH
16818: LD_INT 3
16820: PPUSH
16821: CALL_OW 1
16825: ST_TO_ADDR
// if missile < 2 then
16826: LD_VAR 0 14
16830: PUSH
16831: LD_INT 2
16833: LESS
16834: IFFALSE 16838
// exit ;
16836: GO 17060
// x := GetX ( enemy ) ;
16838: LD_ADDR_VAR 0 4
16842: PUSH
16843: LD_VAR 0 10
16847: PPUSH
16848: CALL_OW 250
16852: ST_TO_ADDR
// y := GetY ( enemy ) ;
16853: LD_ADDR_VAR 0 5
16857: PUSH
16858: LD_VAR 0 10
16862: PPUSH
16863: CALL_OW 251
16867: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16868: LD_ADDR_VAR 0 6
16872: PUSH
16873: LD_VAR 0 4
16877: PUSH
16878: LD_INT 1
16880: NEG
16881: PPUSH
16882: LD_INT 1
16884: PPUSH
16885: CALL_OW 12
16889: PLUS
16890: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16891: LD_ADDR_VAR 0 7
16895: PUSH
16896: LD_VAR 0 5
16900: PUSH
16901: LD_INT 1
16903: NEG
16904: PPUSH
16905: LD_INT 1
16907: PPUSH
16908: CALL_OW 12
16912: PLUS
16913: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16914: LD_VAR 0 6
16918: PPUSH
16919: LD_VAR 0 7
16923: PPUSH
16924: CALL_OW 488
16928: NOT
16929: IFFALSE 16951
// begin _x := x ;
16931: LD_ADDR_VAR 0 6
16935: PUSH
16936: LD_VAR 0 4
16940: ST_TO_ADDR
// _y := y ;
16941: LD_ADDR_VAR 0 7
16945: PUSH
16946: LD_VAR 0 5
16950: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16951: LD_ADDR_VAR 0 3
16955: PUSH
16956: LD_INT 1
16958: PPUSH
16959: LD_VAR 0 14
16963: PPUSH
16964: CALL_OW 12
16968: ST_TO_ADDR
// case i of 1 :
16969: LD_VAR 0 3
16973: PUSH
16974: LD_INT 1
16976: DOUBLE
16977: EQUAL
16978: IFTRUE 16982
16980: GO 16999
16982: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16983: LD_VAR 0 1
16987: PPUSH
16988: LD_VAR 0 10
16992: PPUSH
16993: CALL_OW 115
16997: GO 17060
16999: LD_INT 2
17001: DOUBLE
17002: EQUAL
17003: IFTRUE 17007
17005: GO 17029
17007: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17008: LD_VAR 0 1
17012: PPUSH
17013: LD_VAR 0 6
17017: PPUSH
17018: LD_VAR 0 7
17022: PPUSH
17023: CALL_OW 153
17027: GO 17060
17029: LD_INT 3
17031: DOUBLE
17032: EQUAL
17033: IFTRUE 17037
17035: GO 17059
17037: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17038: LD_VAR 0 1
17042: PPUSH
17043: LD_VAR 0 6
17047: PPUSH
17048: LD_VAR 0 7
17052: PPUSH
17053: CALL_OW 154
17057: GO 17060
17059: POP
// end ;
17060: LD_VAR 0 2
17064: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17065: LD_INT 0
17067: PPUSH
17068: PPUSH
17069: PPUSH
17070: PPUSH
17071: PPUSH
17072: PPUSH
// if not unit or not building then
17073: LD_VAR 0 1
17077: NOT
17078: PUSH
17079: LD_VAR 0 2
17083: NOT
17084: OR
17085: IFFALSE 17089
// exit ;
17087: GO 17247
// x := GetX ( building ) ;
17089: LD_ADDR_VAR 0 5
17093: PUSH
17094: LD_VAR 0 2
17098: PPUSH
17099: CALL_OW 250
17103: ST_TO_ADDR
// y := GetY ( building ) ;
17104: LD_ADDR_VAR 0 6
17108: PUSH
17109: LD_VAR 0 2
17113: PPUSH
17114: CALL_OW 251
17118: ST_TO_ADDR
// for i = 0 to 5 do
17119: LD_ADDR_VAR 0 4
17123: PUSH
17124: DOUBLE
17125: LD_INT 0
17127: DEC
17128: ST_TO_ADDR
17129: LD_INT 5
17131: PUSH
17132: FOR_TO
17133: IFFALSE 17245
// begin _x := ShiftX ( x , i , 3 ) ;
17135: LD_ADDR_VAR 0 7
17139: PUSH
17140: LD_VAR 0 5
17144: PPUSH
17145: LD_VAR 0 4
17149: PPUSH
17150: LD_INT 3
17152: PPUSH
17153: CALL_OW 272
17157: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
17158: LD_ADDR_VAR 0 8
17162: PUSH
17163: LD_VAR 0 6
17167: PPUSH
17168: LD_VAR 0 4
17172: PPUSH
17173: LD_INT 3
17175: PPUSH
17176: CALL_OW 273
17180: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17181: LD_VAR 0 7
17185: PPUSH
17186: LD_VAR 0 8
17190: PPUSH
17191: CALL_OW 488
17195: NOT
17196: IFFALSE 17200
// continue ;
17198: GO 17132
// if HexInfo ( _x , _y ) = 0 then
17200: LD_VAR 0 7
17204: PPUSH
17205: LD_VAR 0 8
17209: PPUSH
17210: CALL_OW 428
17214: PUSH
17215: LD_INT 0
17217: EQUAL
17218: IFFALSE 17243
// begin ComMoveXY ( unit , _x , _y ) ;
17220: LD_VAR 0 1
17224: PPUSH
17225: LD_VAR 0 7
17229: PPUSH
17230: LD_VAR 0 8
17234: PPUSH
17235: CALL_OW 111
// exit ;
17239: POP
17240: POP
17241: GO 17247
// end ; end ;
17243: GO 17132
17245: POP
17246: POP
// end ;
17247: LD_VAR 0 3
17251: RET
// export function ScanBase ( side , base_area ) ; begin
17252: LD_INT 0
17254: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
17255: LD_ADDR_VAR 0 3
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_INT 81
17267: PUSH
17268: LD_VAR 0 1
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PPUSH
17277: CALL_OW 70
17281: ST_TO_ADDR
// end ;
17282: LD_VAR 0 3
17286: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17287: LD_INT 0
17289: PPUSH
17290: PPUSH
17291: PPUSH
17292: PPUSH
// result := false ;
17293: LD_ADDR_VAR 0 2
17297: PUSH
17298: LD_INT 0
17300: ST_TO_ADDR
// side := GetSide ( unit ) ;
17301: LD_ADDR_VAR 0 3
17305: PUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 255
17315: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17316: LD_ADDR_VAR 0 4
17320: PUSH
17321: LD_VAR 0 1
17325: PPUSH
17326: CALL_OW 248
17330: ST_TO_ADDR
// case nat of 1 :
17331: LD_VAR 0 4
17335: PUSH
17336: LD_INT 1
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17355
17344: POP
// tech := tech_lassight ; 2 :
17345: LD_ADDR_VAR 0 5
17349: PUSH
17350: LD_INT 12
17352: ST_TO_ADDR
17353: GO 17394
17355: LD_INT 2
17357: DOUBLE
17358: EQUAL
17359: IFTRUE 17363
17361: GO 17374
17363: POP
// tech := tech_mortar ; 3 :
17364: LD_ADDR_VAR 0 5
17368: PUSH
17369: LD_INT 41
17371: ST_TO_ADDR
17372: GO 17394
17374: LD_INT 3
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 17393
17382: POP
// tech := tech_bazooka ; end ;
17383: LD_ADDR_VAR 0 5
17387: PUSH
17388: LD_INT 44
17390: ST_TO_ADDR
17391: GO 17394
17393: POP
// if Researched ( side , tech ) then
17394: LD_VAR 0 3
17398: PPUSH
17399: LD_VAR 0 5
17403: PPUSH
17404: CALL_OW 325
17408: IFFALSE 17435
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17410: LD_ADDR_VAR 0 2
17414: PUSH
17415: LD_INT 5
17417: PUSH
17418: LD_INT 8
17420: PUSH
17421: LD_INT 9
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: LIST
17428: PUSH
17429: LD_VAR 0 4
17433: ARRAY
17434: ST_TO_ADDR
// end ;
17435: LD_VAR 0 2
17439: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
17444: PPUSH
// if not mines then
17445: LD_VAR 0 2
17449: NOT
17450: IFFALSE 17454
// exit ;
17452: GO 17598
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17454: LD_ADDR_VAR 0 5
17458: PUSH
17459: LD_INT 81
17461: PUSH
17462: LD_VAR 0 1
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: PUSH
17471: LD_INT 3
17473: PUSH
17474: LD_INT 21
17476: PUSH
17477: LD_INT 3
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: CALL_OW 69
17496: ST_TO_ADDR
// for i in mines do
17497: LD_ADDR_VAR 0 4
17501: PUSH
17502: LD_VAR 0 2
17506: PUSH
17507: FOR_IN
17508: IFFALSE 17596
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17510: LD_VAR 0 4
17514: PUSH
17515: LD_INT 1
17517: ARRAY
17518: PPUSH
17519: LD_VAR 0 4
17523: PUSH
17524: LD_INT 2
17526: ARRAY
17527: PPUSH
17528: CALL_OW 458
17532: NOT
17533: IFFALSE 17537
// continue ;
17535: GO 17507
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17537: LD_VAR 0 4
17541: PUSH
17542: LD_INT 1
17544: ARRAY
17545: PPUSH
17546: LD_VAR 0 4
17550: PUSH
17551: LD_INT 2
17553: ARRAY
17554: PPUSH
17555: CALL_OW 428
17559: PUSH
17560: LD_VAR 0 5
17564: IN
17565: IFFALSE 17594
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17567: LD_VAR 0 4
17571: PUSH
17572: LD_INT 1
17574: ARRAY
17575: PPUSH
17576: LD_VAR 0 4
17580: PUSH
17581: LD_INT 2
17583: ARRAY
17584: PPUSH
17585: LD_VAR 0 1
17589: PPUSH
17590: CALL_OW 456
// end ;
17594: GO 17507
17596: POP
17597: POP
// end ;
17598: LD_VAR 0 3
17602: RET
// export function Count ( array ) ; begin
17603: LD_INT 0
17605: PPUSH
// result := array + 0 ;
17606: LD_ADDR_VAR 0 2
17610: PUSH
17611: LD_VAR 0 1
17615: PUSH
17616: LD_INT 0
17618: PLUS
17619: ST_TO_ADDR
// end ;
17620: LD_VAR 0 2
17624: RET
// export function IsEmpty ( building ) ; begin
17625: LD_INT 0
17627: PPUSH
// if not building then
17628: LD_VAR 0 1
17632: NOT
17633: IFFALSE 17637
// exit ;
17635: GO 17680
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17637: LD_ADDR_VAR 0 2
17641: PUSH
17642: LD_VAR 0 1
17646: PUSH
17647: LD_INT 22
17649: PUSH
17650: LD_VAR 0 1
17654: PPUSH
17655: CALL_OW 255
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: LD_INT 58
17666: PUSH
17667: EMPTY
17668: LIST
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PPUSH
17674: CALL_OW 69
17678: IN
17679: ST_TO_ADDR
// end ;
17680: LD_VAR 0 2
17684: RET
// export function IsNotFull ( building ) ; var places ; begin
17685: LD_INT 0
17687: PPUSH
17688: PPUSH
// if not building then
17689: LD_VAR 0 1
17693: NOT
17694: IFFALSE 17698
// exit ;
17696: GO 17726
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
17698: LD_ADDR_VAR 0 2
17702: PUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: LD_INT 3
17710: PUSH
17711: LD_INT 62
17713: PUSH
17714: EMPTY
17715: LIST
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: PPUSH
17721: CALL_OW 72
17725: ST_TO_ADDR
// end ;
17726: LD_VAR 0 2
17730: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17731: LD_INT 0
17733: PPUSH
17734: PPUSH
17735: PPUSH
17736: PPUSH
// tmp := [ ] ;
17737: LD_ADDR_VAR 0 3
17741: PUSH
17742: EMPTY
17743: ST_TO_ADDR
// list := [ ] ;
17744: LD_ADDR_VAR 0 5
17748: PUSH
17749: EMPTY
17750: ST_TO_ADDR
// for i = 16 to 25 do
17751: LD_ADDR_VAR 0 4
17755: PUSH
17756: DOUBLE
17757: LD_INT 16
17759: DEC
17760: ST_TO_ADDR
17761: LD_INT 25
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17838
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17767: LD_ADDR_VAR 0 3
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 22
17779: PUSH
17780: LD_VAR 0 1
17784: PPUSH
17785: CALL_OW 255
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: PUSH
17794: LD_INT 91
17796: PUSH
17797: LD_VAR 0 1
17801: PUSH
17802: LD_INT 6
17804: PUSH
17805: EMPTY
17806: LIST
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 30
17812: PUSH
17813: LD_VAR 0 4
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: LIST
17826: PUSH
17827: EMPTY
17828: LIST
17829: PPUSH
17830: CALL_OW 69
17834: ADD
17835: ST_TO_ADDR
17836: GO 17764
17838: POP
17839: POP
// for i = 1 to tmp do
17840: LD_ADDR_VAR 0 4
17844: PUSH
17845: DOUBLE
17846: LD_INT 1
17848: DEC
17849: ST_TO_ADDR
17850: LD_VAR 0 3
17854: PUSH
17855: FOR_TO
17856: IFFALSE 17944
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17858: LD_ADDR_VAR 0 5
17862: PUSH
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 3
17872: PUSH
17873: LD_VAR 0 4
17877: ARRAY
17878: PPUSH
17879: CALL_OW 266
17883: PUSH
17884: LD_VAR 0 3
17888: PUSH
17889: LD_VAR 0 4
17893: ARRAY
17894: PPUSH
17895: CALL_OW 250
17899: PUSH
17900: LD_VAR 0 3
17904: PUSH
17905: LD_VAR 0 4
17909: ARRAY
17910: PPUSH
17911: CALL_OW 251
17915: PUSH
17916: LD_VAR 0 3
17920: PUSH
17921: LD_VAR 0 4
17925: ARRAY
17926: PPUSH
17927: CALL_OW 254
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: PUSH
17938: EMPTY
17939: LIST
17940: ADD
17941: ST_TO_ADDR
17942: GO 17855
17944: POP
17945: POP
// result := list ;
17946: LD_ADDR_VAR 0 2
17950: PUSH
17951: LD_VAR 0 5
17955: ST_TO_ADDR
// end ;
17956: LD_VAR 0 2
17960: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17961: LD_INT 0
17963: PPUSH
17964: PPUSH
17965: PPUSH
17966: PPUSH
17967: PPUSH
17968: PPUSH
17969: PPUSH
// if not factory then
17970: LD_VAR 0 1
17974: NOT
17975: IFFALSE 17979
// exit ;
17977: GO 18572
// if control = control_apeman then
17979: LD_VAR 0 4
17983: PUSH
17984: LD_INT 5
17986: EQUAL
17987: IFFALSE 18096
// begin tmp := UnitsInside ( factory ) ;
17989: LD_ADDR_VAR 0 8
17993: PUSH
17994: LD_VAR 0 1
17998: PPUSH
17999: CALL_OW 313
18003: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18004: LD_VAR 0 8
18008: PPUSH
18009: LD_INT 25
18011: PUSH
18012: LD_INT 12
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL_OW 72
18023: NOT
18024: IFFALSE 18034
// control := control_manual ;
18026: LD_ADDR_VAR 0 4
18030: PUSH
18031: LD_INT 1
18033: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18034: LD_ADDR_VAR 0 8
18038: PUSH
18039: LD_VAR 0 1
18043: PPUSH
18044: CALL 17731 0 1
18048: ST_TO_ADDR
// if tmp then
18049: LD_VAR 0 8
18053: IFFALSE 18096
// begin for i in tmp do
18055: LD_ADDR_VAR 0 7
18059: PUSH
18060: LD_VAR 0 8
18064: PUSH
18065: FOR_IN
18066: IFFALSE 18094
// if i [ 1 ] = b_ext_radio then
18068: LD_VAR 0 7
18072: PUSH
18073: LD_INT 1
18075: ARRAY
18076: PUSH
18077: LD_INT 22
18079: EQUAL
18080: IFFALSE 18092
// begin control := control_remote ;
18082: LD_ADDR_VAR 0 4
18086: PUSH
18087: LD_INT 2
18089: ST_TO_ADDR
// break ;
18090: GO 18094
// end ;
18092: GO 18065
18094: POP
18095: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18096: LD_VAR 0 1
18100: PPUSH
18101: LD_VAR 0 2
18105: PPUSH
18106: LD_VAR 0 3
18110: PPUSH
18111: LD_VAR 0 4
18115: PPUSH
18116: LD_VAR 0 5
18120: PPUSH
18121: CALL_OW 448
18125: IFFALSE 18160
// begin result := [ chassis , engine , control , weapon ] ;
18127: LD_ADDR_VAR 0 6
18131: PUSH
18132: LD_VAR 0 2
18136: PUSH
18137: LD_VAR 0 3
18141: PUSH
18142: LD_VAR 0 4
18146: PUSH
18147: LD_VAR 0 5
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: ST_TO_ADDR
// exit ;
18158: GO 18572
// end ; _chassis := AvailableChassisList ( factory ) ;
18160: LD_ADDR_VAR 0 9
18164: PUSH
18165: LD_VAR 0 1
18169: PPUSH
18170: CALL_OW 475
18174: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18175: LD_ADDR_VAR 0 11
18179: PUSH
18180: LD_VAR 0 1
18184: PPUSH
18185: CALL_OW 476
18189: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18190: LD_ADDR_VAR 0 12
18194: PUSH
18195: LD_VAR 0 1
18199: PPUSH
18200: CALL_OW 477
18204: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18205: LD_ADDR_VAR 0 10
18209: PUSH
18210: LD_VAR 0 1
18214: PPUSH
18215: CALL_OW 478
18219: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18220: LD_VAR 0 9
18224: NOT
18225: PUSH
18226: LD_VAR 0 11
18230: NOT
18231: OR
18232: PUSH
18233: LD_VAR 0 12
18237: NOT
18238: OR
18239: PUSH
18240: LD_VAR 0 10
18244: NOT
18245: OR
18246: IFFALSE 18281
// begin result := [ chassis , engine , control , weapon ] ;
18248: LD_ADDR_VAR 0 6
18252: PUSH
18253: LD_VAR 0 2
18257: PUSH
18258: LD_VAR 0 3
18262: PUSH
18263: LD_VAR 0 4
18267: PUSH
18268: LD_VAR 0 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: ST_TO_ADDR
// exit ;
18279: GO 18572
// end ; if not chassis in _chassis then
18281: LD_VAR 0 2
18285: PUSH
18286: LD_VAR 0 9
18290: IN
18291: NOT
18292: IFFALSE 18318
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18294: LD_ADDR_VAR 0 2
18298: PUSH
18299: LD_VAR 0 9
18303: PUSH
18304: LD_INT 1
18306: PPUSH
18307: LD_VAR 0 9
18311: PPUSH
18312: CALL_OW 12
18316: ARRAY
18317: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18318: LD_VAR 0 2
18322: PPUSH
18323: LD_VAR 0 3
18327: PPUSH
18328: CALL 18577 0 2
18332: NOT
18333: IFFALSE 18392
// repeat engine := _engine [ 1 ] ;
18335: LD_ADDR_VAR 0 3
18339: PUSH
18340: LD_VAR 0 11
18344: PUSH
18345: LD_INT 1
18347: ARRAY
18348: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18349: LD_ADDR_VAR 0 11
18353: PUSH
18354: LD_VAR 0 11
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: CALL_OW 3
18366: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18367: LD_VAR 0 2
18371: PPUSH
18372: LD_VAR 0 3
18376: PPUSH
18377: CALL 18577 0 2
18381: PUSH
18382: LD_VAR 0 11
18386: PUSH
18387: EMPTY
18388: EQUAL
18389: OR
18390: IFFALSE 18335
// if not control in _control then
18392: LD_VAR 0 4
18396: PUSH
18397: LD_VAR 0 12
18401: IN
18402: NOT
18403: IFFALSE 18429
// control := _control [ rand ( 1 , _control ) ] ;
18405: LD_ADDR_VAR 0 4
18409: PUSH
18410: LD_VAR 0 12
18414: PUSH
18415: LD_INT 1
18417: PPUSH
18418: LD_VAR 0 12
18422: PPUSH
18423: CALL_OW 12
18427: ARRAY
18428: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18429: LD_VAR 0 2
18433: PPUSH
18434: LD_VAR 0 5
18438: PPUSH
18439: CALL 18797 0 2
18443: NOT
18444: IFFALSE 18503
// repeat weapon := _weapon [ 1 ] ;
18446: LD_ADDR_VAR 0 5
18450: PUSH
18451: LD_VAR 0 10
18455: PUSH
18456: LD_INT 1
18458: ARRAY
18459: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18460: LD_ADDR_VAR 0 10
18464: PUSH
18465: LD_VAR 0 10
18469: PPUSH
18470: LD_INT 1
18472: PPUSH
18473: CALL_OW 3
18477: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18478: LD_VAR 0 2
18482: PPUSH
18483: LD_VAR 0 5
18487: PPUSH
18488: CALL 18797 0 2
18492: PUSH
18493: LD_VAR 0 10
18497: PUSH
18498: EMPTY
18499: EQUAL
18500: OR
18501: IFFALSE 18446
// result := [ ] ;
18503: LD_ADDR_VAR 0 6
18507: PUSH
18508: EMPTY
18509: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18510: LD_VAR 0 1
18514: PPUSH
18515: LD_VAR 0 2
18519: PPUSH
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_VAR 0 4
18529: PPUSH
18530: LD_VAR 0 5
18534: PPUSH
18535: CALL_OW 448
18539: IFFALSE 18572
// result := [ chassis , engine , control , weapon ] ;
18541: LD_ADDR_VAR 0 6
18545: PUSH
18546: LD_VAR 0 2
18550: PUSH
18551: LD_VAR 0 3
18555: PUSH
18556: LD_VAR 0 4
18560: PUSH
18561: LD_VAR 0 5
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: ST_TO_ADDR
// end ;
18572: LD_VAR 0 6
18576: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18577: LD_INT 0
18579: PPUSH
// if not chassis or not engine then
18580: LD_VAR 0 1
18584: NOT
18585: PUSH
18586: LD_VAR 0 2
18590: NOT
18591: OR
18592: IFFALSE 18596
// exit ;
18594: GO 18792
// case engine of engine_solar :
18596: LD_VAR 0 2
18600: PUSH
18601: LD_INT 2
18603: DOUBLE
18604: EQUAL
18605: IFTRUE 18609
18607: GO 18647
18609: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18610: LD_ADDR_VAR 0 3
18614: PUSH
18615: LD_INT 11
18617: PUSH
18618: LD_INT 12
18620: PUSH
18621: LD_INT 13
18623: PUSH
18624: LD_INT 14
18626: PUSH
18627: LD_INT 1
18629: PUSH
18630: LD_INT 2
18632: PUSH
18633: LD_INT 3
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: LIST
18642: LIST
18643: LIST
18644: ST_TO_ADDR
18645: GO 18776
18647: LD_INT 1
18649: DOUBLE
18650: EQUAL
18651: IFTRUE 18655
18653: GO 18717
18655: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18656: LD_ADDR_VAR 0 3
18660: PUSH
18661: LD_INT 11
18663: PUSH
18664: LD_INT 12
18666: PUSH
18667: LD_INT 13
18669: PUSH
18670: LD_INT 14
18672: PUSH
18673: LD_INT 1
18675: PUSH
18676: LD_INT 2
18678: PUSH
18679: LD_INT 3
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: LD_INT 5
18687: PUSH
18688: LD_INT 21
18690: PUSH
18691: LD_INT 23
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 24
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: LIST
18704: LIST
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: LIST
18713: LIST
18714: ST_TO_ADDR
18715: GO 18776
18717: LD_INT 3
18719: DOUBLE
18720: EQUAL
18721: IFTRUE 18725
18723: GO 18775
18725: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18726: LD_ADDR_VAR 0 3
18730: PUSH
18731: LD_INT 13
18733: PUSH
18734: LD_INT 14
18736: PUSH
18737: LD_INT 2
18739: PUSH
18740: LD_INT 3
18742: PUSH
18743: LD_INT 4
18745: PUSH
18746: LD_INT 5
18748: PUSH
18749: LD_INT 21
18751: PUSH
18752: LD_INT 22
18754: PUSH
18755: LD_INT 23
18757: PUSH
18758: LD_INT 24
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: ST_TO_ADDR
18773: GO 18776
18775: POP
// result := ( chassis in result ) ;
18776: LD_ADDR_VAR 0 3
18780: PUSH
18781: LD_VAR 0 1
18785: PUSH
18786: LD_VAR 0 3
18790: IN
18791: ST_TO_ADDR
// end ;
18792: LD_VAR 0 3
18796: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18797: LD_INT 0
18799: PPUSH
// if not chassis or not weapon then
18800: LD_VAR 0 1
18804: NOT
18805: PUSH
18806: LD_VAR 0 2
18810: NOT
18811: OR
18812: IFFALSE 18816
// exit ;
18814: GO 19876
// case weapon of us_machine_gun :
18816: LD_VAR 0 2
18820: PUSH
18821: LD_INT 2
18823: DOUBLE
18824: EQUAL
18825: IFTRUE 18829
18827: GO 18859
18829: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18830: LD_ADDR_VAR 0 3
18834: PUSH
18835: LD_INT 1
18837: PUSH
18838: LD_INT 2
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: LD_INT 4
18846: PUSH
18847: LD_INT 5
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: ST_TO_ADDR
18857: GO 19860
18859: LD_INT 3
18861: DOUBLE
18862: EQUAL
18863: IFTRUE 18867
18865: GO 18897
18867: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18868: LD_ADDR_VAR 0 3
18872: PUSH
18873: LD_INT 1
18875: PUSH
18876: LD_INT 2
18878: PUSH
18879: LD_INT 3
18881: PUSH
18882: LD_INT 4
18884: PUSH
18885: LD_INT 5
18887: PUSH
18888: EMPTY
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: ST_TO_ADDR
18895: GO 19860
18897: LD_INT 11
18899: DOUBLE
18900: EQUAL
18901: IFTRUE 18905
18903: GO 18935
18905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18906: LD_ADDR_VAR 0 3
18910: PUSH
18911: LD_INT 1
18913: PUSH
18914: LD_INT 2
18916: PUSH
18917: LD_INT 3
18919: PUSH
18920: LD_INT 4
18922: PUSH
18923: LD_INT 5
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: ST_TO_ADDR
18933: GO 19860
18935: LD_INT 4
18937: DOUBLE
18938: EQUAL
18939: IFTRUE 18943
18941: GO 18969
18943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_INT 2
18951: PUSH
18952: LD_INT 3
18954: PUSH
18955: LD_INT 4
18957: PUSH
18958: LD_INT 5
18960: PUSH
18961: EMPTY
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: ST_TO_ADDR
18967: GO 19860
18969: LD_INT 5
18971: DOUBLE
18972: EQUAL
18973: IFTRUE 18977
18975: GO 19003
18977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18978: LD_ADDR_VAR 0 3
18982: PUSH
18983: LD_INT 2
18985: PUSH
18986: LD_INT 3
18988: PUSH
18989: LD_INT 4
18991: PUSH
18992: LD_INT 5
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: ST_TO_ADDR
19001: GO 19860
19003: LD_INT 9
19005: DOUBLE
19006: EQUAL
19007: IFTRUE 19011
19009: GO 19037
19011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_INT 2
19019: PUSH
19020: LD_INT 3
19022: PUSH
19023: LD_INT 4
19025: PUSH
19026: LD_INT 5
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: ST_TO_ADDR
19035: GO 19860
19037: LD_INT 7
19039: DOUBLE
19040: EQUAL
19041: IFTRUE 19045
19043: GO 19071
19045: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19046: LD_ADDR_VAR 0 3
19050: PUSH
19051: LD_INT 2
19053: PUSH
19054: LD_INT 3
19056: PUSH
19057: LD_INT 4
19059: PUSH
19060: LD_INT 5
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: ST_TO_ADDR
19069: GO 19860
19071: LD_INT 12
19073: DOUBLE
19074: EQUAL
19075: IFTRUE 19079
19077: GO 19105
19079: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19080: LD_ADDR_VAR 0 3
19084: PUSH
19085: LD_INT 2
19087: PUSH
19088: LD_INT 3
19090: PUSH
19091: LD_INT 4
19093: PUSH
19094: LD_INT 5
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: ST_TO_ADDR
19103: GO 19860
19105: LD_INT 13
19107: DOUBLE
19108: EQUAL
19109: IFTRUE 19113
19111: GO 19139
19113: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_INT 2
19121: PUSH
19122: LD_INT 3
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: ST_TO_ADDR
19137: GO 19860
19139: LD_INT 14
19141: DOUBLE
19142: EQUAL
19143: IFTRUE 19147
19145: GO 19165
19147: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: LD_INT 4
19155: PUSH
19156: LD_INT 5
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: ST_TO_ADDR
19163: GO 19860
19165: LD_INT 6
19167: DOUBLE
19168: EQUAL
19169: IFTRUE 19173
19171: GO 19191
19173: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19174: LD_ADDR_VAR 0 3
19178: PUSH
19179: LD_INT 4
19181: PUSH
19182: LD_INT 5
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: ST_TO_ADDR
19189: GO 19860
19191: LD_INT 10
19193: DOUBLE
19194: EQUAL
19195: IFTRUE 19199
19197: GO 19217
19199: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19200: LD_ADDR_VAR 0 3
19204: PUSH
19205: LD_INT 4
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: ST_TO_ADDR
19215: GO 19860
19217: LD_INT 22
19219: DOUBLE
19220: EQUAL
19221: IFTRUE 19225
19223: GO 19251
19225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19226: LD_ADDR_VAR 0 3
19230: PUSH
19231: LD_INT 11
19233: PUSH
19234: LD_INT 12
19236: PUSH
19237: LD_INT 13
19239: PUSH
19240: LD_INT 14
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: LIST
19247: LIST
19248: ST_TO_ADDR
19249: GO 19860
19251: LD_INT 23
19253: DOUBLE
19254: EQUAL
19255: IFTRUE 19259
19257: GO 19285
19259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19260: LD_ADDR_VAR 0 3
19264: PUSH
19265: LD_INT 11
19267: PUSH
19268: LD_INT 12
19270: PUSH
19271: LD_INT 13
19273: PUSH
19274: LD_INT 14
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: LIST
19281: LIST
19282: ST_TO_ADDR
19283: GO 19860
19285: LD_INT 24
19287: DOUBLE
19288: EQUAL
19289: IFTRUE 19293
19291: GO 19319
19293: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_INT 11
19301: PUSH
19302: LD_INT 12
19304: PUSH
19305: LD_INT 13
19307: PUSH
19308: LD_INT 14
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: ST_TO_ADDR
19317: GO 19860
19319: LD_INT 30
19321: DOUBLE
19322: EQUAL
19323: IFTRUE 19327
19325: GO 19353
19327: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19328: LD_ADDR_VAR 0 3
19332: PUSH
19333: LD_INT 11
19335: PUSH
19336: LD_INT 12
19338: PUSH
19339: LD_INT 13
19341: PUSH
19342: LD_INT 14
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: ST_TO_ADDR
19351: GO 19860
19353: LD_INT 25
19355: DOUBLE
19356: EQUAL
19357: IFTRUE 19361
19359: GO 19379
19361: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19362: LD_ADDR_VAR 0 3
19366: PUSH
19367: LD_INT 13
19369: PUSH
19370: LD_INT 14
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: ST_TO_ADDR
19377: GO 19860
19379: LD_INT 27
19381: DOUBLE
19382: EQUAL
19383: IFTRUE 19387
19385: GO 19405
19387: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
19388: LD_ADDR_VAR 0 3
19392: PUSH
19393: LD_INT 13
19395: PUSH
19396: LD_INT 14
19398: PUSH
19399: EMPTY
19400: LIST
19401: LIST
19402: ST_TO_ADDR
19403: GO 19860
19405: LD_INT 92
19407: DOUBLE
19408: EQUAL
19409: IFTRUE 19413
19411: GO 19439
19413: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19414: LD_ADDR_VAR 0 3
19418: PUSH
19419: LD_INT 11
19421: PUSH
19422: LD_INT 12
19424: PUSH
19425: LD_INT 13
19427: PUSH
19428: LD_INT 14
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: ST_TO_ADDR
19437: GO 19860
19439: LD_INT 28
19441: DOUBLE
19442: EQUAL
19443: IFTRUE 19447
19445: GO 19465
19447: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19448: LD_ADDR_VAR 0 3
19452: PUSH
19453: LD_INT 13
19455: PUSH
19456: LD_INT 14
19458: PUSH
19459: EMPTY
19460: LIST
19461: LIST
19462: ST_TO_ADDR
19463: GO 19860
19465: LD_INT 29
19467: DOUBLE
19468: EQUAL
19469: IFTRUE 19473
19471: GO 19491
19473: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19474: LD_ADDR_VAR 0 3
19478: PUSH
19479: LD_INT 13
19481: PUSH
19482: LD_INT 14
19484: PUSH
19485: EMPTY
19486: LIST
19487: LIST
19488: ST_TO_ADDR
19489: GO 19860
19491: LD_INT 31
19493: DOUBLE
19494: EQUAL
19495: IFTRUE 19499
19497: GO 19517
19499: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19500: LD_ADDR_VAR 0 3
19504: PUSH
19505: LD_INT 13
19507: PUSH
19508: LD_INT 14
19510: PUSH
19511: EMPTY
19512: LIST
19513: LIST
19514: ST_TO_ADDR
19515: GO 19860
19517: LD_INT 26
19519: DOUBLE
19520: EQUAL
19521: IFTRUE 19525
19523: GO 19543
19525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19526: LD_ADDR_VAR 0 3
19530: PUSH
19531: LD_INT 13
19533: PUSH
19534: LD_INT 14
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: ST_TO_ADDR
19541: GO 19860
19543: LD_INT 42
19545: DOUBLE
19546: EQUAL
19547: IFTRUE 19551
19549: GO 19577
19551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19552: LD_ADDR_VAR 0 3
19556: PUSH
19557: LD_INT 21
19559: PUSH
19560: LD_INT 22
19562: PUSH
19563: LD_INT 23
19565: PUSH
19566: LD_INT 24
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: ST_TO_ADDR
19575: GO 19860
19577: LD_INT 43
19579: DOUBLE
19580: EQUAL
19581: IFTRUE 19585
19583: GO 19611
19585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19586: LD_ADDR_VAR 0 3
19590: PUSH
19591: LD_INT 21
19593: PUSH
19594: LD_INT 22
19596: PUSH
19597: LD_INT 23
19599: PUSH
19600: LD_INT 24
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: ST_TO_ADDR
19609: GO 19860
19611: LD_INT 44
19613: DOUBLE
19614: EQUAL
19615: IFTRUE 19619
19617: GO 19645
19619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19620: LD_ADDR_VAR 0 3
19624: PUSH
19625: LD_INT 21
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 23
19633: PUSH
19634: LD_INT 24
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: ST_TO_ADDR
19643: GO 19860
19645: LD_INT 45
19647: DOUBLE
19648: EQUAL
19649: IFTRUE 19653
19651: GO 19679
19653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19654: LD_ADDR_VAR 0 3
19658: PUSH
19659: LD_INT 21
19661: PUSH
19662: LD_INT 22
19664: PUSH
19665: LD_INT 23
19667: PUSH
19668: LD_INT 24
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: ST_TO_ADDR
19677: GO 19860
19679: LD_INT 49
19681: DOUBLE
19682: EQUAL
19683: IFTRUE 19687
19685: GO 19713
19687: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: LD_INT 21
19695: PUSH
19696: LD_INT 22
19698: PUSH
19699: LD_INT 23
19701: PUSH
19702: LD_INT 24
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: ST_TO_ADDR
19711: GO 19860
19713: LD_INT 51
19715: DOUBLE
19716: EQUAL
19717: IFTRUE 19721
19719: GO 19747
19721: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19722: LD_ADDR_VAR 0 3
19726: PUSH
19727: LD_INT 21
19729: PUSH
19730: LD_INT 22
19732: PUSH
19733: LD_INT 23
19735: PUSH
19736: LD_INT 24
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
19745: GO 19860
19747: LD_INT 52
19749: DOUBLE
19750: EQUAL
19751: IFTRUE 19755
19753: GO 19781
19755: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: LD_INT 21
19763: PUSH
19764: LD_INT 22
19766: PUSH
19767: LD_INT 23
19769: PUSH
19770: LD_INT 24
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: ST_TO_ADDR
19779: GO 19860
19781: LD_INT 53
19783: DOUBLE
19784: EQUAL
19785: IFTRUE 19789
19787: GO 19807
19789: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19790: LD_ADDR_VAR 0 3
19794: PUSH
19795: LD_INT 23
19797: PUSH
19798: LD_INT 24
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: ST_TO_ADDR
19805: GO 19860
19807: LD_INT 46
19809: DOUBLE
19810: EQUAL
19811: IFTRUE 19815
19813: GO 19833
19815: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19816: LD_ADDR_VAR 0 3
19820: PUSH
19821: LD_INT 23
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: ST_TO_ADDR
19831: GO 19860
19833: LD_INT 47
19835: DOUBLE
19836: EQUAL
19837: IFTRUE 19841
19839: GO 19859
19841: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19842: LD_ADDR_VAR 0 3
19846: PUSH
19847: LD_INT 23
19849: PUSH
19850: LD_INT 24
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: ST_TO_ADDR
19857: GO 19860
19859: POP
// result := ( chassis in result ) ;
19860: LD_ADDR_VAR 0 3
19864: PUSH
19865: LD_VAR 0 1
19869: PUSH
19870: LD_VAR 0 3
19874: IN
19875: ST_TO_ADDR
// end ;
19876: LD_VAR 0 3
19880: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19881: LD_INT 0
19883: PPUSH
19884: PPUSH
19885: PPUSH
19886: PPUSH
19887: PPUSH
19888: PPUSH
19889: PPUSH
// result := array ;
19890: LD_ADDR_VAR 0 5
19894: PUSH
19895: LD_VAR 0 1
19899: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19900: LD_VAR 0 1
19904: NOT
19905: PUSH
19906: LD_VAR 0 2
19910: NOT
19911: OR
19912: PUSH
19913: LD_VAR 0 3
19917: NOT
19918: OR
19919: PUSH
19920: LD_VAR 0 2
19924: PUSH
19925: LD_VAR 0 1
19929: GREATER
19930: OR
19931: PUSH
19932: LD_VAR 0 3
19936: PUSH
19937: LD_VAR 0 1
19941: GREATER
19942: OR
19943: IFFALSE 19947
// exit ;
19945: GO 20243
// if direction then
19947: LD_VAR 0 4
19951: IFFALSE 20015
// begin d := 1 ;
19953: LD_ADDR_VAR 0 9
19957: PUSH
19958: LD_INT 1
19960: ST_TO_ADDR
// if i_from > i_to then
19961: LD_VAR 0 2
19965: PUSH
19966: LD_VAR 0 3
19970: GREATER
19971: IFFALSE 19997
// length := ( array - i_from ) + i_to else
19973: LD_ADDR_VAR 0 11
19977: PUSH
19978: LD_VAR 0 1
19982: PUSH
19983: LD_VAR 0 2
19987: MINUS
19988: PUSH
19989: LD_VAR 0 3
19993: PLUS
19994: ST_TO_ADDR
19995: GO 20013
// length := i_to - i_from ;
19997: LD_ADDR_VAR 0 11
20001: PUSH
20002: LD_VAR 0 3
20006: PUSH
20007: LD_VAR 0 2
20011: MINUS
20012: ST_TO_ADDR
// end else
20013: GO 20076
// begin d := - 1 ;
20015: LD_ADDR_VAR 0 9
20019: PUSH
20020: LD_INT 1
20022: NEG
20023: ST_TO_ADDR
// if i_from > i_to then
20024: LD_VAR 0 2
20028: PUSH
20029: LD_VAR 0 3
20033: GREATER
20034: IFFALSE 20054
// length := i_from - i_to else
20036: LD_ADDR_VAR 0 11
20040: PUSH
20041: LD_VAR 0 2
20045: PUSH
20046: LD_VAR 0 3
20050: MINUS
20051: ST_TO_ADDR
20052: GO 20076
// length := ( array - i_to ) + i_from ;
20054: LD_ADDR_VAR 0 11
20058: PUSH
20059: LD_VAR 0 1
20063: PUSH
20064: LD_VAR 0 3
20068: MINUS
20069: PUSH
20070: LD_VAR 0 2
20074: PLUS
20075: ST_TO_ADDR
// end ; if not length then
20076: LD_VAR 0 11
20080: NOT
20081: IFFALSE 20085
// exit ;
20083: GO 20243
// tmp := array ;
20085: LD_ADDR_VAR 0 10
20089: PUSH
20090: LD_VAR 0 1
20094: ST_TO_ADDR
// for i = 1 to length do
20095: LD_ADDR_VAR 0 6
20099: PUSH
20100: DOUBLE
20101: LD_INT 1
20103: DEC
20104: ST_TO_ADDR
20105: LD_VAR 0 11
20109: PUSH
20110: FOR_TO
20111: IFFALSE 20231
// begin for j = 1 to array do
20113: LD_ADDR_VAR 0 7
20117: PUSH
20118: DOUBLE
20119: LD_INT 1
20121: DEC
20122: ST_TO_ADDR
20123: LD_VAR 0 1
20127: PUSH
20128: FOR_TO
20129: IFFALSE 20217
// begin k := j + d ;
20131: LD_ADDR_VAR 0 8
20135: PUSH
20136: LD_VAR 0 7
20140: PUSH
20141: LD_VAR 0 9
20145: PLUS
20146: ST_TO_ADDR
// if k > array then
20147: LD_VAR 0 8
20151: PUSH
20152: LD_VAR 0 1
20156: GREATER
20157: IFFALSE 20167
// k := 1 ;
20159: LD_ADDR_VAR 0 8
20163: PUSH
20164: LD_INT 1
20166: ST_TO_ADDR
// if not k then
20167: LD_VAR 0 8
20171: NOT
20172: IFFALSE 20184
// k := array ;
20174: LD_ADDR_VAR 0 8
20178: PUSH
20179: LD_VAR 0 1
20183: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20184: LD_ADDR_VAR 0 10
20188: PUSH
20189: LD_VAR 0 10
20193: PPUSH
20194: LD_VAR 0 8
20198: PPUSH
20199: LD_VAR 0 1
20203: PUSH
20204: LD_VAR 0 7
20208: ARRAY
20209: PPUSH
20210: CALL_OW 1
20214: ST_TO_ADDR
// end ;
20215: GO 20128
20217: POP
20218: POP
// array := tmp ;
20219: LD_ADDR_VAR 0 1
20223: PUSH
20224: LD_VAR 0 10
20228: ST_TO_ADDR
// end ;
20229: GO 20110
20231: POP
20232: POP
// result := array ;
20233: LD_ADDR_VAR 0 5
20237: PUSH
20238: LD_VAR 0 1
20242: ST_TO_ADDR
// end ;
20243: LD_VAR 0 5
20247: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20248: LD_INT 0
20250: PPUSH
20251: PPUSH
// result := 0 ;
20252: LD_ADDR_VAR 0 3
20256: PUSH
20257: LD_INT 0
20259: ST_TO_ADDR
// if not array or not value in array then
20260: LD_VAR 0 1
20264: NOT
20265: PUSH
20266: LD_VAR 0 2
20270: PUSH
20271: LD_VAR 0 1
20275: IN
20276: NOT
20277: OR
20278: IFFALSE 20282
// exit ;
20280: GO 20336
// for i = 1 to array do
20282: LD_ADDR_VAR 0 4
20286: PUSH
20287: DOUBLE
20288: LD_INT 1
20290: DEC
20291: ST_TO_ADDR
20292: LD_VAR 0 1
20296: PUSH
20297: FOR_TO
20298: IFFALSE 20334
// if value = array [ i ] then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_VAR 0 1
20309: PUSH
20310: LD_VAR 0 4
20314: ARRAY
20315: EQUAL
20316: IFFALSE 20332
// begin result := i ;
20318: LD_ADDR_VAR 0 3
20322: PUSH
20323: LD_VAR 0 4
20327: ST_TO_ADDR
// exit ;
20328: POP
20329: POP
20330: GO 20336
// end ;
20332: GO 20297
20334: POP
20335: POP
// end ;
20336: LD_VAR 0 3
20340: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20341: LD_INT 0
20343: PPUSH
// vc_chassis := chassis ;
20344: LD_ADDR_OWVAR 37
20348: PUSH
20349: LD_VAR 0 1
20353: ST_TO_ADDR
// vc_engine := engine ;
20354: LD_ADDR_OWVAR 39
20358: PUSH
20359: LD_VAR 0 2
20363: ST_TO_ADDR
// vc_control := control ;
20364: LD_ADDR_OWVAR 38
20368: PUSH
20369: LD_VAR 0 3
20373: ST_TO_ADDR
// vc_weapon := weapon ;
20374: LD_ADDR_OWVAR 40
20378: PUSH
20379: LD_VAR 0 4
20383: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20384: LD_ADDR_OWVAR 41
20388: PUSH
20389: LD_VAR 0 5
20393: ST_TO_ADDR
// end ;
20394: LD_VAR 0 6
20398: RET
// export function WantPlant ( unit ) ; var task ; begin
20399: LD_INT 0
20401: PPUSH
20402: PPUSH
// result := false ;
20403: LD_ADDR_VAR 0 2
20407: PUSH
20408: LD_INT 0
20410: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20411: LD_ADDR_VAR 0 3
20415: PUSH
20416: LD_VAR 0 1
20420: PPUSH
20421: CALL_OW 437
20425: ST_TO_ADDR
// if task then
20426: LD_VAR 0 3
20430: IFFALSE 20458
// if task [ 1 ] [ 1 ] = p then
20432: LD_VAR 0 3
20436: PUSH
20437: LD_INT 1
20439: ARRAY
20440: PUSH
20441: LD_INT 1
20443: ARRAY
20444: PUSH
20445: LD_STRING p
20447: EQUAL
20448: IFFALSE 20458
// result := true ;
20450: LD_ADDR_VAR 0 2
20454: PUSH
20455: LD_INT 1
20457: ST_TO_ADDR
// end ;
20458: LD_VAR 0 2
20462: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20463: LD_INT 0
20465: PPUSH
20466: PPUSH
20467: PPUSH
20468: PPUSH
// if pos < 1 then
20469: LD_VAR 0 2
20473: PUSH
20474: LD_INT 1
20476: LESS
20477: IFFALSE 20481
// exit ;
20479: GO 20784
// if pos = 1 then
20481: LD_VAR 0 2
20485: PUSH
20486: LD_INT 1
20488: EQUAL
20489: IFFALSE 20522
// result := Replace ( arr , pos [ 1 ] , value ) else
20491: LD_ADDR_VAR 0 4
20495: PUSH
20496: LD_VAR 0 1
20500: PPUSH
20501: LD_VAR 0 2
20505: PUSH
20506: LD_INT 1
20508: ARRAY
20509: PPUSH
20510: LD_VAR 0 3
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
20520: GO 20784
// begin tmp := arr ;
20522: LD_ADDR_VAR 0 6
20526: PUSH
20527: LD_VAR 0 1
20531: ST_TO_ADDR
// s_arr := [ tmp ] ;
20532: LD_ADDR_VAR 0 7
20536: PUSH
20537: LD_VAR 0 6
20541: PUSH
20542: EMPTY
20543: LIST
20544: ST_TO_ADDR
// for i = 1 to pos - 1 do
20545: LD_ADDR_VAR 0 5
20549: PUSH
20550: DOUBLE
20551: LD_INT 1
20553: DEC
20554: ST_TO_ADDR
20555: LD_VAR 0 2
20559: PUSH
20560: LD_INT 1
20562: MINUS
20563: PUSH
20564: FOR_TO
20565: IFFALSE 20610
// begin tmp := tmp [ pos [ i ] ] ;
20567: LD_ADDR_VAR 0 6
20571: PUSH
20572: LD_VAR 0 6
20576: PUSH
20577: LD_VAR 0 2
20581: PUSH
20582: LD_VAR 0 5
20586: ARRAY
20587: ARRAY
20588: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20589: LD_ADDR_VAR 0 7
20593: PUSH
20594: LD_VAR 0 7
20598: PUSH
20599: LD_VAR 0 6
20603: PUSH
20604: EMPTY
20605: LIST
20606: ADD
20607: ST_TO_ADDR
// end ;
20608: GO 20564
20610: POP
20611: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20612: LD_ADDR_VAR 0 6
20616: PUSH
20617: LD_VAR 0 6
20621: PPUSH
20622: LD_VAR 0 2
20626: PUSH
20627: LD_VAR 0 2
20631: ARRAY
20632: PPUSH
20633: LD_VAR 0 3
20637: PPUSH
20638: CALL_OW 1
20642: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20643: LD_ADDR_VAR 0 7
20647: PUSH
20648: LD_VAR 0 7
20652: PPUSH
20653: LD_VAR 0 7
20657: PPUSH
20658: LD_VAR 0 6
20662: PPUSH
20663: CALL_OW 1
20667: ST_TO_ADDR
// for i = s_arr downto 2 do
20668: LD_ADDR_VAR 0 5
20672: PUSH
20673: DOUBLE
20674: LD_VAR 0 7
20678: INC
20679: ST_TO_ADDR
20680: LD_INT 2
20682: PUSH
20683: FOR_DOWNTO
20684: IFFALSE 20768
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20686: LD_ADDR_VAR 0 6
20690: PUSH
20691: LD_VAR 0 7
20695: PUSH
20696: LD_VAR 0 5
20700: PUSH
20701: LD_INT 1
20703: MINUS
20704: ARRAY
20705: PPUSH
20706: LD_VAR 0 2
20710: PUSH
20711: LD_VAR 0 5
20715: PUSH
20716: LD_INT 1
20718: MINUS
20719: ARRAY
20720: PPUSH
20721: LD_VAR 0 7
20725: PUSH
20726: LD_VAR 0 5
20730: ARRAY
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20737: LD_ADDR_VAR 0 7
20741: PUSH
20742: LD_VAR 0 7
20746: PPUSH
20747: LD_VAR 0 5
20751: PUSH
20752: LD_INT 1
20754: MINUS
20755: PPUSH
20756: LD_VAR 0 6
20760: PPUSH
20761: CALL_OW 1
20765: ST_TO_ADDR
// end ;
20766: GO 20683
20768: POP
20769: POP
// result := s_arr [ 1 ] ;
20770: LD_ADDR_VAR 0 4
20774: PUSH
20775: LD_VAR 0 7
20779: PUSH
20780: LD_INT 1
20782: ARRAY
20783: ST_TO_ADDR
// end ; end ;
20784: LD_VAR 0 4
20788: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20789: LD_INT 0
20791: PPUSH
20792: PPUSH
// if not list then
20793: LD_VAR 0 1
20797: NOT
20798: IFFALSE 20802
// exit ;
20800: GO 20893
// i := list [ pos1 ] ;
20802: LD_ADDR_VAR 0 5
20806: PUSH
20807: LD_VAR 0 1
20811: PUSH
20812: LD_VAR 0 2
20816: ARRAY
20817: ST_TO_ADDR
// if not i then
20818: LD_VAR 0 5
20822: NOT
20823: IFFALSE 20827
// exit ;
20825: GO 20893
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20827: LD_ADDR_VAR 0 1
20831: PUSH
20832: LD_VAR 0 1
20836: PPUSH
20837: LD_VAR 0 2
20841: PPUSH
20842: LD_VAR 0 1
20846: PUSH
20847: LD_VAR 0 3
20851: ARRAY
20852: PPUSH
20853: CALL_OW 1
20857: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20858: LD_ADDR_VAR 0 1
20862: PUSH
20863: LD_VAR 0 1
20867: PPUSH
20868: LD_VAR 0 3
20872: PPUSH
20873: LD_VAR 0 5
20877: PPUSH
20878: CALL_OW 1
20882: ST_TO_ADDR
// result := list ;
20883: LD_ADDR_VAR 0 4
20887: PUSH
20888: LD_VAR 0 1
20892: ST_TO_ADDR
// end ;
20893: LD_VAR 0 4
20897: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20898: LD_INT 0
20900: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20901: LD_ADDR_VAR 0 5
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 250
20915: PPUSH
20916: LD_VAR 0 1
20920: PPUSH
20921: CALL_OW 251
20925: PPUSH
20926: LD_VAR 0 2
20930: PPUSH
20931: LD_VAR 0 3
20935: PPUSH
20936: LD_VAR 0 4
20940: PPUSH
20941: CALL 20951 0 5
20945: ST_TO_ADDR
// end ;
20946: LD_VAR 0 5
20950: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20951: LD_INT 0
20953: PPUSH
20954: PPUSH
20955: PPUSH
20956: PPUSH
// if not list then
20957: LD_VAR 0 3
20961: NOT
20962: IFFALSE 20966
// exit ;
20964: GO 21354
// result := [ ] ;
20966: LD_ADDR_VAR 0 6
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// for i in list do
20973: LD_ADDR_VAR 0 7
20977: PUSH
20978: LD_VAR 0 3
20982: PUSH
20983: FOR_IN
20984: IFFALSE 21186
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20986: LD_ADDR_VAR 0 9
20990: PUSH
20991: LD_VAR 0 7
20995: PPUSH
20996: LD_VAR 0 1
21000: PPUSH
21001: LD_VAR 0 2
21005: PPUSH
21006: CALL_OW 297
21010: ST_TO_ADDR
// if not result then
21011: LD_VAR 0 6
21015: NOT
21016: IFFALSE 21042
// result := [ [ i , tmp ] ] else
21018: LD_ADDR_VAR 0 6
21022: PUSH
21023: LD_VAR 0 7
21027: PUSH
21028: LD_VAR 0 9
21032: PUSH
21033: EMPTY
21034: LIST
21035: LIST
21036: PUSH
21037: EMPTY
21038: LIST
21039: ST_TO_ADDR
21040: GO 21184
// begin if result [ result ] [ 2 ] < tmp then
21042: LD_VAR 0 6
21046: PUSH
21047: LD_VAR 0 6
21051: ARRAY
21052: PUSH
21053: LD_INT 2
21055: ARRAY
21056: PUSH
21057: LD_VAR 0 9
21061: LESS
21062: IFFALSE 21104
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21064: LD_ADDR_VAR 0 6
21068: PUSH
21069: LD_VAR 0 6
21073: PPUSH
21074: LD_VAR 0 6
21078: PUSH
21079: LD_INT 1
21081: PLUS
21082: PPUSH
21083: LD_VAR 0 7
21087: PUSH
21088: LD_VAR 0 9
21092: PUSH
21093: EMPTY
21094: LIST
21095: LIST
21096: PPUSH
21097: CALL_OW 2
21101: ST_TO_ADDR
21102: GO 21184
// for j = 1 to result do
21104: LD_ADDR_VAR 0 8
21108: PUSH
21109: DOUBLE
21110: LD_INT 1
21112: DEC
21113: ST_TO_ADDR
21114: LD_VAR 0 6
21118: PUSH
21119: FOR_TO
21120: IFFALSE 21182
// begin if tmp < result [ j ] [ 2 ] then
21122: LD_VAR 0 9
21126: PUSH
21127: LD_VAR 0 6
21131: PUSH
21132: LD_VAR 0 8
21136: ARRAY
21137: PUSH
21138: LD_INT 2
21140: ARRAY
21141: LESS
21142: IFFALSE 21180
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21144: LD_ADDR_VAR 0 6
21148: PUSH
21149: LD_VAR 0 6
21153: PPUSH
21154: LD_VAR 0 8
21158: PPUSH
21159: LD_VAR 0 7
21163: PUSH
21164: LD_VAR 0 9
21168: PUSH
21169: EMPTY
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL_OW 2
21177: ST_TO_ADDR
// break ;
21178: GO 21182
// end ; end ;
21180: GO 21119
21182: POP
21183: POP
// end ; end ;
21184: GO 20983
21186: POP
21187: POP
// if result and not asc then
21188: LD_VAR 0 6
21192: PUSH
21193: LD_VAR 0 4
21197: NOT
21198: AND
21199: IFFALSE 21274
// begin tmp := result ;
21201: LD_ADDR_VAR 0 9
21205: PUSH
21206: LD_VAR 0 6
21210: ST_TO_ADDR
// for i = tmp downto 1 do
21211: LD_ADDR_VAR 0 7
21215: PUSH
21216: DOUBLE
21217: LD_VAR 0 9
21221: INC
21222: ST_TO_ADDR
21223: LD_INT 1
21225: PUSH
21226: FOR_DOWNTO
21227: IFFALSE 21272
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21229: LD_ADDR_VAR 0 6
21233: PUSH
21234: LD_VAR 0 6
21238: PPUSH
21239: LD_VAR 0 9
21243: PUSH
21244: LD_VAR 0 7
21248: MINUS
21249: PUSH
21250: LD_INT 1
21252: PLUS
21253: PPUSH
21254: LD_VAR 0 9
21258: PUSH
21259: LD_VAR 0 7
21263: ARRAY
21264: PPUSH
21265: CALL_OW 1
21269: ST_TO_ADDR
21270: GO 21226
21272: POP
21273: POP
// end ; tmp := [ ] ;
21274: LD_ADDR_VAR 0 9
21278: PUSH
21279: EMPTY
21280: ST_TO_ADDR
// if mode then
21281: LD_VAR 0 5
21285: IFFALSE 21354
// begin for i = 1 to result do
21287: LD_ADDR_VAR 0 7
21291: PUSH
21292: DOUBLE
21293: LD_INT 1
21295: DEC
21296: ST_TO_ADDR
21297: LD_VAR 0 6
21301: PUSH
21302: FOR_TO
21303: IFFALSE 21342
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21305: LD_ADDR_VAR 0 9
21309: PUSH
21310: LD_VAR 0 9
21314: PPUSH
21315: LD_VAR 0 7
21319: PPUSH
21320: LD_VAR 0 6
21324: PUSH
21325: LD_VAR 0 7
21329: ARRAY
21330: PUSH
21331: LD_INT 1
21333: ARRAY
21334: PPUSH
21335: CALL_OW 1
21339: ST_TO_ADDR
21340: GO 21302
21342: POP
21343: POP
// result := tmp ;
21344: LD_ADDR_VAR 0 6
21348: PUSH
21349: LD_VAR 0 9
21353: ST_TO_ADDR
// end ; end ;
21354: LD_VAR 0 6
21358: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21359: LD_INT 0
21361: PPUSH
21362: PPUSH
21363: PPUSH
21364: PPUSH
21365: PPUSH
21366: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21367: LD_ADDR_VAR 0 5
21371: PUSH
21372: LD_INT 0
21374: PUSH
21375: LD_INT 0
21377: PUSH
21378: LD_INT 0
21380: PUSH
21381: EMPTY
21382: PUSH
21383: EMPTY
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: ST_TO_ADDR
// if not x or not y then
21389: LD_VAR 0 2
21393: NOT
21394: PUSH
21395: LD_VAR 0 3
21399: NOT
21400: OR
21401: IFFALSE 21405
// exit ;
21403: GO 23055
// if not range then
21405: LD_VAR 0 4
21409: NOT
21410: IFFALSE 21420
// range := 10 ;
21412: LD_ADDR_VAR 0 4
21416: PUSH
21417: LD_INT 10
21419: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21420: LD_ADDR_VAR 0 8
21424: PUSH
21425: LD_INT 81
21427: PUSH
21428: LD_VAR 0 1
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: PUSH
21437: LD_INT 92
21439: PUSH
21440: LD_VAR 0 2
21444: PUSH
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 4
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 3
21463: PUSH
21464: LD_INT 21
21466: PUSH
21467: LD_INT 3
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: LIST
21482: PPUSH
21483: CALL_OW 69
21487: ST_TO_ADDR
// if not tmp then
21488: LD_VAR 0 8
21492: NOT
21493: IFFALSE 21497
// exit ;
21495: GO 23055
// for i in tmp do
21497: LD_ADDR_VAR 0 6
21501: PUSH
21502: LD_VAR 0 8
21506: PUSH
21507: FOR_IN
21508: IFFALSE 23030
// begin points := [ 0 , 0 , 0 ] ;
21510: LD_ADDR_VAR 0 9
21514: PUSH
21515: LD_INT 0
21517: PUSH
21518: LD_INT 0
21520: PUSH
21521: LD_INT 0
21523: PUSH
21524: EMPTY
21525: LIST
21526: LIST
21527: LIST
21528: ST_TO_ADDR
// bpoints := 1 ;
21529: LD_ADDR_VAR 0 10
21533: PUSH
21534: LD_INT 1
21536: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21537: LD_VAR 0 6
21541: PPUSH
21542: CALL_OW 247
21546: PUSH
21547: LD_INT 1
21549: DOUBLE
21550: EQUAL
21551: IFTRUE 21555
21553: GO 22133
21555: POP
// begin if GetClass ( i ) = 1 then
21556: LD_VAR 0 6
21560: PPUSH
21561: CALL_OW 257
21565: PUSH
21566: LD_INT 1
21568: EQUAL
21569: IFFALSE 21590
// points := [ 10 , 5 , 3 ] ;
21571: LD_ADDR_VAR 0 9
21575: PUSH
21576: LD_INT 10
21578: PUSH
21579: LD_INT 5
21581: PUSH
21582: LD_INT 3
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: LIST
21589: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21590: LD_VAR 0 6
21594: PPUSH
21595: CALL_OW 257
21599: PUSH
21600: LD_INT 2
21602: PUSH
21603: LD_INT 3
21605: PUSH
21606: LD_INT 4
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: LIST
21613: IN
21614: IFFALSE 21635
// points := [ 3 , 2 , 1 ] ;
21616: LD_ADDR_VAR 0 9
21620: PUSH
21621: LD_INT 3
21623: PUSH
21624: LD_INT 2
21626: PUSH
21627: LD_INT 1
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: LIST
21634: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21635: LD_VAR 0 6
21639: PPUSH
21640: CALL_OW 257
21644: PUSH
21645: LD_INT 5
21647: EQUAL
21648: IFFALSE 21669
// points := [ 130 , 5 , 2 ] ;
21650: LD_ADDR_VAR 0 9
21654: PUSH
21655: LD_INT 130
21657: PUSH
21658: LD_INT 5
21660: PUSH
21661: LD_INT 2
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: LIST
21668: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21669: LD_VAR 0 6
21673: PPUSH
21674: CALL_OW 257
21678: PUSH
21679: LD_INT 8
21681: EQUAL
21682: IFFALSE 21703
// points := [ 35 , 35 , 30 ] ;
21684: LD_ADDR_VAR 0 9
21688: PUSH
21689: LD_INT 35
21691: PUSH
21692: LD_INT 35
21694: PUSH
21695: LD_INT 30
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: LIST
21702: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21703: LD_VAR 0 6
21707: PPUSH
21708: CALL_OW 257
21712: PUSH
21713: LD_INT 9
21715: EQUAL
21716: IFFALSE 21737
// points := [ 20 , 55 , 40 ] ;
21718: LD_ADDR_VAR 0 9
21722: PUSH
21723: LD_INT 20
21725: PUSH
21726: LD_INT 55
21728: PUSH
21729: LD_INT 40
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: LIST
21736: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21737: LD_VAR 0 6
21741: PPUSH
21742: CALL_OW 257
21746: PUSH
21747: LD_INT 12
21749: PUSH
21750: LD_INT 16
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: IN
21757: IFFALSE 21778
// points := [ 5 , 3 , 2 ] ;
21759: LD_ADDR_VAR 0 9
21763: PUSH
21764: LD_INT 5
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 2
21772: PUSH
21773: EMPTY
21774: LIST
21775: LIST
21776: LIST
21777: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21778: LD_VAR 0 6
21782: PPUSH
21783: CALL_OW 257
21787: PUSH
21788: LD_INT 17
21790: EQUAL
21791: IFFALSE 21812
// points := [ 100 , 50 , 75 ] ;
21793: LD_ADDR_VAR 0 9
21797: PUSH
21798: LD_INT 100
21800: PUSH
21801: LD_INT 50
21803: PUSH
21804: LD_INT 75
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21812: LD_VAR 0 6
21816: PPUSH
21817: CALL_OW 257
21821: PUSH
21822: LD_INT 15
21824: EQUAL
21825: IFFALSE 21846
// points := [ 10 , 5 , 3 ] ;
21827: LD_ADDR_VAR 0 9
21831: PUSH
21832: LD_INT 10
21834: PUSH
21835: LD_INT 5
21837: PUSH
21838: LD_INT 3
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: LIST
21845: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21846: LD_VAR 0 6
21850: PPUSH
21851: CALL_OW 257
21855: PUSH
21856: LD_INT 14
21858: EQUAL
21859: IFFALSE 21880
// points := [ 10 , 0 , 0 ] ;
21861: LD_ADDR_VAR 0 9
21865: PUSH
21866: LD_INT 10
21868: PUSH
21869: LD_INT 0
21871: PUSH
21872: LD_INT 0
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: LIST
21879: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21880: LD_VAR 0 6
21884: PPUSH
21885: CALL_OW 257
21889: PUSH
21890: LD_INT 11
21892: EQUAL
21893: IFFALSE 21914
// points := [ 30 , 10 , 5 ] ;
21895: LD_ADDR_VAR 0 9
21899: PUSH
21900: LD_INT 30
21902: PUSH
21903: LD_INT 10
21905: PUSH
21906: LD_INT 5
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: LIST
21913: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21914: LD_VAR 0 1
21918: PPUSH
21919: LD_INT 5
21921: PPUSH
21922: CALL_OW 321
21926: PUSH
21927: LD_INT 2
21929: EQUAL
21930: IFFALSE 21947
// bpoints := bpoints * 1.8 ;
21932: LD_ADDR_VAR 0 10
21936: PUSH
21937: LD_VAR 0 10
21941: PUSH
21942: LD_REAL  1.80000000000000E+0000
21945: MUL
21946: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21947: LD_VAR 0 6
21951: PPUSH
21952: CALL_OW 257
21956: PUSH
21957: LD_INT 1
21959: PUSH
21960: LD_INT 2
21962: PUSH
21963: LD_INT 3
21965: PUSH
21966: LD_INT 4
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: IN
21975: PUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: LD_INT 51
21983: PPUSH
21984: CALL_OW 321
21988: PUSH
21989: LD_INT 2
21991: EQUAL
21992: AND
21993: IFFALSE 22010
// bpoints := bpoints * 1.2 ;
21995: LD_ADDR_VAR 0 10
21999: PUSH
22000: LD_VAR 0 10
22004: PUSH
22005: LD_REAL  1.20000000000000E+0000
22008: MUL
22009: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22010: LD_VAR 0 6
22014: PPUSH
22015: CALL_OW 257
22019: PUSH
22020: LD_INT 5
22022: PUSH
22023: LD_INT 7
22025: PUSH
22026: LD_INT 9
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: LIST
22033: IN
22034: PUSH
22035: LD_VAR 0 1
22039: PPUSH
22040: LD_INT 52
22042: PPUSH
22043: CALL_OW 321
22047: PUSH
22048: LD_INT 2
22050: EQUAL
22051: AND
22052: IFFALSE 22069
// bpoints := bpoints * 1.5 ;
22054: LD_ADDR_VAR 0 10
22058: PUSH
22059: LD_VAR 0 10
22063: PUSH
22064: LD_REAL  1.50000000000000E+0000
22067: MUL
22068: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22069: LD_VAR 0 1
22073: PPUSH
22074: LD_INT 66
22076: PPUSH
22077: CALL_OW 321
22081: PUSH
22082: LD_INT 2
22084: EQUAL
22085: IFFALSE 22102
// bpoints := bpoints * 1.1 ;
22087: LD_ADDR_VAR 0 10
22091: PUSH
22092: LD_VAR 0 10
22096: PUSH
22097: LD_REAL  1.10000000000000E+0000
22100: MUL
22101: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22102: LD_ADDR_VAR 0 10
22106: PUSH
22107: LD_VAR 0 10
22111: PUSH
22112: LD_VAR 0 6
22116: PPUSH
22117: LD_INT 1
22119: PPUSH
22120: CALL_OW 259
22124: PUSH
22125: LD_REAL  1.15000000000000E+0000
22128: MUL
22129: MUL
22130: ST_TO_ADDR
// end ; unit_vehicle :
22131: GO 22959
22133: LD_INT 2
22135: DOUBLE
22136: EQUAL
22137: IFTRUE 22141
22139: GO 22947
22141: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22142: LD_VAR 0 6
22146: PPUSH
22147: CALL_OW 264
22151: PUSH
22152: LD_INT 2
22154: PUSH
22155: LD_INT 42
22157: PUSH
22158: LD_INT 24
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: LIST
22165: IN
22166: IFFALSE 22187
// points := [ 25 , 5 , 3 ] ;
22168: LD_ADDR_VAR 0 9
22172: PUSH
22173: LD_INT 25
22175: PUSH
22176: LD_INT 5
22178: PUSH
22179: LD_INT 3
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: LIST
22186: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22187: LD_VAR 0 6
22191: PPUSH
22192: CALL_OW 264
22196: PUSH
22197: LD_INT 4
22199: PUSH
22200: LD_INT 43
22202: PUSH
22203: LD_INT 25
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: IN
22211: IFFALSE 22232
// points := [ 40 , 15 , 5 ] ;
22213: LD_ADDR_VAR 0 9
22217: PUSH
22218: LD_INT 40
22220: PUSH
22221: LD_INT 15
22223: PUSH
22224: LD_INT 5
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: LIST
22231: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22232: LD_VAR 0 6
22236: PPUSH
22237: CALL_OW 264
22241: PUSH
22242: LD_INT 3
22244: PUSH
22245: LD_INT 23
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: IN
22252: IFFALSE 22273
// points := [ 7 , 25 , 8 ] ;
22254: LD_ADDR_VAR 0 9
22258: PUSH
22259: LD_INT 7
22261: PUSH
22262: LD_INT 25
22264: PUSH
22265: LD_INT 8
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: LIST
22272: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22273: LD_VAR 0 6
22277: PPUSH
22278: CALL_OW 264
22282: PUSH
22283: LD_INT 5
22285: PUSH
22286: LD_INT 27
22288: PUSH
22289: LD_INT 44
22291: PUSH
22292: EMPTY
22293: LIST
22294: LIST
22295: LIST
22296: IN
22297: IFFALSE 22318
// points := [ 14 , 50 , 16 ] ;
22299: LD_ADDR_VAR 0 9
22303: PUSH
22304: LD_INT 14
22306: PUSH
22307: LD_INT 50
22309: PUSH
22310: LD_INT 16
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: LIST
22317: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22318: LD_VAR 0 6
22322: PPUSH
22323: CALL_OW 264
22327: PUSH
22328: LD_INT 6
22330: PUSH
22331: LD_INT 46
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: IN
22338: IFFALSE 22359
// points := [ 32 , 120 , 70 ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: LD_INT 32
22347: PUSH
22348: LD_INT 120
22350: PUSH
22351: LD_INT 70
22353: PUSH
22354: EMPTY
22355: LIST
22356: LIST
22357: LIST
22358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 7
22371: PUSH
22372: LD_INT 28
22374: PUSH
22375: LD_INT 45
22377: PUSH
22378: LD_INT 92
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: IN
22387: IFFALSE 22408
// points := [ 35 , 20 , 45 ] ;
22389: LD_ADDR_VAR 0 9
22393: PUSH
22394: LD_INT 35
22396: PUSH
22397: LD_INT 20
22399: PUSH
22400: LD_INT 45
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: LIST
22407: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22408: LD_VAR 0 6
22412: PPUSH
22413: CALL_OW 264
22417: PUSH
22418: LD_INT 47
22420: PUSH
22421: EMPTY
22422: LIST
22423: IN
22424: IFFALSE 22445
// points := [ 67 , 45 , 75 ] ;
22426: LD_ADDR_VAR 0 9
22430: PUSH
22431: LD_INT 67
22433: PUSH
22434: LD_INT 45
22436: PUSH
22437: LD_INT 75
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: LIST
22444: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22445: LD_VAR 0 6
22449: PPUSH
22450: CALL_OW 264
22454: PUSH
22455: LD_INT 26
22457: PUSH
22458: EMPTY
22459: LIST
22460: IN
22461: IFFALSE 22482
// points := [ 120 , 30 , 80 ] ;
22463: LD_ADDR_VAR 0 9
22467: PUSH
22468: LD_INT 120
22470: PUSH
22471: LD_INT 30
22473: PUSH
22474: LD_INT 80
22476: PUSH
22477: EMPTY
22478: LIST
22479: LIST
22480: LIST
22481: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22482: LD_VAR 0 6
22486: PPUSH
22487: CALL_OW 264
22491: PUSH
22492: LD_INT 22
22494: PUSH
22495: EMPTY
22496: LIST
22497: IN
22498: IFFALSE 22519
// points := [ 40 , 1 , 1 ] ;
22500: LD_ADDR_VAR 0 9
22504: PUSH
22505: LD_INT 40
22507: PUSH
22508: LD_INT 1
22510: PUSH
22511: LD_INT 1
22513: PUSH
22514: EMPTY
22515: LIST
22516: LIST
22517: LIST
22518: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22519: LD_VAR 0 6
22523: PPUSH
22524: CALL_OW 264
22528: PUSH
22529: LD_INT 29
22531: PUSH
22532: EMPTY
22533: LIST
22534: IN
22535: IFFALSE 22556
// points := [ 70 , 200 , 400 ] ;
22537: LD_ADDR_VAR 0 9
22541: PUSH
22542: LD_INT 70
22544: PUSH
22545: LD_INT 200
22547: PUSH
22548: LD_INT 400
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: LIST
22555: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22556: LD_VAR 0 6
22560: PPUSH
22561: CALL_OW 264
22565: PUSH
22566: LD_INT 14
22568: PUSH
22569: LD_INT 53
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: IN
22576: IFFALSE 22597
// points := [ 40 , 10 , 20 ] ;
22578: LD_ADDR_VAR 0 9
22582: PUSH
22583: LD_INT 40
22585: PUSH
22586: LD_INT 10
22588: PUSH
22589: LD_INT 20
22591: PUSH
22592: EMPTY
22593: LIST
22594: LIST
22595: LIST
22596: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22597: LD_VAR 0 6
22601: PPUSH
22602: CALL_OW 264
22606: PUSH
22607: LD_INT 9
22609: PUSH
22610: EMPTY
22611: LIST
22612: IN
22613: IFFALSE 22634
// points := [ 5 , 70 , 20 ] ;
22615: LD_ADDR_VAR 0 9
22619: PUSH
22620: LD_INT 5
22622: PUSH
22623: LD_INT 70
22625: PUSH
22626: LD_INT 20
22628: PUSH
22629: EMPTY
22630: LIST
22631: LIST
22632: LIST
22633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22634: LD_VAR 0 6
22638: PPUSH
22639: CALL_OW 264
22643: PUSH
22644: LD_INT 10
22646: PUSH
22647: EMPTY
22648: LIST
22649: IN
22650: IFFALSE 22671
// points := [ 35 , 110 , 70 ] ;
22652: LD_ADDR_VAR 0 9
22656: PUSH
22657: LD_INT 35
22659: PUSH
22660: LD_INT 110
22662: PUSH
22663: LD_INT 70
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22671: LD_VAR 0 6
22675: PPUSH
22676: CALL_OW 265
22680: PUSH
22681: LD_INT 25
22683: EQUAL
22684: IFFALSE 22705
// points := [ 80 , 65 , 100 ] ;
22686: LD_ADDR_VAR 0 9
22690: PUSH
22691: LD_INT 80
22693: PUSH
22694: LD_INT 65
22696: PUSH
22697: LD_INT 100
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22705: LD_VAR 0 6
22709: PPUSH
22710: CALL_OW 263
22714: PUSH
22715: LD_INT 1
22717: EQUAL
22718: IFFALSE 22753
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22720: LD_ADDR_VAR 0 10
22724: PUSH
22725: LD_VAR 0 10
22729: PUSH
22730: LD_VAR 0 6
22734: PPUSH
22735: CALL_OW 311
22739: PPUSH
22740: LD_INT 3
22742: PPUSH
22743: CALL_OW 259
22747: PUSH
22748: LD_INT 4
22750: MUL
22751: MUL
22752: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22753: LD_VAR 0 6
22757: PPUSH
22758: CALL_OW 263
22762: PUSH
22763: LD_INT 2
22765: EQUAL
22766: IFFALSE 22817
// begin j := IsControledBy ( i ) ;
22768: LD_ADDR_VAR 0 7
22772: PUSH
22773: LD_VAR 0 6
22777: PPUSH
22778: CALL_OW 312
22782: ST_TO_ADDR
// if j then
22783: LD_VAR 0 7
22787: IFFALSE 22817
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22789: LD_ADDR_VAR 0 10
22793: PUSH
22794: LD_VAR 0 10
22798: PUSH
22799: LD_VAR 0 7
22803: PPUSH
22804: LD_INT 3
22806: PPUSH
22807: CALL_OW 259
22811: PUSH
22812: LD_INT 3
22814: MUL
22815: MUL
22816: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22817: LD_VAR 0 6
22821: PPUSH
22822: CALL_OW 264
22826: PUSH
22827: LD_INT 5
22829: PUSH
22830: LD_INT 6
22832: PUSH
22833: LD_INT 46
22835: PUSH
22836: LD_INT 44
22838: PUSH
22839: LD_INT 47
22841: PUSH
22842: LD_INT 45
22844: PUSH
22845: LD_INT 28
22847: PUSH
22848: LD_INT 7
22850: PUSH
22851: LD_INT 27
22853: PUSH
22854: LD_INT 29
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: LIST
22865: LIST
22866: LIST
22867: LIST
22868: IN
22869: PUSH
22870: LD_VAR 0 1
22874: PPUSH
22875: LD_INT 52
22877: PPUSH
22878: CALL_OW 321
22882: PUSH
22883: LD_INT 2
22885: EQUAL
22886: AND
22887: IFFALSE 22904
// bpoints := bpoints * 1.2 ;
22889: LD_ADDR_VAR 0 10
22893: PUSH
22894: LD_VAR 0 10
22898: PUSH
22899: LD_REAL  1.20000000000000E+0000
22902: MUL
22903: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22904: LD_VAR 0 6
22908: PPUSH
22909: CALL_OW 264
22913: PUSH
22914: LD_INT 6
22916: PUSH
22917: LD_INT 46
22919: PUSH
22920: LD_INT 47
22922: PUSH
22923: EMPTY
22924: LIST
22925: LIST
22926: LIST
22927: IN
22928: IFFALSE 22945
// bpoints := bpoints * 1.2 ;
22930: LD_ADDR_VAR 0 10
22934: PUSH
22935: LD_VAR 0 10
22939: PUSH
22940: LD_REAL  1.20000000000000E+0000
22943: MUL
22944: ST_TO_ADDR
// end ; unit_building :
22945: GO 22959
22947: LD_INT 3
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22958
22955: POP
// ; end ;
22956: GO 22959
22958: POP
// for j = 1 to 3 do
22959: LD_ADDR_VAR 0 7
22963: PUSH
22964: DOUBLE
22965: LD_INT 1
22967: DEC
22968: ST_TO_ADDR
22969: LD_INT 3
22971: PUSH
22972: FOR_TO
22973: IFFALSE 23026
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22975: LD_ADDR_VAR 0 5
22979: PUSH
22980: LD_VAR 0 5
22984: PPUSH
22985: LD_VAR 0 7
22989: PPUSH
22990: LD_VAR 0 5
22994: PUSH
22995: LD_VAR 0 7
22999: ARRAY
23000: PUSH
23001: LD_VAR 0 9
23005: PUSH
23006: LD_VAR 0 7
23010: ARRAY
23011: PUSH
23012: LD_VAR 0 10
23016: MUL
23017: PLUS
23018: PPUSH
23019: CALL_OW 1
23023: ST_TO_ADDR
23024: GO 22972
23026: POP
23027: POP
// end ;
23028: GO 21507
23030: POP
23031: POP
// result := Replace ( result , 4 , tmp ) ;
23032: LD_ADDR_VAR 0 5
23036: PUSH
23037: LD_VAR 0 5
23041: PPUSH
23042: LD_INT 4
23044: PPUSH
23045: LD_VAR 0 8
23049: PPUSH
23050: CALL_OW 1
23054: ST_TO_ADDR
// end ;
23055: LD_VAR 0 5
23059: RET
// export function DangerAtRange ( unit , range ) ; begin
23060: LD_INT 0
23062: PPUSH
// if not unit then
23063: LD_VAR 0 1
23067: NOT
23068: IFFALSE 23072
// exit ;
23070: GO 23117
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23072: LD_ADDR_VAR 0 3
23076: PUSH
23077: LD_VAR 0 1
23081: PPUSH
23082: CALL_OW 255
23086: PPUSH
23087: LD_VAR 0 1
23091: PPUSH
23092: CALL_OW 250
23096: PPUSH
23097: LD_VAR 0 1
23101: PPUSH
23102: CALL_OW 251
23106: PPUSH
23107: LD_VAR 0 2
23111: PPUSH
23112: CALL 21359 0 4
23116: ST_TO_ADDR
// end ;
23117: LD_VAR 0 3
23121: RET
// export function DangerInArea ( side , area ) ; begin
23122: LD_INT 0
23124: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23125: LD_ADDR_VAR 0 3
23129: PUSH
23130: LD_VAR 0 2
23134: PPUSH
23135: LD_INT 81
23137: PUSH
23138: LD_VAR 0 1
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PPUSH
23147: CALL_OW 70
23151: ST_TO_ADDR
// end ;
23152: LD_VAR 0 3
23156: RET
// export function IsExtension ( b ) ; begin
23157: LD_INT 0
23159: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23160: LD_ADDR_VAR 0 2
23164: PUSH
23165: LD_VAR 0 1
23169: PUSH
23170: LD_INT 23
23172: PUSH
23173: LD_INT 20
23175: PUSH
23176: LD_INT 22
23178: PUSH
23179: LD_INT 17
23181: PUSH
23182: LD_INT 24
23184: PUSH
23185: LD_INT 21
23187: PUSH
23188: LD_INT 19
23190: PUSH
23191: LD_INT 16
23193: PUSH
23194: LD_INT 25
23196: PUSH
23197: LD_INT 18
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: LIST
23208: LIST
23209: LIST
23210: LIST
23211: IN
23212: ST_TO_ADDR
// end ;
23213: LD_VAR 0 2
23217: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
23218: LD_INT 0
23220: PPUSH
23221: PPUSH
23222: PPUSH
// result := [ ] ;
23223: LD_ADDR_VAR 0 4
23227: PUSH
23228: EMPTY
23229: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23230: LD_ADDR_VAR 0 5
23234: PUSH
23235: LD_VAR 0 2
23239: PPUSH
23240: LD_INT 21
23242: PUSH
23243: LD_INT 3
23245: PUSH
23246: EMPTY
23247: LIST
23248: LIST
23249: PPUSH
23250: CALL_OW 70
23254: ST_TO_ADDR
// if not tmp then
23255: LD_VAR 0 5
23259: NOT
23260: IFFALSE 23264
// exit ;
23262: GO 23328
// if checkLink then
23264: LD_VAR 0 3
23268: IFFALSE 23318
// begin for i in tmp do
23270: LD_ADDR_VAR 0 6
23274: PUSH
23275: LD_VAR 0 5
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23316
// if GetBase ( i ) <> base then
23283: LD_VAR 0 6
23287: PPUSH
23288: CALL_OW 274
23292: PUSH
23293: LD_VAR 0 1
23297: NONEQUAL
23298: IFFALSE 23314
// ComLinkToBase ( base , i ) ;
23300: LD_VAR 0 1
23304: PPUSH
23305: LD_VAR 0 6
23309: PPUSH
23310: CALL_OW 169
23314: GO 23280
23316: POP
23317: POP
// end ; result := tmp ;
23318: LD_ADDR_VAR 0 4
23322: PUSH
23323: LD_VAR 0 5
23327: ST_TO_ADDR
// end ;
23328: LD_VAR 0 4
23332: RET
// export function ComComplete ( units , b ) ; var i ; begin
23333: LD_INT 0
23335: PPUSH
23336: PPUSH
// if not units then
23337: LD_VAR 0 1
23341: NOT
23342: IFFALSE 23346
// exit ;
23344: GO 23436
// for i in units do
23346: LD_ADDR_VAR 0 4
23350: PUSH
23351: LD_VAR 0 1
23355: PUSH
23356: FOR_IN
23357: IFFALSE 23434
// if BuildingStatus ( b ) = bs_build then
23359: LD_VAR 0 2
23363: PPUSH
23364: CALL_OW 461
23368: PUSH
23369: LD_INT 1
23371: EQUAL
23372: IFFALSE 23432
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23374: LD_VAR 0 4
23378: PPUSH
23379: LD_STRING h
23381: PUSH
23382: LD_VAR 0 2
23386: PPUSH
23387: CALL_OW 250
23391: PUSH
23392: LD_VAR 0 2
23396: PPUSH
23397: CALL_OW 251
23401: PUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 0
23409: PUSH
23410: LD_INT 0
23412: PUSH
23413: LD_INT 0
23415: PUSH
23416: EMPTY
23417: LIST
23418: LIST
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: LIST
23424: PUSH
23425: EMPTY
23426: LIST
23427: PPUSH
23428: CALL_OW 446
23432: GO 23356
23434: POP
23435: POP
// end ;
23436: LD_VAR 0 3
23440: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23441: LD_INT 0
23443: PPUSH
23444: PPUSH
23445: PPUSH
23446: PPUSH
23447: PPUSH
23448: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23449: LD_VAR 0 1
23453: NOT
23454: PUSH
23455: LD_VAR 0 1
23459: PPUSH
23460: CALL_OW 263
23464: PUSH
23465: LD_INT 2
23467: NONEQUAL
23468: OR
23469: IFFALSE 23473
// exit ;
23471: GO 23789
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23473: LD_ADDR_VAR 0 6
23477: PUSH
23478: LD_INT 22
23480: PUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: CALL_OW 255
23490: PUSH
23491: EMPTY
23492: LIST
23493: LIST
23494: PUSH
23495: LD_INT 2
23497: PUSH
23498: LD_INT 30
23500: PUSH
23501: LD_INT 36
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: LD_INT 34
23510: PUSH
23511: LD_INT 31
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: PUSH
23518: EMPTY
23519: LIST
23520: LIST
23521: LIST
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: PPUSH
23527: CALL_OW 69
23531: ST_TO_ADDR
// if not tmp then
23532: LD_VAR 0 6
23536: NOT
23537: IFFALSE 23541
// exit ;
23539: GO 23789
// result := [ ] ;
23541: LD_ADDR_VAR 0 2
23545: PUSH
23546: EMPTY
23547: ST_TO_ADDR
// for i in tmp do
23548: LD_ADDR_VAR 0 3
23552: PUSH
23553: LD_VAR 0 6
23557: PUSH
23558: FOR_IN
23559: IFFALSE 23630
// begin t := UnitsInside ( i ) ;
23561: LD_ADDR_VAR 0 4
23565: PUSH
23566: LD_VAR 0 3
23570: PPUSH
23571: CALL_OW 313
23575: ST_TO_ADDR
// if t then
23576: LD_VAR 0 4
23580: IFFALSE 23628
// for j in t do
23582: LD_ADDR_VAR 0 7
23586: PUSH
23587: LD_VAR 0 4
23591: PUSH
23592: FOR_IN
23593: IFFALSE 23626
// result := Replace ( result , result + 1 , j ) ;
23595: LD_ADDR_VAR 0 2
23599: PUSH
23600: LD_VAR 0 2
23604: PPUSH
23605: LD_VAR 0 2
23609: PUSH
23610: LD_INT 1
23612: PLUS
23613: PPUSH
23614: LD_VAR 0 7
23618: PPUSH
23619: CALL_OW 1
23623: ST_TO_ADDR
23624: GO 23592
23626: POP
23627: POP
// end ;
23628: GO 23558
23630: POP
23631: POP
// if not result then
23632: LD_VAR 0 2
23636: NOT
23637: IFFALSE 23641
// exit ;
23639: GO 23789
// mech := result [ 1 ] ;
23641: LD_ADDR_VAR 0 5
23645: PUSH
23646: LD_VAR 0 2
23650: PUSH
23651: LD_INT 1
23653: ARRAY
23654: ST_TO_ADDR
// if result > 1 then
23655: LD_VAR 0 2
23659: PUSH
23660: LD_INT 1
23662: GREATER
23663: IFFALSE 23775
// begin for i = 2 to result do
23665: LD_ADDR_VAR 0 3
23669: PUSH
23670: DOUBLE
23671: LD_INT 2
23673: DEC
23674: ST_TO_ADDR
23675: LD_VAR 0 2
23679: PUSH
23680: FOR_TO
23681: IFFALSE 23773
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23683: LD_ADDR_VAR 0 4
23687: PUSH
23688: LD_VAR 0 2
23692: PUSH
23693: LD_VAR 0 3
23697: ARRAY
23698: PPUSH
23699: LD_INT 3
23701: PPUSH
23702: CALL_OW 259
23706: PUSH
23707: LD_VAR 0 2
23711: PUSH
23712: LD_VAR 0 3
23716: ARRAY
23717: PPUSH
23718: CALL_OW 432
23722: MINUS
23723: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23724: LD_VAR 0 4
23728: PUSH
23729: LD_VAR 0 5
23733: PPUSH
23734: LD_INT 3
23736: PPUSH
23737: CALL_OW 259
23741: PUSH
23742: LD_VAR 0 5
23746: PPUSH
23747: CALL_OW 432
23751: MINUS
23752: GREATEREQUAL
23753: IFFALSE 23771
// mech := result [ i ] ;
23755: LD_ADDR_VAR 0 5
23759: PUSH
23760: LD_VAR 0 2
23764: PUSH
23765: LD_VAR 0 3
23769: ARRAY
23770: ST_TO_ADDR
// end ;
23771: GO 23680
23773: POP
23774: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23775: LD_VAR 0 1
23779: PPUSH
23780: LD_VAR 0 5
23784: PPUSH
23785: CALL_OW 135
// end ;
23789: LD_VAR 0 2
23793: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23794: LD_INT 0
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
23803: PPUSH
23804: PPUSH
23805: PPUSH
23806: PPUSH
23807: PPUSH
23808: PPUSH
// result := [ ] ;
23809: LD_ADDR_VAR 0 7
23813: PUSH
23814: EMPTY
23815: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23816: LD_VAR 0 1
23820: PPUSH
23821: CALL_OW 266
23825: PUSH
23826: LD_INT 0
23828: PUSH
23829: LD_INT 1
23831: PUSH
23832: EMPTY
23833: LIST
23834: LIST
23835: IN
23836: NOT
23837: IFFALSE 23841
// exit ;
23839: GO 25475
// if name then
23841: LD_VAR 0 3
23845: IFFALSE 23861
// SetBName ( base_dep , name ) ;
23847: LD_VAR 0 1
23851: PPUSH
23852: LD_VAR 0 3
23856: PPUSH
23857: CALL_OW 500
// base := GetBase ( base_dep ) ;
23861: LD_ADDR_VAR 0 15
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 274
23875: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23876: LD_ADDR_VAR 0 16
23880: PUSH
23881: LD_VAR 0 1
23885: PPUSH
23886: CALL_OW 255
23890: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23891: LD_ADDR_VAR 0 17
23895: PUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: CALL_OW 248
23905: ST_TO_ADDR
// if sources then
23906: LD_VAR 0 5
23910: IFFALSE 23957
// for i = 1 to 3 do
23912: LD_ADDR_VAR 0 8
23916: PUSH
23917: DOUBLE
23918: LD_INT 1
23920: DEC
23921: ST_TO_ADDR
23922: LD_INT 3
23924: PUSH
23925: FOR_TO
23926: IFFALSE 23955
// AddResourceType ( base , i , sources [ i ] ) ;
23928: LD_VAR 0 15
23932: PPUSH
23933: LD_VAR 0 8
23937: PPUSH
23938: LD_VAR 0 5
23942: PUSH
23943: LD_VAR 0 8
23947: ARRAY
23948: PPUSH
23949: CALL_OW 276
23953: GO 23925
23955: POP
23956: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23957: LD_ADDR_VAR 0 18
23961: PUSH
23962: LD_VAR 0 15
23966: PPUSH
23967: LD_VAR 0 2
23971: PPUSH
23972: LD_INT 1
23974: PPUSH
23975: CALL 23218 0 3
23979: ST_TO_ADDR
// InitHc ;
23980: CALL_OW 19
// InitUc ;
23984: CALL_OW 18
// uc_side := side ;
23988: LD_ADDR_OWVAR 20
23992: PUSH
23993: LD_VAR 0 16
23997: ST_TO_ADDR
// uc_nation := nation ;
23998: LD_ADDR_OWVAR 21
24002: PUSH
24003: LD_VAR 0 17
24007: ST_TO_ADDR
// if buildings then
24008: LD_VAR 0 18
24012: IFFALSE 25334
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24014: LD_ADDR_VAR 0 19
24018: PUSH
24019: LD_VAR 0 18
24023: PPUSH
24024: LD_INT 2
24026: PUSH
24027: LD_INT 30
24029: PUSH
24030: LD_INT 29
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: LD_INT 30
24039: PUSH
24040: LD_INT 30
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: LIST
24051: PPUSH
24052: CALL_OW 72
24056: ST_TO_ADDR
// if tmp then
24057: LD_VAR 0 19
24061: IFFALSE 24109
// for i in tmp do
24063: LD_ADDR_VAR 0 8
24067: PUSH
24068: LD_VAR 0 19
24072: PUSH
24073: FOR_IN
24074: IFFALSE 24107
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24076: LD_VAR 0 8
24080: PPUSH
24081: CALL_OW 250
24085: PPUSH
24086: LD_VAR 0 8
24090: PPUSH
24091: CALL_OW 251
24095: PPUSH
24096: LD_VAR 0 16
24100: PPUSH
24101: CALL_OW 441
24105: GO 24073
24107: POP
24108: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24109: LD_VAR 0 18
24113: PPUSH
24114: LD_INT 2
24116: PUSH
24117: LD_INT 30
24119: PUSH
24120: LD_INT 32
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 30
24129: PUSH
24130: LD_INT 33
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: LIST
24141: PPUSH
24142: CALL_OW 72
24146: IFFALSE 24234
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24148: LD_ADDR_VAR 0 8
24152: PUSH
24153: LD_VAR 0 18
24157: PPUSH
24158: LD_INT 2
24160: PUSH
24161: LD_INT 30
24163: PUSH
24164: LD_INT 32
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: LD_INT 30
24173: PUSH
24174: LD_INT 33
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: EMPTY
24182: LIST
24183: LIST
24184: LIST
24185: PPUSH
24186: CALL_OW 72
24190: PUSH
24191: FOR_IN
24192: IFFALSE 24232
// begin if not GetBWeapon ( i ) then
24194: LD_VAR 0 8
24198: PPUSH
24199: CALL_OW 269
24203: NOT
24204: IFFALSE 24230
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24206: LD_VAR 0 8
24210: PPUSH
24211: LD_VAR 0 8
24215: PPUSH
24216: LD_VAR 0 2
24220: PPUSH
24221: CALL 25480 0 2
24225: PPUSH
24226: CALL_OW 431
// end ;
24230: GO 24191
24232: POP
24233: POP
// end ; for i = 1 to personel do
24234: LD_ADDR_VAR 0 8
24238: PUSH
24239: DOUBLE
24240: LD_INT 1
24242: DEC
24243: ST_TO_ADDR
24244: LD_VAR 0 6
24248: PUSH
24249: FOR_TO
24250: IFFALSE 25314
// begin if i > 4 then
24252: LD_VAR 0 8
24256: PUSH
24257: LD_INT 4
24259: GREATER
24260: IFFALSE 24264
// break ;
24262: GO 25314
// case i of 1 :
24264: LD_VAR 0 8
24268: PUSH
24269: LD_INT 1
24271: DOUBLE
24272: EQUAL
24273: IFTRUE 24277
24275: GO 24357
24277: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24278: LD_ADDR_VAR 0 12
24282: PUSH
24283: LD_VAR 0 18
24287: PPUSH
24288: LD_INT 22
24290: PUSH
24291: LD_VAR 0 16
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: LD_INT 58
24302: PUSH
24303: EMPTY
24304: LIST
24305: PUSH
24306: LD_INT 2
24308: PUSH
24309: LD_INT 30
24311: PUSH
24312: LD_INT 32
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 30
24321: PUSH
24322: LD_INT 4
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 30
24331: PUSH
24332: LD_INT 5
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: LIST
24349: PPUSH
24350: CALL_OW 72
24354: ST_TO_ADDR
24355: GO 24579
24357: LD_INT 2
24359: DOUBLE
24360: EQUAL
24361: IFTRUE 24365
24363: GO 24427
24365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24366: LD_ADDR_VAR 0 12
24370: PUSH
24371: LD_VAR 0 18
24375: PPUSH
24376: LD_INT 22
24378: PUSH
24379: LD_VAR 0 16
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: LD_INT 2
24390: PUSH
24391: LD_INT 30
24393: PUSH
24394: LD_INT 0
24396: PUSH
24397: EMPTY
24398: LIST
24399: LIST
24400: PUSH
24401: LD_INT 30
24403: PUSH
24404: LD_INT 1
24406: PUSH
24407: EMPTY
24408: LIST
24409: LIST
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: LIST
24415: PUSH
24416: EMPTY
24417: LIST
24418: LIST
24419: PPUSH
24420: CALL_OW 72
24424: ST_TO_ADDR
24425: GO 24579
24427: LD_INT 3
24429: DOUBLE
24430: EQUAL
24431: IFTRUE 24435
24433: GO 24497
24435: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24436: LD_ADDR_VAR 0 12
24440: PUSH
24441: LD_VAR 0 18
24445: PPUSH
24446: LD_INT 22
24448: PUSH
24449: LD_VAR 0 16
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PUSH
24458: LD_INT 2
24460: PUSH
24461: LD_INT 30
24463: PUSH
24464: LD_INT 2
24466: PUSH
24467: EMPTY
24468: LIST
24469: LIST
24470: PUSH
24471: LD_INT 30
24473: PUSH
24474: LD_INT 3
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: LIST
24485: PUSH
24486: EMPTY
24487: LIST
24488: LIST
24489: PPUSH
24490: CALL_OW 72
24494: ST_TO_ADDR
24495: GO 24579
24497: LD_INT 4
24499: DOUBLE
24500: EQUAL
24501: IFTRUE 24505
24503: GO 24578
24505: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24506: LD_ADDR_VAR 0 12
24510: PUSH
24511: LD_VAR 0 18
24515: PPUSH
24516: LD_INT 22
24518: PUSH
24519: LD_VAR 0 16
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: PUSH
24528: LD_INT 2
24530: PUSH
24531: LD_INT 30
24533: PUSH
24534: LD_INT 6
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 30
24543: PUSH
24544: LD_INT 7
24546: PUSH
24547: EMPTY
24548: LIST
24549: LIST
24550: PUSH
24551: LD_INT 30
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PPUSH
24571: CALL_OW 72
24575: ST_TO_ADDR
24576: GO 24579
24578: POP
// if i = 1 then
24579: LD_VAR 0 8
24583: PUSH
24584: LD_INT 1
24586: EQUAL
24587: IFFALSE 24698
// begin tmp := [ ] ;
24589: LD_ADDR_VAR 0 19
24593: PUSH
24594: EMPTY
24595: ST_TO_ADDR
// for j in f do
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 12
24605: PUSH
24606: FOR_IN
24607: IFFALSE 24680
// if GetBType ( j ) = b_bunker then
24609: LD_VAR 0 9
24613: PPUSH
24614: CALL_OW 266
24618: PUSH
24619: LD_INT 32
24621: EQUAL
24622: IFFALSE 24649
// tmp := Insert ( tmp , 1 , j ) else
24624: LD_ADDR_VAR 0 19
24628: PUSH
24629: LD_VAR 0 19
24633: PPUSH
24634: LD_INT 1
24636: PPUSH
24637: LD_VAR 0 9
24641: PPUSH
24642: CALL_OW 2
24646: ST_TO_ADDR
24647: GO 24678
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24649: LD_ADDR_VAR 0 19
24653: PUSH
24654: LD_VAR 0 19
24658: PPUSH
24659: LD_VAR 0 19
24663: PUSH
24664: LD_INT 1
24666: PLUS
24667: PPUSH
24668: LD_VAR 0 9
24672: PPUSH
24673: CALL_OW 2
24677: ST_TO_ADDR
24678: GO 24606
24680: POP
24681: POP
// if tmp then
24682: LD_VAR 0 19
24686: IFFALSE 24698
// f := tmp ;
24688: LD_ADDR_VAR 0 12
24692: PUSH
24693: LD_VAR 0 19
24697: ST_TO_ADDR
// end ; x := personel [ i ] ;
24698: LD_ADDR_VAR 0 13
24702: PUSH
24703: LD_VAR 0 6
24707: PUSH
24708: LD_VAR 0 8
24712: ARRAY
24713: ST_TO_ADDR
// if x = - 1 then
24714: LD_VAR 0 13
24718: PUSH
24719: LD_INT 1
24721: NEG
24722: EQUAL
24723: IFFALSE 24932
// begin for j in f do
24725: LD_ADDR_VAR 0 9
24729: PUSH
24730: LD_VAR 0 12
24734: PUSH
24735: FOR_IN
24736: IFFALSE 24928
// repeat InitHc ;
24738: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24742: LD_VAR 0 9
24746: PPUSH
24747: CALL_OW 266
24751: PUSH
24752: LD_INT 5
24754: EQUAL
24755: IFFALSE 24825
// begin if UnitsInside ( j ) < 3 then
24757: LD_VAR 0 9
24761: PPUSH
24762: CALL_OW 313
24766: PUSH
24767: LD_INT 3
24769: LESS
24770: IFFALSE 24806
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24772: LD_INT 0
24774: PPUSH
24775: LD_INT 5
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: LD_INT 9
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_VAR 0 17
24793: ARRAY
24794: PPUSH
24795: LD_VAR 0 4
24799: PPUSH
24800: CALL_OW 380
24804: GO 24823
// PrepareHuman ( false , i , skill ) ;
24806: LD_INT 0
24808: PPUSH
24809: LD_VAR 0 8
24813: PPUSH
24814: LD_VAR 0 4
24818: PPUSH
24819: CALL_OW 380
// end else
24823: GO 24842
// PrepareHuman ( false , i , skill ) ;
24825: LD_INT 0
24827: PPUSH
24828: LD_VAR 0 8
24832: PPUSH
24833: LD_VAR 0 4
24837: PPUSH
24838: CALL_OW 380
// un := CreateHuman ;
24842: LD_ADDR_VAR 0 14
24846: PUSH
24847: CALL_OW 44
24851: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24852: LD_ADDR_VAR 0 7
24856: PUSH
24857: LD_VAR 0 7
24861: PPUSH
24862: LD_INT 1
24864: PPUSH
24865: LD_VAR 0 14
24869: PPUSH
24870: CALL_OW 2
24874: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24875: LD_VAR 0 14
24879: PPUSH
24880: LD_VAR 0 9
24884: PPUSH
24885: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24889: LD_VAR 0 9
24893: PPUSH
24894: CALL_OW 313
24898: PUSH
24899: LD_INT 6
24901: EQUAL
24902: PUSH
24903: LD_VAR 0 9
24907: PPUSH
24908: CALL_OW 266
24912: PUSH
24913: LD_INT 32
24915: PUSH
24916: LD_INT 31
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: IN
24923: OR
24924: IFFALSE 24738
24926: GO 24735
24928: POP
24929: POP
// end else
24930: GO 25312
// for j = 1 to x do
24932: LD_ADDR_VAR 0 9
24936: PUSH
24937: DOUBLE
24938: LD_INT 1
24940: DEC
24941: ST_TO_ADDR
24942: LD_VAR 0 13
24946: PUSH
24947: FOR_TO
24948: IFFALSE 25310
// begin InitHc ;
24950: CALL_OW 19
// if not f then
24954: LD_VAR 0 12
24958: NOT
24959: IFFALSE 25048
// begin PrepareHuman ( false , i , skill ) ;
24961: LD_INT 0
24963: PPUSH
24964: LD_VAR 0 8
24968: PPUSH
24969: LD_VAR 0 4
24973: PPUSH
24974: CALL_OW 380
// un := CreateHuman ;
24978: LD_ADDR_VAR 0 14
24982: PUSH
24983: CALL_OW 44
24987: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24988: LD_ADDR_VAR 0 7
24992: PUSH
24993: LD_VAR 0 7
24997: PPUSH
24998: LD_INT 1
25000: PPUSH
25001: LD_VAR 0 14
25005: PPUSH
25006: CALL_OW 2
25010: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25011: LD_VAR 0 14
25015: PPUSH
25016: LD_VAR 0 1
25020: PPUSH
25021: CALL_OW 250
25025: PPUSH
25026: LD_VAR 0 1
25030: PPUSH
25031: CALL_OW 251
25035: PPUSH
25036: LD_INT 10
25038: PPUSH
25039: LD_INT 0
25041: PPUSH
25042: CALL_OW 50
// continue ;
25046: GO 24947
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25048: LD_VAR 0 12
25052: PUSH
25053: LD_INT 1
25055: ARRAY
25056: PPUSH
25057: CALL_OW 313
25061: PUSH
25062: LD_VAR 0 12
25066: PUSH
25067: LD_INT 1
25069: ARRAY
25070: PPUSH
25071: CALL_OW 266
25075: PUSH
25076: LD_INT 32
25078: PUSH
25079: LD_INT 31
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: IN
25086: AND
25087: PUSH
25088: LD_VAR 0 12
25092: PUSH
25093: LD_INT 1
25095: ARRAY
25096: PPUSH
25097: CALL_OW 313
25101: PUSH
25102: LD_INT 6
25104: EQUAL
25105: OR
25106: IFFALSE 25126
// f := Delete ( f , 1 ) ;
25108: LD_ADDR_VAR 0 12
25112: PUSH
25113: LD_VAR 0 12
25117: PPUSH
25118: LD_INT 1
25120: PPUSH
25121: CALL_OW 3
25125: ST_TO_ADDR
// if not f then
25126: LD_VAR 0 12
25130: NOT
25131: IFFALSE 25149
// begin x := x + 2 ;
25133: LD_ADDR_VAR 0 13
25137: PUSH
25138: LD_VAR 0 13
25142: PUSH
25143: LD_INT 2
25145: PLUS
25146: ST_TO_ADDR
// continue ;
25147: GO 24947
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25149: LD_VAR 0 12
25153: PUSH
25154: LD_INT 1
25156: ARRAY
25157: PPUSH
25158: CALL_OW 266
25162: PUSH
25163: LD_INT 5
25165: EQUAL
25166: IFFALSE 25240
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25168: LD_VAR 0 12
25172: PUSH
25173: LD_INT 1
25175: ARRAY
25176: PPUSH
25177: CALL_OW 313
25181: PUSH
25182: LD_INT 3
25184: LESS
25185: IFFALSE 25221
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25187: LD_INT 0
25189: PPUSH
25190: LD_INT 5
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: LD_INT 9
25198: PUSH
25199: EMPTY
25200: LIST
25201: LIST
25202: LIST
25203: PUSH
25204: LD_VAR 0 17
25208: ARRAY
25209: PPUSH
25210: LD_VAR 0 4
25214: PPUSH
25215: CALL_OW 380
25219: GO 25238
// PrepareHuman ( false , i , skill ) ;
25221: LD_INT 0
25223: PPUSH
25224: LD_VAR 0 8
25228: PPUSH
25229: LD_VAR 0 4
25233: PPUSH
25234: CALL_OW 380
// end else
25238: GO 25257
// PrepareHuman ( false , i , skill ) ;
25240: LD_INT 0
25242: PPUSH
25243: LD_VAR 0 8
25247: PPUSH
25248: LD_VAR 0 4
25252: PPUSH
25253: CALL_OW 380
// un := CreateHuman ;
25257: LD_ADDR_VAR 0 14
25261: PUSH
25262: CALL_OW 44
25266: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25267: LD_ADDR_VAR 0 7
25271: PUSH
25272: LD_VAR 0 7
25276: PPUSH
25277: LD_INT 1
25279: PPUSH
25280: LD_VAR 0 14
25284: PPUSH
25285: CALL_OW 2
25289: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25290: LD_VAR 0 14
25294: PPUSH
25295: LD_VAR 0 12
25299: PUSH
25300: LD_INT 1
25302: ARRAY
25303: PPUSH
25304: CALL_OW 52
// end ;
25308: GO 24947
25310: POP
25311: POP
// end ;
25312: GO 24249
25314: POP
25315: POP
// result := result ^ buildings ;
25316: LD_ADDR_VAR 0 7
25320: PUSH
25321: LD_VAR 0 7
25325: PUSH
25326: LD_VAR 0 18
25330: ADD
25331: ST_TO_ADDR
// end else
25332: GO 25475
// begin for i = 1 to personel do
25334: LD_ADDR_VAR 0 8
25338: PUSH
25339: DOUBLE
25340: LD_INT 1
25342: DEC
25343: ST_TO_ADDR
25344: LD_VAR 0 6
25348: PUSH
25349: FOR_TO
25350: IFFALSE 25473
// begin if i > 4 then
25352: LD_VAR 0 8
25356: PUSH
25357: LD_INT 4
25359: GREATER
25360: IFFALSE 25364
// break ;
25362: GO 25473
// x := personel [ i ] ;
25364: LD_ADDR_VAR 0 13
25368: PUSH
25369: LD_VAR 0 6
25373: PUSH
25374: LD_VAR 0 8
25378: ARRAY
25379: ST_TO_ADDR
// if x = - 1 then
25380: LD_VAR 0 13
25384: PUSH
25385: LD_INT 1
25387: NEG
25388: EQUAL
25389: IFFALSE 25393
// continue ;
25391: GO 25349
// PrepareHuman ( false , i , skill ) ;
25393: LD_INT 0
25395: PPUSH
25396: LD_VAR 0 8
25400: PPUSH
25401: LD_VAR 0 4
25405: PPUSH
25406: CALL_OW 380
// un := CreateHuman ;
25410: LD_ADDR_VAR 0 14
25414: PUSH
25415: CALL_OW 44
25419: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25420: LD_VAR 0 14
25424: PPUSH
25425: LD_VAR 0 1
25429: PPUSH
25430: CALL_OW 250
25434: PPUSH
25435: LD_VAR 0 1
25439: PPUSH
25440: CALL_OW 251
25444: PPUSH
25445: LD_INT 10
25447: PPUSH
25448: LD_INT 0
25450: PPUSH
25451: CALL_OW 50
// result := result ^ un ;
25455: LD_ADDR_VAR 0 7
25459: PUSH
25460: LD_VAR 0 7
25464: PUSH
25465: LD_VAR 0 14
25469: ADD
25470: ST_TO_ADDR
// end ;
25471: GO 25349
25473: POP
25474: POP
// end ; end ;
25475: LD_VAR 0 7
25479: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25480: LD_INT 0
25482: PPUSH
25483: PPUSH
25484: PPUSH
25485: PPUSH
25486: PPUSH
25487: PPUSH
25488: PPUSH
25489: PPUSH
25490: PPUSH
25491: PPUSH
25492: PPUSH
25493: PPUSH
25494: PPUSH
25495: PPUSH
25496: PPUSH
25497: PPUSH
// result := false ;
25498: LD_ADDR_VAR 0 3
25502: PUSH
25503: LD_INT 0
25505: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25506: LD_VAR 0 1
25510: NOT
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 266
25521: PUSH
25522: LD_INT 32
25524: PUSH
25525: LD_INT 33
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: IN
25532: NOT
25533: OR
25534: IFFALSE 25538
// exit ;
25536: GO 26647
// nat := GetNation ( tower ) ;
25538: LD_ADDR_VAR 0 12
25542: PUSH
25543: LD_VAR 0 1
25547: PPUSH
25548: CALL_OW 248
25552: ST_TO_ADDR
// side := GetSide ( tower ) ;
25553: LD_ADDR_VAR 0 16
25557: PUSH
25558: LD_VAR 0 1
25562: PPUSH
25563: CALL_OW 255
25567: ST_TO_ADDR
// x := GetX ( tower ) ;
25568: LD_ADDR_VAR 0 10
25572: PUSH
25573: LD_VAR 0 1
25577: PPUSH
25578: CALL_OW 250
25582: ST_TO_ADDR
// y := GetY ( tower ) ;
25583: LD_ADDR_VAR 0 11
25587: PUSH
25588: LD_VAR 0 1
25592: PPUSH
25593: CALL_OW 251
25597: ST_TO_ADDR
// if not x or not y then
25598: LD_VAR 0 10
25602: NOT
25603: PUSH
25604: LD_VAR 0 11
25608: NOT
25609: OR
25610: IFFALSE 25614
// exit ;
25612: GO 26647
// weapon := 0 ;
25614: LD_ADDR_VAR 0 18
25618: PUSH
25619: LD_INT 0
25621: ST_TO_ADDR
// fac_list := [ ] ;
25622: LD_ADDR_VAR 0 17
25626: PUSH
25627: EMPTY
25628: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25629: LD_ADDR_VAR 0 6
25633: PUSH
25634: LD_VAR 0 1
25638: PPUSH
25639: CALL_OW 274
25643: PPUSH
25644: LD_VAR 0 2
25648: PPUSH
25649: LD_INT 0
25651: PPUSH
25652: CALL 23218 0 3
25656: PPUSH
25657: LD_INT 30
25659: PUSH
25660: LD_INT 3
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PPUSH
25667: CALL_OW 72
25671: ST_TO_ADDR
// if not factories then
25672: LD_VAR 0 6
25676: NOT
25677: IFFALSE 25681
// exit ;
25679: GO 26647
// for i in factories do
25681: LD_ADDR_VAR 0 8
25685: PUSH
25686: LD_VAR 0 6
25690: PUSH
25691: FOR_IN
25692: IFFALSE 25717
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25694: LD_ADDR_VAR 0 17
25698: PUSH
25699: LD_VAR 0 17
25703: PUSH
25704: LD_VAR 0 8
25708: PPUSH
25709: CALL_OW 478
25713: UNION
25714: ST_TO_ADDR
25715: GO 25691
25717: POP
25718: POP
// if not fac_list then
25719: LD_VAR 0 17
25723: NOT
25724: IFFALSE 25728
// exit ;
25726: GO 26647
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25728: LD_ADDR_VAR 0 5
25732: PUSH
25733: LD_INT 4
25735: PUSH
25736: LD_INT 5
25738: PUSH
25739: LD_INT 9
25741: PUSH
25742: LD_INT 10
25744: PUSH
25745: LD_INT 6
25747: PUSH
25748: LD_INT 7
25750: PUSH
25751: LD_INT 11
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: LIST
25758: LIST
25759: LIST
25760: LIST
25761: LIST
25762: PUSH
25763: LD_INT 27
25765: PUSH
25766: LD_INT 28
25768: PUSH
25769: LD_INT 26
25771: PUSH
25772: LD_INT 30
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: LIST
25779: LIST
25780: PUSH
25781: LD_INT 43
25783: PUSH
25784: LD_INT 44
25786: PUSH
25787: LD_INT 46
25789: PUSH
25790: LD_INT 45
25792: PUSH
25793: LD_INT 47
25795: PUSH
25796: LD_INT 49
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: LIST
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: LIST
25811: PUSH
25812: LD_VAR 0 12
25816: ARRAY
25817: ST_TO_ADDR
// list := list isect fac_list ;
25818: LD_ADDR_VAR 0 5
25822: PUSH
25823: LD_VAR 0 5
25827: PUSH
25828: LD_VAR 0 17
25832: ISECT
25833: ST_TO_ADDR
// if not list then
25834: LD_VAR 0 5
25838: NOT
25839: IFFALSE 25843
// exit ;
25841: GO 26647
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25843: LD_VAR 0 12
25847: PUSH
25848: LD_INT 3
25850: EQUAL
25851: PUSH
25852: LD_INT 49
25854: PUSH
25855: LD_VAR 0 5
25859: IN
25860: AND
25861: PUSH
25862: LD_INT 31
25864: PPUSH
25865: LD_VAR 0 16
25869: PPUSH
25870: CALL_OW 321
25874: PUSH
25875: LD_INT 2
25877: EQUAL
25878: AND
25879: IFFALSE 25939
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25881: LD_INT 22
25883: PUSH
25884: LD_VAR 0 16
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 35
25895: PUSH
25896: LD_INT 49
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 91
25905: PUSH
25906: LD_VAR 0 1
25910: PUSH
25911: LD_INT 10
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: LIST
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: LIST
25923: PPUSH
25924: CALL_OW 69
25928: NOT
25929: IFFALSE 25939
// weapon := ru_time_lapser ;
25931: LD_ADDR_VAR 0 18
25935: PUSH
25936: LD_INT 49
25938: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25939: LD_VAR 0 12
25943: PUSH
25944: LD_INT 1
25946: PUSH
25947: LD_INT 2
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: IN
25954: PUSH
25955: LD_INT 11
25957: PUSH
25958: LD_VAR 0 5
25962: IN
25963: PUSH
25964: LD_INT 30
25966: PUSH
25967: LD_VAR 0 5
25971: IN
25972: OR
25973: AND
25974: PUSH
25975: LD_INT 6
25977: PPUSH
25978: LD_VAR 0 16
25982: PPUSH
25983: CALL_OW 321
25987: PUSH
25988: LD_INT 2
25990: EQUAL
25991: AND
25992: IFFALSE 26157
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25994: LD_INT 22
25996: PUSH
25997: LD_VAR 0 16
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: PUSH
26006: LD_INT 2
26008: PUSH
26009: LD_INT 35
26011: PUSH
26012: LD_INT 11
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 35
26021: PUSH
26022: LD_INT 30
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 91
26036: PUSH
26037: LD_VAR 0 1
26041: PUSH
26042: LD_INT 18
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: LIST
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: LIST
26054: PPUSH
26055: CALL_OW 69
26059: NOT
26060: PUSH
26061: LD_INT 22
26063: PUSH
26064: LD_VAR 0 16
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 2
26075: PUSH
26076: LD_INT 30
26078: PUSH
26079: LD_INT 32
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PUSH
26086: LD_INT 30
26088: PUSH
26089: LD_INT 33
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: LIST
26100: PUSH
26101: LD_INT 91
26103: PUSH
26104: LD_VAR 0 1
26108: PUSH
26109: LD_INT 12
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: LIST
26116: PUSH
26117: EMPTY
26118: LIST
26119: LIST
26120: LIST
26121: PUSH
26122: EMPTY
26123: LIST
26124: PPUSH
26125: CALL_OW 69
26129: PUSH
26130: LD_INT 2
26132: GREATER
26133: AND
26134: IFFALSE 26157
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26136: LD_ADDR_VAR 0 18
26140: PUSH
26141: LD_INT 11
26143: PUSH
26144: LD_INT 30
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: PUSH
26151: LD_VAR 0 12
26155: ARRAY
26156: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26157: LD_VAR 0 18
26161: NOT
26162: PUSH
26163: LD_INT 40
26165: PPUSH
26166: LD_VAR 0 16
26170: PPUSH
26171: CALL_OW 321
26175: PUSH
26176: LD_INT 2
26178: EQUAL
26179: AND
26180: PUSH
26181: LD_INT 7
26183: PUSH
26184: LD_VAR 0 5
26188: IN
26189: PUSH
26190: LD_INT 28
26192: PUSH
26193: LD_VAR 0 5
26197: IN
26198: OR
26199: PUSH
26200: LD_INT 45
26202: PUSH
26203: LD_VAR 0 5
26207: IN
26208: OR
26209: AND
26210: IFFALSE 26464
// begin hex := GetHexInfo ( x , y ) ;
26212: LD_ADDR_VAR 0 4
26216: PUSH
26217: LD_VAR 0 10
26221: PPUSH
26222: LD_VAR 0 11
26226: PPUSH
26227: CALL_OW 546
26231: ST_TO_ADDR
// if hex [ 1 ] then
26232: LD_VAR 0 4
26236: PUSH
26237: LD_INT 1
26239: ARRAY
26240: IFFALSE 26244
// exit ;
26242: GO 26647
// height := hex [ 2 ] ;
26244: LD_ADDR_VAR 0 15
26248: PUSH
26249: LD_VAR 0 4
26253: PUSH
26254: LD_INT 2
26256: ARRAY
26257: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26258: LD_ADDR_VAR 0 14
26262: PUSH
26263: LD_INT 0
26265: PUSH
26266: LD_INT 2
26268: PUSH
26269: LD_INT 3
26271: PUSH
26272: LD_INT 5
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: ST_TO_ADDR
// for i in tmp do
26281: LD_ADDR_VAR 0 8
26285: PUSH
26286: LD_VAR 0 14
26290: PUSH
26291: FOR_IN
26292: IFFALSE 26462
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26294: LD_ADDR_VAR 0 9
26298: PUSH
26299: LD_VAR 0 10
26303: PPUSH
26304: LD_VAR 0 8
26308: PPUSH
26309: LD_INT 5
26311: PPUSH
26312: CALL_OW 272
26316: PUSH
26317: LD_VAR 0 11
26321: PPUSH
26322: LD_VAR 0 8
26326: PPUSH
26327: LD_INT 5
26329: PPUSH
26330: CALL_OW 273
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26339: LD_VAR 0 9
26343: PUSH
26344: LD_INT 1
26346: ARRAY
26347: PPUSH
26348: LD_VAR 0 9
26352: PUSH
26353: LD_INT 2
26355: ARRAY
26356: PPUSH
26357: CALL_OW 488
26361: IFFALSE 26460
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26363: LD_ADDR_VAR 0 4
26367: PUSH
26368: LD_VAR 0 9
26372: PUSH
26373: LD_INT 1
26375: ARRAY
26376: PPUSH
26377: LD_VAR 0 9
26381: PUSH
26382: LD_INT 2
26384: ARRAY
26385: PPUSH
26386: CALL_OW 546
26390: ST_TO_ADDR
// if hex [ 1 ] then
26391: LD_VAR 0 4
26395: PUSH
26396: LD_INT 1
26398: ARRAY
26399: IFFALSE 26403
// continue ;
26401: GO 26291
// h := hex [ 2 ] ;
26403: LD_ADDR_VAR 0 13
26407: PUSH
26408: LD_VAR 0 4
26412: PUSH
26413: LD_INT 2
26415: ARRAY
26416: ST_TO_ADDR
// if h + 7 < height then
26417: LD_VAR 0 13
26421: PUSH
26422: LD_INT 7
26424: PLUS
26425: PUSH
26426: LD_VAR 0 15
26430: LESS
26431: IFFALSE 26460
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26433: LD_ADDR_VAR 0 18
26437: PUSH
26438: LD_INT 7
26440: PUSH
26441: LD_INT 28
26443: PUSH
26444: LD_INT 45
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: LIST
26451: PUSH
26452: LD_VAR 0 12
26456: ARRAY
26457: ST_TO_ADDR
// break ;
26458: GO 26462
// end ; end ; end ;
26460: GO 26291
26462: POP
26463: POP
// end ; if not weapon then
26464: LD_VAR 0 18
26468: NOT
26469: IFFALSE 26529
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26471: LD_ADDR_VAR 0 5
26475: PUSH
26476: LD_VAR 0 5
26480: PUSH
26481: LD_INT 11
26483: PUSH
26484: LD_INT 30
26486: PUSH
26487: LD_INT 49
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: LIST
26494: DIFF
26495: ST_TO_ADDR
// if not list then
26496: LD_VAR 0 5
26500: NOT
26501: IFFALSE 26505
// exit ;
26503: GO 26647
// weapon := list [ rand ( 1 , list ) ] ;
26505: LD_ADDR_VAR 0 18
26509: PUSH
26510: LD_VAR 0 5
26514: PUSH
26515: LD_INT 1
26517: PPUSH
26518: LD_VAR 0 5
26522: PPUSH
26523: CALL_OW 12
26527: ARRAY
26528: ST_TO_ADDR
// end ; if weapon then
26529: LD_VAR 0 18
26533: IFFALSE 26647
// begin tmp := CostOfWeapon ( weapon ) ;
26535: LD_ADDR_VAR 0 14
26539: PUSH
26540: LD_VAR 0 18
26544: PPUSH
26545: CALL_OW 451
26549: ST_TO_ADDR
// j := GetBase ( tower ) ;
26550: LD_ADDR_VAR 0 9
26554: PUSH
26555: LD_VAR 0 1
26559: PPUSH
26560: CALL_OW 274
26564: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26565: LD_VAR 0 9
26569: PPUSH
26570: LD_INT 1
26572: PPUSH
26573: CALL_OW 275
26577: PUSH
26578: LD_VAR 0 14
26582: PUSH
26583: LD_INT 1
26585: ARRAY
26586: GREATEREQUAL
26587: PUSH
26588: LD_VAR 0 9
26592: PPUSH
26593: LD_INT 2
26595: PPUSH
26596: CALL_OW 275
26600: PUSH
26601: LD_VAR 0 14
26605: PUSH
26606: LD_INT 2
26608: ARRAY
26609: GREATEREQUAL
26610: AND
26611: PUSH
26612: LD_VAR 0 9
26616: PPUSH
26617: LD_INT 3
26619: PPUSH
26620: CALL_OW 275
26624: PUSH
26625: LD_VAR 0 14
26629: PUSH
26630: LD_INT 3
26632: ARRAY
26633: GREATEREQUAL
26634: AND
26635: IFFALSE 26647
// result := weapon ;
26637: LD_ADDR_VAR 0 3
26641: PUSH
26642: LD_VAR 0 18
26646: ST_TO_ADDR
// end ; end ;
26647: LD_VAR 0 3
26651: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26652: LD_INT 0
26654: PPUSH
26655: PPUSH
// result := true ;
26656: LD_ADDR_VAR 0 3
26660: PUSH
26661: LD_INT 1
26663: ST_TO_ADDR
// if array1 = array2 then
26664: LD_VAR 0 1
26668: PUSH
26669: LD_VAR 0 2
26673: EQUAL
26674: IFFALSE 26734
// begin for i = 1 to array1 do
26676: LD_ADDR_VAR 0 4
26680: PUSH
26681: DOUBLE
26682: LD_INT 1
26684: DEC
26685: ST_TO_ADDR
26686: LD_VAR 0 1
26690: PUSH
26691: FOR_TO
26692: IFFALSE 26730
// if array1 [ i ] <> array2 [ i ] then
26694: LD_VAR 0 1
26698: PUSH
26699: LD_VAR 0 4
26703: ARRAY
26704: PUSH
26705: LD_VAR 0 2
26709: PUSH
26710: LD_VAR 0 4
26714: ARRAY
26715: NONEQUAL
26716: IFFALSE 26728
// begin result := false ;
26718: LD_ADDR_VAR 0 3
26722: PUSH
26723: LD_INT 0
26725: ST_TO_ADDR
// break ;
26726: GO 26730
// end ;
26728: GO 26691
26730: POP
26731: POP
// end else
26732: GO 26742
// result := false ;
26734: LD_ADDR_VAR 0 3
26738: PUSH
26739: LD_INT 0
26741: ST_TO_ADDR
// end ;
26742: LD_VAR 0 3
26746: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26747: LD_INT 0
26749: PPUSH
26750: PPUSH
// if not array1 or not array2 then
26751: LD_VAR 0 1
26755: NOT
26756: PUSH
26757: LD_VAR 0 2
26761: NOT
26762: OR
26763: IFFALSE 26767
// exit ;
26765: GO 26831
// result := true ;
26767: LD_ADDR_VAR 0 3
26771: PUSH
26772: LD_INT 1
26774: ST_TO_ADDR
// for i = 1 to array1 do
26775: LD_ADDR_VAR 0 4
26779: PUSH
26780: DOUBLE
26781: LD_INT 1
26783: DEC
26784: ST_TO_ADDR
26785: LD_VAR 0 1
26789: PUSH
26790: FOR_TO
26791: IFFALSE 26829
// if array1 [ i ] <> array2 [ i ] then
26793: LD_VAR 0 1
26797: PUSH
26798: LD_VAR 0 4
26802: ARRAY
26803: PUSH
26804: LD_VAR 0 2
26808: PUSH
26809: LD_VAR 0 4
26813: ARRAY
26814: NONEQUAL
26815: IFFALSE 26827
// begin result := false ;
26817: LD_ADDR_VAR 0 3
26821: PUSH
26822: LD_INT 0
26824: ST_TO_ADDR
// break ;
26825: GO 26829
// end ;
26827: GO 26790
26829: POP
26830: POP
// end ;
26831: LD_VAR 0 3
26835: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
// pom := GetBase ( fac ) ;
26841: LD_ADDR_VAR 0 5
26845: PUSH
26846: LD_VAR 0 1
26850: PPUSH
26851: CALL_OW 274
26855: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26856: LD_ADDR_VAR 0 4
26860: PUSH
26861: LD_VAR 0 2
26865: PUSH
26866: LD_INT 1
26868: ARRAY
26869: PPUSH
26870: LD_VAR 0 2
26874: PUSH
26875: LD_INT 2
26877: ARRAY
26878: PPUSH
26879: LD_VAR 0 2
26883: PUSH
26884: LD_INT 3
26886: ARRAY
26887: PPUSH
26888: LD_VAR 0 2
26892: PUSH
26893: LD_INT 4
26895: ARRAY
26896: PPUSH
26897: CALL_OW 449
26901: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26902: LD_ADDR_VAR 0 3
26906: PUSH
26907: LD_VAR 0 5
26911: PPUSH
26912: LD_INT 1
26914: PPUSH
26915: CALL_OW 275
26919: PUSH
26920: LD_VAR 0 4
26924: PUSH
26925: LD_INT 1
26927: ARRAY
26928: GREATEREQUAL
26929: PUSH
26930: LD_VAR 0 5
26934: PPUSH
26935: LD_INT 2
26937: PPUSH
26938: CALL_OW 275
26942: PUSH
26943: LD_VAR 0 4
26947: PUSH
26948: LD_INT 2
26950: ARRAY
26951: GREATEREQUAL
26952: AND
26953: PUSH
26954: LD_VAR 0 5
26958: PPUSH
26959: LD_INT 3
26961: PPUSH
26962: CALL_OW 275
26966: PUSH
26967: LD_VAR 0 4
26971: PUSH
26972: LD_INT 3
26974: ARRAY
26975: GREATEREQUAL
26976: AND
26977: ST_TO_ADDR
// end ;
26978: LD_VAR 0 3
26982: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26983: LD_INT 0
26985: PPUSH
26986: PPUSH
26987: PPUSH
26988: PPUSH
// pom := GetBase ( building ) ;
26989: LD_ADDR_VAR 0 3
26993: PUSH
26994: LD_VAR 0 1
26998: PPUSH
26999: CALL_OW 274
27003: ST_TO_ADDR
// if not pom then
27004: LD_VAR 0 3
27008: NOT
27009: IFFALSE 27013
// exit ;
27011: GO 27183
// btype := GetBType ( building ) ;
27013: LD_ADDR_VAR 0 5
27017: PUSH
27018: LD_VAR 0 1
27022: PPUSH
27023: CALL_OW 266
27027: ST_TO_ADDR
// if btype = b_armoury then
27028: LD_VAR 0 5
27032: PUSH
27033: LD_INT 4
27035: EQUAL
27036: IFFALSE 27046
// btype := b_barracks ;
27038: LD_ADDR_VAR 0 5
27042: PUSH
27043: LD_INT 5
27045: ST_TO_ADDR
// if btype = b_depot then
27046: LD_VAR 0 5
27050: PUSH
27051: LD_INT 0
27053: EQUAL
27054: IFFALSE 27064
// btype := b_warehouse ;
27056: LD_ADDR_VAR 0 5
27060: PUSH
27061: LD_INT 1
27063: ST_TO_ADDR
// if btype = b_workshop then
27064: LD_VAR 0 5
27068: PUSH
27069: LD_INT 2
27071: EQUAL
27072: IFFALSE 27082
// btype := b_factory ;
27074: LD_ADDR_VAR 0 5
27078: PUSH
27079: LD_INT 3
27081: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27082: LD_ADDR_VAR 0 4
27086: PUSH
27087: LD_VAR 0 5
27091: PPUSH
27092: LD_VAR 0 1
27096: PPUSH
27097: CALL_OW 248
27101: PPUSH
27102: CALL_OW 450
27106: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27107: LD_ADDR_VAR 0 2
27111: PUSH
27112: LD_VAR 0 3
27116: PPUSH
27117: LD_INT 1
27119: PPUSH
27120: CALL_OW 275
27124: PUSH
27125: LD_VAR 0 4
27129: PUSH
27130: LD_INT 1
27132: ARRAY
27133: GREATEREQUAL
27134: PUSH
27135: LD_VAR 0 3
27139: PPUSH
27140: LD_INT 2
27142: PPUSH
27143: CALL_OW 275
27147: PUSH
27148: LD_VAR 0 4
27152: PUSH
27153: LD_INT 2
27155: ARRAY
27156: GREATEREQUAL
27157: AND
27158: PUSH
27159: LD_VAR 0 3
27163: PPUSH
27164: LD_INT 3
27166: PPUSH
27167: CALL_OW 275
27171: PUSH
27172: LD_VAR 0 4
27176: PUSH
27177: LD_INT 3
27179: ARRAY
27180: GREATEREQUAL
27181: AND
27182: ST_TO_ADDR
// end ;
27183: LD_VAR 0 2
27187: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
27192: PPUSH
// pom := GetBase ( building ) ;
27193: LD_ADDR_VAR 0 4
27197: PUSH
27198: LD_VAR 0 1
27202: PPUSH
27203: CALL_OW 274
27207: ST_TO_ADDR
// if not pom then
27208: LD_VAR 0 4
27212: NOT
27213: IFFALSE 27217
// exit ;
27215: GO 27318
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27217: LD_ADDR_VAR 0 5
27221: PUSH
27222: LD_VAR 0 2
27226: PPUSH
27227: LD_VAR 0 1
27231: PPUSH
27232: CALL_OW 248
27236: PPUSH
27237: CALL_OW 450
27241: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27242: LD_ADDR_VAR 0 3
27246: PUSH
27247: LD_VAR 0 4
27251: PPUSH
27252: LD_INT 1
27254: PPUSH
27255: CALL_OW 275
27259: PUSH
27260: LD_VAR 0 5
27264: PUSH
27265: LD_INT 1
27267: ARRAY
27268: GREATEREQUAL
27269: PUSH
27270: LD_VAR 0 4
27274: PPUSH
27275: LD_INT 2
27277: PPUSH
27278: CALL_OW 275
27282: PUSH
27283: LD_VAR 0 5
27287: PUSH
27288: LD_INT 2
27290: ARRAY
27291: GREATEREQUAL
27292: AND
27293: PUSH
27294: LD_VAR 0 4
27298: PPUSH
27299: LD_INT 3
27301: PPUSH
27302: CALL_OW 275
27306: PUSH
27307: LD_VAR 0 5
27311: PUSH
27312: LD_INT 3
27314: ARRAY
27315: GREATEREQUAL
27316: AND
27317: ST_TO_ADDR
// end ;
27318: LD_VAR 0 3
27322: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
27323: LD_INT 0
27325: PPUSH
27326: PPUSH
27327: PPUSH
27328: PPUSH
27329: PPUSH
27330: PPUSH
27331: PPUSH
27332: PPUSH
27333: PPUSH
27334: PPUSH
27335: PPUSH
// result := false ;
27336: LD_ADDR_VAR 0 8
27340: PUSH
27341: LD_INT 0
27343: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
27344: LD_VAR 0 5
27348: NOT
27349: PUSH
27350: LD_VAR 0 1
27354: NOT
27355: OR
27356: PUSH
27357: LD_VAR 0 2
27361: NOT
27362: OR
27363: PUSH
27364: LD_VAR 0 3
27368: NOT
27369: OR
27370: IFFALSE 27374
// exit ;
27372: GO 28188
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
27374: LD_ADDR_VAR 0 14
27378: PUSH
27379: LD_VAR 0 1
27383: PPUSH
27384: LD_VAR 0 2
27388: PPUSH
27389: LD_VAR 0 3
27393: PPUSH
27394: LD_VAR 0 4
27398: PPUSH
27399: LD_VAR 0 5
27403: PUSH
27404: LD_INT 1
27406: ARRAY
27407: PPUSH
27408: CALL_OW 248
27412: PPUSH
27413: LD_INT 0
27415: PPUSH
27416: CALL 29441 0 6
27420: ST_TO_ADDR
// if not hexes then
27421: LD_VAR 0 14
27425: NOT
27426: IFFALSE 27430
// exit ;
27428: GO 28188
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27430: LD_ADDR_VAR 0 17
27434: PUSH
27435: LD_VAR 0 5
27439: PPUSH
27440: LD_INT 22
27442: PUSH
27443: LD_VAR 0 13
27447: PPUSH
27448: CALL_OW 255
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 2
27459: PUSH
27460: LD_INT 30
27462: PUSH
27463: LD_INT 0
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 30
27472: PUSH
27473: LD_INT 1
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: LIST
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PPUSH
27489: CALL_OW 72
27493: ST_TO_ADDR
// for i = 1 to hexes do
27494: LD_ADDR_VAR 0 9
27498: PUSH
27499: DOUBLE
27500: LD_INT 1
27502: DEC
27503: ST_TO_ADDR
27504: LD_VAR 0 14
27508: PUSH
27509: FOR_TO
27510: IFFALSE 28186
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27512: LD_ADDR_VAR 0 13
27516: PUSH
27517: LD_VAR 0 14
27521: PUSH
27522: LD_VAR 0 9
27526: ARRAY
27527: PUSH
27528: LD_INT 1
27530: ARRAY
27531: PPUSH
27532: LD_VAR 0 14
27536: PUSH
27537: LD_VAR 0 9
27541: ARRAY
27542: PUSH
27543: LD_INT 2
27545: ARRAY
27546: PPUSH
27547: CALL_OW 428
27551: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27552: LD_VAR 0 14
27556: PUSH
27557: LD_VAR 0 9
27561: ARRAY
27562: PUSH
27563: LD_INT 1
27565: ARRAY
27566: PPUSH
27567: LD_VAR 0 14
27571: PUSH
27572: LD_VAR 0 9
27576: ARRAY
27577: PUSH
27578: LD_INT 2
27580: ARRAY
27581: PPUSH
27582: CALL_OW 351
27586: PUSH
27587: LD_VAR 0 14
27591: PUSH
27592: LD_VAR 0 9
27596: ARRAY
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PPUSH
27602: LD_VAR 0 14
27606: PUSH
27607: LD_VAR 0 9
27611: ARRAY
27612: PUSH
27613: LD_INT 2
27615: ARRAY
27616: PPUSH
27617: CALL_OW 488
27621: NOT
27622: OR
27623: PUSH
27624: LD_VAR 0 13
27628: PPUSH
27629: CALL_OW 247
27633: PUSH
27634: LD_INT 3
27636: EQUAL
27637: OR
27638: IFFALSE 27644
// exit ;
27640: POP
27641: POP
27642: GO 28188
// if not tmp then
27644: LD_VAR 0 13
27648: NOT
27649: IFFALSE 27653
// continue ;
27651: GO 27509
// result := true ;
27653: LD_ADDR_VAR 0 8
27657: PUSH
27658: LD_INT 1
27660: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27661: LD_VAR 0 6
27665: PUSH
27666: LD_VAR 0 13
27670: PPUSH
27671: CALL_OW 247
27675: PUSH
27676: LD_INT 2
27678: EQUAL
27679: AND
27680: PUSH
27681: LD_VAR 0 13
27685: PPUSH
27686: CALL_OW 263
27690: PUSH
27691: LD_INT 1
27693: EQUAL
27694: AND
27695: IFFALSE 27859
// begin if IsDrivenBy ( tmp ) then
27697: LD_VAR 0 13
27701: PPUSH
27702: CALL_OW 311
27706: IFFALSE 27710
// continue ;
27708: GO 27509
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27710: LD_VAR 0 6
27714: PPUSH
27715: LD_INT 3
27717: PUSH
27718: LD_INT 60
27720: PUSH
27721: EMPTY
27722: LIST
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 3
27730: PUSH
27731: LD_INT 55
27733: PUSH
27734: EMPTY
27735: LIST
27736: PUSH
27737: EMPTY
27738: LIST
27739: LIST
27740: PUSH
27741: EMPTY
27742: LIST
27743: LIST
27744: PPUSH
27745: CALL_OW 72
27749: IFFALSE 27857
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27751: LD_ADDR_VAR 0 18
27755: PUSH
27756: LD_VAR 0 6
27760: PPUSH
27761: LD_INT 3
27763: PUSH
27764: LD_INT 60
27766: PUSH
27767: EMPTY
27768: LIST
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 3
27776: PUSH
27777: LD_INT 55
27779: PUSH
27780: EMPTY
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PPUSH
27791: CALL_OW 72
27795: PUSH
27796: LD_INT 1
27798: ARRAY
27799: ST_TO_ADDR
// if IsInUnit ( driver ) then
27800: LD_VAR 0 18
27804: PPUSH
27805: CALL_OW 310
27809: IFFALSE 27820
// ComExit ( driver ) ;
27811: LD_VAR 0 18
27815: PPUSH
27816: CALL 53220 0 1
// AddComEnterUnit ( driver , tmp ) ;
27820: LD_VAR 0 18
27824: PPUSH
27825: LD_VAR 0 13
27829: PPUSH
27830: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27834: LD_VAR 0 18
27838: PPUSH
27839: LD_VAR 0 7
27843: PPUSH
27844: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27848: LD_VAR 0 18
27852: PPUSH
27853: CALL_OW 181
// end ; continue ;
27857: GO 27509
// end ; if not cleaners or not tmp in cleaners then
27859: LD_VAR 0 6
27863: NOT
27864: PUSH
27865: LD_VAR 0 13
27869: PUSH
27870: LD_VAR 0 6
27874: IN
27875: NOT
27876: OR
27877: IFFALSE 28184
// begin if dep then
27879: LD_VAR 0 17
27883: IFFALSE 28019
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27885: LD_ADDR_VAR 0 16
27889: PUSH
27890: LD_VAR 0 17
27894: PUSH
27895: LD_INT 1
27897: ARRAY
27898: PPUSH
27899: CALL_OW 250
27903: PPUSH
27904: LD_VAR 0 17
27908: PUSH
27909: LD_INT 1
27911: ARRAY
27912: PPUSH
27913: CALL_OW 254
27917: PPUSH
27918: LD_INT 5
27920: PPUSH
27921: CALL_OW 272
27925: PUSH
27926: LD_VAR 0 17
27930: PUSH
27931: LD_INT 1
27933: ARRAY
27934: PPUSH
27935: CALL_OW 251
27939: PPUSH
27940: LD_VAR 0 17
27944: PUSH
27945: LD_INT 1
27947: ARRAY
27948: PPUSH
27949: CALL_OW 254
27953: PPUSH
27954: LD_INT 5
27956: PPUSH
27957: CALL_OW 273
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27966: LD_VAR 0 16
27970: PUSH
27971: LD_INT 1
27973: ARRAY
27974: PPUSH
27975: LD_VAR 0 16
27979: PUSH
27980: LD_INT 2
27982: ARRAY
27983: PPUSH
27984: CALL_OW 488
27988: IFFALSE 28019
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27990: LD_VAR 0 13
27994: PPUSH
27995: LD_VAR 0 16
27999: PUSH
28000: LD_INT 1
28002: ARRAY
28003: PPUSH
28004: LD_VAR 0 16
28008: PUSH
28009: LD_INT 2
28011: ARRAY
28012: PPUSH
28013: CALL_OW 111
// continue ;
28017: GO 27509
// end ; end ; r := GetDir ( tmp ) ;
28019: LD_ADDR_VAR 0 15
28023: PUSH
28024: LD_VAR 0 13
28028: PPUSH
28029: CALL_OW 254
28033: ST_TO_ADDR
// if r = 5 then
28034: LD_VAR 0 15
28038: PUSH
28039: LD_INT 5
28041: EQUAL
28042: IFFALSE 28052
// r := 0 ;
28044: LD_ADDR_VAR 0 15
28048: PUSH
28049: LD_INT 0
28051: ST_TO_ADDR
// for j = r to 5 do
28052: LD_ADDR_VAR 0 10
28056: PUSH
28057: DOUBLE
28058: LD_VAR 0 15
28062: DEC
28063: ST_TO_ADDR
28064: LD_INT 5
28066: PUSH
28067: FOR_TO
28068: IFFALSE 28182
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28070: LD_ADDR_VAR 0 11
28074: PUSH
28075: LD_VAR 0 13
28079: PPUSH
28080: CALL_OW 250
28084: PPUSH
28085: LD_VAR 0 10
28089: PPUSH
28090: LD_INT 2
28092: PPUSH
28093: CALL_OW 272
28097: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28098: LD_ADDR_VAR 0 12
28102: PUSH
28103: LD_VAR 0 13
28107: PPUSH
28108: CALL_OW 251
28112: PPUSH
28113: LD_VAR 0 10
28117: PPUSH
28118: LD_INT 2
28120: PPUSH
28121: CALL_OW 273
28125: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28126: LD_VAR 0 11
28130: PPUSH
28131: LD_VAR 0 12
28135: PPUSH
28136: CALL_OW 488
28140: PUSH
28141: LD_VAR 0 11
28145: PPUSH
28146: LD_VAR 0 12
28150: PPUSH
28151: CALL_OW 428
28155: NOT
28156: AND
28157: IFFALSE 28180
// begin ComMoveXY ( tmp , _x , _y ) ;
28159: LD_VAR 0 13
28163: PPUSH
28164: LD_VAR 0 11
28168: PPUSH
28169: LD_VAR 0 12
28173: PPUSH
28174: CALL_OW 111
// break ;
28178: GO 28182
// end ; end ;
28180: GO 28067
28182: POP
28183: POP
// end ; end ;
28184: GO 27509
28186: POP
28187: POP
// end ;
28188: LD_VAR 0 8
28192: RET
// export function BuildingTechInvented ( side , btype ) ; begin
28193: LD_INT 0
28195: PPUSH
// result := true ;
28196: LD_ADDR_VAR 0 3
28200: PUSH
28201: LD_INT 1
28203: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
28204: LD_VAR 0 2
28208: PUSH
28209: LD_INT 24
28211: DOUBLE
28212: EQUAL
28213: IFTRUE 28223
28215: LD_INT 33
28217: DOUBLE
28218: EQUAL
28219: IFTRUE 28223
28221: GO 28248
28223: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
28224: LD_ADDR_VAR 0 3
28228: PUSH
28229: LD_INT 32
28231: PPUSH
28232: LD_VAR 0 1
28236: PPUSH
28237: CALL_OW 321
28241: PUSH
28242: LD_INT 2
28244: EQUAL
28245: ST_TO_ADDR
28246: GO 28564
28248: LD_INT 20
28250: DOUBLE
28251: EQUAL
28252: IFTRUE 28256
28254: GO 28281
28256: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
28257: LD_ADDR_VAR 0 3
28261: PUSH
28262: LD_INT 6
28264: PPUSH
28265: LD_VAR 0 1
28269: PPUSH
28270: CALL_OW 321
28274: PUSH
28275: LD_INT 2
28277: EQUAL
28278: ST_TO_ADDR
28279: GO 28564
28281: LD_INT 22
28283: DOUBLE
28284: EQUAL
28285: IFTRUE 28295
28287: LD_INT 36
28289: DOUBLE
28290: EQUAL
28291: IFTRUE 28295
28293: GO 28320
28295: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
28296: LD_ADDR_VAR 0 3
28300: PUSH
28301: LD_INT 15
28303: PPUSH
28304: LD_VAR 0 1
28308: PPUSH
28309: CALL_OW 321
28313: PUSH
28314: LD_INT 2
28316: EQUAL
28317: ST_TO_ADDR
28318: GO 28564
28320: LD_INT 30
28322: DOUBLE
28323: EQUAL
28324: IFTRUE 28328
28326: GO 28353
28328: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
28329: LD_ADDR_VAR 0 3
28333: PUSH
28334: LD_INT 20
28336: PPUSH
28337: LD_VAR 0 1
28341: PPUSH
28342: CALL_OW 321
28346: PUSH
28347: LD_INT 2
28349: EQUAL
28350: ST_TO_ADDR
28351: GO 28564
28353: LD_INT 28
28355: DOUBLE
28356: EQUAL
28357: IFTRUE 28367
28359: LD_INT 21
28361: DOUBLE
28362: EQUAL
28363: IFTRUE 28367
28365: GO 28392
28367: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
28368: LD_ADDR_VAR 0 3
28372: PUSH
28373: LD_INT 21
28375: PPUSH
28376: LD_VAR 0 1
28380: PPUSH
28381: CALL_OW 321
28385: PUSH
28386: LD_INT 2
28388: EQUAL
28389: ST_TO_ADDR
28390: GO 28564
28392: LD_INT 16
28394: DOUBLE
28395: EQUAL
28396: IFTRUE 28400
28398: GO 28425
28400: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
28401: LD_ADDR_VAR 0 3
28405: PUSH
28406: LD_INT 84
28408: PPUSH
28409: LD_VAR 0 1
28413: PPUSH
28414: CALL_OW 321
28418: PUSH
28419: LD_INT 2
28421: EQUAL
28422: ST_TO_ADDR
28423: GO 28564
28425: LD_INT 19
28427: DOUBLE
28428: EQUAL
28429: IFTRUE 28439
28431: LD_INT 23
28433: DOUBLE
28434: EQUAL
28435: IFTRUE 28439
28437: GO 28464
28439: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28440: LD_ADDR_VAR 0 3
28444: PUSH
28445: LD_INT 83
28447: PPUSH
28448: LD_VAR 0 1
28452: PPUSH
28453: CALL_OW 321
28457: PUSH
28458: LD_INT 2
28460: EQUAL
28461: ST_TO_ADDR
28462: GO 28564
28464: LD_INT 17
28466: DOUBLE
28467: EQUAL
28468: IFTRUE 28472
28470: GO 28497
28472: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28473: LD_ADDR_VAR 0 3
28477: PUSH
28478: LD_INT 39
28480: PPUSH
28481: LD_VAR 0 1
28485: PPUSH
28486: CALL_OW 321
28490: PUSH
28491: LD_INT 2
28493: EQUAL
28494: ST_TO_ADDR
28495: GO 28564
28497: LD_INT 18
28499: DOUBLE
28500: EQUAL
28501: IFTRUE 28505
28503: GO 28530
28505: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28506: LD_ADDR_VAR 0 3
28510: PUSH
28511: LD_INT 40
28513: PPUSH
28514: LD_VAR 0 1
28518: PPUSH
28519: CALL_OW 321
28523: PUSH
28524: LD_INT 2
28526: EQUAL
28527: ST_TO_ADDR
28528: GO 28564
28530: LD_INT 27
28532: DOUBLE
28533: EQUAL
28534: IFTRUE 28538
28536: GO 28563
28538: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28539: LD_ADDR_VAR 0 3
28543: PUSH
28544: LD_INT 35
28546: PPUSH
28547: LD_VAR 0 1
28551: PPUSH
28552: CALL_OW 321
28556: PUSH
28557: LD_INT 2
28559: EQUAL
28560: ST_TO_ADDR
28561: GO 28564
28563: POP
// end ;
28564: LD_VAR 0 3
28568: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28569: LD_INT 0
28571: PPUSH
28572: PPUSH
28573: PPUSH
28574: PPUSH
28575: PPUSH
28576: PPUSH
28577: PPUSH
28578: PPUSH
28579: PPUSH
28580: PPUSH
28581: PPUSH
// result := false ;
28582: LD_ADDR_VAR 0 6
28586: PUSH
28587: LD_INT 0
28589: ST_TO_ADDR
// if btype = b_depot then
28590: LD_VAR 0 2
28594: PUSH
28595: LD_INT 0
28597: EQUAL
28598: IFFALSE 28610
// begin result := true ;
28600: LD_ADDR_VAR 0 6
28604: PUSH
28605: LD_INT 1
28607: ST_TO_ADDR
// exit ;
28608: GO 29436
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28610: LD_VAR 0 1
28614: NOT
28615: PUSH
28616: LD_VAR 0 1
28620: PPUSH
28621: CALL_OW 266
28625: PUSH
28626: LD_INT 0
28628: PUSH
28629: LD_INT 1
28631: PUSH
28632: EMPTY
28633: LIST
28634: LIST
28635: IN
28636: NOT
28637: OR
28638: PUSH
28639: LD_VAR 0 2
28643: NOT
28644: OR
28645: PUSH
28646: LD_VAR 0 5
28650: PUSH
28651: LD_INT 0
28653: PUSH
28654: LD_INT 1
28656: PUSH
28657: LD_INT 2
28659: PUSH
28660: LD_INT 3
28662: PUSH
28663: LD_INT 4
28665: PUSH
28666: LD_INT 5
28668: PUSH
28669: EMPTY
28670: LIST
28671: LIST
28672: LIST
28673: LIST
28674: LIST
28675: LIST
28676: IN
28677: NOT
28678: OR
28679: PUSH
28680: LD_VAR 0 3
28684: PPUSH
28685: LD_VAR 0 4
28689: PPUSH
28690: CALL_OW 488
28694: NOT
28695: OR
28696: IFFALSE 28700
// exit ;
28698: GO 29436
// side := GetSide ( depot ) ;
28700: LD_ADDR_VAR 0 9
28704: PUSH
28705: LD_VAR 0 1
28709: PPUSH
28710: CALL_OW 255
28714: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28715: LD_VAR 0 9
28719: PPUSH
28720: LD_VAR 0 2
28724: PPUSH
28725: CALL 28193 0 2
28729: NOT
28730: IFFALSE 28734
// exit ;
28732: GO 29436
// pom := GetBase ( depot ) ;
28734: LD_ADDR_VAR 0 10
28738: PUSH
28739: LD_VAR 0 1
28743: PPUSH
28744: CALL_OW 274
28748: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28749: LD_ADDR_VAR 0 11
28753: PUSH
28754: LD_VAR 0 2
28758: PPUSH
28759: LD_VAR 0 1
28763: PPUSH
28764: CALL_OW 248
28768: PPUSH
28769: CALL_OW 450
28773: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28774: LD_VAR 0 10
28778: PPUSH
28779: LD_INT 1
28781: PPUSH
28782: CALL_OW 275
28786: PUSH
28787: LD_VAR 0 11
28791: PUSH
28792: LD_INT 1
28794: ARRAY
28795: GREATEREQUAL
28796: PUSH
28797: LD_VAR 0 10
28801: PPUSH
28802: LD_INT 2
28804: PPUSH
28805: CALL_OW 275
28809: PUSH
28810: LD_VAR 0 11
28814: PUSH
28815: LD_INT 2
28817: ARRAY
28818: GREATEREQUAL
28819: AND
28820: PUSH
28821: LD_VAR 0 10
28825: PPUSH
28826: LD_INT 3
28828: PPUSH
28829: CALL_OW 275
28833: PUSH
28834: LD_VAR 0 11
28838: PUSH
28839: LD_INT 3
28841: ARRAY
28842: GREATEREQUAL
28843: AND
28844: NOT
28845: IFFALSE 28849
// exit ;
28847: GO 29436
// if GetBType ( depot ) = b_depot then
28849: LD_VAR 0 1
28853: PPUSH
28854: CALL_OW 266
28858: PUSH
28859: LD_INT 0
28861: EQUAL
28862: IFFALSE 28874
// dist := 28 else
28864: LD_ADDR_VAR 0 14
28868: PUSH
28869: LD_INT 28
28871: ST_TO_ADDR
28872: GO 28882
// dist := 36 ;
28874: LD_ADDR_VAR 0 14
28878: PUSH
28879: LD_INT 36
28881: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28882: LD_VAR 0 1
28886: PPUSH
28887: LD_VAR 0 3
28891: PPUSH
28892: LD_VAR 0 4
28896: PPUSH
28897: CALL_OW 297
28901: PUSH
28902: LD_VAR 0 14
28906: GREATER
28907: IFFALSE 28911
// exit ;
28909: GO 29436
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28911: LD_ADDR_VAR 0 12
28915: PUSH
28916: LD_VAR 0 2
28920: PPUSH
28921: LD_VAR 0 3
28925: PPUSH
28926: LD_VAR 0 4
28930: PPUSH
28931: LD_VAR 0 5
28935: PPUSH
28936: LD_VAR 0 1
28940: PPUSH
28941: CALL_OW 248
28945: PPUSH
28946: LD_INT 0
28948: PPUSH
28949: CALL 29441 0 6
28953: ST_TO_ADDR
// if not hexes then
28954: LD_VAR 0 12
28958: NOT
28959: IFFALSE 28963
// exit ;
28961: GO 29436
// hex := GetHexInfo ( x , y ) ;
28963: LD_ADDR_VAR 0 15
28967: PUSH
28968: LD_VAR 0 3
28972: PPUSH
28973: LD_VAR 0 4
28977: PPUSH
28978: CALL_OW 546
28982: ST_TO_ADDR
// if hex [ 1 ] then
28983: LD_VAR 0 15
28987: PUSH
28988: LD_INT 1
28990: ARRAY
28991: IFFALSE 28995
// exit ;
28993: GO 29436
// height := hex [ 2 ] ;
28995: LD_ADDR_VAR 0 13
28999: PUSH
29000: LD_VAR 0 15
29004: PUSH
29005: LD_INT 2
29007: ARRAY
29008: ST_TO_ADDR
// for i = 1 to hexes do
29009: LD_ADDR_VAR 0 7
29013: PUSH
29014: DOUBLE
29015: LD_INT 1
29017: DEC
29018: ST_TO_ADDR
29019: LD_VAR 0 12
29023: PUSH
29024: FOR_TO
29025: IFFALSE 29355
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29027: LD_VAR 0 12
29031: PUSH
29032: LD_VAR 0 7
29036: ARRAY
29037: PUSH
29038: LD_INT 1
29040: ARRAY
29041: PPUSH
29042: LD_VAR 0 12
29046: PUSH
29047: LD_VAR 0 7
29051: ARRAY
29052: PUSH
29053: LD_INT 2
29055: ARRAY
29056: PPUSH
29057: CALL_OW 488
29061: NOT
29062: PUSH
29063: LD_VAR 0 12
29067: PUSH
29068: LD_VAR 0 7
29072: ARRAY
29073: PUSH
29074: LD_INT 1
29076: ARRAY
29077: PPUSH
29078: LD_VAR 0 12
29082: PUSH
29083: LD_VAR 0 7
29087: ARRAY
29088: PUSH
29089: LD_INT 2
29091: ARRAY
29092: PPUSH
29093: CALL_OW 428
29097: PUSH
29098: LD_INT 0
29100: GREATER
29101: OR
29102: PUSH
29103: LD_VAR 0 12
29107: PUSH
29108: LD_VAR 0 7
29112: ARRAY
29113: PUSH
29114: LD_INT 1
29116: ARRAY
29117: PPUSH
29118: LD_VAR 0 12
29122: PUSH
29123: LD_VAR 0 7
29127: ARRAY
29128: PUSH
29129: LD_INT 2
29131: ARRAY
29132: PPUSH
29133: CALL_OW 351
29137: OR
29138: IFFALSE 29144
// exit ;
29140: POP
29141: POP
29142: GO 29436
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29144: LD_ADDR_VAR 0 8
29148: PUSH
29149: LD_VAR 0 12
29153: PUSH
29154: LD_VAR 0 7
29158: ARRAY
29159: PUSH
29160: LD_INT 1
29162: ARRAY
29163: PPUSH
29164: LD_VAR 0 12
29168: PUSH
29169: LD_VAR 0 7
29173: ARRAY
29174: PUSH
29175: LD_INT 2
29177: ARRAY
29178: PPUSH
29179: CALL_OW 546
29183: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29184: LD_VAR 0 8
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PUSH
29193: LD_VAR 0 8
29197: PUSH
29198: LD_INT 2
29200: ARRAY
29201: PUSH
29202: LD_VAR 0 13
29206: PUSH
29207: LD_INT 2
29209: PLUS
29210: GREATER
29211: OR
29212: PUSH
29213: LD_VAR 0 8
29217: PUSH
29218: LD_INT 2
29220: ARRAY
29221: PUSH
29222: LD_VAR 0 13
29226: PUSH
29227: LD_INT 2
29229: MINUS
29230: LESS
29231: OR
29232: PUSH
29233: LD_VAR 0 8
29237: PUSH
29238: LD_INT 3
29240: ARRAY
29241: PUSH
29242: LD_INT 0
29244: PUSH
29245: LD_INT 8
29247: PUSH
29248: LD_INT 9
29250: PUSH
29251: LD_INT 10
29253: PUSH
29254: LD_INT 11
29256: PUSH
29257: LD_INT 12
29259: PUSH
29260: LD_INT 13
29262: PUSH
29263: LD_INT 16
29265: PUSH
29266: LD_INT 17
29268: PUSH
29269: LD_INT 18
29271: PUSH
29272: LD_INT 19
29274: PUSH
29275: LD_INT 20
29277: PUSH
29278: LD_INT 21
29280: PUSH
29281: EMPTY
29282: LIST
29283: LIST
29284: LIST
29285: LIST
29286: LIST
29287: LIST
29288: LIST
29289: LIST
29290: LIST
29291: LIST
29292: LIST
29293: LIST
29294: LIST
29295: IN
29296: NOT
29297: OR
29298: PUSH
29299: LD_VAR 0 8
29303: PUSH
29304: LD_INT 5
29306: ARRAY
29307: NOT
29308: OR
29309: PUSH
29310: LD_VAR 0 8
29314: PUSH
29315: LD_INT 6
29317: ARRAY
29318: PUSH
29319: LD_INT 1
29321: PUSH
29322: LD_INT 2
29324: PUSH
29325: LD_INT 7
29327: PUSH
29328: LD_INT 9
29330: PUSH
29331: LD_INT 10
29333: PUSH
29334: LD_INT 11
29336: PUSH
29337: EMPTY
29338: LIST
29339: LIST
29340: LIST
29341: LIST
29342: LIST
29343: LIST
29344: IN
29345: NOT
29346: OR
29347: IFFALSE 29353
// exit ;
29349: POP
29350: POP
29351: GO 29436
// end ;
29353: GO 29024
29355: POP
29356: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29357: LD_VAR 0 9
29361: PPUSH
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_VAR 0 4
29371: PPUSH
29372: LD_INT 20
29374: PPUSH
29375: CALL 21359 0 4
29379: PUSH
29380: LD_INT 4
29382: ARRAY
29383: IFFALSE 29387
// exit ;
29385: GO 29436
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29387: LD_VAR 0 2
29391: PUSH
29392: LD_INT 29
29394: PUSH
29395: LD_INT 30
29397: PUSH
29398: EMPTY
29399: LIST
29400: LIST
29401: IN
29402: PUSH
29403: LD_VAR 0 3
29407: PPUSH
29408: LD_VAR 0 4
29412: PPUSH
29413: LD_VAR 0 9
29417: PPUSH
29418: CALL_OW 440
29422: NOT
29423: AND
29424: IFFALSE 29428
// exit ;
29426: GO 29436
// result := true ;
29428: LD_ADDR_VAR 0 6
29432: PUSH
29433: LD_INT 1
29435: ST_TO_ADDR
// end ;
29436: LD_VAR 0 6
29440: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29441: LD_INT 0
29443: PPUSH
29444: PPUSH
29445: PPUSH
29446: PPUSH
29447: PPUSH
29448: PPUSH
29449: PPUSH
29450: PPUSH
29451: PPUSH
29452: PPUSH
29453: PPUSH
29454: PPUSH
29455: PPUSH
29456: PPUSH
29457: PPUSH
29458: PPUSH
29459: PPUSH
29460: PPUSH
29461: PPUSH
29462: PPUSH
29463: PPUSH
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
29468: PPUSH
29469: PPUSH
29470: PPUSH
29471: PPUSH
29472: PPUSH
29473: PPUSH
29474: PPUSH
29475: PPUSH
29476: PPUSH
29477: PPUSH
29478: PPUSH
29479: PPUSH
29480: PPUSH
29481: PPUSH
29482: PPUSH
29483: PPUSH
29484: PPUSH
29485: PPUSH
29486: PPUSH
29487: PPUSH
29488: PPUSH
29489: PPUSH
29490: PPUSH
29491: PPUSH
29492: PPUSH
29493: PPUSH
29494: PPUSH
29495: PPUSH
29496: PPUSH
29497: PPUSH
29498: PPUSH
29499: PPUSH
29500: PPUSH
// result = [ ] ;
29501: LD_ADDR_VAR 0 7
29505: PUSH
29506: EMPTY
29507: ST_TO_ADDR
// temp_list = [ ] ;
29508: LD_ADDR_VAR 0 9
29512: PUSH
29513: EMPTY
29514: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29515: LD_VAR 0 4
29519: PUSH
29520: LD_INT 0
29522: PUSH
29523: LD_INT 1
29525: PUSH
29526: LD_INT 2
29528: PUSH
29529: LD_INT 3
29531: PUSH
29532: LD_INT 4
29534: PUSH
29535: LD_INT 5
29537: PUSH
29538: EMPTY
29539: LIST
29540: LIST
29541: LIST
29542: LIST
29543: LIST
29544: LIST
29545: IN
29546: NOT
29547: PUSH
29548: LD_VAR 0 1
29552: PUSH
29553: LD_INT 0
29555: PUSH
29556: LD_INT 1
29558: PUSH
29559: EMPTY
29560: LIST
29561: LIST
29562: IN
29563: PUSH
29564: LD_VAR 0 5
29568: PUSH
29569: LD_INT 1
29571: PUSH
29572: LD_INT 2
29574: PUSH
29575: LD_INT 3
29577: PUSH
29578: EMPTY
29579: LIST
29580: LIST
29581: LIST
29582: IN
29583: NOT
29584: AND
29585: OR
29586: IFFALSE 29590
// exit ;
29588: GO 47981
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29590: LD_VAR 0 1
29594: PUSH
29595: LD_INT 6
29597: PUSH
29598: LD_INT 7
29600: PUSH
29601: LD_INT 8
29603: PUSH
29604: LD_INT 13
29606: PUSH
29607: LD_INT 12
29609: PUSH
29610: LD_INT 15
29612: PUSH
29613: LD_INT 11
29615: PUSH
29616: LD_INT 14
29618: PUSH
29619: LD_INT 10
29621: PUSH
29622: EMPTY
29623: LIST
29624: LIST
29625: LIST
29626: LIST
29627: LIST
29628: LIST
29629: LIST
29630: LIST
29631: LIST
29632: IN
29633: IFFALSE 29643
// btype = b_lab ;
29635: LD_ADDR_VAR 0 1
29639: PUSH
29640: LD_INT 6
29642: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29643: LD_VAR 0 6
29647: PUSH
29648: LD_INT 0
29650: PUSH
29651: LD_INT 1
29653: PUSH
29654: LD_INT 2
29656: PUSH
29657: EMPTY
29658: LIST
29659: LIST
29660: LIST
29661: IN
29662: NOT
29663: PUSH
29664: LD_VAR 0 1
29668: PUSH
29669: LD_INT 0
29671: PUSH
29672: LD_INT 1
29674: PUSH
29675: LD_INT 2
29677: PUSH
29678: LD_INT 3
29680: PUSH
29681: LD_INT 6
29683: PUSH
29684: LD_INT 36
29686: PUSH
29687: LD_INT 4
29689: PUSH
29690: LD_INT 5
29692: PUSH
29693: LD_INT 31
29695: PUSH
29696: LD_INT 32
29698: PUSH
29699: LD_INT 33
29701: PUSH
29702: EMPTY
29703: LIST
29704: LIST
29705: LIST
29706: LIST
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: IN
29715: NOT
29716: PUSH
29717: LD_VAR 0 6
29721: PUSH
29722: LD_INT 1
29724: EQUAL
29725: AND
29726: OR
29727: PUSH
29728: LD_VAR 0 1
29732: PUSH
29733: LD_INT 2
29735: PUSH
29736: LD_INT 3
29738: PUSH
29739: EMPTY
29740: LIST
29741: LIST
29742: IN
29743: NOT
29744: PUSH
29745: LD_VAR 0 6
29749: PUSH
29750: LD_INT 2
29752: EQUAL
29753: AND
29754: OR
29755: IFFALSE 29765
// mode = 0 ;
29757: LD_ADDR_VAR 0 6
29761: PUSH
29762: LD_INT 0
29764: ST_TO_ADDR
// case mode of 0 :
29765: LD_VAR 0 6
29769: PUSH
29770: LD_INT 0
29772: DOUBLE
29773: EQUAL
29774: IFTRUE 29778
29776: GO 41231
29778: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29779: LD_ADDR_VAR 0 11
29783: PUSH
29784: LD_INT 0
29786: PUSH
29787: LD_INT 0
29789: PUSH
29790: EMPTY
29791: LIST
29792: LIST
29793: PUSH
29794: LD_INT 0
29796: PUSH
29797: LD_INT 1
29799: NEG
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 1
29807: PUSH
29808: LD_INT 0
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: PUSH
29818: LD_INT 1
29820: PUSH
29821: EMPTY
29822: LIST
29823: LIST
29824: PUSH
29825: LD_INT 0
29827: PUSH
29828: LD_INT 1
29830: PUSH
29831: EMPTY
29832: LIST
29833: LIST
29834: PUSH
29835: LD_INT 1
29837: NEG
29838: PUSH
29839: LD_INT 0
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: NEG
29853: PUSH
29854: EMPTY
29855: LIST
29856: LIST
29857: PUSH
29858: LD_INT 1
29860: NEG
29861: PUSH
29862: LD_INT 2
29864: NEG
29865: PUSH
29866: EMPTY
29867: LIST
29868: LIST
29869: PUSH
29870: LD_INT 0
29872: PUSH
29873: LD_INT 2
29875: NEG
29876: PUSH
29877: EMPTY
29878: LIST
29879: LIST
29880: PUSH
29881: LD_INT 1
29883: PUSH
29884: LD_INT 1
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: PUSH
29895: LD_INT 2
29897: PUSH
29898: EMPTY
29899: LIST
29900: LIST
29901: PUSH
29902: LD_INT 0
29904: PUSH
29905: LD_INT 2
29907: PUSH
29908: EMPTY
29909: LIST
29910: LIST
29911: PUSH
29912: LD_INT 1
29914: NEG
29915: PUSH
29916: LD_INT 1
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: PUSH
29926: LD_INT 3
29928: PUSH
29929: EMPTY
29930: LIST
29931: LIST
29932: PUSH
29933: LD_INT 0
29935: PUSH
29936: LD_INT 3
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PUSH
29943: LD_INT 1
29945: NEG
29946: PUSH
29947: LD_INT 2
29949: PUSH
29950: EMPTY
29951: LIST
29952: LIST
29953: PUSH
29954: EMPTY
29955: LIST
29956: LIST
29957: LIST
29958: LIST
29959: LIST
29960: LIST
29961: LIST
29962: LIST
29963: LIST
29964: LIST
29965: LIST
29966: LIST
29967: LIST
29968: LIST
29969: LIST
29970: LIST
29971: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29972: LD_ADDR_VAR 0 12
29976: PUSH
29977: LD_INT 0
29979: PUSH
29980: LD_INT 0
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: LD_INT 0
29989: PUSH
29990: LD_INT 1
29992: NEG
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 1
30000: PUSH
30001: LD_INT 0
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: PUSH
30011: LD_INT 1
30013: PUSH
30014: EMPTY
30015: LIST
30016: LIST
30017: PUSH
30018: LD_INT 0
30020: PUSH
30021: LD_INT 1
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PUSH
30028: LD_INT 1
30030: NEG
30031: PUSH
30032: LD_INT 0
30034: PUSH
30035: EMPTY
30036: LIST
30037: LIST
30038: PUSH
30039: LD_INT 1
30041: NEG
30042: PUSH
30043: LD_INT 1
30045: NEG
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 1
30053: PUSH
30054: LD_INT 1
30056: NEG
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 2
30064: PUSH
30065: LD_INT 0
30067: PUSH
30068: EMPTY
30069: LIST
30070: LIST
30071: PUSH
30072: LD_INT 2
30074: PUSH
30075: LD_INT 1
30077: PUSH
30078: EMPTY
30079: LIST
30080: LIST
30081: PUSH
30082: LD_INT 1
30084: NEG
30085: PUSH
30086: LD_INT 1
30088: PUSH
30089: EMPTY
30090: LIST
30091: LIST
30092: PUSH
30093: LD_INT 2
30095: NEG
30096: PUSH
30097: LD_INT 0
30099: PUSH
30100: EMPTY
30101: LIST
30102: LIST
30103: PUSH
30104: LD_INT 2
30106: NEG
30107: PUSH
30108: LD_INT 1
30110: NEG
30111: PUSH
30112: EMPTY
30113: LIST
30114: LIST
30115: PUSH
30116: LD_INT 2
30118: NEG
30119: PUSH
30120: LD_INT 1
30122: PUSH
30123: EMPTY
30124: LIST
30125: LIST
30126: PUSH
30127: LD_INT 3
30129: NEG
30130: PUSH
30131: LD_INT 0
30133: PUSH
30134: EMPTY
30135: LIST
30136: LIST
30137: PUSH
30138: LD_INT 3
30140: NEG
30141: PUSH
30142: LD_INT 1
30144: NEG
30145: PUSH
30146: EMPTY
30147: LIST
30148: LIST
30149: PUSH
30150: EMPTY
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30168: LD_ADDR_VAR 0 13
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 0
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: LD_INT 1
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 1
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: LD_INT 0
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: NEG
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: LD_INT 2
30253: NEG
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 2
30261: PUSH
30262: LD_INT 1
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 2
30271: PUSH
30272: LD_INT 2
30274: PUSH
30275: EMPTY
30276: LIST
30277: LIST
30278: PUSH
30279: LD_INT 1
30281: PUSH
30282: LD_INT 2
30284: PUSH
30285: EMPTY
30286: LIST
30287: LIST
30288: PUSH
30289: LD_INT 2
30291: NEG
30292: PUSH
30293: LD_INT 1
30295: NEG
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 2
30303: NEG
30304: PUSH
30305: LD_INT 2
30307: NEG
30308: PUSH
30309: EMPTY
30310: LIST
30311: LIST
30312: PUSH
30313: LD_INT 2
30315: NEG
30316: PUSH
30317: LD_INT 3
30319: NEG
30320: PUSH
30321: EMPTY
30322: LIST
30323: LIST
30324: PUSH
30325: LD_INT 3
30327: NEG
30328: PUSH
30329: LD_INT 2
30331: NEG
30332: PUSH
30333: EMPTY
30334: LIST
30335: LIST
30336: PUSH
30337: LD_INT 3
30339: NEG
30340: PUSH
30341: LD_INT 3
30343: NEG
30344: PUSH
30345: EMPTY
30346: LIST
30347: LIST
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: LIST
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30367: LD_ADDR_VAR 0 14
30371: PUSH
30372: LD_INT 0
30374: PUSH
30375: LD_INT 0
30377: PUSH
30378: EMPTY
30379: LIST
30380: LIST
30381: PUSH
30382: LD_INT 0
30384: PUSH
30385: LD_INT 1
30387: NEG
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 1
30395: PUSH
30396: LD_INT 0
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: PUSH
30406: LD_INT 1
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 0
30415: PUSH
30416: LD_INT 1
30418: PUSH
30419: EMPTY
30420: LIST
30421: LIST
30422: PUSH
30423: LD_INT 1
30425: NEG
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: NEG
30437: PUSH
30438: LD_INT 1
30440: NEG
30441: PUSH
30442: EMPTY
30443: LIST
30444: LIST
30445: PUSH
30446: LD_INT 1
30448: NEG
30449: PUSH
30450: LD_INT 2
30452: NEG
30453: PUSH
30454: EMPTY
30455: LIST
30456: LIST
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: LD_INT 2
30463: NEG
30464: PUSH
30465: EMPTY
30466: LIST
30467: LIST
30468: PUSH
30469: LD_INT 1
30471: PUSH
30472: LD_INT 1
30474: NEG
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 1
30482: PUSH
30483: LD_INT 2
30485: PUSH
30486: EMPTY
30487: LIST
30488: LIST
30489: PUSH
30490: LD_INT 0
30492: PUSH
30493: LD_INT 2
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 1
30502: NEG
30503: PUSH
30504: LD_INT 1
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 1
30513: NEG
30514: PUSH
30515: LD_INT 3
30517: NEG
30518: PUSH
30519: EMPTY
30520: LIST
30521: LIST
30522: PUSH
30523: LD_INT 0
30525: PUSH
30526: LD_INT 3
30528: NEG
30529: PUSH
30530: EMPTY
30531: LIST
30532: LIST
30533: PUSH
30534: LD_INT 1
30536: PUSH
30537: LD_INT 2
30539: NEG
30540: PUSH
30541: EMPTY
30542: LIST
30543: LIST
30544: PUSH
30545: EMPTY
30546: LIST
30547: LIST
30548: LIST
30549: LIST
30550: LIST
30551: LIST
30552: LIST
30553: LIST
30554: LIST
30555: LIST
30556: LIST
30557: LIST
30558: LIST
30559: LIST
30560: LIST
30561: LIST
30562: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30563: LD_ADDR_VAR 0 15
30567: PUSH
30568: LD_INT 0
30570: PUSH
30571: LD_INT 0
30573: PUSH
30574: EMPTY
30575: LIST
30576: LIST
30577: PUSH
30578: LD_INT 0
30580: PUSH
30581: LD_INT 1
30583: NEG
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 1
30591: PUSH
30592: LD_INT 0
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 1
30601: PUSH
30602: LD_INT 1
30604: PUSH
30605: EMPTY
30606: LIST
30607: LIST
30608: PUSH
30609: LD_INT 0
30611: PUSH
30612: LD_INT 1
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: NEG
30622: PUSH
30623: LD_INT 0
30625: PUSH
30626: EMPTY
30627: LIST
30628: LIST
30629: PUSH
30630: LD_INT 1
30632: NEG
30633: PUSH
30634: LD_INT 1
30636: NEG
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 1
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 2
30655: PUSH
30656: LD_INT 0
30658: PUSH
30659: EMPTY
30660: LIST
30661: LIST
30662: PUSH
30663: LD_INT 2
30665: PUSH
30666: LD_INT 1
30668: PUSH
30669: EMPTY
30670: LIST
30671: LIST
30672: PUSH
30673: LD_INT 1
30675: NEG
30676: PUSH
30677: LD_INT 1
30679: PUSH
30680: EMPTY
30681: LIST
30682: LIST
30683: PUSH
30684: LD_INT 2
30686: NEG
30687: PUSH
30688: LD_INT 0
30690: PUSH
30691: EMPTY
30692: LIST
30693: LIST
30694: PUSH
30695: LD_INT 2
30697: NEG
30698: PUSH
30699: LD_INT 1
30701: NEG
30702: PUSH
30703: EMPTY
30704: LIST
30705: LIST
30706: PUSH
30707: LD_INT 2
30709: PUSH
30710: LD_INT 1
30712: NEG
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: LD_INT 3
30720: PUSH
30721: LD_INT 0
30723: PUSH
30724: EMPTY
30725: LIST
30726: LIST
30727: PUSH
30728: LD_INT 3
30730: PUSH
30731: LD_INT 1
30733: PUSH
30734: EMPTY
30735: LIST
30736: LIST
30737: PUSH
30738: EMPTY
30739: LIST
30740: LIST
30741: LIST
30742: LIST
30743: LIST
30744: LIST
30745: LIST
30746: LIST
30747: LIST
30748: LIST
30749: LIST
30750: LIST
30751: LIST
30752: LIST
30753: LIST
30754: LIST
30755: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30756: LD_ADDR_VAR 0 16
30760: PUSH
30761: LD_INT 0
30763: PUSH
30764: LD_INT 0
30766: PUSH
30767: EMPTY
30768: LIST
30769: LIST
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: LD_INT 1
30776: NEG
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 1
30784: PUSH
30785: LD_INT 0
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: PUSH
30795: LD_INT 1
30797: PUSH
30798: EMPTY
30799: LIST
30800: LIST
30801: PUSH
30802: LD_INT 0
30804: PUSH
30805: LD_INT 1
30807: PUSH
30808: EMPTY
30809: LIST
30810: LIST
30811: PUSH
30812: LD_INT 1
30814: NEG
30815: PUSH
30816: LD_INT 0
30818: PUSH
30819: EMPTY
30820: LIST
30821: LIST
30822: PUSH
30823: LD_INT 1
30825: NEG
30826: PUSH
30827: LD_INT 1
30829: NEG
30830: PUSH
30831: EMPTY
30832: LIST
30833: LIST
30834: PUSH
30835: LD_INT 1
30837: NEG
30838: PUSH
30839: LD_INT 2
30841: NEG
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 2
30849: PUSH
30850: LD_INT 1
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 2
30859: PUSH
30860: LD_INT 2
30862: PUSH
30863: EMPTY
30864: LIST
30865: LIST
30866: PUSH
30867: LD_INT 1
30869: PUSH
30870: LD_INT 2
30872: PUSH
30873: EMPTY
30874: LIST
30875: LIST
30876: PUSH
30877: LD_INT 2
30879: NEG
30880: PUSH
30881: LD_INT 1
30883: NEG
30884: PUSH
30885: EMPTY
30886: LIST
30887: LIST
30888: PUSH
30889: LD_INT 2
30891: NEG
30892: PUSH
30893: LD_INT 2
30895: NEG
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 3
30903: PUSH
30904: LD_INT 2
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: LD_INT 3
30913: PUSH
30914: LD_INT 3
30916: PUSH
30917: EMPTY
30918: LIST
30919: LIST
30920: PUSH
30921: LD_INT 2
30923: PUSH
30924: LD_INT 3
30926: PUSH
30927: EMPTY
30928: LIST
30929: LIST
30930: PUSH
30931: EMPTY
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30949: LD_ADDR_VAR 0 17
30953: PUSH
30954: LD_INT 0
30956: PUSH
30957: LD_INT 0
30959: PUSH
30960: EMPTY
30961: LIST
30962: LIST
30963: PUSH
30964: LD_INT 0
30966: PUSH
30967: LD_INT 1
30969: NEG
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 1
30977: PUSH
30978: LD_INT 0
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: PUSH
30988: LD_INT 1
30990: PUSH
30991: EMPTY
30992: LIST
30993: LIST
30994: PUSH
30995: LD_INT 0
30997: PUSH
30998: LD_INT 1
31000: PUSH
31001: EMPTY
31002: LIST
31003: LIST
31004: PUSH
31005: LD_INT 1
31007: NEG
31008: PUSH
31009: LD_INT 0
31011: PUSH
31012: EMPTY
31013: LIST
31014: LIST
31015: PUSH
31016: LD_INT 1
31018: NEG
31019: PUSH
31020: LD_INT 1
31022: NEG
31023: PUSH
31024: EMPTY
31025: LIST
31026: LIST
31027: PUSH
31028: LD_INT 1
31030: NEG
31031: PUSH
31032: LD_INT 2
31034: NEG
31035: PUSH
31036: EMPTY
31037: LIST
31038: LIST
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: LD_INT 2
31045: NEG
31046: PUSH
31047: EMPTY
31048: LIST
31049: LIST
31050: PUSH
31051: LD_INT 1
31053: PUSH
31054: LD_INT 1
31056: NEG
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: LD_INT 0
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 2
31074: PUSH
31075: LD_INT 1
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 2
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: PUSH
31095: LD_INT 2
31097: PUSH
31098: EMPTY
31099: LIST
31100: LIST
31101: PUSH
31102: LD_INT 0
31104: PUSH
31105: LD_INT 2
31107: PUSH
31108: EMPTY
31109: LIST
31110: LIST
31111: PUSH
31112: LD_INT 1
31114: NEG
31115: PUSH
31116: LD_INT 1
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 2
31125: NEG
31126: PUSH
31127: LD_INT 0
31129: PUSH
31130: EMPTY
31131: LIST
31132: LIST
31133: PUSH
31134: LD_INT 2
31136: NEG
31137: PUSH
31138: LD_INT 1
31140: NEG
31141: PUSH
31142: EMPTY
31143: LIST
31144: LIST
31145: PUSH
31146: LD_INT 2
31148: NEG
31149: PUSH
31150: LD_INT 2
31152: NEG
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: EMPTY
31159: LIST
31160: LIST
31161: LIST
31162: LIST
31163: LIST
31164: LIST
31165: LIST
31166: LIST
31167: LIST
31168: LIST
31169: LIST
31170: LIST
31171: LIST
31172: LIST
31173: LIST
31174: LIST
31175: LIST
31176: LIST
31177: LIST
31178: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31179: LD_ADDR_VAR 0 18
31183: PUSH
31184: LD_INT 0
31186: PUSH
31187: LD_INT 0
31189: PUSH
31190: EMPTY
31191: LIST
31192: LIST
31193: PUSH
31194: LD_INT 0
31196: PUSH
31197: LD_INT 1
31199: NEG
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 1
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 1
31217: PUSH
31218: LD_INT 1
31220: PUSH
31221: EMPTY
31222: LIST
31223: LIST
31224: PUSH
31225: LD_INT 0
31227: PUSH
31228: LD_INT 1
31230: PUSH
31231: EMPTY
31232: LIST
31233: LIST
31234: PUSH
31235: LD_INT 1
31237: NEG
31238: PUSH
31239: LD_INT 0
31241: PUSH
31242: EMPTY
31243: LIST
31244: LIST
31245: PUSH
31246: LD_INT 1
31248: NEG
31249: PUSH
31250: LD_INT 1
31252: NEG
31253: PUSH
31254: EMPTY
31255: LIST
31256: LIST
31257: PUSH
31258: LD_INT 1
31260: NEG
31261: PUSH
31262: LD_INT 2
31264: NEG
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: LD_INT 2
31275: NEG
31276: PUSH
31277: EMPTY
31278: LIST
31279: LIST
31280: PUSH
31281: LD_INT 1
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: LD_INT 0
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 2
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 2
31314: PUSH
31315: LD_INT 2
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 1
31324: PUSH
31325: LD_INT 2
31327: PUSH
31328: EMPTY
31329: LIST
31330: LIST
31331: PUSH
31332: LD_INT 0
31334: PUSH
31335: LD_INT 2
31337: PUSH
31338: EMPTY
31339: LIST
31340: LIST
31341: PUSH
31342: LD_INT 1
31344: NEG
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 2
31355: NEG
31356: PUSH
31357: LD_INT 0
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 2
31366: NEG
31367: PUSH
31368: LD_INT 1
31370: NEG
31371: PUSH
31372: EMPTY
31373: LIST
31374: LIST
31375: PUSH
31376: LD_INT 2
31378: NEG
31379: PUSH
31380: LD_INT 2
31382: NEG
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: EMPTY
31389: LIST
31390: LIST
31391: LIST
31392: LIST
31393: LIST
31394: LIST
31395: LIST
31396: LIST
31397: LIST
31398: LIST
31399: LIST
31400: LIST
31401: LIST
31402: LIST
31403: LIST
31404: LIST
31405: LIST
31406: LIST
31407: LIST
31408: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31409: LD_ADDR_VAR 0 19
31413: PUSH
31414: LD_INT 0
31416: PUSH
31417: LD_INT 0
31419: PUSH
31420: EMPTY
31421: LIST
31422: LIST
31423: PUSH
31424: LD_INT 0
31426: PUSH
31427: LD_INT 1
31429: NEG
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 1
31437: PUSH
31438: LD_INT 0
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 1
31447: PUSH
31448: LD_INT 1
31450: PUSH
31451: EMPTY
31452: LIST
31453: LIST
31454: PUSH
31455: LD_INT 0
31457: PUSH
31458: LD_INT 1
31460: PUSH
31461: EMPTY
31462: LIST
31463: LIST
31464: PUSH
31465: LD_INT 1
31467: NEG
31468: PUSH
31469: LD_INT 0
31471: PUSH
31472: EMPTY
31473: LIST
31474: LIST
31475: PUSH
31476: LD_INT 1
31478: NEG
31479: PUSH
31480: LD_INT 1
31482: NEG
31483: PUSH
31484: EMPTY
31485: LIST
31486: LIST
31487: PUSH
31488: LD_INT 1
31490: NEG
31491: PUSH
31492: LD_INT 2
31494: NEG
31495: PUSH
31496: EMPTY
31497: LIST
31498: LIST
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: LD_INT 2
31505: NEG
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 1
31513: PUSH
31514: LD_INT 1
31516: NEG
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 2
31534: PUSH
31535: LD_INT 1
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 2
31544: PUSH
31545: LD_INT 2
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 1
31554: PUSH
31555: LD_INT 2
31557: PUSH
31558: EMPTY
31559: LIST
31560: LIST
31561: PUSH
31562: LD_INT 0
31564: PUSH
31565: LD_INT 2
31567: PUSH
31568: EMPTY
31569: LIST
31570: LIST
31571: PUSH
31572: LD_INT 1
31574: NEG
31575: PUSH
31576: LD_INT 1
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 2
31585: NEG
31586: PUSH
31587: LD_INT 0
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: PUSH
31594: LD_INT 2
31596: NEG
31597: PUSH
31598: LD_INT 1
31600: NEG
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: LD_INT 2
31608: NEG
31609: PUSH
31610: LD_INT 2
31612: NEG
31613: PUSH
31614: EMPTY
31615: LIST
31616: LIST
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: LIST
31622: LIST
31623: LIST
31624: LIST
31625: LIST
31626: LIST
31627: LIST
31628: LIST
31629: LIST
31630: LIST
31631: LIST
31632: LIST
31633: LIST
31634: LIST
31635: LIST
31636: LIST
31637: LIST
31638: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31639: LD_ADDR_VAR 0 20
31643: PUSH
31644: LD_INT 0
31646: PUSH
31647: LD_INT 0
31649: PUSH
31650: EMPTY
31651: LIST
31652: LIST
31653: PUSH
31654: LD_INT 0
31656: PUSH
31657: LD_INT 1
31659: NEG
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 1
31667: PUSH
31668: LD_INT 0
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 1
31677: PUSH
31678: LD_INT 1
31680: PUSH
31681: EMPTY
31682: LIST
31683: LIST
31684: PUSH
31685: LD_INT 0
31687: PUSH
31688: LD_INT 1
31690: PUSH
31691: EMPTY
31692: LIST
31693: LIST
31694: PUSH
31695: LD_INT 1
31697: NEG
31698: PUSH
31699: LD_INT 0
31701: PUSH
31702: EMPTY
31703: LIST
31704: LIST
31705: PUSH
31706: LD_INT 1
31708: NEG
31709: PUSH
31710: LD_INT 1
31712: NEG
31713: PUSH
31714: EMPTY
31715: LIST
31716: LIST
31717: PUSH
31718: LD_INT 1
31720: NEG
31721: PUSH
31722: LD_INT 2
31724: NEG
31725: PUSH
31726: EMPTY
31727: LIST
31728: LIST
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: LD_INT 2
31735: NEG
31736: PUSH
31737: EMPTY
31738: LIST
31739: LIST
31740: PUSH
31741: LD_INT 1
31743: PUSH
31744: LD_INT 1
31746: NEG
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 2
31754: PUSH
31755: LD_INT 0
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 2
31764: PUSH
31765: LD_INT 1
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 2
31774: PUSH
31775: LD_INT 2
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: PUSH
31785: LD_INT 2
31787: PUSH
31788: EMPTY
31789: LIST
31790: LIST
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: LD_INT 2
31797: PUSH
31798: EMPTY
31799: LIST
31800: LIST
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: LD_INT 1
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 2
31815: NEG
31816: PUSH
31817: LD_INT 0
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PUSH
31824: LD_INT 2
31826: NEG
31827: PUSH
31828: LD_INT 1
31830: NEG
31831: PUSH
31832: EMPTY
31833: LIST
31834: LIST
31835: PUSH
31836: LD_INT 2
31838: NEG
31839: PUSH
31840: LD_INT 2
31842: NEG
31843: PUSH
31844: EMPTY
31845: LIST
31846: LIST
31847: PUSH
31848: EMPTY
31849: LIST
31850: LIST
31851: LIST
31852: LIST
31853: LIST
31854: LIST
31855: LIST
31856: LIST
31857: LIST
31858: LIST
31859: LIST
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: LIST
31865: LIST
31866: LIST
31867: LIST
31868: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31869: LD_ADDR_VAR 0 21
31873: PUSH
31874: LD_INT 0
31876: PUSH
31877: LD_INT 0
31879: PUSH
31880: EMPTY
31881: LIST
31882: LIST
31883: PUSH
31884: LD_INT 0
31886: PUSH
31887: LD_INT 1
31889: NEG
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 1
31897: PUSH
31898: LD_INT 0
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: PUSH
31908: LD_INT 1
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: PUSH
31915: LD_INT 0
31917: PUSH
31918: LD_INT 1
31920: PUSH
31921: EMPTY
31922: LIST
31923: LIST
31924: PUSH
31925: LD_INT 1
31927: NEG
31928: PUSH
31929: LD_INT 0
31931: PUSH
31932: EMPTY
31933: LIST
31934: LIST
31935: PUSH
31936: LD_INT 1
31938: NEG
31939: PUSH
31940: LD_INT 1
31942: NEG
31943: PUSH
31944: EMPTY
31945: LIST
31946: LIST
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: LD_INT 2
31954: NEG
31955: PUSH
31956: EMPTY
31957: LIST
31958: LIST
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: LD_INT 2
31965: NEG
31966: PUSH
31967: EMPTY
31968: LIST
31969: LIST
31970: PUSH
31971: LD_INT 1
31973: PUSH
31974: LD_INT 1
31976: NEG
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: LD_INT 0
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 2
31994: PUSH
31995: LD_INT 1
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 2
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 1
32014: PUSH
32015: LD_INT 2
32017: PUSH
32018: EMPTY
32019: LIST
32020: LIST
32021: PUSH
32022: LD_INT 0
32024: PUSH
32025: LD_INT 2
32027: PUSH
32028: EMPTY
32029: LIST
32030: LIST
32031: PUSH
32032: LD_INT 1
32034: NEG
32035: PUSH
32036: LD_INT 1
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 2
32045: NEG
32046: PUSH
32047: LD_INT 0
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 2
32056: NEG
32057: PUSH
32058: LD_INT 1
32060: NEG
32061: PUSH
32062: EMPTY
32063: LIST
32064: LIST
32065: PUSH
32066: LD_INT 2
32068: NEG
32069: PUSH
32070: LD_INT 2
32072: NEG
32073: PUSH
32074: EMPTY
32075: LIST
32076: LIST
32077: PUSH
32078: EMPTY
32079: LIST
32080: LIST
32081: LIST
32082: LIST
32083: LIST
32084: LIST
32085: LIST
32086: LIST
32087: LIST
32088: LIST
32089: LIST
32090: LIST
32091: LIST
32092: LIST
32093: LIST
32094: LIST
32095: LIST
32096: LIST
32097: LIST
32098: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32099: LD_ADDR_VAR 0 22
32103: PUSH
32104: LD_INT 0
32106: PUSH
32107: LD_INT 0
32109: PUSH
32110: EMPTY
32111: LIST
32112: LIST
32113: PUSH
32114: LD_INT 0
32116: PUSH
32117: LD_INT 1
32119: NEG
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 1
32127: PUSH
32128: LD_INT 0
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: PUSH
32138: LD_INT 1
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 0
32147: PUSH
32148: LD_INT 1
32150: PUSH
32151: EMPTY
32152: LIST
32153: LIST
32154: PUSH
32155: LD_INT 1
32157: NEG
32158: PUSH
32159: LD_INT 0
32161: PUSH
32162: EMPTY
32163: LIST
32164: LIST
32165: PUSH
32166: LD_INT 1
32168: NEG
32169: PUSH
32170: LD_INT 1
32172: NEG
32173: PUSH
32174: EMPTY
32175: LIST
32176: LIST
32177: PUSH
32178: LD_INT 1
32180: NEG
32181: PUSH
32182: LD_INT 2
32184: NEG
32185: PUSH
32186: EMPTY
32187: LIST
32188: LIST
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: LD_INT 2
32195: NEG
32196: PUSH
32197: EMPTY
32198: LIST
32199: LIST
32200: PUSH
32201: LD_INT 1
32203: PUSH
32204: LD_INT 1
32206: NEG
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: LD_INT 0
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 2
32224: PUSH
32225: LD_INT 1
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 2
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 1
32244: PUSH
32245: LD_INT 2
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 0
32254: PUSH
32255: LD_INT 2
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: NEG
32265: PUSH
32266: LD_INT 1
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 2
32275: NEG
32276: PUSH
32277: LD_INT 0
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 2
32286: NEG
32287: PUSH
32288: LD_INT 1
32290: NEG
32291: PUSH
32292: EMPTY
32293: LIST
32294: LIST
32295: PUSH
32296: LD_INT 2
32298: NEG
32299: PUSH
32300: LD_INT 2
32302: NEG
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: LIST
32320: LIST
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32329: LD_ADDR_VAR 0 23
32333: PUSH
32334: LD_INT 0
32336: PUSH
32337: LD_INT 0
32339: PUSH
32340: EMPTY
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 0
32346: PUSH
32347: LD_INT 1
32349: NEG
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 1
32357: PUSH
32358: LD_INT 0
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 1
32367: PUSH
32368: LD_INT 1
32370: PUSH
32371: EMPTY
32372: LIST
32373: LIST
32374: PUSH
32375: LD_INT 0
32377: PUSH
32378: LD_INT 1
32380: PUSH
32381: EMPTY
32382: LIST
32383: LIST
32384: PUSH
32385: LD_INT 1
32387: NEG
32388: PUSH
32389: LD_INT 0
32391: PUSH
32392: EMPTY
32393: LIST
32394: LIST
32395: PUSH
32396: LD_INT 1
32398: NEG
32399: PUSH
32400: LD_INT 1
32402: NEG
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: PUSH
32408: LD_INT 1
32410: NEG
32411: PUSH
32412: LD_INT 2
32414: NEG
32415: PUSH
32416: EMPTY
32417: LIST
32418: LIST
32419: PUSH
32420: LD_INT 0
32422: PUSH
32423: LD_INT 2
32425: NEG
32426: PUSH
32427: EMPTY
32428: LIST
32429: LIST
32430: PUSH
32431: LD_INT 1
32433: PUSH
32434: LD_INT 1
32436: NEG
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 2
32444: PUSH
32445: LD_INT 0
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 2
32454: PUSH
32455: LD_INT 1
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 2
32464: PUSH
32465: LD_INT 2
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 1
32474: PUSH
32475: LD_INT 2
32477: PUSH
32478: EMPTY
32479: LIST
32480: LIST
32481: PUSH
32482: LD_INT 0
32484: PUSH
32485: LD_INT 2
32487: PUSH
32488: EMPTY
32489: LIST
32490: LIST
32491: PUSH
32492: LD_INT 1
32494: NEG
32495: PUSH
32496: LD_INT 1
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 2
32505: NEG
32506: PUSH
32507: LD_INT 0
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 2
32516: NEG
32517: PUSH
32518: LD_INT 1
32520: NEG
32521: PUSH
32522: EMPTY
32523: LIST
32524: LIST
32525: PUSH
32526: LD_INT 2
32528: NEG
32529: PUSH
32530: LD_INT 2
32532: NEG
32533: PUSH
32534: EMPTY
32535: LIST
32536: LIST
32537: PUSH
32538: LD_INT 2
32540: NEG
32541: PUSH
32542: LD_INT 3
32544: NEG
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 1
32552: NEG
32553: PUSH
32554: LD_INT 3
32556: NEG
32557: PUSH
32558: EMPTY
32559: LIST
32560: LIST
32561: PUSH
32562: LD_INT 1
32564: PUSH
32565: LD_INT 2
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: LD_INT 2
32575: PUSH
32576: LD_INT 1
32578: NEG
32579: PUSH
32580: EMPTY
32581: LIST
32582: LIST
32583: PUSH
32584: EMPTY
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: LIST
32598: LIST
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32609: LD_ADDR_VAR 0 24
32613: PUSH
32614: LD_INT 0
32616: PUSH
32617: LD_INT 0
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 0
32626: PUSH
32627: LD_INT 1
32629: NEG
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 1
32637: PUSH
32638: LD_INT 0
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: LD_INT 1
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PUSH
32655: LD_INT 0
32657: PUSH
32658: LD_INT 1
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: EMPTY
32673: LIST
32674: LIST
32675: PUSH
32676: LD_INT 1
32678: NEG
32679: PUSH
32680: LD_INT 1
32682: NEG
32683: PUSH
32684: EMPTY
32685: LIST
32686: LIST
32687: PUSH
32688: LD_INT 1
32690: NEG
32691: PUSH
32692: LD_INT 2
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: LD_INT 2
32705: NEG
32706: PUSH
32707: EMPTY
32708: LIST
32709: LIST
32710: PUSH
32711: LD_INT 1
32713: PUSH
32714: LD_INT 1
32716: NEG
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 2
32724: PUSH
32725: LD_INT 0
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: LD_INT 1
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 2
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: PUSH
32755: LD_INT 2
32757: PUSH
32758: EMPTY
32759: LIST
32760: LIST
32761: PUSH
32762: LD_INT 0
32764: PUSH
32765: LD_INT 2
32767: PUSH
32768: EMPTY
32769: LIST
32770: LIST
32771: PUSH
32772: LD_INT 1
32774: NEG
32775: PUSH
32776: LD_INT 1
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 2
32785: NEG
32786: PUSH
32787: LD_INT 0
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 2
32796: NEG
32797: PUSH
32798: LD_INT 1
32800: NEG
32801: PUSH
32802: EMPTY
32803: LIST
32804: LIST
32805: PUSH
32806: LD_INT 2
32808: NEG
32809: PUSH
32810: LD_INT 2
32812: NEG
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 2
32823: NEG
32824: PUSH
32825: EMPTY
32826: LIST
32827: LIST
32828: PUSH
32829: LD_INT 2
32831: PUSH
32832: LD_INT 1
32834: NEG
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: LD_INT 3
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: EMPTY
32847: LIST
32848: LIST
32849: PUSH
32850: LD_INT 3
32852: PUSH
32853: LD_INT 2
32855: PUSH
32856: EMPTY
32857: LIST
32858: LIST
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: LIST
32876: LIST
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32885: LD_ADDR_VAR 0 25
32889: PUSH
32890: LD_INT 0
32892: PUSH
32893: LD_INT 0
32895: PUSH
32896: EMPTY
32897: LIST
32898: LIST
32899: PUSH
32900: LD_INT 0
32902: PUSH
32903: LD_INT 1
32905: NEG
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 1
32913: PUSH
32914: LD_INT 0
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: PUSH
32924: LD_INT 1
32926: PUSH
32927: EMPTY
32928: LIST
32929: LIST
32930: PUSH
32931: LD_INT 0
32933: PUSH
32934: LD_INT 1
32936: PUSH
32937: EMPTY
32938: LIST
32939: LIST
32940: PUSH
32941: LD_INT 1
32943: NEG
32944: PUSH
32945: LD_INT 0
32947: PUSH
32948: EMPTY
32949: LIST
32950: LIST
32951: PUSH
32952: LD_INT 1
32954: NEG
32955: PUSH
32956: LD_INT 1
32958: NEG
32959: PUSH
32960: EMPTY
32961: LIST
32962: LIST
32963: PUSH
32964: LD_INT 1
32966: NEG
32967: PUSH
32968: LD_INT 2
32970: NEG
32971: PUSH
32972: EMPTY
32973: LIST
32974: LIST
32975: PUSH
32976: LD_INT 0
32978: PUSH
32979: LD_INT 2
32981: NEG
32982: PUSH
32983: EMPTY
32984: LIST
32985: LIST
32986: PUSH
32987: LD_INT 1
32989: PUSH
32990: LD_INT 1
32992: NEG
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 2
33000: PUSH
33001: LD_INT 0
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 2
33010: PUSH
33011: LD_INT 1
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 2
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 1
33030: PUSH
33031: LD_INT 2
33033: PUSH
33034: EMPTY
33035: LIST
33036: LIST
33037: PUSH
33038: LD_INT 0
33040: PUSH
33041: LD_INT 2
33043: PUSH
33044: EMPTY
33045: LIST
33046: LIST
33047: PUSH
33048: LD_INT 1
33050: NEG
33051: PUSH
33052: LD_INT 1
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 2
33061: NEG
33062: PUSH
33063: LD_INT 0
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 2
33072: NEG
33073: PUSH
33074: LD_INT 1
33076: NEG
33077: PUSH
33078: EMPTY
33079: LIST
33080: LIST
33081: PUSH
33082: LD_INT 2
33084: NEG
33085: PUSH
33086: LD_INT 2
33088: NEG
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 3
33096: PUSH
33097: LD_INT 1
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 3
33106: PUSH
33107: LD_INT 2
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: LD_INT 2
33116: PUSH
33117: LD_INT 3
33119: PUSH
33120: EMPTY
33121: LIST
33122: LIST
33123: PUSH
33124: LD_INT 1
33126: PUSH
33127: LD_INT 3
33129: PUSH
33130: EMPTY
33131: LIST
33132: LIST
33133: PUSH
33134: EMPTY
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: LIST
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33159: LD_ADDR_VAR 0 26
33163: PUSH
33164: LD_INT 0
33166: PUSH
33167: LD_INT 0
33169: PUSH
33170: EMPTY
33171: LIST
33172: LIST
33173: PUSH
33174: LD_INT 0
33176: PUSH
33177: LD_INT 1
33179: NEG
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 1
33187: PUSH
33188: LD_INT 0
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 1
33197: PUSH
33198: LD_INT 1
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 0
33207: PUSH
33208: LD_INT 1
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 1
33217: NEG
33218: PUSH
33219: LD_INT 0
33221: PUSH
33222: EMPTY
33223: LIST
33224: LIST
33225: PUSH
33226: LD_INT 1
33228: NEG
33229: PUSH
33230: LD_INT 1
33232: NEG
33233: PUSH
33234: EMPTY
33235: LIST
33236: LIST
33237: PUSH
33238: LD_INT 1
33240: NEG
33241: PUSH
33242: LD_INT 2
33244: NEG
33245: PUSH
33246: EMPTY
33247: LIST
33248: LIST
33249: PUSH
33250: LD_INT 0
33252: PUSH
33253: LD_INT 2
33255: NEG
33256: PUSH
33257: EMPTY
33258: LIST
33259: LIST
33260: PUSH
33261: LD_INT 1
33263: PUSH
33264: LD_INT 1
33266: NEG
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 2
33274: PUSH
33275: LD_INT 0
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 2
33284: PUSH
33285: LD_INT 1
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 2
33294: PUSH
33295: LD_INT 2
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 1
33304: PUSH
33305: LD_INT 2
33307: PUSH
33308: EMPTY
33309: LIST
33310: LIST
33311: PUSH
33312: LD_INT 0
33314: PUSH
33315: LD_INT 2
33317: PUSH
33318: EMPTY
33319: LIST
33320: LIST
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: LD_INT 1
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 2
33335: NEG
33336: PUSH
33337: LD_INT 0
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 2
33346: NEG
33347: PUSH
33348: LD_INT 1
33350: NEG
33351: PUSH
33352: EMPTY
33353: LIST
33354: LIST
33355: PUSH
33356: LD_INT 2
33358: NEG
33359: PUSH
33360: LD_INT 2
33362: NEG
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 2
33370: PUSH
33371: LD_INT 3
33373: PUSH
33374: EMPTY
33375: LIST
33376: LIST
33377: PUSH
33378: LD_INT 1
33380: PUSH
33381: LD_INT 3
33383: PUSH
33384: EMPTY
33385: LIST
33386: LIST
33387: PUSH
33388: LD_INT 1
33390: NEG
33391: PUSH
33392: LD_INT 2
33394: PUSH
33395: EMPTY
33396: LIST
33397: LIST
33398: PUSH
33399: LD_INT 2
33401: NEG
33402: PUSH
33403: LD_INT 1
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: EMPTY
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: LIST
33433: LIST
33434: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33435: LD_ADDR_VAR 0 27
33439: PUSH
33440: LD_INT 0
33442: PUSH
33443: LD_INT 0
33445: PUSH
33446: EMPTY
33447: LIST
33448: LIST
33449: PUSH
33450: LD_INT 0
33452: PUSH
33453: LD_INT 1
33455: NEG
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 1
33463: PUSH
33464: LD_INT 0
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 1
33473: PUSH
33474: LD_INT 1
33476: PUSH
33477: EMPTY
33478: LIST
33479: LIST
33480: PUSH
33481: LD_INT 0
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: EMPTY
33488: LIST
33489: LIST
33490: PUSH
33491: LD_INT 1
33493: NEG
33494: PUSH
33495: LD_INT 0
33497: PUSH
33498: EMPTY
33499: LIST
33500: LIST
33501: PUSH
33502: LD_INT 1
33504: NEG
33505: PUSH
33506: LD_INT 1
33508: NEG
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: LD_INT 2
33520: NEG
33521: PUSH
33522: EMPTY
33523: LIST
33524: LIST
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: LD_INT 2
33531: NEG
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 1
33539: PUSH
33540: LD_INT 1
33542: NEG
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 2
33550: PUSH
33551: LD_INT 0
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 2
33560: PUSH
33561: LD_INT 1
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: PUSH
33568: LD_INT 2
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 1
33580: PUSH
33581: LD_INT 2
33583: PUSH
33584: EMPTY
33585: LIST
33586: LIST
33587: PUSH
33588: LD_INT 0
33590: PUSH
33591: LD_INT 2
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 1
33600: NEG
33601: PUSH
33602: LD_INT 1
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 2
33611: NEG
33612: PUSH
33613: LD_INT 0
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 2
33622: NEG
33623: PUSH
33624: LD_INT 1
33626: NEG
33627: PUSH
33628: EMPTY
33629: LIST
33630: LIST
33631: PUSH
33632: LD_INT 2
33634: NEG
33635: PUSH
33636: LD_INT 2
33638: NEG
33639: PUSH
33640: EMPTY
33641: LIST
33642: LIST
33643: PUSH
33644: LD_INT 1
33646: NEG
33647: PUSH
33648: LD_INT 2
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 2
33657: NEG
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: EMPTY
33663: LIST
33664: LIST
33665: PUSH
33666: LD_INT 3
33668: NEG
33669: PUSH
33670: LD_INT 1
33672: NEG
33673: PUSH
33674: EMPTY
33675: LIST
33676: LIST
33677: PUSH
33678: LD_INT 3
33680: NEG
33681: PUSH
33682: LD_INT 2
33684: NEG
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: EMPTY
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: LIST
33713: LIST
33714: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33715: LD_ADDR_VAR 0 28
33719: PUSH
33720: LD_INT 0
33722: PUSH
33723: LD_INT 0
33725: PUSH
33726: EMPTY
33727: LIST
33728: LIST
33729: PUSH
33730: LD_INT 0
33732: PUSH
33733: LD_INT 1
33735: NEG
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 1
33743: PUSH
33744: LD_INT 0
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: PUSH
33754: LD_INT 1
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 0
33763: PUSH
33764: LD_INT 1
33766: PUSH
33767: EMPTY
33768: LIST
33769: LIST
33770: PUSH
33771: LD_INT 1
33773: NEG
33774: PUSH
33775: LD_INT 0
33777: PUSH
33778: EMPTY
33779: LIST
33780: LIST
33781: PUSH
33782: LD_INT 1
33784: NEG
33785: PUSH
33786: LD_INT 1
33788: NEG
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: LD_INT 2
33800: NEG
33801: PUSH
33802: EMPTY
33803: LIST
33804: LIST
33805: PUSH
33806: LD_INT 0
33808: PUSH
33809: LD_INT 2
33811: NEG
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 1
33819: PUSH
33820: LD_INT 1
33822: NEG
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: LD_INT 0
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 2
33840: PUSH
33841: LD_INT 1
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 2
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 1
33860: PUSH
33861: LD_INT 2
33863: PUSH
33864: EMPTY
33865: LIST
33866: LIST
33867: PUSH
33868: LD_INT 0
33870: PUSH
33871: LD_INT 2
33873: PUSH
33874: EMPTY
33875: LIST
33876: LIST
33877: PUSH
33878: LD_INT 1
33880: NEG
33881: PUSH
33882: LD_INT 1
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: PUSH
33889: LD_INT 2
33891: NEG
33892: PUSH
33893: LD_INT 0
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 2
33902: NEG
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: EMPTY
33909: LIST
33910: LIST
33911: PUSH
33912: LD_INT 2
33914: NEG
33915: PUSH
33916: LD_INT 2
33918: NEG
33919: PUSH
33920: EMPTY
33921: LIST
33922: LIST
33923: PUSH
33924: LD_INT 2
33926: NEG
33927: PUSH
33928: LD_INT 3
33930: NEG
33931: PUSH
33932: EMPTY
33933: LIST
33934: LIST
33935: PUSH
33936: LD_INT 1
33938: NEG
33939: PUSH
33940: LD_INT 3
33942: NEG
33943: PUSH
33944: EMPTY
33945: LIST
33946: LIST
33947: PUSH
33948: LD_INT 3
33950: NEG
33951: PUSH
33952: LD_INT 1
33954: NEG
33955: PUSH
33956: EMPTY
33957: LIST
33958: LIST
33959: PUSH
33960: LD_INT 3
33962: NEG
33963: PUSH
33964: LD_INT 2
33966: NEG
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: EMPTY
33973: LIST
33974: LIST
33975: LIST
33976: LIST
33977: LIST
33978: LIST
33979: LIST
33980: LIST
33981: LIST
33982: LIST
33983: LIST
33984: LIST
33985: LIST
33986: LIST
33987: LIST
33988: LIST
33989: LIST
33990: LIST
33991: LIST
33992: LIST
33993: LIST
33994: LIST
33995: LIST
33996: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33997: LD_ADDR_VAR 0 29
34001: PUSH
34002: LD_INT 0
34004: PUSH
34005: LD_INT 0
34007: PUSH
34008: EMPTY
34009: LIST
34010: LIST
34011: PUSH
34012: LD_INT 0
34014: PUSH
34015: LD_INT 1
34017: NEG
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 1
34025: PUSH
34026: LD_INT 0
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: PUSH
34036: LD_INT 1
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 0
34045: PUSH
34046: LD_INT 1
34048: PUSH
34049: EMPTY
34050: LIST
34051: LIST
34052: PUSH
34053: LD_INT 1
34055: NEG
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 1
34066: NEG
34067: PUSH
34068: LD_INT 1
34070: NEG
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 1
34078: NEG
34079: PUSH
34080: LD_INT 2
34082: NEG
34083: PUSH
34084: EMPTY
34085: LIST
34086: LIST
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: LD_INT 2
34093: NEG
34094: PUSH
34095: EMPTY
34096: LIST
34097: LIST
34098: PUSH
34099: LD_INT 1
34101: PUSH
34102: LD_INT 1
34104: NEG
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 2
34112: PUSH
34113: LD_INT 0
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 2
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: PUSH
34133: LD_INT 2
34135: PUSH
34136: EMPTY
34137: LIST
34138: LIST
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: LD_INT 2
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: LD_INT 1
34152: NEG
34153: PUSH
34154: LD_INT 1
34156: PUSH
34157: EMPTY
34158: LIST
34159: LIST
34160: PUSH
34161: LD_INT 2
34163: NEG
34164: PUSH
34165: LD_INT 1
34167: NEG
34168: PUSH
34169: EMPTY
34170: LIST
34171: LIST
34172: PUSH
34173: LD_INT 2
34175: NEG
34176: PUSH
34177: LD_INT 2
34179: NEG
34180: PUSH
34181: EMPTY
34182: LIST
34183: LIST
34184: PUSH
34185: LD_INT 2
34187: NEG
34188: PUSH
34189: LD_INT 3
34191: NEG
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 2
34199: PUSH
34200: LD_INT 1
34202: NEG
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 3
34210: PUSH
34211: LD_INT 1
34213: PUSH
34214: EMPTY
34215: LIST
34216: LIST
34217: PUSH
34218: LD_INT 1
34220: PUSH
34221: LD_INT 3
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 2
34234: PUSH
34235: EMPTY
34236: LIST
34237: LIST
34238: PUSH
34239: LD_INT 3
34241: NEG
34242: PUSH
34243: LD_INT 2
34245: NEG
34246: PUSH
34247: EMPTY
34248: LIST
34249: LIST
34250: PUSH
34251: EMPTY
34252: LIST
34253: LIST
34254: LIST
34255: LIST
34256: LIST
34257: LIST
34258: LIST
34259: LIST
34260: LIST
34261: LIST
34262: LIST
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: LIST
34273: LIST
34274: LIST
34275: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34276: LD_ADDR_VAR 0 30
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: LD_INT 0
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 0
34293: PUSH
34294: LD_INT 1
34296: NEG
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 1
34304: PUSH
34305: LD_INT 0
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: LD_INT 1
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 0
34324: PUSH
34325: LD_INT 1
34327: PUSH
34328: EMPTY
34329: LIST
34330: LIST
34331: PUSH
34332: LD_INT 1
34334: NEG
34335: PUSH
34336: LD_INT 0
34338: PUSH
34339: EMPTY
34340: LIST
34341: LIST
34342: PUSH
34343: LD_INT 1
34345: NEG
34346: PUSH
34347: LD_INT 1
34349: NEG
34350: PUSH
34351: EMPTY
34352: LIST
34353: LIST
34354: PUSH
34355: LD_INT 1
34357: NEG
34358: PUSH
34359: LD_INT 2
34361: NEG
34362: PUSH
34363: EMPTY
34364: LIST
34365: LIST
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: LD_INT 2
34372: NEG
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: PUSH
34378: LD_INT 1
34380: PUSH
34381: LD_INT 1
34383: NEG
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 2
34391: PUSH
34392: LD_INT 0
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 2
34401: PUSH
34402: LD_INT 1
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 2
34411: PUSH
34412: LD_INT 2
34414: PUSH
34415: EMPTY
34416: LIST
34417: LIST
34418: PUSH
34419: LD_INT 1
34421: PUSH
34422: LD_INT 2
34424: PUSH
34425: EMPTY
34426: LIST
34427: LIST
34428: PUSH
34429: LD_INT 1
34431: NEG
34432: PUSH
34433: LD_INT 1
34435: PUSH
34436: EMPTY
34437: LIST
34438: LIST
34439: PUSH
34440: LD_INT 2
34442: NEG
34443: PUSH
34444: LD_INT 0
34446: PUSH
34447: EMPTY
34448: LIST
34449: LIST
34450: PUSH
34451: LD_INT 2
34453: NEG
34454: PUSH
34455: LD_INT 1
34457: NEG
34458: PUSH
34459: EMPTY
34460: LIST
34461: LIST
34462: PUSH
34463: LD_INT 1
34465: NEG
34466: PUSH
34467: LD_INT 3
34469: NEG
34470: PUSH
34471: EMPTY
34472: LIST
34473: LIST
34474: PUSH
34475: LD_INT 1
34477: PUSH
34478: LD_INT 2
34480: NEG
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 3
34488: PUSH
34489: LD_INT 2
34491: PUSH
34492: EMPTY
34493: LIST
34494: LIST
34495: PUSH
34496: LD_INT 2
34498: PUSH
34499: LD_INT 3
34501: PUSH
34502: EMPTY
34503: LIST
34504: LIST
34505: PUSH
34506: LD_INT 2
34508: NEG
34509: PUSH
34510: LD_INT 1
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 3
34519: NEG
34520: PUSH
34521: LD_INT 1
34523: NEG
34524: PUSH
34525: EMPTY
34526: LIST
34527: LIST
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: LIST
34533: LIST
34534: LIST
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: LIST
34540: LIST
34541: LIST
34542: LIST
34543: LIST
34544: LIST
34545: LIST
34546: LIST
34547: LIST
34548: LIST
34549: LIST
34550: LIST
34551: LIST
34552: LIST
34553: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34554: LD_ADDR_VAR 0 31
34558: PUSH
34559: LD_INT 0
34561: PUSH
34562: LD_INT 0
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 0
34571: PUSH
34572: LD_INT 1
34574: NEG
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 1
34582: PUSH
34583: LD_INT 0
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: PUSH
34593: LD_INT 1
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PUSH
34600: LD_INT 0
34602: PUSH
34603: LD_INT 1
34605: PUSH
34606: EMPTY
34607: LIST
34608: LIST
34609: PUSH
34610: LD_INT 1
34612: NEG
34613: PUSH
34614: LD_INT 0
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 1
34623: NEG
34624: PUSH
34625: LD_INT 1
34627: NEG
34628: PUSH
34629: EMPTY
34630: LIST
34631: LIST
34632: PUSH
34633: LD_INT 1
34635: NEG
34636: PUSH
34637: LD_INT 2
34639: NEG
34640: PUSH
34641: EMPTY
34642: LIST
34643: LIST
34644: PUSH
34645: LD_INT 1
34647: PUSH
34648: LD_INT 1
34650: NEG
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 2
34658: PUSH
34659: LD_INT 0
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 2
34668: PUSH
34669: LD_INT 1
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 2
34678: PUSH
34679: LD_INT 2
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: LD_INT 2
34691: PUSH
34692: EMPTY
34693: LIST
34694: LIST
34695: PUSH
34696: LD_INT 0
34698: PUSH
34699: LD_INT 2
34701: PUSH
34702: EMPTY
34703: LIST
34704: LIST
34705: PUSH
34706: LD_INT 1
34708: NEG
34709: PUSH
34710: LD_INT 1
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 2
34719: NEG
34720: PUSH
34721: LD_INT 1
34723: NEG
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: LD_INT 2
34731: NEG
34732: PUSH
34733: LD_INT 2
34735: NEG
34736: PUSH
34737: EMPTY
34738: LIST
34739: LIST
34740: PUSH
34741: LD_INT 2
34743: NEG
34744: PUSH
34745: LD_INT 3
34747: NEG
34748: PUSH
34749: EMPTY
34750: LIST
34751: LIST
34752: PUSH
34753: LD_INT 2
34755: PUSH
34756: LD_INT 1
34758: NEG
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 3
34766: PUSH
34767: LD_INT 1
34769: PUSH
34770: EMPTY
34771: LIST
34772: LIST
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: LD_INT 3
34779: PUSH
34780: EMPTY
34781: LIST
34782: LIST
34783: PUSH
34784: LD_INT 1
34786: NEG
34787: PUSH
34788: LD_INT 2
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 3
34797: NEG
34798: PUSH
34799: LD_INT 2
34801: NEG
34802: PUSH
34803: EMPTY
34804: LIST
34805: LIST
34806: PUSH
34807: EMPTY
34808: LIST
34809: LIST
34810: LIST
34811: LIST
34812: LIST
34813: LIST
34814: LIST
34815: LIST
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: LIST
34822: LIST
34823: LIST
34824: LIST
34825: LIST
34826: LIST
34827: LIST
34828: LIST
34829: LIST
34830: LIST
34831: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34832: LD_ADDR_VAR 0 32
34836: PUSH
34837: LD_INT 0
34839: PUSH
34840: LD_INT 0
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 0
34849: PUSH
34850: LD_INT 1
34852: NEG
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 1
34860: PUSH
34861: LD_INT 0
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 1
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: LD_INT 1
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: LD_INT 0
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 1
34901: NEG
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 1
34913: NEG
34914: PUSH
34915: LD_INT 2
34917: NEG
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 0
34925: PUSH
34926: LD_INT 2
34928: NEG
34929: PUSH
34930: EMPTY
34931: LIST
34932: LIST
34933: PUSH
34934: LD_INT 1
34936: PUSH
34937: LD_INT 1
34939: NEG
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 2
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 2
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: PUSH
34968: LD_INT 2
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: LD_INT 2
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: LD_INT 1
34987: NEG
34988: PUSH
34989: LD_INT 1
34991: PUSH
34992: EMPTY
34993: LIST
34994: LIST
34995: PUSH
34996: LD_INT 2
34998: NEG
34999: PUSH
35000: LD_INT 0
35002: PUSH
35003: EMPTY
35004: LIST
35005: LIST
35006: PUSH
35007: LD_INT 2
35009: NEG
35010: PUSH
35011: LD_INT 1
35013: NEG
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: LD_INT 3
35025: NEG
35026: PUSH
35027: EMPTY
35028: LIST
35029: LIST
35030: PUSH
35031: LD_INT 1
35033: PUSH
35034: LD_INT 2
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 3
35044: PUSH
35045: LD_INT 2
35047: PUSH
35048: EMPTY
35049: LIST
35050: LIST
35051: PUSH
35052: LD_INT 2
35054: PUSH
35055: LD_INT 3
35057: PUSH
35058: EMPTY
35059: LIST
35060: LIST
35061: PUSH
35062: LD_INT 2
35064: NEG
35065: PUSH
35066: LD_INT 1
35068: PUSH
35069: EMPTY
35070: LIST
35071: LIST
35072: PUSH
35073: LD_INT 3
35075: NEG
35076: PUSH
35077: LD_INT 1
35079: NEG
35080: PUSH
35081: EMPTY
35082: LIST
35083: LIST
35084: PUSH
35085: EMPTY
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35110: LD_ADDR_VAR 0 33
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 1
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: NEG
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 2
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 1
35203: PUSH
35204: LD_INT 1
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 2
35214: PUSH
35215: LD_INT 0
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 2
35224: PUSH
35225: LD_INT 1
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: LD_INT 1
35234: PUSH
35235: LD_INT 2
35237: PUSH
35238: EMPTY
35239: LIST
35240: LIST
35241: PUSH
35242: LD_INT 0
35244: PUSH
35245: LD_INT 2
35247: PUSH
35248: EMPTY
35249: LIST
35250: LIST
35251: PUSH
35252: LD_INT 1
35254: NEG
35255: PUSH
35256: LD_INT 1
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 2
35265: NEG
35266: PUSH
35267: LD_INT 0
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 2
35276: NEG
35277: PUSH
35278: LD_INT 1
35280: NEG
35281: PUSH
35282: EMPTY
35283: LIST
35284: LIST
35285: PUSH
35286: LD_INT 2
35288: NEG
35289: PUSH
35290: LD_INT 2
35292: NEG
35293: PUSH
35294: EMPTY
35295: LIST
35296: LIST
35297: PUSH
35298: LD_INT 2
35300: NEG
35301: PUSH
35302: LD_INT 3
35304: NEG
35305: PUSH
35306: EMPTY
35307: LIST
35308: LIST
35309: PUSH
35310: LD_INT 2
35312: PUSH
35313: LD_INT 1
35315: NEG
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 3
35323: PUSH
35324: LD_INT 1
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 1
35333: PUSH
35334: LD_INT 3
35336: PUSH
35337: EMPTY
35338: LIST
35339: LIST
35340: PUSH
35341: LD_INT 1
35343: NEG
35344: PUSH
35345: LD_INT 2
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 3
35354: NEG
35355: PUSH
35356: LD_INT 2
35358: NEG
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: LIST
35368: LIST
35369: LIST
35370: LIST
35371: LIST
35372: LIST
35373: LIST
35374: LIST
35375: LIST
35376: LIST
35377: LIST
35378: LIST
35379: LIST
35380: LIST
35381: LIST
35382: LIST
35383: LIST
35384: LIST
35385: LIST
35386: LIST
35387: LIST
35388: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35389: LD_ADDR_VAR 0 34
35393: PUSH
35394: LD_INT 0
35396: PUSH
35397: LD_INT 0
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 0
35406: PUSH
35407: LD_INT 1
35409: NEG
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 1
35417: PUSH
35418: LD_INT 0
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: PUSH
35428: LD_INT 1
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 0
35437: PUSH
35438: LD_INT 1
35440: PUSH
35441: EMPTY
35442: LIST
35443: LIST
35444: PUSH
35445: LD_INT 1
35447: NEG
35448: PUSH
35449: LD_INT 0
35451: PUSH
35452: EMPTY
35453: LIST
35454: LIST
35455: PUSH
35456: LD_INT 1
35458: NEG
35459: PUSH
35460: LD_INT 1
35462: NEG
35463: PUSH
35464: EMPTY
35465: LIST
35466: LIST
35467: PUSH
35468: LD_INT 1
35470: NEG
35471: PUSH
35472: LD_INT 2
35474: NEG
35475: PUSH
35476: EMPTY
35477: LIST
35478: LIST
35479: PUSH
35480: LD_INT 0
35482: PUSH
35483: LD_INT 2
35485: NEG
35486: PUSH
35487: EMPTY
35488: LIST
35489: LIST
35490: PUSH
35491: LD_INT 1
35493: PUSH
35494: LD_INT 1
35496: NEG
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 2
35504: PUSH
35505: LD_INT 1
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 2
35514: PUSH
35515: LD_INT 2
35517: PUSH
35518: EMPTY
35519: LIST
35520: LIST
35521: PUSH
35522: LD_INT 1
35524: PUSH
35525: LD_INT 2
35527: PUSH
35528: EMPTY
35529: LIST
35530: LIST
35531: PUSH
35532: LD_INT 1
35534: NEG
35535: PUSH
35536: LD_INT 1
35538: PUSH
35539: EMPTY
35540: LIST
35541: LIST
35542: PUSH
35543: LD_INT 2
35545: NEG
35546: PUSH
35547: LD_INT 0
35549: PUSH
35550: EMPTY
35551: LIST
35552: LIST
35553: PUSH
35554: LD_INT 2
35556: NEG
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: EMPTY
35563: LIST
35564: LIST
35565: PUSH
35566: LD_INT 2
35568: NEG
35569: PUSH
35570: LD_INT 2
35572: NEG
35573: PUSH
35574: EMPTY
35575: LIST
35576: LIST
35577: PUSH
35578: LD_INT 1
35580: NEG
35581: PUSH
35582: LD_INT 3
35584: NEG
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: LD_INT 2
35595: NEG
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 3
35603: PUSH
35604: LD_INT 2
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: PUSH
35614: LD_INT 3
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 1
35627: PUSH
35628: EMPTY
35629: LIST
35630: LIST
35631: PUSH
35632: LD_INT 3
35634: NEG
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: EMPTY
35645: LIST
35646: LIST
35647: LIST
35648: LIST
35649: LIST
35650: LIST
35651: LIST
35652: LIST
35653: LIST
35654: LIST
35655: LIST
35656: LIST
35657: LIST
35658: LIST
35659: LIST
35660: LIST
35661: LIST
35662: LIST
35663: LIST
35664: LIST
35665: LIST
35666: LIST
35667: LIST
35668: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35669: LD_ADDR_VAR 0 35
35673: PUSH
35674: LD_INT 0
35676: PUSH
35677: LD_INT 0
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 0
35686: PUSH
35687: LD_INT 1
35689: NEG
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 1
35697: PUSH
35698: LD_INT 0
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 0
35717: PUSH
35718: LD_INT 1
35720: PUSH
35721: EMPTY
35722: LIST
35723: LIST
35724: PUSH
35725: LD_INT 1
35727: NEG
35728: PUSH
35729: LD_INT 0
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 1
35738: NEG
35739: PUSH
35740: LD_INT 1
35742: NEG
35743: PUSH
35744: EMPTY
35745: LIST
35746: LIST
35747: PUSH
35748: LD_INT 2
35750: PUSH
35751: LD_INT 1
35753: PUSH
35754: EMPTY
35755: LIST
35756: LIST
35757: PUSH
35758: LD_INT 2
35760: NEG
35761: PUSH
35762: LD_INT 1
35764: NEG
35765: PUSH
35766: EMPTY
35767: LIST
35768: LIST
35769: PUSH
35770: EMPTY
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35781: LD_ADDR_VAR 0 36
35785: PUSH
35786: LD_INT 0
35788: PUSH
35789: LD_INT 0
35791: PUSH
35792: EMPTY
35793: LIST
35794: LIST
35795: PUSH
35796: LD_INT 0
35798: PUSH
35799: LD_INT 1
35801: NEG
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 1
35809: PUSH
35810: LD_INT 0
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: PUSH
35820: LD_INT 1
35822: PUSH
35823: EMPTY
35824: LIST
35825: LIST
35826: PUSH
35827: LD_INT 0
35829: PUSH
35830: LD_INT 1
35832: PUSH
35833: EMPTY
35834: LIST
35835: LIST
35836: PUSH
35837: LD_INT 1
35839: NEG
35840: PUSH
35841: LD_INT 0
35843: PUSH
35844: EMPTY
35845: LIST
35846: LIST
35847: PUSH
35848: LD_INT 1
35850: NEG
35851: PUSH
35852: LD_INT 1
35854: NEG
35855: PUSH
35856: EMPTY
35857: LIST
35858: LIST
35859: PUSH
35860: LD_INT 1
35862: NEG
35863: PUSH
35864: LD_INT 2
35866: NEG
35867: PUSH
35868: EMPTY
35869: LIST
35870: LIST
35871: PUSH
35872: LD_INT 1
35874: PUSH
35875: LD_INT 2
35877: PUSH
35878: EMPTY
35879: LIST
35880: LIST
35881: PUSH
35882: EMPTY
35883: LIST
35884: LIST
35885: LIST
35886: LIST
35887: LIST
35888: LIST
35889: LIST
35890: LIST
35891: LIST
35892: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35893: LD_ADDR_VAR 0 37
35897: PUSH
35898: LD_INT 0
35900: PUSH
35901: LD_INT 0
35903: PUSH
35904: EMPTY
35905: LIST
35906: LIST
35907: PUSH
35908: LD_INT 0
35910: PUSH
35911: LD_INT 1
35913: NEG
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 1
35921: PUSH
35922: LD_INT 0
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 1
35931: PUSH
35932: LD_INT 1
35934: PUSH
35935: EMPTY
35936: LIST
35937: LIST
35938: PUSH
35939: LD_INT 0
35941: PUSH
35942: LD_INT 1
35944: PUSH
35945: EMPTY
35946: LIST
35947: LIST
35948: PUSH
35949: LD_INT 1
35951: NEG
35952: PUSH
35953: LD_INT 0
35955: PUSH
35956: EMPTY
35957: LIST
35958: LIST
35959: PUSH
35960: LD_INT 1
35962: NEG
35963: PUSH
35964: LD_INT 1
35966: NEG
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 1
35974: PUSH
35975: LD_INT 1
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 1
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: LIST
36000: LIST
36001: LIST
36002: LIST
36003: LIST
36004: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36005: LD_ADDR_VAR 0 38
36009: PUSH
36010: LD_INT 0
36012: PUSH
36013: LD_INT 0
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 0
36022: PUSH
36023: LD_INT 1
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: PUSH
36034: LD_INT 0
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 1
36043: PUSH
36044: LD_INT 1
36046: PUSH
36047: EMPTY
36048: LIST
36049: LIST
36050: PUSH
36051: LD_INT 0
36053: PUSH
36054: LD_INT 1
36056: PUSH
36057: EMPTY
36058: LIST
36059: LIST
36060: PUSH
36061: LD_INT 1
36063: NEG
36064: PUSH
36065: LD_INT 0
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: NEG
36075: PUSH
36076: LD_INT 1
36078: NEG
36079: PUSH
36080: EMPTY
36081: LIST
36082: LIST
36083: PUSH
36084: LD_INT 2
36086: PUSH
36087: LD_INT 1
36089: PUSH
36090: EMPTY
36091: LIST
36092: LIST
36093: PUSH
36094: LD_INT 2
36096: NEG
36097: PUSH
36098: LD_INT 1
36100: NEG
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: PUSH
36106: EMPTY
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36117: LD_ADDR_VAR 0 39
36121: PUSH
36122: LD_INT 0
36124: PUSH
36125: LD_INT 0
36127: PUSH
36128: EMPTY
36129: LIST
36130: LIST
36131: PUSH
36132: LD_INT 0
36134: PUSH
36135: LD_INT 1
36137: NEG
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 1
36145: PUSH
36146: LD_INT 0
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 1
36155: PUSH
36156: LD_INT 1
36158: PUSH
36159: EMPTY
36160: LIST
36161: LIST
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: LD_INT 1
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 1
36175: NEG
36176: PUSH
36177: LD_INT 0
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: LD_INT 1
36186: NEG
36187: PUSH
36188: LD_INT 1
36190: NEG
36191: PUSH
36192: EMPTY
36193: LIST
36194: LIST
36195: PUSH
36196: LD_INT 1
36198: NEG
36199: PUSH
36200: LD_INT 2
36202: NEG
36203: PUSH
36204: EMPTY
36205: LIST
36206: LIST
36207: PUSH
36208: LD_INT 1
36210: PUSH
36211: LD_INT 2
36213: PUSH
36214: EMPTY
36215: LIST
36216: LIST
36217: PUSH
36218: EMPTY
36219: LIST
36220: LIST
36221: LIST
36222: LIST
36223: LIST
36224: LIST
36225: LIST
36226: LIST
36227: LIST
36228: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36229: LD_ADDR_VAR 0 40
36233: PUSH
36234: LD_INT 0
36236: PUSH
36237: LD_INT 0
36239: PUSH
36240: EMPTY
36241: LIST
36242: LIST
36243: PUSH
36244: LD_INT 0
36246: PUSH
36247: LD_INT 1
36249: NEG
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 1
36257: PUSH
36258: LD_INT 0
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: PUSH
36265: LD_INT 1
36267: PUSH
36268: LD_INT 1
36270: PUSH
36271: EMPTY
36272: LIST
36273: LIST
36274: PUSH
36275: LD_INT 0
36277: PUSH
36278: LD_INT 1
36280: PUSH
36281: EMPTY
36282: LIST
36283: LIST
36284: PUSH
36285: LD_INT 1
36287: NEG
36288: PUSH
36289: LD_INT 0
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PUSH
36296: LD_INT 1
36298: NEG
36299: PUSH
36300: LD_INT 1
36302: NEG
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 1
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: EMPTY
36316: LIST
36317: LIST
36318: PUSH
36319: LD_INT 1
36321: NEG
36322: PUSH
36323: LD_INT 1
36325: PUSH
36326: EMPTY
36327: LIST
36328: LIST
36329: PUSH
36330: EMPTY
36331: LIST
36332: LIST
36333: LIST
36334: LIST
36335: LIST
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36341: LD_ADDR_VAR 0 41
36345: PUSH
36346: LD_INT 0
36348: PUSH
36349: LD_INT 0
36351: PUSH
36352: EMPTY
36353: LIST
36354: LIST
36355: PUSH
36356: LD_INT 0
36358: PUSH
36359: LD_INT 1
36361: NEG
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 1
36369: PUSH
36370: LD_INT 0
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: PUSH
36380: LD_INT 1
36382: PUSH
36383: EMPTY
36384: LIST
36385: LIST
36386: PUSH
36387: LD_INT 0
36389: PUSH
36390: LD_INT 1
36392: PUSH
36393: EMPTY
36394: LIST
36395: LIST
36396: PUSH
36397: LD_INT 1
36399: NEG
36400: PUSH
36401: LD_INT 0
36403: PUSH
36404: EMPTY
36405: LIST
36406: LIST
36407: PUSH
36408: LD_INT 1
36410: NEG
36411: PUSH
36412: LD_INT 1
36414: NEG
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 1
36422: NEG
36423: PUSH
36424: LD_INT 2
36426: NEG
36427: PUSH
36428: EMPTY
36429: LIST
36430: LIST
36431: PUSH
36432: LD_INT 1
36434: PUSH
36435: LD_INT 1
36437: NEG
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 2
36445: PUSH
36446: LD_INT 0
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 2
36455: PUSH
36456: LD_INT 1
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 2
36465: PUSH
36466: LD_INT 2
36468: PUSH
36469: EMPTY
36470: LIST
36471: LIST
36472: PUSH
36473: LD_INT 1
36475: PUSH
36476: LD_INT 2
36478: PUSH
36479: EMPTY
36480: LIST
36481: LIST
36482: PUSH
36483: LD_INT 1
36485: NEG
36486: PUSH
36487: LD_INT 1
36489: PUSH
36490: EMPTY
36491: LIST
36492: LIST
36493: PUSH
36494: LD_INT 2
36496: NEG
36497: PUSH
36498: LD_INT 0
36500: PUSH
36501: EMPTY
36502: LIST
36503: LIST
36504: PUSH
36505: LD_INT 2
36507: NEG
36508: PUSH
36509: LD_INT 1
36511: NEG
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 2
36519: NEG
36520: PUSH
36521: LD_INT 2
36523: NEG
36524: PUSH
36525: EMPTY
36526: LIST
36527: LIST
36528: PUSH
36529: LD_INT 2
36531: NEG
36532: PUSH
36533: LD_INT 3
36535: NEG
36536: PUSH
36537: EMPTY
36538: LIST
36539: LIST
36540: PUSH
36541: LD_INT 2
36543: PUSH
36544: LD_INT 1
36546: NEG
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 3
36554: PUSH
36555: LD_INT 0
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 3
36564: PUSH
36565: LD_INT 1
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 3
36574: PUSH
36575: LD_INT 2
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 3
36584: PUSH
36585: LD_INT 3
36587: PUSH
36588: EMPTY
36589: LIST
36590: LIST
36591: PUSH
36592: LD_INT 2
36594: PUSH
36595: LD_INT 3
36597: PUSH
36598: EMPTY
36599: LIST
36600: LIST
36601: PUSH
36602: LD_INT 2
36604: NEG
36605: PUSH
36606: LD_INT 1
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PUSH
36613: LD_INT 3
36615: NEG
36616: PUSH
36617: LD_INT 0
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 3
36626: NEG
36627: PUSH
36628: LD_INT 1
36630: NEG
36631: PUSH
36632: EMPTY
36633: LIST
36634: LIST
36635: PUSH
36636: LD_INT 3
36638: NEG
36639: PUSH
36640: LD_INT 2
36642: NEG
36643: PUSH
36644: EMPTY
36645: LIST
36646: LIST
36647: PUSH
36648: LD_INT 3
36650: NEG
36651: PUSH
36652: LD_INT 3
36654: NEG
36655: PUSH
36656: EMPTY
36657: LIST
36658: LIST
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: LIST
36671: LIST
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: LIST
36677: LIST
36678: LIST
36679: LIST
36680: LIST
36681: LIST
36682: LIST
36683: LIST
36684: LIST
36685: LIST
36686: LIST
36687: LIST
36688: LIST
36689: LIST
36690: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36691: LD_ADDR_VAR 0 42
36695: PUSH
36696: LD_INT 0
36698: PUSH
36699: LD_INT 0
36701: PUSH
36702: EMPTY
36703: LIST
36704: LIST
36705: PUSH
36706: LD_INT 0
36708: PUSH
36709: LD_INT 1
36711: NEG
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 1
36719: PUSH
36720: LD_INT 0
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: PUSH
36730: LD_INT 1
36732: PUSH
36733: EMPTY
36734: LIST
36735: LIST
36736: PUSH
36737: LD_INT 0
36739: PUSH
36740: LD_INT 1
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: LD_INT 1
36749: NEG
36750: PUSH
36751: LD_INT 0
36753: PUSH
36754: EMPTY
36755: LIST
36756: LIST
36757: PUSH
36758: LD_INT 1
36760: NEG
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 1
36772: NEG
36773: PUSH
36774: LD_INT 2
36776: NEG
36777: PUSH
36778: EMPTY
36779: LIST
36780: LIST
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: LD_INT 2
36787: NEG
36788: PUSH
36789: EMPTY
36790: LIST
36791: LIST
36792: PUSH
36793: LD_INT 1
36795: PUSH
36796: LD_INT 1
36798: NEG
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 2
36806: PUSH
36807: LD_INT 1
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 2
36816: PUSH
36817: LD_INT 2
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 1
36826: PUSH
36827: LD_INT 2
36829: PUSH
36830: EMPTY
36831: LIST
36832: LIST
36833: PUSH
36834: LD_INT 0
36836: PUSH
36837: LD_INT 2
36839: PUSH
36840: EMPTY
36841: LIST
36842: LIST
36843: PUSH
36844: LD_INT 1
36846: NEG
36847: PUSH
36848: LD_INT 1
36850: PUSH
36851: EMPTY
36852: LIST
36853: LIST
36854: PUSH
36855: LD_INT 2
36857: NEG
36858: PUSH
36859: LD_INT 1
36861: NEG
36862: PUSH
36863: EMPTY
36864: LIST
36865: LIST
36866: PUSH
36867: LD_INT 2
36869: NEG
36870: PUSH
36871: LD_INT 2
36873: NEG
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 2
36881: NEG
36882: PUSH
36883: LD_INT 3
36885: NEG
36886: PUSH
36887: EMPTY
36888: LIST
36889: LIST
36890: PUSH
36891: LD_INT 1
36893: NEG
36894: PUSH
36895: LD_INT 3
36897: NEG
36898: PUSH
36899: EMPTY
36900: LIST
36901: LIST
36902: PUSH
36903: LD_INT 0
36905: PUSH
36906: LD_INT 3
36908: NEG
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 1
36916: PUSH
36917: LD_INT 2
36919: NEG
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 3
36927: PUSH
36928: LD_INT 2
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 3
36937: PUSH
36938: LD_INT 3
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 2
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 1
36957: PUSH
36958: LD_INT 3
36960: PUSH
36961: EMPTY
36962: LIST
36963: LIST
36964: PUSH
36965: LD_INT 0
36967: PUSH
36968: LD_INT 3
36970: PUSH
36971: EMPTY
36972: LIST
36973: LIST
36974: PUSH
36975: LD_INT 1
36977: NEG
36978: PUSH
36979: LD_INT 2
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 3
36988: NEG
36989: PUSH
36990: LD_INT 2
36992: NEG
36993: PUSH
36994: EMPTY
36995: LIST
36996: LIST
36997: PUSH
36998: LD_INT 3
37000: NEG
37001: PUSH
37002: LD_INT 3
37004: NEG
37005: PUSH
37006: EMPTY
37007: LIST
37008: LIST
37009: PUSH
37010: EMPTY
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: LIST
37021: LIST
37022: LIST
37023: LIST
37024: LIST
37025: LIST
37026: LIST
37027: LIST
37028: LIST
37029: LIST
37030: LIST
37031: LIST
37032: LIST
37033: LIST
37034: LIST
37035: LIST
37036: LIST
37037: LIST
37038: LIST
37039: LIST
37040: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37041: LD_ADDR_VAR 0 43
37045: PUSH
37046: LD_INT 0
37048: PUSH
37049: LD_INT 0
37051: PUSH
37052: EMPTY
37053: LIST
37054: LIST
37055: PUSH
37056: LD_INT 0
37058: PUSH
37059: LD_INT 1
37061: NEG
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 1
37069: PUSH
37070: LD_INT 0
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 1
37079: PUSH
37080: LD_INT 1
37082: PUSH
37083: EMPTY
37084: LIST
37085: LIST
37086: PUSH
37087: LD_INT 0
37089: PUSH
37090: LD_INT 1
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: PUSH
37097: LD_INT 1
37099: NEG
37100: PUSH
37101: LD_INT 0
37103: PUSH
37104: EMPTY
37105: LIST
37106: LIST
37107: PUSH
37108: LD_INT 1
37110: NEG
37111: PUSH
37112: LD_INT 1
37114: NEG
37115: PUSH
37116: EMPTY
37117: LIST
37118: LIST
37119: PUSH
37120: LD_INT 1
37122: NEG
37123: PUSH
37124: LD_INT 2
37126: NEG
37127: PUSH
37128: EMPTY
37129: LIST
37130: LIST
37131: PUSH
37132: LD_INT 0
37134: PUSH
37135: LD_INT 2
37137: NEG
37138: PUSH
37139: EMPTY
37140: LIST
37141: LIST
37142: PUSH
37143: LD_INT 1
37145: PUSH
37146: LD_INT 1
37148: NEG
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PUSH
37154: LD_INT 2
37156: PUSH
37157: LD_INT 0
37159: PUSH
37160: EMPTY
37161: LIST
37162: LIST
37163: PUSH
37164: LD_INT 2
37166: PUSH
37167: LD_INT 1
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: PUSH
37177: LD_INT 2
37179: PUSH
37180: EMPTY
37181: LIST
37182: LIST
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: LD_INT 2
37189: PUSH
37190: EMPTY
37191: LIST
37192: LIST
37193: PUSH
37194: LD_INT 1
37196: NEG
37197: PUSH
37198: LD_INT 1
37200: PUSH
37201: EMPTY
37202: LIST
37203: LIST
37204: PUSH
37205: LD_INT 2
37207: NEG
37208: PUSH
37209: LD_INT 0
37211: PUSH
37212: EMPTY
37213: LIST
37214: LIST
37215: PUSH
37216: LD_INT 2
37218: NEG
37219: PUSH
37220: LD_INT 1
37222: NEG
37223: PUSH
37224: EMPTY
37225: LIST
37226: LIST
37227: PUSH
37228: LD_INT 1
37230: NEG
37231: PUSH
37232: LD_INT 3
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 0
37242: PUSH
37243: LD_INT 3
37245: NEG
37246: PUSH
37247: EMPTY
37248: LIST
37249: LIST
37250: PUSH
37251: LD_INT 1
37253: PUSH
37254: LD_INT 2
37256: NEG
37257: PUSH
37258: EMPTY
37259: LIST
37260: LIST
37261: PUSH
37262: LD_INT 2
37264: PUSH
37265: LD_INT 1
37267: NEG
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 3
37275: PUSH
37276: LD_INT 0
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 3
37285: PUSH
37286: LD_INT 1
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: PUSH
37296: LD_INT 3
37298: PUSH
37299: EMPTY
37300: LIST
37301: LIST
37302: PUSH
37303: LD_INT 0
37305: PUSH
37306: LD_INT 3
37308: PUSH
37309: EMPTY
37310: LIST
37311: LIST
37312: PUSH
37313: LD_INT 1
37315: NEG
37316: PUSH
37317: LD_INT 2
37319: PUSH
37320: EMPTY
37321: LIST
37322: LIST
37323: PUSH
37324: LD_INT 2
37326: NEG
37327: PUSH
37328: LD_INT 1
37330: PUSH
37331: EMPTY
37332: LIST
37333: LIST
37334: PUSH
37335: LD_INT 3
37337: NEG
37338: PUSH
37339: LD_INT 0
37341: PUSH
37342: EMPTY
37343: LIST
37344: LIST
37345: PUSH
37346: LD_INT 3
37348: NEG
37349: PUSH
37350: LD_INT 1
37352: NEG
37353: PUSH
37354: EMPTY
37355: LIST
37356: LIST
37357: PUSH
37358: EMPTY
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: LIST
37369: LIST
37370: LIST
37371: LIST
37372: LIST
37373: LIST
37374: LIST
37375: LIST
37376: LIST
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37389: LD_ADDR_VAR 0 44
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: LD_INT 0
37399: PUSH
37400: EMPTY
37401: LIST
37402: LIST
37403: PUSH
37404: LD_INT 0
37406: PUSH
37407: LD_INT 1
37409: NEG
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 1
37417: PUSH
37418: LD_INT 0
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 1
37427: PUSH
37428: LD_INT 1
37430: PUSH
37431: EMPTY
37432: LIST
37433: LIST
37434: PUSH
37435: LD_INT 0
37437: PUSH
37438: LD_INT 1
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: PUSH
37445: LD_INT 1
37447: NEG
37448: PUSH
37449: LD_INT 0
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 1
37458: NEG
37459: PUSH
37460: LD_INT 1
37462: NEG
37463: PUSH
37464: EMPTY
37465: LIST
37466: LIST
37467: PUSH
37468: LD_INT 1
37470: NEG
37471: PUSH
37472: LD_INT 2
37474: NEG
37475: PUSH
37476: EMPTY
37477: LIST
37478: LIST
37479: PUSH
37480: LD_INT 1
37482: PUSH
37483: LD_INT 1
37485: NEG
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 2
37493: PUSH
37494: LD_INT 0
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: LD_INT 1
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: LD_INT 2
37516: PUSH
37517: EMPTY
37518: LIST
37519: LIST
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: LD_INT 2
37526: PUSH
37527: EMPTY
37528: LIST
37529: LIST
37530: PUSH
37531: LD_INT 1
37533: NEG
37534: PUSH
37535: LD_INT 1
37537: PUSH
37538: EMPTY
37539: LIST
37540: LIST
37541: PUSH
37542: LD_INT 2
37544: NEG
37545: PUSH
37546: LD_INT 0
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: LD_INT 2
37555: NEG
37556: PUSH
37557: LD_INT 1
37559: NEG
37560: PUSH
37561: EMPTY
37562: LIST
37563: LIST
37564: PUSH
37565: LD_INT 2
37567: NEG
37568: PUSH
37569: LD_INT 2
37571: NEG
37572: PUSH
37573: EMPTY
37574: LIST
37575: LIST
37576: PUSH
37577: LD_INT 2
37579: NEG
37580: PUSH
37581: LD_INT 3
37583: NEG
37584: PUSH
37585: EMPTY
37586: LIST
37587: LIST
37588: PUSH
37589: LD_INT 2
37591: PUSH
37592: LD_INT 1
37594: NEG
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 3
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 3
37612: PUSH
37613: LD_INT 1
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 3
37622: PUSH
37623: LD_INT 2
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 3
37632: PUSH
37633: LD_INT 3
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PUSH
37640: LD_INT 2
37642: PUSH
37643: LD_INT 3
37645: PUSH
37646: EMPTY
37647: LIST
37648: LIST
37649: PUSH
37650: LD_INT 2
37652: NEG
37653: PUSH
37654: LD_INT 1
37656: PUSH
37657: EMPTY
37658: LIST
37659: LIST
37660: PUSH
37661: LD_INT 3
37663: NEG
37664: PUSH
37665: LD_INT 0
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 3
37674: NEG
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: EMPTY
37681: LIST
37682: LIST
37683: PUSH
37684: LD_INT 3
37686: NEG
37687: PUSH
37688: LD_INT 2
37690: NEG
37691: PUSH
37692: EMPTY
37693: LIST
37694: LIST
37695: PUSH
37696: LD_INT 3
37698: NEG
37699: PUSH
37700: LD_INT 3
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: EMPTY
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: LIST
37719: LIST
37720: LIST
37721: LIST
37722: LIST
37723: LIST
37724: LIST
37725: LIST
37726: LIST
37727: LIST
37728: LIST
37729: LIST
37730: LIST
37731: LIST
37732: LIST
37733: LIST
37734: LIST
37735: LIST
37736: LIST
37737: LIST
37738: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37739: LD_ADDR_VAR 0 45
37743: PUSH
37744: LD_INT 0
37746: PUSH
37747: LD_INT 0
37749: PUSH
37750: EMPTY
37751: LIST
37752: LIST
37753: PUSH
37754: LD_INT 0
37756: PUSH
37757: LD_INT 1
37759: NEG
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 1
37767: PUSH
37768: LD_INT 0
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: PUSH
37778: LD_INT 1
37780: PUSH
37781: EMPTY
37782: LIST
37783: LIST
37784: PUSH
37785: LD_INT 0
37787: PUSH
37788: LD_INT 1
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: PUSH
37795: LD_INT 1
37797: NEG
37798: PUSH
37799: LD_INT 0
37801: PUSH
37802: EMPTY
37803: LIST
37804: LIST
37805: PUSH
37806: LD_INT 1
37808: NEG
37809: PUSH
37810: LD_INT 1
37812: NEG
37813: PUSH
37814: EMPTY
37815: LIST
37816: LIST
37817: PUSH
37818: LD_INT 1
37820: NEG
37821: PUSH
37822: LD_INT 2
37824: NEG
37825: PUSH
37826: EMPTY
37827: LIST
37828: LIST
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 2
37835: NEG
37836: PUSH
37837: EMPTY
37838: LIST
37839: LIST
37840: PUSH
37841: LD_INT 1
37843: PUSH
37844: LD_INT 1
37846: NEG
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PUSH
37852: LD_INT 2
37854: PUSH
37855: LD_INT 1
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 2
37864: PUSH
37865: LD_INT 2
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: PUSH
37875: LD_INT 2
37877: PUSH
37878: EMPTY
37879: LIST
37880: LIST
37881: PUSH
37882: LD_INT 0
37884: PUSH
37885: LD_INT 2
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: PUSH
37899: EMPTY
37900: LIST
37901: LIST
37902: PUSH
37903: LD_INT 2
37905: NEG
37906: PUSH
37907: LD_INT 1
37909: NEG
37910: PUSH
37911: EMPTY
37912: LIST
37913: LIST
37914: PUSH
37915: LD_INT 2
37917: NEG
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 2
37929: NEG
37930: PUSH
37931: LD_INT 3
37933: NEG
37934: PUSH
37935: EMPTY
37936: LIST
37937: LIST
37938: PUSH
37939: LD_INT 1
37941: NEG
37942: PUSH
37943: LD_INT 3
37945: NEG
37946: PUSH
37947: EMPTY
37948: LIST
37949: LIST
37950: PUSH
37951: LD_INT 0
37953: PUSH
37954: LD_INT 3
37956: NEG
37957: PUSH
37958: EMPTY
37959: LIST
37960: LIST
37961: PUSH
37962: LD_INT 1
37964: PUSH
37965: LD_INT 2
37967: NEG
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 3
37975: PUSH
37976: LD_INT 2
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 3
37985: PUSH
37986: LD_INT 3
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 2
37995: PUSH
37996: LD_INT 3
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 1
38005: PUSH
38006: LD_INT 3
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: LD_INT 0
38015: PUSH
38016: LD_INT 3
38018: PUSH
38019: EMPTY
38020: LIST
38021: LIST
38022: PUSH
38023: LD_INT 1
38025: NEG
38026: PUSH
38027: LD_INT 2
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 3
38036: NEG
38037: PUSH
38038: LD_INT 2
38040: NEG
38041: PUSH
38042: EMPTY
38043: LIST
38044: LIST
38045: PUSH
38046: LD_INT 3
38048: NEG
38049: PUSH
38050: LD_INT 3
38052: NEG
38053: PUSH
38054: EMPTY
38055: LIST
38056: LIST
38057: PUSH
38058: EMPTY
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: LIST
38080: LIST
38081: LIST
38082: LIST
38083: LIST
38084: LIST
38085: LIST
38086: LIST
38087: LIST
38088: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38089: LD_ADDR_VAR 0 46
38093: PUSH
38094: LD_INT 0
38096: PUSH
38097: LD_INT 0
38099: PUSH
38100: EMPTY
38101: LIST
38102: LIST
38103: PUSH
38104: LD_INT 0
38106: PUSH
38107: LD_INT 1
38109: NEG
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 1
38117: PUSH
38118: LD_INT 0
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: PUSH
38128: LD_INT 1
38130: PUSH
38131: EMPTY
38132: LIST
38133: LIST
38134: PUSH
38135: LD_INT 0
38137: PUSH
38138: LD_INT 1
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: PUSH
38145: LD_INT 1
38147: NEG
38148: PUSH
38149: LD_INT 0
38151: PUSH
38152: EMPTY
38153: LIST
38154: LIST
38155: PUSH
38156: LD_INT 1
38158: NEG
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 1
38170: NEG
38171: PUSH
38172: LD_INT 2
38174: NEG
38175: PUSH
38176: EMPTY
38177: LIST
38178: LIST
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: LD_INT 2
38185: NEG
38186: PUSH
38187: EMPTY
38188: LIST
38189: LIST
38190: PUSH
38191: LD_INT 1
38193: PUSH
38194: LD_INT 1
38196: NEG
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 2
38204: PUSH
38205: LD_INT 0
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 2
38214: PUSH
38215: LD_INT 1
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: LD_INT 2
38227: PUSH
38228: EMPTY
38229: LIST
38230: LIST
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: LD_INT 2
38237: PUSH
38238: EMPTY
38239: LIST
38240: LIST
38241: PUSH
38242: LD_INT 1
38244: NEG
38245: PUSH
38246: LD_INT 1
38248: PUSH
38249: EMPTY
38250: LIST
38251: LIST
38252: PUSH
38253: LD_INT 2
38255: NEG
38256: PUSH
38257: LD_INT 0
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: LD_INT 2
38266: NEG
38267: PUSH
38268: LD_INT 1
38270: NEG
38271: PUSH
38272: EMPTY
38273: LIST
38274: LIST
38275: PUSH
38276: LD_INT 1
38278: NEG
38279: PUSH
38280: LD_INT 3
38282: NEG
38283: PUSH
38284: EMPTY
38285: LIST
38286: LIST
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: LD_INT 3
38293: NEG
38294: PUSH
38295: EMPTY
38296: LIST
38297: LIST
38298: PUSH
38299: LD_INT 1
38301: PUSH
38302: LD_INT 2
38304: NEG
38305: PUSH
38306: EMPTY
38307: LIST
38308: LIST
38309: PUSH
38310: LD_INT 2
38312: PUSH
38313: LD_INT 1
38315: NEG
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 3
38323: PUSH
38324: LD_INT 0
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 3
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 1
38343: PUSH
38344: LD_INT 3
38346: PUSH
38347: EMPTY
38348: LIST
38349: LIST
38350: PUSH
38351: LD_INT 0
38353: PUSH
38354: LD_INT 3
38356: PUSH
38357: EMPTY
38358: LIST
38359: LIST
38360: PUSH
38361: LD_INT 1
38363: NEG
38364: PUSH
38365: LD_INT 2
38367: PUSH
38368: EMPTY
38369: LIST
38370: LIST
38371: PUSH
38372: LD_INT 2
38374: NEG
38375: PUSH
38376: LD_INT 1
38378: PUSH
38379: EMPTY
38380: LIST
38381: LIST
38382: PUSH
38383: LD_INT 3
38385: NEG
38386: PUSH
38387: LD_INT 0
38389: PUSH
38390: EMPTY
38391: LIST
38392: LIST
38393: PUSH
38394: LD_INT 3
38396: NEG
38397: PUSH
38398: LD_INT 1
38400: NEG
38401: PUSH
38402: EMPTY
38403: LIST
38404: LIST
38405: PUSH
38406: EMPTY
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: LIST
38417: LIST
38418: LIST
38419: LIST
38420: LIST
38421: LIST
38422: LIST
38423: LIST
38424: LIST
38425: LIST
38426: LIST
38427: LIST
38428: LIST
38429: LIST
38430: LIST
38431: LIST
38432: LIST
38433: LIST
38434: LIST
38435: LIST
38436: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38437: LD_ADDR_VAR 0 47
38441: PUSH
38442: LD_INT 0
38444: PUSH
38445: LD_INT 0
38447: PUSH
38448: EMPTY
38449: LIST
38450: LIST
38451: PUSH
38452: LD_INT 0
38454: PUSH
38455: LD_INT 1
38457: NEG
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 1
38465: PUSH
38466: LD_INT 0
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 1
38475: PUSH
38476: LD_INT 1
38478: PUSH
38479: EMPTY
38480: LIST
38481: LIST
38482: PUSH
38483: LD_INT 0
38485: PUSH
38486: LD_INT 1
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: PUSH
38493: LD_INT 1
38495: NEG
38496: PUSH
38497: LD_INT 0
38499: PUSH
38500: EMPTY
38501: LIST
38502: LIST
38503: PUSH
38504: LD_INT 1
38506: NEG
38507: PUSH
38508: LD_INT 1
38510: NEG
38511: PUSH
38512: EMPTY
38513: LIST
38514: LIST
38515: PUSH
38516: LD_INT 1
38518: NEG
38519: PUSH
38520: LD_INT 2
38522: NEG
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PUSH
38528: LD_INT 0
38530: PUSH
38531: LD_INT 2
38533: NEG
38534: PUSH
38535: EMPTY
38536: LIST
38537: LIST
38538: PUSH
38539: LD_INT 1
38541: PUSH
38542: LD_INT 1
38544: NEG
38545: PUSH
38546: EMPTY
38547: LIST
38548: LIST
38549: PUSH
38550: LD_INT 2
38552: NEG
38553: PUSH
38554: LD_INT 1
38556: NEG
38557: PUSH
38558: EMPTY
38559: LIST
38560: LIST
38561: PUSH
38562: LD_INT 2
38564: NEG
38565: PUSH
38566: LD_INT 2
38568: NEG
38569: PUSH
38570: EMPTY
38571: LIST
38572: LIST
38573: PUSH
38574: EMPTY
38575: LIST
38576: LIST
38577: LIST
38578: LIST
38579: LIST
38580: LIST
38581: LIST
38582: LIST
38583: LIST
38584: LIST
38585: LIST
38586: LIST
38587: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38588: LD_ADDR_VAR 0 48
38592: PUSH
38593: LD_INT 0
38595: PUSH
38596: LD_INT 0
38598: PUSH
38599: EMPTY
38600: LIST
38601: LIST
38602: PUSH
38603: LD_INT 0
38605: PUSH
38606: LD_INT 1
38608: NEG
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: LD_INT 1
38616: PUSH
38617: LD_INT 0
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 1
38626: PUSH
38627: LD_INT 1
38629: PUSH
38630: EMPTY
38631: LIST
38632: LIST
38633: PUSH
38634: LD_INT 0
38636: PUSH
38637: LD_INT 1
38639: PUSH
38640: EMPTY
38641: LIST
38642: LIST
38643: PUSH
38644: LD_INT 1
38646: NEG
38647: PUSH
38648: LD_INT 0
38650: PUSH
38651: EMPTY
38652: LIST
38653: LIST
38654: PUSH
38655: LD_INT 1
38657: NEG
38658: PUSH
38659: LD_INT 1
38661: NEG
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PUSH
38667: LD_INT 1
38669: NEG
38670: PUSH
38671: LD_INT 2
38673: NEG
38674: PUSH
38675: EMPTY
38676: LIST
38677: LIST
38678: PUSH
38679: LD_INT 0
38681: PUSH
38682: LD_INT 2
38684: NEG
38685: PUSH
38686: EMPTY
38687: LIST
38688: LIST
38689: PUSH
38690: LD_INT 1
38692: PUSH
38693: LD_INT 1
38695: NEG
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: LD_INT 2
38703: PUSH
38704: LD_INT 0
38706: PUSH
38707: EMPTY
38708: LIST
38709: LIST
38710: PUSH
38711: LD_INT 2
38713: PUSH
38714: LD_INT 1
38716: PUSH
38717: EMPTY
38718: LIST
38719: LIST
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: LIST
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38735: LD_ADDR_VAR 0 49
38739: PUSH
38740: LD_INT 0
38742: PUSH
38743: LD_INT 0
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 1
38755: NEG
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 1
38763: PUSH
38764: LD_INT 0
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 1
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 0
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 1
38793: NEG
38794: PUSH
38795: LD_INT 0
38797: PUSH
38798: EMPTY
38799: LIST
38800: LIST
38801: PUSH
38802: LD_INT 1
38804: NEG
38805: PUSH
38806: LD_INT 1
38808: NEG
38809: PUSH
38810: EMPTY
38811: LIST
38812: LIST
38813: PUSH
38814: LD_INT 1
38816: PUSH
38817: LD_INT 1
38819: NEG
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 2
38827: PUSH
38828: LD_INT 0
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 2
38837: PUSH
38838: LD_INT 1
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: LD_INT 2
38847: PUSH
38848: LD_INT 2
38850: PUSH
38851: EMPTY
38852: LIST
38853: LIST
38854: PUSH
38855: LD_INT 1
38857: PUSH
38858: LD_INT 2
38860: PUSH
38861: EMPTY
38862: LIST
38863: LIST
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: LIST
38869: LIST
38870: LIST
38871: LIST
38872: LIST
38873: LIST
38874: LIST
38875: LIST
38876: LIST
38877: LIST
38878: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38879: LD_ADDR_VAR 0 50
38883: PUSH
38884: LD_INT 0
38886: PUSH
38887: LD_INT 0
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 0
38896: PUSH
38897: LD_INT 1
38899: NEG
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 1
38907: PUSH
38908: LD_INT 0
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 1
38917: PUSH
38918: LD_INT 1
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 0
38927: PUSH
38928: LD_INT 1
38930: PUSH
38931: EMPTY
38932: LIST
38933: LIST
38934: PUSH
38935: LD_INT 1
38937: NEG
38938: PUSH
38939: LD_INT 0
38941: PUSH
38942: EMPTY
38943: LIST
38944: LIST
38945: PUSH
38946: LD_INT 1
38948: NEG
38949: PUSH
38950: LD_INT 1
38952: NEG
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 2
38960: PUSH
38961: LD_INT 1
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 2
38970: PUSH
38971: LD_INT 2
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 1
38980: PUSH
38981: LD_INT 2
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 0
38990: PUSH
38991: LD_INT 2
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 1
39000: NEG
39001: PUSH
39002: LD_INT 1
39004: PUSH
39005: EMPTY
39006: LIST
39007: LIST
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: LIST
39013: LIST
39014: LIST
39015: LIST
39016: LIST
39017: LIST
39018: LIST
39019: LIST
39020: LIST
39021: LIST
39022: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39023: LD_ADDR_VAR 0 51
39027: PUSH
39028: LD_INT 0
39030: PUSH
39031: LD_INT 0
39033: PUSH
39034: EMPTY
39035: LIST
39036: LIST
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: LD_INT 1
39043: NEG
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 1
39051: PUSH
39052: LD_INT 0
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PUSH
39059: LD_INT 1
39061: PUSH
39062: LD_INT 1
39064: PUSH
39065: EMPTY
39066: LIST
39067: LIST
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: LD_INT 1
39074: PUSH
39075: EMPTY
39076: LIST
39077: LIST
39078: PUSH
39079: LD_INT 1
39081: NEG
39082: PUSH
39083: LD_INT 0
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: LD_INT 1
39096: NEG
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 1
39104: PUSH
39105: LD_INT 2
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 2
39117: PUSH
39118: EMPTY
39119: LIST
39120: LIST
39121: PUSH
39122: LD_INT 1
39124: NEG
39125: PUSH
39126: LD_INT 1
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 2
39135: NEG
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: EMPTY
39141: LIST
39142: LIST
39143: PUSH
39144: LD_INT 2
39146: NEG
39147: PUSH
39148: LD_INT 1
39150: NEG
39151: PUSH
39152: EMPTY
39153: LIST
39154: LIST
39155: PUSH
39156: EMPTY
39157: LIST
39158: LIST
39159: LIST
39160: LIST
39161: LIST
39162: LIST
39163: LIST
39164: LIST
39165: LIST
39166: LIST
39167: LIST
39168: LIST
39169: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39170: LD_ADDR_VAR 0 52
39174: PUSH
39175: LD_INT 0
39177: PUSH
39178: LD_INT 0
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 0
39187: PUSH
39188: LD_INT 1
39190: NEG
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 1
39198: PUSH
39199: LD_INT 0
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 1
39208: PUSH
39209: LD_INT 1
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 0
39218: PUSH
39219: LD_INT 1
39221: PUSH
39222: EMPTY
39223: LIST
39224: LIST
39225: PUSH
39226: LD_INT 1
39228: NEG
39229: PUSH
39230: LD_INT 0
39232: PUSH
39233: EMPTY
39234: LIST
39235: LIST
39236: PUSH
39237: LD_INT 1
39239: NEG
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: EMPTY
39246: LIST
39247: LIST
39248: PUSH
39249: LD_INT 1
39251: NEG
39252: PUSH
39253: LD_INT 2
39255: NEG
39256: PUSH
39257: EMPTY
39258: LIST
39259: LIST
39260: PUSH
39261: LD_INT 1
39263: NEG
39264: PUSH
39265: LD_INT 1
39267: PUSH
39268: EMPTY
39269: LIST
39270: LIST
39271: PUSH
39272: LD_INT 2
39274: NEG
39275: PUSH
39276: LD_INT 0
39278: PUSH
39279: EMPTY
39280: LIST
39281: LIST
39282: PUSH
39283: LD_INT 2
39285: NEG
39286: PUSH
39287: LD_INT 1
39289: NEG
39290: PUSH
39291: EMPTY
39292: LIST
39293: LIST
39294: PUSH
39295: LD_INT 2
39297: NEG
39298: PUSH
39299: LD_INT 2
39301: NEG
39302: PUSH
39303: EMPTY
39304: LIST
39305: LIST
39306: PUSH
39307: EMPTY
39308: LIST
39309: LIST
39310: LIST
39311: LIST
39312: LIST
39313: LIST
39314: LIST
39315: LIST
39316: LIST
39317: LIST
39318: LIST
39319: LIST
39320: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39321: LD_ADDR_VAR 0 53
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: LD_INT 0
39331: PUSH
39332: EMPTY
39333: LIST
39334: LIST
39335: PUSH
39336: LD_INT 0
39338: PUSH
39339: LD_INT 1
39341: NEG
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 1
39349: PUSH
39350: LD_INT 0
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: LD_INT 1
39362: PUSH
39363: EMPTY
39364: LIST
39365: LIST
39366: PUSH
39367: LD_INT 0
39369: PUSH
39370: LD_INT 1
39372: PUSH
39373: EMPTY
39374: LIST
39375: LIST
39376: PUSH
39377: LD_INT 1
39379: NEG
39380: PUSH
39381: LD_INT 0
39383: PUSH
39384: EMPTY
39385: LIST
39386: LIST
39387: PUSH
39388: LD_INT 1
39390: NEG
39391: PUSH
39392: LD_INT 1
39394: NEG
39395: PUSH
39396: EMPTY
39397: LIST
39398: LIST
39399: PUSH
39400: LD_INT 1
39402: NEG
39403: PUSH
39404: LD_INT 2
39406: NEG
39407: PUSH
39408: EMPTY
39409: LIST
39410: LIST
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: LD_INT 2
39417: NEG
39418: PUSH
39419: EMPTY
39420: LIST
39421: LIST
39422: PUSH
39423: LD_INT 1
39425: PUSH
39426: LD_INT 1
39428: NEG
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 2
39436: PUSH
39437: LD_INT 0
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 2
39446: PUSH
39447: LD_INT 1
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 2
39456: PUSH
39457: LD_INT 2
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 1
39466: PUSH
39467: LD_INT 2
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: PUSH
39474: LD_INT 0
39476: PUSH
39477: LD_INT 2
39479: PUSH
39480: EMPTY
39481: LIST
39482: LIST
39483: PUSH
39484: LD_INT 1
39486: NEG
39487: PUSH
39488: LD_INT 1
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 2
39497: NEG
39498: PUSH
39499: LD_INT 0
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: LD_INT 2
39508: NEG
39509: PUSH
39510: LD_INT 1
39512: NEG
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PUSH
39518: LD_INT 2
39520: NEG
39521: PUSH
39522: LD_INT 2
39524: NEG
39525: PUSH
39526: EMPTY
39527: LIST
39528: LIST
39529: PUSH
39530: EMPTY
39531: LIST
39532: LIST
39533: LIST
39534: LIST
39535: LIST
39536: LIST
39537: LIST
39538: LIST
39539: LIST
39540: LIST
39541: LIST
39542: LIST
39543: LIST
39544: LIST
39545: LIST
39546: LIST
39547: LIST
39548: LIST
39549: LIST
39550: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39551: LD_ADDR_VAR 0 54
39555: PUSH
39556: LD_INT 0
39558: PUSH
39559: LD_INT 0
39561: PUSH
39562: EMPTY
39563: LIST
39564: LIST
39565: PUSH
39566: LD_INT 0
39568: PUSH
39569: LD_INT 1
39571: NEG
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 1
39579: PUSH
39580: LD_INT 0
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 1
39589: PUSH
39590: LD_INT 1
39592: PUSH
39593: EMPTY
39594: LIST
39595: LIST
39596: PUSH
39597: LD_INT 0
39599: PUSH
39600: LD_INT 1
39602: PUSH
39603: EMPTY
39604: LIST
39605: LIST
39606: PUSH
39607: LD_INT 1
39609: NEG
39610: PUSH
39611: LD_INT 0
39613: PUSH
39614: EMPTY
39615: LIST
39616: LIST
39617: PUSH
39618: LD_INT 1
39620: NEG
39621: PUSH
39622: LD_INT 1
39624: NEG
39625: PUSH
39626: EMPTY
39627: LIST
39628: LIST
39629: PUSH
39630: LD_INT 1
39632: NEG
39633: PUSH
39634: LD_INT 2
39636: NEG
39637: PUSH
39638: EMPTY
39639: LIST
39640: LIST
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: LD_INT 2
39647: NEG
39648: PUSH
39649: EMPTY
39650: LIST
39651: LIST
39652: PUSH
39653: LD_INT 1
39655: PUSH
39656: LD_INT 1
39658: NEG
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: LD_INT 0
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 2
39676: PUSH
39677: LD_INT 1
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 2
39686: PUSH
39687: LD_INT 2
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 1
39696: PUSH
39697: LD_INT 2
39699: PUSH
39700: EMPTY
39701: LIST
39702: LIST
39703: PUSH
39704: LD_INT 0
39706: PUSH
39707: LD_INT 2
39709: PUSH
39710: EMPTY
39711: LIST
39712: LIST
39713: PUSH
39714: LD_INT 1
39716: NEG
39717: PUSH
39718: LD_INT 1
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 2
39727: NEG
39728: PUSH
39729: LD_INT 0
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 2
39738: NEG
39739: PUSH
39740: LD_INT 1
39742: NEG
39743: PUSH
39744: EMPTY
39745: LIST
39746: LIST
39747: PUSH
39748: LD_INT 2
39750: NEG
39751: PUSH
39752: LD_INT 2
39754: NEG
39755: PUSH
39756: EMPTY
39757: LIST
39758: LIST
39759: PUSH
39760: EMPTY
39761: LIST
39762: LIST
39763: LIST
39764: LIST
39765: LIST
39766: LIST
39767: LIST
39768: LIST
39769: LIST
39770: LIST
39771: LIST
39772: LIST
39773: LIST
39774: LIST
39775: LIST
39776: LIST
39777: LIST
39778: LIST
39779: LIST
39780: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39781: LD_ADDR_VAR 0 55
39785: PUSH
39786: LD_INT 0
39788: PUSH
39789: LD_INT 0
39791: PUSH
39792: EMPTY
39793: LIST
39794: LIST
39795: PUSH
39796: LD_INT 0
39798: PUSH
39799: LD_INT 1
39801: NEG
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 1
39809: PUSH
39810: LD_INT 0
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 1
39819: PUSH
39820: LD_INT 1
39822: PUSH
39823: EMPTY
39824: LIST
39825: LIST
39826: PUSH
39827: LD_INT 0
39829: PUSH
39830: LD_INT 1
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 0
39843: PUSH
39844: EMPTY
39845: LIST
39846: LIST
39847: PUSH
39848: LD_INT 1
39850: NEG
39851: PUSH
39852: LD_INT 1
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: LD_INT 1
39862: NEG
39863: PUSH
39864: LD_INT 2
39866: NEG
39867: PUSH
39868: EMPTY
39869: LIST
39870: LIST
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: LD_INT 2
39877: NEG
39878: PUSH
39879: EMPTY
39880: LIST
39881: LIST
39882: PUSH
39883: LD_INT 1
39885: PUSH
39886: LD_INT 1
39888: NEG
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 2
39896: PUSH
39897: LD_INT 0
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 2
39906: PUSH
39907: LD_INT 1
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 2
39916: PUSH
39917: LD_INT 2
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 1
39926: PUSH
39927: LD_INT 2
39929: PUSH
39930: EMPTY
39931: LIST
39932: LIST
39933: PUSH
39934: LD_INT 0
39936: PUSH
39937: LD_INT 2
39939: PUSH
39940: EMPTY
39941: LIST
39942: LIST
39943: PUSH
39944: LD_INT 1
39946: NEG
39947: PUSH
39948: LD_INT 1
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 2
39957: NEG
39958: PUSH
39959: LD_INT 0
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: LD_INT 2
39968: NEG
39969: PUSH
39970: LD_INT 1
39972: NEG
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 2
39980: NEG
39981: PUSH
39982: LD_INT 2
39984: NEG
39985: PUSH
39986: EMPTY
39987: LIST
39988: LIST
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: LIST
39994: LIST
39995: LIST
39996: LIST
39997: LIST
39998: LIST
39999: LIST
40000: LIST
40001: LIST
40002: LIST
40003: LIST
40004: LIST
40005: LIST
40006: LIST
40007: LIST
40008: LIST
40009: LIST
40010: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40011: LD_ADDR_VAR 0 56
40015: PUSH
40016: LD_INT 0
40018: PUSH
40019: LD_INT 0
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: LD_INT 0
40028: PUSH
40029: LD_INT 1
40031: NEG
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 1
40039: PUSH
40040: LD_INT 0
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 1
40049: PUSH
40050: LD_INT 1
40052: PUSH
40053: EMPTY
40054: LIST
40055: LIST
40056: PUSH
40057: LD_INT 0
40059: PUSH
40060: LD_INT 1
40062: PUSH
40063: EMPTY
40064: LIST
40065: LIST
40066: PUSH
40067: LD_INT 1
40069: NEG
40070: PUSH
40071: LD_INT 0
40073: PUSH
40074: EMPTY
40075: LIST
40076: LIST
40077: PUSH
40078: LD_INT 1
40080: NEG
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: EMPTY
40087: LIST
40088: LIST
40089: PUSH
40090: LD_INT 1
40092: NEG
40093: PUSH
40094: LD_INT 2
40096: NEG
40097: PUSH
40098: EMPTY
40099: LIST
40100: LIST
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: LD_INT 2
40107: NEG
40108: PUSH
40109: EMPTY
40110: LIST
40111: LIST
40112: PUSH
40113: LD_INT 1
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 2
40126: PUSH
40127: LD_INT 0
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 2
40136: PUSH
40137: LD_INT 1
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 2
40146: PUSH
40147: LD_INT 2
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 1
40156: PUSH
40157: LD_INT 2
40159: PUSH
40160: EMPTY
40161: LIST
40162: LIST
40163: PUSH
40164: LD_INT 0
40166: PUSH
40167: LD_INT 2
40169: PUSH
40170: EMPTY
40171: LIST
40172: LIST
40173: PUSH
40174: LD_INT 1
40176: NEG
40177: PUSH
40178: LD_INT 1
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 2
40187: NEG
40188: PUSH
40189: LD_INT 0
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 2
40198: NEG
40199: PUSH
40200: LD_INT 1
40202: NEG
40203: PUSH
40204: EMPTY
40205: LIST
40206: LIST
40207: PUSH
40208: LD_INT 2
40210: NEG
40211: PUSH
40212: LD_INT 2
40214: NEG
40215: PUSH
40216: EMPTY
40217: LIST
40218: LIST
40219: PUSH
40220: EMPTY
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: LIST
40232: LIST
40233: LIST
40234: LIST
40235: LIST
40236: LIST
40237: LIST
40238: LIST
40239: LIST
40240: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40241: LD_ADDR_VAR 0 57
40245: PUSH
40246: LD_INT 0
40248: PUSH
40249: LD_INT 0
40251: PUSH
40252: EMPTY
40253: LIST
40254: LIST
40255: PUSH
40256: LD_INT 0
40258: PUSH
40259: LD_INT 1
40261: NEG
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: LD_INT 0
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 1
40279: PUSH
40280: LD_INT 1
40282: PUSH
40283: EMPTY
40284: LIST
40285: LIST
40286: PUSH
40287: LD_INT 0
40289: PUSH
40290: LD_INT 1
40292: PUSH
40293: EMPTY
40294: LIST
40295: LIST
40296: PUSH
40297: LD_INT 1
40299: NEG
40300: PUSH
40301: LD_INT 0
40303: PUSH
40304: EMPTY
40305: LIST
40306: LIST
40307: PUSH
40308: LD_INT 1
40310: NEG
40311: PUSH
40312: LD_INT 1
40314: NEG
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 1
40322: NEG
40323: PUSH
40324: LD_INT 2
40326: NEG
40327: PUSH
40328: EMPTY
40329: LIST
40330: LIST
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: LD_INT 2
40337: NEG
40338: PUSH
40339: EMPTY
40340: LIST
40341: LIST
40342: PUSH
40343: LD_INT 1
40345: PUSH
40346: LD_INT 1
40348: NEG
40349: PUSH
40350: EMPTY
40351: LIST
40352: LIST
40353: PUSH
40354: LD_INT 2
40356: PUSH
40357: LD_INT 0
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 2
40366: PUSH
40367: LD_INT 1
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 2
40376: PUSH
40377: LD_INT 2
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 1
40386: PUSH
40387: LD_INT 2
40389: PUSH
40390: EMPTY
40391: LIST
40392: LIST
40393: PUSH
40394: LD_INT 0
40396: PUSH
40397: LD_INT 2
40399: PUSH
40400: EMPTY
40401: LIST
40402: LIST
40403: PUSH
40404: LD_INT 1
40406: NEG
40407: PUSH
40408: LD_INT 1
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 2
40417: NEG
40418: PUSH
40419: LD_INT 0
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 2
40428: NEG
40429: PUSH
40430: LD_INT 1
40432: NEG
40433: PUSH
40434: EMPTY
40435: LIST
40436: LIST
40437: PUSH
40438: LD_INT 2
40440: NEG
40441: PUSH
40442: LD_INT 2
40444: NEG
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: EMPTY
40451: LIST
40452: LIST
40453: LIST
40454: LIST
40455: LIST
40456: LIST
40457: LIST
40458: LIST
40459: LIST
40460: LIST
40461: LIST
40462: LIST
40463: LIST
40464: LIST
40465: LIST
40466: LIST
40467: LIST
40468: LIST
40469: LIST
40470: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40471: LD_ADDR_VAR 0 58
40475: PUSH
40476: LD_INT 0
40478: PUSH
40479: LD_INT 0
40481: PUSH
40482: EMPTY
40483: LIST
40484: LIST
40485: PUSH
40486: LD_INT 0
40488: PUSH
40489: LD_INT 1
40491: NEG
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 1
40499: PUSH
40500: LD_INT 0
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 1
40509: PUSH
40510: LD_INT 1
40512: PUSH
40513: EMPTY
40514: LIST
40515: LIST
40516: PUSH
40517: LD_INT 0
40519: PUSH
40520: LD_INT 1
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 1
40529: NEG
40530: PUSH
40531: LD_INT 0
40533: PUSH
40534: EMPTY
40535: LIST
40536: LIST
40537: PUSH
40538: LD_INT 1
40540: NEG
40541: PUSH
40542: LD_INT 1
40544: NEG
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: NEG
40553: PUSH
40554: LD_INT 2
40556: NEG
40557: PUSH
40558: EMPTY
40559: LIST
40560: LIST
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: LD_INT 2
40567: NEG
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 1
40575: PUSH
40576: LD_INT 1
40578: NEG
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 2
40586: PUSH
40587: LD_INT 0
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 2
40596: PUSH
40597: LD_INT 1
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 2
40606: PUSH
40607: LD_INT 2
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 1
40616: PUSH
40617: LD_INT 2
40619: PUSH
40620: EMPTY
40621: LIST
40622: LIST
40623: PUSH
40624: LD_INT 0
40626: PUSH
40627: LD_INT 2
40629: PUSH
40630: EMPTY
40631: LIST
40632: LIST
40633: PUSH
40634: LD_INT 1
40636: NEG
40637: PUSH
40638: LD_INT 1
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 2
40647: NEG
40648: PUSH
40649: LD_INT 0
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 2
40658: NEG
40659: PUSH
40660: LD_INT 1
40662: NEG
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PUSH
40668: LD_INT 2
40670: NEG
40671: PUSH
40672: LD_INT 2
40674: NEG
40675: PUSH
40676: EMPTY
40677: LIST
40678: LIST
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: LIST
40684: LIST
40685: LIST
40686: LIST
40687: LIST
40688: LIST
40689: LIST
40690: LIST
40691: LIST
40692: LIST
40693: LIST
40694: LIST
40695: LIST
40696: LIST
40697: LIST
40698: LIST
40699: LIST
40700: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40701: LD_ADDR_VAR 0 59
40705: PUSH
40706: LD_INT 0
40708: PUSH
40709: LD_INT 0
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 0
40718: PUSH
40719: LD_INT 1
40721: NEG
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 1
40729: PUSH
40730: LD_INT 0
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: PUSH
40740: LD_INT 1
40742: PUSH
40743: EMPTY
40744: LIST
40745: LIST
40746: PUSH
40747: LD_INT 0
40749: PUSH
40750: LD_INT 1
40752: PUSH
40753: EMPTY
40754: LIST
40755: LIST
40756: PUSH
40757: LD_INT 1
40759: NEG
40760: PUSH
40761: LD_INT 0
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: LD_INT 1
40770: NEG
40771: PUSH
40772: LD_INT 1
40774: NEG
40775: PUSH
40776: EMPTY
40777: LIST
40778: LIST
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: LIST
40787: LIST
40788: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40789: LD_ADDR_VAR 0 60
40793: PUSH
40794: LD_INT 0
40796: PUSH
40797: LD_INT 0
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 0
40806: PUSH
40807: LD_INT 1
40809: NEG
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 1
40817: PUSH
40818: LD_INT 0
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: PUSH
40828: LD_INT 1
40830: PUSH
40831: EMPTY
40832: LIST
40833: LIST
40834: PUSH
40835: LD_INT 0
40837: PUSH
40838: LD_INT 1
40840: PUSH
40841: EMPTY
40842: LIST
40843: LIST
40844: PUSH
40845: LD_INT 1
40847: NEG
40848: PUSH
40849: LD_INT 0
40851: PUSH
40852: EMPTY
40853: LIST
40854: LIST
40855: PUSH
40856: LD_INT 1
40858: NEG
40859: PUSH
40860: LD_INT 1
40862: NEG
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: LIST
40872: LIST
40873: LIST
40874: LIST
40875: LIST
40876: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40877: LD_ADDR_VAR 0 61
40881: PUSH
40882: LD_INT 0
40884: PUSH
40885: LD_INT 0
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PUSH
40892: LD_INT 0
40894: PUSH
40895: LD_INT 1
40897: NEG
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 1
40905: PUSH
40906: LD_INT 0
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 1
40915: PUSH
40916: LD_INT 1
40918: PUSH
40919: EMPTY
40920: LIST
40921: LIST
40922: PUSH
40923: LD_INT 0
40925: PUSH
40926: LD_INT 1
40928: PUSH
40929: EMPTY
40930: LIST
40931: LIST
40932: PUSH
40933: LD_INT 1
40935: NEG
40936: PUSH
40937: LD_INT 0
40939: PUSH
40940: EMPTY
40941: LIST
40942: LIST
40943: PUSH
40944: LD_INT 1
40946: NEG
40947: PUSH
40948: LD_INT 1
40950: NEG
40951: PUSH
40952: EMPTY
40953: LIST
40954: LIST
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: LIST
40960: LIST
40961: LIST
40962: LIST
40963: LIST
40964: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40965: LD_ADDR_VAR 0 62
40969: PUSH
40970: LD_INT 0
40972: PUSH
40973: LD_INT 0
40975: PUSH
40976: EMPTY
40977: LIST
40978: LIST
40979: PUSH
40980: LD_INT 0
40982: PUSH
40983: LD_INT 1
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 1
40993: PUSH
40994: LD_INT 0
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 1
41003: PUSH
41004: LD_INT 1
41006: PUSH
41007: EMPTY
41008: LIST
41009: LIST
41010: PUSH
41011: LD_INT 0
41013: PUSH
41014: LD_INT 1
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PUSH
41021: LD_INT 1
41023: NEG
41024: PUSH
41025: LD_INT 0
41027: PUSH
41028: EMPTY
41029: LIST
41030: LIST
41031: PUSH
41032: LD_INT 1
41034: NEG
41035: PUSH
41036: LD_INT 1
41038: NEG
41039: PUSH
41040: EMPTY
41041: LIST
41042: LIST
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: LIST
41048: LIST
41049: LIST
41050: LIST
41051: LIST
41052: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41053: LD_ADDR_VAR 0 63
41057: PUSH
41058: LD_INT 0
41060: PUSH
41061: LD_INT 0
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: LD_INT 0
41070: PUSH
41071: LD_INT 1
41073: NEG
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: LD_INT 1
41081: PUSH
41082: LD_INT 0
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 1
41091: PUSH
41092: LD_INT 1
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: PUSH
41099: LD_INT 0
41101: PUSH
41102: LD_INT 1
41104: PUSH
41105: EMPTY
41106: LIST
41107: LIST
41108: PUSH
41109: LD_INT 1
41111: NEG
41112: PUSH
41113: LD_INT 0
41115: PUSH
41116: EMPTY
41117: LIST
41118: LIST
41119: PUSH
41120: LD_INT 1
41122: NEG
41123: PUSH
41124: LD_INT 1
41126: NEG
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: LIST
41136: LIST
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41141: LD_ADDR_VAR 0 64
41145: PUSH
41146: LD_INT 0
41148: PUSH
41149: LD_INT 0
41151: PUSH
41152: EMPTY
41153: LIST
41154: LIST
41155: PUSH
41156: LD_INT 0
41158: PUSH
41159: LD_INT 1
41161: NEG
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 1
41169: PUSH
41170: LD_INT 0
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 1
41179: PUSH
41180: LD_INT 1
41182: PUSH
41183: EMPTY
41184: LIST
41185: LIST
41186: PUSH
41187: LD_INT 0
41189: PUSH
41190: LD_INT 1
41192: PUSH
41193: EMPTY
41194: LIST
41195: LIST
41196: PUSH
41197: LD_INT 1
41199: NEG
41200: PUSH
41201: LD_INT 0
41203: PUSH
41204: EMPTY
41205: LIST
41206: LIST
41207: PUSH
41208: LD_INT 1
41210: NEG
41211: PUSH
41212: LD_INT 1
41214: NEG
41215: PUSH
41216: EMPTY
41217: LIST
41218: LIST
41219: PUSH
41220: EMPTY
41221: LIST
41222: LIST
41223: LIST
41224: LIST
41225: LIST
41226: LIST
41227: LIST
41228: ST_TO_ADDR
// end ; 1 :
41229: GO 47126
41231: LD_INT 1
41233: DOUBLE
41234: EQUAL
41235: IFTRUE 41239
41237: GO 43862
41239: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41240: LD_ADDR_VAR 0 11
41244: PUSH
41245: LD_INT 1
41247: NEG
41248: PUSH
41249: LD_INT 3
41251: NEG
41252: PUSH
41253: EMPTY
41254: LIST
41255: LIST
41256: PUSH
41257: LD_INT 0
41259: PUSH
41260: LD_INT 3
41262: NEG
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: PUSH
41268: LD_INT 1
41270: PUSH
41271: LD_INT 2
41273: NEG
41274: PUSH
41275: EMPTY
41276: LIST
41277: LIST
41278: PUSH
41279: EMPTY
41280: LIST
41281: LIST
41282: LIST
41283: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41284: LD_ADDR_VAR 0 12
41288: PUSH
41289: LD_INT 2
41291: PUSH
41292: LD_INT 1
41294: NEG
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: LD_INT 0
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: LD_INT 1
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: LIST
41324: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41325: LD_ADDR_VAR 0 13
41329: PUSH
41330: LD_INT 3
41332: PUSH
41333: LD_INT 2
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 3
41342: PUSH
41343: LD_INT 3
41345: PUSH
41346: EMPTY
41347: LIST
41348: LIST
41349: PUSH
41350: LD_INT 2
41352: PUSH
41353: LD_INT 3
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: EMPTY
41361: LIST
41362: LIST
41363: LIST
41364: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41365: LD_ADDR_VAR 0 14
41369: PUSH
41370: LD_INT 1
41372: PUSH
41373: LD_INT 3
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: LD_INT 0
41382: PUSH
41383: LD_INT 3
41385: PUSH
41386: EMPTY
41387: LIST
41388: LIST
41389: PUSH
41390: LD_INT 1
41392: NEG
41393: PUSH
41394: LD_INT 2
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: EMPTY
41402: LIST
41403: LIST
41404: LIST
41405: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41406: LD_ADDR_VAR 0 15
41410: PUSH
41411: LD_INT 2
41413: NEG
41414: PUSH
41415: LD_INT 1
41417: PUSH
41418: EMPTY
41419: LIST
41420: LIST
41421: PUSH
41422: LD_INT 3
41424: NEG
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 3
41435: NEG
41436: PUSH
41437: LD_INT 1
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: EMPTY
41446: LIST
41447: LIST
41448: LIST
41449: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41450: LD_ADDR_VAR 0 16
41454: PUSH
41455: LD_INT 2
41457: NEG
41458: PUSH
41459: LD_INT 3
41461: NEG
41462: PUSH
41463: EMPTY
41464: LIST
41465: LIST
41466: PUSH
41467: LD_INT 3
41469: NEG
41470: PUSH
41471: LD_INT 2
41473: NEG
41474: PUSH
41475: EMPTY
41476: LIST
41477: LIST
41478: PUSH
41479: LD_INT 3
41481: NEG
41482: PUSH
41483: LD_INT 3
41485: NEG
41486: PUSH
41487: EMPTY
41488: LIST
41489: LIST
41490: PUSH
41491: EMPTY
41492: LIST
41493: LIST
41494: LIST
41495: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41496: LD_ADDR_VAR 0 17
41500: PUSH
41501: LD_INT 1
41503: NEG
41504: PUSH
41505: LD_INT 3
41507: NEG
41508: PUSH
41509: EMPTY
41510: LIST
41511: LIST
41512: PUSH
41513: LD_INT 0
41515: PUSH
41516: LD_INT 3
41518: NEG
41519: PUSH
41520: EMPTY
41521: LIST
41522: LIST
41523: PUSH
41524: LD_INT 1
41526: PUSH
41527: LD_INT 2
41529: NEG
41530: PUSH
41531: EMPTY
41532: LIST
41533: LIST
41534: PUSH
41535: EMPTY
41536: LIST
41537: LIST
41538: LIST
41539: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41540: LD_ADDR_VAR 0 18
41544: PUSH
41545: LD_INT 2
41547: PUSH
41548: LD_INT 1
41550: NEG
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: LD_INT 3
41558: PUSH
41559: LD_INT 0
41561: PUSH
41562: EMPTY
41563: LIST
41564: LIST
41565: PUSH
41566: LD_INT 3
41568: PUSH
41569: LD_INT 1
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: EMPTY
41577: LIST
41578: LIST
41579: LIST
41580: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41581: LD_ADDR_VAR 0 19
41585: PUSH
41586: LD_INT 3
41588: PUSH
41589: LD_INT 2
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 3
41598: PUSH
41599: LD_INT 3
41601: PUSH
41602: EMPTY
41603: LIST
41604: LIST
41605: PUSH
41606: LD_INT 2
41608: PUSH
41609: LD_INT 3
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: EMPTY
41617: LIST
41618: LIST
41619: LIST
41620: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41621: LD_ADDR_VAR 0 20
41625: PUSH
41626: LD_INT 1
41628: PUSH
41629: LD_INT 3
41631: PUSH
41632: EMPTY
41633: LIST
41634: LIST
41635: PUSH
41636: LD_INT 0
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: EMPTY
41643: LIST
41644: LIST
41645: PUSH
41646: LD_INT 1
41648: NEG
41649: PUSH
41650: LD_INT 2
41652: PUSH
41653: EMPTY
41654: LIST
41655: LIST
41656: PUSH
41657: EMPTY
41658: LIST
41659: LIST
41660: LIST
41661: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41662: LD_ADDR_VAR 0 21
41666: PUSH
41667: LD_INT 2
41669: NEG
41670: PUSH
41671: LD_INT 1
41673: PUSH
41674: EMPTY
41675: LIST
41676: LIST
41677: PUSH
41678: LD_INT 3
41680: NEG
41681: PUSH
41682: LD_INT 0
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 3
41691: NEG
41692: PUSH
41693: LD_INT 1
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: EMPTY
41702: LIST
41703: LIST
41704: LIST
41705: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41706: LD_ADDR_VAR 0 22
41710: PUSH
41711: LD_INT 2
41713: NEG
41714: PUSH
41715: LD_INT 3
41717: NEG
41718: PUSH
41719: EMPTY
41720: LIST
41721: LIST
41722: PUSH
41723: LD_INT 3
41725: NEG
41726: PUSH
41727: LD_INT 2
41729: NEG
41730: PUSH
41731: EMPTY
41732: LIST
41733: LIST
41734: PUSH
41735: LD_INT 3
41737: NEG
41738: PUSH
41739: LD_INT 3
41741: NEG
41742: PUSH
41743: EMPTY
41744: LIST
41745: LIST
41746: PUSH
41747: EMPTY
41748: LIST
41749: LIST
41750: LIST
41751: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41752: LD_ADDR_VAR 0 23
41756: PUSH
41757: LD_INT 0
41759: PUSH
41760: LD_INT 3
41762: NEG
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: LD_INT 1
41770: NEG
41771: PUSH
41772: LD_INT 4
41774: NEG
41775: PUSH
41776: EMPTY
41777: LIST
41778: LIST
41779: PUSH
41780: LD_INT 1
41782: PUSH
41783: LD_INT 3
41785: NEG
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: EMPTY
41792: LIST
41793: LIST
41794: LIST
41795: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41796: LD_ADDR_VAR 0 24
41800: PUSH
41801: LD_INT 3
41803: PUSH
41804: LD_INT 0
41806: PUSH
41807: EMPTY
41808: LIST
41809: LIST
41810: PUSH
41811: LD_INT 3
41813: PUSH
41814: LD_INT 1
41816: NEG
41817: PUSH
41818: EMPTY
41819: LIST
41820: LIST
41821: PUSH
41822: LD_INT 4
41824: PUSH
41825: LD_INT 1
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: EMPTY
41833: LIST
41834: LIST
41835: LIST
41836: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41837: LD_ADDR_VAR 0 25
41841: PUSH
41842: LD_INT 3
41844: PUSH
41845: LD_INT 3
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: LD_INT 4
41854: PUSH
41855: LD_INT 3
41857: PUSH
41858: EMPTY
41859: LIST
41860: LIST
41861: PUSH
41862: LD_INT 3
41864: PUSH
41865: LD_INT 4
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: EMPTY
41873: LIST
41874: LIST
41875: LIST
41876: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41877: LD_ADDR_VAR 0 26
41881: PUSH
41882: LD_INT 0
41884: PUSH
41885: LD_INT 3
41887: PUSH
41888: EMPTY
41889: LIST
41890: LIST
41891: PUSH
41892: LD_INT 1
41894: PUSH
41895: LD_INT 4
41897: PUSH
41898: EMPTY
41899: LIST
41900: LIST
41901: PUSH
41902: LD_INT 1
41904: NEG
41905: PUSH
41906: LD_INT 3
41908: PUSH
41909: EMPTY
41910: LIST
41911: LIST
41912: PUSH
41913: EMPTY
41914: LIST
41915: LIST
41916: LIST
41917: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41918: LD_ADDR_VAR 0 27
41922: PUSH
41923: LD_INT 3
41925: NEG
41926: PUSH
41927: LD_INT 0
41929: PUSH
41930: EMPTY
41931: LIST
41932: LIST
41933: PUSH
41934: LD_INT 3
41936: NEG
41937: PUSH
41938: LD_INT 1
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 4
41947: NEG
41948: PUSH
41949: LD_INT 1
41951: NEG
41952: PUSH
41953: EMPTY
41954: LIST
41955: LIST
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: LIST
41961: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41962: LD_ADDR_VAR 0 28
41966: PUSH
41967: LD_INT 3
41969: NEG
41970: PUSH
41971: LD_INT 3
41973: NEG
41974: PUSH
41975: EMPTY
41976: LIST
41977: LIST
41978: PUSH
41979: LD_INT 3
41981: NEG
41982: PUSH
41983: LD_INT 4
41985: NEG
41986: PUSH
41987: EMPTY
41988: LIST
41989: LIST
41990: PUSH
41991: LD_INT 4
41993: NEG
41994: PUSH
41995: LD_INT 3
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: EMPTY
42004: LIST
42005: LIST
42006: LIST
42007: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42008: LD_ADDR_VAR 0 29
42012: PUSH
42013: LD_INT 1
42015: NEG
42016: PUSH
42017: LD_INT 3
42019: NEG
42020: PUSH
42021: EMPTY
42022: LIST
42023: LIST
42024: PUSH
42025: LD_INT 0
42027: PUSH
42028: LD_INT 3
42030: NEG
42031: PUSH
42032: EMPTY
42033: LIST
42034: LIST
42035: PUSH
42036: LD_INT 1
42038: PUSH
42039: LD_INT 2
42041: NEG
42042: PUSH
42043: EMPTY
42044: LIST
42045: LIST
42046: PUSH
42047: LD_INT 1
42049: NEG
42050: PUSH
42051: LD_INT 4
42053: NEG
42054: PUSH
42055: EMPTY
42056: LIST
42057: LIST
42058: PUSH
42059: LD_INT 0
42061: PUSH
42062: LD_INT 4
42064: NEG
42065: PUSH
42066: EMPTY
42067: LIST
42068: LIST
42069: PUSH
42070: LD_INT 1
42072: PUSH
42073: LD_INT 3
42075: NEG
42076: PUSH
42077: EMPTY
42078: LIST
42079: LIST
42080: PUSH
42081: LD_INT 1
42083: NEG
42084: PUSH
42085: LD_INT 5
42087: NEG
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 0
42095: PUSH
42096: LD_INT 5
42098: NEG
42099: PUSH
42100: EMPTY
42101: LIST
42102: LIST
42103: PUSH
42104: LD_INT 1
42106: PUSH
42107: LD_INT 4
42109: NEG
42110: PUSH
42111: EMPTY
42112: LIST
42113: LIST
42114: PUSH
42115: LD_INT 1
42117: NEG
42118: PUSH
42119: LD_INT 6
42121: NEG
42122: PUSH
42123: EMPTY
42124: LIST
42125: LIST
42126: PUSH
42127: LD_INT 0
42129: PUSH
42130: LD_INT 6
42132: NEG
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 1
42140: PUSH
42141: LD_INT 5
42143: NEG
42144: PUSH
42145: EMPTY
42146: LIST
42147: LIST
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: LIST
42153: LIST
42154: LIST
42155: LIST
42156: LIST
42157: LIST
42158: LIST
42159: LIST
42160: LIST
42161: LIST
42162: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42163: LD_ADDR_VAR 0 30
42167: PUSH
42168: LD_INT 2
42170: PUSH
42171: LD_INT 1
42173: NEG
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 3
42181: PUSH
42182: LD_INT 0
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: LD_INT 1
42194: PUSH
42195: EMPTY
42196: LIST
42197: LIST
42198: PUSH
42199: LD_INT 3
42201: PUSH
42202: LD_INT 1
42204: NEG
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 4
42212: PUSH
42213: LD_INT 0
42215: PUSH
42216: EMPTY
42217: LIST
42218: LIST
42219: PUSH
42220: LD_INT 4
42222: PUSH
42223: LD_INT 1
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 4
42232: PUSH
42233: LD_INT 1
42235: NEG
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 5
42243: PUSH
42244: LD_INT 0
42246: PUSH
42247: EMPTY
42248: LIST
42249: LIST
42250: PUSH
42251: LD_INT 5
42253: PUSH
42254: LD_INT 1
42256: PUSH
42257: EMPTY
42258: LIST
42259: LIST
42260: PUSH
42261: LD_INT 5
42263: PUSH
42264: LD_INT 1
42266: NEG
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 6
42274: PUSH
42275: LD_INT 0
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 6
42284: PUSH
42285: LD_INT 1
42287: PUSH
42288: EMPTY
42289: LIST
42290: LIST
42291: PUSH
42292: EMPTY
42293: LIST
42294: LIST
42295: LIST
42296: LIST
42297: LIST
42298: LIST
42299: LIST
42300: LIST
42301: LIST
42302: LIST
42303: LIST
42304: LIST
42305: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42306: LD_ADDR_VAR 0 31
42310: PUSH
42311: LD_INT 3
42313: PUSH
42314: LD_INT 2
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 3
42323: PUSH
42324: LD_INT 3
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 2
42333: PUSH
42334: LD_INT 3
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: LD_INT 4
42343: PUSH
42344: LD_INT 3
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 4
42353: PUSH
42354: LD_INT 4
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 3
42363: PUSH
42364: LD_INT 4
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 5
42373: PUSH
42374: LD_INT 4
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 5
42383: PUSH
42384: LD_INT 5
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 4
42393: PUSH
42394: LD_INT 5
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 6
42403: PUSH
42404: LD_INT 5
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: LD_INT 6
42413: PUSH
42414: LD_INT 6
42416: PUSH
42417: EMPTY
42418: LIST
42419: LIST
42420: PUSH
42421: LD_INT 5
42423: PUSH
42424: LD_INT 6
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42445: LD_ADDR_VAR 0 32
42449: PUSH
42450: LD_INT 1
42452: PUSH
42453: LD_INT 3
42455: PUSH
42456: EMPTY
42457: LIST
42458: LIST
42459: PUSH
42460: LD_INT 0
42462: PUSH
42463: LD_INT 3
42465: PUSH
42466: EMPTY
42467: LIST
42468: LIST
42469: PUSH
42470: LD_INT 1
42472: NEG
42473: PUSH
42474: LD_INT 2
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 1
42483: PUSH
42484: LD_INT 4
42486: PUSH
42487: EMPTY
42488: LIST
42489: LIST
42490: PUSH
42491: LD_INT 0
42493: PUSH
42494: LD_INT 4
42496: PUSH
42497: EMPTY
42498: LIST
42499: LIST
42500: PUSH
42501: LD_INT 1
42503: NEG
42504: PUSH
42505: LD_INT 3
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 1
42514: PUSH
42515: LD_INT 5
42517: PUSH
42518: EMPTY
42519: LIST
42520: LIST
42521: PUSH
42522: LD_INT 0
42524: PUSH
42525: LD_INT 5
42527: PUSH
42528: EMPTY
42529: LIST
42530: LIST
42531: PUSH
42532: LD_INT 1
42534: NEG
42535: PUSH
42536: LD_INT 4
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 1
42545: PUSH
42546: LD_INT 6
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 0
42555: PUSH
42556: LD_INT 6
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 1
42565: NEG
42566: PUSH
42567: LD_INT 5
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: LIST
42578: LIST
42579: LIST
42580: LIST
42581: LIST
42582: LIST
42583: LIST
42584: LIST
42585: LIST
42586: LIST
42587: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42588: LD_ADDR_VAR 0 33
42592: PUSH
42593: LD_INT 2
42595: NEG
42596: PUSH
42597: LD_INT 1
42599: PUSH
42600: EMPTY
42601: LIST
42602: LIST
42603: PUSH
42604: LD_INT 3
42606: NEG
42607: PUSH
42608: LD_INT 0
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 3
42617: NEG
42618: PUSH
42619: LD_INT 1
42621: NEG
42622: PUSH
42623: EMPTY
42624: LIST
42625: LIST
42626: PUSH
42627: LD_INT 3
42629: NEG
42630: PUSH
42631: LD_INT 1
42633: PUSH
42634: EMPTY
42635: LIST
42636: LIST
42637: PUSH
42638: LD_INT 4
42640: NEG
42641: PUSH
42642: LD_INT 0
42644: PUSH
42645: EMPTY
42646: LIST
42647: LIST
42648: PUSH
42649: LD_INT 4
42651: NEG
42652: PUSH
42653: LD_INT 1
42655: NEG
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: PUSH
42661: LD_INT 4
42663: NEG
42664: PUSH
42665: LD_INT 1
42667: PUSH
42668: EMPTY
42669: LIST
42670: LIST
42671: PUSH
42672: LD_INT 5
42674: NEG
42675: PUSH
42676: LD_INT 0
42678: PUSH
42679: EMPTY
42680: LIST
42681: LIST
42682: PUSH
42683: LD_INT 5
42685: NEG
42686: PUSH
42687: LD_INT 1
42689: NEG
42690: PUSH
42691: EMPTY
42692: LIST
42693: LIST
42694: PUSH
42695: LD_INT 5
42697: NEG
42698: PUSH
42699: LD_INT 1
42701: PUSH
42702: EMPTY
42703: LIST
42704: LIST
42705: PUSH
42706: LD_INT 6
42708: NEG
42709: PUSH
42710: LD_INT 0
42712: PUSH
42713: EMPTY
42714: LIST
42715: LIST
42716: PUSH
42717: LD_INT 6
42719: NEG
42720: PUSH
42721: LD_INT 1
42723: NEG
42724: PUSH
42725: EMPTY
42726: LIST
42727: LIST
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: LIST
42733: LIST
42734: LIST
42735: LIST
42736: LIST
42737: LIST
42738: LIST
42739: LIST
42740: LIST
42741: LIST
42742: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42743: LD_ADDR_VAR 0 34
42747: PUSH
42748: LD_INT 2
42750: NEG
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: EMPTY
42757: LIST
42758: LIST
42759: PUSH
42760: LD_INT 3
42762: NEG
42763: PUSH
42764: LD_INT 2
42766: NEG
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PUSH
42772: LD_INT 3
42774: NEG
42775: PUSH
42776: LD_INT 3
42778: NEG
42779: PUSH
42780: EMPTY
42781: LIST
42782: LIST
42783: PUSH
42784: LD_INT 3
42786: NEG
42787: PUSH
42788: LD_INT 4
42790: NEG
42791: PUSH
42792: EMPTY
42793: LIST
42794: LIST
42795: PUSH
42796: LD_INT 4
42798: NEG
42799: PUSH
42800: LD_INT 3
42802: NEG
42803: PUSH
42804: EMPTY
42805: LIST
42806: LIST
42807: PUSH
42808: LD_INT 4
42810: NEG
42811: PUSH
42812: LD_INT 4
42814: NEG
42815: PUSH
42816: EMPTY
42817: LIST
42818: LIST
42819: PUSH
42820: LD_INT 4
42822: NEG
42823: PUSH
42824: LD_INT 5
42826: NEG
42827: PUSH
42828: EMPTY
42829: LIST
42830: LIST
42831: PUSH
42832: LD_INT 5
42834: NEG
42835: PUSH
42836: LD_INT 4
42838: NEG
42839: PUSH
42840: EMPTY
42841: LIST
42842: LIST
42843: PUSH
42844: LD_INT 5
42846: NEG
42847: PUSH
42848: LD_INT 5
42850: NEG
42851: PUSH
42852: EMPTY
42853: LIST
42854: LIST
42855: PUSH
42856: LD_INT 5
42858: NEG
42859: PUSH
42860: LD_INT 6
42862: NEG
42863: PUSH
42864: EMPTY
42865: LIST
42866: LIST
42867: PUSH
42868: LD_INT 6
42870: NEG
42871: PUSH
42872: LD_INT 5
42874: NEG
42875: PUSH
42876: EMPTY
42877: LIST
42878: LIST
42879: PUSH
42880: LD_INT 6
42882: NEG
42883: PUSH
42884: LD_INT 6
42886: NEG
42887: PUSH
42888: EMPTY
42889: LIST
42890: LIST
42891: PUSH
42892: EMPTY
42893: LIST
42894: LIST
42895: LIST
42896: LIST
42897: LIST
42898: LIST
42899: LIST
42900: LIST
42901: LIST
42902: LIST
42903: LIST
42904: LIST
42905: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42906: LD_ADDR_VAR 0 41
42910: PUSH
42911: LD_INT 0
42913: PUSH
42914: LD_INT 2
42916: NEG
42917: PUSH
42918: EMPTY
42919: LIST
42920: LIST
42921: PUSH
42922: LD_INT 1
42924: NEG
42925: PUSH
42926: LD_INT 3
42928: NEG
42929: PUSH
42930: EMPTY
42931: LIST
42932: LIST
42933: PUSH
42934: LD_INT 1
42936: PUSH
42937: LD_INT 2
42939: NEG
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: EMPTY
42946: LIST
42947: LIST
42948: LIST
42949: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42950: LD_ADDR_VAR 0 42
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 0
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 2
42967: PUSH
42968: LD_INT 1
42970: NEG
42971: PUSH
42972: EMPTY
42973: LIST
42974: LIST
42975: PUSH
42976: LD_INT 3
42978: PUSH
42979: LD_INT 1
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: EMPTY
42987: LIST
42988: LIST
42989: LIST
42990: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42991: LD_ADDR_VAR 0 43
42995: PUSH
42996: LD_INT 2
42998: PUSH
42999: LD_INT 2
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: LD_INT 3
43008: PUSH
43009: LD_INT 2
43011: PUSH
43012: EMPTY
43013: LIST
43014: LIST
43015: PUSH
43016: LD_INT 2
43018: PUSH
43019: LD_INT 3
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: EMPTY
43027: LIST
43028: LIST
43029: LIST
43030: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43031: LD_ADDR_VAR 0 44
43035: PUSH
43036: LD_INT 0
43038: PUSH
43039: LD_INT 2
43041: PUSH
43042: EMPTY
43043: LIST
43044: LIST
43045: PUSH
43046: LD_INT 1
43048: PUSH
43049: LD_INT 3
43051: PUSH
43052: EMPTY
43053: LIST
43054: LIST
43055: PUSH
43056: LD_INT 1
43058: NEG
43059: PUSH
43060: LD_INT 2
43062: PUSH
43063: EMPTY
43064: LIST
43065: LIST
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: LIST
43071: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43072: LD_ADDR_VAR 0 45
43076: PUSH
43077: LD_INT 2
43079: NEG
43080: PUSH
43081: LD_INT 0
43083: PUSH
43084: EMPTY
43085: LIST
43086: LIST
43087: PUSH
43088: LD_INT 2
43090: NEG
43091: PUSH
43092: LD_INT 1
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 3
43101: NEG
43102: PUSH
43103: LD_INT 1
43105: NEG
43106: PUSH
43107: EMPTY
43108: LIST
43109: LIST
43110: PUSH
43111: EMPTY
43112: LIST
43113: LIST
43114: LIST
43115: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43116: LD_ADDR_VAR 0 46
43120: PUSH
43121: LD_INT 2
43123: NEG
43124: PUSH
43125: LD_INT 2
43127: NEG
43128: PUSH
43129: EMPTY
43130: LIST
43131: LIST
43132: PUSH
43133: LD_INT 2
43135: NEG
43136: PUSH
43137: LD_INT 3
43139: NEG
43140: PUSH
43141: EMPTY
43142: LIST
43143: LIST
43144: PUSH
43145: LD_INT 3
43147: NEG
43148: PUSH
43149: LD_INT 2
43151: NEG
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: EMPTY
43158: LIST
43159: LIST
43160: LIST
43161: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43162: LD_ADDR_VAR 0 47
43166: PUSH
43167: LD_INT 2
43169: NEG
43170: PUSH
43171: LD_INT 3
43173: NEG
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 1
43181: NEG
43182: PUSH
43183: LD_INT 3
43185: NEG
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: EMPTY
43192: LIST
43193: LIST
43194: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43195: LD_ADDR_VAR 0 48
43199: PUSH
43200: LD_INT 1
43202: PUSH
43203: LD_INT 2
43205: NEG
43206: PUSH
43207: EMPTY
43208: LIST
43209: LIST
43210: PUSH
43211: LD_INT 2
43213: PUSH
43214: LD_INT 1
43216: NEG
43217: PUSH
43218: EMPTY
43219: LIST
43220: LIST
43221: PUSH
43222: EMPTY
43223: LIST
43224: LIST
43225: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43226: LD_ADDR_VAR 0 49
43230: PUSH
43231: LD_INT 3
43233: PUSH
43234: LD_INT 1
43236: PUSH
43237: EMPTY
43238: LIST
43239: LIST
43240: PUSH
43241: LD_INT 3
43243: PUSH
43244: LD_INT 2
43246: PUSH
43247: EMPTY
43248: LIST
43249: LIST
43250: PUSH
43251: EMPTY
43252: LIST
43253: LIST
43254: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43255: LD_ADDR_VAR 0 50
43259: PUSH
43260: LD_INT 2
43262: PUSH
43263: LD_INT 3
43265: PUSH
43266: EMPTY
43267: LIST
43268: LIST
43269: PUSH
43270: LD_INT 1
43272: PUSH
43273: LD_INT 3
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43284: LD_ADDR_VAR 0 51
43288: PUSH
43289: LD_INT 1
43291: NEG
43292: PUSH
43293: LD_INT 2
43295: PUSH
43296: EMPTY
43297: LIST
43298: LIST
43299: PUSH
43300: LD_INT 2
43302: NEG
43303: PUSH
43304: LD_INT 1
43306: PUSH
43307: EMPTY
43308: LIST
43309: LIST
43310: PUSH
43311: EMPTY
43312: LIST
43313: LIST
43314: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43315: LD_ADDR_VAR 0 52
43319: PUSH
43320: LD_INT 3
43322: NEG
43323: PUSH
43324: LD_INT 1
43326: NEG
43327: PUSH
43328: EMPTY
43329: LIST
43330: LIST
43331: PUSH
43332: LD_INT 3
43334: NEG
43335: PUSH
43336: LD_INT 2
43338: NEG
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: EMPTY
43345: LIST
43346: LIST
43347: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43348: LD_ADDR_VAR 0 53
43352: PUSH
43353: LD_INT 1
43355: NEG
43356: PUSH
43357: LD_INT 3
43359: NEG
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: LD_INT 0
43367: PUSH
43368: LD_INT 3
43370: NEG
43371: PUSH
43372: EMPTY
43373: LIST
43374: LIST
43375: PUSH
43376: LD_INT 1
43378: PUSH
43379: LD_INT 2
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: EMPTY
43388: LIST
43389: LIST
43390: LIST
43391: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43392: LD_ADDR_VAR 0 54
43396: PUSH
43397: LD_INT 2
43399: PUSH
43400: LD_INT 1
43402: NEG
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: LD_INT 3
43410: PUSH
43411: LD_INT 0
43413: PUSH
43414: EMPTY
43415: LIST
43416: LIST
43417: PUSH
43418: LD_INT 3
43420: PUSH
43421: LD_INT 1
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: EMPTY
43429: LIST
43430: LIST
43431: LIST
43432: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43433: LD_ADDR_VAR 0 55
43437: PUSH
43438: LD_INT 3
43440: PUSH
43441: LD_INT 2
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 3
43450: PUSH
43451: LD_INT 3
43453: PUSH
43454: EMPTY
43455: LIST
43456: LIST
43457: PUSH
43458: LD_INT 2
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: EMPTY
43469: LIST
43470: LIST
43471: LIST
43472: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43473: LD_ADDR_VAR 0 56
43477: PUSH
43478: LD_INT 1
43480: PUSH
43481: LD_INT 3
43483: PUSH
43484: EMPTY
43485: LIST
43486: LIST
43487: PUSH
43488: LD_INT 0
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: EMPTY
43495: LIST
43496: LIST
43497: PUSH
43498: LD_INT 1
43500: NEG
43501: PUSH
43502: LD_INT 2
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: EMPTY
43510: LIST
43511: LIST
43512: LIST
43513: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43514: LD_ADDR_VAR 0 57
43518: PUSH
43519: LD_INT 2
43521: NEG
43522: PUSH
43523: LD_INT 1
43525: PUSH
43526: EMPTY
43527: LIST
43528: LIST
43529: PUSH
43530: LD_INT 3
43532: NEG
43533: PUSH
43534: LD_INT 0
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 3
43543: NEG
43544: PUSH
43545: LD_INT 1
43547: NEG
43548: PUSH
43549: EMPTY
43550: LIST
43551: LIST
43552: PUSH
43553: EMPTY
43554: LIST
43555: LIST
43556: LIST
43557: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43558: LD_ADDR_VAR 0 58
43562: PUSH
43563: LD_INT 2
43565: NEG
43566: PUSH
43567: LD_INT 3
43569: NEG
43570: PUSH
43571: EMPTY
43572: LIST
43573: LIST
43574: PUSH
43575: LD_INT 3
43577: NEG
43578: PUSH
43579: LD_INT 2
43581: NEG
43582: PUSH
43583: EMPTY
43584: LIST
43585: LIST
43586: PUSH
43587: LD_INT 3
43589: NEG
43590: PUSH
43591: LD_INT 3
43593: NEG
43594: PUSH
43595: EMPTY
43596: LIST
43597: LIST
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: LIST
43603: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43604: LD_ADDR_VAR 0 59
43608: PUSH
43609: LD_INT 1
43611: NEG
43612: PUSH
43613: LD_INT 2
43615: NEG
43616: PUSH
43617: EMPTY
43618: LIST
43619: LIST
43620: PUSH
43621: LD_INT 0
43623: PUSH
43624: LD_INT 2
43626: NEG
43627: PUSH
43628: EMPTY
43629: LIST
43630: LIST
43631: PUSH
43632: LD_INT 1
43634: PUSH
43635: LD_INT 1
43637: NEG
43638: PUSH
43639: EMPTY
43640: LIST
43641: LIST
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: LIST
43647: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43648: LD_ADDR_VAR 0 60
43652: PUSH
43653: LD_INT 1
43655: PUSH
43656: LD_INT 1
43658: NEG
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: LD_INT 2
43666: PUSH
43667: LD_INT 0
43669: PUSH
43670: EMPTY
43671: LIST
43672: LIST
43673: PUSH
43674: LD_INT 2
43676: PUSH
43677: LD_INT 1
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: EMPTY
43685: LIST
43686: LIST
43687: LIST
43688: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43689: LD_ADDR_VAR 0 61
43693: PUSH
43694: LD_INT 2
43696: PUSH
43697: LD_INT 1
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 2
43706: PUSH
43707: LD_INT 2
43709: PUSH
43710: EMPTY
43711: LIST
43712: LIST
43713: PUSH
43714: LD_INT 1
43716: PUSH
43717: LD_INT 2
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: EMPTY
43725: LIST
43726: LIST
43727: LIST
43728: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43729: LD_ADDR_VAR 0 62
43733: PUSH
43734: LD_INT 1
43736: PUSH
43737: LD_INT 2
43739: PUSH
43740: EMPTY
43741: LIST
43742: LIST
43743: PUSH
43744: LD_INT 0
43746: PUSH
43747: LD_INT 2
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 1
43756: NEG
43757: PUSH
43758: LD_INT 1
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: EMPTY
43766: LIST
43767: LIST
43768: LIST
43769: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43770: LD_ADDR_VAR 0 63
43774: PUSH
43775: LD_INT 1
43777: NEG
43778: PUSH
43779: LD_INT 1
43781: PUSH
43782: EMPTY
43783: LIST
43784: LIST
43785: PUSH
43786: LD_INT 2
43788: NEG
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 2
43799: NEG
43800: PUSH
43801: LD_INT 1
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: EMPTY
43810: LIST
43811: LIST
43812: LIST
43813: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43814: LD_ADDR_VAR 0 64
43818: PUSH
43819: LD_INT 1
43821: NEG
43822: PUSH
43823: LD_INT 2
43825: NEG
43826: PUSH
43827: EMPTY
43828: LIST
43829: LIST
43830: PUSH
43831: LD_INT 2
43833: NEG
43834: PUSH
43835: LD_INT 1
43837: NEG
43838: PUSH
43839: EMPTY
43840: LIST
43841: LIST
43842: PUSH
43843: LD_INT 2
43845: NEG
43846: PUSH
43847: LD_INT 2
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: LIST
43859: ST_TO_ADDR
// end ; 2 :
43860: GO 47126
43862: LD_INT 2
43864: DOUBLE
43865: EQUAL
43866: IFTRUE 43870
43868: GO 47125
43870: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43871: LD_ADDR_VAR 0 29
43875: PUSH
43876: LD_INT 4
43878: PUSH
43879: LD_INT 0
43881: PUSH
43882: EMPTY
43883: LIST
43884: LIST
43885: PUSH
43886: LD_INT 4
43888: PUSH
43889: LD_INT 1
43891: NEG
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 5
43899: PUSH
43900: LD_INT 0
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 5
43909: PUSH
43910: LD_INT 1
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 4
43919: PUSH
43920: LD_INT 1
43922: PUSH
43923: EMPTY
43924: LIST
43925: LIST
43926: PUSH
43927: LD_INT 3
43929: PUSH
43930: LD_INT 0
43932: PUSH
43933: EMPTY
43934: LIST
43935: LIST
43936: PUSH
43937: LD_INT 3
43939: PUSH
43940: LD_INT 1
43942: NEG
43943: PUSH
43944: EMPTY
43945: LIST
43946: LIST
43947: PUSH
43948: LD_INT 3
43950: PUSH
43951: LD_INT 2
43953: NEG
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 5
43961: PUSH
43962: LD_INT 2
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 3
43971: PUSH
43972: LD_INT 3
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 3
43981: PUSH
43982: LD_INT 2
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 4
43991: PUSH
43992: LD_INT 3
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 4
44001: PUSH
44002: LD_INT 4
44004: PUSH
44005: EMPTY
44006: LIST
44007: LIST
44008: PUSH
44009: LD_INT 3
44011: PUSH
44012: LD_INT 4
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 2
44021: PUSH
44022: LD_INT 3
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 2
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 4
44041: PUSH
44042: LD_INT 2
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 2
44051: PUSH
44052: LD_INT 4
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 0
44061: PUSH
44062: LD_INT 4
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 0
44071: PUSH
44072: LD_INT 3
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 1
44081: PUSH
44082: LD_INT 4
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 1
44091: PUSH
44092: LD_INT 5
44094: PUSH
44095: EMPTY
44096: LIST
44097: LIST
44098: PUSH
44099: LD_INT 0
44101: PUSH
44102: LD_INT 5
44104: PUSH
44105: EMPTY
44106: LIST
44107: LIST
44108: PUSH
44109: LD_INT 1
44111: NEG
44112: PUSH
44113: LD_INT 4
44115: PUSH
44116: EMPTY
44117: LIST
44118: LIST
44119: PUSH
44120: LD_INT 1
44122: NEG
44123: PUSH
44124: LD_INT 3
44126: PUSH
44127: EMPTY
44128: LIST
44129: LIST
44130: PUSH
44131: LD_INT 2
44133: PUSH
44134: LD_INT 5
44136: PUSH
44137: EMPTY
44138: LIST
44139: LIST
44140: PUSH
44141: LD_INT 2
44143: NEG
44144: PUSH
44145: LD_INT 3
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 3
44154: NEG
44155: PUSH
44156: LD_INT 0
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 3
44165: NEG
44166: PUSH
44167: LD_INT 1
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 2
44177: NEG
44178: PUSH
44179: LD_INT 0
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 2
44188: NEG
44189: PUSH
44190: LD_INT 1
44192: PUSH
44193: EMPTY
44194: LIST
44195: LIST
44196: PUSH
44197: LD_INT 3
44199: NEG
44200: PUSH
44201: LD_INT 1
44203: PUSH
44204: EMPTY
44205: LIST
44206: LIST
44207: PUSH
44208: LD_INT 4
44210: NEG
44211: PUSH
44212: LD_INT 0
44214: PUSH
44215: EMPTY
44216: LIST
44217: LIST
44218: PUSH
44219: LD_INT 4
44221: NEG
44222: PUSH
44223: LD_INT 1
44225: NEG
44226: PUSH
44227: EMPTY
44228: LIST
44229: LIST
44230: PUSH
44231: LD_INT 4
44233: NEG
44234: PUSH
44235: LD_INT 2
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 2
44245: NEG
44246: PUSH
44247: LD_INT 2
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 4
44256: NEG
44257: PUSH
44258: LD_INT 4
44260: NEG
44261: PUSH
44262: EMPTY
44263: LIST
44264: LIST
44265: PUSH
44266: LD_INT 4
44268: NEG
44269: PUSH
44270: LD_INT 5
44272: NEG
44273: PUSH
44274: EMPTY
44275: LIST
44276: LIST
44277: PUSH
44278: LD_INT 3
44280: NEG
44281: PUSH
44282: LD_INT 4
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 3
44292: NEG
44293: PUSH
44294: LD_INT 3
44296: NEG
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 4
44304: NEG
44305: PUSH
44306: LD_INT 3
44308: NEG
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 5
44316: NEG
44317: PUSH
44318: LD_INT 4
44320: NEG
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 5
44328: NEG
44329: PUSH
44330: LD_INT 5
44332: NEG
44333: PUSH
44334: EMPTY
44335: LIST
44336: LIST
44337: PUSH
44338: LD_INT 3
44340: NEG
44341: PUSH
44342: LD_INT 5
44344: NEG
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: LD_INT 5
44352: NEG
44353: PUSH
44354: LD_INT 3
44356: NEG
44357: PUSH
44358: EMPTY
44359: LIST
44360: LIST
44361: PUSH
44362: EMPTY
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: LIST
44389: LIST
44390: LIST
44391: LIST
44392: LIST
44393: LIST
44394: LIST
44395: LIST
44396: LIST
44397: LIST
44398: LIST
44399: LIST
44400: LIST
44401: LIST
44402: LIST
44403: LIST
44404: LIST
44405: LIST
44406: LIST
44407: LIST
44408: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44409: LD_ADDR_VAR 0 30
44413: PUSH
44414: LD_INT 4
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 4
44426: PUSH
44427: LD_INT 3
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 5
44436: PUSH
44437: LD_INT 4
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 5
44446: PUSH
44447: LD_INT 5
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 4
44456: PUSH
44457: LD_INT 5
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 3
44466: PUSH
44467: LD_INT 4
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 3
44476: PUSH
44477: LD_INT 3
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 5
44486: PUSH
44487: LD_INT 3
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 3
44496: PUSH
44497: LD_INT 5
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 0
44506: PUSH
44507: LD_INT 3
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 0
44516: PUSH
44517: LD_INT 2
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 1
44526: PUSH
44527: LD_INT 3
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 1
44536: PUSH
44537: LD_INT 4
44539: PUSH
44540: EMPTY
44541: LIST
44542: LIST
44543: PUSH
44544: LD_INT 0
44546: PUSH
44547: LD_INT 4
44549: PUSH
44550: EMPTY
44551: LIST
44552: LIST
44553: PUSH
44554: LD_INT 1
44556: NEG
44557: PUSH
44558: LD_INT 3
44560: PUSH
44561: EMPTY
44562: LIST
44563: LIST
44564: PUSH
44565: LD_INT 1
44567: NEG
44568: PUSH
44569: LD_INT 2
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: PUSH
44576: LD_INT 2
44578: PUSH
44579: LD_INT 4
44581: PUSH
44582: EMPTY
44583: LIST
44584: LIST
44585: PUSH
44586: LD_INT 2
44588: NEG
44589: PUSH
44590: LD_INT 2
44592: PUSH
44593: EMPTY
44594: LIST
44595: LIST
44596: PUSH
44597: LD_INT 4
44599: NEG
44600: PUSH
44601: LD_INT 0
44603: PUSH
44604: EMPTY
44605: LIST
44606: LIST
44607: PUSH
44608: LD_INT 4
44610: NEG
44611: PUSH
44612: LD_INT 1
44614: NEG
44615: PUSH
44616: EMPTY
44617: LIST
44618: LIST
44619: PUSH
44620: LD_INT 3
44622: NEG
44623: PUSH
44624: LD_INT 0
44626: PUSH
44627: EMPTY
44628: LIST
44629: LIST
44630: PUSH
44631: LD_INT 3
44633: NEG
44634: PUSH
44635: LD_INT 1
44637: PUSH
44638: EMPTY
44639: LIST
44640: LIST
44641: PUSH
44642: LD_INT 4
44644: NEG
44645: PUSH
44646: LD_INT 1
44648: PUSH
44649: EMPTY
44650: LIST
44651: LIST
44652: PUSH
44653: LD_INT 5
44655: NEG
44656: PUSH
44657: LD_INT 0
44659: PUSH
44660: EMPTY
44661: LIST
44662: LIST
44663: PUSH
44664: LD_INT 5
44666: NEG
44667: PUSH
44668: LD_INT 1
44670: NEG
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 5
44678: NEG
44679: PUSH
44680: LD_INT 2
44682: NEG
44683: PUSH
44684: EMPTY
44685: LIST
44686: LIST
44687: PUSH
44688: LD_INT 3
44690: NEG
44691: PUSH
44692: LD_INT 2
44694: PUSH
44695: EMPTY
44696: LIST
44697: LIST
44698: PUSH
44699: LD_INT 3
44701: NEG
44702: PUSH
44703: LD_INT 3
44705: NEG
44706: PUSH
44707: EMPTY
44708: LIST
44709: LIST
44710: PUSH
44711: LD_INT 3
44713: NEG
44714: PUSH
44715: LD_INT 4
44717: NEG
44718: PUSH
44719: EMPTY
44720: LIST
44721: LIST
44722: PUSH
44723: LD_INT 2
44725: NEG
44726: PUSH
44727: LD_INT 3
44729: NEG
44730: PUSH
44731: EMPTY
44732: LIST
44733: LIST
44734: PUSH
44735: LD_INT 2
44737: NEG
44738: PUSH
44739: LD_INT 2
44741: NEG
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 3
44749: NEG
44750: PUSH
44751: LD_INT 2
44753: NEG
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: LD_INT 4
44761: NEG
44762: PUSH
44763: LD_INT 3
44765: NEG
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 4
44773: NEG
44774: PUSH
44775: LD_INT 4
44777: NEG
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 2
44785: NEG
44786: PUSH
44787: LD_INT 4
44789: NEG
44790: PUSH
44791: EMPTY
44792: LIST
44793: LIST
44794: PUSH
44795: LD_INT 4
44797: NEG
44798: PUSH
44799: LD_INT 2
44801: NEG
44802: PUSH
44803: EMPTY
44804: LIST
44805: LIST
44806: PUSH
44807: LD_INT 0
44809: PUSH
44810: LD_INT 4
44812: NEG
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 0
44820: PUSH
44821: LD_INT 5
44823: NEG
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PUSH
44829: LD_INT 1
44831: PUSH
44832: LD_INT 4
44834: NEG
44835: PUSH
44836: EMPTY
44837: LIST
44838: LIST
44839: PUSH
44840: LD_INT 1
44842: PUSH
44843: LD_INT 3
44845: NEG
44846: PUSH
44847: EMPTY
44848: LIST
44849: LIST
44850: PUSH
44851: LD_INT 0
44853: PUSH
44854: LD_INT 3
44856: NEG
44857: PUSH
44858: EMPTY
44859: LIST
44860: LIST
44861: PUSH
44862: LD_INT 1
44864: NEG
44865: PUSH
44866: LD_INT 4
44868: NEG
44869: PUSH
44870: EMPTY
44871: LIST
44872: LIST
44873: PUSH
44874: LD_INT 1
44876: NEG
44877: PUSH
44878: LD_INT 5
44880: NEG
44881: PUSH
44882: EMPTY
44883: LIST
44884: LIST
44885: PUSH
44886: LD_INT 2
44888: PUSH
44889: LD_INT 3
44891: NEG
44892: PUSH
44893: EMPTY
44894: LIST
44895: LIST
44896: PUSH
44897: LD_INT 2
44899: NEG
44900: PUSH
44901: LD_INT 5
44903: NEG
44904: PUSH
44905: EMPTY
44906: LIST
44907: LIST
44908: PUSH
44909: EMPTY
44910: LIST
44911: LIST
44912: LIST
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: LIST
44936: LIST
44937: LIST
44938: LIST
44939: LIST
44940: LIST
44941: LIST
44942: LIST
44943: LIST
44944: LIST
44945: LIST
44946: LIST
44947: LIST
44948: LIST
44949: LIST
44950: LIST
44951: LIST
44952: LIST
44953: LIST
44954: LIST
44955: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44956: LD_ADDR_VAR 0 31
44960: PUSH
44961: LD_INT 0
44963: PUSH
44964: LD_INT 4
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_INT 0
44973: PUSH
44974: LD_INT 3
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 1
44983: PUSH
44984: LD_INT 4
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 1
44993: PUSH
44994: LD_INT 5
44996: PUSH
44997: EMPTY
44998: LIST
44999: LIST
45000: PUSH
45001: LD_INT 0
45003: PUSH
45004: LD_INT 5
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 1
45013: NEG
45014: PUSH
45015: LD_INT 4
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 1
45024: NEG
45025: PUSH
45026: LD_INT 3
45028: PUSH
45029: EMPTY
45030: LIST
45031: LIST
45032: PUSH
45033: LD_INT 2
45035: PUSH
45036: LD_INT 5
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_INT 2
45045: NEG
45046: PUSH
45047: LD_INT 3
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 3
45056: NEG
45057: PUSH
45058: LD_INT 0
45060: PUSH
45061: EMPTY
45062: LIST
45063: LIST
45064: PUSH
45065: LD_INT 3
45067: NEG
45068: PUSH
45069: LD_INT 1
45071: NEG
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 2
45079: NEG
45080: PUSH
45081: LD_INT 0
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 2
45090: NEG
45091: PUSH
45092: LD_INT 1
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 3
45101: NEG
45102: PUSH
45103: LD_INT 1
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 4
45112: NEG
45113: PUSH
45114: LD_INT 0
45116: PUSH
45117: EMPTY
45118: LIST
45119: LIST
45120: PUSH
45121: LD_INT 4
45123: NEG
45124: PUSH
45125: LD_INT 1
45127: NEG
45128: PUSH
45129: EMPTY
45130: LIST
45131: LIST
45132: PUSH
45133: LD_INT 4
45135: NEG
45136: PUSH
45137: LD_INT 2
45139: NEG
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: LD_INT 2
45147: NEG
45148: PUSH
45149: LD_INT 2
45151: PUSH
45152: EMPTY
45153: LIST
45154: LIST
45155: PUSH
45156: LD_INT 4
45158: NEG
45159: PUSH
45160: LD_INT 4
45162: NEG
45163: PUSH
45164: EMPTY
45165: LIST
45166: LIST
45167: PUSH
45168: LD_INT 4
45170: NEG
45171: PUSH
45172: LD_INT 5
45174: NEG
45175: PUSH
45176: EMPTY
45177: LIST
45178: LIST
45179: PUSH
45180: LD_INT 3
45182: NEG
45183: PUSH
45184: LD_INT 4
45186: NEG
45187: PUSH
45188: EMPTY
45189: LIST
45190: LIST
45191: PUSH
45192: LD_INT 3
45194: NEG
45195: PUSH
45196: LD_INT 3
45198: NEG
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: PUSH
45204: LD_INT 4
45206: NEG
45207: PUSH
45208: LD_INT 3
45210: NEG
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: PUSH
45216: LD_INT 5
45218: NEG
45219: PUSH
45220: LD_INT 4
45222: NEG
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 5
45230: NEG
45231: PUSH
45232: LD_INT 5
45234: NEG
45235: PUSH
45236: EMPTY
45237: LIST
45238: LIST
45239: PUSH
45240: LD_INT 3
45242: NEG
45243: PUSH
45244: LD_INT 5
45246: NEG
45247: PUSH
45248: EMPTY
45249: LIST
45250: LIST
45251: PUSH
45252: LD_INT 5
45254: NEG
45255: PUSH
45256: LD_INT 3
45258: NEG
45259: PUSH
45260: EMPTY
45261: LIST
45262: LIST
45263: PUSH
45264: LD_INT 0
45266: PUSH
45267: LD_INT 3
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 0
45277: PUSH
45278: LD_INT 4
45280: NEG
45281: PUSH
45282: EMPTY
45283: LIST
45284: LIST
45285: PUSH
45286: LD_INT 1
45288: PUSH
45289: LD_INT 3
45291: NEG
45292: PUSH
45293: EMPTY
45294: LIST
45295: LIST
45296: PUSH
45297: LD_INT 1
45299: PUSH
45300: LD_INT 2
45302: NEG
45303: PUSH
45304: EMPTY
45305: LIST
45306: LIST
45307: PUSH
45308: LD_INT 0
45310: PUSH
45311: LD_INT 2
45313: NEG
45314: PUSH
45315: EMPTY
45316: LIST
45317: LIST
45318: PUSH
45319: LD_INT 1
45321: NEG
45322: PUSH
45323: LD_INT 3
45325: NEG
45326: PUSH
45327: EMPTY
45328: LIST
45329: LIST
45330: PUSH
45331: LD_INT 1
45333: NEG
45334: PUSH
45335: LD_INT 4
45337: NEG
45338: PUSH
45339: EMPTY
45340: LIST
45341: LIST
45342: PUSH
45343: LD_INT 2
45345: PUSH
45346: LD_INT 2
45348: NEG
45349: PUSH
45350: EMPTY
45351: LIST
45352: LIST
45353: PUSH
45354: LD_INT 2
45356: NEG
45357: PUSH
45358: LD_INT 4
45360: NEG
45361: PUSH
45362: EMPTY
45363: LIST
45364: LIST
45365: PUSH
45366: LD_INT 4
45368: PUSH
45369: LD_INT 0
45371: PUSH
45372: EMPTY
45373: LIST
45374: LIST
45375: PUSH
45376: LD_INT 4
45378: PUSH
45379: LD_INT 1
45381: NEG
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 5
45389: PUSH
45390: LD_INT 0
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: LD_INT 5
45399: PUSH
45400: LD_INT 1
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 4
45409: PUSH
45410: LD_INT 1
45412: PUSH
45413: EMPTY
45414: LIST
45415: LIST
45416: PUSH
45417: LD_INT 3
45419: PUSH
45420: LD_INT 0
45422: PUSH
45423: EMPTY
45424: LIST
45425: LIST
45426: PUSH
45427: LD_INT 3
45429: PUSH
45430: LD_INT 1
45432: NEG
45433: PUSH
45434: EMPTY
45435: LIST
45436: LIST
45437: PUSH
45438: LD_INT 3
45440: PUSH
45441: LD_INT 2
45443: NEG
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 5
45451: PUSH
45452: LD_INT 2
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: EMPTY
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: LIST
45486: LIST
45487: LIST
45488: LIST
45489: LIST
45490: LIST
45491: LIST
45492: LIST
45493: LIST
45494: LIST
45495: LIST
45496: LIST
45497: LIST
45498: LIST
45499: LIST
45500: LIST
45501: LIST
45502: LIST
45503: LIST
45504: LIST
45505: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45506: LD_ADDR_VAR 0 32
45510: PUSH
45511: LD_INT 4
45513: NEG
45514: PUSH
45515: LD_INT 0
45517: PUSH
45518: EMPTY
45519: LIST
45520: LIST
45521: PUSH
45522: LD_INT 4
45524: NEG
45525: PUSH
45526: LD_INT 1
45528: NEG
45529: PUSH
45530: EMPTY
45531: LIST
45532: LIST
45533: PUSH
45534: LD_INT 3
45536: NEG
45537: PUSH
45538: LD_INT 0
45540: PUSH
45541: EMPTY
45542: LIST
45543: LIST
45544: PUSH
45545: LD_INT 3
45547: NEG
45548: PUSH
45549: LD_INT 1
45551: PUSH
45552: EMPTY
45553: LIST
45554: LIST
45555: PUSH
45556: LD_INT 4
45558: NEG
45559: PUSH
45560: LD_INT 1
45562: PUSH
45563: EMPTY
45564: LIST
45565: LIST
45566: PUSH
45567: LD_INT 5
45569: NEG
45570: PUSH
45571: LD_INT 0
45573: PUSH
45574: EMPTY
45575: LIST
45576: LIST
45577: PUSH
45578: LD_INT 5
45580: NEG
45581: PUSH
45582: LD_INT 1
45584: NEG
45585: PUSH
45586: EMPTY
45587: LIST
45588: LIST
45589: PUSH
45590: LD_INT 5
45592: NEG
45593: PUSH
45594: LD_INT 2
45596: NEG
45597: PUSH
45598: EMPTY
45599: LIST
45600: LIST
45601: PUSH
45602: LD_INT 3
45604: NEG
45605: PUSH
45606: LD_INT 2
45608: PUSH
45609: EMPTY
45610: LIST
45611: LIST
45612: PUSH
45613: LD_INT 3
45615: NEG
45616: PUSH
45617: LD_INT 3
45619: NEG
45620: PUSH
45621: EMPTY
45622: LIST
45623: LIST
45624: PUSH
45625: LD_INT 3
45627: NEG
45628: PUSH
45629: LD_INT 4
45631: NEG
45632: PUSH
45633: EMPTY
45634: LIST
45635: LIST
45636: PUSH
45637: LD_INT 2
45639: NEG
45640: PUSH
45641: LD_INT 3
45643: NEG
45644: PUSH
45645: EMPTY
45646: LIST
45647: LIST
45648: PUSH
45649: LD_INT 2
45651: NEG
45652: PUSH
45653: LD_INT 2
45655: NEG
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: LD_INT 3
45663: NEG
45664: PUSH
45665: LD_INT 2
45667: NEG
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PUSH
45673: LD_INT 4
45675: NEG
45676: PUSH
45677: LD_INT 3
45679: NEG
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 4
45687: NEG
45688: PUSH
45689: LD_INT 4
45691: NEG
45692: PUSH
45693: EMPTY
45694: LIST
45695: LIST
45696: PUSH
45697: LD_INT 2
45699: NEG
45700: PUSH
45701: LD_INT 4
45703: NEG
45704: PUSH
45705: EMPTY
45706: LIST
45707: LIST
45708: PUSH
45709: LD_INT 4
45711: NEG
45712: PUSH
45713: LD_INT 2
45715: NEG
45716: PUSH
45717: EMPTY
45718: LIST
45719: LIST
45720: PUSH
45721: LD_INT 0
45723: PUSH
45724: LD_INT 4
45726: NEG
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 0
45734: PUSH
45735: LD_INT 5
45737: NEG
45738: PUSH
45739: EMPTY
45740: LIST
45741: LIST
45742: PUSH
45743: LD_INT 1
45745: PUSH
45746: LD_INT 4
45748: NEG
45749: PUSH
45750: EMPTY
45751: LIST
45752: LIST
45753: PUSH
45754: LD_INT 1
45756: PUSH
45757: LD_INT 3
45759: NEG
45760: PUSH
45761: EMPTY
45762: LIST
45763: LIST
45764: PUSH
45765: LD_INT 0
45767: PUSH
45768: LD_INT 3
45770: NEG
45771: PUSH
45772: EMPTY
45773: LIST
45774: LIST
45775: PUSH
45776: LD_INT 1
45778: NEG
45779: PUSH
45780: LD_INT 4
45782: NEG
45783: PUSH
45784: EMPTY
45785: LIST
45786: LIST
45787: PUSH
45788: LD_INT 1
45790: NEG
45791: PUSH
45792: LD_INT 5
45794: NEG
45795: PUSH
45796: EMPTY
45797: LIST
45798: LIST
45799: PUSH
45800: LD_INT 2
45802: PUSH
45803: LD_INT 3
45805: NEG
45806: PUSH
45807: EMPTY
45808: LIST
45809: LIST
45810: PUSH
45811: LD_INT 2
45813: NEG
45814: PUSH
45815: LD_INT 5
45817: NEG
45818: PUSH
45819: EMPTY
45820: LIST
45821: LIST
45822: PUSH
45823: LD_INT 3
45825: PUSH
45826: LD_INT 0
45828: PUSH
45829: EMPTY
45830: LIST
45831: LIST
45832: PUSH
45833: LD_INT 3
45835: PUSH
45836: LD_INT 1
45838: NEG
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 4
45846: PUSH
45847: LD_INT 0
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: LD_INT 4
45856: PUSH
45857: LD_INT 1
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 3
45866: PUSH
45867: LD_INT 1
45869: PUSH
45870: EMPTY
45871: LIST
45872: LIST
45873: PUSH
45874: LD_INT 2
45876: PUSH
45877: LD_INT 0
45879: PUSH
45880: EMPTY
45881: LIST
45882: LIST
45883: PUSH
45884: LD_INT 2
45886: PUSH
45887: LD_INT 1
45889: NEG
45890: PUSH
45891: EMPTY
45892: LIST
45893: LIST
45894: PUSH
45895: LD_INT 2
45897: PUSH
45898: LD_INT 2
45900: NEG
45901: PUSH
45902: EMPTY
45903: LIST
45904: LIST
45905: PUSH
45906: LD_INT 4
45908: PUSH
45909: LD_INT 2
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 4
45918: PUSH
45919: LD_INT 4
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 4
45928: PUSH
45929: LD_INT 3
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 5
45938: PUSH
45939: LD_INT 4
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 5
45948: PUSH
45949: LD_INT 5
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: PUSH
45956: LD_INT 4
45958: PUSH
45959: LD_INT 5
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 3
45968: PUSH
45969: LD_INT 4
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 3
45978: PUSH
45979: LD_INT 3
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: LD_INT 5
45988: PUSH
45989: LD_INT 3
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: PUSH
45996: LD_INT 3
45998: PUSH
45999: LD_INT 5
46001: PUSH
46002: EMPTY
46003: LIST
46004: LIST
46005: PUSH
46006: EMPTY
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: LIST
46033: LIST
46034: LIST
46035: LIST
46036: LIST
46037: LIST
46038: LIST
46039: LIST
46040: LIST
46041: LIST
46042: LIST
46043: LIST
46044: LIST
46045: LIST
46046: LIST
46047: LIST
46048: LIST
46049: LIST
46050: LIST
46051: LIST
46052: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46053: LD_ADDR_VAR 0 33
46057: PUSH
46058: LD_INT 4
46060: NEG
46061: PUSH
46062: LD_INT 4
46064: NEG
46065: PUSH
46066: EMPTY
46067: LIST
46068: LIST
46069: PUSH
46070: LD_INT 4
46072: NEG
46073: PUSH
46074: LD_INT 5
46076: NEG
46077: PUSH
46078: EMPTY
46079: LIST
46080: LIST
46081: PUSH
46082: LD_INT 3
46084: NEG
46085: PUSH
46086: LD_INT 4
46088: NEG
46089: PUSH
46090: EMPTY
46091: LIST
46092: LIST
46093: PUSH
46094: LD_INT 3
46096: NEG
46097: PUSH
46098: LD_INT 3
46100: NEG
46101: PUSH
46102: EMPTY
46103: LIST
46104: LIST
46105: PUSH
46106: LD_INT 4
46108: NEG
46109: PUSH
46110: LD_INT 3
46112: NEG
46113: PUSH
46114: EMPTY
46115: LIST
46116: LIST
46117: PUSH
46118: LD_INT 5
46120: NEG
46121: PUSH
46122: LD_INT 4
46124: NEG
46125: PUSH
46126: EMPTY
46127: LIST
46128: LIST
46129: PUSH
46130: LD_INT 5
46132: NEG
46133: PUSH
46134: LD_INT 5
46136: NEG
46137: PUSH
46138: EMPTY
46139: LIST
46140: LIST
46141: PUSH
46142: LD_INT 3
46144: NEG
46145: PUSH
46146: LD_INT 5
46148: NEG
46149: PUSH
46150: EMPTY
46151: LIST
46152: LIST
46153: PUSH
46154: LD_INT 5
46156: NEG
46157: PUSH
46158: LD_INT 3
46160: NEG
46161: PUSH
46162: EMPTY
46163: LIST
46164: LIST
46165: PUSH
46166: LD_INT 0
46168: PUSH
46169: LD_INT 3
46171: NEG
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: PUSH
46177: LD_INT 0
46179: PUSH
46180: LD_INT 4
46182: NEG
46183: PUSH
46184: EMPTY
46185: LIST
46186: LIST
46187: PUSH
46188: LD_INT 1
46190: PUSH
46191: LD_INT 3
46193: NEG
46194: PUSH
46195: EMPTY
46196: LIST
46197: LIST
46198: PUSH
46199: LD_INT 1
46201: PUSH
46202: LD_INT 2
46204: NEG
46205: PUSH
46206: EMPTY
46207: LIST
46208: LIST
46209: PUSH
46210: LD_INT 0
46212: PUSH
46213: LD_INT 2
46215: NEG
46216: PUSH
46217: EMPTY
46218: LIST
46219: LIST
46220: PUSH
46221: LD_INT 1
46223: NEG
46224: PUSH
46225: LD_INT 3
46227: NEG
46228: PUSH
46229: EMPTY
46230: LIST
46231: LIST
46232: PUSH
46233: LD_INT 1
46235: NEG
46236: PUSH
46237: LD_INT 4
46239: NEG
46240: PUSH
46241: EMPTY
46242: LIST
46243: LIST
46244: PUSH
46245: LD_INT 2
46247: PUSH
46248: LD_INT 2
46250: NEG
46251: PUSH
46252: EMPTY
46253: LIST
46254: LIST
46255: PUSH
46256: LD_INT 2
46258: NEG
46259: PUSH
46260: LD_INT 4
46262: NEG
46263: PUSH
46264: EMPTY
46265: LIST
46266: LIST
46267: PUSH
46268: LD_INT 4
46270: PUSH
46271: LD_INT 0
46273: PUSH
46274: EMPTY
46275: LIST
46276: LIST
46277: PUSH
46278: LD_INT 4
46280: PUSH
46281: LD_INT 1
46283: NEG
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 5
46291: PUSH
46292: LD_INT 0
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_INT 5
46301: PUSH
46302: LD_INT 1
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 4
46311: PUSH
46312: LD_INT 1
46314: PUSH
46315: EMPTY
46316: LIST
46317: LIST
46318: PUSH
46319: LD_INT 3
46321: PUSH
46322: LD_INT 0
46324: PUSH
46325: EMPTY
46326: LIST
46327: LIST
46328: PUSH
46329: LD_INT 3
46331: PUSH
46332: LD_INT 1
46334: NEG
46335: PUSH
46336: EMPTY
46337: LIST
46338: LIST
46339: PUSH
46340: LD_INT 3
46342: PUSH
46343: LD_INT 2
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 5
46353: PUSH
46354: LD_INT 2
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 3
46363: PUSH
46364: LD_INT 3
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 3
46373: PUSH
46374: LD_INT 2
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 4
46383: PUSH
46384: LD_INT 3
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 4
46393: PUSH
46394: LD_INT 4
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 3
46403: PUSH
46404: LD_INT 4
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: LD_INT 2
46413: PUSH
46414: LD_INT 3
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 2
46423: PUSH
46424: LD_INT 2
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 4
46433: PUSH
46434: LD_INT 2
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 2
46443: PUSH
46444: LD_INT 4
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: LD_INT 0
46453: PUSH
46454: LD_INT 4
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 0
46463: PUSH
46464: LD_INT 3
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PUSH
46471: LD_INT 1
46473: PUSH
46474: LD_INT 4
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 1
46483: PUSH
46484: LD_INT 5
46486: PUSH
46487: EMPTY
46488: LIST
46489: LIST
46490: PUSH
46491: LD_INT 0
46493: PUSH
46494: LD_INT 5
46496: PUSH
46497: EMPTY
46498: LIST
46499: LIST
46500: PUSH
46501: LD_INT 1
46503: NEG
46504: PUSH
46505: LD_INT 4
46507: PUSH
46508: EMPTY
46509: LIST
46510: LIST
46511: PUSH
46512: LD_INT 1
46514: NEG
46515: PUSH
46516: LD_INT 3
46518: PUSH
46519: EMPTY
46520: LIST
46521: LIST
46522: PUSH
46523: LD_INT 2
46525: PUSH
46526: LD_INT 5
46528: PUSH
46529: EMPTY
46530: LIST
46531: LIST
46532: PUSH
46533: LD_INT 2
46535: NEG
46536: PUSH
46537: LD_INT 3
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: LIST
46571: LIST
46572: LIST
46573: LIST
46574: LIST
46575: LIST
46576: LIST
46577: LIST
46578: LIST
46579: LIST
46580: LIST
46581: LIST
46582: LIST
46583: LIST
46584: LIST
46585: LIST
46586: LIST
46587: LIST
46588: LIST
46589: LIST
46590: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46591: LD_ADDR_VAR 0 34
46595: PUSH
46596: LD_INT 0
46598: PUSH
46599: LD_INT 4
46601: NEG
46602: PUSH
46603: EMPTY
46604: LIST
46605: LIST
46606: PUSH
46607: LD_INT 0
46609: PUSH
46610: LD_INT 5
46612: NEG
46613: PUSH
46614: EMPTY
46615: LIST
46616: LIST
46617: PUSH
46618: LD_INT 1
46620: PUSH
46621: LD_INT 4
46623: NEG
46624: PUSH
46625: EMPTY
46626: LIST
46627: LIST
46628: PUSH
46629: LD_INT 1
46631: PUSH
46632: LD_INT 3
46634: NEG
46635: PUSH
46636: EMPTY
46637: LIST
46638: LIST
46639: PUSH
46640: LD_INT 0
46642: PUSH
46643: LD_INT 3
46645: NEG
46646: PUSH
46647: EMPTY
46648: LIST
46649: LIST
46650: PUSH
46651: LD_INT 1
46653: NEG
46654: PUSH
46655: LD_INT 4
46657: NEG
46658: PUSH
46659: EMPTY
46660: LIST
46661: LIST
46662: PUSH
46663: LD_INT 1
46665: NEG
46666: PUSH
46667: LD_INT 5
46669: NEG
46670: PUSH
46671: EMPTY
46672: LIST
46673: LIST
46674: PUSH
46675: LD_INT 2
46677: PUSH
46678: LD_INT 3
46680: NEG
46681: PUSH
46682: EMPTY
46683: LIST
46684: LIST
46685: PUSH
46686: LD_INT 2
46688: NEG
46689: PUSH
46690: LD_INT 5
46692: NEG
46693: PUSH
46694: EMPTY
46695: LIST
46696: LIST
46697: PUSH
46698: LD_INT 3
46700: PUSH
46701: LD_INT 0
46703: PUSH
46704: EMPTY
46705: LIST
46706: LIST
46707: PUSH
46708: LD_INT 3
46710: PUSH
46711: LD_INT 1
46713: NEG
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 4
46721: PUSH
46722: LD_INT 0
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 4
46731: PUSH
46732: LD_INT 1
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 3
46741: PUSH
46742: LD_INT 1
46744: PUSH
46745: EMPTY
46746: LIST
46747: LIST
46748: PUSH
46749: LD_INT 2
46751: PUSH
46752: LD_INT 0
46754: PUSH
46755: EMPTY
46756: LIST
46757: LIST
46758: PUSH
46759: LD_INT 2
46761: PUSH
46762: LD_INT 1
46764: NEG
46765: PUSH
46766: EMPTY
46767: LIST
46768: LIST
46769: PUSH
46770: LD_INT 2
46772: PUSH
46773: LD_INT 2
46775: NEG
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 4
46783: PUSH
46784: LD_INT 2
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 4
46793: PUSH
46794: LD_INT 4
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 4
46803: PUSH
46804: LD_INT 3
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 5
46813: PUSH
46814: LD_INT 4
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: LD_INT 5
46823: PUSH
46824: LD_INT 5
46826: PUSH
46827: EMPTY
46828: LIST
46829: LIST
46830: PUSH
46831: LD_INT 4
46833: PUSH
46834: LD_INT 5
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: PUSH
46841: LD_INT 3
46843: PUSH
46844: LD_INT 4
46846: PUSH
46847: EMPTY
46848: LIST
46849: LIST
46850: PUSH
46851: LD_INT 3
46853: PUSH
46854: LD_INT 3
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PUSH
46861: LD_INT 5
46863: PUSH
46864: LD_INT 3
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: LD_INT 3
46873: PUSH
46874: LD_INT 5
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: LD_INT 0
46883: PUSH
46884: LD_INT 3
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 0
46893: PUSH
46894: LD_INT 2
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 1
46903: PUSH
46904: LD_INT 3
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: PUSH
46911: LD_INT 1
46913: PUSH
46914: LD_INT 4
46916: PUSH
46917: EMPTY
46918: LIST
46919: LIST
46920: PUSH
46921: LD_INT 0
46923: PUSH
46924: LD_INT 4
46926: PUSH
46927: EMPTY
46928: LIST
46929: LIST
46930: PUSH
46931: LD_INT 1
46933: NEG
46934: PUSH
46935: LD_INT 3
46937: PUSH
46938: EMPTY
46939: LIST
46940: LIST
46941: PUSH
46942: LD_INT 1
46944: NEG
46945: PUSH
46946: LD_INT 2
46948: PUSH
46949: EMPTY
46950: LIST
46951: LIST
46952: PUSH
46953: LD_INT 2
46955: PUSH
46956: LD_INT 4
46958: PUSH
46959: EMPTY
46960: LIST
46961: LIST
46962: PUSH
46963: LD_INT 2
46965: NEG
46966: PUSH
46967: LD_INT 2
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: PUSH
46974: LD_INT 4
46976: NEG
46977: PUSH
46978: LD_INT 0
46980: PUSH
46981: EMPTY
46982: LIST
46983: LIST
46984: PUSH
46985: LD_INT 4
46987: NEG
46988: PUSH
46989: LD_INT 1
46991: NEG
46992: PUSH
46993: EMPTY
46994: LIST
46995: LIST
46996: PUSH
46997: LD_INT 3
46999: NEG
47000: PUSH
47001: LD_INT 0
47003: PUSH
47004: EMPTY
47005: LIST
47006: LIST
47007: PUSH
47008: LD_INT 3
47010: NEG
47011: PUSH
47012: LD_INT 1
47014: PUSH
47015: EMPTY
47016: LIST
47017: LIST
47018: PUSH
47019: LD_INT 4
47021: NEG
47022: PUSH
47023: LD_INT 1
47025: PUSH
47026: EMPTY
47027: LIST
47028: LIST
47029: PUSH
47030: LD_INT 5
47032: NEG
47033: PUSH
47034: LD_INT 0
47036: PUSH
47037: EMPTY
47038: LIST
47039: LIST
47040: PUSH
47041: LD_INT 5
47043: NEG
47044: PUSH
47045: LD_INT 1
47047: NEG
47048: PUSH
47049: EMPTY
47050: LIST
47051: LIST
47052: PUSH
47053: LD_INT 5
47055: NEG
47056: PUSH
47057: LD_INT 2
47059: NEG
47060: PUSH
47061: EMPTY
47062: LIST
47063: LIST
47064: PUSH
47065: LD_INT 3
47067: NEG
47068: PUSH
47069: LD_INT 2
47071: PUSH
47072: EMPTY
47073: LIST
47074: LIST
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: LIST
47103: LIST
47104: LIST
47105: LIST
47106: LIST
47107: LIST
47108: LIST
47109: LIST
47110: LIST
47111: LIST
47112: LIST
47113: LIST
47114: LIST
47115: LIST
47116: LIST
47117: LIST
47118: LIST
47119: LIST
47120: LIST
47121: LIST
47122: ST_TO_ADDR
// end ; end ;
47123: GO 47126
47125: POP
// case btype of b_depot , b_warehouse :
47126: LD_VAR 0 1
47130: PUSH
47131: LD_INT 0
47133: DOUBLE
47134: EQUAL
47135: IFTRUE 47145
47137: LD_INT 1
47139: DOUBLE
47140: EQUAL
47141: IFTRUE 47145
47143: GO 47346
47145: POP
// case nation of nation_american :
47146: LD_VAR 0 5
47150: PUSH
47151: LD_INT 1
47153: DOUBLE
47154: EQUAL
47155: IFTRUE 47159
47157: GO 47215
47159: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
47160: LD_ADDR_VAR 0 9
47164: PUSH
47165: LD_VAR 0 11
47169: PUSH
47170: LD_VAR 0 12
47174: PUSH
47175: LD_VAR 0 13
47179: PUSH
47180: LD_VAR 0 14
47184: PUSH
47185: LD_VAR 0 15
47189: PUSH
47190: LD_VAR 0 16
47194: PUSH
47195: EMPTY
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: PUSH
47203: LD_VAR 0 4
47207: PUSH
47208: LD_INT 1
47210: PLUS
47211: ARRAY
47212: ST_TO_ADDR
47213: GO 47344
47215: LD_INT 2
47217: DOUBLE
47218: EQUAL
47219: IFTRUE 47223
47221: GO 47279
47223: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
47224: LD_ADDR_VAR 0 9
47228: PUSH
47229: LD_VAR 0 17
47233: PUSH
47234: LD_VAR 0 18
47238: PUSH
47239: LD_VAR 0 19
47243: PUSH
47244: LD_VAR 0 20
47248: PUSH
47249: LD_VAR 0 21
47253: PUSH
47254: LD_VAR 0 22
47258: PUSH
47259: EMPTY
47260: LIST
47261: LIST
47262: LIST
47263: LIST
47264: LIST
47265: LIST
47266: PUSH
47267: LD_VAR 0 4
47271: PUSH
47272: LD_INT 1
47274: PLUS
47275: ARRAY
47276: ST_TO_ADDR
47277: GO 47344
47279: LD_INT 3
47281: DOUBLE
47282: EQUAL
47283: IFTRUE 47287
47285: GO 47343
47287: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47288: LD_ADDR_VAR 0 9
47292: PUSH
47293: LD_VAR 0 23
47297: PUSH
47298: LD_VAR 0 24
47302: PUSH
47303: LD_VAR 0 25
47307: PUSH
47308: LD_VAR 0 26
47312: PUSH
47313: LD_VAR 0 27
47317: PUSH
47318: LD_VAR 0 28
47322: PUSH
47323: EMPTY
47324: LIST
47325: LIST
47326: LIST
47327: LIST
47328: LIST
47329: LIST
47330: PUSH
47331: LD_VAR 0 4
47335: PUSH
47336: LD_INT 1
47338: PLUS
47339: ARRAY
47340: ST_TO_ADDR
47341: GO 47344
47343: POP
47344: GO 47899
47346: LD_INT 2
47348: DOUBLE
47349: EQUAL
47350: IFTRUE 47360
47352: LD_INT 3
47354: DOUBLE
47355: EQUAL
47356: IFTRUE 47360
47358: GO 47416
47360: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47361: LD_ADDR_VAR 0 9
47365: PUSH
47366: LD_VAR 0 29
47370: PUSH
47371: LD_VAR 0 30
47375: PUSH
47376: LD_VAR 0 31
47380: PUSH
47381: LD_VAR 0 32
47385: PUSH
47386: LD_VAR 0 33
47390: PUSH
47391: LD_VAR 0 34
47395: PUSH
47396: EMPTY
47397: LIST
47398: LIST
47399: LIST
47400: LIST
47401: LIST
47402: LIST
47403: PUSH
47404: LD_VAR 0 4
47408: PUSH
47409: LD_INT 1
47411: PLUS
47412: ARRAY
47413: ST_TO_ADDR
47414: GO 47899
47416: LD_INT 16
47418: DOUBLE
47419: EQUAL
47420: IFTRUE 47478
47422: LD_INT 17
47424: DOUBLE
47425: EQUAL
47426: IFTRUE 47478
47428: LD_INT 18
47430: DOUBLE
47431: EQUAL
47432: IFTRUE 47478
47434: LD_INT 19
47436: DOUBLE
47437: EQUAL
47438: IFTRUE 47478
47440: LD_INT 22
47442: DOUBLE
47443: EQUAL
47444: IFTRUE 47478
47446: LD_INT 20
47448: DOUBLE
47449: EQUAL
47450: IFTRUE 47478
47452: LD_INT 21
47454: DOUBLE
47455: EQUAL
47456: IFTRUE 47478
47458: LD_INT 23
47460: DOUBLE
47461: EQUAL
47462: IFTRUE 47478
47464: LD_INT 24
47466: DOUBLE
47467: EQUAL
47468: IFTRUE 47478
47470: LD_INT 25
47472: DOUBLE
47473: EQUAL
47474: IFTRUE 47478
47476: GO 47534
47478: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47479: LD_ADDR_VAR 0 9
47483: PUSH
47484: LD_VAR 0 35
47488: PUSH
47489: LD_VAR 0 36
47493: PUSH
47494: LD_VAR 0 37
47498: PUSH
47499: LD_VAR 0 38
47503: PUSH
47504: LD_VAR 0 39
47508: PUSH
47509: LD_VAR 0 40
47513: PUSH
47514: EMPTY
47515: LIST
47516: LIST
47517: LIST
47518: LIST
47519: LIST
47520: LIST
47521: PUSH
47522: LD_VAR 0 4
47526: PUSH
47527: LD_INT 1
47529: PLUS
47530: ARRAY
47531: ST_TO_ADDR
47532: GO 47899
47534: LD_INT 6
47536: DOUBLE
47537: EQUAL
47538: IFTRUE 47590
47540: LD_INT 7
47542: DOUBLE
47543: EQUAL
47544: IFTRUE 47590
47546: LD_INT 8
47548: DOUBLE
47549: EQUAL
47550: IFTRUE 47590
47552: LD_INT 13
47554: DOUBLE
47555: EQUAL
47556: IFTRUE 47590
47558: LD_INT 12
47560: DOUBLE
47561: EQUAL
47562: IFTRUE 47590
47564: LD_INT 15
47566: DOUBLE
47567: EQUAL
47568: IFTRUE 47590
47570: LD_INT 11
47572: DOUBLE
47573: EQUAL
47574: IFTRUE 47590
47576: LD_INT 14
47578: DOUBLE
47579: EQUAL
47580: IFTRUE 47590
47582: LD_INT 10
47584: DOUBLE
47585: EQUAL
47586: IFTRUE 47590
47588: GO 47646
47590: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47591: LD_ADDR_VAR 0 9
47595: PUSH
47596: LD_VAR 0 41
47600: PUSH
47601: LD_VAR 0 42
47605: PUSH
47606: LD_VAR 0 43
47610: PUSH
47611: LD_VAR 0 44
47615: PUSH
47616: LD_VAR 0 45
47620: PUSH
47621: LD_VAR 0 46
47625: PUSH
47626: EMPTY
47627: LIST
47628: LIST
47629: LIST
47630: LIST
47631: LIST
47632: LIST
47633: PUSH
47634: LD_VAR 0 4
47638: PUSH
47639: LD_INT 1
47641: PLUS
47642: ARRAY
47643: ST_TO_ADDR
47644: GO 47899
47646: LD_INT 36
47648: DOUBLE
47649: EQUAL
47650: IFTRUE 47654
47652: GO 47710
47654: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47655: LD_ADDR_VAR 0 9
47659: PUSH
47660: LD_VAR 0 47
47664: PUSH
47665: LD_VAR 0 48
47669: PUSH
47670: LD_VAR 0 49
47674: PUSH
47675: LD_VAR 0 50
47679: PUSH
47680: LD_VAR 0 51
47684: PUSH
47685: LD_VAR 0 52
47689: PUSH
47690: EMPTY
47691: LIST
47692: LIST
47693: LIST
47694: LIST
47695: LIST
47696: LIST
47697: PUSH
47698: LD_VAR 0 4
47702: PUSH
47703: LD_INT 1
47705: PLUS
47706: ARRAY
47707: ST_TO_ADDR
47708: GO 47899
47710: LD_INT 4
47712: DOUBLE
47713: EQUAL
47714: IFTRUE 47736
47716: LD_INT 5
47718: DOUBLE
47719: EQUAL
47720: IFTRUE 47736
47722: LD_INT 34
47724: DOUBLE
47725: EQUAL
47726: IFTRUE 47736
47728: LD_INT 37
47730: DOUBLE
47731: EQUAL
47732: IFTRUE 47736
47734: GO 47792
47736: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47737: LD_ADDR_VAR 0 9
47741: PUSH
47742: LD_VAR 0 53
47746: PUSH
47747: LD_VAR 0 54
47751: PUSH
47752: LD_VAR 0 55
47756: PUSH
47757: LD_VAR 0 56
47761: PUSH
47762: LD_VAR 0 57
47766: PUSH
47767: LD_VAR 0 58
47771: PUSH
47772: EMPTY
47773: LIST
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: PUSH
47780: LD_VAR 0 4
47784: PUSH
47785: LD_INT 1
47787: PLUS
47788: ARRAY
47789: ST_TO_ADDR
47790: GO 47899
47792: LD_INT 31
47794: DOUBLE
47795: EQUAL
47796: IFTRUE 47842
47798: LD_INT 32
47800: DOUBLE
47801: EQUAL
47802: IFTRUE 47842
47804: LD_INT 33
47806: DOUBLE
47807: EQUAL
47808: IFTRUE 47842
47810: LD_INT 27
47812: DOUBLE
47813: EQUAL
47814: IFTRUE 47842
47816: LD_INT 26
47818: DOUBLE
47819: EQUAL
47820: IFTRUE 47842
47822: LD_INT 28
47824: DOUBLE
47825: EQUAL
47826: IFTRUE 47842
47828: LD_INT 29
47830: DOUBLE
47831: EQUAL
47832: IFTRUE 47842
47834: LD_INT 30
47836: DOUBLE
47837: EQUAL
47838: IFTRUE 47842
47840: GO 47898
47842: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47843: LD_ADDR_VAR 0 9
47847: PUSH
47848: LD_VAR 0 59
47852: PUSH
47853: LD_VAR 0 60
47857: PUSH
47858: LD_VAR 0 61
47862: PUSH
47863: LD_VAR 0 62
47867: PUSH
47868: LD_VAR 0 63
47872: PUSH
47873: LD_VAR 0 64
47877: PUSH
47878: EMPTY
47879: LIST
47880: LIST
47881: LIST
47882: LIST
47883: LIST
47884: LIST
47885: PUSH
47886: LD_VAR 0 4
47890: PUSH
47891: LD_INT 1
47893: PLUS
47894: ARRAY
47895: ST_TO_ADDR
47896: GO 47899
47898: POP
// temp_list2 = [ ] ;
47899: LD_ADDR_VAR 0 10
47903: PUSH
47904: EMPTY
47905: ST_TO_ADDR
// for i in temp_list do
47906: LD_ADDR_VAR 0 8
47910: PUSH
47911: LD_VAR 0 9
47915: PUSH
47916: FOR_IN
47917: IFFALSE 47969
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47919: LD_ADDR_VAR 0 10
47923: PUSH
47924: LD_VAR 0 10
47928: PUSH
47929: LD_VAR 0 8
47933: PUSH
47934: LD_INT 1
47936: ARRAY
47937: PUSH
47938: LD_VAR 0 2
47942: PLUS
47943: PUSH
47944: LD_VAR 0 8
47948: PUSH
47949: LD_INT 2
47951: ARRAY
47952: PUSH
47953: LD_VAR 0 3
47957: PLUS
47958: PUSH
47959: EMPTY
47960: LIST
47961: LIST
47962: PUSH
47963: EMPTY
47964: LIST
47965: ADD
47966: ST_TO_ADDR
47967: GO 47916
47969: POP
47970: POP
// result = temp_list2 ;
47971: LD_ADDR_VAR 0 7
47975: PUSH
47976: LD_VAR 0 10
47980: ST_TO_ADDR
// end ;
47981: LD_VAR 0 7
47985: RET
// export function EnemyInRange ( unit , dist ) ; begin
47986: LD_INT 0
47988: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47989: LD_ADDR_VAR 0 3
47993: PUSH
47994: LD_VAR 0 1
47998: PPUSH
47999: CALL_OW 255
48003: PPUSH
48004: LD_VAR 0 1
48008: PPUSH
48009: CALL_OW 250
48013: PPUSH
48014: LD_VAR 0 1
48018: PPUSH
48019: CALL_OW 251
48023: PPUSH
48024: LD_VAR 0 2
48028: PPUSH
48029: CALL 21359 0 4
48033: PUSH
48034: LD_INT 4
48036: ARRAY
48037: ST_TO_ADDR
// end ;
48038: LD_VAR 0 3
48042: RET
// export function PlayerSeeMe ( unit ) ; begin
48043: LD_INT 0
48045: PPUSH
// result := See ( your_side , unit ) ;
48046: LD_ADDR_VAR 0 2
48050: PUSH
48051: LD_OWVAR 2
48055: PPUSH
48056: LD_VAR 0 1
48060: PPUSH
48061: CALL_OW 292
48065: ST_TO_ADDR
// end ;
48066: LD_VAR 0 2
48070: RET
// export function ReverseDir ( unit ) ; begin
48071: LD_INT 0
48073: PPUSH
// if not unit then
48074: LD_VAR 0 1
48078: NOT
48079: IFFALSE 48083
// exit ;
48081: GO 48106
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48083: LD_ADDR_VAR 0 2
48087: PUSH
48088: LD_VAR 0 1
48092: PPUSH
48093: CALL_OW 254
48097: PUSH
48098: LD_INT 3
48100: PLUS
48101: PUSH
48102: LD_INT 6
48104: MOD
48105: ST_TO_ADDR
// end ;
48106: LD_VAR 0 2
48110: RET
// export function ReverseArray ( array ) ; var i ; begin
48111: LD_INT 0
48113: PPUSH
48114: PPUSH
// if not array then
48115: LD_VAR 0 1
48119: NOT
48120: IFFALSE 48124
// exit ;
48122: GO 48179
// result := [ ] ;
48124: LD_ADDR_VAR 0 2
48128: PUSH
48129: EMPTY
48130: ST_TO_ADDR
// for i := array downto 1 do
48131: LD_ADDR_VAR 0 3
48135: PUSH
48136: DOUBLE
48137: LD_VAR 0 1
48141: INC
48142: ST_TO_ADDR
48143: LD_INT 1
48145: PUSH
48146: FOR_DOWNTO
48147: IFFALSE 48177
// result := Join ( result , array [ i ] ) ;
48149: LD_ADDR_VAR 0 2
48153: PUSH
48154: LD_VAR 0 2
48158: PPUSH
48159: LD_VAR 0 1
48163: PUSH
48164: LD_VAR 0 3
48168: ARRAY
48169: PPUSH
48170: CALL 52822 0 2
48174: ST_TO_ADDR
48175: GO 48146
48177: POP
48178: POP
// end ;
48179: LD_VAR 0 2
48183: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
48184: LD_INT 0
48186: PPUSH
48187: PPUSH
48188: PPUSH
48189: PPUSH
48190: PPUSH
48191: PPUSH
// if not unit or not hexes then
48192: LD_VAR 0 1
48196: NOT
48197: PUSH
48198: LD_VAR 0 2
48202: NOT
48203: OR
48204: IFFALSE 48208
// exit ;
48206: GO 48331
// dist := 9999 ;
48208: LD_ADDR_VAR 0 5
48212: PUSH
48213: LD_INT 9999
48215: ST_TO_ADDR
// for i = 1 to hexes do
48216: LD_ADDR_VAR 0 4
48220: PUSH
48221: DOUBLE
48222: LD_INT 1
48224: DEC
48225: ST_TO_ADDR
48226: LD_VAR 0 2
48230: PUSH
48231: FOR_TO
48232: IFFALSE 48319
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48234: LD_ADDR_VAR 0 6
48238: PUSH
48239: LD_VAR 0 1
48243: PPUSH
48244: LD_VAR 0 2
48248: PUSH
48249: LD_VAR 0 4
48253: ARRAY
48254: PUSH
48255: LD_INT 1
48257: ARRAY
48258: PPUSH
48259: LD_VAR 0 2
48263: PUSH
48264: LD_VAR 0 4
48268: ARRAY
48269: PUSH
48270: LD_INT 2
48272: ARRAY
48273: PPUSH
48274: CALL_OW 297
48278: ST_TO_ADDR
// if tdist < dist then
48279: LD_VAR 0 6
48283: PUSH
48284: LD_VAR 0 5
48288: LESS
48289: IFFALSE 48317
// begin hex := hexes [ i ] ;
48291: LD_ADDR_VAR 0 8
48295: PUSH
48296: LD_VAR 0 2
48300: PUSH
48301: LD_VAR 0 4
48305: ARRAY
48306: ST_TO_ADDR
// dist := tdist ;
48307: LD_ADDR_VAR 0 5
48311: PUSH
48312: LD_VAR 0 6
48316: ST_TO_ADDR
// end ; end ;
48317: GO 48231
48319: POP
48320: POP
// result := hex ;
48321: LD_ADDR_VAR 0 3
48325: PUSH
48326: LD_VAR 0 8
48330: ST_TO_ADDR
// end ;
48331: LD_VAR 0 3
48335: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48336: LD_INT 0
48338: PPUSH
48339: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48340: LD_VAR 0 1
48344: NOT
48345: PUSH
48346: LD_VAR 0 1
48350: PUSH
48351: LD_INT 21
48353: PUSH
48354: LD_INT 2
48356: PUSH
48357: EMPTY
48358: LIST
48359: LIST
48360: PUSH
48361: LD_INT 23
48363: PUSH
48364: LD_INT 2
48366: PUSH
48367: EMPTY
48368: LIST
48369: LIST
48370: PUSH
48371: EMPTY
48372: LIST
48373: LIST
48374: PPUSH
48375: CALL_OW 69
48379: IN
48380: NOT
48381: OR
48382: IFFALSE 48386
// exit ;
48384: GO 48433
// for i = 1 to 3 do
48386: LD_ADDR_VAR 0 3
48390: PUSH
48391: DOUBLE
48392: LD_INT 1
48394: DEC
48395: ST_TO_ADDR
48396: LD_INT 3
48398: PUSH
48399: FOR_TO
48400: IFFALSE 48431
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48402: LD_VAR 0 1
48406: PPUSH
48407: CALL_OW 250
48411: PPUSH
48412: LD_VAR 0 1
48416: PPUSH
48417: CALL_OW 251
48421: PPUSH
48422: LD_INT 1
48424: PPUSH
48425: CALL_OW 453
48429: GO 48399
48431: POP
48432: POP
// end ;
48433: LD_VAR 0 2
48437: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48438: LD_INT 0
48440: PPUSH
48441: PPUSH
48442: PPUSH
48443: PPUSH
48444: PPUSH
48445: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48446: LD_VAR 0 1
48450: NOT
48451: PUSH
48452: LD_VAR 0 2
48456: NOT
48457: OR
48458: PUSH
48459: LD_VAR 0 1
48463: PPUSH
48464: CALL_OW 314
48468: OR
48469: IFFALSE 48473
// exit ;
48471: GO 48940
// if GetLives ( i ) < 250 then
48473: LD_VAR 0 4
48477: PPUSH
48478: CALL_OW 256
48482: PUSH
48483: LD_INT 250
48485: LESS
48486: IFFALSE 48499
// begin ComAutodestruct ( i ) ;
48488: LD_VAR 0 4
48492: PPUSH
48493: CALL 48336 0 1
// exit ;
48497: GO 48940
// end ; x := GetX ( enemy_unit ) ;
48499: LD_ADDR_VAR 0 7
48503: PUSH
48504: LD_VAR 0 2
48508: PPUSH
48509: CALL_OW 250
48513: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48514: LD_ADDR_VAR 0 8
48518: PUSH
48519: LD_VAR 0 2
48523: PPUSH
48524: CALL_OW 251
48528: ST_TO_ADDR
// if not x or not y then
48529: LD_VAR 0 7
48533: NOT
48534: PUSH
48535: LD_VAR 0 8
48539: NOT
48540: OR
48541: IFFALSE 48545
// exit ;
48543: GO 48940
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48545: LD_ADDR_VAR 0 6
48549: PUSH
48550: LD_VAR 0 7
48554: PPUSH
48555: LD_INT 0
48557: PPUSH
48558: LD_INT 4
48560: PPUSH
48561: CALL_OW 272
48565: PUSH
48566: LD_VAR 0 8
48570: PPUSH
48571: LD_INT 0
48573: PPUSH
48574: LD_INT 4
48576: PPUSH
48577: CALL_OW 273
48581: PUSH
48582: EMPTY
48583: LIST
48584: LIST
48585: PUSH
48586: LD_VAR 0 7
48590: PPUSH
48591: LD_INT 1
48593: PPUSH
48594: LD_INT 4
48596: PPUSH
48597: CALL_OW 272
48601: PUSH
48602: LD_VAR 0 8
48606: PPUSH
48607: LD_INT 1
48609: PPUSH
48610: LD_INT 4
48612: PPUSH
48613: CALL_OW 273
48617: PUSH
48618: EMPTY
48619: LIST
48620: LIST
48621: PUSH
48622: LD_VAR 0 7
48626: PPUSH
48627: LD_INT 2
48629: PPUSH
48630: LD_INT 4
48632: PPUSH
48633: CALL_OW 272
48637: PUSH
48638: LD_VAR 0 8
48642: PPUSH
48643: LD_INT 2
48645: PPUSH
48646: LD_INT 4
48648: PPUSH
48649: CALL_OW 273
48653: PUSH
48654: EMPTY
48655: LIST
48656: LIST
48657: PUSH
48658: LD_VAR 0 7
48662: PPUSH
48663: LD_INT 3
48665: PPUSH
48666: LD_INT 4
48668: PPUSH
48669: CALL_OW 272
48673: PUSH
48674: LD_VAR 0 8
48678: PPUSH
48679: LD_INT 3
48681: PPUSH
48682: LD_INT 4
48684: PPUSH
48685: CALL_OW 273
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: PUSH
48694: LD_VAR 0 7
48698: PPUSH
48699: LD_INT 4
48701: PPUSH
48702: LD_INT 4
48704: PPUSH
48705: CALL_OW 272
48709: PUSH
48710: LD_VAR 0 8
48714: PPUSH
48715: LD_INT 4
48717: PPUSH
48718: LD_INT 4
48720: PPUSH
48721: CALL_OW 273
48725: PUSH
48726: EMPTY
48727: LIST
48728: LIST
48729: PUSH
48730: LD_VAR 0 7
48734: PPUSH
48735: LD_INT 5
48737: PPUSH
48738: LD_INT 4
48740: PPUSH
48741: CALL_OW 272
48745: PUSH
48746: LD_VAR 0 8
48750: PPUSH
48751: LD_INT 5
48753: PPUSH
48754: LD_INT 4
48756: PPUSH
48757: CALL_OW 273
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: PUSH
48766: EMPTY
48767: LIST
48768: LIST
48769: LIST
48770: LIST
48771: LIST
48772: LIST
48773: ST_TO_ADDR
// for i = tmp downto 1 do
48774: LD_ADDR_VAR 0 4
48778: PUSH
48779: DOUBLE
48780: LD_VAR 0 6
48784: INC
48785: ST_TO_ADDR
48786: LD_INT 1
48788: PUSH
48789: FOR_DOWNTO
48790: IFFALSE 48891
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48792: LD_VAR 0 6
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: PUSH
48803: LD_INT 1
48805: ARRAY
48806: PPUSH
48807: LD_VAR 0 6
48811: PUSH
48812: LD_VAR 0 4
48816: ARRAY
48817: PUSH
48818: LD_INT 2
48820: ARRAY
48821: PPUSH
48822: CALL_OW 488
48826: NOT
48827: PUSH
48828: LD_VAR 0 6
48832: PUSH
48833: LD_VAR 0 4
48837: ARRAY
48838: PUSH
48839: LD_INT 1
48841: ARRAY
48842: PPUSH
48843: LD_VAR 0 6
48847: PUSH
48848: LD_VAR 0 4
48852: ARRAY
48853: PUSH
48854: LD_INT 2
48856: ARRAY
48857: PPUSH
48858: CALL_OW 428
48862: PUSH
48863: LD_INT 0
48865: NONEQUAL
48866: OR
48867: IFFALSE 48889
// tmp := Delete ( tmp , i ) ;
48869: LD_ADDR_VAR 0 6
48873: PUSH
48874: LD_VAR 0 6
48878: PPUSH
48879: LD_VAR 0 4
48883: PPUSH
48884: CALL_OW 3
48888: ST_TO_ADDR
48889: GO 48789
48891: POP
48892: POP
// j := GetClosestHex ( unit , tmp ) ;
48893: LD_ADDR_VAR 0 5
48897: PUSH
48898: LD_VAR 0 1
48902: PPUSH
48903: LD_VAR 0 6
48907: PPUSH
48908: CALL 48184 0 2
48912: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48913: LD_VAR 0 1
48917: PPUSH
48918: LD_VAR 0 5
48922: PUSH
48923: LD_INT 1
48925: ARRAY
48926: PPUSH
48927: LD_VAR 0 5
48931: PUSH
48932: LD_INT 2
48934: ARRAY
48935: PPUSH
48936: CALL_OW 111
// end ;
48940: LD_VAR 0 3
48944: RET
// export function PrepareApemanSoldier ( ) ; begin
48945: LD_INT 0
48947: PPUSH
// uc_nation := 0 ;
48948: LD_ADDR_OWVAR 21
48952: PUSH
48953: LD_INT 0
48955: ST_TO_ADDR
// hc_sex := sex_male ;
48956: LD_ADDR_OWVAR 27
48960: PUSH
48961: LD_INT 1
48963: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48964: LD_ADDR_OWVAR 28
48968: PUSH
48969: LD_INT 15
48971: ST_TO_ADDR
// hc_gallery :=  ;
48972: LD_ADDR_OWVAR 33
48976: PUSH
48977: LD_STRING 
48979: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48980: LD_ADDR_OWVAR 31
48984: PUSH
48985: LD_INT 0
48987: PPUSH
48988: LD_INT 3
48990: PPUSH
48991: CALL_OW 12
48995: PUSH
48996: LD_INT 0
48998: PPUSH
48999: LD_INT 3
49001: PPUSH
49002: CALL_OW 12
49006: PUSH
49007: LD_INT 0
49009: PUSH
49010: LD_INT 0
49012: PUSH
49013: EMPTY
49014: LIST
49015: LIST
49016: LIST
49017: LIST
49018: ST_TO_ADDR
// end ;
49019: LD_VAR 0 1
49023: RET
// export function PrepareApemanEngineer ( ) ; begin
49024: LD_INT 0
49026: PPUSH
// uc_nation := 0 ;
49027: LD_ADDR_OWVAR 21
49031: PUSH
49032: LD_INT 0
49034: ST_TO_ADDR
// hc_sex := sex_male ;
49035: LD_ADDR_OWVAR 27
49039: PUSH
49040: LD_INT 1
49042: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
49043: LD_ADDR_OWVAR 28
49047: PUSH
49048: LD_INT 16
49050: ST_TO_ADDR
// hc_gallery :=  ;
49051: LD_ADDR_OWVAR 33
49055: PUSH
49056: LD_STRING 
49058: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49059: LD_ADDR_OWVAR 31
49063: PUSH
49064: LD_INT 0
49066: PPUSH
49067: LD_INT 3
49069: PPUSH
49070: CALL_OW 12
49074: PUSH
49075: LD_INT 0
49077: PPUSH
49078: LD_INT 3
49080: PPUSH
49081: CALL_OW 12
49085: PUSH
49086: LD_INT 0
49088: PUSH
49089: LD_INT 0
49091: PUSH
49092: EMPTY
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: ST_TO_ADDR
// end ;
49098: LD_VAR 0 1
49102: RET
// export function PrepareApeman ( agressivity ) ; begin
49103: LD_INT 0
49105: PPUSH
// uc_side := 0 ;
49106: LD_ADDR_OWVAR 20
49110: PUSH
49111: LD_INT 0
49113: ST_TO_ADDR
// uc_nation := 0 ;
49114: LD_ADDR_OWVAR 21
49118: PUSH
49119: LD_INT 0
49121: ST_TO_ADDR
// hc_sex := sex_male ;
49122: LD_ADDR_OWVAR 27
49126: PUSH
49127: LD_INT 1
49129: ST_TO_ADDR
// hc_class := class_apeman ;
49130: LD_ADDR_OWVAR 28
49134: PUSH
49135: LD_INT 12
49137: ST_TO_ADDR
// hc_gallery :=  ;
49138: LD_ADDR_OWVAR 33
49142: PUSH
49143: LD_STRING 
49145: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49146: LD_ADDR_OWVAR 35
49150: PUSH
49151: LD_VAR 0 1
49155: NEG
49156: PPUSH
49157: LD_VAR 0 1
49161: PPUSH
49162: CALL_OW 12
49166: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49167: LD_ADDR_OWVAR 31
49171: PUSH
49172: LD_INT 0
49174: PPUSH
49175: LD_INT 3
49177: PPUSH
49178: CALL_OW 12
49182: PUSH
49183: LD_INT 0
49185: PPUSH
49186: LD_INT 3
49188: PPUSH
49189: CALL_OW 12
49193: PUSH
49194: LD_INT 0
49196: PUSH
49197: LD_INT 0
49199: PUSH
49200: EMPTY
49201: LIST
49202: LIST
49203: LIST
49204: LIST
49205: ST_TO_ADDR
// end ;
49206: LD_VAR 0 2
49210: RET
// export function PrepareTiger ( agressivity ) ; begin
49211: LD_INT 0
49213: PPUSH
// uc_side := 0 ;
49214: LD_ADDR_OWVAR 20
49218: PUSH
49219: LD_INT 0
49221: ST_TO_ADDR
// uc_nation := 0 ;
49222: LD_ADDR_OWVAR 21
49226: PUSH
49227: LD_INT 0
49229: ST_TO_ADDR
// hc_class := class_tiger ;
49230: LD_ADDR_OWVAR 28
49234: PUSH
49235: LD_INT 14
49237: ST_TO_ADDR
// hc_gallery :=  ;
49238: LD_ADDR_OWVAR 33
49242: PUSH
49243: LD_STRING 
49245: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49246: LD_ADDR_OWVAR 35
49250: PUSH
49251: LD_VAR 0 1
49255: NEG
49256: PPUSH
49257: LD_VAR 0 1
49261: PPUSH
49262: CALL_OW 12
49266: ST_TO_ADDR
// end ;
49267: LD_VAR 0 2
49271: RET
// export function PrepareEnchidna ( ) ; begin
49272: LD_INT 0
49274: PPUSH
// uc_side := 0 ;
49275: LD_ADDR_OWVAR 20
49279: PUSH
49280: LD_INT 0
49282: ST_TO_ADDR
// uc_nation := 0 ;
49283: LD_ADDR_OWVAR 21
49287: PUSH
49288: LD_INT 0
49290: ST_TO_ADDR
// hc_class := class_baggie ;
49291: LD_ADDR_OWVAR 28
49295: PUSH
49296: LD_INT 13
49298: ST_TO_ADDR
// hc_gallery :=  ;
49299: LD_ADDR_OWVAR 33
49303: PUSH
49304: LD_STRING 
49306: ST_TO_ADDR
// end ;
49307: LD_VAR 0 1
49311: RET
// export function PrepareFrog ( ) ; begin
49312: LD_INT 0
49314: PPUSH
// uc_side := 0 ;
49315: LD_ADDR_OWVAR 20
49319: PUSH
49320: LD_INT 0
49322: ST_TO_ADDR
// uc_nation := 0 ;
49323: LD_ADDR_OWVAR 21
49327: PUSH
49328: LD_INT 0
49330: ST_TO_ADDR
// hc_class := class_frog ;
49331: LD_ADDR_OWVAR 28
49335: PUSH
49336: LD_INT 19
49338: ST_TO_ADDR
// hc_gallery :=  ;
49339: LD_ADDR_OWVAR 33
49343: PUSH
49344: LD_STRING 
49346: ST_TO_ADDR
// end ;
49347: LD_VAR 0 1
49351: RET
// export function PrepareFish ( ) ; begin
49352: LD_INT 0
49354: PPUSH
// uc_side := 0 ;
49355: LD_ADDR_OWVAR 20
49359: PUSH
49360: LD_INT 0
49362: ST_TO_ADDR
// uc_nation := 0 ;
49363: LD_ADDR_OWVAR 21
49367: PUSH
49368: LD_INT 0
49370: ST_TO_ADDR
// hc_class := class_fish ;
49371: LD_ADDR_OWVAR 28
49375: PUSH
49376: LD_INT 20
49378: ST_TO_ADDR
// hc_gallery :=  ;
49379: LD_ADDR_OWVAR 33
49383: PUSH
49384: LD_STRING 
49386: ST_TO_ADDR
// end ;
49387: LD_VAR 0 1
49391: RET
// export function PrepareBird ( ) ; begin
49392: LD_INT 0
49394: PPUSH
// uc_side := 0 ;
49395: LD_ADDR_OWVAR 20
49399: PUSH
49400: LD_INT 0
49402: ST_TO_ADDR
// uc_nation := 0 ;
49403: LD_ADDR_OWVAR 21
49407: PUSH
49408: LD_INT 0
49410: ST_TO_ADDR
// hc_class := class_phororhacos ;
49411: LD_ADDR_OWVAR 28
49415: PUSH
49416: LD_INT 18
49418: ST_TO_ADDR
// hc_gallery :=  ;
49419: LD_ADDR_OWVAR 33
49423: PUSH
49424: LD_STRING 
49426: ST_TO_ADDR
// end ;
49427: LD_VAR 0 1
49431: RET
// export function PrepareHorse ( ) ; begin
49432: LD_INT 0
49434: PPUSH
// uc_side := 0 ;
49435: LD_ADDR_OWVAR 20
49439: PUSH
49440: LD_INT 0
49442: ST_TO_ADDR
// uc_nation := 0 ;
49443: LD_ADDR_OWVAR 21
49447: PUSH
49448: LD_INT 0
49450: ST_TO_ADDR
// hc_class := class_horse ;
49451: LD_ADDR_OWVAR 28
49455: PUSH
49456: LD_INT 21
49458: ST_TO_ADDR
// hc_gallery :=  ;
49459: LD_ADDR_OWVAR 33
49463: PUSH
49464: LD_STRING 
49466: ST_TO_ADDR
// end ;
49467: LD_VAR 0 1
49471: RET
// export function PrepareMastodont ( ) ; begin
49472: LD_INT 0
49474: PPUSH
// uc_side := 0 ;
49475: LD_ADDR_OWVAR 20
49479: PUSH
49480: LD_INT 0
49482: ST_TO_ADDR
// uc_nation := 0 ;
49483: LD_ADDR_OWVAR 21
49487: PUSH
49488: LD_INT 0
49490: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49491: LD_ADDR_OWVAR 37
49495: PUSH
49496: LD_INT 31
49498: ST_TO_ADDR
// vc_control := control_rider ;
49499: LD_ADDR_OWVAR 38
49503: PUSH
49504: LD_INT 4
49506: ST_TO_ADDR
// end ;
49507: LD_VAR 0 1
49511: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49512: LD_INT 0
49514: PPUSH
49515: PPUSH
49516: PPUSH
// uc_side = 0 ;
49517: LD_ADDR_OWVAR 20
49521: PUSH
49522: LD_INT 0
49524: ST_TO_ADDR
// uc_nation = 0 ;
49525: LD_ADDR_OWVAR 21
49529: PUSH
49530: LD_INT 0
49532: ST_TO_ADDR
// InitHc_All ( ) ;
49533: CALL_OW 584
// InitVc ;
49537: CALL_OW 20
// if mastodonts then
49541: LD_VAR 0 6
49545: IFFALSE 49612
// for i = 1 to mastodonts do
49547: LD_ADDR_VAR 0 11
49551: PUSH
49552: DOUBLE
49553: LD_INT 1
49555: DEC
49556: ST_TO_ADDR
49557: LD_VAR 0 6
49561: PUSH
49562: FOR_TO
49563: IFFALSE 49610
// begin vc_chassis := 31 ;
49565: LD_ADDR_OWVAR 37
49569: PUSH
49570: LD_INT 31
49572: ST_TO_ADDR
// vc_control := control_rider ;
49573: LD_ADDR_OWVAR 38
49577: PUSH
49578: LD_INT 4
49580: ST_TO_ADDR
// animal := CreateVehicle ;
49581: LD_ADDR_VAR 0 12
49585: PUSH
49586: CALL_OW 45
49590: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49591: LD_VAR 0 12
49595: PPUSH
49596: LD_VAR 0 8
49600: PPUSH
49601: LD_INT 0
49603: PPUSH
49604: CALL 51740 0 3
// end ;
49608: GO 49562
49610: POP
49611: POP
// if horses then
49612: LD_VAR 0 5
49616: IFFALSE 49683
// for i = 1 to horses do
49618: LD_ADDR_VAR 0 11
49622: PUSH
49623: DOUBLE
49624: LD_INT 1
49626: DEC
49627: ST_TO_ADDR
49628: LD_VAR 0 5
49632: PUSH
49633: FOR_TO
49634: IFFALSE 49681
// begin hc_class := 21 ;
49636: LD_ADDR_OWVAR 28
49640: PUSH
49641: LD_INT 21
49643: ST_TO_ADDR
// hc_gallery :=  ;
49644: LD_ADDR_OWVAR 33
49648: PUSH
49649: LD_STRING 
49651: ST_TO_ADDR
// animal := CreateHuman ;
49652: LD_ADDR_VAR 0 12
49656: PUSH
49657: CALL_OW 44
49661: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49662: LD_VAR 0 12
49666: PPUSH
49667: LD_VAR 0 8
49671: PPUSH
49672: LD_INT 0
49674: PPUSH
49675: CALL 51740 0 3
// end ;
49679: GO 49633
49681: POP
49682: POP
// if birds then
49683: LD_VAR 0 1
49687: IFFALSE 49754
// for i = 1 to birds do
49689: LD_ADDR_VAR 0 11
49693: PUSH
49694: DOUBLE
49695: LD_INT 1
49697: DEC
49698: ST_TO_ADDR
49699: LD_VAR 0 1
49703: PUSH
49704: FOR_TO
49705: IFFALSE 49752
// begin hc_class := 18 ;
49707: LD_ADDR_OWVAR 28
49711: PUSH
49712: LD_INT 18
49714: ST_TO_ADDR
// hc_gallery =  ;
49715: LD_ADDR_OWVAR 33
49719: PUSH
49720: LD_STRING 
49722: ST_TO_ADDR
// animal := CreateHuman ;
49723: LD_ADDR_VAR 0 12
49727: PUSH
49728: CALL_OW 44
49732: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49733: LD_VAR 0 12
49737: PPUSH
49738: LD_VAR 0 8
49742: PPUSH
49743: LD_INT 0
49745: PPUSH
49746: CALL 51740 0 3
// end ;
49750: GO 49704
49752: POP
49753: POP
// if tigers then
49754: LD_VAR 0 2
49758: IFFALSE 49842
// for i = 1 to tigers do
49760: LD_ADDR_VAR 0 11
49764: PUSH
49765: DOUBLE
49766: LD_INT 1
49768: DEC
49769: ST_TO_ADDR
49770: LD_VAR 0 2
49774: PUSH
49775: FOR_TO
49776: IFFALSE 49840
// begin hc_class = class_tiger ;
49778: LD_ADDR_OWVAR 28
49782: PUSH
49783: LD_INT 14
49785: ST_TO_ADDR
// hc_gallery =  ;
49786: LD_ADDR_OWVAR 33
49790: PUSH
49791: LD_STRING 
49793: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49794: LD_ADDR_OWVAR 35
49798: PUSH
49799: LD_INT 7
49801: NEG
49802: PPUSH
49803: LD_INT 7
49805: PPUSH
49806: CALL_OW 12
49810: ST_TO_ADDR
// animal := CreateHuman ;
49811: LD_ADDR_VAR 0 12
49815: PUSH
49816: CALL_OW 44
49820: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49821: LD_VAR 0 12
49825: PPUSH
49826: LD_VAR 0 8
49830: PPUSH
49831: LD_INT 0
49833: PPUSH
49834: CALL 51740 0 3
// end ;
49838: GO 49775
49840: POP
49841: POP
// if apemans then
49842: LD_VAR 0 3
49846: IFFALSE 49969
// for i = 1 to apemans do
49848: LD_ADDR_VAR 0 11
49852: PUSH
49853: DOUBLE
49854: LD_INT 1
49856: DEC
49857: ST_TO_ADDR
49858: LD_VAR 0 3
49862: PUSH
49863: FOR_TO
49864: IFFALSE 49967
// begin hc_class = class_apeman ;
49866: LD_ADDR_OWVAR 28
49870: PUSH
49871: LD_INT 12
49873: ST_TO_ADDR
// hc_gallery =  ;
49874: LD_ADDR_OWVAR 33
49878: PUSH
49879: LD_STRING 
49881: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49882: LD_ADDR_OWVAR 35
49886: PUSH
49887: LD_INT 2
49889: NEG
49890: PPUSH
49891: LD_INT 2
49893: PPUSH
49894: CALL_OW 12
49898: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49899: LD_ADDR_OWVAR 31
49903: PUSH
49904: LD_INT 1
49906: PPUSH
49907: LD_INT 3
49909: PPUSH
49910: CALL_OW 12
49914: PUSH
49915: LD_INT 1
49917: PPUSH
49918: LD_INT 3
49920: PPUSH
49921: CALL_OW 12
49925: PUSH
49926: LD_INT 0
49928: PUSH
49929: LD_INT 0
49931: PUSH
49932: EMPTY
49933: LIST
49934: LIST
49935: LIST
49936: LIST
49937: ST_TO_ADDR
// animal := CreateHuman ;
49938: LD_ADDR_VAR 0 12
49942: PUSH
49943: CALL_OW 44
49947: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49948: LD_VAR 0 12
49952: PPUSH
49953: LD_VAR 0 8
49957: PPUSH
49958: LD_INT 0
49960: PPUSH
49961: CALL 51740 0 3
// end ;
49965: GO 49863
49967: POP
49968: POP
// if enchidnas then
49969: LD_VAR 0 4
49973: IFFALSE 50040
// for i = 1 to enchidnas do
49975: LD_ADDR_VAR 0 11
49979: PUSH
49980: DOUBLE
49981: LD_INT 1
49983: DEC
49984: ST_TO_ADDR
49985: LD_VAR 0 4
49989: PUSH
49990: FOR_TO
49991: IFFALSE 50038
// begin hc_class = 13 ;
49993: LD_ADDR_OWVAR 28
49997: PUSH
49998: LD_INT 13
50000: ST_TO_ADDR
// hc_gallery =  ;
50001: LD_ADDR_OWVAR 33
50005: PUSH
50006: LD_STRING 
50008: ST_TO_ADDR
// animal := CreateHuman ;
50009: LD_ADDR_VAR 0 12
50013: PUSH
50014: CALL_OW 44
50018: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
50019: LD_VAR 0 12
50023: PPUSH
50024: LD_VAR 0 8
50028: PPUSH
50029: LD_INT 0
50031: PPUSH
50032: CALL 51740 0 3
// end ;
50036: GO 49990
50038: POP
50039: POP
// if fishes then
50040: LD_VAR 0 7
50044: IFFALSE 50111
// for i = 1 to fishes do
50046: LD_ADDR_VAR 0 11
50050: PUSH
50051: DOUBLE
50052: LD_INT 1
50054: DEC
50055: ST_TO_ADDR
50056: LD_VAR 0 7
50060: PUSH
50061: FOR_TO
50062: IFFALSE 50109
// begin hc_class = 20 ;
50064: LD_ADDR_OWVAR 28
50068: PUSH
50069: LD_INT 20
50071: ST_TO_ADDR
// hc_gallery =  ;
50072: LD_ADDR_OWVAR 33
50076: PUSH
50077: LD_STRING 
50079: ST_TO_ADDR
// animal := CreateHuman ;
50080: LD_ADDR_VAR 0 12
50084: PUSH
50085: CALL_OW 44
50089: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50090: LD_VAR 0 12
50094: PPUSH
50095: LD_VAR 0 9
50099: PPUSH
50100: LD_INT 0
50102: PPUSH
50103: CALL 51740 0 3
// end ;
50107: GO 50061
50109: POP
50110: POP
// end ;
50111: LD_VAR 0 10
50115: RET
// export function WantHeal ( sci , unit ) ; begin
50116: LD_INT 0
50118: PPUSH
// if GetTaskList ( sci ) > 0 then
50119: LD_VAR 0 1
50123: PPUSH
50124: CALL_OW 437
50128: PUSH
50129: LD_INT 0
50131: GREATER
50132: IFFALSE 50202
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
50134: LD_VAR 0 1
50138: PPUSH
50139: CALL_OW 437
50143: PUSH
50144: LD_INT 1
50146: ARRAY
50147: PUSH
50148: LD_INT 1
50150: ARRAY
50151: PUSH
50152: LD_STRING l
50154: EQUAL
50155: PUSH
50156: LD_VAR 0 1
50160: PPUSH
50161: CALL_OW 437
50165: PUSH
50166: LD_INT 1
50168: ARRAY
50169: PUSH
50170: LD_INT 4
50172: ARRAY
50173: PUSH
50174: LD_VAR 0 2
50178: EQUAL
50179: AND
50180: IFFALSE 50192
// result := true else
50182: LD_ADDR_VAR 0 3
50186: PUSH
50187: LD_INT 1
50189: ST_TO_ADDR
50190: GO 50200
// result := false ;
50192: LD_ADDR_VAR 0 3
50196: PUSH
50197: LD_INT 0
50199: ST_TO_ADDR
// end else
50200: GO 50210
// result := false ;
50202: LD_ADDR_VAR 0 3
50206: PUSH
50207: LD_INT 0
50209: ST_TO_ADDR
// end ;
50210: LD_VAR 0 3
50214: RET
// export function HealTarget ( sci ) ; begin
50215: LD_INT 0
50217: PPUSH
// if not sci then
50218: LD_VAR 0 1
50222: NOT
50223: IFFALSE 50227
// exit ;
50225: GO 50292
// result := 0 ;
50227: LD_ADDR_VAR 0 2
50231: PUSH
50232: LD_INT 0
50234: ST_TO_ADDR
// if GetTaskList ( sci ) then
50235: LD_VAR 0 1
50239: PPUSH
50240: CALL_OW 437
50244: IFFALSE 50292
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50246: LD_VAR 0 1
50250: PPUSH
50251: CALL_OW 437
50255: PUSH
50256: LD_INT 1
50258: ARRAY
50259: PUSH
50260: LD_INT 1
50262: ARRAY
50263: PUSH
50264: LD_STRING l
50266: EQUAL
50267: IFFALSE 50292
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50269: LD_ADDR_VAR 0 2
50273: PUSH
50274: LD_VAR 0 1
50278: PPUSH
50279: CALL_OW 437
50283: PUSH
50284: LD_INT 1
50286: ARRAY
50287: PUSH
50288: LD_INT 4
50290: ARRAY
50291: ST_TO_ADDR
// end ;
50292: LD_VAR 0 2
50296: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50297: LD_INT 0
50299: PPUSH
50300: PPUSH
50301: PPUSH
50302: PPUSH
// if not base_units then
50303: LD_VAR 0 1
50307: NOT
50308: IFFALSE 50312
// exit ;
50310: GO 50399
// result := false ;
50312: LD_ADDR_VAR 0 2
50316: PUSH
50317: LD_INT 0
50319: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50320: LD_ADDR_VAR 0 5
50324: PUSH
50325: LD_VAR 0 1
50329: PPUSH
50330: LD_INT 21
50332: PUSH
50333: LD_INT 3
50335: PUSH
50336: EMPTY
50337: LIST
50338: LIST
50339: PPUSH
50340: CALL_OW 72
50344: ST_TO_ADDR
// if not tmp then
50345: LD_VAR 0 5
50349: NOT
50350: IFFALSE 50354
// exit ;
50352: GO 50399
// for i in tmp do
50354: LD_ADDR_VAR 0 3
50358: PUSH
50359: LD_VAR 0 5
50363: PUSH
50364: FOR_IN
50365: IFFALSE 50397
// begin result := EnemyInRange ( i , 22 ) ;
50367: LD_ADDR_VAR 0 2
50371: PUSH
50372: LD_VAR 0 3
50376: PPUSH
50377: LD_INT 22
50379: PPUSH
50380: CALL 47986 0 2
50384: ST_TO_ADDR
// if result then
50385: LD_VAR 0 2
50389: IFFALSE 50395
// exit ;
50391: POP
50392: POP
50393: GO 50399
// end ;
50395: GO 50364
50397: POP
50398: POP
// end ;
50399: LD_VAR 0 2
50403: RET
// export function FilterByTag ( units , tag ) ; begin
50404: LD_INT 0
50406: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
50407: LD_ADDR_VAR 0 3
50411: PUSH
50412: LD_VAR 0 1
50416: PPUSH
50417: LD_INT 120
50419: PUSH
50420: LD_VAR 0 2
50424: PUSH
50425: EMPTY
50426: LIST
50427: LIST
50428: PPUSH
50429: CALL_OW 72
50433: ST_TO_ADDR
// end ;
50434: LD_VAR 0 3
50438: RET
// export function IsDriver ( un ) ; begin
50439: LD_INT 0
50441: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
50442: LD_ADDR_VAR 0 2
50446: PUSH
50447: LD_VAR 0 1
50451: PUSH
50452: LD_INT 55
50454: PUSH
50455: EMPTY
50456: LIST
50457: PPUSH
50458: CALL_OW 69
50462: IN
50463: ST_TO_ADDR
// end ;
50464: LD_VAR 0 2
50468: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50469: LD_INT 0
50471: PPUSH
50472: PPUSH
// list := [ ] ;
50473: LD_ADDR_VAR 0 5
50477: PUSH
50478: EMPTY
50479: ST_TO_ADDR
// case d of 0 :
50480: LD_VAR 0 3
50484: PUSH
50485: LD_INT 0
50487: DOUBLE
50488: EQUAL
50489: IFTRUE 50493
50491: GO 50626
50493: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50494: LD_ADDR_VAR 0 5
50498: PUSH
50499: LD_VAR 0 1
50503: PUSH
50504: LD_INT 4
50506: MINUS
50507: PUSH
50508: LD_VAR 0 2
50512: PUSH
50513: LD_INT 4
50515: MINUS
50516: PUSH
50517: LD_INT 2
50519: PUSH
50520: EMPTY
50521: LIST
50522: LIST
50523: LIST
50524: PUSH
50525: LD_VAR 0 1
50529: PUSH
50530: LD_INT 3
50532: MINUS
50533: PUSH
50534: LD_VAR 0 2
50538: PUSH
50539: LD_INT 1
50541: PUSH
50542: EMPTY
50543: LIST
50544: LIST
50545: LIST
50546: PUSH
50547: LD_VAR 0 1
50551: PUSH
50552: LD_INT 4
50554: PLUS
50555: PUSH
50556: LD_VAR 0 2
50560: PUSH
50561: LD_INT 4
50563: PUSH
50564: EMPTY
50565: LIST
50566: LIST
50567: LIST
50568: PUSH
50569: LD_VAR 0 1
50573: PUSH
50574: LD_INT 3
50576: PLUS
50577: PUSH
50578: LD_VAR 0 2
50582: PUSH
50583: LD_INT 3
50585: PLUS
50586: PUSH
50587: LD_INT 5
50589: PUSH
50590: EMPTY
50591: LIST
50592: LIST
50593: LIST
50594: PUSH
50595: LD_VAR 0 1
50599: PUSH
50600: LD_VAR 0 2
50604: PUSH
50605: LD_INT 4
50607: PLUS
50608: PUSH
50609: LD_INT 0
50611: PUSH
50612: EMPTY
50613: LIST
50614: LIST
50615: LIST
50616: PUSH
50617: EMPTY
50618: LIST
50619: LIST
50620: LIST
50621: LIST
50622: LIST
50623: ST_TO_ADDR
// end ; 1 :
50624: GO 51324
50626: LD_INT 1
50628: DOUBLE
50629: EQUAL
50630: IFTRUE 50634
50632: GO 50767
50634: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50635: LD_ADDR_VAR 0 5
50639: PUSH
50640: LD_VAR 0 1
50644: PUSH
50645: LD_VAR 0 2
50649: PUSH
50650: LD_INT 4
50652: MINUS
50653: PUSH
50654: LD_INT 3
50656: PUSH
50657: EMPTY
50658: LIST
50659: LIST
50660: LIST
50661: PUSH
50662: LD_VAR 0 1
50666: PUSH
50667: LD_INT 3
50669: MINUS
50670: PUSH
50671: LD_VAR 0 2
50675: PUSH
50676: LD_INT 3
50678: MINUS
50679: PUSH
50680: LD_INT 2
50682: PUSH
50683: EMPTY
50684: LIST
50685: LIST
50686: LIST
50687: PUSH
50688: LD_VAR 0 1
50692: PUSH
50693: LD_INT 4
50695: MINUS
50696: PUSH
50697: LD_VAR 0 2
50701: PUSH
50702: LD_INT 1
50704: PUSH
50705: EMPTY
50706: LIST
50707: LIST
50708: LIST
50709: PUSH
50710: LD_VAR 0 1
50714: PUSH
50715: LD_VAR 0 2
50719: PUSH
50720: LD_INT 3
50722: PLUS
50723: PUSH
50724: LD_INT 0
50726: PUSH
50727: EMPTY
50728: LIST
50729: LIST
50730: LIST
50731: PUSH
50732: LD_VAR 0 1
50736: PUSH
50737: LD_INT 4
50739: PLUS
50740: PUSH
50741: LD_VAR 0 2
50745: PUSH
50746: LD_INT 4
50748: PLUS
50749: PUSH
50750: LD_INT 5
50752: PUSH
50753: EMPTY
50754: LIST
50755: LIST
50756: LIST
50757: PUSH
50758: EMPTY
50759: LIST
50760: LIST
50761: LIST
50762: LIST
50763: LIST
50764: ST_TO_ADDR
// end ; 2 :
50765: GO 51324
50767: LD_INT 2
50769: DOUBLE
50770: EQUAL
50771: IFTRUE 50775
50773: GO 50904
50775: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50776: LD_ADDR_VAR 0 5
50780: PUSH
50781: LD_VAR 0 1
50785: PUSH
50786: LD_VAR 0 2
50790: PUSH
50791: LD_INT 3
50793: MINUS
50794: PUSH
50795: LD_INT 3
50797: PUSH
50798: EMPTY
50799: LIST
50800: LIST
50801: LIST
50802: PUSH
50803: LD_VAR 0 1
50807: PUSH
50808: LD_INT 4
50810: PLUS
50811: PUSH
50812: LD_VAR 0 2
50816: PUSH
50817: LD_INT 4
50819: PUSH
50820: EMPTY
50821: LIST
50822: LIST
50823: LIST
50824: PUSH
50825: LD_VAR 0 1
50829: PUSH
50830: LD_VAR 0 2
50834: PUSH
50835: LD_INT 4
50837: PLUS
50838: PUSH
50839: LD_INT 0
50841: PUSH
50842: EMPTY
50843: LIST
50844: LIST
50845: LIST
50846: PUSH
50847: LD_VAR 0 1
50851: PUSH
50852: LD_INT 3
50854: MINUS
50855: PUSH
50856: LD_VAR 0 2
50860: PUSH
50861: LD_INT 1
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: LIST
50868: PUSH
50869: LD_VAR 0 1
50873: PUSH
50874: LD_INT 4
50876: MINUS
50877: PUSH
50878: LD_VAR 0 2
50882: PUSH
50883: LD_INT 4
50885: MINUS
50886: PUSH
50887: LD_INT 2
50889: PUSH
50890: EMPTY
50891: LIST
50892: LIST
50893: LIST
50894: PUSH
50895: EMPTY
50896: LIST
50897: LIST
50898: LIST
50899: LIST
50900: LIST
50901: ST_TO_ADDR
// end ; 3 :
50902: GO 51324
50904: LD_INT 3
50906: DOUBLE
50907: EQUAL
50908: IFTRUE 50912
50910: GO 51045
50912: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50913: LD_ADDR_VAR 0 5
50917: PUSH
50918: LD_VAR 0 1
50922: PUSH
50923: LD_INT 3
50925: PLUS
50926: PUSH
50927: LD_VAR 0 2
50931: PUSH
50932: LD_INT 4
50934: PUSH
50935: EMPTY
50936: LIST
50937: LIST
50938: LIST
50939: PUSH
50940: LD_VAR 0 1
50944: PUSH
50945: LD_INT 4
50947: PLUS
50948: PUSH
50949: LD_VAR 0 2
50953: PUSH
50954: LD_INT 4
50956: PLUS
50957: PUSH
50958: LD_INT 5
50960: PUSH
50961: EMPTY
50962: LIST
50963: LIST
50964: LIST
50965: PUSH
50966: LD_VAR 0 1
50970: PUSH
50971: LD_INT 4
50973: MINUS
50974: PUSH
50975: LD_VAR 0 2
50979: PUSH
50980: LD_INT 1
50982: PUSH
50983: EMPTY
50984: LIST
50985: LIST
50986: LIST
50987: PUSH
50988: LD_VAR 0 1
50992: PUSH
50993: LD_VAR 0 2
50997: PUSH
50998: LD_INT 4
51000: MINUS
51001: PUSH
51002: LD_INT 3
51004: PUSH
51005: EMPTY
51006: LIST
51007: LIST
51008: LIST
51009: PUSH
51010: LD_VAR 0 1
51014: PUSH
51015: LD_INT 3
51017: MINUS
51018: PUSH
51019: LD_VAR 0 2
51023: PUSH
51024: LD_INT 3
51026: MINUS
51027: PUSH
51028: LD_INT 2
51030: PUSH
51031: EMPTY
51032: LIST
51033: LIST
51034: LIST
51035: PUSH
51036: EMPTY
51037: LIST
51038: LIST
51039: LIST
51040: LIST
51041: LIST
51042: ST_TO_ADDR
// end ; 4 :
51043: GO 51324
51045: LD_INT 4
51047: DOUBLE
51048: EQUAL
51049: IFTRUE 51053
51051: GO 51186
51053: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51054: LD_ADDR_VAR 0 5
51058: PUSH
51059: LD_VAR 0 1
51063: PUSH
51064: LD_VAR 0 2
51068: PUSH
51069: LD_INT 4
51071: PLUS
51072: PUSH
51073: LD_INT 0
51075: PUSH
51076: EMPTY
51077: LIST
51078: LIST
51079: LIST
51080: PUSH
51081: LD_VAR 0 1
51085: PUSH
51086: LD_INT 3
51088: PLUS
51089: PUSH
51090: LD_VAR 0 2
51094: PUSH
51095: LD_INT 3
51097: PLUS
51098: PUSH
51099: LD_INT 5
51101: PUSH
51102: EMPTY
51103: LIST
51104: LIST
51105: LIST
51106: PUSH
51107: LD_VAR 0 1
51111: PUSH
51112: LD_INT 4
51114: PLUS
51115: PUSH
51116: LD_VAR 0 2
51120: PUSH
51121: LD_INT 4
51123: PUSH
51124: EMPTY
51125: LIST
51126: LIST
51127: LIST
51128: PUSH
51129: LD_VAR 0 1
51133: PUSH
51134: LD_VAR 0 2
51138: PUSH
51139: LD_INT 3
51141: MINUS
51142: PUSH
51143: LD_INT 3
51145: PUSH
51146: EMPTY
51147: LIST
51148: LIST
51149: LIST
51150: PUSH
51151: LD_VAR 0 1
51155: PUSH
51156: LD_INT 4
51158: MINUS
51159: PUSH
51160: LD_VAR 0 2
51164: PUSH
51165: LD_INT 4
51167: MINUS
51168: PUSH
51169: LD_INT 2
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: LIST
51176: PUSH
51177: EMPTY
51178: LIST
51179: LIST
51180: LIST
51181: LIST
51182: LIST
51183: ST_TO_ADDR
// end ; 5 :
51184: GO 51324
51186: LD_INT 5
51188: DOUBLE
51189: EQUAL
51190: IFTRUE 51194
51192: GO 51323
51194: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51195: LD_ADDR_VAR 0 5
51199: PUSH
51200: LD_VAR 0 1
51204: PUSH
51205: LD_INT 4
51207: MINUS
51208: PUSH
51209: LD_VAR 0 2
51213: PUSH
51214: LD_INT 1
51216: PUSH
51217: EMPTY
51218: LIST
51219: LIST
51220: LIST
51221: PUSH
51222: LD_VAR 0 1
51226: PUSH
51227: LD_VAR 0 2
51231: PUSH
51232: LD_INT 4
51234: MINUS
51235: PUSH
51236: LD_INT 3
51238: PUSH
51239: EMPTY
51240: LIST
51241: LIST
51242: LIST
51243: PUSH
51244: LD_VAR 0 1
51248: PUSH
51249: LD_INT 4
51251: PLUS
51252: PUSH
51253: LD_VAR 0 2
51257: PUSH
51258: LD_INT 4
51260: PLUS
51261: PUSH
51262: LD_INT 5
51264: PUSH
51265: EMPTY
51266: LIST
51267: LIST
51268: LIST
51269: PUSH
51270: LD_VAR 0 1
51274: PUSH
51275: LD_INT 3
51277: PLUS
51278: PUSH
51279: LD_VAR 0 2
51283: PUSH
51284: LD_INT 4
51286: PUSH
51287: EMPTY
51288: LIST
51289: LIST
51290: LIST
51291: PUSH
51292: LD_VAR 0 1
51296: PUSH
51297: LD_VAR 0 2
51301: PUSH
51302: LD_INT 3
51304: PLUS
51305: PUSH
51306: LD_INT 0
51308: PUSH
51309: EMPTY
51310: LIST
51311: LIST
51312: LIST
51313: PUSH
51314: EMPTY
51315: LIST
51316: LIST
51317: LIST
51318: LIST
51319: LIST
51320: ST_TO_ADDR
// end ; end ;
51321: GO 51324
51323: POP
// result := list ;
51324: LD_ADDR_VAR 0 4
51328: PUSH
51329: LD_VAR 0 5
51333: ST_TO_ADDR
// end ;
51334: LD_VAR 0 4
51338: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
51339: LD_INT 0
51341: PPUSH
51342: PPUSH
51343: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
51344: LD_VAR 0 1
51348: NOT
51349: PUSH
51350: LD_VAR 0 2
51354: PUSH
51355: LD_INT 1
51357: PUSH
51358: LD_INT 2
51360: PUSH
51361: LD_INT 3
51363: PUSH
51364: LD_INT 4
51366: PUSH
51367: EMPTY
51368: LIST
51369: LIST
51370: LIST
51371: LIST
51372: IN
51373: NOT
51374: OR
51375: IFFALSE 51379
// exit ;
51377: GO 51462
// tmp := [ ] ;
51379: LD_ADDR_VAR 0 5
51383: PUSH
51384: EMPTY
51385: ST_TO_ADDR
// for i in units do
51386: LD_ADDR_VAR 0 4
51390: PUSH
51391: LD_VAR 0 1
51395: PUSH
51396: FOR_IN
51397: IFFALSE 51431
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
51399: LD_ADDR_VAR 0 5
51403: PUSH
51404: LD_VAR 0 5
51408: PPUSH
51409: LD_VAR 0 4
51413: PPUSH
51414: LD_VAR 0 2
51418: PPUSH
51419: CALL_OW 259
51423: PPUSH
51424: CALL 52822 0 2
51428: ST_TO_ADDR
51429: GO 51396
51431: POP
51432: POP
// if not tmp then
51433: LD_VAR 0 5
51437: NOT
51438: IFFALSE 51442
// exit ;
51440: GO 51462
// result := SortListByListDesc ( units , tmp ) ;
51442: LD_ADDR_VAR 0 3
51446: PUSH
51447: LD_VAR 0 1
51451: PPUSH
51452: LD_VAR 0 5
51456: PPUSH
51457: CALL_OW 77
51461: ST_TO_ADDR
// end ;
51462: LD_VAR 0 3
51466: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51467: LD_INT 0
51469: PPUSH
51470: PPUSH
51471: PPUSH
// result := false ;
51472: LD_ADDR_VAR 0 3
51476: PUSH
51477: LD_INT 0
51479: ST_TO_ADDR
// if not building then
51480: LD_VAR 0 2
51484: NOT
51485: IFFALSE 51489
// exit ;
51487: GO 51627
// x := GetX ( building ) ;
51489: LD_ADDR_VAR 0 4
51493: PUSH
51494: LD_VAR 0 2
51498: PPUSH
51499: CALL_OW 250
51503: ST_TO_ADDR
// y := GetY ( building ) ;
51504: LD_ADDR_VAR 0 5
51508: PUSH
51509: LD_VAR 0 2
51513: PPUSH
51514: CALL_OW 251
51518: ST_TO_ADDR
// if not x or not y then
51519: LD_VAR 0 4
51523: NOT
51524: PUSH
51525: LD_VAR 0 5
51529: NOT
51530: OR
51531: IFFALSE 51535
// exit ;
51533: GO 51627
// if GetTaskList ( unit ) then
51535: LD_VAR 0 1
51539: PPUSH
51540: CALL_OW 437
51544: IFFALSE 51627
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51546: LD_STRING e
51548: PUSH
51549: LD_VAR 0 1
51553: PPUSH
51554: CALL_OW 437
51558: PUSH
51559: LD_INT 1
51561: ARRAY
51562: PUSH
51563: LD_INT 1
51565: ARRAY
51566: EQUAL
51567: PUSH
51568: LD_VAR 0 4
51572: PUSH
51573: LD_VAR 0 1
51577: PPUSH
51578: CALL_OW 437
51582: PUSH
51583: LD_INT 1
51585: ARRAY
51586: PUSH
51587: LD_INT 2
51589: ARRAY
51590: EQUAL
51591: AND
51592: PUSH
51593: LD_VAR 0 5
51597: PUSH
51598: LD_VAR 0 1
51602: PPUSH
51603: CALL_OW 437
51607: PUSH
51608: LD_INT 1
51610: ARRAY
51611: PUSH
51612: LD_INT 3
51614: ARRAY
51615: EQUAL
51616: AND
51617: IFFALSE 51627
// result := true end ;
51619: LD_ADDR_VAR 0 3
51623: PUSH
51624: LD_INT 1
51626: ST_TO_ADDR
// end ;
51627: LD_VAR 0 3
51631: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51632: LD_INT 0
51634: PPUSH
// result := false ;
51635: LD_ADDR_VAR 0 4
51639: PUSH
51640: LD_INT 0
51642: ST_TO_ADDR
// if GetTaskList ( unit ) then
51643: LD_VAR 0 1
51647: PPUSH
51648: CALL_OW 437
51652: IFFALSE 51735
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51654: LD_STRING M
51656: PUSH
51657: LD_VAR 0 1
51661: PPUSH
51662: CALL_OW 437
51666: PUSH
51667: LD_INT 1
51669: ARRAY
51670: PUSH
51671: LD_INT 1
51673: ARRAY
51674: EQUAL
51675: PUSH
51676: LD_VAR 0 2
51680: PUSH
51681: LD_VAR 0 1
51685: PPUSH
51686: CALL_OW 437
51690: PUSH
51691: LD_INT 1
51693: ARRAY
51694: PUSH
51695: LD_INT 2
51697: ARRAY
51698: EQUAL
51699: AND
51700: PUSH
51701: LD_VAR 0 3
51705: PUSH
51706: LD_VAR 0 1
51710: PPUSH
51711: CALL_OW 437
51715: PUSH
51716: LD_INT 1
51718: ARRAY
51719: PUSH
51720: LD_INT 3
51722: ARRAY
51723: EQUAL
51724: AND
51725: IFFALSE 51735
// result := true ;
51727: LD_ADDR_VAR 0 4
51731: PUSH
51732: LD_INT 1
51734: ST_TO_ADDR
// end ; end ;
51735: LD_VAR 0 4
51739: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51740: LD_INT 0
51742: PPUSH
51743: PPUSH
51744: PPUSH
51745: PPUSH
// if not unit or not area then
51746: LD_VAR 0 1
51750: NOT
51751: PUSH
51752: LD_VAR 0 2
51756: NOT
51757: OR
51758: IFFALSE 51762
// exit ;
51760: GO 51925
// tmp := AreaToList ( area , i ) ;
51762: LD_ADDR_VAR 0 6
51766: PUSH
51767: LD_VAR 0 2
51771: PPUSH
51772: LD_VAR 0 5
51776: PPUSH
51777: CALL_OW 517
51781: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51782: LD_ADDR_VAR 0 5
51786: PUSH
51787: DOUBLE
51788: LD_INT 1
51790: DEC
51791: ST_TO_ADDR
51792: LD_VAR 0 6
51796: PUSH
51797: LD_INT 1
51799: ARRAY
51800: PUSH
51801: FOR_TO
51802: IFFALSE 51923
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51804: LD_ADDR_VAR 0 7
51808: PUSH
51809: LD_VAR 0 6
51813: PUSH
51814: LD_INT 1
51816: ARRAY
51817: PUSH
51818: LD_VAR 0 5
51822: ARRAY
51823: PUSH
51824: LD_VAR 0 6
51828: PUSH
51829: LD_INT 2
51831: ARRAY
51832: PUSH
51833: LD_VAR 0 5
51837: ARRAY
51838: PUSH
51839: EMPTY
51840: LIST
51841: LIST
51842: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
51843: LD_INT 92
51845: PUSH
51846: LD_VAR 0 7
51850: PUSH
51851: LD_INT 1
51853: ARRAY
51854: PUSH
51855: LD_VAR 0 7
51859: PUSH
51860: LD_INT 2
51862: ARRAY
51863: PUSH
51864: LD_INT 3
51866: PUSH
51867: EMPTY
51868: LIST
51869: LIST
51870: LIST
51871: LIST
51872: PPUSH
51873: CALL_OW 69
51877: PUSH
51878: LD_INT 0
51880: EQUAL
51881: IFFALSE 51921
// begin PlaceUnitArea ( unit , area , mode ) ;
51883: LD_VAR 0 1
51887: PPUSH
51888: LD_VAR 0 2
51892: PPUSH
51893: LD_VAR 0 3
51897: PPUSH
51898: CALL_OW 49
// result := IsPlaced ( unit ) ;
51902: LD_ADDR_VAR 0 4
51906: PUSH
51907: LD_VAR 0 1
51911: PPUSH
51912: CALL_OW 305
51916: ST_TO_ADDR
// exit ;
51917: POP
51918: POP
51919: GO 51925
// end ; end ;
51921: GO 51801
51923: POP
51924: POP
// end ;
51925: LD_VAR 0 4
51929: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51930: LD_INT 0
51932: PPUSH
51933: PPUSH
51934: PPUSH
// if not side or side > 8 then
51935: LD_VAR 0 1
51939: NOT
51940: PUSH
51941: LD_VAR 0 1
51945: PUSH
51946: LD_INT 8
51948: GREATER
51949: OR
51950: IFFALSE 51954
// exit ;
51952: GO 52141
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51954: LD_ADDR_VAR 0 4
51958: PUSH
51959: LD_INT 22
51961: PUSH
51962: LD_VAR 0 1
51966: PUSH
51967: EMPTY
51968: LIST
51969: LIST
51970: PUSH
51971: LD_INT 21
51973: PUSH
51974: LD_INT 3
51976: PUSH
51977: EMPTY
51978: LIST
51979: LIST
51980: PUSH
51981: EMPTY
51982: LIST
51983: LIST
51984: PPUSH
51985: CALL_OW 69
51989: ST_TO_ADDR
// if not tmp then
51990: LD_VAR 0 4
51994: NOT
51995: IFFALSE 51999
// exit ;
51997: GO 52141
// enable_addtolog := true ;
51999: LD_ADDR_OWVAR 81
52003: PUSH
52004: LD_INT 1
52006: ST_TO_ADDR
// AddToLog ( [ ) ;
52007: LD_STRING [
52009: PPUSH
52010: CALL_OW 561
// for i in tmp do
52014: LD_ADDR_VAR 0 3
52018: PUSH
52019: LD_VAR 0 4
52023: PUSH
52024: FOR_IN
52025: IFFALSE 52132
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52027: LD_STRING [
52029: PUSH
52030: LD_VAR 0 3
52034: PPUSH
52035: CALL_OW 266
52039: STR
52040: PUSH
52041: LD_STRING , 
52043: STR
52044: PUSH
52045: LD_VAR 0 3
52049: PPUSH
52050: CALL_OW 250
52054: STR
52055: PUSH
52056: LD_STRING , 
52058: STR
52059: PUSH
52060: LD_VAR 0 3
52064: PPUSH
52065: CALL_OW 251
52069: STR
52070: PUSH
52071: LD_STRING , 
52073: STR
52074: PUSH
52075: LD_VAR 0 3
52079: PPUSH
52080: CALL_OW 254
52084: STR
52085: PUSH
52086: LD_STRING , 
52088: STR
52089: PUSH
52090: LD_VAR 0 3
52094: PPUSH
52095: LD_INT 1
52097: PPUSH
52098: CALL_OW 268
52102: STR
52103: PUSH
52104: LD_STRING , 
52106: STR
52107: PUSH
52108: LD_VAR 0 3
52112: PPUSH
52113: LD_INT 2
52115: PPUSH
52116: CALL_OW 268
52120: STR
52121: PUSH
52122: LD_STRING ],
52124: STR
52125: PPUSH
52126: CALL_OW 561
// end ;
52130: GO 52024
52132: POP
52133: POP
// AddToLog ( ]; ) ;
52134: LD_STRING ];
52136: PPUSH
52137: CALL_OW 561
// end ;
52141: LD_VAR 0 2
52145: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52146: LD_INT 0
52148: PPUSH
52149: PPUSH
52150: PPUSH
52151: PPUSH
52152: PPUSH
// if not area or not rate or not max then
52153: LD_VAR 0 1
52157: NOT
52158: PUSH
52159: LD_VAR 0 2
52163: NOT
52164: OR
52165: PUSH
52166: LD_VAR 0 4
52170: NOT
52171: OR
52172: IFFALSE 52176
// exit ;
52174: GO 52365
// while 1 do
52176: LD_INT 1
52178: IFFALSE 52365
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52180: LD_ADDR_VAR 0 9
52184: PUSH
52185: LD_VAR 0 1
52189: PPUSH
52190: LD_INT 1
52192: PPUSH
52193: CALL_OW 287
52197: PUSH
52198: LD_INT 10
52200: MUL
52201: ST_TO_ADDR
// r := rate / 10 ;
52202: LD_ADDR_VAR 0 7
52206: PUSH
52207: LD_VAR 0 2
52211: PUSH
52212: LD_INT 10
52214: DIVREAL
52215: ST_TO_ADDR
// time := 1 1$00 ;
52216: LD_ADDR_VAR 0 8
52220: PUSH
52221: LD_INT 2100
52223: ST_TO_ADDR
// if amount < min then
52224: LD_VAR 0 9
52228: PUSH
52229: LD_VAR 0 3
52233: LESS
52234: IFFALSE 52252
// r := r * 2 else
52236: LD_ADDR_VAR 0 7
52240: PUSH
52241: LD_VAR 0 7
52245: PUSH
52246: LD_INT 2
52248: MUL
52249: ST_TO_ADDR
52250: GO 52278
// if amount > max then
52252: LD_VAR 0 9
52256: PUSH
52257: LD_VAR 0 4
52261: GREATER
52262: IFFALSE 52278
// r := r / 2 ;
52264: LD_ADDR_VAR 0 7
52268: PUSH
52269: LD_VAR 0 7
52273: PUSH
52274: LD_INT 2
52276: DIVREAL
52277: ST_TO_ADDR
// time := time / r ;
52278: LD_ADDR_VAR 0 8
52282: PUSH
52283: LD_VAR 0 8
52287: PUSH
52288: LD_VAR 0 7
52292: DIVREAL
52293: ST_TO_ADDR
// if time < 0 then
52294: LD_VAR 0 8
52298: PUSH
52299: LD_INT 0
52301: LESS
52302: IFFALSE 52319
// time := time * - 1 ;
52304: LD_ADDR_VAR 0 8
52308: PUSH
52309: LD_VAR 0 8
52313: PUSH
52314: LD_INT 1
52316: NEG
52317: MUL
52318: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
52319: LD_VAR 0 8
52323: PUSH
52324: LD_INT 35
52326: PPUSH
52327: LD_INT 875
52329: PPUSH
52330: CALL_OW 12
52334: PLUS
52335: PPUSH
52336: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
52340: LD_INT 1
52342: PPUSH
52343: LD_INT 5
52345: PPUSH
52346: CALL_OW 12
52350: PPUSH
52351: LD_VAR 0 1
52355: PPUSH
52356: LD_INT 1
52358: PPUSH
52359: CALL_OW 55
// end ;
52363: GO 52176
// end ;
52365: LD_VAR 0 5
52369: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
52370: LD_INT 0
52372: PPUSH
52373: PPUSH
52374: PPUSH
52375: PPUSH
52376: PPUSH
52377: PPUSH
52378: PPUSH
52379: PPUSH
// if not turrets or not factories then
52380: LD_VAR 0 1
52384: NOT
52385: PUSH
52386: LD_VAR 0 2
52390: NOT
52391: OR
52392: IFFALSE 52396
// exit ;
52394: GO 52703
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
52396: LD_ADDR_VAR 0 10
52400: PUSH
52401: LD_INT 5
52403: PUSH
52404: LD_INT 6
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: PUSH
52411: LD_INT 2
52413: PUSH
52414: LD_INT 4
52416: PUSH
52417: EMPTY
52418: LIST
52419: LIST
52420: PUSH
52421: LD_INT 3
52423: PUSH
52424: LD_INT 5
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: PUSH
52431: EMPTY
52432: LIST
52433: LIST
52434: LIST
52435: PUSH
52436: LD_INT 24
52438: PUSH
52439: LD_INT 25
52441: PUSH
52442: EMPTY
52443: LIST
52444: LIST
52445: PUSH
52446: LD_INT 23
52448: PUSH
52449: LD_INT 27
52451: PUSH
52452: EMPTY
52453: LIST
52454: LIST
52455: PUSH
52456: EMPTY
52457: LIST
52458: LIST
52459: PUSH
52460: LD_INT 42
52462: PUSH
52463: LD_INT 43
52465: PUSH
52466: EMPTY
52467: LIST
52468: LIST
52469: PUSH
52470: LD_INT 44
52472: PUSH
52473: LD_INT 46
52475: PUSH
52476: EMPTY
52477: LIST
52478: LIST
52479: PUSH
52480: LD_INT 45
52482: PUSH
52483: LD_INT 47
52485: PUSH
52486: EMPTY
52487: LIST
52488: LIST
52489: PUSH
52490: EMPTY
52491: LIST
52492: LIST
52493: LIST
52494: PUSH
52495: EMPTY
52496: LIST
52497: LIST
52498: LIST
52499: ST_TO_ADDR
// result := [ ] ;
52500: LD_ADDR_VAR 0 3
52504: PUSH
52505: EMPTY
52506: ST_TO_ADDR
// for i in turrets do
52507: LD_ADDR_VAR 0 4
52511: PUSH
52512: LD_VAR 0 1
52516: PUSH
52517: FOR_IN
52518: IFFALSE 52701
// begin nat := GetNation ( i ) ;
52520: LD_ADDR_VAR 0 7
52524: PUSH
52525: LD_VAR 0 4
52529: PPUSH
52530: CALL_OW 248
52534: ST_TO_ADDR
// weapon := 0 ;
52535: LD_ADDR_VAR 0 8
52539: PUSH
52540: LD_INT 0
52542: ST_TO_ADDR
// if not nat then
52543: LD_VAR 0 7
52547: NOT
52548: IFFALSE 52552
// continue ;
52550: GO 52517
// for j in list [ nat ] do
52552: LD_ADDR_VAR 0 5
52556: PUSH
52557: LD_VAR 0 10
52561: PUSH
52562: LD_VAR 0 7
52566: ARRAY
52567: PUSH
52568: FOR_IN
52569: IFFALSE 52610
// if GetBWeapon ( i ) = j [ 1 ] then
52571: LD_VAR 0 4
52575: PPUSH
52576: CALL_OW 269
52580: PUSH
52581: LD_VAR 0 5
52585: PUSH
52586: LD_INT 1
52588: ARRAY
52589: EQUAL
52590: IFFALSE 52608
// begin weapon := j [ 2 ] ;
52592: LD_ADDR_VAR 0 8
52596: PUSH
52597: LD_VAR 0 5
52601: PUSH
52602: LD_INT 2
52604: ARRAY
52605: ST_TO_ADDR
// break ;
52606: GO 52610
// end ;
52608: GO 52568
52610: POP
52611: POP
// if not weapon then
52612: LD_VAR 0 8
52616: NOT
52617: IFFALSE 52621
// continue ;
52619: GO 52517
// for k in factories do
52621: LD_ADDR_VAR 0 6
52625: PUSH
52626: LD_VAR 0 2
52630: PUSH
52631: FOR_IN
52632: IFFALSE 52697
// begin weapons := AvailableWeaponList ( k ) ;
52634: LD_ADDR_VAR 0 9
52638: PUSH
52639: LD_VAR 0 6
52643: PPUSH
52644: CALL_OW 478
52648: ST_TO_ADDR
// if not weapons then
52649: LD_VAR 0 9
52653: NOT
52654: IFFALSE 52658
// continue ;
52656: GO 52631
// if weapon in weapons then
52658: LD_VAR 0 8
52662: PUSH
52663: LD_VAR 0 9
52667: IN
52668: IFFALSE 52695
// begin result := [ i , weapon ] ;
52670: LD_ADDR_VAR 0 3
52674: PUSH
52675: LD_VAR 0 4
52679: PUSH
52680: LD_VAR 0 8
52684: PUSH
52685: EMPTY
52686: LIST
52687: LIST
52688: ST_TO_ADDR
// exit ;
52689: POP
52690: POP
52691: POP
52692: POP
52693: GO 52703
// end ; end ;
52695: GO 52631
52697: POP
52698: POP
// end ;
52699: GO 52517
52701: POP
52702: POP
// end ;
52703: LD_VAR 0 3
52707: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52708: LD_INT 0
52710: PPUSH
// if not side or side > 8 then
52711: LD_VAR 0 3
52715: NOT
52716: PUSH
52717: LD_VAR 0 3
52721: PUSH
52722: LD_INT 8
52724: GREATER
52725: OR
52726: IFFALSE 52730
// exit ;
52728: GO 52789
// if not range then
52730: LD_VAR 0 4
52734: NOT
52735: IFFALSE 52746
// range := - 12 ;
52737: LD_ADDR_VAR 0 4
52741: PUSH
52742: LD_INT 12
52744: NEG
52745: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52746: LD_VAR 0 1
52750: PPUSH
52751: LD_VAR 0 2
52755: PPUSH
52756: LD_VAR 0 3
52760: PPUSH
52761: LD_VAR 0 4
52765: PPUSH
52766: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52770: LD_VAR 0 1
52774: PPUSH
52775: LD_VAR 0 2
52779: PPUSH
52780: LD_VAR 0 3
52784: PPUSH
52785: CALL_OW 331
// end ;
52789: LD_VAR 0 5
52793: RET
// export function Video ( mode ) ; begin
52794: LD_INT 0
52796: PPUSH
// ingame_video = mode ;
52797: LD_ADDR_OWVAR 52
52801: PUSH
52802: LD_VAR 0 1
52806: ST_TO_ADDR
// interface_hidden = mode ;
52807: LD_ADDR_OWVAR 54
52811: PUSH
52812: LD_VAR 0 1
52816: ST_TO_ADDR
// end ;
52817: LD_VAR 0 2
52821: RET
// export function Join ( array , element ) ; begin
52822: LD_INT 0
52824: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52825: LD_ADDR_VAR 0 3
52829: PUSH
52830: LD_VAR 0 1
52834: PPUSH
52835: LD_VAR 0 1
52839: PUSH
52840: LD_INT 1
52842: PLUS
52843: PPUSH
52844: LD_VAR 0 2
52848: PPUSH
52849: CALL_OW 1
52853: ST_TO_ADDR
// end ;
52854: LD_VAR 0 3
52858: RET
// export function JoinUnion ( array , element ) ; begin
52859: LD_INT 0
52861: PPUSH
// result := array union element ;
52862: LD_ADDR_VAR 0 3
52866: PUSH
52867: LD_VAR 0 1
52871: PUSH
52872: LD_VAR 0 2
52876: UNION
52877: ST_TO_ADDR
// end ;
52878: LD_VAR 0 3
52882: RET
// export function GetBehemoths ( side ) ; begin
52883: LD_INT 0
52885: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52886: LD_ADDR_VAR 0 2
52890: PUSH
52891: LD_INT 22
52893: PUSH
52894: LD_VAR 0 1
52898: PUSH
52899: EMPTY
52900: LIST
52901: LIST
52902: PUSH
52903: LD_INT 31
52905: PUSH
52906: LD_INT 25
52908: PUSH
52909: EMPTY
52910: LIST
52911: LIST
52912: PUSH
52913: EMPTY
52914: LIST
52915: LIST
52916: PPUSH
52917: CALL_OW 69
52921: ST_TO_ADDR
// end ;
52922: LD_VAR 0 2
52926: RET
// export function Shuffle ( array ) ; var i , index ; begin
52927: LD_INT 0
52929: PPUSH
52930: PPUSH
52931: PPUSH
// result := [ ] ;
52932: LD_ADDR_VAR 0 2
52936: PUSH
52937: EMPTY
52938: ST_TO_ADDR
// if not array then
52939: LD_VAR 0 1
52943: NOT
52944: IFFALSE 52948
// exit ;
52946: GO 53047
// Randomize ;
52948: CALL_OW 10
// for i = array downto 1 do
52952: LD_ADDR_VAR 0 3
52956: PUSH
52957: DOUBLE
52958: LD_VAR 0 1
52962: INC
52963: ST_TO_ADDR
52964: LD_INT 1
52966: PUSH
52967: FOR_DOWNTO
52968: IFFALSE 53045
// begin index := rand ( 1 , array ) ;
52970: LD_ADDR_VAR 0 4
52974: PUSH
52975: LD_INT 1
52977: PPUSH
52978: LD_VAR 0 1
52982: PPUSH
52983: CALL_OW 12
52987: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52988: LD_ADDR_VAR 0 2
52992: PUSH
52993: LD_VAR 0 2
52997: PPUSH
52998: LD_VAR 0 2
53002: PUSH
53003: LD_INT 1
53005: PLUS
53006: PPUSH
53007: LD_VAR 0 1
53011: PUSH
53012: LD_VAR 0 4
53016: ARRAY
53017: PPUSH
53018: CALL_OW 2
53022: ST_TO_ADDR
// array := Delete ( array , index ) ;
53023: LD_ADDR_VAR 0 1
53027: PUSH
53028: LD_VAR 0 1
53032: PPUSH
53033: LD_VAR 0 4
53037: PPUSH
53038: CALL_OW 3
53042: ST_TO_ADDR
// end ;
53043: GO 52967
53045: POP
53046: POP
// end ;
53047: LD_VAR 0 2
53051: RET
// export function GetBaseMaterials ( base ) ; begin
53052: LD_INT 0
53054: PPUSH
// result := [ 0 , 0 , 0 ] ;
53055: LD_ADDR_VAR 0 2
53059: PUSH
53060: LD_INT 0
53062: PUSH
53063: LD_INT 0
53065: PUSH
53066: LD_INT 0
53068: PUSH
53069: EMPTY
53070: LIST
53071: LIST
53072: LIST
53073: ST_TO_ADDR
// if not base then
53074: LD_VAR 0 1
53078: NOT
53079: IFFALSE 53083
// exit ;
53081: GO 53132
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53083: LD_ADDR_VAR 0 2
53087: PUSH
53088: LD_VAR 0 1
53092: PPUSH
53093: LD_INT 1
53095: PPUSH
53096: CALL_OW 275
53100: PUSH
53101: LD_VAR 0 1
53105: PPUSH
53106: LD_INT 2
53108: PPUSH
53109: CALL_OW 275
53113: PUSH
53114: LD_VAR 0 1
53118: PPUSH
53119: LD_INT 3
53121: PPUSH
53122: CALL_OW 275
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: LIST
53131: ST_TO_ADDR
// end ;
53132: LD_VAR 0 2
53136: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
53137: LD_INT 0
53139: PPUSH
53140: PPUSH
// result := array ;
53141: LD_ADDR_VAR 0 3
53145: PUSH
53146: LD_VAR 0 1
53150: ST_TO_ADDR
// if size >= result then
53151: LD_VAR 0 2
53155: PUSH
53156: LD_VAR 0 3
53160: GREATEREQUAL
53161: IFFALSE 53165
// exit ;
53163: GO 53215
// if size then
53165: LD_VAR 0 2
53169: IFFALSE 53215
// for i := array downto size do
53171: LD_ADDR_VAR 0 4
53175: PUSH
53176: DOUBLE
53177: LD_VAR 0 1
53181: INC
53182: ST_TO_ADDR
53183: LD_VAR 0 2
53187: PUSH
53188: FOR_DOWNTO
53189: IFFALSE 53213
// result := Delete ( result , result ) ;
53191: LD_ADDR_VAR 0 3
53195: PUSH
53196: LD_VAR 0 3
53200: PPUSH
53201: LD_VAR 0 3
53205: PPUSH
53206: CALL_OW 3
53210: ST_TO_ADDR
53211: GO 53188
53213: POP
53214: POP
// end ;
53215: LD_VAR 0 3
53219: RET
// export function ComExit ( unit ) ; var tmp ; begin
53220: LD_INT 0
53222: PPUSH
53223: PPUSH
// if not IsInUnit ( unit ) then
53224: LD_VAR 0 1
53228: PPUSH
53229: CALL_OW 310
53233: NOT
53234: IFFALSE 53238
// exit ;
53236: GO 53298
// tmp := IsInUnit ( unit ) ;
53238: LD_ADDR_VAR 0 3
53242: PUSH
53243: LD_VAR 0 1
53247: PPUSH
53248: CALL_OW 310
53252: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
53253: LD_VAR 0 3
53257: PPUSH
53258: CALL_OW 247
53262: PUSH
53263: LD_INT 2
53265: EQUAL
53266: IFFALSE 53279
// ComExitVehicle ( unit ) else
53268: LD_VAR 0 1
53272: PPUSH
53273: CALL_OW 121
53277: GO 53288
// ComExitBuilding ( unit ) ;
53279: LD_VAR 0 1
53283: PPUSH
53284: CALL_OW 122
// result := tmp ;
53288: LD_ADDR_VAR 0 2
53292: PUSH
53293: LD_VAR 0 3
53297: ST_TO_ADDR
// end ;
53298: LD_VAR 0 2
53302: RET
// export function ComExitAll ( units ) ; var i ; begin
53303: LD_INT 0
53305: PPUSH
53306: PPUSH
// if not units then
53307: LD_VAR 0 1
53311: NOT
53312: IFFALSE 53316
// exit ;
53314: GO 53342
// for i in units do
53316: LD_ADDR_VAR 0 3
53320: PUSH
53321: LD_VAR 0 1
53325: PUSH
53326: FOR_IN
53327: IFFALSE 53340
// ComExit ( i ) ;
53329: LD_VAR 0 3
53333: PPUSH
53334: CALL 53220 0 1
53338: GO 53326
53340: POP
53341: POP
// end ;
53342: LD_VAR 0 2
53346: RET
// export function ResetHc ; begin
53347: LD_INT 0
53349: PPUSH
// InitHc ;
53350: CALL_OW 19
// hc_importance := 0 ;
53354: LD_ADDR_OWVAR 32
53358: PUSH
53359: LD_INT 0
53361: ST_TO_ADDR
// end ;
53362: LD_VAR 0 1
53366: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
53367: LD_INT 0
53369: PPUSH
53370: PPUSH
53371: PPUSH
// _x := ( x1 + x2 ) div 2 ;
53372: LD_ADDR_VAR 0 6
53376: PUSH
53377: LD_VAR 0 1
53381: PUSH
53382: LD_VAR 0 3
53386: PLUS
53387: PUSH
53388: LD_INT 2
53390: DIV
53391: ST_TO_ADDR
// if _x < 0 then
53392: LD_VAR 0 6
53396: PUSH
53397: LD_INT 0
53399: LESS
53400: IFFALSE 53417
// _x := _x * - 1 ;
53402: LD_ADDR_VAR 0 6
53406: PUSH
53407: LD_VAR 0 6
53411: PUSH
53412: LD_INT 1
53414: NEG
53415: MUL
53416: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
53417: LD_ADDR_VAR 0 7
53421: PUSH
53422: LD_VAR 0 2
53426: PUSH
53427: LD_VAR 0 4
53431: PLUS
53432: PUSH
53433: LD_INT 2
53435: DIV
53436: ST_TO_ADDR
// if _y < 0 then
53437: LD_VAR 0 7
53441: PUSH
53442: LD_INT 0
53444: LESS
53445: IFFALSE 53462
// _y := _y * - 1 ;
53447: LD_ADDR_VAR 0 7
53451: PUSH
53452: LD_VAR 0 7
53456: PUSH
53457: LD_INT 1
53459: NEG
53460: MUL
53461: ST_TO_ADDR
// result := [ _x , _y ] ;
53462: LD_ADDR_VAR 0 5
53466: PUSH
53467: LD_VAR 0 6
53471: PUSH
53472: LD_VAR 0 7
53476: PUSH
53477: EMPTY
53478: LIST
53479: LIST
53480: ST_TO_ADDR
// end ;
53481: LD_VAR 0 5
53485: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53486: LD_INT 0
53488: PPUSH
53489: PPUSH
53490: PPUSH
53491: PPUSH
// task := GetTaskList ( unit ) ;
53492: LD_ADDR_VAR 0 7
53496: PUSH
53497: LD_VAR 0 1
53501: PPUSH
53502: CALL_OW 437
53506: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53507: LD_VAR 0 7
53511: NOT
53512: PUSH
53513: LD_VAR 0 1
53517: PPUSH
53518: LD_VAR 0 2
53522: PPUSH
53523: CALL_OW 308
53527: NOT
53528: AND
53529: IFFALSE 53533
// exit ;
53531: GO 53651
// if IsInArea ( unit , area ) then
53533: LD_VAR 0 1
53537: PPUSH
53538: LD_VAR 0 2
53542: PPUSH
53543: CALL_OW 308
53547: IFFALSE 53565
// begin ComMoveToArea ( unit , goAway ) ;
53549: LD_VAR 0 1
53553: PPUSH
53554: LD_VAR 0 3
53558: PPUSH
53559: CALL_OW 113
// exit ;
53563: GO 53651
// end ; if task [ 1 ] [ 1 ] <> M then
53565: LD_VAR 0 7
53569: PUSH
53570: LD_INT 1
53572: ARRAY
53573: PUSH
53574: LD_INT 1
53576: ARRAY
53577: PUSH
53578: LD_STRING M
53580: NONEQUAL
53581: IFFALSE 53585
// exit ;
53583: GO 53651
// x := task [ 1 ] [ 2 ] ;
53585: LD_ADDR_VAR 0 5
53589: PUSH
53590: LD_VAR 0 7
53594: PUSH
53595: LD_INT 1
53597: ARRAY
53598: PUSH
53599: LD_INT 2
53601: ARRAY
53602: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53603: LD_ADDR_VAR 0 6
53607: PUSH
53608: LD_VAR 0 7
53612: PUSH
53613: LD_INT 1
53615: ARRAY
53616: PUSH
53617: LD_INT 3
53619: ARRAY
53620: ST_TO_ADDR
// if InArea ( x , y , area ) then
53621: LD_VAR 0 5
53625: PPUSH
53626: LD_VAR 0 6
53630: PPUSH
53631: LD_VAR 0 2
53635: PPUSH
53636: CALL_OW 309
53640: IFFALSE 53651
// ComStop ( unit ) ;
53642: LD_VAR 0 1
53646: PPUSH
53647: CALL_OW 141
// end ;
53651: LD_VAR 0 4
53655: RET
// export function Abs ( value ) ; begin
53656: LD_INT 0
53658: PPUSH
// result := value ;
53659: LD_ADDR_VAR 0 2
53663: PUSH
53664: LD_VAR 0 1
53668: ST_TO_ADDR
// if value < 0 then
53669: LD_VAR 0 1
53673: PUSH
53674: LD_INT 0
53676: LESS
53677: IFFALSE 53694
// result := value * - 1 ;
53679: LD_ADDR_VAR 0 2
53683: PUSH
53684: LD_VAR 0 1
53688: PUSH
53689: LD_INT 1
53691: NEG
53692: MUL
53693: ST_TO_ADDR
// end ;
53694: LD_VAR 0 2
53698: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53699: LD_INT 0
53701: PPUSH
53702: PPUSH
53703: PPUSH
53704: PPUSH
53705: PPUSH
53706: PPUSH
53707: PPUSH
53708: PPUSH
// if not unit or not building then
53709: LD_VAR 0 1
53713: NOT
53714: PUSH
53715: LD_VAR 0 2
53719: NOT
53720: OR
53721: IFFALSE 53725
// exit ;
53723: GO 53951
// x := GetX ( building ) ;
53725: LD_ADDR_VAR 0 4
53729: PUSH
53730: LD_VAR 0 2
53734: PPUSH
53735: CALL_OW 250
53739: ST_TO_ADDR
// y := GetY ( building ) ;
53740: LD_ADDR_VAR 0 6
53744: PUSH
53745: LD_VAR 0 2
53749: PPUSH
53750: CALL_OW 251
53754: ST_TO_ADDR
// d := GetDir ( building ) ;
53755: LD_ADDR_VAR 0 8
53759: PUSH
53760: LD_VAR 0 2
53764: PPUSH
53765: CALL_OW 254
53769: ST_TO_ADDR
// r := 4 ;
53770: LD_ADDR_VAR 0 9
53774: PUSH
53775: LD_INT 4
53777: ST_TO_ADDR
// for i := 1 to 5 do
53778: LD_ADDR_VAR 0 10
53782: PUSH
53783: DOUBLE
53784: LD_INT 1
53786: DEC
53787: ST_TO_ADDR
53788: LD_INT 5
53790: PUSH
53791: FOR_TO
53792: IFFALSE 53949
// begin _x := ShiftX ( x , d , r + i ) ;
53794: LD_ADDR_VAR 0 5
53798: PUSH
53799: LD_VAR 0 4
53803: PPUSH
53804: LD_VAR 0 8
53808: PPUSH
53809: LD_VAR 0 9
53813: PUSH
53814: LD_VAR 0 10
53818: PLUS
53819: PPUSH
53820: CALL_OW 272
53824: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53825: LD_ADDR_VAR 0 7
53829: PUSH
53830: LD_VAR 0 6
53834: PPUSH
53835: LD_VAR 0 8
53839: PPUSH
53840: LD_VAR 0 9
53844: PUSH
53845: LD_VAR 0 10
53849: PLUS
53850: PPUSH
53851: CALL_OW 273
53855: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53856: LD_VAR 0 5
53860: PPUSH
53861: LD_VAR 0 7
53865: PPUSH
53866: CALL_OW 488
53870: PUSH
53871: LD_VAR 0 5
53875: PPUSH
53876: LD_VAR 0 7
53880: PPUSH
53881: CALL_OW 428
53885: PPUSH
53886: CALL_OW 247
53890: PUSH
53891: LD_INT 3
53893: PUSH
53894: LD_INT 2
53896: PUSH
53897: EMPTY
53898: LIST
53899: LIST
53900: IN
53901: NOT
53902: AND
53903: IFFALSE 53947
// begin ComMoveXY ( unit , _x , _y ) ;
53905: LD_VAR 0 1
53909: PPUSH
53910: LD_VAR 0 5
53914: PPUSH
53915: LD_VAR 0 7
53919: PPUSH
53920: CALL_OW 111
// result := [ _x , _y ] ;
53924: LD_ADDR_VAR 0 3
53928: PUSH
53929: LD_VAR 0 5
53933: PUSH
53934: LD_VAR 0 7
53938: PUSH
53939: EMPTY
53940: LIST
53941: LIST
53942: ST_TO_ADDR
// exit ;
53943: POP
53944: POP
53945: GO 53951
// end ; end ;
53947: GO 53791
53949: POP
53950: POP
// end ;
53951: LD_VAR 0 3
53955: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53956: LD_INT 0
53958: PPUSH
53959: PPUSH
53960: PPUSH
// result := 0 ;
53961: LD_ADDR_VAR 0 3
53965: PUSH
53966: LD_INT 0
53968: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53969: LD_VAR 0 1
53973: PUSH
53974: LD_INT 0
53976: LESS
53977: PUSH
53978: LD_VAR 0 1
53982: PUSH
53983: LD_INT 8
53985: GREATER
53986: OR
53987: PUSH
53988: LD_VAR 0 2
53992: PUSH
53993: LD_INT 0
53995: LESS
53996: OR
53997: PUSH
53998: LD_VAR 0 2
54002: PUSH
54003: LD_INT 8
54005: GREATER
54006: OR
54007: IFFALSE 54011
// exit ;
54009: GO 54086
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
54011: LD_ADDR_VAR 0 4
54015: PUSH
54016: LD_INT 22
54018: PUSH
54019: LD_VAR 0 2
54023: PUSH
54024: EMPTY
54025: LIST
54026: LIST
54027: PPUSH
54028: CALL_OW 69
54032: PUSH
54033: FOR_IN
54034: IFFALSE 54084
// begin un := UnitShoot ( i ) ;
54036: LD_ADDR_VAR 0 5
54040: PUSH
54041: LD_VAR 0 4
54045: PPUSH
54046: CALL_OW 504
54050: ST_TO_ADDR
// if GetSide ( un ) = side1 then
54051: LD_VAR 0 5
54055: PPUSH
54056: CALL_OW 255
54060: PUSH
54061: LD_VAR 0 1
54065: EQUAL
54066: IFFALSE 54082
// begin result := un ;
54068: LD_ADDR_VAR 0 3
54072: PUSH
54073: LD_VAR 0 5
54077: ST_TO_ADDR
// exit ;
54078: POP
54079: POP
54080: GO 54086
// end ; end ;
54082: GO 54033
54084: POP
54085: POP
// end ;
54086: LD_VAR 0 3
54090: RET
// export function GetCargoBay ( units ) ; begin
54091: LD_INT 0
54093: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
54094: LD_ADDR_VAR 0 2
54098: PUSH
54099: LD_VAR 0 1
54103: PPUSH
54104: LD_INT 2
54106: PUSH
54107: LD_INT 34
54109: PUSH
54110: LD_INT 12
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: LD_INT 34
54119: PUSH
54120: LD_INT 51
54122: PUSH
54123: EMPTY
54124: LIST
54125: LIST
54126: PUSH
54127: LD_INT 34
54129: PUSH
54130: LD_INT 32
54132: PUSH
54133: EMPTY
54134: LIST
54135: LIST
54136: PUSH
54137: LD_INT 34
54139: PUSH
54140: LD_INT 89
54142: PUSH
54143: EMPTY
54144: LIST
54145: LIST
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: LIST
54152: LIST
54153: PPUSH
54154: CALL_OW 72
54158: ST_TO_ADDR
// end ;
54159: LD_VAR 0 2
54163: RET
// export function Negate ( value ) ; begin
54164: LD_INT 0
54166: PPUSH
// result := not value ;
54167: LD_ADDR_VAR 0 2
54171: PUSH
54172: LD_VAR 0 1
54176: NOT
54177: ST_TO_ADDR
// end ;
54178: LD_VAR 0 2
54182: RET
// export function Inc ( value ) ; begin
54183: LD_INT 0
54185: PPUSH
// result := value + 1 ;
54186: LD_ADDR_VAR 0 2
54190: PUSH
54191: LD_VAR 0 1
54195: PUSH
54196: LD_INT 1
54198: PLUS
54199: ST_TO_ADDR
// end ;
54200: LD_VAR 0 2
54204: RET
// export function Dec ( value ) ; begin
54205: LD_INT 0
54207: PPUSH
// result := value - 1 ;
54208: LD_ADDR_VAR 0 2
54212: PUSH
54213: LD_VAR 0 1
54217: PUSH
54218: LD_INT 1
54220: MINUS
54221: ST_TO_ADDR
// end ;
54222: LD_VAR 0 2
54226: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
54227: LD_INT 0
54229: PPUSH
54230: PPUSH
54231: PPUSH
54232: PPUSH
54233: PPUSH
54234: PPUSH
54235: PPUSH
54236: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
54237: LD_VAR 0 1
54241: PPUSH
54242: LD_VAR 0 2
54246: PPUSH
54247: CALL_OW 488
54251: NOT
54252: PUSH
54253: LD_VAR 0 3
54257: PPUSH
54258: LD_VAR 0 4
54262: PPUSH
54263: CALL_OW 488
54267: NOT
54268: OR
54269: IFFALSE 54282
// begin result := - 1 ;
54271: LD_ADDR_VAR 0 5
54275: PUSH
54276: LD_INT 1
54278: NEG
54279: ST_TO_ADDR
// exit ;
54280: GO 54517
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
54282: LD_ADDR_VAR 0 12
54286: PUSH
54287: LD_VAR 0 1
54291: PPUSH
54292: LD_VAR 0 2
54296: PPUSH
54297: LD_VAR 0 3
54301: PPUSH
54302: LD_VAR 0 4
54306: PPUSH
54307: CALL 53367 0 4
54311: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
54312: LD_ADDR_VAR 0 11
54316: PUSH
54317: LD_VAR 0 1
54321: PPUSH
54322: LD_VAR 0 2
54326: PPUSH
54327: LD_VAR 0 12
54331: PUSH
54332: LD_INT 1
54334: ARRAY
54335: PPUSH
54336: LD_VAR 0 12
54340: PUSH
54341: LD_INT 2
54343: ARRAY
54344: PPUSH
54345: CALL_OW 298
54349: ST_TO_ADDR
// distance := 9999 ;
54350: LD_ADDR_VAR 0 10
54354: PUSH
54355: LD_INT 9999
54357: ST_TO_ADDR
// for i := 0 to 5 do
54358: LD_ADDR_VAR 0 6
54362: PUSH
54363: DOUBLE
54364: LD_INT 0
54366: DEC
54367: ST_TO_ADDR
54368: LD_INT 5
54370: PUSH
54371: FOR_TO
54372: IFFALSE 54515
// begin _x := ShiftX ( x1 , i , centerDist ) ;
54374: LD_ADDR_VAR 0 7
54378: PUSH
54379: LD_VAR 0 1
54383: PPUSH
54384: LD_VAR 0 6
54388: PPUSH
54389: LD_VAR 0 11
54393: PPUSH
54394: CALL_OW 272
54398: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
54399: LD_ADDR_VAR 0 8
54403: PUSH
54404: LD_VAR 0 2
54408: PPUSH
54409: LD_VAR 0 6
54413: PPUSH
54414: LD_VAR 0 11
54418: PPUSH
54419: CALL_OW 273
54423: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54424: LD_VAR 0 7
54428: PPUSH
54429: LD_VAR 0 8
54433: PPUSH
54434: CALL_OW 488
54438: NOT
54439: IFFALSE 54443
// continue ;
54441: GO 54371
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54443: LD_ADDR_VAR 0 9
54447: PUSH
54448: LD_VAR 0 12
54452: PUSH
54453: LD_INT 1
54455: ARRAY
54456: PPUSH
54457: LD_VAR 0 12
54461: PUSH
54462: LD_INT 2
54464: ARRAY
54465: PPUSH
54466: LD_VAR 0 7
54470: PPUSH
54471: LD_VAR 0 8
54475: PPUSH
54476: CALL_OW 298
54480: ST_TO_ADDR
// if tmp < distance then
54481: LD_VAR 0 9
54485: PUSH
54486: LD_VAR 0 10
54490: LESS
54491: IFFALSE 54513
// begin result := i ;
54493: LD_ADDR_VAR 0 5
54497: PUSH
54498: LD_VAR 0 6
54502: ST_TO_ADDR
// distance := tmp ;
54503: LD_ADDR_VAR 0 10
54507: PUSH
54508: LD_VAR 0 9
54512: ST_TO_ADDR
// end ; end ;
54513: GO 54371
54515: POP
54516: POP
// end ;
54517: LD_VAR 0 5
54521: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54522: LD_INT 0
54524: PPUSH
54525: PPUSH
// if not driver or not IsInUnit ( driver ) then
54526: LD_VAR 0 1
54530: NOT
54531: PUSH
54532: LD_VAR 0 1
54536: PPUSH
54537: CALL_OW 310
54541: NOT
54542: OR
54543: IFFALSE 54547
// exit ;
54545: GO 54637
// vehicle := IsInUnit ( driver ) ;
54547: LD_ADDR_VAR 0 3
54551: PUSH
54552: LD_VAR 0 1
54556: PPUSH
54557: CALL_OW 310
54561: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54562: LD_VAR 0 1
54566: PPUSH
54567: LD_STRING \
54569: PUSH
54570: LD_INT 0
54572: PUSH
54573: LD_INT 0
54575: PUSH
54576: LD_INT 0
54578: PUSH
54579: LD_INT 0
54581: PUSH
54582: LD_INT 0
54584: PUSH
54585: LD_INT 0
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: LIST
54592: LIST
54593: LIST
54594: LIST
54595: LIST
54596: PUSH
54597: LD_STRING E
54599: PUSH
54600: LD_INT 0
54602: PUSH
54603: LD_INT 0
54605: PUSH
54606: LD_VAR 0 3
54610: PUSH
54611: LD_INT 0
54613: PUSH
54614: LD_INT 0
54616: PUSH
54617: LD_INT 0
54619: PUSH
54620: EMPTY
54621: LIST
54622: LIST
54623: LIST
54624: LIST
54625: LIST
54626: LIST
54627: LIST
54628: PUSH
54629: EMPTY
54630: LIST
54631: LIST
54632: PPUSH
54633: CALL_OW 446
// end ;
54637: LD_VAR 0 2
54641: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54642: LD_INT 0
54644: PPUSH
54645: PPUSH
// if not driver or not IsInUnit ( driver ) then
54646: LD_VAR 0 1
54650: NOT
54651: PUSH
54652: LD_VAR 0 1
54656: PPUSH
54657: CALL_OW 310
54661: NOT
54662: OR
54663: IFFALSE 54667
// exit ;
54665: GO 54757
// vehicle := IsInUnit ( driver ) ;
54667: LD_ADDR_VAR 0 3
54671: PUSH
54672: LD_VAR 0 1
54676: PPUSH
54677: CALL_OW 310
54681: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54682: LD_VAR 0 1
54686: PPUSH
54687: LD_STRING \
54689: PUSH
54690: LD_INT 0
54692: PUSH
54693: LD_INT 0
54695: PUSH
54696: LD_INT 0
54698: PUSH
54699: LD_INT 0
54701: PUSH
54702: LD_INT 0
54704: PUSH
54705: LD_INT 0
54707: PUSH
54708: EMPTY
54709: LIST
54710: LIST
54711: LIST
54712: LIST
54713: LIST
54714: LIST
54715: LIST
54716: PUSH
54717: LD_STRING E
54719: PUSH
54720: LD_INT 0
54722: PUSH
54723: LD_INT 0
54725: PUSH
54726: LD_VAR 0 3
54730: PUSH
54731: LD_INT 0
54733: PUSH
54734: LD_INT 0
54736: PUSH
54737: LD_INT 0
54739: PUSH
54740: EMPTY
54741: LIST
54742: LIST
54743: LIST
54744: LIST
54745: LIST
54746: LIST
54747: LIST
54748: PUSH
54749: EMPTY
54750: LIST
54751: LIST
54752: PPUSH
54753: CALL_OW 447
// end ;
54757: LD_VAR 0 2
54761: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54762: LD_INT 0
54764: PPUSH
54765: PPUSH
54766: PPUSH
// tmp := [ ] ;
54767: LD_ADDR_VAR 0 5
54771: PUSH
54772: EMPTY
54773: ST_TO_ADDR
// for i in units do
54774: LD_ADDR_VAR 0 4
54778: PUSH
54779: LD_VAR 0 1
54783: PUSH
54784: FOR_IN
54785: IFFALSE 54823
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54787: LD_ADDR_VAR 0 5
54791: PUSH
54792: LD_VAR 0 5
54796: PPUSH
54797: LD_VAR 0 5
54801: PUSH
54802: LD_INT 1
54804: PLUS
54805: PPUSH
54806: LD_VAR 0 4
54810: PPUSH
54811: CALL_OW 256
54815: PPUSH
54816: CALL_OW 2
54820: ST_TO_ADDR
54821: GO 54784
54823: POP
54824: POP
// if not tmp then
54825: LD_VAR 0 5
54829: NOT
54830: IFFALSE 54834
// exit ;
54832: GO 54882
// if asc then
54834: LD_VAR 0 2
54838: IFFALSE 54862
// result := SortListByListAsc ( units , tmp ) else
54840: LD_ADDR_VAR 0 3
54844: PUSH
54845: LD_VAR 0 1
54849: PPUSH
54850: LD_VAR 0 5
54854: PPUSH
54855: CALL_OW 76
54859: ST_TO_ADDR
54860: GO 54882
// result := SortListByListDesc ( units , tmp ) ;
54862: LD_ADDR_VAR 0 3
54866: PUSH
54867: LD_VAR 0 1
54871: PPUSH
54872: LD_VAR 0 5
54876: PPUSH
54877: CALL_OW 77
54881: ST_TO_ADDR
// end ;
54882: LD_VAR 0 3
54886: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54887: LD_INT 0
54889: PPUSH
54890: PPUSH
// task := GetTaskList ( mech ) ;
54891: LD_ADDR_VAR 0 4
54895: PUSH
54896: LD_VAR 0 1
54900: PPUSH
54901: CALL_OW 437
54905: ST_TO_ADDR
// if not task then
54906: LD_VAR 0 4
54910: NOT
54911: IFFALSE 54915
// exit ;
54913: GO 54957
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54915: LD_ADDR_VAR 0 3
54919: PUSH
54920: LD_VAR 0 4
54924: PUSH
54925: LD_INT 1
54927: ARRAY
54928: PUSH
54929: LD_INT 1
54931: ARRAY
54932: PUSH
54933: LD_STRING r
54935: EQUAL
54936: PUSH
54937: LD_VAR 0 4
54941: PUSH
54942: LD_INT 1
54944: ARRAY
54945: PUSH
54946: LD_INT 4
54948: ARRAY
54949: PUSH
54950: LD_VAR 0 2
54954: EQUAL
54955: AND
54956: ST_TO_ADDR
// end ;
54957: LD_VAR 0 3
54961: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54962: LD_INT 0
54964: PPUSH
// SetDir ( unit , d ) ;
54965: LD_VAR 0 1
54969: PPUSH
54970: LD_VAR 0 4
54974: PPUSH
54975: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54979: LD_VAR 0 1
54983: PPUSH
54984: LD_VAR 0 2
54988: PPUSH
54989: LD_VAR 0 3
54993: PPUSH
54994: LD_VAR 0 5
54998: PPUSH
54999: CALL_OW 48
// end ;
55003: LD_VAR 0 6
55007: RET
// export function ToNaturalNumber ( number ) ; begin
55008: LD_INT 0
55010: PPUSH
// result := number div 1 ;
55011: LD_ADDR_VAR 0 2
55015: PUSH
55016: LD_VAR 0 1
55020: PUSH
55021: LD_INT 1
55023: DIV
55024: ST_TO_ADDR
// if number < 0 then
55025: LD_VAR 0 1
55029: PUSH
55030: LD_INT 0
55032: LESS
55033: IFFALSE 55043
// result := 0 ;
55035: LD_ADDR_VAR 0 2
55039: PUSH
55040: LD_INT 0
55042: ST_TO_ADDR
// end ;
55043: LD_VAR 0 2
55047: RET
// export function SortByClass ( units , class ) ; var un ; begin
55048: LD_INT 0
55050: PPUSH
55051: PPUSH
// if not units or not class then
55052: LD_VAR 0 1
55056: NOT
55057: PUSH
55058: LD_VAR 0 2
55062: NOT
55063: OR
55064: IFFALSE 55068
// exit ;
55066: GO 55163
// result := [ ] ;
55068: LD_ADDR_VAR 0 3
55072: PUSH
55073: EMPTY
55074: ST_TO_ADDR
// for un in units do
55075: LD_ADDR_VAR 0 4
55079: PUSH
55080: LD_VAR 0 1
55084: PUSH
55085: FOR_IN
55086: IFFALSE 55161
// if GetClass ( un ) = class then
55088: LD_VAR 0 4
55092: PPUSH
55093: CALL_OW 257
55097: PUSH
55098: LD_VAR 0 2
55102: EQUAL
55103: IFFALSE 55130
// result := Insert ( result , 1 , un ) else
55105: LD_ADDR_VAR 0 3
55109: PUSH
55110: LD_VAR 0 3
55114: PPUSH
55115: LD_INT 1
55117: PPUSH
55118: LD_VAR 0 4
55122: PPUSH
55123: CALL_OW 2
55127: ST_TO_ADDR
55128: GO 55159
// result := Replace ( result , result + 1 , un ) ;
55130: LD_ADDR_VAR 0 3
55134: PUSH
55135: LD_VAR 0 3
55139: PPUSH
55140: LD_VAR 0 3
55144: PUSH
55145: LD_INT 1
55147: PLUS
55148: PPUSH
55149: LD_VAR 0 4
55153: PPUSH
55154: CALL_OW 1
55158: ST_TO_ADDR
55159: GO 55085
55161: POP
55162: POP
// end ;
55163: LD_VAR 0 3
55167: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
55168: LD_INT 0
55170: PPUSH
55171: PPUSH
55172: PPUSH
55173: PPUSH
55174: PPUSH
55175: PPUSH
55176: PPUSH
// result := [ ] ;
55177: LD_ADDR_VAR 0 4
55181: PUSH
55182: EMPTY
55183: ST_TO_ADDR
// if x - r < 0 then
55184: LD_VAR 0 1
55188: PUSH
55189: LD_VAR 0 3
55193: MINUS
55194: PUSH
55195: LD_INT 0
55197: LESS
55198: IFFALSE 55210
// min_x := 0 else
55200: LD_ADDR_VAR 0 8
55204: PUSH
55205: LD_INT 0
55207: ST_TO_ADDR
55208: GO 55226
// min_x := x - r ;
55210: LD_ADDR_VAR 0 8
55214: PUSH
55215: LD_VAR 0 1
55219: PUSH
55220: LD_VAR 0 3
55224: MINUS
55225: ST_TO_ADDR
// if y - r < 0 then
55226: LD_VAR 0 2
55230: PUSH
55231: LD_VAR 0 3
55235: MINUS
55236: PUSH
55237: LD_INT 0
55239: LESS
55240: IFFALSE 55252
// min_y := 0 else
55242: LD_ADDR_VAR 0 7
55246: PUSH
55247: LD_INT 0
55249: ST_TO_ADDR
55250: GO 55268
// min_y := y - r ;
55252: LD_ADDR_VAR 0 7
55256: PUSH
55257: LD_VAR 0 2
55261: PUSH
55262: LD_VAR 0 3
55266: MINUS
55267: ST_TO_ADDR
// max_x := x + r ;
55268: LD_ADDR_VAR 0 9
55272: PUSH
55273: LD_VAR 0 1
55277: PUSH
55278: LD_VAR 0 3
55282: PLUS
55283: ST_TO_ADDR
// max_y := y + r ;
55284: LD_ADDR_VAR 0 10
55288: PUSH
55289: LD_VAR 0 2
55293: PUSH
55294: LD_VAR 0 3
55298: PLUS
55299: ST_TO_ADDR
// for _x = min_x to max_x do
55300: LD_ADDR_VAR 0 5
55304: PUSH
55305: DOUBLE
55306: LD_VAR 0 8
55310: DEC
55311: ST_TO_ADDR
55312: LD_VAR 0 9
55316: PUSH
55317: FOR_TO
55318: IFFALSE 55419
// for _y = min_y to max_y do
55320: LD_ADDR_VAR 0 6
55324: PUSH
55325: DOUBLE
55326: LD_VAR 0 7
55330: DEC
55331: ST_TO_ADDR
55332: LD_VAR 0 10
55336: PUSH
55337: FOR_TO
55338: IFFALSE 55415
// begin if not ValidHex ( _x , _y ) then
55340: LD_VAR 0 5
55344: PPUSH
55345: LD_VAR 0 6
55349: PPUSH
55350: CALL_OW 488
55354: NOT
55355: IFFALSE 55359
// continue ;
55357: GO 55337
// if GetResourceTypeXY ( _x , _y ) then
55359: LD_VAR 0 5
55363: PPUSH
55364: LD_VAR 0 6
55368: PPUSH
55369: CALL_OW 283
55373: IFFALSE 55413
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
55375: LD_ADDR_VAR 0 4
55379: PUSH
55380: LD_VAR 0 4
55384: PPUSH
55385: LD_VAR 0 4
55389: PUSH
55390: LD_INT 1
55392: PLUS
55393: PPUSH
55394: LD_VAR 0 5
55398: PUSH
55399: LD_VAR 0 6
55403: PUSH
55404: EMPTY
55405: LIST
55406: LIST
55407: PPUSH
55408: CALL_OW 1
55412: ST_TO_ADDR
// end ;
55413: GO 55337
55415: POP
55416: POP
55417: GO 55317
55419: POP
55420: POP
// end ;
55421: LD_VAR 0 4
55425: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
55426: LD_INT 0
55428: PPUSH
55429: PPUSH
55430: PPUSH
55431: PPUSH
55432: PPUSH
55433: PPUSH
55434: PPUSH
55435: PPUSH
// if not units then
55436: LD_VAR 0 1
55440: NOT
55441: IFFALSE 55445
// exit ;
55443: GO 55969
// result := UnitFilter ( units , [ f_ok ] ) ;
55445: LD_ADDR_VAR 0 3
55449: PUSH
55450: LD_VAR 0 1
55454: PPUSH
55455: LD_INT 50
55457: PUSH
55458: EMPTY
55459: LIST
55460: PPUSH
55461: CALL_OW 72
55465: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55466: LD_ADDR_VAR 0 8
55470: PUSH
55471: LD_VAR 0 1
55475: PUSH
55476: LD_INT 1
55478: ARRAY
55479: PPUSH
55480: CALL_OW 255
55484: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55485: LD_ADDR_VAR 0 10
55489: PUSH
55490: LD_INT 29
55492: PUSH
55493: LD_INT 91
55495: PUSH
55496: LD_INT 49
55498: PUSH
55499: EMPTY
55500: LIST
55501: LIST
55502: LIST
55503: ST_TO_ADDR
// if not result then
55504: LD_VAR 0 3
55508: NOT
55509: IFFALSE 55513
// exit ;
55511: GO 55969
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55513: LD_ADDR_VAR 0 5
55517: PUSH
55518: LD_INT 81
55520: PUSH
55521: LD_VAR 0 8
55525: PUSH
55526: EMPTY
55527: LIST
55528: LIST
55529: PPUSH
55530: CALL_OW 69
55534: ST_TO_ADDR
// for i in result do
55535: LD_ADDR_VAR 0 4
55539: PUSH
55540: LD_VAR 0 3
55544: PUSH
55545: FOR_IN
55546: IFFALSE 55967
// begin tag := GetTag ( i ) + 1 ;
55548: LD_ADDR_VAR 0 9
55552: PUSH
55553: LD_VAR 0 4
55557: PPUSH
55558: CALL_OW 110
55562: PUSH
55563: LD_INT 1
55565: PLUS
55566: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55567: LD_ADDR_VAR 0 7
55571: PUSH
55572: LD_VAR 0 4
55576: PPUSH
55577: CALL_OW 250
55581: PPUSH
55582: LD_VAR 0 4
55586: PPUSH
55587: CALL_OW 251
55591: PPUSH
55592: LD_INT 6
55594: PPUSH
55595: CALL 55168 0 3
55599: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55600: LD_VAR 0 4
55604: PPUSH
55605: CALL_OW 247
55609: PUSH
55610: LD_INT 2
55612: EQUAL
55613: PUSH
55614: LD_VAR 0 7
55618: AND
55619: PUSH
55620: LD_VAR 0 4
55624: PPUSH
55625: CALL_OW 264
55629: PUSH
55630: LD_VAR 0 10
55634: IN
55635: NOT
55636: AND
55637: IFFALSE 55676
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55639: LD_VAR 0 4
55643: PPUSH
55644: LD_VAR 0 7
55648: PUSH
55649: LD_INT 1
55651: ARRAY
55652: PUSH
55653: LD_INT 1
55655: ARRAY
55656: PPUSH
55657: LD_VAR 0 7
55661: PUSH
55662: LD_INT 1
55664: ARRAY
55665: PUSH
55666: LD_INT 2
55668: ARRAY
55669: PPUSH
55670: CALL_OW 116
55674: GO 55965
// if path > tag then
55676: LD_VAR 0 2
55680: PUSH
55681: LD_VAR 0 9
55685: GREATER
55686: IFFALSE 55894
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55688: LD_ADDR_VAR 0 6
55692: PUSH
55693: LD_VAR 0 5
55697: PPUSH
55698: LD_INT 91
55700: PUSH
55701: LD_VAR 0 4
55705: PUSH
55706: LD_INT 8
55708: PUSH
55709: EMPTY
55710: LIST
55711: LIST
55712: LIST
55713: PPUSH
55714: CALL_OW 72
55718: ST_TO_ADDR
// if nearEnemy then
55719: LD_VAR 0 6
55723: IFFALSE 55792
// begin if GetWeapon ( i ) = ru_time_lapser then
55725: LD_VAR 0 4
55729: PPUSH
55730: CALL_OW 264
55734: PUSH
55735: LD_INT 49
55737: EQUAL
55738: IFFALSE 55766
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55740: LD_VAR 0 4
55744: PPUSH
55745: LD_VAR 0 6
55749: PPUSH
55750: LD_VAR 0 4
55754: PPUSH
55755: CALL_OW 74
55759: PPUSH
55760: CALL_OW 112
55764: GO 55790
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55766: LD_VAR 0 4
55770: PPUSH
55771: LD_VAR 0 6
55775: PPUSH
55776: LD_VAR 0 4
55780: PPUSH
55781: CALL_OW 74
55785: PPUSH
55786: CALL 56894 0 2
// end else
55790: GO 55892
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55792: LD_VAR 0 4
55796: PPUSH
55797: LD_VAR 0 2
55801: PUSH
55802: LD_VAR 0 9
55806: ARRAY
55807: PUSH
55808: LD_INT 1
55810: ARRAY
55811: PPUSH
55812: LD_VAR 0 2
55816: PUSH
55817: LD_VAR 0 9
55821: ARRAY
55822: PUSH
55823: LD_INT 2
55825: ARRAY
55826: PPUSH
55827: CALL_OW 297
55831: PUSH
55832: LD_INT 6
55834: GREATER
55835: IFFALSE 55878
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55837: LD_VAR 0 4
55841: PPUSH
55842: LD_VAR 0 2
55846: PUSH
55847: LD_VAR 0 9
55851: ARRAY
55852: PUSH
55853: LD_INT 1
55855: ARRAY
55856: PPUSH
55857: LD_VAR 0 2
55861: PUSH
55862: LD_VAR 0 9
55866: ARRAY
55867: PUSH
55868: LD_INT 2
55870: ARRAY
55871: PPUSH
55872: CALL_OW 114
55876: GO 55892
// SetTag ( i , tag ) ;
55878: LD_VAR 0 4
55882: PPUSH
55883: LD_VAR 0 9
55887: PPUSH
55888: CALL_OW 109
// end else
55892: GO 55965
// if enemy then
55894: LD_VAR 0 5
55898: IFFALSE 55965
// begin if GetWeapon ( i ) = ru_time_lapser then
55900: LD_VAR 0 4
55904: PPUSH
55905: CALL_OW 264
55909: PUSH
55910: LD_INT 49
55912: EQUAL
55913: IFFALSE 55941
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55915: LD_VAR 0 4
55919: PPUSH
55920: LD_VAR 0 5
55924: PPUSH
55925: LD_VAR 0 4
55929: PPUSH
55930: CALL_OW 74
55934: PPUSH
55935: CALL_OW 112
55939: GO 55965
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55941: LD_VAR 0 4
55945: PPUSH
55946: LD_VAR 0 5
55950: PPUSH
55951: LD_VAR 0 4
55955: PPUSH
55956: CALL_OW 74
55960: PPUSH
55961: CALL 56894 0 2
// end ; end ;
55965: GO 55545
55967: POP
55968: POP
// end ;
55969: LD_VAR 0 3
55973: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55974: LD_INT 0
55976: PPUSH
55977: PPUSH
55978: PPUSH
// if not unit or IsInUnit ( unit ) then
55979: LD_VAR 0 1
55983: NOT
55984: PUSH
55985: LD_VAR 0 1
55989: PPUSH
55990: CALL_OW 310
55994: OR
55995: IFFALSE 55999
// exit ;
55997: GO 56090
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55999: LD_ADDR_VAR 0 4
56003: PUSH
56004: LD_VAR 0 1
56008: PPUSH
56009: CALL_OW 250
56013: PPUSH
56014: LD_VAR 0 2
56018: PPUSH
56019: LD_INT 1
56021: PPUSH
56022: CALL_OW 272
56026: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
56027: LD_ADDR_VAR 0 5
56031: PUSH
56032: LD_VAR 0 1
56036: PPUSH
56037: CALL_OW 251
56041: PPUSH
56042: LD_VAR 0 2
56046: PPUSH
56047: LD_INT 1
56049: PPUSH
56050: CALL_OW 273
56054: ST_TO_ADDR
// if ValidHex ( x , y ) then
56055: LD_VAR 0 4
56059: PPUSH
56060: LD_VAR 0 5
56064: PPUSH
56065: CALL_OW 488
56069: IFFALSE 56090
// ComTurnXY ( unit , x , y ) ;
56071: LD_VAR 0 1
56075: PPUSH
56076: LD_VAR 0 4
56080: PPUSH
56081: LD_VAR 0 5
56085: PPUSH
56086: CALL_OW 118
// end ;
56090: LD_VAR 0 3
56094: RET
// export function SeeUnits ( side , units ) ; var i ; begin
56095: LD_INT 0
56097: PPUSH
56098: PPUSH
// result := false ;
56099: LD_ADDR_VAR 0 3
56103: PUSH
56104: LD_INT 0
56106: ST_TO_ADDR
// if not units then
56107: LD_VAR 0 2
56111: NOT
56112: IFFALSE 56116
// exit ;
56114: GO 56161
// for i in units do
56116: LD_ADDR_VAR 0 4
56120: PUSH
56121: LD_VAR 0 2
56125: PUSH
56126: FOR_IN
56127: IFFALSE 56159
// if See ( side , i ) then
56129: LD_VAR 0 1
56133: PPUSH
56134: LD_VAR 0 4
56138: PPUSH
56139: CALL_OW 292
56143: IFFALSE 56157
// begin result := true ;
56145: LD_ADDR_VAR 0 3
56149: PUSH
56150: LD_INT 1
56152: ST_TO_ADDR
// exit ;
56153: POP
56154: POP
56155: GO 56161
// end ;
56157: GO 56126
56159: POP
56160: POP
// end ;
56161: LD_VAR 0 3
56165: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
56166: LD_INT 0
56168: PPUSH
56169: PPUSH
56170: PPUSH
56171: PPUSH
// if not unit or not points then
56172: LD_VAR 0 1
56176: NOT
56177: PUSH
56178: LD_VAR 0 2
56182: NOT
56183: OR
56184: IFFALSE 56188
// exit ;
56186: GO 56278
// dist := 99999 ;
56188: LD_ADDR_VAR 0 5
56192: PUSH
56193: LD_INT 99999
56195: ST_TO_ADDR
// for i in points do
56196: LD_ADDR_VAR 0 4
56200: PUSH
56201: LD_VAR 0 2
56205: PUSH
56206: FOR_IN
56207: IFFALSE 56276
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
56209: LD_ADDR_VAR 0 6
56213: PUSH
56214: LD_VAR 0 1
56218: PPUSH
56219: LD_VAR 0 4
56223: PUSH
56224: LD_INT 1
56226: ARRAY
56227: PPUSH
56228: LD_VAR 0 4
56232: PUSH
56233: LD_INT 2
56235: ARRAY
56236: PPUSH
56237: CALL_OW 297
56241: ST_TO_ADDR
// if tmpDist < dist then
56242: LD_VAR 0 6
56246: PUSH
56247: LD_VAR 0 5
56251: LESS
56252: IFFALSE 56274
// begin result := i ;
56254: LD_ADDR_VAR 0 3
56258: PUSH
56259: LD_VAR 0 4
56263: ST_TO_ADDR
// dist := tmpDist ;
56264: LD_ADDR_VAR 0 5
56268: PUSH
56269: LD_VAR 0 6
56273: ST_TO_ADDR
// end ; end ;
56274: GO 56206
56276: POP
56277: POP
// end ;
56278: LD_VAR 0 3
56282: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
56283: LD_INT 0
56285: PPUSH
// uc_side := side ;
56286: LD_ADDR_OWVAR 20
56290: PUSH
56291: LD_VAR 0 1
56295: ST_TO_ADDR
// uc_nation := 3 ;
56296: LD_ADDR_OWVAR 21
56300: PUSH
56301: LD_INT 3
56303: ST_TO_ADDR
// vc_chassis := 25 ;
56304: LD_ADDR_OWVAR 37
56308: PUSH
56309: LD_INT 25
56311: ST_TO_ADDR
// vc_engine := engine_siberite ;
56312: LD_ADDR_OWVAR 39
56316: PUSH
56317: LD_INT 3
56319: ST_TO_ADDR
// vc_control := control_computer ;
56320: LD_ADDR_OWVAR 38
56324: PUSH
56325: LD_INT 3
56327: ST_TO_ADDR
// vc_weapon := 59 ;
56328: LD_ADDR_OWVAR 40
56332: PUSH
56333: LD_INT 59
56335: ST_TO_ADDR
// result := CreateVehicle ;
56336: LD_ADDR_VAR 0 5
56340: PUSH
56341: CALL_OW 45
56345: ST_TO_ADDR
// SetDir ( result , d ) ;
56346: LD_VAR 0 5
56350: PPUSH
56351: LD_VAR 0 4
56355: PPUSH
56356: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
56360: LD_VAR 0 5
56364: PPUSH
56365: LD_VAR 0 2
56369: PPUSH
56370: LD_VAR 0 3
56374: PPUSH
56375: LD_INT 0
56377: PPUSH
56378: CALL_OW 48
// end ;
56382: LD_VAR 0 5
56386: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
56387: LD_INT 0
56389: PPUSH
56390: PPUSH
56391: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
56392: LD_ADDR_VAR 0 2
56396: PUSH
56397: LD_INT 0
56399: PUSH
56400: LD_INT 0
56402: PUSH
56403: LD_INT 0
56405: PUSH
56406: LD_INT 0
56408: PUSH
56409: EMPTY
56410: LIST
56411: LIST
56412: LIST
56413: LIST
56414: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
56415: LD_VAR 0 1
56419: NOT
56420: PUSH
56421: LD_VAR 0 1
56425: PPUSH
56426: CALL_OW 264
56430: PUSH
56431: LD_INT 12
56433: PUSH
56434: LD_INT 51
56436: PUSH
56437: LD_INT 32
56439: PUSH
56440: LD_INT 89
56442: PUSH
56443: EMPTY
56444: LIST
56445: LIST
56446: LIST
56447: LIST
56448: IN
56449: NOT
56450: OR
56451: IFFALSE 56455
// exit ;
56453: GO 56553
// for i := 1 to 3 do
56455: LD_ADDR_VAR 0 3
56459: PUSH
56460: DOUBLE
56461: LD_INT 1
56463: DEC
56464: ST_TO_ADDR
56465: LD_INT 3
56467: PUSH
56468: FOR_TO
56469: IFFALSE 56551
// begin tmp := GetCargo ( cargo , i ) ;
56471: LD_ADDR_VAR 0 4
56475: PUSH
56476: LD_VAR 0 1
56480: PPUSH
56481: LD_VAR 0 3
56485: PPUSH
56486: CALL_OW 289
56490: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56491: LD_ADDR_VAR 0 2
56495: PUSH
56496: LD_VAR 0 2
56500: PPUSH
56501: LD_VAR 0 3
56505: PPUSH
56506: LD_VAR 0 4
56510: PPUSH
56511: CALL_OW 1
56515: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56516: LD_ADDR_VAR 0 2
56520: PUSH
56521: LD_VAR 0 2
56525: PPUSH
56526: LD_INT 4
56528: PPUSH
56529: LD_VAR 0 2
56533: PUSH
56534: LD_INT 4
56536: ARRAY
56537: PUSH
56538: LD_VAR 0 4
56542: PLUS
56543: PPUSH
56544: CALL_OW 1
56548: ST_TO_ADDR
// end ;
56549: GO 56468
56551: POP
56552: POP
// end ;
56553: LD_VAR 0 2
56557: RET
// export function Length ( array ) ; begin
56558: LD_INT 0
56560: PPUSH
// result := array + 0 ;
56561: LD_ADDR_VAR 0 2
56565: PUSH
56566: LD_VAR 0 1
56570: PUSH
56571: LD_INT 0
56573: PLUS
56574: ST_TO_ADDR
// end ;
56575: LD_VAR 0 2
56579: RET
// export function PrepareArray ( array ) ; begin
56580: LD_INT 0
56582: PPUSH
// result := array diff 0 ;
56583: LD_ADDR_VAR 0 2
56587: PUSH
56588: LD_VAR 0 1
56592: PUSH
56593: LD_INT 0
56595: DIFF
56596: ST_TO_ADDR
// if not result [ 1 ] then
56597: LD_VAR 0 2
56601: PUSH
56602: LD_INT 1
56604: ARRAY
56605: NOT
56606: IFFALSE 56626
// result := Delete ( result , 1 ) ;
56608: LD_ADDR_VAR 0 2
56612: PUSH
56613: LD_VAR 0 2
56617: PPUSH
56618: LD_INT 1
56620: PPUSH
56621: CALL_OW 3
56625: ST_TO_ADDR
// end ;
56626: LD_VAR 0 2
56630: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56631: LD_INT 0
56633: PPUSH
56634: PPUSH
56635: PPUSH
56636: PPUSH
// sibRocketRange := 25 ;
56637: LD_ADDR_VAR 0 6
56641: PUSH
56642: LD_INT 25
56644: ST_TO_ADDR
// result := false ;
56645: LD_ADDR_VAR 0 4
56649: PUSH
56650: LD_INT 0
56652: ST_TO_ADDR
// for i := 0 to 5 do
56653: LD_ADDR_VAR 0 5
56657: PUSH
56658: DOUBLE
56659: LD_INT 0
56661: DEC
56662: ST_TO_ADDR
56663: LD_INT 5
56665: PUSH
56666: FOR_TO
56667: IFFALSE 56734
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56669: LD_VAR 0 1
56673: PPUSH
56674: LD_VAR 0 5
56678: PPUSH
56679: LD_VAR 0 6
56683: PPUSH
56684: CALL_OW 272
56688: PPUSH
56689: LD_VAR 0 2
56693: PPUSH
56694: LD_VAR 0 5
56698: PPUSH
56699: LD_VAR 0 6
56703: PPUSH
56704: CALL_OW 273
56708: PPUSH
56709: LD_VAR 0 3
56713: PPUSH
56714: CALL_OW 309
56718: IFFALSE 56732
// begin result := true ;
56720: LD_ADDR_VAR 0 4
56724: PUSH
56725: LD_INT 1
56727: ST_TO_ADDR
// exit ;
56728: POP
56729: POP
56730: GO 56736
// end ;
56732: GO 56666
56734: POP
56735: POP
// end ;
56736: LD_VAR 0 4
56740: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56741: LD_INT 0
56743: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56744: LD_VAR 0 1
56748: PPUSH
56749: LD_VAR 0 2
56753: PPUSH
56754: LD_INT 0
56756: PPUSH
56757: LD_INT 0
56759: PPUSH
56760: LD_INT 1
56762: PPUSH
56763: LD_INT 0
56765: PPUSH
56766: CALL_OW 587
// end ;
56770: LD_VAR 0 3
56774: RET
// export function CenterOnNow ( unit ) ; begin
56775: LD_INT 0
56777: PPUSH
// result := IsInUnit ( unit ) ;
56778: LD_ADDR_VAR 0 2
56782: PUSH
56783: LD_VAR 0 1
56787: PPUSH
56788: CALL_OW 310
56792: ST_TO_ADDR
// if not result then
56793: LD_VAR 0 2
56797: NOT
56798: IFFALSE 56810
// result := unit ;
56800: LD_ADDR_VAR 0 2
56804: PUSH
56805: LD_VAR 0 1
56809: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
56810: LD_VAR 0 1
56814: PPUSH
56815: CALL_OW 87
// end ;
56819: LD_VAR 0 2
56823: RET
// export function ComMoveHex ( unit , hex ) ; begin
56824: LD_INT 0
56826: PPUSH
// if not hex then
56827: LD_VAR 0 2
56831: NOT
56832: IFFALSE 56836
// exit ;
56834: GO 56889
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
56836: LD_VAR 0 2
56840: PUSH
56841: LD_INT 1
56843: ARRAY
56844: PPUSH
56845: LD_VAR 0 2
56849: PUSH
56850: LD_INT 2
56852: ARRAY
56853: PPUSH
56854: CALL_OW 428
56858: IFFALSE 56862
// exit ;
56860: GO 56889
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
56862: LD_VAR 0 1
56866: PPUSH
56867: LD_VAR 0 2
56871: PUSH
56872: LD_INT 1
56874: ARRAY
56875: PPUSH
56876: LD_VAR 0 2
56880: PUSH
56881: LD_INT 2
56883: ARRAY
56884: PPUSH
56885: CALL_OW 111
// end ;
56889: LD_VAR 0 3
56893: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
56894: LD_INT 0
56896: PPUSH
56897: PPUSH
56898: PPUSH
// if not unit or not enemy then
56899: LD_VAR 0 1
56903: NOT
56904: PUSH
56905: LD_VAR 0 2
56909: NOT
56910: OR
56911: IFFALSE 56915
// exit ;
56913: GO 57039
// x := GetX ( enemy ) ;
56915: LD_ADDR_VAR 0 4
56919: PUSH
56920: LD_VAR 0 2
56924: PPUSH
56925: CALL_OW 250
56929: ST_TO_ADDR
// y := GetY ( enemy ) ;
56930: LD_ADDR_VAR 0 5
56934: PUSH
56935: LD_VAR 0 2
56939: PPUSH
56940: CALL_OW 251
56944: ST_TO_ADDR
// if ValidHex ( x , y ) then
56945: LD_VAR 0 4
56949: PPUSH
56950: LD_VAR 0 5
56954: PPUSH
56955: CALL_OW 488
56959: IFFALSE 57039
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
56961: LD_VAR 0 2
56965: PPUSH
56966: CALL_OW 247
56970: PUSH
56971: LD_INT 3
56973: PUSH
56974: LD_INT 2
56976: PUSH
56977: EMPTY
56978: LIST
56979: LIST
56980: IN
56981: PUSH
56982: LD_VAR 0 1
56986: PPUSH
56987: CALL_OW 255
56991: PPUSH
56992: LD_VAR 0 2
56996: PPUSH
56997: CALL_OW 292
57001: AND
57002: IFFALSE 57020
// ComAttackUnit ( unit , enemy ) else
57004: LD_VAR 0 1
57008: PPUSH
57009: LD_VAR 0 2
57013: PPUSH
57014: CALL_OW 115
57018: GO 57039
// ComAgressiveMove ( unit , x , y ) ;
57020: LD_VAR 0 1
57024: PPUSH
57025: LD_VAR 0 4
57029: PPUSH
57030: LD_VAR 0 5
57034: PPUSH
57035: CALL_OW 114
// end ; end_of_file
57039: LD_VAR 0 3
57043: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
57044: LD_INT 0
57046: PPUSH
57047: PPUSH
// skirmish := false ;
57048: LD_ADDR_EXP 59
57052: PUSH
57053: LD_INT 0
57055: ST_TO_ADDR
// debug_mc := false ;
57056: LD_ADDR_EXP 60
57060: PUSH
57061: LD_INT 0
57063: ST_TO_ADDR
// mc_bases := [ ] ;
57064: LD_ADDR_EXP 61
57068: PUSH
57069: EMPTY
57070: ST_TO_ADDR
// mc_sides := [ ] ;
57071: LD_ADDR_EXP 87
57075: PUSH
57076: EMPTY
57077: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57078: LD_ADDR_EXP 62
57082: PUSH
57083: EMPTY
57084: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57085: LD_ADDR_EXP 63
57089: PUSH
57090: EMPTY
57091: ST_TO_ADDR
// mc_need_heal := [ ] ;
57092: LD_ADDR_EXP 64
57096: PUSH
57097: EMPTY
57098: ST_TO_ADDR
// mc_healers := [ ] ;
57099: LD_ADDR_EXP 65
57103: PUSH
57104: EMPTY
57105: ST_TO_ADDR
// mc_build_list := [ ] ;
57106: LD_ADDR_EXP 66
57110: PUSH
57111: EMPTY
57112: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57113: LD_ADDR_EXP 93
57117: PUSH
57118: EMPTY
57119: ST_TO_ADDR
// mc_builders := [ ] ;
57120: LD_ADDR_EXP 67
57124: PUSH
57125: EMPTY
57126: ST_TO_ADDR
// mc_construct_list := [ ] ;
57127: LD_ADDR_EXP 68
57131: PUSH
57132: EMPTY
57133: ST_TO_ADDR
// mc_turret_list := [ ] ;
57134: LD_ADDR_EXP 69
57138: PUSH
57139: EMPTY
57140: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57141: LD_ADDR_EXP 70
57145: PUSH
57146: EMPTY
57147: ST_TO_ADDR
// mc_miners := [ ] ;
57148: LD_ADDR_EXP 75
57152: PUSH
57153: EMPTY
57154: ST_TO_ADDR
// mc_mines := [ ] ;
57155: LD_ADDR_EXP 74
57159: PUSH
57160: EMPTY
57161: ST_TO_ADDR
// mc_minefields := [ ] ;
57162: LD_ADDR_EXP 76
57166: PUSH
57167: EMPTY
57168: ST_TO_ADDR
// mc_crates := [ ] ;
57169: LD_ADDR_EXP 77
57173: PUSH
57174: EMPTY
57175: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57176: LD_ADDR_EXP 78
57180: PUSH
57181: EMPTY
57182: ST_TO_ADDR
// mc_crates_area := [ ] ;
57183: LD_ADDR_EXP 79
57187: PUSH
57188: EMPTY
57189: ST_TO_ADDR
// mc_vehicles := [ ] ;
57190: LD_ADDR_EXP 80
57194: PUSH
57195: EMPTY
57196: ST_TO_ADDR
// mc_attack := [ ] ;
57197: LD_ADDR_EXP 81
57201: PUSH
57202: EMPTY
57203: ST_TO_ADDR
// mc_produce := [ ] ;
57204: LD_ADDR_EXP 82
57208: PUSH
57209: EMPTY
57210: ST_TO_ADDR
// mc_defender := [ ] ;
57211: LD_ADDR_EXP 83
57215: PUSH
57216: EMPTY
57217: ST_TO_ADDR
// mc_parking := [ ] ;
57218: LD_ADDR_EXP 85
57222: PUSH
57223: EMPTY
57224: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57225: LD_ADDR_EXP 71
57229: PUSH
57230: EMPTY
57231: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57232: LD_ADDR_EXP 73
57236: PUSH
57237: EMPTY
57238: ST_TO_ADDR
// mc_scan := [ ] ;
57239: LD_ADDR_EXP 84
57243: PUSH
57244: EMPTY
57245: ST_TO_ADDR
// mc_scan_area := [ ] ;
57246: LD_ADDR_EXP 86
57250: PUSH
57251: EMPTY
57252: ST_TO_ADDR
// mc_tech := [ ] ;
57253: LD_ADDR_EXP 88
57257: PUSH
57258: EMPTY
57259: ST_TO_ADDR
// mc_class := [ ] ;
57260: LD_ADDR_EXP 102
57264: PUSH
57265: EMPTY
57266: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57267: LD_ADDR_EXP 103
57271: PUSH
57272: EMPTY
57273: ST_TO_ADDR
// mc_is_defending := [ ] ;
57274: LD_ADDR_EXP 104
57278: PUSH
57279: EMPTY
57280: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
57281: LD_ADDR_EXP 95
57285: PUSH
57286: EMPTY
57287: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
57288: LD_ADDR_EXP 105
57292: PUSH
57293: LD_INT 0
57295: ST_TO_ADDR
// end ;
57296: LD_VAR 0 1
57300: RET
// export function MC_Kill ( base ) ; begin
57301: LD_INT 0
57303: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57304: LD_ADDR_EXP 61
57308: PUSH
57309: LD_EXP 61
57313: PPUSH
57314: LD_VAR 0 1
57318: PPUSH
57319: EMPTY
57320: PPUSH
57321: CALL_OW 1
57325: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57326: LD_ADDR_EXP 62
57330: PUSH
57331: LD_EXP 62
57335: PPUSH
57336: LD_VAR 0 1
57340: PPUSH
57341: EMPTY
57342: PPUSH
57343: CALL_OW 1
57347: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57348: LD_ADDR_EXP 63
57352: PUSH
57353: LD_EXP 63
57357: PPUSH
57358: LD_VAR 0 1
57362: PPUSH
57363: EMPTY
57364: PPUSH
57365: CALL_OW 1
57369: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57370: LD_ADDR_EXP 64
57374: PUSH
57375: LD_EXP 64
57379: PPUSH
57380: LD_VAR 0 1
57384: PPUSH
57385: EMPTY
57386: PPUSH
57387: CALL_OW 1
57391: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57392: LD_ADDR_EXP 65
57396: PUSH
57397: LD_EXP 65
57401: PPUSH
57402: LD_VAR 0 1
57406: PPUSH
57407: EMPTY
57408: PPUSH
57409: CALL_OW 1
57413: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57414: LD_ADDR_EXP 66
57418: PUSH
57419: LD_EXP 66
57423: PPUSH
57424: LD_VAR 0 1
57428: PPUSH
57429: EMPTY
57430: PPUSH
57431: CALL_OW 1
57435: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57436: LD_ADDR_EXP 67
57440: PUSH
57441: LD_EXP 67
57445: PPUSH
57446: LD_VAR 0 1
57450: PPUSH
57451: EMPTY
57452: PPUSH
57453: CALL_OW 1
57457: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57458: LD_ADDR_EXP 68
57462: PUSH
57463: LD_EXP 68
57467: PPUSH
57468: LD_VAR 0 1
57472: PPUSH
57473: EMPTY
57474: PPUSH
57475: CALL_OW 1
57479: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57480: LD_ADDR_EXP 69
57484: PUSH
57485: LD_EXP 69
57489: PPUSH
57490: LD_VAR 0 1
57494: PPUSH
57495: EMPTY
57496: PPUSH
57497: CALL_OW 1
57501: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57502: LD_ADDR_EXP 70
57506: PUSH
57507: LD_EXP 70
57511: PPUSH
57512: LD_VAR 0 1
57516: PPUSH
57517: EMPTY
57518: PPUSH
57519: CALL_OW 1
57523: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57524: LD_ADDR_EXP 71
57528: PUSH
57529: LD_EXP 71
57533: PPUSH
57534: LD_VAR 0 1
57538: PPUSH
57539: EMPTY
57540: PPUSH
57541: CALL_OW 1
57545: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57546: LD_ADDR_EXP 72
57550: PUSH
57551: LD_EXP 72
57555: PPUSH
57556: LD_VAR 0 1
57560: PPUSH
57561: LD_INT 0
57563: PPUSH
57564: CALL_OW 1
57568: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57569: LD_ADDR_EXP 73
57573: PUSH
57574: LD_EXP 73
57578: PPUSH
57579: LD_VAR 0 1
57583: PPUSH
57584: EMPTY
57585: PPUSH
57586: CALL_OW 1
57590: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57591: LD_ADDR_EXP 74
57595: PUSH
57596: LD_EXP 74
57600: PPUSH
57601: LD_VAR 0 1
57605: PPUSH
57606: EMPTY
57607: PPUSH
57608: CALL_OW 1
57612: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57613: LD_ADDR_EXP 75
57617: PUSH
57618: LD_EXP 75
57622: PPUSH
57623: LD_VAR 0 1
57627: PPUSH
57628: EMPTY
57629: PPUSH
57630: CALL_OW 1
57634: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57635: LD_ADDR_EXP 76
57639: PUSH
57640: LD_EXP 76
57644: PPUSH
57645: LD_VAR 0 1
57649: PPUSH
57650: EMPTY
57651: PPUSH
57652: CALL_OW 1
57656: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57657: LD_ADDR_EXP 77
57661: PUSH
57662: LD_EXP 77
57666: PPUSH
57667: LD_VAR 0 1
57671: PPUSH
57672: EMPTY
57673: PPUSH
57674: CALL_OW 1
57678: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57679: LD_ADDR_EXP 78
57683: PUSH
57684: LD_EXP 78
57688: PPUSH
57689: LD_VAR 0 1
57693: PPUSH
57694: EMPTY
57695: PPUSH
57696: CALL_OW 1
57700: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57701: LD_ADDR_EXP 79
57705: PUSH
57706: LD_EXP 79
57710: PPUSH
57711: LD_VAR 0 1
57715: PPUSH
57716: EMPTY
57717: PPUSH
57718: CALL_OW 1
57722: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57723: LD_ADDR_EXP 80
57727: PUSH
57728: LD_EXP 80
57732: PPUSH
57733: LD_VAR 0 1
57737: PPUSH
57738: EMPTY
57739: PPUSH
57740: CALL_OW 1
57744: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57745: LD_ADDR_EXP 81
57749: PUSH
57750: LD_EXP 81
57754: PPUSH
57755: LD_VAR 0 1
57759: PPUSH
57760: EMPTY
57761: PPUSH
57762: CALL_OW 1
57766: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57767: LD_ADDR_EXP 82
57771: PUSH
57772: LD_EXP 82
57776: PPUSH
57777: LD_VAR 0 1
57781: PPUSH
57782: EMPTY
57783: PPUSH
57784: CALL_OW 1
57788: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57789: LD_ADDR_EXP 83
57793: PUSH
57794: LD_EXP 83
57798: PPUSH
57799: LD_VAR 0 1
57803: PPUSH
57804: EMPTY
57805: PPUSH
57806: CALL_OW 1
57810: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57811: LD_ADDR_EXP 84
57815: PUSH
57816: LD_EXP 84
57820: PPUSH
57821: LD_VAR 0 1
57825: PPUSH
57826: EMPTY
57827: PPUSH
57828: CALL_OW 1
57832: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57833: LD_ADDR_EXP 85
57837: PUSH
57838: LD_EXP 85
57842: PPUSH
57843: LD_VAR 0 1
57847: PPUSH
57848: EMPTY
57849: PPUSH
57850: CALL_OW 1
57854: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57855: LD_ADDR_EXP 86
57859: PUSH
57860: LD_EXP 86
57864: PPUSH
57865: LD_VAR 0 1
57869: PPUSH
57870: EMPTY
57871: PPUSH
57872: CALL_OW 1
57876: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57877: LD_ADDR_EXP 88
57881: PUSH
57882: LD_EXP 88
57886: PPUSH
57887: LD_VAR 0 1
57891: PPUSH
57892: EMPTY
57893: PPUSH
57894: CALL_OW 1
57898: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57899: LD_ADDR_EXP 90
57903: PUSH
57904: LD_EXP 90
57908: PPUSH
57909: LD_VAR 0 1
57913: PPUSH
57914: EMPTY
57915: PPUSH
57916: CALL_OW 1
57920: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57921: LD_ADDR_EXP 91
57925: PUSH
57926: LD_EXP 91
57930: PPUSH
57931: LD_VAR 0 1
57935: PPUSH
57936: EMPTY
57937: PPUSH
57938: CALL_OW 1
57942: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57943: LD_ADDR_EXP 92
57947: PUSH
57948: LD_EXP 92
57952: PPUSH
57953: LD_VAR 0 1
57957: PPUSH
57958: EMPTY
57959: PPUSH
57960: CALL_OW 1
57964: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57965: LD_ADDR_EXP 93
57969: PUSH
57970: LD_EXP 93
57974: PPUSH
57975: LD_VAR 0 1
57979: PPUSH
57980: EMPTY
57981: PPUSH
57982: CALL_OW 1
57986: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57987: LD_ADDR_EXP 94
57991: PUSH
57992: LD_EXP 94
57996: PPUSH
57997: LD_VAR 0 1
58001: PPUSH
58002: EMPTY
58003: PPUSH
58004: CALL_OW 1
58008: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58009: LD_ADDR_EXP 95
58013: PUSH
58014: LD_EXP 95
58018: PPUSH
58019: LD_VAR 0 1
58023: PPUSH
58024: EMPTY
58025: PPUSH
58026: CALL_OW 1
58030: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58031: LD_ADDR_EXP 96
58035: PUSH
58036: LD_EXP 96
58040: PPUSH
58041: LD_VAR 0 1
58045: PPUSH
58046: EMPTY
58047: PPUSH
58048: CALL_OW 1
58052: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58053: LD_ADDR_EXP 97
58057: PUSH
58058: LD_EXP 97
58062: PPUSH
58063: LD_VAR 0 1
58067: PPUSH
58068: EMPTY
58069: PPUSH
58070: CALL_OW 1
58074: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58075: LD_ADDR_EXP 98
58079: PUSH
58080: LD_EXP 98
58084: PPUSH
58085: LD_VAR 0 1
58089: PPUSH
58090: EMPTY
58091: PPUSH
58092: CALL_OW 1
58096: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58097: LD_ADDR_EXP 99
58101: PUSH
58102: LD_EXP 99
58106: PPUSH
58107: LD_VAR 0 1
58111: PPUSH
58112: EMPTY
58113: PPUSH
58114: CALL_OW 1
58118: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58119: LD_ADDR_EXP 100
58123: PUSH
58124: LD_EXP 100
58128: PPUSH
58129: LD_VAR 0 1
58133: PPUSH
58134: EMPTY
58135: PPUSH
58136: CALL_OW 1
58140: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58141: LD_ADDR_EXP 101
58145: PUSH
58146: LD_EXP 101
58150: PPUSH
58151: LD_VAR 0 1
58155: PPUSH
58156: EMPTY
58157: PPUSH
58158: CALL_OW 1
58162: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58163: LD_ADDR_EXP 102
58167: PUSH
58168: LD_EXP 102
58172: PPUSH
58173: LD_VAR 0 1
58177: PPUSH
58178: EMPTY
58179: PPUSH
58180: CALL_OW 1
58184: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58185: LD_ADDR_EXP 103
58189: PUSH
58190: LD_EXP 103
58194: PPUSH
58195: LD_VAR 0 1
58199: PPUSH
58200: LD_INT 0
58202: PPUSH
58203: CALL_OW 1
58207: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58208: LD_ADDR_EXP 104
58212: PUSH
58213: LD_EXP 104
58217: PPUSH
58218: LD_VAR 0 1
58222: PPUSH
58223: LD_INT 0
58225: PPUSH
58226: CALL_OW 1
58230: ST_TO_ADDR
// end ;
58231: LD_VAR 0 2
58235: RET
// export function MC_Add ( side , units ) ; var base ; begin
58236: LD_INT 0
58238: PPUSH
58239: PPUSH
// base := mc_bases + 1 ;
58240: LD_ADDR_VAR 0 4
58244: PUSH
58245: LD_EXP 61
58249: PUSH
58250: LD_INT 1
58252: PLUS
58253: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58254: LD_ADDR_EXP 87
58258: PUSH
58259: LD_EXP 87
58263: PPUSH
58264: LD_VAR 0 4
58268: PPUSH
58269: LD_VAR 0 1
58273: PPUSH
58274: CALL_OW 1
58278: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58279: LD_ADDR_EXP 61
58283: PUSH
58284: LD_EXP 61
58288: PPUSH
58289: LD_VAR 0 4
58293: PPUSH
58294: LD_VAR 0 2
58298: PPUSH
58299: CALL_OW 1
58303: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58304: LD_ADDR_EXP 62
58308: PUSH
58309: LD_EXP 62
58313: PPUSH
58314: LD_VAR 0 4
58318: PPUSH
58319: EMPTY
58320: PPUSH
58321: CALL_OW 1
58325: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58326: LD_ADDR_EXP 63
58330: PUSH
58331: LD_EXP 63
58335: PPUSH
58336: LD_VAR 0 4
58340: PPUSH
58341: EMPTY
58342: PPUSH
58343: CALL_OW 1
58347: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58348: LD_ADDR_EXP 64
58352: PUSH
58353: LD_EXP 64
58357: PPUSH
58358: LD_VAR 0 4
58362: PPUSH
58363: EMPTY
58364: PPUSH
58365: CALL_OW 1
58369: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58370: LD_ADDR_EXP 65
58374: PUSH
58375: LD_EXP 65
58379: PPUSH
58380: LD_VAR 0 4
58384: PPUSH
58385: EMPTY
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58392: LD_ADDR_EXP 66
58396: PUSH
58397: LD_EXP 66
58401: PPUSH
58402: LD_VAR 0 4
58406: PPUSH
58407: EMPTY
58408: PPUSH
58409: CALL_OW 1
58413: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58414: LD_ADDR_EXP 67
58418: PUSH
58419: LD_EXP 67
58423: PPUSH
58424: LD_VAR 0 4
58428: PPUSH
58429: EMPTY
58430: PPUSH
58431: CALL_OW 1
58435: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58436: LD_ADDR_EXP 68
58440: PUSH
58441: LD_EXP 68
58445: PPUSH
58446: LD_VAR 0 4
58450: PPUSH
58451: EMPTY
58452: PPUSH
58453: CALL_OW 1
58457: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58458: LD_ADDR_EXP 69
58462: PUSH
58463: LD_EXP 69
58467: PPUSH
58468: LD_VAR 0 4
58472: PPUSH
58473: EMPTY
58474: PPUSH
58475: CALL_OW 1
58479: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58480: LD_ADDR_EXP 70
58484: PUSH
58485: LD_EXP 70
58489: PPUSH
58490: LD_VAR 0 4
58494: PPUSH
58495: EMPTY
58496: PPUSH
58497: CALL_OW 1
58501: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58502: LD_ADDR_EXP 71
58506: PUSH
58507: LD_EXP 71
58511: PPUSH
58512: LD_VAR 0 4
58516: PPUSH
58517: EMPTY
58518: PPUSH
58519: CALL_OW 1
58523: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58524: LD_ADDR_EXP 72
58528: PUSH
58529: LD_EXP 72
58533: PPUSH
58534: LD_VAR 0 4
58538: PPUSH
58539: LD_INT 0
58541: PPUSH
58542: CALL_OW 1
58546: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58547: LD_ADDR_EXP 73
58551: PUSH
58552: LD_EXP 73
58556: PPUSH
58557: LD_VAR 0 4
58561: PPUSH
58562: EMPTY
58563: PPUSH
58564: CALL_OW 1
58568: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58569: LD_ADDR_EXP 74
58573: PUSH
58574: LD_EXP 74
58578: PPUSH
58579: LD_VAR 0 4
58583: PPUSH
58584: EMPTY
58585: PPUSH
58586: CALL_OW 1
58590: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58591: LD_ADDR_EXP 75
58595: PUSH
58596: LD_EXP 75
58600: PPUSH
58601: LD_VAR 0 4
58605: PPUSH
58606: EMPTY
58607: PPUSH
58608: CALL_OW 1
58612: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58613: LD_ADDR_EXP 76
58617: PUSH
58618: LD_EXP 76
58622: PPUSH
58623: LD_VAR 0 4
58627: PPUSH
58628: EMPTY
58629: PPUSH
58630: CALL_OW 1
58634: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58635: LD_ADDR_EXP 77
58639: PUSH
58640: LD_EXP 77
58644: PPUSH
58645: LD_VAR 0 4
58649: PPUSH
58650: EMPTY
58651: PPUSH
58652: CALL_OW 1
58656: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58657: LD_ADDR_EXP 78
58661: PUSH
58662: LD_EXP 78
58666: PPUSH
58667: LD_VAR 0 4
58671: PPUSH
58672: EMPTY
58673: PPUSH
58674: CALL_OW 1
58678: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58679: LD_ADDR_EXP 79
58683: PUSH
58684: LD_EXP 79
58688: PPUSH
58689: LD_VAR 0 4
58693: PPUSH
58694: EMPTY
58695: PPUSH
58696: CALL_OW 1
58700: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58701: LD_ADDR_EXP 80
58705: PUSH
58706: LD_EXP 80
58710: PPUSH
58711: LD_VAR 0 4
58715: PPUSH
58716: EMPTY
58717: PPUSH
58718: CALL_OW 1
58722: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58723: LD_ADDR_EXP 81
58727: PUSH
58728: LD_EXP 81
58732: PPUSH
58733: LD_VAR 0 4
58737: PPUSH
58738: EMPTY
58739: PPUSH
58740: CALL_OW 1
58744: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58745: LD_ADDR_EXP 82
58749: PUSH
58750: LD_EXP 82
58754: PPUSH
58755: LD_VAR 0 4
58759: PPUSH
58760: EMPTY
58761: PPUSH
58762: CALL_OW 1
58766: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58767: LD_ADDR_EXP 83
58771: PUSH
58772: LD_EXP 83
58776: PPUSH
58777: LD_VAR 0 4
58781: PPUSH
58782: EMPTY
58783: PPUSH
58784: CALL_OW 1
58788: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58789: LD_ADDR_EXP 84
58793: PUSH
58794: LD_EXP 84
58798: PPUSH
58799: LD_VAR 0 4
58803: PPUSH
58804: EMPTY
58805: PPUSH
58806: CALL_OW 1
58810: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58811: LD_ADDR_EXP 85
58815: PUSH
58816: LD_EXP 85
58820: PPUSH
58821: LD_VAR 0 4
58825: PPUSH
58826: EMPTY
58827: PPUSH
58828: CALL_OW 1
58832: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58833: LD_ADDR_EXP 86
58837: PUSH
58838: LD_EXP 86
58842: PPUSH
58843: LD_VAR 0 4
58847: PPUSH
58848: EMPTY
58849: PPUSH
58850: CALL_OW 1
58854: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58855: LD_ADDR_EXP 88
58859: PUSH
58860: LD_EXP 88
58864: PPUSH
58865: LD_VAR 0 4
58869: PPUSH
58870: EMPTY
58871: PPUSH
58872: CALL_OW 1
58876: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58877: LD_ADDR_EXP 90
58881: PUSH
58882: LD_EXP 90
58886: PPUSH
58887: LD_VAR 0 4
58891: PPUSH
58892: EMPTY
58893: PPUSH
58894: CALL_OW 1
58898: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58899: LD_ADDR_EXP 91
58903: PUSH
58904: LD_EXP 91
58908: PPUSH
58909: LD_VAR 0 4
58913: PPUSH
58914: EMPTY
58915: PPUSH
58916: CALL_OW 1
58920: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58921: LD_ADDR_EXP 92
58925: PUSH
58926: LD_EXP 92
58930: PPUSH
58931: LD_VAR 0 4
58935: PPUSH
58936: EMPTY
58937: PPUSH
58938: CALL_OW 1
58942: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58943: LD_ADDR_EXP 93
58947: PUSH
58948: LD_EXP 93
58952: PPUSH
58953: LD_VAR 0 4
58957: PPUSH
58958: EMPTY
58959: PPUSH
58960: CALL_OW 1
58964: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58965: LD_ADDR_EXP 94
58969: PUSH
58970: LD_EXP 94
58974: PPUSH
58975: LD_VAR 0 4
58979: PPUSH
58980: EMPTY
58981: PPUSH
58982: CALL_OW 1
58986: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58987: LD_ADDR_EXP 95
58991: PUSH
58992: LD_EXP 95
58996: PPUSH
58997: LD_VAR 0 4
59001: PPUSH
59002: EMPTY
59003: PPUSH
59004: CALL_OW 1
59008: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59009: LD_ADDR_EXP 96
59013: PUSH
59014: LD_EXP 96
59018: PPUSH
59019: LD_VAR 0 4
59023: PPUSH
59024: EMPTY
59025: PPUSH
59026: CALL_OW 1
59030: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59031: LD_ADDR_EXP 97
59035: PUSH
59036: LD_EXP 97
59040: PPUSH
59041: LD_VAR 0 4
59045: PPUSH
59046: EMPTY
59047: PPUSH
59048: CALL_OW 1
59052: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59053: LD_ADDR_EXP 98
59057: PUSH
59058: LD_EXP 98
59062: PPUSH
59063: LD_VAR 0 4
59067: PPUSH
59068: EMPTY
59069: PPUSH
59070: CALL_OW 1
59074: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59075: LD_ADDR_EXP 99
59079: PUSH
59080: LD_EXP 99
59084: PPUSH
59085: LD_VAR 0 4
59089: PPUSH
59090: EMPTY
59091: PPUSH
59092: CALL_OW 1
59096: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59097: LD_ADDR_EXP 100
59101: PUSH
59102: LD_EXP 100
59106: PPUSH
59107: LD_VAR 0 4
59111: PPUSH
59112: EMPTY
59113: PPUSH
59114: CALL_OW 1
59118: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59119: LD_ADDR_EXP 101
59123: PUSH
59124: LD_EXP 101
59128: PPUSH
59129: LD_VAR 0 4
59133: PPUSH
59134: EMPTY
59135: PPUSH
59136: CALL_OW 1
59140: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59141: LD_ADDR_EXP 102
59145: PUSH
59146: LD_EXP 102
59150: PPUSH
59151: LD_VAR 0 4
59155: PPUSH
59156: EMPTY
59157: PPUSH
59158: CALL_OW 1
59162: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59163: LD_ADDR_EXP 103
59167: PUSH
59168: LD_EXP 103
59172: PPUSH
59173: LD_VAR 0 4
59177: PPUSH
59178: LD_INT 0
59180: PPUSH
59181: CALL_OW 1
59185: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
59186: LD_ADDR_EXP 104
59190: PUSH
59191: LD_EXP 104
59195: PPUSH
59196: LD_VAR 0 4
59200: PPUSH
59201: LD_INT 0
59203: PPUSH
59204: CALL_OW 1
59208: ST_TO_ADDR
// result := base ;
59209: LD_ADDR_VAR 0 3
59213: PUSH
59214: LD_VAR 0 4
59218: ST_TO_ADDR
// end ;
59219: LD_VAR 0 3
59223: RET
// export function MC_Start ( ) ; var i ; begin
59224: LD_INT 0
59226: PPUSH
59227: PPUSH
// for i = 1 to mc_bases do
59228: LD_ADDR_VAR 0 2
59232: PUSH
59233: DOUBLE
59234: LD_INT 1
59236: DEC
59237: ST_TO_ADDR
59238: LD_EXP 61
59242: PUSH
59243: FOR_TO
59244: IFFALSE 60344
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59246: LD_ADDR_EXP 61
59250: PUSH
59251: LD_EXP 61
59255: PPUSH
59256: LD_VAR 0 2
59260: PPUSH
59261: LD_EXP 61
59265: PUSH
59266: LD_VAR 0 2
59270: ARRAY
59271: PUSH
59272: LD_INT 0
59274: DIFF
59275: PPUSH
59276: CALL_OW 1
59280: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59281: LD_ADDR_EXP 62
59285: PUSH
59286: LD_EXP 62
59290: PPUSH
59291: LD_VAR 0 2
59295: PPUSH
59296: EMPTY
59297: PPUSH
59298: CALL_OW 1
59302: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59303: LD_ADDR_EXP 63
59307: PUSH
59308: LD_EXP 63
59312: PPUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: EMPTY
59319: PPUSH
59320: CALL_OW 1
59324: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59325: LD_ADDR_EXP 64
59329: PUSH
59330: LD_EXP 64
59334: PPUSH
59335: LD_VAR 0 2
59339: PPUSH
59340: EMPTY
59341: PPUSH
59342: CALL_OW 1
59346: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59347: LD_ADDR_EXP 65
59351: PUSH
59352: LD_EXP 65
59356: PPUSH
59357: LD_VAR 0 2
59361: PPUSH
59362: EMPTY
59363: PUSH
59364: EMPTY
59365: PUSH
59366: EMPTY
59367: LIST
59368: LIST
59369: PPUSH
59370: CALL_OW 1
59374: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59375: LD_ADDR_EXP 66
59379: PUSH
59380: LD_EXP 66
59384: PPUSH
59385: LD_VAR 0 2
59389: PPUSH
59390: EMPTY
59391: PPUSH
59392: CALL_OW 1
59396: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59397: LD_ADDR_EXP 93
59401: PUSH
59402: LD_EXP 93
59406: PPUSH
59407: LD_VAR 0 2
59411: PPUSH
59412: EMPTY
59413: PPUSH
59414: CALL_OW 1
59418: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59419: LD_ADDR_EXP 67
59423: PUSH
59424: LD_EXP 67
59428: PPUSH
59429: LD_VAR 0 2
59433: PPUSH
59434: EMPTY
59435: PPUSH
59436: CALL_OW 1
59440: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59441: LD_ADDR_EXP 68
59445: PUSH
59446: LD_EXP 68
59450: PPUSH
59451: LD_VAR 0 2
59455: PPUSH
59456: EMPTY
59457: PPUSH
59458: CALL_OW 1
59462: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59463: LD_ADDR_EXP 69
59467: PUSH
59468: LD_EXP 69
59472: PPUSH
59473: LD_VAR 0 2
59477: PPUSH
59478: LD_EXP 61
59482: PUSH
59483: LD_VAR 0 2
59487: ARRAY
59488: PPUSH
59489: LD_INT 2
59491: PUSH
59492: LD_INT 30
59494: PUSH
59495: LD_INT 32
59497: PUSH
59498: EMPTY
59499: LIST
59500: LIST
59501: PUSH
59502: LD_INT 30
59504: PUSH
59505: LD_INT 33
59507: PUSH
59508: EMPTY
59509: LIST
59510: LIST
59511: PUSH
59512: EMPTY
59513: LIST
59514: LIST
59515: LIST
59516: PPUSH
59517: CALL_OW 72
59521: PPUSH
59522: CALL_OW 1
59526: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59527: LD_ADDR_EXP 70
59531: PUSH
59532: LD_EXP 70
59536: PPUSH
59537: LD_VAR 0 2
59541: PPUSH
59542: LD_EXP 61
59546: PUSH
59547: LD_VAR 0 2
59551: ARRAY
59552: PPUSH
59553: LD_INT 2
59555: PUSH
59556: LD_INT 30
59558: PUSH
59559: LD_INT 32
59561: PUSH
59562: EMPTY
59563: LIST
59564: LIST
59565: PUSH
59566: LD_INT 30
59568: PUSH
59569: LD_INT 31
59571: PUSH
59572: EMPTY
59573: LIST
59574: LIST
59575: PUSH
59576: EMPTY
59577: LIST
59578: LIST
59579: LIST
59580: PUSH
59581: LD_INT 58
59583: PUSH
59584: EMPTY
59585: LIST
59586: PUSH
59587: EMPTY
59588: LIST
59589: LIST
59590: PPUSH
59591: CALL_OW 72
59595: PPUSH
59596: CALL_OW 1
59600: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59601: LD_ADDR_EXP 71
59605: PUSH
59606: LD_EXP 71
59610: PPUSH
59611: LD_VAR 0 2
59615: PPUSH
59616: EMPTY
59617: PPUSH
59618: CALL_OW 1
59622: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59623: LD_ADDR_EXP 75
59627: PUSH
59628: LD_EXP 75
59632: PPUSH
59633: LD_VAR 0 2
59637: PPUSH
59638: EMPTY
59639: PPUSH
59640: CALL_OW 1
59644: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59645: LD_ADDR_EXP 74
59649: PUSH
59650: LD_EXP 74
59654: PPUSH
59655: LD_VAR 0 2
59659: PPUSH
59660: EMPTY
59661: PPUSH
59662: CALL_OW 1
59666: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59667: LD_ADDR_EXP 76
59671: PUSH
59672: LD_EXP 76
59676: PPUSH
59677: LD_VAR 0 2
59681: PPUSH
59682: EMPTY
59683: PPUSH
59684: CALL_OW 1
59688: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59689: LD_ADDR_EXP 77
59693: PUSH
59694: LD_EXP 77
59698: PPUSH
59699: LD_VAR 0 2
59703: PPUSH
59704: EMPTY
59705: PPUSH
59706: CALL_OW 1
59710: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59711: LD_ADDR_EXP 78
59715: PUSH
59716: LD_EXP 78
59720: PPUSH
59721: LD_VAR 0 2
59725: PPUSH
59726: EMPTY
59727: PPUSH
59728: CALL_OW 1
59732: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59733: LD_ADDR_EXP 79
59737: PUSH
59738: LD_EXP 79
59742: PPUSH
59743: LD_VAR 0 2
59747: PPUSH
59748: EMPTY
59749: PPUSH
59750: CALL_OW 1
59754: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59755: LD_ADDR_EXP 80
59759: PUSH
59760: LD_EXP 80
59764: PPUSH
59765: LD_VAR 0 2
59769: PPUSH
59770: EMPTY
59771: PPUSH
59772: CALL_OW 1
59776: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59777: LD_ADDR_EXP 81
59781: PUSH
59782: LD_EXP 81
59786: PPUSH
59787: LD_VAR 0 2
59791: PPUSH
59792: EMPTY
59793: PPUSH
59794: CALL_OW 1
59798: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59799: LD_ADDR_EXP 82
59803: PUSH
59804: LD_EXP 82
59808: PPUSH
59809: LD_VAR 0 2
59813: PPUSH
59814: EMPTY
59815: PPUSH
59816: CALL_OW 1
59820: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59821: LD_ADDR_EXP 83
59825: PUSH
59826: LD_EXP 83
59830: PPUSH
59831: LD_VAR 0 2
59835: PPUSH
59836: EMPTY
59837: PPUSH
59838: CALL_OW 1
59842: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59843: LD_ADDR_EXP 72
59847: PUSH
59848: LD_EXP 72
59852: PPUSH
59853: LD_VAR 0 2
59857: PPUSH
59858: LD_INT 0
59860: PPUSH
59861: CALL_OW 1
59865: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59866: LD_ADDR_EXP 85
59870: PUSH
59871: LD_EXP 85
59875: PPUSH
59876: LD_VAR 0 2
59880: PPUSH
59881: LD_INT 0
59883: PPUSH
59884: CALL_OW 1
59888: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59889: LD_ADDR_EXP 73
59893: PUSH
59894: LD_EXP 73
59898: PPUSH
59899: LD_VAR 0 2
59903: PPUSH
59904: EMPTY
59905: PPUSH
59906: CALL_OW 1
59910: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59911: LD_ADDR_EXP 84
59915: PUSH
59916: LD_EXP 84
59920: PPUSH
59921: LD_VAR 0 2
59925: PPUSH
59926: LD_INT 0
59928: PPUSH
59929: CALL_OW 1
59933: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59934: LD_ADDR_EXP 86
59938: PUSH
59939: LD_EXP 86
59943: PPUSH
59944: LD_VAR 0 2
59948: PPUSH
59949: EMPTY
59950: PPUSH
59951: CALL_OW 1
59955: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59956: LD_ADDR_EXP 89
59960: PUSH
59961: LD_EXP 89
59965: PPUSH
59966: LD_VAR 0 2
59970: PPUSH
59971: LD_INT 0
59973: PPUSH
59974: CALL_OW 1
59978: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59979: LD_ADDR_EXP 90
59983: PUSH
59984: LD_EXP 90
59988: PPUSH
59989: LD_VAR 0 2
59993: PPUSH
59994: EMPTY
59995: PPUSH
59996: CALL_OW 1
60000: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60001: LD_ADDR_EXP 91
60005: PUSH
60006: LD_EXP 91
60010: PPUSH
60011: LD_VAR 0 2
60015: PPUSH
60016: EMPTY
60017: PPUSH
60018: CALL_OW 1
60022: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60023: LD_ADDR_EXP 92
60027: PUSH
60028: LD_EXP 92
60032: PPUSH
60033: LD_VAR 0 2
60037: PPUSH
60038: EMPTY
60039: PPUSH
60040: CALL_OW 1
60044: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60045: LD_ADDR_EXP 94
60049: PUSH
60050: LD_EXP 94
60054: PPUSH
60055: LD_VAR 0 2
60059: PPUSH
60060: LD_EXP 61
60064: PUSH
60065: LD_VAR 0 2
60069: ARRAY
60070: PPUSH
60071: LD_INT 2
60073: PUSH
60074: LD_INT 30
60076: PUSH
60077: LD_INT 6
60079: PUSH
60080: EMPTY
60081: LIST
60082: LIST
60083: PUSH
60084: LD_INT 30
60086: PUSH
60087: LD_INT 7
60089: PUSH
60090: EMPTY
60091: LIST
60092: LIST
60093: PUSH
60094: LD_INT 30
60096: PUSH
60097: LD_INT 8
60099: PUSH
60100: EMPTY
60101: LIST
60102: LIST
60103: PUSH
60104: EMPTY
60105: LIST
60106: LIST
60107: LIST
60108: LIST
60109: PPUSH
60110: CALL_OW 72
60114: PPUSH
60115: CALL_OW 1
60119: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60120: LD_ADDR_EXP 95
60124: PUSH
60125: LD_EXP 95
60129: PPUSH
60130: LD_VAR 0 2
60134: PPUSH
60135: EMPTY
60136: PPUSH
60137: CALL_OW 1
60141: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60142: LD_ADDR_EXP 96
60146: PUSH
60147: LD_EXP 96
60151: PPUSH
60152: LD_VAR 0 2
60156: PPUSH
60157: EMPTY
60158: PPUSH
60159: CALL_OW 1
60163: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60164: LD_ADDR_EXP 97
60168: PUSH
60169: LD_EXP 97
60173: PPUSH
60174: LD_VAR 0 2
60178: PPUSH
60179: EMPTY
60180: PPUSH
60181: CALL_OW 1
60185: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60186: LD_ADDR_EXP 98
60190: PUSH
60191: LD_EXP 98
60195: PPUSH
60196: LD_VAR 0 2
60200: PPUSH
60201: EMPTY
60202: PPUSH
60203: CALL_OW 1
60207: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60208: LD_ADDR_EXP 99
60212: PUSH
60213: LD_EXP 99
60217: PPUSH
60218: LD_VAR 0 2
60222: PPUSH
60223: EMPTY
60224: PPUSH
60225: CALL_OW 1
60229: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60230: LD_ADDR_EXP 100
60234: PUSH
60235: LD_EXP 100
60239: PPUSH
60240: LD_VAR 0 2
60244: PPUSH
60245: EMPTY
60246: PPUSH
60247: CALL_OW 1
60251: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60252: LD_ADDR_EXP 101
60256: PUSH
60257: LD_EXP 101
60261: PPUSH
60262: LD_VAR 0 2
60266: PPUSH
60267: EMPTY
60268: PPUSH
60269: CALL_OW 1
60273: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60274: LD_ADDR_EXP 102
60278: PUSH
60279: LD_EXP 102
60283: PPUSH
60284: LD_VAR 0 2
60288: PPUSH
60289: EMPTY
60290: PPUSH
60291: CALL_OW 1
60295: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60296: LD_ADDR_EXP 103
60300: PUSH
60301: LD_EXP 103
60305: PPUSH
60306: LD_VAR 0 2
60310: PPUSH
60311: LD_INT 0
60313: PPUSH
60314: CALL_OW 1
60318: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
60319: LD_ADDR_EXP 104
60323: PUSH
60324: LD_EXP 104
60328: PPUSH
60329: LD_VAR 0 2
60333: PPUSH
60334: LD_INT 0
60336: PPUSH
60337: CALL_OW 1
60341: ST_TO_ADDR
// end ;
60342: GO 59243
60344: POP
60345: POP
// MC_InitSides ( ) ;
60346: CALL 60632 0 0
// MC_InitResearch ( ) ;
60350: CALL 60371 0 0
// CustomInitMacro ( ) ;
60354: CALL 219 0 0
// skirmish := true ;
60358: LD_ADDR_EXP 59
60362: PUSH
60363: LD_INT 1
60365: ST_TO_ADDR
// end ;
60366: LD_VAR 0 1
60370: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60371: LD_INT 0
60373: PPUSH
60374: PPUSH
60375: PPUSH
60376: PPUSH
60377: PPUSH
60378: PPUSH
// if not mc_bases then
60379: LD_EXP 61
60383: NOT
60384: IFFALSE 60388
// exit ;
60386: GO 60627
// for i = 1 to 8 do
60388: LD_ADDR_VAR 0 2
60392: PUSH
60393: DOUBLE
60394: LD_INT 1
60396: DEC
60397: ST_TO_ADDR
60398: LD_INT 8
60400: PUSH
60401: FOR_TO
60402: IFFALSE 60428
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60404: LD_ADDR_EXP 88
60408: PUSH
60409: LD_EXP 88
60413: PPUSH
60414: LD_VAR 0 2
60418: PPUSH
60419: EMPTY
60420: PPUSH
60421: CALL_OW 1
60425: ST_TO_ADDR
60426: GO 60401
60428: POP
60429: POP
// tmp := [ ] ;
60430: LD_ADDR_VAR 0 5
60434: PUSH
60435: EMPTY
60436: ST_TO_ADDR
// for i = 1 to mc_sides do
60437: LD_ADDR_VAR 0 2
60441: PUSH
60442: DOUBLE
60443: LD_INT 1
60445: DEC
60446: ST_TO_ADDR
60447: LD_EXP 87
60451: PUSH
60452: FOR_TO
60453: IFFALSE 60511
// if not mc_sides [ i ] in tmp then
60455: LD_EXP 87
60459: PUSH
60460: LD_VAR 0 2
60464: ARRAY
60465: PUSH
60466: LD_VAR 0 5
60470: IN
60471: NOT
60472: IFFALSE 60509
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60474: LD_ADDR_VAR 0 5
60478: PUSH
60479: LD_VAR 0 5
60483: PPUSH
60484: LD_VAR 0 5
60488: PUSH
60489: LD_INT 1
60491: PLUS
60492: PPUSH
60493: LD_EXP 87
60497: PUSH
60498: LD_VAR 0 2
60502: ARRAY
60503: PPUSH
60504: CALL_OW 2
60508: ST_TO_ADDR
60509: GO 60452
60511: POP
60512: POP
// if not tmp then
60513: LD_VAR 0 5
60517: NOT
60518: IFFALSE 60522
// exit ;
60520: GO 60627
// for j in tmp do
60522: LD_ADDR_VAR 0 3
60526: PUSH
60527: LD_VAR 0 5
60531: PUSH
60532: FOR_IN
60533: IFFALSE 60625
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60535: LD_ADDR_VAR 0 6
60539: PUSH
60540: LD_INT 22
60542: PUSH
60543: LD_VAR 0 3
60547: PUSH
60548: EMPTY
60549: LIST
60550: LIST
60551: PPUSH
60552: CALL_OW 69
60556: ST_TO_ADDR
// if not un then
60557: LD_VAR 0 6
60561: NOT
60562: IFFALSE 60566
// continue ;
60564: GO 60532
// nation := GetNation ( un [ 1 ] ) ;
60566: LD_ADDR_VAR 0 4
60570: PUSH
60571: LD_VAR 0 6
60575: PUSH
60576: LD_INT 1
60578: ARRAY
60579: PPUSH
60580: CALL_OW 248
60584: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60585: LD_ADDR_EXP 88
60589: PUSH
60590: LD_EXP 88
60594: PPUSH
60595: LD_VAR 0 3
60599: PPUSH
60600: LD_VAR 0 3
60604: PPUSH
60605: LD_VAR 0 4
60609: PPUSH
60610: LD_INT 1
60612: PPUSH
60613: CALL 15564 0 3
60617: PPUSH
60618: CALL_OW 1
60622: ST_TO_ADDR
// end ;
60623: GO 60532
60625: POP
60626: POP
// end ;
60627: LD_VAR 0 1
60631: RET
// export function MC_InitSides ( ) ; var i ; begin
60632: LD_INT 0
60634: PPUSH
60635: PPUSH
// if not mc_bases then
60636: LD_EXP 61
60640: NOT
60641: IFFALSE 60645
// exit ;
60643: GO 60719
// for i = 1 to mc_bases do
60645: LD_ADDR_VAR 0 2
60649: PUSH
60650: DOUBLE
60651: LD_INT 1
60653: DEC
60654: ST_TO_ADDR
60655: LD_EXP 61
60659: PUSH
60660: FOR_TO
60661: IFFALSE 60717
// if mc_bases [ i ] then
60663: LD_EXP 61
60667: PUSH
60668: LD_VAR 0 2
60672: ARRAY
60673: IFFALSE 60715
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60675: LD_ADDR_EXP 87
60679: PUSH
60680: LD_EXP 87
60684: PPUSH
60685: LD_VAR 0 2
60689: PPUSH
60690: LD_EXP 61
60694: PUSH
60695: LD_VAR 0 2
60699: ARRAY
60700: PUSH
60701: LD_INT 1
60703: ARRAY
60704: PPUSH
60705: CALL_OW 255
60709: PPUSH
60710: CALL_OW 1
60714: ST_TO_ADDR
60715: GO 60660
60717: POP
60718: POP
// end ;
60719: LD_VAR 0 1
60723: RET
// every 0 0$03 trigger skirmish do
60724: LD_EXP 59
60728: IFFALSE 60882
60730: GO 60732
60732: DISABLE
// begin enable ;
60733: ENABLE
// MC_CheckBuildings ( ) ;
60734: CALL 65394 0 0
// MC_CheckPeopleLife ( ) ;
60738: CALL 65555 0 0
// RaiseSailEvent ( 100 ) ;
60742: LD_INT 100
60744: PPUSH
60745: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60749: LD_INT 103
60751: PPUSH
60752: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60756: LD_INT 104
60758: PPUSH
60759: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60763: LD_INT 105
60765: PPUSH
60766: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60770: LD_INT 106
60772: PPUSH
60773: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60777: LD_INT 107
60779: PPUSH
60780: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60784: LD_INT 108
60786: PPUSH
60787: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60791: LD_INT 109
60793: PPUSH
60794: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60798: LD_INT 110
60800: PPUSH
60801: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60805: LD_INT 111
60807: PPUSH
60808: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60812: LD_INT 112
60814: PPUSH
60815: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60819: LD_INT 113
60821: PPUSH
60822: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60826: LD_INT 120
60828: PPUSH
60829: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60833: LD_INT 121
60835: PPUSH
60836: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60840: LD_INT 122
60842: PPUSH
60843: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60847: LD_INT 123
60849: PPUSH
60850: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60854: LD_INT 124
60856: PPUSH
60857: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60861: LD_INT 125
60863: PPUSH
60864: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60868: LD_INT 126
60870: PPUSH
60871: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60875: LD_INT 200
60877: PPUSH
60878: CALL_OW 427
// end ;
60882: END
// on SailEvent ( event ) do begin if event < 100 then
60883: LD_VAR 0 1
60887: PUSH
60888: LD_INT 100
60890: LESS
60891: IFFALSE 60902
// CustomEvent ( event ) ;
60893: LD_VAR 0 1
60897: PPUSH
60898: CALL 14179 0 1
// if event = 100 then
60902: LD_VAR 0 1
60906: PUSH
60907: LD_INT 100
60909: EQUAL
60910: IFFALSE 60916
// MC_ClassManager ( ) ;
60912: CALL 61308 0 0
// if event = 101 then
60916: LD_VAR 0 1
60920: PUSH
60921: LD_INT 101
60923: EQUAL
60924: IFFALSE 60930
// MC_RepairBuildings ( ) ;
60926: CALL 66140 0 0
// if event = 102 then
60930: LD_VAR 0 1
60934: PUSH
60935: LD_INT 102
60937: EQUAL
60938: IFFALSE 60944
// MC_Heal ( ) ;
60940: CALL 67075 0 0
// if event = 103 then
60944: LD_VAR 0 1
60948: PUSH
60949: LD_INT 103
60951: EQUAL
60952: IFFALSE 60958
// MC_Build ( ) ;
60954: CALL 67497 0 0
// if event = 104 then
60958: LD_VAR 0 1
60962: PUSH
60963: LD_INT 104
60965: EQUAL
60966: IFFALSE 60972
// MC_TurretWeapon ( ) ;
60968: CALL 69131 0 0
// if event = 105 then
60972: LD_VAR 0 1
60976: PUSH
60977: LD_INT 105
60979: EQUAL
60980: IFFALSE 60986
// MC_BuildUpgrade ( ) ;
60982: CALL 68682 0 0
// if event = 106 then
60986: LD_VAR 0 1
60990: PUSH
60991: LD_INT 106
60993: EQUAL
60994: IFFALSE 61000
// MC_PlantMines ( ) ;
60996: CALL 69561 0 0
// if event = 107 then
61000: LD_VAR 0 1
61004: PUSH
61005: LD_INT 107
61007: EQUAL
61008: IFFALSE 61014
// MC_CollectCrates ( ) ;
61010: CALL 70359 0 0
// if event = 108 then
61014: LD_VAR 0 1
61018: PUSH
61019: LD_INT 108
61021: EQUAL
61022: IFFALSE 61028
// MC_LinkRemoteControl ( ) ;
61024: CALL 72209 0 0
// if event = 109 then
61028: LD_VAR 0 1
61032: PUSH
61033: LD_INT 109
61035: EQUAL
61036: IFFALSE 61042
// MC_ProduceVehicle ( ) ;
61038: CALL 72390 0 0
// if event = 110 then
61042: LD_VAR 0 1
61046: PUSH
61047: LD_INT 110
61049: EQUAL
61050: IFFALSE 61056
// MC_SendAttack ( ) ;
61052: CALL 72856 0 0
// if event = 111 then
61056: LD_VAR 0 1
61060: PUSH
61061: LD_INT 111
61063: EQUAL
61064: IFFALSE 61070
// MC_Defend ( ) ;
61066: CALL 72964 0 0
// if event = 112 then
61070: LD_VAR 0 1
61074: PUSH
61075: LD_INT 112
61077: EQUAL
61078: IFFALSE 61084
// MC_Research ( ) ;
61080: CALL 73844 0 0
// if event = 113 then
61084: LD_VAR 0 1
61088: PUSH
61089: LD_INT 113
61091: EQUAL
61092: IFFALSE 61098
// MC_MinesTrigger ( ) ;
61094: CALL 74958 0 0
// if event = 120 then
61098: LD_VAR 0 1
61102: PUSH
61103: LD_INT 120
61105: EQUAL
61106: IFFALSE 61112
// MC_RepairVehicle ( ) ;
61108: CALL 75057 0 0
// if event = 121 then
61112: LD_VAR 0 1
61116: PUSH
61117: LD_INT 121
61119: EQUAL
61120: IFFALSE 61126
// MC_TameApe ( ) ;
61122: CALL 75826 0 0
// if event = 122 then
61126: LD_VAR 0 1
61130: PUSH
61131: LD_INT 122
61133: EQUAL
61134: IFFALSE 61140
// MC_ChangeApeClass ( ) ;
61136: CALL 76655 0 0
// if event = 123 then
61140: LD_VAR 0 1
61144: PUSH
61145: LD_INT 123
61147: EQUAL
61148: IFFALSE 61154
// MC_Bazooka ( ) ;
61150: CALL 77305 0 0
// if event = 124 then
61154: LD_VAR 0 1
61158: PUSH
61159: LD_INT 124
61161: EQUAL
61162: IFFALSE 61168
// MC_TeleportExit ( ) ;
61164: CALL 77503 0 0
// if event = 125 then
61168: LD_VAR 0 1
61172: PUSH
61173: LD_INT 125
61175: EQUAL
61176: IFFALSE 61182
// MC_Deposits ( ) ;
61178: CALL 78150 0 0
// if event = 126 then
61182: LD_VAR 0 1
61186: PUSH
61187: LD_INT 126
61189: EQUAL
61190: IFFALSE 61196
// MC_RemoteDriver ( ) ;
61192: CALL 78775 0 0
// if event = 200 then
61196: LD_VAR 0 1
61200: PUSH
61201: LD_INT 200
61203: EQUAL
61204: IFFALSE 61210
// MC_Idle ( ) ;
61206: CALL 80682 0 0
// end ;
61210: PPOPN 1
61212: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61213: LD_INT 0
61215: PPUSH
61216: PPUSH
// if not mc_bases [ base ] or not tag then
61217: LD_EXP 61
61221: PUSH
61222: LD_VAR 0 1
61226: ARRAY
61227: NOT
61228: PUSH
61229: LD_VAR 0 2
61233: NOT
61234: OR
61235: IFFALSE 61239
// exit ;
61237: GO 61303
// for i in mc_bases [ base ] union mc_ape [ base ] do
61239: LD_ADDR_VAR 0 4
61243: PUSH
61244: LD_EXP 61
61248: PUSH
61249: LD_VAR 0 1
61253: ARRAY
61254: PUSH
61255: LD_EXP 90
61259: PUSH
61260: LD_VAR 0 1
61264: ARRAY
61265: UNION
61266: PUSH
61267: FOR_IN
61268: IFFALSE 61301
// if GetTag ( i ) = tag then
61270: LD_VAR 0 4
61274: PPUSH
61275: CALL_OW 110
61279: PUSH
61280: LD_VAR 0 2
61284: EQUAL
61285: IFFALSE 61299
// SetTag ( i , 0 ) ;
61287: LD_VAR 0 4
61291: PPUSH
61292: LD_INT 0
61294: PPUSH
61295: CALL_OW 109
61299: GO 61267
61301: POP
61302: POP
// end ;
61303: LD_VAR 0 3
61307: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61308: LD_INT 0
61310: PPUSH
61311: PPUSH
61312: PPUSH
61313: PPUSH
61314: PPUSH
61315: PPUSH
61316: PPUSH
61317: PPUSH
// if not mc_bases then
61318: LD_EXP 61
61322: NOT
61323: IFFALSE 61327
// exit ;
61325: GO 61776
// for i = 1 to mc_bases do
61327: LD_ADDR_VAR 0 2
61331: PUSH
61332: DOUBLE
61333: LD_INT 1
61335: DEC
61336: ST_TO_ADDR
61337: LD_EXP 61
61341: PUSH
61342: FOR_TO
61343: IFFALSE 61774
// begin tmp := MC_ClassCheckReq ( i ) ;
61345: LD_ADDR_VAR 0 4
61349: PUSH
61350: LD_VAR 0 2
61354: PPUSH
61355: CALL 61781 0 1
61359: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61360: LD_ADDR_EXP 102
61364: PUSH
61365: LD_EXP 102
61369: PPUSH
61370: LD_VAR 0 2
61374: PPUSH
61375: LD_VAR 0 4
61379: PPUSH
61380: CALL_OW 1
61384: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61385: LD_ADDR_VAR 0 6
61389: PUSH
61390: LD_EXP 61
61394: PUSH
61395: LD_VAR 0 2
61399: ARRAY
61400: PPUSH
61401: LD_INT 2
61403: PUSH
61404: LD_INT 30
61406: PUSH
61407: LD_INT 4
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: LD_INT 30
61416: PUSH
61417: LD_INT 5
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: EMPTY
61425: LIST
61426: LIST
61427: LIST
61428: PPUSH
61429: CALL_OW 72
61433: PUSH
61434: LD_EXP 61
61438: PUSH
61439: LD_VAR 0 2
61443: ARRAY
61444: PPUSH
61445: LD_INT 2
61447: PUSH
61448: LD_INT 30
61450: PUSH
61451: LD_INT 0
61453: PUSH
61454: EMPTY
61455: LIST
61456: LIST
61457: PUSH
61458: LD_INT 30
61460: PUSH
61461: LD_INT 1
61463: PUSH
61464: EMPTY
61465: LIST
61466: LIST
61467: PUSH
61468: EMPTY
61469: LIST
61470: LIST
61471: LIST
61472: PPUSH
61473: CALL_OW 72
61477: PUSH
61478: LD_EXP 61
61482: PUSH
61483: LD_VAR 0 2
61487: ARRAY
61488: PPUSH
61489: LD_INT 30
61491: PUSH
61492: LD_INT 3
61494: PUSH
61495: EMPTY
61496: LIST
61497: LIST
61498: PPUSH
61499: CALL_OW 72
61503: PUSH
61504: LD_EXP 61
61508: PUSH
61509: LD_VAR 0 2
61513: ARRAY
61514: PPUSH
61515: LD_INT 2
61517: PUSH
61518: LD_INT 30
61520: PUSH
61521: LD_INT 6
61523: PUSH
61524: EMPTY
61525: LIST
61526: LIST
61527: PUSH
61528: LD_INT 30
61530: PUSH
61531: LD_INT 7
61533: PUSH
61534: EMPTY
61535: LIST
61536: LIST
61537: PUSH
61538: LD_INT 30
61540: PUSH
61541: LD_INT 8
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: PUSH
61548: EMPTY
61549: LIST
61550: LIST
61551: LIST
61552: LIST
61553: PPUSH
61554: CALL_OW 72
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: LIST
61563: LIST
61564: ST_TO_ADDR
// for j := 1 to 4 do
61565: LD_ADDR_VAR 0 3
61569: PUSH
61570: DOUBLE
61571: LD_INT 1
61573: DEC
61574: ST_TO_ADDR
61575: LD_INT 4
61577: PUSH
61578: FOR_TO
61579: IFFALSE 61770
// begin if not tmp [ j ] then
61581: LD_VAR 0 4
61585: PUSH
61586: LD_VAR 0 3
61590: ARRAY
61591: NOT
61592: IFFALSE 61596
// continue ;
61594: GO 61578
// for p in tmp [ j ] do
61596: LD_ADDR_VAR 0 5
61600: PUSH
61601: LD_VAR 0 4
61605: PUSH
61606: LD_VAR 0 3
61610: ARRAY
61611: PUSH
61612: FOR_IN
61613: IFFALSE 61766
// begin if not b [ j ] then
61615: LD_VAR 0 6
61619: PUSH
61620: LD_VAR 0 3
61624: ARRAY
61625: NOT
61626: IFFALSE 61630
// break ;
61628: GO 61766
// e := 0 ;
61630: LD_ADDR_VAR 0 7
61634: PUSH
61635: LD_INT 0
61637: ST_TO_ADDR
// for k in b [ j ] do
61638: LD_ADDR_VAR 0 8
61642: PUSH
61643: LD_VAR 0 6
61647: PUSH
61648: LD_VAR 0 3
61652: ARRAY
61653: PUSH
61654: FOR_IN
61655: IFFALSE 61682
// if IsNotFull ( k ) then
61657: LD_VAR 0 8
61661: PPUSH
61662: CALL 17685 0 1
61666: IFFALSE 61680
// begin e := k ;
61668: LD_ADDR_VAR 0 7
61672: PUSH
61673: LD_VAR 0 8
61677: ST_TO_ADDR
// break ;
61678: GO 61682
// end ;
61680: GO 61654
61682: POP
61683: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61684: LD_VAR 0 7
61688: PUSH
61689: LD_VAR 0 5
61693: PPUSH
61694: LD_VAR 0 7
61698: PPUSH
61699: CALL 51467 0 2
61703: NOT
61704: AND
61705: IFFALSE 61764
// begin if IsInUnit ( p ) then
61707: LD_VAR 0 5
61711: PPUSH
61712: CALL_OW 310
61716: IFFALSE 61727
// ComExitBuilding ( p ) ;
61718: LD_VAR 0 5
61722: PPUSH
61723: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61727: LD_VAR 0 5
61731: PPUSH
61732: LD_VAR 0 7
61736: PPUSH
61737: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61741: LD_VAR 0 5
61745: PPUSH
61746: LD_VAR 0 3
61750: PPUSH
61751: CALL_OW 183
// AddComExitBuilding ( p ) ;
61755: LD_VAR 0 5
61759: PPUSH
61760: CALL_OW 182
// end ; end ;
61764: GO 61612
61766: POP
61767: POP
// end ;
61768: GO 61578
61770: POP
61771: POP
// end ;
61772: GO 61342
61774: POP
61775: POP
// end ;
61776: LD_VAR 0 1
61780: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61781: LD_INT 0
61783: PPUSH
61784: PPUSH
61785: PPUSH
61786: PPUSH
61787: PPUSH
61788: PPUSH
61789: PPUSH
61790: PPUSH
61791: PPUSH
61792: PPUSH
61793: PPUSH
61794: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
61795: LD_ADDR_VAR 0 2
61799: PUSH
61800: LD_INT 0
61802: PUSH
61803: LD_INT 0
61805: PUSH
61806: LD_INT 0
61808: PUSH
61809: LD_INT 0
61811: PUSH
61812: EMPTY
61813: LIST
61814: LIST
61815: LIST
61816: LIST
61817: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61818: LD_VAR 0 1
61822: NOT
61823: PUSH
61824: LD_EXP 61
61828: PUSH
61829: LD_VAR 0 1
61833: ARRAY
61834: NOT
61835: OR
61836: PUSH
61837: LD_EXP 61
61841: PUSH
61842: LD_VAR 0 1
61846: ARRAY
61847: PPUSH
61848: LD_INT 2
61850: PUSH
61851: LD_INT 30
61853: PUSH
61854: LD_INT 0
61856: PUSH
61857: EMPTY
61858: LIST
61859: LIST
61860: PUSH
61861: LD_INT 30
61863: PUSH
61864: LD_INT 1
61866: PUSH
61867: EMPTY
61868: LIST
61869: LIST
61870: PUSH
61871: EMPTY
61872: LIST
61873: LIST
61874: LIST
61875: PPUSH
61876: CALL_OW 72
61880: NOT
61881: OR
61882: IFFALSE 61886
// exit ;
61884: GO 65389
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61886: LD_ADDR_VAR 0 4
61890: PUSH
61891: LD_EXP 61
61895: PUSH
61896: LD_VAR 0 1
61900: ARRAY
61901: PPUSH
61902: LD_INT 2
61904: PUSH
61905: LD_INT 25
61907: PUSH
61908: LD_INT 1
61910: PUSH
61911: EMPTY
61912: LIST
61913: LIST
61914: PUSH
61915: LD_INT 25
61917: PUSH
61918: LD_INT 2
61920: PUSH
61921: EMPTY
61922: LIST
61923: LIST
61924: PUSH
61925: LD_INT 25
61927: PUSH
61928: LD_INT 3
61930: PUSH
61931: EMPTY
61932: LIST
61933: LIST
61934: PUSH
61935: LD_INT 25
61937: PUSH
61938: LD_INT 4
61940: PUSH
61941: EMPTY
61942: LIST
61943: LIST
61944: PUSH
61945: LD_INT 25
61947: PUSH
61948: LD_INT 5
61950: PUSH
61951: EMPTY
61952: LIST
61953: LIST
61954: PUSH
61955: LD_INT 25
61957: PUSH
61958: LD_INT 8
61960: PUSH
61961: EMPTY
61962: LIST
61963: LIST
61964: PUSH
61965: LD_INT 25
61967: PUSH
61968: LD_INT 9
61970: PUSH
61971: EMPTY
61972: LIST
61973: LIST
61974: PUSH
61975: EMPTY
61976: LIST
61977: LIST
61978: LIST
61979: LIST
61980: LIST
61981: LIST
61982: LIST
61983: LIST
61984: PPUSH
61985: CALL_OW 72
61989: ST_TO_ADDR
// if not tmp then
61990: LD_VAR 0 4
61994: NOT
61995: IFFALSE 61999
// exit ;
61997: GO 65389
// for i in tmp do
61999: LD_ADDR_VAR 0 3
62003: PUSH
62004: LD_VAR 0 4
62008: PUSH
62009: FOR_IN
62010: IFFALSE 62041
// if GetTag ( i ) then
62012: LD_VAR 0 3
62016: PPUSH
62017: CALL_OW 110
62021: IFFALSE 62039
// tmp := tmp diff i ;
62023: LD_ADDR_VAR 0 4
62027: PUSH
62028: LD_VAR 0 4
62032: PUSH
62033: LD_VAR 0 3
62037: DIFF
62038: ST_TO_ADDR
62039: GO 62009
62041: POP
62042: POP
// if not tmp then
62043: LD_VAR 0 4
62047: NOT
62048: IFFALSE 62052
// exit ;
62050: GO 65389
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62052: LD_ADDR_VAR 0 5
62056: PUSH
62057: LD_EXP 61
62061: PUSH
62062: LD_VAR 0 1
62066: ARRAY
62067: PPUSH
62068: LD_INT 2
62070: PUSH
62071: LD_INT 25
62073: PUSH
62074: LD_INT 1
62076: PUSH
62077: EMPTY
62078: LIST
62079: LIST
62080: PUSH
62081: LD_INT 25
62083: PUSH
62084: LD_INT 5
62086: PUSH
62087: EMPTY
62088: LIST
62089: LIST
62090: PUSH
62091: LD_INT 25
62093: PUSH
62094: LD_INT 8
62096: PUSH
62097: EMPTY
62098: LIST
62099: LIST
62100: PUSH
62101: LD_INT 25
62103: PUSH
62104: LD_INT 9
62106: PUSH
62107: EMPTY
62108: LIST
62109: LIST
62110: PUSH
62111: EMPTY
62112: LIST
62113: LIST
62114: LIST
62115: LIST
62116: LIST
62117: PPUSH
62118: CALL_OW 72
62122: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62123: LD_ADDR_VAR 0 6
62127: PUSH
62128: LD_EXP 61
62132: PUSH
62133: LD_VAR 0 1
62137: ARRAY
62138: PPUSH
62139: LD_INT 25
62141: PUSH
62142: LD_INT 2
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PPUSH
62149: CALL_OW 72
62153: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62154: LD_ADDR_VAR 0 7
62158: PUSH
62159: LD_EXP 61
62163: PUSH
62164: LD_VAR 0 1
62168: ARRAY
62169: PPUSH
62170: LD_INT 25
62172: PUSH
62173: LD_INT 3
62175: PUSH
62176: EMPTY
62177: LIST
62178: LIST
62179: PPUSH
62180: CALL_OW 72
62184: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62185: LD_ADDR_VAR 0 8
62189: PUSH
62190: LD_EXP 61
62194: PUSH
62195: LD_VAR 0 1
62199: ARRAY
62200: PPUSH
62201: LD_INT 25
62203: PUSH
62204: LD_INT 4
62206: PUSH
62207: EMPTY
62208: LIST
62209: LIST
62210: PUSH
62211: LD_INT 24
62213: PUSH
62214: LD_INT 251
62216: PUSH
62217: EMPTY
62218: LIST
62219: LIST
62220: PUSH
62221: EMPTY
62222: LIST
62223: LIST
62224: PPUSH
62225: CALL_OW 72
62229: ST_TO_ADDR
// if mc_is_defending [ base ] then
62230: LD_EXP 104
62234: PUSH
62235: LD_VAR 0 1
62239: ARRAY
62240: IFFALSE 62701
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62242: LD_ADDR_EXP 103
62246: PUSH
62247: LD_EXP 103
62251: PPUSH
62252: LD_VAR 0 1
62256: PPUSH
62257: LD_INT 4
62259: PPUSH
62260: CALL_OW 1
62264: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62265: LD_ADDR_VAR 0 12
62269: PUSH
62270: LD_EXP 61
62274: PUSH
62275: LD_VAR 0 1
62279: ARRAY
62280: PPUSH
62281: LD_INT 2
62283: PUSH
62284: LD_INT 30
62286: PUSH
62287: LD_INT 4
62289: PUSH
62290: EMPTY
62291: LIST
62292: LIST
62293: PUSH
62294: LD_INT 30
62296: PUSH
62297: LD_INT 5
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PUSH
62304: EMPTY
62305: LIST
62306: LIST
62307: LIST
62308: PPUSH
62309: CALL_OW 72
62313: ST_TO_ADDR
// if not b then
62314: LD_VAR 0 12
62318: NOT
62319: IFFALSE 62323
// exit ;
62321: GO 65389
// p := [ ] ;
62323: LD_ADDR_VAR 0 11
62327: PUSH
62328: EMPTY
62329: ST_TO_ADDR
// if sci >= 2 then
62330: LD_VAR 0 8
62334: PUSH
62335: LD_INT 2
62337: GREATEREQUAL
62338: IFFALSE 62369
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62340: LD_ADDR_VAR 0 8
62344: PUSH
62345: LD_VAR 0 8
62349: PUSH
62350: LD_INT 1
62352: ARRAY
62353: PUSH
62354: LD_VAR 0 8
62358: PUSH
62359: LD_INT 2
62361: ARRAY
62362: PUSH
62363: EMPTY
62364: LIST
62365: LIST
62366: ST_TO_ADDR
62367: GO 62430
// if sci = 1 then
62369: LD_VAR 0 8
62373: PUSH
62374: LD_INT 1
62376: EQUAL
62377: IFFALSE 62398
// sci := [ sci [ 1 ] ] else
62379: LD_ADDR_VAR 0 8
62383: PUSH
62384: LD_VAR 0 8
62388: PUSH
62389: LD_INT 1
62391: ARRAY
62392: PUSH
62393: EMPTY
62394: LIST
62395: ST_TO_ADDR
62396: GO 62430
// if sci = 0 then
62398: LD_VAR 0 8
62402: PUSH
62403: LD_INT 0
62405: EQUAL
62406: IFFALSE 62430
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62408: LD_ADDR_VAR 0 11
62412: PUSH
62413: LD_VAR 0 4
62417: PPUSH
62418: LD_INT 4
62420: PPUSH
62421: CALL 51339 0 2
62425: PUSH
62426: LD_INT 1
62428: ARRAY
62429: ST_TO_ADDR
// if eng > 4 then
62430: LD_VAR 0 6
62434: PUSH
62435: LD_INT 4
62437: GREATER
62438: IFFALSE 62484
// for i = eng downto 4 do
62440: LD_ADDR_VAR 0 3
62444: PUSH
62445: DOUBLE
62446: LD_VAR 0 6
62450: INC
62451: ST_TO_ADDR
62452: LD_INT 4
62454: PUSH
62455: FOR_DOWNTO
62456: IFFALSE 62482
// eng := eng diff eng [ i ] ;
62458: LD_ADDR_VAR 0 6
62462: PUSH
62463: LD_VAR 0 6
62467: PUSH
62468: LD_VAR 0 6
62472: PUSH
62473: LD_VAR 0 3
62477: ARRAY
62478: DIFF
62479: ST_TO_ADDR
62480: GO 62455
62482: POP
62483: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62484: LD_ADDR_VAR 0 4
62488: PUSH
62489: LD_VAR 0 4
62493: PUSH
62494: LD_VAR 0 5
62498: PUSH
62499: LD_VAR 0 6
62503: UNION
62504: PUSH
62505: LD_VAR 0 7
62509: UNION
62510: PUSH
62511: LD_VAR 0 8
62515: UNION
62516: DIFF
62517: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62518: LD_ADDR_VAR 0 13
62522: PUSH
62523: LD_EXP 61
62527: PUSH
62528: LD_VAR 0 1
62532: ARRAY
62533: PPUSH
62534: LD_INT 2
62536: PUSH
62537: LD_INT 30
62539: PUSH
62540: LD_INT 32
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: PUSH
62547: LD_INT 30
62549: PUSH
62550: LD_INT 31
62552: PUSH
62553: EMPTY
62554: LIST
62555: LIST
62556: PUSH
62557: EMPTY
62558: LIST
62559: LIST
62560: LIST
62561: PPUSH
62562: CALL_OW 72
62566: PUSH
62567: LD_EXP 61
62571: PUSH
62572: LD_VAR 0 1
62576: ARRAY
62577: PPUSH
62578: LD_INT 2
62580: PUSH
62581: LD_INT 30
62583: PUSH
62584: LD_INT 4
62586: PUSH
62587: EMPTY
62588: LIST
62589: LIST
62590: PUSH
62591: LD_INT 30
62593: PUSH
62594: LD_INT 5
62596: PUSH
62597: EMPTY
62598: LIST
62599: LIST
62600: PUSH
62601: EMPTY
62602: LIST
62603: LIST
62604: LIST
62605: PPUSH
62606: CALL_OW 72
62610: PUSH
62611: LD_INT 6
62613: MUL
62614: PLUS
62615: ST_TO_ADDR
// if bcount < tmp then
62616: LD_VAR 0 13
62620: PUSH
62621: LD_VAR 0 4
62625: LESS
62626: IFFALSE 62672
// for i = tmp downto bcount do
62628: LD_ADDR_VAR 0 3
62632: PUSH
62633: DOUBLE
62634: LD_VAR 0 4
62638: INC
62639: ST_TO_ADDR
62640: LD_VAR 0 13
62644: PUSH
62645: FOR_DOWNTO
62646: IFFALSE 62670
// tmp := Delete ( tmp , tmp ) ;
62648: LD_ADDR_VAR 0 4
62652: PUSH
62653: LD_VAR 0 4
62657: PPUSH
62658: LD_VAR 0 4
62662: PPUSH
62663: CALL_OW 3
62667: ST_TO_ADDR
62668: GO 62645
62670: POP
62671: POP
// result := [ tmp , 0 , 0 , p ] ;
62672: LD_ADDR_VAR 0 2
62676: PUSH
62677: LD_VAR 0 4
62681: PUSH
62682: LD_INT 0
62684: PUSH
62685: LD_INT 0
62687: PUSH
62688: LD_VAR 0 11
62692: PUSH
62693: EMPTY
62694: LIST
62695: LIST
62696: LIST
62697: LIST
62698: ST_TO_ADDR
// exit ;
62699: GO 65389
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62701: LD_EXP 61
62705: PUSH
62706: LD_VAR 0 1
62710: ARRAY
62711: PPUSH
62712: LD_INT 2
62714: PUSH
62715: LD_INT 30
62717: PUSH
62718: LD_INT 6
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: PUSH
62725: LD_INT 30
62727: PUSH
62728: LD_INT 7
62730: PUSH
62731: EMPTY
62732: LIST
62733: LIST
62734: PUSH
62735: LD_INT 30
62737: PUSH
62738: LD_INT 8
62740: PUSH
62741: EMPTY
62742: LIST
62743: LIST
62744: PUSH
62745: EMPTY
62746: LIST
62747: LIST
62748: LIST
62749: LIST
62750: PPUSH
62751: CALL_OW 72
62755: NOT
62756: PUSH
62757: LD_EXP 61
62761: PUSH
62762: LD_VAR 0 1
62766: ARRAY
62767: PPUSH
62768: LD_INT 30
62770: PUSH
62771: LD_INT 3
62773: PUSH
62774: EMPTY
62775: LIST
62776: LIST
62777: PPUSH
62778: CALL_OW 72
62782: NOT
62783: AND
62784: IFFALSE 62856
// begin if eng = tmp then
62786: LD_VAR 0 6
62790: PUSH
62791: LD_VAR 0 4
62795: EQUAL
62796: IFFALSE 62800
// exit ;
62798: GO 65389
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62800: LD_ADDR_EXP 103
62804: PUSH
62805: LD_EXP 103
62809: PPUSH
62810: LD_VAR 0 1
62814: PPUSH
62815: LD_INT 1
62817: PPUSH
62818: CALL_OW 1
62822: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62823: LD_ADDR_VAR 0 2
62827: PUSH
62828: LD_INT 0
62830: PUSH
62831: LD_VAR 0 4
62835: PUSH
62836: LD_VAR 0 6
62840: DIFF
62841: PUSH
62842: LD_INT 0
62844: PUSH
62845: LD_INT 0
62847: PUSH
62848: EMPTY
62849: LIST
62850: LIST
62851: LIST
62852: LIST
62853: ST_TO_ADDR
// exit ;
62854: GO 65389
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62856: LD_EXP 88
62860: PUSH
62861: LD_EXP 87
62865: PUSH
62866: LD_VAR 0 1
62870: ARRAY
62871: ARRAY
62872: PUSH
62873: LD_EXP 61
62877: PUSH
62878: LD_VAR 0 1
62882: ARRAY
62883: PPUSH
62884: LD_INT 2
62886: PUSH
62887: LD_INT 30
62889: PUSH
62890: LD_INT 6
62892: PUSH
62893: EMPTY
62894: LIST
62895: LIST
62896: PUSH
62897: LD_INT 30
62899: PUSH
62900: LD_INT 7
62902: PUSH
62903: EMPTY
62904: LIST
62905: LIST
62906: PUSH
62907: LD_INT 30
62909: PUSH
62910: LD_INT 8
62912: PUSH
62913: EMPTY
62914: LIST
62915: LIST
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: LIST
62921: LIST
62922: PPUSH
62923: CALL_OW 72
62927: AND
62928: PUSH
62929: LD_EXP 61
62933: PUSH
62934: LD_VAR 0 1
62938: ARRAY
62939: PPUSH
62940: LD_INT 30
62942: PUSH
62943: LD_INT 3
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PPUSH
62950: CALL_OW 72
62954: NOT
62955: AND
62956: IFFALSE 63170
// begin if sci >= 6 then
62958: LD_VAR 0 8
62962: PUSH
62963: LD_INT 6
62965: GREATEREQUAL
62966: IFFALSE 62970
// exit ;
62968: GO 65389
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62970: LD_ADDR_EXP 103
62974: PUSH
62975: LD_EXP 103
62979: PPUSH
62980: LD_VAR 0 1
62984: PPUSH
62985: LD_INT 2
62987: PPUSH
62988: CALL_OW 1
62992: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62993: LD_ADDR_VAR 0 9
62997: PUSH
62998: LD_VAR 0 4
63002: PUSH
63003: LD_VAR 0 8
63007: DIFF
63008: PPUSH
63009: LD_INT 4
63011: PPUSH
63012: CALL 51339 0 2
63016: ST_TO_ADDR
// p := [ ] ;
63017: LD_ADDR_VAR 0 11
63021: PUSH
63022: EMPTY
63023: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63024: LD_VAR 0 8
63028: PUSH
63029: LD_INT 6
63031: LESS
63032: PUSH
63033: LD_VAR 0 9
63037: PUSH
63038: LD_INT 6
63040: GREATER
63041: AND
63042: IFFALSE 63123
// begin for i = 1 to 6 - sci do
63044: LD_ADDR_VAR 0 3
63048: PUSH
63049: DOUBLE
63050: LD_INT 1
63052: DEC
63053: ST_TO_ADDR
63054: LD_INT 6
63056: PUSH
63057: LD_VAR 0 8
63061: MINUS
63062: PUSH
63063: FOR_TO
63064: IFFALSE 63119
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63066: LD_ADDR_VAR 0 11
63070: PUSH
63071: LD_VAR 0 11
63075: PPUSH
63076: LD_VAR 0 11
63080: PUSH
63081: LD_INT 1
63083: PLUS
63084: PPUSH
63085: LD_VAR 0 9
63089: PUSH
63090: LD_INT 1
63092: ARRAY
63093: PPUSH
63094: CALL_OW 2
63098: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63099: LD_ADDR_VAR 0 9
63103: PUSH
63104: LD_VAR 0 9
63108: PPUSH
63109: LD_INT 1
63111: PPUSH
63112: CALL_OW 3
63116: ST_TO_ADDR
// end ;
63117: GO 63063
63119: POP
63120: POP
// end else
63121: GO 63143
// if sort then
63123: LD_VAR 0 9
63127: IFFALSE 63143
// p := sort [ 1 ] ;
63129: LD_ADDR_VAR 0 11
63133: PUSH
63134: LD_VAR 0 9
63138: PUSH
63139: LD_INT 1
63141: ARRAY
63142: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63143: LD_ADDR_VAR 0 2
63147: PUSH
63148: LD_INT 0
63150: PUSH
63151: LD_INT 0
63153: PUSH
63154: LD_INT 0
63156: PUSH
63157: LD_VAR 0 11
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: LIST
63166: LIST
63167: ST_TO_ADDR
// exit ;
63168: GO 65389
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63170: LD_EXP 88
63174: PUSH
63175: LD_EXP 87
63179: PUSH
63180: LD_VAR 0 1
63184: ARRAY
63185: ARRAY
63186: PUSH
63187: LD_EXP 61
63191: PUSH
63192: LD_VAR 0 1
63196: ARRAY
63197: PPUSH
63198: LD_INT 2
63200: PUSH
63201: LD_INT 30
63203: PUSH
63204: LD_INT 6
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: LD_INT 30
63213: PUSH
63214: LD_INT 7
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 30
63223: PUSH
63224: LD_INT 8
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: EMPTY
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: PPUSH
63237: CALL_OW 72
63241: AND
63242: PUSH
63243: LD_EXP 61
63247: PUSH
63248: LD_VAR 0 1
63252: ARRAY
63253: PPUSH
63254: LD_INT 30
63256: PUSH
63257: LD_INT 3
63259: PUSH
63260: EMPTY
63261: LIST
63262: LIST
63263: PPUSH
63264: CALL_OW 72
63268: AND
63269: IFFALSE 64003
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63271: LD_ADDR_EXP 103
63275: PUSH
63276: LD_EXP 103
63280: PPUSH
63281: LD_VAR 0 1
63285: PPUSH
63286: LD_INT 3
63288: PPUSH
63289: CALL_OW 1
63293: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63294: LD_ADDR_VAR 0 2
63298: PUSH
63299: LD_INT 0
63301: PUSH
63302: LD_INT 0
63304: PUSH
63305: LD_INT 0
63307: PUSH
63308: LD_INT 0
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: LIST
63315: LIST
63316: ST_TO_ADDR
// if not eng then
63317: LD_VAR 0 6
63321: NOT
63322: IFFALSE 63385
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63324: LD_ADDR_VAR 0 11
63328: PUSH
63329: LD_VAR 0 4
63333: PPUSH
63334: LD_INT 2
63336: PPUSH
63337: CALL 51339 0 2
63341: PUSH
63342: LD_INT 1
63344: ARRAY
63345: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63346: LD_ADDR_VAR 0 2
63350: PUSH
63351: LD_VAR 0 2
63355: PPUSH
63356: LD_INT 2
63358: PPUSH
63359: LD_VAR 0 11
63363: PPUSH
63364: CALL_OW 1
63368: ST_TO_ADDR
// tmp := tmp diff p ;
63369: LD_ADDR_VAR 0 4
63373: PUSH
63374: LD_VAR 0 4
63378: PUSH
63379: LD_VAR 0 11
63383: DIFF
63384: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63385: LD_VAR 0 4
63389: PUSH
63390: LD_VAR 0 8
63394: PUSH
63395: LD_INT 6
63397: LESS
63398: AND
63399: IFFALSE 63587
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63401: LD_ADDR_VAR 0 9
63405: PUSH
63406: LD_VAR 0 4
63410: PUSH
63411: LD_VAR 0 8
63415: PUSH
63416: LD_VAR 0 7
63420: UNION
63421: DIFF
63422: PPUSH
63423: LD_INT 4
63425: PPUSH
63426: CALL 51339 0 2
63430: ST_TO_ADDR
// p := [ ] ;
63431: LD_ADDR_VAR 0 11
63435: PUSH
63436: EMPTY
63437: ST_TO_ADDR
// if sort then
63438: LD_VAR 0 9
63442: IFFALSE 63558
// for i = 1 to 6 - sci do
63444: LD_ADDR_VAR 0 3
63448: PUSH
63449: DOUBLE
63450: LD_INT 1
63452: DEC
63453: ST_TO_ADDR
63454: LD_INT 6
63456: PUSH
63457: LD_VAR 0 8
63461: MINUS
63462: PUSH
63463: FOR_TO
63464: IFFALSE 63556
// begin if i = sort then
63466: LD_VAR 0 3
63470: PUSH
63471: LD_VAR 0 9
63475: EQUAL
63476: IFFALSE 63480
// break ;
63478: GO 63556
// if GetClass ( i ) = 4 then
63480: LD_VAR 0 3
63484: PPUSH
63485: CALL_OW 257
63489: PUSH
63490: LD_INT 4
63492: EQUAL
63493: IFFALSE 63497
// continue ;
63495: GO 63463
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63497: LD_ADDR_VAR 0 11
63501: PUSH
63502: LD_VAR 0 11
63506: PPUSH
63507: LD_VAR 0 11
63511: PUSH
63512: LD_INT 1
63514: PLUS
63515: PPUSH
63516: LD_VAR 0 9
63520: PUSH
63521: LD_VAR 0 3
63525: ARRAY
63526: PPUSH
63527: CALL_OW 2
63531: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63532: LD_ADDR_VAR 0 4
63536: PUSH
63537: LD_VAR 0 4
63541: PUSH
63542: LD_VAR 0 9
63546: PUSH
63547: LD_VAR 0 3
63551: ARRAY
63552: DIFF
63553: ST_TO_ADDR
// end ;
63554: GO 63463
63556: POP
63557: POP
// if p then
63558: LD_VAR 0 11
63562: IFFALSE 63587
// result := Replace ( result , 4 , p ) ;
63564: LD_ADDR_VAR 0 2
63568: PUSH
63569: LD_VAR 0 2
63573: PPUSH
63574: LD_INT 4
63576: PPUSH
63577: LD_VAR 0 11
63581: PPUSH
63582: CALL_OW 1
63586: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63587: LD_VAR 0 4
63591: PUSH
63592: LD_VAR 0 7
63596: PUSH
63597: LD_INT 6
63599: LESS
63600: AND
63601: IFFALSE 63789
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63603: LD_ADDR_VAR 0 9
63607: PUSH
63608: LD_VAR 0 4
63612: PUSH
63613: LD_VAR 0 8
63617: PUSH
63618: LD_VAR 0 7
63622: UNION
63623: DIFF
63624: PPUSH
63625: LD_INT 3
63627: PPUSH
63628: CALL 51339 0 2
63632: ST_TO_ADDR
// p := [ ] ;
63633: LD_ADDR_VAR 0 11
63637: PUSH
63638: EMPTY
63639: ST_TO_ADDR
// if sort then
63640: LD_VAR 0 9
63644: IFFALSE 63760
// for i = 1 to 6 - mech do
63646: LD_ADDR_VAR 0 3
63650: PUSH
63651: DOUBLE
63652: LD_INT 1
63654: DEC
63655: ST_TO_ADDR
63656: LD_INT 6
63658: PUSH
63659: LD_VAR 0 7
63663: MINUS
63664: PUSH
63665: FOR_TO
63666: IFFALSE 63758
// begin if i = sort then
63668: LD_VAR 0 3
63672: PUSH
63673: LD_VAR 0 9
63677: EQUAL
63678: IFFALSE 63682
// break ;
63680: GO 63758
// if GetClass ( i ) = 3 then
63682: LD_VAR 0 3
63686: PPUSH
63687: CALL_OW 257
63691: PUSH
63692: LD_INT 3
63694: EQUAL
63695: IFFALSE 63699
// continue ;
63697: GO 63665
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63699: LD_ADDR_VAR 0 11
63703: PUSH
63704: LD_VAR 0 11
63708: PPUSH
63709: LD_VAR 0 11
63713: PUSH
63714: LD_INT 1
63716: PLUS
63717: PPUSH
63718: LD_VAR 0 9
63722: PUSH
63723: LD_VAR 0 3
63727: ARRAY
63728: PPUSH
63729: CALL_OW 2
63733: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63734: LD_ADDR_VAR 0 4
63738: PUSH
63739: LD_VAR 0 4
63743: PUSH
63744: LD_VAR 0 9
63748: PUSH
63749: LD_VAR 0 3
63753: ARRAY
63754: DIFF
63755: ST_TO_ADDR
// end ;
63756: GO 63665
63758: POP
63759: POP
// if p then
63760: LD_VAR 0 11
63764: IFFALSE 63789
// result := Replace ( result , 3 , p ) ;
63766: LD_ADDR_VAR 0 2
63770: PUSH
63771: LD_VAR 0 2
63775: PPUSH
63776: LD_INT 3
63778: PPUSH
63779: LD_VAR 0 11
63783: PPUSH
63784: CALL_OW 1
63788: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63789: LD_VAR 0 4
63793: PUSH
63794: LD_INT 6
63796: GREATER
63797: PUSH
63798: LD_VAR 0 6
63802: PUSH
63803: LD_INT 6
63805: LESS
63806: AND
63807: IFFALSE 64001
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63809: LD_ADDR_VAR 0 9
63813: PUSH
63814: LD_VAR 0 4
63818: PUSH
63819: LD_VAR 0 8
63823: PUSH
63824: LD_VAR 0 7
63828: UNION
63829: PUSH
63830: LD_VAR 0 6
63834: UNION
63835: DIFF
63836: PPUSH
63837: LD_INT 2
63839: PPUSH
63840: CALL 51339 0 2
63844: ST_TO_ADDR
// p := [ ] ;
63845: LD_ADDR_VAR 0 11
63849: PUSH
63850: EMPTY
63851: ST_TO_ADDR
// if sort then
63852: LD_VAR 0 9
63856: IFFALSE 63972
// for i = 1 to 6 - eng do
63858: LD_ADDR_VAR 0 3
63862: PUSH
63863: DOUBLE
63864: LD_INT 1
63866: DEC
63867: ST_TO_ADDR
63868: LD_INT 6
63870: PUSH
63871: LD_VAR 0 6
63875: MINUS
63876: PUSH
63877: FOR_TO
63878: IFFALSE 63970
// begin if i = sort then
63880: LD_VAR 0 3
63884: PUSH
63885: LD_VAR 0 9
63889: EQUAL
63890: IFFALSE 63894
// break ;
63892: GO 63970
// if GetClass ( i ) = 2 then
63894: LD_VAR 0 3
63898: PPUSH
63899: CALL_OW 257
63903: PUSH
63904: LD_INT 2
63906: EQUAL
63907: IFFALSE 63911
// continue ;
63909: GO 63877
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63911: LD_ADDR_VAR 0 11
63915: PUSH
63916: LD_VAR 0 11
63920: PPUSH
63921: LD_VAR 0 11
63925: PUSH
63926: LD_INT 1
63928: PLUS
63929: PPUSH
63930: LD_VAR 0 9
63934: PUSH
63935: LD_VAR 0 3
63939: ARRAY
63940: PPUSH
63941: CALL_OW 2
63945: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63946: LD_ADDR_VAR 0 4
63950: PUSH
63951: LD_VAR 0 4
63955: PUSH
63956: LD_VAR 0 9
63960: PUSH
63961: LD_VAR 0 3
63965: ARRAY
63966: DIFF
63967: ST_TO_ADDR
// end ;
63968: GO 63877
63970: POP
63971: POP
// if p then
63972: LD_VAR 0 11
63976: IFFALSE 64001
// result := Replace ( result , 2 , p ) ;
63978: LD_ADDR_VAR 0 2
63982: PUSH
63983: LD_VAR 0 2
63987: PPUSH
63988: LD_INT 2
63990: PPUSH
63991: LD_VAR 0 11
63995: PPUSH
63996: CALL_OW 1
64000: ST_TO_ADDR
// end ; exit ;
64001: GO 65389
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64003: LD_EXP 88
64007: PUSH
64008: LD_EXP 87
64012: PUSH
64013: LD_VAR 0 1
64017: ARRAY
64018: ARRAY
64019: NOT
64020: PUSH
64021: LD_EXP 61
64025: PUSH
64026: LD_VAR 0 1
64030: ARRAY
64031: PPUSH
64032: LD_INT 30
64034: PUSH
64035: LD_INT 3
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PPUSH
64042: CALL_OW 72
64046: AND
64047: PUSH
64048: LD_EXP 66
64052: PUSH
64053: LD_VAR 0 1
64057: ARRAY
64058: AND
64059: IFFALSE 64667
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64061: LD_ADDR_EXP 103
64065: PUSH
64066: LD_EXP 103
64070: PPUSH
64071: LD_VAR 0 1
64075: PPUSH
64076: LD_INT 5
64078: PPUSH
64079: CALL_OW 1
64083: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64084: LD_ADDR_VAR 0 2
64088: PUSH
64089: LD_INT 0
64091: PUSH
64092: LD_INT 0
64094: PUSH
64095: LD_INT 0
64097: PUSH
64098: LD_INT 0
64100: PUSH
64101: EMPTY
64102: LIST
64103: LIST
64104: LIST
64105: LIST
64106: ST_TO_ADDR
// if sci > 1 then
64107: LD_VAR 0 8
64111: PUSH
64112: LD_INT 1
64114: GREATER
64115: IFFALSE 64143
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64117: LD_ADDR_VAR 0 4
64121: PUSH
64122: LD_VAR 0 4
64126: PUSH
64127: LD_VAR 0 8
64131: PUSH
64132: LD_VAR 0 8
64136: PUSH
64137: LD_INT 1
64139: ARRAY
64140: DIFF
64141: DIFF
64142: ST_TO_ADDR
// if tmp and not sci then
64143: LD_VAR 0 4
64147: PUSH
64148: LD_VAR 0 8
64152: NOT
64153: AND
64154: IFFALSE 64223
// begin sort := SortBySkill ( tmp , 4 ) ;
64156: LD_ADDR_VAR 0 9
64160: PUSH
64161: LD_VAR 0 4
64165: PPUSH
64166: LD_INT 4
64168: PPUSH
64169: CALL 51339 0 2
64173: ST_TO_ADDR
// if sort then
64174: LD_VAR 0 9
64178: IFFALSE 64194
// p := sort [ 1 ] ;
64180: LD_ADDR_VAR 0 11
64184: PUSH
64185: LD_VAR 0 9
64189: PUSH
64190: LD_INT 1
64192: ARRAY
64193: ST_TO_ADDR
// if p then
64194: LD_VAR 0 11
64198: IFFALSE 64223
// result := Replace ( result , 4 , p ) ;
64200: LD_ADDR_VAR 0 2
64204: PUSH
64205: LD_VAR 0 2
64209: PPUSH
64210: LD_INT 4
64212: PPUSH
64213: LD_VAR 0 11
64217: PPUSH
64218: CALL_OW 1
64222: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64223: LD_ADDR_VAR 0 4
64227: PUSH
64228: LD_VAR 0 4
64232: PUSH
64233: LD_VAR 0 7
64237: DIFF
64238: ST_TO_ADDR
// if tmp and mech < 6 then
64239: LD_VAR 0 4
64243: PUSH
64244: LD_VAR 0 7
64248: PUSH
64249: LD_INT 6
64251: LESS
64252: AND
64253: IFFALSE 64441
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64255: LD_ADDR_VAR 0 9
64259: PUSH
64260: LD_VAR 0 4
64264: PUSH
64265: LD_VAR 0 8
64269: PUSH
64270: LD_VAR 0 7
64274: UNION
64275: DIFF
64276: PPUSH
64277: LD_INT 3
64279: PPUSH
64280: CALL 51339 0 2
64284: ST_TO_ADDR
// p := [ ] ;
64285: LD_ADDR_VAR 0 11
64289: PUSH
64290: EMPTY
64291: ST_TO_ADDR
// if sort then
64292: LD_VAR 0 9
64296: IFFALSE 64412
// for i = 1 to 6 - mech do
64298: LD_ADDR_VAR 0 3
64302: PUSH
64303: DOUBLE
64304: LD_INT 1
64306: DEC
64307: ST_TO_ADDR
64308: LD_INT 6
64310: PUSH
64311: LD_VAR 0 7
64315: MINUS
64316: PUSH
64317: FOR_TO
64318: IFFALSE 64410
// begin if i = sort then
64320: LD_VAR 0 3
64324: PUSH
64325: LD_VAR 0 9
64329: EQUAL
64330: IFFALSE 64334
// break ;
64332: GO 64410
// if GetClass ( i ) = 3 then
64334: LD_VAR 0 3
64338: PPUSH
64339: CALL_OW 257
64343: PUSH
64344: LD_INT 3
64346: EQUAL
64347: IFFALSE 64351
// continue ;
64349: GO 64317
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64351: LD_ADDR_VAR 0 11
64355: PUSH
64356: LD_VAR 0 11
64360: PPUSH
64361: LD_VAR 0 11
64365: PUSH
64366: LD_INT 1
64368: PLUS
64369: PPUSH
64370: LD_VAR 0 9
64374: PUSH
64375: LD_VAR 0 3
64379: ARRAY
64380: PPUSH
64381: CALL_OW 2
64385: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64386: LD_ADDR_VAR 0 4
64390: PUSH
64391: LD_VAR 0 4
64395: PUSH
64396: LD_VAR 0 9
64400: PUSH
64401: LD_VAR 0 3
64405: ARRAY
64406: DIFF
64407: ST_TO_ADDR
// end ;
64408: GO 64317
64410: POP
64411: POP
// if p then
64412: LD_VAR 0 11
64416: IFFALSE 64441
// result := Replace ( result , 3 , p ) ;
64418: LD_ADDR_VAR 0 2
64422: PUSH
64423: LD_VAR 0 2
64427: PPUSH
64428: LD_INT 3
64430: PPUSH
64431: LD_VAR 0 11
64435: PPUSH
64436: CALL_OW 1
64440: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64441: LD_ADDR_VAR 0 4
64445: PUSH
64446: LD_VAR 0 4
64450: PUSH
64451: LD_VAR 0 6
64455: DIFF
64456: ST_TO_ADDR
// if tmp and eng < 6 then
64457: LD_VAR 0 4
64461: PUSH
64462: LD_VAR 0 6
64466: PUSH
64467: LD_INT 6
64469: LESS
64470: AND
64471: IFFALSE 64665
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64473: LD_ADDR_VAR 0 9
64477: PUSH
64478: LD_VAR 0 4
64482: PUSH
64483: LD_VAR 0 8
64487: PUSH
64488: LD_VAR 0 7
64492: UNION
64493: PUSH
64494: LD_VAR 0 6
64498: UNION
64499: DIFF
64500: PPUSH
64501: LD_INT 2
64503: PPUSH
64504: CALL 51339 0 2
64508: ST_TO_ADDR
// p := [ ] ;
64509: LD_ADDR_VAR 0 11
64513: PUSH
64514: EMPTY
64515: ST_TO_ADDR
// if sort then
64516: LD_VAR 0 9
64520: IFFALSE 64636
// for i = 1 to 6 - eng do
64522: LD_ADDR_VAR 0 3
64526: PUSH
64527: DOUBLE
64528: LD_INT 1
64530: DEC
64531: ST_TO_ADDR
64532: LD_INT 6
64534: PUSH
64535: LD_VAR 0 6
64539: MINUS
64540: PUSH
64541: FOR_TO
64542: IFFALSE 64634
// begin if i = sort then
64544: LD_VAR 0 3
64548: PUSH
64549: LD_VAR 0 9
64553: EQUAL
64554: IFFALSE 64558
// break ;
64556: GO 64634
// if GetClass ( i ) = 2 then
64558: LD_VAR 0 3
64562: PPUSH
64563: CALL_OW 257
64567: PUSH
64568: LD_INT 2
64570: EQUAL
64571: IFFALSE 64575
// continue ;
64573: GO 64541
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64575: LD_ADDR_VAR 0 11
64579: PUSH
64580: LD_VAR 0 11
64584: PPUSH
64585: LD_VAR 0 11
64589: PUSH
64590: LD_INT 1
64592: PLUS
64593: PPUSH
64594: LD_VAR 0 9
64598: PUSH
64599: LD_VAR 0 3
64603: ARRAY
64604: PPUSH
64605: CALL_OW 2
64609: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64610: LD_ADDR_VAR 0 4
64614: PUSH
64615: LD_VAR 0 4
64619: PUSH
64620: LD_VAR 0 9
64624: PUSH
64625: LD_VAR 0 3
64629: ARRAY
64630: DIFF
64631: ST_TO_ADDR
// end ;
64632: GO 64541
64634: POP
64635: POP
// if p then
64636: LD_VAR 0 11
64640: IFFALSE 64665
// result := Replace ( result , 2 , p ) ;
64642: LD_ADDR_VAR 0 2
64646: PUSH
64647: LD_VAR 0 2
64651: PPUSH
64652: LD_INT 2
64654: PPUSH
64655: LD_VAR 0 11
64659: PPUSH
64660: CALL_OW 1
64664: ST_TO_ADDR
// end ; exit ;
64665: GO 65389
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64667: LD_EXP 88
64671: PUSH
64672: LD_EXP 87
64676: PUSH
64677: LD_VAR 0 1
64681: ARRAY
64682: ARRAY
64683: NOT
64684: PUSH
64685: LD_EXP 61
64689: PUSH
64690: LD_VAR 0 1
64694: ARRAY
64695: PPUSH
64696: LD_INT 30
64698: PUSH
64699: LD_INT 3
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PPUSH
64706: CALL_OW 72
64710: AND
64711: PUSH
64712: LD_EXP 66
64716: PUSH
64717: LD_VAR 0 1
64721: ARRAY
64722: NOT
64723: AND
64724: IFFALSE 65389
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64726: LD_ADDR_EXP 103
64730: PUSH
64731: LD_EXP 103
64735: PPUSH
64736: LD_VAR 0 1
64740: PPUSH
64741: LD_INT 6
64743: PPUSH
64744: CALL_OW 1
64748: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64749: LD_ADDR_VAR 0 2
64753: PUSH
64754: LD_INT 0
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: LD_INT 0
64762: PUSH
64763: LD_INT 0
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: ST_TO_ADDR
// if sci >= 1 then
64772: LD_VAR 0 8
64776: PUSH
64777: LD_INT 1
64779: GREATEREQUAL
64780: IFFALSE 64802
// tmp := tmp diff sci [ 1 ] ;
64782: LD_ADDR_VAR 0 4
64786: PUSH
64787: LD_VAR 0 4
64791: PUSH
64792: LD_VAR 0 8
64796: PUSH
64797: LD_INT 1
64799: ARRAY
64800: DIFF
64801: ST_TO_ADDR
// if tmp and not sci then
64802: LD_VAR 0 4
64806: PUSH
64807: LD_VAR 0 8
64811: NOT
64812: AND
64813: IFFALSE 64882
// begin sort := SortBySkill ( tmp , 4 ) ;
64815: LD_ADDR_VAR 0 9
64819: PUSH
64820: LD_VAR 0 4
64824: PPUSH
64825: LD_INT 4
64827: PPUSH
64828: CALL 51339 0 2
64832: ST_TO_ADDR
// if sort then
64833: LD_VAR 0 9
64837: IFFALSE 64853
// p := sort [ 1 ] ;
64839: LD_ADDR_VAR 0 11
64843: PUSH
64844: LD_VAR 0 9
64848: PUSH
64849: LD_INT 1
64851: ARRAY
64852: ST_TO_ADDR
// if p then
64853: LD_VAR 0 11
64857: IFFALSE 64882
// result := Replace ( result , 4 , p ) ;
64859: LD_ADDR_VAR 0 2
64863: PUSH
64864: LD_VAR 0 2
64868: PPUSH
64869: LD_INT 4
64871: PPUSH
64872: LD_VAR 0 11
64876: PPUSH
64877: CALL_OW 1
64881: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64882: LD_ADDR_VAR 0 4
64886: PUSH
64887: LD_VAR 0 4
64891: PUSH
64892: LD_VAR 0 7
64896: DIFF
64897: ST_TO_ADDR
// if tmp and mech < 6 then
64898: LD_VAR 0 4
64902: PUSH
64903: LD_VAR 0 7
64907: PUSH
64908: LD_INT 6
64910: LESS
64911: AND
64912: IFFALSE 65094
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64914: LD_ADDR_VAR 0 9
64918: PUSH
64919: LD_VAR 0 4
64923: PUSH
64924: LD_VAR 0 7
64928: DIFF
64929: PPUSH
64930: LD_INT 3
64932: PPUSH
64933: CALL 51339 0 2
64937: ST_TO_ADDR
// p := [ ] ;
64938: LD_ADDR_VAR 0 11
64942: PUSH
64943: EMPTY
64944: ST_TO_ADDR
// if sort then
64945: LD_VAR 0 9
64949: IFFALSE 65065
// for i = 1 to 6 - mech do
64951: LD_ADDR_VAR 0 3
64955: PUSH
64956: DOUBLE
64957: LD_INT 1
64959: DEC
64960: ST_TO_ADDR
64961: LD_INT 6
64963: PUSH
64964: LD_VAR 0 7
64968: MINUS
64969: PUSH
64970: FOR_TO
64971: IFFALSE 65063
// begin if i = sort then
64973: LD_VAR 0 3
64977: PUSH
64978: LD_VAR 0 9
64982: EQUAL
64983: IFFALSE 64987
// break ;
64985: GO 65063
// if GetClass ( i ) = 3 then
64987: LD_VAR 0 3
64991: PPUSH
64992: CALL_OW 257
64996: PUSH
64997: LD_INT 3
64999: EQUAL
65000: IFFALSE 65004
// continue ;
65002: GO 64970
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65004: LD_ADDR_VAR 0 11
65008: PUSH
65009: LD_VAR 0 11
65013: PPUSH
65014: LD_VAR 0 11
65018: PUSH
65019: LD_INT 1
65021: PLUS
65022: PPUSH
65023: LD_VAR 0 9
65027: PUSH
65028: LD_VAR 0 3
65032: ARRAY
65033: PPUSH
65034: CALL_OW 2
65038: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65039: LD_ADDR_VAR 0 4
65043: PUSH
65044: LD_VAR 0 4
65048: PUSH
65049: LD_VAR 0 9
65053: PUSH
65054: LD_VAR 0 3
65058: ARRAY
65059: DIFF
65060: ST_TO_ADDR
// end ;
65061: GO 64970
65063: POP
65064: POP
// if p then
65065: LD_VAR 0 11
65069: IFFALSE 65094
// result := Replace ( result , 3 , p ) ;
65071: LD_ADDR_VAR 0 2
65075: PUSH
65076: LD_VAR 0 2
65080: PPUSH
65081: LD_INT 3
65083: PPUSH
65084: LD_VAR 0 11
65088: PPUSH
65089: CALL_OW 1
65093: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65094: LD_ADDR_VAR 0 4
65098: PUSH
65099: LD_VAR 0 4
65103: PUSH
65104: LD_VAR 0 6
65108: DIFF
65109: ST_TO_ADDR
// if tmp and eng < 4 then
65110: LD_VAR 0 4
65114: PUSH
65115: LD_VAR 0 6
65119: PUSH
65120: LD_INT 4
65122: LESS
65123: AND
65124: IFFALSE 65314
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65126: LD_ADDR_VAR 0 9
65130: PUSH
65131: LD_VAR 0 4
65135: PUSH
65136: LD_VAR 0 7
65140: PUSH
65141: LD_VAR 0 6
65145: UNION
65146: DIFF
65147: PPUSH
65148: LD_INT 2
65150: PPUSH
65151: CALL 51339 0 2
65155: ST_TO_ADDR
// p := [ ] ;
65156: LD_ADDR_VAR 0 11
65160: PUSH
65161: EMPTY
65162: ST_TO_ADDR
// if sort then
65163: LD_VAR 0 9
65167: IFFALSE 65283
// for i = 1 to 4 - eng do
65169: LD_ADDR_VAR 0 3
65173: PUSH
65174: DOUBLE
65175: LD_INT 1
65177: DEC
65178: ST_TO_ADDR
65179: LD_INT 4
65181: PUSH
65182: LD_VAR 0 6
65186: MINUS
65187: PUSH
65188: FOR_TO
65189: IFFALSE 65281
// begin if i = sort then
65191: LD_VAR 0 3
65195: PUSH
65196: LD_VAR 0 9
65200: EQUAL
65201: IFFALSE 65205
// break ;
65203: GO 65281
// if GetClass ( i ) = 2 then
65205: LD_VAR 0 3
65209: PPUSH
65210: CALL_OW 257
65214: PUSH
65215: LD_INT 2
65217: EQUAL
65218: IFFALSE 65222
// continue ;
65220: GO 65188
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65222: LD_ADDR_VAR 0 11
65226: PUSH
65227: LD_VAR 0 11
65231: PPUSH
65232: LD_VAR 0 11
65236: PUSH
65237: LD_INT 1
65239: PLUS
65240: PPUSH
65241: LD_VAR 0 9
65245: PUSH
65246: LD_VAR 0 3
65250: ARRAY
65251: PPUSH
65252: CALL_OW 2
65256: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65257: LD_ADDR_VAR 0 4
65261: PUSH
65262: LD_VAR 0 4
65266: PUSH
65267: LD_VAR 0 9
65271: PUSH
65272: LD_VAR 0 3
65276: ARRAY
65277: DIFF
65278: ST_TO_ADDR
// end ;
65279: GO 65188
65281: POP
65282: POP
// if p then
65283: LD_VAR 0 11
65287: IFFALSE 65312
// result := Replace ( result , 2 , p ) ;
65289: LD_ADDR_VAR 0 2
65293: PUSH
65294: LD_VAR 0 2
65298: PPUSH
65299: LD_INT 2
65301: PPUSH
65302: LD_VAR 0 11
65306: PPUSH
65307: CALL_OW 1
65311: ST_TO_ADDR
// end else
65312: GO 65358
// for i = eng downto 5 do
65314: LD_ADDR_VAR 0 3
65318: PUSH
65319: DOUBLE
65320: LD_VAR 0 6
65324: INC
65325: ST_TO_ADDR
65326: LD_INT 5
65328: PUSH
65329: FOR_DOWNTO
65330: IFFALSE 65356
// tmp := tmp union eng [ i ] ;
65332: LD_ADDR_VAR 0 4
65336: PUSH
65337: LD_VAR 0 4
65341: PUSH
65342: LD_VAR 0 6
65346: PUSH
65347: LD_VAR 0 3
65351: ARRAY
65352: UNION
65353: ST_TO_ADDR
65354: GO 65329
65356: POP
65357: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65358: LD_ADDR_VAR 0 2
65362: PUSH
65363: LD_VAR 0 2
65367: PPUSH
65368: LD_INT 1
65370: PPUSH
65371: LD_VAR 0 4
65375: PUSH
65376: LD_VAR 0 5
65380: DIFF
65381: PPUSH
65382: CALL_OW 1
65386: ST_TO_ADDR
// exit ;
65387: GO 65389
// end ; end ;
65389: LD_VAR 0 2
65393: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65394: LD_INT 0
65396: PPUSH
65397: PPUSH
65398: PPUSH
// if not mc_bases then
65399: LD_EXP 61
65403: NOT
65404: IFFALSE 65408
// exit ;
65406: GO 65550
// for i = 1 to mc_bases do
65408: LD_ADDR_VAR 0 2
65412: PUSH
65413: DOUBLE
65414: LD_INT 1
65416: DEC
65417: ST_TO_ADDR
65418: LD_EXP 61
65422: PUSH
65423: FOR_TO
65424: IFFALSE 65541
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65426: LD_ADDR_VAR 0 3
65430: PUSH
65431: LD_EXP 61
65435: PUSH
65436: LD_VAR 0 2
65440: ARRAY
65441: PPUSH
65442: LD_INT 21
65444: PUSH
65445: LD_INT 3
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 3
65454: PUSH
65455: LD_INT 2
65457: PUSH
65458: LD_INT 30
65460: PUSH
65461: LD_INT 29
65463: PUSH
65464: EMPTY
65465: LIST
65466: LIST
65467: PUSH
65468: LD_INT 30
65470: PUSH
65471: LD_INT 30
65473: PUSH
65474: EMPTY
65475: LIST
65476: LIST
65477: PUSH
65478: EMPTY
65479: LIST
65480: LIST
65481: LIST
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 3
65489: PUSH
65490: LD_INT 24
65492: PUSH
65493: LD_INT 1000
65495: PUSH
65496: EMPTY
65497: LIST
65498: LIST
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: EMPTY
65505: LIST
65506: LIST
65507: LIST
65508: PPUSH
65509: CALL_OW 72
65513: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65514: LD_ADDR_EXP 62
65518: PUSH
65519: LD_EXP 62
65523: PPUSH
65524: LD_VAR 0 2
65528: PPUSH
65529: LD_VAR 0 3
65533: PPUSH
65534: CALL_OW 1
65538: ST_TO_ADDR
// end ;
65539: GO 65423
65541: POP
65542: POP
// RaiseSailEvent ( 101 ) ;
65543: LD_INT 101
65545: PPUSH
65546: CALL_OW 427
// end ;
65550: LD_VAR 0 1
65554: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65555: LD_INT 0
65557: PPUSH
65558: PPUSH
65559: PPUSH
65560: PPUSH
65561: PPUSH
65562: PPUSH
65563: PPUSH
// if not mc_bases then
65564: LD_EXP 61
65568: NOT
65569: IFFALSE 65573
// exit ;
65571: GO 66135
// for i = 1 to mc_bases do
65573: LD_ADDR_VAR 0 2
65577: PUSH
65578: DOUBLE
65579: LD_INT 1
65581: DEC
65582: ST_TO_ADDR
65583: LD_EXP 61
65587: PUSH
65588: FOR_TO
65589: IFFALSE 66126
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
65591: LD_ADDR_VAR 0 5
65595: PUSH
65596: LD_EXP 61
65600: PUSH
65601: LD_VAR 0 2
65605: ARRAY
65606: PUSH
65607: LD_EXP 90
65611: PUSH
65612: LD_VAR 0 2
65616: ARRAY
65617: UNION
65618: PPUSH
65619: LD_INT 21
65621: PUSH
65622: LD_INT 1
65624: PUSH
65625: EMPTY
65626: LIST
65627: LIST
65628: PUSH
65629: LD_INT 1
65631: PUSH
65632: LD_INT 3
65634: PUSH
65635: LD_INT 54
65637: PUSH
65638: EMPTY
65639: LIST
65640: PUSH
65641: EMPTY
65642: LIST
65643: LIST
65644: PUSH
65645: LD_INT 3
65647: PUSH
65648: LD_INT 24
65650: PUSH
65651: LD_INT 1000
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: EMPTY
65663: LIST
65664: LIST
65665: LIST
65666: PUSH
65667: EMPTY
65668: LIST
65669: LIST
65670: PPUSH
65671: CALL_OW 72
65675: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65676: LD_ADDR_VAR 0 6
65680: PUSH
65681: LD_EXP 61
65685: PUSH
65686: LD_VAR 0 2
65690: ARRAY
65691: PPUSH
65692: LD_INT 21
65694: PUSH
65695: LD_INT 1
65697: PUSH
65698: EMPTY
65699: LIST
65700: LIST
65701: PUSH
65702: LD_INT 1
65704: PUSH
65705: LD_INT 3
65707: PUSH
65708: LD_INT 54
65710: PUSH
65711: EMPTY
65712: LIST
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PUSH
65718: LD_INT 3
65720: PUSH
65721: LD_INT 24
65723: PUSH
65724: LD_INT 250
65726: PUSH
65727: EMPTY
65728: LIST
65729: LIST
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: LIST
65739: PUSH
65740: EMPTY
65741: LIST
65742: LIST
65743: PPUSH
65744: CALL_OW 72
65748: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65749: LD_ADDR_VAR 0 7
65753: PUSH
65754: LD_VAR 0 5
65758: PUSH
65759: LD_VAR 0 6
65763: DIFF
65764: ST_TO_ADDR
// if not need_heal_1 then
65765: LD_VAR 0 6
65769: NOT
65770: IFFALSE 65803
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65772: LD_ADDR_EXP 64
65776: PUSH
65777: LD_EXP 64
65781: PPUSH
65782: LD_VAR 0 2
65786: PUSH
65787: LD_INT 1
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PPUSH
65794: EMPTY
65795: PPUSH
65796: CALL 20463 0 3
65800: ST_TO_ADDR
65801: GO 65873
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65803: LD_ADDR_EXP 64
65807: PUSH
65808: LD_EXP 64
65812: PPUSH
65813: LD_VAR 0 2
65817: PUSH
65818: LD_INT 1
65820: PUSH
65821: EMPTY
65822: LIST
65823: LIST
65824: PPUSH
65825: LD_EXP 64
65829: PUSH
65830: LD_VAR 0 2
65834: ARRAY
65835: PUSH
65836: LD_INT 1
65838: ARRAY
65839: PPUSH
65840: LD_INT 3
65842: PUSH
65843: LD_INT 24
65845: PUSH
65846: LD_INT 1000
65848: PUSH
65849: EMPTY
65850: LIST
65851: LIST
65852: PUSH
65853: EMPTY
65854: LIST
65855: LIST
65856: PPUSH
65857: CALL_OW 72
65861: PUSH
65862: LD_VAR 0 6
65866: UNION
65867: PPUSH
65868: CALL 20463 0 3
65872: ST_TO_ADDR
// if not need_heal_2 then
65873: LD_VAR 0 7
65877: NOT
65878: IFFALSE 65911
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65880: LD_ADDR_EXP 64
65884: PUSH
65885: LD_EXP 64
65889: PPUSH
65890: LD_VAR 0 2
65894: PUSH
65895: LD_INT 2
65897: PUSH
65898: EMPTY
65899: LIST
65900: LIST
65901: PPUSH
65902: EMPTY
65903: PPUSH
65904: CALL 20463 0 3
65908: ST_TO_ADDR
65909: GO 65943
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65911: LD_ADDR_EXP 64
65915: PUSH
65916: LD_EXP 64
65920: PPUSH
65921: LD_VAR 0 2
65925: PUSH
65926: LD_INT 2
65928: PUSH
65929: EMPTY
65930: LIST
65931: LIST
65932: PPUSH
65933: LD_VAR 0 7
65937: PPUSH
65938: CALL 20463 0 3
65942: ST_TO_ADDR
// if need_heal_2 then
65943: LD_VAR 0 7
65947: IFFALSE 66108
// for j in need_heal_2 do
65949: LD_ADDR_VAR 0 3
65953: PUSH
65954: LD_VAR 0 7
65958: PUSH
65959: FOR_IN
65960: IFFALSE 66106
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65962: LD_ADDR_VAR 0 5
65966: PUSH
65967: LD_EXP 61
65971: PUSH
65972: LD_VAR 0 2
65976: ARRAY
65977: PPUSH
65978: LD_INT 2
65980: PUSH
65981: LD_INT 30
65983: PUSH
65984: LD_INT 6
65986: PUSH
65987: EMPTY
65988: LIST
65989: LIST
65990: PUSH
65991: LD_INT 30
65993: PUSH
65994: LD_INT 7
65996: PUSH
65997: EMPTY
65998: LIST
65999: LIST
66000: PUSH
66001: LD_INT 30
66003: PUSH
66004: LD_INT 8
66006: PUSH
66007: EMPTY
66008: LIST
66009: LIST
66010: PUSH
66011: LD_INT 30
66013: PUSH
66014: LD_INT 0
66016: PUSH
66017: EMPTY
66018: LIST
66019: LIST
66020: PUSH
66021: LD_INT 30
66023: PUSH
66024: LD_INT 1
66026: PUSH
66027: EMPTY
66028: LIST
66029: LIST
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: LIST
66035: LIST
66036: LIST
66037: LIST
66038: PPUSH
66039: CALL_OW 72
66043: ST_TO_ADDR
// if tmp then
66044: LD_VAR 0 5
66048: IFFALSE 66104
// begin k := NearestUnitToUnit ( tmp , j ) ;
66050: LD_ADDR_VAR 0 4
66054: PUSH
66055: LD_VAR 0 5
66059: PPUSH
66060: LD_VAR 0 3
66064: PPUSH
66065: CALL_OW 74
66069: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
66070: LD_VAR 0 3
66074: PPUSH
66075: LD_VAR 0 4
66079: PPUSH
66080: CALL_OW 296
66084: PUSH
66085: LD_INT 5
66087: GREATER
66088: IFFALSE 66104
// ComMoveToNearbyEntrance ( j , k ) ;
66090: LD_VAR 0 3
66094: PPUSH
66095: LD_VAR 0 4
66099: PPUSH
66100: CALL 53699 0 2
// end ; end ;
66104: GO 65959
66106: POP
66107: POP
// if not need_heal_1 and not need_heal_2 then
66108: LD_VAR 0 6
66112: NOT
66113: PUSH
66114: LD_VAR 0 7
66118: NOT
66119: AND
66120: IFFALSE 66124
// continue ;
66122: GO 65588
// end ;
66124: GO 65588
66126: POP
66127: POP
// RaiseSailEvent ( 102 ) ;
66128: LD_INT 102
66130: PPUSH
66131: CALL_OW 427
// end ;
66135: LD_VAR 0 1
66139: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66140: LD_INT 0
66142: PPUSH
66143: PPUSH
66144: PPUSH
66145: PPUSH
66146: PPUSH
66147: PPUSH
66148: PPUSH
66149: PPUSH
// if not mc_bases then
66150: LD_EXP 61
66154: NOT
66155: IFFALSE 66159
// exit ;
66157: GO 67070
// for i = 1 to mc_bases do
66159: LD_ADDR_VAR 0 2
66163: PUSH
66164: DOUBLE
66165: LD_INT 1
66167: DEC
66168: ST_TO_ADDR
66169: LD_EXP 61
66173: PUSH
66174: FOR_TO
66175: IFFALSE 67068
// begin if not mc_building_need_repair [ i ] then
66177: LD_EXP 62
66181: PUSH
66182: LD_VAR 0 2
66186: ARRAY
66187: NOT
66188: IFFALSE 66373
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
66190: LD_ADDR_VAR 0 6
66194: PUSH
66195: LD_EXP 80
66199: PUSH
66200: LD_VAR 0 2
66204: ARRAY
66205: PPUSH
66206: LD_INT 3
66208: PUSH
66209: LD_INT 24
66211: PUSH
66212: LD_INT 1000
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: EMPTY
66220: LIST
66221: LIST
66222: PUSH
66223: LD_INT 2
66225: PUSH
66226: LD_INT 34
66228: PUSH
66229: LD_INT 13
66231: PUSH
66232: EMPTY
66233: LIST
66234: LIST
66235: PUSH
66236: LD_INT 34
66238: PUSH
66239: LD_INT 52
66241: PUSH
66242: EMPTY
66243: LIST
66244: LIST
66245: PUSH
66246: LD_INT 34
66248: PUSH
66249: LD_INT 88
66251: PUSH
66252: EMPTY
66253: LIST
66254: LIST
66255: PUSH
66256: EMPTY
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: PUSH
66262: EMPTY
66263: LIST
66264: LIST
66265: PPUSH
66266: CALL_OW 72
66270: ST_TO_ADDR
// if cranes then
66271: LD_VAR 0 6
66275: IFFALSE 66337
// for j in cranes do
66277: LD_ADDR_VAR 0 3
66281: PUSH
66282: LD_VAR 0 6
66286: PUSH
66287: FOR_IN
66288: IFFALSE 66335
// if not IsInArea ( j , mc_parking [ i ] ) then
66290: LD_VAR 0 3
66294: PPUSH
66295: LD_EXP 85
66299: PUSH
66300: LD_VAR 0 2
66304: ARRAY
66305: PPUSH
66306: CALL_OW 308
66310: NOT
66311: IFFALSE 66333
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66313: LD_VAR 0 3
66317: PPUSH
66318: LD_EXP 85
66322: PUSH
66323: LD_VAR 0 2
66327: ARRAY
66328: PPUSH
66329: CALL_OW 113
66333: GO 66287
66335: POP
66336: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66337: LD_ADDR_EXP 63
66341: PUSH
66342: LD_EXP 63
66346: PPUSH
66347: LD_VAR 0 2
66351: PPUSH
66352: EMPTY
66353: PPUSH
66354: CALL_OW 1
66358: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66359: LD_VAR 0 2
66363: PPUSH
66364: LD_INT 101
66366: PPUSH
66367: CALL 61213 0 2
// continue ;
66371: GO 66174
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66373: LD_ADDR_EXP 67
66377: PUSH
66378: LD_EXP 67
66382: PPUSH
66383: LD_VAR 0 2
66387: PPUSH
66388: EMPTY
66389: PPUSH
66390: CALL_OW 1
66394: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66395: LD_VAR 0 2
66399: PPUSH
66400: LD_INT 103
66402: PPUSH
66403: CALL 61213 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66407: LD_ADDR_VAR 0 5
66411: PUSH
66412: LD_EXP 61
66416: PUSH
66417: LD_VAR 0 2
66421: ARRAY
66422: PUSH
66423: LD_EXP 90
66427: PUSH
66428: LD_VAR 0 2
66432: ARRAY
66433: UNION
66434: PPUSH
66435: LD_INT 2
66437: PUSH
66438: LD_INT 25
66440: PUSH
66441: LD_INT 2
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 25
66450: PUSH
66451: LD_INT 16
66453: PUSH
66454: EMPTY
66455: LIST
66456: LIST
66457: PUSH
66458: EMPTY
66459: LIST
66460: LIST
66461: LIST
66462: PUSH
66463: EMPTY
66464: LIST
66465: PPUSH
66466: CALL_OW 72
66470: ST_TO_ADDR
// if mc_need_heal [ i ] then
66471: LD_EXP 64
66475: PUSH
66476: LD_VAR 0 2
66480: ARRAY
66481: IFFALSE 66525
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
66483: LD_ADDR_VAR 0 5
66487: PUSH
66488: LD_VAR 0 5
66492: PUSH
66493: LD_EXP 64
66497: PUSH
66498: LD_VAR 0 2
66502: ARRAY
66503: PUSH
66504: LD_INT 1
66506: ARRAY
66507: PUSH
66508: LD_EXP 64
66512: PUSH
66513: LD_VAR 0 2
66517: ARRAY
66518: PUSH
66519: LD_INT 2
66521: ARRAY
66522: UNION
66523: DIFF
66524: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
66525: LD_ADDR_VAR 0 6
66529: PUSH
66530: LD_EXP 80
66534: PUSH
66535: LD_VAR 0 2
66539: ARRAY
66540: PPUSH
66541: LD_INT 2
66543: PUSH
66544: LD_INT 34
66546: PUSH
66547: LD_INT 13
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 34
66556: PUSH
66557: LD_INT 52
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PUSH
66564: LD_INT 34
66566: PUSH
66567: LD_INT 88
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: LIST
66578: LIST
66579: PPUSH
66580: CALL_OW 72
66584: ST_TO_ADDR
// if cranes then
66585: LD_VAR 0 6
66589: IFFALSE 66757
// begin for j in cranes do
66591: LD_ADDR_VAR 0 3
66595: PUSH
66596: LD_VAR 0 6
66600: PUSH
66601: FOR_IN
66602: IFFALSE 66755
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
66604: LD_VAR 0 3
66608: PPUSH
66609: CALL_OW 256
66613: PUSH
66614: LD_INT 1000
66616: EQUAL
66617: PUSH
66618: LD_VAR 0 3
66622: PPUSH
66623: CALL_OW 314
66627: NOT
66628: AND
66629: IFFALSE 66695
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
66631: LD_ADDR_VAR 0 8
66635: PUSH
66636: LD_EXP 62
66640: PUSH
66641: LD_VAR 0 2
66645: ARRAY
66646: PPUSH
66647: LD_VAR 0 3
66651: PPUSH
66652: CALL_OW 74
66656: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
66657: LD_VAR 0 8
66661: PPUSH
66662: LD_INT 16
66664: PPUSH
66665: CALL 23060 0 2
66669: PUSH
66670: LD_INT 4
66672: ARRAY
66673: PUSH
66674: LD_INT 10
66676: LESS
66677: IFFALSE 66693
// ComRepairBuilding ( j , to_repair ) ;
66679: LD_VAR 0 3
66683: PPUSH
66684: LD_VAR 0 8
66688: PPUSH
66689: CALL_OW 130
// end else
66693: GO 66753
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66695: LD_VAR 0 3
66699: PPUSH
66700: CALL_OW 256
66704: PUSH
66705: LD_INT 500
66707: LESS
66708: PUSH
66709: LD_VAR 0 3
66713: PPUSH
66714: LD_EXP 85
66718: PUSH
66719: LD_VAR 0 2
66723: ARRAY
66724: PPUSH
66725: CALL_OW 308
66729: NOT
66730: AND
66731: IFFALSE 66753
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66733: LD_VAR 0 3
66737: PPUSH
66738: LD_EXP 85
66742: PUSH
66743: LD_VAR 0 2
66747: ARRAY
66748: PPUSH
66749: CALL_OW 113
// end ;
66753: GO 66601
66755: POP
66756: POP
// end ; if tmp > 3 then
66757: LD_VAR 0 5
66761: PUSH
66762: LD_INT 3
66764: GREATER
66765: IFFALSE 66785
// tmp := ShrinkArray ( tmp , 4 ) ;
66767: LD_ADDR_VAR 0 5
66771: PUSH
66772: LD_VAR 0 5
66776: PPUSH
66777: LD_INT 4
66779: PPUSH
66780: CALL 53137 0 2
66784: ST_TO_ADDR
// if not tmp then
66785: LD_VAR 0 5
66789: NOT
66790: IFFALSE 66794
// continue ;
66792: GO 66174
// for j in tmp do
66794: LD_ADDR_VAR 0 3
66798: PUSH
66799: LD_VAR 0 5
66803: PUSH
66804: FOR_IN
66805: IFFALSE 67064
// begin if IsInUnit ( j ) then
66807: LD_VAR 0 3
66811: PPUSH
66812: CALL_OW 310
66816: IFFALSE 66827
// ComExitBuilding ( j ) ;
66818: LD_VAR 0 3
66822: PPUSH
66823: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66827: LD_VAR 0 3
66831: PUSH
66832: LD_EXP 63
66836: PUSH
66837: LD_VAR 0 2
66841: ARRAY
66842: IN
66843: NOT
66844: IFFALSE 66902
// begin SetTag ( j , 101 ) ;
66846: LD_VAR 0 3
66850: PPUSH
66851: LD_INT 101
66853: PPUSH
66854: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66858: LD_ADDR_EXP 63
66862: PUSH
66863: LD_EXP 63
66867: PPUSH
66868: LD_VAR 0 2
66872: PUSH
66873: LD_EXP 63
66877: PUSH
66878: LD_VAR 0 2
66882: ARRAY
66883: PUSH
66884: LD_INT 1
66886: PLUS
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PPUSH
66892: LD_VAR 0 3
66896: PPUSH
66897: CALL 20463 0 3
66901: ST_TO_ADDR
// end ; wait ( 1 ) ;
66902: LD_INT 1
66904: PPUSH
66905: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66909: LD_ADDR_VAR 0 7
66913: PUSH
66914: LD_EXP 62
66918: PUSH
66919: LD_VAR 0 2
66923: ARRAY
66924: ST_TO_ADDR
// if mc_scan [ i ] then
66925: LD_EXP 84
66929: PUSH
66930: LD_VAR 0 2
66934: ARRAY
66935: IFFALSE 66997
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66937: LD_ADDR_VAR 0 7
66941: PUSH
66942: LD_EXP 62
66946: PUSH
66947: LD_VAR 0 2
66951: ARRAY
66952: PPUSH
66953: LD_INT 3
66955: PUSH
66956: LD_INT 30
66958: PUSH
66959: LD_INT 32
66961: PUSH
66962: EMPTY
66963: LIST
66964: LIST
66965: PUSH
66966: LD_INT 30
66968: PUSH
66969: LD_INT 33
66971: PUSH
66972: EMPTY
66973: LIST
66974: LIST
66975: PUSH
66976: LD_INT 30
66978: PUSH
66979: LD_INT 31
66981: PUSH
66982: EMPTY
66983: LIST
66984: LIST
66985: PUSH
66986: EMPTY
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: PPUSH
66992: CALL_OW 72
66996: ST_TO_ADDR
// if not to_repair_tmp then
66997: LD_VAR 0 7
67001: NOT
67002: IFFALSE 67006
// continue ;
67004: GO 66804
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
67006: LD_ADDR_VAR 0 8
67010: PUSH
67011: LD_VAR 0 7
67015: PPUSH
67016: LD_VAR 0 3
67020: PPUSH
67021: CALL_OW 74
67025: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
67026: LD_VAR 0 8
67030: PPUSH
67031: LD_INT 16
67033: PPUSH
67034: CALL 23060 0 2
67038: PUSH
67039: LD_INT 4
67041: ARRAY
67042: PUSH
67043: LD_INT 14
67045: LESS
67046: IFFALSE 67062
// ComRepairBuilding ( j , to_repair ) ;
67048: LD_VAR 0 3
67052: PPUSH
67053: LD_VAR 0 8
67057: PPUSH
67058: CALL_OW 130
// end ;
67062: GO 66804
67064: POP
67065: POP
// end ;
67066: GO 66174
67068: POP
67069: POP
// end ;
67070: LD_VAR 0 1
67074: RET
// export function MC_Heal ; var i , j , tmp ; begin
67075: LD_INT 0
67077: PPUSH
67078: PPUSH
67079: PPUSH
67080: PPUSH
// if not mc_bases then
67081: LD_EXP 61
67085: NOT
67086: IFFALSE 67090
// exit ;
67088: GO 67492
// for i = 1 to mc_bases do
67090: LD_ADDR_VAR 0 2
67094: PUSH
67095: DOUBLE
67096: LD_INT 1
67098: DEC
67099: ST_TO_ADDR
67100: LD_EXP 61
67104: PUSH
67105: FOR_TO
67106: IFFALSE 67490
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67108: LD_EXP 64
67112: PUSH
67113: LD_VAR 0 2
67117: ARRAY
67118: PUSH
67119: LD_INT 1
67121: ARRAY
67122: NOT
67123: PUSH
67124: LD_EXP 64
67128: PUSH
67129: LD_VAR 0 2
67133: ARRAY
67134: PUSH
67135: LD_INT 2
67137: ARRAY
67138: NOT
67139: AND
67140: IFFALSE 67178
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67142: LD_ADDR_EXP 65
67146: PUSH
67147: LD_EXP 65
67151: PPUSH
67152: LD_VAR 0 2
67156: PPUSH
67157: EMPTY
67158: PPUSH
67159: CALL_OW 1
67163: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67164: LD_VAR 0 2
67168: PPUSH
67169: LD_INT 102
67171: PPUSH
67172: CALL 61213 0 2
// continue ;
67176: GO 67105
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67178: LD_ADDR_VAR 0 4
67182: PUSH
67183: LD_EXP 61
67187: PUSH
67188: LD_VAR 0 2
67192: ARRAY
67193: PPUSH
67194: LD_INT 25
67196: PUSH
67197: LD_INT 4
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PPUSH
67204: CALL_OW 72
67208: ST_TO_ADDR
// if not tmp then
67209: LD_VAR 0 4
67213: NOT
67214: IFFALSE 67218
// continue ;
67216: GO 67105
// if mc_taming [ i ] then
67218: LD_EXP 92
67222: PUSH
67223: LD_VAR 0 2
67227: ARRAY
67228: IFFALSE 67252
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67230: LD_ADDR_EXP 92
67234: PUSH
67235: LD_EXP 92
67239: PPUSH
67240: LD_VAR 0 2
67244: PPUSH
67245: EMPTY
67246: PPUSH
67247: CALL_OW 1
67251: ST_TO_ADDR
// for j in tmp do
67252: LD_ADDR_VAR 0 3
67256: PUSH
67257: LD_VAR 0 4
67261: PUSH
67262: FOR_IN
67263: IFFALSE 67486
// begin if IsInUnit ( j ) then
67265: LD_VAR 0 3
67269: PPUSH
67270: CALL_OW 310
67274: IFFALSE 67285
// ComExitBuilding ( j ) ;
67276: LD_VAR 0 3
67280: PPUSH
67281: CALL_OW 122
// if not j in mc_healers [ i ] then
67285: LD_VAR 0 3
67289: PUSH
67290: LD_EXP 65
67294: PUSH
67295: LD_VAR 0 2
67299: ARRAY
67300: IN
67301: NOT
67302: IFFALSE 67348
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67304: LD_ADDR_EXP 65
67308: PUSH
67309: LD_EXP 65
67313: PPUSH
67314: LD_VAR 0 2
67318: PUSH
67319: LD_EXP 65
67323: PUSH
67324: LD_VAR 0 2
67328: ARRAY
67329: PUSH
67330: LD_INT 1
67332: PLUS
67333: PUSH
67334: EMPTY
67335: LIST
67336: LIST
67337: PPUSH
67338: LD_VAR 0 3
67342: PPUSH
67343: CALL 20463 0 3
67347: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67348: LD_VAR 0 3
67352: PPUSH
67353: CALL_OW 110
67357: PUSH
67358: LD_INT 102
67360: NONEQUAL
67361: IFFALSE 67375
// SetTag ( j , 102 ) ;
67363: LD_VAR 0 3
67367: PPUSH
67368: LD_INT 102
67370: PPUSH
67371: CALL_OW 109
// Wait ( 3 ) ;
67375: LD_INT 3
67377: PPUSH
67378: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67382: LD_EXP 64
67386: PUSH
67387: LD_VAR 0 2
67391: ARRAY
67392: PUSH
67393: LD_INT 1
67395: ARRAY
67396: IFFALSE 67428
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67398: LD_VAR 0 3
67402: PPUSH
67403: LD_EXP 64
67407: PUSH
67408: LD_VAR 0 2
67412: ARRAY
67413: PUSH
67414: LD_INT 1
67416: ARRAY
67417: PUSH
67418: LD_INT 1
67420: ARRAY
67421: PPUSH
67422: CALL_OW 128
67426: GO 67484
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67428: LD_VAR 0 3
67432: PPUSH
67433: CALL_OW 314
67437: NOT
67438: PUSH
67439: LD_EXP 64
67443: PUSH
67444: LD_VAR 0 2
67448: ARRAY
67449: PUSH
67450: LD_INT 2
67452: ARRAY
67453: AND
67454: IFFALSE 67484
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67456: LD_VAR 0 3
67460: PPUSH
67461: LD_EXP 64
67465: PUSH
67466: LD_VAR 0 2
67470: ARRAY
67471: PUSH
67472: LD_INT 2
67474: ARRAY
67475: PUSH
67476: LD_INT 1
67478: ARRAY
67479: PPUSH
67480: CALL_OW 128
// end ;
67484: GO 67262
67486: POP
67487: POP
// end ;
67488: GO 67105
67490: POP
67491: POP
// end ;
67492: LD_VAR 0 1
67496: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
67497: LD_INT 0
67499: PPUSH
67500: PPUSH
67501: PPUSH
67502: PPUSH
67503: PPUSH
67504: PPUSH
// if not mc_bases then
67505: LD_EXP 61
67509: NOT
67510: IFFALSE 67514
// exit ;
67512: GO 68677
// for i = 1 to mc_bases do
67514: LD_ADDR_VAR 0 2
67518: PUSH
67519: DOUBLE
67520: LD_INT 1
67522: DEC
67523: ST_TO_ADDR
67524: LD_EXP 61
67528: PUSH
67529: FOR_TO
67530: IFFALSE 68675
// begin if mc_scan [ i ] then
67532: LD_EXP 84
67536: PUSH
67537: LD_VAR 0 2
67541: ARRAY
67542: IFFALSE 67546
// continue ;
67544: GO 67529
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67546: LD_EXP 66
67550: PUSH
67551: LD_VAR 0 2
67555: ARRAY
67556: NOT
67557: PUSH
67558: LD_EXP 68
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: NOT
67569: AND
67570: PUSH
67571: LD_EXP 67
67575: PUSH
67576: LD_VAR 0 2
67580: ARRAY
67581: AND
67582: IFFALSE 67620
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67584: LD_ADDR_EXP 67
67588: PUSH
67589: LD_EXP 67
67593: PPUSH
67594: LD_VAR 0 2
67598: PPUSH
67599: EMPTY
67600: PPUSH
67601: CALL_OW 1
67605: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67606: LD_VAR 0 2
67610: PPUSH
67611: LD_INT 103
67613: PPUSH
67614: CALL 61213 0 2
// continue ;
67618: GO 67529
// end ; if mc_construct_list [ i ] then
67620: LD_EXP 68
67624: PUSH
67625: LD_VAR 0 2
67629: ARRAY
67630: IFFALSE 67850
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67632: LD_ADDR_VAR 0 5
67636: PUSH
67637: LD_EXP 61
67641: PUSH
67642: LD_VAR 0 2
67646: ARRAY
67647: PPUSH
67648: LD_INT 25
67650: PUSH
67651: LD_INT 2
67653: PUSH
67654: EMPTY
67655: LIST
67656: LIST
67657: PPUSH
67658: CALL_OW 72
67662: PUSH
67663: LD_EXP 63
67667: PUSH
67668: LD_VAR 0 2
67672: ARRAY
67673: DIFF
67674: ST_TO_ADDR
// if not tmp then
67675: LD_VAR 0 5
67679: NOT
67680: IFFALSE 67684
// continue ;
67682: GO 67529
// for j in tmp do
67684: LD_ADDR_VAR 0 3
67688: PUSH
67689: LD_VAR 0 5
67693: PUSH
67694: FOR_IN
67695: IFFALSE 67846
// begin if not mc_builders [ i ] then
67697: LD_EXP 67
67701: PUSH
67702: LD_VAR 0 2
67706: ARRAY
67707: NOT
67708: IFFALSE 67766
// begin SetTag ( j , 103 ) ;
67710: LD_VAR 0 3
67714: PPUSH
67715: LD_INT 103
67717: PPUSH
67718: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67722: LD_ADDR_EXP 67
67726: PUSH
67727: LD_EXP 67
67731: PPUSH
67732: LD_VAR 0 2
67736: PUSH
67737: LD_EXP 67
67741: PUSH
67742: LD_VAR 0 2
67746: ARRAY
67747: PUSH
67748: LD_INT 1
67750: PLUS
67751: PUSH
67752: EMPTY
67753: LIST
67754: LIST
67755: PPUSH
67756: LD_VAR 0 3
67760: PPUSH
67761: CALL 20463 0 3
67765: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67766: LD_VAR 0 3
67770: PPUSH
67771: CALL_OW 310
67775: IFFALSE 67786
// ComExitBuilding ( j ) ;
67777: LD_VAR 0 3
67781: PPUSH
67782: CALL_OW 122
// wait ( 3 ) ;
67786: LD_INT 3
67788: PPUSH
67789: CALL_OW 67
// if not mc_construct_list [ i ] then
67793: LD_EXP 68
67797: PUSH
67798: LD_VAR 0 2
67802: ARRAY
67803: NOT
67804: IFFALSE 67808
// break ;
67806: GO 67846
// if not HasTask ( j ) then
67808: LD_VAR 0 3
67812: PPUSH
67813: CALL_OW 314
67817: NOT
67818: IFFALSE 67844
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67820: LD_VAR 0 3
67824: PPUSH
67825: LD_EXP 68
67829: PUSH
67830: LD_VAR 0 2
67834: ARRAY
67835: PUSH
67836: LD_INT 1
67838: ARRAY
67839: PPUSH
67840: CALL 23333 0 2
// end ;
67844: GO 67694
67846: POP
67847: POP
// end else
67848: GO 68673
// if mc_build_list [ i ] then
67850: LD_EXP 66
67854: PUSH
67855: LD_VAR 0 2
67859: ARRAY
67860: IFFALSE 68673
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67862: LD_EXP 66
67866: PUSH
67867: LD_VAR 0 2
67871: ARRAY
67872: PUSH
67873: LD_INT 1
67875: ARRAY
67876: PUSH
67877: LD_INT 1
67879: ARRAY
67880: PPUSH
67881: CALL 23157 0 1
67885: PUSH
67886: LD_EXP 61
67890: PUSH
67891: LD_VAR 0 2
67895: ARRAY
67896: PPUSH
67897: LD_INT 2
67899: PUSH
67900: LD_INT 30
67902: PUSH
67903: LD_INT 2
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 30
67912: PUSH
67913: LD_INT 3
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: EMPTY
67921: LIST
67922: LIST
67923: LIST
67924: PPUSH
67925: CALL_OW 72
67929: NOT
67930: AND
67931: IFFALSE 68036
// begin for j = 1 to mc_build_list [ i ] do
67933: LD_ADDR_VAR 0 3
67937: PUSH
67938: DOUBLE
67939: LD_INT 1
67941: DEC
67942: ST_TO_ADDR
67943: LD_EXP 66
67947: PUSH
67948: LD_VAR 0 2
67952: ARRAY
67953: PUSH
67954: FOR_TO
67955: IFFALSE 68034
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67957: LD_EXP 66
67961: PUSH
67962: LD_VAR 0 2
67966: ARRAY
67967: PUSH
67968: LD_VAR 0 3
67972: ARRAY
67973: PUSH
67974: LD_INT 1
67976: ARRAY
67977: PUSH
67978: LD_INT 2
67980: EQUAL
67981: IFFALSE 68032
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67983: LD_ADDR_EXP 66
67987: PUSH
67988: LD_EXP 66
67992: PPUSH
67993: LD_VAR 0 2
67997: PPUSH
67998: LD_EXP 66
68002: PUSH
68003: LD_VAR 0 2
68007: ARRAY
68008: PPUSH
68009: LD_VAR 0 3
68013: PPUSH
68014: LD_INT 1
68016: PPUSH
68017: LD_INT 0
68019: PPUSH
68020: CALL 19881 0 4
68024: PPUSH
68025: CALL_OW 1
68029: ST_TO_ADDR
// break ;
68030: GO 68034
// end ;
68032: GO 67954
68034: POP
68035: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68036: LD_ADDR_VAR 0 6
68040: PUSH
68041: LD_EXP 61
68045: PUSH
68046: LD_VAR 0 2
68050: ARRAY
68051: PPUSH
68052: LD_INT 2
68054: PUSH
68055: LD_INT 30
68057: PUSH
68058: LD_INT 0
68060: PUSH
68061: EMPTY
68062: LIST
68063: LIST
68064: PUSH
68065: LD_INT 30
68067: PUSH
68068: LD_INT 1
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: LIST
68079: PPUSH
68080: CALL_OW 72
68084: ST_TO_ADDR
// for k := 1 to depot do
68085: LD_ADDR_VAR 0 4
68089: PUSH
68090: DOUBLE
68091: LD_INT 1
68093: DEC
68094: ST_TO_ADDR
68095: LD_VAR 0 6
68099: PUSH
68100: FOR_TO
68101: IFFALSE 68671
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68103: LD_EXP 66
68107: PUSH
68108: LD_VAR 0 2
68112: ARRAY
68113: PUSH
68114: LD_INT 1
68116: ARRAY
68117: PUSH
68118: LD_INT 1
68120: ARRAY
68121: PUSH
68122: LD_INT 0
68124: EQUAL
68125: PUSH
68126: LD_VAR 0 6
68130: PUSH
68131: LD_VAR 0 4
68135: ARRAY
68136: PPUSH
68137: LD_EXP 66
68141: PUSH
68142: LD_VAR 0 2
68146: ARRAY
68147: PUSH
68148: LD_INT 1
68150: ARRAY
68151: PUSH
68152: LD_INT 1
68154: ARRAY
68155: PPUSH
68156: LD_EXP 66
68160: PUSH
68161: LD_VAR 0 2
68165: ARRAY
68166: PUSH
68167: LD_INT 1
68169: ARRAY
68170: PUSH
68171: LD_INT 2
68173: ARRAY
68174: PPUSH
68175: LD_EXP 66
68179: PUSH
68180: LD_VAR 0 2
68184: ARRAY
68185: PUSH
68186: LD_INT 1
68188: ARRAY
68189: PUSH
68190: LD_INT 3
68192: ARRAY
68193: PPUSH
68194: LD_EXP 66
68198: PUSH
68199: LD_VAR 0 2
68203: ARRAY
68204: PUSH
68205: LD_INT 1
68207: ARRAY
68208: PUSH
68209: LD_INT 4
68211: ARRAY
68212: PPUSH
68213: CALL 28569 0 5
68217: OR
68218: IFFALSE 68499
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68220: LD_ADDR_VAR 0 5
68224: PUSH
68225: LD_EXP 61
68229: PUSH
68230: LD_VAR 0 2
68234: ARRAY
68235: PPUSH
68236: LD_INT 25
68238: PUSH
68239: LD_INT 2
68241: PUSH
68242: EMPTY
68243: LIST
68244: LIST
68245: PPUSH
68246: CALL_OW 72
68250: PUSH
68251: LD_EXP 63
68255: PUSH
68256: LD_VAR 0 2
68260: ARRAY
68261: DIFF
68262: ST_TO_ADDR
// if not tmp then
68263: LD_VAR 0 5
68267: NOT
68268: IFFALSE 68272
// continue ;
68270: GO 68100
// for j in tmp do
68272: LD_ADDR_VAR 0 3
68276: PUSH
68277: LD_VAR 0 5
68281: PUSH
68282: FOR_IN
68283: IFFALSE 68495
// begin if not mc_builders [ i ] then
68285: LD_EXP 67
68289: PUSH
68290: LD_VAR 0 2
68294: ARRAY
68295: NOT
68296: IFFALSE 68354
// begin SetTag ( j , 103 ) ;
68298: LD_VAR 0 3
68302: PPUSH
68303: LD_INT 103
68305: PPUSH
68306: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68310: LD_ADDR_EXP 67
68314: PUSH
68315: LD_EXP 67
68319: PPUSH
68320: LD_VAR 0 2
68324: PUSH
68325: LD_EXP 67
68329: PUSH
68330: LD_VAR 0 2
68334: ARRAY
68335: PUSH
68336: LD_INT 1
68338: PLUS
68339: PUSH
68340: EMPTY
68341: LIST
68342: LIST
68343: PPUSH
68344: LD_VAR 0 3
68348: PPUSH
68349: CALL 20463 0 3
68353: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68354: LD_VAR 0 3
68358: PPUSH
68359: CALL_OW 310
68363: IFFALSE 68374
// ComExitBuilding ( j ) ;
68365: LD_VAR 0 3
68369: PPUSH
68370: CALL_OW 122
// wait ( 3 ) ;
68374: LD_INT 3
68376: PPUSH
68377: CALL_OW 67
// if not mc_build_list [ i ] then
68381: LD_EXP 66
68385: PUSH
68386: LD_VAR 0 2
68390: ARRAY
68391: NOT
68392: IFFALSE 68396
// break ;
68394: GO 68495
// if not HasTask ( j ) then
68396: LD_VAR 0 3
68400: PPUSH
68401: CALL_OW 314
68405: NOT
68406: IFFALSE 68493
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68408: LD_VAR 0 3
68412: PPUSH
68413: LD_EXP 66
68417: PUSH
68418: LD_VAR 0 2
68422: ARRAY
68423: PUSH
68424: LD_INT 1
68426: ARRAY
68427: PUSH
68428: LD_INT 1
68430: ARRAY
68431: PPUSH
68432: LD_EXP 66
68436: PUSH
68437: LD_VAR 0 2
68441: ARRAY
68442: PUSH
68443: LD_INT 1
68445: ARRAY
68446: PUSH
68447: LD_INT 2
68449: ARRAY
68450: PPUSH
68451: LD_EXP 66
68455: PUSH
68456: LD_VAR 0 2
68460: ARRAY
68461: PUSH
68462: LD_INT 1
68464: ARRAY
68465: PUSH
68466: LD_INT 3
68468: ARRAY
68469: PPUSH
68470: LD_EXP 66
68474: PUSH
68475: LD_VAR 0 2
68479: ARRAY
68480: PUSH
68481: LD_INT 1
68483: ARRAY
68484: PUSH
68485: LD_INT 4
68487: ARRAY
68488: PPUSH
68489: CALL_OW 145
// end ;
68493: GO 68282
68495: POP
68496: POP
// end else
68497: GO 68669
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
68499: LD_EXP 61
68503: PUSH
68504: LD_VAR 0 2
68508: ARRAY
68509: PPUSH
68510: LD_EXP 66
68514: PUSH
68515: LD_VAR 0 2
68519: ARRAY
68520: PUSH
68521: LD_INT 1
68523: ARRAY
68524: PUSH
68525: LD_INT 1
68527: ARRAY
68528: PPUSH
68529: LD_EXP 66
68533: PUSH
68534: LD_VAR 0 2
68538: ARRAY
68539: PUSH
68540: LD_INT 1
68542: ARRAY
68543: PUSH
68544: LD_INT 2
68546: ARRAY
68547: PPUSH
68548: LD_EXP 66
68552: PUSH
68553: LD_VAR 0 2
68557: ARRAY
68558: PUSH
68559: LD_INT 1
68561: ARRAY
68562: PUSH
68563: LD_INT 3
68565: ARRAY
68566: PPUSH
68567: LD_EXP 66
68571: PUSH
68572: LD_VAR 0 2
68576: ARRAY
68577: PUSH
68578: LD_INT 1
68580: ARRAY
68581: PUSH
68582: LD_INT 4
68584: ARRAY
68585: PPUSH
68586: LD_EXP 61
68590: PUSH
68591: LD_VAR 0 2
68595: ARRAY
68596: PPUSH
68597: LD_INT 21
68599: PUSH
68600: LD_INT 3
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PPUSH
68607: CALL_OW 72
68611: PPUSH
68612: EMPTY
68613: PPUSH
68614: CALL 27323 0 7
68618: NOT
68619: IFFALSE 68669
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68621: LD_ADDR_EXP 66
68625: PUSH
68626: LD_EXP 66
68630: PPUSH
68631: LD_VAR 0 2
68635: PPUSH
68636: LD_EXP 66
68640: PUSH
68641: LD_VAR 0 2
68645: ARRAY
68646: PPUSH
68647: LD_INT 1
68649: PPUSH
68650: LD_INT 1
68652: NEG
68653: PPUSH
68654: LD_INT 0
68656: PPUSH
68657: CALL 19881 0 4
68661: PPUSH
68662: CALL_OW 1
68666: ST_TO_ADDR
// continue ;
68667: GO 68100
// end ; end ;
68669: GO 68100
68671: POP
68672: POP
// end ; end ;
68673: GO 67529
68675: POP
68676: POP
// end ;
68677: LD_VAR 0 1
68681: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68682: LD_INT 0
68684: PPUSH
68685: PPUSH
68686: PPUSH
68687: PPUSH
68688: PPUSH
68689: PPUSH
// if not mc_bases then
68690: LD_EXP 61
68694: NOT
68695: IFFALSE 68699
// exit ;
68697: GO 69126
// for i = 1 to mc_bases do
68699: LD_ADDR_VAR 0 2
68703: PUSH
68704: DOUBLE
68705: LD_INT 1
68707: DEC
68708: ST_TO_ADDR
68709: LD_EXP 61
68713: PUSH
68714: FOR_TO
68715: IFFALSE 69124
// begin tmp := mc_build_upgrade [ i ] ;
68717: LD_ADDR_VAR 0 4
68721: PUSH
68722: LD_EXP 93
68726: PUSH
68727: LD_VAR 0 2
68731: ARRAY
68732: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68733: LD_ADDR_VAR 0 6
68737: PUSH
68738: LD_EXP 94
68742: PUSH
68743: LD_VAR 0 2
68747: ARRAY
68748: PPUSH
68749: LD_INT 2
68751: PUSH
68752: LD_INT 30
68754: PUSH
68755: LD_INT 6
68757: PUSH
68758: EMPTY
68759: LIST
68760: LIST
68761: PUSH
68762: LD_INT 30
68764: PUSH
68765: LD_INT 7
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: LIST
68776: PPUSH
68777: CALL_OW 72
68781: ST_TO_ADDR
// if not tmp and not lab then
68782: LD_VAR 0 4
68786: NOT
68787: PUSH
68788: LD_VAR 0 6
68792: NOT
68793: AND
68794: IFFALSE 68798
// continue ;
68796: GO 68714
// if tmp then
68798: LD_VAR 0 4
68802: IFFALSE 68922
// for j in tmp do
68804: LD_ADDR_VAR 0 3
68808: PUSH
68809: LD_VAR 0 4
68813: PUSH
68814: FOR_IN
68815: IFFALSE 68920
// begin if UpgradeCost ( j ) then
68817: LD_VAR 0 3
68821: PPUSH
68822: CALL 26983 0 1
68826: IFFALSE 68918
// begin ComUpgrade ( j ) ;
68828: LD_VAR 0 3
68832: PPUSH
68833: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68837: LD_ADDR_EXP 93
68841: PUSH
68842: LD_EXP 93
68846: PPUSH
68847: LD_VAR 0 2
68851: PPUSH
68852: LD_EXP 93
68856: PUSH
68857: LD_VAR 0 2
68861: ARRAY
68862: PUSH
68863: LD_VAR 0 3
68867: DIFF
68868: PPUSH
68869: CALL_OW 1
68873: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68874: LD_ADDR_EXP 68
68878: PUSH
68879: LD_EXP 68
68883: PPUSH
68884: LD_VAR 0 2
68888: PUSH
68889: LD_EXP 68
68893: PUSH
68894: LD_VAR 0 2
68898: ARRAY
68899: PUSH
68900: LD_INT 1
68902: PLUS
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PPUSH
68908: LD_VAR 0 3
68912: PPUSH
68913: CALL 20463 0 3
68917: ST_TO_ADDR
// end ; end ;
68918: GO 68814
68920: POP
68921: POP
// if not lab or not mc_lab_upgrade [ i ] then
68922: LD_VAR 0 6
68926: NOT
68927: PUSH
68928: LD_EXP 95
68932: PUSH
68933: LD_VAR 0 2
68937: ARRAY
68938: NOT
68939: OR
68940: IFFALSE 68944
// continue ;
68942: GO 68714
// for j in lab do
68944: LD_ADDR_VAR 0 3
68948: PUSH
68949: LD_VAR 0 6
68953: PUSH
68954: FOR_IN
68955: IFFALSE 69120
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68957: LD_VAR 0 3
68961: PPUSH
68962: CALL_OW 266
68966: PUSH
68967: LD_INT 6
68969: PUSH
68970: LD_INT 7
68972: PUSH
68973: EMPTY
68974: LIST
68975: LIST
68976: IN
68977: PUSH
68978: LD_VAR 0 3
68982: PPUSH
68983: CALL_OW 461
68987: PUSH
68988: LD_INT 1
68990: NONEQUAL
68991: AND
68992: IFFALSE 69118
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68994: LD_VAR 0 3
68998: PPUSH
68999: LD_EXP 95
69003: PUSH
69004: LD_VAR 0 2
69008: ARRAY
69009: PUSH
69010: LD_INT 1
69012: ARRAY
69013: PPUSH
69014: CALL 27188 0 2
69018: IFFALSE 69118
// begin ComCancel ( j ) ;
69020: LD_VAR 0 3
69024: PPUSH
69025: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69029: LD_VAR 0 3
69033: PPUSH
69034: LD_EXP 95
69038: PUSH
69039: LD_VAR 0 2
69043: ARRAY
69044: PUSH
69045: LD_INT 1
69047: ARRAY
69048: PPUSH
69049: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69053: LD_VAR 0 3
69057: PUSH
69058: LD_EXP 68
69062: PUSH
69063: LD_VAR 0 2
69067: ARRAY
69068: IN
69069: NOT
69070: IFFALSE 69116
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69072: LD_ADDR_EXP 68
69076: PUSH
69077: LD_EXP 68
69081: PPUSH
69082: LD_VAR 0 2
69086: PUSH
69087: LD_EXP 68
69091: PUSH
69092: LD_VAR 0 2
69096: ARRAY
69097: PUSH
69098: LD_INT 1
69100: PLUS
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PPUSH
69106: LD_VAR 0 3
69110: PPUSH
69111: CALL 20463 0 3
69115: ST_TO_ADDR
// break ;
69116: GO 69120
// end ; end ; end ;
69118: GO 68954
69120: POP
69121: POP
// end ;
69122: GO 68714
69124: POP
69125: POP
// end ;
69126: LD_VAR 0 1
69130: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69131: LD_INT 0
69133: PPUSH
69134: PPUSH
69135: PPUSH
69136: PPUSH
69137: PPUSH
69138: PPUSH
69139: PPUSH
69140: PPUSH
69141: PPUSH
// if not mc_bases then
69142: LD_EXP 61
69146: NOT
69147: IFFALSE 69151
// exit ;
69149: GO 69556
// for i = 1 to mc_bases do
69151: LD_ADDR_VAR 0 2
69155: PUSH
69156: DOUBLE
69157: LD_INT 1
69159: DEC
69160: ST_TO_ADDR
69161: LD_EXP 61
69165: PUSH
69166: FOR_TO
69167: IFFALSE 69554
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69169: LD_EXP 69
69173: PUSH
69174: LD_VAR 0 2
69178: ARRAY
69179: NOT
69180: PUSH
69181: LD_EXP 61
69185: PUSH
69186: LD_VAR 0 2
69190: ARRAY
69191: PPUSH
69192: LD_INT 30
69194: PUSH
69195: LD_INT 3
69197: PUSH
69198: EMPTY
69199: LIST
69200: LIST
69201: PPUSH
69202: CALL_OW 72
69206: NOT
69207: OR
69208: IFFALSE 69212
// continue ;
69210: GO 69166
// busy := false ;
69212: LD_ADDR_VAR 0 8
69216: PUSH
69217: LD_INT 0
69219: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69220: LD_ADDR_VAR 0 4
69224: PUSH
69225: LD_EXP 61
69229: PUSH
69230: LD_VAR 0 2
69234: ARRAY
69235: PPUSH
69236: LD_INT 30
69238: PUSH
69239: LD_INT 3
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PPUSH
69246: CALL_OW 72
69250: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69251: LD_ADDR_VAR 0 6
69255: PUSH
69256: LD_EXP 69
69260: PUSH
69261: LD_VAR 0 2
69265: ARRAY
69266: PPUSH
69267: LD_INT 2
69269: PUSH
69270: LD_INT 30
69272: PUSH
69273: LD_INT 32
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 30
69282: PUSH
69283: LD_INT 33
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: LIST
69294: PPUSH
69295: CALL_OW 72
69299: ST_TO_ADDR
// if not t then
69300: LD_VAR 0 6
69304: NOT
69305: IFFALSE 69309
// continue ;
69307: GO 69166
// for j in tmp do
69309: LD_ADDR_VAR 0 3
69313: PUSH
69314: LD_VAR 0 4
69318: PUSH
69319: FOR_IN
69320: IFFALSE 69350
// if not BuildingStatus ( j ) = bs_idle then
69322: LD_VAR 0 3
69326: PPUSH
69327: CALL_OW 461
69331: PUSH
69332: LD_INT 2
69334: EQUAL
69335: NOT
69336: IFFALSE 69348
// begin busy := true ;
69338: LD_ADDR_VAR 0 8
69342: PUSH
69343: LD_INT 1
69345: ST_TO_ADDR
// break ;
69346: GO 69350
// end ;
69348: GO 69319
69350: POP
69351: POP
// if busy then
69352: LD_VAR 0 8
69356: IFFALSE 69360
// continue ;
69358: GO 69166
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69360: LD_ADDR_VAR 0 7
69364: PUSH
69365: LD_VAR 0 6
69369: PPUSH
69370: LD_INT 35
69372: PUSH
69373: LD_INT 0
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PPUSH
69380: CALL_OW 72
69384: ST_TO_ADDR
// if tw then
69385: LD_VAR 0 7
69389: IFFALSE 69466
// begin tw := tw [ 1 ] ;
69391: LD_ADDR_VAR 0 7
69395: PUSH
69396: LD_VAR 0 7
69400: PUSH
69401: LD_INT 1
69403: ARRAY
69404: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69405: LD_ADDR_VAR 0 9
69409: PUSH
69410: LD_VAR 0 7
69414: PPUSH
69415: LD_EXP 86
69419: PUSH
69420: LD_VAR 0 2
69424: ARRAY
69425: PPUSH
69426: CALL 25480 0 2
69430: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69431: LD_EXP 100
69435: PUSH
69436: LD_VAR 0 2
69440: ARRAY
69441: IFFALSE 69464
// if not weapon in mc_allowed_tower_weapons [ i ] then
69443: LD_VAR 0 9
69447: PUSH
69448: LD_EXP 100
69452: PUSH
69453: LD_VAR 0 2
69457: ARRAY
69458: IN
69459: NOT
69460: IFFALSE 69464
// continue ;
69462: GO 69166
// end else
69464: GO 69529
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69466: LD_ADDR_VAR 0 5
69470: PUSH
69471: LD_EXP 69
69475: PUSH
69476: LD_VAR 0 2
69480: ARRAY
69481: PPUSH
69482: LD_VAR 0 4
69486: PPUSH
69487: CALL 52370 0 2
69491: ST_TO_ADDR
// if not tmp2 then
69492: LD_VAR 0 5
69496: NOT
69497: IFFALSE 69501
// continue ;
69499: GO 69166
// tw := tmp2 [ 1 ] ;
69501: LD_ADDR_VAR 0 7
69505: PUSH
69506: LD_VAR 0 5
69510: PUSH
69511: LD_INT 1
69513: ARRAY
69514: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69515: LD_ADDR_VAR 0 9
69519: PUSH
69520: LD_VAR 0 5
69524: PUSH
69525: LD_INT 2
69527: ARRAY
69528: ST_TO_ADDR
// end ; if not weapon then
69529: LD_VAR 0 9
69533: NOT
69534: IFFALSE 69538
// continue ;
69536: GO 69166
// ComPlaceWeapon ( tw , weapon ) ;
69538: LD_VAR 0 7
69542: PPUSH
69543: LD_VAR 0 9
69547: PPUSH
69548: CALL_OW 148
// end ;
69552: GO 69166
69554: POP
69555: POP
// end ;
69556: LD_VAR 0 1
69560: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
69561: LD_INT 0
69563: PPUSH
69564: PPUSH
69565: PPUSH
69566: PPUSH
69567: PPUSH
69568: PPUSH
69569: PPUSH
// if not mc_bases then
69570: LD_EXP 61
69574: NOT
69575: IFFALSE 69579
// exit ;
69577: GO 70354
// for i = 1 to mc_bases do
69579: LD_ADDR_VAR 0 2
69583: PUSH
69584: DOUBLE
69585: LD_INT 1
69587: DEC
69588: ST_TO_ADDR
69589: LD_EXP 61
69593: PUSH
69594: FOR_TO
69595: IFFALSE 70352
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69597: LD_EXP 74
69601: PUSH
69602: LD_VAR 0 2
69606: ARRAY
69607: NOT
69608: PUSH
69609: LD_EXP 74
69613: PUSH
69614: LD_VAR 0 2
69618: ARRAY
69619: PUSH
69620: LD_EXP 75
69624: PUSH
69625: LD_VAR 0 2
69629: ARRAY
69630: EQUAL
69631: OR
69632: PUSH
69633: LD_EXP 84
69637: PUSH
69638: LD_VAR 0 2
69642: ARRAY
69643: OR
69644: IFFALSE 69648
// continue ;
69646: GO 69594
// if mc_miners [ i ] then
69648: LD_EXP 75
69652: PUSH
69653: LD_VAR 0 2
69657: ARRAY
69658: IFFALSE 70039
// begin for j = mc_miners [ i ] downto 1 do
69660: LD_ADDR_VAR 0 3
69664: PUSH
69665: DOUBLE
69666: LD_EXP 75
69670: PUSH
69671: LD_VAR 0 2
69675: ARRAY
69676: INC
69677: ST_TO_ADDR
69678: LD_INT 1
69680: PUSH
69681: FOR_DOWNTO
69682: IFFALSE 70037
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69684: LD_EXP 75
69688: PUSH
69689: LD_VAR 0 2
69693: ARRAY
69694: PUSH
69695: LD_VAR 0 3
69699: ARRAY
69700: PPUSH
69701: CALL_OW 301
69705: PUSH
69706: LD_EXP 75
69710: PUSH
69711: LD_VAR 0 2
69715: ARRAY
69716: PUSH
69717: LD_VAR 0 3
69721: ARRAY
69722: PPUSH
69723: CALL_OW 257
69727: PUSH
69728: LD_INT 1
69730: NONEQUAL
69731: OR
69732: IFFALSE 69795
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69734: LD_ADDR_VAR 0 5
69738: PUSH
69739: LD_EXP 75
69743: PUSH
69744: LD_VAR 0 2
69748: ARRAY
69749: PUSH
69750: LD_EXP 75
69754: PUSH
69755: LD_VAR 0 2
69759: ARRAY
69760: PUSH
69761: LD_VAR 0 3
69765: ARRAY
69766: DIFF
69767: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69768: LD_ADDR_EXP 75
69772: PUSH
69773: LD_EXP 75
69777: PPUSH
69778: LD_VAR 0 2
69782: PPUSH
69783: LD_VAR 0 5
69787: PPUSH
69788: CALL_OW 1
69792: ST_TO_ADDR
// continue ;
69793: GO 69681
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69795: LD_EXP 75
69799: PUSH
69800: LD_VAR 0 2
69804: ARRAY
69805: PUSH
69806: LD_VAR 0 3
69810: ARRAY
69811: PPUSH
69812: CALL_OW 257
69816: PUSH
69817: LD_INT 1
69819: EQUAL
69820: PUSH
69821: LD_EXP 75
69825: PUSH
69826: LD_VAR 0 2
69830: ARRAY
69831: PUSH
69832: LD_VAR 0 3
69836: ARRAY
69837: PPUSH
69838: CALL_OW 459
69842: NOT
69843: AND
69844: PUSH
69845: LD_EXP 75
69849: PUSH
69850: LD_VAR 0 2
69854: ARRAY
69855: PUSH
69856: LD_VAR 0 3
69860: ARRAY
69861: PPUSH
69862: CALL_OW 314
69866: NOT
69867: AND
69868: IFFALSE 70035
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69870: LD_EXP 75
69874: PUSH
69875: LD_VAR 0 2
69879: ARRAY
69880: PUSH
69881: LD_VAR 0 3
69885: ARRAY
69886: PPUSH
69887: CALL_OW 310
69891: IFFALSE 69914
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69893: LD_EXP 75
69897: PUSH
69898: LD_VAR 0 2
69902: ARRAY
69903: PUSH
69904: LD_VAR 0 3
69908: ARRAY
69909: PPUSH
69910: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69914: LD_EXP 75
69918: PUSH
69919: LD_VAR 0 2
69923: ARRAY
69924: PUSH
69925: LD_VAR 0 3
69929: ARRAY
69930: PPUSH
69931: CALL_OW 314
69935: NOT
69936: IFFALSE 70035
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
69938: LD_ADDR_VAR 0 7
69942: PUSH
69943: LD_VAR 0 3
69947: PUSH
69948: LD_EXP 74
69952: PUSH
69953: LD_VAR 0 2
69957: ARRAY
69958: PPUSH
69959: CALL 17603 0 1
69963: MOD
69964: PUSH
69965: LD_INT 1
69967: PLUS
69968: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69969: LD_EXP 75
69973: PUSH
69974: LD_VAR 0 2
69978: ARRAY
69979: PUSH
69980: LD_VAR 0 3
69984: ARRAY
69985: PPUSH
69986: LD_EXP 74
69990: PUSH
69991: LD_VAR 0 2
69995: ARRAY
69996: PUSH
69997: LD_VAR 0 7
70001: ARRAY
70002: PUSH
70003: LD_INT 1
70005: ARRAY
70006: PPUSH
70007: LD_EXP 74
70011: PUSH
70012: LD_VAR 0 2
70016: ARRAY
70017: PUSH
70018: LD_VAR 0 7
70022: ARRAY
70023: PUSH
70024: LD_INT 2
70026: ARRAY
70027: PPUSH
70028: LD_INT 0
70030: PPUSH
70031: CALL_OW 193
// end ; end ; end ;
70035: GO 69681
70037: POP
70038: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70039: LD_ADDR_VAR 0 5
70043: PUSH
70044: LD_EXP 61
70048: PUSH
70049: LD_VAR 0 2
70053: ARRAY
70054: PPUSH
70055: LD_INT 2
70057: PUSH
70058: LD_INT 30
70060: PUSH
70061: LD_INT 4
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 30
70070: PUSH
70071: LD_INT 5
70073: PUSH
70074: EMPTY
70075: LIST
70076: LIST
70077: PUSH
70078: LD_INT 30
70080: PUSH
70081: LD_INT 32
70083: PUSH
70084: EMPTY
70085: LIST
70086: LIST
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: LIST
70092: LIST
70093: PPUSH
70094: CALL_OW 72
70098: ST_TO_ADDR
// if not tmp then
70099: LD_VAR 0 5
70103: NOT
70104: IFFALSE 70108
// continue ;
70106: GO 69594
// list := [ ] ;
70108: LD_ADDR_VAR 0 6
70112: PUSH
70113: EMPTY
70114: ST_TO_ADDR
// for j in tmp do
70115: LD_ADDR_VAR 0 3
70119: PUSH
70120: LD_VAR 0 5
70124: PUSH
70125: FOR_IN
70126: IFFALSE 70195
// begin for k in UnitsInside ( j ) do
70128: LD_ADDR_VAR 0 4
70132: PUSH
70133: LD_VAR 0 3
70137: PPUSH
70138: CALL_OW 313
70142: PUSH
70143: FOR_IN
70144: IFFALSE 70191
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70146: LD_VAR 0 4
70150: PPUSH
70151: CALL_OW 257
70155: PUSH
70156: LD_INT 1
70158: EQUAL
70159: PUSH
70160: LD_VAR 0 4
70164: PPUSH
70165: CALL_OW 459
70169: NOT
70170: AND
70171: IFFALSE 70189
// list := list ^ k ;
70173: LD_ADDR_VAR 0 6
70177: PUSH
70178: LD_VAR 0 6
70182: PUSH
70183: LD_VAR 0 4
70187: ADD
70188: ST_TO_ADDR
70189: GO 70143
70191: POP
70192: POP
// end ;
70193: GO 70125
70195: POP
70196: POP
// list := list diff mc_miners [ i ] ;
70197: LD_ADDR_VAR 0 6
70201: PUSH
70202: LD_VAR 0 6
70206: PUSH
70207: LD_EXP 75
70211: PUSH
70212: LD_VAR 0 2
70216: ARRAY
70217: DIFF
70218: ST_TO_ADDR
// if not list then
70219: LD_VAR 0 6
70223: NOT
70224: IFFALSE 70228
// continue ;
70226: GO 69594
// k := mc_mines [ i ] - mc_miners [ i ] ;
70228: LD_ADDR_VAR 0 4
70232: PUSH
70233: LD_EXP 74
70237: PUSH
70238: LD_VAR 0 2
70242: ARRAY
70243: PUSH
70244: LD_EXP 75
70248: PUSH
70249: LD_VAR 0 2
70253: ARRAY
70254: MINUS
70255: ST_TO_ADDR
// if k > list then
70256: LD_VAR 0 4
70260: PUSH
70261: LD_VAR 0 6
70265: GREATER
70266: IFFALSE 70278
// k := list ;
70268: LD_ADDR_VAR 0 4
70272: PUSH
70273: LD_VAR 0 6
70277: ST_TO_ADDR
// for j = 1 to k do
70278: LD_ADDR_VAR 0 3
70282: PUSH
70283: DOUBLE
70284: LD_INT 1
70286: DEC
70287: ST_TO_ADDR
70288: LD_VAR 0 4
70292: PUSH
70293: FOR_TO
70294: IFFALSE 70348
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70296: LD_ADDR_EXP 75
70300: PUSH
70301: LD_EXP 75
70305: PPUSH
70306: LD_VAR 0 2
70310: PUSH
70311: LD_EXP 75
70315: PUSH
70316: LD_VAR 0 2
70320: ARRAY
70321: PUSH
70322: LD_INT 1
70324: PLUS
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PPUSH
70330: LD_VAR 0 6
70334: PUSH
70335: LD_VAR 0 3
70339: ARRAY
70340: PPUSH
70341: CALL 20463 0 3
70345: ST_TO_ADDR
70346: GO 70293
70348: POP
70349: POP
// end ;
70350: GO 69594
70352: POP
70353: POP
// end ;
70354: LD_VAR 0 1
70358: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
70359: LD_INT 0
70361: PPUSH
70362: PPUSH
70363: PPUSH
70364: PPUSH
70365: PPUSH
70366: PPUSH
70367: PPUSH
70368: PPUSH
70369: PPUSH
70370: PPUSH
70371: PPUSH
// if not mc_bases then
70372: LD_EXP 61
70376: NOT
70377: IFFALSE 70381
// exit ;
70379: GO 72204
// for i = 1 to mc_bases do
70381: LD_ADDR_VAR 0 2
70385: PUSH
70386: DOUBLE
70387: LD_INT 1
70389: DEC
70390: ST_TO_ADDR
70391: LD_EXP 61
70395: PUSH
70396: FOR_TO
70397: IFFALSE 72202
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70399: LD_EXP 61
70403: PUSH
70404: LD_VAR 0 2
70408: ARRAY
70409: NOT
70410: PUSH
70411: LD_EXP 68
70415: PUSH
70416: LD_VAR 0 2
70420: ARRAY
70421: OR
70422: IFFALSE 70426
// continue ;
70424: GO 70396
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70426: LD_EXP 77
70430: PUSH
70431: LD_VAR 0 2
70435: ARRAY
70436: NOT
70437: PUSH
70438: LD_EXP 78
70442: PUSH
70443: LD_VAR 0 2
70447: ARRAY
70448: AND
70449: IFFALSE 70487
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70451: LD_ADDR_EXP 78
70455: PUSH
70456: LD_EXP 78
70460: PPUSH
70461: LD_VAR 0 2
70465: PPUSH
70466: EMPTY
70467: PPUSH
70468: CALL_OW 1
70472: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70473: LD_VAR 0 2
70477: PPUSH
70478: LD_INT 107
70480: PPUSH
70481: CALL 61213 0 2
// continue ;
70485: GO 70396
// end ; target := [ ] ;
70487: LD_ADDR_VAR 0 7
70491: PUSH
70492: EMPTY
70493: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70494: LD_ADDR_VAR 0 6
70498: PUSH
70499: LD_EXP 61
70503: PUSH
70504: LD_VAR 0 2
70508: ARRAY
70509: PUSH
70510: LD_INT 1
70512: ARRAY
70513: PPUSH
70514: CALL_OW 255
70518: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70519: LD_ADDR_VAR 0 9
70523: PUSH
70524: LD_EXP 61
70528: PUSH
70529: LD_VAR 0 2
70533: ARRAY
70534: PPUSH
70535: LD_INT 2
70537: PUSH
70538: LD_INT 30
70540: PUSH
70541: LD_INT 0
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 30
70550: PUSH
70551: LD_INT 1
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: EMPTY
70559: LIST
70560: LIST
70561: LIST
70562: PPUSH
70563: CALL_OW 72
70567: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70568: LD_ADDR_VAR 0 3
70572: PUSH
70573: DOUBLE
70574: LD_EXP 77
70578: PUSH
70579: LD_VAR 0 2
70583: ARRAY
70584: INC
70585: ST_TO_ADDR
70586: LD_INT 1
70588: PUSH
70589: FOR_DOWNTO
70590: IFFALSE 70835
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70592: LD_EXP 77
70596: PUSH
70597: LD_VAR 0 2
70601: ARRAY
70602: PUSH
70603: LD_VAR 0 3
70607: ARRAY
70608: PUSH
70609: LD_INT 2
70611: ARRAY
70612: PPUSH
70613: LD_EXP 77
70617: PUSH
70618: LD_VAR 0 2
70622: ARRAY
70623: PUSH
70624: LD_VAR 0 3
70628: ARRAY
70629: PUSH
70630: LD_INT 3
70632: ARRAY
70633: PPUSH
70634: CALL_OW 488
70638: PUSH
70639: LD_EXP 77
70643: PUSH
70644: LD_VAR 0 2
70648: ARRAY
70649: PUSH
70650: LD_VAR 0 3
70654: ARRAY
70655: PUSH
70656: LD_INT 2
70658: ARRAY
70659: PPUSH
70660: LD_EXP 77
70664: PUSH
70665: LD_VAR 0 2
70669: ARRAY
70670: PUSH
70671: LD_VAR 0 3
70675: ARRAY
70676: PUSH
70677: LD_INT 3
70679: ARRAY
70680: PPUSH
70681: CALL_OW 284
70685: PUSH
70686: LD_INT 0
70688: EQUAL
70689: AND
70690: IFFALSE 70745
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70692: LD_ADDR_VAR 0 5
70696: PUSH
70697: LD_EXP 77
70701: PUSH
70702: LD_VAR 0 2
70706: ARRAY
70707: PPUSH
70708: LD_VAR 0 3
70712: PPUSH
70713: CALL_OW 3
70717: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70718: LD_ADDR_EXP 77
70722: PUSH
70723: LD_EXP 77
70727: PPUSH
70728: LD_VAR 0 2
70732: PPUSH
70733: LD_VAR 0 5
70737: PPUSH
70738: CALL_OW 1
70742: ST_TO_ADDR
// continue ;
70743: GO 70589
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70745: LD_VAR 0 6
70749: PPUSH
70750: LD_EXP 77
70754: PUSH
70755: LD_VAR 0 2
70759: ARRAY
70760: PUSH
70761: LD_VAR 0 3
70765: ARRAY
70766: PUSH
70767: LD_INT 2
70769: ARRAY
70770: PPUSH
70771: LD_EXP 77
70775: PUSH
70776: LD_VAR 0 2
70780: ARRAY
70781: PUSH
70782: LD_VAR 0 3
70786: ARRAY
70787: PUSH
70788: LD_INT 3
70790: ARRAY
70791: PPUSH
70792: LD_INT 30
70794: PPUSH
70795: CALL 21359 0 4
70799: PUSH
70800: LD_INT 4
70802: ARRAY
70803: PUSH
70804: LD_INT 0
70806: EQUAL
70807: IFFALSE 70833
// begin target := mc_crates [ i ] [ j ] ;
70809: LD_ADDR_VAR 0 7
70813: PUSH
70814: LD_EXP 77
70818: PUSH
70819: LD_VAR 0 2
70823: ARRAY
70824: PUSH
70825: LD_VAR 0 3
70829: ARRAY
70830: ST_TO_ADDR
// break ;
70831: GO 70835
// end ; end ;
70833: GO 70589
70835: POP
70836: POP
// if not target then
70837: LD_VAR 0 7
70841: NOT
70842: IFFALSE 70846
// continue ;
70844: GO 70396
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70846: LD_ADDR_VAR 0 8
70850: PUSH
70851: LD_EXP 80
70855: PUSH
70856: LD_VAR 0 2
70860: ARRAY
70861: PPUSH
70862: LD_INT 2
70864: PUSH
70865: LD_INT 3
70867: PUSH
70868: LD_INT 58
70870: PUSH
70871: EMPTY
70872: LIST
70873: PUSH
70874: EMPTY
70875: LIST
70876: LIST
70877: PUSH
70878: LD_INT 61
70880: PUSH
70881: EMPTY
70882: LIST
70883: PUSH
70884: LD_INT 33
70886: PUSH
70887: LD_INT 5
70889: PUSH
70890: EMPTY
70891: LIST
70892: LIST
70893: PUSH
70894: LD_INT 33
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: PUSH
70911: LD_INT 2
70913: PUSH
70914: LD_INT 34
70916: PUSH
70917: LD_INT 32
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PUSH
70924: LD_INT 34
70926: PUSH
70927: LD_INT 51
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PUSH
70934: LD_INT 34
70936: PUSH
70937: LD_INT 12
70939: PUSH
70940: EMPTY
70941: LIST
70942: LIST
70943: PUSH
70944: EMPTY
70945: LIST
70946: LIST
70947: LIST
70948: LIST
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PPUSH
70954: CALL_OW 72
70958: ST_TO_ADDR
// if not cargo then
70959: LD_VAR 0 8
70963: NOT
70964: IFFALSE 71670
// begin if mc_crates_collector [ i ] < 5 then
70966: LD_EXP 78
70970: PUSH
70971: LD_VAR 0 2
70975: ARRAY
70976: PUSH
70977: LD_INT 5
70979: LESS
70980: IFFALSE 71346
// begin if mc_ape [ i ] then
70982: LD_EXP 90
70986: PUSH
70987: LD_VAR 0 2
70991: ARRAY
70992: IFFALSE 71039
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70994: LD_ADDR_VAR 0 5
70998: PUSH
70999: LD_EXP 90
71003: PUSH
71004: LD_VAR 0 2
71008: ARRAY
71009: PPUSH
71010: LD_INT 25
71012: PUSH
71013: LD_INT 16
71015: PUSH
71016: EMPTY
71017: LIST
71018: LIST
71019: PUSH
71020: LD_INT 24
71022: PUSH
71023: LD_INT 750
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: EMPTY
71031: LIST
71032: LIST
71033: PPUSH
71034: CALL_OW 72
71038: ST_TO_ADDR
// if not tmp then
71039: LD_VAR 0 5
71043: NOT
71044: IFFALSE 71091
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71046: LD_ADDR_VAR 0 5
71050: PUSH
71051: LD_EXP 61
71055: PUSH
71056: LD_VAR 0 2
71060: ARRAY
71061: PPUSH
71062: LD_INT 25
71064: PUSH
71065: LD_INT 2
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 24
71074: PUSH
71075: LD_INT 750
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: EMPTY
71083: LIST
71084: LIST
71085: PPUSH
71086: CALL_OW 72
71090: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71091: LD_EXP 90
71095: PUSH
71096: LD_VAR 0 2
71100: ARRAY
71101: PUSH
71102: LD_EXP 61
71106: PUSH
71107: LD_VAR 0 2
71111: ARRAY
71112: PPUSH
71113: LD_INT 25
71115: PUSH
71116: LD_INT 2
71118: PUSH
71119: EMPTY
71120: LIST
71121: LIST
71122: PUSH
71123: LD_INT 24
71125: PUSH
71126: LD_INT 750
71128: PUSH
71129: EMPTY
71130: LIST
71131: LIST
71132: PUSH
71133: EMPTY
71134: LIST
71135: LIST
71136: PPUSH
71137: CALL_OW 72
71141: AND
71142: PUSH
71143: LD_VAR 0 5
71147: PUSH
71148: LD_INT 5
71150: LESS
71151: AND
71152: IFFALSE 71234
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71154: LD_ADDR_VAR 0 3
71158: PUSH
71159: LD_EXP 61
71163: PUSH
71164: LD_VAR 0 2
71168: ARRAY
71169: PPUSH
71170: LD_INT 25
71172: PUSH
71173: LD_INT 2
71175: PUSH
71176: EMPTY
71177: LIST
71178: LIST
71179: PUSH
71180: LD_INT 24
71182: PUSH
71183: LD_INT 750
71185: PUSH
71186: EMPTY
71187: LIST
71188: LIST
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PPUSH
71194: CALL_OW 72
71198: PUSH
71199: FOR_IN
71200: IFFALSE 71232
// begin tmp := tmp union j ;
71202: LD_ADDR_VAR 0 5
71206: PUSH
71207: LD_VAR 0 5
71211: PUSH
71212: LD_VAR 0 3
71216: UNION
71217: ST_TO_ADDR
// if tmp >= 5 then
71218: LD_VAR 0 5
71222: PUSH
71223: LD_INT 5
71225: GREATEREQUAL
71226: IFFALSE 71230
// break ;
71228: GO 71232
// end ;
71230: GO 71199
71232: POP
71233: POP
// end ; if not tmp then
71234: LD_VAR 0 5
71238: NOT
71239: IFFALSE 71243
// continue ;
71241: GO 70396
// for j in tmp do
71243: LD_ADDR_VAR 0 3
71247: PUSH
71248: LD_VAR 0 5
71252: PUSH
71253: FOR_IN
71254: IFFALSE 71344
// if not GetTag ( j ) then
71256: LD_VAR 0 3
71260: PPUSH
71261: CALL_OW 110
71265: NOT
71266: IFFALSE 71342
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71268: LD_ADDR_EXP 78
71272: PUSH
71273: LD_EXP 78
71277: PPUSH
71278: LD_VAR 0 2
71282: PUSH
71283: LD_EXP 78
71287: PUSH
71288: LD_VAR 0 2
71292: ARRAY
71293: PUSH
71294: LD_INT 1
71296: PLUS
71297: PUSH
71298: EMPTY
71299: LIST
71300: LIST
71301: PPUSH
71302: LD_VAR 0 3
71306: PPUSH
71307: CALL 20463 0 3
71311: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71312: LD_VAR 0 3
71316: PPUSH
71317: LD_INT 107
71319: PPUSH
71320: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71324: LD_EXP 78
71328: PUSH
71329: LD_VAR 0 2
71333: ARRAY
71334: PUSH
71335: LD_INT 5
71337: GREATEREQUAL
71338: IFFALSE 71342
// break ;
71340: GO 71344
// end ;
71342: GO 71253
71344: POP
71345: POP
// end ; if mc_crates_collector [ i ] and target then
71346: LD_EXP 78
71350: PUSH
71351: LD_VAR 0 2
71355: ARRAY
71356: PUSH
71357: LD_VAR 0 7
71361: AND
71362: IFFALSE 71668
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71364: LD_EXP 78
71368: PUSH
71369: LD_VAR 0 2
71373: ARRAY
71374: PUSH
71375: LD_VAR 0 7
71379: PUSH
71380: LD_INT 1
71382: ARRAY
71383: LESS
71384: IFFALSE 71404
// tmp := mc_crates_collector [ i ] else
71386: LD_ADDR_VAR 0 5
71390: PUSH
71391: LD_EXP 78
71395: PUSH
71396: LD_VAR 0 2
71400: ARRAY
71401: ST_TO_ADDR
71402: GO 71418
// tmp := target [ 1 ] ;
71404: LD_ADDR_VAR 0 5
71408: PUSH
71409: LD_VAR 0 7
71413: PUSH
71414: LD_INT 1
71416: ARRAY
71417: ST_TO_ADDR
// k := 0 ;
71418: LD_ADDR_VAR 0 4
71422: PUSH
71423: LD_INT 0
71425: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71426: LD_ADDR_VAR 0 3
71430: PUSH
71431: LD_EXP 78
71435: PUSH
71436: LD_VAR 0 2
71440: ARRAY
71441: PUSH
71442: FOR_IN
71443: IFFALSE 71666
// begin k := k + 1 ;
71445: LD_ADDR_VAR 0 4
71449: PUSH
71450: LD_VAR 0 4
71454: PUSH
71455: LD_INT 1
71457: PLUS
71458: ST_TO_ADDR
// if k > tmp then
71459: LD_VAR 0 4
71463: PUSH
71464: LD_VAR 0 5
71468: GREATER
71469: IFFALSE 71473
// break ;
71471: GO 71666
// if not GetClass ( j ) in [ 2 , 16 ] then
71473: LD_VAR 0 3
71477: PPUSH
71478: CALL_OW 257
71482: PUSH
71483: LD_INT 2
71485: PUSH
71486: LD_INT 16
71488: PUSH
71489: EMPTY
71490: LIST
71491: LIST
71492: IN
71493: NOT
71494: IFFALSE 71547
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71496: LD_ADDR_EXP 78
71500: PUSH
71501: LD_EXP 78
71505: PPUSH
71506: LD_VAR 0 2
71510: PPUSH
71511: LD_EXP 78
71515: PUSH
71516: LD_VAR 0 2
71520: ARRAY
71521: PUSH
71522: LD_VAR 0 3
71526: DIFF
71527: PPUSH
71528: CALL_OW 1
71532: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71533: LD_VAR 0 3
71537: PPUSH
71538: LD_INT 0
71540: PPUSH
71541: CALL_OW 109
// continue ;
71545: GO 71442
// end ; if IsInUnit ( j ) then
71547: LD_VAR 0 3
71551: PPUSH
71552: CALL_OW 310
71556: IFFALSE 71567
// ComExitBuilding ( j ) ;
71558: LD_VAR 0 3
71562: PPUSH
71563: CALL_OW 122
// wait ( 3 ) ;
71567: LD_INT 3
71569: PPUSH
71570: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
71574: LD_VAR 0 3
71578: PPUSH
71579: CALL_OW 314
71583: PUSH
71584: LD_VAR 0 6
71588: PPUSH
71589: LD_VAR 0 7
71593: PUSH
71594: LD_INT 2
71596: ARRAY
71597: PPUSH
71598: LD_VAR 0 7
71602: PUSH
71603: LD_INT 3
71605: ARRAY
71606: PPUSH
71607: LD_INT 30
71609: PPUSH
71610: CALL 21359 0 4
71614: PUSH
71615: LD_INT 4
71617: ARRAY
71618: AND
71619: IFFALSE 71637
// ComStandNearbyBuilding ( j , depot ) else
71621: LD_VAR 0 3
71625: PPUSH
71626: LD_VAR 0 9
71630: PPUSH
71631: CALL 17065 0 2
71635: GO 71664
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71637: LD_VAR 0 3
71641: PPUSH
71642: LD_VAR 0 7
71646: PUSH
71647: LD_INT 2
71649: ARRAY
71650: PPUSH
71651: LD_VAR 0 7
71655: PUSH
71656: LD_INT 3
71658: ARRAY
71659: PPUSH
71660: CALL_OW 117
// end ;
71664: GO 71442
71666: POP
71667: POP
// end ; end else
71668: GO 72200
// begin for j in cargo do
71670: LD_ADDR_VAR 0 3
71674: PUSH
71675: LD_VAR 0 8
71679: PUSH
71680: FOR_IN
71681: IFFALSE 72198
// begin if GetTag ( j ) <> 0 then
71683: LD_VAR 0 3
71687: PPUSH
71688: CALL_OW 110
71692: PUSH
71693: LD_INT 0
71695: NONEQUAL
71696: IFFALSE 71700
// continue ;
71698: GO 71680
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71700: LD_VAR 0 3
71704: PPUSH
71705: CALL_OW 256
71709: PUSH
71710: LD_INT 1000
71712: LESS
71713: PUSH
71714: LD_VAR 0 3
71718: PPUSH
71719: LD_EXP 85
71723: PUSH
71724: LD_VAR 0 2
71728: ARRAY
71729: PPUSH
71730: CALL_OW 308
71734: NOT
71735: AND
71736: IFFALSE 71758
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71738: LD_VAR 0 3
71742: PPUSH
71743: LD_EXP 85
71747: PUSH
71748: LD_VAR 0 2
71752: ARRAY
71753: PPUSH
71754: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71758: LD_VAR 0 3
71762: PPUSH
71763: CALL_OW 256
71767: PUSH
71768: LD_INT 1000
71770: LESS
71771: PUSH
71772: LD_VAR 0 3
71776: PPUSH
71777: LD_EXP 85
71781: PUSH
71782: LD_VAR 0 2
71786: ARRAY
71787: PPUSH
71788: CALL_OW 308
71792: AND
71793: IFFALSE 71797
// continue ;
71795: GO 71680
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71797: LD_VAR 0 3
71801: PPUSH
71802: CALL_OW 262
71806: PUSH
71807: LD_INT 2
71809: EQUAL
71810: PUSH
71811: LD_VAR 0 3
71815: PPUSH
71816: CALL_OW 261
71820: PUSH
71821: LD_INT 15
71823: LESS
71824: AND
71825: IFFALSE 71829
// continue ;
71827: GO 71680
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71829: LD_VAR 0 3
71833: PPUSH
71834: CALL_OW 262
71838: PUSH
71839: LD_INT 1
71841: EQUAL
71842: PUSH
71843: LD_VAR 0 3
71847: PPUSH
71848: CALL_OW 261
71852: PUSH
71853: LD_INT 10
71855: LESS
71856: AND
71857: IFFALSE 72137
// begin if not depot then
71859: LD_VAR 0 9
71863: NOT
71864: IFFALSE 71868
// continue ;
71866: GO 71680
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71868: LD_VAR 0 3
71872: PPUSH
71873: LD_VAR 0 9
71877: PPUSH
71878: LD_VAR 0 3
71882: PPUSH
71883: CALL_OW 74
71887: PPUSH
71888: CALL_OW 296
71892: PUSH
71893: LD_INT 6
71895: LESS
71896: IFFALSE 71912
// SetFuel ( j , 100 ) else
71898: LD_VAR 0 3
71902: PPUSH
71903: LD_INT 100
71905: PPUSH
71906: CALL_OW 240
71910: GO 72137
// if GetFuel ( j ) = 0 then
71912: LD_VAR 0 3
71916: PPUSH
71917: CALL_OW 261
71921: PUSH
71922: LD_INT 0
71924: EQUAL
71925: IFFALSE 72137
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71927: LD_ADDR_EXP 80
71931: PUSH
71932: LD_EXP 80
71936: PPUSH
71937: LD_VAR 0 2
71941: PPUSH
71942: LD_EXP 80
71946: PUSH
71947: LD_VAR 0 2
71951: ARRAY
71952: PUSH
71953: LD_VAR 0 3
71957: DIFF
71958: PPUSH
71959: CALL_OW 1
71963: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71964: LD_VAR 0 3
71968: PPUSH
71969: CALL_OW 263
71973: PUSH
71974: LD_INT 1
71976: EQUAL
71977: IFFALSE 71993
// ComExitVehicle ( IsInUnit ( j ) ) ;
71979: LD_VAR 0 3
71983: PPUSH
71984: CALL_OW 310
71988: PPUSH
71989: CALL_OW 121
// if GetControl ( j ) = control_remote then
71993: LD_VAR 0 3
71997: PPUSH
71998: CALL_OW 263
72002: PUSH
72003: LD_INT 2
72005: EQUAL
72006: IFFALSE 72017
// ComUnlink ( j ) ;
72008: LD_VAR 0 3
72012: PPUSH
72013: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
72017: LD_ADDR_VAR 0 10
72021: PUSH
72022: LD_VAR 0 2
72026: PPUSH
72027: LD_INT 3
72029: PPUSH
72030: CALL 81781 0 2
72034: ST_TO_ADDR
// if fac then
72035: LD_VAR 0 10
72039: IFFALSE 72135
// begin for k in fac do
72041: LD_ADDR_VAR 0 4
72045: PUSH
72046: LD_VAR 0 10
72050: PUSH
72051: FOR_IN
72052: IFFALSE 72133
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72054: LD_ADDR_VAR 0 11
72058: PUSH
72059: LD_VAR 0 10
72063: PPUSH
72064: LD_VAR 0 3
72068: PPUSH
72069: CALL_OW 265
72073: PPUSH
72074: LD_VAR 0 3
72078: PPUSH
72079: CALL_OW 262
72083: PPUSH
72084: LD_VAR 0 3
72088: PPUSH
72089: CALL_OW 263
72093: PPUSH
72094: LD_VAR 0 3
72098: PPUSH
72099: CALL_OW 264
72103: PPUSH
72104: CALL 17961 0 5
72108: ST_TO_ADDR
// if components then
72109: LD_VAR 0 11
72113: IFFALSE 72131
// begin MC_InsertProduceList ( i , components ) ;
72115: LD_VAR 0 2
72119: PPUSH
72120: LD_VAR 0 11
72124: PPUSH
72125: CALL 81326 0 2
// break ;
72129: GO 72133
// end ; end ;
72131: GO 72051
72133: POP
72134: POP
// end ; continue ;
72135: GO 71680
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72137: LD_VAR 0 3
72141: PPUSH
72142: LD_INT 1
72144: PPUSH
72145: CALL_OW 289
72149: PUSH
72150: LD_INT 100
72152: LESS
72153: PUSH
72154: LD_VAR 0 3
72158: PPUSH
72159: CALL_OW 314
72163: NOT
72164: AND
72165: IFFALSE 72194
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72167: LD_VAR 0 3
72171: PPUSH
72172: LD_VAR 0 7
72176: PUSH
72177: LD_INT 2
72179: ARRAY
72180: PPUSH
72181: LD_VAR 0 7
72185: PUSH
72186: LD_INT 3
72188: ARRAY
72189: PPUSH
72190: CALL_OW 117
// break ;
72194: GO 72198
// end ;
72196: GO 71680
72198: POP
72199: POP
// end ; end ;
72200: GO 70396
72202: POP
72203: POP
// end ;
72204: LD_VAR 0 1
72208: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72209: LD_INT 0
72211: PPUSH
72212: PPUSH
72213: PPUSH
72214: PPUSH
// if not mc_bases then
72215: LD_EXP 61
72219: NOT
72220: IFFALSE 72224
// exit ;
72222: GO 72385
// for i = 1 to mc_bases do
72224: LD_ADDR_VAR 0 2
72228: PUSH
72229: DOUBLE
72230: LD_INT 1
72232: DEC
72233: ST_TO_ADDR
72234: LD_EXP 61
72238: PUSH
72239: FOR_TO
72240: IFFALSE 72383
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72242: LD_ADDR_VAR 0 4
72246: PUSH
72247: LD_EXP 80
72251: PUSH
72252: LD_VAR 0 2
72256: ARRAY
72257: PUSH
72258: LD_EXP 83
72262: PUSH
72263: LD_VAR 0 2
72267: ARRAY
72268: UNION
72269: PPUSH
72270: LD_INT 33
72272: PUSH
72273: LD_INT 2
72275: PUSH
72276: EMPTY
72277: LIST
72278: LIST
72279: PPUSH
72280: CALL_OW 72
72284: ST_TO_ADDR
// if tmp then
72285: LD_VAR 0 4
72289: IFFALSE 72381
// for j in tmp do
72291: LD_ADDR_VAR 0 3
72295: PUSH
72296: LD_VAR 0 4
72300: PUSH
72301: FOR_IN
72302: IFFALSE 72379
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72304: LD_VAR 0 3
72308: PPUSH
72309: CALL_OW 312
72313: NOT
72314: PUSH
72315: LD_VAR 0 3
72319: PPUSH
72320: CALL_OW 256
72324: PUSH
72325: LD_INT 250
72327: GREATEREQUAL
72328: AND
72329: IFFALSE 72342
// Connect ( j ) else
72331: LD_VAR 0 3
72335: PPUSH
72336: CALL 23441 0 1
72340: GO 72377
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72342: LD_VAR 0 3
72346: PPUSH
72347: CALL_OW 256
72351: PUSH
72352: LD_INT 250
72354: LESS
72355: PUSH
72356: LD_VAR 0 3
72360: PPUSH
72361: CALL_OW 312
72365: AND
72366: IFFALSE 72377
// ComUnlink ( j ) ;
72368: LD_VAR 0 3
72372: PPUSH
72373: CALL_OW 136
72377: GO 72301
72379: POP
72380: POP
// end ;
72381: GO 72239
72383: POP
72384: POP
// end ;
72385: LD_VAR 0 1
72389: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72390: LD_INT 0
72392: PPUSH
72393: PPUSH
72394: PPUSH
72395: PPUSH
72396: PPUSH
// if not mc_bases then
72397: LD_EXP 61
72401: NOT
72402: IFFALSE 72406
// exit ;
72404: GO 72851
// for i = 1 to mc_bases do
72406: LD_ADDR_VAR 0 2
72410: PUSH
72411: DOUBLE
72412: LD_INT 1
72414: DEC
72415: ST_TO_ADDR
72416: LD_EXP 61
72420: PUSH
72421: FOR_TO
72422: IFFALSE 72849
// begin if not mc_produce [ i ] then
72424: LD_EXP 82
72428: PUSH
72429: LD_VAR 0 2
72433: ARRAY
72434: NOT
72435: IFFALSE 72439
// continue ;
72437: GO 72421
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72439: LD_ADDR_VAR 0 5
72443: PUSH
72444: LD_EXP 61
72448: PUSH
72449: LD_VAR 0 2
72453: ARRAY
72454: PPUSH
72455: LD_INT 30
72457: PUSH
72458: LD_INT 3
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PPUSH
72465: CALL_OW 72
72469: ST_TO_ADDR
// if not fac then
72470: LD_VAR 0 5
72474: NOT
72475: IFFALSE 72479
// continue ;
72477: GO 72421
// for j in fac do
72479: LD_ADDR_VAR 0 3
72483: PUSH
72484: LD_VAR 0 5
72488: PUSH
72489: FOR_IN
72490: IFFALSE 72845
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72492: LD_VAR 0 3
72496: PPUSH
72497: CALL_OW 461
72501: PUSH
72502: LD_INT 2
72504: NONEQUAL
72505: PUSH
72506: LD_VAR 0 3
72510: PPUSH
72511: LD_INT 15
72513: PPUSH
72514: CALL 23060 0 2
72518: PUSH
72519: LD_INT 4
72521: ARRAY
72522: OR
72523: IFFALSE 72527
// continue ;
72525: GO 72489
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72527: LD_VAR 0 3
72531: PPUSH
72532: LD_EXP 82
72536: PUSH
72537: LD_VAR 0 2
72541: ARRAY
72542: PUSH
72543: LD_INT 1
72545: ARRAY
72546: PUSH
72547: LD_INT 1
72549: ARRAY
72550: PPUSH
72551: LD_EXP 82
72555: PUSH
72556: LD_VAR 0 2
72560: ARRAY
72561: PUSH
72562: LD_INT 1
72564: ARRAY
72565: PUSH
72566: LD_INT 2
72568: ARRAY
72569: PPUSH
72570: LD_EXP 82
72574: PUSH
72575: LD_VAR 0 2
72579: ARRAY
72580: PUSH
72581: LD_INT 1
72583: ARRAY
72584: PUSH
72585: LD_INT 3
72587: ARRAY
72588: PPUSH
72589: LD_EXP 82
72593: PUSH
72594: LD_VAR 0 2
72598: ARRAY
72599: PUSH
72600: LD_INT 1
72602: ARRAY
72603: PUSH
72604: LD_INT 4
72606: ARRAY
72607: PPUSH
72608: CALL_OW 448
72612: PUSH
72613: LD_VAR 0 3
72617: PPUSH
72618: LD_EXP 82
72622: PUSH
72623: LD_VAR 0 2
72627: ARRAY
72628: PUSH
72629: LD_INT 1
72631: ARRAY
72632: PUSH
72633: LD_INT 1
72635: ARRAY
72636: PUSH
72637: LD_EXP 82
72641: PUSH
72642: LD_VAR 0 2
72646: ARRAY
72647: PUSH
72648: LD_INT 1
72650: ARRAY
72651: PUSH
72652: LD_INT 2
72654: ARRAY
72655: PUSH
72656: LD_EXP 82
72660: PUSH
72661: LD_VAR 0 2
72665: ARRAY
72666: PUSH
72667: LD_INT 1
72669: ARRAY
72670: PUSH
72671: LD_INT 3
72673: ARRAY
72674: PUSH
72675: LD_EXP 82
72679: PUSH
72680: LD_VAR 0 2
72684: ARRAY
72685: PUSH
72686: LD_INT 1
72688: ARRAY
72689: PUSH
72690: LD_INT 4
72692: ARRAY
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: LIST
72698: LIST
72699: PPUSH
72700: CALL 26836 0 2
72704: AND
72705: IFFALSE 72843
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72707: LD_VAR 0 3
72711: PPUSH
72712: LD_EXP 82
72716: PUSH
72717: LD_VAR 0 2
72721: ARRAY
72722: PUSH
72723: LD_INT 1
72725: ARRAY
72726: PUSH
72727: LD_INT 1
72729: ARRAY
72730: PPUSH
72731: LD_EXP 82
72735: PUSH
72736: LD_VAR 0 2
72740: ARRAY
72741: PUSH
72742: LD_INT 1
72744: ARRAY
72745: PUSH
72746: LD_INT 2
72748: ARRAY
72749: PPUSH
72750: LD_EXP 82
72754: PUSH
72755: LD_VAR 0 2
72759: ARRAY
72760: PUSH
72761: LD_INT 1
72763: ARRAY
72764: PUSH
72765: LD_INT 3
72767: ARRAY
72768: PPUSH
72769: LD_EXP 82
72773: PUSH
72774: LD_VAR 0 2
72778: ARRAY
72779: PUSH
72780: LD_INT 1
72782: ARRAY
72783: PUSH
72784: LD_INT 4
72786: ARRAY
72787: PPUSH
72788: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72792: LD_ADDR_VAR 0 4
72796: PUSH
72797: LD_EXP 82
72801: PUSH
72802: LD_VAR 0 2
72806: ARRAY
72807: PPUSH
72808: LD_INT 1
72810: PPUSH
72811: CALL_OW 3
72815: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72816: LD_ADDR_EXP 82
72820: PUSH
72821: LD_EXP 82
72825: PPUSH
72826: LD_VAR 0 2
72830: PPUSH
72831: LD_VAR 0 4
72835: PPUSH
72836: CALL_OW 1
72840: ST_TO_ADDR
// break ;
72841: GO 72845
// end ; end ;
72843: GO 72489
72845: POP
72846: POP
// end ;
72847: GO 72421
72849: POP
72850: POP
// end ;
72851: LD_VAR 0 1
72855: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72856: LD_INT 0
72858: PPUSH
72859: PPUSH
72860: PPUSH
// if not mc_bases then
72861: LD_EXP 61
72865: NOT
72866: IFFALSE 72870
// exit ;
72868: GO 72959
// for i = 1 to mc_bases do
72870: LD_ADDR_VAR 0 2
72874: PUSH
72875: DOUBLE
72876: LD_INT 1
72878: DEC
72879: ST_TO_ADDR
72880: LD_EXP 61
72884: PUSH
72885: FOR_TO
72886: IFFALSE 72957
// begin if mc_attack [ i ] then
72888: LD_EXP 81
72892: PUSH
72893: LD_VAR 0 2
72897: ARRAY
72898: IFFALSE 72955
// begin tmp := mc_attack [ i ] [ 1 ] ;
72900: LD_ADDR_VAR 0 3
72904: PUSH
72905: LD_EXP 81
72909: PUSH
72910: LD_VAR 0 2
72914: ARRAY
72915: PUSH
72916: LD_INT 1
72918: ARRAY
72919: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72920: LD_ADDR_EXP 81
72924: PUSH
72925: LD_EXP 81
72929: PPUSH
72930: LD_VAR 0 2
72934: PPUSH
72935: EMPTY
72936: PPUSH
72937: CALL_OW 1
72941: ST_TO_ADDR
// Attack ( tmp ) ;
72942: LD_VAR 0 3
72946: PPUSH
72947: CALL 107843 0 1
// exit ;
72951: POP
72952: POP
72953: GO 72959
// end ; end ;
72955: GO 72885
72957: POP
72958: POP
// end ;
72959: LD_VAR 0 1
72963: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72964: LD_INT 0
72966: PPUSH
72967: PPUSH
72968: PPUSH
72969: PPUSH
72970: PPUSH
72971: PPUSH
72972: PPUSH
// if not mc_bases then
72973: LD_EXP 61
72977: NOT
72978: IFFALSE 72982
// exit ;
72980: GO 73839
// for i = 1 to mc_bases do
72982: LD_ADDR_VAR 0 2
72986: PUSH
72987: DOUBLE
72988: LD_INT 1
72990: DEC
72991: ST_TO_ADDR
72992: LD_EXP 61
72996: PUSH
72997: FOR_TO
72998: IFFALSE 73837
// begin if not mc_bases [ i ] then
73000: LD_EXP 61
73004: PUSH
73005: LD_VAR 0 2
73009: ARRAY
73010: NOT
73011: IFFALSE 73015
// continue ;
73013: GO 72997
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
73015: LD_ADDR_VAR 0 7
73019: PUSH
73020: LD_EXP 61
73024: PUSH
73025: LD_VAR 0 2
73029: ARRAY
73030: PUSH
73031: LD_INT 1
73033: ARRAY
73034: PPUSH
73035: CALL 17287 0 1
73039: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73040: LD_ADDR_EXP 84
73044: PUSH
73045: LD_EXP 84
73049: PPUSH
73050: LD_VAR 0 2
73054: PPUSH
73055: LD_EXP 61
73059: PUSH
73060: LD_VAR 0 2
73064: ARRAY
73065: PUSH
73066: LD_INT 1
73068: ARRAY
73069: PPUSH
73070: CALL_OW 255
73074: PPUSH
73075: LD_EXP 86
73079: PUSH
73080: LD_VAR 0 2
73084: ARRAY
73085: PPUSH
73086: CALL 17252 0 2
73090: PPUSH
73091: CALL_OW 1
73095: ST_TO_ADDR
// if not mc_scan [ i ] then
73096: LD_EXP 84
73100: PUSH
73101: LD_VAR 0 2
73105: ARRAY
73106: NOT
73107: IFFALSE 73285
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
73109: LD_ADDR_EXP 104
73113: PUSH
73114: LD_EXP 104
73118: PPUSH
73119: LD_VAR 0 2
73123: PPUSH
73124: LD_INT 0
73126: PPUSH
73127: CALL_OW 1
73131: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73132: LD_ADDR_VAR 0 4
73136: PUSH
73137: LD_EXP 61
73141: PUSH
73142: LD_VAR 0 2
73146: ARRAY
73147: PPUSH
73148: LD_INT 2
73150: PUSH
73151: LD_INT 25
73153: PUSH
73154: LD_INT 5
73156: PUSH
73157: EMPTY
73158: LIST
73159: LIST
73160: PUSH
73161: LD_INT 25
73163: PUSH
73164: LD_INT 8
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 25
73173: PUSH
73174: LD_INT 9
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: LIST
73185: LIST
73186: PPUSH
73187: CALL_OW 72
73191: ST_TO_ADDR
// if not tmp then
73192: LD_VAR 0 4
73196: NOT
73197: IFFALSE 73201
// continue ;
73199: GO 72997
// for j in tmp do
73201: LD_ADDR_VAR 0 3
73205: PUSH
73206: LD_VAR 0 4
73210: PUSH
73211: FOR_IN
73212: IFFALSE 73283
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73214: LD_VAR 0 3
73218: PPUSH
73219: CALL_OW 310
73223: PPUSH
73224: CALL_OW 266
73228: PUSH
73229: LD_INT 5
73231: EQUAL
73232: PUSH
73233: LD_VAR 0 3
73237: PPUSH
73238: CALL_OW 257
73242: PUSH
73243: LD_INT 1
73245: EQUAL
73246: AND
73247: PUSH
73248: LD_VAR 0 3
73252: PPUSH
73253: CALL_OW 459
73257: NOT
73258: AND
73259: PUSH
73260: LD_VAR 0 7
73264: AND
73265: IFFALSE 73281
// ComChangeProfession ( j , class ) ;
73267: LD_VAR 0 3
73271: PPUSH
73272: LD_VAR 0 7
73276: PPUSH
73277: CALL_OW 123
73281: GO 73211
73283: POP
73284: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
73285: LD_EXP 84
73289: PUSH
73290: LD_VAR 0 2
73294: ARRAY
73295: PUSH
73296: LD_EXP 104
73300: PUSH
73301: LD_VAR 0 2
73305: ARRAY
73306: NOT
73307: AND
73308: PUSH
73309: LD_EXP 83
73313: PUSH
73314: LD_VAR 0 2
73318: ARRAY
73319: NOT
73320: AND
73321: PUSH
73322: LD_EXP 61
73326: PUSH
73327: LD_VAR 0 2
73331: ARRAY
73332: PPUSH
73333: LD_INT 50
73335: PUSH
73336: EMPTY
73337: LIST
73338: PUSH
73339: LD_INT 2
73341: PUSH
73342: LD_INT 30
73344: PUSH
73345: LD_INT 32
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 30
73354: PUSH
73355: LD_INT 33
73357: PUSH
73358: EMPTY
73359: LIST
73360: LIST
73361: PUSH
73362: LD_INT 30
73364: PUSH
73365: LD_INT 4
73367: PUSH
73368: EMPTY
73369: LIST
73370: LIST
73371: PUSH
73372: LD_INT 30
73374: PUSH
73375: LD_INT 5
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: LIST
73386: LIST
73387: LIST
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PPUSH
73393: CALL_OW 72
73397: PUSH
73398: LD_INT 4
73400: LESS
73401: PUSH
73402: LD_EXP 61
73406: PUSH
73407: LD_VAR 0 2
73411: ARRAY
73412: PPUSH
73413: LD_INT 3
73415: PUSH
73416: LD_INT 24
73418: PUSH
73419: LD_INT 1000
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: PUSH
73430: LD_INT 2
73432: PUSH
73433: LD_INT 30
73435: PUSH
73436: LD_INT 0
73438: PUSH
73439: EMPTY
73440: LIST
73441: LIST
73442: PUSH
73443: LD_INT 30
73445: PUSH
73446: LD_INT 1
73448: PUSH
73449: EMPTY
73450: LIST
73451: LIST
73452: PUSH
73453: EMPTY
73454: LIST
73455: LIST
73456: LIST
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PPUSH
73462: CALL_OW 72
73466: OR
73467: AND
73468: IFFALSE 73719
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73470: LD_ADDR_EXP 104
73474: PUSH
73475: LD_EXP 104
73479: PPUSH
73480: LD_VAR 0 2
73484: PPUSH
73485: LD_INT 1
73487: PPUSH
73488: CALL_OW 1
73492: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73493: LD_ADDR_VAR 0 4
73497: PUSH
73498: LD_EXP 61
73502: PUSH
73503: LD_VAR 0 2
73507: ARRAY
73508: PPUSH
73509: LD_INT 2
73511: PUSH
73512: LD_INT 25
73514: PUSH
73515: LD_INT 1
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 25
73524: PUSH
73525: LD_INT 5
73527: PUSH
73528: EMPTY
73529: LIST
73530: LIST
73531: PUSH
73532: LD_INT 25
73534: PUSH
73535: LD_INT 8
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: PUSH
73542: LD_INT 25
73544: PUSH
73545: LD_INT 9
73547: PUSH
73548: EMPTY
73549: LIST
73550: LIST
73551: PUSH
73552: EMPTY
73553: LIST
73554: LIST
73555: LIST
73556: LIST
73557: LIST
73558: PPUSH
73559: CALL_OW 72
73563: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73564: LD_ADDR_VAR 0 4
73568: PUSH
73569: LD_VAR 0 4
73573: PUSH
73574: LD_VAR 0 4
73578: PPUSH
73579: LD_INT 18
73581: PPUSH
73582: CALL 50404 0 2
73586: DIFF
73587: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73588: LD_VAR 0 4
73592: NOT
73593: PUSH
73594: LD_EXP 61
73598: PUSH
73599: LD_VAR 0 2
73603: ARRAY
73604: PPUSH
73605: LD_INT 2
73607: PUSH
73608: LD_INT 30
73610: PUSH
73611: LD_INT 4
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 30
73620: PUSH
73621: LD_INT 5
73623: PUSH
73624: EMPTY
73625: LIST
73626: LIST
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: LIST
73632: PPUSH
73633: CALL_OW 72
73637: NOT
73638: AND
73639: IFFALSE 73701
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
73641: LD_ADDR_VAR 0 4
73645: PUSH
73646: LD_EXP 61
73650: PUSH
73651: LD_VAR 0 2
73655: ARRAY
73656: PPUSH
73657: LD_INT 2
73659: PUSH
73660: LD_INT 25
73662: PUSH
73663: LD_INT 2
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 25
73672: PUSH
73673: LD_INT 3
73675: PUSH
73676: EMPTY
73677: LIST
73678: LIST
73679: PUSH
73680: LD_INT 25
73682: PUSH
73683: LD_INT 4
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: LIST
73694: LIST
73695: PPUSH
73696: CALL_OW 72
73700: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
73701: LD_VAR 0 2
73705: PPUSH
73706: LD_VAR 0 4
73710: PPUSH
73711: CALL 112552 0 2
// exit ;
73715: POP
73716: POP
73717: GO 73839
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
73719: LD_EXP 84
73723: PUSH
73724: LD_VAR 0 2
73728: ARRAY
73729: PUSH
73730: LD_EXP 104
73734: PUSH
73735: LD_VAR 0 2
73739: ARRAY
73740: NOT
73741: AND
73742: PUSH
73743: LD_EXP 83
73747: PUSH
73748: LD_VAR 0 2
73752: ARRAY
73753: AND
73754: IFFALSE 73835
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73756: LD_ADDR_EXP 104
73760: PUSH
73761: LD_EXP 104
73765: PPUSH
73766: LD_VAR 0 2
73770: PPUSH
73771: LD_INT 1
73773: PPUSH
73774: CALL_OW 1
73778: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73779: LD_ADDR_VAR 0 4
73783: PUSH
73784: LD_EXP 83
73788: PUSH
73789: LD_VAR 0 2
73793: ARRAY
73794: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73795: LD_ADDR_EXP 83
73799: PUSH
73800: LD_EXP 83
73804: PPUSH
73805: LD_VAR 0 2
73809: PPUSH
73810: EMPTY
73811: PPUSH
73812: CALL_OW 1
73816: ST_TO_ADDR
// Defend ( i , tmp ) ;
73817: LD_VAR 0 2
73821: PPUSH
73822: LD_VAR 0 4
73826: PPUSH
73827: CALL 113148 0 2
// exit ;
73831: POP
73832: POP
73833: GO 73839
// end ; end ;
73835: GO 72997
73837: POP
73838: POP
// end ;
73839: LD_VAR 0 1
73843: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73844: LD_INT 0
73846: PPUSH
73847: PPUSH
73848: PPUSH
73849: PPUSH
73850: PPUSH
73851: PPUSH
73852: PPUSH
73853: PPUSH
73854: PPUSH
73855: PPUSH
73856: PPUSH
// if not mc_bases then
73857: LD_EXP 61
73861: NOT
73862: IFFALSE 73866
// exit ;
73864: GO 74953
// for i = 1 to mc_bases do
73866: LD_ADDR_VAR 0 2
73870: PUSH
73871: DOUBLE
73872: LD_INT 1
73874: DEC
73875: ST_TO_ADDR
73876: LD_EXP 61
73880: PUSH
73881: FOR_TO
73882: IFFALSE 74951
// begin tmp := mc_lab [ i ] ;
73884: LD_ADDR_VAR 0 6
73888: PUSH
73889: LD_EXP 94
73893: PUSH
73894: LD_VAR 0 2
73898: ARRAY
73899: ST_TO_ADDR
// if not tmp then
73900: LD_VAR 0 6
73904: NOT
73905: IFFALSE 73909
// continue ;
73907: GO 73881
// idle_lab := 0 ;
73909: LD_ADDR_VAR 0 11
73913: PUSH
73914: LD_INT 0
73916: ST_TO_ADDR
// for j in tmp do
73917: LD_ADDR_VAR 0 3
73921: PUSH
73922: LD_VAR 0 6
73926: PUSH
73927: FOR_IN
73928: IFFALSE 74947
// begin researching := false ;
73930: LD_ADDR_VAR 0 10
73934: PUSH
73935: LD_INT 0
73937: ST_TO_ADDR
// side := GetSide ( j ) ;
73938: LD_ADDR_VAR 0 4
73942: PUSH
73943: LD_VAR 0 3
73947: PPUSH
73948: CALL_OW 255
73952: ST_TO_ADDR
// if not mc_tech [ side ] then
73953: LD_EXP 88
73957: PUSH
73958: LD_VAR 0 4
73962: ARRAY
73963: NOT
73964: IFFALSE 73968
// continue ;
73966: GO 73927
// if BuildingStatus ( j ) = bs_idle then
73968: LD_VAR 0 3
73972: PPUSH
73973: CALL_OW 461
73977: PUSH
73978: LD_INT 2
73980: EQUAL
73981: IFFALSE 74169
// begin if idle_lab and UnitsInside ( j ) < 6 then
73983: LD_VAR 0 11
73987: PUSH
73988: LD_VAR 0 3
73992: PPUSH
73993: CALL_OW 313
73997: PUSH
73998: LD_INT 6
74000: LESS
74001: AND
74002: IFFALSE 74073
// begin tmp2 := UnitsInside ( idle_lab ) ;
74004: LD_ADDR_VAR 0 9
74008: PUSH
74009: LD_VAR 0 11
74013: PPUSH
74014: CALL_OW 313
74018: ST_TO_ADDR
// if tmp2 then
74019: LD_VAR 0 9
74023: IFFALSE 74065
// for x in tmp2 do
74025: LD_ADDR_VAR 0 7
74029: PUSH
74030: LD_VAR 0 9
74034: PUSH
74035: FOR_IN
74036: IFFALSE 74063
// begin ComExitBuilding ( x ) ;
74038: LD_VAR 0 7
74042: PPUSH
74043: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74047: LD_VAR 0 7
74051: PPUSH
74052: LD_VAR 0 3
74056: PPUSH
74057: CALL_OW 180
// end ;
74061: GO 74035
74063: POP
74064: POP
// idle_lab := 0 ;
74065: LD_ADDR_VAR 0 11
74069: PUSH
74070: LD_INT 0
74072: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
74073: LD_ADDR_VAR 0 5
74077: PUSH
74078: LD_EXP 88
74082: PUSH
74083: LD_VAR 0 4
74087: ARRAY
74088: PUSH
74089: FOR_IN
74090: IFFALSE 74150
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
74092: LD_VAR 0 3
74096: PPUSH
74097: LD_VAR 0 5
74101: PPUSH
74102: CALL_OW 430
74106: PUSH
74107: LD_VAR 0 4
74111: PPUSH
74112: LD_VAR 0 5
74116: PPUSH
74117: CALL 16357 0 2
74121: AND
74122: IFFALSE 74148
// begin researching := true ;
74124: LD_ADDR_VAR 0 10
74128: PUSH
74129: LD_INT 1
74131: ST_TO_ADDR
// ComResearch ( j , t ) ;
74132: LD_VAR 0 3
74136: PPUSH
74137: LD_VAR 0 5
74141: PPUSH
74142: CALL_OW 124
// break ;
74146: GO 74150
// end ;
74148: GO 74089
74150: POP
74151: POP
// if not researching then
74152: LD_VAR 0 10
74156: NOT
74157: IFFALSE 74169
// idle_lab := j ;
74159: LD_ADDR_VAR 0 11
74163: PUSH
74164: LD_VAR 0 3
74168: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74169: LD_VAR 0 3
74173: PPUSH
74174: CALL_OW 461
74178: PUSH
74179: LD_INT 10
74181: EQUAL
74182: IFFALSE 74770
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74184: LD_EXP 90
74188: PUSH
74189: LD_VAR 0 2
74193: ARRAY
74194: NOT
74195: PUSH
74196: LD_EXP 91
74200: PUSH
74201: LD_VAR 0 2
74205: ARRAY
74206: NOT
74207: AND
74208: PUSH
74209: LD_EXP 88
74213: PUSH
74214: LD_VAR 0 4
74218: ARRAY
74219: PUSH
74220: LD_INT 1
74222: GREATER
74223: AND
74224: IFFALSE 74355
// begin ComCancel ( j ) ;
74226: LD_VAR 0 3
74230: PPUSH
74231: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74235: LD_ADDR_EXP 88
74239: PUSH
74240: LD_EXP 88
74244: PPUSH
74245: LD_VAR 0 4
74249: PPUSH
74250: LD_EXP 88
74254: PUSH
74255: LD_VAR 0 4
74259: ARRAY
74260: PPUSH
74261: LD_EXP 88
74265: PUSH
74266: LD_VAR 0 4
74270: ARRAY
74271: PUSH
74272: LD_INT 1
74274: MINUS
74275: PPUSH
74276: LD_EXP 88
74280: PUSH
74281: LD_VAR 0 4
74285: ARRAY
74286: PPUSH
74287: LD_INT 0
74289: PPUSH
74290: CALL 19881 0 4
74294: PPUSH
74295: CALL_OW 1
74299: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74300: LD_ADDR_EXP 88
74304: PUSH
74305: LD_EXP 88
74309: PPUSH
74310: LD_VAR 0 4
74314: PPUSH
74315: LD_EXP 88
74319: PUSH
74320: LD_VAR 0 4
74324: ARRAY
74325: PPUSH
74326: LD_EXP 88
74330: PUSH
74331: LD_VAR 0 4
74335: ARRAY
74336: PPUSH
74337: LD_INT 1
74339: PPUSH
74340: LD_INT 0
74342: PPUSH
74343: CALL 19881 0 4
74347: PPUSH
74348: CALL_OW 1
74352: ST_TO_ADDR
// continue ;
74353: GO 73927
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74355: LD_EXP 90
74359: PUSH
74360: LD_VAR 0 2
74364: ARRAY
74365: PUSH
74366: LD_EXP 91
74370: PUSH
74371: LD_VAR 0 2
74375: ARRAY
74376: NOT
74377: AND
74378: IFFALSE 74505
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74380: LD_ADDR_EXP 91
74384: PUSH
74385: LD_EXP 91
74389: PPUSH
74390: LD_VAR 0 2
74394: PUSH
74395: LD_EXP 91
74399: PUSH
74400: LD_VAR 0 2
74404: ARRAY
74405: PUSH
74406: LD_INT 1
74408: PLUS
74409: PUSH
74410: EMPTY
74411: LIST
74412: LIST
74413: PPUSH
74414: LD_EXP 90
74418: PUSH
74419: LD_VAR 0 2
74423: ARRAY
74424: PUSH
74425: LD_INT 1
74427: ARRAY
74428: PPUSH
74429: CALL 20463 0 3
74433: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74434: LD_EXP 90
74438: PUSH
74439: LD_VAR 0 2
74443: ARRAY
74444: PUSH
74445: LD_INT 1
74447: ARRAY
74448: PPUSH
74449: LD_INT 112
74451: PPUSH
74452: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74456: LD_ADDR_VAR 0 9
74460: PUSH
74461: LD_EXP 90
74465: PUSH
74466: LD_VAR 0 2
74470: ARRAY
74471: PPUSH
74472: LD_INT 1
74474: PPUSH
74475: CALL_OW 3
74479: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74480: LD_ADDR_EXP 90
74484: PUSH
74485: LD_EXP 90
74489: PPUSH
74490: LD_VAR 0 2
74494: PPUSH
74495: LD_VAR 0 9
74499: PPUSH
74500: CALL_OW 1
74504: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74505: LD_EXP 90
74509: PUSH
74510: LD_VAR 0 2
74514: ARRAY
74515: PUSH
74516: LD_EXP 91
74520: PUSH
74521: LD_VAR 0 2
74525: ARRAY
74526: AND
74527: PUSH
74528: LD_EXP 91
74532: PUSH
74533: LD_VAR 0 2
74537: ARRAY
74538: PUSH
74539: LD_INT 1
74541: ARRAY
74542: PPUSH
74543: CALL_OW 310
74547: NOT
74548: AND
74549: PUSH
74550: LD_VAR 0 3
74554: PPUSH
74555: CALL_OW 313
74559: PUSH
74560: LD_INT 6
74562: EQUAL
74563: AND
74564: IFFALSE 74620
// begin tmp2 := UnitsInside ( j ) ;
74566: LD_ADDR_VAR 0 9
74570: PUSH
74571: LD_VAR 0 3
74575: PPUSH
74576: CALL_OW 313
74580: ST_TO_ADDR
// if tmp2 = 6 then
74581: LD_VAR 0 9
74585: PUSH
74586: LD_INT 6
74588: EQUAL
74589: IFFALSE 74620
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74591: LD_VAR 0 9
74595: PUSH
74596: LD_INT 1
74598: ARRAY
74599: PPUSH
74600: LD_INT 112
74602: PPUSH
74603: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74607: LD_VAR 0 9
74611: PUSH
74612: LD_INT 1
74614: ARRAY
74615: PPUSH
74616: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74620: LD_EXP 91
74624: PUSH
74625: LD_VAR 0 2
74629: ARRAY
74630: PUSH
74631: LD_EXP 91
74635: PUSH
74636: LD_VAR 0 2
74640: ARRAY
74641: PUSH
74642: LD_INT 1
74644: ARRAY
74645: PPUSH
74646: CALL_OW 314
74650: NOT
74651: AND
74652: PUSH
74653: LD_EXP 91
74657: PUSH
74658: LD_VAR 0 2
74662: ARRAY
74663: PUSH
74664: LD_INT 1
74666: ARRAY
74667: PPUSH
74668: CALL_OW 310
74672: NOT
74673: AND
74674: IFFALSE 74700
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74676: LD_EXP 91
74680: PUSH
74681: LD_VAR 0 2
74685: ARRAY
74686: PUSH
74687: LD_INT 1
74689: ARRAY
74690: PPUSH
74691: LD_VAR 0 3
74695: PPUSH
74696: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74700: LD_EXP 91
74704: PUSH
74705: LD_VAR 0 2
74709: ARRAY
74710: PUSH
74711: LD_INT 1
74713: ARRAY
74714: PPUSH
74715: CALL_OW 310
74719: PUSH
74720: LD_EXP 91
74724: PUSH
74725: LD_VAR 0 2
74729: ARRAY
74730: PUSH
74731: LD_INT 1
74733: ARRAY
74734: PPUSH
74735: CALL_OW 310
74739: PPUSH
74740: CALL_OW 461
74744: PUSH
74745: LD_INT 3
74747: NONEQUAL
74748: AND
74749: IFFALSE 74770
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74751: LD_EXP 91
74755: PUSH
74756: LD_VAR 0 2
74760: ARRAY
74761: PUSH
74762: LD_INT 1
74764: ARRAY
74765: PPUSH
74766: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74770: LD_VAR 0 3
74774: PPUSH
74775: CALL_OW 461
74779: PUSH
74780: LD_INT 6
74782: EQUAL
74783: PUSH
74784: LD_VAR 0 6
74788: PUSH
74789: LD_INT 1
74791: GREATER
74792: AND
74793: IFFALSE 74945
// begin sci := [ ] ;
74795: LD_ADDR_VAR 0 8
74799: PUSH
74800: EMPTY
74801: ST_TO_ADDR
// for x in ( tmp diff j ) do
74802: LD_ADDR_VAR 0 7
74806: PUSH
74807: LD_VAR 0 6
74811: PUSH
74812: LD_VAR 0 3
74816: DIFF
74817: PUSH
74818: FOR_IN
74819: IFFALSE 74871
// begin if sci = 6 then
74821: LD_VAR 0 8
74825: PUSH
74826: LD_INT 6
74828: EQUAL
74829: IFFALSE 74833
// break ;
74831: GO 74871
// if BuildingStatus ( x ) = bs_idle then
74833: LD_VAR 0 7
74837: PPUSH
74838: CALL_OW 461
74842: PUSH
74843: LD_INT 2
74845: EQUAL
74846: IFFALSE 74869
// sci := sci ^ UnitsInside ( x ) ;
74848: LD_ADDR_VAR 0 8
74852: PUSH
74853: LD_VAR 0 8
74857: PUSH
74858: LD_VAR 0 7
74862: PPUSH
74863: CALL_OW 313
74867: ADD
74868: ST_TO_ADDR
// end ;
74869: GO 74818
74871: POP
74872: POP
// if not sci then
74873: LD_VAR 0 8
74877: NOT
74878: IFFALSE 74882
// continue ;
74880: GO 73927
// for x in sci do
74882: LD_ADDR_VAR 0 7
74886: PUSH
74887: LD_VAR 0 8
74891: PUSH
74892: FOR_IN
74893: IFFALSE 74943
// if IsInUnit ( x ) and not HasTask ( x ) then
74895: LD_VAR 0 7
74899: PPUSH
74900: CALL_OW 310
74904: PUSH
74905: LD_VAR 0 7
74909: PPUSH
74910: CALL_OW 314
74914: NOT
74915: AND
74916: IFFALSE 74941
// begin ComExitBuilding ( x ) ;
74918: LD_VAR 0 7
74922: PPUSH
74923: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74927: LD_VAR 0 7
74931: PPUSH
74932: LD_VAR 0 3
74936: PPUSH
74937: CALL_OW 180
// end ;
74941: GO 74892
74943: POP
74944: POP
// end ; end ;
74945: GO 73927
74947: POP
74948: POP
// end ;
74949: GO 73881
74951: POP
74952: POP
// end ;
74953: LD_VAR 0 1
74957: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74958: LD_INT 0
74960: PPUSH
74961: PPUSH
// if not mc_bases then
74962: LD_EXP 61
74966: NOT
74967: IFFALSE 74971
// exit ;
74969: GO 75052
// for i = 1 to mc_bases do
74971: LD_ADDR_VAR 0 2
74975: PUSH
74976: DOUBLE
74977: LD_INT 1
74979: DEC
74980: ST_TO_ADDR
74981: LD_EXP 61
74985: PUSH
74986: FOR_TO
74987: IFFALSE 75050
// if mc_mines [ i ] and mc_miners [ i ] then
74989: LD_EXP 74
74993: PUSH
74994: LD_VAR 0 2
74998: ARRAY
74999: PUSH
75000: LD_EXP 75
75004: PUSH
75005: LD_VAR 0 2
75009: ARRAY
75010: AND
75011: IFFALSE 75048
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
75013: LD_EXP 75
75017: PUSH
75018: LD_VAR 0 2
75022: ARRAY
75023: PUSH
75024: LD_INT 1
75026: ARRAY
75027: PPUSH
75028: CALL_OW 255
75032: PPUSH
75033: LD_EXP 74
75037: PUSH
75038: LD_VAR 0 2
75042: ARRAY
75043: PPUSH
75044: CALL 17440 0 2
75048: GO 74986
75050: POP
75051: POP
// end ;
75052: LD_VAR 0 1
75056: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
75057: LD_INT 0
75059: PPUSH
75060: PPUSH
75061: PPUSH
75062: PPUSH
75063: PPUSH
75064: PPUSH
75065: PPUSH
75066: PPUSH
// if not mc_bases or not mc_parking then
75067: LD_EXP 61
75071: NOT
75072: PUSH
75073: LD_EXP 85
75077: NOT
75078: OR
75079: IFFALSE 75083
// exit ;
75081: GO 75821
// for i = 1 to mc_bases do
75083: LD_ADDR_VAR 0 2
75087: PUSH
75088: DOUBLE
75089: LD_INT 1
75091: DEC
75092: ST_TO_ADDR
75093: LD_EXP 61
75097: PUSH
75098: FOR_TO
75099: IFFALSE 75819
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
75101: LD_EXP 61
75105: PUSH
75106: LD_VAR 0 2
75110: ARRAY
75111: NOT
75112: PUSH
75113: LD_EXP 85
75117: PUSH
75118: LD_VAR 0 2
75122: ARRAY
75123: NOT
75124: OR
75125: IFFALSE 75129
// continue ;
75127: GO 75098
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75129: LD_ADDR_VAR 0 5
75133: PUSH
75134: LD_EXP 61
75138: PUSH
75139: LD_VAR 0 2
75143: ARRAY
75144: PUSH
75145: LD_INT 1
75147: ARRAY
75148: PPUSH
75149: CALL_OW 255
75153: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75154: LD_ADDR_VAR 0 6
75158: PUSH
75159: LD_EXP 61
75163: PUSH
75164: LD_VAR 0 2
75168: ARRAY
75169: PPUSH
75170: LD_INT 30
75172: PUSH
75173: LD_INT 3
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PPUSH
75180: CALL_OW 72
75184: ST_TO_ADDR
// if not fac then
75185: LD_VAR 0 6
75189: NOT
75190: IFFALSE 75241
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75192: LD_ADDR_VAR 0 6
75196: PUSH
75197: LD_EXP 61
75201: PUSH
75202: LD_VAR 0 2
75206: ARRAY
75207: PPUSH
75208: LD_INT 2
75210: PUSH
75211: LD_INT 30
75213: PUSH
75214: LD_INT 0
75216: PUSH
75217: EMPTY
75218: LIST
75219: LIST
75220: PUSH
75221: LD_INT 30
75223: PUSH
75224: LD_INT 1
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: EMPTY
75232: LIST
75233: LIST
75234: LIST
75235: PPUSH
75236: CALL_OW 72
75240: ST_TO_ADDR
// if not fac then
75241: LD_VAR 0 6
75245: NOT
75246: IFFALSE 75250
// continue ;
75248: GO 75098
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75250: LD_ADDR_VAR 0 7
75254: PUSH
75255: LD_EXP 85
75259: PUSH
75260: LD_VAR 0 2
75264: ARRAY
75265: PPUSH
75266: LD_INT 22
75268: PUSH
75269: LD_VAR 0 5
75273: PUSH
75274: EMPTY
75275: LIST
75276: LIST
75277: PUSH
75278: LD_INT 21
75280: PUSH
75281: LD_INT 2
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 3
75290: PUSH
75291: LD_INT 60
75293: PUSH
75294: EMPTY
75295: LIST
75296: PUSH
75297: EMPTY
75298: LIST
75299: LIST
75300: PUSH
75301: LD_INT 3
75303: PUSH
75304: LD_INT 24
75306: PUSH
75307: LD_INT 1000
75309: PUSH
75310: EMPTY
75311: LIST
75312: LIST
75313: PUSH
75314: EMPTY
75315: LIST
75316: LIST
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: LIST
75322: LIST
75323: PPUSH
75324: CALL_OW 70
75328: ST_TO_ADDR
// for j in fac do
75329: LD_ADDR_VAR 0 3
75333: PUSH
75334: LD_VAR 0 6
75338: PUSH
75339: FOR_IN
75340: IFFALSE 75435
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75342: LD_ADDR_VAR 0 7
75346: PUSH
75347: LD_VAR 0 7
75351: PUSH
75352: LD_INT 22
75354: PUSH
75355: LD_VAR 0 5
75359: PUSH
75360: EMPTY
75361: LIST
75362: LIST
75363: PUSH
75364: LD_INT 91
75366: PUSH
75367: LD_VAR 0 3
75371: PUSH
75372: LD_INT 15
75374: PUSH
75375: EMPTY
75376: LIST
75377: LIST
75378: LIST
75379: PUSH
75380: LD_INT 21
75382: PUSH
75383: LD_INT 2
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 3
75392: PUSH
75393: LD_INT 60
75395: PUSH
75396: EMPTY
75397: LIST
75398: PUSH
75399: EMPTY
75400: LIST
75401: LIST
75402: PUSH
75403: LD_INT 3
75405: PUSH
75406: LD_INT 24
75408: PUSH
75409: LD_INT 1000
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: PUSH
75416: EMPTY
75417: LIST
75418: LIST
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: LIST
75424: LIST
75425: LIST
75426: PPUSH
75427: CALL_OW 69
75431: UNION
75432: ST_TO_ADDR
75433: GO 75339
75435: POP
75436: POP
// if not vehs then
75437: LD_VAR 0 7
75441: NOT
75442: IFFALSE 75468
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75444: LD_ADDR_EXP 73
75448: PUSH
75449: LD_EXP 73
75453: PPUSH
75454: LD_VAR 0 2
75458: PPUSH
75459: EMPTY
75460: PPUSH
75461: CALL_OW 1
75465: ST_TO_ADDR
// continue ;
75466: GO 75098
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75468: LD_ADDR_VAR 0 8
75472: PUSH
75473: LD_EXP 61
75477: PUSH
75478: LD_VAR 0 2
75482: ARRAY
75483: PPUSH
75484: LD_INT 30
75486: PUSH
75487: LD_INT 3
75489: PUSH
75490: EMPTY
75491: LIST
75492: LIST
75493: PPUSH
75494: CALL_OW 72
75498: ST_TO_ADDR
// if tmp then
75499: LD_VAR 0 8
75503: IFFALSE 75606
// begin for j in tmp do
75505: LD_ADDR_VAR 0 3
75509: PUSH
75510: LD_VAR 0 8
75514: PUSH
75515: FOR_IN
75516: IFFALSE 75604
// for k in UnitsInside ( j ) do
75518: LD_ADDR_VAR 0 4
75522: PUSH
75523: LD_VAR 0 3
75527: PPUSH
75528: CALL_OW 313
75532: PUSH
75533: FOR_IN
75534: IFFALSE 75600
// if k then
75536: LD_VAR 0 4
75540: IFFALSE 75598
// if not k in mc_repair_vehicle [ i ] then
75542: LD_VAR 0 4
75546: PUSH
75547: LD_EXP 73
75551: PUSH
75552: LD_VAR 0 2
75556: ARRAY
75557: IN
75558: NOT
75559: IFFALSE 75598
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75561: LD_ADDR_EXP 73
75565: PUSH
75566: LD_EXP 73
75570: PPUSH
75571: LD_VAR 0 2
75575: PPUSH
75576: LD_EXP 73
75580: PUSH
75581: LD_VAR 0 2
75585: ARRAY
75586: PUSH
75587: LD_VAR 0 4
75591: UNION
75592: PPUSH
75593: CALL_OW 1
75597: ST_TO_ADDR
75598: GO 75533
75600: POP
75601: POP
75602: GO 75515
75604: POP
75605: POP
// end ; if not mc_repair_vehicle [ i ] then
75606: LD_EXP 73
75610: PUSH
75611: LD_VAR 0 2
75615: ARRAY
75616: NOT
75617: IFFALSE 75621
// continue ;
75619: GO 75098
// for j in mc_repair_vehicle [ i ] do
75621: LD_ADDR_VAR 0 3
75625: PUSH
75626: LD_EXP 73
75630: PUSH
75631: LD_VAR 0 2
75635: ARRAY
75636: PUSH
75637: FOR_IN
75638: IFFALSE 75815
// begin if GetClass ( j ) <> 3 then
75640: LD_VAR 0 3
75644: PPUSH
75645: CALL_OW 257
75649: PUSH
75650: LD_INT 3
75652: NONEQUAL
75653: IFFALSE 75694
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75655: LD_ADDR_EXP 73
75659: PUSH
75660: LD_EXP 73
75664: PPUSH
75665: LD_VAR 0 2
75669: PPUSH
75670: LD_EXP 73
75674: PUSH
75675: LD_VAR 0 2
75679: ARRAY
75680: PUSH
75681: LD_VAR 0 3
75685: DIFF
75686: PPUSH
75687: CALL_OW 1
75691: ST_TO_ADDR
// continue ;
75692: GO 75637
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75694: LD_VAR 0 3
75698: PPUSH
75699: CALL_OW 311
75703: NOT
75704: PUSH
75705: LD_VAR 0 3
75709: PUSH
75710: LD_EXP 64
75714: PUSH
75715: LD_VAR 0 2
75719: ARRAY
75720: PUSH
75721: LD_INT 1
75723: ARRAY
75724: IN
75725: NOT
75726: AND
75727: PUSH
75728: LD_VAR 0 3
75732: PUSH
75733: LD_EXP 64
75737: PUSH
75738: LD_VAR 0 2
75742: ARRAY
75743: PUSH
75744: LD_INT 2
75746: ARRAY
75747: IN
75748: NOT
75749: AND
75750: IFFALSE 75813
// begin if IsInUnit ( j ) then
75752: LD_VAR 0 3
75756: PPUSH
75757: CALL_OW 310
75761: IFFALSE 75774
// ComExitBuilding ( j ) else
75763: LD_VAR 0 3
75767: PPUSH
75768: CALL_OW 122
75772: GO 75813
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75774: LD_VAR 0 3
75778: PPUSH
75779: LD_VAR 0 7
75783: PUSH
75784: LD_INT 1
75786: ARRAY
75787: PPUSH
75788: CALL 54887 0 2
75792: NOT
75793: IFFALSE 75813
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75795: LD_VAR 0 3
75799: PPUSH
75800: LD_VAR 0 7
75804: PUSH
75805: LD_INT 1
75807: ARRAY
75808: PPUSH
75809: CALL_OW 129
// end ; end ;
75813: GO 75637
75815: POP
75816: POP
// end ;
75817: GO 75098
75819: POP
75820: POP
// end ;
75821: LD_VAR 0 1
75825: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75826: LD_INT 0
75828: PPUSH
75829: PPUSH
75830: PPUSH
75831: PPUSH
75832: PPUSH
75833: PPUSH
75834: PPUSH
75835: PPUSH
75836: PPUSH
75837: PPUSH
75838: PPUSH
// if not mc_bases then
75839: LD_EXP 61
75843: NOT
75844: IFFALSE 75848
// exit ;
75846: GO 76650
// for i = 1 to mc_bases do
75848: LD_ADDR_VAR 0 2
75852: PUSH
75853: DOUBLE
75854: LD_INT 1
75856: DEC
75857: ST_TO_ADDR
75858: LD_EXP 61
75862: PUSH
75863: FOR_TO
75864: IFFALSE 76648
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75866: LD_EXP 89
75870: PUSH
75871: LD_VAR 0 2
75875: ARRAY
75876: NOT
75877: PUSH
75878: LD_EXP 64
75882: PUSH
75883: LD_VAR 0 2
75887: ARRAY
75888: PUSH
75889: LD_INT 1
75891: ARRAY
75892: OR
75893: PUSH
75894: LD_EXP 64
75898: PUSH
75899: LD_VAR 0 2
75903: ARRAY
75904: PUSH
75905: LD_INT 2
75907: ARRAY
75908: OR
75909: PUSH
75910: LD_EXP 87
75914: PUSH
75915: LD_VAR 0 2
75919: ARRAY
75920: PPUSH
75921: LD_INT 1
75923: PPUSH
75924: CALL_OW 325
75928: NOT
75929: OR
75930: PUSH
75931: LD_EXP 84
75935: PUSH
75936: LD_VAR 0 2
75940: ARRAY
75941: OR
75942: IFFALSE 75946
// continue ;
75944: GO 75863
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75946: LD_ADDR_VAR 0 8
75950: PUSH
75951: LD_EXP 61
75955: PUSH
75956: LD_VAR 0 2
75960: ARRAY
75961: PPUSH
75962: LD_INT 25
75964: PUSH
75965: LD_INT 4
75967: PUSH
75968: EMPTY
75969: LIST
75970: LIST
75971: PUSH
75972: LD_INT 50
75974: PUSH
75975: EMPTY
75976: LIST
75977: PUSH
75978: LD_INT 3
75980: PUSH
75981: LD_INT 60
75983: PUSH
75984: EMPTY
75985: LIST
75986: PUSH
75987: EMPTY
75988: LIST
75989: LIST
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: LIST
75995: PPUSH
75996: CALL_OW 72
76000: PUSH
76001: LD_EXP 65
76005: PUSH
76006: LD_VAR 0 2
76010: ARRAY
76011: DIFF
76012: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76013: LD_ADDR_VAR 0 9
76017: PUSH
76018: LD_EXP 61
76022: PUSH
76023: LD_VAR 0 2
76027: ARRAY
76028: PPUSH
76029: LD_INT 2
76031: PUSH
76032: LD_INT 30
76034: PUSH
76035: LD_INT 0
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 30
76044: PUSH
76045: LD_INT 1
76047: PUSH
76048: EMPTY
76049: LIST
76050: LIST
76051: PUSH
76052: EMPTY
76053: LIST
76054: LIST
76055: LIST
76056: PPUSH
76057: CALL_OW 72
76061: ST_TO_ADDR
// if not tmp or not dep then
76062: LD_VAR 0 8
76066: NOT
76067: PUSH
76068: LD_VAR 0 9
76072: NOT
76073: OR
76074: IFFALSE 76078
// continue ;
76076: GO 75863
// side := GetSide ( tmp [ 1 ] ) ;
76078: LD_ADDR_VAR 0 11
76082: PUSH
76083: LD_VAR 0 8
76087: PUSH
76088: LD_INT 1
76090: ARRAY
76091: PPUSH
76092: CALL_OW 255
76096: ST_TO_ADDR
// dep := dep [ 1 ] ;
76097: LD_ADDR_VAR 0 9
76101: PUSH
76102: LD_VAR 0 9
76106: PUSH
76107: LD_INT 1
76109: ARRAY
76110: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
76111: LD_ADDR_VAR 0 7
76115: PUSH
76116: LD_EXP 89
76120: PUSH
76121: LD_VAR 0 2
76125: ARRAY
76126: PPUSH
76127: LD_INT 22
76129: PUSH
76130: LD_INT 0
76132: PUSH
76133: EMPTY
76134: LIST
76135: LIST
76136: PUSH
76137: LD_INT 25
76139: PUSH
76140: LD_INT 12
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: EMPTY
76148: LIST
76149: LIST
76150: PPUSH
76151: CALL_OW 70
76155: PUSH
76156: LD_INT 22
76158: PUSH
76159: LD_INT 0
76161: PUSH
76162: EMPTY
76163: LIST
76164: LIST
76165: PUSH
76166: LD_INT 25
76168: PUSH
76169: LD_INT 12
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: PUSH
76176: LD_INT 91
76178: PUSH
76179: LD_VAR 0 9
76183: PUSH
76184: LD_INT 20
76186: PUSH
76187: EMPTY
76188: LIST
76189: LIST
76190: LIST
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: LIST
76196: PPUSH
76197: CALL_OW 69
76201: UNION
76202: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76203: LD_ADDR_VAR 0 10
76207: PUSH
76208: LD_EXP 89
76212: PUSH
76213: LD_VAR 0 2
76217: ARRAY
76218: PPUSH
76219: LD_INT 81
76221: PUSH
76222: LD_VAR 0 11
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PPUSH
76231: CALL_OW 70
76235: ST_TO_ADDR
// if not apes or danger_at_area then
76236: LD_VAR 0 7
76240: NOT
76241: PUSH
76242: LD_VAR 0 10
76246: OR
76247: IFFALSE 76297
// begin if mc_taming [ i ] then
76249: LD_EXP 92
76253: PUSH
76254: LD_VAR 0 2
76258: ARRAY
76259: IFFALSE 76295
// begin MC_Reset ( i , 121 ) ;
76261: LD_VAR 0 2
76265: PPUSH
76266: LD_INT 121
76268: PPUSH
76269: CALL 61213 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76273: LD_ADDR_EXP 92
76277: PUSH
76278: LD_EXP 92
76282: PPUSH
76283: LD_VAR 0 2
76287: PPUSH
76288: EMPTY
76289: PPUSH
76290: CALL_OW 1
76294: ST_TO_ADDR
// end ; continue ;
76295: GO 75863
// end ; for j in tmp do
76297: LD_ADDR_VAR 0 3
76301: PUSH
76302: LD_VAR 0 8
76306: PUSH
76307: FOR_IN
76308: IFFALSE 76644
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76310: LD_VAR 0 3
76314: PUSH
76315: LD_EXP 92
76319: PUSH
76320: LD_VAR 0 2
76324: ARRAY
76325: IN
76326: NOT
76327: PUSH
76328: LD_EXP 92
76332: PUSH
76333: LD_VAR 0 2
76337: ARRAY
76338: PUSH
76339: LD_INT 3
76341: LESS
76342: AND
76343: IFFALSE 76401
// begin SetTag ( j , 121 ) ;
76345: LD_VAR 0 3
76349: PPUSH
76350: LD_INT 121
76352: PPUSH
76353: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76357: LD_ADDR_EXP 92
76361: PUSH
76362: LD_EXP 92
76366: PPUSH
76367: LD_VAR 0 2
76371: PUSH
76372: LD_EXP 92
76376: PUSH
76377: LD_VAR 0 2
76381: ARRAY
76382: PUSH
76383: LD_INT 1
76385: PLUS
76386: PUSH
76387: EMPTY
76388: LIST
76389: LIST
76390: PPUSH
76391: LD_VAR 0 3
76395: PPUSH
76396: CALL 20463 0 3
76400: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76401: LD_VAR 0 3
76405: PUSH
76406: LD_EXP 92
76410: PUSH
76411: LD_VAR 0 2
76415: ARRAY
76416: IN
76417: IFFALSE 76642
// begin if GetClass ( j ) <> 4 then
76419: LD_VAR 0 3
76423: PPUSH
76424: CALL_OW 257
76428: PUSH
76429: LD_INT 4
76431: NONEQUAL
76432: IFFALSE 76485
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76434: LD_ADDR_EXP 92
76438: PUSH
76439: LD_EXP 92
76443: PPUSH
76444: LD_VAR 0 2
76448: PPUSH
76449: LD_EXP 92
76453: PUSH
76454: LD_VAR 0 2
76458: ARRAY
76459: PUSH
76460: LD_VAR 0 3
76464: DIFF
76465: PPUSH
76466: CALL_OW 1
76470: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76471: LD_VAR 0 3
76475: PPUSH
76476: LD_INT 0
76478: PPUSH
76479: CALL_OW 109
// continue ;
76483: GO 76307
// end ; if IsInUnit ( j ) then
76485: LD_VAR 0 3
76489: PPUSH
76490: CALL_OW 310
76494: IFFALSE 76505
// ComExitBuilding ( j ) ;
76496: LD_VAR 0 3
76500: PPUSH
76501: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76505: LD_ADDR_VAR 0 6
76509: PUSH
76510: LD_VAR 0 7
76514: PPUSH
76515: LD_VAR 0 3
76519: PPUSH
76520: CALL_OW 74
76524: ST_TO_ADDR
// if not ape then
76525: LD_VAR 0 6
76529: NOT
76530: IFFALSE 76534
// break ;
76532: GO 76644
// x := GetX ( ape ) ;
76534: LD_ADDR_VAR 0 4
76538: PUSH
76539: LD_VAR 0 6
76543: PPUSH
76544: CALL_OW 250
76548: ST_TO_ADDR
// y := GetY ( ape ) ;
76549: LD_ADDR_VAR 0 5
76553: PUSH
76554: LD_VAR 0 6
76558: PPUSH
76559: CALL_OW 251
76563: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76564: LD_VAR 0 4
76568: PPUSH
76569: LD_VAR 0 5
76573: PPUSH
76574: CALL_OW 488
76578: NOT
76579: PUSH
76580: LD_VAR 0 11
76584: PPUSH
76585: LD_VAR 0 4
76589: PPUSH
76590: LD_VAR 0 5
76594: PPUSH
76595: LD_INT 20
76597: PPUSH
76598: CALL 21359 0 4
76602: PUSH
76603: LD_INT 4
76605: ARRAY
76606: OR
76607: IFFALSE 76611
// break ;
76609: GO 76644
// if not HasTask ( j ) then
76611: LD_VAR 0 3
76615: PPUSH
76616: CALL_OW 314
76620: NOT
76621: IFFALSE 76642
// ComTameXY ( j , x , y ) ;
76623: LD_VAR 0 3
76627: PPUSH
76628: LD_VAR 0 4
76632: PPUSH
76633: LD_VAR 0 5
76637: PPUSH
76638: CALL_OW 131
// end ; end ;
76642: GO 76307
76644: POP
76645: POP
// end ;
76646: GO 75863
76648: POP
76649: POP
// end ;
76650: LD_VAR 0 1
76654: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76655: LD_INT 0
76657: PPUSH
76658: PPUSH
76659: PPUSH
76660: PPUSH
76661: PPUSH
76662: PPUSH
76663: PPUSH
76664: PPUSH
// if not mc_bases then
76665: LD_EXP 61
76669: NOT
76670: IFFALSE 76674
// exit ;
76672: GO 77300
// for i = 1 to mc_bases do
76674: LD_ADDR_VAR 0 2
76678: PUSH
76679: DOUBLE
76680: LD_INT 1
76682: DEC
76683: ST_TO_ADDR
76684: LD_EXP 61
76688: PUSH
76689: FOR_TO
76690: IFFALSE 77298
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76692: LD_EXP 90
76696: PUSH
76697: LD_VAR 0 2
76701: ARRAY
76702: NOT
76703: PUSH
76704: LD_EXP 90
76708: PUSH
76709: LD_VAR 0 2
76713: ARRAY
76714: PPUSH
76715: LD_INT 25
76717: PUSH
76718: LD_INT 12
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PPUSH
76725: CALL_OW 72
76729: NOT
76730: OR
76731: IFFALSE 76735
// continue ;
76733: GO 76689
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76735: LD_ADDR_VAR 0 5
76739: PUSH
76740: LD_EXP 90
76744: PUSH
76745: LD_VAR 0 2
76749: ARRAY
76750: PUSH
76751: LD_INT 1
76753: ARRAY
76754: PPUSH
76755: CALL_OW 255
76759: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76760: LD_VAR 0 5
76764: PPUSH
76765: LD_INT 2
76767: PPUSH
76768: CALL_OW 325
76772: IFFALSE 77025
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76774: LD_ADDR_VAR 0 4
76778: PUSH
76779: LD_EXP 90
76783: PUSH
76784: LD_VAR 0 2
76788: ARRAY
76789: PPUSH
76790: LD_INT 25
76792: PUSH
76793: LD_INT 16
76795: PUSH
76796: EMPTY
76797: LIST
76798: LIST
76799: PPUSH
76800: CALL_OW 72
76804: ST_TO_ADDR
// if tmp < 6 then
76805: LD_VAR 0 4
76809: PUSH
76810: LD_INT 6
76812: LESS
76813: IFFALSE 77025
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76815: LD_ADDR_VAR 0 6
76819: PUSH
76820: LD_EXP 61
76824: PUSH
76825: LD_VAR 0 2
76829: ARRAY
76830: PPUSH
76831: LD_INT 2
76833: PUSH
76834: LD_INT 30
76836: PUSH
76837: LD_INT 0
76839: PUSH
76840: EMPTY
76841: LIST
76842: LIST
76843: PUSH
76844: LD_INT 30
76846: PUSH
76847: LD_INT 1
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: LIST
76858: PPUSH
76859: CALL_OW 72
76863: ST_TO_ADDR
// if depot then
76864: LD_VAR 0 6
76868: IFFALSE 77025
// begin selected := 0 ;
76870: LD_ADDR_VAR 0 7
76874: PUSH
76875: LD_INT 0
76877: ST_TO_ADDR
// for j in depot do
76878: LD_ADDR_VAR 0 3
76882: PUSH
76883: LD_VAR 0 6
76887: PUSH
76888: FOR_IN
76889: IFFALSE 76920
// begin if UnitsInside ( j ) < 6 then
76891: LD_VAR 0 3
76895: PPUSH
76896: CALL_OW 313
76900: PUSH
76901: LD_INT 6
76903: LESS
76904: IFFALSE 76918
// begin selected := j ;
76906: LD_ADDR_VAR 0 7
76910: PUSH
76911: LD_VAR 0 3
76915: ST_TO_ADDR
// break ;
76916: GO 76920
// end ; end ;
76918: GO 76888
76920: POP
76921: POP
// if selected then
76922: LD_VAR 0 7
76926: IFFALSE 77025
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76928: LD_ADDR_VAR 0 3
76932: PUSH
76933: LD_EXP 90
76937: PUSH
76938: LD_VAR 0 2
76942: ARRAY
76943: PPUSH
76944: LD_INT 25
76946: PUSH
76947: LD_INT 12
76949: PUSH
76950: EMPTY
76951: LIST
76952: LIST
76953: PPUSH
76954: CALL_OW 72
76958: PUSH
76959: FOR_IN
76960: IFFALSE 77023
// if not HasTask ( j ) then
76962: LD_VAR 0 3
76966: PPUSH
76967: CALL_OW 314
76971: NOT
76972: IFFALSE 77021
// begin if not IsInUnit ( j ) then
76974: LD_VAR 0 3
76978: PPUSH
76979: CALL_OW 310
76983: NOT
76984: IFFALSE 77000
// ComEnterUnit ( j , selected ) ;
76986: LD_VAR 0 3
76990: PPUSH
76991: LD_VAR 0 7
76995: PPUSH
76996: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
77000: LD_VAR 0 3
77004: PPUSH
77005: LD_INT 16
77007: PPUSH
77008: CALL_OW 183
// AddComExitBuilding ( j ) ;
77012: LD_VAR 0 3
77016: PPUSH
77017: CALL_OW 182
// end ;
77021: GO 76959
77023: POP
77024: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
77025: LD_VAR 0 5
77029: PPUSH
77030: LD_INT 11
77032: PPUSH
77033: CALL_OW 325
77037: IFFALSE 77296
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
77039: LD_ADDR_VAR 0 4
77043: PUSH
77044: LD_EXP 90
77048: PUSH
77049: LD_VAR 0 2
77053: ARRAY
77054: PPUSH
77055: LD_INT 25
77057: PUSH
77058: LD_INT 16
77060: PUSH
77061: EMPTY
77062: LIST
77063: LIST
77064: PPUSH
77065: CALL_OW 72
77069: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
77070: LD_VAR 0 4
77074: PUSH
77075: LD_INT 6
77077: GREATEREQUAL
77078: PUSH
77079: LD_VAR 0 5
77083: PPUSH
77084: LD_INT 2
77086: PPUSH
77087: CALL_OW 325
77091: NOT
77092: OR
77093: IFFALSE 77296
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
77095: LD_ADDR_VAR 0 8
77099: PUSH
77100: LD_EXP 61
77104: PUSH
77105: LD_VAR 0 2
77109: ARRAY
77110: PPUSH
77111: LD_INT 2
77113: PUSH
77114: LD_INT 30
77116: PUSH
77117: LD_INT 4
77119: PUSH
77120: EMPTY
77121: LIST
77122: LIST
77123: PUSH
77124: LD_INT 30
77126: PUSH
77127: LD_INT 5
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: EMPTY
77135: LIST
77136: LIST
77137: LIST
77138: PPUSH
77139: CALL_OW 72
77143: ST_TO_ADDR
// if barracks then
77144: LD_VAR 0 8
77148: IFFALSE 77296
// begin selected := 0 ;
77150: LD_ADDR_VAR 0 7
77154: PUSH
77155: LD_INT 0
77157: ST_TO_ADDR
// for j in barracks do
77158: LD_ADDR_VAR 0 3
77162: PUSH
77163: LD_VAR 0 8
77167: PUSH
77168: FOR_IN
77169: IFFALSE 77200
// begin if UnitsInside ( j ) < 6 then
77171: LD_VAR 0 3
77175: PPUSH
77176: CALL_OW 313
77180: PUSH
77181: LD_INT 6
77183: LESS
77184: IFFALSE 77198
// begin selected := j ;
77186: LD_ADDR_VAR 0 7
77190: PUSH
77191: LD_VAR 0 3
77195: ST_TO_ADDR
// break ;
77196: GO 77200
// end ; end ;
77198: GO 77168
77200: POP
77201: POP
// if selected then
77202: LD_VAR 0 7
77206: IFFALSE 77296
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77208: LD_ADDR_VAR 0 3
77212: PUSH
77213: LD_EXP 90
77217: PUSH
77218: LD_VAR 0 2
77222: ARRAY
77223: PPUSH
77224: LD_INT 25
77226: PUSH
77227: LD_INT 12
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PPUSH
77234: CALL_OW 72
77238: PUSH
77239: FOR_IN
77240: IFFALSE 77294
// if not IsInUnit ( j ) and not HasTask ( j ) then
77242: LD_VAR 0 3
77246: PPUSH
77247: CALL_OW 310
77251: NOT
77252: PUSH
77253: LD_VAR 0 3
77257: PPUSH
77258: CALL_OW 314
77262: NOT
77263: AND
77264: IFFALSE 77292
// begin ComEnterUnit ( j , selected ) ;
77266: LD_VAR 0 3
77270: PPUSH
77271: LD_VAR 0 7
77275: PPUSH
77276: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77280: LD_VAR 0 3
77284: PPUSH
77285: LD_INT 15
77287: PPUSH
77288: CALL_OW 183
// end ;
77292: GO 77239
77294: POP
77295: POP
// end ; end ; end ; end ; end ;
77296: GO 76689
77298: POP
77299: POP
// end ;
77300: LD_VAR 0 1
77304: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77305: LD_INT 0
77307: PPUSH
77308: PPUSH
77309: PPUSH
77310: PPUSH
// if not mc_bases then
77311: LD_EXP 61
77315: NOT
77316: IFFALSE 77320
// exit ;
77318: GO 77498
// for i = 1 to mc_bases do
77320: LD_ADDR_VAR 0 2
77324: PUSH
77325: DOUBLE
77326: LD_INT 1
77328: DEC
77329: ST_TO_ADDR
77330: LD_EXP 61
77334: PUSH
77335: FOR_TO
77336: IFFALSE 77496
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77338: LD_ADDR_VAR 0 4
77342: PUSH
77343: LD_EXP 61
77347: PUSH
77348: LD_VAR 0 2
77352: ARRAY
77353: PPUSH
77354: LD_INT 25
77356: PUSH
77357: LD_INT 9
77359: PUSH
77360: EMPTY
77361: LIST
77362: LIST
77363: PPUSH
77364: CALL_OW 72
77368: ST_TO_ADDR
// if not tmp then
77369: LD_VAR 0 4
77373: NOT
77374: IFFALSE 77378
// continue ;
77376: GO 77335
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77378: LD_EXP 87
77382: PUSH
77383: LD_VAR 0 2
77387: ARRAY
77388: PPUSH
77389: LD_INT 29
77391: PPUSH
77392: CALL_OW 325
77396: NOT
77397: PUSH
77398: LD_EXP 87
77402: PUSH
77403: LD_VAR 0 2
77407: ARRAY
77408: PPUSH
77409: LD_INT 28
77411: PPUSH
77412: CALL_OW 325
77416: NOT
77417: AND
77418: IFFALSE 77422
// continue ;
77420: GO 77335
// for j in tmp do
77422: LD_ADDR_VAR 0 3
77426: PUSH
77427: LD_VAR 0 4
77431: PUSH
77432: FOR_IN
77433: IFFALSE 77492
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77435: LD_VAR 0 3
77439: PUSH
77440: LD_EXP 64
77444: PUSH
77445: LD_VAR 0 2
77449: ARRAY
77450: PUSH
77451: LD_INT 1
77453: ARRAY
77454: IN
77455: NOT
77456: PUSH
77457: LD_VAR 0 3
77461: PUSH
77462: LD_EXP 64
77466: PUSH
77467: LD_VAR 0 2
77471: ARRAY
77472: PUSH
77473: LD_INT 2
77475: ARRAY
77476: IN
77477: NOT
77478: AND
77479: IFFALSE 77490
// ComSpaceTimeShoot ( j ) ;
77481: LD_VAR 0 3
77485: PPUSH
77486: CALL 16448 0 1
77490: GO 77432
77492: POP
77493: POP
// end ;
77494: GO 77335
77496: POP
77497: POP
// end ;
77498: LD_VAR 0 1
77502: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77503: LD_INT 0
77505: PPUSH
77506: PPUSH
77507: PPUSH
77508: PPUSH
77509: PPUSH
77510: PPUSH
77511: PPUSH
77512: PPUSH
77513: PPUSH
// if not mc_bases then
77514: LD_EXP 61
77518: NOT
77519: IFFALSE 77523
// exit ;
77521: GO 78145
// for i = 1 to mc_bases do
77523: LD_ADDR_VAR 0 2
77527: PUSH
77528: DOUBLE
77529: LD_INT 1
77531: DEC
77532: ST_TO_ADDR
77533: LD_EXP 61
77537: PUSH
77538: FOR_TO
77539: IFFALSE 78143
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77541: LD_EXP 96
77545: PUSH
77546: LD_VAR 0 2
77550: ARRAY
77551: NOT
77552: PUSH
77553: LD_INT 38
77555: PPUSH
77556: LD_EXP 87
77560: PUSH
77561: LD_VAR 0 2
77565: ARRAY
77566: PPUSH
77567: CALL_OW 321
77571: PUSH
77572: LD_INT 2
77574: NONEQUAL
77575: OR
77576: IFFALSE 77580
// continue ;
77578: GO 77538
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77580: LD_ADDR_VAR 0 8
77584: PUSH
77585: LD_EXP 61
77589: PUSH
77590: LD_VAR 0 2
77594: ARRAY
77595: PPUSH
77596: LD_INT 30
77598: PUSH
77599: LD_INT 34
77601: PUSH
77602: EMPTY
77603: LIST
77604: LIST
77605: PPUSH
77606: CALL_OW 72
77610: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77611: LD_ADDR_VAR 0 9
77615: PUSH
77616: LD_EXP 61
77620: PUSH
77621: LD_VAR 0 2
77625: ARRAY
77626: PPUSH
77627: LD_INT 25
77629: PUSH
77630: LD_INT 4
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PPUSH
77637: CALL_OW 72
77641: PPUSH
77642: LD_INT 0
77644: PPUSH
77645: CALL 50404 0 2
77649: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77650: LD_VAR 0 9
77654: NOT
77655: PUSH
77656: LD_VAR 0 8
77660: NOT
77661: OR
77662: PUSH
77663: LD_EXP 61
77667: PUSH
77668: LD_VAR 0 2
77672: ARRAY
77673: PPUSH
77674: LD_INT 124
77676: PPUSH
77677: CALL 50404 0 2
77681: OR
77682: IFFALSE 77686
// continue ;
77684: GO 77538
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77686: LD_EXP 97
77690: PUSH
77691: LD_VAR 0 2
77695: ARRAY
77696: PUSH
77697: LD_EXP 96
77701: PUSH
77702: LD_VAR 0 2
77706: ARRAY
77707: LESS
77708: PUSH
77709: LD_EXP 97
77713: PUSH
77714: LD_VAR 0 2
77718: ARRAY
77719: PUSH
77720: LD_VAR 0 8
77724: LESS
77725: AND
77726: IFFALSE 78141
// begin tmp := sci [ 1 ] ;
77728: LD_ADDR_VAR 0 7
77732: PUSH
77733: LD_VAR 0 9
77737: PUSH
77738: LD_INT 1
77740: ARRAY
77741: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77742: LD_VAR 0 7
77746: PPUSH
77747: LD_INT 124
77749: PPUSH
77750: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77754: LD_ADDR_VAR 0 3
77758: PUSH
77759: DOUBLE
77760: LD_EXP 96
77764: PUSH
77765: LD_VAR 0 2
77769: ARRAY
77770: INC
77771: ST_TO_ADDR
77772: LD_EXP 96
77776: PUSH
77777: LD_VAR 0 2
77781: ARRAY
77782: PUSH
77783: FOR_DOWNTO
77784: IFFALSE 78127
// begin if IsInUnit ( tmp ) then
77786: LD_VAR 0 7
77790: PPUSH
77791: CALL_OW 310
77795: IFFALSE 77806
// ComExitBuilding ( tmp ) ;
77797: LD_VAR 0 7
77801: PPUSH
77802: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77806: LD_INT 35
77808: PPUSH
77809: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77813: LD_VAR 0 7
77817: PPUSH
77818: CALL_OW 310
77822: NOT
77823: PUSH
77824: LD_VAR 0 7
77828: PPUSH
77829: CALL_OW 314
77833: NOT
77834: AND
77835: IFFALSE 77806
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77837: LD_ADDR_VAR 0 6
77841: PUSH
77842: LD_VAR 0 7
77846: PPUSH
77847: CALL_OW 250
77851: PUSH
77852: LD_VAR 0 7
77856: PPUSH
77857: CALL_OW 251
77861: PUSH
77862: EMPTY
77863: LIST
77864: LIST
77865: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77866: LD_INT 35
77868: PPUSH
77869: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77873: LD_ADDR_VAR 0 4
77877: PUSH
77878: LD_EXP 96
77882: PUSH
77883: LD_VAR 0 2
77887: ARRAY
77888: PUSH
77889: LD_VAR 0 3
77893: ARRAY
77894: PUSH
77895: LD_INT 1
77897: ARRAY
77898: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77899: LD_ADDR_VAR 0 5
77903: PUSH
77904: LD_EXP 96
77908: PUSH
77909: LD_VAR 0 2
77913: ARRAY
77914: PUSH
77915: LD_VAR 0 3
77919: ARRAY
77920: PUSH
77921: LD_INT 2
77923: ARRAY
77924: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77925: LD_VAR 0 7
77929: PPUSH
77930: LD_INT 10
77932: PPUSH
77933: CALL 23060 0 2
77937: PUSH
77938: LD_INT 4
77940: ARRAY
77941: IFFALSE 77979
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77943: LD_VAR 0 7
77947: PPUSH
77948: LD_VAR 0 6
77952: PUSH
77953: LD_INT 1
77955: ARRAY
77956: PPUSH
77957: LD_VAR 0 6
77961: PUSH
77962: LD_INT 2
77964: ARRAY
77965: PPUSH
77966: CALL_OW 111
// wait ( 0 0$10 ) ;
77970: LD_INT 350
77972: PPUSH
77973: CALL_OW 67
// end else
77977: GO 78005
// begin ComMoveXY ( tmp , x , y ) ;
77979: LD_VAR 0 7
77983: PPUSH
77984: LD_VAR 0 4
77988: PPUSH
77989: LD_VAR 0 5
77993: PPUSH
77994: CALL_OW 111
// wait ( 0 0$3 ) ;
77998: LD_INT 105
78000: PPUSH
78001: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
78005: LD_VAR 0 7
78009: PPUSH
78010: LD_VAR 0 4
78014: PPUSH
78015: LD_VAR 0 5
78019: PPUSH
78020: CALL_OW 307
78024: IFFALSE 77866
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
78026: LD_VAR 0 7
78030: PPUSH
78031: LD_VAR 0 4
78035: PPUSH
78036: LD_VAR 0 5
78040: PPUSH
78041: LD_VAR 0 8
78045: PUSH
78046: LD_VAR 0 3
78050: ARRAY
78051: PPUSH
78052: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
78056: LD_INT 35
78058: PPUSH
78059: CALL_OW 67
// until not HasTask ( tmp ) ;
78063: LD_VAR 0 7
78067: PPUSH
78068: CALL_OW 314
78072: NOT
78073: IFFALSE 78056
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
78075: LD_ADDR_EXP 97
78079: PUSH
78080: LD_EXP 97
78084: PPUSH
78085: LD_VAR 0 2
78089: PUSH
78090: LD_EXP 97
78094: PUSH
78095: LD_VAR 0 2
78099: ARRAY
78100: PUSH
78101: LD_INT 1
78103: PLUS
78104: PUSH
78105: EMPTY
78106: LIST
78107: LIST
78108: PPUSH
78109: LD_VAR 0 8
78113: PUSH
78114: LD_VAR 0 3
78118: ARRAY
78119: PPUSH
78120: CALL 20463 0 3
78124: ST_TO_ADDR
// end ;
78125: GO 77783
78127: POP
78128: POP
// MC_Reset ( i , 124 ) ;
78129: LD_VAR 0 2
78133: PPUSH
78134: LD_INT 124
78136: PPUSH
78137: CALL 61213 0 2
// end ; end ;
78141: GO 77538
78143: POP
78144: POP
// end ;
78145: LD_VAR 0 1
78149: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
78150: LD_INT 0
78152: PPUSH
78153: PPUSH
78154: PPUSH
// if not mc_bases then
78155: LD_EXP 61
78159: NOT
78160: IFFALSE 78164
// exit ;
78162: GO 78770
// for i = 1 to mc_bases do
78164: LD_ADDR_VAR 0 2
78168: PUSH
78169: DOUBLE
78170: LD_INT 1
78172: DEC
78173: ST_TO_ADDR
78174: LD_EXP 61
78178: PUSH
78179: FOR_TO
78180: IFFALSE 78768
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78182: LD_ADDR_VAR 0 3
78186: PUSH
78187: LD_EXP 61
78191: PUSH
78192: LD_VAR 0 2
78196: ARRAY
78197: PPUSH
78198: LD_INT 25
78200: PUSH
78201: LD_INT 4
78203: PUSH
78204: EMPTY
78205: LIST
78206: LIST
78207: PPUSH
78208: CALL_OW 72
78212: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78213: LD_VAR 0 3
78217: NOT
78218: PUSH
78219: LD_EXP 98
78223: PUSH
78224: LD_VAR 0 2
78228: ARRAY
78229: NOT
78230: OR
78231: PUSH
78232: LD_EXP 61
78236: PUSH
78237: LD_VAR 0 2
78241: ARRAY
78242: PPUSH
78243: LD_INT 2
78245: PUSH
78246: LD_INT 30
78248: PUSH
78249: LD_INT 0
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 30
78258: PUSH
78259: LD_INT 1
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: EMPTY
78267: LIST
78268: LIST
78269: LIST
78270: PPUSH
78271: CALL_OW 72
78275: NOT
78276: OR
78277: IFFALSE 78327
// begin if mc_deposits_finder [ i ] then
78279: LD_EXP 99
78283: PUSH
78284: LD_VAR 0 2
78288: ARRAY
78289: IFFALSE 78325
// begin MC_Reset ( i , 125 ) ;
78291: LD_VAR 0 2
78295: PPUSH
78296: LD_INT 125
78298: PPUSH
78299: CALL 61213 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78303: LD_ADDR_EXP 99
78307: PUSH
78308: LD_EXP 99
78312: PPUSH
78313: LD_VAR 0 2
78317: PPUSH
78318: EMPTY
78319: PPUSH
78320: CALL_OW 1
78324: ST_TO_ADDR
// end ; continue ;
78325: GO 78179
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78327: LD_EXP 98
78331: PUSH
78332: LD_VAR 0 2
78336: ARRAY
78337: PUSH
78338: LD_INT 1
78340: ARRAY
78341: PUSH
78342: LD_INT 3
78344: ARRAY
78345: PUSH
78346: LD_INT 1
78348: EQUAL
78349: PUSH
78350: LD_INT 20
78352: PPUSH
78353: LD_EXP 87
78357: PUSH
78358: LD_VAR 0 2
78362: ARRAY
78363: PPUSH
78364: CALL_OW 321
78368: PUSH
78369: LD_INT 2
78371: NONEQUAL
78372: AND
78373: IFFALSE 78423
// begin if mc_deposits_finder [ i ] then
78375: LD_EXP 99
78379: PUSH
78380: LD_VAR 0 2
78384: ARRAY
78385: IFFALSE 78421
// begin MC_Reset ( i , 125 ) ;
78387: LD_VAR 0 2
78391: PPUSH
78392: LD_INT 125
78394: PPUSH
78395: CALL 61213 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78399: LD_ADDR_EXP 99
78403: PUSH
78404: LD_EXP 99
78408: PPUSH
78409: LD_VAR 0 2
78413: PPUSH
78414: EMPTY
78415: PPUSH
78416: CALL_OW 1
78420: ST_TO_ADDR
// end ; continue ;
78421: GO 78179
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78423: LD_EXP 98
78427: PUSH
78428: LD_VAR 0 2
78432: ARRAY
78433: PUSH
78434: LD_INT 1
78436: ARRAY
78437: PUSH
78438: LD_INT 1
78440: ARRAY
78441: PPUSH
78442: LD_EXP 98
78446: PUSH
78447: LD_VAR 0 2
78451: ARRAY
78452: PUSH
78453: LD_INT 1
78455: ARRAY
78456: PUSH
78457: LD_INT 2
78459: ARRAY
78460: PPUSH
78461: LD_EXP 87
78465: PUSH
78466: LD_VAR 0 2
78470: ARRAY
78471: PPUSH
78472: CALL_OW 440
78476: IFFALSE 78519
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78478: LD_ADDR_EXP 98
78482: PUSH
78483: LD_EXP 98
78487: PPUSH
78488: LD_VAR 0 2
78492: PPUSH
78493: LD_EXP 98
78497: PUSH
78498: LD_VAR 0 2
78502: ARRAY
78503: PPUSH
78504: LD_INT 1
78506: PPUSH
78507: CALL_OW 3
78511: PPUSH
78512: CALL_OW 1
78516: ST_TO_ADDR
78517: GO 78766
// begin if not mc_deposits_finder [ i ] then
78519: LD_EXP 99
78523: PUSH
78524: LD_VAR 0 2
78528: ARRAY
78529: NOT
78530: IFFALSE 78582
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78532: LD_ADDR_EXP 99
78536: PUSH
78537: LD_EXP 99
78541: PPUSH
78542: LD_VAR 0 2
78546: PPUSH
78547: LD_VAR 0 3
78551: PUSH
78552: LD_INT 1
78554: ARRAY
78555: PUSH
78556: EMPTY
78557: LIST
78558: PPUSH
78559: CALL_OW 1
78563: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78564: LD_VAR 0 3
78568: PUSH
78569: LD_INT 1
78571: ARRAY
78572: PPUSH
78573: LD_INT 125
78575: PPUSH
78576: CALL_OW 109
// end else
78580: GO 78766
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78582: LD_EXP 99
78586: PUSH
78587: LD_VAR 0 2
78591: ARRAY
78592: PUSH
78593: LD_INT 1
78595: ARRAY
78596: PPUSH
78597: CALL_OW 310
78601: IFFALSE 78624
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78603: LD_EXP 99
78607: PUSH
78608: LD_VAR 0 2
78612: ARRAY
78613: PUSH
78614: LD_INT 1
78616: ARRAY
78617: PPUSH
78618: CALL_OW 122
78622: GO 78766
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78624: LD_EXP 99
78628: PUSH
78629: LD_VAR 0 2
78633: ARRAY
78634: PUSH
78635: LD_INT 1
78637: ARRAY
78638: PPUSH
78639: CALL_OW 314
78643: NOT
78644: PUSH
78645: LD_EXP 99
78649: PUSH
78650: LD_VAR 0 2
78654: ARRAY
78655: PUSH
78656: LD_INT 1
78658: ARRAY
78659: PPUSH
78660: LD_EXP 98
78664: PUSH
78665: LD_VAR 0 2
78669: ARRAY
78670: PUSH
78671: LD_INT 1
78673: ARRAY
78674: PUSH
78675: LD_INT 1
78677: ARRAY
78678: PPUSH
78679: LD_EXP 98
78683: PUSH
78684: LD_VAR 0 2
78688: ARRAY
78689: PUSH
78690: LD_INT 1
78692: ARRAY
78693: PUSH
78694: LD_INT 2
78696: ARRAY
78697: PPUSH
78698: CALL_OW 297
78702: PUSH
78703: LD_INT 6
78705: GREATER
78706: AND
78707: IFFALSE 78766
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78709: LD_EXP 99
78713: PUSH
78714: LD_VAR 0 2
78718: ARRAY
78719: PUSH
78720: LD_INT 1
78722: ARRAY
78723: PPUSH
78724: LD_EXP 98
78728: PUSH
78729: LD_VAR 0 2
78733: ARRAY
78734: PUSH
78735: LD_INT 1
78737: ARRAY
78738: PUSH
78739: LD_INT 1
78741: ARRAY
78742: PPUSH
78743: LD_EXP 98
78747: PUSH
78748: LD_VAR 0 2
78752: ARRAY
78753: PUSH
78754: LD_INT 1
78756: ARRAY
78757: PUSH
78758: LD_INT 2
78760: ARRAY
78761: PPUSH
78762: CALL_OW 111
// end ; end ; end ;
78766: GO 78179
78768: POP
78769: POP
// end ;
78770: LD_VAR 0 1
78774: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78775: LD_INT 0
78777: PPUSH
78778: PPUSH
78779: PPUSH
78780: PPUSH
78781: PPUSH
78782: PPUSH
78783: PPUSH
78784: PPUSH
78785: PPUSH
78786: PPUSH
78787: PPUSH
// if not mc_bases then
78788: LD_EXP 61
78792: NOT
78793: IFFALSE 78797
// exit ;
78795: GO 79737
// for i = 1 to mc_bases do
78797: LD_ADDR_VAR 0 2
78801: PUSH
78802: DOUBLE
78803: LD_INT 1
78805: DEC
78806: ST_TO_ADDR
78807: LD_EXP 61
78811: PUSH
78812: FOR_TO
78813: IFFALSE 79735
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78815: LD_EXP 61
78819: PUSH
78820: LD_VAR 0 2
78824: ARRAY
78825: NOT
78826: PUSH
78827: LD_EXP 84
78831: PUSH
78832: LD_VAR 0 2
78836: ARRAY
78837: OR
78838: IFFALSE 78842
// continue ;
78840: GO 78812
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78842: LD_ADDR_VAR 0 7
78846: PUSH
78847: LD_EXP 61
78851: PUSH
78852: LD_VAR 0 2
78856: ARRAY
78857: PUSH
78858: LD_INT 1
78860: ARRAY
78861: PPUSH
78862: CALL_OW 248
78866: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78867: LD_VAR 0 7
78871: PUSH
78872: LD_INT 3
78874: EQUAL
78875: PUSH
78876: LD_EXP 80
78880: PUSH
78881: LD_VAR 0 2
78885: ARRAY
78886: PUSH
78887: LD_EXP 83
78891: PUSH
78892: LD_VAR 0 2
78896: ARRAY
78897: UNION
78898: PPUSH
78899: LD_INT 33
78901: PUSH
78902: LD_INT 2
78904: PUSH
78905: EMPTY
78906: LIST
78907: LIST
78908: PPUSH
78909: CALL_OW 72
78913: NOT
78914: OR
78915: IFFALSE 78919
// continue ;
78917: GO 78812
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78919: LD_ADDR_VAR 0 9
78923: PUSH
78924: LD_EXP 61
78928: PUSH
78929: LD_VAR 0 2
78933: ARRAY
78934: PPUSH
78935: LD_INT 30
78937: PUSH
78938: LD_INT 36
78940: PUSH
78941: EMPTY
78942: LIST
78943: LIST
78944: PPUSH
78945: CALL_OW 72
78949: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78950: LD_ADDR_VAR 0 10
78954: PUSH
78955: LD_EXP 80
78959: PUSH
78960: LD_VAR 0 2
78964: ARRAY
78965: PPUSH
78966: LD_INT 34
78968: PUSH
78969: LD_INT 31
78971: PUSH
78972: EMPTY
78973: LIST
78974: LIST
78975: PPUSH
78976: CALL_OW 72
78980: ST_TO_ADDR
// if not cts and not mcts then
78981: LD_VAR 0 9
78985: NOT
78986: PUSH
78987: LD_VAR 0 10
78991: NOT
78992: AND
78993: IFFALSE 78997
// continue ;
78995: GO 78812
// x := cts ;
78997: LD_ADDR_VAR 0 11
79001: PUSH
79002: LD_VAR 0 9
79006: ST_TO_ADDR
// if not x then
79007: LD_VAR 0 11
79011: NOT
79012: IFFALSE 79024
// x := mcts ;
79014: LD_ADDR_VAR 0 11
79018: PUSH
79019: LD_VAR 0 10
79023: ST_TO_ADDR
// if not x then
79024: LD_VAR 0 11
79028: NOT
79029: IFFALSE 79033
// continue ;
79031: GO 78812
// if mc_remote_driver [ i ] then
79033: LD_EXP 101
79037: PUSH
79038: LD_VAR 0 2
79042: ARRAY
79043: IFFALSE 79430
// for j in mc_remote_driver [ i ] do
79045: LD_ADDR_VAR 0 3
79049: PUSH
79050: LD_EXP 101
79054: PUSH
79055: LD_VAR 0 2
79059: ARRAY
79060: PUSH
79061: FOR_IN
79062: IFFALSE 79428
// begin if GetClass ( j ) <> 3 then
79064: LD_VAR 0 3
79068: PPUSH
79069: CALL_OW 257
79073: PUSH
79074: LD_INT 3
79076: NONEQUAL
79077: IFFALSE 79130
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
79079: LD_ADDR_EXP 101
79083: PUSH
79084: LD_EXP 101
79088: PPUSH
79089: LD_VAR 0 2
79093: PPUSH
79094: LD_EXP 101
79098: PUSH
79099: LD_VAR 0 2
79103: ARRAY
79104: PUSH
79105: LD_VAR 0 3
79109: DIFF
79110: PPUSH
79111: CALL_OW 1
79115: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79116: LD_VAR 0 3
79120: PPUSH
79121: LD_INT 0
79123: PPUSH
79124: CALL_OW 109
// continue ;
79128: GO 79061
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
79130: LD_EXP 80
79134: PUSH
79135: LD_VAR 0 2
79139: ARRAY
79140: PPUSH
79141: LD_INT 34
79143: PUSH
79144: LD_INT 31
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 58
79153: PUSH
79154: EMPTY
79155: LIST
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PPUSH
79161: CALL_OW 72
79165: PUSH
79166: LD_VAR 0 3
79170: PPUSH
79171: CALL 50439 0 1
79175: NOT
79176: AND
79177: IFFALSE 79248
// begin if IsInUnit ( j ) then
79179: LD_VAR 0 3
79183: PPUSH
79184: CALL_OW 310
79188: IFFALSE 79199
// ComExitBuilding ( j ) ;
79190: LD_VAR 0 3
79194: PPUSH
79195: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79199: LD_VAR 0 3
79203: PPUSH
79204: LD_EXP 80
79208: PUSH
79209: LD_VAR 0 2
79213: ARRAY
79214: PPUSH
79215: LD_INT 34
79217: PUSH
79218: LD_INT 31
79220: PUSH
79221: EMPTY
79222: LIST
79223: LIST
79224: PUSH
79225: LD_INT 58
79227: PUSH
79228: EMPTY
79229: LIST
79230: PUSH
79231: EMPTY
79232: LIST
79233: LIST
79234: PPUSH
79235: CALL_OW 72
79239: PUSH
79240: LD_INT 1
79242: ARRAY
79243: PPUSH
79244: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79248: LD_VAR 0 3
79252: PPUSH
79253: CALL_OW 310
79257: NOT
79258: PUSH
79259: LD_VAR 0 3
79263: PPUSH
79264: CALL_OW 310
79268: PPUSH
79269: CALL_OW 266
79273: PUSH
79274: LD_INT 36
79276: NONEQUAL
79277: PUSH
79278: LD_VAR 0 3
79282: PPUSH
79283: CALL 50439 0 1
79287: NOT
79288: AND
79289: OR
79290: IFFALSE 79426
// begin if IsInUnit ( j ) then
79292: LD_VAR 0 3
79296: PPUSH
79297: CALL_OW 310
79301: IFFALSE 79312
// ComExitBuilding ( j ) ;
79303: LD_VAR 0 3
79307: PPUSH
79308: CALL_OW 122
// ct := 0 ;
79312: LD_ADDR_VAR 0 8
79316: PUSH
79317: LD_INT 0
79319: ST_TO_ADDR
// for k in x do
79320: LD_ADDR_VAR 0 4
79324: PUSH
79325: LD_VAR 0 11
79329: PUSH
79330: FOR_IN
79331: IFFALSE 79404
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79333: LD_VAR 0 4
79337: PPUSH
79338: CALL_OW 264
79342: PUSH
79343: LD_INT 31
79345: EQUAL
79346: PUSH
79347: LD_VAR 0 4
79351: PPUSH
79352: CALL_OW 311
79356: NOT
79357: AND
79358: PUSH
79359: LD_VAR 0 4
79363: PPUSH
79364: CALL_OW 266
79368: PUSH
79369: LD_INT 36
79371: EQUAL
79372: PUSH
79373: LD_VAR 0 4
79377: PPUSH
79378: CALL_OW 313
79382: PUSH
79383: LD_INT 3
79385: LESS
79386: AND
79387: OR
79388: IFFALSE 79402
// begin ct := k ;
79390: LD_ADDR_VAR 0 8
79394: PUSH
79395: LD_VAR 0 4
79399: ST_TO_ADDR
// break ;
79400: GO 79404
// end ;
79402: GO 79330
79404: POP
79405: POP
// if ct then
79406: LD_VAR 0 8
79410: IFFALSE 79426
// ComEnterUnit ( j , ct ) ;
79412: LD_VAR 0 3
79416: PPUSH
79417: LD_VAR 0 8
79421: PPUSH
79422: CALL_OW 120
// end ; end ;
79426: GO 79061
79428: POP
79429: POP
// places := 0 ;
79430: LD_ADDR_VAR 0 5
79434: PUSH
79435: LD_INT 0
79437: ST_TO_ADDR
// for j = 1 to x do
79438: LD_ADDR_VAR 0 3
79442: PUSH
79443: DOUBLE
79444: LD_INT 1
79446: DEC
79447: ST_TO_ADDR
79448: LD_VAR 0 11
79452: PUSH
79453: FOR_TO
79454: IFFALSE 79530
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79456: LD_VAR 0 11
79460: PUSH
79461: LD_VAR 0 3
79465: ARRAY
79466: PPUSH
79467: CALL_OW 264
79471: PUSH
79472: LD_INT 31
79474: EQUAL
79475: IFFALSE 79493
// places := places + 1 else
79477: LD_ADDR_VAR 0 5
79481: PUSH
79482: LD_VAR 0 5
79486: PUSH
79487: LD_INT 1
79489: PLUS
79490: ST_TO_ADDR
79491: GO 79528
// if GetBType ( x [ j ] ) = b_control_tower then
79493: LD_VAR 0 11
79497: PUSH
79498: LD_VAR 0 3
79502: ARRAY
79503: PPUSH
79504: CALL_OW 266
79508: PUSH
79509: LD_INT 36
79511: EQUAL
79512: IFFALSE 79528
// places := places + 3 ;
79514: LD_ADDR_VAR 0 5
79518: PUSH
79519: LD_VAR 0 5
79523: PUSH
79524: LD_INT 3
79526: PLUS
79527: ST_TO_ADDR
79528: GO 79453
79530: POP
79531: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79532: LD_VAR 0 5
79536: PUSH
79537: LD_INT 0
79539: EQUAL
79540: PUSH
79541: LD_VAR 0 5
79545: PUSH
79546: LD_EXP 101
79550: PUSH
79551: LD_VAR 0 2
79555: ARRAY
79556: LESSEQUAL
79557: OR
79558: IFFALSE 79562
// continue ;
79560: GO 78812
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79562: LD_ADDR_VAR 0 6
79566: PUSH
79567: LD_EXP 61
79571: PUSH
79572: LD_VAR 0 2
79576: ARRAY
79577: PPUSH
79578: LD_INT 25
79580: PUSH
79581: LD_INT 3
79583: PUSH
79584: EMPTY
79585: LIST
79586: LIST
79587: PPUSH
79588: CALL_OW 72
79592: PUSH
79593: LD_EXP 101
79597: PUSH
79598: LD_VAR 0 2
79602: ARRAY
79603: DIFF
79604: PPUSH
79605: LD_INT 3
79607: PPUSH
79608: CALL 51339 0 2
79612: ST_TO_ADDR
// for j in tmp do
79613: LD_ADDR_VAR 0 3
79617: PUSH
79618: LD_VAR 0 6
79622: PUSH
79623: FOR_IN
79624: IFFALSE 79659
// if GetTag ( j ) > 0 then
79626: LD_VAR 0 3
79630: PPUSH
79631: CALL_OW 110
79635: PUSH
79636: LD_INT 0
79638: GREATER
79639: IFFALSE 79657
// tmp := tmp diff j ;
79641: LD_ADDR_VAR 0 6
79645: PUSH
79646: LD_VAR 0 6
79650: PUSH
79651: LD_VAR 0 3
79655: DIFF
79656: ST_TO_ADDR
79657: GO 79623
79659: POP
79660: POP
// if not tmp then
79661: LD_VAR 0 6
79665: NOT
79666: IFFALSE 79670
// continue ;
79668: GO 78812
// if places then
79670: LD_VAR 0 5
79674: IFFALSE 79733
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79676: LD_ADDR_EXP 101
79680: PUSH
79681: LD_EXP 101
79685: PPUSH
79686: LD_VAR 0 2
79690: PPUSH
79691: LD_EXP 101
79695: PUSH
79696: LD_VAR 0 2
79700: ARRAY
79701: PUSH
79702: LD_VAR 0 6
79706: PUSH
79707: LD_INT 1
79709: ARRAY
79710: UNION
79711: PPUSH
79712: CALL_OW 1
79716: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79717: LD_VAR 0 6
79721: PUSH
79722: LD_INT 1
79724: ARRAY
79725: PPUSH
79726: LD_INT 126
79728: PPUSH
79729: CALL_OW 109
// end ; end ;
79733: GO 78812
79735: POP
79736: POP
// end ;
79737: LD_VAR 0 1
79741: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79742: LD_INT 0
79744: PPUSH
79745: PPUSH
79746: PPUSH
79747: PPUSH
79748: PPUSH
79749: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79750: LD_VAR 0 1
79754: NOT
79755: PUSH
79756: LD_VAR 0 2
79760: NOT
79761: OR
79762: PUSH
79763: LD_VAR 0 3
79767: NOT
79768: OR
79769: PUSH
79770: LD_VAR 0 4
79774: PUSH
79775: LD_INT 1
79777: PUSH
79778: LD_INT 2
79780: PUSH
79781: LD_INT 3
79783: PUSH
79784: LD_INT 4
79786: PUSH
79787: LD_INT 5
79789: PUSH
79790: LD_INT 8
79792: PUSH
79793: LD_INT 9
79795: PUSH
79796: LD_INT 15
79798: PUSH
79799: LD_INT 16
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: LIST
79806: LIST
79807: LIST
79808: LIST
79809: LIST
79810: LIST
79811: LIST
79812: IN
79813: NOT
79814: OR
79815: IFFALSE 79819
// exit ;
79817: GO 80677
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79819: LD_ADDR_VAR 0 2
79823: PUSH
79824: LD_VAR 0 2
79828: PPUSH
79829: LD_INT 21
79831: PUSH
79832: LD_INT 3
79834: PUSH
79835: EMPTY
79836: LIST
79837: LIST
79838: PUSH
79839: LD_INT 24
79841: PUSH
79842: LD_INT 250
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: EMPTY
79850: LIST
79851: LIST
79852: PPUSH
79853: CALL_OW 72
79857: ST_TO_ADDR
// case class of 1 , 15 :
79858: LD_VAR 0 4
79862: PUSH
79863: LD_INT 1
79865: DOUBLE
79866: EQUAL
79867: IFTRUE 79877
79869: LD_INT 15
79871: DOUBLE
79872: EQUAL
79873: IFTRUE 79877
79875: GO 79962
79877: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79878: LD_ADDR_VAR 0 8
79882: PUSH
79883: LD_VAR 0 2
79887: PPUSH
79888: LD_INT 2
79890: PUSH
79891: LD_INT 30
79893: PUSH
79894: LD_INT 32
79896: PUSH
79897: EMPTY
79898: LIST
79899: LIST
79900: PUSH
79901: LD_INT 30
79903: PUSH
79904: LD_INT 31
79906: PUSH
79907: EMPTY
79908: LIST
79909: LIST
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: LIST
79915: PPUSH
79916: CALL_OW 72
79920: PUSH
79921: LD_VAR 0 2
79925: PPUSH
79926: LD_INT 2
79928: PUSH
79929: LD_INT 30
79931: PUSH
79932: LD_INT 4
79934: PUSH
79935: EMPTY
79936: LIST
79937: LIST
79938: PUSH
79939: LD_INT 30
79941: PUSH
79942: LD_INT 5
79944: PUSH
79945: EMPTY
79946: LIST
79947: LIST
79948: PUSH
79949: EMPTY
79950: LIST
79951: LIST
79952: LIST
79953: PPUSH
79954: CALL_OW 72
79958: ADD
79959: ST_TO_ADDR
79960: GO 80208
79962: LD_INT 2
79964: DOUBLE
79965: EQUAL
79966: IFTRUE 79976
79968: LD_INT 16
79970: DOUBLE
79971: EQUAL
79972: IFTRUE 79976
79974: GO 80022
79976: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79977: LD_ADDR_VAR 0 8
79981: PUSH
79982: LD_VAR 0 2
79986: PPUSH
79987: LD_INT 2
79989: PUSH
79990: LD_INT 30
79992: PUSH
79993: LD_INT 0
79995: PUSH
79996: EMPTY
79997: LIST
79998: LIST
79999: PUSH
80000: LD_INT 30
80002: PUSH
80003: LD_INT 1
80005: PUSH
80006: EMPTY
80007: LIST
80008: LIST
80009: PUSH
80010: EMPTY
80011: LIST
80012: LIST
80013: LIST
80014: PPUSH
80015: CALL_OW 72
80019: ST_TO_ADDR
80020: GO 80208
80022: LD_INT 3
80024: DOUBLE
80025: EQUAL
80026: IFTRUE 80030
80028: GO 80076
80030: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
80031: LD_ADDR_VAR 0 8
80035: PUSH
80036: LD_VAR 0 2
80040: PPUSH
80041: LD_INT 2
80043: PUSH
80044: LD_INT 30
80046: PUSH
80047: LD_INT 2
80049: PUSH
80050: EMPTY
80051: LIST
80052: LIST
80053: PUSH
80054: LD_INT 30
80056: PUSH
80057: LD_INT 3
80059: PUSH
80060: EMPTY
80061: LIST
80062: LIST
80063: PUSH
80064: EMPTY
80065: LIST
80066: LIST
80067: LIST
80068: PPUSH
80069: CALL_OW 72
80073: ST_TO_ADDR
80074: GO 80208
80076: LD_INT 4
80078: DOUBLE
80079: EQUAL
80080: IFTRUE 80084
80082: GO 80141
80084: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
80085: LD_ADDR_VAR 0 8
80089: PUSH
80090: LD_VAR 0 2
80094: PPUSH
80095: LD_INT 2
80097: PUSH
80098: LD_INT 30
80100: PUSH
80101: LD_INT 6
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 30
80110: PUSH
80111: LD_INT 7
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 30
80120: PUSH
80121: LD_INT 8
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: EMPTY
80129: LIST
80130: LIST
80131: LIST
80132: LIST
80133: PPUSH
80134: CALL_OW 72
80138: ST_TO_ADDR
80139: GO 80208
80141: LD_INT 5
80143: DOUBLE
80144: EQUAL
80145: IFTRUE 80161
80147: LD_INT 8
80149: DOUBLE
80150: EQUAL
80151: IFTRUE 80161
80153: LD_INT 9
80155: DOUBLE
80156: EQUAL
80157: IFTRUE 80161
80159: GO 80207
80161: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
80162: LD_ADDR_VAR 0 8
80166: PUSH
80167: LD_VAR 0 2
80171: PPUSH
80172: LD_INT 2
80174: PUSH
80175: LD_INT 30
80177: PUSH
80178: LD_INT 4
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_INT 30
80187: PUSH
80188: LD_INT 5
80190: PUSH
80191: EMPTY
80192: LIST
80193: LIST
80194: PUSH
80195: EMPTY
80196: LIST
80197: LIST
80198: LIST
80199: PPUSH
80200: CALL_OW 72
80204: ST_TO_ADDR
80205: GO 80208
80207: POP
// if not tmp then
80208: LD_VAR 0 8
80212: NOT
80213: IFFALSE 80217
// exit ;
80215: GO 80677
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80217: LD_VAR 0 4
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: LD_INT 15
80227: PUSH
80228: EMPTY
80229: LIST
80230: LIST
80231: IN
80232: PUSH
80233: LD_EXP 70
80237: PUSH
80238: LD_VAR 0 1
80242: ARRAY
80243: AND
80244: IFFALSE 80400
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80246: LD_ADDR_VAR 0 9
80250: PUSH
80251: LD_EXP 70
80255: PUSH
80256: LD_VAR 0 1
80260: ARRAY
80261: PUSH
80262: LD_INT 1
80264: ARRAY
80265: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80266: LD_VAR 0 9
80270: PUSH
80271: LD_EXP 71
80275: PUSH
80276: LD_VAR 0 1
80280: ARRAY
80281: IN
80282: NOT
80283: IFFALSE 80398
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80285: LD_ADDR_EXP 71
80289: PUSH
80290: LD_EXP 71
80294: PPUSH
80295: LD_VAR 0 1
80299: PUSH
80300: LD_EXP 71
80304: PUSH
80305: LD_VAR 0 1
80309: ARRAY
80310: PUSH
80311: LD_INT 1
80313: PLUS
80314: PUSH
80315: EMPTY
80316: LIST
80317: LIST
80318: PPUSH
80319: LD_VAR 0 9
80323: PPUSH
80324: CALL 20463 0 3
80328: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80329: LD_ADDR_EXP 70
80333: PUSH
80334: LD_EXP 70
80338: PPUSH
80339: LD_VAR 0 1
80343: PPUSH
80344: LD_EXP 70
80348: PUSH
80349: LD_VAR 0 1
80353: ARRAY
80354: PUSH
80355: LD_VAR 0 9
80359: DIFF
80360: PPUSH
80361: CALL_OW 1
80365: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80366: LD_VAR 0 3
80370: PPUSH
80371: LD_EXP 71
80375: PUSH
80376: LD_VAR 0 1
80380: ARRAY
80381: PUSH
80382: LD_EXP 71
80386: PUSH
80387: LD_VAR 0 1
80391: ARRAY
80392: ARRAY
80393: PPUSH
80394: CALL_OW 120
// end ; exit ;
80398: GO 80677
// end ; if tmp > 1 then
80400: LD_VAR 0 8
80404: PUSH
80405: LD_INT 1
80407: GREATER
80408: IFFALSE 80512
// for i = 2 to tmp do
80410: LD_ADDR_VAR 0 6
80414: PUSH
80415: DOUBLE
80416: LD_INT 2
80418: DEC
80419: ST_TO_ADDR
80420: LD_VAR 0 8
80424: PUSH
80425: FOR_TO
80426: IFFALSE 80510
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80428: LD_VAR 0 8
80432: PUSH
80433: LD_VAR 0 6
80437: ARRAY
80438: PPUSH
80439: CALL_OW 461
80443: PUSH
80444: LD_INT 6
80446: EQUAL
80447: IFFALSE 80508
// begin x := tmp [ i ] ;
80449: LD_ADDR_VAR 0 9
80453: PUSH
80454: LD_VAR 0 8
80458: PUSH
80459: LD_VAR 0 6
80463: ARRAY
80464: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80465: LD_ADDR_VAR 0 8
80469: PUSH
80470: LD_VAR 0 8
80474: PPUSH
80475: LD_VAR 0 6
80479: PPUSH
80480: CALL_OW 3
80484: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80485: LD_ADDR_VAR 0 8
80489: PUSH
80490: LD_VAR 0 8
80494: PPUSH
80495: LD_INT 1
80497: PPUSH
80498: LD_VAR 0 9
80502: PPUSH
80503: CALL_OW 2
80507: ST_TO_ADDR
// end ;
80508: GO 80425
80510: POP
80511: POP
// for i in tmp do
80512: LD_ADDR_VAR 0 6
80516: PUSH
80517: LD_VAR 0 8
80521: PUSH
80522: FOR_IN
80523: IFFALSE 80550
// begin if IsNotFull ( i ) then
80525: LD_VAR 0 6
80529: PPUSH
80530: CALL 17685 0 1
80534: IFFALSE 80548
// begin j := i ;
80536: LD_ADDR_VAR 0 7
80540: PUSH
80541: LD_VAR 0 6
80545: ST_TO_ADDR
// break ;
80546: GO 80550
// end ; end ;
80548: GO 80522
80550: POP
80551: POP
// if j then
80552: LD_VAR 0 7
80556: IFFALSE 80574
// ComEnterUnit ( unit , j ) else
80558: LD_VAR 0 3
80562: PPUSH
80563: LD_VAR 0 7
80567: PPUSH
80568: CALL_OW 120
80572: GO 80677
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80574: LD_ADDR_VAR 0 10
80578: PUSH
80579: LD_VAR 0 2
80583: PPUSH
80584: LD_INT 2
80586: PUSH
80587: LD_INT 30
80589: PUSH
80590: LD_INT 0
80592: PUSH
80593: EMPTY
80594: LIST
80595: LIST
80596: PUSH
80597: LD_INT 30
80599: PUSH
80600: LD_INT 1
80602: PUSH
80603: EMPTY
80604: LIST
80605: LIST
80606: PUSH
80607: EMPTY
80608: LIST
80609: LIST
80610: LIST
80611: PPUSH
80612: CALL_OW 72
80616: ST_TO_ADDR
// if depot then
80617: LD_VAR 0 10
80621: IFFALSE 80677
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80623: LD_ADDR_VAR 0 10
80627: PUSH
80628: LD_VAR 0 10
80632: PPUSH
80633: LD_VAR 0 3
80637: PPUSH
80638: CALL_OW 74
80642: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80643: LD_VAR 0 3
80647: PPUSH
80648: LD_VAR 0 10
80652: PPUSH
80653: CALL_OW 296
80657: PUSH
80658: LD_INT 10
80660: GREATER
80661: IFFALSE 80677
// ComStandNearbyBuilding ( unit , depot ) ;
80663: LD_VAR 0 3
80667: PPUSH
80668: LD_VAR 0 10
80672: PPUSH
80673: CALL 17065 0 2
// end ; end ; end ;
80677: LD_VAR 0 5
80681: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80682: LD_INT 0
80684: PPUSH
80685: PPUSH
80686: PPUSH
80687: PPUSH
// if not mc_bases then
80688: LD_EXP 61
80692: NOT
80693: IFFALSE 80697
// exit ;
80695: GO 80936
// for i = 1 to mc_bases do
80697: LD_ADDR_VAR 0 2
80701: PUSH
80702: DOUBLE
80703: LD_INT 1
80705: DEC
80706: ST_TO_ADDR
80707: LD_EXP 61
80711: PUSH
80712: FOR_TO
80713: IFFALSE 80934
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80715: LD_ADDR_VAR 0 4
80719: PUSH
80720: LD_EXP 61
80724: PUSH
80725: LD_VAR 0 2
80729: ARRAY
80730: PPUSH
80731: LD_INT 21
80733: PUSH
80734: LD_INT 1
80736: PUSH
80737: EMPTY
80738: LIST
80739: LIST
80740: PPUSH
80741: CALL_OW 72
80745: PUSH
80746: LD_EXP 90
80750: PUSH
80751: LD_VAR 0 2
80755: ARRAY
80756: UNION
80757: ST_TO_ADDR
// if not tmp then
80758: LD_VAR 0 4
80762: NOT
80763: IFFALSE 80767
// continue ;
80765: GO 80712
// for j in tmp do
80767: LD_ADDR_VAR 0 3
80771: PUSH
80772: LD_VAR 0 4
80776: PUSH
80777: FOR_IN
80778: IFFALSE 80930
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80780: LD_VAR 0 3
80784: PPUSH
80785: CALL_OW 110
80789: NOT
80790: PUSH
80791: LD_VAR 0 3
80795: PPUSH
80796: CALL_OW 314
80800: NOT
80801: AND
80802: PUSH
80803: LD_VAR 0 3
80807: PPUSH
80808: CALL_OW 311
80812: NOT
80813: AND
80814: PUSH
80815: LD_VAR 0 3
80819: PPUSH
80820: CALL_OW 310
80824: NOT
80825: AND
80826: PUSH
80827: LD_VAR 0 3
80831: PUSH
80832: LD_EXP 64
80836: PUSH
80837: LD_VAR 0 2
80841: ARRAY
80842: PUSH
80843: LD_INT 1
80845: ARRAY
80846: IN
80847: NOT
80848: AND
80849: PUSH
80850: LD_VAR 0 3
80854: PUSH
80855: LD_EXP 64
80859: PUSH
80860: LD_VAR 0 2
80864: ARRAY
80865: PUSH
80866: LD_INT 2
80868: ARRAY
80869: IN
80870: NOT
80871: AND
80872: PUSH
80873: LD_VAR 0 3
80877: PUSH
80878: LD_EXP 73
80882: PUSH
80883: LD_VAR 0 2
80887: ARRAY
80888: IN
80889: NOT
80890: AND
80891: IFFALSE 80928
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80893: LD_VAR 0 2
80897: PPUSH
80898: LD_EXP 61
80902: PUSH
80903: LD_VAR 0 2
80907: ARRAY
80908: PPUSH
80909: LD_VAR 0 3
80913: PPUSH
80914: LD_VAR 0 3
80918: PPUSH
80919: CALL_OW 257
80923: PPUSH
80924: CALL 79742 0 4
// end ;
80928: GO 80777
80930: POP
80931: POP
// end ;
80932: GO 80712
80934: POP
80935: POP
// end ;
80936: LD_VAR 0 1
80940: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
80941: LD_INT 0
80943: PPUSH
80944: PPUSH
80945: PPUSH
80946: PPUSH
80947: PPUSH
80948: PPUSH
// if not mc_bases [ base ] then
80949: LD_EXP 61
80953: PUSH
80954: LD_VAR 0 1
80958: ARRAY
80959: NOT
80960: IFFALSE 80964
// exit ;
80962: GO 81165
// tmp := [ ] ;
80964: LD_ADDR_VAR 0 6
80968: PUSH
80969: EMPTY
80970: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80971: LD_ADDR_VAR 0 7
80975: PUSH
80976: LD_VAR 0 3
80980: PPUSH
80981: LD_INT 0
80983: PPUSH
80984: CALL_OW 517
80988: ST_TO_ADDR
// if not list then
80989: LD_VAR 0 7
80993: NOT
80994: IFFALSE 80998
// exit ;
80996: GO 81165
// c := Count ( list [ 1 ] ) ;
80998: LD_ADDR_VAR 0 9
81002: PUSH
81003: LD_VAR 0 7
81007: PUSH
81008: LD_INT 1
81010: ARRAY
81011: PPUSH
81012: CALL 17603 0 1
81016: ST_TO_ADDR
// if amount > c then
81017: LD_VAR 0 2
81021: PUSH
81022: LD_VAR 0 9
81026: GREATER
81027: IFFALSE 81039
// amount := c ;
81029: LD_ADDR_VAR 0 2
81033: PUSH
81034: LD_VAR 0 9
81038: ST_TO_ADDR
// for i := 1 to amount do
81039: LD_ADDR_VAR 0 5
81043: PUSH
81044: DOUBLE
81045: LD_INT 1
81047: DEC
81048: ST_TO_ADDR
81049: LD_VAR 0 2
81053: PUSH
81054: FOR_TO
81055: IFFALSE 81113
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
81057: LD_ADDR_VAR 0 6
81061: PUSH
81062: LD_VAR 0 6
81066: PPUSH
81067: LD_VAR 0 5
81071: PPUSH
81072: LD_VAR 0 7
81076: PUSH
81077: LD_INT 1
81079: ARRAY
81080: PUSH
81081: LD_VAR 0 5
81085: ARRAY
81086: PUSH
81087: LD_VAR 0 7
81091: PUSH
81092: LD_INT 2
81094: ARRAY
81095: PUSH
81096: LD_VAR 0 5
81100: ARRAY
81101: PUSH
81102: EMPTY
81103: LIST
81104: LIST
81105: PPUSH
81106: CALL_OW 1
81110: ST_TO_ADDR
81111: GO 81054
81113: POP
81114: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
81115: LD_ADDR_EXP 74
81119: PUSH
81120: LD_EXP 74
81124: PPUSH
81125: LD_VAR 0 1
81129: PPUSH
81130: LD_VAR 0 6
81134: PPUSH
81135: CALL_OW 1
81139: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
81140: LD_ADDR_EXP 76
81144: PUSH
81145: LD_EXP 76
81149: PPUSH
81150: LD_VAR 0 1
81154: PPUSH
81155: LD_VAR 0 3
81159: PPUSH
81160: CALL_OW 1
81164: ST_TO_ADDR
// end ;
81165: LD_VAR 0 4
81169: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81170: LD_INT 0
81172: PPUSH
// if not mc_bases [ base ] then
81173: LD_EXP 61
81177: PUSH
81178: LD_VAR 0 1
81182: ARRAY
81183: NOT
81184: IFFALSE 81188
// exit ;
81186: GO 81213
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81188: LD_ADDR_EXP 66
81192: PUSH
81193: LD_EXP 66
81197: PPUSH
81198: LD_VAR 0 1
81202: PPUSH
81203: LD_VAR 0 2
81207: PPUSH
81208: CALL_OW 1
81212: ST_TO_ADDR
// end ;
81213: LD_VAR 0 3
81217: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81218: LD_INT 0
81220: PPUSH
// if not mc_bases [ base ] then
81221: LD_EXP 61
81225: PUSH
81226: LD_VAR 0 1
81230: ARRAY
81231: NOT
81232: IFFALSE 81236
// exit ;
81234: GO 81273
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81236: LD_ADDR_EXP 66
81240: PUSH
81241: LD_EXP 66
81245: PPUSH
81246: LD_VAR 0 1
81250: PPUSH
81251: LD_EXP 66
81255: PUSH
81256: LD_VAR 0 1
81260: ARRAY
81261: PUSH
81262: LD_VAR 0 2
81266: UNION
81267: PPUSH
81268: CALL_OW 1
81272: ST_TO_ADDR
// end ;
81273: LD_VAR 0 3
81277: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81278: LD_INT 0
81280: PPUSH
// if not mc_bases [ base ] then
81281: LD_EXP 61
81285: PUSH
81286: LD_VAR 0 1
81290: ARRAY
81291: NOT
81292: IFFALSE 81296
// exit ;
81294: GO 81321
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81296: LD_ADDR_EXP 82
81300: PUSH
81301: LD_EXP 82
81305: PPUSH
81306: LD_VAR 0 1
81310: PPUSH
81311: LD_VAR 0 2
81315: PPUSH
81316: CALL_OW 1
81320: ST_TO_ADDR
// end ;
81321: LD_VAR 0 3
81325: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81326: LD_INT 0
81328: PPUSH
// if not mc_bases [ base ] then
81329: LD_EXP 61
81333: PUSH
81334: LD_VAR 0 1
81338: ARRAY
81339: NOT
81340: IFFALSE 81344
// exit ;
81342: GO 81381
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81344: LD_ADDR_EXP 82
81348: PUSH
81349: LD_EXP 82
81353: PPUSH
81354: LD_VAR 0 1
81358: PPUSH
81359: LD_EXP 82
81363: PUSH
81364: LD_VAR 0 1
81368: ARRAY
81369: PUSH
81370: LD_VAR 0 2
81374: ADD
81375: PPUSH
81376: CALL_OW 1
81380: ST_TO_ADDR
// end ;
81381: LD_VAR 0 3
81385: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81386: LD_INT 0
81388: PPUSH
// if not mc_bases [ base ] then
81389: LD_EXP 61
81393: PUSH
81394: LD_VAR 0 1
81398: ARRAY
81399: NOT
81400: IFFALSE 81404
// exit ;
81402: GO 81458
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81404: LD_ADDR_EXP 83
81408: PUSH
81409: LD_EXP 83
81413: PPUSH
81414: LD_VAR 0 1
81418: PPUSH
81419: LD_VAR 0 2
81423: PPUSH
81424: CALL_OW 1
81428: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81429: LD_ADDR_EXP 72
81433: PUSH
81434: LD_EXP 72
81438: PPUSH
81439: LD_VAR 0 1
81443: PPUSH
81444: LD_VAR 0 2
81448: PUSH
81449: LD_INT 0
81451: PLUS
81452: PPUSH
81453: CALL_OW 1
81457: ST_TO_ADDR
// end ;
81458: LD_VAR 0 3
81462: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81463: LD_INT 0
81465: PPUSH
// if not mc_bases [ base ] then
81466: LD_EXP 61
81470: PUSH
81471: LD_VAR 0 1
81475: ARRAY
81476: NOT
81477: IFFALSE 81481
// exit ;
81479: GO 81506
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81481: LD_ADDR_EXP 72
81485: PUSH
81486: LD_EXP 72
81490: PPUSH
81491: LD_VAR 0 1
81495: PPUSH
81496: LD_VAR 0 2
81500: PPUSH
81501: CALL_OW 1
81505: ST_TO_ADDR
// end ;
81506: LD_VAR 0 3
81510: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81511: LD_INT 0
81513: PPUSH
81514: PPUSH
81515: PPUSH
81516: PPUSH
// if not mc_bases [ base ] then
81517: LD_EXP 61
81521: PUSH
81522: LD_VAR 0 1
81526: ARRAY
81527: NOT
81528: IFFALSE 81532
// exit ;
81530: GO 81597
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81532: LD_ADDR_EXP 81
81536: PUSH
81537: LD_EXP 81
81541: PPUSH
81542: LD_VAR 0 1
81546: PUSH
81547: LD_EXP 81
81551: PUSH
81552: LD_VAR 0 1
81556: ARRAY
81557: PUSH
81558: LD_INT 1
81560: PLUS
81561: PUSH
81562: EMPTY
81563: LIST
81564: LIST
81565: PPUSH
81566: LD_VAR 0 1
81570: PUSH
81571: LD_VAR 0 2
81575: PUSH
81576: LD_VAR 0 3
81580: PUSH
81581: LD_VAR 0 4
81585: PUSH
81586: EMPTY
81587: LIST
81588: LIST
81589: LIST
81590: LIST
81591: PPUSH
81592: CALL 20463 0 3
81596: ST_TO_ADDR
// end ;
81597: LD_VAR 0 5
81601: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81602: LD_INT 0
81604: PPUSH
// if not mc_bases [ base ] then
81605: LD_EXP 61
81609: PUSH
81610: LD_VAR 0 1
81614: ARRAY
81615: NOT
81616: IFFALSE 81620
// exit ;
81618: GO 81645
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81620: LD_ADDR_EXP 98
81624: PUSH
81625: LD_EXP 98
81629: PPUSH
81630: LD_VAR 0 1
81634: PPUSH
81635: LD_VAR 0 2
81639: PPUSH
81640: CALL_OW 1
81644: ST_TO_ADDR
// end ;
81645: LD_VAR 0 3
81649: RET
// export function MC_GetMinesField ( base ) ; begin
81650: LD_INT 0
81652: PPUSH
// result := mc_mines [ base ] ;
81653: LD_ADDR_VAR 0 2
81657: PUSH
81658: LD_EXP 74
81662: PUSH
81663: LD_VAR 0 1
81667: ARRAY
81668: ST_TO_ADDR
// end ;
81669: LD_VAR 0 2
81673: RET
// export function MC_GetProduceList ( base ) ; begin
81674: LD_INT 0
81676: PPUSH
// result := mc_produce [ base ] ;
81677: LD_ADDR_VAR 0 2
81681: PUSH
81682: LD_EXP 82
81686: PUSH
81687: LD_VAR 0 1
81691: ARRAY
81692: ST_TO_ADDR
// end ;
81693: LD_VAR 0 2
81697: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81698: LD_INT 0
81700: PPUSH
81701: PPUSH
// if not mc_bases then
81702: LD_EXP 61
81706: NOT
81707: IFFALSE 81711
// exit ;
81709: GO 81776
// if mc_bases [ base ] then
81711: LD_EXP 61
81715: PUSH
81716: LD_VAR 0 1
81720: ARRAY
81721: IFFALSE 81776
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81723: LD_ADDR_VAR 0 3
81727: PUSH
81728: LD_EXP 61
81732: PUSH
81733: LD_VAR 0 1
81737: ARRAY
81738: PPUSH
81739: LD_INT 30
81741: PUSH
81742: LD_VAR 0 2
81746: PUSH
81747: EMPTY
81748: LIST
81749: LIST
81750: PPUSH
81751: CALL_OW 72
81755: ST_TO_ADDR
// if result then
81756: LD_VAR 0 3
81760: IFFALSE 81776
// result := result [ 1 ] ;
81762: LD_ADDR_VAR 0 3
81766: PUSH
81767: LD_VAR 0 3
81771: PUSH
81772: LD_INT 1
81774: ARRAY
81775: ST_TO_ADDR
// end ; end ;
81776: LD_VAR 0 3
81780: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81781: LD_INT 0
81783: PPUSH
81784: PPUSH
// if not mc_bases then
81785: LD_EXP 61
81789: NOT
81790: IFFALSE 81794
// exit ;
81792: GO 81839
// if mc_bases [ base ] then
81794: LD_EXP 61
81798: PUSH
81799: LD_VAR 0 1
81803: ARRAY
81804: IFFALSE 81839
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81806: LD_ADDR_VAR 0 3
81810: PUSH
81811: LD_EXP 61
81815: PUSH
81816: LD_VAR 0 1
81820: ARRAY
81821: PPUSH
81822: LD_INT 30
81824: PUSH
81825: LD_VAR 0 2
81829: PUSH
81830: EMPTY
81831: LIST
81832: LIST
81833: PPUSH
81834: CALL_OW 72
81838: ST_TO_ADDR
// end ;
81839: LD_VAR 0 3
81843: RET
// export function MC_SetTame ( base , area ) ; begin
81844: LD_INT 0
81846: PPUSH
// if not mc_bases or not base then
81847: LD_EXP 61
81851: NOT
81852: PUSH
81853: LD_VAR 0 1
81857: NOT
81858: OR
81859: IFFALSE 81863
// exit ;
81861: GO 81888
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81863: LD_ADDR_EXP 89
81867: PUSH
81868: LD_EXP 89
81872: PPUSH
81873: LD_VAR 0 1
81877: PPUSH
81878: LD_VAR 0 2
81882: PPUSH
81883: CALL_OW 1
81887: ST_TO_ADDR
// end ;
81888: LD_VAR 0 3
81892: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81893: LD_INT 0
81895: PPUSH
81896: PPUSH
// if not mc_bases or not base then
81897: LD_EXP 61
81901: NOT
81902: PUSH
81903: LD_VAR 0 1
81907: NOT
81908: OR
81909: IFFALSE 81913
// exit ;
81911: GO 82015
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81913: LD_ADDR_VAR 0 4
81917: PUSH
81918: LD_EXP 61
81922: PUSH
81923: LD_VAR 0 1
81927: ARRAY
81928: PPUSH
81929: LD_INT 30
81931: PUSH
81932: LD_VAR 0 2
81936: PUSH
81937: EMPTY
81938: LIST
81939: LIST
81940: PPUSH
81941: CALL_OW 72
81945: ST_TO_ADDR
// if not tmp then
81946: LD_VAR 0 4
81950: NOT
81951: IFFALSE 81955
// exit ;
81953: GO 82015
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81955: LD_ADDR_EXP 93
81959: PUSH
81960: LD_EXP 93
81964: PPUSH
81965: LD_VAR 0 1
81969: PPUSH
81970: LD_EXP 93
81974: PUSH
81975: LD_VAR 0 1
81979: ARRAY
81980: PPUSH
81981: LD_EXP 93
81985: PUSH
81986: LD_VAR 0 1
81990: ARRAY
81991: PUSH
81992: LD_INT 1
81994: PLUS
81995: PPUSH
81996: LD_VAR 0 4
82000: PUSH
82001: LD_INT 1
82003: ARRAY
82004: PPUSH
82005: CALL_OW 2
82009: PPUSH
82010: CALL_OW 1
82014: ST_TO_ADDR
// end ;
82015: LD_VAR 0 3
82019: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
82020: LD_INT 0
82022: PPUSH
82023: PPUSH
// if not mc_bases or not base or not kinds then
82024: LD_EXP 61
82028: NOT
82029: PUSH
82030: LD_VAR 0 1
82034: NOT
82035: OR
82036: PUSH
82037: LD_VAR 0 2
82041: NOT
82042: OR
82043: IFFALSE 82047
// exit ;
82045: GO 82108
// for i in kinds do
82047: LD_ADDR_VAR 0 4
82051: PUSH
82052: LD_VAR 0 2
82056: PUSH
82057: FOR_IN
82058: IFFALSE 82106
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
82060: LD_ADDR_EXP 95
82064: PUSH
82065: LD_EXP 95
82069: PPUSH
82070: LD_VAR 0 1
82074: PUSH
82075: LD_EXP 95
82079: PUSH
82080: LD_VAR 0 1
82084: ARRAY
82085: PUSH
82086: LD_INT 1
82088: PLUS
82089: PUSH
82090: EMPTY
82091: LIST
82092: LIST
82093: PPUSH
82094: LD_VAR 0 4
82098: PPUSH
82099: CALL 20463 0 3
82103: ST_TO_ADDR
82104: GO 82057
82106: POP
82107: POP
// end ;
82108: LD_VAR 0 3
82112: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
82113: LD_INT 0
82115: PPUSH
// if not mc_bases or not base or not areas then
82116: LD_EXP 61
82120: NOT
82121: PUSH
82122: LD_VAR 0 1
82126: NOT
82127: OR
82128: PUSH
82129: LD_VAR 0 2
82133: NOT
82134: OR
82135: IFFALSE 82139
// exit ;
82137: GO 82164
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
82139: LD_ADDR_EXP 79
82143: PUSH
82144: LD_EXP 79
82148: PPUSH
82149: LD_VAR 0 1
82153: PPUSH
82154: LD_VAR 0 2
82158: PPUSH
82159: CALL_OW 1
82163: ST_TO_ADDR
// end ;
82164: LD_VAR 0 3
82168: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82169: LD_INT 0
82171: PPUSH
// if not mc_bases or not base or not teleports_exit then
82172: LD_EXP 61
82176: NOT
82177: PUSH
82178: LD_VAR 0 1
82182: NOT
82183: OR
82184: PUSH
82185: LD_VAR 0 2
82189: NOT
82190: OR
82191: IFFALSE 82195
// exit ;
82193: GO 82220
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82195: LD_ADDR_EXP 96
82199: PUSH
82200: LD_EXP 96
82204: PPUSH
82205: LD_VAR 0 1
82209: PPUSH
82210: LD_VAR 0 2
82214: PPUSH
82215: CALL_OW 1
82219: ST_TO_ADDR
// end ;
82220: LD_VAR 0 3
82224: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82225: LD_INT 0
82227: PPUSH
82228: PPUSH
82229: PPUSH
// if not mc_bases or not base or not ext_list then
82230: LD_EXP 61
82234: NOT
82235: PUSH
82236: LD_VAR 0 1
82240: NOT
82241: OR
82242: PUSH
82243: LD_VAR 0 5
82247: NOT
82248: OR
82249: IFFALSE 82253
// exit ;
82251: GO 82426
// tmp := GetFacExtXYD ( x , y , d ) ;
82253: LD_ADDR_VAR 0 8
82257: PUSH
82258: LD_VAR 0 2
82262: PPUSH
82263: LD_VAR 0 3
82267: PPUSH
82268: LD_VAR 0 4
82272: PPUSH
82273: CALL 50469 0 3
82277: ST_TO_ADDR
// if not tmp then
82278: LD_VAR 0 8
82282: NOT
82283: IFFALSE 82287
// exit ;
82285: GO 82426
// for i in tmp do
82287: LD_ADDR_VAR 0 7
82291: PUSH
82292: LD_VAR 0 8
82296: PUSH
82297: FOR_IN
82298: IFFALSE 82424
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82300: LD_ADDR_EXP 66
82304: PUSH
82305: LD_EXP 66
82309: PPUSH
82310: LD_VAR 0 1
82314: PPUSH
82315: LD_EXP 66
82319: PUSH
82320: LD_VAR 0 1
82324: ARRAY
82325: PPUSH
82326: LD_EXP 66
82330: PUSH
82331: LD_VAR 0 1
82335: ARRAY
82336: PUSH
82337: LD_INT 1
82339: PLUS
82340: PPUSH
82341: LD_VAR 0 5
82345: PUSH
82346: LD_INT 1
82348: ARRAY
82349: PUSH
82350: LD_VAR 0 7
82354: PUSH
82355: LD_INT 1
82357: ARRAY
82358: PUSH
82359: LD_VAR 0 7
82363: PUSH
82364: LD_INT 2
82366: ARRAY
82367: PUSH
82368: LD_VAR 0 7
82372: PUSH
82373: LD_INT 3
82375: ARRAY
82376: PUSH
82377: EMPTY
82378: LIST
82379: LIST
82380: LIST
82381: LIST
82382: PPUSH
82383: CALL_OW 2
82387: PPUSH
82388: CALL_OW 1
82392: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82393: LD_ADDR_VAR 0 5
82397: PUSH
82398: LD_VAR 0 5
82402: PPUSH
82403: LD_INT 1
82405: PPUSH
82406: CALL_OW 3
82410: ST_TO_ADDR
// if not ext_list then
82411: LD_VAR 0 5
82415: NOT
82416: IFFALSE 82422
// exit ;
82418: POP
82419: POP
82420: GO 82426
// end ;
82422: GO 82297
82424: POP
82425: POP
// end ;
82426: LD_VAR 0 6
82430: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82431: LD_INT 0
82433: PPUSH
// if not mc_bases or not base or not weapon_list then
82434: LD_EXP 61
82438: NOT
82439: PUSH
82440: LD_VAR 0 1
82444: NOT
82445: OR
82446: PUSH
82447: LD_VAR 0 2
82451: NOT
82452: OR
82453: IFFALSE 82457
// exit ;
82455: GO 82482
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82457: LD_ADDR_EXP 100
82461: PUSH
82462: LD_EXP 100
82466: PPUSH
82467: LD_VAR 0 1
82471: PPUSH
82472: LD_VAR 0 2
82476: PPUSH
82477: CALL_OW 1
82481: ST_TO_ADDR
// end ;
82482: LD_VAR 0 3
82486: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82487: LD_INT 0
82489: PPUSH
// if not mc_bases or not base or not tech_list then
82490: LD_EXP 61
82494: NOT
82495: PUSH
82496: LD_VAR 0 1
82500: NOT
82501: OR
82502: PUSH
82503: LD_VAR 0 2
82507: NOT
82508: OR
82509: IFFALSE 82513
// exit ;
82511: GO 82538
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82513: LD_ADDR_EXP 88
82517: PUSH
82518: LD_EXP 88
82522: PPUSH
82523: LD_VAR 0 1
82527: PPUSH
82528: LD_VAR 0 2
82532: PPUSH
82533: CALL_OW 1
82537: ST_TO_ADDR
// end ;
82538: LD_VAR 0 3
82542: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82543: LD_INT 0
82545: PPUSH
// if not mc_bases or not parking_area or not base then
82546: LD_EXP 61
82550: NOT
82551: PUSH
82552: LD_VAR 0 2
82556: NOT
82557: OR
82558: PUSH
82559: LD_VAR 0 1
82563: NOT
82564: OR
82565: IFFALSE 82569
// exit ;
82567: GO 82594
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82569: LD_ADDR_EXP 85
82573: PUSH
82574: LD_EXP 85
82578: PPUSH
82579: LD_VAR 0 1
82583: PPUSH
82584: LD_VAR 0 2
82588: PPUSH
82589: CALL_OW 1
82593: ST_TO_ADDR
// end ;
82594: LD_VAR 0 3
82598: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82599: LD_INT 0
82601: PPUSH
// if not mc_bases or not base or not scan_area then
82602: LD_EXP 61
82606: NOT
82607: PUSH
82608: LD_VAR 0 1
82612: NOT
82613: OR
82614: PUSH
82615: LD_VAR 0 2
82619: NOT
82620: OR
82621: IFFALSE 82625
// exit ;
82623: GO 82650
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82625: LD_ADDR_EXP 86
82629: PUSH
82630: LD_EXP 86
82634: PPUSH
82635: LD_VAR 0 1
82639: PPUSH
82640: LD_VAR 0 2
82644: PPUSH
82645: CALL_OW 1
82649: ST_TO_ADDR
// end ;
82650: LD_VAR 0 3
82654: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82655: LD_INT 0
82657: PPUSH
82658: PPUSH
// if not mc_bases or not base then
82659: LD_EXP 61
82663: NOT
82664: PUSH
82665: LD_VAR 0 1
82669: NOT
82670: OR
82671: IFFALSE 82675
// exit ;
82673: GO 82739
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82675: LD_ADDR_VAR 0 3
82679: PUSH
82680: LD_INT 1
82682: PUSH
82683: LD_INT 2
82685: PUSH
82686: LD_INT 3
82688: PUSH
82689: LD_INT 4
82691: PUSH
82692: LD_INT 11
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82702: LD_ADDR_EXP 88
82706: PUSH
82707: LD_EXP 88
82711: PPUSH
82712: LD_VAR 0 1
82716: PPUSH
82717: LD_EXP 88
82721: PUSH
82722: LD_VAR 0 1
82726: ARRAY
82727: PUSH
82728: LD_VAR 0 3
82732: DIFF
82733: PPUSH
82734: CALL_OW 1
82738: ST_TO_ADDR
// end ;
82739: LD_VAR 0 2
82743: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82744: LD_INT 0
82746: PPUSH
// result := mc_vehicles [ base ] ;
82747: LD_ADDR_VAR 0 3
82751: PUSH
82752: LD_EXP 80
82756: PUSH
82757: LD_VAR 0 1
82761: ARRAY
82762: ST_TO_ADDR
// if onlyCombat then
82763: LD_VAR 0 2
82767: IFFALSE 82939
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82769: LD_ADDR_VAR 0 3
82773: PUSH
82774: LD_VAR 0 3
82778: PUSH
82779: LD_VAR 0 3
82783: PPUSH
82784: LD_INT 2
82786: PUSH
82787: LD_INT 34
82789: PUSH
82790: LD_INT 12
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: PUSH
82797: LD_INT 34
82799: PUSH
82800: LD_INT 51
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: LD_INT 34
82809: PUSH
82810: LD_INT 89
82812: PUSH
82813: EMPTY
82814: LIST
82815: LIST
82816: PUSH
82817: LD_INT 34
82819: PUSH
82820: LD_INT 32
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: PUSH
82827: LD_INT 34
82829: PUSH
82830: LD_INT 13
82832: PUSH
82833: EMPTY
82834: LIST
82835: LIST
82836: PUSH
82837: LD_INT 34
82839: PUSH
82840: LD_INT 52
82842: PUSH
82843: EMPTY
82844: LIST
82845: LIST
82846: PUSH
82847: LD_INT 34
82849: PUSH
82850: LD_INT 88
82852: PUSH
82853: EMPTY
82854: LIST
82855: LIST
82856: PUSH
82857: LD_INT 34
82859: PUSH
82860: LD_INT 14
82862: PUSH
82863: EMPTY
82864: LIST
82865: LIST
82866: PUSH
82867: LD_INT 34
82869: PUSH
82870: LD_INT 53
82872: PUSH
82873: EMPTY
82874: LIST
82875: LIST
82876: PUSH
82877: LD_INT 34
82879: PUSH
82880: LD_INT 98
82882: PUSH
82883: EMPTY
82884: LIST
82885: LIST
82886: PUSH
82887: LD_INT 34
82889: PUSH
82890: LD_INT 31
82892: PUSH
82893: EMPTY
82894: LIST
82895: LIST
82896: PUSH
82897: LD_INT 34
82899: PUSH
82900: LD_INT 48
82902: PUSH
82903: EMPTY
82904: LIST
82905: LIST
82906: PUSH
82907: LD_INT 34
82909: PUSH
82910: LD_INT 8
82912: PUSH
82913: EMPTY
82914: LIST
82915: LIST
82916: PUSH
82917: EMPTY
82918: LIST
82919: LIST
82920: LIST
82921: LIST
82922: LIST
82923: LIST
82924: LIST
82925: LIST
82926: LIST
82927: LIST
82928: LIST
82929: LIST
82930: LIST
82931: LIST
82932: PPUSH
82933: CALL_OW 72
82937: DIFF
82938: ST_TO_ADDR
// end ; end_of_file
82939: LD_VAR 0 3
82943: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82944: LD_INT 0
82946: PPUSH
82947: PPUSH
82948: PPUSH
// if not mc_bases or not skirmish then
82949: LD_EXP 61
82953: NOT
82954: PUSH
82955: LD_EXP 59
82959: NOT
82960: OR
82961: IFFALSE 82965
// exit ;
82963: GO 83130
// for i = 1 to mc_bases do
82965: LD_ADDR_VAR 0 4
82969: PUSH
82970: DOUBLE
82971: LD_INT 1
82973: DEC
82974: ST_TO_ADDR
82975: LD_EXP 61
82979: PUSH
82980: FOR_TO
82981: IFFALSE 83128
// begin if sci in mc_bases [ i ] then
82983: LD_VAR 0 2
82987: PUSH
82988: LD_EXP 61
82992: PUSH
82993: LD_VAR 0 4
82997: ARRAY
82998: IN
82999: IFFALSE 83126
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
83001: LD_ADDR_EXP 90
83005: PUSH
83006: LD_EXP 90
83010: PPUSH
83011: LD_VAR 0 4
83015: PUSH
83016: LD_EXP 90
83020: PUSH
83021: LD_VAR 0 4
83025: ARRAY
83026: PUSH
83027: LD_INT 1
83029: PLUS
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: PPUSH
83035: LD_VAR 0 1
83039: PPUSH
83040: CALL 20463 0 3
83044: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
83045: LD_ADDR_VAR 0 5
83049: PUSH
83050: LD_EXP 61
83054: PUSH
83055: LD_VAR 0 4
83059: ARRAY
83060: PPUSH
83061: LD_INT 2
83063: PUSH
83064: LD_INT 30
83066: PUSH
83067: LD_INT 0
83069: PUSH
83070: EMPTY
83071: LIST
83072: LIST
83073: PUSH
83074: LD_INT 30
83076: PUSH
83077: LD_INT 1
83079: PUSH
83080: EMPTY
83081: LIST
83082: LIST
83083: PUSH
83084: EMPTY
83085: LIST
83086: LIST
83087: LIST
83088: PPUSH
83089: CALL_OW 72
83093: PPUSH
83094: LD_VAR 0 1
83098: PPUSH
83099: CALL_OW 74
83103: ST_TO_ADDR
// if tmp then
83104: LD_VAR 0 5
83108: IFFALSE 83124
// ComStandNearbyBuilding ( ape , tmp ) ;
83110: LD_VAR 0 1
83114: PPUSH
83115: LD_VAR 0 5
83119: PPUSH
83120: CALL 17065 0 2
// break ;
83124: GO 83128
// end ; end ;
83126: GO 82980
83128: POP
83129: POP
// end ;
83130: LD_VAR 0 3
83134: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
83135: LD_INT 0
83137: PPUSH
83138: PPUSH
83139: PPUSH
// if not mc_bases or not skirmish then
83140: LD_EXP 61
83144: NOT
83145: PUSH
83146: LD_EXP 59
83150: NOT
83151: OR
83152: IFFALSE 83156
// exit ;
83154: GO 83245
// for i = 1 to mc_bases do
83156: LD_ADDR_VAR 0 4
83160: PUSH
83161: DOUBLE
83162: LD_INT 1
83164: DEC
83165: ST_TO_ADDR
83166: LD_EXP 61
83170: PUSH
83171: FOR_TO
83172: IFFALSE 83243
// begin if building in mc_busy_turret_list [ i ] then
83174: LD_VAR 0 1
83178: PUSH
83179: LD_EXP 71
83183: PUSH
83184: LD_VAR 0 4
83188: ARRAY
83189: IN
83190: IFFALSE 83241
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83192: LD_ADDR_VAR 0 5
83196: PUSH
83197: LD_EXP 71
83201: PUSH
83202: LD_VAR 0 4
83206: ARRAY
83207: PUSH
83208: LD_VAR 0 1
83212: DIFF
83213: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83214: LD_ADDR_EXP 71
83218: PUSH
83219: LD_EXP 71
83223: PPUSH
83224: LD_VAR 0 4
83228: PPUSH
83229: LD_VAR 0 5
83233: PPUSH
83234: CALL_OW 1
83238: ST_TO_ADDR
// break ;
83239: GO 83243
// end ; end ;
83241: GO 83171
83243: POP
83244: POP
// end ;
83245: LD_VAR 0 3
83249: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83250: LD_INT 0
83252: PPUSH
83253: PPUSH
83254: PPUSH
// if not mc_bases or not skirmish then
83255: LD_EXP 61
83259: NOT
83260: PUSH
83261: LD_EXP 59
83265: NOT
83266: OR
83267: IFFALSE 83271
// exit ;
83269: GO 83470
// for i = 1 to mc_bases do
83271: LD_ADDR_VAR 0 5
83275: PUSH
83276: DOUBLE
83277: LD_INT 1
83279: DEC
83280: ST_TO_ADDR
83281: LD_EXP 61
83285: PUSH
83286: FOR_TO
83287: IFFALSE 83468
// if building in mc_bases [ i ] then
83289: LD_VAR 0 1
83293: PUSH
83294: LD_EXP 61
83298: PUSH
83299: LD_VAR 0 5
83303: ARRAY
83304: IN
83305: IFFALSE 83466
// begin tmp := mc_bases [ i ] diff building ;
83307: LD_ADDR_VAR 0 6
83311: PUSH
83312: LD_EXP 61
83316: PUSH
83317: LD_VAR 0 5
83321: ARRAY
83322: PUSH
83323: LD_VAR 0 1
83327: DIFF
83328: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83329: LD_ADDR_EXP 61
83333: PUSH
83334: LD_EXP 61
83338: PPUSH
83339: LD_VAR 0 5
83343: PPUSH
83344: LD_VAR 0 6
83348: PPUSH
83349: CALL_OW 1
83353: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83354: LD_VAR 0 1
83358: PUSH
83359: LD_EXP 69
83363: PUSH
83364: LD_VAR 0 5
83368: ARRAY
83369: IN
83370: IFFALSE 83409
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83372: LD_ADDR_EXP 69
83376: PUSH
83377: LD_EXP 69
83381: PPUSH
83382: LD_VAR 0 5
83386: PPUSH
83387: LD_EXP 69
83391: PUSH
83392: LD_VAR 0 5
83396: ARRAY
83397: PUSH
83398: LD_VAR 0 1
83402: DIFF
83403: PPUSH
83404: CALL_OW 1
83408: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83409: LD_VAR 0 1
83413: PUSH
83414: LD_EXP 70
83418: PUSH
83419: LD_VAR 0 5
83423: ARRAY
83424: IN
83425: IFFALSE 83464
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83427: LD_ADDR_EXP 70
83431: PUSH
83432: LD_EXP 70
83436: PPUSH
83437: LD_VAR 0 5
83441: PPUSH
83442: LD_EXP 70
83446: PUSH
83447: LD_VAR 0 5
83451: ARRAY
83452: PUSH
83453: LD_VAR 0 1
83457: DIFF
83458: PPUSH
83459: CALL_OW 1
83463: ST_TO_ADDR
// break ;
83464: GO 83468
// end ;
83466: GO 83286
83468: POP
83469: POP
// end ;
83470: LD_VAR 0 4
83474: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83475: LD_INT 0
83477: PPUSH
83478: PPUSH
83479: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83480: LD_EXP 61
83484: NOT
83485: PUSH
83486: LD_EXP 59
83490: NOT
83491: OR
83492: PUSH
83493: LD_VAR 0 3
83497: PUSH
83498: LD_EXP 87
83502: IN
83503: NOT
83504: OR
83505: IFFALSE 83509
// exit ;
83507: GO 83632
// for i = 1 to mc_vehicles do
83509: LD_ADDR_VAR 0 6
83513: PUSH
83514: DOUBLE
83515: LD_INT 1
83517: DEC
83518: ST_TO_ADDR
83519: LD_EXP 80
83523: PUSH
83524: FOR_TO
83525: IFFALSE 83630
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83527: LD_VAR 0 2
83531: PUSH
83532: LD_EXP 80
83536: PUSH
83537: LD_VAR 0 6
83541: ARRAY
83542: IN
83543: PUSH
83544: LD_VAR 0 1
83548: PUSH
83549: LD_EXP 80
83553: PUSH
83554: LD_VAR 0 6
83558: ARRAY
83559: IN
83560: OR
83561: IFFALSE 83628
// begin tmp := mc_vehicles [ i ] diff old ;
83563: LD_ADDR_VAR 0 7
83567: PUSH
83568: LD_EXP 80
83572: PUSH
83573: LD_VAR 0 6
83577: ARRAY
83578: PUSH
83579: LD_VAR 0 2
83583: DIFF
83584: ST_TO_ADDR
// tmp := tmp diff new ;
83585: LD_ADDR_VAR 0 7
83589: PUSH
83590: LD_VAR 0 7
83594: PUSH
83595: LD_VAR 0 1
83599: DIFF
83600: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83601: LD_ADDR_EXP 80
83605: PUSH
83606: LD_EXP 80
83610: PPUSH
83611: LD_VAR 0 6
83615: PPUSH
83616: LD_VAR 0 7
83620: PPUSH
83621: CALL_OW 1
83625: ST_TO_ADDR
// break ;
83626: GO 83630
// end ;
83628: GO 83524
83630: POP
83631: POP
// end ;
83632: LD_VAR 0 5
83636: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83637: LD_INT 0
83639: PPUSH
83640: PPUSH
83641: PPUSH
83642: PPUSH
// if not mc_bases or not skirmish then
83643: LD_EXP 61
83647: NOT
83648: PUSH
83649: LD_EXP 59
83653: NOT
83654: OR
83655: IFFALSE 83659
// exit ;
83657: GO 84079
// repeat wait ( 0 0$1 ) ;
83659: LD_INT 35
83661: PPUSH
83662: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
83666: LD_EXP 105
83670: NOT
83671: IFFALSE 83659
// mc_block_vehicle_constructed_thread := true ;
83673: LD_ADDR_EXP 105
83677: PUSH
83678: LD_INT 1
83680: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
83681: LD_ADDR_VAR 0 5
83685: PUSH
83686: LD_VAR 0 1
83690: PPUSH
83691: CALL_OW 255
83695: ST_TO_ADDR
// for i = 1 to mc_bases do
83696: LD_ADDR_VAR 0 4
83700: PUSH
83701: DOUBLE
83702: LD_INT 1
83704: DEC
83705: ST_TO_ADDR
83706: LD_EXP 61
83710: PUSH
83711: FOR_TO
83712: IFFALSE 84069
// begin if factory in mc_bases [ i ] then
83714: LD_VAR 0 2
83718: PUSH
83719: LD_EXP 61
83723: PUSH
83724: LD_VAR 0 4
83728: ARRAY
83729: IN
83730: IFFALSE 84067
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
83732: LD_EXP 83
83736: PUSH
83737: LD_VAR 0 4
83741: ARRAY
83742: PUSH
83743: LD_EXP 72
83747: PUSH
83748: LD_VAR 0 4
83752: ARRAY
83753: LESS
83754: PUSH
83755: LD_VAR 0 1
83759: PPUSH
83760: CALL_OW 264
83764: PUSH
83765: LD_INT 31
83767: PUSH
83768: LD_INT 32
83770: PUSH
83771: LD_INT 51
83773: PUSH
83774: LD_INT 89
83776: PUSH
83777: LD_INT 12
83779: PUSH
83780: LD_INT 30
83782: PUSH
83783: LD_INT 98
83785: PUSH
83786: LD_INT 11
83788: PUSH
83789: LD_INT 53
83791: PUSH
83792: LD_INT 14
83794: PUSH
83795: LD_INT 91
83797: PUSH
83798: LD_INT 29
83800: PUSH
83801: LD_INT 99
83803: PUSH
83804: LD_INT 13
83806: PUSH
83807: LD_INT 52
83809: PUSH
83810: LD_INT 88
83812: PUSH
83813: LD_INT 48
83815: PUSH
83816: LD_INT 8
83818: PUSH
83819: EMPTY
83820: LIST
83821: LIST
83822: LIST
83823: LIST
83824: LIST
83825: LIST
83826: LIST
83827: LIST
83828: LIST
83829: LIST
83830: LIST
83831: LIST
83832: LIST
83833: LIST
83834: LIST
83835: LIST
83836: LIST
83837: LIST
83838: IN
83839: NOT
83840: AND
83841: IFFALSE 83889
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83843: LD_ADDR_EXP 83
83847: PUSH
83848: LD_EXP 83
83852: PPUSH
83853: LD_VAR 0 4
83857: PUSH
83858: LD_EXP 83
83862: PUSH
83863: LD_VAR 0 4
83867: ARRAY
83868: PUSH
83869: LD_INT 1
83871: PLUS
83872: PUSH
83873: EMPTY
83874: LIST
83875: LIST
83876: PPUSH
83877: LD_VAR 0 1
83881: PPUSH
83882: CALL 20463 0 3
83886: ST_TO_ADDR
83887: GO 83933
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83889: LD_ADDR_EXP 80
83893: PUSH
83894: LD_EXP 80
83898: PPUSH
83899: LD_VAR 0 4
83903: PUSH
83904: LD_EXP 80
83908: PUSH
83909: LD_VAR 0 4
83913: ARRAY
83914: PUSH
83915: LD_INT 1
83917: PLUS
83918: PUSH
83919: EMPTY
83920: LIST
83921: LIST
83922: PPUSH
83923: LD_VAR 0 1
83927: PPUSH
83928: CALL 20463 0 3
83932: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
83933: LD_ADDR_EXP 105
83937: PUSH
83938: LD_INT 0
83940: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83941: LD_VAR 0 1
83945: PPUSH
83946: CALL_OW 263
83950: PUSH
83951: LD_INT 2
83953: EQUAL
83954: IFFALSE 83983
// begin repeat wait ( 0 0$3 ) ;
83956: LD_INT 105
83958: PPUSH
83959: CALL_OW 67
// Connect ( vehicle ) ;
83963: LD_VAR 0 1
83967: PPUSH
83968: CALL 23441 0 1
// until IsControledBy ( vehicle ) ;
83972: LD_VAR 0 1
83976: PPUSH
83977: CALL_OW 312
83981: IFFALSE 83956
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83983: LD_VAR 0 1
83987: PPUSH
83988: LD_EXP 85
83992: PUSH
83993: LD_VAR 0 4
83997: ARRAY
83998: PPUSH
83999: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
84003: LD_VAR 0 1
84007: PPUSH
84008: CALL_OW 263
84012: PUSH
84013: LD_INT 1
84015: NONEQUAL
84016: IFFALSE 84020
// break ;
84018: GO 84069
// repeat wait ( 0 0$1 ) ;
84020: LD_INT 35
84022: PPUSH
84023: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
84027: LD_VAR 0 1
84031: PPUSH
84032: LD_EXP 85
84036: PUSH
84037: LD_VAR 0 4
84041: ARRAY
84042: PPUSH
84043: CALL_OW 308
84047: IFFALSE 84020
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
84049: LD_VAR 0 1
84053: PPUSH
84054: CALL_OW 311
84058: PPUSH
84059: CALL_OW 121
// exit ;
84063: POP
84064: POP
84065: GO 84079
// end ; end ;
84067: GO 83711
84069: POP
84070: POP
// mc_block_vehicle_constructed_thread := false ;
84071: LD_ADDR_EXP 105
84075: PUSH
84076: LD_INT 0
84078: ST_TO_ADDR
// end ;
84079: LD_VAR 0 3
84083: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
84084: LD_INT 0
84086: PPUSH
84087: PPUSH
84088: PPUSH
84089: PPUSH
// if not mc_bases or not skirmish then
84090: LD_EXP 61
84094: NOT
84095: PUSH
84096: LD_EXP 59
84100: NOT
84101: OR
84102: IFFALSE 84106
// exit ;
84104: GO 84459
// repeat wait ( 0 0$1 ) ;
84106: LD_INT 35
84108: PPUSH
84109: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
84113: LD_VAR 0 2
84117: PPUSH
84118: LD_VAR 0 3
84122: PPUSH
84123: CALL_OW 284
84127: IFFALSE 84106
// if GetResourceTypeXY ( x , y ) = mat_artefact then
84129: LD_VAR 0 2
84133: PPUSH
84134: LD_VAR 0 3
84138: PPUSH
84139: CALL_OW 283
84143: PUSH
84144: LD_INT 4
84146: EQUAL
84147: IFFALSE 84151
// exit ;
84149: GO 84459
// for i = 1 to mc_bases do
84151: LD_ADDR_VAR 0 7
84155: PUSH
84156: DOUBLE
84157: LD_INT 1
84159: DEC
84160: ST_TO_ADDR
84161: LD_EXP 61
84165: PUSH
84166: FOR_TO
84167: IFFALSE 84457
// begin if mc_crates_area [ i ] then
84169: LD_EXP 79
84173: PUSH
84174: LD_VAR 0 7
84178: ARRAY
84179: IFFALSE 84290
// for j in mc_crates_area [ i ] do
84181: LD_ADDR_VAR 0 8
84185: PUSH
84186: LD_EXP 79
84190: PUSH
84191: LD_VAR 0 7
84195: ARRAY
84196: PUSH
84197: FOR_IN
84198: IFFALSE 84288
// if InArea ( x , y , j ) then
84200: LD_VAR 0 2
84204: PPUSH
84205: LD_VAR 0 3
84209: PPUSH
84210: LD_VAR 0 8
84214: PPUSH
84215: CALL_OW 309
84219: IFFALSE 84286
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84221: LD_ADDR_EXP 77
84225: PUSH
84226: LD_EXP 77
84230: PPUSH
84231: LD_VAR 0 7
84235: PUSH
84236: LD_EXP 77
84240: PUSH
84241: LD_VAR 0 7
84245: ARRAY
84246: PUSH
84247: LD_INT 1
84249: PLUS
84250: PUSH
84251: EMPTY
84252: LIST
84253: LIST
84254: PPUSH
84255: LD_VAR 0 4
84259: PUSH
84260: LD_VAR 0 2
84264: PUSH
84265: LD_VAR 0 3
84269: PUSH
84270: EMPTY
84271: LIST
84272: LIST
84273: LIST
84274: PPUSH
84275: CALL 20463 0 3
84279: ST_TO_ADDR
// exit ;
84280: POP
84281: POP
84282: POP
84283: POP
84284: GO 84459
// end ;
84286: GO 84197
84288: POP
84289: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84290: LD_ADDR_VAR 0 9
84294: PUSH
84295: LD_EXP 61
84299: PUSH
84300: LD_VAR 0 7
84304: ARRAY
84305: PPUSH
84306: LD_INT 2
84308: PUSH
84309: LD_INT 30
84311: PUSH
84312: LD_INT 0
84314: PUSH
84315: EMPTY
84316: LIST
84317: LIST
84318: PUSH
84319: LD_INT 30
84321: PUSH
84322: LD_INT 1
84324: PUSH
84325: EMPTY
84326: LIST
84327: LIST
84328: PUSH
84329: EMPTY
84330: LIST
84331: LIST
84332: LIST
84333: PPUSH
84334: CALL_OW 72
84338: ST_TO_ADDR
// if not depot then
84339: LD_VAR 0 9
84343: NOT
84344: IFFALSE 84348
// continue ;
84346: GO 84166
// for j in depot do
84348: LD_ADDR_VAR 0 8
84352: PUSH
84353: LD_VAR 0 9
84357: PUSH
84358: FOR_IN
84359: IFFALSE 84453
// if GetDistUnitXY ( j , x , y ) < 30 then
84361: LD_VAR 0 8
84365: PPUSH
84366: LD_VAR 0 2
84370: PPUSH
84371: LD_VAR 0 3
84375: PPUSH
84376: CALL_OW 297
84380: PUSH
84381: LD_INT 30
84383: LESS
84384: IFFALSE 84451
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84386: LD_ADDR_EXP 77
84390: PUSH
84391: LD_EXP 77
84395: PPUSH
84396: LD_VAR 0 7
84400: PUSH
84401: LD_EXP 77
84405: PUSH
84406: LD_VAR 0 7
84410: ARRAY
84411: PUSH
84412: LD_INT 1
84414: PLUS
84415: PUSH
84416: EMPTY
84417: LIST
84418: LIST
84419: PPUSH
84420: LD_VAR 0 4
84424: PUSH
84425: LD_VAR 0 2
84429: PUSH
84430: LD_VAR 0 3
84434: PUSH
84435: EMPTY
84436: LIST
84437: LIST
84438: LIST
84439: PPUSH
84440: CALL 20463 0 3
84444: ST_TO_ADDR
// exit ;
84445: POP
84446: POP
84447: POP
84448: POP
84449: GO 84459
// end ;
84451: GO 84358
84453: POP
84454: POP
// end ;
84455: GO 84166
84457: POP
84458: POP
// end ;
84459: LD_VAR 0 6
84463: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84464: LD_INT 0
84466: PPUSH
84467: PPUSH
84468: PPUSH
84469: PPUSH
// if not mc_bases or not skirmish then
84470: LD_EXP 61
84474: NOT
84475: PUSH
84476: LD_EXP 59
84480: NOT
84481: OR
84482: IFFALSE 84486
// exit ;
84484: GO 84763
// side := GetSide ( lab ) ;
84486: LD_ADDR_VAR 0 4
84490: PUSH
84491: LD_VAR 0 2
84495: PPUSH
84496: CALL_OW 255
84500: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84501: LD_VAR 0 4
84505: PUSH
84506: LD_EXP 87
84510: IN
84511: NOT
84512: PUSH
84513: LD_EXP 88
84517: NOT
84518: OR
84519: PUSH
84520: LD_EXP 61
84524: NOT
84525: OR
84526: IFFALSE 84530
// exit ;
84528: GO 84763
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84530: LD_ADDR_EXP 88
84534: PUSH
84535: LD_EXP 88
84539: PPUSH
84540: LD_VAR 0 4
84544: PPUSH
84545: LD_EXP 88
84549: PUSH
84550: LD_VAR 0 4
84554: ARRAY
84555: PUSH
84556: LD_VAR 0 1
84560: DIFF
84561: PPUSH
84562: CALL_OW 1
84566: ST_TO_ADDR
// for i = 1 to mc_bases do
84567: LD_ADDR_VAR 0 5
84571: PUSH
84572: DOUBLE
84573: LD_INT 1
84575: DEC
84576: ST_TO_ADDR
84577: LD_EXP 61
84581: PUSH
84582: FOR_TO
84583: IFFALSE 84761
// begin if lab in mc_bases [ i ] then
84585: LD_VAR 0 2
84589: PUSH
84590: LD_EXP 61
84594: PUSH
84595: LD_VAR 0 5
84599: ARRAY
84600: IN
84601: IFFALSE 84759
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84603: LD_VAR 0 1
84607: PUSH
84608: LD_INT 11
84610: PUSH
84611: LD_INT 4
84613: PUSH
84614: LD_INT 3
84616: PUSH
84617: LD_INT 2
84619: PUSH
84620: EMPTY
84621: LIST
84622: LIST
84623: LIST
84624: LIST
84625: IN
84626: PUSH
84627: LD_EXP 91
84631: PUSH
84632: LD_VAR 0 5
84636: ARRAY
84637: AND
84638: IFFALSE 84759
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84640: LD_ADDR_VAR 0 6
84644: PUSH
84645: LD_EXP 91
84649: PUSH
84650: LD_VAR 0 5
84654: ARRAY
84655: PUSH
84656: LD_INT 1
84658: ARRAY
84659: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84660: LD_ADDR_EXP 91
84664: PUSH
84665: LD_EXP 91
84669: PPUSH
84670: LD_VAR 0 5
84674: PPUSH
84675: EMPTY
84676: PPUSH
84677: CALL_OW 1
84681: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84682: LD_VAR 0 6
84686: PPUSH
84687: LD_INT 0
84689: PPUSH
84690: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84694: LD_VAR 0 6
84698: PPUSH
84699: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84703: LD_ADDR_EXP 90
84707: PUSH
84708: LD_EXP 90
84712: PPUSH
84713: LD_VAR 0 5
84717: PPUSH
84718: LD_EXP 90
84722: PUSH
84723: LD_VAR 0 5
84727: ARRAY
84728: PPUSH
84729: LD_INT 1
84731: PPUSH
84732: LD_VAR 0 6
84736: PPUSH
84737: CALL_OW 2
84741: PPUSH
84742: CALL_OW 1
84746: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84747: LD_VAR 0 5
84751: PPUSH
84752: LD_INT 112
84754: PPUSH
84755: CALL 61213 0 2
// end ; end ; end ;
84759: GO 84582
84761: POP
84762: POP
// end ;
84763: LD_VAR 0 3
84767: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84768: LD_INT 0
84770: PPUSH
84771: PPUSH
84772: PPUSH
84773: PPUSH
84774: PPUSH
84775: PPUSH
84776: PPUSH
84777: PPUSH
// if not mc_bases or not skirmish then
84778: LD_EXP 61
84782: NOT
84783: PUSH
84784: LD_EXP 59
84788: NOT
84789: OR
84790: IFFALSE 84794
// exit ;
84792: GO 86163
// for i = 1 to mc_bases do
84794: LD_ADDR_VAR 0 3
84798: PUSH
84799: DOUBLE
84800: LD_INT 1
84802: DEC
84803: ST_TO_ADDR
84804: LD_EXP 61
84808: PUSH
84809: FOR_TO
84810: IFFALSE 86161
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84812: LD_VAR 0 1
84816: PUSH
84817: LD_EXP 61
84821: PUSH
84822: LD_VAR 0 3
84826: ARRAY
84827: IN
84828: PUSH
84829: LD_VAR 0 1
84833: PUSH
84834: LD_EXP 68
84838: PUSH
84839: LD_VAR 0 3
84843: ARRAY
84844: IN
84845: OR
84846: PUSH
84847: LD_VAR 0 1
84851: PUSH
84852: LD_EXP 83
84856: PUSH
84857: LD_VAR 0 3
84861: ARRAY
84862: IN
84863: OR
84864: PUSH
84865: LD_VAR 0 1
84869: PUSH
84870: LD_EXP 80
84874: PUSH
84875: LD_VAR 0 3
84879: ARRAY
84880: IN
84881: OR
84882: PUSH
84883: LD_VAR 0 1
84887: PUSH
84888: LD_EXP 90
84892: PUSH
84893: LD_VAR 0 3
84897: ARRAY
84898: IN
84899: OR
84900: PUSH
84901: LD_VAR 0 1
84905: PUSH
84906: LD_EXP 91
84910: PUSH
84911: LD_VAR 0 3
84915: ARRAY
84916: IN
84917: OR
84918: IFFALSE 86159
// begin if un in mc_ape [ i ] then
84920: LD_VAR 0 1
84924: PUSH
84925: LD_EXP 90
84929: PUSH
84930: LD_VAR 0 3
84934: ARRAY
84935: IN
84936: IFFALSE 84975
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84938: LD_ADDR_EXP 90
84942: PUSH
84943: LD_EXP 90
84947: PPUSH
84948: LD_VAR 0 3
84952: PPUSH
84953: LD_EXP 90
84957: PUSH
84958: LD_VAR 0 3
84962: ARRAY
84963: PUSH
84964: LD_VAR 0 1
84968: DIFF
84969: PPUSH
84970: CALL_OW 1
84974: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84975: LD_VAR 0 1
84979: PUSH
84980: LD_EXP 91
84984: PUSH
84985: LD_VAR 0 3
84989: ARRAY
84990: IN
84991: IFFALSE 85015
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84993: LD_ADDR_EXP 91
84997: PUSH
84998: LD_EXP 91
85002: PPUSH
85003: LD_VAR 0 3
85007: PPUSH
85008: EMPTY
85009: PPUSH
85010: CALL_OW 1
85014: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
85015: LD_VAR 0 1
85019: PPUSH
85020: CALL_OW 247
85024: PUSH
85025: LD_INT 2
85027: EQUAL
85028: PUSH
85029: LD_VAR 0 1
85033: PPUSH
85034: CALL_OW 110
85038: PUSH
85039: LD_INT 20
85041: EQUAL
85042: PUSH
85043: LD_VAR 0 1
85047: PUSH
85048: LD_EXP 83
85052: PUSH
85053: LD_VAR 0 3
85057: ARRAY
85058: IN
85059: OR
85060: PUSH
85061: LD_VAR 0 1
85065: PPUSH
85066: CALL_OW 264
85070: PUSH
85071: LD_INT 12
85073: PUSH
85074: LD_INT 51
85076: PUSH
85077: LD_INT 89
85079: PUSH
85080: LD_INT 32
85082: PUSH
85083: LD_INT 13
85085: PUSH
85086: LD_INT 52
85088: PUSH
85089: LD_INT 31
85091: PUSH
85092: EMPTY
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: IN
85101: OR
85102: AND
85103: IFFALSE 85411
// begin if un in mc_defender [ i ] then
85105: LD_VAR 0 1
85109: PUSH
85110: LD_EXP 83
85114: PUSH
85115: LD_VAR 0 3
85119: ARRAY
85120: IN
85121: IFFALSE 85160
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85123: LD_ADDR_EXP 83
85127: PUSH
85128: LD_EXP 83
85132: PPUSH
85133: LD_VAR 0 3
85137: PPUSH
85138: LD_EXP 83
85142: PUSH
85143: LD_VAR 0 3
85147: ARRAY
85148: PUSH
85149: LD_VAR 0 1
85153: DIFF
85154: PPUSH
85155: CALL_OW 1
85159: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
85160: LD_ADDR_VAR 0 8
85164: PUSH
85165: LD_VAR 0 3
85169: PPUSH
85170: LD_INT 3
85172: PPUSH
85173: CALL 81781 0 2
85177: ST_TO_ADDR
// if fac then
85178: LD_VAR 0 8
85182: IFFALSE 85411
// begin for j in fac do
85184: LD_ADDR_VAR 0 4
85188: PUSH
85189: LD_VAR 0 8
85193: PUSH
85194: FOR_IN
85195: IFFALSE 85409
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
85197: LD_ADDR_VAR 0 9
85201: PUSH
85202: LD_VAR 0 8
85206: PPUSH
85207: LD_VAR 0 1
85211: PPUSH
85212: CALL_OW 265
85216: PPUSH
85217: LD_VAR 0 1
85221: PPUSH
85222: CALL_OW 262
85226: PPUSH
85227: LD_VAR 0 1
85231: PPUSH
85232: CALL_OW 263
85236: PPUSH
85237: LD_VAR 0 1
85241: PPUSH
85242: CALL_OW 264
85246: PPUSH
85247: CALL 17961 0 5
85251: ST_TO_ADDR
// if components then
85252: LD_VAR 0 9
85256: IFFALSE 85407
// begin if GetWeapon ( un ) = ar_control_tower then
85258: LD_VAR 0 1
85262: PPUSH
85263: CALL_OW 264
85267: PUSH
85268: LD_INT 31
85270: EQUAL
85271: IFFALSE 85388
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85273: LD_VAR 0 1
85277: PPUSH
85278: CALL_OW 311
85282: PPUSH
85283: LD_INT 0
85285: PPUSH
85286: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85290: LD_ADDR_EXP 101
85294: PUSH
85295: LD_EXP 101
85299: PPUSH
85300: LD_VAR 0 3
85304: PPUSH
85305: LD_EXP 101
85309: PUSH
85310: LD_VAR 0 3
85314: ARRAY
85315: PUSH
85316: LD_VAR 0 1
85320: PPUSH
85321: CALL_OW 311
85325: DIFF
85326: PPUSH
85327: CALL_OW 1
85331: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85332: LD_ADDR_VAR 0 7
85336: PUSH
85337: LD_EXP 82
85341: PUSH
85342: LD_VAR 0 3
85346: ARRAY
85347: PPUSH
85348: LD_INT 1
85350: PPUSH
85351: LD_VAR 0 9
85355: PPUSH
85356: CALL_OW 2
85360: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85361: LD_ADDR_EXP 82
85365: PUSH
85366: LD_EXP 82
85370: PPUSH
85371: LD_VAR 0 3
85375: PPUSH
85376: LD_VAR 0 7
85380: PPUSH
85381: CALL_OW 1
85385: ST_TO_ADDR
// end else
85386: GO 85405
// MC_InsertProduceList ( i , [ components ] ) ;
85388: LD_VAR 0 3
85392: PPUSH
85393: LD_VAR 0 9
85397: PUSH
85398: EMPTY
85399: LIST
85400: PPUSH
85401: CALL 81326 0 2
// break ;
85405: GO 85409
// end ; end ;
85407: GO 85194
85409: POP
85410: POP
// end ; end ; if GetType ( un ) = unit_building then
85411: LD_VAR 0 1
85415: PPUSH
85416: CALL_OW 247
85420: PUSH
85421: LD_INT 3
85423: EQUAL
85424: IFFALSE 85827
// begin btype := GetBType ( un ) ;
85426: LD_ADDR_VAR 0 5
85430: PUSH
85431: LD_VAR 0 1
85435: PPUSH
85436: CALL_OW 266
85440: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85441: LD_VAR 0 5
85445: PUSH
85446: LD_INT 29
85448: PUSH
85449: LD_INT 30
85451: PUSH
85452: EMPTY
85453: LIST
85454: LIST
85455: IN
85456: IFFALSE 85529
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85458: LD_VAR 0 1
85462: PPUSH
85463: CALL_OW 250
85467: PPUSH
85468: LD_VAR 0 1
85472: PPUSH
85473: CALL_OW 251
85477: PPUSH
85478: LD_VAR 0 1
85482: PPUSH
85483: CALL_OW 255
85487: PPUSH
85488: CALL_OW 440
85492: NOT
85493: IFFALSE 85529
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85495: LD_VAR 0 1
85499: PPUSH
85500: CALL_OW 250
85504: PPUSH
85505: LD_VAR 0 1
85509: PPUSH
85510: CALL_OW 251
85514: PPUSH
85515: LD_VAR 0 1
85519: PPUSH
85520: CALL_OW 255
85524: PPUSH
85525: CALL_OW 441
// end ; if btype = b_warehouse then
85529: LD_VAR 0 5
85533: PUSH
85534: LD_INT 1
85536: EQUAL
85537: IFFALSE 85555
// begin btype := b_depot ;
85539: LD_ADDR_VAR 0 5
85543: PUSH
85544: LD_INT 0
85546: ST_TO_ADDR
// pos := 1 ;
85547: LD_ADDR_VAR 0 6
85551: PUSH
85552: LD_INT 1
85554: ST_TO_ADDR
// end ; if btype = b_factory then
85555: LD_VAR 0 5
85559: PUSH
85560: LD_INT 3
85562: EQUAL
85563: IFFALSE 85581
// begin btype := b_workshop ;
85565: LD_ADDR_VAR 0 5
85569: PUSH
85570: LD_INT 2
85572: ST_TO_ADDR
// pos := 1 ;
85573: LD_ADDR_VAR 0 6
85577: PUSH
85578: LD_INT 1
85580: ST_TO_ADDR
// end ; if btype = b_barracks then
85581: LD_VAR 0 5
85585: PUSH
85586: LD_INT 5
85588: EQUAL
85589: IFFALSE 85599
// btype := b_armoury ;
85591: LD_ADDR_VAR 0 5
85595: PUSH
85596: LD_INT 4
85598: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85599: LD_VAR 0 5
85603: PUSH
85604: LD_INT 7
85606: PUSH
85607: LD_INT 8
85609: PUSH
85610: EMPTY
85611: LIST
85612: LIST
85613: IN
85614: IFFALSE 85624
// btype := b_lab ;
85616: LD_ADDR_VAR 0 5
85620: PUSH
85621: LD_INT 6
85623: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85624: LD_ADDR_EXP 66
85628: PUSH
85629: LD_EXP 66
85633: PPUSH
85634: LD_VAR 0 3
85638: PUSH
85639: LD_EXP 66
85643: PUSH
85644: LD_VAR 0 3
85648: ARRAY
85649: PUSH
85650: LD_INT 1
85652: PLUS
85653: PUSH
85654: EMPTY
85655: LIST
85656: LIST
85657: PPUSH
85658: LD_VAR 0 5
85662: PUSH
85663: LD_VAR 0 1
85667: PPUSH
85668: CALL_OW 250
85672: PUSH
85673: LD_VAR 0 1
85677: PPUSH
85678: CALL_OW 251
85682: PUSH
85683: LD_VAR 0 1
85687: PPUSH
85688: CALL_OW 254
85692: PUSH
85693: EMPTY
85694: LIST
85695: LIST
85696: LIST
85697: LIST
85698: PPUSH
85699: CALL 20463 0 3
85703: ST_TO_ADDR
// if pos = 1 then
85704: LD_VAR 0 6
85708: PUSH
85709: LD_INT 1
85711: EQUAL
85712: IFFALSE 85827
// begin tmp := mc_build_list [ i ] ;
85714: LD_ADDR_VAR 0 7
85718: PUSH
85719: LD_EXP 66
85723: PUSH
85724: LD_VAR 0 3
85728: ARRAY
85729: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85730: LD_VAR 0 7
85734: PPUSH
85735: LD_INT 2
85737: PUSH
85738: LD_INT 30
85740: PUSH
85741: LD_INT 0
85743: PUSH
85744: EMPTY
85745: LIST
85746: LIST
85747: PUSH
85748: LD_INT 30
85750: PUSH
85751: LD_INT 1
85753: PUSH
85754: EMPTY
85755: LIST
85756: LIST
85757: PUSH
85758: EMPTY
85759: LIST
85760: LIST
85761: LIST
85762: PPUSH
85763: CALL_OW 72
85767: IFFALSE 85777
// pos := 2 ;
85769: LD_ADDR_VAR 0 6
85773: PUSH
85774: LD_INT 2
85776: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85777: LD_ADDR_VAR 0 7
85781: PUSH
85782: LD_VAR 0 7
85786: PPUSH
85787: LD_VAR 0 6
85791: PPUSH
85792: LD_VAR 0 7
85796: PPUSH
85797: CALL 20789 0 3
85801: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85802: LD_ADDR_EXP 66
85806: PUSH
85807: LD_EXP 66
85811: PPUSH
85812: LD_VAR 0 3
85816: PPUSH
85817: LD_VAR 0 7
85821: PPUSH
85822: CALL_OW 1
85826: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85827: LD_VAR 0 1
85831: PUSH
85832: LD_EXP 61
85836: PUSH
85837: LD_VAR 0 3
85841: ARRAY
85842: IN
85843: IFFALSE 85882
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85845: LD_ADDR_EXP 61
85849: PUSH
85850: LD_EXP 61
85854: PPUSH
85855: LD_VAR 0 3
85859: PPUSH
85860: LD_EXP 61
85864: PUSH
85865: LD_VAR 0 3
85869: ARRAY
85870: PUSH
85871: LD_VAR 0 1
85875: DIFF
85876: PPUSH
85877: CALL_OW 1
85881: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85882: LD_VAR 0 1
85886: PUSH
85887: LD_EXP 68
85891: PUSH
85892: LD_VAR 0 3
85896: ARRAY
85897: IN
85898: IFFALSE 85937
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85900: LD_ADDR_EXP 68
85904: PUSH
85905: LD_EXP 68
85909: PPUSH
85910: LD_VAR 0 3
85914: PPUSH
85915: LD_EXP 68
85919: PUSH
85920: LD_VAR 0 3
85924: ARRAY
85925: PUSH
85926: LD_VAR 0 1
85930: DIFF
85931: PPUSH
85932: CALL_OW 1
85936: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85937: LD_VAR 0 1
85941: PUSH
85942: LD_EXP 80
85946: PUSH
85947: LD_VAR 0 3
85951: ARRAY
85952: IN
85953: IFFALSE 85992
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85955: LD_ADDR_EXP 80
85959: PUSH
85960: LD_EXP 80
85964: PPUSH
85965: LD_VAR 0 3
85969: PPUSH
85970: LD_EXP 80
85974: PUSH
85975: LD_VAR 0 3
85979: ARRAY
85980: PUSH
85981: LD_VAR 0 1
85985: DIFF
85986: PPUSH
85987: CALL_OW 1
85991: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85992: LD_VAR 0 1
85996: PUSH
85997: LD_EXP 83
86001: PUSH
86002: LD_VAR 0 3
86006: ARRAY
86007: IN
86008: IFFALSE 86047
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
86010: LD_ADDR_EXP 83
86014: PUSH
86015: LD_EXP 83
86019: PPUSH
86020: LD_VAR 0 3
86024: PPUSH
86025: LD_EXP 83
86029: PUSH
86030: LD_VAR 0 3
86034: ARRAY
86035: PUSH
86036: LD_VAR 0 1
86040: DIFF
86041: PPUSH
86042: CALL_OW 1
86046: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
86047: LD_VAR 0 1
86051: PUSH
86052: LD_EXP 70
86056: PUSH
86057: LD_VAR 0 3
86061: ARRAY
86062: IN
86063: IFFALSE 86102
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
86065: LD_ADDR_EXP 70
86069: PUSH
86070: LD_EXP 70
86074: PPUSH
86075: LD_VAR 0 3
86079: PPUSH
86080: LD_EXP 70
86084: PUSH
86085: LD_VAR 0 3
86089: ARRAY
86090: PUSH
86091: LD_VAR 0 1
86095: DIFF
86096: PPUSH
86097: CALL_OW 1
86101: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
86102: LD_VAR 0 1
86106: PUSH
86107: LD_EXP 69
86111: PUSH
86112: LD_VAR 0 3
86116: ARRAY
86117: IN
86118: IFFALSE 86157
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
86120: LD_ADDR_EXP 69
86124: PUSH
86125: LD_EXP 69
86129: PPUSH
86130: LD_VAR 0 3
86134: PPUSH
86135: LD_EXP 69
86139: PUSH
86140: LD_VAR 0 3
86144: ARRAY
86145: PUSH
86146: LD_VAR 0 1
86150: DIFF
86151: PPUSH
86152: CALL_OW 1
86156: ST_TO_ADDR
// end ; break ;
86157: GO 86161
// end ;
86159: GO 84809
86161: POP
86162: POP
// end ;
86163: LD_VAR 0 2
86167: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
86168: LD_INT 0
86170: PPUSH
86171: PPUSH
86172: PPUSH
// if not mc_bases or not skirmish then
86173: LD_EXP 61
86177: NOT
86178: PUSH
86179: LD_EXP 59
86183: NOT
86184: OR
86185: IFFALSE 86189
// exit ;
86187: GO 86404
// for i = 1 to mc_bases do
86189: LD_ADDR_VAR 0 3
86193: PUSH
86194: DOUBLE
86195: LD_INT 1
86197: DEC
86198: ST_TO_ADDR
86199: LD_EXP 61
86203: PUSH
86204: FOR_TO
86205: IFFALSE 86402
// begin if building in mc_construct_list [ i ] then
86207: LD_VAR 0 1
86211: PUSH
86212: LD_EXP 68
86216: PUSH
86217: LD_VAR 0 3
86221: ARRAY
86222: IN
86223: IFFALSE 86400
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86225: LD_ADDR_EXP 68
86229: PUSH
86230: LD_EXP 68
86234: PPUSH
86235: LD_VAR 0 3
86239: PPUSH
86240: LD_EXP 68
86244: PUSH
86245: LD_VAR 0 3
86249: ARRAY
86250: PUSH
86251: LD_VAR 0 1
86255: DIFF
86256: PPUSH
86257: CALL_OW 1
86261: ST_TO_ADDR
// if building in mc_lab [ i ] then
86262: LD_VAR 0 1
86266: PUSH
86267: LD_EXP 94
86271: PUSH
86272: LD_VAR 0 3
86276: ARRAY
86277: IN
86278: IFFALSE 86333
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86280: LD_ADDR_EXP 95
86284: PUSH
86285: LD_EXP 95
86289: PPUSH
86290: LD_VAR 0 3
86294: PPUSH
86295: LD_EXP 95
86299: PUSH
86300: LD_VAR 0 3
86304: ARRAY
86305: PPUSH
86306: LD_INT 1
86308: PPUSH
86309: LD_EXP 95
86313: PUSH
86314: LD_VAR 0 3
86318: ARRAY
86319: PPUSH
86320: LD_INT 0
86322: PPUSH
86323: CALL 19881 0 4
86327: PPUSH
86328: CALL_OW 1
86332: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86333: LD_VAR 0 1
86337: PUSH
86338: LD_EXP 61
86342: PUSH
86343: LD_VAR 0 3
86347: ARRAY
86348: IN
86349: NOT
86350: IFFALSE 86396
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86352: LD_ADDR_EXP 61
86356: PUSH
86357: LD_EXP 61
86361: PPUSH
86362: LD_VAR 0 3
86366: PUSH
86367: LD_EXP 61
86371: PUSH
86372: LD_VAR 0 3
86376: ARRAY
86377: PUSH
86378: LD_INT 1
86380: PLUS
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: PPUSH
86386: LD_VAR 0 1
86390: PPUSH
86391: CALL 20463 0 3
86395: ST_TO_ADDR
// exit ;
86396: POP
86397: POP
86398: GO 86404
// end ; end ;
86400: GO 86204
86402: POP
86403: POP
// end ;
86404: LD_VAR 0 2
86408: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86409: LD_INT 0
86411: PPUSH
86412: PPUSH
86413: PPUSH
86414: PPUSH
86415: PPUSH
86416: PPUSH
86417: PPUSH
// if not mc_bases or not skirmish then
86418: LD_EXP 61
86422: NOT
86423: PUSH
86424: LD_EXP 59
86428: NOT
86429: OR
86430: IFFALSE 86434
// exit ;
86432: GO 87095
// for i = 1 to mc_bases do
86434: LD_ADDR_VAR 0 3
86438: PUSH
86439: DOUBLE
86440: LD_INT 1
86442: DEC
86443: ST_TO_ADDR
86444: LD_EXP 61
86448: PUSH
86449: FOR_TO
86450: IFFALSE 87093
// begin if building in mc_construct_list [ i ] then
86452: LD_VAR 0 1
86456: PUSH
86457: LD_EXP 68
86461: PUSH
86462: LD_VAR 0 3
86466: ARRAY
86467: IN
86468: IFFALSE 87091
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86470: LD_ADDR_EXP 68
86474: PUSH
86475: LD_EXP 68
86479: PPUSH
86480: LD_VAR 0 3
86484: PPUSH
86485: LD_EXP 68
86489: PUSH
86490: LD_VAR 0 3
86494: ARRAY
86495: PUSH
86496: LD_VAR 0 1
86500: DIFF
86501: PPUSH
86502: CALL_OW 1
86506: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86507: LD_ADDR_EXP 61
86511: PUSH
86512: LD_EXP 61
86516: PPUSH
86517: LD_VAR 0 3
86521: PUSH
86522: LD_EXP 61
86526: PUSH
86527: LD_VAR 0 3
86531: ARRAY
86532: PUSH
86533: LD_INT 1
86535: PLUS
86536: PUSH
86537: EMPTY
86538: LIST
86539: LIST
86540: PPUSH
86541: LD_VAR 0 1
86545: PPUSH
86546: CALL 20463 0 3
86550: ST_TO_ADDR
// btype := GetBType ( building ) ;
86551: LD_ADDR_VAR 0 5
86555: PUSH
86556: LD_VAR 0 1
86560: PPUSH
86561: CALL_OW 266
86565: ST_TO_ADDR
// side := GetSide ( building ) ;
86566: LD_ADDR_VAR 0 8
86570: PUSH
86571: LD_VAR 0 1
86575: PPUSH
86576: CALL_OW 255
86580: ST_TO_ADDR
// if btype = b_lab then
86581: LD_VAR 0 5
86585: PUSH
86586: LD_INT 6
86588: EQUAL
86589: IFFALSE 86639
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86591: LD_ADDR_EXP 94
86595: PUSH
86596: LD_EXP 94
86600: PPUSH
86601: LD_VAR 0 3
86605: PUSH
86606: LD_EXP 94
86610: PUSH
86611: LD_VAR 0 3
86615: ARRAY
86616: PUSH
86617: LD_INT 1
86619: PLUS
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: PPUSH
86625: LD_VAR 0 1
86629: PPUSH
86630: CALL 20463 0 3
86634: ST_TO_ADDR
// exit ;
86635: POP
86636: POP
86637: GO 87095
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86639: LD_VAR 0 5
86643: PUSH
86644: LD_INT 0
86646: PUSH
86647: LD_INT 2
86649: PUSH
86650: LD_INT 4
86652: PUSH
86653: EMPTY
86654: LIST
86655: LIST
86656: LIST
86657: IN
86658: IFFALSE 86782
// begin if btype = b_armoury then
86660: LD_VAR 0 5
86664: PUSH
86665: LD_INT 4
86667: EQUAL
86668: IFFALSE 86678
// btype := b_barracks ;
86670: LD_ADDR_VAR 0 5
86674: PUSH
86675: LD_INT 5
86677: ST_TO_ADDR
// if btype = b_depot then
86678: LD_VAR 0 5
86682: PUSH
86683: LD_INT 0
86685: EQUAL
86686: IFFALSE 86696
// btype := b_warehouse ;
86688: LD_ADDR_VAR 0 5
86692: PUSH
86693: LD_INT 1
86695: ST_TO_ADDR
// if btype = b_workshop then
86696: LD_VAR 0 5
86700: PUSH
86701: LD_INT 2
86703: EQUAL
86704: IFFALSE 86714
// btype := b_factory ;
86706: LD_ADDR_VAR 0 5
86710: PUSH
86711: LD_INT 3
86713: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86714: LD_VAR 0 5
86718: PPUSH
86719: LD_VAR 0 8
86723: PPUSH
86724: CALL_OW 323
86728: PUSH
86729: LD_INT 1
86731: EQUAL
86732: IFFALSE 86778
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86734: LD_ADDR_EXP 93
86738: PUSH
86739: LD_EXP 93
86743: PPUSH
86744: LD_VAR 0 3
86748: PUSH
86749: LD_EXP 93
86753: PUSH
86754: LD_VAR 0 3
86758: ARRAY
86759: PUSH
86760: LD_INT 1
86762: PLUS
86763: PUSH
86764: EMPTY
86765: LIST
86766: LIST
86767: PPUSH
86768: LD_VAR 0 1
86772: PPUSH
86773: CALL 20463 0 3
86777: ST_TO_ADDR
// exit ;
86778: POP
86779: POP
86780: GO 87095
// end ; if btype in [ b_bunker , b_turret ] then
86782: LD_VAR 0 5
86786: PUSH
86787: LD_INT 32
86789: PUSH
86790: LD_INT 33
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: IN
86797: IFFALSE 87087
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86799: LD_ADDR_EXP 69
86803: PUSH
86804: LD_EXP 69
86808: PPUSH
86809: LD_VAR 0 3
86813: PUSH
86814: LD_EXP 69
86818: PUSH
86819: LD_VAR 0 3
86823: ARRAY
86824: PUSH
86825: LD_INT 1
86827: PLUS
86828: PUSH
86829: EMPTY
86830: LIST
86831: LIST
86832: PPUSH
86833: LD_VAR 0 1
86837: PPUSH
86838: CALL 20463 0 3
86842: ST_TO_ADDR
// if btype = b_bunker then
86843: LD_VAR 0 5
86847: PUSH
86848: LD_INT 32
86850: EQUAL
86851: IFFALSE 87087
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86853: LD_ADDR_EXP 70
86857: PUSH
86858: LD_EXP 70
86862: PPUSH
86863: LD_VAR 0 3
86867: PUSH
86868: LD_EXP 70
86872: PUSH
86873: LD_VAR 0 3
86877: ARRAY
86878: PUSH
86879: LD_INT 1
86881: PLUS
86882: PUSH
86883: EMPTY
86884: LIST
86885: LIST
86886: PPUSH
86887: LD_VAR 0 1
86891: PPUSH
86892: CALL 20463 0 3
86896: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86897: LD_ADDR_VAR 0 6
86901: PUSH
86902: LD_EXP 61
86906: PUSH
86907: LD_VAR 0 3
86911: ARRAY
86912: PPUSH
86913: LD_INT 25
86915: PUSH
86916: LD_INT 1
86918: PUSH
86919: EMPTY
86920: LIST
86921: LIST
86922: PUSH
86923: LD_INT 3
86925: PUSH
86926: LD_INT 54
86928: PUSH
86929: EMPTY
86930: LIST
86931: PUSH
86932: EMPTY
86933: LIST
86934: LIST
86935: PUSH
86936: EMPTY
86937: LIST
86938: LIST
86939: PPUSH
86940: CALL_OW 72
86944: ST_TO_ADDR
// if tmp then
86945: LD_VAR 0 6
86949: IFFALSE 86955
// exit ;
86951: POP
86952: POP
86953: GO 87095
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86955: LD_ADDR_VAR 0 6
86959: PUSH
86960: LD_EXP 61
86964: PUSH
86965: LD_VAR 0 3
86969: ARRAY
86970: PPUSH
86971: LD_INT 2
86973: PUSH
86974: LD_INT 30
86976: PUSH
86977: LD_INT 4
86979: PUSH
86980: EMPTY
86981: LIST
86982: LIST
86983: PUSH
86984: LD_INT 30
86986: PUSH
86987: LD_INT 5
86989: PUSH
86990: EMPTY
86991: LIST
86992: LIST
86993: PUSH
86994: EMPTY
86995: LIST
86996: LIST
86997: LIST
86998: PPUSH
86999: CALL_OW 72
87003: ST_TO_ADDR
// if not tmp then
87004: LD_VAR 0 6
87008: NOT
87009: IFFALSE 87015
// exit ;
87011: POP
87012: POP
87013: GO 87095
// for j in tmp do
87015: LD_ADDR_VAR 0 4
87019: PUSH
87020: LD_VAR 0 6
87024: PUSH
87025: FOR_IN
87026: IFFALSE 87085
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
87028: LD_ADDR_VAR 0 7
87032: PUSH
87033: LD_VAR 0 4
87037: PPUSH
87038: CALL_OW 313
87042: PPUSH
87043: LD_INT 25
87045: PUSH
87046: LD_INT 1
87048: PUSH
87049: EMPTY
87050: LIST
87051: LIST
87052: PPUSH
87053: CALL_OW 72
87057: ST_TO_ADDR
// if units then
87058: LD_VAR 0 7
87062: IFFALSE 87083
// begin ComExitBuilding ( units [ 1 ] ) ;
87064: LD_VAR 0 7
87068: PUSH
87069: LD_INT 1
87071: ARRAY
87072: PPUSH
87073: CALL_OW 122
// exit ;
87077: POP
87078: POP
87079: POP
87080: POP
87081: GO 87095
// end ; end ;
87083: GO 87025
87085: POP
87086: POP
// end ; end ; exit ;
87087: POP
87088: POP
87089: GO 87095
// end ; end ;
87091: GO 86449
87093: POP
87094: POP
// end ;
87095: LD_VAR 0 2
87099: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
87100: LD_INT 0
87102: PPUSH
87103: PPUSH
87104: PPUSH
87105: PPUSH
87106: PPUSH
87107: PPUSH
87108: PPUSH
// if not mc_bases or not skirmish then
87109: LD_EXP 61
87113: NOT
87114: PUSH
87115: LD_EXP 59
87119: NOT
87120: OR
87121: IFFALSE 87125
// exit ;
87123: GO 87390
// btype := GetBType ( building ) ;
87125: LD_ADDR_VAR 0 6
87129: PUSH
87130: LD_VAR 0 1
87134: PPUSH
87135: CALL_OW 266
87139: ST_TO_ADDR
// x := GetX ( building ) ;
87140: LD_ADDR_VAR 0 7
87144: PUSH
87145: LD_VAR 0 1
87149: PPUSH
87150: CALL_OW 250
87154: ST_TO_ADDR
// y := GetY ( building ) ;
87155: LD_ADDR_VAR 0 8
87159: PUSH
87160: LD_VAR 0 1
87164: PPUSH
87165: CALL_OW 251
87169: ST_TO_ADDR
// d := GetDir ( building ) ;
87170: LD_ADDR_VAR 0 9
87174: PUSH
87175: LD_VAR 0 1
87179: PPUSH
87180: CALL_OW 254
87184: ST_TO_ADDR
// for i = 1 to mc_bases do
87185: LD_ADDR_VAR 0 4
87189: PUSH
87190: DOUBLE
87191: LD_INT 1
87193: DEC
87194: ST_TO_ADDR
87195: LD_EXP 61
87199: PUSH
87200: FOR_TO
87201: IFFALSE 87388
// begin if not mc_build_list [ i ] then
87203: LD_EXP 66
87207: PUSH
87208: LD_VAR 0 4
87212: ARRAY
87213: NOT
87214: IFFALSE 87218
// continue ;
87216: GO 87200
// for j := 1 to mc_build_list [ i ] do
87218: LD_ADDR_VAR 0 5
87222: PUSH
87223: DOUBLE
87224: LD_INT 1
87226: DEC
87227: ST_TO_ADDR
87228: LD_EXP 66
87232: PUSH
87233: LD_VAR 0 4
87237: ARRAY
87238: PUSH
87239: FOR_TO
87240: IFFALSE 87384
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
87242: LD_VAR 0 6
87246: PUSH
87247: LD_VAR 0 7
87251: PUSH
87252: LD_VAR 0 8
87256: PUSH
87257: LD_VAR 0 9
87261: PUSH
87262: EMPTY
87263: LIST
87264: LIST
87265: LIST
87266: LIST
87267: PPUSH
87268: LD_EXP 66
87272: PUSH
87273: LD_VAR 0 4
87277: ARRAY
87278: PUSH
87279: LD_VAR 0 5
87283: ARRAY
87284: PPUSH
87285: CALL 26652 0 2
87289: IFFALSE 87382
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
87291: LD_ADDR_EXP 66
87295: PUSH
87296: LD_EXP 66
87300: PPUSH
87301: LD_VAR 0 4
87305: PPUSH
87306: LD_EXP 66
87310: PUSH
87311: LD_VAR 0 4
87315: ARRAY
87316: PPUSH
87317: LD_VAR 0 5
87321: PPUSH
87322: CALL_OW 3
87326: PPUSH
87327: CALL_OW 1
87331: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87332: LD_ADDR_EXP 68
87336: PUSH
87337: LD_EXP 68
87341: PPUSH
87342: LD_VAR 0 4
87346: PUSH
87347: LD_EXP 68
87351: PUSH
87352: LD_VAR 0 4
87356: ARRAY
87357: PUSH
87358: LD_INT 1
87360: PLUS
87361: PUSH
87362: EMPTY
87363: LIST
87364: LIST
87365: PPUSH
87366: LD_VAR 0 1
87370: PPUSH
87371: CALL 20463 0 3
87375: ST_TO_ADDR
// exit ;
87376: POP
87377: POP
87378: POP
87379: POP
87380: GO 87390
// end ;
87382: GO 87239
87384: POP
87385: POP
// end ;
87386: GO 87200
87388: POP
87389: POP
// end ;
87390: LD_VAR 0 3
87394: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87395: LD_INT 0
87397: PPUSH
87398: PPUSH
87399: PPUSH
// if not mc_bases or not skirmish then
87400: LD_EXP 61
87404: NOT
87405: PUSH
87406: LD_EXP 59
87410: NOT
87411: OR
87412: IFFALSE 87416
// exit ;
87414: GO 87606
// for i = 1 to mc_bases do
87416: LD_ADDR_VAR 0 4
87420: PUSH
87421: DOUBLE
87422: LD_INT 1
87424: DEC
87425: ST_TO_ADDR
87426: LD_EXP 61
87430: PUSH
87431: FOR_TO
87432: IFFALSE 87519
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87434: LD_VAR 0 1
87438: PUSH
87439: LD_EXP 69
87443: PUSH
87444: LD_VAR 0 4
87448: ARRAY
87449: IN
87450: PUSH
87451: LD_VAR 0 1
87455: PUSH
87456: LD_EXP 70
87460: PUSH
87461: LD_VAR 0 4
87465: ARRAY
87466: IN
87467: NOT
87468: AND
87469: IFFALSE 87517
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87471: LD_ADDR_EXP 70
87475: PUSH
87476: LD_EXP 70
87480: PPUSH
87481: LD_VAR 0 4
87485: PUSH
87486: LD_EXP 70
87490: PUSH
87491: LD_VAR 0 4
87495: ARRAY
87496: PUSH
87497: LD_INT 1
87499: PLUS
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: PPUSH
87505: LD_VAR 0 1
87509: PPUSH
87510: CALL 20463 0 3
87514: ST_TO_ADDR
// break ;
87515: GO 87519
// end ; end ;
87517: GO 87431
87519: POP
87520: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87521: LD_VAR 0 1
87525: PPUSH
87526: CALL_OW 257
87530: PUSH
87531: LD_EXP 87
87535: IN
87536: PUSH
87537: LD_VAR 0 1
87541: PPUSH
87542: CALL_OW 266
87546: PUSH
87547: LD_INT 5
87549: EQUAL
87550: AND
87551: PUSH
87552: LD_VAR 0 2
87556: PPUSH
87557: CALL_OW 110
87561: PUSH
87562: LD_INT 18
87564: NONEQUAL
87565: AND
87566: IFFALSE 87606
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87568: LD_VAR 0 2
87572: PPUSH
87573: CALL_OW 257
87577: PUSH
87578: LD_INT 5
87580: PUSH
87581: LD_INT 8
87583: PUSH
87584: LD_INT 9
87586: PUSH
87587: EMPTY
87588: LIST
87589: LIST
87590: LIST
87591: IN
87592: IFFALSE 87606
// SetClass ( unit , 1 ) ;
87594: LD_VAR 0 2
87598: PPUSH
87599: LD_INT 1
87601: PPUSH
87602: CALL_OW 336
// end ;
87606: LD_VAR 0 3
87610: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87611: LD_INT 0
87613: PPUSH
87614: PPUSH
// if not mc_bases or not skirmish then
87615: LD_EXP 61
87619: NOT
87620: PUSH
87621: LD_EXP 59
87625: NOT
87626: OR
87627: IFFALSE 87631
// exit ;
87629: GO 87747
// if GetLives ( abandoned_vehicle ) > 250 then
87631: LD_VAR 0 2
87635: PPUSH
87636: CALL_OW 256
87640: PUSH
87641: LD_INT 250
87643: GREATER
87644: IFFALSE 87648
// exit ;
87646: GO 87747
// for i = 1 to mc_bases do
87648: LD_ADDR_VAR 0 6
87652: PUSH
87653: DOUBLE
87654: LD_INT 1
87656: DEC
87657: ST_TO_ADDR
87658: LD_EXP 61
87662: PUSH
87663: FOR_TO
87664: IFFALSE 87745
// begin if driver in mc_bases [ i ] then
87666: LD_VAR 0 1
87670: PUSH
87671: LD_EXP 61
87675: PUSH
87676: LD_VAR 0 6
87680: ARRAY
87681: IN
87682: IFFALSE 87743
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87684: LD_VAR 0 1
87688: PPUSH
87689: LD_EXP 61
87693: PUSH
87694: LD_VAR 0 6
87698: ARRAY
87699: PPUSH
87700: LD_INT 2
87702: PUSH
87703: LD_INT 30
87705: PUSH
87706: LD_INT 0
87708: PUSH
87709: EMPTY
87710: LIST
87711: LIST
87712: PUSH
87713: LD_INT 30
87715: PUSH
87716: LD_INT 1
87718: PUSH
87719: EMPTY
87720: LIST
87721: LIST
87722: PUSH
87723: EMPTY
87724: LIST
87725: LIST
87726: LIST
87727: PPUSH
87728: CALL_OW 72
87732: PUSH
87733: LD_INT 1
87735: ARRAY
87736: PPUSH
87737: CALL 53699 0 2
// break ;
87741: GO 87745
// end ; end ;
87743: GO 87663
87745: POP
87746: POP
// end ; end_of_file end_of_file
87747: LD_VAR 0 5
87751: RET
// export globalGameSaveCounter ; every 0 0$1 do
87752: GO 87754
87754: DISABLE
// begin enable ;
87755: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87756: LD_STRING updateTimer(
87758: PUSH
87759: LD_OWVAR 1
87763: STR
87764: PUSH
87765: LD_STRING );
87767: STR
87768: PPUSH
87769: CALL_OW 559
// end ;
87773: END
// every 0 0$1 do
87774: GO 87776
87776: DISABLE
// begin globalGameSaveCounter := 0 ;
87777: LD_ADDR_EXP 106
87781: PUSH
87782: LD_INT 0
87784: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
87785: LD_STRING setGameSaveCounter(0)
87787: PPUSH
87788: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
87792: LD_STRING initStreamRollete();
87794: PPUSH
87795: CALL_OW 559
// InitStreamMode ;
87799: CALL 89125 0 0
// DefineStreamItems ( false ) ;
87803: LD_INT 0
87805: PPUSH
87806: CALL 89589 0 1
// end ;
87810: END
// export function SOS_MapStart ( ) ; begin
87811: LD_INT 0
87813: PPUSH
// if streamModeActive then
87814: LD_EXP 107
87818: IFFALSE 87827
// DefineStreamItems ( true ) ;
87820: LD_INT 1
87822: PPUSH
87823: CALL 89589 0 1
// UpdateLuaVariables ( ) ;
87827: CALL 87844 0 0
// UpdateFactoryWaypoints ( ) ;
87831: CALL 102458 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87835: CALL 102715 0 0
// end ;
87839: LD_VAR 0 1
87843: RET
// function UpdateLuaVariables ( ) ; begin
87844: LD_INT 0
87846: PPUSH
// if globalGameSaveCounter then
87847: LD_EXP 106
87851: IFFALSE 87885
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
87853: LD_ADDR_EXP 106
87857: PUSH
87858: LD_EXP 106
87862: PPUSH
87863: CALL 54183 0 1
87867: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87868: LD_STRING setGameSaveCounter(
87870: PUSH
87871: LD_EXP 106
87875: STR
87876: PUSH
87877: LD_STRING )
87879: STR
87880: PPUSH
87881: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
87885: LD_STRING setGameDifficulty(
87887: PUSH
87888: LD_OWVAR 67
87892: STR
87893: PUSH
87894: LD_STRING )
87896: STR
87897: PPUSH
87898: CALL_OW 559
// end ;
87902: LD_VAR 0 1
87906: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87907: LD_INT 0
87909: PPUSH
// if p2 = stream_mode then
87910: LD_VAR 0 2
87914: PUSH
87915: LD_INT 100
87917: EQUAL
87918: IFFALSE 88921
// begin if not StreamModeActive then
87920: LD_EXP 107
87924: NOT
87925: IFFALSE 87935
// StreamModeActive := true ;
87927: LD_ADDR_EXP 107
87931: PUSH
87932: LD_INT 1
87934: ST_TO_ADDR
// if p3 = 0 then
87935: LD_VAR 0 3
87939: PUSH
87940: LD_INT 0
87942: EQUAL
87943: IFFALSE 87949
// InitStreamMode ;
87945: CALL 89125 0 0
// if p3 = 1 then
87949: LD_VAR 0 3
87953: PUSH
87954: LD_INT 1
87956: EQUAL
87957: IFFALSE 87967
// sRocket := true ;
87959: LD_ADDR_EXP 112
87963: PUSH
87964: LD_INT 1
87966: ST_TO_ADDR
// if p3 = 2 then
87967: LD_VAR 0 3
87971: PUSH
87972: LD_INT 2
87974: EQUAL
87975: IFFALSE 87985
// sSpeed := true ;
87977: LD_ADDR_EXP 111
87981: PUSH
87982: LD_INT 1
87984: ST_TO_ADDR
// if p3 = 3 then
87985: LD_VAR 0 3
87989: PUSH
87990: LD_INT 3
87992: EQUAL
87993: IFFALSE 88003
// sEngine := true ;
87995: LD_ADDR_EXP 113
87999: PUSH
88000: LD_INT 1
88002: ST_TO_ADDR
// if p3 = 4 then
88003: LD_VAR 0 3
88007: PUSH
88008: LD_INT 4
88010: EQUAL
88011: IFFALSE 88021
// sSpec := true ;
88013: LD_ADDR_EXP 110
88017: PUSH
88018: LD_INT 1
88020: ST_TO_ADDR
// if p3 = 5 then
88021: LD_VAR 0 3
88025: PUSH
88026: LD_INT 5
88028: EQUAL
88029: IFFALSE 88039
// sLevel := true ;
88031: LD_ADDR_EXP 114
88035: PUSH
88036: LD_INT 1
88038: ST_TO_ADDR
// if p3 = 6 then
88039: LD_VAR 0 3
88043: PUSH
88044: LD_INT 6
88046: EQUAL
88047: IFFALSE 88057
// sArmoury := true ;
88049: LD_ADDR_EXP 115
88053: PUSH
88054: LD_INT 1
88056: ST_TO_ADDR
// if p3 = 7 then
88057: LD_VAR 0 3
88061: PUSH
88062: LD_INT 7
88064: EQUAL
88065: IFFALSE 88075
// sRadar := true ;
88067: LD_ADDR_EXP 116
88071: PUSH
88072: LD_INT 1
88074: ST_TO_ADDR
// if p3 = 8 then
88075: LD_VAR 0 3
88079: PUSH
88080: LD_INT 8
88082: EQUAL
88083: IFFALSE 88093
// sBunker := true ;
88085: LD_ADDR_EXP 117
88089: PUSH
88090: LD_INT 1
88092: ST_TO_ADDR
// if p3 = 9 then
88093: LD_VAR 0 3
88097: PUSH
88098: LD_INT 9
88100: EQUAL
88101: IFFALSE 88111
// sHack := true ;
88103: LD_ADDR_EXP 118
88107: PUSH
88108: LD_INT 1
88110: ST_TO_ADDR
// if p3 = 10 then
88111: LD_VAR 0 3
88115: PUSH
88116: LD_INT 10
88118: EQUAL
88119: IFFALSE 88129
// sFire := true ;
88121: LD_ADDR_EXP 119
88125: PUSH
88126: LD_INT 1
88128: ST_TO_ADDR
// if p3 = 11 then
88129: LD_VAR 0 3
88133: PUSH
88134: LD_INT 11
88136: EQUAL
88137: IFFALSE 88147
// sRefresh := true ;
88139: LD_ADDR_EXP 120
88143: PUSH
88144: LD_INT 1
88146: ST_TO_ADDR
// if p3 = 12 then
88147: LD_VAR 0 3
88151: PUSH
88152: LD_INT 12
88154: EQUAL
88155: IFFALSE 88165
// sExp := true ;
88157: LD_ADDR_EXP 121
88161: PUSH
88162: LD_INT 1
88164: ST_TO_ADDR
// if p3 = 13 then
88165: LD_VAR 0 3
88169: PUSH
88170: LD_INT 13
88172: EQUAL
88173: IFFALSE 88183
// sDepot := true ;
88175: LD_ADDR_EXP 122
88179: PUSH
88180: LD_INT 1
88182: ST_TO_ADDR
// if p3 = 14 then
88183: LD_VAR 0 3
88187: PUSH
88188: LD_INT 14
88190: EQUAL
88191: IFFALSE 88201
// sFlag := true ;
88193: LD_ADDR_EXP 123
88197: PUSH
88198: LD_INT 1
88200: ST_TO_ADDR
// if p3 = 15 then
88201: LD_VAR 0 3
88205: PUSH
88206: LD_INT 15
88208: EQUAL
88209: IFFALSE 88219
// sKamikadze := true ;
88211: LD_ADDR_EXP 131
88215: PUSH
88216: LD_INT 1
88218: ST_TO_ADDR
// if p3 = 16 then
88219: LD_VAR 0 3
88223: PUSH
88224: LD_INT 16
88226: EQUAL
88227: IFFALSE 88237
// sTroll := true ;
88229: LD_ADDR_EXP 132
88233: PUSH
88234: LD_INT 1
88236: ST_TO_ADDR
// if p3 = 17 then
88237: LD_VAR 0 3
88241: PUSH
88242: LD_INT 17
88244: EQUAL
88245: IFFALSE 88255
// sSlow := true ;
88247: LD_ADDR_EXP 133
88251: PUSH
88252: LD_INT 1
88254: ST_TO_ADDR
// if p3 = 18 then
88255: LD_VAR 0 3
88259: PUSH
88260: LD_INT 18
88262: EQUAL
88263: IFFALSE 88273
// sLack := true ;
88265: LD_ADDR_EXP 134
88269: PUSH
88270: LD_INT 1
88272: ST_TO_ADDR
// if p3 = 19 then
88273: LD_VAR 0 3
88277: PUSH
88278: LD_INT 19
88280: EQUAL
88281: IFFALSE 88291
// sTank := true ;
88283: LD_ADDR_EXP 136
88287: PUSH
88288: LD_INT 1
88290: ST_TO_ADDR
// if p3 = 20 then
88291: LD_VAR 0 3
88295: PUSH
88296: LD_INT 20
88298: EQUAL
88299: IFFALSE 88309
// sRemote := true ;
88301: LD_ADDR_EXP 137
88305: PUSH
88306: LD_INT 1
88308: ST_TO_ADDR
// if p3 = 21 then
88309: LD_VAR 0 3
88313: PUSH
88314: LD_INT 21
88316: EQUAL
88317: IFFALSE 88327
// sPowell := true ;
88319: LD_ADDR_EXP 138
88323: PUSH
88324: LD_INT 1
88326: ST_TO_ADDR
// if p3 = 22 then
88327: LD_VAR 0 3
88331: PUSH
88332: LD_INT 22
88334: EQUAL
88335: IFFALSE 88345
// sTeleport := true ;
88337: LD_ADDR_EXP 141
88341: PUSH
88342: LD_INT 1
88344: ST_TO_ADDR
// if p3 = 23 then
88345: LD_VAR 0 3
88349: PUSH
88350: LD_INT 23
88352: EQUAL
88353: IFFALSE 88363
// sOilTower := true ;
88355: LD_ADDR_EXP 143
88359: PUSH
88360: LD_INT 1
88362: ST_TO_ADDR
// if p3 = 24 then
88363: LD_VAR 0 3
88367: PUSH
88368: LD_INT 24
88370: EQUAL
88371: IFFALSE 88381
// sShovel := true ;
88373: LD_ADDR_EXP 144
88377: PUSH
88378: LD_INT 1
88380: ST_TO_ADDR
// if p3 = 25 then
88381: LD_VAR 0 3
88385: PUSH
88386: LD_INT 25
88388: EQUAL
88389: IFFALSE 88399
// sSheik := true ;
88391: LD_ADDR_EXP 145
88395: PUSH
88396: LD_INT 1
88398: ST_TO_ADDR
// if p3 = 26 then
88399: LD_VAR 0 3
88403: PUSH
88404: LD_INT 26
88406: EQUAL
88407: IFFALSE 88417
// sEarthquake := true ;
88409: LD_ADDR_EXP 147
88413: PUSH
88414: LD_INT 1
88416: ST_TO_ADDR
// if p3 = 27 then
88417: LD_VAR 0 3
88421: PUSH
88422: LD_INT 27
88424: EQUAL
88425: IFFALSE 88435
// sAI := true ;
88427: LD_ADDR_EXP 148
88431: PUSH
88432: LD_INT 1
88434: ST_TO_ADDR
// if p3 = 28 then
88435: LD_VAR 0 3
88439: PUSH
88440: LD_INT 28
88442: EQUAL
88443: IFFALSE 88453
// sCargo := true ;
88445: LD_ADDR_EXP 151
88449: PUSH
88450: LD_INT 1
88452: ST_TO_ADDR
// if p3 = 29 then
88453: LD_VAR 0 3
88457: PUSH
88458: LD_INT 29
88460: EQUAL
88461: IFFALSE 88471
// sDLaser := true ;
88463: LD_ADDR_EXP 152
88467: PUSH
88468: LD_INT 1
88470: ST_TO_ADDR
// if p3 = 30 then
88471: LD_VAR 0 3
88475: PUSH
88476: LD_INT 30
88478: EQUAL
88479: IFFALSE 88489
// sExchange := true ;
88481: LD_ADDR_EXP 153
88485: PUSH
88486: LD_INT 1
88488: ST_TO_ADDR
// if p3 = 31 then
88489: LD_VAR 0 3
88493: PUSH
88494: LD_INT 31
88496: EQUAL
88497: IFFALSE 88507
// sFac := true ;
88499: LD_ADDR_EXP 154
88503: PUSH
88504: LD_INT 1
88506: ST_TO_ADDR
// if p3 = 32 then
88507: LD_VAR 0 3
88511: PUSH
88512: LD_INT 32
88514: EQUAL
88515: IFFALSE 88525
// sPower := true ;
88517: LD_ADDR_EXP 155
88521: PUSH
88522: LD_INT 1
88524: ST_TO_ADDR
// if p3 = 33 then
88525: LD_VAR 0 3
88529: PUSH
88530: LD_INT 33
88532: EQUAL
88533: IFFALSE 88543
// sRandom := true ;
88535: LD_ADDR_EXP 156
88539: PUSH
88540: LD_INT 1
88542: ST_TO_ADDR
// if p3 = 34 then
88543: LD_VAR 0 3
88547: PUSH
88548: LD_INT 34
88550: EQUAL
88551: IFFALSE 88561
// sShield := true ;
88553: LD_ADDR_EXP 157
88557: PUSH
88558: LD_INT 1
88560: ST_TO_ADDR
// if p3 = 35 then
88561: LD_VAR 0 3
88565: PUSH
88566: LD_INT 35
88568: EQUAL
88569: IFFALSE 88579
// sTime := true ;
88571: LD_ADDR_EXP 158
88575: PUSH
88576: LD_INT 1
88578: ST_TO_ADDR
// if p3 = 36 then
88579: LD_VAR 0 3
88583: PUSH
88584: LD_INT 36
88586: EQUAL
88587: IFFALSE 88597
// sTools := true ;
88589: LD_ADDR_EXP 159
88593: PUSH
88594: LD_INT 1
88596: ST_TO_ADDR
// if p3 = 101 then
88597: LD_VAR 0 3
88601: PUSH
88602: LD_INT 101
88604: EQUAL
88605: IFFALSE 88615
// sSold := true ;
88607: LD_ADDR_EXP 124
88611: PUSH
88612: LD_INT 1
88614: ST_TO_ADDR
// if p3 = 102 then
88615: LD_VAR 0 3
88619: PUSH
88620: LD_INT 102
88622: EQUAL
88623: IFFALSE 88633
// sDiff := true ;
88625: LD_ADDR_EXP 125
88629: PUSH
88630: LD_INT 1
88632: ST_TO_ADDR
// if p3 = 103 then
88633: LD_VAR 0 3
88637: PUSH
88638: LD_INT 103
88640: EQUAL
88641: IFFALSE 88651
// sFog := true ;
88643: LD_ADDR_EXP 128
88647: PUSH
88648: LD_INT 1
88650: ST_TO_ADDR
// if p3 = 104 then
88651: LD_VAR 0 3
88655: PUSH
88656: LD_INT 104
88658: EQUAL
88659: IFFALSE 88669
// sReset := true ;
88661: LD_ADDR_EXP 129
88665: PUSH
88666: LD_INT 1
88668: ST_TO_ADDR
// if p3 = 105 then
88669: LD_VAR 0 3
88673: PUSH
88674: LD_INT 105
88676: EQUAL
88677: IFFALSE 88687
// sSun := true ;
88679: LD_ADDR_EXP 130
88683: PUSH
88684: LD_INT 1
88686: ST_TO_ADDR
// if p3 = 106 then
88687: LD_VAR 0 3
88691: PUSH
88692: LD_INT 106
88694: EQUAL
88695: IFFALSE 88705
// sTiger := true ;
88697: LD_ADDR_EXP 126
88701: PUSH
88702: LD_INT 1
88704: ST_TO_ADDR
// if p3 = 107 then
88705: LD_VAR 0 3
88709: PUSH
88710: LD_INT 107
88712: EQUAL
88713: IFFALSE 88723
// sBomb := true ;
88715: LD_ADDR_EXP 127
88719: PUSH
88720: LD_INT 1
88722: ST_TO_ADDR
// if p3 = 108 then
88723: LD_VAR 0 3
88727: PUSH
88728: LD_INT 108
88730: EQUAL
88731: IFFALSE 88741
// sWound := true ;
88733: LD_ADDR_EXP 135
88737: PUSH
88738: LD_INT 1
88740: ST_TO_ADDR
// if p3 = 109 then
88741: LD_VAR 0 3
88745: PUSH
88746: LD_INT 109
88748: EQUAL
88749: IFFALSE 88759
// sBetray := true ;
88751: LD_ADDR_EXP 139
88755: PUSH
88756: LD_INT 1
88758: ST_TO_ADDR
// if p3 = 110 then
88759: LD_VAR 0 3
88763: PUSH
88764: LD_INT 110
88766: EQUAL
88767: IFFALSE 88777
// sContamin := true ;
88769: LD_ADDR_EXP 140
88773: PUSH
88774: LD_INT 1
88776: ST_TO_ADDR
// if p3 = 111 then
88777: LD_VAR 0 3
88781: PUSH
88782: LD_INT 111
88784: EQUAL
88785: IFFALSE 88795
// sOil := true ;
88787: LD_ADDR_EXP 142
88791: PUSH
88792: LD_INT 1
88794: ST_TO_ADDR
// if p3 = 112 then
88795: LD_VAR 0 3
88799: PUSH
88800: LD_INT 112
88802: EQUAL
88803: IFFALSE 88813
// sStu := true ;
88805: LD_ADDR_EXP 146
88809: PUSH
88810: LD_INT 1
88812: ST_TO_ADDR
// if p3 = 113 then
88813: LD_VAR 0 3
88817: PUSH
88818: LD_INT 113
88820: EQUAL
88821: IFFALSE 88831
// sBazooka := true ;
88823: LD_ADDR_EXP 149
88827: PUSH
88828: LD_INT 1
88830: ST_TO_ADDR
// if p3 = 114 then
88831: LD_VAR 0 3
88835: PUSH
88836: LD_INT 114
88838: EQUAL
88839: IFFALSE 88849
// sMortar := true ;
88841: LD_ADDR_EXP 150
88845: PUSH
88846: LD_INT 1
88848: ST_TO_ADDR
// if p3 = 115 then
88849: LD_VAR 0 3
88853: PUSH
88854: LD_INT 115
88856: EQUAL
88857: IFFALSE 88867
// sRanger := true ;
88859: LD_ADDR_EXP 160
88863: PUSH
88864: LD_INT 1
88866: ST_TO_ADDR
// if p3 = 116 then
88867: LD_VAR 0 3
88871: PUSH
88872: LD_INT 116
88874: EQUAL
88875: IFFALSE 88885
// sComputer := true ;
88877: LD_ADDR_EXP 161
88881: PUSH
88882: LD_INT 1
88884: ST_TO_ADDR
// if p3 = 117 then
88885: LD_VAR 0 3
88889: PUSH
88890: LD_INT 117
88892: EQUAL
88893: IFFALSE 88903
// s30 := true ;
88895: LD_ADDR_EXP 162
88899: PUSH
88900: LD_INT 1
88902: ST_TO_ADDR
// if p3 = 118 then
88903: LD_VAR 0 3
88907: PUSH
88908: LD_INT 118
88910: EQUAL
88911: IFFALSE 88921
// s60 := true ;
88913: LD_ADDR_EXP 163
88917: PUSH
88918: LD_INT 1
88920: ST_TO_ADDR
// end ; if p2 = hack_mode then
88921: LD_VAR 0 2
88925: PUSH
88926: LD_INT 101
88928: EQUAL
88929: IFFALSE 89057
// begin case p3 of 1 :
88931: LD_VAR 0 3
88935: PUSH
88936: LD_INT 1
88938: DOUBLE
88939: EQUAL
88940: IFTRUE 88944
88942: GO 88951
88944: POP
// hHackUnlimitedResources ; 2 :
88945: CALL 101204 0 0
88949: GO 89057
88951: LD_INT 2
88953: DOUBLE
88954: EQUAL
88955: IFTRUE 88959
88957: GO 88966
88959: POP
// hHackSetLevel10 ; 3 :
88960: CALL 101337 0 0
88964: GO 89057
88966: LD_INT 3
88968: DOUBLE
88969: EQUAL
88970: IFTRUE 88974
88972: GO 88981
88974: POP
// hHackSetLevel10YourUnits ; 4 :
88975: CALL 101422 0 0
88979: GO 89057
88981: LD_INT 4
88983: DOUBLE
88984: EQUAL
88985: IFTRUE 88989
88987: GO 88996
88989: POP
// hHackInvincible ; 5 :
88990: CALL 101870 0 0
88994: GO 89057
88996: LD_INT 5
88998: DOUBLE
88999: EQUAL
89000: IFTRUE 89004
89002: GO 89011
89004: POP
// hHackInvisible ; 6 :
89005: CALL 101981 0 0
89009: GO 89057
89011: LD_INT 6
89013: DOUBLE
89014: EQUAL
89015: IFTRUE 89019
89017: GO 89026
89019: POP
// hHackChangeYourSide ; 7 :
89020: CALL 102038 0 0
89024: GO 89057
89026: LD_INT 7
89028: DOUBLE
89029: EQUAL
89030: IFTRUE 89034
89032: GO 89041
89034: POP
// hHackChangeUnitSide ; 8 :
89035: CALL 102080 0 0
89039: GO 89057
89041: LD_INT 8
89043: DOUBLE
89044: EQUAL
89045: IFTRUE 89049
89047: GO 89056
89049: POP
// hHackFog ; end ;
89050: CALL 102181 0 0
89054: GO 89057
89056: POP
// end ; if p2 = game_save_mode then
89057: LD_VAR 0 2
89061: PUSH
89062: LD_INT 102
89064: EQUAL
89065: IFFALSE 89120
// begin if p3 = 1 then
89067: LD_VAR 0 3
89071: PUSH
89072: LD_INT 1
89074: EQUAL
89075: IFFALSE 89087
// globalGameSaveCounter := p4 ;
89077: LD_ADDR_EXP 106
89081: PUSH
89082: LD_VAR 0 4
89086: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
89087: LD_VAR 0 3
89091: PUSH
89092: LD_INT 2
89094: EQUAL
89095: PUSH
89096: LD_EXP 106
89100: AND
89101: IFFALSE 89120
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
89103: LD_STRING setGameSaveCounter(
89105: PUSH
89106: LD_EXP 106
89110: STR
89111: PUSH
89112: LD_STRING )
89114: STR
89115: PPUSH
89116: CALL_OW 559
// end ; end ;
89120: LD_VAR 0 7
89124: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
89125: LD_INT 0
89127: PPUSH
// streamModeActive := false ;
89128: LD_ADDR_EXP 107
89132: PUSH
89133: LD_INT 0
89135: ST_TO_ADDR
// normalCounter := 36 ;
89136: LD_ADDR_EXP 108
89140: PUSH
89141: LD_INT 36
89143: ST_TO_ADDR
// hardcoreCounter := 18 ;
89144: LD_ADDR_EXP 109
89148: PUSH
89149: LD_INT 18
89151: ST_TO_ADDR
// sRocket := false ;
89152: LD_ADDR_EXP 112
89156: PUSH
89157: LD_INT 0
89159: ST_TO_ADDR
// sSpeed := false ;
89160: LD_ADDR_EXP 111
89164: PUSH
89165: LD_INT 0
89167: ST_TO_ADDR
// sEngine := false ;
89168: LD_ADDR_EXP 113
89172: PUSH
89173: LD_INT 0
89175: ST_TO_ADDR
// sSpec := false ;
89176: LD_ADDR_EXP 110
89180: PUSH
89181: LD_INT 0
89183: ST_TO_ADDR
// sLevel := false ;
89184: LD_ADDR_EXP 114
89188: PUSH
89189: LD_INT 0
89191: ST_TO_ADDR
// sArmoury := false ;
89192: LD_ADDR_EXP 115
89196: PUSH
89197: LD_INT 0
89199: ST_TO_ADDR
// sRadar := false ;
89200: LD_ADDR_EXP 116
89204: PUSH
89205: LD_INT 0
89207: ST_TO_ADDR
// sBunker := false ;
89208: LD_ADDR_EXP 117
89212: PUSH
89213: LD_INT 0
89215: ST_TO_ADDR
// sHack := false ;
89216: LD_ADDR_EXP 118
89220: PUSH
89221: LD_INT 0
89223: ST_TO_ADDR
// sFire := false ;
89224: LD_ADDR_EXP 119
89228: PUSH
89229: LD_INT 0
89231: ST_TO_ADDR
// sRefresh := false ;
89232: LD_ADDR_EXP 120
89236: PUSH
89237: LD_INT 0
89239: ST_TO_ADDR
// sExp := false ;
89240: LD_ADDR_EXP 121
89244: PUSH
89245: LD_INT 0
89247: ST_TO_ADDR
// sDepot := false ;
89248: LD_ADDR_EXP 122
89252: PUSH
89253: LD_INT 0
89255: ST_TO_ADDR
// sFlag := false ;
89256: LD_ADDR_EXP 123
89260: PUSH
89261: LD_INT 0
89263: ST_TO_ADDR
// sKamikadze := false ;
89264: LD_ADDR_EXP 131
89268: PUSH
89269: LD_INT 0
89271: ST_TO_ADDR
// sTroll := false ;
89272: LD_ADDR_EXP 132
89276: PUSH
89277: LD_INT 0
89279: ST_TO_ADDR
// sSlow := false ;
89280: LD_ADDR_EXP 133
89284: PUSH
89285: LD_INT 0
89287: ST_TO_ADDR
// sLack := false ;
89288: LD_ADDR_EXP 134
89292: PUSH
89293: LD_INT 0
89295: ST_TO_ADDR
// sTank := false ;
89296: LD_ADDR_EXP 136
89300: PUSH
89301: LD_INT 0
89303: ST_TO_ADDR
// sRemote := false ;
89304: LD_ADDR_EXP 137
89308: PUSH
89309: LD_INT 0
89311: ST_TO_ADDR
// sPowell := false ;
89312: LD_ADDR_EXP 138
89316: PUSH
89317: LD_INT 0
89319: ST_TO_ADDR
// sTeleport := false ;
89320: LD_ADDR_EXP 141
89324: PUSH
89325: LD_INT 0
89327: ST_TO_ADDR
// sOilTower := false ;
89328: LD_ADDR_EXP 143
89332: PUSH
89333: LD_INT 0
89335: ST_TO_ADDR
// sShovel := false ;
89336: LD_ADDR_EXP 144
89340: PUSH
89341: LD_INT 0
89343: ST_TO_ADDR
// sSheik := false ;
89344: LD_ADDR_EXP 145
89348: PUSH
89349: LD_INT 0
89351: ST_TO_ADDR
// sEarthquake := false ;
89352: LD_ADDR_EXP 147
89356: PUSH
89357: LD_INT 0
89359: ST_TO_ADDR
// sAI := false ;
89360: LD_ADDR_EXP 148
89364: PUSH
89365: LD_INT 0
89367: ST_TO_ADDR
// sCargo := false ;
89368: LD_ADDR_EXP 151
89372: PUSH
89373: LD_INT 0
89375: ST_TO_ADDR
// sDLaser := false ;
89376: LD_ADDR_EXP 152
89380: PUSH
89381: LD_INT 0
89383: ST_TO_ADDR
// sExchange := false ;
89384: LD_ADDR_EXP 153
89388: PUSH
89389: LD_INT 0
89391: ST_TO_ADDR
// sFac := false ;
89392: LD_ADDR_EXP 154
89396: PUSH
89397: LD_INT 0
89399: ST_TO_ADDR
// sPower := false ;
89400: LD_ADDR_EXP 155
89404: PUSH
89405: LD_INT 0
89407: ST_TO_ADDR
// sRandom := false ;
89408: LD_ADDR_EXP 156
89412: PUSH
89413: LD_INT 0
89415: ST_TO_ADDR
// sShield := false ;
89416: LD_ADDR_EXP 157
89420: PUSH
89421: LD_INT 0
89423: ST_TO_ADDR
// sTime := false ;
89424: LD_ADDR_EXP 158
89428: PUSH
89429: LD_INT 0
89431: ST_TO_ADDR
// sTools := false ;
89432: LD_ADDR_EXP 159
89436: PUSH
89437: LD_INT 0
89439: ST_TO_ADDR
// sSold := false ;
89440: LD_ADDR_EXP 124
89444: PUSH
89445: LD_INT 0
89447: ST_TO_ADDR
// sDiff := false ;
89448: LD_ADDR_EXP 125
89452: PUSH
89453: LD_INT 0
89455: ST_TO_ADDR
// sFog := false ;
89456: LD_ADDR_EXP 128
89460: PUSH
89461: LD_INT 0
89463: ST_TO_ADDR
// sReset := false ;
89464: LD_ADDR_EXP 129
89468: PUSH
89469: LD_INT 0
89471: ST_TO_ADDR
// sSun := false ;
89472: LD_ADDR_EXP 130
89476: PUSH
89477: LD_INT 0
89479: ST_TO_ADDR
// sTiger := false ;
89480: LD_ADDR_EXP 126
89484: PUSH
89485: LD_INT 0
89487: ST_TO_ADDR
// sBomb := false ;
89488: LD_ADDR_EXP 127
89492: PUSH
89493: LD_INT 0
89495: ST_TO_ADDR
// sWound := false ;
89496: LD_ADDR_EXP 135
89500: PUSH
89501: LD_INT 0
89503: ST_TO_ADDR
// sBetray := false ;
89504: LD_ADDR_EXP 139
89508: PUSH
89509: LD_INT 0
89511: ST_TO_ADDR
// sContamin := false ;
89512: LD_ADDR_EXP 140
89516: PUSH
89517: LD_INT 0
89519: ST_TO_ADDR
// sOil := false ;
89520: LD_ADDR_EXP 142
89524: PUSH
89525: LD_INT 0
89527: ST_TO_ADDR
// sStu := false ;
89528: LD_ADDR_EXP 146
89532: PUSH
89533: LD_INT 0
89535: ST_TO_ADDR
// sBazooka := false ;
89536: LD_ADDR_EXP 149
89540: PUSH
89541: LD_INT 0
89543: ST_TO_ADDR
// sMortar := false ;
89544: LD_ADDR_EXP 150
89548: PUSH
89549: LD_INT 0
89551: ST_TO_ADDR
// sRanger := false ;
89552: LD_ADDR_EXP 160
89556: PUSH
89557: LD_INT 0
89559: ST_TO_ADDR
// sComputer := false ;
89560: LD_ADDR_EXP 161
89564: PUSH
89565: LD_INT 0
89567: ST_TO_ADDR
// s30 := false ;
89568: LD_ADDR_EXP 162
89572: PUSH
89573: LD_INT 0
89575: ST_TO_ADDR
// s60 := false ;
89576: LD_ADDR_EXP 163
89580: PUSH
89581: LD_INT 0
89583: ST_TO_ADDR
// end ;
89584: LD_VAR 0 1
89588: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
89589: LD_INT 0
89591: PPUSH
89592: PPUSH
89593: PPUSH
89594: PPUSH
89595: PPUSH
89596: PPUSH
89597: PPUSH
// result := [ ] ;
89598: LD_ADDR_VAR 0 2
89602: PUSH
89603: EMPTY
89604: ST_TO_ADDR
// if campaign_id = 1 then
89605: LD_OWVAR 69
89609: PUSH
89610: LD_INT 1
89612: EQUAL
89613: IFFALSE 92779
// begin case mission_number of 1 :
89615: LD_OWVAR 70
89619: PUSH
89620: LD_INT 1
89622: DOUBLE
89623: EQUAL
89624: IFTRUE 89628
89626: GO 89704
89628: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
89629: LD_ADDR_VAR 0 2
89633: PUSH
89634: LD_INT 2
89636: PUSH
89637: LD_INT 4
89639: PUSH
89640: LD_INT 11
89642: PUSH
89643: LD_INT 12
89645: PUSH
89646: LD_INT 15
89648: PUSH
89649: LD_INT 16
89651: PUSH
89652: LD_INT 22
89654: PUSH
89655: LD_INT 23
89657: PUSH
89658: LD_INT 26
89660: PUSH
89661: EMPTY
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: PUSH
89672: LD_INT 101
89674: PUSH
89675: LD_INT 102
89677: PUSH
89678: LD_INT 106
89680: PUSH
89681: LD_INT 116
89683: PUSH
89684: LD_INT 117
89686: PUSH
89687: LD_INT 118
89689: PUSH
89690: EMPTY
89691: LIST
89692: LIST
89693: LIST
89694: LIST
89695: LIST
89696: LIST
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: ST_TO_ADDR
89702: GO 92777
89704: LD_INT 2
89706: DOUBLE
89707: EQUAL
89708: IFTRUE 89712
89710: GO 89796
89712: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
89713: LD_ADDR_VAR 0 2
89717: PUSH
89718: LD_INT 2
89720: PUSH
89721: LD_INT 4
89723: PUSH
89724: LD_INT 11
89726: PUSH
89727: LD_INT 12
89729: PUSH
89730: LD_INT 15
89732: PUSH
89733: LD_INT 16
89735: PUSH
89736: LD_INT 22
89738: PUSH
89739: LD_INT 23
89741: PUSH
89742: LD_INT 26
89744: PUSH
89745: EMPTY
89746: LIST
89747: LIST
89748: LIST
89749: LIST
89750: LIST
89751: LIST
89752: LIST
89753: LIST
89754: LIST
89755: PUSH
89756: LD_INT 101
89758: PUSH
89759: LD_INT 102
89761: PUSH
89762: LD_INT 105
89764: PUSH
89765: LD_INT 106
89767: PUSH
89768: LD_INT 108
89770: PUSH
89771: LD_INT 116
89773: PUSH
89774: LD_INT 117
89776: PUSH
89777: LD_INT 118
89779: PUSH
89780: EMPTY
89781: LIST
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: PUSH
89790: EMPTY
89791: LIST
89792: LIST
89793: ST_TO_ADDR
89794: GO 92777
89796: LD_INT 3
89798: DOUBLE
89799: EQUAL
89800: IFTRUE 89804
89802: GO 89892
89804: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
89805: LD_ADDR_VAR 0 2
89809: PUSH
89810: LD_INT 2
89812: PUSH
89813: LD_INT 4
89815: PUSH
89816: LD_INT 5
89818: PUSH
89819: LD_INT 11
89821: PUSH
89822: LD_INT 12
89824: PUSH
89825: LD_INT 15
89827: PUSH
89828: LD_INT 16
89830: PUSH
89831: LD_INT 22
89833: PUSH
89834: LD_INT 26
89836: PUSH
89837: LD_INT 36
89839: PUSH
89840: EMPTY
89841: LIST
89842: LIST
89843: LIST
89844: LIST
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: PUSH
89852: LD_INT 101
89854: PUSH
89855: LD_INT 102
89857: PUSH
89858: LD_INT 105
89860: PUSH
89861: LD_INT 106
89863: PUSH
89864: LD_INT 108
89866: PUSH
89867: LD_INT 116
89869: PUSH
89870: LD_INT 117
89872: PUSH
89873: LD_INT 118
89875: PUSH
89876: EMPTY
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: PUSH
89886: EMPTY
89887: LIST
89888: LIST
89889: ST_TO_ADDR
89890: GO 92777
89892: LD_INT 4
89894: DOUBLE
89895: EQUAL
89896: IFTRUE 89900
89898: GO 89996
89900: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89901: LD_ADDR_VAR 0 2
89905: PUSH
89906: LD_INT 2
89908: PUSH
89909: LD_INT 4
89911: PUSH
89912: LD_INT 5
89914: PUSH
89915: LD_INT 8
89917: PUSH
89918: LD_INT 11
89920: PUSH
89921: LD_INT 12
89923: PUSH
89924: LD_INT 15
89926: PUSH
89927: LD_INT 16
89929: PUSH
89930: LD_INT 22
89932: PUSH
89933: LD_INT 23
89935: PUSH
89936: LD_INT 26
89938: PUSH
89939: LD_INT 36
89941: PUSH
89942: EMPTY
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: LIST
89950: LIST
89951: LIST
89952: LIST
89953: LIST
89954: LIST
89955: PUSH
89956: LD_INT 101
89958: PUSH
89959: LD_INT 102
89961: PUSH
89962: LD_INT 105
89964: PUSH
89965: LD_INT 106
89967: PUSH
89968: LD_INT 108
89970: PUSH
89971: LD_INT 116
89973: PUSH
89974: LD_INT 117
89976: PUSH
89977: LD_INT 118
89979: PUSH
89980: EMPTY
89981: LIST
89982: LIST
89983: LIST
89984: LIST
89985: LIST
89986: LIST
89987: LIST
89988: LIST
89989: PUSH
89990: EMPTY
89991: LIST
89992: LIST
89993: ST_TO_ADDR
89994: GO 92777
89996: LD_INT 5
89998: DOUBLE
89999: EQUAL
90000: IFTRUE 90004
90002: GO 90116
90004: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
90005: LD_ADDR_VAR 0 2
90009: PUSH
90010: LD_INT 2
90012: PUSH
90013: LD_INT 4
90015: PUSH
90016: LD_INT 5
90018: PUSH
90019: LD_INT 6
90021: PUSH
90022: LD_INT 8
90024: PUSH
90025: LD_INT 11
90027: PUSH
90028: LD_INT 12
90030: PUSH
90031: LD_INT 15
90033: PUSH
90034: LD_INT 16
90036: PUSH
90037: LD_INT 22
90039: PUSH
90040: LD_INT 23
90042: PUSH
90043: LD_INT 25
90045: PUSH
90046: LD_INT 26
90048: PUSH
90049: LD_INT 36
90051: PUSH
90052: EMPTY
90053: LIST
90054: LIST
90055: LIST
90056: LIST
90057: LIST
90058: LIST
90059: LIST
90060: LIST
90061: LIST
90062: LIST
90063: LIST
90064: LIST
90065: LIST
90066: LIST
90067: PUSH
90068: LD_INT 101
90070: PUSH
90071: LD_INT 102
90073: PUSH
90074: LD_INT 105
90076: PUSH
90077: LD_INT 106
90079: PUSH
90080: LD_INT 108
90082: PUSH
90083: LD_INT 109
90085: PUSH
90086: LD_INT 112
90088: PUSH
90089: LD_INT 116
90091: PUSH
90092: LD_INT 117
90094: PUSH
90095: LD_INT 118
90097: PUSH
90098: EMPTY
90099: LIST
90100: LIST
90101: LIST
90102: LIST
90103: LIST
90104: LIST
90105: LIST
90106: LIST
90107: LIST
90108: LIST
90109: PUSH
90110: EMPTY
90111: LIST
90112: LIST
90113: ST_TO_ADDR
90114: GO 92777
90116: LD_INT 6
90118: DOUBLE
90119: EQUAL
90120: IFTRUE 90124
90122: GO 90256
90124: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
90125: LD_ADDR_VAR 0 2
90129: PUSH
90130: LD_INT 2
90132: PUSH
90133: LD_INT 4
90135: PUSH
90136: LD_INT 5
90138: PUSH
90139: LD_INT 6
90141: PUSH
90142: LD_INT 8
90144: PUSH
90145: LD_INT 11
90147: PUSH
90148: LD_INT 12
90150: PUSH
90151: LD_INT 15
90153: PUSH
90154: LD_INT 16
90156: PUSH
90157: LD_INT 20
90159: PUSH
90160: LD_INT 21
90162: PUSH
90163: LD_INT 22
90165: PUSH
90166: LD_INT 23
90168: PUSH
90169: LD_INT 25
90171: PUSH
90172: LD_INT 26
90174: PUSH
90175: LD_INT 30
90177: PUSH
90178: LD_INT 31
90180: PUSH
90181: LD_INT 32
90183: PUSH
90184: LD_INT 36
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: LIST
90194: LIST
90195: LIST
90196: LIST
90197: LIST
90198: LIST
90199: LIST
90200: LIST
90201: LIST
90202: LIST
90203: LIST
90204: LIST
90205: LIST
90206: LIST
90207: PUSH
90208: LD_INT 101
90210: PUSH
90211: LD_INT 102
90213: PUSH
90214: LD_INT 105
90216: PUSH
90217: LD_INT 106
90219: PUSH
90220: LD_INT 108
90222: PUSH
90223: LD_INT 109
90225: PUSH
90226: LD_INT 112
90228: PUSH
90229: LD_INT 116
90231: PUSH
90232: LD_INT 117
90234: PUSH
90235: LD_INT 118
90237: PUSH
90238: EMPTY
90239: LIST
90240: LIST
90241: LIST
90242: LIST
90243: LIST
90244: LIST
90245: LIST
90246: LIST
90247: LIST
90248: LIST
90249: PUSH
90250: EMPTY
90251: LIST
90252: LIST
90253: ST_TO_ADDR
90254: GO 92777
90256: LD_INT 7
90258: DOUBLE
90259: EQUAL
90260: IFTRUE 90264
90262: GO 90376
90264: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
90265: LD_ADDR_VAR 0 2
90269: PUSH
90270: LD_INT 2
90272: PUSH
90273: LD_INT 4
90275: PUSH
90276: LD_INT 5
90278: PUSH
90279: LD_INT 7
90281: PUSH
90282: LD_INT 11
90284: PUSH
90285: LD_INT 12
90287: PUSH
90288: LD_INT 15
90290: PUSH
90291: LD_INT 16
90293: PUSH
90294: LD_INT 20
90296: PUSH
90297: LD_INT 21
90299: PUSH
90300: LD_INT 22
90302: PUSH
90303: LD_INT 23
90305: PUSH
90306: LD_INT 25
90308: PUSH
90309: LD_INT 26
90311: PUSH
90312: EMPTY
90313: LIST
90314: LIST
90315: LIST
90316: LIST
90317: LIST
90318: LIST
90319: LIST
90320: LIST
90321: LIST
90322: LIST
90323: LIST
90324: LIST
90325: LIST
90326: LIST
90327: PUSH
90328: LD_INT 101
90330: PUSH
90331: LD_INT 102
90333: PUSH
90334: LD_INT 103
90336: PUSH
90337: LD_INT 105
90339: PUSH
90340: LD_INT 106
90342: PUSH
90343: LD_INT 108
90345: PUSH
90346: LD_INT 112
90348: PUSH
90349: LD_INT 116
90351: PUSH
90352: LD_INT 117
90354: PUSH
90355: LD_INT 118
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: PUSH
90370: EMPTY
90371: LIST
90372: LIST
90373: ST_TO_ADDR
90374: GO 92777
90376: LD_INT 8
90378: DOUBLE
90379: EQUAL
90380: IFTRUE 90384
90382: GO 90524
90384: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
90385: LD_ADDR_VAR 0 2
90389: PUSH
90390: LD_INT 2
90392: PUSH
90393: LD_INT 4
90395: PUSH
90396: LD_INT 5
90398: PUSH
90399: LD_INT 6
90401: PUSH
90402: LD_INT 7
90404: PUSH
90405: LD_INT 8
90407: PUSH
90408: LD_INT 11
90410: PUSH
90411: LD_INT 12
90413: PUSH
90414: LD_INT 15
90416: PUSH
90417: LD_INT 16
90419: PUSH
90420: LD_INT 20
90422: PUSH
90423: LD_INT 21
90425: PUSH
90426: LD_INT 22
90428: PUSH
90429: LD_INT 23
90431: PUSH
90432: LD_INT 25
90434: PUSH
90435: LD_INT 26
90437: PUSH
90438: LD_INT 30
90440: PUSH
90441: LD_INT 31
90443: PUSH
90444: LD_INT 32
90446: PUSH
90447: LD_INT 36
90449: PUSH
90450: EMPTY
90451: LIST
90452: LIST
90453: LIST
90454: LIST
90455: LIST
90456: LIST
90457: LIST
90458: LIST
90459: LIST
90460: LIST
90461: LIST
90462: LIST
90463: LIST
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: LIST
90469: LIST
90470: LIST
90471: PUSH
90472: LD_INT 101
90474: PUSH
90475: LD_INT 102
90477: PUSH
90478: LD_INT 103
90480: PUSH
90481: LD_INT 105
90483: PUSH
90484: LD_INT 106
90486: PUSH
90487: LD_INT 108
90489: PUSH
90490: LD_INT 109
90492: PUSH
90493: LD_INT 112
90495: PUSH
90496: LD_INT 116
90498: PUSH
90499: LD_INT 117
90501: PUSH
90502: LD_INT 118
90504: PUSH
90505: EMPTY
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: PUSH
90518: EMPTY
90519: LIST
90520: LIST
90521: ST_TO_ADDR
90522: GO 92777
90524: LD_INT 9
90526: DOUBLE
90527: EQUAL
90528: IFTRUE 90532
90530: GO 90680
90532: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
90533: LD_ADDR_VAR 0 2
90537: PUSH
90538: LD_INT 2
90540: PUSH
90541: LD_INT 4
90543: PUSH
90544: LD_INT 5
90546: PUSH
90547: LD_INT 6
90549: PUSH
90550: LD_INT 7
90552: PUSH
90553: LD_INT 8
90555: PUSH
90556: LD_INT 11
90558: PUSH
90559: LD_INT 12
90561: PUSH
90562: LD_INT 15
90564: PUSH
90565: LD_INT 16
90567: PUSH
90568: LD_INT 20
90570: PUSH
90571: LD_INT 21
90573: PUSH
90574: LD_INT 22
90576: PUSH
90577: LD_INT 23
90579: PUSH
90580: LD_INT 25
90582: PUSH
90583: LD_INT 26
90585: PUSH
90586: LD_INT 28
90588: PUSH
90589: LD_INT 30
90591: PUSH
90592: LD_INT 31
90594: PUSH
90595: LD_INT 32
90597: PUSH
90598: LD_INT 36
90600: PUSH
90601: EMPTY
90602: LIST
90603: LIST
90604: LIST
90605: LIST
90606: LIST
90607: LIST
90608: LIST
90609: LIST
90610: LIST
90611: LIST
90612: LIST
90613: LIST
90614: LIST
90615: LIST
90616: LIST
90617: LIST
90618: LIST
90619: LIST
90620: LIST
90621: LIST
90622: LIST
90623: PUSH
90624: LD_INT 101
90626: PUSH
90627: LD_INT 102
90629: PUSH
90630: LD_INT 103
90632: PUSH
90633: LD_INT 105
90635: PUSH
90636: LD_INT 106
90638: PUSH
90639: LD_INT 108
90641: PUSH
90642: LD_INT 109
90644: PUSH
90645: LD_INT 112
90647: PUSH
90648: LD_INT 114
90650: PUSH
90651: LD_INT 116
90653: PUSH
90654: LD_INT 117
90656: PUSH
90657: LD_INT 118
90659: PUSH
90660: EMPTY
90661: LIST
90662: LIST
90663: LIST
90664: LIST
90665: LIST
90666: LIST
90667: LIST
90668: LIST
90669: LIST
90670: LIST
90671: LIST
90672: LIST
90673: PUSH
90674: EMPTY
90675: LIST
90676: LIST
90677: ST_TO_ADDR
90678: GO 92777
90680: LD_INT 10
90682: DOUBLE
90683: EQUAL
90684: IFTRUE 90688
90686: GO 90884
90688: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
90689: LD_ADDR_VAR 0 2
90693: PUSH
90694: LD_INT 2
90696: PUSH
90697: LD_INT 4
90699: PUSH
90700: LD_INT 5
90702: PUSH
90703: LD_INT 6
90705: PUSH
90706: LD_INT 7
90708: PUSH
90709: LD_INT 8
90711: PUSH
90712: LD_INT 9
90714: PUSH
90715: LD_INT 10
90717: PUSH
90718: LD_INT 11
90720: PUSH
90721: LD_INT 12
90723: PUSH
90724: LD_INT 13
90726: PUSH
90727: LD_INT 14
90729: PUSH
90730: LD_INT 15
90732: PUSH
90733: LD_INT 16
90735: PUSH
90736: LD_INT 17
90738: PUSH
90739: LD_INT 18
90741: PUSH
90742: LD_INT 19
90744: PUSH
90745: LD_INT 20
90747: PUSH
90748: LD_INT 21
90750: PUSH
90751: LD_INT 22
90753: PUSH
90754: LD_INT 23
90756: PUSH
90757: LD_INT 24
90759: PUSH
90760: LD_INT 25
90762: PUSH
90763: LD_INT 26
90765: PUSH
90766: LD_INT 28
90768: PUSH
90769: LD_INT 30
90771: PUSH
90772: LD_INT 31
90774: PUSH
90775: LD_INT 32
90777: PUSH
90778: LD_INT 36
90780: PUSH
90781: EMPTY
90782: LIST
90783: LIST
90784: LIST
90785: LIST
90786: LIST
90787: LIST
90788: LIST
90789: LIST
90790: LIST
90791: LIST
90792: LIST
90793: LIST
90794: LIST
90795: LIST
90796: LIST
90797: LIST
90798: LIST
90799: LIST
90800: LIST
90801: LIST
90802: LIST
90803: LIST
90804: LIST
90805: LIST
90806: LIST
90807: LIST
90808: LIST
90809: LIST
90810: LIST
90811: PUSH
90812: LD_INT 101
90814: PUSH
90815: LD_INT 102
90817: PUSH
90818: LD_INT 103
90820: PUSH
90821: LD_INT 104
90823: PUSH
90824: LD_INT 105
90826: PUSH
90827: LD_INT 106
90829: PUSH
90830: LD_INT 107
90832: PUSH
90833: LD_INT 108
90835: PUSH
90836: LD_INT 109
90838: PUSH
90839: LD_INT 110
90841: PUSH
90842: LD_INT 111
90844: PUSH
90845: LD_INT 112
90847: PUSH
90848: LD_INT 114
90850: PUSH
90851: LD_INT 116
90853: PUSH
90854: LD_INT 117
90856: PUSH
90857: LD_INT 118
90859: PUSH
90860: EMPTY
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: PUSH
90878: EMPTY
90879: LIST
90880: LIST
90881: ST_TO_ADDR
90882: GO 92777
90884: LD_INT 11
90886: DOUBLE
90887: EQUAL
90888: IFTRUE 90892
90890: GO 91096
90892: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
90893: LD_ADDR_VAR 0 2
90897: PUSH
90898: LD_INT 2
90900: PUSH
90901: LD_INT 3
90903: PUSH
90904: LD_INT 4
90906: PUSH
90907: LD_INT 5
90909: PUSH
90910: LD_INT 6
90912: PUSH
90913: LD_INT 7
90915: PUSH
90916: LD_INT 8
90918: PUSH
90919: LD_INT 9
90921: PUSH
90922: LD_INT 10
90924: PUSH
90925: LD_INT 11
90927: PUSH
90928: LD_INT 12
90930: PUSH
90931: LD_INT 13
90933: PUSH
90934: LD_INT 14
90936: PUSH
90937: LD_INT 15
90939: PUSH
90940: LD_INT 16
90942: PUSH
90943: LD_INT 17
90945: PUSH
90946: LD_INT 18
90948: PUSH
90949: LD_INT 19
90951: PUSH
90952: LD_INT 20
90954: PUSH
90955: LD_INT 21
90957: PUSH
90958: LD_INT 22
90960: PUSH
90961: LD_INT 23
90963: PUSH
90964: LD_INT 24
90966: PUSH
90967: LD_INT 25
90969: PUSH
90970: LD_INT 26
90972: PUSH
90973: LD_INT 28
90975: PUSH
90976: LD_INT 30
90978: PUSH
90979: LD_INT 31
90981: PUSH
90982: LD_INT 32
90984: PUSH
90985: LD_INT 34
90987: PUSH
90988: LD_INT 36
90990: PUSH
90991: EMPTY
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: LIST
90997: LIST
90998: LIST
90999: LIST
91000: LIST
91001: LIST
91002: LIST
91003: LIST
91004: LIST
91005: LIST
91006: LIST
91007: LIST
91008: LIST
91009: LIST
91010: LIST
91011: LIST
91012: LIST
91013: LIST
91014: LIST
91015: LIST
91016: LIST
91017: LIST
91018: LIST
91019: LIST
91020: LIST
91021: LIST
91022: LIST
91023: PUSH
91024: LD_INT 101
91026: PUSH
91027: LD_INT 102
91029: PUSH
91030: LD_INT 103
91032: PUSH
91033: LD_INT 104
91035: PUSH
91036: LD_INT 105
91038: PUSH
91039: LD_INT 106
91041: PUSH
91042: LD_INT 107
91044: PUSH
91045: LD_INT 108
91047: PUSH
91048: LD_INT 109
91050: PUSH
91051: LD_INT 110
91053: PUSH
91054: LD_INT 111
91056: PUSH
91057: LD_INT 112
91059: PUSH
91060: LD_INT 114
91062: PUSH
91063: LD_INT 116
91065: PUSH
91066: LD_INT 117
91068: PUSH
91069: LD_INT 118
91071: PUSH
91072: EMPTY
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: ST_TO_ADDR
91094: GO 92777
91096: LD_INT 12
91098: DOUBLE
91099: EQUAL
91100: IFTRUE 91104
91102: GO 91324
91104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
91105: LD_ADDR_VAR 0 2
91109: PUSH
91110: LD_INT 1
91112: PUSH
91113: LD_INT 2
91115: PUSH
91116: LD_INT 3
91118: PUSH
91119: LD_INT 4
91121: PUSH
91122: LD_INT 5
91124: PUSH
91125: LD_INT 6
91127: PUSH
91128: LD_INT 7
91130: PUSH
91131: LD_INT 8
91133: PUSH
91134: LD_INT 9
91136: PUSH
91137: LD_INT 10
91139: PUSH
91140: LD_INT 11
91142: PUSH
91143: LD_INT 12
91145: PUSH
91146: LD_INT 13
91148: PUSH
91149: LD_INT 14
91151: PUSH
91152: LD_INT 15
91154: PUSH
91155: LD_INT 16
91157: PUSH
91158: LD_INT 17
91160: PUSH
91161: LD_INT 18
91163: PUSH
91164: LD_INT 19
91166: PUSH
91167: LD_INT 20
91169: PUSH
91170: LD_INT 21
91172: PUSH
91173: LD_INT 22
91175: PUSH
91176: LD_INT 23
91178: PUSH
91179: LD_INT 24
91181: PUSH
91182: LD_INT 25
91184: PUSH
91185: LD_INT 26
91187: PUSH
91188: LD_INT 27
91190: PUSH
91191: LD_INT 28
91193: PUSH
91194: LD_INT 30
91196: PUSH
91197: LD_INT 31
91199: PUSH
91200: LD_INT 32
91202: PUSH
91203: LD_INT 33
91205: PUSH
91206: LD_INT 34
91208: PUSH
91209: LD_INT 36
91211: PUSH
91212: EMPTY
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: PUSH
91248: LD_INT 101
91250: PUSH
91251: LD_INT 102
91253: PUSH
91254: LD_INT 103
91256: PUSH
91257: LD_INT 104
91259: PUSH
91260: LD_INT 105
91262: PUSH
91263: LD_INT 106
91265: PUSH
91266: LD_INT 107
91268: PUSH
91269: LD_INT 108
91271: PUSH
91272: LD_INT 109
91274: PUSH
91275: LD_INT 110
91277: PUSH
91278: LD_INT 111
91280: PUSH
91281: LD_INT 112
91283: PUSH
91284: LD_INT 113
91286: PUSH
91287: LD_INT 114
91289: PUSH
91290: LD_INT 116
91292: PUSH
91293: LD_INT 117
91295: PUSH
91296: LD_INT 118
91298: PUSH
91299: EMPTY
91300: LIST
91301: LIST
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: ST_TO_ADDR
91322: GO 92777
91324: LD_INT 13
91326: DOUBLE
91327: EQUAL
91328: IFTRUE 91332
91330: GO 91540
91332: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
91333: LD_ADDR_VAR 0 2
91337: PUSH
91338: LD_INT 1
91340: PUSH
91341: LD_INT 2
91343: PUSH
91344: LD_INT 3
91346: PUSH
91347: LD_INT 4
91349: PUSH
91350: LD_INT 5
91352: PUSH
91353: LD_INT 8
91355: PUSH
91356: LD_INT 9
91358: PUSH
91359: LD_INT 10
91361: PUSH
91362: LD_INT 11
91364: PUSH
91365: LD_INT 12
91367: PUSH
91368: LD_INT 14
91370: PUSH
91371: LD_INT 15
91373: PUSH
91374: LD_INT 16
91376: PUSH
91377: LD_INT 17
91379: PUSH
91380: LD_INT 18
91382: PUSH
91383: LD_INT 19
91385: PUSH
91386: LD_INT 20
91388: PUSH
91389: LD_INT 21
91391: PUSH
91392: LD_INT 22
91394: PUSH
91395: LD_INT 23
91397: PUSH
91398: LD_INT 24
91400: PUSH
91401: LD_INT 25
91403: PUSH
91404: LD_INT 26
91406: PUSH
91407: LD_INT 27
91409: PUSH
91410: LD_INT 28
91412: PUSH
91413: LD_INT 30
91415: PUSH
91416: LD_INT 31
91418: PUSH
91419: LD_INT 32
91421: PUSH
91422: LD_INT 33
91424: PUSH
91425: LD_INT 34
91427: PUSH
91428: LD_INT 36
91430: PUSH
91431: EMPTY
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: PUSH
91464: LD_INT 101
91466: PUSH
91467: LD_INT 102
91469: PUSH
91470: LD_INT 103
91472: PUSH
91473: LD_INT 104
91475: PUSH
91476: LD_INT 105
91478: PUSH
91479: LD_INT 106
91481: PUSH
91482: LD_INT 107
91484: PUSH
91485: LD_INT 108
91487: PUSH
91488: LD_INT 109
91490: PUSH
91491: LD_INT 110
91493: PUSH
91494: LD_INT 111
91496: PUSH
91497: LD_INT 112
91499: PUSH
91500: LD_INT 113
91502: PUSH
91503: LD_INT 114
91505: PUSH
91506: LD_INT 116
91508: PUSH
91509: LD_INT 117
91511: PUSH
91512: LD_INT 118
91514: PUSH
91515: EMPTY
91516: LIST
91517: LIST
91518: LIST
91519: LIST
91520: LIST
91521: LIST
91522: LIST
91523: LIST
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: PUSH
91534: EMPTY
91535: LIST
91536: LIST
91537: ST_TO_ADDR
91538: GO 92777
91540: LD_INT 14
91542: DOUBLE
91543: EQUAL
91544: IFTRUE 91548
91546: GO 91772
91548: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
91549: LD_ADDR_VAR 0 2
91553: PUSH
91554: LD_INT 1
91556: PUSH
91557: LD_INT 2
91559: PUSH
91560: LD_INT 3
91562: PUSH
91563: LD_INT 4
91565: PUSH
91566: LD_INT 5
91568: PUSH
91569: LD_INT 6
91571: PUSH
91572: LD_INT 7
91574: PUSH
91575: LD_INT 8
91577: PUSH
91578: LD_INT 9
91580: PUSH
91581: LD_INT 10
91583: PUSH
91584: LD_INT 11
91586: PUSH
91587: LD_INT 12
91589: PUSH
91590: LD_INT 13
91592: PUSH
91593: LD_INT 14
91595: PUSH
91596: LD_INT 15
91598: PUSH
91599: LD_INT 16
91601: PUSH
91602: LD_INT 17
91604: PUSH
91605: LD_INT 18
91607: PUSH
91608: LD_INT 19
91610: PUSH
91611: LD_INT 20
91613: PUSH
91614: LD_INT 21
91616: PUSH
91617: LD_INT 22
91619: PUSH
91620: LD_INT 23
91622: PUSH
91623: LD_INT 24
91625: PUSH
91626: LD_INT 25
91628: PUSH
91629: LD_INT 26
91631: PUSH
91632: LD_INT 27
91634: PUSH
91635: LD_INT 28
91637: PUSH
91638: LD_INT 29
91640: PUSH
91641: LD_INT 30
91643: PUSH
91644: LD_INT 31
91646: PUSH
91647: LD_INT 32
91649: PUSH
91650: LD_INT 33
91652: PUSH
91653: LD_INT 34
91655: PUSH
91656: LD_INT 36
91658: PUSH
91659: EMPTY
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: LIST
91669: LIST
91670: LIST
91671: LIST
91672: LIST
91673: LIST
91674: LIST
91675: LIST
91676: LIST
91677: LIST
91678: LIST
91679: LIST
91680: LIST
91681: LIST
91682: LIST
91683: LIST
91684: LIST
91685: LIST
91686: LIST
91687: LIST
91688: LIST
91689: LIST
91690: LIST
91691: LIST
91692: LIST
91693: LIST
91694: LIST
91695: PUSH
91696: LD_INT 101
91698: PUSH
91699: LD_INT 102
91701: PUSH
91702: LD_INT 103
91704: PUSH
91705: LD_INT 104
91707: PUSH
91708: LD_INT 105
91710: PUSH
91711: LD_INT 106
91713: PUSH
91714: LD_INT 107
91716: PUSH
91717: LD_INT 108
91719: PUSH
91720: LD_INT 109
91722: PUSH
91723: LD_INT 110
91725: PUSH
91726: LD_INT 111
91728: PUSH
91729: LD_INT 112
91731: PUSH
91732: LD_INT 113
91734: PUSH
91735: LD_INT 114
91737: PUSH
91738: LD_INT 116
91740: PUSH
91741: LD_INT 117
91743: PUSH
91744: LD_INT 118
91746: PUSH
91747: EMPTY
91748: LIST
91749: LIST
91750: LIST
91751: LIST
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: LIST
91757: LIST
91758: LIST
91759: LIST
91760: LIST
91761: LIST
91762: LIST
91763: LIST
91764: LIST
91765: PUSH
91766: EMPTY
91767: LIST
91768: LIST
91769: ST_TO_ADDR
91770: GO 92777
91772: LD_INT 15
91774: DOUBLE
91775: EQUAL
91776: IFTRUE 91780
91778: GO 92004
91780: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
91781: LD_ADDR_VAR 0 2
91785: PUSH
91786: LD_INT 1
91788: PUSH
91789: LD_INT 2
91791: PUSH
91792: LD_INT 3
91794: PUSH
91795: LD_INT 4
91797: PUSH
91798: LD_INT 5
91800: PUSH
91801: LD_INT 6
91803: PUSH
91804: LD_INT 7
91806: PUSH
91807: LD_INT 8
91809: PUSH
91810: LD_INT 9
91812: PUSH
91813: LD_INT 10
91815: PUSH
91816: LD_INT 11
91818: PUSH
91819: LD_INT 12
91821: PUSH
91822: LD_INT 13
91824: PUSH
91825: LD_INT 14
91827: PUSH
91828: LD_INT 15
91830: PUSH
91831: LD_INT 16
91833: PUSH
91834: LD_INT 17
91836: PUSH
91837: LD_INT 18
91839: PUSH
91840: LD_INT 19
91842: PUSH
91843: LD_INT 20
91845: PUSH
91846: LD_INT 21
91848: PUSH
91849: LD_INT 22
91851: PUSH
91852: LD_INT 23
91854: PUSH
91855: LD_INT 24
91857: PUSH
91858: LD_INT 25
91860: PUSH
91861: LD_INT 26
91863: PUSH
91864: LD_INT 27
91866: PUSH
91867: LD_INT 28
91869: PUSH
91870: LD_INT 29
91872: PUSH
91873: LD_INT 30
91875: PUSH
91876: LD_INT 31
91878: PUSH
91879: LD_INT 32
91881: PUSH
91882: LD_INT 33
91884: PUSH
91885: LD_INT 34
91887: PUSH
91888: LD_INT 36
91890: PUSH
91891: EMPTY
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: LIST
91901: LIST
91902: LIST
91903: LIST
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: LIST
91913: LIST
91914: LIST
91915: LIST
91916: LIST
91917: LIST
91918: LIST
91919: LIST
91920: LIST
91921: LIST
91922: LIST
91923: LIST
91924: LIST
91925: LIST
91926: LIST
91927: PUSH
91928: LD_INT 101
91930: PUSH
91931: LD_INT 102
91933: PUSH
91934: LD_INT 103
91936: PUSH
91937: LD_INT 104
91939: PUSH
91940: LD_INT 105
91942: PUSH
91943: LD_INT 106
91945: PUSH
91946: LD_INT 107
91948: PUSH
91949: LD_INT 108
91951: PUSH
91952: LD_INT 109
91954: PUSH
91955: LD_INT 110
91957: PUSH
91958: LD_INT 111
91960: PUSH
91961: LD_INT 112
91963: PUSH
91964: LD_INT 113
91966: PUSH
91967: LD_INT 114
91969: PUSH
91970: LD_INT 116
91972: PUSH
91973: LD_INT 117
91975: PUSH
91976: LD_INT 118
91978: PUSH
91979: EMPTY
91980: LIST
91981: LIST
91982: LIST
91983: LIST
91984: LIST
91985: LIST
91986: LIST
91987: LIST
91988: LIST
91989: LIST
91990: LIST
91991: LIST
91992: LIST
91993: LIST
91994: LIST
91995: LIST
91996: LIST
91997: PUSH
91998: EMPTY
91999: LIST
92000: LIST
92001: ST_TO_ADDR
92002: GO 92777
92004: LD_INT 16
92006: DOUBLE
92007: EQUAL
92008: IFTRUE 92012
92010: GO 92148
92012: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
92013: LD_ADDR_VAR 0 2
92017: PUSH
92018: LD_INT 2
92020: PUSH
92021: LD_INT 4
92023: PUSH
92024: LD_INT 5
92026: PUSH
92027: LD_INT 7
92029: PUSH
92030: LD_INT 11
92032: PUSH
92033: LD_INT 12
92035: PUSH
92036: LD_INT 15
92038: PUSH
92039: LD_INT 16
92041: PUSH
92042: LD_INT 20
92044: PUSH
92045: LD_INT 21
92047: PUSH
92048: LD_INT 22
92050: PUSH
92051: LD_INT 23
92053: PUSH
92054: LD_INT 25
92056: PUSH
92057: LD_INT 26
92059: PUSH
92060: LD_INT 30
92062: PUSH
92063: LD_INT 31
92065: PUSH
92066: LD_INT 32
92068: PUSH
92069: LD_INT 33
92071: PUSH
92072: LD_INT 34
92074: PUSH
92075: EMPTY
92076: LIST
92077: LIST
92078: LIST
92079: LIST
92080: LIST
92081: LIST
92082: LIST
92083: LIST
92084: LIST
92085: LIST
92086: LIST
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: PUSH
92096: LD_INT 101
92098: PUSH
92099: LD_INT 102
92101: PUSH
92102: LD_INT 103
92104: PUSH
92105: LD_INT 106
92107: PUSH
92108: LD_INT 108
92110: PUSH
92111: LD_INT 112
92113: PUSH
92114: LD_INT 113
92116: PUSH
92117: LD_INT 114
92119: PUSH
92120: LD_INT 116
92122: PUSH
92123: LD_INT 117
92125: PUSH
92126: LD_INT 118
92128: PUSH
92129: EMPTY
92130: LIST
92131: LIST
92132: LIST
92133: LIST
92134: LIST
92135: LIST
92136: LIST
92137: LIST
92138: LIST
92139: LIST
92140: LIST
92141: PUSH
92142: EMPTY
92143: LIST
92144: LIST
92145: ST_TO_ADDR
92146: GO 92777
92148: LD_INT 17
92150: DOUBLE
92151: EQUAL
92152: IFTRUE 92156
92154: GO 92380
92156: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
92157: LD_ADDR_VAR 0 2
92161: PUSH
92162: LD_INT 1
92164: PUSH
92165: LD_INT 2
92167: PUSH
92168: LD_INT 3
92170: PUSH
92171: LD_INT 4
92173: PUSH
92174: LD_INT 5
92176: PUSH
92177: LD_INT 6
92179: PUSH
92180: LD_INT 7
92182: PUSH
92183: LD_INT 8
92185: PUSH
92186: LD_INT 9
92188: PUSH
92189: LD_INT 10
92191: PUSH
92192: LD_INT 11
92194: PUSH
92195: LD_INT 12
92197: PUSH
92198: LD_INT 13
92200: PUSH
92201: LD_INT 14
92203: PUSH
92204: LD_INT 15
92206: PUSH
92207: LD_INT 16
92209: PUSH
92210: LD_INT 17
92212: PUSH
92213: LD_INT 18
92215: PUSH
92216: LD_INT 19
92218: PUSH
92219: LD_INT 20
92221: PUSH
92222: LD_INT 21
92224: PUSH
92225: LD_INT 22
92227: PUSH
92228: LD_INT 23
92230: PUSH
92231: LD_INT 24
92233: PUSH
92234: LD_INT 25
92236: PUSH
92237: LD_INT 26
92239: PUSH
92240: LD_INT 27
92242: PUSH
92243: LD_INT 28
92245: PUSH
92246: LD_INT 29
92248: PUSH
92249: LD_INT 30
92251: PUSH
92252: LD_INT 31
92254: PUSH
92255: LD_INT 32
92257: PUSH
92258: LD_INT 33
92260: PUSH
92261: LD_INT 34
92263: PUSH
92264: LD_INT 36
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: LIST
92277: LIST
92278: LIST
92279: LIST
92280: LIST
92281: LIST
92282: LIST
92283: LIST
92284: LIST
92285: LIST
92286: LIST
92287: LIST
92288: LIST
92289: LIST
92290: LIST
92291: LIST
92292: LIST
92293: LIST
92294: LIST
92295: LIST
92296: LIST
92297: LIST
92298: LIST
92299: LIST
92300: LIST
92301: LIST
92302: LIST
92303: PUSH
92304: LD_INT 101
92306: PUSH
92307: LD_INT 102
92309: PUSH
92310: LD_INT 103
92312: PUSH
92313: LD_INT 104
92315: PUSH
92316: LD_INT 105
92318: PUSH
92319: LD_INT 106
92321: PUSH
92322: LD_INT 107
92324: PUSH
92325: LD_INT 108
92327: PUSH
92328: LD_INT 109
92330: PUSH
92331: LD_INT 110
92333: PUSH
92334: LD_INT 111
92336: PUSH
92337: LD_INT 112
92339: PUSH
92340: LD_INT 113
92342: PUSH
92343: LD_INT 114
92345: PUSH
92346: LD_INT 116
92348: PUSH
92349: LD_INT 117
92351: PUSH
92352: LD_INT 118
92354: PUSH
92355: EMPTY
92356: LIST
92357: LIST
92358: LIST
92359: LIST
92360: LIST
92361: LIST
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: LIST
92373: PUSH
92374: EMPTY
92375: LIST
92376: LIST
92377: ST_TO_ADDR
92378: GO 92777
92380: LD_INT 18
92382: DOUBLE
92383: EQUAL
92384: IFTRUE 92388
92386: GO 92536
92388: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
92389: LD_ADDR_VAR 0 2
92393: PUSH
92394: LD_INT 2
92396: PUSH
92397: LD_INT 4
92399: PUSH
92400: LD_INT 5
92402: PUSH
92403: LD_INT 7
92405: PUSH
92406: LD_INT 11
92408: PUSH
92409: LD_INT 12
92411: PUSH
92412: LD_INT 15
92414: PUSH
92415: LD_INT 16
92417: PUSH
92418: LD_INT 20
92420: PUSH
92421: LD_INT 21
92423: PUSH
92424: LD_INT 22
92426: PUSH
92427: LD_INT 23
92429: PUSH
92430: LD_INT 25
92432: PUSH
92433: LD_INT 26
92435: PUSH
92436: LD_INT 30
92438: PUSH
92439: LD_INT 31
92441: PUSH
92442: LD_INT 32
92444: PUSH
92445: LD_INT 33
92447: PUSH
92448: LD_INT 34
92450: PUSH
92451: LD_INT 35
92453: PUSH
92454: LD_INT 36
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: LIST
92461: LIST
92462: LIST
92463: LIST
92464: LIST
92465: LIST
92466: LIST
92467: LIST
92468: LIST
92469: LIST
92470: LIST
92471: LIST
92472: LIST
92473: LIST
92474: LIST
92475: LIST
92476: LIST
92477: LIST
92478: LIST
92479: PUSH
92480: LD_INT 101
92482: PUSH
92483: LD_INT 102
92485: PUSH
92486: LD_INT 103
92488: PUSH
92489: LD_INT 106
92491: PUSH
92492: LD_INT 108
92494: PUSH
92495: LD_INT 112
92497: PUSH
92498: LD_INT 113
92500: PUSH
92501: LD_INT 114
92503: PUSH
92504: LD_INT 115
92506: PUSH
92507: LD_INT 116
92509: PUSH
92510: LD_INT 117
92512: PUSH
92513: LD_INT 118
92515: PUSH
92516: EMPTY
92517: LIST
92518: LIST
92519: LIST
92520: LIST
92521: LIST
92522: LIST
92523: LIST
92524: LIST
92525: LIST
92526: LIST
92527: LIST
92528: LIST
92529: PUSH
92530: EMPTY
92531: LIST
92532: LIST
92533: ST_TO_ADDR
92534: GO 92777
92536: LD_INT 19
92538: DOUBLE
92539: EQUAL
92540: IFTRUE 92544
92542: GO 92776
92544: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
92545: LD_ADDR_VAR 0 2
92549: PUSH
92550: LD_INT 1
92552: PUSH
92553: LD_INT 2
92555: PUSH
92556: LD_INT 3
92558: PUSH
92559: LD_INT 4
92561: PUSH
92562: LD_INT 5
92564: PUSH
92565: LD_INT 6
92567: PUSH
92568: LD_INT 7
92570: PUSH
92571: LD_INT 8
92573: PUSH
92574: LD_INT 9
92576: PUSH
92577: LD_INT 10
92579: PUSH
92580: LD_INT 11
92582: PUSH
92583: LD_INT 12
92585: PUSH
92586: LD_INT 13
92588: PUSH
92589: LD_INT 14
92591: PUSH
92592: LD_INT 15
92594: PUSH
92595: LD_INT 16
92597: PUSH
92598: LD_INT 17
92600: PUSH
92601: LD_INT 18
92603: PUSH
92604: LD_INT 19
92606: PUSH
92607: LD_INT 20
92609: PUSH
92610: LD_INT 21
92612: PUSH
92613: LD_INT 22
92615: PUSH
92616: LD_INT 23
92618: PUSH
92619: LD_INT 24
92621: PUSH
92622: LD_INT 25
92624: PUSH
92625: LD_INT 26
92627: PUSH
92628: LD_INT 27
92630: PUSH
92631: LD_INT 28
92633: PUSH
92634: LD_INT 29
92636: PUSH
92637: LD_INT 30
92639: PUSH
92640: LD_INT 31
92642: PUSH
92643: LD_INT 32
92645: PUSH
92646: LD_INT 33
92648: PUSH
92649: LD_INT 34
92651: PUSH
92652: LD_INT 35
92654: PUSH
92655: LD_INT 36
92657: PUSH
92658: EMPTY
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: LIST
92669: LIST
92670: LIST
92671: LIST
92672: LIST
92673: LIST
92674: LIST
92675: LIST
92676: LIST
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: LIST
92686: LIST
92687: LIST
92688: LIST
92689: LIST
92690: LIST
92691: LIST
92692: LIST
92693: LIST
92694: LIST
92695: PUSH
92696: LD_INT 101
92698: PUSH
92699: LD_INT 102
92701: PUSH
92702: LD_INT 103
92704: PUSH
92705: LD_INT 104
92707: PUSH
92708: LD_INT 105
92710: PUSH
92711: LD_INT 106
92713: PUSH
92714: LD_INT 107
92716: PUSH
92717: LD_INT 108
92719: PUSH
92720: LD_INT 109
92722: PUSH
92723: LD_INT 110
92725: PUSH
92726: LD_INT 111
92728: PUSH
92729: LD_INT 112
92731: PUSH
92732: LD_INT 113
92734: PUSH
92735: LD_INT 114
92737: PUSH
92738: LD_INT 115
92740: PUSH
92741: LD_INT 116
92743: PUSH
92744: LD_INT 117
92746: PUSH
92747: LD_INT 118
92749: PUSH
92750: EMPTY
92751: LIST
92752: LIST
92753: LIST
92754: LIST
92755: LIST
92756: LIST
92757: LIST
92758: LIST
92759: LIST
92760: LIST
92761: LIST
92762: LIST
92763: LIST
92764: LIST
92765: LIST
92766: LIST
92767: LIST
92768: LIST
92769: PUSH
92770: EMPTY
92771: LIST
92772: LIST
92773: ST_TO_ADDR
92774: GO 92777
92776: POP
// end else
92777: GO 93008
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
92779: LD_ADDR_VAR 0 2
92783: PUSH
92784: LD_INT 1
92786: PUSH
92787: LD_INT 2
92789: PUSH
92790: LD_INT 3
92792: PUSH
92793: LD_INT 4
92795: PUSH
92796: LD_INT 5
92798: PUSH
92799: LD_INT 6
92801: PUSH
92802: LD_INT 7
92804: PUSH
92805: LD_INT 8
92807: PUSH
92808: LD_INT 9
92810: PUSH
92811: LD_INT 10
92813: PUSH
92814: LD_INT 11
92816: PUSH
92817: LD_INT 12
92819: PUSH
92820: LD_INT 13
92822: PUSH
92823: LD_INT 14
92825: PUSH
92826: LD_INT 15
92828: PUSH
92829: LD_INT 16
92831: PUSH
92832: LD_INT 17
92834: PUSH
92835: LD_INT 18
92837: PUSH
92838: LD_INT 19
92840: PUSH
92841: LD_INT 20
92843: PUSH
92844: LD_INT 21
92846: PUSH
92847: LD_INT 22
92849: PUSH
92850: LD_INT 23
92852: PUSH
92853: LD_INT 24
92855: PUSH
92856: LD_INT 25
92858: PUSH
92859: LD_INT 26
92861: PUSH
92862: LD_INT 27
92864: PUSH
92865: LD_INT 28
92867: PUSH
92868: LD_INT 29
92870: PUSH
92871: LD_INT 30
92873: PUSH
92874: LD_INT 31
92876: PUSH
92877: LD_INT 32
92879: PUSH
92880: LD_INT 33
92882: PUSH
92883: LD_INT 34
92885: PUSH
92886: LD_INT 35
92888: PUSH
92889: LD_INT 36
92891: PUSH
92892: EMPTY
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: LIST
92903: LIST
92904: LIST
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: PUSH
92930: LD_INT 101
92932: PUSH
92933: LD_INT 102
92935: PUSH
92936: LD_INT 103
92938: PUSH
92939: LD_INT 104
92941: PUSH
92942: LD_INT 105
92944: PUSH
92945: LD_INT 106
92947: PUSH
92948: LD_INT 107
92950: PUSH
92951: LD_INT 108
92953: PUSH
92954: LD_INT 109
92956: PUSH
92957: LD_INT 110
92959: PUSH
92960: LD_INT 111
92962: PUSH
92963: LD_INT 112
92965: PUSH
92966: LD_INT 113
92968: PUSH
92969: LD_INT 114
92971: PUSH
92972: LD_INT 115
92974: PUSH
92975: LD_INT 116
92977: PUSH
92978: LD_INT 117
92980: PUSH
92981: LD_INT 118
92983: PUSH
92984: EMPTY
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: ST_TO_ADDR
// if result then
93008: LD_VAR 0 2
93012: IFFALSE 93798
// begin normal :=  ;
93014: LD_ADDR_VAR 0 5
93018: PUSH
93019: LD_STRING 
93021: ST_TO_ADDR
// hardcore :=  ;
93022: LD_ADDR_VAR 0 6
93026: PUSH
93027: LD_STRING 
93029: ST_TO_ADDR
// active :=  ;
93030: LD_ADDR_VAR 0 7
93034: PUSH
93035: LD_STRING 
93037: ST_TO_ADDR
// for i = 1 to normalCounter do
93038: LD_ADDR_VAR 0 8
93042: PUSH
93043: DOUBLE
93044: LD_INT 1
93046: DEC
93047: ST_TO_ADDR
93048: LD_EXP 108
93052: PUSH
93053: FOR_TO
93054: IFFALSE 93155
// begin tmp := 0 ;
93056: LD_ADDR_VAR 0 3
93060: PUSH
93061: LD_STRING 0
93063: ST_TO_ADDR
// if result [ 1 ] then
93064: LD_VAR 0 2
93068: PUSH
93069: LD_INT 1
93071: ARRAY
93072: IFFALSE 93137
// if result [ 1 ] [ 1 ] = i then
93074: LD_VAR 0 2
93078: PUSH
93079: LD_INT 1
93081: ARRAY
93082: PUSH
93083: LD_INT 1
93085: ARRAY
93086: PUSH
93087: LD_VAR 0 8
93091: EQUAL
93092: IFFALSE 93137
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93094: LD_ADDR_VAR 0 2
93098: PUSH
93099: LD_VAR 0 2
93103: PPUSH
93104: LD_INT 1
93106: PPUSH
93107: LD_VAR 0 2
93111: PUSH
93112: LD_INT 1
93114: ARRAY
93115: PPUSH
93116: LD_INT 1
93118: PPUSH
93119: CALL_OW 3
93123: PPUSH
93124: CALL_OW 1
93128: ST_TO_ADDR
// tmp := 1 ;
93129: LD_ADDR_VAR 0 3
93133: PUSH
93134: LD_STRING 1
93136: ST_TO_ADDR
// end ; normal := normal & tmp ;
93137: LD_ADDR_VAR 0 5
93141: PUSH
93142: LD_VAR 0 5
93146: PUSH
93147: LD_VAR 0 3
93151: STR
93152: ST_TO_ADDR
// end ;
93153: GO 93053
93155: POP
93156: POP
// for i = 1 to hardcoreCounter do
93157: LD_ADDR_VAR 0 8
93161: PUSH
93162: DOUBLE
93163: LD_INT 1
93165: DEC
93166: ST_TO_ADDR
93167: LD_EXP 109
93171: PUSH
93172: FOR_TO
93173: IFFALSE 93278
// begin tmp := 0 ;
93175: LD_ADDR_VAR 0 3
93179: PUSH
93180: LD_STRING 0
93182: ST_TO_ADDR
// if result [ 2 ] then
93183: LD_VAR 0 2
93187: PUSH
93188: LD_INT 2
93190: ARRAY
93191: IFFALSE 93260
// if result [ 2 ] [ 1 ] = 100 + i then
93193: LD_VAR 0 2
93197: PUSH
93198: LD_INT 2
93200: ARRAY
93201: PUSH
93202: LD_INT 1
93204: ARRAY
93205: PUSH
93206: LD_INT 100
93208: PUSH
93209: LD_VAR 0 8
93213: PLUS
93214: EQUAL
93215: IFFALSE 93260
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93217: LD_ADDR_VAR 0 2
93221: PUSH
93222: LD_VAR 0 2
93226: PPUSH
93227: LD_INT 2
93229: PPUSH
93230: LD_VAR 0 2
93234: PUSH
93235: LD_INT 2
93237: ARRAY
93238: PPUSH
93239: LD_INT 1
93241: PPUSH
93242: CALL_OW 3
93246: PPUSH
93247: CALL_OW 1
93251: ST_TO_ADDR
// tmp := 1 ;
93252: LD_ADDR_VAR 0 3
93256: PUSH
93257: LD_STRING 1
93259: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93260: LD_ADDR_VAR 0 6
93264: PUSH
93265: LD_VAR 0 6
93269: PUSH
93270: LD_VAR 0 3
93274: STR
93275: ST_TO_ADDR
// end ;
93276: GO 93172
93278: POP
93279: POP
// if isGameLoad then
93280: LD_VAR 0 1
93284: IFFALSE 93759
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
93286: LD_ADDR_VAR 0 4
93290: PUSH
93291: LD_EXP 112
93295: PUSH
93296: LD_EXP 111
93300: PUSH
93301: LD_EXP 113
93305: PUSH
93306: LD_EXP 110
93310: PUSH
93311: LD_EXP 114
93315: PUSH
93316: LD_EXP 115
93320: PUSH
93321: LD_EXP 116
93325: PUSH
93326: LD_EXP 117
93330: PUSH
93331: LD_EXP 118
93335: PUSH
93336: LD_EXP 119
93340: PUSH
93341: LD_EXP 120
93345: PUSH
93346: LD_EXP 121
93350: PUSH
93351: LD_EXP 122
93355: PUSH
93356: LD_EXP 123
93360: PUSH
93361: LD_EXP 131
93365: PUSH
93366: LD_EXP 132
93370: PUSH
93371: LD_EXP 133
93375: PUSH
93376: LD_EXP 134
93380: PUSH
93381: LD_EXP 136
93385: PUSH
93386: LD_EXP 137
93390: PUSH
93391: LD_EXP 138
93395: PUSH
93396: LD_EXP 141
93400: PUSH
93401: LD_EXP 143
93405: PUSH
93406: LD_EXP 144
93410: PUSH
93411: LD_EXP 145
93415: PUSH
93416: LD_EXP 147
93420: PUSH
93421: LD_EXP 148
93425: PUSH
93426: LD_EXP 151
93430: PUSH
93431: LD_EXP 152
93435: PUSH
93436: LD_EXP 153
93440: PUSH
93441: LD_EXP 154
93445: PUSH
93446: LD_EXP 155
93450: PUSH
93451: LD_EXP 156
93455: PUSH
93456: LD_EXP 157
93460: PUSH
93461: LD_EXP 158
93465: PUSH
93466: LD_EXP 159
93470: PUSH
93471: LD_EXP 124
93475: PUSH
93476: LD_EXP 125
93480: PUSH
93481: LD_EXP 128
93485: PUSH
93486: LD_EXP 129
93490: PUSH
93491: LD_EXP 130
93495: PUSH
93496: LD_EXP 126
93500: PUSH
93501: LD_EXP 127
93505: PUSH
93506: LD_EXP 135
93510: PUSH
93511: LD_EXP 139
93515: PUSH
93516: LD_EXP 140
93520: PUSH
93521: LD_EXP 142
93525: PUSH
93526: LD_EXP 146
93530: PUSH
93531: LD_EXP 149
93535: PUSH
93536: LD_EXP 150
93540: PUSH
93541: LD_EXP 160
93545: PUSH
93546: LD_EXP 161
93550: PUSH
93551: LD_EXP 162
93555: PUSH
93556: LD_EXP 163
93560: PUSH
93561: EMPTY
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: LIST
93590: LIST
93591: LIST
93592: LIST
93593: LIST
93594: LIST
93595: LIST
93596: LIST
93597: LIST
93598: LIST
93599: LIST
93600: LIST
93601: LIST
93602: LIST
93603: LIST
93604: LIST
93605: LIST
93606: LIST
93607: LIST
93608: LIST
93609: LIST
93610: LIST
93611: LIST
93612: LIST
93613: LIST
93614: LIST
93615: LIST
93616: ST_TO_ADDR
// tmp :=  ;
93617: LD_ADDR_VAR 0 3
93621: PUSH
93622: LD_STRING 
93624: ST_TO_ADDR
// for i = 1 to normalCounter do
93625: LD_ADDR_VAR 0 8
93629: PUSH
93630: DOUBLE
93631: LD_INT 1
93633: DEC
93634: ST_TO_ADDR
93635: LD_EXP 108
93639: PUSH
93640: FOR_TO
93641: IFFALSE 93677
// begin if flags [ i ] then
93643: LD_VAR 0 4
93647: PUSH
93648: LD_VAR 0 8
93652: ARRAY
93653: IFFALSE 93675
// tmp := tmp & i & ; ;
93655: LD_ADDR_VAR 0 3
93659: PUSH
93660: LD_VAR 0 3
93664: PUSH
93665: LD_VAR 0 8
93669: STR
93670: PUSH
93671: LD_STRING ;
93673: STR
93674: ST_TO_ADDR
// end ;
93675: GO 93640
93677: POP
93678: POP
// for i = 1 to hardcoreCounter do
93679: LD_ADDR_VAR 0 8
93683: PUSH
93684: DOUBLE
93685: LD_INT 1
93687: DEC
93688: ST_TO_ADDR
93689: LD_EXP 109
93693: PUSH
93694: FOR_TO
93695: IFFALSE 93741
// begin if flags [ normalCounter + i ] then
93697: LD_VAR 0 4
93701: PUSH
93702: LD_EXP 108
93706: PUSH
93707: LD_VAR 0 8
93711: PLUS
93712: ARRAY
93713: IFFALSE 93739
// tmp := tmp & ( 100 + i ) & ; ;
93715: LD_ADDR_VAR 0 3
93719: PUSH
93720: LD_VAR 0 3
93724: PUSH
93725: LD_INT 100
93727: PUSH
93728: LD_VAR 0 8
93732: PLUS
93733: STR
93734: PUSH
93735: LD_STRING ;
93737: STR
93738: ST_TO_ADDR
// end ;
93739: GO 93694
93741: POP
93742: POP
// if tmp then
93743: LD_VAR 0 3
93747: IFFALSE 93759
// active := tmp ;
93749: LD_ADDR_VAR 0 7
93753: PUSH
93754: LD_VAR 0 3
93758: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
93759: LD_STRING getStreamItemsFromMission("
93761: PUSH
93762: LD_VAR 0 5
93766: STR
93767: PUSH
93768: LD_STRING ","
93770: STR
93771: PUSH
93772: LD_VAR 0 6
93776: STR
93777: PUSH
93778: LD_STRING ","
93780: STR
93781: PUSH
93782: LD_VAR 0 7
93786: STR
93787: PUSH
93788: LD_STRING ")
93790: STR
93791: PPUSH
93792: CALL_OW 559
// end else
93796: GO 93805
// ToLua ( getStreamItemsFromMission("","","") ) ;
93798: LD_STRING getStreamItemsFromMission("","","")
93800: PPUSH
93801: CALL_OW 559
// end ;
93805: LD_VAR 0 2
93809: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93810: LD_EXP 107
93814: PUSH
93815: LD_EXP 112
93819: AND
93820: IFFALSE 93944
93822: GO 93824
93824: DISABLE
93825: LD_INT 0
93827: PPUSH
93828: PPUSH
// begin enable ;
93829: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93830: LD_ADDR_VAR 0 2
93834: PUSH
93835: LD_INT 22
93837: PUSH
93838: LD_OWVAR 2
93842: PUSH
93843: EMPTY
93844: LIST
93845: LIST
93846: PUSH
93847: LD_INT 2
93849: PUSH
93850: LD_INT 34
93852: PUSH
93853: LD_INT 7
93855: PUSH
93856: EMPTY
93857: LIST
93858: LIST
93859: PUSH
93860: LD_INT 34
93862: PUSH
93863: LD_INT 45
93865: PUSH
93866: EMPTY
93867: LIST
93868: LIST
93869: PUSH
93870: LD_INT 34
93872: PUSH
93873: LD_INT 28
93875: PUSH
93876: EMPTY
93877: LIST
93878: LIST
93879: PUSH
93880: LD_INT 34
93882: PUSH
93883: LD_INT 47
93885: PUSH
93886: EMPTY
93887: LIST
93888: LIST
93889: PUSH
93890: EMPTY
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: PUSH
93897: EMPTY
93898: LIST
93899: LIST
93900: PPUSH
93901: CALL_OW 69
93905: ST_TO_ADDR
// if not tmp then
93906: LD_VAR 0 2
93910: NOT
93911: IFFALSE 93915
// exit ;
93913: GO 93944
// for i in tmp do
93915: LD_ADDR_VAR 0 1
93919: PUSH
93920: LD_VAR 0 2
93924: PUSH
93925: FOR_IN
93926: IFFALSE 93942
// begin SetLives ( i , 0 ) ;
93928: LD_VAR 0 1
93932: PPUSH
93933: LD_INT 0
93935: PPUSH
93936: CALL_OW 234
// end ;
93940: GO 93925
93942: POP
93943: POP
// end ;
93944: PPOPN 2
93946: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93947: LD_EXP 107
93951: PUSH
93952: LD_EXP 113
93956: AND
93957: IFFALSE 94041
93959: GO 93961
93961: DISABLE
93962: LD_INT 0
93964: PPUSH
93965: PPUSH
// begin enable ;
93966: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93967: LD_ADDR_VAR 0 2
93971: PUSH
93972: LD_INT 22
93974: PUSH
93975: LD_OWVAR 2
93979: PUSH
93980: EMPTY
93981: LIST
93982: LIST
93983: PUSH
93984: LD_INT 32
93986: PUSH
93987: LD_INT 3
93989: PUSH
93990: EMPTY
93991: LIST
93992: LIST
93993: PUSH
93994: EMPTY
93995: LIST
93996: LIST
93997: PPUSH
93998: CALL_OW 69
94002: ST_TO_ADDR
// if not tmp then
94003: LD_VAR 0 2
94007: NOT
94008: IFFALSE 94012
// exit ;
94010: GO 94041
// for i in tmp do
94012: LD_ADDR_VAR 0 1
94016: PUSH
94017: LD_VAR 0 2
94021: PUSH
94022: FOR_IN
94023: IFFALSE 94039
// begin SetLives ( i , 0 ) ;
94025: LD_VAR 0 1
94029: PPUSH
94030: LD_INT 0
94032: PPUSH
94033: CALL_OW 234
// end ;
94037: GO 94022
94039: POP
94040: POP
// end ;
94041: PPOPN 2
94043: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94044: LD_EXP 107
94048: PUSH
94049: LD_EXP 110
94053: AND
94054: IFFALSE 94147
94056: GO 94058
94058: DISABLE
94059: LD_INT 0
94061: PPUSH
// begin enable ;
94062: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94063: LD_ADDR_VAR 0 1
94067: PUSH
94068: LD_INT 22
94070: PUSH
94071: LD_OWVAR 2
94075: PUSH
94076: EMPTY
94077: LIST
94078: LIST
94079: PUSH
94080: LD_INT 2
94082: PUSH
94083: LD_INT 25
94085: PUSH
94086: LD_INT 5
94088: PUSH
94089: EMPTY
94090: LIST
94091: LIST
94092: PUSH
94093: LD_INT 25
94095: PUSH
94096: LD_INT 9
94098: PUSH
94099: EMPTY
94100: LIST
94101: LIST
94102: PUSH
94103: LD_INT 25
94105: PUSH
94106: LD_INT 8
94108: PUSH
94109: EMPTY
94110: LIST
94111: LIST
94112: PUSH
94113: EMPTY
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: PUSH
94119: EMPTY
94120: LIST
94121: LIST
94122: PPUSH
94123: CALL_OW 69
94127: PUSH
94128: FOR_IN
94129: IFFALSE 94145
// begin SetClass ( i , 1 ) ;
94131: LD_VAR 0 1
94135: PPUSH
94136: LD_INT 1
94138: PPUSH
94139: CALL_OW 336
// end ;
94143: GO 94128
94145: POP
94146: POP
// end ;
94147: PPOPN 1
94149: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94150: LD_EXP 107
94154: PUSH
94155: LD_EXP 111
94159: AND
94160: PUSH
94161: LD_OWVAR 65
94165: PUSH
94166: LD_INT 7
94168: LESS
94169: AND
94170: IFFALSE 94184
94172: GO 94174
94174: DISABLE
// begin enable ;
94175: ENABLE
// game_speed := 7 ;
94176: LD_ADDR_OWVAR 65
94180: PUSH
94181: LD_INT 7
94183: ST_TO_ADDR
// end ;
94184: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94185: LD_EXP 107
94189: PUSH
94190: LD_EXP 114
94194: AND
94195: IFFALSE 94397
94197: GO 94199
94199: DISABLE
94200: LD_INT 0
94202: PPUSH
94203: PPUSH
94204: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94205: LD_ADDR_VAR 0 3
94209: PUSH
94210: LD_INT 81
94212: PUSH
94213: LD_OWVAR 2
94217: PUSH
94218: EMPTY
94219: LIST
94220: LIST
94221: PUSH
94222: LD_INT 21
94224: PUSH
94225: LD_INT 1
94227: PUSH
94228: EMPTY
94229: LIST
94230: LIST
94231: PUSH
94232: EMPTY
94233: LIST
94234: LIST
94235: PPUSH
94236: CALL_OW 69
94240: ST_TO_ADDR
// if not tmp then
94241: LD_VAR 0 3
94245: NOT
94246: IFFALSE 94250
// exit ;
94248: GO 94397
// if tmp > 5 then
94250: LD_VAR 0 3
94254: PUSH
94255: LD_INT 5
94257: GREATER
94258: IFFALSE 94270
// k := 5 else
94260: LD_ADDR_VAR 0 2
94264: PUSH
94265: LD_INT 5
94267: ST_TO_ADDR
94268: GO 94280
// k := tmp ;
94270: LD_ADDR_VAR 0 2
94274: PUSH
94275: LD_VAR 0 3
94279: ST_TO_ADDR
// for i := 1 to k do
94280: LD_ADDR_VAR 0 1
94284: PUSH
94285: DOUBLE
94286: LD_INT 1
94288: DEC
94289: ST_TO_ADDR
94290: LD_VAR 0 2
94294: PUSH
94295: FOR_TO
94296: IFFALSE 94395
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94298: LD_VAR 0 3
94302: PUSH
94303: LD_VAR 0 1
94307: ARRAY
94308: PPUSH
94309: LD_VAR 0 1
94313: PUSH
94314: LD_INT 4
94316: MOD
94317: PUSH
94318: LD_INT 1
94320: PLUS
94321: PPUSH
94322: CALL_OW 259
94326: PUSH
94327: LD_INT 10
94329: LESS
94330: IFFALSE 94393
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94332: LD_VAR 0 3
94336: PUSH
94337: LD_VAR 0 1
94341: ARRAY
94342: PPUSH
94343: LD_VAR 0 1
94347: PUSH
94348: LD_INT 4
94350: MOD
94351: PUSH
94352: LD_INT 1
94354: PLUS
94355: PPUSH
94356: LD_VAR 0 3
94360: PUSH
94361: LD_VAR 0 1
94365: ARRAY
94366: PPUSH
94367: LD_VAR 0 1
94371: PUSH
94372: LD_INT 4
94374: MOD
94375: PUSH
94376: LD_INT 1
94378: PLUS
94379: PPUSH
94380: CALL_OW 259
94384: PUSH
94385: LD_INT 1
94387: PLUS
94388: PPUSH
94389: CALL_OW 237
94393: GO 94295
94395: POP
94396: POP
// end ;
94397: PPOPN 3
94399: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94400: LD_EXP 107
94404: PUSH
94405: LD_EXP 115
94409: AND
94410: IFFALSE 94430
94412: GO 94414
94414: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94415: LD_INT 4
94417: PPUSH
94418: LD_OWVAR 2
94422: PPUSH
94423: LD_INT 0
94425: PPUSH
94426: CALL_OW 324
94430: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94431: LD_EXP 107
94435: PUSH
94436: LD_EXP 144
94440: AND
94441: IFFALSE 94461
94443: GO 94445
94445: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94446: LD_INT 19
94448: PPUSH
94449: LD_OWVAR 2
94453: PPUSH
94454: LD_INT 0
94456: PPUSH
94457: CALL_OW 324
94461: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94462: LD_EXP 107
94466: PUSH
94467: LD_EXP 116
94471: AND
94472: IFFALSE 94574
94474: GO 94476
94476: DISABLE
94477: LD_INT 0
94479: PPUSH
94480: PPUSH
// begin enable ;
94481: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94482: LD_ADDR_VAR 0 2
94486: PUSH
94487: LD_INT 22
94489: PUSH
94490: LD_OWVAR 2
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: PUSH
94499: LD_INT 2
94501: PUSH
94502: LD_INT 34
94504: PUSH
94505: LD_INT 11
94507: PUSH
94508: EMPTY
94509: LIST
94510: LIST
94511: PUSH
94512: LD_INT 34
94514: PUSH
94515: LD_INT 30
94517: PUSH
94518: EMPTY
94519: LIST
94520: LIST
94521: PUSH
94522: EMPTY
94523: LIST
94524: LIST
94525: LIST
94526: PUSH
94527: EMPTY
94528: LIST
94529: LIST
94530: PPUSH
94531: CALL_OW 69
94535: ST_TO_ADDR
// if not tmp then
94536: LD_VAR 0 2
94540: NOT
94541: IFFALSE 94545
// exit ;
94543: GO 94574
// for i in tmp do
94545: LD_ADDR_VAR 0 1
94549: PUSH
94550: LD_VAR 0 2
94554: PUSH
94555: FOR_IN
94556: IFFALSE 94572
// begin SetLives ( i , 0 ) ;
94558: LD_VAR 0 1
94562: PPUSH
94563: LD_INT 0
94565: PPUSH
94566: CALL_OW 234
// end ;
94570: GO 94555
94572: POP
94573: POP
// end ;
94574: PPOPN 2
94576: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94577: LD_EXP 107
94581: PUSH
94582: LD_EXP 117
94586: AND
94587: IFFALSE 94607
94589: GO 94591
94591: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94592: LD_INT 32
94594: PPUSH
94595: LD_OWVAR 2
94599: PPUSH
94600: LD_INT 0
94602: PPUSH
94603: CALL_OW 324
94607: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94608: LD_EXP 107
94612: PUSH
94613: LD_EXP 118
94617: AND
94618: IFFALSE 94799
94620: GO 94622
94622: DISABLE
94623: LD_INT 0
94625: PPUSH
94626: PPUSH
94627: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94628: LD_ADDR_VAR 0 2
94632: PUSH
94633: LD_INT 22
94635: PUSH
94636: LD_OWVAR 2
94640: PUSH
94641: EMPTY
94642: LIST
94643: LIST
94644: PUSH
94645: LD_INT 33
94647: PUSH
94648: LD_INT 3
94650: PUSH
94651: EMPTY
94652: LIST
94653: LIST
94654: PUSH
94655: EMPTY
94656: LIST
94657: LIST
94658: PPUSH
94659: CALL_OW 69
94663: ST_TO_ADDR
// if not tmp then
94664: LD_VAR 0 2
94668: NOT
94669: IFFALSE 94673
// exit ;
94671: GO 94799
// side := 0 ;
94673: LD_ADDR_VAR 0 3
94677: PUSH
94678: LD_INT 0
94680: ST_TO_ADDR
// for i := 1 to 8 do
94681: LD_ADDR_VAR 0 1
94685: PUSH
94686: DOUBLE
94687: LD_INT 1
94689: DEC
94690: ST_TO_ADDR
94691: LD_INT 8
94693: PUSH
94694: FOR_TO
94695: IFFALSE 94743
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94697: LD_OWVAR 2
94701: PUSH
94702: LD_VAR 0 1
94706: NONEQUAL
94707: PUSH
94708: LD_OWVAR 2
94712: PPUSH
94713: LD_VAR 0 1
94717: PPUSH
94718: CALL_OW 81
94722: PUSH
94723: LD_INT 2
94725: EQUAL
94726: AND
94727: IFFALSE 94741
// begin side := i ;
94729: LD_ADDR_VAR 0 3
94733: PUSH
94734: LD_VAR 0 1
94738: ST_TO_ADDR
// break ;
94739: GO 94743
// end ;
94741: GO 94694
94743: POP
94744: POP
// if not side then
94745: LD_VAR 0 3
94749: NOT
94750: IFFALSE 94754
// exit ;
94752: GO 94799
// for i := 1 to tmp do
94754: LD_ADDR_VAR 0 1
94758: PUSH
94759: DOUBLE
94760: LD_INT 1
94762: DEC
94763: ST_TO_ADDR
94764: LD_VAR 0 2
94768: PUSH
94769: FOR_TO
94770: IFFALSE 94797
// if Prob ( 60 ) then
94772: LD_INT 60
94774: PPUSH
94775: CALL_OW 13
94779: IFFALSE 94795
// SetSide ( i , side ) ;
94781: LD_VAR 0 1
94785: PPUSH
94786: LD_VAR 0 3
94790: PPUSH
94791: CALL_OW 235
94795: GO 94769
94797: POP
94798: POP
// end ;
94799: PPOPN 3
94801: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94802: LD_EXP 107
94806: PUSH
94807: LD_EXP 120
94811: AND
94812: IFFALSE 94931
94814: GO 94816
94816: DISABLE
94817: LD_INT 0
94819: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94820: LD_ADDR_VAR 0 1
94824: PUSH
94825: LD_INT 22
94827: PUSH
94828: LD_OWVAR 2
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: PUSH
94837: LD_INT 21
94839: PUSH
94840: LD_INT 1
94842: PUSH
94843: EMPTY
94844: LIST
94845: LIST
94846: PUSH
94847: LD_INT 3
94849: PUSH
94850: LD_INT 23
94852: PUSH
94853: LD_INT 0
94855: PUSH
94856: EMPTY
94857: LIST
94858: LIST
94859: PUSH
94860: EMPTY
94861: LIST
94862: LIST
94863: PUSH
94864: EMPTY
94865: LIST
94866: LIST
94867: LIST
94868: PPUSH
94869: CALL_OW 69
94873: PUSH
94874: FOR_IN
94875: IFFALSE 94929
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94877: LD_VAR 0 1
94881: PPUSH
94882: CALL_OW 257
94886: PUSH
94887: LD_INT 1
94889: PUSH
94890: LD_INT 2
94892: PUSH
94893: LD_INT 3
94895: PUSH
94896: LD_INT 4
94898: PUSH
94899: EMPTY
94900: LIST
94901: LIST
94902: LIST
94903: LIST
94904: IN
94905: IFFALSE 94927
// SetClass ( un , rand ( 1 , 4 ) ) ;
94907: LD_VAR 0 1
94911: PPUSH
94912: LD_INT 1
94914: PPUSH
94915: LD_INT 4
94917: PPUSH
94918: CALL_OW 12
94922: PPUSH
94923: CALL_OW 336
94927: GO 94874
94929: POP
94930: POP
// end ;
94931: PPOPN 1
94933: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94934: LD_EXP 107
94938: PUSH
94939: LD_EXP 119
94943: AND
94944: IFFALSE 95023
94946: GO 94948
94948: DISABLE
94949: LD_INT 0
94951: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94952: LD_ADDR_VAR 0 1
94956: PUSH
94957: LD_INT 22
94959: PUSH
94960: LD_OWVAR 2
94964: PUSH
94965: EMPTY
94966: LIST
94967: LIST
94968: PUSH
94969: LD_INT 21
94971: PUSH
94972: LD_INT 3
94974: PUSH
94975: EMPTY
94976: LIST
94977: LIST
94978: PUSH
94979: EMPTY
94980: LIST
94981: LIST
94982: PPUSH
94983: CALL_OW 69
94987: ST_TO_ADDR
// if not tmp then
94988: LD_VAR 0 1
94992: NOT
94993: IFFALSE 94997
// exit ;
94995: GO 95023
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94997: LD_VAR 0 1
95001: PUSH
95002: LD_INT 1
95004: PPUSH
95005: LD_VAR 0 1
95009: PPUSH
95010: CALL_OW 12
95014: ARRAY
95015: PPUSH
95016: LD_INT 100
95018: PPUSH
95019: CALL_OW 234
// end ;
95023: PPOPN 1
95025: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
95026: LD_EXP 107
95030: PUSH
95031: LD_EXP 121
95035: AND
95036: IFFALSE 95134
95038: GO 95040
95040: DISABLE
95041: LD_INT 0
95043: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95044: LD_ADDR_VAR 0 1
95048: PUSH
95049: LD_INT 22
95051: PUSH
95052: LD_OWVAR 2
95056: PUSH
95057: EMPTY
95058: LIST
95059: LIST
95060: PUSH
95061: LD_INT 21
95063: PUSH
95064: LD_INT 1
95066: PUSH
95067: EMPTY
95068: LIST
95069: LIST
95070: PUSH
95071: EMPTY
95072: LIST
95073: LIST
95074: PPUSH
95075: CALL_OW 69
95079: ST_TO_ADDR
// if not tmp then
95080: LD_VAR 0 1
95084: NOT
95085: IFFALSE 95089
// exit ;
95087: GO 95134
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95089: LD_VAR 0 1
95093: PUSH
95094: LD_INT 1
95096: PPUSH
95097: LD_VAR 0 1
95101: PPUSH
95102: CALL_OW 12
95106: ARRAY
95107: PPUSH
95108: LD_INT 1
95110: PPUSH
95111: LD_INT 4
95113: PPUSH
95114: CALL_OW 12
95118: PPUSH
95119: LD_INT 3000
95121: PPUSH
95122: LD_INT 9000
95124: PPUSH
95125: CALL_OW 12
95129: PPUSH
95130: CALL_OW 492
// end ;
95134: PPOPN 1
95136: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95137: LD_EXP 107
95141: PUSH
95142: LD_EXP 122
95146: AND
95147: IFFALSE 95167
95149: GO 95151
95151: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95152: LD_INT 1
95154: PPUSH
95155: LD_OWVAR 2
95159: PPUSH
95160: LD_INT 0
95162: PPUSH
95163: CALL_OW 324
95167: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95168: LD_EXP 107
95172: PUSH
95173: LD_EXP 123
95177: AND
95178: IFFALSE 95261
95180: GO 95182
95182: DISABLE
95183: LD_INT 0
95185: PPUSH
95186: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95187: LD_ADDR_VAR 0 2
95191: PUSH
95192: LD_INT 22
95194: PUSH
95195: LD_OWVAR 2
95199: PUSH
95200: EMPTY
95201: LIST
95202: LIST
95203: PUSH
95204: LD_INT 21
95206: PUSH
95207: LD_INT 3
95209: PUSH
95210: EMPTY
95211: LIST
95212: LIST
95213: PUSH
95214: EMPTY
95215: LIST
95216: LIST
95217: PPUSH
95218: CALL_OW 69
95222: ST_TO_ADDR
// if not tmp then
95223: LD_VAR 0 2
95227: NOT
95228: IFFALSE 95232
// exit ;
95230: GO 95261
// for i in tmp do
95232: LD_ADDR_VAR 0 1
95236: PUSH
95237: LD_VAR 0 2
95241: PUSH
95242: FOR_IN
95243: IFFALSE 95259
// SetBLevel ( i , 10 ) ;
95245: LD_VAR 0 1
95249: PPUSH
95250: LD_INT 10
95252: PPUSH
95253: CALL_OW 241
95257: GO 95242
95259: POP
95260: POP
// end ;
95261: PPOPN 2
95263: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95264: LD_EXP 107
95268: PUSH
95269: LD_EXP 124
95273: AND
95274: IFFALSE 95385
95276: GO 95278
95278: DISABLE
95279: LD_INT 0
95281: PPUSH
95282: PPUSH
95283: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95284: LD_ADDR_VAR 0 3
95288: PUSH
95289: LD_INT 22
95291: PUSH
95292: LD_OWVAR 2
95296: PUSH
95297: EMPTY
95298: LIST
95299: LIST
95300: PUSH
95301: LD_INT 25
95303: PUSH
95304: LD_INT 1
95306: PUSH
95307: EMPTY
95308: LIST
95309: LIST
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: PPUSH
95315: CALL_OW 69
95319: ST_TO_ADDR
// if not tmp then
95320: LD_VAR 0 3
95324: NOT
95325: IFFALSE 95329
// exit ;
95327: GO 95385
// un := tmp [ rand ( 1 , tmp ) ] ;
95329: LD_ADDR_VAR 0 2
95333: PUSH
95334: LD_VAR 0 3
95338: PUSH
95339: LD_INT 1
95341: PPUSH
95342: LD_VAR 0 3
95346: PPUSH
95347: CALL_OW 12
95351: ARRAY
95352: ST_TO_ADDR
// if Crawls ( un ) then
95353: LD_VAR 0 2
95357: PPUSH
95358: CALL_OW 318
95362: IFFALSE 95373
// ComWalk ( un ) ;
95364: LD_VAR 0 2
95368: PPUSH
95369: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95373: LD_VAR 0 2
95377: PPUSH
95378: LD_INT 5
95380: PPUSH
95381: CALL_OW 336
// end ;
95385: PPOPN 3
95387: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
95388: LD_EXP 107
95392: PUSH
95393: LD_EXP 125
95397: AND
95398: PUSH
95399: LD_OWVAR 67
95403: PUSH
95404: LD_INT 4
95406: LESS
95407: AND
95408: IFFALSE 95427
95410: GO 95412
95412: DISABLE
// begin Difficulty := Difficulty + 1 ;
95413: LD_ADDR_OWVAR 67
95417: PUSH
95418: LD_OWVAR 67
95422: PUSH
95423: LD_INT 1
95425: PLUS
95426: ST_TO_ADDR
// end ;
95427: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95428: LD_EXP 107
95432: PUSH
95433: LD_EXP 126
95437: AND
95438: IFFALSE 95541
95440: GO 95442
95442: DISABLE
95443: LD_INT 0
95445: PPUSH
// begin for i := 1 to 5 do
95446: LD_ADDR_VAR 0 1
95450: PUSH
95451: DOUBLE
95452: LD_INT 1
95454: DEC
95455: ST_TO_ADDR
95456: LD_INT 5
95458: PUSH
95459: FOR_TO
95460: IFFALSE 95539
// begin uc_nation := nation_nature ;
95462: LD_ADDR_OWVAR 21
95466: PUSH
95467: LD_INT 0
95469: ST_TO_ADDR
// uc_side := 0 ;
95470: LD_ADDR_OWVAR 20
95474: PUSH
95475: LD_INT 0
95477: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95478: LD_ADDR_OWVAR 29
95482: PUSH
95483: LD_INT 12
95485: PUSH
95486: LD_INT 12
95488: PUSH
95489: EMPTY
95490: LIST
95491: LIST
95492: ST_TO_ADDR
// hc_agressivity := 20 ;
95493: LD_ADDR_OWVAR 35
95497: PUSH
95498: LD_INT 20
95500: ST_TO_ADDR
// hc_class := class_tiger ;
95501: LD_ADDR_OWVAR 28
95505: PUSH
95506: LD_INT 14
95508: ST_TO_ADDR
// hc_gallery :=  ;
95509: LD_ADDR_OWVAR 33
95513: PUSH
95514: LD_STRING 
95516: ST_TO_ADDR
// hc_name :=  ;
95517: LD_ADDR_OWVAR 26
95521: PUSH
95522: LD_STRING 
95524: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95525: CALL_OW 44
95529: PPUSH
95530: LD_INT 0
95532: PPUSH
95533: CALL_OW 51
// end ;
95537: GO 95459
95539: POP
95540: POP
// end ;
95541: PPOPN 1
95543: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95544: LD_EXP 107
95548: PUSH
95549: LD_EXP 127
95553: AND
95554: IFFALSE 95563
95556: GO 95558
95558: DISABLE
// StreamSibBomb ;
95559: CALL 95564 0 0
95563: END
// export function StreamSibBomb ; var i , x , y ; begin
95564: LD_INT 0
95566: PPUSH
95567: PPUSH
95568: PPUSH
95569: PPUSH
// result := false ;
95570: LD_ADDR_VAR 0 1
95574: PUSH
95575: LD_INT 0
95577: ST_TO_ADDR
// for i := 1 to 16 do
95578: LD_ADDR_VAR 0 2
95582: PUSH
95583: DOUBLE
95584: LD_INT 1
95586: DEC
95587: ST_TO_ADDR
95588: LD_INT 16
95590: PUSH
95591: FOR_TO
95592: IFFALSE 95791
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95594: LD_ADDR_VAR 0 3
95598: PUSH
95599: LD_INT 10
95601: PUSH
95602: LD_INT 20
95604: PUSH
95605: LD_INT 30
95607: PUSH
95608: LD_INT 40
95610: PUSH
95611: LD_INT 50
95613: PUSH
95614: LD_INT 60
95616: PUSH
95617: LD_INT 70
95619: PUSH
95620: LD_INT 80
95622: PUSH
95623: LD_INT 90
95625: PUSH
95626: LD_INT 100
95628: PUSH
95629: LD_INT 110
95631: PUSH
95632: LD_INT 120
95634: PUSH
95635: LD_INT 130
95637: PUSH
95638: LD_INT 140
95640: PUSH
95641: LD_INT 150
95643: PUSH
95644: EMPTY
95645: LIST
95646: LIST
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: PUSH
95661: LD_INT 1
95663: PPUSH
95664: LD_INT 15
95666: PPUSH
95667: CALL_OW 12
95671: ARRAY
95672: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95673: LD_ADDR_VAR 0 4
95677: PUSH
95678: LD_INT 10
95680: PUSH
95681: LD_INT 20
95683: PUSH
95684: LD_INT 30
95686: PUSH
95687: LD_INT 40
95689: PUSH
95690: LD_INT 50
95692: PUSH
95693: LD_INT 60
95695: PUSH
95696: LD_INT 70
95698: PUSH
95699: LD_INT 80
95701: PUSH
95702: LD_INT 90
95704: PUSH
95705: LD_INT 100
95707: PUSH
95708: LD_INT 110
95710: PUSH
95711: LD_INT 120
95713: PUSH
95714: LD_INT 130
95716: PUSH
95717: LD_INT 140
95719: PUSH
95720: LD_INT 150
95722: PUSH
95723: EMPTY
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: PUSH
95740: LD_INT 1
95742: PPUSH
95743: LD_INT 15
95745: PPUSH
95746: CALL_OW 12
95750: ARRAY
95751: ST_TO_ADDR
// if ValidHex ( x , y ) then
95752: LD_VAR 0 3
95756: PPUSH
95757: LD_VAR 0 4
95761: PPUSH
95762: CALL_OW 488
95766: IFFALSE 95789
// begin result := [ x , y ] ;
95768: LD_ADDR_VAR 0 1
95772: PUSH
95773: LD_VAR 0 3
95777: PUSH
95778: LD_VAR 0 4
95782: PUSH
95783: EMPTY
95784: LIST
95785: LIST
95786: ST_TO_ADDR
// break ;
95787: GO 95791
// end ; end ;
95789: GO 95591
95791: POP
95792: POP
// if result then
95793: LD_VAR 0 1
95797: IFFALSE 95857
// begin ToLua ( playSibBomb() ) ;
95799: LD_STRING playSibBomb()
95801: PPUSH
95802: CALL_OW 559
// wait ( 0 0$14 ) ;
95806: LD_INT 490
95808: PPUSH
95809: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95813: LD_VAR 0 1
95817: PUSH
95818: LD_INT 1
95820: ARRAY
95821: PPUSH
95822: LD_VAR 0 1
95826: PUSH
95827: LD_INT 2
95829: ARRAY
95830: PPUSH
95831: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95835: LD_VAR 0 1
95839: PUSH
95840: LD_INT 1
95842: ARRAY
95843: PPUSH
95844: LD_VAR 0 1
95848: PUSH
95849: LD_INT 2
95851: ARRAY
95852: PPUSH
95853: CALL_OW 429
// end ; end ;
95857: LD_VAR 0 1
95861: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95862: LD_EXP 107
95866: PUSH
95867: LD_EXP 129
95871: AND
95872: IFFALSE 95884
95874: GO 95876
95876: DISABLE
// YouLost (  ) ;
95877: LD_STRING 
95879: PPUSH
95880: CALL_OW 104
95884: END
// every 0 0$1 trigger StreamModeActive and sFog do
95885: LD_EXP 107
95889: PUSH
95890: LD_EXP 128
95894: AND
95895: IFFALSE 95909
95897: GO 95899
95899: DISABLE
// FogOff ( your_side ) ;
95900: LD_OWVAR 2
95904: PPUSH
95905: CALL_OW 344
95909: END
// every 0 0$1 trigger StreamModeActive and sSun do
95910: LD_EXP 107
95914: PUSH
95915: LD_EXP 130
95919: AND
95920: IFFALSE 95948
95922: GO 95924
95924: DISABLE
// begin solar_recharge_percent := 0 ;
95925: LD_ADDR_OWVAR 79
95929: PUSH
95930: LD_INT 0
95932: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95933: LD_INT 10500
95935: PPUSH
95936: CALL_OW 67
// solar_recharge_percent := 100 ;
95940: LD_ADDR_OWVAR 79
95944: PUSH
95945: LD_INT 100
95947: ST_TO_ADDR
// end ;
95948: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95949: LD_EXP 107
95953: PUSH
95954: LD_EXP 131
95958: AND
95959: IFFALSE 96198
95961: GO 95963
95963: DISABLE
95964: LD_INT 0
95966: PPUSH
95967: PPUSH
95968: PPUSH
// begin tmp := [ ] ;
95969: LD_ADDR_VAR 0 3
95973: PUSH
95974: EMPTY
95975: ST_TO_ADDR
// for i := 1 to 6 do
95976: LD_ADDR_VAR 0 1
95980: PUSH
95981: DOUBLE
95982: LD_INT 1
95984: DEC
95985: ST_TO_ADDR
95986: LD_INT 6
95988: PUSH
95989: FOR_TO
95990: IFFALSE 96095
// begin uc_nation := nation_nature ;
95992: LD_ADDR_OWVAR 21
95996: PUSH
95997: LD_INT 0
95999: ST_TO_ADDR
// uc_side := 0 ;
96000: LD_ADDR_OWVAR 20
96004: PUSH
96005: LD_INT 0
96007: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
96008: LD_ADDR_OWVAR 29
96012: PUSH
96013: LD_INT 12
96015: PUSH
96016: LD_INT 12
96018: PUSH
96019: EMPTY
96020: LIST
96021: LIST
96022: ST_TO_ADDR
// hc_agressivity := 20 ;
96023: LD_ADDR_OWVAR 35
96027: PUSH
96028: LD_INT 20
96030: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96031: LD_ADDR_OWVAR 28
96035: PUSH
96036: LD_INT 17
96038: ST_TO_ADDR
// hc_gallery :=  ;
96039: LD_ADDR_OWVAR 33
96043: PUSH
96044: LD_STRING 
96046: ST_TO_ADDR
// hc_name :=  ;
96047: LD_ADDR_OWVAR 26
96051: PUSH
96052: LD_STRING 
96054: ST_TO_ADDR
// un := CreateHuman ;
96055: LD_ADDR_VAR 0 2
96059: PUSH
96060: CALL_OW 44
96064: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96065: LD_VAR 0 2
96069: PPUSH
96070: LD_INT 1
96072: PPUSH
96073: CALL_OW 51
// tmp := tmp ^ un ;
96077: LD_ADDR_VAR 0 3
96081: PUSH
96082: LD_VAR 0 3
96086: PUSH
96087: LD_VAR 0 2
96091: ADD
96092: ST_TO_ADDR
// end ;
96093: GO 95989
96095: POP
96096: POP
// repeat wait ( 0 0$1 ) ;
96097: LD_INT 35
96099: PPUSH
96100: CALL_OW 67
// for un in tmp do
96104: LD_ADDR_VAR 0 2
96108: PUSH
96109: LD_VAR 0 3
96113: PUSH
96114: FOR_IN
96115: IFFALSE 96189
// begin if IsDead ( un ) then
96117: LD_VAR 0 2
96121: PPUSH
96122: CALL_OW 301
96126: IFFALSE 96146
// begin tmp := tmp diff un ;
96128: LD_ADDR_VAR 0 3
96132: PUSH
96133: LD_VAR 0 3
96137: PUSH
96138: LD_VAR 0 2
96142: DIFF
96143: ST_TO_ADDR
// continue ;
96144: GO 96114
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96146: LD_VAR 0 2
96150: PPUSH
96151: LD_INT 3
96153: PUSH
96154: LD_INT 22
96156: PUSH
96157: LD_INT 0
96159: PUSH
96160: EMPTY
96161: LIST
96162: LIST
96163: PUSH
96164: EMPTY
96165: LIST
96166: LIST
96167: PPUSH
96168: CALL_OW 69
96172: PPUSH
96173: LD_VAR 0 2
96177: PPUSH
96178: CALL_OW 74
96182: PPUSH
96183: CALL_OW 115
// end ;
96187: GO 96114
96189: POP
96190: POP
// until not tmp ;
96191: LD_VAR 0 3
96195: NOT
96196: IFFALSE 96097
// end ;
96198: PPOPN 3
96200: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96201: LD_EXP 107
96205: PUSH
96206: LD_EXP 132
96210: AND
96211: IFFALSE 96265
96213: GO 96215
96215: DISABLE
// begin ToLua ( displayTroll(); ) ;
96216: LD_STRING displayTroll();
96218: PPUSH
96219: CALL_OW 559
// wait ( 3 3$00 ) ;
96223: LD_INT 6300
96225: PPUSH
96226: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96230: LD_STRING hideTroll();
96232: PPUSH
96233: CALL_OW 559
// wait ( 1 1$00 ) ;
96237: LD_INT 2100
96239: PPUSH
96240: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96244: LD_STRING displayTroll();
96246: PPUSH
96247: CALL_OW 559
// wait ( 1 1$00 ) ;
96251: LD_INT 2100
96253: PPUSH
96254: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96258: LD_STRING hideTroll();
96260: PPUSH
96261: CALL_OW 559
// end ;
96265: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96266: LD_EXP 107
96270: PUSH
96271: LD_EXP 133
96275: AND
96276: IFFALSE 96339
96278: GO 96280
96280: DISABLE
96281: LD_INT 0
96283: PPUSH
// begin p := 0 ;
96284: LD_ADDR_VAR 0 1
96288: PUSH
96289: LD_INT 0
96291: ST_TO_ADDR
// repeat game_speed := 1 ;
96292: LD_ADDR_OWVAR 65
96296: PUSH
96297: LD_INT 1
96299: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96300: LD_INT 35
96302: PPUSH
96303: CALL_OW 67
// p := p + 1 ;
96307: LD_ADDR_VAR 0 1
96311: PUSH
96312: LD_VAR 0 1
96316: PUSH
96317: LD_INT 1
96319: PLUS
96320: ST_TO_ADDR
// until p >= 60 ;
96321: LD_VAR 0 1
96325: PUSH
96326: LD_INT 60
96328: GREATEREQUAL
96329: IFFALSE 96292
// game_speed := 4 ;
96331: LD_ADDR_OWVAR 65
96335: PUSH
96336: LD_INT 4
96338: ST_TO_ADDR
// end ;
96339: PPOPN 1
96341: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96342: LD_EXP 107
96346: PUSH
96347: LD_EXP 134
96351: AND
96352: IFFALSE 96498
96354: GO 96356
96356: DISABLE
96357: LD_INT 0
96359: PPUSH
96360: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96361: LD_ADDR_VAR 0 1
96365: PUSH
96366: LD_INT 22
96368: PUSH
96369: LD_OWVAR 2
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: PUSH
96378: LD_INT 2
96380: PUSH
96381: LD_INT 30
96383: PUSH
96384: LD_INT 0
96386: PUSH
96387: EMPTY
96388: LIST
96389: LIST
96390: PUSH
96391: LD_INT 30
96393: PUSH
96394: LD_INT 1
96396: PUSH
96397: EMPTY
96398: LIST
96399: LIST
96400: PUSH
96401: EMPTY
96402: LIST
96403: LIST
96404: LIST
96405: PUSH
96406: EMPTY
96407: LIST
96408: LIST
96409: PPUSH
96410: CALL_OW 69
96414: ST_TO_ADDR
// if not depot then
96415: LD_VAR 0 1
96419: NOT
96420: IFFALSE 96424
// exit ;
96422: GO 96498
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96424: LD_ADDR_VAR 0 2
96428: PUSH
96429: LD_VAR 0 1
96433: PUSH
96434: LD_INT 1
96436: PPUSH
96437: LD_VAR 0 1
96441: PPUSH
96442: CALL_OW 12
96446: ARRAY
96447: PPUSH
96448: CALL_OW 274
96452: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96453: LD_VAR 0 2
96457: PPUSH
96458: LD_INT 1
96460: PPUSH
96461: LD_INT 0
96463: PPUSH
96464: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96468: LD_VAR 0 2
96472: PPUSH
96473: LD_INT 2
96475: PPUSH
96476: LD_INT 0
96478: PPUSH
96479: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96483: LD_VAR 0 2
96487: PPUSH
96488: LD_INT 3
96490: PPUSH
96491: LD_INT 0
96493: PPUSH
96494: CALL_OW 277
// end ;
96498: PPOPN 2
96500: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96501: LD_EXP 107
96505: PUSH
96506: LD_EXP 135
96510: AND
96511: IFFALSE 96608
96513: GO 96515
96515: DISABLE
96516: LD_INT 0
96518: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96519: LD_ADDR_VAR 0 1
96523: PUSH
96524: LD_INT 22
96526: PUSH
96527: LD_OWVAR 2
96531: PUSH
96532: EMPTY
96533: LIST
96534: LIST
96535: PUSH
96536: LD_INT 21
96538: PUSH
96539: LD_INT 1
96541: PUSH
96542: EMPTY
96543: LIST
96544: LIST
96545: PUSH
96546: LD_INT 3
96548: PUSH
96549: LD_INT 23
96551: PUSH
96552: LD_INT 0
96554: PUSH
96555: EMPTY
96556: LIST
96557: LIST
96558: PUSH
96559: EMPTY
96560: LIST
96561: LIST
96562: PUSH
96563: EMPTY
96564: LIST
96565: LIST
96566: LIST
96567: PPUSH
96568: CALL_OW 69
96572: ST_TO_ADDR
// if not tmp then
96573: LD_VAR 0 1
96577: NOT
96578: IFFALSE 96582
// exit ;
96580: GO 96608
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96582: LD_VAR 0 1
96586: PUSH
96587: LD_INT 1
96589: PPUSH
96590: LD_VAR 0 1
96594: PPUSH
96595: CALL_OW 12
96599: ARRAY
96600: PPUSH
96601: LD_INT 200
96603: PPUSH
96604: CALL_OW 234
// end ;
96608: PPOPN 1
96610: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96611: LD_EXP 107
96615: PUSH
96616: LD_EXP 136
96620: AND
96621: IFFALSE 96700
96623: GO 96625
96625: DISABLE
96626: LD_INT 0
96628: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96629: LD_ADDR_VAR 0 1
96633: PUSH
96634: LD_INT 22
96636: PUSH
96637: LD_OWVAR 2
96641: PUSH
96642: EMPTY
96643: LIST
96644: LIST
96645: PUSH
96646: LD_INT 21
96648: PUSH
96649: LD_INT 2
96651: PUSH
96652: EMPTY
96653: LIST
96654: LIST
96655: PUSH
96656: EMPTY
96657: LIST
96658: LIST
96659: PPUSH
96660: CALL_OW 69
96664: ST_TO_ADDR
// if not tmp then
96665: LD_VAR 0 1
96669: NOT
96670: IFFALSE 96674
// exit ;
96672: GO 96700
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96674: LD_VAR 0 1
96678: PUSH
96679: LD_INT 1
96681: PPUSH
96682: LD_VAR 0 1
96686: PPUSH
96687: CALL_OW 12
96691: ARRAY
96692: PPUSH
96693: LD_INT 60
96695: PPUSH
96696: CALL_OW 234
// end ;
96700: PPOPN 1
96702: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96703: LD_EXP 107
96707: PUSH
96708: LD_EXP 137
96712: AND
96713: IFFALSE 96812
96715: GO 96717
96717: DISABLE
96718: LD_INT 0
96720: PPUSH
96721: PPUSH
// begin enable ;
96722: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96723: LD_ADDR_VAR 0 1
96727: PUSH
96728: LD_INT 22
96730: PUSH
96731: LD_OWVAR 2
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 61
96742: PUSH
96743: EMPTY
96744: LIST
96745: PUSH
96746: LD_INT 33
96748: PUSH
96749: LD_INT 2
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: EMPTY
96757: LIST
96758: LIST
96759: LIST
96760: PPUSH
96761: CALL_OW 69
96765: ST_TO_ADDR
// if not tmp then
96766: LD_VAR 0 1
96770: NOT
96771: IFFALSE 96775
// exit ;
96773: GO 96812
// for i in tmp do
96775: LD_ADDR_VAR 0 2
96779: PUSH
96780: LD_VAR 0 1
96784: PUSH
96785: FOR_IN
96786: IFFALSE 96810
// if IsControledBy ( i ) then
96788: LD_VAR 0 2
96792: PPUSH
96793: CALL_OW 312
96797: IFFALSE 96808
// ComUnlink ( i ) ;
96799: LD_VAR 0 2
96803: PPUSH
96804: CALL_OW 136
96808: GO 96785
96810: POP
96811: POP
// end ;
96812: PPOPN 2
96814: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96815: LD_EXP 107
96819: PUSH
96820: LD_EXP 138
96824: AND
96825: IFFALSE 96965
96827: GO 96829
96829: DISABLE
96830: LD_INT 0
96832: PPUSH
96833: PPUSH
// begin ToLua ( displayPowell(); ) ;
96834: LD_STRING displayPowell();
96836: PPUSH
96837: CALL_OW 559
// uc_side := 0 ;
96841: LD_ADDR_OWVAR 20
96845: PUSH
96846: LD_INT 0
96848: ST_TO_ADDR
// uc_nation := 2 ;
96849: LD_ADDR_OWVAR 21
96853: PUSH
96854: LD_INT 2
96856: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96857: LD_ADDR_OWVAR 37
96861: PUSH
96862: LD_INT 14
96864: ST_TO_ADDR
// vc_engine := engine_siberite ;
96865: LD_ADDR_OWVAR 39
96869: PUSH
96870: LD_INT 3
96872: ST_TO_ADDR
// vc_control := control_apeman ;
96873: LD_ADDR_OWVAR 38
96877: PUSH
96878: LD_INT 5
96880: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96881: LD_ADDR_OWVAR 40
96885: PUSH
96886: LD_INT 29
96888: ST_TO_ADDR
// un := CreateVehicle ;
96889: LD_ADDR_VAR 0 2
96893: PUSH
96894: CALL_OW 45
96898: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96899: LD_VAR 0 2
96903: PPUSH
96904: LD_INT 1
96906: PPUSH
96907: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96911: LD_INT 35
96913: PPUSH
96914: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96918: LD_VAR 0 2
96922: PPUSH
96923: LD_INT 22
96925: PUSH
96926: LD_OWVAR 2
96930: PUSH
96931: EMPTY
96932: LIST
96933: LIST
96934: PPUSH
96935: CALL_OW 69
96939: PPUSH
96940: LD_VAR 0 2
96944: PPUSH
96945: CALL_OW 74
96949: PPUSH
96950: CALL_OW 115
// until IsDead ( un ) ;
96954: LD_VAR 0 2
96958: PPUSH
96959: CALL_OW 301
96963: IFFALSE 96911
// end ;
96965: PPOPN 2
96967: END
// every 0 0$1 trigger StreamModeActive and sStu do
96968: LD_EXP 107
96972: PUSH
96973: LD_EXP 146
96977: AND
96978: IFFALSE 96994
96980: GO 96982
96982: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96983: LD_STRING displayStucuk();
96985: PPUSH
96986: CALL_OW 559
// ResetFog ;
96990: CALL_OW 335
// end ;
96994: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96995: LD_EXP 107
96999: PUSH
97000: LD_EXP 139
97004: AND
97005: IFFALSE 97146
97007: GO 97009
97009: DISABLE
97010: LD_INT 0
97012: PPUSH
97013: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97014: LD_ADDR_VAR 0 2
97018: PUSH
97019: LD_INT 22
97021: PUSH
97022: LD_OWVAR 2
97026: PUSH
97027: EMPTY
97028: LIST
97029: LIST
97030: PUSH
97031: LD_INT 21
97033: PUSH
97034: LD_INT 1
97036: PUSH
97037: EMPTY
97038: LIST
97039: LIST
97040: PUSH
97041: EMPTY
97042: LIST
97043: LIST
97044: PPUSH
97045: CALL_OW 69
97049: ST_TO_ADDR
// if not tmp then
97050: LD_VAR 0 2
97054: NOT
97055: IFFALSE 97059
// exit ;
97057: GO 97146
// un := tmp [ rand ( 1 , tmp ) ] ;
97059: LD_ADDR_VAR 0 1
97063: PUSH
97064: LD_VAR 0 2
97068: PUSH
97069: LD_INT 1
97071: PPUSH
97072: LD_VAR 0 2
97076: PPUSH
97077: CALL_OW 12
97081: ARRAY
97082: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97083: LD_VAR 0 1
97087: PPUSH
97088: LD_INT 0
97090: PPUSH
97091: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97095: LD_VAR 0 1
97099: PPUSH
97100: LD_OWVAR 3
97104: PUSH
97105: LD_VAR 0 1
97109: DIFF
97110: PPUSH
97111: LD_VAR 0 1
97115: PPUSH
97116: CALL_OW 74
97120: PPUSH
97121: CALL_OW 115
// wait ( 0 0$20 ) ;
97125: LD_INT 700
97127: PPUSH
97128: CALL_OW 67
// SetSide ( un , your_side ) ;
97132: LD_VAR 0 1
97136: PPUSH
97137: LD_OWVAR 2
97141: PPUSH
97142: CALL_OW 235
// end ;
97146: PPOPN 2
97148: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97149: LD_EXP 107
97153: PUSH
97154: LD_EXP 140
97158: AND
97159: IFFALSE 97265
97161: GO 97163
97163: DISABLE
97164: LD_INT 0
97166: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97167: LD_ADDR_VAR 0 1
97171: PUSH
97172: LD_INT 22
97174: PUSH
97175: LD_OWVAR 2
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PUSH
97184: LD_INT 2
97186: PUSH
97187: LD_INT 30
97189: PUSH
97190: LD_INT 0
97192: PUSH
97193: EMPTY
97194: LIST
97195: LIST
97196: PUSH
97197: LD_INT 30
97199: PUSH
97200: LD_INT 1
97202: PUSH
97203: EMPTY
97204: LIST
97205: LIST
97206: PUSH
97207: EMPTY
97208: LIST
97209: LIST
97210: LIST
97211: PUSH
97212: EMPTY
97213: LIST
97214: LIST
97215: PPUSH
97216: CALL_OW 69
97220: ST_TO_ADDR
// if not depot then
97221: LD_VAR 0 1
97225: NOT
97226: IFFALSE 97230
// exit ;
97228: GO 97265
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97230: LD_VAR 0 1
97234: PUSH
97235: LD_INT 1
97237: ARRAY
97238: PPUSH
97239: CALL_OW 250
97243: PPUSH
97244: LD_VAR 0 1
97248: PUSH
97249: LD_INT 1
97251: ARRAY
97252: PPUSH
97253: CALL_OW 251
97257: PPUSH
97258: LD_INT 70
97260: PPUSH
97261: CALL_OW 495
// end ;
97265: PPOPN 1
97267: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97268: LD_EXP 107
97272: PUSH
97273: LD_EXP 141
97277: AND
97278: IFFALSE 97489
97280: GO 97282
97282: DISABLE
97283: LD_INT 0
97285: PPUSH
97286: PPUSH
97287: PPUSH
97288: PPUSH
97289: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97290: LD_ADDR_VAR 0 5
97294: PUSH
97295: LD_INT 22
97297: PUSH
97298: LD_OWVAR 2
97302: PUSH
97303: EMPTY
97304: LIST
97305: LIST
97306: PUSH
97307: LD_INT 21
97309: PUSH
97310: LD_INT 1
97312: PUSH
97313: EMPTY
97314: LIST
97315: LIST
97316: PUSH
97317: EMPTY
97318: LIST
97319: LIST
97320: PPUSH
97321: CALL_OW 69
97325: ST_TO_ADDR
// if not tmp then
97326: LD_VAR 0 5
97330: NOT
97331: IFFALSE 97335
// exit ;
97333: GO 97489
// for i in tmp do
97335: LD_ADDR_VAR 0 1
97339: PUSH
97340: LD_VAR 0 5
97344: PUSH
97345: FOR_IN
97346: IFFALSE 97487
// begin d := rand ( 0 , 5 ) ;
97348: LD_ADDR_VAR 0 4
97352: PUSH
97353: LD_INT 0
97355: PPUSH
97356: LD_INT 5
97358: PPUSH
97359: CALL_OW 12
97363: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97364: LD_ADDR_VAR 0 2
97368: PUSH
97369: LD_VAR 0 1
97373: PPUSH
97374: CALL_OW 250
97378: PPUSH
97379: LD_VAR 0 4
97383: PPUSH
97384: LD_INT 3
97386: PPUSH
97387: LD_INT 12
97389: PPUSH
97390: CALL_OW 12
97394: PPUSH
97395: CALL_OW 272
97399: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97400: LD_ADDR_VAR 0 3
97404: PUSH
97405: LD_VAR 0 1
97409: PPUSH
97410: CALL_OW 251
97414: PPUSH
97415: LD_VAR 0 4
97419: PPUSH
97420: LD_INT 3
97422: PPUSH
97423: LD_INT 12
97425: PPUSH
97426: CALL_OW 12
97430: PPUSH
97431: CALL_OW 273
97435: ST_TO_ADDR
// if ValidHex ( x , y ) then
97436: LD_VAR 0 2
97440: PPUSH
97441: LD_VAR 0 3
97445: PPUSH
97446: CALL_OW 488
97450: IFFALSE 97485
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97452: LD_VAR 0 1
97456: PPUSH
97457: LD_VAR 0 2
97461: PPUSH
97462: LD_VAR 0 3
97466: PPUSH
97467: LD_INT 3
97469: PPUSH
97470: LD_INT 6
97472: PPUSH
97473: CALL_OW 12
97477: PPUSH
97478: LD_INT 1
97480: PPUSH
97481: CALL_OW 483
// end ;
97485: GO 97345
97487: POP
97488: POP
// end ;
97489: PPOPN 5
97491: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97492: LD_EXP 107
97496: PUSH
97497: LD_EXP 142
97501: AND
97502: IFFALSE 97596
97504: GO 97506
97506: DISABLE
97507: LD_INT 0
97509: PPUSH
97510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97511: LD_ADDR_VAR 0 2
97515: PUSH
97516: LD_INT 22
97518: PUSH
97519: LD_OWVAR 2
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: PUSH
97528: LD_INT 32
97530: PUSH
97531: LD_INT 1
97533: PUSH
97534: EMPTY
97535: LIST
97536: LIST
97537: PUSH
97538: LD_INT 21
97540: PUSH
97541: LD_INT 2
97543: PUSH
97544: EMPTY
97545: LIST
97546: LIST
97547: PUSH
97548: EMPTY
97549: LIST
97550: LIST
97551: LIST
97552: PPUSH
97553: CALL_OW 69
97557: ST_TO_ADDR
// if not tmp then
97558: LD_VAR 0 2
97562: NOT
97563: IFFALSE 97567
// exit ;
97565: GO 97596
// for i in tmp do
97567: LD_ADDR_VAR 0 1
97571: PUSH
97572: LD_VAR 0 2
97576: PUSH
97577: FOR_IN
97578: IFFALSE 97594
// SetFuel ( i , 0 ) ;
97580: LD_VAR 0 1
97584: PPUSH
97585: LD_INT 0
97587: PPUSH
97588: CALL_OW 240
97592: GO 97577
97594: POP
97595: POP
// end ;
97596: PPOPN 2
97598: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97599: LD_EXP 107
97603: PUSH
97604: LD_EXP 143
97608: AND
97609: IFFALSE 97675
97611: GO 97613
97613: DISABLE
97614: LD_INT 0
97616: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97617: LD_ADDR_VAR 0 1
97621: PUSH
97622: LD_INT 22
97624: PUSH
97625: LD_OWVAR 2
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: LD_INT 30
97636: PUSH
97637: LD_INT 29
97639: PUSH
97640: EMPTY
97641: LIST
97642: LIST
97643: PUSH
97644: EMPTY
97645: LIST
97646: LIST
97647: PPUSH
97648: CALL_OW 69
97652: ST_TO_ADDR
// if not tmp then
97653: LD_VAR 0 1
97657: NOT
97658: IFFALSE 97662
// exit ;
97660: GO 97675
// DestroyUnit ( tmp [ 1 ] ) ;
97662: LD_VAR 0 1
97666: PUSH
97667: LD_INT 1
97669: ARRAY
97670: PPUSH
97671: CALL_OW 65
// end ;
97675: PPOPN 1
97677: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97678: LD_EXP 107
97682: PUSH
97683: LD_EXP 145
97687: AND
97688: IFFALSE 97817
97690: GO 97692
97692: DISABLE
97693: LD_INT 0
97695: PPUSH
// begin uc_side := 0 ;
97696: LD_ADDR_OWVAR 20
97700: PUSH
97701: LD_INT 0
97703: ST_TO_ADDR
// uc_nation := nation_arabian ;
97704: LD_ADDR_OWVAR 21
97708: PUSH
97709: LD_INT 2
97711: ST_TO_ADDR
// hc_gallery :=  ;
97712: LD_ADDR_OWVAR 33
97716: PUSH
97717: LD_STRING 
97719: ST_TO_ADDR
// hc_name :=  ;
97720: LD_ADDR_OWVAR 26
97724: PUSH
97725: LD_STRING 
97727: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97728: LD_INT 1
97730: PPUSH
97731: LD_INT 11
97733: PPUSH
97734: LD_INT 10
97736: PPUSH
97737: CALL_OW 380
// un := CreateHuman ;
97741: LD_ADDR_VAR 0 1
97745: PUSH
97746: CALL_OW 44
97750: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97751: LD_VAR 0 1
97755: PPUSH
97756: LD_INT 1
97758: PPUSH
97759: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97763: LD_INT 35
97765: PPUSH
97766: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97770: LD_VAR 0 1
97774: PPUSH
97775: LD_INT 22
97777: PUSH
97778: LD_OWVAR 2
97782: PUSH
97783: EMPTY
97784: LIST
97785: LIST
97786: PPUSH
97787: CALL_OW 69
97791: PPUSH
97792: LD_VAR 0 1
97796: PPUSH
97797: CALL_OW 74
97801: PPUSH
97802: CALL_OW 115
// until IsDead ( un ) ;
97806: LD_VAR 0 1
97810: PPUSH
97811: CALL_OW 301
97815: IFFALSE 97763
// end ;
97817: PPOPN 1
97819: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97820: LD_EXP 107
97824: PUSH
97825: LD_EXP 147
97829: AND
97830: IFFALSE 97842
97832: GO 97834
97834: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97835: LD_STRING earthquake(getX(game), 0, 32)
97837: PPUSH
97838: CALL_OW 559
97842: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97843: LD_EXP 107
97847: PUSH
97848: LD_EXP 148
97852: AND
97853: IFFALSE 97944
97855: GO 97857
97857: DISABLE
97858: LD_INT 0
97860: PPUSH
// begin enable ;
97861: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97862: LD_ADDR_VAR 0 1
97866: PUSH
97867: LD_INT 22
97869: PUSH
97870: LD_OWVAR 2
97874: PUSH
97875: EMPTY
97876: LIST
97877: LIST
97878: PUSH
97879: LD_INT 21
97881: PUSH
97882: LD_INT 2
97884: PUSH
97885: EMPTY
97886: LIST
97887: LIST
97888: PUSH
97889: LD_INT 33
97891: PUSH
97892: LD_INT 3
97894: PUSH
97895: EMPTY
97896: LIST
97897: LIST
97898: PUSH
97899: EMPTY
97900: LIST
97901: LIST
97902: LIST
97903: PPUSH
97904: CALL_OW 69
97908: ST_TO_ADDR
// if not tmp then
97909: LD_VAR 0 1
97913: NOT
97914: IFFALSE 97918
// exit ;
97916: GO 97944
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97918: LD_VAR 0 1
97922: PUSH
97923: LD_INT 1
97925: PPUSH
97926: LD_VAR 0 1
97930: PPUSH
97931: CALL_OW 12
97935: ARRAY
97936: PPUSH
97937: LD_INT 1
97939: PPUSH
97940: CALL_OW 234
// end ;
97944: PPOPN 1
97946: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97947: LD_EXP 107
97951: PUSH
97952: LD_EXP 149
97956: AND
97957: IFFALSE 98098
97959: GO 97961
97961: DISABLE
97962: LD_INT 0
97964: PPUSH
97965: PPUSH
97966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97967: LD_ADDR_VAR 0 3
97971: PUSH
97972: LD_INT 22
97974: PUSH
97975: LD_OWVAR 2
97979: PUSH
97980: EMPTY
97981: LIST
97982: LIST
97983: PUSH
97984: LD_INT 25
97986: PUSH
97987: LD_INT 1
97989: PUSH
97990: EMPTY
97991: LIST
97992: LIST
97993: PUSH
97994: EMPTY
97995: LIST
97996: LIST
97997: PPUSH
97998: CALL_OW 69
98002: ST_TO_ADDR
// if not tmp then
98003: LD_VAR 0 3
98007: NOT
98008: IFFALSE 98012
// exit ;
98010: GO 98098
// un := tmp [ rand ( 1 , tmp ) ] ;
98012: LD_ADDR_VAR 0 2
98016: PUSH
98017: LD_VAR 0 3
98021: PUSH
98022: LD_INT 1
98024: PPUSH
98025: LD_VAR 0 3
98029: PPUSH
98030: CALL_OW 12
98034: ARRAY
98035: ST_TO_ADDR
// if Crawls ( un ) then
98036: LD_VAR 0 2
98040: PPUSH
98041: CALL_OW 318
98045: IFFALSE 98056
// ComWalk ( un ) ;
98047: LD_VAR 0 2
98051: PPUSH
98052: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98056: LD_VAR 0 2
98060: PPUSH
98061: LD_INT 9
98063: PPUSH
98064: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98068: LD_INT 28
98070: PPUSH
98071: LD_OWVAR 2
98075: PPUSH
98076: LD_INT 2
98078: PPUSH
98079: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98083: LD_INT 29
98085: PPUSH
98086: LD_OWVAR 2
98090: PPUSH
98091: LD_INT 2
98093: PPUSH
98094: CALL_OW 322
// end ;
98098: PPOPN 3
98100: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98101: LD_EXP 107
98105: PUSH
98106: LD_EXP 150
98110: AND
98111: IFFALSE 98222
98113: GO 98115
98115: DISABLE
98116: LD_INT 0
98118: PPUSH
98119: PPUSH
98120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98121: LD_ADDR_VAR 0 3
98125: PUSH
98126: LD_INT 22
98128: PUSH
98129: LD_OWVAR 2
98133: PUSH
98134: EMPTY
98135: LIST
98136: LIST
98137: PUSH
98138: LD_INT 25
98140: PUSH
98141: LD_INT 1
98143: PUSH
98144: EMPTY
98145: LIST
98146: LIST
98147: PUSH
98148: EMPTY
98149: LIST
98150: LIST
98151: PPUSH
98152: CALL_OW 69
98156: ST_TO_ADDR
// if not tmp then
98157: LD_VAR 0 3
98161: NOT
98162: IFFALSE 98166
// exit ;
98164: GO 98222
// un := tmp [ rand ( 1 , tmp ) ] ;
98166: LD_ADDR_VAR 0 2
98170: PUSH
98171: LD_VAR 0 3
98175: PUSH
98176: LD_INT 1
98178: PPUSH
98179: LD_VAR 0 3
98183: PPUSH
98184: CALL_OW 12
98188: ARRAY
98189: ST_TO_ADDR
// if Crawls ( un ) then
98190: LD_VAR 0 2
98194: PPUSH
98195: CALL_OW 318
98199: IFFALSE 98210
// ComWalk ( un ) ;
98201: LD_VAR 0 2
98205: PPUSH
98206: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98210: LD_VAR 0 2
98214: PPUSH
98215: LD_INT 8
98217: PPUSH
98218: CALL_OW 336
// end ;
98222: PPOPN 3
98224: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98225: LD_EXP 107
98229: PUSH
98230: LD_EXP 151
98234: AND
98235: IFFALSE 98379
98237: GO 98239
98239: DISABLE
98240: LD_INT 0
98242: PPUSH
98243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98244: LD_ADDR_VAR 0 2
98248: PUSH
98249: LD_INT 22
98251: PUSH
98252: LD_OWVAR 2
98256: PUSH
98257: EMPTY
98258: LIST
98259: LIST
98260: PUSH
98261: LD_INT 21
98263: PUSH
98264: LD_INT 2
98266: PUSH
98267: EMPTY
98268: LIST
98269: LIST
98270: PUSH
98271: LD_INT 2
98273: PUSH
98274: LD_INT 34
98276: PUSH
98277: LD_INT 12
98279: PUSH
98280: EMPTY
98281: LIST
98282: LIST
98283: PUSH
98284: LD_INT 34
98286: PUSH
98287: LD_INT 51
98289: PUSH
98290: EMPTY
98291: LIST
98292: LIST
98293: PUSH
98294: LD_INT 34
98296: PUSH
98297: LD_INT 32
98299: PUSH
98300: EMPTY
98301: LIST
98302: LIST
98303: PUSH
98304: EMPTY
98305: LIST
98306: LIST
98307: LIST
98308: LIST
98309: PUSH
98310: EMPTY
98311: LIST
98312: LIST
98313: LIST
98314: PPUSH
98315: CALL_OW 69
98319: ST_TO_ADDR
// if not tmp then
98320: LD_VAR 0 2
98324: NOT
98325: IFFALSE 98329
// exit ;
98327: GO 98379
// for i in tmp do
98329: LD_ADDR_VAR 0 1
98333: PUSH
98334: LD_VAR 0 2
98338: PUSH
98339: FOR_IN
98340: IFFALSE 98377
// if GetCargo ( i , mat_artifact ) = 0 then
98342: LD_VAR 0 1
98346: PPUSH
98347: LD_INT 4
98349: PPUSH
98350: CALL_OW 289
98354: PUSH
98355: LD_INT 0
98357: EQUAL
98358: IFFALSE 98375
// SetCargo ( i , mat_siberit , 100 ) ;
98360: LD_VAR 0 1
98364: PPUSH
98365: LD_INT 3
98367: PPUSH
98368: LD_INT 100
98370: PPUSH
98371: CALL_OW 290
98375: GO 98339
98377: POP
98378: POP
// end ;
98379: PPOPN 2
98381: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98382: LD_EXP 107
98386: PUSH
98387: LD_EXP 152
98391: AND
98392: IFFALSE 98575
98394: GO 98396
98396: DISABLE
98397: LD_INT 0
98399: PPUSH
98400: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98401: LD_ADDR_VAR 0 2
98405: PUSH
98406: LD_INT 22
98408: PUSH
98409: LD_OWVAR 2
98413: PUSH
98414: EMPTY
98415: LIST
98416: LIST
98417: PPUSH
98418: CALL_OW 69
98422: ST_TO_ADDR
// if not tmp then
98423: LD_VAR 0 2
98427: NOT
98428: IFFALSE 98432
// exit ;
98430: GO 98575
// for i := 1 to 2 do
98432: LD_ADDR_VAR 0 1
98436: PUSH
98437: DOUBLE
98438: LD_INT 1
98440: DEC
98441: ST_TO_ADDR
98442: LD_INT 2
98444: PUSH
98445: FOR_TO
98446: IFFALSE 98573
// begin uc_side := your_side ;
98448: LD_ADDR_OWVAR 20
98452: PUSH
98453: LD_OWVAR 2
98457: ST_TO_ADDR
// uc_nation := nation_american ;
98458: LD_ADDR_OWVAR 21
98462: PUSH
98463: LD_INT 1
98465: ST_TO_ADDR
// vc_chassis := us_morphling ;
98466: LD_ADDR_OWVAR 37
98470: PUSH
98471: LD_INT 5
98473: ST_TO_ADDR
// vc_engine := engine_siberite ;
98474: LD_ADDR_OWVAR 39
98478: PUSH
98479: LD_INT 3
98481: ST_TO_ADDR
// vc_control := control_computer ;
98482: LD_ADDR_OWVAR 38
98486: PUSH
98487: LD_INT 3
98489: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98490: LD_ADDR_OWVAR 40
98494: PUSH
98495: LD_INT 10
98497: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98498: LD_VAR 0 2
98502: PUSH
98503: LD_INT 1
98505: ARRAY
98506: PPUSH
98507: CALL_OW 310
98511: NOT
98512: IFFALSE 98559
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98514: CALL_OW 45
98518: PPUSH
98519: LD_VAR 0 2
98523: PUSH
98524: LD_INT 1
98526: ARRAY
98527: PPUSH
98528: CALL_OW 250
98532: PPUSH
98533: LD_VAR 0 2
98537: PUSH
98538: LD_INT 1
98540: ARRAY
98541: PPUSH
98542: CALL_OW 251
98546: PPUSH
98547: LD_INT 12
98549: PPUSH
98550: LD_INT 1
98552: PPUSH
98553: CALL_OW 50
98557: GO 98571
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98559: CALL_OW 45
98563: PPUSH
98564: LD_INT 1
98566: PPUSH
98567: CALL_OW 51
// end ;
98571: GO 98445
98573: POP
98574: POP
// end ;
98575: PPOPN 2
98577: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98578: LD_EXP 107
98582: PUSH
98583: LD_EXP 153
98587: AND
98588: IFFALSE 98810
98590: GO 98592
98592: DISABLE
98593: LD_INT 0
98595: PPUSH
98596: PPUSH
98597: PPUSH
98598: PPUSH
98599: PPUSH
98600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98601: LD_ADDR_VAR 0 6
98605: PUSH
98606: LD_INT 22
98608: PUSH
98609: LD_OWVAR 2
98613: PUSH
98614: EMPTY
98615: LIST
98616: LIST
98617: PUSH
98618: LD_INT 21
98620: PUSH
98621: LD_INT 1
98623: PUSH
98624: EMPTY
98625: LIST
98626: LIST
98627: PUSH
98628: LD_INT 3
98630: PUSH
98631: LD_INT 23
98633: PUSH
98634: LD_INT 0
98636: PUSH
98637: EMPTY
98638: LIST
98639: LIST
98640: PUSH
98641: EMPTY
98642: LIST
98643: LIST
98644: PUSH
98645: EMPTY
98646: LIST
98647: LIST
98648: LIST
98649: PPUSH
98650: CALL_OW 69
98654: ST_TO_ADDR
// if not tmp then
98655: LD_VAR 0 6
98659: NOT
98660: IFFALSE 98664
// exit ;
98662: GO 98810
// s1 := rand ( 1 , 4 ) ;
98664: LD_ADDR_VAR 0 2
98668: PUSH
98669: LD_INT 1
98671: PPUSH
98672: LD_INT 4
98674: PPUSH
98675: CALL_OW 12
98679: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98680: LD_ADDR_VAR 0 4
98684: PUSH
98685: LD_VAR 0 6
98689: PUSH
98690: LD_INT 1
98692: ARRAY
98693: PPUSH
98694: LD_VAR 0 2
98698: PPUSH
98699: CALL_OW 259
98703: ST_TO_ADDR
// if s1 = 1 then
98704: LD_VAR 0 2
98708: PUSH
98709: LD_INT 1
98711: EQUAL
98712: IFFALSE 98732
// s2 := rand ( 2 , 4 ) else
98714: LD_ADDR_VAR 0 3
98718: PUSH
98719: LD_INT 2
98721: PPUSH
98722: LD_INT 4
98724: PPUSH
98725: CALL_OW 12
98729: ST_TO_ADDR
98730: GO 98740
// s2 := 1 ;
98732: LD_ADDR_VAR 0 3
98736: PUSH
98737: LD_INT 1
98739: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98740: LD_ADDR_VAR 0 5
98744: PUSH
98745: LD_VAR 0 6
98749: PUSH
98750: LD_INT 1
98752: ARRAY
98753: PPUSH
98754: LD_VAR 0 3
98758: PPUSH
98759: CALL_OW 259
98763: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98764: LD_VAR 0 6
98768: PUSH
98769: LD_INT 1
98771: ARRAY
98772: PPUSH
98773: LD_VAR 0 2
98777: PPUSH
98778: LD_VAR 0 5
98782: PPUSH
98783: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98787: LD_VAR 0 6
98791: PUSH
98792: LD_INT 1
98794: ARRAY
98795: PPUSH
98796: LD_VAR 0 3
98800: PPUSH
98801: LD_VAR 0 4
98805: PPUSH
98806: CALL_OW 237
// end ;
98810: PPOPN 6
98812: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98813: LD_EXP 107
98817: PUSH
98818: LD_EXP 154
98822: AND
98823: IFFALSE 98902
98825: GO 98827
98827: DISABLE
98828: LD_INT 0
98830: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98831: LD_ADDR_VAR 0 1
98835: PUSH
98836: LD_INT 22
98838: PUSH
98839: LD_OWVAR 2
98843: PUSH
98844: EMPTY
98845: LIST
98846: LIST
98847: PUSH
98848: LD_INT 30
98850: PUSH
98851: LD_INT 3
98853: PUSH
98854: EMPTY
98855: LIST
98856: LIST
98857: PUSH
98858: EMPTY
98859: LIST
98860: LIST
98861: PPUSH
98862: CALL_OW 69
98866: ST_TO_ADDR
// if not tmp then
98867: LD_VAR 0 1
98871: NOT
98872: IFFALSE 98876
// exit ;
98874: GO 98902
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98876: LD_VAR 0 1
98880: PUSH
98881: LD_INT 1
98883: PPUSH
98884: LD_VAR 0 1
98888: PPUSH
98889: CALL_OW 12
98893: ARRAY
98894: PPUSH
98895: LD_INT 1
98897: PPUSH
98898: CALL_OW 234
// end ;
98902: PPOPN 1
98904: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98905: LD_EXP 107
98909: PUSH
98910: LD_EXP 155
98914: AND
98915: IFFALSE 99027
98917: GO 98919
98919: DISABLE
98920: LD_INT 0
98922: PPUSH
98923: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98924: LD_ADDR_VAR 0 2
98928: PUSH
98929: LD_INT 22
98931: PUSH
98932: LD_OWVAR 2
98936: PUSH
98937: EMPTY
98938: LIST
98939: LIST
98940: PUSH
98941: LD_INT 2
98943: PUSH
98944: LD_INT 30
98946: PUSH
98947: LD_INT 27
98949: PUSH
98950: EMPTY
98951: LIST
98952: LIST
98953: PUSH
98954: LD_INT 30
98956: PUSH
98957: LD_INT 26
98959: PUSH
98960: EMPTY
98961: LIST
98962: LIST
98963: PUSH
98964: LD_INT 30
98966: PUSH
98967: LD_INT 28
98969: PUSH
98970: EMPTY
98971: LIST
98972: LIST
98973: PUSH
98974: EMPTY
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: PUSH
98980: EMPTY
98981: LIST
98982: LIST
98983: PPUSH
98984: CALL_OW 69
98988: ST_TO_ADDR
// if not tmp then
98989: LD_VAR 0 2
98993: NOT
98994: IFFALSE 98998
// exit ;
98996: GO 99027
// for i in tmp do
98998: LD_ADDR_VAR 0 1
99002: PUSH
99003: LD_VAR 0 2
99007: PUSH
99008: FOR_IN
99009: IFFALSE 99025
// SetLives ( i , 1 ) ;
99011: LD_VAR 0 1
99015: PPUSH
99016: LD_INT 1
99018: PPUSH
99019: CALL_OW 234
99023: GO 99008
99025: POP
99026: POP
// end ;
99027: PPOPN 2
99029: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99030: LD_EXP 107
99034: PUSH
99035: LD_EXP 156
99039: AND
99040: IFFALSE 99327
99042: GO 99044
99044: DISABLE
99045: LD_INT 0
99047: PPUSH
99048: PPUSH
99049: PPUSH
// begin i := rand ( 1 , 7 ) ;
99050: LD_ADDR_VAR 0 1
99054: PUSH
99055: LD_INT 1
99057: PPUSH
99058: LD_INT 7
99060: PPUSH
99061: CALL_OW 12
99065: ST_TO_ADDR
// case i of 1 :
99066: LD_VAR 0 1
99070: PUSH
99071: LD_INT 1
99073: DOUBLE
99074: EQUAL
99075: IFTRUE 99079
99077: GO 99089
99079: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99080: LD_STRING earthquake(getX(game), 0, 32)
99082: PPUSH
99083: CALL_OW 559
99087: GO 99327
99089: LD_INT 2
99091: DOUBLE
99092: EQUAL
99093: IFTRUE 99097
99095: GO 99111
99097: POP
// begin ToLua ( displayStucuk(); ) ;
99098: LD_STRING displayStucuk();
99100: PPUSH
99101: CALL_OW 559
// ResetFog ;
99105: CALL_OW 335
// end ; 3 :
99109: GO 99327
99111: LD_INT 3
99113: DOUBLE
99114: EQUAL
99115: IFTRUE 99119
99117: GO 99223
99119: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99120: LD_ADDR_VAR 0 2
99124: PUSH
99125: LD_INT 22
99127: PUSH
99128: LD_OWVAR 2
99132: PUSH
99133: EMPTY
99134: LIST
99135: LIST
99136: PUSH
99137: LD_INT 25
99139: PUSH
99140: LD_INT 1
99142: PUSH
99143: EMPTY
99144: LIST
99145: LIST
99146: PUSH
99147: EMPTY
99148: LIST
99149: LIST
99150: PPUSH
99151: CALL_OW 69
99155: ST_TO_ADDR
// if not tmp then
99156: LD_VAR 0 2
99160: NOT
99161: IFFALSE 99165
// exit ;
99163: GO 99327
// un := tmp [ rand ( 1 , tmp ) ] ;
99165: LD_ADDR_VAR 0 3
99169: PUSH
99170: LD_VAR 0 2
99174: PUSH
99175: LD_INT 1
99177: PPUSH
99178: LD_VAR 0 2
99182: PPUSH
99183: CALL_OW 12
99187: ARRAY
99188: ST_TO_ADDR
// if Crawls ( un ) then
99189: LD_VAR 0 3
99193: PPUSH
99194: CALL_OW 318
99198: IFFALSE 99209
// ComWalk ( un ) ;
99200: LD_VAR 0 3
99204: PPUSH
99205: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99209: LD_VAR 0 3
99213: PPUSH
99214: LD_INT 8
99216: PPUSH
99217: CALL_OW 336
// end ; 4 :
99221: GO 99327
99223: LD_INT 4
99225: DOUBLE
99226: EQUAL
99227: IFTRUE 99231
99229: GO 99305
99231: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99232: LD_ADDR_VAR 0 2
99236: PUSH
99237: LD_INT 22
99239: PUSH
99240: LD_OWVAR 2
99244: PUSH
99245: EMPTY
99246: LIST
99247: LIST
99248: PUSH
99249: LD_INT 30
99251: PUSH
99252: LD_INT 29
99254: PUSH
99255: EMPTY
99256: LIST
99257: LIST
99258: PUSH
99259: EMPTY
99260: LIST
99261: LIST
99262: PPUSH
99263: CALL_OW 69
99267: ST_TO_ADDR
// if not tmp then
99268: LD_VAR 0 2
99272: NOT
99273: IFFALSE 99277
// exit ;
99275: GO 99327
// CenterNowOnUnits ( tmp [ 1 ] ) ;
99277: LD_VAR 0 2
99281: PUSH
99282: LD_INT 1
99284: ARRAY
99285: PPUSH
99286: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
99290: LD_VAR 0 2
99294: PUSH
99295: LD_INT 1
99297: ARRAY
99298: PPUSH
99299: CALL_OW 65
// end ; 5 .. 7 :
99303: GO 99327
99305: LD_INT 5
99307: DOUBLE
99308: GREATEREQUAL
99309: IFFALSE 99317
99311: LD_INT 7
99313: DOUBLE
99314: LESSEQUAL
99315: IFTRUE 99319
99317: GO 99326
99319: POP
// StreamSibBomb ; end ;
99320: CALL 95564 0 0
99324: GO 99327
99326: POP
// end ;
99327: PPOPN 3
99329: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99330: LD_EXP 107
99334: PUSH
99335: LD_EXP 157
99339: AND
99340: IFFALSE 99496
99342: GO 99344
99344: DISABLE
99345: LD_INT 0
99347: PPUSH
99348: PPUSH
99349: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99350: LD_ADDR_VAR 0 2
99354: PUSH
99355: LD_INT 81
99357: PUSH
99358: LD_OWVAR 2
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: PUSH
99367: LD_INT 2
99369: PUSH
99370: LD_INT 21
99372: PUSH
99373: LD_INT 1
99375: PUSH
99376: EMPTY
99377: LIST
99378: LIST
99379: PUSH
99380: LD_INT 21
99382: PUSH
99383: LD_INT 2
99385: PUSH
99386: EMPTY
99387: LIST
99388: LIST
99389: PUSH
99390: EMPTY
99391: LIST
99392: LIST
99393: LIST
99394: PUSH
99395: EMPTY
99396: LIST
99397: LIST
99398: PPUSH
99399: CALL_OW 69
99403: ST_TO_ADDR
// if not tmp then
99404: LD_VAR 0 2
99408: NOT
99409: IFFALSE 99413
// exit ;
99411: GO 99496
// p := 0 ;
99413: LD_ADDR_VAR 0 3
99417: PUSH
99418: LD_INT 0
99420: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99421: LD_INT 35
99423: PPUSH
99424: CALL_OW 67
// p := p + 1 ;
99428: LD_ADDR_VAR 0 3
99432: PUSH
99433: LD_VAR 0 3
99437: PUSH
99438: LD_INT 1
99440: PLUS
99441: ST_TO_ADDR
// for i in tmp do
99442: LD_ADDR_VAR 0 1
99446: PUSH
99447: LD_VAR 0 2
99451: PUSH
99452: FOR_IN
99453: IFFALSE 99484
// if GetLives ( i ) < 1000 then
99455: LD_VAR 0 1
99459: PPUSH
99460: CALL_OW 256
99464: PUSH
99465: LD_INT 1000
99467: LESS
99468: IFFALSE 99482
// SetLives ( i , 1000 ) ;
99470: LD_VAR 0 1
99474: PPUSH
99475: LD_INT 1000
99477: PPUSH
99478: CALL_OW 234
99482: GO 99452
99484: POP
99485: POP
// until p > 20 ;
99486: LD_VAR 0 3
99490: PUSH
99491: LD_INT 20
99493: GREATER
99494: IFFALSE 99421
// end ;
99496: PPOPN 3
99498: END
// every 0 0$1 trigger StreamModeActive and sTime do
99499: LD_EXP 107
99503: PUSH
99504: LD_EXP 158
99508: AND
99509: IFFALSE 99544
99511: GO 99513
99513: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99514: LD_INT 28
99516: PPUSH
99517: LD_OWVAR 2
99521: PPUSH
99522: LD_INT 2
99524: PPUSH
99525: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99529: LD_INT 30
99531: PPUSH
99532: LD_OWVAR 2
99536: PPUSH
99537: LD_INT 2
99539: PPUSH
99540: CALL_OW 322
// end ;
99544: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99545: LD_EXP 107
99549: PUSH
99550: LD_EXP 159
99554: AND
99555: IFFALSE 99676
99557: GO 99559
99559: DISABLE
99560: LD_INT 0
99562: PPUSH
99563: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99564: LD_ADDR_VAR 0 2
99568: PUSH
99569: LD_INT 22
99571: PUSH
99572: LD_OWVAR 2
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: PUSH
99581: LD_INT 21
99583: PUSH
99584: LD_INT 1
99586: PUSH
99587: EMPTY
99588: LIST
99589: LIST
99590: PUSH
99591: LD_INT 3
99593: PUSH
99594: LD_INT 23
99596: PUSH
99597: LD_INT 0
99599: PUSH
99600: EMPTY
99601: LIST
99602: LIST
99603: PUSH
99604: EMPTY
99605: LIST
99606: LIST
99607: PUSH
99608: EMPTY
99609: LIST
99610: LIST
99611: LIST
99612: PPUSH
99613: CALL_OW 69
99617: ST_TO_ADDR
// if not tmp then
99618: LD_VAR 0 2
99622: NOT
99623: IFFALSE 99627
// exit ;
99625: GO 99676
// for i in tmp do
99627: LD_ADDR_VAR 0 1
99631: PUSH
99632: LD_VAR 0 2
99636: PUSH
99637: FOR_IN
99638: IFFALSE 99674
// begin if Crawls ( i ) then
99640: LD_VAR 0 1
99644: PPUSH
99645: CALL_OW 318
99649: IFFALSE 99660
// ComWalk ( i ) ;
99651: LD_VAR 0 1
99655: PPUSH
99656: CALL_OW 138
// SetClass ( i , 2 ) ;
99660: LD_VAR 0 1
99664: PPUSH
99665: LD_INT 2
99667: PPUSH
99668: CALL_OW 336
// end ;
99672: GO 99637
99674: POP
99675: POP
// end ;
99676: PPOPN 2
99678: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99679: LD_EXP 107
99683: PUSH
99684: LD_EXP 160
99688: AND
99689: IFFALSE 99977
99691: GO 99693
99693: DISABLE
99694: LD_INT 0
99696: PPUSH
99697: PPUSH
99698: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99699: LD_OWVAR 2
99703: PPUSH
99704: LD_INT 9
99706: PPUSH
99707: LD_INT 1
99709: PPUSH
99710: LD_INT 1
99712: PPUSH
99713: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99717: LD_INT 9
99719: PPUSH
99720: LD_OWVAR 2
99724: PPUSH
99725: CALL_OW 343
// uc_side := 9 ;
99729: LD_ADDR_OWVAR 20
99733: PUSH
99734: LD_INT 9
99736: ST_TO_ADDR
// uc_nation := 2 ;
99737: LD_ADDR_OWVAR 21
99741: PUSH
99742: LD_INT 2
99744: ST_TO_ADDR
// hc_name := Dark Warrior ;
99745: LD_ADDR_OWVAR 26
99749: PUSH
99750: LD_STRING Dark Warrior
99752: ST_TO_ADDR
// hc_gallery :=  ;
99753: LD_ADDR_OWVAR 33
99757: PUSH
99758: LD_STRING 
99760: ST_TO_ADDR
// hc_noskilllimit := true ;
99761: LD_ADDR_OWVAR 76
99765: PUSH
99766: LD_INT 1
99768: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99769: LD_ADDR_OWVAR 31
99773: PUSH
99774: LD_INT 30
99776: PUSH
99777: LD_INT 30
99779: PUSH
99780: LD_INT 30
99782: PUSH
99783: LD_INT 30
99785: PUSH
99786: EMPTY
99787: LIST
99788: LIST
99789: LIST
99790: LIST
99791: ST_TO_ADDR
// un := CreateHuman ;
99792: LD_ADDR_VAR 0 3
99796: PUSH
99797: CALL_OW 44
99801: ST_TO_ADDR
// hc_noskilllimit := false ;
99802: LD_ADDR_OWVAR 76
99806: PUSH
99807: LD_INT 0
99809: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99810: LD_VAR 0 3
99814: PPUSH
99815: LD_INT 1
99817: PPUSH
99818: CALL_OW 51
// ToLua ( playRanger() ) ;
99822: LD_STRING playRanger()
99824: PPUSH
99825: CALL_OW 559
// p := 0 ;
99829: LD_ADDR_VAR 0 2
99833: PUSH
99834: LD_INT 0
99836: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99837: LD_INT 35
99839: PPUSH
99840: CALL_OW 67
// p := p + 1 ;
99844: LD_ADDR_VAR 0 2
99848: PUSH
99849: LD_VAR 0 2
99853: PUSH
99854: LD_INT 1
99856: PLUS
99857: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99858: LD_VAR 0 3
99862: PPUSH
99863: CALL_OW 256
99867: PUSH
99868: LD_INT 1000
99870: LESS
99871: IFFALSE 99885
// SetLives ( un , 1000 ) ;
99873: LD_VAR 0 3
99877: PPUSH
99878: LD_INT 1000
99880: PPUSH
99881: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99885: LD_VAR 0 3
99889: PPUSH
99890: LD_INT 81
99892: PUSH
99893: LD_OWVAR 2
99897: PUSH
99898: EMPTY
99899: LIST
99900: LIST
99901: PUSH
99902: LD_INT 91
99904: PUSH
99905: LD_VAR 0 3
99909: PUSH
99910: LD_INT 30
99912: PUSH
99913: EMPTY
99914: LIST
99915: LIST
99916: LIST
99917: PUSH
99918: EMPTY
99919: LIST
99920: LIST
99921: PPUSH
99922: CALL_OW 69
99926: PPUSH
99927: LD_VAR 0 3
99931: PPUSH
99932: CALL_OW 74
99936: PPUSH
99937: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99941: LD_VAR 0 2
99945: PUSH
99946: LD_INT 80
99948: GREATER
99949: PUSH
99950: LD_VAR 0 3
99954: PPUSH
99955: CALL_OW 301
99959: OR
99960: IFFALSE 99837
// if un then
99962: LD_VAR 0 3
99966: IFFALSE 99977
// RemoveUnit ( un ) ;
99968: LD_VAR 0 3
99972: PPUSH
99973: CALL_OW 64
// end ;
99977: PPOPN 3
99979: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99980: LD_EXP 161
99984: IFFALSE 100100
99986: GO 99988
99988: DISABLE
99989: LD_INT 0
99991: PPUSH
99992: PPUSH
99993: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99994: LD_ADDR_VAR 0 2
99998: PUSH
99999: LD_INT 81
100001: PUSH
100002: LD_OWVAR 2
100006: PUSH
100007: EMPTY
100008: LIST
100009: LIST
100010: PUSH
100011: LD_INT 21
100013: PUSH
100014: LD_INT 1
100016: PUSH
100017: EMPTY
100018: LIST
100019: LIST
100020: PUSH
100021: EMPTY
100022: LIST
100023: LIST
100024: PPUSH
100025: CALL_OW 69
100029: ST_TO_ADDR
// ToLua ( playComputer() ) ;
100030: LD_STRING playComputer()
100032: PPUSH
100033: CALL_OW 559
// if not tmp then
100037: LD_VAR 0 2
100041: NOT
100042: IFFALSE 100046
// exit ;
100044: GO 100100
// for i in tmp do
100046: LD_ADDR_VAR 0 1
100050: PUSH
100051: LD_VAR 0 2
100055: PUSH
100056: FOR_IN
100057: IFFALSE 100098
// for j := 1 to 4 do
100059: LD_ADDR_VAR 0 3
100063: PUSH
100064: DOUBLE
100065: LD_INT 1
100067: DEC
100068: ST_TO_ADDR
100069: LD_INT 4
100071: PUSH
100072: FOR_TO
100073: IFFALSE 100094
// SetSkill ( i , j , 10 ) ;
100075: LD_VAR 0 1
100079: PPUSH
100080: LD_VAR 0 3
100084: PPUSH
100085: LD_INT 10
100087: PPUSH
100088: CALL_OW 237
100092: GO 100072
100094: POP
100095: POP
100096: GO 100056
100098: POP
100099: POP
// end ;
100100: PPOPN 3
100102: END
// every 0 0$1 trigger s30 do var i , tmp ;
100103: LD_EXP 162
100107: IFFALSE 100176
100109: GO 100111
100111: DISABLE
100112: LD_INT 0
100114: PPUSH
100115: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100116: LD_ADDR_VAR 0 2
100120: PUSH
100121: LD_INT 22
100123: PUSH
100124: LD_OWVAR 2
100128: PUSH
100129: EMPTY
100130: LIST
100131: LIST
100132: PPUSH
100133: CALL_OW 69
100137: ST_TO_ADDR
// if not tmp then
100138: LD_VAR 0 2
100142: NOT
100143: IFFALSE 100147
// exit ;
100145: GO 100176
// for i in tmp do
100147: LD_ADDR_VAR 0 1
100151: PUSH
100152: LD_VAR 0 2
100156: PUSH
100157: FOR_IN
100158: IFFALSE 100174
// SetLives ( i , 300 ) ;
100160: LD_VAR 0 1
100164: PPUSH
100165: LD_INT 300
100167: PPUSH
100168: CALL_OW 234
100172: GO 100157
100174: POP
100175: POP
// end ;
100176: PPOPN 2
100178: END
// every 0 0$1 trigger s60 do var i , tmp ;
100179: LD_EXP 163
100183: IFFALSE 100252
100185: GO 100187
100187: DISABLE
100188: LD_INT 0
100190: PPUSH
100191: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100192: LD_ADDR_VAR 0 2
100196: PUSH
100197: LD_INT 22
100199: PUSH
100200: LD_OWVAR 2
100204: PUSH
100205: EMPTY
100206: LIST
100207: LIST
100208: PPUSH
100209: CALL_OW 69
100213: ST_TO_ADDR
// if not tmp then
100214: LD_VAR 0 2
100218: NOT
100219: IFFALSE 100223
// exit ;
100221: GO 100252
// for i in tmp do
100223: LD_ADDR_VAR 0 1
100227: PUSH
100228: LD_VAR 0 2
100232: PUSH
100233: FOR_IN
100234: IFFALSE 100250
// SetLives ( i , 600 ) ;
100236: LD_VAR 0 1
100240: PPUSH
100241: LD_INT 600
100243: PPUSH
100244: CALL_OW 234
100248: GO 100233
100250: POP
100251: POP
// end ;
100252: PPOPN 2
100254: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100255: LD_INT 0
100257: PPUSH
// case cmd of 301 :
100258: LD_VAR 0 1
100262: PUSH
100263: LD_INT 301
100265: DOUBLE
100266: EQUAL
100267: IFTRUE 100271
100269: GO 100303
100271: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100272: LD_VAR 0 6
100276: PPUSH
100277: LD_VAR 0 7
100281: PPUSH
100282: LD_VAR 0 8
100286: PPUSH
100287: LD_VAR 0 4
100291: PPUSH
100292: LD_VAR 0 5
100296: PPUSH
100297: CALL 101512 0 5
100301: GO 100424
100303: LD_INT 302
100305: DOUBLE
100306: EQUAL
100307: IFTRUE 100311
100309: GO 100348
100311: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100312: LD_VAR 0 6
100316: PPUSH
100317: LD_VAR 0 7
100321: PPUSH
100322: LD_VAR 0 8
100326: PPUSH
100327: LD_VAR 0 9
100331: PPUSH
100332: LD_VAR 0 4
100336: PPUSH
100337: LD_VAR 0 5
100341: PPUSH
100342: CALL 101603 0 6
100346: GO 100424
100348: LD_INT 303
100350: DOUBLE
100351: EQUAL
100352: IFTRUE 100356
100354: GO 100393
100356: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100357: LD_VAR 0 6
100361: PPUSH
100362: LD_VAR 0 7
100366: PPUSH
100367: LD_VAR 0 8
100371: PPUSH
100372: LD_VAR 0 9
100376: PPUSH
100377: LD_VAR 0 4
100381: PPUSH
100382: LD_VAR 0 5
100386: PPUSH
100387: CALL 100429 0 6
100391: GO 100424
100393: LD_INT 304
100395: DOUBLE
100396: EQUAL
100397: IFTRUE 100401
100399: GO 100423
100401: POP
// hHackTeleport ( unit , x , y ) ; end ;
100402: LD_VAR 0 2
100406: PPUSH
100407: LD_VAR 0 4
100411: PPUSH
100412: LD_VAR 0 5
100416: PPUSH
100417: CALL 102196 0 3
100421: GO 100424
100423: POP
// end ;
100424: LD_VAR 0 12
100428: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100429: LD_INT 0
100431: PPUSH
100432: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100433: LD_VAR 0 1
100437: PUSH
100438: LD_INT 1
100440: LESS
100441: PUSH
100442: LD_VAR 0 1
100446: PUSH
100447: LD_INT 3
100449: GREATER
100450: OR
100451: PUSH
100452: LD_VAR 0 5
100456: PPUSH
100457: LD_VAR 0 6
100461: PPUSH
100462: CALL_OW 428
100466: OR
100467: IFFALSE 100471
// exit ;
100469: GO 101199
// uc_side := your_side ;
100471: LD_ADDR_OWVAR 20
100475: PUSH
100476: LD_OWVAR 2
100480: ST_TO_ADDR
// uc_nation := nation ;
100481: LD_ADDR_OWVAR 21
100485: PUSH
100486: LD_VAR 0 1
100490: ST_TO_ADDR
// bc_level = 1 ;
100491: LD_ADDR_OWVAR 43
100495: PUSH
100496: LD_INT 1
100498: ST_TO_ADDR
// case btype of 1 :
100499: LD_VAR 0 2
100503: PUSH
100504: LD_INT 1
100506: DOUBLE
100507: EQUAL
100508: IFTRUE 100512
100510: GO 100523
100512: POP
// bc_type := b_depot ; 2 :
100513: LD_ADDR_OWVAR 42
100517: PUSH
100518: LD_INT 0
100520: ST_TO_ADDR
100521: GO 101143
100523: LD_INT 2
100525: DOUBLE
100526: EQUAL
100527: IFTRUE 100531
100529: GO 100542
100531: POP
// bc_type := b_warehouse ; 3 :
100532: LD_ADDR_OWVAR 42
100536: PUSH
100537: LD_INT 1
100539: ST_TO_ADDR
100540: GO 101143
100542: LD_INT 3
100544: DOUBLE
100545: EQUAL
100546: IFTRUE 100550
100548: GO 100561
100550: POP
// bc_type := b_lab ; 4 .. 9 :
100551: LD_ADDR_OWVAR 42
100555: PUSH
100556: LD_INT 6
100558: ST_TO_ADDR
100559: GO 101143
100561: LD_INT 4
100563: DOUBLE
100564: GREATEREQUAL
100565: IFFALSE 100573
100567: LD_INT 9
100569: DOUBLE
100570: LESSEQUAL
100571: IFTRUE 100575
100573: GO 100635
100575: POP
// begin bc_type := b_lab_half ;
100576: LD_ADDR_OWVAR 42
100580: PUSH
100581: LD_INT 7
100583: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100584: LD_ADDR_OWVAR 44
100588: PUSH
100589: LD_INT 10
100591: PUSH
100592: LD_INT 11
100594: PUSH
100595: LD_INT 12
100597: PUSH
100598: LD_INT 15
100600: PUSH
100601: LD_INT 14
100603: PUSH
100604: LD_INT 13
100606: PUSH
100607: EMPTY
100608: LIST
100609: LIST
100610: LIST
100611: LIST
100612: LIST
100613: LIST
100614: PUSH
100615: LD_VAR 0 2
100619: PUSH
100620: LD_INT 3
100622: MINUS
100623: ARRAY
100624: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
100625: LD_ADDR_OWVAR 45
100629: PUSH
100630: LD_INT 9
100632: ST_TO_ADDR
// end ; 10 .. 13 :
100633: GO 101143
100635: LD_INT 10
100637: DOUBLE
100638: GREATEREQUAL
100639: IFFALSE 100647
100641: LD_INT 13
100643: DOUBLE
100644: LESSEQUAL
100645: IFTRUE 100649
100647: GO 100726
100649: POP
// begin bc_type := b_lab_full ;
100650: LD_ADDR_OWVAR 42
100654: PUSH
100655: LD_INT 8
100657: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100658: LD_ADDR_OWVAR 44
100662: PUSH
100663: LD_INT 10
100665: PUSH
100666: LD_INT 12
100668: PUSH
100669: LD_INT 14
100671: PUSH
100672: LD_INT 13
100674: PUSH
100675: EMPTY
100676: LIST
100677: LIST
100678: LIST
100679: LIST
100680: PUSH
100681: LD_VAR 0 2
100685: PUSH
100686: LD_INT 9
100688: MINUS
100689: ARRAY
100690: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100691: LD_ADDR_OWVAR 45
100695: PUSH
100696: LD_INT 11
100698: PUSH
100699: LD_INT 15
100701: PUSH
100702: LD_INT 12
100704: PUSH
100705: LD_INT 15
100707: PUSH
100708: EMPTY
100709: LIST
100710: LIST
100711: LIST
100712: LIST
100713: PUSH
100714: LD_VAR 0 2
100718: PUSH
100719: LD_INT 9
100721: MINUS
100722: ARRAY
100723: ST_TO_ADDR
// end ; 14 :
100724: GO 101143
100726: LD_INT 14
100728: DOUBLE
100729: EQUAL
100730: IFTRUE 100734
100732: GO 100745
100734: POP
// bc_type := b_workshop ; 15 :
100735: LD_ADDR_OWVAR 42
100739: PUSH
100740: LD_INT 2
100742: ST_TO_ADDR
100743: GO 101143
100745: LD_INT 15
100747: DOUBLE
100748: EQUAL
100749: IFTRUE 100753
100751: GO 100764
100753: POP
// bc_type := b_factory ; 16 :
100754: LD_ADDR_OWVAR 42
100758: PUSH
100759: LD_INT 3
100761: ST_TO_ADDR
100762: GO 101143
100764: LD_INT 16
100766: DOUBLE
100767: EQUAL
100768: IFTRUE 100772
100770: GO 100783
100772: POP
// bc_type := b_ext_gun ; 17 :
100773: LD_ADDR_OWVAR 42
100777: PUSH
100778: LD_INT 17
100780: ST_TO_ADDR
100781: GO 101143
100783: LD_INT 17
100785: DOUBLE
100786: EQUAL
100787: IFTRUE 100791
100789: GO 100819
100791: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100792: LD_ADDR_OWVAR 42
100796: PUSH
100797: LD_INT 19
100799: PUSH
100800: LD_INT 23
100802: PUSH
100803: LD_INT 19
100805: PUSH
100806: EMPTY
100807: LIST
100808: LIST
100809: LIST
100810: PUSH
100811: LD_VAR 0 1
100815: ARRAY
100816: ST_TO_ADDR
100817: GO 101143
100819: LD_INT 18
100821: DOUBLE
100822: EQUAL
100823: IFTRUE 100827
100825: GO 100838
100827: POP
// bc_type := b_ext_radar ; 19 :
100828: LD_ADDR_OWVAR 42
100832: PUSH
100833: LD_INT 20
100835: ST_TO_ADDR
100836: GO 101143
100838: LD_INT 19
100840: DOUBLE
100841: EQUAL
100842: IFTRUE 100846
100844: GO 100857
100846: POP
// bc_type := b_ext_radio ; 20 :
100847: LD_ADDR_OWVAR 42
100851: PUSH
100852: LD_INT 22
100854: ST_TO_ADDR
100855: GO 101143
100857: LD_INT 20
100859: DOUBLE
100860: EQUAL
100861: IFTRUE 100865
100863: GO 100876
100865: POP
// bc_type := b_ext_siberium ; 21 :
100866: LD_ADDR_OWVAR 42
100870: PUSH
100871: LD_INT 21
100873: ST_TO_ADDR
100874: GO 101143
100876: LD_INT 21
100878: DOUBLE
100879: EQUAL
100880: IFTRUE 100884
100882: GO 100895
100884: POP
// bc_type := b_ext_computer ; 22 :
100885: LD_ADDR_OWVAR 42
100889: PUSH
100890: LD_INT 24
100892: ST_TO_ADDR
100893: GO 101143
100895: LD_INT 22
100897: DOUBLE
100898: EQUAL
100899: IFTRUE 100903
100901: GO 100914
100903: POP
// bc_type := b_ext_track ; 23 :
100904: LD_ADDR_OWVAR 42
100908: PUSH
100909: LD_INT 16
100911: ST_TO_ADDR
100912: GO 101143
100914: LD_INT 23
100916: DOUBLE
100917: EQUAL
100918: IFTRUE 100922
100920: GO 100933
100922: POP
// bc_type := b_ext_laser ; 24 :
100923: LD_ADDR_OWVAR 42
100927: PUSH
100928: LD_INT 25
100930: ST_TO_ADDR
100931: GO 101143
100933: LD_INT 24
100935: DOUBLE
100936: EQUAL
100937: IFTRUE 100941
100939: GO 100952
100941: POP
// bc_type := b_control_tower ; 25 :
100942: LD_ADDR_OWVAR 42
100946: PUSH
100947: LD_INT 36
100949: ST_TO_ADDR
100950: GO 101143
100952: LD_INT 25
100954: DOUBLE
100955: EQUAL
100956: IFTRUE 100960
100958: GO 100971
100960: POP
// bc_type := b_breastwork ; 26 :
100961: LD_ADDR_OWVAR 42
100965: PUSH
100966: LD_INT 31
100968: ST_TO_ADDR
100969: GO 101143
100971: LD_INT 26
100973: DOUBLE
100974: EQUAL
100975: IFTRUE 100979
100977: GO 100990
100979: POP
// bc_type := b_bunker ; 27 :
100980: LD_ADDR_OWVAR 42
100984: PUSH
100985: LD_INT 32
100987: ST_TO_ADDR
100988: GO 101143
100990: LD_INT 27
100992: DOUBLE
100993: EQUAL
100994: IFTRUE 100998
100996: GO 101009
100998: POP
// bc_type := b_turret ; 28 :
100999: LD_ADDR_OWVAR 42
101003: PUSH
101004: LD_INT 33
101006: ST_TO_ADDR
101007: GO 101143
101009: LD_INT 28
101011: DOUBLE
101012: EQUAL
101013: IFTRUE 101017
101015: GO 101028
101017: POP
// bc_type := b_armoury ; 29 :
101018: LD_ADDR_OWVAR 42
101022: PUSH
101023: LD_INT 4
101025: ST_TO_ADDR
101026: GO 101143
101028: LD_INT 29
101030: DOUBLE
101031: EQUAL
101032: IFTRUE 101036
101034: GO 101047
101036: POP
// bc_type := b_barracks ; 30 :
101037: LD_ADDR_OWVAR 42
101041: PUSH
101042: LD_INT 5
101044: ST_TO_ADDR
101045: GO 101143
101047: LD_INT 30
101049: DOUBLE
101050: EQUAL
101051: IFTRUE 101055
101053: GO 101066
101055: POP
// bc_type := b_solar_power ; 31 :
101056: LD_ADDR_OWVAR 42
101060: PUSH
101061: LD_INT 27
101063: ST_TO_ADDR
101064: GO 101143
101066: LD_INT 31
101068: DOUBLE
101069: EQUAL
101070: IFTRUE 101074
101072: GO 101085
101074: POP
// bc_type := b_oil_power ; 32 :
101075: LD_ADDR_OWVAR 42
101079: PUSH
101080: LD_INT 26
101082: ST_TO_ADDR
101083: GO 101143
101085: LD_INT 32
101087: DOUBLE
101088: EQUAL
101089: IFTRUE 101093
101091: GO 101104
101093: POP
// bc_type := b_siberite_power ; 33 :
101094: LD_ADDR_OWVAR 42
101098: PUSH
101099: LD_INT 28
101101: ST_TO_ADDR
101102: GO 101143
101104: LD_INT 33
101106: DOUBLE
101107: EQUAL
101108: IFTRUE 101112
101110: GO 101123
101112: POP
// bc_type := b_oil_mine ; 34 :
101113: LD_ADDR_OWVAR 42
101117: PUSH
101118: LD_INT 29
101120: ST_TO_ADDR
101121: GO 101143
101123: LD_INT 34
101125: DOUBLE
101126: EQUAL
101127: IFTRUE 101131
101129: GO 101142
101131: POP
// bc_type := b_siberite_mine ; end ;
101132: LD_ADDR_OWVAR 42
101136: PUSH
101137: LD_INT 30
101139: ST_TO_ADDR
101140: GO 101143
101142: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101143: LD_ADDR_VAR 0 8
101147: PUSH
101148: LD_VAR 0 5
101152: PPUSH
101153: LD_VAR 0 6
101157: PPUSH
101158: LD_VAR 0 3
101162: PPUSH
101163: CALL_OW 47
101167: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101168: LD_OWVAR 42
101172: PUSH
101173: LD_INT 32
101175: PUSH
101176: LD_INT 33
101178: PUSH
101179: EMPTY
101180: LIST
101181: LIST
101182: IN
101183: IFFALSE 101199
// PlaceWeaponTurret ( b , weapon ) ;
101185: LD_VAR 0 8
101189: PPUSH
101190: LD_VAR 0 4
101194: PPUSH
101195: CALL_OW 431
// end ;
101199: LD_VAR 0 7
101203: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101204: LD_INT 0
101206: PPUSH
101207: PPUSH
101208: PPUSH
101209: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101210: LD_ADDR_VAR 0 4
101214: PUSH
101215: LD_INT 22
101217: PUSH
101218: LD_OWVAR 2
101222: PUSH
101223: EMPTY
101224: LIST
101225: LIST
101226: PUSH
101227: LD_INT 2
101229: PUSH
101230: LD_INT 30
101232: PUSH
101233: LD_INT 0
101235: PUSH
101236: EMPTY
101237: LIST
101238: LIST
101239: PUSH
101240: LD_INT 30
101242: PUSH
101243: LD_INT 1
101245: PUSH
101246: EMPTY
101247: LIST
101248: LIST
101249: PUSH
101250: EMPTY
101251: LIST
101252: LIST
101253: LIST
101254: PUSH
101255: EMPTY
101256: LIST
101257: LIST
101258: PPUSH
101259: CALL_OW 69
101263: ST_TO_ADDR
// if not tmp then
101264: LD_VAR 0 4
101268: NOT
101269: IFFALSE 101273
// exit ;
101271: GO 101332
// for i in tmp do
101273: LD_ADDR_VAR 0 2
101277: PUSH
101278: LD_VAR 0 4
101282: PUSH
101283: FOR_IN
101284: IFFALSE 101330
// for j = 1 to 3 do
101286: LD_ADDR_VAR 0 3
101290: PUSH
101291: DOUBLE
101292: LD_INT 1
101294: DEC
101295: ST_TO_ADDR
101296: LD_INT 3
101298: PUSH
101299: FOR_TO
101300: IFFALSE 101326
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101302: LD_VAR 0 2
101306: PPUSH
101307: CALL_OW 274
101311: PPUSH
101312: LD_VAR 0 3
101316: PPUSH
101317: LD_INT 99999
101319: PPUSH
101320: CALL_OW 277
101324: GO 101299
101326: POP
101327: POP
101328: GO 101283
101330: POP
101331: POP
// end ;
101332: LD_VAR 0 1
101336: RET
// export function hHackSetLevel10 ; var i , j ; begin
101337: LD_INT 0
101339: PPUSH
101340: PPUSH
101341: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101342: LD_ADDR_VAR 0 2
101346: PUSH
101347: LD_INT 21
101349: PUSH
101350: LD_INT 1
101352: PUSH
101353: EMPTY
101354: LIST
101355: LIST
101356: PPUSH
101357: CALL_OW 69
101361: PUSH
101362: FOR_IN
101363: IFFALSE 101415
// if IsSelected ( i ) then
101365: LD_VAR 0 2
101369: PPUSH
101370: CALL_OW 306
101374: IFFALSE 101413
// begin for j := 1 to 4 do
101376: LD_ADDR_VAR 0 3
101380: PUSH
101381: DOUBLE
101382: LD_INT 1
101384: DEC
101385: ST_TO_ADDR
101386: LD_INT 4
101388: PUSH
101389: FOR_TO
101390: IFFALSE 101411
// SetSkill ( i , j , 10 ) ;
101392: LD_VAR 0 2
101396: PPUSH
101397: LD_VAR 0 3
101401: PPUSH
101402: LD_INT 10
101404: PPUSH
101405: CALL_OW 237
101409: GO 101389
101411: POP
101412: POP
// end ;
101413: GO 101362
101415: POP
101416: POP
// end ;
101417: LD_VAR 0 1
101421: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101422: LD_INT 0
101424: PPUSH
101425: PPUSH
101426: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101427: LD_ADDR_VAR 0 2
101431: PUSH
101432: LD_INT 22
101434: PUSH
101435: LD_OWVAR 2
101439: PUSH
101440: EMPTY
101441: LIST
101442: LIST
101443: PUSH
101444: LD_INT 21
101446: PUSH
101447: LD_INT 1
101449: PUSH
101450: EMPTY
101451: LIST
101452: LIST
101453: PUSH
101454: EMPTY
101455: LIST
101456: LIST
101457: PPUSH
101458: CALL_OW 69
101462: PUSH
101463: FOR_IN
101464: IFFALSE 101505
// begin for j := 1 to 4 do
101466: LD_ADDR_VAR 0 3
101470: PUSH
101471: DOUBLE
101472: LD_INT 1
101474: DEC
101475: ST_TO_ADDR
101476: LD_INT 4
101478: PUSH
101479: FOR_TO
101480: IFFALSE 101501
// SetSkill ( i , j , 10 ) ;
101482: LD_VAR 0 2
101486: PPUSH
101487: LD_VAR 0 3
101491: PPUSH
101492: LD_INT 10
101494: PPUSH
101495: CALL_OW 237
101499: GO 101479
101501: POP
101502: POP
// end ;
101503: GO 101463
101505: POP
101506: POP
// end ;
101507: LD_VAR 0 1
101511: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101512: LD_INT 0
101514: PPUSH
// uc_side := your_side ;
101515: LD_ADDR_OWVAR 20
101519: PUSH
101520: LD_OWVAR 2
101524: ST_TO_ADDR
// uc_nation := nation ;
101525: LD_ADDR_OWVAR 21
101529: PUSH
101530: LD_VAR 0 1
101534: ST_TO_ADDR
// InitHc ;
101535: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101539: LD_INT 0
101541: PPUSH
101542: LD_VAR 0 2
101546: PPUSH
101547: LD_VAR 0 3
101551: PPUSH
101552: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101556: LD_VAR 0 4
101560: PPUSH
101561: LD_VAR 0 5
101565: PPUSH
101566: CALL_OW 428
101570: PUSH
101571: LD_INT 0
101573: EQUAL
101574: IFFALSE 101598
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101576: CALL_OW 44
101580: PPUSH
101581: LD_VAR 0 4
101585: PPUSH
101586: LD_VAR 0 5
101590: PPUSH
101591: LD_INT 1
101593: PPUSH
101594: CALL_OW 48
// end ;
101598: LD_VAR 0 6
101602: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101603: LD_INT 0
101605: PPUSH
101606: PPUSH
// uc_side := your_side ;
101607: LD_ADDR_OWVAR 20
101611: PUSH
101612: LD_OWVAR 2
101616: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101617: LD_VAR 0 1
101621: PUSH
101622: LD_INT 1
101624: PUSH
101625: LD_INT 2
101627: PUSH
101628: LD_INT 3
101630: PUSH
101631: LD_INT 4
101633: PUSH
101634: LD_INT 5
101636: PUSH
101637: EMPTY
101638: LIST
101639: LIST
101640: LIST
101641: LIST
101642: LIST
101643: IN
101644: IFFALSE 101656
// uc_nation := nation_american else
101646: LD_ADDR_OWVAR 21
101650: PUSH
101651: LD_INT 1
101653: ST_TO_ADDR
101654: GO 101699
// if chassis in [ 11 , 12 , 13 , 14 ] then
101656: LD_VAR 0 1
101660: PUSH
101661: LD_INT 11
101663: PUSH
101664: LD_INT 12
101666: PUSH
101667: LD_INT 13
101669: PUSH
101670: LD_INT 14
101672: PUSH
101673: EMPTY
101674: LIST
101675: LIST
101676: LIST
101677: LIST
101678: IN
101679: IFFALSE 101691
// uc_nation := nation_arabian else
101681: LD_ADDR_OWVAR 21
101685: PUSH
101686: LD_INT 2
101688: ST_TO_ADDR
101689: GO 101699
// uc_nation := nation_russian ;
101691: LD_ADDR_OWVAR 21
101695: PUSH
101696: LD_INT 3
101698: ST_TO_ADDR
// vc_chassis := chassis ;
101699: LD_ADDR_OWVAR 37
101703: PUSH
101704: LD_VAR 0 1
101708: ST_TO_ADDR
// vc_engine := engine ;
101709: LD_ADDR_OWVAR 39
101713: PUSH
101714: LD_VAR 0 2
101718: ST_TO_ADDR
// vc_control := control ;
101719: LD_ADDR_OWVAR 38
101723: PUSH
101724: LD_VAR 0 3
101728: ST_TO_ADDR
// vc_weapon := weapon ;
101729: LD_ADDR_OWVAR 40
101733: PUSH
101734: LD_VAR 0 4
101738: ST_TO_ADDR
// un := CreateVehicle ;
101739: LD_ADDR_VAR 0 8
101743: PUSH
101744: CALL_OW 45
101748: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101749: LD_VAR 0 8
101753: PPUSH
101754: LD_INT 0
101756: PPUSH
101757: LD_INT 5
101759: PPUSH
101760: CALL_OW 12
101764: PPUSH
101765: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101769: LD_VAR 0 8
101773: PPUSH
101774: LD_VAR 0 5
101778: PPUSH
101779: LD_VAR 0 6
101783: PPUSH
101784: LD_INT 1
101786: PPUSH
101787: CALL_OW 48
// end ;
101791: LD_VAR 0 7
101795: RET
// export hInvincible ; every 1 do
101796: GO 101798
101798: DISABLE
// hInvincible := [ ] ;
101799: LD_ADDR_EXP 164
101803: PUSH
101804: EMPTY
101805: ST_TO_ADDR
101806: END
// every 10 do var i ;
101807: GO 101809
101809: DISABLE
101810: LD_INT 0
101812: PPUSH
// begin enable ;
101813: ENABLE
// if not hInvincible then
101814: LD_EXP 164
101818: NOT
101819: IFFALSE 101823
// exit ;
101821: GO 101867
// for i in hInvincible do
101823: LD_ADDR_VAR 0 1
101827: PUSH
101828: LD_EXP 164
101832: PUSH
101833: FOR_IN
101834: IFFALSE 101865
// if GetLives ( i ) < 1000 then
101836: LD_VAR 0 1
101840: PPUSH
101841: CALL_OW 256
101845: PUSH
101846: LD_INT 1000
101848: LESS
101849: IFFALSE 101863
// SetLives ( i , 1000 ) ;
101851: LD_VAR 0 1
101855: PPUSH
101856: LD_INT 1000
101858: PPUSH
101859: CALL_OW 234
101863: GO 101833
101865: POP
101866: POP
// end ;
101867: PPOPN 1
101869: END
// export function hHackInvincible ; var i ; begin
101870: LD_INT 0
101872: PPUSH
101873: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101874: LD_ADDR_VAR 0 2
101878: PUSH
101879: LD_INT 2
101881: PUSH
101882: LD_INT 21
101884: PUSH
101885: LD_INT 1
101887: PUSH
101888: EMPTY
101889: LIST
101890: LIST
101891: PUSH
101892: LD_INT 21
101894: PUSH
101895: LD_INT 2
101897: PUSH
101898: EMPTY
101899: LIST
101900: LIST
101901: PUSH
101902: EMPTY
101903: LIST
101904: LIST
101905: LIST
101906: PPUSH
101907: CALL_OW 69
101911: PUSH
101912: FOR_IN
101913: IFFALSE 101974
// if IsSelected ( i ) then
101915: LD_VAR 0 2
101919: PPUSH
101920: CALL_OW 306
101924: IFFALSE 101972
// begin if i in hInvincible then
101926: LD_VAR 0 2
101930: PUSH
101931: LD_EXP 164
101935: IN
101936: IFFALSE 101956
// hInvincible := hInvincible diff i else
101938: LD_ADDR_EXP 164
101942: PUSH
101943: LD_EXP 164
101947: PUSH
101948: LD_VAR 0 2
101952: DIFF
101953: ST_TO_ADDR
101954: GO 101972
// hInvincible := hInvincible union i ;
101956: LD_ADDR_EXP 164
101960: PUSH
101961: LD_EXP 164
101965: PUSH
101966: LD_VAR 0 2
101970: UNION
101971: ST_TO_ADDR
// end ;
101972: GO 101912
101974: POP
101975: POP
// end ;
101976: LD_VAR 0 1
101980: RET
// export function hHackInvisible ; var i , j ; begin
101981: LD_INT 0
101983: PPUSH
101984: PPUSH
101985: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101986: LD_ADDR_VAR 0 2
101990: PUSH
101991: LD_INT 21
101993: PUSH
101994: LD_INT 1
101996: PUSH
101997: EMPTY
101998: LIST
101999: LIST
102000: PPUSH
102001: CALL_OW 69
102005: PUSH
102006: FOR_IN
102007: IFFALSE 102031
// if IsSelected ( i ) then
102009: LD_VAR 0 2
102013: PPUSH
102014: CALL_OW 306
102018: IFFALSE 102029
// ComForceInvisible ( i ) ;
102020: LD_VAR 0 2
102024: PPUSH
102025: CALL_OW 496
102029: GO 102006
102031: POP
102032: POP
// end ;
102033: LD_VAR 0 1
102037: RET
// export function hHackChangeYourSide ; begin
102038: LD_INT 0
102040: PPUSH
// if your_side = 8 then
102041: LD_OWVAR 2
102045: PUSH
102046: LD_INT 8
102048: EQUAL
102049: IFFALSE 102061
// your_side := 0 else
102051: LD_ADDR_OWVAR 2
102055: PUSH
102056: LD_INT 0
102058: ST_TO_ADDR
102059: GO 102075
// your_side := your_side + 1 ;
102061: LD_ADDR_OWVAR 2
102065: PUSH
102066: LD_OWVAR 2
102070: PUSH
102071: LD_INT 1
102073: PLUS
102074: ST_TO_ADDR
// end ;
102075: LD_VAR 0 1
102079: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102080: LD_INT 0
102082: PPUSH
102083: PPUSH
102084: PPUSH
// for i in all_units do
102085: LD_ADDR_VAR 0 2
102089: PUSH
102090: LD_OWVAR 3
102094: PUSH
102095: FOR_IN
102096: IFFALSE 102174
// if IsSelected ( i ) then
102098: LD_VAR 0 2
102102: PPUSH
102103: CALL_OW 306
102107: IFFALSE 102172
// begin j := GetSide ( i ) ;
102109: LD_ADDR_VAR 0 3
102113: PUSH
102114: LD_VAR 0 2
102118: PPUSH
102119: CALL_OW 255
102123: ST_TO_ADDR
// if j = 8 then
102124: LD_VAR 0 3
102128: PUSH
102129: LD_INT 8
102131: EQUAL
102132: IFFALSE 102144
// j := 0 else
102134: LD_ADDR_VAR 0 3
102138: PUSH
102139: LD_INT 0
102141: ST_TO_ADDR
102142: GO 102158
// j := j + 1 ;
102144: LD_ADDR_VAR 0 3
102148: PUSH
102149: LD_VAR 0 3
102153: PUSH
102154: LD_INT 1
102156: PLUS
102157: ST_TO_ADDR
// SetSide ( i , j ) ;
102158: LD_VAR 0 2
102162: PPUSH
102163: LD_VAR 0 3
102167: PPUSH
102168: CALL_OW 235
// end ;
102172: GO 102095
102174: POP
102175: POP
// end ;
102176: LD_VAR 0 1
102180: RET
// export function hHackFog ; begin
102181: LD_INT 0
102183: PPUSH
// FogOff ( true ) ;
102184: LD_INT 1
102186: PPUSH
102187: CALL_OW 344
// end ;
102191: LD_VAR 0 1
102195: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102196: LD_INT 0
102198: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102199: LD_VAR 0 1
102203: PPUSH
102204: LD_VAR 0 2
102208: PPUSH
102209: LD_VAR 0 3
102213: PPUSH
102214: LD_INT 1
102216: PPUSH
102217: LD_INT 1
102219: PPUSH
102220: CALL_OW 483
// CenterOnXY ( x , y ) ;
102224: LD_VAR 0 2
102228: PPUSH
102229: LD_VAR 0 3
102233: PPUSH
102234: CALL_OW 84
// end ;
102238: LD_VAR 0 4
102242: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
102243: LD_INT 0
102245: PPUSH
102246: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
102247: LD_VAR 0 1
102251: NOT
102252: PUSH
102253: LD_VAR 0 2
102257: PPUSH
102258: LD_VAR 0 3
102262: PPUSH
102263: CALL_OW 488
102267: NOT
102268: OR
102269: PUSH
102270: LD_VAR 0 1
102274: PPUSH
102275: CALL_OW 266
102279: PUSH
102280: LD_INT 3
102282: NONEQUAL
102283: PUSH
102284: LD_VAR 0 1
102288: PPUSH
102289: CALL_OW 247
102293: PUSH
102294: LD_INT 1
102296: EQUAL
102297: NOT
102298: AND
102299: OR
102300: IFFALSE 102304
// exit ;
102302: GO 102453
// if GetType ( factory ) = unit_human then
102304: LD_VAR 0 1
102308: PPUSH
102309: CALL_OW 247
102313: PUSH
102314: LD_INT 1
102316: EQUAL
102317: IFFALSE 102334
// factory := IsInUnit ( factory ) ;
102319: LD_ADDR_VAR 0 1
102323: PUSH
102324: LD_VAR 0 1
102328: PPUSH
102329: CALL_OW 310
102333: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
102334: LD_VAR 0 1
102338: PPUSH
102339: CALL_OW 266
102343: PUSH
102344: LD_INT 3
102346: NONEQUAL
102347: IFFALSE 102351
// exit ;
102349: GO 102453
// if HexInfo ( x , y ) = factory then
102351: LD_VAR 0 2
102355: PPUSH
102356: LD_VAR 0 3
102360: PPUSH
102361: CALL_OW 428
102365: PUSH
102366: LD_VAR 0 1
102370: EQUAL
102371: IFFALSE 102398
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
102373: LD_ADDR_EXP 165
102377: PUSH
102378: LD_EXP 165
102382: PPUSH
102383: LD_VAR 0 1
102387: PPUSH
102388: LD_INT 0
102390: PPUSH
102391: CALL_OW 1
102395: ST_TO_ADDR
102396: GO 102449
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
102398: LD_ADDR_EXP 165
102402: PUSH
102403: LD_EXP 165
102407: PPUSH
102408: LD_VAR 0 1
102412: PPUSH
102413: LD_VAR 0 1
102417: PPUSH
102418: CALL_OW 255
102422: PUSH
102423: LD_VAR 0 1
102427: PUSH
102428: LD_VAR 0 2
102432: PUSH
102433: LD_VAR 0 3
102437: PUSH
102438: EMPTY
102439: LIST
102440: LIST
102441: LIST
102442: LIST
102443: PPUSH
102444: CALL_OW 1
102448: ST_TO_ADDR
// UpdateFactoryWaypoints ;
102449: CALL 102458 0 0
// end ;
102453: LD_VAR 0 4
102457: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
102458: LD_INT 0
102460: PPUSH
102461: PPUSH
102462: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
102463: LD_STRING resetFactoryWaypoint();
102465: PPUSH
102466: CALL_OW 559
// if factoryWaypoints then
102470: LD_EXP 165
102474: IFFALSE 102600
// begin list := PrepareArray ( factoryWaypoints ) ;
102476: LD_ADDR_VAR 0 3
102480: PUSH
102481: LD_EXP 165
102485: PPUSH
102486: CALL 56580 0 1
102490: ST_TO_ADDR
// for i := 1 to list do
102491: LD_ADDR_VAR 0 2
102495: PUSH
102496: DOUBLE
102497: LD_INT 1
102499: DEC
102500: ST_TO_ADDR
102501: LD_VAR 0 3
102505: PUSH
102506: FOR_TO
102507: IFFALSE 102598
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102509: LD_STRING setFactoryWaypointXY(
102511: PUSH
102512: LD_VAR 0 3
102516: PUSH
102517: LD_VAR 0 2
102521: ARRAY
102522: PUSH
102523: LD_INT 1
102525: ARRAY
102526: STR
102527: PUSH
102528: LD_STRING ,
102530: STR
102531: PUSH
102532: LD_VAR 0 3
102536: PUSH
102537: LD_VAR 0 2
102541: ARRAY
102542: PUSH
102543: LD_INT 2
102545: ARRAY
102546: STR
102547: PUSH
102548: LD_STRING ,
102550: STR
102551: PUSH
102552: LD_VAR 0 3
102556: PUSH
102557: LD_VAR 0 2
102561: ARRAY
102562: PUSH
102563: LD_INT 3
102565: ARRAY
102566: STR
102567: PUSH
102568: LD_STRING ,
102570: STR
102571: PUSH
102572: LD_VAR 0 3
102576: PUSH
102577: LD_VAR 0 2
102581: ARRAY
102582: PUSH
102583: LD_INT 4
102585: ARRAY
102586: STR
102587: PUSH
102588: LD_STRING )
102590: STR
102591: PPUSH
102592: CALL_OW 559
102596: GO 102506
102598: POP
102599: POP
// end ; end ;
102600: LD_VAR 0 1
102604: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
102605: LD_INT 0
102607: PPUSH
// if HexInfo ( x , y ) = warehouse then
102608: LD_VAR 0 2
102612: PPUSH
102613: LD_VAR 0 3
102617: PPUSH
102618: CALL_OW 428
102622: PUSH
102623: LD_VAR 0 1
102627: EQUAL
102628: IFFALSE 102655
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
102630: LD_ADDR_EXP 166
102634: PUSH
102635: LD_EXP 166
102639: PPUSH
102640: LD_VAR 0 1
102644: PPUSH
102645: LD_INT 0
102647: PPUSH
102648: CALL_OW 1
102652: ST_TO_ADDR
102653: GO 102706
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
102655: LD_ADDR_EXP 166
102659: PUSH
102660: LD_EXP 166
102664: PPUSH
102665: LD_VAR 0 1
102669: PPUSH
102670: LD_VAR 0 1
102674: PPUSH
102675: CALL_OW 255
102679: PUSH
102680: LD_VAR 0 1
102684: PUSH
102685: LD_VAR 0 2
102689: PUSH
102690: LD_VAR 0 3
102694: PUSH
102695: EMPTY
102696: LIST
102697: LIST
102698: LIST
102699: LIST
102700: PPUSH
102701: CALL_OW 1
102705: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
102706: CALL 102715 0 0
// end ;
102710: LD_VAR 0 4
102714: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
102715: LD_INT 0
102717: PPUSH
102718: PPUSH
102719: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
102720: LD_STRING resetWarehouseGatheringPoints();
102722: PPUSH
102723: CALL_OW 559
// if warehouseGatheringPoints then
102727: LD_EXP 166
102731: IFFALSE 102857
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
102733: LD_ADDR_VAR 0 3
102737: PUSH
102738: LD_EXP 166
102742: PPUSH
102743: CALL 56580 0 1
102747: ST_TO_ADDR
// for i := 1 to list do
102748: LD_ADDR_VAR 0 2
102752: PUSH
102753: DOUBLE
102754: LD_INT 1
102756: DEC
102757: ST_TO_ADDR
102758: LD_VAR 0 3
102762: PUSH
102763: FOR_TO
102764: IFFALSE 102855
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102766: LD_STRING setWarehouseGatheringPointXY(
102768: PUSH
102769: LD_VAR 0 3
102773: PUSH
102774: LD_VAR 0 2
102778: ARRAY
102779: PUSH
102780: LD_INT 1
102782: ARRAY
102783: STR
102784: PUSH
102785: LD_STRING ,
102787: STR
102788: PUSH
102789: LD_VAR 0 3
102793: PUSH
102794: LD_VAR 0 2
102798: ARRAY
102799: PUSH
102800: LD_INT 2
102802: ARRAY
102803: STR
102804: PUSH
102805: LD_STRING ,
102807: STR
102808: PUSH
102809: LD_VAR 0 3
102813: PUSH
102814: LD_VAR 0 2
102818: ARRAY
102819: PUSH
102820: LD_INT 3
102822: ARRAY
102823: STR
102824: PUSH
102825: LD_STRING ,
102827: STR
102828: PUSH
102829: LD_VAR 0 3
102833: PUSH
102834: LD_VAR 0 2
102838: ARRAY
102839: PUSH
102840: LD_INT 4
102842: ARRAY
102843: STR
102844: PUSH
102845: LD_STRING )
102847: STR
102848: PPUSH
102849: CALL_OW 559
102853: GO 102763
102855: POP
102856: POP
// end ; end ;
102857: LD_VAR 0 1
102861: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
102862: LD_EXP 166
102866: IFFALSE 103551
102868: GO 102870
102870: DISABLE
102871: LD_INT 0
102873: PPUSH
102874: PPUSH
102875: PPUSH
102876: PPUSH
102877: PPUSH
102878: PPUSH
102879: PPUSH
102880: PPUSH
102881: PPUSH
// begin enable ;
102882: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
102883: LD_ADDR_VAR 0 3
102887: PUSH
102888: LD_EXP 166
102892: PPUSH
102893: CALL 56580 0 1
102897: ST_TO_ADDR
// if not list then
102898: LD_VAR 0 3
102902: NOT
102903: IFFALSE 102907
// exit ;
102905: GO 103551
// for i := 1 to list do
102907: LD_ADDR_VAR 0 1
102911: PUSH
102912: DOUBLE
102913: LD_INT 1
102915: DEC
102916: ST_TO_ADDR
102917: LD_VAR 0 3
102921: PUSH
102922: FOR_TO
102923: IFFALSE 103549
// begin depot := list [ i ] [ 2 ] ;
102925: LD_ADDR_VAR 0 8
102929: PUSH
102930: LD_VAR 0 3
102934: PUSH
102935: LD_VAR 0 1
102939: ARRAY
102940: PUSH
102941: LD_INT 2
102943: ARRAY
102944: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102945: LD_ADDR_VAR 0 5
102949: PUSH
102950: LD_VAR 0 3
102954: PUSH
102955: LD_VAR 0 1
102959: ARRAY
102960: PUSH
102961: LD_INT 1
102963: ARRAY
102964: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102965: LD_VAR 0 8
102969: PPUSH
102970: CALL_OW 301
102974: PUSH
102975: LD_VAR 0 5
102979: PUSH
102980: LD_VAR 0 8
102984: PPUSH
102985: CALL_OW 255
102989: NONEQUAL
102990: OR
102991: IFFALSE 103020
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102993: LD_ADDR_EXP 166
102997: PUSH
102998: LD_EXP 166
103002: PPUSH
103003: LD_VAR 0 8
103007: PPUSH
103008: LD_INT 0
103010: PPUSH
103011: CALL_OW 1
103015: ST_TO_ADDR
// exit ;
103016: POP
103017: POP
103018: GO 103551
// end ; x := list [ i ] [ 3 ] ;
103020: LD_ADDR_VAR 0 6
103024: PUSH
103025: LD_VAR 0 3
103029: PUSH
103030: LD_VAR 0 1
103034: ARRAY
103035: PUSH
103036: LD_INT 3
103038: ARRAY
103039: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
103040: LD_ADDR_VAR 0 7
103044: PUSH
103045: LD_VAR 0 3
103049: PUSH
103050: LD_VAR 0 1
103054: ARRAY
103055: PUSH
103056: LD_INT 4
103058: ARRAY
103059: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
103060: LD_ADDR_VAR 0 9
103064: PUSH
103065: LD_VAR 0 6
103069: PPUSH
103070: LD_VAR 0 7
103074: PPUSH
103075: LD_INT 16
103077: PPUSH
103078: CALL 55168 0 3
103082: ST_TO_ADDR
// if not cratesNearbyPoint then
103083: LD_VAR 0 9
103087: NOT
103088: IFFALSE 103094
// exit ;
103090: POP
103091: POP
103092: GO 103551
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
103094: LD_ADDR_VAR 0 4
103098: PUSH
103099: LD_INT 22
103101: PUSH
103102: LD_VAR 0 5
103106: PUSH
103107: EMPTY
103108: LIST
103109: LIST
103110: PUSH
103111: LD_INT 3
103113: PUSH
103114: LD_INT 60
103116: PUSH
103117: EMPTY
103118: LIST
103119: PUSH
103120: EMPTY
103121: LIST
103122: LIST
103123: PUSH
103124: LD_INT 91
103126: PUSH
103127: LD_VAR 0 8
103131: PUSH
103132: LD_INT 6
103134: PUSH
103135: EMPTY
103136: LIST
103137: LIST
103138: LIST
103139: PUSH
103140: LD_INT 2
103142: PUSH
103143: LD_INT 25
103145: PUSH
103146: LD_INT 2
103148: PUSH
103149: EMPTY
103150: LIST
103151: LIST
103152: PUSH
103153: LD_INT 25
103155: PUSH
103156: LD_INT 16
103158: PUSH
103159: EMPTY
103160: LIST
103161: LIST
103162: PUSH
103163: EMPTY
103164: LIST
103165: LIST
103166: LIST
103167: PUSH
103168: EMPTY
103169: LIST
103170: LIST
103171: LIST
103172: LIST
103173: PPUSH
103174: CALL_OW 69
103178: PUSH
103179: LD_VAR 0 8
103183: PPUSH
103184: CALL_OW 313
103188: PPUSH
103189: LD_INT 3
103191: PUSH
103192: LD_INT 60
103194: PUSH
103195: EMPTY
103196: LIST
103197: PUSH
103198: EMPTY
103199: LIST
103200: LIST
103201: PUSH
103202: LD_INT 2
103204: PUSH
103205: LD_INT 25
103207: PUSH
103208: LD_INT 2
103210: PUSH
103211: EMPTY
103212: LIST
103213: LIST
103214: PUSH
103215: LD_INT 25
103217: PUSH
103218: LD_INT 16
103220: PUSH
103221: EMPTY
103222: LIST
103223: LIST
103224: PUSH
103225: EMPTY
103226: LIST
103227: LIST
103228: LIST
103229: PUSH
103230: EMPTY
103231: LIST
103232: LIST
103233: PPUSH
103234: CALL_OW 72
103238: UNION
103239: ST_TO_ADDR
// if tmp then
103240: LD_VAR 0 4
103244: IFFALSE 103324
// begin tmp := ShrinkArray ( tmp , 3 ) ;
103246: LD_ADDR_VAR 0 4
103250: PUSH
103251: LD_VAR 0 4
103255: PPUSH
103256: LD_INT 3
103258: PPUSH
103259: CALL 53137 0 2
103263: ST_TO_ADDR
// for j in tmp do
103264: LD_ADDR_VAR 0 2
103268: PUSH
103269: LD_VAR 0 4
103273: PUSH
103274: FOR_IN
103275: IFFALSE 103318
// begin if IsInUnit ( j ) then
103277: LD_VAR 0 2
103281: PPUSH
103282: CALL_OW 310
103286: IFFALSE 103297
// ComExit ( j ) ;
103288: LD_VAR 0 2
103292: PPUSH
103293: CALL 53220 0 1
// AddComCollect ( j , x , y ) ;
103297: LD_VAR 0 2
103301: PPUSH
103302: LD_VAR 0 6
103306: PPUSH
103307: LD_VAR 0 7
103311: PPUSH
103312: CALL_OW 177
// end ;
103316: GO 103274
103318: POP
103319: POP
// exit ;
103320: POP
103321: POP
103322: GO 103551
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
103324: LD_ADDR_VAR 0 4
103328: PUSH
103329: LD_INT 22
103331: PUSH
103332: LD_VAR 0 5
103336: PUSH
103337: EMPTY
103338: LIST
103339: LIST
103340: PUSH
103341: LD_INT 91
103343: PUSH
103344: LD_VAR 0 8
103348: PUSH
103349: LD_INT 8
103351: PUSH
103352: EMPTY
103353: LIST
103354: LIST
103355: LIST
103356: PUSH
103357: LD_INT 2
103359: PUSH
103360: LD_INT 34
103362: PUSH
103363: LD_INT 12
103365: PUSH
103366: EMPTY
103367: LIST
103368: LIST
103369: PUSH
103370: LD_INT 34
103372: PUSH
103373: LD_INT 51
103375: PUSH
103376: EMPTY
103377: LIST
103378: LIST
103379: PUSH
103380: LD_INT 34
103382: PUSH
103383: LD_INT 32
103385: PUSH
103386: EMPTY
103387: LIST
103388: LIST
103389: PUSH
103390: LD_INT 34
103392: PUSH
103393: LD_INT 89
103395: PUSH
103396: EMPTY
103397: LIST
103398: LIST
103399: PUSH
103400: EMPTY
103401: LIST
103402: LIST
103403: LIST
103404: LIST
103405: LIST
103406: PUSH
103407: EMPTY
103408: LIST
103409: LIST
103410: LIST
103411: PPUSH
103412: CALL_OW 69
103416: ST_TO_ADDR
// if tmp then
103417: LD_VAR 0 4
103421: IFFALSE 103547
// begin for j in tmp do
103423: LD_ADDR_VAR 0 2
103427: PUSH
103428: LD_VAR 0 4
103432: PUSH
103433: FOR_IN
103434: IFFALSE 103545
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
103436: LD_VAR 0 2
103440: PPUSH
103441: CALL_OW 262
103445: PUSH
103446: LD_INT 3
103448: EQUAL
103449: PUSH
103450: LD_VAR 0 2
103454: PPUSH
103455: CALL_OW 261
103459: PUSH
103460: LD_INT 20
103462: GREATER
103463: OR
103464: PUSH
103465: LD_VAR 0 2
103469: PPUSH
103470: CALL_OW 314
103474: NOT
103475: AND
103476: PUSH
103477: LD_VAR 0 2
103481: PPUSH
103482: CALL_OW 263
103486: PUSH
103487: LD_INT 1
103489: NONEQUAL
103490: PUSH
103491: LD_VAR 0 2
103495: PPUSH
103496: CALL_OW 311
103500: OR
103501: AND
103502: IFFALSE 103543
// begin ComCollect ( j , x , y ) ;
103504: LD_VAR 0 2
103508: PPUSH
103509: LD_VAR 0 6
103513: PPUSH
103514: LD_VAR 0 7
103518: PPUSH
103519: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
103523: LD_VAR 0 2
103527: PPUSH
103528: LD_VAR 0 8
103532: PPUSH
103533: CALL_OW 172
// exit ;
103537: POP
103538: POP
103539: POP
103540: POP
103541: GO 103551
// end ;
103543: GO 103433
103545: POP
103546: POP
// end ; end ;
103547: GO 102922
103549: POP
103550: POP
// end ; end_of_file
103551: PPOPN 9
103553: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103554: LD_INT 0
103556: PPUSH
103557: PPUSH
103558: PPUSH
103559: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103560: LD_VAR 0 1
103564: PPUSH
103565: CALL_OW 264
103569: PUSH
103570: LD_INT 91
103572: EQUAL
103573: IFFALSE 103645
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103575: LD_INT 68
103577: PPUSH
103578: LD_VAR 0 1
103582: PPUSH
103583: CALL_OW 255
103587: PPUSH
103588: CALL_OW 321
103592: PUSH
103593: LD_INT 2
103595: EQUAL
103596: IFFALSE 103608
// eff := 70 else
103598: LD_ADDR_VAR 0 4
103602: PUSH
103603: LD_INT 70
103605: ST_TO_ADDR
103606: GO 103616
// eff := 30 ;
103608: LD_ADDR_VAR 0 4
103612: PUSH
103613: LD_INT 30
103615: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103616: LD_VAR 0 1
103620: PPUSH
103621: CALL_OW 250
103625: PPUSH
103626: LD_VAR 0 1
103630: PPUSH
103631: CALL_OW 251
103635: PPUSH
103636: LD_VAR 0 4
103640: PPUSH
103641: CALL_OW 495
// end ; end ;
103645: LD_VAR 0 2
103649: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103650: LD_INT 0
103652: PPUSH
// end ;
103653: LD_VAR 0 4
103657: RET
// export function SOS_Command ( cmd ) ; begin
103658: LD_INT 0
103660: PPUSH
// end ;
103661: LD_VAR 0 2
103665: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103666: LD_INT 0
103668: PPUSH
// end ;
103669: LD_VAR 0 6
103673: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
103674: LD_INT 0
103676: PPUSH
103677: PPUSH
// if not vehicle or not factory then
103678: LD_VAR 0 1
103682: NOT
103683: PUSH
103684: LD_VAR 0 2
103688: NOT
103689: OR
103690: IFFALSE 103694
// exit ;
103692: GO 103925
// if factoryWaypoints >= factory then
103694: LD_EXP 165
103698: PUSH
103699: LD_VAR 0 2
103703: GREATEREQUAL
103704: IFFALSE 103925
// if factoryWaypoints [ factory ] then
103706: LD_EXP 165
103710: PUSH
103711: LD_VAR 0 2
103715: ARRAY
103716: IFFALSE 103925
// begin if GetControl ( vehicle ) = control_manual then
103718: LD_VAR 0 1
103722: PPUSH
103723: CALL_OW 263
103727: PUSH
103728: LD_INT 1
103730: EQUAL
103731: IFFALSE 103812
// begin driver := IsDrivenBy ( vehicle ) ;
103733: LD_ADDR_VAR 0 4
103737: PUSH
103738: LD_VAR 0 1
103742: PPUSH
103743: CALL_OW 311
103747: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103748: LD_VAR 0 4
103752: PPUSH
103753: LD_EXP 165
103757: PUSH
103758: LD_VAR 0 2
103762: ARRAY
103763: PUSH
103764: LD_INT 3
103766: ARRAY
103767: PPUSH
103768: LD_EXP 165
103772: PUSH
103773: LD_VAR 0 2
103777: ARRAY
103778: PUSH
103779: LD_INT 4
103781: ARRAY
103782: PPUSH
103783: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103787: LD_VAR 0 4
103791: PPUSH
103792: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103796: LD_VAR 0 4
103800: PPUSH
103801: LD_VAR 0 2
103805: PPUSH
103806: CALL_OW 180
// end else
103810: GO 103925
// if GetControl ( vehicle ) = control_remote then
103812: LD_VAR 0 1
103816: PPUSH
103817: CALL_OW 263
103821: PUSH
103822: LD_INT 2
103824: EQUAL
103825: IFFALSE 103886
// begin wait ( 0 0$2 ) ;
103827: LD_INT 70
103829: PPUSH
103830: CALL_OW 67
// if Connect ( vehicle ) then
103834: LD_VAR 0 1
103838: PPUSH
103839: CALL 23441 0 1
103843: IFFALSE 103884
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103845: LD_VAR 0 1
103849: PPUSH
103850: LD_EXP 165
103854: PUSH
103855: LD_VAR 0 2
103859: ARRAY
103860: PUSH
103861: LD_INT 3
103863: ARRAY
103864: PPUSH
103865: LD_EXP 165
103869: PUSH
103870: LD_VAR 0 2
103874: ARRAY
103875: PUSH
103876: LD_INT 4
103878: ARRAY
103879: PPUSH
103880: CALL_OW 171
// end else
103884: GO 103925
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103886: LD_VAR 0 1
103890: PPUSH
103891: LD_EXP 165
103895: PUSH
103896: LD_VAR 0 2
103900: ARRAY
103901: PUSH
103902: LD_INT 3
103904: ARRAY
103905: PPUSH
103906: LD_EXP 165
103910: PUSH
103911: LD_VAR 0 2
103915: ARRAY
103916: PUSH
103917: LD_INT 4
103919: ARRAY
103920: PPUSH
103921: CALL_OW 171
// end ; end ;
103925: LD_VAR 0 3
103929: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103930: LD_INT 0
103932: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103933: LD_VAR 0 1
103937: PUSH
103938: LD_INT 250
103940: EQUAL
103941: PUSH
103942: LD_VAR 0 2
103946: PPUSH
103947: CALL_OW 264
103951: PUSH
103952: LD_INT 81
103954: EQUAL
103955: AND
103956: IFFALSE 103977
// MinerPlaceMine ( unit , x , y ) ;
103958: LD_VAR 0 2
103962: PPUSH
103963: LD_VAR 0 4
103967: PPUSH
103968: LD_VAR 0 5
103972: PPUSH
103973: CALL 106362 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103977: LD_VAR 0 1
103981: PUSH
103982: LD_INT 251
103984: EQUAL
103985: PUSH
103986: LD_VAR 0 2
103990: PPUSH
103991: CALL_OW 264
103995: PUSH
103996: LD_INT 81
103998: EQUAL
103999: AND
104000: IFFALSE 104021
// MinerDetonateMine ( unit , x , y ) ;
104002: LD_VAR 0 2
104006: PPUSH
104007: LD_VAR 0 4
104011: PPUSH
104012: LD_VAR 0 5
104016: PPUSH
104017: CALL 106637 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
104021: LD_VAR 0 1
104025: PUSH
104026: LD_INT 252
104028: EQUAL
104029: PUSH
104030: LD_VAR 0 2
104034: PPUSH
104035: CALL_OW 264
104039: PUSH
104040: LD_INT 81
104042: EQUAL
104043: AND
104044: IFFALSE 104065
// MinerCreateMinefield ( unit , x , y ) ;
104046: LD_VAR 0 2
104050: PPUSH
104051: LD_VAR 0 4
104055: PPUSH
104056: LD_VAR 0 5
104060: PPUSH
104061: CALL 107054 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
104065: LD_VAR 0 1
104069: PUSH
104070: LD_INT 253
104072: EQUAL
104073: PUSH
104074: LD_VAR 0 2
104078: PPUSH
104079: CALL_OW 257
104083: PUSH
104084: LD_INT 5
104086: EQUAL
104087: AND
104088: IFFALSE 104109
// ComBinocular ( unit , x , y ) ;
104090: LD_VAR 0 2
104094: PPUSH
104095: LD_VAR 0 4
104099: PPUSH
104100: LD_VAR 0 5
104104: PPUSH
104105: CALL 107423 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
104109: LD_VAR 0 1
104113: PUSH
104114: LD_INT 254
104116: EQUAL
104117: PUSH
104118: LD_VAR 0 2
104122: PPUSH
104123: CALL_OW 264
104127: PUSH
104128: LD_INT 99
104130: EQUAL
104131: AND
104132: PUSH
104133: LD_VAR 0 3
104137: PPUSH
104138: CALL_OW 263
104142: PUSH
104143: LD_INT 3
104145: EQUAL
104146: AND
104147: IFFALSE 104163
// HackDestroyVehicle ( unit , selectedUnit ) ;
104149: LD_VAR 0 2
104153: PPUSH
104154: LD_VAR 0 3
104158: PPUSH
104159: CALL 105726 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104163: LD_VAR 0 1
104167: PUSH
104168: LD_INT 255
104170: EQUAL
104171: PUSH
104172: LD_VAR 0 2
104176: PPUSH
104177: CALL_OW 264
104181: PUSH
104182: LD_INT 14
104184: PUSH
104185: LD_INT 53
104187: PUSH
104188: EMPTY
104189: LIST
104190: LIST
104191: IN
104192: AND
104193: PUSH
104194: LD_VAR 0 4
104198: PPUSH
104199: LD_VAR 0 5
104203: PPUSH
104204: CALL_OW 488
104208: AND
104209: IFFALSE 104233
// CutTreeXYR ( unit , x , y , 12 ) ;
104211: LD_VAR 0 2
104215: PPUSH
104216: LD_VAR 0 4
104220: PPUSH
104221: LD_VAR 0 5
104225: PPUSH
104226: LD_INT 12
104228: PPUSH
104229: CALL 104296 0 4
// if cmd = 256 then
104233: LD_VAR 0 1
104237: PUSH
104238: LD_INT 256
104240: EQUAL
104241: IFFALSE 104262
// SetFactoryWaypoint ( unit , x , y ) ;
104243: LD_VAR 0 2
104247: PPUSH
104248: LD_VAR 0 4
104252: PPUSH
104253: LD_VAR 0 5
104257: PPUSH
104258: CALL 102243 0 3
// if cmd = 257 then
104262: LD_VAR 0 1
104266: PUSH
104267: LD_INT 257
104269: EQUAL
104270: IFFALSE 104291
// SetWarehouseGatheringPoint ( unit , x , y ) ;
104272: LD_VAR 0 2
104276: PPUSH
104277: LD_VAR 0 4
104281: PPUSH
104282: LD_VAR 0 5
104286: PPUSH
104287: CALL 102605 0 3
// end ;
104291: LD_VAR 0 6
104295: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104296: LD_INT 0
104298: PPUSH
104299: PPUSH
104300: PPUSH
104301: PPUSH
104302: PPUSH
104303: PPUSH
104304: PPUSH
104305: PPUSH
104306: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104307: LD_VAR 0 1
104311: NOT
104312: PUSH
104313: LD_VAR 0 2
104317: PPUSH
104318: LD_VAR 0 3
104322: PPUSH
104323: CALL_OW 488
104327: NOT
104328: OR
104329: PUSH
104330: LD_VAR 0 4
104334: NOT
104335: OR
104336: IFFALSE 104340
// exit ;
104338: GO 104680
// list := [ ] ;
104340: LD_ADDR_VAR 0 13
104344: PUSH
104345: EMPTY
104346: ST_TO_ADDR
// if x - r < 0 then
104347: LD_VAR 0 2
104351: PUSH
104352: LD_VAR 0 4
104356: MINUS
104357: PUSH
104358: LD_INT 0
104360: LESS
104361: IFFALSE 104373
// min_x := 0 else
104363: LD_ADDR_VAR 0 7
104367: PUSH
104368: LD_INT 0
104370: ST_TO_ADDR
104371: GO 104389
// min_x := x - r ;
104373: LD_ADDR_VAR 0 7
104377: PUSH
104378: LD_VAR 0 2
104382: PUSH
104383: LD_VAR 0 4
104387: MINUS
104388: ST_TO_ADDR
// if y - r < 0 then
104389: LD_VAR 0 3
104393: PUSH
104394: LD_VAR 0 4
104398: MINUS
104399: PUSH
104400: LD_INT 0
104402: LESS
104403: IFFALSE 104415
// min_y := 0 else
104405: LD_ADDR_VAR 0 8
104409: PUSH
104410: LD_INT 0
104412: ST_TO_ADDR
104413: GO 104431
// min_y := y - r ;
104415: LD_ADDR_VAR 0 8
104419: PUSH
104420: LD_VAR 0 3
104424: PUSH
104425: LD_VAR 0 4
104429: MINUS
104430: ST_TO_ADDR
// max_x := x + r ;
104431: LD_ADDR_VAR 0 9
104435: PUSH
104436: LD_VAR 0 2
104440: PUSH
104441: LD_VAR 0 4
104445: PLUS
104446: ST_TO_ADDR
// max_y := y + r ;
104447: LD_ADDR_VAR 0 10
104451: PUSH
104452: LD_VAR 0 3
104456: PUSH
104457: LD_VAR 0 4
104461: PLUS
104462: ST_TO_ADDR
// for _x = min_x to max_x do
104463: LD_ADDR_VAR 0 11
104467: PUSH
104468: DOUBLE
104469: LD_VAR 0 7
104473: DEC
104474: ST_TO_ADDR
104475: LD_VAR 0 9
104479: PUSH
104480: FOR_TO
104481: IFFALSE 104598
// for _y = min_y to max_y do
104483: LD_ADDR_VAR 0 12
104487: PUSH
104488: DOUBLE
104489: LD_VAR 0 8
104493: DEC
104494: ST_TO_ADDR
104495: LD_VAR 0 10
104499: PUSH
104500: FOR_TO
104501: IFFALSE 104594
// begin if not ValidHex ( _x , _y ) then
104503: LD_VAR 0 11
104507: PPUSH
104508: LD_VAR 0 12
104512: PPUSH
104513: CALL_OW 488
104517: NOT
104518: IFFALSE 104522
// continue ;
104520: GO 104500
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104522: LD_VAR 0 11
104526: PPUSH
104527: LD_VAR 0 12
104531: PPUSH
104532: CALL_OW 351
104536: PUSH
104537: LD_VAR 0 11
104541: PPUSH
104542: LD_VAR 0 12
104546: PPUSH
104547: CALL_OW 554
104551: AND
104552: IFFALSE 104592
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104554: LD_ADDR_VAR 0 13
104558: PUSH
104559: LD_VAR 0 13
104563: PPUSH
104564: LD_VAR 0 13
104568: PUSH
104569: LD_INT 1
104571: PLUS
104572: PPUSH
104573: LD_VAR 0 11
104577: PUSH
104578: LD_VAR 0 12
104582: PUSH
104583: EMPTY
104584: LIST
104585: LIST
104586: PPUSH
104587: CALL_OW 2
104591: ST_TO_ADDR
// end ;
104592: GO 104500
104594: POP
104595: POP
104596: GO 104480
104598: POP
104599: POP
// if not list then
104600: LD_VAR 0 13
104604: NOT
104605: IFFALSE 104609
// exit ;
104607: GO 104680
// for i in list do
104609: LD_ADDR_VAR 0 6
104613: PUSH
104614: LD_VAR 0 13
104618: PUSH
104619: FOR_IN
104620: IFFALSE 104678
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104622: LD_VAR 0 1
104626: PPUSH
104627: LD_STRING M
104629: PUSH
104630: LD_VAR 0 6
104634: PUSH
104635: LD_INT 1
104637: ARRAY
104638: PUSH
104639: LD_VAR 0 6
104643: PUSH
104644: LD_INT 2
104646: ARRAY
104647: PUSH
104648: LD_INT 0
104650: PUSH
104651: LD_INT 0
104653: PUSH
104654: LD_INT 0
104656: PUSH
104657: LD_INT 0
104659: PUSH
104660: EMPTY
104661: LIST
104662: LIST
104663: LIST
104664: LIST
104665: LIST
104666: LIST
104667: LIST
104668: PUSH
104669: EMPTY
104670: LIST
104671: PPUSH
104672: CALL_OW 447
104676: GO 104619
104678: POP
104679: POP
// end ;
104680: LD_VAR 0 5
104684: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104685: LD_EXP 168
104689: NOT
104690: IFFALSE 104740
104692: GO 104694
104694: DISABLE
// begin initHack := true ;
104695: LD_ADDR_EXP 168
104699: PUSH
104700: LD_INT 1
104702: ST_TO_ADDR
// hackTanks := [ ] ;
104703: LD_ADDR_EXP 169
104707: PUSH
104708: EMPTY
104709: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104710: LD_ADDR_EXP 170
104714: PUSH
104715: EMPTY
104716: ST_TO_ADDR
// hackLimit := 3 ;
104717: LD_ADDR_EXP 171
104721: PUSH
104722: LD_INT 3
104724: ST_TO_ADDR
// hackDist := 12 ;
104725: LD_ADDR_EXP 172
104729: PUSH
104730: LD_INT 12
104732: ST_TO_ADDR
// hackCounter := [ ] ;
104733: LD_ADDR_EXP 173
104737: PUSH
104738: EMPTY
104739: ST_TO_ADDR
// end ;
104740: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104741: LD_EXP 168
104745: PUSH
104746: LD_INT 34
104748: PUSH
104749: LD_INT 99
104751: PUSH
104752: EMPTY
104753: LIST
104754: LIST
104755: PPUSH
104756: CALL_OW 69
104760: AND
104761: IFFALSE 105014
104763: GO 104765
104765: DISABLE
104766: LD_INT 0
104768: PPUSH
104769: PPUSH
// begin enable ;
104770: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104771: LD_ADDR_VAR 0 1
104775: PUSH
104776: LD_INT 34
104778: PUSH
104779: LD_INT 99
104781: PUSH
104782: EMPTY
104783: LIST
104784: LIST
104785: PPUSH
104786: CALL_OW 69
104790: PUSH
104791: FOR_IN
104792: IFFALSE 105012
// begin if not i in hackTanks then
104794: LD_VAR 0 1
104798: PUSH
104799: LD_EXP 169
104803: IN
104804: NOT
104805: IFFALSE 104888
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104807: LD_ADDR_EXP 169
104811: PUSH
104812: LD_EXP 169
104816: PPUSH
104817: LD_EXP 169
104821: PUSH
104822: LD_INT 1
104824: PLUS
104825: PPUSH
104826: LD_VAR 0 1
104830: PPUSH
104831: CALL_OW 1
104835: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104836: LD_ADDR_EXP 170
104840: PUSH
104841: LD_EXP 170
104845: PPUSH
104846: LD_EXP 170
104850: PUSH
104851: LD_INT 1
104853: PLUS
104854: PPUSH
104855: EMPTY
104856: PPUSH
104857: CALL_OW 1
104861: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104862: LD_ADDR_EXP 173
104866: PUSH
104867: LD_EXP 173
104871: PPUSH
104872: LD_EXP 173
104876: PUSH
104877: LD_INT 1
104879: PLUS
104880: PPUSH
104881: EMPTY
104882: PPUSH
104883: CALL_OW 1
104887: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104888: LD_VAR 0 1
104892: PPUSH
104893: CALL_OW 302
104897: NOT
104898: IFFALSE 104911
// begin HackUnlinkAll ( i ) ;
104900: LD_VAR 0 1
104904: PPUSH
104905: CALL 105017 0 1
// continue ;
104909: GO 104791
// end ; HackCheckCapturedStatus ( i ) ;
104911: LD_VAR 0 1
104915: PPUSH
104916: CALL 105460 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104920: LD_ADDR_VAR 0 2
104924: PUSH
104925: LD_INT 81
104927: PUSH
104928: LD_VAR 0 1
104932: PPUSH
104933: CALL_OW 255
104937: PUSH
104938: EMPTY
104939: LIST
104940: LIST
104941: PUSH
104942: LD_INT 33
104944: PUSH
104945: LD_INT 3
104947: PUSH
104948: EMPTY
104949: LIST
104950: LIST
104951: PUSH
104952: LD_INT 91
104954: PUSH
104955: LD_VAR 0 1
104959: PUSH
104960: LD_EXP 172
104964: PUSH
104965: EMPTY
104966: LIST
104967: LIST
104968: LIST
104969: PUSH
104970: LD_INT 50
104972: PUSH
104973: EMPTY
104974: LIST
104975: PUSH
104976: EMPTY
104977: LIST
104978: LIST
104979: LIST
104980: LIST
104981: PPUSH
104982: CALL_OW 69
104986: ST_TO_ADDR
// if not tmp then
104987: LD_VAR 0 2
104991: NOT
104992: IFFALSE 104996
// continue ;
104994: GO 104791
// HackLink ( i , tmp ) ;
104996: LD_VAR 0 1
105000: PPUSH
105001: LD_VAR 0 2
105005: PPUSH
105006: CALL 105153 0 2
// end ;
105010: GO 104791
105012: POP
105013: POP
// end ;
105014: PPOPN 2
105016: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
105017: LD_INT 0
105019: PPUSH
105020: PPUSH
105021: PPUSH
// if not hack in hackTanks then
105022: LD_VAR 0 1
105026: PUSH
105027: LD_EXP 169
105031: IN
105032: NOT
105033: IFFALSE 105037
// exit ;
105035: GO 105148
// index := GetElementIndex ( hackTanks , hack ) ;
105037: LD_ADDR_VAR 0 4
105041: PUSH
105042: LD_EXP 169
105046: PPUSH
105047: LD_VAR 0 1
105051: PPUSH
105052: CALL 20248 0 2
105056: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
105057: LD_EXP 170
105061: PUSH
105062: LD_VAR 0 4
105066: ARRAY
105067: IFFALSE 105148
// begin for i in hackTanksCaptured [ index ] do
105069: LD_ADDR_VAR 0 3
105073: PUSH
105074: LD_EXP 170
105078: PUSH
105079: LD_VAR 0 4
105083: ARRAY
105084: PUSH
105085: FOR_IN
105086: IFFALSE 105112
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105088: LD_VAR 0 3
105092: PUSH
105093: LD_INT 1
105095: ARRAY
105096: PPUSH
105097: LD_VAR 0 3
105101: PUSH
105102: LD_INT 2
105104: ARRAY
105105: PPUSH
105106: CALL_OW 235
105110: GO 105085
105112: POP
105113: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105114: LD_ADDR_EXP 170
105118: PUSH
105119: LD_EXP 170
105123: PPUSH
105124: LD_VAR 0 4
105128: PPUSH
105129: EMPTY
105130: PPUSH
105131: CALL_OW 1
105135: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105136: LD_VAR 0 1
105140: PPUSH
105141: LD_INT 0
105143: PPUSH
105144: CALL_OW 505
// end ; end ;
105148: LD_VAR 0 2
105152: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105153: LD_INT 0
105155: PPUSH
105156: PPUSH
105157: PPUSH
// if not hack in hackTanks or not vehicles then
105158: LD_VAR 0 1
105162: PUSH
105163: LD_EXP 169
105167: IN
105168: NOT
105169: PUSH
105170: LD_VAR 0 2
105174: NOT
105175: OR
105176: IFFALSE 105180
// exit ;
105178: GO 105455
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105180: LD_ADDR_VAR 0 2
105184: PUSH
105185: LD_VAR 0 1
105189: PPUSH
105190: LD_VAR 0 2
105194: PPUSH
105195: LD_INT 1
105197: PPUSH
105198: LD_INT 1
105200: PPUSH
105201: CALL 20898 0 4
105205: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105206: LD_ADDR_VAR 0 5
105210: PUSH
105211: LD_EXP 169
105215: PPUSH
105216: LD_VAR 0 1
105220: PPUSH
105221: CALL 20248 0 2
105225: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105226: LD_EXP 170
105230: PUSH
105231: LD_VAR 0 5
105235: ARRAY
105236: PUSH
105237: LD_EXP 171
105241: LESS
105242: IFFALSE 105431
// begin for i := 1 to vehicles do
105244: LD_ADDR_VAR 0 4
105248: PUSH
105249: DOUBLE
105250: LD_INT 1
105252: DEC
105253: ST_TO_ADDR
105254: LD_VAR 0 2
105258: PUSH
105259: FOR_TO
105260: IFFALSE 105429
// begin if hackTanksCaptured [ index ] = hackLimit then
105262: LD_EXP 170
105266: PUSH
105267: LD_VAR 0 5
105271: ARRAY
105272: PUSH
105273: LD_EXP 171
105277: EQUAL
105278: IFFALSE 105282
// break ;
105280: GO 105429
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105282: LD_ADDR_EXP 173
105286: PUSH
105287: LD_EXP 173
105291: PPUSH
105292: LD_VAR 0 5
105296: PPUSH
105297: LD_EXP 173
105301: PUSH
105302: LD_VAR 0 5
105306: ARRAY
105307: PUSH
105308: LD_INT 1
105310: PLUS
105311: PPUSH
105312: CALL_OW 1
105316: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105317: LD_ADDR_EXP 170
105321: PUSH
105322: LD_EXP 170
105326: PPUSH
105327: LD_VAR 0 5
105331: PUSH
105332: LD_EXP 170
105336: PUSH
105337: LD_VAR 0 5
105341: ARRAY
105342: PUSH
105343: LD_INT 1
105345: PLUS
105346: PUSH
105347: EMPTY
105348: LIST
105349: LIST
105350: PPUSH
105351: LD_VAR 0 2
105355: PUSH
105356: LD_VAR 0 4
105360: ARRAY
105361: PUSH
105362: LD_VAR 0 2
105366: PUSH
105367: LD_VAR 0 4
105371: ARRAY
105372: PPUSH
105373: CALL_OW 255
105377: PUSH
105378: EMPTY
105379: LIST
105380: LIST
105381: PPUSH
105382: CALL 20463 0 3
105386: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105387: LD_VAR 0 2
105391: PUSH
105392: LD_VAR 0 4
105396: ARRAY
105397: PPUSH
105398: LD_VAR 0 1
105402: PPUSH
105403: CALL_OW 255
105407: PPUSH
105408: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105412: LD_VAR 0 2
105416: PUSH
105417: LD_VAR 0 4
105421: ARRAY
105422: PPUSH
105423: CALL_OW 141
// end ;
105427: GO 105259
105429: POP
105430: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105431: LD_VAR 0 1
105435: PPUSH
105436: LD_EXP 170
105440: PUSH
105441: LD_VAR 0 5
105445: ARRAY
105446: PUSH
105447: LD_INT 0
105449: PLUS
105450: PPUSH
105451: CALL_OW 505
// end ;
105455: LD_VAR 0 3
105459: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105460: LD_INT 0
105462: PPUSH
105463: PPUSH
105464: PPUSH
105465: PPUSH
// if not hack in hackTanks then
105466: LD_VAR 0 1
105470: PUSH
105471: LD_EXP 169
105475: IN
105476: NOT
105477: IFFALSE 105481
// exit ;
105479: GO 105721
// index := GetElementIndex ( hackTanks , hack ) ;
105481: LD_ADDR_VAR 0 4
105485: PUSH
105486: LD_EXP 169
105490: PPUSH
105491: LD_VAR 0 1
105495: PPUSH
105496: CALL 20248 0 2
105500: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105501: LD_ADDR_VAR 0 3
105505: PUSH
105506: DOUBLE
105507: LD_EXP 170
105511: PUSH
105512: LD_VAR 0 4
105516: ARRAY
105517: INC
105518: ST_TO_ADDR
105519: LD_INT 1
105521: PUSH
105522: FOR_DOWNTO
105523: IFFALSE 105695
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105525: LD_ADDR_VAR 0 5
105529: PUSH
105530: LD_EXP 170
105534: PUSH
105535: LD_VAR 0 4
105539: ARRAY
105540: PUSH
105541: LD_VAR 0 3
105545: ARRAY
105546: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105547: LD_VAR 0 5
105551: PUSH
105552: LD_INT 1
105554: ARRAY
105555: PPUSH
105556: CALL_OW 302
105560: NOT
105561: PUSH
105562: LD_VAR 0 5
105566: PUSH
105567: LD_INT 1
105569: ARRAY
105570: PPUSH
105571: CALL_OW 255
105575: PUSH
105576: LD_VAR 0 1
105580: PPUSH
105581: CALL_OW 255
105585: NONEQUAL
105586: OR
105587: IFFALSE 105693
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105589: LD_VAR 0 5
105593: PUSH
105594: LD_INT 1
105596: ARRAY
105597: PPUSH
105598: CALL_OW 305
105602: PUSH
105603: LD_VAR 0 5
105607: PUSH
105608: LD_INT 1
105610: ARRAY
105611: PPUSH
105612: CALL_OW 255
105616: PUSH
105617: LD_VAR 0 1
105621: PPUSH
105622: CALL_OW 255
105626: EQUAL
105627: AND
105628: IFFALSE 105652
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105630: LD_VAR 0 5
105634: PUSH
105635: LD_INT 1
105637: ARRAY
105638: PPUSH
105639: LD_VAR 0 5
105643: PUSH
105644: LD_INT 2
105646: ARRAY
105647: PPUSH
105648: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105652: LD_ADDR_EXP 170
105656: PUSH
105657: LD_EXP 170
105661: PPUSH
105662: LD_VAR 0 4
105666: PPUSH
105667: LD_EXP 170
105671: PUSH
105672: LD_VAR 0 4
105676: ARRAY
105677: PPUSH
105678: LD_VAR 0 3
105682: PPUSH
105683: CALL_OW 3
105687: PPUSH
105688: CALL_OW 1
105692: ST_TO_ADDR
// end ; end ;
105693: GO 105522
105695: POP
105696: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105697: LD_VAR 0 1
105701: PPUSH
105702: LD_EXP 170
105706: PUSH
105707: LD_VAR 0 4
105711: ARRAY
105712: PUSH
105713: LD_INT 0
105715: PLUS
105716: PPUSH
105717: CALL_OW 505
// end ;
105721: LD_VAR 0 2
105725: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105726: LD_INT 0
105728: PPUSH
105729: PPUSH
105730: PPUSH
105731: PPUSH
// if not hack in hackTanks then
105732: LD_VAR 0 1
105736: PUSH
105737: LD_EXP 169
105741: IN
105742: NOT
105743: IFFALSE 105747
// exit ;
105745: GO 105832
// index := GetElementIndex ( hackTanks , hack ) ;
105747: LD_ADDR_VAR 0 5
105751: PUSH
105752: LD_EXP 169
105756: PPUSH
105757: LD_VAR 0 1
105761: PPUSH
105762: CALL 20248 0 2
105766: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105767: LD_ADDR_VAR 0 4
105771: PUSH
105772: DOUBLE
105773: LD_INT 1
105775: DEC
105776: ST_TO_ADDR
105777: LD_EXP 170
105781: PUSH
105782: LD_VAR 0 5
105786: ARRAY
105787: PUSH
105788: FOR_TO
105789: IFFALSE 105830
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105791: LD_EXP 170
105795: PUSH
105796: LD_VAR 0 5
105800: ARRAY
105801: PUSH
105802: LD_VAR 0 4
105806: ARRAY
105807: PUSH
105808: LD_INT 1
105810: ARRAY
105811: PUSH
105812: LD_VAR 0 2
105816: EQUAL
105817: IFFALSE 105828
// KillUnit ( vehicle ) ;
105819: LD_VAR 0 2
105823: PPUSH
105824: CALL_OW 66
105828: GO 105788
105830: POP
105831: POP
// end ;
105832: LD_VAR 0 3
105836: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105837: LD_EXP 174
105841: NOT
105842: IFFALSE 105877
105844: GO 105846
105846: DISABLE
// begin initMiner := true ;
105847: LD_ADDR_EXP 174
105851: PUSH
105852: LD_INT 1
105854: ST_TO_ADDR
// minersList := [ ] ;
105855: LD_ADDR_EXP 175
105859: PUSH
105860: EMPTY
105861: ST_TO_ADDR
// minerMinesList := [ ] ;
105862: LD_ADDR_EXP 176
105866: PUSH
105867: EMPTY
105868: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105869: LD_ADDR_EXP 177
105873: PUSH
105874: LD_INT 5
105876: ST_TO_ADDR
// end ;
105877: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105878: LD_EXP 174
105882: PUSH
105883: LD_INT 34
105885: PUSH
105886: LD_INT 81
105888: PUSH
105889: EMPTY
105890: LIST
105891: LIST
105892: PPUSH
105893: CALL_OW 69
105897: AND
105898: IFFALSE 106359
105900: GO 105902
105902: DISABLE
105903: LD_INT 0
105905: PPUSH
105906: PPUSH
105907: PPUSH
105908: PPUSH
// begin enable ;
105909: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105910: LD_ADDR_VAR 0 1
105914: PUSH
105915: LD_INT 34
105917: PUSH
105918: LD_INT 81
105920: PUSH
105921: EMPTY
105922: LIST
105923: LIST
105924: PPUSH
105925: CALL_OW 69
105929: PUSH
105930: FOR_IN
105931: IFFALSE 106003
// begin if not i in minersList then
105933: LD_VAR 0 1
105937: PUSH
105938: LD_EXP 175
105942: IN
105943: NOT
105944: IFFALSE 106001
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105946: LD_ADDR_EXP 175
105950: PUSH
105951: LD_EXP 175
105955: PPUSH
105956: LD_EXP 175
105960: PUSH
105961: LD_INT 1
105963: PLUS
105964: PPUSH
105965: LD_VAR 0 1
105969: PPUSH
105970: CALL_OW 1
105974: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105975: LD_ADDR_EXP 176
105979: PUSH
105980: LD_EXP 176
105984: PPUSH
105985: LD_EXP 176
105989: PUSH
105990: LD_INT 1
105992: PLUS
105993: PPUSH
105994: EMPTY
105995: PPUSH
105996: CALL_OW 1
106000: ST_TO_ADDR
// end end ;
106001: GO 105930
106003: POP
106004: POP
// for i := minerMinesList downto 1 do
106005: LD_ADDR_VAR 0 1
106009: PUSH
106010: DOUBLE
106011: LD_EXP 176
106015: INC
106016: ST_TO_ADDR
106017: LD_INT 1
106019: PUSH
106020: FOR_DOWNTO
106021: IFFALSE 106357
// begin if IsLive ( minersList [ i ] ) then
106023: LD_EXP 175
106027: PUSH
106028: LD_VAR 0 1
106032: ARRAY
106033: PPUSH
106034: CALL_OW 300
106038: IFFALSE 106066
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
106040: LD_EXP 175
106044: PUSH
106045: LD_VAR 0 1
106049: ARRAY
106050: PPUSH
106051: LD_EXP 176
106055: PUSH
106056: LD_VAR 0 1
106060: ARRAY
106061: PPUSH
106062: CALL_OW 505
// if not minerMinesList [ i ] then
106066: LD_EXP 176
106070: PUSH
106071: LD_VAR 0 1
106075: ARRAY
106076: NOT
106077: IFFALSE 106081
// continue ;
106079: GO 106020
// for j := minerMinesList [ i ] downto 1 do
106081: LD_ADDR_VAR 0 2
106085: PUSH
106086: DOUBLE
106087: LD_EXP 176
106091: PUSH
106092: LD_VAR 0 1
106096: ARRAY
106097: INC
106098: ST_TO_ADDR
106099: LD_INT 1
106101: PUSH
106102: FOR_DOWNTO
106103: IFFALSE 106353
// begin side := GetSide ( minersList [ i ] ) ;
106105: LD_ADDR_VAR 0 3
106109: PUSH
106110: LD_EXP 175
106114: PUSH
106115: LD_VAR 0 1
106119: ARRAY
106120: PPUSH
106121: CALL_OW 255
106125: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106126: LD_ADDR_VAR 0 4
106130: PUSH
106131: LD_EXP 176
106135: PUSH
106136: LD_VAR 0 1
106140: ARRAY
106141: PUSH
106142: LD_VAR 0 2
106146: ARRAY
106147: PUSH
106148: LD_INT 1
106150: ARRAY
106151: PPUSH
106152: LD_EXP 176
106156: PUSH
106157: LD_VAR 0 1
106161: ARRAY
106162: PUSH
106163: LD_VAR 0 2
106167: ARRAY
106168: PUSH
106169: LD_INT 2
106171: ARRAY
106172: PPUSH
106173: CALL_OW 428
106177: ST_TO_ADDR
// if not tmp then
106178: LD_VAR 0 4
106182: NOT
106183: IFFALSE 106187
// continue ;
106185: GO 106102
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106187: LD_VAR 0 4
106191: PUSH
106192: LD_INT 81
106194: PUSH
106195: LD_VAR 0 3
106199: PUSH
106200: EMPTY
106201: LIST
106202: LIST
106203: PPUSH
106204: CALL_OW 69
106208: IN
106209: PUSH
106210: LD_EXP 176
106214: PUSH
106215: LD_VAR 0 1
106219: ARRAY
106220: PUSH
106221: LD_VAR 0 2
106225: ARRAY
106226: PUSH
106227: LD_INT 1
106229: ARRAY
106230: PPUSH
106231: LD_EXP 176
106235: PUSH
106236: LD_VAR 0 1
106240: ARRAY
106241: PUSH
106242: LD_VAR 0 2
106246: ARRAY
106247: PUSH
106248: LD_INT 2
106250: ARRAY
106251: PPUSH
106252: CALL_OW 458
106256: AND
106257: IFFALSE 106351
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106259: LD_EXP 176
106263: PUSH
106264: LD_VAR 0 1
106268: ARRAY
106269: PUSH
106270: LD_VAR 0 2
106274: ARRAY
106275: PUSH
106276: LD_INT 1
106278: ARRAY
106279: PPUSH
106280: LD_EXP 176
106284: PUSH
106285: LD_VAR 0 1
106289: ARRAY
106290: PUSH
106291: LD_VAR 0 2
106295: ARRAY
106296: PUSH
106297: LD_INT 2
106299: ARRAY
106300: PPUSH
106301: LD_VAR 0 3
106305: PPUSH
106306: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106310: LD_ADDR_EXP 176
106314: PUSH
106315: LD_EXP 176
106319: PPUSH
106320: LD_VAR 0 1
106324: PPUSH
106325: LD_EXP 176
106329: PUSH
106330: LD_VAR 0 1
106334: ARRAY
106335: PPUSH
106336: LD_VAR 0 2
106340: PPUSH
106341: CALL_OW 3
106345: PPUSH
106346: CALL_OW 1
106350: ST_TO_ADDR
// end ; end ;
106351: GO 106102
106353: POP
106354: POP
// end ;
106355: GO 106020
106357: POP
106358: POP
// end ;
106359: PPOPN 4
106361: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106362: LD_INT 0
106364: PPUSH
106365: PPUSH
// result := false ;
106366: LD_ADDR_VAR 0 4
106370: PUSH
106371: LD_INT 0
106373: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106374: LD_VAR 0 1
106378: PPUSH
106379: CALL_OW 264
106383: PUSH
106384: LD_INT 81
106386: EQUAL
106387: NOT
106388: IFFALSE 106392
// exit ;
106390: GO 106632
// index := GetElementIndex ( minersList , unit ) ;
106392: LD_ADDR_VAR 0 5
106396: PUSH
106397: LD_EXP 175
106401: PPUSH
106402: LD_VAR 0 1
106406: PPUSH
106407: CALL 20248 0 2
106411: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106412: LD_EXP 176
106416: PUSH
106417: LD_VAR 0 5
106421: ARRAY
106422: PUSH
106423: LD_EXP 177
106427: GREATEREQUAL
106428: IFFALSE 106432
// exit ;
106430: GO 106632
// ComMoveXY ( unit , x , y ) ;
106432: LD_VAR 0 1
106436: PPUSH
106437: LD_VAR 0 2
106441: PPUSH
106442: LD_VAR 0 3
106446: PPUSH
106447: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106451: LD_INT 35
106453: PPUSH
106454: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106458: LD_VAR 0 1
106462: PPUSH
106463: LD_VAR 0 2
106467: PPUSH
106468: LD_VAR 0 3
106472: PPUSH
106473: CALL 51632 0 3
106477: NOT
106478: PUSH
106479: LD_VAR 0 1
106483: PPUSH
106484: CALL_OW 314
106488: AND
106489: IFFALSE 106493
// exit ;
106491: GO 106632
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106493: LD_VAR 0 2
106497: PPUSH
106498: LD_VAR 0 3
106502: PPUSH
106503: CALL_OW 428
106507: PUSH
106508: LD_VAR 0 1
106512: EQUAL
106513: PUSH
106514: LD_VAR 0 1
106518: PPUSH
106519: CALL_OW 314
106523: NOT
106524: AND
106525: IFFALSE 106451
// PlaySoundXY ( x , y , PlantMine ) ;
106527: LD_VAR 0 2
106531: PPUSH
106532: LD_VAR 0 3
106536: PPUSH
106537: LD_STRING PlantMine
106539: PPUSH
106540: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106544: LD_VAR 0 2
106548: PPUSH
106549: LD_VAR 0 3
106553: PPUSH
106554: LD_VAR 0 1
106558: PPUSH
106559: CALL_OW 255
106563: PPUSH
106564: LD_INT 0
106566: PPUSH
106567: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106571: LD_ADDR_EXP 176
106575: PUSH
106576: LD_EXP 176
106580: PPUSH
106581: LD_VAR 0 5
106585: PUSH
106586: LD_EXP 176
106590: PUSH
106591: LD_VAR 0 5
106595: ARRAY
106596: PUSH
106597: LD_INT 1
106599: PLUS
106600: PUSH
106601: EMPTY
106602: LIST
106603: LIST
106604: PPUSH
106605: LD_VAR 0 2
106609: PUSH
106610: LD_VAR 0 3
106614: PUSH
106615: EMPTY
106616: LIST
106617: LIST
106618: PPUSH
106619: CALL 20463 0 3
106623: ST_TO_ADDR
// result := true ;
106624: LD_ADDR_VAR 0 4
106628: PUSH
106629: LD_INT 1
106631: ST_TO_ADDR
// end ;
106632: LD_VAR 0 4
106636: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106637: LD_INT 0
106639: PPUSH
106640: PPUSH
106641: PPUSH
// if not unit in minersList then
106642: LD_VAR 0 1
106646: PUSH
106647: LD_EXP 175
106651: IN
106652: NOT
106653: IFFALSE 106657
// exit ;
106655: GO 107049
// index := GetElementIndex ( minersList , unit ) ;
106657: LD_ADDR_VAR 0 6
106661: PUSH
106662: LD_EXP 175
106666: PPUSH
106667: LD_VAR 0 1
106671: PPUSH
106672: CALL 20248 0 2
106676: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106677: LD_ADDR_VAR 0 5
106681: PUSH
106682: DOUBLE
106683: LD_EXP 176
106687: PUSH
106688: LD_VAR 0 6
106692: ARRAY
106693: INC
106694: ST_TO_ADDR
106695: LD_INT 1
106697: PUSH
106698: FOR_DOWNTO
106699: IFFALSE 106860
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106701: LD_EXP 176
106705: PUSH
106706: LD_VAR 0 6
106710: ARRAY
106711: PUSH
106712: LD_VAR 0 5
106716: ARRAY
106717: PUSH
106718: LD_INT 1
106720: ARRAY
106721: PUSH
106722: LD_VAR 0 2
106726: EQUAL
106727: PUSH
106728: LD_EXP 176
106732: PUSH
106733: LD_VAR 0 6
106737: ARRAY
106738: PUSH
106739: LD_VAR 0 5
106743: ARRAY
106744: PUSH
106745: LD_INT 2
106747: ARRAY
106748: PUSH
106749: LD_VAR 0 3
106753: EQUAL
106754: AND
106755: IFFALSE 106858
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106757: LD_EXP 176
106761: PUSH
106762: LD_VAR 0 6
106766: ARRAY
106767: PUSH
106768: LD_VAR 0 5
106772: ARRAY
106773: PUSH
106774: LD_INT 1
106776: ARRAY
106777: PPUSH
106778: LD_EXP 176
106782: PUSH
106783: LD_VAR 0 6
106787: ARRAY
106788: PUSH
106789: LD_VAR 0 5
106793: ARRAY
106794: PUSH
106795: LD_INT 2
106797: ARRAY
106798: PPUSH
106799: LD_VAR 0 1
106803: PPUSH
106804: CALL_OW 255
106808: PPUSH
106809: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106813: LD_ADDR_EXP 176
106817: PUSH
106818: LD_EXP 176
106822: PPUSH
106823: LD_VAR 0 6
106827: PPUSH
106828: LD_EXP 176
106832: PUSH
106833: LD_VAR 0 6
106837: ARRAY
106838: PPUSH
106839: LD_VAR 0 5
106843: PPUSH
106844: CALL_OW 3
106848: PPUSH
106849: CALL_OW 1
106853: ST_TO_ADDR
// exit ;
106854: POP
106855: POP
106856: GO 107049
// end ; end ;
106858: GO 106698
106860: POP
106861: POP
// for i := minerMinesList [ index ] downto 1 do
106862: LD_ADDR_VAR 0 5
106866: PUSH
106867: DOUBLE
106868: LD_EXP 176
106872: PUSH
106873: LD_VAR 0 6
106877: ARRAY
106878: INC
106879: ST_TO_ADDR
106880: LD_INT 1
106882: PUSH
106883: FOR_DOWNTO
106884: IFFALSE 107047
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106886: LD_EXP 176
106890: PUSH
106891: LD_VAR 0 6
106895: ARRAY
106896: PUSH
106897: LD_VAR 0 5
106901: ARRAY
106902: PUSH
106903: LD_INT 1
106905: ARRAY
106906: PPUSH
106907: LD_EXP 176
106911: PUSH
106912: LD_VAR 0 6
106916: ARRAY
106917: PUSH
106918: LD_VAR 0 5
106922: ARRAY
106923: PUSH
106924: LD_INT 2
106926: ARRAY
106927: PPUSH
106928: LD_VAR 0 2
106932: PPUSH
106933: LD_VAR 0 3
106937: PPUSH
106938: CALL_OW 298
106942: PUSH
106943: LD_INT 6
106945: LESS
106946: IFFALSE 107045
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106948: LD_EXP 176
106952: PUSH
106953: LD_VAR 0 6
106957: ARRAY
106958: PUSH
106959: LD_VAR 0 5
106963: ARRAY
106964: PUSH
106965: LD_INT 1
106967: ARRAY
106968: PPUSH
106969: LD_EXP 176
106973: PUSH
106974: LD_VAR 0 6
106978: ARRAY
106979: PUSH
106980: LD_VAR 0 5
106984: ARRAY
106985: PUSH
106986: LD_INT 2
106988: ARRAY
106989: PPUSH
106990: LD_VAR 0 1
106994: PPUSH
106995: CALL_OW 255
106999: PPUSH
107000: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
107004: LD_ADDR_EXP 176
107008: PUSH
107009: LD_EXP 176
107013: PPUSH
107014: LD_VAR 0 6
107018: PPUSH
107019: LD_EXP 176
107023: PUSH
107024: LD_VAR 0 6
107028: ARRAY
107029: PPUSH
107030: LD_VAR 0 5
107034: PPUSH
107035: CALL_OW 3
107039: PPUSH
107040: CALL_OW 1
107044: ST_TO_ADDR
// end ; end ;
107045: GO 106883
107047: POP
107048: POP
// end ;
107049: LD_VAR 0 4
107053: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
107054: LD_INT 0
107056: PPUSH
107057: PPUSH
107058: PPUSH
107059: PPUSH
107060: PPUSH
107061: PPUSH
107062: PPUSH
107063: PPUSH
107064: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107065: LD_VAR 0 1
107069: PPUSH
107070: CALL_OW 264
107074: PUSH
107075: LD_INT 81
107077: EQUAL
107078: NOT
107079: PUSH
107080: LD_VAR 0 1
107084: PUSH
107085: LD_EXP 175
107089: IN
107090: NOT
107091: OR
107092: IFFALSE 107096
// exit ;
107094: GO 107418
// index := GetElementIndex ( minersList , unit ) ;
107096: LD_ADDR_VAR 0 6
107100: PUSH
107101: LD_EXP 175
107105: PPUSH
107106: LD_VAR 0 1
107110: PPUSH
107111: CALL 20248 0 2
107115: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107116: LD_ADDR_VAR 0 8
107120: PUSH
107121: LD_EXP 177
107125: PUSH
107126: LD_EXP 176
107130: PUSH
107131: LD_VAR 0 6
107135: ARRAY
107136: MINUS
107137: ST_TO_ADDR
// if not minesFreeAmount then
107138: LD_VAR 0 8
107142: NOT
107143: IFFALSE 107147
// exit ;
107145: GO 107418
// tmp := [ ] ;
107147: LD_ADDR_VAR 0 7
107151: PUSH
107152: EMPTY
107153: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107154: LD_ADDR_VAR 0 5
107158: PUSH
107159: DOUBLE
107160: LD_INT 1
107162: DEC
107163: ST_TO_ADDR
107164: LD_VAR 0 8
107168: PUSH
107169: FOR_TO
107170: IFFALSE 107365
// begin _d := rand ( 0 , 5 ) ;
107172: LD_ADDR_VAR 0 11
107176: PUSH
107177: LD_INT 0
107179: PPUSH
107180: LD_INT 5
107182: PPUSH
107183: CALL_OW 12
107187: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107188: LD_ADDR_VAR 0 12
107192: PUSH
107193: LD_INT 2
107195: PPUSH
107196: LD_INT 6
107198: PPUSH
107199: CALL_OW 12
107203: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107204: LD_ADDR_VAR 0 9
107208: PUSH
107209: LD_VAR 0 2
107213: PPUSH
107214: LD_VAR 0 11
107218: PPUSH
107219: LD_VAR 0 12
107223: PPUSH
107224: CALL_OW 272
107228: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107229: LD_ADDR_VAR 0 10
107233: PUSH
107234: LD_VAR 0 3
107238: PPUSH
107239: LD_VAR 0 11
107243: PPUSH
107244: LD_VAR 0 12
107248: PPUSH
107249: CALL_OW 273
107253: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107254: LD_VAR 0 9
107258: PPUSH
107259: LD_VAR 0 10
107263: PPUSH
107264: CALL_OW 488
107268: PUSH
107269: LD_VAR 0 9
107273: PUSH
107274: LD_VAR 0 10
107278: PUSH
107279: EMPTY
107280: LIST
107281: LIST
107282: PUSH
107283: LD_VAR 0 7
107287: IN
107288: NOT
107289: AND
107290: PUSH
107291: LD_VAR 0 9
107295: PPUSH
107296: LD_VAR 0 10
107300: PPUSH
107301: CALL_OW 458
107305: NOT
107306: AND
107307: IFFALSE 107349
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107309: LD_ADDR_VAR 0 7
107313: PUSH
107314: LD_VAR 0 7
107318: PPUSH
107319: LD_VAR 0 7
107323: PUSH
107324: LD_INT 1
107326: PLUS
107327: PPUSH
107328: LD_VAR 0 9
107332: PUSH
107333: LD_VAR 0 10
107337: PUSH
107338: EMPTY
107339: LIST
107340: LIST
107341: PPUSH
107342: CALL_OW 1
107346: ST_TO_ADDR
107347: GO 107363
// i := i - 1 ;
107349: LD_ADDR_VAR 0 5
107353: PUSH
107354: LD_VAR 0 5
107358: PUSH
107359: LD_INT 1
107361: MINUS
107362: ST_TO_ADDR
// end ;
107363: GO 107169
107365: POP
107366: POP
// for i in tmp do
107367: LD_ADDR_VAR 0 5
107371: PUSH
107372: LD_VAR 0 7
107376: PUSH
107377: FOR_IN
107378: IFFALSE 107416
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107380: LD_VAR 0 1
107384: PPUSH
107385: LD_VAR 0 5
107389: PUSH
107390: LD_INT 1
107392: ARRAY
107393: PPUSH
107394: LD_VAR 0 5
107398: PUSH
107399: LD_INT 2
107401: ARRAY
107402: PPUSH
107403: CALL 106362 0 3
107407: NOT
107408: IFFALSE 107414
// exit ;
107410: POP
107411: POP
107412: GO 107418
107414: GO 107377
107416: POP
107417: POP
// end ;
107418: LD_VAR 0 4
107422: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107423: LD_INT 0
107425: PPUSH
107426: PPUSH
107427: PPUSH
107428: PPUSH
107429: PPUSH
107430: PPUSH
107431: PPUSH
// if not GetClass ( unit ) = class_sniper then
107432: LD_VAR 0 1
107436: PPUSH
107437: CALL_OW 257
107441: PUSH
107442: LD_INT 5
107444: EQUAL
107445: NOT
107446: IFFALSE 107450
// exit ;
107448: GO 107838
// dist := 8 ;
107450: LD_ADDR_VAR 0 5
107454: PUSH
107455: LD_INT 8
107457: ST_TO_ADDR
// viewRange := 12 ;
107458: LD_ADDR_VAR 0 7
107462: PUSH
107463: LD_INT 12
107465: ST_TO_ADDR
// side := GetSide ( unit ) ;
107466: LD_ADDR_VAR 0 6
107470: PUSH
107471: LD_VAR 0 1
107475: PPUSH
107476: CALL_OW 255
107480: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107481: LD_INT 61
107483: PPUSH
107484: LD_VAR 0 6
107488: PPUSH
107489: CALL_OW 321
107493: PUSH
107494: LD_INT 2
107496: EQUAL
107497: IFFALSE 107507
// viewRange := 16 ;
107499: LD_ADDR_VAR 0 7
107503: PUSH
107504: LD_INT 16
107506: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107507: LD_VAR 0 1
107511: PPUSH
107512: LD_VAR 0 2
107516: PPUSH
107517: LD_VAR 0 3
107521: PPUSH
107522: CALL_OW 297
107526: PUSH
107527: LD_VAR 0 5
107531: GREATER
107532: IFFALSE 107611
// begin ComMoveXY ( unit , x , y ) ;
107534: LD_VAR 0 1
107538: PPUSH
107539: LD_VAR 0 2
107543: PPUSH
107544: LD_VAR 0 3
107548: PPUSH
107549: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107553: LD_INT 35
107555: PPUSH
107556: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107560: LD_VAR 0 1
107564: PPUSH
107565: LD_VAR 0 2
107569: PPUSH
107570: LD_VAR 0 3
107574: PPUSH
107575: CALL 51632 0 3
107579: NOT
107580: IFFALSE 107584
// exit ;
107582: GO 107838
// until GetDistUnitXY ( unit , x , y ) < dist ;
107584: LD_VAR 0 1
107588: PPUSH
107589: LD_VAR 0 2
107593: PPUSH
107594: LD_VAR 0 3
107598: PPUSH
107599: CALL_OW 297
107603: PUSH
107604: LD_VAR 0 5
107608: LESS
107609: IFFALSE 107553
// end ; ComTurnXY ( unit , x , y ) ;
107611: LD_VAR 0 1
107615: PPUSH
107616: LD_VAR 0 2
107620: PPUSH
107621: LD_VAR 0 3
107625: PPUSH
107626: CALL_OW 118
// wait ( 5 ) ;
107630: LD_INT 5
107632: PPUSH
107633: CALL_OW 67
// _d := GetDir ( unit ) ;
107637: LD_ADDR_VAR 0 10
107641: PUSH
107642: LD_VAR 0 1
107646: PPUSH
107647: CALL_OW 254
107651: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107652: LD_ADDR_VAR 0 8
107656: PUSH
107657: LD_VAR 0 1
107661: PPUSH
107662: CALL_OW 250
107666: PPUSH
107667: LD_VAR 0 10
107671: PPUSH
107672: LD_VAR 0 5
107676: PPUSH
107677: CALL_OW 272
107681: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107682: LD_ADDR_VAR 0 9
107686: PUSH
107687: LD_VAR 0 1
107691: PPUSH
107692: CALL_OW 251
107696: PPUSH
107697: LD_VAR 0 10
107701: PPUSH
107702: LD_VAR 0 5
107706: PPUSH
107707: CALL_OW 273
107711: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107712: LD_VAR 0 8
107716: PPUSH
107717: LD_VAR 0 9
107721: PPUSH
107722: CALL_OW 488
107726: NOT
107727: IFFALSE 107731
// exit ;
107729: GO 107838
// ComAnimCustom ( unit , 1 ) ;
107731: LD_VAR 0 1
107735: PPUSH
107736: LD_INT 1
107738: PPUSH
107739: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107743: LD_VAR 0 8
107747: PPUSH
107748: LD_VAR 0 9
107752: PPUSH
107753: LD_VAR 0 6
107757: PPUSH
107758: LD_VAR 0 7
107762: PPUSH
107763: CALL_OW 330
// repeat wait ( 1 ) ;
107767: LD_INT 1
107769: PPUSH
107770: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107774: LD_VAR 0 1
107778: PPUSH
107779: CALL_OW 316
107783: PUSH
107784: LD_VAR 0 1
107788: PPUSH
107789: CALL_OW 314
107793: OR
107794: PUSH
107795: LD_VAR 0 1
107799: PPUSH
107800: CALL_OW 302
107804: NOT
107805: OR
107806: PUSH
107807: LD_VAR 0 1
107811: PPUSH
107812: CALL_OW 301
107816: OR
107817: IFFALSE 107767
// RemoveSeeing ( _x , _y , side ) ;
107819: LD_VAR 0 8
107823: PPUSH
107824: LD_VAR 0 9
107828: PPUSH
107829: LD_VAR 0 6
107833: PPUSH
107834: CALL_OW 331
// end ; end_of_file
107838: LD_VAR 0 4
107842: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107843: LD_INT 0
107845: PPUSH
107846: PPUSH
107847: PPUSH
107848: PPUSH
107849: PPUSH
107850: PPUSH
107851: PPUSH
107852: PPUSH
107853: PPUSH
107854: PPUSH
107855: PPUSH
107856: PPUSH
107857: PPUSH
107858: PPUSH
107859: PPUSH
107860: PPUSH
107861: PPUSH
107862: PPUSH
107863: PPUSH
107864: PPUSH
107865: PPUSH
107866: PPUSH
107867: PPUSH
107868: PPUSH
107869: PPUSH
107870: PPUSH
107871: PPUSH
107872: PPUSH
107873: PPUSH
107874: PPUSH
107875: PPUSH
107876: PPUSH
107877: PPUSH
107878: PPUSH
// if not list then
107879: LD_VAR 0 1
107883: NOT
107884: IFFALSE 107888
// exit ;
107886: GO 112547
// base := list [ 1 ] ;
107888: LD_ADDR_VAR 0 3
107892: PUSH
107893: LD_VAR 0 1
107897: PUSH
107898: LD_INT 1
107900: ARRAY
107901: ST_TO_ADDR
// group := list [ 2 ] ;
107902: LD_ADDR_VAR 0 4
107906: PUSH
107907: LD_VAR 0 1
107911: PUSH
107912: LD_INT 2
107914: ARRAY
107915: ST_TO_ADDR
// path := list [ 3 ] ;
107916: LD_ADDR_VAR 0 5
107920: PUSH
107921: LD_VAR 0 1
107925: PUSH
107926: LD_INT 3
107928: ARRAY
107929: ST_TO_ADDR
// flags := list [ 4 ] ;
107930: LD_ADDR_VAR 0 6
107934: PUSH
107935: LD_VAR 0 1
107939: PUSH
107940: LD_INT 4
107942: ARRAY
107943: ST_TO_ADDR
// mined := [ ] ;
107944: LD_ADDR_VAR 0 27
107948: PUSH
107949: EMPTY
107950: ST_TO_ADDR
// bombed := [ ] ;
107951: LD_ADDR_VAR 0 28
107955: PUSH
107956: EMPTY
107957: ST_TO_ADDR
// healers := [ ] ;
107958: LD_ADDR_VAR 0 31
107962: PUSH
107963: EMPTY
107964: ST_TO_ADDR
// to_heal := [ ] ;
107965: LD_ADDR_VAR 0 30
107969: PUSH
107970: EMPTY
107971: ST_TO_ADDR
// repairs := [ ] ;
107972: LD_ADDR_VAR 0 33
107976: PUSH
107977: EMPTY
107978: ST_TO_ADDR
// to_repair := [ ] ;
107979: LD_ADDR_VAR 0 32
107983: PUSH
107984: EMPTY
107985: ST_TO_ADDR
// if not group or not path then
107986: LD_VAR 0 4
107990: NOT
107991: PUSH
107992: LD_VAR 0 5
107996: NOT
107997: OR
107998: IFFALSE 108002
// exit ;
108000: GO 112547
// side := GetSide ( group [ 1 ] ) ;
108002: LD_ADDR_VAR 0 35
108006: PUSH
108007: LD_VAR 0 4
108011: PUSH
108012: LD_INT 1
108014: ARRAY
108015: PPUSH
108016: CALL_OW 255
108020: ST_TO_ADDR
// if flags then
108021: LD_VAR 0 6
108025: IFFALSE 108169
// begin f_ignore_area := flags [ 1 ] ;
108027: LD_ADDR_VAR 0 17
108031: PUSH
108032: LD_VAR 0 6
108036: PUSH
108037: LD_INT 1
108039: ARRAY
108040: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
108041: LD_ADDR_VAR 0 18
108045: PUSH
108046: LD_VAR 0 6
108050: PUSH
108051: LD_INT 2
108053: ARRAY
108054: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
108055: LD_ADDR_VAR 0 19
108059: PUSH
108060: LD_VAR 0 6
108064: PUSH
108065: LD_INT 3
108067: ARRAY
108068: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108069: LD_ADDR_VAR 0 20
108073: PUSH
108074: LD_VAR 0 6
108078: PUSH
108079: LD_INT 4
108081: ARRAY
108082: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108083: LD_ADDR_VAR 0 21
108087: PUSH
108088: LD_VAR 0 6
108092: PUSH
108093: LD_INT 5
108095: ARRAY
108096: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108097: LD_ADDR_VAR 0 22
108101: PUSH
108102: LD_VAR 0 6
108106: PUSH
108107: LD_INT 6
108109: ARRAY
108110: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108111: LD_ADDR_VAR 0 23
108115: PUSH
108116: LD_VAR 0 6
108120: PUSH
108121: LD_INT 7
108123: ARRAY
108124: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108125: LD_ADDR_VAR 0 24
108129: PUSH
108130: LD_VAR 0 6
108134: PUSH
108135: LD_INT 8
108137: ARRAY
108138: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108139: LD_ADDR_VAR 0 25
108143: PUSH
108144: LD_VAR 0 6
108148: PUSH
108149: LD_INT 9
108151: ARRAY
108152: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108153: LD_ADDR_VAR 0 26
108157: PUSH
108158: LD_VAR 0 6
108162: PUSH
108163: LD_INT 10
108165: ARRAY
108166: ST_TO_ADDR
// end else
108167: GO 108249
// begin f_ignore_area := false ;
108169: LD_ADDR_VAR 0 17
108173: PUSH
108174: LD_INT 0
108176: ST_TO_ADDR
// f_capture := false ;
108177: LD_ADDR_VAR 0 18
108181: PUSH
108182: LD_INT 0
108184: ST_TO_ADDR
// f_ignore_civ := false ;
108185: LD_ADDR_VAR 0 19
108189: PUSH
108190: LD_INT 0
108192: ST_TO_ADDR
// f_murder := false ;
108193: LD_ADDR_VAR 0 20
108197: PUSH
108198: LD_INT 0
108200: ST_TO_ADDR
// f_mines := false ;
108201: LD_ADDR_VAR 0 21
108205: PUSH
108206: LD_INT 0
108208: ST_TO_ADDR
// f_repair := false ;
108209: LD_ADDR_VAR 0 22
108213: PUSH
108214: LD_INT 0
108216: ST_TO_ADDR
// f_heal := false ;
108217: LD_ADDR_VAR 0 23
108221: PUSH
108222: LD_INT 0
108224: ST_TO_ADDR
// f_spacetime := false ;
108225: LD_ADDR_VAR 0 24
108229: PUSH
108230: LD_INT 0
108232: ST_TO_ADDR
// f_attack_depot := false ;
108233: LD_ADDR_VAR 0 25
108237: PUSH
108238: LD_INT 0
108240: ST_TO_ADDR
// f_crawl := false ;
108241: LD_ADDR_VAR 0 26
108245: PUSH
108246: LD_INT 0
108248: ST_TO_ADDR
// end ; if f_heal then
108249: LD_VAR 0 23
108253: IFFALSE 108280
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108255: LD_ADDR_VAR 0 31
108259: PUSH
108260: LD_VAR 0 4
108264: PPUSH
108265: LD_INT 25
108267: PUSH
108268: LD_INT 4
108270: PUSH
108271: EMPTY
108272: LIST
108273: LIST
108274: PPUSH
108275: CALL_OW 72
108279: ST_TO_ADDR
// if f_repair then
108280: LD_VAR 0 22
108284: IFFALSE 108311
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108286: LD_ADDR_VAR 0 33
108290: PUSH
108291: LD_VAR 0 4
108295: PPUSH
108296: LD_INT 25
108298: PUSH
108299: LD_INT 3
108301: PUSH
108302: EMPTY
108303: LIST
108304: LIST
108305: PPUSH
108306: CALL_OW 72
108310: ST_TO_ADDR
// units_path := [ ] ;
108311: LD_ADDR_VAR 0 16
108315: PUSH
108316: EMPTY
108317: ST_TO_ADDR
// for i = 1 to group do
108318: LD_ADDR_VAR 0 7
108322: PUSH
108323: DOUBLE
108324: LD_INT 1
108326: DEC
108327: ST_TO_ADDR
108328: LD_VAR 0 4
108332: PUSH
108333: FOR_TO
108334: IFFALSE 108363
// units_path := Replace ( units_path , i , path ) ;
108336: LD_ADDR_VAR 0 16
108340: PUSH
108341: LD_VAR 0 16
108345: PPUSH
108346: LD_VAR 0 7
108350: PPUSH
108351: LD_VAR 0 5
108355: PPUSH
108356: CALL_OW 1
108360: ST_TO_ADDR
108361: GO 108333
108363: POP
108364: POP
// repeat for i = group downto 1 do
108365: LD_ADDR_VAR 0 7
108369: PUSH
108370: DOUBLE
108371: LD_VAR 0 4
108375: INC
108376: ST_TO_ADDR
108377: LD_INT 1
108379: PUSH
108380: FOR_DOWNTO
108381: IFFALSE 112503
// begin wait ( 5 ) ;
108383: LD_INT 5
108385: PPUSH
108386: CALL_OW 67
// tmp := [ ] ;
108390: LD_ADDR_VAR 0 14
108394: PUSH
108395: EMPTY
108396: ST_TO_ADDR
// attacking := false ;
108397: LD_ADDR_VAR 0 29
108401: PUSH
108402: LD_INT 0
108404: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108405: LD_VAR 0 4
108409: PUSH
108410: LD_VAR 0 7
108414: ARRAY
108415: PPUSH
108416: CALL_OW 301
108420: PUSH
108421: LD_VAR 0 4
108425: PUSH
108426: LD_VAR 0 7
108430: ARRAY
108431: NOT
108432: OR
108433: IFFALSE 108542
// begin if GetType ( group [ i ] ) = unit_human then
108435: LD_VAR 0 4
108439: PUSH
108440: LD_VAR 0 7
108444: ARRAY
108445: PPUSH
108446: CALL_OW 247
108450: PUSH
108451: LD_INT 1
108453: EQUAL
108454: IFFALSE 108500
// begin to_heal := to_heal diff group [ i ] ;
108456: LD_ADDR_VAR 0 30
108460: PUSH
108461: LD_VAR 0 30
108465: PUSH
108466: LD_VAR 0 4
108470: PUSH
108471: LD_VAR 0 7
108475: ARRAY
108476: DIFF
108477: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108478: LD_ADDR_VAR 0 31
108482: PUSH
108483: LD_VAR 0 31
108487: PUSH
108488: LD_VAR 0 4
108492: PUSH
108493: LD_VAR 0 7
108497: ARRAY
108498: DIFF
108499: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108500: LD_ADDR_VAR 0 4
108504: PUSH
108505: LD_VAR 0 4
108509: PPUSH
108510: LD_VAR 0 7
108514: PPUSH
108515: CALL_OW 3
108519: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108520: LD_ADDR_VAR 0 16
108524: PUSH
108525: LD_VAR 0 16
108529: PPUSH
108530: LD_VAR 0 7
108534: PPUSH
108535: CALL_OW 3
108539: ST_TO_ADDR
// continue ;
108540: GO 108380
// end ; if f_repair then
108542: LD_VAR 0 22
108546: IFFALSE 109035
// begin if GetType ( group [ i ] ) = unit_vehicle then
108548: LD_VAR 0 4
108552: PUSH
108553: LD_VAR 0 7
108557: ARRAY
108558: PPUSH
108559: CALL_OW 247
108563: PUSH
108564: LD_INT 2
108566: EQUAL
108567: IFFALSE 108757
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108569: LD_VAR 0 4
108573: PUSH
108574: LD_VAR 0 7
108578: ARRAY
108579: PPUSH
108580: CALL_OW 256
108584: PUSH
108585: LD_INT 700
108587: LESS
108588: PUSH
108589: LD_VAR 0 4
108593: PUSH
108594: LD_VAR 0 7
108598: ARRAY
108599: PUSH
108600: LD_VAR 0 32
108604: IN
108605: NOT
108606: AND
108607: IFFALSE 108631
// to_repair := to_repair union group [ i ] ;
108609: LD_ADDR_VAR 0 32
108613: PUSH
108614: LD_VAR 0 32
108618: PUSH
108619: LD_VAR 0 4
108623: PUSH
108624: LD_VAR 0 7
108628: ARRAY
108629: UNION
108630: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108631: LD_VAR 0 4
108635: PUSH
108636: LD_VAR 0 7
108640: ARRAY
108641: PPUSH
108642: CALL_OW 256
108646: PUSH
108647: LD_INT 1000
108649: EQUAL
108650: PUSH
108651: LD_VAR 0 4
108655: PUSH
108656: LD_VAR 0 7
108660: ARRAY
108661: PUSH
108662: LD_VAR 0 32
108666: IN
108667: AND
108668: IFFALSE 108692
// to_repair := to_repair diff group [ i ] ;
108670: LD_ADDR_VAR 0 32
108674: PUSH
108675: LD_VAR 0 32
108679: PUSH
108680: LD_VAR 0 4
108684: PUSH
108685: LD_VAR 0 7
108689: ARRAY
108690: DIFF
108691: ST_TO_ADDR
// if group [ i ] in to_repair then
108692: LD_VAR 0 4
108696: PUSH
108697: LD_VAR 0 7
108701: ARRAY
108702: PUSH
108703: LD_VAR 0 32
108707: IN
108708: IFFALSE 108755
// begin if not IsInArea ( group [ i ] , f_repair ) then
108710: LD_VAR 0 4
108714: PUSH
108715: LD_VAR 0 7
108719: ARRAY
108720: PPUSH
108721: LD_VAR 0 22
108725: PPUSH
108726: CALL_OW 308
108730: NOT
108731: IFFALSE 108753
// ComMoveToArea ( group [ i ] , f_repair ) ;
108733: LD_VAR 0 4
108737: PUSH
108738: LD_VAR 0 7
108742: ARRAY
108743: PPUSH
108744: LD_VAR 0 22
108748: PPUSH
108749: CALL_OW 113
// continue ;
108753: GO 108380
// end ; end else
108755: GO 109035
// if group [ i ] in repairs then
108757: LD_VAR 0 4
108761: PUSH
108762: LD_VAR 0 7
108766: ARRAY
108767: PUSH
108768: LD_VAR 0 33
108772: IN
108773: IFFALSE 109035
// begin if IsInUnit ( group [ i ] ) then
108775: LD_VAR 0 4
108779: PUSH
108780: LD_VAR 0 7
108784: ARRAY
108785: PPUSH
108786: CALL_OW 310
108790: IFFALSE 108858
// begin z := IsInUnit ( group [ i ] ) ;
108792: LD_ADDR_VAR 0 13
108796: PUSH
108797: LD_VAR 0 4
108801: PUSH
108802: LD_VAR 0 7
108806: ARRAY
108807: PPUSH
108808: CALL_OW 310
108812: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108813: LD_VAR 0 13
108817: PUSH
108818: LD_VAR 0 32
108822: IN
108823: PUSH
108824: LD_VAR 0 13
108828: PPUSH
108829: LD_VAR 0 22
108833: PPUSH
108834: CALL_OW 308
108838: AND
108839: IFFALSE 108856
// ComExitVehicle ( group [ i ] ) ;
108841: LD_VAR 0 4
108845: PUSH
108846: LD_VAR 0 7
108850: ARRAY
108851: PPUSH
108852: CALL_OW 121
// end else
108856: GO 109035
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108858: LD_ADDR_VAR 0 13
108862: PUSH
108863: LD_VAR 0 4
108867: PPUSH
108868: LD_INT 95
108870: PUSH
108871: LD_VAR 0 22
108875: PUSH
108876: EMPTY
108877: LIST
108878: LIST
108879: PUSH
108880: LD_INT 58
108882: PUSH
108883: EMPTY
108884: LIST
108885: PUSH
108886: EMPTY
108887: LIST
108888: LIST
108889: PPUSH
108890: CALL_OW 72
108894: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108895: LD_VAR 0 4
108899: PUSH
108900: LD_VAR 0 7
108904: ARRAY
108905: PPUSH
108906: CALL_OW 314
108910: NOT
108911: IFFALSE 109033
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108913: LD_ADDR_VAR 0 10
108917: PUSH
108918: LD_VAR 0 13
108922: PPUSH
108923: LD_VAR 0 4
108927: PUSH
108928: LD_VAR 0 7
108932: ARRAY
108933: PPUSH
108934: CALL_OW 74
108938: ST_TO_ADDR
// if not x then
108939: LD_VAR 0 10
108943: NOT
108944: IFFALSE 108948
// continue ;
108946: GO 108380
// if GetLives ( x ) < 1000 then
108948: LD_VAR 0 10
108952: PPUSH
108953: CALL_OW 256
108957: PUSH
108958: LD_INT 1000
108960: LESS
108961: IFFALSE 108985
// ComRepairVehicle ( group [ i ] , x ) else
108963: LD_VAR 0 4
108967: PUSH
108968: LD_VAR 0 7
108972: ARRAY
108973: PPUSH
108974: LD_VAR 0 10
108978: PPUSH
108979: CALL_OW 129
108983: GO 109033
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108985: LD_VAR 0 23
108989: PUSH
108990: LD_VAR 0 4
108994: PUSH
108995: LD_VAR 0 7
108999: ARRAY
109000: PPUSH
109001: CALL_OW 256
109005: PUSH
109006: LD_INT 1000
109008: LESS
109009: AND
109010: NOT
109011: IFFALSE 109033
// ComEnterUnit ( group [ i ] , x ) ;
109013: LD_VAR 0 4
109017: PUSH
109018: LD_VAR 0 7
109022: ARRAY
109023: PPUSH
109024: LD_VAR 0 10
109028: PPUSH
109029: CALL_OW 120
// end ; continue ;
109033: GO 108380
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
109035: LD_VAR 0 23
109039: PUSH
109040: LD_VAR 0 4
109044: PUSH
109045: LD_VAR 0 7
109049: ARRAY
109050: PPUSH
109051: CALL_OW 247
109055: PUSH
109056: LD_INT 1
109058: EQUAL
109059: AND
109060: IFFALSE 109538
// begin if group [ i ] in healers then
109062: LD_VAR 0 4
109066: PUSH
109067: LD_VAR 0 7
109071: ARRAY
109072: PUSH
109073: LD_VAR 0 31
109077: IN
109078: IFFALSE 109351
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109080: LD_VAR 0 4
109084: PUSH
109085: LD_VAR 0 7
109089: ARRAY
109090: PPUSH
109091: LD_VAR 0 23
109095: PPUSH
109096: CALL_OW 308
109100: NOT
109101: PUSH
109102: LD_VAR 0 4
109106: PUSH
109107: LD_VAR 0 7
109111: ARRAY
109112: PPUSH
109113: CALL_OW 314
109117: NOT
109118: AND
109119: IFFALSE 109143
// ComMoveToArea ( group [ i ] , f_heal ) else
109121: LD_VAR 0 4
109125: PUSH
109126: LD_VAR 0 7
109130: ARRAY
109131: PPUSH
109132: LD_VAR 0 23
109136: PPUSH
109137: CALL_OW 113
109141: GO 109349
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109143: LD_VAR 0 4
109147: PUSH
109148: LD_VAR 0 7
109152: ARRAY
109153: PPUSH
109154: CALL 50215 0 1
109158: PPUSH
109159: CALL_OW 256
109163: PUSH
109164: LD_INT 1000
109166: EQUAL
109167: IFFALSE 109186
// ComStop ( group [ i ] ) else
109169: LD_VAR 0 4
109173: PUSH
109174: LD_VAR 0 7
109178: ARRAY
109179: PPUSH
109180: CALL_OW 141
109184: GO 109349
// if not HasTask ( group [ i ] ) and to_heal then
109186: LD_VAR 0 4
109190: PUSH
109191: LD_VAR 0 7
109195: ARRAY
109196: PPUSH
109197: CALL_OW 314
109201: NOT
109202: PUSH
109203: LD_VAR 0 30
109207: AND
109208: IFFALSE 109349
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109210: LD_ADDR_VAR 0 13
109214: PUSH
109215: LD_VAR 0 30
109219: PPUSH
109220: LD_INT 3
109222: PUSH
109223: LD_INT 54
109225: PUSH
109226: EMPTY
109227: LIST
109228: PUSH
109229: EMPTY
109230: LIST
109231: LIST
109232: PPUSH
109233: CALL_OW 72
109237: PPUSH
109238: LD_VAR 0 4
109242: PUSH
109243: LD_VAR 0 7
109247: ARRAY
109248: PPUSH
109249: CALL_OW 74
109253: ST_TO_ADDR
// if z then
109254: LD_VAR 0 13
109258: IFFALSE 109349
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109260: LD_INT 91
109262: PUSH
109263: LD_VAR 0 13
109267: PUSH
109268: LD_INT 10
109270: PUSH
109271: EMPTY
109272: LIST
109273: LIST
109274: LIST
109275: PUSH
109276: LD_INT 81
109278: PUSH
109279: LD_VAR 0 13
109283: PPUSH
109284: CALL_OW 255
109288: PUSH
109289: EMPTY
109290: LIST
109291: LIST
109292: PUSH
109293: EMPTY
109294: LIST
109295: LIST
109296: PPUSH
109297: CALL_OW 69
109301: PUSH
109302: LD_INT 0
109304: EQUAL
109305: IFFALSE 109329
// ComHeal ( group [ i ] , z ) else
109307: LD_VAR 0 4
109311: PUSH
109312: LD_VAR 0 7
109316: ARRAY
109317: PPUSH
109318: LD_VAR 0 13
109322: PPUSH
109323: CALL_OW 128
109327: GO 109349
// ComMoveToArea ( group [ i ] , f_heal ) ;
109329: LD_VAR 0 4
109333: PUSH
109334: LD_VAR 0 7
109338: ARRAY
109339: PPUSH
109340: LD_VAR 0 23
109344: PPUSH
109345: CALL_OW 113
// end ; continue ;
109349: GO 108380
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109351: LD_VAR 0 4
109355: PUSH
109356: LD_VAR 0 7
109360: ARRAY
109361: PPUSH
109362: CALL_OW 256
109366: PUSH
109367: LD_INT 700
109369: LESS
109370: PUSH
109371: LD_VAR 0 4
109375: PUSH
109376: LD_VAR 0 7
109380: ARRAY
109381: PUSH
109382: LD_VAR 0 30
109386: IN
109387: NOT
109388: AND
109389: IFFALSE 109413
// to_heal := to_heal union group [ i ] ;
109391: LD_ADDR_VAR 0 30
109395: PUSH
109396: LD_VAR 0 30
109400: PUSH
109401: LD_VAR 0 4
109405: PUSH
109406: LD_VAR 0 7
109410: ARRAY
109411: UNION
109412: ST_TO_ADDR
// if group [ i ] in to_heal then
109413: LD_VAR 0 4
109417: PUSH
109418: LD_VAR 0 7
109422: ARRAY
109423: PUSH
109424: LD_VAR 0 30
109428: IN
109429: IFFALSE 109538
// begin if GetLives ( group [ i ] ) = 1000 then
109431: LD_VAR 0 4
109435: PUSH
109436: LD_VAR 0 7
109440: ARRAY
109441: PPUSH
109442: CALL_OW 256
109446: PUSH
109447: LD_INT 1000
109449: EQUAL
109450: IFFALSE 109476
// to_heal := to_heal diff group [ i ] else
109452: LD_ADDR_VAR 0 30
109456: PUSH
109457: LD_VAR 0 30
109461: PUSH
109462: LD_VAR 0 4
109466: PUSH
109467: LD_VAR 0 7
109471: ARRAY
109472: DIFF
109473: ST_TO_ADDR
109474: GO 109538
// begin if not IsInArea ( group [ i ] , to_heal ) then
109476: LD_VAR 0 4
109480: PUSH
109481: LD_VAR 0 7
109485: ARRAY
109486: PPUSH
109487: LD_VAR 0 30
109491: PPUSH
109492: CALL_OW 308
109496: NOT
109497: IFFALSE 109521
// ComMoveToArea ( group [ i ] , f_heal ) else
109499: LD_VAR 0 4
109503: PUSH
109504: LD_VAR 0 7
109508: ARRAY
109509: PPUSH
109510: LD_VAR 0 23
109514: PPUSH
109515: CALL_OW 113
109519: GO 109536
// ComHold ( group [ i ] ) ;
109521: LD_VAR 0 4
109525: PUSH
109526: LD_VAR 0 7
109530: ARRAY
109531: PPUSH
109532: CALL_OW 140
// continue ;
109536: GO 108380
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109538: LD_VAR 0 4
109542: PUSH
109543: LD_VAR 0 7
109547: ARRAY
109548: PPUSH
109549: LD_INT 10
109551: PPUSH
109552: CALL 47986 0 2
109556: NOT
109557: PUSH
109558: LD_VAR 0 16
109562: PUSH
109563: LD_VAR 0 7
109567: ARRAY
109568: PUSH
109569: EMPTY
109570: EQUAL
109571: NOT
109572: AND
109573: IFFALSE 109839
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109575: LD_VAR 0 4
109579: PUSH
109580: LD_VAR 0 7
109584: ARRAY
109585: PPUSH
109586: CALL_OW 262
109590: PUSH
109591: LD_INT 1
109593: PUSH
109594: LD_INT 2
109596: PUSH
109597: EMPTY
109598: LIST
109599: LIST
109600: IN
109601: IFFALSE 109642
// if GetFuel ( group [ i ] ) < 10 then
109603: LD_VAR 0 4
109607: PUSH
109608: LD_VAR 0 7
109612: ARRAY
109613: PPUSH
109614: CALL_OW 261
109618: PUSH
109619: LD_INT 10
109621: LESS
109622: IFFALSE 109642
// SetFuel ( group [ i ] , 12 ) ;
109624: LD_VAR 0 4
109628: PUSH
109629: LD_VAR 0 7
109633: ARRAY
109634: PPUSH
109635: LD_INT 12
109637: PPUSH
109638: CALL_OW 240
// if units_path [ i ] then
109642: LD_VAR 0 16
109646: PUSH
109647: LD_VAR 0 7
109651: ARRAY
109652: IFFALSE 109837
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109654: LD_VAR 0 4
109658: PUSH
109659: LD_VAR 0 7
109663: ARRAY
109664: PPUSH
109665: LD_VAR 0 16
109669: PUSH
109670: LD_VAR 0 7
109674: ARRAY
109675: PUSH
109676: LD_INT 1
109678: ARRAY
109679: PUSH
109680: LD_INT 1
109682: ARRAY
109683: PPUSH
109684: LD_VAR 0 16
109688: PUSH
109689: LD_VAR 0 7
109693: ARRAY
109694: PUSH
109695: LD_INT 1
109697: ARRAY
109698: PUSH
109699: LD_INT 2
109701: ARRAY
109702: PPUSH
109703: CALL_OW 297
109707: PUSH
109708: LD_INT 6
109710: GREATER
109711: IFFALSE 109786
// begin if not HasTask ( group [ i ] ) then
109713: LD_VAR 0 4
109717: PUSH
109718: LD_VAR 0 7
109722: ARRAY
109723: PPUSH
109724: CALL_OW 314
109728: NOT
109729: IFFALSE 109784
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109731: LD_VAR 0 4
109735: PUSH
109736: LD_VAR 0 7
109740: ARRAY
109741: PPUSH
109742: LD_VAR 0 16
109746: PUSH
109747: LD_VAR 0 7
109751: ARRAY
109752: PUSH
109753: LD_INT 1
109755: ARRAY
109756: PUSH
109757: LD_INT 1
109759: ARRAY
109760: PPUSH
109761: LD_VAR 0 16
109765: PUSH
109766: LD_VAR 0 7
109770: ARRAY
109771: PUSH
109772: LD_INT 1
109774: ARRAY
109775: PUSH
109776: LD_INT 2
109778: ARRAY
109779: PPUSH
109780: CALL_OW 114
// end else
109784: GO 109837
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109786: LD_ADDR_VAR 0 15
109790: PUSH
109791: LD_VAR 0 16
109795: PUSH
109796: LD_VAR 0 7
109800: ARRAY
109801: PPUSH
109802: LD_INT 1
109804: PPUSH
109805: CALL_OW 3
109809: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109810: LD_ADDR_VAR 0 16
109814: PUSH
109815: LD_VAR 0 16
109819: PPUSH
109820: LD_VAR 0 7
109824: PPUSH
109825: LD_VAR 0 15
109829: PPUSH
109830: CALL_OW 1
109834: ST_TO_ADDR
// continue ;
109835: GO 108380
// end ; end ; end else
109837: GO 112501
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109839: LD_ADDR_VAR 0 14
109843: PUSH
109844: LD_INT 81
109846: PUSH
109847: LD_VAR 0 4
109851: PUSH
109852: LD_VAR 0 7
109856: ARRAY
109857: PPUSH
109858: CALL_OW 255
109862: PUSH
109863: EMPTY
109864: LIST
109865: LIST
109866: PPUSH
109867: CALL_OW 69
109871: ST_TO_ADDR
// if not tmp then
109872: LD_VAR 0 14
109876: NOT
109877: IFFALSE 109881
// continue ;
109879: GO 108380
// if f_ignore_area then
109881: LD_VAR 0 17
109885: IFFALSE 109973
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109887: LD_ADDR_VAR 0 15
109891: PUSH
109892: LD_VAR 0 14
109896: PPUSH
109897: LD_INT 3
109899: PUSH
109900: LD_INT 92
109902: PUSH
109903: LD_VAR 0 17
109907: PUSH
109908: LD_INT 1
109910: ARRAY
109911: PUSH
109912: LD_VAR 0 17
109916: PUSH
109917: LD_INT 2
109919: ARRAY
109920: PUSH
109921: LD_VAR 0 17
109925: PUSH
109926: LD_INT 3
109928: ARRAY
109929: PUSH
109930: EMPTY
109931: LIST
109932: LIST
109933: LIST
109934: LIST
109935: PUSH
109936: EMPTY
109937: LIST
109938: LIST
109939: PPUSH
109940: CALL_OW 72
109944: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109945: LD_VAR 0 14
109949: PUSH
109950: LD_VAR 0 15
109954: DIFF
109955: IFFALSE 109973
// tmp := tmp diff tmp2 ;
109957: LD_ADDR_VAR 0 14
109961: PUSH
109962: LD_VAR 0 14
109966: PUSH
109967: LD_VAR 0 15
109971: DIFF
109972: ST_TO_ADDR
// end ; if not f_murder then
109973: LD_VAR 0 20
109977: NOT
109978: IFFALSE 110036
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109980: LD_ADDR_VAR 0 15
109984: PUSH
109985: LD_VAR 0 14
109989: PPUSH
109990: LD_INT 3
109992: PUSH
109993: LD_INT 50
109995: PUSH
109996: EMPTY
109997: LIST
109998: PUSH
109999: EMPTY
110000: LIST
110001: LIST
110002: PPUSH
110003: CALL_OW 72
110007: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
110008: LD_VAR 0 14
110012: PUSH
110013: LD_VAR 0 15
110017: DIFF
110018: IFFALSE 110036
// tmp := tmp diff tmp2 ;
110020: LD_ADDR_VAR 0 14
110024: PUSH
110025: LD_VAR 0 14
110029: PUSH
110030: LD_VAR 0 15
110034: DIFF
110035: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
110036: LD_ADDR_VAR 0 14
110040: PUSH
110041: LD_VAR 0 4
110045: PUSH
110046: LD_VAR 0 7
110050: ARRAY
110051: PPUSH
110052: LD_VAR 0 14
110056: PPUSH
110057: LD_INT 1
110059: PPUSH
110060: LD_INT 1
110062: PPUSH
110063: CALL 20898 0 4
110067: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110068: LD_VAR 0 4
110072: PUSH
110073: LD_VAR 0 7
110077: ARRAY
110078: PPUSH
110079: CALL_OW 257
110083: PUSH
110084: LD_INT 1
110086: EQUAL
110087: IFFALSE 110535
// begin if WantPlant ( group [ i ] ) then
110089: LD_VAR 0 4
110093: PUSH
110094: LD_VAR 0 7
110098: ARRAY
110099: PPUSH
110100: CALL 20399 0 1
110104: IFFALSE 110108
// continue ;
110106: GO 108380
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110108: LD_VAR 0 18
110112: PUSH
110113: LD_VAR 0 4
110117: PUSH
110118: LD_VAR 0 7
110122: ARRAY
110123: PPUSH
110124: CALL_OW 310
110128: NOT
110129: AND
110130: PUSH
110131: LD_VAR 0 14
110135: PUSH
110136: LD_INT 1
110138: ARRAY
110139: PUSH
110140: LD_VAR 0 14
110144: PPUSH
110145: LD_INT 21
110147: PUSH
110148: LD_INT 2
110150: PUSH
110151: EMPTY
110152: LIST
110153: LIST
110154: PUSH
110155: LD_INT 58
110157: PUSH
110158: EMPTY
110159: LIST
110160: PUSH
110161: EMPTY
110162: LIST
110163: LIST
110164: PPUSH
110165: CALL_OW 72
110169: IN
110170: AND
110171: IFFALSE 110207
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110173: LD_VAR 0 4
110177: PUSH
110178: LD_VAR 0 7
110182: ARRAY
110183: PPUSH
110184: LD_VAR 0 14
110188: PUSH
110189: LD_INT 1
110191: ARRAY
110192: PPUSH
110193: CALL_OW 120
// attacking := true ;
110197: LD_ADDR_VAR 0 29
110201: PUSH
110202: LD_INT 1
110204: ST_TO_ADDR
// continue ;
110205: GO 108380
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110207: LD_VAR 0 26
110211: PUSH
110212: LD_VAR 0 4
110216: PUSH
110217: LD_VAR 0 7
110221: ARRAY
110222: PPUSH
110223: CALL_OW 257
110227: PUSH
110228: LD_INT 1
110230: EQUAL
110231: AND
110232: PUSH
110233: LD_VAR 0 4
110237: PUSH
110238: LD_VAR 0 7
110242: ARRAY
110243: PPUSH
110244: CALL_OW 256
110248: PUSH
110249: LD_INT 800
110251: LESS
110252: AND
110253: PUSH
110254: LD_VAR 0 4
110258: PUSH
110259: LD_VAR 0 7
110263: ARRAY
110264: PPUSH
110265: CALL_OW 318
110269: NOT
110270: AND
110271: IFFALSE 110288
// ComCrawl ( group [ i ] ) ;
110273: LD_VAR 0 4
110277: PUSH
110278: LD_VAR 0 7
110282: ARRAY
110283: PPUSH
110284: CALL_OW 137
// if f_mines then
110288: LD_VAR 0 21
110292: IFFALSE 110535
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110294: LD_VAR 0 14
110298: PUSH
110299: LD_INT 1
110301: ARRAY
110302: PPUSH
110303: CALL_OW 247
110307: PUSH
110308: LD_INT 3
110310: EQUAL
110311: PUSH
110312: LD_VAR 0 14
110316: PUSH
110317: LD_INT 1
110319: ARRAY
110320: PUSH
110321: LD_VAR 0 27
110325: IN
110326: NOT
110327: AND
110328: IFFALSE 110535
// begin x := GetX ( tmp [ 1 ] ) ;
110330: LD_ADDR_VAR 0 10
110334: PUSH
110335: LD_VAR 0 14
110339: PUSH
110340: LD_INT 1
110342: ARRAY
110343: PPUSH
110344: CALL_OW 250
110348: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110349: LD_ADDR_VAR 0 11
110353: PUSH
110354: LD_VAR 0 14
110358: PUSH
110359: LD_INT 1
110361: ARRAY
110362: PPUSH
110363: CALL_OW 251
110367: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110368: LD_ADDR_VAR 0 12
110372: PUSH
110373: LD_VAR 0 4
110377: PUSH
110378: LD_VAR 0 7
110382: ARRAY
110383: PPUSH
110384: CALL 48071 0 1
110388: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110389: LD_VAR 0 4
110393: PUSH
110394: LD_VAR 0 7
110398: ARRAY
110399: PPUSH
110400: LD_VAR 0 10
110404: PPUSH
110405: LD_VAR 0 11
110409: PPUSH
110410: LD_VAR 0 14
110414: PUSH
110415: LD_INT 1
110417: ARRAY
110418: PPUSH
110419: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110423: LD_VAR 0 4
110427: PUSH
110428: LD_VAR 0 7
110432: ARRAY
110433: PPUSH
110434: LD_VAR 0 10
110438: PPUSH
110439: LD_VAR 0 12
110443: PPUSH
110444: LD_INT 7
110446: PPUSH
110447: CALL_OW 272
110451: PPUSH
110452: LD_VAR 0 11
110456: PPUSH
110457: LD_VAR 0 12
110461: PPUSH
110462: LD_INT 7
110464: PPUSH
110465: CALL_OW 273
110469: PPUSH
110470: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110474: LD_VAR 0 4
110478: PUSH
110479: LD_VAR 0 7
110483: ARRAY
110484: PPUSH
110485: LD_INT 71
110487: PPUSH
110488: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110492: LD_ADDR_VAR 0 27
110496: PUSH
110497: LD_VAR 0 27
110501: PPUSH
110502: LD_VAR 0 27
110506: PUSH
110507: LD_INT 1
110509: PLUS
110510: PPUSH
110511: LD_VAR 0 14
110515: PUSH
110516: LD_INT 1
110518: ARRAY
110519: PPUSH
110520: CALL_OW 1
110524: ST_TO_ADDR
// attacking := true ;
110525: LD_ADDR_VAR 0 29
110529: PUSH
110530: LD_INT 1
110532: ST_TO_ADDR
// continue ;
110533: GO 108380
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110535: LD_VAR 0 4
110539: PUSH
110540: LD_VAR 0 7
110544: ARRAY
110545: PPUSH
110546: CALL_OW 257
110550: PUSH
110551: LD_INT 17
110553: EQUAL
110554: PUSH
110555: LD_VAR 0 4
110559: PUSH
110560: LD_VAR 0 7
110564: ARRAY
110565: PPUSH
110566: CALL_OW 110
110570: PUSH
110571: LD_INT 71
110573: EQUAL
110574: NOT
110575: AND
110576: IFFALSE 110722
// begin attacking := false ;
110578: LD_ADDR_VAR 0 29
110582: PUSH
110583: LD_INT 0
110585: ST_TO_ADDR
// k := 5 ;
110586: LD_ADDR_VAR 0 9
110590: PUSH
110591: LD_INT 5
110593: ST_TO_ADDR
// if tmp < k then
110594: LD_VAR 0 14
110598: PUSH
110599: LD_VAR 0 9
110603: LESS
110604: IFFALSE 110616
// k := tmp ;
110606: LD_ADDR_VAR 0 9
110610: PUSH
110611: LD_VAR 0 14
110615: ST_TO_ADDR
// for j = 1 to k do
110616: LD_ADDR_VAR 0 8
110620: PUSH
110621: DOUBLE
110622: LD_INT 1
110624: DEC
110625: ST_TO_ADDR
110626: LD_VAR 0 9
110630: PUSH
110631: FOR_TO
110632: IFFALSE 110720
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110634: LD_VAR 0 14
110638: PUSH
110639: LD_VAR 0 8
110643: ARRAY
110644: PUSH
110645: LD_VAR 0 14
110649: PPUSH
110650: LD_INT 58
110652: PUSH
110653: EMPTY
110654: LIST
110655: PPUSH
110656: CALL_OW 72
110660: IN
110661: NOT
110662: IFFALSE 110718
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110664: LD_VAR 0 4
110668: PUSH
110669: LD_VAR 0 7
110673: ARRAY
110674: PPUSH
110675: LD_VAR 0 14
110679: PUSH
110680: LD_VAR 0 8
110684: ARRAY
110685: PPUSH
110686: CALL_OW 115
// attacking := true ;
110690: LD_ADDR_VAR 0 29
110694: PUSH
110695: LD_INT 1
110697: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110698: LD_VAR 0 4
110702: PUSH
110703: LD_VAR 0 7
110707: ARRAY
110708: PPUSH
110709: LD_INT 71
110711: PPUSH
110712: CALL_OW 109
// continue ;
110716: GO 110631
// end ; end ;
110718: GO 110631
110720: POP
110721: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110722: LD_VAR 0 4
110726: PUSH
110727: LD_VAR 0 7
110731: ARRAY
110732: PPUSH
110733: CALL_OW 257
110737: PUSH
110738: LD_INT 8
110740: EQUAL
110741: PUSH
110742: LD_VAR 0 4
110746: PUSH
110747: LD_VAR 0 7
110751: ARRAY
110752: PPUSH
110753: CALL_OW 264
110757: PUSH
110758: LD_INT 28
110760: PUSH
110761: LD_INT 45
110763: PUSH
110764: LD_INT 7
110766: PUSH
110767: LD_INT 47
110769: PUSH
110770: EMPTY
110771: LIST
110772: LIST
110773: LIST
110774: LIST
110775: IN
110776: OR
110777: IFFALSE 111033
// begin attacking := false ;
110779: LD_ADDR_VAR 0 29
110783: PUSH
110784: LD_INT 0
110786: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110787: LD_VAR 0 14
110791: PUSH
110792: LD_INT 1
110794: ARRAY
110795: PPUSH
110796: CALL_OW 266
110800: PUSH
110801: LD_INT 32
110803: PUSH
110804: LD_INT 31
110806: PUSH
110807: LD_INT 33
110809: PUSH
110810: LD_INT 4
110812: PUSH
110813: LD_INT 5
110815: PUSH
110816: EMPTY
110817: LIST
110818: LIST
110819: LIST
110820: LIST
110821: LIST
110822: IN
110823: IFFALSE 111009
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110825: LD_ADDR_VAR 0 9
110829: PUSH
110830: LD_VAR 0 14
110834: PUSH
110835: LD_INT 1
110837: ARRAY
110838: PPUSH
110839: CALL_OW 266
110843: PPUSH
110844: LD_VAR 0 14
110848: PUSH
110849: LD_INT 1
110851: ARRAY
110852: PPUSH
110853: CALL_OW 250
110857: PPUSH
110858: LD_VAR 0 14
110862: PUSH
110863: LD_INT 1
110865: ARRAY
110866: PPUSH
110867: CALL_OW 251
110871: PPUSH
110872: LD_VAR 0 14
110876: PUSH
110877: LD_INT 1
110879: ARRAY
110880: PPUSH
110881: CALL_OW 254
110885: PPUSH
110886: LD_VAR 0 14
110890: PUSH
110891: LD_INT 1
110893: ARRAY
110894: PPUSH
110895: CALL_OW 248
110899: PPUSH
110900: LD_INT 0
110902: PPUSH
110903: CALL 29441 0 6
110907: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110908: LD_ADDR_VAR 0 8
110912: PUSH
110913: LD_VAR 0 4
110917: PUSH
110918: LD_VAR 0 7
110922: ARRAY
110923: PPUSH
110924: LD_VAR 0 9
110928: PPUSH
110929: CALL 48184 0 2
110933: ST_TO_ADDR
// if j then
110934: LD_VAR 0 8
110938: IFFALSE 111007
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110940: LD_VAR 0 8
110944: PUSH
110945: LD_INT 1
110947: ARRAY
110948: PPUSH
110949: LD_VAR 0 8
110953: PUSH
110954: LD_INT 2
110956: ARRAY
110957: PPUSH
110958: CALL_OW 488
110962: IFFALSE 111007
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110964: LD_VAR 0 4
110968: PUSH
110969: LD_VAR 0 7
110973: ARRAY
110974: PPUSH
110975: LD_VAR 0 8
110979: PUSH
110980: LD_INT 1
110982: ARRAY
110983: PPUSH
110984: LD_VAR 0 8
110988: PUSH
110989: LD_INT 2
110991: ARRAY
110992: PPUSH
110993: CALL_OW 116
// attacking := true ;
110997: LD_ADDR_VAR 0 29
111001: PUSH
111002: LD_INT 1
111004: ST_TO_ADDR
// continue ;
111005: GO 108380
// end ; end else
111007: GO 111033
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111009: LD_VAR 0 4
111013: PUSH
111014: LD_VAR 0 7
111018: ARRAY
111019: PPUSH
111020: LD_VAR 0 14
111024: PUSH
111025: LD_INT 1
111027: ARRAY
111028: PPUSH
111029: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
111033: LD_VAR 0 4
111037: PUSH
111038: LD_VAR 0 7
111042: ARRAY
111043: PPUSH
111044: CALL_OW 265
111048: PUSH
111049: LD_INT 11
111051: EQUAL
111052: IFFALSE 111330
// begin k := 10 ;
111054: LD_ADDR_VAR 0 9
111058: PUSH
111059: LD_INT 10
111061: ST_TO_ADDR
// x := 0 ;
111062: LD_ADDR_VAR 0 10
111066: PUSH
111067: LD_INT 0
111069: ST_TO_ADDR
// if tmp < k then
111070: LD_VAR 0 14
111074: PUSH
111075: LD_VAR 0 9
111079: LESS
111080: IFFALSE 111092
// k := tmp ;
111082: LD_ADDR_VAR 0 9
111086: PUSH
111087: LD_VAR 0 14
111091: ST_TO_ADDR
// for j = k downto 1 do
111092: LD_ADDR_VAR 0 8
111096: PUSH
111097: DOUBLE
111098: LD_VAR 0 9
111102: INC
111103: ST_TO_ADDR
111104: LD_INT 1
111106: PUSH
111107: FOR_DOWNTO
111108: IFFALSE 111183
// begin if GetType ( tmp [ j ] ) = unit_human then
111110: LD_VAR 0 14
111114: PUSH
111115: LD_VAR 0 8
111119: ARRAY
111120: PPUSH
111121: CALL_OW 247
111125: PUSH
111126: LD_INT 1
111128: EQUAL
111129: IFFALSE 111181
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111131: LD_VAR 0 4
111135: PUSH
111136: LD_VAR 0 7
111140: ARRAY
111141: PPUSH
111142: LD_VAR 0 14
111146: PUSH
111147: LD_VAR 0 8
111151: ARRAY
111152: PPUSH
111153: CALL 48438 0 2
// x := tmp [ j ] ;
111157: LD_ADDR_VAR 0 10
111161: PUSH
111162: LD_VAR 0 14
111166: PUSH
111167: LD_VAR 0 8
111171: ARRAY
111172: ST_TO_ADDR
// attacking := true ;
111173: LD_ADDR_VAR 0 29
111177: PUSH
111178: LD_INT 1
111180: ST_TO_ADDR
// end ; end ;
111181: GO 111107
111183: POP
111184: POP
// if not x then
111185: LD_VAR 0 10
111189: NOT
111190: IFFALSE 111330
// begin attacking := true ;
111192: LD_ADDR_VAR 0 29
111196: PUSH
111197: LD_INT 1
111199: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111200: LD_VAR 0 4
111204: PUSH
111205: LD_VAR 0 7
111209: ARRAY
111210: PPUSH
111211: CALL_OW 250
111215: PPUSH
111216: LD_VAR 0 4
111220: PUSH
111221: LD_VAR 0 7
111225: ARRAY
111226: PPUSH
111227: CALL_OW 251
111231: PPUSH
111232: CALL_OW 546
111236: PUSH
111237: LD_INT 2
111239: ARRAY
111240: PUSH
111241: LD_VAR 0 14
111245: PUSH
111246: LD_INT 1
111248: ARRAY
111249: PPUSH
111250: CALL_OW 250
111254: PPUSH
111255: LD_VAR 0 14
111259: PUSH
111260: LD_INT 1
111262: ARRAY
111263: PPUSH
111264: CALL_OW 251
111268: PPUSH
111269: CALL_OW 546
111273: PUSH
111274: LD_INT 2
111276: ARRAY
111277: EQUAL
111278: IFFALSE 111306
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111280: LD_VAR 0 4
111284: PUSH
111285: LD_VAR 0 7
111289: ARRAY
111290: PPUSH
111291: LD_VAR 0 14
111295: PUSH
111296: LD_INT 1
111298: ARRAY
111299: PPUSH
111300: CALL 48438 0 2
111304: GO 111330
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111306: LD_VAR 0 4
111310: PUSH
111311: LD_VAR 0 7
111315: ARRAY
111316: PPUSH
111317: LD_VAR 0 14
111321: PUSH
111322: LD_INT 1
111324: ARRAY
111325: PPUSH
111326: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111330: LD_VAR 0 4
111334: PUSH
111335: LD_VAR 0 7
111339: ARRAY
111340: PPUSH
111341: CALL_OW 264
111345: PUSH
111346: LD_INT 29
111348: EQUAL
111349: IFFALSE 111715
// begin if WantsToAttack ( group [ i ] ) in bombed then
111351: LD_VAR 0 4
111355: PUSH
111356: LD_VAR 0 7
111360: ARRAY
111361: PPUSH
111362: CALL_OW 319
111366: PUSH
111367: LD_VAR 0 28
111371: IN
111372: IFFALSE 111376
// continue ;
111374: GO 108380
// k := 8 ;
111376: LD_ADDR_VAR 0 9
111380: PUSH
111381: LD_INT 8
111383: ST_TO_ADDR
// x := 0 ;
111384: LD_ADDR_VAR 0 10
111388: PUSH
111389: LD_INT 0
111391: ST_TO_ADDR
// if tmp < k then
111392: LD_VAR 0 14
111396: PUSH
111397: LD_VAR 0 9
111401: LESS
111402: IFFALSE 111414
// k := tmp ;
111404: LD_ADDR_VAR 0 9
111408: PUSH
111409: LD_VAR 0 14
111413: ST_TO_ADDR
// for j = 1 to k do
111414: LD_ADDR_VAR 0 8
111418: PUSH
111419: DOUBLE
111420: LD_INT 1
111422: DEC
111423: ST_TO_ADDR
111424: LD_VAR 0 9
111428: PUSH
111429: FOR_TO
111430: IFFALSE 111562
// begin if GetType ( tmp [ j ] ) = unit_building then
111432: LD_VAR 0 14
111436: PUSH
111437: LD_VAR 0 8
111441: ARRAY
111442: PPUSH
111443: CALL_OW 247
111447: PUSH
111448: LD_INT 3
111450: EQUAL
111451: IFFALSE 111560
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111453: LD_VAR 0 14
111457: PUSH
111458: LD_VAR 0 8
111462: ARRAY
111463: PUSH
111464: LD_VAR 0 28
111468: IN
111469: NOT
111470: PUSH
111471: LD_VAR 0 14
111475: PUSH
111476: LD_VAR 0 8
111480: ARRAY
111481: PPUSH
111482: CALL_OW 313
111486: AND
111487: IFFALSE 111560
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111489: LD_VAR 0 4
111493: PUSH
111494: LD_VAR 0 7
111498: ARRAY
111499: PPUSH
111500: LD_VAR 0 14
111504: PUSH
111505: LD_VAR 0 8
111509: ARRAY
111510: PPUSH
111511: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111515: LD_ADDR_VAR 0 28
111519: PUSH
111520: LD_VAR 0 28
111524: PPUSH
111525: LD_VAR 0 28
111529: PUSH
111530: LD_INT 1
111532: PLUS
111533: PPUSH
111534: LD_VAR 0 14
111538: PUSH
111539: LD_VAR 0 8
111543: ARRAY
111544: PPUSH
111545: CALL_OW 1
111549: ST_TO_ADDR
// attacking := true ;
111550: LD_ADDR_VAR 0 29
111554: PUSH
111555: LD_INT 1
111557: ST_TO_ADDR
// break ;
111558: GO 111562
// end ; end ;
111560: GO 111429
111562: POP
111563: POP
// if not attacking and f_attack_depot then
111564: LD_VAR 0 29
111568: NOT
111569: PUSH
111570: LD_VAR 0 25
111574: AND
111575: IFFALSE 111670
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111577: LD_ADDR_VAR 0 13
111581: PUSH
111582: LD_VAR 0 14
111586: PPUSH
111587: LD_INT 2
111589: PUSH
111590: LD_INT 30
111592: PUSH
111593: LD_INT 0
111595: PUSH
111596: EMPTY
111597: LIST
111598: LIST
111599: PUSH
111600: LD_INT 30
111602: PUSH
111603: LD_INT 1
111605: PUSH
111606: EMPTY
111607: LIST
111608: LIST
111609: PUSH
111610: EMPTY
111611: LIST
111612: LIST
111613: LIST
111614: PPUSH
111615: CALL_OW 72
111619: ST_TO_ADDR
// if z then
111620: LD_VAR 0 13
111624: IFFALSE 111670
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111626: LD_VAR 0 4
111630: PUSH
111631: LD_VAR 0 7
111635: ARRAY
111636: PPUSH
111637: LD_VAR 0 13
111641: PPUSH
111642: LD_VAR 0 4
111646: PUSH
111647: LD_VAR 0 7
111651: ARRAY
111652: PPUSH
111653: CALL_OW 74
111657: PPUSH
111658: CALL_OW 115
// attacking := true ;
111662: LD_ADDR_VAR 0 29
111666: PUSH
111667: LD_INT 1
111669: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111670: LD_VAR 0 4
111674: PUSH
111675: LD_VAR 0 7
111679: ARRAY
111680: PPUSH
111681: CALL_OW 256
111685: PUSH
111686: LD_INT 500
111688: LESS
111689: IFFALSE 111715
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111691: LD_VAR 0 4
111695: PUSH
111696: LD_VAR 0 7
111700: ARRAY
111701: PPUSH
111702: LD_VAR 0 14
111706: PUSH
111707: LD_INT 1
111709: ARRAY
111710: PPUSH
111711: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111715: LD_VAR 0 4
111719: PUSH
111720: LD_VAR 0 7
111724: ARRAY
111725: PPUSH
111726: CALL_OW 264
111730: PUSH
111731: LD_INT 49
111733: EQUAL
111734: IFFALSE 111855
// begin if not HasTask ( group [ i ] ) then
111736: LD_VAR 0 4
111740: PUSH
111741: LD_VAR 0 7
111745: ARRAY
111746: PPUSH
111747: CALL_OW 314
111751: NOT
111752: IFFALSE 111855
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111754: LD_ADDR_VAR 0 9
111758: PUSH
111759: LD_INT 81
111761: PUSH
111762: LD_VAR 0 4
111766: PUSH
111767: LD_VAR 0 7
111771: ARRAY
111772: PPUSH
111773: CALL_OW 255
111777: PUSH
111778: EMPTY
111779: LIST
111780: LIST
111781: PPUSH
111782: CALL_OW 69
111786: PPUSH
111787: LD_VAR 0 4
111791: PUSH
111792: LD_VAR 0 7
111796: ARRAY
111797: PPUSH
111798: CALL_OW 74
111802: ST_TO_ADDR
// if k then
111803: LD_VAR 0 9
111807: IFFALSE 111855
// if GetDistUnits ( group [ i ] , k ) > 10 then
111809: LD_VAR 0 4
111813: PUSH
111814: LD_VAR 0 7
111818: ARRAY
111819: PPUSH
111820: LD_VAR 0 9
111824: PPUSH
111825: CALL_OW 296
111829: PUSH
111830: LD_INT 10
111832: GREATER
111833: IFFALSE 111855
// ComMoveUnit ( group [ i ] , k ) ;
111835: LD_VAR 0 4
111839: PUSH
111840: LD_VAR 0 7
111844: ARRAY
111845: PPUSH
111846: LD_VAR 0 9
111850: PPUSH
111851: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111855: LD_VAR 0 4
111859: PUSH
111860: LD_VAR 0 7
111864: ARRAY
111865: PPUSH
111866: CALL_OW 256
111870: PUSH
111871: LD_INT 250
111873: LESS
111874: PUSH
111875: LD_VAR 0 4
111879: PUSH
111880: LD_VAR 0 7
111884: ARRAY
111885: PUSH
111886: LD_INT 21
111888: PUSH
111889: LD_INT 2
111891: PUSH
111892: EMPTY
111893: LIST
111894: LIST
111895: PUSH
111896: LD_INT 23
111898: PUSH
111899: LD_INT 2
111901: PUSH
111902: EMPTY
111903: LIST
111904: LIST
111905: PUSH
111906: EMPTY
111907: LIST
111908: LIST
111909: PPUSH
111910: CALL_OW 69
111914: IN
111915: AND
111916: IFFALSE 112041
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111918: LD_ADDR_VAR 0 9
111922: PUSH
111923: LD_OWVAR 3
111927: PUSH
111928: LD_VAR 0 4
111932: PUSH
111933: LD_VAR 0 7
111937: ARRAY
111938: DIFF
111939: PPUSH
111940: LD_VAR 0 4
111944: PUSH
111945: LD_VAR 0 7
111949: ARRAY
111950: PPUSH
111951: CALL_OW 74
111955: ST_TO_ADDR
// if not k then
111956: LD_VAR 0 9
111960: NOT
111961: IFFALSE 111965
// continue ;
111963: GO 108380
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111965: LD_VAR 0 9
111969: PUSH
111970: LD_INT 81
111972: PUSH
111973: LD_VAR 0 4
111977: PUSH
111978: LD_VAR 0 7
111982: ARRAY
111983: PPUSH
111984: CALL_OW 255
111988: PUSH
111989: EMPTY
111990: LIST
111991: LIST
111992: PPUSH
111993: CALL_OW 69
111997: IN
111998: PUSH
111999: LD_VAR 0 9
112003: PPUSH
112004: LD_VAR 0 4
112008: PUSH
112009: LD_VAR 0 7
112013: ARRAY
112014: PPUSH
112015: CALL_OW 296
112019: PUSH
112020: LD_INT 5
112022: LESS
112023: AND
112024: IFFALSE 112041
// ComAutodestruct ( group [ i ] ) ;
112026: LD_VAR 0 4
112030: PUSH
112031: LD_VAR 0 7
112035: ARRAY
112036: PPUSH
112037: CALL 48336 0 1
// end ; if f_attack_depot then
112041: LD_VAR 0 25
112045: IFFALSE 112157
// begin k := 6 ;
112047: LD_ADDR_VAR 0 9
112051: PUSH
112052: LD_INT 6
112054: ST_TO_ADDR
// if tmp < k then
112055: LD_VAR 0 14
112059: PUSH
112060: LD_VAR 0 9
112064: LESS
112065: IFFALSE 112077
// k := tmp ;
112067: LD_ADDR_VAR 0 9
112071: PUSH
112072: LD_VAR 0 14
112076: ST_TO_ADDR
// for j = 1 to k do
112077: LD_ADDR_VAR 0 8
112081: PUSH
112082: DOUBLE
112083: LD_INT 1
112085: DEC
112086: ST_TO_ADDR
112087: LD_VAR 0 9
112091: PUSH
112092: FOR_TO
112093: IFFALSE 112155
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112095: LD_VAR 0 8
112099: PPUSH
112100: CALL_OW 266
112104: PUSH
112105: LD_INT 0
112107: PUSH
112108: LD_INT 1
112110: PUSH
112111: EMPTY
112112: LIST
112113: LIST
112114: IN
112115: IFFALSE 112153
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112117: LD_VAR 0 4
112121: PUSH
112122: LD_VAR 0 7
112126: ARRAY
112127: PPUSH
112128: LD_VAR 0 14
112132: PUSH
112133: LD_VAR 0 8
112137: ARRAY
112138: PPUSH
112139: CALL_OW 115
// attacking := true ;
112143: LD_ADDR_VAR 0 29
112147: PUSH
112148: LD_INT 1
112150: ST_TO_ADDR
// break ;
112151: GO 112155
// end ;
112153: GO 112092
112155: POP
112156: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112157: LD_VAR 0 4
112161: PUSH
112162: LD_VAR 0 7
112166: ARRAY
112167: PPUSH
112168: CALL_OW 302
112172: PUSH
112173: LD_VAR 0 29
112177: NOT
112178: AND
112179: IFFALSE 112501
// begin if GetTag ( group [ i ] ) = 71 then
112181: LD_VAR 0 4
112185: PUSH
112186: LD_VAR 0 7
112190: ARRAY
112191: PPUSH
112192: CALL_OW 110
112196: PUSH
112197: LD_INT 71
112199: EQUAL
112200: IFFALSE 112241
// begin if HasTask ( group [ i ] ) then
112202: LD_VAR 0 4
112206: PUSH
112207: LD_VAR 0 7
112211: ARRAY
112212: PPUSH
112213: CALL_OW 314
112217: IFFALSE 112223
// continue else
112219: GO 108380
112221: GO 112241
// SetTag ( group [ i ] , 0 ) ;
112223: LD_VAR 0 4
112227: PUSH
112228: LD_VAR 0 7
112232: ARRAY
112233: PPUSH
112234: LD_INT 0
112236: PPUSH
112237: CALL_OW 109
// end ; k := 8 ;
112241: LD_ADDR_VAR 0 9
112245: PUSH
112246: LD_INT 8
112248: ST_TO_ADDR
// x := 0 ;
112249: LD_ADDR_VAR 0 10
112253: PUSH
112254: LD_INT 0
112256: ST_TO_ADDR
// if tmp < k then
112257: LD_VAR 0 14
112261: PUSH
112262: LD_VAR 0 9
112266: LESS
112267: IFFALSE 112279
// k := tmp ;
112269: LD_ADDR_VAR 0 9
112273: PUSH
112274: LD_VAR 0 14
112278: ST_TO_ADDR
// for j = 1 to k do
112279: LD_ADDR_VAR 0 8
112283: PUSH
112284: DOUBLE
112285: LD_INT 1
112287: DEC
112288: ST_TO_ADDR
112289: LD_VAR 0 9
112293: PUSH
112294: FOR_TO
112295: IFFALSE 112393
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112297: LD_VAR 0 14
112301: PUSH
112302: LD_VAR 0 8
112306: ARRAY
112307: PPUSH
112308: CALL_OW 247
112312: PUSH
112313: LD_INT 1
112315: EQUAL
112316: PUSH
112317: LD_VAR 0 14
112321: PUSH
112322: LD_VAR 0 8
112326: ARRAY
112327: PPUSH
112328: CALL_OW 256
112332: PUSH
112333: LD_INT 250
112335: LESS
112336: PUSH
112337: LD_VAR 0 20
112341: AND
112342: PUSH
112343: LD_VAR 0 20
112347: NOT
112348: PUSH
112349: LD_VAR 0 14
112353: PUSH
112354: LD_VAR 0 8
112358: ARRAY
112359: PPUSH
112360: CALL_OW 256
112364: PUSH
112365: LD_INT 250
112367: GREATEREQUAL
112368: AND
112369: OR
112370: AND
112371: IFFALSE 112391
// begin x := tmp [ j ] ;
112373: LD_ADDR_VAR 0 10
112377: PUSH
112378: LD_VAR 0 14
112382: PUSH
112383: LD_VAR 0 8
112387: ARRAY
112388: ST_TO_ADDR
// break ;
112389: GO 112393
// end ;
112391: GO 112294
112393: POP
112394: POP
// if x then
112395: LD_VAR 0 10
112399: IFFALSE 112423
// ComAttackUnit ( group [ i ] , x ) else
112401: LD_VAR 0 4
112405: PUSH
112406: LD_VAR 0 7
112410: ARRAY
112411: PPUSH
112412: LD_VAR 0 10
112416: PPUSH
112417: CALL_OW 115
112421: GO 112447
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112423: LD_VAR 0 4
112427: PUSH
112428: LD_VAR 0 7
112432: ARRAY
112433: PPUSH
112434: LD_VAR 0 14
112438: PUSH
112439: LD_INT 1
112441: ARRAY
112442: PPUSH
112443: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112447: LD_VAR 0 4
112451: PUSH
112452: LD_VAR 0 7
112456: ARRAY
112457: PPUSH
112458: CALL_OW 314
112462: NOT
112463: IFFALSE 112501
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112465: LD_VAR 0 4
112469: PUSH
112470: LD_VAR 0 7
112474: ARRAY
112475: PPUSH
112476: LD_VAR 0 14
112480: PPUSH
112481: LD_VAR 0 4
112485: PUSH
112486: LD_VAR 0 7
112490: ARRAY
112491: PPUSH
112492: CALL_OW 74
112496: PPUSH
112497: CALL_OW 115
// end ; end ; end ;
112501: GO 108380
112503: POP
112504: POP
// wait ( 0 0$2 ) ;
112505: LD_INT 70
112507: PPUSH
112508: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112512: LD_VAR 0 4
112516: NOT
112517: PUSH
112518: LD_VAR 0 4
112522: PUSH
112523: EMPTY
112524: EQUAL
112525: OR
112526: PUSH
112527: LD_INT 81
112529: PUSH
112530: LD_VAR 0 35
112534: PUSH
112535: EMPTY
112536: LIST
112537: LIST
112538: PPUSH
112539: CALL_OW 69
112543: NOT
112544: OR
112545: IFFALSE 108365
// end ;
112547: LD_VAR 0 2
112551: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112552: LD_INT 0
112554: PPUSH
112555: PPUSH
112556: PPUSH
112557: PPUSH
112558: PPUSH
112559: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112560: LD_VAR 0 1
112564: NOT
112565: PUSH
112566: LD_EXP 61
112570: PUSH
112571: LD_VAR 0 1
112575: ARRAY
112576: NOT
112577: OR
112578: PUSH
112579: LD_VAR 0 2
112583: NOT
112584: OR
112585: IFFALSE 112589
// exit ;
112587: GO 113143
// side := mc_sides [ base ] ;
112589: LD_ADDR_VAR 0 6
112593: PUSH
112594: LD_EXP 87
112598: PUSH
112599: LD_VAR 0 1
112603: ARRAY
112604: ST_TO_ADDR
// if not side then
112605: LD_VAR 0 6
112609: NOT
112610: IFFALSE 112614
// exit ;
112612: GO 113143
// for i in solds do
112614: LD_ADDR_VAR 0 7
112618: PUSH
112619: LD_VAR 0 2
112623: PUSH
112624: FOR_IN
112625: IFFALSE 112686
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112627: LD_VAR 0 7
112631: PPUSH
112632: CALL_OW 310
112636: PPUSH
112637: CALL_OW 266
112641: PUSH
112642: LD_INT 32
112644: PUSH
112645: LD_INT 31
112647: PUSH
112648: EMPTY
112649: LIST
112650: LIST
112651: IN
112652: IFFALSE 112672
// solds := solds diff i else
112654: LD_ADDR_VAR 0 2
112658: PUSH
112659: LD_VAR 0 2
112663: PUSH
112664: LD_VAR 0 7
112668: DIFF
112669: ST_TO_ADDR
112670: GO 112684
// SetTag ( i , 18 ) ;
112672: LD_VAR 0 7
112676: PPUSH
112677: LD_INT 18
112679: PPUSH
112680: CALL_OW 109
112684: GO 112624
112686: POP
112687: POP
// if not solds then
112688: LD_VAR 0 2
112692: NOT
112693: IFFALSE 112697
// exit ;
112695: GO 113143
// repeat wait ( 0 0$2 ) ;
112697: LD_INT 70
112699: PPUSH
112700: CALL_OW 67
// enemy := mc_scan [ base ] ;
112704: LD_ADDR_VAR 0 4
112708: PUSH
112709: LD_EXP 84
112713: PUSH
112714: LD_VAR 0 1
112718: ARRAY
112719: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112720: LD_EXP 61
112724: PUSH
112725: LD_VAR 0 1
112729: ARRAY
112730: NOT
112731: PUSH
112732: LD_EXP 61
112736: PUSH
112737: LD_VAR 0 1
112741: ARRAY
112742: PUSH
112743: EMPTY
112744: EQUAL
112745: OR
112746: IFFALSE 112783
// begin for i in solds do
112748: LD_ADDR_VAR 0 7
112752: PUSH
112753: LD_VAR 0 2
112757: PUSH
112758: FOR_IN
112759: IFFALSE 112772
// ComStop ( i ) ;
112761: LD_VAR 0 7
112765: PPUSH
112766: CALL_OW 141
112770: GO 112758
112772: POP
112773: POP
// solds := [ ] ;
112774: LD_ADDR_VAR 0 2
112778: PUSH
112779: EMPTY
112780: ST_TO_ADDR
// exit ;
112781: GO 113143
// end ; for i in solds do
112783: LD_ADDR_VAR 0 7
112787: PUSH
112788: LD_VAR 0 2
112792: PUSH
112793: FOR_IN
112794: IFFALSE 113115
// begin if IsInUnit ( i ) then
112796: LD_VAR 0 7
112800: PPUSH
112801: CALL_OW 310
112805: IFFALSE 112816
// ComExitBuilding ( i ) ;
112807: LD_VAR 0 7
112811: PPUSH
112812: CALL_OW 122
// if GetLives ( i ) > 500 then
112816: LD_VAR 0 7
112820: PPUSH
112821: CALL_OW 256
112825: PUSH
112826: LD_INT 500
112828: GREATER
112829: IFFALSE 112882
// begin e := NearestUnitToUnit ( enemy , i ) ;
112831: LD_ADDR_VAR 0 5
112835: PUSH
112836: LD_VAR 0 4
112840: PPUSH
112841: LD_VAR 0 7
112845: PPUSH
112846: CALL_OW 74
112850: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112851: LD_VAR 0 7
112855: PPUSH
112856: LD_VAR 0 5
112860: PPUSH
112861: CALL_OW 250
112865: PPUSH
112866: LD_VAR 0 5
112870: PPUSH
112871: CALL_OW 251
112875: PPUSH
112876: CALL_OW 114
// end else
112880: GO 113113
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112882: LD_VAR 0 7
112886: PPUSH
112887: LD_EXP 61
112891: PUSH
112892: LD_VAR 0 1
112896: ARRAY
112897: PPUSH
112898: LD_INT 2
112900: PUSH
112901: LD_INT 30
112903: PUSH
112904: LD_INT 0
112906: PUSH
112907: EMPTY
112908: LIST
112909: LIST
112910: PUSH
112911: LD_INT 30
112913: PUSH
112914: LD_INT 1
112916: PUSH
112917: EMPTY
112918: LIST
112919: LIST
112920: PUSH
112921: LD_INT 30
112923: PUSH
112924: LD_INT 6
112926: PUSH
112927: EMPTY
112928: LIST
112929: LIST
112930: PUSH
112931: EMPTY
112932: LIST
112933: LIST
112934: LIST
112935: LIST
112936: PPUSH
112937: CALL_OW 72
112941: PPUSH
112942: LD_VAR 0 7
112946: PPUSH
112947: CALL_OW 74
112951: PPUSH
112952: CALL_OW 296
112956: PUSH
112957: LD_INT 10
112959: GREATER
112960: IFFALSE 113113
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112962: LD_ADDR_VAR 0 8
112966: PUSH
112967: LD_EXP 61
112971: PUSH
112972: LD_VAR 0 1
112976: ARRAY
112977: PPUSH
112978: LD_INT 2
112980: PUSH
112981: LD_INT 30
112983: PUSH
112984: LD_INT 0
112986: PUSH
112987: EMPTY
112988: LIST
112989: LIST
112990: PUSH
112991: LD_INT 30
112993: PUSH
112994: LD_INT 1
112996: PUSH
112997: EMPTY
112998: LIST
112999: LIST
113000: PUSH
113001: LD_INT 30
113003: PUSH
113004: LD_INT 6
113006: PUSH
113007: EMPTY
113008: LIST
113009: LIST
113010: PUSH
113011: EMPTY
113012: LIST
113013: LIST
113014: LIST
113015: LIST
113016: PPUSH
113017: CALL_OW 72
113021: PPUSH
113022: LD_VAR 0 7
113026: PPUSH
113027: CALL_OW 74
113031: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
113032: LD_VAR 0 7
113036: PPUSH
113037: LD_VAR 0 8
113041: PPUSH
113042: CALL_OW 250
113046: PPUSH
113047: LD_INT 3
113049: PPUSH
113050: LD_INT 5
113052: PPUSH
113053: CALL_OW 272
113057: PPUSH
113058: LD_VAR 0 8
113062: PPUSH
113063: CALL_OW 251
113067: PPUSH
113068: LD_INT 3
113070: PPUSH
113071: LD_INT 5
113073: PPUSH
113074: CALL_OW 273
113078: PPUSH
113079: CALL_OW 111
// SetTag ( i , 0 ) ;
113083: LD_VAR 0 7
113087: PPUSH
113088: LD_INT 0
113090: PPUSH
113091: CALL_OW 109
// solds := solds diff i ;
113095: LD_ADDR_VAR 0 2
113099: PUSH
113100: LD_VAR 0 2
113104: PUSH
113105: LD_VAR 0 7
113109: DIFF
113110: ST_TO_ADDR
// continue ;
113111: GO 112793
// end ; end ;
113113: GO 112793
113115: POP
113116: POP
// until not solds or not enemy ;
113117: LD_VAR 0 2
113121: NOT
113122: PUSH
113123: LD_VAR 0 4
113127: NOT
113128: OR
113129: IFFALSE 112697
// MC_Reset ( base , 18 ) ;
113131: LD_VAR 0 1
113135: PPUSH
113136: LD_INT 18
113138: PPUSH
113139: CALL 61213 0 2
// end ;
113143: LD_VAR 0 3
113147: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113148: LD_INT 0
113150: PPUSH
113151: PPUSH
113152: PPUSH
113153: PPUSH
113154: PPUSH
113155: PPUSH
113156: PPUSH
113157: PPUSH
113158: PPUSH
113159: PPUSH
113160: PPUSH
113161: PPUSH
113162: PPUSH
113163: PPUSH
113164: PPUSH
113165: PPUSH
113166: PPUSH
113167: PPUSH
113168: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113169: LD_ADDR_VAR 0 12
113173: PUSH
113174: LD_EXP 61
113178: PUSH
113179: LD_VAR 0 1
113183: ARRAY
113184: PPUSH
113185: LD_INT 25
113187: PUSH
113188: LD_INT 3
113190: PUSH
113191: EMPTY
113192: LIST
113193: LIST
113194: PPUSH
113195: CALL_OW 72
113199: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113200: LD_EXP 101
113204: PUSH
113205: LD_VAR 0 1
113209: ARRAY
113210: IFFALSE 113234
// mechs := mechs diff mc_remote_driver [ base ] ;
113212: LD_ADDR_VAR 0 12
113216: PUSH
113217: LD_VAR 0 12
113221: PUSH
113222: LD_EXP 101
113226: PUSH
113227: LD_VAR 0 1
113231: ARRAY
113232: DIFF
113233: ST_TO_ADDR
// for i in mechs do
113234: LD_ADDR_VAR 0 4
113238: PUSH
113239: LD_VAR 0 12
113243: PUSH
113244: FOR_IN
113245: IFFALSE 113280
// if GetTag ( i ) > 0 then
113247: LD_VAR 0 4
113251: PPUSH
113252: CALL_OW 110
113256: PUSH
113257: LD_INT 0
113259: GREATER
113260: IFFALSE 113278
// mechs := mechs diff i ;
113262: LD_ADDR_VAR 0 12
113266: PUSH
113267: LD_VAR 0 12
113271: PUSH
113272: LD_VAR 0 4
113276: DIFF
113277: ST_TO_ADDR
113278: GO 113244
113280: POP
113281: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113282: LD_ADDR_VAR 0 8
113286: PUSH
113287: LD_EXP 61
113291: PUSH
113292: LD_VAR 0 1
113296: ARRAY
113297: PPUSH
113298: LD_INT 2
113300: PUSH
113301: LD_INT 25
113303: PUSH
113304: LD_INT 1
113306: PUSH
113307: EMPTY
113308: LIST
113309: LIST
113310: PUSH
113311: LD_INT 25
113313: PUSH
113314: LD_INT 5
113316: PUSH
113317: EMPTY
113318: LIST
113319: LIST
113320: PUSH
113321: LD_INT 25
113323: PUSH
113324: LD_INT 8
113326: PUSH
113327: EMPTY
113328: LIST
113329: LIST
113330: PUSH
113331: LD_INT 25
113333: PUSH
113334: LD_INT 9
113336: PUSH
113337: EMPTY
113338: LIST
113339: LIST
113340: PUSH
113341: EMPTY
113342: LIST
113343: LIST
113344: LIST
113345: LIST
113346: LIST
113347: PPUSH
113348: CALL_OW 72
113352: ST_TO_ADDR
// if not defenders and not solds then
113353: LD_VAR 0 2
113357: NOT
113358: PUSH
113359: LD_VAR 0 8
113363: NOT
113364: AND
113365: IFFALSE 113369
// exit ;
113367: GO 115139
// depot_under_attack := false ;
113369: LD_ADDR_VAR 0 16
113373: PUSH
113374: LD_INT 0
113376: ST_TO_ADDR
// sold_defenders := [ ] ;
113377: LD_ADDR_VAR 0 17
113381: PUSH
113382: EMPTY
113383: ST_TO_ADDR
// if mechs then
113384: LD_VAR 0 12
113388: IFFALSE 113541
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113390: LD_ADDR_VAR 0 4
113394: PUSH
113395: LD_VAR 0 2
113399: PPUSH
113400: LD_INT 21
113402: PUSH
113403: LD_INT 2
113405: PUSH
113406: EMPTY
113407: LIST
113408: LIST
113409: PPUSH
113410: CALL_OW 72
113414: PUSH
113415: FOR_IN
113416: IFFALSE 113539
// begin if GetTag ( i ) <> 20 then
113418: LD_VAR 0 4
113422: PPUSH
113423: CALL_OW 110
113427: PUSH
113428: LD_INT 20
113430: NONEQUAL
113431: IFFALSE 113445
// SetTag ( i , 20 ) ;
113433: LD_VAR 0 4
113437: PPUSH
113438: LD_INT 20
113440: PPUSH
113441: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113445: LD_VAR 0 4
113449: PPUSH
113450: CALL_OW 263
113454: PUSH
113455: LD_INT 1
113457: EQUAL
113458: PUSH
113459: LD_VAR 0 4
113463: PPUSH
113464: CALL_OW 311
113468: NOT
113469: AND
113470: IFFALSE 113537
// begin un := mechs [ 1 ] ;
113472: LD_ADDR_VAR 0 10
113476: PUSH
113477: LD_VAR 0 12
113481: PUSH
113482: LD_INT 1
113484: ARRAY
113485: ST_TO_ADDR
// ComExit ( un ) ;
113486: LD_VAR 0 10
113490: PPUSH
113491: CALL 53220 0 1
// AddComEnterUnit ( un , i ) ;
113495: LD_VAR 0 10
113499: PPUSH
113500: LD_VAR 0 4
113504: PPUSH
113505: CALL_OW 180
// SetTag ( un , 19 ) ;
113509: LD_VAR 0 10
113513: PPUSH
113514: LD_INT 19
113516: PPUSH
113517: CALL_OW 109
// mechs := mechs diff un ;
113521: LD_ADDR_VAR 0 12
113525: PUSH
113526: LD_VAR 0 12
113530: PUSH
113531: LD_VAR 0 10
113535: DIFF
113536: ST_TO_ADDR
// end ; end ;
113537: GO 113415
113539: POP
113540: POP
// if solds then
113541: LD_VAR 0 8
113545: IFFALSE 113604
// for i in solds do
113547: LD_ADDR_VAR 0 4
113551: PUSH
113552: LD_VAR 0 8
113556: PUSH
113557: FOR_IN
113558: IFFALSE 113602
// if not GetTag ( i ) then
113560: LD_VAR 0 4
113564: PPUSH
113565: CALL_OW 110
113569: NOT
113570: IFFALSE 113600
// begin defenders := defenders union i ;
113572: LD_ADDR_VAR 0 2
113576: PUSH
113577: LD_VAR 0 2
113581: PUSH
113582: LD_VAR 0 4
113586: UNION
113587: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113588: LD_VAR 0 4
113592: PPUSH
113593: LD_INT 18
113595: PPUSH
113596: CALL_OW 109
// end ;
113600: GO 113557
113602: POP
113603: POP
// repeat wait ( 0 0$2 ) ;
113604: LD_INT 70
113606: PPUSH
113607: CALL_OW 67
// enemy := mc_scan [ base ] ;
113611: LD_ADDR_VAR 0 21
113615: PUSH
113616: LD_EXP 84
113620: PUSH
113621: LD_VAR 0 1
113625: ARRAY
113626: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113627: LD_EXP 61
113631: PUSH
113632: LD_VAR 0 1
113636: ARRAY
113637: NOT
113638: PUSH
113639: LD_EXP 61
113643: PUSH
113644: LD_VAR 0 1
113648: ARRAY
113649: PUSH
113650: EMPTY
113651: EQUAL
113652: OR
113653: IFFALSE 113690
// begin for i in defenders do
113655: LD_ADDR_VAR 0 4
113659: PUSH
113660: LD_VAR 0 2
113664: PUSH
113665: FOR_IN
113666: IFFALSE 113679
// ComStop ( i ) ;
113668: LD_VAR 0 4
113672: PPUSH
113673: CALL_OW 141
113677: GO 113665
113679: POP
113680: POP
// defenders := [ ] ;
113681: LD_ADDR_VAR 0 2
113685: PUSH
113686: EMPTY
113687: ST_TO_ADDR
// exit ;
113688: GO 115139
// end ; for i in defenders do
113690: LD_ADDR_VAR 0 4
113694: PUSH
113695: LD_VAR 0 2
113699: PUSH
113700: FOR_IN
113701: IFFALSE 114599
// begin e := NearestUnitToUnit ( enemy , i ) ;
113703: LD_ADDR_VAR 0 13
113707: PUSH
113708: LD_VAR 0 21
113712: PPUSH
113713: LD_VAR 0 4
113717: PPUSH
113718: CALL_OW 74
113722: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113723: LD_ADDR_VAR 0 7
113727: PUSH
113728: LD_EXP 61
113732: PUSH
113733: LD_VAR 0 1
113737: ARRAY
113738: PPUSH
113739: LD_INT 2
113741: PUSH
113742: LD_INT 30
113744: PUSH
113745: LD_INT 0
113747: PUSH
113748: EMPTY
113749: LIST
113750: LIST
113751: PUSH
113752: LD_INT 30
113754: PUSH
113755: LD_INT 1
113757: PUSH
113758: EMPTY
113759: LIST
113760: LIST
113761: PUSH
113762: EMPTY
113763: LIST
113764: LIST
113765: LIST
113766: PPUSH
113767: CALL_OW 72
113771: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113772: LD_ADDR_VAR 0 16
113776: PUSH
113777: LD_VAR 0 7
113781: NOT
113782: PUSH
113783: LD_VAR 0 7
113787: PPUSH
113788: LD_INT 3
113790: PUSH
113791: LD_INT 24
113793: PUSH
113794: LD_INT 600
113796: PUSH
113797: EMPTY
113798: LIST
113799: LIST
113800: PUSH
113801: EMPTY
113802: LIST
113803: LIST
113804: PPUSH
113805: CALL_OW 72
113809: OR
113810: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113811: LD_VAR 0 4
113815: PPUSH
113816: CALL_OW 247
113820: PUSH
113821: LD_INT 2
113823: DOUBLE
113824: EQUAL
113825: IFTRUE 113829
113827: GO 114225
113829: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113830: LD_VAR 0 4
113834: PPUSH
113835: CALL_OW 256
113839: PUSH
113840: LD_INT 1000
113842: EQUAL
113843: PUSH
113844: LD_VAR 0 4
113848: PPUSH
113849: LD_VAR 0 13
113853: PPUSH
113854: CALL_OW 296
113858: PUSH
113859: LD_INT 40
113861: LESS
113862: PUSH
113863: LD_VAR 0 13
113867: PPUSH
113868: LD_EXP 86
113872: PUSH
113873: LD_VAR 0 1
113877: ARRAY
113878: PPUSH
113879: CALL_OW 308
113883: OR
113884: AND
113885: IFFALSE 114007
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113887: LD_VAR 0 4
113891: PPUSH
113892: CALL_OW 262
113896: PUSH
113897: LD_INT 1
113899: EQUAL
113900: PUSH
113901: LD_VAR 0 4
113905: PPUSH
113906: CALL_OW 261
113910: PUSH
113911: LD_INT 30
113913: LESS
113914: AND
113915: PUSH
113916: LD_VAR 0 7
113920: AND
113921: IFFALSE 113991
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113923: LD_VAR 0 4
113927: PPUSH
113928: LD_VAR 0 7
113932: PPUSH
113933: LD_VAR 0 4
113937: PPUSH
113938: CALL_OW 74
113942: PPUSH
113943: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113947: LD_VAR 0 4
113951: PPUSH
113952: LD_VAR 0 7
113956: PPUSH
113957: LD_VAR 0 4
113961: PPUSH
113962: CALL_OW 74
113966: PPUSH
113967: CALL_OW 296
113971: PUSH
113972: LD_INT 6
113974: LESS
113975: IFFALSE 113989
// SetFuel ( i , 100 ) ;
113977: LD_VAR 0 4
113981: PPUSH
113982: LD_INT 100
113984: PPUSH
113985: CALL_OW 240
// end else
113989: GO 114005
// ComAttackUnit ( i , e ) ;
113991: LD_VAR 0 4
113995: PPUSH
113996: LD_VAR 0 13
114000: PPUSH
114001: CALL_OW 115
// end else
114005: GO 114108
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
114007: LD_VAR 0 13
114011: PPUSH
114012: LD_EXP 86
114016: PUSH
114017: LD_VAR 0 1
114021: ARRAY
114022: PPUSH
114023: CALL_OW 308
114027: NOT
114028: PUSH
114029: LD_VAR 0 4
114033: PPUSH
114034: LD_VAR 0 13
114038: PPUSH
114039: CALL_OW 296
114043: PUSH
114044: LD_INT 40
114046: GREATEREQUAL
114047: AND
114048: PUSH
114049: LD_VAR 0 4
114053: PPUSH
114054: CALL_OW 256
114058: PUSH
114059: LD_INT 650
114061: LESSEQUAL
114062: OR
114063: PUSH
114064: LD_VAR 0 4
114068: PPUSH
114069: LD_EXP 85
114073: PUSH
114074: LD_VAR 0 1
114078: ARRAY
114079: PPUSH
114080: CALL_OW 308
114084: NOT
114085: AND
114086: IFFALSE 114108
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114088: LD_VAR 0 4
114092: PPUSH
114093: LD_EXP 85
114097: PUSH
114098: LD_VAR 0 1
114102: ARRAY
114103: PPUSH
114104: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114108: LD_VAR 0 4
114112: PPUSH
114113: CALL_OW 256
114117: PUSH
114118: LD_INT 1000
114120: LESS
114121: PUSH
114122: LD_VAR 0 4
114126: PPUSH
114127: CALL_OW 263
114131: PUSH
114132: LD_INT 1
114134: EQUAL
114135: AND
114136: PUSH
114137: LD_VAR 0 4
114141: PPUSH
114142: CALL_OW 311
114146: AND
114147: PUSH
114148: LD_VAR 0 4
114152: PPUSH
114153: LD_EXP 85
114157: PUSH
114158: LD_VAR 0 1
114162: ARRAY
114163: PPUSH
114164: CALL_OW 308
114168: AND
114169: IFFALSE 114223
// begin mech := IsDrivenBy ( i ) ;
114171: LD_ADDR_VAR 0 9
114175: PUSH
114176: LD_VAR 0 4
114180: PPUSH
114181: CALL_OW 311
114185: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114186: LD_VAR 0 9
114190: PPUSH
114191: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114195: LD_VAR 0 9
114199: PPUSH
114200: LD_VAR 0 4
114204: PPUSH
114205: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114209: LD_VAR 0 9
114213: PPUSH
114214: LD_VAR 0 4
114218: PPUSH
114219: CALL_OW 180
// end ; end ; unit_human :
114223: GO 114570
114225: LD_INT 1
114227: DOUBLE
114228: EQUAL
114229: IFTRUE 114233
114231: GO 114569
114233: POP
// begin b := IsInUnit ( i ) ;
114234: LD_ADDR_VAR 0 18
114238: PUSH
114239: LD_VAR 0 4
114243: PPUSH
114244: CALL_OW 310
114248: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114249: LD_ADDR_VAR 0 19
114253: PUSH
114254: LD_VAR 0 18
114258: NOT
114259: PUSH
114260: LD_VAR 0 18
114264: PPUSH
114265: CALL_OW 266
114269: PUSH
114270: LD_INT 32
114272: PUSH
114273: LD_INT 31
114275: PUSH
114276: EMPTY
114277: LIST
114278: LIST
114279: IN
114280: OR
114281: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114282: LD_VAR 0 18
114286: PPUSH
114287: CALL_OW 266
114291: PUSH
114292: LD_INT 5
114294: EQUAL
114295: PUSH
114296: LD_VAR 0 4
114300: PPUSH
114301: CALL_OW 257
114305: PUSH
114306: LD_INT 1
114308: PUSH
114309: LD_INT 2
114311: PUSH
114312: LD_INT 3
114314: PUSH
114315: LD_INT 4
114317: PUSH
114318: EMPTY
114319: LIST
114320: LIST
114321: LIST
114322: LIST
114323: IN
114324: AND
114325: IFFALSE 114362
// begin class := AllowSpecClass ( i ) ;
114327: LD_ADDR_VAR 0 20
114331: PUSH
114332: LD_VAR 0 4
114336: PPUSH
114337: CALL 17287 0 1
114341: ST_TO_ADDR
// if class then
114342: LD_VAR 0 20
114346: IFFALSE 114362
// ComChangeProfession ( i , class ) ;
114348: LD_VAR 0 4
114352: PPUSH
114353: LD_VAR 0 20
114357: PPUSH
114358: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114362: LD_VAR 0 16
114366: PUSH
114367: LD_VAR 0 2
114371: PPUSH
114372: LD_INT 21
114374: PUSH
114375: LD_INT 2
114377: PUSH
114378: EMPTY
114379: LIST
114380: LIST
114381: PPUSH
114382: CALL_OW 72
114386: PUSH
114387: LD_INT 1
114389: LESSEQUAL
114390: OR
114391: PUSH
114392: LD_VAR 0 19
114396: AND
114397: PUSH
114398: LD_VAR 0 4
114402: PUSH
114403: LD_VAR 0 17
114407: IN
114408: NOT
114409: AND
114410: IFFALSE 114503
// begin if b then
114412: LD_VAR 0 18
114416: IFFALSE 114465
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114418: LD_VAR 0 18
114422: PPUSH
114423: LD_VAR 0 21
114427: PPUSH
114428: LD_VAR 0 18
114432: PPUSH
114433: CALL_OW 74
114437: PPUSH
114438: CALL_OW 296
114442: PUSH
114443: LD_INT 10
114445: LESS
114446: PUSH
114447: LD_VAR 0 18
114451: PPUSH
114452: CALL_OW 461
114456: PUSH
114457: LD_INT 7
114459: NONEQUAL
114460: AND
114461: IFFALSE 114465
// continue ;
114463: GO 113700
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114465: LD_ADDR_VAR 0 17
114469: PUSH
114470: LD_VAR 0 17
114474: PPUSH
114475: LD_VAR 0 17
114479: PUSH
114480: LD_INT 1
114482: PLUS
114483: PPUSH
114484: LD_VAR 0 4
114488: PPUSH
114489: CALL_OW 1
114493: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114494: LD_VAR 0 4
114498: PPUSH
114499: CALL_OW 122
// end ; if sold_defenders then
114503: LD_VAR 0 17
114507: IFFALSE 114567
// if i in sold_defenders then
114509: LD_VAR 0 4
114513: PUSH
114514: LD_VAR 0 17
114518: IN
114519: IFFALSE 114567
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114521: LD_VAR 0 4
114525: PPUSH
114526: CALL_OW 314
114530: NOT
114531: PUSH
114532: LD_VAR 0 4
114536: PPUSH
114537: LD_VAR 0 13
114541: PPUSH
114542: CALL_OW 296
114546: PUSH
114547: LD_INT 30
114549: LESS
114550: AND
114551: IFFALSE 114567
// ComAttackUnit ( i , e ) ;
114553: LD_VAR 0 4
114557: PPUSH
114558: LD_VAR 0 13
114562: PPUSH
114563: CALL_OW 115
// end ; end ; end ;
114567: GO 114570
114569: POP
// if IsDead ( i ) then
114570: LD_VAR 0 4
114574: PPUSH
114575: CALL_OW 301
114579: IFFALSE 114597
// defenders := defenders diff i ;
114581: LD_ADDR_VAR 0 2
114585: PUSH
114586: LD_VAR 0 2
114590: PUSH
114591: LD_VAR 0 4
114595: DIFF
114596: ST_TO_ADDR
// end ;
114597: GO 113700
114599: POP
114600: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114601: LD_VAR 0 21
114605: NOT
114606: PUSH
114607: LD_VAR 0 2
114611: NOT
114612: OR
114613: PUSH
114614: LD_EXP 61
114618: PUSH
114619: LD_VAR 0 1
114623: ARRAY
114624: NOT
114625: OR
114626: IFFALSE 113604
// MC_Reset ( base , 18 ) ;
114628: LD_VAR 0 1
114632: PPUSH
114633: LD_INT 18
114635: PPUSH
114636: CALL 61213 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114640: LD_ADDR_VAR 0 2
114644: PUSH
114645: LD_VAR 0 2
114649: PUSH
114650: LD_VAR 0 2
114654: PPUSH
114655: LD_INT 2
114657: PUSH
114658: LD_INT 25
114660: PUSH
114661: LD_INT 1
114663: PUSH
114664: EMPTY
114665: LIST
114666: LIST
114667: PUSH
114668: LD_INT 25
114670: PUSH
114671: LD_INT 5
114673: PUSH
114674: EMPTY
114675: LIST
114676: LIST
114677: PUSH
114678: LD_INT 25
114680: PUSH
114681: LD_INT 8
114683: PUSH
114684: EMPTY
114685: LIST
114686: LIST
114687: PUSH
114688: LD_INT 25
114690: PUSH
114691: LD_INT 9
114693: PUSH
114694: EMPTY
114695: LIST
114696: LIST
114697: PUSH
114698: EMPTY
114699: LIST
114700: LIST
114701: LIST
114702: LIST
114703: LIST
114704: PPUSH
114705: CALL_OW 72
114709: DIFF
114710: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114711: LD_VAR 0 21
114715: NOT
114716: PUSH
114717: LD_VAR 0 2
114721: PPUSH
114722: LD_INT 21
114724: PUSH
114725: LD_INT 2
114727: PUSH
114728: EMPTY
114729: LIST
114730: LIST
114731: PPUSH
114732: CALL_OW 72
114736: AND
114737: IFFALSE 115075
// begin tmp := FilterByTag ( defenders , 19 ) ;
114739: LD_ADDR_VAR 0 11
114743: PUSH
114744: LD_VAR 0 2
114748: PPUSH
114749: LD_INT 19
114751: PPUSH
114752: CALL 50404 0 2
114756: ST_TO_ADDR
// if tmp then
114757: LD_VAR 0 11
114761: IFFALSE 114831
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114763: LD_ADDR_VAR 0 11
114767: PUSH
114768: LD_VAR 0 11
114772: PPUSH
114773: LD_INT 25
114775: PUSH
114776: LD_INT 3
114778: PUSH
114779: EMPTY
114780: LIST
114781: LIST
114782: PPUSH
114783: CALL_OW 72
114787: ST_TO_ADDR
// if tmp then
114788: LD_VAR 0 11
114792: IFFALSE 114831
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114794: LD_ADDR_EXP 73
114798: PUSH
114799: LD_EXP 73
114803: PPUSH
114804: LD_VAR 0 1
114808: PPUSH
114809: LD_EXP 73
114813: PUSH
114814: LD_VAR 0 1
114818: ARRAY
114819: PUSH
114820: LD_VAR 0 11
114824: UNION
114825: PPUSH
114826: CALL_OW 1
114830: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114831: LD_VAR 0 1
114835: PPUSH
114836: LD_INT 19
114838: PPUSH
114839: CALL 61213 0 2
// repeat wait ( 0 0$1 ) ;
114843: LD_INT 35
114845: PPUSH
114846: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114850: LD_EXP 61
114854: PUSH
114855: LD_VAR 0 1
114859: ARRAY
114860: NOT
114861: PUSH
114862: LD_EXP 61
114866: PUSH
114867: LD_VAR 0 1
114871: ARRAY
114872: PUSH
114873: EMPTY
114874: EQUAL
114875: OR
114876: IFFALSE 114913
// begin for i in defenders do
114878: LD_ADDR_VAR 0 4
114882: PUSH
114883: LD_VAR 0 2
114887: PUSH
114888: FOR_IN
114889: IFFALSE 114902
// ComStop ( i ) ;
114891: LD_VAR 0 4
114895: PPUSH
114896: CALL_OW 141
114900: GO 114888
114902: POP
114903: POP
// defenders := [ ] ;
114904: LD_ADDR_VAR 0 2
114908: PUSH
114909: EMPTY
114910: ST_TO_ADDR
// exit ;
114911: GO 115139
// end ; for i in defenders do
114913: LD_ADDR_VAR 0 4
114917: PUSH
114918: LD_VAR 0 2
114922: PUSH
114923: FOR_IN
114924: IFFALSE 115013
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114926: LD_VAR 0 4
114930: PPUSH
114931: LD_EXP 85
114935: PUSH
114936: LD_VAR 0 1
114940: ARRAY
114941: PPUSH
114942: CALL_OW 308
114946: NOT
114947: IFFALSE 114971
// ComMoveToArea ( i , mc_parking [ base ] ) else
114949: LD_VAR 0 4
114953: PPUSH
114954: LD_EXP 85
114958: PUSH
114959: LD_VAR 0 1
114963: ARRAY
114964: PPUSH
114965: CALL_OW 113
114969: GO 115011
// if GetControl ( i ) = control_manual then
114971: LD_VAR 0 4
114975: PPUSH
114976: CALL_OW 263
114980: PUSH
114981: LD_INT 1
114983: EQUAL
114984: IFFALSE 115011
// if IsDrivenBy ( i ) then
114986: LD_VAR 0 4
114990: PPUSH
114991: CALL_OW 311
114995: IFFALSE 115011
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114997: LD_VAR 0 4
115001: PPUSH
115002: CALL_OW 311
115006: PPUSH
115007: CALL_OW 121
// end ;
115011: GO 114923
115013: POP
115014: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
115015: LD_VAR 0 2
115019: PPUSH
115020: LD_INT 95
115022: PUSH
115023: LD_EXP 85
115027: PUSH
115028: LD_VAR 0 1
115032: ARRAY
115033: PUSH
115034: EMPTY
115035: LIST
115036: LIST
115037: PPUSH
115038: CALL_OW 72
115042: PUSH
115043: LD_VAR 0 2
115047: EQUAL
115048: PUSH
115049: LD_EXP 84
115053: PUSH
115054: LD_VAR 0 1
115058: ARRAY
115059: OR
115060: PUSH
115061: LD_EXP 61
115065: PUSH
115066: LD_VAR 0 1
115070: ARRAY
115071: NOT
115072: OR
115073: IFFALSE 114843
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115075: LD_ADDR_EXP 83
115079: PUSH
115080: LD_EXP 83
115084: PPUSH
115085: LD_VAR 0 1
115089: PPUSH
115090: LD_VAR 0 2
115094: PPUSH
115095: LD_INT 21
115097: PUSH
115098: LD_INT 2
115100: PUSH
115101: EMPTY
115102: LIST
115103: LIST
115104: PPUSH
115105: CALL_OW 72
115109: PPUSH
115110: CALL_OW 1
115114: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115115: LD_VAR 0 1
115119: PPUSH
115120: LD_INT 19
115122: PPUSH
115123: CALL 61213 0 2
// MC_Reset ( base , 20 ) ;
115127: LD_VAR 0 1
115131: PPUSH
115132: LD_INT 20
115134: PPUSH
115135: CALL 61213 0 2
// end ; end_of_file
115139: LD_VAR 0 3
115143: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115144: LD_VAR 0 1
115148: PUSH
115149: LD_INT 200
115151: DOUBLE
115152: GREATEREQUAL
115153: IFFALSE 115161
115155: LD_INT 299
115157: DOUBLE
115158: LESSEQUAL
115159: IFTRUE 115163
115161: GO 115195
115163: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115164: LD_VAR 0 1
115168: PPUSH
115169: LD_VAR 0 2
115173: PPUSH
115174: LD_VAR 0 3
115178: PPUSH
115179: LD_VAR 0 4
115183: PPUSH
115184: LD_VAR 0 5
115188: PPUSH
115189: CALL 103930 0 5
115193: GO 115272
115195: LD_INT 300
115197: DOUBLE
115198: GREATEREQUAL
115199: IFFALSE 115207
115201: LD_INT 399
115203: DOUBLE
115204: LESSEQUAL
115205: IFTRUE 115209
115207: GO 115271
115209: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115210: LD_VAR 0 1
115214: PPUSH
115215: LD_VAR 0 2
115219: PPUSH
115220: LD_VAR 0 3
115224: PPUSH
115225: LD_VAR 0 4
115229: PPUSH
115230: LD_VAR 0 5
115234: PPUSH
115235: LD_VAR 0 6
115239: PPUSH
115240: LD_VAR 0 7
115244: PPUSH
115245: LD_VAR 0 8
115249: PPUSH
115250: LD_VAR 0 9
115254: PPUSH
115255: LD_VAR 0 10
115259: PPUSH
115260: LD_VAR 0 11
115264: PPUSH
115265: CALL 100255 0 11
115269: GO 115272
115271: POP
// end ;
115272: PPOPN 11
115274: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115275: LD_VAR 0 1
115279: PPUSH
115280: LD_VAR 0 2
115284: PPUSH
115285: LD_VAR 0 3
115289: PPUSH
115290: LD_VAR 0 4
115294: PPUSH
115295: LD_VAR 0 5
115299: PPUSH
115300: CALL 103666 0 5
// end ; end_of_file
115304: PPOPN 5
115306: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115307: LD_VAR 0 1
115311: PPUSH
115312: LD_VAR 0 2
115316: PPUSH
115317: LD_VAR 0 3
115321: PPUSH
115322: LD_VAR 0 4
115326: PPUSH
115327: LD_VAR 0 5
115331: PPUSH
115332: LD_VAR 0 6
115336: PPUSH
115337: CALL 87907 0 6
// end ;
115341: PPOPN 6
115343: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
115344: LD_INT 0
115346: PPUSH
// begin if not units then
115347: LD_VAR 0 1
115351: NOT
115352: IFFALSE 115356
// exit ;
115354: GO 115356
// end ;
115356: PPOPN 7
115358: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115359: CALL 87811 0 0
// end ;
115363: PPOPN 1
115365: END
