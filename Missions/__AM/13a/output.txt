// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 619 0 0
// InitMacro ;
  19: CALL 50653 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 46907 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 46907 0 9
// PrepareArabian ;
 147: CALL 3690 0 0
// PrepareRussian ;
 151: CALL 2825 0 0
// PrepareAlliance ;
 155: CALL 821 0 0
// MC_Start ( ) ;
 159: CALL 52765 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6853 0 0
// end ;
 180: END
// export function CustomInitMacro ; var i ; begin
 181: LD_INT 0
 183: PPUSH
 184: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 185: LD_ADDR_EXP 83
 189: PUSH
 190: LD_INT 1
 192: PUSH
 193: LD_INT 2
 195: PUSH
 196: EMPTY
 197: LIST
 198: LIST
 199: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 200: LD_ADDR_EXP 84
 204: PUSH
 205: LD_INT 3
 207: PUSH
 208: LD_INT 4
 210: PUSH
 211: EMPTY
 212: LIST
 213: LIST
 214: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 215: LD_INT 1
 217: PPUSH
 218: LD_INT 12
 220: PUSH
 221: LD_INT 15
 223: PUSH
 224: LD_INT 18
 226: PUSH
 227: EMPTY
 228: LIST
 229: LIST
 230: LIST
 231: PUSH
 232: LD_OWVAR 67
 236: ARRAY
 237: PPUSH
 238: LD_INT 7
 240: PPUSH
 241: CALL 73966 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 245: LD_INT 1
 247: PPUSH
 248: LD_EXP 54
 252: PPUSH
 253: CALL 74392 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 257: LD_INT 1
 259: PPUSH
 260: LD_INT 6
 262: PPUSH
 263: CALL 74850 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 267: LD_INT 1
 269: PPUSH
 270: LD_INT 9
 272: PUSH
 273: EMPTY
 274: LIST
 275: PPUSH
 276: CALL 75119 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 280: LD_INT 1
 282: PPUSH
 283: LD_INT 13
 285: PUSH
 286: LD_INT 1
 288: PUSH
 289: LD_INT 2
 291: PUSH
 292: LD_INT 32
 294: PUSH
 295: EMPTY
 296: LIST
 297: LIST
 298: LIST
 299: LIST
 300: PUSH
 301: EMPTY
 302: LIST
 303: PPUSH
 304: CALL 74332 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 308: LD_INT 2
 310: PPUSH
 311: LD_INT 12
 313: PUSH
 314: LD_INT 14
 316: PUSH
 317: LD_INT 10
 319: PUSH
 320: LD_INT 11
 322: PUSH
 323: EMPTY
 324: LIST
 325: LIST
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 75026 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_EXP 51
 340: PPUSH
 341: CALL 74392 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 345: LD_INT 2
 347: PPUSH
 348: LD_INT 8
 350: PPUSH
 351: CALL 74850 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 355: LD_INT 2
 357: PPUSH
 358: LD_INT 10
 360: PUSH
 361: EMPTY
 362: LIST
 363: PPUSH
 364: CALL 75119 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 368: LD_INT 2
 370: PPUSH
 371: LD_INT 6
 373: PUSH
 374: LD_INT 71
 376: PUSH
 377: LD_INT 116
 379: PUSH
 380: LD_INT 4
 382: PUSH
 383: EMPTY
 384: LIST
 385: LIST
 386: LIST
 387: LIST
 388: PUSH
 389: LD_INT 4
 391: PUSH
 392: LD_INT 85
 394: PUSH
 395: LD_INT 116
 397: PUSH
 398: LD_INT 4
 400: PUSH
 401: EMPTY
 402: LIST
 403: LIST
 404: LIST
 405: LIST
 406: PUSH
 407: LD_INT 32
 409: PUSH
 410: LD_INT 83
 412: PUSH
 413: LD_INT 111
 415: PUSH
 416: LD_INT 4
 418: PUSH
 419: EMPTY
 420: LIST
 421: LIST
 422: LIST
 423: LIST
 424: PUSH
 425: LD_INT 32
 427: PUSH
 428: LD_INT 87
 430: PUSH
 431: LD_INT 121
 433: PUSH
 434: LD_INT 4
 436: PUSH
 437: EMPTY
 438: LIST
 439: LIST
 440: LIST
 441: LIST
 442: PUSH
 443: LD_INT 33
 445: PUSH
 446: LD_INT 88
 448: PUSH
 449: LD_INT 128
 451: PUSH
 452: LD_INT 4
 454: PUSH
 455: EMPTY
 456: LIST
 457: LIST
 458: LIST
 459: LIST
 460: PUSH
 461: LD_INT 32
 463: PUSH
 464: LD_INT 59
 466: PUSH
 467: LD_INT 89
 469: PUSH
 470: LD_INT 3
 472: PUSH
 473: EMPTY
 474: LIST
 475: LIST
 476: LIST
 477: LIST
 478: PUSH
 479: LD_INT 33
 481: PUSH
 482: LD_INT 69
 484: PUSH
 485: LD_INT 98
 487: PUSH
 488: LD_INT 3
 490: PUSH
 491: EMPTY
 492: LIST
 493: LIST
 494: LIST
 495: LIST
 496: PUSH
 497: LD_INT 33
 499: PUSH
 500: LD_INT 77
 502: PUSH
 503: LD_INT 103
 505: PUSH
 506: LD_INT 3
 508: PUSH
 509: EMPTY
 510: LIST
 511: LIST
 512: LIST
 513: LIST
 514: PUSH
 515: LD_INT 33
 517: PUSH
 518: LD_INT 83
 520: PUSH
 521: LD_INT 105
 523: PUSH
 524: LD_INT 3
 526: PUSH
 527: EMPTY
 528: LIST
 529: LIST
 530: LIST
 531: LIST
 532: PUSH
 533: LD_INT 33
 535: PUSH
 536: LD_INT 71
 538: PUSH
 539: LD_INT 125
 541: PUSH
 542: LD_INT 5
 544: PUSH
 545: EMPTY
 546: LIST
 547: LIST
 548: LIST
 549: LIST
 550: PUSH
 551: EMPTY
 552: LIST
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: PPUSH
 563: CALL 74176 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 567: LD_INT 2
 569: PPUSH
 570: LD_INT 21
 572: PUSH
 573: LD_INT 1
 575: PUSH
 576: LD_INT 3
 578: PUSH
 579: LD_INT 51
 581: PUSH
 582: EMPTY
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PUSH
 588: LD_INT 22
 590: PUSH
 591: LD_INT 1
 593: PUSH
 594: LD_INT 3
 596: PUSH
 597: LD_INT 52
 599: PUSH
 600: EMPTY
 601: LIST
 602: LIST
 603: LIST
 604: LIST
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: PPUSH
 610: CALL 74332 0 2
// end ;
 614: LD_VAR 0 1
 618: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 619: LD_INT 0
 621: PPUSH
// debug := 0 ;
 622: LD_ADDR_EXP 1
 626: PUSH
 627: LD_INT 0
 629: ST_TO_ADDR
// game := true ;
 630: LD_ADDR_EXP 2
 634: PUSH
 635: LD_INT 1
 637: ST_TO_ADDR
// gossudarov_arrive := false ;
 638: LD_ADDR_EXP 4
 642: PUSH
 643: LD_INT 0
 645: ST_TO_ADDR
// ru_lab_builded := false ;
 646: LD_ADDR_EXP 5
 650: PUSH
 651: LD_INT 0
 653: ST_TO_ADDR
// player_spotted := false ;
 654: LD_ADDR_EXP 6
 658: PUSH
 659: LD_INT 0
 661: ST_TO_ADDR
// first_attack := false ;
 662: LD_ADDR_EXP 7
 666: PUSH
 667: LD_INT 0
 669: ST_TO_ADDR
// ru_attackers := [ ] ;
 670: LD_ADDR_EXP 52
 674: PUSH
 675: EMPTY
 676: ST_TO_ADDR
// ar_base_spotted := false ;
 677: LD_ADDR_EXP 8
 681: PUSH
 682: LD_INT 0
 684: ST_TO_ADDR
// ar_active_attack := false ;
 685: LD_ADDR_EXP 9
 689: PUSH
 690: LD_INT 0
 692: ST_TO_ADDR
// ar_attackers := [ ] ;
 693: LD_ADDR_EXP 10
 697: PUSH
 698: EMPTY
 699: ST_TO_ADDR
// first_powell_attack := false ;
 700: LD_ADDR_EXP 11
 704: PUSH
 705: LD_INT 0
 707: ST_TO_ADDR
// abdul_escaped := true ;
 708: LD_ADDR_EXP 12
 712: PUSH
 713: LD_INT 1
 715: ST_TO_ADDR
// loss_counter := 0 ;
 716: LD_ADDR_EXP 13
 720: PUSH
 721: LD_INT 0
 723: ST_TO_ADDR
// hack_counter := 0 ;
 724: LD_ADDR_EXP 14
 728: PUSH
 729: LD_INT 0
 731: ST_TO_ADDR
// end ;
 732: LD_VAR 0 1
 736: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 737: LD_EXP 48
 741: PPUSH
 742: CALL_OW 255
 746: PUSH
 747: LD_INT 7
 749: EQUAL
 750: PUSH
 751: LD_EXP 47
 755: PPUSH
 756: CALL_OW 255
 760: PUSH
 761: LD_INT 7
 763: EQUAL
 764: AND
 765: PUSH
 766: LD_EXP 48
 770: PPUSH
 771: CALL_OW 302
 775: AND
 776: PUSH
 777: LD_EXP 47
 781: PPUSH
 782: CALL_OW 302
 786: AND
 787: IFFALSE 799
 789: GO 791
 791: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 792: LD_STRING ACH_COMRADE
 794: PPUSH
 795: CALL_OW 543
 799: END
// every 0 0$1 trigger hack_counter >= 10 do
 800: LD_EXP 14
 804: PUSH
 805: LD_INT 10
 807: GREATEREQUAL
 808: IFFALSE 820
 810: GO 812
 812: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 813: LD_STRING ACH_HACK
 815: PPUSH
 816: CALL_OW 543
 820: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 821: LD_INT 0
 823: PPUSH
 824: PPUSH
 825: PPUSH
 826: PPUSH
// uc_side := 7 ;
 827: LD_ADDR_OWVAR 20
 831: PUSH
 832: LD_INT 7
 834: ST_TO_ADDR
// uc_nation := 1 ;
 835: LD_ADDR_OWVAR 21
 839: PUSH
 840: LD_INT 1
 842: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 843: LD_ADDR_EXP 15
 847: PUSH
 848: LD_STRING JMM
 850: PPUSH
 851: LD_EXP 1
 855: NOT
 856: PPUSH
 857: LD_STRING 12a_
 859: PPUSH
 860: CALL 14292 0 3
 864: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 865: LD_EXP 15
 869: PPUSH
 870: LD_INT 71
 872: PPUSH
 873: LD_INT 23
 875: PPUSH
 876: LD_INT 0
 878: PPUSH
 879: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 883: LD_EXP 15
 887: PPUSH
 888: LD_INT 2
 890: PPUSH
 891: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 895: LD_ADDR_EXP 16
 899: PUSH
 900: LD_STRING Roth
 902: PPUSH
 903: LD_EXP 1
 907: NOT
 908: PPUSH
 909: LD_STRING 12a_
 911: PPUSH
 912: CALL 14292 0 3
 916: ST_TO_ADDR
// if Roth then
 917: LD_EXP 16
 921: IFFALSE 941
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 923: LD_EXP 16
 927: PPUSH
 928: LD_INT 71
 930: PPUSH
 931: LD_INT 21
 933: PPUSH
 934: LD_INT 0
 936: PPUSH
 937: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 941: LD_ADDR_EXP 17
 945: PUSH
 946: LD_STRING Lisa
 948: PPUSH
 949: LD_EXP 1
 953: NOT
 954: PPUSH
 955: LD_STRING 12a_
 957: PPUSH
 958: CALL 14292 0 3
 962: ST_TO_ADDR
// if Lisa then
 963: LD_EXP 17
 967: IFFALSE 984
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 969: LD_EXP 17
 973: PPUSH
 974: LD_INT 13
 976: PPUSH
 977: LD_INT 0
 979: PPUSH
 980: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 984: LD_ADDR_EXP 18
 988: PUSH
 989: LD_STRING Donaldson
 991: PPUSH
 992: LD_EXP 1
 996: NOT
 997: PPUSH
 998: LD_STRING 12a_
1000: PPUSH
1001: CALL 14292 0 3
1005: ST_TO_ADDR
// if Donaldson then
1006: LD_EXP 18
1010: IFFALSE 1027
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1012: LD_EXP 18
1016: PPUSH
1017: LD_INT 13
1019: PPUSH
1020: LD_INT 0
1022: PPUSH
1023: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1027: LD_ADDR_EXP 19
1031: PUSH
1032: LD_STRING Bobby
1034: PPUSH
1035: LD_EXP 1
1039: NOT
1040: PPUSH
1041: LD_STRING 12a_
1043: PPUSH
1044: CALL 14292 0 3
1048: ST_TO_ADDR
// if Bobby then
1049: LD_EXP 19
1053: IFFALSE 1070
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1055: LD_EXP 19
1059: PPUSH
1060: LD_INT 13
1062: PPUSH
1063: LD_INT 0
1065: PPUSH
1066: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1070: LD_ADDR_EXP 20
1074: PUSH
1075: LD_STRING Cyrus
1077: PPUSH
1078: LD_EXP 1
1082: NOT
1083: PPUSH
1084: LD_STRING 12a_
1086: PPUSH
1087: CALL 14292 0 3
1091: ST_TO_ADDR
// if Cyrus then
1092: LD_EXP 20
1096: IFFALSE 1113
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1098: LD_EXP 20
1102: PPUSH
1103: LD_INT 13
1105: PPUSH
1106: LD_INT 0
1108: PPUSH
1109: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1113: LD_ADDR_EXP 21
1117: PUSH
1118: LD_STRING Denis
1120: PPUSH
1121: LD_EXP 1
1125: NOT
1126: PPUSH
1127: LD_STRING 12a_
1129: PPUSH
1130: CALL 14292 0 3
1134: ST_TO_ADDR
// if Denis then
1135: LD_EXP 21
1139: IFFALSE 1156
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1141: LD_EXP 21
1145: PPUSH
1146: LD_INT 13
1148: PPUSH
1149: LD_INT 0
1151: PPUSH
1152: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1156: LD_ADDR_EXP 22
1160: PUSH
1161: LD_STRING Brown
1163: PPUSH
1164: LD_EXP 1
1168: NOT
1169: PPUSH
1170: LD_STRING 12a_
1172: PPUSH
1173: CALL 14292 0 3
1177: ST_TO_ADDR
// if Brown then
1178: LD_EXP 22
1182: IFFALSE 1199
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1184: LD_EXP 22
1188: PPUSH
1189: LD_INT 13
1191: PPUSH
1192: LD_INT 0
1194: PPUSH
1195: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1199: LD_ADDR_EXP 23
1203: PUSH
1204: LD_STRING Gladstone
1206: PPUSH
1207: LD_EXP 1
1211: NOT
1212: PPUSH
1213: LD_STRING 12a_
1215: PPUSH
1216: CALL 14292 0 3
1220: ST_TO_ADDR
// if Gladstone then
1221: LD_EXP 23
1225: IFFALSE 1242
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1227: LD_EXP 23
1231: PPUSH
1232: LD_INT 13
1234: PPUSH
1235: LD_INT 0
1237: PPUSH
1238: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1242: LD_ADDR_EXP 24
1246: PUSH
1247: LD_STRING Houten
1249: PPUSH
1250: LD_EXP 1
1254: NOT
1255: PPUSH
1256: LD_STRING 12a_
1258: PPUSH
1259: CALL 14292 0 3
1263: ST_TO_ADDR
// if Houten then
1264: LD_EXP 24
1268: IFFALSE 1285
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1270: LD_EXP 24
1274: PPUSH
1275: LD_INT 13
1277: PPUSH
1278: LD_INT 0
1280: PPUSH
1281: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1285: LD_ADDR_EXP 25
1289: PUSH
1290: LD_STRING Cornell
1292: PPUSH
1293: LD_EXP 1
1297: NOT
1298: PPUSH
1299: LD_STRING 12a_
1301: PPUSH
1302: CALL 14292 0 3
1306: ST_TO_ADDR
// if Cornel then
1307: LD_EXP 25
1311: IFFALSE 1328
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1313: LD_EXP 25
1317: PPUSH
1318: LD_INT 13
1320: PPUSH
1321: LD_INT 0
1323: PPUSH
1324: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1328: LD_ADDR_EXP 26
1332: PUSH
1333: LD_STRING Gary
1335: PPUSH
1336: LD_EXP 1
1340: NOT
1341: PPUSH
1342: LD_STRING 12a_
1344: PPUSH
1345: CALL 14292 0 3
1349: ST_TO_ADDR
// if Gary then
1350: LD_EXP 26
1354: IFFALSE 1371
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1356: LD_EXP 26
1360: PPUSH
1361: LD_INT 13
1363: PPUSH
1364: LD_INT 0
1366: PPUSH
1367: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1371: LD_ADDR_EXP 27
1375: PUSH
1376: LD_STRING Frank
1378: PPUSH
1379: LD_EXP 1
1383: NOT
1384: PPUSH
1385: LD_STRING 12a_
1387: PPUSH
1388: CALL 14292 0 3
1392: ST_TO_ADDR
// if Frank then
1393: LD_EXP 27
1397: IFFALSE 1414
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1399: LD_EXP 27
1403: PPUSH
1404: LD_INT 13
1406: PPUSH
1407: LD_INT 0
1409: PPUSH
1410: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1414: LD_ADDR_EXP 28
1418: PUSH
1419: LD_STRING Kikuchi
1421: PPUSH
1422: LD_EXP 1
1426: NOT
1427: PPUSH
1428: LD_STRING 12a_
1430: PPUSH
1431: CALL 14292 0 3
1435: ST_TO_ADDR
// if Kikuchi then
1436: LD_EXP 28
1440: IFFALSE 1457
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1442: LD_EXP 28
1446: PPUSH
1447: LD_INT 13
1449: PPUSH
1450: LD_INT 0
1452: PPUSH
1453: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1457: LD_ADDR_EXP 29
1461: PUSH
1462: LD_STRING Simms
1464: PPUSH
1465: LD_EXP 1
1469: NOT
1470: PPUSH
1471: LD_STRING 12a_
1473: PPUSH
1474: CALL 14292 0 3
1478: ST_TO_ADDR
// if Simms then
1479: LD_EXP 29
1483: IFFALSE 1500
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1485: LD_EXP 29
1489: PPUSH
1490: LD_INT 13
1492: PPUSH
1493: LD_INT 0
1495: PPUSH
1496: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1500: LD_ADDR_EXP 30
1504: PUSH
1505: LD_STRING Joan
1507: PPUSH
1508: LD_EXP 1
1512: NOT
1513: PPUSH
1514: LD_STRING 12a_
1516: PPUSH
1517: CALL 14292 0 3
1521: ST_TO_ADDR
// if Joan then
1522: LD_EXP 30
1526: IFFALSE 1543
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1528: LD_EXP 30
1532: PPUSH
1533: LD_INT 13
1535: PPUSH
1536: LD_INT 0
1538: PPUSH
1539: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1543: LD_ADDR_EXP 31
1547: PUSH
1548: LD_STRING DeltaDoctor
1550: PPUSH
1551: LD_EXP 1
1555: NOT
1556: PPUSH
1557: LD_STRING 12a_
1559: PPUSH
1560: CALL 14292 0 3
1564: ST_TO_ADDR
// if DeltaDoctor then
1565: LD_EXP 31
1569: IFFALSE 1586
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1571: LD_EXP 31
1575: PPUSH
1576: LD_INT 13
1578: PPUSH
1579: LD_INT 0
1581: PPUSH
1582: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1586: LD_ADDR_VAR 0 4
1590: PUSH
1591: LD_STRING 12a_others
1593: PPUSH
1594: CALL_OW 31
1598: ST_TO_ADDR
// if tmp then
1599: LD_VAR 0 4
1603: IFFALSE 1637
// for i in tmp do
1605: LD_ADDR_VAR 0 3
1609: PUSH
1610: LD_VAR 0 4
1614: PUSH
1615: FOR_IN
1616: IFFALSE 1635
// PlaceUnitArea ( i , alliance_start , false ) ;
1618: LD_VAR 0 3
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
1633: GO 1615
1635: POP
1636: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1637: LD_INT 3
1639: PPUSH
1640: LD_INT 3
1642: PPUSH
1643: LD_INT 3
1645: PPUSH
1646: LD_INT 12
1648: PPUSH
1649: LD_INT 100
1651: PPUSH
1652: CALL 19116 0 5
// veh := CreateVehicle ;
1656: LD_ADDR_VAR 0 2
1660: PUSH
1661: CALL_OW 45
1665: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1666: LD_VAR 0 2
1670: PPUSH
1671: LD_INT 2
1673: PPUSH
1674: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1678: LD_VAR 0 2
1682: PPUSH
1683: LD_INT 60
1685: PPUSH
1686: LD_INT 6
1688: PPUSH
1689: LD_INT 0
1691: PPUSH
1692: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1696: LD_VAR 0 2
1700: PPUSH
1701: LD_INT 4
1703: PPUSH
1704: LD_INT 30
1706: PPUSH
1707: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1711: LD_STRING 11_artifact_captured
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 30
1721: IFFALSE 1797
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1723: LD_INT 3
1725: PPUSH
1726: LD_INT 3
1728: PPUSH
1729: LD_INT 3
1731: PPUSH
1732: LD_INT 12
1734: PPUSH
1735: LD_INT 100
1737: PPUSH
1738: CALL 19116 0 5
// veh := CreateVehicle ;
1742: LD_ADDR_VAR 0 2
1746: PUSH
1747: CALL_OW 45
1751: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1752: LD_VAR 0 2
1756: PPUSH
1757: LD_INT 3
1759: PPUSH
1760: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1764: LD_VAR 0 2
1768: PPUSH
1769: LD_INT 75
1771: PPUSH
1772: LD_INT 6
1774: PPUSH
1775: LD_INT 0
1777: PPUSH
1778: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1782: LD_VAR 0 2
1786: PPUSH
1787: LD_INT 4
1789: PPUSH
1790: LD_INT 50
1792: PPUSH
1793: CALL_OW 290
// end ; end ;
1797: LD_VAR 0 1
1801: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1802: LD_INT 0
1804: PPUSH
1805: PPUSH
1806: PPUSH
1807: PPUSH
// uc_side := 6 ;
1808: LD_ADDR_OWVAR 20
1812: PUSH
1813: LD_INT 6
1815: ST_TO_ADDR
// uc_nation := 3 ;
1816: LD_ADDR_OWVAR 21
1820: PUSH
1821: LD_INT 3
1823: ST_TO_ADDR
// InitHc ;
1824: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1828: LD_ADDR_EXP 32
1832: PUSH
1833: LD_STRING Gossudarov
1835: PPUSH
1836: CALL_OW 25
1840: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1841: LD_ADDR_EXP 33
1845: PUSH
1846: LD_STRING Kirilenkova
1848: PPUSH
1849: CALL_OW 25
1853: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1854: LD_ADDR_EXP 34
1858: PUSH
1859: LD_STRING Titov
1861: PPUSH
1862: CALL_OW 25
1866: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1867: LD_ADDR_EXP 39
1871: PUSH
1872: LD_STRING Oblukov
1874: PPUSH
1875: CALL_OW 25
1879: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1880: LD_ADDR_EXP 36
1884: PUSH
1885: LD_STRING Dolgov
1887: PPUSH
1888: CALL_OW 25
1892: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1893: LD_ADDR_EXP 37
1897: PUSH
1898: LD_STRING Petrosyan
1900: PPUSH
1901: CALL_OW 25
1905: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1906: LD_ADDR_EXP 38
1910: PUSH
1911: LD_STRING Scholtze
1913: PPUSH
1914: CALL_OW 25
1918: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1919: LD_ADDR_EXP 40
1923: PUSH
1924: LD_STRING Kapitsova
1926: PPUSH
1927: CALL_OW 25
1931: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1932: LD_ADDR_VAR 0 2
1936: PUSH
1937: LD_EXP 32
1941: PUSH
1942: LD_EXP 33
1946: PUSH
1947: LD_EXP 34
1951: PUSH
1952: LD_EXP 39
1956: PUSH
1957: LD_EXP 36
1961: PUSH
1962: LD_EXP 37
1966: PUSH
1967: LD_EXP 38
1971: PUSH
1972: LD_EXP 40
1976: PUSH
1977: EMPTY
1978: LIST
1979: LIST
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: LIST
1985: LIST
1986: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1987: LD_INT 1
1989: PPUSH
1990: LD_INT 4
1992: PPUSH
1993: LD_INT 8
1995: PPUSH
1996: CALL_OW 380
// un := CreateHuman ;
2000: LD_ADDR_VAR 0 4
2004: PUSH
2005: CALL_OW 44
2009: ST_TO_ADDR
// tmp := tmp ^ un ;
2010: LD_ADDR_VAR 0 2
2014: PUSH
2015: LD_VAR 0 2
2019: PUSH
2020: LD_VAR 0 4
2024: ADD
2025: ST_TO_ADDR
// for i in tmp do
2026: LD_ADDR_VAR 0 3
2030: PUSH
2031: LD_VAR 0 2
2035: PUSH
2036: FOR_IN
2037: IFFALSE 2056
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2039: LD_VAR 0 3
2043: PPUSH
2044: LD_INT 14
2046: PPUSH
2047: LD_INT 0
2049: PPUSH
2050: CALL_OW 49
2054: GO 2036
2056: POP
2057: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2058: LD_VAR 0 2
2062: PPUSH
2063: LD_EXP 3
2067: PPUSH
2068: CALL_OW 250
2072: PPUSH
2073: LD_EXP 3
2077: PPUSH
2078: CALL_OW 251
2082: PPUSH
2083: CALL_OW 111
// end ;
2087: LD_VAR 0 1
2091: RET
// export function PrepareBelkov ; begin
2092: LD_INT 0
2094: PPUSH
// uc_side := 4 ;
2095: LD_ADDR_OWVAR 20
2099: PUSH
2100: LD_INT 4
2102: ST_TO_ADDR
// uc_nation := 3 ;
2103: LD_ADDR_OWVAR 21
2107: PUSH
2108: LD_INT 3
2110: ST_TO_ADDR
// InitHc ;
2111: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2115: LD_ADDR_EXP 47
2119: PUSH
2120: LD_STRING Belkov
2122: PPUSH
2123: CALL_OW 25
2127: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2128: LD_EXP 47
2132: PPUSH
2133: LD_INT 14
2135: PPUSH
2136: LD_INT 0
2138: PPUSH
2139: CALL_OW 49
// end ;
2143: LD_VAR 0 1
2147: RET
// export function PrepareGnyevko ; begin
2148: LD_INT 0
2150: PPUSH
// uc_side := 4 ;
2151: LD_ADDR_OWVAR 20
2155: PUSH
2156: LD_INT 4
2158: ST_TO_ADDR
// uc_nation := 3 ;
2159: LD_ADDR_OWVAR 21
2163: PUSH
2164: LD_INT 3
2166: ST_TO_ADDR
// InitHc ;
2167: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2171: LD_ADDR_EXP 48
2175: PUSH
2176: LD_STRING Gnyevko
2178: PPUSH
2179: CALL_OW 25
2183: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2184: LD_EXP 48
2188: PPUSH
2189: LD_INT 14
2191: PPUSH
2192: LD_INT 0
2194: PPUSH
2195: CALL_OW 49
// end ;
2199: LD_VAR 0 1
2203: RET
// export function PrepareBurlak ; var i , tmp ; begin
2204: LD_INT 0
2206: PPUSH
2207: PPUSH
2208: PPUSH
// uc_side := 4 ;
2209: LD_ADDR_OWVAR 20
2213: PUSH
2214: LD_INT 4
2216: ST_TO_ADDR
// uc_nation := 3 ;
2217: LD_ADDR_OWVAR 21
2221: PUSH
2222: LD_INT 3
2224: ST_TO_ADDR
// InitHc ;
2225: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2229: LD_ADDR_EXP 46
2233: PUSH
2234: LD_STRING Burlak
2236: PPUSH
2237: CALL_OW 25
2241: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2242: LD_INT 24
2244: PUSH
2245: LD_INT 23
2247: PUSH
2248: LD_INT 22
2250: PUSH
2251: EMPTY
2252: LIST
2253: LIST
2254: LIST
2255: PUSH
2256: LD_OWVAR 67
2260: ARRAY
2261: PPUSH
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 1
2267: PPUSH
2268: LD_INT 45
2270: PUSH
2271: LD_INT 44
2273: PUSH
2274: LD_INT 43
2276: PUSH
2277: EMPTY
2278: LIST
2279: LIST
2280: LIST
2281: PUSH
2282: LD_OWVAR 67
2286: ARRAY
2287: PPUSH
2288: LD_INT 0
2290: PPUSH
2291: CALL 19116 0 5
// Masha := CreateVehicle ;
2295: LD_ADDR_EXP 49
2299: PUSH
2300: CALL_OW 45
2304: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2305: LD_EXP 49
2309: PUSH
2310: LD_EXP 46
2314: PUSH
2315: EMPTY
2316: LIST
2317: LIST
2318: PPUSH
2319: LD_INT 499
2321: PPUSH
2322: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2326: LD_EXP 49
2330: PPUSH
2331: LD_INT 3
2333: PPUSH
2334: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2338: LD_EXP 49
2342: PPUSH
2343: LD_INT 1
2345: PPUSH
2346: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2350: LD_INT 1
2352: PPUSH
2353: LD_INT 18
2355: PPUSH
2356: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2360: LD_INT 35
2362: PPUSH
2363: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 18
2374: PPUSH
2375: EMPTY
2376: PPUSH
2377: CALL_OW 70
2381: ST_TO_ADDR
// if tmp then
2382: LD_VAR 0 3
2386: IFFALSE 2420
// for i in tmp do
2388: LD_ADDR_VAR 0 2
2392: PUSH
2393: LD_VAR 0 3
2397: PUSH
2398: FOR_IN
2399: IFFALSE 2418
// ComMoveXY ( i , 114 , 9 ) ;
2401: LD_VAR 0 2
2405: PPUSH
2406: LD_INT 114
2408: PPUSH
2409: LD_INT 9
2411: PPUSH
2412: CALL_OW 111
2416: GO 2398
2418: POP
2419: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2420: LD_INT 18
2422: PPUSH
2423: EMPTY
2424: PPUSH
2425: CALL_OW 70
2429: NOT
2430: PUSH
2431: LD_INT 123
2433: PPUSH
2434: LD_INT 3
2436: PPUSH
2437: CALL_OW 428
2441: PUSH
2442: LD_INT 0
2444: EQUAL
2445: AND
2446: IFFALSE 2360
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2448: LD_EXP 49
2452: PPUSH
2453: LD_INT 123
2455: PPUSH
2456: LD_INT 3
2458: PPUSH
2459: LD_INT 0
2461: PPUSH
2462: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2466: LD_EXP 46
2470: PPUSH
2471: LD_INT 125
2473: PPUSH
2474: LD_INT 1
2476: PPUSH
2477: LD_INT 0
2479: PPUSH
2480: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2484: LD_EXP 46
2488: PPUSH
2489: LD_EXP 49
2493: PPUSH
2494: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2498: LD_INT 10
2500: PPUSH
2501: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2505: LD_EXP 49
2509: PPUSH
2510: LD_INT 110
2512: PPUSH
2513: LD_INT 10
2515: PPUSH
2516: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2520: LD_ADDR_EXP 42
2524: PUSH
2525: LD_STRING Petrovova
2527: PPUSH
2528: CALL_OW 25
2532: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2533: LD_ADDR_EXP 44
2537: PUSH
2538: LD_STRING Kuzmov
2540: PPUSH
2541: CALL_OW 25
2545: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2546: LD_ADDR_EXP 43
2550: PUSH
2551: LD_STRING Kovalyuk
2553: PPUSH
2554: CALL_OW 25
2558: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2559: LD_ADDR_EXP 41
2563: PUSH
2564: LD_STRING Lipshchin
2566: PPUSH
2567: CALL_OW 25
2571: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2572: LD_ADDR_EXP 45
2576: PUSH
2577: LD_STRING Karamazov
2579: PPUSH
2580: CALL_OW 25
2584: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2585: LD_ADDR_VAR 0 3
2589: PUSH
2590: LD_EXP 42
2594: PUSH
2595: LD_EXP 44
2599: PUSH
2600: LD_EXP 43
2604: PUSH
2605: LD_EXP 41
2609: PUSH
2610: LD_EXP 45
2614: PUSH
2615: EMPTY
2616: LIST
2617: LIST
2618: LIST
2619: LIST
2620: LIST
2621: ST_TO_ADDR
// for i in tmp do
2622: LD_ADDR_VAR 0 2
2626: PUSH
2627: LD_VAR 0 3
2631: PUSH
2632: FOR_IN
2633: IFFALSE 2672
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2635: LD_VAR 0 2
2639: PPUSH
2640: LD_INT 399
2642: PPUSH
2643: LD_INT 799
2645: PPUSH
2646: CALL_OW 12
2650: PPUSH
2651: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2655: LD_VAR 0 2
2659: PPUSH
2660: LD_INT 19
2662: PPUSH
2663: LD_INT 0
2665: PPUSH
2666: CALL_OW 49
// end ;
2670: GO 2632
2672: POP
2673: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2674: LD_VAR 0 3
2678: PPUSH
2679: LD_INT 116
2681: PPUSH
2682: LD_INT 8
2684: PPUSH
2685: CALL_OW 111
// AddComHold ( tmp ) ;
2689: LD_VAR 0 3
2693: PPUSH
2694: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2698: LD_ADDR_VAR 0 2
2702: PUSH
2703: LD_VAR 0 3
2707: PPUSH
2708: LD_INT 25
2710: PUSH
2711: LD_INT 1
2713: PUSH
2714: EMPTY
2715: LIST
2716: LIST
2717: PPUSH
2718: CALL_OW 72
2722: PUSH
2723: FOR_IN
2724: IFFALSE 2764
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2726: LD_VAR 0 2
2730: PPUSH
2731: LD_INT 20
2733: PPUSH
2734: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2738: LD_VAR 0 2
2742: PPUSH
2743: LD_INT 147
2745: PPUSH
2746: LD_INT 45
2748: PPUSH
2749: CALL_OW 178
// AddComCrawl ( i ) ;
2753: LD_VAR 0 2
2757: PPUSH
2758: CALL_OW 197
// end ;
2762: GO 2723
2764: POP
2765: POP
// repeat wait ( 0 0$1 ) ;
2766: LD_INT 35
2768: PPUSH
2769: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2773: LD_EXP 49
2777: PPUSH
2778: LD_INT 110
2780: PPUSH
2781: LD_INT 10
2783: PPUSH
2784: CALL_OW 307
2788: PUSH
2789: LD_EXP 49
2793: PPUSH
2794: CALL_OW 305
2798: NOT
2799: OR
2800: IFFALSE 2766
// ComStop ( Burlak ) ;
2802: LD_EXP 46
2806: PPUSH
2807: CALL_OW 141
// AddComHold ( Burlak ) ;
2811: LD_EXP 46
2815: PPUSH
2816: CALL_OW 200
// end ; end_of_file
2820: LD_VAR 0 1
2824: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2825: LD_INT 0
2827: PPUSH
2828: PPUSH
2829: PPUSH
2830: PPUSH
// uc_side := 3 ;
2831: LD_ADDR_OWVAR 20
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// uc_nation := 3 ;
2839: LD_ADDR_OWVAR 21
2843: PUSH
2844: LD_INT 3
2846: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2847: LD_ADDR_EXP 50
2851: PUSH
2852: LD_INT 47
2854: PPUSH
2855: LD_INT 4
2857: PPUSH
2858: LD_STRING 
2860: PPUSH
2861: LD_INT 7
2863: PUSH
2864: LD_INT 8
2866: PUSH
2867: LD_INT 9
2869: PUSH
2870: EMPTY
2871: LIST
2872: LIST
2873: LIST
2874: PUSH
2875: LD_OWVAR 67
2879: ARRAY
2880: PPUSH
2881: LD_INT 10000
2883: PUSH
2884: LD_INT 3000
2886: PUSH
2887: LD_INT 300
2889: PUSH
2890: EMPTY
2891: LIST
2892: LIST
2893: LIST
2894: PPUSH
2895: LD_INT 9
2897: PUSH
2898: LD_INT 5
2900: PUSH
2901: LD_INT 6
2903: PUSH
2904: LD_INT 6
2906: PUSH
2907: EMPTY
2908: LIST
2909: LIST
2910: LIST
2911: LIST
2912: PPUSH
2913: CALL 22525 0 6
2917: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2918: LD_ADDR_EXP 59
2922: PUSH
2923: LD_EXP 59
2927: PPUSH
2928: LD_INT 2
2930: PPUSH
2931: LD_EXP 50
2935: PPUSH
2936: CALL_OW 1
2940: ST_TO_ADDR
// tmp := [ ] ;
2941: LD_ADDR_VAR 0 4
2945: PUSH
2946: EMPTY
2947: ST_TO_ADDR
// for i = 1 to 4 do
2948: LD_ADDR_VAR 0 2
2952: PUSH
2953: DOUBLE
2954: LD_INT 1
2956: DEC
2957: ST_TO_ADDR
2958: LD_INT 4
2960: PUSH
2961: FOR_TO
2962: IFFALSE 3055
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2964: LD_INT 22
2966: PPUSH
2967: LD_INT 3
2969: PPUSH
2970: LD_INT 3
2972: PPUSH
2973: LD_INT 43
2975: PUSH
2976: LD_INT 45
2978: PUSH
2979: LD_INT 45
2981: PUSH
2982: LD_INT 44
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: LIST
2990: PUSH
2991: LD_VAR 0 2
2995: PUSH
2996: LD_INT 4
2998: MOD
2999: PUSH
3000: LD_INT 1
3002: PLUS
3003: ARRAY
3004: PPUSH
3005: LD_INT 100
3007: PPUSH
3008: CALL 19116 0 5
// veh := CreateVehicle ;
3012: LD_ADDR_VAR 0 3
3016: PUSH
3017: CALL_OW 45
3021: ST_TO_ADDR
// tmp := tmp ^ veh ;
3022: LD_ADDR_VAR 0 4
3026: PUSH
3027: LD_VAR 0 4
3031: PUSH
3032: LD_VAR 0 3
3036: ADD
3037: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3038: LD_VAR 0 3
3042: PPUSH
3043: LD_INT 2
3045: PPUSH
3046: LD_INT 0
3048: PPUSH
3049: CALL_OW 49
// end ;
3053: GO 2961
3055: POP
3056: POP
// russian_guard := tmp ;
3057: LD_ADDR_EXP 51
3061: PUSH
3062: LD_VAR 0 4
3066: ST_TO_ADDR
// end ;
3067: LD_VAR 0 1
3071: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3072: LD_INT 47
3074: PPUSH
3075: CALL_OW 302
3079: PUSH
3080: LD_EXP 6
3084: AND
3085: IFFALSE 3687
3087: GO 3089
3089: DISABLE
3090: LD_INT 0
3092: PPUSH
3093: PPUSH
3094: PPUSH
3095: PPUSH
3096: PPUSH
3097: PPUSH
// begin enable ;
3098: ENABLE
// base := 2 ;
3099: LD_ADDR_VAR 0 2
3103: PUSH
3104: LD_INT 2
3106: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3107: LD_ADDR_VAR 0 4
3111: PUSH
3112: LD_INT 0
3114: PUSH
3115: LD_INT 0
3117: PUSH
3118: LD_INT 0
3120: PUSH
3121: LD_INT 0
3123: PUSH
3124: LD_INT 0
3126: PUSH
3127: LD_INT 0
3129: PUSH
3130: LD_INT 0
3132: PUSH
3133: LD_INT 0
3135: PUSH
3136: LD_INT 1
3138: PUSH
3139: LD_INT 0
3141: PUSH
3142: EMPTY
3143: LIST
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: LIST
3149: LIST
3150: LIST
3151: LIST
3152: LIST
3153: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3154: LD_ADDR_VAR 0 3
3158: PUSH
3159: LD_INT 22
3161: PUSH
3162: LD_INT 1
3164: PUSH
3165: LD_INT 3
3167: PUSH
3168: LD_INT 45
3170: PUSH
3171: EMPTY
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: PUSH
3177: LD_INT 21
3179: PUSH
3180: LD_INT 1
3182: PUSH
3183: LD_INT 3
3185: PUSH
3186: LD_INT 45
3188: PUSH
3189: EMPTY
3190: LIST
3191: LIST
3192: LIST
3193: LIST
3194: PUSH
3195: LD_INT 22
3197: PUSH
3198: LD_INT 1
3200: PUSH
3201: LD_INT 3
3203: PUSH
3204: LD_INT 45
3206: PUSH
3207: EMPTY
3208: LIST
3209: LIST
3210: LIST
3211: LIST
3212: PUSH
3213: LD_INT 23
3215: PUSH
3216: LD_INT 1
3218: PUSH
3219: LD_INT 3
3221: PUSH
3222: LD_INT 46
3224: PUSH
3225: EMPTY
3226: LIST
3227: LIST
3228: LIST
3229: LIST
3230: PUSH
3231: EMPTY
3232: LIST
3233: LIST
3234: LIST
3235: LIST
3236: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3237: LD_ADDR_VAR 0 1
3241: PUSH
3242: DOUBLE
3243: LD_INT 1
3245: DEC
3246: ST_TO_ADDR
3247: LD_OWVAR 67
3251: PUSH
3252: LD_OWVAR 1
3256: PUSH
3257: LD_INT 21000
3259: DIV
3260: PLUS
3261: PUSH
3262: FOR_TO
3263: IFFALSE 3351
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3265: LD_ADDR_VAR 0 3
3269: PUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: LD_VAR 0 3
3279: PUSH
3280: LD_INT 1
3282: PLUS
3283: PPUSH
3284: LD_INT 23
3286: PUSH
3287: LD_INT 24
3289: PUSH
3290: EMPTY
3291: LIST
3292: LIST
3293: PUSH
3294: LD_INT 1
3296: PPUSH
3297: LD_INT 2
3299: PPUSH
3300: CALL_OW 12
3304: ARRAY
3305: PUSH
3306: LD_INT 1
3308: PUSH
3309: LD_INT 3
3311: PUSH
3312: LD_INT 46
3314: PUSH
3315: LD_INT 47
3317: PUSH
3318: LD_INT 45
3320: PUSH
3321: EMPTY
3322: LIST
3323: LIST
3324: LIST
3325: PUSH
3326: LD_INT 1
3328: PPUSH
3329: LD_INT 3
3331: PPUSH
3332: CALL_OW 12
3336: ARRAY
3337: PUSH
3338: EMPTY
3339: LIST
3340: LIST
3341: LIST
3342: LIST
3343: PPUSH
3344: CALL_OW 2
3348: ST_TO_ADDR
3349: GO 3262
3351: POP
3352: POP
// MC_InsertProduceList ( base , tmp ) ;
3353: LD_VAR 0 2
3357: PPUSH
3358: LD_VAR 0 3
3362: PPUSH
3363: CALL 74332 0 2
// repeat wait ( 0 0$1 ) ;
3367: LD_INT 35
3369: PPUSH
3370: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3374: LD_EXP 78
3378: PUSH
3379: LD_VAR 0 2
3383: ARRAY
3384: PUSH
3385: LD_INT 6
3387: GREATER
3388: IFFALSE 3367
// wait ( 0 0$20 ) ;
3390: LD_INT 700
3392: PPUSH
3393: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3397: LD_ADDR_VAR 0 5
3401: PUSH
3402: LD_INT 71
3404: PUSH
3405: LD_INT 19
3407: PUSH
3408: EMPTY
3409: LIST
3410: LIST
3411: PUSH
3412: LD_INT 91
3414: PUSH
3415: LD_INT 67
3417: PUSH
3418: EMPTY
3419: LIST
3420: LIST
3421: PUSH
3422: LD_INT 52
3424: PUSH
3425: LD_INT 44
3427: PUSH
3428: EMPTY
3429: LIST
3430: LIST
3431: PUSH
3432: LD_INT 68
3434: PUSH
3435: LD_INT 48
3437: PUSH
3438: EMPTY
3439: LIST
3440: LIST
3441: PUSH
3442: EMPTY
3443: LIST
3444: LIST
3445: LIST
3446: LIST
3447: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3448: LD_ADDR_VAR 0 6
3452: PUSH
3453: LD_EXP 78
3457: PUSH
3458: LD_VAR 0 2
3462: ARRAY
3463: PUSH
3464: LD_EXP 78
3468: PUSH
3469: LD_VAR 0 2
3473: ARRAY
3474: PPUSH
3475: LD_INT 2
3477: PUSH
3478: LD_INT 34
3480: PUSH
3481: LD_INT 51
3483: PUSH
3484: EMPTY
3485: LIST
3486: LIST
3487: PUSH
3488: LD_INT 34
3490: PUSH
3491: LD_INT 52
3493: PUSH
3494: EMPTY
3495: LIST
3496: LIST
3497: PUSH
3498: EMPTY
3499: LIST
3500: LIST
3501: LIST
3502: PPUSH
3503: CALL_OW 72
3507: DIFF
3508: ST_TO_ADDR
// if not attackers then
3509: LD_VAR 0 6
3513: NOT
3514: IFFALSE 3518
// exit ;
3516: GO 3687
// ru_attackers := attackers ;
3518: LD_ADDR_EXP 52
3522: PUSH
3523: LD_VAR 0 6
3527: ST_TO_ADDR
// for i = 1 to attackers do
3528: LD_ADDR_VAR 0 1
3532: PUSH
3533: DOUBLE
3534: LD_INT 1
3536: DEC
3537: ST_TO_ADDR
3538: LD_VAR 0 6
3542: PUSH
3543: FOR_TO
3544: IFFALSE 3621
// begin case i mod 3 of 0 :
3546: LD_VAR 0 1
3550: PUSH
3551: LD_INT 3
3553: MOD
3554: PUSH
3555: LD_INT 0
3557: DOUBLE
3558: EQUAL
3559: IFTRUE 3563
3561: GO 3566
3563: POP
// ; 1 :
3564: GO 3619
3566: LD_INT 1
3568: DOUBLE
3569: EQUAL
3570: IFTRUE 3574
3572: GO 3592
3574: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3575: LD_VAR 0 1
3579: PPUSH
3580: LD_INT 32
3582: PPUSH
3583: LD_INT 49
3585: PPUSH
3586: CALL_OW 114
3590: GO 3619
3592: LD_INT 2
3594: DOUBLE
3595: EQUAL
3596: IFTRUE 3600
3598: GO 3618
3600: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3601: LD_VAR 0 1
3605: PPUSH
3606: LD_INT 117
3608: PPUSH
3609: LD_INT 107
3611: PPUSH
3612: CALL_OW 114
3616: GO 3619
3618: POP
// end ;
3619: GO 3543
3621: POP
3622: POP
// repeat wait ( 0 0$1 ) ;
3623: LD_INT 35
3625: PPUSH
3626: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3630: LD_VAR 0 6
3634: PPUSH
3635: LD_INT 60
3637: PUSH
3638: EMPTY
3639: LIST
3640: PPUSH
3641: CALL_OW 72
3645: NOT
3646: IFFALSE 3623
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3648: LD_VAR 0 2
3652: PPUSH
3653: LD_VAR 0 6
3657: PPUSH
3658: LD_VAR 0 5
3662: PPUSH
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL 74517 0 4
// if not first_attack then
3672: LD_EXP 7
3676: NOT
3677: IFFALSE 3687
// first_attack := true ;
3679: LD_ADDR_EXP 7
3683: PUSH
3684: LD_INT 1
3686: ST_TO_ADDR
// end ; end_of_file
3687: PPOPN 6
3689: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3690: LD_INT 0
3692: PPUSH
3693: PPUSH
3694: PPUSH
3695: PPUSH
3696: PPUSH
3697: PPUSH
3698: PPUSH
// uc_side := 2 ;
3699: LD_ADDR_OWVAR 20
3703: PUSH
3704: LD_INT 2
3706: ST_TO_ADDR
// uc_nation := 2 ;
3707: LD_ADDR_OWVAR 21
3711: PUSH
3712: LD_INT 2
3714: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3715: LD_ADDR_EXP 55
3719: PUSH
3720: LD_STRING Abdul
3722: PPUSH
3723: CALL_OW 25
3727: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3728: LD_EXP 55
3732: PPUSH
3733: LD_INT 11
3735: PPUSH
3736: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3740: LD_EXP 55
3744: PPUSH
3745: LD_INT 1
3747: PPUSH
3748: CALL_OW 52
// vc_chassis := 31 ;
3752: LD_ADDR_OWVAR 37
3756: PUSH
3757: LD_INT 31
3759: ST_TO_ADDR
// vc_control := control_rider ;
3760: LD_ADDR_OWVAR 38
3764: PUSH
3765: LD_INT 4
3767: ST_TO_ADDR
// mastodont := CreateVehicle ;
3768: LD_ADDR_EXP 56
3772: PUSH
3773: CALL_OW 45
3777: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3778: LD_EXP 56
3782: PPUSH
3783: LD_INT 153
3785: PPUSH
3786: LD_INT 71
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// InitVc ;
3796: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3800: LD_ADDR_EXP 53
3804: PUSH
3805: LD_INT 1
3807: PPUSH
3808: LD_INT 3
3810: PPUSH
3811: LD_STRING 
3813: PPUSH
3814: LD_INT 7
3816: PUSH
3817: LD_INT 8
3819: PUSH
3820: LD_INT 9
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PUSH
3828: LD_OWVAR 67
3832: ARRAY
3833: PPUSH
3834: LD_INT 5000
3836: PUSH
3837: LD_INT 1000
3839: PUSH
3840: LD_INT 300
3842: PUSH
3843: EMPTY
3844: LIST
3845: LIST
3846: LIST
3847: PPUSH
3848: LD_INT 22
3850: PUSH
3851: LD_INT 5
3853: PUSH
3854: LD_INT 6
3856: PUSH
3857: LD_INT 9
3859: PUSH
3860: EMPTY
3861: LIST
3862: LIST
3863: LIST
3864: LIST
3865: PPUSH
3866: CALL 22525 0 6
3870: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3871: LD_ADDR_EXP 59
3875: PUSH
3876: LD_EXP 59
3880: PPUSH
3881: LD_INT 1
3883: PPUSH
3884: LD_EXP 53
3888: PPUSH
3889: CALL_OW 1
3893: ST_TO_ADDR
// tmp := [ ] ;
3894: LD_ADDR_VAR 0 4
3898: PUSH
3899: EMPTY
3900: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3901: LD_ADDR_OWVAR 37
3905: PUSH
3906: LD_INT 14
3908: ST_TO_ADDR
// vc_engine := engine_siberite ;
3909: LD_ADDR_OWVAR 39
3913: PUSH
3914: LD_INT 3
3916: ST_TO_ADDR
// vc_control := control_manual ;
3917: LD_ADDR_OWVAR 38
3921: PUSH
3922: LD_INT 1
3924: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3925: LD_ADDR_OWVAR 40
3929: PUSH
3930: LD_INT 31
3932: ST_TO_ADDR
// for i = 1 to 3 do
3933: LD_ADDR_VAR 0 2
3937: PUSH
3938: DOUBLE
3939: LD_INT 1
3941: DEC
3942: ST_TO_ADDR
3943: LD_INT 3
3945: PUSH
3946: FOR_TO
3947: IFFALSE 4191
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3949: LD_ADDR_VAR 0 5
3953: PUSH
3954: LD_INT 153
3956: PUSH
3957: LD_INT 71
3959: PUSH
3960: EMPTY
3961: LIST
3962: LIST
3963: PUSH
3964: LD_INT 155
3966: PUSH
3967: LD_INT 81
3969: PUSH
3970: EMPTY
3971: LIST
3972: LIST
3973: PUSH
3974: EMPTY
3975: LIST
3976: LIST
3977: PUSH
3978: LD_VAR 0 2
3982: PUSH
3983: LD_INT 2
3985: MOD
3986: PUSH
3987: LD_INT 1
3989: PLUS
3990: ARRAY
3991: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3992: LD_INT 0
3994: PPUSH
3995: LD_INT 3
3997: PPUSH
3998: LD_INT 7
4000: PUSH
4001: LD_INT 8
4003: PUSH
4004: LD_INT 9
4006: PUSH
4007: EMPTY
4008: LIST
4009: LIST
4010: LIST
4011: PUSH
4012: LD_OWVAR 67
4016: ARRAY
4017: PPUSH
4018: CALL_OW 380
// un := CreateVehicle ;
4022: LD_ADDR_VAR 0 6
4026: PUSH
4027: CALL_OW 45
4031: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4032: LD_VAR 0 6
4036: PPUSH
4037: LD_INT 0
4039: PPUSH
4040: LD_INT 5
4042: PPUSH
4043: CALL_OW 12
4047: PPUSH
4048: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4052: LD_VAR 0 6
4056: PPUSH
4057: LD_VAR 0 5
4061: PUSH
4062: LD_INT 1
4064: ARRAY
4065: PPUSH
4066: LD_VAR 0 5
4070: PUSH
4071: LD_INT 2
4073: ARRAY
4074: PPUSH
4075: LD_INT 6
4077: PPUSH
4078: LD_INT 0
4080: PPUSH
4081: CALL_OW 50
// un2 := CreateHuman ;
4085: LD_ADDR_VAR 0 7
4089: PUSH
4090: CALL_OW 44
4094: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4095: LD_VAR 0 7
4099: PPUSH
4100: LD_VAR 0 6
4104: PPUSH
4105: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4109: LD_ADDR_EXP 59
4113: PUSH
4114: LD_EXP 59
4118: PPUSH
4119: LD_INT 1
4121: PUSH
4122: LD_EXP 59
4126: PUSH
4127: LD_INT 1
4129: ARRAY
4130: PUSH
4131: LD_INT 1
4133: PLUS
4134: PUSH
4135: EMPTY
4136: LIST
4137: LIST
4138: PPUSH
4139: LD_VAR 0 6
4143: PPUSH
4144: CALL 19238 0 3
4148: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4149: LD_ADDR_EXP 59
4153: PUSH
4154: LD_EXP 59
4158: PPUSH
4159: LD_INT 1
4161: PUSH
4162: LD_EXP 59
4166: PUSH
4167: LD_INT 1
4169: ARRAY
4170: PUSH
4171: LD_INT 1
4173: PLUS
4174: PUSH
4175: EMPTY
4176: LIST
4177: LIST
4178: PPUSH
4179: LD_VAR 0 7
4183: PPUSH
4184: CALL 19238 0 3
4188: ST_TO_ADDR
// end ;
4189: GO 3946
4191: POP
4192: POP
// for i = 1 to 5 do
4193: LD_ADDR_VAR 0 2
4197: PUSH
4198: DOUBLE
4199: LD_INT 1
4201: DEC
4202: ST_TO_ADDR
4203: LD_INT 5
4205: PUSH
4206: FOR_TO
4207: IFFALSE 4300
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4209: LD_INT 14
4211: PPUSH
4212: LD_INT 3
4214: PPUSH
4215: LD_INT 1
4217: PPUSH
4218: LD_INT 25
4220: PUSH
4221: LD_INT 28
4223: PUSH
4224: LD_INT 28
4226: PUSH
4227: LD_INT 26
4229: PUSH
4230: EMPTY
4231: LIST
4232: LIST
4233: LIST
4234: LIST
4235: PUSH
4236: LD_VAR 0 2
4240: PUSH
4241: LD_INT 4
4243: MOD
4244: PUSH
4245: LD_INT 1
4247: PLUS
4248: ARRAY
4249: PPUSH
4250: LD_INT 100
4252: PPUSH
4253: CALL 19116 0 5
// veh := CreateVehicle ;
4257: LD_ADDR_VAR 0 3
4261: PUSH
4262: CALL_OW 45
4266: ST_TO_ADDR
// tmp := tmp ^ veh ;
4267: LD_ADDR_VAR 0 4
4271: PUSH
4272: LD_VAR 0 4
4276: PUSH
4277: LD_VAR 0 3
4281: ADD
4282: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4283: LD_VAR 0 3
4287: PPUSH
4288: LD_INT 1
4290: PPUSH
4291: LD_INT 0
4293: PPUSH
4294: CALL_OW 49
// end ;
4298: GO 4206
4300: POP
4301: POP
// arabian_guard := tmp ;
4302: LD_ADDR_EXP 54
4306: PUSH
4307: LD_VAR 0 4
4311: ST_TO_ADDR
// end ;
4312: LD_VAR 0 1
4316: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4317: LD_INT 22
4319: PUSH
4320: LD_INT 7
4322: PUSH
4323: EMPTY
4324: LIST
4325: LIST
4326: PUSH
4327: LD_INT 91
4329: PUSH
4330: LD_INT 1
4332: PUSH
4333: LD_INT 12
4335: PUSH
4336: EMPTY
4337: LIST
4338: LIST
4339: LIST
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: PPUSH
4345: CALL_OW 69
4349: PUSH
4350: LD_EXP 56
4354: PPUSH
4355: CALL_OW 256
4359: PUSH
4360: LD_INT 990
4362: LESS
4363: OR
4364: PUSH
4365: LD_EXP 55
4369: PPUSH
4370: CALL_OW 256
4374: PUSH
4375: LD_INT 990
4377: LESS
4378: OR
4379: IFFALSE 4522
4381: GO 4383
4383: DISABLE
// begin if IsInUnit ( Abdul ) then
4384: LD_EXP 55
4388: PPUSH
4389: CALL_OW 310
4393: IFFALSE 4404
// ComExitBuilding ( Abdul ) ;
4395: LD_EXP 55
4399: PPUSH
4400: CALL_OW 122
// if Mastodont then
4404: LD_EXP 56
4408: IFFALSE 4425
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4410: LD_EXP 56
4414: PPUSH
4415: LD_INT 205
4417: PPUSH
4418: LD_INT 132
4420: PPUSH
4421: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4425: LD_EXP 55
4429: PPUSH
4430: LD_INT 205
4432: PPUSH
4433: LD_INT 132
4435: PPUSH
4436: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4440: LD_INT 35
4442: PPUSH
4443: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4447: LD_EXP 55
4451: PPUSH
4452: LD_INT 21
4454: PPUSH
4455: CALL_OW 308
4459: IFFALSE 4440
// RemoveUnit ( Abdul ) ;
4461: LD_EXP 55
4465: PPUSH
4466: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4470: LD_INT 35
4472: PPUSH
4473: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4477: LD_EXP 56
4481: PPUSH
4482: LD_INT 21
4484: PPUSH
4485: CALL_OW 308
4489: PUSH
4490: LD_EXP 56
4494: PPUSH
4495: CALL_OW 301
4499: OR
4500: IFFALSE 4470
// if IsOk ( Mastodont ) then
4502: LD_EXP 56
4506: PPUSH
4507: CALL_OW 302
4511: IFFALSE 4522
// RemoveUnit ( Mastodont ) ;
4513: LD_EXP 56
4517: PPUSH
4518: CALL_OW 64
// end ;
4522: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4523: LD_EXP 55
4527: PPUSH
4528: CALL_OW 301
4532: PUSH
4533: LD_INT 22
4535: PUSH
4536: LD_INT 2
4538: PUSH
4539: EMPTY
4540: LIST
4541: LIST
4542: PUSH
4543: LD_INT 2
4545: PUSH
4546: LD_INT 25
4548: PUSH
4549: LD_INT 1
4551: PUSH
4552: EMPTY
4553: LIST
4554: LIST
4555: PUSH
4556: LD_INT 25
4558: PUSH
4559: LD_INT 2
4561: PUSH
4562: EMPTY
4563: LIST
4564: LIST
4565: PUSH
4566: LD_INT 25
4568: PUSH
4569: LD_INT 3
4571: PUSH
4572: EMPTY
4573: LIST
4574: LIST
4575: PUSH
4576: LD_INT 25
4578: PUSH
4579: LD_INT 4
4581: PUSH
4582: EMPTY
4583: LIST
4584: LIST
4585: PUSH
4586: LD_INT 25
4588: PUSH
4589: LD_INT 8
4591: PUSH
4592: EMPTY
4593: LIST
4594: LIST
4595: PUSH
4596: EMPTY
4597: LIST
4598: LIST
4599: LIST
4600: LIST
4601: LIST
4602: LIST
4603: PUSH
4604: EMPTY
4605: LIST
4606: LIST
4607: PPUSH
4608: CALL_OW 69
4612: PUSH
4613: LD_INT 16
4615: PUSH
4616: LD_INT 19
4618: PUSH
4619: LD_INT 22
4621: PUSH
4622: EMPTY
4623: LIST
4624: LIST
4625: LIST
4626: PUSH
4627: LD_OWVAR 67
4631: ARRAY
4632: LESS
4633: OR
4634: IFFALSE 5307
4636: GO 4638
4638: DISABLE
4639: LD_INT 0
4641: PPUSH
4642: PPUSH
4643: PPUSH
4644: PPUSH
4645: PPUSH
4646: PPUSH
// begin MC_Kill ( 1 ) ;
4647: LD_INT 1
4649: PPUSH
4650: CALL 50888 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4654: LD_ADDR_VAR 0 2
4658: PUSH
4659: LD_INT 22
4661: PUSH
4662: LD_INT 2
4664: PUSH
4665: EMPTY
4666: LIST
4667: LIST
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: LD_INT 25
4674: PUSH
4675: LD_INT 1
4677: PUSH
4678: EMPTY
4679: LIST
4680: LIST
4681: PUSH
4682: LD_INT 25
4684: PUSH
4685: LD_INT 2
4687: PUSH
4688: EMPTY
4689: LIST
4690: LIST
4691: PUSH
4692: LD_INT 25
4694: PUSH
4695: LD_INT 3
4697: PUSH
4698: EMPTY
4699: LIST
4700: LIST
4701: PUSH
4702: LD_INT 25
4704: PUSH
4705: LD_INT 4
4707: PUSH
4708: EMPTY
4709: LIST
4710: LIST
4711: PUSH
4712: LD_INT 25
4714: PUSH
4715: LD_INT 8
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PUSH
4722: EMPTY
4723: LIST
4724: LIST
4725: LIST
4726: LIST
4727: LIST
4728: LIST
4729: PUSH
4730: EMPTY
4731: LIST
4732: LIST
4733: PPUSH
4734: CALL_OW 69
4738: ST_TO_ADDR
// for i in tmp do
4739: LD_ADDR_VAR 0 5
4743: PUSH
4744: LD_VAR 0 2
4748: PUSH
4749: FOR_IN
4750: IFFALSE 4766
// SetTag ( i , 10 ) ;
4752: LD_VAR 0 5
4756: PPUSH
4757: LD_INT 10
4759: PPUSH
4760: CALL_OW 109
4764: GO 4749
4766: POP
4767: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4768: LD_ADDR_VAR 0 3
4772: PUSH
4773: LD_INT 22
4775: PUSH
4776: LD_INT 2
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: PUSH
4783: LD_INT 21
4785: PUSH
4786: LD_INT 1
4788: PUSH
4789: EMPTY
4790: LIST
4791: LIST
4792: PUSH
4793: EMPTY
4794: LIST
4795: LIST
4796: PPUSH
4797: CALL_OW 69
4801: PUSH
4802: LD_VAR 0 2
4806: DIFF
4807: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4808: LD_ADDR_VAR 0 1
4812: PUSH
4813: LD_INT 22
4815: PUSH
4816: LD_INT 2
4818: PUSH
4819: EMPTY
4820: LIST
4821: LIST
4822: PUSH
4823: LD_INT 21
4825: PUSH
4826: LD_INT 2
4828: PUSH
4829: EMPTY
4830: LIST
4831: LIST
4832: PUSH
4833: LD_INT 24
4835: PUSH
4836: LD_INT 300
4838: PUSH
4839: EMPTY
4840: LIST
4841: LIST
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: LIST
4847: PPUSH
4848: CALL_OW 69
4852: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4853: LD_ADDR_VAR 0 4
4857: PUSH
4858: LD_VAR 0 1
4862: PPUSH
4863: LD_INT 33
4865: PUSH
4866: LD_INT 1
4868: PUSH
4869: EMPTY
4870: LIST
4871: LIST
4872: PUSH
4873: LD_INT 58
4875: PUSH
4876: EMPTY
4877: LIST
4878: PUSH
4879: EMPTY
4880: LIST
4881: LIST
4882: PPUSH
4883: CALL_OW 72
4887: ST_TO_ADDR
// for i in tmp do
4888: LD_ADDR_VAR 0 5
4892: PUSH
4893: LD_VAR 0 2
4897: PUSH
4898: FOR_IN
4899: IFFALSE 5083
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4901: LD_VAR 0 5
4905: PUSH
4906: LD_INT 55
4908: PUSH
4909: EMPTY
4910: LIST
4911: PPUSH
4912: CALL_OW 69
4916: IN
4917: IFFALSE 4936
// begin AddComMoveXY ( i , 209 , 132 ) ;
4919: LD_VAR 0 5
4923: PPUSH
4924: LD_INT 209
4926: PPUSH
4927: LD_INT 132
4929: PPUSH
4930: CALL_OW 171
// continue ;
4934: GO 4898
// end ; if IsInUnit ( i ) then
4936: LD_VAR 0 5
4940: PPUSH
4941: CALL_OW 310
4945: IFFALSE 4963
// begin ComExitBuilding ( i ) ;
4947: LD_VAR 0 5
4951: PPUSH
4952: CALL_OW 122
// wait ( 3 ) ;
4956: LD_INT 3
4958: PPUSH
4959: CALL_OW 67
// end ; if tmp_empty then
4963: LD_VAR 0 4
4967: IFFALSE 5066
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4969: LD_VAR 0 5
4973: PPUSH
4974: LD_VAR 0 4
4978: PPUSH
4979: LD_VAR 0 5
4983: PPUSH
4984: CALL_OW 74
4988: PPUSH
4989: CALL_OW 296
4993: PUSH
4994: LD_INT 25
4996: LESS
4997: IFFALSE 5066
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4999: LD_ADDR_VAR 0 6
5003: PUSH
5004: LD_VAR 0 4
5008: PPUSH
5009: LD_VAR 0 5
5013: PPUSH
5014: CALL_OW 74
5018: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5019: LD_VAR 0 5
5023: PPUSH
5024: LD_VAR 0 6
5028: PPUSH
5029: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5033: LD_VAR 0 5
5037: PPUSH
5038: LD_INT 209
5040: PPUSH
5041: LD_INT 132
5043: PPUSH
5044: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5048: LD_ADDR_VAR 0 4
5052: PUSH
5053: LD_VAR 0 4
5057: PUSH
5058: LD_VAR 0 6
5062: DIFF
5063: ST_TO_ADDR
// continue ;
5064: GO 4898
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5066: LD_VAR 0 5
5070: PPUSH
5071: LD_INT 201
5073: PPUSH
5074: LD_INT 132
5076: PPUSH
5077: CALL_OW 171
// end ;
5081: GO 4898
5083: POP
5084: POP
// for i in tmp_ape do
5085: LD_ADDR_VAR 0 5
5089: PUSH
5090: LD_VAR 0 3
5094: PUSH
5095: FOR_IN
5096: IFFALSE 5135
// begin if IsInUnit ( i ) then
5098: LD_VAR 0 5
5102: PPUSH
5103: CALL_OW 310
5107: IFFALSE 5118
// ComExitBuilding ( i ) ;
5109: LD_VAR 0 5
5113: PPUSH
5114: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5118: LD_VAR 0 5
5122: PPUSH
5123: LD_INT 201
5125: PPUSH
5126: LD_INT 132
5128: PPUSH
5129: CALL_OW 171
// end ;
5133: GO 5095
5135: POP
5136: POP
// repeat wait ( 0 0$1 ) ;
5137: LD_INT 35
5139: PPUSH
5140: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5144: LD_ADDR_VAR 0 5
5148: PUSH
5149: LD_VAR 0 2
5153: PUSH
5154: LD_VAR 0 3
5158: UNION
5159: PUSH
5160: LD_VAR 0 1
5164: UNION
5165: PUSH
5166: FOR_IN
5167: IFFALSE 5198
// if not HasTask ( i ) then
5169: LD_VAR 0 5
5173: PPUSH
5174: CALL_OW 314
5178: NOT
5179: IFFALSE 5196
// ComMoveXY ( i , 201 , 132 ) ;
5181: LD_VAR 0 5
5185: PPUSH
5186: LD_INT 201
5188: PPUSH
5189: LD_INT 132
5191: PPUSH
5192: CALL_OW 111
5196: GO 5166
5198: POP
5199: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5200: LD_INT 21
5202: PPUSH
5203: LD_INT 22
5205: PUSH
5206: LD_INT 2
5208: PUSH
5209: EMPTY
5210: LIST
5211: LIST
5212: PPUSH
5213: CALL_OW 70
5217: IFFALSE 5258
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5219: LD_ADDR_VAR 0 5
5223: PUSH
5224: LD_INT 21
5226: PPUSH
5227: LD_INT 22
5229: PUSH
5230: LD_INT 2
5232: PUSH
5233: EMPTY
5234: LIST
5235: LIST
5236: PPUSH
5237: CALL_OW 70
5241: PUSH
5242: FOR_IN
5243: IFFALSE 5256
// RemoveUnit ( i ) ;
5245: LD_VAR 0 5
5249: PPUSH
5250: CALL_OW 64
5254: GO 5242
5256: POP
5257: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5258: LD_INT 22
5260: PUSH
5261: LD_INT 2
5263: PUSH
5264: EMPTY
5265: LIST
5266: LIST
5267: PUSH
5268: LD_INT 2
5270: PUSH
5271: LD_INT 21
5273: PUSH
5274: LD_INT 1
5276: PUSH
5277: EMPTY
5278: LIST
5279: LIST
5280: PUSH
5281: LD_INT 21
5283: PUSH
5284: LD_INT 2
5286: PUSH
5287: EMPTY
5288: LIST
5289: LIST
5290: PUSH
5291: EMPTY
5292: LIST
5293: LIST
5294: LIST
5295: PUSH
5296: EMPTY
5297: LIST
5298: LIST
5299: PPUSH
5300: CALL_OW 69
5304: NOT
5305: IFFALSE 5137
// end ;
5307: PPOPN 6
5309: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5310: LD_EXP 9
5314: PUSH
5315: LD_INT 92
5317: PPUSH
5318: LD_INT 40
5320: PPUSH
5321: CALL_OW 428
5325: PPUSH
5326: CALL_OW 266
5330: PUSH
5331: LD_INT 30
5333: EQUAL
5334: AND
5335: IFFALSE 5531
5337: GO 5339
5339: DISABLE
5340: LD_INT 0
5342: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5343: LD_ADDR_VAR 0 1
5347: PUSH
5348: LD_EXP 59
5352: PUSH
5353: LD_INT 1
5355: ARRAY
5356: PPUSH
5357: LD_INT 25
5359: PUSH
5360: LD_INT 4
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PPUSH
5367: CALL_OW 72
5371: ST_TO_ADDR
// if not sci then
5372: LD_VAR 0 1
5376: NOT
5377: IFFALSE 5381
// exit ;
5379: GO 5531
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5381: LD_ADDR_EXP 59
5385: PUSH
5386: LD_EXP 59
5390: PPUSH
5391: LD_INT 1
5393: PPUSH
5394: LD_EXP 59
5398: PUSH
5399: LD_INT 1
5401: ARRAY
5402: PUSH
5403: LD_VAR 0 1
5407: PUSH
5408: LD_INT 1
5410: ARRAY
5411: DIFF
5412: PPUSH
5413: CALL_OW 1
5417: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5418: LD_VAR 0 1
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PPUSH
5427: CALL_OW 310
5431: IFFALSE 5446
// ComExitBuilding ( sci [ 1 ] ) ;
5433: LD_VAR 0 1
5437: PUSH
5438: LD_INT 1
5440: ARRAY
5441: PPUSH
5442: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5446: LD_INT 2
5448: PPUSH
5449: LD_INT 105
5451: PPUSH
5452: LD_INT 14
5454: PPUSH
5455: LD_INT 20
5457: PPUSH
5458: CALL 20134 0 4
5462: PUSH
5463: LD_INT 4
5465: ARRAY
5466: PUSH
5467: LD_INT 10
5469: LESS
5470: IFFALSE 5493
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5472: LD_VAR 0 1
5476: PUSH
5477: LD_INT 1
5479: ARRAY
5480: PPUSH
5481: LD_INT 105
5483: PPUSH
5484: LD_INT 14
5486: PPUSH
5487: CALL_OW 171
5491: GO 5512
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5493: LD_VAR 0 1
5497: PUSH
5498: LD_INT 1
5500: ARRAY
5501: PPUSH
5502: LD_INT 118
5504: PPUSH
5505: LD_INT 77
5507: PPUSH
5508: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5512: LD_VAR 0 1
5516: PUSH
5517: LD_INT 1
5519: ARRAY
5520: PPUSH
5521: LD_INT 92
5523: PPUSH
5524: LD_INT 40
5526: PPUSH
5527: CALL_OW 218
// end ;
5531: PPOPN 1
5533: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5534: LD_INT 1
5536: PPUSH
5537: CALL_OW 302
5541: PUSH
5542: LD_EXP 9
5546: AND
5547: IFFALSE 6006
5549: GO 5551
5551: DISABLE
5552: LD_INT 0
5554: PPUSH
5555: PPUSH
5556: PPUSH
5557: PPUSH
5558: PPUSH
5559: PPUSH
// begin enable ;
5560: ENABLE
// base := 1 ;
5561: LD_ADDR_VAR 0 2
5565: PUSH
5566: LD_INT 1
5568: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5569: LD_ADDR_VAR 0 4
5573: PUSH
5574: LD_INT 0
5576: PUSH
5577: LD_INT 0
5579: PUSH
5580: LD_INT 0
5582: PUSH
5583: LD_INT 0
5585: PUSH
5586: LD_INT 0
5588: PUSH
5589: LD_INT 0
5591: PUSH
5592: LD_INT 0
5594: PUSH
5595: LD_INT 0
5597: PUSH
5598: LD_INT 1
5600: PUSH
5601: LD_INT 0
5603: PUSH
5604: EMPTY
5605: LIST
5606: LIST
5607: LIST
5608: LIST
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: LIST
5614: LIST
5615: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5616: LD_ADDR_VAR 0 3
5620: PUSH
5621: LD_INT 14
5623: PUSH
5624: LD_INT 1
5626: PUSH
5627: LD_INT 2
5629: PUSH
5630: LD_INT 26
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: PUSH
5639: LD_INT 14
5641: PUSH
5642: LD_INT 1
5644: PUSH
5645: LD_INT 2
5647: PUSH
5648: LD_INT 28
5650: PUSH
5651: EMPTY
5652: LIST
5653: LIST
5654: LIST
5655: LIST
5656: PUSH
5657: LD_INT 13
5659: PUSH
5660: LD_INT 1
5662: PUSH
5663: LD_INT 2
5665: PUSH
5666: LD_INT 29
5668: PUSH
5669: EMPTY
5670: LIST
5671: LIST
5672: LIST
5673: LIST
5674: PUSH
5675: EMPTY
5676: LIST
5677: LIST
5678: LIST
5679: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5680: LD_ADDR_VAR 0 1
5684: PUSH
5685: DOUBLE
5686: LD_INT 1
5688: DEC
5689: ST_TO_ADDR
5690: LD_OWVAR 67
5694: PUSH
5695: LD_OWVAR 1
5699: PUSH
5700: LD_INT 21000
5702: DIV
5703: PLUS
5704: PUSH
5705: FOR_TO
5706: IFFALSE 5798
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5708: LD_ADDR_VAR 0 3
5712: PUSH
5713: LD_VAR 0 3
5717: PPUSH
5718: LD_VAR 0 3
5722: PUSH
5723: LD_INT 1
5725: PLUS
5726: PPUSH
5727: LD_INT 13
5729: PUSH
5730: LD_INT 14
5732: PUSH
5733: EMPTY
5734: LIST
5735: LIST
5736: PUSH
5737: LD_INT 1
5739: PPUSH
5740: LD_INT 2
5742: PPUSH
5743: CALL_OW 12
5747: ARRAY
5748: PUSH
5749: LD_INT 1
5751: PUSH
5752: LD_INT 2
5754: PUSH
5755: LD_INT 28
5757: PUSH
5758: LD_INT 29
5760: PUSH
5761: LD_INT 25
5763: PUSH
5764: LD_INT 26
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: LIST
5771: LIST
5772: PUSH
5773: LD_INT 1
5775: PPUSH
5776: LD_INT 4
5778: PPUSH
5779: CALL_OW 12
5783: ARRAY
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: LIST
5789: LIST
5790: PPUSH
5791: CALL_OW 2
5795: ST_TO_ADDR
5796: GO 5705
5798: POP
5799: POP
// MC_InsertProduceList ( base , tmp ) ;
5800: LD_VAR 0 2
5804: PPUSH
5805: LD_VAR 0 3
5809: PPUSH
5810: CALL 74332 0 2
// repeat wait ( 0 0$1 ) ;
5814: LD_INT 35
5816: PPUSH
5817: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5821: LD_EXP 78
5825: PUSH
5826: LD_VAR 0 2
5830: ARRAY
5831: PUSH
5832: LD_INT 6
5834: GREATER
5835: IFFALSE 5814
// wait ( 0 0$20 ) ;
5837: LD_INT 700
5839: PPUSH
5840: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5844: LD_ADDR_VAR 0 5
5848: PUSH
5849: LD_INT 124
5851: PUSH
5852: LD_INT 85
5854: PUSH
5855: EMPTY
5856: LIST
5857: LIST
5858: PUSH
5859: LD_INT 90
5861: PUSH
5862: LD_INT 61
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: PUSH
5869: LD_INT 69
5871: PUSH
5872: LD_INT 48
5874: PUSH
5875: EMPTY
5876: LIST
5877: LIST
5878: PUSH
5879: LD_INT 68
5881: PUSH
5882: LD_INT 48
5884: PUSH
5885: EMPTY
5886: LIST
5887: LIST
5888: PUSH
5889: EMPTY
5890: LIST
5891: LIST
5892: LIST
5893: LIST
5894: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5895: LD_ADDR_VAR 0 6
5899: PUSH
5900: LD_EXP 78
5904: PUSH
5905: LD_VAR 0 2
5909: ARRAY
5910: PUSH
5911: LD_EXP 78
5915: PUSH
5916: LD_VAR 0 2
5920: ARRAY
5921: PPUSH
5922: LD_INT 34
5924: PUSH
5925: LD_INT 32
5927: PUSH
5928: EMPTY
5929: LIST
5930: LIST
5931: PPUSH
5932: CALL_OW 72
5936: DIFF
5937: ST_TO_ADDR
// if not attackers then
5938: LD_VAR 0 6
5942: NOT
5943: IFFALSE 5947
// exit ;
5945: GO 6006
// ar_attackers := attackers ;
5947: LD_ADDR_EXP 10
5951: PUSH
5952: LD_VAR 0 6
5956: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5957: LD_INT 35
5959: PPUSH
5960: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5964: LD_VAR 0 6
5968: PPUSH
5969: LD_INT 60
5971: PUSH
5972: EMPTY
5973: LIST
5974: PPUSH
5975: CALL_OW 72
5979: NOT
5980: IFFALSE 5957
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5982: LD_VAR 0 2
5986: PPUSH
5987: LD_VAR 0 6
5991: PPUSH
5992: LD_VAR 0 5
5996: PPUSH
5997: LD_VAR 0 4
6001: PPUSH
6002: CALL 74517 0 4
// end ;
6006: PPOPN 6
6008: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6009: LD_INT 1
6011: PPUSH
6012: CALL_OW 302
6016: PUSH
6017: LD_EXP 9
6021: AND
6022: PUSH
6023: LD_EXP 49
6027: PPUSH
6028: LD_INT 22
6030: PPUSH
6031: CALL_OW 308
6035: AND
6036: PUSH
6037: LD_INT 1
6039: PPUSH
6040: CALL 74680 0 1
6044: PUSH
6045: LD_INT 0
6047: EQUAL
6048: AND
6049: PUSH
6050: LD_EXP 10
6054: NOT
6055: AND
6056: IFFALSE 6520
6058: GO 6060
6060: DISABLE
6061: LD_INT 0
6063: PPUSH
6064: PPUSH
6065: PPUSH
6066: PPUSH
6067: PPUSH
6068: PPUSH
6069: PPUSH
// begin base := 1 ;
6070: LD_ADDR_VAR 0 2
6074: PUSH
6075: LD_INT 1
6077: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6078: LD_ADDR_VAR 0 4
6082: PUSH
6083: LD_INT 0
6085: PUSH
6086: LD_INT 0
6088: PUSH
6089: LD_INT 0
6091: PUSH
6092: LD_INT 0
6094: PUSH
6095: LD_INT 0
6097: PUSH
6098: LD_INT 0
6100: PUSH
6101: LD_INT 0
6103: PUSH
6104: LD_INT 0
6106: PUSH
6107: LD_INT 1
6109: PUSH
6110: LD_INT 0
6112: PUSH
6113: EMPTY
6114: LIST
6115: LIST
6116: LIST
6117: LIST
6118: LIST
6119: LIST
6120: LIST
6121: LIST
6122: LIST
6123: LIST
6124: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6125: LD_ADDR_VAR 0 3
6129: PUSH
6130: LD_INT 13
6132: PUSH
6133: LD_INT 1
6135: PUSH
6136: LD_INT 2
6138: PUSH
6139: LD_INT 28
6141: PUSH
6142: EMPTY
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 13
6150: PUSH
6151: LD_INT 1
6153: PUSH
6154: LD_INT 2
6156: PUSH
6157: LD_INT 27
6159: PUSH
6160: EMPTY
6161: LIST
6162: LIST
6163: LIST
6164: LIST
6165: PUSH
6166: LD_INT 13
6168: PUSH
6169: LD_INT 1
6171: PUSH
6172: LD_INT 2
6174: PUSH
6175: LD_INT 25
6177: PUSH
6178: EMPTY
6179: LIST
6180: LIST
6181: LIST
6182: LIST
6183: PUSH
6184: LD_INT 11
6186: PUSH
6187: LD_INT 2
6189: PUSH
6190: LD_INT 2
6192: PUSH
6193: LD_INT 24
6195: PUSH
6196: EMPTY
6197: LIST
6198: LIST
6199: LIST
6200: LIST
6201: PUSH
6202: LD_INT 11
6204: PUSH
6205: LD_INT 2
6207: PUSH
6208: LD_INT 2
6210: PUSH
6211: LD_INT 24
6213: PUSH
6214: EMPTY
6215: LIST
6216: LIST
6217: LIST
6218: LIST
6219: PUSH
6220: EMPTY
6221: LIST
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6227: LD_VAR 0 2
6231: PPUSH
6232: LD_VAR 0 3
6236: PPUSH
6237: CALL 74332 0 2
// repeat wait ( 0 0$1 ) ;
6241: LD_INT 35
6243: PPUSH
6244: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6248: LD_EXP 78
6252: PUSH
6253: LD_VAR 0 2
6257: ARRAY
6258: PUSH
6259: LD_INT 6
6261: GREATEREQUAL
6262: IFFALSE 6241
// wait ( 0 0$20 ) ;
6264: LD_INT 700
6266: PPUSH
6267: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6271: LD_ADDR_VAR 0 5
6275: PUSH
6276: LD_INT 119
6278: PUSH
6279: LD_INT 9
6281: PUSH
6282: EMPTY
6283: LIST
6284: LIST
6285: PUSH
6286: EMPTY
6287: LIST
6288: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6289: LD_ADDR_VAR 0 6
6293: PUSH
6294: LD_EXP 78
6298: PUSH
6299: LD_VAR 0 2
6303: ARRAY
6304: PUSH
6305: LD_EXP 78
6309: PUSH
6310: LD_VAR 0 2
6314: ARRAY
6315: PPUSH
6316: LD_INT 34
6318: PUSH
6319: LD_INT 32
6321: PUSH
6322: EMPTY
6323: LIST
6324: LIST
6325: PPUSH
6326: CALL_OW 72
6330: DIFF
6331: ST_TO_ADDR
// if not attackers then
6332: LD_VAR 0 6
6336: NOT
6337: IFFALSE 6341
// exit ;
6339: GO 6520
// uc_side := 2 ;
6341: LD_ADDR_OWVAR 20
6345: PUSH
6346: LD_INT 2
6348: ST_TO_ADDR
// uc_nation := 2 ;
6349: LD_ADDR_OWVAR 21
6353: PUSH
6354: LD_INT 2
6356: ST_TO_ADDR
// InitHc ;
6357: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6361: LD_ADDR_VAR 0 1
6365: PUSH
6366: DOUBLE
6367: LD_INT 1
6369: DEC
6370: ST_TO_ADDR
6371: LD_INT 4
6373: PUSH
6374: LD_INT 5
6376: PUSH
6377: LD_INT 6
6379: PUSH
6380: EMPTY
6381: LIST
6382: LIST
6383: LIST
6384: PUSH
6385: LD_OWVAR 67
6389: ARRAY
6390: PUSH
6391: FOR_TO
6392: IFFALSE 6469
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6394: LD_INT 0
6396: PPUSH
6397: LD_INT 15
6399: PUSH
6400: LD_INT 17
6402: PUSH
6403: EMPTY
6404: LIST
6405: LIST
6406: PUSH
6407: LD_INT 1
6409: PPUSH
6410: LD_INT 2
6412: PPUSH
6413: CALL_OW 12
6417: ARRAY
6418: PPUSH
6419: LD_INT 8
6421: PPUSH
6422: CALL_OW 380
// un := CreateHuman ;
6426: LD_ADDR_VAR 0 7
6430: PUSH
6431: CALL_OW 44
6435: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6436: LD_VAR 0 7
6440: PPUSH
6441: LD_INT 23
6443: PPUSH
6444: LD_INT 0
6446: PPUSH
6447: CALL_OW 49
// attackers := attackers union un ;
6451: LD_ADDR_VAR 0 6
6455: PUSH
6456: LD_VAR 0 6
6460: PUSH
6461: LD_VAR 0 7
6465: UNION
6466: ST_TO_ADDR
// end ;
6467: GO 6391
6469: POP
6470: POP
// repeat wait ( 0 0$1 ) ;
6471: LD_INT 35
6473: PPUSH
6474: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6478: LD_VAR 0 6
6482: PPUSH
6483: LD_INT 60
6485: PUSH
6486: EMPTY
6487: LIST
6488: PPUSH
6489: CALL_OW 72
6493: NOT
6494: IFFALSE 6471
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6496: LD_VAR 0 2
6500: PPUSH
6501: LD_VAR 0 6
6505: PPUSH
6506: LD_VAR 0 5
6510: PPUSH
6511: LD_VAR 0 4
6515: PPUSH
6516: CALL 74517 0 4
// end ; end_of_file
6520: PPOPN 7
6522: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6523: LD_INT 0
6525: PPUSH
6526: PPUSH
6527: PPUSH
6528: PPUSH
// uc_side := 1 ;
6529: LD_ADDR_OWVAR 20
6533: PUSH
6534: LD_INT 1
6536: ST_TO_ADDR
// uc_nation := 1 ;
6537: LD_ADDR_OWVAR 21
6541: PUSH
6542: LD_INT 1
6544: ST_TO_ADDR
// InitHc ;
6545: CALL_OW 19
// InitVc ;
6549: CALL_OW 20
// tmp := [ ] ;
6553: LD_ADDR_VAR 0 3
6557: PUSH
6558: EMPTY
6559: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6560: LD_ADDR_VAR 0 2
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 5
6572: PUSH
6573: LD_INT 6
6575: PUSH
6576: LD_INT 6
6578: PUSH
6579: EMPTY
6580: LIST
6581: LIST
6582: LIST
6583: PUSH
6584: LD_OWVAR 67
6588: ARRAY
6589: PUSH
6590: FOR_TO
6591: IFFALSE 6728
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6593: LD_INT 2
6595: PUSH
6596: LD_INT 4
6598: PUSH
6599: LD_INT 5
6601: PUSH
6602: EMPTY
6603: LIST
6604: LIST
6605: LIST
6606: PUSH
6607: LD_INT 1
6609: PPUSH
6610: LD_INT 3
6612: PPUSH
6613: CALL_OW 12
6617: ARRAY
6618: PPUSH
6619: LD_INT 1
6621: PUSH
6622: LD_INT 3
6624: PUSH
6625: EMPTY
6626: LIST
6627: LIST
6628: PUSH
6629: LD_INT 1
6631: PPUSH
6632: LD_INT 2
6634: PPUSH
6635: CALL_OW 12
6639: ARRAY
6640: PPUSH
6641: LD_INT 3
6643: PPUSH
6644: LD_INT 9
6646: PUSH
6647: LD_INT 7
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 78
6668: PPUSH
6669: CALL 19116 0 5
// veh := CreateVehicle ;
6673: LD_ADDR_VAR 0 4
6677: PUSH
6678: CALL_OW 45
6682: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6683: LD_VAR 0 4
6687: PPUSH
6688: LD_INT 2
6690: PPUSH
6691: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6695: LD_VAR 0 4
6699: PPUSH
6700: LD_INT 17
6702: PPUSH
6703: LD_INT 0
6705: PPUSH
6706: CALL_OW 49
// tmp := tmp ^ veh ;
6710: LD_ADDR_VAR 0 3
6714: PUSH
6715: LD_VAR 0 3
6719: PUSH
6720: LD_VAR 0 4
6724: ADD
6725: ST_TO_ADDR
// end ;
6726: GO 6590
6728: POP
6729: POP
// if not tmp then
6730: LD_VAR 0 3
6734: NOT
6735: IFFALSE 6739
// exit ;
6737: GO 6848
// if not first_powell_attack then
6739: LD_EXP 11
6743: NOT
6744: IFFALSE 6754
// first_powell_attack := true ;
6746: LD_ADDR_EXP 11
6750: PUSH
6751: LD_INT 1
6753: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6754: LD_INT 70
6756: PPUSH
6757: CALL_OW 67
// for i in tmp do
6761: LD_ADDR_VAR 0 2
6765: PUSH
6766: LD_VAR 0 3
6770: PUSH
6771: FOR_IN
6772: IFFALSE 6839
// if IsOk ( i ) then
6774: LD_VAR 0 2
6778: PPUSH
6779: CALL_OW 302
6783: IFFALSE 6821
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6785: LD_VAR 0 2
6789: PPUSH
6790: LD_INT 81
6792: PUSH
6793: LD_INT 1
6795: PUSH
6796: EMPTY
6797: LIST
6798: LIST
6799: PPUSH
6800: CALL_OW 69
6804: PPUSH
6805: LD_VAR 0 2
6809: PPUSH
6810: CALL_OW 74
6814: PPUSH
6815: CALL_OW 115
6819: GO 6837
// tmp := tmp diff i ;
6821: LD_ADDR_VAR 0 3
6825: PUSH
6826: LD_VAR 0 3
6830: PUSH
6831: LD_VAR 0 2
6835: DIFF
6836: ST_TO_ADDR
6837: GO 6771
6839: POP
6840: POP
// until not tmp ;
6841: LD_VAR 0 3
6845: NOT
6846: IFFALSE 6754
// end ; end_of_file
6848: LD_VAR 0 1
6852: RET
// export function Action ; var tmp , i , un ; begin
6853: LD_INT 0
6855: PPUSH
6856: PPUSH
6857: PPUSH
6858: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6859: LD_INT 68
6861: PPUSH
6862: LD_INT 39
6864: PPUSH
6865: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6869: LD_ADDR_VAR 0 2
6873: PUSH
6874: LD_INT 22
6876: PUSH
6877: LD_INT 7
6879: PUSH
6880: EMPTY
6881: LIST
6882: LIST
6883: PPUSH
6884: CALL_OW 69
6888: ST_TO_ADDR
// InGameOn ;
6889: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6893: LD_VAR 0 2
6897: PPUSH
6898: LD_INT 71
6900: PPUSH
6901: LD_INT 49
6903: PPUSH
6904: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6908: LD_INT 35
6910: PPUSH
6911: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6915: LD_INT 7
6917: PPUSH
6918: LD_INT 71
6920: PPUSH
6921: LD_INT 51
6923: PPUSH
6924: CALL_OW 293
6928: IFFALSE 6908
// DialogueOn ;
6930: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6934: LD_EXP 15
6938: PPUSH
6939: LD_STRING D1-JMM-1
6941: PPUSH
6942: CALL_OW 88
// if Joan then
6946: LD_EXP 30
6950: IFFALSE 6964
// Say ( Joan , D1-Joan-1 ) ;
6952: LD_EXP 30
6956: PPUSH
6957: LD_STRING D1-Joan-1
6959: PPUSH
6960: CALL_OW 88
// if Lisa then
6964: LD_EXP 17
6968: IFFALSE 6982
// Say ( Lisa , D1-Lisa-1 ) ;
6970: LD_EXP 17
6974: PPUSH
6975: LD_STRING D1-Lisa-1
6977: PPUSH
6978: CALL_OW 88
// if Joan or Lisa then
6982: LD_EXP 30
6986: PUSH
6987: LD_EXP 17
6991: OR
6992: IFFALSE 7006
// Say ( JMM , D1-JMM-2 ) ;
6994: LD_EXP 15
6998: PPUSH
6999: LD_STRING D1-JMM-2
7001: PPUSH
7002: CALL_OW 88
// DialogueOff ;
7006: CALL_OW 7
// InGameOff ;
7010: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7014: LD_INT 71
7016: PPUSH
7017: LD_INT 50
7019: PPUSH
7020: LD_INT 7
7022: PPUSH
7023: LD_INT 30
7025: NEG
7026: PPUSH
7027: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7031: LD_INT 71
7033: PPUSH
7034: LD_INT 50
7036: PPUSH
7037: LD_INT 7
7039: PPUSH
7040: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7044: LD_STRING M1
7046: PPUSH
7047: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7051: LD_INT 35
7053: PPUSH
7054: CALL_OW 67
// until freedom ;
7058: LD_EXP 3
7062: IFFALSE 7051
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7064: LD_INT 350
7066: PPUSH
7067: LD_INT 700
7069: PPUSH
7070: CALL_OW 12
7074: PPUSH
7075: CALL_OW 67
// PrepareGossudarov ;
7079: CALL 1802 0 0
// repeat wait ( 0 0$1 ) ;
7083: LD_INT 35
7085: PPUSH
7086: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7090: LD_INT 22
7092: PUSH
7093: LD_INT 6
7095: PUSH
7096: EMPTY
7097: LIST
7098: LIST
7099: PUSH
7100: LD_INT 3
7102: PUSH
7103: LD_INT 24
7105: PUSH
7106: LD_INT 1000
7108: PUSH
7109: EMPTY
7110: LIST
7111: LIST
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: PPUSH
7121: CALL_OW 69
7125: PUSH
7126: LD_INT 7
7128: PPUSH
7129: LD_EXP 32
7133: PPUSH
7134: CALL_OW 292
7138: OR
7139: IFFALSE 7083
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7141: LD_ADDR_VAR 0 2
7145: PUSH
7146: LD_INT 22
7148: PUSH
7149: LD_INT 6
7151: PUSH
7152: EMPTY
7153: LIST
7154: LIST
7155: PPUSH
7156: CALL_OW 69
7160: ST_TO_ADDR
// for i in tmp do
7161: LD_ADDR_VAR 0 3
7165: PUSH
7166: LD_VAR 0 2
7170: PUSH
7171: FOR_IN
7172: IFFALSE 7188
// SetSide ( i , 7 ) ;
7174: LD_VAR 0 3
7178: PPUSH
7179: LD_INT 7
7181: PPUSH
7182: CALL_OW 235
7186: GO 7171
7188: POP
7189: POP
// DialogueOn ;
7190: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7194: LD_EXP 15
7198: PUSH
7199: LD_EXP 16
7203: PUSH
7204: EMPTY
7205: LIST
7206: LIST
7207: PPUSH
7208: LD_EXP 32
7212: PPUSH
7213: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7217: LD_EXP 32
7221: PPUSH
7222: CALL_OW 87
// if not Roth then
7226: LD_EXP 16
7230: NOT
7231: IFFALSE 7323
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7233: LD_VAR 0 2
7237: PPUSH
7238: LD_INT 3
7240: PUSH
7241: LD_INT 24
7243: PUSH
7244: LD_INT 1000
7246: PUSH
7247: EMPTY
7248: LIST
7249: LIST
7250: PUSH
7251: EMPTY
7252: LIST
7253: LIST
7254: PPUSH
7255: CALL_OW 72
7259: IFFALSE 7273
// Say ( JMM , D2-JMM-1 ) ;
7261: LD_EXP 15
7265: PPUSH
7266: LD_STRING D2-JMM-1
7268: PPUSH
7269: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7273: LD_EXP 15
7277: PPUSH
7278: LD_STRING D2-JMM-1b
7280: PPUSH
7281: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7285: LD_EXP 32
7289: PPUSH
7290: LD_STRING D2-Gos-1
7292: PPUSH
7293: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7297: LD_EXP 15
7301: PPUSH
7302: LD_STRING D2-JMM-2
7304: PPUSH
7305: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7309: LD_EXP 32
7313: PPUSH
7314: LD_STRING D2-Gos-2
7316: PPUSH
7317: CALL_OW 88
// end else
7321: GO 7475
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7375
// begin Say ( Roth , D2-Roth-2 ) ;
7351: LD_EXP 16
7355: PPUSH
7356: LD_STRING D2-Roth-2
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7363: LD_EXP 15
7367: PPUSH
7368: LD_STRING D2-JMM-1a
7370: PPUSH
7371: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7375: LD_EXP 16
7379: PPUSH
7380: LD_STRING D2-Roth-2a
7382: PPUSH
7383: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7387: LD_EXP 16
7391: PPUSH
7392: LD_STRING D2-Roth-2b
7394: PPUSH
7395: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7399: LD_EXP 15
7403: PPUSH
7404: LD_STRING D2-JMM-3
7406: PPUSH
7407: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7411: LD_VAR 0 2
7415: PPUSH
7416: LD_INT 3
7418: PUSH
7419: LD_INT 24
7421: PUSH
7422: LD_INT 1000
7424: PUSH
7425: EMPTY
7426: LIST
7427: LIST
7428: PUSH
7429: EMPTY
7430: LIST
7431: LIST
7432: PPUSH
7433: CALL_OW 72
7437: IFFALSE 7475
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7439: LD_EXP 32
7443: PPUSH
7444: LD_STRING D2-Gos-3
7446: PPUSH
7447: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7451: LD_EXP 15
7455: PPUSH
7456: LD_STRING D2-JMM-4
7458: PPUSH
7459: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7463: LD_EXP 32
7467: PPUSH
7468: LD_STRING D2-Gos-4
7470: PPUSH
7471: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7475: LD_EXP 15
7479: PPUSH
7480: LD_STRING D2-JMM-5
7482: PPUSH
7483: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7487: LD_EXP 32
7491: PPUSH
7492: LD_STRING D2-Gos-5
7494: PPUSH
7495: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7499: LD_EXP 15
7503: PPUSH
7504: LD_STRING D2-JMM-6
7506: PPUSH
7507: CALL_OW 88
// DialogueOff ;
7511: CALL_OW 7
// wait ( 0 0$2 ) ;
7515: LD_INT 70
7517: PPUSH
7518: CALL_OW 67
// if Kirilenkova then
7522: LD_EXP 33
7526: IFFALSE 7540
// Say ( Kirilenkova , D3-Kir-1 ) ;
7528: LD_EXP 33
7532: PPUSH
7533: LD_STRING D3-Kir-1
7535: PPUSH
7536: CALL_OW 88
// gossudarov_arrive := true ;
7540: LD_ADDR_EXP 4
7544: PUSH
7545: LD_INT 1
7547: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7548: LD_INT 35
7550: PPUSH
7551: CALL_OW 67
// until ru_lab_builded ;
7555: LD_EXP 5
7559: IFFALSE 7548
// DialogueOn ;
7561: CALL_OW 6
// if Kirilenkova then
7565: LD_EXP 33
7569: IFFALSE 7585
// Say ( Kirilenkova , D3a-Kir-1 ) else
7571: LD_EXP 33
7575: PPUSH
7576: LD_STRING D3a-Kir-1
7578: PPUSH
7579: CALL_OW 88
7583: GO 7607
// begin un := SciRu ;
7585: LD_ADDR_VAR 0 4
7589: PUSH
7590: CALL 12719 0 0
7594: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7595: LD_VAR 0 4
7599: PPUSH
7600: LD_STRING D3a-Sci1-1
7602: PPUSH
7603: CALL_OW 88
// end ; if Kirilenkova or un then
7607: LD_EXP 33
7611: PUSH
7612: LD_VAR 0 4
7616: OR
7617: IFFALSE 7631
// Say ( JMM , D3a-JMM-1 ) ;
7619: LD_EXP 15
7623: PPUSH
7624: LD_STRING D3a-JMM-1
7626: PPUSH
7627: CALL_OW 88
// DialogueOff ;
7631: CALL_OW 7
// end ;
7635: LD_VAR 0 1
7639: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7640: LD_EXP 4
7644: PUSH
7645: LD_INT 22
7647: PUSH
7648: LD_INT 7
7650: PUSH
7651: EMPTY
7652: LIST
7653: LIST
7654: PUSH
7655: LD_INT 2
7657: PUSH
7658: LD_INT 25
7660: PUSH
7661: LD_INT 1
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: LD_INT 25
7670: PUSH
7671: LD_INT 2
7673: PUSH
7674: EMPTY
7675: LIST
7676: LIST
7677: PUSH
7678: LD_INT 25
7680: PUSH
7681: LD_INT 3
7683: PUSH
7684: EMPTY
7685: LIST
7686: LIST
7687: PUSH
7688: LD_INT 25
7690: PUSH
7691: LD_INT 4
7693: PUSH
7694: EMPTY
7695: LIST
7696: LIST
7697: PUSH
7698: LD_INT 25
7700: PUSH
7701: LD_INT 5
7703: PUSH
7704: EMPTY
7705: LIST
7706: LIST
7707: PUSH
7708: LD_INT 25
7710: PUSH
7711: LD_INT 8
7713: PUSH
7714: EMPTY
7715: LIST
7716: LIST
7717: PUSH
7718: LD_INT 25
7720: PUSH
7721: LD_INT 9
7723: PUSH
7724: EMPTY
7725: LIST
7726: LIST
7727: PUSH
7728: EMPTY
7729: LIST
7730: LIST
7731: LIST
7732: LIST
7733: LIST
7734: LIST
7735: LIST
7736: LIST
7737: PUSH
7738: EMPTY
7739: LIST
7740: LIST
7741: PPUSH
7742: CALL_OW 69
7746: PUSH
7747: LD_INT 7
7749: LESS
7750: AND
7751: IFFALSE 7763
7753: GO 7755
7755: DISABLE
// YouLost ( TooMany ) ;
7756: LD_STRING TooMany
7758: PPUSH
7759: CALL_OW 104
7763: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7764: LD_EXP 32
7768: PPUSH
7769: CALL_OW 255
7773: PUSH
7774: LD_INT 7
7776: EQUAL
7777: IFFALSE 7977
7779: GO 7781
7781: DISABLE
7782: LD_INT 0
7784: PPUSH
7785: PPUSH
7786: PPUSH
// begin uc_side := 3 ;
7787: LD_ADDR_OWVAR 20
7791: PUSH
7792: LD_INT 3
7794: ST_TO_ADDR
// uc_nation := 3 ;
7795: LD_ADDR_OWVAR 21
7799: PUSH
7800: LD_INT 3
7802: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7803: LD_INT 21
7805: PPUSH
7806: LD_INT 3
7808: PPUSH
7809: LD_INT 3
7811: PPUSH
7812: LD_INT 42
7814: PPUSH
7815: LD_INT 100
7817: PPUSH
7818: CALL 19116 0 5
// un := CreateVehicle ;
7822: LD_ADDR_VAR 0 3
7826: PUSH
7827: CALL_OW 45
7831: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7832: LD_VAR 0 3
7836: PPUSH
7837: LD_INT 15
7839: PPUSH
7840: LD_INT 0
7842: PPUSH
7843: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7847: LD_VAR 0 3
7851: PPUSH
7852: LD_INT 67
7854: PPUSH
7855: LD_INT 45
7857: PPUSH
7858: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7862: LD_VAR 0 3
7866: PPUSH
7867: LD_INT 70
7869: PPUSH
7870: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7874: LD_VAR 0 3
7878: PPUSH
7879: LD_INT 69
7881: PPUSH
7882: LD_INT 18
7884: PPUSH
7885: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7889: LD_VAR 0 3
7893: PPUSH
7894: LD_INT 60
7896: PPUSH
7897: LD_INT 2
7899: PPUSH
7900: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7904: LD_INT 35
7906: PPUSH
7907: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7911: LD_VAR 0 3
7915: PPUSH
7916: CALL_OW 302
7920: NOT
7921: PUSH
7922: LD_VAR 0 3
7926: PPUSH
7927: LD_INT 17
7929: PPUSH
7930: CALL_OW 308
7934: OR
7935: IFFALSE 7904
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7937: LD_VAR 0 3
7941: PPUSH
7942: LD_INT 17
7944: PPUSH
7945: CALL_OW 308
7949: PUSH
7950: LD_VAR 0 3
7954: PPUSH
7955: LD_INT 60
7957: PPUSH
7958: LD_INT 2
7960: PPUSH
7961: CALL_OW 307
7965: OR
7966: IFFALSE 7977
// RemoveUnit ( un ) ;
7968: LD_VAR 0 3
7972: PPUSH
7973: CALL_OW 64
// end ;
7977: PPOPN 3
7979: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
7980: LD_EXP 4
7984: IFFALSE 8226
7986: GO 7988
7988: DISABLE
7989: LD_INT 0
7991: PPUSH
7992: PPUSH
7993: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7994: LD_INT 70
7996: PPUSH
7997: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8001: LD_ADDR_VAR 0 3
8005: PUSH
8006: LD_INT 22
8008: PUSH
8009: LD_INT 7
8011: PUSH
8012: EMPTY
8013: LIST
8014: LIST
8015: PUSH
8016: LD_INT 101
8018: PUSH
8019: LD_INT 3
8021: PUSH
8022: EMPTY
8023: LIST
8024: LIST
8025: PUSH
8026: EMPTY
8027: LIST
8028: LIST
8029: PPUSH
8030: CALL_OW 69
8034: ST_TO_ADDR
// until tmp ;
8035: LD_VAR 0 3
8039: IFFALSE 7994
// un := NearestUnitToUnit ( tmp , JMM ) ;
8041: LD_ADDR_VAR 0 2
8045: PUSH
8046: LD_VAR 0 3
8050: PPUSH
8051: LD_EXP 15
8055: PPUSH
8056: CALL_OW 74
8060: ST_TO_ADDR
// player_spotted := true ;
8061: LD_ADDR_EXP 6
8065: PUSH
8066: LD_INT 1
8068: ST_TO_ADDR
// tmp := SciRu ;
8069: LD_ADDR_VAR 0 3
8073: PUSH
8074: CALL 12719 0 0
8078: ST_TO_ADDR
// if not tmp then
8079: LD_VAR 0 3
8083: NOT
8084: IFFALSE 8096
// tmp := SolRu ;
8086: LD_ADDR_VAR 0 3
8090: PUSH
8091: CALL 12866 0 0
8095: ST_TO_ADDR
// DialogueOn ;
8096: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8100: LD_VAR 0 2
8104: PPUSH
8105: CALL_OW 250
8109: PPUSH
8110: LD_VAR 0 2
8114: PPUSH
8115: CALL_OW 251
8119: PPUSH
8120: LD_INT 7
8122: PPUSH
8123: LD_INT 8
8125: NEG
8126: PPUSH
8127: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8131: LD_VAR 0 2
8135: PPUSH
8136: CALL_OW 87
// if tmp then
8140: LD_VAR 0 3
8144: IFFALSE 8158
// Say ( tmp , D4-RSci1-1 ) ;
8146: LD_VAR 0 3
8150: PPUSH
8151: LD_STRING D4-RSci1-1
8153: PPUSH
8154: CALL_OW 88
// if Gossudarov then
8158: LD_EXP 32
8162: IFFALSE 8188
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8164: LD_EXP 32
8168: PPUSH
8169: LD_STRING D4-Gos-1
8171: PPUSH
8172: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8176: LD_EXP 15
8180: PPUSH
8181: LD_STRING D4-JMM-1
8183: PPUSH
8184: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: CALL_OW 250
8197: PPUSH
8198: LD_VAR 0 2
8202: PPUSH
8203: CALL_OW 251
8207: PPUSH
8208: LD_INT 7
8210: PPUSH
8211: CALL_OW 331
// DialogueOff ;
8215: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8219: LD_STRING M5
8221: PPUSH
8222: CALL_OW 337
// end ;
8226: PPOPN 3
8228: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8229: LD_EXP 6
8233: IFFALSE 8822
8235: GO 8237
8237: DISABLE
8238: LD_INT 0
8240: PPUSH
8241: PPUSH
8242: PPUSH
// begin PrepareBelkov ;
8243: CALL 2092 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8247: LD_EXP 47
8251: PPUSH
8252: LD_INT 118
8254: PPUSH
8255: LD_INT 106
8257: PPUSH
8258: CALL_OW 111
// AddComHold ( Belkov ) ;
8262: LD_EXP 47
8266: PPUSH
8267: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8271: LD_INT 35
8273: PPUSH
8274: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8278: LD_EXP 47
8282: PPUSH
8283: LD_INT 118
8285: PPUSH
8286: LD_INT 106
8288: PPUSH
8289: CALL_OW 307
8293: IFFALSE 8271
// ChangeSideFog ( 4 , 7 ) ;
8295: LD_INT 4
8297: PPUSH
8298: LD_INT 7
8300: PPUSH
8301: CALL_OW 343
// if IsOk ( Belkov ) then
8305: LD_EXP 47
8309: PPUSH
8310: CALL_OW 302
8314: IFFALSE 8398
// begin InGameOn ;
8316: CALL_OW 8
// DialogueOn ;
8320: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8324: LD_EXP 47
8328: PPUSH
8329: LD_STRING D5-Bel-1
8331: PPUSH
8332: CALL_OW 94
// if Gossudarov then
8336: LD_EXP 32
8340: IFFALSE 8390
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8342: LD_EXP 32
8346: PPUSH
8347: LD_STRING D5-Gos-1
8349: PPUSH
8350: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8354: LD_EXP 15
8358: PPUSH
8359: LD_STRING D5-JMM-1
8361: PPUSH
8362: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8366: LD_EXP 32
8370: PPUSH
8371: LD_STRING D5-Gos-2
8373: PPUSH
8374: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8378: LD_EXP 15
8382: PPUSH
8383: LD_STRING D5-JMM-2
8385: PPUSH
8386: CALL_OW 88
// end ; DialogueOff ;
8390: CALL_OW 7
// InGameOff ;
8394: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8398: LD_STRING QSaveBelkov
8400: PPUSH
8401: CALL_OW 97
8405: PUSH
8406: LD_INT 1
8408: DOUBLE
8409: EQUAL
8410: IFTRUE 8414
8412: GO 8464
8414: POP
// begin DialogueOn ;
8415: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8419: LD_EXP 15
8423: PPUSH
8424: LD_STRING D5a-JMM-1
8426: PPUSH
8427: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8431: LD_EXP 47
8435: PPUSH
8436: LD_STRING D5a-Bel-1
8438: PPUSH
8439: CALL_OW 94
// DialogueOff ;
8443: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8447: LD_EXP 47
8451: PPUSH
8452: LD_INT 83
8454: PPUSH
8455: LD_INT 49
8457: PPUSH
8458: CALL_OW 111
// end ; 2 :
8462: GO 8497
8464: LD_INT 2
8466: DOUBLE
8467: EQUAL
8468: IFTRUE 8472
8470: GO 8496
8472: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8473: LD_EXP 15
8477: PPUSH
8478: LD_STRING D5a-JMM-2
8480: PPUSH
8481: CALL_OW 88
// ComHold ( Belkov ) ;
8485: LD_EXP 47
8489: PPUSH
8490: CALL_OW 140
// end ; end ;
8494: GO 8497
8496: POP
// time := 0 0$00 ;
8497: LD_ADDR_VAR 0 1
8501: PUSH
8502: LD_INT 0
8504: ST_TO_ADDR
// vehSpawned := false ;
8505: LD_ADDR_VAR 0 3
8509: PUSH
8510: LD_INT 0
8512: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8513: LD_INT 35
8515: PPUSH
8516: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8520: LD_VAR 0 1
8524: PUSH
8525: LD_INT 350
8527: PUSH
8528: LD_INT 175
8530: PUSH
8531: LD_INT 70
8533: PUSH
8534: EMPTY
8535: LIST
8536: LIST
8537: LIST
8538: PUSH
8539: LD_OWVAR 67
8543: ARRAY
8544: GREATEREQUAL
8545: PUSH
8546: LD_VAR 0 3
8550: NOT
8551: AND
8552: IFFALSE 8642
// begin vehSpawned := true ;
8554: LD_ADDR_VAR 0 3
8558: PUSH
8559: LD_INT 1
8561: ST_TO_ADDR
// uc_side := 3 ;
8562: LD_ADDR_OWVAR 20
8566: PUSH
8567: LD_INT 3
8569: ST_TO_ADDR
// uc_nation := 3 ;
8570: LD_ADDR_OWVAR 21
8574: PUSH
8575: LD_INT 3
8577: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8578: LD_INT 22
8580: PPUSH
8581: LD_INT 3
8583: PPUSH
8584: LD_INT 3
8586: PPUSH
8587: LD_INT 43
8589: PPUSH
8590: LD_INT 100
8592: PPUSH
8593: CALL 19116 0 5
// veh := CreateVehicle ;
8597: LD_ADDR_VAR 0 2
8601: PUSH
8602: CALL_OW 45
8606: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8607: LD_VAR 0 2
8611: PPUSH
8612: LD_INT 130
8614: PPUSH
8615: LD_INT 131
8617: PPUSH
8618: LD_INT 0
8620: PPUSH
8621: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8625: LD_VAR 0 2
8629: PPUSH
8630: LD_INT 100
8632: PPUSH
8633: LD_INT 82
8635: PPUSH
8636: CALL_OW 114
// end else
8640: GO 8656
// time := time + 0 0$1 ;
8642: LD_ADDR_VAR 0 1
8646: PUSH
8647: LD_VAR 0 1
8651: PUSH
8652: LD_INT 35
8654: PLUS
8655: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8656: LD_EXP 47
8660: PPUSH
8661: CALL_OW 301
8665: PUSH
8666: LD_EXP 47
8670: PPUSH
8671: CALL_OW 255
8675: PUSH
8676: LD_INT 4
8678: EQUAL
8679: AND
8680: PUSH
8681: LD_INT 22
8683: PUSH
8684: LD_INT 7
8686: PUSH
8687: EMPTY
8688: LIST
8689: LIST
8690: PPUSH
8691: CALL_OW 69
8695: PPUSH
8696: LD_EXP 47
8700: PPUSH
8701: CALL_OW 74
8705: PPUSH
8706: LD_EXP 47
8710: PPUSH
8711: CALL_OW 296
8715: PUSH
8716: LD_INT 10
8718: LESS
8719: OR
8720: IFFALSE 8513
// if IsDead ( Belkov ) then
8722: LD_EXP 47
8726: PPUSH
8727: CALL_OW 301
8731: IFFALSE 8756
// begin CenterNowOnUnits ( Belkov ) ;
8733: LD_EXP 47
8737: PPUSH
8738: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8742: LD_EXP 15
8746: PPUSH
8747: LD_STRING D5a-JMM-2a
8749: PPUSH
8750: CALL_OW 88
// exit ;
8754: GO 8822
// end ; if See ( 7 , Belkov ) then
8756: LD_INT 7
8758: PPUSH
8759: LD_EXP 47
8763: PPUSH
8764: CALL_OW 292
8768: IFFALSE 8782
// SetSide ( Belkov , 7 ) ;
8770: LD_EXP 47
8774: PPUSH
8775: LD_INT 7
8777: PPUSH
8778: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8782: LD_INT 35
8784: PPUSH
8785: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8789: LD_EXP 47
8793: PPUSH
8794: LD_INT 66
8796: PPUSH
8797: LD_INT 45
8799: PPUSH
8800: CALL_OW 297
8804: PUSH
8805: LD_INT 30
8807: LESS
8808: IFFALSE 8782
// Say ( Belkov , D6-Bel-1 ) ;
8810: LD_EXP 47
8814: PPUSH
8815: LD_STRING D6-Bel-1
8817: PPUSH
8818: CALL_OW 88
// end ;
8822: PPOPN 3
8824: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8825: LD_EXP 47
8829: PPUSH
8830: CALL_OW 302
8834: PUSH
8835: LD_EXP 47
8839: PPUSH
8840: CALL_OW 504
8844: PUSH
8845: LD_INT 2
8847: PUSH
8848: LD_INT 34
8850: PUSH
8851: LD_INT 47
8853: PUSH
8854: EMPTY
8855: LIST
8856: LIST
8857: PUSH
8858: LD_INT 34
8860: PUSH
8861: LD_INT 45
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PUSH
8868: EMPTY
8869: LIST
8870: LIST
8871: LIST
8872: PPUSH
8873: CALL_OW 69
8877: IN
8878: AND
8879: IFFALSE 8896
8881: GO 8883
8883: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8884: LD_EXP 47
8888: PPUSH
8889: LD_STRING D7-Bel-1
8891: PPUSH
8892: CALL_OW 88
8896: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8897: LD_INT 22
8899: PUSH
8900: LD_INT 7
8902: PUSH
8903: EMPTY
8904: LIST
8905: LIST
8906: PUSH
8907: LD_INT 101
8909: PUSH
8910: LD_INT 2
8912: PUSH
8913: EMPTY
8914: LIST
8915: LIST
8916: PUSH
8917: EMPTY
8918: LIST
8919: LIST
8920: PPUSH
8921: CALL_OW 69
8925: PUSH
8926: LD_EXP 8
8930: NOT
8931: AND
8932: PUSH
8933: LD_EXP 46
8937: PPUSH
8938: CALL_OW 305
8942: NOT
8943: AND
8944: IFFALSE 9414
8946: GO 8948
8948: DISABLE
8949: LD_INT 0
8951: PPUSH
// begin ar_base_spotted := true ;
8952: LD_ADDR_EXP 8
8956: PUSH
8957: LD_INT 1
8959: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8960: LD_ADDR_VAR 0 1
8964: PUSH
8965: LD_INT 22
8967: PUSH
8968: LD_INT 2
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 21
8977: PUSH
8978: LD_INT 3
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: PPUSH
8989: CALL_OW 69
8993: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8994: LD_ADDR_VAR 0 1
8998: PUSH
8999: LD_VAR 0 1
9003: PPUSH
9004: LD_EXP 15
9008: PPUSH
9009: CALL_OW 74
9013: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9014: LD_INT 7
9016: PPUSH
9017: LD_INT 3
9019: PPUSH
9020: CALL_OW 332
// DialogueOn ;
9024: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9028: LD_VAR 0 1
9032: PPUSH
9033: CALL_OW 250
9037: PPUSH
9038: LD_VAR 0 1
9042: PPUSH
9043: CALL_OW 251
9047: PPUSH
9048: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9052: LD_ADDR_VAR 0 1
9056: PUSH
9057: LD_INT 22
9059: PUSH
9060: LD_INT 7
9062: PUSH
9063: EMPTY
9064: LIST
9065: LIST
9066: PUSH
9067: LD_INT 23
9069: PUSH
9070: LD_INT 1
9072: PUSH
9073: EMPTY
9074: LIST
9075: LIST
9076: PUSH
9077: LD_INT 26
9079: PUSH
9080: LD_INT 1
9082: PUSH
9083: EMPTY
9084: LIST
9085: LIST
9086: PUSH
9087: EMPTY
9088: LIST
9089: LIST
9090: LIST
9091: PPUSH
9092: CALL_OW 69
9096: PUSH
9097: LD_EXP 15
9101: PUSH
9102: LD_EXP 19
9106: PUSH
9107: LD_EXP 20
9111: PUSH
9112: LD_EXP 27
9116: PUSH
9117: LD_EXP 16
9121: PUSH
9122: LD_EXP 25
9126: PUSH
9127: LD_EXP 21
9131: PUSH
9132: LD_EXP 23
9136: PUSH
9137: EMPTY
9138: LIST
9139: LIST
9140: LIST
9141: LIST
9142: LIST
9143: LIST
9144: LIST
9145: LIST
9146: DIFF
9147: ST_TO_ADDR
// if not tmp then
9148: LD_VAR 0 1
9152: NOT
9153: IFFALSE 9227
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9155: LD_ADDR_VAR 0 1
9159: PUSH
9160: LD_INT 22
9162: PUSH
9163: LD_INT 7
9165: PUSH
9166: EMPTY
9167: LIST
9168: LIST
9169: PUSH
9170: LD_INT 23
9172: PUSH
9173: LD_INT 1
9175: PUSH
9176: EMPTY
9177: LIST
9178: LIST
9179: PUSH
9180: LD_INT 26
9182: PUSH
9183: LD_INT 2
9185: PUSH
9186: EMPTY
9187: LIST
9188: LIST
9189: PUSH
9190: EMPTY
9191: LIST
9192: LIST
9193: LIST
9194: PPUSH
9195: CALL_OW 69
9199: PUSH
9200: LD_EXP 30
9204: PUSH
9205: LD_EXP 17
9209: PUSH
9210: LD_EXP 28
9214: PUSH
9215: LD_EXP 29
9219: PUSH
9220: EMPTY
9221: LIST
9222: LIST
9223: LIST
9224: LIST
9225: DIFF
9226: ST_TO_ADDR
// if tmp then
9227: LD_VAR 0 1
9231: IFFALSE 9302
// case GetSex ( tmp [ 1 ] ) of sex_male :
9233: LD_VAR 0 1
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: CALL_OW 258
9246: PUSH
9247: LD_INT 1
9249: DOUBLE
9250: EQUAL
9251: IFTRUE 9255
9253: GO 9274
9255: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9256: LD_VAR 0 1
9260: PUSH
9261: LD_INT 1
9263: ARRAY
9264: PPUSH
9265: LD_STRING D9-Sol1-1
9267: PPUSH
9268: CALL_OW 88
9272: GO 9302
9274: LD_INT 2
9276: DOUBLE
9277: EQUAL
9278: IFTRUE 9282
9280: GO 9301
9282: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9283: LD_VAR 0 1
9287: PUSH
9288: LD_INT 1
9290: ARRAY
9291: PPUSH
9292: LD_STRING D9-FSol1-1
9294: PPUSH
9295: CALL_OW 88
9299: GO 9302
9301: POP
// if Frank then
9302: LD_EXP 27
9306: IFFALSE 9410
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9308: LD_EXP 56
9312: PPUSH
9313: CALL_OW 250
9317: PPUSH
9318: LD_EXP 56
9322: PPUSH
9323: CALL_OW 251
9327: PPUSH
9328: LD_INT 7
9330: PPUSH
9331: LD_INT 8
9333: PPUSH
9334: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9338: LD_EXP 56
9342: PPUSH
9343: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9347: LD_EXP 27
9351: PPUSH
9352: LD_STRING D9-Frank-1
9354: PPUSH
9355: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9359: LD_EXP 15
9363: PPUSH
9364: LD_STRING D9-JMM-1
9366: PPUSH
9367: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9371: LD_EXP 27
9375: PPUSH
9376: LD_STRING D9-Frank-2
9378: PPUSH
9379: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9383: LD_EXP 56
9387: PPUSH
9388: CALL_OW 250
9392: PPUSH
9393: LD_EXP 56
9397: PPUSH
9398: CALL_OW 251
9402: PPUSH
9403: LD_INT 7
9405: PPUSH
9406: CALL_OW 331
// end ; DialogueOff ;
9410: CALL_OW 7
// end ;
9414: PPOPN 1
9416: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9417: LD_EXP 7
9421: PUSH
9422: LD_OWVAR 1
9426: PUSH
9427: LD_INT 42000
9429: GREATEREQUAL
9430: OR
9431: IFFALSE 10458
9433: GO 9435
9435: DISABLE
9436: LD_INT 0
9438: PPUSH
9439: PPUSH
// begin selected_option := 1 ;
9440: LD_ADDR_VAR 0 2
9444: PUSH
9445: LD_INT 1
9447: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9448: LD_INT 10500
9450: PPUSH
9451: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9455: LD_INT 35
9457: PPUSH
9458: CALL_OW 67
// until not ru_attackers ;
9462: LD_EXP 52
9466: NOT
9467: IFFALSE 9455
// PrepareBurlak ;
9469: CALL 2204 0 0
// repeat wait ( 0 0$2 ) ;
9473: LD_INT 70
9475: PPUSH
9476: CALL_OW 67
// until not HasTask ( Burlak ) ;
9480: LD_EXP 46
9484: PPUSH
9485: CALL_OW 314
9489: NOT
9490: IFFALSE 9473
// InGameOn ;
9492: CALL_OW 8
// DialogueOn ;
9496: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9500: LD_EXP 49
9504: PPUSH
9505: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9509: LD_EXP 46
9513: PPUSH
9514: LD_STRING D10-Bur-1
9516: PPUSH
9517: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9521: LD_EXP 47
9525: PUSH
9526: LD_EXP 47
9530: PPUSH
9531: CALL_OW 255
9535: PUSH
9536: LD_INT 7
9538: EQUAL
9539: AND
9540: IFFALSE 9554
// Say ( Belkov , D10-Bel-1 ) ;
9542: LD_EXP 47
9546: PPUSH
9547: LD_STRING D10-Bel-1
9549: PPUSH
9550: CALL_OW 88
// if Gossudarov then
9554: LD_EXP 32
9558: IFFALSE 9572
// Say ( Gossudarov , D10-Gos-1 ) ;
9560: LD_EXP 32
9564: PPUSH
9565: LD_STRING D10-Gos-1
9567: PPUSH
9568: CALL_OW 88
// if Kirilenkova then
9572: LD_EXP 33
9576: IFFALSE 9590
// Say ( Kirilenkova , D10-Kir-1 ) ;
9578: LD_EXP 33
9582: PPUSH
9583: LD_STRING D10-Kir-1
9585: PPUSH
9586: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9590: CALL 12866 0 0
9594: PPUSH
9595: LD_STRING D10-RSol1-1
9597: PPUSH
9598: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9602: LD_EXP 46
9606: PPUSH
9607: LD_STRING D10-Bur-2
9609: PPUSH
9610: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9614: LD_EXP 15
9618: PPUSH
9619: LD_STRING D10-JMM-2
9621: PPUSH
9622: CALL_OW 88
// if Kirilenkova then
9626: LD_EXP 33
9630: IFFALSE 9646
// Say ( Kirilenkova , D10-Kir-2 ) else
9632: LD_EXP 33
9636: PPUSH
9637: LD_STRING D10-Kir-2
9639: PPUSH
9640: CALL_OW 88
9644: GO 9658
// Say ( SolRu , D10-RSol1-2 ) ;
9646: CALL 12866 0 0
9650: PPUSH
9651: LD_STRING D10-RSol1-2
9653: PPUSH
9654: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9658: LD_EXP 15
9662: PPUSH
9663: LD_STRING D10-JMM-3
9665: PPUSH
9666: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9670: LD_EXP 46
9674: PPUSH
9675: LD_STRING D10-Bur-3
9677: PPUSH
9678: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9682: LD_EXP 15
9686: PPUSH
9687: LD_STRING D10-JMM-4
9689: PPUSH
9690: CALL_OW 88
// DialogueOff ;
9694: CALL_OW 7
// InGameOff ;
9698: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9702: LD_STRING M2
9704: PPUSH
9705: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9709: LD_INT 35
9711: PPUSH
9712: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9716: LD_INT 22
9718: PUSH
9719: LD_INT 7
9721: PUSH
9722: EMPTY
9723: LIST
9724: LIST
9725: PUSH
9726: LD_INT 91
9728: PUSH
9729: LD_EXP 46
9733: PUSH
9734: LD_INT 8
9736: PUSH
9737: EMPTY
9738: LIST
9739: LIST
9740: LIST
9741: PUSH
9742: EMPTY
9743: LIST
9744: LIST
9745: PPUSH
9746: CALL_OW 69
9750: IFFALSE 9709
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9752: LD_ADDR_VAR 0 1
9756: PUSH
9757: LD_INT 22
9759: PUSH
9760: LD_INT 4
9762: PUSH
9763: EMPTY
9764: LIST
9765: LIST
9766: PPUSH
9767: CALL_OW 69
9771: PUSH
9772: FOR_IN
9773: IFFALSE 9789
// SetSide ( i , 7 ) ;
9775: LD_VAR 0 1
9779: PPUSH
9780: LD_INT 7
9782: PPUSH
9783: CALL_OW 235
9787: GO 9772
9789: POP
9790: POP
// ChangeMissionObjectives ( M3 ) ;
9791: LD_STRING M3
9793: PPUSH
9794: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9798: LD_INT 35
9800: PPUSH
9801: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9805: LD_EXP 15
9809: PPUSH
9810: LD_EXP 46
9814: PPUSH
9815: CALL_OW 296
9819: PUSH
9820: LD_INT 8
9822: LESS
9823: IFFALSE 9798
// ComTurnUnit ( JMM , Burlak ) ;
9825: LD_EXP 15
9829: PPUSH
9830: LD_EXP 46
9834: PPUSH
9835: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9839: LD_EXP 46
9843: PPUSH
9844: LD_EXP 15
9848: PPUSH
9849: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9853: LD_INT 10
9855: PPUSH
9856: CALL_OW 67
// DialogueOn ;
9860: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9864: LD_EXP 15
9868: PPUSH
9869: LD_STRING D11-JMM-1
9871: PPUSH
9872: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9876: LD_EXP 46
9880: PPUSH
9881: LD_STRING D11-Bur-1
9883: PPUSH
9884: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9888: LD_EXP 15
9892: PPUSH
9893: LD_STRING D11-JMM-2
9895: PPUSH
9896: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9900: LD_EXP 46
9904: PPUSH
9905: LD_STRING D11-Bur-2
9907: PPUSH
9908: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9912: LD_EXP 15
9916: PPUSH
9917: LD_STRING D11-JMM-3
9919: PPUSH
9920: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9924: LD_EXP 46
9928: PPUSH
9929: LD_STRING D11-Bur-3
9931: PPUSH
9932: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9936: LD_EXP 15
9940: PPUSH
9941: LD_STRING D11-JMM-4
9943: PPUSH
9944: CALL_OW 88
// if ar_base_spotted then
9948: LD_EXP 8
9952: IFFALSE 9968
// Say ( Burlak , D12-Bur-1 ) else
9954: LD_EXP 46
9958: PPUSH
9959: LD_STRING D12-Bur-1
9961: PPUSH
9962: CALL_OW 88
9966: GO 10007
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9968: LD_INT 7
9970: PPUSH
9971: LD_INT 3
9973: PPUSH
9974: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9978: LD_INT 127
9980: PPUSH
9981: LD_INT 45
9983: PPUSH
9984: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9988: LD_EXP 46
9992: PPUSH
9993: LD_STRING D12-Bur-1a
9995: PPUSH
9996: CALL_OW 88
// dwait ( 0 0$2 ) ;
10000: LD_INT 70
10002: PPUSH
10003: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10007: LD_EXP 46
10011: PPUSH
10012: LD_STRING D12-Bur-1b
10014: PPUSH
10015: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10019: LD_EXP 15
10023: PPUSH
10024: LD_STRING D12-JMM-1
10026: PPUSH
10027: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10031: LD_EXP 46
10035: PPUSH
10036: LD_STRING D12-Bur-2
10038: PPUSH
10039: CALL_OW 88
// if Roth then
10043: LD_EXP 16
10047: IFFALSE 10063
// Say ( Roth , D12-Roth-2 ) else
10049: LD_EXP 16
10053: PPUSH
10054: LD_STRING D12-Roth-2
10056: PPUSH
10057: CALL_OW 88
10061: GO 10075
// Say ( SciRu , D12-RSci1-2 ) ;
10063: CALL 12719 0 0
10067: PPUSH
10068: LD_STRING D12-RSci1-2
10070: PPUSH
10071: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10075: LD_EXP 15
10079: PPUSH
10080: LD_STRING D12-JMM-2
10082: PPUSH
10083: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10087: LD_EXP 46
10091: PPUSH
10092: LD_STRING D12-Bur-3
10094: PPUSH
10095: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10099: LD_EXP 15
10103: PPUSH
10104: LD_STRING D12-JMM-3
10106: PPUSH
10107: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10111: LD_EXP 46
10115: PPUSH
10116: LD_STRING D12-Bur-4
10118: PPUSH
10119: CALL_OW 88
// case Query ( QBase ) of 1 :
10123: LD_STRING QBase
10125: PPUSH
10126: CALL_OW 97
10130: PUSH
10131: LD_INT 1
10133: DOUBLE
10134: EQUAL
10135: IFTRUE 10139
10137: GO 10257
10139: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10140: LD_EXP 15
10144: PPUSH
10145: LD_STRING D13a-JMM-1
10147: PPUSH
10148: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10152: LD_EXP 46
10156: PPUSH
10157: LD_STRING D13a-Bur-1
10159: PPUSH
10160: CALL_OW 88
// if Roth then
10164: LD_EXP 16
10168: IFFALSE 10184
// Say ( Roth , D13a-Roth-1 ) else
10170: LD_EXP 16
10174: PPUSH
10175: LD_STRING D13a-Roth-1
10177: PPUSH
10178: CALL_OW 88
10182: GO 10196
// Say ( SciRu , D13a-RSci1-1 ) ;
10184: CALL 12719 0 0
10188: PPUSH
10189: LD_STRING D13a-RSci1-1
10191: PPUSH
10192: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10196: LD_EXP 15
10200: PPUSH
10201: LD_STRING D13a-JMM-2
10203: PPUSH
10204: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10208: LD_STRING QBaseAgain
10210: PPUSH
10211: CALL_OW 97
10215: PUSH
10216: LD_INT 1
10218: DOUBLE
10219: EQUAL
10220: IFTRUE 10224
10222: GO 10235
10224: POP
// selected_option := 2 ; 2 :
10225: LD_ADDR_VAR 0 2
10229: PUSH
10230: LD_INT 2
10232: ST_TO_ADDR
10233: GO 10255
10235: LD_INT 2
10237: DOUBLE
10238: EQUAL
10239: IFTRUE 10243
10241: GO 10254
10243: POP
// selected_option := 3 ; end ;
10244: LD_ADDR_VAR 0 2
10248: PUSH
10249: LD_INT 3
10251: ST_TO_ADDR
10252: GO 10255
10254: POP
// end ; 2 :
10255: GO 10296
10257: LD_INT 2
10259: DOUBLE
10260: EQUAL
10261: IFTRUE 10265
10263: GO 10276
10265: POP
// selected_option := 2 ; 3 :
10266: LD_ADDR_VAR 0 2
10270: PUSH
10271: LD_INT 2
10273: ST_TO_ADDR
10274: GO 10296
10276: LD_INT 3
10278: DOUBLE
10279: EQUAL
10280: IFTRUE 10284
10282: GO 10295
10284: POP
// selected_option := 3 ; end ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 3
10292: ST_TO_ADDR
10293: GO 10296
10295: POP
// if selected_option = 2 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 2
10303: EQUAL
10304: IFFALSE 10398
// begin Say ( JMM , D13b-JMM-1 ) ;
10306: LD_EXP 15
10310: PPUSH
10311: LD_STRING D13b-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10318: LD_EXP 46
10322: PPUSH
10323: LD_STRING D13b-Bur-1
10325: PPUSH
10326: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10330: LD_EXP 15
10334: PPUSH
10335: LD_STRING D13b-JMM-2
10337: PPUSH
10338: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10342: LD_EXP 55
10346: PPUSH
10347: LD_STRING D13b-Abd-2
10349: PPUSH
10350: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10354: LD_EXP 15
10358: PPUSH
10359: LD_STRING D13b-JMM-3
10361: PPUSH
10362: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10366: LD_EXP 55
10370: PPUSH
10371: LD_STRING D13b-Abd-3
10373: PPUSH
10374: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10378: LD_EXP 15
10382: PPUSH
10383: LD_STRING D13b-JMM-4
10385: PPUSH
10386: CALL_OW 88
// ar_active_attack := true ;
10390: LD_ADDR_EXP 9
10394: PUSH
10395: LD_INT 1
10397: ST_TO_ADDR
// end ; if selected_option = 3 then
10398: LD_VAR 0 2
10402: PUSH
10403: LD_INT 3
10405: EQUAL
10406: IFFALSE 10432
// begin Say ( JMM , D13c-JMM-1 ) ;
10408: LD_EXP 15
10412: PPUSH
10413: LD_STRING D13c-JMM-1
10415: PPUSH
10416: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10420: LD_EXP 46
10424: PPUSH
10425: LD_STRING D13c-Bur-1
10427: PPUSH
10428: CALL_OW 88
// end ; DialogueOff ;
10432: CALL_OW 7
// if not ar_active_attack then
10436: LD_EXP 9
10440: NOT
10441: IFFALSE 10458
// begin wait ( 6 6$00 ) ;
10443: LD_INT 12600
10445: PPUSH
10446: CALL_OW 67
// ar_active_attack := true ;
10450: LD_ADDR_EXP 9
10454: PUSH
10455: LD_INT 1
10457: ST_TO_ADDR
// end ; end ;
10458: PPOPN 2
10460: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10461: LD_EXP 46
10465: PPUSH
10466: CALL_OW 305
10470: PUSH
10471: LD_EXP 46
10475: PPUSH
10476: CALL_OW 255
10480: PUSH
10481: LD_INT 7
10483: EQUAL
10484: AND
10485: IFFALSE 10681
10487: GO 10489
10489: DISABLE
10490: LD_INT 0
10492: PPUSH
// begin wait ( 4 4$40 ) ;
10493: LD_INT 9800
10495: PPUSH
10496: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10500: LD_INT 35
10502: PPUSH
10503: CALL_OW 67
// until not ru_attackers ;
10507: LD_EXP 52
10511: NOT
10512: IFFALSE 10500
// PrepareGnyevko ;
10514: CALL 2148 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10518: LD_EXP 48
10522: PPUSH
10523: LD_INT 124
10525: PPUSH
10526: LD_INT 118
10528: PPUSH
10529: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10533: LD_EXP 48
10537: PPUSH
10538: CALL_OW 200
// time := 0 0$00 ;
10542: LD_ADDR_VAR 0 1
10546: PUSH
10547: LD_INT 0
10549: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10550: LD_INT 35
10552: PPUSH
10553: CALL_OW 67
// time := time + 0 0$1 ;
10557: LD_ADDR_VAR 0 1
10561: PUSH
10562: LD_VAR 0 1
10566: PUSH
10567: LD_INT 35
10569: PLUS
10570: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10571: LD_EXP 48
10575: PPUSH
10576: LD_INT 124
10578: PPUSH
10579: LD_INT 118
10581: PPUSH
10582: CALL_OW 307
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 1050
10594: GREATEREQUAL
10595: OR
10596: IFFALSE 10550
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10598: LD_EXP 48
10602: PPUSH
10603: LD_STRING DBelkov-Gny-1
10605: PPUSH
10606: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10610: LD_EXP 46
10614: PPUSH
10615: LD_STRING DBelkov-Bur-1a
10617: PPUSH
10618: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10622: LD_INT 35
10624: PPUSH
10625: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10629: LD_EXP 48
10633: PPUSH
10634: LD_INT 22
10636: PUSH
10637: LD_INT 7
10639: PUSH
10640: EMPTY
10641: LIST
10642: LIST
10643: PPUSH
10644: CALL_OW 69
10648: PPUSH
10649: LD_EXP 48
10653: PPUSH
10654: CALL_OW 74
10658: PPUSH
10659: CALL_OW 296
10663: PUSH
10664: LD_INT 8
10666: LESS
10667: IFFALSE 10622
// SetSide ( Gnyevko , 7 ) ;
10669: LD_EXP 48
10673: PPUSH
10674: LD_INT 7
10676: PPUSH
10677: CALL_OW 235
// end ;
10681: PPOPN 1
10683: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10684: LD_EXP 46
10688: PPUSH
10689: CALL_OW 255
10693: PUSH
10694: LD_INT 7
10696: EQUAL
10697: IFFALSE 10707
10699: GO 10701
10701: DISABLE
// begin enable ;
10702: ENABLE
// PrepareAmericanAttack ;
10703: CALL 6523 0 0
// end ;
10707: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10708: LD_INT 22
10710: PUSH
10711: LD_INT 1
10713: PUSH
10714: EMPTY
10715: LIST
10716: LIST
10717: PPUSH
10718: CALL_OW 69
10722: IFFALSE 10906
10724: GO 10726
10726: DISABLE
10727: LD_INT 0
10729: PPUSH
10730: PPUSH
// begin while true do
10731: LD_INT 1
10733: IFFALSE 10790
// begin wait ( 0 0$1 ) ;
10735: LD_INT 35
10737: PPUSH
10738: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10742: LD_ADDR_VAR 0 2
10746: PUSH
10747: LD_INT 22
10749: PUSH
10750: LD_INT 1
10752: PUSH
10753: EMPTY
10754: LIST
10755: LIST
10756: PPUSH
10757: CALL_OW 69
10761: PPUSH
10762: LD_EXP 15
10766: PPUSH
10767: CALL_OW 74
10771: ST_TO_ADDR
// if See ( 7 , tmp ) then
10772: LD_INT 7
10774: PPUSH
10775: LD_VAR 0 2
10779: PPUSH
10780: CALL_OW 292
10784: IFFALSE 10788
// break ;
10786: GO 10790
// end ;
10788: GO 10731
// DialogueOn ;
10790: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10794: LD_VAR 0 2
10798: PPUSH
10799: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10803: LD_VAR 0 2
10807: PPUSH
10808: CALL_OW 250
10812: PPUSH
10813: LD_VAR 0 2
10817: PPUSH
10818: CALL_OW 251
10822: PPUSH
10823: LD_INT 7
10825: PPUSH
10826: LD_INT 8
10828: PPUSH
10829: CALL_OW 330
// if Denis then
10833: LD_EXP 21
10837: IFFALSE 10851
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10839: LD_EXP 21
10843: PPUSH
10844: LD_STRING DAmerAttack-Pet-1
10846: PPUSH
10847: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10851: LD_EXP 15
10855: PPUSH
10856: LD_STRING DAmerAttack-JMM-1
10858: PPUSH
10859: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10863: LD_EXP 46
10867: PPUSH
10868: LD_STRING DStop-Bur-1
10870: PPUSH
10871: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10875: LD_VAR 0 2
10879: PPUSH
10880: CALL_OW 250
10884: PPUSH
10885: LD_VAR 0 2
10889: PPUSH
10890: CALL_OW 251
10894: PPUSH
10895: LD_INT 7
10897: PPUSH
10898: CALL_OW 331
// DialogueOff ;
10902: CALL_OW 7
// end ;
10906: PPOPN 2
10908: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10909: LD_INT 22
10911: PUSH
10912: LD_INT 3
10914: PUSH
10915: EMPTY
10916: LIST
10917: LIST
10918: PUSH
10919: LD_INT 21
10921: PUSH
10922: LD_INT 1
10924: PUSH
10925: EMPTY
10926: LIST
10927: LIST
10928: PUSH
10929: EMPTY
10930: LIST
10931: LIST
10932: PPUSH
10933: CALL_OW 69
10937: PUSH
10938: LD_INT 0
10940: EQUAL
10941: IFFALSE 10983
10943: GO 10945
10945: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10946: LD_STRING M5a
10948: PPUSH
10949: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10953: LD_EXP 15
10957: PPUSH
10958: LD_STRING D8-JMM-1
10960: PPUSH
10961: CALL_OW 88
// if Gossudarov then
10965: LD_EXP 32
10969: IFFALSE 10983
// Say ( Gossudarov , D8-Gos-1 ) ;
10971: LD_EXP 32
10975: PPUSH
10976: LD_STRING D8-Gos-1
10978: PPUSH
10979: CALL_OW 88
// end ;
10983: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10984: LD_INT 22
10986: PUSH
10987: LD_INT 2
10989: PUSH
10990: EMPTY
10991: LIST
10992: LIST
10993: PUSH
10994: LD_INT 21
10996: PUSH
10997: LD_INT 1
10999: PUSH
11000: EMPTY
11001: LIST
11002: LIST
11003: PUSH
11004: EMPTY
11005: LIST
11006: LIST
11007: PPUSH
11008: CALL_OW 69
11012: PUSH
11013: LD_INT 0
11015: EQUAL
11016: IFFALSE 11066
11018: GO 11020
11020: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11021: LD_STRING M4c
11023: PPUSH
11024: CALL_OW 337
// if Roth then
11028: LD_EXP 16
11032: IFFALSE 11048
// Say ( Roth , DStop-Roth-1 ) else
11034: LD_EXP 16
11038: PPUSH
11039: LD_STRING DStop-Roth-1
11041: PPUSH
11042: CALL_OW 88
11046: GO 11066
// if Gossudarov then
11048: LD_EXP 32
11052: IFFALSE 11066
// Say ( Gossudarov , D8-Gos-1a ) ;
11054: LD_EXP 32
11058: PPUSH
11059: LD_STRING D8-Gos-1a
11061: PPUSH
11062: CALL_OW 88
// end ;
11066: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11067: LD_INT 7
11069: PPUSH
11070: LD_INT 1
11072: PPUSH
11073: LD_INT 1
11075: PPUSH
11076: CALL 14355 0 3
11080: PUSH
11081: LD_INT 0
11083: EQUAL
11084: PUSH
11085: LD_INT 7
11087: PPUSH
11088: LD_INT 3
11090: PPUSH
11091: LD_INT 1
11093: PPUSH
11094: CALL 14355 0 3
11098: PUSH
11099: LD_INT 0
11101: EQUAL
11102: AND
11103: IFFALSE 11115
11105: GO 11107
11107: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11108: LD_STRING M1a
11110: PPUSH
11111: CALL_OW 337
// end ;
11115: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11116: LD_INT 22
11118: PUSH
11119: LD_INT 2
11121: PUSH
11122: EMPTY
11123: LIST
11124: LIST
11125: PUSH
11126: LD_INT 21
11128: PUSH
11129: LD_INT 1
11131: PUSH
11132: EMPTY
11133: LIST
11134: LIST
11135: PUSH
11136: EMPTY
11137: LIST
11138: LIST
11139: PPUSH
11140: CALL_OW 69
11144: PUSH
11145: LD_INT 0
11147: EQUAL
11148: PUSH
11149: LD_INT 22
11151: PUSH
11152: LD_INT 3
11154: PUSH
11155: EMPTY
11156: LIST
11157: LIST
11158: PUSH
11159: LD_INT 21
11161: PUSH
11162: LD_INT 1
11164: PUSH
11165: EMPTY
11166: LIST
11167: LIST
11168: PUSH
11169: EMPTY
11170: LIST
11171: LIST
11172: PPUSH
11173: CALL_OW 69
11177: PUSH
11178: LD_INT 0
11180: EQUAL
11181: AND
11182: PUSH
11183: LD_INT 22
11185: PUSH
11186: LD_INT 1
11188: PUSH
11189: EMPTY
11190: LIST
11191: LIST
11192: PPUSH
11193: CALL_OW 69
11197: PUSH
11198: LD_INT 0
11200: EQUAL
11201: AND
11202: PUSH
11203: LD_INT 7
11205: PPUSH
11206: LD_INT 1
11208: PPUSH
11209: LD_INT 1
11211: PPUSH
11212: CALL 14355 0 3
11216: PUSH
11217: LD_INT 0
11219: EQUAL
11220: AND
11221: PUSH
11222: LD_INT 7
11224: PPUSH
11225: LD_INT 3
11227: PPUSH
11228: LD_INT 1
11230: PPUSH
11231: CALL 14355 0 3
11235: PUSH
11236: LD_INT 0
11238: EQUAL
11239: AND
11240: IFFALSE 12716
11242: GO 11244
11244: DISABLE
11245: LD_INT 0
11247: PPUSH
11248: PPUSH
11249: PPUSH
11250: PPUSH
11251: PPUSH
11252: PPUSH
// begin m1 := false ;
11253: LD_ADDR_VAR 0 4
11257: PUSH
11258: LD_INT 0
11260: ST_TO_ADDR
// m2 := false ;
11261: LD_ADDR_VAR 0 5
11265: PUSH
11266: LD_INT 0
11268: ST_TO_ADDR
// m3 := false ;
11269: LD_ADDR_VAR 0 6
11273: PUSH
11274: LD_INT 0
11276: ST_TO_ADDR
// if tick < 40 40$00 then
11277: LD_OWVAR 1
11281: PUSH
11282: LD_INT 84000
11284: LESS
11285: IFFALSE 11294
// SetAchievement ( ACH_ASPEED_17 ) ;
11287: LD_STRING ACH_ASPEED_17
11289: PPUSH
11290: CALL_OW 543
// wait ( 0 0$1 ) ;
11294: LD_INT 35
11296: PPUSH
11297: CALL_OW 67
// if not IsDead ( Masha ) then
11301: LD_EXP 49
11305: PPUSH
11306: CALL_OW 301
11310: NOT
11311: IFFALSE 11333
// begin m1 := true ;
11313: LD_ADDR_VAR 0 4
11317: PUSH
11318: LD_INT 1
11320: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11321: LD_STRING Masha
11323: PPUSH
11324: LD_INT 1
11326: PPUSH
11327: CALL_OW 101
// end else
11331: GO 11344
// AddMedal ( Masha , - 1 ) ;
11333: LD_STRING Masha
11335: PPUSH
11336: LD_INT 1
11338: NEG
11339: PPUSH
11340: CALL_OW 101
// if abdul_escaped then
11344: LD_EXP 12
11348: IFFALSE 11363
// AddMedal ( Abdul , - 1 ) else
11350: LD_STRING Abdul
11352: PPUSH
11353: LD_INT 1
11355: NEG
11356: PPUSH
11357: CALL_OW 101
11361: GO 11381
// begin m2 := true ;
11363: LD_ADDR_VAR 0 5
11367: PUSH
11368: LD_INT 1
11370: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11371: LD_STRING Abdul
11373: PPUSH
11374: LD_INT 1
11376: PPUSH
11377: CALL_OW 101
// end ; if loss_counter = 0 then
11381: LD_EXP 13
11385: PUSH
11386: LD_INT 0
11388: EQUAL
11389: IFFALSE 11411
// begin m3 := true ;
11391: LD_ADDR_VAR 0 6
11395: PUSH
11396: LD_INT 1
11398: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11399: LD_STRING People
11401: PPUSH
11402: LD_INT 2
11404: PPUSH
11405: CALL_OW 101
// end else
11409: GO 11469
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11411: LD_EXP 13
11415: PUSH
11416: LD_INT 3
11418: PUSH
11419: LD_INT 2
11421: PUSH
11422: LD_INT 2
11424: PUSH
11425: EMPTY
11426: LIST
11427: LIST
11428: LIST
11429: PUSH
11430: LD_OWVAR 67
11434: ARRAY
11435: LESSEQUAL
11436: IFFALSE 11458
// begin AddMedal ( People , 1 ) ;
11438: LD_STRING People
11440: PPUSH
11441: LD_INT 1
11443: PPUSH
11444: CALL_OW 101
// m3 := true ;
11448: LD_ADDR_VAR 0 6
11452: PUSH
11453: LD_INT 1
11455: ST_TO_ADDR
// end else
11456: GO 11469
// AddMedal ( People , - 1 ) ;
11458: LD_STRING People
11460: PPUSH
11461: LD_INT 1
11463: NEG
11464: PPUSH
11465: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11469: LD_OWVAR 67
11473: PUSH
11474: LD_INT 3
11476: EQUAL
11477: PUSH
11478: LD_VAR 0 4
11482: AND
11483: PUSH
11484: LD_VAR 0 5
11488: AND
11489: PUSH
11490: LD_VAR 0 6
11494: AND
11495: IFFALSE 11507
// SetAchievementEX ( ACH_AMER , 17 ) ;
11497: LD_STRING ACH_AMER
11499: PPUSH
11500: LD_INT 17
11502: PPUSH
11503: CALL_OW 564
// GiveMedals ( MAIN ) ;
11507: LD_STRING MAIN
11509: PPUSH
11510: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11514: LD_ADDR_VAR 0 2
11518: PUSH
11519: LD_INT 22
11521: PUSH
11522: LD_INT 7
11524: PUSH
11525: EMPTY
11526: LIST
11527: LIST
11528: PUSH
11529: LD_INT 2
11531: PUSH
11532: LD_INT 25
11534: PUSH
11535: LD_INT 1
11537: PUSH
11538: EMPTY
11539: LIST
11540: LIST
11541: PUSH
11542: LD_INT 25
11544: PUSH
11545: LD_INT 2
11547: PUSH
11548: EMPTY
11549: LIST
11550: LIST
11551: PUSH
11552: LD_INT 25
11554: PUSH
11555: LD_INT 3
11557: PUSH
11558: EMPTY
11559: LIST
11560: LIST
11561: PUSH
11562: LD_INT 25
11564: PUSH
11565: LD_INT 4
11567: PUSH
11568: EMPTY
11569: LIST
11570: LIST
11571: PUSH
11572: LD_INT 25
11574: PUSH
11575: LD_INT 5
11577: PUSH
11578: EMPTY
11579: LIST
11580: LIST
11581: PUSH
11582: LD_INT 25
11584: PUSH
11585: LD_INT 8
11587: PUSH
11588: EMPTY
11589: LIST
11590: LIST
11591: PUSH
11592: LD_INT 25
11594: PUSH
11595: LD_INT 9
11597: PUSH
11598: EMPTY
11599: LIST
11600: LIST
11601: PUSH
11602: EMPTY
11603: LIST
11604: LIST
11605: LIST
11606: LIST
11607: LIST
11608: LIST
11609: LIST
11610: LIST
11611: PUSH
11612: EMPTY
11613: LIST
11614: LIST
11615: PPUSH
11616: CALL_OW 69
11620: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11621: LD_VAR 0 2
11625: PPUSH
11626: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11630: LD_ADDR_VAR 0 3
11634: PUSH
11635: LD_EXP 15
11639: PUSH
11640: LD_EXP 16
11644: PUSH
11645: LD_EXP 17
11649: PUSH
11650: LD_EXP 18
11654: PUSH
11655: LD_EXP 19
11659: PUSH
11660: LD_EXP 20
11664: PUSH
11665: LD_EXP 21
11669: PUSH
11670: LD_EXP 22
11674: PUSH
11675: LD_EXP 23
11679: PUSH
11680: LD_EXP 24
11684: PUSH
11685: LD_EXP 25
11689: PUSH
11690: LD_EXP 26
11694: PUSH
11695: LD_EXP 27
11699: PUSH
11700: LD_EXP 28
11704: PUSH
11705: LD_EXP 29
11709: PUSH
11710: LD_EXP 30
11714: PUSH
11715: LD_EXP 31
11719: PUSH
11720: LD_EXP 32
11724: PUSH
11725: LD_EXP 33
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: LD_EXP 36
11739: PUSH
11740: LD_EXP 37
11744: PUSH
11745: LD_EXP 38
11749: PUSH
11750: LD_EXP 39
11754: PUSH
11755: LD_EXP 40
11759: PUSH
11760: LD_EXP 41
11764: PUSH
11765: LD_EXP 42
11769: PUSH
11770: LD_EXP 43
11774: PUSH
11775: LD_EXP 44
11779: PUSH
11780: LD_EXP 45
11784: PUSH
11785: LD_EXP 46
11789: PUSH
11790: LD_EXP 47
11794: PUSH
11795: LD_EXP 48
11799: PUSH
11800: EMPTY
11801: LIST
11802: LIST
11803: LIST
11804: LIST
11805: LIST
11806: LIST
11807: LIST
11808: LIST
11809: LIST
11810: LIST
11811: LIST
11812: LIST
11813: LIST
11814: LIST
11815: LIST
11816: LIST
11817: LIST
11818: LIST
11819: LIST
11820: LIST
11821: LIST
11822: LIST
11823: LIST
11824: LIST
11825: LIST
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: ST_TO_ADDR
// if tmp diff tmp2 then
11835: LD_VAR 0 2
11839: PUSH
11840: LD_VAR 0 3
11844: DIFF
11845: IFFALSE 11865
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11847: LD_VAR 0 2
11851: PUSH
11852: LD_VAR 0 3
11856: DIFF
11857: PPUSH
11858: LD_STRING 13a_others
11860: PPUSH
11861: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11865: LD_EXP 15
11869: PPUSH
11870: LD_STRING 13a_JMM
11872: PPUSH
11873: CALL_OW 38
// if Titov then
11877: LD_EXP 34
11881: IFFALSE 11895
// SaveCharacters ( Titov , 13a_Titov ) ;
11883: LD_EXP 34
11887: PPUSH
11888: LD_STRING 13a_Titov
11890: PPUSH
11891: CALL_OW 38
// if Dolgov then
11895: LD_EXP 36
11899: IFFALSE 11913
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11901: LD_EXP 36
11905: PPUSH
11906: LD_STRING 13a_Dolgov
11908: PPUSH
11909: CALL_OW 38
// if Petrosyan then
11913: LD_EXP 37
11917: IFFALSE 11931
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11919: LD_EXP 37
11923: PPUSH
11924: LD_STRING 13a_Petrosyan
11926: PPUSH
11927: CALL_OW 38
// if Scholtze then
11931: LD_EXP 38
11935: IFFALSE 11949
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11937: LD_EXP 38
11941: PPUSH
11942: LD_STRING 13a_Scholtze
11944: PPUSH
11945: CALL_OW 38
// if Oblukov then
11949: LD_EXP 39
11953: IFFALSE 11967
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11955: LD_EXP 39
11959: PPUSH
11960: LD_STRING 13a_Oblukov
11962: PPUSH
11963: CALL_OW 38
// if Kapitsova then
11967: LD_EXP 40
11971: IFFALSE 11985
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11973: LD_EXP 40
11977: PPUSH
11978: LD_STRING 13a_Kapitsova
11980: PPUSH
11981: CALL_OW 38
// if Lipshchin then
11985: LD_EXP 41
11989: IFFALSE 12003
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11991: LD_EXP 41
11995: PPUSH
11996: LD_STRING 13a_Lipshchin
11998: PPUSH
11999: CALL_OW 38
// if Petrovova then
12003: LD_EXP 42
12007: IFFALSE 12021
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12009: LD_EXP 42
12013: PPUSH
12014: LD_STRING 13a_Petrovova
12016: PPUSH
12017: CALL_OW 38
// if Kovalyuk then
12021: LD_EXP 43
12025: IFFALSE 12039
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12027: LD_EXP 43
12031: PPUSH
12032: LD_STRING 13a_Kovalyuk
12034: PPUSH
12035: CALL_OW 38
// if Kuzmov then
12039: LD_EXP 44
12043: IFFALSE 12057
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12045: LD_EXP 44
12049: PPUSH
12050: LD_STRING 13a_Kuzmov
12052: PPUSH
12053: CALL_OW 38
// if Karamazov then
12057: LD_EXP 45
12061: IFFALSE 12075
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12063: LD_EXP 45
12067: PPUSH
12068: LD_STRING 13a_Karamazov
12070: PPUSH
12071: CALL_OW 38
// if Burlak then
12075: LD_EXP 46
12079: IFFALSE 12093
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12081: LD_EXP 46
12085: PPUSH
12086: LD_STRING 13a_Burlak
12088: PPUSH
12089: CALL_OW 38
// if Belkov then
12093: LD_EXP 47
12097: IFFALSE 12111
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12099: LD_EXP 47
12103: PPUSH
12104: LD_STRING 13a_Belkov
12106: PPUSH
12107: CALL_OW 38
// if Gnyevko then
12111: LD_EXP 48
12115: IFFALSE 12129
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12117: LD_EXP 48
12121: PPUSH
12122: LD_STRING 13a_Gnyevko
12124: PPUSH
12125: CALL_OW 38
// if Lisa then
12129: LD_EXP 17
12133: IFFALSE 12147
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12135: LD_EXP 17
12139: PPUSH
12140: LD_STRING 13a_Lisa
12142: PPUSH
12143: CALL_OW 38
// if Donaldson then
12147: LD_EXP 18
12151: IFFALSE 12165
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12153: LD_EXP 18
12157: PPUSH
12158: LD_STRING 13a_Donaldson
12160: PPUSH
12161: CALL_OW 38
// if Bobby then
12165: LD_EXP 19
12169: IFFALSE 12183
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12171: LD_EXP 19
12175: PPUSH
12176: LD_STRING 13a_Bobby
12178: PPUSH
12179: CALL_OW 38
// if Cyrus then
12183: LD_EXP 20
12187: IFFALSE 12201
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12189: LD_EXP 20
12193: PPUSH
12194: LD_STRING 13a_Cyrus
12196: PPUSH
12197: CALL_OW 38
// if Denis then
12201: LD_EXP 21
12205: IFFALSE 12219
// SaveCharacters ( Denis , 13a_Denis ) ;
12207: LD_EXP 21
12211: PPUSH
12212: LD_STRING 13a_Denis
12214: PPUSH
12215: CALL_OW 38
// if Brown then
12219: LD_EXP 22
12223: IFFALSE 12237
// SaveCharacters ( Brown , 13a_Brown ) ;
12225: LD_EXP 22
12229: PPUSH
12230: LD_STRING 13a_Brown
12232: PPUSH
12233: CALL_OW 38
// if Gladstone then
12237: LD_EXP 23
12241: IFFALSE 12255
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12243: LD_EXP 23
12247: PPUSH
12248: LD_STRING 13a_Gladstone
12250: PPUSH
12251: CALL_OW 38
// if Houten then
12255: LD_EXP 24
12259: IFFALSE 12273
// SaveCharacters ( Houten , 13a_Houten ) ;
12261: LD_EXP 24
12265: PPUSH
12266: LD_STRING 13a_Houten
12268: PPUSH
12269: CALL_OW 38
// if Cornel then
12273: LD_EXP 25
12277: IFFALSE 12291
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12279: LD_EXP 25
12283: PPUSH
12284: LD_STRING 13a_Cornel
12286: PPUSH
12287: CALL_OW 38
// if Gary then
12291: LD_EXP 26
12295: IFFALSE 12309
// SaveCharacters ( Gary , 13a_Gary ) ;
12297: LD_EXP 26
12301: PPUSH
12302: LD_STRING 13a_Gary
12304: PPUSH
12305: CALL_OW 38
// if Frank then
12309: LD_EXP 27
12313: IFFALSE 12327
// SaveCharacters ( Frank , 13a_Frank ) ;
12315: LD_EXP 27
12319: PPUSH
12320: LD_STRING 13a_Frank
12322: PPUSH
12323: CALL_OW 38
// if Kikuchi then
12327: LD_EXP 28
12331: IFFALSE 12345
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12333: LD_EXP 28
12337: PPUSH
12338: LD_STRING 13a_Kikuchi
12340: PPUSH
12341: CALL_OW 38
// if Simms then
12345: LD_EXP 29
12349: IFFALSE 12363
// SaveCharacters ( Simms , 13a_Simms ) ;
12351: LD_EXP 29
12355: PPUSH
12356: LD_STRING 13a_Simms
12358: PPUSH
12359: CALL_OW 38
// if Joan then
12363: LD_EXP 30
12367: IFFALSE 12381
// SaveCharacters ( Joan , 13a_Joan ) ;
12369: LD_EXP 30
12373: PPUSH
12374: LD_STRING 13a_Joan
12376: PPUSH
12377: CALL_OW 38
// if DeltaDoctor then
12381: LD_EXP 31
12385: IFFALSE 12399
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12387: LD_EXP 31
12391: PPUSH
12392: LD_STRING 13a_DeltaDoctor
12394: PPUSH
12395: CALL_OW 38
// if Gossudarov then
12399: LD_EXP 32
12403: IFFALSE 12417
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12405: LD_EXP 32
12409: PPUSH
12410: LD_STRING 13a_Gossudarov
12412: PPUSH
12413: CALL_OW 38
// if Kirilenkova then
12417: LD_EXP 33
12421: IFFALSE 12435
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12423: LD_EXP 33
12427: PPUSH
12428: LD_STRING 13a_Kirilenkova
12430: PPUSH
12431: CALL_OW 38
// if Roth then
12435: LD_EXP 16
12439: IFFALSE 12453
// SaveCharacters ( Roth , 13a_Roth ) ;
12441: LD_EXP 16
12445: PPUSH
12446: LD_STRING 13a_Roth
12448: PPUSH
12449: CALL_OW 38
// if Masha then
12453: LD_EXP 49
12457: IFFALSE 12512
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12459: LD_EXP 49
12463: PPUSH
12464: CALL_OW 265
12468: PUSH
12469: LD_EXP 49
12473: PPUSH
12474: CALL_OW 262
12478: PUSH
12479: LD_EXP 49
12483: PPUSH
12484: CALL_OW 263
12488: PUSH
12489: LD_EXP 49
12493: PPUSH
12494: CALL_OW 264
12498: PUSH
12499: EMPTY
12500: LIST
12501: LIST
12502: LIST
12503: LIST
12504: PPUSH
12505: LD_STRING 13a_Masha
12507: PPUSH
12508: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12512: LD_ADDR_VAR 0 2
12516: PUSH
12517: LD_INT 21
12519: PUSH
12520: LD_INT 3
12522: PUSH
12523: EMPTY
12524: LIST
12525: LIST
12526: PPUSH
12527: CALL_OW 69
12531: ST_TO_ADDR
// tmp2 := [ ] ;
12532: LD_ADDR_VAR 0 3
12536: PUSH
12537: EMPTY
12538: ST_TO_ADDR
// if tmp then
12539: LD_VAR 0 2
12543: IFFALSE 12694
// for i in tmp do
12545: LD_ADDR_VAR 0 1
12549: PUSH
12550: LD_VAR 0 2
12554: PUSH
12555: FOR_IN
12556: IFFALSE 12692
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12558: LD_ADDR_VAR 0 3
12562: PUSH
12563: LD_VAR 0 3
12567: PUSH
12568: LD_VAR 0 1
12572: PPUSH
12573: CALL_OW 255
12577: PUSH
12578: LD_VAR 0 1
12582: PPUSH
12583: CALL_OW 248
12587: PUSH
12588: LD_VAR 0 1
12592: PPUSH
12593: CALL_OW 266
12597: PUSH
12598: LD_VAR 0 1
12602: PPUSH
12603: CALL_OW 250
12607: PUSH
12608: LD_VAR 0 1
12612: PPUSH
12613: CALL_OW 251
12617: PUSH
12618: LD_VAR 0 1
12622: PPUSH
12623: CALL_OW 254
12627: PUSH
12628: LD_VAR 0 1
12632: PPUSH
12633: CALL_OW 267
12637: PUSH
12638: LD_VAR 0 1
12642: PPUSH
12643: LD_INT 1
12645: PPUSH
12646: CALL_OW 268
12650: PUSH
12651: LD_VAR 0 1
12655: PPUSH
12656: LD_INT 2
12658: PPUSH
12659: CALL_OW 268
12663: PUSH
12664: LD_VAR 0 1
12668: PPUSH
12669: CALL_OW 269
12673: PUSH
12674: EMPTY
12675: LIST
12676: LIST
12677: LIST
12678: LIST
12679: LIST
12680: LIST
12681: LIST
12682: LIST
12683: LIST
12684: LIST
12685: PUSH
12686: EMPTY
12687: LIST
12688: ADD
12689: ST_TO_ADDR
12690: GO 12555
12692: POP
12693: POP
// if tmp2 then
12694: LD_VAR 0 3
12698: IFFALSE 12712
// SaveVariable ( tmp2 , 13a_buildings ) ;
12700: LD_VAR 0 3
12704: PPUSH
12705: LD_STRING 13a_buildings
12707: PPUSH
12708: CALL_OW 39
// YouWin ;
12712: CALL_OW 103
// end ;
12716: PPOPN 6
12718: END
// export function SciRu ; var tmp , t ; begin
12719: LD_INT 0
12721: PPUSH
12722: PPUSH
12723: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12724: LD_ADDR_VAR 0 3
12728: PUSH
12729: LD_EXP 32
12733: PUSH
12734: LD_EXP 46
12738: PUSH
12739: LD_EXP 34
12743: PUSH
12744: LD_EXP 47
12748: PUSH
12749: LD_EXP 48
12753: PUSH
12754: LD_EXP 37
12758: PUSH
12759: LD_EXP 38
12763: PUSH
12764: LD_EXP 36
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: LIST
12773: LIST
12774: LIST
12775: LIST
12776: LIST
12777: LIST
12778: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12779: LD_ADDR_VAR 0 2
12783: PUSH
12784: LD_INT 22
12786: PUSH
12787: LD_INT 7
12789: PUSH
12790: EMPTY
12791: LIST
12792: LIST
12793: PUSH
12794: LD_INT 23
12796: PUSH
12797: LD_INT 3
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 25
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: LD_INT 26
12816: PUSH
12817: LD_INT 1
12819: PUSH
12820: EMPTY
12821: LIST
12822: LIST
12823: PUSH
12824: EMPTY
12825: LIST
12826: LIST
12827: LIST
12828: LIST
12829: PPUSH
12830: CALL_OW 69
12834: PUSH
12835: LD_VAR 0 3
12839: DIFF
12840: ST_TO_ADDR
// if tmp then
12841: LD_VAR 0 2
12845: IFFALSE 12861
// result := tmp [ 1 ] ;
12847: LD_ADDR_VAR 0 1
12851: PUSH
12852: LD_VAR 0 2
12856: PUSH
12857: LD_INT 1
12859: ARRAY
12860: ST_TO_ADDR
// end ;
12861: LD_VAR 0 1
12865: RET
// export function SolRu ; var tmp , t ; begin
12866: LD_INT 0
12868: PPUSH
12869: PPUSH
12870: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12871: LD_ADDR_VAR 0 3
12875: PUSH
12876: LD_EXP 32
12880: PUSH
12881: LD_EXP 46
12885: PUSH
12886: LD_EXP 34
12890: PUSH
12891: LD_EXP 47
12895: PUSH
12896: LD_EXP 48
12900: PUSH
12901: LD_EXP 37
12905: PUSH
12906: LD_EXP 38
12910: PUSH
12911: LD_EXP 36
12915: PUSH
12916: EMPTY
12917: LIST
12918: LIST
12919: LIST
12920: LIST
12921: LIST
12922: LIST
12923: LIST
12924: LIST
12925: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12926: LD_ADDR_VAR 0 2
12930: PUSH
12931: LD_INT 22
12933: PUSH
12934: LD_INT 7
12936: PUSH
12937: EMPTY
12938: LIST
12939: LIST
12940: PUSH
12941: LD_INT 23
12943: PUSH
12944: LD_INT 3
12946: PUSH
12947: EMPTY
12948: LIST
12949: LIST
12950: PUSH
12951: LD_INT 25
12953: PUSH
12954: LD_INT 1
12956: PUSH
12957: EMPTY
12958: LIST
12959: LIST
12960: PUSH
12961: LD_INT 26
12963: PUSH
12964: LD_INT 1
12966: PUSH
12967: EMPTY
12968: LIST
12969: LIST
12970: PUSH
12971: EMPTY
12972: LIST
12973: LIST
12974: LIST
12975: LIST
12976: PPUSH
12977: CALL_OW 69
12981: PUSH
12982: LD_VAR 0 3
12986: DIFF
12987: ST_TO_ADDR
// if tmp then
12988: LD_VAR 0 2
12992: IFFALSE 13008
// result := tmp [ 1 ] ;
12994: LD_ADDR_VAR 0 1
12998: PUSH
12999: LD_VAR 0 2
13003: PUSH
13004: LD_INT 1
13006: ARRAY
13007: ST_TO_ADDR
// end ; end_of_file
13008: LD_VAR 0 1
13012: RET
// export function CustomEvent ( event ) ; begin
13013: LD_INT 0
13015: PPUSH
// end ;
13016: LD_VAR 0 2
13020: RET
// on UnitDestroyed ( un ) do var i , side ;
13021: LD_INT 0
13023: PPUSH
13024: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13025: LD_VAR 0 1
13029: PUSH
13030: LD_INT 22
13032: PUSH
13033: LD_INT 7
13035: PUSH
13036: EMPTY
13037: LIST
13038: LIST
13039: PUSH
13040: LD_INT 2
13042: PUSH
13043: LD_INT 25
13045: PUSH
13046: LD_INT 1
13048: PUSH
13049: EMPTY
13050: LIST
13051: LIST
13052: PUSH
13053: LD_INT 25
13055: PUSH
13056: LD_INT 2
13058: PUSH
13059: EMPTY
13060: LIST
13061: LIST
13062: PUSH
13063: LD_INT 25
13065: PUSH
13066: LD_INT 3
13068: PUSH
13069: EMPTY
13070: LIST
13071: LIST
13072: PUSH
13073: LD_INT 25
13075: PUSH
13076: LD_INT 4
13078: PUSH
13079: EMPTY
13080: LIST
13081: LIST
13082: PUSH
13083: LD_INT 25
13085: PUSH
13086: LD_INT 5
13088: PUSH
13089: EMPTY
13090: LIST
13091: LIST
13092: PUSH
13093: LD_INT 25
13095: PUSH
13096: LD_INT 8
13098: PUSH
13099: EMPTY
13100: LIST
13101: LIST
13102: PUSH
13103: LD_INT 25
13105: PUSH
13106: LD_INT 9
13108: PUSH
13109: EMPTY
13110: LIST
13111: LIST
13112: PUSH
13113: EMPTY
13114: LIST
13115: LIST
13116: LIST
13117: LIST
13118: LIST
13119: LIST
13120: LIST
13121: LIST
13122: PUSH
13123: EMPTY
13124: LIST
13125: LIST
13126: PPUSH
13127: CALL_OW 69
13131: IN
13132: IFFALSE 13148
// loss_counter := loss_counter + 1 ;
13134: LD_ADDR_EXP 13
13138: PUSH
13139: LD_EXP 13
13143: PUSH
13144: LD_INT 1
13146: PLUS
13147: ST_TO_ADDR
// if un = Abdul then
13148: LD_VAR 0 1
13152: PUSH
13153: LD_EXP 55
13157: EQUAL
13158: IFFALSE 13168
// abdul_escaped := false ;
13160: LD_ADDR_EXP 12
13164: PUSH
13165: LD_INT 0
13167: ST_TO_ADDR
// if un in ru_attackers then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 52
13177: IN
13178: IFFALSE 13196
// ru_attackers := ru_attackers diff un ;
13180: LD_ADDR_EXP 52
13184: PUSH
13185: LD_EXP 52
13189: PUSH
13190: LD_VAR 0 1
13194: DIFF
13195: ST_TO_ADDR
// if un in ar_attackers then
13196: LD_VAR 0 1
13200: PUSH
13201: LD_EXP 10
13205: IN
13206: IFFALSE 13224
// ar_attackers := ar_attackers diff un ;
13208: LD_ADDR_EXP 10
13212: PUSH
13213: LD_EXP 10
13217: PUSH
13218: LD_VAR 0 1
13222: DIFF
13223: ST_TO_ADDR
// if un = JMM then
13224: LD_VAR 0 1
13228: PUSH
13229: LD_EXP 15
13233: EQUAL
13234: IFFALSE 13245
// begin YouLost ( JMM ) ;
13236: LD_STRING JMM
13238: PPUSH
13239: CALL_OW 104
// exit ;
13243: GO 13334
// end ; if un = Burlak then
13245: LD_VAR 0 1
13249: PUSH
13250: LD_EXP 46
13254: EQUAL
13255: IFFALSE 13266
// begin YouLost ( Burlak ) ;
13257: LD_STRING Burlak
13259: PPUSH
13260: CALL_OW 104
// exit ;
13264: GO 13334
// end ; if un = freedom then
13266: LD_VAR 0 1
13270: PUSH
13271: LD_EXP 3
13275: EQUAL
13276: IFFALSE 13287
// begin YouLost ( Destroyed ) ;
13278: LD_STRING Destroyed
13280: PPUSH
13281: CALL_OW 104
// exit ;
13285: GO 13334
// end ; if un = Masha then
13287: LD_VAR 0 1
13291: PUSH
13292: LD_EXP 49
13296: EQUAL
13297: IFFALSE 13306
// ChangeMissionObjectives ( M4b ) ;
13299: LD_STRING M4b
13301: PPUSH
13302: CALL_OW 337
// if un = Mastodont then
13306: LD_VAR 0 1
13310: PUSH
13311: LD_EXP 56
13315: EQUAL
13316: IFFALSE 13325
// ChangeMissionObjectives ( M4a ) ;
13318: LD_STRING M4a
13320: PPUSH
13321: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13325: LD_VAR 0 1
13329: PPUSH
13330: CALL 77724 0 1
// end ;
13334: PPOPN 3
13336: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13337: LD_VAR 0 1
13341: PPUSH
13342: LD_VAR 0 2
13346: PPUSH
13347: CALL 80058 0 2
// end ;
13351: PPOPN 2
13353: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13354: LD_VAR 0 1
13358: PPUSH
13359: CALL 79126 0 1
// end ;
13363: PPOPN 1
13365: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13366: LD_VAR 0 1
13370: PUSH
13371: LD_INT 22
13373: PUSH
13374: LD_INT 7
13376: PUSH
13377: EMPTY
13378: LIST
13379: LIST
13380: PUSH
13381: LD_INT 30
13383: PUSH
13384: LD_INT 0
13386: PUSH
13387: EMPTY
13388: LIST
13389: LIST
13390: PUSH
13391: EMPTY
13392: LIST
13393: LIST
13394: PPUSH
13395: CALL_OW 69
13399: IN
13400: IFFALSE 13439
// begin SetBName ( building , freedom ) ;
13402: LD_VAR 0 1
13406: PPUSH
13407: LD_STRING freedom
13409: PPUSH
13410: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13414: LD_INT 0
13416: PPUSH
13417: LD_INT 7
13419: PPUSH
13420: LD_INT 0
13422: PPUSH
13423: CALL_OW 324
// freedom := building ;
13427: LD_ADDR_EXP 3
13431: PUSH
13432: LD_VAR 0 1
13436: ST_TO_ADDR
// exit ;
13437: GO 13505
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13439: LD_VAR 0 1
13443: PUSH
13444: LD_INT 22
13446: PUSH
13447: LD_INT 7
13449: PUSH
13450: EMPTY
13451: LIST
13452: LIST
13453: PUSH
13454: LD_INT 23
13456: PUSH
13457: LD_INT 3
13459: PUSH
13460: EMPTY
13461: LIST
13462: LIST
13463: PUSH
13464: LD_INT 30
13466: PUSH
13467: LD_INT 6
13469: PUSH
13470: EMPTY
13471: LIST
13472: LIST
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: LIST
13478: PPUSH
13479: CALL_OW 69
13483: IN
13484: IFFALSE 13496
// begin ru_lab_builded := true ;
13486: LD_ADDR_EXP 5
13490: PUSH
13491: LD_INT 1
13493: ST_TO_ADDR
// exit ;
13494: GO 13505
// end ; MCE_BuildingComplete ( building ) ;
13496: LD_VAR 0 1
13500: PPUSH
13501: CALL 79367 0 1
// end ;
13505: PPOPN 1
13507: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13508: LD_VAR 0 1
13512: PPUSH
13513: LD_VAR 0 2
13517: PPUSH
13518: CALL 77420 0 2
// end ;
13522: PPOPN 2
13524: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13525: LD_VAR 0 1
13529: PPUSH
13530: LD_VAR 0 2
13534: PPUSH
13535: LD_VAR 0 3
13539: PPUSH
13540: LD_VAR 0 4
13544: PPUSH
13545: LD_VAR 0 5
13549: PPUSH
13550: CALL 77040 0 5
// end ;
13554: PPOPN 5
13556: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13557: LD_VAR 0 1
13561: PPUSH
13562: LD_VAR 0 2
13566: PPUSH
13567: CALL 76636 0 2
// end ;
13571: PPOPN 2
13573: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13574: LD_VAR 0 1
13578: PPUSH
13579: CALL_OW 263
13583: PUSH
13584: LD_INT 3
13586: EQUAL
13587: PUSH
13588: LD_VAR 0 2
13592: PPUSH
13593: CALL_OW 263
13597: PUSH
13598: LD_INT 3
13600: EQUAL
13601: OR
13602: IFFALSE 13618
// hack_counter := hack_counter + 1 ;
13604: LD_ADDR_EXP 14
13608: PUSH
13609: LD_EXP 14
13613: PUSH
13614: LD_INT 1
13616: PLUS
13617: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13618: LD_VAR 0 1
13622: PPUSH
13623: LD_VAR 0 2
13627: PPUSH
13628: LD_VAR 0 3
13632: PPUSH
13633: LD_VAR 0 4
13637: PPUSH
13638: CALL 76474 0 4
// end ;
13642: PPOPN 4
13644: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13645: LD_VAR 0 1
13649: PPUSH
13650: LD_VAR 0 2
13654: PPUSH
13655: LD_VAR 0 3
13659: PPUSH
13660: CALL 76249 0 3
// end ;
13664: PPOPN 3
13666: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13667: LD_VAR 0 1
13671: PPUSH
13672: LD_VAR 0 2
13676: PPUSH
13677: CALL 76134 0 2
// end ;
13681: PPOPN 2
13683: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13684: LD_VAR 0 1
13688: PPUSH
13689: LD_VAR 0 2
13693: PPUSH
13694: CALL 80319 0 2
// end ;
13698: PPOPN 2
13700: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13701: LD_VAR 0 1
13705: PPUSH
13706: LD_VAR 0 2
13710: PPUSH
13711: LD_VAR 0 3
13715: PPUSH
13716: LD_VAR 0 4
13720: PPUSH
13721: CALL 80535 0 4
// end ;
13725: PPOPN 4
13727: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13728: LD_VAR 0 1
13732: PPUSH
13733: LD_VAR 0 2
13737: PPUSH
13738: CALL 75943 0 2
// end ;
13742: PPOPN 2
13744: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13745: LD_VAR 0 1
13749: PPUSH
13750: CALL 93576 0 1
// end ; end_of_file
13754: PPOPN 1
13756: END
// every 0 0$30 do var cr , time ;
13757: GO 13759
13759: DISABLE
13760: LD_INT 0
13762: PPUSH
13763: PPUSH
// begin time := 0 0$30 ;
13764: LD_ADDR_VAR 0 2
13768: PUSH
13769: LD_INT 1050
13771: ST_TO_ADDR
// while game do
13772: LD_EXP 2
13776: IFFALSE 13875
// begin wait ( time ) ;
13778: LD_VAR 0 2
13782: PPUSH
13783: CALL_OW 67
// if tick > 2 2$00 then
13787: LD_OWVAR 1
13791: PUSH
13792: LD_INT 4200
13794: GREATER
13795: IFFALSE 13828
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13797: LD_ADDR_VAR 0 2
13801: PUSH
13802: LD_VAR 0 2
13806: PUSH
13807: LD_INT 280
13809: PUSH
13810: LD_INT 420
13812: PUSH
13813: LD_INT 630
13815: PUSH
13816: EMPTY
13817: LIST
13818: LIST
13819: LIST
13820: PUSH
13821: LD_OWVAR 67
13825: ARRAY
13826: PLUS
13827: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13828: LD_INT 1
13830: PPUSH
13831: LD_INT 5
13833: PPUSH
13834: CALL_OW 12
13838: PPUSH
13839: LD_INT 70
13841: PPUSH
13842: LD_INT 49
13844: PPUSH
13845: LD_INT 25
13847: PPUSH
13848: LD_INT 1
13850: PPUSH
13851: CALL_OW 56
// if time > 5 5$00 then
13855: LD_VAR 0 2
13859: PUSH
13860: LD_INT 10500
13862: GREATER
13863: IFFALSE 13873
// time := 0 0$30 ;
13865: LD_ADDR_VAR 0 2
13869: PUSH
13870: LD_INT 1050
13872: ST_TO_ADDR
// end ;
13873: GO 13772
// end ;
13875: PPOPN 2
13877: END
// every 0 0$30 do var cr , time ;
13878: GO 13880
13880: DISABLE
13881: LD_INT 0
13883: PPUSH
13884: PPUSH
// begin time := 0 0$20 ;
13885: LD_ADDR_VAR 0 2
13889: PUSH
13890: LD_INT 700
13892: ST_TO_ADDR
// while game do
13893: LD_EXP 2
13897: IFFALSE 13986
// begin wait ( time ) ;
13899: LD_VAR 0 2
13903: PPUSH
13904: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13908: LD_ADDR_VAR 0 2
13912: PUSH
13913: LD_VAR 0 2
13917: PUSH
13918: LD_INT 490
13920: PUSH
13921: LD_INT 525
13923: PUSH
13924: LD_INT 560
13926: PUSH
13927: EMPTY
13928: LIST
13929: LIST
13930: LIST
13931: PUSH
13932: LD_OWVAR 67
13936: ARRAY
13937: PLUS
13938: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13939: LD_INT 3
13941: PPUSH
13942: LD_INT 5
13944: PPUSH
13945: CALL_OW 12
13949: PPUSH
13950: LD_INT 26
13952: PPUSH
13953: LD_INT 9
13955: PPUSH
13956: LD_INT 30
13958: PPUSH
13959: LD_INT 1
13961: PPUSH
13962: CALL_OW 56
// if time > 3 3$00 then
13966: LD_VAR 0 2
13970: PUSH
13971: LD_INT 6300
13973: GREATER
13974: IFFALSE 13984
// time := 0 0$20 ;
13976: LD_ADDR_VAR 0 2
13980: PUSH
13981: LD_INT 700
13983: ST_TO_ADDR
// end ;
13984: GO 13893
// end ;
13986: PPOPN 2
13988: END
// every 0 0$30 do var cr , time ;
13989: GO 13991
13991: DISABLE
13992: LD_INT 0
13994: PPUSH
13995: PPUSH
// begin time := 0 0$20 ;
13996: LD_ADDR_VAR 0 2
14000: PUSH
14001: LD_INT 700
14003: ST_TO_ADDR
// while game do
14004: LD_EXP 2
14008: IFFALSE 14133
// begin wait ( time ) ;
14010: LD_VAR 0 2
14014: PPUSH
14015: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14019: LD_ADDR_VAR 0 2
14023: PUSH
14024: LD_VAR 0 2
14028: PUSH
14029: LD_INT 175
14031: PUSH
14032: LD_INT 210
14034: PUSH
14035: LD_INT 280
14037: PUSH
14038: EMPTY
14039: LIST
14040: LIST
14041: LIST
14042: PUSH
14043: LD_OWVAR 67
14047: ARRAY
14048: PLUS
14049: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14050: LD_INT 1
14052: PPUSH
14053: LD_INT 5
14055: PPUSH
14056: CALL_OW 12
14060: PPUSH
14061: LD_INT 179
14063: PPUSH
14064: LD_INT 101
14066: PPUSH
14067: LD_INT 20
14069: PPUSH
14070: LD_INT 1
14072: PPUSH
14073: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14077: LD_INT 350
14079: PPUSH
14080: LD_INT 525
14082: PPUSH
14083: CALL_OW 12
14087: PPUSH
14088: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14092: LD_INT 1
14094: PPUSH
14095: LD_INT 5
14097: PPUSH
14098: CALL_OW 12
14102: PPUSH
14103: LD_INT 9
14105: PPUSH
14106: LD_INT 1
14108: PPUSH
14109: CALL_OW 55
// if time > 4 4$00 then
14113: LD_VAR 0 2
14117: PUSH
14118: LD_INT 8400
14120: GREATER
14121: IFFALSE 14131
// time := 0 0$30 ;
14123: LD_ADDR_VAR 0 2
14127: PUSH
14128: LD_INT 1050
14130: ST_TO_ADDR
// end ;
14131: GO 14004
// end ;
14133: PPOPN 2
14135: END
// every 0 0$30 do var cr , time ;
14136: GO 14138
14138: DISABLE
14139: LD_INT 0
14141: PPUSH
14142: PPUSH
// begin time := 0 0$10 ;
14143: LD_ADDR_VAR 0 2
14147: PUSH
14148: LD_INT 350
14150: ST_TO_ADDR
// while game do
14151: LD_EXP 2
14155: IFFALSE 14289
// begin wait ( time ) ;
14157: LD_VAR 0 2
14161: PPUSH
14162: CALL_OW 67
// time := time + 0 0$10 ;
14166: LD_ADDR_VAR 0 2
14170: PUSH
14171: LD_VAR 0 2
14175: PUSH
14176: LD_INT 350
14178: PLUS
14179: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14180: LD_INT 1
14182: PPUSH
14183: LD_INT 5
14185: PPUSH
14186: CALL_OW 12
14190: PPUSH
14191: LD_INT 11
14193: PPUSH
14194: LD_INT 1
14196: PPUSH
14197: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14201: LD_ADDR_VAR 0 1
14205: PUSH
14206: LD_INT 1
14208: PPUSH
14209: LD_INT 3
14211: PPUSH
14212: CALL_OW 12
14216: ST_TO_ADDR
// if cr = 1 then
14217: LD_VAR 0 1
14221: PUSH
14222: LD_INT 1
14224: EQUAL
14225: IFFALSE 14269
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14227: LD_INT 700
14229: PPUSH
14230: LD_INT 1575
14232: PPUSH
14233: CALL_OW 12
14237: PPUSH
14238: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14242: LD_INT 1
14244: PPUSH
14245: LD_INT 5
14247: PPUSH
14248: CALL_OW 12
14252: PPUSH
14253: LD_INT 34
14255: PPUSH
14256: LD_INT 50
14258: PPUSH
14259: LD_INT 7
14261: PPUSH
14262: LD_INT 1
14264: PPUSH
14265: CALL_OW 56
// end ; if time > 8 8$00 then
14269: LD_VAR 0 2
14273: PUSH
14274: LD_INT 16800
14276: GREATER
14277: IFFALSE 14287
// time := 0 0$40 ;
14279: LD_ADDR_VAR 0 2
14283: PUSH
14284: LD_INT 1400
14286: ST_TO_ADDR
// end ;
14287: GO 14151
// end ; end_of_file
14289: PPOPN 2
14291: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14292: LD_INT 0
14294: PPUSH
14295: PPUSH
// if exist_mode then
14296: LD_VAR 0 2
14300: IFFALSE 14325
// unit := CreateCharacter ( prefix & ident ) else
14302: LD_ADDR_VAR 0 5
14306: PUSH
14307: LD_VAR 0 3
14311: PUSH
14312: LD_VAR 0 1
14316: STR
14317: PPUSH
14318: CALL_OW 34
14322: ST_TO_ADDR
14323: GO 14340
// unit := NewCharacter ( ident ) ;
14325: LD_ADDR_VAR 0 5
14329: PUSH
14330: LD_VAR 0 1
14334: PPUSH
14335: CALL_OW 25
14339: ST_TO_ADDR
// result := unit ;
14340: LD_ADDR_VAR 0 4
14344: PUSH
14345: LD_VAR 0 5
14349: ST_TO_ADDR
// end ;
14350: LD_VAR 0 4
14354: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14355: LD_INT 0
14357: PPUSH
14358: PPUSH
// if not side or not nation then
14359: LD_VAR 0 1
14363: NOT
14364: PUSH
14365: LD_VAR 0 2
14369: NOT
14370: OR
14371: IFFALSE 14375
// exit ;
14373: GO 15139
// case nation of nation_american :
14375: LD_VAR 0 2
14379: PUSH
14380: LD_INT 1
14382: DOUBLE
14383: EQUAL
14384: IFTRUE 14388
14386: GO 14602
14388: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14389: LD_ADDR_VAR 0 4
14393: PUSH
14394: LD_INT 35
14396: PUSH
14397: LD_INT 45
14399: PUSH
14400: LD_INT 46
14402: PUSH
14403: LD_INT 47
14405: PUSH
14406: LD_INT 82
14408: PUSH
14409: LD_INT 83
14411: PUSH
14412: LD_INT 84
14414: PUSH
14415: LD_INT 85
14417: PUSH
14418: LD_INT 86
14420: PUSH
14421: LD_INT 1
14423: PUSH
14424: LD_INT 2
14426: PUSH
14427: LD_INT 6
14429: PUSH
14430: LD_INT 15
14432: PUSH
14433: LD_INT 16
14435: PUSH
14436: LD_INT 7
14438: PUSH
14439: LD_INT 12
14441: PUSH
14442: LD_INT 13
14444: PUSH
14445: LD_INT 10
14447: PUSH
14448: LD_INT 14
14450: PUSH
14451: LD_INT 20
14453: PUSH
14454: LD_INT 21
14456: PUSH
14457: LD_INT 22
14459: PUSH
14460: LD_INT 25
14462: PUSH
14463: LD_INT 32
14465: PUSH
14466: LD_INT 27
14468: PUSH
14469: LD_INT 36
14471: PUSH
14472: LD_INT 69
14474: PUSH
14475: LD_INT 39
14477: PUSH
14478: LD_INT 34
14480: PUSH
14481: LD_INT 40
14483: PUSH
14484: LD_INT 48
14486: PUSH
14487: LD_INT 49
14489: PUSH
14490: LD_INT 50
14492: PUSH
14493: LD_INT 51
14495: PUSH
14496: LD_INT 52
14498: PUSH
14499: LD_INT 53
14501: PUSH
14502: LD_INT 54
14504: PUSH
14505: LD_INT 55
14507: PUSH
14508: LD_INT 56
14510: PUSH
14511: LD_INT 57
14513: PUSH
14514: LD_INT 58
14516: PUSH
14517: LD_INT 59
14519: PUSH
14520: LD_INT 60
14522: PUSH
14523: LD_INT 61
14525: PUSH
14526: LD_INT 62
14528: PUSH
14529: LD_INT 80
14531: PUSH
14532: LD_INT 82
14534: PUSH
14535: LD_INT 83
14537: PUSH
14538: LD_INT 84
14540: PUSH
14541: LD_INT 85
14543: PUSH
14544: LD_INT 86
14546: PUSH
14547: EMPTY
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: ST_TO_ADDR
14600: GO 15063
14602: LD_INT 2
14604: DOUBLE
14605: EQUAL
14606: IFTRUE 14610
14608: GO 14832
14610: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14611: LD_ADDR_VAR 0 4
14615: PUSH
14616: LD_INT 35
14618: PUSH
14619: LD_INT 45
14621: PUSH
14622: LD_INT 46
14624: PUSH
14625: LD_INT 47
14627: PUSH
14628: LD_INT 82
14630: PUSH
14631: LD_INT 83
14633: PUSH
14634: LD_INT 84
14636: PUSH
14637: LD_INT 85
14639: PUSH
14640: LD_INT 87
14642: PUSH
14643: LD_INT 70
14645: PUSH
14646: LD_INT 1
14648: PUSH
14649: LD_INT 11
14651: PUSH
14652: LD_INT 3
14654: PUSH
14655: LD_INT 4
14657: PUSH
14658: LD_INT 5
14660: PUSH
14661: LD_INT 6
14663: PUSH
14664: LD_INT 15
14666: PUSH
14667: LD_INT 18
14669: PUSH
14670: LD_INT 7
14672: PUSH
14673: LD_INT 17
14675: PUSH
14676: LD_INT 8
14678: PUSH
14679: LD_INT 20
14681: PUSH
14682: LD_INT 21
14684: PUSH
14685: LD_INT 22
14687: PUSH
14688: LD_INT 72
14690: PUSH
14691: LD_INT 26
14693: PUSH
14694: LD_INT 69
14696: PUSH
14697: LD_INT 39
14699: PUSH
14700: LD_INT 40
14702: PUSH
14703: LD_INT 41
14705: PUSH
14706: LD_INT 42
14708: PUSH
14709: LD_INT 43
14711: PUSH
14712: LD_INT 48
14714: PUSH
14715: LD_INT 49
14717: PUSH
14718: LD_INT 50
14720: PUSH
14721: LD_INT 51
14723: PUSH
14724: LD_INT 52
14726: PUSH
14727: LD_INT 53
14729: PUSH
14730: LD_INT 54
14732: PUSH
14733: LD_INT 55
14735: PUSH
14736: LD_INT 56
14738: PUSH
14739: LD_INT 60
14741: PUSH
14742: LD_INT 61
14744: PUSH
14745: LD_INT 62
14747: PUSH
14748: LD_INT 66
14750: PUSH
14751: LD_INT 67
14753: PUSH
14754: LD_INT 68
14756: PUSH
14757: LD_INT 81
14759: PUSH
14760: LD_INT 82
14762: PUSH
14763: LD_INT 83
14765: PUSH
14766: LD_INT 84
14768: PUSH
14769: LD_INT 85
14771: PUSH
14772: LD_INT 87
14774: PUSH
14775: EMPTY
14776: LIST
14777: LIST
14778: LIST
14779: LIST
14780: LIST
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: LIST
14795: LIST
14796: LIST
14797: LIST
14798: LIST
14799: LIST
14800: LIST
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: ST_TO_ADDR
14830: GO 15063
14832: LD_INT 3
14834: DOUBLE
14835: EQUAL
14836: IFTRUE 14840
14838: GO 15062
14840: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14841: LD_ADDR_VAR 0 4
14845: PUSH
14846: LD_INT 46
14848: PUSH
14849: LD_INT 47
14851: PUSH
14852: LD_INT 1
14854: PUSH
14855: LD_INT 2
14857: PUSH
14858: LD_INT 82
14860: PUSH
14861: LD_INT 83
14863: PUSH
14864: LD_INT 84
14866: PUSH
14867: LD_INT 85
14869: PUSH
14870: LD_INT 86
14872: PUSH
14873: LD_INT 11
14875: PUSH
14876: LD_INT 9
14878: PUSH
14879: LD_INT 20
14881: PUSH
14882: LD_INT 19
14884: PUSH
14885: LD_INT 21
14887: PUSH
14888: LD_INT 24
14890: PUSH
14891: LD_INT 22
14893: PUSH
14894: LD_INT 25
14896: PUSH
14897: LD_INT 28
14899: PUSH
14900: LD_INT 29
14902: PUSH
14903: LD_INT 30
14905: PUSH
14906: LD_INT 31
14908: PUSH
14909: LD_INT 37
14911: PUSH
14912: LD_INT 38
14914: PUSH
14915: LD_INT 32
14917: PUSH
14918: LD_INT 27
14920: PUSH
14921: LD_INT 33
14923: PUSH
14924: LD_INT 69
14926: PUSH
14927: LD_INT 39
14929: PUSH
14930: LD_INT 34
14932: PUSH
14933: LD_INT 40
14935: PUSH
14936: LD_INT 71
14938: PUSH
14939: LD_INT 23
14941: PUSH
14942: LD_INT 44
14944: PUSH
14945: LD_INT 48
14947: PUSH
14948: LD_INT 49
14950: PUSH
14951: LD_INT 50
14953: PUSH
14954: LD_INT 51
14956: PUSH
14957: LD_INT 52
14959: PUSH
14960: LD_INT 53
14962: PUSH
14963: LD_INT 54
14965: PUSH
14966: LD_INT 55
14968: PUSH
14969: LD_INT 56
14971: PUSH
14972: LD_INT 57
14974: PUSH
14975: LD_INT 58
14977: PUSH
14978: LD_INT 59
14980: PUSH
14981: LD_INT 63
14983: PUSH
14984: LD_INT 64
14986: PUSH
14987: LD_INT 65
14989: PUSH
14990: LD_INT 82
14992: PUSH
14993: LD_INT 83
14995: PUSH
14996: LD_INT 84
14998: PUSH
14999: LD_INT 85
15001: PUSH
15002: LD_INT 86
15004: PUSH
15005: EMPTY
15006: LIST
15007: LIST
15008: LIST
15009: LIST
15010: LIST
15011: LIST
15012: LIST
15013: LIST
15014: LIST
15015: LIST
15016: LIST
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: LIST
15022: LIST
15023: LIST
15024: LIST
15025: LIST
15026: LIST
15027: LIST
15028: LIST
15029: LIST
15030: LIST
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: ST_TO_ADDR
15060: GO 15063
15062: POP
// if state > - 1 and state < 3 then
15063: LD_VAR 0 3
15067: PUSH
15068: LD_INT 1
15070: NEG
15071: GREATER
15072: PUSH
15073: LD_VAR 0 3
15077: PUSH
15078: LD_INT 3
15080: LESS
15081: AND
15082: IFFALSE 15139
// for i in result do
15084: LD_ADDR_VAR 0 5
15088: PUSH
15089: LD_VAR 0 4
15093: PUSH
15094: FOR_IN
15095: IFFALSE 15137
// if GetTech ( i , side ) <> state then
15097: LD_VAR 0 5
15101: PPUSH
15102: LD_VAR 0 1
15106: PPUSH
15107: CALL_OW 321
15111: PUSH
15112: LD_VAR 0 3
15116: NONEQUAL
15117: IFFALSE 15135
// result := result diff i ;
15119: LD_ADDR_VAR 0 4
15123: PUSH
15124: LD_VAR 0 4
15128: PUSH
15129: LD_VAR 0 5
15133: DIFF
15134: ST_TO_ADDR
15135: GO 15094
15137: POP
15138: POP
// end ;
15139: LD_VAR 0 4
15143: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15144: LD_INT 0
15146: PPUSH
15147: PPUSH
15148: PPUSH
// result := true ;
15149: LD_ADDR_VAR 0 3
15153: PUSH
15154: LD_INT 1
15156: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15157: LD_ADDR_VAR 0 5
15161: PUSH
15162: LD_VAR 0 2
15166: PPUSH
15167: CALL_OW 480
15171: ST_TO_ADDR
// if not tmp then
15172: LD_VAR 0 5
15176: NOT
15177: IFFALSE 15181
// exit ;
15179: GO 15230
// for i in tmp do
15181: LD_ADDR_VAR 0 4
15185: PUSH
15186: LD_VAR 0 5
15190: PUSH
15191: FOR_IN
15192: IFFALSE 15228
// if GetTech ( i , side ) <> state_researched then
15194: LD_VAR 0 4
15198: PPUSH
15199: LD_VAR 0 1
15203: PPUSH
15204: CALL_OW 321
15208: PUSH
15209: LD_INT 2
15211: NONEQUAL
15212: IFFALSE 15226
// begin result := false ;
15214: LD_ADDR_VAR 0 3
15218: PUSH
15219: LD_INT 0
15221: ST_TO_ADDR
// exit ;
15222: POP
15223: POP
15224: GO 15230
// end ;
15226: GO 15191
15228: POP
15229: POP
// end ;
15230: LD_VAR 0 3
15234: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15235: LD_INT 0
15237: PPUSH
15238: PPUSH
15239: PPUSH
15240: PPUSH
15241: PPUSH
15242: PPUSH
15243: PPUSH
15244: PPUSH
15245: PPUSH
15246: PPUSH
15247: PPUSH
15248: PPUSH
15249: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15250: LD_VAR 0 1
15254: NOT
15255: PUSH
15256: LD_VAR 0 1
15260: PPUSH
15261: CALL_OW 257
15265: PUSH
15266: LD_INT 9
15268: NONEQUAL
15269: OR
15270: IFFALSE 15274
// exit ;
15272: GO 15847
// side := GetSide ( unit ) ;
15274: LD_ADDR_VAR 0 9
15278: PUSH
15279: LD_VAR 0 1
15283: PPUSH
15284: CALL_OW 255
15288: ST_TO_ADDR
// tech_space := tech_spacanom ;
15289: LD_ADDR_VAR 0 12
15293: PUSH
15294: LD_INT 29
15296: ST_TO_ADDR
// tech_time := tech_taurad ;
15297: LD_ADDR_VAR 0 13
15301: PUSH
15302: LD_INT 28
15304: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15305: LD_ADDR_VAR 0 11
15309: PUSH
15310: LD_VAR 0 1
15314: PPUSH
15315: CALL_OW 310
15319: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15320: LD_VAR 0 11
15324: PPUSH
15325: CALL_OW 247
15329: PUSH
15330: LD_INT 2
15332: EQUAL
15333: IFFALSE 15337
// exit ;
15335: GO 15847
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15337: LD_ADDR_VAR 0 8
15341: PUSH
15342: LD_INT 81
15344: PUSH
15345: LD_VAR 0 9
15349: PUSH
15350: EMPTY
15351: LIST
15352: LIST
15353: PUSH
15354: LD_INT 3
15356: PUSH
15357: LD_INT 21
15359: PUSH
15360: LD_INT 3
15362: PUSH
15363: EMPTY
15364: LIST
15365: LIST
15366: PUSH
15367: EMPTY
15368: LIST
15369: LIST
15370: PUSH
15371: EMPTY
15372: LIST
15373: LIST
15374: PPUSH
15375: CALL_OW 69
15379: ST_TO_ADDR
// if not tmp then
15380: LD_VAR 0 8
15384: NOT
15385: IFFALSE 15389
// exit ;
15387: GO 15847
// if in_unit then
15389: LD_VAR 0 11
15393: IFFALSE 15417
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15395: LD_ADDR_VAR 0 10
15399: PUSH
15400: LD_VAR 0 8
15404: PPUSH
15405: LD_VAR 0 11
15409: PPUSH
15410: CALL_OW 74
15414: ST_TO_ADDR
15415: GO 15437
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15417: LD_ADDR_VAR 0 10
15421: PUSH
15422: LD_VAR 0 8
15426: PPUSH
15427: LD_VAR 0 1
15431: PPUSH
15432: CALL_OW 74
15436: ST_TO_ADDR
// if not enemy then
15437: LD_VAR 0 10
15441: NOT
15442: IFFALSE 15446
// exit ;
15444: GO 15847
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15446: LD_VAR 0 11
15450: PUSH
15451: LD_VAR 0 11
15455: PPUSH
15456: LD_VAR 0 10
15460: PPUSH
15461: CALL_OW 296
15465: PUSH
15466: LD_INT 13
15468: GREATER
15469: AND
15470: PUSH
15471: LD_VAR 0 1
15475: PPUSH
15476: LD_VAR 0 10
15480: PPUSH
15481: CALL_OW 296
15485: PUSH
15486: LD_INT 12
15488: GREATER
15489: OR
15490: IFFALSE 15494
// exit ;
15492: GO 15847
// missile := [ 1 ] ;
15494: LD_ADDR_VAR 0 14
15498: PUSH
15499: LD_INT 1
15501: PUSH
15502: EMPTY
15503: LIST
15504: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15505: LD_VAR 0 9
15509: PPUSH
15510: LD_VAR 0 12
15514: PPUSH
15515: CALL_OW 325
15519: IFFALSE 15548
// missile := Insert ( missile , missile + 1 , 2 ) ;
15521: LD_ADDR_VAR 0 14
15525: PUSH
15526: LD_VAR 0 14
15530: PPUSH
15531: LD_VAR 0 14
15535: PUSH
15536: LD_INT 1
15538: PLUS
15539: PPUSH
15540: LD_INT 2
15542: PPUSH
15543: CALL_OW 2
15547: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15548: LD_VAR 0 9
15552: PPUSH
15553: LD_VAR 0 13
15557: PPUSH
15558: CALL_OW 325
15562: PUSH
15563: LD_VAR 0 10
15567: PPUSH
15568: CALL_OW 255
15572: PPUSH
15573: LD_VAR 0 13
15577: PPUSH
15578: CALL_OW 325
15582: NOT
15583: AND
15584: IFFALSE 15613
// missile := Insert ( missile , missile + 1 , 3 ) ;
15586: LD_ADDR_VAR 0 14
15590: PUSH
15591: LD_VAR 0 14
15595: PPUSH
15596: LD_VAR 0 14
15600: PUSH
15601: LD_INT 1
15603: PLUS
15604: PPUSH
15605: LD_INT 3
15607: PPUSH
15608: CALL_OW 2
15612: ST_TO_ADDR
// if missile < 2 then
15613: LD_VAR 0 14
15617: PUSH
15618: LD_INT 2
15620: LESS
15621: IFFALSE 15625
// exit ;
15623: GO 15847
// x := GetX ( enemy ) ;
15625: LD_ADDR_VAR 0 4
15629: PUSH
15630: LD_VAR 0 10
15634: PPUSH
15635: CALL_OW 250
15639: ST_TO_ADDR
// y := GetY ( enemy ) ;
15640: LD_ADDR_VAR 0 5
15644: PUSH
15645: LD_VAR 0 10
15649: PPUSH
15650: CALL_OW 251
15654: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15655: LD_ADDR_VAR 0 6
15659: PUSH
15660: LD_VAR 0 4
15664: PUSH
15665: LD_INT 1
15667: NEG
15668: PPUSH
15669: LD_INT 1
15671: PPUSH
15672: CALL_OW 12
15676: PLUS
15677: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15678: LD_ADDR_VAR 0 7
15682: PUSH
15683: LD_VAR 0 5
15687: PUSH
15688: LD_INT 1
15690: NEG
15691: PPUSH
15692: LD_INT 1
15694: PPUSH
15695: CALL_OW 12
15699: PLUS
15700: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15701: LD_VAR 0 6
15705: PPUSH
15706: LD_VAR 0 7
15710: PPUSH
15711: CALL_OW 488
15715: NOT
15716: IFFALSE 15738
// begin _x := x ;
15718: LD_ADDR_VAR 0 6
15722: PUSH
15723: LD_VAR 0 4
15727: ST_TO_ADDR
// _y := y ;
15728: LD_ADDR_VAR 0 7
15732: PUSH
15733: LD_VAR 0 5
15737: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15738: LD_ADDR_VAR 0 3
15742: PUSH
15743: LD_INT 1
15745: PPUSH
15746: LD_VAR 0 14
15750: PPUSH
15751: CALL_OW 12
15755: ST_TO_ADDR
// case i of 1 :
15756: LD_VAR 0 3
15760: PUSH
15761: LD_INT 1
15763: DOUBLE
15764: EQUAL
15765: IFTRUE 15769
15767: GO 15786
15769: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15770: LD_VAR 0 1
15774: PPUSH
15775: LD_VAR 0 10
15779: PPUSH
15780: CALL_OW 115
15784: GO 15847
15786: LD_INT 2
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15816
15794: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 6
15804: PPUSH
15805: LD_VAR 0 7
15809: PPUSH
15810: CALL_OW 153
15814: GO 15847
15816: LD_INT 3
15818: DOUBLE
15819: EQUAL
15820: IFTRUE 15824
15822: GO 15846
15824: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15825: LD_VAR 0 1
15829: PPUSH
15830: LD_VAR 0 6
15834: PPUSH
15835: LD_VAR 0 7
15839: PPUSH
15840: CALL_OW 154
15844: GO 15847
15846: POP
// end ;
15847: LD_VAR 0 2
15851: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15852: LD_INT 0
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
15858: PPUSH
15859: PPUSH
// if not unit or not building then
15860: LD_VAR 0 1
15864: NOT
15865: PUSH
15866: LD_VAR 0 2
15870: NOT
15871: OR
15872: IFFALSE 15876
// exit ;
15874: GO 16034
// x := GetX ( building ) ;
15876: LD_ADDR_VAR 0 5
15880: PUSH
15881: LD_VAR 0 2
15885: PPUSH
15886: CALL_OW 250
15890: ST_TO_ADDR
// y := GetY ( building ) ;
15891: LD_ADDR_VAR 0 6
15895: PUSH
15896: LD_VAR 0 2
15900: PPUSH
15901: CALL_OW 251
15905: ST_TO_ADDR
// for i = 0 to 5 do
15906: LD_ADDR_VAR 0 4
15910: PUSH
15911: DOUBLE
15912: LD_INT 0
15914: DEC
15915: ST_TO_ADDR
15916: LD_INT 5
15918: PUSH
15919: FOR_TO
15920: IFFALSE 16032
// begin _x := ShiftX ( x , i , 3 ) ;
15922: LD_ADDR_VAR 0 7
15926: PUSH
15927: LD_VAR 0 5
15931: PPUSH
15932: LD_VAR 0 4
15936: PPUSH
15937: LD_INT 3
15939: PPUSH
15940: CALL_OW 272
15944: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15945: LD_ADDR_VAR 0 8
15949: PUSH
15950: LD_VAR 0 6
15954: PPUSH
15955: LD_VAR 0 4
15959: PPUSH
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 273
15967: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15968: LD_VAR 0 7
15972: PPUSH
15973: LD_VAR 0 8
15977: PPUSH
15978: CALL_OW 488
15982: NOT
15983: IFFALSE 15987
// continue ;
15985: GO 15919
// if HexInfo ( _x , _y ) = 0 then
15987: LD_VAR 0 7
15991: PPUSH
15992: LD_VAR 0 8
15996: PPUSH
15997: CALL_OW 428
16001: PUSH
16002: LD_INT 0
16004: EQUAL
16005: IFFALSE 16030
// begin ComMoveXY ( unit , _x , _y ) ;
16007: LD_VAR 0 1
16011: PPUSH
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 111
// exit ;
16026: POP
16027: POP
16028: GO 16034
// end ; end ;
16030: GO 15919
16032: POP
16033: POP
// end ;
16034: LD_VAR 0 3
16038: RET
// export function ScanBase ( side , base_area ) ; begin
16039: LD_INT 0
16041: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16042: LD_ADDR_VAR 0 3
16046: PUSH
16047: LD_VAR 0 2
16051: PPUSH
16052: LD_INT 81
16054: PUSH
16055: LD_VAR 0 1
16059: PUSH
16060: EMPTY
16061: LIST
16062: LIST
16063: PPUSH
16064: CALL_OW 70
16068: ST_TO_ADDR
// end ;
16069: LD_VAR 0 3
16073: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16074: LD_INT 0
16076: PPUSH
16077: PPUSH
16078: PPUSH
16079: PPUSH
// result := false ;
16080: LD_ADDR_VAR 0 2
16084: PUSH
16085: LD_INT 0
16087: ST_TO_ADDR
// side := GetSide ( unit ) ;
16088: LD_ADDR_VAR 0 3
16092: PUSH
16093: LD_VAR 0 1
16097: PPUSH
16098: CALL_OW 255
16102: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16103: LD_ADDR_VAR 0 4
16107: PUSH
16108: LD_VAR 0 1
16112: PPUSH
16113: CALL_OW 248
16117: ST_TO_ADDR
// case nat of 1 :
16118: LD_VAR 0 4
16122: PUSH
16123: LD_INT 1
16125: DOUBLE
16126: EQUAL
16127: IFTRUE 16131
16129: GO 16142
16131: POP
// tech := tech_lassight ; 2 :
16132: LD_ADDR_VAR 0 5
16136: PUSH
16137: LD_INT 12
16139: ST_TO_ADDR
16140: GO 16181
16142: LD_INT 2
16144: DOUBLE
16145: EQUAL
16146: IFTRUE 16150
16148: GO 16161
16150: POP
// tech := tech_mortar ; 3 :
16151: LD_ADDR_VAR 0 5
16155: PUSH
16156: LD_INT 41
16158: ST_TO_ADDR
16159: GO 16181
16161: LD_INT 3
16163: DOUBLE
16164: EQUAL
16165: IFTRUE 16169
16167: GO 16180
16169: POP
// tech := tech_bazooka ; end ;
16170: LD_ADDR_VAR 0 5
16174: PUSH
16175: LD_INT 44
16177: ST_TO_ADDR
16178: GO 16181
16180: POP
// if Researched ( side , tech ) then
16181: LD_VAR 0 3
16185: PPUSH
16186: LD_VAR 0 5
16190: PPUSH
16191: CALL_OW 325
16195: IFFALSE 16222
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16197: LD_ADDR_VAR 0 2
16201: PUSH
16202: LD_INT 5
16204: PUSH
16205: LD_INT 8
16207: PUSH
16208: LD_INT 9
16210: PUSH
16211: EMPTY
16212: LIST
16213: LIST
16214: LIST
16215: PUSH
16216: LD_VAR 0 4
16220: ARRAY
16221: ST_TO_ADDR
// end ;
16222: LD_VAR 0 2
16226: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16227: LD_INT 0
16229: PPUSH
16230: PPUSH
16231: PPUSH
// if not mines then
16232: LD_VAR 0 2
16236: NOT
16237: IFFALSE 16241
// exit ;
16239: GO 16385
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16241: LD_ADDR_VAR 0 5
16245: PUSH
16246: LD_INT 81
16248: PUSH
16249: LD_VAR 0 1
16253: PUSH
16254: EMPTY
16255: LIST
16256: LIST
16257: PUSH
16258: LD_INT 3
16260: PUSH
16261: LD_INT 21
16263: PUSH
16264: LD_INT 3
16266: PUSH
16267: EMPTY
16268: LIST
16269: LIST
16270: PUSH
16271: EMPTY
16272: LIST
16273: LIST
16274: PUSH
16275: EMPTY
16276: LIST
16277: LIST
16278: PPUSH
16279: CALL_OW 69
16283: ST_TO_ADDR
// for i in mines do
16284: LD_ADDR_VAR 0 4
16288: PUSH
16289: LD_VAR 0 2
16293: PUSH
16294: FOR_IN
16295: IFFALSE 16383
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16297: LD_VAR 0 4
16301: PUSH
16302: LD_INT 1
16304: ARRAY
16305: PPUSH
16306: LD_VAR 0 4
16310: PUSH
16311: LD_INT 2
16313: ARRAY
16314: PPUSH
16315: CALL_OW 458
16319: NOT
16320: IFFALSE 16324
// continue ;
16322: GO 16294
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16324: LD_VAR 0 4
16328: PUSH
16329: LD_INT 1
16331: ARRAY
16332: PPUSH
16333: LD_VAR 0 4
16337: PUSH
16338: LD_INT 2
16340: ARRAY
16341: PPUSH
16342: CALL_OW 428
16346: PUSH
16347: LD_VAR 0 5
16351: IN
16352: IFFALSE 16381
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16354: LD_VAR 0 4
16358: PUSH
16359: LD_INT 1
16361: ARRAY
16362: PPUSH
16363: LD_VAR 0 4
16367: PUSH
16368: LD_INT 2
16370: ARRAY
16371: PPUSH
16372: LD_VAR 0 1
16376: PPUSH
16377: CALL_OW 456
// end ;
16381: GO 16294
16383: POP
16384: POP
// end ;
16385: LD_VAR 0 3
16389: RET
// export function Count ( array ) ; var i ; begin
16390: LD_INT 0
16392: PPUSH
16393: PPUSH
// result := 0 ;
16394: LD_ADDR_VAR 0 2
16398: PUSH
16399: LD_INT 0
16401: ST_TO_ADDR
// for i in array do
16402: LD_ADDR_VAR 0 3
16406: PUSH
16407: LD_VAR 0 1
16411: PUSH
16412: FOR_IN
16413: IFFALSE 16437
// if i then
16415: LD_VAR 0 3
16419: IFFALSE 16435
// result := result + 1 ;
16421: LD_ADDR_VAR 0 2
16425: PUSH
16426: LD_VAR 0 2
16430: PUSH
16431: LD_INT 1
16433: PLUS
16434: ST_TO_ADDR
16435: GO 16412
16437: POP
16438: POP
// end ;
16439: LD_VAR 0 2
16443: RET
// export function IsEmpty ( building ) ; begin
16444: LD_INT 0
16446: PPUSH
// if not building then
16447: LD_VAR 0 1
16451: NOT
16452: IFFALSE 16456
// exit ;
16454: GO 16499
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16456: LD_ADDR_VAR 0 2
16460: PUSH
16461: LD_VAR 0 1
16465: PUSH
16466: LD_INT 22
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 255
16478: PUSH
16479: EMPTY
16480: LIST
16481: LIST
16482: PUSH
16483: LD_INT 58
16485: PUSH
16486: EMPTY
16487: LIST
16488: PUSH
16489: EMPTY
16490: LIST
16491: LIST
16492: PPUSH
16493: CALL_OW 69
16497: IN
16498: ST_TO_ADDR
// end ;
16499: LD_VAR 0 2
16503: RET
// export function IsNotFull ( building ) ; begin
16504: LD_INT 0
16506: PPUSH
// if not building then
16507: LD_VAR 0 1
16511: NOT
16512: IFFALSE 16516
// exit ;
16514: GO 16535
// result := UnitsInside ( building ) < 6 ;
16516: LD_ADDR_VAR 0 2
16520: PUSH
16521: LD_VAR 0 1
16525: PPUSH
16526: CALL_OW 313
16530: PUSH
16531: LD_INT 6
16533: LESS
16534: ST_TO_ADDR
// end ;
16535: LD_VAR 0 2
16539: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16540: LD_INT 0
16542: PPUSH
16543: PPUSH
16544: PPUSH
16545: PPUSH
// tmp := [ ] ;
16546: LD_ADDR_VAR 0 3
16550: PUSH
16551: EMPTY
16552: ST_TO_ADDR
// list := [ ] ;
16553: LD_ADDR_VAR 0 5
16557: PUSH
16558: EMPTY
16559: ST_TO_ADDR
// for i = 16 to 25 do
16560: LD_ADDR_VAR 0 4
16564: PUSH
16565: DOUBLE
16566: LD_INT 16
16568: DEC
16569: ST_TO_ADDR
16570: LD_INT 25
16572: PUSH
16573: FOR_TO
16574: IFFALSE 16647
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16576: LD_ADDR_VAR 0 3
16580: PUSH
16581: LD_VAR 0 3
16585: PUSH
16586: LD_INT 22
16588: PUSH
16589: LD_VAR 0 1
16593: PPUSH
16594: CALL_OW 255
16598: PUSH
16599: EMPTY
16600: LIST
16601: LIST
16602: PUSH
16603: LD_INT 91
16605: PUSH
16606: LD_VAR 0 1
16610: PUSH
16611: LD_INT 6
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: LIST
16618: PUSH
16619: LD_INT 30
16621: PUSH
16622: LD_VAR 0 4
16626: PUSH
16627: EMPTY
16628: LIST
16629: LIST
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: LIST
16635: PUSH
16636: EMPTY
16637: LIST
16638: PPUSH
16639: CALL_OW 69
16643: ADD
16644: ST_TO_ADDR
16645: GO 16573
16647: POP
16648: POP
// for i = 1 to tmp do
16649: LD_ADDR_VAR 0 4
16653: PUSH
16654: DOUBLE
16655: LD_INT 1
16657: DEC
16658: ST_TO_ADDR
16659: LD_VAR 0 3
16663: PUSH
16664: FOR_TO
16665: IFFALSE 16753
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16667: LD_ADDR_VAR 0 5
16671: PUSH
16672: LD_VAR 0 5
16676: PUSH
16677: LD_VAR 0 3
16681: PUSH
16682: LD_VAR 0 4
16686: ARRAY
16687: PPUSH
16688: CALL_OW 266
16692: PUSH
16693: LD_VAR 0 3
16697: PUSH
16698: LD_VAR 0 4
16702: ARRAY
16703: PPUSH
16704: CALL_OW 250
16708: PUSH
16709: LD_VAR 0 3
16713: PUSH
16714: LD_VAR 0 4
16718: ARRAY
16719: PPUSH
16720: CALL_OW 251
16724: PUSH
16725: LD_VAR 0 3
16729: PUSH
16730: LD_VAR 0 4
16734: ARRAY
16735: PPUSH
16736: CALL_OW 254
16740: PUSH
16741: EMPTY
16742: LIST
16743: LIST
16744: LIST
16745: LIST
16746: PUSH
16747: EMPTY
16748: LIST
16749: ADD
16750: ST_TO_ADDR
16751: GO 16664
16753: POP
16754: POP
// result := list ;
16755: LD_ADDR_VAR 0 2
16759: PUSH
16760: LD_VAR 0 5
16764: ST_TO_ADDR
// end ;
16765: LD_VAR 0 2
16769: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16770: LD_INT 0
16772: PPUSH
16773: PPUSH
16774: PPUSH
16775: PPUSH
16776: PPUSH
16777: PPUSH
16778: PPUSH
// if not factory then
16779: LD_VAR 0 1
16783: NOT
16784: IFFALSE 16788
// exit ;
16786: GO 17381
// if control = control_apeman then
16788: LD_VAR 0 4
16792: PUSH
16793: LD_INT 5
16795: EQUAL
16796: IFFALSE 16905
// begin tmp := UnitsInside ( factory ) ;
16798: LD_ADDR_VAR 0 8
16802: PUSH
16803: LD_VAR 0 1
16807: PPUSH
16808: CALL_OW 313
16812: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16813: LD_VAR 0 8
16817: PPUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 12
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PPUSH
16828: CALL_OW 72
16832: NOT
16833: IFFALSE 16843
// control := control_manual ;
16835: LD_ADDR_VAR 0 4
16839: PUSH
16840: LD_INT 1
16842: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16843: LD_ADDR_VAR 0 8
16847: PUSH
16848: LD_VAR 0 1
16852: PPUSH
16853: CALL 16540 0 1
16857: ST_TO_ADDR
// if tmp then
16858: LD_VAR 0 8
16862: IFFALSE 16905
// begin for i in tmp do
16864: LD_ADDR_VAR 0 7
16868: PUSH
16869: LD_VAR 0 8
16873: PUSH
16874: FOR_IN
16875: IFFALSE 16903
// if i [ 1 ] = b_ext_radio then
16877: LD_VAR 0 7
16881: PUSH
16882: LD_INT 1
16884: ARRAY
16885: PUSH
16886: LD_INT 22
16888: EQUAL
16889: IFFALSE 16901
// begin control := control_remote ;
16891: LD_ADDR_VAR 0 4
16895: PUSH
16896: LD_INT 2
16898: ST_TO_ADDR
// break ;
16899: GO 16903
// end ;
16901: GO 16874
16903: POP
16904: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16905: LD_VAR 0 1
16909: PPUSH
16910: LD_VAR 0 2
16914: PPUSH
16915: LD_VAR 0 3
16919: PPUSH
16920: LD_VAR 0 4
16924: PPUSH
16925: LD_VAR 0 5
16929: PPUSH
16930: CALL_OW 448
16934: IFFALSE 16969
// begin result := [ chassis , engine , control , weapon ] ;
16936: LD_ADDR_VAR 0 6
16940: PUSH
16941: LD_VAR 0 2
16945: PUSH
16946: LD_VAR 0 3
16950: PUSH
16951: LD_VAR 0 4
16955: PUSH
16956: LD_VAR 0 5
16960: PUSH
16961: EMPTY
16962: LIST
16963: LIST
16964: LIST
16965: LIST
16966: ST_TO_ADDR
// exit ;
16967: GO 17381
// end ; _chassis := AvailableChassisList ( factory ) ;
16969: LD_ADDR_VAR 0 9
16973: PUSH
16974: LD_VAR 0 1
16978: PPUSH
16979: CALL_OW 475
16983: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
16984: LD_ADDR_VAR 0 11
16988: PUSH
16989: LD_VAR 0 1
16993: PPUSH
16994: CALL_OW 476
16998: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
16999: LD_ADDR_VAR 0 12
17003: PUSH
17004: LD_VAR 0 1
17008: PPUSH
17009: CALL_OW 477
17013: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17014: LD_ADDR_VAR 0 10
17018: PUSH
17019: LD_VAR 0 1
17023: PPUSH
17024: CALL_OW 478
17028: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17029: LD_VAR 0 9
17033: NOT
17034: PUSH
17035: LD_VAR 0 11
17039: NOT
17040: OR
17041: PUSH
17042: LD_VAR 0 12
17046: NOT
17047: OR
17048: PUSH
17049: LD_VAR 0 10
17053: NOT
17054: OR
17055: IFFALSE 17090
// begin result := [ chassis , engine , control , weapon ] ;
17057: LD_ADDR_VAR 0 6
17061: PUSH
17062: LD_VAR 0 2
17066: PUSH
17067: LD_VAR 0 3
17071: PUSH
17072: LD_VAR 0 4
17076: PUSH
17077: LD_VAR 0 5
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: LIST
17086: LIST
17087: ST_TO_ADDR
// exit ;
17088: GO 17381
// end ; if not chassis in _chassis then
17090: LD_VAR 0 2
17094: PUSH
17095: LD_VAR 0 9
17099: IN
17100: NOT
17101: IFFALSE 17127
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17103: LD_ADDR_VAR 0 2
17107: PUSH
17108: LD_VAR 0 9
17112: PUSH
17113: LD_INT 1
17115: PPUSH
17116: LD_VAR 0 9
17120: PPUSH
17121: CALL_OW 12
17125: ARRAY
17126: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17127: LD_VAR 0 2
17131: PPUSH
17132: LD_VAR 0 3
17136: PPUSH
17137: CALL 17386 0 2
17141: NOT
17142: IFFALSE 17201
// repeat engine := _engine [ 1 ] ;
17144: LD_ADDR_VAR 0 3
17148: PUSH
17149: LD_VAR 0 11
17153: PUSH
17154: LD_INT 1
17156: ARRAY
17157: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17158: LD_ADDR_VAR 0 11
17162: PUSH
17163: LD_VAR 0 11
17167: PPUSH
17168: LD_INT 1
17170: PPUSH
17171: CALL_OW 3
17175: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17176: LD_VAR 0 2
17180: PPUSH
17181: LD_VAR 0 3
17185: PPUSH
17186: CALL 17386 0 2
17190: PUSH
17191: LD_VAR 0 11
17195: PUSH
17196: EMPTY
17197: EQUAL
17198: OR
17199: IFFALSE 17144
// if not control in _control then
17201: LD_VAR 0 4
17205: PUSH
17206: LD_VAR 0 12
17210: IN
17211: NOT
17212: IFFALSE 17238
// control := _control [ rand ( 1 , _control ) ] ;
17214: LD_ADDR_VAR 0 4
17218: PUSH
17219: LD_VAR 0 12
17223: PUSH
17224: LD_INT 1
17226: PPUSH
17227: LD_VAR 0 12
17231: PPUSH
17232: CALL_OW 12
17236: ARRAY
17237: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17238: LD_VAR 0 2
17242: PPUSH
17243: LD_VAR 0 5
17247: PPUSH
17248: CALL 17606 0 2
17252: NOT
17253: IFFALSE 17312
// repeat weapon := _weapon [ 1 ] ;
17255: LD_ADDR_VAR 0 5
17259: PUSH
17260: LD_VAR 0 10
17264: PUSH
17265: LD_INT 1
17267: ARRAY
17268: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17269: LD_ADDR_VAR 0 10
17273: PUSH
17274: LD_VAR 0 10
17278: PPUSH
17279: LD_INT 1
17281: PPUSH
17282: CALL_OW 3
17286: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17287: LD_VAR 0 2
17291: PPUSH
17292: LD_VAR 0 5
17296: PPUSH
17297: CALL 17606 0 2
17301: PUSH
17302: LD_VAR 0 10
17306: PUSH
17307: EMPTY
17308: EQUAL
17309: OR
17310: IFFALSE 17255
// result := [ ] ;
17312: LD_ADDR_VAR 0 6
17316: PUSH
17317: EMPTY
17318: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17319: LD_VAR 0 1
17323: PPUSH
17324: LD_VAR 0 2
17328: PPUSH
17329: LD_VAR 0 3
17333: PPUSH
17334: LD_VAR 0 4
17338: PPUSH
17339: LD_VAR 0 5
17343: PPUSH
17344: CALL_OW 448
17348: IFFALSE 17381
// result := [ chassis , engine , control , weapon ] ;
17350: LD_ADDR_VAR 0 6
17354: PUSH
17355: LD_VAR 0 2
17359: PUSH
17360: LD_VAR 0 3
17364: PUSH
17365: LD_VAR 0 4
17369: PUSH
17370: LD_VAR 0 5
17374: PUSH
17375: EMPTY
17376: LIST
17377: LIST
17378: LIST
17379: LIST
17380: ST_TO_ADDR
// end ;
17381: LD_VAR 0 6
17385: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17386: LD_INT 0
17388: PPUSH
// if not chassis or not engine then
17389: LD_VAR 0 1
17393: NOT
17394: PUSH
17395: LD_VAR 0 2
17399: NOT
17400: OR
17401: IFFALSE 17405
// exit ;
17403: GO 17601
// case engine of engine_solar :
17405: LD_VAR 0 2
17409: PUSH
17410: LD_INT 2
17412: DOUBLE
17413: EQUAL
17414: IFTRUE 17418
17416: GO 17456
17418: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17419: LD_ADDR_VAR 0 3
17423: PUSH
17424: LD_INT 11
17426: PUSH
17427: LD_INT 12
17429: PUSH
17430: LD_INT 13
17432: PUSH
17433: LD_INT 14
17435: PUSH
17436: LD_INT 1
17438: PUSH
17439: LD_INT 2
17441: PUSH
17442: LD_INT 3
17444: PUSH
17445: EMPTY
17446: LIST
17447: LIST
17448: LIST
17449: LIST
17450: LIST
17451: LIST
17452: LIST
17453: ST_TO_ADDR
17454: GO 17585
17456: LD_INT 1
17458: DOUBLE
17459: EQUAL
17460: IFTRUE 17464
17462: GO 17526
17464: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17465: LD_ADDR_VAR 0 3
17469: PUSH
17470: LD_INT 11
17472: PUSH
17473: LD_INT 12
17475: PUSH
17476: LD_INT 13
17478: PUSH
17479: LD_INT 14
17481: PUSH
17482: LD_INT 1
17484: PUSH
17485: LD_INT 2
17487: PUSH
17488: LD_INT 3
17490: PUSH
17491: LD_INT 4
17493: PUSH
17494: LD_INT 5
17496: PUSH
17497: LD_INT 21
17499: PUSH
17500: LD_INT 23
17502: PUSH
17503: LD_INT 22
17505: PUSH
17506: LD_INT 24
17508: PUSH
17509: EMPTY
17510: LIST
17511: LIST
17512: LIST
17513: LIST
17514: LIST
17515: LIST
17516: LIST
17517: LIST
17518: LIST
17519: LIST
17520: LIST
17521: LIST
17522: LIST
17523: ST_TO_ADDR
17524: GO 17585
17526: LD_INT 3
17528: DOUBLE
17529: EQUAL
17530: IFTRUE 17534
17532: GO 17584
17534: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17535: LD_ADDR_VAR 0 3
17539: PUSH
17540: LD_INT 13
17542: PUSH
17543: LD_INT 14
17545: PUSH
17546: LD_INT 2
17548: PUSH
17549: LD_INT 3
17551: PUSH
17552: LD_INT 4
17554: PUSH
17555: LD_INT 5
17557: PUSH
17558: LD_INT 21
17560: PUSH
17561: LD_INT 22
17563: PUSH
17564: LD_INT 23
17566: PUSH
17567: LD_INT 24
17569: PUSH
17570: EMPTY
17571: LIST
17572: LIST
17573: LIST
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: LIST
17579: LIST
17580: LIST
17581: ST_TO_ADDR
17582: GO 17585
17584: POP
// result := ( chassis in result ) ;
17585: LD_ADDR_VAR 0 3
17589: PUSH
17590: LD_VAR 0 1
17594: PUSH
17595: LD_VAR 0 3
17599: IN
17600: ST_TO_ADDR
// end ;
17601: LD_VAR 0 3
17605: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17606: LD_INT 0
17608: PPUSH
// if not chassis or not weapon then
17609: LD_VAR 0 1
17613: NOT
17614: PUSH
17615: LD_VAR 0 2
17619: NOT
17620: OR
17621: IFFALSE 17625
// exit ;
17623: GO 18651
// case weapon of us_machine_gun :
17625: LD_VAR 0 2
17629: PUSH
17630: LD_INT 2
17632: DOUBLE
17633: EQUAL
17634: IFTRUE 17638
17636: GO 17668
17638: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17639: LD_ADDR_VAR 0 3
17643: PUSH
17644: LD_INT 1
17646: PUSH
17647: LD_INT 2
17649: PUSH
17650: LD_INT 3
17652: PUSH
17653: LD_INT 4
17655: PUSH
17656: LD_INT 5
17658: PUSH
17659: EMPTY
17660: LIST
17661: LIST
17662: LIST
17663: LIST
17664: LIST
17665: ST_TO_ADDR
17666: GO 18635
17668: LD_INT 3
17670: DOUBLE
17671: EQUAL
17672: IFTRUE 17676
17674: GO 17706
17676: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17677: LD_ADDR_VAR 0 3
17681: PUSH
17682: LD_INT 1
17684: PUSH
17685: LD_INT 2
17687: PUSH
17688: LD_INT 3
17690: PUSH
17691: LD_INT 4
17693: PUSH
17694: LD_INT 5
17696: PUSH
17697: EMPTY
17698: LIST
17699: LIST
17700: LIST
17701: LIST
17702: LIST
17703: ST_TO_ADDR
17704: GO 18635
17706: LD_INT 11
17708: DOUBLE
17709: EQUAL
17710: IFTRUE 17714
17712: GO 17744
17714: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17715: LD_ADDR_VAR 0 3
17719: PUSH
17720: LD_INT 1
17722: PUSH
17723: LD_INT 2
17725: PUSH
17726: LD_INT 3
17728: PUSH
17729: LD_INT 4
17731: PUSH
17732: LD_INT 5
17734: PUSH
17735: EMPTY
17736: LIST
17737: LIST
17738: LIST
17739: LIST
17740: LIST
17741: ST_TO_ADDR
17742: GO 18635
17744: LD_INT 4
17746: DOUBLE
17747: EQUAL
17748: IFTRUE 17752
17750: GO 17778
17752: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17753: LD_ADDR_VAR 0 3
17757: PUSH
17758: LD_INT 2
17760: PUSH
17761: LD_INT 3
17763: PUSH
17764: LD_INT 4
17766: PUSH
17767: LD_INT 5
17769: PUSH
17770: EMPTY
17771: LIST
17772: LIST
17773: LIST
17774: LIST
17775: ST_TO_ADDR
17776: GO 18635
17778: LD_INT 5
17780: DOUBLE
17781: EQUAL
17782: IFTRUE 17786
17784: GO 17812
17786: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17787: LD_ADDR_VAR 0 3
17791: PUSH
17792: LD_INT 2
17794: PUSH
17795: LD_INT 3
17797: PUSH
17798: LD_INT 4
17800: PUSH
17801: LD_INT 5
17803: PUSH
17804: EMPTY
17805: LIST
17806: LIST
17807: LIST
17808: LIST
17809: ST_TO_ADDR
17810: GO 18635
17812: LD_INT 9
17814: DOUBLE
17815: EQUAL
17816: IFTRUE 17820
17818: GO 17846
17820: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17821: LD_ADDR_VAR 0 3
17825: PUSH
17826: LD_INT 2
17828: PUSH
17829: LD_INT 3
17831: PUSH
17832: LD_INT 4
17834: PUSH
17835: LD_INT 5
17837: PUSH
17838: EMPTY
17839: LIST
17840: LIST
17841: LIST
17842: LIST
17843: ST_TO_ADDR
17844: GO 18635
17846: LD_INT 7
17848: DOUBLE
17849: EQUAL
17850: IFTRUE 17854
17852: GO 17880
17854: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17855: LD_ADDR_VAR 0 3
17859: PUSH
17860: LD_INT 2
17862: PUSH
17863: LD_INT 3
17865: PUSH
17866: LD_INT 4
17868: PUSH
17869: LD_INT 5
17871: PUSH
17872: EMPTY
17873: LIST
17874: LIST
17875: LIST
17876: LIST
17877: ST_TO_ADDR
17878: GO 18635
17880: LD_INT 12
17882: DOUBLE
17883: EQUAL
17884: IFTRUE 17888
17886: GO 17914
17888: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17889: LD_ADDR_VAR 0 3
17893: PUSH
17894: LD_INT 2
17896: PUSH
17897: LD_INT 3
17899: PUSH
17900: LD_INT 4
17902: PUSH
17903: LD_INT 5
17905: PUSH
17906: EMPTY
17907: LIST
17908: LIST
17909: LIST
17910: LIST
17911: ST_TO_ADDR
17912: GO 18635
17914: LD_INT 13
17916: DOUBLE
17917: EQUAL
17918: IFTRUE 17922
17920: GO 17948
17922: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17923: LD_ADDR_VAR 0 3
17927: PUSH
17928: LD_INT 2
17930: PUSH
17931: LD_INT 3
17933: PUSH
17934: LD_INT 4
17936: PUSH
17937: LD_INT 5
17939: PUSH
17940: EMPTY
17941: LIST
17942: LIST
17943: LIST
17944: LIST
17945: ST_TO_ADDR
17946: GO 18635
17948: LD_INT 14
17950: DOUBLE
17951: EQUAL
17952: IFTRUE 17956
17954: GO 17974
17956: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17957: LD_ADDR_VAR 0 3
17961: PUSH
17962: LD_INT 4
17964: PUSH
17965: LD_INT 5
17967: PUSH
17968: EMPTY
17969: LIST
17970: LIST
17971: ST_TO_ADDR
17972: GO 18635
17974: LD_INT 6
17976: DOUBLE
17977: EQUAL
17978: IFTRUE 17982
17980: GO 18000
17982: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
17983: LD_ADDR_VAR 0 3
17987: PUSH
17988: LD_INT 4
17990: PUSH
17991: LD_INT 5
17993: PUSH
17994: EMPTY
17995: LIST
17996: LIST
17997: ST_TO_ADDR
17998: GO 18635
18000: LD_INT 10
18002: DOUBLE
18003: EQUAL
18004: IFTRUE 18008
18006: GO 18026
18008: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18009: LD_ADDR_VAR 0 3
18013: PUSH
18014: LD_INT 4
18016: PUSH
18017: LD_INT 5
18019: PUSH
18020: EMPTY
18021: LIST
18022: LIST
18023: ST_TO_ADDR
18024: GO 18635
18026: LD_INT 22
18028: DOUBLE
18029: EQUAL
18030: IFTRUE 18034
18032: GO 18060
18034: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18035: LD_ADDR_VAR 0 3
18039: PUSH
18040: LD_INT 11
18042: PUSH
18043: LD_INT 12
18045: PUSH
18046: LD_INT 13
18048: PUSH
18049: LD_INT 14
18051: PUSH
18052: EMPTY
18053: LIST
18054: LIST
18055: LIST
18056: LIST
18057: ST_TO_ADDR
18058: GO 18635
18060: LD_INT 23
18062: DOUBLE
18063: EQUAL
18064: IFTRUE 18068
18066: GO 18094
18068: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18069: LD_ADDR_VAR 0 3
18073: PUSH
18074: LD_INT 11
18076: PUSH
18077: LD_INT 12
18079: PUSH
18080: LD_INT 13
18082: PUSH
18083: LD_INT 14
18085: PUSH
18086: EMPTY
18087: LIST
18088: LIST
18089: LIST
18090: LIST
18091: ST_TO_ADDR
18092: GO 18635
18094: LD_INT 24
18096: DOUBLE
18097: EQUAL
18098: IFTRUE 18102
18100: GO 18128
18102: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18103: LD_ADDR_VAR 0 3
18107: PUSH
18108: LD_INT 11
18110: PUSH
18111: LD_INT 12
18113: PUSH
18114: LD_INT 13
18116: PUSH
18117: LD_INT 14
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: LIST
18124: LIST
18125: ST_TO_ADDR
18126: GO 18635
18128: LD_INT 30
18130: DOUBLE
18131: EQUAL
18132: IFTRUE 18136
18134: GO 18162
18136: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18137: LD_ADDR_VAR 0 3
18141: PUSH
18142: LD_INT 11
18144: PUSH
18145: LD_INT 12
18147: PUSH
18148: LD_INT 13
18150: PUSH
18151: LD_INT 14
18153: PUSH
18154: EMPTY
18155: LIST
18156: LIST
18157: LIST
18158: LIST
18159: ST_TO_ADDR
18160: GO 18635
18162: LD_INT 25
18164: DOUBLE
18165: EQUAL
18166: IFTRUE 18170
18168: GO 18188
18170: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18171: LD_ADDR_VAR 0 3
18175: PUSH
18176: LD_INT 13
18178: PUSH
18179: LD_INT 14
18181: PUSH
18182: EMPTY
18183: LIST
18184: LIST
18185: ST_TO_ADDR
18186: GO 18635
18188: LD_INT 27
18190: DOUBLE
18191: EQUAL
18192: IFTRUE 18196
18194: GO 18214
18196: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18197: LD_ADDR_VAR 0 3
18201: PUSH
18202: LD_INT 13
18204: PUSH
18205: LD_INT 14
18207: PUSH
18208: EMPTY
18209: LIST
18210: LIST
18211: ST_TO_ADDR
18212: GO 18635
18214: LD_INT 28
18216: DOUBLE
18217: EQUAL
18218: IFTRUE 18222
18220: GO 18240
18222: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18223: LD_ADDR_VAR 0 3
18227: PUSH
18228: LD_INT 13
18230: PUSH
18231: LD_INT 14
18233: PUSH
18234: EMPTY
18235: LIST
18236: LIST
18237: ST_TO_ADDR
18238: GO 18635
18240: LD_INT 29
18242: DOUBLE
18243: EQUAL
18244: IFTRUE 18248
18246: GO 18266
18248: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18249: LD_ADDR_VAR 0 3
18253: PUSH
18254: LD_INT 13
18256: PUSH
18257: LD_INT 14
18259: PUSH
18260: EMPTY
18261: LIST
18262: LIST
18263: ST_TO_ADDR
18264: GO 18635
18266: LD_INT 31
18268: DOUBLE
18269: EQUAL
18270: IFTRUE 18274
18272: GO 18292
18274: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18275: LD_ADDR_VAR 0 3
18279: PUSH
18280: LD_INT 13
18282: PUSH
18283: LD_INT 14
18285: PUSH
18286: EMPTY
18287: LIST
18288: LIST
18289: ST_TO_ADDR
18290: GO 18635
18292: LD_INT 26
18294: DOUBLE
18295: EQUAL
18296: IFTRUE 18300
18298: GO 18318
18300: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18301: LD_ADDR_VAR 0 3
18305: PUSH
18306: LD_INT 13
18308: PUSH
18309: LD_INT 14
18311: PUSH
18312: EMPTY
18313: LIST
18314: LIST
18315: ST_TO_ADDR
18316: GO 18635
18318: LD_INT 42
18320: DOUBLE
18321: EQUAL
18322: IFTRUE 18326
18324: GO 18352
18326: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18327: LD_ADDR_VAR 0 3
18331: PUSH
18332: LD_INT 21
18334: PUSH
18335: LD_INT 22
18337: PUSH
18338: LD_INT 23
18340: PUSH
18341: LD_INT 24
18343: PUSH
18344: EMPTY
18345: LIST
18346: LIST
18347: LIST
18348: LIST
18349: ST_TO_ADDR
18350: GO 18635
18352: LD_INT 43
18354: DOUBLE
18355: EQUAL
18356: IFTRUE 18360
18358: GO 18386
18360: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18361: LD_ADDR_VAR 0 3
18365: PUSH
18366: LD_INT 21
18368: PUSH
18369: LD_INT 22
18371: PUSH
18372: LD_INT 23
18374: PUSH
18375: LD_INT 24
18377: PUSH
18378: EMPTY
18379: LIST
18380: LIST
18381: LIST
18382: LIST
18383: ST_TO_ADDR
18384: GO 18635
18386: LD_INT 44
18388: DOUBLE
18389: EQUAL
18390: IFTRUE 18394
18392: GO 18420
18394: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18395: LD_ADDR_VAR 0 3
18399: PUSH
18400: LD_INT 21
18402: PUSH
18403: LD_INT 22
18405: PUSH
18406: LD_INT 23
18408: PUSH
18409: LD_INT 24
18411: PUSH
18412: EMPTY
18413: LIST
18414: LIST
18415: LIST
18416: LIST
18417: ST_TO_ADDR
18418: GO 18635
18420: LD_INT 45
18422: DOUBLE
18423: EQUAL
18424: IFTRUE 18428
18426: GO 18454
18428: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18429: LD_ADDR_VAR 0 3
18433: PUSH
18434: LD_INT 21
18436: PUSH
18437: LD_INT 22
18439: PUSH
18440: LD_INT 23
18442: PUSH
18443: LD_INT 24
18445: PUSH
18446: EMPTY
18447: LIST
18448: LIST
18449: LIST
18450: LIST
18451: ST_TO_ADDR
18452: GO 18635
18454: LD_INT 49
18456: DOUBLE
18457: EQUAL
18458: IFTRUE 18462
18460: GO 18488
18462: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18463: LD_ADDR_VAR 0 3
18467: PUSH
18468: LD_INT 21
18470: PUSH
18471: LD_INT 22
18473: PUSH
18474: LD_INT 23
18476: PUSH
18477: LD_INT 24
18479: PUSH
18480: EMPTY
18481: LIST
18482: LIST
18483: LIST
18484: LIST
18485: ST_TO_ADDR
18486: GO 18635
18488: LD_INT 51
18490: DOUBLE
18491: EQUAL
18492: IFTRUE 18496
18494: GO 18522
18496: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18497: LD_ADDR_VAR 0 3
18501: PUSH
18502: LD_INT 21
18504: PUSH
18505: LD_INT 22
18507: PUSH
18508: LD_INT 23
18510: PUSH
18511: LD_INT 24
18513: PUSH
18514: EMPTY
18515: LIST
18516: LIST
18517: LIST
18518: LIST
18519: ST_TO_ADDR
18520: GO 18635
18522: LD_INT 52
18524: DOUBLE
18525: EQUAL
18526: IFTRUE 18530
18528: GO 18556
18530: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18531: LD_ADDR_VAR 0 3
18535: PUSH
18536: LD_INT 21
18538: PUSH
18539: LD_INT 22
18541: PUSH
18542: LD_INT 23
18544: PUSH
18545: LD_INT 24
18547: PUSH
18548: EMPTY
18549: LIST
18550: LIST
18551: LIST
18552: LIST
18553: ST_TO_ADDR
18554: GO 18635
18556: LD_INT 53
18558: DOUBLE
18559: EQUAL
18560: IFTRUE 18564
18562: GO 18582
18564: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18565: LD_ADDR_VAR 0 3
18569: PUSH
18570: LD_INT 23
18572: PUSH
18573: LD_INT 24
18575: PUSH
18576: EMPTY
18577: LIST
18578: LIST
18579: ST_TO_ADDR
18580: GO 18635
18582: LD_INT 46
18584: DOUBLE
18585: EQUAL
18586: IFTRUE 18590
18588: GO 18608
18590: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18591: LD_ADDR_VAR 0 3
18595: PUSH
18596: LD_INT 23
18598: PUSH
18599: LD_INT 24
18601: PUSH
18602: EMPTY
18603: LIST
18604: LIST
18605: ST_TO_ADDR
18606: GO 18635
18608: LD_INT 47
18610: DOUBLE
18611: EQUAL
18612: IFTRUE 18616
18614: GO 18634
18616: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18617: LD_ADDR_VAR 0 3
18621: PUSH
18622: LD_INT 23
18624: PUSH
18625: LD_INT 24
18627: PUSH
18628: EMPTY
18629: LIST
18630: LIST
18631: ST_TO_ADDR
18632: GO 18635
18634: POP
// result := ( chassis in result ) ;
18635: LD_ADDR_VAR 0 3
18639: PUSH
18640: LD_VAR 0 1
18644: PUSH
18645: LD_VAR 0 3
18649: IN
18650: ST_TO_ADDR
// end ;
18651: LD_VAR 0 3
18655: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18656: LD_INT 0
18658: PPUSH
18659: PPUSH
18660: PPUSH
18661: PPUSH
18662: PPUSH
18663: PPUSH
18664: PPUSH
// result := array ;
18665: LD_ADDR_VAR 0 5
18669: PUSH
18670: LD_VAR 0 1
18674: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18675: LD_VAR 0 1
18679: NOT
18680: PUSH
18681: LD_VAR 0 2
18685: NOT
18686: OR
18687: PUSH
18688: LD_VAR 0 3
18692: NOT
18693: OR
18694: PUSH
18695: LD_VAR 0 2
18699: PUSH
18700: LD_VAR 0 1
18704: GREATER
18705: OR
18706: PUSH
18707: LD_VAR 0 3
18711: PUSH
18712: LD_VAR 0 1
18716: GREATER
18717: OR
18718: IFFALSE 18722
// exit ;
18720: GO 19018
// if direction then
18722: LD_VAR 0 4
18726: IFFALSE 18790
// begin d := 1 ;
18728: LD_ADDR_VAR 0 9
18732: PUSH
18733: LD_INT 1
18735: ST_TO_ADDR
// if i_from > i_to then
18736: LD_VAR 0 2
18740: PUSH
18741: LD_VAR 0 3
18745: GREATER
18746: IFFALSE 18772
// length := ( array - i_from ) + i_to else
18748: LD_ADDR_VAR 0 11
18752: PUSH
18753: LD_VAR 0 1
18757: PUSH
18758: LD_VAR 0 2
18762: MINUS
18763: PUSH
18764: LD_VAR 0 3
18768: PLUS
18769: ST_TO_ADDR
18770: GO 18788
// length := i_to - i_from ;
18772: LD_ADDR_VAR 0 11
18776: PUSH
18777: LD_VAR 0 3
18781: PUSH
18782: LD_VAR 0 2
18786: MINUS
18787: ST_TO_ADDR
// end else
18788: GO 18851
// begin d := - 1 ;
18790: LD_ADDR_VAR 0 9
18794: PUSH
18795: LD_INT 1
18797: NEG
18798: ST_TO_ADDR
// if i_from > i_to then
18799: LD_VAR 0 2
18803: PUSH
18804: LD_VAR 0 3
18808: GREATER
18809: IFFALSE 18829
// length := i_from - i_to else
18811: LD_ADDR_VAR 0 11
18815: PUSH
18816: LD_VAR 0 2
18820: PUSH
18821: LD_VAR 0 3
18825: MINUS
18826: ST_TO_ADDR
18827: GO 18851
// length := ( array - i_to ) + i_from ;
18829: LD_ADDR_VAR 0 11
18833: PUSH
18834: LD_VAR 0 1
18838: PUSH
18839: LD_VAR 0 3
18843: MINUS
18844: PUSH
18845: LD_VAR 0 2
18849: PLUS
18850: ST_TO_ADDR
// end ; if not length then
18851: LD_VAR 0 11
18855: NOT
18856: IFFALSE 18860
// exit ;
18858: GO 19018
// tmp := array ;
18860: LD_ADDR_VAR 0 10
18864: PUSH
18865: LD_VAR 0 1
18869: ST_TO_ADDR
// for i = 1 to length do
18870: LD_ADDR_VAR 0 6
18874: PUSH
18875: DOUBLE
18876: LD_INT 1
18878: DEC
18879: ST_TO_ADDR
18880: LD_VAR 0 11
18884: PUSH
18885: FOR_TO
18886: IFFALSE 19006
// begin for j = 1 to array do
18888: LD_ADDR_VAR 0 7
18892: PUSH
18893: DOUBLE
18894: LD_INT 1
18896: DEC
18897: ST_TO_ADDR
18898: LD_VAR 0 1
18902: PUSH
18903: FOR_TO
18904: IFFALSE 18992
// begin k := j + d ;
18906: LD_ADDR_VAR 0 8
18910: PUSH
18911: LD_VAR 0 7
18915: PUSH
18916: LD_VAR 0 9
18920: PLUS
18921: ST_TO_ADDR
// if k > array then
18922: LD_VAR 0 8
18926: PUSH
18927: LD_VAR 0 1
18931: GREATER
18932: IFFALSE 18942
// k := 1 ;
18934: LD_ADDR_VAR 0 8
18938: PUSH
18939: LD_INT 1
18941: ST_TO_ADDR
// if not k then
18942: LD_VAR 0 8
18946: NOT
18947: IFFALSE 18959
// k := array ;
18949: LD_ADDR_VAR 0 8
18953: PUSH
18954: LD_VAR 0 1
18958: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18959: LD_ADDR_VAR 0 10
18963: PUSH
18964: LD_VAR 0 10
18968: PPUSH
18969: LD_VAR 0 8
18973: PPUSH
18974: LD_VAR 0 1
18978: PUSH
18979: LD_VAR 0 7
18983: ARRAY
18984: PPUSH
18985: CALL_OW 1
18989: ST_TO_ADDR
// end ;
18990: GO 18903
18992: POP
18993: POP
// array := tmp ;
18994: LD_ADDR_VAR 0 1
18998: PUSH
18999: LD_VAR 0 10
19003: ST_TO_ADDR
// end ;
19004: GO 18885
19006: POP
19007: POP
// result := array ;
19008: LD_ADDR_VAR 0 5
19012: PUSH
19013: LD_VAR 0 1
19017: ST_TO_ADDR
// end ;
19018: LD_VAR 0 5
19022: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19023: LD_INT 0
19025: PPUSH
19026: PPUSH
// result := 0 ;
19027: LD_ADDR_VAR 0 3
19031: PUSH
19032: LD_INT 0
19034: ST_TO_ADDR
// if not array or not value in array then
19035: LD_VAR 0 1
19039: NOT
19040: PUSH
19041: LD_VAR 0 2
19045: PUSH
19046: LD_VAR 0 1
19050: IN
19051: NOT
19052: OR
19053: IFFALSE 19057
// exit ;
19055: GO 19111
// for i = 1 to array do
19057: LD_ADDR_VAR 0 4
19061: PUSH
19062: DOUBLE
19063: LD_INT 1
19065: DEC
19066: ST_TO_ADDR
19067: LD_VAR 0 1
19071: PUSH
19072: FOR_TO
19073: IFFALSE 19109
// if value = array [ i ] then
19075: LD_VAR 0 2
19079: PUSH
19080: LD_VAR 0 1
19084: PUSH
19085: LD_VAR 0 4
19089: ARRAY
19090: EQUAL
19091: IFFALSE 19107
// begin result := i ;
19093: LD_ADDR_VAR 0 3
19097: PUSH
19098: LD_VAR 0 4
19102: ST_TO_ADDR
// exit ;
19103: POP
19104: POP
19105: GO 19111
// end ;
19107: GO 19072
19109: POP
19110: POP
// end ;
19111: LD_VAR 0 3
19115: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19116: LD_INT 0
19118: PPUSH
// vc_chassis := chassis ;
19119: LD_ADDR_OWVAR 37
19123: PUSH
19124: LD_VAR 0 1
19128: ST_TO_ADDR
// vc_engine := engine ;
19129: LD_ADDR_OWVAR 39
19133: PUSH
19134: LD_VAR 0 2
19138: ST_TO_ADDR
// vc_control := control ;
19139: LD_ADDR_OWVAR 38
19143: PUSH
19144: LD_VAR 0 3
19148: ST_TO_ADDR
// vc_weapon := weapon ;
19149: LD_ADDR_OWVAR 40
19153: PUSH
19154: LD_VAR 0 4
19158: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19159: LD_ADDR_OWVAR 41
19163: PUSH
19164: LD_VAR 0 5
19168: ST_TO_ADDR
// end ;
19169: LD_VAR 0 6
19173: RET
// export function WantPlant ( unit ) ; var task ; begin
19174: LD_INT 0
19176: PPUSH
19177: PPUSH
// result := false ;
19178: LD_ADDR_VAR 0 2
19182: PUSH
19183: LD_INT 0
19185: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19186: LD_ADDR_VAR 0 3
19190: PUSH
19191: LD_VAR 0 1
19195: PPUSH
19196: CALL_OW 437
19200: ST_TO_ADDR
// if task then
19201: LD_VAR 0 3
19205: IFFALSE 19233
// if task [ 1 ] [ 1 ] = p then
19207: LD_VAR 0 3
19211: PUSH
19212: LD_INT 1
19214: ARRAY
19215: PUSH
19216: LD_INT 1
19218: ARRAY
19219: PUSH
19220: LD_STRING p
19222: EQUAL
19223: IFFALSE 19233
// result := true ;
19225: LD_ADDR_VAR 0 2
19229: PUSH
19230: LD_INT 1
19232: ST_TO_ADDR
// end ;
19233: LD_VAR 0 2
19237: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19238: LD_INT 0
19240: PPUSH
19241: PPUSH
19242: PPUSH
19243: PPUSH
// if pos < 1 then
19244: LD_VAR 0 2
19248: PUSH
19249: LD_INT 1
19251: LESS
19252: IFFALSE 19256
// exit ;
19254: GO 19559
// if pos = 1 then
19256: LD_VAR 0 2
19260: PUSH
19261: LD_INT 1
19263: EQUAL
19264: IFFALSE 19297
// result := Replace ( arr , pos [ 1 ] , value ) else
19266: LD_ADDR_VAR 0 4
19270: PUSH
19271: LD_VAR 0 1
19275: PPUSH
19276: LD_VAR 0 2
19280: PUSH
19281: LD_INT 1
19283: ARRAY
19284: PPUSH
19285: LD_VAR 0 3
19289: PPUSH
19290: CALL_OW 1
19294: ST_TO_ADDR
19295: GO 19559
// begin tmp := arr ;
19297: LD_ADDR_VAR 0 6
19301: PUSH
19302: LD_VAR 0 1
19306: ST_TO_ADDR
// s_arr := [ tmp ] ;
19307: LD_ADDR_VAR 0 7
19311: PUSH
19312: LD_VAR 0 6
19316: PUSH
19317: EMPTY
19318: LIST
19319: ST_TO_ADDR
// for i = 1 to pos - 1 do
19320: LD_ADDR_VAR 0 5
19324: PUSH
19325: DOUBLE
19326: LD_INT 1
19328: DEC
19329: ST_TO_ADDR
19330: LD_VAR 0 2
19334: PUSH
19335: LD_INT 1
19337: MINUS
19338: PUSH
19339: FOR_TO
19340: IFFALSE 19385
// begin tmp := tmp [ pos [ i ] ] ;
19342: LD_ADDR_VAR 0 6
19346: PUSH
19347: LD_VAR 0 6
19351: PUSH
19352: LD_VAR 0 2
19356: PUSH
19357: LD_VAR 0 5
19361: ARRAY
19362: ARRAY
19363: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19364: LD_ADDR_VAR 0 7
19368: PUSH
19369: LD_VAR 0 7
19373: PUSH
19374: LD_VAR 0 6
19378: PUSH
19379: EMPTY
19380: LIST
19381: ADD
19382: ST_TO_ADDR
// end ;
19383: GO 19339
19385: POP
19386: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19387: LD_ADDR_VAR 0 6
19391: PUSH
19392: LD_VAR 0 6
19396: PPUSH
19397: LD_VAR 0 2
19401: PUSH
19402: LD_VAR 0 2
19406: ARRAY
19407: PPUSH
19408: LD_VAR 0 3
19412: PPUSH
19413: CALL_OW 1
19417: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19418: LD_ADDR_VAR 0 7
19422: PUSH
19423: LD_VAR 0 7
19427: PPUSH
19428: LD_VAR 0 7
19432: PPUSH
19433: LD_VAR 0 6
19437: PPUSH
19438: CALL_OW 1
19442: ST_TO_ADDR
// for i = s_arr downto 2 do
19443: LD_ADDR_VAR 0 5
19447: PUSH
19448: DOUBLE
19449: LD_VAR 0 7
19453: INC
19454: ST_TO_ADDR
19455: LD_INT 2
19457: PUSH
19458: FOR_DOWNTO
19459: IFFALSE 19543
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19461: LD_ADDR_VAR 0 6
19465: PUSH
19466: LD_VAR 0 7
19470: PUSH
19471: LD_VAR 0 5
19475: PUSH
19476: LD_INT 1
19478: MINUS
19479: ARRAY
19480: PPUSH
19481: LD_VAR 0 2
19485: PUSH
19486: LD_VAR 0 5
19490: PUSH
19491: LD_INT 1
19493: MINUS
19494: ARRAY
19495: PPUSH
19496: LD_VAR 0 7
19500: PUSH
19501: LD_VAR 0 5
19505: ARRAY
19506: PPUSH
19507: CALL_OW 1
19511: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19512: LD_ADDR_VAR 0 7
19516: PUSH
19517: LD_VAR 0 7
19521: PPUSH
19522: LD_VAR 0 5
19526: PUSH
19527: LD_INT 1
19529: MINUS
19530: PPUSH
19531: LD_VAR 0 6
19535: PPUSH
19536: CALL_OW 1
19540: ST_TO_ADDR
// end ;
19541: GO 19458
19543: POP
19544: POP
// result := s_arr [ 1 ] ;
19545: LD_ADDR_VAR 0 4
19549: PUSH
19550: LD_VAR 0 7
19554: PUSH
19555: LD_INT 1
19557: ARRAY
19558: ST_TO_ADDR
// end ; end ;
19559: LD_VAR 0 4
19563: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19564: LD_INT 0
19566: PPUSH
19567: PPUSH
// if not list then
19568: LD_VAR 0 1
19572: NOT
19573: IFFALSE 19577
// exit ;
19575: GO 19668
// i := list [ pos1 ] ;
19577: LD_ADDR_VAR 0 5
19581: PUSH
19582: LD_VAR 0 1
19586: PUSH
19587: LD_VAR 0 2
19591: ARRAY
19592: ST_TO_ADDR
// if not i then
19593: LD_VAR 0 5
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19668
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19602: LD_ADDR_VAR 0 1
19606: PUSH
19607: LD_VAR 0 1
19611: PPUSH
19612: LD_VAR 0 2
19616: PPUSH
19617: LD_VAR 0 1
19621: PUSH
19622: LD_VAR 0 3
19626: ARRAY
19627: PPUSH
19628: CALL_OW 1
19632: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19633: LD_ADDR_VAR 0 1
19637: PUSH
19638: LD_VAR 0 1
19642: PPUSH
19643: LD_VAR 0 3
19647: PPUSH
19648: LD_VAR 0 5
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// result := list ;
19658: LD_ADDR_VAR 0 4
19662: PUSH
19663: LD_VAR 0 1
19667: ST_TO_ADDR
// end ;
19668: LD_VAR 0 4
19672: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19673: LD_INT 0
19675: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19676: LD_ADDR_VAR 0 5
19680: PUSH
19681: LD_VAR 0 1
19685: PPUSH
19686: CALL_OW 250
19690: PPUSH
19691: LD_VAR 0 1
19695: PPUSH
19696: CALL_OW 251
19700: PPUSH
19701: LD_VAR 0 2
19705: PPUSH
19706: LD_VAR 0 3
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: CALL 19726 0 5
19720: ST_TO_ADDR
// end ;
19721: LD_VAR 0 5
19725: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19726: LD_INT 0
19728: PPUSH
19729: PPUSH
19730: PPUSH
19731: PPUSH
// if not list then
19732: LD_VAR 0 3
19736: NOT
19737: IFFALSE 19741
// exit ;
19739: GO 20129
// result := [ ] ;
19741: LD_ADDR_VAR 0 6
19745: PUSH
19746: EMPTY
19747: ST_TO_ADDR
// for i in list do
19748: LD_ADDR_VAR 0 7
19752: PUSH
19753: LD_VAR 0 3
19757: PUSH
19758: FOR_IN
19759: IFFALSE 19961
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19761: LD_ADDR_VAR 0 9
19765: PUSH
19766: LD_VAR 0 7
19770: PPUSH
19771: LD_VAR 0 1
19775: PPUSH
19776: LD_VAR 0 2
19780: PPUSH
19781: CALL_OW 297
19785: ST_TO_ADDR
// if not result then
19786: LD_VAR 0 6
19790: NOT
19791: IFFALSE 19817
// result := [ [ i , tmp ] ] else
19793: LD_ADDR_VAR 0 6
19797: PUSH
19798: LD_VAR 0 7
19802: PUSH
19803: LD_VAR 0 9
19807: PUSH
19808: EMPTY
19809: LIST
19810: LIST
19811: PUSH
19812: EMPTY
19813: LIST
19814: ST_TO_ADDR
19815: GO 19959
// begin if result [ result ] [ 2 ] < tmp then
19817: LD_VAR 0 6
19821: PUSH
19822: LD_VAR 0 6
19826: ARRAY
19827: PUSH
19828: LD_INT 2
19830: ARRAY
19831: PUSH
19832: LD_VAR 0 9
19836: LESS
19837: IFFALSE 19879
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19839: LD_ADDR_VAR 0 6
19843: PUSH
19844: LD_VAR 0 6
19848: PPUSH
19849: LD_VAR 0 6
19853: PUSH
19854: LD_INT 1
19856: PLUS
19857: PPUSH
19858: LD_VAR 0 7
19862: PUSH
19863: LD_VAR 0 9
19867: PUSH
19868: EMPTY
19869: LIST
19870: LIST
19871: PPUSH
19872: CALL_OW 2
19876: ST_TO_ADDR
19877: GO 19959
// for j = 1 to result do
19879: LD_ADDR_VAR 0 8
19883: PUSH
19884: DOUBLE
19885: LD_INT 1
19887: DEC
19888: ST_TO_ADDR
19889: LD_VAR 0 6
19893: PUSH
19894: FOR_TO
19895: IFFALSE 19957
// begin if tmp < result [ j ] [ 2 ] then
19897: LD_VAR 0 9
19901: PUSH
19902: LD_VAR 0 6
19906: PUSH
19907: LD_VAR 0 8
19911: ARRAY
19912: PUSH
19913: LD_INT 2
19915: ARRAY
19916: LESS
19917: IFFALSE 19955
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19919: LD_ADDR_VAR 0 6
19923: PUSH
19924: LD_VAR 0 6
19928: PPUSH
19929: LD_VAR 0 8
19933: PPUSH
19934: LD_VAR 0 7
19938: PUSH
19939: LD_VAR 0 9
19943: PUSH
19944: EMPTY
19945: LIST
19946: LIST
19947: PPUSH
19948: CALL_OW 2
19952: ST_TO_ADDR
// break ;
19953: GO 19957
// end ; end ;
19955: GO 19894
19957: POP
19958: POP
// end ; end ;
19959: GO 19758
19961: POP
19962: POP
// if result and not asc then
19963: LD_VAR 0 6
19967: PUSH
19968: LD_VAR 0 4
19972: NOT
19973: AND
19974: IFFALSE 20049
// begin tmp := result ;
19976: LD_ADDR_VAR 0 9
19980: PUSH
19981: LD_VAR 0 6
19985: ST_TO_ADDR
// for i = tmp downto 1 do
19986: LD_ADDR_VAR 0 7
19990: PUSH
19991: DOUBLE
19992: LD_VAR 0 9
19996: INC
19997: ST_TO_ADDR
19998: LD_INT 1
20000: PUSH
20001: FOR_DOWNTO
20002: IFFALSE 20047
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20004: LD_ADDR_VAR 0 6
20008: PUSH
20009: LD_VAR 0 6
20013: PPUSH
20014: LD_VAR 0 9
20018: PUSH
20019: LD_VAR 0 7
20023: MINUS
20024: PUSH
20025: LD_INT 1
20027: PLUS
20028: PPUSH
20029: LD_VAR 0 9
20033: PUSH
20034: LD_VAR 0 7
20038: ARRAY
20039: PPUSH
20040: CALL_OW 1
20044: ST_TO_ADDR
20045: GO 20001
20047: POP
20048: POP
// end ; tmp := [ ] ;
20049: LD_ADDR_VAR 0 9
20053: PUSH
20054: EMPTY
20055: ST_TO_ADDR
// if mode then
20056: LD_VAR 0 5
20060: IFFALSE 20129
// begin for i = 1 to result do
20062: LD_ADDR_VAR 0 7
20066: PUSH
20067: DOUBLE
20068: LD_INT 1
20070: DEC
20071: ST_TO_ADDR
20072: LD_VAR 0 6
20076: PUSH
20077: FOR_TO
20078: IFFALSE 20117
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20080: LD_ADDR_VAR 0 9
20084: PUSH
20085: LD_VAR 0 9
20089: PPUSH
20090: LD_VAR 0 7
20094: PPUSH
20095: LD_VAR 0 6
20099: PUSH
20100: LD_VAR 0 7
20104: ARRAY
20105: PUSH
20106: LD_INT 1
20108: ARRAY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
20115: GO 20077
20117: POP
20118: POP
// result := tmp ;
20119: LD_ADDR_VAR 0 6
20123: PUSH
20124: LD_VAR 0 9
20128: ST_TO_ADDR
// end ; end ;
20129: LD_VAR 0 6
20133: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20134: LD_INT 0
20136: PPUSH
20137: PPUSH
20138: PPUSH
20139: PPUSH
20140: PPUSH
20141: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20142: LD_ADDR_VAR 0 5
20146: PUSH
20147: LD_INT 0
20149: PUSH
20150: LD_INT 0
20152: PUSH
20153: LD_INT 0
20155: PUSH
20156: EMPTY
20157: PUSH
20158: EMPTY
20159: LIST
20160: LIST
20161: LIST
20162: LIST
20163: ST_TO_ADDR
// if not x or not y then
20164: LD_VAR 0 2
20168: NOT
20169: PUSH
20170: LD_VAR 0 3
20174: NOT
20175: OR
20176: IFFALSE 20180
// exit ;
20178: GO 21826
// if not range then
20180: LD_VAR 0 4
20184: NOT
20185: IFFALSE 20195
// range := 10 ;
20187: LD_ADDR_VAR 0 4
20191: PUSH
20192: LD_INT 10
20194: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20195: LD_ADDR_VAR 0 8
20199: PUSH
20200: LD_INT 81
20202: PUSH
20203: LD_VAR 0 1
20207: PUSH
20208: EMPTY
20209: LIST
20210: LIST
20211: PUSH
20212: LD_INT 92
20214: PUSH
20215: LD_VAR 0 2
20219: PUSH
20220: LD_VAR 0 3
20224: PUSH
20225: LD_VAR 0 4
20229: PUSH
20230: EMPTY
20231: LIST
20232: LIST
20233: LIST
20234: LIST
20235: PUSH
20236: LD_INT 3
20238: PUSH
20239: LD_INT 21
20241: PUSH
20242: LD_INT 3
20244: PUSH
20245: EMPTY
20246: LIST
20247: LIST
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PPUSH
20258: CALL_OW 69
20262: ST_TO_ADDR
// if not tmp then
20263: LD_VAR 0 8
20267: NOT
20268: IFFALSE 20272
// exit ;
20270: GO 21826
// for i in tmp do
20272: LD_ADDR_VAR 0 6
20276: PUSH
20277: LD_VAR 0 8
20281: PUSH
20282: FOR_IN
20283: IFFALSE 21801
// begin points := [ 0 , 0 , 0 ] ;
20285: LD_ADDR_VAR 0 9
20289: PUSH
20290: LD_INT 0
20292: PUSH
20293: LD_INT 0
20295: PUSH
20296: LD_INT 0
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: LIST
20303: ST_TO_ADDR
// bpoints := 1 ;
20304: LD_ADDR_VAR 0 10
20308: PUSH
20309: LD_INT 1
20311: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20312: LD_VAR 0 6
20316: PPUSH
20317: CALL_OW 247
20321: PUSH
20322: LD_INT 1
20324: DOUBLE
20325: EQUAL
20326: IFTRUE 20330
20328: GO 20908
20330: POP
// begin if GetClass ( i ) = 1 then
20331: LD_VAR 0 6
20335: PPUSH
20336: CALL_OW 257
20340: PUSH
20341: LD_INT 1
20343: EQUAL
20344: IFFALSE 20365
// points := [ 10 , 5 , 3 ] ;
20346: LD_ADDR_VAR 0 9
20350: PUSH
20351: LD_INT 10
20353: PUSH
20354: LD_INT 5
20356: PUSH
20357: LD_INT 3
20359: PUSH
20360: EMPTY
20361: LIST
20362: LIST
20363: LIST
20364: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20365: LD_VAR 0 6
20369: PPUSH
20370: CALL_OW 257
20374: PUSH
20375: LD_INT 2
20377: PUSH
20378: LD_INT 3
20380: PUSH
20381: LD_INT 4
20383: PUSH
20384: EMPTY
20385: LIST
20386: LIST
20387: LIST
20388: IN
20389: IFFALSE 20410
// points := [ 3 , 2 , 1 ] ;
20391: LD_ADDR_VAR 0 9
20395: PUSH
20396: LD_INT 3
20398: PUSH
20399: LD_INT 2
20401: PUSH
20402: LD_INT 1
20404: PUSH
20405: EMPTY
20406: LIST
20407: LIST
20408: LIST
20409: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20410: LD_VAR 0 6
20414: PPUSH
20415: CALL_OW 257
20419: PUSH
20420: LD_INT 5
20422: EQUAL
20423: IFFALSE 20444
// points := [ 130 , 5 , 2 ] ;
20425: LD_ADDR_VAR 0 9
20429: PUSH
20430: LD_INT 130
20432: PUSH
20433: LD_INT 5
20435: PUSH
20436: LD_INT 2
20438: PUSH
20439: EMPTY
20440: LIST
20441: LIST
20442: LIST
20443: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20444: LD_VAR 0 6
20448: PPUSH
20449: CALL_OW 257
20453: PUSH
20454: LD_INT 8
20456: EQUAL
20457: IFFALSE 20478
// points := [ 35 , 35 , 30 ] ;
20459: LD_ADDR_VAR 0 9
20463: PUSH
20464: LD_INT 35
20466: PUSH
20467: LD_INT 35
20469: PUSH
20470: LD_INT 30
20472: PUSH
20473: EMPTY
20474: LIST
20475: LIST
20476: LIST
20477: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20478: LD_VAR 0 6
20482: PPUSH
20483: CALL_OW 257
20487: PUSH
20488: LD_INT 9
20490: EQUAL
20491: IFFALSE 20512
// points := [ 20 , 55 , 40 ] ;
20493: LD_ADDR_VAR 0 9
20497: PUSH
20498: LD_INT 20
20500: PUSH
20501: LD_INT 55
20503: PUSH
20504: LD_INT 40
20506: PUSH
20507: EMPTY
20508: LIST
20509: LIST
20510: LIST
20511: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20512: LD_VAR 0 6
20516: PPUSH
20517: CALL_OW 257
20521: PUSH
20522: LD_INT 12
20524: PUSH
20525: LD_INT 16
20527: PUSH
20528: EMPTY
20529: LIST
20530: LIST
20531: IN
20532: IFFALSE 20553
// points := [ 5 , 3 , 2 ] ;
20534: LD_ADDR_VAR 0 9
20538: PUSH
20539: LD_INT 5
20541: PUSH
20542: LD_INT 3
20544: PUSH
20545: LD_INT 2
20547: PUSH
20548: EMPTY
20549: LIST
20550: LIST
20551: LIST
20552: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20553: LD_VAR 0 6
20557: PPUSH
20558: CALL_OW 257
20562: PUSH
20563: LD_INT 17
20565: EQUAL
20566: IFFALSE 20587
// points := [ 100 , 50 , 75 ] ;
20568: LD_ADDR_VAR 0 9
20572: PUSH
20573: LD_INT 100
20575: PUSH
20576: LD_INT 50
20578: PUSH
20579: LD_INT 75
20581: PUSH
20582: EMPTY
20583: LIST
20584: LIST
20585: LIST
20586: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20587: LD_VAR 0 6
20591: PPUSH
20592: CALL_OW 257
20596: PUSH
20597: LD_INT 15
20599: EQUAL
20600: IFFALSE 20621
// points := [ 10 , 5 , 3 ] ;
20602: LD_ADDR_VAR 0 9
20606: PUSH
20607: LD_INT 10
20609: PUSH
20610: LD_INT 5
20612: PUSH
20613: LD_INT 3
20615: PUSH
20616: EMPTY
20617: LIST
20618: LIST
20619: LIST
20620: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20621: LD_VAR 0 6
20625: PPUSH
20626: CALL_OW 257
20630: PUSH
20631: LD_INT 14
20633: EQUAL
20634: IFFALSE 20655
// points := [ 10 , 0 , 0 ] ;
20636: LD_ADDR_VAR 0 9
20640: PUSH
20641: LD_INT 10
20643: PUSH
20644: LD_INT 0
20646: PUSH
20647: LD_INT 0
20649: PUSH
20650: EMPTY
20651: LIST
20652: LIST
20653: LIST
20654: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20655: LD_VAR 0 6
20659: PPUSH
20660: CALL_OW 257
20664: PUSH
20665: LD_INT 11
20667: EQUAL
20668: IFFALSE 20689
// points := [ 30 , 10 , 5 ] ;
20670: LD_ADDR_VAR 0 9
20674: PUSH
20675: LD_INT 30
20677: PUSH
20678: LD_INT 10
20680: PUSH
20681: LD_INT 5
20683: PUSH
20684: EMPTY
20685: LIST
20686: LIST
20687: LIST
20688: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20689: LD_VAR 0 1
20693: PPUSH
20694: LD_INT 5
20696: PPUSH
20697: CALL_OW 321
20701: PUSH
20702: LD_INT 2
20704: EQUAL
20705: IFFALSE 20722
// bpoints := bpoints * 1.8 ;
20707: LD_ADDR_VAR 0 10
20711: PUSH
20712: LD_VAR 0 10
20716: PUSH
20717: LD_REAL  1.80000000000000E+0000
20720: MUL
20721: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20722: LD_VAR 0 6
20726: PPUSH
20727: CALL_OW 257
20731: PUSH
20732: LD_INT 1
20734: PUSH
20735: LD_INT 2
20737: PUSH
20738: LD_INT 3
20740: PUSH
20741: LD_INT 4
20743: PUSH
20744: EMPTY
20745: LIST
20746: LIST
20747: LIST
20748: LIST
20749: IN
20750: PUSH
20751: LD_VAR 0 1
20755: PPUSH
20756: LD_INT 51
20758: PPUSH
20759: CALL_OW 321
20763: PUSH
20764: LD_INT 2
20766: EQUAL
20767: AND
20768: IFFALSE 20785
// bpoints := bpoints * 1.2 ;
20770: LD_ADDR_VAR 0 10
20774: PUSH
20775: LD_VAR 0 10
20779: PUSH
20780: LD_REAL  1.20000000000000E+0000
20783: MUL
20784: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20785: LD_VAR 0 6
20789: PPUSH
20790: CALL_OW 257
20794: PUSH
20795: LD_INT 5
20797: PUSH
20798: LD_INT 7
20800: PUSH
20801: LD_INT 9
20803: PUSH
20804: EMPTY
20805: LIST
20806: LIST
20807: LIST
20808: IN
20809: PUSH
20810: LD_VAR 0 1
20814: PPUSH
20815: LD_INT 52
20817: PPUSH
20818: CALL_OW 321
20822: PUSH
20823: LD_INT 2
20825: EQUAL
20826: AND
20827: IFFALSE 20844
// bpoints := bpoints * 1.5 ;
20829: LD_ADDR_VAR 0 10
20833: PUSH
20834: LD_VAR 0 10
20838: PUSH
20839: LD_REAL  1.50000000000000E+0000
20842: MUL
20843: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20844: LD_VAR 0 1
20848: PPUSH
20849: LD_INT 66
20851: PPUSH
20852: CALL_OW 321
20856: PUSH
20857: LD_INT 2
20859: EQUAL
20860: IFFALSE 20877
// bpoints := bpoints * 1.1 ;
20862: LD_ADDR_VAR 0 10
20866: PUSH
20867: LD_VAR 0 10
20871: PUSH
20872: LD_REAL  1.10000000000000E+0000
20875: MUL
20876: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20877: LD_ADDR_VAR 0 10
20881: PUSH
20882: LD_VAR 0 10
20886: PUSH
20887: LD_VAR 0 6
20891: PPUSH
20892: LD_INT 1
20894: PPUSH
20895: CALL_OW 259
20899: PUSH
20900: LD_REAL  1.15000000000000E+0000
20903: MUL
20904: MUL
20905: ST_TO_ADDR
// end ; unit_vehicle :
20906: GO 21730
20908: LD_INT 2
20910: DOUBLE
20911: EQUAL
20912: IFTRUE 20916
20914: GO 21718
20916: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20917: LD_VAR 0 6
20921: PPUSH
20922: CALL_OW 264
20926: PUSH
20927: LD_INT 2
20929: PUSH
20930: LD_INT 42
20932: PUSH
20933: LD_INT 24
20935: PUSH
20936: EMPTY
20937: LIST
20938: LIST
20939: LIST
20940: IN
20941: IFFALSE 20962
// points := [ 25 , 5 , 3 ] ;
20943: LD_ADDR_VAR 0 9
20947: PUSH
20948: LD_INT 25
20950: PUSH
20951: LD_INT 5
20953: PUSH
20954: LD_INT 3
20956: PUSH
20957: EMPTY
20958: LIST
20959: LIST
20960: LIST
20961: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20962: LD_VAR 0 6
20966: PPUSH
20967: CALL_OW 264
20971: PUSH
20972: LD_INT 4
20974: PUSH
20975: LD_INT 43
20977: PUSH
20978: LD_INT 25
20980: PUSH
20981: EMPTY
20982: LIST
20983: LIST
20984: LIST
20985: IN
20986: IFFALSE 21007
// points := [ 40 , 15 , 5 ] ;
20988: LD_ADDR_VAR 0 9
20992: PUSH
20993: LD_INT 40
20995: PUSH
20996: LD_INT 15
20998: PUSH
20999: LD_INT 5
21001: PUSH
21002: EMPTY
21003: LIST
21004: LIST
21005: LIST
21006: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21007: LD_VAR 0 6
21011: PPUSH
21012: CALL_OW 264
21016: PUSH
21017: LD_INT 3
21019: PUSH
21020: LD_INT 23
21022: PUSH
21023: EMPTY
21024: LIST
21025: LIST
21026: IN
21027: IFFALSE 21048
// points := [ 7 , 25 , 8 ] ;
21029: LD_ADDR_VAR 0 9
21033: PUSH
21034: LD_INT 7
21036: PUSH
21037: LD_INT 25
21039: PUSH
21040: LD_INT 8
21042: PUSH
21043: EMPTY
21044: LIST
21045: LIST
21046: LIST
21047: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21048: LD_VAR 0 6
21052: PPUSH
21053: CALL_OW 264
21057: PUSH
21058: LD_INT 5
21060: PUSH
21061: LD_INT 27
21063: PUSH
21064: LD_INT 44
21066: PUSH
21067: EMPTY
21068: LIST
21069: LIST
21070: LIST
21071: IN
21072: IFFALSE 21093
// points := [ 14 , 50 , 16 ] ;
21074: LD_ADDR_VAR 0 9
21078: PUSH
21079: LD_INT 14
21081: PUSH
21082: LD_INT 50
21084: PUSH
21085: LD_INT 16
21087: PUSH
21088: EMPTY
21089: LIST
21090: LIST
21091: LIST
21092: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21093: LD_VAR 0 6
21097: PPUSH
21098: CALL_OW 264
21102: PUSH
21103: LD_INT 6
21105: PUSH
21106: LD_INT 46
21108: PUSH
21109: EMPTY
21110: LIST
21111: LIST
21112: IN
21113: IFFALSE 21134
// points := [ 32 , 120 , 70 ] ;
21115: LD_ADDR_VAR 0 9
21119: PUSH
21120: LD_INT 32
21122: PUSH
21123: LD_INT 120
21125: PUSH
21126: LD_INT 70
21128: PUSH
21129: EMPTY
21130: LIST
21131: LIST
21132: LIST
21133: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21134: LD_VAR 0 6
21138: PPUSH
21139: CALL_OW 264
21143: PUSH
21144: LD_INT 7
21146: PUSH
21147: LD_INT 28
21149: PUSH
21150: LD_INT 45
21152: PUSH
21153: EMPTY
21154: LIST
21155: LIST
21156: LIST
21157: IN
21158: IFFALSE 21179
// points := [ 35 , 20 , 45 ] ;
21160: LD_ADDR_VAR 0 9
21164: PUSH
21165: LD_INT 35
21167: PUSH
21168: LD_INT 20
21170: PUSH
21171: LD_INT 45
21173: PUSH
21174: EMPTY
21175: LIST
21176: LIST
21177: LIST
21178: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21179: LD_VAR 0 6
21183: PPUSH
21184: CALL_OW 264
21188: PUSH
21189: LD_INT 47
21191: PUSH
21192: EMPTY
21193: LIST
21194: IN
21195: IFFALSE 21216
// points := [ 67 , 45 , 75 ] ;
21197: LD_ADDR_VAR 0 9
21201: PUSH
21202: LD_INT 67
21204: PUSH
21205: LD_INT 45
21207: PUSH
21208: LD_INT 75
21210: PUSH
21211: EMPTY
21212: LIST
21213: LIST
21214: LIST
21215: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21216: LD_VAR 0 6
21220: PPUSH
21221: CALL_OW 264
21225: PUSH
21226: LD_INT 26
21228: PUSH
21229: EMPTY
21230: LIST
21231: IN
21232: IFFALSE 21253
// points := [ 120 , 30 , 80 ] ;
21234: LD_ADDR_VAR 0 9
21238: PUSH
21239: LD_INT 120
21241: PUSH
21242: LD_INT 30
21244: PUSH
21245: LD_INT 80
21247: PUSH
21248: EMPTY
21249: LIST
21250: LIST
21251: LIST
21252: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21253: LD_VAR 0 6
21257: PPUSH
21258: CALL_OW 264
21262: PUSH
21263: LD_INT 22
21265: PUSH
21266: EMPTY
21267: LIST
21268: IN
21269: IFFALSE 21290
// points := [ 40 , 1 , 1 ] ;
21271: LD_ADDR_VAR 0 9
21275: PUSH
21276: LD_INT 40
21278: PUSH
21279: LD_INT 1
21281: PUSH
21282: LD_INT 1
21284: PUSH
21285: EMPTY
21286: LIST
21287: LIST
21288: LIST
21289: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21290: LD_VAR 0 6
21294: PPUSH
21295: CALL_OW 264
21299: PUSH
21300: LD_INT 29
21302: PUSH
21303: EMPTY
21304: LIST
21305: IN
21306: IFFALSE 21327
// points := [ 70 , 200 , 400 ] ;
21308: LD_ADDR_VAR 0 9
21312: PUSH
21313: LD_INT 70
21315: PUSH
21316: LD_INT 200
21318: PUSH
21319: LD_INT 400
21321: PUSH
21322: EMPTY
21323: LIST
21324: LIST
21325: LIST
21326: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21327: LD_VAR 0 6
21331: PPUSH
21332: CALL_OW 264
21336: PUSH
21337: LD_INT 14
21339: PUSH
21340: LD_INT 53
21342: PUSH
21343: EMPTY
21344: LIST
21345: LIST
21346: IN
21347: IFFALSE 21368
// points := [ 40 , 10 , 20 ] ;
21349: LD_ADDR_VAR 0 9
21353: PUSH
21354: LD_INT 40
21356: PUSH
21357: LD_INT 10
21359: PUSH
21360: LD_INT 20
21362: PUSH
21363: EMPTY
21364: LIST
21365: LIST
21366: LIST
21367: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21368: LD_VAR 0 6
21372: PPUSH
21373: CALL_OW 264
21377: PUSH
21378: LD_INT 9
21380: PUSH
21381: EMPTY
21382: LIST
21383: IN
21384: IFFALSE 21405
// points := [ 5 , 70 , 20 ] ;
21386: LD_ADDR_VAR 0 9
21390: PUSH
21391: LD_INT 5
21393: PUSH
21394: LD_INT 70
21396: PUSH
21397: LD_INT 20
21399: PUSH
21400: EMPTY
21401: LIST
21402: LIST
21403: LIST
21404: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21405: LD_VAR 0 6
21409: PPUSH
21410: CALL_OW 264
21414: PUSH
21415: LD_INT 10
21417: PUSH
21418: EMPTY
21419: LIST
21420: IN
21421: IFFALSE 21442
// points := [ 35 , 110 , 70 ] ;
21423: LD_ADDR_VAR 0 9
21427: PUSH
21428: LD_INT 35
21430: PUSH
21431: LD_INT 110
21433: PUSH
21434: LD_INT 70
21436: PUSH
21437: EMPTY
21438: LIST
21439: LIST
21440: LIST
21441: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21442: LD_VAR 0 6
21446: PPUSH
21447: CALL_OW 265
21451: PUSH
21452: LD_INT 25
21454: EQUAL
21455: IFFALSE 21476
// points := [ 80 , 65 , 100 ] ;
21457: LD_ADDR_VAR 0 9
21461: PUSH
21462: LD_INT 80
21464: PUSH
21465: LD_INT 65
21467: PUSH
21468: LD_INT 100
21470: PUSH
21471: EMPTY
21472: LIST
21473: LIST
21474: LIST
21475: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21476: LD_VAR 0 6
21480: PPUSH
21481: CALL_OW 263
21485: PUSH
21486: LD_INT 1
21488: EQUAL
21489: IFFALSE 21524
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21491: LD_ADDR_VAR 0 10
21495: PUSH
21496: LD_VAR 0 10
21500: PUSH
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 311
21510: PPUSH
21511: LD_INT 3
21513: PPUSH
21514: CALL_OW 259
21518: PUSH
21519: LD_INT 4
21521: MUL
21522: MUL
21523: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21524: LD_VAR 0 6
21528: PPUSH
21529: CALL_OW 263
21533: PUSH
21534: LD_INT 2
21536: EQUAL
21537: IFFALSE 21588
// begin j := IsControledBy ( i ) ;
21539: LD_ADDR_VAR 0 7
21543: PUSH
21544: LD_VAR 0 6
21548: PPUSH
21549: CALL_OW 312
21553: ST_TO_ADDR
// if j then
21554: LD_VAR 0 7
21558: IFFALSE 21588
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21560: LD_ADDR_VAR 0 10
21564: PUSH
21565: LD_VAR 0 10
21569: PUSH
21570: LD_VAR 0 7
21574: PPUSH
21575: LD_INT 3
21577: PPUSH
21578: CALL_OW 259
21582: PUSH
21583: LD_INT 3
21585: MUL
21586: MUL
21587: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21588: LD_VAR 0 6
21592: PPUSH
21593: CALL_OW 264
21597: PUSH
21598: LD_INT 5
21600: PUSH
21601: LD_INT 6
21603: PUSH
21604: LD_INT 46
21606: PUSH
21607: LD_INT 44
21609: PUSH
21610: LD_INT 47
21612: PUSH
21613: LD_INT 45
21615: PUSH
21616: LD_INT 28
21618: PUSH
21619: LD_INT 7
21621: PUSH
21622: LD_INT 27
21624: PUSH
21625: LD_INT 29
21627: PUSH
21628: EMPTY
21629: LIST
21630: LIST
21631: LIST
21632: LIST
21633: LIST
21634: LIST
21635: LIST
21636: LIST
21637: LIST
21638: LIST
21639: IN
21640: PUSH
21641: LD_VAR 0 1
21645: PPUSH
21646: LD_INT 52
21648: PPUSH
21649: CALL_OW 321
21653: PUSH
21654: LD_INT 2
21656: EQUAL
21657: AND
21658: IFFALSE 21675
// bpoints := bpoints * 1.2 ;
21660: LD_ADDR_VAR 0 10
21664: PUSH
21665: LD_VAR 0 10
21669: PUSH
21670: LD_REAL  1.20000000000000E+0000
21673: MUL
21674: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21675: LD_VAR 0 6
21679: PPUSH
21680: CALL_OW 264
21684: PUSH
21685: LD_INT 6
21687: PUSH
21688: LD_INT 46
21690: PUSH
21691: LD_INT 47
21693: PUSH
21694: EMPTY
21695: LIST
21696: LIST
21697: LIST
21698: IN
21699: IFFALSE 21716
// bpoints := bpoints * 1.2 ;
21701: LD_ADDR_VAR 0 10
21705: PUSH
21706: LD_VAR 0 10
21710: PUSH
21711: LD_REAL  1.20000000000000E+0000
21714: MUL
21715: ST_TO_ADDR
// end ; unit_building :
21716: GO 21730
21718: LD_INT 3
21720: DOUBLE
21721: EQUAL
21722: IFTRUE 21726
21724: GO 21729
21726: POP
// ; end ;
21727: GO 21730
21729: POP
// for j = 1 to 3 do
21730: LD_ADDR_VAR 0 7
21734: PUSH
21735: DOUBLE
21736: LD_INT 1
21738: DEC
21739: ST_TO_ADDR
21740: LD_INT 3
21742: PUSH
21743: FOR_TO
21744: IFFALSE 21797
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21746: LD_ADDR_VAR 0 5
21750: PUSH
21751: LD_VAR 0 5
21755: PPUSH
21756: LD_VAR 0 7
21760: PPUSH
21761: LD_VAR 0 5
21765: PUSH
21766: LD_VAR 0 7
21770: ARRAY
21771: PUSH
21772: LD_VAR 0 9
21776: PUSH
21777: LD_VAR 0 7
21781: ARRAY
21782: PUSH
21783: LD_VAR 0 10
21787: MUL
21788: PLUS
21789: PPUSH
21790: CALL_OW 1
21794: ST_TO_ADDR
21795: GO 21743
21797: POP
21798: POP
// end ;
21799: GO 20282
21801: POP
21802: POP
// result := Replace ( result , 4 , tmp ) ;
21803: LD_ADDR_VAR 0 5
21807: PUSH
21808: LD_VAR 0 5
21812: PPUSH
21813: LD_INT 4
21815: PPUSH
21816: LD_VAR 0 8
21820: PPUSH
21821: CALL_OW 1
21825: ST_TO_ADDR
// end ;
21826: LD_VAR 0 5
21830: RET
// export function DangerAtRange ( unit , range ) ; begin
21831: LD_INT 0
21833: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21834: LD_ADDR_VAR 0 3
21838: PUSH
21839: LD_VAR 0 1
21843: PPUSH
21844: CALL_OW 255
21848: PPUSH
21849: LD_VAR 0 1
21853: PPUSH
21854: CALL_OW 250
21858: PPUSH
21859: LD_VAR 0 1
21863: PPUSH
21864: CALL_OW 251
21868: PPUSH
21869: LD_VAR 0 2
21873: PPUSH
21874: CALL 20134 0 4
21878: ST_TO_ADDR
// end ;
21879: LD_VAR 0 3
21883: RET
// export function DangerInArea ( side , area ) ; begin
21884: LD_INT 0
21886: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21887: LD_ADDR_VAR 0 3
21891: PUSH
21892: LD_VAR 0 2
21896: PPUSH
21897: LD_INT 81
21899: PUSH
21900: LD_VAR 0 1
21904: PUSH
21905: EMPTY
21906: LIST
21907: LIST
21908: PPUSH
21909: CALL_OW 70
21913: ST_TO_ADDR
// end ;
21914: LD_VAR 0 3
21918: RET
// export function IsExtension ( b ) ; begin
21919: LD_INT 0
21921: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21922: LD_ADDR_VAR 0 2
21926: PUSH
21927: LD_VAR 0 1
21931: PUSH
21932: LD_INT 23
21934: PUSH
21935: LD_INT 20
21937: PUSH
21938: LD_INT 22
21940: PUSH
21941: LD_INT 17
21943: PUSH
21944: LD_INT 24
21946: PUSH
21947: LD_INT 21
21949: PUSH
21950: LD_INT 19
21952: PUSH
21953: LD_INT 16
21955: PUSH
21956: LD_INT 25
21958: PUSH
21959: LD_INT 18
21961: PUSH
21962: EMPTY
21963: LIST
21964: LIST
21965: LIST
21966: LIST
21967: LIST
21968: LIST
21969: LIST
21970: LIST
21971: LIST
21972: LIST
21973: IN
21974: ST_TO_ADDR
// end ;
21975: LD_VAR 0 2
21979: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
21980: LD_INT 0
21982: PPUSH
21983: PPUSH
21984: PPUSH
// result := [ ] ;
21985: LD_ADDR_VAR 0 3
21989: PUSH
21990: EMPTY
21991: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
21992: LD_ADDR_VAR 0 4
21996: PUSH
21997: LD_VAR 0 2
22001: PPUSH
22002: LD_INT 21
22004: PUSH
22005: LD_INT 3
22007: PUSH
22008: EMPTY
22009: LIST
22010: LIST
22011: PPUSH
22012: CALL_OW 70
22016: ST_TO_ADDR
// if not tmp then
22017: LD_VAR 0 4
22021: NOT
22022: IFFALSE 22026
// exit ;
22024: GO 22084
// for i in tmp do
22026: LD_ADDR_VAR 0 5
22030: PUSH
22031: LD_VAR 0 4
22035: PUSH
22036: FOR_IN
22037: IFFALSE 22072
// if GetBase ( i ) <> base then
22039: LD_VAR 0 5
22043: PPUSH
22044: CALL_OW 274
22048: PUSH
22049: LD_VAR 0 1
22053: NONEQUAL
22054: IFFALSE 22070
// ComLinkToBase ( base , i ) ;
22056: LD_VAR 0 1
22060: PPUSH
22061: LD_VAR 0 5
22065: PPUSH
22066: CALL_OW 169
22070: GO 22036
22072: POP
22073: POP
// result := tmp ;
22074: LD_ADDR_VAR 0 3
22078: PUSH
22079: LD_VAR 0 4
22083: ST_TO_ADDR
// end ;
22084: LD_VAR 0 3
22088: RET
// export function ComComplete ( unit , b ) ; var i ; begin
22089: LD_INT 0
22091: PPUSH
22092: PPUSH
// if BuildingStatus ( b ) = bs_build then
22093: LD_VAR 0 2
22097: PPUSH
22098: CALL_OW 461
22102: PUSH
22103: LD_INT 1
22105: EQUAL
22106: IFFALSE 22166
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22108: LD_VAR 0 1
22112: PPUSH
22113: LD_STRING h
22115: PUSH
22116: LD_VAR 0 2
22120: PPUSH
22121: CALL_OW 250
22125: PUSH
22126: LD_VAR 0 2
22130: PPUSH
22131: CALL_OW 251
22135: PUSH
22136: LD_VAR 0 2
22140: PUSH
22141: LD_INT 0
22143: PUSH
22144: LD_INT 0
22146: PUSH
22147: LD_INT 0
22149: PUSH
22150: EMPTY
22151: LIST
22152: LIST
22153: LIST
22154: LIST
22155: LIST
22156: LIST
22157: LIST
22158: PUSH
22159: EMPTY
22160: LIST
22161: PPUSH
22162: CALL_OW 446
// end ;
22166: LD_VAR 0 3
22170: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22171: LD_INT 0
22173: PPUSH
22174: PPUSH
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22179: LD_VAR 0 1
22183: NOT
22184: PUSH
22185: LD_VAR 0 1
22189: PPUSH
22190: CALL_OW 263
22194: PUSH
22195: LD_INT 2
22197: EQUAL
22198: NOT
22199: OR
22200: IFFALSE 22204
// exit ;
22202: GO 22520
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22204: LD_ADDR_VAR 0 6
22208: PUSH
22209: LD_INT 22
22211: PUSH
22212: LD_VAR 0 1
22216: PPUSH
22217: CALL_OW 255
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: PUSH
22226: LD_INT 2
22228: PUSH
22229: LD_INT 30
22231: PUSH
22232: LD_INT 36
22234: PUSH
22235: EMPTY
22236: LIST
22237: LIST
22238: PUSH
22239: LD_INT 34
22241: PUSH
22242: LD_INT 31
22244: PUSH
22245: EMPTY
22246: LIST
22247: LIST
22248: PUSH
22249: EMPTY
22250: LIST
22251: LIST
22252: LIST
22253: PUSH
22254: EMPTY
22255: LIST
22256: LIST
22257: PPUSH
22258: CALL_OW 69
22262: ST_TO_ADDR
// if not tmp then
22263: LD_VAR 0 6
22267: NOT
22268: IFFALSE 22272
// exit ;
22270: GO 22520
// result := [ ] ;
22272: LD_ADDR_VAR 0 2
22276: PUSH
22277: EMPTY
22278: ST_TO_ADDR
// for i in tmp do
22279: LD_ADDR_VAR 0 3
22283: PUSH
22284: LD_VAR 0 6
22288: PUSH
22289: FOR_IN
22290: IFFALSE 22361
// begin t := UnitsInside ( i ) ;
22292: LD_ADDR_VAR 0 4
22296: PUSH
22297: LD_VAR 0 3
22301: PPUSH
22302: CALL_OW 313
22306: ST_TO_ADDR
// if t then
22307: LD_VAR 0 4
22311: IFFALSE 22359
// for j in t do
22313: LD_ADDR_VAR 0 7
22317: PUSH
22318: LD_VAR 0 4
22322: PUSH
22323: FOR_IN
22324: IFFALSE 22357
// result := Insert ( result , result + 1 , j ) ;
22326: LD_ADDR_VAR 0 2
22330: PUSH
22331: LD_VAR 0 2
22335: PPUSH
22336: LD_VAR 0 2
22340: PUSH
22341: LD_INT 1
22343: PLUS
22344: PPUSH
22345: LD_VAR 0 7
22349: PPUSH
22350: CALL_OW 2
22354: ST_TO_ADDR
22355: GO 22323
22357: POP
22358: POP
// end ;
22359: GO 22289
22361: POP
22362: POP
// if not result then
22363: LD_VAR 0 2
22367: NOT
22368: IFFALSE 22372
// exit ;
22370: GO 22520
// mech := result [ 1 ] ;
22372: LD_ADDR_VAR 0 5
22376: PUSH
22377: LD_VAR 0 2
22381: PUSH
22382: LD_INT 1
22384: ARRAY
22385: ST_TO_ADDR
// if result > 1 then
22386: LD_VAR 0 2
22390: PUSH
22391: LD_INT 1
22393: GREATER
22394: IFFALSE 22506
// for i = 2 to result do
22396: LD_ADDR_VAR 0 3
22400: PUSH
22401: DOUBLE
22402: LD_INT 2
22404: DEC
22405: ST_TO_ADDR
22406: LD_VAR 0 2
22410: PUSH
22411: FOR_TO
22412: IFFALSE 22504
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22414: LD_ADDR_VAR 0 4
22418: PUSH
22419: LD_VAR 0 2
22423: PUSH
22424: LD_VAR 0 3
22428: ARRAY
22429: PPUSH
22430: LD_INT 3
22432: PPUSH
22433: CALL_OW 259
22437: PUSH
22438: LD_VAR 0 2
22442: PUSH
22443: LD_VAR 0 3
22447: ARRAY
22448: PPUSH
22449: CALL_OW 432
22453: MINUS
22454: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22455: LD_VAR 0 4
22459: PUSH
22460: LD_VAR 0 5
22464: PPUSH
22465: LD_INT 3
22467: PPUSH
22468: CALL_OW 259
22472: PUSH
22473: LD_VAR 0 5
22477: PPUSH
22478: CALL_OW 432
22482: MINUS
22483: GREATEREQUAL
22484: IFFALSE 22502
// mech := result [ i ] ;
22486: LD_ADDR_VAR 0 5
22490: PUSH
22491: LD_VAR 0 2
22495: PUSH
22496: LD_VAR 0 3
22500: ARRAY
22501: ST_TO_ADDR
// end ;
22502: GO 22411
22504: POP
22505: POP
// ComLinkTo ( vehicle , mech ) ;
22506: LD_VAR 0 1
22510: PPUSH
22511: LD_VAR 0 5
22515: PPUSH
22516: CALL_OW 135
// end ;
22520: LD_VAR 0 2
22524: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22525: LD_INT 0
22527: PPUSH
22528: PPUSH
22529: PPUSH
22530: PPUSH
22531: PPUSH
22532: PPUSH
22533: PPUSH
22534: PPUSH
22535: PPUSH
22536: PPUSH
22537: PPUSH
22538: PPUSH
22539: PPUSH
// result := [ ] ;
22540: LD_ADDR_VAR 0 7
22544: PUSH
22545: EMPTY
22546: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22547: LD_VAR 0 1
22551: PPUSH
22552: CALL_OW 266
22556: PUSH
22557: LD_INT 0
22559: PUSH
22560: LD_INT 1
22562: PUSH
22563: EMPTY
22564: LIST
22565: LIST
22566: IN
22567: NOT
22568: IFFALSE 22572
// exit ;
22570: GO 24203
// if name then
22572: LD_VAR 0 3
22576: IFFALSE 22592
// SetBName ( base_dep , name ) ;
22578: LD_VAR 0 1
22582: PPUSH
22583: LD_VAR 0 3
22587: PPUSH
22588: CALL_OW 500
// base := GetBase ( base_dep ) ;
22592: LD_ADDR_VAR 0 15
22596: PUSH
22597: LD_VAR 0 1
22601: PPUSH
22602: CALL_OW 274
22606: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22607: LD_ADDR_VAR 0 16
22611: PUSH
22612: LD_VAR 0 1
22616: PPUSH
22617: CALL_OW 255
22621: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22622: LD_ADDR_VAR 0 17
22626: PUSH
22627: LD_VAR 0 1
22631: PPUSH
22632: CALL_OW 248
22636: ST_TO_ADDR
// if sources then
22637: LD_VAR 0 5
22641: IFFALSE 22688
// for i = 1 to 3 do
22643: LD_ADDR_VAR 0 8
22647: PUSH
22648: DOUBLE
22649: LD_INT 1
22651: DEC
22652: ST_TO_ADDR
22653: LD_INT 3
22655: PUSH
22656: FOR_TO
22657: IFFALSE 22686
// AddResourceType ( base , i , sources [ i ] ) ;
22659: LD_VAR 0 15
22663: PPUSH
22664: LD_VAR 0 8
22668: PPUSH
22669: LD_VAR 0 5
22673: PUSH
22674: LD_VAR 0 8
22678: ARRAY
22679: PPUSH
22680: CALL_OW 276
22684: GO 22656
22686: POP
22687: POP
// buildings := GetBaseBuildings ( base , area ) ;
22688: LD_ADDR_VAR 0 18
22692: PUSH
22693: LD_VAR 0 15
22697: PPUSH
22698: LD_VAR 0 2
22702: PPUSH
22703: CALL 21980 0 2
22707: ST_TO_ADDR
// InitHc ;
22708: CALL_OW 19
// InitUc ;
22712: CALL_OW 18
// uc_side := side ;
22716: LD_ADDR_OWVAR 20
22720: PUSH
22721: LD_VAR 0 16
22725: ST_TO_ADDR
// uc_nation := nation ;
22726: LD_ADDR_OWVAR 21
22730: PUSH
22731: LD_VAR 0 17
22735: ST_TO_ADDR
// if buildings then
22736: LD_VAR 0 18
22740: IFFALSE 24062
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22742: LD_ADDR_VAR 0 19
22746: PUSH
22747: LD_VAR 0 18
22751: PPUSH
22752: LD_INT 2
22754: PUSH
22755: LD_INT 30
22757: PUSH
22758: LD_INT 29
22760: PUSH
22761: EMPTY
22762: LIST
22763: LIST
22764: PUSH
22765: LD_INT 30
22767: PUSH
22768: LD_INT 30
22770: PUSH
22771: EMPTY
22772: LIST
22773: LIST
22774: PUSH
22775: EMPTY
22776: LIST
22777: LIST
22778: LIST
22779: PPUSH
22780: CALL_OW 72
22784: ST_TO_ADDR
// if tmp then
22785: LD_VAR 0 19
22789: IFFALSE 22837
// for i in tmp do
22791: LD_ADDR_VAR 0 8
22795: PUSH
22796: LD_VAR 0 19
22800: PUSH
22801: FOR_IN
22802: IFFALSE 22835
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22804: LD_VAR 0 8
22808: PPUSH
22809: CALL_OW 250
22813: PPUSH
22814: LD_VAR 0 8
22818: PPUSH
22819: CALL_OW 251
22823: PPUSH
22824: LD_VAR 0 16
22828: PPUSH
22829: CALL_OW 441
22833: GO 22801
22835: POP
22836: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22837: LD_VAR 0 18
22841: PPUSH
22842: LD_INT 2
22844: PUSH
22845: LD_INT 30
22847: PUSH
22848: LD_INT 32
22850: PUSH
22851: EMPTY
22852: LIST
22853: LIST
22854: PUSH
22855: LD_INT 30
22857: PUSH
22858: LD_INT 33
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PUSH
22865: EMPTY
22866: LIST
22867: LIST
22868: LIST
22869: PPUSH
22870: CALL_OW 72
22874: IFFALSE 22962
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22876: LD_ADDR_VAR 0 8
22880: PUSH
22881: LD_VAR 0 18
22885: PPUSH
22886: LD_INT 2
22888: PUSH
22889: LD_INT 30
22891: PUSH
22892: LD_INT 32
22894: PUSH
22895: EMPTY
22896: LIST
22897: LIST
22898: PUSH
22899: LD_INT 30
22901: PUSH
22902: LD_INT 33
22904: PUSH
22905: EMPTY
22906: LIST
22907: LIST
22908: PUSH
22909: EMPTY
22910: LIST
22911: LIST
22912: LIST
22913: PPUSH
22914: CALL_OW 72
22918: PUSH
22919: FOR_IN
22920: IFFALSE 22960
// begin if not GetBWeapon ( i ) then
22922: LD_VAR 0 8
22926: PPUSH
22927: CALL_OW 269
22931: NOT
22932: IFFALSE 22958
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22934: LD_VAR 0 8
22938: PPUSH
22939: LD_VAR 0 8
22943: PPUSH
22944: LD_VAR 0 2
22948: PPUSH
22949: CALL 24208 0 2
22953: PPUSH
22954: CALL_OW 431
// end ;
22958: GO 22919
22960: POP
22961: POP
// end ; for i = 1 to personel do
22962: LD_ADDR_VAR 0 8
22966: PUSH
22967: DOUBLE
22968: LD_INT 1
22970: DEC
22971: ST_TO_ADDR
22972: LD_VAR 0 6
22976: PUSH
22977: FOR_TO
22978: IFFALSE 24042
// begin if i > 4 then
22980: LD_VAR 0 8
22984: PUSH
22985: LD_INT 4
22987: GREATER
22988: IFFALSE 22992
// break ;
22990: GO 24042
// case i of 1 :
22992: LD_VAR 0 8
22996: PUSH
22997: LD_INT 1
22999: DOUBLE
23000: EQUAL
23001: IFTRUE 23005
23003: GO 23085
23005: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23006: LD_ADDR_VAR 0 12
23010: PUSH
23011: LD_VAR 0 18
23015: PPUSH
23016: LD_INT 22
23018: PUSH
23019: LD_VAR 0 16
23023: PUSH
23024: EMPTY
23025: LIST
23026: LIST
23027: PUSH
23028: LD_INT 58
23030: PUSH
23031: EMPTY
23032: LIST
23033: PUSH
23034: LD_INT 2
23036: PUSH
23037: LD_INT 30
23039: PUSH
23040: LD_INT 32
23042: PUSH
23043: EMPTY
23044: LIST
23045: LIST
23046: PUSH
23047: LD_INT 30
23049: PUSH
23050: LD_INT 4
23052: PUSH
23053: EMPTY
23054: LIST
23055: LIST
23056: PUSH
23057: LD_INT 30
23059: PUSH
23060: LD_INT 5
23062: PUSH
23063: EMPTY
23064: LIST
23065: LIST
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: LIST
23071: LIST
23072: PUSH
23073: EMPTY
23074: LIST
23075: LIST
23076: LIST
23077: PPUSH
23078: CALL_OW 72
23082: ST_TO_ADDR
23083: GO 23307
23085: LD_INT 2
23087: DOUBLE
23088: EQUAL
23089: IFTRUE 23093
23091: GO 23155
23093: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23094: LD_ADDR_VAR 0 12
23098: PUSH
23099: LD_VAR 0 18
23103: PPUSH
23104: LD_INT 22
23106: PUSH
23107: LD_VAR 0 16
23111: PUSH
23112: EMPTY
23113: LIST
23114: LIST
23115: PUSH
23116: LD_INT 2
23118: PUSH
23119: LD_INT 30
23121: PUSH
23122: LD_INT 0
23124: PUSH
23125: EMPTY
23126: LIST
23127: LIST
23128: PUSH
23129: LD_INT 30
23131: PUSH
23132: LD_INT 1
23134: PUSH
23135: EMPTY
23136: LIST
23137: LIST
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: LIST
23143: PUSH
23144: EMPTY
23145: LIST
23146: LIST
23147: PPUSH
23148: CALL_OW 72
23152: ST_TO_ADDR
23153: GO 23307
23155: LD_INT 3
23157: DOUBLE
23158: EQUAL
23159: IFTRUE 23163
23161: GO 23225
23163: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23164: LD_ADDR_VAR 0 12
23168: PUSH
23169: LD_VAR 0 18
23173: PPUSH
23174: LD_INT 22
23176: PUSH
23177: LD_VAR 0 16
23181: PUSH
23182: EMPTY
23183: LIST
23184: LIST
23185: PUSH
23186: LD_INT 2
23188: PUSH
23189: LD_INT 30
23191: PUSH
23192: LD_INT 2
23194: PUSH
23195: EMPTY
23196: LIST
23197: LIST
23198: PUSH
23199: LD_INT 30
23201: PUSH
23202: LD_INT 3
23204: PUSH
23205: EMPTY
23206: LIST
23207: LIST
23208: PUSH
23209: EMPTY
23210: LIST
23211: LIST
23212: LIST
23213: PUSH
23214: EMPTY
23215: LIST
23216: LIST
23217: PPUSH
23218: CALL_OW 72
23222: ST_TO_ADDR
23223: GO 23307
23225: LD_INT 4
23227: DOUBLE
23228: EQUAL
23229: IFTRUE 23233
23231: GO 23306
23233: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23234: LD_ADDR_VAR 0 12
23238: PUSH
23239: LD_VAR 0 18
23243: PPUSH
23244: LD_INT 22
23246: PUSH
23247: LD_VAR 0 16
23251: PUSH
23252: EMPTY
23253: LIST
23254: LIST
23255: PUSH
23256: LD_INT 2
23258: PUSH
23259: LD_INT 30
23261: PUSH
23262: LD_INT 6
23264: PUSH
23265: EMPTY
23266: LIST
23267: LIST
23268: PUSH
23269: LD_INT 30
23271: PUSH
23272: LD_INT 7
23274: PUSH
23275: EMPTY
23276: LIST
23277: LIST
23278: PUSH
23279: LD_INT 30
23281: PUSH
23282: LD_INT 8
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: PUSH
23289: EMPTY
23290: LIST
23291: LIST
23292: LIST
23293: LIST
23294: PUSH
23295: EMPTY
23296: LIST
23297: LIST
23298: PPUSH
23299: CALL_OW 72
23303: ST_TO_ADDR
23304: GO 23307
23306: POP
// if i = 1 then
23307: LD_VAR 0 8
23311: PUSH
23312: LD_INT 1
23314: EQUAL
23315: IFFALSE 23426
// begin tmp := [ ] ;
23317: LD_ADDR_VAR 0 19
23321: PUSH
23322: EMPTY
23323: ST_TO_ADDR
// for j in f do
23324: LD_ADDR_VAR 0 9
23328: PUSH
23329: LD_VAR 0 12
23333: PUSH
23334: FOR_IN
23335: IFFALSE 23408
// if GetBType ( j ) = b_bunker then
23337: LD_VAR 0 9
23341: PPUSH
23342: CALL_OW 266
23346: PUSH
23347: LD_INT 32
23349: EQUAL
23350: IFFALSE 23377
// tmp := Insert ( tmp , 1 , j ) else
23352: LD_ADDR_VAR 0 19
23356: PUSH
23357: LD_VAR 0 19
23361: PPUSH
23362: LD_INT 1
23364: PPUSH
23365: LD_VAR 0 9
23369: PPUSH
23370: CALL_OW 2
23374: ST_TO_ADDR
23375: GO 23406
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23377: LD_ADDR_VAR 0 19
23381: PUSH
23382: LD_VAR 0 19
23386: PPUSH
23387: LD_VAR 0 19
23391: PUSH
23392: LD_INT 1
23394: PLUS
23395: PPUSH
23396: LD_VAR 0 9
23400: PPUSH
23401: CALL_OW 2
23405: ST_TO_ADDR
23406: GO 23334
23408: POP
23409: POP
// if tmp then
23410: LD_VAR 0 19
23414: IFFALSE 23426
// f := tmp ;
23416: LD_ADDR_VAR 0 12
23420: PUSH
23421: LD_VAR 0 19
23425: ST_TO_ADDR
// end ; x := personel [ i ] ;
23426: LD_ADDR_VAR 0 13
23430: PUSH
23431: LD_VAR 0 6
23435: PUSH
23436: LD_VAR 0 8
23440: ARRAY
23441: ST_TO_ADDR
// if x = - 1 then
23442: LD_VAR 0 13
23446: PUSH
23447: LD_INT 1
23449: NEG
23450: EQUAL
23451: IFFALSE 23660
// begin for j in f do
23453: LD_ADDR_VAR 0 9
23457: PUSH
23458: LD_VAR 0 12
23462: PUSH
23463: FOR_IN
23464: IFFALSE 23656
// repeat InitHc ;
23466: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23470: LD_VAR 0 9
23474: PPUSH
23475: CALL_OW 266
23479: PUSH
23480: LD_INT 5
23482: EQUAL
23483: IFFALSE 23553
// begin if UnitsInside ( j ) < 3 then
23485: LD_VAR 0 9
23489: PPUSH
23490: CALL_OW 313
23494: PUSH
23495: LD_INT 3
23497: LESS
23498: IFFALSE 23534
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23500: LD_INT 0
23502: PPUSH
23503: LD_INT 5
23505: PUSH
23506: LD_INT 8
23508: PUSH
23509: LD_INT 9
23511: PUSH
23512: EMPTY
23513: LIST
23514: LIST
23515: LIST
23516: PUSH
23517: LD_VAR 0 17
23521: ARRAY
23522: PPUSH
23523: LD_VAR 0 4
23527: PPUSH
23528: CALL_OW 380
23532: GO 23551
// PrepareHuman ( false , i , skill ) ;
23534: LD_INT 0
23536: PPUSH
23537: LD_VAR 0 8
23541: PPUSH
23542: LD_VAR 0 4
23546: PPUSH
23547: CALL_OW 380
// end else
23551: GO 23570
// PrepareHuman ( false , i , skill ) ;
23553: LD_INT 0
23555: PPUSH
23556: LD_VAR 0 8
23560: PPUSH
23561: LD_VAR 0 4
23565: PPUSH
23566: CALL_OW 380
// un := CreateHuman ;
23570: LD_ADDR_VAR 0 14
23574: PUSH
23575: CALL_OW 44
23579: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23580: LD_ADDR_VAR 0 7
23584: PUSH
23585: LD_VAR 0 7
23589: PPUSH
23590: LD_INT 1
23592: PPUSH
23593: LD_VAR 0 14
23597: PPUSH
23598: CALL_OW 2
23602: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23603: LD_VAR 0 14
23607: PPUSH
23608: LD_VAR 0 9
23612: PPUSH
23613: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23617: LD_VAR 0 9
23621: PPUSH
23622: CALL_OW 313
23626: PUSH
23627: LD_INT 6
23629: EQUAL
23630: PUSH
23631: LD_VAR 0 9
23635: PPUSH
23636: CALL_OW 266
23640: PUSH
23641: LD_INT 32
23643: PUSH
23644: LD_INT 31
23646: PUSH
23647: EMPTY
23648: LIST
23649: LIST
23650: IN
23651: OR
23652: IFFALSE 23466
23654: GO 23463
23656: POP
23657: POP
// end else
23658: GO 24040
// for j = 1 to x do
23660: LD_ADDR_VAR 0 9
23664: PUSH
23665: DOUBLE
23666: LD_INT 1
23668: DEC
23669: ST_TO_ADDR
23670: LD_VAR 0 13
23674: PUSH
23675: FOR_TO
23676: IFFALSE 24038
// begin InitHc ;
23678: CALL_OW 19
// if not f then
23682: LD_VAR 0 12
23686: NOT
23687: IFFALSE 23776
// begin PrepareHuman ( false , i , skill ) ;
23689: LD_INT 0
23691: PPUSH
23692: LD_VAR 0 8
23696: PPUSH
23697: LD_VAR 0 4
23701: PPUSH
23702: CALL_OW 380
// un := CreateHuman ;
23706: LD_ADDR_VAR 0 14
23710: PUSH
23711: CALL_OW 44
23715: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23716: LD_ADDR_VAR 0 7
23720: PUSH
23721: LD_VAR 0 7
23725: PPUSH
23726: LD_INT 1
23728: PPUSH
23729: LD_VAR 0 14
23733: PPUSH
23734: CALL_OW 2
23738: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23739: LD_VAR 0 14
23743: PPUSH
23744: LD_VAR 0 1
23748: PPUSH
23749: CALL_OW 250
23753: PPUSH
23754: LD_VAR 0 1
23758: PPUSH
23759: CALL_OW 251
23763: PPUSH
23764: LD_INT 10
23766: PPUSH
23767: LD_INT 0
23769: PPUSH
23770: CALL_OW 50
// continue ;
23774: GO 23675
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23776: LD_VAR 0 12
23780: PUSH
23781: LD_INT 1
23783: ARRAY
23784: PPUSH
23785: CALL_OW 313
23789: PUSH
23790: LD_VAR 0 12
23794: PUSH
23795: LD_INT 1
23797: ARRAY
23798: PPUSH
23799: CALL_OW 266
23803: PUSH
23804: LD_INT 32
23806: PUSH
23807: LD_INT 31
23809: PUSH
23810: EMPTY
23811: LIST
23812: LIST
23813: IN
23814: AND
23815: PUSH
23816: LD_VAR 0 12
23820: PUSH
23821: LD_INT 1
23823: ARRAY
23824: PPUSH
23825: CALL_OW 313
23829: PUSH
23830: LD_INT 6
23832: EQUAL
23833: OR
23834: IFFALSE 23854
// f := Delete ( f , 1 ) ;
23836: LD_ADDR_VAR 0 12
23840: PUSH
23841: LD_VAR 0 12
23845: PPUSH
23846: LD_INT 1
23848: PPUSH
23849: CALL_OW 3
23853: ST_TO_ADDR
// if not f then
23854: LD_VAR 0 12
23858: NOT
23859: IFFALSE 23877
// begin x := x + 2 ;
23861: LD_ADDR_VAR 0 13
23865: PUSH
23866: LD_VAR 0 13
23870: PUSH
23871: LD_INT 2
23873: PLUS
23874: ST_TO_ADDR
// continue ;
23875: GO 23675
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23877: LD_VAR 0 12
23881: PUSH
23882: LD_INT 1
23884: ARRAY
23885: PPUSH
23886: CALL_OW 266
23890: PUSH
23891: LD_INT 5
23893: EQUAL
23894: IFFALSE 23968
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23896: LD_VAR 0 12
23900: PUSH
23901: LD_INT 1
23903: ARRAY
23904: PPUSH
23905: CALL_OW 313
23909: PUSH
23910: LD_INT 3
23912: LESS
23913: IFFALSE 23949
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23915: LD_INT 0
23917: PPUSH
23918: LD_INT 5
23920: PUSH
23921: LD_INT 8
23923: PUSH
23924: LD_INT 9
23926: PUSH
23927: EMPTY
23928: LIST
23929: LIST
23930: LIST
23931: PUSH
23932: LD_VAR 0 17
23936: ARRAY
23937: PPUSH
23938: LD_VAR 0 4
23942: PPUSH
23943: CALL_OW 380
23947: GO 23966
// PrepareHuman ( false , i , skill ) ;
23949: LD_INT 0
23951: PPUSH
23952: LD_VAR 0 8
23956: PPUSH
23957: LD_VAR 0 4
23961: PPUSH
23962: CALL_OW 380
// end else
23966: GO 23985
// PrepareHuman ( false , i , skill ) ;
23968: LD_INT 0
23970: PPUSH
23971: LD_VAR 0 8
23975: PPUSH
23976: LD_VAR 0 4
23980: PPUSH
23981: CALL_OW 380
// un := CreateHuman ;
23985: LD_ADDR_VAR 0 14
23989: PUSH
23990: CALL_OW 44
23994: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23995: LD_ADDR_VAR 0 7
23999: PUSH
24000: LD_VAR 0 7
24004: PPUSH
24005: LD_INT 1
24007: PPUSH
24008: LD_VAR 0 14
24012: PPUSH
24013: CALL_OW 2
24017: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24018: LD_VAR 0 14
24022: PPUSH
24023: LD_VAR 0 12
24027: PUSH
24028: LD_INT 1
24030: ARRAY
24031: PPUSH
24032: CALL_OW 52
// end ;
24036: GO 23675
24038: POP
24039: POP
// end ;
24040: GO 22977
24042: POP
24043: POP
// result := result ^ buildings ;
24044: LD_ADDR_VAR 0 7
24048: PUSH
24049: LD_VAR 0 7
24053: PUSH
24054: LD_VAR 0 18
24058: ADD
24059: ST_TO_ADDR
// end else
24060: GO 24203
// begin for i = 1 to personel do
24062: LD_ADDR_VAR 0 8
24066: PUSH
24067: DOUBLE
24068: LD_INT 1
24070: DEC
24071: ST_TO_ADDR
24072: LD_VAR 0 6
24076: PUSH
24077: FOR_TO
24078: IFFALSE 24201
// begin if i > 4 then
24080: LD_VAR 0 8
24084: PUSH
24085: LD_INT 4
24087: GREATER
24088: IFFALSE 24092
// break ;
24090: GO 24201
// x := personel [ i ] ;
24092: LD_ADDR_VAR 0 13
24096: PUSH
24097: LD_VAR 0 6
24101: PUSH
24102: LD_VAR 0 8
24106: ARRAY
24107: ST_TO_ADDR
// if x = - 1 then
24108: LD_VAR 0 13
24112: PUSH
24113: LD_INT 1
24115: NEG
24116: EQUAL
24117: IFFALSE 24121
// continue ;
24119: GO 24077
// PrepareHuman ( false , i , skill ) ;
24121: LD_INT 0
24123: PPUSH
24124: LD_VAR 0 8
24128: PPUSH
24129: LD_VAR 0 4
24133: PPUSH
24134: CALL_OW 380
// un := CreateHuman ;
24138: LD_ADDR_VAR 0 14
24142: PUSH
24143: CALL_OW 44
24147: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24148: LD_VAR 0 14
24152: PPUSH
24153: LD_VAR 0 1
24157: PPUSH
24158: CALL_OW 250
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: CALL_OW 251
24172: PPUSH
24173: LD_INT 10
24175: PPUSH
24176: LD_INT 0
24178: PPUSH
24179: CALL_OW 50
// result := result ^ un ;
24183: LD_ADDR_VAR 0 7
24187: PUSH
24188: LD_VAR 0 7
24192: PUSH
24193: LD_VAR 0 14
24197: ADD
24198: ST_TO_ADDR
// end ;
24199: GO 24077
24201: POP
24202: POP
// end ; end ;
24203: LD_VAR 0 7
24207: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24208: LD_INT 0
24210: PPUSH
24211: PPUSH
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
24218: PPUSH
24219: PPUSH
24220: PPUSH
24221: PPUSH
24222: PPUSH
24223: PPUSH
24224: PPUSH
24225: PPUSH
// result := false ;
24226: LD_ADDR_VAR 0 3
24230: PUSH
24231: LD_INT 0
24233: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24234: LD_VAR 0 1
24238: NOT
24239: PUSH
24240: LD_VAR 0 1
24244: PPUSH
24245: CALL_OW 266
24249: PUSH
24250: LD_INT 32
24252: PUSH
24253: LD_INT 33
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: IN
24260: NOT
24261: OR
24262: IFFALSE 24266
// exit ;
24264: GO 25402
// nat := GetNation ( tower ) ;
24266: LD_ADDR_VAR 0 12
24270: PUSH
24271: LD_VAR 0 1
24275: PPUSH
24276: CALL_OW 248
24280: ST_TO_ADDR
// side := GetSide ( tower ) ;
24281: LD_ADDR_VAR 0 16
24285: PUSH
24286: LD_VAR 0 1
24290: PPUSH
24291: CALL_OW 255
24295: ST_TO_ADDR
// x := GetX ( tower ) ;
24296: LD_ADDR_VAR 0 10
24300: PUSH
24301: LD_VAR 0 1
24305: PPUSH
24306: CALL_OW 250
24310: ST_TO_ADDR
// y := GetY ( tower ) ;
24311: LD_ADDR_VAR 0 11
24315: PUSH
24316: LD_VAR 0 1
24320: PPUSH
24321: CALL_OW 251
24325: ST_TO_ADDR
// if not x or not y then
24326: LD_VAR 0 10
24330: NOT
24331: PUSH
24332: LD_VAR 0 11
24336: NOT
24337: OR
24338: IFFALSE 24342
// exit ;
24340: GO 25402
// weapon := 0 ;
24342: LD_ADDR_VAR 0 18
24346: PUSH
24347: LD_INT 0
24349: ST_TO_ADDR
// fac_list := [ ] ;
24350: LD_ADDR_VAR 0 17
24354: PUSH
24355: EMPTY
24356: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
24357: LD_ADDR_VAR 0 6
24361: PUSH
24362: LD_VAR 0 1
24366: PPUSH
24367: CALL_OW 274
24371: PPUSH
24372: LD_VAR 0 2
24376: PPUSH
24377: CALL 21980 0 2
24381: PPUSH
24382: LD_INT 30
24384: PUSH
24385: LD_INT 3
24387: PUSH
24388: EMPTY
24389: LIST
24390: LIST
24391: PPUSH
24392: CALL_OW 72
24396: ST_TO_ADDR
// if not factories then
24397: LD_VAR 0 6
24401: NOT
24402: IFFALSE 24406
// exit ;
24404: GO 25402
// for i in factories do
24406: LD_ADDR_VAR 0 8
24410: PUSH
24411: LD_VAR 0 6
24415: PUSH
24416: FOR_IN
24417: IFFALSE 24442
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24419: LD_ADDR_VAR 0 17
24423: PUSH
24424: LD_VAR 0 17
24428: PUSH
24429: LD_VAR 0 8
24433: PPUSH
24434: CALL_OW 478
24438: UNION
24439: ST_TO_ADDR
24440: GO 24416
24442: POP
24443: POP
// if not fac_list then
24444: LD_VAR 0 17
24448: NOT
24449: IFFALSE 24453
// exit ;
24451: GO 25402
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24453: LD_ADDR_VAR 0 5
24457: PUSH
24458: LD_INT 4
24460: PUSH
24461: LD_INT 5
24463: PUSH
24464: LD_INT 9
24466: PUSH
24467: LD_INT 10
24469: PUSH
24470: LD_INT 6
24472: PUSH
24473: LD_INT 7
24475: PUSH
24476: LD_INT 11
24478: PUSH
24479: EMPTY
24480: LIST
24481: LIST
24482: LIST
24483: LIST
24484: LIST
24485: LIST
24486: LIST
24487: PUSH
24488: LD_INT 27
24490: PUSH
24491: LD_INT 28
24493: PUSH
24494: LD_INT 26
24496: PUSH
24497: LD_INT 30
24499: PUSH
24500: EMPTY
24501: LIST
24502: LIST
24503: LIST
24504: LIST
24505: PUSH
24506: LD_INT 43
24508: PUSH
24509: LD_INT 44
24511: PUSH
24512: LD_INT 46
24514: PUSH
24515: LD_INT 45
24517: PUSH
24518: LD_INT 47
24520: PUSH
24521: LD_INT 49
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: LIST
24531: PUSH
24532: EMPTY
24533: LIST
24534: LIST
24535: LIST
24536: PUSH
24537: LD_VAR 0 12
24541: ARRAY
24542: ST_TO_ADDR
// for i in list do
24543: LD_ADDR_VAR 0 8
24547: PUSH
24548: LD_VAR 0 5
24552: PUSH
24553: FOR_IN
24554: IFFALSE 24587
// if not i in fac_list then
24556: LD_VAR 0 8
24560: PUSH
24561: LD_VAR 0 17
24565: IN
24566: NOT
24567: IFFALSE 24585
// list := list diff i ;
24569: LD_ADDR_VAR 0 5
24573: PUSH
24574: LD_VAR 0 5
24578: PUSH
24579: LD_VAR 0 8
24583: DIFF
24584: ST_TO_ADDR
24585: GO 24553
24587: POP
24588: POP
// if not list then
24589: LD_VAR 0 5
24593: NOT
24594: IFFALSE 24598
// exit ;
24596: GO 25402
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24598: LD_VAR 0 12
24602: PUSH
24603: LD_INT 3
24605: EQUAL
24606: PUSH
24607: LD_INT 49
24609: PUSH
24610: LD_VAR 0 5
24614: IN
24615: AND
24616: PUSH
24617: LD_INT 31
24619: PPUSH
24620: LD_VAR 0 16
24624: PPUSH
24625: CALL_OW 321
24629: PUSH
24630: LD_INT 2
24632: EQUAL
24633: AND
24634: IFFALSE 24694
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24636: LD_INT 22
24638: PUSH
24639: LD_VAR 0 16
24643: PUSH
24644: EMPTY
24645: LIST
24646: LIST
24647: PUSH
24648: LD_INT 35
24650: PUSH
24651: LD_INT 49
24653: PUSH
24654: EMPTY
24655: LIST
24656: LIST
24657: PUSH
24658: LD_INT 91
24660: PUSH
24661: LD_VAR 0 1
24665: PUSH
24666: LD_INT 10
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: LIST
24673: PUSH
24674: EMPTY
24675: LIST
24676: LIST
24677: LIST
24678: PPUSH
24679: CALL_OW 69
24683: NOT
24684: IFFALSE 24694
// weapon := ru_time_lapser ;
24686: LD_ADDR_VAR 0 18
24690: PUSH
24691: LD_INT 49
24693: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24694: LD_VAR 0 12
24698: PUSH
24699: LD_INT 1
24701: PUSH
24702: LD_INT 2
24704: PUSH
24705: EMPTY
24706: LIST
24707: LIST
24708: IN
24709: PUSH
24710: LD_INT 11
24712: PUSH
24713: LD_VAR 0 5
24717: IN
24718: PUSH
24719: LD_INT 30
24721: PUSH
24722: LD_VAR 0 5
24726: IN
24727: OR
24728: AND
24729: PUSH
24730: LD_INT 6
24732: PPUSH
24733: LD_VAR 0 16
24737: PPUSH
24738: CALL_OW 321
24742: PUSH
24743: LD_INT 2
24745: EQUAL
24746: AND
24747: IFFALSE 24912
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24749: LD_INT 22
24751: PUSH
24752: LD_VAR 0 16
24756: PUSH
24757: EMPTY
24758: LIST
24759: LIST
24760: PUSH
24761: LD_INT 2
24763: PUSH
24764: LD_INT 35
24766: PUSH
24767: LD_INT 11
24769: PUSH
24770: EMPTY
24771: LIST
24772: LIST
24773: PUSH
24774: LD_INT 35
24776: PUSH
24777: LD_INT 30
24779: PUSH
24780: EMPTY
24781: LIST
24782: LIST
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_INT 91
24791: PUSH
24792: LD_VAR 0 1
24796: PUSH
24797: LD_INT 18
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: LIST
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: LIST
24809: PPUSH
24810: CALL_OW 69
24814: NOT
24815: PUSH
24816: LD_INT 22
24818: PUSH
24819: LD_VAR 0 16
24823: PUSH
24824: EMPTY
24825: LIST
24826: LIST
24827: PUSH
24828: LD_INT 2
24830: PUSH
24831: LD_INT 30
24833: PUSH
24834: LD_INT 32
24836: PUSH
24837: EMPTY
24838: LIST
24839: LIST
24840: PUSH
24841: LD_INT 30
24843: PUSH
24844: LD_INT 33
24846: PUSH
24847: EMPTY
24848: LIST
24849: LIST
24850: PUSH
24851: EMPTY
24852: LIST
24853: LIST
24854: LIST
24855: PUSH
24856: LD_INT 91
24858: PUSH
24859: LD_VAR 0 1
24863: PUSH
24864: LD_INT 12
24866: PUSH
24867: EMPTY
24868: LIST
24869: LIST
24870: LIST
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: LIST
24876: PUSH
24877: EMPTY
24878: LIST
24879: PPUSH
24880: CALL_OW 69
24884: PUSH
24885: LD_INT 2
24887: GREATER
24888: AND
24889: IFFALSE 24912
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24891: LD_ADDR_VAR 0 18
24895: PUSH
24896: LD_INT 11
24898: PUSH
24899: LD_INT 30
24901: PUSH
24902: EMPTY
24903: LIST
24904: LIST
24905: PUSH
24906: LD_VAR 0 12
24910: ARRAY
24911: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24912: LD_VAR 0 18
24916: NOT
24917: PUSH
24918: LD_INT 40
24920: PPUSH
24921: LD_VAR 0 16
24925: PPUSH
24926: CALL_OW 321
24930: PUSH
24931: LD_INT 2
24933: EQUAL
24934: AND
24935: PUSH
24936: LD_INT 7
24938: PUSH
24939: LD_VAR 0 5
24943: IN
24944: PUSH
24945: LD_INT 28
24947: PUSH
24948: LD_VAR 0 5
24952: IN
24953: OR
24954: PUSH
24955: LD_INT 45
24957: PUSH
24958: LD_VAR 0 5
24962: IN
24963: OR
24964: AND
24965: IFFALSE 25219
// begin hex := GetHexInfo ( x , y ) ;
24967: LD_ADDR_VAR 0 4
24971: PUSH
24972: LD_VAR 0 10
24976: PPUSH
24977: LD_VAR 0 11
24981: PPUSH
24982: CALL_OW 546
24986: ST_TO_ADDR
// if hex [ 1 ] then
24987: LD_VAR 0 4
24991: PUSH
24992: LD_INT 1
24994: ARRAY
24995: IFFALSE 24999
// exit ;
24997: GO 25402
// height := hex [ 2 ] ;
24999: LD_ADDR_VAR 0 15
25003: PUSH
25004: LD_VAR 0 4
25008: PUSH
25009: LD_INT 2
25011: ARRAY
25012: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25013: LD_ADDR_VAR 0 14
25017: PUSH
25018: LD_INT 0
25020: PUSH
25021: LD_INT 2
25023: PUSH
25024: LD_INT 3
25026: PUSH
25027: LD_INT 5
25029: PUSH
25030: EMPTY
25031: LIST
25032: LIST
25033: LIST
25034: LIST
25035: ST_TO_ADDR
// for i in tmp do
25036: LD_ADDR_VAR 0 8
25040: PUSH
25041: LD_VAR 0 14
25045: PUSH
25046: FOR_IN
25047: IFFALSE 25217
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25049: LD_ADDR_VAR 0 9
25053: PUSH
25054: LD_VAR 0 10
25058: PPUSH
25059: LD_VAR 0 8
25063: PPUSH
25064: LD_INT 5
25066: PPUSH
25067: CALL_OW 272
25071: PUSH
25072: LD_VAR 0 11
25076: PPUSH
25077: LD_VAR 0 8
25081: PPUSH
25082: LD_INT 5
25084: PPUSH
25085: CALL_OW 273
25089: PUSH
25090: EMPTY
25091: LIST
25092: LIST
25093: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25094: LD_VAR 0 9
25098: PUSH
25099: LD_INT 1
25101: ARRAY
25102: PPUSH
25103: LD_VAR 0 9
25107: PUSH
25108: LD_INT 2
25110: ARRAY
25111: PPUSH
25112: CALL_OW 488
25116: IFFALSE 25215
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25118: LD_ADDR_VAR 0 4
25122: PUSH
25123: LD_VAR 0 9
25127: PUSH
25128: LD_INT 1
25130: ARRAY
25131: PPUSH
25132: LD_VAR 0 9
25136: PUSH
25137: LD_INT 2
25139: ARRAY
25140: PPUSH
25141: CALL_OW 546
25145: ST_TO_ADDR
// if hex [ 1 ] then
25146: LD_VAR 0 4
25150: PUSH
25151: LD_INT 1
25153: ARRAY
25154: IFFALSE 25158
// continue ;
25156: GO 25046
// h := hex [ 2 ] ;
25158: LD_ADDR_VAR 0 13
25162: PUSH
25163: LD_VAR 0 4
25167: PUSH
25168: LD_INT 2
25170: ARRAY
25171: ST_TO_ADDR
// if h + 7 < height then
25172: LD_VAR 0 13
25176: PUSH
25177: LD_INT 7
25179: PLUS
25180: PUSH
25181: LD_VAR 0 15
25185: LESS
25186: IFFALSE 25215
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25188: LD_ADDR_VAR 0 18
25192: PUSH
25193: LD_INT 7
25195: PUSH
25196: LD_INT 28
25198: PUSH
25199: LD_INT 45
25201: PUSH
25202: EMPTY
25203: LIST
25204: LIST
25205: LIST
25206: PUSH
25207: LD_VAR 0 12
25211: ARRAY
25212: ST_TO_ADDR
// break ;
25213: GO 25217
// end ; end ; end ;
25215: GO 25046
25217: POP
25218: POP
// end ; if not weapon then
25219: LD_VAR 0 18
25223: NOT
25224: IFFALSE 25284
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25226: LD_ADDR_VAR 0 5
25230: PUSH
25231: LD_VAR 0 5
25235: PUSH
25236: LD_INT 11
25238: PUSH
25239: LD_INT 30
25241: PUSH
25242: LD_INT 49
25244: PUSH
25245: EMPTY
25246: LIST
25247: LIST
25248: LIST
25249: DIFF
25250: ST_TO_ADDR
// if not list then
25251: LD_VAR 0 5
25255: NOT
25256: IFFALSE 25260
// exit ;
25258: GO 25402
// weapon := list [ rand ( 1 , list ) ] ;
25260: LD_ADDR_VAR 0 18
25264: PUSH
25265: LD_VAR 0 5
25269: PUSH
25270: LD_INT 1
25272: PPUSH
25273: LD_VAR 0 5
25277: PPUSH
25278: CALL_OW 12
25282: ARRAY
25283: ST_TO_ADDR
// end ; if weapon then
25284: LD_VAR 0 18
25288: IFFALSE 25402
// begin tmp := CostOfWeapon ( weapon ) ;
25290: LD_ADDR_VAR 0 14
25294: PUSH
25295: LD_VAR 0 18
25299: PPUSH
25300: CALL_OW 451
25304: ST_TO_ADDR
// j := GetBase ( tower ) ;
25305: LD_ADDR_VAR 0 9
25309: PUSH
25310: LD_VAR 0 1
25314: PPUSH
25315: CALL_OW 274
25319: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25320: LD_VAR 0 9
25324: PPUSH
25325: LD_INT 1
25327: PPUSH
25328: CALL_OW 275
25332: PUSH
25333: LD_VAR 0 14
25337: PUSH
25338: LD_INT 1
25340: ARRAY
25341: GREATEREQUAL
25342: PUSH
25343: LD_VAR 0 9
25347: PPUSH
25348: LD_INT 2
25350: PPUSH
25351: CALL_OW 275
25355: PUSH
25356: LD_VAR 0 14
25360: PUSH
25361: LD_INT 2
25363: ARRAY
25364: GREATEREQUAL
25365: AND
25366: PUSH
25367: LD_VAR 0 9
25371: PPUSH
25372: LD_INT 3
25374: PPUSH
25375: CALL_OW 275
25379: PUSH
25380: LD_VAR 0 14
25384: PUSH
25385: LD_INT 3
25387: ARRAY
25388: GREATEREQUAL
25389: AND
25390: IFFALSE 25402
// result := weapon ;
25392: LD_ADDR_VAR 0 3
25396: PUSH
25397: LD_VAR 0 18
25401: ST_TO_ADDR
// end ; end ;
25402: LD_VAR 0 3
25406: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25407: LD_INT 0
25409: PPUSH
25410: PPUSH
// result := true ;
25411: LD_ADDR_VAR 0 3
25415: PUSH
25416: LD_INT 1
25418: ST_TO_ADDR
// if array1 = array2 then
25419: LD_VAR 0 1
25423: PUSH
25424: LD_VAR 0 2
25428: EQUAL
25429: IFFALSE 25489
// begin for i = 1 to array1 do
25431: LD_ADDR_VAR 0 4
25435: PUSH
25436: DOUBLE
25437: LD_INT 1
25439: DEC
25440: ST_TO_ADDR
25441: LD_VAR 0 1
25445: PUSH
25446: FOR_TO
25447: IFFALSE 25485
// if array1 [ i ] <> array2 [ i ] then
25449: LD_VAR 0 1
25453: PUSH
25454: LD_VAR 0 4
25458: ARRAY
25459: PUSH
25460: LD_VAR 0 2
25464: PUSH
25465: LD_VAR 0 4
25469: ARRAY
25470: NONEQUAL
25471: IFFALSE 25483
// begin result := false ;
25473: LD_ADDR_VAR 0 3
25477: PUSH
25478: LD_INT 0
25480: ST_TO_ADDR
// break ;
25481: GO 25485
// end ;
25483: GO 25446
25485: POP
25486: POP
// end else
25487: GO 25497
// result := false ;
25489: LD_ADDR_VAR 0 3
25493: PUSH
25494: LD_INT 0
25496: ST_TO_ADDR
// end ;
25497: LD_VAR 0 3
25501: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25502: LD_INT 0
25504: PPUSH
25505: PPUSH
25506: PPUSH
// pom := GetBase ( fac ) ;
25507: LD_ADDR_VAR 0 5
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 274
25521: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 2
25531: PUSH
25532: LD_INT 1
25534: ARRAY
25535: PPUSH
25536: LD_VAR 0 2
25540: PUSH
25541: LD_INT 2
25543: ARRAY
25544: PPUSH
25545: LD_VAR 0 2
25549: PUSH
25550: LD_INT 3
25552: ARRAY
25553: PPUSH
25554: LD_VAR 0 2
25558: PUSH
25559: LD_INT 4
25561: ARRAY
25562: PPUSH
25563: CALL_OW 449
25567: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25568: LD_ADDR_VAR 0 3
25572: PUSH
25573: LD_VAR 0 5
25577: PPUSH
25578: LD_INT 1
25580: PPUSH
25581: CALL_OW 275
25585: PUSH
25586: LD_VAR 0 4
25590: PUSH
25591: LD_INT 1
25593: ARRAY
25594: GREATEREQUAL
25595: PUSH
25596: LD_VAR 0 5
25600: PPUSH
25601: LD_INT 2
25603: PPUSH
25604: CALL_OW 275
25608: PUSH
25609: LD_VAR 0 4
25613: PUSH
25614: LD_INT 2
25616: ARRAY
25617: GREATEREQUAL
25618: AND
25619: PUSH
25620: LD_VAR 0 5
25624: PPUSH
25625: LD_INT 3
25627: PPUSH
25628: CALL_OW 275
25632: PUSH
25633: LD_VAR 0 4
25637: PUSH
25638: LD_INT 3
25640: ARRAY
25641: GREATEREQUAL
25642: AND
25643: ST_TO_ADDR
// end ;
25644: LD_VAR 0 3
25648: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25649: LD_INT 0
25651: PPUSH
25652: PPUSH
25653: PPUSH
25654: PPUSH
// pom := GetBase ( building ) ;
25655: LD_ADDR_VAR 0 3
25659: PUSH
25660: LD_VAR 0 1
25664: PPUSH
25665: CALL_OW 274
25669: ST_TO_ADDR
// if not pom then
25670: LD_VAR 0 3
25674: NOT
25675: IFFALSE 25679
// exit ;
25677: GO 25849
// btype := GetBType ( building ) ;
25679: LD_ADDR_VAR 0 5
25683: PUSH
25684: LD_VAR 0 1
25688: PPUSH
25689: CALL_OW 266
25693: ST_TO_ADDR
// if btype = b_armoury then
25694: LD_VAR 0 5
25698: PUSH
25699: LD_INT 4
25701: EQUAL
25702: IFFALSE 25712
// btype := b_barracks ;
25704: LD_ADDR_VAR 0 5
25708: PUSH
25709: LD_INT 5
25711: ST_TO_ADDR
// if btype = b_depot then
25712: LD_VAR 0 5
25716: PUSH
25717: LD_INT 0
25719: EQUAL
25720: IFFALSE 25730
// btype := b_warehouse ;
25722: LD_ADDR_VAR 0 5
25726: PUSH
25727: LD_INT 1
25729: ST_TO_ADDR
// if btype = b_workshop then
25730: LD_VAR 0 5
25734: PUSH
25735: LD_INT 2
25737: EQUAL
25738: IFFALSE 25748
// btype := b_factory ;
25740: LD_ADDR_VAR 0 5
25744: PUSH
25745: LD_INT 3
25747: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25748: LD_ADDR_VAR 0 4
25752: PUSH
25753: LD_VAR 0 5
25757: PPUSH
25758: LD_VAR 0 1
25762: PPUSH
25763: CALL_OW 248
25767: PPUSH
25768: CALL_OW 450
25772: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25773: LD_ADDR_VAR 0 2
25777: PUSH
25778: LD_VAR 0 3
25782: PPUSH
25783: LD_INT 1
25785: PPUSH
25786: CALL_OW 275
25790: PUSH
25791: LD_VAR 0 4
25795: PUSH
25796: LD_INT 1
25798: ARRAY
25799: GREATEREQUAL
25800: PUSH
25801: LD_VAR 0 3
25805: PPUSH
25806: LD_INT 2
25808: PPUSH
25809: CALL_OW 275
25813: PUSH
25814: LD_VAR 0 4
25818: PUSH
25819: LD_INT 2
25821: ARRAY
25822: GREATEREQUAL
25823: AND
25824: PUSH
25825: LD_VAR 0 3
25829: PPUSH
25830: LD_INT 3
25832: PPUSH
25833: CALL_OW 275
25837: PUSH
25838: LD_VAR 0 4
25842: PUSH
25843: LD_INT 3
25845: ARRAY
25846: GREATEREQUAL
25847: AND
25848: ST_TO_ADDR
// end ;
25849: LD_VAR 0 2
25853: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25854: LD_INT 0
25856: PPUSH
25857: PPUSH
25858: PPUSH
// pom := GetBase ( building ) ;
25859: LD_ADDR_VAR 0 4
25863: PUSH
25864: LD_VAR 0 1
25868: PPUSH
25869: CALL_OW 274
25873: ST_TO_ADDR
// if not pom then
25874: LD_VAR 0 4
25878: NOT
25879: IFFALSE 25883
// exit ;
25881: GO 25984
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25883: LD_ADDR_VAR 0 5
25887: PUSH
25888: LD_VAR 0 2
25892: PPUSH
25893: LD_VAR 0 1
25897: PPUSH
25898: CALL_OW 248
25902: PPUSH
25903: CALL_OW 450
25907: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25908: LD_ADDR_VAR 0 3
25912: PUSH
25913: LD_VAR 0 4
25917: PPUSH
25918: LD_INT 1
25920: PPUSH
25921: CALL_OW 275
25925: PUSH
25926: LD_VAR 0 5
25930: PUSH
25931: LD_INT 1
25933: ARRAY
25934: GREATEREQUAL
25935: PUSH
25936: LD_VAR 0 4
25940: PPUSH
25941: LD_INT 2
25943: PPUSH
25944: CALL_OW 275
25948: PUSH
25949: LD_VAR 0 5
25953: PUSH
25954: LD_INT 2
25956: ARRAY
25957: GREATEREQUAL
25958: AND
25959: PUSH
25960: LD_VAR 0 4
25964: PPUSH
25965: LD_INT 3
25967: PPUSH
25968: CALL_OW 275
25972: PUSH
25973: LD_VAR 0 5
25977: PUSH
25978: LD_INT 3
25980: ARRAY
25981: GREATEREQUAL
25982: AND
25983: ST_TO_ADDR
// end ;
25984: LD_VAR 0 3
25988: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
25989: LD_INT 0
25991: PPUSH
25992: PPUSH
25993: PPUSH
25994: PPUSH
25995: PPUSH
25996: PPUSH
25997: PPUSH
25998: PPUSH
25999: PPUSH
26000: PPUSH
// result := false ;
26001: LD_ADDR_VAR 0 6
26005: PUSH
26006: LD_INT 0
26008: ST_TO_ADDR
// if not base or not btype or not x or not y then
26009: LD_VAR 0 1
26013: NOT
26014: PUSH
26015: LD_VAR 0 2
26019: NOT
26020: OR
26021: PUSH
26022: LD_VAR 0 3
26026: NOT
26027: OR
26028: PUSH
26029: LD_VAR 0 4
26033: NOT
26034: OR
26035: IFFALSE 26039
// exit ;
26037: GO 26648
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26039: LD_ADDR_VAR 0 12
26043: PUSH
26044: LD_VAR 0 2
26048: PPUSH
26049: LD_VAR 0 3
26053: PPUSH
26054: LD_VAR 0 4
26058: PPUSH
26059: LD_VAR 0 5
26063: PPUSH
26064: LD_VAR 0 1
26068: PUSH
26069: LD_INT 1
26071: ARRAY
26072: PPUSH
26073: CALL_OW 248
26077: PPUSH
26078: LD_INT 0
26080: PPUSH
26081: CALL 27485 0 6
26085: ST_TO_ADDR
// if not hexes then
26086: LD_VAR 0 12
26090: NOT
26091: IFFALSE 26095
// exit ;
26093: GO 26648
// for i = 1 to hexes do
26095: LD_ADDR_VAR 0 7
26099: PUSH
26100: DOUBLE
26101: LD_INT 1
26103: DEC
26104: ST_TO_ADDR
26105: LD_VAR 0 12
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26646
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26113: LD_ADDR_VAR 0 11
26117: PUSH
26118: LD_VAR 0 12
26122: PUSH
26123: LD_VAR 0 7
26127: ARRAY
26128: PUSH
26129: LD_INT 1
26131: ARRAY
26132: PPUSH
26133: LD_VAR 0 12
26137: PUSH
26138: LD_VAR 0 7
26142: ARRAY
26143: PUSH
26144: LD_INT 2
26146: ARRAY
26147: PPUSH
26148: CALL_OW 428
26152: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26153: LD_VAR 0 12
26157: PUSH
26158: LD_VAR 0 7
26162: ARRAY
26163: PUSH
26164: LD_INT 1
26166: ARRAY
26167: PPUSH
26168: LD_VAR 0 12
26172: PUSH
26173: LD_VAR 0 7
26177: ARRAY
26178: PUSH
26179: LD_INT 2
26181: ARRAY
26182: PPUSH
26183: CALL_OW 351
26187: PUSH
26188: LD_VAR 0 12
26192: PUSH
26193: LD_VAR 0 7
26197: ARRAY
26198: PUSH
26199: LD_INT 1
26201: ARRAY
26202: PPUSH
26203: LD_VAR 0 12
26207: PUSH
26208: LD_VAR 0 7
26212: ARRAY
26213: PUSH
26214: LD_INT 2
26216: ARRAY
26217: PPUSH
26218: CALL_OW 488
26222: NOT
26223: OR
26224: PUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 247
26234: PUSH
26235: LD_INT 3
26237: EQUAL
26238: OR
26239: IFFALSE 26245
// exit ;
26241: POP
26242: POP
26243: GO 26648
// if not tmp or not tmp in base then
26245: LD_VAR 0 11
26249: NOT
26250: PUSH
26251: LD_VAR 0 11
26255: PUSH
26256: LD_VAR 0 1
26260: IN
26261: NOT
26262: OR
26263: IFFALSE 26267
// continue ;
26265: GO 26110
// result := true ;
26267: LD_ADDR_VAR 0 6
26271: PUSH
26272: LD_INT 1
26274: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26275: LD_ADDR_VAR 0 15
26279: PUSH
26280: LD_VAR 0 1
26284: PPUSH
26285: LD_INT 22
26287: PUSH
26288: LD_VAR 0 11
26292: PPUSH
26293: CALL_OW 255
26297: PUSH
26298: EMPTY
26299: LIST
26300: LIST
26301: PUSH
26302: LD_INT 2
26304: PUSH
26305: LD_INT 30
26307: PUSH
26308: LD_INT 0
26310: PUSH
26311: EMPTY
26312: LIST
26313: LIST
26314: PUSH
26315: LD_INT 30
26317: PUSH
26318: LD_INT 1
26320: PUSH
26321: EMPTY
26322: LIST
26323: LIST
26324: PUSH
26325: EMPTY
26326: LIST
26327: LIST
26328: LIST
26329: PUSH
26330: EMPTY
26331: LIST
26332: LIST
26333: PPUSH
26334: CALL_OW 72
26338: ST_TO_ADDR
// if dep then
26339: LD_VAR 0 15
26343: IFFALSE 26479
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26345: LD_ADDR_VAR 0 14
26349: PUSH
26350: LD_VAR 0 15
26354: PUSH
26355: LD_INT 1
26357: ARRAY
26358: PPUSH
26359: CALL_OW 250
26363: PPUSH
26364: LD_VAR 0 15
26368: PUSH
26369: LD_INT 1
26371: ARRAY
26372: PPUSH
26373: CALL_OW 254
26377: PPUSH
26378: LD_INT 5
26380: PPUSH
26381: CALL_OW 272
26385: PUSH
26386: LD_VAR 0 15
26390: PUSH
26391: LD_INT 1
26393: ARRAY
26394: PPUSH
26395: CALL_OW 251
26399: PPUSH
26400: LD_VAR 0 15
26404: PUSH
26405: LD_INT 1
26407: ARRAY
26408: PPUSH
26409: CALL_OW 254
26413: PPUSH
26414: LD_INT 5
26416: PPUSH
26417: CALL_OW 273
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26426: LD_VAR 0 14
26430: PUSH
26431: LD_INT 1
26433: ARRAY
26434: PPUSH
26435: LD_VAR 0 14
26439: PUSH
26440: LD_INT 2
26442: ARRAY
26443: PPUSH
26444: CALL_OW 488
26448: IFFALSE 26479
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26450: LD_VAR 0 11
26454: PPUSH
26455: LD_VAR 0 14
26459: PUSH
26460: LD_INT 1
26462: ARRAY
26463: PPUSH
26464: LD_VAR 0 14
26468: PUSH
26469: LD_INT 2
26471: ARRAY
26472: PPUSH
26473: CALL_OW 111
// continue ;
26477: GO 26110
// end ; end ; r := GetDir ( tmp ) ;
26479: LD_ADDR_VAR 0 13
26483: PUSH
26484: LD_VAR 0 11
26488: PPUSH
26489: CALL_OW 254
26493: ST_TO_ADDR
// if r = 5 then
26494: LD_VAR 0 13
26498: PUSH
26499: LD_INT 5
26501: EQUAL
26502: IFFALSE 26512
// r := 0 ;
26504: LD_ADDR_VAR 0 13
26508: PUSH
26509: LD_INT 0
26511: ST_TO_ADDR
// for j = r to 5 do
26512: LD_ADDR_VAR 0 8
26516: PUSH
26517: DOUBLE
26518: LD_VAR 0 13
26522: DEC
26523: ST_TO_ADDR
26524: LD_INT 5
26526: PUSH
26527: FOR_TO
26528: IFFALSE 26642
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26530: LD_ADDR_VAR 0 9
26534: PUSH
26535: LD_VAR 0 11
26539: PPUSH
26540: CALL_OW 250
26544: PPUSH
26545: LD_VAR 0 8
26549: PPUSH
26550: LD_INT 2
26552: PPUSH
26553: CALL_OW 272
26557: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26558: LD_ADDR_VAR 0 10
26562: PUSH
26563: LD_VAR 0 11
26567: PPUSH
26568: CALL_OW 251
26572: PPUSH
26573: LD_VAR 0 8
26577: PPUSH
26578: LD_INT 2
26580: PPUSH
26581: CALL_OW 273
26585: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26586: LD_VAR 0 9
26590: PPUSH
26591: LD_VAR 0 10
26595: PPUSH
26596: CALL_OW 488
26600: PUSH
26601: LD_VAR 0 9
26605: PPUSH
26606: LD_VAR 0 10
26610: PPUSH
26611: CALL_OW 428
26615: NOT
26616: AND
26617: IFFALSE 26640
// begin ComMoveXY ( tmp , _x , _y ) ;
26619: LD_VAR 0 11
26623: PPUSH
26624: LD_VAR 0 9
26628: PPUSH
26629: LD_VAR 0 10
26633: PPUSH
26634: CALL_OW 111
// break ;
26638: GO 26642
// end ; end ;
26640: GO 26527
26642: POP
26643: POP
// end ;
26644: GO 26110
26646: POP
26647: POP
// end ;
26648: LD_VAR 0 6
26652: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26653: LD_INT 0
26655: PPUSH
26656: PPUSH
26657: PPUSH
26658: PPUSH
26659: PPUSH
26660: PPUSH
26661: PPUSH
26662: PPUSH
26663: PPUSH
26664: PPUSH
// result := false ;
26665: LD_ADDR_VAR 0 6
26669: PUSH
26670: LD_INT 0
26672: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26673: LD_VAR 0 1
26677: NOT
26678: PUSH
26679: LD_VAR 0 1
26683: PPUSH
26684: CALL_OW 266
26688: PUSH
26689: LD_INT 0
26691: PUSH
26692: LD_INT 1
26694: PUSH
26695: EMPTY
26696: LIST
26697: LIST
26698: IN
26699: NOT
26700: OR
26701: PUSH
26702: LD_VAR 0 2
26706: NOT
26707: OR
26708: PUSH
26709: LD_VAR 0 5
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 1
26719: PUSH
26720: LD_INT 2
26722: PUSH
26723: LD_INT 3
26725: PUSH
26726: LD_INT 4
26728: PUSH
26729: LD_INT 5
26731: PUSH
26732: EMPTY
26733: LIST
26734: LIST
26735: LIST
26736: LIST
26737: LIST
26738: LIST
26739: IN
26740: NOT
26741: OR
26742: PUSH
26743: LD_VAR 0 3
26747: PPUSH
26748: LD_VAR 0 4
26752: PPUSH
26753: CALL_OW 488
26757: NOT
26758: OR
26759: IFFALSE 26763
// exit ;
26761: GO 27480
// pom := GetBase ( depot ) ;
26763: LD_ADDR_VAR 0 10
26767: PUSH
26768: LD_VAR 0 1
26772: PPUSH
26773: CALL_OW 274
26777: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26778: LD_ADDR_VAR 0 11
26782: PUSH
26783: LD_VAR 0 2
26787: PPUSH
26788: LD_VAR 0 1
26792: PPUSH
26793: CALL_OW 248
26797: PPUSH
26798: CALL_OW 450
26802: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26803: LD_VAR 0 10
26807: PPUSH
26808: LD_INT 1
26810: PPUSH
26811: CALL_OW 275
26815: PUSH
26816: LD_VAR 0 11
26820: PUSH
26821: LD_INT 1
26823: ARRAY
26824: GREATEREQUAL
26825: PUSH
26826: LD_VAR 0 10
26830: PPUSH
26831: LD_INT 2
26833: PPUSH
26834: CALL_OW 275
26838: PUSH
26839: LD_VAR 0 11
26843: PUSH
26844: LD_INT 2
26846: ARRAY
26847: GREATEREQUAL
26848: AND
26849: PUSH
26850: LD_VAR 0 10
26854: PPUSH
26855: LD_INT 3
26857: PPUSH
26858: CALL_OW 275
26862: PUSH
26863: LD_VAR 0 11
26867: PUSH
26868: LD_INT 3
26870: ARRAY
26871: GREATEREQUAL
26872: AND
26873: NOT
26874: IFFALSE 26878
// exit ;
26876: GO 27480
// if GetBType ( depot ) = b_depot then
26878: LD_VAR 0 1
26882: PPUSH
26883: CALL_OW 266
26887: PUSH
26888: LD_INT 0
26890: EQUAL
26891: IFFALSE 26903
// dist := 28 else
26893: LD_ADDR_VAR 0 14
26897: PUSH
26898: LD_INT 28
26900: ST_TO_ADDR
26901: GO 26911
// dist := 36 ;
26903: LD_ADDR_VAR 0 14
26907: PUSH
26908: LD_INT 36
26910: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26911: LD_VAR 0 1
26915: PPUSH
26916: LD_VAR 0 3
26920: PPUSH
26921: LD_VAR 0 4
26925: PPUSH
26926: CALL_OW 297
26930: PUSH
26931: LD_VAR 0 14
26935: GREATER
26936: IFFALSE 26940
// exit ;
26938: GO 27480
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26940: LD_ADDR_VAR 0 12
26944: PUSH
26945: LD_VAR 0 2
26949: PPUSH
26950: LD_VAR 0 3
26954: PPUSH
26955: LD_VAR 0 4
26959: PPUSH
26960: LD_VAR 0 5
26964: PPUSH
26965: LD_VAR 0 1
26969: PPUSH
26970: CALL_OW 248
26974: PPUSH
26975: LD_INT 0
26977: PPUSH
26978: CALL 27485 0 6
26982: ST_TO_ADDR
// if not hexes then
26983: LD_VAR 0 12
26987: NOT
26988: IFFALSE 26992
// exit ;
26990: GO 27480
// hex := GetHexInfo ( x , y ) ;
26992: LD_ADDR_VAR 0 15
26996: PUSH
26997: LD_VAR 0 3
27001: PPUSH
27002: LD_VAR 0 4
27006: PPUSH
27007: CALL_OW 546
27011: ST_TO_ADDR
// if hex [ 1 ] then
27012: LD_VAR 0 15
27016: PUSH
27017: LD_INT 1
27019: ARRAY
27020: IFFALSE 27024
// exit ;
27022: GO 27480
// height := hex [ 2 ] ;
27024: LD_ADDR_VAR 0 13
27028: PUSH
27029: LD_VAR 0 15
27033: PUSH
27034: LD_INT 2
27036: ARRAY
27037: ST_TO_ADDR
// for i = 1 to hexes do
27038: LD_ADDR_VAR 0 7
27042: PUSH
27043: DOUBLE
27044: LD_INT 1
27046: DEC
27047: ST_TO_ADDR
27048: LD_VAR 0 12
27052: PUSH
27053: FOR_TO
27054: IFFALSE 27384
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27056: LD_VAR 0 12
27060: PUSH
27061: LD_VAR 0 7
27065: ARRAY
27066: PUSH
27067: LD_INT 1
27069: ARRAY
27070: PPUSH
27071: LD_VAR 0 12
27075: PUSH
27076: LD_VAR 0 7
27080: ARRAY
27081: PUSH
27082: LD_INT 2
27084: ARRAY
27085: PPUSH
27086: CALL_OW 488
27090: NOT
27091: PUSH
27092: LD_VAR 0 12
27096: PUSH
27097: LD_VAR 0 7
27101: ARRAY
27102: PUSH
27103: LD_INT 1
27105: ARRAY
27106: PPUSH
27107: LD_VAR 0 12
27111: PUSH
27112: LD_VAR 0 7
27116: ARRAY
27117: PUSH
27118: LD_INT 2
27120: ARRAY
27121: PPUSH
27122: CALL_OW 428
27126: PUSH
27127: LD_INT 0
27129: GREATER
27130: OR
27131: PUSH
27132: LD_VAR 0 12
27136: PUSH
27137: LD_VAR 0 7
27141: ARRAY
27142: PUSH
27143: LD_INT 1
27145: ARRAY
27146: PPUSH
27147: LD_VAR 0 12
27151: PUSH
27152: LD_VAR 0 7
27156: ARRAY
27157: PUSH
27158: LD_INT 2
27160: ARRAY
27161: PPUSH
27162: CALL_OW 351
27166: OR
27167: IFFALSE 27173
// exit ;
27169: POP
27170: POP
27171: GO 27480
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27173: LD_ADDR_VAR 0 8
27177: PUSH
27178: LD_VAR 0 12
27182: PUSH
27183: LD_VAR 0 7
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_VAR 0 12
27197: PUSH
27198: LD_VAR 0 7
27202: ARRAY
27203: PUSH
27204: LD_INT 2
27206: ARRAY
27207: PPUSH
27208: CALL_OW 546
27212: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27213: LD_VAR 0 8
27217: PUSH
27218: LD_INT 1
27220: ARRAY
27221: PUSH
27222: LD_VAR 0 8
27226: PUSH
27227: LD_INT 2
27229: ARRAY
27230: PUSH
27231: LD_VAR 0 13
27235: PUSH
27236: LD_INT 2
27238: PLUS
27239: GREATER
27240: OR
27241: PUSH
27242: LD_VAR 0 8
27246: PUSH
27247: LD_INT 2
27249: ARRAY
27250: PUSH
27251: LD_VAR 0 13
27255: PUSH
27256: LD_INT 2
27258: MINUS
27259: LESS
27260: OR
27261: PUSH
27262: LD_VAR 0 8
27266: PUSH
27267: LD_INT 3
27269: ARRAY
27270: PUSH
27271: LD_INT 0
27273: PUSH
27274: LD_INT 8
27276: PUSH
27277: LD_INT 9
27279: PUSH
27280: LD_INT 10
27282: PUSH
27283: LD_INT 11
27285: PUSH
27286: LD_INT 12
27288: PUSH
27289: LD_INT 13
27291: PUSH
27292: LD_INT 16
27294: PUSH
27295: LD_INT 17
27297: PUSH
27298: LD_INT 18
27300: PUSH
27301: LD_INT 19
27303: PUSH
27304: LD_INT 20
27306: PUSH
27307: LD_INT 21
27309: PUSH
27310: EMPTY
27311: LIST
27312: LIST
27313: LIST
27314: LIST
27315: LIST
27316: LIST
27317: LIST
27318: LIST
27319: LIST
27320: LIST
27321: LIST
27322: LIST
27323: LIST
27324: IN
27325: NOT
27326: OR
27327: PUSH
27328: LD_VAR 0 8
27332: PUSH
27333: LD_INT 5
27335: ARRAY
27336: NOT
27337: OR
27338: PUSH
27339: LD_VAR 0 8
27343: PUSH
27344: LD_INT 6
27346: ARRAY
27347: PUSH
27348: LD_INT 1
27350: PUSH
27351: LD_INT 2
27353: PUSH
27354: LD_INT 7
27356: PUSH
27357: LD_INT 9
27359: PUSH
27360: LD_INT 10
27362: PUSH
27363: LD_INT 11
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: LIST
27370: LIST
27371: LIST
27372: LIST
27373: IN
27374: NOT
27375: OR
27376: IFFALSE 27382
// exit ;
27378: POP
27379: POP
27380: GO 27480
// end ;
27382: GO 27053
27384: POP
27385: POP
// side := GetSide ( depot ) ;
27386: LD_ADDR_VAR 0 9
27390: PUSH
27391: LD_VAR 0 1
27395: PPUSH
27396: CALL_OW 255
27400: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27401: LD_VAR 0 9
27405: PPUSH
27406: LD_VAR 0 3
27410: PPUSH
27411: LD_VAR 0 4
27415: PPUSH
27416: LD_INT 20
27418: PPUSH
27419: CALL 20134 0 4
27423: PUSH
27424: LD_INT 4
27426: ARRAY
27427: IFFALSE 27431
// exit ;
27429: GO 27480
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27431: LD_VAR 0 2
27435: PUSH
27436: LD_INT 29
27438: PUSH
27439: LD_INT 30
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: IN
27446: PUSH
27447: LD_VAR 0 3
27451: PPUSH
27452: LD_VAR 0 4
27456: PPUSH
27457: LD_VAR 0 9
27461: PPUSH
27462: CALL_OW 440
27466: NOT
27467: AND
27468: IFFALSE 27472
// exit ;
27470: GO 27480
// result := true ;
27472: LD_ADDR_VAR 0 6
27476: PUSH
27477: LD_INT 1
27479: ST_TO_ADDR
// end ;
27480: LD_VAR 0 6
27484: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
27485: LD_INT 0
27487: PPUSH
27488: PPUSH
27489: PPUSH
27490: PPUSH
27491: PPUSH
27492: PPUSH
27493: PPUSH
27494: PPUSH
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
27503: PPUSH
27504: PPUSH
27505: PPUSH
27506: PPUSH
27507: PPUSH
27508: PPUSH
27509: PPUSH
27510: PPUSH
27511: PPUSH
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
27532: PPUSH
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
// result = [ ] ;
27545: LD_ADDR_VAR 0 7
27549: PUSH
27550: EMPTY
27551: ST_TO_ADDR
// temp_list = [ ] ;
27552: LD_ADDR_VAR 0 9
27556: PUSH
27557: EMPTY
27558: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27559: LD_VAR 0 4
27563: PUSH
27564: LD_INT 0
27566: PUSH
27567: LD_INT 1
27569: PUSH
27570: LD_INT 2
27572: PUSH
27573: LD_INT 3
27575: PUSH
27576: LD_INT 4
27578: PUSH
27579: LD_INT 5
27581: PUSH
27582: EMPTY
27583: LIST
27584: LIST
27585: LIST
27586: LIST
27587: LIST
27588: LIST
27589: IN
27590: NOT
27591: PUSH
27592: LD_VAR 0 1
27596: PUSH
27597: LD_INT 0
27599: PUSH
27600: LD_INT 1
27602: PUSH
27603: EMPTY
27604: LIST
27605: LIST
27606: IN
27607: PUSH
27608: LD_VAR 0 5
27612: PUSH
27613: LD_INT 1
27615: PUSH
27616: LD_INT 2
27618: PUSH
27619: LD_INT 3
27621: PUSH
27622: EMPTY
27623: LIST
27624: LIST
27625: LIST
27626: IN
27627: NOT
27628: AND
27629: OR
27630: IFFALSE 27634
// exit ;
27632: GO 46025
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27634: LD_VAR 0 1
27638: PUSH
27639: LD_INT 6
27641: PUSH
27642: LD_INT 7
27644: PUSH
27645: LD_INT 8
27647: PUSH
27648: LD_INT 13
27650: PUSH
27651: LD_INT 12
27653: PUSH
27654: LD_INT 15
27656: PUSH
27657: LD_INT 11
27659: PUSH
27660: LD_INT 14
27662: PUSH
27663: LD_INT 10
27665: PUSH
27666: EMPTY
27667: LIST
27668: LIST
27669: LIST
27670: LIST
27671: LIST
27672: LIST
27673: LIST
27674: LIST
27675: LIST
27676: IN
27677: IFFALSE 27687
// btype = b_lab ;
27679: LD_ADDR_VAR 0 1
27683: PUSH
27684: LD_INT 6
27686: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27687: LD_VAR 0 6
27691: PUSH
27692: LD_INT 0
27694: PUSH
27695: LD_INT 1
27697: PUSH
27698: LD_INT 2
27700: PUSH
27701: EMPTY
27702: LIST
27703: LIST
27704: LIST
27705: IN
27706: NOT
27707: PUSH
27708: LD_VAR 0 1
27712: PUSH
27713: LD_INT 0
27715: PUSH
27716: LD_INT 1
27718: PUSH
27719: LD_INT 2
27721: PUSH
27722: LD_INT 3
27724: PUSH
27725: LD_INT 6
27727: PUSH
27728: LD_INT 36
27730: PUSH
27731: LD_INT 4
27733: PUSH
27734: LD_INT 5
27736: PUSH
27737: LD_INT 31
27739: PUSH
27740: LD_INT 32
27742: PUSH
27743: LD_INT 33
27745: PUSH
27746: EMPTY
27747: LIST
27748: LIST
27749: LIST
27750: LIST
27751: LIST
27752: LIST
27753: LIST
27754: LIST
27755: LIST
27756: LIST
27757: LIST
27758: IN
27759: NOT
27760: PUSH
27761: LD_VAR 0 6
27765: PUSH
27766: LD_INT 1
27768: EQUAL
27769: AND
27770: OR
27771: PUSH
27772: LD_VAR 0 1
27776: PUSH
27777: LD_INT 2
27779: PUSH
27780: LD_INT 3
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: IN
27787: NOT
27788: PUSH
27789: LD_VAR 0 6
27793: PUSH
27794: LD_INT 2
27796: EQUAL
27797: AND
27798: OR
27799: IFFALSE 27809
// mode = 0 ;
27801: LD_ADDR_VAR 0 6
27805: PUSH
27806: LD_INT 0
27808: ST_TO_ADDR
// case mode of 0 :
27809: LD_VAR 0 6
27813: PUSH
27814: LD_INT 0
27816: DOUBLE
27817: EQUAL
27818: IFTRUE 27822
27820: GO 39275
27822: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27823: LD_ADDR_VAR 0 11
27827: PUSH
27828: LD_INT 0
27830: PUSH
27831: LD_INT 0
27833: PUSH
27834: EMPTY
27835: LIST
27836: LIST
27837: PUSH
27838: LD_INT 0
27840: PUSH
27841: LD_INT 1
27843: NEG
27844: PUSH
27845: EMPTY
27846: LIST
27847: LIST
27848: PUSH
27849: LD_INT 1
27851: PUSH
27852: LD_INT 0
27854: PUSH
27855: EMPTY
27856: LIST
27857: LIST
27858: PUSH
27859: LD_INT 1
27861: PUSH
27862: LD_INT 1
27864: PUSH
27865: EMPTY
27866: LIST
27867: LIST
27868: PUSH
27869: LD_INT 0
27871: PUSH
27872: LD_INT 1
27874: PUSH
27875: EMPTY
27876: LIST
27877: LIST
27878: PUSH
27879: LD_INT 1
27881: NEG
27882: PUSH
27883: LD_INT 0
27885: PUSH
27886: EMPTY
27887: LIST
27888: LIST
27889: PUSH
27890: LD_INT 1
27892: NEG
27893: PUSH
27894: LD_INT 1
27896: NEG
27897: PUSH
27898: EMPTY
27899: LIST
27900: LIST
27901: PUSH
27902: LD_INT 1
27904: NEG
27905: PUSH
27906: LD_INT 2
27908: NEG
27909: PUSH
27910: EMPTY
27911: LIST
27912: LIST
27913: PUSH
27914: LD_INT 0
27916: PUSH
27917: LD_INT 2
27919: NEG
27920: PUSH
27921: EMPTY
27922: LIST
27923: LIST
27924: PUSH
27925: LD_INT 1
27927: PUSH
27928: LD_INT 1
27930: NEG
27931: PUSH
27932: EMPTY
27933: LIST
27934: LIST
27935: PUSH
27936: LD_INT 1
27938: PUSH
27939: LD_INT 2
27941: PUSH
27942: EMPTY
27943: LIST
27944: LIST
27945: PUSH
27946: LD_INT 0
27948: PUSH
27949: LD_INT 2
27951: PUSH
27952: EMPTY
27953: LIST
27954: LIST
27955: PUSH
27956: LD_INT 1
27958: NEG
27959: PUSH
27960: LD_INT 1
27962: PUSH
27963: EMPTY
27964: LIST
27965: LIST
27966: PUSH
27967: LD_INT 1
27969: PUSH
27970: LD_INT 3
27972: PUSH
27973: EMPTY
27974: LIST
27975: LIST
27976: PUSH
27977: LD_INT 0
27979: PUSH
27980: LD_INT 3
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 1
27989: NEG
27990: PUSH
27991: LD_INT 2
27993: PUSH
27994: EMPTY
27995: LIST
27996: LIST
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: LIST
28002: LIST
28003: LIST
28004: LIST
28005: LIST
28006: LIST
28007: LIST
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: LIST
28013: LIST
28014: LIST
28015: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28016: LD_ADDR_VAR 0 12
28020: PUSH
28021: LD_INT 0
28023: PUSH
28024: LD_INT 0
28026: PUSH
28027: EMPTY
28028: LIST
28029: LIST
28030: PUSH
28031: LD_INT 0
28033: PUSH
28034: LD_INT 1
28036: NEG
28037: PUSH
28038: EMPTY
28039: LIST
28040: LIST
28041: PUSH
28042: LD_INT 1
28044: PUSH
28045: LD_INT 0
28047: PUSH
28048: EMPTY
28049: LIST
28050: LIST
28051: PUSH
28052: LD_INT 1
28054: PUSH
28055: LD_INT 1
28057: PUSH
28058: EMPTY
28059: LIST
28060: LIST
28061: PUSH
28062: LD_INT 0
28064: PUSH
28065: LD_INT 1
28067: PUSH
28068: EMPTY
28069: LIST
28070: LIST
28071: PUSH
28072: LD_INT 1
28074: NEG
28075: PUSH
28076: LD_INT 0
28078: PUSH
28079: EMPTY
28080: LIST
28081: LIST
28082: PUSH
28083: LD_INT 1
28085: NEG
28086: PUSH
28087: LD_INT 1
28089: NEG
28090: PUSH
28091: EMPTY
28092: LIST
28093: LIST
28094: PUSH
28095: LD_INT 1
28097: PUSH
28098: LD_INT 1
28100: NEG
28101: PUSH
28102: EMPTY
28103: LIST
28104: LIST
28105: PUSH
28106: LD_INT 2
28108: PUSH
28109: LD_INT 0
28111: PUSH
28112: EMPTY
28113: LIST
28114: LIST
28115: PUSH
28116: LD_INT 2
28118: PUSH
28119: LD_INT 1
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PUSH
28126: LD_INT 1
28128: NEG
28129: PUSH
28130: LD_INT 1
28132: PUSH
28133: EMPTY
28134: LIST
28135: LIST
28136: PUSH
28137: LD_INT 2
28139: NEG
28140: PUSH
28141: LD_INT 0
28143: PUSH
28144: EMPTY
28145: LIST
28146: LIST
28147: PUSH
28148: LD_INT 2
28150: NEG
28151: PUSH
28152: LD_INT 1
28154: NEG
28155: PUSH
28156: EMPTY
28157: LIST
28158: LIST
28159: PUSH
28160: LD_INT 2
28162: NEG
28163: PUSH
28164: LD_INT 1
28166: PUSH
28167: EMPTY
28168: LIST
28169: LIST
28170: PUSH
28171: LD_INT 3
28173: NEG
28174: PUSH
28175: LD_INT 0
28177: PUSH
28178: EMPTY
28179: LIST
28180: LIST
28181: PUSH
28182: LD_INT 3
28184: NEG
28185: PUSH
28186: LD_INT 1
28188: NEG
28189: PUSH
28190: EMPTY
28191: LIST
28192: LIST
28193: PUSH
28194: EMPTY
28195: LIST
28196: LIST
28197: LIST
28198: LIST
28199: LIST
28200: LIST
28201: LIST
28202: LIST
28203: LIST
28204: LIST
28205: LIST
28206: LIST
28207: LIST
28208: LIST
28209: LIST
28210: LIST
28211: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28212: LD_ADDR_VAR 0 13
28216: PUSH
28217: LD_INT 0
28219: PUSH
28220: LD_INT 0
28222: PUSH
28223: EMPTY
28224: LIST
28225: LIST
28226: PUSH
28227: LD_INT 0
28229: PUSH
28230: LD_INT 1
28232: NEG
28233: PUSH
28234: EMPTY
28235: LIST
28236: LIST
28237: PUSH
28238: LD_INT 1
28240: PUSH
28241: LD_INT 0
28243: PUSH
28244: EMPTY
28245: LIST
28246: LIST
28247: PUSH
28248: LD_INT 1
28250: PUSH
28251: LD_INT 1
28253: PUSH
28254: EMPTY
28255: LIST
28256: LIST
28257: PUSH
28258: LD_INT 0
28260: PUSH
28261: LD_INT 1
28263: PUSH
28264: EMPTY
28265: LIST
28266: LIST
28267: PUSH
28268: LD_INT 1
28270: NEG
28271: PUSH
28272: LD_INT 0
28274: PUSH
28275: EMPTY
28276: LIST
28277: LIST
28278: PUSH
28279: LD_INT 1
28281: NEG
28282: PUSH
28283: LD_INT 1
28285: NEG
28286: PUSH
28287: EMPTY
28288: LIST
28289: LIST
28290: PUSH
28291: LD_INT 1
28293: NEG
28294: PUSH
28295: LD_INT 2
28297: NEG
28298: PUSH
28299: EMPTY
28300: LIST
28301: LIST
28302: PUSH
28303: LD_INT 2
28305: PUSH
28306: LD_INT 1
28308: PUSH
28309: EMPTY
28310: LIST
28311: LIST
28312: PUSH
28313: LD_INT 2
28315: PUSH
28316: LD_INT 2
28318: PUSH
28319: EMPTY
28320: LIST
28321: LIST
28322: PUSH
28323: LD_INT 1
28325: PUSH
28326: LD_INT 2
28328: PUSH
28329: EMPTY
28330: LIST
28331: LIST
28332: PUSH
28333: LD_INT 2
28335: NEG
28336: PUSH
28337: LD_INT 1
28339: NEG
28340: PUSH
28341: EMPTY
28342: LIST
28343: LIST
28344: PUSH
28345: LD_INT 2
28347: NEG
28348: PUSH
28349: LD_INT 2
28351: NEG
28352: PUSH
28353: EMPTY
28354: LIST
28355: LIST
28356: PUSH
28357: LD_INT 2
28359: NEG
28360: PUSH
28361: LD_INT 3
28363: NEG
28364: PUSH
28365: EMPTY
28366: LIST
28367: LIST
28368: PUSH
28369: LD_INT 3
28371: NEG
28372: PUSH
28373: LD_INT 2
28375: NEG
28376: PUSH
28377: EMPTY
28378: LIST
28379: LIST
28380: PUSH
28381: LD_INT 3
28383: NEG
28384: PUSH
28385: LD_INT 3
28387: NEG
28388: PUSH
28389: EMPTY
28390: LIST
28391: LIST
28392: PUSH
28393: EMPTY
28394: LIST
28395: LIST
28396: LIST
28397: LIST
28398: LIST
28399: LIST
28400: LIST
28401: LIST
28402: LIST
28403: LIST
28404: LIST
28405: LIST
28406: LIST
28407: LIST
28408: LIST
28409: LIST
28410: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28411: LD_ADDR_VAR 0 14
28415: PUSH
28416: LD_INT 0
28418: PUSH
28419: LD_INT 0
28421: PUSH
28422: EMPTY
28423: LIST
28424: LIST
28425: PUSH
28426: LD_INT 0
28428: PUSH
28429: LD_INT 1
28431: NEG
28432: PUSH
28433: EMPTY
28434: LIST
28435: LIST
28436: PUSH
28437: LD_INT 1
28439: PUSH
28440: LD_INT 0
28442: PUSH
28443: EMPTY
28444: LIST
28445: LIST
28446: PUSH
28447: LD_INT 1
28449: PUSH
28450: LD_INT 1
28452: PUSH
28453: EMPTY
28454: LIST
28455: LIST
28456: PUSH
28457: LD_INT 0
28459: PUSH
28460: LD_INT 1
28462: PUSH
28463: EMPTY
28464: LIST
28465: LIST
28466: PUSH
28467: LD_INT 1
28469: NEG
28470: PUSH
28471: LD_INT 0
28473: PUSH
28474: EMPTY
28475: LIST
28476: LIST
28477: PUSH
28478: LD_INT 1
28480: NEG
28481: PUSH
28482: LD_INT 1
28484: NEG
28485: PUSH
28486: EMPTY
28487: LIST
28488: LIST
28489: PUSH
28490: LD_INT 1
28492: NEG
28493: PUSH
28494: LD_INT 2
28496: NEG
28497: PUSH
28498: EMPTY
28499: LIST
28500: LIST
28501: PUSH
28502: LD_INT 0
28504: PUSH
28505: LD_INT 2
28507: NEG
28508: PUSH
28509: EMPTY
28510: LIST
28511: LIST
28512: PUSH
28513: LD_INT 1
28515: PUSH
28516: LD_INT 1
28518: NEG
28519: PUSH
28520: EMPTY
28521: LIST
28522: LIST
28523: PUSH
28524: LD_INT 1
28526: PUSH
28527: LD_INT 2
28529: PUSH
28530: EMPTY
28531: LIST
28532: LIST
28533: PUSH
28534: LD_INT 0
28536: PUSH
28537: LD_INT 2
28539: PUSH
28540: EMPTY
28541: LIST
28542: LIST
28543: PUSH
28544: LD_INT 1
28546: NEG
28547: PUSH
28548: LD_INT 1
28550: PUSH
28551: EMPTY
28552: LIST
28553: LIST
28554: PUSH
28555: LD_INT 1
28557: NEG
28558: PUSH
28559: LD_INT 3
28561: NEG
28562: PUSH
28563: EMPTY
28564: LIST
28565: LIST
28566: PUSH
28567: LD_INT 0
28569: PUSH
28570: LD_INT 3
28572: NEG
28573: PUSH
28574: EMPTY
28575: LIST
28576: LIST
28577: PUSH
28578: LD_INT 1
28580: PUSH
28581: LD_INT 2
28583: NEG
28584: PUSH
28585: EMPTY
28586: LIST
28587: LIST
28588: PUSH
28589: EMPTY
28590: LIST
28591: LIST
28592: LIST
28593: LIST
28594: LIST
28595: LIST
28596: LIST
28597: LIST
28598: LIST
28599: LIST
28600: LIST
28601: LIST
28602: LIST
28603: LIST
28604: LIST
28605: LIST
28606: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28607: LD_ADDR_VAR 0 15
28611: PUSH
28612: LD_INT 0
28614: PUSH
28615: LD_INT 0
28617: PUSH
28618: EMPTY
28619: LIST
28620: LIST
28621: PUSH
28622: LD_INT 0
28624: PUSH
28625: LD_INT 1
28627: NEG
28628: PUSH
28629: EMPTY
28630: LIST
28631: LIST
28632: PUSH
28633: LD_INT 1
28635: PUSH
28636: LD_INT 0
28638: PUSH
28639: EMPTY
28640: LIST
28641: LIST
28642: PUSH
28643: LD_INT 1
28645: PUSH
28646: LD_INT 1
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: PUSH
28653: LD_INT 0
28655: PUSH
28656: LD_INT 1
28658: PUSH
28659: EMPTY
28660: LIST
28661: LIST
28662: PUSH
28663: LD_INT 1
28665: NEG
28666: PUSH
28667: LD_INT 0
28669: PUSH
28670: EMPTY
28671: LIST
28672: LIST
28673: PUSH
28674: LD_INT 1
28676: NEG
28677: PUSH
28678: LD_INT 1
28680: NEG
28681: PUSH
28682: EMPTY
28683: LIST
28684: LIST
28685: PUSH
28686: LD_INT 1
28688: PUSH
28689: LD_INT 1
28691: NEG
28692: PUSH
28693: EMPTY
28694: LIST
28695: LIST
28696: PUSH
28697: LD_INT 2
28699: PUSH
28700: LD_INT 0
28702: PUSH
28703: EMPTY
28704: LIST
28705: LIST
28706: PUSH
28707: LD_INT 2
28709: PUSH
28710: LD_INT 1
28712: PUSH
28713: EMPTY
28714: LIST
28715: LIST
28716: PUSH
28717: LD_INT 1
28719: NEG
28720: PUSH
28721: LD_INT 1
28723: PUSH
28724: EMPTY
28725: LIST
28726: LIST
28727: PUSH
28728: LD_INT 2
28730: NEG
28731: PUSH
28732: LD_INT 0
28734: PUSH
28735: EMPTY
28736: LIST
28737: LIST
28738: PUSH
28739: LD_INT 2
28741: NEG
28742: PUSH
28743: LD_INT 1
28745: NEG
28746: PUSH
28747: EMPTY
28748: LIST
28749: LIST
28750: PUSH
28751: LD_INT 2
28753: PUSH
28754: LD_INT 1
28756: NEG
28757: PUSH
28758: EMPTY
28759: LIST
28760: LIST
28761: PUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 0
28767: PUSH
28768: EMPTY
28769: LIST
28770: LIST
28771: PUSH
28772: LD_INT 3
28774: PUSH
28775: LD_INT 1
28777: PUSH
28778: EMPTY
28779: LIST
28780: LIST
28781: PUSH
28782: EMPTY
28783: LIST
28784: LIST
28785: LIST
28786: LIST
28787: LIST
28788: LIST
28789: LIST
28790: LIST
28791: LIST
28792: LIST
28793: LIST
28794: LIST
28795: LIST
28796: LIST
28797: LIST
28798: LIST
28799: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28800: LD_ADDR_VAR 0 16
28804: PUSH
28805: LD_INT 0
28807: PUSH
28808: LD_INT 0
28810: PUSH
28811: EMPTY
28812: LIST
28813: LIST
28814: PUSH
28815: LD_INT 0
28817: PUSH
28818: LD_INT 1
28820: NEG
28821: PUSH
28822: EMPTY
28823: LIST
28824: LIST
28825: PUSH
28826: LD_INT 1
28828: PUSH
28829: LD_INT 0
28831: PUSH
28832: EMPTY
28833: LIST
28834: LIST
28835: PUSH
28836: LD_INT 1
28838: PUSH
28839: LD_INT 1
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: PUSH
28846: LD_INT 0
28848: PUSH
28849: LD_INT 1
28851: PUSH
28852: EMPTY
28853: LIST
28854: LIST
28855: PUSH
28856: LD_INT 1
28858: NEG
28859: PUSH
28860: LD_INT 0
28862: PUSH
28863: EMPTY
28864: LIST
28865: LIST
28866: PUSH
28867: LD_INT 1
28869: NEG
28870: PUSH
28871: LD_INT 1
28873: NEG
28874: PUSH
28875: EMPTY
28876: LIST
28877: LIST
28878: PUSH
28879: LD_INT 1
28881: NEG
28882: PUSH
28883: LD_INT 2
28885: NEG
28886: PUSH
28887: EMPTY
28888: LIST
28889: LIST
28890: PUSH
28891: LD_INT 2
28893: PUSH
28894: LD_INT 1
28896: PUSH
28897: EMPTY
28898: LIST
28899: LIST
28900: PUSH
28901: LD_INT 2
28903: PUSH
28904: LD_INT 2
28906: PUSH
28907: EMPTY
28908: LIST
28909: LIST
28910: PUSH
28911: LD_INT 1
28913: PUSH
28914: LD_INT 2
28916: PUSH
28917: EMPTY
28918: LIST
28919: LIST
28920: PUSH
28921: LD_INT 2
28923: NEG
28924: PUSH
28925: LD_INT 1
28927: NEG
28928: PUSH
28929: EMPTY
28930: LIST
28931: LIST
28932: PUSH
28933: LD_INT 2
28935: NEG
28936: PUSH
28937: LD_INT 2
28939: NEG
28940: PUSH
28941: EMPTY
28942: LIST
28943: LIST
28944: PUSH
28945: LD_INT 3
28947: PUSH
28948: LD_INT 2
28950: PUSH
28951: EMPTY
28952: LIST
28953: LIST
28954: PUSH
28955: LD_INT 3
28957: PUSH
28958: LD_INT 3
28960: PUSH
28961: EMPTY
28962: LIST
28963: LIST
28964: PUSH
28965: LD_INT 2
28967: PUSH
28968: LD_INT 3
28970: PUSH
28971: EMPTY
28972: LIST
28973: LIST
28974: PUSH
28975: EMPTY
28976: LIST
28977: LIST
28978: LIST
28979: LIST
28980: LIST
28981: LIST
28982: LIST
28983: LIST
28984: LIST
28985: LIST
28986: LIST
28987: LIST
28988: LIST
28989: LIST
28990: LIST
28991: LIST
28992: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
28993: LD_ADDR_VAR 0 17
28997: PUSH
28998: LD_INT 0
29000: PUSH
29001: LD_INT 0
29003: PUSH
29004: EMPTY
29005: LIST
29006: LIST
29007: PUSH
29008: LD_INT 0
29010: PUSH
29011: LD_INT 1
29013: NEG
29014: PUSH
29015: EMPTY
29016: LIST
29017: LIST
29018: PUSH
29019: LD_INT 1
29021: PUSH
29022: LD_INT 0
29024: PUSH
29025: EMPTY
29026: LIST
29027: LIST
29028: PUSH
29029: LD_INT 1
29031: PUSH
29032: LD_INT 1
29034: PUSH
29035: EMPTY
29036: LIST
29037: LIST
29038: PUSH
29039: LD_INT 0
29041: PUSH
29042: LD_INT 1
29044: PUSH
29045: EMPTY
29046: LIST
29047: LIST
29048: PUSH
29049: LD_INT 1
29051: NEG
29052: PUSH
29053: LD_INT 0
29055: PUSH
29056: EMPTY
29057: LIST
29058: LIST
29059: PUSH
29060: LD_INT 1
29062: NEG
29063: PUSH
29064: LD_INT 1
29066: NEG
29067: PUSH
29068: EMPTY
29069: LIST
29070: LIST
29071: PUSH
29072: LD_INT 1
29074: NEG
29075: PUSH
29076: LD_INT 2
29078: NEG
29079: PUSH
29080: EMPTY
29081: LIST
29082: LIST
29083: PUSH
29084: LD_INT 0
29086: PUSH
29087: LD_INT 2
29089: NEG
29090: PUSH
29091: EMPTY
29092: LIST
29093: LIST
29094: PUSH
29095: LD_INT 1
29097: PUSH
29098: LD_INT 1
29100: NEG
29101: PUSH
29102: EMPTY
29103: LIST
29104: LIST
29105: PUSH
29106: LD_INT 2
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: EMPTY
29113: LIST
29114: LIST
29115: PUSH
29116: LD_INT 2
29118: PUSH
29119: LD_INT 1
29121: PUSH
29122: EMPTY
29123: LIST
29124: LIST
29125: PUSH
29126: LD_INT 2
29128: PUSH
29129: LD_INT 2
29131: PUSH
29132: EMPTY
29133: LIST
29134: LIST
29135: PUSH
29136: LD_INT 1
29138: PUSH
29139: LD_INT 2
29141: PUSH
29142: EMPTY
29143: LIST
29144: LIST
29145: PUSH
29146: LD_INT 0
29148: PUSH
29149: LD_INT 2
29151: PUSH
29152: EMPTY
29153: LIST
29154: LIST
29155: PUSH
29156: LD_INT 1
29158: NEG
29159: PUSH
29160: LD_INT 1
29162: PUSH
29163: EMPTY
29164: LIST
29165: LIST
29166: PUSH
29167: LD_INT 2
29169: NEG
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: EMPTY
29175: LIST
29176: LIST
29177: PUSH
29178: LD_INT 2
29180: NEG
29181: PUSH
29182: LD_INT 1
29184: NEG
29185: PUSH
29186: EMPTY
29187: LIST
29188: LIST
29189: PUSH
29190: LD_INT 2
29192: NEG
29193: PUSH
29194: LD_INT 2
29196: NEG
29197: PUSH
29198: EMPTY
29199: LIST
29200: LIST
29201: PUSH
29202: EMPTY
29203: LIST
29204: LIST
29205: LIST
29206: LIST
29207: LIST
29208: LIST
29209: LIST
29210: LIST
29211: LIST
29212: LIST
29213: LIST
29214: LIST
29215: LIST
29216: LIST
29217: LIST
29218: LIST
29219: LIST
29220: LIST
29221: LIST
29222: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29223: LD_ADDR_VAR 0 18
29227: PUSH
29228: LD_INT 0
29230: PUSH
29231: LD_INT 0
29233: PUSH
29234: EMPTY
29235: LIST
29236: LIST
29237: PUSH
29238: LD_INT 0
29240: PUSH
29241: LD_INT 1
29243: NEG
29244: PUSH
29245: EMPTY
29246: LIST
29247: LIST
29248: PUSH
29249: LD_INT 1
29251: PUSH
29252: LD_INT 0
29254: PUSH
29255: EMPTY
29256: LIST
29257: LIST
29258: PUSH
29259: LD_INT 1
29261: PUSH
29262: LD_INT 1
29264: PUSH
29265: EMPTY
29266: LIST
29267: LIST
29268: PUSH
29269: LD_INT 0
29271: PUSH
29272: LD_INT 1
29274: PUSH
29275: EMPTY
29276: LIST
29277: LIST
29278: PUSH
29279: LD_INT 1
29281: NEG
29282: PUSH
29283: LD_INT 0
29285: PUSH
29286: EMPTY
29287: LIST
29288: LIST
29289: PUSH
29290: LD_INT 1
29292: NEG
29293: PUSH
29294: LD_INT 1
29296: NEG
29297: PUSH
29298: EMPTY
29299: LIST
29300: LIST
29301: PUSH
29302: LD_INT 1
29304: NEG
29305: PUSH
29306: LD_INT 2
29308: NEG
29309: PUSH
29310: EMPTY
29311: LIST
29312: LIST
29313: PUSH
29314: LD_INT 0
29316: PUSH
29317: LD_INT 2
29319: NEG
29320: PUSH
29321: EMPTY
29322: LIST
29323: LIST
29324: PUSH
29325: LD_INT 1
29327: PUSH
29328: LD_INT 1
29330: NEG
29331: PUSH
29332: EMPTY
29333: LIST
29334: LIST
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: EMPTY
29343: LIST
29344: LIST
29345: PUSH
29346: LD_INT 2
29348: PUSH
29349: LD_INT 1
29351: PUSH
29352: EMPTY
29353: LIST
29354: LIST
29355: PUSH
29356: LD_INT 2
29358: PUSH
29359: LD_INT 2
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PUSH
29366: LD_INT 1
29368: PUSH
29369: LD_INT 2
29371: PUSH
29372: EMPTY
29373: LIST
29374: LIST
29375: PUSH
29376: LD_INT 0
29378: PUSH
29379: LD_INT 2
29381: PUSH
29382: EMPTY
29383: LIST
29384: LIST
29385: PUSH
29386: LD_INT 1
29388: NEG
29389: PUSH
29390: LD_INT 1
29392: PUSH
29393: EMPTY
29394: LIST
29395: LIST
29396: PUSH
29397: LD_INT 2
29399: NEG
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: EMPTY
29405: LIST
29406: LIST
29407: PUSH
29408: LD_INT 2
29410: NEG
29411: PUSH
29412: LD_INT 1
29414: NEG
29415: PUSH
29416: EMPTY
29417: LIST
29418: LIST
29419: PUSH
29420: LD_INT 2
29422: NEG
29423: PUSH
29424: LD_INT 2
29426: NEG
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: PUSH
29432: EMPTY
29433: LIST
29434: LIST
29435: LIST
29436: LIST
29437: LIST
29438: LIST
29439: LIST
29440: LIST
29441: LIST
29442: LIST
29443: LIST
29444: LIST
29445: LIST
29446: LIST
29447: LIST
29448: LIST
29449: LIST
29450: LIST
29451: LIST
29452: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29453: LD_ADDR_VAR 0 19
29457: PUSH
29458: LD_INT 0
29460: PUSH
29461: LD_INT 0
29463: PUSH
29464: EMPTY
29465: LIST
29466: LIST
29467: PUSH
29468: LD_INT 0
29470: PUSH
29471: LD_INT 1
29473: NEG
29474: PUSH
29475: EMPTY
29476: LIST
29477: LIST
29478: PUSH
29479: LD_INT 1
29481: PUSH
29482: LD_INT 0
29484: PUSH
29485: EMPTY
29486: LIST
29487: LIST
29488: PUSH
29489: LD_INT 1
29491: PUSH
29492: LD_INT 1
29494: PUSH
29495: EMPTY
29496: LIST
29497: LIST
29498: PUSH
29499: LD_INT 0
29501: PUSH
29502: LD_INT 1
29504: PUSH
29505: EMPTY
29506: LIST
29507: LIST
29508: PUSH
29509: LD_INT 1
29511: NEG
29512: PUSH
29513: LD_INT 0
29515: PUSH
29516: EMPTY
29517: LIST
29518: LIST
29519: PUSH
29520: LD_INT 1
29522: NEG
29523: PUSH
29524: LD_INT 1
29526: NEG
29527: PUSH
29528: EMPTY
29529: LIST
29530: LIST
29531: PUSH
29532: LD_INT 1
29534: NEG
29535: PUSH
29536: LD_INT 2
29538: NEG
29539: PUSH
29540: EMPTY
29541: LIST
29542: LIST
29543: PUSH
29544: LD_INT 0
29546: PUSH
29547: LD_INT 2
29549: NEG
29550: PUSH
29551: EMPTY
29552: LIST
29553: LIST
29554: PUSH
29555: LD_INT 1
29557: PUSH
29558: LD_INT 1
29560: NEG
29561: PUSH
29562: EMPTY
29563: LIST
29564: LIST
29565: PUSH
29566: LD_INT 2
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: EMPTY
29573: LIST
29574: LIST
29575: PUSH
29576: LD_INT 2
29578: PUSH
29579: LD_INT 1
29581: PUSH
29582: EMPTY
29583: LIST
29584: LIST
29585: PUSH
29586: LD_INT 2
29588: PUSH
29589: LD_INT 2
29591: PUSH
29592: EMPTY
29593: LIST
29594: LIST
29595: PUSH
29596: LD_INT 1
29598: PUSH
29599: LD_INT 2
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: PUSH
29606: LD_INT 0
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: EMPTY
29613: LIST
29614: LIST
29615: PUSH
29616: LD_INT 1
29618: NEG
29619: PUSH
29620: LD_INT 1
29622: PUSH
29623: EMPTY
29624: LIST
29625: LIST
29626: PUSH
29627: LD_INT 2
29629: NEG
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: EMPTY
29635: LIST
29636: LIST
29637: PUSH
29638: LD_INT 2
29640: NEG
29641: PUSH
29642: LD_INT 1
29644: NEG
29645: PUSH
29646: EMPTY
29647: LIST
29648: LIST
29649: PUSH
29650: LD_INT 2
29652: NEG
29653: PUSH
29654: LD_INT 2
29656: NEG
29657: PUSH
29658: EMPTY
29659: LIST
29660: LIST
29661: PUSH
29662: EMPTY
29663: LIST
29664: LIST
29665: LIST
29666: LIST
29667: LIST
29668: LIST
29669: LIST
29670: LIST
29671: LIST
29672: LIST
29673: LIST
29674: LIST
29675: LIST
29676: LIST
29677: LIST
29678: LIST
29679: LIST
29680: LIST
29681: LIST
29682: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29683: LD_ADDR_VAR 0 20
29687: PUSH
29688: LD_INT 0
29690: PUSH
29691: LD_INT 0
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: PUSH
29698: LD_INT 0
29700: PUSH
29701: LD_INT 1
29703: NEG
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: PUSH
29709: LD_INT 1
29711: PUSH
29712: LD_INT 0
29714: PUSH
29715: EMPTY
29716: LIST
29717: LIST
29718: PUSH
29719: LD_INT 1
29721: PUSH
29722: LD_INT 1
29724: PUSH
29725: EMPTY
29726: LIST
29727: LIST
29728: PUSH
29729: LD_INT 0
29731: PUSH
29732: LD_INT 1
29734: PUSH
29735: EMPTY
29736: LIST
29737: LIST
29738: PUSH
29739: LD_INT 1
29741: NEG
29742: PUSH
29743: LD_INT 0
29745: PUSH
29746: EMPTY
29747: LIST
29748: LIST
29749: PUSH
29750: LD_INT 1
29752: NEG
29753: PUSH
29754: LD_INT 1
29756: NEG
29757: PUSH
29758: EMPTY
29759: LIST
29760: LIST
29761: PUSH
29762: LD_INT 1
29764: NEG
29765: PUSH
29766: LD_INT 2
29768: NEG
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 2
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 1
29790: NEG
29791: PUSH
29792: EMPTY
29793: LIST
29794: LIST
29795: PUSH
29796: LD_INT 2
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: EMPTY
29803: LIST
29804: LIST
29805: PUSH
29806: LD_INT 2
29808: PUSH
29809: LD_INT 1
29811: PUSH
29812: EMPTY
29813: LIST
29814: LIST
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 2
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: PUSH
29829: LD_INT 2
29831: PUSH
29832: EMPTY
29833: LIST
29834: LIST
29835: PUSH
29836: LD_INT 0
29838: PUSH
29839: LD_INT 2
29841: PUSH
29842: EMPTY
29843: LIST
29844: LIST
29845: PUSH
29846: LD_INT 1
29848: NEG
29849: PUSH
29850: LD_INT 1
29852: PUSH
29853: EMPTY
29854: LIST
29855: LIST
29856: PUSH
29857: LD_INT 2
29859: NEG
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: EMPTY
29865: LIST
29866: LIST
29867: PUSH
29868: LD_INT 2
29870: NEG
29871: PUSH
29872: LD_INT 1
29874: NEG
29875: PUSH
29876: EMPTY
29877: LIST
29878: LIST
29879: PUSH
29880: LD_INT 2
29882: NEG
29883: PUSH
29884: LD_INT 2
29886: NEG
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: EMPTY
29893: LIST
29894: LIST
29895: LIST
29896: LIST
29897: LIST
29898: LIST
29899: LIST
29900: LIST
29901: LIST
29902: LIST
29903: LIST
29904: LIST
29905: LIST
29906: LIST
29907: LIST
29908: LIST
29909: LIST
29910: LIST
29911: LIST
29912: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29913: LD_ADDR_VAR 0 21
29917: PUSH
29918: LD_INT 0
29920: PUSH
29921: LD_INT 0
29923: PUSH
29924: EMPTY
29925: LIST
29926: LIST
29927: PUSH
29928: LD_INT 0
29930: PUSH
29931: LD_INT 1
29933: NEG
29934: PUSH
29935: EMPTY
29936: LIST
29937: LIST
29938: PUSH
29939: LD_INT 1
29941: PUSH
29942: LD_INT 0
29944: PUSH
29945: EMPTY
29946: LIST
29947: LIST
29948: PUSH
29949: LD_INT 1
29951: PUSH
29952: LD_INT 1
29954: PUSH
29955: EMPTY
29956: LIST
29957: LIST
29958: PUSH
29959: LD_INT 0
29961: PUSH
29962: LD_INT 1
29964: PUSH
29965: EMPTY
29966: LIST
29967: LIST
29968: PUSH
29969: LD_INT 1
29971: NEG
29972: PUSH
29973: LD_INT 0
29975: PUSH
29976: EMPTY
29977: LIST
29978: LIST
29979: PUSH
29980: LD_INT 1
29982: NEG
29983: PUSH
29984: LD_INT 1
29986: NEG
29987: PUSH
29988: EMPTY
29989: LIST
29990: LIST
29991: PUSH
29992: LD_INT 1
29994: NEG
29995: PUSH
29996: LD_INT 2
29998: NEG
29999: PUSH
30000: EMPTY
30001: LIST
30002: LIST
30003: PUSH
30004: LD_INT 0
30006: PUSH
30007: LD_INT 2
30009: NEG
30010: PUSH
30011: EMPTY
30012: LIST
30013: LIST
30014: PUSH
30015: LD_INT 1
30017: PUSH
30018: LD_INT 1
30020: NEG
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 2
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: EMPTY
30033: LIST
30034: LIST
30035: PUSH
30036: LD_INT 2
30038: PUSH
30039: LD_INT 1
30041: PUSH
30042: EMPTY
30043: LIST
30044: LIST
30045: PUSH
30046: LD_INT 2
30048: PUSH
30049: LD_INT 2
30051: PUSH
30052: EMPTY
30053: LIST
30054: LIST
30055: PUSH
30056: LD_INT 1
30058: PUSH
30059: LD_INT 2
30061: PUSH
30062: EMPTY
30063: LIST
30064: LIST
30065: PUSH
30066: LD_INT 0
30068: PUSH
30069: LD_INT 2
30071: PUSH
30072: EMPTY
30073: LIST
30074: LIST
30075: PUSH
30076: LD_INT 1
30078: NEG
30079: PUSH
30080: LD_INT 1
30082: PUSH
30083: EMPTY
30084: LIST
30085: LIST
30086: PUSH
30087: LD_INT 2
30089: NEG
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: EMPTY
30095: LIST
30096: LIST
30097: PUSH
30098: LD_INT 2
30100: NEG
30101: PUSH
30102: LD_INT 1
30104: NEG
30105: PUSH
30106: EMPTY
30107: LIST
30108: LIST
30109: PUSH
30110: LD_INT 2
30112: NEG
30113: PUSH
30114: LD_INT 2
30116: NEG
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: EMPTY
30123: LIST
30124: LIST
30125: LIST
30126: LIST
30127: LIST
30128: LIST
30129: LIST
30130: LIST
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30143: LD_ADDR_VAR 0 22
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: LD_INT 0
30153: PUSH
30154: EMPTY
30155: LIST
30156: LIST
30157: PUSH
30158: LD_INT 0
30160: PUSH
30161: LD_INT 1
30163: NEG
30164: PUSH
30165: EMPTY
30166: LIST
30167: LIST
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: LD_INT 0
30174: PUSH
30175: EMPTY
30176: LIST
30177: LIST
30178: PUSH
30179: LD_INT 1
30181: PUSH
30182: LD_INT 1
30184: PUSH
30185: EMPTY
30186: LIST
30187: LIST
30188: PUSH
30189: LD_INT 0
30191: PUSH
30192: LD_INT 1
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 1
30201: NEG
30202: PUSH
30203: LD_INT 0
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 1
30212: NEG
30213: PUSH
30214: LD_INT 1
30216: NEG
30217: PUSH
30218: EMPTY
30219: LIST
30220: LIST
30221: PUSH
30222: LD_INT 1
30224: NEG
30225: PUSH
30226: LD_INT 2
30228: NEG
30229: PUSH
30230: EMPTY
30231: LIST
30232: LIST
30233: PUSH
30234: LD_INT 0
30236: PUSH
30237: LD_INT 2
30239: NEG
30240: PUSH
30241: EMPTY
30242: LIST
30243: LIST
30244: PUSH
30245: LD_INT 1
30247: PUSH
30248: LD_INT 1
30250: NEG
30251: PUSH
30252: EMPTY
30253: LIST
30254: LIST
30255: PUSH
30256: LD_INT 2
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 2
30268: PUSH
30269: LD_INT 1
30271: PUSH
30272: EMPTY
30273: LIST
30274: LIST
30275: PUSH
30276: LD_INT 2
30278: PUSH
30279: LD_INT 2
30281: PUSH
30282: EMPTY
30283: LIST
30284: LIST
30285: PUSH
30286: LD_INT 1
30288: PUSH
30289: LD_INT 2
30291: PUSH
30292: EMPTY
30293: LIST
30294: LIST
30295: PUSH
30296: LD_INT 0
30298: PUSH
30299: LD_INT 2
30301: PUSH
30302: EMPTY
30303: LIST
30304: LIST
30305: PUSH
30306: LD_INT 1
30308: NEG
30309: PUSH
30310: LD_INT 1
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 2
30319: NEG
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: EMPTY
30325: LIST
30326: LIST
30327: PUSH
30328: LD_INT 2
30330: NEG
30331: PUSH
30332: LD_INT 1
30334: NEG
30335: PUSH
30336: EMPTY
30337: LIST
30338: LIST
30339: PUSH
30340: LD_INT 2
30342: NEG
30343: PUSH
30344: LD_INT 2
30346: NEG
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: EMPTY
30353: LIST
30354: LIST
30355: LIST
30356: LIST
30357: LIST
30358: LIST
30359: LIST
30360: LIST
30361: LIST
30362: LIST
30363: LIST
30364: LIST
30365: LIST
30366: LIST
30367: LIST
30368: LIST
30369: LIST
30370: LIST
30371: LIST
30372: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30373: LD_ADDR_VAR 0 23
30377: PUSH
30378: LD_INT 0
30380: PUSH
30381: LD_INT 0
30383: PUSH
30384: EMPTY
30385: LIST
30386: LIST
30387: PUSH
30388: LD_INT 0
30390: PUSH
30391: LD_INT 1
30393: NEG
30394: PUSH
30395: EMPTY
30396: LIST
30397: LIST
30398: PUSH
30399: LD_INT 1
30401: PUSH
30402: LD_INT 0
30404: PUSH
30405: EMPTY
30406: LIST
30407: LIST
30408: PUSH
30409: LD_INT 1
30411: PUSH
30412: LD_INT 1
30414: PUSH
30415: EMPTY
30416: LIST
30417: LIST
30418: PUSH
30419: LD_INT 0
30421: PUSH
30422: LD_INT 1
30424: PUSH
30425: EMPTY
30426: LIST
30427: LIST
30428: PUSH
30429: LD_INT 1
30431: NEG
30432: PUSH
30433: LD_INT 0
30435: PUSH
30436: EMPTY
30437: LIST
30438: LIST
30439: PUSH
30440: LD_INT 1
30442: NEG
30443: PUSH
30444: LD_INT 1
30446: NEG
30447: PUSH
30448: EMPTY
30449: LIST
30450: LIST
30451: PUSH
30452: LD_INT 1
30454: NEG
30455: PUSH
30456: LD_INT 2
30458: NEG
30459: PUSH
30460: EMPTY
30461: LIST
30462: LIST
30463: PUSH
30464: LD_INT 0
30466: PUSH
30467: LD_INT 2
30469: NEG
30470: PUSH
30471: EMPTY
30472: LIST
30473: LIST
30474: PUSH
30475: LD_INT 1
30477: PUSH
30478: LD_INT 1
30480: NEG
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 2
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 2
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 2
30508: PUSH
30509: LD_INT 2
30511: PUSH
30512: EMPTY
30513: LIST
30514: LIST
30515: PUSH
30516: LD_INT 1
30518: PUSH
30519: LD_INT 2
30521: PUSH
30522: EMPTY
30523: LIST
30524: LIST
30525: PUSH
30526: LD_INT 0
30528: PUSH
30529: LD_INT 2
30531: PUSH
30532: EMPTY
30533: LIST
30534: LIST
30535: PUSH
30536: LD_INT 1
30538: NEG
30539: PUSH
30540: LD_INT 1
30542: PUSH
30543: EMPTY
30544: LIST
30545: LIST
30546: PUSH
30547: LD_INT 2
30549: NEG
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 2
30560: NEG
30561: PUSH
30562: LD_INT 1
30564: NEG
30565: PUSH
30566: EMPTY
30567: LIST
30568: LIST
30569: PUSH
30570: LD_INT 2
30572: NEG
30573: PUSH
30574: LD_INT 2
30576: NEG
30577: PUSH
30578: EMPTY
30579: LIST
30580: LIST
30581: PUSH
30582: LD_INT 2
30584: NEG
30585: PUSH
30586: LD_INT 3
30588: NEG
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 3
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 1
30608: PUSH
30609: LD_INT 2
30611: NEG
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 2
30619: PUSH
30620: LD_INT 1
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: LIST
30646: LIST
30647: LIST
30648: LIST
30649: LIST
30650: LIST
30651: LIST
30652: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30653: LD_ADDR_VAR 0 24
30657: PUSH
30658: LD_INT 0
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: EMPTY
30665: LIST
30666: LIST
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: LD_INT 1
30673: NEG
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PUSH
30679: LD_INT 1
30681: PUSH
30682: LD_INT 0
30684: PUSH
30685: EMPTY
30686: LIST
30687: LIST
30688: PUSH
30689: LD_INT 1
30691: PUSH
30692: LD_INT 1
30694: PUSH
30695: EMPTY
30696: LIST
30697: LIST
30698: PUSH
30699: LD_INT 0
30701: PUSH
30702: LD_INT 1
30704: PUSH
30705: EMPTY
30706: LIST
30707: LIST
30708: PUSH
30709: LD_INT 1
30711: NEG
30712: PUSH
30713: LD_INT 0
30715: PUSH
30716: EMPTY
30717: LIST
30718: LIST
30719: PUSH
30720: LD_INT 1
30722: NEG
30723: PUSH
30724: LD_INT 1
30726: NEG
30727: PUSH
30728: EMPTY
30729: LIST
30730: LIST
30731: PUSH
30732: LD_INT 1
30734: NEG
30735: PUSH
30736: LD_INT 2
30738: NEG
30739: PUSH
30740: EMPTY
30741: LIST
30742: LIST
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: LD_INT 2
30749: NEG
30750: PUSH
30751: EMPTY
30752: LIST
30753: LIST
30754: PUSH
30755: LD_INT 1
30757: PUSH
30758: LD_INT 1
30760: NEG
30761: PUSH
30762: EMPTY
30763: LIST
30764: LIST
30765: PUSH
30766: LD_INT 2
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: EMPTY
30773: LIST
30774: LIST
30775: PUSH
30776: LD_INT 2
30778: PUSH
30779: LD_INT 1
30781: PUSH
30782: EMPTY
30783: LIST
30784: LIST
30785: PUSH
30786: LD_INT 2
30788: PUSH
30789: LD_INT 2
30791: PUSH
30792: EMPTY
30793: LIST
30794: LIST
30795: PUSH
30796: LD_INT 1
30798: PUSH
30799: LD_INT 2
30801: PUSH
30802: EMPTY
30803: LIST
30804: LIST
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: LD_INT 2
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 1
30818: NEG
30819: PUSH
30820: LD_INT 1
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 2
30829: NEG
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: EMPTY
30835: LIST
30836: LIST
30837: PUSH
30838: LD_INT 2
30840: NEG
30841: PUSH
30842: LD_INT 1
30844: NEG
30845: PUSH
30846: EMPTY
30847: LIST
30848: LIST
30849: PUSH
30850: LD_INT 2
30852: NEG
30853: PUSH
30854: LD_INT 2
30856: NEG
30857: PUSH
30858: EMPTY
30859: LIST
30860: LIST
30861: PUSH
30862: LD_INT 1
30864: PUSH
30865: LD_INT 2
30867: NEG
30868: PUSH
30869: EMPTY
30870: LIST
30871: LIST
30872: PUSH
30873: LD_INT 2
30875: PUSH
30876: LD_INT 1
30878: NEG
30879: PUSH
30880: EMPTY
30881: LIST
30882: LIST
30883: PUSH
30884: LD_INT 3
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: EMPTY
30891: LIST
30892: LIST
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: LD_INT 2
30899: PUSH
30900: EMPTY
30901: LIST
30902: LIST
30903: PUSH
30904: EMPTY
30905: LIST
30906: LIST
30907: LIST
30908: LIST
30909: LIST
30910: LIST
30911: LIST
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30929: LD_ADDR_VAR 0 25
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: NEG
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: LD_INT 1
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: LD_INT 1
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 2
31014: NEG
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 0
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: LD_INT 2
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: LD_INT 2
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: NEG
31129: PUSH
31130: LD_INT 2
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: LD_INT 3
31140: PUSH
31141: LD_INT 1
31143: PUSH
31144: EMPTY
31145: LIST
31146: LIST
31147: PUSH
31148: LD_INT 3
31150: PUSH
31151: LD_INT 2
31153: PUSH
31154: EMPTY
31155: LIST
31156: LIST
31157: PUSH
31158: LD_INT 2
31160: PUSH
31161: LD_INT 3
31163: PUSH
31164: EMPTY
31165: LIST
31166: LIST
31167: PUSH
31168: LD_INT 1
31170: PUSH
31171: LD_INT 3
31173: PUSH
31174: EMPTY
31175: LIST
31176: LIST
31177: PUSH
31178: EMPTY
31179: LIST
31180: LIST
31181: LIST
31182: LIST
31183: LIST
31184: LIST
31185: LIST
31186: LIST
31187: LIST
31188: LIST
31189: LIST
31190: LIST
31191: LIST
31192: LIST
31193: LIST
31194: LIST
31195: LIST
31196: LIST
31197: LIST
31198: LIST
31199: LIST
31200: LIST
31201: LIST
31202: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31203: LD_ADDR_VAR 0 26
31207: PUSH
31208: LD_INT 0
31210: PUSH
31211: LD_INT 0
31213: PUSH
31214: EMPTY
31215: LIST
31216: LIST
31217: PUSH
31218: LD_INT 0
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 1
31231: PUSH
31232: LD_INT 0
31234: PUSH
31235: EMPTY
31236: LIST
31237: LIST
31238: PUSH
31239: LD_INT 1
31241: PUSH
31242: LD_INT 1
31244: PUSH
31245: EMPTY
31246: LIST
31247: LIST
31248: PUSH
31249: LD_INT 0
31251: PUSH
31252: LD_INT 1
31254: PUSH
31255: EMPTY
31256: LIST
31257: LIST
31258: PUSH
31259: LD_INT 1
31261: NEG
31262: PUSH
31263: LD_INT 0
31265: PUSH
31266: EMPTY
31267: LIST
31268: LIST
31269: PUSH
31270: LD_INT 1
31272: NEG
31273: PUSH
31274: LD_INT 1
31276: NEG
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 1
31284: NEG
31285: PUSH
31286: LD_INT 2
31288: NEG
31289: PUSH
31290: EMPTY
31291: LIST
31292: LIST
31293: PUSH
31294: LD_INT 0
31296: PUSH
31297: LD_INT 2
31299: NEG
31300: PUSH
31301: EMPTY
31302: LIST
31303: LIST
31304: PUSH
31305: LD_INT 1
31307: PUSH
31308: LD_INT 1
31310: NEG
31311: PUSH
31312: EMPTY
31313: LIST
31314: LIST
31315: PUSH
31316: LD_INT 2
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: EMPTY
31323: LIST
31324: LIST
31325: PUSH
31326: LD_INT 2
31328: PUSH
31329: LD_INT 1
31331: PUSH
31332: EMPTY
31333: LIST
31334: LIST
31335: PUSH
31336: LD_INT 2
31338: PUSH
31339: LD_INT 2
31341: PUSH
31342: EMPTY
31343: LIST
31344: LIST
31345: PUSH
31346: LD_INT 1
31348: PUSH
31349: LD_INT 2
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 0
31358: PUSH
31359: LD_INT 2
31361: PUSH
31362: EMPTY
31363: LIST
31364: LIST
31365: PUSH
31366: LD_INT 1
31368: NEG
31369: PUSH
31370: LD_INT 1
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: LD_INT 2
31379: NEG
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: EMPTY
31385: LIST
31386: LIST
31387: PUSH
31388: LD_INT 2
31390: NEG
31391: PUSH
31392: LD_INT 1
31394: NEG
31395: PUSH
31396: EMPTY
31397: LIST
31398: LIST
31399: PUSH
31400: LD_INT 2
31402: NEG
31403: PUSH
31404: LD_INT 2
31406: NEG
31407: PUSH
31408: EMPTY
31409: LIST
31410: LIST
31411: PUSH
31412: LD_INT 2
31414: PUSH
31415: LD_INT 3
31417: PUSH
31418: EMPTY
31419: LIST
31420: LIST
31421: PUSH
31422: LD_INT 1
31424: PUSH
31425: LD_INT 3
31427: PUSH
31428: EMPTY
31429: LIST
31430: LIST
31431: PUSH
31432: LD_INT 1
31434: NEG
31435: PUSH
31436: LD_INT 2
31438: PUSH
31439: EMPTY
31440: LIST
31441: LIST
31442: PUSH
31443: LD_INT 2
31445: NEG
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: EMPTY
31451: LIST
31452: LIST
31453: PUSH
31454: EMPTY
31455: LIST
31456: LIST
31457: LIST
31458: LIST
31459: LIST
31460: LIST
31461: LIST
31462: LIST
31463: LIST
31464: LIST
31465: LIST
31466: LIST
31467: LIST
31468: LIST
31469: LIST
31470: LIST
31471: LIST
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31479: LD_ADDR_VAR 0 27
31483: PUSH
31484: LD_INT 0
31486: PUSH
31487: LD_INT 0
31489: PUSH
31490: EMPTY
31491: LIST
31492: LIST
31493: PUSH
31494: LD_INT 0
31496: PUSH
31497: LD_INT 1
31499: NEG
31500: PUSH
31501: EMPTY
31502: LIST
31503: LIST
31504: PUSH
31505: LD_INT 1
31507: PUSH
31508: LD_INT 0
31510: PUSH
31511: EMPTY
31512: LIST
31513: LIST
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: PUSH
31525: LD_INT 0
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: EMPTY
31532: LIST
31533: LIST
31534: PUSH
31535: LD_INT 1
31537: NEG
31538: PUSH
31539: LD_INT 0
31541: PUSH
31542: EMPTY
31543: LIST
31544: LIST
31545: PUSH
31546: LD_INT 1
31548: NEG
31549: PUSH
31550: LD_INT 1
31552: NEG
31553: PUSH
31554: EMPTY
31555: LIST
31556: LIST
31557: PUSH
31558: LD_INT 1
31560: NEG
31561: PUSH
31562: LD_INT 2
31564: NEG
31565: PUSH
31566: EMPTY
31567: LIST
31568: LIST
31569: PUSH
31570: LD_INT 0
31572: PUSH
31573: LD_INT 2
31575: NEG
31576: PUSH
31577: EMPTY
31578: LIST
31579: LIST
31580: PUSH
31581: LD_INT 1
31583: PUSH
31584: LD_INT 1
31586: NEG
31587: PUSH
31588: EMPTY
31589: LIST
31590: LIST
31591: PUSH
31592: LD_INT 2
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: PUSH
31602: LD_INT 2
31604: PUSH
31605: LD_INT 1
31607: PUSH
31608: EMPTY
31609: LIST
31610: LIST
31611: PUSH
31612: LD_INT 2
31614: PUSH
31615: LD_INT 2
31617: PUSH
31618: EMPTY
31619: LIST
31620: LIST
31621: PUSH
31622: LD_INT 1
31624: PUSH
31625: LD_INT 2
31627: PUSH
31628: EMPTY
31629: LIST
31630: LIST
31631: PUSH
31632: LD_INT 0
31634: PUSH
31635: LD_INT 2
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 1
31644: NEG
31645: PUSH
31646: LD_INT 1
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 2
31655: NEG
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PUSH
31664: LD_INT 2
31666: NEG
31667: PUSH
31668: LD_INT 1
31670: NEG
31671: PUSH
31672: EMPTY
31673: LIST
31674: LIST
31675: PUSH
31676: LD_INT 2
31678: NEG
31679: PUSH
31680: LD_INT 2
31682: NEG
31683: PUSH
31684: EMPTY
31685: LIST
31686: LIST
31687: PUSH
31688: LD_INT 1
31690: NEG
31691: PUSH
31692: LD_INT 2
31694: PUSH
31695: EMPTY
31696: LIST
31697: LIST
31698: PUSH
31699: LD_INT 2
31701: NEG
31702: PUSH
31703: LD_INT 1
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 3
31712: NEG
31713: PUSH
31714: LD_INT 1
31716: NEG
31717: PUSH
31718: EMPTY
31719: LIST
31720: LIST
31721: PUSH
31722: LD_INT 3
31724: NEG
31725: PUSH
31726: LD_INT 2
31728: NEG
31729: PUSH
31730: EMPTY
31731: LIST
31732: LIST
31733: PUSH
31734: EMPTY
31735: LIST
31736: LIST
31737: LIST
31738: LIST
31739: LIST
31740: LIST
31741: LIST
31742: LIST
31743: LIST
31744: LIST
31745: LIST
31746: LIST
31747: LIST
31748: LIST
31749: LIST
31750: LIST
31751: LIST
31752: LIST
31753: LIST
31754: LIST
31755: LIST
31756: LIST
31757: LIST
31758: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31759: LD_ADDR_VAR 0 28
31763: PUSH
31764: LD_INT 0
31766: PUSH
31767: LD_INT 0
31769: PUSH
31770: EMPTY
31771: LIST
31772: LIST
31773: PUSH
31774: LD_INT 0
31776: PUSH
31777: LD_INT 1
31779: NEG
31780: PUSH
31781: EMPTY
31782: LIST
31783: LIST
31784: PUSH
31785: LD_INT 1
31787: PUSH
31788: LD_INT 0
31790: PUSH
31791: EMPTY
31792: LIST
31793: LIST
31794: PUSH
31795: LD_INT 1
31797: PUSH
31798: LD_INT 1
31800: PUSH
31801: EMPTY
31802: LIST
31803: LIST
31804: PUSH
31805: LD_INT 0
31807: PUSH
31808: LD_INT 1
31810: PUSH
31811: EMPTY
31812: LIST
31813: LIST
31814: PUSH
31815: LD_INT 1
31817: NEG
31818: PUSH
31819: LD_INT 0
31821: PUSH
31822: EMPTY
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 1
31828: NEG
31829: PUSH
31830: LD_INT 1
31832: NEG
31833: PUSH
31834: EMPTY
31835: LIST
31836: LIST
31837: PUSH
31838: LD_INT 1
31840: NEG
31841: PUSH
31842: LD_INT 2
31844: NEG
31845: PUSH
31846: EMPTY
31847: LIST
31848: LIST
31849: PUSH
31850: LD_INT 0
31852: PUSH
31853: LD_INT 2
31855: NEG
31856: PUSH
31857: EMPTY
31858: LIST
31859: LIST
31860: PUSH
31861: LD_INT 1
31863: PUSH
31864: LD_INT 1
31866: NEG
31867: PUSH
31868: EMPTY
31869: LIST
31870: LIST
31871: PUSH
31872: LD_INT 2
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: EMPTY
31879: LIST
31880: LIST
31881: PUSH
31882: LD_INT 2
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: EMPTY
31889: LIST
31890: LIST
31891: PUSH
31892: LD_INT 2
31894: PUSH
31895: LD_INT 2
31897: PUSH
31898: EMPTY
31899: LIST
31900: LIST
31901: PUSH
31902: LD_INT 1
31904: PUSH
31905: LD_INT 2
31907: PUSH
31908: EMPTY
31909: LIST
31910: LIST
31911: PUSH
31912: LD_INT 0
31914: PUSH
31915: LD_INT 2
31917: PUSH
31918: EMPTY
31919: LIST
31920: LIST
31921: PUSH
31922: LD_INT 1
31924: NEG
31925: PUSH
31926: LD_INT 1
31928: PUSH
31929: EMPTY
31930: LIST
31931: LIST
31932: PUSH
31933: LD_INT 2
31935: NEG
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: EMPTY
31941: LIST
31942: LIST
31943: PUSH
31944: LD_INT 2
31946: NEG
31947: PUSH
31948: LD_INT 1
31950: NEG
31951: PUSH
31952: EMPTY
31953: LIST
31954: LIST
31955: PUSH
31956: LD_INT 2
31958: NEG
31959: PUSH
31960: LD_INT 2
31962: NEG
31963: PUSH
31964: EMPTY
31965: LIST
31966: LIST
31967: PUSH
31968: LD_INT 2
31970: NEG
31971: PUSH
31972: LD_INT 3
31974: NEG
31975: PUSH
31976: EMPTY
31977: LIST
31978: LIST
31979: PUSH
31980: LD_INT 1
31982: NEG
31983: PUSH
31984: LD_INT 3
31986: NEG
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 3
31994: NEG
31995: PUSH
31996: LD_INT 1
31998: NEG
31999: PUSH
32000: EMPTY
32001: LIST
32002: LIST
32003: PUSH
32004: LD_INT 3
32006: NEG
32007: PUSH
32008: LD_INT 2
32010: NEG
32011: PUSH
32012: EMPTY
32013: LIST
32014: LIST
32015: PUSH
32016: EMPTY
32017: LIST
32018: LIST
32019: LIST
32020: LIST
32021: LIST
32022: LIST
32023: LIST
32024: LIST
32025: LIST
32026: LIST
32027: LIST
32028: LIST
32029: LIST
32030: LIST
32031: LIST
32032: LIST
32033: LIST
32034: LIST
32035: LIST
32036: LIST
32037: LIST
32038: LIST
32039: LIST
32040: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32041: LD_ADDR_VAR 0 29
32045: PUSH
32046: LD_INT 0
32048: PUSH
32049: LD_INT 0
32051: PUSH
32052: EMPTY
32053: LIST
32054: LIST
32055: PUSH
32056: LD_INT 0
32058: PUSH
32059: LD_INT 1
32061: NEG
32062: PUSH
32063: EMPTY
32064: LIST
32065: LIST
32066: PUSH
32067: LD_INT 1
32069: PUSH
32070: LD_INT 0
32072: PUSH
32073: EMPTY
32074: LIST
32075: LIST
32076: PUSH
32077: LD_INT 1
32079: PUSH
32080: LD_INT 1
32082: PUSH
32083: EMPTY
32084: LIST
32085: LIST
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: LD_INT 1
32092: PUSH
32093: EMPTY
32094: LIST
32095: LIST
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: LD_INT 0
32103: PUSH
32104: EMPTY
32105: LIST
32106: LIST
32107: PUSH
32108: LD_INT 1
32110: NEG
32111: PUSH
32112: LD_INT 1
32114: NEG
32115: PUSH
32116: EMPTY
32117: LIST
32118: LIST
32119: PUSH
32120: LD_INT 1
32122: NEG
32123: PUSH
32124: LD_INT 2
32126: NEG
32127: PUSH
32128: EMPTY
32129: LIST
32130: LIST
32131: PUSH
32132: LD_INT 0
32134: PUSH
32135: LD_INT 2
32137: NEG
32138: PUSH
32139: EMPTY
32140: LIST
32141: LIST
32142: PUSH
32143: LD_INT 1
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: EMPTY
32151: LIST
32152: LIST
32153: PUSH
32154: LD_INT 2
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: EMPTY
32161: LIST
32162: LIST
32163: PUSH
32164: LD_INT 2
32166: PUSH
32167: LD_INT 1
32169: PUSH
32170: EMPTY
32171: LIST
32172: LIST
32173: PUSH
32174: LD_INT 1
32176: PUSH
32177: LD_INT 2
32179: PUSH
32180: EMPTY
32181: LIST
32182: LIST
32183: PUSH
32184: LD_INT 0
32186: PUSH
32187: LD_INT 2
32189: PUSH
32190: EMPTY
32191: LIST
32192: LIST
32193: PUSH
32194: LD_INT 1
32196: NEG
32197: PUSH
32198: LD_INT 1
32200: PUSH
32201: EMPTY
32202: LIST
32203: LIST
32204: PUSH
32205: LD_INT 2
32207: NEG
32208: PUSH
32209: LD_INT 1
32211: NEG
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PUSH
32217: LD_INT 2
32219: NEG
32220: PUSH
32221: LD_INT 2
32223: NEG
32224: PUSH
32225: EMPTY
32226: LIST
32227: LIST
32228: PUSH
32229: LD_INT 2
32231: NEG
32232: PUSH
32233: LD_INT 3
32235: NEG
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: PUSH
32241: LD_INT 2
32243: PUSH
32244: LD_INT 1
32246: NEG
32247: PUSH
32248: EMPTY
32249: LIST
32250: LIST
32251: PUSH
32252: LD_INT 3
32254: PUSH
32255: LD_INT 1
32257: PUSH
32258: EMPTY
32259: LIST
32260: LIST
32261: PUSH
32262: LD_INT 1
32264: PUSH
32265: LD_INT 3
32267: PUSH
32268: EMPTY
32269: LIST
32270: LIST
32271: PUSH
32272: LD_INT 1
32274: NEG
32275: PUSH
32276: LD_INT 2
32278: PUSH
32279: EMPTY
32280: LIST
32281: LIST
32282: PUSH
32283: LD_INT 3
32285: NEG
32286: PUSH
32287: LD_INT 2
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: EMPTY
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: LIST
32309: LIST
32310: LIST
32311: LIST
32312: LIST
32313: LIST
32314: LIST
32315: LIST
32316: LIST
32317: LIST
32318: LIST
32319: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32320: LD_ADDR_VAR 0 30
32324: PUSH
32325: LD_INT 0
32327: PUSH
32328: LD_INT 0
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 0
32337: PUSH
32338: LD_INT 1
32340: NEG
32341: PUSH
32342: EMPTY
32343: LIST
32344: LIST
32345: PUSH
32346: LD_INT 1
32348: PUSH
32349: LD_INT 0
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 1
32358: PUSH
32359: LD_INT 1
32361: PUSH
32362: EMPTY
32363: LIST
32364: LIST
32365: PUSH
32366: LD_INT 0
32368: PUSH
32369: LD_INT 1
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 0
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PUSH
32387: LD_INT 1
32389: NEG
32390: PUSH
32391: LD_INT 1
32393: NEG
32394: PUSH
32395: EMPTY
32396: LIST
32397: LIST
32398: PUSH
32399: LD_INT 1
32401: NEG
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 0
32413: PUSH
32414: LD_INT 2
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 1
32424: PUSH
32425: LD_INT 1
32427: NEG
32428: PUSH
32429: EMPTY
32430: LIST
32431: LIST
32432: PUSH
32433: LD_INT 2
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: EMPTY
32440: LIST
32441: LIST
32442: PUSH
32443: LD_INT 2
32445: PUSH
32446: LD_INT 1
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 2
32455: PUSH
32456: LD_INT 2
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: LD_INT 1
32465: PUSH
32466: LD_INT 2
32468: PUSH
32469: EMPTY
32470: LIST
32471: LIST
32472: PUSH
32473: LD_INT 1
32475: NEG
32476: PUSH
32477: LD_INT 1
32479: PUSH
32480: EMPTY
32481: LIST
32482: LIST
32483: PUSH
32484: LD_INT 2
32486: NEG
32487: PUSH
32488: LD_INT 0
32490: PUSH
32491: EMPTY
32492: LIST
32493: LIST
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: LD_INT 1
32501: NEG
32502: PUSH
32503: EMPTY
32504: LIST
32505: LIST
32506: PUSH
32507: LD_INT 1
32509: NEG
32510: PUSH
32511: LD_INT 3
32513: NEG
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PUSH
32519: LD_INT 1
32521: PUSH
32522: LD_INT 2
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 3
32532: PUSH
32533: LD_INT 2
32535: PUSH
32536: EMPTY
32537: LIST
32538: LIST
32539: PUSH
32540: LD_INT 2
32542: PUSH
32543: LD_INT 3
32545: PUSH
32546: EMPTY
32547: LIST
32548: LIST
32549: PUSH
32550: LD_INT 2
32552: NEG
32553: PUSH
32554: LD_INT 1
32556: PUSH
32557: EMPTY
32558: LIST
32559: LIST
32560: PUSH
32561: LD_INT 3
32563: NEG
32564: PUSH
32565: LD_INT 1
32567: NEG
32568: PUSH
32569: EMPTY
32570: LIST
32571: LIST
32572: PUSH
32573: EMPTY
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: LIST
32589: LIST
32590: LIST
32591: LIST
32592: LIST
32593: LIST
32594: LIST
32595: LIST
32596: LIST
32597: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32598: LD_ADDR_VAR 0 31
32602: PUSH
32603: LD_INT 0
32605: PUSH
32606: LD_INT 0
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 0
32615: PUSH
32616: LD_INT 1
32618: NEG
32619: PUSH
32620: EMPTY
32621: LIST
32622: LIST
32623: PUSH
32624: LD_INT 1
32626: PUSH
32627: LD_INT 0
32629: PUSH
32630: EMPTY
32631: LIST
32632: LIST
32633: PUSH
32634: LD_INT 1
32636: PUSH
32637: LD_INT 1
32639: PUSH
32640: EMPTY
32641: LIST
32642: LIST
32643: PUSH
32644: LD_INT 0
32646: PUSH
32647: LD_INT 1
32649: PUSH
32650: EMPTY
32651: LIST
32652: LIST
32653: PUSH
32654: LD_INT 1
32656: NEG
32657: PUSH
32658: LD_INT 0
32660: PUSH
32661: EMPTY
32662: LIST
32663: LIST
32664: PUSH
32665: LD_INT 1
32667: NEG
32668: PUSH
32669: LD_INT 1
32671: NEG
32672: PUSH
32673: EMPTY
32674: LIST
32675: LIST
32676: PUSH
32677: LD_INT 1
32679: NEG
32680: PUSH
32681: LD_INT 2
32683: NEG
32684: PUSH
32685: EMPTY
32686: LIST
32687: LIST
32688: PUSH
32689: LD_INT 1
32691: PUSH
32692: LD_INT 1
32694: NEG
32695: PUSH
32696: EMPTY
32697: LIST
32698: LIST
32699: PUSH
32700: LD_INT 2
32702: PUSH
32703: LD_INT 0
32705: PUSH
32706: EMPTY
32707: LIST
32708: LIST
32709: PUSH
32710: LD_INT 2
32712: PUSH
32713: LD_INT 1
32715: PUSH
32716: EMPTY
32717: LIST
32718: LIST
32719: PUSH
32720: LD_INT 2
32722: PUSH
32723: LD_INT 2
32725: PUSH
32726: EMPTY
32727: LIST
32728: LIST
32729: PUSH
32730: LD_INT 1
32732: PUSH
32733: LD_INT 2
32735: PUSH
32736: EMPTY
32737: LIST
32738: LIST
32739: PUSH
32740: LD_INT 0
32742: PUSH
32743: LD_INT 2
32745: PUSH
32746: EMPTY
32747: LIST
32748: LIST
32749: PUSH
32750: LD_INT 1
32752: NEG
32753: PUSH
32754: LD_INT 1
32756: PUSH
32757: EMPTY
32758: LIST
32759: LIST
32760: PUSH
32761: LD_INT 2
32763: NEG
32764: PUSH
32765: LD_INT 1
32767: NEG
32768: PUSH
32769: EMPTY
32770: LIST
32771: LIST
32772: PUSH
32773: LD_INT 2
32775: NEG
32776: PUSH
32777: LD_INT 2
32779: NEG
32780: PUSH
32781: EMPTY
32782: LIST
32783: LIST
32784: PUSH
32785: LD_INT 2
32787: NEG
32788: PUSH
32789: LD_INT 3
32791: NEG
32792: PUSH
32793: EMPTY
32794: LIST
32795: LIST
32796: PUSH
32797: LD_INT 2
32799: PUSH
32800: LD_INT 1
32802: NEG
32803: PUSH
32804: EMPTY
32805: LIST
32806: LIST
32807: PUSH
32808: LD_INT 3
32810: PUSH
32811: LD_INT 1
32813: PUSH
32814: EMPTY
32815: LIST
32816: LIST
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: LD_INT 3
32823: PUSH
32824: EMPTY
32825: LIST
32826: LIST
32827: PUSH
32828: LD_INT 1
32830: NEG
32831: PUSH
32832: LD_INT 2
32834: PUSH
32835: EMPTY
32836: LIST
32837: LIST
32838: PUSH
32839: LD_INT 3
32841: NEG
32842: PUSH
32843: LD_INT 2
32845: NEG
32846: PUSH
32847: EMPTY
32848: LIST
32849: LIST
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: LIST
32865: LIST
32866: LIST
32867: LIST
32868: LIST
32869: LIST
32870: LIST
32871: LIST
32872: LIST
32873: LIST
32874: LIST
32875: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32876: LD_ADDR_VAR 0 32
32880: PUSH
32881: LD_INT 0
32883: PUSH
32884: LD_INT 0
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 0
32893: PUSH
32894: LD_INT 1
32896: NEG
32897: PUSH
32898: EMPTY
32899: LIST
32900: LIST
32901: PUSH
32902: LD_INT 1
32904: PUSH
32905: LD_INT 0
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 1
32914: PUSH
32915: LD_INT 1
32917: PUSH
32918: EMPTY
32919: LIST
32920: LIST
32921: PUSH
32922: LD_INT 0
32924: PUSH
32925: LD_INT 1
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 0
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: LD_INT 1
32945: NEG
32946: PUSH
32947: LD_INT 1
32949: NEG
32950: PUSH
32951: EMPTY
32952: LIST
32953: LIST
32954: PUSH
32955: LD_INT 1
32957: NEG
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 0
32969: PUSH
32970: LD_INT 2
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 1
32980: PUSH
32981: LD_INT 1
32983: NEG
32984: PUSH
32985: EMPTY
32986: LIST
32987: LIST
32988: PUSH
32989: LD_INT 2
32991: PUSH
32992: LD_INT 1
32994: PUSH
32995: EMPTY
32996: LIST
32997: LIST
32998: PUSH
32999: LD_INT 2
33001: PUSH
33002: LD_INT 2
33004: PUSH
33005: EMPTY
33006: LIST
33007: LIST
33008: PUSH
33009: LD_INT 1
33011: PUSH
33012: LD_INT 2
33014: PUSH
33015: EMPTY
33016: LIST
33017: LIST
33018: PUSH
33019: LD_INT 0
33021: PUSH
33022: LD_INT 2
33024: PUSH
33025: EMPTY
33026: LIST
33027: LIST
33028: PUSH
33029: LD_INT 1
33031: NEG
33032: PUSH
33033: LD_INT 1
33035: PUSH
33036: EMPTY
33037: LIST
33038: LIST
33039: PUSH
33040: LD_INT 2
33042: NEG
33043: PUSH
33044: LD_INT 0
33046: PUSH
33047: EMPTY
33048: LIST
33049: LIST
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: LD_INT 1
33057: NEG
33058: PUSH
33059: EMPTY
33060: LIST
33061: LIST
33062: PUSH
33063: LD_INT 1
33065: NEG
33066: PUSH
33067: LD_INT 3
33069: NEG
33070: PUSH
33071: EMPTY
33072: LIST
33073: LIST
33074: PUSH
33075: LD_INT 1
33077: PUSH
33078: LD_INT 2
33080: NEG
33081: PUSH
33082: EMPTY
33083: LIST
33084: LIST
33085: PUSH
33086: LD_INT 3
33088: PUSH
33089: LD_INT 2
33091: PUSH
33092: EMPTY
33093: LIST
33094: LIST
33095: PUSH
33096: LD_INT 2
33098: PUSH
33099: LD_INT 3
33101: PUSH
33102: EMPTY
33103: LIST
33104: LIST
33105: PUSH
33106: LD_INT 2
33108: NEG
33109: PUSH
33110: LD_INT 1
33112: PUSH
33113: EMPTY
33114: LIST
33115: LIST
33116: PUSH
33117: LD_INT 3
33119: NEG
33120: PUSH
33121: LD_INT 1
33123: NEG
33124: PUSH
33125: EMPTY
33126: LIST
33127: LIST
33128: PUSH
33129: EMPTY
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: LIST
33139: LIST
33140: LIST
33141: LIST
33142: LIST
33143: LIST
33144: LIST
33145: LIST
33146: LIST
33147: LIST
33148: LIST
33149: LIST
33150: LIST
33151: LIST
33152: LIST
33153: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33154: LD_ADDR_VAR 0 33
33158: PUSH
33159: LD_INT 0
33161: PUSH
33162: LD_INT 0
33164: PUSH
33165: EMPTY
33166: LIST
33167: LIST
33168: PUSH
33169: LD_INT 0
33171: PUSH
33172: LD_INT 1
33174: NEG
33175: PUSH
33176: EMPTY
33177: LIST
33178: LIST
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: LD_INT 0
33185: PUSH
33186: EMPTY
33187: LIST
33188: LIST
33189: PUSH
33190: LD_INT 1
33192: PUSH
33193: LD_INT 1
33195: PUSH
33196: EMPTY
33197: LIST
33198: LIST
33199: PUSH
33200: LD_INT 0
33202: PUSH
33203: LD_INT 1
33205: PUSH
33206: EMPTY
33207: LIST
33208: LIST
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: LD_INT 0
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: PUSH
33221: LD_INT 1
33223: NEG
33224: PUSH
33225: LD_INT 1
33227: NEG
33228: PUSH
33229: EMPTY
33230: LIST
33231: LIST
33232: PUSH
33233: LD_INT 1
33235: NEG
33236: PUSH
33237: LD_INT 2
33239: NEG
33240: PUSH
33241: EMPTY
33242: LIST
33243: LIST
33244: PUSH
33245: LD_INT 1
33247: PUSH
33248: LD_INT 1
33250: NEG
33251: PUSH
33252: EMPTY
33253: LIST
33254: LIST
33255: PUSH
33256: LD_INT 2
33258: PUSH
33259: LD_INT 0
33261: PUSH
33262: EMPTY
33263: LIST
33264: LIST
33265: PUSH
33266: LD_INT 2
33268: PUSH
33269: LD_INT 1
33271: PUSH
33272: EMPTY
33273: LIST
33274: LIST
33275: PUSH
33276: LD_INT 1
33278: PUSH
33279: LD_INT 2
33281: PUSH
33282: EMPTY
33283: LIST
33284: LIST
33285: PUSH
33286: LD_INT 0
33288: PUSH
33289: LD_INT 2
33291: PUSH
33292: EMPTY
33293: LIST
33294: LIST
33295: PUSH
33296: LD_INT 1
33298: NEG
33299: PUSH
33300: LD_INT 1
33302: PUSH
33303: EMPTY
33304: LIST
33305: LIST
33306: PUSH
33307: LD_INT 2
33309: NEG
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: EMPTY
33315: LIST
33316: LIST
33317: PUSH
33318: LD_INT 2
33320: NEG
33321: PUSH
33322: LD_INT 1
33324: NEG
33325: PUSH
33326: EMPTY
33327: LIST
33328: LIST
33329: PUSH
33330: LD_INT 2
33332: NEG
33333: PUSH
33334: LD_INT 2
33336: NEG
33337: PUSH
33338: EMPTY
33339: LIST
33340: LIST
33341: PUSH
33342: LD_INT 2
33344: NEG
33345: PUSH
33346: LD_INT 3
33348: NEG
33349: PUSH
33350: EMPTY
33351: LIST
33352: LIST
33353: PUSH
33354: LD_INT 2
33356: PUSH
33357: LD_INT 1
33359: NEG
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 3
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 1
33377: PUSH
33378: LD_INT 3
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: NEG
33388: PUSH
33389: LD_INT 2
33391: PUSH
33392: EMPTY
33393: LIST
33394: LIST
33395: PUSH
33396: LD_INT 3
33398: NEG
33399: PUSH
33400: LD_INT 2
33402: NEG
33403: PUSH
33404: EMPTY
33405: LIST
33406: LIST
33407: PUSH
33408: EMPTY
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: LIST
33415: LIST
33416: LIST
33417: LIST
33418: LIST
33419: LIST
33420: LIST
33421: LIST
33422: LIST
33423: LIST
33424: LIST
33425: LIST
33426: LIST
33427: LIST
33428: LIST
33429: LIST
33430: LIST
33431: LIST
33432: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33433: LD_ADDR_VAR 0 34
33437: PUSH
33438: LD_INT 0
33440: PUSH
33441: LD_INT 0
33443: PUSH
33444: EMPTY
33445: LIST
33446: LIST
33447: PUSH
33448: LD_INT 0
33450: PUSH
33451: LD_INT 1
33453: NEG
33454: PUSH
33455: EMPTY
33456: LIST
33457: LIST
33458: PUSH
33459: LD_INT 1
33461: PUSH
33462: LD_INT 0
33464: PUSH
33465: EMPTY
33466: LIST
33467: LIST
33468: PUSH
33469: LD_INT 1
33471: PUSH
33472: LD_INT 1
33474: PUSH
33475: EMPTY
33476: LIST
33477: LIST
33478: PUSH
33479: LD_INT 0
33481: PUSH
33482: LD_INT 1
33484: PUSH
33485: EMPTY
33486: LIST
33487: LIST
33488: PUSH
33489: LD_INT 1
33491: NEG
33492: PUSH
33493: LD_INT 0
33495: PUSH
33496: EMPTY
33497: LIST
33498: LIST
33499: PUSH
33500: LD_INT 1
33502: NEG
33503: PUSH
33504: LD_INT 1
33506: NEG
33507: PUSH
33508: EMPTY
33509: LIST
33510: LIST
33511: PUSH
33512: LD_INT 1
33514: NEG
33515: PUSH
33516: LD_INT 2
33518: NEG
33519: PUSH
33520: EMPTY
33521: LIST
33522: LIST
33523: PUSH
33524: LD_INT 0
33526: PUSH
33527: LD_INT 2
33529: NEG
33530: PUSH
33531: EMPTY
33532: LIST
33533: LIST
33534: PUSH
33535: LD_INT 1
33537: PUSH
33538: LD_INT 1
33540: NEG
33541: PUSH
33542: EMPTY
33543: LIST
33544: LIST
33545: PUSH
33546: LD_INT 2
33548: PUSH
33549: LD_INT 1
33551: PUSH
33552: EMPTY
33553: LIST
33554: LIST
33555: PUSH
33556: LD_INT 2
33558: PUSH
33559: LD_INT 2
33561: PUSH
33562: EMPTY
33563: LIST
33564: LIST
33565: PUSH
33566: LD_INT 1
33568: PUSH
33569: LD_INT 2
33571: PUSH
33572: EMPTY
33573: LIST
33574: LIST
33575: PUSH
33576: LD_INT 1
33578: NEG
33579: PUSH
33580: LD_INT 1
33582: PUSH
33583: EMPTY
33584: LIST
33585: LIST
33586: PUSH
33587: LD_INT 2
33589: NEG
33590: PUSH
33591: LD_INT 0
33593: PUSH
33594: EMPTY
33595: LIST
33596: LIST
33597: PUSH
33598: LD_INT 2
33600: NEG
33601: PUSH
33602: LD_INT 1
33604: NEG
33605: PUSH
33606: EMPTY
33607: LIST
33608: LIST
33609: PUSH
33610: LD_INT 2
33612: NEG
33613: PUSH
33614: LD_INT 2
33616: NEG
33617: PUSH
33618: EMPTY
33619: LIST
33620: LIST
33621: PUSH
33622: LD_INT 1
33624: NEG
33625: PUSH
33626: LD_INT 3
33628: NEG
33629: PUSH
33630: EMPTY
33631: LIST
33632: LIST
33633: PUSH
33634: LD_INT 1
33636: PUSH
33637: LD_INT 2
33639: NEG
33640: PUSH
33641: EMPTY
33642: LIST
33643: LIST
33644: PUSH
33645: LD_INT 3
33647: PUSH
33648: LD_INT 2
33650: PUSH
33651: EMPTY
33652: LIST
33653: LIST
33654: PUSH
33655: LD_INT 2
33657: PUSH
33658: LD_INT 3
33660: PUSH
33661: EMPTY
33662: LIST
33663: LIST
33664: PUSH
33665: LD_INT 2
33667: NEG
33668: PUSH
33669: LD_INT 1
33671: PUSH
33672: EMPTY
33673: LIST
33674: LIST
33675: PUSH
33676: LD_INT 3
33678: NEG
33679: PUSH
33680: LD_INT 1
33682: NEG
33683: PUSH
33684: EMPTY
33685: LIST
33686: LIST
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: LIST
33695: LIST
33696: LIST
33697: LIST
33698: LIST
33699: LIST
33700: LIST
33701: LIST
33702: LIST
33703: LIST
33704: LIST
33705: LIST
33706: LIST
33707: LIST
33708: LIST
33709: LIST
33710: LIST
33711: LIST
33712: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33713: LD_ADDR_VAR 0 35
33717: PUSH
33718: LD_INT 0
33720: PUSH
33721: LD_INT 0
33723: PUSH
33724: EMPTY
33725: LIST
33726: LIST
33727: PUSH
33728: LD_INT 0
33730: PUSH
33731: LD_INT 1
33733: NEG
33734: PUSH
33735: EMPTY
33736: LIST
33737: LIST
33738: PUSH
33739: LD_INT 1
33741: PUSH
33742: LD_INT 0
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 1
33751: PUSH
33752: LD_INT 1
33754: PUSH
33755: EMPTY
33756: LIST
33757: LIST
33758: PUSH
33759: LD_INT 0
33761: PUSH
33762: LD_INT 1
33764: PUSH
33765: EMPTY
33766: LIST
33767: LIST
33768: PUSH
33769: LD_INT 1
33771: NEG
33772: PUSH
33773: LD_INT 0
33775: PUSH
33776: EMPTY
33777: LIST
33778: LIST
33779: PUSH
33780: LD_INT 1
33782: NEG
33783: PUSH
33784: LD_INT 1
33786: NEG
33787: PUSH
33788: EMPTY
33789: LIST
33790: LIST
33791: PUSH
33792: LD_INT 2
33794: PUSH
33795: LD_INT 1
33797: PUSH
33798: EMPTY
33799: LIST
33800: LIST
33801: PUSH
33802: LD_INT 2
33804: NEG
33805: PUSH
33806: LD_INT 1
33808: NEG
33809: PUSH
33810: EMPTY
33811: LIST
33812: LIST
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: LIST
33818: LIST
33819: LIST
33820: LIST
33821: LIST
33822: LIST
33823: LIST
33824: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33825: LD_ADDR_VAR 0 36
33829: PUSH
33830: LD_INT 0
33832: PUSH
33833: LD_INT 0
33835: PUSH
33836: EMPTY
33837: LIST
33838: LIST
33839: PUSH
33840: LD_INT 0
33842: PUSH
33843: LD_INT 1
33845: NEG
33846: PUSH
33847: EMPTY
33848: LIST
33849: LIST
33850: PUSH
33851: LD_INT 1
33853: PUSH
33854: LD_INT 0
33856: PUSH
33857: EMPTY
33858: LIST
33859: LIST
33860: PUSH
33861: LD_INT 1
33863: PUSH
33864: LD_INT 1
33866: PUSH
33867: EMPTY
33868: LIST
33869: LIST
33870: PUSH
33871: LD_INT 0
33873: PUSH
33874: LD_INT 1
33876: PUSH
33877: EMPTY
33878: LIST
33879: LIST
33880: PUSH
33881: LD_INT 1
33883: NEG
33884: PUSH
33885: LD_INT 0
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 1
33894: NEG
33895: PUSH
33896: LD_INT 1
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 1
33906: NEG
33907: PUSH
33908: LD_INT 2
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: PUSH
33919: LD_INT 2
33921: PUSH
33922: EMPTY
33923: LIST
33924: LIST
33925: PUSH
33926: EMPTY
33927: LIST
33928: LIST
33929: LIST
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: LIST
33935: LIST
33936: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33937: LD_ADDR_VAR 0 37
33941: PUSH
33942: LD_INT 0
33944: PUSH
33945: LD_INT 0
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: LD_INT 0
33954: PUSH
33955: LD_INT 1
33957: NEG
33958: PUSH
33959: EMPTY
33960: LIST
33961: LIST
33962: PUSH
33963: LD_INT 1
33965: PUSH
33966: LD_INT 0
33968: PUSH
33969: EMPTY
33970: LIST
33971: LIST
33972: PUSH
33973: LD_INT 1
33975: PUSH
33976: LD_INT 1
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 0
33985: PUSH
33986: LD_INT 1
33988: PUSH
33989: EMPTY
33990: LIST
33991: LIST
33992: PUSH
33993: LD_INT 1
33995: NEG
33996: PUSH
33997: LD_INT 0
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: PUSH
34004: LD_INT 1
34006: NEG
34007: PUSH
34008: LD_INT 1
34010: NEG
34011: PUSH
34012: EMPTY
34013: LIST
34014: LIST
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: EMPTY
34024: LIST
34025: LIST
34026: PUSH
34027: LD_INT 1
34029: NEG
34030: PUSH
34031: LD_INT 1
34033: PUSH
34034: EMPTY
34035: LIST
34036: LIST
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: LIST
34042: LIST
34043: LIST
34044: LIST
34045: LIST
34046: LIST
34047: LIST
34048: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34049: LD_ADDR_VAR 0 38
34053: PUSH
34054: LD_INT 0
34056: PUSH
34057: LD_INT 0
34059: PUSH
34060: EMPTY
34061: LIST
34062: LIST
34063: PUSH
34064: LD_INT 0
34066: PUSH
34067: LD_INT 1
34069: NEG
34070: PUSH
34071: EMPTY
34072: LIST
34073: LIST
34074: PUSH
34075: LD_INT 1
34077: PUSH
34078: LD_INT 0
34080: PUSH
34081: EMPTY
34082: LIST
34083: LIST
34084: PUSH
34085: LD_INT 1
34087: PUSH
34088: LD_INT 1
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 1
34100: PUSH
34101: EMPTY
34102: LIST
34103: LIST
34104: PUSH
34105: LD_INT 1
34107: NEG
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: NEG
34119: PUSH
34120: LD_INT 1
34122: NEG
34123: PUSH
34124: EMPTY
34125: LIST
34126: LIST
34127: PUSH
34128: LD_INT 2
34130: PUSH
34131: LD_INT 1
34133: PUSH
34134: EMPTY
34135: LIST
34136: LIST
34137: PUSH
34138: LD_INT 2
34140: NEG
34141: PUSH
34142: LD_INT 1
34144: NEG
34145: PUSH
34146: EMPTY
34147: LIST
34148: LIST
34149: PUSH
34150: EMPTY
34151: LIST
34152: LIST
34153: LIST
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: LIST
34160: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34161: LD_ADDR_VAR 0 39
34165: PUSH
34166: LD_INT 0
34168: PUSH
34169: LD_INT 0
34171: PUSH
34172: EMPTY
34173: LIST
34174: LIST
34175: PUSH
34176: LD_INT 0
34178: PUSH
34179: LD_INT 1
34181: NEG
34182: PUSH
34183: EMPTY
34184: LIST
34185: LIST
34186: PUSH
34187: LD_INT 1
34189: PUSH
34190: LD_INT 0
34192: PUSH
34193: EMPTY
34194: LIST
34195: LIST
34196: PUSH
34197: LD_INT 1
34199: PUSH
34200: LD_INT 1
34202: PUSH
34203: EMPTY
34204: LIST
34205: LIST
34206: PUSH
34207: LD_INT 0
34209: PUSH
34210: LD_INT 1
34212: PUSH
34213: EMPTY
34214: LIST
34215: LIST
34216: PUSH
34217: LD_INT 1
34219: NEG
34220: PUSH
34221: LD_INT 0
34223: PUSH
34224: EMPTY
34225: LIST
34226: LIST
34227: PUSH
34228: LD_INT 1
34230: NEG
34231: PUSH
34232: LD_INT 1
34234: NEG
34235: PUSH
34236: EMPTY
34237: LIST
34238: LIST
34239: PUSH
34240: LD_INT 1
34242: NEG
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: EMPTY
34249: LIST
34250: LIST
34251: PUSH
34252: LD_INT 1
34254: PUSH
34255: LD_INT 2
34257: PUSH
34258: EMPTY
34259: LIST
34260: LIST
34261: PUSH
34262: EMPTY
34263: LIST
34264: LIST
34265: LIST
34266: LIST
34267: LIST
34268: LIST
34269: LIST
34270: LIST
34271: LIST
34272: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34273: LD_ADDR_VAR 0 40
34277: PUSH
34278: LD_INT 0
34280: PUSH
34281: LD_INT 0
34283: PUSH
34284: EMPTY
34285: LIST
34286: LIST
34287: PUSH
34288: LD_INT 0
34290: PUSH
34291: LD_INT 1
34293: NEG
34294: PUSH
34295: EMPTY
34296: LIST
34297: LIST
34298: PUSH
34299: LD_INT 1
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: EMPTY
34306: LIST
34307: LIST
34308: PUSH
34309: LD_INT 1
34311: PUSH
34312: LD_INT 1
34314: PUSH
34315: EMPTY
34316: LIST
34317: LIST
34318: PUSH
34319: LD_INT 0
34321: PUSH
34322: LD_INT 1
34324: PUSH
34325: EMPTY
34326: LIST
34327: LIST
34328: PUSH
34329: LD_INT 1
34331: NEG
34332: PUSH
34333: LD_INT 0
34335: PUSH
34336: EMPTY
34337: LIST
34338: LIST
34339: PUSH
34340: LD_INT 1
34342: NEG
34343: PUSH
34344: LD_INT 1
34346: NEG
34347: PUSH
34348: EMPTY
34349: LIST
34350: LIST
34351: PUSH
34352: LD_INT 1
34354: PUSH
34355: LD_INT 1
34357: NEG
34358: PUSH
34359: EMPTY
34360: LIST
34361: LIST
34362: PUSH
34363: LD_INT 1
34365: NEG
34366: PUSH
34367: LD_INT 1
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: EMPTY
34375: LIST
34376: LIST
34377: LIST
34378: LIST
34379: LIST
34380: LIST
34381: LIST
34382: LIST
34383: LIST
34384: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34385: LD_ADDR_VAR 0 41
34389: PUSH
34390: LD_INT 0
34392: PUSH
34393: LD_INT 0
34395: PUSH
34396: EMPTY
34397: LIST
34398: LIST
34399: PUSH
34400: LD_INT 0
34402: PUSH
34403: LD_INT 1
34405: NEG
34406: PUSH
34407: EMPTY
34408: LIST
34409: LIST
34410: PUSH
34411: LD_INT 1
34413: PUSH
34414: LD_INT 0
34416: PUSH
34417: EMPTY
34418: LIST
34419: LIST
34420: PUSH
34421: LD_INT 1
34423: PUSH
34424: LD_INT 1
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 0
34433: PUSH
34434: LD_INT 1
34436: PUSH
34437: EMPTY
34438: LIST
34439: LIST
34440: PUSH
34441: LD_INT 1
34443: NEG
34444: PUSH
34445: LD_INT 0
34447: PUSH
34448: EMPTY
34449: LIST
34450: LIST
34451: PUSH
34452: LD_INT 1
34454: NEG
34455: PUSH
34456: LD_INT 1
34458: NEG
34459: PUSH
34460: EMPTY
34461: LIST
34462: LIST
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: LD_INT 2
34470: NEG
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 1
34478: PUSH
34479: LD_INT 1
34481: NEG
34482: PUSH
34483: EMPTY
34484: LIST
34485: LIST
34486: PUSH
34487: LD_INT 2
34489: PUSH
34490: LD_INT 0
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 2
34499: PUSH
34500: LD_INT 1
34502: PUSH
34503: EMPTY
34504: LIST
34505: LIST
34506: PUSH
34507: LD_INT 2
34509: PUSH
34510: LD_INT 2
34512: PUSH
34513: EMPTY
34514: LIST
34515: LIST
34516: PUSH
34517: LD_INT 1
34519: PUSH
34520: LD_INT 2
34522: PUSH
34523: EMPTY
34524: LIST
34525: LIST
34526: PUSH
34527: LD_INT 1
34529: NEG
34530: PUSH
34531: LD_INT 1
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: PUSH
34538: LD_INT 2
34540: NEG
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 2
34551: NEG
34552: PUSH
34553: LD_INT 1
34555: NEG
34556: PUSH
34557: EMPTY
34558: LIST
34559: LIST
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: LD_INT 2
34567: NEG
34568: PUSH
34569: EMPTY
34570: LIST
34571: LIST
34572: PUSH
34573: LD_INT 2
34575: NEG
34576: PUSH
34577: LD_INT 3
34579: NEG
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 2
34587: PUSH
34588: LD_INT 1
34590: NEG
34591: PUSH
34592: EMPTY
34593: LIST
34594: LIST
34595: PUSH
34596: LD_INT 3
34598: PUSH
34599: LD_INT 0
34601: PUSH
34602: EMPTY
34603: LIST
34604: LIST
34605: PUSH
34606: LD_INT 3
34608: PUSH
34609: LD_INT 1
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: PUSH
34616: LD_INT 3
34618: PUSH
34619: LD_INT 2
34621: PUSH
34622: EMPTY
34623: LIST
34624: LIST
34625: PUSH
34626: LD_INT 3
34628: PUSH
34629: LD_INT 3
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: LD_INT 3
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: NEG
34649: PUSH
34650: LD_INT 1
34652: PUSH
34653: EMPTY
34654: LIST
34655: LIST
34656: PUSH
34657: LD_INT 3
34659: NEG
34660: PUSH
34661: LD_INT 0
34663: PUSH
34664: EMPTY
34665: LIST
34666: LIST
34667: PUSH
34668: LD_INT 3
34670: NEG
34671: PUSH
34672: LD_INT 1
34674: NEG
34675: PUSH
34676: EMPTY
34677: LIST
34678: LIST
34679: PUSH
34680: LD_INT 3
34682: NEG
34683: PUSH
34684: LD_INT 2
34686: NEG
34687: PUSH
34688: EMPTY
34689: LIST
34690: LIST
34691: PUSH
34692: LD_INT 3
34694: NEG
34695: PUSH
34696: LD_INT 3
34698: NEG
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: EMPTY
34705: LIST
34706: LIST
34707: LIST
34708: LIST
34709: LIST
34710: LIST
34711: LIST
34712: LIST
34713: LIST
34714: LIST
34715: LIST
34716: LIST
34717: LIST
34718: LIST
34719: LIST
34720: LIST
34721: LIST
34722: LIST
34723: LIST
34724: LIST
34725: LIST
34726: LIST
34727: LIST
34728: LIST
34729: LIST
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34735: LD_ADDR_VAR 0 42
34739: PUSH
34740: LD_INT 0
34742: PUSH
34743: LD_INT 0
34745: PUSH
34746: EMPTY
34747: LIST
34748: LIST
34749: PUSH
34750: LD_INT 0
34752: PUSH
34753: LD_INT 1
34755: NEG
34756: PUSH
34757: EMPTY
34758: LIST
34759: LIST
34760: PUSH
34761: LD_INT 1
34763: PUSH
34764: LD_INT 0
34766: PUSH
34767: EMPTY
34768: LIST
34769: LIST
34770: PUSH
34771: LD_INT 1
34773: PUSH
34774: LD_INT 1
34776: PUSH
34777: EMPTY
34778: LIST
34779: LIST
34780: PUSH
34781: LD_INT 0
34783: PUSH
34784: LD_INT 1
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: PUSH
34791: LD_INT 1
34793: NEG
34794: PUSH
34795: LD_INT 0
34797: PUSH
34798: EMPTY
34799: LIST
34800: LIST
34801: PUSH
34802: LD_INT 1
34804: NEG
34805: PUSH
34806: LD_INT 1
34808: NEG
34809: PUSH
34810: EMPTY
34811: LIST
34812: LIST
34813: PUSH
34814: LD_INT 1
34816: NEG
34817: PUSH
34818: LD_INT 2
34820: NEG
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PUSH
34826: LD_INT 0
34828: PUSH
34829: LD_INT 2
34831: NEG
34832: PUSH
34833: EMPTY
34834: LIST
34835: LIST
34836: PUSH
34837: LD_INT 1
34839: PUSH
34840: LD_INT 1
34842: NEG
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 2
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 2
34860: PUSH
34861: LD_INT 2
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: LD_INT 2
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 0
34880: PUSH
34881: LD_INT 2
34883: PUSH
34884: EMPTY
34885: LIST
34886: LIST
34887: PUSH
34888: LD_INT 1
34890: NEG
34891: PUSH
34892: LD_INT 1
34894: PUSH
34895: EMPTY
34896: LIST
34897: LIST
34898: PUSH
34899: LD_INT 2
34901: NEG
34902: PUSH
34903: LD_INT 1
34905: NEG
34906: PUSH
34907: EMPTY
34908: LIST
34909: LIST
34910: PUSH
34911: LD_INT 2
34913: NEG
34914: PUSH
34915: LD_INT 2
34917: NEG
34918: PUSH
34919: EMPTY
34920: LIST
34921: LIST
34922: PUSH
34923: LD_INT 2
34925: NEG
34926: PUSH
34927: LD_INT 3
34929: NEG
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 1
34937: NEG
34938: PUSH
34939: LD_INT 3
34941: NEG
34942: PUSH
34943: EMPTY
34944: LIST
34945: LIST
34946: PUSH
34947: LD_INT 0
34949: PUSH
34950: LD_INT 3
34952: NEG
34953: PUSH
34954: EMPTY
34955: LIST
34956: LIST
34957: PUSH
34958: LD_INT 1
34960: PUSH
34961: LD_INT 2
34963: NEG
34964: PUSH
34965: EMPTY
34966: LIST
34967: LIST
34968: PUSH
34969: LD_INT 3
34971: PUSH
34972: LD_INT 2
34974: PUSH
34975: EMPTY
34976: LIST
34977: LIST
34978: PUSH
34979: LD_INT 3
34981: PUSH
34982: LD_INT 3
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: PUSH
34989: LD_INT 2
34991: PUSH
34992: LD_INT 3
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: PUSH
35002: LD_INT 3
35004: PUSH
35005: EMPTY
35006: LIST
35007: LIST
35008: PUSH
35009: LD_INT 0
35011: PUSH
35012: LD_INT 3
35014: PUSH
35015: EMPTY
35016: LIST
35017: LIST
35018: PUSH
35019: LD_INT 1
35021: NEG
35022: PUSH
35023: LD_INT 2
35025: PUSH
35026: EMPTY
35027: LIST
35028: LIST
35029: PUSH
35030: LD_INT 3
35032: NEG
35033: PUSH
35034: LD_INT 2
35036: NEG
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 3
35044: NEG
35045: PUSH
35046: LD_INT 3
35048: NEG
35049: PUSH
35050: EMPTY
35051: LIST
35052: LIST
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: LIST
35058: LIST
35059: LIST
35060: LIST
35061: LIST
35062: LIST
35063: LIST
35064: LIST
35065: LIST
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35085: LD_ADDR_VAR 0 43
35089: PUSH
35090: LD_INT 0
35092: PUSH
35093: LD_INT 0
35095: PUSH
35096: EMPTY
35097: LIST
35098: LIST
35099: PUSH
35100: LD_INT 0
35102: PUSH
35103: LD_INT 1
35105: NEG
35106: PUSH
35107: EMPTY
35108: LIST
35109: LIST
35110: PUSH
35111: LD_INT 1
35113: PUSH
35114: LD_INT 0
35116: PUSH
35117: EMPTY
35118: LIST
35119: LIST
35120: PUSH
35121: LD_INT 1
35123: PUSH
35124: LD_INT 1
35126: PUSH
35127: EMPTY
35128: LIST
35129: LIST
35130: PUSH
35131: LD_INT 0
35133: PUSH
35134: LD_INT 1
35136: PUSH
35137: EMPTY
35138: LIST
35139: LIST
35140: PUSH
35141: LD_INT 1
35143: NEG
35144: PUSH
35145: LD_INT 0
35147: PUSH
35148: EMPTY
35149: LIST
35150: LIST
35151: PUSH
35152: LD_INT 1
35154: NEG
35155: PUSH
35156: LD_INT 1
35158: NEG
35159: PUSH
35160: EMPTY
35161: LIST
35162: LIST
35163: PUSH
35164: LD_INT 1
35166: NEG
35167: PUSH
35168: LD_INT 2
35170: NEG
35171: PUSH
35172: EMPTY
35173: LIST
35174: LIST
35175: PUSH
35176: LD_INT 0
35178: PUSH
35179: LD_INT 2
35181: NEG
35182: PUSH
35183: EMPTY
35184: LIST
35185: LIST
35186: PUSH
35187: LD_INT 1
35189: PUSH
35190: LD_INT 1
35192: NEG
35193: PUSH
35194: EMPTY
35195: LIST
35196: LIST
35197: PUSH
35198: LD_INT 2
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 2
35210: PUSH
35211: LD_INT 1
35213: PUSH
35214: EMPTY
35215: LIST
35216: LIST
35217: PUSH
35218: LD_INT 1
35220: PUSH
35221: LD_INT 2
35223: PUSH
35224: EMPTY
35225: LIST
35226: LIST
35227: PUSH
35228: LD_INT 0
35230: PUSH
35231: LD_INT 2
35233: PUSH
35234: EMPTY
35235: LIST
35236: LIST
35237: PUSH
35238: LD_INT 1
35240: NEG
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 2
35251: NEG
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 2
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 3
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 0
35286: PUSH
35287: LD_INT 3
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 1
35297: PUSH
35298: LD_INT 2
35300: NEG
35301: PUSH
35302: EMPTY
35303: LIST
35304: LIST
35305: PUSH
35306: LD_INT 2
35308: PUSH
35309: LD_INT 1
35311: NEG
35312: PUSH
35313: EMPTY
35314: LIST
35315: LIST
35316: PUSH
35317: LD_INT 3
35319: PUSH
35320: LD_INT 0
35322: PUSH
35323: EMPTY
35324: LIST
35325: LIST
35326: PUSH
35327: LD_INT 3
35329: PUSH
35330: LD_INT 1
35332: PUSH
35333: EMPTY
35334: LIST
35335: LIST
35336: PUSH
35337: LD_INT 1
35339: PUSH
35340: LD_INT 3
35342: PUSH
35343: EMPTY
35344: LIST
35345: LIST
35346: PUSH
35347: LD_INT 0
35349: PUSH
35350: LD_INT 3
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 1
35359: NEG
35360: PUSH
35361: LD_INT 2
35363: PUSH
35364: EMPTY
35365: LIST
35366: LIST
35367: PUSH
35368: LD_INT 2
35370: NEG
35371: PUSH
35372: LD_INT 1
35374: PUSH
35375: EMPTY
35376: LIST
35377: LIST
35378: PUSH
35379: LD_INT 3
35381: NEG
35382: PUSH
35383: LD_INT 0
35385: PUSH
35386: EMPTY
35387: LIST
35388: LIST
35389: PUSH
35390: LD_INT 3
35392: NEG
35393: PUSH
35394: LD_INT 1
35396: NEG
35397: PUSH
35398: EMPTY
35399: LIST
35400: LIST
35401: PUSH
35402: EMPTY
35403: LIST
35404: LIST
35405: LIST
35406: LIST
35407: LIST
35408: LIST
35409: LIST
35410: LIST
35411: LIST
35412: LIST
35413: LIST
35414: LIST
35415: LIST
35416: LIST
35417: LIST
35418: LIST
35419: LIST
35420: LIST
35421: LIST
35422: LIST
35423: LIST
35424: LIST
35425: LIST
35426: LIST
35427: LIST
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35433: LD_ADDR_VAR 0 44
35437: PUSH
35438: LD_INT 0
35440: PUSH
35441: LD_INT 0
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 0
35450: PUSH
35451: LD_INT 1
35453: NEG
35454: PUSH
35455: EMPTY
35456: LIST
35457: LIST
35458: PUSH
35459: LD_INT 1
35461: PUSH
35462: LD_INT 0
35464: PUSH
35465: EMPTY
35466: LIST
35467: LIST
35468: PUSH
35469: LD_INT 1
35471: PUSH
35472: LD_INT 1
35474: PUSH
35475: EMPTY
35476: LIST
35477: LIST
35478: PUSH
35479: LD_INT 0
35481: PUSH
35482: LD_INT 1
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: LD_INT 1
35491: NEG
35492: PUSH
35493: LD_INT 0
35495: PUSH
35496: EMPTY
35497: LIST
35498: LIST
35499: PUSH
35500: LD_INT 1
35502: NEG
35503: PUSH
35504: LD_INT 1
35506: NEG
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 2
35518: NEG
35519: PUSH
35520: EMPTY
35521: LIST
35522: LIST
35523: PUSH
35524: LD_INT 1
35526: PUSH
35527: LD_INT 1
35529: NEG
35530: PUSH
35531: EMPTY
35532: LIST
35533: LIST
35534: PUSH
35535: LD_INT 2
35537: PUSH
35538: LD_INT 0
35540: PUSH
35541: EMPTY
35542: LIST
35543: LIST
35544: PUSH
35545: LD_INT 2
35547: PUSH
35548: LD_INT 1
35550: PUSH
35551: EMPTY
35552: LIST
35553: LIST
35554: PUSH
35555: LD_INT 2
35557: PUSH
35558: LD_INT 2
35560: PUSH
35561: EMPTY
35562: LIST
35563: LIST
35564: PUSH
35565: LD_INT 1
35567: PUSH
35568: LD_INT 2
35570: PUSH
35571: EMPTY
35572: LIST
35573: LIST
35574: PUSH
35575: LD_INT 1
35577: NEG
35578: PUSH
35579: LD_INT 1
35581: PUSH
35582: EMPTY
35583: LIST
35584: LIST
35585: PUSH
35586: LD_INT 2
35588: NEG
35589: PUSH
35590: LD_INT 0
35592: PUSH
35593: EMPTY
35594: LIST
35595: LIST
35596: PUSH
35597: LD_INT 2
35599: NEG
35600: PUSH
35601: LD_INT 1
35603: NEG
35604: PUSH
35605: EMPTY
35606: LIST
35607: LIST
35608: PUSH
35609: LD_INT 2
35611: NEG
35612: PUSH
35613: LD_INT 2
35615: NEG
35616: PUSH
35617: EMPTY
35618: LIST
35619: LIST
35620: PUSH
35621: LD_INT 2
35623: NEG
35624: PUSH
35625: LD_INT 3
35627: NEG
35628: PUSH
35629: EMPTY
35630: LIST
35631: LIST
35632: PUSH
35633: LD_INT 2
35635: PUSH
35636: LD_INT 1
35638: NEG
35639: PUSH
35640: EMPTY
35641: LIST
35642: LIST
35643: PUSH
35644: LD_INT 3
35646: PUSH
35647: LD_INT 0
35649: PUSH
35650: EMPTY
35651: LIST
35652: LIST
35653: PUSH
35654: LD_INT 3
35656: PUSH
35657: LD_INT 1
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 3
35666: PUSH
35667: LD_INT 2
35669: PUSH
35670: EMPTY
35671: LIST
35672: LIST
35673: PUSH
35674: LD_INT 3
35676: PUSH
35677: LD_INT 3
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 2
35686: PUSH
35687: LD_INT 3
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 2
35696: NEG
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 3
35707: NEG
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 3
35718: NEG
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 3
35730: NEG
35731: PUSH
35732: LD_INT 2
35734: NEG
35735: PUSH
35736: EMPTY
35737: LIST
35738: LIST
35739: PUSH
35740: LD_INT 3
35742: NEG
35743: PUSH
35744: LD_INT 3
35746: NEG
35747: PUSH
35748: EMPTY
35749: LIST
35750: LIST
35751: PUSH
35752: EMPTY
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: LIST
35761: LIST
35762: LIST
35763: LIST
35764: LIST
35765: LIST
35766: LIST
35767: LIST
35768: LIST
35769: LIST
35770: LIST
35771: LIST
35772: LIST
35773: LIST
35774: LIST
35775: LIST
35776: LIST
35777: LIST
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35783: LD_ADDR_VAR 0 45
35787: PUSH
35788: LD_INT 0
35790: PUSH
35791: LD_INT 0
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: LD_INT 1
35803: NEG
35804: PUSH
35805: EMPTY
35806: LIST
35807: LIST
35808: PUSH
35809: LD_INT 1
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: PUSH
35822: LD_INT 1
35824: PUSH
35825: EMPTY
35826: LIST
35827: LIST
35828: PUSH
35829: LD_INT 0
35831: PUSH
35832: LD_INT 1
35834: PUSH
35835: EMPTY
35836: LIST
35837: LIST
35838: PUSH
35839: LD_INT 1
35841: NEG
35842: PUSH
35843: LD_INT 0
35845: PUSH
35846: EMPTY
35847: LIST
35848: LIST
35849: PUSH
35850: LD_INT 1
35852: NEG
35853: PUSH
35854: LD_INT 1
35856: NEG
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: LD_INT 1
35864: NEG
35865: PUSH
35866: LD_INT 2
35868: NEG
35869: PUSH
35870: EMPTY
35871: LIST
35872: LIST
35873: PUSH
35874: LD_INT 0
35876: PUSH
35877: LD_INT 2
35879: NEG
35880: PUSH
35881: EMPTY
35882: LIST
35883: LIST
35884: PUSH
35885: LD_INT 1
35887: PUSH
35888: LD_INT 1
35890: NEG
35891: PUSH
35892: EMPTY
35893: LIST
35894: LIST
35895: PUSH
35896: LD_INT 2
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: LD_INT 2
35908: PUSH
35909: LD_INT 2
35911: PUSH
35912: EMPTY
35913: LIST
35914: LIST
35915: PUSH
35916: LD_INT 1
35918: PUSH
35919: LD_INT 2
35921: PUSH
35922: EMPTY
35923: LIST
35924: LIST
35925: PUSH
35926: LD_INT 0
35928: PUSH
35929: LD_INT 2
35931: PUSH
35932: EMPTY
35933: LIST
35934: LIST
35935: PUSH
35936: LD_INT 1
35938: NEG
35939: PUSH
35940: LD_INT 1
35942: PUSH
35943: EMPTY
35944: LIST
35945: LIST
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: LD_INT 1
35953: NEG
35954: PUSH
35955: EMPTY
35956: LIST
35957: LIST
35958: PUSH
35959: LD_INT 2
35961: NEG
35962: PUSH
35963: LD_INT 2
35965: NEG
35966: PUSH
35967: EMPTY
35968: LIST
35969: LIST
35970: PUSH
35971: LD_INT 2
35973: NEG
35974: PUSH
35975: LD_INT 3
35977: NEG
35978: PUSH
35979: EMPTY
35980: LIST
35981: LIST
35982: PUSH
35983: LD_INT 1
35985: NEG
35986: PUSH
35987: LD_INT 3
35989: NEG
35990: PUSH
35991: EMPTY
35992: LIST
35993: LIST
35994: PUSH
35995: LD_INT 0
35997: PUSH
35998: LD_INT 3
36000: NEG
36001: PUSH
36002: EMPTY
36003: LIST
36004: LIST
36005: PUSH
36006: LD_INT 1
36008: PUSH
36009: LD_INT 2
36011: NEG
36012: PUSH
36013: EMPTY
36014: LIST
36015: LIST
36016: PUSH
36017: LD_INT 3
36019: PUSH
36020: LD_INT 2
36022: PUSH
36023: EMPTY
36024: LIST
36025: LIST
36026: PUSH
36027: LD_INT 3
36029: PUSH
36030: LD_INT 3
36032: PUSH
36033: EMPTY
36034: LIST
36035: LIST
36036: PUSH
36037: LD_INT 2
36039: PUSH
36040: LD_INT 3
36042: PUSH
36043: EMPTY
36044: LIST
36045: LIST
36046: PUSH
36047: LD_INT 1
36049: PUSH
36050: LD_INT 3
36052: PUSH
36053: EMPTY
36054: LIST
36055: LIST
36056: PUSH
36057: LD_INT 0
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PUSH
36067: LD_INT 1
36069: NEG
36070: PUSH
36071: LD_INT 2
36073: PUSH
36074: EMPTY
36075: LIST
36076: LIST
36077: PUSH
36078: LD_INT 3
36080: NEG
36081: PUSH
36082: LD_INT 2
36084: NEG
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: PUSH
36090: LD_INT 3
36092: NEG
36093: PUSH
36094: LD_INT 3
36096: NEG
36097: PUSH
36098: EMPTY
36099: LIST
36100: LIST
36101: PUSH
36102: EMPTY
36103: LIST
36104: LIST
36105: LIST
36106: LIST
36107: LIST
36108: LIST
36109: LIST
36110: LIST
36111: LIST
36112: LIST
36113: LIST
36114: LIST
36115: LIST
36116: LIST
36117: LIST
36118: LIST
36119: LIST
36120: LIST
36121: LIST
36122: LIST
36123: LIST
36124: LIST
36125: LIST
36126: LIST
36127: LIST
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36133: LD_ADDR_VAR 0 46
36137: PUSH
36138: LD_INT 0
36140: PUSH
36141: LD_INT 0
36143: PUSH
36144: EMPTY
36145: LIST
36146: LIST
36147: PUSH
36148: LD_INT 0
36150: PUSH
36151: LD_INT 1
36153: NEG
36154: PUSH
36155: EMPTY
36156: LIST
36157: LIST
36158: PUSH
36159: LD_INT 1
36161: PUSH
36162: LD_INT 0
36164: PUSH
36165: EMPTY
36166: LIST
36167: LIST
36168: PUSH
36169: LD_INT 1
36171: PUSH
36172: LD_INT 1
36174: PUSH
36175: EMPTY
36176: LIST
36177: LIST
36178: PUSH
36179: LD_INT 0
36181: PUSH
36182: LD_INT 1
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: LD_INT 1
36191: NEG
36192: PUSH
36193: LD_INT 0
36195: PUSH
36196: EMPTY
36197: LIST
36198: LIST
36199: PUSH
36200: LD_INT 1
36202: NEG
36203: PUSH
36204: LD_INT 1
36206: NEG
36207: PUSH
36208: EMPTY
36209: LIST
36210: LIST
36211: PUSH
36212: LD_INT 1
36214: NEG
36215: PUSH
36216: LD_INT 2
36218: NEG
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 2
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 1
36240: NEG
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 2
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 2
36258: PUSH
36259: LD_INT 1
36261: PUSH
36262: EMPTY
36263: LIST
36264: LIST
36265: PUSH
36266: LD_INT 1
36268: PUSH
36269: LD_INT 2
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 0
36278: PUSH
36279: LD_INT 2
36281: PUSH
36282: EMPTY
36283: LIST
36284: LIST
36285: PUSH
36286: LD_INT 1
36288: NEG
36289: PUSH
36290: LD_INT 1
36292: PUSH
36293: EMPTY
36294: LIST
36295: LIST
36296: PUSH
36297: LD_INT 2
36299: NEG
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: EMPTY
36305: LIST
36306: LIST
36307: PUSH
36308: LD_INT 2
36310: NEG
36311: PUSH
36312: LD_INT 1
36314: NEG
36315: PUSH
36316: EMPTY
36317: LIST
36318: LIST
36319: PUSH
36320: LD_INT 1
36322: NEG
36323: PUSH
36324: LD_INT 3
36326: NEG
36327: PUSH
36328: EMPTY
36329: LIST
36330: LIST
36331: PUSH
36332: LD_INT 0
36334: PUSH
36335: LD_INT 3
36337: NEG
36338: PUSH
36339: EMPTY
36340: LIST
36341: LIST
36342: PUSH
36343: LD_INT 1
36345: PUSH
36346: LD_INT 2
36348: NEG
36349: PUSH
36350: EMPTY
36351: LIST
36352: LIST
36353: PUSH
36354: LD_INT 2
36356: PUSH
36357: LD_INT 1
36359: NEG
36360: PUSH
36361: EMPTY
36362: LIST
36363: LIST
36364: PUSH
36365: LD_INT 3
36367: PUSH
36368: LD_INT 0
36370: PUSH
36371: EMPTY
36372: LIST
36373: LIST
36374: PUSH
36375: LD_INT 3
36377: PUSH
36378: LD_INT 1
36380: PUSH
36381: EMPTY
36382: LIST
36383: LIST
36384: PUSH
36385: LD_INT 1
36387: PUSH
36388: LD_INT 3
36390: PUSH
36391: EMPTY
36392: LIST
36393: LIST
36394: PUSH
36395: LD_INT 0
36397: PUSH
36398: LD_INT 3
36400: PUSH
36401: EMPTY
36402: LIST
36403: LIST
36404: PUSH
36405: LD_INT 1
36407: NEG
36408: PUSH
36409: LD_INT 2
36411: PUSH
36412: EMPTY
36413: LIST
36414: LIST
36415: PUSH
36416: LD_INT 2
36418: NEG
36419: PUSH
36420: LD_INT 1
36422: PUSH
36423: EMPTY
36424: LIST
36425: LIST
36426: PUSH
36427: LD_INT 3
36429: NEG
36430: PUSH
36431: LD_INT 0
36433: PUSH
36434: EMPTY
36435: LIST
36436: LIST
36437: PUSH
36438: LD_INT 3
36440: NEG
36441: PUSH
36442: LD_INT 1
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: EMPTY
36451: LIST
36452: LIST
36453: LIST
36454: LIST
36455: LIST
36456: LIST
36457: LIST
36458: LIST
36459: LIST
36460: LIST
36461: LIST
36462: LIST
36463: LIST
36464: LIST
36465: LIST
36466: LIST
36467: LIST
36468: LIST
36469: LIST
36470: LIST
36471: LIST
36472: LIST
36473: LIST
36474: LIST
36475: LIST
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36481: LD_ADDR_VAR 0 47
36485: PUSH
36486: LD_INT 0
36488: PUSH
36489: LD_INT 0
36491: PUSH
36492: EMPTY
36493: LIST
36494: LIST
36495: PUSH
36496: LD_INT 0
36498: PUSH
36499: LD_INT 1
36501: NEG
36502: PUSH
36503: EMPTY
36504: LIST
36505: LIST
36506: PUSH
36507: LD_INT 1
36509: PUSH
36510: LD_INT 0
36512: PUSH
36513: EMPTY
36514: LIST
36515: LIST
36516: PUSH
36517: LD_INT 1
36519: PUSH
36520: LD_INT 1
36522: PUSH
36523: EMPTY
36524: LIST
36525: LIST
36526: PUSH
36527: LD_INT 0
36529: PUSH
36530: LD_INT 1
36532: PUSH
36533: EMPTY
36534: LIST
36535: LIST
36536: PUSH
36537: LD_INT 1
36539: NEG
36540: PUSH
36541: LD_INT 0
36543: PUSH
36544: EMPTY
36545: LIST
36546: LIST
36547: PUSH
36548: LD_INT 1
36550: NEG
36551: PUSH
36552: LD_INT 1
36554: NEG
36555: PUSH
36556: EMPTY
36557: LIST
36558: LIST
36559: PUSH
36560: LD_INT 1
36562: NEG
36563: PUSH
36564: LD_INT 2
36566: NEG
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 0
36574: PUSH
36575: LD_INT 2
36577: NEG
36578: PUSH
36579: EMPTY
36580: LIST
36581: LIST
36582: PUSH
36583: LD_INT 1
36585: PUSH
36586: LD_INT 1
36588: NEG
36589: PUSH
36590: EMPTY
36591: LIST
36592: LIST
36593: PUSH
36594: LD_INT 2
36596: NEG
36597: PUSH
36598: LD_INT 1
36600: NEG
36601: PUSH
36602: EMPTY
36603: LIST
36604: LIST
36605: PUSH
36606: LD_INT 2
36608: NEG
36609: PUSH
36610: LD_INT 2
36612: NEG
36613: PUSH
36614: EMPTY
36615: LIST
36616: LIST
36617: PUSH
36618: EMPTY
36619: LIST
36620: LIST
36621: LIST
36622: LIST
36623: LIST
36624: LIST
36625: LIST
36626: LIST
36627: LIST
36628: LIST
36629: LIST
36630: LIST
36631: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36632: LD_ADDR_VAR 0 48
36636: PUSH
36637: LD_INT 0
36639: PUSH
36640: LD_INT 0
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: PUSH
36647: LD_INT 0
36649: PUSH
36650: LD_INT 1
36652: NEG
36653: PUSH
36654: EMPTY
36655: LIST
36656: LIST
36657: PUSH
36658: LD_INT 1
36660: PUSH
36661: LD_INT 0
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: PUSH
36668: LD_INT 1
36670: PUSH
36671: LD_INT 1
36673: PUSH
36674: EMPTY
36675: LIST
36676: LIST
36677: PUSH
36678: LD_INT 0
36680: PUSH
36681: LD_INT 1
36683: PUSH
36684: EMPTY
36685: LIST
36686: LIST
36687: PUSH
36688: LD_INT 1
36690: NEG
36691: PUSH
36692: LD_INT 0
36694: PUSH
36695: EMPTY
36696: LIST
36697: LIST
36698: PUSH
36699: LD_INT 1
36701: NEG
36702: PUSH
36703: LD_INT 1
36705: NEG
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: LD_INT 2
36717: NEG
36718: PUSH
36719: EMPTY
36720: LIST
36721: LIST
36722: PUSH
36723: LD_INT 0
36725: PUSH
36726: LD_INT 2
36728: NEG
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 1
36736: PUSH
36737: LD_INT 1
36739: NEG
36740: PUSH
36741: EMPTY
36742: LIST
36743: LIST
36744: PUSH
36745: LD_INT 2
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: PUSH
36755: LD_INT 2
36757: PUSH
36758: LD_INT 1
36760: PUSH
36761: EMPTY
36762: LIST
36763: LIST
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: LIST
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36779: LD_ADDR_VAR 0 49
36783: PUSH
36784: LD_INT 0
36786: PUSH
36787: LD_INT 0
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 0
36796: PUSH
36797: LD_INT 1
36799: NEG
36800: PUSH
36801: EMPTY
36802: LIST
36803: LIST
36804: PUSH
36805: LD_INT 1
36807: PUSH
36808: LD_INT 0
36810: PUSH
36811: EMPTY
36812: LIST
36813: LIST
36814: PUSH
36815: LD_INT 1
36817: PUSH
36818: LD_INT 1
36820: PUSH
36821: EMPTY
36822: LIST
36823: LIST
36824: PUSH
36825: LD_INT 0
36827: PUSH
36828: LD_INT 1
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 1
36837: NEG
36838: PUSH
36839: LD_INT 0
36841: PUSH
36842: EMPTY
36843: LIST
36844: LIST
36845: PUSH
36846: LD_INT 1
36848: NEG
36849: PUSH
36850: LD_INT 1
36852: NEG
36853: PUSH
36854: EMPTY
36855: LIST
36856: LIST
36857: PUSH
36858: LD_INT 1
36860: PUSH
36861: LD_INT 1
36863: NEG
36864: PUSH
36865: EMPTY
36866: LIST
36867: LIST
36868: PUSH
36869: LD_INT 2
36871: PUSH
36872: LD_INT 0
36874: PUSH
36875: EMPTY
36876: LIST
36877: LIST
36878: PUSH
36879: LD_INT 2
36881: PUSH
36882: LD_INT 1
36884: PUSH
36885: EMPTY
36886: LIST
36887: LIST
36888: PUSH
36889: LD_INT 2
36891: PUSH
36892: LD_INT 2
36894: PUSH
36895: EMPTY
36896: LIST
36897: LIST
36898: PUSH
36899: LD_INT 1
36901: PUSH
36902: LD_INT 2
36904: PUSH
36905: EMPTY
36906: LIST
36907: LIST
36908: PUSH
36909: EMPTY
36910: LIST
36911: LIST
36912: LIST
36913: LIST
36914: LIST
36915: LIST
36916: LIST
36917: LIST
36918: LIST
36919: LIST
36920: LIST
36921: LIST
36922: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36923: LD_ADDR_VAR 0 50
36927: PUSH
36928: LD_INT 0
36930: PUSH
36931: LD_INT 0
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 0
36940: PUSH
36941: LD_INT 1
36943: NEG
36944: PUSH
36945: EMPTY
36946: LIST
36947: LIST
36948: PUSH
36949: LD_INT 1
36951: PUSH
36952: LD_INT 0
36954: PUSH
36955: EMPTY
36956: LIST
36957: LIST
36958: PUSH
36959: LD_INT 1
36961: PUSH
36962: LD_INT 1
36964: PUSH
36965: EMPTY
36966: LIST
36967: LIST
36968: PUSH
36969: LD_INT 0
36971: PUSH
36972: LD_INT 1
36974: PUSH
36975: EMPTY
36976: LIST
36977: LIST
36978: PUSH
36979: LD_INT 1
36981: NEG
36982: PUSH
36983: LD_INT 0
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: LD_INT 1
36992: NEG
36993: PUSH
36994: LD_INT 1
36996: NEG
36997: PUSH
36998: EMPTY
36999: LIST
37000: LIST
37001: PUSH
37002: LD_INT 2
37004: PUSH
37005: LD_INT 1
37007: PUSH
37008: EMPTY
37009: LIST
37010: LIST
37011: PUSH
37012: LD_INT 2
37014: PUSH
37015: LD_INT 2
37017: PUSH
37018: EMPTY
37019: LIST
37020: LIST
37021: PUSH
37022: LD_INT 1
37024: PUSH
37025: LD_INT 2
37027: PUSH
37028: EMPTY
37029: LIST
37030: LIST
37031: PUSH
37032: LD_INT 0
37034: PUSH
37035: LD_INT 2
37037: PUSH
37038: EMPTY
37039: LIST
37040: LIST
37041: PUSH
37042: LD_INT 1
37044: NEG
37045: PUSH
37046: LD_INT 1
37048: PUSH
37049: EMPTY
37050: LIST
37051: LIST
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: LIST
37057: LIST
37058: LIST
37059: LIST
37060: LIST
37061: LIST
37062: LIST
37063: LIST
37064: LIST
37065: LIST
37066: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37067: LD_ADDR_VAR 0 51
37071: PUSH
37072: LD_INT 0
37074: PUSH
37075: LD_INT 0
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: PUSH
37082: LD_INT 0
37084: PUSH
37085: LD_INT 1
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: LD_INT 1
37095: PUSH
37096: LD_INT 0
37098: PUSH
37099: EMPTY
37100: LIST
37101: LIST
37102: PUSH
37103: LD_INT 1
37105: PUSH
37106: LD_INT 1
37108: PUSH
37109: EMPTY
37110: LIST
37111: LIST
37112: PUSH
37113: LD_INT 0
37115: PUSH
37116: LD_INT 1
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: NEG
37126: PUSH
37127: LD_INT 0
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 1
37136: NEG
37137: PUSH
37138: LD_INT 1
37140: NEG
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PUSH
37146: LD_INT 1
37148: PUSH
37149: LD_INT 2
37151: PUSH
37152: EMPTY
37153: LIST
37154: LIST
37155: PUSH
37156: LD_INT 0
37158: PUSH
37159: LD_INT 2
37161: PUSH
37162: EMPTY
37163: LIST
37164: LIST
37165: PUSH
37166: LD_INT 1
37168: NEG
37169: PUSH
37170: LD_INT 1
37172: PUSH
37173: EMPTY
37174: LIST
37175: LIST
37176: PUSH
37177: LD_INT 2
37179: NEG
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: EMPTY
37185: LIST
37186: LIST
37187: PUSH
37188: LD_INT 2
37190: NEG
37191: PUSH
37192: LD_INT 1
37194: NEG
37195: PUSH
37196: EMPTY
37197: LIST
37198: LIST
37199: PUSH
37200: EMPTY
37201: LIST
37202: LIST
37203: LIST
37204: LIST
37205: LIST
37206: LIST
37207: LIST
37208: LIST
37209: LIST
37210: LIST
37211: LIST
37212: LIST
37213: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37214: LD_ADDR_VAR 0 52
37218: PUSH
37219: LD_INT 0
37221: PUSH
37222: LD_INT 0
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: PUSH
37229: LD_INT 0
37231: PUSH
37232: LD_INT 1
37234: NEG
37235: PUSH
37236: EMPTY
37237: LIST
37238: LIST
37239: PUSH
37240: LD_INT 1
37242: PUSH
37243: LD_INT 0
37245: PUSH
37246: EMPTY
37247: LIST
37248: LIST
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: LD_INT 1
37255: PUSH
37256: EMPTY
37257: LIST
37258: LIST
37259: PUSH
37260: LD_INT 0
37262: PUSH
37263: LD_INT 1
37265: PUSH
37266: EMPTY
37267: LIST
37268: LIST
37269: PUSH
37270: LD_INT 1
37272: NEG
37273: PUSH
37274: LD_INT 0
37276: PUSH
37277: EMPTY
37278: LIST
37279: LIST
37280: PUSH
37281: LD_INT 1
37283: NEG
37284: PUSH
37285: LD_INT 1
37287: NEG
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: NEG
37296: PUSH
37297: LD_INT 2
37299: NEG
37300: PUSH
37301: EMPTY
37302: LIST
37303: LIST
37304: PUSH
37305: LD_INT 1
37307: NEG
37308: PUSH
37309: LD_INT 1
37311: PUSH
37312: EMPTY
37313: LIST
37314: LIST
37315: PUSH
37316: LD_INT 2
37318: NEG
37319: PUSH
37320: LD_INT 0
37322: PUSH
37323: EMPTY
37324: LIST
37325: LIST
37326: PUSH
37327: LD_INT 2
37329: NEG
37330: PUSH
37331: LD_INT 1
37333: NEG
37334: PUSH
37335: EMPTY
37336: LIST
37337: LIST
37338: PUSH
37339: LD_INT 2
37341: NEG
37342: PUSH
37343: LD_INT 2
37345: NEG
37346: PUSH
37347: EMPTY
37348: LIST
37349: LIST
37350: PUSH
37351: EMPTY
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37365: LD_ADDR_VAR 0 53
37369: PUSH
37370: LD_INT 0
37372: PUSH
37373: LD_INT 0
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: PUSH
37380: LD_INT 0
37382: PUSH
37383: LD_INT 1
37385: NEG
37386: PUSH
37387: EMPTY
37388: LIST
37389: LIST
37390: PUSH
37391: LD_INT 1
37393: PUSH
37394: LD_INT 0
37396: PUSH
37397: EMPTY
37398: LIST
37399: LIST
37400: PUSH
37401: LD_INT 1
37403: PUSH
37404: LD_INT 1
37406: PUSH
37407: EMPTY
37408: LIST
37409: LIST
37410: PUSH
37411: LD_INT 0
37413: PUSH
37414: LD_INT 1
37416: PUSH
37417: EMPTY
37418: LIST
37419: LIST
37420: PUSH
37421: LD_INT 1
37423: NEG
37424: PUSH
37425: LD_INT 0
37427: PUSH
37428: EMPTY
37429: LIST
37430: LIST
37431: PUSH
37432: LD_INT 1
37434: NEG
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: EMPTY
37441: LIST
37442: LIST
37443: PUSH
37444: LD_INT 1
37446: NEG
37447: PUSH
37448: LD_INT 2
37450: NEG
37451: PUSH
37452: EMPTY
37453: LIST
37454: LIST
37455: PUSH
37456: LD_INT 0
37458: PUSH
37459: LD_INT 2
37461: NEG
37462: PUSH
37463: EMPTY
37464: LIST
37465: LIST
37466: PUSH
37467: LD_INT 1
37469: PUSH
37470: LD_INT 1
37472: NEG
37473: PUSH
37474: EMPTY
37475: LIST
37476: LIST
37477: PUSH
37478: LD_INT 2
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: EMPTY
37485: LIST
37486: LIST
37487: PUSH
37488: LD_INT 2
37490: PUSH
37491: LD_INT 1
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 2
37500: PUSH
37501: LD_INT 2
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 2
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 2
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 1
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 2
37541: NEG
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: EMPTY
37547: LIST
37548: LIST
37549: PUSH
37550: LD_INT 2
37552: NEG
37553: PUSH
37554: LD_INT 1
37556: NEG
37557: PUSH
37558: EMPTY
37559: LIST
37560: LIST
37561: PUSH
37562: LD_INT 2
37564: NEG
37565: PUSH
37566: LD_INT 2
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: EMPTY
37575: LIST
37576: LIST
37577: LIST
37578: LIST
37579: LIST
37580: LIST
37581: LIST
37582: LIST
37583: LIST
37584: LIST
37585: LIST
37586: LIST
37587: LIST
37588: LIST
37589: LIST
37590: LIST
37591: LIST
37592: LIST
37593: LIST
37594: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37595: LD_ADDR_VAR 0 54
37599: PUSH
37600: LD_INT 0
37602: PUSH
37603: LD_INT 0
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 0
37612: PUSH
37613: LD_INT 1
37615: NEG
37616: PUSH
37617: EMPTY
37618: LIST
37619: LIST
37620: PUSH
37621: LD_INT 1
37623: PUSH
37624: LD_INT 0
37626: PUSH
37627: EMPTY
37628: LIST
37629: LIST
37630: PUSH
37631: LD_INT 1
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 0
37643: PUSH
37644: LD_INT 1
37646: PUSH
37647: EMPTY
37648: LIST
37649: LIST
37650: PUSH
37651: LD_INT 1
37653: NEG
37654: PUSH
37655: LD_INT 0
37657: PUSH
37658: EMPTY
37659: LIST
37660: LIST
37661: PUSH
37662: LD_INT 1
37664: NEG
37665: PUSH
37666: LD_INT 1
37668: NEG
37669: PUSH
37670: EMPTY
37671: LIST
37672: LIST
37673: PUSH
37674: LD_INT 1
37676: NEG
37677: PUSH
37678: LD_INT 2
37680: NEG
37681: PUSH
37682: EMPTY
37683: LIST
37684: LIST
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: LD_INT 2
37691: NEG
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 1
37699: PUSH
37700: LD_INT 1
37702: NEG
37703: PUSH
37704: EMPTY
37705: LIST
37706: LIST
37707: PUSH
37708: LD_INT 2
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: EMPTY
37715: LIST
37716: LIST
37717: PUSH
37718: LD_INT 2
37720: PUSH
37721: LD_INT 1
37723: PUSH
37724: EMPTY
37725: LIST
37726: LIST
37727: PUSH
37728: LD_INT 2
37730: PUSH
37731: LD_INT 2
37733: PUSH
37734: EMPTY
37735: LIST
37736: LIST
37737: PUSH
37738: LD_INT 1
37740: PUSH
37741: LD_INT 2
37743: PUSH
37744: EMPTY
37745: LIST
37746: LIST
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: LD_INT 2
37753: PUSH
37754: EMPTY
37755: LIST
37756: LIST
37757: PUSH
37758: LD_INT 1
37760: NEG
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: LD_INT 2
37771: NEG
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: EMPTY
37777: LIST
37778: LIST
37779: PUSH
37780: LD_INT 2
37782: NEG
37783: PUSH
37784: LD_INT 1
37786: NEG
37787: PUSH
37788: EMPTY
37789: LIST
37790: LIST
37791: PUSH
37792: LD_INT 2
37794: NEG
37795: PUSH
37796: LD_INT 2
37798: NEG
37799: PUSH
37800: EMPTY
37801: LIST
37802: LIST
37803: PUSH
37804: EMPTY
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: LIST
37822: LIST
37823: LIST
37824: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37825: LD_ADDR_VAR 0 55
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: LD_INT 0
37835: PUSH
37836: EMPTY
37837: LIST
37838: LIST
37839: PUSH
37840: LD_INT 0
37842: PUSH
37843: LD_INT 1
37845: NEG
37846: PUSH
37847: EMPTY
37848: LIST
37849: LIST
37850: PUSH
37851: LD_INT 1
37853: PUSH
37854: LD_INT 0
37856: PUSH
37857: EMPTY
37858: LIST
37859: LIST
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: LD_INT 1
37866: PUSH
37867: EMPTY
37868: LIST
37869: LIST
37870: PUSH
37871: LD_INT 0
37873: PUSH
37874: LD_INT 1
37876: PUSH
37877: EMPTY
37878: LIST
37879: LIST
37880: PUSH
37881: LD_INT 1
37883: NEG
37884: PUSH
37885: LD_INT 0
37887: PUSH
37888: EMPTY
37889: LIST
37890: LIST
37891: PUSH
37892: LD_INT 1
37894: NEG
37895: PUSH
37896: LD_INT 1
37898: NEG
37899: PUSH
37900: EMPTY
37901: LIST
37902: LIST
37903: PUSH
37904: LD_INT 1
37906: NEG
37907: PUSH
37908: LD_INT 2
37910: NEG
37911: PUSH
37912: EMPTY
37913: LIST
37914: LIST
37915: PUSH
37916: LD_INT 0
37918: PUSH
37919: LD_INT 2
37921: NEG
37922: PUSH
37923: EMPTY
37924: LIST
37925: LIST
37926: PUSH
37927: LD_INT 1
37929: PUSH
37930: LD_INT 1
37932: NEG
37933: PUSH
37934: EMPTY
37935: LIST
37936: LIST
37937: PUSH
37938: LD_INT 2
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: EMPTY
37945: LIST
37946: LIST
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: LD_INT 1
37953: PUSH
37954: EMPTY
37955: LIST
37956: LIST
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: LD_INT 2
37963: PUSH
37964: EMPTY
37965: LIST
37966: LIST
37967: PUSH
37968: LD_INT 1
37970: PUSH
37971: LD_INT 2
37973: PUSH
37974: EMPTY
37975: LIST
37976: LIST
37977: PUSH
37978: LD_INT 0
37980: PUSH
37981: LD_INT 2
37983: PUSH
37984: EMPTY
37985: LIST
37986: LIST
37987: PUSH
37988: LD_INT 1
37990: NEG
37991: PUSH
37992: LD_INT 1
37994: PUSH
37995: EMPTY
37996: LIST
37997: LIST
37998: PUSH
37999: LD_INT 2
38001: NEG
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 1
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 2
38024: NEG
38025: PUSH
38026: LD_INT 2
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: LIST
38038: LIST
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38055: LD_ADDR_VAR 0 56
38059: PUSH
38060: LD_INT 0
38062: PUSH
38063: LD_INT 0
38065: PUSH
38066: EMPTY
38067: LIST
38068: LIST
38069: PUSH
38070: LD_INT 0
38072: PUSH
38073: LD_INT 1
38075: NEG
38076: PUSH
38077: EMPTY
38078: LIST
38079: LIST
38080: PUSH
38081: LD_INT 1
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: EMPTY
38088: LIST
38089: LIST
38090: PUSH
38091: LD_INT 1
38093: PUSH
38094: LD_INT 1
38096: PUSH
38097: EMPTY
38098: LIST
38099: LIST
38100: PUSH
38101: LD_INT 0
38103: PUSH
38104: LD_INT 1
38106: PUSH
38107: EMPTY
38108: LIST
38109: LIST
38110: PUSH
38111: LD_INT 1
38113: NEG
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: EMPTY
38119: LIST
38120: LIST
38121: PUSH
38122: LD_INT 1
38124: NEG
38125: PUSH
38126: LD_INT 1
38128: NEG
38129: PUSH
38130: EMPTY
38131: LIST
38132: LIST
38133: PUSH
38134: LD_INT 1
38136: NEG
38137: PUSH
38138: LD_INT 2
38140: NEG
38141: PUSH
38142: EMPTY
38143: LIST
38144: LIST
38145: PUSH
38146: LD_INT 0
38148: PUSH
38149: LD_INT 2
38151: NEG
38152: PUSH
38153: EMPTY
38154: LIST
38155: LIST
38156: PUSH
38157: LD_INT 1
38159: PUSH
38160: LD_INT 1
38162: NEG
38163: PUSH
38164: EMPTY
38165: LIST
38166: LIST
38167: PUSH
38168: LD_INT 2
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: EMPTY
38175: LIST
38176: LIST
38177: PUSH
38178: LD_INT 2
38180: PUSH
38181: LD_INT 1
38183: PUSH
38184: EMPTY
38185: LIST
38186: LIST
38187: PUSH
38188: LD_INT 2
38190: PUSH
38191: LD_INT 2
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: LD_INT 2
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 0
38210: PUSH
38211: LD_INT 2
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 1
38220: NEG
38221: PUSH
38222: LD_INT 1
38224: PUSH
38225: EMPTY
38226: LIST
38227: LIST
38228: PUSH
38229: LD_INT 2
38231: NEG
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: EMPTY
38237: LIST
38238: LIST
38239: PUSH
38240: LD_INT 2
38242: NEG
38243: PUSH
38244: LD_INT 1
38246: NEG
38247: PUSH
38248: EMPTY
38249: LIST
38250: LIST
38251: PUSH
38252: LD_INT 2
38254: NEG
38255: PUSH
38256: LD_INT 2
38258: NEG
38259: PUSH
38260: EMPTY
38261: LIST
38262: LIST
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: LIST
38268: LIST
38269: LIST
38270: LIST
38271: LIST
38272: LIST
38273: LIST
38274: LIST
38275: LIST
38276: LIST
38277: LIST
38278: LIST
38279: LIST
38280: LIST
38281: LIST
38282: LIST
38283: LIST
38284: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38285: LD_ADDR_VAR 0 57
38289: PUSH
38290: LD_INT 0
38292: PUSH
38293: LD_INT 0
38295: PUSH
38296: EMPTY
38297: LIST
38298: LIST
38299: PUSH
38300: LD_INT 0
38302: PUSH
38303: LD_INT 1
38305: NEG
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 1
38313: PUSH
38314: LD_INT 0
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: PUSH
38324: LD_INT 1
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 0
38333: PUSH
38334: LD_INT 1
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 1
38343: NEG
38344: PUSH
38345: LD_INT 0
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 1
38354: NEG
38355: PUSH
38356: LD_INT 1
38358: NEG
38359: PUSH
38360: EMPTY
38361: LIST
38362: LIST
38363: PUSH
38364: LD_INT 1
38366: NEG
38367: PUSH
38368: LD_INT 2
38370: NEG
38371: PUSH
38372: EMPTY
38373: LIST
38374: LIST
38375: PUSH
38376: LD_INT 0
38378: PUSH
38379: LD_INT 2
38381: NEG
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PUSH
38387: LD_INT 1
38389: PUSH
38390: LD_INT 1
38392: NEG
38393: PUSH
38394: EMPTY
38395: LIST
38396: LIST
38397: PUSH
38398: LD_INT 2
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: EMPTY
38405: LIST
38406: LIST
38407: PUSH
38408: LD_INT 2
38410: PUSH
38411: LD_INT 1
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PUSH
38418: LD_INT 2
38420: PUSH
38421: LD_INT 2
38423: PUSH
38424: EMPTY
38425: LIST
38426: LIST
38427: PUSH
38428: LD_INT 1
38430: PUSH
38431: LD_INT 2
38433: PUSH
38434: EMPTY
38435: LIST
38436: LIST
38437: PUSH
38438: LD_INT 0
38440: PUSH
38441: LD_INT 2
38443: PUSH
38444: EMPTY
38445: LIST
38446: LIST
38447: PUSH
38448: LD_INT 1
38450: NEG
38451: PUSH
38452: LD_INT 1
38454: PUSH
38455: EMPTY
38456: LIST
38457: LIST
38458: PUSH
38459: LD_INT 2
38461: NEG
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: EMPTY
38467: LIST
38468: LIST
38469: PUSH
38470: LD_INT 2
38472: NEG
38473: PUSH
38474: LD_INT 1
38476: NEG
38477: PUSH
38478: EMPTY
38479: LIST
38480: LIST
38481: PUSH
38482: LD_INT 2
38484: NEG
38485: PUSH
38486: LD_INT 2
38488: NEG
38489: PUSH
38490: EMPTY
38491: LIST
38492: LIST
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38515: LD_ADDR_VAR 0 58
38519: PUSH
38520: LD_INT 0
38522: PUSH
38523: LD_INT 0
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 0
38532: PUSH
38533: LD_INT 1
38535: NEG
38536: PUSH
38537: EMPTY
38538: LIST
38539: LIST
38540: PUSH
38541: LD_INT 1
38543: PUSH
38544: LD_INT 0
38546: PUSH
38547: EMPTY
38548: LIST
38549: LIST
38550: PUSH
38551: LD_INT 1
38553: PUSH
38554: LD_INT 1
38556: PUSH
38557: EMPTY
38558: LIST
38559: LIST
38560: PUSH
38561: LD_INT 0
38563: PUSH
38564: LD_INT 1
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: PUSH
38571: LD_INT 1
38573: NEG
38574: PUSH
38575: LD_INT 0
38577: PUSH
38578: EMPTY
38579: LIST
38580: LIST
38581: PUSH
38582: LD_INT 1
38584: NEG
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: NEG
38597: PUSH
38598: LD_INT 2
38600: NEG
38601: PUSH
38602: EMPTY
38603: LIST
38604: LIST
38605: PUSH
38606: LD_INT 0
38608: PUSH
38609: LD_INT 2
38611: NEG
38612: PUSH
38613: EMPTY
38614: LIST
38615: LIST
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: LD_INT 1
38622: NEG
38623: PUSH
38624: EMPTY
38625: LIST
38626: LIST
38627: PUSH
38628: LD_INT 2
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: EMPTY
38635: LIST
38636: LIST
38637: PUSH
38638: LD_INT 2
38640: PUSH
38641: LD_INT 1
38643: PUSH
38644: EMPTY
38645: LIST
38646: LIST
38647: PUSH
38648: LD_INT 2
38650: PUSH
38651: LD_INT 2
38653: PUSH
38654: EMPTY
38655: LIST
38656: LIST
38657: PUSH
38658: LD_INT 1
38660: PUSH
38661: LD_INT 2
38663: PUSH
38664: EMPTY
38665: LIST
38666: LIST
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: LD_INT 2
38673: PUSH
38674: EMPTY
38675: LIST
38676: LIST
38677: PUSH
38678: LD_INT 1
38680: NEG
38681: PUSH
38682: LD_INT 1
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: PUSH
38689: LD_INT 2
38691: NEG
38692: PUSH
38693: LD_INT 0
38695: PUSH
38696: EMPTY
38697: LIST
38698: LIST
38699: PUSH
38700: LD_INT 2
38702: NEG
38703: PUSH
38704: LD_INT 1
38706: NEG
38707: PUSH
38708: EMPTY
38709: LIST
38710: LIST
38711: PUSH
38712: LD_INT 2
38714: NEG
38715: PUSH
38716: LD_INT 2
38718: NEG
38719: PUSH
38720: EMPTY
38721: LIST
38722: LIST
38723: PUSH
38724: EMPTY
38725: LIST
38726: LIST
38727: LIST
38728: LIST
38729: LIST
38730: LIST
38731: LIST
38732: LIST
38733: LIST
38734: LIST
38735: LIST
38736: LIST
38737: LIST
38738: LIST
38739: LIST
38740: LIST
38741: LIST
38742: LIST
38743: LIST
38744: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38745: LD_ADDR_VAR 0 59
38749: PUSH
38750: LD_INT 0
38752: PUSH
38753: LD_INT 0
38755: PUSH
38756: EMPTY
38757: LIST
38758: LIST
38759: PUSH
38760: LD_INT 0
38762: PUSH
38763: LD_INT 1
38765: NEG
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: PUSH
38774: LD_INT 0
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PUSH
38781: LD_INT 1
38783: PUSH
38784: LD_INT 1
38786: PUSH
38787: EMPTY
38788: LIST
38789: LIST
38790: PUSH
38791: LD_INT 0
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: EMPTY
38798: LIST
38799: LIST
38800: PUSH
38801: LD_INT 1
38803: NEG
38804: PUSH
38805: LD_INT 0
38807: PUSH
38808: EMPTY
38809: LIST
38810: LIST
38811: PUSH
38812: LD_INT 1
38814: NEG
38815: PUSH
38816: LD_INT 1
38818: NEG
38819: PUSH
38820: EMPTY
38821: LIST
38822: LIST
38823: PUSH
38824: EMPTY
38825: LIST
38826: LIST
38827: LIST
38828: LIST
38829: LIST
38830: LIST
38831: LIST
38832: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38833: LD_ADDR_VAR 0 60
38837: PUSH
38838: LD_INT 0
38840: PUSH
38841: LD_INT 0
38843: PUSH
38844: EMPTY
38845: LIST
38846: LIST
38847: PUSH
38848: LD_INT 0
38850: PUSH
38851: LD_INT 1
38853: NEG
38854: PUSH
38855: EMPTY
38856: LIST
38857: LIST
38858: PUSH
38859: LD_INT 1
38861: PUSH
38862: LD_INT 0
38864: PUSH
38865: EMPTY
38866: LIST
38867: LIST
38868: PUSH
38869: LD_INT 1
38871: PUSH
38872: LD_INT 1
38874: PUSH
38875: EMPTY
38876: LIST
38877: LIST
38878: PUSH
38879: LD_INT 0
38881: PUSH
38882: LD_INT 1
38884: PUSH
38885: EMPTY
38886: LIST
38887: LIST
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: LD_INT 0
38895: PUSH
38896: EMPTY
38897: LIST
38898: LIST
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: LD_INT 1
38906: NEG
38907: PUSH
38908: EMPTY
38909: LIST
38910: LIST
38911: PUSH
38912: EMPTY
38913: LIST
38914: LIST
38915: LIST
38916: LIST
38917: LIST
38918: LIST
38919: LIST
38920: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38921: LD_ADDR_VAR 0 61
38925: PUSH
38926: LD_INT 0
38928: PUSH
38929: LD_INT 0
38931: PUSH
38932: EMPTY
38933: LIST
38934: LIST
38935: PUSH
38936: LD_INT 0
38938: PUSH
38939: LD_INT 1
38941: NEG
38942: PUSH
38943: EMPTY
38944: LIST
38945: LIST
38946: PUSH
38947: LD_INT 1
38949: PUSH
38950: LD_INT 0
38952: PUSH
38953: EMPTY
38954: LIST
38955: LIST
38956: PUSH
38957: LD_INT 1
38959: PUSH
38960: LD_INT 1
38962: PUSH
38963: EMPTY
38964: LIST
38965: LIST
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: LD_INT 1
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 1
38979: NEG
38980: PUSH
38981: LD_INT 0
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 1
38990: NEG
38991: PUSH
38992: LD_INT 1
38994: NEG
38995: PUSH
38996: EMPTY
38997: LIST
38998: LIST
38999: PUSH
39000: EMPTY
39001: LIST
39002: LIST
39003: LIST
39004: LIST
39005: LIST
39006: LIST
39007: LIST
39008: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39009: LD_ADDR_VAR 0 62
39013: PUSH
39014: LD_INT 0
39016: PUSH
39017: LD_INT 0
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PUSH
39024: LD_INT 0
39026: PUSH
39027: LD_INT 1
39029: NEG
39030: PUSH
39031: EMPTY
39032: LIST
39033: LIST
39034: PUSH
39035: LD_INT 1
39037: PUSH
39038: LD_INT 0
39040: PUSH
39041: EMPTY
39042: LIST
39043: LIST
39044: PUSH
39045: LD_INT 1
39047: PUSH
39048: LD_INT 1
39050: PUSH
39051: EMPTY
39052: LIST
39053: LIST
39054: PUSH
39055: LD_INT 0
39057: PUSH
39058: LD_INT 1
39060: PUSH
39061: EMPTY
39062: LIST
39063: LIST
39064: PUSH
39065: LD_INT 1
39067: NEG
39068: PUSH
39069: LD_INT 0
39071: PUSH
39072: EMPTY
39073: LIST
39074: LIST
39075: PUSH
39076: LD_INT 1
39078: NEG
39079: PUSH
39080: LD_INT 1
39082: NEG
39083: PUSH
39084: EMPTY
39085: LIST
39086: LIST
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: LIST
39092: LIST
39093: LIST
39094: LIST
39095: LIST
39096: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39097: LD_ADDR_VAR 0 63
39101: PUSH
39102: LD_INT 0
39104: PUSH
39105: LD_INT 0
39107: PUSH
39108: EMPTY
39109: LIST
39110: LIST
39111: PUSH
39112: LD_INT 0
39114: PUSH
39115: LD_INT 1
39117: NEG
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PUSH
39123: LD_INT 1
39125: PUSH
39126: LD_INT 0
39128: PUSH
39129: EMPTY
39130: LIST
39131: LIST
39132: PUSH
39133: LD_INT 1
39135: PUSH
39136: LD_INT 1
39138: PUSH
39139: EMPTY
39140: LIST
39141: LIST
39142: PUSH
39143: LD_INT 0
39145: PUSH
39146: LD_INT 1
39148: PUSH
39149: EMPTY
39150: LIST
39151: LIST
39152: PUSH
39153: LD_INT 1
39155: NEG
39156: PUSH
39157: LD_INT 0
39159: PUSH
39160: EMPTY
39161: LIST
39162: LIST
39163: PUSH
39164: LD_INT 1
39166: NEG
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: EMPTY
39177: LIST
39178: LIST
39179: LIST
39180: LIST
39181: LIST
39182: LIST
39183: LIST
39184: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39185: LD_ADDR_VAR 0 64
39189: PUSH
39190: LD_INT 0
39192: PUSH
39193: LD_INT 0
39195: PUSH
39196: EMPTY
39197: LIST
39198: LIST
39199: PUSH
39200: LD_INT 0
39202: PUSH
39203: LD_INT 1
39205: NEG
39206: PUSH
39207: EMPTY
39208: LIST
39209: LIST
39210: PUSH
39211: LD_INT 1
39213: PUSH
39214: LD_INT 0
39216: PUSH
39217: EMPTY
39218: LIST
39219: LIST
39220: PUSH
39221: LD_INT 1
39223: PUSH
39224: LD_INT 1
39226: PUSH
39227: EMPTY
39228: LIST
39229: LIST
39230: PUSH
39231: LD_INT 0
39233: PUSH
39234: LD_INT 1
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 0
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 1
39254: NEG
39255: PUSH
39256: LD_INT 1
39258: NEG
39259: PUSH
39260: EMPTY
39261: LIST
39262: LIST
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: LIST
39268: LIST
39269: LIST
39270: LIST
39271: LIST
39272: ST_TO_ADDR
// end ; 1 :
39273: GO 45170
39275: LD_INT 1
39277: DOUBLE
39278: EQUAL
39279: IFTRUE 39283
39281: GO 41906
39283: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39284: LD_ADDR_VAR 0 11
39288: PUSH
39289: LD_INT 1
39291: NEG
39292: PUSH
39293: LD_INT 3
39295: NEG
39296: PUSH
39297: EMPTY
39298: LIST
39299: LIST
39300: PUSH
39301: LD_INT 0
39303: PUSH
39304: LD_INT 3
39306: NEG
39307: PUSH
39308: EMPTY
39309: LIST
39310: LIST
39311: PUSH
39312: LD_INT 1
39314: PUSH
39315: LD_INT 2
39317: NEG
39318: PUSH
39319: EMPTY
39320: LIST
39321: LIST
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: LIST
39327: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39328: LD_ADDR_VAR 0 12
39332: PUSH
39333: LD_INT 2
39335: PUSH
39336: LD_INT 1
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 3
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: EMPTY
39351: LIST
39352: LIST
39353: PUSH
39354: LD_INT 3
39356: PUSH
39357: LD_INT 1
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: LIST
39368: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39369: LD_ADDR_VAR 0 13
39373: PUSH
39374: LD_INT 3
39376: PUSH
39377: LD_INT 2
39379: PUSH
39380: EMPTY
39381: LIST
39382: LIST
39383: PUSH
39384: LD_INT 3
39386: PUSH
39387: LD_INT 3
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: PUSH
39394: LD_INT 2
39396: PUSH
39397: LD_INT 3
39399: PUSH
39400: EMPTY
39401: LIST
39402: LIST
39403: PUSH
39404: EMPTY
39405: LIST
39406: LIST
39407: LIST
39408: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39409: LD_ADDR_VAR 0 14
39413: PUSH
39414: LD_INT 1
39416: PUSH
39417: LD_INT 3
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 0
39426: PUSH
39427: LD_INT 3
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 1
39436: NEG
39437: PUSH
39438: LD_INT 2
39440: PUSH
39441: EMPTY
39442: LIST
39443: LIST
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: LIST
39449: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39450: LD_ADDR_VAR 0 15
39454: PUSH
39455: LD_INT 2
39457: NEG
39458: PUSH
39459: LD_INT 1
39461: PUSH
39462: EMPTY
39463: LIST
39464: LIST
39465: PUSH
39466: LD_INT 3
39468: NEG
39469: PUSH
39470: LD_INT 0
39472: PUSH
39473: EMPTY
39474: LIST
39475: LIST
39476: PUSH
39477: LD_INT 3
39479: NEG
39480: PUSH
39481: LD_INT 1
39483: NEG
39484: PUSH
39485: EMPTY
39486: LIST
39487: LIST
39488: PUSH
39489: EMPTY
39490: LIST
39491: LIST
39492: LIST
39493: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39494: LD_ADDR_VAR 0 16
39498: PUSH
39499: LD_INT 2
39501: NEG
39502: PUSH
39503: LD_INT 3
39505: NEG
39506: PUSH
39507: EMPTY
39508: LIST
39509: LIST
39510: PUSH
39511: LD_INT 3
39513: NEG
39514: PUSH
39515: LD_INT 2
39517: NEG
39518: PUSH
39519: EMPTY
39520: LIST
39521: LIST
39522: PUSH
39523: LD_INT 3
39525: NEG
39526: PUSH
39527: LD_INT 3
39529: NEG
39530: PUSH
39531: EMPTY
39532: LIST
39533: LIST
39534: PUSH
39535: EMPTY
39536: LIST
39537: LIST
39538: LIST
39539: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39540: LD_ADDR_VAR 0 17
39544: PUSH
39545: LD_INT 1
39547: NEG
39548: PUSH
39549: LD_INT 3
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: LD_INT 3
39562: NEG
39563: PUSH
39564: EMPTY
39565: LIST
39566: LIST
39567: PUSH
39568: LD_INT 1
39570: PUSH
39571: LD_INT 2
39573: NEG
39574: PUSH
39575: EMPTY
39576: LIST
39577: LIST
39578: PUSH
39579: EMPTY
39580: LIST
39581: LIST
39582: LIST
39583: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39584: LD_ADDR_VAR 0 18
39588: PUSH
39589: LD_INT 2
39591: PUSH
39592: LD_INT 1
39594: NEG
39595: PUSH
39596: EMPTY
39597: LIST
39598: LIST
39599: PUSH
39600: LD_INT 3
39602: PUSH
39603: LD_INT 0
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 3
39612: PUSH
39613: LD_INT 1
39615: PUSH
39616: EMPTY
39617: LIST
39618: LIST
39619: PUSH
39620: EMPTY
39621: LIST
39622: LIST
39623: LIST
39624: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39625: LD_ADDR_VAR 0 19
39629: PUSH
39630: LD_INT 3
39632: PUSH
39633: LD_INT 2
39635: PUSH
39636: EMPTY
39637: LIST
39638: LIST
39639: PUSH
39640: LD_INT 3
39642: PUSH
39643: LD_INT 3
39645: PUSH
39646: EMPTY
39647: LIST
39648: LIST
39649: PUSH
39650: LD_INT 2
39652: PUSH
39653: LD_INT 3
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: LIST
39664: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39665: LD_ADDR_VAR 0 20
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 3
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 3
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: LD_INT 2
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: LIST
39705: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39706: LD_ADDR_VAR 0 21
39710: PUSH
39711: LD_INT 2
39713: NEG
39714: PUSH
39715: LD_INT 1
39717: PUSH
39718: EMPTY
39719: LIST
39720: LIST
39721: PUSH
39722: LD_INT 3
39724: NEG
39725: PUSH
39726: LD_INT 0
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PUSH
39733: LD_INT 3
39735: NEG
39736: PUSH
39737: LD_INT 1
39739: NEG
39740: PUSH
39741: EMPTY
39742: LIST
39743: LIST
39744: PUSH
39745: EMPTY
39746: LIST
39747: LIST
39748: LIST
39749: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39750: LD_ADDR_VAR 0 22
39754: PUSH
39755: LD_INT 2
39757: NEG
39758: PUSH
39759: LD_INT 3
39761: NEG
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 3
39769: NEG
39770: PUSH
39771: LD_INT 2
39773: NEG
39774: PUSH
39775: EMPTY
39776: LIST
39777: LIST
39778: PUSH
39779: LD_INT 3
39781: NEG
39782: PUSH
39783: LD_INT 3
39785: NEG
39786: PUSH
39787: EMPTY
39788: LIST
39789: LIST
39790: PUSH
39791: EMPTY
39792: LIST
39793: LIST
39794: LIST
39795: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39796: LD_ADDR_VAR 0 23
39800: PUSH
39801: LD_INT 0
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: EMPTY
39809: LIST
39810: LIST
39811: PUSH
39812: LD_INT 1
39814: NEG
39815: PUSH
39816: LD_INT 4
39818: NEG
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PUSH
39824: LD_INT 1
39826: PUSH
39827: LD_INT 3
39829: NEG
39830: PUSH
39831: EMPTY
39832: LIST
39833: LIST
39834: PUSH
39835: EMPTY
39836: LIST
39837: LIST
39838: LIST
39839: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39840: LD_ADDR_VAR 0 24
39844: PUSH
39845: LD_INT 3
39847: PUSH
39848: LD_INT 0
39850: PUSH
39851: EMPTY
39852: LIST
39853: LIST
39854: PUSH
39855: LD_INT 3
39857: PUSH
39858: LD_INT 1
39860: NEG
39861: PUSH
39862: EMPTY
39863: LIST
39864: LIST
39865: PUSH
39866: LD_INT 4
39868: PUSH
39869: LD_INT 1
39871: PUSH
39872: EMPTY
39873: LIST
39874: LIST
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: LIST
39880: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39881: LD_ADDR_VAR 0 25
39885: PUSH
39886: LD_INT 3
39888: PUSH
39889: LD_INT 3
39891: PUSH
39892: EMPTY
39893: LIST
39894: LIST
39895: PUSH
39896: LD_INT 4
39898: PUSH
39899: LD_INT 3
39901: PUSH
39902: EMPTY
39903: LIST
39904: LIST
39905: PUSH
39906: LD_INT 3
39908: PUSH
39909: LD_INT 4
39911: PUSH
39912: EMPTY
39913: LIST
39914: LIST
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: LIST
39920: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39921: LD_ADDR_VAR 0 26
39925: PUSH
39926: LD_INT 0
39928: PUSH
39929: LD_INT 3
39931: PUSH
39932: EMPTY
39933: LIST
39934: LIST
39935: PUSH
39936: LD_INT 1
39938: PUSH
39939: LD_INT 4
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 1
39948: NEG
39949: PUSH
39950: LD_INT 3
39952: PUSH
39953: EMPTY
39954: LIST
39955: LIST
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: LIST
39961: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39962: LD_ADDR_VAR 0 27
39966: PUSH
39967: LD_INT 3
39969: NEG
39970: PUSH
39971: LD_INT 0
39973: PUSH
39974: EMPTY
39975: LIST
39976: LIST
39977: PUSH
39978: LD_INT 3
39980: NEG
39981: PUSH
39982: LD_INT 1
39984: PUSH
39985: EMPTY
39986: LIST
39987: LIST
39988: PUSH
39989: LD_INT 4
39991: NEG
39992: PUSH
39993: LD_INT 1
39995: NEG
39996: PUSH
39997: EMPTY
39998: LIST
39999: LIST
40000: PUSH
40001: EMPTY
40002: LIST
40003: LIST
40004: LIST
40005: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40006: LD_ADDR_VAR 0 28
40010: PUSH
40011: LD_INT 3
40013: NEG
40014: PUSH
40015: LD_INT 3
40017: NEG
40018: PUSH
40019: EMPTY
40020: LIST
40021: LIST
40022: PUSH
40023: LD_INT 3
40025: NEG
40026: PUSH
40027: LD_INT 4
40029: NEG
40030: PUSH
40031: EMPTY
40032: LIST
40033: LIST
40034: PUSH
40035: LD_INT 4
40037: NEG
40038: PUSH
40039: LD_INT 3
40041: NEG
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: EMPTY
40048: LIST
40049: LIST
40050: LIST
40051: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40052: LD_ADDR_VAR 0 29
40056: PUSH
40057: LD_INT 1
40059: NEG
40060: PUSH
40061: LD_INT 3
40063: NEG
40064: PUSH
40065: EMPTY
40066: LIST
40067: LIST
40068: PUSH
40069: LD_INT 0
40071: PUSH
40072: LD_INT 3
40074: NEG
40075: PUSH
40076: EMPTY
40077: LIST
40078: LIST
40079: PUSH
40080: LD_INT 1
40082: PUSH
40083: LD_INT 2
40085: NEG
40086: PUSH
40087: EMPTY
40088: LIST
40089: LIST
40090: PUSH
40091: LD_INT 1
40093: NEG
40094: PUSH
40095: LD_INT 4
40097: NEG
40098: PUSH
40099: EMPTY
40100: LIST
40101: LIST
40102: PUSH
40103: LD_INT 0
40105: PUSH
40106: LD_INT 4
40108: NEG
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 1
40116: PUSH
40117: LD_INT 3
40119: NEG
40120: PUSH
40121: EMPTY
40122: LIST
40123: LIST
40124: PUSH
40125: LD_INT 1
40127: NEG
40128: PUSH
40129: LD_INT 5
40131: NEG
40132: PUSH
40133: EMPTY
40134: LIST
40135: LIST
40136: PUSH
40137: LD_INT 0
40139: PUSH
40140: LD_INT 5
40142: NEG
40143: PUSH
40144: EMPTY
40145: LIST
40146: LIST
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: LD_INT 4
40153: NEG
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: PUSH
40159: LD_INT 1
40161: NEG
40162: PUSH
40163: LD_INT 6
40165: NEG
40166: PUSH
40167: EMPTY
40168: LIST
40169: LIST
40170: PUSH
40171: LD_INT 0
40173: PUSH
40174: LD_INT 6
40176: NEG
40177: PUSH
40178: EMPTY
40179: LIST
40180: LIST
40181: PUSH
40182: LD_INT 1
40184: PUSH
40185: LD_INT 5
40187: NEG
40188: PUSH
40189: EMPTY
40190: LIST
40191: LIST
40192: PUSH
40193: EMPTY
40194: LIST
40195: LIST
40196: LIST
40197: LIST
40198: LIST
40199: LIST
40200: LIST
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40207: LD_ADDR_VAR 0 30
40211: PUSH
40212: LD_INT 2
40214: PUSH
40215: LD_INT 1
40217: NEG
40218: PUSH
40219: EMPTY
40220: LIST
40221: LIST
40222: PUSH
40223: LD_INT 3
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: EMPTY
40230: LIST
40231: LIST
40232: PUSH
40233: LD_INT 3
40235: PUSH
40236: LD_INT 1
40238: PUSH
40239: EMPTY
40240: LIST
40241: LIST
40242: PUSH
40243: LD_INT 3
40245: PUSH
40246: LD_INT 1
40248: NEG
40249: PUSH
40250: EMPTY
40251: LIST
40252: LIST
40253: PUSH
40254: LD_INT 4
40256: PUSH
40257: LD_INT 0
40259: PUSH
40260: EMPTY
40261: LIST
40262: LIST
40263: PUSH
40264: LD_INT 4
40266: PUSH
40267: LD_INT 1
40269: PUSH
40270: EMPTY
40271: LIST
40272: LIST
40273: PUSH
40274: LD_INT 4
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: EMPTY
40282: LIST
40283: LIST
40284: PUSH
40285: LD_INT 5
40287: PUSH
40288: LD_INT 0
40290: PUSH
40291: EMPTY
40292: LIST
40293: LIST
40294: PUSH
40295: LD_INT 5
40297: PUSH
40298: LD_INT 1
40300: PUSH
40301: EMPTY
40302: LIST
40303: LIST
40304: PUSH
40305: LD_INT 5
40307: PUSH
40308: LD_INT 1
40310: NEG
40311: PUSH
40312: EMPTY
40313: LIST
40314: LIST
40315: PUSH
40316: LD_INT 6
40318: PUSH
40319: LD_INT 0
40321: PUSH
40322: EMPTY
40323: LIST
40324: LIST
40325: PUSH
40326: LD_INT 6
40328: PUSH
40329: LD_INT 1
40331: PUSH
40332: EMPTY
40333: LIST
40334: LIST
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: LIST
40340: LIST
40341: LIST
40342: LIST
40343: LIST
40344: LIST
40345: LIST
40346: LIST
40347: LIST
40348: LIST
40349: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40350: LD_ADDR_VAR 0 31
40354: PUSH
40355: LD_INT 3
40357: PUSH
40358: LD_INT 2
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: PUSH
40365: LD_INT 3
40367: PUSH
40368: LD_INT 3
40370: PUSH
40371: EMPTY
40372: LIST
40373: LIST
40374: PUSH
40375: LD_INT 2
40377: PUSH
40378: LD_INT 3
40380: PUSH
40381: EMPTY
40382: LIST
40383: LIST
40384: PUSH
40385: LD_INT 4
40387: PUSH
40388: LD_INT 3
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 4
40397: PUSH
40398: LD_INT 4
40400: PUSH
40401: EMPTY
40402: LIST
40403: LIST
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: LD_INT 4
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 5
40417: PUSH
40418: LD_INT 4
40420: PUSH
40421: EMPTY
40422: LIST
40423: LIST
40424: PUSH
40425: LD_INT 5
40427: PUSH
40428: LD_INT 5
40430: PUSH
40431: EMPTY
40432: LIST
40433: LIST
40434: PUSH
40435: LD_INT 4
40437: PUSH
40438: LD_INT 5
40440: PUSH
40441: EMPTY
40442: LIST
40443: LIST
40444: PUSH
40445: LD_INT 6
40447: PUSH
40448: LD_INT 5
40450: PUSH
40451: EMPTY
40452: LIST
40453: LIST
40454: PUSH
40455: LD_INT 6
40457: PUSH
40458: LD_INT 6
40460: PUSH
40461: EMPTY
40462: LIST
40463: LIST
40464: PUSH
40465: LD_INT 5
40467: PUSH
40468: LD_INT 6
40470: PUSH
40471: EMPTY
40472: LIST
40473: LIST
40474: PUSH
40475: EMPTY
40476: LIST
40477: LIST
40478: LIST
40479: LIST
40480: LIST
40481: LIST
40482: LIST
40483: LIST
40484: LIST
40485: LIST
40486: LIST
40487: LIST
40488: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40489: LD_ADDR_VAR 0 32
40493: PUSH
40494: LD_INT 1
40496: PUSH
40497: LD_INT 3
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 0
40506: PUSH
40507: LD_INT 3
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PUSH
40514: LD_INT 1
40516: NEG
40517: PUSH
40518: LD_INT 2
40520: PUSH
40521: EMPTY
40522: LIST
40523: LIST
40524: PUSH
40525: LD_INT 1
40527: PUSH
40528: LD_INT 4
40530: PUSH
40531: EMPTY
40532: LIST
40533: LIST
40534: PUSH
40535: LD_INT 0
40537: PUSH
40538: LD_INT 4
40540: PUSH
40541: EMPTY
40542: LIST
40543: LIST
40544: PUSH
40545: LD_INT 1
40547: NEG
40548: PUSH
40549: LD_INT 3
40551: PUSH
40552: EMPTY
40553: LIST
40554: LIST
40555: PUSH
40556: LD_INT 1
40558: PUSH
40559: LD_INT 5
40561: PUSH
40562: EMPTY
40563: LIST
40564: LIST
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: LD_INT 5
40571: PUSH
40572: EMPTY
40573: LIST
40574: LIST
40575: PUSH
40576: LD_INT 1
40578: NEG
40579: PUSH
40580: LD_INT 4
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: PUSH
40587: LD_INT 1
40589: PUSH
40590: LD_INT 6
40592: PUSH
40593: EMPTY
40594: LIST
40595: LIST
40596: PUSH
40597: LD_INT 0
40599: PUSH
40600: LD_INT 6
40602: PUSH
40603: EMPTY
40604: LIST
40605: LIST
40606: PUSH
40607: LD_INT 1
40609: NEG
40610: PUSH
40611: LD_INT 5
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: LIST
40622: LIST
40623: LIST
40624: LIST
40625: LIST
40626: LIST
40627: LIST
40628: LIST
40629: LIST
40630: LIST
40631: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40632: LD_ADDR_VAR 0 33
40636: PUSH
40637: LD_INT 2
40639: NEG
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 3
40650: NEG
40651: PUSH
40652: LD_INT 0
40654: PUSH
40655: EMPTY
40656: LIST
40657: LIST
40658: PUSH
40659: LD_INT 3
40661: NEG
40662: PUSH
40663: LD_INT 1
40665: NEG
40666: PUSH
40667: EMPTY
40668: LIST
40669: LIST
40670: PUSH
40671: LD_INT 3
40673: NEG
40674: PUSH
40675: LD_INT 1
40677: PUSH
40678: EMPTY
40679: LIST
40680: LIST
40681: PUSH
40682: LD_INT 4
40684: NEG
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: EMPTY
40690: LIST
40691: LIST
40692: PUSH
40693: LD_INT 4
40695: NEG
40696: PUSH
40697: LD_INT 1
40699: NEG
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: PUSH
40705: LD_INT 4
40707: NEG
40708: PUSH
40709: LD_INT 1
40711: PUSH
40712: EMPTY
40713: LIST
40714: LIST
40715: PUSH
40716: LD_INT 5
40718: NEG
40719: PUSH
40720: LD_INT 0
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 5
40729: NEG
40730: PUSH
40731: LD_INT 1
40733: NEG
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 5
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: PUSH
40746: EMPTY
40747: LIST
40748: LIST
40749: PUSH
40750: LD_INT 6
40752: NEG
40753: PUSH
40754: LD_INT 0
40756: PUSH
40757: EMPTY
40758: LIST
40759: LIST
40760: PUSH
40761: LD_INT 6
40763: NEG
40764: PUSH
40765: LD_INT 1
40767: NEG
40768: PUSH
40769: EMPTY
40770: LIST
40771: LIST
40772: PUSH
40773: EMPTY
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: LIST
40784: LIST
40785: LIST
40786: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40787: LD_ADDR_VAR 0 34
40791: PUSH
40792: LD_INT 2
40794: NEG
40795: PUSH
40796: LD_INT 3
40798: NEG
40799: PUSH
40800: EMPTY
40801: LIST
40802: LIST
40803: PUSH
40804: LD_INT 3
40806: NEG
40807: PUSH
40808: LD_INT 2
40810: NEG
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 3
40818: NEG
40819: PUSH
40820: LD_INT 3
40822: NEG
40823: PUSH
40824: EMPTY
40825: LIST
40826: LIST
40827: PUSH
40828: LD_INT 3
40830: NEG
40831: PUSH
40832: LD_INT 4
40834: NEG
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 4
40842: NEG
40843: PUSH
40844: LD_INT 3
40846: NEG
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: PUSH
40852: LD_INT 4
40854: NEG
40855: PUSH
40856: LD_INT 4
40858: NEG
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: LD_INT 4
40866: NEG
40867: PUSH
40868: LD_INT 5
40870: NEG
40871: PUSH
40872: EMPTY
40873: LIST
40874: LIST
40875: PUSH
40876: LD_INT 5
40878: NEG
40879: PUSH
40880: LD_INT 4
40882: NEG
40883: PUSH
40884: EMPTY
40885: LIST
40886: LIST
40887: PUSH
40888: LD_INT 5
40890: NEG
40891: PUSH
40892: LD_INT 5
40894: NEG
40895: PUSH
40896: EMPTY
40897: LIST
40898: LIST
40899: PUSH
40900: LD_INT 5
40902: NEG
40903: PUSH
40904: LD_INT 6
40906: NEG
40907: PUSH
40908: EMPTY
40909: LIST
40910: LIST
40911: PUSH
40912: LD_INT 6
40914: NEG
40915: PUSH
40916: LD_INT 5
40918: NEG
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 6
40926: NEG
40927: PUSH
40928: LD_INT 6
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: LIST
40945: LIST
40946: LIST
40947: LIST
40948: LIST
40949: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40950: LD_ADDR_VAR 0 41
40954: PUSH
40955: LD_INT 0
40957: PUSH
40958: LD_INT 2
40960: NEG
40961: PUSH
40962: EMPTY
40963: LIST
40964: LIST
40965: PUSH
40966: LD_INT 1
40968: NEG
40969: PUSH
40970: LD_INT 3
40972: NEG
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: PUSH
40978: LD_INT 1
40980: PUSH
40981: LD_INT 2
40983: NEG
40984: PUSH
40985: EMPTY
40986: LIST
40987: LIST
40988: PUSH
40989: EMPTY
40990: LIST
40991: LIST
40992: LIST
40993: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
40994: LD_ADDR_VAR 0 42
40998: PUSH
40999: LD_INT 2
41001: PUSH
41002: LD_INT 0
41004: PUSH
41005: EMPTY
41006: LIST
41007: LIST
41008: PUSH
41009: LD_INT 2
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: EMPTY
41017: LIST
41018: LIST
41019: PUSH
41020: LD_INT 3
41022: PUSH
41023: LD_INT 1
41025: PUSH
41026: EMPTY
41027: LIST
41028: LIST
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: LIST
41034: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41035: LD_ADDR_VAR 0 43
41039: PUSH
41040: LD_INT 2
41042: PUSH
41043: LD_INT 2
41045: PUSH
41046: EMPTY
41047: LIST
41048: LIST
41049: PUSH
41050: LD_INT 3
41052: PUSH
41053: LD_INT 2
41055: PUSH
41056: EMPTY
41057: LIST
41058: LIST
41059: PUSH
41060: LD_INT 2
41062: PUSH
41063: LD_INT 3
41065: PUSH
41066: EMPTY
41067: LIST
41068: LIST
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: LIST
41074: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41075: LD_ADDR_VAR 0 44
41079: PUSH
41080: LD_INT 0
41082: PUSH
41083: LD_INT 2
41085: PUSH
41086: EMPTY
41087: LIST
41088: LIST
41089: PUSH
41090: LD_INT 1
41092: PUSH
41093: LD_INT 3
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: LD_INT 2
41106: PUSH
41107: EMPTY
41108: LIST
41109: LIST
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: LIST
41115: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41116: LD_ADDR_VAR 0 45
41120: PUSH
41121: LD_INT 2
41123: NEG
41124: PUSH
41125: LD_INT 0
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: PUSH
41132: LD_INT 2
41134: NEG
41135: PUSH
41136: LD_INT 1
41138: PUSH
41139: EMPTY
41140: LIST
41141: LIST
41142: PUSH
41143: LD_INT 3
41145: NEG
41146: PUSH
41147: LD_INT 1
41149: NEG
41150: PUSH
41151: EMPTY
41152: LIST
41153: LIST
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41160: LD_ADDR_VAR 0 46
41164: PUSH
41165: LD_INT 2
41167: NEG
41168: PUSH
41169: LD_INT 2
41171: NEG
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 2
41179: NEG
41180: PUSH
41181: LD_INT 3
41183: NEG
41184: PUSH
41185: EMPTY
41186: LIST
41187: LIST
41188: PUSH
41189: LD_INT 3
41191: NEG
41192: PUSH
41193: LD_INT 2
41195: NEG
41196: PUSH
41197: EMPTY
41198: LIST
41199: LIST
41200: PUSH
41201: EMPTY
41202: LIST
41203: LIST
41204: LIST
41205: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41206: LD_ADDR_VAR 0 47
41210: PUSH
41211: LD_INT 2
41213: NEG
41214: PUSH
41215: LD_INT 3
41217: NEG
41218: PUSH
41219: EMPTY
41220: LIST
41221: LIST
41222: PUSH
41223: LD_INT 1
41225: NEG
41226: PUSH
41227: LD_INT 3
41229: NEG
41230: PUSH
41231: EMPTY
41232: LIST
41233: LIST
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41239: LD_ADDR_VAR 0 48
41243: PUSH
41244: LD_INT 1
41246: PUSH
41247: LD_INT 2
41249: NEG
41250: PUSH
41251: EMPTY
41252: LIST
41253: LIST
41254: PUSH
41255: LD_INT 2
41257: PUSH
41258: LD_INT 1
41260: NEG
41261: PUSH
41262: EMPTY
41263: LIST
41264: LIST
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41270: LD_ADDR_VAR 0 49
41274: PUSH
41275: LD_INT 3
41277: PUSH
41278: LD_INT 1
41280: PUSH
41281: EMPTY
41282: LIST
41283: LIST
41284: PUSH
41285: LD_INT 3
41287: PUSH
41288: LD_INT 2
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: PUSH
41295: EMPTY
41296: LIST
41297: LIST
41298: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41299: LD_ADDR_VAR 0 50
41303: PUSH
41304: LD_INT 2
41306: PUSH
41307: LD_INT 3
41309: PUSH
41310: EMPTY
41311: LIST
41312: LIST
41313: PUSH
41314: LD_INT 1
41316: PUSH
41317: LD_INT 3
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: PUSH
41324: EMPTY
41325: LIST
41326: LIST
41327: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41328: LD_ADDR_VAR 0 51
41332: PUSH
41333: LD_INT 1
41335: NEG
41336: PUSH
41337: LD_INT 2
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: LD_INT 2
41346: NEG
41347: PUSH
41348: LD_INT 1
41350: PUSH
41351: EMPTY
41352: LIST
41353: LIST
41354: PUSH
41355: EMPTY
41356: LIST
41357: LIST
41358: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41359: LD_ADDR_VAR 0 52
41363: PUSH
41364: LD_INT 3
41366: NEG
41367: PUSH
41368: LD_INT 1
41370: NEG
41371: PUSH
41372: EMPTY
41373: LIST
41374: LIST
41375: PUSH
41376: LD_INT 3
41378: NEG
41379: PUSH
41380: LD_INT 2
41382: NEG
41383: PUSH
41384: EMPTY
41385: LIST
41386: LIST
41387: PUSH
41388: EMPTY
41389: LIST
41390: LIST
41391: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41392: LD_ADDR_VAR 0 53
41396: PUSH
41397: LD_INT 1
41399: NEG
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: EMPTY
41406: LIST
41407: LIST
41408: PUSH
41409: LD_INT 0
41411: PUSH
41412: LD_INT 3
41414: NEG
41415: PUSH
41416: EMPTY
41417: LIST
41418: LIST
41419: PUSH
41420: LD_INT 1
41422: PUSH
41423: LD_INT 2
41425: NEG
41426: PUSH
41427: EMPTY
41428: LIST
41429: LIST
41430: PUSH
41431: EMPTY
41432: LIST
41433: LIST
41434: LIST
41435: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41436: LD_ADDR_VAR 0 54
41440: PUSH
41441: LD_INT 2
41443: PUSH
41444: LD_INT 1
41446: NEG
41447: PUSH
41448: EMPTY
41449: LIST
41450: LIST
41451: PUSH
41452: LD_INT 3
41454: PUSH
41455: LD_INT 0
41457: PUSH
41458: EMPTY
41459: LIST
41460: LIST
41461: PUSH
41462: LD_INT 3
41464: PUSH
41465: LD_INT 1
41467: PUSH
41468: EMPTY
41469: LIST
41470: LIST
41471: PUSH
41472: EMPTY
41473: LIST
41474: LIST
41475: LIST
41476: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41477: LD_ADDR_VAR 0 55
41481: PUSH
41482: LD_INT 3
41484: PUSH
41485: LD_INT 2
41487: PUSH
41488: EMPTY
41489: LIST
41490: LIST
41491: PUSH
41492: LD_INT 3
41494: PUSH
41495: LD_INT 3
41497: PUSH
41498: EMPTY
41499: LIST
41500: LIST
41501: PUSH
41502: LD_INT 2
41504: PUSH
41505: LD_INT 3
41507: PUSH
41508: EMPTY
41509: LIST
41510: LIST
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: LIST
41516: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41517: LD_ADDR_VAR 0 56
41521: PUSH
41522: LD_INT 1
41524: PUSH
41525: LD_INT 3
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: PUSH
41532: LD_INT 0
41534: PUSH
41535: LD_INT 3
41537: PUSH
41538: EMPTY
41539: LIST
41540: LIST
41541: PUSH
41542: LD_INT 1
41544: NEG
41545: PUSH
41546: LD_INT 2
41548: PUSH
41549: EMPTY
41550: LIST
41551: LIST
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: LIST
41557: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41558: LD_ADDR_VAR 0 57
41562: PUSH
41563: LD_INT 2
41565: NEG
41566: PUSH
41567: LD_INT 1
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: LD_INT 3
41576: NEG
41577: PUSH
41578: LD_INT 0
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: PUSH
41585: LD_INT 3
41587: NEG
41588: PUSH
41589: LD_INT 1
41591: NEG
41592: PUSH
41593: EMPTY
41594: LIST
41595: LIST
41596: PUSH
41597: EMPTY
41598: LIST
41599: LIST
41600: LIST
41601: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41602: LD_ADDR_VAR 0 58
41606: PUSH
41607: LD_INT 2
41609: NEG
41610: PUSH
41611: LD_INT 3
41613: NEG
41614: PUSH
41615: EMPTY
41616: LIST
41617: LIST
41618: PUSH
41619: LD_INT 3
41621: NEG
41622: PUSH
41623: LD_INT 2
41625: NEG
41626: PUSH
41627: EMPTY
41628: LIST
41629: LIST
41630: PUSH
41631: LD_INT 3
41633: NEG
41634: PUSH
41635: LD_INT 3
41637: NEG
41638: PUSH
41639: EMPTY
41640: LIST
41641: LIST
41642: PUSH
41643: EMPTY
41644: LIST
41645: LIST
41646: LIST
41647: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41648: LD_ADDR_VAR 0 59
41652: PUSH
41653: LD_INT 1
41655: NEG
41656: PUSH
41657: LD_INT 2
41659: NEG
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: PUSH
41665: LD_INT 0
41667: PUSH
41668: LD_INT 2
41670: NEG
41671: PUSH
41672: EMPTY
41673: LIST
41674: LIST
41675: PUSH
41676: LD_INT 1
41678: PUSH
41679: LD_INT 1
41681: NEG
41682: PUSH
41683: EMPTY
41684: LIST
41685: LIST
41686: PUSH
41687: EMPTY
41688: LIST
41689: LIST
41690: LIST
41691: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41692: LD_ADDR_VAR 0 60
41696: PUSH
41697: LD_INT 1
41699: PUSH
41700: LD_INT 1
41702: NEG
41703: PUSH
41704: EMPTY
41705: LIST
41706: LIST
41707: PUSH
41708: LD_INT 2
41710: PUSH
41711: LD_INT 0
41713: PUSH
41714: EMPTY
41715: LIST
41716: LIST
41717: PUSH
41718: LD_INT 2
41720: PUSH
41721: LD_INT 1
41723: PUSH
41724: EMPTY
41725: LIST
41726: LIST
41727: PUSH
41728: EMPTY
41729: LIST
41730: LIST
41731: LIST
41732: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41733: LD_ADDR_VAR 0 61
41737: PUSH
41738: LD_INT 2
41740: PUSH
41741: LD_INT 1
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 2
41750: PUSH
41751: LD_INT 2
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: PUSH
41758: LD_INT 1
41760: PUSH
41761: LD_INT 2
41763: PUSH
41764: EMPTY
41765: LIST
41766: LIST
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: LIST
41772: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41773: LD_ADDR_VAR 0 62
41777: PUSH
41778: LD_INT 1
41780: PUSH
41781: LD_INT 2
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: PUSH
41788: LD_INT 0
41790: PUSH
41791: LD_INT 2
41793: PUSH
41794: EMPTY
41795: LIST
41796: LIST
41797: PUSH
41798: LD_INT 1
41800: NEG
41801: PUSH
41802: LD_INT 1
41804: PUSH
41805: EMPTY
41806: LIST
41807: LIST
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: LIST
41813: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41814: LD_ADDR_VAR 0 63
41818: PUSH
41819: LD_INT 1
41821: NEG
41822: PUSH
41823: LD_INT 1
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: LD_INT 2
41832: NEG
41833: PUSH
41834: LD_INT 0
41836: PUSH
41837: EMPTY
41838: LIST
41839: LIST
41840: PUSH
41841: LD_INT 2
41843: NEG
41844: PUSH
41845: LD_INT 1
41847: NEG
41848: PUSH
41849: EMPTY
41850: LIST
41851: LIST
41852: PUSH
41853: EMPTY
41854: LIST
41855: LIST
41856: LIST
41857: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41858: LD_ADDR_VAR 0 64
41862: PUSH
41863: LD_INT 1
41865: NEG
41866: PUSH
41867: LD_INT 2
41869: NEG
41870: PUSH
41871: EMPTY
41872: LIST
41873: LIST
41874: PUSH
41875: LD_INT 2
41877: NEG
41878: PUSH
41879: LD_INT 1
41881: NEG
41882: PUSH
41883: EMPTY
41884: LIST
41885: LIST
41886: PUSH
41887: LD_INT 2
41889: NEG
41890: PUSH
41891: LD_INT 2
41893: NEG
41894: PUSH
41895: EMPTY
41896: LIST
41897: LIST
41898: PUSH
41899: EMPTY
41900: LIST
41901: LIST
41902: LIST
41903: ST_TO_ADDR
// end ; 2 :
41904: GO 45170
41906: LD_INT 2
41908: DOUBLE
41909: EQUAL
41910: IFTRUE 41914
41912: GO 45169
41914: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41915: LD_ADDR_VAR 0 29
41919: PUSH
41920: LD_INT 4
41922: PUSH
41923: LD_INT 0
41925: PUSH
41926: EMPTY
41927: LIST
41928: LIST
41929: PUSH
41930: LD_INT 4
41932: PUSH
41933: LD_INT 1
41935: NEG
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: PUSH
41941: LD_INT 5
41943: PUSH
41944: LD_INT 0
41946: PUSH
41947: EMPTY
41948: LIST
41949: LIST
41950: PUSH
41951: LD_INT 5
41953: PUSH
41954: LD_INT 1
41956: PUSH
41957: EMPTY
41958: LIST
41959: LIST
41960: PUSH
41961: LD_INT 4
41963: PUSH
41964: LD_INT 1
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 3
41973: PUSH
41974: LD_INT 0
41976: PUSH
41977: EMPTY
41978: LIST
41979: LIST
41980: PUSH
41981: LD_INT 3
41983: PUSH
41984: LD_INT 1
41986: NEG
41987: PUSH
41988: EMPTY
41989: LIST
41990: LIST
41991: PUSH
41992: LD_INT 3
41994: PUSH
41995: LD_INT 2
41997: NEG
41998: PUSH
41999: EMPTY
42000: LIST
42001: LIST
42002: PUSH
42003: LD_INT 5
42005: PUSH
42006: LD_INT 2
42008: PUSH
42009: EMPTY
42010: LIST
42011: LIST
42012: PUSH
42013: LD_INT 3
42015: PUSH
42016: LD_INT 3
42018: PUSH
42019: EMPTY
42020: LIST
42021: LIST
42022: PUSH
42023: LD_INT 3
42025: PUSH
42026: LD_INT 2
42028: PUSH
42029: EMPTY
42030: LIST
42031: LIST
42032: PUSH
42033: LD_INT 4
42035: PUSH
42036: LD_INT 3
42038: PUSH
42039: EMPTY
42040: LIST
42041: LIST
42042: PUSH
42043: LD_INT 4
42045: PUSH
42046: LD_INT 4
42048: PUSH
42049: EMPTY
42050: LIST
42051: LIST
42052: PUSH
42053: LD_INT 3
42055: PUSH
42056: LD_INT 4
42058: PUSH
42059: EMPTY
42060: LIST
42061: LIST
42062: PUSH
42063: LD_INT 2
42065: PUSH
42066: LD_INT 3
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 2
42075: PUSH
42076: LD_INT 2
42078: PUSH
42079: EMPTY
42080: LIST
42081: LIST
42082: PUSH
42083: LD_INT 4
42085: PUSH
42086: LD_INT 2
42088: PUSH
42089: EMPTY
42090: LIST
42091: LIST
42092: PUSH
42093: LD_INT 2
42095: PUSH
42096: LD_INT 4
42098: PUSH
42099: EMPTY
42100: LIST
42101: LIST
42102: PUSH
42103: LD_INT 0
42105: PUSH
42106: LD_INT 4
42108: PUSH
42109: EMPTY
42110: LIST
42111: LIST
42112: PUSH
42113: LD_INT 0
42115: PUSH
42116: LD_INT 3
42118: PUSH
42119: EMPTY
42120: LIST
42121: LIST
42122: PUSH
42123: LD_INT 1
42125: PUSH
42126: LD_INT 4
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: PUSH
42133: LD_INT 1
42135: PUSH
42136: LD_INT 5
42138: PUSH
42139: EMPTY
42140: LIST
42141: LIST
42142: PUSH
42143: LD_INT 0
42145: PUSH
42146: LD_INT 5
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: NEG
42156: PUSH
42157: LD_INT 4
42159: PUSH
42160: EMPTY
42161: LIST
42162: LIST
42163: PUSH
42164: LD_INT 1
42166: NEG
42167: PUSH
42168: LD_INT 3
42170: PUSH
42171: EMPTY
42172: LIST
42173: LIST
42174: PUSH
42175: LD_INT 2
42177: PUSH
42178: LD_INT 5
42180: PUSH
42181: EMPTY
42182: LIST
42183: LIST
42184: PUSH
42185: LD_INT 2
42187: NEG
42188: PUSH
42189: LD_INT 3
42191: PUSH
42192: EMPTY
42193: LIST
42194: LIST
42195: PUSH
42196: LD_INT 3
42198: NEG
42199: PUSH
42200: LD_INT 0
42202: PUSH
42203: EMPTY
42204: LIST
42205: LIST
42206: PUSH
42207: LD_INT 3
42209: NEG
42210: PUSH
42211: LD_INT 1
42213: NEG
42214: PUSH
42215: EMPTY
42216: LIST
42217: LIST
42218: PUSH
42219: LD_INT 2
42221: NEG
42222: PUSH
42223: LD_INT 0
42225: PUSH
42226: EMPTY
42227: LIST
42228: LIST
42229: PUSH
42230: LD_INT 2
42232: NEG
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 3
42243: NEG
42244: PUSH
42245: LD_INT 1
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 4
42254: NEG
42255: PUSH
42256: LD_INT 0
42258: PUSH
42259: EMPTY
42260: LIST
42261: LIST
42262: PUSH
42263: LD_INT 4
42265: NEG
42266: PUSH
42267: LD_INT 1
42269: NEG
42270: PUSH
42271: EMPTY
42272: LIST
42273: LIST
42274: PUSH
42275: LD_INT 4
42277: NEG
42278: PUSH
42279: LD_INT 2
42281: NEG
42282: PUSH
42283: EMPTY
42284: LIST
42285: LIST
42286: PUSH
42287: LD_INT 2
42289: NEG
42290: PUSH
42291: LD_INT 2
42293: PUSH
42294: EMPTY
42295: LIST
42296: LIST
42297: PUSH
42298: LD_INT 4
42300: NEG
42301: PUSH
42302: LD_INT 4
42304: NEG
42305: PUSH
42306: EMPTY
42307: LIST
42308: LIST
42309: PUSH
42310: LD_INT 4
42312: NEG
42313: PUSH
42314: LD_INT 5
42316: NEG
42317: PUSH
42318: EMPTY
42319: LIST
42320: LIST
42321: PUSH
42322: LD_INT 3
42324: NEG
42325: PUSH
42326: LD_INT 4
42328: NEG
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 3
42336: NEG
42337: PUSH
42338: LD_INT 3
42340: NEG
42341: PUSH
42342: EMPTY
42343: LIST
42344: LIST
42345: PUSH
42346: LD_INT 4
42348: NEG
42349: PUSH
42350: LD_INT 3
42352: NEG
42353: PUSH
42354: EMPTY
42355: LIST
42356: LIST
42357: PUSH
42358: LD_INT 5
42360: NEG
42361: PUSH
42362: LD_INT 4
42364: NEG
42365: PUSH
42366: EMPTY
42367: LIST
42368: LIST
42369: PUSH
42370: LD_INT 5
42372: NEG
42373: PUSH
42374: LD_INT 5
42376: NEG
42377: PUSH
42378: EMPTY
42379: LIST
42380: LIST
42381: PUSH
42382: LD_INT 3
42384: NEG
42385: PUSH
42386: LD_INT 5
42388: NEG
42389: PUSH
42390: EMPTY
42391: LIST
42392: LIST
42393: PUSH
42394: LD_INT 5
42396: NEG
42397: PUSH
42398: LD_INT 3
42400: NEG
42401: PUSH
42402: EMPTY
42403: LIST
42404: LIST
42405: PUSH
42406: EMPTY
42407: LIST
42408: LIST
42409: LIST
42410: LIST
42411: LIST
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: LIST
42425: LIST
42426: LIST
42427: LIST
42428: LIST
42429: LIST
42430: LIST
42431: LIST
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42453: LD_ADDR_VAR 0 30
42457: PUSH
42458: LD_INT 4
42460: PUSH
42461: LD_INT 4
42463: PUSH
42464: EMPTY
42465: LIST
42466: LIST
42467: PUSH
42468: LD_INT 4
42470: PUSH
42471: LD_INT 3
42473: PUSH
42474: EMPTY
42475: LIST
42476: LIST
42477: PUSH
42478: LD_INT 5
42480: PUSH
42481: LD_INT 4
42483: PUSH
42484: EMPTY
42485: LIST
42486: LIST
42487: PUSH
42488: LD_INT 5
42490: PUSH
42491: LD_INT 5
42493: PUSH
42494: EMPTY
42495: LIST
42496: LIST
42497: PUSH
42498: LD_INT 4
42500: PUSH
42501: LD_INT 5
42503: PUSH
42504: EMPTY
42505: LIST
42506: LIST
42507: PUSH
42508: LD_INT 3
42510: PUSH
42511: LD_INT 4
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: PUSH
42518: LD_INT 3
42520: PUSH
42521: LD_INT 3
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: PUSH
42528: LD_INT 5
42530: PUSH
42531: LD_INT 3
42533: PUSH
42534: EMPTY
42535: LIST
42536: LIST
42537: PUSH
42538: LD_INT 3
42540: PUSH
42541: LD_INT 5
42543: PUSH
42544: EMPTY
42545: LIST
42546: LIST
42547: PUSH
42548: LD_INT 0
42550: PUSH
42551: LD_INT 3
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: PUSH
42558: LD_INT 0
42560: PUSH
42561: LD_INT 2
42563: PUSH
42564: EMPTY
42565: LIST
42566: LIST
42567: PUSH
42568: LD_INT 1
42570: PUSH
42571: LD_INT 3
42573: PUSH
42574: EMPTY
42575: LIST
42576: LIST
42577: PUSH
42578: LD_INT 1
42580: PUSH
42581: LD_INT 4
42583: PUSH
42584: EMPTY
42585: LIST
42586: LIST
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: LD_INT 4
42593: PUSH
42594: EMPTY
42595: LIST
42596: LIST
42597: PUSH
42598: LD_INT 1
42600: NEG
42601: PUSH
42602: LD_INT 3
42604: PUSH
42605: EMPTY
42606: LIST
42607: LIST
42608: PUSH
42609: LD_INT 1
42611: NEG
42612: PUSH
42613: LD_INT 2
42615: PUSH
42616: EMPTY
42617: LIST
42618: LIST
42619: PUSH
42620: LD_INT 2
42622: PUSH
42623: LD_INT 4
42625: PUSH
42626: EMPTY
42627: LIST
42628: LIST
42629: PUSH
42630: LD_INT 2
42632: NEG
42633: PUSH
42634: LD_INT 2
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 4
42643: NEG
42644: PUSH
42645: LD_INT 0
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 4
42654: NEG
42655: PUSH
42656: LD_INT 1
42658: NEG
42659: PUSH
42660: EMPTY
42661: LIST
42662: LIST
42663: PUSH
42664: LD_INT 3
42666: NEG
42667: PUSH
42668: LD_INT 0
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 3
42677: NEG
42678: PUSH
42679: LD_INT 1
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 4
42688: NEG
42689: PUSH
42690: LD_INT 1
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 5
42699: NEG
42700: PUSH
42701: LD_INT 0
42703: PUSH
42704: EMPTY
42705: LIST
42706: LIST
42707: PUSH
42708: LD_INT 5
42710: NEG
42711: PUSH
42712: LD_INT 1
42714: NEG
42715: PUSH
42716: EMPTY
42717: LIST
42718: LIST
42719: PUSH
42720: LD_INT 5
42722: NEG
42723: PUSH
42724: LD_INT 2
42726: NEG
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: LD_INT 2
42738: PUSH
42739: EMPTY
42740: LIST
42741: LIST
42742: PUSH
42743: LD_INT 3
42745: NEG
42746: PUSH
42747: LD_INT 3
42749: NEG
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 3
42757: NEG
42758: PUSH
42759: LD_INT 4
42761: NEG
42762: PUSH
42763: EMPTY
42764: LIST
42765: LIST
42766: PUSH
42767: LD_INT 2
42769: NEG
42770: PUSH
42771: LD_INT 3
42773: NEG
42774: PUSH
42775: EMPTY
42776: LIST
42777: LIST
42778: PUSH
42779: LD_INT 2
42781: NEG
42782: PUSH
42783: LD_INT 2
42785: NEG
42786: PUSH
42787: EMPTY
42788: LIST
42789: LIST
42790: PUSH
42791: LD_INT 3
42793: NEG
42794: PUSH
42795: LD_INT 2
42797: NEG
42798: PUSH
42799: EMPTY
42800: LIST
42801: LIST
42802: PUSH
42803: LD_INT 4
42805: NEG
42806: PUSH
42807: LD_INT 3
42809: NEG
42810: PUSH
42811: EMPTY
42812: LIST
42813: LIST
42814: PUSH
42815: LD_INT 4
42817: NEG
42818: PUSH
42819: LD_INT 4
42821: NEG
42822: PUSH
42823: EMPTY
42824: LIST
42825: LIST
42826: PUSH
42827: LD_INT 2
42829: NEG
42830: PUSH
42831: LD_INT 4
42833: NEG
42834: PUSH
42835: EMPTY
42836: LIST
42837: LIST
42838: PUSH
42839: LD_INT 4
42841: NEG
42842: PUSH
42843: LD_INT 2
42845: NEG
42846: PUSH
42847: EMPTY
42848: LIST
42849: LIST
42850: PUSH
42851: LD_INT 0
42853: PUSH
42854: LD_INT 4
42856: NEG
42857: PUSH
42858: EMPTY
42859: LIST
42860: LIST
42861: PUSH
42862: LD_INT 0
42864: PUSH
42865: LD_INT 5
42867: NEG
42868: PUSH
42869: EMPTY
42870: LIST
42871: LIST
42872: PUSH
42873: LD_INT 1
42875: PUSH
42876: LD_INT 4
42878: NEG
42879: PUSH
42880: EMPTY
42881: LIST
42882: LIST
42883: PUSH
42884: LD_INT 1
42886: PUSH
42887: LD_INT 3
42889: NEG
42890: PUSH
42891: EMPTY
42892: LIST
42893: LIST
42894: PUSH
42895: LD_INT 0
42897: PUSH
42898: LD_INT 3
42900: NEG
42901: PUSH
42902: EMPTY
42903: LIST
42904: LIST
42905: PUSH
42906: LD_INT 1
42908: NEG
42909: PUSH
42910: LD_INT 4
42912: NEG
42913: PUSH
42914: EMPTY
42915: LIST
42916: LIST
42917: PUSH
42918: LD_INT 1
42920: NEG
42921: PUSH
42922: LD_INT 5
42924: NEG
42925: PUSH
42926: EMPTY
42927: LIST
42928: LIST
42929: PUSH
42930: LD_INT 2
42932: PUSH
42933: LD_INT 3
42935: NEG
42936: PUSH
42937: EMPTY
42938: LIST
42939: LIST
42940: PUSH
42941: LD_INT 2
42943: NEG
42944: PUSH
42945: LD_INT 5
42947: NEG
42948: PUSH
42949: EMPTY
42950: LIST
42951: LIST
42952: PUSH
42953: EMPTY
42954: LIST
42955: LIST
42956: LIST
42957: LIST
42958: LIST
42959: LIST
42960: LIST
42961: LIST
42962: LIST
42963: LIST
42964: LIST
42965: LIST
42966: LIST
42967: LIST
42968: LIST
42969: LIST
42970: LIST
42971: LIST
42972: LIST
42973: LIST
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43000: LD_ADDR_VAR 0 31
43004: PUSH
43005: LD_INT 0
43007: PUSH
43008: LD_INT 4
43010: PUSH
43011: EMPTY
43012: LIST
43013: LIST
43014: PUSH
43015: LD_INT 0
43017: PUSH
43018: LD_INT 3
43020: PUSH
43021: EMPTY
43022: LIST
43023: LIST
43024: PUSH
43025: LD_INT 1
43027: PUSH
43028: LD_INT 4
43030: PUSH
43031: EMPTY
43032: LIST
43033: LIST
43034: PUSH
43035: LD_INT 1
43037: PUSH
43038: LD_INT 5
43040: PUSH
43041: EMPTY
43042: LIST
43043: LIST
43044: PUSH
43045: LD_INT 0
43047: PUSH
43048: LD_INT 5
43050: PUSH
43051: EMPTY
43052: LIST
43053: LIST
43054: PUSH
43055: LD_INT 1
43057: NEG
43058: PUSH
43059: LD_INT 4
43061: PUSH
43062: EMPTY
43063: LIST
43064: LIST
43065: PUSH
43066: LD_INT 1
43068: NEG
43069: PUSH
43070: LD_INT 3
43072: PUSH
43073: EMPTY
43074: LIST
43075: LIST
43076: PUSH
43077: LD_INT 2
43079: PUSH
43080: LD_INT 5
43082: PUSH
43083: EMPTY
43084: LIST
43085: LIST
43086: PUSH
43087: LD_INT 2
43089: NEG
43090: PUSH
43091: LD_INT 3
43093: PUSH
43094: EMPTY
43095: LIST
43096: LIST
43097: PUSH
43098: LD_INT 3
43100: NEG
43101: PUSH
43102: LD_INT 0
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: LD_INT 3
43111: NEG
43112: PUSH
43113: LD_INT 1
43115: NEG
43116: PUSH
43117: EMPTY
43118: LIST
43119: LIST
43120: PUSH
43121: LD_INT 2
43123: NEG
43124: PUSH
43125: LD_INT 0
43127: PUSH
43128: EMPTY
43129: LIST
43130: LIST
43131: PUSH
43132: LD_INT 2
43134: NEG
43135: PUSH
43136: LD_INT 1
43138: PUSH
43139: EMPTY
43140: LIST
43141: LIST
43142: PUSH
43143: LD_INT 3
43145: NEG
43146: PUSH
43147: LD_INT 1
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: PUSH
43154: LD_INT 4
43156: NEG
43157: PUSH
43158: LD_INT 0
43160: PUSH
43161: EMPTY
43162: LIST
43163: LIST
43164: PUSH
43165: LD_INT 4
43167: NEG
43168: PUSH
43169: LD_INT 1
43171: NEG
43172: PUSH
43173: EMPTY
43174: LIST
43175: LIST
43176: PUSH
43177: LD_INT 4
43179: NEG
43180: PUSH
43181: LD_INT 2
43183: NEG
43184: PUSH
43185: EMPTY
43186: LIST
43187: LIST
43188: PUSH
43189: LD_INT 2
43191: NEG
43192: PUSH
43193: LD_INT 2
43195: PUSH
43196: EMPTY
43197: LIST
43198: LIST
43199: PUSH
43200: LD_INT 4
43202: NEG
43203: PUSH
43204: LD_INT 4
43206: NEG
43207: PUSH
43208: EMPTY
43209: LIST
43210: LIST
43211: PUSH
43212: LD_INT 4
43214: NEG
43215: PUSH
43216: LD_INT 5
43218: NEG
43219: PUSH
43220: EMPTY
43221: LIST
43222: LIST
43223: PUSH
43224: LD_INT 3
43226: NEG
43227: PUSH
43228: LD_INT 4
43230: NEG
43231: PUSH
43232: EMPTY
43233: LIST
43234: LIST
43235: PUSH
43236: LD_INT 3
43238: NEG
43239: PUSH
43240: LD_INT 3
43242: NEG
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 4
43250: NEG
43251: PUSH
43252: LD_INT 3
43254: NEG
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: LD_INT 5
43262: NEG
43263: PUSH
43264: LD_INT 4
43266: NEG
43267: PUSH
43268: EMPTY
43269: LIST
43270: LIST
43271: PUSH
43272: LD_INT 5
43274: NEG
43275: PUSH
43276: LD_INT 5
43278: NEG
43279: PUSH
43280: EMPTY
43281: LIST
43282: LIST
43283: PUSH
43284: LD_INT 3
43286: NEG
43287: PUSH
43288: LD_INT 5
43290: NEG
43291: PUSH
43292: EMPTY
43293: LIST
43294: LIST
43295: PUSH
43296: LD_INT 5
43298: NEG
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: EMPTY
43305: LIST
43306: LIST
43307: PUSH
43308: LD_INT 0
43310: PUSH
43311: LD_INT 3
43313: NEG
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: PUSH
43319: LD_INT 0
43321: PUSH
43322: LD_INT 4
43324: NEG
43325: PUSH
43326: EMPTY
43327: LIST
43328: LIST
43329: PUSH
43330: LD_INT 1
43332: PUSH
43333: LD_INT 3
43335: NEG
43336: PUSH
43337: EMPTY
43338: LIST
43339: LIST
43340: PUSH
43341: LD_INT 1
43343: PUSH
43344: LD_INT 2
43346: NEG
43347: PUSH
43348: EMPTY
43349: LIST
43350: LIST
43351: PUSH
43352: LD_INT 0
43354: PUSH
43355: LD_INT 2
43357: NEG
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: LD_INT 1
43365: NEG
43366: PUSH
43367: LD_INT 3
43369: NEG
43370: PUSH
43371: EMPTY
43372: LIST
43373: LIST
43374: PUSH
43375: LD_INT 1
43377: NEG
43378: PUSH
43379: LD_INT 4
43381: NEG
43382: PUSH
43383: EMPTY
43384: LIST
43385: LIST
43386: PUSH
43387: LD_INT 2
43389: PUSH
43390: LD_INT 2
43392: NEG
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 2
43400: NEG
43401: PUSH
43402: LD_INT 4
43404: NEG
43405: PUSH
43406: EMPTY
43407: LIST
43408: LIST
43409: PUSH
43410: LD_INT 4
43412: PUSH
43413: LD_INT 0
43415: PUSH
43416: EMPTY
43417: LIST
43418: LIST
43419: PUSH
43420: LD_INT 4
43422: PUSH
43423: LD_INT 1
43425: NEG
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: PUSH
43431: LD_INT 5
43433: PUSH
43434: LD_INT 0
43436: PUSH
43437: EMPTY
43438: LIST
43439: LIST
43440: PUSH
43441: LD_INT 5
43443: PUSH
43444: LD_INT 1
43446: PUSH
43447: EMPTY
43448: LIST
43449: LIST
43450: PUSH
43451: LD_INT 4
43453: PUSH
43454: LD_INT 1
43456: PUSH
43457: EMPTY
43458: LIST
43459: LIST
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: LD_INT 0
43466: PUSH
43467: EMPTY
43468: LIST
43469: LIST
43470: PUSH
43471: LD_INT 3
43473: PUSH
43474: LD_INT 1
43476: NEG
43477: PUSH
43478: EMPTY
43479: LIST
43480: LIST
43481: PUSH
43482: LD_INT 3
43484: PUSH
43485: LD_INT 2
43487: NEG
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: PUSH
43493: LD_INT 5
43495: PUSH
43496: LD_INT 2
43498: PUSH
43499: EMPTY
43500: LIST
43501: LIST
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: LIST
43507: LIST
43508: LIST
43509: LIST
43510: LIST
43511: LIST
43512: LIST
43513: LIST
43514: LIST
43515: LIST
43516: LIST
43517: LIST
43518: LIST
43519: LIST
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43550: LD_ADDR_VAR 0 32
43554: PUSH
43555: LD_INT 4
43557: NEG
43558: PUSH
43559: LD_INT 0
43561: PUSH
43562: EMPTY
43563: LIST
43564: LIST
43565: PUSH
43566: LD_INT 4
43568: NEG
43569: PUSH
43570: LD_INT 1
43572: NEG
43573: PUSH
43574: EMPTY
43575: LIST
43576: LIST
43577: PUSH
43578: LD_INT 3
43580: NEG
43581: PUSH
43582: LD_INT 0
43584: PUSH
43585: EMPTY
43586: LIST
43587: LIST
43588: PUSH
43589: LD_INT 3
43591: NEG
43592: PUSH
43593: LD_INT 1
43595: PUSH
43596: EMPTY
43597: LIST
43598: LIST
43599: PUSH
43600: LD_INT 4
43602: NEG
43603: PUSH
43604: LD_INT 1
43606: PUSH
43607: EMPTY
43608: LIST
43609: LIST
43610: PUSH
43611: LD_INT 5
43613: NEG
43614: PUSH
43615: LD_INT 0
43617: PUSH
43618: EMPTY
43619: LIST
43620: LIST
43621: PUSH
43622: LD_INT 5
43624: NEG
43625: PUSH
43626: LD_INT 1
43628: NEG
43629: PUSH
43630: EMPTY
43631: LIST
43632: LIST
43633: PUSH
43634: LD_INT 5
43636: NEG
43637: PUSH
43638: LD_INT 2
43640: NEG
43641: PUSH
43642: EMPTY
43643: LIST
43644: LIST
43645: PUSH
43646: LD_INT 3
43648: NEG
43649: PUSH
43650: LD_INT 2
43652: PUSH
43653: EMPTY
43654: LIST
43655: LIST
43656: PUSH
43657: LD_INT 3
43659: NEG
43660: PUSH
43661: LD_INT 3
43663: NEG
43664: PUSH
43665: EMPTY
43666: LIST
43667: LIST
43668: PUSH
43669: LD_INT 3
43671: NEG
43672: PUSH
43673: LD_INT 4
43675: NEG
43676: PUSH
43677: EMPTY
43678: LIST
43679: LIST
43680: PUSH
43681: LD_INT 2
43683: NEG
43684: PUSH
43685: LD_INT 3
43687: NEG
43688: PUSH
43689: EMPTY
43690: LIST
43691: LIST
43692: PUSH
43693: LD_INT 2
43695: NEG
43696: PUSH
43697: LD_INT 2
43699: NEG
43700: PUSH
43701: EMPTY
43702: LIST
43703: LIST
43704: PUSH
43705: LD_INT 3
43707: NEG
43708: PUSH
43709: LD_INT 2
43711: NEG
43712: PUSH
43713: EMPTY
43714: LIST
43715: LIST
43716: PUSH
43717: LD_INT 4
43719: NEG
43720: PUSH
43721: LD_INT 3
43723: NEG
43724: PUSH
43725: EMPTY
43726: LIST
43727: LIST
43728: PUSH
43729: LD_INT 4
43731: NEG
43732: PUSH
43733: LD_INT 4
43735: NEG
43736: PUSH
43737: EMPTY
43738: LIST
43739: LIST
43740: PUSH
43741: LD_INT 2
43743: NEG
43744: PUSH
43745: LD_INT 4
43747: NEG
43748: PUSH
43749: EMPTY
43750: LIST
43751: LIST
43752: PUSH
43753: LD_INT 4
43755: NEG
43756: PUSH
43757: LD_INT 2
43759: NEG
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 0
43767: PUSH
43768: LD_INT 4
43770: NEG
43771: PUSH
43772: EMPTY
43773: LIST
43774: LIST
43775: PUSH
43776: LD_INT 0
43778: PUSH
43779: LD_INT 5
43781: NEG
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 1
43789: PUSH
43790: LD_INT 4
43792: NEG
43793: PUSH
43794: EMPTY
43795: LIST
43796: LIST
43797: PUSH
43798: LD_INT 1
43800: PUSH
43801: LD_INT 3
43803: NEG
43804: PUSH
43805: EMPTY
43806: LIST
43807: LIST
43808: PUSH
43809: LD_INT 0
43811: PUSH
43812: LD_INT 3
43814: NEG
43815: PUSH
43816: EMPTY
43817: LIST
43818: LIST
43819: PUSH
43820: LD_INT 1
43822: NEG
43823: PUSH
43824: LD_INT 4
43826: NEG
43827: PUSH
43828: EMPTY
43829: LIST
43830: LIST
43831: PUSH
43832: LD_INT 1
43834: NEG
43835: PUSH
43836: LD_INT 5
43838: NEG
43839: PUSH
43840: EMPTY
43841: LIST
43842: LIST
43843: PUSH
43844: LD_INT 2
43846: PUSH
43847: LD_INT 3
43849: NEG
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: LD_INT 2
43857: NEG
43858: PUSH
43859: LD_INT 5
43861: NEG
43862: PUSH
43863: EMPTY
43864: LIST
43865: LIST
43866: PUSH
43867: LD_INT 3
43869: PUSH
43870: LD_INT 0
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 3
43879: PUSH
43880: LD_INT 1
43882: NEG
43883: PUSH
43884: EMPTY
43885: LIST
43886: LIST
43887: PUSH
43888: LD_INT 4
43890: PUSH
43891: LD_INT 0
43893: PUSH
43894: EMPTY
43895: LIST
43896: LIST
43897: PUSH
43898: LD_INT 4
43900: PUSH
43901: LD_INT 1
43903: PUSH
43904: EMPTY
43905: LIST
43906: LIST
43907: PUSH
43908: LD_INT 3
43910: PUSH
43911: LD_INT 1
43913: PUSH
43914: EMPTY
43915: LIST
43916: LIST
43917: PUSH
43918: LD_INT 2
43920: PUSH
43921: LD_INT 0
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 2
43930: PUSH
43931: LD_INT 1
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 2
43941: PUSH
43942: LD_INT 2
43944: NEG
43945: PUSH
43946: EMPTY
43947: LIST
43948: LIST
43949: PUSH
43950: LD_INT 4
43952: PUSH
43953: LD_INT 2
43955: PUSH
43956: EMPTY
43957: LIST
43958: LIST
43959: PUSH
43960: LD_INT 4
43962: PUSH
43963: LD_INT 4
43965: PUSH
43966: EMPTY
43967: LIST
43968: LIST
43969: PUSH
43970: LD_INT 4
43972: PUSH
43973: LD_INT 3
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 5
43982: PUSH
43983: LD_INT 4
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 5
43992: PUSH
43993: LD_INT 5
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: LD_INT 5
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 3
44012: PUSH
44013: LD_INT 4
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 3
44022: PUSH
44023: LD_INT 3
44025: PUSH
44026: EMPTY
44027: LIST
44028: LIST
44029: PUSH
44030: LD_INT 5
44032: PUSH
44033: LD_INT 3
44035: PUSH
44036: EMPTY
44037: LIST
44038: LIST
44039: PUSH
44040: LD_INT 3
44042: PUSH
44043: LD_INT 5
44045: PUSH
44046: EMPTY
44047: LIST
44048: LIST
44049: PUSH
44050: EMPTY
44051: LIST
44052: LIST
44053: LIST
44054: LIST
44055: LIST
44056: LIST
44057: LIST
44058: LIST
44059: LIST
44060: LIST
44061: LIST
44062: LIST
44063: LIST
44064: LIST
44065: LIST
44066: LIST
44067: LIST
44068: LIST
44069: LIST
44070: LIST
44071: LIST
44072: LIST
44073: LIST
44074: LIST
44075: LIST
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44097: LD_ADDR_VAR 0 33
44101: PUSH
44102: LD_INT 4
44104: NEG
44105: PUSH
44106: LD_INT 4
44108: NEG
44109: PUSH
44110: EMPTY
44111: LIST
44112: LIST
44113: PUSH
44114: LD_INT 4
44116: NEG
44117: PUSH
44118: LD_INT 5
44120: NEG
44121: PUSH
44122: EMPTY
44123: LIST
44124: LIST
44125: PUSH
44126: LD_INT 3
44128: NEG
44129: PUSH
44130: LD_INT 4
44132: NEG
44133: PUSH
44134: EMPTY
44135: LIST
44136: LIST
44137: PUSH
44138: LD_INT 3
44140: NEG
44141: PUSH
44142: LD_INT 3
44144: NEG
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 4
44152: NEG
44153: PUSH
44154: LD_INT 3
44156: NEG
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 5
44164: NEG
44165: PUSH
44166: LD_INT 4
44168: NEG
44169: PUSH
44170: EMPTY
44171: LIST
44172: LIST
44173: PUSH
44174: LD_INT 5
44176: NEG
44177: PUSH
44178: LD_INT 5
44180: NEG
44181: PUSH
44182: EMPTY
44183: LIST
44184: LIST
44185: PUSH
44186: LD_INT 3
44188: NEG
44189: PUSH
44190: LD_INT 5
44192: NEG
44193: PUSH
44194: EMPTY
44195: LIST
44196: LIST
44197: PUSH
44198: LD_INT 5
44200: NEG
44201: PUSH
44202: LD_INT 3
44204: NEG
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 0
44212: PUSH
44213: LD_INT 3
44215: NEG
44216: PUSH
44217: EMPTY
44218: LIST
44219: LIST
44220: PUSH
44221: LD_INT 0
44223: PUSH
44224: LD_INT 4
44226: NEG
44227: PUSH
44228: EMPTY
44229: LIST
44230: LIST
44231: PUSH
44232: LD_INT 1
44234: PUSH
44235: LD_INT 3
44237: NEG
44238: PUSH
44239: EMPTY
44240: LIST
44241: LIST
44242: PUSH
44243: LD_INT 1
44245: PUSH
44246: LD_INT 2
44248: NEG
44249: PUSH
44250: EMPTY
44251: LIST
44252: LIST
44253: PUSH
44254: LD_INT 0
44256: PUSH
44257: LD_INT 2
44259: NEG
44260: PUSH
44261: EMPTY
44262: LIST
44263: LIST
44264: PUSH
44265: LD_INT 1
44267: NEG
44268: PUSH
44269: LD_INT 3
44271: NEG
44272: PUSH
44273: EMPTY
44274: LIST
44275: LIST
44276: PUSH
44277: LD_INT 1
44279: NEG
44280: PUSH
44281: LD_INT 4
44283: NEG
44284: PUSH
44285: EMPTY
44286: LIST
44287: LIST
44288: PUSH
44289: LD_INT 2
44291: PUSH
44292: LD_INT 2
44294: NEG
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 2
44302: NEG
44303: PUSH
44304: LD_INT 4
44306: NEG
44307: PUSH
44308: EMPTY
44309: LIST
44310: LIST
44311: PUSH
44312: LD_INT 4
44314: PUSH
44315: LD_INT 0
44317: PUSH
44318: EMPTY
44319: LIST
44320: LIST
44321: PUSH
44322: LD_INT 4
44324: PUSH
44325: LD_INT 1
44327: NEG
44328: PUSH
44329: EMPTY
44330: LIST
44331: LIST
44332: PUSH
44333: LD_INT 5
44335: PUSH
44336: LD_INT 0
44338: PUSH
44339: EMPTY
44340: LIST
44341: LIST
44342: PUSH
44343: LD_INT 5
44345: PUSH
44346: LD_INT 1
44348: PUSH
44349: EMPTY
44350: LIST
44351: LIST
44352: PUSH
44353: LD_INT 4
44355: PUSH
44356: LD_INT 1
44358: PUSH
44359: EMPTY
44360: LIST
44361: LIST
44362: PUSH
44363: LD_INT 3
44365: PUSH
44366: LD_INT 0
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 3
44375: PUSH
44376: LD_INT 1
44378: NEG
44379: PUSH
44380: EMPTY
44381: LIST
44382: LIST
44383: PUSH
44384: LD_INT 3
44386: PUSH
44387: LD_INT 2
44389: NEG
44390: PUSH
44391: EMPTY
44392: LIST
44393: LIST
44394: PUSH
44395: LD_INT 5
44397: PUSH
44398: LD_INT 2
44400: PUSH
44401: EMPTY
44402: LIST
44403: LIST
44404: PUSH
44405: LD_INT 3
44407: PUSH
44408: LD_INT 3
44410: PUSH
44411: EMPTY
44412: LIST
44413: LIST
44414: PUSH
44415: LD_INT 3
44417: PUSH
44418: LD_INT 2
44420: PUSH
44421: EMPTY
44422: LIST
44423: LIST
44424: PUSH
44425: LD_INT 4
44427: PUSH
44428: LD_INT 3
44430: PUSH
44431: EMPTY
44432: LIST
44433: LIST
44434: PUSH
44435: LD_INT 4
44437: PUSH
44438: LD_INT 4
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: LD_INT 3
44447: PUSH
44448: LD_INT 4
44450: PUSH
44451: EMPTY
44452: LIST
44453: LIST
44454: PUSH
44455: LD_INT 2
44457: PUSH
44458: LD_INT 3
44460: PUSH
44461: EMPTY
44462: LIST
44463: LIST
44464: PUSH
44465: LD_INT 2
44467: PUSH
44468: LD_INT 2
44470: PUSH
44471: EMPTY
44472: LIST
44473: LIST
44474: PUSH
44475: LD_INT 4
44477: PUSH
44478: LD_INT 2
44480: PUSH
44481: EMPTY
44482: LIST
44483: LIST
44484: PUSH
44485: LD_INT 2
44487: PUSH
44488: LD_INT 4
44490: PUSH
44491: EMPTY
44492: LIST
44493: LIST
44494: PUSH
44495: LD_INT 0
44497: PUSH
44498: LD_INT 4
44500: PUSH
44501: EMPTY
44502: LIST
44503: LIST
44504: PUSH
44505: LD_INT 0
44507: PUSH
44508: LD_INT 3
44510: PUSH
44511: EMPTY
44512: LIST
44513: LIST
44514: PUSH
44515: LD_INT 1
44517: PUSH
44518: LD_INT 4
44520: PUSH
44521: EMPTY
44522: LIST
44523: LIST
44524: PUSH
44525: LD_INT 1
44527: PUSH
44528: LD_INT 5
44530: PUSH
44531: EMPTY
44532: LIST
44533: LIST
44534: PUSH
44535: LD_INT 0
44537: PUSH
44538: LD_INT 5
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: LD_INT 4
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 1
44558: NEG
44559: PUSH
44560: LD_INT 3
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 2
44569: PUSH
44570: LD_INT 5
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 2
44579: NEG
44580: PUSH
44581: LD_INT 3
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: LIST
44592: LIST
44593: LIST
44594: LIST
44595: LIST
44596: LIST
44597: LIST
44598: LIST
44599: LIST
44600: LIST
44601: LIST
44602: LIST
44603: LIST
44604: LIST
44605: LIST
44606: LIST
44607: LIST
44608: LIST
44609: LIST
44610: LIST
44611: LIST
44612: LIST
44613: LIST
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44635: LD_ADDR_VAR 0 34
44639: PUSH
44640: LD_INT 0
44642: PUSH
44643: LD_INT 4
44645: NEG
44646: PUSH
44647: EMPTY
44648: LIST
44649: LIST
44650: PUSH
44651: LD_INT 0
44653: PUSH
44654: LD_INT 5
44656: NEG
44657: PUSH
44658: EMPTY
44659: LIST
44660: LIST
44661: PUSH
44662: LD_INT 1
44664: PUSH
44665: LD_INT 4
44667: NEG
44668: PUSH
44669: EMPTY
44670: LIST
44671: LIST
44672: PUSH
44673: LD_INT 1
44675: PUSH
44676: LD_INT 3
44678: NEG
44679: PUSH
44680: EMPTY
44681: LIST
44682: LIST
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: LD_INT 3
44689: NEG
44690: PUSH
44691: EMPTY
44692: LIST
44693: LIST
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: LD_INT 4
44701: NEG
44702: PUSH
44703: EMPTY
44704: LIST
44705: LIST
44706: PUSH
44707: LD_INT 1
44709: NEG
44710: PUSH
44711: LD_INT 5
44713: NEG
44714: PUSH
44715: EMPTY
44716: LIST
44717: LIST
44718: PUSH
44719: LD_INT 2
44721: PUSH
44722: LD_INT 3
44724: NEG
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 2
44732: NEG
44733: PUSH
44734: LD_INT 5
44736: NEG
44737: PUSH
44738: EMPTY
44739: LIST
44740: LIST
44741: PUSH
44742: LD_INT 3
44744: PUSH
44745: LD_INT 0
44747: PUSH
44748: EMPTY
44749: LIST
44750: LIST
44751: PUSH
44752: LD_INT 3
44754: PUSH
44755: LD_INT 1
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 4
44765: PUSH
44766: LD_INT 0
44768: PUSH
44769: EMPTY
44770: LIST
44771: LIST
44772: PUSH
44773: LD_INT 4
44775: PUSH
44776: LD_INT 1
44778: PUSH
44779: EMPTY
44780: LIST
44781: LIST
44782: PUSH
44783: LD_INT 3
44785: PUSH
44786: LD_INT 1
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PUSH
44793: LD_INT 2
44795: PUSH
44796: LD_INT 0
44798: PUSH
44799: EMPTY
44800: LIST
44801: LIST
44802: PUSH
44803: LD_INT 2
44805: PUSH
44806: LD_INT 1
44808: NEG
44809: PUSH
44810: EMPTY
44811: LIST
44812: LIST
44813: PUSH
44814: LD_INT 2
44816: PUSH
44817: LD_INT 2
44819: NEG
44820: PUSH
44821: EMPTY
44822: LIST
44823: LIST
44824: PUSH
44825: LD_INT 4
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: EMPTY
44832: LIST
44833: LIST
44834: PUSH
44835: LD_INT 4
44837: PUSH
44838: LD_INT 4
44840: PUSH
44841: EMPTY
44842: LIST
44843: LIST
44844: PUSH
44845: LD_INT 4
44847: PUSH
44848: LD_INT 3
44850: PUSH
44851: EMPTY
44852: LIST
44853: LIST
44854: PUSH
44855: LD_INT 5
44857: PUSH
44858: LD_INT 4
44860: PUSH
44861: EMPTY
44862: LIST
44863: LIST
44864: PUSH
44865: LD_INT 5
44867: PUSH
44868: LD_INT 5
44870: PUSH
44871: EMPTY
44872: LIST
44873: LIST
44874: PUSH
44875: LD_INT 4
44877: PUSH
44878: LD_INT 5
44880: PUSH
44881: EMPTY
44882: LIST
44883: LIST
44884: PUSH
44885: LD_INT 3
44887: PUSH
44888: LD_INT 4
44890: PUSH
44891: EMPTY
44892: LIST
44893: LIST
44894: PUSH
44895: LD_INT 3
44897: PUSH
44898: LD_INT 3
44900: PUSH
44901: EMPTY
44902: LIST
44903: LIST
44904: PUSH
44905: LD_INT 5
44907: PUSH
44908: LD_INT 3
44910: PUSH
44911: EMPTY
44912: LIST
44913: LIST
44914: PUSH
44915: LD_INT 3
44917: PUSH
44918: LD_INT 5
44920: PUSH
44921: EMPTY
44922: LIST
44923: LIST
44924: PUSH
44925: LD_INT 0
44927: PUSH
44928: LD_INT 3
44930: PUSH
44931: EMPTY
44932: LIST
44933: LIST
44934: PUSH
44935: LD_INT 0
44937: PUSH
44938: LD_INT 2
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 1
44947: PUSH
44948: LD_INT 3
44950: PUSH
44951: EMPTY
44952: LIST
44953: LIST
44954: PUSH
44955: LD_INT 1
44957: PUSH
44958: LD_INT 4
44960: PUSH
44961: EMPTY
44962: LIST
44963: LIST
44964: PUSH
44965: LD_INT 0
44967: PUSH
44968: LD_INT 4
44970: PUSH
44971: EMPTY
44972: LIST
44973: LIST
44974: PUSH
44975: LD_INT 1
44977: NEG
44978: PUSH
44979: LD_INT 3
44981: PUSH
44982: EMPTY
44983: LIST
44984: LIST
44985: PUSH
44986: LD_INT 1
44988: NEG
44989: PUSH
44990: LD_INT 2
44992: PUSH
44993: EMPTY
44994: LIST
44995: LIST
44996: PUSH
44997: LD_INT 2
44999: PUSH
45000: LD_INT 4
45002: PUSH
45003: EMPTY
45004: LIST
45005: LIST
45006: PUSH
45007: LD_INT 2
45009: NEG
45010: PUSH
45011: LD_INT 2
45013: PUSH
45014: EMPTY
45015: LIST
45016: LIST
45017: PUSH
45018: LD_INT 4
45020: NEG
45021: PUSH
45022: LD_INT 0
45024: PUSH
45025: EMPTY
45026: LIST
45027: LIST
45028: PUSH
45029: LD_INT 4
45031: NEG
45032: PUSH
45033: LD_INT 1
45035: NEG
45036: PUSH
45037: EMPTY
45038: LIST
45039: LIST
45040: PUSH
45041: LD_INT 3
45043: NEG
45044: PUSH
45045: LD_INT 0
45047: PUSH
45048: EMPTY
45049: LIST
45050: LIST
45051: PUSH
45052: LD_INT 3
45054: NEG
45055: PUSH
45056: LD_INT 1
45058: PUSH
45059: EMPTY
45060: LIST
45061: LIST
45062: PUSH
45063: LD_INT 4
45065: NEG
45066: PUSH
45067: LD_INT 1
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 5
45076: NEG
45077: PUSH
45078: LD_INT 0
45080: PUSH
45081: EMPTY
45082: LIST
45083: LIST
45084: PUSH
45085: LD_INT 5
45087: NEG
45088: PUSH
45089: LD_INT 1
45091: NEG
45092: PUSH
45093: EMPTY
45094: LIST
45095: LIST
45096: PUSH
45097: LD_INT 5
45099: NEG
45100: PUSH
45101: LD_INT 2
45103: NEG
45104: PUSH
45105: EMPTY
45106: LIST
45107: LIST
45108: PUSH
45109: LD_INT 3
45111: NEG
45112: PUSH
45113: LD_INT 2
45115: PUSH
45116: EMPTY
45117: LIST
45118: LIST
45119: PUSH
45120: EMPTY
45121: LIST
45122: LIST
45123: LIST
45124: LIST
45125: LIST
45126: LIST
45127: LIST
45128: LIST
45129: LIST
45130: LIST
45131: LIST
45132: LIST
45133: LIST
45134: LIST
45135: LIST
45136: LIST
45137: LIST
45138: LIST
45139: LIST
45140: LIST
45141: LIST
45142: LIST
45143: LIST
45144: LIST
45145: LIST
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: ST_TO_ADDR
// end ; end ;
45167: GO 45170
45169: POP
// case btype of b_depot , b_warehouse :
45170: LD_VAR 0 1
45174: PUSH
45175: LD_INT 0
45177: DOUBLE
45178: EQUAL
45179: IFTRUE 45189
45181: LD_INT 1
45183: DOUBLE
45184: EQUAL
45185: IFTRUE 45189
45187: GO 45390
45189: POP
// case nation of nation_american :
45190: LD_VAR 0 5
45194: PUSH
45195: LD_INT 1
45197: DOUBLE
45198: EQUAL
45199: IFTRUE 45203
45201: GO 45259
45203: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
45204: LD_ADDR_VAR 0 9
45208: PUSH
45209: LD_VAR 0 11
45213: PUSH
45214: LD_VAR 0 12
45218: PUSH
45219: LD_VAR 0 13
45223: PUSH
45224: LD_VAR 0 14
45228: PUSH
45229: LD_VAR 0 15
45233: PUSH
45234: LD_VAR 0 16
45238: PUSH
45239: EMPTY
45240: LIST
45241: LIST
45242: LIST
45243: LIST
45244: LIST
45245: LIST
45246: PUSH
45247: LD_VAR 0 4
45251: PUSH
45252: LD_INT 1
45254: PLUS
45255: ARRAY
45256: ST_TO_ADDR
45257: GO 45388
45259: LD_INT 2
45261: DOUBLE
45262: EQUAL
45263: IFTRUE 45267
45265: GO 45323
45267: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
45268: LD_ADDR_VAR 0 9
45272: PUSH
45273: LD_VAR 0 17
45277: PUSH
45278: LD_VAR 0 18
45282: PUSH
45283: LD_VAR 0 19
45287: PUSH
45288: LD_VAR 0 20
45292: PUSH
45293: LD_VAR 0 21
45297: PUSH
45298: LD_VAR 0 22
45302: PUSH
45303: EMPTY
45304: LIST
45305: LIST
45306: LIST
45307: LIST
45308: LIST
45309: LIST
45310: PUSH
45311: LD_VAR 0 4
45315: PUSH
45316: LD_INT 1
45318: PLUS
45319: ARRAY
45320: ST_TO_ADDR
45321: GO 45388
45323: LD_INT 3
45325: DOUBLE
45326: EQUAL
45327: IFTRUE 45331
45329: GO 45387
45331: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45332: LD_ADDR_VAR 0 9
45336: PUSH
45337: LD_VAR 0 23
45341: PUSH
45342: LD_VAR 0 24
45346: PUSH
45347: LD_VAR 0 25
45351: PUSH
45352: LD_VAR 0 26
45356: PUSH
45357: LD_VAR 0 27
45361: PUSH
45362: LD_VAR 0 28
45366: PUSH
45367: EMPTY
45368: LIST
45369: LIST
45370: LIST
45371: LIST
45372: LIST
45373: LIST
45374: PUSH
45375: LD_VAR 0 4
45379: PUSH
45380: LD_INT 1
45382: PLUS
45383: ARRAY
45384: ST_TO_ADDR
45385: GO 45388
45387: POP
45388: GO 45943
45390: LD_INT 2
45392: DOUBLE
45393: EQUAL
45394: IFTRUE 45404
45396: LD_INT 3
45398: DOUBLE
45399: EQUAL
45400: IFTRUE 45404
45402: GO 45460
45404: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45405: LD_ADDR_VAR 0 9
45409: PUSH
45410: LD_VAR 0 29
45414: PUSH
45415: LD_VAR 0 30
45419: PUSH
45420: LD_VAR 0 31
45424: PUSH
45425: LD_VAR 0 32
45429: PUSH
45430: LD_VAR 0 33
45434: PUSH
45435: LD_VAR 0 34
45439: PUSH
45440: EMPTY
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: PUSH
45448: LD_VAR 0 4
45452: PUSH
45453: LD_INT 1
45455: PLUS
45456: ARRAY
45457: ST_TO_ADDR
45458: GO 45943
45460: LD_INT 16
45462: DOUBLE
45463: EQUAL
45464: IFTRUE 45522
45466: LD_INT 17
45468: DOUBLE
45469: EQUAL
45470: IFTRUE 45522
45472: LD_INT 18
45474: DOUBLE
45475: EQUAL
45476: IFTRUE 45522
45478: LD_INT 19
45480: DOUBLE
45481: EQUAL
45482: IFTRUE 45522
45484: LD_INT 22
45486: DOUBLE
45487: EQUAL
45488: IFTRUE 45522
45490: LD_INT 20
45492: DOUBLE
45493: EQUAL
45494: IFTRUE 45522
45496: LD_INT 21
45498: DOUBLE
45499: EQUAL
45500: IFTRUE 45522
45502: LD_INT 23
45504: DOUBLE
45505: EQUAL
45506: IFTRUE 45522
45508: LD_INT 24
45510: DOUBLE
45511: EQUAL
45512: IFTRUE 45522
45514: LD_INT 25
45516: DOUBLE
45517: EQUAL
45518: IFTRUE 45522
45520: GO 45578
45522: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45523: LD_ADDR_VAR 0 9
45527: PUSH
45528: LD_VAR 0 35
45532: PUSH
45533: LD_VAR 0 36
45537: PUSH
45538: LD_VAR 0 37
45542: PUSH
45543: LD_VAR 0 38
45547: PUSH
45548: LD_VAR 0 39
45552: PUSH
45553: LD_VAR 0 40
45557: PUSH
45558: EMPTY
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: PUSH
45566: LD_VAR 0 4
45570: PUSH
45571: LD_INT 1
45573: PLUS
45574: ARRAY
45575: ST_TO_ADDR
45576: GO 45943
45578: LD_INT 6
45580: DOUBLE
45581: EQUAL
45582: IFTRUE 45634
45584: LD_INT 7
45586: DOUBLE
45587: EQUAL
45588: IFTRUE 45634
45590: LD_INT 8
45592: DOUBLE
45593: EQUAL
45594: IFTRUE 45634
45596: LD_INT 13
45598: DOUBLE
45599: EQUAL
45600: IFTRUE 45634
45602: LD_INT 12
45604: DOUBLE
45605: EQUAL
45606: IFTRUE 45634
45608: LD_INT 15
45610: DOUBLE
45611: EQUAL
45612: IFTRUE 45634
45614: LD_INT 11
45616: DOUBLE
45617: EQUAL
45618: IFTRUE 45634
45620: LD_INT 14
45622: DOUBLE
45623: EQUAL
45624: IFTRUE 45634
45626: LD_INT 10
45628: DOUBLE
45629: EQUAL
45630: IFTRUE 45634
45632: GO 45690
45634: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
45635: LD_ADDR_VAR 0 9
45639: PUSH
45640: LD_VAR 0 41
45644: PUSH
45645: LD_VAR 0 42
45649: PUSH
45650: LD_VAR 0 43
45654: PUSH
45655: LD_VAR 0 44
45659: PUSH
45660: LD_VAR 0 45
45664: PUSH
45665: LD_VAR 0 46
45669: PUSH
45670: EMPTY
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: LIST
45677: PUSH
45678: LD_VAR 0 4
45682: PUSH
45683: LD_INT 1
45685: PLUS
45686: ARRAY
45687: ST_TO_ADDR
45688: GO 45943
45690: LD_INT 36
45692: DOUBLE
45693: EQUAL
45694: IFTRUE 45698
45696: GO 45754
45698: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45699: LD_ADDR_VAR 0 9
45703: PUSH
45704: LD_VAR 0 47
45708: PUSH
45709: LD_VAR 0 48
45713: PUSH
45714: LD_VAR 0 49
45718: PUSH
45719: LD_VAR 0 50
45723: PUSH
45724: LD_VAR 0 51
45728: PUSH
45729: LD_VAR 0 52
45733: PUSH
45734: EMPTY
45735: LIST
45736: LIST
45737: LIST
45738: LIST
45739: LIST
45740: LIST
45741: PUSH
45742: LD_VAR 0 4
45746: PUSH
45747: LD_INT 1
45749: PLUS
45750: ARRAY
45751: ST_TO_ADDR
45752: GO 45943
45754: LD_INT 4
45756: DOUBLE
45757: EQUAL
45758: IFTRUE 45780
45760: LD_INT 5
45762: DOUBLE
45763: EQUAL
45764: IFTRUE 45780
45766: LD_INT 34
45768: DOUBLE
45769: EQUAL
45770: IFTRUE 45780
45772: LD_INT 37
45774: DOUBLE
45775: EQUAL
45776: IFTRUE 45780
45778: GO 45836
45780: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45781: LD_ADDR_VAR 0 9
45785: PUSH
45786: LD_VAR 0 53
45790: PUSH
45791: LD_VAR 0 54
45795: PUSH
45796: LD_VAR 0 55
45800: PUSH
45801: LD_VAR 0 56
45805: PUSH
45806: LD_VAR 0 57
45810: PUSH
45811: LD_VAR 0 58
45815: PUSH
45816: EMPTY
45817: LIST
45818: LIST
45819: LIST
45820: LIST
45821: LIST
45822: LIST
45823: PUSH
45824: LD_VAR 0 4
45828: PUSH
45829: LD_INT 1
45831: PLUS
45832: ARRAY
45833: ST_TO_ADDR
45834: GO 45943
45836: LD_INT 31
45838: DOUBLE
45839: EQUAL
45840: IFTRUE 45886
45842: LD_INT 32
45844: DOUBLE
45845: EQUAL
45846: IFTRUE 45886
45848: LD_INT 33
45850: DOUBLE
45851: EQUAL
45852: IFTRUE 45886
45854: LD_INT 27
45856: DOUBLE
45857: EQUAL
45858: IFTRUE 45886
45860: LD_INT 26
45862: DOUBLE
45863: EQUAL
45864: IFTRUE 45886
45866: LD_INT 28
45868: DOUBLE
45869: EQUAL
45870: IFTRUE 45886
45872: LD_INT 29
45874: DOUBLE
45875: EQUAL
45876: IFTRUE 45886
45878: LD_INT 30
45880: DOUBLE
45881: EQUAL
45882: IFTRUE 45886
45884: GO 45942
45886: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
45887: LD_ADDR_VAR 0 9
45891: PUSH
45892: LD_VAR 0 59
45896: PUSH
45897: LD_VAR 0 60
45901: PUSH
45902: LD_VAR 0 61
45906: PUSH
45907: LD_VAR 0 62
45911: PUSH
45912: LD_VAR 0 63
45916: PUSH
45917: LD_VAR 0 64
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: LIST
45926: LIST
45927: LIST
45928: LIST
45929: PUSH
45930: LD_VAR 0 4
45934: PUSH
45935: LD_INT 1
45937: PLUS
45938: ARRAY
45939: ST_TO_ADDR
45940: GO 45943
45942: POP
// temp_list2 = [ ] ;
45943: LD_ADDR_VAR 0 10
45947: PUSH
45948: EMPTY
45949: ST_TO_ADDR
// for i in temp_list do
45950: LD_ADDR_VAR 0 8
45954: PUSH
45955: LD_VAR 0 9
45959: PUSH
45960: FOR_IN
45961: IFFALSE 46013
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45963: LD_ADDR_VAR 0 10
45967: PUSH
45968: LD_VAR 0 10
45972: PUSH
45973: LD_VAR 0 8
45977: PUSH
45978: LD_INT 1
45980: ARRAY
45981: PUSH
45982: LD_VAR 0 2
45986: PLUS
45987: PUSH
45988: LD_VAR 0 8
45992: PUSH
45993: LD_INT 2
45995: ARRAY
45996: PUSH
45997: LD_VAR 0 3
46001: PLUS
46002: PUSH
46003: EMPTY
46004: LIST
46005: LIST
46006: PUSH
46007: EMPTY
46008: LIST
46009: ADD
46010: ST_TO_ADDR
46011: GO 45960
46013: POP
46014: POP
// result = temp_list2 ;
46015: LD_ADDR_VAR 0 7
46019: PUSH
46020: LD_VAR 0 10
46024: ST_TO_ADDR
// end ;
46025: LD_VAR 0 7
46029: RET
// export function EnemyInRange ( unit , dist ) ; begin
46030: LD_INT 0
46032: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46033: LD_ADDR_VAR 0 3
46037: PUSH
46038: LD_VAR 0 1
46042: PPUSH
46043: CALL_OW 255
46047: PPUSH
46048: LD_VAR 0 1
46052: PPUSH
46053: CALL_OW 250
46057: PPUSH
46058: LD_VAR 0 1
46062: PPUSH
46063: CALL_OW 251
46067: PPUSH
46068: LD_VAR 0 2
46072: PPUSH
46073: CALL 20134 0 4
46077: PUSH
46078: LD_INT 4
46080: ARRAY
46081: ST_TO_ADDR
// end ;
46082: LD_VAR 0 3
46086: RET
// export function PlayerSeeMe ( unit ) ; begin
46087: LD_INT 0
46089: PPUSH
// result := See ( your_side , unit ) ;
46090: LD_ADDR_VAR 0 2
46094: PUSH
46095: LD_OWVAR 2
46099: PPUSH
46100: LD_VAR 0 1
46104: PPUSH
46105: CALL_OW 292
46109: ST_TO_ADDR
// end ;
46110: LD_VAR 0 2
46114: RET
// export function ReverseDir ( unit ) ; begin
46115: LD_INT 0
46117: PPUSH
// if not unit then
46118: LD_VAR 0 1
46122: NOT
46123: IFFALSE 46127
// exit ;
46125: GO 46150
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46127: LD_ADDR_VAR 0 2
46131: PUSH
46132: LD_VAR 0 1
46136: PPUSH
46137: CALL_OW 254
46141: PUSH
46142: LD_INT 3
46144: PLUS
46145: PUSH
46146: LD_INT 6
46148: MOD
46149: ST_TO_ADDR
// end ;
46150: LD_VAR 0 2
46154: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46155: LD_INT 0
46157: PPUSH
46158: PPUSH
46159: PPUSH
46160: PPUSH
46161: PPUSH
// if not hexes then
46162: LD_VAR 0 2
46166: NOT
46167: IFFALSE 46171
// exit ;
46169: GO 46319
// dist := 9999 ;
46171: LD_ADDR_VAR 0 5
46175: PUSH
46176: LD_INT 9999
46178: ST_TO_ADDR
// for i = 1 to hexes do
46179: LD_ADDR_VAR 0 4
46183: PUSH
46184: DOUBLE
46185: LD_INT 1
46187: DEC
46188: ST_TO_ADDR
46189: LD_VAR 0 2
46193: PUSH
46194: FOR_TO
46195: IFFALSE 46307
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46197: LD_VAR 0 1
46201: PPUSH
46202: LD_VAR 0 2
46206: PUSH
46207: LD_VAR 0 4
46211: ARRAY
46212: PUSH
46213: LD_INT 1
46215: ARRAY
46216: PPUSH
46217: LD_VAR 0 2
46221: PUSH
46222: LD_VAR 0 4
46226: ARRAY
46227: PUSH
46228: LD_INT 2
46230: ARRAY
46231: PPUSH
46232: CALL_OW 297
46236: PUSH
46237: LD_VAR 0 5
46241: LESS
46242: IFFALSE 46305
// begin hex := hexes [ i ] ;
46244: LD_ADDR_VAR 0 7
46248: PUSH
46249: LD_VAR 0 2
46253: PUSH
46254: LD_VAR 0 4
46258: ARRAY
46259: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46260: LD_ADDR_VAR 0 5
46264: PUSH
46265: LD_VAR 0 1
46269: PPUSH
46270: LD_VAR 0 2
46274: PUSH
46275: LD_VAR 0 4
46279: ARRAY
46280: PUSH
46281: LD_INT 1
46283: ARRAY
46284: PPUSH
46285: LD_VAR 0 2
46289: PUSH
46290: LD_VAR 0 4
46294: ARRAY
46295: PUSH
46296: LD_INT 2
46298: ARRAY
46299: PPUSH
46300: CALL_OW 297
46304: ST_TO_ADDR
// end ; end ;
46305: GO 46194
46307: POP
46308: POP
// result := hex ;
46309: LD_ADDR_VAR 0 3
46313: PUSH
46314: LD_VAR 0 7
46318: ST_TO_ADDR
// end ;
46319: LD_VAR 0 3
46323: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46324: LD_INT 0
46326: PPUSH
46327: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46328: LD_VAR 0 1
46332: NOT
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_INT 21
46341: PUSH
46342: LD_INT 2
46344: PUSH
46345: EMPTY
46346: LIST
46347: LIST
46348: PUSH
46349: LD_INT 23
46351: PUSH
46352: LD_INT 2
46354: PUSH
46355: EMPTY
46356: LIST
46357: LIST
46358: PUSH
46359: EMPTY
46360: LIST
46361: LIST
46362: PPUSH
46363: CALL_OW 69
46367: IN
46368: NOT
46369: OR
46370: IFFALSE 46374
// exit ;
46372: GO 46421
// for i = 1 to 3 do
46374: LD_ADDR_VAR 0 3
46378: PUSH
46379: DOUBLE
46380: LD_INT 1
46382: DEC
46383: ST_TO_ADDR
46384: LD_INT 3
46386: PUSH
46387: FOR_TO
46388: IFFALSE 46419
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46390: LD_VAR 0 1
46394: PPUSH
46395: CALL_OW 250
46399: PPUSH
46400: LD_VAR 0 1
46404: PPUSH
46405: CALL_OW 251
46409: PPUSH
46410: LD_INT 1
46412: PPUSH
46413: CALL_OW 453
46417: GO 46387
46419: POP
46420: POP
// end ;
46421: LD_VAR 0 2
46425: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46426: LD_INT 0
46428: PPUSH
46429: PPUSH
46430: PPUSH
46431: PPUSH
46432: PPUSH
46433: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46434: LD_VAR 0 1
46438: NOT
46439: PUSH
46440: LD_VAR 0 2
46444: NOT
46445: OR
46446: PUSH
46447: LD_VAR 0 1
46451: PPUSH
46452: CALL_OW 314
46456: OR
46457: IFFALSE 46461
// exit ;
46459: GO 46902
// x := GetX ( enemy_unit ) ;
46461: LD_ADDR_VAR 0 7
46465: PUSH
46466: LD_VAR 0 2
46470: PPUSH
46471: CALL_OW 250
46475: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46476: LD_ADDR_VAR 0 8
46480: PUSH
46481: LD_VAR 0 2
46485: PPUSH
46486: CALL_OW 251
46490: ST_TO_ADDR
// if not x or not y then
46491: LD_VAR 0 7
46495: NOT
46496: PUSH
46497: LD_VAR 0 8
46501: NOT
46502: OR
46503: IFFALSE 46507
// exit ;
46505: GO 46902
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46507: LD_ADDR_VAR 0 6
46511: PUSH
46512: LD_VAR 0 7
46516: PPUSH
46517: LD_INT 0
46519: PPUSH
46520: LD_INT 4
46522: PPUSH
46523: CALL_OW 272
46527: PUSH
46528: LD_VAR 0 8
46532: PPUSH
46533: LD_INT 0
46535: PPUSH
46536: LD_INT 4
46538: PPUSH
46539: CALL_OW 273
46543: PUSH
46544: EMPTY
46545: LIST
46546: LIST
46547: PUSH
46548: LD_VAR 0 7
46552: PPUSH
46553: LD_INT 1
46555: PPUSH
46556: LD_INT 4
46558: PPUSH
46559: CALL_OW 272
46563: PUSH
46564: LD_VAR 0 8
46568: PPUSH
46569: LD_INT 1
46571: PPUSH
46572: LD_INT 4
46574: PPUSH
46575: CALL_OW 273
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_VAR 0 7
46588: PPUSH
46589: LD_INT 2
46591: PPUSH
46592: LD_INT 4
46594: PPUSH
46595: CALL_OW 272
46599: PUSH
46600: LD_VAR 0 8
46604: PPUSH
46605: LD_INT 2
46607: PPUSH
46608: LD_INT 4
46610: PPUSH
46611: CALL_OW 273
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_VAR 0 7
46624: PPUSH
46625: LD_INT 3
46627: PPUSH
46628: LD_INT 4
46630: PPUSH
46631: CALL_OW 272
46635: PUSH
46636: LD_VAR 0 8
46640: PPUSH
46641: LD_INT 3
46643: PPUSH
46644: LD_INT 4
46646: PPUSH
46647: CALL_OW 273
46651: PUSH
46652: EMPTY
46653: LIST
46654: LIST
46655: PUSH
46656: LD_VAR 0 7
46660: PPUSH
46661: LD_INT 4
46663: PPUSH
46664: LD_INT 4
46666: PPUSH
46667: CALL_OW 272
46671: PUSH
46672: LD_VAR 0 8
46676: PPUSH
46677: LD_INT 4
46679: PPUSH
46680: LD_INT 4
46682: PPUSH
46683: CALL_OW 273
46687: PUSH
46688: EMPTY
46689: LIST
46690: LIST
46691: PUSH
46692: LD_VAR 0 7
46696: PPUSH
46697: LD_INT 5
46699: PPUSH
46700: LD_INT 4
46702: PPUSH
46703: CALL_OW 272
46707: PUSH
46708: LD_VAR 0 8
46712: PPUSH
46713: LD_INT 5
46715: PPUSH
46716: LD_INT 4
46718: PPUSH
46719: CALL_OW 273
46723: PUSH
46724: EMPTY
46725: LIST
46726: LIST
46727: PUSH
46728: EMPTY
46729: LIST
46730: LIST
46731: LIST
46732: LIST
46733: LIST
46734: LIST
46735: ST_TO_ADDR
// for i = tmp downto 1 do
46736: LD_ADDR_VAR 0 4
46740: PUSH
46741: DOUBLE
46742: LD_VAR 0 6
46746: INC
46747: ST_TO_ADDR
46748: LD_INT 1
46750: PUSH
46751: FOR_DOWNTO
46752: IFFALSE 46853
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46754: LD_VAR 0 6
46758: PUSH
46759: LD_VAR 0 4
46763: ARRAY
46764: PUSH
46765: LD_INT 1
46767: ARRAY
46768: PPUSH
46769: LD_VAR 0 6
46773: PUSH
46774: LD_VAR 0 4
46778: ARRAY
46779: PUSH
46780: LD_INT 2
46782: ARRAY
46783: PPUSH
46784: CALL_OW 488
46788: NOT
46789: PUSH
46790: LD_VAR 0 6
46794: PUSH
46795: LD_VAR 0 4
46799: ARRAY
46800: PUSH
46801: LD_INT 1
46803: ARRAY
46804: PPUSH
46805: LD_VAR 0 6
46809: PUSH
46810: LD_VAR 0 4
46814: ARRAY
46815: PUSH
46816: LD_INT 2
46818: ARRAY
46819: PPUSH
46820: CALL_OW 428
46824: PUSH
46825: LD_INT 0
46827: NONEQUAL
46828: OR
46829: IFFALSE 46851
// tmp := Delete ( tmp , i ) ;
46831: LD_ADDR_VAR 0 6
46835: PUSH
46836: LD_VAR 0 6
46840: PPUSH
46841: LD_VAR 0 4
46845: PPUSH
46846: CALL_OW 3
46850: ST_TO_ADDR
46851: GO 46751
46853: POP
46854: POP
// j := GetClosestHex ( unit , tmp ) ;
46855: LD_ADDR_VAR 0 5
46859: PUSH
46860: LD_VAR 0 1
46864: PPUSH
46865: LD_VAR 0 6
46869: PPUSH
46870: CALL 46155 0 2
46874: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46875: LD_VAR 0 1
46879: PPUSH
46880: LD_VAR 0 5
46884: PUSH
46885: LD_INT 1
46887: ARRAY
46888: PPUSH
46889: LD_VAR 0 5
46893: PUSH
46894: LD_INT 2
46896: ARRAY
46897: PPUSH
46898: CALL_OW 111
// end ;
46902: LD_VAR 0 3
46906: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46907: LD_INT 0
46909: PPUSH
46910: PPUSH
46911: PPUSH
// uc_side = 0 ;
46912: LD_ADDR_OWVAR 20
46916: PUSH
46917: LD_INT 0
46919: ST_TO_ADDR
// uc_nation = 0 ;
46920: LD_ADDR_OWVAR 21
46924: PUSH
46925: LD_INT 0
46927: ST_TO_ADDR
// InitHc ;
46928: CALL_OW 19
// InitVc ;
46932: CALL_OW 20
// if mastodonts then
46936: LD_VAR 0 6
46940: IFFALSE 47007
// for i = 1 to mastodonts do
46942: LD_ADDR_VAR 0 11
46946: PUSH
46947: DOUBLE
46948: LD_INT 1
46950: DEC
46951: ST_TO_ADDR
46952: LD_VAR 0 6
46956: PUSH
46957: FOR_TO
46958: IFFALSE 47005
// begin vc_chassis := 31 ;
46960: LD_ADDR_OWVAR 37
46964: PUSH
46965: LD_INT 31
46967: ST_TO_ADDR
// vc_control := control_rider ;
46968: LD_ADDR_OWVAR 38
46972: PUSH
46973: LD_INT 4
46975: ST_TO_ADDR
// animal := CreateVehicle ;
46976: LD_ADDR_VAR 0 12
46980: PUSH
46981: CALL_OW 45
46985: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
46986: LD_VAR 0 12
46990: PPUSH
46991: LD_VAR 0 8
46995: PPUSH
46996: LD_INT 0
46998: PPUSH
46999: CALL 49076 0 3
// end ;
47003: GO 46957
47005: POP
47006: POP
// if horses then
47007: LD_VAR 0 5
47011: IFFALSE 47078
// for i = 1 to horses do
47013: LD_ADDR_VAR 0 11
47017: PUSH
47018: DOUBLE
47019: LD_INT 1
47021: DEC
47022: ST_TO_ADDR
47023: LD_VAR 0 5
47027: PUSH
47028: FOR_TO
47029: IFFALSE 47076
// begin hc_class := 21 ;
47031: LD_ADDR_OWVAR 28
47035: PUSH
47036: LD_INT 21
47038: ST_TO_ADDR
// hc_gallery :=  ;
47039: LD_ADDR_OWVAR 33
47043: PUSH
47044: LD_STRING 
47046: ST_TO_ADDR
// animal := CreateHuman ;
47047: LD_ADDR_VAR 0 12
47051: PUSH
47052: CALL_OW 44
47056: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47057: LD_VAR 0 12
47061: PPUSH
47062: LD_VAR 0 8
47066: PPUSH
47067: LD_INT 0
47069: PPUSH
47070: CALL 49076 0 3
// end ;
47074: GO 47028
47076: POP
47077: POP
// if birds then
47078: LD_VAR 0 1
47082: IFFALSE 47149
// for i = 1 to birds do
47084: LD_ADDR_VAR 0 11
47088: PUSH
47089: DOUBLE
47090: LD_INT 1
47092: DEC
47093: ST_TO_ADDR
47094: LD_VAR 0 1
47098: PUSH
47099: FOR_TO
47100: IFFALSE 47147
// begin hc_class = 18 ;
47102: LD_ADDR_OWVAR 28
47106: PUSH
47107: LD_INT 18
47109: ST_TO_ADDR
// hc_gallery =  ;
47110: LD_ADDR_OWVAR 33
47114: PUSH
47115: LD_STRING 
47117: ST_TO_ADDR
// animal := CreateHuman ;
47118: LD_ADDR_VAR 0 12
47122: PUSH
47123: CALL_OW 44
47127: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47128: LD_VAR 0 12
47132: PPUSH
47133: LD_VAR 0 8
47137: PPUSH
47138: LD_INT 0
47140: PPUSH
47141: CALL 49076 0 3
// end ;
47145: GO 47099
47147: POP
47148: POP
// if tigers then
47149: LD_VAR 0 2
47153: IFFALSE 47237
// for i = 1 to tigers do
47155: LD_ADDR_VAR 0 11
47159: PUSH
47160: DOUBLE
47161: LD_INT 1
47163: DEC
47164: ST_TO_ADDR
47165: LD_VAR 0 2
47169: PUSH
47170: FOR_TO
47171: IFFALSE 47235
// begin hc_class = class_tiger ;
47173: LD_ADDR_OWVAR 28
47177: PUSH
47178: LD_INT 14
47180: ST_TO_ADDR
// hc_gallery =  ;
47181: LD_ADDR_OWVAR 33
47185: PUSH
47186: LD_STRING 
47188: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47189: LD_ADDR_OWVAR 35
47193: PUSH
47194: LD_INT 7
47196: NEG
47197: PPUSH
47198: LD_INT 7
47200: PPUSH
47201: CALL_OW 12
47205: ST_TO_ADDR
// animal := CreateHuman ;
47206: LD_ADDR_VAR 0 12
47210: PUSH
47211: CALL_OW 44
47215: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47216: LD_VAR 0 12
47220: PPUSH
47221: LD_VAR 0 8
47225: PPUSH
47226: LD_INT 0
47228: PPUSH
47229: CALL 49076 0 3
// end ;
47233: GO 47170
47235: POP
47236: POP
// if apemans then
47237: LD_VAR 0 3
47241: IFFALSE 47364
// for i = 1 to apemans do
47243: LD_ADDR_VAR 0 11
47247: PUSH
47248: DOUBLE
47249: LD_INT 1
47251: DEC
47252: ST_TO_ADDR
47253: LD_VAR 0 3
47257: PUSH
47258: FOR_TO
47259: IFFALSE 47362
// begin hc_class = class_apeman ;
47261: LD_ADDR_OWVAR 28
47265: PUSH
47266: LD_INT 12
47268: ST_TO_ADDR
// hc_gallery =  ;
47269: LD_ADDR_OWVAR 33
47273: PUSH
47274: LD_STRING 
47276: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47277: LD_ADDR_OWVAR 35
47281: PUSH
47282: LD_INT 5
47284: NEG
47285: PPUSH
47286: LD_INT 5
47288: PPUSH
47289: CALL_OW 12
47293: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47294: LD_ADDR_OWVAR 31
47298: PUSH
47299: LD_INT 1
47301: PPUSH
47302: LD_INT 3
47304: PPUSH
47305: CALL_OW 12
47309: PUSH
47310: LD_INT 1
47312: PPUSH
47313: LD_INT 3
47315: PPUSH
47316: CALL_OW 12
47320: PUSH
47321: LD_INT 0
47323: PUSH
47324: LD_INT 0
47326: PUSH
47327: EMPTY
47328: LIST
47329: LIST
47330: LIST
47331: LIST
47332: ST_TO_ADDR
// animal := CreateHuman ;
47333: LD_ADDR_VAR 0 12
47337: PUSH
47338: CALL_OW 44
47342: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47343: LD_VAR 0 12
47347: PPUSH
47348: LD_VAR 0 8
47352: PPUSH
47353: LD_INT 0
47355: PPUSH
47356: CALL 49076 0 3
// end ;
47360: GO 47258
47362: POP
47363: POP
// if enchidnas then
47364: LD_VAR 0 4
47368: IFFALSE 47435
// for i = 1 to enchidnas do
47370: LD_ADDR_VAR 0 11
47374: PUSH
47375: DOUBLE
47376: LD_INT 1
47378: DEC
47379: ST_TO_ADDR
47380: LD_VAR 0 4
47384: PUSH
47385: FOR_TO
47386: IFFALSE 47433
// begin hc_class = 13 ;
47388: LD_ADDR_OWVAR 28
47392: PUSH
47393: LD_INT 13
47395: ST_TO_ADDR
// hc_gallery =  ;
47396: LD_ADDR_OWVAR 33
47400: PUSH
47401: LD_STRING 
47403: ST_TO_ADDR
// animal := CreateHuman ;
47404: LD_ADDR_VAR 0 12
47408: PUSH
47409: CALL_OW 44
47413: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47414: LD_VAR 0 12
47418: PPUSH
47419: LD_VAR 0 8
47423: PPUSH
47424: LD_INT 0
47426: PPUSH
47427: CALL 49076 0 3
// end ;
47431: GO 47385
47433: POP
47434: POP
// if fishes then
47435: LD_VAR 0 7
47439: IFFALSE 47506
// for i = 1 to fishes do
47441: LD_ADDR_VAR 0 11
47445: PUSH
47446: DOUBLE
47447: LD_INT 1
47449: DEC
47450: ST_TO_ADDR
47451: LD_VAR 0 7
47455: PUSH
47456: FOR_TO
47457: IFFALSE 47504
// begin hc_class = 20 ;
47459: LD_ADDR_OWVAR 28
47463: PUSH
47464: LD_INT 20
47466: ST_TO_ADDR
// hc_gallery =  ;
47467: LD_ADDR_OWVAR 33
47471: PUSH
47472: LD_STRING 
47474: ST_TO_ADDR
// animal := CreateHuman ;
47475: LD_ADDR_VAR 0 12
47479: PUSH
47480: CALL_OW 44
47484: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47485: LD_VAR 0 12
47489: PPUSH
47490: LD_VAR 0 9
47494: PPUSH
47495: LD_INT 0
47497: PPUSH
47498: CALL 49076 0 3
// end ;
47502: GO 47456
47504: POP
47505: POP
// end ;
47506: LD_VAR 0 10
47510: RET
// export function WantHeal ( sci , unit ) ; begin
47511: LD_INT 0
47513: PPUSH
// if GetTaskList ( sci ) > 0 then
47514: LD_VAR 0 1
47518: PPUSH
47519: CALL_OW 437
47523: PUSH
47524: LD_INT 0
47526: GREATER
47527: IFFALSE 47597
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47529: LD_VAR 0 1
47533: PPUSH
47534: CALL_OW 437
47538: PUSH
47539: LD_INT 1
47541: ARRAY
47542: PUSH
47543: LD_INT 1
47545: ARRAY
47546: PUSH
47547: LD_STRING l
47549: EQUAL
47550: PUSH
47551: LD_VAR 0 1
47555: PPUSH
47556: CALL_OW 437
47560: PUSH
47561: LD_INT 1
47563: ARRAY
47564: PUSH
47565: LD_INT 4
47567: ARRAY
47568: PUSH
47569: LD_VAR 0 2
47573: EQUAL
47574: AND
47575: IFFALSE 47587
// result := true else
47577: LD_ADDR_VAR 0 3
47581: PUSH
47582: LD_INT 1
47584: ST_TO_ADDR
47585: GO 47595
// result := false ;
47587: LD_ADDR_VAR 0 3
47591: PUSH
47592: LD_INT 0
47594: ST_TO_ADDR
// end else
47595: GO 47605
// result := false ;
47597: LD_ADDR_VAR 0 3
47601: PUSH
47602: LD_INT 0
47604: ST_TO_ADDR
// end ;
47605: LD_VAR 0 3
47609: RET
// export function HealTarget ( sci ) ; begin
47610: LD_INT 0
47612: PPUSH
// if not sci then
47613: LD_VAR 0 1
47617: NOT
47618: IFFALSE 47622
// exit ;
47620: GO 47687
// result := 0 ;
47622: LD_ADDR_VAR 0 2
47626: PUSH
47627: LD_INT 0
47629: ST_TO_ADDR
// if GetTaskList ( sci ) then
47630: LD_VAR 0 1
47634: PPUSH
47635: CALL_OW 437
47639: IFFALSE 47687
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47641: LD_VAR 0 1
47645: PPUSH
47646: CALL_OW 437
47650: PUSH
47651: LD_INT 1
47653: ARRAY
47654: PUSH
47655: LD_INT 1
47657: ARRAY
47658: PUSH
47659: LD_STRING l
47661: EQUAL
47662: IFFALSE 47687
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47664: LD_ADDR_VAR 0 2
47668: PUSH
47669: LD_VAR 0 1
47673: PPUSH
47674: CALL_OW 437
47678: PUSH
47679: LD_INT 1
47681: ARRAY
47682: PUSH
47683: LD_INT 4
47685: ARRAY
47686: ST_TO_ADDR
// end ;
47687: LD_VAR 0 2
47691: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47692: LD_INT 0
47694: PPUSH
47695: PPUSH
47696: PPUSH
47697: PPUSH
// if not base_units then
47698: LD_VAR 0 1
47702: NOT
47703: IFFALSE 47707
// exit ;
47705: GO 47794
// result := false ;
47707: LD_ADDR_VAR 0 2
47711: PUSH
47712: LD_INT 0
47714: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47715: LD_ADDR_VAR 0 5
47719: PUSH
47720: LD_VAR 0 1
47724: PPUSH
47725: LD_INT 21
47727: PUSH
47728: LD_INT 3
47730: PUSH
47731: EMPTY
47732: LIST
47733: LIST
47734: PPUSH
47735: CALL_OW 72
47739: ST_TO_ADDR
// if not tmp then
47740: LD_VAR 0 5
47744: NOT
47745: IFFALSE 47749
// exit ;
47747: GO 47794
// for i in tmp do
47749: LD_ADDR_VAR 0 3
47753: PUSH
47754: LD_VAR 0 5
47758: PUSH
47759: FOR_IN
47760: IFFALSE 47792
// begin result := EnemyInRange ( i , 22 ) ;
47762: LD_ADDR_VAR 0 2
47766: PUSH
47767: LD_VAR 0 3
47771: PPUSH
47772: LD_INT 22
47774: PPUSH
47775: CALL 46030 0 2
47779: ST_TO_ADDR
// if result then
47780: LD_VAR 0 2
47784: IFFALSE 47790
// exit ;
47786: POP
47787: POP
47788: GO 47794
// end ;
47790: GO 47759
47792: POP
47793: POP
// end ;
47794: LD_VAR 0 2
47798: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47799: LD_INT 0
47801: PPUSH
47802: PPUSH
// if not units then
47803: LD_VAR 0 1
47807: NOT
47808: IFFALSE 47812
// exit ;
47810: GO 47882
// result := [ ] ;
47812: LD_ADDR_VAR 0 3
47816: PUSH
47817: EMPTY
47818: ST_TO_ADDR
// for i in units do
47819: LD_ADDR_VAR 0 4
47823: PUSH
47824: LD_VAR 0 1
47828: PUSH
47829: FOR_IN
47830: IFFALSE 47880
// if GetTag ( i ) = tag then
47832: LD_VAR 0 4
47836: PPUSH
47837: CALL_OW 110
47841: PUSH
47842: LD_VAR 0 2
47846: EQUAL
47847: IFFALSE 47878
// result := Insert ( result , result + 1 , i ) ;
47849: LD_ADDR_VAR 0 3
47853: PUSH
47854: LD_VAR 0 3
47858: PPUSH
47859: LD_VAR 0 3
47863: PUSH
47864: LD_INT 1
47866: PLUS
47867: PPUSH
47868: LD_VAR 0 4
47872: PPUSH
47873: CALL_OW 2
47877: ST_TO_ADDR
47878: GO 47829
47880: POP
47881: POP
// end ;
47882: LD_VAR 0 3
47886: RET
// export function IsDriver ( un ) ; begin
47887: LD_INT 0
47889: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47890: LD_ADDR_VAR 0 2
47894: PUSH
47895: LD_VAR 0 1
47899: PUSH
47900: LD_INT 55
47902: PUSH
47903: EMPTY
47904: LIST
47905: PPUSH
47906: CALL_OW 69
47910: IN
47911: ST_TO_ADDR
// end ;
47912: LD_VAR 0 2
47916: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47917: LD_INT 0
47919: PPUSH
47920: PPUSH
// list := [ ] ;
47921: LD_ADDR_VAR 0 5
47925: PUSH
47926: EMPTY
47927: ST_TO_ADDR
// case d of 0 :
47928: LD_VAR 0 3
47932: PUSH
47933: LD_INT 0
47935: DOUBLE
47936: EQUAL
47937: IFTRUE 47941
47939: GO 48074
47941: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47942: LD_ADDR_VAR 0 5
47946: PUSH
47947: LD_VAR 0 1
47951: PUSH
47952: LD_INT 4
47954: MINUS
47955: PUSH
47956: LD_VAR 0 2
47960: PUSH
47961: LD_INT 4
47963: MINUS
47964: PUSH
47965: LD_INT 2
47967: PUSH
47968: EMPTY
47969: LIST
47970: LIST
47971: LIST
47972: PUSH
47973: LD_VAR 0 1
47977: PUSH
47978: LD_INT 3
47980: MINUS
47981: PUSH
47982: LD_VAR 0 2
47986: PUSH
47987: LD_INT 1
47989: PUSH
47990: EMPTY
47991: LIST
47992: LIST
47993: LIST
47994: PUSH
47995: LD_VAR 0 1
47999: PUSH
48000: LD_INT 4
48002: PLUS
48003: PUSH
48004: LD_VAR 0 2
48008: PUSH
48009: LD_INT 4
48011: PUSH
48012: EMPTY
48013: LIST
48014: LIST
48015: LIST
48016: PUSH
48017: LD_VAR 0 1
48021: PUSH
48022: LD_INT 3
48024: PLUS
48025: PUSH
48026: LD_VAR 0 2
48030: PUSH
48031: LD_INT 3
48033: PLUS
48034: PUSH
48035: LD_INT 5
48037: PUSH
48038: EMPTY
48039: LIST
48040: LIST
48041: LIST
48042: PUSH
48043: LD_VAR 0 1
48047: PUSH
48048: LD_VAR 0 2
48052: PUSH
48053: LD_INT 4
48055: PLUS
48056: PUSH
48057: LD_INT 0
48059: PUSH
48060: EMPTY
48061: LIST
48062: LIST
48063: LIST
48064: PUSH
48065: EMPTY
48066: LIST
48067: LIST
48068: LIST
48069: LIST
48070: LIST
48071: ST_TO_ADDR
// end ; 1 :
48072: GO 48772
48074: LD_INT 1
48076: DOUBLE
48077: EQUAL
48078: IFTRUE 48082
48080: GO 48215
48082: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48083: LD_ADDR_VAR 0 5
48087: PUSH
48088: LD_VAR 0 1
48092: PUSH
48093: LD_VAR 0 2
48097: PUSH
48098: LD_INT 4
48100: MINUS
48101: PUSH
48102: LD_INT 3
48104: PUSH
48105: EMPTY
48106: LIST
48107: LIST
48108: LIST
48109: PUSH
48110: LD_VAR 0 1
48114: PUSH
48115: LD_INT 3
48117: MINUS
48118: PUSH
48119: LD_VAR 0 2
48123: PUSH
48124: LD_INT 3
48126: MINUS
48127: PUSH
48128: LD_INT 2
48130: PUSH
48131: EMPTY
48132: LIST
48133: LIST
48134: LIST
48135: PUSH
48136: LD_VAR 0 1
48140: PUSH
48141: LD_INT 4
48143: MINUS
48144: PUSH
48145: LD_VAR 0 2
48149: PUSH
48150: LD_INT 1
48152: PUSH
48153: EMPTY
48154: LIST
48155: LIST
48156: LIST
48157: PUSH
48158: LD_VAR 0 1
48162: PUSH
48163: LD_VAR 0 2
48167: PUSH
48168: LD_INT 3
48170: PLUS
48171: PUSH
48172: LD_INT 0
48174: PUSH
48175: EMPTY
48176: LIST
48177: LIST
48178: LIST
48179: PUSH
48180: LD_VAR 0 1
48184: PUSH
48185: LD_INT 4
48187: PLUS
48188: PUSH
48189: LD_VAR 0 2
48193: PUSH
48194: LD_INT 4
48196: PLUS
48197: PUSH
48198: LD_INT 5
48200: PUSH
48201: EMPTY
48202: LIST
48203: LIST
48204: LIST
48205: PUSH
48206: EMPTY
48207: LIST
48208: LIST
48209: LIST
48210: LIST
48211: LIST
48212: ST_TO_ADDR
// end ; 2 :
48213: GO 48772
48215: LD_INT 2
48217: DOUBLE
48218: EQUAL
48219: IFTRUE 48223
48221: GO 48352
48223: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48224: LD_ADDR_VAR 0 5
48228: PUSH
48229: LD_VAR 0 1
48233: PUSH
48234: LD_VAR 0 2
48238: PUSH
48239: LD_INT 3
48241: MINUS
48242: PUSH
48243: LD_INT 3
48245: PUSH
48246: EMPTY
48247: LIST
48248: LIST
48249: LIST
48250: PUSH
48251: LD_VAR 0 1
48255: PUSH
48256: LD_INT 4
48258: PLUS
48259: PUSH
48260: LD_VAR 0 2
48264: PUSH
48265: LD_INT 4
48267: PUSH
48268: EMPTY
48269: LIST
48270: LIST
48271: LIST
48272: PUSH
48273: LD_VAR 0 1
48277: PUSH
48278: LD_VAR 0 2
48282: PUSH
48283: LD_INT 4
48285: PLUS
48286: PUSH
48287: LD_INT 0
48289: PUSH
48290: EMPTY
48291: LIST
48292: LIST
48293: LIST
48294: PUSH
48295: LD_VAR 0 1
48299: PUSH
48300: LD_INT 3
48302: MINUS
48303: PUSH
48304: LD_VAR 0 2
48308: PUSH
48309: LD_INT 1
48311: PUSH
48312: EMPTY
48313: LIST
48314: LIST
48315: LIST
48316: PUSH
48317: LD_VAR 0 1
48321: PUSH
48322: LD_INT 4
48324: MINUS
48325: PUSH
48326: LD_VAR 0 2
48330: PUSH
48331: LD_INT 4
48333: MINUS
48334: PUSH
48335: LD_INT 2
48337: PUSH
48338: EMPTY
48339: LIST
48340: LIST
48341: LIST
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: ST_TO_ADDR
// end ; 3 :
48350: GO 48772
48352: LD_INT 3
48354: DOUBLE
48355: EQUAL
48356: IFTRUE 48360
48358: GO 48493
48360: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48361: LD_ADDR_VAR 0 5
48365: PUSH
48366: LD_VAR 0 1
48370: PUSH
48371: LD_INT 3
48373: PLUS
48374: PUSH
48375: LD_VAR 0 2
48379: PUSH
48380: LD_INT 4
48382: PUSH
48383: EMPTY
48384: LIST
48385: LIST
48386: LIST
48387: PUSH
48388: LD_VAR 0 1
48392: PUSH
48393: LD_INT 4
48395: PLUS
48396: PUSH
48397: LD_VAR 0 2
48401: PUSH
48402: LD_INT 4
48404: PLUS
48405: PUSH
48406: LD_INT 5
48408: PUSH
48409: EMPTY
48410: LIST
48411: LIST
48412: LIST
48413: PUSH
48414: LD_VAR 0 1
48418: PUSH
48419: LD_INT 4
48421: MINUS
48422: PUSH
48423: LD_VAR 0 2
48427: PUSH
48428: LD_INT 1
48430: PUSH
48431: EMPTY
48432: LIST
48433: LIST
48434: LIST
48435: PUSH
48436: LD_VAR 0 1
48440: PUSH
48441: LD_VAR 0 2
48445: PUSH
48446: LD_INT 4
48448: MINUS
48449: PUSH
48450: LD_INT 3
48452: PUSH
48453: EMPTY
48454: LIST
48455: LIST
48456: LIST
48457: PUSH
48458: LD_VAR 0 1
48462: PUSH
48463: LD_INT 3
48465: MINUS
48466: PUSH
48467: LD_VAR 0 2
48471: PUSH
48472: LD_INT 3
48474: MINUS
48475: PUSH
48476: LD_INT 2
48478: PUSH
48479: EMPTY
48480: LIST
48481: LIST
48482: LIST
48483: PUSH
48484: EMPTY
48485: LIST
48486: LIST
48487: LIST
48488: LIST
48489: LIST
48490: ST_TO_ADDR
// end ; 4 :
48491: GO 48772
48493: LD_INT 4
48495: DOUBLE
48496: EQUAL
48497: IFTRUE 48501
48499: GO 48634
48501: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48502: LD_ADDR_VAR 0 5
48506: PUSH
48507: LD_VAR 0 1
48511: PUSH
48512: LD_VAR 0 2
48516: PUSH
48517: LD_INT 4
48519: PLUS
48520: PUSH
48521: LD_INT 0
48523: PUSH
48524: EMPTY
48525: LIST
48526: LIST
48527: LIST
48528: PUSH
48529: LD_VAR 0 1
48533: PUSH
48534: LD_INT 3
48536: PLUS
48537: PUSH
48538: LD_VAR 0 2
48542: PUSH
48543: LD_INT 3
48545: PLUS
48546: PUSH
48547: LD_INT 5
48549: PUSH
48550: EMPTY
48551: LIST
48552: LIST
48553: LIST
48554: PUSH
48555: LD_VAR 0 1
48559: PUSH
48560: LD_INT 4
48562: PLUS
48563: PUSH
48564: LD_VAR 0 2
48568: PUSH
48569: LD_INT 4
48571: PUSH
48572: EMPTY
48573: LIST
48574: LIST
48575: LIST
48576: PUSH
48577: LD_VAR 0 1
48581: PUSH
48582: LD_VAR 0 2
48586: PUSH
48587: LD_INT 3
48589: MINUS
48590: PUSH
48591: LD_INT 3
48593: PUSH
48594: EMPTY
48595: LIST
48596: LIST
48597: LIST
48598: PUSH
48599: LD_VAR 0 1
48603: PUSH
48604: LD_INT 4
48606: MINUS
48607: PUSH
48608: LD_VAR 0 2
48612: PUSH
48613: LD_INT 4
48615: MINUS
48616: PUSH
48617: LD_INT 2
48619: PUSH
48620: EMPTY
48621: LIST
48622: LIST
48623: LIST
48624: PUSH
48625: EMPTY
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: ST_TO_ADDR
// end ; 5 :
48632: GO 48772
48634: LD_INT 5
48636: DOUBLE
48637: EQUAL
48638: IFTRUE 48642
48640: GO 48771
48642: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48643: LD_ADDR_VAR 0 5
48647: PUSH
48648: LD_VAR 0 1
48652: PUSH
48653: LD_INT 4
48655: MINUS
48656: PUSH
48657: LD_VAR 0 2
48661: PUSH
48662: LD_INT 1
48664: PUSH
48665: EMPTY
48666: LIST
48667: LIST
48668: LIST
48669: PUSH
48670: LD_VAR 0 1
48674: PUSH
48675: LD_VAR 0 2
48679: PUSH
48680: LD_INT 4
48682: MINUS
48683: PUSH
48684: LD_INT 3
48686: PUSH
48687: EMPTY
48688: LIST
48689: LIST
48690: LIST
48691: PUSH
48692: LD_VAR 0 1
48696: PUSH
48697: LD_INT 4
48699: PLUS
48700: PUSH
48701: LD_VAR 0 2
48705: PUSH
48706: LD_INT 4
48708: PLUS
48709: PUSH
48710: LD_INT 5
48712: PUSH
48713: EMPTY
48714: LIST
48715: LIST
48716: LIST
48717: PUSH
48718: LD_VAR 0 1
48722: PUSH
48723: LD_INT 3
48725: PLUS
48726: PUSH
48727: LD_VAR 0 2
48731: PUSH
48732: LD_INT 4
48734: PUSH
48735: EMPTY
48736: LIST
48737: LIST
48738: LIST
48739: PUSH
48740: LD_VAR 0 1
48744: PUSH
48745: LD_VAR 0 2
48749: PUSH
48750: LD_INT 3
48752: PLUS
48753: PUSH
48754: LD_INT 0
48756: PUSH
48757: EMPTY
48758: LIST
48759: LIST
48760: LIST
48761: PUSH
48762: EMPTY
48763: LIST
48764: LIST
48765: LIST
48766: LIST
48767: LIST
48768: ST_TO_ADDR
// end ; end ;
48769: GO 48772
48771: POP
// result := list ;
48772: LD_ADDR_VAR 0 4
48776: PUSH
48777: LD_VAR 0 5
48781: ST_TO_ADDR
// end ;
48782: LD_VAR 0 4
48786: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48787: LD_INT 0
48789: PPUSH
48790: PPUSH
48791: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48792: LD_VAR 0 1
48796: NOT
48797: PUSH
48798: LD_VAR 0 2
48802: PUSH
48803: LD_INT 1
48805: PUSH
48806: LD_INT 2
48808: PUSH
48809: LD_INT 3
48811: PUSH
48812: LD_INT 4
48814: PUSH
48815: EMPTY
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: IN
48821: NOT
48822: OR
48823: IFFALSE 48827
// exit ;
48825: GO 48919
// tmp := [ ] ;
48827: LD_ADDR_VAR 0 5
48831: PUSH
48832: EMPTY
48833: ST_TO_ADDR
// for i in units do
48834: LD_ADDR_VAR 0 4
48838: PUSH
48839: LD_VAR 0 1
48843: PUSH
48844: FOR_IN
48845: IFFALSE 48888
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48847: LD_ADDR_VAR 0 5
48851: PUSH
48852: LD_VAR 0 5
48856: PPUSH
48857: LD_VAR 0 5
48861: PUSH
48862: LD_INT 1
48864: PLUS
48865: PPUSH
48866: LD_VAR 0 4
48870: PPUSH
48871: LD_VAR 0 2
48875: PPUSH
48876: CALL_OW 259
48880: PPUSH
48881: CALL_OW 2
48885: ST_TO_ADDR
48886: GO 48844
48888: POP
48889: POP
// if not tmp then
48890: LD_VAR 0 5
48894: NOT
48895: IFFALSE 48899
// exit ;
48897: GO 48919
// result := SortListByListDesc ( units , tmp ) ;
48899: LD_ADDR_VAR 0 3
48903: PUSH
48904: LD_VAR 0 1
48908: PPUSH
48909: LD_VAR 0 5
48913: PPUSH
48914: CALL_OW 77
48918: ST_TO_ADDR
// end ;
48919: LD_VAR 0 3
48923: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48924: LD_INT 0
48926: PPUSH
48927: PPUSH
48928: PPUSH
// x := GetX ( building ) ;
48929: LD_ADDR_VAR 0 4
48933: PUSH
48934: LD_VAR 0 2
48938: PPUSH
48939: CALL_OW 250
48943: ST_TO_ADDR
// y := GetY ( building ) ;
48944: LD_ADDR_VAR 0 5
48948: PUSH
48949: LD_VAR 0 2
48953: PPUSH
48954: CALL_OW 251
48958: ST_TO_ADDR
// if GetTaskList ( unit ) then
48959: LD_VAR 0 1
48963: PPUSH
48964: CALL_OW 437
48968: IFFALSE 49063
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
48970: LD_STRING e
48972: PUSH
48973: LD_VAR 0 1
48977: PPUSH
48978: CALL_OW 437
48982: PUSH
48983: LD_INT 1
48985: ARRAY
48986: PUSH
48987: LD_INT 1
48989: ARRAY
48990: EQUAL
48991: PUSH
48992: LD_VAR 0 4
48996: PUSH
48997: LD_VAR 0 1
49001: PPUSH
49002: CALL_OW 437
49006: PUSH
49007: LD_INT 1
49009: ARRAY
49010: PUSH
49011: LD_INT 2
49013: ARRAY
49014: EQUAL
49015: AND
49016: PUSH
49017: LD_VAR 0 5
49021: PUSH
49022: LD_VAR 0 1
49026: PPUSH
49027: CALL_OW 437
49031: PUSH
49032: LD_INT 1
49034: ARRAY
49035: PUSH
49036: LD_INT 3
49038: ARRAY
49039: EQUAL
49040: AND
49041: IFFALSE 49053
// result := true else
49043: LD_ADDR_VAR 0 3
49047: PUSH
49048: LD_INT 1
49050: ST_TO_ADDR
49051: GO 49061
// result := false ;
49053: LD_ADDR_VAR 0 3
49057: PUSH
49058: LD_INT 0
49060: ST_TO_ADDR
// end else
49061: GO 49071
// result := false ;
49063: LD_ADDR_VAR 0 3
49067: PUSH
49068: LD_INT 0
49070: ST_TO_ADDR
// end ;
49071: LD_VAR 0 3
49075: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49076: LD_INT 0
49078: PPUSH
49079: PPUSH
49080: PPUSH
49081: PPUSH
// if not unit or not area then
49082: LD_VAR 0 1
49086: NOT
49087: PUSH
49088: LD_VAR 0 2
49092: NOT
49093: OR
49094: IFFALSE 49098
// exit ;
49096: GO 49262
// tmp := AreaToList ( area , i ) ;
49098: LD_ADDR_VAR 0 6
49102: PUSH
49103: LD_VAR 0 2
49107: PPUSH
49108: LD_VAR 0 5
49112: PPUSH
49113: CALL_OW 517
49117: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49118: LD_ADDR_VAR 0 5
49122: PUSH
49123: DOUBLE
49124: LD_INT 1
49126: DEC
49127: ST_TO_ADDR
49128: LD_VAR 0 6
49132: PUSH
49133: LD_INT 1
49135: ARRAY
49136: PUSH
49137: FOR_TO
49138: IFFALSE 49260
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49140: LD_ADDR_VAR 0 7
49144: PUSH
49145: LD_VAR 0 6
49149: PUSH
49150: LD_INT 1
49152: ARRAY
49153: PUSH
49154: LD_VAR 0 5
49158: ARRAY
49159: PUSH
49160: LD_VAR 0 6
49164: PUSH
49165: LD_INT 2
49167: ARRAY
49168: PUSH
49169: LD_VAR 0 5
49173: ARRAY
49174: PUSH
49175: EMPTY
49176: LIST
49177: LIST
49178: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49179: LD_VAR 0 7
49183: PUSH
49184: LD_INT 1
49186: ARRAY
49187: PPUSH
49188: LD_VAR 0 7
49192: PUSH
49193: LD_INT 2
49195: ARRAY
49196: PPUSH
49197: CALL_OW 428
49201: PUSH
49202: LD_INT 0
49204: EQUAL
49205: IFFALSE 49258
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49207: LD_VAR 0 1
49211: PPUSH
49212: LD_VAR 0 7
49216: PUSH
49217: LD_INT 1
49219: ARRAY
49220: PPUSH
49221: LD_VAR 0 7
49225: PUSH
49226: LD_INT 2
49228: ARRAY
49229: PPUSH
49230: LD_VAR 0 3
49234: PPUSH
49235: CALL_OW 48
// result := IsPlaced ( unit ) ;
49239: LD_ADDR_VAR 0 4
49243: PUSH
49244: LD_VAR 0 1
49248: PPUSH
49249: CALL_OW 305
49253: ST_TO_ADDR
// exit ;
49254: POP
49255: POP
49256: GO 49262
// end ; end ;
49258: GO 49137
49260: POP
49261: POP
// end ;
49262: LD_VAR 0 4
49266: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49267: LD_INT 0
49269: PPUSH
49270: PPUSH
49271: PPUSH
// if not side or side > 8 then
49272: LD_VAR 0 1
49276: NOT
49277: PUSH
49278: LD_VAR 0 1
49282: PUSH
49283: LD_INT 8
49285: GREATER
49286: OR
49287: IFFALSE 49291
// exit ;
49289: GO 49478
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49291: LD_ADDR_VAR 0 4
49295: PUSH
49296: LD_INT 22
49298: PUSH
49299: LD_VAR 0 1
49303: PUSH
49304: EMPTY
49305: LIST
49306: LIST
49307: PUSH
49308: LD_INT 21
49310: PUSH
49311: LD_INT 3
49313: PUSH
49314: EMPTY
49315: LIST
49316: LIST
49317: PUSH
49318: EMPTY
49319: LIST
49320: LIST
49321: PPUSH
49322: CALL_OW 69
49326: ST_TO_ADDR
// if not tmp then
49327: LD_VAR 0 4
49331: NOT
49332: IFFALSE 49336
// exit ;
49334: GO 49478
// enable_addtolog := true ;
49336: LD_ADDR_OWVAR 81
49340: PUSH
49341: LD_INT 1
49343: ST_TO_ADDR
// AddToLog ( [ ) ;
49344: LD_STRING [
49346: PPUSH
49347: CALL_OW 561
// for i in tmp do
49351: LD_ADDR_VAR 0 3
49355: PUSH
49356: LD_VAR 0 4
49360: PUSH
49361: FOR_IN
49362: IFFALSE 49469
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49364: LD_STRING [
49366: PUSH
49367: LD_VAR 0 3
49371: PPUSH
49372: CALL_OW 266
49376: STR
49377: PUSH
49378: LD_STRING , 
49380: STR
49381: PUSH
49382: LD_VAR 0 3
49386: PPUSH
49387: CALL_OW 250
49391: STR
49392: PUSH
49393: LD_STRING , 
49395: STR
49396: PUSH
49397: LD_VAR 0 3
49401: PPUSH
49402: CALL_OW 251
49406: STR
49407: PUSH
49408: LD_STRING , 
49410: STR
49411: PUSH
49412: LD_VAR 0 3
49416: PPUSH
49417: CALL_OW 254
49421: STR
49422: PUSH
49423: LD_STRING , 
49425: STR
49426: PUSH
49427: LD_VAR 0 3
49431: PPUSH
49432: LD_INT 1
49434: PPUSH
49435: CALL_OW 268
49439: STR
49440: PUSH
49441: LD_STRING , 
49443: STR
49444: PUSH
49445: LD_VAR 0 3
49449: PPUSH
49450: LD_INT 2
49452: PPUSH
49453: CALL_OW 268
49457: STR
49458: PUSH
49459: LD_STRING ],
49461: STR
49462: PPUSH
49463: CALL_OW 561
// end ;
49467: GO 49361
49469: POP
49470: POP
// AddToLog ( ]; ) ;
49471: LD_STRING ];
49473: PPUSH
49474: CALL_OW 561
// end ;
49478: LD_VAR 0 2
49482: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49483: LD_INT 0
49485: PPUSH
49486: PPUSH
49487: PPUSH
49488: PPUSH
49489: PPUSH
// if not area or not rate or not max then
49490: LD_VAR 0 1
49494: NOT
49495: PUSH
49496: LD_VAR 0 2
49500: NOT
49501: OR
49502: PUSH
49503: LD_VAR 0 4
49507: NOT
49508: OR
49509: IFFALSE 49513
// exit ;
49511: GO 49705
// while 1 do
49513: LD_INT 1
49515: IFFALSE 49705
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49517: LD_ADDR_VAR 0 9
49521: PUSH
49522: LD_VAR 0 1
49526: PPUSH
49527: LD_INT 1
49529: PPUSH
49530: CALL_OW 287
49534: PUSH
49535: LD_INT 10
49537: MUL
49538: ST_TO_ADDR
// r := rate / 10 ;
49539: LD_ADDR_VAR 0 7
49543: PUSH
49544: LD_VAR 0 2
49548: PUSH
49549: LD_INT 10
49551: DIVREAL
49552: ST_TO_ADDR
// time := 1 1$00 ;
49553: LD_ADDR_VAR 0 8
49557: PUSH
49558: LD_INT 2100
49560: ST_TO_ADDR
// if amount < min then
49561: LD_VAR 0 9
49565: PUSH
49566: LD_VAR 0 3
49570: LESS
49571: IFFALSE 49589
// r := r * 2 else
49573: LD_ADDR_VAR 0 7
49577: PUSH
49578: LD_VAR 0 7
49582: PUSH
49583: LD_INT 2
49585: MUL
49586: ST_TO_ADDR
49587: GO 49615
// if amount > max then
49589: LD_VAR 0 9
49593: PUSH
49594: LD_VAR 0 4
49598: GREATER
49599: IFFALSE 49615
// r := r / 2 ;
49601: LD_ADDR_VAR 0 7
49605: PUSH
49606: LD_VAR 0 7
49610: PUSH
49611: LD_INT 2
49613: DIVREAL
49614: ST_TO_ADDR
// time := time / r ;
49615: LD_ADDR_VAR 0 8
49619: PUSH
49620: LD_VAR 0 8
49624: PUSH
49625: LD_VAR 0 7
49629: DIVREAL
49630: ST_TO_ADDR
// if time < 0 then
49631: LD_VAR 0 8
49635: PUSH
49636: LD_INT 0
49638: LESS
49639: IFFALSE 49656
// time := time * - 1 ;
49641: LD_ADDR_VAR 0 8
49645: PUSH
49646: LD_VAR 0 8
49650: PUSH
49651: LD_INT 1
49653: NEG
49654: MUL
49655: ST_TO_ADDR
// wait ( time ) ;
49656: LD_VAR 0 8
49660: PPUSH
49661: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49665: LD_INT 35
49667: PPUSH
49668: LD_INT 875
49670: PPUSH
49671: CALL_OW 12
49675: PPUSH
49676: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49680: LD_INT 1
49682: PPUSH
49683: LD_INT 5
49685: PPUSH
49686: CALL_OW 12
49690: PPUSH
49691: LD_VAR 0 1
49695: PPUSH
49696: LD_INT 1
49698: PPUSH
49699: CALL_OW 55
// end ;
49703: GO 49513
// end ;
49705: LD_VAR 0 5
49709: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49710: LD_INT 0
49712: PPUSH
49713: PPUSH
49714: PPUSH
49715: PPUSH
49716: PPUSH
49717: PPUSH
49718: PPUSH
49719: PPUSH
// if not turrets or not factories then
49720: LD_VAR 0 1
49724: NOT
49725: PUSH
49726: LD_VAR 0 2
49730: NOT
49731: OR
49732: IFFALSE 49736
// exit ;
49734: GO 50043
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49736: LD_ADDR_VAR 0 10
49740: PUSH
49741: LD_INT 5
49743: PUSH
49744: LD_INT 6
49746: PUSH
49747: EMPTY
49748: LIST
49749: LIST
49750: PUSH
49751: LD_INT 2
49753: PUSH
49754: LD_INT 4
49756: PUSH
49757: EMPTY
49758: LIST
49759: LIST
49760: PUSH
49761: LD_INT 3
49763: PUSH
49764: LD_INT 5
49766: PUSH
49767: EMPTY
49768: LIST
49769: LIST
49770: PUSH
49771: EMPTY
49772: LIST
49773: LIST
49774: LIST
49775: PUSH
49776: LD_INT 24
49778: PUSH
49779: LD_INT 25
49781: PUSH
49782: EMPTY
49783: LIST
49784: LIST
49785: PUSH
49786: LD_INT 23
49788: PUSH
49789: LD_INT 27
49791: PUSH
49792: EMPTY
49793: LIST
49794: LIST
49795: PUSH
49796: EMPTY
49797: LIST
49798: LIST
49799: PUSH
49800: LD_INT 42
49802: PUSH
49803: LD_INT 43
49805: PUSH
49806: EMPTY
49807: LIST
49808: LIST
49809: PUSH
49810: LD_INT 44
49812: PUSH
49813: LD_INT 46
49815: PUSH
49816: EMPTY
49817: LIST
49818: LIST
49819: PUSH
49820: LD_INT 45
49822: PUSH
49823: LD_INT 47
49825: PUSH
49826: EMPTY
49827: LIST
49828: LIST
49829: PUSH
49830: EMPTY
49831: LIST
49832: LIST
49833: LIST
49834: PUSH
49835: EMPTY
49836: LIST
49837: LIST
49838: LIST
49839: ST_TO_ADDR
// result := [ ] ;
49840: LD_ADDR_VAR 0 3
49844: PUSH
49845: EMPTY
49846: ST_TO_ADDR
// for i in turrets do
49847: LD_ADDR_VAR 0 4
49851: PUSH
49852: LD_VAR 0 1
49856: PUSH
49857: FOR_IN
49858: IFFALSE 50041
// begin nat := GetNation ( i ) ;
49860: LD_ADDR_VAR 0 7
49864: PUSH
49865: LD_VAR 0 4
49869: PPUSH
49870: CALL_OW 248
49874: ST_TO_ADDR
// weapon := 0 ;
49875: LD_ADDR_VAR 0 8
49879: PUSH
49880: LD_INT 0
49882: ST_TO_ADDR
// if not nat then
49883: LD_VAR 0 7
49887: NOT
49888: IFFALSE 49892
// continue ;
49890: GO 49857
// for j in list [ nat ] do
49892: LD_ADDR_VAR 0 5
49896: PUSH
49897: LD_VAR 0 10
49901: PUSH
49902: LD_VAR 0 7
49906: ARRAY
49907: PUSH
49908: FOR_IN
49909: IFFALSE 49950
// if GetBWeapon ( i ) = j [ 1 ] then
49911: LD_VAR 0 4
49915: PPUSH
49916: CALL_OW 269
49920: PUSH
49921: LD_VAR 0 5
49925: PUSH
49926: LD_INT 1
49928: ARRAY
49929: EQUAL
49930: IFFALSE 49948
// begin weapon := j [ 2 ] ;
49932: LD_ADDR_VAR 0 8
49936: PUSH
49937: LD_VAR 0 5
49941: PUSH
49942: LD_INT 2
49944: ARRAY
49945: ST_TO_ADDR
// break ;
49946: GO 49950
// end ;
49948: GO 49908
49950: POP
49951: POP
// if not weapon then
49952: LD_VAR 0 8
49956: NOT
49957: IFFALSE 49961
// continue ;
49959: GO 49857
// for k in factories do
49961: LD_ADDR_VAR 0 6
49965: PUSH
49966: LD_VAR 0 2
49970: PUSH
49971: FOR_IN
49972: IFFALSE 50037
// begin weapons := AvailableWeaponList ( k ) ;
49974: LD_ADDR_VAR 0 9
49978: PUSH
49979: LD_VAR 0 6
49983: PPUSH
49984: CALL_OW 478
49988: ST_TO_ADDR
// if not weapons then
49989: LD_VAR 0 9
49993: NOT
49994: IFFALSE 49998
// continue ;
49996: GO 49971
// if weapon in weapons then
49998: LD_VAR 0 8
50002: PUSH
50003: LD_VAR 0 9
50007: IN
50008: IFFALSE 50035
// begin result := [ i , weapon ] ;
50010: LD_ADDR_VAR 0 3
50014: PUSH
50015: LD_VAR 0 4
50019: PUSH
50020: LD_VAR 0 8
50024: PUSH
50025: EMPTY
50026: LIST
50027: LIST
50028: ST_TO_ADDR
// exit ;
50029: POP
50030: POP
50031: POP
50032: POP
50033: GO 50043
// end ; end ;
50035: GO 49971
50037: POP
50038: POP
// end ;
50039: GO 49857
50041: POP
50042: POP
// end ;
50043: LD_VAR 0 3
50047: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50048: LD_INT 0
50050: PPUSH
// if not side or side > 8 then
50051: LD_VAR 0 3
50055: NOT
50056: PUSH
50057: LD_VAR 0 3
50061: PUSH
50062: LD_INT 8
50064: GREATER
50065: OR
50066: IFFALSE 50070
// exit ;
50068: GO 50129
// if not range then
50070: LD_VAR 0 4
50074: NOT
50075: IFFALSE 50086
// range := - 12 ;
50077: LD_ADDR_VAR 0 4
50081: PUSH
50082: LD_INT 12
50084: NEG
50085: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50086: LD_VAR 0 1
50090: PPUSH
50091: LD_VAR 0 2
50095: PPUSH
50096: LD_VAR 0 3
50100: PPUSH
50101: LD_VAR 0 4
50105: PPUSH
50106: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50110: LD_VAR 0 1
50114: PPUSH
50115: LD_VAR 0 2
50119: PPUSH
50120: LD_VAR 0 3
50124: PPUSH
50125: CALL_OW 331
// end ;
50129: LD_VAR 0 5
50133: RET
// export function Video ( mode ) ; begin
50134: LD_INT 0
50136: PPUSH
// ingame_video = mode ;
50137: LD_ADDR_OWVAR 52
50141: PUSH
50142: LD_VAR 0 1
50146: ST_TO_ADDR
// interface_hidden = mode ;
50147: LD_ADDR_OWVAR 54
50151: PUSH
50152: LD_VAR 0 1
50156: ST_TO_ADDR
// end ;
50157: LD_VAR 0 2
50161: RET
// export function Join ( array , element ) ; begin
50162: LD_INT 0
50164: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50165: LD_ADDR_VAR 0 3
50169: PUSH
50170: LD_VAR 0 1
50174: PPUSH
50175: LD_VAR 0 1
50179: PUSH
50180: LD_INT 1
50182: PLUS
50183: PPUSH
50184: LD_VAR 0 2
50188: PPUSH
50189: CALL_OW 1
50193: ST_TO_ADDR
// end ;
50194: LD_VAR 0 3
50198: RET
// export function JoinUnion ( array , element ) ; begin
50199: LD_INT 0
50201: PPUSH
// result := array union element ;
50202: LD_ADDR_VAR 0 3
50206: PUSH
50207: LD_VAR 0 1
50211: PUSH
50212: LD_VAR 0 2
50216: UNION
50217: ST_TO_ADDR
// end ;
50218: LD_VAR 0 3
50222: RET
// export function GetBehemoths ( side ) ; begin
50223: LD_INT 0
50225: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50226: LD_ADDR_VAR 0 2
50230: PUSH
50231: LD_INT 22
50233: PUSH
50234: LD_VAR 0 1
50238: PUSH
50239: EMPTY
50240: LIST
50241: LIST
50242: PUSH
50243: LD_INT 31
50245: PUSH
50246: LD_INT 25
50248: PUSH
50249: EMPTY
50250: LIST
50251: LIST
50252: PUSH
50253: EMPTY
50254: LIST
50255: LIST
50256: PPUSH
50257: CALL_OW 69
50261: ST_TO_ADDR
// end ;
50262: LD_VAR 0 2
50266: RET
// export function Shuffle ( array ) ; var i , index ; begin
50267: LD_INT 0
50269: PPUSH
50270: PPUSH
50271: PPUSH
// result := [ ] ;
50272: LD_ADDR_VAR 0 2
50276: PUSH
50277: EMPTY
50278: ST_TO_ADDR
// if not array then
50279: LD_VAR 0 1
50283: NOT
50284: IFFALSE 50288
// exit ;
50286: GO 50387
// Randomize ;
50288: CALL_OW 10
// for i = array downto 1 do
50292: LD_ADDR_VAR 0 3
50296: PUSH
50297: DOUBLE
50298: LD_VAR 0 1
50302: INC
50303: ST_TO_ADDR
50304: LD_INT 1
50306: PUSH
50307: FOR_DOWNTO
50308: IFFALSE 50385
// begin index := rand ( 1 , array ) ;
50310: LD_ADDR_VAR 0 4
50314: PUSH
50315: LD_INT 1
50317: PPUSH
50318: LD_VAR 0 1
50322: PPUSH
50323: CALL_OW 12
50327: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50328: LD_ADDR_VAR 0 2
50332: PUSH
50333: LD_VAR 0 2
50337: PPUSH
50338: LD_VAR 0 2
50342: PUSH
50343: LD_INT 1
50345: PLUS
50346: PPUSH
50347: LD_VAR 0 1
50351: PUSH
50352: LD_VAR 0 4
50356: ARRAY
50357: PPUSH
50358: CALL_OW 2
50362: ST_TO_ADDR
// array := Delete ( array , index ) ;
50363: LD_ADDR_VAR 0 1
50367: PUSH
50368: LD_VAR 0 1
50372: PPUSH
50373: LD_VAR 0 4
50377: PPUSH
50378: CALL_OW 3
50382: ST_TO_ADDR
// end ;
50383: GO 50307
50385: POP
50386: POP
// end ;
50387: LD_VAR 0 2
50391: RET
// export function GetBaseMaterials ( base ) ; begin
50392: LD_INT 0
50394: PPUSH
// result := [ 0 , 0 , 0 ] ;
50395: LD_ADDR_VAR 0 2
50399: PUSH
50400: LD_INT 0
50402: PUSH
50403: LD_INT 0
50405: PUSH
50406: LD_INT 0
50408: PUSH
50409: EMPTY
50410: LIST
50411: LIST
50412: LIST
50413: ST_TO_ADDR
// if not base then
50414: LD_VAR 0 1
50418: NOT
50419: IFFALSE 50423
// exit ;
50421: GO 50472
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50423: LD_ADDR_VAR 0 2
50427: PUSH
50428: LD_VAR 0 1
50432: PPUSH
50433: LD_INT 1
50435: PPUSH
50436: CALL_OW 275
50440: PUSH
50441: LD_VAR 0 1
50445: PPUSH
50446: LD_INT 2
50448: PPUSH
50449: CALL_OW 275
50453: PUSH
50454: LD_VAR 0 1
50458: PPUSH
50459: LD_INT 3
50461: PPUSH
50462: CALL_OW 275
50466: PUSH
50467: EMPTY
50468: LIST
50469: LIST
50470: LIST
50471: ST_TO_ADDR
// end ;
50472: LD_VAR 0 2
50476: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50477: LD_INT 0
50479: PPUSH
50480: PPUSH
// result := array ;
50481: LD_ADDR_VAR 0 3
50485: PUSH
50486: LD_VAR 0 1
50490: ST_TO_ADDR
// if size > 0 then
50491: LD_VAR 0 2
50495: PUSH
50496: LD_INT 0
50498: GREATER
50499: IFFALSE 50545
// for i := array downto size do
50501: LD_ADDR_VAR 0 4
50505: PUSH
50506: DOUBLE
50507: LD_VAR 0 1
50511: INC
50512: ST_TO_ADDR
50513: LD_VAR 0 2
50517: PUSH
50518: FOR_DOWNTO
50519: IFFALSE 50543
// result := Delete ( result , result ) ;
50521: LD_ADDR_VAR 0 3
50525: PUSH
50526: LD_VAR 0 3
50530: PPUSH
50531: LD_VAR 0 3
50535: PPUSH
50536: CALL_OW 3
50540: ST_TO_ADDR
50541: GO 50518
50543: POP
50544: POP
// end ;
50545: LD_VAR 0 3
50549: RET
// export function ComExit ( unit ) ; var tmp ; begin
50550: LD_INT 0
50552: PPUSH
50553: PPUSH
// if not IsInUnit ( unit ) then
50554: LD_VAR 0 1
50558: PPUSH
50559: CALL_OW 310
50563: NOT
50564: IFFALSE 50568
// exit ;
50566: GO 50628
// tmp := IsInUnit ( unit ) ;
50568: LD_ADDR_VAR 0 3
50572: PUSH
50573: LD_VAR 0 1
50577: PPUSH
50578: CALL_OW 310
50582: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50583: LD_VAR 0 3
50587: PPUSH
50588: CALL_OW 247
50592: PUSH
50593: LD_INT 2
50595: EQUAL
50596: IFFALSE 50609
// ComExitVehicle ( unit ) else
50598: LD_VAR 0 1
50602: PPUSH
50603: CALL_OW 121
50607: GO 50618
// ComExitBuilding ( unit ) ;
50609: LD_VAR 0 1
50613: PPUSH
50614: CALL_OW 122
// result := tmp ;
50618: LD_ADDR_VAR 0 2
50622: PUSH
50623: LD_VAR 0 3
50627: ST_TO_ADDR
// end ;
50628: LD_VAR 0 2
50632: RET
// export function ResetHc ; begin
50633: LD_INT 0
50635: PPUSH
// InitHc ;
50636: CALL_OW 19
// hc_importance := 0 ;
50640: LD_ADDR_OWVAR 32
50644: PUSH
50645: LD_INT 0
50647: ST_TO_ADDR
// end ; end_of_file
50648: LD_VAR 0 1
50652: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
50653: LD_INT 0
50655: PPUSH
50656: PPUSH
// skirmish := false ;
50657: LD_ADDR_EXP 57
50661: PUSH
50662: LD_INT 0
50664: ST_TO_ADDR
// debug_mc := false ;
50665: LD_ADDR_EXP 58
50669: PUSH
50670: LD_INT 0
50672: ST_TO_ADDR
// mc_bases := [ ] ;
50673: LD_ADDR_EXP 59
50677: PUSH
50678: EMPTY
50679: ST_TO_ADDR
// mc_sides := [ ] ;
50680: LD_ADDR_EXP 85
50684: PUSH
50685: EMPTY
50686: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
50687: LD_ADDR_EXP 60
50691: PUSH
50692: EMPTY
50693: ST_TO_ADDR
// mc_building_repairs := [ ] ;
50694: LD_ADDR_EXP 61
50698: PUSH
50699: EMPTY
50700: ST_TO_ADDR
// mc_need_heal := [ ] ;
50701: LD_ADDR_EXP 62
50705: PUSH
50706: EMPTY
50707: ST_TO_ADDR
// mc_healers := [ ] ;
50708: LD_ADDR_EXP 63
50712: PUSH
50713: EMPTY
50714: ST_TO_ADDR
// mc_build_list := [ ] ;
50715: LD_ADDR_EXP 64
50719: PUSH
50720: EMPTY
50721: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
50722: LD_ADDR_EXP 91
50726: PUSH
50727: EMPTY
50728: ST_TO_ADDR
// mc_builders := [ ] ;
50729: LD_ADDR_EXP 65
50733: PUSH
50734: EMPTY
50735: ST_TO_ADDR
// mc_construct_list := [ ] ;
50736: LD_ADDR_EXP 66
50740: PUSH
50741: EMPTY
50742: ST_TO_ADDR
// mc_turret_list := [ ] ;
50743: LD_ADDR_EXP 67
50747: PUSH
50748: EMPTY
50749: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
50750: LD_ADDR_EXP 68
50754: PUSH
50755: EMPTY
50756: ST_TO_ADDR
// mc_miners := [ ] ;
50757: LD_ADDR_EXP 73
50761: PUSH
50762: EMPTY
50763: ST_TO_ADDR
// mc_mines := [ ] ;
50764: LD_ADDR_EXP 72
50768: PUSH
50769: EMPTY
50770: ST_TO_ADDR
// mc_minefields := [ ] ;
50771: LD_ADDR_EXP 74
50775: PUSH
50776: EMPTY
50777: ST_TO_ADDR
// mc_crates := [ ] ;
50778: LD_ADDR_EXP 75
50782: PUSH
50783: EMPTY
50784: ST_TO_ADDR
// mc_crates_collector := [ ] ;
50785: LD_ADDR_EXP 76
50789: PUSH
50790: EMPTY
50791: ST_TO_ADDR
// mc_crates_area := [ ] ;
50792: LD_ADDR_EXP 77
50796: PUSH
50797: EMPTY
50798: ST_TO_ADDR
// mc_vehicles := [ ] ;
50799: LD_ADDR_EXP 78
50803: PUSH
50804: EMPTY
50805: ST_TO_ADDR
// mc_attack := [ ] ;
50806: LD_ADDR_EXP 79
50810: PUSH
50811: EMPTY
50812: ST_TO_ADDR
// mc_produce := [ ] ;
50813: LD_ADDR_EXP 80
50817: PUSH
50818: EMPTY
50819: ST_TO_ADDR
// mc_defender := [ ] ;
50820: LD_ADDR_EXP 81
50824: PUSH
50825: EMPTY
50826: ST_TO_ADDR
// mc_parking := [ ] ;
50827: LD_ADDR_EXP 83
50831: PUSH
50832: EMPTY
50833: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
50834: LD_ADDR_EXP 69
50838: PUSH
50839: EMPTY
50840: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
50841: LD_ADDR_EXP 71
50845: PUSH
50846: EMPTY
50847: ST_TO_ADDR
// mc_scan := [ ] ;
50848: LD_ADDR_EXP 82
50852: PUSH
50853: EMPTY
50854: ST_TO_ADDR
// mc_scan_area := [ ] ;
50855: LD_ADDR_EXP 84
50859: PUSH
50860: EMPTY
50861: ST_TO_ADDR
// mc_tech := [ ] ;
50862: LD_ADDR_EXP 86
50866: PUSH
50867: EMPTY
50868: ST_TO_ADDR
// mc_class := [ ] ;
50869: LD_ADDR_EXP 100
50873: PUSH
50874: EMPTY
50875: ST_TO_ADDR
// mc_class_case_use := [ ] ;
50876: LD_ADDR_EXP 101
50880: PUSH
50881: EMPTY
50882: ST_TO_ADDR
// end ;
50883: LD_VAR 0 1
50887: RET
// export function MC_Kill ( base ) ; begin
50888: LD_INT 0
50890: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
50891: LD_ADDR_EXP 59
50895: PUSH
50896: LD_EXP 59
50900: PPUSH
50901: LD_VAR 0 1
50905: PPUSH
50906: EMPTY
50907: PPUSH
50908: CALL_OW 1
50912: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
50913: LD_ADDR_EXP 60
50917: PUSH
50918: LD_EXP 60
50922: PPUSH
50923: LD_VAR 0 1
50927: PPUSH
50928: EMPTY
50929: PPUSH
50930: CALL_OW 1
50934: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
50935: LD_ADDR_EXP 61
50939: PUSH
50940: LD_EXP 61
50944: PPUSH
50945: LD_VAR 0 1
50949: PPUSH
50950: EMPTY
50951: PPUSH
50952: CALL_OW 1
50956: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
50957: LD_ADDR_EXP 62
50961: PUSH
50962: LD_EXP 62
50966: PPUSH
50967: LD_VAR 0 1
50971: PPUSH
50972: EMPTY
50973: PPUSH
50974: CALL_OW 1
50978: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
50979: LD_ADDR_EXP 63
50983: PUSH
50984: LD_EXP 63
50988: PPUSH
50989: LD_VAR 0 1
50993: PPUSH
50994: EMPTY
50995: PPUSH
50996: CALL_OW 1
51000: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51001: LD_ADDR_EXP 64
51005: PUSH
51006: LD_EXP 64
51010: PPUSH
51011: LD_VAR 0 1
51015: PPUSH
51016: EMPTY
51017: PPUSH
51018: CALL_OW 1
51022: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51023: LD_ADDR_EXP 65
51027: PUSH
51028: LD_EXP 65
51032: PPUSH
51033: LD_VAR 0 1
51037: PPUSH
51038: EMPTY
51039: PPUSH
51040: CALL_OW 1
51044: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51045: LD_ADDR_EXP 66
51049: PUSH
51050: LD_EXP 66
51054: PPUSH
51055: LD_VAR 0 1
51059: PPUSH
51060: EMPTY
51061: PPUSH
51062: CALL_OW 1
51066: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51067: LD_ADDR_EXP 67
51071: PUSH
51072: LD_EXP 67
51076: PPUSH
51077: LD_VAR 0 1
51081: PPUSH
51082: EMPTY
51083: PPUSH
51084: CALL_OW 1
51088: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51089: LD_ADDR_EXP 68
51093: PUSH
51094: LD_EXP 68
51098: PPUSH
51099: LD_VAR 0 1
51103: PPUSH
51104: EMPTY
51105: PPUSH
51106: CALL_OW 1
51110: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51111: LD_ADDR_EXP 69
51115: PUSH
51116: LD_EXP 69
51120: PPUSH
51121: LD_VAR 0 1
51125: PPUSH
51126: EMPTY
51127: PPUSH
51128: CALL_OW 1
51132: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51133: LD_ADDR_EXP 70
51137: PUSH
51138: LD_EXP 70
51142: PPUSH
51143: LD_VAR 0 1
51147: PPUSH
51148: LD_INT 0
51150: PPUSH
51151: CALL_OW 1
51155: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51156: LD_ADDR_EXP 71
51160: PUSH
51161: LD_EXP 71
51165: PPUSH
51166: LD_VAR 0 1
51170: PPUSH
51171: EMPTY
51172: PPUSH
51173: CALL_OW 1
51177: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51178: LD_ADDR_EXP 72
51182: PUSH
51183: LD_EXP 72
51187: PPUSH
51188: LD_VAR 0 1
51192: PPUSH
51193: EMPTY
51194: PPUSH
51195: CALL_OW 1
51199: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51200: LD_ADDR_EXP 73
51204: PUSH
51205: LD_EXP 73
51209: PPUSH
51210: LD_VAR 0 1
51214: PPUSH
51215: EMPTY
51216: PPUSH
51217: CALL_OW 1
51221: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51222: LD_ADDR_EXP 74
51226: PUSH
51227: LD_EXP 74
51231: PPUSH
51232: LD_VAR 0 1
51236: PPUSH
51237: EMPTY
51238: PPUSH
51239: CALL_OW 1
51243: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51244: LD_ADDR_EXP 75
51248: PUSH
51249: LD_EXP 75
51253: PPUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: EMPTY
51260: PPUSH
51261: CALL_OW 1
51265: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51266: LD_ADDR_EXP 76
51270: PUSH
51271: LD_EXP 76
51275: PPUSH
51276: LD_VAR 0 1
51280: PPUSH
51281: EMPTY
51282: PPUSH
51283: CALL_OW 1
51287: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
51288: LD_ADDR_EXP 77
51292: PUSH
51293: LD_EXP 77
51297: PPUSH
51298: LD_VAR 0 1
51302: PPUSH
51303: EMPTY
51304: PPUSH
51305: CALL_OW 1
51309: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
51310: LD_ADDR_EXP 78
51314: PUSH
51315: LD_EXP 78
51319: PPUSH
51320: LD_VAR 0 1
51324: PPUSH
51325: EMPTY
51326: PPUSH
51327: CALL_OW 1
51331: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
51332: LD_ADDR_EXP 79
51336: PUSH
51337: LD_EXP 79
51341: PPUSH
51342: LD_VAR 0 1
51346: PPUSH
51347: EMPTY
51348: PPUSH
51349: CALL_OW 1
51353: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
51354: LD_ADDR_EXP 80
51358: PUSH
51359: LD_EXP 80
51363: PPUSH
51364: LD_VAR 0 1
51368: PPUSH
51369: EMPTY
51370: PPUSH
51371: CALL_OW 1
51375: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
51376: LD_ADDR_EXP 81
51380: PUSH
51381: LD_EXP 81
51385: PPUSH
51386: LD_VAR 0 1
51390: PPUSH
51391: EMPTY
51392: PPUSH
51393: CALL_OW 1
51397: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
51398: LD_ADDR_EXP 82
51402: PUSH
51403: LD_EXP 82
51407: PPUSH
51408: LD_VAR 0 1
51412: PPUSH
51413: EMPTY
51414: PPUSH
51415: CALL_OW 1
51419: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
51420: LD_ADDR_EXP 83
51424: PUSH
51425: LD_EXP 83
51429: PPUSH
51430: LD_VAR 0 1
51434: PPUSH
51435: EMPTY
51436: PPUSH
51437: CALL_OW 1
51441: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
51442: LD_ADDR_EXP 84
51446: PUSH
51447: LD_EXP 84
51451: PPUSH
51452: LD_VAR 0 1
51456: PPUSH
51457: EMPTY
51458: PPUSH
51459: CALL_OW 1
51463: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
51464: LD_ADDR_EXP 86
51468: PUSH
51469: LD_EXP 86
51473: PPUSH
51474: LD_VAR 0 1
51478: PPUSH
51479: EMPTY
51480: PPUSH
51481: CALL_OW 1
51485: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
51486: LD_ADDR_EXP 88
51490: PUSH
51491: LD_EXP 88
51495: PPUSH
51496: LD_VAR 0 1
51500: PPUSH
51501: EMPTY
51502: PPUSH
51503: CALL_OW 1
51507: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
51508: LD_ADDR_EXP 89
51512: PUSH
51513: LD_EXP 89
51517: PPUSH
51518: LD_VAR 0 1
51522: PPUSH
51523: EMPTY
51524: PPUSH
51525: CALL_OW 1
51529: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
51530: LD_ADDR_EXP 90
51534: PUSH
51535: LD_EXP 90
51539: PPUSH
51540: LD_VAR 0 1
51544: PPUSH
51545: EMPTY
51546: PPUSH
51547: CALL_OW 1
51551: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
51552: LD_ADDR_EXP 91
51556: PUSH
51557: LD_EXP 91
51561: PPUSH
51562: LD_VAR 0 1
51566: PPUSH
51567: EMPTY
51568: PPUSH
51569: CALL_OW 1
51573: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
51574: LD_ADDR_EXP 92
51578: PUSH
51579: LD_EXP 92
51583: PPUSH
51584: LD_VAR 0 1
51588: PPUSH
51589: EMPTY
51590: PPUSH
51591: CALL_OW 1
51595: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
51596: LD_ADDR_EXP 93
51600: PUSH
51601: LD_EXP 93
51605: PPUSH
51606: LD_VAR 0 1
51610: PPUSH
51611: EMPTY
51612: PPUSH
51613: CALL_OW 1
51617: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
51618: LD_ADDR_EXP 94
51622: PUSH
51623: LD_EXP 94
51627: PPUSH
51628: LD_VAR 0 1
51632: PPUSH
51633: EMPTY
51634: PPUSH
51635: CALL_OW 1
51639: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
51640: LD_ADDR_EXP 95
51644: PUSH
51645: LD_EXP 95
51649: PPUSH
51650: LD_VAR 0 1
51654: PPUSH
51655: EMPTY
51656: PPUSH
51657: CALL_OW 1
51661: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
51662: LD_ADDR_EXP 96
51666: PUSH
51667: LD_EXP 96
51671: PPUSH
51672: LD_VAR 0 1
51676: PPUSH
51677: EMPTY
51678: PPUSH
51679: CALL_OW 1
51683: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
51684: LD_ADDR_EXP 97
51688: PUSH
51689: LD_EXP 97
51693: PPUSH
51694: LD_VAR 0 1
51698: PPUSH
51699: EMPTY
51700: PPUSH
51701: CALL_OW 1
51705: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
51706: LD_ADDR_EXP 98
51710: PUSH
51711: LD_EXP 98
51715: PPUSH
51716: LD_VAR 0 1
51720: PPUSH
51721: EMPTY
51722: PPUSH
51723: CALL_OW 1
51727: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
51728: LD_ADDR_EXP 99
51732: PUSH
51733: LD_EXP 99
51737: PPUSH
51738: LD_VAR 0 1
51742: PPUSH
51743: EMPTY
51744: PPUSH
51745: CALL_OW 1
51749: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
51750: LD_ADDR_EXP 100
51754: PUSH
51755: LD_EXP 100
51759: PPUSH
51760: LD_VAR 0 1
51764: PPUSH
51765: EMPTY
51766: PPUSH
51767: CALL_OW 1
51771: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
51772: LD_ADDR_EXP 101
51776: PUSH
51777: LD_EXP 101
51781: PPUSH
51782: LD_VAR 0 1
51786: PPUSH
51787: LD_INT 0
51789: PPUSH
51790: CALL_OW 1
51794: ST_TO_ADDR
// end ;
51795: LD_VAR 0 2
51799: RET
// export function MC_Add ( side , units ) ; var base ; begin
51800: LD_INT 0
51802: PPUSH
51803: PPUSH
// base := mc_bases + 1 ;
51804: LD_ADDR_VAR 0 4
51808: PUSH
51809: LD_EXP 59
51813: PUSH
51814: LD_INT 1
51816: PLUS
51817: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
51818: LD_ADDR_EXP 85
51822: PUSH
51823: LD_EXP 85
51827: PPUSH
51828: LD_VAR 0 4
51832: PPUSH
51833: LD_VAR 0 1
51837: PPUSH
51838: CALL_OW 1
51842: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
51843: LD_ADDR_EXP 59
51847: PUSH
51848: LD_EXP 59
51852: PPUSH
51853: LD_VAR 0 4
51857: PPUSH
51858: LD_VAR 0 2
51862: PPUSH
51863: CALL_OW 1
51867: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51868: LD_ADDR_EXP 60
51872: PUSH
51873: LD_EXP 60
51877: PPUSH
51878: LD_VAR 0 4
51882: PPUSH
51883: EMPTY
51884: PPUSH
51885: CALL_OW 1
51889: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51890: LD_ADDR_EXP 61
51894: PUSH
51895: LD_EXP 61
51899: PPUSH
51900: LD_VAR 0 4
51904: PPUSH
51905: EMPTY
51906: PPUSH
51907: CALL_OW 1
51911: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51912: LD_ADDR_EXP 62
51916: PUSH
51917: LD_EXP 62
51921: PPUSH
51922: LD_VAR 0 4
51926: PPUSH
51927: EMPTY
51928: PPUSH
51929: CALL_OW 1
51933: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51934: LD_ADDR_EXP 63
51938: PUSH
51939: LD_EXP 63
51943: PPUSH
51944: LD_VAR 0 4
51948: PPUSH
51949: EMPTY
51950: PPUSH
51951: CALL_OW 1
51955: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51956: LD_ADDR_EXP 64
51960: PUSH
51961: LD_EXP 64
51965: PPUSH
51966: LD_VAR 0 4
51970: PPUSH
51971: EMPTY
51972: PPUSH
51973: CALL_OW 1
51977: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51978: LD_ADDR_EXP 65
51982: PUSH
51983: LD_EXP 65
51987: PPUSH
51988: LD_VAR 0 4
51992: PPUSH
51993: EMPTY
51994: PPUSH
51995: CALL_OW 1
51999: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52000: LD_ADDR_EXP 66
52004: PUSH
52005: LD_EXP 66
52009: PPUSH
52010: LD_VAR 0 4
52014: PPUSH
52015: EMPTY
52016: PPUSH
52017: CALL_OW 1
52021: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52022: LD_ADDR_EXP 67
52026: PUSH
52027: LD_EXP 67
52031: PPUSH
52032: LD_VAR 0 4
52036: PPUSH
52037: EMPTY
52038: PPUSH
52039: CALL_OW 1
52043: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52044: LD_ADDR_EXP 68
52048: PUSH
52049: LD_EXP 68
52053: PPUSH
52054: LD_VAR 0 4
52058: PPUSH
52059: EMPTY
52060: PPUSH
52061: CALL_OW 1
52065: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52066: LD_ADDR_EXP 69
52070: PUSH
52071: LD_EXP 69
52075: PPUSH
52076: LD_VAR 0 4
52080: PPUSH
52081: EMPTY
52082: PPUSH
52083: CALL_OW 1
52087: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52088: LD_ADDR_EXP 70
52092: PUSH
52093: LD_EXP 70
52097: PPUSH
52098: LD_VAR 0 4
52102: PPUSH
52103: LD_INT 0
52105: PPUSH
52106: CALL_OW 1
52110: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52111: LD_ADDR_EXP 71
52115: PUSH
52116: LD_EXP 71
52120: PPUSH
52121: LD_VAR 0 4
52125: PPUSH
52126: EMPTY
52127: PPUSH
52128: CALL_OW 1
52132: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52133: LD_ADDR_EXP 72
52137: PUSH
52138: LD_EXP 72
52142: PPUSH
52143: LD_VAR 0 4
52147: PPUSH
52148: EMPTY
52149: PPUSH
52150: CALL_OW 1
52154: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52155: LD_ADDR_EXP 73
52159: PUSH
52160: LD_EXP 73
52164: PPUSH
52165: LD_VAR 0 4
52169: PPUSH
52170: EMPTY
52171: PPUSH
52172: CALL_OW 1
52176: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52177: LD_ADDR_EXP 74
52181: PUSH
52182: LD_EXP 74
52186: PPUSH
52187: LD_VAR 0 4
52191: PPUSH
52192: EMPTY
52193: PPUSH
52194: CALL_OW 1
52198: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52199: LD_ADDR_EXP 75
52203: PUSH
52204: LD_EXP 75
52208: PPUSH
52209: LD_VAR 0 4
52213: PPUSH
52214: EMPTY
52215: PPUSH
52216: CALL_OW 1
52220: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52221: LD_ADDR_EXP 76
52225: PUSH
52226: LD_EXP 76
52230: PPUSH
52231: LD_VAR 0 4
52235: PPUSH
52236: EMPTY
52237: PPUSH
52238: CALL_OW 1
52242: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52243: LD_ADDR_EXP 77
52247: PUSH
52248: LD_EXP 77
52252: PPUSH
52253: LD_VAR 0 4
52257: PPUSH
52258: EMPTY
52259: PPUSH
52260: CALL_OW 1
52264: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52265: LD_ADDR_EXP 78
52269: PUSH
52270: LD_EXP 78
52274: PPUSH
52275: LD_VAR 0 4
52279: PPUSH
52280: EMPTY
52281: PPUSH
52282: CALL_OW 1
52286: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52287: LD_ADDR_EXP 79
52291: PUSH
52292: LD_EXP 79
52296: PPUSH
52297: LD_VAR 0 4
52301: PPUSH
52302: EMPTY
52303: PPUSH
52304: CALL_OW 1
52308: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52309: LD_ADDR_EXP 80
52313: PUSH
52314: LD_EXP 80
52318: PPUSH
52319: LD_VAR 0 4
52323: PPUSH
52324: EMPTY
52325: PPUSH
52326: CALL_OW 1
52330: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52331: LD_ADDR_EXP 81
52335: PUSH
52336: LD_EXP 81
52340: PPUSH
52341: LD_VAR 0 4
52345: PPUSH
52346: EMPTY
52347: PPUSH
52348: CALL_OW 1
52352: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52353: LD_ADDR_EXP 82
52357: PUSH
52358: LD_EXP 82
52362: PPUSH
52363: LD_VAR 0 4
52367: PPUSH
52368: EMPTY
52369: PPUSH
52370: CALL_OW 1
52374: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52375: LD_ADDR_EXP 83
52379: PUSH
52380: LD_EXP 83
52384: PPUSH
52385: LD_VAR 0 4
52389: PPUSH
52390: EMPTY
52391: PPUSH
52392: CALL_OW 1
52396: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52397: LD_ADDR_EXP 84
52401: PUSH
52402: LD_EXP 84
52406: PPUSH
52407: LD_VAR 0 4
52411: PPUSH
52412: EMPTY
52413: PPUSH
52414: CALL_OW 1
52418: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52419: LD_ADDR_EXP 86
52423: PUSH
52424: LD_EXP 86
52428: PPUSH
52429: LD_VAR 0 4
52433: PPUSH
52434: EMPTY
52435: PPUSH
52436: CALL_OW 1
52440: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52441: LD_ADDR_EXP 88
52445: PUSH
52446: LD_EXP 88
52450: PPUSH
52451: LD_VAR 0 4
52455: PPUSH
52456: EMPTY
52457: PPUSH
52458: CALL_OW 1
52462: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52463: LD_ADDR_EXP 89
52467: PUSH
52468: LD_EXP 89
52472: PPUSH
52473: LD_VAR 0 4
52477: PPUSH
52478: EMPTY
52479: PPUSH
52480: CALL_OW 1
52484: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52485: LD_ADDR_EXP 90
52489: PUSH
52490: LD_EXP 90
52494: PPUSH
52495: LD_VAR 0 4
52499: PPUSH
52500: EMPTY
52501: PPUSH
52502: CALL_OW 1
52506: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52507: LD_ADDR_EXP 91
52511: PUSH
52512: LD_EXP 91
52516: PPUSH
52517: LD_VAR 0 4
52521: PPUSH
52522: EMPTY
52523: PPUSH
52524: CALL_OW 1
52528: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52529: LD_ADDR_EXP 92
52533: PUSH
52534: LD_EXP 92
52538: PPUSH
52539: LD_VAR 0 4
52543: PPUSH
52544: EMPTY
52545: PPUSH
52546: CALL_OW 1
52550: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52551: LD_ADDR_EXP 93
52555: PUSH
52556: LD_EXP 93
52560: PPUSH
52561: LD_VAR 0 4
52565: PPUSH
52566: EMPTY
52567: PPUSH
52568: CALL_OW 1
52572: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52573: LD_ADDR_EXP 94
52577: PUSH
52578: LD_EXP 94
52582: PPUSH
52583: LD_VAR 0 4
52587: PPUSH
52588: EMPTY
52589: PPUSH
52590: CALL_OW 1
52594: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52595: LD_ADDR_EXP 95
52599: PUSH
52600: LD_EXP 95
52604: PPUSH
52605: LD_VAR 0 4
52609: PPUSH
52610: EMPTY
52611: PPUSH
52612: CALL_OW 1
52616: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52617: LD_ADDR_EXP 96
52621: PUSH
52622: LD_EXP 96
52626: PPUSH
52627: LD_VAR 0 4
52631: PPUSH
52632: EMPTY
52633: PPUSH
52634: CALL_OW 1
52638: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52639: LD_ADDR_EXP 97
52643: PUSH
52644: LD_EXP 97
52648: PPUSH
52649: LD_VAR 0 4
52653: PPUSH
52654: EMPTY
52655: PPUSH
52656: CALL_OW 1
52660: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52661: LD_ADDR_EXP 98
52665: PUSH
52666: LD_EXP 98
52670: PPUSH
52671: LD_VAR 0 4
52675: PPUSH
52676: EMPTY
52677: PPUSH
52678: CALL_OW 1
52682: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52683: LD_ADDR_EXP 99
52687: PUSH
52688: LD_EXP 99
52692: PPUSH
52693: LD_VAR 0 4
52697: PPUSH
52698: EMPTY
52699: PPUSH
52700: CALL_OW 1
52704: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52705: LD_ADDR_EXP 100
52709: PUSH
52710: LD_EXP 100
52714: PPUSH
52715: LD_VAR 0 4
52719: PPUSH
52720: EMPTY
52721: PPUSH
52722: CALL_OW 1
52726: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52727: LD_ADDR_EXP 101
52731: PUSH
52732: LD_EXP 101
52736: PPUSH
52737: LD_VAR 0 4
52741: PPUSH
52742: LD_INT 0
52744: PPUSH
52745: CALL_OW 1
52749: ST_TO_ADDR
// result := base ;
52750: LD_ADDR_VAR 0 3
52754: PUSH
52755: LD_VAR 0 4
52759: ST_TO_ADDR
// end ;
52760: LD_VAR 0 3
52764: RET
// export function MC_Start ( ) ; var i ; begin
52765: LD_INT 0
52767: PPUSH
52768: PPUSH
// for i = 1 to mc_bases do
52769: LD_ADDR_VAR 0 2
52773: PUSH
52774: DOUBLE
52775: LD_INT 1
52777: DEC
52778: ST_TO_ADDR
52779: LD_EXP 59
52783: PUSH
52784: FOR_TO
52785: IFFALSE 53862
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
52787: LD_ADDR_EXP 59
52791: PUSH
52792: LD_EXP 59
52796: PPUSH
52797: LD_VAR 0 2
52801: PPUSH
52802: LD_EXP 59
52806: PUSH
52807: LD_VAR 0 2
52811: ARRAY
52812: PUSH
52813: LD_INT 0
52815: DIFF
52816: PPUSH
52817: CALL_OW 1
52821: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
52822: LD_ADDR_EXP 60
52826: PUSH
52827: LD_EXP 60
52831: PPUSH
52832: LD_VAR 0 2
52836: PPUSH
52837: EMPTY
52838: PPUSH
52839: CALL_OW 1
52843: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
52844: LD_ADDR_EXP 61
52848: PUSH
52849: LD_EXP 61
52853: PPUSH
52854: LD_VAR 0 2
52858: PPUSH
52859: EMPTY
52860: PPUSH
52861: CALL_OW 1
52865: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
52866: LD_ADDR_EXP 62
52870: PUSH
52871: LD_EXP 62
52875: PPUSH
52876: LD_VAR 0 2
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
52888: LD_ADDR_EXP 63
52892: PUSH
52893: LD_EXP 63
52897: PPUSH
52898: LD_VAR 0 2
52902: PPUSH
52903: EMPTY
52904: PUSH
52905: EMPTY
52906: PUSH
52907: EMPTY
52908: LIST
52909: LIST
52910: PPUSH
52911: CALL_OW 1
52915: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
52916: LD_ADDR_EXP 64
52920: PUSH
52921: LD_EXP 64
52925: PPUSH
52926: LD_VAR 0 2
52930: PPUSH
52931: EMPTY
52932: PPUSH
52933: CALL_OW 1
52937: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
52938: LD_ADDR_EXP 91
52942: PUSH
52943: LD_EXP 91
52947: PPUSH
52948: LD_VAR 0 2
52952: PPUSH
52953: EMPTY
52954: PPUSH
52955: CALL_OW 1
52959: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
52960: LD_ADDR_EXP 65
52964: PUSH
52965: LD_EXP 65
52969: PPUSH
52970: LD_VAR 0 2
52974: PPUSH
52975: EMPTY
52976: PPUSH
52977: CALL_OW 1
52981: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
52982: LD_ADDR_EXP 66
52986: PUSH
52987: LD_EXP 66
52991: PPUSH
52992: LD_VAR 0 2
52996: PPUSH
52997: EMPTY
52998: PPUSH
52999: CALL_OW 1
53003: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53004: LD_ADDR_EXP 67
53008: PUSH
53009: LD_EXP 67
53013: PPUSH
53014: LD_VAR 0 2
53018: PPUSH
53019: LD_EXP 59
53023: PUSH
53024: LD_VAR 0 2
53028: ARRAY
53029: PPUSH
53030: LD_INT 2
53032: PUSH
53033: LD_INT 30
53035: PUSH
53036: LD_INT 32
53038: PUSH
53039: EMPTY
53040: LIST
53041: LIST
53042: PUSH
53043: LD_INT 30
53045: PUSH
53046: LD_INT 33
53048: PUSH
53049: EMPTY
53050: LIST
53051: LIST
53052: PUSH
53053: EMPTY
53054: LIST
53055: LIST
53056: LIST
53057: PPUSH
53058: CALL_OW 72
53062: PPUSH
53063: CALL_OW 1
53067: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53068: LD_ADDR_EXP 68
53072: PUSH
53073: LD_EXP 68
53077: PPUSH
53078: LD_VAR 0 2
53082: PPUSH
53083: LD_EXP 59
53087: PUSH
53088: LD_VAR 0 2
53092: ARRAY
53093: PPUSH
53094: LD_INT 2
53096: PUSH
53097: LD_INT 30
53099: PUSH
53100: LD_INT 32
53102: PUSH
53103: EMPTY
53104: LIST
53105: LIST
53106: PUSH
53107: LD_INT 30
53109: PUSH
53110: LD_INT 31
53112: PUSH
53113: EMPTY
53114: LIST
53115: LIST
53116: PUSH
53117: EMPTY
53118: LIST
53119: LIST
53120: LIST
53121: PUSH
53122: LD_INT 58
53124: PUSH
53125: EMPTY
53126: LIST
53127: PUSH
53128: EMPTY
53129: LIST
53130: LIST
53131: PPUSH
53132: CALL_OW 72
53136: PPUSH
53137: CALL_OW 1
53141: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53142: LD_ADDR_EXP 69
53146: PUSH
53147: LD_EXP 69
53151: PPUSH
53152: LD_VAR 0 2
53156: PPUSH
53157: EMPTY
53158: PPUSH
53159: CALL_OW 1
53163: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53164: LD_ADDR_EXP 73
53168: PUSH
53169: LD_EXP 73
53173: PPUSH
53174: LD_VAR 0 2
53178: PPUSH
53179: EMPTY
53180: PPUSH
53181: CALL_OW 1
53185: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53186: LD_ADDR_EXP 72
53190: PUSH
53191: LD_EXP 72
53195: PPUSH
53196: LD_VAR 0 2
53200: PPUSH
53201: EMPTY
53202: PPUSH
53203: CALL_OW 1
53207: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53208: LD_ADDR_EXP 74
53212: PUSH
53213: LD_EXP 74
53217: PPUSH
53218: LD_VAR 0 2
53222: PPUSH
53223: EMPTY
53224: PPUSH
53225: CALL_OW 1
53229: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53230: LD_ADDR_EXP 75
53234: PUSH
53235: LD_EXP 75
53239: PPUSH
53240: LD_VAR 0 2
53244: PPUSH
53245: EMPTY
53246: PPUSH
53247: CALL_OW 1
53251: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53252: LD_ADDR_EXP 76
53256: PUSH
53257: LD_EXP 76
53261: PPUSH
53262: LD_VAR 0 2
53266: PPUSH
53267: EMPTY
53268: PPUSH
53269: CALL_OW 1
53273: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
53274: LD_ADDR_EXP 77
53278: PUSH
53279: LD_EXP 77
53283: PPUSH
53284: LD_VAR 0 2
53288: PPUSH
53289: EMPTY
53290: PPUSH
53291: CALL_OW 1
53295: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
53296: LD_ADDR_EXP 78
53300: PUSH
53301: LD_EXP 78
53305: PPUSH
53306: LD_VAR 0 2
53310: PPUSH
53311: EMPTY
53312: PPUSH
53313: CALL_OW 1
53317: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
53318: LD_ADDR_EXP 79
53322: PUSH
53323: LD_EXP 79
53327: PPUSH
53328: LD_VAR 0 2
53332: PPUSH
53333: EMPTY
53334: PPUSH
53335: CALL_OW 1
53339: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
53340: LD_ADDR_EXP 80
53344: PUSH
53345: LD_EXP 80
53349: PPUSH
53350: LD_VAR 0 2
53354: PPUSH
53355: EMPTY
53356: PPUSH
53357: CALL_OW 1
53361: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
53362: LD_ADDR_EXP 81
53366: PUSH
53367: LD_EXP 81
53371: PPUSH
53372: LD_VAR 0 2
53376: PPUSH
53377: EMPTY
53378: PPUSH
53379: CALL_OW 1
53383: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
53384: LD_ADDR_EXP 70
53388: PUSH
53389: LD_EXP 70
53393: PPUSH
53394: LD_VAR 0 2
53398: PPUSH
53399: LD_INT 0
53401: PPUSH
53402: CALL_OW 1
53406: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
53407: LD_ADDR_EXP 83
53411: PUSH
53412: LD_EXP 83
53416: PPUSH
53417: LD_VAR 0 2
53421: PPUSH
53422: LD_INT 0
53424: PPUSH
53425: CALL_OW 1
53429: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
53430: LD_ADDR_EXP 71
53434: PUSH
53435: LD_EXP 71
53439: PPUSH
53440: LD_VAR 0 2
53444: PPUSH
53445: EMPTY
53446: PPUSH
53447: CALL_OW 1
53451: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
53452: LD_ADDR_EXP 82
53456: PUSH
53457: LD_EXP 82
53461: PPUSH
53462: LD_VAR 0 2
53466: PPUSH
53467: LD_INT 0
53469: PPUSH
53470: CALL_OW 1
53474: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
53475: LD_ADDR_EXP 84
53479: PUSH
53480: LD_EXP 84
53484: PPUSH
53485: LD_VAR 0 2
53489: PPUSH
53490: EMPTY
53491: PPUSH
53492: CALL_OW 1
53496: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
53497: LD_ADDR_EXP 87
53501: PUSH
53502: LD_EXP 87
53506: PPUSH
53507: LD_VAR 0 2
53511: PPUSH
53512: LD_INT 0
53514: PPUSH
53515: CALL_OW 1
53519: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
53520: LD_ADDR_EXP 88
53524: PUSH
53525: LD_EXP 88
53529: PPUSH
53530: LD_VAR 0 2
53534: PPUSH
53535: EMPTY
53536: PPUSH
53537: CALL_OW 1
53541: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
53542: LD_ADDR_EXP 89
53546: PUSH
53547: LD_EXP 89
53551: PPUSH
53552: LD_VAR 0 2
53556: PPUSH
53557: EMPTY
53558: PPUSH
53559: CALL_OW 1
53563: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
53564: LD_ADDR_EXP 90
53568: PUSH
53569: LD_EXP 90
53573: PPUSH
53574: LD_VAR 0 2
53578: PPUSH
53579: EMPTY
53580: PPUSH
53581: CALL_OW 1
53585: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
53586: LD_ADDR_EXP 92
53590: PUSH
53591: LD_EXP 92
53595: PPUSH
53596: LD_VAR 0 2
53600: PPUSH
53601: LD_EXP 59
53605: PUSH
53606: LD_VAR 0 2
53610: ARRAY
53611: PPUSH
53612: LD_INT 2
53614: PUSH
53615: LD_INT 30
53617: PUSH
53618: LD_INT 6
53620: PUSH
53621: EMPTY
53622: LIST
53623: LIST
53624: PUSH
53625: LD_INT 30
53627: PUSH
53628: LD_INT 7
53630: PUSH
53631: EMPTY
53632: LIST
53633: LIST
53634: PUSH
53635: LD_INT 30
53637: PUSH
53638: LD_INT 8
53640: PUSH
53641: EMPTY
53642: LIST
53643: LIST
53644: PUSH
53645: EMPTY
53646: LIST
53647: LIST
53648: LIST
53649: LIST
53650: PPUSH
53651: CALL_OW 72
53655: PPUSH
53656: CALL_OW 1
53660: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
53661: LD_ADDR_EXP 93
53665: PUSH
53666: LD_EXP 93
53670: PPUSH
53671: LD_VAR 0 2
53675: PPUSH
53676: EMPTY
53677: PPUSH
53678: CALL_OW 1
53682: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
53683: LD_ADDR_EXP 94
53687: PUSH
53688: LD_EXP 94
53692: PPUSH
53693: LD_VAR 0 2
53697: PPUSH
53698: EMPTY
53699: PPUSH
53700: CALL_OW 1
53704: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
53705: LD_ADDR_EXP 95
53709: PUSH
53710: LD_EXP 95
53714: PPUSH
53715: LD_VAR 0 2
53719: PPUSH
53720: EMPTY
53721: PPUSH
53722: CALL_OW 1
53726: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
53727: LD_ADDR_EXP 96
53731: PUSH
53732: LD_EXP 96
53736: PPUSH
53737: LD_VAR 0 2
53741: PPUSH
53742: EMPTY
53743: PPUSH
53744: CALL_OW 1
53748: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
53749: LD_ADDR_EXP 97
53753: PUSH
53754: LD_EXP 97
53758: PPUSH
53759: LD_VAR 0 2
53763: PPUSH
53764: EMPTY
53765: PPUSH
53766: CALL_OW 1
53770: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
53771: LD_ADDR_EXP 98
53775: PUSH
53776: LD_EXP 98
53780: PPUSH
53781: LD_VAR 0 2
53785: PPUSH
53786: EMPTY
53787: PPUSH
53788: CALL_OW 1
53792: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
53793: LD_ADDR_EXP 99
53797: PUSH
53798: LD_EXP 99
53802: PPUSH
53803: LD_VAR 0 2
53807: PPUSH
53808: EMPTY
53809: PPUSH
53810: CALL_OW 1
53814: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
53815: LD_ADDR_EXP 100
53819: PUSH
53820: LD_EXP 100
53824: PPUSH
53825: LD_VAR 0 2
53829: PPUSH
53830: EMPTY
53831: PPUSH
53832: CALL_OW 1
53836: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
53837: LD_ADDR_EXP 101
53841: PUSH
53842: LD_EXP 101
53846: PPUSH
53847: LD_VAR 0 2
53851: PPUSH
53852: LD_INT 0
53854: PPUSH
53855: CALL_OW 1
53859: ST_TO_ADDR
// end ;
53860: GO 52784
53862: POP
53863: POP
// MC_InitSides ( ) ;
53864: CALL 54150 0 0
// MC_InitResearch ( ) ;
53868: CALL 53889 0 0
// CustomInitMacro ( ) ;
53872: CALL 181 0 0
// skirmish := true ;
53876: LD_ADDR_EXP 57
53880: PUSH
53881: LD_INT 1
53883: ST_TO_ADDR
// end ;
53884: LD_VAR 0 1
53888: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
53889: LD_INT 0
53891: PPUSH
53892: PPUSH
53893: PPUSH
53894: PPUSH
53895: PPUSH
53896: PPUSH
// if not mc_bases then
53897: LD_EXP 59
53901: NOT
53902: IFFALSE 53906
// exit ;
53904: GO 54145
// for i = 1 to 8 do
53906: LD_ADDR_VAR 0 2
53910: PUSH
53911: DOUBLE
53912: LD_INT 1
53914: DEC
53915: ST_TO_ADDR
53916: LD_INT 8
53918: PUSH
53919: FOR_TO
53920: IFFALSE 53946
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
53922: LD_ADDR_EXP 86
53926: PUSH
53927: LD_EXP 86
53931: PPUSH
53932: LD_VAR 0 2
53936: PPUSH
53937: EMPTY
53938: PPUSH
53939: CALL_OW 1
53943: ST_TO_ADDR
53944: GO 53919
53946: POP
53947: POP
// tmp := [ ] ;
53948: LD_ADDR_VAR 0 5
53952: PUSH
53953: EMPTY
53954: ST_TO_ADDR
// for i = 1 to mc_sides do
53955: LD_ADDR_VAR 0 2
53959: PUSH
53960: DOUBLE
53961: LD_INT 1
53963: DEC
53964: ST_TO_ADDR
53965: LD_EXP 85
53969: PUSH
53970: FOR_TO
53971: IFFALSE 54029
// if not mc_sides [ i ] in tmp then
53973: LD_EXP 85
53977: PUSH
53978: LD_VAR 0 2
53982: ARRAY
53983: PUSH
53984: LD_VAR 0 5
53988: IN
53989: NOT
53990: IFFALSE 54027
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
53992: LD_ADDR_VAR 0 5
53996: PUSH
53997: LD_VAR 0 5
54001: PPUSH
54002: LD_VAR 0 5
54006: PUSH
54007: LD_INT 1
54009: PLUS
54010: PPUSH
54011: LD_EXP 85
54015: PUSH
54016: LD_VAR 0 2
54020: ARRAY
54021: PPUSH
54022: CALL_OW 2
54026: ST_TO_ADDR
54027: GO 53970
54029: POP
54030: POP
// if not tmp then
54031: LD_VAR 0 5
54035: NOT
54036: IFFALSE 54040
// exit ;
54038: GO 54145
// for j in tmp do
54040: LD_ADDR_VAR 0 3
54044: PUSH
54045: LD_VAR 0 5
54049: PUSH
54050: FOR_IN
54051: IFFALSE 54143
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54053: LD_ADDR_VAR 0 6
54057: PUSH
54058: LD_INT 22
54060: PUSH
54061: LD_VAR 0 3
54065: PUSH
54066: EMPTY
54067: LIST
54068: LIST
54069: PPUSH
54070: CALL_OW 69
54074: ST_TO_ADDR
// if not un then
54075: LD_VAR 0 6
54079: NOT
54080: IFFALSE 54084
// continue ;
54082: GO 54050
// nation := GetNation ( un [ 1 ] ) ;
54084: LD_ADDR_VAR 0 4
54088: PUSH
54089: LD_VAR 0 6
54093: PUSH
54094: LD_INT 1
54096: ARRAY
54097: PPUSH
54098: CALL_OW 248
54102: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54103: LD_ADDR_EXP 86
54107: PUSH
54108: LD_EXP 86
54112: PPUSH
54113: LD_VAR 0 3
54117: PPUSH
54118: LD_VAR 0 3
54122: PPUSH
54123: LD_VAR 0 4
54127: PPUSH
54128: LD_INT 1
54130: PPUSH
54131: CALL 14355 0 3
54135: PPUSH
54136: CALL_OW 1
54140: ST_TO_ADDR
// end ;
54141: GO 54050
54143: POP
54144: POP
// end ;
54145: LD_VAR 0 1
54149: RET
// export function MC_InitSides ( ) ; var i ; begin
54150: LD_INT 0
54152: PPUSH
54153: PPUSH
// if not mc_bases then
54154: LD_EXP 59
54158: NOT
54159: IFFALSE 54163
// exit ;
54161: GO 54237
// for i = 1 to mc_bases do
54163: LD_ADDR_VAR 0 2
54167: PUSH
54168: DOUBLE
54169: LD_INT 1
54171: DEC
54172: ST_TO_ADDR
54173: LD_EXP 59
54177: PUSH
54178: FOR_TO
54179: IFFALSE 54235
// if mc_bases [ i ] then
54181: LD_EXP 59
54185: PUSH
54186: LD_VAR 0 2
54190: ARRAY
54191: IFFALSE 54233
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54193: LD_ADDR_EXP 85
54197: PUSH
54198: LD_EXP 85
54202: PPUSH
54203: LD_VAR 0 2
54207: PPUSH
54208: LD_EXP 59
54212: PUSH
54213: LD_VAR 0 2
54217: ARRAY
54218: PUSH
54219: LD_INT 1
54221: ARRAY
54222: PPUSH
54223: CALL_OW 255
54227: PPUSH
54228: CALL_OW 1
54232: ST_TO_ADDR
54233: GO 54178
54235: POP
54236: POP
// end ;
54237: LD_VAR 0 1
54241: RET
// every 0 0$01 trigger skirmish do
54242: LD_EXP 57
54246: IFFALSE 54400
54248: GO 54250
54250: DISABLE
// begin enable ;
54251: ENABLE
// MC_CheckBuildings ( ) ;
54252: CALL 58898 0 0
// MC_CheckPeopleLife ( ) ;
54256: CALL 59023 0 0
// RaiseSailEvent ( 100 ) ;
54260: LD_INT 100
54262: PPUSH
54263: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
54267: LD_INT 103
54269: PPUSH
54270: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
54274: LD_INT 104
54276: PPUSH
54277: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
54281: LD_INT 105
54283: PPUSH
54284: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
54288: LD_INT 106
54290: PPUSH
54291: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
54295: LD_INT 107
54297: PPUSH
54298: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
54302: LD_INT 108
54304: PPUSH
54305: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
54309: LD_INT 109
54311: PPUSH
54312: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
54316: LD_INT 110
54318: PPUSH
54319: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
54323: LD_INT 111
54325: PPUSH
54326: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
54330: LD_INT 112
54332: PPUSH
54333: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
54337: LD_INT 113
54339: PPUSH
54340: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
54344: LD_INT 120
54346: PPUSH
54347: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
54351: LD_INT 121
54353: PPUSH
54354: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
54358: LD_INT 122
54360: PPUSH
54361: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
54365: LD_INT 123
54367: PPUSH
54368: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
54372: LD_INT 124
54374: PPUSH
54375: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
54379: LD_INT 125
54381: PPUSH
54382: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
54386: LD_INT 126
54388: PPUSH
54389: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
54393: LD_INT 200
54395: PPUSH
54396: CALL_OW 427
// end ;
54400: END
// on SailEvent ( event ) do begin if event < 100 then
54401: LD_VAR 0 1
54405: PUSH
54406: LD_INT 100
54408: LESS
54409: IFFALSE 54420
// CustomEvent ( event ) ;
54411: LD_VAR 0 1
54415: PPUSH
54416: CALL 13013 0 1
// if event = 100 then
54420: LD_VAR 0 1
54424: PUSH
54425: LD_INT 100
54427: EQUAL
54428: IFFALSE 54434
// MC_ClassManager ( ) ;
54430: CALL 54826 0 0
// if event = 101 then
54434: LD_VAR 0 1
54438: PUSH
54439: LD_INT 101
54441: EQUAL
54442: IFFALSE 54448
// MC_RepairBuildings ( ) ;
54444: CALL 59608 0 0
// if event = 102 then
54448: LD_VAR 0 1
54452: PUSH
54453: LD_INT 102
54455: EQUAL
54456: IFFALSE 54462
// MC_Heal ( ) ;
54458: CALL 60467 0 0
// if event = 103 then
54462: LD_VAR 0 1
54466: PUSH
54467: LD_INT 103
54469: EQUAL
54470: IFFALSE 54476
// MC_Build ( ) ;
54472: CALL 60889 0 0
// if event = 104 then
54476: LD_VAR 0 1
54480: PUSH
54481: LD_INT 104
54483: EQUAL
54484: IFFALSE 54490
// MC_TurretWeapon ( ) ;
54486: CALL 62502 0 0
// if event = 105 then
54490: LD_VAR 0 1
54494: PUSH
54495: LD_INT 105
54497: EQUAL
54498: IFFALSE 54504
// MC_BuildUpgrade ( ) ;
54500: CALL 62053 0 0
// if event = 106 then
54504: LD_VAR 0 1
54508: PUSH
54509: LD_INT 106
54511: EQUAL
54512: IFFALSE 54518
// MC_PlantMines ( ) ;
54514: CALL 62932 0 0
// if event = 107 then
54518: LD_VAR 0 1
54522: PUSH
54523: LD_INT 107
54525: EQUAL
54526: IFFALSE 54532
// MC_CollectCrates ( ) ;
54528: CALL 63730 0 0
// if event = 108 then
54532: LD_VAR 0 1
54536: PUSH
54537: LD_INT 108
54539: EQUAL
54540: IFFALSE 54546
// MC_LinkRemoteControl ( ) ;
54542: CALL 65506 0 0
// if event = 109 then
54546: LD_VAR 0 1
54550: PUSH
54551: LD_INT 109
54553: EQUAL
54554: IFFALSE 54560
// MC_ProduceVehicle ( ) ;
54556: CALL 65687 0 0
// if event = 110 then
54560: LD_VAR 0 1
54564: PUSH
54565: LD_INT 110
54567: EQUAL
54568: IFFALSE 54574
// MC_SendAttack ( ) ;
54570: CALL 66153 0 0
// if event = 111 then
54574: LD_VAR 0 1
54578: PUSH
54579: LD_INT 111
54581: EQUAL
54582: IFFALSE 54588
// MC_Defend ( ) ;
54584: CALL 66261 0 0
// if event = 112 then
54588: LD_VAR 0 1
54592: PUSH
54593: LD_INT 112
54595: EQUAL
54596: IFFALSE 54602
// MC_Research ( ) ;
54598: CALL 66866 0 0
// if event = 113 then
54602: LD_VAR 0 1
54606: PUSH
54607: LD_INT 113
54609: EQUAL
54610: IFFALSE 54616
// MC_MinesTrigger ( ) ;
54612: CALL 67980 0 0
// if event = 120 then
54616: LD_VAR 0 1
54620: PUSH
54621: LD_INT 120
54623: EQUAL
54624: IFFALSE 54630
// MC_RepairVehicle ( ) ;
54626: CALL 68079 0 0
// if event = 121 then
54630: LD_VAR 0 1
54634: PUSH
54635: LD_INT 121
54637: EQUAL
54638: IFFALSE 54644
// MC_TameApe ( ) ;
54640: CALL 68809 0 0
// if event = 122 then
54644: LD_VAR 0 1
54648: PUSH
54649: LD_INT 122
54651: EQUAL
54652: IFFALSE 54658
// MC_ChangeApeClass ( ) ;
54654: CALL 69638 0 0
// if event = 123 then
54658: LD_VAR 0 1
54662: PUSH
54663: LD_INT 123
54665: EQUAL
54666: IFFALSE 54672
// MC_Bazooka ( ) ;
54668: CALL 70288 0 0
// if event = 124 then
54672: LD_VAR 0 1
54676: PUSH
54677: LD_INT 124
54679: EQUAL
54680: IFFALSE 54686
// MC_TeleportExit ( ) ;
54682: CALL 70486 0 0
// if event = 125 then
54686: LD_VAR 0 1
54690: PUSH
54691: LD_INT 125
54693: EQUAL
54694: IFFALSE 54700
// MC_Deposits ( ) ;
54696: CALL 71133 0 0
// if event = 126 then
54700: LD_VAR 0 1
54704: PUSH
54705: LD_INT 126
54707: EQUAL
54708: IFFALSE 54714
// MC_RemoteDriver ( ) ;
54710: CALL 71758 0 0
// if event = 200 then
54714: LD_VAR 0 1
54718: PUSH
54719: LD_INT 200
54721: EQUAL
54722: IFFALSE 54728
// MC_Idle ( ) ;
54724: CALL 73707 0 0
// end ;
54728: PPOPN 1
54730: END
// export function MC_Reset ( base , tag ) ; var i ; begin
54731: LD_INT 0
54733: PPUSH
54734: PPUSH
// if not mc_bases [ base ] or not tag then
54735: LD_EXP 59
54739: PUSH
54740: LD_VAR 0 1
54744: ARRAY
54745: NOT
54746: PUSH
54747: LD_VAR 0 2
54751: NOT
54752: OR
54753: IFFALSE 54757
// exit ;
54755: GO 54821
// for i in mc_bases [ base ] union mc_ape [ base ] do
54757: LD_ADDR_VAR 0 4
54761: PUSH
54762: LD_EXP 59
54766: PUSH
54767: LD_VAR 0 1
54771: ARRAY
54772: PUSH
54773: LD_EXP 88
54777: PUSH
54778: LD_VAR 0 1
54782: ARRAY
54783: UNION
54784: PUSH
54785: FOR_IN
54786: IFFALSE 54819
// if GetTag ( i ) = tag then
54788: LD_VAR 0 4
54792: PPUSH
54793: CALL_OW 110
54797: PUSH
54798: LD_VAR 0 2
54802: EQUAL
54803: IFFALSE 54817
// SetTag ( i , 0 ) ;
54805: LD_VAR 0 4
54809: PPUSH
54810: LD_INT 0
54812: PPUSH
54813: CALL_OW 109
54817: GO 54785
54819: POP
54820: POP
// end ;
54821: LD_VAR 0 3
54825: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
54826: LD_INT 0
54828: PPUSH
54829: PPUSH
54830: PPUSH
54831: PPUSH
54832: PPUSH
54833: PPUSH
54834: PPUSH
54835: PPUSH
// if not mc_bases then
54836: LD_EXP 59
54840: NOT
54841: IFFALSE 54845
// exit ;
54843: GO 55303
// for i = 1 to mc_bases do
54845: LD_ADDR_VAR 0 2
54849: PUSH
54850: DOUBLE
54851: LD_INT 1
54853: DEC
54854: ST_TO_ADDR
54855: LD_EXP 59
54859: PUSH
54860: FOR_TO
54861: IFFALSE 55301
// begin tmp := MC_ClassCheckReq ( i ) ;
54863: LD_ADDR_VAR 0 4
54867: PUSH
54868: LD_VAR 0 2
54872: PPUSH
54873: CALL 55308 0 1
54877: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
54878: LD_ADDR_EXP 100
54882: PUSH
54883: LD_EXP 100
54887: PPUSH
54888: LD_VAR 0 2
54892: PPUSH
54893: LD_VAR 0 4
54897: PPUSH
54898: CALL_OW 1
54902: ST_TO_ADDR
// if not tmp then
54903: LD_VAR 0 4
54907: NOT
54908: IFFALSE 54912
// continue ;
54910: GO 54860
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
54912: LD_ADDR_VAR 0 6
54916: PUSH
54917: LD_EXP 59
54921: PUSH
54922: LD_VAR 0 2
54926: ARRAY
54927: PPUSH
54928: LD_INT 2
54930: PUSH
54931: LD_INT 30
54933: PUSH
54934: LD_INT 4
54936: PUSH
54937: EMPTY
54938: LIST
54939: LIST
54940: PUSH
54941: LD_INT 30
54943: PUSH
54944: LD_INT 5
54946: PUSH
54947: EMPTY
54948: LIST
54949: LIST
54950: PUSH
54951: EMPTY
54952: LIST
54953: LIST
54954: LIST
54955: PPUSH
54956: CALL_OW 72
54960: PUSH
54961: LD_EXP 59
54965: PUSH
54966: LD_VAR 0 2
54970: ARRAY
54971: PPUSH
54972: LD_INT 2
54974: PUSH
54975: LD_INT 30
54977: PUSH
54978: LD_INT 0
54980: PUSH
54981: EMPTY
54982: LIST
54983: LIST
54984: PUSH
54985: LD_INT 30
54987: PUSH
54988: LD_INT 1
54990: PUSH
54991: EMPTY
54992: LIST
54993: LIST
54994: PUSH
54995: EMPTY
54996: LIST
54997: LIST
54998: LIST
54999: PPUSH
55000: CALL_OW 72
55004: PUSH
55005: LD_EXP 59
55009: PUSH
55010: LD_VAR 0 2
55014: ARRAY
55015: PPUSH
55016: LD_INT 30
55018: PUSH
55019: LD_INT 3
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: PPUSH
55026: CALL_OW 72
55030: PUSH
55031: LD_EXP 59
55035: PUSH
55036: LD_VAR 0 2
55040: ARRAY
55041: PPUSH
55042: LD_INT 2
55044: PUSH
55045: LD_INT 30
55047: PUSH
55048: LD_INT 6
55050: PUSH
55051: EMPTY
55052: LIST
55053: LIST
55054: PUSH
55055: LD_INT 30
55057: PUSH
55058: LD_INT 7
55060: PUSH
55061: EMPTY
55062: LIST
55063: LIST
55064: PUSH
55065: LD_INT 30
55067: PUSH
55068: LD_INT 8
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: PUSH
55075: EMPTY
55076: LIST
55077: LIST
55078: LIST
55079: LIST
55080: PPUSH
55081: CALL_OW 72
55085: PUSH
55086: EMPTY
55087: LIST
55088: LIST
55089: LIST
55090: LIST
55091: ST_TO_ADDR
// for j = 1 to 4 do
55092: LD_ADDR_VAR 0 3
55096: PUSH
55097: DOUBLE
55098: LD_INT 1
55100: DEC
55101: ST_TO_ADDR
55102: LD_INT 4
55104: PUSH
55105: FOR_TO
55106: IFFALSE 55297
// begin if not tmp [ j ] then
55108: LD_VAR 0 4
55112: PUSH
55113: LD_VAR 0 3
55117: ARRAY
55118: NOT
55119: IFFALSE 55123
// continue ;
55121: GO 55105
// for p in tmp [ j ] do
55123: LD_ADDR_VAR 0 5
55127: PUSH
55128: LD_VAR 0 4
55132: PUSH
55133: LD_VAR 0 3
55137: ARRAY
55138: PUSH
55139: FOR_IN
55140: IFFALSE 55293
// begin if not b [ j ] then
55142: LD_VAR 0 6
55146: PUSH
55147: LD_VAR 0 3
55151: ARRAY
55152: NOT
55153: IFFALSE 55157
// break ;
55155: GO 55293
// e := 0 ;
55157: LD_ADDR_VAR 0 7
55161: PUSH
55162: LD_INT 0
55164: ST_TO_ADDR
// for k in b [ j ] do
55165: LD_ADDR_VAR 0 8
55169: PUSH
55170: LD_VAR 0 6
55174: PUSH
55175: LD_VAR 0 3
55179: ARRAY
55180: PUSH
55181: FOR_IN
55182: IFFALSE 55209
// if IsNotFull ( k ) then
55184: LD_VAR 0 8
55188: PPUSH
55189: CALL 16504 0 1
55193: IFFALSE 55207
// begin e := k ;
55195: LD_ADDR_VAR 0 7
55199: PUSH
55200: LD_VAR 0 8
55204: ST_TO_ADDR
// break ;
55205: GO 55209
// end ;
55207: GO 55181
55209: POP
55210: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55211: LD_VAR 0 7
55215: PUSH
55216: LD_VAR 0 5
55220: PPUSH
55221: LD_VAR 0 7
55225: PPUSH
55226: CALL 48924 0 2
55230: NOT
55231: AND
55232: IFFALSE 55291
// begin if IsInUnit ( p ) then
55234: LD_VAR 0 5
55238: PPUSH
55239: CALL_OW 310
55243: IFFALSE 55254
// ComExitBuilding ( p ) ;
55245: LD_VAR 0 5
55249: PPUSH
55250: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55254: LD_VAR 0 5
55258: PPUSH
55259: LD_VAR 0 7
55263: PPUSH
55264: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
55268: LD_VAR 0 5
55272: PPUSH
55273: LD_VAR 0 3
55277: PPUSH
55278: CALL_OW 183
// AddComExitBuilding ( p ) ;
55282: LD_VAR 0 5
55286: PPUSH
55287: CALL_OW 182
// end ; end ;
55291: GO 55139
55293: POP
55294: POP
// end ;
55295: GO 55105
55297: POP
55298: POP
// end ;
55299: GO 54860
55301: POP
55302: POP
// end ;
55303: LD_VAR 0 1
55307: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
55308: LD_INT 0
55310: PPUSH
55311: PPUSH
55312: PPUSH
55313: PPUSH
55314: PPUSH
55315: PPUSH
55316: PPUSH
55317: PPUSH
55318: PPUSH
55319: PPUSH
55320: PPUSH
55321: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
55322: LD_VAR 0 1
55326: NOT
55327: PUSH
55328: LD_EXP 59
55332: PUSH
55333: LD_VAR 0 1
55337: ARRAY
55338: NOT
55339: OR
55340: PUSH
55341: LD_EXP 59
55345: PUSH
55346: LD_VAR 0 1
55350: ARRAY
55351: PPUSH
55352: LD_INT 2
55354: PUSH
55355: LD_INT 30
55357: PUSH
55358: LD_INT 0
55360: PUSH
55361: EMPTY
55362: LIST
55363: LIST
55364: PUSH
55365: LD_INT 30
55367: PUSH
55368: LD_INT 1
55370: PUSH
55371: EMPTY
55372: LIST
55373: LIST
55374: PUSH
55375: EMPTY
55376: LIST
55377: LIST
55378: LIST
55379: PPUSH
55380: CALL_OW 72
55384: NOT
55385: OR
55386: IFFALSE 55390
// exit ;
55388: GO 58893
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55390: LD_ADDR_VAR 0 4
55394: PUSH
55395: LD_EXP 59
55399: PUSH
55400: LD_VAR 0 1
55404: ARRAY
55405: PPUSH
55406: LD_INT 2
55408: PUSH
55409: LD_INT 25
55411: PUSH
55412: LD_INT 1
55414: PUSH
55415: EMPTY
55416: LIST
55417: LIST
55418: PUSH
55419: LD_INT 25
55421: PUSH
55422: LD_INT 2
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: PUSH
55429: LD_INT 25
55431: PUSH
55432: LD_INT 3
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: PUSH
55439: LD_INT 25
55441: PUSH
55442: LD_INT 4
55444: PUSH
55445: EMPTY
55446: LIST
55447: LIST
55448: PUSH
55449: LD_INT 25
55451: PUSH
55452: LD_INT 5
55454: PUSH
55455: EMPTY
55456: LIST
55457: LIST
55458: PUSH
55459: LD_INT 25
55461: PUSH
55462: LD_INT 8
55464: PUSH
55465: EMPTY
55466: LIST
55467: LIST
55468: PUSH
55469: LD_INT 25
55471: PUSH
55472: LD_INT 9
55474: PUSH
55475: EMPTY
55476: LIST
55477: LIST
55478: PUSH
55479: EMPTY
55480: LIST
55481: LIST
55482: LIST
55483: LIST
55484: LIST
55485: LIST
55486: LIST
55487: LIST
55488: PPUSH
55489: CALL_OW 72
55493: ST_TO_ADDR
// if not tmp then
55494: LD_VAR 0 4
55498: NOT
55499: IFFALSE 55503
// exit ;
55501: GO 58893
// for i in tmp do
55503: LD_ADDR_VAR 0 3
55507: PUSH
55508: LD_VAR 0 4
55512: PUSH
55513: FOR_IN
55514: IFFALSE 55545
// if GetTag ( i ) then
55516: LD_VAR 0 3
55520: PPUSH
55521: CALL_OW 110
55525: IFFALSE 55543
// tmp := tmp diff i ;
55527: LD_ADDR_VAR 0 4
55531: PUSH
55532: LD_VAR 0 4
55536: PUSH
55537: LD_VAR 0 3
55541: DIFF
55542: ST_TO_ADDR
55543: GO 55513
55545: POP
55546: POP
// if not tmp then
55547: LD_VAR 0 4
55551: NOT
55552: IFFALSE 55556
// exit ;
55554: GO 58893
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
55556: LD_ADDR_VAR 0 5
55560: PUSH
55561: LD_EXP 59
55565: PUSH
55566: LD_VAR 0 1
55570: ARRAY
55571: PPUSH
55572: LD_INT 2
55574: PUSH
55575: LD_INT 25
55577: PUSH
55578: LD_INT 1
55580: PUSH
55581: EMPTY
55582: LIST
55583: LIST
55584: PUSH
55585: LD_INT 25
55587: PUSH
55588: LD_INT 5
55590: PUSH
55591: EMPTY
55592: LIST
55593: LIST
55594: PUSH
55595: LD_INT 25
55597: PUSH
55598: LD_INT 8
55600: PUSH
55601: EMPTY
55602: LIST
55603: LIST
55604: PUSH
55605: LD_INT 25
55607: PUSH
55608: LD_INT 9
55610: PUSH
55611: EMPTY
55612: LIST
55613: LIST
55614: PUSH
55615: EMPTY
55616: LIST
55617: LIST
55618: LIST
55619: LIST
55620: LIST
55621: PPUSH
55622: CALL_OW 72
55626: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
55627: LD_ADDR_VAR 0 6
55631: PUSH
55632: LD_EXP 59
55636: PUSH
55637: LD_VAR 0 1
55641: ARRAY
55642: PPUSH
55643: LD_INT 25
55645: PUSH
55646: LD_INT 2
55648: PUSH
55649: EMPTY
55650: LIST
55651: LIST
55652: PPUSH
55653: CALL_OW 72
55657: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
55658: LD_ADDR_VAR 0 7
55662: PUSH
55663: LD_EXP 59
55667: PUSH
55668: LD_VAR 0 1
55672: ARRAY
55673: PPUSH
55674: LD_INT 25
55676: PUSH
55677: LD_INT 3
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: PPUSH
55684: CALL_OW 72
55688: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
55689: LD_ADDR_VAR 0 8
55693: PUSH
55694: LD_EXP 59
55698: PUSH
55699: LD_VAR 0 1
55703: ARRAY
55704: PPUSH
55705: LD_INT 25
55707: PUSH
55708: LD_INT 4
55710: PUSH
55711: EMPTY
55712: LIST
55713: LIST
55714: PUSH
55715: LD_INT 24
55717: PUSH
55718: LD_INT 251
55720: PUSH
55721: EMPTY
55722: LIST
55723: LIST
55724: PUSH
55725: EMPTY
55726: LIST
55727: LIST
55728: PPUSH
55729: CALL_OW 72
55733: ST_TO_ADDR
// if mc_scan [ base ] then
55734: LD_EXP 82
55738: PUSH
55739: LD_VAR 0 1
55743: ARRAY
55744: IFFALSE 56205
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
55746: LD_ADDR_EXP 101
55750: PUSH
55751: LD_EXP 101
55755: PPUSH
55756: LD_VAR 0 1
55760: PPUSH
55761: LD_INT 4
55763: PPUSH
55764: CALL_OW 1
55768: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
55769: LD_ADDR_VAR 0 12
55773: PUSH
55774: LD_EXP 59
55778: PUSH
55779: LD_VAR 0 1
55783: ARRAY
55784: PPUSH
55785: LD_INT 2
55787: PUSH
55788: LD_INT 30
55790: PUSH
55791: LD_INT 4
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: PUSH
55798: LD_INT 30
55800: PUSH
55801: LD_INT 5
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: PPUSH
55813: CALL_OW 72
55817: ST_TO_ADDR
// if not b then
55818: LD_VAR 0 12
55822: NOT
55823: IFFALSE 55827
// exit ;
55825: GO 58893
// p := [ ] ;
55827: LD_ADDR_VAR 0 11
55831: PUSH
55832: EMPTY
55833: ST_TO_ADDR
// if sci >= 2 then
55834: LD_VAR 0 8
55838: PUSH
55839: LD_INT 2
55841: GREATEREQUAL
55842: IFFALSE 55873
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
55844: LD_ADDR_VAR 0 8
55848: PUSH
55849: LD_VAR 0 8
55853: PUSH
55854: LD_INT 1
55856: ARRAY
55857: PUSH
55858: LD_VAR 0 8
55862: PUSH
55863: LD_INT 2
55865: ARRAY
55866: PUSH
55867: EMPTY
55868: LIST
55869: LIST
55870: ST_TO_ADDR
55871: GO 55934
// if sci = 1 then
55873: LD_VAR 0 8
55877: PUSH
55878: LD_INT 1
55880: EQUAL
55881: IFFALSE 55902
// sci := [ sci [ 1 ] ] else
55883: LD_ADDR_VAR 0 8
55887: PUSH
55888: LD_VAR 0 8
55892: PUSH
55893: LD_INT 1
55895: ARRAY
55896: PUSH
55897: EMPTY
55898: LIST
55899: ST_TO_ADDR
55900: GO 55934
// if sci = 0 then
55902: LD_VAR 0 8
55906: PUSH
55907: LD_INT 0
55909: EQUAL
55910: IFFALSE 55934
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
55912: LD_ADDR_VAR 0 11
55916: PUSH
55917: LD_VAR 0 4
55921: PPUSH
55922: LD_INT 4
55924: PPUSH
55925: CALL 48787 0 2
55929: PUSH
55930: LD_INT 1
55932: ARRAY
55933: ST_TO_ADDR
// if eng > 4 then
55934: LD_VAR 0 6
55938: PUSH
55939: LD_INT 4
55941: GREATER
55942: IFFALSE 55988
// for i = eng downto 4 do
55944: LD_ADDR_VAR 0 3
55948: PUSH
55949: DOUBLE
55950: LD_VAR 0 6
55954: INC
55955: ST_TO_ADDR
55956: LD_INT 4
55958: PUSH
55959: FOR_DOWNTO
55960: IFFALSE 55986
// eng := eng diff eng [ i ] ;
55962: LD_ADDR_VAR 0 6
55966: PUSH
55967: LD_VAR 0 6
55971: PUSH
55972: LD_VAR 0 6
55976: PUSH
55977: LD_VAR 0 3
55981: ARRAY
55982: DIFF
55983: ST_TO_ADDR
55984: GO 55959
55986: POP
55987: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
55988: LD_ADDR_VAR 0 4
55992: PUSH
55993: LD_VAR 0 4
55997: PUSH
55998: LD_VAR 0 5
56002: PUSH
56003: LD_VAR 0 6
56007: UNION
56008: PUSH
56009: LD_VAR 0 7
56013: UNION
56014: PUSH
56015: LD_VAR 0 8
56019: UNION
56020: DIFF
56021: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56022: LD_ADDR_VAR 0 13
56026: PUSH
56027: LD_EXP 59
56031: PUSH
56032: LD_VAR 0 1
56036: ARRAY
56037: PPUSH
56038: LD_INT 2
56040: PUSH
56041: LD_INT 30
56043: PUSH
56044: LD_INT 32
56046: PUSH
56047: EMPTY
56048: LIST
56049: LIST
56050: PUSH
56051: LD_INT 30
56053: PUSH
56054: LD_INT 31
56056: PUSH
56057: EMPTY
56058: LIST
56059: LIST
56060: PUSH
56061: EMPTY
56062: LIST
56063: LIST
56064: LIST
56065: PPUSH
56066: CALL_OW 72
56070: PUSH
56071: LD_EXP 59
56075: PUSH
56076: LD_VAR 0 1
56080: ARRAY
56081: PPUSH
56082: LD_INT 2
56084: PUSH
56085: LD_INT 30
56087: PUSH
56088: LD_INT 4
56090: PUSH
56091: EMPTY
56092: LIST
56093: LIST
56094: PUSH
56095: LD_INT 30
56097: PUSH
56098: LD_INT 5
56100: PUSH
56101: EMPTY
56102: LIST
56103: LIST
56104: PUSH
56105: EMPTY
56106: LIST
56107: LIST
56108: LIST
56109: PPUSH
56110: CALL_OW 72
56114: PUSH
56115: LD_INT 6
56117: MUL
56118: PLUS
56119: ST_TO_ADDR
// if bcount < tmp then
56120: LD_VAR 0 13
56124: PUSH
56125: LD_VAR 0 4
56129: LESS
56130: IFFALSE 56176
// for i = tmp downto bcount do
56132: LD_ADDR_VAR 0 3
56136: PUSH
56137: DOUBLE
56138: LD_VAR 0 4
56142: INC
56143: ST_TO_ADDR
56144: LD_VAR 0 13
56148: PUSH
56149: FOR_DOWNTO
56150: IFFALSE 56174
// tmp := Delete ( tmp , tmp ) ;
56152: LD_ADDR_VAR 0 4
56156: PUSH
56157: LD_VAR 0 4
56161: PPUSH
56162: LD_VAR 0 4
56166: PPUSH
56167: CALL_OW 3
56171: ST_TO_ADDR
56172: GO 56149
56174: POP
56175: POP
// result := [ tmp , 0 , 0 , p ] ;
56176: LD_ADDR_VAR 0 2
56180: PUSH
56181: LD_VAR 0 4
56185: PUSH
56186: LD_INT 0
56188: PUSH
56189: LD_INT 0
56191: PUSH
56192: LD_VAR 0 11
56196: PUSH
56197: EMPTY
56198: LIST
56199: LIST
56200: LIST
56201: LIST
56202: ST_TO_ADDR
// exit ;
56203: GO 58893
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56205: LD_EXP 59
56209: PUSH
56210: LD_VAR 0 1
56214: ARRAY
56215: PPUSH
56216: LD_INT 2
56218: PUSH
56219: LD_INT 30
56221: PUSH
56222: LD_INT 6
56224: PUSH
56225: EMPTY
56226: LIST
56227: LIST
56228: PUSH
56229: LD_INT 30
56231: PUSH
56232: LD_INT 7
56234: PUSH
56235: EMPTY
56236: LIST
56237: LIST
56238: PUSH
56239: LD_INT 30
56241: PUSH
56242: LD_INT 8
56244: PUSH
56245: EMPTY
56246: LIST
56247: LIST
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: LIST
56254: PPUSH
56255: CALL_OW 72
56259: NOT
56260: PUSH
56261: LD_EXP 59
56265: PUSH
56266: LD_VAR 0 1
56270: ARRAY
56271: PPUSH
56272: LD_INT 30
56274: PUSH
56275: LD_INT 3
56277: PUSH
56278: EMPTY
56279: LIST
56280: LIST
56281: PPUSH
56282: CALL_OW 72
56286: NOT
56287: AND
56288: IFFALSE 56360
// begin if eng = tmp then
56290: LD_VAR 0 6
56294: PUSH
56295: LD_VAR 0 4
56299: EQUAL
56300: IFFALSE 56304
// exit ;
56302: GO 58893
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
56304: LD_ADDR_EXP 101
56308: PUSH
56309: LD_EXP 101
56313: PPUSH
56314: LD_VAR 0 1
56318: PPUSH
56319: LD_INT 1
56321: PPUSH
56322: CALL_OW 1
56326: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
56327: LD_ADDR_VAR 0 2
56331: PUSH
56332: LD_INT 0
56334: PUSH
56335: LD_VAR 0 4
56339: PUSH
56340: LD_VAR 0 6
56344: DIFF
56345: PUSH
56346: LD_INT 0
56348: PUSH
56349: LD_INT 0
56351: PUSH
56352: EMPTY
56353: LIST
56354: LIST
56355: LIST
56356: LIST
56357: ST_TO_ADDR
// exit ;
56358: GO 58893
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56360: LD_EXP 86
56364: PUSH
56365: LD_EXP 85
56369: PUSH
56370: LD_VAR 0 1
56374: ARRAY
56375: ARRAY
56376: PUSH
56377: LD_EXP 59
56381: PUSH
56382: LD_VAR 0 1
56386: ARRAY
56387: PPUSH
56388: LD_INT 2
56390: PUSH
56391: LD_INT 30
56393: PUSH
56394: LD_INT 6
56396: PUSH
56397: EMPTY
56398: LIST
56399: LIST
56400: PUSH
56401: LD_INT 30
56403: PUSH
56404: LD_INT 7
56406: PUSH
56407: EMPTY
56408: LIST
56409: LIST
56410: PUSH
56411: LD_INT 30
56413: PUSH
56414: LD_INT 8
56416: PUSH
56417: EMPTY
56418: LIST
56419: LIST
56420: PUSH
56421: EMPTY
56422: LIST
56423: LIST
56424: LIST
56425: LIST
56426: PPUSH
56427: CALL_OW 72
56431: AND
56432: PUSH
56433: LD_EXP 59
56437: PUSH
56438: LD_VAR 0 1
56442: ARRAY
56443: PPUSH
56444: LD_INT 30
56446: PUSH
56447: LD_INT 3
56449: PUSH
56450: EMPTY
56451: LIST
56452: LIST
56453: PPUSH
56454: CALL_OW 72
56458: NOT
56459: AND
56460: IFFALSE 56674
// begin if sci >= 6 then
56462: LD_VAR 0 8
56466: PUSH
56467: LD_INT 6
56469: GREATEREQUAL
56470: IFFALSE 56474
// exit ;
56472: GO 58893
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
56474: LD_ADDR_EXP 101
56478: PUSH
56479: LD_EXP 101
56483: PPUSH
56484: LD_VAR 0 1
56488: PPUSH
56489: LD_INT 2
56491: PPUSH
56492: CALL_OW 1
56496: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
56497: LD_ADDR_VAR 0 9
56501: PUSH
56502: LD_VAR 0 4
56506: PUSH
56507: LD_VAR 0 8
56511: DIFF
56512: PPUSH
56513: LD_INT 4
56515: PPUSH
56516: CALL 48787 0 2
56520: ST_TO_ADDR
// p := [ ] ;
56521: LD_ADDR_VAR 0 11
56525: PUSH
56526: EMPTY
56527: ST_TO_ADDR
// if sci < 6 and sort > 6 then
56528: LD_VAR 0 8
56532: PUSH
56533: LD_INT 6
56535: LESS
56536: PUSH
56537: LD_VAR 0 9
56541: PUSH
56542: LD_INT 6
56544: GREATER
56545: AND
56546: IFFALSE 56627
// begin for i = 1 to 6 - sci do
56548: LD_ADDR_VAR 0 3
56552: PUSH
56553: DOUBLE
56554: LD_INT 1
56556: DEC
56557: ST_TO_ADDR
56558: LD_INT 6
56560: PUSH
56561: LD_VAR 0 8
56565: MINUS
56566: PUSH
56567: FOR_TO
56568: IFFALSE 56623
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
56570: LD_ADDR_VAR 0 11
56574: PUSH
56575: LD_VAR 0 11
56579: PPUSH
56580: LD_VAR 0 11
56584: PUSH
56585: LD_INT 1
56587: PLUS
56588: PPUSH
56589: LD_VAR 0 9
56593: PUSH
56594: LD_INT 1
56596: ARRAY
56597: PPUSH
56598: CALL_OW 2
56602: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
56603: LD_ADDR_VAR 0 9
56607: PUSH
56608: LD_VAR 0 9
56612: PPUSH
56613: LD_INT 1
56615: PPUSH
56616: CALL_OW 3
56620: ST_TO_ADDR
// end ;
56621: GO 56567
56623: POP
56624: POP
// end else
56625: GO 56647
// if sort then
56627: LD_VAR 0 9
56631: IFFALSE 56647
// p := sort [ 1 ] ;
56633: LD_ADDR_VAR 0 11
56637: PUSH
56638: LD_VAR 0 9
56642: PUSH
56643: LD_INT 1
56645: ARRAY
56646: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
56647: LD_ADDR_VAR 0 2
56651: PUSH
56652: LD_INT 0
56654: PUSH
56655: LD_INT 0
56657: PUSH
56658: LD_INT 0
56660: PUSH
56661: LD_VAR 0 11
56665: PUSH
56666: EMPTY
56667: LIST
56668: LIST
56669: LIST
56670: LIST
56671: ST_TO_ADDR
// exit ;
56672: GO 58893
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56674: LD_EXP 86
56678: PUSH
56679: LD_EXP 85
56683: PUSH
56684: LD_VAR 0 1
56688: ARRAY
56689: ARRAY
56690: PUSH
56691: LD_EXP 59
56695: PUSH
56696: LD_VAR 0 1
56700: ARRAY
56701: PPUSH
56702: LD_INT 2
56704: PUSH
56705: LD_INT 30
56707: PUSH
56708: LD_INT 6
56710: PUSH
56711: EMPTY
56712: LIST
56713: LIST
56714: PUSH
56715: LD_INT 30
56717: PUSH
56718: LD_INT 7
56720: PUSH
56721: EMPTY
56722: LIST
56723: LIST
56724: PUSH
56725: LD_INT 30
56727: PUSH
56728: LD_INT 8
56730: PUSH
56731: EMPTY
56732: LIST
56733: LIST
56734: PUSH
56735: EMPTY
56736: LIST
56737: LIST
56738: LIST
56739: LIST
56740: PPUSH
56741: CALL_OW 72
56745: AND
56746: PUSH
56747: LD_EXP 59
56751: PUSH
56752: LD_VAR 0 1
56756: ARRAY
56757: PPUSH
56758: LD_INT 30
56760: PUSH
56761: LD_INT 3
56763: PUSH
56764: EMPTY
56765: LIST
56766: LIST
56767: PPUSH
56768: CALL_OW 72
56772: AND
56773: IFFALSE 57507
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
56775: LD_ADDR_EXP 101
56779: PUSH
56780: LD_EXP 101
56784: PPUSH
56785: LD_VAR 0 1
56789: PPUSH
56790: LD_INT 3
56792: PPUSH
56793: CALL_OW 1
56797: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
56798: LD_ADDR_VAR 0 2
56802: PUSH
56803: LD_INT 0
56805: PUSH
56806: LD_INT 0
56808: PUSH
56809: LD_INT 0
56811: PUSH
56812: LD_INT 0
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: LIST
56819: LIST
56820: ST_TO_ADDR
// if not eng then
56821: LD_VAR 0 6
56825: NOT
56826: IFFALSE 56889
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
56828: LD_ADDR_VAR 0 11
56832: PUSH
56833: LD_VAR 0 4
56837: PPUSH
56838: LD_INT 2
56840: PPUSH
56841: CALL 48787 0 2
56845: PUSH
56846: LD_INT 1
56848: ARRAY
56849: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
56850: LD_ADDR_VAR 0 2
56854: PUSH
56855: LD_VAR 0 2
56859: PPUSH
56860: LD_INT 2
56862: PPUSH
56863: LD_VAR 0 11
56867: PPUSH
56868: CALL_OW 1
56872: ST_TO_ADDR
// tmp := tmp diff p ;
56873: LD_ADDR_VAR 0 4
56877: PUSH
56878: LD_VAR 0 4
56882: PUSH
56883: LD_VAR 0 11
56887: DIFF
56888: ST_TO_ADDR
// end ; if tmp and sci < 6 then
56889: LD_VAR 0 4
56893: PUSH
56894: LD_VAR 0 8
56898: PUSH
56899: LD_INT 6
56901: LESS
56902: AND
56903: IFFALSE 57091
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
56905: LD_ADDR_VAR 0 9
56909: PUSH
56910: LD_VAR 0 4
56914: PUSH
56915: LD_VAR 0 8
56919: PUSH
56920: LD_VAR 0 7
56924: UNION
56925: DIFF
56926: PPUSH
56927: LD_INT 4
56929: PPUSH
56930: CALL 48787 0 2
56934: ST_TO_ADDR
// p := [ ] ;
56935: LD_ADDR_VAR 0 11
56939: PUSH
56940: EMPTY
56941: ST_TO_ADDR
// if sort then
56942: LD_VAR 0 9
56946: IFFALSE 57062
// for i = 1 to 6 - sci do
56948: LD_ADDR_VAR 0 3
56952: PUSH
56953: DOUBLE
56954: LD_INT 1
56956: DEC
56957: ST_TO_ADDR
56958: LD_INT 6
56960: PUSH
56961: LD_VAR 0 8
56965: MINUS
56966: PUSH
56967: FOR_TO
56968: IFFALSE 57060
// begin if i = sort then
56970: LD_VAR 0 3
56974: PUSH
56975: LD_VAR 0 9
56979: EQUAL
56980: IFFALSE 56984
// break ;
56982: GO 57060
// if GetClass ( i ) = 4 then
56984: LD_VAR 0 3
56988: PPUSH
56989: CALL_OW 257
56993: PUSH
56994: LD_INT 4
56996: EQUAL
56997: IFFALSE 57001
// continue ;
56999: GO 56967
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57001: LD_ADDR_VAR 0 11
57005: PUSH
57006: LD_VAR 0 11
57010: PPUSH
57011: LD_VAR 0 11
57015: PUSH
57016: LD_INT 1
57018: PLUS
57019: PPUSH
57020: LD_VAR 0 9
57024: PUSH
57025: LD_VAR 0 3
57029: ARRAY
57030: PPUSH
57031: CALL_OW 2
57035: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57036: LD_ADDR_VAR 0 4
57040: PUSH
57041: LD_VAR 0 4
57045: PUSH
57046: LD_VAR 0 9
57050: PUSH
57051: LD_VAR 0 3
57055: ARRAY
57056: DIFF
57057: ST_TO_ADDR
// end ;
57058: GO 56967
57060: POP
57061: POP
// if p then
57062: LD_VAR 0 11
57066: IFFALSE 57091
// result := Replace ( result , 4 , p ) ;
57068: LD_ADDR_VAR 0 2
57072: PUSH
57073: LD_VAR 0 2
57077: PPUSH
57078: LD_INT 4
57080: PPUSH
57081: LD_VAR 0 11
57085: PPUSH
57086: CALL_OW 1
57090: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57091: LD_VAR 0 4
57095: PUSH
57096: LD_VAR 0 7
57100: PUSH
57101: LD_INT 6
57103: LESS
57104: AND
57105: IFFALSE 57293
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57107: LD_ADDR_VAR 0 9
57111: PUSH
57112: LD_VAR 0 4
57116: PUSH
57117: LD_VAR 0 8
57121: PUSH
57122: LD_VAR 0 7
57126: UNION
57127: DIFF
57128: PPUSH
57129: LD_INT 3
57131: PPUSH
57132: CALL 48787 0 2
57136: ST_TO_ADDR
// p := [ ] ;
57137: LD_ADDR_VAR 0 11
57141: PUSH
57142: EMPTY
57143: ST_TO_ADDR
// if sort then
57144: LD_VAR 0 9
57148: IFFALSE 57264
// for i = 1 to 6 - mech do
57150: LD_ADDR_VAR 0 3
57154: PUSH
57155: DOUBLE
57156: LD_INT 1
57158: DEC
57159: ST_TO_ADDR
57160: LD_INT 6
57162: PUSH
57163: LD_VAR 0 7
57167: MINUS
57168: PUSH
57169: FOR_TO
57170: IFFALSE 57262
// begin if i = sort then
57172: LD_VAR 0 3
57176: PUSH
57177: LD_VAR 0 9
57181: EQUAL
57182: IFFALSE 57186
// break ;
57184: GO 57262
// if GetClass ( i ) = 3 then
57186: LD_VAR 0 3
57190: PPUSH
57191: CALL_OW 257
57195: PUSH
57196: LD_INT 3
57198: EQUAL
57199: IFFALSE 57203
// continue ;
57201: GO 57169
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57203: LD_ADDR_VAR 0 11
57207: PUSH
57208: LD_VAR 0 11
57212: PPUSH
57213: LD_VAR 0 11
57217: PUSH
57218: LD_INT 1
57220: PLUS
57221: PPUSH
57222: LD_VAR 0 9
57226: PUSH
57227: LD_VAR 0 3
57231: ARRAY
57232: PPUSH
57233: CALL_OW 2
57237: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57238: LD_ADDR_VAR 0 4
57242: PUSH
57243: LD_VAR 0 4
57247: PUSH
57248: LD_VAR 0 9
57252: PUSH
57253: LD_VAR 0 3
57257: ARRAY
57258: DIFF
57259: ST_TO_ADDR
// end ;
57260: GO 57169
57262: POP
57263: POP
// if p then
57264: LD_VAR 0 11
57268: IFFALSE 57293
// result := Replace ( result , 3 , p ) ;
57270: LD_ADDR_VAR 0 2
57274: PUSH
57275: LD_VAR 0 2
57279: PPUSH
57280: LD_INT 3
57282: PPUSH
57283: LD_VAR 0 11
57287: PPUSH
57288: CALL_OW 1
57292: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
57293: LD_VAR 0 4
57297: PUSH
57298: LD_INT 6
57300: GREATER
57301: PUSH
57302: LD_VAR 0 6
57306: PUSH
57307: LD_INT 6
57309: LESS
57310: AND
57311: IFFALSE 57505
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57313: LD_ADDR_VAR 0 9
57317: PUSH
57318: LD_VAR 0 4
57322: PUSH
57323: LD_VAR 0 8
57327: PUSH
57328: LD_VAR 0 7
57332: UNION
57333: PUSH
57334: LD_VAR 0 6
57338: UNION
57339: DIFF
57340: PPUSH
57341: LD_INT 2
57343: PPUSH
57344: CALL 48787 0 2
57348: ST_TO_ADDR
// p := [ ] ;
57349: LD_ADDR_VAR 0 11
57353: PUSH
57354: EMPTY
57355: ST_TO_ADDR
// if sort then
57356: LD_VAR 0 9
57360: IFFALSE 57476
// for i = 1 to 6 - eng do
57362: LD_ADDR_VAR 0 3
57366: PUSH
57367: DOUBLE
57368: LD_INT 1
57370: DEC
57371: ST_TO_ADDR
57372: LD_INT 6
57374: PUSH
57375: LD_VAR 0 6
57379: MINUS
57380: PUSH
57381: FOR_TO
57382: IFFALSE 57474
// begin if i = sort then
57384: LD_VAR 0 3
57388: PUSH
57389: LD_VAR 0 9
57393: EQUAL
57394: IFFALSE 57398
// break ;
57396: GO 57474
// if GetClass ( i ) = 2 then
57398: LD_VAR 0 3
57402: PPUSH
57403: CALL_OW 257
57407: PUSH
57408: LD_INT 2
57410: EQUAL
57411: IFFALSE 57415
// continue ;
57413: GO 57381
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57415: LD_ADDR_VAR 0 11
57419: PUSH
57420: LD_VAR 0 11
57424: PPUSH
57425: LD_VAR 0 11
57429: PUSH
57430: LD_INT 1
57432: PLUS
57433: PPUSH
57434: LD_VAR 0 9
57438: PUSH
57439: LD_VAR 0 3
57443: ARRAY
57444: PPUSH
57445: CALL_OW 2
57449: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57450: LD_ADDR_VAR 0 4
57454: PUSH
57455: LD_VAR 0 4
57459: PUSH
57460: LD_VAR 0 9
57464: PUSH
57465: LD_VAR 0 3
57469: ARRAY
57470: DIFF
57471: ST_TO_ADDR
// end ;
57472: GO 57381
57474: POP
57475: POP
// if p then
57476: LD_VAR 0 11
57480: IFFALSE 57505
// result := Replace ( result , 2 , p ) ;
57482: LD_ADDR_VAR 0 2
57486: PUSH
57487: LD_VAR 0 2
57491: PPUSH
57492: LD_INT 2
57494: PPUSH
57495: LD_VAR 0 11
57499: PPUSH
57500: CALL_OW 1
57504: ST_TO_ADDR
// end ; exit ;
57505: GO 58893
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
57507: LD_EXP 86
57511: PUSH
57512: LD_EXP 85
57516: PUSH
57517: LD_VAR 0 1
57521: ARRAY
57522: ARRAY
57523: NOT
57524: PUSH
57525: LD_EXP 59
57529: PUSH
57530: LD_VAR 0 1
57534: ARRAY
57535: PPUSH
57536: LD_INT 30
57538: PUSH
57539: LD_INT 3
57541: PUSH
57542: EMPTY
57543: LIST
57544: LIST
57545: PPUSH
57546: CALL_OW 72
57550: AND
57551: PUSH
57552: LD_EXP 64
57556: PUSH
57557: LD_VAR 0 1
57561: ARRAY
57562: AND
57563: IFFALSE 58171
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
57565: LD_ADDR_EXP 101
57569: PUSH
57570: LD_EXP 101
57574: PPUSH
57575: LD_VAR 0 1
57579: PPUSH
57580: LD_INT 5
57582: PPUSH
57583: CALL_OW 1
57587: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57588: LD_ADDR_VAR 0 2
57592: PUSH
57593: LD_INT 0
57595: PUSH
57596: LD_INT 0
57598: PUSH
57599: LD_INT 0
57601: PUSH
57602: LD_INT 0
57604: PUSH
57605: EMPTY
57606: LIST
57607: LIST
57608: LIST
57609: LIST
57610: ST_TO_ADDR
// if sci > 1 then
57611: LD_VAR 0 8
57615: PUSH
57616: LD_INT 1
57618: GREATER
57619: IFFALSE 57647
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
57621: LD_ADDR_VAR 0 4
57625: PUSH
57626: LD_VAR 0 4
57630: PUSH
57631: LD_VAR 0 8
57635: PUSH
57636: LD_VAR 0 8
57640: PUSH
57641: LD_INT 1
57643: ARRAY
57644: DIFF
57645: DIFF
57646: ST_TO_ADDR
// if tmp and not sci then
57647: LD_VAR 0 4
57651: PUSH
57652: LD_VAR 0 8
57656: NOT
57657: AND
57658: IFFALSE 57727
// begin sort := SortBySkill ( tmp , 4 ) ;
57660: LD_ADDR_VAR 0 9
57664: PUSH
57665: LD_VAR 0 4
57669: PPUSH
57670: LD_INT 4
57672: PPUSH
57673: CALL 48787 0 2
57677: ST_TO_ADDR
// if sort then
57678: LD_VAR 0 9
57682: IFFALSE 57698
// p := sort [ 1 ] ;
57684: LD_ADDR_VAR 0 11
57688: PUSH
57689: LD_VAR 0 9
57693: PUSH
57694: LD_INT 1
57696: ARRAY
57697: ST_TO_ADDR
// if p then
57698: LD_VAR 0 11
57702: IFFALSE 57727
// result := Replace ( result , 4 , p ) ;
57704: LD_ADDR_VAR 0 2
57708: PUSH
57709: LD_VAR 0 2
57713: PPUSH
57714: LD_INT 4
57716: PPUSH
57717: LD_VAR 0 11
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
57727: LD_ADDR_VAR 0 4
57731: PUSH
57732: LD_VAR 0 4
57736: PUSH
57737: LD_VAR 0 7
57741: DIFF
57742: ST_TO_ADDR
// if tmp and mech < 6 then
57743: LD_VAR 0 4
57747: PUSH
57748: LD_VAR 0 7
57752: PUSH
57753: LD_INT 6
57755: LESS
57756: AND
57757: IFFALSE 57945
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57759: LD_ADDR_VAR 0 9
57763: PUSH
57764: LD_VAR 0 4
57768: PUSH
57769: LD_VAR 0 8
57773: PUSH
57774: LD_VAR 0 7
57778: UNION
57779: DIFF
57780: PPUSH
57781: LD_INT 3
57783: PPUSH
57784: CALL 48787 0 2
57788: ST_TO_ADDR
// p := [ ] ;
57789: LD_ADDR_VAR 0 11
57793: PUSH
57794: EMPTY
57795: ST_TO_ADDR
// if sort then
57796: LD_VAR 0 9
57800: IFFALSE 57916
// for i = 1 to 6 - mech do
57802: LD_ADDR_VAR 0 3
57806: PUSH
57807: DOUBLE
57808: LD_INT 1
57810: DEC
57811: ST_TO_ADDR
57812: LD_INT 6
57814: PUSH
57815: LD_VAR 0 7
57819: MINUS
57820: PUSH
57821: FOR_TO
57822: IFFALSE 57914
// begin if i = sort then
57824: LD_VAR 0 3
57828: PUSH
57829: LD_VAR 0 9
57833: EQUAL
57834: IFFALSE 57838
// break ;
57836: GO 57914
// if GetClass ( i ) = 3 then
57838: LD_VAR 0 3
57842: PPUSH
57843: CALL_OW 257
57847: PUSH
57848: LD_INT 3
57850: EQUAL
57851: IFFALSE 57855
// continue ;
57853: GO 57821
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57855: LD_ADDR_VAR 0 11
57859: PUSH
57860: LD_VAR 0 11
57864: PPUSH
57865: LD_VAR 0 11
57869: PUSH
57870: LD_INT 1
57872: PLUS
57873: PPUSH
57874: LD_VAR 0 9
57878: PUSH
57879: LD_VAR 0 3
57883: ARRAY
57884: PPUSH
57885: CALL_OW 2
57889: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57890: LD_ADDR_VAR 0 4
57894: PUSH
57895: LD_VAR 0 4
57899: PUSH
57900: LD_VAR 0 9
57904: PUSH
57905: LD_VAR 0 3
57909: ARRAY
57910: DIFF
57911: ST_TO_ADDR
// end ;
57912: GO 57821
57914: POP
57915: POP
// if p then
57916: LD_VAR 0 11
57920: IFFALSE 57945
// result := Replace ( result , 3 , p ) ;
57922: LD_ADDR_VAR 0 2
57926: PUSH
57927: LD_VAR 0 2
57931: PPUSH
57932: LD_INT 3
57934: PPUSH
57935: LD_VAR 0 11
57939: PPUSH
57940: CALL_OW 1
57944: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
57945: LD_ADDR_VAR 0 4
57949: PUSH
57950: LD_VAR 0 4
57954: PUSH
57955: LD_VAR 0 6
57959: DIFF
57960: ST_TO_ADDR
// if tmp and eng < 6 then
57961: LD_VAR 0 4
57965: PUSH
57966: LD_VAR 0 6
57970: PUSH
57971: LD_INT 6
57973: LESS
57974: AND
57975: IFFALSE 58169
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
57977: LD_ADDR_VAR 0 9
57981: PUSH
57982: LD_VAR 0 4
57986: PUSH
57987: LD_VAR 0 8
57991: PUSH
57992: LD_VAR 0 7
57996: UNION
57997: PUSH
57998: LD_VAR 0 6
58002: UNION
58003: DIFF
58004: PPUSH
58005: LD_INT 2
58007: PPUSH
58008: CALL 48787 0 2
58012: ST_TO_ADDR
// p := [ ] ;
58013: LD_ADDR_VAR 0 11
58017: PUSH
58018: EMPTY
58019: ST_TO_ADDR
// if sort then
58020: LD_VAR 0 9
58024: IFFALSE 58140
// for i = 1 to 6 - eng do
58026: LD_ADDR_VAR 0 3
58030: PUSH
58031: DOUBLE
58032: LD_INT 1
58034: DEC
58035: ST_TO_ADDR
58036: LD_INT 6
58038: PUSH
58039: LD_VAR 0 6
58043: MINUS
58044: PUSH
58045: FOR_TO
58046: IFFALSE 58138
// begin if i = sort then
58048: LD_VAR 0 3
58052: PUSH
58053: LD_VAR 0 9
58057: EQUAL
58058: IFFALSE 58062
// break ;
58060: GO 58138
// if GetClass ( i ) = 2 then
58062: LD_VAR 0 3
58066: PPUSH
58067: CALL_OW 257
58071: PUSH
58072: LD_INT 2
58074: EQUAL
58075: IFFALSE 58079
// continue ;
58077: GO 58045
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58079: LD_ADDR_VAR 0 11
58083: PUSH
58084: LD_VAR 0 11
58088: PPUSH
58089: LD_VAR 0 11
58093: PUSH
58094: LD_INT 1
58096: PLUS
58097: PPUSH
58098: LD_VAR 0 9
58102: PUSH
58103: LD_VAR 0 3
58107: ARRAY
58108: PPUSH
58109: CALL_OW 2
58113: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58114: LD_ADDR_VAR 0 4
58118: PUSH
58119: LD_VAR 0 4
58123: PUSH
58124: LD_VAR 0 9
58128: PUSH
58129: LD_VAR 0 3
58133: ARRAY
58134: DIFF
58135: ST_TO_ADDR
// end ;
58136: GO 58045
58138: POP
58139: POP
// if p then
58140: LD_VAR 0 11
58144: IFFALSE 58169
// result := Replace ( result , 2 , p ) ;
58146: LD_ADDR_VAR 0 2
58150: PUSH
58151: LD_VAR 0 2
58155: PPUSH
58156: LD_INT 2
58158: PPUSH
58159: LD_VAR 0 11
58163: PPUSH
58164: CALL_OW 1
58168: ST_TO_ADDR
// end ; exit ;
58169: GO 58893
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58171: LD_EXP 86
58175: PUSH
58176: LD_EXP 85
58180: PUSH
58181: LD_VAR 0 1
58185: ARRAY
58186: ARRAY
58187: NOT
58188: PUSH
58189: LD_EXP 59
58193: PUSH
58194: LD_VAR 0 1
58198: ARRAY
58199: PPUSH
58200: LD_INT 30
58202: PUSH
58203: LD_INT 3
58205: PUSH
58206: EMPTY
58207: LIST
58208: LIST
58209: PPUSH
58210: CALL_OW 72
58214: AND
58215: PUSH
58216: LD_EXP 64
58220: PUSH
58221: LD_VAR 0 1
58225: ARRAY
58226: NOT
58227: AND
58228: IFFALSE 58893
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58230: LD_ADDR_EXP 101
58234: PUSH
58235: LD_EXP 101
58239: PPUSH
58240: LD_VAR 0 1
58244: PPUSH
58245: LD_INT 6
58247: PPUSH
58248: CALL_OW 1
58252: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58253: LD_ADDR_VAR 0 2
58257: PUSH
58258: LD_INT 0
58260: PUSH
58261: LD_INT 0
58263: PUSH
58264: LD_INT 0
58266: PUSH
58267: LD_INT 0
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: LIST
58274: LIST
58275: ST_TO_ADDR
// if sci >= 1 then
58276: LD_VAR 0 8
58280: PUSH
58281: LD_INT 1
58283: GREATEREQUAL
58284: IFFALSE 58306
// tmp := tmp diff sci [ 1 ] ;
58286: LD_ADDR_VAR 0 4
58290: PUSH
58291: LD_VAR 0 4
58295: PUSH
58296: LD_VAR 0 8
58300: PUSH
58301: LD_INT 1
58303: ARRAY
58304: DIFF
58305: ST_TO_ADDR
// if tmp and not sci then
58306: LD_VAR 0 4
58310: PUSH
58311: LD_VAR 0 8
58315: NOT
58316: AND
58317: IFFALSE 58386
// begin sort := SortBySkill ( tmp , 4 ) ;
58319: LD_ADDR_VAR 0 9
58323: PUSH
58324: LD_VAR 0 4
58328: PPUSH
58329: LD_INT 4
58331: PPUSH
58332: CALL 48787 0 2
58336: ST_TO_ADDR
// if sort then
58337: LD_VAR 0 9
58341: IFFALSE 58357
// p := sort [ 1 ] ;
58343: LD_ADDR_VAR 0 11
58347: PUSH
58348: LD_VAR 0 9
58352: PUSH
58353: LD_INT 1
58355: ARRAY
58356: ST_TO_ADDR
// if p then
58357: LD_VAR 0 11
58361: IFFALSE 58386
// result := Replace ( result , 4 , p ) ;
58363: LD_ADDR_VAR 0 2
58367: PUSH
58368: LD_VAR 0 2
58372: PPUSH
58373: LD_INT 4
58375: PPUSH
58376: LD_VAR 0 11
58380: PPUSH
58381: CALL_OW 1
58385: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58386: LD_ADDR_VAR 0 4
58390: PUSH
58391: LD_VAR 0 4
58395: PUSH
58396: LD_VAR 0 7
58400: DIFF
58401: ST_TO_ADDR
// if tmp and mech < 6 then
58402: LD_VAR 0 4
58406: PUSH
58407: LD_VAR 0 7
58411: PUSH
58412: LD_INT 6
58414: LESS
58415: AND
58416: IFFALSE 58598
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
58418: LD_ADDR_VAR 0 9
58422: PUSH
58423: LD_VAR 0 4
58427: PUSH
58428: LD_VAR 0 7
58432: DIFF
58433: PPUSH
58434: LD_INT 3
58436: PPUSH
58437: CALL 48787 0 2
58441: ST_TO_ADDR
// p := [ ] ;
58442: LD_ADDR_VAR 0 11
58446: PUSH
58447: EMPTY
58448: ST_TO_ADDR
// if sort then
58449: LD_VAR 0 9
58453: IFFALSE 58569
// for i = 1 to 6 - mech do
58455: LD_ADDR_VAR 0 3
58459: PUSH
58460: DOUBLE
58461: LD_INT 1
58463: DEC
58464: ST_TO_ADDR
58465: LD_INT 6
58467: PUSH
58468: LD_VAR 0 7
58472: MINUS
58473: PUSH
58474: FOR_TO
58475: IFFALSE 58567
// begin if i = sort then
58477: LD_VAR 0 3
58481: PUSH
58482: LD_VAR 0 9
58486: EQUAL
58487: IFFALSE 58491
// break ;
58489: GO 58567
// if GetClass ( i ) = 3 then
58491: LD_VAR 0 3
58495: PPUSH
58496: CALL_OW 257
58500: PUSH
58501: LD_INT 3
58503: EQUAL
58504: IFFALSE 58508
// continue ;
58506: GO 58474
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58508: LD_ADDR_VAR 0 11
58512: PUSH
58513: LD_VAR 0 11
58517: PPUSH
58518: LD_VAR 0 11
58522: PUSH
58523: LD_INT 1
58525: PLUS
58526: PPUSH
58527: LD_VAR 0 9
58531: PUSH
58532: LD_VAR 0 3
58536: ARRAY
58537: PPUSH
58538: CALL_OW 2
58542: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58543: LD_ADDR_VAR 0 4
58547: PUSH
58548: LD_VAR 0 4
58552: PUSH
58553: LD_VAR 0 9
58557: PUSH
58558: LD_VAR 0 3
58562: ARRAY
58563: DIFF
58564: ST_TO_ADDR
// end ;
58565: GO 58474
58567: POP
58568: POP
// if p then
58569: LD_VAR 0 11
58573: IFFALSE 58598
// result := Replace ( result , 3 , p ) ;
58575: LD_ADDR_VAR 0 2
58579: PUSH
58580: LD_VAR 0 2
58584: PPUSH
58585: LD_INT 3
58587: PPUSH
58588: LD_VAR 0 11
58592: PPUSH
58593: CALL_OW 1
58597: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58598: LD_ADDR_VAR 0 4
58602: PUSH
58603: LD_VAR 0 4
58607: PUSH
58608: LD_VAR 0 6
58612: DIFF
58613: ST_TO_ADDR
// if tmp and eng < 4 then
58614: LD_VAR 0 4
58618: PUSH
58619: LD_VAR 0 6
58623: PUSH
58624: LD_INT 4
58626: LESS
58627: AND
58628: IFFALSE 58818
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
58630: LD_ADDR_VAR 0 9
58634: PUSH
58635: LD_VAR 0 4
58639: PUSH
58640: LD_VAR 0 7
58644: PUSH
58645: LD_VAR 0 6
58649: UNION
58650: DIFF
58651: PPUSH
58652: LD_INT 2
58654: PPUSH
58655: CALL 48787 0 2
58659: ST_TO_ADDR
// p := [ ] ;
58660: LD_ADDR_VAR 0 11
58664: PUSH
58665: EMPTY
58666: ST_TO_ADDR
// if sort then
58667: LD_VAR 0 9
58671: IFFALSE 58787
// for i = 1 to 4 - eng do
58673: LD_ADDR_VAR 0 3
58677: PUSH
58678: DOUBLE
58679: LD_INT 1
58681: DEC
58682: ST_TO_ADDR
58683: LD_INT 4
58685: PUSH
58686: LD_VAR 0 6
58690: MINUS
58691: PUSH
58692: FOR_TO
58693: IFFALSE 58785
// begin if i = sort then
58695: LD_VAR 0 3
58699: PUSH
58700: LD_VAR 0 9
58704: EQUAL
58705: IFFALSE 58709
// break ;
58707: GO 58785
// if GetClass ( i ) = 2 then
58709: LD_VAR 0 3
58713: PPUSH
58714: CALL_OW 257
58718: PUSH
58719: LD_INT 2
58721: EQUAL
58722: IFFALSE 58726
// continue ;
58724: GO 58692
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58726: LD_ADDR_VAR 0 11
58730: PUSH
58731: LD_VAR 0 11
58735: PPUSH
58736: LD_VAR 0 11
58740: PUSH
58741: LD_INT 1
58743: PLUS
58744: PPUSH
58745: LD_VAR 0 9
58749: PUSH
58750: LD_VAR 0 3
58754: ARRAY
58755: PPUSH
58756: CALL_OW 2
58760: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58761: LD_ADDR_VAR 0 4
58765: PUSH
58766: LD_VAR 0 4
58770: PUSH
58771: LD_VAR 0 9
58775: PUSH
58776: LD_VAR 0 3
58780: ARRAY
58781: DIFF
58782: ST_TO_ADDR
// end ;
58783: GO 58692
58785: POP
58786: POP
// if p then
58787: LD_VAR 0 11
58791: IFFALSE 58816
// result := Replace ( result , 2 , p ) ;
58793: LD_ADDR_VAR 0 2
58797: PUSH
58798: LD_VAR 0 2
58802: PPUSH
58803: LD_INT 2
58805: PPUSH
58806: LD_VAR 0 11
58810: PPUSH
58811: CALL_OW 1
58815: ST_TO_ADDR
// end else
58816: GO 58862
// for i = eng downto 5 do
58818: LD_ADDR_VAR 0 3
58822: PUSH
58823: DOUBLE
58824: LD_VAR 0 6
58828: INC
58829: ST_TO_ADDR
58830: LD_INT 5
58832: PUSH
58833: FOR_DOWNTO
58834: IFFALSE 58860
// tmp := tmp union eng [ i ] ;
58836: LD_ADDR_VAR 0 4
58840: PUSH
58841: LD_VAR 0 4
58845: PUSH
58846: LD_VAR 0 6
58850: PUSH
58851: LD_VAR 0 3
58855: ARRAY
58856: UNION
58857: ST_TO_ADDR
58858: GO 58833
58860: POP
58861: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
58862: LD_ADDR_VAR 0 2
58866: PUSH
58867: LD_VAR 0 2
58871: PPUSH
58872: LD_INT 1
58874: PPUSH
58875: LD_VAR 0 4
58879: PUSH
58880: LD_VAR 0 5
58884: DIFF
58885: PPUSH
58886: CALL_OW 1
58890: ST_TO_ADDR
// exit ;
58891: GO 58893
// end ; end ;
58893: LD_VAR 0 2
58897: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
58898: LD_INT 0
58900: PPUSH
58901: PPUSH
58902: PPUSH
// if not mc_bases then
58903: LD_EXP 59
58907: NOT
58908: IFFALSE 58912
// exit ;
58910: GO 59018
// for i = 1 to mc_bases do
58912: LD_ADDR_VAR 0 2
58916: PUSH
58917: DOUBLE
58918: LD_INT 1
58920: DEC
58921: ST_TO_ADDR
58922: LD_EXP 59
58926: PUSH
58927: FOR_TO
58928: IFFALSE 59009
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
58930: LD_ADDR_VAR 0 3
58934: PUSH
58935: LD_EXP 59
58939: PUSH
58940: LD_VAR 0 2
58944: ARRAY
58945: PPUSH
58946: LD_INT 21
58948: PUSH
58949: LD_INT 3
58951: PUSH
58952: EMPTY
58953: LIST
58954: LIST
58955: PUSH
58956: LD_INT 3
58958: PUSH
58959: LD_INT 24
58961: PUSH
58962: LD_INT 1000
58964: PUSH
58965: EMPTY
58966: LIST
58967: LIST
58968: PUSH
58969: EMPTY
58970: LIST
58971: LIST
58972: PUSH
58973: EMPTY
58974: LIST
58975: LIST
58976: PPUSH
58977: CALL_OW 72
58981: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
58982: LD_ADDR_EXP 60
58986: PUSH
58987: LD_EXP 60
58991: PPUSH
58992: LD_VAR 0 2
58996: PPUSH
58997: LD_VAR 0 3
59001: PPUSH
59002: CALL_OW 1
59006: ST_TO_ADDR
// end ;
59007: GO 58927
59009: POP
59010: POP
// RaiseSailEvent ( 101 ) ;
59011: LD_INT 101
59013: PPUSH
59014: CALL_OW 427
// end ;
59018: LD_VAR 0 1
59022: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59023: LD_INT 0
59025: PPUSH
59026: PPUSH
59027: PPUSH
59028: PPUSH
59029: PPUSH
59030: PPUSH
59031: PPUSH
// if not mc_bases then
59032: LD_EXP 59
59036: NOT
59037: IFFALSE 59041
// exit ;
59039: GO 59603
// for i = 1 to mc_bases do
59041: LD_ADDR_VAR 0 2
59045: PUSH
59046: DOUBLE
59047: LD_INT 1
59049: DEC
59050: ST_TO_ADDR
59051: LD_EXP 59
59055: PUSH
59056: FOR_TO
59057: IFFALSE 59594
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
59059: LD_ADDR_VAR 0 5
59063: PUSH
59064: LD_EXP 59
59068: PUSH
59069: LD_VAR 0 2
59073: ARRAY
59074: PUSH
59075: LD_EXP 88
59079: PUSH
59080: LD_VAR 0 2
59084: ARRAY
59085: UNION
59086: PPUSH
59087: LD_INT 21
59089: PUSH
59090: LD_INT 1
59092: PUSH
59093: EMPTY
59094: LIST
59095: LIST
59096: PUSH
59097: LD_INT 1
59099: PUSH
59100: LD_INT 3
59102: PUSH
59103: LD_INT 54
59105: PUSH
59106: EMPTY
59107: LIST
59108: PUSH
59109: EMPTY
59110: LIST
59111: LIST
59112: PUSH
59113: LD_INT 3
59115: PUSH
59116: LD_INT 24
59118: PUSH
59119: LD_INT 800
59121: PUSH
59122: EMPTY
59123: LIST
59124: LIST
59125: PUSH
59126: EMPTY
59127: LIST
59128: LIST
59129: PUSH
59130: EMPTY
59131: LIST
59132: LIST
59133: LIST
59134: PUSH
59135: EMPTY
59136: LIST
59137: LIST
59138: PPUSH
59139: CALL_OW 72
59143: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59144: LD_ADDR_VAR 0 6
59148: PUSH
59149: LD_EXP 59
59153: PUSH
59154: LD_VAR 0 2
59158: ARRAY
59159: PPUSH
59160: LD_INT 21
59162: PUSH
59163: LD_INT 1
59165: PUSH
59166: EMPTY
59167: LIST
59168: LIST
59169: PUSH
59170: LD_INT 1
59172: PUSH
59173: LD_INT 3
59175: PUSH
59176: LD_INT 54
59178: PUSH
59179: EMPTY
59180: LIST
59181: PUSH
59182: EMPTY
59183: LIST
59184: LIST
59185: PUSH
59186: LD_INT 3
59188: PUSH
59189: LD_INT 24
59191: PUSH
59192: LD_INT 250
59194: PUSH
59195: EMPTY
59196: LIST
59197: LIST
59198: PUSH
59199: EMPTY
59200: LIST
59201: LIST
59202: PUSH
59203: EMPTY
59204: LIST
59205: LIST
59206: LIST
59207: PUSH
59208: EMPTY
59209: LIST
59210: LIST
59211: PPUSH
59212: CALL_OW 72
59216: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59217: LD_ADDR_VAR 0 7
59221: PUSH
59222: LD_VAR 0 5
59226: PUSH
59227: LD_VAR 0 6
59231: DIFF
59232: ST_TO_ADDR
// if not need_heal_1 then
59233: LD_VAR 0 6
59237: NOT
59238: IFFALSE 59271
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59240: LD_ADDR_EXP 62
59244: PUSH
59245: LD_EXP 62
59249: PPUSH
59250: LD_VAR 0 2
59254: PUSH
59255: LD_INT 1
59257: PUSH
59258: EMPTY
59259: LIST
59260: LIST
59261: PPUSH
59262: EMPTY
59263: PPUSH
59264: CALL 19238 0 3
59268: ST_TO_ADDR
59269: GO 59341
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
59271: LD_ADDR_EXP 62
59275: PUSH
59276: LD_EXP 62
59280: PPUSH
59281: LD_VAR 0 2
59285: PUSH
59286: LD_INT 1
59288: PUSH
59289: EMPTY
59290: LIST
59291: LIST
59292: PPUSH
59293: LD_EXP 62
59297: PUSH
59298: LD_VAR 0 2
59302: ARRAY
59303: PUSH
59304: LD_INT 1
59306: ARRAY
59307: PPUSH
59308: LD_INT 3
59310: PUSH
59311: LD_INT 24
59313: PUSH
59314: LD_INT 1000
59316: PUSH
59317: EMPTY
59318: LIST
59319: LIST
59320: PUSH
59321: EMPTY
59322: LIST
59323: LIST
59324: PPUSH
59325: CALL_OW 72
59329: PUSH
59330: LD_VAR 0 6
59334: UNION
59335: PPUSH
59336: CALL 19238 0 3
59340: ST_TO_ADDR
// if not need_heal_2 then
59341: LD_VAR 0 7
59345: NOT
59346: IFFALSE 59379
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
59348: LD_ADDR_EXP 62
59352: PUSH
59353: LD_EXP 62
59357: PPUSH
59358: LD_VAR 0 2
59362: PUSH
59363: LD_INT 2
59365: PUSH
59366: EMPTY
59367: LIST
59368: LIST
59369: PPUSH
59370: EMPTY
59371: PPUSH
59372: CALL 19238 0 3
59376: ST_TO_ADDR
59377: GO 59411
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
59379: LD_ADDR_EXP 62
59383: PUSH
59384: LD_EXP 62
59388: PPUSH
59389: LD_VAR 0 2
59393: PUSH
59394: LD_INT 2
59396: PUSH
59397: EMPTY
59398: LIST
59399: LIST
59400: PPUSH
59401: LD_VAR 0 7
59405: PPUSH
59406: CALL 19238 0 3
59410: ST_TO_ADDR
// if need_heal_2 then
59411: LD_VAR 0 7
59415: IFFALSE 59576
// for j in need_heal_2 do
59417: LD_ADDR_VAR 0 3
59421: PUSH
59422: LD_VAR 0 7
59426: PUSH
59427: FOR_IN
59428: IFFALSE 59574
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
59430: LD_ADDR_VAR 0 5
59434: PUSH
59435: LD_EXP 59
59439: PUSH
59440: LD_VAR 0 2
59444: ARRAY
59445: PPUSH
59446: LD_INT 2
59448: PUSH
59449: LD_INT 30
59451: PUSH
59452: LD_INT 6
59454: PUSH
59455: EMPTY
59456: LIST
59457: LIST
59458: PUSH
59459: LD_INT 30
59461: PUSH
59462: LD_INT 7
59464: PUSH
59465: EMPTY
59466: LIST
59467: LIST
59468: PUSH
59469: LD_INT 30
59471: PUSH
59472: LD_INT 8
59474: PUSH
59475: EMPTY
59476: LIST
59477: LIST
59478: PUSH
59479: LD_INT 30
59481: PUSH
59482: LD_INT 0
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: PUSH
59489: LD_INT 30
59491: PUSH
59492: LD_INT 1
59494: PUSH
59495: EMPTY
59496: LIST
59497: LIST
59498: PUSH
59499: EMPTY
59500: LIST
59501: LIST
59502: LIST
59503: LIST
59504: LIST
59505: LIST
59506: PPUSH
59507: CALL_OW 72
59511: ST_TO_ADDR
// if tmp then
59512: LD_VAR 0 5
59516: IFFALSE 59572
// begin k := NearestUnitToUnit ( tmp , j ) ;
59518: LD_ADDR_VAR 0 4
59522: PUSH
59523: LD_VAR 0 5
59527: PPUSH
59528: LD_VAR 0 3
59532: PPUSH
59533: CALL_OW 74
59537: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
59538: LD_VAR 0 3
59542: PPUSH
59543: LD_VAR 0 4
59547: PPUSH
59548: CALL_OW 296
59552: PUSH
59553: LD_INT 5
59555: GREATER
59556: IFFALSE 59572
// ComMoveUnit ( j , k ) ;
59558: LD_VAR 0 3
59562: PPUSH
59563: LD_VAR 0 4
59567: PPUSH
59568: CALL_OW 112
// end ; end ;
59572: GO 59427
59574: POP
59575: POP
// if not need_heal_1 and not need_heal_2 then
59576: LD_VAR 0 6
59580: NOT
59581: PUSH
59582: LD_VAR 0 7
59586: NOT
59587: AND
59588: IFFALSE 59592
// continue ;
59590: GO 59056
// end ;
59592: GO 59056
59594: POP
59595: POP
// RaiseSailEvent ( 102 ) ;
59596: LD_INT 102
59598: PPUSH
59599: CALL_OW 427
// end ;
59603: LD_VAR 0 1
59607: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
59608: LD_INT 0
59610: PPUSH
59611: PPUSH
59612: PPUSH
59613: PPUSH
59614: PPUSH
59615: PPUSH
59616: PPUSH
59617: PPUSH
// if not mc_bases then
59618: LD_EXP 59
59622: NOT
59623: IFFALSE 59627
// exit ;
59625: GO 60462
// for i = 1 to mc_bases do
59627: LD_ADDR_VAR 0 2
59631: PUSH
59632: DOUBLE
59633: LD_INT 1
59635: DEC
59636: ST_TO_ADDR
59637: LD_EXP 59
59641: PUSH
59642: FOR_TO
59643: IFFALSE 60460
// begin if not mc_building_need_repair [ i ] then
59645: LD_EXP 60
59649: PUSH
59650: LD_VAR 0 2
59654: ARRAY
59655: NOT
59656: IFFALSE 59830
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
59658: LD_ADDR_VAR 0 6
59662: PUSH
59663: LD_EXP 78
59667: PUSH
59668: LD_VAR 0 2
59672: ARRAY
59673: PPUSH
59674: LD_INT 3
59676: PUSH
59677: LD_INT 24
59679: PUSH
59680: LD_INT 1000
59682: PUSH
59683: EMPTY
59684: LIST
59685: LIST
59686: PUSH
59687: EMPTY
59688: LIST
59689: LIST
59690: PUSH
59691: LD_INT 2
59693: PUSH
59694: LD_INT 34
59696: PUSH
59697: LD_INT 13
59699: PUSH
59700: EMPTY
59701: LIST
59702: LIST
59703: PUSH
59704: LD_INT 34
59706: PUSH
59707: LD_INT 52
59709: PUSH
59710: EMPTY
59711: LIST
59712: LIST
59713: PUSH
59714: EMPTY
59715: LIST
59716: LIST
59717: LIST
59718: PUSH
59719: EMPTY
59720: LIST
59721: LIST
59722: PPUSH
59723: CALL_OW 72
59727: ST_TO_ADDR
// if cranes then
59728: LD_VAR 0 6
59732: IFFALSE 59794
// for j in cranes do
59734: LD_ADDR_VAR 0 3
59738: PUSH
59739: LD_VAR 0 6
59743: PUSH
59744: FOR_IN
59745: IFFALSE 59792
// if not IsInArea ( j , mc_parking [ i ] ) then
59747: LD_VAR 0 3
59751: PPUSH
59752: LD_EXP 83
59756: PUSH
59757: LD_VAR 0 2
59761: ARRAY
59762: PPUSH
59763: CALL_OW 308
59767: NOT
59768: IFFALSE 59790
// ComMoveToArea ( j , mc_parking [ i ] ) ;
59770: LD_VAR 0 3
59774: PPUSH
59775: LD_EXP 83
59779: PUSH
59780: LD_VAR 0 2
59784: ARRAY
59785: PPUSH
59786: CALL_OW 113
59790: GO 59744
59792: POP
59793: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59794: LD_ADDR_EXP 61
59798: PUSH
59799: LD_EXP 61
59803: PPUSH
59804: LD_VAR 0 2
59808: PPUSH
59809: EMPTY
59810: PPUSH
59811: CALL_OW 1
59815: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
59816: LD_VAR 0 2
59820: PPUSH
59821: LD_INT 101
59823: PPUSH
59824: CALL 54731 0 2
// continue ;
59828: GO 59642
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
59830: LD_ADDR_EXP 65
59834: PUSH
59835: LD_EXP 65
59839: PPUSH
59840: LD_VAR 0 2
59844: PPUSH
59845: EMPTY
59846: PPUSH
59847: CALL_OW 1
59851: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
59852: LD_VAR 0 2
59856: PPUSH
59857: LD_INT 103
59859: PPUSH
59860: CALL 54731 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
59864: LD_ADDR_VAR 0 5
59868: PUSH
59869: LD_EXP 59
59873: PUSH
59874: LD_VAR 0 2
59878: ARRAY
59879: PUSH
59880: LD_EXP 88
59884: PUSH
59885: LD_VAR 0 2
59889: ARRAY
59890: UNION
59891: PPUSH
59892: LD_INT 2
59894: PUSH
59895: LD_INT 25
59897: PUSH
59898: LD_INT 2
59900: PUSH
59901: EMPTY
59902: LIST
59903: LIST
59904: PUSH
59905: LD_INT 25
59907: PUSH
59908: LD_INT 16
59910: PUSH
59911: EMPTY
59912: LIST
59913: LIST
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: LIST
59919: PUSH
59920: EMPTY
59921: LIST
59922: PPUSH
59923: CALL_OW 72
59927: PUSH
59928: LD_EXP 62
59932: PUSH
59933: LD_VAR 0 2
59937: ARRAY
59938: PUSH
59939: LD_INT 1
59941: ARRAY
59942: PUSH
59943: LD_EXP 62
59947: PUSH
59948: LD_VAR 0 2
59952: ARRAY
59953: PUSH
59954: LD_INT 2
59956: ARRAY
59957: UNION
59958: DIFF
59959: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
59960: LD_ADDR_VAR 0 6
59964: PUSH
59965: LD_EXP 78
59969: PUSH
59970: LD_VAR 0 2
59974: ARRAY
59975: PPUSH
59976: LD_INT 2
59978: PUSH
59979: LD_INT 34
59981: PUSH
59982: LD_INT 13
59984: PUSH
59985: EMPTY
59986: LIST
59987: LIST
59988: PUSH
59989: LD_INT 34
59991: PUSH
59992: LD_INT 52
59994: PUSH
59995: EMPTY
59996: LIST
59997: LIST
59998: PUSH
59999: EMPTY
60000: LIST
60001: LIST
60002: LIST
60003: PPUSH
60004: CALL_OW 72
60008: ST_TO_ADDR
// if cranes then
60009: LD_VAR 0 6
60013: IFFALSE 60149
// begin for j in cranes do
60015: LD_ADDR_VAR 0 3
60019: PUSH
60020: LD_VAR 0 6
60024: PUSH
60025: FOR_IN
60026: IFFALSE 60147
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
60028: LD_VAR 0 3
60032: PPUSH
60033: CALL_OW 256
60037: PUSH
60038: LD_INT 500
60040: GREATEREQUAL
60041: PUSH
60042: LD_VAR 0 3
60046: PPUSH
60047: CALL_OW 314
60051: NOT
60052: AND
60053: IFFALSE 60087
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60055: LD_VAR 0 3
60059: PPUSH
60060: LD_EXP 60
60064: PUSH
60065: LD_VAR 0 2
60069: ARRAY
60070: PPUSH
60071: LD_VAR 0 3
60075: PPUSH
60076: CALL_OW 74
60080: PPUSH
60081: CALL_OW 130
60085: GO 60145
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60087: LD_VAR 0 3
60091: PPUSH
60092: CALL_OW 256
60096: PUSH
60097: LD_INT 500
60099: LESS
60100: PUSH
60101: LD_VAR 0 3
60105: PPUSH
60106: LD_EXP 83
60110: PUSH
60111: LD_VAR 0 2
60115: ARRAY
60116: PPUSH
60117: CALL_OW 308
60121: NOT
60122: AND
60123: IFFALSE 60145
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60125: LD_VAR 0 3
60129: PPUSH
60130: LD_EXP 83
60134: PUSH
60135: LD_VAR 0 2
60139: ARRAY
60140: PPUSH
60141: CALL_OW 113
60145: GO 60025
60147: POP
60148: POP
// end ; if tmp > 3 then
60149: LD_VAR 0 5
60153: PUSH
60154: LD_INT 3
60156: GREATER
60157: IFFALSE 60177
// tmp := ShrinkArray ( tmp , 4 ) ;
60159: LD_ADDR_VAR 0 5
60163: PUSH
60164: LD_VAR 0 5
60168: PPUSH
60169: LD_INT 4
60171: PPUSH
60172: CALL 50477 0 2
60176: ST_TO_ADDR
// if not tmp then
60177: LD_VAR 0 5
60181: NOT
60182: IFFALSE 60186
// continue ;
60184: GO 59642
// for j in tmp do
60186: LD_ADDR_VAR 0 3
60190: PUSH
60191: LD_VAR 0 5
60195: PUSH
60196: FOR_IN
60197: IFFALSE 60456
// begin if IsInUnit ( j ) then
60199: LD_VAR 0 3
60203: PPUSH
60204: CALL_OW 310
60208: IFFALSE 60219
// ComExitBuilding ( j ) ;
60210: LD_VAR 0 3
60214: PPUSH
60215: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60219: LD_VAR 0 3
60223: PUSH
60224: LD_EXP 61
60228: PUSH
60229: LD_VAR 0 2
60233: ARRAY
60234: IN
60235: NOT
60236: IFFALSE 60294
// begin SetTag ( j , 101 ) ;
60238: LD_VAR 0 3
60242: PPUSH
60243: LD_INT 101
60245: PPUSH
60246: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
60250: LD_ADDR_EXP 61
60254: PUSH
60255: LD_EXP 61
60259: PPUSH
60260: LD_VAR 0 2
60264: PUSH
60265: LD_EXP 61
60269: PUSH
60270: LD_VAR 0 2
60274: ARRAY
60275: PUSH
60276: LD_INT 1
60278: PLUS
60279: PUSH
60280: EMPTY
60281: LIST
60282: LIST
60283: PPUSH
60284: LD_VAR 0 3
60288: PPUSH
60289: CALL 19238 0 3
60293: ST_TO_ADDR
// end ; wait ( 1 ) ;
60294: LD_INT 1
60296: PPUSH
60297: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
60301: LD_ADDR_VAR 0 7
60305: PUSH
60306: LD_EXP 60
60310: PUSH
60311: LD_VAR 0 2
60315: ARRAY
60316: ST_TO_ADDR
// if mc_scan [ i ] then
60317: LD_EXP 82
60321: PUSH
60322: LD_VAR 0 2
60326: ARRAY
60327: IFFALSE 60389
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
60329: LD_ADDR_VAR 0 7
60333: PUSH
60334: LD_EXP 60
60338: PUSH
60339: LD_VAR 0 2
60343: ARRAY
60344: PPUSH
60345: LD_INT 3
60347: PUSH
60348: LD_INT 30
60350: PUSH
60351: LD_INT 32
60353: PUSH
60354: EMPTY
60355: LIST
60356: LIST
60357: PUSH
60358: LD_INT 30
60360: PUSH
60361: LD_INT 33
60363: PUSH
60364: EMPTY
60365: LIST
60366: LIST
60367: PUSH
60368: LD_INT 30
60370: PUSH
60371: LD_INT 31
60373: PUSH
60374: EMPTY
60375: LIST
60376: LIST
60377: PUSH
60378: EMPTY
60379: LIST
60380: LIST
60381: LIST
60382: LIST
60383: PPUSH
60384: CALL_OW 72
60388: ST_TO_ADDR
// if not to_repair_tmp then
60389: LD_VAR 0 7
60393: NOT
60394: IFFALSE 60398
// continue ;
60396: GO 60196
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
60398: LD_ADDR_VAR 0 8
60402: PUSH
60403: LD_VAR 0 7
60407: PPUSH
60408: LD_VAR 0 3
60412: PPUSH
60413: CALL_OW 74
60417: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 5 then
60418: LD_VAR 0 8
60422: PPUSH
60423: LD_INT 16
60425: PPUSH
60426: CALL 21831 0 2
60430: PUSH
60431: LD_INT 4
60433: ARRAY
60434: PUSH
60435: LD_INT 5
60437: LESS
60438: IFFALSE 60454
// ComRepairBuilding ( j , to_repair ) ;
60440: LD_VAR 0 3
60444: PPUSH
60445: LD_VAR 0 8
60449: PPUSH
60450: CALL_OW 130
// end ;
60454: GO 60196
60456: POP
60457: POP
// end ;
60458: GO 59642
60460: POP
60461: POP
// end ;
60462: LD_VAR 0 1
60466: RET
// export function MC_Heal ; var i , j , tmp ; begin
60467: LD_INT 0
60469: PPUSH
60470: PPUSH
60471: PPUSH
60472: PPUSH
// if not mc_bases then
60473: LD_EXP 59
60477: NOT
60478: IFFALSE 60482
// exit ;
60480: GO 60884
// for i = 1 to mc_bases do
60482: LD_ADDR_VAR 0 2
60486: PUSH
60487: DOUBLE
60488: LD_INT 1
60490: DEC
60491: ST_TO_ADDR
60492: LD_EXP 59
60496: PUSH
60497: FOR_TO
60498: IFFALSE 60882
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
60500: LD_EXP 62
60504: PUSH
60505: LD_VAR 0 2
60509: ARRAY
60510: PUSH
60511: LD_INT 1
60513: ARRAY
60514: NOT
60515: PUSH
60516: LD_EXP 62
60520: PUSH
60521: LD_VAR 0 2
60525: ARRAY
60526: PUSH
60527: LD_INT 2
60529: ARRAY
60530: NOT
60531: AND
60532: IFFALSE 60570
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
60534: LD_ADDR_EXP 63
60538: PUSH
60539: LD_EXP 63
60543: PPUSH
60544: LD_VAR 0 2
60548: PPUSH
60549: EMPTY
60550: PPUSH
60551: CALL_OW 1
60555: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
60556: LD_VAR 0 2
60560: PPUSH
60561: LD_INT 102
60563: PPUSH
60564: CALL 54731 0 2
// continue ;
60568: GO 60497
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
60570: LD_ADDR_VAR 0 4
60574: PUSH
60575: LD_EXP 59
60579: PUSH
60580: LD_VAR 0 2
60584: ARRAY
60585: PPUSH
60586: LD_INT 25
60588: PUSH
60589: LD_INT 4
60591: PUSH
60592: EMPTY
60593: LIST
60594: LIST
60595: PPUSH
60596: CALL_OW 72
60600: ST_TO_ADDR
// if not tmp then
60601: LD_VAR 0 4
60605: NOT
60606: IFFALSE 60610
// continue ;
60608: GO 60497
// if mc_taming [ i ] then
60610: LD_EXP 90
60614: PUSH
60615: LD_VAR 0 2
60619: ARRAY
60620: IFFALSE 60644
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60622: LD_ADDR_EXP 90
60626: PUSH
60627: LD_EXP 90
60631: PPUSH
60632: LD_VAR 0 2
60636: PPUSH
60637: EMPTY
60638: PPUSH
60639: CALL_OW 1
60643: ST_TO_ADDR
// for j in tmp do
60644: LD_ADDR_VAR 0 3
60648: PUSH
60649: LD_VAR 0 4
60653: PUSH
60654: FOR_IN
60655: IFFALSE 60878
// begin if IsInUnit ( j ) then
60657: LD_VAR 0 3
60661: PPUSH
60662: CALL_OW 310
60666: IFFALSE 60677
// ComExitBuilding ( j ) ;
60668: LD_VAR 0 3
60672: PPUSH
60673: CALL_OW 122
// if not j in mc_healers [ i ] then
60677: LD_VAR 0 3
60681: PUSH
60682: LD_EXP 63
60686: PUSH
60687: LD_VAR 0 2
60691: ARRAY
60692: IN
60693: NOT
60694: IFFALSE 60740
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
60696: LD_ADDR_EXP 63
60700: PUSH
60701: LD_EXP 63
60705: PPUSH
60706: LD_VAR 0 2
60710: PUSH
60711: LD_EXP 63
60715: PUSH
60716: LD_VAR 0 2
60720: ARRAY
60721: PUSH
60722: LD_INT 1
60724: PLUS
60725: PUSH
60726: EMPTY
60727: LIST
60728: LIST
60729: PPUSH
60730: LD_VAR 0 3
60734: PPUSH
60735: CALL 19238 0 3
60739: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
60740: LD_VAR 0 3
60744: PPUSH
60745: CALL_OW 110
60749: PUSH
60750: LD_INT 102
60752: NONEQUAL
60753: IFFALSE 60767
// SetTag ( j , 102 ) ;
60755: LD_VAR 0 3
60759: PPUSH
60760: LD_INT 102
60762: PPUSH
60763: CALL_OW 109
// Wait ( 3 ) ;
60767: LD_INT 3
60769: PPUSH
60770: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
60774: LD_EXP 62
60778: PUSH
60779: LD_VAR 0 2
60783: ARRAY
60784: PUSH
60785: LD_INT 1
60787: ARRAY
60788: IFFALSE 60820
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
60790: LD_VAR 0 3
60794: PPUSH
60795: LD_EXP 62
60799: PUSH
60800: LD_VAR 0 2
60804: ARRAY
60805: PUSH
60806: LD_INT 1
60808: ARRAY
60809: PUSH
60810: LD_INT 1
60812: ARRAY
60813: PPUSH
60814: CALL_OW 128
60818: GO 60876
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
60820: LD_VAR 0 3
60824: PPUSH
60825: CALL_OW 314
60829: NOT
60830: PUSH
60831: LD_EXP 62
60835: PUSH
60836: LD_VAR 0 2
60840: ARRAY
60841: PUSH
60842: LD_INT 2
60844: ARRAY
60845: AND
60846: IFFALSE 60876
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
60848: LD_VAR 0 3
60852: PPUSH
60853: LD_EXP 62
60857: PUSH
60858: LD_VAR 0 2
60862: ARRAY
60863: PUSH
60864: LD_INT 2
60866: ARRAY
60867: PUSH
60868: LD_INT 1
60870: ARRAY
60871: PPUSH
60872: CALL_OW 128
// end ;
60876: GO 60654
60878: POP
60879: POP
// end ;
60880: GO 60497
60882: POP
60883: POP
// end ;
60884: LD_VAR 0 1
60888: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
60889: LD_INT 0
60891: PPUSH
60892: PPUSH
60893: PPUSH
60894: PPUSH
60895: PPUSH
// if not mc_bases then
60896: LD_EXP 59
60900: NOT
60901: IFFALSE 60905
// exit ;
60903: GO 62048
// for i = 1 to mc_bases do
60905: LD_ADDR_VAR 0 2
60909: PUSH
60910: DOUBLE
60911: LD_INT 1
60913: DEC
60914: ST_TO_ADDR
60915: LD_EXP 59
60919: PUSH
60920: FOR_TO
60921: IFFALSE 62046
// begin if mc_scan [ i ] then
60923: LD_EXP 82
60927: PUSH
60928: LD_VAR 0 2
60932: ARRAY
60933: IFFALSE 60937
// continue ;
60935: GO 60920
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
60937: LD_EXP 64
60941: PUSH
60942: LD_VAR 0 2
60946: ARRAY
60947: NOT
60948: PUSH
60949: LD_EXP 66
60953: PUSH
60954: LD_VAR 0 2
60958: ARRAY
60959: NOT
60960: AND
60961: PUSH
60962: LD_EXP 65
60966: PUSH
60967: LD_VAR 0 2
60971: ARRAY
60972: AND
60973: IFFALSE 61011
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
60975: LD_ADDR_EXP 65
60979: PUSH
60980: LD_EXP 65
60984: PPUSH
60985: LD_VAR 0 2
60989: PPUSH
60990: EMPTY
60991: PPUSH
60992: CALL_OW 1
60996: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60997: LD_VAR 0 2
61001: PPUSH
61002: LD_INT 103
61004: PPUSH
61005: CALL 54731 0 2
// continue ;
61009: GO 60920
// end ; if mc_construct_list [ i ] then
61011: LD_EXP 66
61015: PUSH
61016: LD_VAR 0 2
61020: ARRAY
61021: IFFALSE 61241
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61023: LD_ADDR_VAR 0 4
61027: PUSH
61028: LD_EXP 59
61032: PUSH
61033: LD_VAR 0 2
61037: ARRAY
61038: PPUSH
61039: LD_INT 25
61041: PUSH
61042: LD_INT 2
61044: PUSH
61045: EMPTY
61046: LIST
61047: LIST
61048: PPUSH
61049: CALL_OW 72
61053: PUSH
61054: LD_EXP 61
61058: PUSH
61059: LD_VAR 0 2
61063: ARRAY
61064: DIFF
61065: ST_TO_ADDR
// if not tmp then
61066: LD_VAR 0 4
61070: NOT
61071: IFFALSE 61075
// continue ;
61073: GO 60920
// for j in tmp do
61075: LD_ADDR_VAR 0 3
61079: PUSH
61080: LD_VAR 0 4
61084: PUSH
61085: FOR_IN
61086: IFFALSE 61237
// begin if not mc_builders [ i ] then
61088: LD_EXP 65
61092: PUSH
61093: LD_VAR 0 2
61097: ARRAY
61098: NOT
61099: IFFALSE 61157
// begin SetTag ( j , 103 ) ;
61101: LD_VAR 0 3
61105: PPUSH
61106: LD_INT 103
61108: PPUSH
61109: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61113: LD_ADDR_EXP 65
61117: PUSH
61118: LD_EXP 65
61122: PPUSH
61123: LD_VAR 0 2
61127: PUSH
61128: LD_EXP 65
61132: PUSH
61133: LD_VAR 0 2
61137: ARRAY
61138: PUSH
61139: LD_INT 1
61141: PLUS
61142: PUSH
61143: EMPTY
61144: LIST
61145: LIST
61146: PPUSH
61147: LD_VAR 0 3
61151: PPUSH
61152: CALL 19238 0 3
61156: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61157: LD_VAR 0 3
61161: PPUSH
61162: CALL_OW 310
61166: IFFALSE 61177
// ComExitBuilding ( j ) ;
61168: LD_VAR 0 3
61172: PPUSH
61173: CALL_OW 122
// wait ( 3 ) ;
61177: LD_INT 3
61179: PPUSH
61180: CALL_OW 67
// if not mc_construct_list [ i ] then
61184: LD_EXP 66
61188: PUSH
61189: LD_VAR 0 2
61193: ARRAY
61194: NOT
61195: IFFALSE 61199
// break ;
61197: GO 61237
// if not HasTask ( j ) then
61199: LD_VAR 0 3
61203: PPUSH
61204: CALL_OW 314
61208: NOT
61209: IFFALSE 61235
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61211: LD_VAR 0 3
61215: PPUSH
61216: LD_EXP 66
61220: PUSH
61221: LD_VAR 0 2
61225: ARRAY
61226: PUSH
61227: LD_INT 1
61229: ARRAY
61230: PPUSH
61231: CALL 22089 0 2
// end ;
61235: GO 61085
61237: POP
61238: POP
// end else
61239: GO 62044
// if mc_build_list [ i ] then
61241: LD_EXP 64
61245: PUSH
61246: LD_VAR 0 2
61250: ARRAY
61251: IFFALSE 62044
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
61253: LD_ADDR_VAR 0 5
61257: PUSH
61258: LD_EXP 59
61262: PUSH
61263: LD_VAR 0 2
61267: ARRAY
61268: PPUSH
61269: LD_INT 2
61271: PUSH
61272: LD_INT 30
61274: PUSH
61275: LD_INT 0
61277: PUSH
61278: EMPTY
61279: LIST
61280: LIST
61281: PUSH
61282: LD_INT 30
61284: PUSH
61285: LD_INT 1
61287: PUSH
61288: EMPTY
61289: LIST
61290: LIST
61291: PUSH
61292: EMPTY
61293: LIST
61294: LIST
61295: LIST
61296: PPUSH
61297: CALL_OW 72
61301: ST_TO_ADDR
// if depot then
61302: LD_VAR 0 5
61306: IFFALSE 61324
// depot := depot [ 1 ] else
61308: LD_ADDR_VAR 0 5
61312: PUSH
61313: LD_VAR 0 5
61317: PUSH
61318: LD_INT 1
61320: ARRAY
61321: ST_TO_ADDR
61322: GO 61332
// depot := 0 ;
61324: LD_ADDR_VAR 0 5
61328: PUSH
61329: LD_INT 0
61331: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
61332: LD_EXP 64
61336: PUSH
61337: LD_VAR 0 2
61341: ARRAY
61342: PUSH
61343: LD_INT 1
61345: ARRAY
61346: PUSH
61347: LD_INT 1
61349: ARRAY
61350: PPUSH
61351: CALL 21919 0 1
61355: PUSH
61356: LD_EXP 59
61360: PUSH
61361: LD_VAR 0 2
61365: ARRAY
61366: PPUSH
61367: LD_INT 2
61369: PUSH
61370: LD_INT 30
61372: PUSH
61373: LD_INT 2
61375: PUSH
61376: EMPTY
61377: LIST
61378: LIST
61379: PUSH
61380: LD_INT 30
61382: PUSH
61383: LD_INT 3
61385: PUSH
61386: EMPTY
61387: LIST
61388: LIST
61389: PUSH
61390: EMPTY
61391: LIST
61392: LIST
61393: LIST
61394: PPUSH
61395: CALL_OW 72
61399: NOT
61400: AND
61401: IFFALSE 61506
// begin for j = 1 to mc_build_list [ i ] do
61403: LD_ADDR_VAR 0 3
61407: PUSH
61408: DOUBLE
61409: LD_INT 1
61411: DEC
61412: ST_TO_ADDR
61413: LD_EXP 64
61417: PUSH
61418: LD_VAR 0 2
61422: ARRAY
61423: PUSH
61424: FOR_TO
61425: IFFALSE 61504
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
61427: LD_EXP 64
61431: PUSH
61432: LD_VAR 0 2
61436: ARRAY
61437: PUSH
61438: LD_VAR 0 3
61442: ARRAY
61443: PUSH
61444: LD_INT 1
61446: ARRAY
61447: PUSH
61448: LD_INT 2
61450: EQUAL
61451: IFFALSE 61502
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
61453: LD_ADDR_EXP 64
61457: PUSH
61458: LD_EXP 64
61462: PPUSH
61463: LD_VAR 0 2
61467: PPUSH
61468: LD_EXP 64
61472: PUSH
61473: LD_VAR 0 2
61477: ARRAY
61478: PPUSH
61479: LD_VAR 0 3
61483: PPUSH
61484: LD_INT 1
61486: PPUSH
61487: LD_INT 0
61489: PPUSH
61490: CALL 18656 0 4
61494: PPUSH
61495: CALL_OW 1
61499: ST_TO_ADDR
// break ;
61500: GO 61504
// end ;
61502: GO 61424
61504: POP
61505: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
61506: LD_EXP 64
61510: PUSH
61511: LD_VAR 0 2
61515: ARRAY
61516: PUSH
61517: LD_INT 1
61519: ARRAY
61520: PUSH
61521: LD_INT 1
61523: ARRAY
61524: PUSH
61525: LD_INT 0
61527: EQUAL
61528: PUSH
61529: LD_VAR 0 5
61533: PUSH
61534: LD_VAR 0 5
61538: PPUSH
61539: LD_EXP 64
61543: PUSH
61544: LD_VAR 0 2
61548: ARRAY
61549: PUSH
61550: LD_INT 1
61552: ARRAY
61553: PUSH
61554: LD_INT 1
61556: ARRAY
61557: PPUSH
61558: LD_EXP 64
61562: PUSH
61563: LD_VAR 0 2
61567: ARRAY
61568: PUSH
61569: LD_INT 1
61571: ARRAY
61572: PUSH
61573: LD_INT 2
61575: ARRAY
61576: PPUSH
61577: LD_EXP 64
61581: PUSH
61582: LD_VAR 0 2
61586: ARRAY
61587: PUSH
61588: LD_INT 1
61590: ARRAY
61591: PUSH
61592: LD_INT 3
61594: ARRAY
61595: PPUSH
61596: LD_EXP 64
61600: PUSH
61601: LD_VAR 0 2
61605: ARRAY
61606: PUSH
61607: LD_INT 1
61609: ARRAY
61610: PUSH
61611: LD_INT 4
61613: ARRAY
61614: PPUSH
61615: CALL 26653 0 5
61619: AND
61620: OR
61621: IFFALSE 61902
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61623: LD_ADDR_VAR 0 4
61627: PUSH
61628: LD_EXP 59
61632: PUSH
61633: LD_VAR 0 2
61637: ARRAY
61638: PPUSH
61639: LD_INT 25
61641: PUSH
61642: LD_INT 2
61644: PUSH
61645: EMPTY
61646: LIST
61647: LIST
61648: PPUSH
61649: CALL_OW 72
61653: PUSH
61654: LD_EXP 61
61658: PUSH
61659: LD_VAR 0 2
61663: ARRAY
61664: DIFF
61665: ST_TO_ADDR
// if not tmp then
61666: LD_VAR 0 4
61670: NOT
61671: IFFALSE 61675
// continue ;
61673: GO 60920
// for j in tmp do
61675: LD_ADDR_VAR 0 3
61679: PUSH
61680: LD_VAR 0 4
61684: PUSH
61685: FOR_IN
61686: IFFALSE 61898
// begin if not mc_builders [ i ] then
61688: LD_EXP 65
61692: PUSH
61693: LD_VAR 0 2
61697: ARRAY
61698: NOT
61699: IFFALSE 61757
// begin SetTag ( j , 103 ) ;
61701: LD_VAR 0 3
61705: PPUSH
61706: LD_INT 103
61708: PPUSH
61709: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61713: LD_ADDR_EXP 65
61717: PUSH
61718: LD_EXP 65
61722: PPUSH
61723: LD_VAR 0 2
61727: PUSH
61728: LD_EXP 65
61732: PUSH
61733: LD_VAR 0 2
61737: ARRAY
61738: PUSH
61739: LD_INT 1
61741: PLUS
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PPUSH
61747: LD_VAR 0 3
61751: PPUSH
61752: CALL 19238 0 3
61756: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61757: LD_VAR 0 3
61761: PPUSH
61762: CALL_OW 310
61766: IFFALSE 61777
// ComExitBuilding ( j ) ;
61768: LD_VAR 0 3
61772: PPUSH
61773: CALL_OW 122
// wait ( 3 ) ;
61777: LD_INT 3
61779: PPUSH
61780: CALL_OW 67
// if not mc_build_list [ i ] then
61784: LD_EXP 64
61788: PUSH
61789: LD_VAR 0 2
61793: ARRAY
61794: NOT
61795: IFFALSE 61799
// break ;
61797: GO 61898
// if not HasTask ( j ) then
61799: LD_VAR 0 3
61803: PPUSH
61804: CALL_OW 314
61808: NOT
61809: IFFALSE 61896
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
61811: LD_VAR 0 3
61815: PPUSH
61816: LD_EXP 64
61820: PUSH
61821: LD_VAR 0 2
61825: ARRAY
61826: PUSH
61827: LD_INT 1
61829: ARRAY
61830: PUSH
61831: LD_INT 1
61833: ARRAY
61834: PPUSH
61835: LD_EXP 64
61839: PUSH
61840: LD_VAR 0 2
61844: ARRAY
61845: PUSH
61846: LD_INT 1
61848: ARRAY
61849: PUSH
61850: LD_INT 2
61852: ARRAY
61853: PPUSH
61854: LD_EXP 64
61858: PUSH
61859: LD_VAR 0 2
61863: ARRAY
61864: PUSH
61865: LD_INT 1
61867: ARRAY
61868: PUSH
61869: LD_INT 3
61871: ARRAY
61872: PPUSH
61873: LD_EXP 64
61877: PUSH
61878: LD_VAR 0 2
61882: ARRAY
61883: PUSH
61884: LD_INT 1
61886: ARRAY
61887: PUSH
61888: LD_INT 4
61890: ARRAY
61891: PPUSH
61892: CALL_OW 145
// end ;
61896: GO 61685
61898: POP
61899: POP
// end else
61900: GO 62044
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
61902: LD_EXP 59
61906: PUSH
61907: LD_VAR 0 2
61911: ARRAY
61912: PPUSH
61913: LD_EXP 64
61917: PUSH
61918: LD_VAR 0 2
61922: ARRAY
61923: PUSH
61924: LD_INT 1
61926: ARRAY
61927: PUSH
61928: LD_INT 1
61930: ARRAY
61931: PPUSH
61932: LD_EXP 64
61936: PUSH
61937: LD_VAR 0 2
61941: ARRAY
61942: PUSH
61943: LD_INT 1
61945: ARRAY
61946: PUSH
61947: LD_INT 2
61949: ARRAY
61950: PPUSH
61951: LD_EXP 64
61955: PUSH
61956: LD_VAR 0 2
61960: ARRAY
61961: PUSH
61962: LD_INT 1
61964: ARRAY
61965: PUSH
61966: LD_INT 3
61968: ARRAY
61969: PPUSH
61970: LD_EXP 64
61974: PUSH
61975: LD_VAR 0 2
61979: ARRAY
61980: PUSH
61981: LD_INT 1
61983: ARRAY
61984: PUSH
61985: LD_INT 4
61987: ARRAY
61988: PPUSH
61989: CALL 25989 0 5
61993: NOT
61994: IFFALSE 62044
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
61996: LD_ADDR_EXP 64
62000: PUSH
62001: LD_EXP 64
62005: PPUSH
62006: LD_VAR 0 2
62010: PPUSH
62011: LD_EXP 64
62015: PUSH
62016: LD_VAR 0 2
62020: ARRAY
62021: PPUSH
62022: LD_INT 1
62024: PPUSH
62025: LD_INT 1
62027: NEG
62028: PPUSH
62029: LD_INT 0
62031: PPUSH
62032: CALL 18656 0 4
62036: PPUSH
62037: CALL_OW 1
62041: ST_TO_ADDR
// continue ;
62042: GO 60920
// end ; end ; end ;
62044: GO 60920
62046: POP
62047: POP
// end ;
62048: LD_VAR 0 1
62052: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62053: LD_INT 0
62055: PPUSH
62056: PPUSH
62057: PPUSH
62058: PPUSH
62059: PPUSH
62060: PPUSH
// if not mc_bases then
62061: LD_EXP 59
62065: NOT
62066: IFFALSE 62070
// exit ;
62068: GO 62497
// for i = 1 to mc_bases do
62070: LD_ADDR_VAR 0 2
62074: PUSH
62075: DOUBLE
62076: LD_INT 1
62078: DEC
62079: ST_TO_ADDR
62080: LD_EXP 59
62084: PUSH
62085: FOR_TO
62086: IFFALSE 62495
// begin tmp := mc_build_upgrade [ i ] ;
62088: LD_ADDR_VAR 0 4
62092: PUSH
62093: LD_EXP 91
62097: PUSH
62098: LD_VAR 0 2
62102: ARRAY
62103: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62104: LD_ADDR_VAR 0 6
62108: PUSH
62109: LD_EXP 92
62113: PUSH
62114: LD_VAR 0 2
62118: ARRAY
62119: PPUSH
62120: LD_INT 2
62122: PUSH
62123: LD_INT 30
62125: PUSH
62126: LD_INT 6
62128: PUSH
62129: EMPTY
62130: LIST
62131: LIST
62132: PUSH
62133: LD_INT 30
62135: PUSH
62136: LD_INT 7
62138: PUSH
62139: EMPTY
62140: LIST
62141: LIST
62142: PUSH
62143: EMPTY
62144: LIST
62145: LIST
62146: LIST
62147: PPUSH
62148: CALL_OW 72
62152: ST_TO_ADDR
// if not tmp and not lab then
62153: LD_VAR 0 4
62157: NOT
62158: PUSH
62159: LD_VAR 0 6
62163: NOT
62164: AND
62165: IFFALSE 62169
// continue ;
62167: GO 62085
// if tmp then
62169: LD_VAR 0 4
62173: IFFALSE 62293
// for j in tmp do
62175: LD_ADDR_VAR 0 3
62179: PUSH
62180: LD_VAR 0 4
62184: PUSH
62185: FOR_IN
62186: IFFALSE 62291
// begin if UpgradeCost ( j ) then
62188: LD_VAR 0 3
62192: PPUSH
62193: CALL 25649 0 1
62197: IFFALSE 62289
// begin ComUpgrade ( j ) ;
62199: LD_VAR 0 3
62203: PPUSH
62204: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62208: LD_ADDR_EXP 91
62212: PUSH
62213: LD_EXP 91
62217: PPUSH
62218: LD_VAR 0 2
62222: PPUSH
62223: LD_EXP 91
62227: PUSH
62228: LD_VAR 0 2
62232: ARRAY
62233: PUSH
62234: LD_VAR 0 3
62238: DIFF
62239: PPUSH
62240: CALL_OW 1
62244: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62245: LD_ADDR_EXP 66
62249: PUSH
62250: LD_EXP 66
62254: PPUSH
62255: LD_VAR 0 2
62259: PUSH
62260: LD_EXP 66
62264: PUSH
62265: LD_VAR 0 2
62269: ARRAY
62270: PUSH
62271: LD_INT 1
62273: PLUS
62274: PUSH
62275: EMPTY
62276: LIST
62277: LIST
62278: PPUSH
62279: LD_VAR 0 3
62283: PPUSH
62284: CALL 19238 0 3
62288: ST_TO_ADDR
// end ; end ;
62289: GO 62185
62291: POP
62292: POP
// if not lab or not mc_lab_upgrade [ i ] then
62293: LD_VAR 0 6
62297: NOT
62298: PUSH
62299: LD_EXP 93
62303: PUSH
62304: LD_VAR 0 2
62308: ARRAY
62309: NOT
62310: OR
62311: IFFALSE 62315
// continue ;
62313: GO 62085
// for j in lab do
62315: LD_ADDR_VAR 0 3
62319: PUSH
62320: LD_VAR 0 6
62324: PUSH
62325: FOR_IN
62326: IFFALSE 62491
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
62328: LD_VAR 0 3
62332: PPUSH
62333: CALL_OW 266
62337: PUSH
62338: LD_INT 6
62340: PUSH
62341: LD_INT 7
62343: PUSH
62344: EMPTY
62345: LIST
62346: LIST
62347: IN
62348: PUSH
62349: LD_VAR 0 3
62353: PPUSH
62354: CALL_OW 461
62358: PUSH
62359: LD_INT 1
62361: NONEQUAL
62362: AND
62363: IFFALSE 62489
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
62365: LD_VAR 0 3
62369: PPUSH
62370: LD_EXP 93
62374: PUSH
62375: LD_VAR 0 2
62379: ARRAY
62380: PUSH
62381: LD_INT 1
62383: ARRAY
62384: PPUSH
62385: CALL 25854 0 2
62389: IFFALSE 62489
// begin ComCancel ( j ) ;
62391: LD_VAR 0 3
62395: PPUSH
62396: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
62400: LD_VAR 0 3
62404: PPUSH
62405: LD_EXP 93
62409: PUSH
62410: LD_VAR 0 2
62414: ARRAY
62415: PUSH
62416: LD_INT 1
62418: ARRAY
62419: PPUSH
62420: CALL_OW 207
// if not j in mc_construct_list [ i ] then
62424: LD_VAR 0 3
62428: PUSH
62429: LD_EXP 66
62433: PUSH
62434: LD_VAR 0 2
62438: ARRAY
62439: IN
62440: NOT
62441: IFFALSE 62487
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
62443: LD_ADDR_EXP 66
62447: PUSH
62448: LD_EXP 66
62452: PPUSH
62453: LD_VAR 0 2
62457: PUSH
62458: LD_EXP 66
62462: PUSH
62463: LD_VAR 0 2
62467: ARRAY
62468: PUSH
62469: LD_INT 1
62471: PLUS
62472: PUSH
62473: EMPTY
62474: LIST
62475: LIST
62476: PPUSH
62477: LD_VAR 0 3
62481: PPUSH
62482: CALL 19238 0 3
62486: ST_TO_ADDR
// break ;
62487: GO 62491
// end ; end ; end ;
62489: GO 62325
62491: POP
62492: POP
// end ;
62493: GO 62085
62495: POP
62496: POP
// end ;
62497: LD_VAR 0 1
62501: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
62502: LD_INT 0
62504: PPUSH
62505: PPUSH
62506: PPUSH
62507: PPUSH
62508: PPUSH
62509: PPUSH
62510: PPUSH
62511: PPUSH
62512: PPUSH
// if not mc_bases then
62513: LD_EXP 59
62517: NOT
62518: IFFALSE 62522
// exit ;
62520: GO 62927
// for i = 1 to mc_bases do
62522: LD_ADDR_VAR 0 2
62526: PUSH
62527: DOUBLE
62528: LD_INT 1
62530: DEC
62531: ST_TO_ADDR
62532: LD_EXP 59
62536: PUSH
62537: FOR_TO
62538: IFFALSE 62925
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
62540: LD_EXP 67
62544: PUSH
62545: LD_VAR 0 2
62549: ARRAY
62550: NOT
62551: PUSH
62552: LD_EXP 59
62556: PUSH
62557: LD_VAR 0 2
62561: ARRAY
62562: PPUSH
62563: LD_INT 30
62565: PUSH
62566: LD_INT 3
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: PPUSH
62573: CALL_OW 72
62577: NOT
62578: OR
62579: IFFALSE 62583
// continue ;
62581: GO 62537
// busy := false ;
62583: LD_ADDR_VAR 0 8
62587: PUSH
62588: LD_INT 0
62590: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
62591: LD_ADDR_VAR 0 4
62595: PUSH
62596: LD_EXP 59
62600: PUSH
62601: LD_VAR 0 2
62605: ARRAY
62606: PPUSH
62607: LD_INT 30
62609: PUSH
62610: LD_INT 3
62612: PUSH
62613: EMPTY
62614: LIST
62615: LIST
62616: PPUSH
62617: CALL_OW 72
62621: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
62622: LD_ADDR_VAR 0 6
62626: PUSH
62627: LD_EXP 67
62631: PUSH
62632: LD_VAR 0 2
62636: ARRAY
62637: PPUSH
62638: LD_INT 2
62640: PUSH
62641: LD_INT 30
62643: PUSH
62644: LD_INT 32
62646: PUSH
62647: EMPTY
62648: LIST
62649: LIST
62650: PUSH
62651: LD_INT 30
62653: PUSH
62654: LD_INT 33
62656: PUSH
62657: EMPTY
62658: LIST
62659: LIST
62660: PUSH
62661: EMPTY
62662: LIST
62663: LIST
62664: LIST
62665: PPUSH
62666: CALL_OW 72
62670: ST_TO_ADDR
// if not t then
62671: LD_VAR 0 6
62675: NOT
62676: IFFALSE 62680
// continue ;
62678: GO 62537
// for j in tmp do
62680: LD_ADDR_VAR 0 3
62684: PUSH
62685: LD_VAR 0 4
62689: PUSH
62690: FOR_IN
62691: IFFALSE 62721
// if not BuildingStatus ( j ) = bs_idle then
62693: LD_VAR 0 3
62697: PPUSH
62698: CALL_OW 461
62702: PUSH
62703: LD_INT 2
62705: EQUAL
62706: NOT
62707: IFFALSE 62719
// begin busy := true ;
62709: LD_ADDR_VAR 0 8
62713: PUSH
62714: LD_INT 1
62716: ST_TO_ADDR
// break ;
62717: GO 62721
// end ;
62719: GO 62690
62721: POP
62722: POP
// if busy then
62723: LD_VAR 0 8
62727: IFFALSE 62731
// continue ;
62729: GO 62537
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
62731: LD_ADDR_VAR 0 7
62735: PUSH
62736: LD_VAR 0 6
62740: PPUSH
62741: LD_INT 35
62743: PUSH
62744: LD_INT 0
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: PPUSH
62751: CALL_OW 72
62755: ST_TO_ADDR
// if tw then
62756: LD_VAR 0 7
62760: IFFALSE 62837
// begin tw := tw [ 1 ] ;
62762: LD_ADDR_VAR 0 7
62766: PUSH
62767: LD_VAR 0 7
62771: PUSH
62772: LD_INT 1
62774: ARRAY
62775: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
62776: LD_ADDR_VAR 0 9
62780: PUSH
62781: LD_VAR 0 7
62785: PPUSH
62786: LD_EXP 84
62790: PUSH
62791: LD_VAR 0 2
62795: ARRAY
62796: PPUSH
62797: CALL 24208 0 2
62801: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
62802: LD_EXP 98
62806: PUSH
62807: LD_VAR 0 2
62811: ARRAY
62812: IFFALSE 62835
// if not weapon in mc_allowed_tower_weapons [ i ] then
62814: LD_VAR 0 9
62818: PUSH
62819: LD_EXP 98
62823: PUSH
62824: LD_VAR 0 2
62828: ARRAY
62829: IN
62830: NOT
62831: IFFALSE 62835
// continue ;
62833: GO 62537
// end else
62835: GO 62900
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
62837: LD_ADDR_VAR 0 5
62841: PUSH
62842: LD_EXP 67
62846: PUSH
62847: LD_VAR 0 2
62851: ARRAY
62852: PPUSH
62853: LD_VAR 0 4
62857: PPUSH
62858: CALL 49710 0 2
62862: ST_TO_ADDR
// if not tmp2 then
62863: LD_VAR 0 5
62867: NOT
62868: IFFALSE 62872
// continue ;
62870: GO 62537
// tw := tmp2 [ 1 ] ;
62872: LD_ADDR_VAR 0 7
62876: PUSH
62877: LD_VAR 0 5
62881: PUSH
62882: LD_INT 1
62884: ARRAY
62885: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
62886: LD_ADDR_VAR 0 9
62890: PUSH
62891: LD_VAR 0 5
62895: PUSH
62896: LD_INT 2
62898: ARRAY
62899: ST_TO_ADDR
// end ; if not weapon then
62900: LD_VAR 0 9
62904: NOT
62905: IFFALSE 62909
// continue ;
62907: GO 62537
// ComPlaceWeapon ( tw , weapon ) ;
62909: LD_VAR 0 7
62913: PPUSH
62914: LD_VAR 0 9
62918: PPUSH
62919: CALL_OW 148
// end ;
62923: GO 62537
62925: POP
62926: POP
// end ;
62927: LD_VAR 0 1
62931: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
62932: LD_INT 0
62934: PPUSH
62935: PPUSH
62936: PPUSH
62937: PPUSH
62938: PPUSH
62939: PPUSH
// if not mc_bases then
62940: LD_EXP 59
62944: NOT
62945: IFFALSE 62949
// exit ;
62947: GO 63725
// for i = 1 to mc_bases do
62949: LD_ADDR_VAR 0 2
62953: PUSH
62954: DOUBLE
62955: LD_INT 1
62957: DEC
62958: ST_TO_ADDR
62959: LD_EXP 59
62963: PUSH
62964: FOR_TO
62965: IFFALSE 63723
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
62967: LD_EXP 72
62971: PUSH
62972: LD_VAR 0 2
62976: ARRAY
62977: NOT
62978: PUSH
62979: LD_EXP 72
62983: PUSH
62984: LD_VAR 0 2
62988: ARRAY
62989: PUSH
62990: LD_EXP 73
62994: PUSH
62995: LD_VAR 0 2
62999: ARRAY
63000: EQUAL
63001: OR
63002: PUSH
63003: LD_EXP 82
63007: PUSH
63008: LD_VAR 0 2
63012: ARRAY
63013: OR
63014: IFFALSE 63018
// continue ;
63016: GO 62964
// if mc_miners [ i ] then
63018: LD_EXP 73
63022: PUSH
63023: LD_VAR 0 2
63027: ARRAY
63028: IFFALSE 63410
// begin for j = mc_miners [ i ] downto 1 do
63030: LD_ADDR_VAR 0 3
63034: PUSH
63035: DOUBLE
63036: LD_EXP 73
63040: PUSH
63041: LD_VAR 0 2
63045: ARRAY
63046: INC
63047: ST_TO_ADDR
63048: LD_INT 1
63050: PUSH
63051: FOR_DOWNTO
63052: IFFALSE 63408
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63054: LD_EXP 73
63058: PUSH
63059: LD_VAR 0 2
63063: ARRAY
63064: PUSH
63065: LD_VAR 0 3
63069: ARRAY
63070: PPUSH
63071: CALL_OW 301
63075: PUSH
63076: LD_EXP 73
63080: PUSH
63081: LD_VAR 0 2
63085: ARRAY
63086: PUSH
63087: LD_VAR 0 3
63091: ARRAY
63092: PPUSH
63093: CALL_OW 257
63097: PUSH
63098: LD_INT 1
63100: NONEQUAL
63101: OR
63102: IFFALSE 63165
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63104: LD_ADDR_VAR 0 5
63108: PUSH
63109: LD_EXP 73
63113: PUSH
63114: LD_VAR 0 2
63118: ARRAY
63119: PUSH
63120: LD_EXP 73
63124: PUSH
63125: LD_VAR 0 2
63129: ARRAY
63130: PUSH
63131: LD_VAR 0 3
63135: ARRAY
63136: DIFF
63137: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63138: LD_ADDR_EXP 73
63142: PUSH
63143: LD_EXP 73
63147: PPUSH
63148: LD_VAR 0 2
63152: PPUSH
63153: LD_VAR 0 5
63157: PPUSH
63158: CALL_OW 1
63162: ST_TO_ADDR
// continue ;
63163: GO 63051
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63165: LD_EXP 73
63169: PUSH
63170: LD_VAR 0 2
63174: ARRAY
63175: PUSH
63176: LD_VAR 0 3
63180: ARRAY
63181: PPUSH
63182: CALL_OW 257
63186: PUSH
63187: LD_INT 1
63189: EQUAL
63190: PUSH
63191: LD_EXP 73
63195: PUSH
63196: LD_VAR 0 2
63200: ARRAY
63201: PUSH
63202: LD_VAR 0 3
63206: ARRAY
63207: PPUSH
63208: CALL_OW 459
63212: NOT
63213: AND
63214: PUSH
63215: LD_EXP 73
63219: PUSH
63220: LD_VAR 0 2
63224: ARRAY
63225: PUSH
63226: LD_VAR 0 3
63230: ARRAY
63231: PPUSH
63232: CALL_OW 314
63236: NOT
63237: AND
63238: IFFALSE 63406
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63240: LD_EXP 73
63244: PUSH
63245: LD_VAR 0 2
63249: ARRAY
63250: PUSH
63251: LD_VAR 0 3
63255: ARRAY
63256: PPUSH
63257: CALL_OW 310
63261: IFFALSE 63284
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
63263: LD_EXP 73
63267: PUSH
63268: LD_VAR 0 2
63272: ARRAY
63273: PUSH
63274: LD_VAR 0 3
63278: ARRAY
63279: PPUSH
63280: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
63284: LD_EXP 73
63288: PUSH
63289: LD_VAR 0 2
63293: ARRAY
63294: PUSH
63295: LD_VAR 0 3
63299: ARRAY
63300: PPUSH
63301: CALL_OW 314
63305: NOT
63306: IFFALSE 63406
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
63308: LD_EXP 73
63312: PUSH
63313: LD_VAR 0 2
63317: ARRAY
63318: PUSH
63319: LD_VAR 0 3
63323: ARRAY
63324: PPUSH
63325: LD_EXP 72
63329: PUSH
63330: LD_VAR 0 2
63334: ARRAY
63335: PUSH
63336: LD_VAR 0 3
63340: PUSH
63341: LD_EXP 72
63345: PUSH
63346: LD_VAR 0 2
63350: ARRAY
63351: MOD
63352: PUSH
63353: LD_INT 1
63355: PLUS
63356: ARRAY
63357: PUSH
63358: LD_INT 1
63360: ARRAY
63361: PPUSH
63362: LD_EXP 72
63366: PUSH
63367: LD_VAR 0 2
63371: ARRAY
63372: PUSH
63373: LD_VAR 0 3
63377: PUSH
63378: LD_EXP 72
63382: PUSH
63383: LD_VAR 0 2
63387: ARRAY
63388: MOD
63389: PUSH
63390: LD_INT 1
63392: PLUS
63393: ARRAY
63394: PUSH
63395: LD_INT 2
63397: ARRAY
63398: PPUSH
63399: LD_INT 0
63401: PPUSH
63402: CALL_OW 193
// end ; end ;
63406: GO 63051
63408: POP
63409: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
63410: LD_ADDR_VAR 0 5
63414: PUSH
63415: LD_EXP 59
63419: PUSH
63420: LD_VAR 0 2
63424: ARRAY
63425: PPUSH
63426: LD_INT 2
63428: PUSH
63429: LD_INT 30
63431: PUSH
63432: LD_INT 4
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: PUSH
63439: LD_INT 30
63441: PUSH
63442: LD_INT 5
63444: PUSH
63445: EMPTY
63446: LIST
63447: LIST
63448: PUSH
63449: LD_INT 30
63451: PUSH
63452: LD_INT 32
63454: PUSH
63455: EMPTY
63456: LIST
63457: LIST
63458: PUSH
63459: EMPTY
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: PPUSH
63465: CALL_OW 72
63469: ST_TO_ADDR
// if not tmp then
63470: LD_VAR 0 5
63474: NOT
63475: IFFALSE 63479
// continue ;
63477: GO 62964
// list := [ ] ;
63479: LD_ADDR_VAR 0 6
63483: PUSH
63484: EMPTY
63485: ST_TO_ADDR
// for j in tmp do
63486: LD_ADDR_VAR 0 3
63490: PUSH
63491: LD_VAR 0 5
63495: PUSH
63496: FOR_IN
63497: IFFALSE 63566
// begin for k in UnitsInside ( j ) do
63499: LD_ADDR_VAR 0 4
63503: PUSH
63504: LD_VAR 0 3
63508: PPUSH
63509: CALL_OW 313
63513: PUSH
63514: FOR_IN
63515: IFFALSE 63562
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
63517: LD_VAR 0 4
63521: PPUSH
63522: CALL_OW 257
63526: PUSH
63527: LD_INT 1
63529: EQUAL
63530: PUSH
63531: LD_VAR 0 4
63535: PPUSH
63536: CALL_OW 459
63540: NOT
63541: AND
63542: IFFALSE 63560
// list := list ^ k ;
63544: LD_ADDR_VAR 0 6
63548: PUSH
63549: LD_VAR 0 6
63553: PUSH
63554: LD_VAR 0 4
63558: ADD
63559: ST_TO_ADDR
63560: GO 63514
63562: POP
63563: POP
// end ;
63564: GO 63496
63566: POP
63567: POP
// list := list diff mc_miners [ i ] ;
63568: LD_ADDR_VAR 0 6
63572: PUSH
63573: LD_VAR 0 6
63577: PUSH
63578: LD_EXP 73
63582: PUSH
63583: LD_VAR 0 2
63587: ARRAY
63588: DIFF
63589: ST_TO_ADDR
// if not list then
63590: LD_VAR 0 6
63594: NOT
63595: IFFALSE 63599
// continue ;
63597: GO 62964
// k := mc_mines [ i ] - mc_miners [ i ] ;
63599: LD_ADDR_VAR 0 4
63603: PUSH
63604: LD_EXP 72
63608: PUSH
63609: LD_VAR 0 2
63613: ARRAY
63614: PUSH
63615: LD_EXP 73
63619: PUSH
63620: LD_VAR 0 2
63624: ARRAY
63625: MINUS
63626: ST_TO_ADDR
// if k > list then
63627: LD_VAR 0 4
63631: PUSH
63632: LD_VAR 0 6
63636: GREATER
63637: IFFALSE 63649
// k := list ;
63639: LD_ADDR_VAR 0 4
63643: PUSH
63644: LD_VAR 0 6
63648: ST_TO_ADDR
// for j = 1 to k do
63649: LD_ADDR_VAR 0 3
63653: PUSH
63654: DOUBLE
63655: LD_INT 1
63657: DEC
63658: ST_TO_ADDR
63659: LD_VAR 0 4
63663: PUSH
63664: FOR_TO
63665: IFFALSE 63719
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
63667: LD_ADDR_EXP 73
63671: PUSH
63672: LD_EXP 73
63676: PPUSH
63677: LD_VAR 0 2
63681: PUSH
63682: LD_EXP 73
63686: PUSH
63687: LD_VAR 0 2
63691: ARRAY
63692: PUSH
63693: LD_INT 1
63695: PLUS
63696: PUSH
63697: EMPTY
63698: LIST
63699: LIST
63700: PPUSH
63701: LD_VAR 0 6
63705: PUSH
63706: LD_VAR 0 3
63710: ARRAY
63711: PPUSH
63712: CALL 19238 0 3
63716: ST_TO_ADDR
63717: GO 63664
63719: POP
63720: POP
// end ;
63721: GO 62964
63723: POP
63724: POP
// end ;
63725: LD_VAR 0 1
63729: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
63730: LD_INT 0
63732: PPUSH
63733: PPUSH
63734: PPUSH
63735: PPUSH
63736: PPUSH
63737: PPUSH
63738: PPUSH
63739: PPUSH
63740: PPUSH
63741: PPUSH
// if not mc_bases then
63742: LD_EXP 59
63746: NOT
63747: IFFALSE 63751
// exit ;
63749: GO 65501
// for i = 1 to mc_bases do
63751: LD_ADDR_VAR 0 2
63755: PUSH
63756: DOUBLE
63757: LD_INT 1
63759: DEC
63760: ST_TO_ADDR
63761: LD_EXP 59
63765: PUSH
63766: FOR_TO
63767: IFFALSE 65499
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
63769: LD_EXP 59
63773: PUSH
63774: LD_VAR 0 2
63778: ARRAY
63779: NOT
63780: PUSH
63781: LD_EXP 66
63785: PUSH
63786: LD_VAR 0 2
63790: ARRAY
63791: OR
63792: IFFALSE 63796
// continue ;
63794: GO 63766
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
63796: LD_EXP 75
63800: PUSH
63801: LD_VAR 0 2
63805: ARRAY
63806: NOT
63807: PUSH
63808: LD_EXP 76
63812: PUSH
63813: LD_VAR 0 2
63817: ARRAY
63818: AND
63819: IFFALSE 63857
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
63821: LD_ADDR_EXP 76
63825: PUSH
63826: LD_EXP 76
63830: PPUSH
63831: LD_VAR 0 2
63835: PPUSH
63836: EMPTY
63837: PPUSH
63838: CALL_OW 1
63842: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
63843: LD_VAR 0 2
63847: PPUSH
63848: LD_INT 107
63850: PPUSH
63851: CALL 54731 0 2
// continue ;
63855: GO 63766
// end ; target := [ ] ;
63857: LD_ADDR_VAR 0 6
63861: PUSH
63862: EMPTY
63863: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
63864: LD_ADDR_VAR 0 3
63868: PUSH
63869: DOUBLE
63870: LD_EXP 75
63874: PUSH
63875: LD_VAR 0 2
63879: ARRAY
63880: INC
63881: ST_TO_ADDR
63882: LD_INT 1
63884: PUSH
63885: FOR_DOWNTO
63886: IFFALSE 64146
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
63888: LD_EXP 75
63892: PUSH
63893: LD_VAR 0 2
63897: ARRAY
63898: PUSH
63899: LD_VAR 0 3
63903: ARRAY
63904: PUSH
63905: LD_INT 2
63907: ARRAY
63908: PPUSH
63909: LD_EXP 75
63913: PUSH
63914: LD_VAR 0 2
63918: ARRAY
63919: PUSH
63920: LD_VAR 0 3
63924: ARRAY
63925: PUSH
63926: LD_INT 3
63928: ARRAY
63929: PPUSH
63930: CALL_OW 488
63934: PUSH
63935: LD_EXP 75
63939: PUSH
63940: LD_VAR 0 2
63944: ARRAY
63945: PUSH
63946: LD_VAR 0 3
63950: ARRAY
63951: PUSH
63952: LD_INT 2
63954: ARRAY
63955: PPUSH
63956: LD_EXP 75
63960: PUSH
63961: LD_VAR 0 2
63965: ARRAY
63966: PUSH
63967: LD_VAR 0 3
63971: ARRAY
63972: PUSH
63973: LD_INT 3
63975: ARRAY
63976: PPUSH
63977: CALL_OW 284
63981: PUSH
63982: LD_INT 0
63984: EQUAL
63985: AND
63986: IFFALSE 64041
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
63988: LD_ADDR_VAR 0 5
63992: PUSH
63993: LD_EXP 75
63997: PUSH
63998: LD_VAR 0 2
64002: ARRAY
64003: PPUSH
64004: LD_VAR 0 3
64008: PPUSH
64009: CALL_OW 3
64013: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64014: LD_ADDR_EXP 75
64018: PUSH
64019: LD_EXP 75
64023: PPUSH
64024: LD_VAR 0 2
64028: PPUSH
64029: LD_VAR 0 5
64033: PPUSH
64034: CALL_OW 1
64038: ST_TO_ADDR
// continue ;
64039: GO 63885
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64041: LD_EXP 59
64045: PUSH
64046: LD_VAR 0 2
64050: ARRAY
64051: PUSH
64052: LD_INT 1
64054: ARRAY
64055: PPUSH
64056: CALL_OW 255
64060: PPUSH
64061: LD_EXP 75
64065: PUSH
64066: LD_VAR 0 2
64070: ARRAY
64071: PUSH
64072: LD_VAR 0 3
64076: ARRAY
64077: PUSH
64078: LD_INT 2
64080: ARRAY
64081: PPUSH
64082: LD_EXP 75
64086: PUSH
64087: LD_VAR 0 2
64091: ARRAY
64092: PUSH
64093: LD_VAR 0 3
64097: ARRAY
64098: PUSH
64099: LD_INT 3
64101: ARRAY
64102: PPUSH
64103: LD_INT 30
64105: PPUSH
64106: CALL 20134 0 4
64110: PUSH
64111: LD_INT 4
64113: ARRAY
64114: PUSH
64115: LD_INT 0
64117: EQUAL
64118: IFFALSE 64144
// begin target := mc_crates [ i ] [ j ] ;
64120: LD_ADDR_VAR 0 6
64124: PUSH
64125: LD_EXP 75
64129: PUSH
64130: LD_VAR 0 2
64134: ARRAY
64135: PUSH
64136: LD_VAR 0 3
64140: ARRAY
64141: ST_TO_ADDR
// break ;
64142: GO 64146
// end ; end ;
64144: GO 63885
64146: POP
64147: POP
// if not target then
64148: LD_VAR 0 6
64152: NOT
64153: IFFALSE 64157
// continue ;
64155: GO 63766
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64157: LD_ADDR_VAR 0 7
64161: PUSH
64162: LD_EXP 78
64166: PUSH
64167: LD_VAR 0 2
64171: ARRAY
64172: PPUSH
64173: LD_INT 2
64175: PUSH
64176: LD_INT 3
64178: PUSH
64179: LD_INT 58
64181: PUSH
64182: EMPTY
64183: LIST
64184: PUSH
64185: EMPTY
64186: LIST
64187: LIST
64188: PUSH
64189: LD_INT 61
64191: PUSH
64192: EMPTY
64193: LIST
64194: PUSH
64195: LD_INT 33
64197: PUSH
64198: LD_INT 5
64200: PUSH
64201: EMPTY
64202: LIST
64203: LIST
64204: PUSH
64205: LD_INT 33
64207: PUSH
64208: LD_INT 3
64210: PUSH
64211: EMPTY
64212: LIST
64213: LIST
64214: PUSH
64215: EMPTY
64216: LIST
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: PUSH
64222: LD_INT 2
64224: PUSH
64225: LD_INT 34
64227: PUSH
64228: LD_INT 32
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: PUSH
64235: LD_INT 34
64237: PUSH
64238: LD_INT 51
64240: PUSH
64241: EMPTY
64242: LIST
64243: LIST
64244: PUSH
64245: LD_INT 34
64247: PUSH
64248: LD_INT 12
64250: PUSH
64251: EMPTY
64252: LIST
64253: LIST
64254: PUSH
64255: EMPTY
64256: LIST
64257: LIST
64258: LIST
64259: LIST
64260: PUSH
64261: EMPTY
64262: LIST
64263: LIST
64264: PPUSH
64265: CALL_OW 72
64269: ST_TO_ADDR
// if not cargo then
64270: LD_VAR 0 7
64274: NOT
64275: IFFALSE 64918
// begin if mc_crates_collector [ i ] < 5 then
64277: LD_EXP 76
64281: PUSH
64282: LD_VAR 0 2
64286: ARRAY
64287: PUSH
64288: LD_INT 5
64290: LESS
64291: IFFALSE 64657
// begin if mc_ape [ i ] then
64293: LD_EXP 88
64297: PUSH
64298: LD_VAR 0 2
64302: ARRAY
64303: IFFALSE 64350
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
64305: LD_ADDR_VAR 0 5
64309: PUSH
64310: LD_EXP 88
64314: PUSH
64315: LD_VAR 0 2
64319: ARRAY
64320: PPUSH
64321: LD_INT 25
64323: PUSH
64324: LD_INT 16
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 24
64333: PUSH
64334: LD_INT 750
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: EMPTY
64342: LIST
64343: LIST
64344: PPUSH
64345: CALL_OW 72
64349: ST_TO_ADDR
// if not tmp then
64350: LD_VAR 0 5
64354: NOT
64355: IFFALSE 64402
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
64357: LD_ADDR_VAR 0 5
64361: PUSH
64362: LD_EXP 59
64366: PUSH
64367: LD_VAR 0 2
64371: ARRAY
64372: PPUSH
64373: LD_INT 25
64375: PUSH
64376: LD_INT 2
64378: PUSH
64379: EMPTY
64380: LIST
64381: LIST
64382: PUSH
64383: LD_INT 24
64385: PUSH
64386: LD_INT 750
64388: PUSH
64389: EMPTY
64390: LIST
64391: LIST
64392: PUSH
64393: EMPTY
64394: LIST
64395: LIST
64396: PPUSH
64397: CALL_OW 72
64401: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
64402: LD_EXP 88
64406: PUSH
64407: LD_VAR 0 2
64411: ARRAY
64412: PUSH
64413: LD_EXP 59
64417: PUSH
64418: LD_VAR 0 2
64422: ARRAY
64423: PPUSH
64424: LD_INT 25
64426: PUSH
64427: LD_INT 2
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: LD_INT 24
64436: PUSH
64437: LD_INT 750
64439: PUSH
64440: EMPTY
64441: LIST
64442: LIST
64443: PUSH
64444: EMPTY
64445: LIST
64446: LIST
64447: PPUSH
64448: CALL_OW 72
64452: AND
64453: PUSH
64454: LD_VAR 0 5
64458: PUSH
64459: LD_INT 5
64461: LESS
64462: AND
64463: IFFALSE 64545
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
64465: LD_ADDR_VAR 0 3
64469: PUSH
64470: LD_EXP 59
64474: PUSH
64475: LD_VAR 0 2
64479: ARRAY
64480: PPUSH
64481: LD_INT 25
64483: PUSH
64484: LD_INT 2
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: LD_INT 24
64493: PUSH
64494: LD_INT 750
64496: PUSH
64497: EMPTY
64498: LIST
64499: LIST
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PPUSH
64505: CALL_OW 72
64509: PUSH
64510: FOR_IN
64511: IFFALSE 64543
// begin tmp := tmp union j ;
64513: LD_ADDR_VAR 0 5
64517: PUSH
64518: LD_VAR 0 5
64522: PUSH
64523: LD_VAR 0 3
64527: UNION
64528: ST_TO_ADDR
// if tmp >= 5 then
64529: LD_VAR 0 5
64533: PUSH
64534: LD_INT 5
64536: GREATEREQUAL
64537: IFFALSE 64541
// break ;
64539: GO 64543
// end ;
64541: GO 64510
64543: POP
64544: POP
// end ; if not tmp then
64545: LD_VAR 0 5
64549: NOT
64550: IFFALSE 64554
// continue ;
64552: GO 63766
// for j in tmp do
64554: LD_ADDR_VAR 0 3
64558: PUSH
64559: LD_VAR 0 5
64563: PUSH
64564: FOR_IN
64565: IFFALSE 64655
// if not GetTag ( j ) then
64567: LD_VAR 0 3
64571: PPUSH
64572: CALL_OW 110
64576: NOT
64577: IFFALSE 64653
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
64579: LD_ADDR_EXP 76
64583: PUSH
64584: LD_EXP 76
64588: PPUSH
64589: LD_VAR 0 2
64593: PUSH
64594: LD_EXP 76
64598: PUSH
64599: LD_VAR 0 2
64603: ARRAY
64604: PUSH
64605: LD_INT 1
64607: PLUS
64608: PUSH
64609: EMPTY
64610: LIST
64611: LIST
64612: PPUSH
64613: LD_VAR 0 3
64617: PPUSH
64618: CALL 19238 0 3
64622: ST_TO_ADDR
// SetTag ( j , 107 ) ;
64623: LD_VAR 0 3
64627: PPUSH
64628: LD_INT 107
64630: PPUSH
64631: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
64635: LD_EXP 76
64639: PUSH
64640: LD_VAR 0 2
64644: ARRAY
64645: PUSH
64646: LD_INT 5
64648: GREATEREQUAL
64649: IFFALSE 64653
// break ;
64651: GO 64655
// end ;
64653: GO 64564
64655: POP
64656: POP
// end ; if mc_crates_collector [ i ] and target then
64657: LD_EXP 76
64661: PUSH
64662: LD_VAR 0 2
64666: ARRAY
64667: PUSH
64668: LD_VAR 0 6
64672: AND
64673: IFFALSE 64916
// begin if mc_crates_collector [ i ] < target [ 1 ] then
64675: LD_EXP 76
64679: PUSH
64680: LD_VAR 0 2
64684: ARRAY
64685: PUSH
64686: LD_VAR 0 6
64690: PUSH
64691: LD_INT 1
64693: ARRAY
64694: LESS
64695: IFFALSE 64715
// tmp := mc_crates_collector [ i ] else
64697: LD_ADDR_VAR 0 5
64701: PUSH
64702: LD_EXP 76
64706: PUSH
64707: LD_VAR 0 2
64711: ARRAY
64712: ST_TO_ADDR
64713: GO 64729
// tmp := target [ 1 ] ;
64715: LD_ADDR_VAR 0 5
64719: PUSH
64720: LD_VAR 0 6
64724: PUSH
64725: LD_INT 1
64727: ARRAY
64728: ST_TO_ADDR
// k := 0 ;
64729: LD_ADDR_VAR 0 4
64733: PUSH
64734: LD_INT 0
64736: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
64737: LD_ADDR_VAR 0 3
64741: PUSH
64742: LD_EXP 76
64746: PUSH
64747: LD_VAR 0 2
64751: ARRAY
64752: PUSH
64753: FOR_IN
64754: IFFALSE 64914
// begin k := k + 1 ;
64756: LD_ADDR_VAR 0 4
64760: PUSH
64761: LD_VAR 0 4
64765: PUSH
64766: LD_INT 1
64768: PLUS
64769: ST_TO_ADDR
// if k > tmp then
64770: LD_VAR 0 4
64774: PUSH
64775: LD_VAR 0 5
64779: GREATER
64780: IFFALSE 64784
// break ;
64782: GO 64914
// if not GetClass ( j ) in [ 2 , 16 ] then
64784: LD_VAR 0 3
64788: PPUSH
64789: CALL_OW 257
64793: PUSH
64794: LD_INT 2
64796: PUSH
64797: LD_INT 16
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: IN
64804: NOT
64805: IFFALSE 64858
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
64807: LD_ADDR_EXP 76
64811: PUSH
64812: LD_EXP 76
64816: PPUSH
64817: LD_VAR 0 2
64821: PPUSH
64822: LD_EXP 76
64826: PUSH
64827: LD_VAR 0 2
64831: ARRAY
64832: PUSH
64833: LD_VAR 0 3
64837: DIFF
64838: PPUSH
64839: CALL_OW 1
64843: ST_TO_ADDR
// SetTag ( j , 0 ) ;
64844: LD_VAR 0 3
64848: PPUSH
64849: LD_INT 0
64851: PPUSH
64852: CALL_OW 109
// continue ;
64856: GO 64753
// end ; if IsInUnit ( j ) then
64858: LD_VAR 0 3
64862: PPUSH
64863: CALL_OW 310
64867: IFFALSE 64878
// ComExitBuilding ( j ) ;
64869: LD_VAR 0 3
64873: PPUSH
64874: CALL_OW 122
// wait ( 3 ) ;
64878: LD_INT 3
64880: PPUSH
64881: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
64885: LD_VAR 0 3
64889: PPUSH
64890: LD_VAR 0 6
64894: PUSH
64895: LD_INT 2
64897: ARRAY
64898: PPUSH
64899: LD_VAR 0 6
64903: PUSH
64904: LD_INT 3
64906: ARRAY
64907: PPUSH
64908: CALL_OW 117
// end ;
64912: GO 64753
64914: POP
64915: POP
// end ; end else
64916: GO 65497
// begin for j in cargo do
64918: LD_ADDR_VAR 0 3
64922: PUSH
64923: LD_VAR 0 7
64927: PUSH
64928: FOR_IN
64929: IFFALSE 65495
// begin if GetTag ( j ) <> 0 then
64931: LD_VAR 0 3
64935: PPUSH
64936: CALL_OW 110
64940: PUSH
64941: LD_INT 0
64943: NONEQUAL
64944: IFFALSE 64948
// continue ;
64946: GO 64928
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
64948: LD_VAR 0 3
64952: PPUSH
64953: CALL_OW 256
64957: PUSH
64958: LD_INT 1000
64960: LESS
64961: PUSH
64962: LD_VAR 0 3
64966: PPUSH
64967: LD_EXP 83
64971: PUSH
64972: LD_VAR 0 2
64976: ARRAY
64977: PPUSH
64978: CALL_OW 308
64982: NOT
64983: AND
64984: IFFALSE 65006
// ComMoveToArea ( j , mc_parking [ i ] ) ;
64986: LD_VAR 0 3
64990: PPUSH
64991: LD_EXP 83
64995: PUSH
64996: LD_VAR 0 2
65000: ARRAY
65001: PPUSH
65002: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65006: LD_VAR 0 3
65010: PPUSH
65011: CALL_OW 256
65015: PUSH
65016: LD_INT 1000
65018: LESS
65019: PUSH
65020: LD_VAR 0 3
65024: PPUSH
65025: LD_EXP 83
65029: PUSH
65030: LD_VAR 0 2
65034: ARRAY
65035: PPUSH
65036: CALL_OW 308
65040: AND
65041: IFFALSE 65045
// continue ;
65043: GO 64928
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65045: LD_VAR 0 3
65049: PPUSH
65050: CALL_OW 262
65054: PUSH
65055: LD_INT 2
65057: EQUAL
65058: PUSH
65059: LD_VAR 0 3
65063: PPUSH
65064: CALL_OW 261
65068: PUSH
65069: LD_INT 15
65071: LESS
65072: AND
65073: IFFALSE 65077
// continue ;
65075: GO 64928
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65077: LD_VAR 0 3
65081: PPUSH
65082: CALL_OW 262
65086: PUSH
65087: LD_INT 1
65089: EQUAL
65090: PUSH
65091: LD_VAR 0 3
65095: PPUSH
65096: CALL_OW 261
65100: PUSH
65101: LD_INT 10
65103: LESS
65104: AND
65105: IFFALSE 65434
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65107: LD_ADDR_VAR 0 8
65111: PUSH
65112: LD_EXP 59
65116: PUSH
65117: LD_VAR 0 2
65121: ARRAY
65122: PPUSH
65123: LD_INT 2
65125: PUSH
65126: LD_INT 30
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 30
65138: PUSH
65139: LD_INT 1
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: EMPTY
65147: LIST
65148: LIST
65149: LIST
65150: PPUSH
65151: CALL_OW 72
65155: ST_TO_ADDR
// if not depot then
65156: LD_VAR 0 8
65160: NOT
65161: IFFALSE 65165
// continue ;
65163: GO 64928
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65165: LD_VAR 0 3
65169: PPUSH
65170: LD_VAR 0 8
65174: PPUSH
65175: LD_VAR 0 3
65179: PPUSH
65180: CALL_OW 74
65184: PPUSH
65185: CALL_OW 296
65189: PUSH
65190: LD_INT 6
65192: LESS
65193: IFFALSE 65209
// SetFuel ( j , 100 ) else
65195: LD_VAR 0 3
65199: PPUSH
65200: LD_INT 100
65202: PPUSH
65203: CALL_OW 240
65207: GO 65434
// if GetFuel ( j ) = 0 then
65209: LD_VAR 0 3
65213: PPUSH
65214: CALL_OW 261
65218: PUSH
65219: LD_INT 0
65221: EQUAL
65222: IFFALSE 65434
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65224: LD_ADDR_EXP 78
65228: PUSH
65229: LD_EXP 78
65233: PPUSH
65234: LD_VAR 0 2
65238: PPUSH
65239: LD_EXP 78
65243: PUSH
65244: LD_VAR 0 2
65248: ARRAY
65249: PUSH
65250: LD_VAR 0 3
65254: DIFF
65255: PPUSH
65256: CALL_OW 1
65260: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
65261: LD_VAR 0 3
65265: PPUSH
65266: CALL_OW 263
65270: PUSH
65271: LD_INT 1
65273: EQUAL
65274: IFFALSE 65290
// ComExitVehicle ( IsInUnit ( j ) ) ;
65276: LD_VAR 0 3
65280: PPUSH
65281: CALL_OW 310
65285: PPUSH
65286: CALL_OW 121
// if GetControl ( j ) = control_remote then
65290: LD_VAR 0 3
65294: PPUSH
65295: CALL_OW 263
65299: PUSH
65300: LD_INT 2
65302: EQUAL
65303: IFFALSE 65314
// ComUnlink ( j ) ;
65305: LD_VAR 0 3
65309: PPUSH
65310: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
65314: LD_ADDR_VAR 0 9
65318: PUSH
65319: LD_VAR 0 2
65323: PPUSH
65324: LD_INT 3
65326: PPUSH
65327: CALL 74787 0 2
65331: ST_TO_ADDR
// if fac then
65332: LD_VAR 0 9
65336: IFFALSE 65432
// begin for k in fac do
65338: LD_ADDR_VAR 0 4
65342: PUSH
65343: LD_VAR 0 9
65347: PUSH
65348: FOR_IN
65349: IFFALSE 65430
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
65351: LD_ADDR_VAR 0 10
65355: PUSH
65356: LD_VAR 0 9
65360: PPUSH
65361: LD_VAR 0 3
65365: PPUSH
65366: CALL_OW 265
65370: PPUSH
65371: LD_VAR 0 3
65375: PPUSH
65376: CALL_OW 262
65380: PPUSH
65381: LD_VAR 0 3
65385: PPUSH
65386: CALL_OW 263
65390: PPUSH
65391: LD_VAR 0 3
65395: PPUSH
65396: CALL_OW 264
65400: PPUSH
65401: CALL 16770 0 5
65405: ST_TO_ADDR
// if components then
65406: LD_VAR 0 10
65410: IFFALSE 65428
// begin MC_InsertProduceList ( i , components ) ;
65412: LD_VAR 0 2
65416: PPUSH
65417: LD_VAR 0 10
65421: PPUSH
65422: CALL 74332 0 2
// break ;
65426: GO 65430
// end ; end ;
65428: GO 65348
65430: POP
65431: POP
// end ; continue ;
65432: GO 64928
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
65434: LD_VAR 0 3
65438: PPUSH
65439: LD_INT 1
65441: PPUSH
65442: CALL_OW 289
65446: PUSH
65447: LD_INT 100
65449: LESS
65450: PUSH
65451: LD_VAR 0 3
65455: PPUSH
65456: CALL_OW 314
65460: NOT
65461: AND
65462: IFFALSE 65491
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65464: LD_VAR 0 3
65468: PPUSH
65469: LD_VAR 0 6
65473: PUSH
65474: LD_INT 2
65476: ARRAY
65477: PPUSH
65478: LD_VAR 0 6
65482: PUSH
65483: LD_INT 3
65485: ARRAY
65486: PPUSH
65487: CALL_OW 117
// break ;
65491: GO 65495
// end ;
65493: GO 64928
65495: POP
65496: POP
// end ; end ;
65497: GO 63766
65499: POP
65500: POP
// end ;
65501: LD_VAR 0 1
65505: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
65506: LD_INT 0
65508: PPUSH
65509: PPUSH
65510: PPUSH
65511: PPUSH
// if not mc_bases then
65512: LD_EXP 59
65516: NOT
65517: IFFALSE 65521
// exit ;
65519: GO 65682
// for i = 1 to mc_bases do
65521: LD_ADDR_VAR 0 2
65525: PUSH
65526: DOUBLE
65527: LD_INT 1
65529: DEC
65530: ST_TO_ADDR
65531: LD_EXP 59
65535: PUSH
65536: FOR_TO
65537: IFFALSE 65680
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
65539: LD_ADDR_VAR 0 4
65543: PUSH
65544: LD_EXP 78
65548: PUSH
65549: LD_VAR 0 2
65553: ARRAY
65554: PUSH
65555: LD_EXP 81
65559: PUSH
65560: LD_VAR 0 2
65564: ARRAY
65565: UNION
65566: PPUSH
65567: LD_INT 33
65569: PUSH
65570: LD_INT 2
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PPUSH
65577: CALL_OW 72
65581: ST_TO_ADDR
// if tmp then
65582: LD_VAR 0 4
65586: IFFALSE 65678
// for j in tmp do
65588: LD_ADDR_VAR 0 3
65592: PUSH
65593: LD_VAR 0 4
65597: PUSH
65598: FOR_IN
65599: IFFALSE 65676
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
65601: LD_VAR 0 3
65605: PPUSH
65606: CALL_OW 312
65610: NOT
65611: PUSH
65612: LD_VAR 0 3
65616: PPUSH
65617: CALL_OW 256
65621: PUSH
65622: LD_INT 250
65624: GREATEREQUAL
65625: AND
65626: IFFALSE 65639
// Connect ( j ) else
65628: LD_VAR 0 3
65632: PPUSH
65633: CALL 22171 0 1
65637: GO 65674
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
65639: LD_VAR 0 3
65643: PPUSH
65644: CALL_OW 256
65648: PUSH
65649: LD_INT 250
65651: LESS
65652: PUSH
65653: LD_VAR 0 3
65657: PPUSH
65658: CALL_OW 312
65662: AND
65663: IFFALSE 65674
// ComUnlink ( j ) ;
65665: LD_VAR 0 3
65669: PPUSH
65670: CALL_OW 136
65674: GO 65598
65676: POP
65677: POP
// end ;
65678: GO 65536
65680: POP
65681: POP
// end ;
65682: LD_VAR 0 1
65686: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
65687: LD_INT 0
65689: PPUSH
65690: PPUSH
65691: PPUSH
65692: PPUSH
65693: PPUSH
// if not mc_bases then
65694: LD_EXP 59
65698: NOT
65699: IFFALSE 65703
// exit ;
65701: GO 66148
// for i = 1 to mc_bases do
65703: LD_ADDR_VAR 0 2
65707: PUSH
65708: DOUBLE
65709: LD_INT 1
65711: DEC
65712: ST_TO_ADDR
65713: LD_EXP 59
65717: PUSH
65718: FOR_TO
65719: IFFALSE 66146
// begin if not mc_produce [ i ] then
65721: LD_EXP 80
65725: PUSH
65726: LD_VAR 0 2
65730: ARRAY
65731: NOT
65732: IFFALSE 65736
// continue ;
65734: GO 65718
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
65736: LD_ADDR_VAR 0 5
65740: PUSH
65741: LD_EXP 59
65745: PUSH
65746: LD_VAR 0 2
65750: ARRAY
65751: PPUSH
65752: LD_INT 30
65754: PUSH
65755: LD_INT 3
65757: PUSH
65758: EMPTY
65759: LIST
65760: LIST
65761: PPUSH
65762: CALL_OW 72
65766: ST_TO_ADDR
// if not fac then
65767: LD_VAR 0 5
65771: NOT
65772: IFFALSE 65776
// continue ;
65774: GO 65718
// for j in fac do
65776: LD_ADDR_VAR 0 3
65780: PUSH
65781: LD_VAR 0 5
65785: PUSH
65786: FOR_IN
65787: IFFALSE 66142
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
65789: LD_VAR 0 3
65793: PPUSH
65794: CALL_OW 461
65798: PUSH
65799: LD_INT 2
65801: NONEQUAL
65802: PUSH
65803: LD_VAR 0 3
65807: PPUSH
65808: LD_INT 15
65810: PPUSH
65811: CALL 21831 0 2
65815: PUSH
65816: LD_INT 4
65818: ARRAY
65819: OR
65820: IFFALSE 65824
// continue ;
65822: GO 65786
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
65824: LD_VAR 0 3
65828: PPUSH
65829: LD_EXP 80
65833: PUSH
65834: LD_VAR 0 2
65838: ARRAY
65839: PUSH
65840: LD_INT 1
65842: ARRAY
65843: PUSH
65844: LD_INT 1
65846: ARRAY
65847: PPUSH
65848: LD_EXP 80
65852: PUSH
65853: LD_VAR 0 2
65857: ARRAY
65858: PUSH
65859: LD_INT 1
65861: ARRAY
65862: PUSH
65863: LD_INT 2
65865: ARRAY
65866: PPUSH
65867: LD_EXP 80
65871: PUSH
65872: LD_VAR 0 2
65876: ARRAY
65877: PUSH
65878: LD_INT 1
65880: ARRAY
65881: PUSH
65882: LD_INT 3
65884: ARRAY
65885: PPUSH
65886: LD_EXP 80
65890: PUSH
65891: LD_VAR 0 2
65895: ARRAY
65896: PUSH
65897: LD_INT 1
65899: ARRAY
65900: PUSH
65901: LD_INT 4
65903: ARRAY
65904: PPUSH
65905: CALL_OW 448
65909: PUSH
65910: LD_VAR 0 3
65914: PPUSH
65915: LD_EXP 80
65919: PUSH
65920: LD_VAR 0 2
65924: ARRAY
65925: PUSH
65926: LD_INT 1
65928: ARRAY
65929: PUSH
65930: LD_INT 1
65932: ARRAY
65933: PUSH
65934: LD_EXP 80
65938: PUSH
65939: LD_VAR 0 2
65943: ARRAY
65944: PUSH
65945: LD_INT 1
65947: ARRAY
65948: PUSH
65949: LD_INT 2
65951: ARRAY
65952: PUSH
65953: LD_EXP 80
65957: PUSH
65958: LD_VAR 0 2
65962: ARRAY
65963: PUSH
65964: LD_INT 1
65966: ARRAY
65967: PUSH
65968: LD_INT 3
65970: ARRAY
65971: PUSH
65972: LD_EXP 80
65976: PUSH
65977: LD_VAR 0 2
65981: ARRAY
65982: PUSH
65983: LD_INT 1
65985: ARRAY
65986: PUSH
65987: LD_INT 4
65989: ARRAY
65990: PUSH
65991: EMPTY
65992: LIST
65993: LIST
65994: LIST
65995: LIST
65996: PPUSH
65997: CALL 25502 0 2
66001: AND
66002: IFFALSE 66140
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66004: LD_VAR 0 3
66008: PPUSH
66009: LD_EXP 80
66013: PUSH
66014: LD_VAR 0 2
66018: ARRAY
66019: PUSH
66020: LD_INT 1
66022: ARRAY
66023: PUSH
66024: LD_INT 1
66026: ARRAY
66027: PPUSH
66028: LD_EXP 80
66032: PUSH
66033: LD_VAR 0 2
66037: ARRAY
66038: PUSH
66039: LD_INT 1
66041: ARRAY
66042: PUSH
66043: LD_INT 2
66045: ARRAY
66046: PPUSH
66047: LD_EXP 80
66051: PUSH
66052: LD_VAR 0 2
66056: ARRAY
66057: PUSH
66058: LD_INT 1
66060: ARRAY
66061: PUSH
66062: LD_INT 3
66064: ARRAY
66065: PPUSH
66066: LD_EXP 80
66070: PUSH
66071: LD_VAR 0 2
66075: ARRAY
66076: PUSH
66077: LD_INT 1
66079: ARRAY
66080: PUSH
66081: LD_INT 4
66083: ARRAY
66084: PPUSH
66085: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66089: LD_ADDR_VAR 0 4
66093: PUSH
66094: LD_EXP 80
66098: PUSH
66099: LD_VAR 0 2
66103: ARRAY
66104: PPUSH
66105: LD_INT 1
66107: PPUSH
66108: CALL_OW 3
66112: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66113: LD_ADDR_EXP 80
66117: PUSH
66118: LD_EXP 80
66122: PPUSH
66123: LD_VAR 0 2
66127: PPUSH
66128: LD_VAR 0 4
66132: PPUSH
66133: CALL_OW 1
66137: ST_TO_ADDR
// break ;
66138: GO 66142
// end ; end ;
66140: GO 65786
66142: POP
66143: POP
// end ;
66144: GO 65718
66146: POP
66147: POP
// end ;
66148: LD_VAR 0 1
66152: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66153: LD_INT 0
66155: PPUSH
66156: PPUSH
66157: PPUSH
// if not mc_bases then
66158: LD_EXP 59
66162: NOT
66163: IFFALSE 66167
// exit ;
66165: GO 66256
// for i = 1 to mc_bases do
66167: LD_ADDR_VAR 0 2
66171: PUSH
66172: DOUBLE
66173: LD_INT 1
66175: DEC
66176: ST_TO_ADDR
66177: LD_EXP 59
66181: PUSH
66182: FOR_TO
66183: IFFALSE 66254
// begin if mc_attack [ i ] then
66185: LD_EXP 79
66189: PUSH
66190: LD_VAR 0 2
66194: ARRAY
66195: IFFALSE 66252
// begin tmp := mc_attack [ i ] [ 1 ] ;
66197: LD_ADDR_VAR 0 3
66201: PUSH
66202: LD_EXP 79
66206: PUSH
66207: LD_VAR 0 2
66211: ARRAY
66212: PUSH
66213: LD_INT 1
66215: ARRAY
66216: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66217: LD_ADDR_EXP 79
66221: PUSH
66222: LD_EXP 79
66226: PPUSH
66227: LD_VAR 0 2
66231: PPUSH
66232: EMPTY
66233: PPUSH
66234: CALL_OW 1
66238: ST_TO_ADDR
// Attack ( tmp ) ;
66239: LD_VAR 0 3
66243: PPUSH
66244: CALL 95258 0 1
// exit ;
66248: POP
66249: POP
66250: GO 66256
// end ; end ;
66252: GO 66182
66254: POP
66255: POP
// end ;
66256: LD_VAR 0 1
66260: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
66261: LD_INT 0
66263: PPUSH
66264: PPUSH
66265: PPUSH
66266: PPUSH
66267: PPUSH
66268: PPUSH
66269: PPUSH
// if not mc_bases then
66270: LD_EXP 59
66274: NOT
66275: IFFALSE 66279
// exit ;
66277: GO 66861
// for i = 1 to mc_bases do
66279: LD_ADDR_VAR 0 2
66283: PUSH
66284: DOUBLE
66285: LD_INT 1
66287: DEC
66288: ST_TO_ADDR
66289: LD_EXP 59
66293: PUSH
66294: FOR_TO
66295: IFFALSE 66859
// begin if not mc_bases [ i ] then
66297: LD_EXP 59
66301: PUSH
66302: LD_VAR 0 2
66306: ARRAY
66307: NOT
66308: IFFALSE 66312
// continue ;
66310: GO 66294
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
66312: LD_ADDR_VAR 0 7
66316: PUSH
66317: LD_EXP 59
66321: PUSH
66322: LD_VAR 0 2
66326: ARRAY
66327: PUSH
66328: LD_INT 1
66330: ARRAY
66331: PPUSH
66332: CALL 16074 0 1
66336: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
66337: LD_ADDR_EXP 82
66341: PUSH
66342: LD_EXP 82
66346: PPUSH
66347: LD_VAR 0 2
66351: PPUSH
66352: LD_EXP 59
66356: PUSH
66357: LD_VAR 0 2
66361: ARRAY
66362: PUSH
66363: LD_INT 1
66365: ARRAY
66366: PPUSH
66367: CALL_OW 255
66371: PPUSH
66372: LD_EXP 84
66376: PUSH
66377: LD_VAR 0 2
66381: ARRAY
66382: PPUSH
66383: CALL 16039 0 2
66387: PPUSH
66388: CALL_OW 1
66392: ST_TO_ADDR
// if not mc_scan [ i ] then
66393: LD_EXP 82
66397: PUSH
66398: LD_VAR 0 2
66402: ARRAY
66403: NOT
66404: IFFALSE 66559
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66406: LD_ADDR_VAR 0 4
66410: PUSH
66411: LD_EXP 59
66415: PUSH
66416: LD_VAR 0 2
66420: ARRAY
66421: PPUSH
66422: LD_INT 2
66424: PUSH
66425: LD_INT 25
66427: PUSH
66428: LD_INT 5
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: PUSH
66435: LD_INT 25
66437: PUSH
66438: LD_INT 8
66440: PUSH
66441: EMPTY
66442: LIST
66443: LIST
66444: PUSH
66445: LD_INT 25
66447: PUSH
66448: LD_INT 9
66450: PUSH
66451: EMPTY
66452: LIST
66453: LIST
66454: PUSH
66455: EMPTY
66456: LIST
66457: LIST
66458: LIST
66459: LIST
66460: PPUSH
66461: CALL_OW 72
66465: ST_TO_ADDR
// if not tmp then
66466: LD_VAR 0 4
66470: NOT
66471: IFFALSE 66475
// continue ;
66473: GO 66294
// for j in tmp do
66475: LD_ADDR_VAR 0 3
66479: PUSH
66480: LD_VAR 0 4
66484: PUSH
66485: FOR_IN
66486: IFFALSE 66557
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
66488: LD_VAR 0 3
66492: PPUSH
66493: CALL_OW 310
66497: PPUSH
66498: CALL_OW 266
66502: PUSH
66503: LD_INT 5
66505: EQUAL
66506: PUSH
66507: LD_VAR 0 3
66511: PPUSH
66512: CALL_OW 257
66516: PUSH
66517: LD_INT 1
66519: EQUAL
66520: AND
66521: PUSH
66522: LD_VAR 0 3
66526: PPUSH
66527: CALL_OW 459
66531: NOT
66532: AND
66533: PUSH
66534: LD_VAR 0 7
66538: AND
66539: IFFALSE 66555
// ComChangeProfession ( j , class ) ;
66541: LD_VAR 0 3
66545: PPUSH
66546: LD_VAR 0 7
66550: PPUSH
66551: CALL_OW 123
66555: GO 66485
66557: POP
66558: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
66559: LD_EXP 82
66563: PUSH
66564: LD_VAR 0 2
66568: ARRAY
66569: PUSH
66570: LD_EXP 81
66574: PUSH
66575: LD_VAR 0 2
66579: ARRAY
66580: NOT
66581: AND
66582: PUSH
66583: LD_EXP 59
66587: PUSH
66588: LD_VAR 0 2
66592: ARRAY
66593: PPUSH
66594: LD_INT 30
66596: PUSH
66597: LD_INT 32
66599: PUSH
66600: EMPTY
66601: LIST
66602: LIST
66603: PPUSH
66604: CALL_OW 72
66608: NOT
66609: AND
66610: PUSH
66611: LD_EXP 59
66615: PUSH
66616: LD_VAR 0 2
66620: ARRAY
66621: PPUSH
66622: LD_INT 2
66624: PUSH
66625: LD_INT 30
66627: PUSH
66628: LD_INT 4
66630: PUSH
66631: EMPTY
66632: LIST
66633: LIST
66634: PUSH
66635: LD_INT 30
66637: PUSH
66638: LD_INT 5
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: EMPTY
66646: LIST
66647: LIST
66648: LIST
66649: PPUSH
66650: CALL_OW 72
66654: NOT
66655: AND
66656: IFFALSE 66788
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
66658: LD_ADDR_VAR 0 4
66662: PUSH
66663: LD_EXP 59
66667: PUSH
66668: LD_VAR 0 2
66672: ARRAY
66673: PPUSH
66674: LD_INT 2
66676: PUSH
66677: LD_INT 25
66679: PUSH
66680: LD_INT 1
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 25
66689: PUSH
66690: LD_INT 5
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 25
66699: PUSH
66700: LD_INT 8
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 25
66709: PUSH
66710: LD_INT 9
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: EMPTY
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: PPUSH
66724: CALL_OW 72
66728: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
66729: LD_ADDR_VAR 0 4
66733: PUSH
66734: LD_VAR 0 4
66738: PUSH
66739: LD_VAR 0 4
66743: PPUSH
66744: LD_INT 18
66746: PPUSH
66747: CALL 47799 0 2
66751: DIFF
66752: ST_TO_ADDR
// if tmp then
66753: LD_VAR 0 4
66757: IFFALSE 66788
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
66759: LD_VAR 0 2
66763: PPUSH
66764: LD_VAR 0 4
66768: PPUSH
66769: LD_EXP 84
66773: PUSH
66774: LD_VAR 0 2
66778: ARRAY
66779: PPUSH
66780: CALL 99967 0 3
// exit ;
66784: POP
66785: POP
66786: GO 66861
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
66788: LD_EXP 82
66792: PUSH
66793: LD_VAR 0 2
66797: ARRAY
66798: PUSH
66799: LD_EXP 81
66803: PUSH
66804: LD_VAR 0 2
66808: ARRAY
66809: AND
66810: IFFALSE 66857
// begin tmp := mc_defender [ i ] ;
66812: LD_ADDR_VAR 0 4
66816: PUSH
66817: LD_EXP 81
66821: PUSH
66822: LD_VAR 0 2
66826: ARRAY
66827: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
66828: LD_VAR 0 2
66832: PPUSH
66833: LD_VAR 0 4
66837: PPUSH
66838: LD_EXP 82
66842: PUSH
66843: LD_VAR 0 2
66847: ARRAY
66848: PPUSH
66849: CALL 100528 0 3
// exit ;
66853: POP
66854: POP
66855: GO 66861
// end ; end ;
66857: GO 66294
66859: POP
66860: POP
// end ;
66861: LD_VAR 0 1
66865: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
66866: LD_INT 0
66868: PPUSH
66869: PPUSH
66870: PPUSH
66871: PPUSH
66872: PPUSH
66873: PPUSH
66874: PPUSH
66875: PPUSH
66876: PPUSH
66877: PPUSH
66878: PPUSH
// if not mc_bases then
66879: LD_EXP 59
66883: NOT
66884: IFFALSE 66888
// exit ;
66886: GO 67975
// for i = 1 to mc_bases do
66888: LD_ADDR_VAR 0 2
66892: PUSH
66893: DOUBLE
66894: LD_INT 1
66896: DEC
66897: ST_TO_ADDR
66898: LD_EXP 59
66902: PUSH
66903: FOR_TO
66904: IFFALSE 67973
// begin tmp := mc_lab [ i ] ;
66906: LD_ADDR_VAR 0 6
66910: PUSH
66911: LD_EXP 92
66915: PUSH
66916: LD_VAR 0 2
66920: ARRAY
66921: ST_TO_ADDR
// if not tmp then
66922: LD_VAR 0 6
66926: NOT
66927: IFFALSE 66931
// continue ;
66929: GO 66903
// idle_lab := 0 ;
66931: LD_ADDR_VAR 0 11
66935: PUSH
66936: LD_INT 0
66938: ST_TO_ADDR
// for j in tmp do
66939: LD_ADDR_VAR 0 3
66943: PUSH
66944: LD_VAR 0 6
66948: PUSH
66949: FOR_IN
66950: IFFALSE 67969
// begin researching := false ;
66952: LD_ADDR_VAR 0 10
66956: PUSH
66957: LD_INT 0
66959: ST_TO_ADDR
// side := GetSide ( j ) ;
66960: LD_ADDR_VAR 0 4
66964: PUSH
66965: LD_VAR 0 3
66969: PPUSH
66970: CALL_OW 255
66974: ST_TO_ADDR
// if not mc_tech [ side ] then
66975: LD_EXP 86
66979: PUSH
66980: LD_VAR 0 4
66984: ARRAY
66985: NOT
66986: IFFALSE 66990
// continue ;
66988: GO 66949
// if BuildingStatus ( j ) = bs_idle then
66990: LD_VAR 0 3
66994: PPUSH
66995: CALL_OW 461
66999: PUSH
67000: LD_INT 2
67002: EQUAL
67003: IFFALSE 67191
// begin if idle_lab and UnitsInside ( j ) < 6 then
67005: LD_VAR 0 11
67009: PUSH
67010: LD_VAR 0 3
67014: PPUSH
67015: CALL_OW 313
67019: PUSH
67020: LD_INT 6
67022: LESS
67023: AND
67024: IFFALSE 67095
// begin tmp2 := UnitsInside ( idle_lab ) ;
67026: LD_ADDR_VAR 0 9
67030: PUSH
67031: LD_VAR 0 11
67035: PPUSH
67036: CALL_OW 313
67040: ST_TO_ADDR
// if tmp2 then
67041: LD_VAR 0 9
67045: IFFALSE 67087
// for x in tmp2 do
67047: LD_ADDR_VAR 0 7
67051: PUSH
67052: LD_VAR 0 9
67056: PUSH
67057: FOR_IN
67058: IFFALSE 67085
// begin ComExitBuilding ( x ) ;
67060: LD_VAR 0 7
67064: PPUSH
67065: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67069: LD_VAR 0 7
67073: PPUSH
67074: LD_VAR 0 3
67078: PPUSH
67079: CALL_OW 180
// end ;
67083: GO 67057
67085: POP
67086: POP
// idle_lab := 0 ;
67087: LD_ADDR_VAR 0 11
67091: PUSH
67092: LD_INT 0
67094: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67095: LD_ADDR_VAR 0 5
67099: PUSH
67100: LD_EXP 86
67104: PUSH
67105: LD_VAR 0 4
67109: ARRAY
67110: PUSH
67111: FOR_IN
67112: IFFALSE 67172
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67114: LD_VAR 0 3
67118: PPUSH
67119: LD_VAR 0 5
67123: PPUSH
67124: CALL_OW 430
67128: PUSH
67129: LD_VAR 0 4
67133: PPUSH
67134: LD_VAR 0 5
67138: PPUSH
67139: CALL 15144 0 2
67143: AND
67144: IFFALSE 67170
// begin researching := true ;
67146: LD_ADDR_VAR 0 10
67150: PUSH
67151: LD_INT 1
67153: ST_TO_ADDR
// ComResearch ( j , t ) ;
67154: LD_VAR 0 3
67158: PPUSH
67159: LD_VAR 0 5
67163: PPUSH
67164: CALL_OW 124
// break ;
67168: GO 67172
// end ;
67170: GO 67111
67172: POP
67173: POP
// if not researching then
67174: LD_VAR 0 10
67178: NOT
67179: IFFALSE 67191
// idle_lab := j ;
67181: LD_ADDR_VAR 0 11
67185: PUSH
67186: LD_VAR 0 3
67190: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67191: LD_VAR 0 3
67195: PPUSH
67196: CALL_OW 461
67200: PUSH
67201: LD_INT 10
67203: EQUAL
67204: IFFALSE 67792
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67206: LD_EXP 88
67210: PUSH
67211: LD_VAR 0 2
67215: ARRAY
67216: NOT
67217: PUSH
67218: LD_EXP 89
67222: PUSH
67223: LD_VAR 0 2
67227: ARRAY
67228: NOT
67229: AND
67230: PUSH
67231: LD_EXP 86
67235: PUSH
67236: LD_VAR 0 4
67240: ARRAY
67241: PUSH
67242: LD_INT 1
67244: GREATER
67245: AND
67246: IFFALSE 67377
// begin ComCancel ( j ) ;
67248: LD_VAR 0 3
67252: PPUSH
67253: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
67257: LD_ADDR_EXP 86
67261: PUSH
67262: LD_EXP 86
67266: PPUSH
67267: LD_VAR 0 4
67271: PPUSH
67272: LD_EXP 86
67276: PUSH
67277: LD_VAR 0 4
67281: ARRAY
67282: PPUSH
67283: LD_EXP 86
67287: PUSH
67288: LD_VAR 0 4
67292: ARRAY
67293: PUSH
67294: LD_INT 1
67296: MINUS
67297: PPUSH
67298: LD_EXP 86
67302: PUSH
67303: LD_VAR 0 4
67307: ARRAY
67308: PPUSH
67309: LD_INT 0
67311: PPUSH
67312: CALL 18656 0 4
67316: PPUSH
67317: CALL_OW 1
67321: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
67322: LD_ADDR_EXP 86
67326: PUSH
67327: LD_EXP 86
67331: PPUSH
67332: LD_VAR 0 4
67336: PPUSH
67337: LD_EXP 86
67341: PUSH
67342: LD_VAR 0 4
67346: ARRAY
67347: PPUSH
67348: LD_EXP 86
67352: PUSH
67353: LD_VAR 0 4
67357: ARRAY
67358: PPUSH
67359: LD_INT 1
67361: PPUSH
67362: LD_INT 0
67364: PPUSH
67365: CALL 18656 0 4
67369: PPUSH
67370: CALL_OW 1
67374: ST_TO_ADDR
// continue ;
67375: GO 66949
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
67377: LD_EXP 88
67381: PUSH
67382: LD_VAR 0 2
67386: ARRAY
67387: PUSH
67388: LD_EXP 89
67392: PUSH
67393: LD_VAR 0 2
67397: ARRAY
67398: NOT
67399: AND
67400: IFFALSE 67527
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
67402: LD_ADDR_EXP 89
67406: PUSH
67407: LD_EXP 89
67411: PPUSH
67412: LD_VAR 0 2
67416: PUSH
67417: LD_EXP 89
67421: PUSH
67422: LD_VAR 0 2
67426: ARRAY
67427: PUSH
67428: LD_INT 1
67430: PLUS
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PPUSH
67436: LD_EXP 88
67440: PUSH
67441: LD_VAR 0 2
67445: ARRAY
67446: PUSH
67447: LD_INT 1
67449: ARRAY
67450: PPUSH
67451: CALL 19238 0 3
67455: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
67456: LD_EXP 88
67460: PUSH
67461: LD_VAR 0 2
67465: ARRAY
67466: PUSH
67467: LD_INT 1
67469: ARRAY
67470: PPUSH
67471: LD_INT 112
67473: PPUSH
67474: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
67478: LD_ADDR_VAR 0 9
67482: PUSH
67483: LD_EXP 88
67487: PUSH
67488: LD_VAR 0 2
67492: ARRAY
67493: PPUSH
67494: LD_INT 1
67496: PPUSH
67497: CALL_OW 3
67501: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
67502: LD_ADDR_EXP 88
67506: PUSH
67507: LD_EXP 88
67511: PPUSH
67512: LD_VAR 0 2
67516: PPUSH
67517: LD_VAR 0 9
67521: PPUSH
67522: CALL_OW 1
67526: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
67527: LD_EXP 88
67531: PUSH
67532: LD_VAR 0 2
67536: ARRAY
67537: PUSH
67538: LD_EXP 89
67542: PUSH
67543: LD_VAR 0 2
67547: ARRAY
67548: AND
67549: PUSH
67550: LD_EXP 89
67554: PUSH
67555: LD_VAR 0 2
67559: ARRAY
67560: PUSH
67561: LD_INT 1
67563: ARRAY
67564: PPUSH
67565: CALL_OW 310
67569: NOT
67570: AND
67571: PUSH
67572: LD_VAR 0 3
67576: PPUSH
67577: CALL_OW 313
67581: PUSH
67582: LD_INT 6
67584: EQUAL
67585: AND
67586: IFFALSE 67642
// begin tmp2 := UnitsInside ( j ) ;
67588: LD_ADDR_VAR 0 9
67592: PUSH
67593: LD_VAR 0 3
67597: PPUSH
67598: CALL_OW 313
67602: ST_TO_ADDR
// if tmp2 = 6 then
67603: LD_VAR 0 9
67607: PUSH
67608: LD_INT 6
67610: EQUAL
67611: IFFALSE 67642
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
67613: LD_VAR 0 9
67617: PUSH
67618: LD_INT 1
67620: ARRAY
67621: PPUSH
67622: LD_INT 112
67624: PPUSH
67625: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
67629: LD_VAR 0 9
67633: PUSH
67634: LD_INT 1
67636: ARRAY
67637: PPUSH
67638: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
67642: LD_EXP 89
67646: PUSH
67647: LD_VAR 0 2
67651: ARRAY
67652: PUSH
67653: LD_EXP 89
67657: PUSH
67658: LD_VAR 0 2
67662: ARRAY
67663: PUSH
67664: LD_INT 1
67666: ARRAY
67667: PPUSH
67668: CALL_OW 314
67672: NOT
67673: AND
67674: PUSH
67675: LD_EXP 89
67679: PUSH
67680: LD_VAR 0 2
67684: ARRAY
67685: PUSH
67686: LD_INT 1
67688: ARRAY
67689: PPUSH
67690: CALL_OW 310
67694: NOT
67695: AND
67696: IFFALSE 67722
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
67698: LD_EXP 89
67702: PUSH
67703: LD_VAR 0 2
67707: ARRAY
67708: PUSH
67709: LD_INT 1
67711: ARRAY
67712: PPUSH
67713: LD_VAR 0 3
67717: PPUSH
67718: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
67722: LD_EXP 89
67726: PUSH
67727: LD_VAR 0 2
67731: ARRAY
67732: PUSH
67733: LD_INT 1
67735: ARRAY
67736: PPUSH
67737: CALL_OW 310
67741: PUSH
67742: LD_EXP 89
67746: PUSH
67747: LD_VAR 0 2
67751: ARRAY
67752: PUSH
67753: LD_INT 1
67755: ARRAY
67756: PPUSH
67757: CALL_OW 310
67761: PPUSH
67762: CALL_OW 461
67766: PUSH
67767: LD_INT 3
67769: NONEQUAL
67770: AND
67771: IFFALSE 67792
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
67773: LD_EXP 89
67777: PUSH
67778: LD_VAR 0 2
67782: ARRAY
67783: PUSH
67784: LD_INT 1
67786: ARRAY
67787: PPUSH
67788: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
67792: LD_VAR 0 3
67796: PPUSH
67797: CALL_OW 461
67801: PUSH
67802: LD_INT 6
67804: EQUAL
67805: PUSH
67806: LD_VAR 0 6
67810: PUSH
67811: LD_INT 1
67813: GREATER
67814: AND
67815: IFFALSE 67967
// begin sci := [ ] ;
67817: LD_ADDR_VAR 0 8
67821: PUSH
67822: EMPTY
67823: ST_TO_ADDR
// for x in ( tmp diff j ) do
67824: LD_ADDR_VAR 0 7
67828: PUSH
67829: LD_VAR 0 6
67833: PUSH
67834: LD_VAR 0 3
67838: DIFF
67839: PUSH
67840: FOR_IN
67841: IFFALSE 67893
// begin if sci = 6 then
67843: LD_VAR 0 8
67847: PUSH
67848: LD_INT 6
67850: EQUAL
67851: IFFALSE 67855
// break ;
67853: GO 67893
// if BuildingStatus ( x ) = bs_idle then
67855: LD_VAR 0 7
67859: PPUSH
67860: CALL_OW 461
67864: PUSH
67865: LD_INT 2
67867: EQUAL
67868: IFFALSE 67891
// sci := sci ^ UnitsInside ( x ) ;
67870: LD_ADDR_VAR 0 8
67874: PUSH
67875: LD_VAR 0 8
67879: PUSH
67880: LD_VAR 0 7
67884: PPUSH
67885: CALL_OW 313
67889: ADD
67890: ST_TO_ADDR
// end ;
67891: GO 67840
67893: POP
67894: POP
// if not sci then
67895: LD_VAR 0 8
67899: NOT
67900: IFFALSE 67904
// continue ;
67902: GO 66949
// for x in sci do
67904: LD_ADDR_VAR 0 7
67908: PUSH
67909: LD_VAR 0 8
67913: PUSH
67914: FOR_IN
67915: IFFALSE 67965
// if IsInUnit ( x ) and not HasTask ( x ) then
67917: LD_VAR 0 7
67921: PPUSH
67922: CALL_OW 310
67926: PUSH
67927: LD_VAR 0 7
67931: PPUSH
67932: CALL_OW 314
67936: NOT
67937: AND
67938: IFFALSE 67963
// begin ComExitBuilding ( x ) ;
67940: LD_VAR 0 7
67944: PPUSH
67945: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67949: LD_VAR 0 7
67953: PPUSH
67954: LD_VAR 0 3
67958: PPUSH
67959: CALL_OW 180
// end ;
67963: GO 67914
67965: POP
67966: POP
// end ; end ;
67967: GO 66949
67969: POP
67970: POP
// end ;
67971: GO 66903
67973: POP
67974: POP
// end ;
67975: LD_VAR 0 1
67979: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
67980: LD_INT 0
67982: PPUSH
67983: PPUSH
// if not mc_bases then
67984: LD_EXP 59
67988: NOT
67989: IFFALSE 67993
// exit ;
67991: GO 68074
// for i = 1 to mc_bases do
67993: LD_ADDR_VAR 0 2
67997: PUSH
67998: DOUBLE
67999: LD_INT 1
68001: DEC
68002: ST_TO_ADDR
68003: LD_EXP 59
68007: PUSH
68008: FOR_TO
68009: IFFALSE 68072
// if mc_mines [ i ] and mc_miners [ i ] then
68011: LD_EXP 72
68015: PUSH
68016: LD_VAR 0 2
68020: ARRAY
68021: PUSH
68022: LD_EXP 73
68026: PUSH
68027: LD_VAR 0 2
68031: ARRAY
68032: AND
68033: IFFALSE 68070
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68035: LD_EXP 73
68039: PUSH
68040: LD_VAR 0 2
68044: ARRAY
68045: PUSH
68046: LD_INT 1
68048: ARRAY
68049: PPUSH
68050: CALL_OW 255
68054: PPUSH
68055: LD_EXP 72
68059: PUSH
68060: LD_VAR 0 2
68064: ARRAY
68065: PPUSH
68066: CALL 16227 0 2
68070: GO 68008
68072: POP
68073: POP
// end ;
68074: LD_VAR 0 1
68078: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68079: LD_INT 0
68081: PPUSH
68082: PPUSH
68083: PPUSH
68084: PPUSH
68085: PPUSH
68086: PPUSH
68087: PPUSH
68088: PPUSH
// if not mc_bases or not mc_parking then
68089: LD_EXP 59
68093: NOT
68094: PUSH
68095: LD_EXP 83
68099: NOT
68100: OR
68101: IFFALSE 68105
// exit ;
68103: GO 68804
// for i = 1 to mc_bases do
68105: LD_ADDR_VAR 0 2
68109: PUSH
68110: DOUBLE
68111: LD_INT 1
68113: DEC
68114: ST_TO_ADDR
68115: LD_EXP 59
68119: PUSH
68120: FOR_TO
68121: IFFALSE 68802
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68123: LD_EXP 59
68127: PUSH
68128: LD_VAR 0 2
68132: ARRAY
68133: NOT
68134: PUSH
68135: LD_EXP 83
68139: PUSH
68140: LD_VAR 0 2
68144: ARRAY
68145: NOT
68146: OR
68147: IFFALSE 68151
// continue ;
68149: GO 68120
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68151: LD_ADDR_VAR 0 5
68155: PUSH
68156: LD_EXP 59
68160: PUSH
68161: LD_VAR 0 2
68165: ARRAY
68166: PUSH
68167: LD_INT 1
68169: ARRAY
68170: PPUSH
68171: CALL_OW 255
68175: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68176: LD_ADDR_VAR 0 6
68180: PUSH
68181: LD_EXP 59
68185: PUSH
68186: LD_VAR 0 2
68190: ARRAY
68191: PPUSH
68192: LD_INT 30
68194: PUSH
68195: LD_INT 3
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PPUSH
68202: CALL_OW 72
68206: ST_TO_ADDR
// if not fac then
68207: LD_VAR 0 6
68211: NOT
68212: IFFALSE 68263
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68214: LD_ADDR_VAR 0 6
68218: PUSH
68219: LD_EXP 59
68223: PUSH
68224: LD_VAR 0 2
68228: ARRAY
68229: PPUSH
68230: LD_INT 2
68232: PUSH
68233: LD_INT 30
68235: PUSH
68236: LD_INT 0
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 30
68245: PUSH
68246: LD_INT 1
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: LIST
68257: PPUSH
68258: CALL_OW 72
68262: ST_TO_ADDR
// if not fac then
68263: LD_VAR 0 6
68267: NOT
68268: IFFALSE 68272
// continue ;
68270: GO 68120
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68272: LD_ADDR_VAR 0 7
68276: PUSH
68277: LD_EXP 83
68281: PUSH
68282: LD_VAR 0 2
68286: ARRAY
68287: PPUSH
68288: LD_INT 22
68290: PUSH
68291: LD_VAR 0 5
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 21
68302: PUSH
68303: LD_INT 2
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 3
68312: PUSH
68313: LD_INT 24
68315: PUSH
68316: LD_INT 1000
68318: PUSH
68319: EMPTY
68320: LIST
68321: LIST
68322: PUSH
68323: EMPTY
68324: LIST
68325: LIST
68326: PUSH
68327: EMPTY
68328: LIST
68329: LIST
68330: LIST
68331: PPUSH
68332: CALL_OW 70
68336: ST_TO_ADDR
// for j in fac do
68337: LD_ADDR_VAR 0 3
68341: PUSH
68342: LD_VAR 0 6
68346: PUSH
68347: FOR_IN
68348: IFFALSE 68429
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
68350: LD_ADDR_VAR 0 7
68354: PUSH
68355: LD_VAR 0 7
68359: PUSH
68360: LD_INT 22
68362: PUSH
68363: LD_VAR 0 5
68367: PUSH
68368: EMPTY
68369: LIST
68370: LIST
68371: PUSH
68372: LD_INT 91
68374: PUSH
68375: LD_VAR 0 3
68379: PUSH
68380: LD_INT 15
68382: PUSH
68383: EMPTY
68384: LIST
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 21
68390: PUSH
68391: LD_INT 2
68393: PUSH
68394: EMPTY
68395: LIST
68396: LIST
68397: PUSH
68398: LD_INT 3
68400: PUSH
68401: LD_INT 24
68403: PUSH
68404: LD_INT 1000
68406: PUSH
68407: EMPTY
68408: LIST
68409: LIST
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: PPUSH
68421: CALL_OW 69
68425: UNION
68426: ST_TO_ADDR
68427: GO 68347
68429: POP
68430: POP
// if not vehs then
68431: LD_VAR 0 7
68435: NOT
68436: IFFALSE 68462
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
68438: LD_ADDR_EXP 71
68442: PUSH
68443: LD_EXP 71
68447: PPUSH
68448: LD_VAR 0 2
68452: PPUSH
68453: EMPTY
68454: PPUSH
68455: CALL_OW 1
68459: ST_TO_ADDR
// continue ;
68460: GO 68120
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68462: LD_ADDR_VAR 0 8
68466: PUSH
68467: LD_EXP 59
68471: PUSH
68472: LD_VAR 0 2
68476: ARRAY
68477: PPUSH
68478: LD_INT 30
68480: PUSH
68481: LD_INT 3
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PPUSH
68488: CALL_OW 72
68492: ST_TO_ADDR
// if tmp then
68493: LD_VAR 0 8
68497: IFFALSE 68600
// begin for j in tmp do
68499: LD_ADDR_VAR 0 3
68503: PUSH
68504: LD_VAR 0 8
68508: PUSH
68509: FOR_IN
68510: IFFALSE 68598
// for k in UnitsInside ( j ) do
68512: LD_ADDR_VAR 0 4
68516: PUSH
68517: LD_VAR 0 3
68521: PPUSH
68522: CALL_OW 313
68526: PUSH
68527: FOR_IN
68528: IFFALSE 68594
// if k then
68530: LD_VAR 0 4
68534: IFFALSE 68592
// if not k in mc_repair_vehicle [ i ] then
68536: LD_VAR 0 4
68540: PUSH
68541: LD_EXP 71
68545: PUSH
68546: LD_VAR 0 2
68550: ARRAY
68551: IN
68552: NOT
68553: IFFALSE 68592
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
68555: LD_ADDR_EXP 71
68559: PUSH
68560: LD_EXP 71
68564: PPUSH
68565: LD_VAR 0 2
68569: PPUSH
68570: LD_EXP 71
68574: PUSH
68575: LD_VAR 0 2
68579: ARRAY
68580: PUSH
68581: LD_VAR 0 4
68585: UNION
68586: PPUSH
68587: CALL_OW 1
68591: ST_TO_ADDR
68592: GO 68527
68594: POP
68595: POP
68596: GO 68509
68598: POP
68599: POP
// end ; if not mc_repair_vehicle [ i ] then
68600: LD_EXP 71
68604: PUSH
68605: LD_VAR 0 2
68609: ARRAY
68610: NOT
68611: IFFALSE 68615
// continue ;
68613: GO 68120
// for j in mc_repair_vehicle [ i ] do
68615: LD_ADDR_VAR 0 3
68619: PUSH
68620: LD_EXP 71
68624: PUSH
68625: LD_VAR 0 2
68629: ARRAY
68630: PUSH
68631: FOR_IN
68632: IFFALSE 68798
// begin if GetClass ( j ) <> 3 then
68634: LD_VAR 0 3
68638: PPUSH
68639: CALL_OW 257
68643: PUSH
68644: LD_INT 3
68646: NONEQUAL
68647: IFFALSE 68688
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
68649: LD_ADDR_EXP 71
68653: PUSH
68654: LD_EXP 71
68658: PPUSH
68659: LD_VAR 0 2
68663: PPUSH
68664: LD_EXP 71
68668: PUSH
68669: LD_VAR 0 2
68673: ARRAY
68674: PUSH
68675: LD_VAR 0 3
68679: DIFF
68680: PPUSH
68681: CALL_OW 1
68685: ST_TO_ADDR
// continue ;
68686: GO 68631
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
68688: LD_VAR 0 3
68692: PPUSH
68693: CALL_OW 311
68697: NOT
68698: PUSH
68699: LD_VAR 0 3
68703: PUSH
68704: LD_EXP 62
68708: PUSH
68709: LD_VAR 0 2
68713: ARRAY
68714: PUSH
68715: LD_INT 1
68717: ARRAY
68718: IN
68719: NOT
68720: AND
68721: PUSH
68722: LD_VAR 0 3
68726: PUSH
68727: LD_EXP 62
68731: PUSH
68732: LD_VAR 0 2
68736: ARRAY
68737: PUSH
68738: LD_INT 2
68740: ARRAY
68741: IN
68742: NOT
68743: AND
68744: IFFALSE 68796
// begin if IsInUnit ( j ) then
68746: LD_VAR 0 3
68750: PPUSH
68751: CALL_OW 310
68755: IFFALSE 68766
// ComExitBuilding ( j ) ;
68757: LD_VAR 0 3
68761: PPUSH
68762: CALL_OW 122
// if not HasTask ( j ) then
68766: LD_VAR 0 3
68770: PPUSH
68771: CALL_OW 314
68775: NOT
68776: IFFALSE 68796
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
68778: LD_VAR 0 3
68782: PPUSH
68783: LD_VAR 0 7
68787: PUSH
68788: LD_INT 1
68790: ARRAY
68791: PPUSH
68792: CALL_OW 189
// end ; end ;
68796: GO 68631
68798: POP
68799: POP
// end ;
68800: GO 68120
68802: POP
68803: POP
// end ;
68804: LD_VAR 0 1
68808: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
68809: LD_INT 0
68811: PPUSH
68812: PPUSH
68813: PPUSH
68814: PPUSH
68815: PPUSH
68816: PPUSH
68817: PPUSH
68818: PPUSH
68819: PPUSH
68820: PPUSH
68821: PPUSH
// if not mc_bases then
68822: LD_EXP 59
68826: NOT
68827: IFFALSE 68831
// exit ;
68829: GO 69633
// for i = 1 to mc_bases do
68831: LD_ADDR_VAR 0 2
68835: PUSH
68836: DOUBLE
68837: LD_INT 1
68839: DEC
68840: ST_TO_ADDR
68841: LD_EXP 59
68845: PUSH
68846: FOR_TO
68847: IFFALSE 69631
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
68849: LD_EXP 87
68853: PUSH
68854: LD_VAR 0 2
68858: ARRAY
68859: NOT
68860: PUSH
68861: LD_EXP 62
68865: PUSH
68866: LD_VAR 0 2
68870: ARRAY
68871: PUSH
68872: LD_INT 1
68874: ARRAY
68875: OR
68876: PUSH
68877: LD_EXP 62
68881: PUSH
68882: LD_VAR 0 2
68886: ARRAY
68887: PUSH
68888: LD_INT 2
68890: ARRAY
68891: OR
68892: PUSH
68893: LD_EXP 85
68897: PUSH
68898: LD_VAR 0 2
68902: ARRAY
68903: PPUSH
68904: LD_INT 1
68906: PPUSH
68907: CALL_OW 325
68911: NOT
68912: OR
68913: PUSH
68914: LD_EXP 82
68918: PUSH
68919: LD_VAR 0 2
68923: ARRAY
68924: OR
68925: IFFALSE 68929
// continue ;
68927: GO 68846
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
68929: LD_ADDR_VAR 0 8
68933: PUSH
68934: LD_EXP 59
68938: PUSH
68939: LD_VAR 0 2
68943: ARRAY
68944: PPUSH
68945: LD_INT 25
68947: PUSH
68948: LD_INT 4
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 50
68957: PUSH
68958: EMPTY
68959: LIST
68960: PUSH
68961: LD_INT 3
68963: PUSH
68964: LD_INT 60
68966: PUSH
68967: EMPTY
68968: LIST
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: EMPTY
68975: LIST
68976: LIST
68977: LIST
68978: PPUSH
68979: CALL_OW 72
68983: PUSH
68984: LD_EXP 63
68988: PUSH
68989: LD_VAR 0 2
68993: ARRAY
68994: DIFF
68995: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68996: LD_ADDR_VAR 0 9
69000: PUSH
69001: LD_EXP 59
69005: PUSH
69006: LD_VAR 0 2
69010: ARRAY
69011: PPUSH
69012: LD_INT 2
69014: PUSH
69015: LD_INT 30
69017: PUSH
69018: LD_INT 0
69020: PUSH
69021: EMPTY
69022: LIST
69023: LIST
69024: PUSH
69025: LD_INT 30
69027: PUSH
69028: LD_INT 1
69030: PUSH
69031: EMPTY
69032: LIST
69033: LIST
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: LIST
69039: PPUSH
69040: CALL_OW 72
69044: ST_TO_ADDR
// if not tmp or not dep then
69045: LD_VAR 0 8
69049: NOT
69050: PUSH
69051: LD_VAR 0 9
69055: NOT
69056: OR
69057: IFFALSE 69061
// continue ;
69059: GO 68846
// side := GetSide ( tmp [ 1 ] ) ;
69061: LD_ADDR_VAR 0 11
69065: PUSH
69066: LD_VAR 0 8
69070: PUSH
69071: LD_INT 1
69073: ARRAY
69074: PPUSH
69075: CALL_OW 255
69079: ST_TO_ADDR
// dep := dep [ 1 ] ;
69080: LD_ADDR_VAR 0 9
69084: PUSH
69085: LD_VAR 0 9
69089: PUSH
69090: LD_INT 1
69092: ARRAY
69093: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69094: LD_ADDR_VAR 0 7
69098: PUSH
69099: LD_EXP 87
69103: PUSH
69104: LD_VAR 0 2
69108: ARRAY
69109: PPUSH
69110: LD_INT 22
69112: PUSH
69113: LD_INT 0
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 25
69122: PUSH
69123: LD_INT 12
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PPUSH
69134: CALL_OW 70
69138: PUSH
69139: LD_INT 22
69141: PUSH
69142: LD_INT 0
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 25
69151: PUSH
69152: LD_INT 12
69154: PUSH
69155: EMPTY
69156: LIST
69157: LIST
69158: PUSH
69159: LD_INT 91
69161: PUSH
69162: LD_VAR 0 9
69166: PUSH
69167: LD_INT 20
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: LIST
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: LIST
69179: PPUSH
69180: CALL_OW 69
69184: UNION
69185: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69186: LD_ADDR_VAR 0 10
69190: PUSH
69191: LD_EXP 87
69195: PUSH
69196: LD_VAR 0 2
69200: ARRAY
69201: PPUSH
69202: LD_INT 81
69204: PUSH
69205: LD_VAR 0 11
69209: PUSH
69210: EMPTY
69211: LIST
69212: LIST
69213: PPUSH
69214: CALL_OW 70
69218: ST_TO_ADDR
// if not apes or danger_at_area then
69219: LD_VAR 0 7
69223: NOT
69224: PUSH
69225: LD_VAR 0 10
69229: OR
69230: IFFALSE 69280
// begin if mc_taming [ i ] then
69232: LD_EXP 90
69236: PUSH
69237: LD_VAR 0 2
69241: ARRAY
69242: IFFALSE 69278
// begin MC_Reset ( i , 121 ) ;
69244: LD_VAR 0 2
69248: PPUSH
69249: LD_INT 121
69251: PPUSH
69252: CALL 54731 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
69256: LD_ADDR_EXP 90
69260: PUSH
69261: LD_EXP 90
69265: PPUSH
69266: LD_VAR 0 2
69270: PPUSH
69271: EMPTY
69272: PPUSH
69273: CALL_OW 1
69277: ST_TO_ADDR
// end ; continue ;
69278: GO 68846
// end ; for j in tmp do
69280: LD_ADDR_VAR 0 3
69284: PUSH
69285: LD_VAR 0 8
69289: PUSH
69290: FOR_IN
69291: IFFALSE 69627
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
69293: LD_VAR 0 3
69297: PUSH
69298: LD_EXP 90
69302: PUSH
69303: LD_VAR 0 2
69307: ARRAY
69308: IN
69309: NOT
69310: PUSH
69311: LD_EXP 90
69315: PUSH
69316: LD_VAR 0 2
69320: ARRAY
69321: PUSH
69322: LD_INT 3
69324: LESS
69325: AND
69326: IFFALSE 69384
// begin SetTag ( j , 121 ) ;
69328: LD_VAR 0 3
69332: PPUSH
69333: LD_INT 121
69335: PPUSH
69336: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
69340: LD_ADDR_EXP 90
69344: PUSH
69345: LD_EXP 90
69349: PPUSH
69350: LD_VAR 0 2
69354: PUSH
69355: LD_EXP 90
69359: PUSH
69360: LD_VAR 0 2
69364: ARRAY
69365: PUSH
69366: LD_INT 1
69368: PLUS
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PPUSH
69374: LD_VAR 0 3
69378: PPUSH
69379: CALL 19238 0 3
69383: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
69384: LD_VAR 0 3
69388: PUSH
69389: LD_EXP 90
69393: PUSH
69394: LD_VAR 0 2
69398: ARRAY
69399: IN
69400: IFFALSE 69625
// begin if GetClass ( j ) <> 4 then
69402: LD_VAR 0 3
69406: PPUSH
69407: CALL_OW 257
69411: PUSH
69412: LD_INT 4
69414: NONEQUAL
69415: IFFALSE 69468
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
69417: LD_ADDR_EXP 90
69421: PUSH
69422: LD_EXP 90
69426: PPUSH
69427: LD_VAR 0 2
69431: PPUSH
69432: LD_EXP 90
69436: PUSH
69437: LD_VAR 0 2
69441: ARRAY
69442: PUSH
69443: LD_VAR 0 3
69447: DIFF
69448: PPUSH
69449: CALL_OW 1
69453: ST_TO_ADDR
// SetTag ( j , 0 ) ;
69454: LD_VAR 0 3
69458: PPUSH
69459: LD_INT 0
69461: PPUSH
69462: CALL_OW 109
// continue ;
69466: GO 69290
// end ; if IsInUnit ( j ) then
69468: LD_VAR 0 3
69472: PPUSH
69473: CALL_OW 310
69477: IFFALSE 69488
// ComExitBuilding ( j ) ;
69479: LD_VAR 0 3
69483: PPUSH
69484: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
69488: LD_ADDR_VAR 0 6
69492: PUSH
69493: LD_VAR 0 7
69497: PPUSH
69498: LD_VAR 0 3
69502: PPUSH
69503: CALL_OW 74
69507: ST_TO_ADDR
// if not ape then
69508: LD_VAR 0 6
69512: NOT
69513: IFFALSE 69517
// break ;
69515: GO 69627
// x := GetX ( ape ) ;
69517: LD_ADDR_VAR 0 4
69521: PUSH
69522: LD_VAR 0 6
69526: PPUSH
69527: CALL_OW 250
69531: ST_TO_ADDR
// y := GetY ( ape ) ;
69532: LD_ADDR_VAR 0 5
69536: PUSH
69537: LD_VAR 0 6
69541: PPUSH
69542: CALL_OW 251
69546: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
69547: LD_VAR 0 4
69551: PPUSH
69552: LD_VAR 0 5
69556: PPUSH
69557: CALL_OW 488
69561: NOT
69562: PUSH
69563: LD_VAR 0 11
69567: PPUSH
69568: LD_VAR 0 4
69572: PPUSH
69573: LD_VAR 0 5
69577: PPUSH
69578: LD_INT 20
69580: PPUSH
69581: CALL 20134 0 4
69585: PUSH
69586: LD_INT 4
69588: ARRAY
69589: OR
69590: IFFALSE 69594
// break ;
69592: GO 69627
// if not HasTask ( j ) then
69594: LD_VAR 0 3
69598: PPUSH
69599: CALL_OW 314
69603: NOT
69604: IFFALSE 69625
// ComTameXY ( j , x , y ) ;
69606: LD_VAR 0 3
69610: PPUSH
69611: LD_VAR 0 4
69615: PPUSH
69616: LD_VAR 0 5
69620: PPUSH
69621: CALL_OW 131
// end ; end ;
69625: GO 69290
69627: POP
69628: POP
// end ;
69629: GO 68846
69631: POP
69632: POP
// end ;
69633: LD_VAR 0 1
69637: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
69638: LD_INT 0
69640: PPUSH
69641: PPUSH
69642: PPUSH
69643: PPUSH
69644: PPUSH
69645: PPUSH
69646: PPUSH
69647: PPUSH
// if not mc_bases then
69648: LD_EXP 59
69652: NOT
69653: IFFALSE 69657
// exit ;
69655: GO 70283
// for i = 1 to mc_bases do
69657: LD_ADDR_VAR 0 2
69661: PUSH
69662: DOUBLE
69663: LD_INT 1
69665: DEC
69666: ST_TO_ADDR
69667: LD_EXP 59
69671: PUSH
69672: FOR_TO
69673: IFFALSE 70281
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
69675: LD_EXP 88
69679: PUSH
69680: LD_VAR 0 2
69684: ARRAY
69685: NOT
69686: PUSH
69687: LD_EXP 88
69691: PUSH
69692: LD_VAR 0 2
69696: ARRAY
69697: PPUSH
69698: LD_INT 25
69700: PUSH
69701: LD_INT 12
69703: PUSH
69704: EMPTY
69705: LIST
69706: LIST
69707: PPUSH
69708: CALL_OW 72
69712: NOT
69713: OR
69714: IFFALSE 69718
// continue ;
69716: GO 69672
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
69718: LD_ADDR_VAR 0 5
69722: PUSH
69723: LD_EXP 88
69727: PUSH
69728: LD_VAR 0 2
69732: ARRAY
69733: PUSH
69734: LD_INT 1
69736: ARRAY
69737: PPUSH
69738: CALL_OW 255
69742: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
69743: LD_VAR 0 5
69747: PPUSH
69748: LD_INT 2
69750: PPUSH
69751: CALL_OW 325
69755: IFFALSE 70008
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
69757: LD_ADDR_VAR 0 4
69761: PUSH
69762: LD_EXP 88
69766: PUSH
69767: LD_VAR 0 2
69771: ARRAY
69772: PPUSH
69773: LD_INT 25
69775: PUSH
69776: LD_INT 16
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PPUSH
69783: CALL_OW 72
69787: ST_TO_ADDR
// if tmp < 6 then
69788: LD_VAR 0 4
69792: PUSH
69793: LD_INT 6
69795: LESS
69796: IFFALSE 70008
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69798: LD_ADDR_VAR 0 6
69802: PUSH
69803: LD_EXP 59
69807: PUSH
69808: LD_VAR 0 2
69812: ARRAY
69813: PPUSH
69814: LD_INT 2
69816: PUSH
69817: LD_INT 30
69819: PUSH
69820: LD_INT 0
69822: PUSH
69823: EMPTY
69824: LIST
69825: LIST
69826: PUSH
69827: LD_INT 30
69829: PUSH
69830: LD_INT 1
69832: PUSH
69833: EMPTY
69834: LIST
69835: LIST
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: LIST
69841: PPUSH
69842: CALL_OW 72
69846: ST_TO_ADDR
// if depot then
69847: LD_VAR 0 6
69851: IFFALSE 70008
// begin selected := 0 ;
69853: LD_ADDR_VAR 0 7
69857: PUSH
69858: LD_INT 0
69860: ST_TO_ADDR
// for j in depot do
69861: LD_ADDR_VAR 0 3
69865: PUSH
69866: LD_VAR 0 6
69870: PUSH
69871: FOR_IN
69872: IFFALSE 69903
// begin if UnitsInside ( j ) < 6 then
69874: LD_VAR 0 3
69878: PPUSH
69879: CALL_OW 313
69883: PUSH
69884: LD_INT 6
69886: LESS
69887: IFFALSE 69901
// begin selected := j ;
69889: LD_ADDR_VAR 0 7
69893: PUSH
69894: LD_VAR 0 3
69898: ST_TO_ADDR
// break ;
69899: GO 69903
// end ; end ;
69901: GO 69871
69903: POP
69904: POP
// if selected then
69905: LD_VAR 0 7
69909: IFFALSE 70008
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
69911: LD_ADDR_VAR 0 3
69915: PUSH
69916: LD_EXP 88
69920: PUSH
69921: LD_VAR 0 2
69925: ARRAY
69926: PPUSH
69927: LD_INT 25
69929: PUSH
69930: LD_INT 12
69932: PUSH
69933: EMPTY
69934: LIST
69935: LIST
69936: PPUSH
69937: CALL_OW 72
69941: PUSH
69942: FOR_IN
69943: IFFALSE 70006
// if not HasTask ( j ) then
69945: LD_VAR 0 3
69949: PPUSH
69950: CALL_OW 314
69954: NOT
69955: IFFALSE 70004
// begin if not IsInUnit ( j ) then
69957: LD_VAR 0 3
69961: PPUSH
69962: CALL_OW 310
69966: NOT
69967: IFFALSE 69983
// ComEnterUnit ( j , selected ) ;
69969: LD_VAR 0 3
69973: PPUSH
69974: LD_VAR 0 7
69978: PPUSH
69979: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
69983: LD_VAR 0 3
69987: PPUSH
69988: LD_INT 16
69990: PPUSH
69991: CALL_OW 183
// AddComExitBuilding ( j ) ;
69995: LD_VAR 0 3
69999: PPUSH
70000: CALL_OW 182
// end ;
70004: GO 69942
70006: POP
70007: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70008: LD_VAR 0 5
70012: PPUSH
70013: LD_INT 11
70015: PPUSH
70016: CALL_OW 325
70020: IFFALSE 70279
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70022: LD_ADDR_VAR 0 4
70026: PUSH
70027: LD_EXP 88
70031: PUSH
70032: LD_VAR 0 2
70036: ARRAY
70037: PPUSH
70038: LD_INT 25
70040: PUSH
70041: LD_INT 16
70043: PUSH
70044: EMPTY
70045: LIST
70046: LIST
70047: PPUSH
70048: CALL_OW 72
70052: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70053: LD_VAR 0 4
70057: PUSH
70058: LD_INT 6
70060: GREATEREQUAL
70061: PUSH
70062: LD_VAR 0 5
70066: PPUSH
70067: LD_INT 2
70069: PPUSH
70070: CALL_OW 325
70074: NOT
70075: OR
70076: IFFALSE 70279
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70078: LD_ADDR_VAR 0 8
70082: PUSH
70083: LD_EXP 59
70087: PUSH
70088: LD_VAR 0 2
70092: ARRAY
70093: PPUSH
70094: LD_INT 2
70096: PUSH
70097: LD_INT 30
70099: PUSH
70100: LD_INT 4
70102: PUSH
70103: EMPTY
70104: LIST
70105: LIST
70106: PUSH
70107: LD_INT 30
70109: PUSH
70110: LD_INT 5
70112: PUSH
70113: EMPTY
70114: LIST
70115: LIST
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: LIST
70121: PPUSH
70122: CALL_OW 72
70126: ST_TO_ADDR
// if barracks then
70127: LD_VAR 0 8
70131: IFFALSE 70279
// begin selected := 0 ;
70133: LD_ADDR_VAR 0 7
70137: PUSH
70138: LD_INT 0
70140: ST_TO_ADDR
// for j in barracks do
70141: LD_ADDR_VAR 0 3
70145: PUSH
70146: LD_VAR 0 8
70150: PUSH
70151: FOR_IN
70152: IFFALSE 70183
// begin if UnitsInside ( j ) < 6 then
70154: LD_VAR 0 3
70158: PPUSH
70159: CALL_OW 313
70163: PUSH
70164: LD_INT 6
70166: LESS
70167: IFFALSE 70181
// begin selected := j ;
70169: LD_ADDR_VAR 0 7
70173: PUSH
70174: LD_VAR 0 3
70178: ST_TO_ADDR
// break ;
70179: GO 70183
// end ; end ;
70181: GO 70151
70183: POP
70184: POP
// if selected then
70185: LD_VAR 0 7
70189: IFFALSE 70279
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70191: LD_ADDR_VAR 0 3
70195: PUSH
70196: LD_EXP 88
70200: PUSH
70201: LD_VAR 0 2
70205: ARRAY
70206: PPUSH
70207: LD_INT 25
70209: PUSH
70210: LD_INT 12
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PPUSH
70217: CALL_OW 72
70221: PUSH
70222: FOR_IN
70223: IFFALSE 70277
// if not IsInUnit ( j ) and not HasTask ( j ) then
70225: LD_VAR 0 3
70229: PPUSH
70230: CALL_OW 310
70234: NOT
70235: PUSH
70236: LD_VAR 0 3
70240: PPUSH
70241: CALL_OW 314
70245: NOT
70246: AND
70247: IFFALSE 70275
// begin ComEnterUnit ( j , selected ) ;
70249: LD_VAR 0 3
70253: PPUSH
70254: LD_VAR 0 7
70258: PPUSH
70259: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
70263: LD_VAR 0 3
70267: PPUSH
70268: LD_INT 15
70270: PPUSH
70271: CALL_OW 183
// end ;
70275: GO 70222
70277: POP
70278: POP
// end ; end ; end ; end ; end ;
70279: GO 69672
70281: POP
70282: POP
// end ;
70283: LD_VAR 0 1
70287: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
70288: LD_INT 0
70290: PPUSH
70291: PPUSH
70292: PPUSH
70293: PPUSH
// if not mc_bases then
70294: LD_EXP 59
70298: NOT
70299: IFFALSE 70303
// exit ;
70301: GO 70481
// for i = 1 to mc_bases do
70303: LD_ADDR_VAR 0 2
70307: PUSH
70308: DOUBLE
70309: LD_INT 1
70311: DEC
70312: ST_TO_ADDR
70313: LD_EXP 59
70317: PUSH
70318: FOR_TO
70319: IFFALSE 70479
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
70321: LD_ADDR_VAR 0 4
70325: PUSH
70326: LD_EXP 59
70330: PUSH
70331: LD_VAR 0 2
70335: ARRAY
70336: PPUSH
70337: LD_INT 25
70339: PUSH
70340: LD_INT 9
70342: PUSH
70343: EMPTY
70344: LIST
70345: LIST
70346: PPUSH
70347: CALL_OW 72
70351: ST_TO_ADDR
// if not tmp then
70352: LD_VAR 0 4
70356: NOT
70357: IFFALSE 70361
// continue ;
70359: GO 70318
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
70361: LD_EXP 85
70365: PUSH
70366: LD_VAR 0 2
70370: ARRAY
70371: PPUSH
70372: LD_INT 29
70374: PPUSH
70375: CALL_OW 325
70379: NOT
70380: PUSH
70381: LD_EXP 85
70385: PUSH
70386: LD_VAR 0 2
70390: ARRAY
70391: PPUSH
70392: LD_INT 28
70394: PPUSH
70395: CALL_OW 325
70399: NOT
70400: AND
70401: IFFALSE 70405
// continue ;
70403: GO 70318
// for j in tmp do
70405: LD_ADDR_VAR 0 3
70409: PUSH
70410: LD_VAR 0 4
70414: PUSH
70415: FOR_IN
70416: IFFALSE 70475
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
70418: LD_VAR 0 3
70422: PUSH
70423: LD_EXP 62
70427: PUSH
70428: LD_VAR 0 2
70432: ARRAY
70433: PUSH
70434: LD_INT 1
70436: ARRAY
70437: IN
70438: NOT
70439: PUSH
70440: LD_VAR 0 3
70444: PUSH
70445: LD_EXP 62
70449: PUSH
70450: LD_VAR 0 2
70454: ARRAY
70455: PUSH
70456: LD_INT 2
70458: ARRAY
70459: IN
70460: NOT
70461: AND
70462: IFFALSE 70473
// ComSpaceTimeShoot ( j ) ;
70464: LD_VAR 0 3
70468: PPUSH
70469: CALL 15235 0 1
70473: GO 70415
70475: POP
70476: POP
// end ;
70477: GO 70318
70479: POP
70480: POP
// end ;
70481: LD_VAR 0 1
70485: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
70486: LD_INT 0
70488: PPUSH
70489: PPUSH
70490: PPUSH
70491: PPUSH
70492: PPUSH
70493: PPUSH
70494: PPUSH
70495: PPUSH
70496: PPUSH
// if not mc_bases then
70497: LD_EXP 59
70501: NOT
70502: IFFALSE 70506
// exit ;
70504: GO 71128
// for i = 1 to mc_bases do
70506: LD_ADDR_VAR 0 2
70510: PUSH
70511: DOUBLE
70512: LD_INT 1
70514: DEC
70515: ST_TO_ADDR
70516: LD_EXP 59
70520: PUSH
70521: FOR_TO
70522: IFFALSE 71126
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
70524: LD_EXP 94
70528: PUSH
70529: LD_VAR 0 2
70533: ARRAY
70534: NOT
70535: PUSH
70536: LD_INT 38
70538: PPUSH
70539: LD_EXP 85
70543: PUSH
70544: LD_VAR 0 2
70548: ARRAY
70549: PPUSH
70550: CALL_OW 321
70554: PUSH
70555: LD_INT 2
70557: NONEQUAL
70558: OR
70559: IFFALSE 70563
// continue ;
70561: GO 70521
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
70563: LD_ADDR_VAR 0 8
70567: PUSH
70568: LD_EXP 59
70572: PUSH
70573: LD_VAR 0 2
70577: ARRAY
70578: PPUSH
70579: LD_INT 30
70581: PUSH
70582: LD_INT 34
70584: PUSH
70585: EMPTY
70586: LIST
70587: LIST
70588: PPUSH
70589: CALL_OW 72
70593: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
70594: LD_ADDR_VAR 0 9
70598: PUSH
70599: LD_EXP 59
70603: PUSH
70604: LD_VAR 0 2
70608: ARRAY
70609: PPUSH
70610: LD_INT 25
70612: PUSH
70613: LD_INT 4
70615: PUSH
70616: EMPTY
70617: LIST
70618: LIST
70619: PPUSH
70620: CALL_OW 72
70624: PPUSH
70625: LD_INT 0
70627: PPUSH
70628: CALL 47799 0 2
70632: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
70633: LD_VAR 0 9
70637: NOT
70638: PUSH
70639: LD_VAR 0 8
70643: NOT
70644: OR
70645: PUSH
70646: LD_EXP 59
70650: PUSH
70651: LD_VAR 0 2
70655: ARRAY
70656: PPUSH
70657: LD_INT 124
70659: PPUSH
70660: CALL 47799 0 2
70664: OR
70665: IFFALSE 70669
// continue ;
70667: GO 70521
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
70669: LD_EXP 95
70673: PUSH
70674: LD_VAR 0 2
70678: ARRAY
70679: PUSH
70680: LD_EXP 94
70684: PUSH
70685: LD_VAR 0 2
70689: ARRAY
70690: LESS
70691: PUSH
70692: LD_EXP 95
70696: PUSH
70697: LD_VAR 0 2
70701: ARRAY
70702: PUSH
70703: LD_VAR 0 8
70707: LESS
70708: AND
70709: IFFALSE 71124
// begin tmp := sci [ 1 ] ;
70711: LD_ADDR_VAR 0 7
70715: PUSH
70716: LD_VAR 0 9
70720: PUSH
70721: LD_INT 1
70723: ARRAY
70724: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
70725: LD_VAR 0 7
70729: PPUSH
70730: LD_INT 124
70732: PPUSH
70733: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
70737: LD_ADDR_VAR 0 3
70741: PUSH
70742: DOUBLE
70743: LD_EXP 94
70747: PUSH
70748: LD_VAR 0 2
70752: ARRAY
70753: INC
70754: ST_TO_ADDR
70755: LD_EXP 94
70759: PUSH
70760: LD_VAR 0 2
70764: ARRAY
70765: PUSH
70766: FOR_DOWNTO
70767: IFFALSE 71110
// begin if IsInUnit ( tmp ) then
70769: LD_VAR 0 7
70773: PPUSH
70774: CALL_OW 310
70778: IFFALSE 70789
// ComExitBuilding ( tmp ) ;
70780: LD_VAR 0 7
70784: PPUSH
70785: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
70789: LD_INT 35
70791: PPUSH
70792: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
70796: LD_VAR 0 7
70800: PPUSH
70801: CALL_OW 310
70805: NOT
70806: PUSH
70807: LD_VAR 0 7
70811: PPUSH
70812: CALL_OW 314
70816: NOT
70817: AND
70818: IFFALSE 70789
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
70820: LD_ADDR_VAR 0 6
70824: PUSH
70825: LD_VAR 0 7
70829: PPUSH
70830: CALL_OW 250
70834: PUSH
70835: LD_VAR 0 7
70839: PPUSH
70840: CALL_OW 251
70844: PUSH
70845: EMPTY
70846: LIST
70847: LIST
70848: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
70849: LD_INT 35
70851: PPUSH
70852: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
70856: LD_ADDR_VAR 0 4
70860: PUSH
70861: LD_EXP 94
70865: PUSH
70866: LD_VAR 0 2
70870: ARRAY
70871: PUSH
70872: LD_VAR 0 3
70876: ARRAY
70877: PUSH
70878: LD_INT 1
70880: ARRAY
70881: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
70882: LD_ADDR_VAR 0 5
70886: PUSH
70887: LD_EXP 94
70891: PUSH
70892: LD_VAR 0 2
70896: ARRAY
70897: PUSH
70898: LD_VAR 0 3
70902: ARRAY
70903: PUSH
70904: LD_INT 2
70906: ARRAY
70907: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
70908: LD_VAR 0 7
70912: PPUSH
70913: LD_INT 10
70915: PPUSH
70916: CALL 21831 0 2
70920: PUSH
70921: LD_INT 4
70923: ARRAY
70924: IFFALSE 70962
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
70926: LD_VAR 0 7
70930: PPUSH
70931: LD_VAR 0 6
70935: PUSH
70936: LD_INT 1
70938: ARRAY
70939: PPUSH
70940: LD_VAR 0 6
70944: PUSH
70945: LD_INT 2
70947: ARRAY
70948: PPUSH
70949: CALL_OW 111
// wait ( 0 0$10 ) ;
70953: LD_INT 350
70955: PPUSH
70956: CALL_OW 67
// end else
70960: GO 70988
// begin ComMoveXY ( tmp , x , y ) ;
70962: LD_VAR 0 7
70966: PPUSH
70967: LD_VAR 0 4
70971: PPUSH
70972: LD_VAR 0 5
70976: PPUSH
70977: CALL_OW 111
// wait ( 0 0$3 ) ;
70981: LD_INT 105
70983: PPUSH
70984: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
70988: LD_VAR 0 7
70992: PPUSH
70993: LD_VAR 0 4
70997: PPUSH
70998: LD_VAR 0 5
71002: PPUSH
71003: CALL_OW 307
71007: IFFALSE 70849
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71009: LD_VAR 0 7
71013: PPUSH
71014: LD_VAR 0 4
71018: PPUSH
71019: LD_VAR 0 5
71023: PPUSH
71024: LD_VAR 0 8
71028: PUSH
71029: LD_VAR 0 3
71033: ARRAY
71034: PPUSH
71035: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71039: LD_INT 35
71041: PPUSH
71042: CALL_OW 67
// until not HasTask ( tmp ) ;
71046: LD_VAR 0 7
71050: PPUSH
71051: CALL_OW 314
71055: NOT
71056: IFFALSE 71039
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71058: LD_ADDR_EXP 95
71062: PUSH
71063: LD_EXP 95
71067: PPUSH
71068: LD_VAR 0 2
71072: PUSH
71073: LD_EXP 95
71077: PUSH
71078: LD_VAR 0 2
71082: ARRAY
71083: PUSH
71084: LD_INT 1
71086: PLUS
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PPUSH
71092: LD_VAR 0 8
71096: PUSH
71097: LD_VAR 0 3
71101: ARRAY
71102: PPUSH
71103: CALL 19238 0 3
71107: ST_TO_ADDR
// end ;
71108: GO 70766
71110: POP
71111: POP
// MC_Reset ( i , 124 ) ;
71112: LD_VAR 0 2
71116: PPUSH
71117: LD_INT 124
71119: PPUSH
71120: CALL 54731 0 2
// end ; end ;
71124: GO 70521
71126: POP
71127: POP
// end ;
71128: LD_VAR 0 1
71132: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71133: LD_INT 0
71135: PPUSH
71136: PPUSH
71137: PPUSH
// if not mc_bases then
71138: LD_EXP 59
71142: NOT
71143: IFFALSE 71147
// exit ;
71145: GO 71753
// for i = 1 to mc_bases do
71147: LD_ADDR_VAR 0 2
71151: PUSH
71152: DOUBLE
71153: LD_INT 1
71155: DEC
71156: ST_TO_ADDR
71157: LD_EXP 59
71161: PUSH
71162: FOR_TO
71163: IFFALSE 71751
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71165: LD_ADDR_VAR 0 3
71169: PUSH
71170: LD_EXP 59
71174: PUSH
71175: LD_VAR 0 2
71179: ARRAY
71180: PPUSH
71181: LD_INT 25
71183: PUSH
71184: LD_INT 4
71186: PUSH
71187: EMPTY
71188: LIST
71189: LIST
71190: PPUSH
71191: CALL_OW 72
71195: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71196: LD_VAR 0 3
71200: NOT
71201: PUSH
71202: LD_EXP 96
71206: PUSH
71207: LD_VAR 0 2
71211: ARRAY
71212: NOT
71213: OR
71214: PUSH
71215: LD_EXP 59
71219: PUSH
71220: LD_VAR 0 2
71224: ARRAY
71225: PPUSH
71226: LD_INT 2
71228: PUSH
71229: LD_INT 30
71231: PUSH
71232: LD_INT 0
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 30
71241: PUSH
71242: LD_INT 1
71244: PUSH
71245: EMPTY
71246: LIST
71247: LIST
71248: PUSH
71249: EMPTY
71250: LIST
71251: LIST
71252: LIST
71253: PPUSH
71254: CALL_OW 72
71258: NOT
71259: OR
71260: IFFALSE 71310
// begin if mc_deposits_finder [ i ] then
71262: LD_EXP 97
71266: PUSH
71267: LD_VAR 0 2
71271: ARRAY
71272: IFFALSE 71308
// begin MC_Reset ( i , 125 ) ;
71274: LD_VAR 0 2
71278: PPUSH
71279: LD_INT 125
71281: PPUSH
71282: CALL 54731 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71286: LD_ADDR_EXP 97
71290: PUSH
71291: LD_EXP 97
71295: PPUSH
71296: LD_VAR 0 2
71300: PPUSH
71301: EMPTY
71302: PPUSH
71303: CALL_OW 1
71307: ST_TO_ADDR
// end ; continue ;
71308: GO 71162
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
71310: LD_EXP 96
71314: PUSH
71315: LD_VAR 0 2
71319: ARRAY
71320: PUSH
71321: LD_INT 1
71323: ARRAY
71324: PUSH
71325: LD_INT 3
71327: ARRAY
71328: PUSH
71329: LD_INT 1
71331: EQUAL
71332: PUSH
71333: LD_INT 20
71335: PPUSH
71336: LD_EXP 85
71340: PUSH
71341: LD_VAR 0 2
71345: ARRAY
71346: PPUSH
71347: CALL_OW 321
71351: PUSH
71352: LD_INT 2
71354: NONEQUAL
71355: AND
71356: IFFALSE 71406
// begin if mc_deposits_finder [ i ] then
71358: LD_EXP 97
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: IFFALSE 71404
// begin MC_Reset ( i , 125 ) ;
71370: LD_VAR 0 2
71374: PPUSH
71375: LD_INT 125
71377: PPUSH
71378: CALL 54731 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
71382: LD_ADDR_EXP 97
71386: PUSH
71387: LD_EXP 97
71391: PPUSH
71392: LD_VAR 0 2
71396: PPUSH
71397: EMPTY
71398: PPUSH
71399: CALL_OW 1
71403: ST_TO_ADDR
// end ; continue ;
71404: GO 71162
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
71406: LD_EXP 96
71410: PUSH
71411: LD_VAR 0 2
71415: ARRAY
71416: PUSH
71417: LD_INT 1
71419: ARRAY
71420: PUSH
71421: LD_INT 1
71423: ARRAY
71424: PPUSH
71425: LD_EXP 96
71429: PUSH
71430: LD_VAR 0 2
71434: ARRAY
71435: PUSH
71436: LD_INT 1
71438: ARRAY
71439: PUSH
71440: LD_INT 2
71442: ARRAY
71443: PPUSH
71444: LD_EXP 85
71448: PUSH
71449: LD_VAR 0 2
71453: ARRAY
71454: PPUSH
71455: CALL_OW 440
71459: IFFALSE 71502
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
71461: LD_ADDR_EXP 96
71465: PUSH
71466: LD_EXP 96
71470: PPUSH
71471: LD_VAR 0 2
71475: PPUSH
71476: LD_EXP 96
71480: PUSH
71481: LD_VAR 0 2
71485: ARRAY
71486: PPUSH
71487: LD_INT 1
71489: PPUSH
71490: CALL_OW 3
71494: PPUSH
71495: CALL_OW 1
71499: ST_TO_ADDR
71500: GO 71749
// begin if not mc_deposits_finder [ i ] then
71502: LD_EXP 97
71506: PUSH
71507: LD_VAR 0 2
71511: ARRAY
71512: NOT
71513: IFFALSE 71565
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
71515: LD_ADDR_EXP 97
71519: PUSH
71520: LD_EXP 97
71524: PPUSH
71525: LD_VAR 0 2
71529: PPUSH
71530: LD_VAR 0 3
71534: PUSH
71535: LD_INT 1
71537: ARRAY
71538: PUSH
71539: EMPTY
71540: LIST
71541: PPUSH
71542: CALL_OW 1
71546: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
71547: LD_VAR 0 3
71551: PUSH
71552: LD_INT 1
71554: ARRAY
71555: PPUSH
71556: LD_INT 125
71558: PPUSH
71559: CALL_OW 109
// end else
71563: GO 71749
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
71565: LD_EXP 97
71569: PUSH
71570: LD_VAR 0 2
71574: ARRAY
71575: PUSH
71576: LD_INT 1
71578: ARRAY
71579: PPUSH
71580: CALL_OW 310
71584: IFFALSE 71607
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
71586: LD_EXP 97
71590: PUSH
71591: LD_VAR 0 2
71595: ARRAY
71596: PUSH
71597: LD_INT 1
71599: ARRAY
71600: PPUSH
71601: CALL_OW 122
71605: GO 71749
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
71607: LD_EXP 97
71611: PUSH
71612: LD_VAR 0 2
71616: ARRAY
71617: PUSH
71618: LD_INT 1
71620: ARRAY
71621: PPUSH
71622: CALL_OW 314
71626: NOT
71627: PUSH
71628: LD_EXP 97
71632: PUSH
71633: LD_VAR 0 2
71637: ARRAY
71638: PUSH
71639: LD_INT 1
71641: ARRAY
71642: PPUSH
71643: LD_EXP 96
71647: PUSH
71648: LD_VAR 0 2
71652: ARRAY
71653: PUSH
71654: LD_INT 1
71656: ARRAY
71657: PUSH
71658: LD_INT 1
71660: ARRAY
71661: PPUSH
71662: LD_EXP 96
71666: PUSH
71667: LD_VAR 0 2
71671: ARRAY
71672: PUSH
71673: LD_INT 1
71675: ARRAY
71676: PUSH
71677: LD_INT 2
71679: ARRAY
71680: PPUSH
71681: CALL_OW 297
71685: PUSH
71686: LD_INT 6
71688: GREATER
71689: AND
71690: IFFALSE 71749
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
71692: LD_EXP 97
71696: PUSH
71697: LD_VAR 0 2
71701: ARRAY
71702: PUSH
71703: LD_INT 1
71705: ARRAY
71706: PPUSH
71707: LD_EXP 96
71711: PUSH
71712: LD_VAR 0 2
71716: ARRAY
71717: PUSH
71718: LD_INT 1
71720: ARRAY
71721: PUSH
71722: LD_INT 1
71724: ARRAY
71725: PPUSH
71726: LD_EXP 96
71730: PUSH
71731: LD_VAR 0 2
71735: ARRAY
71736: PUSH
71737: LD_INT 1
71739: ARRAY
71740: PUSH
71741: LD_INT 2
71743: ARRAY
71744: PPUSH
71745: CALL_OW 111
// end ; end ; end ;
71749: GO 71162
71751: POP
71752: POP
// end ;
71753: LD_VAR 0 1
71757: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
71758: LD_INT 0
71760: PPUSH
71761: PPUSH
71762: PPUSH
71763: PPUSH
71764: PPUSH
71765: PPUSH
71766: PPUSH
71767: PPUSH
71768: PPUSH
71769: PPUSH
71770: PPUSH
// if not mc_bases then
71771: LD_EXP 59
71775: NOT
71776: IFFALSE 71780
// exit ;
71778: GO 72720
// for i = 1 to mc_bases do
71780: LD_ADDR_VAR 0 2
71784: PUSH
71785: DOUBLE
71786: LD_INT 1
71788: DEC
71789: ST_TO_ADDR
71790: LD_EXP 59
71794: PUSH
71795: FOR_TO
71796: IFFALSE 72718
// begin if not mc_bases [ i ] or mc_scan [ i ] then
71798: LD_EXP 59
71802: PUSH
71803: LD_VAR 0 2
71807: ARRAY
71808: NOT
71809: PUSH
71810: LD_EXP 82
71814: PUSH
71815: LD_VAR 0 2
71819: ARRAY
71820: OR
71821: IFFALSE 71825
// continue ;
71823: GO 71795
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
71825: LD_ADDR_VAR 0 7
71829: PUSH
71830: LD_EXP 59
71834: PUSH
71835: LD_VAR 0 2
71839: ARRAY
71840: PUSH
71841: LD_INT 1
71843: ARRAY
71844: PPUSH
71845: CALL_OW 248
71849: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
71850: LD_VAR 0 7
71854: PUSH
71855: LD_INT 3
71857: EQUAL
71858: PUSH
71859: LD_EXP 78
71863: PUSH
71864: LD_VAR 0 2
71868: ARRAY
71869: PUSH
71870: LD_EXP 81
71874: PUSH
71875: LD_VAR 0 2
71879: ARRAY
71880: UNION
71881: PPUSH
71882: LD_INT 33
71884: PUSH
71885: LD_INT 2
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PPUSH
71892: CALL_OW 72
71896: NOT
71897: OR
71898: IFFALSE 71902
// continue ;
71900: GO 71795
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
71902: LD_ADDR_VAR 0 9
71906: PUSH
71907: LD_EXP 59
71911: PUSH
71912: LD_VAR 0 2
71916: ARRAY
71917: PPUSH
71918: LD_INT 30
71920: PUSH
71921: LD_INT 36
71923: PUSH
71924: EMPTY
71925: LIST
71926: LIST
71927: PPUSH
71928: CALL_OW 72
71932: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
71933: LD_ADDR_VAR 0 10
71937: PUSH
71938: LD_EXP 78
71942: PUSH
71943: LD_VAR 0 2
71947: ARRAY
71948: PPUSH
71949: LD_INT 34
71951: PUSH
71952: LD_INT 31
71954: PUSH
71955: EMPTY
71956: LIST
71957: LIST
71958: PPUSH
71959: CALL_OW 72
71963: ST_TO_ADDR
// if not cts and not mcts then
71964: LD_VAR 0 9
71968: NOT
71969: PUSH
71970: LD_VAR 0 10
71974: NOT
71975: AND
71976: IFFALSE 71980
// continue ;
71978: GO 71795
// x := cts ;
71980: LD_ADDR_VAR 0 11
71984: PUSH
71985: LD_VAR 0 9
71989: ST_TO_ADDR
// if not x then
71990: LD_VAR 0 11
71994: NOT
71995: IFFALSE 72007
// x := mcts ;
71997: LD_ADDR_VAR 0 11
72001: PUSH
72002: LD_VAR 0 10
72006: ST_TO_ADDR
// if not x then
72007: LD_VAR 0 11
72011: NOT
72012: IFFALSE 72016
// continue ;
72014: GO 71795
// if mc_remote_driver [ i ] then
72016: LD_EXP 99
72020: PUSH
72021: LD_VAR 0 2
72025: ARRAY
72026: IFFALSE 72413
// for j in mc_remote_driver [ i ] do
72028: LD_ADDR_VAR 0 3
72032: PUSH
72033: LD_EXP 99
72037: PUSH
72038: LD_VAR 0 2
72042: ARRAY
72043: PUSH
72044: FOR_IN
72045: IFFALSE 72411
// begin if GetClass ( j ) <> 3 then
72047: LD_VAR 0 3
72051: PPUSH
72052: CALL_OW 257
72056: PUSH
72057: LD_INT 3
72059: NONEQUAL
72060: IFFALSE 72113
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72062: LD_ADDR_EXP 99
72066: PUSH
72067: LD_EXP 99
72071: PPUSH
72072: LD_VAR 0 2
72076: PPUSH
72077: LD_EXP 99
72081: PUSH
72082: LD_VAR 0 2
72086: ARRAY
72087: PUSH
72088: LD_VAR 0 3
72092: DIFF
72093: PPUSH
72094: CALL_OW 1
72098: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72099: LD_VAR 0 3
72103: PPUSH
72104: LD_INT 0
72106: PPUSH
72107: CALL_OW 109
// continue ;
72111: GO 72044
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72113: LD_EXP 78
72117: PUSH
72118: LD_VAR 0 2
72122: ARRAY
72123: PPUSH
72124: LD_INT 34
72126: PUSH
72127: LD_INT 31
72129: PUSH
72130: EMPTY
72131: LIST
72132: LIST
72133: PUSH
72134: LD_INT 58
72136: PUSH
72137: EMPTY
72138: LIST
72139: PUSH
72140: EMPTY
72141: LIST
72142: LIST
72143: PPUSH
72144: CALL_OW 72
72148: PUSH
72149: LD_VAR 0 3
72153: PPUSH
72154: CALL 47887 0 1
72158: NOT
72159: AND
72160: IFFALSE 72231
// begin if IsInUnit ( j ) then
72162: LD_VAR 0 3
72166: PPUSH
72167: CALL_OW 310
72171: IFFALSE 72182
// ComExitBuilding ( j ) ;
72173: LD_VAR 0 3
72177: PPUSH
72178: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72182: LD_VAR 0 3
72186: PPUSH
72187: LD_EXP 78
72191: PUSH
72192: LD_VAR 0 2
72196: ARRAY
72197: PPUSH
72198: LD_INT 34
72200: PUSH
72201: LD_INT 31
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 58
72210: PUSH
72211: EMPTY
72212: LIST
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PPUSH
72218: CALL_OW 72
72222: PUSH
72223: LD_INT 1
72225: ARRAY
72226: PPUSH
72227: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72231: LD_VAR 0 3
72235: PPUSH
72236: CALL_OW 310
72240: NOT
72241: PUSH
72242: LD_VAR 0 3
72246: PPUSH
72247: CALL_OW 310
72251: PPUSH
72252: CALL_OW 266
72256: PUSH
72257: LD_INT 36
72259: NONEQUAL
72260: PUSH
72261: LD_VAR 0 3
72265: PPUSH
72266: CALL 47887 0 1
72270: NOT
72271: AND
72272: OR
72273: IFFALSE 72409
// begin if IsInUnit ( j ) then
72275: LD_VAR 0 3
72279: PPUSH
72280: CALL_OW 310
72284: IFFALSE 72295
// ComExitBuilding ( j ) ;
72286: LD_VAR 0 3
72290: PPUSH
72291: CALL_OW 122
// ct := 0 ;
72295: LD_ADDR_VAR 0 8
72299: PUSH
72300: LD_INT 0
72302: ST_TO_ADDR
// for k in x do
72303: LD_ADDR_VAR 0 4
72307: PUSH
72308: LD_VAR 0 11
72312: PUSH
72313: FOR_IN
72314: IFFALSE 72387
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
72316: LD_VAR 0 4
72320: PPUSH
72321: CALL_OW 264
72325: PUSH
72326: LD_INT 31
72328: EQUAL
72329: PUSH
72330: LD_VAR 0 4
72334: PPUSH
72335: CALL_OW 311
72339: NOT
72340: AND
72341: PUSH
72342: LD_VAR 0 4
72346: PPUSH
72347: CALL_OW 266
72351: PUSH
72352: LD_INT 36
72354: EQUAL
72355: PUSH
72356: LD_VAR 0 4
72360: PPUSH
72361: CALL_OW 313
72365: PUSH
72366: LD_INT 3
72368: LESS
72369: AND
72370: OR
72371: IFFALSE 72385
// begin ct := k ;
72373: LD_ADDR_VAR 0 8
72377: PUSH
72378: LD_VAR 0 4
72382: ST_TO_ADDR
// break ;
72383: GO 72387
// end ;
72385: GO 72313
72387: POP
72388: POP
// if ct then
72389: LD_VAR 0 8
72393: IFFALSE 72409
// ComEnterUnit ( j , ct ) ;
72395: LD_VAR 0 3
72399: PPUSH
72400: LD_VAR 0 8
72404: PPUSH
72405: CALL_OW 120
// end ; end ;
72409: GO 72044
72411: POP
72412: POP
// places := 0 ;
72413: LD_ADDR_VAR 0 5
72417: PUSH
72418: LD_INT 0
72420: ST_TO_ADDR
// for j = 1 to x do
72421: LD_ADDR_VAR 0 3
72425: PUSH
72426: DOUBLE
72427: LD_INT 1
72429: DEC
72430: ST_TO_ADDR
72431: LD_VAR 0 11
72435: PUSH
72436: FOR_TO
72437: IFFALSE 72513
// if GetWeapon ( x [ j ] ) = ar_control_tower then
72439: LD_VAR 0 11
72443: PUSH
72444: LD_VAR 0 3
72448: ARRAY
72449: PPUSH
72450: CALL_OW 264
72454: PUSH
72455: LD_INT 31
72457: EQUAL
72458: IFFALSE 72476
// places := places + 1 else
72460: LD_ADDR_VAR 0 5
72464: PUSH
72465: LD_VAR 0 5
72469: PUSH
72470: LD_INT 1
72472: PLUS
72473: ST_TO_ADDR
72474: GO 72511
// if GetBType ( x [ j ] ) = b_control_tower then
72476: LD_VAR 0 11
72480: PUSH
72481: LD_VAR 0 3
72485: ARRAY
72486: PPUSH
72487: CALL_OW 266
72491: PUSH
72492: LD_INT 36
72494: EQUAL
72495: IFFALSE 72511
// places := places + 3 ;
72497: LD_ADDR_VAR 0 5
72501: PUSH
72502: LD_VAR 0 5
72506: PUSH
72507: LD_INT 3
72509: PLUS
72510: ST_TO_ADDR
72511: GO 72436
72513: POP
72514: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
72515: LD_VAR 0 5
72519: PUSH
72520: LD_INT 0
72522: EQUAL
72523: PUSH
72524: LD_VAR 0 5
72528: PUSH
72529: LD_EXP 99
72533: PUSH
72534: LD_VAR 0 2
72538: ARRAY
72539: LESSEQUAL
72540: OR
72541: IFFALSE 72545
// continue ;
72543: GO 71795
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
72545: LD_ADDR_VAR 0 6
72549: PUSH
72550: LD_EXP 59
72554: PUSH
72555: LD_VAR 0 2
72559: ARRAY
72560: PPUSH
72561: LD_INT 25
72563: PUSH
72564: LD_INT 3
72566: PUSH
72567: EMPTY
72568: LIST
72569: LIST
72570: PPUSH
72571: CALL_OW 72
72575: PUSH
72576: LD_EXP 99
72580: PUSH
72581: LD_VAR 0 2
72585: ARRAY
72586: DIFF
72587: PPUSH
72588: LD_INT 3
72590: PPUSH
72591: CALL 48787 0 2
72595: ST_TO_ADDR
// for j in tmp do
72596: LD_ADDR_VAR 0 3
72600: PUSH
72601: LD_VAR 0 6
72605: PUSH
72606: FOR_IN
72607: IFFALSE 72642
// if GetTag ( j ) > 0 then
72609: LD_VAR 0 3
72613: PPUSH
72614: CALL_OW 110
72618: PUSH
72619: LD_INT 0
72621: GREATER
72622: IFFALSE 72640
// tmp := tmp diff j ;
72624: LD_ADDR_VAR 0 6
72628: PUSH
72629: LD_VAR 0 6
72633: PUSH
72634: LD_VAR 0 3
72638: DIFF
72639: ST_TO_ADDR
72640: GO 72606
72642: POP
72643: POP
// if not tmp then
72644: LD_VAR 0 6
72648: NOT
72649: IFFALSE 72653
// continue ;
72651: GO 71795
// if places then
72653: LD_VAR 0 5
72657: IFFALSE 72716
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
72659: LD_ADDR_EXP 99
72663: PUSH
72664: LD_EXP 99
72668: PPUSH
72669: LD_VAR 0 2
72673: PPUSH
72674: LD_EXP 99
72678: PUSH
72679: LD_VAR 0 2
72683: ARRAY
72684: PUSH
72685: LD_VAR 0 6
72689: PUSH
72690: LD_INT 1
72692: ARRAY
72693: UNION
72694: PPUSH
72695: CALL_OW 1
72699: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
72700: LD_VAR 0 6
72704: PUSH
72705: LD_INT 1
72707: ARRAY
72708: PPUSH
72709: LD_INT 126
72711: PPUSH
72712: CALL_OW 109
// end ; end ;
72716: GO 71795
72718: POP
72719: POP
// end ;
72720: LD_VAR 0 1
72724: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
72725: LD_INT 0
72727: PPUSH
72728: PPUSH
72729: PPUSH
72730: PPUSH
72731: PPUSH
72732: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
72733: LD_VAR 0 1
72737: NOT
72738: PUSH
72739: LD_VAR 0 2
72743: NOT
72744: OR
72745: PUSH
72746: LD_VAR 0 3
72750: NOT
72751: OR
72752: PUSH
72753: LD_VAR 0 4
72757: PUSH
72758: LD_INT 1
72760: PUSH
72761: LD_INT 2
72763: PUSH
72764: LD_INT 3
72766: PUSH
72767: LD_INT 4
72769: PUSH
72770: LD_INT 5
72772: PUSH
72773: LD_INT 8
72775: PUSH
72776: LD_INT 9
72778: PUSH
72779: LD_INT 15
72781: PUSH
72782: LD_INT 16
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: LIST
72789: LIST
72790: LIST
72791: LIST
72792: LIST
72793: LIST
72794: LIST
72795: IN
72796: NOT
72797: OR
72798: IFFALSE 72802
// exit ;
72800: GO 73702
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
72802: LD_ADDR_VAR 0 2
72806: PUSH
72807: LD_VAR 0 2
72811: PPUSH
72812: LD_INT 21
72814: PUSH
72815: LD_INT 3
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: PUSH
72822: LD_INT 24
72824: PUSH
72825: LD_INT 250
72827: PUSH
72828: EMPTY
72829: LIST
72830: LIST
72831: PUSH
72832: EMPTY
72833: LIST
72834: LIST
72835: PPUSH
72836: CALL_OW 72
72840: ST_TO_ADDR
// case class of 1 , 15 :
72841: LD_VAR 0 4
72845: PUSH
72846: LD_INT 1
72848: DOUBLE
72849: EQUAL
72850: IFTRUE 72860
72852: LD_INT 15
72854: DOUBLE
72855: EQUAL
72856: IFTRUE 72860
72858: GO 72945
72860: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
72861: LD_ADDR_VAR 0 8
72865: PUSH
72866: LD_VAR 0 2
72870: PPUSH
72871: LD_INT 2
72873: PUSH
72874: LD_INT 30
72876: PUSH
72877: LD_INT 32
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 30
72886: PUSH
72887: LD_INT 31
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: EMPTY
72895: LIST
72896: LIST
72897: LIST
72898: PPUSH
72899: CALL_OW 72
72903: PUSH
72904: LD_VAR 0 2
72908: PPUSH
72909: LD_INT 2
72911: PUSH
72912: LD_INT 30
72914: PUSH
72915: LD_INT 4
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: PUSH
72922: LD_INT 30
72924: PUSH
72925: LD_INT 5
72927: PUSH
72928: EMPTY
72929: LIST
72930: LIST
72931: PUSH
72932: EMPTY
72933: LIST
72934: LIST
72935: LIST
72936: PPUSH
72937: CALL_OW 72
72941: ADD
72942: ST_TO_ADDR
72943: GO 73191
72945: LD_INT 2
72947: DOUBLE
72948: EQUAL
72949: IFTRUE 72959
72951: LD_INT 16
72953: DOUBLE
72954: EQUAL
72955: IFTRUE 72959
72957: GO 73005
72959: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
72960: LD_ADDR_VAR 0 8
72964: PUSH
72965: LD_VAR 0 2
72969: PPUSH
72970: LD_INT 2
72972: PUSH
72973: LD_INT 30
72975: PUSH
72976: LD_INT 0
72978: PUSH
72979: EMPTY
72980: LIST
72981: LIST
72982: PUSH
72983: LD_INT 30
72985: PUSH
72986: LD_INT 1
72988: PUSH
72989: EMPTY
72990: LIST
72991: LIST
72992: PUSH
72993: EMPTY
72994: LIST
72995: LIST
72996: LIST
72997: PPUSH
72998: CALL_OW 72
73002: ST_TO_ADDR
73003: GO 73191
73005: LD_INT 3
73007: DOUBLE
73008: EQUAL
73009: IFTRUE 73013
73011: GO 73059
73013: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73014: LD_ADDR_VAR 0 8
73018: PUSH
73019: LD_VAR 0 2
73023: PPUSH
73024: LD_INT 2
73026: PUSH
73027: LD_INT 30
73029: PUSH
73030: LD_INT 2
73032: PUSH
73033: EMPTY
73034: LIST
73035: LIST
73036: PUSH
73037: LD_INT 30
73039: PUSH
73040: LD_INT 3
73042: PUSH
73043: EMPTY
73044: LIST
73045: LIST
73046: PUSH
73047: EMPTY
73048: LIST
73049: LIST
73050: LIST
73051: PPUSH
73052: CALL_OW 72
73056: ST_TO_ADDR
73057: GO 73191
73059: LD_INT 4
73061: DOUBLE
73062: EQUAL
73063: IFTRUE 73067
73065: GO 73124
73067: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73068: LD_ADDR_VAR 0 8
73072: PUSH
73073: LD_VAR 0 2
73077: PPUSH
73078: LD_INT 2
73080: PUSH
73081: LD_INT 30
73083: PUSH
73084: LD_INT 6
73086: PUSH
73087: EMPTY
73088: LIST
73089: LIST
73090: PUSH
73091: LD_INT 30
73093: PUSH
73094: LD_INT 7
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 30
73103: PUSH
73104: LD_INT 8
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: LIST
73115: LIST
73116: PPUSH
73117: CALL_OW 72
73121: ST_TO_ADDR
73122: GO 73191
73124: LD_INT 5
73126: DOUBLE
73127: EQUAL
73128: IFTRUE 73144
73130: LD_INT 8
73132: DOUBLE
73133: EQUAL
73134: IFTRUE 73144
73136: LD_INT 9
73138: DOUBLE
73139: EQUAL
73140: IFTRUE 73144
73142: GO 73190
73144: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73145: LD_ADDR_VAR 0 8
73149: PUSH
73150: LD_VAR 0 2
73154: PPUSH
73155: LD_INT 2
73157: PUSH
73158: LD_INT 30
73160: PUSH
73161: LD_INT 4
73163: PUSH
73164: EMPTY
73165: LIST
73166: LIST
73167: PUSH
73168: LD_INT 30
73170: PUSH
73171: LD_INT 5
73173: PUSH
73174: EMPTY
73175: LIST
73176: LIST
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: LIST
73182: PPUSH
73183: CALL_OW 72
73187: ST_TO_ADDR
73188: GO 73191
73190: POP
// if not tmp then
73191: LD_VAR 0 8
73195: NOT
73196: IFFALSE 73200
// exit ;
73198: GO 73702
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73200: LD_VAR 0 4
73204: PUSH
73205: LD_INT 1
73207: PUSH
73208: LD_INT 15
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: IN
73215: PUSH
73216: LD_EXP 68
73220: PUSH
73221: LD_VAR 0 1
73225: ARRAY
73226: AND
73227: IFFALSE 73383
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73229: LD_ADDR_VAR 0 9
73233: PUSH
73234: LD_EXP 68
73238: PUSH
73239: LD_VAR 0 1
73243: ARRAY
73244: PUSH
73245: LD_INT 1
73247: ARRAY
73248: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
73249: LD_VAR 0 9
73253: PUSH
73254: LD_EXP 69
73258: PUSH
73259: LD_VAR 0 1
73263: ARRAY
73264: IN
73265: NOT
73266: IFFALSE 73381
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
73268: LD_ADDR_EXP 69
73272: PUSH
73273: LD_EXP 69
73277: PPUSH
73278: LD_VAR 0 1
73282: PUSH
73283: LD_EXP 69
73287: PUSH
73288: LD_VAR 0 1
73292: ARRAY
73293: PUSH
73294: LD_INT 1
73296: PLUS
73297: PUSH
73298: EMPTY
73299: LIST
73300: LIST
73301: PPUSH
73302: LD_VAR 0 9
73306: PPUSH
73307: CALL 19238 0 3
73311: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
73312: LD_ADDR_EXP 68
73316: PUSH
73317: LD_EXP 68
73321: PPUSH
73322: LD_VAR 0 1
73326: PPUSH
73327: LD_EXP 68
73331: PUSH
73332: LD_VAR 0 1
73336: ARRAY
73337: PUSH
73338: LD_VAR 0 9
73342: DIFF
73343: PPUSH
73344: CALL_OW 1
73348: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
73349: LD_VAR 0 3
73353: PPUSH
73354: LD_EXP 69
73358: PUSH
73359: LD_VAR 0 1
73363: ARRAY
73364: PUSH
73365: LD_EXP 69
73369: PUSH
73370: LD_VAR 0 1
73374: ARRAY
73375: ARRAY
73376: PPUSH
73377: CALL_OW 120
// end ; exit ;
73381: GO 73702
// end ; if tmp > 1 then
73383: LD_VAR 0 8
73387: PUSH
73388: LD_INT 1
73390: GREATER
73391: IFFALSE 73495
// for i = 2 to tmp do
73393: LD_ADDR_VAR 0 6
73397: PUSH
73398: DOUBLE
73399: LD_INT 2
73401: DEC
73402: ST_TO_ADDR
73403: LD_VAR 0 8
73407: PUSH
73408: FOR_TO
73409: IFFALSE 73493
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
73411: LD_VAR 0 8
73415: PUSH
73416: LD_VAR 0 6
73420: ARRAY
73421: PPUSH
73422: CALL_OW 461
73426: PUSH
73427: LD_INT 6
73429: EQUAL
73430: IFFALSE 73491
// begin x := tmp [ i ] ;
73432: LD_ADDR_VAR 0 9
73436: PUSH
73437: LD_VAR 0 8
73441: PUSH
73442: LD_VAR 0 6
73446: ARRAY
73447: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
73448: LD_ADDR_VAR 0 8
73452: PUSH
73453: LD_VAR 0 8
73457: PPUSH
73458: LD_VAR 0 6
73462: PPUSH
73463: CALL_OW 3
73467: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
73468: LD_ADDR_VAR 0 8
73472: PUSH
73473: LD_VAR 0 8
73477: PPUSH
73478: LD_INT 1
73480: PPUSH
73481: LD_VAR 0 9
73485: PPUSH
73486: CALL_OW 2
73490: ST_TO_ADDR
// end ;
73491: GO 73408
73493: POP
73494: POP
// for i in tmp do
73495: LD_ADDR_VAR 0 6
73499: PUSH
73500: LD_VAR 0 8
73504: PUSH
73505: FOR_IN
73506: IFFALSE 73575
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
73508: LD_VAR 0 6
73512: PPUSH
73513: CALL_OW 313
73517: PUSH
73518: LD_INT 6
73520: LESS
73521: PUSH
73522: LD_VAR 0 6
73526: PPUSH
73527: CALL_OW 266
73531: PUSH
73532: LD_INT 31
73534: PUSH
73535: LD_INT 32
73537: PUSH
73538: EMPTY
73539: LIST
73540: LIST
73541: IN
73542: NOT
73543: AND
73544: PUSH
73545: LD_VAR 0 6
73549: PPUSH
73550: CALL_OW 313
73554: PUSH
73555: LD_INT 0
73557: EQUAL
73558: OR
73559: IFFALSE 73573
// begin j := i ;
73561: LD_ADDR_VAR 0 7
73565: PUSH
73566: LD_VAR 0 6
73570: ST_TO_ADDR
// break ;
73571: GO 73575
// end ; end ;
73573: GO 73505
73575: POP
73576: POP
// if j then
73577: LD_VAR 0 7
73581: IFFALSE 73599
// ComEnterUnit ( unit , j ) else
73583: LD_VAR 0 3
73587: PPUSH
73588: LD_VAR 0 7
73592: PPUSH
73593: CALL_OW 120
73597: GO 73702
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
73599: LD_ADDR_VAR 0 10
73603: PUSH
73604: LD_VAR 0 2
73608: PPUSH
73609: LD_INT 2
73611: PUSH
73612: LD_INT 30
73614: PUSH
73615: LD_INT 0
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: PUSH
73622: LD_INT 30
73624: PUSH
73625: LD_INT 1
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: EMPTY
73633: LIST
73634: LIST
73635: LIST
73636: PPUSH
73637: CALL_OW 72
73641: ST_TO_ADDR
// if depot then
73642: LD_VAR 0 10
73646: IFFALSE 73702
// begin depot := NearestUnitToUnit ( depot , unit ) ;
73648: LD_ADDR_VAR 0 10
73652: PUSH
73653: LD_VAR 0 10
73657: PPUSH
73658: LD_VAR 0 3
73662: PPUSH
73663: CALL_OW 74
73667: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
73668: LD_VAR 0 3
73672: PPUSH
73673: LD_VAR 0 10
73677: PPUSH
73678: CALL_OW 296
73682: PUSH
73683: LD_INT 10
73685: GREATER
73686: IFFALSE 73702
// ComStandNearbyBuilding ( unit , depot ) ;
73688: LD_VAR 0 3
73692: PPUSH
73693: LD_VAR 0 10
73697: PPUSH
73698: CALL 15852 0 2
// end ; end ; end ;
73702: LD_VAR 0 5
73706: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
73707: LD_INT 0
73709: PPUSH
73710: PPUSH
73711: PPUSH
73712: PPUSH
// if not mc_bases then
73713: LD_EXP 59
73717: NOT
73718: IFFALSE 73722
// exit ;
73720: GO 73961
// for i = 1 to mc_bases do
73722: LD_ADDR_VAR 0 2
73726: PUSH
73727: DOUBLE
73728: LD_INT 1
73730: DEC
73731: ST_TO_ADDR
73732: LD_EXP 59
73736: PUSH
73737: FOR_TO
73738: IFFALSE 73959
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
73740: LD_ADDR_VAR 0 4
73744: PUSH
73745: LD_EXP 59
73749: PUSH
73750: LD_VAR 0 2
73754: ARRAY
73755: PPUSH
73756: LD_INT 21
73758: PUSH
73759: LD_INT 1
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PPUSH
73766: CALL_OW 72
73770: PUSH
73771: LD_EXP 88
73775: PUSH
73776: LD_VAR 0 2
73780: ARRAY
73781: UNION
73782: ST_TO_ADDR
// if not tmp then
73783: LD_VAR 0 4
73787: NOT
73788: IFFALSE 73792
// continue ;
73790: GO 73737
// for j in tmp do
73792: LD_ADDR_VAR 0 3
73796: PUSH
73797: LD_VAR 0 4
73801: PUSH
73802: FOR_IN
73803: IFFALSE 73955
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
73805: LD_VAR 0 3
73809: PPUSH
73810: CALL_OW 110
73814: NOT
73815: PUSH
73816: LD_VAR 0 3
73820: PPUSH
73821: CALL_OW 314
73825: NOT
73826: AND
73827: PUSH
73828: LD_VAR 0 3
73832: PPUSH
73833: CALL_OW 311
73837: NOT
73838: AND
73839: PUSH
73840: LD_VAR 0 3
73844: PPUSH
73845: CALL_OW 310
73849: NOT
73850: AND
73851: PUSH
73852: LD_VAR 0 3
73856: PUSH
73857: LD_EXP 62
73861: PUSH
73862: LD_VAR 0 2
73866: ARRAY
73867: PUSH
73868: LD_INT 1
73870: ARRAY
73871: IN
73872: NOT
73873: AND
73874: PUSH
73875: LD_VAR 0 3
73879: PUSH
73880: LD_EXP 62
73884: PUSH
73885: LD_VAR 0 2
73889: ARRAY
73890: PUSH
73891: LD_INT 2
73893: ARRAY
73894: IN
73895: NOT
73896: AND
73897: PUSH
73898: LD_VAR 0 3
73902: PUSH
73903: LD_EXP 71
73907: PUSH
73908: LD_VAR 0 2
73912: ARRAY
73913: IN
73914: NOT
73915: AND
73916: IFFALSE 73953
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
73918: LD_VAR 0 2
73922: PPUSH
73923: LD_EXP 59
73927: PUSH
73928: LD_VAR 0 2
73932: ARRAY
73933: PPUSH
73934: LD_VAR 0 3
73938: PPUSH
73939: LD_VAR 0 3
73943: PPUSH
73944: CALL_OW 257
73948: PPUSH
73949: CALL 72725 0 4
// end ;
73953: GO 73802
73955: POP
73956: POP
// end ;
73957: GO 73737
73959: POP
73960: POP
// end ;
73961: LD_VAR 0 1
73965: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
73966: LD_INT 0
73968: PPUSH
73969: PPUSH
73970: PPUSH
73971: PPUSH
73972: PPUSH
73973: PPUSH
// if not mc_bases [ base ] then
73974: LD_EXP 59
73978: PUSH
73979: LD_VAR 0 1
73983: ARRAY
73984: NOT
73985: IFFALSE 73989
// exit ;
73987: GO 74171
// tmp := [ ] ;
73989: LD_ADDR_VAR 0 6
73993: PUSH
73994: EMPTY
73995: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
73996: LD_ADDR_VAR 0 7
74000: PUSH
74001: LD_VAR 0 3
74005: PPUSH
74006: LD_INT 0
74008: PPUSH
74009: CALL_OW 517
74013: ST_TO_ADDR
// if not list then
74014: LD_VAR 0 7
74018: NOT
74019: IFFALSE 74023
// exit ;
74021: GO 74171
// for i = 1 to amount do
74023: LD_ADDR_VAR 0 5
74027: PUSH
74028: DOUBLE
74029: LD_INT 1
74031: DEC
74032: ST_TO_ADDR
74033: LD_VAR 0 2
74037: PUSH
74038: FOR_TO
74039: IFFALSE 74119
// begin x := rand ( 1 , list [ 1 ] ) ;
74041: LD_ADDR_VAR 0 8
74045: PUSH
74046: LD_INT 1
74048: PPUSH
74049: LD_VAR 0 7
74053: PUSH
74054: LD_INT 1
74056: ARRAY
74057: PPUSH
74058: CALL_OW 12
74062: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74063: LD_ADDR_VAR 0 6
74067: PUSH
74068: LD_VAR 0 6
74072: PPUSH
74073: LD_VAR 0 5
74077: PPUSH
74078: LD_VAR 0 7
74082: PUSH
74083: LD_INT 1
74085: ARRAY
74086: PUSH
74087: LD_VAR 0 8
74091: ARRAY
74092: PUSH
74093: LD_VAR 0 7
74097: PUSH
74098: LD_INT 2
74100: ARRAY
74101: PUSH
74102: LD_VAR 0 8
74106: ARRAY
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PPUSH
74112: CALL_OW 1
74116: ST_TO_ADDR
// end ;
74117: GO 74038
74119: POP
74120: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74121: LD_ADDR_EXP 72
74125: PUSH
74126: LD_EXP 72
74130: PPUSH
74131: LD_VAR 0 1
74135: PPUSH
74136: LD_VAR 0 6
74140: PPUSH
74141: CALL_OW 1
74145: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74146: LD_ADDR_EXP 74
74150: PUSH
74151: LD_EXP 74
74155: PPUSH
74156: LD_VAR 0 1
74160: PPUSH
74161: LD_VAR 0 3
74165: PPUSH
74166: CALL_OW 1
74170: ST_TO_ADDR
// end ;
74171: LD_VAR 0 4
74175: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74176: LD_INT 0
74178: PPUSH
// if not mc_bases [ base ] then
74179: LD_EXP 59
74183: PUSH
74184: LD_VAR 0 1
74188: ARRAY
74189: NOT
74190: IFFALSE 74194
// exit ;
74192: GO 74219
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74194: LD_ADDR_EXP 64
74198: PUSH
74199: LD_EXP 64
74203: PPUSH
74204: LD_VAR 0 1
74208: PPUSH
74209: LD_VAR 0 2
74213: PPUSH
74214: CALL_OW 1
74218: ST_TO_ADDR
// end ;
74219: LD_VAR 0 3
74223: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74224: LD_INT 0
74226: PPUSH
// if not mc_bases [ base ] then
74227: LD_EXP 59
74231: PUSH
74232: LD_VAR 0 1
74236: ARRAY
74237: NOT
74238: IFFALSE 74242
// exit ;
74240: GO 74279
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
74242: LD_ADDR_EXP 64
74246: PUSH
74247: LD_EXP 64
74251: PPUSH
74252: LD_VAR 0 1
74256: PPUSH
74257: LD_EXP 64
74261: PUSH
74262: LD_VAR 0 1
74266: ARRAY
74267: PUSH
74268: LD_VAR 0 2
74272: UNION
74273: PPUSH
74274: CALL_OW 1
74278: ST_TO_ADDR
// end ;
74279: LD_VAR 0 3
74283: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
74284: LD_INT 0
74286: PPUSH
// if not mc_bases [ base ] then
74287: LD_EXP 59
74291: PUSH
74292: LD_VAR 0 1
74296: ARRAY
74297: NOT
74298: IFFALSE 74302
// exit ;
74300: GO 74327
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
74302: LD_ADDR_EXP 80
74306: PUSH
74307: LD_EXP 80
74311: PPUSH
74312: LD_VAR 0 1
74316: PPUSH
74317: LD_VAR 0 2
74321: PPUSH
74322: CALL_OW 1
74326: ST_TO_ADDR
// end ;
74327: LD_VAR 0 3
74331: RET
// export function MC_InsertProduceList ( base , components ) ; begin
74332: LD_INT 0
74334: PPUSH
// if not mc_bases [ base ] then
74335: LD_EXP 59
74339: PUSH
74340: LD_VAR 0 1
74344: ARRAY
74345: NOT
74346: IFFALSE 74350
// exit ;
74348: GO 74387
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
74350: LD_ADDR_EXP 80
74354: PUSH
74355: LD_EXP 80
74359: PPUSH
74360: LD_VAR 0 1
74364: PPUSH
74365: LD_EXP 80
74369: PUSH
74370: LD_VAR 0 1
74374: ARRAY
74375: PUSH
74376: LD_VAR 0 2
74380: ADD
74381: PPUSH
74382: CALL_OW 1
74386: ST_TO_ADDR
// end ;
74387: LD_VAR 0 3
74391: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
74392: LD_INT 0
74394: PPUSH
// if not mc_bases [ base ] then
74395: LD_EXP 59
74399: PUSH
74400: LD_VAR 0 1
74404: ARRAY
74405: NOT
74406: IFFALSE 74410
// exit ;
74408: GO 74464
// mc_defender := Replace ( mc_defender , base , deflist ) ;
74410: LD_ADDR_EXP 81
74414: PUSH
74415: LD_EXP 81
74419: PPUSH
74420: LD_VAR 0 1
74424: PPUSH
74425: LD_VAR 0 2
74429: PPUSH
74430: CALL_OW 1
74434: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
74435: LD_ADDR_EXP 70
74439: PUSH
74440: LD_EXP 70
74444: PPUSH
74445: LD_VAR 0 1
74449: PPUSH
74450: LD_VAR 0 2
74454: PUSH
74455: LD_INT 0
74457: PLUS
74458: PPUSH
74459: CALL_OW 1
74463: ST_TO_ADDR
// end ;
74464: LD_VAR 0 3
74468: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
74469: LD_INT 0
74471: PPUSH
// if not mc_bases [ base ] then
74472: LD_EXP 59
74476: PUSH
74477: LD_VAR 0 1
74481: ARRAY
74482: NOT
74483: IFFALSE 74487
// exit ;
74485: GO 74512
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
74487: LD_ADDR_EXP 70
74491: PUSH
74492: LD_EXP 70
74496: PPUSH
74497: LD_VAR 0 1
74501: PPUSH
74502: LD_VAR 0 2
74506: PPUSH
74507: CALL_OW 1
74511: ST_TO_ADDR
// end ;
74512: LD_VAR 0 3
74516: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
74517: LD_INT 0
74519: PPUSH
74520: PPUSH
74521: PPUSH
74522: PPUSH
// if not mc_bases [ base ] then
74523: LD_EXP 59
74527: PUSH
74528: LD_VAR 0 1
74532: ARRAY
74533: NOT
74534: IFFALSE 74538
// exit ;
74536: GO 74603
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
74538: LD_ADDR_EXP 79
74542: PUSH
74543: LD_EXP 79
74547: PPUSH
74548: LD_VAR 0 1
74552: PUSH
74553: LD_EXP 79
74557: PUSH
74558: LD_VAR 0 1
74562: ARRAY
74563: PUSH
74564: LD_INT 1
74566: PLUS
74567: PUSH
74568: EMPTY
74569: LIST
74570: LIST
74571: PPUSH
74572: LD_VAR 0 1
74576: PUSH
74577: LD_VAR 0 2
74581: PUSH
74582: LD_VAR 0 3
74586: PUSH
74587: LD_VAR 0 4
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: LIST
74596: LIST
74597: PPUSH
74598: CALL 19238 0 3
74602: ST_TO_ADDR
// end ;
74603: LD_VAR 0 5
74607: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
74608: LD_INT 0
74610: PPUSH
// if not mc_bases [ base ] then
74611: LD_EXP 59
74615: PUSH
74616: LD_VAR 0 1
74620: ARRAY
74621: NOT
74622: IFFALSE 74626
// exit ;
74624: GO 74651
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
74626: LD_ADDR_EXP 96
74630: PUSH
74631: LD_EXP 96
74635: PPUSH
74636: LD_VAR 0 1
74640: PPUSH
74641: LD_VAR 0 2
74645: PPUSH
74646: CALL_OW 1
74650: ST_TO_ADDR
// end ;
74651: LD_VAR 0 3
74655: RET
// export function MC_GetMinesField ( base ) ; begin
74656: LD_INT 0
74658: PPUSH
// result := mc_mines [ base ] ;
74659: LD_ADDR_VAR 0 2
74663: PUSH
74664: LD_EXP 72
74668: PUSH
74669: LD_VAR 0 1
74673: ARRAY
74674: ST_TO_ADDR
// end ;
74675: LD_VAR 0 2
74679: RET
// export function MC_GetProduceList ( base ) ; begin
74680: LD_INT 0
74682: PPUSH
// result := mc_produce [ base ] ;
74683: LD_ADDR_VAR 0 2
74687: PUSH
74688: LD_EXP 80
74692: PUSH
74693: LD_VAR 0 1
74697: ARRAY
74698: ST_TO_ADDR
// end ;
74699: LD_VAR 0 2
74703: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
74704: LD_INT 0
74706: PPUSH
74707: PPUSH
// if not mc_bases then
74708: LD_EXP 59
74712: NOT
74713: IFFALSE 74717
// exit ;
74715: GO 74782
// if mc_bases [ base ] then
74717: LD_EXP 59
74721: PUSH
74722: LD_VAR 0 1
74726: ARRAY
74727: IFFALSE 74782
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74729: LD_ADDR_VAR 0 3
74733: PUSH
74734: LD_EXP 59
74738: PUSH
74739: LD_VAR 0 1
74743: ARRAY
74744: PPUSH
74745: LD_INT 30
74747: PUSH
74748: LD_VAR 0 2
74752: PUSH
74753: EMPTY
74754: LIST
74755: LIST
74756: PPUSH
74757: CALL_OW 72
74761: ST_TO_ADDR
// if result then
74762: LD_VAR 0 3
74766: IFFALSE 74782
// result := result [ 1 ] ;
74768: LD_ADDR_VAR 0 3
74772: PUSH
74773: LD_VAR 0 3
74777: PUSH
74778: LD_INT 1
74780: ARRAY
74781: ST_TO_ADDR
// end ; end ;
74782: LD_VAR 0 3
74786: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
74787: LD_INT 0
74789: PPUSH
74790: PPUSH
// if not mc_bases then
74791: LD_EXP 59
74795: NOT
74796: IFFALSE 74800
// exit ;
74798: GO 74845
// if mc_bases [ base ] then
74800: LD_EXP 59
74804: PUSH
74805: LD_VAR 0 1
74809: ARRAY
74810: IFFALSE 74845
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74812: LD_ADDR_VAR 0 3
74816: PUSH
74817: LD_EXP 59
74821: PUSH
74822: LD_VAR 0 1
74826: ARRAY
74827: PPUSH
74828: LD_INT 30
74830: PUSH
74831: LD_VAR 0 2
74835: PUSH
74836: EMPTY
74837: LIST
74838: LIST
74839: PPUSH
74840: CALL_OW 72
74844: ST_TO_ADDR
// end ;
74845: LD_VAR 0 3
74849: RET
// export function MC_SetTame ( base , area ) ; begin
74850: LD_INT 0
74852: PPUSH
// if not mc_bases or not base then
74853: LD_EXP 59
74857: NOT
74858: PUSH
74859: LD_VAR 0 1
74863: NOT
74864: OR
74865: IFFALSE 74869
// exit ;
74867: GO 74894
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
74869: LD_ADDR_EXP 87
74873: PUSH
74874: LD_EXP 87
74878: PPUSH
74879: LD_VAR 0 1
74883: PPUSH
74884: LD_VAR 0 2
74888: PPUSH
74889: CALL_OW 1
74893: ST_TO_ADDR
// end ;
74894: LD_VAR 0 3
74898: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
74899: LD_INT 0
74901: PPUSH
74902: PPUSH
// if not mc_bases or not base then
74903: LD_EXP 59
74907: NOT
74908: PUSH
74909: LD_VAR 0 1
74913: NOT
74914: OR
74915: IFFALSE 74919
// exit ;
74917: GO 75021
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
74919: LD_ADDR_VAR 0 4
74923: PUSH
74924: LD_EXP 59
74928: PUSH
74929: LD_VAR 0 1
74933: ARRAY
74934: PPUSH
74935: LD_INT 30
74937: PUSH
74938: LD_VAR 0 2
74942: PUSH
74943: EMPTY
74944: LIST
74945: LIST
74946: PPUSH
74947: CALL_OW 72
74951: ST_TO_ADDR
// if not tmp then
74952: LD_VAR 0 4
74956: NOT
74957: IFFALSE 74961
// exit ;
74959: GO 75021
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
74961: LD_ADDR_EXP 91
74965: PUSH
74966: LD_EXP 91
74970: PPUSH
74971: LD_VAR 0 1
74975: PPUSH
74976: LD_EXP 91
74980: PUSH
74981: LD_VAR 0 1
74985: ARRAY
74986: PPUSH
74987: LD_EXP 91
74991: PUSH
74992: LD_VAR 0 1
74996: ARRAY
74997: PUSH
74998: LD_INT 1
75000: PLUS
75001: PPUSH
75002: LD_VAR 0 4
75006: PUSH
75007: LD_INT 1
75009: ARRAY
75010: PPUSH
75011: CALL_OW 2
75015: PPUSH
75016: CALL_OW 1
75020: ST_TO_ADDR
// end ;
75021: LD_VAR 0 3
75025: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75026: LD_INT 0
75028: PPUSH
75029: PPUSH
// if not mc_bases or not base or not kinds then
75030: LD_EXP 59
75034: NOT
75035: PUSH
75036: LD_VAR 0 1
75040: NOT
75041: OR
75042: PUSH
75043: LD_VAR 0 2
75047: NOT
75048: OR
75049: IFFALSE 75053
// exit ;
75051: GO 75114
// for i in kinds do
75053: LD_ADDR_VAR 0 4
75057: PUSH
75058: LD_VAR 0 2
75062: PUSH
75063: FOR_IN
75064: IFFALSE 75112
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75066: LD_ADDR_EXP 93
75070: PUSH
75071: LD_EXP 93
75075: PPUSH
75076: LD_VAR 0 1
75080: PUSH
75081: LD_EXP 93
75085: PUSH
75086: LD_VAR 0 1
75090: ARRAY
75091: PUSH
75092: LD_INT 1
75094: PLUS
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PPUSH
75100: LD_VAR 0 4
75104: PPUSH
75105: CALL 19238 0 3
75109: ST_TO_ADDR
75110: GO 75063
75112: POP
75113: POP
// end ;
75114: LD_VAR 0 3
75118: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75119: LD_INT 0
75121: PPUSH
// if not mc_bases or not base or not areas then
75122: LD_EXP 59
75126: NOT
75127: PUSH
75128: LD_VAR 0 1
75132: NOT
75133: OR
75134: PUSH
75135: LD_VAR 0 2
75139: NOT
75140: OR
75141: IFFALSE 75145
// exit ;
75143: GO 75170
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75145: LD_ADDR_EXP 77
75149: PUSH
75150: LD_EXP 77
75154: PPUSH
75155: LD_VAR 0 1
75159: PPUSH
75160: LD_VAR 0 2
75164: PPUSH
75165: CALL_OW 1
75169: ST_TO_ADDR
// end ;
75170: LD_VAR 0 3
75174: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75175: LD_INT 0
75177: PPUSH
// if not mc_bases or not base or not teleports_exit then
75178: LD_EXP 59
75182: NOT
75183: PUSH
75184: LD_VAR 0 1
75188: NOT
75189: OR
75190: PUSH
75191: LD_VAR 0 2
75195: NOT
75196: OR
75197: IFFALSE 75201
// exit ;
75199: GO 75226
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75201: LD_ADDR_EXP 94
75205: PUSH
75206: LD_EXP 94
75210: PPUSH
75211: LD_VAR 0 1
75215: PPUSH
75216: LD_VAR 0 2
75220: PPUSH
75221: CALL_OW 1
75225: ST_TO_ADDR
// end ;
75226: LD_VAR 0 3
75230: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75231: LD_INT 0
75233: PPUSH
75234: PPUSH
75235: PPUSH
// if not mc_bases or not base or not ext_list then
75236: LD_EXP 59
75240: NOT
75241: PUSH
75242: LD_VAR 0 1
75246: NOT
75247: OR
75248: PUSH
75249: LD_VAR 0 5
75253: NOT
75254: OR
75255: IFFALSE 75259
// exit ;
75257: GO 75432
// tmp := GetFacExtXYD ( x , y , d ) ;
75259: LD_ADDR_VAR 0 8
75263: PUSH
75264: LD_VAR 0 2
75268: PPUSH
75269: LD_VAR 0 3
75273: PPUSH
75274: LD_VAR 0 4
75278: PPUSH
75279: CALL 47917 0 3
75283: ST_TO_ADDR
// if not tmp then
75284: LD_VAR 0 8
75288: NOT
75289: IFFALSE 75293
// exit ;
75291: GO 75432
// for i in tmp do
75293: LD_ADDR_VAR 0 7
75297: PUSH
75298: LD_VAR 0 8
75302: PUSH
75303: FOR_IN
75304: IFFALSE 75430
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
75306: LD_ADDR_EXP 64
75310: PUSH
75311: LD_EXP 64
75315: PPUSH
75316: LD_VAR 0 1
75320: PPUSH
75321: LD_EXP 64
75325: PUSH
75326: LD_VAR 0 1
75330: ARRAY
75331: PPUSH
75332: LD_EXP 64
75336: PUSH
75337: LD_VAR 0 1
75341: ARRAY
75342: PUSH
75343: LD_INT 1
75345: PLUS
75346: PPUSH
75347: LD_VAR 0 5
75351: PUSH
75352: LD_INT 1
75354: ARRAY
75355: PUSH
75356: LD_VAR 0 7
75360: PUSH
75361: LD_INT 1
75363: ARRAY
75364: PUSH
75365: LD_VAR 0 7
75369: PUSH
75370: LD_INT 2
75372: ARRAY
75373: PUSH
75374: LD_VAR 0 7
75378: PUSH
75379: LD_INT 3
75381: ARRAY
75382: PUSH
75383: EMPTY
75384: LIST
75385: LIST
75386: LIST
75387: LIST
75388: PPUSH
75389: CALL_OW 2
75393: PPUSH
75394: CALL_OW 1
75398: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
75399: LD_ADDR_VAR 0 5
75403: PUSH
75404: LD_VAR 0 5
75408: PPUSH
75409: LD_INT 1
75411: PPUSH
75412: CALL_OW 3
75416: ST_TO_ADDR
// if not ext_list then
75417: LD_VAR 0 5
75421: NOT
75422: IFFALSE 75428
// exit ;
75424: POP
75425: POP
75426: GO 75432
// end ;
75428: GO 75303
75430: POP
75431: POP
// end ;
75432: LD_VAR 0 6
75436: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
75437: LD_INT 0
75439: PPUSH
// if not mc_bases or not base or not weapon_list then
75440: LD_EXP 59
75444: NOT
75445: PUSH
75446: LD_VAR 0 1
75450: NOT
75451: OR
75452: PUSH
75453: LD_VAR 0 2
75457: NOT
75458: OR
75459: IFFALSE 75463
// exit ;
75461: GO 75488
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
75463: LD_ADDR_EXP 98
75467: PUSH
75468: LD_EXP 98
75472: PPUSH
75473: LD_VAR 0 1
75477: PPUSH
75478: LD_VAR 0 2
75482: PPUSH
75483: CALL_OW 1
75487: ST_TO_ADDR
// end ;
75488: LD_VAR 0 3
75492: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
75493: LD_INT 0
75495: PPUSH
// if not mc_bases or not base or not tech_list then
75496: LD_EXP 59
75500: NOT
75501: PUSH
75502: LD_VAR 0 1
75506: NOT
75507: OR
75508: PUSH
75509: LD_VAR 0 2
75513: NOT
75514: OR
75515: IFFALSE 75519
// exit ;
75517: GO 75544
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
75519: LD_ADDR_EXP 86
75523: PUSH
75524: LD_EXP 86
75528: PPUSH
75529: LD_VAR 0 1
75533: PPUSH
75534: LD_VAR 0 2
75538: PPUSH
75539: CALL_OW 1
75543: ST_TO_ADDR
// end ;
75544: LD_VAR 0 3
75548: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
75549: LD_INT 0
75551: PPUSH
// if not mc_bases or not parking_area or not base then
75552: LD_EXP 59
75556: NOT
75557: PUSH
75558: LD_VAR 0 2
75562: NOT
75563: OR
75564: PUSH
75565: LD_VAR 0 1
75569: NOT
75570: OR
75571: IFFALSE 75575
// exit ;
75573: GO 75600
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
75575: LD_ADDR_EXP 83
75579: PUSH
75580: LD_EXP 83
75584: PPUSH
75585: LD_VAR 0 1
75589: PPUSH
75590: LD_VAR 0 2
75594: PPUSH
75595: CALL_OW 1
75599: ST_TO_ADDR
// end ;
75600: LD_VAR 0 3
75604: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
75605: LD_INT 0
75607: PPUSH
// if not mc_bases or not base or not scan_area then
75608: LD_EXP 59
75612: NOT
75613: PUSH
75614: LD_VAR 0 1
75618: NOT
75619: OR
75620: PUSH
75621: LD_VAR 0 2
75625: NOT
75626: OR
75627: IFFALSE 75631
// exit ;
75629: GO 75656
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
75631: LD_ADDR_EXP 84
75635: PUSH
75636: LD_EXP 84
75640: PPUSH
75641: LD_VAR 0 1
75645: PPUSH
75646: LD_VAR 0 2
75650: PPUSH
75651: CALL_OW 1
75655: ST_TO_ADDR
// end ;
75656: LD_VAR 0 3
75660: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
75661: LD_INT 0
75663: PPUSH
75664: PPUSH
// if not mc_bases or not base then
75665: LD_EXP 59
75669: NOT
75670: PUSH
75671: LD_VAR 0 1
75675: NOT
75676: OR
75677: IFFALSE 75681
// exit ;
75679: GO 75745
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
75681: LD_ADDR_VAR 0 3
75685: PUSH
75686: LD_INT 1
75688: PUSH
75689: LD_INT 2
75691: PUSH
75692: LD_INT 3
75694: PUSH
75695: LD_INT 4
75697: PUSH
75698: LD_INT 11
75700: PUSH
75701: EMPTY
75702: LIST
75703: LIST
75704: LIST
75705: LIST
75706: LIST
75707: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
75708: LD_ADDR_EXP 86
75712: PUSH
75713: LD_EXP 86
75717: PPUSH
75718: LD_VAR 0 1
75722: PPUSH
75723: LD_EXP 86
75727: PUSH
75728: LD_VAR 0 1
75732: ARRAY
75733: PUSH
75734: LD_VAR 0 3
75738: DIFF
75739: PPUSH
75740: CALL_OW 1
75744: ST_TO_ADDR
// end ;
75745: LD_VAR 0 2
75749: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
75750: LD_INT 0
75752: PPUSH
// result := mc_vehicles [ base ] ;
75753: LD_ADDR_VAR 0 3
75757: PUSH
75758: LD_EXP 78
75762: PUSH
75763: LD_VAR 0 1
75767: ARRAY
75768: ST_TO_ADDR
// if onlyCombat then
75769: LD_VAR 0 2
75773: IFFALSE 75938
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
75775: LD_ADDR_VAR 0 3
75779: PUSH
75780: LD_VAR 0 3
75784: PUSH
75785: LD_VAR 0 3
75789: PPUSH
75790: LD_INT 2
75792: PUSH
75793: LD_INT 34
75795: PUSH
75796: LD_INT 12
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 34
75805: PUSH
75806: LD_INT 51
75808: PUSH
75809: EMPTY
75810: LIST
75811: LIST
75812: PUSH
75813: LD_INT 34
75815: PUSH
75816: LD_EXP 103
75820: PUSH
75821: EMPTY
75822: LIST
75823: LIST
75824: PUSH
75825: LD_INT 34
75827: PUSH
75828: LD_INT 32
75830: PUSH
75831: EMPTY
75832: LIST
75833: LIST
75834: PUSH
75835: LD_INT 34
75837: PUSH
75838: LD_INT 13
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 34
75847: PUSH
75848: LD_INT 52
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 34
75857: PUSH
75858: LD_INT 14
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 34
75867: PUSH
75868: LD_INT 53
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 34
75877: PUSH
75878: LD_EXP 102
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 34
75889: PUSH
75890: LD_INT 31
75892: PUSH
75893: EMPTY
75894: LIST
75895: LIST
75896: PUSH
75897: LD_INT 34
75899: PUSH
75900: LD_INT 48
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 34
75909: PUSH
75910: LD_INT 8
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: LIST
75921: LIST
75922: LIST
75923: LIST
75924: LIST
75925: LIST
75926: LIST
75927: LIST
75928: LIST
75929: LIST
75930: LIST
75931: PPUSH
75932: CALL_OW 72
75936: DIFF
75937: ST_TO_ADDR
// end ; end_of_file
75938: LD_VAR 0 3
75942: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
75943: LD_INT 0
75945: PPUSH
75946: PPUSH
75947: PPUSH
// if not mc_bases or not skirmish then
75948: LD_EXP 59
75952: NOT
75953: PUSH
75954: LD_EXP 57
75958: NOT
75959: OR
75960: IFFALSE 75964
// exit ;
75962: GO 76129
// for i = 1 to mc_bases do
75964: LD_ADDR_VAR 0 4
75968: PUSH
75969: DOUBLE
75970: LD_INT 1
75972: DEC
75973: ST_TO_ADDR
75974: LD_EXP 59
75978: PUSH
75979: FOR_TO
75980: IFFALSE 76127
// begin if sci in mc_bases [ i ] then
75982: LD_VAR 0 2
75986: PUSH
75987: LD_EXP 59
75991: PUSH
75992: LD_VAR 0 4
75996: ARRAY
75997: IN
75998: IFFALSE 76125
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76000: LD_ADDR_EXP 88
76004: PUSH
76005: LD_EXP 88
76009: PPUSH
76010: LD_VAR 0 4
76014: PUSH
76015: LD_EXP 88
76019: PUSH
76020: LD_VAR 0 4
76024: ARRAY
76025: PUSH
76026: LD_INT 1
76028: PLUS
76029: PUSH
76030: EMPTY
76031: LIST
76032: LIST
76033: PPUSH
76034: LD_VAR 0 1
76038: PPUSH
76039: CALL 19238 0 3
76043: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76044: LD_ADDR_VAR 0 5
76048: PUSH
76049: LD_EXP 59
76053: PUSH
76054: LD_VAR 0 4
76058: ARRAY
76059: PPUSH
76060: LD_INT 2
76062: PUSH
76063: LD_INT 30
76065: PUSH
76066: LD_INT 0
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 30
76075: PUSH
76076: LD_INT 1
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: EMPTY
76084: LIST
76085: LIST
76086: LIST
76087: PPUSH
76088: CALL_OW 72
76092: PPUSH
76093: LD_VAR 0 1
76097: PPUSH
76098: CALL_OW 74
76102: ST_TO_ADDR
// if tmp then
76103: LD_VAR 0 5
76107: IFFALSE 76123
// ComStandNearbyBuilding ( ape , tmp ) ;
76109: LD_VAR 0 1
76113: PPUSH
76114: LD_VAR 0 5
76118: PPUSH
76119: CALL 15852 0 2
// break ;
76123: GO 76127
// end ; end ;
76125: GO 75979
76127: POP
76128: POP
// end ;
76129: LD_VAR 0 3
76133: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76134: LD_INT 0
76136: PPUSH
76137: PPUSH
76138: PPUSH
// if not mc_bases or not skirmish then
76139: LD_EXP 59
76143: NOT
76144: PUSH
76145: LD_EXP 57
76149: NOT
76150: OR
76151: IFFALSE 76155
// exit ;
76153: GO 76244
// for i = 1 to mc_bases do
76155: LD_ADDR_VAR 0 4
76159: PUSH
76160: DOUBLE
76161: LD_INT 1
76163: DEC
76164: ST_TO_ADDR
76165: LD_EXP 59
76169: PUSH
76170: FOR_TO
76171: IFFALSE 76242
// begin if building in mc_busy_turret_list [ i ] then
76173: LD_VAR 0 1
76177: PUSH
76178: LD_EXP 69
76182: PUSH
76183: LD_VAR 0 4
76187: ARRAY
76188: IN
76189: IFFALSE 76240
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76191: LD_ADDR_VAR 0 5
76195: PUSH
76196: LD_EXP 69
76200: PUSH
76201: LD_VAR 0 4
76205: ARRAY
76206: PUSH
76207: LD_VAR 0 1
76211: DIFF
76212: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76213: LD_ADDR_EXP 69
76217: PUSH
76218: LD_EXP 69
76222: PPUSH
76223: LD_VAR 0 4
76227: PPUSH
76228: LD_VAR 0 5
76232: PPUSH
76233: CALL_OW 1
76237: ST_TO_ADDR
// break ;
76238: GO 76242
// end ; end ;
76240: GO 76170
76242: POP
76243: POP
// end ;
76244: LD_VAR 0 3
76248: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
76249: LD_INT 0
76251: PPUSH
76252: PPUSH
76253: PPUSH
// if not mc_bases or not skirmish then
76254: LD_EXP 59
76258: NOT
76259: PUSH
76260: LD_EXP 57
76264: NOT
76265: OR
76266: IFFALSE 76270
// exit ;
76268: GO 76469
// for i = 1 to mc_bases do
76270: LD_ADDR_VAR 0 5
76274: PUSH
76275: DOUBLE
76276: LD_INT 1
76278: DEC
76279: ST_TO_ADDR
76280: LD_EXP 59
76284: PUSH
76285: FOR_TO
76286: IFFALSE 76467
// if building in mc_bases [ i ] then
76288: LD_VAR 0 1
76292: PUSH
76293: LD_EXP 59
76297: PUSH
76298: LD_VAR 0 5
76302: ARRAY
76303: IN
76304: IFFALSE 76465
// begin tmp := mc_bases [ i ] diff building ;
76306: LD_ADDR_VAR 0 6
76310: PUSH
76311: LD_EXP 59
76315: PUSH
76316: LD_VAR 0 5
76320: ARRAY
76321: PUSH
76322: LD_VAR 0 1
76326: DIFF
76327: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
76328: LD_ADDR_EXP 59
76332: PUSH
76333: LD_EXP 59
76337: PPUSH
76338: LD_VAR 0 5
76342: PPUSH
76343: LD_VAR 0 6
76347: PPUSH
76348: CALL_OW 1
76352: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
76353: LD_VAR 0 1
76357: PUSH
76358: LD_EXP 67
76362: PUSH
76363: LD_VAR 0 5
76367: ARRAY
76368: IN
76369: IFFALSE 76408
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
76371: LD_ADDR_EXP 67
76375: PUSH
76376: LD_EXP 67
76380: PPUSH
76381: LD_VAR 0 5
76385: PPUSH
76386: LD_EXP 67
76390: PUSH
76391: LD_VAR 0 5
76395: ARRAY
76396: PUSH
76397: LD_VAR 0 1
76401: DIFF
76402: PPUSH
76403: CALL_OW 1
76407: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
76408: LD_VAR 0 1
76412: PUSH
76413: LD_EXP 68
76417: PUSH
76418: LD_VAR 0 5
76422: ARRAY
76423: IN
76424: IFFALSE 76463
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
76426: LD_ADDR_EXP 68
76430: PUSH
76431: LD_EXP 68
76435: PPUSH
76436: LD_VAR 0 5
76440: PPUSH
76441: LD_EXP 68
76445: PUSH
76446: LD_VAR 0 5
76450: ARRAY
76451: PUSH
76452: LD_VAR 0 1
76456: DIFF
76457: PPUSH
76458: CALL_OW 1
76462: ST_TO_ADDR
// break ;
76463: GO 76467
// end ;
76465: GO 76285
76467: POP
76468: POP
// end ;
76469: LD_VAR 0 4
76473: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
76474: LD_INT 0
76476: PPUSH
76477: PPUSH
76478: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
76479: LD_EXP 59
76483: NOT
76484: PUSH
76485: LD_EXP 57
76489: NOT
76490: OR
76491: PUSH
76492: LD_VAR 0 3
76496: PUSH
76497: LD_EXP 85
76501: IN
76502: NOT
76503: OR
76504: IFFALSE 76508
// exit ;
76506: GO 76631
// for i = 1 to mc_vehicles do
76508: LD_ADDR_VAR 0 6
76512: PUSH
76513: DOUBLE
76514: LD_INT 1
76516: DEC
76517: ST_TO_ADDR
76518: LD_EXP 78
76522: PUSH
76523: FOR_TO
76524: IFFALSE 76629
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
76526: LD_VAR 0 2
76530: PUSH
76531: LD_EXP 78
76535: PUSH
76536: LD_VAR 0 6
76540: ARRAY
76541: IN
76542: PUSH
76543: LD_VAR 0 1
76547: PUSH
76548: LD_EXP 78
76552: PUSH
76553: LD_VAR 0 6
76557: ARRAY
76558: IN
76559: OR
76560: IFFALSE 76627
// begin tmp := mc_vehicles [ i ] diff old ;
76562: LD_ADDR_VAR 0 7
76566: PUSH
76567: LD_EXP 78
76571: PUSH
76572: LD_VAR 0 6
76576: ARRAY
76577: PUSH
76578: LD_VAR 0 2
76582: DIFF
76583: ST_TO_ADDR
// tmp := tmp diff new ;
76584: LD_ADDR_VAR 0 7
76588: PUSH
76589: LD_VAR 0 7
76593: PUSH
76594: LD_VAR 0 1
76598: DIFF
76599: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
76600: LD_ADDR_EXP 78
76604: PUSH
76605: LD_EXP 78
76609: PPUSH
76610: LD_VAR 0 6
76614: PPUSH
76615: LD_VAR 0 7
76619: PPUSH
76620: CALL_OW 1
76624: ST_TO_ADDR
// break ;
76625: GO 76629
// end ;
76627: GO 76523
76629: POP
76630: POP
// end ;
76631: LD_VAR 0 5
76635: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
76636: LD_INT 0
76638: PPUSH
76639: PPUSH
76640: PPUSH
76641: PPUSH
// if not mc_bases or not skirmish then
76642: LD_EXP 59
76646: NOT
76647: PUSH
76648: LD_EXP 57
76652: NOT
76653: OR
76654: IFFALSE 76658
// exit ;
76656: GO 77035
// side := GetSide ( vehicle ) ;
76658: LD_ADDR_VAR 0 5
76662: PUSH
76663: LD_VAR 0 1
76667: PPUSH
76668: CALL_OW 255
76672: ST_TO_ADDR
// for i = 1 to mc_bases do
76673: LD_ADDR_VAR 0 4
76677: PUSH
76678: DOUBLE
76679: LD_INT 1
76681: DEC
76682: ST_TO_ADDR
76683: LD_EXP 59
76687: PUSH
76688: FOR_TO
76689: IFFALSE 77033
// begin if factory in mc_bases [ i ] then
76691: LD_VAR 0 2
76695: PUSH
76696: LD_EXP 59
76700: PUSH
76701: LD_VAR 0 4
76705: ARRAY
76706: IN
76707: IFFALSE 77031
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
76709: LD_EXP 81
76713: PUSH
76714: LD_VAR 0 4
76718: ARRAY
76719: PUSH
76720: LD_EXP 70
76724: PUSH
76725: LD_VAR 0 4
76729: ARRAY
76730: LESS
76731: PUSH
76732: LD_VAR 0 1
76736: PPUSH
76737: CALL_OW 264
76741: PUSH
76742: LD_INT 31
76744: PUSH
76745: LD_INT 32
76747: PUSH
76748: LD_INT 51
76750: PUSH
76751: LD_EXP 103
76755: PUSH
76756: LD_INT 12
76758: PUSH
76759: LD_INT 30
76761: PUSH
76762: LD_EXP 102
76766: PUSH
76767: LD_INT 11
76769: PUSH
76770: LD_INT 53
76772: PUSH
76773: LD_INT 14
76775: PUSH
76776: LD_EXP 106
76780: PUSH
76781: LD_INT 29
76783: PUSH
76784: LD_EXP 104
76788: PUSH
76789: LD_INT 13
76791: PUSH
76792: LD_INT 52
76794: PUSH
76795: LD_INT 48
76797: PUSH
76798: LD_INT 8
76800: PUSH
76801: EMPTY
76802: LIST
76803: LIST
76804: LIST
76805: LIST
76806: LIST
76807: LIST
76808: LIST
76809: LIST
76810: LIST
76811: LIST
76812: LIST
76813: LIST
76814: LIST
76815: LIST
76816: LIST
76817: LIST
76818: LIST
76819: IN
76820: NOT
76821: AND
76822: IFFALSE 76870
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
76824: LD_ADDR_EXP 81
76828: PUSH
76829: LD_EXP 81
76833: PPUSH
76834: LD_VAR 0 4
76838: PUSH
76839: LD_EXP 81
76843: PUSH
76844: LD_VAR 0 4
76848: ARRAY
76849: PUSH
76850: LD_INT 1
76852: PLUS
76853: PUSH
76854: EMPTY
76855: LIST
76856: LIST
76857: PPUSH
76858: LD_VAR 0 1
76862: PPUSH
76863: CALL 19238 0 3
76867: ST_TO_ADDR
76868: GO 76914
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
76870: LD_ADDR_EXP 78
76874: PUSH
76875: LD_EXP 78
76879: PPUSH
76880: LD_VAR 0 4
76884: PUSH
76885: LD_EXP 78
76889: PUSH
76890: LD_VAR 0 4
76894: ARRAY
76895: PUSH
76896: LD_INT 1
76898: PLUS
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PPUSH
76904: LD_VAR 0 1
76908: PPUSH
76909: CALL 19238 0 3
76913: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
76914: LD_VAR 0 1
76918: PPUSH
76919: CALL_OW 263
76923: PUSH
76924: LD_INT 2
76926: EQUAL
76927: IFFALSE 76947
// begin repeat wait ( 0 0$1 ) ;
76929: LD_INT 35
76931: PPUSH
76932: CALL_OW 67
// until IsControledBy ( vehicle ) ;
76936: LD_VAR 0 1
76940: PPUSH
76941: CALL_OW 312
76945: IFFALSE 76929
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
76947: LD_VAR 0 1
76951: PPUSH
76952: LD_EXP 83
76956: PUSH
76957: LD_VAR 0 4
76961: ARRAY
76962: PPUSH
76963: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
76967: LD_VAR 0 1
76971: PPUSH
76972: CALL_OW 263
76976: PUSH
76977: LD_INT 1
76979: NONEQUAL
76980: IFFALSE 76984
// break ;
76982: GO 77033
// repeat wait ( 0 0$1 ) ;
76984: LD_INT 35
76986: PPUSH
76987: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
76991: LD_VAR 0 1
76995: PPUSH
76996: LD_EXP 83
77000: PUSH
77001: LD_VAR 0 4
77005: ARRAY
77006: PPUSH
77007: CALL_OW 308
77011: IFFALSE 76984
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77013: LD_VAR 0 1
77017: PPUSH
77018: CALL_OW 311
77022: PPUSH
77023: CALL_OW 121
// exit ;
77027: POP
77028: POP
77029: GO 77035
// end ; end ;
77031: GO 76688
77033: POP
77034: POP
// end ;
77035: LD_VAR 0 3
77039: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77040: LD_INT 0
77042: PPUSH
77043: PPUSH
77044: PPUSH
77045: PPUSH
// if not mc_bases or not skirmish then
77046: LD_EXP 59
77050: NOT
77051: PUSH
77052: LD_EXP 57
77056: NOT
77057: OR
77058: IFFALSE 77062
// exit ;
77060: GO 77415
// repeat wait ( 0 0$1 ) ;
77062: LD_INT 35
77064: PPUSH
77065: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77069: LD_VAR 0 2
77073: PPUSH
77074: LD_VAR 0 3
77078: PPUSH
77079: CALL_OW 284
77083: IFFALSE 77062
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77085: LD_VAR 0 2
77089: PPUSH
77090: LD_VAR 0 3
77094: PPUSH
77095: CALL_OW 283
77099: PUSH
77100: LD_INT 4
77102: EQUAL
77103: IFFALSE 77107
// exit ;
77105: GO 77415
// for i = 1 to mc_bases do
77107: LD_ADDR_VAR 0 7
77111: PUSH
77112: DOUBLE
77113: LD_INT 1
77115: DEC
77116: ST_TO_ADDR
77117: LD_EXP 59
77121: PUSH
77122: FOR_TO
77123: IFFALSE 77413
// begin if mc_crates_area [ i ] then
77125: LD_EXP 77
77129: PUSH
77130: LD_VAR 0 7
77134: ARRAY
77135: IFFALSE 77246
// for j in mc_crates_area [ i ] do
77137: LD_ADDR_VAR 0 8
77141: PUSH
77142: LD_EXP 77
77146: PUSH
77147: LD_VAR 0 7
77151: ARRAY
77152: PUSH
77153: FOR_IN
77154: IFFALSE 77244
// if InArea ( x , y , j ) then
77156: LD_VAR 0 2
77160: PPUSH
77161: LD_VAR 0 3
77165: PPUSH
77166: LD_VAR 0 8
77170: PPUSH
77171: CALL_OW 309
77175: IFFALSE 77242
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77177: LD_ADDR_EXP 75
77181: PUSH
77182: LD_EXP 75
77186: PPUSH
77187: LD_VAR 0 7
77191: PUSH
77192: LD_EXP 75
77196: PUSH
77197: LD_VAR 0 7
77201: ARRAY
77202: PUSH
77203: LD_INT 1
77205: PLUS
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PPUSH
77211: LD_VAR 0 4
77215: PUSH
77216: LD_VAR 0 2
77220: PUSH
77221: LD_VAR 0 3
77225: PUSH
77226: EMPTY
77227: LIST
77228: LIST
77229: LIST
77230: PPUSH
77231: CALL 19238 0 3
77235: ST_TO_ADDR
// exit ;
77236: POP
77237: POP
77238: POP
77239: POP
77240: GO 77415
// end ;
77242: GO 77153
77244: POP
77245: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
77246: LD_ADDR_VAR 0 9
77250: PUSH
77251: LD_EXP 59
77255: PUSH
77256: LD_VAR 0 7
77260: ARRAY
77261: PPUSH
77262: LD_INT 2
77264: PUSH
77265: LD_INT 30
77267: PUSH
77268: LD_INT 0
77270: PUSH
77271: EMPTY
77272: LIST
77273: LIST
77274: PUSH
77275: LD_INT 30
77277: PUSH
77278: LD_INT 1
77280: PUSH
77281: EMPTY
77282: LIST
77283: LIST
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: LIST
77289: PPUSH
77290: CALL_OW 72
77294: ST_TO_ADDR
// if not depot then
77295: LD_VAR 0 9
77299: NOT
77300: IFFALSE 77304
// continue ;
77302: GO 77122
// for j in depot do
77304: LD_ADDR_VAR 0 8
77308: PUSH
77309: LD_VAR 0 9
77313: PUSH
77314: FOR_IN
77315: IFFALSE 77409
// if GetDistUnitXY ( j , x , y ) < 30 then
77317: LD_VAR 0 8
77321: PPUSH
77322: LD_VAR 0 2
77326: PPUSH
77327: LD_VAR 0 3
77331: PPUSH
77332: CALL_OW 297
77336: PUSH
77337: LD_INT 30
77339: LESS
77340: IFFALSE 77407
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77342: LD_ADDR_EXP 75
77346: PUSH
77347: LD_EXP 75
77351: PPUSH
77352: LD_VAR 0 7
77356: PUSH
77357: LD_EXP 75
77361: PUSH
77362: LD_VAR 0 7
77366: ARRAY
77367: PUSH
77368: LD_INT 1
77370: PLUS
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PPUSH
77376: LD_VAR 0 4
77380: PUSH
77381: LD_VAR 0 2
77385: PUSH
77386: LD_VAR 0 3
77390: PUSH
77391: EMPTY
77392: LIST
77393: LIST
77394: LIST
77395: PPUSH
77396: CALL 19238 0 3
77400: ST_TO_ADDR
// exit ;
77401: POP
77402: POP
77403: POP
77404: POP
77405: GO 77415
// end ;
77407: GO 77314
77409: POP
77410: POP
// end ;
77411: GO 77122
77413: POP
77414: POP
// end ;
77415: LD_VAR 0 6
77419: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
77420: LD_INT 0
77422: PPUSH
77423: PPUSH
77424: PPUSH
77425: PPUSH
// if not mc_bases or not skirmish then
77426: LD_EXP 59
77430: NOT
77431: PUSH
77432: LD_EXP 57
77436: NOT
77437: OR
77438: IFFALSE 77442
// exit ;
77440: GO 77719
// side := GetSide ( lab ) ;
77442: LD_ADDR_VAR 0 4
77446: PUSH
77447: LD_VAR 0 2
77451: PPUSH
77452: CALL_OW 255
77456: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
77457: LD_VAR 0 4
77461: PUSH
77462: LD_EXP 85
77466: IN
77467: NOT
77468: PUSH
77469: LD_EXP 86
77473: NOT
77474: OR
77475: PUSH
77476: LD_EXP 59
77480: NOT
77481: OR
77482: IFFALSE 77486
// exit ;
77484: GO 77719
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
77486: LD_ADDR_EXP 86
77490: PUSH
77491: LD_EXP 86
77495: PPUSH
77496: LD_VAR 0 4
77500: PPUSH
77501: LD_EXP 86
77505: PUSH
77506: LD_VAR 0 4
77510: ARRAY
77511: PUSH
77512: LD_VAR 0 1
77516: DIFF
77517: PPUSH
77518: CALL_OW 1
77522: ST_TO_ADDR
// for i = 1 to mc_bases do
77523: LD_ADDR_VAR 0 5
77527: PUSH
77528: DOUBLE
77529: LD_INT 1
77531: DEC
77532: ST_TO_ADDR
77533: LD_EXP 59
77537: PUSH
77538: FOR_TO
77539: IFFALSE 77717
// begin if lab in mc_bases [ i ] then
77541: LD_VAR 0 2
77545: PUSH
77546: LD_EXP 59
77550: PUSH
77551: LD_VAR 0 5
77555: ARRAY
77556: IN
77557: IFFALSE 77715
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
77559: LD_VAR 0 1
77563: PUSH
77564: LD_INT 11
77566: PUSH
77567: LD_INT 4
77569: PUSH
77570: LD_INT 3
77572: PUSH
77573: LD_INT 2
77575: PUSH
77576: EMPTY
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: IN
77582: PUSH
77583: LD_EXP 89
77587: PUSH
77588: LD_VAR 0 5
77592: ARRAY
77593: AND
77594: IFFALSE 77715
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
77596: LD_ADDR_VAR 0 6
77600: PUSH
77601: LD_EXP 89
77605: PUSH
77606: LD_VAR 0 5
77610: ARRAY
77611: PUSH
77612: LD_INT 1
77614: ARRAY
77615: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77616: LD_ADDR_EXP 89
77620: PUSH
77621: LD_EXP 89
77625: PPUSH
77626: LD_VAR 0 5
77630: PPUSH
77631: EMPTY
77632: PPUSH
77633: CALL_OW 1
77637: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
77638: LD_VAR 0 6
77642: PPUSH
77643: LD_INT 0
77645: PPUSH
77646: CALL_OW 109
// ComExitBuilding ( tmp ) ;
77650: LD_VAR 0 6
77654: PPUSH
77655: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
77659: LD_ADDR_EXP 88
77663: PUSH
77664: LD_EXP 88
77668: PPUSH
77669: LD_VAR 0 5
77673: PPUSH
77674: LD_EXP 88
77678: PUSH
77679: LD_VAR 0 5
77683: ARRAY
77684: PPUSH
77685: LD_INT 1
77687: PPUSH
77688: LD_VAR 0 6
77692: PPUSH
77693: CALL_OW 2
77697: PPUSH
77698: CALL_OW 1
77702: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
77703: LD_VAR 0 5
77707: PPUSH
77708: LD_INT 112
77710: PPUSH
77711: CALL 54731 0 2
// end ; end ; end ;
77715: GO 77538
77717: POP
77718: POP
// end ;
77719: LD_VAR 0 3
77723: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
77724: LD_INT 0
77726: PPUSH
77727: PPUSH
77728: PPUSH
77729: PPUSH
77730: PPUSH
77731: PPUSH
77732: PPUSH
77733: PPUSH
// if not mc_bases or not skirmish then
77734: LD_EXP 59
77738: NOT
77739: PUSH
77740: LD_EXP 57
77744: NOT
77745: OR
77746: IFFALSE 77750
// exit ;
77748: GO 79121
// for i = 1 to mc_bases do
77750: LD_ADDR_VAR 0 3
77754: PUSH
77755: DOUBLE
77756: LD_INT 1
77758: DEC
77759: ST_TO_ADDR
77760: LD_EXP 59
77764: PUSH
77765: FOR_TO
77766: IFFALSE 79119
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
77768: LD_VAR 0 1
77772: PUSH
77773: LD_EXP 59
77777: PUSH
77778: LD_VAR 0 3
77782: ARRAY
77783: IN
77784: PUSH
77785: LD_VAR 0 1
77789: PUSH
77790: LD_EXP 66
77794: PUSH
77795: LD_VAR 0 3
77799: ARRAY
77800: IN
77801: OR
77802: PUSH
77803: LD_VAR 0 1
77807: PUSH
77808: LD_EXP 81
77812: PUSH
77813: LD_VAR 0 3
77817: ARRAY
77818: IN
77819: OR
77820: PUSH
77821: LD_VAR 0 1
77825: PUSH
77826: LD_EXP 78
77830: PUSH
77831: LD_VAR 0 3
77835: ARRAY
77836: IN
77837: OR
77838: PUSH
77839: LD_VAR 0 1
77843: PUSH
77844: LD_EXP 88
77848: PUSH
77849: LD_VAR 0 3
77853: ARRAY
77854: IN
77855: OR
77856: PUSH
77857: LD_VAR 0 1
77861: PUSH
77862: LD_EXP 89
77866: PUSH
77867: LD_VAR 0 3
77871: ARRAY
77872: IN
77873: OR
77874: IFFALSE 79117
// begin if un in mc_ape [ i ] then
77876: LD_VAR 0 1
77880: PUSH
77881: LD_EXP 88
77885: PUSH
77886: LD_VAR 0 3
77890: ARRAY
77891: IN
77892: IFFALSE 77931
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
77894: LD_ADDR_EXP 88
77898: PUSH
77899: LD_EXP 88
77903: PPUSH
77904: LD_VAR 0 3
77908: PPUSH
77909: LD_EXP 88
77913: PUSH
77914: LD_VAR 0 3
77918: ARRAY
77919: PUSH
77920: LD_VAR 0 1
77924: DIFF
77925: PPUSH
77926: CALL_OW 1
77930: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
77931: LD_VAR 0 1
77935: PUSH
77936: LD_EXP 89
77940: PUSH
77941: LD_VAR 0 3
77945: ARRAY
77946: IN
77947: IFFALSE 77971
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
77949: LD_ADDR_EXP 89
77953: PUSH
77954: LD_EXP 89
77958: PPUSH
77959: LD_VAR 0 3
77963: PPUSH
77964: EMPTY
77965: PPUSH
77966: CALL_OW 1
77970: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
77971: LD_VAR 0 1
77975: PPUSH
77976: CALL_OW 247
77980: PUSH
77981: LD_INT 2
77983: EQUAL
77984: PUSH
77985: LD_VAR 0 1
77989: PPUSH
77990: CALL_OW 110
77994: PUSH
77995: LD_INT 20
77997: EQUAL
77998: PUSH
77999: LD_VAR 0 1
78003: PUSH
78004: LD_EXP 81
78008: PUSH
78009: LD_VAR 0 3
78013: ARRAY
78014: IN
78015: OR
78016: PUSH
78017: LD_VAR 0 1
78021: PPUSH
78022: CALL_OW 264
78026: PUSH
78027: LD_INT 12
78029: PUSH
78030: LD_INT 51
78032: PUSH
78033: LD_EXP 103
78037: PUSH
78038: LD_INT 32
78040: PUSH
78041: LD_INT 13
78043: PUSH
78044: LD_INT 52
78046: PUSH
78047: LD_INT 31
78049: PUSH
78050: EMPTY
78051: LIST
78052: LIST
78053: LIST
78054: LIST
78055: LIST
78056: LIST
78057: LIST
78058: IN
78059: OR
78060: AND
78061: IFFALSE 78369
// begin if un in mc_defender [ i ] then
78063: LD_VAR 0 1
78067: PUSH
78068: LD_EXP 81
78072: PUSH
78073: LD_VAR 0 3
78077: ARRAY
78078: IN
78079: IFFALSE 78118
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78081: LD_ADDR_EXP 81
78085: PUSH
78086: LD_EXP 81
78090: PPUSH
78091: LD_VAR 0 3
78095: PPUSH
78096: LD_EXP 81
78100: PUSH
78101: LD_VAR 0 3
78105: ARRAY
78106: PUSH
78107: LD_VAR 0 1
78111: DIFF
78112: PPUSH
78113: CALL_OW 1
78117: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78118: LD_ADDR_VAR 0 8
78122: PUSH
78123: LD_VAR 0 3
78127: PPUSH
78128: LD_INT 3
78130: PPUSH
78131: CALL 74787 0 2
78135: ST_TO_ADDR
// if fac then
78136: LD_VAR 0 8
78140: IFFALSE 78369
// begin for j in fac do
78142: LD_ADDR_VAR 0 4
78146: PUSH
78147: LD_VAR 0 8
78151: PUSH
78152: FOR_IN
78153: IFFALSE 78367
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78155: LD_ADDR_VAR 0 9
78159: PUSH
78160: LD_VAR 0 8
78164: PPUSH
78165: LD_VAR 0 1
78169: PPUSH
78170: CALL_OW 265
78174: PPUSH
78175: LD_VAR 0 1
78179: PPUSH
78180: CALL_OW 262
78184: PPUSH
78185: LD_VAR 0 1
78189: PPUSH
78190: CALL_OW 263
78194: PPUSH
78195: LD_VAR 0 1
78199: PPUSH
78200: CALL_OW 264
78204: PPUSH
78205: CALL 16770 0 5
78209: ST_TO_ADDR
// if components then
78210: LD_VAR 0 9
78214: IFFALSE 78365
// begin if GetWeapon ( un ) = ar_control_tower then
78216: LD_VAR 0 1
78220: PPUSH
78221: CALL_OW 264
78225: PUSH
78226: LD_INT 31
78228: EQUAL
78229: IFFALSE 78346
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
78231: LD_VAR 0 1
78235: PPUSH
78236: CALL_OW 311
78240: PPUSH
78241: LD_INT 0
78243: PPUSH
78244: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
78248: LD_ADDR_EXP 99
78252: PUSH
78253: LD_EXP 99
78257: PPUSH
78258: LD_VAR 0 3
78262: PPUSH
78263: LD_EXP 99
78267: PUSH
78268: LD_VAR 0 3
78272: ARRAY
78273: PUSH
78274: LD_VAR 0 1
78278: PPUSH
78279: CALL_OW 311
78283: DIFF
78284: PPUSH
78285: CALL_OW 1
78289: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
78290: LD_ADDR_VAR 0 7
78294: PUSH
78295: LD_EXP 80
78299: PUSH
78300: LD_VAR 0 3
78304: ARRAY
78305: PPUSH
78306: LD_INT 1
78308: PPUSH
78309: LD_VAR 0 9
78313: PPUSH
78314: CALL_OW 2
78318: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
78319: LD_ADDR_EXP 80
78323: PUSH
78324: LD_EXP 80
78328: PPUSH
78329: LD_VAR 0 3
78333: PPUSH
78334: LD_VAR 0 7
78338: PPUSH
78339: CALL_OW 1
78343: ST_TO_ADDR
// end else
78344: GO 78363
// MC_InsertProduceList ( i , [ components ] ) ;
78346: LD_VAR 0 3
78350: PPUSH
78351: LD_VAR 0 9
78355: PUSH
78356: EMPTY
78357: LIST
78358: PPUSH
78359: CALL 74332 0 2
// break ;
78363: GO 78367
// end ; end ;
78365: GO 78152
78367: POP
78368: POP
// end ; end ; if GetType ( un ) = unit_building then
78369: LD_VAR 0 1
78373: PPUSH
78374: CALL_OW 247
78378: PUSH
78379: LD_INT 3
78381: EQUAL
78382: IFFALSE 78785
// begin btype := GetBType ( un ) ;
78384: LD_ADDR_VAR 0 5
78388: PUSH
78389: LD_VAR 0 1
78393: PPUSH
78394: CALL_OW 266
78398: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
78399: LD_VAR 0 5
78403: PUSH
78404: LD_INT 29
78406: PUSH
78407: LD_INT 30
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: IN
78414: IFFALSE 78487
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
78416: LD_VAR 0 1
78420: PPUSH
78421: CALL_OW 250
78425: PPUSH
78426: LD_VAR 0 1
78430: PPUSH
78431: CALL_OW 251
78435: PPUSH
78436: LD_VAR 0 1
78440: PPUSH
78441: CALL_OW 255
78445: PPUSH
78446: CALL_OW 440
78450: NOT
78451: IFFALSE 78487
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
78453: LD_VAR 0 1
78457: PPUSH
78458: CALL_OW 250
78462: PPUSH
78463: LD_VAR 0 1
78467: PPUSH
78468: CALL_OW 251
78472: PPUSH
78473: LD_VAR 0 1
78477: PPUSH
78478: CALL_OW 255
78482: PPUSH
78483: CALL_OW 441
// end ; if btype = b_warehouse then
78487: LD_VAR 0 5
78491: PUSH
78492: LD_INT 1
78494: EQUAL
78495: IFFALSE 78513
// begin btype := b_depot ;
78497: LD_ADDR_VAR 0 5
78501: PUSH
78502: LD_INT 0
78504: ST_TO_ADDR
// pos := 1 ;
78505: LD_ADDR_VAR 0 6
78509: PUSH
78510: LD_INT 1
78512: ST_TO_ADDR
// end ; if btype = b_factory then
78513: LD_VAR 0 5
78517: PUSH
78518: LD_INT 3
78520: EQUAL
78521: IFFALSE 78539
// begin btype := b_workshop ;
78523: LD_ADDR_VAR 0 5
78527: PUSH
78528: LD_INT 2
78530: ST_TO_ADDR
// pos := 1 ;
78531: LD_ADDR_VAR 0 6
78535: PUSH
78536: LD_INT 1
78538: ST_TO_ADDR
// end ; if btype = b_barracks then
78539: LD_VAR 0 5
78543: PUSH
78544: LD_INT 5
78546: EQUAL
78547: IFFALSE 78557
// btype := b_armoury ;
78549: LD_ADDR_VAR 0 5
78553: PUSH
78554: LD_INT 4
78556: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
78557: LD_VAR 0 5
78561: PUSH
78562: LD_INT 7
78564: PUSH
78565: LD_INT 8
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: IN
78572: IFFALSE 78582
// btype := b_lab ;
78574: LD_ADDR_VAR 0 5
78578: PUSH
78579: LD_INT 6
78581: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
78582: LD_ADDR_EXP 64
78586: PUSH
78587: LD_EXP 64
78591: PPUSH
78592: LD_VAR 0 3
78596: PUSH
78597: LD_EXP 64
78601: PUSH
78602: LD_VAR 0 3
78606: ARRAY
78607: PUSH
78608: LD_INT 1
78610: PLUS
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PPUSH
78616: LD_VAR 0 5
78620: PUSH
78621: LD_VAR 0 1
78625: PPUSH
78626: CALL_OW 250
78630: PUSH
78631: LD_VAR 0 1
78635: PPUSH
78636: CALL_OW 251
78640: PUSH
78641: LD_VAR 0 1
78645: PPUSH
78646: CALL_OW 254
78650: PUSH
78651: EMPTY
78652: LIST
78653: LIST
78654: LIST
78655: LIST
78656: PPUSH
78657: CALL 19238 0 3
78661: ST_TO_ADDR
// if pos = 1 then
78662: LD_VAR 0 6
78666: PUSH
78667: LD_INT 1
78669: EQUAL
78670: IFFALSE 78785
// begin tmp := mc_build_list [ i ] ;
78672: LD_ADDR_VAR 0 7
78676: PUSH
78677: LD_EXP 64
78681: PUSH
78682: LD_VAR 0 3
78686: ARRAY
78687: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78688: LD_VAR 0 7
78692: PPUSH
78693: LD_INT 2
78695: PUSH
78696: LD_INT 30
78698: PUSH
78699: LD_INT 0
78701: PUSH
78702: EMPTY
78703: LIST
78704: LIST
78705: PUSH
78706: LD_INT 30
78708: PUSH
78709: LD_INT 1
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: EMPTY
78717: LIST
78718: LIST
78719: LIST
78720: PPUSH
78721: CALL_OW 72
78725: IFFALSE 78735
// pos := 2 ;
78727: LD_ADDR_VAR 0 6
78731: PUSH
78732: LD_INT 2
78734: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
78735: LD_ADDR_VAR 0 7
78739: PUSH
78740: LD_VAR 0 7
78744: PPUSH
78745: LD_VAR 0 6
78749: PPUSH
78750: LD_VAR 0 7
78754: PPUSH
78755: CALL 19564 0 3
78759: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
78760: LD_ADDR_EXP 64
78764: PUSH
78765: LD_EXP 64
78769: PPUSH
78770: LD_VAR 0 3
78774: PPUSH
78775: LD_VAR 0 7
78779: PPUSH
78780: CALL_OW 1
78784: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
78785: LD_VAR 0 1
78789: PUSH
78790: LD_EXP 59
78794: PUSH
78795: LD_VAR 0 3
78799: ARRAY
78800: IN
78801: IFFALSE 78840
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
78803: LD_ADDR_EXP 59
78807: PUSH
78808: LD_EXP 59
78812: PPUSH
78813: LD_VAR 0 3
78817: PPUSH
78818: LD_EXP 59
78822: PUSH
78823: LD_VAR 0 3
78827: ARRAY
78828: PUSH
78829: LD_VAR 0 1
78833: DIFF
78834: PPUSH
78835: CALL_OW 1
78839: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
78840: LD_VAR 0 1
78844: PUSH
78845: LD_EXP 66
78849: PUSH
78850: LD_VAR 0 3
78854: ARRAY
78855: IN
78856: IFFALSE 78895
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
78858: LD_ADDR_EXP 66
78862: PUSH
78863: LD_EXP 66
78867: PPUSH
78868: LD_VAR 0 3
78872: PPUSH
78873: LD_EXP 66
78877: PUSH
78878: LD_VAR 0 3
78882: ARRAY
78883: PUSH
78884: LD_VAR 0 1
78888: DIFF
78889: PPUSH
78890: CALL_OW 1
78894: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
78895: LD_VAR 0 1
78899: PUSH
78900: LD_EXP 78
78904: PUSH
78905: LD_VAR 0 3
78909: ARRAY
78910: IN
78911: IFFALSE 78950
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
78913: LD_ADDR_EXP 78
78917: PUSH
78918: LD_EXP 78
78922: PPUSH
78923: LD_VAR 0 3
78927: PPUSH
78928: LD_EXP 78
78932: PUSH
78933: LD_VAR 0 3
78937: ARRAY
78938: PUSH
78939: LD_VAR 0 1
78943: DIFF
78944: PPUSH
78945: CALL_OW 1
78949: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
78950: LD_VAR 0 1
78954: PUSH
78955: LD_EXP 81
78959: PUSH
78960: LD_VAR 0 3
78964: ARRAY
78965: IN
78966: IFFALSE 79005
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78968: LD_ADDR_EXP 81
78972: PUSH
78973: LD_EXP 81
78977: PPUSH
78978: LD_VAR 0 3
78982: PPUSH
78983: LD_EXP 81
78987: PUSH
78988: LD_VAR 0 3
78992: ARRAY
78993: PUSH
78994: LD_VAR 0 1
78998: DIFF
78999: PPUSH
79000: CALL_OW 1
79004: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79005: LD_VAR 0 1
79009: PUSH
79010: LD_EXP 68
79014: PUSH
79015: LD_VAR 0 3
79019: ARRAY
79020: IN
79021: IFFALSE 79060
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79023: LD_ADDR_EXP 68
79027: PUSH
79028: LD_EXP 68
79032: PPUSH
79033: LD_VAR 0 3
79037: PPUSH
79038: LD_EXP 68
79042: PUSH
79043: LD_VAR 0 3
79047: ARRAY
79048: PUSH
79049: LD_VAR 0 1
79053: DIFF
79054: PPUSH
79055: CALL_OW 1
79059: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79060: LD_VAR 0 1
79064: PUSH
79065: LD_EXP 67
79069: PUSH
79070: LD_VAR 0 3
79074: ARRAY
79075: IN
79076: IFFALSE 79115
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79078: LD_ADDR_EXP 67
79082: PUSH
79083: LD_EXP 67
79087: PPUSH
79088: LD_VAR 0 3
79092: PPUSH
79093: LD_EXP 67
79097: PUSH
79098: LD_VAR 0 3
79102: ARRAY
79103: PUSH
79104: LD_VAR 0 1
79108: DIFF
79109: PPUSH
79110: CALL_OW 1
79114: ST_TO_ADDR
// end ; break ;
79115: GO 79119
// end ;
79117: GO 77765
79119: POP
79120: POP
// end ;
79121: LD_VAR 0 2
79125: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79126: LD_INT 0
79128: PPUSH
79129: PPUSH
79130: PPUSH
// if not mc_bases or not skirmish then
79131: LD_EXP 59
79135: NOT
79136: PUSH
79137: LD_EXP 57
79141: NOT
79142: OR
79143: IFFALSE 79147
// exit ;
79145: GO 79362
// for i = 1 to mc_bases do
79147: LD_ADDR_VAR 0 3
79151: PUSH
79152: DOUBLE
79153: LD_INT 1
79155: DEC
79156: ST_TO_ADDR
79157: LD_EXP 59
79161: PUSH
79162: FOR_TO
79163: IFFALSE 79360
// begin if building in mc_construct_list [ i ] then
79165: LD_VAR 0 1
79169: PUSH
79170: LD_EXP 66
79174: PUSH
79175: LD_VAR 0 3
79179: ARRAY
79180: IN
79181: IFFALSE 79358
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79183: LD_ADDR_EXP 66
79187: PUSH
79188: LD_EXP 66
79192: PPUSH
79193: LD_VAR 0 3
79197: PPUSH
79198: LD_EXP 66
79202: PUSH
79203: LD_VAR 0 3
79207: ARRAY
79208: PUSH
79209: LD_VAR 0 1
79213: DIFF
79214: PPUSH
79215: CALL_OW 1
79219: ST_TO_ADDR
// if building in mc_lab [ i ] then
79220: LD_VAR 0 1
79224: PUSH
79225: LD_EXP 92
79229: PUSH
79230: LD_VAR 0 3
79234: ARRAY
79235: IN
79236: IFFALSE 79291
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
79238: LD_ADDR_EXP 93
79242: PUSH
79243: LD_EXP 93
79247: PPUSH
79248: LD_VAR 0 3
79252: PPUSH
79253: LD_EXP 93
79257: PUSH
79258: LD_VAR 0 3
79262: ARRAY
79263: PPUSH
79264: LD_INT 1
79266: PPUSH
79267: LD_EXP 93
79271: PUSH
79272: LD_VAR 0 3
79276: ARRAY
79277: PPUSH
79278: LD_INT 0
79280: PPUSH
79281: CALL 18656 0 4
79285: PPUSH
79286: CALL_OW 1
79290: ST_TO_ADDR
// if not building in mc_bases [ i ] then
79291: LD_VAR 0 1
79295: PUSH
79296: LD_EXP 59
79300: PUSH
79301: LD_VAR 0 3
79305: ARRAY
79306: IN
79307: NOT
79308: IFFALSE 79354
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79310: LD_ADDR_EXP 59
79314: PUSH
79315: LD_EXP 59
79319: PPUSH
79320: LD_VAR 0 3
79324: PUSH
79325: LD_EXP 59
79329: PUSH
79330: LD_VAR 0 3
79334: ARRAY
79335: PUSH
79336: LD_INT 1
79338: PLUS
79339: PUSH
79340: EMPTY
79341: LIST
79342: LIST
79343: PPUSH
79344: LD_VAR 0 1
79348: PPUSH
79349: CALL 19238 0 3
79353: ST_TO_ADDR
// exit ;
79354: POP
79355: POP
79356: GO 79362
// end ; end ;
79358: GO 79162
79360: POP
79361: POP
// end ;
79362: LD_VAR 0 2
79366: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
79367: LD_INT 0
79369: PPUSH
79370: PPUSH
79371: PPUSH
79372: PPUSH
79373: PPUSH
79374: PPUSH
79375: PPUSH
// if not mc_bases or not skirmish then
79376: LD_EXP 59
79380: NOT
79381: PUSH
79382: LD_EXP 57
79386: NOT
79387: OR
79388: IFFALSE 79392
// exit ;
79390: GO 80053
// for i = 1 to mc_bases do
79392: LD_ADDR_VAR 0 3
79396: PUSH
79397: DOUBLE
79398: LD_INT 1
79400: DEC
79401: ST_TO_ADDR
79402: LD_EXP 59
79406: PUSH
79407: FOR_TO
79408: IFFALSE 80051
// begin if building in mc_construct_list [ i ] then
79410: LD_VAR 0 1
79414: PUSH
79415: LD_EXP 66
79419: PUSH
79420: LD_VAR 0 3
79424: ARRAY
79425: IN
79426: IFFALSE 80049
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79428: LD_ADDR_EXP 66
79432: PUSH
79433: LD_EXP 66
79437: PPUSH
79438: LD_VAR 0 3
79442: PPUSH
79443: LD_EXP 66
79447: PUSH
79448: LD_VAR 0 3
79452: ARRAY
79453: PUSH
79454: LD_VAR 0 1
79458: DIFF
79459: PPUSH
79460: CALL_OW 1
79464: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
79465: LD_ADDR_EXP 59
79469: PUSH
79470: LD_EXP 59
79474: PPUSH
79475: LD_VAR 0 3
79479: PUSH
79480: LD_EXP 59
79484: PUSH
79485: LD_VAR 0 3
79489: ARRAY
79490: PUSH
79491: LD_INT 1
79493: PLUS
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PPUSH
79499: LD_VAR 0 1
79503: PPUSH
79504: CALL 19238 0 3
79508: ST_TO_ADDR
// btype := GetBType ( building ) ;
79509: LD_ADDR_VAR 0 5
79513: PUSH
79514: LD_VAR 0 1
79518: PPUSH
79519: CALL_OW 266
79523: ST_TO_ADDR
// side := GetSide ( building ) ;
79524: LD_ADDR_VAR 0 8
79528: PUSH
79529: LD_VAR 0 1
79533: PPUSH
79534: CALL_OW 255
79538: ST_TO_ADDR
// if btype = b_lab then
79539: LD_VAR 0 5
79543: PUSH
79544: LD_INT 6
79546: EQUAL
79547: IFFALSE 79597
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
79549: LD_ADDR_EXP 92
79553: PUSH
79554: LD_EXP 92
79558: PPUSH
79559: LD_VAR 0 3
79563: PUSH
79564: LD_EXP 92
79568: PUSH
79569: LD_VAR 0 3
79573: ARRAY
79574: PUSH
79575: LD_INT 1
79577: PLUS
79578: PUSH
79579: EMPTY
79580: LIST
79581: LIST
79582: PPUSH
79583: LD_VAR 0 1
79587: PPUSH
79588: CALL 19238 0 3
79592: ST_TO_ADDR
// exit ;
79593: POP
79594: POP
79595: GO 80053
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
79597: LD_VAR 0 5
79601: PUSH
79602: LD_INT 0
79604: PUSH
79605: LD_INT 2
79607: PUSH
79608: LD_INT 4
79610: PUSH
79611: EMPTY
79612: LIST
79613: LIST
79614: LIST
79615: IN
79616: IFFALSE 79740
// begin if btype = b_armoury then
79618: LD_VAR 0 5
79622: PUSH
79623: LD_INT 4
79625: EQUAL
79626: IFFALSE 79636
// btype := b_barracks ;
79628: LD_ADDR_VAR 0 5
79632: PUSH
79633: LD_INT 5
79635: ST_TO_ADDR
// if btype = b_depot then
79636: LD_VAR 0 5
79640: PUSH
79641: LD_INT 0
79643: EQUAL
79644: IFFALSE 79654
// btype := b_warehouse ;
79646: LD_ADDR_VAR 0 5
79650: PUSH
79651: LD_INT 1
79653: ST_TO_ADDR
// if btype = b_workshop then
79654: LD_VAR 0 5
79658: PUSH
79659: LD_INT 2
79661: EQUAL
79662: IFFALSE 79672
// btype := b_factory ;
79664: LD_ADDR_VAR 0 5
79668: PUSH
79669: LD_INT 3
79671: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
79672: LD_VAR 0 5
79676: PPUSH
79677: LD_VAR 0 8
79681: PPUSH
79682: CALL_OW 323
79686: PUSH
79687: LD_INT 1
79689: EQUAL
79690: IFFALSE 79736
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
79692: LD_ADDR_EXP 91
79696: PUSH
79697: LD_EXP 91
79701: PPUSH
79702: LD_VAR 0 3
79706: PUSH
79707: LD_EXP 91
79711: PUSH
79712: LD_VAR 0 3
79716: ARRAY
79717: PUSH
79718: LD_INT 1
79720: PLUS
79721: PUSH
79722: EMPTY
79723: LIST
79724: LIST
79725: PPUSH
79726: LD_VAR 0 1
79730: PPUSH
79731: CALL 19238 0 3
79735: ST_TO_ADDR
// exit ;
79736: POP
79737: POP
79738: GO 80053
// end ; if btype in [ b_bunker , b_turret ] then
79740: LD_VAR 0 5
79744: PUSH
79745: LD_INT 32
79747: PUSH
79748: LD_INT 33
79750: PUSH
79751: EMPTY
79752: LIST
79753: LIST
79754: IN
79755: IFFALSE 80045
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
79757: LD_ADDR_EXP 67
79761: PUSH
79762: LD_EXP 67
79766: PPUSH
79767: LD_VAR 0 3
79771: PUSH
79772: LD_EXP 67
79776: PUSH
79777: LD_VAR 0 3
79781: ARRAY
79782: PUSH
79783: LD_INT 1
79785: PLUS
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PPUSH
79791: LD_VAR 0 1
79795: PPUSH
79796: CALL 19238 0 3
79800: ST_TO_ADDR
// if btype = b_bunker then
79801: LD_VAR 0 5
79805: PUSH
79806: LD_INT 32
79808: EQUAL
79809: IFFALSE 80045
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
79811: LD_ADDR_EXP 68
79815: PUSH
79816: LD_EXP 68
79820: PPUSH
79821: LD_VAR 0 3
79825: PUSH
79826: LD_EXP 68
79830: PUSH
79831: LD_VAR 0 3
79835: ARRAY
79836: PUSH
79837: LD_INT 1
79839: PLUS
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: PPUSH
79845: LD_VAR 0 1
79849: PPUSH
79850: CALL 19238 0 3
79854: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
79855: LD_ADDR_VAR 0 6
79859: PUSH
79860: LD_EXP 59
79864: PUSH
79865: LD_VAR 0 3
79869: ARRAY
79870: PPUSH
79871: LD_INT 25
79873: PUSH
79874: LD_INT 1
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 3
79883: PUSH
79884: LD_INT 54
79886: PUSH
79887: EMPTY
79888: LIST
79889: PUSH
79890: EMPTY
79891: LIST
79892: LIST
79893: PUSH
79894: EMPTY
79895: LIST
79896: LIST
79897: PPUSH
79898: CALL_OW 72
79902: ST_TO_ADDR
// if tmp then
79903: LD_VAR 0 6
79907: IFFALSE 79913
// exit ;
79909: POP
79910: POP
79911: GO 80053
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
79913: LD_ADDR_VAR 0 6
79917: PUSH
79918: LD_EXP 59
79922: PUSH
79923: LD_VAR 0 3
79927: ARRAY
79928: PPUSH
79929: LD_INT 2
79931: PUSH
79932: LD_INT 30
79934: PUSH
79935: LD_INT 4
79937: PUSH
79938: EMPTY
79939: LIST
79940: LIST
79941: PUSH
79942: LD_INT 30
79944: PUSH
79945: LD_INT 5
79947: PUSH
79948: EMPTY
79949: LIST
79950: LIST
79951: PUSH
79952: EMPTY
79953: LIST
79954: LIST
79955: LIST
79956: PPUSH
79957: CALL_OW 72
79961: ST_TO_ADDR
// if not tmp then
79962: LD_VAR 0 6
79966: NOT
79967: IFFALSE 79973
// exit ;
79969: POP
79970: POP
79971: GO 80053
// for j in tmp do
79973: LD_ADDR_VAR 0 4
79977: PUSH
79978: LD_VAR 0 6
79982: PUSH
79983: FOR_IN
79984: IFFALSE 80043
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
79986: LD_ADDR_VAR 0 7
79990: PUSH
79991: LD_VAR 0 4
79995: PPUSH
79996: CALL_OW 313
80000: PPUSH
80001: LD_INT 25
80003: PUSH
80004: LD_INT 1
80006: PUSH
80007: EMPTY
80008: LIST
80009: LIST
80010: PPUSH
80011: CALL_OW 72
80015: ST_TO_ADDR
// if units then
80016: LD_VAR 0 7
80020: IFFALSE 80041
// begin ComExitBuilding ( units [ 1 ] ) ;
80022: LD_VAR 0 7
80026: PUSH
80027: LD_INT 1
80029: ARRAY
80030: PPUSH
80031: CALL_OW 122
// exit ;
80035: POP
80036: POP
80037: POP
80038: POP
80039: GO 80053
// end ; end ;
80041: GO 79983
80043: POP
80044: POP
// end ; end ; exit ;
80045: POP
80046: POP
80047: GO 80053
// end ; end ;
80049: GO 79407
80051: POP
80052: POP
// end ;
80053: LD_VAR 0 2
80057: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80058: LD_INT 0
80060: PPUSH
80061: PPUSH
80062: PPUSH
80063: PPUSH
80064: PPUSH
80065: PPUSH
80066: PPUSH
// if not mc_bases or not skirmish then
80067: LD_EXP 59
80071: NOT
80072: PUSH
80073: LD_EXP 57
80077: NOT
80078: OR
80079: IFFALSE 80083
// exit ;
80081: GO 80314
// btype := GetBType ( building ) ;
80083: LD_ADDR_VAR 0 6
80087: PUSH
80088: LD_VAR 0 1
80092: PPUSH
80093: CALL_OW 266
80097: ST_TO_ADDR
// x := GetX ( building ) ;
80098: LD_ADDR_VAR 0 7
80102: PUSH
80103: LD_VAR 0 1
80107: PPUSH
80108: CALL_OW 250
80112: ST_TO_ADDR
// y := GetY ( building ) ;
80113: LD_ADDR_VAR 0 8
80117: PUSH
80118: LD_VAR 0 1
80122: PPUSH
80123: CALL_OW 251
80127: ST_TO_ADDR
// d := GetDir ( building ) ;
80128: LD_ADDR_VAR 0 9
80132: PUSH
80133: LD_VAR 0 1
80137: PPUSH
80138: CALL_OW 254
80142: ST_TO_ADDR
// for i = 1 to mc_bases do
80143: LD_ADDR_VAR 0 4
80147: PUSH
80148: DOUBLE
80149: LD_INT 1
80151: DEC
80152: ST_TO_ADDR
80153: LD_EXP 59
80157: PUSH
80158: FOR_TO
80159: IFFALSE 80312
// begin if not mc_build_list [ i ] then
80161: LD_EXP 64
80165: PUSH
80166: LD_VAR 0 4
80170: ARRAY
80171: NOT
80172: IFFALSE 80176
// continue ;
80174: GO 80158
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80176: LD_VAR 0 6
80180: PUSH
80181: LD_VAR 0 7
80185: PUSH
80186: LD_VAR 0 8
80190: PUSH
80191: LD_VAR 0 9
80195: PUSH
80196: EMPTY
80197: LIST
80198: LIST
80199: LIST
80200: LIST
80201: PPUSH
80202: LD_EXP 64
80206: PUSH
80207: LD_VAR 0 4
80211: ARRAY
80212: PUSH
80213: LD_INT 1
80215: ARRAY
80216: PPUSH
80217: CALL 25407 0 2
80221: IFFALSE 80310
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
80223: LD_ADDR_EXP 64
80227: PUSH
80228: LD_EXP 64
80232: PPUSH
80233: LD_VAR 0 4
80237: PPUSH
80238: LD_EXP 64
80242: PUSH
80243: LD_VAR 0 4
80247: ARRAY
80248: PPUSH
80249: LD_INT 1
80251: PPUSH
80252: CALL_OW 3
80256: PPUSH
80257: CALL_OW 1
80261: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
80262: LD_ADDR_EXP 66
80266: PUSH
80267: LD_EXP 66
80271: PPUSH
80272: LD_VAR 0 4
80276: PUSH
80277: LD_EXP 66
80281: PUSH
80282: LD_VAR 0 4
80286: ARRAY
80287: PUSH
80288: LD_INT 1
80290: PLUS
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: PPUSH
80296: LD_VAR 0 1
80300: PPUSH
80301: CALL 19238 0 3
80305: ST_TO_ADDR
// exit ;
80306: POP
80307: POP
80308: GO 80314
// end ; end ;
80310: GO 80158
80312: POP
80313: POP
// end ;
80314: LD_VAR 0 3
80318: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
80319: LD_INT 0
80321: PPUSH
80322: PPUSH
80323: PPUSH
// if not mc_bases or not skirmish then
80324: LD_EXP 59
80328: NOT
80329: PUSH
80330: LD_EXP 57
80334: NOT
80335: OR
80336: IFFALSE 80340
// exit ;
80338: GO 80530
// for i = 1 to mc_bases do
80340: LD_ADDR_VAR 0 4
80344: PUSH
80345: DOUBLE
80346: LD_INT 1
80348: DEC
80349: ST_TO_ADDR
80350: LD_EXP 59
80354: PUSH
80355: FOR_TO
80356: IFFALSE 80443
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
80358: LD_VAR 0 1
80362: PUSH
80363: LD_EXP 67
80367: PUSH
80368: LD_VAR 0 4
80372: ARRAY
80373: IN
80374: PUSH
80375: LD_VAR 0 1
80379: PUSH
80380: LD_EXP 68
80384: PUSH
80385: LD_VAR 0 4
80389: ARRAY
80390: IN
80391: NOT
80392: AND
80393: IFFALSE 80441
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80395: LD_ADDR_EXP 68
80399: PUSH
80400: LD_EXP 68
80404: PPUSH
80405: LD_VAR 0 4
80409: PUSH
80410: LD_EXP 68
80414: PUSH
80415: LD_VAR 0 4
80419: ARRAY
80420: PUSH
80421: LD_INT 1
80423: PLUS
80424: PUSH
80425: EMPTY
80426: LIST
80427: LIST
80428: PPUSH
80429: LD_VAR 0 1
80433: PPUSH
80434: CALL 19238 0 3
80438: ST_TO_ADDR
// break ;
80439: GO 80443
// end ; end ;
80441: GO 80355
80443: POP
80444: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
80445: LD_VAR 0 1
80449: PPUSH
80450: CALL_OW 257
80454: PUSH
80455: LD_EXP 85
80459: IN
80460: PUSH
80461: LD_VAR 0 1
80465: PPUSH
80466: CALL_OW 266
80470: PUSH
80471: LD_INT 5
80473: EQUAL
80474: AND
80475: PUSH
80476: LD_VAR 0 2
80480: PPUSH
80481: CALL_OW 110
80485: PUSH
80486: LD_INT 18
80488: NONEQUAL
80489: AND
80490: IFFALSE 80530
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
80492: LD_VAR 0 2
80496: PPUSH
80497: CALL_OW 257
80501: PUSH
80502: LD_INT 5
80504: PUSH
80505: LD_INT 8
80507: PUSH
80508: LD_INT 9
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: LIST
80515: IN
80516: IFFALSE 80530
// SetClass ( unit , 1 ) ;
80518: LD_VAR 0 2
80522: PPUSH
80523: LD_INT 1
80525: PPUSH
80526: CALL_OW 336
// end ;
80530: LD_VAR 0 3
80534: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
80535: LD_INT 0
80537: PPUSH
80538: PPUSH
// if not mc_bases or not skirmish then
80539: LD_EXP 59
80543: NOT
80544: PUSH
80545: LD_EXP 57
80549: NOT
80550: OR
80551: IFFALSE 80555
// exit ;
80553: GO 80671
// if GetLives ( abandoned_vehicle ) > 250 then
80555: LD_VAR 0 2
80559: PPUSH
80560: CALL_OW 256
80564: PUSH
80565: LD_INT 250
80567: GREATER
80568: IFFALSE 80572
// exit ;
80570: GO 80671
// for i = 1 to mc_bases do
80572: LD_ADDR_VAR 0 6
80576: PUSH
80577: DOUBLE
80578: LD_INT 1
80580: DEC
80581: ST_TO_ADDR
80582: LD_EXP 59
80586: PUSH
80587: FOR_TO
80588: IFFALSE 80669
// begin if driver in mc_bases [ i ] then
80590: LD_VAR 0 1
80594: PUSH
80595: LD_EXP 59
80599: PUSH
80600: LD_VAR 0 6
80604: ARRAY
80605: IN
80606: IFFALSE 80667
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
80608: LD_VAR 0 1
80612: PPUSH
80613: LD_EXP 59
80617: PUSH
80618: LD_VAR 0 6
80622: ARRAY
80623: PPUSH
80624: LD_INT 2
80626: PUSH
80627: LD_INT 30
80629: PUSH
80630: LD_INT 0
80632: PUSH
80633: EMPTY
80634: LIST
80635: LIST
80636: PUSH
80637: LD_INT 30
80639: PUSH
80640: LD_INT 1
80642: PUSH
80643: EMPTY
80644: LIST
80645: LIST
80646: PUSH
80647: EMPTY
80648: LIST
80649: LIST
80650: LIST
80651: PPUSH
80652: CALL_OW 72
80656: PUSH
80657: LD_INT 1
80659: ARRAY
80660: PPUSH
80661: CALL_OW 112
// break ;
80665: GO 80669
// end ; end ;
80667: GO 80587
80669: POP
80670: POP
// end ; end_of_file
80671: LD_VAR 0 5
80675: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
80676: LD_INT 0
80678: PPUSH
// ar_crane := 88 ;
80679: LD_ADDR_EXP 108
80683: PUSH
80684: LD_INT 88
80686: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
80687: LD_ADDR_EXP 103
80691: PUSH
80692: LD_INT 89
80694: ST_TO_ADDR
// us_hack := 99 ;
80695: LD_ADDR_EXP 104
80699: PUSH
80700: LD_INT 99
80702: ST_TO_ADDR
// us_artillery := 97 ;
80703: LD_ADDR_EXP 105
80707: PUSH
80708: LD_INT 97
80710: ST_TO_ADDR
// ar_bio_bomb := 91 ;
80711: LD_ADDR_EXP 106
80715: PUSH
80716: LD_INT 91
80718: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
80719: LD_ADDR_EXP 107
80723: PUSH
80724: LD_INT 92
80726: ST_TO_ADDR
// ru_radar := 98 ;
80727: LD_ADDR_EXP 102
80731: PUSH
80732: LD_INT 98
80734: ST_TO_ADDR
// tech_Artillery := 80 ;
80735: LD_ADDR_EXP 109
80739: PUSH
80740: LD_INT 80
80742: ST_TO_ADDR
// tech_RadMat := 81 ;
80743: LD_ADDR_EXP 110
80747: PUSH
80748: LD_INT 81
80750: ST_TO_ADDR
// tech_BasicTools := 82 ;
80751: LD_ADDR_EXP 111
80755: PUSH
80756: LD_INT 82
80758: ST_TO_ADDR
// tech_Cargo := 83 ;
80759: LD_ADDR_EXP 112
80763: PUSH
80764: LD_INT 83
80766: ST_TO_ADDR
// tech_Track := 84 ;
80767: LD_ADDR_EXP 113
80771: PUSH
80772: LD_INT 84
80774: ST_TO_ADDR
// tech_Crane := 85 ;
80775: LD_ADDR_EXP 114
80779: PUSH
80780: LD_INT 85
80782: ST_TO_ADDR
// tech_Bulldozer := 86 ;
80783: LD_ADDR_EXP 115
80787: PUSH
80788: LD_INT 86
80790: ST_TO_ADDR
// tech_Hovercraft := 87 ;
80791: LD_ADDR_EXP 116
80795: PUSH
80796: LD_INT 87
80798: ST_TO_ADDR
// end ;
80799: LD_VAR 0 1
80803: RET
// every 1 do
80804: GO 80806
80806: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
80807: CALL 80676 0 0
80811: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
80812: LD_VAR 0 2
80816: PUSH
80817: LD_INT 100
80819: EQUAL
80820: IFFALSE 81769
// begin if not StreamModeActive then
80822: LD_EXP 117
80826: NOT
80827: IFFALSE 80837
// StreamModeActive := true ;
80829: LD_ADDR_EXP 117
80833: PUSH
80834: LD_INT 1
80836: ST_TO_ADDR
// if p3 = 0 then
80837: LD_VAR 0 3
80841: PUSH
80842: LD_INT 0
80844: EQUAL
80845: IFFALSE 80851
// InitStreamMode ;
80847: CALL 82002 0 0
// if p3 = 1 then
80851: LD_VAR 0 3
80855: PUSH
80856: LD_INT 1
80858: EQUAL
80859: IFFALSE 80869
// sRocket := true ;
80861: LD_ADDR_EXP 122
80865: PUSH
80866: LD_INT 1
80868: ST_TO_ADDR
// if p3 = 2 then
80869: LD_VAR 0 3
80873: PUSH
80874: LD_INT 2
80876: EQUAL
80877: IFFALSE 80887
// sSpeed := true ;
80879: LD_ADDR_EXP 121
80883: PUSH
80884: LD_INT 1
80886: ST_TO_ADDR
// if p3 = 3 then
80887: LD_VAR 0 3
80891: PUSH
80892: LD_INT 3
80894: EQUAL
80895: IFFALSE 80905
// sEngine := true ;
80897: LD_ADDR_EXP 123
80901: PUSH
80902: LD_INT 1
80904: ST_TO_ADDR
// if p3 = 4 then
80905: LD_VAR 0 3
80909: PUSH
80910: LD_INT 4
80912: EQUAL
80913: IFFALSE 80923
// sSpec := true ;
80915: LD_ADDR_EXP 120
80919: PUSH
80920: LD_INT 1
80922: ST_TO_ADDR
// if p3 = 5 then
80923: LD_VAR 0 3
80927: PUSH
80928: LD_INT 5
80930: EQUAL
80931: IFFALSE 80941
// sLevel := true ;
80933: LD_ADDR_EXP 124
80937: PUSH
80938: LD_INT 1
80940: ST_TO_ADDR
// if p3 = 6 then
80941: LD_VAR 0 3
80945: PUSH
80946: LD_INT 6
80948: EQUAL
80949: IFFALSE 80959
// sArmoury := true ;
80951: LD_ADDR_EXP 125
80955: PUSH
80956: LD_INT 1
80958: ST_TO_ADDR
// if p3 = 7 then
80959: LD_VAR 0 3
80963: PUSH
80964: LD_INT 7
80966: EQUAL
80967: IFFALSE 80977
// sRadar := true ;
80969: LD_ADDR_EXP 126
80973: PUSH
80974: LD_INT 1
80976: ST_TO_ADDR
// if p3 = 8 then
80977: LD_VAR 0 3
80981: PUSH
80982: LD_INT 8
80984: EQUAL
80985: IFFALSE 80995
// sBunker := true ;
80987: LD_ADDR_EXP 127
80991: PUSH
80992: LD_INT 1
80994: ST_TO_ADDR
// if p3 = 9 then
80995: LD_VAR 0 3
80999: PUSH
81000: LD_INT 9
81002: EQUAL
81003: IFFALSE 81013
// sHack := true ;
81005: LD_ADDR_EXP 128
81009: PUSH
81010: LD_INT 1
81012: ST_TO_ADDR
// if p3 = 10 then
81013: LD_VAR 0 3
81017: PUSH
81018: LD_INT 10
81020: EQUAL
81021: IFFALSE 81031
// sFire := true ;
81023: LD_ADDR_EXP 129
81027: PUSH
81028: LD_INT 1
81030: ST_TO_ADDR
// if p3 = 11 then
81031: LD_VAR 0 3
81035: PUSH
81036: LD_INT 11
81038: EQUAL
81039: IFFALSE 81049
// sRefresh := true ;
81041: LD_ADDR_EXP 130
81045: PUSH
81046: LD_INT 1
81048: ST_TO_ADDR
// if p3 = 12 then
81049: LD_VAR 0 3
81053: PUSH
81054: LD_INT 12
81056: EQUAL
81057: IFFALSE 81067
// sExp := true ;
81059: LD_ADDR_EXP 131
81063: PUSH
81064: LD_INT 1
81066: ST_TO_ADDR
// if p3 = 13 then
81067: LD_VAR 0 3
81071: PUSH
81072: LD_INT 13
81074: EQUAL
81075: IFFALSE 81085
// sDepot := true ;
81077: LD_ADDR_EXP 132
81081: PUSH
81082: LD_INT 1
81084: ST_TO_ADDR
// if p3 = 14 then
81085: LD_VAR 0 3
81089: PUSH
81090: LD_INT 14
81092: EQUAL
81093: IFFALSE 81103
// sFlag := true ;
81095: LD_ADDR_EXP 133
81099: PUSH
81100: LD_INT 1
81102: ST_TO_ADDR
// if p3 = 15 then
81103: LD_VAR 0 3
81107: PUSH
81108: LD_INT 15
81110: EQUAL
81111: IFFALSE 81121
// sKamikadze := true ;
81113: LD_ADDR_EXP 141
81117: PUSH
81118: LD_INT 1
81120: ST_TO_ADDR
// if p3 = 16 then
81121: LD_VAR 0 3
81125: PUSH
81126: LD_INT 16
81128: EQUAL
81129: IFFALSE 81139
// sTroll := true ;
81131: LD_ADDR_EXP 142
81135: PUSH
81136: LD_INT 1
81138: ST_TO_ADDR
// if p3 = 17 then
81139: LD_VAR 0 3
81143: PUSH
81144: LD_INT 17
81146: EQUAL
81147: IFFALSE 81157
// sSlow := true ;
81149: LD_ADDR_EXP 143
81153: PUSH
81154: LD_INT 1
81156: ST_TO_ADDR
// if p3 = 18 then
81157: LD_VAR 0 3
81161: PUSH
81162: LD_INT 18
81164: EQUAL
81165: IFFALSE 81175
// sLack := true ;
81167: LD_ADDR_EXP 144
81171: PUSH
81172: LD_INT 1
81174: ST_TO_ADDR
// if p3 = 19 then
81175: LD_VAR 0 3
81179: PUSH
81180: LD_INT 19
81182: EQUAL
81183: IFFALSE 81193
// sTank := true ;
81185: LD_ADDR_EXP 146
81189: PUSH
81190: LD_INT 1
81192: ST_TO_ADDR
// if p3 = 20 then
81193: LD_VAR 0 3
81197: PUSH
81198: LD_INT 20
81200: EQUAL
81201: IFFALSE 81211
// sRemote := true ;
81203: LD_ADDR_EXP 147
81207: PUSH
81208: LD_INT 1
81210: ST_TO_ADDR
// if p3 = 21 then
81211: LD_VAR 0 3
81215: PUSH
81216: LD_INT 21
81218: EQUAL
81219: IFFALSE 81229
// sPowell := true ;
81221: LD_ADDR_EXP 148
81225: PUSH
81226: LD_INT 1
81228: ST_TO_ADDR
// if p3 = 22 then
81229: LD_VAR 0 3
81233: PUSH
81234: LD_INT 22
81236: EQUAL
81237: IFFALSE 81247
// sTeleport := true ;
81239: LD_ADDR_EXP 151
81243: PUSH
81244: LD_INT 1
81246: ST_TO_ADDR
// if p3 = 23 then
81247: LD_VAR 0 3
81251: PUSH
81252: LD_INT 23
81254: EQUAL
81255: IFFALSE 81265
// sOilTower := true ;
81257: LD_ADDR_EXP 153
81261: PUSH
81262: LD_INT 1
81264: ST_TO_ADDR
// if p3 = 24 then
81265: LD_VAR 0 3
81269: PUSH
81270: LD_INT 24
81272: EQUAL
81273: IFFALSE 81283
// sShovel := true ;
81275: LD_ADDR_EXP 154
81279: PUSH
81280: LD_INT 1
81282: ST_TO_ADDR
// if p3 = 25 then
81283: LD_VAR 0 3
81287: PUSH
81288: LD_INT 25
81290: EQUAL
81291: IFFALSE 81301
// sSheik := true ;
81293: LD_ADDR_EXP 155
81297: PUSH
81298: LD_INT 1
81300: ST_TO_ADDR
// if p3 = 26 then
81301: LD_VAR 0 3
81305: PUSH
81306: LD_INT 26
81308: EQUAL
81309: IFFALSE 81319
// sEarthquake := true ;
81311: LD_ADDR_EXP 157
81315: PUSH
81316: LD_INT 1
81318: ST_TO_ADDR
// if p3 = 27 then
81319: LD_VAR 0 3
81323: PUSH
81324: LD_INT 27
81326: EQUAL
81327: IFFALSE 81337
// sAI := true ;
81329: LD_ADDR_EXP 158
81333: PUSH
81334: LD_INT 1
81336: ST_TO_ADDR
// if p3 = 28 then
81337: LD_VAR 0 3
81341: PUSH
81342: LD_INT 28
81344: EQUAL
81345: IFFALSE 81355
// sCargo := true ;
81347: LD_ADDR_EXP 161
81351: PUSH
81352: LD_INT 1
81354: ST_TO_ADDR
// if p3 = 29 then
81355: LD_VAR 0 3
81359: PUSH
81360: LD_INT 29
81362: EQUAL
81363: IFFALSE 81373
// sDLaser := true ;
81365: LD_ADDR_EXP 162
81369: PUSH
81370: LD_INT 1
81372: ST_TO_ADDR
// if p3 = 30 then
81373: LD_VAR 0 3
81377: PUSH
81378: LD_INT 30
81380: EQUAL
81381: IFFALSE 81391
// sExchange := true ;
81383: LD_ADDR_EXP 163
81387: PUSH
81388: LD_INT 1
81390: ST_TO_ADDR
// if p3 = 31 then
81391: LD_VAR 0 3
81395: PUSH
81396: LD_INT 31
81398: EQUAL
81399: IFFALSE 81409
// sFac := true ;
81401: LD_ADDR_EXP 164
81405: PUSH
81406: LD_INT 1
81408: ST_TO_ADDR
// if p3 = 32 then
81409: LD_VAR 0 3
81413: PUSH
81414: LD_INT 32
81416: EQUAL
81417: IFFALSE 81427
// sPower := true ;
81419: LD_ADDR_EXP 165
81423: PUSH
81424: LD_INT 1
81426: ST_TO_ADDR
// if p3 = 33 then
81427: LD_VAR 0 3
81431: PUSH
81432: LD_INT 33
81434: EQUAL
81435: IFFALSE 81445
// sRandom := true ;
81437: LD_ADDR_EXP 166
81441: PUSH
81442: LD_INT 1
81444: ST_TO_ADDR
// if p3 = 34 then
81445: LD_VAR 0 3
81449: PUSH
81450: LD_INT 34
81452: EQUAL
81453: IFFALSE 81463
// sShield := true ;
81455: LD_ADDR_EXP 167
81459: PUSH
81460: LD_INT 1
81462: ST_TO_ADDR
// if p3 = 35 then
81463: LD_VAR 0 3
81467: PUSH
81468: LD_INT 35
81470: EQUAL
81471: IFFALSE 81481
// sTime := true ;
81473: LD_ADDR_EXP 168
81477: PUSH
81478: LD_INT 1
81480: ST_TO_ADDR
// if p3 = 36 then
81481: LD_VAR 0 3
81485: PUSH
81486: LD_INT 36
81488: EQUAL
81489: IFFALSE 81499
// sTools := true ;
81491: LD_ADDR_EXP 169
81495: PUSH
81496: LD_INT 1
81498: ST_TO_ADDR
// if p3 = 101 then
81499: LD_VAR 0 3
81503: PUSH
81504: LD_INT 101
81506: EQUAL
81507: IFFALSE 81517
// sSold := true ;
81509: LD_ADDR_EXP 134
81513: PUSH
81514: LD_INT 1
81516: ST_TO_ADDR
// if p3 = 102 then
81517: LD_VAR 0 3
81521: PUSH
81522: LD_INT 102
81524: EQUAL
81525: IFFALSE 81535
// sDiff := true ;
81527: LD_ADDR_EXP 135
81531: PUSH
81532: LD_INT 1
81534: ST_TO_ADDR
// if p3 = 103 then
81535: LD_VAR 0 3
81539: PUSH
81540: LD_INT 103
81542: EQUAL
81543: IFFALSE 81553
// sFog := true ;
81545: LD_ADDR_EXP 138
81549: PUSH
81550: LD_INT 1
81552: ST_TO_ADDR
// if p3 = 104 then
81553: LD_VAR 0 3
81557: PUSH
81558: LD_INT 104
81560: EQUAL
81561: IFFALSE 81571
// sReset := true ;
81563: LD_ADDR_EXP 139
81567: PUSH
81568: LD_INT 1
81570: ST_TO_ADDR
// if p3 = 105 then
81571: LD_VAR 0 3
81575: PUSH
81576: LD_INT 105
81578: EQUAL
81579: IFFALSE 81589
// sSun := true ;
81581: LD_ADDR_EXP 140
81585: PUSH
81586: LD_INT 1
81588: ST_TO_ADDR
// if p3 = 106 then
81589: LD_VAR 0 3
81593: PUSH
81594: LD_INT 106
81596: EQUAL
81597: IFFALSE 81607
// sTiger := true ;
81599: LD_ADDR_EXP 136
81603: PUSH
81604: LD_INT 1
81606: ST_TO_ADDR
// if p3 = 107 then
81607: LD_VAR 0 3
81611: PUSH
81612: LD_INT 107
81614: EQUAL
81615: IFFALSE 81625
// sBomb := true ;
81617: LD_ADDR_EXP 137
81621: PUSH
81622: LD_INT 1
81624: ST_TO_ADDR
// if p3 = 108 then
81625: LD_VAR 0 3
81629: PUSH
81630: LD_INT 108
81632: EQUAL
81633: IFFALSE 81643
// sWound := true ;
81635: LD_ADDR_EXP 145
81639: PUSH
81640: LD_INT 1
81642: ST_TO_ADDR
// if p3 = 109 then
81643: LD_VAR 0 3
81647: PUSH
81648: LD_INT 109
81650: EQUAL
81651: IFFALSE 81661
// sBetray := true ;
81653: LD_ADDR_EXP 149
81657: PUSH
81658: LD_INT 1
81660: ST_TO_ADDR
// if p3 = 110 then
81661: LD_VAR 0 3
81665: PUSH
81666: LD_INT 110
81668: EQUAL
81669: IFFALSE 81679
// sContamin := true ;
81671: LD_ADDR_EXP 150
81675: PUSH
81676: LD_INT 1
81678: ST_TO_ADDR
// if p3 = 111 then
81679: LD_VAR 0 3
81683: PUSH
81684: LD_INT 111
81686: EQUAL
81687: IFFALSE 81697
// sOil := true ;
81689: LD_ADDR_EXP 152
81693: PUSH
81694: LD_INT 1
81696: ST_TO_ADDR
// if p3 = 112 then
81697: LD_VAR 0 3
81701: PUSH
81702: LD_INT 112
81704: EQUAL
81705: IFFALSE 81715
// sStu := true ;
81707: LD_ADDR_EXP 156
81711: PUSH
81712: LD_INT 1
81714: ST_TO_ADDR
// if p3 = 113 then
81715: LD_VAR 0 3
81719: PUSH
81720: LD_INT 113
81722: EQUAL
81723: IFFALSE 81733
// sBazooka := true ;
81725: LD_ADDR_EXP 159
81729: PUSH
81730: LD_INT 1
81732: ST_TO_ADDR
// if p3 = 114 then
81733: LD_VAR 0 3
81737: PUSH
81738: LD_INT 114
81740: EQUAL
81741: IFFALSE 81751
// sMortar := true ;
81743: LD_ADDR_EXP 160
81747: PUSH
81748: LD_INT 1
81750: ST_TO_ADDR
// if p3 = 115 then
81751: LD_VAR 0 3
81755: PUSH
81756: LD_INT 115
81758: EQUAL
81759: IFFALSE 81769
// sRanger := true ;
81761: LD_ADDR_EXP 170
81765: PUSH
81766: LD_INT 1
81768: ST_TO_ADDR
// end ; if p2 = 101 then
81769: LD_VAR 0 2
81773: PUSH
81774: LD_INT 101
81776: EQUAL
81777: IFFALSE 81980
// begin case p3 of 1 :
81779: LD_VAR 0 3
81783: PUSH
81784: LD_INT 1
81786: DOUBLE
81787: EQUAL
81788: IFTRUE 81792
81790: GO 81799
81792: POP
// hHackUnlimitedResources ; 2 :
81793: CALL 92074 0 0
81797: GO 81980
81799: LD_INT 2
81801: DOUBLE
81802: EQUAL
81803: IFTRUE 81807
81805: GO 81814
81807: POP
// hHackSetLevel10 ; 3 :
81808: CALL 92207 0 0
81812: GO 81980
81814: LD_INT 3
81816: DOUBLE
81817: EQUAL
81818: IFTRUE 81822
81820: GO 81829
81822: POP
// hHackSetLevel10YourUnits ; 4 :
81823: CALL 92292 0 0
81827: GO 81980
81829: LD_INT 4
81831: DOUBLE
81832: EQUAL
81833: IFTRUE 81837
81835: GO 81859
81837: POP
// hHackSpawnHuman ( p4 , p5 , p6 ) ; 5 :
81838: LD_VAR 0 4
81842: PPUSH
81843: LD_VAR 0 5
81847: PPUSH
81848: LD_VAR 0 6
81852: PPUSH
81853: CALL 92382 0 3
81857: GO 81980
81859: LD_INT 5
81861: DOUBLE
81862: EQUAL
81863: IFTRUE 81867
81865: GO 81874
81867: POP
// hHackSpawnVehicle ; 6 :
81868: CALL 92443 0 0
81872: GO 81980
81874: LD_INT 6
81876: DOUBLE
81877: EQUAL
81878: IFTRUE 81882
81880: GO 81889
81882: POP
// hHackInvincible ; 7 :
81883: CALL 92989 0 0
81887: GO 81980
81889: LD_INT 7
81891: DOUBLE
81892: EQUAL
81893: IFTRUE 81897
81895: GO 81904
81897: POP
// hHackInvisible ; 8 :
81898: CALL 93100 0 0
81902: GO 81980
81904: LD_INT 8
81906: DOUBLE
81907: EQUAL
81908: IFTRUE 81912
81910: GO 81919
81912: POP
// hHackChangeYourSide ; 9 :
81913: CALL 93157 0 0
81917: GO 81980
81919: LD_INT 9
81921: DOUBLE
81922: EQUAL
81923: IFTRUE 81927
81925: GO 81934
81927: POP
// hHackChangeUnitSide ; 10 :
81928: CALL 93199 0 0
81932: GO 81980
81934: LD_INT 10
81936: DOUBLE
81937: EQUAL
81938: IFTRUE 81942
81940: GO 81949
81942: POP
// hHackFog ; 11 :
81943: CALL 93300 0 0
81947: GO 81980
81949: LD_INT 11
81951: DOUBLE
81952: EQUAL
81953: IFTRUE 81957
81955: GO 81964
81957: POP
// hHackApeman ; 12 :
81958: CALL 93315 0 0
81962: GO 81980
81964: LD_INT 12
81966: DOUBLE
81967: EQUAL
81968: IFTRUE 81972
81970: GO 81979
81972: POP
// hHackBoom ; end ;
81973: CALL 93400 0 0
81977: GO 81980
81979: POP
// end ; end ;
81980: PPOPN 6
81982: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
81983: GO 81985
81985: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
81986: LD_STRING initStreamRollete();
81988: PPUSH
81989: CALL_OW 559
// InitStreamMode ;
81993: CALL 82002 0 0
// DefineStreamItems ( ) ;
81997: CALL 82442 0 0
// end ;
82001: END
// function InitStreamMode ; begin
82002: LD_INT 0
82004: PPUSH
// streamModeActive := false ;
82005: LD_ADDR_EXP 117
82009: PUSH
82010: LD_INT 0
82012: ST_TO_ADDR
// normalCounter := 36 ;
82013: LD_ADDR_EXP 118
82017: PUSH
82018: LD_INT 36
82020: ST_TO_ADDR
// hardcoreCounter := 16 ;
82021: LD_ADDR_EXP 119
82025: PUSH
82026: LD_INT 16
82028: ST_TO_ADDR
// sRocket := false ;
82029: LD_ADDR_EXP 122
82033: PUSH
82034: LD_INT 0
82036: ST_TO_ADDR
// sSpeed := false ;
82037: LD_ADDR_EXP 121
82041: PUSH
82042: LD_INT 0
82044: ST_TO_ADDR
// sEngine := false ;
82045: LD_ADDR_EXP 123
82049: PUSH
82050: LD_INT 0
82052: ST_TO_ADDR
// sSpec := false ;
82053: LD_ADDR_EXP 120
82057: PUSH
82058: LD_INT 0
82060: ST_TO_ADDR
// sLevel := false ;
82061: LD_ADDR_EXP 124
82065: PUSH
82066: LD_INT 0
82068: ST_TO_ADDR
// sArmoury := false ;
82069: LD_ADDR_EXP 125
82073: PUSH
82074: LD_INT 0
82076: ST_TO_ADDR
// sRadar := false ;
82077: LD_ADDR_EXP 126
82081: PUSH
82082: LD_INT 0
82084: ST_TO_ADDR
// sBunker := false ;
82085: LD_ADDR_EXP 127
82089: PUSH
82090: LD_INT 0
82092: ST_TO_ADDR
// sHack := false ;
82093: LD_ADDR_EXP 128
82097: PUSH
82098: LD_INT 0
82100: ST_TO_ADDR
// sFire := false ;
82101: LD_ADDR_EXP 129
82105: PUSH
82106: LD_INT 0
82108: ST_TO_ADDR
// sRefresh := false ;
82109: LD_ADDR_EXP 130
82113: PUSH
82114: LD_INT 0
82116: ST_TO_ADDR
// sExp := false ;
82117: LD_ADDR_EXP 131
82121: PUSH
82122: LD_INT 0
82124: ST_TO_ADDR
// sDepot := false ;
82125: LD_ADDR_EXP 132
82129: PUSH
82130: LD_INT 0
82132: ST_TO_ADDR
// sFlag := false ;
82133: LD_ADDR_EXP 133
82137: PUSH
82138: LD_INT 0
82140: ST_TO_ADDR
// sKamikadze := false ;
82141: LD_ADDR_EXP 141
82145: PUSH
82146: LD_INT 0
82148: ST_TO_ADDR
// sTroll := false ;
82149: LD_ADDR_EXP 142
82153: PUSH
82154: LD_INT 0
82156: ST_TO_ADDR
// sSlow := false ;
82157: LD_ADDR_EXP 143
82161: PUSH
82162: LD_INT 0
82164: ST_TO_ADDR
// sLack := false ;
82165: LD_ADDR_EXP 144
82169: PUSH
82170: LD_INT 0
82172: ST_TO_ADDR
// sTank := false ;
82173: LD_ADDR_EXP 146
82177: PUSH
82178: LD_INT 0
82180: ST_TO_ADDR
// sRemote := false ;
82181: LD_ADDR_EXP 147
82185: PUSH
82186: LD_INT 0
82188: ST_TO_ADDR
// sPowell := false ;
82189: LD_ADDR_EXP 148
82193: PUSH
82194: LD_INT 0
82196: ST_TO_ADDR
// sTeleport := false ;
82197: LD_ADDR_EXP 151
82201: PUSH
82202: LD_INT 0
82204: ST_TO_ADDR
// sOilTower := false ;
82205: LD_ADDR_EXP 153
82209: PUSH
82210: LD_INT 0
82212: ST_TO_ADDR
// sShovel := false ;
82213: LD_ADDR_EXP 154
82217: PUSH
82218: LD_INT 0
82220: ST_TO_ADDR
// sSheik := false ;
82221: LD_ADDR_EXP 155
82225: PUSH
82226: LD_INT 0
82228: ST_TO_ADDR
// sEarthquake := false ;
82229: LD_ADDR_EXP 157
82233: PUSH
82234: LD_INT 0
82236: ST_TO_ADDR
// sAI := false ;
82237: LD_ADDR_EXP 158
82241: PUSH
82242: LD_INT 0
82244: ST_TO_ADDR
// sCargo := false ;
82245: LD_ADDR_EXP 161
82249: PUSH
82250: LD_INT 0
82252: ST_TO_ADDR
// sDLaser := false ;
82253: LD_ADDR_EXP 162
82257: PUSH
82258: LD_INT 0
82260: ST_TO_ADDR
// sExchange := false ;
82261: LD_ADDR_EXP 163
82265: PUSH
82266: LD_INT 0
82268: ST_TO_ADDR
// sFac := false ;
82269: LD_ADDR_EXP 164
82273: PUSH
82274: LD_INT 0
82276: ST_TO_ADDR
// sPower := false ;
82277: LD_ADDR_EXP 165
82281: PUSH
82282: LD_INT 0
82284: ST_TO_ADDR
// sRandom := false ;
82285: LD_ADDR_EXP 166
82289: PUSH
82290: LD_INT 0
82292: ST_TO_ADDR
// sShield := false ;
82293: LD_ADDR_EXP 167
82297: PUSH
82298: LD_INT 0
82300: ST_TO_ADDR
// sTime := false ;
82301: LD_ADDR_EXP 168
82305: PUSH
82306: LD_INT 0
82308: ST_TO_ADDR
// sTools := false ;
82309: LD_ADDR_EXP 169
82313: PUSH
82314: LD_INT 0
82316: ST_TO_ADDR
// sSold := false ;
82317: LD_ADDR_EXP 134
82321: PUSH
82322: LD_INT 0
82324: ST_TO_ADDR
// sDiff := false ;
82325: LD_ADDR_EXP 135
82329: PUSH
82330: LD_INT 0
82332: ST_TO_ADDR
// sFog := false ;
82333: LD_ADDR_EXP 138
82337: PUSH
82338: LD_INT 0
82340: ST_TO_ADDR
// sReset := false ;
82341: LD_ADDR_EXP 139
82345: PUSH
82346: LD_INT 0
82348: ST_TO_ADDR
// sSun := false ;
82349: LD_ADDR_EXP 140
82353: PUSH
82354: LD_INT 0
82356: ST_TO_ADDR
// sTiger := false ;
82357: LD_ADDR_EXP 136
82361: PUSH
82362: LD_INT 0
82364: ST_TO_ADDR
// sBomb := false ;
82365: LD_ADDR_EXP 137
82369: PUSH
82370: LD_INT 0
82372: ST_TO_ADDR
// sWound := false ;
82373: LD_ADDR_EXP 145
82377: PUSH
82378: LD_INT 0
82380: ST_TO_ADDR
// sBetray := false ;
82381: LD_ADDR_EXP 149
82385: PUSH
82386: LD_INT 0
82388: ST_TO_ADDR
// sContamin := false ;
82389: LD_ADDR_EXP 150
82393: PUSH
82394: LD_INT 0
82396: ST_TO_ADDR
// sOil := false ;
82397: LD_ADDR_EXP 152
82401: PUSH
82402: LD_INT 0
82404: ST_TO_ADDR
// sStu := false ;
82405: LD_ADDR_EXP 156
82409: PUSH
82410: LD_INT 0
82412: ST_TO_ADDR
// sBazooka := false ;
82413: LD_ADDR_EXP 159
82417: PUSH
82418: LD_INT 0
82420: ST_TO_ADDR
// sMortar := false ;
82421: LD_ADDR_EXP 160
82425: PUSH
82426: LD_INT 0
82428: ST_TO_ADDR
// sRanger := false ;
82429: LD_ADDR_EXP 170
82433: PUSH
82434: LD_INT 0
82436: ST_TO_ADDR
// end ;
82437: LD_VAR 0 1
82441: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
82442: LD_INT 0
82444: PPUSH
82445: PPUSH
82446: PPUSH
82447: PPUSH
82448: PPUSH
// result := [ ] ;
82449: LD_ADDR_VAR 0 1
82453: PUSH
82454: EMPTY
82455: ST_TO_ADDR
// if campaign_id = 1 then
82456: LD_OWVAR 69
82460: PUSH
82461: LD_INT 1
82463: EQUAL
82464: IFFALSE 85402
// begin case mission_number of 1 :
82466: LD_OWVAR 70
82470: PUSH
82471: LD_INT 1
82473: DOUBLE
82474: EQUAL
82475: IFTRUE 82479
82477: GO 82543
82479: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
82480: LD_ADDR_VAR 0 1
82484: PUSH
82485: LD_INT 2
82487: PUSH
82488: LD_INT 4
82490: PUSH
82491: LD_INT 11
82493: PUSH
82494: LD_INT 12
82496: PUSH
82497: LD_INT 15
82499: PUSH
82500: LD_INT 16
82502: PUSH
82503: LD_INT 22
82505: PUSH
82506: LD_INT 23
82508: PUSH
82509: LD_INT 26
82511: PUSH
82512: EMPTY
82513: LIST
82514: LIST
82515: LIST
82516: LIST
82517: LIST
82518: LIST
82519: LIST
82520: LIST
82521: LIST
82522: PUSH
82523: LD_INT 101
82525: PUSH
82526: LD_INT 102
82528: PUSH
82529: LD_INT 106
82531: PUSH
82532: EMPTY
82533: LIST
82534: LIST
82535: LIST
82536: PUSH
82537: EMPTY
82538: LIST
82539: LIST
82540: ST_TO_ADDR
82541: GO 85400
82543: LD_INT 2
82545: DOUBLE
82546: EQUAL
82547: IFTRUE 82551
82549: GO 82623
82551: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
82552: LD_ADDR_VAR 0 1
82556: PUSH
82557: LD_INT 2
82559: PUSH
82560: LD_INT 4
82562: PUSH
82563: LD_INT 11
82565: PUSH
82566: LD_INT 12
82568: PUSH
82569: LD_INT 15
82571: PUSH
82572: LD_INT 16
82574: PUSH
82575: LD_INT 22
82577: PUSH
82578: LD_INT 23
82580: PUSH
82581: LD_INT 26
82583: PUSH
82584: EMPTY
82585: LIST
82586: LIST
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: PUSH
82595: LD_INT 101
82597: PUSH
82598: LD_INT 102
82600: PUSH
82601: LD_INT 105
82603: PUSH
82604: LD_INT 106
82606: PUSH
82607: LD_INT 108
82609: PUSH
82610: EMPTY
82611: LIST
82612: LIST
82613: LIST
82614: LIST
82615: LIST
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: ST_TO_ADDR
82621: GO 85400
82623: LD_INT 3
82625: DOUBLE
82626: EQUAL
82627: IFTRUE 82631
82629: GO 82707
82631: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
82632: LD_ADDR_VAR 0 1
82636: PUSH
82637: LD_INT 2
82639: PUSH
82640: LD_INT 4
82642: PUSH
82643: LD_INT 5
82645: PUSH
82646: LD_INT 11
82648: PUSH
82649: LD_INT 12
82651: PUSH
82652: LD_INT 15
82654: PUSH
82655: LD_INT 16
82657: PUSH
82658: LD_INT 22
82660: PUSH
82661: LD_INT 26
82663: PUSH
82664: LD_INT 36
82666: PUSH
82667: EMPTY
82668: LIST
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: LIST
82675: LIST
82676: LIST
82677: LIST
82678: PUSH
82679: LD_INT 101
82681: PUSH
82682: LD_INT 102
82684: PUSH
82685: LD_INT 105
82687: PUSH
82688: LD_INT 106
82690: PUSH
82691: LD_INT 108
82693: PUSH
82694: EMPTY
82695: LIST
82696: LIST
82697: LIST
82698: LIST
82699: LIST
82700: PUSH
82701: EMPTY
82702: LIST
82703: LIST
82704: ST_TO_ADDR
82705: GO 85400
82707: LD_INT 4
82709: DOUBLE
82710: EQUAL
82711: IFTRUE 82715
82713: GO 82799
82715: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
82716: LD_ADDR_VAR 0 1
82720: PUSH
82721: LD_INT 2
82723: PUSH
82724: LD_INT 4
82726: PUSH
82727: LD_INT 5
82729: PUSH
82730: LD_INT 8
82732: PUSH
82733: LD_INT 11
82735: PUSH
82736: LD_INT 12
82738: PUSH
82739: LD_INT 15
82741: PUSH
82742: LD_INT 16
82744: PUSH
82745: LD_INT 22
82747: PUSH
82748: LD_INT 23
82750: PUSH
82751: LD_INT 26
82753: PUSH
82754: LD_INT 36
82756: PUSH
82757: EMPTY
82758: LIST
82759: LIST
82760: LIST
82761: LIST
82762: LIST
82763: LIST
82764: LIST
82765: LIST
82766: LIST
82767: LIST
82768: LIST
82769: LIST
82770: PUSH
82771: LD_INT 101
82773: PUSH
82774: LD_INT 102
82776: PUSH
82777: LD_INT 105
82779: PUSH
82780: LD_INT 106
82782: PUSH
82783: LD_INT 108
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: LIST
82790: LIST
82791: LIST
82792: PUSH
82793: EMPTY
82794: LIST
82795: LIST
82796: ST_TO_ADDR
82797: GO 85400
82799: LD_INT 5
82801: DOUBLE
82802: EQUAL
82803: IFTRUE 82807
82805: GO 82907
82807: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
82808: LD_ADDR_VAR 0 1
82812: PUSH
82813: LD_INT 2
82815: PUSH
82816: LD_INT 4
82818: PUSH
82819: LD_INT 5
82821: PUSH
82822: LD_INT 6
82824: PUSH
82825: LD_INT 8
82827: PUSH
82828: LD_INT 11
82830: PUSH
82831: LD_INT 12
82833: PUSH
82834: LD_INT 15
82836: PUSH
82837: LD_INT 16
82839: PUSH
82840: LD_INT 22
82842: PUSH
82843: LD_INT 23
82845: PUSH
82846: LD_INT 25
82848: PUSH
82849: LD_INT 26
82851: PUSH
82852: LD_INT 36
82854: PUSH
82855: EMPTY
82856: LIST
82857: LIST
82858: LIST
82859: LIST
82860: LIST
82861: LIST
82862: LIST
82863: LIST
82864: LIST
82865: LIST
82866: LIST
82867: LIST
82868: LIST
82869: LIST
82870: PUSH
82871: LD_INT 101
82873: PUSH
82874: LD_INT 102
82876: PUSH
82877: LD_INT 105
82879: PUSH
82880: LD_INT 106
82882: PUSH
82883: LD_INT 108
82885: PUSH
82886: LD_INT 109
82888: PUSH
82889: LD_INT 112
82891: PUSH
82892: EMPTY
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: PUSH
82901: EMPTY
82902: LIST
82903: LIST
82904: ST_TO_ADDR
82905: GO 85400
82907: LD_INT 6
82909: DOUBLE
82910: EQUAL
82911: IFTRUE 82915
82913: GO 83035
82915: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
82916: LD_ADDR_VAR 0 1
82920: PUSH
82921: LD_INT 2
82923: PUSH
82924: LD_INT 4
82926: PUSH
82927: LD_INT 5
82929: PUSH
82930: LD_INT 6
82932: PUSH
82933: LD_INT 8
82935: PUSH
82936: LD_INT 11
82938: PUSH
82939: LD_INT 12
82941: PUSH
82942: LD_INT 15
82944: PUSH
82945: LD_INT 16
82947: PUSH
82948: LD_INT 20
82950: PUSH
82951: LD_INT 21
82953: PUSH
82954: LD_INT 22
82956: PUSH
82957: LD_INT 23
82959: PUSH
82960: LD_INT 25
82962: PUSH
82963: LD_INT 26
82965: PUSH
82966: LD_INT 30
82968: PUSH
82969: LD_INT 31
82971: PUSH
82972: LD_INT 32
82974: PUSH
82975: LD_INT 36
82977: PUSH
82978: EMPTY
82979: LIST
82980: LIST
82981: LIST
82982: LIST
82983: LIST
82984: LIST
82985: LIST
82986: LIST
82987: LIST
82988: LIST
82989: LIST
82990: LIST
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: LIST
82997: LIST
82998: PUSH
82999: LD_INT 101
83001: PUSH
83002: LD_INT 102
83004: PUSH
83005: LD_INT 105
83007: PUSH
83008: LD_INT 106
83010: PUSH
83011: LD_INT 108
83013: PUSH
83014: LD_INT 109
83016: PUSH
83017: LD_INT 112
83019: PUSH
83020: EMPTY
83021: LIST
83022: LIST
83023: LIST
83024: LIST
83025: LIST
83026: LIST
83027: LIST
83028: PUSH
83029: EMPTY
83030: LIST
83031: LIST
83032: ST_TO_ADDR
83033: GO 85400
83035: LD_INT 7
83037: DOUBLE
83038: EQUAL
83039: IFTRUE 83043
83041: GO 83143
83043: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83044: LD_ADDR_VAR 0 1
83048: PUSH
83049: LD_INT 2
83051: PUSH
83052: LD_INT 4
83054: PUSH
83055: LD_INT 5
83057: PUSH
83058: LD_INT 7
83060: PUSH
83061: LD_INT 11
83063: PUSH
83064: LD_INT 12
83066: PUSH
83067: LD_INT 15
83069: PUSH
83070: LD_INT 16
83072: PUSH
83073: LD_INT 20
83075: PUSH
83076: LD_INT 21
83078: PUSH
83079: LD_INT 22
83081: PUSH
83082: LD_INT 23
83084: PUSH
83085: LD_INT 25
83087: PUSH
83088: LD_INT 26
83090: PUSH
83091: EMPTY
83092: LIST
83093: LIST
83094: LIST
83095: LIST
83096: LIST
83097: LIST
83098: LIST
83099: LIST
83100: LIST
83101: LIST
83102: LIST
83103: LIST
83104: LIST
83105: LIST
83106: PUSH
83107: LD_INT 101
83109: PUSH
83110: LD_INT 102
83112: PUSH
83113: LD_INT 103
83115: PUSH
83116: LD_INT 105
83118: PUSH
83119: LD_INT 106
83121: PUSH
83122: LD_INT 108
83124: PUSH
83125: LD_INT 112
83127: PUSH
83128: EMPTY
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: LIST
83134: LIST
83135: LIST
83136: PUSH
83137: EMPTY
83138: LIST
83139: LIST
83140: ST_TO_ADDR
83141: GO 85400
83143: LD_INT 8
83145: DOUBLE
83146: EQUAL
83147: IFTRUE 83151
83149: GO 83279
83151: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83152: LD_ADDR_VAR 0 1
83156: PUSH
83157: LD_INT 2
83159: PUSH
83160: LD_INT 4
83162: PUSH
83163: LD_INT 5
83165: PUSH
83166: LD_INT 6
83168: PUSH
83169: LD_INT 7
83171: PUSH
83172: LD_INT 8
83174: PUSH
83175: LD_INT 11
83177: PUSH
83178: LD_INT 12
83180: PUSH
83181: LD_INT 15
83183: PUSH
83184: LD_INT 16
83186: PUSH
83187: LD_INT 20
83189: PUSH
83190: LD_INT 21
83192: PUSH
83193: LD_INT 22
83195: PUSH
83196: LD_INT 23
83198: PUSH
83199: LD_INT 25
83201: PUSH
83202: LD_INT 26
83204: PUSH
83205: LD_INT 30
83207: PUSH
83208: LD_INT 31
83210: PUSH
83211: LD_INT 32
83213: PUSH
83214: LD_INT 36
83216: PUSH
83217: EMPTY
83218: LIST
83219: LIST
83220: LIST
83221: LIST
83222: LIST
83223: LIST
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: LIST
83234: LIST
83235: LIST
83236: LIST
83237: LIST
83238: PUSH
83239: LD_INT 101
83241: PUSH
83242: LD_INT 102
83244: PUSH
83245: LD_INT 103
83247: PUSH
83248: LD_INT 105
83250: PUSH
83251: LD_INT 106
83253: PUSH
83254: LD_INT 108
83256: PUSH
83257: LD_INT 109
83259: PUSH
83260: LD_INT 112
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: LIST
83267: LIST
83268: LIST
83269: LIST
83270: LIST
83271: LIST
83272: PUSH
83273: EMPTY
83274: LIST
83275: LIST
83276: ST_TO_ADDR
83277: GO 85400
83279: LD_INT 9
83281: DOUBLE
83282: EQUAL
83283: IFTRUE 83287
83285: GO 83423
83287: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
83288: LD_ADDR_VAR 0 1
83292: PUSH
83293: LD_INT 2
83295: PUSH
83296: LD_INT 4
83298: PUSH
83299: LD_INT 5
83301: PUSH
83302: LD_INT 6
83304: PUSH
83305: LD_INT 7
83307: PUSH
83308: LD_INT 8
83310: PUSH
83311: LD_INT 11
83313: PUSH
83314: LD_INT 12
83316: PUSH
83317: LD_INT 15
83319: PUSH
83320: LD_INT 16
83322: PUSH
83323: LD_INT 20
83325: PUSH
83326: LD_INT 21
83328: PUSH
83329: LD_INT 22
83331: PUSH
83332: LD_INT 23
83334: PUSH
83335: LD_INT 25
83337: PUSH
83338: LD_INT 26
83340: PUSH
83341: LD_INT 28
83343: PUSH
83344: LD_INT 30
83346: PUSH
83347: LD_INT 31
83349: PUSH
83350: LD_INT 32
83352: PUSH
83353: LD_INT 36
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: LIST
83360: LIST
83361: LIST
83362: LIST
83363: LIST
83364: LIST
83365: LIST
83366: LIST
83367: LIST
83368: LIST
83369: LIST
83370: LIST
83371: LIST
83372: LIST
83373: LIST
83374: LIST
83375: LIST
83376: LIST
83377: LIST
83378: PUSH
83379: LD_INT 101
83381: PUSH
83382: LD_INT 102
83384: PUSH
83385: LD_INT 103
83387: PUSH
83388: LD_INT 105
83390: PUSH
83391: LD_INT 106
83393: PUSH
83394: LD_INT 108
83396: PUSH
83397: LD_INT 109
83399: PUSH
83400: LD_INT 112
83402: PUSH
83403: LD_INT 114
83405: PUSH
83406: EMPTY
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: LIST
83416: PUSH
83417: EMPTY
83418: LIST
83419: LIST
83420: ST_TO_ADDR
83421: GO 85400
83423: LD_INT 10
83425: DOUBLE
83426: EQUAL
83427: IFTRUE 83431
83429: GO 83615
83431: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
83432: LD_ADDR_VAR 0 1
83436: PUSH
83437: LD_INT 2
83439: PUSH
83440: LD_INT 4
83442: PUSH
83443: LD_INT 5
83445: PUSH
83446: LD_INT 6
83448: PUSH
83449: LD_INT 7
83451: PUSH
83452: LD_INT 8
83454: PUSH
83455: LD_INT 9
83457: PUSH
83458: LD_INT 10
83460: PUSH
83461: LD_INT 11
83463: PUSH
83464: LD_INT 12
83466: PUSH
83467: LD_INT 13
83469: PUSH
83470: LD_INT 14
83472: PUSH
83473: LD_INT 15
83475: PUSH
83476: LD_INT 16
83478: PUSH
83479: LD_INT 17
83481: PUSH
83482: LD_INT 18
83484: PUSH
83485: LD_INT 19
83487: PUSH
83488: LD_INT 20
83490: PUSH
83491: LD_INT 21
83493: PUSH
83494: LD_INT 22
83496: PUSH
83497: LD_INT 23
83499: PUSH
83500: LD_INT 24
83502: PUSH
83503: LD_INT 25
83505: PUSH
83506: LD_INT 26
83508: PUSH
83509: LD_INT 28
83511: PUSH
83512: LD_INT 30
83514: PUSH
83515: LD_INT 31
83517: PUSH
83518: LD_INT 32
83520: PUSH
83521: LD_INT 36
83523: PUSH
83524: EMPTY
83525: LIST
83526: LIST
83527: LIST
83528: LIST
83529: LIST
83530: LIST
83531: LIST
83532: LIST
83533: LIST
83534: LIST
83535: LIST
83536: LIST
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: LIST
83542: LIST
83543: LIST
83544: LIST
83545: LIST
83546: LIST
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: LIST
83553: LIST
83554: PUSH
83555: LD_INT 101
83557: PUSH
83558: LD_INT 102
83560: PUSH
83561: LD_INT 103
83563: PUSH
83564: LD_INT 104
83566: PUSH
83567: LD_INT 105
83569: PUSH
83570: LD_INT 106
83572: PUSH
83573: LD_INT 107
83575: PUSH
83576: LD_INT 108
83578: PUSH
83579: LD_INT 109
83581: PUSH
83582: LD_INT 110
83584: PUSH
83585: LD_INT 111
83587: PUSH
83588: LD_INT 112
83590: PUSH
83591: LD_INT 114
83593: PUSH
83594: EMPTY
83595: LIST
83596: LIST
83597: LIST
83598: LIST
83599: LIST
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: PUSH
83609: EMPTY
83610: LIST
83611: LIST
83612: ST_TO_ADDR
83613: GO 85400
83615: LD_INT 11
83617: DOUBLE
83618: EQUAL
83619: IFTRUE 83623
83621: GO 83815
83623: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
83624: LD_ADDR_VAR 0 1
83628: PUSH
83629: LD_INT 2
83631: PUSH
83632: LD_INT 3
83634: PUSH
83635: LD_INT 4
83637: PUSH
83638: LD_INT 5
83640: PUSH
83641: LD_INT 6
83643: PUSH
83644: LD_INT 7
83646: PUSH
83647: LD_INT 8
83649: PUSH
83650: LD_INT 9
83652: PUSH
83653: LD_INT 10
83655: PUSH
83656: LD_INT 11
83658: PUSH
83659: LD_INT 12
83661: PUSH
83662: LD_INT 13
83664: PUSH
83665: LD_INT 14
83667: PUSH
83668: LD_INT 15
83670: PUSH
83671: LD_INT 16
83673: PUSH
83674: LD_INT 17
83676: PUSH
83677: LD_INT 18
83679: PUSH
83680: LD_INT 19
83682: PUSH
83683: LD_INT 20
83685: PUSH
83686: LD_INT 21
83688: PUSH
83689: LD_INT 22
83691: PUSH
83692: LD_INT 23
83694: PUSH
83695: LD_INT 24
83697: PUSH
83698: LD_INT 25
83700: PUSH
83701: LD_INT 26
83703: PUSH
83704: LD_INT 28
83706: PUSH
83707: LD_INT 30
83709: PUSH
83710: LD_INT 31
83712: PUSH
83713: LD_INT 32
83715: PUSH
83716: LD_INT 34
83718: PUSH
83719: LD_INT 36
83721: PUSH
83722: EMPTY
83723: LIST
83724: LIST
83725: LIST
83726: LIST
83727: LIST
83728: LIST
83729: LIST
83730: LIST
83731: LIST
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: LIST
83740: LIST
83741: LIST
83742: LIST
83743: LIST
83744: LIST
83745: LIST
83746: LIST
83747: LIST
83748: LIST
83749: LIST
83750: LIST
83751: LIST
83752: LIST
83753: LIST
83754: PUSH
83755: LD_INT 101
83757: PUSH
83758: LD_INT 102
83760: PUSH
83761: LD_INT 103
83763: PUSH
83764: LD_INT 104
83766: PUSH
83767: LD_INT 105
83769: PUSH
83770: LD_INT 106
83772: PUSH
83773: LD_INT 107
83775: PUSH
83776: LD_INT 108
83778: PUSH
83779: LD_INT 109
83781: PUSH
83782: LD_INT 110
83784: PUSH
83785: LD_INT 111
83787: PUSH
83788: LD_INT 112
83790: PUSH
83791: LD_INT 114
83793: PUSH
83794: EMPTY
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: PUSH
83809: EMPTY
83810: LIST
83811: LIST
83812: ST_TO_ADDR
83813: GO 85400
83815: LD_INT 12
83817: DOUBLE
83818: EQUAL
83819: IFTRUE 83823
83821: GO 84031
83823: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
83824: LD_ADDR_VAR 0 1
83828: PUSH
83829: LD_INT 1
83831: PUSH
83832: LD_INT 2
83834: PUSH
83835: LD_INT 3
83837: PUSH
83838: LD_INT 4
83840: PUSH
83841: LD_INT 5
83843: PUSH
83844: LD_INT 6
83846: PUSH
83847: LD_INT 7
83849: PUSH
83850: LD_INT 8
83852: PUSH
83853: LD_INT 9
83855: PUSH
83856: LD_INT 10
83858: PUSH
83859: LD_INT 11
83861: PUSH
83862: LD_INT 12
83864: PUSH
83865: LD_INT 13
83867: PUSH
83868: LD_INT 14
83870: PUSH
83871: LD_INT 15
83873: PUSH
83874: LD_INT 16
83876: PUSH
83877: LD_INT 17
83879: PUSH
83880: LD_INT 18
83882: PUSH
83883: LD_INT 19
83885: PUSH
83886: LD_INT 20
83888: PUSH
83889: LD_INT 21
83891: PUSH
83892: LD_INT 22
83894: PUSH
83895: LD_INT 23
83897: PUSH
83898: LD_INT 24
83900: PUSH
83901: LD_INT 25
83903: PUSH
83904: LD_INT 26
83906: PUSH
83907: LD_INT 27
83909: PUSH
83910: LD_INT 28
83912: PUSH
83913: LD_INT 30
83915: PUSH
83916: LD_INT 31
83918: PUSH
83919: LD_INT 32
83921: PUSH
83922: LD_INT 33
83924: PUSH
83925: LD_INT 34
83927: PUSH
83928: LD_INT 36
83930: PUSH
83931: EMPTY
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: LIST
83950: LIST
83951: LIST
83952: LIST
83953: LIST
83954: LIST
83955: LIST
83956: LIST
83957: LIST
83958: LIST
83959: LIST
83960: LIST
83961: LIST
83962: LIST
83963: LIST
83964: LIST
83965: LIST
83966: PUSH
83967: LD_INT 101
83969: PUSH
83970: LD_INT 102
83972: PUSH
83973: LD_INT 103
83975: PUSH
83976: LD_INT 104
83978: PUSH
83979: LD_INT 105
83981: PUSH
83982: LD_INT 106
83984: PUSH
83985: LD_INT 107
83987: PUSH
83988: LD_INT 108
83990: PUSH
83991: LD_INT 109
83993: PUSH
83994: LD_INT 110
83996: PUSH
83997: LD_INT 111
83999: PUSH
84000: LD_INT 112
84002: PUSH
84003: LD_INT 113
84005: PUSH
84006: LD_INT 114
84008: PUSH
84009: EMPTY
84010: LIST
84011: LIST
84012: LIST
84013: LIST
84014: LIST
84015: LIST
84016: LIST
84017: LIST
84018: LIST
84019: LIST
84020: LIST
84021: LIST
84022: LIST
84023: LIST
84024: PUSH
84025: EMPTY
84026: LIST
84027: LIST
84028: ST_TO_ADDR
84029: GO 85400
84031: LD_INT 13
84033: DOUBLE
84034: EQUAL
84035: IFTRUE 84039
84037: GO 84235
84039: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84040: LD_ADDR_VAR 0 1
84044: PUSH
84045: LD_INT 1
84047: PUSH
84048: LD_INT 2
84050: PUSH
84051: LD_INT 3
84053: PUSH
84054: LD_INT 4
84056: PUSH
84057: LD_INT 5
84059: PUSH
84060: LD_INT 8
84062: PUSH
84063: LD_INT 9
84065: PUSH
84066: LD_INT 10
84068: PUSH
84069: LD_INT 11
84071: PUSH
84072: LD_INT 12
84074: PUSH
84075: LD_INT 14
84077: PUSH
84078: LD_INT 15
84080: PUSH
84081: LD_INT 16
84083: PUSH
84084: LD_INT 17
84086: PUSH
84087: LD_INT 18
84089: PUSH
84090: LD_INT 19
84092: PUSH
84093: LD_INT 20
84095: PUSH
84096: LD_INT 21
84098: PUSH
84099: LD_INT 22
84101: PUSH
84102: LD_INT 23
84104: PUSH
84105: LD_INT 24
84107: PUSH
84108: LD_INT 25
84110: PUSH
84111: LD_INT 26
84113: PUSH
84114: LD_INT 27
84116: PUSH
84117: LD_INT 28
84119: PUSH
84120: LD_INT 30
84122: PUSH
84123: LD_INT 31
84125: PUSH
84126: LD_INT 32
84128: PUSH
84129: LD_INT 33
84131: PUSH
84132: LD_INT 34
84134: PUSH
84135: LD_INT 36
84137: PUSH
84138: EMPTY
84139: LIST
84140: LIST
84141: LIST
84142: LIST
84143: LIST
84144: LIST
84145: LIST
84146: LIST
84147: LIST
84148: LIST
84149: LIST
84150: LIST
84151: LIST
84152: LIST
84153: LIST
84154: LIST
84155: LIST
84156: LIST
84157: LIST
84158: LIST
84159: LIST
84160: LIST
84161: LIST
84162: LIST
84163: LIST
84164: LIST
84165: LIST
84166: LIST
84167: LIST
84168: LIST
84169: LIST
84170: PUSH
84171: LD_INT 101
84173: PUSH
84174: LD_INT 102
84176: PUSH
84177: LD_INT 103
84179: PUSH
84180: LD_INT 104
84182: PUSH
84183: LD_INT 105
84185: PUSH
84186: LD_INT 106
84188: PUSH
84189: LD_INT 107
84191: PUSH
84192: LD_INT 108
84194: PUSH
84195: LD_INT 109
84197: PUSH
84198: LD_INT 110
84200: PUSH
84201: LD_INT 111
84203: PUSH
84204: LD_INT 112
84206: PUSH
84207: LD_INT 113
84209: PUSH
84210: LD_INT 114
84212: PUSH
84213: EMPTY
84214: LIST
84215: LIST
84216: LIST
84217: LIST
84218: LIST
84219: LIST
84220: LIST
84221: LIST
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: LIST
84228: PUSH
84229: EMPTY
84230: LIST
84231: LIST
84232: ST_TO_ADDR
84233: GO 85400
84235: LD_INT 14
84237: DOUBLE
84238: EQUAL
84239: IFTRUE 84243
84241: GO 84455
84243: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
84244: LD_ADDR_VAR 0 1
84248: PUSH
84249: LD_INT 1
84251: PUSH
84252: LD_INT 2
84254: PUSH
84255: LD_INT 3
84257: PUSH
84258: LD_INT 4
84260: PUSH
84261: LD_INT 5
84263: PUSH
84264: LD_INT 6
84266: PUSH
84267: LD_INT 7
84269: PUSH
84270: LD_INT 8
84272: PUSH
84273: LD_INT 9
84275: PUSH
84276: LD_INT 10
84278: PUSH
84279: LD_INT 11
84281: PUSH
84282: LD_INT 12
84284: PUSH
84285: LD_INT 13
84287: PUSH
84288: LD_INT 14
84290: PUSH
84291: LD_INT 15
84293: PUSH
84294: LD_INT 16
84296: PUSH
84297: LD_INT 17
84299: PUSH
84300: LD_INT 18
84302: PUSH
84303: LD_INT 19
84305: PUSH
84306: LD_INT 20
84308: PUSH
84309: LD_INT 21
84311: PUSH
84312: LD_INT 22
84314: PUSH
84315: LD_INT 23
84317: PUSH
84318: LD_INT 24
84320: PUSH
84321: LD_INT 25
84323: PUSH
84324: LD_INT 26
84326: PUSH
84327: LD_INT 27
84329: PUSH
84330: LD_INT 28
84332: PUSH
84333: LD_INT 29
84335: PUSH
84336: LD_INT 30
84338: PUSH
84339: LD_INT 31
84341: PUSH
84342: LD_INT 32
84344: PUSH
84345: LD_INT 33
84347: PUSH
84348: LD_INT 34
84350: PUSH
84351: LD_INT 36
84353: PUSH
84354: EMPTY
84355: LIST
84356: LIST
84357: LIST
84358: LIST
84359: LIST
84360: LIST
84361: LIST
84362: LIST
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: LIST
84369: LIST
84370: LIST
84371: LIST
84372: LIST
84373: LIST
84374: LIST
84375: LIST
84376: LIST
84377: LIST
84378: LIST
84379: LIST
84380: LIST
84381: LIST
84382: LIST
84383: LIST
84384: LIST
84385: LIST
84386: LIST
84387: LIST
84388: LIST
84389: LIST
84390: PUSH
84391: LD_INT 101
84393: PUSH
84394: LD_INT 102
84396: PUSH
84397: LD_INT 103
84399: PUSH
84400: LD_INT 104
84402: PUSH
84403: LD_INT 105
84405: PUSH
84406: LD_INT 106
84408: PUSH
84409: LD_INT 107
84411: PUSH
84412: LD_INT 108
84414: PUSH
84415: LD_INT 109
84417: PUSH
84418: LD_INT 110
84420: PUSH
84421: LD_INT 111
84423: PUSH
84424: LD_INT 112
84426: PUSH
84427: LD_INT 113
84429: PUSH
84430: LD_INT 114
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: PUSH
84449: EMPTY
84450: LIST
84451: LIST
84452: ST_TO_ADDR
84453: GO 85400
84455: LD_INT 15
84457: DOUBLE
84458: EQUAL
84459: IFTRUE 84463
84461: GO 84675
84463: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
84464: LD_ADDR_VAR 0 1
84468: PUSH
84469: LD_INT 1
84471: PUSH
84472: LD_INT 2
84474: PUSH
84475: LD_INT 3
84477: PUSH
84478: LD_INT 4
84480: PUSH
84481: LD_INT 5
84483: PUSH
84484: LD_INT 6
84486: PUSH
84487: LD_INT 7
84489: PUSH
84490: LD_INT 8
84492: PUSH
84493: LD_INT 9
84495: PUSH
84496: LD_INT 10
84498: PUSH
84499: LD_INT 11
84501: PUSH
84502: LD_INT 12
84504: PUSH
84505: LD_INT 13
84507: PUSH
84508: LD_INT 14
84510: PUSH
84511: LD_INT 15
84513: PUSH
84514: LD_INT 16
84516: PUSH
84517: LD_INT 17
84519: PUSH
84520: LD_INT 18
84522: PUSH
84523: LD_INT 19
84525: PUSH
84526: LD_INT 20
84528: PUSH
84529: LD_INT 21
84531: PUSH
84532: LD_INT 22
84534: PUSH
84535: LD_INT 23
84537: PUSH
84538: LD_INT 24
84540: PUSH
84541: LD_INT 25
84543: PUSH
84544: LD_INT 26
84546: PUSH
84547: LD_INT 27
84549: PUSH
84550: LD_INT 28
84552: PUSH
84553: LD_INT 29
84555: PUSH
84556: LD_INT 30
84558: PUSH
84559: LD_INT 31
84561: PUSH
84562: LD_INT 32
84564: PUSH
84565: LD_INT 33
84567: PUSH
84568: LD_INT 34
84570: PUSH
84571: LD_INT 36
84573: PUSH
84574: EMPTY
84575: LIST
84576: LIST
84577: LIST
84578: LIST
84579: LIST
84580: LIST
84581: LIST
84582: LIST
84583: LIST
84584: LIST
84585: LIST
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: LIST
84592: LIST
84593: LIST
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: LIST
84599: LIST
84600: LIST
84601: LIST
84602: LIST
84603: LIST
84604: LIST
84605: LIST
84606: LIST
84607: LIST
84608: LIST
84609: LIST
84610: PUSH
84611: LD_INT 101
84613: PUSH
84614: LD_INT 102
84616: PUSH
84617: LD_INT 103
84619: PUSH
84620: LD_INT 104
84622: PUSH
84623: LD_INT 105
84625: PUSH
84626: LD_INT 106
84628: PUSH
84629: LD_INT 107
84631: PUSH
84632: LD_INT 108
84634: PUSH
84635: LD_INT 109
84637: PUSH
84638: LD_INT 110
84640: PUSH
84641: LD_INT 111
84643: PUSH
84644: LD_INT 112
84646: PUSH
84647: LD_INT 113
84649: PUSH
84650: LD_INT 114
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: PUSH
84669: EMPTY
84670: LIST
84671: LIST
84672: ST_TO_ADDR
84673: GO 85400
84675: LD_INT 16
84677: DOUBLE
84678: EQUAL
84679: IFTRUE 84683
84681: GO 84807
84683: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
84684: LD_ADDR_VAR 0 1
84688: PUSH
84689: LD_INT 2
84691: PUSH
84692: LD_INT 4
84694: PUSH
84695: LD_INT 5
84697: PUSH
84698: LD_INT 7
84700: PUSH
84701: LD_INT 11
84703: PUSH
84704: LD_INT 12
84706: PUSH
84707: LD_INT 15
84709: PUSH
84710: LD_INT 16
84712: PUSH
84713: LD_INT 20
84715: PUSH
84716: LD_INT 21
84718: PUSH
84719: LD_INT 22
84721: PUSH
84722: LD_INT 23
84724: PUSH
84725: LD_INT 25
84727: PUSH
84728: LD_INT 26
84730: PUSH
84731: LD_INT 30
84733: PUSH
84734: LD_INT 31
84736: PUSH
84737: LD_INT 32
84739: PUSH
84740: LD_INT 33
84742: PUSH
84743: LD_INT 34
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: LIST
84750: LIST
84751: LIST
84752: LIST
84753: LIST
84754: LIST
84755: LIST
84756: LIST
84757: LIST
84758: LIST
84759: LIST
84760: LIST
84761: LIST
84762: LIST
84763: LIST
84764: LIST
84765: LIST
84766: PUSH
84767: LD_INT 101
84769: PUSH
84770: LD_INT 102
84772: PUSH
84773: LD_INT 103
84775: PUSH
84776: LD_INT 106
84778: PUSH
84779: LD_INT 108
84781: PUSH
84782: LD_INT 112
84784: PUSH
84785: LD_INT 113
84787: PUSH
84788: LD_INT 114
84790: PUSH
84791: EMPTY
84792: LIST
84793: LIST
84794: LIST
84795: LIST
84796: LIST
84797: LIST
84798: LIST
84799: LIST
84800: PUSH
84801: EMPTY
84802: LIST
84803: LIST
84804: ST_TO_ADDR
84805: GO 85400
84807: LD_INT 17
84809: DOUBLE
84810: EQUAL
84811: IFTRUE 84815
84813: GO 85027
84815: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
84816: LD_ADDR_VAR 0 1
84820: PUSH
84821: LD_INT 1
84823: PUSH
84824: LD_INT 2
84826: PUSH
84827: LD_INT 3
84829: PUSH
84830: LD_INT 4
84832: PUSH
84833: LD_INT 5
84835: PUSH
84836: LD_INT 6
84838: PUSH
84839: LD_INT 7
84841: PUSH
84842: LD_INT 8
84844: PUSH
84845: LD_INT 9
84847: PUSH
84848: LD_INT 10
84850: PUSH
84851: LD_INT 11
84853: PUSH
84854: LD_INT 12
84856: PUSH
84857: LD_INT 13
84859: PUSH
84860: LD_INT 14
84862: PUSH
84863: LD_INT 15
84865: PUSH
84866: LD_INT 16
84868: PUSH
84869: LD_INT 17
84871: PUSH
84872: LD_INT 18
84874: PUSH
84875: LD_INT 19
84877: PUSH
84878: LD_INT 20
84880: PUSH
84881: LD_INT 21
84883: PUSH
84884: LD_INT 22
84886: PUSH
84887: LD_INT 23
84889: PUSH
84890: LD_INT 24
84892: PUSH
84893: LD_INT 25
84895: PUSH
84896: LD_INT 26
84898: PUSH
84899: LD_INT 27
84901: PUSH
84902: LD_INT 28
84904: PUSH
84905: LD_INT 29
84907: PUSH
84908: LD_INT 30
84910: PUSH
84911: LD_INT 31
84913: PUSH
84914: LD_INT 32
84916: PUSH
84917: LD_INT 33
84919: PUSH
84920: LD_INT 34
84922: PUSH
84923: LD_INT 36
84925: PUSH
84926: EMPTY
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: LIST
84943: LIST
84944: LIST
84945: LIST
84946: LIST
84947: LIST
84948: LIST
84949: LIST
84950: LIST
84951: LIST
84952: LIST
84953: LIST
84954: LIST
84955: LIST
84956: LIST
84957: LIST
84958: LIST
84959: LIST
84960: LIST
84961: LIST
84962: PUSH
84963: LD_INT 101
84965: PUSH
84966: LD_INT 102
84968: PUSH
84969: LD_INT 103
84971: PUSH
84972: LD_INT 104
84974: PUSH
84975: LD_INT 105
84977: PUSH
84978: LD_INT 106
84980: PUSH
84981: LD_INT 107
84983: PUSH
84984: LD_INT 108
84986: PUSH
84987: LD_INT 109
84989: PUSH
84990: LD_INT 110
84992: PUSH
84993: LD_INT 111
84995: PUSH
84996: LD_INT 112
84998: PUSH
84999: LD_INT 113
85001: PUSH
85002: LD_INT 114
85004: PUSH
85005: EMPTY
85006: LIST
85007: LIST
85008: LIST
85009: LIST
85010: LIST
85011: LIST
85012: LIST
85013: LIST
85014: LIST
85015: LIST
85016: LIST
85017: LIST
85018: LIST
85019: LIST
85020: PUSH
85021: EMPTY
85022: LIST
85023: LIST
85024: ST_TO_ADDR
85025: GO 85400
85027: LD_INT 18
85029: DOUBLE
85030: EQUAL
85031: IFTRUE 85035
85033: GO 85171
85035: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85036: LD_ADDR_VAR 0 1
85040: PUSH
85041: LD_INT 2
85043: PUSH
85044: LD_INT 4
85046: PUSH
85047: LD_INT 5
85049: PUSH
85050: LD_INT 7
85052: PUSH
85053: LD_INT 11
85055: PUSH
85056: LD_INT 12
85058: PUSH
85059: LD_INT 15
85061: PUSH
85062: LD_INT 16
85064: PUSH
85065: LD_INT 20
85067: PUSH
85068: LD_INT 21
85070: PUSH
85071: LD_INT 22
85073: PUSH
85074: LD_INT 23
85076: PUSH
85077: LD_INT 25
85079: PUSH
85080: LD_INT 26
85082: PUSH
85083: LD_INT 30
85085: PUSH
85086: LD_INT 31
85088: PUSH
85089: LD_INT 32
85091: PUSH
85092: LD_INT 33
85094: PUSH
85095: LD_INT 34
85097: PUSH
85098: LD_INT 35
85100: PUSH
85101: LD_INT 36
85103: PUSH
85104: EMPTY
85105: LIST
85106: LIST
85107: LIST
85108: LIST
85109: LIST
85110: LIST
85111: LIST
85112: LIST
85113: LIST
85114: LIST
85115: LIST
85116: LIST
85117: LIST
85118: LIST
85119: LIST
85120: LIST
85121: LIST
85122: LIST
85123: LIST
85124: LIST
85125: LIST
85126: PUSH
85127: LD_INT 101
85129: PUSH
85130: LD_INT 102
85132: PUSH
85133: LD_INT 103
85135: PUSH
85136: LD_INT 106
85138: PUSH
85139: LD_INT 108
85141: PUSH
85142: LD_INT 112
85144: PUSH
85145: LD_INT 113
85147: PUSH
85148: LD_INT 114
85150: PUSH
85151: LD_INT 115
85153: PUSH
85154: EMPTY
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: LIST
85160: LIST
85161: LIST
85162: LIST
85163: LIST
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: ST_TO_ADDR
85169: GO 85400
85171: LD_INT 19
85173: DOUBLE
85174: EQUAL
85175: IFTRUE 85179
85177: GO 85399
85179: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85180: LD_ADDR_VAR 0 1
85184: PUSH
85185: LD_INT 1
85187: PUSH
85188: LD_INT 2
85190: PUSH
85191: LD_INT 3
85193: PUSH
85194: LD_INT 4
85196: PUSH
85197: LD_INT 5
85199: PUSH
85200: LD_INT 6
85202: PUSH
85203: LD_INT 7
85205: PUSH
85206: LD_INT 8
85208: PUSH
85209: LD_INT 9
85211: PUSH
85212: LD_INT 10
85214: PUSH
85215: LD_INT 11
85217: PUSH
85218: LD_INT 12
85220: PUSH
85221: LD_INT 13
85223: PUSH
85224: LD_INT 14
85226: PUSH
85227: LD_INT 15
85229: PUSH
85230: LD_INT 16
85232: PUSH
85233: LD_INT 17
85235: PUSH
85236: LD_INT 18
85238: PUSH
85239: LD_INT 19
85241: PUSH
85242: LD_INT 20
85244: PUSH
85245: LD_INT 21
85247: PUSH
85248: LD_INT 22
85250: PUSH
85251: LD_INT 23
85253: PUSH
85254: LD_INT 24
85256: PUSH
85257: LD_INT 25
85259: PUSH
85260: LD_INT 26
85262: PUSH
85263: LD_INT 27
85265: PUSH
85266: LD_INT 28
85268: PUSH
85269: LD_INT 29
85271: PUSH
85272: LD_INT 30
85274: PUSH
85275: LD_INT 31
85277: PUSH
85278: LD_INT 32
85280: PUSH
85281: LD_INT 33
85283: PUSH
85284: LD_INT 34
85286: PUSH
85287: LD_INT 35
85289: PUSH
85290: LD_INT 36
85292: PUSH
85293: EMPTY
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: LIST
85326: LIST
85327: LIST
85328: LIST
85329: LIST
85330: PUSH
85331: LD_INT 101
85333: PUSH
85334: LD_INT 102
85336: PUSH
85337: LD_INT 103
85339: PUSH
85340: LD_INT 104
85342: PUSH
85343: LD_INT 105
85345: PUSH
85346: LD_INT 106
85348: PUSH
85349: LD_INT 107
85351: PUSH
85352: LD_INT 108
85354: PUSH
85355: LD_INT 109
85357: PUSH
85358: LD_INT 110
85360: PUSH
85361: LD_INT 111
85363: PUSH
85364: LD_INT 112
85366: PUSH
85367: LD_INT 113
85369: PUSH
85370: LD_INT 114
85372: PUSH
85373: LD_INT 115
85375: PUSH
85376: EMPTY
85377: LIST
85378: LIST
85379: LIST
85380: LIST
85381: LIST
85382: LIST
85383: LIST
85384: LIST
85385: LIST
85386: LIST
85387: LIST
85388: LIST
85389: LIST
85390: LIST
85391: LIST
85392: PUSH
85393: EMPTY
85394: LIST
85395: LIST
85396: ST_TO_ADDR
85397: GO 85400
85399: POP
// end else
85400: GO 85619
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
85402: LD_ADDR_VAR 0 1
85406: PUSH
85407: LD_INT 1
85409: PUSH
85410: LD_INT 2
85412: PUSH
85413: LD_INT 3
85415: PUSH
85416: LD_INT 4
85418: PUSH
85419: LD_INT 5
85421: PUSH
85422: LD_INT 6
85424: PUSH
85425: LD_INT 7
85427: PUSH
85428: LD_INT 8
85430: PUSH
85431: LD_INT 9
85433: PUSH
85434: LD_INT 10
85436: PUSH
85437: LD_INT 11
85439: PUSH
85440: LD_INT 12
85442: PUSH
85443: LD_INT 13
85445: PUSH
85446: LD_INT 14
85448: PUSH
85449: LD_INT 15
85451: PUSH
85452: LD_INT 16
85454: PUSH
85455: LD_INT 17
85457: PUSH
85458: LD_INT 18
85460: PUSH
85461: LD_INT 19
85463: PUSH
85464: LD_INT 20
85466: PUSH
85467: LD_INT 21
85469: PUSH
85470: LD_INT 22
85472: PUSH
85473: LD_INT 23
85475: PUSH
85476: LD_INT 24
85478: PUSH
85479: LD_INT 25
85481: PUSH
85482: LD_INT 26
85484: PUSH
85485: LD_INT 27
85487: PUSH
85488: LD_INT 28
85490: PUSH
85491: LD_INT 29
85493: PUSH
85494: LD_INT 30
85496: PUSH
85497: LD_INT 31
85499: PUSH
85500: LD_INT 32
85502: PUSH
85503: LD_INT 33
85505: PUSH
85506: LD_INT 34
85508: PUSH
85509: LD_INT 35
85511: PUSH
85512: LD_INT 36
85514: PUSH
85515: EMPTY
85516: LIST
85517: LIST
85518: LIST
85519: LIST
85520: LIST
85521: LIST
85522: LIST
85523: LIST
85524: LIST
85525: LIST
85526: LIST
85527: LIST
85528: LIST
85529: LIST
85530: LIST
85531: LIST
85532: LIST
85533: LIST
85534: LIST
85535: LIST
85536: LIST
85537: LIST
85538: LIST
85539: LIST
85540: LIST
85541: LIST
85542: LIST
85543: LIST
85544: LIST
85545: LIST
85546: LIST
85547: LIST
85548: LIST
85549: LIST
85550: LIST
85551: LIST
85552: PUSH
85553: LD_INT 101
85555: PUSH
85556: LD_INT 102
85558: PUSH
85559: LD_INT 103
85561: PUSH
85562: LD_INT 104
85564: PUSH
85565: LD_INT 105
85567: PUSH
85568: LD_INT 106
85570: PUSH
85571: LD_INT 107
85573: PUSH
85574: LD_INT 108
85576: PUSH
85577: LD_INT 109
85579: PUSH
85580: LD_INT 110
85582: PUSH
85583: LD_INT 111
85585: PUSH
85586: LD_INT 112
85588: PUSH
85589: LD_INT 113
85591: PUSH
85592: LD_INT 114
85594: PUSH
85595: LD_INT 115
85597: PUSH
85598: EMPTY
85599: LIST
85600: LIST
85601: LIST
85602: LIST
85603: LIST
85604: LIST
85605: LIST
85606: LIST
85607: LIST
85608: LIST
85609: LIST
85610: LIST
85611: LIST
85612: LIST
85613: LIST
85614: PUSH
85615: EMPTY
85616: LIST
85617: LIST
85618: ST_TO_ADDR
// if result then
85619: LD_VAR 0 1
85623: IFFALSE 85912
// begin normal :=  ;
85625: LD_ADDR_VAR 0 3
85629: PUSH
85630: LD_STRING 
85632: ST_TO_ADDR
// hardcore :=  ;
85633: LD_ADDR_VAR 0 4
85637: PUSH
85638: LD_STRING 
85640: ST_TO_ADDR
// for i = 1 to normalCounter do
85641: LD_ADDR_VAR 0 5
85645: PUSH
85646: DOUBLE
85647: LD_INT 1
85649: DEC
85650: ST_TO_ADDR
85651: LD_EXP 118
85655: PUSH
85656: FOR_TO
85657: IFFALSE 85758
// begin tmp := 0 ;
85659: LD_ADDR_VAR 0 2
85663: PUSH
85664: LD_STRING 0
85666: ST_TO_ADDR
// if result [ 1 ] then
85667: LD_VAR 0 1
85671: PUSH
85672: LD_INT 1
85674: ARRAY
85675: IFFALSE 85740
// if result [ 1 ] [ 1 ] = i then
85677: LD_VAR 0 1
85681: PUSH
85682: LD_INT 1
85684: ARRAY
85685: PUSH
85686: LD_INT 1
85688: ARRAY
85689: PUSH
85690: LD_VAR 0 5
85694: EQUAL
85695: IFFALSE 85740
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
85697: LD_ADDR_VAR 0 1
85701: PUSH
85702: LD_VAR 0 1
85706: PPUSH
85707: LD_INT 1
85709: PPUSH
85710: LD_VAR 0 1
85714: PUSH
85715: LD_INT 1
85717: ARRAY
85718: PPUSH
85719: LD_INT 1
85721: PPUSH
85722: CALL_OW 3
85726: PPUSH
85727: CALL_OW 1
85731: ST_TO_ADDR
// tmp := 1 ;
85732: LD_ADDR_VAR 0 2
85736: PUSH
85737: LD_STRING 1
85739: ST_TO_ADDR
// end ; normal := normal & tmp ;
85740: LD_ADDR_VAR 0 3
85744: PUSH
85745: LD_VAR 0 3
85749: PUSH
85750: LD_VAR 0 2
85754: STR
85755: ST_TO_ADDR
// end ;
85756: GO 85656
85758: POP
85759: POP
// for i = 1 to hardcoreCounter do
85760: LD_ADDR_VAR 0 5
85764: PUSH
85765: DOUBLE
85766: LD_INT 1
85768: DEC
85769: ST_TO_ADDR
85770: LD_EXP 119
85774: PUSH
85775: FOR_TO
85776: IFFALSE 85881
// begin tmp := 0 ;
85778: LD_ADDR_VAR 0 2
85782: PUSH
85783: LD_STRING 0
85785: ST_TO_ADDR
// if result [ 2 ] then
85786: LD_VAR 0 1
85790: PUSH
85791: LD_INT 2
85793: ARRAY
85794: IFFALSE 85863
// if result [ 2 ] [ 1 ] = 100 + i then
85796: LD_VAR 0 1
85800: PUSH
85801: LD_INT 2
85803: ARRAY
85804: PUSH
85805: LD_INT 1
85807: ARRAY
85808: PUSH
85809: LD_INT 100
85811: PUSH
85812: LD_VAR 0 5
85816: PLUS
85817: EQUAL
85818: IFFALSE 85863
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
85820: LD_ADDR_VAR 0 1
85824: PUSH
85825: LD_VAR 0 1
85829: PPUSH
85830: LD_INT 2
85832: PPUSH
85833: LD_VAR 0 1
85837: PUSH
85838: LD_INT 2
85840: ARRAY
85841: PPUSH
85842: LD_INT 1
85844: PPUSH
85845: CALL_OW 3
85849: PPUSH
85850: CALL_OW 1
85854: ST_TO_ADDR
// tmp := 1 ;
85855: LD_ADDR_VAR 0 2
85859: PUSH
85860: LD_STRING 1
85862: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
85863: LD_ADDR_VAR 0 4
85867: PUSH
85868: LD_VAR 0 4
85872: PUSH
85873: LD_VAR 0 2
85877: STR
85878: ST_TO_ADDR
// end ;
85879: GO 85775
85881: POP
85882: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
85883: LD_STRING getStreamItemsFromMission("
85885: PUSH
85886: LD_VAR 0 3
85890: STR
85891: PUSH
85892: LD_STRING ","
85894: STR
85895: PUSH
85896: LD_VAR 0 4
85900: STR
85901: PUSH
85902: LD_STRING ")
85904: STR
85905: PPUSH
85906: CALL_OW 559
// end else
85910: GO 85919
// ToLua ( getStreamItemsFromMission("","") ) ;
85912: LD_STRING getStreamItemsFromMission("","")
85914: PPUSH
85915: CALL_OW 559
// end ;
85919: LD_VAR 0 1
85923: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
85924: LD_EXP 117
85928: PUSH
85929: LD_EXP 122
85933: AND
85934: IFFALSE 86058
85936: GO 85938
85938: DISABLE
85939: LD_INT 0
85941: PPUSH
85942: PPUSH
// begin enable ;
85943: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
85944: LD_ADDR_VAR 0 2
85948: PUSH
85949: LD_INT 22
85951: PUSH
85952: LD_OWVAR 2
85956: PUSH
85957: EMPTY
85958: LIST
85959: LIST
85960: PUSH
85961: LD_INT 2
85963: PUSH
85964: LD_INT 34
85966: PUSH
85967: LD_INT 7
85969: PUSH
85970: EMPTY
85971: LIST
85972: LIST
85973: PUSH
85974: LD_INT 34
85976: PUSH
85977: LD_INT 45
85979: PUSH
85980: EMPTY
85981: LIST
85982: LIST
85983: PUSH
85984: LD_INT 34
85986: PUSH
85987: LD_INT 28
85989: PUSH
85990: EMPTY
85991: LIST
85992: LIST
85993: PUSH
85994: LD_INT 34
85996: PUSH
85997: LD_INT 47
85999: PUSH
86000: EMPTY
86001: LIST
86002: LIST
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PPUSH
86015: CALL_OW 69
86019: ST_TO_ADDR
// if not tmp then
86020: LD_VAR 0 2
86024: NOT
86025: IFFALSE 86029
// exit ;
86027: GO 86058
// for i in tmp do
86029: LD_ADDR_VAR 0 1
86033: PUSH
86034: LD_VAR 0 2
86038: PUSH
86039: FOR_IN
86040: IFFALSE 86056
// begin SetLives ( i , 0 ) ;
86042: LD_VAR 0 1
86046: PPUSH
86047: LD_INT 0
86049: PPUSH
86050: CALL_OW 234
// end ;
86054: GO 86039
86056: POP
86057: POP
// end ;
86058: PPOPN 2
86060: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86061: LD_EXP 117
86065: PUSH
86066: LD_EXP 123
86070: AND
86071: IFFALSE 86155
86073: GO 86075
86075: DISABLE
86076: LD_INT 0
86078: PPUSH
86079: PPUSH
// begin enable ;
86080: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86081: LD_ADDR_VAR 0 2
86085: PUSH
86086: LD_INT 22
86088: PUSH
86089: LD_OWVAR 2
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: PUSH
86098: LD_INT 32
86100: PUSH
86101: LD_INT 3
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: PUSH
86108: EMPTY
86109: LIST
86110: LIST
86111: PPUSH
86112: CALL_OW 69
86116: ST_TO_ADDR
// if not tmp then
86117: LD_VAR 0 2
86121: NOT
86122: IFFALSE 86126
// exit ;
86124: GO 86155
// for i in tmp do
86126: LD_ADDR_VAR 0 1
86130: PUSH
86131: LD_VAR 0 2
86135: PUSH
86136: FOR_IN
86137: IFFALSE 86153
// begin SetLives ( i , 0 ) ;
86139: LD_VAR 0 1
86143: PPUSH
86144: LD_INT 0
86146: PPUSH
86147: CALL_OW 234
// end ;
86151: GO 86136
86153: POP
86154: POP
// end ;
86155: PPOPN 2
86157: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86158: LD_EXP 117
86162: PUSH
86163: LD_EXP 120
86167: AND
86168: IFFALSE 86261
86170: GO 86172
86172: DISABLE
86173: LD_INT 0
86175: PPUSH
// begin enable ;
86176: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86177: LD_ADDR_VAR 0 1
86181: PUSH
86182: LD_INT 22
86184: PUSH
86185: LD_OWVAR 2
86189: PUSH
86190: EMPTY
86191: LIST
86192: LIST
86193: PUSH
86194: LD_INT 2
86196: PUSH
86197: LD_INT 25
86199: PUSH
86200: LD_INT 5
86202: PUSH
86203: EMPTY
86204: LIST
86205: LIST
86206: PUSH
86207: LD_INT 25
86209: PUSH
86210: LD_INT 9
86212: PUSH
86213: EMPTY
86214: LIST
86215: LIST
86216: PUSH
86217: LD_INT 25
86219: PUSH
86220: LD_INT 8
86222: PUSH
86223: EMPTY
86224: LIST
86225: LIST
86226: PUSH
86227: EMPTY
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: PUSH
86233: EMPTY
86234: LIST
86235: LIST
86236: PPUSH
86237: CALL_OW 69
86241: PUSH
86242: FOR_IN
86243: IFFALSE 86259
// begin SetClass ( i , 1 ) ;
86245: LD_VAR 0 1
86249: PPUSH
86250: LD_INT 1
86252: PPUSH
86253: CALL_OW 336
// end ;
86257: GO 86242
86259: POP
86260: POP
// end ;
86261: PPOPN 1
86263: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
86264: LD_EXP 117
86268: PUSH
86269: LD_EXP 121
86273: AND
86274: PUSH
86275: LD_OWVAR 65
86279: PUSH
86280: LD_INT 7
86282: LESS
86283: AND
86284: IFFALSE 86298
86286: GO 86288
86288: DISABLE
// begin enable ;
86289: ENABLE
// game_speed := 7 ;
86290: LD_ADDR_OWVAR 65
86294: PUSH
86295: LD_INT 7
86297: ST_TO_ADDR
// end ;
86298: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
86299: LD_EXP 117
86303: PUSH
86304: LD_EXP 124
86308: AND
86309: IFFALSE 86511
86311: GO 86313
86313: DISABLE
86314: LD_INT 0
86316: PPUSH
86317: PPUSH
86318: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
86319: LD_ADDR_VAR 0 3
86323: PUSH
86324: LD_INT 81
86326: PUSH
86327: LD_OWVAR 2
86331: PUSH
86332: EMPTY
86333: LIST
86334: LIST
86335: PUSH
86336: LD_INT 21
86338: PUSH
86339: LD_INT 1
86341: PUSH
86342: EMPTY
86343: LIST
86344: LIST
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PPUSH
86350: CALL_OW 69
86354: ST_TO_ADDR
// if not tmp then
86355: LD_VAR 0 3
86359: NOT
86360: IFFALSE 86364
// exit ;
86362: GO 86511
// if tmp > 5 then
86364: LD_VAR 0 3
86368: PUSH
86369: LD_INT 5
86371: GREATER
86372: IFFALSE 86384
// k := 5 else
86374: LD_ADDR_VAR 0 2
86378: PUSH
86379: LD_INT 5
86381: ST_TO_ADDR
86382: GO 86394
// k := tmp ;
86384: LD_ADDR_VAR 0 2
86388: PUSH
86389: LD_VAR 0 3
86393: ST_TO_ADDR
// for i := 1 to k do
86394: LD_ADDR_VAR 0 1
86398: PUSH
86399: DOUBLE
86400: LD_INT 1
86402: DEC
86403: ST_TO_ADDR
86404: LD_VAR 0 2
86408: PUSH
86409: FOR_TO
86410: IFFALSE 86509
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
86412: LD_VAR 0 3
86416: PUSH
86417: LD_VAR 0 1
86421: ARRAY
86422: PPUSH
86423: LD_VAR 0 1
86427: PUSH
86428: LD_INT 4
86430: MOD
86431: PUSH
86432: LD_INT 1
86434: PLUS
86435: PPUSH
86436: CALL_OW 259
86440: PUSH
86441: LD_INT 10
86443: LESS
86444: IFFALSE 86507
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
86446: LD_VAR 0 3
86450: PUSH
86451: LD_VAR 0 1
86455: ARRAY
86456: PPUSH
86457: LD_VAR 0 1
86461: PUSH
86462: LD_INT 4
86464: MOD
86465: PUSH
86466: LD_INT 1
86468: PLUS
86469: PPUSH
86470: LD_VAR 0 3
86474: PUSH
86475: LD_VAR 0 1
86479: ARRAY
86480: PPUSH
86481: LD_VAR 0 1
86485: PUSH
86486: LD_INT 4
86488: MOD
86489: PUSH
86490: LD_INT 1
86492: PLUS
86493: PPUSH
86494: CALL_OW 259
86498: PUSH
86499: LD_INT 1
86501: PLUS
86502: PPUSH
86503: CALL_OW 237
86507: GO 86409
86509: POP
86510: POP
// end ;
86511: PPOPN 3
86513: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
86514: LD_EXP 117
86518: PUSH
86519: LD_EXP 125
86523: AND
86524: IFFALSE 86544
86526: GO 86528
86528: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
86529: LD_INT 4
86531: PPUSH
86532: LD_OWVAR 2
86536: PPUSH
86537: LD_INT 0
86539: PPUSH
86540: CALL_OW 324
86544: END
// every 0 0$1 trigger StreamModeActive and sShovel do
86545: LD_EXP 117
86549: PUSH
86550: LD_EXP 154
86554: AND
86555: IFFALSE 86575
86557: GO 86559
86559: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
86560: LD_INT 19
86562: PPUSH
86563: LD_OWVAR 2
86567: PPUSH
86568: LD_INT 0
86570: PPUSH
86571: CALL_OW 324
86575: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
86576: LD_EXP 117
86580: PUSH
86581: LD_EXP 126
86585: AND
86586: IFFALSE 86688
86588: GO 86590
86590: DISABLE
86591: LD_INT 0
86593: PPUSH
86594: PPUSH
// begin enable ;
86595: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
86596: LD_ADDR_VAR 0 2
86600: PUSH
86601: LD_INT 22
86603: PUSH
86604: LD_OWVAR 2
86608: PUSH
86609: EMPTY
86610: LIST
86611: LIST
86612: PUSH
86613: LD_INT 2
86615: PUSH
86616: LD_INT 34
86618: PUSH
86619: LD_INT 11
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: PUSH
86626: LD_INT 34
86628: PUSH
86629: LD_INT 30
86631: PUSH
86632: EMPTY
86633: LIST
86634: LIST
86635: PUSH
86636: EMPTY
86637: LIST
86638: LIST
86639: LIST
86640: PUSH
86641: EMPTY
86642: LIST
86643: LIST
86644: PPUSH
86645: CALL_OW 69
86649: ST_TO_ADDR
// if not tmp then
86650: LD_VAR 0 2
86654: NOT
86655: IFFALSE 86659
// exit ;
86657: GO 86688
// for i in tmp do
86659: LD_ADDR_VAR 0 1
86663: PUSH
86664: LD_VAR 0 2
86668: PUSH
86669: FOR_IN
86670: IFFALSE 86686
// begin SetLives ( i , 0 ) ;
86672: LD_VAR 0 1
86676: PPUSH
86677: LD_INT 0
86679: PPUSH
86680: CALL_OW 234
// end ;
86684: GO 86669
86686: POP
86687: POP
// end ;
86688: PPOPN 2
86690: END
// every 0 0$1 trigger StreamModeActive and sBunker do
86691: LD_EXP 117
86695: PUSH
86696: LD_EXP 127
86700: AND
86701: IFFALSE 86721
86703: GO 86705
86705: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
86706: LD_INT 32
86708: PPUSH
86709: LD_OWVAR 2
86713: PPUSH
86714: LD_INT 0
86716: PPUSH
86717: CALL_OW 324
86721: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
86722: LD_EXP 117
86726: PUSH
86727: LD_EXP 128
86731: AND
86732: IFFALSE 86913
86734: GO 86736
86736: DISABLE
86737: LD_INT 0
86739: PPUSH
86740: PPUSH
86741: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
86742: LD_ADDR_VAR 0 2
86746: PUSH
86747: LD_INT 22
86749: PUSH
86750: LD_OWVAR 2
86754: PUSH
86755: EMPTY
86756: LIST
86757: LIST
86758: PUSH
86759: LD_INT 33
86761: PUSH
86762: LD_INT 3
86764: PUSH
86765: EMPTY
86766: LIST
86767: LIST
86768: PUSH
86769: EMPTY
86770: LIST
86771: LIST
86772: PPUSH
86773: CALL_OW 69
86777: ST_TO_ADDR
// if not tmp then
86778: LD_VAR 0 2
86782: NOT
86783: IFFALSE 86787
// exit ;
86785: GO 86913
// side := 0 ;
86787: LD_ADDR_VAR 0 3
86791: PUSH
86792: LD_INT 0
86794: ST_TO_ADDR
// for i := 1 to 8 do
86795: LD_ADDR_VAR 0 1
86799: PUSH
86800: DOUBLE
86801: LD_INT 1
86803: DEC
86804: ST_TO_ADDR
86805: LD_INT 8
86807: PUSH
86808: FOR_TO
86809: IFFALSE 86857
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
86811: LD_OWVAR 2
86815: PUSH
86816: LD_VAR 0 1
86820: NONEQUAL
86821: PUSH
86822: LD_OWVAR 2
86826: PPUSH
86827: LD_VAR 0 1
86831: PPUSH
86832: CALL_OW 81
86836: PUSH
86837: LD_INT 2
86839: EQUAL
86840: AND
86841: IFFALSE 86855
// begin side := i ;
86843: LD_ADDR_VAR 0 3
86847: PUSH
86848: LD_VAR 0 1
86852: ST_TO_ADDR
// break ;
86853: GO 86857
// end ;
86855: GO 86808
86857: POP
86858: POP
// if not side then
86859: LD_VAR 0 3
86863: NOT
86864: IFFALSE 86868
// exit ;
86866: GO 86913
// for i := 1 to tmp do
86868: LD_ADDR_VAR 0 1
86872: PUSH
86873: DOUBLE
86874: LD_INT 1
86876: DEC
86877: ST_TO_ADDR
86878: LD_VAR 0 2
86882: PUSH
86883: FOR_TO
86884: IFFALSE 86911
// if Prob ( 60 ) then
86886: LD_INT 60
86888: PPUSH
86889: CALL_OW 13
86893: IFFALSE 86909
// SetSide ( i , side ) ;
86895: LD_VAR 0 1
86899: PPUSH
86900: LD_VAR 0 3
86904: PPUSH
86905: CALL_OW 235
86909: GO 86883
86911: POP
86912: POP
// end ;
86913: PPOPN 3
86915: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
86916: LD_EXP 117
86920: PUSH
86921: LD_EXP 130
86925: AND
86926: IFFALSE 87045
86928: GO 86930
86930: DISABLE
86931: LD_INT 0
86933: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
86934: LD_ADDR_VAR 0 1
86938: PUSH
86939: LD_INT 22
86941: PUSH
86942: LD_OWVAR 2
86946: PUSH
86947: EMPTY
86948: LIST
86949: LIST
86950: PUSH
86951: LD_INT 21
86953: PUSH
86954: LD_INT 1
86956: PUSH
86957: EMPTY
86958: LIST
86959: LIST
86960: PUSH
86961: LD_INT 3
86963: PUSH
86964: LD_INT 23
86966: PUSH
86967: LD_INT 0
86969: PUSH
86970: EMPTY
86971: LIST
86972: LIST
86973: PUSH
86974: EMPTY
86975: LIST
86976: LIST
86977: PUSH
86978: EMPTY
86979: LIST
86980: LIST
86981: LIST
86982: PPUSH
86983: CALL_OW 69
86987: PUSH
86988: FOR_IN
86989: IFFALSE 87043
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
86991: LD_VAR 0 1
86995: PPUSH
86996: CALL_OW 257
87000: PUSH
87001: LD_INT 1
87003: PUSH
87004: LD_INT 2
87006: PUSH
87007: LD_INT 3
87009: PUSH
87010: LD_INT 4
87012: PUSH
87013: EMPTY
87014: LIST
87015: LIST
87016: LIST
87017: LIST
87018: IN
87019: IFFALSE 87041
// SetClass ( un , rand ( 1 , 4 ) ) ;
87021: LD_VAR 0 1
87025: PPUSH
87026: LD_INT 1
87028: PPUSH
87029: LD_INT 4
87031: PPUSH
87032: CALL_OW 12
87036: PPUSH
87037: CALL_OW 336
87041: GO 86988
87043: POP
87044: POP
// end ;
87045: PPOPN 1
87047: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87048: LD_EXP 117
87052: PUSH
87053: LD_EXP 129
87057: AND
87058: IFFALSE 87137
87060: GO 87062
87062: DISABLE
87063: LD_INT 0
87065: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87066: LD_ADDR_VAR 0 1
87070: PUSH
87071: LD_INT 22
87073: PUSH
87074: LD_OWVAR 2
87078: PUSH
87079: EMPTY
87080: LIST
87081: LIST
87082: PUSH
87083: LD_INT 21
87085: PUSH
87086: LD_INT 3
87088: PUSH
87089: EMPTY
87090: LIST
87091: LIST
87092: PUSH
87093: EMPTY
87094: LIST
87095: LIST
87096: PPUSH
87097: CALL_OW 69
87101: ST_TO_ADDR
// if not tmp then
87102: LD_VAR 0 1
87106: NOT
87107: IFFALSE 87111
// exit ;
87109: GO 87137
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87111: LD_VAR 0 1
87115: PUSH
87116: LD_INT 1
87118: PPUSH
87119: LD_VAR 0 1
87123: PPUSH
87124: CALL_OW 12
87128: ARRAY
87129: PPUSH
87130: LD_INT 100
87132: PPUSH
87133: CALL_OW 234
// end ;
87137: PPOPN 1
87139: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87140: LD_EXP 117
87144: PUSH
87145: LD_EXP 131
87149: AND
87150: IFFALSE 87248
87152: GO 87154
87154: DISABLE
87155: LD_INT 0
87157: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87158: LD_ADDR_VAR 0 1
87162: PUSH
87163: LD_INT 22
87165: PUSH
87166: LD_OWVAR 2
87170: PUSH
87171: EMPTY
87172: LIST
87173: LIST
87174: PUSH
87175: LD_INT 21
87177: PUSH
87178: LD_INT 1
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: PUSH
87185: EMPTY
87186: LIST
87187: LIST
87188: PPUSH
87189: CALL_OW 69
87193: ST_TO_ADDR
// if not tmp then
87194: LD_VAR 0 1
87198: NOT
87199: IFFALSE 87203
// exit ;
87201: GO 87248
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87203: LD_VAR 0 1
87207: PUSH
87208: LD_INT 1
87210: PPUSH
87211: LD_VAR 0 1
87215: PPUSH
87216: CALL_OW 12
87220: ARRAY
87221: PPUSH
87222: LD_INT 1
87224: PPUSH
87225: LD_INT 4
87227: PPUSH
87228: CALL_OW 12
87232: PPUSH
87233: LD_INT 3000
87235: PPUSH
87236: LD_INT 9000
87238: PPUSH
87239: CALL_OW 12
87243: PPUSH
87244: CALL_OW 492
// end ;
87248: PPOPN 1
87250: END
// every 0 0$1 trigger StreamModeActive and sDepot do
87251: LD_EXP 117
87255: PUSH
87256: LD_EXP 132
87260: AND
87261: IFFALSE 87281
87263: GO 87265
87265: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
87266: LD_INT 1
87268: PPUSH
87269: LD_OWVAR 2
87273: PPUSH
87274: LD_INT 0
87276: PPUSH
87277: CALL_OW 324
87281: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
87282: LD_EXP 117
87286: PUSH
87287: LD_EXP 133
87291: AND
87292: IFFALSE 87375
87294: GO 87296
87296: DISABLE
87297: LD_INT 0
87299: PPUSH
87300: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87301: LD_ADDR_VAR 0 2
87305: PUSH
87306: LD_INT 22
87308: PUSH
87309: LD_OWVAR 2
87313: PUSH
87314: EMPTY
87315: LIST
87316: LIST
87317: PUSH
87318: LD_INT 21
87320: PUSH
87321: LD_INT 3
87323: PUSH
87324: EMPTY
87325: LIST
87326: LIST
87327: PUSH
87328: EMPTY
87329: LIST
87330: LIST
87331: PPUSH
87332: CALL_OW 69
87336: ST_TO_ADDR
// if not tmp then
87337: LD_VAR 0 2
87341: NOT
87342: IFFALSE 87346
// exit ;
87344: GO 87375
// for i in tmp do
87346: LD_ADDR_VAR 0 1
87350: PUSH
87351: LD_VAR 0 2
87355: PUSH
87356: FOR_IN
87357: IFFALSE 87373
// SetBLevel ( i , 10 ) ;
87359: LD_VAR 0 1
87363: PPUSH
87364: LD_INT 10
87366: PPUSH
87367: CALL_OW 241
87371: GO 87356
87373: POP
87374: POP
// end ;
87375: PPOPN 2
87377: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
87378: LD_EXP 117
87382: PUSH
87383: LD_EXP 134
87387: AND
87388: IFFALSE 87499
87390: GO 87392
87392: DISABLE
87393: LD_INT 0
87395: PPUSH
87396: PPUSH
87397: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
87398: LD_ADDR_VAR 0 3
87402: PUSH
87403: LD_INT 22
87405: PUSH
87406: LD_OWVAR 2
87410: PUSH
87411: EMPTY
87412: LIST
87413: LIST
87414: PUSH
87415: LD_INT 25
87417: PUSH
87418: LD_INT 1
87420: PUSH
87421: EMPTY
87422: LIST
87423: LIST
87424: PUSH
87425: EMPTY
87426: LIST
87427: LIST
87428: PPUSH
87429: CALL_OW 69
87433: ST_TO_ADDR
// if not tmp then
87434: LD_VAR 0 3
87438: NOT
87439: IFFALSE 87443
// exit ;
87441: GO 87499
// un := tmp [ rand ( 1 , tmp ) ] ;
87443: LD_ADDR_VAR 0 2
87447: PUSH
87448: LD_VAR 0 3
87452: PUSH
87453: LD_INT 1
87455: PPUSH
87456: LD_VAR 0 3
87460: PPUSH
87461: CALL_OW 12
87465: ARRAY
87466: ST_TO_ADDR
// if Crawls ( un ) then
87467: LD_VAR 0 2
87471: PPUSH
87472: CALL_OW 318
87476: IFFALSE 87487
// ComWalk ( un ) ;
87478: LD_VAR 0 2
87482: PPUSH
87483: CALL_OW 138
// SetClass ( un , class_sniper ) ;
87487: LD_VAR 0 2
87491: PPUSH
87492: LD_INT 5
87494: PPUSH
87495: CALL_OW 336
// end ;
87499: PPOPN 3
87501: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
87502: LD_EXP 117
87506: PUSH
87507: LD_EXP 135
87511: AND
87512: PUSH
87513: LD_OWVAR 67
87517: PUSH
87518: LD_INT 3
87520: LESS
87521: AND
87522: IFFALSE 87541
87524: GO 87526
87526: DISABLE
// Difficulty := Difficulty + 1 ;
87527: LD_ADDR_OWVAR 67
87531: PUSH
87532: LD_OWVAR 67
87536: PUSH
87537: LD_INT 1
87539: PLUS
87540: ST_TO_ADDR
87541: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
87542: LD_EXP 117
87546: PUSH
87547: LD_EXP 136
87551: AND
87552: IFFALSE 87655
87554: GO 87556
87556: DISABLE
87557: LD_INT 0
87559: PPUSH
// begin for i := 1 to 5 do
87560: LD_ADDR_VAR 0 1
87564: PUSH
87565: DOUBLE
87566: LD_INT 1
87568: DEC
87569: ST_TO_ADDR
87570: LD_INT 5
87572: PUSH
87573: FOR_TO
87574: IFFALSE 87653
// begin uc_nation := nation_nature ;
87576: LD_ADDR_OWVAR 21
87580: PUSH
87581: LD_INT 0
87583: ST_TO_ADDR
// uc_side := 0 ;
87584: LD_ADDR_OWVAR 20
87588: PUSH
87589: LD_INT 0
87591: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
87592: LD_ADDR_OWVAR 29
87596: PUSH
87597: LD_INT 12
87599: PUSH
87600: LD_INT 12
87602: PUSH
87603: EMPTY
87604: LIST
87605: LIST
87606: ST_TO_ADDR
// hc_agressivity := 20 ;
87607: LD_ADDR_OWVAR 35
87611: PUSH
87612: LD_INT 20
87614: ST_TO_ADDR
// hc_class := class_tiger ;
87615: LD_ADDR_OWVAR 28
87619: PUSH
87620: LD_INT 14
87622: ST_TO_ADDR
// hc_gallery :=  ;
87623: LD_ADDR_OWVAR 33
87627: PUSH
87628: LD_STRING 
87630: ST_TO_ADDR
// hc_name :=  ;
87631: LD_ADDR_OWVAR 26
87635: PUSH
87636: LD_STRING 
87638: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
87639: CALL_OW 44
87643: PPUSH
87644: LD_INT 0
87646: PPUSH
87647: CALL_OW 51
// end ;
87651: GO 87573
87653: POP
87654: POP
// end ;
87655: PPOPN 1
87657: END
// every 0 0$1 trigger StreamModeActive and sBomb do
87658: LD_EXP 117
87662: PUSH
87663: LD_EXP 137
87667: AND
87668: IFFALSE 87677
87670: GO 87672
87672: DISABLE
// StreamSibBomb ;
87673: CALL 87678 0 0
87677: END
// export function StreamSibBomb ; var i , x , y ; begin
87678: LD_INT 0
87680: PPUSH
87681: PPUSH
87682: PPUSH
87683: PPUSH
// result := false ;
87684: LD_ADDR_VAR 0 1
87688: PUSH
87689: LD_INT 0
87691: ST_TO_ADDR
// for i := 1 to 16 do
87692: LD_ADDR_VAR 0 2
87696: PUSH
87697: DOUBLE
87698: LD_INT 1
87700: DEC
87701: ST_TO_ADDR
87702: LD_INT 16
87704: PUSH
87705: FOR_TO
87706: IFFALSE 87905
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87708: LD_ADDR_VAR 0 3
87712: PUSH
87713: LD_INT 10
87715: PUSH
87716: LD_INT 20
87718: PUSH
87719: LD_INT 30
87721: PUSH
87722: LD_INT 40
87724: PUSH
87725: LD_INT 50
87727: PUSH
87728: LD_INT 60
87730: PUSH
87731: LD_INT 70
87733: PUSH
87734: LD_INT 80
87736: PUSH
87737: LD_INT 90
87739: PUSH
87740: LD_INT 100
87742: PUSH
87743: LD_INT 110
87745: PUSH
87746: LD_INT 120
87748: PUSH
87749: LD_INT 130
87751: PUSH
87752: LD_INT 140
87754: PUSH
87755: LD_INT 150
87757: PUSH
87758: EMPTY
87759: LIST
87760: LIST
87761: LIST
87762: LIST
87763: LIST
87764: LIST
87765: LIST
87766: LIST
87767: LIST
87768: LIST
87769: LIST
87770: LIST
87771: LIST
87772: LIST
87773: LIST
87774: PUSH
87775: LD_INT 1
87777: PPUSH
87778: LD_INT 15
87780: PPUSH
87781: CALL_OW 12
87785: ARRAY
87786: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
87787: LD_ADDR_VAR 0 4
87791: PUSH
87792: LD_INT 10
87794: PUSH
87795: LD_INT 20
87797: PUSH
87798: LD_INT 30
87800: PUSH
87801: LD_INT 40
87803: PUSH
87804: LD_INT 50
87806: PUSH
87807: LD_INT 60
87809: PUSH
87810: LD_INT 70
87812: PUSH
87813: LD_INT 80
87815: PUSH
87816: LD_INT 90
87818: PUSH
87819: LD_INT 100
87821: PUSH
87822: LD_INT 110
87824: PUSH
87825: LD_INT 120
87827: PUSH
87828: LD_INT 130
87830: PUSH
87831: LD_INT 140
87833: PUSH
87834: LD_INT 150
87836: PUSH
87837: EMPTY
87838: LIST
87839: LIST
87840: LIST
87841: LIST
87842: LIST
87843: LIST
87844: LIST
87845: LIST
87846: LIST
87847: LIST
87848: LIST
87849: LIST
87850: LIST
87851: LIST
87852: LIST
87853: PUSH
87854: LD_INT 1
87856: PPUSH
87857: LD_INT 15
87859: PPUSH
87860: CALL_OW 12
87864: ARRAY
87865: ST_TO_ADDR
// if ValidHex ( x , y ) then
87866: LD_VAR 0 3
87870: PPUSH
87871: LD_VAR 0 4
87875: PPUSH
87876: CALL_OW 488
87880: IFFALSE 87903
// begin result := [ x , y ] ;
87882: LD_ADDR_VAR 0 1
87886: PUSH
87887: LD_VAR 0 3
87891: PUSH
87892: LD_VAR 0 4
87896: PUSH
87897: EMPTY
87898: LIST
87899: LIST
87900: ST_TO_ADDR
// break ;
87901: GO 87905
// end ; end ;
87903: GO 87705
87905: POP
87906: POP
// if result then
87907: LD_VAR 0 1
87911: IFFALSE 87971
// begin ToLua ( playSibBomb() ) ;
87913: LD_STRING playSibBomb()
87915: PPUSH
87916: CALL_OW 559
// wait ( 0 0$14 ) ;
87920: LD_INT 490
87922: PPUSH
87923: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
87927: LD_VAR 0 1
87931: PUSH
87932: LD_INT 1
87934: ARRAY
87935: PPUSH
87936: LD_VAR 0 1
87940: PUSH
87941: LD_INT 2
87943: ARRAY
87944: PPUSH
87945: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
87949: LD_VAR 0 1
87953: PUSH
87954: LD_INT 1
87956: ARRAY
87957: PPUSH
87958: LD_VAR 0 1
87962: PUSH
87963: LD_INT 2
87965: ARRAY
87966: PPUSH
87967: CALL_OW 429
// end ; end ;
87971: LD_VAR 0 1
87975: RET
// every 0 0$1 trigger StreamModeActive and sReset do
87976: LD_EXP 117
87980: PUSH
87981: LD_EXP 139
87985: AND
87986: IFFALSE 87998
87988: GO 87990
87990: DISABLE
// YouLost (  ) ;
87991: LD_STRING 
87993: PPUSH
87994: CALL_OW 104
87998: END
// every 0 0$1 trigger StreamModeActive and sFog do
87999: LD_EXP 117
88003: PUSH
88004: LD_EXP 138
88008: AND
88009: IFFALSE 88023
88011: GO 88013
88013: DISABLE
// FogOff ( your_side ) ;
88014: LD_OWVAR 2
88018: PPUSH
88019: CALL_OW 344
88023: END
// every 0 0$1 trigger StreamModeActive and sSun do
88024: LD_EXP 117
88028: PUSH
88029: LD_EXP 140
88033: AND
88034: IFFALSE 88062
88036: GO 88038
88038: DISABLE
// begin solar_recharge_percent := 0 ;
88039: LD_ADDR_OWVAR 79
88043: PUSH
88044: LD_INT 0
88046: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88047: LD_INT 10500
88049: PPUSH
88050: CALL_OW 67
// solar_recharge_percent := 100 ;
88054: LD_ADDR_OWVAR 79
88058: PUSH
88059: LD_INT 100
88061: ST_TO_ADDR
// end ;
88062: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88063: LD_EXP 117
88067: PUSH
88068: LD_EXP 141
88072: AND
88073: IFFALSE 88312
88075: GO 88077
88077: DISABLE
88078: LD_INT 0
88080: PPUSH
88081: PPUSH
88082: PPUSH
// begin tmp := [ ] ;
88083: LD_ADDR_VAR 0 3
88087: PUSH
88088: EMPTY
88089: ST_TO_ADDR
// for i := 1 to 6 do
88090: LD_ADDR_VAR 0 1
88094: PUSH
88095: DOUBLE
88096: LD_INT 1
88098: DEC
88099: ST_TO_ADDR
88100: LD_INT 6
88102: PUSH
88103: FOR_TO
88104: IFFALSE 88209
// begin uc_nation := nation_nature ;
88106: LD_ADDR_OWVAR 21
88110: PUSH
88111: LD_INT 0
88113: ST_TO_ADDR
// uc_side := 0 ;
88114: LD_ADDR_OWVAR 20
88118: PUSH
88119: LD_INT 0
88121: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88122: LD_ADDR_OWVAR 29
88126: PUSH
88127: LD_INT 12
88129: PUSH
88130: LD_INT 12
88132: PUSH
88133: EMPTY
88134: LIST
88135: LIST
88136: ST_TO_ADDR
// hc_agressivity := 20 ;
88137: LD_ADDR_OWVAR 35
88141: PUSH
88142: LD_INT 20
88144: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88145: LD_ADDR_OWVAR 28
88149: PUSH
88150: LD_INT 17
88152: ST_TO_ADDR
// hc_gallery :=  ;
88153: LD_ADDR_OWVAR 33
88157: PUSH
88158: LD_STRING 
88160: ST_TO_ADDR
// hc_name :=  ;
88161: LD_ADDR_OWVAR 26
88165: PUSH
88166: LD_STRING 
88168: ST_TO_ADDR
// un := CreateHuman ;
88169: LD_ADDR_VAR 0 2
88173: PUSH
88174: CALL_OW 44
88178: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88179: LD_VAR 0 2
88183: PPUSH
88184: LD_INT 1
88186: PPUSH
88187: CALL_OW 51
// tmp := tmp ^ un ;
88191: LD_ADDR_VAR 0 3
88195: PUSH
88196: LD_VAR 0 3
88200: PUSH
88201: LD_VAR 0 2
88205: ADD
88206: ST_TO_ADDR
// end ;
88207: GO 88103
88209: POP
88210: POP
// repeat wait ( 0 0$1 ) ;
88211: LD_INT 35
88213: PPUSH
88214: CALL_OW 67
// for un in tmp do
88218: LD_ADDR_VAR 0 2
88222: PUSH
88223: LD_VAR 0 3
88227: PUSH
88228: FOR_IN
88229: IFFALSE 88303
// begin if IsDead ( un ) then
88231: LD_VAR 0 2
88235: PPUSH
88236: CALL_OW 301
88240: IFFALSE 88260
// begin tmp := tmp diff un ;
88242: LD_ADDR_VAR 0 3
88246: PUSH
88247: LD_VAR 0 3
88251: PUSH
88252: LD_VAR 0 2
88256: DIFF
88257: ST_TO_ADDR
// continue ;
88258: GO 88228
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
88260: LD_VAR 0 2
88264: PPUSH
88265: LD_INT 3
88267: PUSH
88268: LD_INT 22
88270: PUSH
88271: LD_INT 0
88273: PUSH
88274: EMPTY
88275: LIST
88276: LIST
88277: PUSH
88278: EMPTY
88279: LIST
88280: LIST
88281: PPUSH
88282: CALL_OW 69
88286: PPUSH
88287: LD_VAR 0 2
88291: PPUSH
88292: CALL_OW 74
88296: PPUSH
88297: CALL_OW 115
// end ;
88301: GO 88228
88303: POP
88304: POP
// until not tmp ;
88305: LD_VAR 0 3
88309: NOT
88310: IFFALSE 88211
// end ;
88312: PPOPN 3
88314: END
// every 0 0$1 trigger StreamModeActive and sTroll do
88315: LD_EXP 117
88319: PUSH
88320: LD_EXP 142
88324: AND
88325: IFFALSE 88379
88327: GO 88329
88329: DISABLE
// begin ToLua ( displayTroll(); ) ;
88330: LD_STRING displayTroll();
88332: PPUSH
88333: CALL_OW 559
// wait ( 3 3$00 ) ;
88337: LD_INT 6300
88339: PPUSH
88340: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88344: LD_STRING hideTroll();
88346: PPUSH
88347: CALL_OW 559
// wait ( 1 1$00 ) ;
88351: LD_INT 2100
88353: PPUSH
88354: CALL_OW 67
// ToLua ( displayTroll(); ) ;
88358: LD_STRING displayTroll();
88360: PPUSH
88361: CALL_OW 559
// wait ( 1 1$00 ) ;
88365: LD_INT 2100
88367: PPUSH
88368: CALL_OW 67
// ToLua ( hideTroll(); ) ;
88372: LD_STRING hideTroll();
88374: PPUSH
88375: CALL_OW 559
// end ;
88379: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
88380: LD_EXP 117
88384: PUSH
88385: LD_EXP 143
88389: AND
88390: IFFALSE 88453
88392: GO 88394
88394: DISABLE
88395: LD_INT 0
88397: PPUSH
// begin p := 0 ;
88398: LD_ADDR_VAR 0 1
88402: PUSH
88403: LD_INT 0
88405: ST_TO_ADDR
// repeat game_speed := 1 ;
88406: LD_ADDR_OWVAR 65
88410: PUSH
88411: LD_INT 1
88413: ST_TO_ADDR
// wait ( 0 0$1 ) ;
88414: LD_INT 35
88416: PPUSH
88417: CALL_OW 67
// p := p + 1 ;
88421: LD_ADDR_VAR 0 1
88425: PUSH
88426: LD_VAR 0 1
88430: PUSH
88431: LD_INT 1
88433: PLUS
88434: ST_TO_ADDR
// until p >= 60 ;
88435: LD_VAR 0 1
88439: PUSH
88440: LD_INT 60
88442: GREATEREQUAL
88443: IFFALSE 88406
// game_speed := 4 ;
88445: LD_ADDR_OWVAR 65
88449: PUSH
88450: LD_INT 4
88452: ST_TO_ADDR
// end ;
88453: PPOPN 1
88455: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
88456: LD_EXP 117
88460: PUSH
88461: LD_EXP 144
88465: AND
88466: IFFALSE 88612
88468: GO 88470
88470: DISABLE
88471: LD_INT 0
88473: PPUSH
88474: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
88475: LD_ADDR_VAR 0 1
88479: PUSH
88480: LD_INT 22
88482: PUSH
88483: LD_OWVAR 2
88487: PUSH
88488: EMPTY
88489: LIST
88490: LIST
88491: PUSH
88492: LD_INT 2
88494: PUSH
88495: LD_INT 30
88497: PUSH
88498: LD_INT 0
88500: PUSH
88501: EMPTY
88502: LIST
88503: LIST
88504: PUSH
88505: LD_INT 30
88507: PUSH
88508: LD_INT 1
88510: PUSH
88511: EMPTY
88512: LIST
88513: LIST
88514: PUSH
88515: EMPTY
88516: LIST
88517: LIST
88518: LIST
88519: PUSH
88520: EMPTY
88521: LIST
88522: LIST
88523: PPUSH
88524: CALL_OW 69
88528: ST_TO_ADDR
// if not depot then
88529: LD_VAR 0 1
88533: NOT
88534: IFFALSE 88538
// exit ;
88536: GO 88612
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
88538: LD_ADDR_VAR 0 2
88542: PUSH
88543: LD_VAR 0 1
88547: PUSH
88548: LD_INT 1
88550: PPUSH
88551: LD_VAR 0 1
88555: PPUSH
88556: CALL_OW 12
88560: ARRAY
88561: PPUSH
88562: CALL_OW 274
88566: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
88567: LD_VAR 0 2
88571: PPUSH
88572: LD_INT 1
88574: PPUSH
88575: LD_INT 0
88577: PPUSH
88578: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
88582: LD_VAR 0 2
88586: PPUSH
88587: LD_INT 2
88589: PPUSH
88590: LD_INT 0
88592: PPUSH
88593: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
88597: LD_VAR 0 2
88601: PPUSH
88602: LD_INT 3
88604: PPUSH
88605: LD_INT 0
88607: PPUSH
88608: CALL_OW 277
// end ;
88612: PPOPN 2
88614: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
88615: LD_EXP 117
88619: PUSH
88620: LD_EXP 145
88624: AND
88625: IFFALSE 88722
88627: GO 88629
88629: DISABLE
88630: LD_INT 0
88632: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
88633: LD_ADDR_VAR 0 1
88637: PUSH
88638: LD_INT 22
88640: PUSH
88641: LD_OWVAR 2
88645: PUSH
88646: EMPTY
88647: LIST
88648: LIST
88649: PUSH
88650: LD_INT 21
88652: PUSH
88653: LD_INT 1
88655: PUSH
88656: EMPTY
88657: LIST
88658: LIST
88659: PUSH
88660: LD_INT 3
88662: PUSH
88663: LD_INT 23
88665: PUSH
88666: LD_INT 0
88668: PUSH
88669: EMPTY
88670: LIST
88671: LIST
88672: PUSH
88673: EMPTY
88674: LIST
88675: LIST
88676: PUSH
88677: EMPTY
88678: LIST
88679: LIST
88680: LIST
88681: PPUSH
88682: CALL_OW 69
88686: ST_TO_ADDR
// if not tmp then
88687: LD_VAR 0 1
88691: NOT
88692: IFFALSE 88696
// exit ;
88694: GO 88722
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
88696: LD_VAR 0 1
88700: PUSH
88701: LD_INT 1
88703: PPUSH
88704: LD_VAR 0 1
88708: PPUSH
88709: CALL_OW 12
88713: ARRAY
88714: PPUSH
88715: LD_INT 200
88717: PPUSH
88718: CALL_OW 234
// end ;
88722: PPOPN 1
88724: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
88725: LD_EXP 117
88729: PUSH
88730: LD_EXP 146
88734: AND
88735: IFFALSE 88814
88737: GO 88739
88739: DISABLE
88740: LD_INT 0
88742: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
88743: LD_ADDR_VAR 0 1
88747: PUSH
88748: LD_INT 22
88750: PUSH
88751: LD_OWVAR 2
88755: PUSH
88756: EMPTY
88757: LIST
88758: LIST
88759: PUSH
88760: LD_INT 21
88762: PUSH
88763: LD_INT 2
88765: PUSH
88766: EMPTY
88767: LIST
88768: LIST
88769: PUSH
88770: EMPTY
88771: LIST
88772: LIST
88773: PPUSH
88774: CALL_OW 69
88778: ST_TO_ADDR
// if not tmp then
88779: LD_VAR 0 1
88783: NOT
88784: IFFALSE 88788
// exit ;
88786: GO 88814
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
88788: LD_VAR 0 1
88792: PUSH
88793: LD_INT 1
88795: PPUSH
88796: LD_VAR 0 1
88800: PPUSH
88801: CALL_OW 12
88805: ARRAY
88806: PPUSH
88807: LD_INT 60
88809: PPUSH
88810: CALL_OW 234
// end ;
88814: PPOPN 1
88816: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
88817: LD_EXP 117
88821: PUSH
88822: LD_EXP 147
88826: AND
88827: IFFALSE 88926
88829: GO 88831
88831: DISABLE
88832: LD_INT 0
88834: PPUSH
88835: PPUSH
// begin enable ;
88836: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
88837: LD_ADDR_VAR 0 1
88841: PUSH
88842: LD_INT 22
88844: PUSH
88845: LD_OWVAR 2
88849: PUSH
88850: EMPTY
88851: LIST
88852: LIST
88853: PUSH
88854: LD_INT 61
88856: PUSH
88857: EMPTY
88858: LIST
88859: PUSH
88860: LD_INT 33
88862: PUSH
88863: LD_INT 2
88865: PUSH
88866: EMPTY
88867: LIST
88868: LIST
88869: PUSH
88870: EMPTY
88871: LIST
88872: LIST
88873: LIST
88874: PPUSH
88875: CALL_OW 69
88879: ST_TO_ADDR
// if not tmp then
88880: LD_VAR 0 1
88884: NOT
88885: IFFALSE 88889
// exit ;
88887: GO 88926
// for i in tmp do
88889: LD_ADDR_VAR 0 2
88893: PUSH
88894: LD_VAR 0 1
88898: PUSH
88899: FOR_IN
88900: IFFALSE 88924
// if IsControledBy ( i ) then
88902: LD_VAR 0 2
88906: PPUSH
88907: CALL_OW 312
88911: IFFALSE 88922
// ComUnlink ( i ) ;
88913: LD_VAR 0 2
88917: PPUSH
88918: CALL_OW 136
88922: GO 88899
88924: POP
88925: POP
// end ;
88926: PPOPN 2
88928: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
88929: LD_EXP 117
88933: PUSH
88934: LD_EXP 148
88938: AND
88939: IFFALSE 89079
88941: GO 88943
88943: DISABLE
88944: LD_INT 0
88946: PPUSH
88947: PPUSH
// begin ToLua ( displayPowell(); ) ;
88948: LD_STRING displayPowell();
88950: PPUSH
88951: CALL_OW 559
// uc_side := 0 ;
88955: LD_ADDR_OWVAR 20
88959: PUSH
88960: LD_INT 0
88962: ST_TO_ADDR
// uc_nation := 2 ;
88963: LD_ADDR_OWVAR 21
88967: PUSH
88968: LD_INT 2
88970: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
88971: LD_ADDR_OWVAR 37
88975: PUSH
88976: LD_INT 14
88978: ST_TO_ADDR
// vc_engine := engine_siberite ;
88979: LD_ADDR_OWVAR 39
88983: PUSH
88984: LD_INT 3
88986: ST_TO_ADDR
// vc_control := control_apeman ;
88987: LD_ADDR_OWVAR 38
88991: PUSH
88992: LD_INT 5
88994: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
88995: LD_ADDR_OWVAR 40
88999: PUSH
89000: LD_INT 29
89002: ST_TO_ADDR
// un := CreateVehicle ;
89003: LD_ADDR_VAR 0 2
89007: PUSH
89008: CALL_OW 45
89012: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89013: LD_VAR 0 2
89017: PPUSH
89018: LD_INT 1
89020: PPUSH
89021: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89025: LD_INT 35
89027: PPUSH
89028: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89032: LD_VAR 0 2
89036: PPUSH
89037: LD_INT 22
89039: PUSH
89040: LD_OWVAR 2
89044: PUSH
89045: EMPTY
89046: LIST
89047: LIST
89048: PPUSH
89049: CALL_OW 69
89053: PPUSH
89054: LD_VAR 0 2
89058: PPUSH
89059: CALL_OW 74
89063: PPUSH
89064: CALL_OW 115
// until IsDead ( un ) ;
89068: LD_VAR 0 2
89072: PPUSH
89073: CALL_OW 301
89077: IFFALSE 89025
// end ;
89079: PPOPN 2
89081: END
// every 0 0$1 trigger StreamModeActive and sStu do
89082: LD_EXP 117
89086: PUSH
89087: LD_EXP 156
89091: AND
89092: IFFALSE 89108
89094: GO 89096
89096: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89097: LD_STRING displayStucuk();
89099: PPUSH
89100: CALL_OW 559
// ResetFog ;
89104: CALL_OW 335
// end ;
89108: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89109: LD_EXP 117
89113: PUSH
89114: LD_EXP 149
89118: AND
89119: IFFALSE 89260
89121: GO 89123
89123: DISABLE
89124: LD_INT 0
89126: PPUSH
89127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89128: LD_ADDR_VAR 0 2
89132: PUSH
89133: LD_INT 22
89135: PUSH
89136: LD_OWVAR 2
89140: PUSH
89141: EMPTY
89142: LIST
89143: LIST
89144: PUSH
89145: LD_INT 21
89147: PUSH
89148: LD_INT 1
89150: PUSH
89151: EMPTY
89152: LIST
89153: LIST
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: PPUSH
89159: CALL_OW 69
89163: ST_TO_ADDR
// if not tmp then
89164: LD_VAR 0 2
89168: NOT
89169: IFFALSE 89173
// exit ;
89171: GO 89260
// un := tmp [ rand ( 1 , tmp ) ] ;
89173: LD_ADDR_VAR 0 1
89177: PUSH
89178: LD_VAR 0 2
89182: PUSH
89183: LD_INT 1
89185: PPUSH
89186: LD_VAR 0 2
89190: PPUSH
89191: CALL_OW 12
89195: ARRAY
89196: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89197: LD_VAR 0 1
89201: PPUSH
89202: LD_INT 0
89204: PPUSH
89205: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
89209: LD_VAR 0 1
89213: PPUSH
89214: LD_OWVAR 3
89218: PUSH
89219: LD_VAR 0 1
89223: DIFF
89224: PPUSH
89225: LD_VAR 0 1
89229: PPUSH
89230: CALL_OW 74
89234: PPUSH
89235: CALL_OW 115
// wait ( 0 0$20 ) ;
89239: LD_INT 700
89241: PPUSH
89242: CALL_OW 67
// SetSide ( un , your_side ) ;
89246: LD_VAR 0 1
89250: PPUSH
89251: LD_OWVAR 2
89255: PPUSH
89256: CALL_OW 235
// end ;
89260: PPOPN 2
89262: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
89263: LD_EXP 117
89267: PUSH
89268: LD_EXP 150
89272: AND
89273: IFFALSE 89379
89275: GO 89277
89277: DISABLE
89278: LD_INT 0
89280: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89281: LD_ADDR_VAR 0 1
89285: PUSH
89286: LD_INT 22
89288: PUSH
89289: LD_OWVAR 2
89293: PUSH
89294: EMPTY
89295: LIST
89296: LIST
89297: PUSH
89298: LD_INT 2
89300: PUSH
89301: LD_INT 30
89303: PUSH
89304: LD_INT 0
89306: PUSH
89307: EMPTY
89308: LIST
89309: LIST
89310: PUSH
89311: LD_INT 30
89313: PUSH
89314: LD_INT 1
89316: PUSH
89317: EMPTY
89318: LIST
89319: LIST
89320: PUSH
89321: EMPTY
89322: LIST
89323: LIST
89324: LIST
89325: PUSH
89326: EMPTY
89327: LIST
89328: LIST
89329: PPUSH
89330: CALL_OW 69
89334: ST_TO_ADDR
// if not depot then
89335: LD_VAR 0 1
89339: NOT
89340: IFFALSE 89344
// exit ;
89342: GO 89379
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
89344: LD_VAR 0 1
89348: PUSH
89349: LD_INT 1
89351: ARRAY
89352: PPUSH
89353: CALL_OW 250
89357: PPUSH
89358: LD_VAR 0 1
89362: PUSH
89363: LD_INT 1
89365: ARRAY
89366: PPUSH
89367: CALL_OW 251
89371: PPUSH
89372: LD_INT 70
89374: PPUSH
89375: CALL_OW 495
// end ;
89379: PPOPN 1
89381: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
89382: LD_EXP 117
89386: PUSH
89387: LD_EXP 151
89391: AND
89392: IFFALSE 89603
89394: GO 89396
89396: DISABLE
89397: LD_INT 0
89399: PPUSH
89400: PPUSH
89401: PPUSH
89402: PPUSH
89403: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89404: LD_ADDR_VAR 0 5
89408: PUSH
89409: LD_INT 22
89411: PUSH
89412: LD_OWVAR 2
89416: PUSH
89417: EMPTY
89418: LIST
89419: LIST
89420: PUSH
89421: LD_INT 21
89423: PUSH
89424: LD_INT 1
89426: PUSH
89427: EMPTY
89428: LIST
89429: LIST
89430: PUSH
89431: EMPTY
89432: LIST
89433: LIST
89434: PPUSH
89435: CALL_OW 69
89439: ST_TO_ADDR
// if not tmp then
89440: LD_VAR 0 5
89444: NOT
89445: IFFALSE 89449
// exit ;
89447: GO 89603
// for i in tmp do
89449: LD_ADDR_VAR 0 1
89453: PUSH
89454: LD_VAR 0 5
89458: PUSH
89459: FOR_IN
89460: IFFALSE 89601
// begin d := rand ( 0 , 5 ) ;
89462: LD_ADDR_VAR 0 4
89466: PUSH
89467: LD_INT 0
89469: PPUSH
89470: LD_INT 5
89472: PPUSH
89473: CALL_OW 12
89477: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
89478: LD_ADDR_VAR 0 2
89482: PUSH
89483: LD_VAR 0 1
89487: PPUSH
89488: CALL_OW 250
89492: PPUSH
89493: LD_VAR 0 4
89497: PPUSH
89498: LD_INT 3
89500: PPUSH
89501: LD_INT 12
89503: PPUSH
89504: CALL_OW 12
89508: PPUSH
89509: CALL_OW 272
89513: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
89514: LD_ADDR_VAR 0 3
89518: PUSH
89519: LD_VAR 0 1
89523: PPUSH
89524: CALL_OW 251
89528: PPUSH
89529: LD_VAR 0 4
89533: PPUSH
89534: LD_INT 3
89536: PPUSH
89537: LD_INT 12
89539: PPUSH
89540: CALL_OW 12
89544: PPUSH
89545: CALL_OW 273
89549: ST_TO_ADDR
// if ValidHex ( x , y ) then
89550: LD_VAR 0 2
89554: PPUSH
89555: LD_VAR 0 3
89559: PPUSH
89560: CALL_OW 488
89564: IFFALSE 89599
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
89566: LD_VAR 0 1
89570: PPUSH
89571: LD_VAR 0 2
89575: PPUSH
89576: LD_VAR 0 3
89580: PPUSH
89581: LD_INT 3
89583: PPUSH
89584: LD_INT 6
89586: PPUSH
89587: CALL_OW 12
89591: PPUSH
89592: LD_INT 1
89594: PPUSH
89595: CALL_OW 483
// end ;
89599: GO 89459
89601: POP
89602: POP
// end ;
89603: PPOPN 5
89605: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
89606: LD_EXP 117
89610: PUSH
89611: LD_EXP 152
89615: AND
89616: IFFALSE 89710
89618: GO 89620
89620: DISABLE
89621: LD_INT 0
89623: PPUSH
89624: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
89625: LD_ADDR_VAR 0 2
89629: PUSH
89630: LD_INT 22
89632: PUSH
89633: LD_OWVAR 2
89637: PUSH
89638: EMPTY
89639: LIST
89640: LIST
89641: PUSH
89642: LD_INT 32
89644: PUSH
89645: LD_INT 1
89647: PUSH
89648: EMPTY
89649: LIST
89650: LIST
89651: PUSH
89652: LD_INT 21
89654: PUSH
89655: LD_INT 2
89657: PUSH
89658: EMPTY
89659: LIST
89660: LIST
89661: PUSH
89662: EMPTY
89663: LIST
89664: LIST
89665: LIST
89666: PPUSH
89667: CALL_OW 69
89671: ST_TO_ADDR
// if not tmp then
89672: LD_VAR 0 2
89676: NOT
89677: IFFALSE 89681
// exit ;
89679: GO 89710
// for i in tmp do
89681: LD_ADDR_VAR 0 1
89685: PUSH
89686: LD_VAR 0 2
89690: PUSH
89691: FOR_IN
89692: IFFALSE 89708
// SetFuel ( i , 0 ) ;
89694: LD_VAR 0 1
89698: PPUSH
89699: LD_INT 0
89701: PPUSH
89702: CALL_OW 240
89706: GO 89691
89708: POP
89709: POP
// end ;
89710: PPOPN 2
89712: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
89713: LD_EXP 117
89717: PUSH
89718: LD_EXP 153
89722: AND
89723: IFFALSE 89789
89725: GO 89727
89727: DISABLE
89728: LD_INT 0
89730: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
89731: LD_ADDR_VAR 0 1
89735: PUSH
89736: LD_INT 22
89738: PUSH
89739: LD_OWVAR 2
89743: PUSH
89744: EMPTY
89745: LIST
89746: LIST
89747: PUSH
89748: LD_INT 30
89750: PUSH
89751: LD_INT 29
89753: PUSH
89754: EMPTY
89755: LIST
89756: LIST
89757: PUSH
89758: EMPTY
89759: LIST
89760: LIST
89761: PPUSH
89762: CALL_OW 69
89766: ST_TO_ADDR
// if not tmp then
89767: LD_VAR 0 1
89771: NOT
89772: IFFALSE 89776
// exit ;
89774: GO 89789
// DestroyUnit ( tmp [ 1 ] ) ;
89776: LD_VAR 0 1
89780: PUSH
89781: LD_INT 1
89783: ARRAY
89784: PPUSH
89785: CALL_OW 65
// end ;
89789: PPOPN 1
89791: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
89792: LD_EXP 117
89796: PUSH
89797: LD_EXP 155
89801: AND
89802: IFFALSE 89931
89804: GO 89806
89806: DISABLE
89807: LD_INT 0
89809: PPUSH
// begin uc_side := 0 ;
89810: LD_ADDR_OWVAR 20
89814: PUSH
89815: LD_INT 0
89817: ST_TO_ADDR
// uc_nation := nation_arabian ;
89818: LD_ADDR_OWVAR 21
89822: PUSH
89823: LD_INT 2
89825: ST_TO_ADDR
// hc_gallery :=  ;
89826: LD_ADDR_OWVAR 33
89830: PUSH
89831: LD_STRING 
89833: ST_TO_ADDR
// hc_name :=  ;
89834: LD_ADDR_OWVAR 26
89838: PUSH
89839: LD_STRING 
89841: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
89842: LD_INT 1
89844: PPUSH
89845: LD_INT 11
89847: PPUSH
89848: LD_INT 10
89850: PPUSH
89851: CALL_OW 380
// un := CreateHuman ;
89855: LD_ADDR_VAR 0 1
89859: PUSH
89860: CALL_OW 44
89864: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89865: LD_VAR 0 1
89869: PPUSH
89870: LD_INT 1
89872: PPUSH
89873: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89877: LD_INT 35
89879: PPUSH
89880: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89884: LD_VAR 0 1
89888: PPUSH
89889: LD_INT 22
89891: PUSH
89892: LD_OWVAR 2
89896: PUSH
89897: EMPTY
89898: LIST
89899: LIST
89900: PPUSH
89901: CALL_OW 69
89905: PPUSH
89906: LD_VAR 0 1
89910: PPUSH
89911: CALL_OW 74
89915: PPUSH
89916: CALL_OW 115
// until IsDead ( un ) ;
89920: LD_VAR 0 1
89924: PPUSH
89925: CALL_OW 301
89929: IFFALSE 89877
// end ;
89931: PPOPN 1
89933: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
89934: LD_EXP 117
89938: PUSH
89939: LD_EXP 157
89943: AND
89944: IFFALSE 89956
89946: GO 89948
89948: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
89949: LD_STRING earthquake(getX(game), 0, 32)
89951: PPUSH
89952: CALL_OW 559
89956: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
89957: LD_EXP 117
89961: PUSH
89962: LD_EXP 158
89966: AND
89967: IFFALSE 90058
89969: GO 89971
89971: DISABLE
89972: LD_INT 0
89974: PPUSH
// begin enable ;
89975: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
89976: LD_ADDR_VAR 0 1
89980: PUSH
89981: LD_INT 22
89983: PUSH
89984: LD_OWVAR 2
89988: PUSH
89989: EMPTY
89990: LIST
89991: LIST
89992: PUSH
89993: LD_INT 21
89995: PUSH
89996: LD_INT 2
89998: PUSH
89999: EMPTY
90000: LIST
90001: LIST
90002: PUSH
90003: LD_INT 33
90005: PUSH
90006: LD_INT 3
90008: PUSH
90009: EMPTY
90010: LIST
90011: LIST
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: LIST
90017: PPUSH
90018: CALL_OW 69
90022: ST_TO_ADDR
// if not tmp then
90023: LD_VAR 0 1
90027: NOT
90028: IFFALSE 90032
// exit ;
90030: GO 90058
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90032: LD_VAR 0 1
90036: PUSH
90037: LD_INT 1
90039: PPUSH
90040: LD_VAR 0 1
90044: PPUSH
90045: CALL_OW 12
90049: ARRAY
90050: PPUSH
90051: LD_INT 1
90053: PPUSH
90054: CALL_OW 234
// end ;
90058: PPOPN 1
90060: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90061: LD_EXP 117
90065: PUSH
90066: LD_EXP 159
90070: AND
90071: IFFALSE 90212
90073: GO 90075
90075: DISABLE
90076: LD_INT 0
90078: PPUSH
90079: PPUSH
90080: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90081: LD_ADDR_VAR 0 3
90085: PUSH
90086: LD_INT 22
90088: PUSH
90089: LD_OWVAR 2
90093: PUSH
90094: EMPTY
90095: LIST
90096: LIST
90097: PUSH
90098: LD_INT 25
90100: PUSH
90101: LD_INT 1
90103: PUSH
90104: EMPTY
90105: LIST
90106: LIST
90107: PUSH
90108: EMPTY
90109: LIST
90110: LIST
90111: PPUSH
90112: CALL_OW 69
90116: ST_TO_ADDR
// if not tmp then
90117: LD_VAR 0 3
90121: NOT
90122: IFFALSE 90126
// exit ;
90124: GO 90212
// un := tmp [ rand ( 1 , tmp ) ] ;
90126: LD_ADDR_VAR 0 2
90130: PUSH
90131: LD_VAR 0 3
90135: PUSH
90136: LD_INT 1
90138: PPUSH
90139: LD_VAR 0 3
90143: PPUSH
90144: CALL_OW 12
90148: ARRAY
90149: ST_TO_ADDR
// if Crawls ( un ) then
90150: LD_VAR 0 2
90154: PPUSH
90155: CALL_OW 318
90159: IFFALSE 90170
// ComWalk ( un ) ;
90161: LD_VAR 0 2
90165: PPUSH
90166: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90170: LD_VAR 0 2
90174: PPUSH
90175: LD_INT 9
90177: PPUSH
90178: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90182: LD_INT 28
90184: PPUSH
90185: LD_OWVAR 2
90189: PPUSH
90190: LD_INT 2
90192: PPUSH
90193: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90197: LD_INT 29
90199: PPUSH
90200: LD_OWVAR 2
90204: PPUSH
90205: LD_INT 2
90207: PPUSH
90208: CALL_OW 322
// end ;
90212: PPOPN 3
90214: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
90215: LD_EXP 117
90219: PUSH
90220: LD_EXP 160
90224: AND
90225: IFFALSE 90336
90227: GO 90229
90229: DISABLE
90230: LD_INT 0
90232: PPUSH
90233: PPUSH
90234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90235: LD_ADDR_VAR 0 3
90239: PUSH
90240: LD_INT 22
90242: PUSH
90243: LD_OWVAR 2
90247: PUSH
90248: EMPTY
90249: LIST
90250: LIST
90251: PUSH
90252: LD_INT 25
90254: PUSH
90255: LD_INT 1
90257: PUSH
90258: EMPTY
90259: LIST
90260: LIST
90261: PUSH
90262: EMPTY
90263: LIST
90264: LIST
90265: PPUSH
90266: CALL_OW 69
90270: ST_TO_ADDR
// if not tmp then
90271: LD_VAR 0 3
90275: NOT
90276: IFFALSE 90280
// exit ;
90278: GO 90336
// un := tmp [ rand ( 1 , tmp ) ] ;
90280: LD_ADDR_VAR 0 2
90284: PUSH
90285: LD_VAR 0 3
90289: PUSH
90290: LD_INT 1
90292: PPUSH
90293: LD_VAR 0 3
90297: PPUSH
90298: CALL_OW 12
90302: ARRAY
90303: ST_TO_ADDR
// if Crawls ( un ) then
90304: LD_VAR 0 2
90308: PPUSH
90309: CALL_OW 318
90313: IFFALSE 90324
// ComWalk ( un ) ;
90315: LD_VAR 0 2
90319: PPUSH
90320: CALL_OW 138
// SetClass ( un , class_mortar ) ;
90324: LD_VAR 0 2
90328: PPUSH
90329: LD_INT 8
90331: PPUSH
90332: CALL_OW 336
// end ;
90336: PPOPN 3
90338: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
90339: LD_EXP 117
90343: PUSH
90344: LD_EXP 161
90348: AND
90349: IFFALSE 90493
90351: GO 90353
90353: DISABLE
90354: LD_INT 0
90356: PPUSH
90357: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
90358: LD_ADDR_VAR 0 2
90362: PUSH
90363: LD_INT 22
90365: PUSH
90366: LD_OWVAR 2
90370: PUSH
90371: EMPTY
90372: LIST
90373: LIST
90374: PUSH
90375: LD_INT 21
90377: PUSH
90378: LD_INT 2
90380: PUSH
90381: EMPTY
90382: LIST
90383: LIST
90384: PUSH
90385: LD_INT 2
90387: PUSH
90388: LD_INT 34
90390: PUSH
90391: LD_INT 12
90393: PUSH
90394: EMPTY
90395: LIST
90396: LIST
90397: PUSH
90398: LD_INT 34
90400: PUSH
90401: LD_INT 51
90403: PUSH
90404: EMPTY
90405: LIST
90406: LIST
90407: PUSH
90408: LD_INT 34
90410: PUSH
90411: LD_INT 32
90413: PUSH
90414: EMPTY
90415: LIST
90416: LIST
90417: PUSH
90418: EMPTY
90419: LIST
90420: LIST
90421: LIST
90422: LIST
90423: PUSH
90424: EMPTY
90425: LIST
90426: LIST
90427: LIST
90428: PPUSH
90429: CALL_OW 69
90433: ST_TO_ADDR
// if not tmp then
90434: LD_VAR 0 2
90438: NOT
90439: IFFALSE 90443
// exit ;
90441: GO 90493
// for i in tmp do
90443: LD_ADDR_VAR 0 1
90447: PUSH
90448: LD_VAR 0 2
90452: PUSH
90453: FOR_IN
90454: IFFALSE 90491
// if GetCargo ( i , mat_artifact ) = 0 then
90456: LD_VAR 0 1
90460: PPUSH
90461: LD_INT 4
90463: PPUSH
90464: CALL_OW 289
90468: PUSH
90469: LD_INT 0
90471: EQUAL
90472: IFFALSE 90489
// SetCargo ( i , mat_siberit , 100 ) ;
90474: LD_VAR 0 1
90478: PPUSH
90479: LD_INT 3
90481: PPUSH
90482: LD_INT 100
90484: PPUSH
90485: CALL_OW 290
90489: GO 90453
90491: POP
90492: POP
// end ;
90493: PPOPN 2
90495: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
90496: LD_EXP 117
90500: PUSH
90501: LD_EXP 162
90505: AND
90506: IFFALSE 90689
90508: GO 90510
90510: DISABLE
90511: LD_INT 0
90513: PPUSH
90514: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
90515: LD_ADDR_VAR 0 2
90519: PUSH
90520: LD_INT 22
90522: PUSH
90523: LD_OWVAR 2
90527: PUSH
90528: EMPTY
90529: LIST
90530: LIST
90531: PPUSH
90532: CALL_OW 69
90536: ST_TO_ADDR
// if not tmp then
90537: LD_VAR 0 2
90541: NOT
90542: IFFALSE 90546
// exit ;
90544: GO 90689
// for i := 1 to 2 do
90546: LD_ADDR_VAR 0 1
90550: PUSH
90551: DOUBLE
90552: LD_INT 1
90554: DEC
90555: ST_TO_ADDR
90556: LD_INT 2
90558: PUSH
90559: FOR_TO
90560: IFFALSE 90687
// begin uc_side := your_side ;
90562: LD_ADDR_OWVAR 20
90566: PUSH
90567: LD_OWVAR 2
90571: ST_TO_ADDR
// uc_nation := nation_american ;
90572: LD_ADDR_OWVAR 21
90576: PUSH
90577: LD_INT 1
90579: ST_TO_ADDR
// vc_chassis := us_morphling ;
90580: LD_ADDR_OWVAR 37
90584: PUSH
90585: LD_INT 5
90587: ST_TO_ADDR
// vc_engine := engine_siberite ;
90588: LD_ADDR_OWVAR 39
90592: PUSH
90593: LD_INT 3
90595: ST_TO_ADDR
// vc_control := control_computer ;
90596: LD_ADDR_OWVAR 38
90600: PUSH
90601: LD_INT 3
90603: ST_TO_ADDR
// vc_weapon := us_double_laser ;
90604: LD_ADDR_OWVAR 40
90608: PUSH
90609: LD_INT 10
90611: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
90612: LD_VAR 0 2
90616: PUSH
90617: LD_INT 1
90619: ARRAY
90620: PPUSH
90621: CALL_OW 310
90625: NOT
90626: IFFALSE 90673
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
90628: CALL_OW 45
90632: PPUSH
90633: LD_VAR 0 2
90637: PUSH
90638: LD_INT 1
90640: ARRAY
90641: PPUSH
90642: CALL_OW 250
90646: PPUSH
90647: LD_VAR 0 2
90651: PUSH
90652: LD_INT 1
90654: ARRAY
90655: PPUSH
90656: CALL_OW 251
90660: PPUSH
90661: LD_INT 12
90663: PPUSH
90664: LD_INT 1
90666: PPUSH
90667: CALL_OW 50
90671: GO 90685
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
90673: CALL_OW 45
90677: PPUSH
90678: LD_INT 1
90680: PPUSH
90681: CALL_OW 51
// end ;
90685: GO 90559
90687: POP
90688: POP
// end ;
90689: PPOPN 2
90691: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
90692: LD_EXP 117
90696: PUSH
90697: LD_EXP 163
90701: AND
90702: IFFALSE 90924
90704: GO 90706
90706: DISABLE
90707: LD_INT 0
90709: PPUSH
90710: PPUSH
90711: PPUSH
90712: PPUSH
90713: PPUSH
90714: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
90715: LD_ADDR_VAR 0 6
90719: PUSH
90720: LD_INT 22
90722: PUSH
90723: LD_OWVAR 2
90727: PUSH
90728: EMPTY
90729: LIST
90730: LIST
90731: PUSH
90732: LD_INT 21
90734: PUSH
90735: LD_INT 1
90737: PUSH
90738: EMPTY
90739: LIST
90740: LIST
90741: PUSH
90742: LD_INT 3
90744: PUSH
90745: LD_INT 23
90747: PUSH
90748: LD_INT 0
90750: PUSH
90751: EMPTY
90752: LIST
90753: LIST
90754: PUSH
90755: EMPTY
90756: LIST
90757: LIST
90758: PUSH
90759: EMPTY
90760: LIST
90761: LIST
90762: LIST
90763: PPUSH
90764: CALL_OW 69
90768: ST_TO_ADDR
// if not tmp then
90769: LD_VAR 0 6
90773: NOT
90774: IFFALSE 90778
// exit ;
90776: GO 90924
// s1 := rand ( 1 , 4 ) ;
90778: LD_ADDR_VAR 0 2
90782: PUSH
90783: LD_INT 1
90785: PPUSH
90786: LD_INT 4
90788: PPUSH
90789: CALL_OW 12
90793: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
90794: LD_ADDR_VAR 0 4
90798: PUSH
90799: LD_VAR 0 6
90803: PUSH
90804: LD_INT 1
90806: ARRAY
90807: PPUSH
90808: LD_VAR 0 2
90812: PPUSH
90813: CALL_OW 259
90817: ST_TO_ADDR
// if s1 = 1 then
90818: LD_VAR 0 2
90822: PUSH
90823: LD_INT 1
90825: EQUAL
90826: IFFALSE 90846
// s2 := rand ( 2 , 4 ) else
90828: LD_ADDR_VAR 0 3
90832: PUSH
90833: LD_INT 2
90835: PPUSH
90836: LD_INT 4
90838: PPUSH
90839: CALL_OW 12
90843: ST_TO_ADDR
90844: GO 90854
// s2 := 1 ;
90846: LD_ADDR_VAR 0 3
90850: PUSH
90851: LD_INT 1
90853: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
90854: LD_ADDR_VAR 0 5
90858: PUSH
90859: LD_VAR 0 6
90863: PUSH
90864: LD_INT 1
90866: ARRAY
90867: PPUSH
90868: LD_VAR 0 3
90872: PPUSH
90873: CALL_OW 259
90877: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
90878: LD_VAR 0 6
90882: PUSH
90883: LD_INT 1
90885: ARRAY
90886: PPUSH
90887: LD_VAR 0 2
90891: PPUSH
90892: LD_VAR 0 5
90896: PPUSH
90897: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
90901: LD_VAR 0 6
90905: PUSH
90906: LD_INT 1
90908: ARRAY
90909: PPUSH
90910: LD_VAR 0 3
90914: PPUSH
90915: LD_VAR 0 4
90919: PPUSH
90920: CALL_OW 237
// end ;
90924: PPOPN 6
90926: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
90927: LD_EXP 117
90931: PUSH
90932: LD_EXP 164
90936: AND
90937: IFFALSE 91016
90939: GO 90941
90941: DISABLE
90942: LD_INT 0
90944: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
90945: LD_ADDR_VAR 0 1
90949: PUSH
90950: LD_INT 22
90952: PUSH
90953: LD_OWVAR 2
90957: PUSH
90958: EMPTY
90959: LIST
90960: LIST
90961: PUSH
90962: LD_INT 30
90964: PUSH
90965: LD_INT 3
90967: PUSH
90968: EMPTY
90969: LIST
90970: LIST
90971: PUSH
90972: EMPTY
90973: LIST
90974: LIST
90975: PPUSH
90976: CALL_OW 69
90980: ST_TO_ADDR
// if not tmp then
90981: LD_VAR 0 1
90985: NOT
90986: IFFALSE 90990
// exit ;
90988: GO 91016
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90990: LD_VAR 0 1
90994: PUSH
90995: LD_INT 1
90997: PPUSH
90998: LD_VAR 0 1
91002: PPUSH
91003: CALL_OW 12
91007: ARRAY
91008: PPUSH
91009: LD_INT 1
91011: PPUSH
91012: CALL_OW 234
// end ;
91016: PPOPN 1
91018: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91019: LD_EXP 117
91023: PUSH
91024: LD_EXP 165
91028: AND
91029: IFFALSE 91141
91031: GO 91033
91033: DISABLE
91034: LD_INT 0
91036: PPUSH
91037: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91038: LD_ADDR_VAR 0 2
91042: PUSH
91043: LD_INT 22
91045: PUSH
91046: LD_OWVAR 2
91050: PUSH
91051: EMPTY
91052: LIST
91053: LIST
91054: PUSH
91055: LD_INT 2
91057: PUSH
91058: LD_INT 30
91060: PUSH
91061: LD_INT 27
91063: PUSH
91064: EMPTY
91065: LIST
91066: LIST
91067: PUSH
91068: LD_INT 30
91070: PUSH
91071: LD_INT 26
91073: PUSH
91074: EMPTY
91075: LIST
91076: LIST
91077: PUSH
91078: LD_INT 30
91080: PUSH
91081: LD_INT 28
91083: PUSH
91084: EMPTY
91085: LIST
91086: LIST
91087: PUSH
91088: EMPTY
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: PUSH
91094: EMPTY
91095: LIST
91096: LIST
91097: PPUSH
91098: CALL_OW 69
91102: ST_TO_ADDR
// if not tmp then
91103: LD_VAR 0 2
91107: NOT
91108: IFFALSE 91112
// exit ;
91110: GO 91141
// for i in tmp do
91112: LD_ADDR_VAR 0 1
91116: PUSH
91117: LD_VAR 0 2
91121: PUSH
91122: FOR_IN
91123: IFFALSE 91139
// SetLives ( i , 1 ) ;
91125: LD_VAR 0 1
91129: PPUSH
91130: LD_INT 1
91132: PPUSH
91133: CALL_OW 234
91137: GO 91122
91139: POP
91140: POP
// end ;
91141: PPOPN 2
91143: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91144: LD_EXP 117
91148: PUSH
91149: LD_EXP 166
91153: AND
91154: IFFALSE 91428
91156: GO 91158
91158: DISABLE
91159: LD_INT 0
91161: PPUSH
91162: PPUSH
91163: PPUSH
// begin i := rand ( 1 , 7 ) ;
91164: LD_ADDR_VAR 0 1
91168: PUSH
91169: LD_INT 1
91171: PPUSH
91172: LD_INT 7
91174: PPUSH
91175: CALL_OW 12
91179: ST_TO_ADDR
// case i of 1 :
91180: LD_VAR 0 1
91184: PUSH
91185: LD_INT 1
91187: DOUBLE
91188: EQUAL
91189: IFTRUE 91193
91191: GO 91203
91193: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91194: LD_STRING earthquake(getX(game), 0, 32)
91196: PPUSH
91197: CALL_OW 559
91201: GO 91428
91203: LD_INT 2
91205: DOUBLE
91206: EQUAL
91207: IFTRUE 91211
91209: GO 91225
91211: POP
// begin ToLua ( displayStucuk(); ) ;
91212: LD_STRING displayStucuk();
91214: PPUSH
91215: CALL_OW 559
// ResetFog ;
91219: CALL_OW 335
// end ; 3 :
91223: GO 91428
91225: LD_INT 3
91227: DOUBLE
91228: EQUAL
91229: IFTRUE 91233
91231: GO 91337
91233: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91234: LD_ADDR_VAR 0 2
91238: PUSH
91239: LD_INT 22
91241: PUSH
91242: LD_OWVAR 2
91246: PUSH
91247: EMPTY
91248: LIST
91249: LIST
91250: PUSH
91251: LD_INT 25
91253: PUSH
91254: LD_INT 1
91256: PUSH
91257: EMPTY
91258: LIST
91259: LIST
91260: PUSH
91261: EMPTY
91262: LIST
91263: LIST
91264: PPUSH
91265: CALL_OW 69
91269: ST_TO_ADDR
// if not tmp then
91270: LD_VAR 0 2
91274: NOT
91275: IFFALSE 91279
// exit ;
91277: GO 91428
// un := tmp [ rand ( 1 , tmp ) ] ;
91279: LD_ADDR_VAR 0 3
91283: PUSH
91284: LD_VAR 0 2
91288: PUSH
91289: LD_INT 1
91291: PPUSH
91292: LD_VAR 0 2
91296: PPUSH
91297: CALL_OW 12
91301: ARRAY
91302: ST_TO_ADDR
// if Crawls ( un ) then
91303: LD_VAR 0 3
91307: PPUSH
91308: CALL_OW 318
91312: IFFALSE 91323
// ComWalk ( un ) ;
91314: LD_VAR 0 3
91318: PPUSH
91319: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91323: LD_VAR 0 3
91327: PPUSH
91328: LD_INT 8
91330: PPUSH
91331: CALL_OW 336
// end ; 4 :
91335: GO 91428
91337: LD_INT 4
91339: DOUBLE
91340: EQUAL
91341: IFTRUE 91345
91343: GO 91406
91345: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
91346: LD_ADDR_VAR 0 2
91350: PUSH
91351: LD_INT 22
91353: PUSH
91354: LD_OWVAR 2
91358: PUSH
91359: EMPTY
91360: LIST
91361: LIST
91362: PUSH
91363: LD_INT 30
91365: PUSH
91366: LD_INT 29
91368: PUSH
91369: EMPTY
91370: LIST
91371: LIST
91372: PUSH
91373: EMPTY
91374: LIST
91375: LIST
91376: PPUSH
91377: CALL_OW 69
91381: ST_TO_ADDR
// if not tmp then
91382: LD_VAR 0 2
91386: NOT
91387: IFFALSE 91391
// exit ;
91389: GO 91428
// DestroyUnit ( tmp [ 1 ] ) ;
91391: LD_VAR 0 2
91395: PUSH
91396: LD_INT 1
91398: ARRAY
91399: PPUSH
91400: CALL_OW 65
// end ; 5 .. 7 :
91404: GO 91428
91406: LD_INT 5
91408: DOUBLE
91409: GREATEREQUAL
91410: IFFALSE 91418
91412: LD_INT 7
91414: DOUBLE
91415: LESSEQUAL
91416: IFTRUE 91420
91418: GO 91427
91420: POP
// StreamSibBomb ; end ;
91421: CALL 87678 0 0
91425: GO 91428
91427: POP
// end ;
91428: PPOPN 3
91430: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
91431: LD_EXP 117
91435: PUSH
91436: LD_EXP 167
91440: AND
91441: IFFALSE 91597
91443: GO 91445
91445: DISABLE
91446: LD_INT 0
91448: PPUSH
91449: PPUSH
91450: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
91451: LD_ADDR_VAR 0 2
91455: PUSH
91456: LD_INT 81
91458: PUSH
91459: LD_OWVAR 2
91463: PUSH
91464: EMPTY
91465: LIST
91466: LIST
91467: PUSH
91468: LD_INT 2
91470: PUSH
91471: LD_INT 21
91473: PUSH
91474: LD_INT 1
91476: PUSH
91477: EMPTY
91478: LIST
91479: LIST
91480: PUSH
91481: LD_INT 21
91483: PUSH
91484: LD_INT 2
91486: PUSH
91487: EMPTY
91488: LIST
91489: LIST
91490: PUSH
91491: EMPTY
91492: LIST
91493: LIST
91494: LIST
91495: PUSH
91496: EMPTY
91497: LIST
91498: LIST
91499: PPUSH
91500: CALL_OW 69
91504: ST_TO_ADDR
// if not tmp then
91505: LD_VAR 0 2
91509: NOT
91510: IFFALSE 91514
// exit ;
91512: GO 91597
// p := 0 ;
91514: LD_ADDR_VAR 0 3
91518: PUSH
91519: LD_INT 0
91521: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91522: LD_INT 35
91524: PPUSH
91525: CALL_OW 67
// p := p + 1 ;
91529: LD_ADDR_VAR 0 3
91533: PUSH
91534: LD_VAR 0 3
91538: PUSH
91539: LD_INT 1
91541: PLUS
91542: ST_TO_ADDR
// for i in tmp do
91543: LD_ADDR_VAR 0 1
91547: PUSH
91548: LD_VAR 0 2
91552: PUSH
91553: FOR_IN
91554: IFFALSE 91585
// if GetLives ( i ) < 1000 then
91556: LD_VAR 0 1
91560: PPUSH
91561: CALL_OW 256
91565: PUSH
91566: LD_INT 1000
91568: LESS
91569: IFFALSE 91583
// SetLives ( i , 1000 ) ;
91571: LD_VAR 0 1
91575: PPUSH
91576: LD_INT 1000
91578: PPUSH
91579: CALL_OW 234
91583: GO 91553
91585: POP
91586: POP
// until p > 20 ;
91587: LD_VAR 0 3
91591: PUSH
91592: LD_INT 20
91594: GREATER
91595: IFFALSE 91522
// end ;
91597: PPOPN 3
91599: END
// every 0 0$1 trigger StreamModeActive and sTime do
91600: LD_EXP 117
91604: PUSH
91605: LD_EXP 168
91609: AND
91610: IFFALSE 91645
91612: GO 91614
91614: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
91615: LD_INT 28
91617: PPUSH
91618: LD_OWVAR 2
91622: PPUSH
91623: LD_INT 2
91625: PPUSH
91626: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
91630: LD_INT 30
91632: PPUSH
91633: LD_OWVAR 2
91637: PPUSH
91638: LD_INT 2
91640: PPUSH
91641: CALL_OW 322
// end ;
91645: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
91646: LD_EXP 117
91650: PUSH
91651: LD_EXP 169
91655: AND
91656: IFFALSE 91777
91658: GO 91660
91660: DISABLE
91661: LD_INT 0
91663: PPUSH
91664: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91665: LD_ADDR_VAR 0 2
91669: PUSH
91670: LD_INT 22
91672: PUSH
91673: LD_OWVAR 2
91677: PUSH
91678: EMPTY
91679: LIST
91680: LIST
91681: PUSH
91682: LD_INT 21
91684: PUSH
91685: LD_INT 1
91687: PUSH
91688: EMPTY
91689: LIST
91690: LIST
91691: PUSH
91692: LD_INT 3
91694: PUSH
91695: LD_INT 23
91697: PUSH
91698: LD_INT 0
91700: PUSH
91701: EMPTY
91702: LIST
91703: LIST
91704: PUSH
91705: EMPTY
91706: LIST
91707: LIST
91708: PUSH
91709: EMPTY
91710: LIST
91711: LIST
91712: LIST
91713: PPUSH
91714: CALL_OW 69
91718: ST_TO_ADDR
// if not tmp then
91719: LD_VAR 0 2
91723: NOT
91724: IFFALSE 91728
// exit ;
91726: GO 91777
// for i in tmp do
91728: LD_ADDR_VAR 0 1
91732: PUSH
91733: LD_VAR 0 2
91737: PUSH
91738: FOR_IN
91739: IFFALSE 91775
// begin if Crawls ( i ) then
91741: LD_VAR 0 1
91745: PPUSH
91746: CALL_OW 318
91750: IFFALSE 91761
// ComWalk ( i ) ;
91752: LD_VAR 0 1
91756: PPUSH
91757: CALL_OW 138
// SetClass ( i , 2 ) ;
91761: LD_VAR 0 1
91765: PPUSH
91766: LD_INT 2
91768: PPUSH
91769: CALL_OW 336
// end ;
91773: GO 91738
91775: POP
91776: POP
// end ;
91777: PPOPN 2
91779: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
91780: LD_EXP 117
91784: PUSH
91785: LD_EXP 170
91789: AND
91790: IFFALSE 92071
91792: GO 91794
91794: DISABLE
91795: LD_INT 0
91797: PPUSH
91798: PPUSH
91799: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
91800: LD_OWVAR 2
91804: PPUSH
91805: LD_INT 9
91807: PPUSH
91808: LD_INT 1
91810: PPUSH
91811: LD_INT 1
91813: PPUSH
91814: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
91818: LD_INT 9
91820: PPUSH
91821: LD_OWVAR 2
91825: PPUSH
91826: CALL_OW 343
// uc_side := 9 ;
91830: LD_ADDR_OWVAR 20
91834: PUSH
91835: LD_INT 9
91837: ST_TO_ADDR
// uc_nation := 2 ;
91838: LD_ADDR_OWVAR 21
91842: PUSH
91843: LD_INT 2
91845: ST_TO_ADDR
// hc_name := Dark Warrior ;
91846: LD_ADDR_OWVAR 26
91850: PUSH
91851: LD_STRING Dark Warrior
91853: ST_TO_ADDR
// hc_gallery :=  ;
91854: LD_ADDR_OWVAR 33
91858: PUSH
91859: LD_STRING 
91861: ST_TO_ADDR
// hc_noskilllimit := true ;
91862: LD_ADDR_OWVAR 76
91866: PUSH
91867: LD_INT 1
91869: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
91870: LD_ADDR_OWVAR 31
91874: PUSH
91875: LD_INT 30
91877: PUSH
91878: LD_INT 30
91880: PUSH
91881: LD_INT 30
91883: PUSH
91884: LD_INT 30
91886: PUSH
91887: EMPTY
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: ST_TO_ADDR
// un := CreateHuman ;
91893: LD_ADDR_VAR 0 3
91897: PUSH
91898: CALL_OW 44
91902: ST_TO_ADDR
// hc_noskilllimit := false ;
91903: LD_ADDR_OWVAR 76
91907: PUSH
91908: LD_INT 0
91910: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
91911: LD_VAR 0 3
91915: PPUSH
91916: LD_INT 1
91918: PPUSH
91919: CALL_OW 51
// p := 0 ;
91923: LD_ADDR_VAR 0 2
91927: PUSH
91928: LD_INT 0
91930: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
91931: LD_INT 35
91933: PPUSH
91934: CALL_OW 67
// p := p + 1 ;
91938: LD_ADDR_VAR 0 2
91942: PUSH
91943: LD_VAR 0 2
91947: PUSH
91948: LD_INT 1
91950: PLUS
91951: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
91952: LD_VAR 0 3
91956: PPUSH
91957: CALL_OW 256
91961: PUSH
91962: LD_INT 1000
91964: LESS
91965: IFFALSE 91979
// SetLives ( un , 1000 ) ;
91967: LD_VAR 0 3
91971: PPUSH
91972: LD_INT 1000
91974: PPUSH
91975: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
91979: LD_VAR 0 3
91983: PPUSH
91984: LD_INT 81
91986: PUSH
91987: LD_OWVAR 2
91991: PUSH
91992: EMPTY
91993: LIST
91994: LIST
91995: PUSH
91996: LD_INT 91
91998: PUSH
91999: LD_VAR 0 3
92003: PUSH
92004: LD_INT 30
92006: PUSH
92007: EMPTY
92008: LIST
92009: LIST
92010: LIST
92011: PUSH
92012: EMPTY
92013: LIST
92014: LIST
92015: PPUSH
92016: CALL_OW 69
92020: PPUSH
92021: LD_VAR 0 3
92025: PPUSH
92026: CALL_OW 74
92030: PPUSH
92031: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92035: LD_VAR 0 2
92039: PUSH
92040: LD_INT 60
92042: GREATER
92043: PUSH
92044: LD_VAR 0 3
92048: PPUSH
92049: CALL_OW 301
92053: OR
92054: IFFALSE 91931
// if un then
92056: LD_VAR 0 3
92060: IFFALSE 92071
// RemoveUnit ( un ) ;
92062: LD_VAR 0 3
92066: PPUSH
92067: CALL_OW 64
// end ;
92071: PPOPN 3
92073: END
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
92074: LD_INT 0
92076: PPUSH
92077: PPUSH
92078: PPUSH
92079: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92080: LD_ADDR_VAR 0 4
92084: PUSH
92085: LD_INT 22
92087: PUSH
92088: LD_OWVAR 2
92092: PUSH
92093: EMPTY
92094: LIST
92095: LIST
92096: PUSH
92097: LD_INT 2
92099: PUSH
92100: LD_INT 30
92102: PUSH
92103: LD_INT 0
92105: PUSH
92106: EMPTY
92107: LIST
92108: LIST
92109: PUSH
92110: LD_INT 30
92112: PUSH
92113: LD_INT 1
92115: PUSH
92116: EMPTY
92117: LIST
92118: LIST
92119: PUSH
92120: EMPTY
92121: LIST
92122: LIST
92123: LIST
92124: PUSH
92125: EMPTY
92126: LIST
92127: LIST
92128: PPUSH
92129: CALL_OW 69
92133: ST_TO_ADDR
// if not tmp then
92134: LD_VAR 0 4
92138: NOT
92139: IFFALSE 92143
// exit ;
92141: GO 92202
// for i in tmp do
92143: LD_ADDR_VAR 0 2
92147: PUSH
92148: LD_VAR 0 4
92152: PUSH
92153: FOR_IN
92154: IFFALSE 92200
// for j = 1 to 3 do
92156: LD_ADDR_VAR 0 3
92160: PUSH
92161: DOUBLE
92162: LD_INT 1
92164: DEC
92165: ST_TO_ADDR
92166: LD_INT 3
92168: PUSH
92169: FOR_TO
92170: IFFALSE 92196
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
92172: LD_VAR 0 2
92176: PPUSH
92177: CALL_OW 274
92181: PPUSH
92182: LD_VAR 0 3
92186: PPUSH
92187: LD_INT 99999
92189: PPUSH
92190: CALL_OW 277
92194: GO 92169
92196: POP
92197: POP
92198: GO 92153
92200: POP
92201: POP
// end ;
92202: LD_VAR 0 1
92206: RET
// export function hHackSetLevel10 ; var i , j ; begin
92207: LD_INT 0
92209: PPUSH
92210: PPUSH
92211: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
92212: LD_ADDR_VAR 0 2
92216: PUSH
92217: LD_INT 21
92219: PUSH
92220: LD_INT 1
92222: PUSH
92223: EMPTY
92224: LIST
92225: LIST
92226: PPUSH
92227: CALL_OW 69
92231: PUSH
92232: FOR_IN
92233: IFFALSE 92285
// if IsSelected ( i ) then
92235: LD_VAR 0 2
92239: PPUSH
92240: CALL_OW 306
92244: IFFALSE 92283
// begin for j := 1 to 4 do
92246: LD_ADDR_VAR 0 3
92250: PUSH
92251: DOUBLE
92252: LD_INT 1
92254: DEC
92255: ST_TO_ADDR
92256: LD_INT 4
92258: PUSH
92259: FOR_TO
92260: IFFALSE 92281
// SetSkill ( i , j , 10 ) ;
92262: LD_VAR 0 2
92266: PPUSH
92267: LD_VAR 0 3
92271: PPUSH
92272: LD_INT 10
92274: PPUSH
92275: CALL_OW 237
92279: GO 92259
92281: POP
92282: POP
// end ;
92283: GO 92232
92285: POP
92286: POP
// end ;
92287: LD_VAR 0 1
92291: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
92292: LD_INT 0
92294: PPUSH
92295: PPUSH
92296: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
92297: LD_ADDR_VAR 0 2
92301: PUSH
92302: LD_INT 22
92304: PUSH
92305: LD_OWVAR 2
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: PUSH
92314: LD_INT 21
92316: PUSH
92317: LD_INT 1
92319: PUSH
92320: EMPTY
92321: LIST
92322: LIST
92323: PUSH
92324: EMPTY
92325: LIST
92326: LIST
92327: PPUSH
92328: CALL_OW 69
92332: PUSH
92333: FOR_IN
92334: IFFALSE 92375
// begin for j := 1 to 4 do
92336: LD_ADDR_VAR 0 3
92340: PUSH
92341: DOUBLE
92342: LD_INT 1
92344: DEC
92345: ST_TO_ADDR
92346: LD_INT 4
92348: PUSH
92349: FOR_TO
92350: IFFALSE 92371
// SetSkill ( i , j , 10 ) ;
92352: LD_VAR 0 2
92356: PPUSH
92357: LD_VAR 0 3
92361: PPUSH
92362: LD_INT 10
92364: PPUSH
92365: CALL_OW 237
92369: GO 92349
92371: POP
92372: POP
// end ;
92373: GO 92333
92375: POP
92376: POP
// end ;
92377: LD_VAR 0 1
92381: RET
// export function hHackSpawnHuman ( nation , class , skill ) ; begin
92382: LD_INT 0
92384: PPUSH
// uc_side := your_side ;
92385: LD_ADDR_OWVAR 20
92389: PUSH
92390: LD_OWVAR 2
92394: ST_TO_ADDR
// uc_nation := nation ;
92395: LD_ADDR_OWVAR 21
92399: PUSH
92400: LD_VAR 0 1
92404: ST_TO_ADDR
// InitHc ;
92405: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
92409: LD_INT 0
92411: PPUSH
92412: LD_VAR 0 2
92416: PPUSH
92417: LD_VAR 0 3
92421: PPUSH
92422: CALL_OW 380
// PlaceUnitAnywhere ( CreateHuman , true ) ;
92426: CALL_OW 44
92430: PPUSH
92431: LD_INT 1
92433: PPUSH
92434: CALL_OW 51
// end ;
92438: LD_VAR 0 4
92442: RET
// export function hHackSpawnVehicle ; begin
92443: LD_INT 0
92445: PPUSH
// uc_side := your_side ;
92446: LD_ADDR_OWVAR 20
92450: PUSH
92451: LD_OWVAR 2
92455: ST_TO_ADDR
// uc_nation := rand ( 1 , 3 ) ;
92456: LD_ADDR_OWVAR 21
92460: PUSH
92461: LD_INT 1
92463: PPUSH
92464: LD_INT 3
92466: PPUSH
92467: CALL_OW 12
92471: ST_TO_ADDR
// InitVc ;
92472: CALL_OW 20
// case uc_nation of 1 :
92476: LD_OWVAR 21
92480: PUSH
92481: LD_INT 1
92483: DOUBLE
92484: EQUAL
92485: IFTRUE 92489
92487: GO 92633
92489: POP
// begin vc_chassis := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] [ rand ( 1 , 5 ) ] ;
92490: LD_ADDR_OWVAR 37
92494: PUSH
92495: LD_INT 1
92497: PUSH
92498: LD_INT 2
92500: PUSH
92501: LD_INT 3
92503: PUSH
92504: LD_INT 4
92506: PUSH
92507: LD_INT 5
92509: PUSH
92510: EMPTY
92511: LIST
92512: LIST
92513: LIST
92514: LIST
92515: LIST
92516: PUSH
92517: LD_INT 1
92519: PPUSH
92520: LD_INT 5
92522: PPUSH
92523: CALL_OW 12
92527: ARRAY
92528: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
92529: LD_ADDR_OWVAR 39
92533: PUSH
92534: LD_INT 1
92536: PPUSH
92537: LD_INT 3
92539: PPUSH
92540: CALL_OW 12
92544: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_computer ] [ rand ( 1 , 3 ) ] ;
92545: LD_ADDR_OWVAR 38
92549: PUSH
92550: LD_INT 1
92552: PUSH
92553: LD_INT 2
92555: PUSH
92556: LD_INT 3
92558: PUSH
92559: EMPTY
92560: LIST
92561: LIST
92562: LIST
92563: PUSH
92564: LD_INT 1
92566: PPUSH
92567: LD_INT 3
92569: PPUSH
92570: CALL_OW 12
92574: ARRAY
92575: ST_TO_ADDR
// vc_weapon := [ us_machine_gun , us_gatling_gun , us_double_gun , us_light_gun , us_rocket_launcher , us_siberium_rocket , us_laser , us_double_laser , us_heavy_gun ] [ rand ( 1 , 9 ) ] ;
92576: LD_ADDR_OWVAR 40
92580: PUSH
92581: LD_INT 2
92583: PUSH
92584: LD_INT 4
92586: PUSH
92587: LD_INT 5
92589: PUSH
92590: LD_INT 3
92592: PUSH
92593: LD_INT 7
92595: PUSH
92596: LD_INT 8
92598: PUSH
92599: LD_INT 9
92601: PUSH
92602: LD_INT 10
92604: PUSH
92605: LD_INT 6
92607: PUSH
92608: EMPTY
92609: LIST
92610: LIST
92611: LIST
92612: LIST
92613: LIST
92614: LIST
92615: LIST
92616: LIST
92617: LIST
92618: PUSH
92619: LD_INT 1
92621: PPUSH
92622: LD_INT 9
92624: PPUSH
92625: CALL_OW 12
92629: ARRAY
92630: ST_TO_ADDR
// end ; 2 :
92631: GO 92898
92633: LD_INT 2
92635: DOUBLE
92636: EQUAL
92637: IFTRUE 92641
92639: GO 92765
92641: POP
// begin vc_chassis := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 4 ) ] ;
92642: LD_ADDR_OWVAR 37
92646: PUSH
92647: LD_INT 11
92649: PUSH
92650: LD_INT 12
92652: PUSH
92653: LD_INT 13
92655: PUSH
92656: LD_INT 14
92658: PUSH
92659: EMPTY
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: PUSH
92665: LD_INT 1
92667: PPUSH
92668: LD_INT 4
92670: PPUSH
92671: CALL_OW 12
92675: ARRAY
92676: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
92677: LD_ADDR_OWVAR 39
92681: PUSH
92682: LD_INT 1
92684: PPUSH
92685: LD_INT 3
92687: PPUSH
92688: CALL_OW 12
92692: ST_TO_ADDR
// vc_control := [ control_manual , control_remote , control_apeman ] [ rand ( 1 , 3 ) ] ;
92693: LD_ADDR_OWVAR 38
92697: PUSH
92698: LD_INT 1
92700: PUSH
92701: LD_INT 2
92703: PUSH
92704: LD_INT 5
92706: PUSH
92707: EMPTY
92708: LIST
92709: LIST
92710: LIST
92711: PUSH
92712: LD_INT 1
92714: PPUSH
92715: LD_INT 3
92717: PPUSH
92718: CALL_OW 12
92722: ARRAY
92723: ST_TO_ADDR
// vc_weapon := [ ar_double_machine_gun , ar_flame_thrower , ar_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 5 ) ] ;
92724: LD_ADDR_OWVAR 40
92728: PUSH
92729: LD_INT 24
92731: PUSH
92732: LD_INT 26
92734: PUSH
92735: LD_INT 27
92737: PUSH
92738: LD_INT 28
92740: PUSH
92741: LD_INT 29
92743: PUSH
92744: EMPTY
92745: LIST
92746: LIST
92747: LIST
92748: LIST
92749: LIST
92750: PUSH
92751: LD_INT 1
92753: PPUSH
92754: LD_INT 5
92756: PPUSH
92757: CALL_OW 12
92761: ARRAY
92762: ST_TO_ADDR
// end ; 3 :
92763: GO 92898
92765: LD_INT 3
92767: DOUBLE
92768: EQUAL
92769: IFTRUE 92773
92771: GO 92897
92773: POP
// begin vc_chassis := [ ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] [ rand ( 1 , 4 ) ] ;
92774: LD_ADDR_OWVAR 37
92778: PUSH
92779: LD_INT 21
92781: PUSH
92782: LD_INT 23
92784: PUSH
92785: LD_INT 22
92787: PUSH
92788: LD_INT 24
92790: PUSH
92791: EMPTY
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: PUSH
92797: LD_INT 1
92799: PPUSH
92800: LD_INT 4
92802: PPUSH
92803: CALL_OW 12
92807: ARRAY
92808: ST_TO_ADDR
// vc_engine := rand ( 1 , 3 ) ;
92809: LD_ADDR_OWVAR 39
92813: PUSH
92814: LD_INT 1
92816: PPUSH
92817: LD_INT 3
92819: PPUSH
92820: CALL_OW 12
92824: ST_TO_ADDR
// vc_control := [ control_manual , control_computer ] [ rand ( 1 , 2 ) ] ;
92825: LD_ADDR_OWVAR 38
92829: PUSH
92830: LD_INT 1
92832: PUSH
92833: LD_INT 3
92835: PUSH
92836: EMPTY
92837: LIST
92838: LIST
92839: PUSH
92840: LD_INT 1
92842: PPUSH
92843: LD_INT 2
92845: PPUSH
92846: CALL_OW 12
92850: ARRAY
92851: ST_TO_ADDR
// vc_weapon := [ ru_heavy_machine_gun , ru_gatling_gun , ru_gun , ru_heavy_gun , ru_siberium_rocket , ru_rocket ] [ rand ( 1 , 6 ) ] ;
92852: LD_ADDR_OWVAR 40
92856: PUSH
92857: LD_INT 42
92859: PUSH
92860: LD_INT 43
92862: PUSH
92863: LD_INT 44
92865: PUSH
92866: LD_INT 46
92868: PUSH
92869: LD_INT 48
92871: PUSH
92872: LD_INT 47
92874: PUSH
92875: EMPTY
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: PUSH
92883: LD_INT 1
92885: PPUSH
92886: LD_INT 6
92888: PPUSH
92889: CALL_OW 12
92893: ARRAY
92894: ST_TO_ADDR
// end ; end ;
92895: GO 92898
92897: POP
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
92898: CALL_OW 45
92902: PPUSH
92903: LD_INT 1
92905: PPUSH
92906: CALL_OW 51
// end ;
92910: LD_VAR 0 1
92914: RET
// export hInvincible ; every 1 do
92915: GO 92917
92917: DISABLE
// hInvincible := [ ] ;
92918: LD_ADDR_EXP 171
92922: PUSH
92923: EMPTY
92924: ST_TO_ADDR
92925: END
// every 10 do var i ;
92926: GO 92928
92928: DISABLE
92929: LD_INT 0
92931: PPUSH
// begin enable ;
92932: ENABLE
// if not hInvincible then
92933: LD_EXP 171
92937: NOT
92938: IFFALSE 92942
// exit ;
92940: GO 92986
// for i in hInvincible do
92942: LD_ADDR_VAR 0 1
92946: PUSH
92947: LD_EXP 171
92951: PUSH
92952: FOR_IN
92953: IFFALSE 92984
// if GetLives ( i ) < 1000 then
92955: LD_VAR 0 1
92959: PPUSH
92960: CALL_OW 256
92964: PUSH
92965: LD_INT 1000
92967: LESS
92968: IFFALSE 92982
// SetLives ( i , 1000 ) ;
92970: LD_VAR 0 1
92974: PPUSH
92975: LD_INT 1000
92977: PPUSH
92978: CALL_OW 234
92982: GO 92952
92984: POP
92985: POP
// end ;
92986: PPOPN 1
92988: END
// export function hHackInvincible ; var i ; begin
92989: LD_INT 0
92991: PPUSH
92992: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
92993: LD_ADDR_VAR 0 2
92997: PUSH
92998: LD_INT 2
93000: PUSH
93001: LD_INT 21
93003: PUSH
93004: LD_INT 1
93006: PUSH
93007: EMPTY
93008: LIST
93009: LIST
93010: PUSH
93011: LD_INT 21
93013: PUSH
93014: LD_INT 2
93016: PUSH
93017: EMPTY
93018: LIST
93019: LIST
93020: PUSH
93021: EMPTY
93022: LIST
93023: LIST
93024: LIST
93025: PPUSH
93026: CALL_OW 69
93030: PUSH
93031: FOR_IN
93032: IFFALSE 93093
// if IsSelected ( i ) then
93034: LD_VAR 0 2
93038: PPUSH
93039: CALL_OW 306
93043: IFFALSE 93091
// begin if i in hInvincible then
93045: LD_VAR 0 2
93049: PUSH
93050: LD_EXP 171
93054: IN
93055: IFFALSE 93075
// hInvincible := hInvincible diff i else
93057: LD_ADDR_EXP 171
93061: PUSH
93062: LD_EXP 171
93066: PUSH
93067: LD_VAR 0 2
93071: DIFF
93072: ST_TO_ADDR
93073: GO 93091
// hInvincible := hInvincible union i ;
93075: LD_ADDR_EXP 171
93079: PUSH
93080: LD_EXP 171
93084: PUSH
93085: LD_VAR 0 2
93089: UNION
93090: ST_TO_ADDR
// end ;
93091: GO 93031
93093: POP
93094: POP
// end ;
93095: LD_VAR 0 1
93099: RET
// export function hHackInvisible ; var i , j ; begin
93100: LD_INT 0
93102: PPUSH
93103: PPUSH
93104: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93105: LD_ADDR_VAR 0 2
93109: PUSH
93110: LD_INT 21
93112: PUSH
93113: LD_INT 1
93115: PUSH
93116: EMPTY
93117: LIST
93118: LIST
93119: PPUSH
93120: CALL_OW 69
93124: PUSH
93125: FOR_IN
93126: IFFALSE 93150
// if IsSelected ( i ) then
93128: LD_VAR 0 2
93132: PPUSH
93133: CALL_OW 306
93137: IFFALSE 93148
// ComForceInvisible ( i ) ;
93139: LD_VAR 0 2
93143: PPUSH
93144: CALL_OW 496
93148: GO 93125
93150: POP
93151: POP
// end ;
93152: LD_VAR 0 1
93156: RET
// export function hHackChangeYourSide ; begin
93157: LD_INT 0
93159: PPUSH
// if your_side = 8 then
93160: LD_OWVAR 2
93164: PUSH
93165: LD_INT 8
93167: EQUAL
93168: IFFALSE 93180
// your_side := 0 else
93170: LD_ADDR_OWVAR 2
93174: PUSH
93175: LD_INT 0
93177: ST_TO_ADDR
93178: GO 93194
// your_side := your_side + 1 ;
93180: LD_ADDR_OWVAR 2
93184: PUSH
93185: LD_OWVAR 2
93189: PUSH
93190: LD_INT 1
93192: PLUS
93193: ST_TO_ADDR
// end ;
93194: LD_VAR 0 1
93198: RET
// export function hHackChangeUnitSide ; var i , j ; begin
93199: LD_INT 0
93201: PPUSH
93202: PPUSH
93203: PPUSH
// for i in all_units do
93204: LD_ADDR_VAR 0 2
93208: PUSH
93209: LD_OWVAR 3
93213: PUSH
93214: FOR_IN
93215: IFFALSE 93293
// if IsSelected ( i ) then
93217: LD_VAR 0 2
93221: PPUSH
93222: CALL_OW 306
93226: IFFALSE 93291
// begin j := GetSide ( i ) ;
93228: LD_ADDR_VAR 0 3
93232: PUSH
93233: LD_VAR 0 2
93237: PPUSH
93238: CALL_OW 255
93242: ST_TO_ADDR
// if j = 8 then
93243: LD_VAR 0 3
93247: PUSH
93248: LD_INT 8
93250: EQUAL
93251: IFFALSE 93263
// j := 0 else
93253: LD_ADDR_VAR 0 3
93257: PUSH
93258: LD_INT 0
93260: ST_TO_ADDR
93261: GO 93277
// j := j + 1 ;
93263: LD_ADDR_VAR 0 3
93267: PUSH
93268: LD_VAR 0 3
93272: PUSH
93273: LD_INT 1
93275: PLUS
93276: ST_TO_ADDR
// SetSide ( i , j ) ;
93277: LD_VAR 0 2
93281: PPUSH
93282: LD_VAR 0 3
93286: PPUSH
93287: CALL_OW 235
// end ;
93291: GO 93214
93293: POP
93294: POP
// end ;
93295: LD_VAR 0 1
93299: RET
// export function hHackFog ; begin
93300: LD_INT 0
93302: PPUSH
// FogOff ( true ) ;
93303: LD_INT 1
93305: PPUSH
93306: CALL_OW 344
// end ;
93310: LD_VAR 0 1
93314: RET
// export function hHackApeman ; begin
93315: LD_INT 0
93317: PPUSH
// uc_side := your_side ;
93318: LD_ADDR_OWVAR 20
93322: PUSH
93323: LD_OWVAR 2
93327: ST_TO_ADDR
// uc_nation := 0 ;
93328: LD_ADDR_OWVAR 21
93332: PUSH
93333: LD_INT 0
93335: ST_TO_ADDR
// hc_name :=  ;
93336: LD_ADDR_OWVAR 26
93340: PUSH
93341: LD_STRING 
93343: ST_TO_ADDR
// hc_gallery :=  ;
93344: LD_ADDR_OWVAR 33
93348: PUSH
93349: LD_STRING 
93351: ST_TO_ADDR
// hc_skills := [ 0 , 0 , 0 , 0 ] ;
93352: LD_ADDR_OWVAR 31
93356: PUSH
93357: LD_INT 0
93359: PUSH
93360: LD_INT 0
93362: PUSH
93363: LD_INT 0
93365: PUSH
93366: LD_INT 0
93368: PUSH
93369: EMPTY
93370: LIST
93371: LIST
93372: LIST
93373: LIST
93374: ST_TO_ADDR
// hc_class := class_apeman ;
93375: LD_ADDR_OWVAR 28
93379: PUSH
93380: LD_INT 12
93382: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateHuman , true ) ;
93383: CALL_OW 44
93387: PPUSH
93388: LD_INT 1
93390: PPUSH
93391: CALL_OW 51
// end ;
93395: LD_VAR 0 1
93399: RET
// export function hHackBoom ; begin
93400: LD_INT 0
93402: PPUSH
// uc_side := your_side ;
93403: LD_ADDR_OWVAR 20
93407: PUSH
93408: LD_OWVAR 2
93412: ST_TO_ADDR
// uc_nation := 1 ;
93413: LD_ADDR_OWVAR 21
93417: PUSH
93418: LD_INT 1
93420: ST_TO_ADDR
// vc_chassis := us_morphling ;
93421: LD_ADDR_OWVAR 37
93425: PUSH
93426: LD_INT 5
93428: ST_TO_ADDR
// vc_engine := engine_siberite ;
93429: LD_ADDR_OWVAR 39
93433: PUSH
93434: LD_INT 3
93436: ST_TO_ADDR
// vc_control := control_computer ;
93437: LD_ADDR_OWVAR 38
93441: PUSH
93442: LD_INT 3
93444: ST_TO_ADDR
// vc_weapon := us_siberium_rocket ;
93445: LD_ADDR_OWVAR 40
93449: PUSH
93450: LD_INT 8
93452: ST_TO_ADDR
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
93453: CALL_OW 45
93457: PPUSH
93458: LD_INT 1
93460: PPUSH
93461: CALL_OW 51
// end ; end_of_file
93465: LD_VAR 0 1
93469: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
93470: LD_INT 0
93472: PPUSH
93473: PPUSH
93474: PPUSH
93475: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
93476: LD_VAR 0 1
93480: PPUSH
93481: CALL_OW 264
93485: PUSH
93486: LD_EXP 106
93490: EQUAL
93491: IFFALSE 93563
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
93493: LD_INT 68
93495: PPUSH
93496: LD_VAR 0 1
93500: PPUSH
93501: CALL_OW 255
93505: PPUSH
93506: CALL_OW 321
93510: PUSH
93511: LD_INT 2
93513: EQUAL
93514: IFFALSE 93526
// eff := 70 else
93516: LD_ADDR_VAR 0 4
93520: PUSH
93521: LD_INT 70
93523: ST_TO_ADDR
93524: GO 93534
// eff := 30 ;
93526: LD_ADDR_VAR 0 4
93530: PUSH
93531: LD_INT 30
93533: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
93534: LD_VAR 0 1
93538: PPUSH
93539: CALL_OW 250
93543: PPUSH
93544: LD_VAR 0 1
93548: PPUSH
93549: CALL_OW 251
93553: PPUSH
93554: LD_VAR 0 4
93558: PPUSH
93559: CALL_OW 495
// end ; end ;
93563: LD_VAR 0 2
93567: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
93568: LD_INT 0
93570: PPUSH
// end ;
93571: LD_VAR 0 4
93575: RET
// export function SOS_Command ( cmd ) ; begin
93576: LD_INT 0
93578: PPUSH
// end ;
93579: LD_VAR 0 2
93583: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y ) do begin if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
93584: LD_VAR 0 1
93588: PUSH
93589: LD_INT 254
93591: EQUAL
93592: PUSH
93593: LD_VAR 0 2
93597: PPUSH
93598: CALL_OW 264
93602: PUSH
93603: LD_EXP 104
93607: EQUAL
93608: AND
93609: PUSH
93610: LD_VAR 0 3
93614: PPUSH
93615: CALL_OW 263
93619: PUSH
93620: LD_INT 3
93622: EQUAL
93623: AND
93624: IFFALSE 93640
// HackDestroyVehicle ( unit , selectedUnit ) ;
93626: LD_VAR 0 2
93630: PPUSH
93631: LD_VAR 0 3
93635: PPUSH
93636: CALL 95147 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
93640: LD_VAR 0 1
93644: PUSH
93645: LD_INT 255
93647: EQUAL
93648: PUSH
93649: LD_VAR 0 2
93653: PPUSH
93654: CALL_OW 264
93658: PUSH
93659: LD_INT 14
93661: PUSH
93662: LD_INT 53
93664: PUSH
93665: EMPTY
93666: LIST
93667: LIST
93668: IN
93669: AND
93670: PUSH
93671: LD_VAR 0 4
93675: PPUSH
93676: LD_VAR 0 5
93680: PPUSH
93681: CALL_OW 488
93685: AND
93686: IFFALSE 93710
// CutTreeXYR ( unit , x , y , 12 ) ;
93688: LD_VAR 0 2
93692: PPUSH
93693: LD_VAR 0 4
93697: PPUSH
93698: LD_VAR 0 5
93702: PPUSH
93703: LD_INT 12
93705: PPUSH
93706: CALL 93713 0 4
// end ;
93710: PPOPN 5
93712: END
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
93713: LD_INT 0
93715: PPUSH
93716: PPUSH
93717: PPUSH
93718: PPUSH
93719: PPUSH
93720: PPUSH
93721: PPUSH
93722: PPUSH
93723: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
93724: LD_VAR 0 1
93728: NOT
93729: PUSH
93730: LD_VAR 0 2
93734: PPUSH
93735: LD_VAR 0 3
93739: PPUSH
93740: CALL_OW 488
93744: NOT
93745: OR
93746: PUSH
93747: LD_VAR 0 4
93751: NOT
93752: OR
93753: IFFALSE 93757
// exit ;
93755: GO 94097
// list := [ ] ;
93757: LD_ADDR_VAR 0 13
93761: PUSH
93762: EMPTY
93763: ST_TO_ADDR
// if x - r < 0 then
93764: LD_VAR 0 2
93768: PUSH
93769: LD_VAR 0 4
93773: MINUS
93774: PUSH
93775: LD_INT 0
93777: LESS
93778: IFFALSE 93790
// min_x := 0 else
93780: LD_ADDR_VAR 0 7
93784: PUSH
93785: LD_INT 0
93787: ST_TO_ADDR
93788: GO 93806
// min_x := x - r ;
93790: LD_ADDR_VAR 0 7
93794: PUSH
93795: LD_VAR 0 2
93799: PUSH
93800: LD_VAR 0 4
93804: MINUS
93805: ST_TO_ADDR
// if y - r < 0 then
93806: LD_VAR 0 3
93810: PUSH
93811: LD_VAR 0 4
93815: MINUS
93816: PUSH
93817: LD_INT 0
93819: LESS
93820: IFFALSE 93832
// min_y := 0 else
93822: LD_ADDR_VAR 0 8
93826: PUSH
93827: LD_INT 0
93829: ST_TO_ADDR
93830: GO 93848
// min_y := y - r ;
93832: LD_ADDR_VAR 0 8
93836: PUSH
93837: LD_VAR 0 3
93841: PUSH
93842: LD_VAR 0 4
93846: MINUS
93847: ST_TO_ADDR
// max_x := x + r ;
93848: LD_ADDR_VAR 0 9
93852: PUSH
93853: LD_VAR 0 2
93857: PUSH
93858: LD_VAR 0 4
93862: PLUS
93863: ST_TO_ADDR
// max_y := y + r ;
93864: LD_ADDR_VAR 0 10
93868: PUSH
93869: LD_VAR 0 3
93873: PUSH
93874: LD_VAR 0 4
93878: PLUS
93879: ST_TO_ADDR
// for _x = min_x to max_x do
93880: LD_ADDR_VAR 0 11
93884: PUSH
93885: DOUBLE
93886: LD_VAR 0 7
93890: DEC
93891: ST_TO_ADDR
93892: LD_VAR 0 9
93896: PUSH
93897: FOR_TO
93898: IFFALSE 94015
// for _y = min_y to max_y do
93900: LD_ADDR_VAR 0 12
93904: PUSH
93905: DOUBLE
93906: LD_VAR 0 8
93910: DEC
93911: ST_TO_ADDR
93912: LD_VAR 0 10
93916: PUSH
93917: FOR_TO
93918: IFFALSE 94011
// begin if not ValidHex ( _x , _y ) then
93920: LD_VAR 0 11
93924: PPUSH
93925: LD_VAR 0 12
93929: PPUSH
93930: CALL_OW 488
93934: NOT
93935: IFFALSE 93939
// continue ;
93937: GO 93917
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
93939: LD_VAR 0 11
93943: PPUSH
93944: LD_VAR 0 12
93948: PPUSH
93949: CALL_OW 351
93953: PUSH
93954: LD_VAR 0 11
93958: PPUSH
93959: LD_VAR 0 12
93963: PPUSH
93964: CALL_OW 554
93968: AND
93969: IFFALSE 94009
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
93971: LD_ADDR_VAR 0 13
93975: PUSH
93976: LD_VAR 0 13
93980: PPUSH
93981: LD_VAR 0 13
93985: PUSH
93986: LD_INT 1
93988: PLUS
93989: PPUSH
93990: LD_VAR 0 11
93994: PUSH
93995: LD_VAR 0 12
93999: PUSH
94000: EMPTY
94001: LIST
94002: LIST
94003: PPUSH
94004: CALL_OW 2
94008: ST_TO_ADDR
// end ;
94009: GO 93917
94011: POP
94012: POP
94013: GO 93897
94015: POP
94016: POP
// if not list then
94017: LD_VAR 0 13
94021: NOT
94022: IFFALSE 94026
// exit ;
94024: GO 94097
// for i in list do
94026: LD_ADDR_VAR 0 6
94030: PUSH
94031: LD_VAR 0 13
94035: PUSH
94036: FOR_IN
94037: IFFALSE 94095
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
94039: LD_VAR 0 1
94043: PPUSH
94044: LD_STRING M
94046: PUSH
94047: LD_VAR 0 6
94051: PUSH
94052: LD_INT 1
94054: ARRAY
94055: PUSH
94056: LD_VAR 0 6
94060: PUSH
94061: LD_INT 2
94063: ARRAY
94064: PUSH
94065: LD_INT 0
94067: PUSH
94068: LD_INT 0
94070: PUSH
94071: LD_INT 0
94073: PUSH
94074: LD_INT 0
94076: PUSH
94077: EMPTY
94078: LIST
94079: LIST
94080: LIST
94081: LIST
94082: LIST
94083: LIST
94084: LIST
94085: PUSH
94086: EMPTY
94087: LIST
94088: PPUSH
94089: CALL_OW 447
94093: GO 94036
94095: POP
94096: POP
// end ;
94097: LD_VAR 0 5
94101: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
94102: LD_EXP 172
94106: NOT
94107: IFFALSE 94157
94109: GO 94111
94111: DISABLE
// begin initHack := true ;
94112: LD_ADDR_EXP 172
94116: PUSH
94117: LD_INT 1
94119: ST_TO_ADDR
// hackTanks := [ ] ;
94120: LD_ADDR_EXP 173
94124: PUSH
94125: EMPTY
94126: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
94127: LD_ADDR_EXP 174
94131: PUSH
94132: EMPTY
94133: ST_TO_ADDR
// hackLimit := 3 ;
94134: LD_ADDR_EXP 175
94138: PUSH
94139: LD_INT 3
94141: ST_TO_ADDR
// hackDist := 12 ;
94142: LD_ADDR_EXP 176
94146: PUSH
94147: LD_INT 12
94149: ST_TO_ADDR
// hackCounter := [ ] ;
94150: LD_ADDR_EXP 177
94154: PUSH
94155: EMPTY
94156: ST_TO_ADDR
// end ;
94157: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
94158: LD_EXP 172
94162: PUSH
94163: LD_INT 34
94165: PUSH
94166: LD_EXP 104
94170: PUSH
94171: EMPTY
94172: LIST
94173: LIST
94174: PPUSH
94175: CALL_OW 69
94179: AND
94180: IFFALSE 94435
94182: GO 94184
94184: DISABLE
94185: LD_INT 0
94187: PPUSH
94188: PPUSH
// begin enable ;
94189: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
94190: LD_ADDR_VAR 0 1
94194: PUSH
94195: LD_INT 34
94197: PUSH
94198: LD_EXP 104
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PPUSH
94207: CALL_OW 69
94211: PUSH
94212: FOR_IN
94213: IFFALSE 94433
// begin if not i in hackTanks then
94215: LD_VAR 0 1
94219: PUSH
94220: LD_EXP 173
94224: IN
94225: NOT
94226: IFFALSE 94309
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
94228: LD_ADDR_EXP 173
94232: PUSH
94233: LD_EXP 173
94237: PPUSH
94238: LD_EXP 173
94242: PUSH
94243: LD_INT 1
94245: PLUS
94246: PPUSH
94247: LD_VAR 0 1
94251: PPUSH
94252: CALL_OW 1
94256: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
94257: LD_ADDR_EXP 174
94261: PUSH
94262: LD_EXP 174
94266: PPUSH
94267: LD_EXP 174
94271: PUSH
94272: LD_INT 1
94274: PLUS
94275: PPUSH
94276: EMPTY
94277: PPUSH
94278: CALL_OW 1
94282: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
94283: LD_ADDR_EXP 177
94287: PUSH
94288: LD_EXP 177
94292: PPUSH
94293: LD_EXP 177
94297: PUSH
94298: LD_INT 1
94300: PLUS
94301: PPUSH
94302: EMPTY
94303: PPUSH
94304: CALL_OW 1
94308: ST_TO_ADDR
// end ; if not IsOk ( i ) then
94309: LD_VAR 0 1
94313: PPUSH
94314: CALL_OW 302
94318: NOT
94319: IFFALSE 94332
// begin HackUnlinkAll ( i ) ;
94321: LD_VAR 0 1
94325: PPUSH
94326: CALL 94438 0 1
// continue ;
94330: GO 94212
// end ; HackCheckCapturedStatus ( i ) ;
94332: LD_VAR 0 1
94336: PPUSH
94337: CALL 94881 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
94341: LD_ADDR_VAR 0 2
94345: PUSH
94346: LD_INT 81
94348: PUSH
94349: LD_VAR 0 1
94353: PPUSH
94354: CALL_OW 255
94358: PUSH
94359: EMPTY
94360: LIST
94361: LIST
94362: PUSH
94363: LD_INT 33
94365: PUSH
94366: LD_INT 3
94368: PUSH
94369: EMPTY
94370: LIST
94371: LIST
94372: PUSH
94373: LD_INT 91
94375: PUSH
94376: LD_VAR 0 1
94380: PUSH
94381: LD_EXP 176
94385: PUSH
94386: EMPTY
94387: LIST
94388: LIST
94389: LIST
94390: PUSH
94391: LD_INT 50
94393: PUSH
94394: EMPTY
94395: LIST
94396: PUSH
94397: EMPTY
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: PPUSH
94403: CALL_OW 69
94407: ST_TO_ADDR
// if not tmp then
94408: LD_VAR 0 2
94412: NOT
94413: IFFALSE 94417
// continue ;
94415: GO 94212
// HackLink ( i , tmp ) ;
94417: LD_VAR 0 1
94421: PPUSH
94422: LD_VAR 0 2
94426: PPUSH
94427: CALL 94574 0 2
// end ;
94431: GO 94212
94433: POP
94434: POP
// end ;
94435: PPOPN 2
94437: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
94438: LD_INT 0
94440: PPUSH
94441: PPUSH
94442: PPUSH
// if not hack in hackTanks then
94443: LD_VAR 0 1
94447: PUSH
94448: LD_EXP 173
94452: IN
94453: NOT
94454: IFFALSE 94458
// exit ;
94456: GO 94569
// index := GetElementIndex ( hackTanks , hack ) ;
94458: LD_ADDR_VAR 0 4
94462: PUSH
94463: LD_EXP 173
94467: PPUSH
94468: LD_VAR 0 1
94472: PPUSH
94473: CALL 19023 0 2
94477: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
94478: LD_EXP 174
94482: PUSH
94483: LD_VAR 0 4
94487: ARRAY
94488: IFFALSE 94569
// begin for i in hackTanksCaptured [ index ] do
94490: LD_ADDR_VAR 0 3
94494: PUSH
94495: LD_EXP 174
94499: PUSH
94500: LD_VAR 0 4
94504: ARRAY
94505: PUSH
94506: FOR_IN
94507: IFFALSE 94533
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
94509: LD_VAR 0 3
94513: PUSH
94514: LD_INT 1
94516: ARRAY
94517: PPUSH
94518: LD_VAR 0 3
94522: PUSH
94523: LD_INT 2
94525: ARRAY
94526: PPUSH
94527: CALL_OW 235
94531: GO 94506
94533: POP
94534: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
94535: LD_ADDR_EXP 174
94539: PUSH
94540: LD_EXP 174
94544: PPUSH
94545: LD_VAR 0 4
94549: PPUSH
94550: EMPTY
94551: PPUSH
94552: CALL_OW 1
94556: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
94557: LD_VAR 0 1
94561: PPUSH
94562: LD_INT 0
94564: PPUSH
94565: CALL_OW 505
// end ; end ;
94569: LD_VAR 0 2
94573: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
94574: LD_INT 0
94576: PPUSH
94577: PPUSH
94578: PPUSH
// if not hack in hackTanks or not vehicles then
94579: LD_VAR 0 1
94583: PUSH
94584: LD_EXP 173
94588: IN
94589: NOT
94590: PUSH
94591: LD_VAR 0 2
94595: NOT
94596: OR
94597: IFFALSE 94601
// exit ;
94599: GO 94876
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
94601: LD_ADDR_VAR 0 2
94605: PUSH
94606: LD_VAR 0 1
94610: PPUSH
94611: LD_VAR 0 2
94615: PPUSH
94616: LD_INT 1
94618: PPUSH
94619: LD_INT 1
94621: PPUSH
94622: CALL 19673 0 4
94626: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
94627: LD_ADDR_VAR 0 5
94631: PUSH
94632: LD_EXP 173
94636: PPUSH
94637: LD_VAR 0 1
94641: PPUSH
94642: CALL 19023 0 2
94646: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
94647: LD_EXP 174
94651: PUSH
94652: LD_VAR 0 5
94656: ARRAY
94657: PUSH
94658: LD_EXP 175
94662: LESS
94663: IFFALSE 94852
// begin for i := 1 to vehicles do
94665: LD_ADDR_VAR 0 4
94669: PUSH
94670: DOUBLE
94671: LD_INT 1
94673: DEC
94674: ST_TO_ADDR
94675: LD_VAR 0 2
94679: PUSH
94680: FOR_TO
94681: IFFALSE 94850
// begin if hackTanksCaptured [ index ] = hackLimit then
94683: LD_EXP 174
94687: PUSH
94688: LD_VAR 0 5
94692: ARRAY
94693: PUSH
94694: LD_EXP 175
94698: EQUAL
94699: IFFALSE 94703
// break ;
94701: GO 94850
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
94703: LD_ADDR_EXP 177
94707: PUSH
94708: LD_EXP 177
94712: PPUSH
94713: LD_VAR 0 5
94717: PPUSH
94718: LD_EXP 177
94722: PUSH
94723: LD_VAR 0 5
94727: ARRAY
94728: PUSH
94729: LD_INT 1
94731: PLUS
94732: PPUSH
94733: CALL_OW 1
94737: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
94738: LD_ADDR_EXP 174
94742: PUSH
94743: LD_EXP 174
94747: PPUSH
94748: LD_VAR 0 5
94752: PUSH
94753: LD_EXP 174
94757: PUSH
94758: LD_VAR 0 5
94762: ARRAY
94763: PUSH
94764: LD_INT 1
94766: PLUS
94767: PUSH
94768: EMPTY
94769: LIST
94770: LIST
94771: PPUSH
94772: LD_VAR 0 2
94776: PUSH
94777: LD_VAR 0 4
94781: ARRAY
94782: PUSH
94783: LD_VAR 0 2
94787: PUSH
94788: LD_VAR 0 4
94792: ARRAY
94793: PPUSH
94794: CALL_OW 255
94798: PUSH
94799: EMPTY
94800: LIST
94801: LIST
94802: PPUSH
94803: CALL 19238 0 3
94807: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
94808: LD_VAR 0 2
94812: PUSH
94813: LD_VAR 0 4
94817: ARRAY
94818: PPUSH
94819: LD_VAR 0 1
94823: PPUSH
94824: CALL_OW 255
94828: PPUSH
94829: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
94833: LD_VAR 0 2
94837: PUSH
94838: LD_VAR 0 4
94842: ARRAY
94843: PPUSH
94844: CALL_OW 141
// end ;
94848: GO 94680
94850: POP
94851: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
94852: LD_VAR 0 1
94856: PPUSH
94857: LD_EXP 174
94861: PUSH
94862: LD_VAR 0 5
94866: ARRAY
94867: PUSH
94868: LD_INT 0
94870: PLUS
94871: PPUSH
94872: CALL_OW 505
// end ;
94876: LD_VAR 0 3
94880: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
94881: LD_INT 0
94883: PPUSH
94884: PPUSH
94885: PPUSH
94886: PPUSH
// if not hack in hackTanks then
94887: LD_VAR 0 1
94891: PUSH
94892: LD_EXP 173
94896: IN
94897: NOT
94898: IFFALSE 94902
// exit ;
94900: GO 95142
// index := GetElementIndex ( hackTanks , hack ) ;
94902: LD_ADDR_VAR 0 4
94906: PUSH
94907: LD_EXP 173
94911: PPUSH
94912: LD_VAR 0 1
94916: PPUSH
94917: CALL 19023 0 2
94921: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
94922: LD_ADDR_VAR 0 3
94926: PUSH
94927: DOUBLE
94928: LD_EXP 174
94932: PUSH
94933: LD_VAR 0 4
94937: ARRAY
94938: INC
94939: ST_TO_ADDR
94940: LD_INT 1
94942: PUSH
94943: FOR_DOWNTO
94944: IFFALSE 95116
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
94946: LD_ADDR_VAR 0 5
94950: PUSH
94951: LD_EXP 174
94955: PUSH
94956: LD_VAR 0 4
94960: ARRAY
94961: PUSH
94962: LD_VAR 0 3
94966: ARRAY
94967: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
94968: LD_VAR 0 5
94972: PUSH
94973: LD_INT 1
94975: ARRAY
94976: PPUSH
94977: CALL_OW 302
94981: NOT
94982: PUSH
94983: LD_VAR 0 5
94987: PUSH
94988: LD_INT 1
94990: ARRAY
94991: PPUSH
94992: CALL_OW 255
94996: PUSH
94997: LD_VAR 0 1
95001: PPUSH
95002: CALL_OW 255
95006: NONEQUAL
95007: OR
95008: IFFALSE 95114
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
95010: LD_VAR 0 5
95014: PUSH
95015: LD_INT 1
95017: ARRAY
95018: PPUSH
95019: CALL_OW 305
95023: PUSH
95024: LD_VAR 0 5
95028: PUSH
95029: LD_INT 1
95031: ARRAY
95032: PPUSH
95033: CALL_OW 255
95037: PUSH
95038: LD_VAR 0 1
95042: PPUSH
95043: CALL_OW 255
95047: EQUAL
95048: AND
95049: IFFALSE 95073
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
95051: LD_VAR 0 5
95055: PUSH
95056: LD_INT 1
95058: ARRAY
95059: PPUSH
95060: LD_VAR 0 5
95064: PUSH
95065: LD_INT 2
95067: ARRAY
95068: PPUSH
95069: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
95073: LD_ADDR_EXP 174
95077: PUSH
95078: LD_EXP 174
95082: PPUSH
95083: LD_VAR 0 4
95087: PPUSH
95088: LD_EXP 174
95092: PUSH
95093: LD_VAR 0 4
95097: ARRAY
95098: PPUSH
95099: LD_VAR 0 3
95103: PPUSH
95104: CALL_OW 3
95108: PPUSH
95109: CALL_OW 1
95113: ST_TO_ADDR
// end ; end ;
95114: GO 94943
95116: POP
95117: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
95118: LD_VAR 0 1
95122: PPUSH
95123: LD_EXP 174
95127: PUSH
95128: LD_VAR 0 4
95132: ARRAY
95133: PUSH
95134: LD_INT 0
95136: PLUS
95137: PPUSH
95138: CALL_OW 505
// end ;
95142: LD_VAR 0 2
95146: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
95147: LD_INT 0
95149: PPUSH
95150: PPUSH
95151: PPUSH
95152: PPUSH
// if not hack in hackTanks then
95153: LD_VAR 0 1
95157: PUSH
95158: LD_EXP 173
95162: IN
95163: NOT
95164: IFFALSE 95168
// exit ;
95166: GO 95253
// index := GetElementIndex ( hackTanks , hack ) ;
95168: LD_ADDR_VAR 0 5
95172: PUSH
95173: LD_EXP 173
95177: PPUSH
95178: LD_VAR 0 1
95182: PPUSH
95183: CALL 19023 0 2
95187: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
95188: LD_ADDR_VAR 0 4
95192: PUSH
95193: DOUBLE
95194: LD_INT 1
95196: DEC
95197: ST_TO_ADDR
95198: LD_EXP 174
95202: PUSH
95203: LD_VAR 0 5
95207: ARRAY
95208: PUSH
95209: FOR_TO
95210: IFFALSE 95251
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
95212: LD_EXP 174
95216: PUSH
95217: LD_VAR 0 5
95221: ARRAY
95222: PUSH
95223: LD_VAR 0 4
95227: ARRAY
95228: PUSH
95229: LD_INT 1
95231: ARRAY
95232: PUSH
95233: LD_VAR 0 2
95237: EQUAL
95238: IFFALSE 95249
// KillUnit ( vehicle ) ;
95240: LD_VAR 0 2
95244: PPUSH
95245: CALL_OW 66
95249: GO 95209
95251: POP
95252: POP
// end ; end_of_file
95253: LD_VAR 0 3
95257: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
95258: LD_INT 0
95260: PPUSH
95261: PPUSH
95262: PPUSH
95263: PPUSH
95264: PPUSH
95265: PPUSH
95266: PPUSH
95267: PPUSH
95268: PPUSH
95269: PPUSH
95270: PPUSH
95271: PPUSH
95272: PPUSH
95273: PPUSH
95274: PPUSH
95275: PPUSH
95276: PPUSH
95277: PPUSH
95278: PPUSH
95279: PPUSH
95280: PPUSH
95281: PPUSH
95282: PPUSH
95283: PPUSH
95284: PPUSH
95285: PPUSH
95286: PPUSH
95287: PPUSH
95288: PPUSH
95289: PPUSH
95290: PPUSH
95291: PPUSH
95292: PPUSH
95293: PPUSH
// if not list then
95294: LD_VAR 0 1
95298: NOT
95299: IFFALSE 95303
// exit ;
95301: GO 99962
// base := list [ 1 ] ;
95303: LD_ADDR_VAR 0 3
95307: PUSH
95308: LD_VAR 0 1
95312: PUSH
95313: LD_INT 1
95315: ARRAY
95316: ST_TO_ADDR
// group := list [ 2 ] ;
95317: LD_ADDR_VAR 0 4
95321: PUSH
95322: LD_VAR 0 1
95326: PUSH
95327: LD_INT 2
95329: ARRAY
95330: ST_TO_ADDR
// path := list [ 3 ] ;
95331: LD_ADDR_VAR 0 5
95335: PUSH
95336: LD_VAR 0 1
95340: PUSH
95341: LD_INT 3
95343: ARRAY
95344: ST_TO_ADDR
// flags := list [ 4 ] ;
95345: LD_ADDR_VAR 0 6
95349: PUSH
95350: LD_VAR 0 1
95354: PUSH
95355: LD_INT 4
95357: ARRAY
95358: ST_TO_ADDR
// mined := [ ] ;
95359: LD_ADDR_VAR 0 27
95363: PUSH
95364: EMPTY
95365: ST_TO_ADDR
// bombed := [ ] ;
95366: LD_ADDR_VAR 0 28
95370: PUSH
95371: EMPTY
95372: ST_TO_ADDR
// healers := [ ] ;
95373: LD_ADDR_VAR 0 31
95377: PUSH
95378: EMPTY
95379: ST_TO_ADDR
// to_heal := [ ] ;
95380: LD_ADDR_VAR 0 30
95384: PUSH
95385: EMPTY
95386: ST_TO_ADDR
// repairs := [ ] ;
95387: LD_ADDR_VAR 0 33
95391: PUSH
95392: EMPTY
95393: ST_TO_ADDR
// to_repair := [ ] ;
95394: LD_ADDR_VAR 0 32
95398: PUSH
95399: EMPTY
95400: ST_TO_ADDR
// if not group or not path then
95401: LD_VAR 0 4
95405: NOT
95406: PUSH
95407: LD_VAR 0 5
95411: NOT
95412: OR
95413: IFFALSE 95417
// exit ;
95415: GO 99962
// side := GetSide ( group [ 1 ] ) ;
95417: LD_ADDR_VAR 0 35
95421: PUSH
95422: LD_VAR 0 4
95426: PUSH
95427: LD_INT 1
95429: ARRAY
95430: PPUSH
95431: CALL_OW 255
95435: ST_TO_ADDR
// if flags then
95436: LD_VAR 0 6
95440: IFFALSE 95584
// begin f_ignore_area := flags [ 1 ] ;
95442: LD_ADDR_VAR 0 17
95446: PUSH
95447: LD_VAR 0 6
95451: PUSH
95452: LD_INT 1
95454: ARRAY
95455: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
95456: LD_ADDR_VAR 0 18
95460: PUSH
95461: LD_VAR 0 6
95465: PUSH
95466: LD_INT 2
95468: ARRAY
95469: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
95470: LD_ADDR_VAR 0 19
95474: PUSH
95475: LD_VAR 0 6
95479: PUSH
95480: LD_INT 3
95482: ARRAY
95483: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
95484: LD_ADDR_VAR 0 20
95488: PUSH
95489: LD_VAR 0 6
95493: PUSH
95494: LD_INT 4
95496: ARRAY
95497: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
95498: LD_ADDR_VAR 0 21
95502: PUSH
95503: LD_VAR 0 6
95507: PUSH
95508: LD_INT 5
95510: ARRAY
95511: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
95512: LD_ADDR_VAR 0 22
95516: PUSH
95517: LD_VAR 0 6
95521: PUSH
95522: LD_INT 6
95524: ARRAY
95525: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
95526: LD_ADDR_VAR 0 23
95530: PUSH
95531: LD_VAR 0 6
95535: PUSH
95536: LD_INT 7
95538: ARRAY
95539: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
95540: LD_ADDR_VAR 0 24
95544: PUSH
95545: LD_VAR 0 6
95549: PUSH
95550: LD_INT 8
95552: ARRAY
95553: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
95554: LD_ADDR_VAR 0 25
95558: PUSH
95559: LD_VAR 0 6
95563: PUSH
95564: LD_INT 9
95566: ARRAY
95567: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
95568: LD_ADDR_VAR 0 26
95572: PUSH
95573: LD_VAR 0 6
95577: PUSH
95578: LD_INT 10
95580: ARRAY
95581: ST_TO_ADDR
// end else
95582: GO 95664
// begin f_ignore_area := false ;
95584: LD_ADDR_VAR 0 17
95588: PUSH
95589: LD_INT 0
95591: ST_TO_ADDR
// f_capture := false ;
95592: LD_ADDR_VAR 0 18
95596: PUSH
95597: LD_INT 0
95599: ST_TO_ADDR
// f_ignore_civ := false ;
95600: LD_ADDR_VAR 0 19
95604: PUSH
95605: LD_INT 0
95607: ST_TO_ADDR
// f_murder := false ;
95608: LD_ADDR_VAR 0 20
95612: PUSH
95613: LD_INT 0
95615: ST_TO_ADDR
// f_mines := false ;
95616: LD_ADDR_VAR 0 21
95620: PUSH
95621: LD_INT 0
95623: ST_TO_ADDR
// f_repair := false ;
95624: LD_ADDR_VAR 0 22
95628: PUSH
95629: LD_INT 0
95631: ST_TO_ADDR
// f_heal := false ;
95632: LD_ADDR_VAR 0 23
95636: PUSH
95637: LD_INT 0
95639: ST_TO_ADDR
// f_spacetime := false ;
95640: LD_ADDR_VAR 0 24
95644: PUSH
95645: LD_INT 0
95647: ST_TO_ADDR
// f_attack_depot := false ;
95648: LD_ADDR_VAR 0 25
95652: PUSH
95653: LD_INT 0
95655: ST_TO_ADDR
// f_crawl := false ;
95656: LD_ADDR_VAR 0 26
95660: PUSH
95661: LD_INT 0
95663: ST_TO_ADDR
// end ; if f_heal then
95664: LD_VAR 0 23
95668: IFFALSE 95695
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
95670: LD_ADDR_VAR 0 31
95674: PUSH
95675: LD_VAR 0 4
95679: PPUSH
95680: LD_INT 25
95682: PUSH
95683: LD_INT 4
95685: PUSH
95686: EMPTY
95687: LIST
95688: LIST
95689: PPUSH
95690: CALL_OW 72
95694: ST_TO_ADDR
// if f_repair then
95695: LD_VAR 0 22
95699: IFFALSE 95726
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
95701: LD_ADDR_VAR 0 33
95705: PUSH
95706: LD_VAR 0 4
95710: PPUSH
95711: LD_INT 25
95713: PUSH
95714: LD_INT 3
95716: PUSH
95717: EMPTY
95718: LIST
95719: LIST
95720: PPUSH
95721: CALL_OW 72
95725: ST_TO_ADDR
// units_path := [ ] ;
95726: LD_ADDR_VAR 0 16
95730: PUSH
95731: EMPTY
95732: ST_TO_ADDR
// for i = 1 to group do
95733: LD_ADDR_VAR 0 7
95737: PUSH
95738: DOUBLE
95739: LD_INT 1
95741: DEC
95742: ST_TO_ADDR
95743: LD_VAR 0 4
95747: PUSH
95748: FOR_TO
95749: IFFALSE 95778
// units_path := Replace ( units_path , i , path ) ;
95751: LD_ADDR_VAR 0 16
95755: PUSH
95756: LD_VAR 0 16
95760: PPUSH
95761: LD_VAR 0 7
95765: PPUSH
95766: LD_VAR 0 5
95770: PPUSH
95771: CALL_OW 1
95775: ST_TO_ADDR
95776: GO 95748
95778: POP
95779: POP
// repeat for i = group downto 1 do
95780: LD_ADDR_VAR 0 7
95784: PUSH
95785: DOUBLE
95786: LD_VAR 0 4
95790: INC
95791: ST_TO_ADDR
95792: LD_INT 1
95794: PUSH
95795: FOR_DOWNTO
95796: IFFALSE 99918
// begin wait ( 5 ) ;
95798: LD_INT 5
95800: PPUSH
95801: CALL_OW 67
// tmp := [ ] ;
95805: LD_ADDR_VAR 0 14
95809: PUSH
95810: EMPTY
95811: ST_TO_ADDR
// attacking := false ;
95812: LD_ADDR_VAR 0 29
95816: PUSH
95817: LD_INT 0
95819: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
95820: LD_VAR 0 4
95824: PUSH
95825: LD_VAR 0 7
95829: ARRAY
95830: PPUSH
95831: CALL_OW 301
95835: PUSH
95836: LD_VAR 0 4
95840: PUSH
95841: LD_VAR 0 7
95845: ARRAY
95846: NOT
95847: OR
95848: IFFALSE 95957
// begin if GetType ( group [ i ] ) = unit_human then
95850: LD_VAR 0 4
95854: PUSH
95855: LD_VAR 0 7
95859: ARRAY
95860: PPUSH
95861: CALL_OW 247
95865: PUSH
95866: LD_INT 1
95868: EQUAL
95869: IFFALSE 95915
// begin to_heal := to_heal diff group [ i ] ;
95871: LD_ADDR_VAR 0 30
95875: PUSH
95876: LD_VAR 0 30
95880: PUSH
95881: LD_VAR 0 4
95885: PUSH
95886: LD_VAR 0 7
95890: ARRAY
95891: DIFF
95892: ST_TO_ADDR
// healers := healers diff group [ i ] ;
95893: LD_ADDR_VAR 0 31
95897: PUSH
95898: LD_VAR 0 31
95902: PUSH
95903: LD_VAR 0 4
95907: PUSH
95908: LD_VAR 0 7
95912: ARRAY
95913: DIFF
95914: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
95915: LD_ADDR_VAR 0 4
95919: PUSH
95920: LD_VAR 0 4
95924: PPUSH
95925: LD_VAR 0 7
95929: PPUSH
95930: CALL_OW 3
95934: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
95935: LD_ADDR_VAR 0 16
95939: PUSH
95940: LD_VAR 0 16
95944: PPUSH
95945: LD_VAR 0 7
95949: PPUSH
95950: CALL_OW 3
95954: ST_TO_ADDR
// continue ;
95955: GO 95795
// end ; if f_repair then
95957: LD_VAR 0 22
95961: IFFALSE 96450
// begin if GetType ( group [ i ] ) = unit_vehicle then
95963: LD_VAR 0 4
95967: PUSH
95968: LD_VAR 0 7
95972: ARRAY
95973: PPUSH
95974: CALL_OW 247
95978: PUSH
95979: LD_INT 2
95981: EQUAL
95982: IFFALSE 96172
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
95984: LD_VAR 0 4
95988: PUSH
95989: LD_VAR 0 7
95993: ARRAY
95994: PPUSH
95995: CALL_OW 256
95999: PUSH
96000: LD_INT 700
96002: LESS
96003: PUSH
96004: LD_VAR 0 4
96008: PUSH
96009: LD_VAR 0 7
96013: ARRAY
96014: PUSH
96015: LD_VAR 0 32
96019: IN
96020: NOT
96021: AND
96022: IFFALSE 96046
// to_repair := to_repair union group [ i ] ;
96024: LD_ADDR_VAR 0 32
96028: PUSH
96029: LD_VAR 0 32
96033: PUSH
96034: LD_VAR 0 4
96038: PUSH
96039: LD_VAR 0 7
96043: ARRAY
96044: UNION
96045: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
96046: LD_VAR 0 4
96050: PUSH
96051: LD_VAR 0 7
96055: ARRAY
96056: PPUSH
96057: CALL_OW 256
96061: PUSH
96062: LD_INT 1000
96064: EQUAL
96065: PUSH
96066: LD_VAR 0 4
96070: PUSH
96071: LD_VAR 0 7
96075: ARRAY
96076: PUSH
96077: LD_VAR 0 32
96081: IN
96082: AND
96083: IFFALSE 96107
// to_repair := to_repair diff group [ i ] ;
96085: LD_ADDR_VAR 0 32
96089: PUSH
96090: LD_VAR 0 32
96094: PUSH
96095: LD_VAR 0 4
96099: PUSH
96100: LD_VAR 0 7
96104: ARRAY
96105: DIFF
96106: ST_TO_ADDR
// if group [ i ] in to_repair then
96107: LD_VAR 0 4
96111: PUSH
96112: LD_VAR 0 7
96116: ARRAY
96117: PUSH
96118: LD_VAR 0 32
96122: IN
96123: IFFALSE 96170
// begin if not IsInArea ( group [ i ] , f_repair ) then
96125: LD_VAR 0 4
96129: PUSH
96130: LD_VAR 0 7
96134: ARRAY
96135: PPUSH
96136: LD_VAR 0 22
96140: PPUSH
96141: CALL_OW 308
96145: NOT
96146: IFFALSE 96168
// ComMoveToArea ( group [ i ] , f_repair ) ;
96148: LD_VAR 0 4
96152: PUSH
96153: LD_VAR 0 7
96157: ARRAY
96158: PPUSH
96159: LD_VAR 0 22
96163: PPUSH
96164: CALL_OW 113
// continue ;
96168: GO 95795
// end ; end else
96170: GO 96450
// if group [ i ] in repairs then
96172: LD_VAR 0 4
96176: PUSH
96177: LD_VAR 0 7
96181: ARRAY
96182: PUSH
96183: LD_VAR 0 33
96187: IN
96188: IFFALSE 96450
// begin if IsInUnit ( group [ i ] ) then
96190: LD_VAR 0 4
96194: PUSH
96195: LD_VAR 0 7
96199: ARRAY
96200: PPUSH
96201: CALL_OW 310
96205: IFFALSE 96273
// begin z := IsInUnit ( group [ i ] ) ;
96207: LD_ADDR_VAR 0 13
96211: PUSH
96212: LD_VAR 0 4
96216: PUSH
96217: LD_VAR 0 7
96221: ARRAY
96222: PPUSH
96223: CALL_OW 310
96227: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
96228: LD_VAR 0 13
96232: PUSH
96233: LD_VAR 0 32
96237: IN
96238: PUSH
96239: LD_VAR 0 13
96243: PPUSH
96244: LD_VAR 0 22
96248: PPUSH
96249: CALL_OW 308
96253: AND
96254: IFFALSE 96271
// ComExitVehicle ( group [ i ] ) ;
96256: LD_VAR 0 4
96260: PUSH
96261: LD_VAR 0 7
96265: ARRAY
96266: PPUSH
96267: CALL_OW 121
// end else
96271: GO 96450
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
96273: LD_ADDR_VAR 0 13
96277: PUSH
96278: LD_VAR 0 4
96282: PPUSH
96283: LD_INT 95
96285: PUSH
96286: LD_VAR 0 22
96290: PUSH
96291: EMPTY
96292: LIST
96293: LIST
96294: PUSH
96295: LD_INT 58
96297: PUSH
96298: EMPTY
96299: LIST
96300: PUSH
96301: EMPTY
96302: LIST
96303: LIST
96304: PPUSH
96305: CALL_OW 72
96309: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
96310: LD_VAR 0 4
96314: PUSH
96315: LD_VAR 0 7
96319: ARRAY
96320: PPUSH
96321: CALL_OW 314
96325: NOT
96326: IFFALSE 96448
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
96328: LD_ADDR_VAR 0 10
96332: PUSH
96333: LD_VAR 0 13
96337: PPUSH
96338: LD_VAR 0 4
96342: PUSH
96343: LD_VAR 0 7
96347: ARRAY
96348: PPUSH
96349: CALL_OW 74
96353: ST_TO_ADDR
// if not x then
96354: LD_VAR 0 10
96358: NOT
96359: IFFALSE 96363
// continue ;
96361: GO 95795
// if GetLives ( x ) < 1000 then
96363: LD_VAR 0 10
96367: PPUSH
96368: CALL_OW 256
96372: PUSH
96373: LD_INT 1000
96375: LESS
96376: IFFALSE 96400
// ComRepairVehicle ( group [ i ] , x ) else
96378: LD_VAR 0 4
96382: PUSH
96383: LD_VAR 0 7
96387: ARRAY
96388: PPUSH
96389: LD_VAR 0 10
96393: PPUSH
96394: CALL_OW 129
96398: GO 96448
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
96400: LD_VAR 0 23
96404: PUSH
96405: LD_VAR 0 4
96409: PUSH
96410: LD_VAR 0 7
96414: ARRAY
96415: PPUSH
96416: CALL_OW 256
96420: PUSH
96421: LD_INT 1000
96423: LESS
96424: AND
96425: NOT
96426: IFFALSE 96448
// ComEnterUnit ( group [ i ] , x ) ;
96428: LD_VAR 0 4
96432: PUSH
96433: LD_VAR 0 7
96437: ARRAY
96438: PPUSH
96439: LD_VAR 0 10
96443: PPUSH
96444: CALL_OW 120
// end ; continue ;
96448: GO 95795
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
96450: LD_VAR 0 23
96454: PUSH
96455: LD_VAR 0 4
96459: PUSH
96460: LD_VAR 0 7
96464: ARRAY
96465: PPUSH
96466: CALL_OW 247
96470: PUSH
96471: LD_INT 1
96473: EQUAL
96474: AND
96475: IFFALSE 96953
// begin if group [ i ] in healers then
96477: LD_VAR 0 4
96481: PUSH
96482: LD_VAR 0 7
96486: ARRAY
96487: PUSH
96488: LD_VAR 0 31
96492: IN
96493: IFFALSE 96766
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
96495: LD_VAR 0 4
96499: PUSH
96500: LD_VAR 0 7
96504: ARRAY
96505: PPUSH
96506: LD_VAR 0 23
96510: PPUSH
96511: CALL_OW 308
96515: NOT
96516: PUSH
96517: LD_VAR 0 4
96521: PUSH
96522: LD_VAR 0 7
96526: ARRAY
96527: PPUSH
96528: CALL_OW 314
96532: NOT
96533: AND
96534: IFFALSE 96558
// ComMoveToArea ( group [ i ] , f_heal ) else
96536: LD_VAR 0 4
96540: PUSH
96541: LD_VAR 0 7
96545: ARRAY
96546: PPUSH
96547: LD_VAR 0 23
96551: PPUSH
96552: CALL_OW 113
96556: GO 96764
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
96558: LD_VAR 0 4
96562: PUSH
96563: LD_VAR 0 7
96567: ARRAY
96568: PPUSH
96569: CALL 47610 0 1
96573: PPUSH
96574: CALL_OW 256
96578: PUSH
96579: LD_INT 1000
96581: EQUAL
96582: IFFALSE 96601
// ComStop ( group [ i ] ) else
96584: LD_VAR 0 4
96588: PUSH
96589: LD_VAR 0 7
96593: ARRAY
96594: PPUSH
96595: CALL_OW 141
96599: GO 96764
// if not HasTask ( group [ i ] ) and to_heal then
96601: LD_VAR 0 4
96605: PUSH
96606: LD_VAR 0 7
96610: ARRAY
96611: PPUSH
96612: CALL_OW 314
96616: NOT
96617: PUSH
96618: LD_VAR 0 30
96622: AND
96623: IFFALSE 96764
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
96625: LD_ADDR_VAR 0 13
96629: PUSH
96630: LD_VAR 0 30
96634: PPUSH
96635: LD_INT 3
96637: PUSH
96638: LD_INT 54
96640: PUSH
96641: EMPTY
96642: LIST
96643: PUSH
96644: EMPTY
96645: LIST
96646: LIST
96647: PPUSH
96648: CALL_OW 72
96652: PPUSH
96653: LD_VAR 0 4
96657: PUSH
96658: LD_VAR 0 7
96662: ARRAY
96663: PPUSH
96664: CALL_OW 74
96668: ST_TO_ADDR
// if z then
96669: LD_VAR 0 13
96673: IFFALSE 96764
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
96675: LD_INT 91
96677: PUSH
96678: LD_VAR 0 13
96682: PUSH
96683: LD_INT 10
96685: PUSH
96686: EMPTY
96687: LIST
96688: LIST
96689: LIST
96690: PUSH
96691: LD_INT 81
96693: PUSH
96694: LD_VAR 0 13
96698: PPUSH
96699: CALL_OW 255
96703: PUSH
96704: EMPTY
96705: LIST
96706: LIST
96707: PUSH
96708: EMPTY
96709: LIST
96710: LIST
96711: PPUSH
96712: CALL_OW 69
96716: PUSH
96717: LD_INT 0
96719: EQUAL
96720: IFFALSE 96744
// ComHeal ( group [ i ] , z ) else
96722: LD_VAR 0 4
96726: PUSH
96727: LD_VAR 0 7
96731: ARRAY
96732: PPUSH
96733: LD_VAR 0 13
96737: PPUSH
96738: CALL_OW 128
96742: GO 96764
// ComMoveToArea ( group [ i ] , f_heal ) ;
96744: LD_VAR 0 4
96748: PUSH
96749: LD_VAR 0 7
96753: ARRAY
96754: PPUSH
96755: LD_VAR 0 23
96759: PPUSH
96760: CALL_OW 113
// end ; continue ;
96764: GO 95795
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
96766: LD_VAR 0 4
96770: PUSH
96771: LD_VAR 0 7
96775: ARRAY
96776: PPUSH
96777: CALL_OW 256
96781: PUSH
96782: LD_INT 700
96784: LESS
96785: PUSH
96786: LD_VAR 0 4
96790: PUSH
96791: LD_VAR 0 7
96795: ARRAY
96796: PUSH
96797: LD_VAR 0 30
96801: IN
96802: NOT
96803: AND
96804: IFFALSE 96828
// to_heal := to_heal union group [ i ] ;
96806: LD_ADDR_VAR 0 30
96810: PUSH
96811: LD_VAR 0 30
96815: PUSH
96816: LD_VAR 0 4
96820: PUSH
96821: LD_VAR 0 7
96825: ARRAY
96826: UNION
96827: ST_TO_ADDR
// if group [ i ] in to_heal then
96828: LD_VAR 0 4
96832: PUSH
96833: LD_VAR 0 7
96837: ARRAY
96838: PUSH
96839: LD_VAR 0 30
96843: IN
96844: IFFALSE 96953
// begin if GetLives ( group [ i ] ) = 1000 then
96846: LD_VAR 0 4
96850: PUSH
96851: LD_VAR 0 7
96855: ARRAY
96856: PPUSH
96857: CALL_OW 256
96861: PUSH
96862: LD_INT 1000
96864: EQUAL
96865: IFFALSE 96891
// to_heal := to_heal diff group [ i ] else
96867: LD_ADDR_VAR 0 30
96871: PUSH
96872: LD_VAR 0 30
96876: PUSH
96877: LD_VAR 0 4
96881: PUSH
96882: LD_VAR 0 7
96886: ARRAY
96887: DIFF
96888: ST_TO_ADDR
96889: GO 96953
// begin if not IsInArea ( group [ i ] , to_heal ) then
96891: LD_VAR 0 4
96895: PUSH
96896: LD_VAR 0 7
96900: ARRAY
96901: PPUSH
96902: LD_VAR 0 30
96906: PPUSH
96907: CALL_OW 308
96911: NOT
96912: IFFALSE 96936
// ComMoveToArea ( group [ i ] , f_heal ) else
96914: LD_VAR 0 4
96918: PUSH
96919: LD_VAR 0 7
96923: ARRAY
96924: PPUSH
96925: LD_VAR 0 23
96929: PPUSH
96930: CALL_OW 113
96934: GO 96951
// ComHold ( group [ i ] ) ;
96936: LD_VAR 0 4
96940: PUSH
96941: LD_VAR 0 7
96945: ARRAY
96946: PPUSH
96947: CALL_OW 140
// continue ;
96951: GO 95795
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
96953: LD_VAR 0 4
96957: PUSH
96958: LD_VAR 0 7
96962: ARRAY
96963: PPUSH
96964: LD_INT 10
96966: PPUSH
96967: CALL 46030 0 2
96971: NOT
96972: PUSH
96973: LD_VAR 0 16
96977: PUSH
96978: LD_VAR 0 7
96982: ARRAY
96983: PUSH
96984: EMPTY
96985: EQUAL
96986: NOT
96987: AND
96988: IFFALSE 97254
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
96990: LD_VAR 0 4
96994: PUSH
96995: LD_VAR 0 7
96999: ARRAY
97000: PPUSH
97001: CALL_OW 262
97005: PUSH
97006: LD_INT 1
97008: PUSH
97009: LD_INT 2
97011: PUSH
97012: EMPTY
97013: LIST
97014: LIST
97015: IN
97016: IFFALSE 97057
// if GetFuel ( group [ i ] ) < 10 then
97018: LD_VAR 0 4
97022: PUSH
97023: LD_VAR 0 7
97027: ARRAY
97028: PPUSH
97029: CALL_OW 261
97033: PUSH
97034: LD_INT 10
97036: LESS
97037: IFFALSE 97057
// SetFuel ( group [ i ] , 12 ) ;
97039: LD_VAR 0 4
97043: PUSH
97044: LD_VAR 0 7
97048: ARRAY
97049: PPUSH
97050: LD_INT 12
97052: PPUSH
97053: CALL_OW 240
// if units_path [ i ] then
97057: LD_VAR 0 16
97061: PUSH
97062: LD_VAR 0 7
97066: ARRAY
97067: IFFALSE 97252
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
97069: LD_VAR 0 4
97073: PUSH
97074: LD_VAR 0 7
97078: ARRAY
97079: PPUSH
97080: LD_VAR 0 16
97084: PUSH
97085: LD_VAR 0 7
97089: ARRAY
97090: PUSH
97091: LD_INT 1
97093: ARRAY
97094: PUSH
97095: LD_INT 1
97097: ARRAY
97098: PPUSH
97099: LD_VAR 0 16
97103: PUSH
97104: LD_VAR 0 7
97108: ARRAY
97109: PUSH
97110: LD_INT 1
97112: ARRAY
97113: PUSH
97114: LD_INT 2
97116: ARRAY
97117: PPUSH
97118: CALL_OW 297
97122: PUSH
97123: LD_INT 6
97125: GREATER
97126: IFFALSE 97201
// begin if not HasTask ( group [ i ] ) then
97128: LD_VAR 0 4
97132: PUSH
97133: LD_VAR 0 7
97137: ARRAY
97138: PPUSH
97139: CALL_OW 314
97143: NOT
97144: IFFALSE 97199
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
97146: LD_VAR 0 4
97150: PUSH
97151: LD_VAR 0 7
97155: ARRAY
97156: PPUSH
97157: LD_VAR 0 16
97161: PUSH
97162: LD_VAR 0 7
97166: ARRAY
97167: PUSH
97168: LD_INT 1
97170: ARRAY
97171: PUSH
97172: LD_INT 1
97174: ARRAY
97175: PPUSH
97176: LD_VAR 0 16
97180: PUSH
97181: LD_VAR 0 7
97185: ARRAY
97186: PUSH
97187: LD_INT 1
97189: ARRAY
97190: PUSH
97191: LD_INT 2
97193: ARRAY
97194: PPUSH
97195: CALL_OW 114
// end else
97199: GO 97252
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
97201: LD_ADDR_VAR 0 15
97205: PUSH
97206: LD_VAR 0 16
97210: PUSH
97211: LD_VAR 0 7
97215: ARRAY
97216: PPUSH
97217: LD_INT 1
97219: PPUSH
97220: CALL_OW 3
97224: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
97225: LD_ADDR_VAR 0 16
97229: PUSH
97230: LD_VAR 0 16
97234: PPUSH
97235: LD_VAR 0 7
97239: PPUSH
97240: LD_VAR 0 15
97244: PPUSH
97245: CALL_OW 1
97249: ST_TO_ADDR
// continue ;
97250: GO 95795
// end ; end ; end else
97252: GO 99916
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
97254: LD_ADDR_VAR 0 14
97258: PUSH
97259: LD_INT 81
97261: PUSH
97262: LD_VAR 0 4
97266: PUSH
97267: LD_VAR 0 7
97271: ARRAY
97272: PPUSH
97273: CALL_OW 255
97277: PUSH
97278: EMPTY
97279: LIST
97280: LIST
97281: PPUSH
97282: CALL_OW 69
97286: ST_TO_ADDR
// if not tmp then
97287: LD_VAR 0 14
97291: NOT
97292: IFFALSE 97296
// continue ;
97294: GO 95795
// if f_ignore_area then
97296: LD_VAR 0 17
97300: IFFALSE 97388
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
97302: LD_ADDR_VAR 0 15
97306: PUSH
97307: LD_VAR 0 14
97311: PPUSH
97312: LD_INT 3
97314: PUSH
97315: LD_INT 92
97317: PUSH
97318: LD_VAR 0 17
97322: PUSH
97323: LD_INT 1
97325: ARRAY
97326: PUSH
97327: LD_VAR 0 17
97331: PUSH
97332: LD_INT 2
97334: ARRAY
97335: PUSH
97336: LD_VAR 0 17
97340: PUSH
97341: LD_INT 3
97343: ARRAY
97344: PUSH
97345: EMPTY
97346: LIST
97347: LIST
97348: LIST
97349: LIST
97350: PUSH
97351: EMPTY
97352: LIST
97353: LIST
97354: PPUSH
97355: CALL_OW 72
97359: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97360: LD_VAR 0 14
97364: PUSH
97365: LD_VAR 0 15
97369: DIFF
97370: IFFALSE 97388
// tmp := tmp diff tmp2 ;
97372: LD_ADDR_VAR 0 14
97376: PUSH
97377: LD_VAR 0 14
97381: PUSH
97382: LD_VAR 0 15
97386: DIFF
97387: ST_TO_ADDR
// end ; if not f_murder then
97388: LD_VAR 0 20
97392: NOT
97393: IFFALSE 97451
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
97395: LD_ADDR_VAR 0 15
97399: PUSH
97400: LD_VAR 0 14
97404: PPUSH
97405: LD_INT 3
97407: PUSH
97408: LD_INT 50
97410: PUSH
97411: EMPTY
97412: LIST
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PPUSH
97418: CALL_OW 72
97422: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
97423: LD_VAR 0 14
97427: PUSH
97428: LD_VAR 0 15
97432: DIFF
97433: IFFALSE 97451
// tmp := tmp diff tmp2 ;
97435: LD_ADDR_VAR 0 14
97439: PUSH
97440: LD_VAR 0 14
97444: PUSH
97445: LD_VAR 0 15
97449: DIFF
97450: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
97451: LD_ADDR_VAR 0 14
97455: PUSH
97456: LD_VAR 0 4
97460: PUSH
97461: LD_VAR 0 7
97465: ARRAY
97466: PPUSH
97467: LD_VAR 0 14
97471: PPUSH
97472: LD_INT 1
97474: PPUSH
97475: LD_INT 1
97477: PPUSH
97478: CALL 19673 0 4
97482: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
97483: LD_VAR 0 4
97487: PUSH
97488: LD_VAR 0 7
97492: ARRAY
97493: PPUSH
97494: CALL_OW 257
97498: PUSH
97499: LD_INT 1
97501: EQUAL
97502: IFFALSE 97950
// begin if WantPlant ( group [ i ] ) then
97504: LD_VAR 0 4
97508: PUSH
97509: LD_VAR 0 7
97513: ARRAY
97514: PPUSH
97515: CALL 19174 0 1
97519: IFFALSE 97523
// continue ;
97521: GO 95795
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
97523: LD_VAR 0 18
97527: PUSH
97528: LD_VAR 0 4
97532: PUSH
97533: LD_VAR 0 7
97537: ARRAY
97538: PPUSH
97539: CALL_OW 310
97543: NOT
97544: AND
97545: PUSH
97546: LD_VAR 0 14
97550: PUSH
97551: LD_INT 1
97553: ARRAY
97554: PUSH
97555: LD_VAR 0 14
97559: PPUSH
97560: LD_INT 21
97562: PUSH
97563: LD_INT 2
97565: PUSH
97566: EMPTY
97567: LIST
97568: LIST
97569: PUSH
97570: LD_INT 58
97572: PUSH
97573: EMPTY
97574: LIST
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: PPUSH
97580: CALL_OW 72
97584: IN
97585: AND
97586: IFFALSE 97622
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
97588: LD_VAR 0 4
97592: PUSH
97593: LD_VAR 0 7
97597: ARRAY
97598: PPUSH
97599: LD_VAR 0 14
97603: PUSH
97604: LD_INT 1
97606: ARRAY
97607: PPUSH
97608: CALL_OW 120
// attacking := true ;
97612: LD_ADDR_VAR 0 29
97616: PUSH
97617: LD_INT 1
97619: ST_TO_ADDR
// continue ;
97620: GO 95795
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
97622: LD_VAR 0 26
97626: PUSH
97627: LD_VAR 0 4
97631: PUSH
97632: LD_VAR 0 7
97636: ARRAY
97637: PPUSH
97638: CALL_OW 257
97642: PUSH
97643: LD_INT 1
97645: EQUAL
97646: AND
97647: PUSH
97648: LD_VAR 0 4
97652: PUSH
97653: LD_VAR 0 7
97657: ARRAY
97658: PPUSH
97659: CALL_OW 256
97663: PUSH
97664: LD_INT 800
97666: LESS
97667: AND
97668: PUSH
97669: LD_VAR 0 4
97673: PUSH
97674: LD_VAR 0 7
97678: ARRAY
97679: PPUSH
97680: CALL_OW 318
97684: NOT
97685: AND
97686: IFFALSE 97703
// ComCrawl ( group [ i ] ) ;
97688: LD_VAR 0 4
97692: PUSH
97693: LD_VAR 0 7
97697: ARRAY
97698: PPUSH
97699: CALL_OW 137
// if f_mines then
97703: LD_VAR 0 21
97707: IFFALSE 97950
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
97709: LD_VAR 0 14
97713: PUSH
97714: LD_INT 1
97716: ARRAY
97717: PPUSH
97718: CALL_OW 247
97722: PUSH
97723: LD_INT 3
97725: EQUAL
97726: PUSH
97727: LD_VAR 0 14
97731: PUSH
97732: LD_INT 1
97734: ARRAY
97735: PUSH
97736: LD_VAR 0 27
97740: IN
97741: NOT
97742: AND
97743: IFFALSE 97950
// begin x := GetX ( tmp [ 1 ] ) ;
97745: LD_ADDR_VAR 0 10
97749: PUSH
97750: LD_VAR 0 14
97754: PUSH
97755: LD_INT 1
97757: ARRAY
97758: PPUSH
97759: CALL_OW 250
97763: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
97764: LD_ADDR_VAR 0 11
97768: PUSH
97769: LD_VAR 0 14
97773: PUSH
97774: LD_INT 1
97776: ARRAY
97777: PPUSH
97778: CALL_OW 251
97782: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
97783: LD_ADDR_VAR 0 12
97787: PUSH
97788: LD_VAR 0 4
97792: PUSH
97793: LD_VAR 0 7
97797: ARRAY
97798: PPUSH
97799: CALL 46115 0 1
97803: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
97804: LD_VAR 0 4
97808: PUSH
97809: LD_VAR 0 7
97813: ARRAY
97814: PPUSH
97815: LD_VAR 0 10
97819: PPUSH
97820: LD_VAR 0 11
97824: PPUSH
97825: LD_VAR 0 14
97829: PUSH
97830: LD_INT 1
97832: ARRAY
97833: PPUSH
97834: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
97838: LD_VAR 0 4
97842: PUSH
97843: LD_VAR 0 7
97847: ARRAY
97848: PPUSH
97849: LD_VAR 0 10
97853: PPUSH
97854: LD_VAR 0 12
97858: PPUSH
97859: LD_INT 7
97861: PPUSH
97862: CALL_OW 272
97866: PPUSH
97867: LD_VAR 0 11
97871: PPUSH
97872: LD_VAR 0 12
97876: PPUSH
97877: LD_INT 7
97879: PPUSH
97880: CALL_OW 273
97884: PPUSH
97885: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
97889: LD_VAR 0 4
97893: PUSH
97894: LD_VAR 0 7
97898: ARRAY
97899: PPUSH
97900: LD_INT 71
97902: PPUSH
97903: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
97907: LD_ADDR_VAR 0 27
97911: PUSH
97912: LD_VAR 0 27
97916: PPUSH
97917: LD_VAR 0 27
97921: PUSH
97922: LD_INT 1
97924: PLUS
97925: PPUSH
97926: LD_VAR 0 14
97930: PUSH
97931: LD_INT 1
97933: ARRAY
97934: PPUSH
97935: CALL_OW 1
97939: ST_TO_ADDR
// attacking := true ;
97940: LD_ADDR_VAR 0 29
97944: PUSH
97945: LD_INT 1
97947: ST_TO_ADDR
// continue ;
97948: GO 95795
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
97950: LD_VAR 0 4
97954: PUSH
97955: LD_VAR 0 7
97959: ARRAY
97960: PPUSH
97961: CALL_OW 257
97965: PUSH
97966: LD_INT 17
97968: EQUAL
97969: PUSH
97970: LD_VAR 0 4
97974: PUSH
97975: LD_VAR 0 7
97979: ARRAY
97980: PPUSH
97981: CALL_OW 110
97985: PUSH
97986: LD_INT 71
97988: EQUAL
97989: NOT
97990: AND
97991: IFFALSE 98137
// begin attacking := false ;
97993: LD_ADDR_VAR 0 29
97997: PUSH
97998: LD_INT 0
98000: ST_TO_ADDR
// k := 5 ;
98001: LD_ADDR_VAR 0 9
98005: PUSH
98006: LD_INT 5
98008: ST_TO_ADDR
// if tmp < k then
98009: LD_VAR 0 14
98013: PUSH
98014: LD_VAR 0 9
98018: LESS
98019: IFFALSE 98031
// k := tmp ;
98021: LD_ADDR_VAR 0 9
98025: PUSH
98026: LD_VAR 0 14
98030: ST_TO_ADDR
// for j = 1 to k do
98031: LD_ADDR_VAR 0 8
98035: PUSH
98036: DOUBLE
98037: LD_INT 1
98039: DEC
98040: ST_TO_ADDR
98041: LD_VAR 0 9
98045: PUSH
98046: FOR_TO
98047: IFFALSE 98135
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
98049: LD_VAR 0 14
98053: PUSH
98054: LD_VAR 0 8
98058: ARRAY
98059: PUSH
98060: LD_VAR 0 14
98064: PPUSH
98065: LD_INT 58
98067: PUSH
98068: EMPTY
98069: LIST
98070: PPUSH
98071: CALL_OW 72
98075: IN
98076: NOT
98077: IFFALSE 98133
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98079: LD_VAR 0 4
98083: PUSH
98084: LD_VAR 0 7
98088: ARRAY
98089: PPUSH
98090: LD_VAR 0 14
98094: PUSH
98095: LD_VAR 0 8
98099: ARRAY
98100: PPUSH
98101: CALL_OW 115
// attacking := true ;
98105: LD_ADDR_VAR 0 29
98109: PUSH
98110: LD_INT 1
98112: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
98113: LD_VAR 0 4
98117: PUSH
98118: LD_VAR 0 7
98122: ARRAY
98123: PPUSH
98124: LD_INT 71
98126: PPUSH
98127: CALL_OW 109
// continue ;
98131: GO 98046
// end ; end ;
98133: GO 98046
98135: POP
98136: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
98137: LD_VAR 0 4
98141: PUSH
98142: LD_VAR 0 7
98146: ARRAY
98147: PPUSH
98148: CALL_OW 257
98152: PUSH
98153: LD_INT 8
98155: EQUAL
98156: PUSH
98157: LD_VAR 0 4
98161: PUSH
98162: LD_VAR 0 7
98166: ARRAY
98167: PPUSH
98168: CALL_OW 264
98172: PUSH
98173: LD_INT 28
98175: PUSH
98176: LD_INT 45
98178: PUSH
98179: LD_INT 7
98181: PUSH
98182: LD_INT 47
98184: PUSH
98185: EMPTY
98186: LIST
98187: LIST
98188: LIST
98189: LIST
98190: IN
98191: OR
98192: IFFALSE 98448
// begin attacking := false ;
98194: LD_ADDR_VAR 0 29
98198: PUSH
98199: LD_INT 0
98201: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
98202: LD_VAR 0 14
98206: PUSH
98207: LD_INT 1
98209: ARRAY
98210: PPUSH
98211: CALL_OW 266
98215: PUSH
98216: LD_INT 32
98218: PUSH
98219: LD_INT 31
98221: PUSH
98222: LD_INT 33
98224: PUSH
98225: LD_INT 4
98227: PUSH
98228: LD_INT 5
98230: PUSH
98231: EMPTY
98232: LIST
98233: LIST
98234: LIST
98235: LIST
98236: LIST
98237: IN
98238: IFFALSE 98424
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
98240: LD_ADDR_VAR 0 9
98244: PUSH
98245: LD_VAR 0 14
98249: PUSH
98250: LD_INT 1
98252: ARRAY
98253: PPUSH
98254: CALL_OW 266
98258: PPUSH
98259: LD_VAR 0 14
98263: PUSH
98264: LD_INT 1
98266: ARRAY
98267: PPUSH
98268: CALL_OW 250
98272: PPUSH
98273: LD_VAR 0 14
98277: PUSH
98278: LD_INT 1
98280: ARRAY
98281: PPUSH
98282: CALL_OW 251
98286: PPUSH
98287: LD_VAR 0 14
98291: PUSH
98292: LD_INT 1
98294: ARRAY
98295: PPUSH
98296: CALL_OW 254
98300: PPUSH
98301: LD_VAR 0 14
98305: PUSH
98306: LD_INT 1
98308: ARRAY
98309: PPUSH
98310: CALL_OW 248
98314: PPUSH
98315: LD_INT 0
98317: PPUSH
98318: CALL 27485 0 6
98322: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
98323: LD_ADDR_VAR 0 8
98327: PUSH
98328: LD_VAR 0 4
98332: PUSH
98333: LD_VAR 0 7
98337: ARRAY
98338: PPUSH
98339: LD_VAR 0 9
98343: PPUSH
98344: CALL 46155 0 2
98348: ST_TO_ADDR
// if j then
98349: LD_VAR 0 8
98353: IFFALSE 98422
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
98355: LD_VAR 0 8
98359: PUSH
98360: LD_INT 1
98362: ARRAY
98363: PPUSH
98364: LD_VAR 0 8
98368: PUSH
98369: LD_INT 2
98371: ARRAY
98372: PPUSH
98373: CALL_OW 488
98377: IFFALSE 98422
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
98379: LD_VAR 0 4
98383: PUSH
98384: LD_VAR 0 7
98388: ARRAY
98389: PPUSH
98390: LD_VAR 0 8
98394: PUSH
98395: LD_INT 1
98397: ARRAY
98398: PPUSH
98399: LD_VAR 0 8
98403: PUSH
98404: LD_INT 2
98406: ARRAY
98407: PPUSH
98408: CALL_OW 116
// attacking := true ;
98412: LD_ADDR_VAR 0 29
98416: PUSH
98417: LD_INT 1
98419: ST_TO_ADDR
// continue ;
98420: GO 95795
// end ; end else
98422: GO 98448
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98424: LD_VAR 0 4
98428: PUSH
98429: LD_VAR 0 7
98433: ARRAY
98434: PPUSH
98435: LD_VAR 0 14
98439: PUSH
98440: LD_INT 1
98442: ARRAY
98443: PPUSH
98444: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
98448: LD_VAR 0 4
98452: PUSH
98453: LD_VAR 0 7
98457: ARRAY
98458: PPUSH
98459: CALL_OW 265
98463: PUSH
98464: LD_INT 11
98466: EQUAL
98467: IFFALSE 98745
// begin k := 10 ;
98469: LD_ADDR_VAR 0 9
98473: PUSH
98474: LD_INT 10
98476: ST_TO_ADDR
// x := 0 ;
98477: LD_ADDR_VAR 0 10
98481: PUSH
98482: LD_INT 0
98484: ST_TO_ADDR
// if tmp < k then
98485: LD_VAR 0 14
98489: PUSH
98490: LD_VAR 0 9
98494: LESS
98495: IFFALSE 98507
// k := tmp ;
98497: LD_ADDR_VAR 0 9
98501: PUSH
98502: LD_VAR 0 14
98506: ST_TO_ADDR
// for j = k downto 1 do
98507: LD_ADDR_VAR 0 8
98511: PUSH
98512: DOUBLE
98513: LD_VAR 0 9
98517: INC
98518: ST_TO_ADDR
98519: LD_INT 1
98521: PUSH
98522: FOR_DOWNTO
98523: IFFALSE 98598
// begin if GetType ( tmp [ j ] ) = unit_human then
98525: LD_VAR 0 14
98529: PUSH
98530: LD_VAR 0 8
98534: ARRAY
98535: PPUSH
98536: CALL_OW 247
98540: PUSH
98541: LD_INT 1
98543: EQUAL
98544: IFFALSE 98596
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
98546: LD_VAR 0 4
98550: PUSH
98551: LD_VAR 0 7
98555: ARRAY
98556: PPUSH
98557: LD_VAR 0 14
98561: PUSH
98562: LD_VAR 0 8
98566: ARRAY
98567: PPUSH
98568: CALL 46426 0 2
// x := tmp [ j ] ;
98572: LD_ADDR_VAR 0 10
98576: PUSH
98577: LD_VAR 0 14
98581: PUSH
98582: LD_VAR 0 8
98586: ARRAY
98587: ST_TO_ADDR
// attacking := true ;
98588: LD_ADDR_VAR 0 29
98592: PUSH
98593: LD_INT 1
98595: ST_TO_ADDR
// end ; end ;
98596: GO 98522
98598: POP
98599: POP
// if not x then
98600: LD_VAR 0 10
98604: NOT
98605: IFFALSE 98745
// begin attacking := true ;
98607: LD_ADDR_VAR 0 29
98611: PUSH
98612: LD_INT 1
98614: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
98615: LD_VAR 0 4
98619: PUSH
98620: LD_VAR 0 7
98624: ARRAY
98625: PPUSH
98626: CALL_OW 250
98630: PPUSH
98631: LD_VAR 0 4
98635: PUSH
98636: LD_VAR 0 7
98640: ARRAY
98641: PPUSH
98642: CALL_OW 251
98646: PPUSH
98647: CALL_OW 546
98651: PUSH
98652: LD_INT 2
98654: ARRAY
98655: PUSH
98656: LD_VAR 0 14
98660: PUSH
98661: LD_INT 1
98663: ARRAY
98664: PPUSH
98665: CALL_OW 250
98669: PPUSH
98670: LD_VAR 0 14
98674: PUSH
98675: LD_INT 1
98677: ARRAY
98678: PPUSH
98679: CALL_OW 251
98683: PPUSH
98684: CALL_OW 546
98688: PUSH
98689: LD_INT 2
98691: ARRAY
98692: EQUAL
98693: IFFALSE 98721
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
98695: LD_VAR 0 4
98699: PUSH
98700: LD_VAR 0 7
98704: ARRAY
98705: PPUSH
98706: LD_VAR 0 14
98710: PUSH
98711: LD_INT 1
98713: ARRAY
98714: PPUSH
98715: CALL 46426 0 2
98719: GO 98745
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
98721: LD_VAR 0 4
98725: PUSH
98726: LD_VAR 0 7
98730: ARRAY
98731: PPUSH
98732: LD_VAR 0 14
98736: PUSH
98737: LD_INT 1
98739: ARRAY
98740: PPUSH
98741: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
98745: LD_VAR 0 4
98749: PUSH
98750: LD_VAR 0 7
98754: ARRAY
98755: PPUSH
98756: CALL_OW 264
98760: PUSH
98761: LD_INT 29
98763: EQUAL
98764: IFFALSE 99130
// begin if WantsToAttack ( group [ i ] ) in bombed then
98766: LD_VAR 0 4
98770: PUSH
98771: LD_VAR 0 7
98775: ARRAY
98776: PPUSH
98777: CALL_OW 319
98781: PUSH
98782: LD_VAR 0 28
98786: IN
98787: IFFALSE 98791
// continue ;
98789: GO 95795
// k := 8 ;
98791: LD_ADDR_VAR 0 9
98795: PUSH
98796: LD_INT 8
98798: ST_TO_ADDR
// x := 0 ;
98799: LD_ADDR_VAR 0 10
98803: PUSH
98804: LD_INT 0
98806: ST_TO_ADDR
// if tmp < k then
98807: LD_VAR 0 14
98811: PUSH
98812: LD_VAR 0 9
98816: LESS
98817: IFFALSE 98829
// k := tmp ;
98819: LD_ADDR_VAR 0 9
98823: PUSH
98824: LD_VAR 0 14
98828: ST_TO_ADDR
// for j = 1 to k do
98829: LD_ADDR_VAR 0 8
98833: PUSH
98834: DOUBLE
98835: LD_INT 1
98837: DEC
98838: ST_TO_ADDR
98839: LD_VAR 0 9
98843: PUSH
98844: FOR_TO
98845: IFFALSE 98977
// begin if GetType ( tmp [ j ] ) = unit_building then
98847: LD_VAR 0 14
98851: PUSH
98852: LD_VAR 0 8
98856: ARRAY
98857: PPUSH
98858: CALL_OW 247
98862: PUSH
98863: LD_INT 3
98865: EQUAL
98866: IFFALSE 98975
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
98868: LD_VAR 0 14
98872: PUSH
98873: LD_VAR 0 8
98877: ARRAY
98878: PUSH
98879: LD_VAR 0 28
98883: IN
98884: NOT
98885: PUSH
98886: LD_VAR 0 14
98890: PUSH
98891: LD_VAR 0 8
98895: ARRAY
98896: PPUSH
98897: CALL_OW 313
98901: AND
98902: IFFALSE 98975
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
98904: LD_VAR 0 4
98908: PUSH
98909: LD_VAR 0 7
98913: ARRAY
98914: PPUSH
98915: LD_VAR 0 14
98919: PUSH
98920: LD_VAR 0 8
98924: ARRAY
98925: PPUSH
98926: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
98930: LD_ADDR_VAR 0 28
98934: PUSH
98935: LD_VAR 0 28
98939: PPUSH
98940: LD_VAR 0 28
98944: PUSH
98945: LD_INT 1
98947: PLUS
98948: PPUSH
98949: LD_VAR 0 14
98953: PUSH
98954: LD_VAR 0 8
98958: ARRAY
98959: PPUSH
98960: CALL_OW 1
98964: ST_TO_ADDR
// attacking := true ;
98965: LD_ADDR_VAR 0 29
98969: PUSH
98970: LD_INT 1
98972: ST_TO_ADDR
// break ;
98973: GO 98977
// end ; end ;
98975: GO 98844
98977: POP
98978: POP
// if not attacking and f_attack_depot then
98979: LD_VAR 0 29
98983: NOT
98984: PUSH
98985: LD_VAR 0 25
98989: AND
98990: IFFALSE 99085
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
98992: LD_ADDR_VAR 0 13
98996: PUSH
98997: LD_VAR 0 14
99001: PPUSH
99002: LD_INT 2
99004: PUSH
99005: LD_INT 30
99007: PUSH
99008: LD_INT 0
99010: PUSH
99011: EMPTY
99012: LIST
99013: LIST
99014: PUSH
99015: LD_INT 30
99017: PUSH
99018: LD_INT 1
99020: PUSH
99021: EMPTY
99022: LIST
99023: LIST
99024: PUSH
99025: EMPTY
99026: LIST
99027: LIST
99028: LIST
99029: PPUSH
99030: CALL_OW 72
99034: ST_TO_ADDR
// if z then
99035: LD_VAR 0 13
99039: IFFALSE 99085
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
99041: LD_VAR 0 4
99045: PUSH
99046: LD_VAR 0 7
99050: ARRAY
99051: PPUSH
99052: LD_VAR 0 13
99056: PPUSH
99057: LD_VAR 0 4
99061: PUSH
99062: LD_VAR 0 7
99066: ARRAY
99067: PPUSH
99068: CALL_OW 74
99072: PPUSH
99073: CALL_OW 115
// attacking := true ;
99077: LD_ADDR_VAR 0 29
99081: PUSH
99082: LD_INT 1
99084: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
99085: LD_VAR 0 4
99089: PUSH
99090: LD_VAR 0 7
99094: ARRAY
99095: PPUSH
99096: CALL_OW 256
99100: PUSH
99101: LD_INT 500
99103: LESS
99104: IFFALSE 99130
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99106: LD_VAR 0 4
99110: PUSH
99111: LD_VAR 0 7
99115: ARRAY
99116: PPUSH
99117: LD_VAR 0 14
99121: PUSH
99122: LD_INT 1
99124: ARRAY
99125: PPUSH
99126: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
99130: LD_VAR 0 4
99134: PUSH
99135: LD_VAR 0 7
99139: ARRAY
99140: PPUSH
99141: CALL_OW 264
99145: PUSH
99146: LD_INT 49
99148: EQUAL
99149: IFFALSE 99270
// begin if not HasTask ( group [ i ] ) then
99151: LD_VAR 0 4
99155: PUSH
99156: LD_VAR 0 7
99160: ARRAY
99161: PPUSH
99162: CALL_OW 314
99166: NOT
99167: IFFALSE 99270
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
99169: LD_ADDR_VAR 0 9
99173: PUSH
99174: LD_INT 81
99176: PUSH
99177: LD_VAR 0 4
99181: PUSH
99182: LD_VAR 0 7
99186: ARRAY
99187: PPUSH
99188: CALL_OW 255
99192: PUSH
99193: EMPTY
99194: LIST
99195: LIST
99196: PPUSH
99197: CALL_OW 69
99201: PPUSH
99202: LD_VAR 0 4
99206: PUSH
99207: LD_VAR 0 7
99211: ARRAY
99212: PPUSH
99213: CALL_OW 74
99217: ST_TO_ADDR
// if k then
99218: LD_VAR 0 9
99222: IFFALSE 99270
// if GetDistUnits ( group [ i ] , k ) > 10 then
99224: LD_VAR 0 4
99228: PUSH
99229: LD_VAR 0 7
99233: ARRAY
99234: PPUSH
99235: LD_VAR 0 9
99239: PPUSH
99240: CALL_OW 296
99244: PUSH
99245: LD_INT 10
99247: GREATER
99248: IFFALSE 99270
// ComMoveUnit ( group [ i ] , k ) ;
99250: LD_VAR 0 4
99254: PUSH
99255: LD_VAR 0 7
99259: ARRAY
99260: PPUSH
99261: LD_VAR 0 9
99265: PPUSH
99266: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
99270: LD_VAR 0 4
99274: PUSH
99275: LD_VAR 0 7
99279: ARRAY
99280: PPUSH
99281: CALL_OW 256
99285: PUSH
99286: LD_INT 250
99288: LESS
99289: PUSH
99290: LD_VAR 0 4
99294: PUSH
99295: LD_VAR 0 7
99299: ARRAY
99300: PUSH
99301: LD_INT 21
99303: PUSH
99304: LD_INT 2
99306: PUSH
99307: EMPTY
99308: LIST
99309: LIST
99310: PUSH
99311: LD_INT 23
99313: PUSH
99314: LD_INT 2
99316: PUSH
99317: EMPTY
99318: LIST
99319: LIST
99320: PUSH
99321: EMPTY
99322: LIST
99323: LIST
99324: PPUSH
99325: CALL_OW 69
99329: IN
99330: AND
99331: IFFALSE 99456
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
99333: LD_ADDR_VAR 0 9
99337: PUSH
99338: LD_OWVAR 3
99342: PUSH
99343: LD_VAR 0 4
99347: PUSH
99348: LD_VAR 0 7
99352: ARRAY
99353: DIFF
99354: PPUSH
99355: LD_VAR 0 4
99359: PUSH
99360: LD_VAR 0 7
99364: ARRAY
99365: PPUSH
99366: CALL_OW 74
99370: ST_TO_ADDR
// if not k then
99371: LD_VAR 0 9
99375: NOT
99376: IFFALSE 99380
// continue ;
99378: GO 95795
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
99380: LD_VAR 0 9
99384: PUSH
99385: LD_INT 81
99387: PUSH
99388: LD_VAR 0 4
99392: PUSH
99393: LD_VAR 0 7
99397: ARRAY
99398: PPUSH
99399: CALL_OW 255
99403: PUSH
99404: EMPTY
99405: LIST
99406: LIST
99407: PPUSH
99408: CALL_OW 69
99412: IN
99413: PUSH
99414: LD_VAR 0 9
99418: PPUSH
99419: LD_VAR 0 4
99423: PUSH
99424: LD_VAR 0 7
99428: ARRAY
99429: PPUSH
99430: CALL_OW 296
99434: PUSH
99435: LD_INT 5
99437: LESS
99438: AND
99439: IFFALSE 99456
// ComAutodestruct ( group [ i ] ) ;
99441: LD_VAR 0 4
99445: PUSH
99446: LD_VAR 0 7
99450: ARRAY
99451: PPUSH
99452: CALL 46324 0 1
// end ; if f_attack_depot then
99456: LD_VAR 0 25
99460: IFFALSE 99572
// begin k := 6 ;
99462: LD_ADDR_VAR 0 9
99466: PUSH
99467: LD_INT 6
99469: ST_TO_ADDR
// if tmp < k then
99470: LD_VAR 0 14
99474: PUSH
99475: LD_VAR 0 9
99479: LESS
99480: IFFALSE 99492
// k := tmp ;
99482: LD_ADDR_VAR 0 9
99486: PUSH
99487: LD_VAR 0 14
99491: ST_TO_ADDR
// for j = 1 to k do
99492: LD_ADDR_VAR 0 8
99496: PUSH
99497: DOUBLE
99498: LD_INT 1
99500: DEC
99501: ST_TO_ADDR
99502: LD_VAR 0 9
99506: PUSH
99507: FOR_TO
99508: IFFALSE 99570
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
99510: LD_VAR 0 8
99514: PPUSH
99515: CALL_OW 266
99519: PUSH
99520: LD_INT 0
99522: PUSH
99523: LD_INT 1
99525: PUSH
99526: EMPTY
99527: LIST
99528: LIST
99529: IN
99530: IFFALSE 99568
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
99532: LD_VAR 0 4
99536: PUSH
99537: LD_VAR 0 7
99541: ARRAY
99542: PPUSH
99543: LD_VAR 0 14
99547: PUSH
99548: LD_VAR 0 8
99552: ARRAY
99553: PPUSH
99554: CALL_OW 115
// attacking := true ;
99558: LD_ADDR_VAR 0 29
99562: PUSH
99563: LD_INT 1
99565: ST_TO_ADDR
// break ;
99566: GO 99570
// end ;
99568: GO 99507
99570: POP
99571: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
99572: LD_VAR 0 4
99576: PUSH
99577: LD_VAR 0 7
99581: ARRAY
99582: PPUSH
99583: CALL_OW 302
99587: PUSH
99588: LD_VAR 0 29
99592: NOT
99593: AND
99594: IFFALSE 99916
// begin if GetTag ( group [ i ] ) = 71 then
99596: LD_VAR 0 4
99600: PUSH
99601: LD_VAR 0 7
99605: ARRAY
99606: PPUSH
99607: CALL_OW 110
99611: PUSH
99612: LD_INT 71
99614: EQUAL
99615: IFFALSE 99656
// begin if HasTask ( group [ i ] ) then
99617: LD_VAR 0 4
99621: PUSH
99622: LD_VAR 0 7
99626: ARRAY
99627: PPUSH
99628: CALL_OW 314
99632: IFFALSE 99638
// continue else
99634: GO 95795
99636: GO 99656
// SetTag ( group [ i ] , 0 ) ;
99638: LD_VAR 0 4
99642: PUSH
99643: LD_VAR 0 7
99647: ARRAY
99648: PPUSH
99649: LD_INT 0
99651: PPUSH
99652: CALL_OW 109
// end ; k := 8 ;
99656: LD_ADDR_VAR 0 9
99660: PUSH
99661: LD_INT 8
99663: ST_TO_ADDR
// x := 0 ;
99664: LD_ADDR_VAR 0 10
99668: PUSH
99669: LD_INT 0
99671: ST_TO_ADDR
// if tmp < k then
99672: LD_VAR 0 14
99676: PUSH
99677: LD_VAR 0 9
99681: LESS
99682: IFFALSE 99694
// k := tmp ;
99684: LD_ADDR_VAR 0 9
99688: PUSH
99689: LD_VAR 0 14
99693: ST_TO_ADDR
// for j = 1 to k do
99694: LD_ADDR_VAR 0 8
99698: PUSH
99699: DOUBLE
99700: LD_INT 1
99702: DEC
99703: ST_TO_ADDR
99704: LD_VAR 0 9
99708: PUSH
99709: FOR_TO
99710: IFFALSE 99808
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
99712: LD_VAR 0 14
99716: PUSH
99717: LD_VAR 0 8
99721: ARRAY
99722: PPUSH
99723: CALL_OW 247
99727: PUSH
99728: LD_INT 1
99730: EQUAL
99731: PUSH
99732: LD_VAR 0 14
99736: PUSH
99737: LD_VAR 0 8
99741: ARRAY
99742: PPUSH
99743: CALL_OW 256
99747: PUSH
99748: LD_INT 250
99750: LESS
99751: PUSH
99752: LD_VAR 0 20
99756: AND
99757: PUSH
99758: LD_VAR 0 20
99762: NOT
99763: PUSH
99764: LD_VAR 0 14
99768: PUSH
99769: LD_VAR 0 8
99773: ARRAY
99774: PPUSH
99775: CALL_OW 256
99779: PUSH
99780: LD_INT 250
99782: GREATEREQUAL
99783: AND
99784: OR
99785: AND
99786: IFFALSE 99806
// begin x := tmp [ j ] ;
99788: LD_ADDR_VAR 0 10
99792: PUSH
99793: LD_VAR 0 14
99797: PUSH
99798: LD_VAR 0 8
99802: ARRAY
99803: ST_TO_ADDR
// break ;
99804: GO 99808
// end ;
99806: GO 99709
99808: POP
99809: POP
// if x then
99810: LD_VAR 0 10
99814: IFFALSE 99838
// ComAttackUnit ( group [ i ] , x ) else
99816: LD_VAR 0 4
99820: PUSH
99821: LD_VAR 0 7
99825: ARRAY
99826: PPUSH
99827: LD_VAR 0 10
99831: PPUSH
99832: CALL_OW 115
99836: GO 99862
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
99838: LD_VAR 0 4
99842: PUSH
99843: LD_VAR 0 7
99847: ARRAY
99848: PPUSH
99849: LD_VAR 0 14
99853: PUSH
99854: LD_INT 1
99856: ARRAY
99857: PPUSH
99858: CALL_OW 115
// if not HasTask ( group [ i ] ) then
99862: LD_VAR 0 4
99866: PUSH
99867: LD_VAR 0 7
99871: ARRAY
99872: PPUSH
99873: CALL_OW 314
99877: NOT
99878: IFFALSE 99916
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
99880: LD_VAR 0 4
99884: PUSH
99885: LD_VAR 0 7
99889: ARRAY
99890: PPUSH
99891: LD_VAR 0 14
99895: PPUSH
99896: LD_VAR 0 4
99900: PUSH
99901: LD_VAR 0 7
99905: ARRAY
99906: PPUSH
99907: CALL_OW 74
99911: PPUSH
99912: CALL_OW 115
// end ; end ; end ;
99916: GO 95795
99918: POP
99919: POP
// wait ( 0 0$2 ) ;
99920: LD_INT 70
99922: PPUSH
99923: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
99927: LD_VAR 0 4
99931: NOT
99932: PUSH
99933: LD_VAR 0 4
99937: PUSH
99938: EMPTY
99939: EQUAL
99940: OR
99941: PUSH
99942: LD_INT 81
99944: PUSH
99945: LD_VAR 0 35
99949: PUSH
99950: EMPTY
99951: LIST
99952: LIST
99953: PPUSH
99954: CALL_OW 69
99958: NOT
99959: OR
99960: IFFALSE 95780
// end ;
99962: LD_VAR 0 2
99966: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
99967: LD_INT 0
99969: PPUSH
99970: PPUSH
99971: PPUSH
99972: PPUSH
99973: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
99974: LD_VAR 0 1
99978: NOT
99979: PUSH
99980: LD_EXP 59
99984: PUSH
99985: LD_VAR 0 1
99989: ARRAY
99990: NOT
99991: OR
99992: PUSH
99993: LD_VAR 0 2
99997: NOT
99998: OR
99999: PUSH
100000: LD_VAR 0 3
100004: NOT
100005: OR
100006: IFFALSE 100010
// exit ;
100008: GO 100523
// side := mc_sides [ base ] ;
100010: LD_ADDR_VAR 0 6
100014: PUSH
100015: LD_EXP 85
100019: PUSH
100020: LD_VAR 0 1
100024: ARRAY
100025: ST_TO_ADDR
// if not side then
100026: LD_VAR 0 6
100030: NOT
100031: IFFALSE 100035
// exit ;
100033: GO 100523
// for i in solds do
100035: LD_ADDR_VAR 0 7
100039: PUSH
100040: LD_VAR 0 2
100044: PUSH
100045: FOR_IN
100046: IFFALSE 100107
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
100048: LD_VAR 0 7
100052: PPUSH
100053: CALL_OW 310
100057: PPUSH
100058: CALL_OW 266
100062: PUSH
100063: LD_INT 32
100065: PUSH
100066: LD_INT 31
100068: PUSH
100069: EMPTY
100070: LIST
100071: LIST
100072: IN
100073: IFFALSE 100093
// solds := solds diff i else
100075: LD_ADDR_VAR 0 2
100079: PUSH
100080: LD_VAR 0 2
100084: PUSH
100085: LD_VAR 0 7
100089: DIFF
100090: ST_TO_ADDR
100091: GO 100105
// SetTag ( i , 18 ) ;
100093: LD_VAR 0 7
100097: PPUSH
100098: LD_INT 18
100100: PPUSH
100101: CALL_OW 109
100105: GO 100045
100107: POP
100108: POP
// if not solds then
100109: LD_VAR 0 2
100113: NOT
100114: IFFALSE 100118
// exit ;
100116: GO 100523
// repeat wait ( 0 0$1 ) ;
100118: LD_INT 35
100120: PPUSH
100121: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
100125: LD_ADDR_VAR 0 5
100129: PUSH
100130: LD_VAR 0 6
100134: PPUSH
100135: LD_VAR 0 3
100139: PPUSH
100140: CALL 16039 0 2
100144: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
100145: LD_EXP 59
100149: PUSH
100150: LD_VAR 0 1
100154: ARRAY
100155: NOT
100156: PUSH
100157: LD_EXP 59
100161: PUSH
100162: LD_VAR 0 1
100166: ARRAY
100167: PUSH
100168: EMPTY
100169: EQUAL
100170: OR
100171: IFFALSE 100208
// begin for i in solds do
100173: LD_ADDR_VAR 0 7
100177: PUSH
100178: LD_VAR 0 2
100182: PUSH
100183: FOR_IN
100184: IFFALSE 100197
// ComStop ( i ) ;
100186: LD_VAR 0 7
100190: PPUSH
100191: CALL_OW 141
100195: GO 100183
100197: POP
100198: POP
// solds := [ ] ;
100199: LD_ADDR_VAR 0 2
100203: PUSH
100204: EMPTY
100205: ST_TO_ADDR
// exit ;
100206: GO 100523
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
100208: LD_VAR 0 5
100212: NOT
100213: PUSH
100214: LD_VAR 0 5
100218: PUSH
100219: LD_INT 3
100221: GREATER
100222: OR
100223: PUSH
100224: LD_EXP 81
100228: PUSH
100229: LD_VAR 0 1
100233: ARRAY
100234: OR
100235: IFFALSE 100276
// begin for i in solds do
100237: LD_ADDR_VAR 0 7
100241: PUSH
100242: LD_VAR 0 2
100246: PUSH
100247: FOR_IN
100248: IFFALSE 100272
// if HasTask ( i ) then
100250: LD_VAR 0 7
100254: PPUSH
100255: CALL_OW 314
100259: IFFALSE 100270
// ComStop ( i ) ;
100261: LD_VAR 0 7
100265: PPUSH
100266: CALL_OW 141
100270: GO 100247
100272: POP
100273: POP
// break ;
100274: GO 100511
// end ; for i in solds do
100276: LD_ADDR_VAR 0 7
100280: PUSH
100281: LD_VAR 0 2
100285: PUSH
100286: FOR_IN
100287: IFFALSE 100503
// begin if IsInUnit ( i ) then
100289: LD_VAR 0 7
100293: PPUSH
100294: CALL_OW 310
100298: IFFALSE 100309
// ComExitBuilding ( i ) ;
100300: LD_VAR 0 7
100304: PPUSH
100305: CALL_OW 122
// if GetLives ( i ) > 333 then
100309: LD_VAR 0 7
100313: PPUSH
100314: CALL_OW 256
100318: PUSH
100319: LD_INT 333
100321: GREATER
100322: IFFALSE 100350
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
100324: LD_VAR 0 7
100328: PPUSH
100329: LD_VAR 0 5
100333: PPUSH
100334: LD_VAR 0 7
100338: PPUSH
100339: CALL_OW 74
100343: PPUSH
100344: CALL_OW 115
100348: GO 100501
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
100350: LD_ADDR_VAR 0 8
100354: PUSH
100355: LD_EXP 59
100359: PUSH
100360: LD_VAR 0 1
100364: ARRAY
100365: PPUSH
100366: LD_INT 2
100368: PUSH
100369: LD_INT 30
100371: PUSH
100372: LD_INT 0
100374: PUSH
100375: EMPTY
100376: LIST
100377: LIST
100378: PUSH
100379: LD_INT 30
100381: PUSH
100382: LD_INT 1
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PUSH
100389: LD_INT 30
100391: PUSH
100392: LD_INT 6
100394: PUSH
100395: EMPTY
100396: LIST
100397: LIST
100398: PUSH
100399: EMPTY
100400: LIST
100401: LIST
100402: LIST
100403: LIST
100404: PPUSH
100405: CALL_OW 72
100409: PPUSH
100410: LD_VAR 0 7
100414: PPUSH
100415: CALL_OW 74
100419: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
100420: LD_VAR 0 7
100424: PPUSH
100425: LD_VAR 0 8
100429: PPUSH
100430: CALL_OW 250
100434: PPUSH
100435: LD_INT 3
100437: PPUSH
100438: LD_INT 5
100440: PPUSH
100441: CALL_OW 272
100445: PPUSH
100446: LD_VAR 0 8
100450: PPUSH
100451: CALL_OW 251
100455: PPUSH
100456: LD_INT 3
100458: PPUSH
100459: LD_INT 5
100461: PPUSH
100462: CALL_OW 273
100466: PPUSH
100467: CALL_OW 111
// SetTag ( i , 0 ) ;
100471: LD_VAR 0 7
100475: PPUSH
100476: LD_INT 0
100478: PPUSH
100479: CALL_OW 109
// solds := solds diff i ;
100483: LD_ADDR_VAR 0 2
100487: PUSH
100488: LD_VAR 0 2
100492: PUSH
100493: LD_VAR 0 7
100497: DIFF
100498: ST_TO_ADDR
// continue ;
100499: GO 100286
// end ; end ;
100501: GO 100286
100503: POP
100504: POP
// until solds ;
100505: LD_VAR 0 2
100509: IFFALSE 100118
// MC_Reset ( base , 18 ) ;
100511: LD_VAR 0 1
100515: PPUSH
100516: LD_INT 18
100518: PPUSH
100519: CALL 54731 0 2
// end ;
100523: LD_VAR 0 4
100527: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
100528: LD_INT 0
100530: PPUSH
100531: PPUSH
100532: PPUSH
100533: PPUSH
100534: PPUSH
100535: PPUSH
100536: PPUSH
100537: PPUSH
100538: PPUSH
100539: PPUSH
100540: PPUSH
100541: PPUSH
100542: PPUSH
100543: PPUSH
100544: PPUSH
100545: PPUSH
100546: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
100547: LD_ADDR_VAR 0 13
100551: PUSH
100552: LD_EXP 59
100556: PUSH
100557: LD_VAR 0 1
100561: ARRAY
100562: PPUSH
100563: LD_INT 25
100565: PUSH
100566: LD_INT 3
100568: PUSH
100569: EMPTY
100570: LIST
100571: LIST
100572: PPUSH
100573: CALL_OW 72
100577: ST_TO_ADDR
// if mc_remote_driver [ base ] then
100578: LD_EXP 99
100582: PUSH
100583: LD_VAR 0 1
100587: ARRAY
100588: IFFALSE 100612
// mechs := mechs diff mc_remote_driver [ base ] ;
100590: LD_ADDR_VAR 0 13
100594: PUSH
100595: LD_VAR 0 13
100599: PUSH
100600: LD_EXP 99
100604: PUSH
100605: LD_VAR 0 1
100609: ARRAY
100610: DIFF
100611: ST_TO_ADDR
// for i in mechs do
100612: LD_ADDR_VAR 0 5
100616: PUSH
100617: LD_VAR 0 13
100621: PUSH
100622: FOR_IN
100623: IFFALSE 100658
// if GetTag ( i ) > 0 then
100625: LD_VAR 0 5
100629: PPUSH
100630: CALL_OW 110
100634: PUSH
100635: LD_INT 0
100637: GREATER
100638: IFFALSE 100656
// mechs := mechs diff i ;
100640: LD_ADDR_VAR 0 13
100644: PUSH
100645: LD_VAR 0 13
100649: PUSH
100650: LD_VAR 0 5
100654: DIFF
100655: ST_TO_ADDR
100656: GO 100622
100658: POP
100659: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
100660: LD_ADDR_VAR 0 9
100664: PUSH
100665: LD_EXP 59
100669: PUSH
100670: LD_VAR 0 1
100674: ARRAY
100675: PPUSH
100676: LD_INT 2
100678: PUSH
100679: LD_INT 25
100681: PUSH
100682: LD_INT 1
100684: PUSH
100685: EMPTY
100686: LIST
100687: LIST
100688: PUSH
100689: LD_INT 25
100691: PUSH
100692: LD_INT 5
100694: PUSH
100695: EMPTY
100696: LIST
100697: LIST
100698: PUSH
100699: LD_INT 25
100701: PUSH
100702: LD_INT 8
100704: PUSH
100705: EMPTY
100706: LIST
100707: LIST
100708: PUSH
100709: LD_INT 25
100711: PUSH
100712: LD_INT 9
100714: PUSH
100715: EMPTY
100716: LIST
100717: LIST
100718: PUSH
100719: EMPTY
100720: LIST
100721: LIST
100722: LIST
100723: LIST
100724: LIST
100725: PPUSH
100726: CALL_OW 72
100730: ST_TO_ADDR
// if not defenders and not solds then
100731: LD_VAR 0 2
100735: NOT
100736: PUSH
100737: LD_VAR 0 9
100741: NOT
100742: AND
100743: IFFALSE 100747
// exit ;
100745: GO 102373
// depot_under_attack := false ;
100747: LD_ADDR_VAR 0 17
100751: PUSH
100752: LD_INT 0
100754: ST_TO_ADDR
// sold_defenders := [ ] ;
100755: LD_ADDR_VAR 0 18
100759: PUSH
100760: EMPTY
100761: ST_TO_ADDR
// if mechs then
100762: LD_VAR 0 13
100766: IFFALSE 100895
// for i in defenders do
100768: LD_ADDR_VAR 0 5
100772: PUSH
100773: LD_VAR 0 2
100777: PUSH
100778: FOR_IN
100779: IFFALSE 100893
// begin SetTag ( i , 20 ) ;
100781: LD_VAR 0 5
100785: PPUSH
100786: LD_INT 20
100788: PPUSH
100789: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
100793: LD_VAR 0 5
100797: PPUSH
100798: CALL_OW 263
100802: PUSH
100803: LD_INT 1
100805: EQUAL
100806: PUSH
100807: LD_VAR 0 5
100811: PPUSH
100812: CALL_OW 311
100816: NOT
100817: AND
100818: PUSH
100819: LD_VAR 0 13
100823: AND
100824: IFFALSE 100891
// begin un := mechs [ 1 ] ;
100826: LD_ADDR_VAR 0 11
100830: PUSH
100831: LD_VAR 0 13
100835: PUSH
100836: LD_INT 1
100838: ARRAY
100839: ST_TO_ADDR
// ComExitBuilding ( un ) ;
100840: LD_VAR 0 11
100844: PPUSH
100845: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
100849: LD_VAR 0 11
100853: PPUSH
100854: LD_VAR 0 5
100858: PPUSH
100859: CALL_OW 180
// SetTag ( un , 19 ) ;
100863: LD_VAR 0 11
100867: PPUSH
100868: LD_INT 19
100870: PPUSH
100871: CALL_OW 109
// mechs := mechs diff un ;
100875: LD_ADDR_VAR 0 13
100879: PUSH
100880: LD_VAR 0 13
100884: PUSH
100885: LD_VAR 0 11
100889: DIFF
100890: ST_TO_ADDR
// end ; end ;
100891: GO 100778
100893: POP
100894: POP
// if solds then
100895: LD_VAR 0 9
100899: IFFALSE 100958
// for i in solds do
100901: LD_ADDR_VAR 0 5
100905: PUSH
100906: LD_VAR 0 9
100910: PUSH
100911: FOR_IN
100912: IFFALSE 100956
// if not GetTag ( i ) then
100914: LD_VAR 0 5
100918: PPUSH
100919: CALL_OW 110
100923: NOT
100924: IFFALSE 100954
// begin defenders := defenders union i ;
100926: LD_ADDR_VAR 0 2
100930: PUSH
100931: LD_VAR 0 2
100935: PUSH
100936: LD_VAR 0 5
100940: UNION
100941: ST_TO_ADDR
// SetTag ( i , 18 ) ;
100942: LD_VAR 0 5
100946: PPUSH
100947: LD_INT 18
100949: PPUSH
100950: CALL_OW 109
// end ;
100954: GO 100911
100956: POP
100957: POP
// repeat wait ( 0 0$1 ) ;
100958: LD_INT 35
100960: PPUSH
100961: CALL_OW 67
// enemy := mc_scan [ base ] ;
100965: LD_ADDR_VAR 0 3
100969: PUSH
100970: LD_EXP 82
100974: PUSH
100975: LD_VAR 0 1
100979: ARRAY
100980: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
100981: LD_EXP 59
100985: PUSH
100986: LD_VAR 0 1
100990: ARRAY
100991: NOT
100992: PUSH
100993: LD_EXP 59
100997: PUSH
100998: LD_VAR 0 1
101002: ARRAY
101003: PUSH
101004: EMPTY
101005: EQUAL
101006: OR
101007: IFFALSE 101044
// begin for i in defenders do
101009: LD_ADDR_VAR 0 5
101013: PUSH
101014: LD_VAR 0 2
101018: PUSH
101019: FOR_IN
101020: IFFALSE 101033
// ComStop ( i ) ;
101022: LD_VAR 0 5
101026: PPUSH
101027: CALL_OW 141
101031: GO 101019
101033: POP
101034: POP
// defenders := [ ] ;
101035: LD_ADDR_VAR 0 2
101039: PUSH
101040: EMPTY
101041: ST_TO_ADDR
// exit ;
101042: GO 102373
// end ; for i in defenders do
101044: LD_ADDR_VAR 0 5
101048: PUSH
101049: LD_VAR 0 2
101053: PUSH
101054: FOR_IN
101055: IFFALSE 101873
// begin e := NearestUnitToUnit ( enemy , i ) ;
101057: LD_ADDR_VAR 0 14
101061: PUSH
101062: LD_VAR 0 3
101066: PPUSH
101067: LD_VAR 0 5
101071: PPUSH
101072: CALL_OW 74
101076: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
101077: LD_ADDR_VAR 0 8
101081: PUSH
101082: LD_EXP 59
101086: PUSH
101087: LD_VAR 0 1
101091: ARRAY
101092: PPUSH
101093: LD_INT 2
101095: PUSH
101096: LD_INT 30
101098: PUSH
101099: LD_INT 0
101101: PUSH
101102: EMPTY
101103: LIST
101104: LIST
101105: PUSH
101106: LD_INT 30
101108: PUSH
101109: LD_INT 1
101111: PUSH
101112: EMPTY
101113: LIST
101114: LIST
101115: PUSH
101116: EMPTY
101117: LIST
101118: LIST
101119: LIST
101120: PPUSH
101121: CALL_OW 72
101125: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
101126: LD_ADDR_VAR 0 17
101130: PUSH
101131: LD_VAR 0 8
101135: NOT
101136: PUSH
101137: LD_VAR 0 8
101141: PPUSH
101142: LD_INT 3
101144: PUSH
101145: LD_INT 24
101147: PUSH
101148: LD_INT 600
101150: PUSH
101151: EMPTY
101152: LIST
101153: LIST
101154: PUSH
101155: EMPTY
101156: LIST
101157: LIST
101158: PPUSH
101159: CALL_OW 72
101163: OR
101164: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
101165: LD_VAR 0 5
101169: PPUSH
101170: CALL_OW 247
101174: PUSH
101175: LD_INT 2
101177: DOUBLE
101178: EQUAL
101179: IFTRUE 101183
101181: GO 101579
101183: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
101184: LD_VAR 0 5
101188: PPUSH
101189: CALL_OW 256
101193: PUSH
101194: LD_INT 650
101196: GREATER
101197: PUSH
101198: LD_VAR 0 5
101202: PPUSH
101203: LD_VAR 0 14
101207: PPUSH
101208: CALL_OW 296
101212: PUSH
101213: LD_INT 40
101215: LESS
101216: PUSH
101217: LD_VAR 0 14
101221: PPUSH
101222: LD_EXP 84
101226: PUSH
101227: LD_VAR 0 1
101231: ARRAY
101232: PPUSH
101233: CALL_OW 308
101237: OR
101238: AND
101239: IFFALSE 101361
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
101241: LD_VAR 0 5
101245: PPUSH
101246: CALL_OW 262
101250: PUSH
101251: LD_INT 1
101253: EQUAL
101254: PUSH
101255: LD_VAR 0 5
101259: PPUSH
101260: CALL_OW 261
101264: PUSH
101265: LD_INT 30
101267: LESS
101268: AND
101269: PUSH
101270: LD_VAR 0 8
101274: AND
101275: IFFALSE 101345
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
101277: LD_VAR 0 5
101281: PPUSH
101282: LD_VAR 0 8
101286: PPUSH
101287: LD_VAR 0 5
101291: PPUSH
101292: CALL_OW 74
101296: PPUSH
101297: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
101301: LD_VAR 0 5
101305: PPUSH
101306: LD_VAR 0 8
101310: PPUSH
101311: LD_VAR 0 5
101315: PPUSH
101316: CALL_OW 74
101320: PPUSH
101321: CALL_OW 296
101325: PUSH
101326: LD_INT 6
101328: LESS
101329: IFFALSE 101343
// SetFuel ( i , 100 ) ;
101331: LD_VAR 0 5
101335: PPUSH
101336: LD_INT 100
101338: PPUSH
101339: CALL_OW 240
// end else
101343: GO 101359
// ComAttackUnit ( i , e ) ;
101345: LD_VAR 0 5
101349: PPUSH
101350: LD_VAR 0 14
101354: PPUSH
101355: CALL_OW 115
// end else
101359: GO 101462
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
101361: LD_VAR 0 14
101365: PPUSH
101366: LD_EXP 84
101370: PUSH
101371: LD_VAR 0 1
101375: ARRAY
101376: PPUSH
101377: CALL_OW 308
101381: NOT
101382: PUSH
101383: LD_VAR 0 5
101387: PPUSH
101388: LD_VAR 0 14
101392: PPUSH
101393: CALL_OW 296
101397: PUSH
101398: LD_INT 40
101400: GREATEREQUAL
101401: AND
101402: PUSH
101403: LD_VAR 0 5
101407: PPUSH
101408: CALL_OW 256
101412: PUSH
101413: LD_INT 650
101415: LESSEQUAL
101416: OR
101417: PUSH
101418: LD_VAR 0 5
101422: PPUSH
101423: LD_EXP 83
101427: PUSH
101428: LD_VAR 0 1
101432: ARRAY
101433: PPUSH
101434: CALL_OW 308
101438: NOT
101439: AND
101440: IFFALSE 101462
// ComMoveToArea ( i , mc_parking [ base ] ) ;
101442: LD_VAR 0 5
101446: PPUSH
101447: LD_EXP 83
101451: PUSH
101452: LD_VAR 0 1
101456: ARRAY
101457: PPUSH
101458: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
101462: LD_VAR 0 5
101466: PPUSH
101467: CALL_OW 256
101471: PUSH
101472: LD_INT 998
101474: LESS
101475: PUSH
101476: LD_VAR 0 5
101480: PPUSH
101481: CALL_OW 263
101485: PUSH
101486: LD_INT 1
101488: EQUAL
101489: AND
101490: PUSH
101491: LD_VAR 0 5
101495: PPUSH
101496: CALL_OW 311
101500: AND
101501: PUSH
101502: LD_VAR 0 5
101506: PPUSH
101507: LD_EXP 83
101511: PUSH
101512: LD_VAR 0 1
101516: ARRAY
101517: PPUSH
101518: CALL_OW 308
101522: AND
101523: IFFALSE 101577
// begin mech := IsDrivenBy ( i ) ;
101525: LD_ADDR_VAR 0 10
101529: PUSH
101530: LD_VAR 0 5
101534: PPUSH
101535: CALL_OW 311
101539: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
101540: LD_VAR 0 10
101544: PPUSH
101545: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
101549: LD_VAR 0 10
101553: PPUSH
101554: LD_VAR 0 5
101558: PPUSH
101559: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
101563: LD_VAR 0 10
101567: PPUSH
101568: LD_VAR 0 5
101572: PPUSH
101573: CALL_OW 180
// end ; end ; unit_human :
101577: GO 101844
101579: LD_INT 1
101581: DOUBLE
101582: EQUAL
101583: IFTRUE 101587
101585: GO 101843
101587: POP
// begin b := IsInUnit ( i ) ;
101588: LD_ADDR_VAR 0 19
101592: PUSH
101593: LD_VAR 0 5
101597: PPUSH
101598: CALL_OW 310
101602: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
101603: LD_ADDR_VAR 0 20
101607: PUSH
101608: LD_VAR 0 19
101612: NOT
101613: PUSH
101614: LD_VAR 0 19
101618: PPUSH
101619: CALL_OW 266
101623: PUSH
101624: LD_INT 32
101626: PUSH
101627: LD_INT 31
101629: PUSH
101630: EMPTY
101631: LIST
101632: LIST
101633: IN
101634: OR
101635: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
101636: LD_VAR 0 17
101640: PUSH
101641: LD_VAR 0 2
101645: PPUSH
101646: LD_INT 21
101648: PUSH
101649: LD_INT 2
101651: PUSH
101652: EMPTY
101653: LIST
101654: LIST
101655: PPUSH
101656: CALL_OW 72
101660: PUSH
101661: LD_INT 1
101663: LESSEQUAL
101664: OR
101665: PUSH
101666: LD_VAR 0 20
101670: AND
101671: PUSH
101672: LD_VAR 0 5
101676: PUSH
101677: LD_VAR 0 18
101681: IN
101682: NOT
101683: AND
101684: IFFALSE 101777
// begin if b then
101686: LD_VAR 0 19
101690: IFFALSE 101739
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
101692: LD_VAR 0 19
101696: PPUSH
101697: LD_VAR 0 3
101701: PPUSH
101702: LD_VAR 0 19
101706: PPUSH
101707: CALL_OW 74
101711: PPUSH
101712: CALL_OW 296
101716: PUSH
101717: LD_INT 10
101719: LESS
101720: PUSH
101721: LD_VAR 0 19
101725: PPUSH
101726: CALL_OW 461
101730: PUSH
101731: LD_INT 7
101733: NONEQUAL
101734: AND
101735: IFFALSE 101739
// continue ;
101737: GO 101054
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
101739: LD_ADDR_VAR 0 18
101743: PUSH
101744: LD_VAR 0 18
101748: PPUSH
101749: LD_VAR 0 18
101753: PUSH
101754: LD_INT 1
101756: PLUS
101757: PPUSH
101758: LD_VAR 0 5
101762: PPUSH
101763: CALL_OW 1
101767: ST_TO_ADDR
// ComExitBuilding ( i ) ;
101768: LD_VAR 0 5
101772: PPUSH
101773: CALL_OW 122
// end ; if sold_defenders then
101777: LD_VAR 0 18
101781: IFFALSE 101841
// if i in sold_defenders then
101783: LD_VAR 0 5
101787: PUSH
101788: LD_VAR 0 18
101792: IN
101793: IFFALSE 101841
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
101795: LD_VAR 0 5
101799: PPUSH
101800: CALL_OW 314
101804: NOT
101805: PUSH
101806: LD_VAR 0 5
101810: PPUSH
101811: LD_VAR 0 14
101815: PPUSH
101816: CALL_OW 296
101820: PUSH
101821: LD_INT 30
101823: LESS
101824: AND
101825: IFFALSE 101841
// ComAttackUnit ( i , e ) ;
101827: LD_VAR 0 5
101831: PPUSH
101832: LD_VAR 0 14
101836: PPUSH
101837: CALL_OW 115
// end ; end ; end ;
101841: GO 101844
101843: POP
// if IsDead ( i ) then
101844: LD_VAR 0 5
101848: PPUSH
101849: CALL_OW 301
101853: IFFALSE 101871
// defenders := defenders diff i ;
101855: LD_ADDR_VAR 0 2
101859: PUSH
101860: LD_VAR 0 2
101864: PUSH
101865: LD_VAR 0 5
101869: DIFF
101870: ST_TO_ADDR
// end ;
101871: GO 101054
101873: POP
101874: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
101875: LD_VAR 0 3
101879: NOT
101880: PUSH
101881: LD_VAR 0 2
101885: NOT
101886: OR
101887: PUSH
101888: LD_EXP 59
101892: PUSH
101893: LD_VAR 0 1
101897: ARRAY
101898: NOT
101899: OR
101900: IFFALSE 100958
// MC_Reset ( base , 18 ) ;
101902: LD_VAR 0 1
101906: PPUSH
101907: LD_INT 18
101909: PPUSH
101910: CALL 54731 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
101914: LD_ADDR_VAR 0 2
101918: PUSH
101919: LD_VAR 0 2
101923: PUSH
101924: LD_VAR 0 2
101928: PPUSH
101929: LD_INT 2
101931: PUSH
101932: LD_INT 25
101934: PUSH
101935: LD_INT 1
101937: PUSH
101938: EMPTY
101939: LIST
101940: LIST
101941: PUSH
101942: LD_INT 25
101944: PUSH
101945: LD_INT 5
101947: PUSH
101948: EMPTY
101949: LIST
101950: LIST
101951: PUSH
101952: LD_INT 25
101954: PUSH
101955: LD_INT 8
101957: PUSH
101958: EMPTY
101959: LIST
101960: LIST
101961: PUSH
101962: LD_INT 25
101964: PUSH
101965: LD_INT 9
101967: PUSH
101968: EMPTY
101969: LIST
101970: LIST
101971: PUSH
101972: EMPTY
101973: LIST
101974: LIST
101975: LIST
101976: LIST
101977: LIST
101978: PPUSH
101979: CALL_OW 72
101983: DIFF
101984: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
101985: LD_VAR 0 3
101989: NOT
101990: PUSH
101991: LD_VAR 0 2
101995: PPUSH
101996: LD_INT 21
101998: PUSH
101999: LD_INT 2
102001: PUSH
102002: EMPTY
102003: LIST
102004: LIST
102005: PPUSH
102006: CALL_OW 72
102010: AND
102011: IFFALSE 102349
// begin tmp := FilterByTag ( defenders , 19 ) ;
102013: LD_ADDR_VAR 0 12
102017: PUSH
102018: LD_VAR 0 2
102022: PPUSH
102023: LD_INT 19
102025: PPUSH
102026: CALL 47799 0 2
102030: ST_TO_ADDR
// if tmp then
102031: LD_VAR 0 12
102035: IFFALSE 102105
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
102037: LD_ADDR_VAR 0 12
102041: PUSH
102042: LD_VAR 0 12
102046: PPUSH
102047: LD_INT 25
102049: PUSH
102050: LD_INT 3
102052: PUSH
102053: EMPTY
102054: LIST
102055: LIST
102056: PPUSH
102057: CALL_OW 72
102061: ST_TO_ADDR
// if tmp then
102062: LD_VAR 0 12
102066: IFFALSE 102105
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
102068: LD_ADDR_EXP 71
102072: PUSH
102073: LD_EXP 71
102077: PPUSH
102078: LD_VAR 0 1
102082: PPUSH
102083: LD_EXP 71
102087: PUSH
102088: LD_VAR 0 1
102092: ARRAY
102093: PUSH
102094: LD_VAR 0 12
102098: UNION
102099: PPUSH
102100: CALL_OW 1
102104: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
102105: LD_VAR 0 1
102109: PPUSH
102110: LD_INT 19
102112: PPUSH
102113: CALL 54731 0 2
// repeat wait ( 0 0$1 ) ;
102117: LD_INT 35
102119: PPUSH
102120: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
102124: LD_EXP 59
102128: PUSH
102129: LD_VAR 0 1
102133: ARRAY
102134: NOT
102135: PUSH
102136: LD_EXP 59
102140: PUSH
102141: LD_VAR 0 1
102145: ARRAY
102146: PUSH
102147: EMPTY
102148: EQUAL
102149: OR
102150: IFFALSE 102187
// begin for i in defenders do
102152: LD_ADDR_VAR 0 5
102156: PUSH
102157: LD_VAR 0 2
102161: PUSH
102162: FOR_IN
102163: IFFALSE 102176
// ComStop ( i ) ;
102165: LD_VAR 0 5
102169: PPUSH
102170: CALL_OW 141
102174: GO 102162
102176: POP
102177: POP
// defenders := [ ] ;
102178: LD_ADDR_VAR 0 2
102182: PUSH
102183: EMPTY
102184: ST_TO_ADDR
// exit ;
102185: GO 102373
// end ; for i in defenders do
102187: LD_ADDR_VAR 0 5
102191: PUSH
102192: LD_VAR 0 2
102196: PUSH
102197: FOR_IN
102198: IFFALSE 102287
// begin if not IsInArea ( i , mc_parking [ base ] ) then
102200: LD_VAR 0 5
102204: PPUSH
102205: LD_EXP 83
102209: PUSH
102210: LD_VAR 0 1
102214: ARRAY
102215: PPUSH
102216: CALL_OW 308
102220: NOT
102221: IFFALSE 102245
// ComMoveToArea ( i , mc_parking [ base ] ) else
102223: LD_VAR 0 5
102227: PPUSH
102228: LD_EXP 83
102232: PUSH
102233: LD_VAR 0 1
102237: ARRAY
102238: PPUSH
102239: CALL_OW 113
102243: GO 102285
// if GetControl ( i ) = control_manual then
102245: LD_VAR 0 5
102249: PPUSH
102250: CALL_OW 263
102254: PUSH
102255: LD_INT 1
102257: EQUAL
102258: IFFALSE 102285
// if IsDrivenBy ( i ) then
102260: LD_VAR 0 5
102264: PPUSH
102265: CALL_OW 311
102269: IFFALSE 102285
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
102271: LD_VAR 0 5
102275: PPUSH
102276: CALL_OW 311
102280: PPUSH
102281: CALL_OW 121
// end ;
102285: GO 102197
102287: POP
102288: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
102289: LD_VAR 0 2
102293: PPUSH
102294: LD_INT 95
102296: PUSH
102297: LD_EXP 83
102301: PUSH
102302: LD_VAR 0 1
102306: ARRAY
102307: PUSH
102308: EMPTY
102309: LIST
102310: LIST
102311: PPUSH
102312: CALL_OW 72
102316: PUSH
102317: LD_VAR 0 2
102321: EQUAL
102322: PUSH
102323: LD_EXP 82
102327: PUSH
102328: LD_VAR 0 1
102332: ARRAY
102333: OR
102334: PUSH
102335: LD_EXP 59
102339: PUSH
102340: LD_VAR 0 1
102344: ARRAY
102345: NOT
102346: OR
102347: IFFALSE 102117
// end ; MC_Reset ( base , 19 ) ;
102349: LD_VAR 0 1
102353: PPUSH
102354: LD_INT 19
102356: PPUSH
102357: CALL 54731 0 2
// MC_Reset ( base , 20 ) ;
102361: LD_VAR 0 1
102365: PPUSH
102366: LD_INT 20
102368: PPUSH
102369: CALL 54731 0 2
// end ;
102373: LD_VAR 0 4
102377: RET
