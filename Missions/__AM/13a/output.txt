// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 701 0 0
// InitMacro ;
  19: CALL 57017 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 49492 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 49492 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 49492 0 9
// PrepareNature ( 0 , 0 , [ 4 , 3 , 2 , 2 ] [ Difficulty ] , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 4
 124: PUSH
 125: LD_INT 3
 127: PUSH
 128: LD_INT 2
 130: PUSH
 131: LD_INT 2
 133: PUSH
 134: EMPTY
 135: LIST
 136: LIST
 137: LIST
 138: LIST
 139: PUSH
 140: LD_OWVAR 67
 144: ARRAY
 145: PPUSH
 146: LD_INT 0
 148: PPUSH
 149: LD_INT 0
 151: PPUSH
 152: LD_INT 0
 154: PPUSH
 155: LD_INT 0
 157: PPUSH
 158: LD_INT 12
 160: PPUSH
 161: LD_INT 0
 163: PPUSH
 164: CALL 49492 0 9
// if Difficulty < 4 then
 168: LD_OWVAR 67
 172: PUSH
 173: LD_INT 4
 175: LESS
 176: IFFALSE 185
// RemoveEnvironmentArea ( oilBlockArea ) ;
 178: LD_INT 24
 180: PPUSH
 181: CALL_OW 355
// PrepareArabian ;
 185: CALL 4085 0 0
// PrepareRussian ;
 189: CALL 2989 0 0
// PrepareAlliance ;
 193: CALL 911 0 0
// MC_Start ( ) ;
 197: CALL 59197 0 0
// if debug then
 201: LD_EXP 1
 205: IFFALSE 214
// FogOff ( 1 ) ;
 207: LD_INT 1
 209: PPUSH
 210: CALL_OW 344
// Action ;
 214: CALL 7736 0 0
// end ;
 218: END
// export function CustomInitMacro ; var i ; begin
 219: LD_INT 0
 221: PPUSH
 222: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 223: LD_ADDR_EXP 85
 227: PUSH
 228: LD_INT 1
 230: PUSH
 231: LD_INT 2
 233: PUSH
 234: EMPTY
 235: LIST
 236: LIST
 237: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 238: LD_ADDR_EXP 86
 242: PUSH
 243: LD_INT 3
 245: PUSH
 246: LD_INT 4
 248: PUSH
 249: EMPTY
 250: LIST
 251: LIST
 252: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 , 20 ] [ Difficulty ] , minefield ) ;
 253: LD_INT 1
 255: PPUSH
 256: LD_INT 12
 258: PUSH
 259: LD_INT 15
 261: PUSH
 262: LD_INT 18
 264: PUSH
 265: LD_INT 20
 267: PUSH
 268: EMPTY
 269: LIST
 270: LIST
 271: LIST
 272: LIST
 273: PUSH
 274: LD_OWVAR 67
 278: ARRAY
 279: PPUSH
 280: LD_INT 7
 282: PPUSH
 283: CALL 80914 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 287: LD_INT 1
 289: PPUSH
 290: LD_EXP 56
 294: PPUSH
 295: CALL 81359 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 299: LD_INT 1
 301: PPUSH
 302: LD_INT 6
 304: PPUSH
 305: CALL 81817 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 309: LD_INT 1
 311: PPUSH
 312: LD_INT 9
 314: PUSH
 315: EMPTY
 316: LIST
 317: PPUSH
 318: CALL 82086 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 322: LD_INT 1
 324: PPUSH
 325: LD_INT 13
 327: PUSH
 328: LD_INT 1
 330: PUSH
 331: LD_INT 2
 333: PUSH
 334: LD_INT 32
 336: PUSH
 337: EMPTY
 338: LIST
 339: LIST
 340: LIST
 341: LIST
 342: PUSH
 343: LD_INT 13
 345: PUSH
 346: LD_INT 1
 348: PUSH
 349: LD_INT 2
 351: PUSH
 352: LD_INT 88
 354: PUSH
 355: EMPTY
 356: LIST
 357: LIST
 358: LIST
 359: LIST
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: PPUSH
 365: CALL 81299 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 369: LD_INT 2
 371: PPUSH
 372: LD_INT 12
 374: PUSH
 375: LD_INT 14
 377: PUSH
 378: LD_INT 10
 380: PUSH
 381: LD_INT 11
 383: PUSH
 384: EMPTY
 385: LIST
 386: LIST
 387: LIST
 388: LIST
 389: PPUSH
 390: CALL 81993 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 394: LD_INT 2
 396: PPUSH
 397: LD_EXP 53
 401: PPUSH
 402: CALL 81359 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 406: LD_INT 2
 408: PPUSH
 409: LD_INT 8
 411: PPUSH
 412: CALL 81817 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 416: LD_INT 2
 418: PPUSH
 419: LD_INT 10
 421: PUSH
 422: EMPTY
 423: LIST
 424: PPUSH
 425: CALL 82086 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 429: LD_INT 2
 431: PPUSH
 432: LD_INT 6
 434: PUSH
 435: LD_INT 71
 437: PUSH
 438: LD_INT 116
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 4
 452: PUSH
 453: LD_INT 85
 455: PUSH
 456: LD_INT 116
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 32
 470: PUSH
 471: LD_INT 83
 473: PUSH
 474: LD_INT 111
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 87
 491: PUSH
 492: LD_INT 121
 494: PUSH
 495: LD_INT 4
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 88
 509: PUSH
 510: LD_INT 128
 512: PUSH
 513: LD_INT 4
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 32
 524: PUSH
 525: LD_INT 59
 527: PUSH
 528: LD_INT 89
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 69
 545: PUSH
 546: LD_INT 98
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 77
 563: PUSH
 564: LD_INT 103
 566: PUSH
 567: LD_INT 3
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: LD_INT 33
 578: PUSH
 579: LD_INT 83
 581: PUSH
 582: LD_INT 105
 584: PUSH
 585: LD_INT 3
 587: PUSH
 588: EMPTY
 589: LIST
 590: LIST
 591: LIST
 592: LIST
 593: PUSH
 594: LD_INT 33
 596: PUSH
 597: LD_INT 71
 599: PUSH
 600: LD_INT 125
 602: PUSH
 603: LD_INT 5
 605: PUSH
 606: EMPTY
 607: LIST
 608: LIST
 609: LIST
 610: LIST
 611: PUSH
 612: EMPTY
 613: LIST
 614: LIST
 615: LIST
 616: LIST
 617: LIST
 618: LIST
 619: LIST
 620: LIST
 621: LIST
 622: LIST
 623: PPUSH
 624: CALL 81143 0 2
// MC_SetAllowedTurretWeapons ( 2 , [ ru_gatling_gun , ru_rocket , ru_heavy_gun ] ) ;
 628: LD_INT 2
 630: PPUSH
 631: LD_INT 43
 633: PUSH
 634: LD_INT 47
 636: PUSH
 637: LD_INT 46
 639: PUSH
 640: EMPTY
 641: LIST
 642: LIST
 643: LIST
 644: PPUSH
 645: CALL 82404 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 649: LD_INT 2
 651: PPUSH
 652: LD_INT 21
 654: PUSH
 655: LD_INT 1
 657: PUSH
 658: LD_INT 3
 660: PUSH
 661: LD_INT 51
 663: PUSH
 664: EMPTY
 665: LIST
 666: LIST
 667: LIST
 668: LIST
 669: PUSH
 670: LD_INT 22
 672: PUSH
 673: LD_INT 1
 675: PUSH
 676: LD_INT 3
 678: PUSH
 679: LD_INT 52
 681: PUSH
 682: EMPTY
 683: LIST
 684: LIST
 685: LIST
 686: LIST
 687: PUSH
 688: EMPTY
 689: LIST
 690: LIST
 691: PPUSH
 692: CALL 81299 0 2
// end ;
 696: LD_VAR 0 1
 700: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , masha_killed , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 701: LD_INT 0
 703: PPUSH
// debug := false ;
 704: LD_ADDR_EXP 1
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// game := true ;
 712: LD_ADDR_EXP 2
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// gossudarov_arrive := false ;
 720: LD_ADDR_EXP 4
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// ru_lab_builded := false ;
 728: LD_ADDR_EXP 5
 732: PUSH
 733: LD_INT 0
 735: ST_TO_ADDR
// player_spotted := false ;
 736: LD_ADDR_EXP 6
 740: PUSH
 741: LD_INT 0
 743: ST_TO_ADDR
// first_attack := false ;
 744: LD_ADDR_EXP 7
 748: PUSH
 749: LD_INT 0
 751: ST_TO_ADDR
// ru_attackers := [ ] ;
 752: LD_ADDR_EXP 54
 756: PUSH
 757: EMPTY
 758: ST_TO_ADDR
// ar_base_spotted := false ;
 759: LD_ADDR_EXP 8
 763: PUSH
 764: LD_INT 0
 766: ST_TO_ADDR
// ar_active_attack := false ;
 767: LD_ADDR_EXP 9
 771: PUSH
 772: LD_INT 0
 774: ST_TO_ADDR
// ar_attackers := [ ] ;
 775: LD_ADDR_EXP 11
 779: PUSH
 780: EMPTY
 781: ST_TO_ADDR
// first_powell_attack := false ;
 782: LD_ADDR_EXP 12
 786: PUSH
 787: LD_INT 0
 789: ST_TO_ADDR
// masha_killed := false ;
 790: LD_ADDR_EXP 10
 794: PUSH
 795: LD_INT 0
 797: ST_TO_ADDR
// abdul_escaped := true ;
 798: LD_ADDR_EXP 13
 802: PUSH
 803: LD_INT 1
 805: ST_TO_ADDR
// loss_counter := 0 ;
 806: LD_ADDR_EXP 14
 810: PUSH
 811: LD_INT 0
 813: ST_TO_ADDR
// hack_counter := 0 ;
 814: LD_ADDR_EXP 15
 818: PUSH
 819: LD_INT 0
 821: ST_TO_ADDR
// end ;
 822: LD_VAR 0 1
 826: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 827: LD_EXP 50
 831: PPUSH
 832: CALL_OW 255
 836: PUSH
 837: LD_INT 7
 839: EQUAL
 840: PUSH
 841: LD_EXP 49
 845: PPUSH
 846: CALL_OW 255
 850: PUSH
 851: LD_INT 7
 853: EQUAL
 854: AND
 855: PUSH
 856: LD_EXP 50
 860: PPUSH
 861: CALL_OW 302
 865: AND
 866: PUSH
 867: LD_EXP 49
 871: PPUSH
 872: CALL_OW 302
 876: AND
 877: IFFALSE 889
 879: GO 881
 881: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 882: LD_STRING ACH_COMRADE
 884: PPUSH
 885: CALL_OW 543
 889: END
// every 0 0$1 trigger hack_counter >= 10 do
 890: LD_EXP 15
 894: PUSH
 895: LD_INT 10
 897: GREATEREQUAL
 898: IFFALSE 910
 900: GO 902
 902: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 903: LD_STRING ACH_HACK
 905: PPUSH
 906: CALL_OW 543
 910: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Mike ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 911: LD_INT 0
 913: PPUSH
 914: PPUSH
 915: PPUSH
 916: PPUSH
// uc_side := 7 ;
 917: LD_ADDR_OWVAR 20
 921: PUSH
 922: LD_INT 7
 924: ST_TO_ADDR
// uc_nation := 1 ;
 925: LD_ADDR_OWVAR 21
 929: PUSH
 930: LD_INT 1
 932: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 933: LD_ADDR_EXP 16
 937: PUSH
 938: LD_STRING JMM
 940: PPUSH
 941: LD_EXP 1
 945: NOT
 946: PPUSH
 947: LD_STRING 12a_
 949: PPUSH
 950: CALL 15501 0 3
 954: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 955: LD_EXP 16
 959: PPUSH
 960: LD_INT 71
 962: PPUSH
 963: LD_INT 23
 965: PPUSH
 966: LD_INT 0
 968: PPUSH
 969: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 973: LD_EXP 16
 977: PPUSH
 978: LD_INT 2
 980: PPUSH
 981: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 985: LD_ADDR_EXP 17
 989: PUSH
 990: LD_STRING Roth
 992: PPUSH
 993: LD_EXP 1
 997: NOT
 998: PPUSH
 999: LD_STRING 12a_
1001: PPUSH
1002: CALL 15501 0 3
1006: ST_TO_ADDR
// if Roth then
1007: LD_EXP 17
1011: IFFALSE 1031
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
1013: LD_EXP 17
1017: PPUSH
1018: LD_INT 71
1020: PPUSH
1021: LD_INT 21
1023: PPUSH
1024: LD_INT 0
1026: PPUSH
1027: CALL_OW 48
// Mike := PrepareUnit ( Mike , ( not debug ) , 12a_ ) ;
1031: LD_ADDR_EXP 33
1035: PUSH
1036: LD_STRING Mike
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_STRING 12a_
1047: PPUSH
1048: CALL 15501 0 3
1052: ST_TO_ADDR
// if Mike then
1053: LD_EXP 33
1057: IFFALSE 1074
// PlaceUnitArea ( Mike , alliance_start , false ) ;
1059: LD_EXP 33
1063: PPUSH
1064: LD_INT 13
1066: PPUSH
1067: LD_INT 0
1069: PPUSH
1070: CALL_OW 49
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
1074: LD_ADDR_EXP 18
1078: PUSH
1079: LD_STRING Lisa
1081: PPUSH
1082: LD_EXP 1
1086: NOT
1087: PPUSH
1088: LD_STRING 12a_
1090: PPUSH
1091: CALL 15501 0 3
1095: ST_TO_ADDR
// if Lisa then
1096: LD_EXP 18
1100: IFFALSE 1117
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
1102: LD_EXP 18
1106: PPUSH
1107: LD_INT 13
1109: PPUSH
1110: LD_INT 0
1112: PPUSH
1113: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1117: LD_ADDR_EXP 19
1121: PUSH
1122: LD_STRING Donaldson
1124: PPUSH
1125: LD_EXP 1
1129: NOT
1130: PPUSH
1131: LD_STRING 12a_
1133: PPUSH
1134: CALL 15501 0 3
1138: ST_TO_ADDR
// if Donaldson then
1139: LD_EXP 19
1143: IFFALSE 1160
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1145: LD_EXP 19
1149: PPUSH
1150: LD_INT 13
1152: PPUSH
1153: LD_INT 0
1155: PPUSH
1156: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1160: LD_ADDR_EXP 20
1164: PUSH
1165: LD_STRING Bobby
1167: PPUSH
1168: LD_EXP 1
1172: NOT
1173: PPUSH
1174: LD_STRING 12a_
1176: PPUSH
1177: CALL 15501 0 3
1181: ST_TO_ADDR
// if Bobby then
1182: LD_EXP 20
1186: IFFALSE 1203
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1188: LD_EXP 20
1192: PPUSH
1193: LD_INT 13
1195: PPUSH
1196: LD_INT 0
1198: PPUSH
1199: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1203: LD_ADDR_EXP 21
1207: PUSH
1208: LD_STRING Cyrus
1210: PPUSH
1211: LD_EXP 1
1215: NOT
1216: PPUSH
1217: LD_STRING 12a_
1219: PPUSH
1220: CALL 15501 0 3
1224: ST_TO_ADDR
// if Cyrus then
1225: LD_EXP 21
1229: IFFALSE 1246
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1231: LD_EXP 21
1235: PPUSH
1236: LD_INT 13
1238: PPUSH
1239: LD_INT 0
1241: PPUSH
1242: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1246: LD_ADDR_EXP 22
1250: PUSH
1251: LD_STRING Denis
1253: PPUSH
1254: LD_EXP 1
1258: NOT
1259: PPUSH
1260: LD_STRING 12a_
1262: PPUSH
1263: CALL 15501 0 3
1267: ST_TO_ADDR
// if Denis then
1268: LD_EXP 22
1272: IFFALSE 1289
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1274: LD_EXP 22
1278: PPUSH
1279: LD_INT 13
1281: PPUSH
1282: LD_INT 0
1284: PPUSH
1285: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1289: LD_ADDR_EXP 23
1293: PUSH
1294: LD_STRING Brown
1296: PPUSH
1297: LD_EXP 1
1301: NOT
1302: PPUSH
1303: LD_STRING 12a_
1305: PPUSH
1306: CALL 15501 0 3
1310: ST_TO_ADDR
// if Brown then
1311: LD_EXP 23
1315: IFFALSE 1332
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1317: LD_EXP 23
1321: PPUSH
1322: LD_INT 13
1324: PPUSH
1325: LD_INT 0
1327: PPUSH
1328: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1332: LD_ADDR_EXP 24
1336: PUSH
1337: LD_STRING Gladstone
1339: PPUSH
1340: LD_EXP 1
1344: NOT
1345: PPUSH
1346: LD_STRING 12a_
1348: PPUSH
1349: CALL 15501 0 3
1353: ST_TO_ADDR
// if Gladstone then
1354: LD_EXP 24
1358: IFFALSE 1375
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1360: LD_EXP 24
1364: PPUSH
1365: LD_INT 13
1367: PPUSH
1368: LD_INT 0
1370: PPUSH
1371: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1375: LD_ADDR_EXP 25
1379: PUSH
1380: LD_STRING Houten
1382: PPUSH
1383: LD_EXP 1
1387: NOT
1388: PPUSH
1389: LD_STRING 12a_
1391: PPUSH
1392: CALL 15501 0 3
1396: ST_TO_ADDR
// if Houten then
1397: LD_EXP 25
1401: IFFALSE 1418
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1403: LD_EXP 25
1407: PPUSH
1408: LD_INT 13
1410: PPUSH
1411: LD_INT 0
1413: PPUSH
1414: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1418: LD_ADDR_EXP 26
1422: PUSH
1423: LD_STRING Cornell
1425: PPUSH
1426: LD_EXP 1
1430: NOT
1431: PPUSH
1432: LD_STRING 12a_
1434: PPUSH
1435: CALL 15501 0 3
1439: ST_TO_ADDR
// if Cornel then
1440: LD_EXP 26
1444: IFFALSE 1461
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1446: LD_EXP 26
1450: PPUSH
1451: LD_INT 13
1453: PPUSH
1454: LD_INT 0
1456: PPUSH
1457: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1461: LD_ADDR_EXP 27
1465: PUSH
1466: LD_STRING Gary
1468: PPUSH
1469: LD_EXP 1
1473: NOT
1474: PPUSH
1475: LD_STRING 12a_
1477: PPUSH
1478: CALL 15501 0 3
1482: ST_TO_ADDR
// if Gary then
1483: LD_EXP 27
1487: IFFALSE 1504
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1489: LD_EXP 27
1493: PPUSH
1494: LD_INT 13
1496: PPUSH
1497: LD_INT 0
1499: PPUSH
1500: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1504: LD_ADDR_EXP 28
1508: PUSH
1509: LD_STRING Frank
1511: PPUSH
1512: LD_EXP 1
1516: NOT
1517: PPUSH
1518: LD_STRING 12a_
1520: PPUSH
1521: CALL 15501 0 3
1525: ST_TO_ADDR
// if Frank then
1526: LD_EXP 28
1530: IFFALSE 1547
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1532: LD_EXP 28
1536: PPUSH
1537: LD_INT 13
1539: PPUSH
1540: LD_INT 0
1542: PPUSH
1543: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1547: LD_ADDR_EXP 29
1551: PUSH
1552: LD_STRING Kikuchi
1554: PPUSH
1555: LD_EXP 1
1559: NOT
1560: PPUSH
1561: LD_STRING 12a_
1563: PPUSH
1564: CALL 15501 0 3
1568: ST_TO_ADDR
// if Kikuchi then
1569: LD_EXP 29
1573: IFFALSE 1590
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1575: LD_EXP 29
1579: PPUSH
1580: LD_INT 13
1582: PPUSH
1583: LD_INT 0
1585: PPUSH
1586: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1590: LD_ADDR_EXP 30
1594: PUSH
1595: LD_STRING Simms
1597: PPUSH
1598: LD_EXP 1
1602: NOT
1603: PPUSH
1604: LD_STRING 12a_
1606: PPUSH
1607: CALL 15501 0 3
1611: ST_TO_ADDR
// if Simms then
1612: LD_EXP 30
1616: IFFALSE 1633
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1618: LD_EXP 30
1622: PPUSH
1623: LD_INT 13
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1633: LD_ADDR_EXP 31
1637: PUSH
1638: LD_STRING Joan
1640: PPUSH
1641: LD_EXP 1
1645: NOT
1646: PPUSH
1647: LD_STRING 12a_
1649: PPUSH
1650: CALL 15501 0 3
1654: ST_TO_ADDR
// if Joan then
1655: LD_EXP 31
1659: IFFALSE 1676
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1661: LD_EXP 31
1665: PPUSH
1666: LD_INT 13
1668: PPUSH
1669: LD_INT 0
1671: PPUSH
1672: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1676: LD_ADDR_EXP 32
1680: PUSH
1681: LD_STRING DeltaDoctor
1683: PPUSH
1684: LD_EXP 1
1688: NOT
1689: PPUSH
1690: LD_STRING 12a_
1692: PPUSH
1693: CALL 15501 0 3
1697: ST_TO_ADDR
// if DeltaDoctor then
1698: LD_EXP 32
1702: IFFALSE 1719
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1704: LD_EXP 32
1708: PPUSH
1709: LD_INT 13
1711: PPUSH
1712: LD_INT 0
1714: PPUSH
1715: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1719: LD_ADDR_VAR 0 4
1723: PUSH
1724: LD_STRING 12a_others
1726: PPUSH
1727: CALL_OW 31
1731: ST_TO_ADDR
// if tmp then
1732: LD_VAR 0 4
1736: IFFALSE 1770
// for i in tmp do
1738: LD_ADDR_VAR 0 3
1742: PUSH
1743: LD_VAR 0 4
1747: PUSH
1748: FOR_IN
1749: IFFALSE 1768
// PlaceUnitArea ( i , alliance_start , false ) ;
1751: LD_VAR 0 3
1755: PPUSH
1756: LD_INT 13
1758: PPUSH
1759: LD_INT 0
1761: PPUSH
1762: CALL_OW 49
1766: GO 1748
1768: POP
1769: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1770: LD_INT 3
1772: PPUSH
1773: LD_INT 3
1775: PPUSH
1776: LD_INT 3
1778: PPUSH
1779: LD_INT 12
1781: PPUSH
1782: LD_INT 100
1784: PPUSH
1785: CALL 20341 0 5
// veh := CreateVehicle ;
1789: LD_ADDR_VAR 0 2
1793: PUSH
1794: CALL_OW 45
1798: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1799: LD_VAR 0 2
1803: PPUSH
1804: LD_INT 2
1806: PPUSH
1807: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1811: LD_VAR 0 2
1815: PPUSH
1816: LD_INT 60
1818: PPUSH
1819: LD_INT 6
1821: PPUSH
1822: LD_INT 0
1824: PPUSH
1825: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1829: LD_VAR 0 2
1833: PPUSH
1834: LD_INT 4
1836: PPUSH
1837: LD_INT 30
1839: PPUSH
1840: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1844: LD_STRING 11_artifact_captured
1846: PPUSH
1847: LD_INT 0
1849: PPUSH
1850: CALL_OW 30
1854: IFFALSE 1930
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1856: LD_INT 3
1858: PPUSH
1859: LD_INT 3
1861: PPUSH
1862: LD_INT 3
1864: PPUSH
1865: LD_INT 12
1867: PPUSH
1868: LD_INT 100
1870: PPUSH
1871: CALL 20341 0 5
// veh := CreateVehicle ;
1875: LD_ADDR_VAR 0 2
1879: PUSH
1880: CALL_OW 45
1884: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1885: LD_VAR 0 2
1889: PPUSH
1890: LD_INT 3
1892: PPUSH
1893: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1897: LD_VAR 0 2
1901: PPUSH
1902: LD_INT 75
1904: PPUSH
1905: LD_INT 6
1907: PPUSH
1908: LD_INT 0
1910: PPUSH
1911: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1915: LD_VAR 0 2
1919: PPUSH
1920: LD_INT 4
1922: PPUSH
1923: LD_INT 50
1925: PPUSH
1926: CALL_OW 290
// end ; end ;
1930: LD_VAR 0 1
1934: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1935: LD_INT 0
1937: PPUSH
1938: PPUSH
1939: PPUSH
1940: PPUSH
// uc_side := 6 ;
1941: LD_ADDR_OWVAR 20
1945: PUSH
1946: LD_INT 6
1948: ST_TO_ADDR
// uc_nation := 3 ;
1949: LD_ADDR_OWVAR 21
1953: PUSH
1954: LD_INT 3
1956: ST_TO_ADDR
// InitHc ;
1957: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1961: LD_ADDR_EXP 34
1965: PUSH
1966: LD_STRING Gossudarov
1968: PPUSH
1969: CALL_OW 25
1973: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1974: LD_ADDR_EXP 35
1978: PUSH
1979: LD_STRING Kirilenkova
1981: PPUSH
1982: CALL_OW 25
1986: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1987: LD_ADDR_EXP 36
1991: PUSH
1992: LD_STRING Titov
1994: PPUSH
1995: CALL_OW 25
1999: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
2000: LD_ADDR_EXP 41
2004: PUSH
2005: LD_STRING Oblukov
2007: PPUSH
2008: CALL_OW 25
2012: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
2013: LD_ADDR_EXP 38
2017: PUSH
2018: LD_STRING Dolgov
2020: PPUSH
2021: CALL_OW 25
2025: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
2026: LD_ADDR_EXP 39
2030: PUSH
2031: LD_STRING Petrosyan
2033: PPUSH
2034: CALL_OW 25
2038: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
2039: LD_ADDR_EXP 40
2043: PUSH
2044: LD_STRING Scholtze
2046: PPUSH
2047: CALL_OW 25
2051: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
2052: LD_ADDR_EXP 42
2056: PUSH
2057: LD_STRING Kapitsova
2059: PPUSH
2060: CALL_OW 25
2064: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
2065: LD_ADDR_VAR 0 2
2069: PUSH
2070: LD_EXP 34
2074: PUSH
2075: LD_EXP 35
2079: PUSH
2080: LD_EXP 36
2084: PUSH
2085: LD_EXP 41
2089: PUSH
2090: LD_EXP 38
2094: PUSH
2095: LD_EXP 39
2099: PUSH
2100: LD_EXP 40
2104: PUSH
2105: LD_EXP 42
2109: PUSH
2110: EMPTY
2111: LIST
2112: LIST
2113: LIST
2114: LIST
2115: LIST
2116: LIST
2117: LIST
2118: LIST
2119: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2120: LD_INT 1
2122: PPUSH
2123: LD_INT 4
2125: PPUSH
2126: LD_INT 8
2128: PPUSH
2129: CALL_OW 380
// un := CreateHuman ;
2133: LD_ADDR_VAR 0 4
2137: PUSH
2138: CALL_OW 44
2142: ST_TO_ADDR
// tmp := tmp ^ un ;
2143: LD_ADDR_VAR 0 2
2147: PUSH
2148: LD_VAR 0 2
2152: PUSH
2153: LD_VAR 0 4
2157: ADD
2158: ST_TO_ADDR
// for i in tmp do
2159: LD_ADDR_VAR 0 3
2163: PUSH
2164: LD_VAR 0 2
2168: PUSH
2169: FOR_IN
2170: IFFALSE 2189
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2172: LD_VAR 0 3
2176: PPUSH
2177: LD_INT 14
2179: PPUSH
2180: LD_INT 0
2182: PPUSH
2183: CALL_OW 49
2187: GO 2169
2189: POP
2190: POP
// if freedom then
2191: LD_EXP 3
2195: IFFALSE 2228
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) else
2197: LD_VAR 0 2
2201: PPUSH
2202: LD_EXP 3
2206: PPUSH
2207: CALL_OW 250
2211: PPUSH
2212: LD_EXP 3
2216: PPUSH
2217: CALL_OW 251
2221: PPUSH
2222: CALL_OW 111
2226: GO 2243
// ComMoveXY ( tmp , 70 , 48 ) ;
2228: LD_VAR 0 2
2232: PPUSH
2233: LD_INT 70
2235: PPUSH
2236: LD_INT 48
2238: PPUSH
2239: CALL_OW 111
// end ;
2243: LD_VAR 0 1
2247: RET
// export function PrepareBelkov ; begin
2248: LD_INT 0
2250: PPUSH
// uc_side := 4 ;
2251: LD_ADDR_OWVAR 20
2255: PUSH
2256: LD_INT 4
2258: ST_TO_ADDR
// uc_nation := 3 ;
2259: LD_ADDR_OWVAR 21
2263: PUSH
2264: LD_INT 3
2266: ST_TO_ADDR
// InitHc ;
2267: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2271: LD_ADDR_EXP 49
2275: PUSH
2276: LD_STRING Belkov
2278: PPUSH
2279: CALL_OW 25
2283: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2284: LD_EXP 49
2288: PPUSH
2289: LD_INT 14
2291: PPUSH
2292: LD_INT 0
2294: PPUSH
2295: CALL_OW 49
// end ;
2299: LD_VAR 0 1
2303: RET
// export function PrepareGnyevko ; begin
2304: LD_INT 0
2306: PPUSH
// uc_side := 4 ;
2307: LD_ADDR_OWVAR 20
2311: PUSH
2312: LD_INT 4
2314: ST_TO_ADDR
// uc_nation := 3 ;
2315: LD_ADDR_OWVAR 21
2319: PUSH
2320: LD_INT 3
2322: ST_TO_ADDR
// InitHc ;
2323: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2327: LD_ADDR_EXP 50
2331: PUSH
2332: LD_STRING Gnyevko
2334: PPUSH
2335: CALL_OW 25
2339: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2340: LD_EXP 50
2344: PPUSH
2345: LD_INT 14
2347: PPUSH
2348: LD_INT 0
2350: PPUSH
2351: CALL_OW 49
// end ;
2355: LD_VAR 0 1
2359: RET
// export function PrepareBurlak ; var i , tmp ; begin
2360: LD_INT 0
2362: PPUSH
2363: PPUSH
2364: PPUSH
// uc_side := 4 ;
2365: LD_ADDR_OWVAR 20
2369: PUSH
2370: LD_INT 4
2372: ST_TO_ADDR
// uc_nation := 3 ;
2373: LD_ADDR_OWVAR 21
2377: PUSH
2378: LD_INT 3
2380: ST_TO_ADDR
// InitHc ;
2381: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2385: LD_ADDR_EXP 48
2389: PUSH
2390: LD_STRING Burlak
2392: PPUSH
2393: CALL_OW 25
2397: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun , ru_heavy_machine_gun ] [ Difficulty ] , 0 ) ;
2398: LD_INT 24
2400: PUSH
2401: LD_INT 23
2403: PUSH
2404: LD_INT 22
2406: PUSH
2407: LD_INT 22
2409: PUSH
2410: EMPTY
2411: LIST
2412: LIST
2413: LIST
2414: LIST
2415: PUSH
2416: LD_OWVAR 67
2420: ARRAY
2421: PPUSH
2422: LD_INT 1
2424: PPUSH
2425: LD_INT 1
2427: PPUSH
2428: LD_INT 45
2430: PUSH
2431: LD_INT 44
2433: PUSH
2434: LD_INT 43
2436: PUSH
2437: LD_INT 42
2439: PUSH
2440: EMPTY
2441: LIST
2442: LIST
2443: LIST
2444: LIST
2445: PUSH
2446: LD_OWVAR 67
2450: ARRAY
2451: PPUSH
2452: LD_INT 0
2454: PPUSH
2455: CALL 20341 0 5
// Masha := CreateVehicle ;
2459: LD_ADDR_EXP 51
2463: PUSH
2464: CALL_OW 45
2468: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2469: LD_EXP 51
2473: PUSH
2474: LD_EXP 48
2478: PUSH
2479: EMPTY
2480: LIST
2481: LIST
2482: PPUSH
2483: LD_INT 499
2485: PPUSH
2486: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2490: LD_EXP 51
2494: PPUSH
2495: LD_INT 3
2497: PPUSH
2498: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2502: LD_EXP 51
2506: PPUSH
2507: LD_INT 1
2509: PPUSH
2510: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2514: LD_INT 1
2516: PPUSH
2517: LD_INT 18
2519: PPUSH
2520: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2524: LD_INT 35
2526: PPUSH
2527: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2531: LD_ADDR_VAR 0 3
2535: PUSH
2536: LD_INT 18
2538: PPUSH
2539: EMPTY
2540: PPUSH
2541: CALL_OW 70
2545: ST_TO_ADDR
// if tmp then
2546: LD_VAR 0 3
2550: IFFALSE 2584
// for i in tmp do
2552: LD_ADDR_VAR 0 2
2556: PUSH
2557: LD_VAR 0 3
2561: PUSH
2562: FOR_IN
2563: IFFALSE 2582
// ComMoveXY ( i , 114 , 9 ) ;
2565: LD_VAR 0 2
2569: PPUSH
2570: LD_INT 114
2572: PPUSH
2573: LD_INT 9
2575: PPUSH
2576: CALL_OW 111
2580: GO 2562
2582: POP
2583: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2584: LD_INT 18
2586: PPUSH
2587: EMPTY
2588: PPUSH
2589: CALL_OW 70
2593: NOT
2594: PUSH
2595: LD_INT 123
2597: PPUSH
2598: LD_INT 3
2600: PPUSH
2601: CALL_OW 428
2605: PUSH
2606: LD_INT 0
2608: EQUAL
2609: AND
2610: IFFALSE 2524
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2612: LD_EXP 51
2616: PPUSH
2617: LD_INT 123
2619: PPUSH
2620: LD_INT 3
2622: PPUSH
2623: LD_INT 0
2625: PPUSH
2626: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2630: LD_EXP 48
2634: PPUSH
2635: LD_INT 125
2637: PPUSH
2638: LD_INT 1
2640: PPUSH
2641: LD_INT 0
2643: PPUSH
2644: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2648: LD_EXP 48
2652: PPUSH
2653: LD_EXP 51
2657: PPUSH
2658: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2662: LD_INT 10
2664: PPUSH
2665: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2669: LD_EXP 51
2673: PPUSH
2674: LD_INT 110
2676: PPUSH
2677: LD_INT 10
2679: PPUSH
2680: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2684: LD_ADDR_EXP 44
2688: PUSH
2689: LD_STRING Petrovova
2691: PPUSH
2692: CALL_OW 25
2696: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2697: LD_ADDR_EXP 46
2701: PUSH
2702: LD_STRING Kuzmov
2704: PPUSH
2705: CALL_OW 25
2709: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2710: LD_ADDR_EXP 45
2714: PUSH
2715: LD_STRING Kovalyuk
2717: PPUSH
2718: CALL_OW 25
2722: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2723: LD_ADDR_EXP 43
2727: PUSH
2728: LD_STRING Lipshchin
2730: PPUSH
2731: CALL_OW 25
2735: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2736: LD_ADDR_EXP 47
2740: PUSH
2741: LD_STRING Karamazov
2743: PPUSH
2744: CALL_OW 25
2748: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2749: LD_ADDR_VAR 0 3
2753: PUSH
2754: LD_EXP 44
2758: PUSH
2759: LD_EXP 46
2763: PUSH
2764: LD_EXP 45
2768: PUSH
2769: LD_EXP 43
2773: PUSH
2774: LD_EXP 47
2778: PUSH
2779: EMPTY
2780: LIST
2781: LIST
2782: LIST
2783: LIST
2784: LIST
2785: ST_TO_ADDR
// for i in tmp do
2786: LD_ADDR_VAR 0 2
2790: PUSH
2791: LD_VAR 0 3
2795: PUSH
2796: FOR_IN
2797: IFFALSE 2836
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2799: LD_VAR 0 2
2803: PPUSH
2804: LD_INT 399
2806: PPUSH
2807: LD_INT 799
2809: PPUSH
2810: CALL_OW 12
2814: PPUSH
2815: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2819: LD_VAR 0 2
2823: PPUSH
2824: LD_INT 19
2826: PPUSH
2827: LD_INT 0
2829: PPUSH
2830: CALL_OW 49
// end ;
2834: GO 2796
2836: POP
2837: POP
// ComMoveXY ( tmp , 112 , 5 ) ;
2838: LD_VAR 0 3
2842: PPUSH
2843: LD_INT 112
2845: PPUSH
2846: LD_INT 5
2848: PPUSH
2849: CALL_OW 111
// AddComHold ( tmp ) ;
2853: LD_VAR 0 3
2857: PPUSH
2858: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2862: LD_ADDR_VAR 0 2
2866: PUSH
2867: LD_VAR 0 3
2871: PPUSH
2872: LD_INT 25
2874: PUSH
2875: LD_INT 1
2877: PUSH
2878: EMPTY
2879: LIST
2880: LIST
2881: PPUSH
2882: CALL_OW 72
2886: PUSH
2887: FOR_IN
2888: IFFALSE 2928
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2890: LD_VAR 0 2
2894: PPUSH
2895: LD_INT 20
2897: PPUSH
2898: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2902: LD_VAR 0 2
2906: PPUSH
2907: LD_INT 147
2909: PPUSH
2910: LD_INT 45
2912: PPUSH
2913: CALL_OW 178
// AddComCrawl ( i ) ;
2917: LD_VAR 0 2
2921: PPUSH
2922: CALL_OW 197
// end ;
2926: GO 2887
2928: POP
2929: POP
// repeat wait ( 0 0$1 ) ;
2930: LD_INT 35
2932: PPUSH
2933: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2937: LD_EXP 51
2941: PPUSH
2942: LD_INT 110
2944: PPUSH
2945: LD_INT 10
2947: PPUSH
2948: CALL_OW 307
2952: PUSH
2953: LD_EXP 51
2957: PPUSH
2958: CALL_OW 305
2962: NOT
2963: OR
2964: IFFALSE 2930
// ComStop ( Burlak ) ;
2966: LD_EXP 48
2970: PPUSH
2971: CALL_OW 141
// AddComHold ( Burlak ) ;
2975: LD_EXP 48
2979: PPUSH
2980: CALL_OW 200
// end ; end_of_file
2984: LD_VAR 0 1
2988: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp , b ; begin
2989: LD_INT 0
2991: PPUSH
2992: PPUSH
2993: PPUSH
2994: PPUSH
2995: PPUSH
// uc_side := 3 ;
2996: LD_ADDR_OWVAR 20
3000: PUSH
3001: LD_INT 3
3003: ST_TO_ADDR
// uc_nation := 3 ;
3004: LD_ADDR_OWVAR 21
3008: PUSH
3009: LD_INT 3
3011: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
3012: LD_ADDR_EXP 52
3016: PUSH
3017: LD_INT 47
3019: PPUSH
3020: LD_INT 4
3022: PPUSH
3023: LD_STRING 
3025: PPUSH
3026: LD_INT 7
3028: PUSH
3029: LD_INT 8
3031: PUSH
3032: LD_INT 9
3034: PUSH
3035: LD_INT 10
3037: PUSH
3038: EMPTY
3039: LIST
3040: LIST
3041: LIST
3042: LIST
3043: PUSH
3044: LD_OWVAR 67
3048: ARRAY
3049: PPUSH
3050: LD_INT 10000
3052: PUSH
3053: LD_INT 3000
3055: PUSH
3056: LD_INT 300
3058: PUSH
3059: EMPTY
3060: LIST
3061: LIST
3062: LIST
3063: PPUSH
3064: LD_INT 9
3066: PUSH
3067: LD_INT 5
3069: PUSH
3070: LD_INT 6
3072: PUSH
3073: LD_INT 6
3075: PUSH
3076: EMPTY
3077: LIST
3078: LIST
3079: LIST
3080: LIST
3081: PPUSH
3082: CALL 23794 0 6
3086: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
3087: LD_ADDR_EXP 61
3091: PUSH
3092: LD_EXP 61
3096: PPUSH
3097: LD_INT 2
3099: PPUSH
3100: LD_EXP 52
3104: PPUSH
3105: CALL_OW 1
3109: ST_TO_ADDR
// tmp := [ ] ;
3110: LD_ADDR_VAR 0 4
3114: PUSH
3115: EMPTY
3116: ST_TO_ADDR
// for i = 1 to 4 do
3117: LD_ADDR_VAR 0 2
3121: PUSH
3122: DOUBLE
3123: LD_INT 1
3125: DEC
3126: ST_TO_ADDR
3127: LD_INT 4
3129: PUSH
3130: FOR_TO
3131: IFFALSE 3224
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
3133: LD_INT 22
3135: PPUSH
3136: LD_INT 3
3138: PPUSH
3139: LD_INT 3
3141: PPUSH
3142: LD_INT 43
3144: PUSH
3145: LD_INT 45
3147: PUSH
3148: LD_INT 45
3150: PUSH
3151: LD_INT 44
3153: PUSH
3154: EMPTY
3155: LIST
3156: LIST
3157: LIST
3158: LIST
3159: PUSH
3160: LD_VAR 0 2
3164: PUSH
3165: LD_INT 4
3167: MOD
3168: PUSH
3169: LD_INT 1
3171: PLUS
3172: ARRAY
3173: PPUSH
3174: LD_INT 100
3176: PPUSH
3177: CALL 20341 0 5
// veh := CreateVehicle ;
3181: LD_ADDR_VAR 0 3
3185: PUSH
3186: CALL_OW 45
3190: ST_TO_ADDR
// tmp := tmp ^ veh ;
3191: LD_ADDR_VAR 0 4
3195: PUSH
3196: LD_VAR 0 4
3200: PUSH
3201: LD_VAR 0 3
3205: ADD
3206: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3207: LD_VAR 0 3
3211: PPUSH
3212: LD_INT 2
3214: PPUSH
3215: LD_INT 0
3217: PPUSH
3218: CALL_OW 49
// end ;
3222: GO 3130
3224: POP
3225: POP
// russian_guard := tmp ;
3226: LD_ADDR_EXP 53
3230: PUSH
3231: LD_VAR 0 4
3235: ST_TO_ADDR
// if Difficulty >= 3 then
3236: LD_OWVAR 67
3240: PUSH
3241: LD_INT 3
3243: GREATEREQUAL
3244: IFFALSE 3308
// begin bc_type := b_breastwork ;
3246: LD_ADDR_OWVAR 42
3250: PUSH
3251: LD_INT 31
3253: ST_TO_ADDR
// bc_level := 10 ;
3254: LD_ADDR_OWVAR 43
3258: PUSH
3259: LD_INT 10
3261: ST_TO_ADDR
// b := CreateAndPlaceBuildingXYD ( 96 , 105 , 3 ) ;
3262: LD_ADDR_VAR 0 5
3266: PUSH
3267: LD_INT 96
3269: PPUSH
3270: LD_INT 105
3272: PPUSH
3273: LD_INT 3
3275: PPUSH
3276: CALL_OW 47
3280: ST_TO_ADDR
// PrepareHuman ( false , class_bazooker , 10 ) ;
3281: LD_INT 0
3283: PPUSH
3284: LD_INT 9
3286: PPUSH
3287: LD_INT 10
3289: PPUSH
3290: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , b ) ;
3294: CALL_OW 44
3298: PPUSH
3299: LD_VAR 0 5
3303: PPUSH
3304: CALL_OW 52
// end ; end ;
3308: LD_VAR 0 1
3312: RET
// every 7 7$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , p , base , tmp , flags , _target , attackers , amount ;
3313: LD_INT 47
3315: PPUSH
3316: CALL_OW 302
3320: PUSH
3321: LD_EXP 6
3325: AND
3326: IFFALSE 4082
3328: GO 3330
3330: DISABLE
3331: LD_INT 0
3333: PPUSH
3334: PPUSH
3335: PPUSH
3336: PPUSH
3337: PPUSH
3338: PPUSH
3339: PPUSH
3340: PPUSH
// begin enable ;
3341: ENABLE
// base := 2 ;
3342: LD_ADDR_VAR 0 3
3346: PUSH
3347: LD_INT 2
3349: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3350: LD_ADDR_VAR 0 5
3354: PUSH
3355: LD_INT 0
3357: PUSH
3358: LD_INT 0
3360: PUSH
3361: LD_INT 0
3363: PUSH
3364: LD_INT 0
3366: PUSH
3367: LD_INT 0
3369: PUSH
3370: LD_INT 0
3372: PUSH
3373: LD_INT 0
3375: PUSH
3376: LD_INT 0
3378: PUSH
3379: LD_INT 1
3381: PUSH
3382: LD_INT 0
3384: PUSH
3385: EMPTY
3386: LIST
3387: LIST
3388: LIST
3389: LIST
3390: LIST
3391: LIST
3392: LIST
3393: LIST
3394: LIST
3395: LIST
3396: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3397: LD_ADDR_VAR 0 4
3401: PUSH
3402: LD_INT 22
3404: PUSH
3405: LD_INT 1
3407: PUSH
3408: LD_INT 3
3410: PUSH
3411: LD_INT 45
3413: PUSH
3414: EMPTY
3415: LIST
3416: LIST
3417: LIST
3418: LIST
3419: PUSH
3420: LD_INT 21
3422: PUSH
3423: LD_INT 1
3425: PUSH
3426: LD_INT 3
3428: PUSH
3429: LD_INT 45
3431: PUSH
3432: EMPTY
3433: LIST
3434: LIST
3435: LIST
3436: LIST
3437: PUSH
3438: LD_INT 22
3440: PUSH
3441: LD_INT 1
3443: PUSH
3444: LD_INT 3
3446: PUSH
3447: LD_INT 45
3449: PUSH
3450: EMPTY
3451: LIST
3452: LIST
3453: LIST
3454: LIST
3455: PUSH
3456: LD_INT 23
3458: PUSH
3459: LD_INT 1
3461: PUSH
3462: LD_INT 3
3464: PUSH
3465: LD_INT 46
3467: PUSH
3468: EMPTY
3469: LIST
3470: LIST
3471: LIST
3472: LIST
3473: PUSH
3474: EMPTY
3475: LIST
3476: LIST
3477: LIST
3478: LIST
3479: ST_TO_ADDR
// amount := Difficulty ;
3480: LD_ADDR_VAR 0 8
3484: PUSH
3485: LD_OWVAR 67
3489: ST_TO_ADDR
// if tick > 30 30$00 then
3490: LD_OWVAR 1
3494: PUSH
3495: LD_INT 63000
3497: GREATER
3498: IFFALSE 3535
// amount := amount + [ 2 , 3 , 4 , 4 ] [ Difficulty ] ;
3500: LD_ADDR_VAR 0 8
3504: PUSH
3505: LD_VAR 0 8
3509: PUSH
3510: LD_INT 2
3512: PUSH
3513: LD_INT 3
3515: PUSH
3516: LD_INT 4
3518: PUSH
3519: LD_INT 4
3521: PUSH
3522: EMPTY
3523: LIST
3524: LIST
3525: LIST
3526: LIST
3527: PUSH
3528: LD_OWVAR 67
3532: ARRAY
3533: PLUS
3534: ST_TO_ADDR
// for i = 1 to amount do
3535: LD_ADDR_VAR 0 1
3539: PUSH
3540: DOUBLE
3541: LD_INT 1
3543: DEC
3544: ST_TO_ADDR
3545: LD_VAR 0 8
3549: PUSH
3550: FOR_TO
3551: IFFALSE 3639
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3553: LD_ADDR_VAR 0 4
3557: PUSH
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_VAR 0 4
3567: PUSH
3568: LD_INT 1
3570: PLUS
3571: PPUSH
3572: LD_INT 23
3574: PUSH
3575: LD_INT 24
3577: PUSH
3578: EMPTY
3579: LIST
3580: LIST
3581: PUSH
3582: LD_INT 1
3584: PPUSH
3585: LD_INT 2
3587: PPUSH
3588: CALL_OW 12
3592: ARRAY
3593: PUSH
3594: LD_INT 1
3596: PUSH
3597: LD_INT 3
3599: PUSH
3600: LD_INT 46
3602: PUSH
3603: LD_INT 47
3605: PUSH
3606: LD_INT 45
3608: PUSH
3609: EMPTY
3610: LIST
3611: LIST
3612: LIST
3613: PUSH
3614: LD_INT 1
3616: PPUSH
3617: LD_INT 3
3619: PPUSH
3620: CALL_OW 12
3624: ARRAY
3625: PUSH
3626: EMPTY
3627: LIST
3628: LIST
3629: LIST
3630: LIST
3631: PPUSH
3632: CALL_OW 2
3636: ST_TO_ADDR
3637: GO 3550
3639: POP
3640: POP
// p := 1 ;
3641: LD_ADDR_VAR 0 2
3645: PUSH
3646: LD_INT 1
3648: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
3649: LD_VAR 0 3
3653: PPUSH
3654: LD_VAR 0 4
3658: PPUSH
3659: CALL 81299 0 2
// repeat wait ( 0 0$1 ) ;
3663: LD_INT 35
3665: PPUSH
3666: CALL_OW 67
// p := Inc ( p ) ;
3670: LD_ADDR_VAR 0 2
3674: PUSH
3675: LD_VAR 0 2
3679: PPUSH
3680: CALL 54163 0 1
3684: ST_TO_ADDR
// until MC_GetVehicles ( base , true ) >= amount or p >= 100 ;
3685: LD_VAR 0 3
3689: PPUSH
3690: LD_INT 1
3692: PPUSH
3693: CALL 82717 0 2
3697: PUSH
3698: LD_VAR 0 8
3702: GREATEREQUAL
3703: PUSH
3704: LD_VAR 0 2
3708: PUSH
3709: LD_INT 100
3711: GREATEREQUAL
3712: OR
3713: IFFALSE 3663
// wait ( 0 0$30 ) ;
3715: LD_INT 1050
3717: PPUSH
3718: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3722: LD_ADDR_VAR 0 6
3726: PUSH
3727: LD_INT 71
3729: PUSH
3730: LD_INT 19
3732: PUSH
3733: EMPTY
3734: LIST
3735: LIST
3736: PUSH
3737: LD_INT 91
3739: PUSH
3740: LD_INT 67
3742: PUSH
3743: EMPTY
3744: LIST
3745: LIST
3746: PUSH
3747: LD_INT 52
3749: PUSH
3750: LD_INT 44
3752: PUSH
3753: EMPTY
3754: LIST
3755: LIST
3756: PUSH
3757: LD_INT 68
3759: PUSH
3760: LD_INT 48
3762: PUSH
3763: EMPTY
3764: LIST
3765: LIST
3766: PUSH
3767: EMPTY
3768: LIST
3769: LIST
3770: LIST
3771: LIST
3772: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3773: LD_ADDR_VAR 0 7
3777: PUSH
3778: LD_EXP 80
3782: PUSH
3783: LD_VAR 0 3
3787: ARRAY
3788: PUSH
3789: LD_EXP 80
3793: PUSH
3794: LD_VAR 0 3
3798: ARRAY
3799: PPUSH
3800: LD_INT 2
3802: PUSH
3803: LD_INT 34
3805: PUSH
3806: LD_INT 51
3808: PUSH
3809: EMPTY
3810: LIST
3811: LIST
3812: PUSH
3813: LD_INT 34
3815: PUSH
3816: LD_INT 52
3818: PUSH
3819: EMPTY
3820: LIST
3821: LIST
3822: PUSH
3823: EMPTY
3824: LIST
3825: LIST
3826: LIST
3827: PPUSH
3828: CALL_OW 72
3832: DIFF
3833: ST_TO_ADDR
// if not attackers then
3834: LD_VAR 0 7
3838: NOT
3839: IFFALSE 3843
// exit ;
3841: GO 4082
// ru_attackers := attackers ;
3843: LD_ADDR_EXP 54
3847: PUSH
3848: LD_VAR 0 7
3852: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , mc_vehicles [ base ] diff attackers ) ;
3853: LD_ADDR_EXP 80
3857: PUSH
3858: LD_EXP 80
3862: PPUSH
3863: LD_VAR 0 3
3867: PPUSH
3868: LD_EXP 80
3872: PUSH
3873: LD_VAR 0 3
3877: ARRAY
3878: PUSH
3879: LD_VAR 0 7
3883: DIFF
3884: PPUSH
3885: CALL_OW 1
3889: ST_TO_ADDR
// for i = 1 to attackers do
3890: LD_ADDR_VAR 0 1
3894: PUSH
3895: DOUBLE
3896: LD_INT 1
3898: DEC
3899: ST_TO_ADDR
3900: LD_VAR 0 7
3904: PUSH
3905: FOR_TO
3906: IFFALSE 3983
// begin case i mod 3 of 0 :
3908: LD_VAR 0 1
3912: PUSH
3913: LD_INT 3
3915: MOD
3916: PUSH
3917: LD_INT 0
3919: DOUBLE
3920: EQUAL
3921: IFTRUE 3925
3923: GO 3928
3925: POP
// ; 1 :
3926: GO 3981
3928: LD_INT 1
3930: DOUBLE
3931: EQUAL
3932: IFTRUE 3936
3934: GO 3954
3936: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3937: LD_VAR 0 1
3941: PPUSH
3942: LD_INT 32
3944: PPUSH
3945: LD_INT 49
3947: PPUSH
3948: CALL_OW 114
3952: GO 3981
3954: LD_INT 2
3956: DOUBLE
3957: EQUAL
3958: IFTRUE 3962
3960: GO 3980
3962: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3963: LD_VAR 0 1
3967: PPUSH
3968: LD_INT 117
3970: PPUSH
3971: LD_INT 107
3973: PPUSH
3974: CALL_OW 114
3978: GO 3981
3980: POP
// end ;
3981: GO 3905
3983: POP
3984: POP
// p := 0 ;
3985: LD_ADDR_VAR 0 2
3989: PUSH
3990: LD_INT 0
3992: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
3993: LD_INT 35
3995: PPUSH
3996: CALL_OW 67
// p := Inc ( p ) ;
4000: LD_ADDR_VAR 0 2
4004: PUSH
4005: LD_VAR 0 2
4009: PPUSH
4010: CALL 54163 0 1
4014: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
4015: LD_VAR 0 7
4019: PPUSH
4020: LD_INT 60
4022: PUSH
4023: EMPTY
4024: LIST
4025: PPUSH
4026: CALL_OW 72
4030: NOT
4031: PUSH
4032: LD_VAR 0 2
4036: PUSH
4037: LD_INT 30
4039: GREATER
4040: OR
4041: IFFALSE 3993
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
4043: LD_VAR 0 3
4047: PPUSH
4048: LD_VAR 0 7
4052: PPUSH
4053: LD_VAR 0 6
4057: PPUSH
4058: LD_VAR 0 5
4062: PPUSH
4063: CALL 81484 0 4
// if not first_attack then
4067: LD_EXP 7
4071: NOT
4072: IFFALSE 4082
// first_attack := true ;
4074: LD_ADDR_EXP 7
4078: PUSH
4079: LD_INT 1
4081: ST_TO_ADDR
// end ; end_of_file
4082: PPOPN 8
4084: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
4085: LD_INT 0
4087: PPUSH
4088: PPUSH
4089: PPUSH
4090: PPUSH
4091: PPUSH
4092: PPUSH
4093: PPUSH
// uc_side := 2 ;
4094: LD_ADDR_OWVAR 20
4098: PUSH
4099: LD_INT 2
4101: ST_TO_ADDR
// uc_nation := 2 ;
4102: LD_ADDR_OWVAR 21
4106: PUSH
4107: LD_INT 2
4109: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
4110: LD_ADDR_EXP 57
4114: PUSH
4115: LD_STRING Abdul
4117: PPUSH
4118: CALL_OW 25
4122: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
4123: LD_EXP 57
4127: PPUSH
4128: LD_INT 11
4130: PPUSH
4131: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
4135: LD_EXP 57
4139: PPUSH
4140: LD_INT 1
4142: PPUSH
4143: CALL_OW 52
// vc_chassis := 31 ;
4147: LD_ADDR_OWVAR 37
4151: PUSH
4152: LD_INT 31
4154: ST_TO_ADDR
// vc_control := control_rider ;
4155: LD_ADDR_OWVAR 38
4159: PUSH
4160: LD_INT 4
4162: ST_TO_ADDR
// mastodont := CreateVehicle ;
4163: LD_ADDR_EXP 58
4167: PUSH
4168: CALL_OW 45
4172: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
4173: LD_EXP 58
4177: PPUSH
4178: LD_INT 153
4180: PPUSH
4181: LD_INT 71
4183: PPUSH
4184: LD_INT 0
4186: PPUSH
4187: CALL_OW 48
// InitVc ;
4191: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 , 10 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 18 , 5 , 6 , 9 ] ) ;
4195: LD_ADDR_EXP 55
4199: PUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 3
4205: PPUSH
4206: LD_STRING 
4208: PPUSH
4209: LD_INT 7
4211: PUSH
4212: LD_INT 8
4214: PUSH
4215: LD_INT 9
4217: PUSH
4218: LD_INT 10
4220: PUSH
4221: EMPTY
4222: LIST
4223: LIST
4224: LIST
4225: LIST
4226: PUSH
4227: LD_OWVAR 67
4231: ARRAY
4232: PPUSH
4233: LD_INT 5000
4235: PUSH
4236: LD_INT 1000
4238: PUSH
4239: LD_INT 300
4241: PUSH
4242: EMPTY
4243: LIST
4244: LIST
4245: LIST
4246: PPUSH
4247: LD_INT 18
4249: PUSH
4250: LD_INT 5
4252: PUSH
4253: LD_INT 6
4255: PUSH
4256: LD_INT 9
4258: PUSH
4259: EMPTY
4260: LIST
4261: LIST
4262: LIST
4263: LIST
4264: PPUSH
4265: CALL 23794 0 6
4269: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
4270: LD_ADDR_EXP 61
4274: PUSH
4275: LD_EXP 61
4279: PPUSH
4280: LD_INT 1
4282: PPUSH
4283: LD_EXP 55
4287: PPUSH
4288: CALL_OW 1
4292: ST_TO_ADDR
// tmp := [ ] ;
4293: LD_ADDR_VAR 0 4
4297: PUSH
4298: EMPTY
4299: ST_TO_ADDR
// vc_chassis := ar_medium_trike ;
4300: LD_ADDR_OWVAR 37
4304: PUSH
4305: LD_INT 13
4307: ST_TO_ADDR
// vc_engine := engine_siberite ;
4308: LD_ADDR_OWVAR 39
4312: PUSH
4313: LD_INT 3
4315: ST_TO_ADDR
// vc_control := control_manual ;
4316: LD_ADDR_OWVAR 38
4320: PUSH
4321: LD_INT 1
4323: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
4324: LD_ADDR_OWVAR 40
4328: PUSH
4329: LD_INT 31
4331: ST_TO_ADDR
// for i = 1 to 3 do
4332: LD_ADDR_VAR 0 2
4336: PUSH
4337: DOUBLE
4338: LD_INT 1
4340: DEC
4341: ST_TO_ADDR
4342: LD_INT 3
4344: PUSH
4345: FOR_TO
4346: IFFALSE 4594
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
4348: LD_ADDR_VAR 0 5
4352: PUSH
4353: LD_INT 153
4355: PUSH
4356: LD_INT 71
4358: PUSH
4359: EMPTY
4360: LIST
4361: LIST
4362: PUSH
4363: LD_INT 155
4365: PUSH
4366: LD_INT 81
4368: PUSH
4369: EMPTY
4370: LIST
4371: LIST
4372: PUSH
4373: EMPTY
4374: LIST
4375: LIST
4376: PUSH
4377: LD_VAR 0 2
4381: PUSH
4382: LD_INT 2
4384: MOD
4385: PUSH
4386: LD_INT 1
4388: PLUS
4389: ARRAY
4390: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 10 , 10 ] [ Difficulty ] ) ;
4391: LD_INT 0
4393: PPUSH
4394: LD_INT 3
4396: PPUSH
4397: LD_INT 7
4399: PUSH
4400: LD_INT 8
4402: PUSH
4403: LD_INT 10
4405: PUSH
4406: LD_INT 10
4408: PUSH
4409: EMPTY
4410: LIST
4411: LIST
4412: LIST
4413: LIST
4414: PUSH
4415: LD_OWVAR 67
4419: ARRAY
4420: PPUSH
4421: CALL_OW 380
// un := CreateVehicle ;
4425: LD_ADDR_VAR 0 6
4429: PUSH
4430: CALL_OW 45
4434: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4435: LD_VAR 0 6
4439: PPUSH
4440: LD_INT 0
4442: PPUSH
4443: LD_INT 5
4445: PPUSH
4446: CALL_OW 12
4450: PPUSH
4451: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4455: LD_VAR 0 6
4459: PPUSH
4460: LD_VAR 0 5
4464: PUSH
4465: LD_INT 1
4467: ARRAY
4468: PPUSH
4469: LD_VAR 0 5
4473: PUSH
4474: LD_INT 2
4476: ARRAY
4477: PPUSH
4478: LD_INT 6
4480: PPUSH
4481: LD_INT 0
4483: PPUSH
4484: CALL_OW 50
// un2 := CreateHuman ;
4488: LD_ADDR_VAR 0 7
4492: PUSH
4493: CALL_OW 44
4497: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4498: LD_VAR 0 7
4502: PPUSH
4503: LD_VAR 0 6
4507: PPUSH
4508: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4512: LD_ADDR_EXP 61
4516: PUSH
4517: LD_EXP 61
4521: PPUSH
4522: LD_INT 1
4524: PUSH
4525: LD_EXP 61
4529: PUSH
4530: LD_INT 1
4532: ARRAY
4533: PUSH
4534: LD_INT 1
4536: PLUS
4537: PUSH
4538: EMPTY
4539: LIST
4540: LIST
4541: PPUSH
4542: LD_VAR 0 6
4546: PPUSH
4547: CALL 20463 0 3
4551: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4552: LD_ADDR_EXP 61
4556: PUSH
4557: LD_EXP 61
4561: PPUSH
4562: LD_INT 1
4564: PUSH
4565: LD_EXP 61
4569: PUSH
4570: LD_INT 1
4572: ARRAY
4573: PUSH
4574: LD_INT 1
4576: PLUS
4577: PUSH
4578: EMPTY
4579: LIST
4580: LIST
4581: PPUSH
4582: LD_VAR 0 7
4586: PPUSH
4587: CALL 20463 0 3
4591: ST_TO_ADDR
// end ;
4592: GO 4345
4594: POP
4595: POP
// for i = 1 to 5 do
4596: LD_ADDR_VAR 0 2
4600: PUSH
4601: DOUBLE
4602: LD_INT 1
4604: DEC
4605: ST_TO_ADDR
4606: LD_INT 5
4608: PUSH
4609: FOR_TO
4610: IFFALSE 4703
// begin PrepareVehicle ( ar_medium_trike , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4612: LD_INT 13
4614: PPUSH
4615: LD_INT 3
4617: PPUSH
4618: LD_INT 1
4620: PPUSH
4621: LD_INT 25
4623: PUSH
4624: LD_INT 28
4626: PUSH
4627: LD_INT 28
4629: PUSH
4630: LD_INT 26
4632: PUSH
4633: EMPTY
4634: LIST
4635: LIST
4636: LIST
4637: LIST
4638: PUSH
4639: LD_VAR 0 2
4643: PUSH
4644: LD_INT 4
4646: MOD
4647: PUSH
4648: LD_INT 1
4650: PLUS
4651: ARRAY
4652: PPUSH
4653: LD_INT 100
4655: PPUSH
4656: CALL 20341 0 5
// veh := CreateVehicle ;
4660: LD_ADDR_VAR 0 3
4664: PUSH
4665: CALL_OW 45
4669: ST_TO_ADDR
// tmp := tmp ^ veh ;
4670: LD_ADDR_VAR 0 4
4674: PUSH
4675: LD_VAR 0 4
4679: PUSH
4680: LD_VAR 0 3
4684: ADD
4685: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4686: LD_VAR 0 3
4690: PPUSH
4691: LD_INT 1
4693: PPUSH
4694: LD_INT 0
4696: PPUSH
4697: CALL_OW 49
// end ;
4701: GO 4609
4703: POP
4704: POP
// arabian_guard := tmp ;
4705: LD_ADDR_EXP 56
4709: PUSH
4710: LD_VAR 0 4
4714: ST_TO_ADDR
// end ;
4715: LD_VAR 0 1
4719: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4720: LD_INT 22
4722: PUSH
4723: LD_INT 7
4725: PUSH
4726: EMPTY
4727: LIST
4728: LIST
4729: PUSH
4730: LD_INT 91
4732: PUSH
4733: LD_INT 1
4735: PUSH
4736: LD_INT 12
4738: PUSH
4739: EMPTY
4740: LIST
4741: LIST
4742: LIST
4743: PUSH
4744: EMPTY
4745: LIST
4746: LIST
4747: PPUSH
4748: CALL_OW 69
4752: PUSH
4753: LD_EXP 58
4757: PPUSH
4758: CALL_OW 256
4762: PUSH
4763: LD_INT 990
4765: LESS
4766: OR
4767: PUSH
4768: LD_EXP 57
4772: PPUSH
4773: CALL_OW 256
4777: PUSH
4778: LD_INT 990
4780: LESS
4781: OR
4782: IFFALSE 4925
4784: GO 4786
4786: DISABLE
// begin if IsInUnit ( Abdul ) then
4787: LD_EXP 57
4791: PPUSH
4792: CALL_OW 310
4796: IFFALSE 4807
// ComExitBuilding ( Abdul ) ;
4798: LD_EXP 57
4802: PPUSH
4803: CALL_OW 122
// if Mastodont then
4807: LD_EXP 58
4811: IFFALSE 4828
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4813: LD_EXP 58
4817: PPUSH
4818: LD_INT 205
4820: PPUSH
4821: LD_INT 132
4823: PPUSH
4824: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4828: LD_EXP 57
4832: PPUSH
4833: LD_INT 205
4835: PPUSH
4836: LD_INT 132
4838: PPUSH
4839: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4843: LD_INT 35
4845: PPUSH
4846: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4850: LD_EXP 57
4854: PPUSH
4855: LD_INT 21
4857: PPUSH
4858: CALL_OW 308
4862: IFFALSE 4843
// RemoveUnit ( Abdul ) ;
4864: LD_EXP 57
4868: PPUSH
4869: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4873: LD_INT 35
4875: PPUSH
4876: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4880: LD_EXP 58
4884: PPUSH
4885: LD_INT 21
4887: PPUSH
4888: CALL_OW 308
4892: PUSH
4893: LD_EXP 58
4897: PPUSH
4898: CALL_OW 301
4902: OR
4903: IFFALSE 4873
// if IsOk ( Mastodont ) then
4905: LD_EXP 58
4909: PPUSH
4910: CALL_OW 302
4914: IFFALSE 4925
// RemoveUnit ( Mastodont ) ;
4916: LD_EXP 58
4920: PPUSH
4921: CALL_OW 64
// end ;
4925: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4926: LD_EXP 57
4930: PPUSH
4931: CALL_OW 301
4935: PUSH
4936: LD_INT 22
4938: PUSH
4939: LD_INT 2
4941: PUSH
4942: EMPTY
4943: LIST
4944: LIST
4945: PUSH
4946: LD_INT 2
4948: PUSH
4949: LD_INT 25
4951: PUSH
4952: LD_INT 1
4954: PUSH
4955: EMPTY
4956: LIST
4957: LIST
4958: PUSH
4959: LD_INT 25
4961: PUSH
4962: LD_INT 2
4964: PUSH
4965: EMPTY
4966: LIST
4967: LIST
4968: PUSH
4969: LD_INT 25
4971: PUSH
4972: LD_INT 3
4974: PUSH
4975: EMPTY
4976: LIST
4977: LIST
4978: PUSH
4979: LD_INT 25
4981: PUSH
4982: LD_INT 4
4984: PUSH
4985: EMPTY
4986: LIST
4987: LIST
4988: PUSH
4989: LD_INT 25
4991: PUSH
4992: LD_INT 8
4994: PUSH
4995: EMPTY
4996: LIST
4997: LIST
4998: PUSH
4999: EMPTY
5000: LIST
5001: LIST
5002: LIST
5003: LIST
5004: LIST
5005: LIST
5006: PUSH
5007: EMPTY
5008: LIST
5009: LIST
5010: PPUSH
5011: CALL_OW 69
5015: PUSH
5016: LD_INT 16
5018: PUSH
5019: LD_INT 19
5021: PUSH
5022: LD_INT 22
5024: PUSH
5025: LD_INT 22
5027: PUSH
5028: EMPTY
5029: LIST
5030: LIST
5031: LIST
5032: LIST
5033: PUSH
5034: LD_OWVAR 67
5038: ARRAY
5039: LESS
5040: OR
5041: IFFALSE 5714
5043: GO 5045
5045: DISABLE
5046: LD_INT 0
5048: PPUSH
5049: PPUSH
5050: PPUSH
5051: PPUSH
5052: PPUSH
5053: PPUSH
// begin MC_Kill ( 1 ) ;
5054: LD_INT 1
5056: PPUSH
5057: CALL 57274 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
5061: LD_ADDR_VAR 0 2
5065: PUSH
5066: LD_INT 22
5068: PUSH
5069: LD_INT 2
5071: PUSH
5072: EMPTY
5073: LIST
5074: LIST
5075: PUSH
5076: LD_INT 2
5078: PUSH
5079: LD_INT 25
5081: PUSH
5082: LD_INT 1
5084: PUSH
5085: EMPTY
5086: LIST
5087: LIST
5088: PUSH
5089: LD_INT 25
5091: PUSH
5092: LD_INT 2
5094: PUSH
5095: EMPTY
5096: LIST
5097: LIST
5098: PUSH
5099: LD_INT 25
5101: PUSH
5102: LD_INT 3
5104: PUSH
5105: EMPTY
5106: LIST
5107: LIST
5108: PUSH
5109: LD_INT 25
5111: PUSH
5112: LD_INT 4
5114: PUSH
5115: EMPTY
5116: LIST
5117: LIST
5118: PUSH
5119: LD_INT 25
5121: PUSH
5122: LD_INT 8
5124: PUSH
5125: EMPTY
5126: LIST
5127: LIST
5128: PUSH
5129: EMPTY
5130: LIST
5131: LIST
5132: LIST
5133: LIST
5134: LIST
5135: LIST
5136: PUSH
5137: EMPTY
5138: LIST
5139: LIST
5140: PPUSH
5141: CALL_OW 69
5145: ST_TO_ADDR
// for i in tmp do
5146: LD_ADDR_VAR 0 5
5150: PUSH
5151: LD_VAR 0 2
5155: PUSH
5156: FOR_IN
5157: IFFALSE 5173
// SetTag ( i , 10 ) ;
5159: LD_VAR 0 5
5163: PPUSH
5164: LD_INT 10
5166: PPUSH
5167: CALL_OW 109
5171: GO 5156
5173: POP
5174: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
5175: LD_ADDR_VAR 0 3
5179: PUSH
5180: LD_INT 22
5182: PUSH
5183: LD_INT 2
5185: PUSH
5186: EMPTY
5187: LIST
5188: LIST
5189: PUSH
5190: LD_INT 21
5192: PUSH
5193: LD_INT 1
5195: PUSH
5196: EMPTY
5197: LIST
5198: LIST
5199: PUSH
5200: EMPTY
5201: LIST
5202: LIST
5203: PPUSH
5204: CALL_OW 69
5208: PUSH
5209: LD_VAR 0 2
5213: DIFF
5214: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
5215: LD_ADDR_VAR 0 1
5219: PUSH
5220: LD_INT 22
5222: PUSH
5223: LD_INT 2
5225: PUSH
5226: EMPTY
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 21
5232: PUSH
5233: LD_INT 2
5235: PUSH
5236: EMPTY
5237: LIST
5238: LIST
5239: PUSH
5240: LD_INT 24
5242: PUSH
5243: LD_INT 300
5245: PUSH
5246: EMPTY
5247: LIST
5248: LIST
5249: PUSH
5250: EMPTY
5251: LIST
5252: LIST
5253: LIST
5254: PPUSH
5255: CALL_OW 69
5259: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
5260: LD_ADDR_VAR 0 4
5264: PUSH
5265: LD_VAR 0 1
5269: PPUSH
5270: LD_INT 33
5272: PUSH
5273: LD_INT 1
5275: PUSH
5276: EMPTY
5277: LIST
5278: LIST
5279: PUSH
5280: LD_INT 58
5282: PUSH
5283: EMPTY
5284: LIST
5285: PUSH
5286: EMPTY
5287: LIST
5288: LIST
5289: PPUSH
5290: CALL_OW 72
5294: ST_TO_ADDR
// for i in tmp do
5295: LD_ADDR_VAR 0 5
5299: PUSH
5300: LD_VAR 0 2
5304: PUSH
5305: FOR_IN
5306: IFFALSE 5490
// begin if i in FilterAllUnits ( [ f_driving ] ) then
5308: LD_VAR 0 5
5312: PUSH
5313: LD_INT 55
5315: PUSH
5316: EMPTY
5317: LIST
5318: PPUSH
5319: CALL_OW 69
5323: IN
5324: IFFALSE 5343
// begin AddComMoveXY ( i , 209 , 132 ) ;
5326: LD_VAR 0 5
5330: PPUSH
5331: LD_INT 209
5333: PPUSH
5334: LD_INT 132
5336: PPUSH
5337: CALL_OW 171
// continue ;
5341: GO 5305
// end ; if IsInUnit ( i ) then
5343: LD_VAR 0 5
5347: PPUSH
5348: CALL_OW 310
5352: IFFALSE 5370
// begin ComExitBuilding ( i ) ;
5354: LD_VAR 0 5
5358: PPUSH
5359: CALL_OW 122
// wait ( 3 ) ;
5363: LD_INT 3
5365: PPUSH
5366: CALL_OW 67
// end ; if tmp_empty then
5370: LD_VAR 0 4
5374: IFFALSE 5473
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
5376: LD_VAR 0 5
5380: PPUSH
5381: LD_VAR 0 4
5385: PPUSH
5386: LD_VAR 0 5
5390: PPUSH
5391: CALL_OW 74
5395: PPUSH
5396: CALL_OW 296
5400: PUSH
5401: LD_INT 25
5403: LESS
5404: IFFALSE 5473
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5406: LD_ADDR_VAR 0 6
5410: PUSH
5411: LD_VAR 0 4
5415: PPUSH
5416: LD_VAR 0 5
5420: PPUSH
5421: CALL_OW 74
5425: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5426: LD_VAR 0 5
5430: PPUSH
5431: LD_VAR 0 6
5435: PPUSH
5436: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5440: LD_VAR 0 5
5444: PPUSH
5445: LD_INT 209
5447: PPUSH
5448: LD_INT 132
5450: PPUSH
5451: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5455: LD_ADDR_VAR 0 4
5459: PUSH
5460: LD_VAR 0 4
5464: PUSH
5465: LD_VAR 0 6
5469: DIFF
5470: ST_TO_ADDR
// continue ;
5471: GO 5305
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5473: LD_VAR 0 5
5477: PPUSH
5478: LD_INT 201
5480: PPUSH
5481: LD_INT 132
5483: PPUSH
5484: CALL_OW 171
// end ;
5488: GO 5305
5490: POP
5491: POP
// for i in tmp_ape do
5492: LD_ADDR_VAR 0 5
5496: PUSH
5497: LD_VAR 0 3
5501: PUSH
5502: FOR_IN
5503: IFFALSE 5542
// begin if IsInUnit ( i ) then
5505: LD_VAR 0 5
5509: PPUSH
5510: CALL_OW 310
5514: IFFALSE 5525
// ComExitBuilding ( i ) ;
5516: LD_VAR 0 5
5520: PPUSH
5521: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5525: LD_VAR 0 5
5529: PPUSH
5530: LD_INT 201
5532: PPUSH
5533: LD_INT 132
5535: PPUSH
5536: CALL_OW 171
// end ;
5540: GO 5502
5542: POP
5543: POP
// repeat wait ( 0 0$1 ) ;
5544: LD_INT 35
5546: PPUSH
5547: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5551: LD_ADDR_VAR 0 5
5555: PUSH
5556: LD_VAR 0 2
5560: PUSH
5561: LD_VAR 0 3
5565: UNION
5566: PUSH
5567: LD_VAR 0 1
5571: UNION
5572: PUSH
5573: FOR_IN
5574: IFFALSE 5605
// if not HasTask ( i ) then
5576: LD_VAR 0 5
5580: PPUSH
5581: CALL_OW 314
5585: NOT
5586: IFFALSE 5603
// ComMoveXY ( i , 201 , 132 ) ;
5588: LD_VAR 0 5
5592: PPUSH
5593: LD_INT 201
5595: PPUSH
5596: LD_INT 132
5598: PPUSH
5599: CALL_OW 111
5603: GO 5573
5605: POP
5606: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5607: LD_INT 21
5609: PPUSH
5610: LD_INT 22
5612: PUSH
5613: LD_INT 2
5615: PUSH
5616: EMPTY
5617: LIST
5618: LIST
5619: PPUSH
5620: CALL_OW 70
5624: IFFALSE 5665
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5626: LD_ADDR_VAR 0 5
5630: PUSH
5631: LD_INT 21
5633: PPUSH
5634: LD_INT 22
5636: PUSH
5637: LD_INT 2
5639: PUSH
5640: EMPTY
5641: LIST
5642: LIST
5643: PPUSH
5644: CALL_OW 70
5648: PUSH
5649: FOR_IN
5650: IFFALSE 5663
// RemoveUnit ( i ) ;
5652: LD_VAR 0 5
5656: PPUSH
5657: CALL_OW 64
5661: GO 5649
5663: POP
5664: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5665: LD_INT 22
5667: PUSH
5668: LD_INT 2
5670: PUSH
5671: EMPTY
5672: LIST
5673: LIST
5674: PUSH
5675: LD_INT 2
5677: PUSH
5678: LD_INT 21
5680: PUSH
5681: LD_INT 1
5683: PUSH
5684: EMPTY
5685: LIST
5686: LIST
5687: PUSH
5688: LD_INT 21
5690: PUSH
5691: LD_INT 2
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: PUSH
5698: EMPTY
5699: LIST
5700: LIST
5701: LIST
5702: PUSH
5703: EMPTY
5704: LIST
5705: LIST
5706: PPUSH
5707: CALL_OW 69
5711: NOT
5712: IFFALSE 5544
// end ;
5714: PPOPN 6
5716: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5717: LD_EXP 9
5721: PUSH
5722: LD_INT 92
5724: PPUSH
5725: LD_INT 40
5727: PPUSH
5728: CALL_OW 428
5732: PPUSH
5733: CALL_OW 266
5737: PUSH
5738: LD_INT 30
5740: EQUAL
5741: AND
5742: IFFALSE 5938
5744: GO 5746
5746: DISABLE
5747: LD_INT 0
5749: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5750: LD_ADDR_VAR 0 1
5754: PUSH
5755: LD_EXP 61
5759: PUSH
5760: LD_INT 1
5762: ARRAY
5763: PPUSH
5764: LD_INT 25
5766: PUSH
5767: LD_INT 4
5769: PUSH
5770: EMPTY
5771: LIST
5772: LIST
5773: PPUSH
5774: CALL_OW 72
5778: ST_TO_ADDR
// if not sci then
5779: LD_VAR 0 1
5783: NOT
5784: IFFALSE 5788
// exit ;
5786: GO 5938
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5788: LD_ADDR_EXP 61
5792: PUSH
5793: LD_EXP 61
5797: PPUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_EXP 61
5805: PUSH
5806: LD_INT 1
5808: ARRAY
5809: PUSH
5810: LD_VAR 0 1
5814: PUSH
5815: LD_INT 1
5817: ARRAY
5818: DIFF
5819: PPUSH
5820: CALL_OW 1
5824: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5825: LD_VAR 0 1
5829: PUSH
5830: LD_INT 1
5832: ARRAY
5833: PPUSH
5834: CALL_OW 310
5838: IFFALSE 5853
// ComExitBuilding ( sci [ 1 ] ) ;
5840: LD_VAR 0 1
5844: PUSH
5845: LD_INT 1
5847: ARRAY
5848: PPUSH
5849: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5853: LD_INT 2
5855: PPUSH
5856: LD_INT 105
5858: PPUSH
5859: LD_INT 14
5861: PPUSH
5862: LD_INT 20
5864: PPUSH
5865: CALL 21359 0 4
5869: PUSH
5870: LD_INT 4
5872: ARRAY
5873: PUSH
5874: LD_INT 10
5876: LESS
5877: IFFALSE 5900
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5879: LD_VAR 0 1
5883: PUSH
5884: LD_INT 1
5886: ARRAY
5887: PPUSH
5888: LD_INT 105
5890: PPUSH
5891: LD_INT 14
5893: PPUSH
5894: CALL_OW 171
5898: GO 5919
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5900: LD_VAR 0 1
5904: PUSH
5905: LD_INT 1
5907: ARRAY
5908: PPUSH
5909: LD_INT 118
5911: PPUSH
5912: LD_INT 77
5914: PPUSH
5915: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5919: LD_VAR 0 1
5923: PUSH
5924: LD_INT 1
5926: ARRAY
5927: PPUSH
5928: LD_INT 92
5930: PPUSH
5931: LD_INT 40
5933: PPUSH
5934: CALL_OW 218
// end ;
5938: PPOPN 1
5940: END
// every 9 9$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , un , base , tmp , flags , _target , attackers , p ;
5941: LD_INT 1
5943: PPUSH
5944: CALL_OW 302
5948: PUSH
5949: LD_EXP 9
5953: AND
5954: IFFALSE 6742
5956: GO 5958
5958: DISABLE
5959: LD_INT 0
5961: PPUSH
5962: PPUSH
5963: PPUSH
5964: PPUSH
5965: PPUSH
5966: PPUSH
5967: PPUSH
5968: PPUSH
// begin enable ;
5969: ENABLE
// base := 1 ;
5970: LD_ADDR_VAR 0 3
5974: PUSH
5975: LD_INT 1
5977: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5978: LD_ADDR_VAR 0 5
5982: PUSH
5983: LD_INT 0
5985: PUSH
5986: LD_INT 0
5988: PUSH
5989: LD_INT 0
5991: PUSH
5992: LD_INT 0
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: LD_INT 0
6000: PUSH
6001: LD_INT 0
6003: PUSH
6004: LD_INT 0
6006: PUSH
6007: LD_INT 1
6009: PUSH
6010: LD_INT 0
6012: PUSH
6013: EMPTY
6014: LIST
6015: LIST
6016: LIST
6017: LIST
6018: LIST
6019: LIST
6020: LIST
6021: LIST
6022: LIST
6023: LIST
6024: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
6025: LD_ADDR_VAR 0 4
6029: PUSH
6030: LD_INT 13
6032: PUSH
6033: LD_INT 1
6035: PUSH
6036: LD_INT 2
6038: PUSH
6039: LD_INT 26
6041: PUSH
6042: EMPTY
6043: LIST
6044: LIST
6045: LIST
6046: LIST
6047: PUSH
6048: LD_INT 13
6050: PUSH
6051: LD_INT 1
6053: PUSH
6054: LD_INT 2
6056: PUSH
6057: LD_INT 28
6059: PUSH
6060: EMPTY
6061: LIST
6062: LIST
6063: LIST
6064: LIST
6065: PUSH
6066: LD_INT 13
6068: PUSH
6069: LD_INT 1
6071: PUSH
6072: LD_INT 2
6074: PUSH
6075: LD_INT 29
6077: PUSH
6078: EMPTY
6079: LIST
6080: LIST
6081: LIST
6082: LIST
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: LIST
6088: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
6089: LD_ADDR_VAR 0 1
6093: PUSH
6094: DOUBLE
6095: LD_INT 1
6097: DEC
6098: ST_TO_ADDR
6099: LD_OWVAR 67
6103: PUSH
6104: LD_OWVAR 1
6108: PUSH
6109: LD_INT 21000
6111: DIV
6112: PLUS
6113: PUSH
6114: FOR_TO
6115: IFFALSE 6188
// tmp := Insert ( tmp , tmp + 1 , [ ar_medium_trike , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
6117: LD_ADDR_VAR 0 4
6121: PUSH
6122: LD_VAR 0 4
6126: PPUSH
6127: LD_VAR 0 4
6131: PUSH
6132: LD_INT 1
6134: PLUS
6135: PPUSH
6136: LD_INT 13
6138: PUSH
6139: LD_INT 1
6141: PUSH
6142: LD_INT 2
6144: PUSH
6145: LD_INT 28
6147: PUSH
6148: LD_INT 29
6150: PUSH
6151: LD_INT 25
6153: PUSH
6154: LD_INT 26
6156: PUSH
6157: EMPTY
6158: LIST
6159: LIST
6160: LIST
6161: LIST
6162: PUSH
6163: LD_INT 1
6165: PPUSH
6166: LD_INT 4
6168: PPUSH
6169: CALL_OW 12
6173: ARRAY
6174: PUSH
6175: EMPTY
6176: LIST
6177: LIST
6178: LIST
6179: LIST
6180: PPUSH
6181: CALL_OW 2
6185: ST_TO_ADDR
6186: GO 6114
6188: POP
6189: POP
// MC_InsertProduceList ( base , tmp ) ;
6190: LD_VAR 0 3
6194: PPUSH
6195: LD_VAR 0 4
6199: PPUSH
6200: CALL 81299 0 2
// wait ( 4 4$20 ) ;
6204: LD_INT 9100
6206: PPUSH
6207: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
6211: LD_ADDR_VAR 0 6
6215: PUSH
6216: LD_INT 124
6218: PUSH
6219: LD_INT 85
6221: PUSH
6222: EMPTY
6223: LIST
6224: LIST
6225: PUSH
6226: LD_INT 90
6228: PUSH
6229: LD_INT 61
6231: PUSH
6232: EMPTY
6233: LIST
6234: LIST
6235: PUSH
6236: LD_INT 69
6238: PUSH
6239: LD_INT 48
6241: PUSH
6242: EMPTY
6243: LIST
6244: LIST
6245: PUSH
6246: LD_INT 68
6248: PUSH
6249: LD_INT 48
6251: PUSH
6252: EMPTY
6253: LIST
6254: LIST
6255: PUSH
6256: EMPTY
6257: LIST
6258: LIST
6259: LIST
6260: LIST
6261: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6262: LD_ADDR_VAR 0 7
6266: PUSH
6267: LD_EXP 80
6271: PUSH
6272: LD_VAR 0 3
6276: ARRAY
6277: PUSH
6278: LD_EXP 80
6282: PUSH
6283: LD_VAR 0 3
6287: ARRAY
6288: PPUSH
6289: LD_INT 2
6291: PUSH
6292: LD_INT 34
6294: PUSH
6295: LD_INT 32
6297: PUSH
6298: EMPTY
6299: LIST
6300: LIST
6301: PUSH
6302: LD_INT 34
6304: PUSH
6305: LD_INT 88
6307: PUSH
6308: EMPTY
6309: LIST
6310: LIST
6311: PUSH
6312: EMPTY
6313: LIST
6314: LIST
6315: LIST
6316: PPUSH
6317: CALL_OW 72
6321: DIFF
6322: ST_TO_ADDR
// if rand ( 0 , 1 ) then
6323: LD_INT 0
6325: PPUSH
6326: LD_INT 1
6328: PPUSH
6329: CALL_OW 12
6333: IFFALSE 6483
// begin for i := 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
6335: LD_ADDR_VAR 0 1
6339: PUSH
6340: DOUBLE
6341: LD_INT 1
6343: DEC
6344: ST_TO_ADDR
6345: LD_INT 3
6347: PUSH
6348: LD_INT 4
6350: PUSH
6351: LD_INT 5
6353: PUSH
6354: LD_INT 6
6356: PUSH
6357: EMPTY
6358: LIST
6359: LIST
6360: LIST
6361: LIST
6362: PUSH
6363: LD_OWVAR 67
6367: ARRAY
6368: PUSH
6369: FOR_TO
6370: IFFALSE 6479
// begin uc_side := 2 ;
6372: LD_ADDR_OWVAR 20
6376: PUSH
6377: LD_INT 2
6379: ST_TO_ADDR
// uc_nation := 2 ;
6380: LD_ADDR_OWVAR 21
6384: PUSH
6385: LD_INT 2
6387: ST_TO_ADDR
// InitHc ;
6388: CALL_OW 19
// PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6392: LD_INT 0
6394: PPUSH
6395: LD_INT 15
6397: PUSH
6398: LD_INT 17
6400: PUSH
6401: EMPTY
6402: LIST
6403: LIST
6404: PUSH
6405: LD_INT 1
6407: PPUSH
6408: LD_INT 2
6410: PPUSH
6411: CALL_OW 12
6415: ARRAY
6416: PPUSH
6417: LD_INT 8
6419: PPUSH
6420: CALL_OW 380
// un := CreateHuman ;
6424: LD_ADDR_VAR 0 2
6428: PUSH
6429: CALL_OW 44
6433: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6434: LD_VAR 0 2
6438: PPUSH
6439: LD_INT 4
6441: PPUSH
6442: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6446: LD_VAR 0 2
6450: PPUSH
6451: LD_INT 23
6453: PPUSH
6454: LD_INT 0
6456: PPUSH
6457: CALL_OW 49
// attackers := attackers union un ;
6461: LD_ADDR_VAR 0 7
6465: PUSH
6466: LD_VAR 0 7
6470: PUSH
6471: LD_VAR 0 2
6475: UNION
6476: ST_TO_ADDR
// end ;
6477: GO 6369
6479: POP
6480: POP
// end else
6481: GO 6641
// begin for i := 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6483: LD_ADDR_VAR 0 1
6487: PUSH
6488: DOUBLE
6489: LD_INT 1
6491: DEC
6492: ST_TO_ADDR
6493: LD_INT 2
6495: PUSH
6496: LD_INT 3
6498: PUSH
6499: LD_INT 4
6501: PUSH
6502: LD_INT 5
6504: PUSH
6505: EMPTY
6506: LIST
6507: LIST
6508: LIST
6509: LIST
6510: PUSH
6511: LD_OWVAR 67
6515: ARRAY
6516: PUSH
6517: FOR_TO
6518: IFFALSE 6639
// begin uc_side := 2 ;
6520: LD_ADDR_OWVAR 20
6524: PUSH
6525: LD_INT 2
6527: ST_TO_ADDR
// uc_nation := 2 ;
6528: LD_ADDR_OWVAR 21
6532: PUSH
6533: LD_INT 2
6535: ST_TO_ADDR
// InitHc ;
6536: CALL_OW 19
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_selfpropelled_bomb , ar_selfpropelled_bomb , ar_flame_thrower ] [ i mod 3 + 1 ] , 100 ) ;
6540: LD_INT 14
6542: PPUSH
6543: LD_INT 3
6545: PPUSH
6546: LD_INT 5
6548: PPUSH
6549: LD_INT 29
6551: PUSH
6552: LD_INT 29
6554: PUSH
6555: LD_INT 26
6557: PUSH
6558: EMPTY
6559: LIST
6560: LIST
6561: LIST
6562: PUSH
6563: LD_VAR 0 1
6567: PUSH
6568: LD_INT 3
6570: MOD
6571: PUSH
6572: LD_INT 1
6574: PLUS
6575: ARRAY
6576: PPUSH
6577: LD_INT 100
6579: PPUSH
6580: CALL 20341 0 5
// un := CreateVehicle ;
6584: LD_ADDR_VAR 0 2
6588: PUSH
6589: CALL_OW 45
6593: ST_TO_ADDR
// SetDir ( un , 4 ) ;
6594: LD_VAR 0 2
6598: PPUSH
6599: LD_INT 4
6601: PPUSH
6602: CALL_OW 233
// PlaceUnitArea ( un , east_spawn , false ) ;
6606: LD_VAR 0 2
6610: PPUSH
6611: LD_INT 23
6613: PPUSH
6614: LD_INT 0
6616: PPUSH
6617: CALL_OW 49
// attackers := attackers union un ;
6621: LD_ADDR_VAR 0 7
6625: PUSH
6626: LD_VAR 0 7
6630: PUSH
6631: LD_VAR 0 2
6635: UNION
6636: ST_TO_ADDR
// end ;
6637: GO 6517
6639: POP
6640: POP
// end ; if not attackers then
6641: LD_VAR 0 7
6645: NOT
6646: IFFALSE 6650
// exit ;
6648: GO 6742
// ar_attackers := attackers ;
6650: LD_ADDR_EXP 11
6654: PUSH
6655: LD_VAR 0 7
6659: ST_TO_ADDR
// p := 0 ;
6660: LD_ADDR_VAR 0 8
6664: PUSH
6665: LD_INT 0
6667: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
6668: LD_INT 35
6670: PPUSH
6671: CALL_OW 67
// p := Inc ( p ) ;
6675: LD_ADDR_VAR 0 8
6679: PUSH
6680: LD_VAR 0 8
6684: PPUSH
6685: CALL 54163 0 1
6689: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
6690: LD_VAR 0 7
6694: PPUSH
6695: LD_INT 60
6697: PUSH
6698: EMPTY
6699: LIST
6700: PPUSH
6701: CALL_OW 72
6705: NOT
6706: PUSH
6707: LD_VAR 0 8
6711: PUSH
6712: LD_INT 30
6714: GREATER
6715: OR
6716: IFFALSE 6668
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6718: LD_VAR 0 3
6722: PPUSH
6723: LD_VAR 0 7
6727: PPUSH
6728: LD_VAR 0 6
6732: PPUSH
6733: LD_VAR 0 5
6737: PPUSH
6738: CALL 81484 0 4
// end ;
6742: PPOPN 8
6744: END
// every 5 5$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) do var i , base , tmp , flags , _target , attackers , un , p ;
6745: LD_INT 1
6747: PPUSH
6748: CALL_OW 302
6752: PUSH
6753: LD_EXP 9
6757: AND
6758: PUSH
6759: LD_EXP 51
6763: PPUSH
6764: LD_INT 22
6766: PPUSH
6767: CALL_OW 308
6771: AND
6772: IFFALSE 7260
6774: GO 6776
6776: DISABLE
6777: LD_INT 0
6779: PPUSH
6780: PPUSH
6781: PPUSH
6782: PPUSH
6783: PPUSH
6784: PPUSH
6785: PPUSH
6786: PPUSH
// begin base := 1 ;
6787: LD_ADDR_VAR 0 2
6791: PUSH
6792: LD_INT 1
6794: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6795: LD_ADDR_VAR 0 4
6799: PUSH
6800: LD_INT 0
6802: PUSH
6803: LD_INT 0
6805: PUSH
6806: LD_INT 0
6808: PUSH
6809: LD_INT 0
6811: PUSH
6812: LD_INT 0
6814: PUSH
6815: LD_INT 0
6817: PUSH
6818: LD_INT 0
6820: PUSH
6821: LD_INT 0
6823: PUSH
6824: LD_INT 1
6826: PUSH
6827: LD_INT 0
6829: PUSH
6830: EMPTY
6831: LIST
6832: LIST
6833: LIST
6834: LIST
6835: LIST
6836: LIST
6837: LIST
6838: LIST
6839: LIST
6840: LIST
6841: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6842: LD_ADDR_VAR 0 3
6846: PUSH
6847: LD_INT 13
6849: PUSH
6850: LD_INT 1
6852: PUSH
6853: LD_INT 2
6855: PUSH
6856: LD_INT 28
6858: PUSH
6859: EMPTY
6860: LIST
6861: LIST
6862: LIST
6863: LIST
6864: PUSH
6865: LD_INT 13
6867: PUSH
6868: LD_INT 1
6870: PUSH
6871: LD_INT 2
6873: PUSH
6874: LD_INT 27
6876: PUSH
6877: EMPTY
6878: LIST
6879: LIST
6880: LIST
6881: LIST
6882: PUSH
6883: LD_INT 13
6885: PUSH
6886: LD_INT 1
6888: PUSH
6889: LD_INT 2
6891: PUSH
6892: LD_INT 25
6894: PUSH
6895: EMPTY
6896: LIST
6897: LIST
6898: LIST
6899: LIST
6900: PUSH
6901: LD_INT 11
6903: PUSH
6904: LD_INT 2
6906: PUSH
6907: LD_INT 2
6909: PUSH
6910: LD_INT 24
6912: PUSH
6913: EMPTY
6914: LIST
6915: LIST
6916: LIST
6917: LIST
6918: PUSH
6919: LD_INT 11
6921: PUSH
6922: LD_INT 2
6924: PUSH
6925: LD_INT 2
6927: PUSH
6928: LD_INT 24
6930: PUSH
6931: EMPTY
6932: LIST
6933: LIST
6934: LIST
6935: LIST
6936: PUSH
6937: EMPTY
6938: LIST
6939: LIST
6940: LIST
6941: LIST
6942: LIST
6943: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6944: LD_VAR 0 2
6948: PPUSH
6949: LD_VAR 0 3
6953: PPUSH
6954: CALL 81299 0 2
// wait ( 4 4$20 ) ;
6958: LD_INT 9100
6960: PPUSH
6961: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6965: LD_ADDR_VAR 0 5
6969: PUSH
6970: LD_INT 119
6972: PUSH
6973: LD_INT 9
6975: PUSH
6976: EMPTY
6977: LIST
6978: LIST
6979: PUSH
6980: EMPTY
6981: LIST
6982: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
6983: LD_ADDR_VAR 0 6
6987: PUSH
6988: LD_EXP 80
6992: PUSH
6993: LD_VAR 0 2
6997: ARRAY
6998: PUSH
6999: LD_EXP 80
7003: PUSH
7004: LD_VAR 0 2
7008: ARRAY
7009: PPUSH
7010: LD_INT 2
7012: PUSH
7013: LD_INT 34
7015: PUSH
7016: LD_INT 32
7018: PUSH
7019: EMPTY
7020: LIST
7021: LIST
7022: PUSH
7023: LD_INT 34
7025: PUSH
7026: LD_INT 88
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PUSH
7033: EMPTY
7034: LIST
7035: LIST
7036: LIST
7037: PPUSH
7038: CALL_OW 72
7042: DIFF
7043: ST_TO_ADDR
// uc_side := 2 ;
7044: LD_ADDR_OWVAR 20
7048: PUSH
7049: LD_INT 2
7051: ST_TO_ADDR
// uc_nation := 2 ;
7052: LD_ADDR_OWVAR 21
7056: PUSH
7057: LD_INT 2
7059: ST_TO_ADDR
// InitHc ;
7060: CALL_OW 19
// for i := 1 to [ 4 , 5 , 6 , 6 ] [ Difficulty ] do
7064: LD_ADDR_VAR 0 1
7068: PUSH
7069: DOUBLE
7070: LD_INT 1
7072: DEC
7073: ST_TO_ADDR
7074: LD_INT 4
7076: PUSH
7077: LD_INT 5
7079: PUSH
7080: LD_INT 6
7082: PUSH
7083: LD_INT 6
7085: PUSH
7086: EMPTY
7087: LIST
7088: LIST
7089: LIST
7090: LIST
7091: PUSH
7092: LD_OWVAR 67
7096: ARRAY
7097: PUSH
7098: FOR_TO
7099: IFFALSE 7176
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
7101: LD_INT 0
7103: PPUSH
7104: LD_INT 15
7106: PUSH
7107: LD_INT 17
7109: PUSH
7110: EMPTY
7111: LIST
7112: LIST
7113: PUSH
7114: LD_INT 1
7116: PPUSH
7117: LD_INT 2
7119: PPUSH
7120: CALL_OW 12
7124: ARRAY
7125: PPUSH
7126: LD_INT 8
7128: PPUSH
7129: CALL_OW 380
// un := CreateHuman ;
7133: LD_ADDR_VAR 0 7
7137: PUSH
7138: CALL_OW 44
7142: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
7143: LD_VAR 0 7
7147: PPUSH
7148: LD_INT 23
7150: PPUSH
7151: LD_INT 0
7153: PPUSH
7154: CALL_OW 49
// attackers := attackers union un ;
7158: LD_ADDR_VAR 0 6
7162: PUSH
7163: LD_VAR 0 6
7167: PUSH
7168: LD_VAR 0 7
7172: UNION
7173: ST_TO_ADDR
// end ;
7174: GO 7098
7176: POP
7177: POP
// p := 0 ;
7178: LD_ADDR_VAR 0 8
7182: PUSH
7183: LD_INT 0
7185: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7186: LD_INT 35
7188: PPUSH
7189: CALL_OW 67
// p := Inc ( p ) ;
7193: LD_ADDR_VAR 0 8
7197: PUSH
7198: LD_VAR 0 8
7202: PPUSH
7203: CALL 54163 0 1
7207: ST_TO_ADDR
// until not UnitFilter ( attackers , [ f_hastask ] ) or p > 30 ;
7208: LD_VAR 0 6
7212: PPUSH
7213: LD_INT 60
7215: PUSH
7216: EMPTY
7217: LIST
7218: PPUSH
7219: CALL_OW 72
7223: NOT
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_INT 30
7232: GREATER
7233: OR
7234: IFFALSE 7186
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
7236: LD_VAR 0 2
7240: PPUSH
7241: LD_VAR 0 6
7245: PPUSH
7246: LD_VAR 0 5
7250: PPUSH
7251: LD_VAR 0 4
7255: PPUSH
7256: CALL 81484 0 4
// end ; end_of_file
7260: PPOPN 8
7262: END
// export function PrepareAmericanAttack ; var i , tmp , veh , chassis , weapon ; begin
7263: LD_INT 0
7265: PPUSH
7266: PPUSH
7267: PPUSH
7268: PPUSH
7269: PPUSH
7270: PPUSH
// uc_side := 1 ;
7271: LD_ADDR_OWVAR 20
7275: PUSH
7276: LD_INT 1
7278: ST_TO_ADDR
// uc_nation := 1 ;
7279: LD_ADDR_OWVAR 21
7283: PUSH
7284: LD_INT 1
7286: ST_TO_ADDR
// InitHc ;
7287: CALL_OW 19
// InitVc ;
7291: CALL_OW 20
// tmp := [ ] ;
7295: LD_ADDR_VAR 0 3
7299: PUSH
7300: EMPTY
7301: ST_TO_ADDR
// for i = 1 to [ 6 , 8 , 10 , 10 ] [ Difficulty ] do
7302: LD_ADDR_VAR 0 2
7306: PUSH
7307: DOUBLE
7308: LD_INT 1
7310: DEC
7311: ST_TO_ADDR
7312: LD_INT 6
7314: PUSH
7315: LD_INT 8
7317: PUSH
7318: LD_INT 10
7320: PUSH
7321: LD_INT 10
7323: PUSH
7324: EMPTY
7325: LIST
7326: LIST
7327: LIST
7328: LIST
7329: PUSH
7330: LD_OWVAR 67
7334: ARRAY
7335: PUSH
7336: FOR_TO
7337: IFFALSE 7611
// begin chassis := [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] ;
7339: LD_ADDR_VAR 0 5
7343: PUSH
7344: LD_INT 2
7346: PUSH
7347: LD_INT 4
7349: PUSH
7350: LD_INT 5
7352: PUSH
7353: EMPTY
7354: LIST
7355: LIST
7356: LIST
7357: PUSH
7358: LD_INT 1
7360: PPUSH
7361: LD_INT 3
7363: PPUSH
7364: CALL_OW 12
7368: ARRAY
7369: ST_TO_ADDR
// case chassis of us_medium_wheeled :
7370: LD_VAR 0 5
7374: PUSH
7375: LD_INT 2
7377: DOUBLE
7378: EQUAL
7379: IFTRUE 7383
7381: GO 7417
7383: POP
// weapon := [ us_laser , us_double_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; us_heavy_tracked :
7384: LD_ADDR_VAR 0 6
7388: PUSH
7389: LD_INT 9
7391: PUSH
7392: LD_INT 5
7394: PUSH
7395: LD_INT 7
7397: PUSH
7398: EMPTY
7399: LIST
7400: LIST
7401: LIST
7402: PUSH
7403: LD_INT 1
7405: PPUSH
7406: LD_INT 3
7408: PPUSH
7409: CALL_OW 12
7413: ARRAY
7414: ST_TO_ADDR
7415: GO 7506
7417: LD_INT 4
7419: DOUBLE
7420: EQUAL
7421: IFTRUE 7425
7423: GO 7463
7425: POP
// weapon := [ us_laser , us_heavy_gun , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 4 ) ] ; us_morphling :
7426: LD_ADDR_VAR 0 6
7430: PUSH
7431: LD_INT 9
7433: PUSH
7434: LD_INT 6
7436: PUSH
7437: LD_INT 6
7439: PUSH
7440: LD_INT 7
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: LIST
7447: LIST
7448: PUSH
7449: LD_INT 1
7451: PPUSH
7452: LD_INT 4
7454: PPUSH
7455: CALL_OW 12
7459: ARRAY
7460: ST_TO_ADDR
7461: GO 7506
7463: LD_INT 5
7465: DOUBLE
7466: EQUAL
7467: IFTRUE 7471
7469: GO 7505
7471: POP
// weapon := [ us_laser , us_heavy_gun , us_rocket_launcher ] [ rand ( 1 , 3 ) ] ; end ;
7472: LD_ADDR_VAR 0 6
7476: PUSH
7477: LD_INT 9
7479: PUSH
7480: LD_INT 6
7482: PUSH
7483: LD_INT 7
7485: PUSH
7486: EMPTY
7487: LIST
7488: LIST
7489: LIST
7490: PUSH
7491: LD_INT 1
7493: PPUSH
7494: LD_INT 3
7496: PPUSH
7497: CALL_OW 12
7501: ARRAY
7502: ST_TO_ADDR
7503: GO 7506
7505: POP
// PrepareVehicle ( chassis , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , weapon , rand ( 70 , 90 ) ) ;
7506: LD_VAR 0 5
7510: PPUSH
7511: LD_INT 1
7513: PUSH
7514: LD_INT 3
7516: PUSH
7517: EMPTY
7518: LIST
7519: LIST
7520: PUSH
7521: LD_INT 1
7523: PPUSH
7524: LD_INT 2
7526: PPUSH
7527: CALL_OW 12
7531: ARRAY
7532: PPUSH
7533: LD_INT 3
7535: PPUSH
7536: LD_VAR 0 6
7540: PPUSH
7541: LD_INT 70
7543: PPUSH
7544: LD_INT 90
7546: PPUSH
7547: CALL_OW 12
7551: PPUSH
7552: CALL 20341 0 5
// veh := CreateVehicle ;
7556: LD_ADDR_VAR 0 4
7560: PUSH
7561: CALL_OW 45
7565: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
7566: LD_VAR 0 4
7570: PPUSH
7571: LD_INT 2
7573: PPUSH
7574: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
7578: LD_VAR 0 4
7582: PPUSH
7583: LD_INT 17
7585: PPUSH
7586: LD_INT 0
7588: PPUSH
7589: CALL_OW 49
// tmp := tmp ^ veh ;
7593: LD_ADDR_VAR 0 3
7597: PUSH
7598: LD_VAR 0 3
7602: PUSH
7603: LD_VAR 0 4
7607: ADD
7608: ST_TO_ADDR
// end ;
7609: GO 7336
7611: POP
7612: POP
// if not tmp then
7613: LD_VAR 0 3
7617: NOT
7618: IFFALSE 7622
// exit ;
7620: GO 7731
// if not first_powell_attack then
7622: LD_EXP 12
7626: NOT
7627: IFFALSE 7637
// first_powell_attack := true ;
7629: LD_ADDR_EXP 12
7633: PUSH
7634: LD_INT 1
7636: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
7637: LD_INT 70
7639: PPUSH
7640: CALL_OW 67
// for i in tmp do
7644: LD_ADDR_VAR 0 2
7648: PUSH
7649: LD_VAR 0 3
7653: PUSH
7654: FOR_IN
7655: IFFALSE 7722
// if IsOk ( i ) then
7657: LD_VAR 0 2
7661: PPUSH
7662: CALL_OW 302
7666: IFFALSE 7704
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
7668: LD_VAR 0 2
7672: PPUSH
7673: LD_INT 81
7675: PUSH
7676: LD_INT 1
7678: PUSH
7679: EMPTY
7680: LIST
7681: LIST
7682: PPUSH
7683: CALL_OW 69
7687: PPUSH
7688: LD_VAR 0 2
7692: PPUSH
7693: CALL_OW 74
7697: PPUSH
7698: CALL_OW 115
7702: GO 7720
// tmp := tmp diff i ;
7704: LD_ADDR_VAR 0 3
7708: PUSH
7709: LD_VAR 0 3
7713: PUSH
7714: LD_VAR 0 2
7718: DIFF
7719: ST_TO_ADDR
7720: GO 7654
7722: POP
7723: POP
// until not tmp ;
7724: LD_VAR 0 3
7728: NOT
7729: IFFALSE 7637
// end ; end_of_file
7731: LD_VAR 0 1
7735: RET
// export function Action ; var tmp , i , un ; begin
7736: LD_INT 0
7738: PPUSH
7739: PPUSH
7740: PPUSH
7741: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
7742: LD_INT 68
7744: PPUSH
7745: LD_INT 39
7747: PPUSH
7748: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
7752: LD_ADDR_VAR 0 2
7756: PUSH
7757: LD_INT 22
7759: PUSH
7760: LD_INT 7
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: ST_TO_ADDR
// InGameOn ;
7772: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
7776: LD_VAR 0 2
7780: PPUSH
7781: LD_INT 71
7783: PPUSH
7784: LD_INT 49
7786: PPUSH
7787: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
7791: LD_INT 35
7793: PPUSH
7794: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
7798: LD_INT 7
7800: PPUSH
7801: LD_INT 71
7803: PPUSH
7804: LD_INT 51
7806: PPUSH
7807: CALL_OW 293
7811: IFFALSE 7791
// DialogueOn ;
7813: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
7817: LD_EXP 16
7821: PPUSH
7822: LD_STRING D1-JMM-1
7824: PPUSH
7825: CALL_OW 88
// if Joan then
7829: LD_EXP 31
7833: IFFALSE 7847
// Say ( Joan , D1-Joan-1 ) ;
7835: LD_EXP 31
7839: PPUSH
7840: LD_STRING D1-Joan-1
7842: PPUSH
7843: CALL_OW 88
// if Lisa then
7847: LD_EXP 18
7851: IFFALSE 7865
// Say ( Lisa , D1-Lisa-1 ) ;
7853: LD_EXP 18
7857: PPUSH
7858: LD_STRING D1-Lisa-1
7860: PPUSH
7861: CALL_OW 88
// if Joan or Lisa then
7865: LD_EXP 31
7869: PUSH
7870: LD_EXP 18
7874: OR
7875: IFFALSE 7889
// Say ( JMM , D1-JMM-2 ) ;
7877: LD_EXP 16
7881: PPUSH
7882: LD_STRING D1-JMM-2
7884: PPUSH
7885: CALL_OW 88
// DialogueOff ;
7889: CALL_OW 7
// InGameOff ;
7893: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7897: LD_INT 71
7899: PPUSH
7900: LD_INT 50
7902: PPUSH
7903: LD_INT 7
7905: PPUSH
7906: LD_INT 30
7908: NEG
7909: PPUSH
7910: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7914: LD_INT 71
7916: PPUSH
7917: LD_INT 50
7919: PPUSH
7920: LD_INT 7
7922: PPUSH
7923: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7927: LD_STRING M1
7929: PPUSH
7930: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7934: LD_INT 35
7936: PPUSH
7937: CALL_OW 67
// until freedom or tick > 1 1$00 ;
7941: LD_EXP 3
7945: PUSH
7946: LD_OWVAR 1
7950: PUSH
7951: LD_INT 2100
7953: GREATER
7954: OR
7955: IFFALSE 7934
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7957: LD_INT 350
7959: PPUSH
7960: LD_INT 700
7962: PPUSH
7963: CALL_OW 12
7967: PPUSH
7968: CALL_OW 67
// PrepareGossudarov ;
7972: CALL 1935 0 0
// repeat wait ( 0 0$1 ) ;
7976: LD_INT 35
7978: PPUSH
7979: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7983: LD_INT 22
7985: PUSH
7986: LD_INT 6
7988: PUSH
7989: EMPTY
7990: LIST
7991: LIST
7992: PUSH
7993: LD_INT 3
7995: PUSH
7996: LD_INT 24
7998: PUSH
7999: LD_INT 1000
8001: PUSH
8002: EMPTY
8003: LIST
8004: LIST
8005: PUSH
8006: EMPTY
8007: LIST
8008: LIST
8009: PUSH
8010: EMPTY
8011: LIST
8012: LIST
8013: PPUSH
8014: CALL_OW 69
8018: PUSH
8019: LD_INT 7
8021: PPUSH
8022: LD_EXP 34
8026: PPUSH
8027: CALL_OW 292
8031: OR
8032: IFFALSE 7976
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
8034: LD_ADDR_VAR 0 2
8038: PUSH
8039: LD_INT 22
8041: PUSH
8042: LD_INT 6
8044: PUSH
8045: EMPTY
8046: LIST
8047: LIST
8048: PPUSH
8049: CALL_OW 69
8053: ST_TO_ADDR
// for i in tmp do
8054: LD_ADDR_VAR 0 3
8058: PUSH
8059: LD_VAR 0 2
8063: PUSH
8064: FOR_IN
8065: IFFALSE 8081
// SetSide ( i , 7 ) ;
8067: LD_VAR 0 3
8071: PPUSH
8072: LD_INT 7
8074: PPUSH
8075: CALL_OW 235
8079: GO 8064
8081: POP
8082: POP
// DialogueOn ;
8083: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
8087: LD_EXP 16
8091: PUSH
8092: LD_EXP 17
8096: PUSH
8097: EMPTY
8098: LIST
8099: LIST
8100: PPUSH
8101: LD_EXP 34
8105: PPUSH
8106: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
8110: LD_EXP 34
8114: PPUSH
8115: CALL_OW 87
// if not Roth then
8119: LD_EXP 17
8123: NOT
8124: IFFALSE 8216
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8126: LD_VAR 0 2
8130: PPUSH
8131: LD_INT 3
8133: PUSH
8134: LD_INT 24
8136: PUSH
8137: LD_INT 1000
8139: PUSH
8140: EMPTY
8141: LIST
8142: LIST
8143: PUSH
8144: EMPTY
8145: LIST
8146: LIST
8147: PPUSH
8148: CALL_OW 72
8152: IFFALSE 8166
// Say ( JMM , D2-JMM-1 ) ;
8154: LD_EXP 16
8158: PPUSH
8159: LD_STRING D2-JMM-1
8161: PPUSH
8162: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
8166: LD_EXP 16
8170: PPUSH
8171: LD_STRING D2-JMM-1b
8173: PPUSH
8174: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
8178: LD_EXP 34
8182: PPUSH
8183: LD_STRING D2-Gos-1
8185: PPUSH
8186: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
8190: LD_EXP 16
8194: PPUSH
8195: LD_STRING D2-JMM-2
8197: PPUSH
8198: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
8202: LD_EXP 34
8206: PPUSH
8207: LD_STRING D2-Gos-2
8209: PPUSH
8210: CALL_OW 88
// end else
8214: GO 8368
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8216: LD_VAR 0 2
8220: PPUSH
8221: LD_INT 3
8223: PUSH
8224: LD_INT 24
8226: PUSH
8227: LD_INT 1000
8229: PUSH
8230: EMPTY
8231: LIST
8232: LIST
8233: PUSH
8234: EMPTY
8235: LIST
8236: LIST
8237: PPUSH
8238: CALL_OW 72
8242: IFFALSE 8268
// begin Say ( Roth , D2-Roth-2 ) ;
8244: LD_EXP 17
8248: PPUSH
8249: LD_STRING D2-Roth-2
8251: PPUSH
8252: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
8256: LD_EXP 16
8260: PPUSH
8261: LD_STRING D2-JMM-1a
8263: PPUSH
8264: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
8268: LD_EXP 17
8272: PPUSH
8273: LD_STRING D2-Roth-2a
8275: PPUSH
8276: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
8280: LD_EXP 17
8284: PPUSH
8285: LD_STRING D2-Roth-2b
8287: PPUSH
8288: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
8292: LD_EXP 16
8296: PPUSH
8297: LD_STRING D2-JMM-3
8299: PPUSH
8300: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
8304: LD_VAR 0 2
8308: PPUSH
8309: LD_INT 3
8311: PUSH
8312: LD_INT 24
8314: PUSH
8315: LD_INT 1000
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: PPUSH
8326: CALL_OW 72
8330: IFFALSE 8368
// begin Say ( Gossudarov , D2-Gos-3 ) ;
8332: LD_EXP 34
8336: PPUSH
8337: LD_STRING D2-Gos-3
8339: PPUSH
8340: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
8344: LD_EXP 16
8348: PPUSH
8349: LD_STRING D2-JMM-4
8351: PPUSH
8352: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
8356: LD_EXP 34
8360: PPUSH
8361: LD_STRING D2-Gos-4
8363: PPUSH
8364: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
8368: LD_EXP 16
8372: PPUSH
8373: LD_STRING D2-JMM-5
8375: PPUSH
8376: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
8380: LD_EXP 34
8384: PPUSH
8385: LD_STRING D2-Gos-5
8387: PPUSH
8388: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
8392: LD_EXP 16
8396: PPUSH
8397: LD_STRING D2-JMM-6
8399: PPUSH
8400: CALL_OW 88
// DialogueOff ;
8404: CALL_OW 7
// wait ( 0 0$2 ) ;
8408: LD_INT 70
8410: PPUSH
8411: CALL_OW 67
// if Kirilenkova then
8415: LD_EXP 35
8419: IFFALSE 8433
// Say ( Kirilenkova , D3-Kir-1 ) ;
8421: LD_EXP 35
8425: PPUSH
8426: LD_STRING D3-Kir-1
8428: PPUSH
8429: CALL_OW 88
// gossudarov_arrive := true ;
8433: LD_ADDR_EXP 4
8437: PUSH
8438: LD_INT 1
8440: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8441: LD_INT 35
8443: PPUSH
8444: CALL_OW 67
// until ru_lab_builded ;
8448: LD_EXP 5
8452: IFFALSE 8441
// DialogueOn ;
8454: CALL_OW 6
// if Kirilenkova then
8458: LD_EXP 35
8462: IFFALSE 8478
// Say ( Kirilenkova , D3a-Kir-1 ) else
8464: LD_EXP 35
8468: PPUSH
8469: LD_STRING D3a-Kir-1
8471: PPUSH
8472: CALL_OW 88
8476: GO 8500
// begin un := SciRu ;
8478: LD_ADDR_VAR 0 4
8482: PUSH
8483: CALL 13885 0 0
8487: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
8488: LD_VAR 0 4
8492: PPUSH
8493: LD_STRING D3a-Sci1-1
8495: PPUSH
8496: CALL_OW 88
// end ; if Kirilenkova or un then
8500: LD_EXP 35
8504: PUSH
8505: LD_VAR 0 4
8509: OR
8510: IFFALSE 8524
// Say ( JMM , D3a-JMM-1 ) ;
8512: LD_EXP 16
8516: PPUSH
8517: LD_STRING D3a-JMM-1
8519: PPUSH
8520: CALL_OW 88
// DialogueOff ;
8524: CALL_OW 7
// end ;
8528: LD_VAR 0 1
8532: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
8533: LD_EXP 4
8537: PUSH
8538: LD_INT 22
8540: PUSH
8541: LD_INT 7
8543: PUSH
8544: EMPTY
8545: LIST
8546: LIST
8547: PUSH
8548: LD_INT 2
8550: PUSH
8551: LD_INT 25
8553: PUSH
8554: LD_INT 1
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PUSH
8561: LD_INT 25
8563: PUSH
8564: LD_INT 2
8566: PUSH
8567: EMPTY
8568: LIST
8569: LIST
8570: PUSH
8571: LD_INT 25
8573: PUSH
8574: LD_INT 3
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 25
8583: PUSH
8584: LD_INT 4
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: LD_INT 25
8593: PUSH
8594: LD_INT 5
8596: PUSH
8597: EMPTY
8598: LIST
8599: LIST
8600: PUSH
8601: LD_INT 25
8603: PUSH
8604: LD_INT 8
8606: PUSH
8607: EMPTY
8608: LIST
8609: LIST
8610: PUSH
8611: LD_INT 25
8613: PUSH
8614: LD_INT 9
8616: PUSH
8617: EMPTY
8618: LIST
8619: LIST
8620: PUSH
8621: EMPTY
8622: LIST
8623: LIST
8624: LIST
8625: LIST
8626: LIST
8627: LIST
8628: LIST
8629: LIST
8630: PUSH
8631: EMPTY
8632: LIST
8633: LIST
8634: PPUSH
8635: CALL_OW 69
8639: PUSH
8640: LD_INT 7
8642: LESS
8643: AND
8644: IFFALSE 8656
8646: GO 8648
8648: DISABLE
// YouLost ( TooMany ) ;
8649: LD_STRING TooMany
8651: PPUSH
8652: CALL_OW 104
8656: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
8657: LD_EXP 34
8661: PPUSH
8662: CALL_OW 255
8666: PUSH
8667: LD_INT 7
8669: EQUAL
8670: IFFALSE 8887
8672: GO 8674
8674: DISABLE
8675: LD_INT 0
8677: PPUSH
8678: PPUSH
8679: PPUSH
// begin uc_side := 3 ;
8680: LD_ADDR_OWVAR 20
8684: PUSH
8685: LD_INT 3
8687: ST_TO_ADDR
// uc_nation := 3 ;
8688: LD_ADDR_OWVAR 21
8692: PUSH
8693: LD_INT 3
8695: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
8696: LD_INT 21
8698: PPUSH
8699: LD_INT 3
8701: PPUSH
8702: LD_INT 3
8704: PPUSH
8705: LD_INT 42
8707: PPUSH
8708: LD_INT 100
8710: PPUSH
8711: CALL 20341 0 5
// un := CreateVehicle ;
8715: LD_ADDR_VAR 0 3
8719: PUSH
8720: CALL_OW 45
8724: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
8725: LD_VAR 0 3
8729: PPUSH
8730: LD_INT 15
8732: PPUSH
8733: LD_INT 0
8735: PPUSH
8736: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
8740: LD_VAR 0 3
8744: PPUSH
8745: LD_INT 67
8747: PPUSH
8748: LD_INT 45
8750: PPUSH
8751: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
8755: LD_VAR 0 3
8759: PPUSH
8760: LD_INT 70
8762: PPUSH
8763: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
8767: LD_VAR 0 3
8771: PPUSH
8772: LD_INT 69
8774: PPUSH
8775: LD_INT 18
8777: PPUSH
8778: CALL_OW 171
// AddComMoveXY ( un , 60 , 3 ) ;
8782: LD_VAR 0 3
8786: PPUSH
8787: LD_INT 60
8789: PPUSH
8790: LD_INT 3
8792: PPUSH
8793: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
8797: LD_INT 35
8799: PPUSH
8800: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) ;
8804: LD_VAR 0 3
8808: PPUSH
8809: CALL_OW 302
8813: NOT
8814: PUSH
8815: LD_VAR 0 3
8819: PPUSH
8820: LD_INT 17
8822: PPUSH
8823: CALL_OW 308
8827: OR
8828: PUSH
8829: LD_VAR 0 3
8833: PPUSH
8834: LD_INT 60
8836: PPUSH
8837: LD_INT 3
8839: PPUSH
8840: CALL_OW 307
8844: OR
8845: IFFALSE 8797
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 3 ) then
8847: LD_VAR 0 3
8851: PPUSH
8852: LD_INT 17
8854: PPUSH
8855: CALL_OW 308
8859: PUSH
8860: LD_VAR 0 3
8864: PPUSH
8865: LD_INT 60
8867: PPUSH
8868: LD_INT 3
8870: PPUSH
8871: CALL_OW 307
8875: OR
8876: IFFALSE 8887
// RemoveUnit ( un ) ;
8878: LD_VAR 0 3
8882: PPUSH
8883: CALL_OW 64
// end ;
8887: PPOPN 3
8889: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8890: LD_EXP 4
8894: IFFALSE 9136
8896: GO 8898
8898: DISABLE
8899: LD_INT 0
8901: PPUSH
8902: PPUSH
8903: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8904: LD_INT 70
8906: PPUSH
8907: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8911: LD_ADDR_VAR 0 3
8915: PUSH
8916: LD_INT 22
8918: PUSH
8919: LD_INT 7
8921: PUSH
8922: EMPTY
8923: LIST
8924: LIST
8925: PUSH
8926: LD_INT 101
8928: PUSH
8929: LD_INT 3
8931: PUSH
8932: EMPTY
8933: LIST
8934: LIST
8935: PUSH
8936: EMPTY
8937: LIST
8938: LIST
8939: PPUSH
8940: CALL_OW 69
8944: ST_TO_ADDR
// until tmp ;
8945: LD_VAR 0 3
8949: IFFALSE 8904
// un := NearestUnitToUnit ( tmp , JMM ) ;
8951: LD_ADDR_VAR 0 2
8955: PUSH
8956: LD_VAR 0 3
8960: PPUSH
8961: LD_EXP 16
8965: PPUSH
8966: CALL_OW 74
8970: ST_TO_ADDR
// player_spotted := true ;
8971: LD_ADDR_EXP 6
8975: PUSH
8976: LD_INT 1
8978: ST_TO_ADDR
// tmp := SciRu ;
8979: LD_ADDR_VAR 0 3
8983: PUSH
8984: CALL 13885 0 0
8988: ST_TO_ADDR
// if not tmp then
8989: LD_VAR 0 3
8993: NOT
8994: IFFALSE 9006
// tmp := SolRu ;
8996: LD_ADDR_VAR 0 3
9000: PUSH
9001: CALL 14032 0 0
9005: ST_TO_ADDR
// DialogueOn ;
9006: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
9010: LD_VAR 0 2
9014: PPUSH
9015: CALL_OW 250
9019: PPUSH
9020: LD_VAR 0 2
9024: PPUSH
9025: CALL_OW 251
9029: PPUSH
9030: LD_INT 7
9032: PPUSH
9033: LD_INT 8
9035: NEG
9036: PPUSH
9037: CALL_OW 330
// CenterNowOnUnits ( un ) ;
9041: LD_VAR 0 2
9045: PPUSH
9046: CALL_OW 87
// if tmp then
9050: LD_VAR 0 3
9054: IFFALSE 9068
// Say ( tmp , D4-RSci1-1 ) ;
9056: LD_VAR 0 3
9060: PPUSH
9061: LD_STRING D4-RSci1-1
9063: PPUSH
9064: CALL_OW 88
// if Gossudarov then
9068: LD_EXP 34
9072: IFFALSE 9098
// begin Say ( Gossudarov , D4-Gos-1 ) ;
9074: LD_EXP 34
9078: PPUSH
9079: LD_STRING D4-Gos-1
9081: PPUSH
9082: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
9086: LD_EXP 16
9090: PPUSH
9091: LD_STRING D4-JMM-1
9093: PPUSH
9094: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
9098: LD_VAR 0 2
9102: PPUSH
9103: CALL_OW 250
9107: PPUSH
9108: LD_VAR 0 2
9112: PPUSH
9113: CALL_OW 251
9117: PPUSH
9118: LD_INT 7
9120: PPUSH
9121: CALL_OW 331
// DialogueOff ;
9125: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
9129: LD_STRING M5
9131: PPUSH
9132: CALL_OW 337
// end ;
9136: PPOPN 3
9138: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
9139: LD_EXP 6
9143: IFFALSE 9736
9145: GO 9147
9147: DISABLE
9148: LD_INT 0
9150: PPUSH
9151: PPUSH
9152: PPUSH
// begin PrepareBelkov ;
9153: CALL 2248 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
9157: LD_EXP 49
9161: PPUSH
9162: LD_INT 118
9164: PPUSH
9165: LD_INT 106
9167: PPUSH
9168: CALL_OW 111
// AddComHold ( Belkov ) ;
9172: LD_EXP 49
9176: PPUSH
9177: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
9181: LD_INT 35
9183: PPUSH
9184: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
9188: LD_EXP 49
9192: PPUSH
9193: LD_INT 118
9195: PPUSH
9196: LD_INT 106
9198: PPUSH
9199: CALL_OW 307
9203: IFFALSE 9181
// ChangeSideFog ( 4 , 7 ) ;
9205: LD_INT 4
9207: PPUSH
9208: LD_INT 7
9210: PPUSH
9211: CALL_OW 343
// if IsOk ( Belkov ) then
9215: LD_EXP 49
9219: PPUSH
9220: CALL_OW 302
9224: IFFALSE 9308
// begin InGameOn ;
9226: CALL_OW 8
// DialogueOn ;
9230: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
9234: LD_EXP 49
9238: PPUSH
9239: LD_STRING D5-Bel-1
9241: PPUSH
9242: CALL_OW 94
// if Gossudarov then
9246: LD_EXP 34
9250: IFFALSE 9300
// begin Say ( Gossudarov , D5-Gos-1 ) ;
9252: LD_EXP 34
9256: PPUSH
9257: LD_STRING D5-Gos-1
9259: PPUSH
9260: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
9264: LD_EXP 16
9268: PPUSH
9269: LD_STRING D5-JMM-1
9271: PPUSH
9272: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
9276: LD_EXP 34
9280: PPUSH
9281: LD_STRING D5-Gos-2
9283: PPUSH
9284: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
9288: LD_EXP 16
9292: PPUSH
9293: LD_STRING D5-JMM-2
9295: PPUSH
9296: CALL_OW 88
// end ; DialogueOff ;
9300: CALL_OW 7
// InGameOff ;
9304: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
9308: LD_STRING QSaveBelkov
9310: PPUSH
9311: CALL_OW 97
9315: PUSH
9316: LD_INT 1
9318: DOUBLE
9319: EQUAL
9320: IFTRUE 9324
9322: GO 9374
9324: POP
// begin DialogueOn ;
9325: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
9329: LD_EXP 16
9333: PPUSH
9334: LD_STRING D5a-JMM-1
9336: PPUSH
9337: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
9341: LD_EXP 49
9345: PPUSH
9346: LD_STRING D5a-Bel-1
9348: PPUSH
9349: CALL_OW 94
// DialogueOff ;
9353: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
9357: LD_EXP 49
9361: PPUSH
9362: LD_INT 83
9364: PPUSH
9365: LD_INT 49
9367: PPUSH
9368: CALL_OW 111
// end ; 2 :
9372: GO 9407
9374: LD_INT 2
9376: DOUBLE
9377: EQUAL
9378: IFTRUE 9382
9380: GO 9406
9382: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
9383: LD_EXP 16
9387: PPUSH
9388: LD_STRING D5a-JMM-2
9390: PPUSH
9391: CALL_OW 88
// ComHold ( Belkov ) ;
9395: LD_EXP 49
9399: PPUSH
9400: CALL_OW 140
// end ; end ;
9404: GO 9407
9406: POP
// time := 0 0$00 ;
9407: LD_ADDR_VAR 0 1
9411: PUSH
9412: LD_INT 0
9414: ST_TO_ADDR
// vehSpawned := false ;
9415: LD_ADDR_VAR 0 3
9419: PUSH
9420: LD_INT 0
9422: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9423: LD_INT 35
9425: PPUSH
9426: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$03 , 0 0$2 ] [ Difficulty ] and not vehSpawned then
9430: LD_VAR 0 1
9434: PUSH
9435: LD_INT 350
9437: PUSH
9438: LD_INT 175
9440: PUSH
9441: LD_INT 105
9443: PUSH
9444: LD_INT 70
9446: PUSH
9447: EMPTY
9448: LIST
9449: LIST
9450: LIST
9451: LIST
9452: PUSH
9453: LD_OWVAR 67
9457: ARRAY
9458: GREATEREQUAL
9459: PUSH
9460: LD_VAR 0 3
9464: NOT
9465: AND
9466: IFFALSE 9556
// begin vehSpawned := true ;
9468: LD_ADDR_VAR 0 3
9472: PUSH
9473: LD_INT 1
9475: ST_TO_ADDR
// uc_side := 3 ;
9476: LD_ADDR_OWVAR 20
9480: PUSH
9481: LD_INT 3
9483: ST_TO_ADDR
// uc_nation := 3 ;
9484: LD_ADDR_OWVAR 21
9488: PUSH
9489: LD_INT 3
9491: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
9492: LD_INT 22
9494: PPUSH
9495: LD_INT 3
9497: PPUSH
9498: LD_INT 3
9500: PPUSH
9501: LD_INT 43
9503: PPUSH
9504: LD_INT 100
9506: PPUSH
9507: CALL 20341 0 5
// veh := CreateVehicle ;
9511: LD_ADDR_VAR 0 2
9515: PUSH
9516: CALL_OW 45
9520: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
9521: LD_VAR 0 2
9525: PPUSH
9526: LD_INT 130
9528: PPUSH
9529: LD_INT 131
9531: PPUSH
9532: LD_INT 0
9534: PPUSH
9535: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
9539: LD_VAR 0 2
9543: PPUSH
9544: LD_INT 100
9546: PPUSH
9547: LD_INT 82
9549: PPUSH
9550: CALL_OW 114
// end else
9554: GO 9570
// time := time + 0 0$1 ;
9556: LD_ADDR_VAR 0 1
9560: PUSH
9561: LD_VAR 0 1
9565: PUSH
9566: LD_INT 35
9568: PLUS
9569: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
9570: LD_EXP 49
9574: PPUSH
9575: CALL_OW 301
9579: PUSH
9580: LD_EXP 49
9584: PPUSH
9585: CALL_OW 255
9589: PUSH
9590: LD_INT 4
9592: EQUAL
9593: AND
9594: PUSH
9595: LD_INT 22
9597: PUSH
9598: LD_INT 7
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 69
9609: PPUSH
9610: LD_EXP 49
9614: PPUSH
9615: CALL_OW 74
9619: PPUSH
9620: LD_EXP 49
9624: PPUSH
9625: CALL_OW 296
9629: PUSH
9630: LD_INT 10
9632: LESS
9633: OR
9634: IFFALSE 9423
// if IsDead ( Belkov ) then
9636: LD_EXP 49
9640: PPUSH
9641: CALL_OW 301
9645: IFFALSE 9670
// begin CenterNowOnUnits ( Belkov ) ;
9647: LD_EXP 49
9651: PPUSH
9652: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
9656: LD_EXP 16
9660: PPUSH
9661: LD_STRING D5a-JMM-2a
9663: PPUSH
9664: CALL_OW 88
// exit ;
9668: GO 9736
// end ; if See ( 7 , Belkov ) then
9670: LD_INT 7
9672: PPUSH
9673: LD_EXP 49
9677: PPUSH
9678: CALL_OW 292
9682: IFFALSE 9696
// SetSide ( Belkov , 7 ) ;
9684: LD_EXP 49
9688: PPUSH
9689: LD_INT 7
9691: PPUSH
9692: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
9703: LD_EXP 49
9707: PPUSH
9708: LD_INT 66
9710: PPUSH
9711: LD_INT 45
9713: PPUSH
9714: CALL_OW 297
9718: PUSH
9719: LD_INT 30
9721: LESS
9722: IFFALSE 9696
// Say ( Belkov , D6-Bel-1 ) ;
9724: LD_EXP 49
9728: PPUSH
9729: LD_STRING D6-Bel-1
9731: PPUSH
9732: CALL_OW 88
// end ;
9736: PPOPN 3
9738: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
9739: LD_EXP 49
9743: PPUSH
9744: CALL_OW 302
9748: PUSH
9749: LD_EXP 49
9753: PPUSH
9754: CALL_OW 504
9758: PUSH
9759: LD_INT 2
9761: PUSH
9762: LD_INT 34
9764: PUSH
9765: LD_INT 47
9767: PUSH
9768: EMPTY
9769: LIST
9770: LIST
9771: PUSH
9772: LD_INT 34
9774: PUSH
9775: LD_INT 45
9777: PUSH
9778: EMPTY
9779: LIST
9780: LIST
9781: PUSH
9782: EMPTY
9783: LIST
9784: LIST
9785: LIST
9786: PPUSH
9787: CALL_OW 69
9791: IN
9792: AND
9793: IFFALSE 9810
9795: GO 9797
9797: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
9798: LD_EXP 49
9802: PPUSH
9803: LD_STRING D7-Bel-1
9805: PPUSH
9806: CALL_OW 88
9810: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
9811: LD_INT 22
9813: PUSH
9814: LD_INT 7
9816: PUSH
9817: EMPTY
9818: LIST
9819: LIST
9820: PUSH
9821: LD_INT 101
9823: PUSH
9824: LD_INT 2
9826: PUSH
9827: EMPTY
9828: LIST
9829: LIST
9830: PUSH
9831: EMPTY
9832: LIST
9833: LIST
9834: PPUSH
9835: CALL_OW 69
9839: PUSH
9840: LD_EXP 8
9844: NOT
9845: AND
9846: PUSH
9847: LD_EXP 48
9851: PPUSH
9852: CALL_OW 305
9856: NOT
9857: AND
9858: IFFALSE 10328
9860: GO 9862
9862: DISABLE
9863: LD_INT 0
9865: PPUSH
// begin ar_base_spotted := true ;
9866: LD_ADDR_EXP 8
9870: PUSH
9871: LD_INT 1
9873: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
9874: LD_ADDR_VAR 0 1
9878: PUSH
9879: LD_INT 22
9881: PUSH
9882: LD_INT 2
9884: PUSH
9885: EMPTY
9886: LIST
9887: LIST
9888: PUSH
9889: LD_INT 21
9891: PUSH
9892: LD_INT 3
9894: PUSH
9895: EMPTY
9896: LIST
9897: LIST
9898: PUSH
9899: EMPTY
9900: LIST
9901: LIST
9902: PPUSH
9903: CALL_OW 69
9907: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9908: LD_ADDR_VAR 0 1
9912: PUSH
9913: LD_VAR 0 1
9917: PPUSH
9918: LD_EXP 16
9922: PPUSH
9923: CALL_OW 74
9927: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9928: LD_INT 7
9930: PPUSH
9931: LD_INT 3
9933: PPUSH
9934: CALL_OW 332
// DialogueOn ;
9938: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9942: LD_VAR 0 1
9946: PPUSH
9947: CALL_OW 250
9951: PPUSH
9952: LD_VAR 0 1
9956: PPUSH
9957: CALL_OW 251
9961: PPUSH
9962: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9966: LD_ADDR_VAR 0 1
9970: PUSH
9971: LD_INT 22
9973: PUSH
9974: LD_INT 7
9976: PUSH
9977: EMPTY
9978: LIST
9979: LIST
9980: PUSH
9981: LD_INT 23
9983: PUSH
9984: LD_INT 1
9986: PUSH
9987: EMPTY
9988: LIST
9989: LIST
9990: PUSH
9991: LD_INT 26
9993: PUSH
9994: LD_INT 1
9996: PUSH
9997: EMPTY
9998: LIST
9999: LIST
10000: PUSH
10001: EMPTY
10002: LIST
10003: LIST
10004: LIST
10005: PPUSH
10006: CALL_OW 69
10010: PUSH
10011: LD_EXP 16
10015: PUSH
10016: LD_EXP 20
10020: PUSH
10021: LD_EXP 21
10025: PUSH
10026: LD_EXP 28
10030: PUSH
10031: LD_EXP 17
10035: PUSH
10036: LD_EXP 26
10040: PUSH
10041: LD_EXP 22
10045: PUSH
10046: LD_EXP 24
10050: PUSH
10051: EMPTY
10052: LIST
10053: LIST
10054: LIST
10055: LIST
10056: LIST
10057: LIST
10058: LIST
10059: LIST
10060: DIFF
10061: ST_TO_ADDR
// if not tmp then
10062: LD_VAR 0 1
10066: NOT
10067: IFFALSE 10141
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
10069: LD_ADDR_VAR 0 1
10073: PUSH
10074: LD_INT 22
10076: PUSH
10077: LD_INT 7
10079: PUSH
10080: EMPTY
10081: LIST
10082: LIST
10083: PUSH
10084: LD_INT 23
10086: PUSH
10087: LD_INT 1
10089: PUSH
10090: EMPTY
10091: LIST
10092: LIST
10093: PUSH
10094: LD_INT 26
10096: PUSH
10097: LD_INT 2
10099: PUSH
10100: EMPTY
10101: LIST
10102: LIST
10103: PUSH
10104: EMPTY
10105: LIST
10106: LIST
10107: LIST
10108: PPUSH
10109: CALL_OW 69
10113: PUSH
10114: LD_EXP 31
10118: PUSH
10119: LD_EXP 18
10123: PUSH
10124: LD_EXP 29
10128: PUSH
10129: LD_EXP 30
10133: PUSH
10134: EMPTY
10135: LIST
10136: LIST
10137: LIST
10138: LIST
10139: DIFF
10140: ST_TO_ADDR
// if tmp then
10141: LD_VAR 0 1
10145: IFFALSE 10216
// case GetSex ( tmp [ 1 ] ) of sex_male :
10147: LD_VAR 0 1
10151: PUSH
10152: LD_INT 1
10154: ARRAY
10155: PPUSH
10156: CALL_OW 258
10160: PUSH
10161: LD_INT 1
10163: DOUBLE
10164: EQUAL
10165: IFTRUE 10169
10167: GO 10188
10169: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
10170: LD_VAR 0 1
10174: PUSH
10175: LD_INT 1
10177: ARRAY
10178: PPUSH
10179: LD_STRING D9-Sol1-1
10181: PPUSH
10182: CALL_OW 88
10186: GO 10216
10188: LD_INT 2
10190: DOUBLE
10191: EQUAL
10192: IFTRUE 10196
10194: GO 10215
10196: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
10197: LD_VAR 0 1
10201: PUSH
10202: LD_INT 1
10204: ARRAY
10205: PPUSH
10206: LD_STRING D9-FSol1-1
10208: PPUSH
10209: CALL_OW 88
10213: GO 10216
10215: POP
// if Frank then
10216: LD_EXP 28
10220: IFFALSE 10324
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
10222: LD_EXP 58
10226: PPUSH
10227: CALL_OW 250
10231: PPUSH
10232: LD_EXP 58
10236: PPUSH
10237: CALL_OW 251
10241: PPUSH
10242: LD_INT 7
10244: PPUSH
10245: LD_INT 8
10247: PPUSH
10248: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
10252: LD_EXP 58
10256: PPUSH
10257: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
10261: LD_EXP 28
10265: PPUSH
10266: LD_STRING D9-Frank-1
10268: PPUSH
10269: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
10273: LD_EXP 16
10277: PPUSH
10278: LD_STRING D9-JMM-1
10280: PPUSH
10281: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
10285: LD_EXP 28
10289: PPUSH
10290: LD_STRING D9-Frank-2
10292: PPUSH
10293: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
10297: LD_EXP 58
10301: PPUSH
10302: CALL_OW 250
10306: PPUSH
10307: LD_EXP 58
10311: PPUSH
10312: CALL_OW 251
10316: PPUSH
10317: LD_INT 7
10319: PPUSH
10320: CALL_OW 331
// end ; DialogueOff ;
10324: CALL_OW 7
// end ;
10328: PPOPN 1
10330: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
10331: LD_EXP 7
10335: PUSH
10336: LD_OWVAR 1
10340: PUSH
10341: LD_INT 42000
10343: GREATEREQUAL
10344: OR
10345: IFFALSE 11379
10347: GO 10349
10349: DISABLE
10350: LD_INT 0
10352: PPUSH
10353: PPUSH
// begin selected_option := 1 ;
10354: LD_ADDR_VAR 0 2
10358: PUSH
10359: LD_INT 1
10361: ST_TO_ADDR
// wait ( 5 5$00 ) ;
10362: LD_INT 10500
10364: PPUSH
10365: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10369: LD_INT 35
10371: PPUSH
10372: CALL_OW 67
// until not ru_attackers ;
10376: LD_EXP 54
10380: NOT
10381: IFFALSE 10369
// PrepareBurlak ;
10383: CALL 2360 0 0
// repeat wait ( 0 0$2 ) ;
10387: LD_INT 70
10389: PPUSH
10390: CALL_OW 67
// until not HasTask ( Burlak ) ;
10394: LD_EXP 48
10398: PPUSH
10399: CALL_OW 314
10403: NOT
10404: IFFALSE 10387
// InGameOn ;
10406: CALL_OW 8
// DialogueOn ;
10410: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
10414: LD_EXP 51
10418: PPUSH
10419: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
10423: LD_EXP 48
10427: PPUSH
10428: LD_STRING D10-Bur-1
10430: PPUSH
10431: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
10435: LD_EXP 49
10439: PUSH
10440: LD_EXP 49
10444: PPUSH
10445: CALL_OW 255
10449: PUSH
10450: LD_INT 7
10452: EQUAL
10453: AND
10454: IFFALSE 10468
// Say ( Belkov , D10-Bel-1 ) ;
10456: LD_EXP 49
10460: PPUSH
10461: LD_STRING D10-Bel-1
10463: PPUSH
10464: CALL_OW 88
// if Gossudarov then
10468: LD_EXP 34
10472: IFFALSE 10486
// Say ( Gossudarov , D10-Gos-1 ) ;
10474: LD_EXP 34
10478: PPUSH
10479: LD_STRING D10-Gos-1
10481: PPUSH
10482: CALL_OW 88
// if Kirilenkova then
10486: LD_EXP 35
10490: IFFALSE 10504
// Say ( Kirilenkova , D10-Kir-1 ) ;
10492: LD_EXP 35
10496: PPUSH
10497: LD_STRING D10-Kir-1
10499: PPUSH
10500: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
10504: CALL 14032 0 0
10508: PPUSH
10509: LD_STRING D10-RSol1-1
10511: PPUSH
10512: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
10516: LD_EXP 48
10520: PPUSH
10521: LD_STRING D10-Bur-2
10523: PPUSH
10524: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
10528: LD_EXP 16
10532: PPUSH
10533: LD_STRING D10-JMM-2
10535: PPUSH
10536: CALL_OW 88
// if Kirilenkova then
10540: LD_EXP 35
10544: IFFALSE 10560
// Say ( Kirilenkova , D10-Kir-2 ) else
10546: LD_EXP 35
10550: PPUSH
10551: LD_STRING D10-Kir-2
10553: PPUSH
10554: CALL_OW 88
10558: GO 10572
// Say ( SolRu , D10-RSol1-2 ) ;
10560: CALL 14032 0 0
10564: PPUSH
10565: LD_STRING D10-RSol1-2
10567: PPUSH
10568: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
10572: LD_EXP 16
10576: PPUSH
10577: LD_STRING D10-JMM-3
10579: PPUSH
10580: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
10584: LD_EXP 48
10588: PPUSH
10589: LD_STRING D10-Bur-3
10591: PPUSH
10592: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
10596: LD_EXP 16
10600: PPUSH
10601: LD_STRING D10-JMM-4
10603: PPUSH
10604: CALL_OW 88
// DialogueOff ;
10608: CALL_OW 7
// InGameOff ;
10612: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
10616: LD_STRING M2
10618: PPUSH
10619: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10623: LD_INT 35
10625: PPUSH
10626: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
10630: LD_INT 22
10632: PUSH
10633: LD_INT 7
10635: PUSH
10636: EMPTY
10637: LIST
10638: LIST
10639: PUSH
10640: LD_INT 91
10642: PUSH
10643: LD_EXP 48
10647: PUSH
10648: LD_INT 8
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: LIST
10655: PUSH
10656: EMPTY
10657: LIST
10658: LIST
10659: PPUSH
10660: CALL_OW 69
10664: IFFALSE 10623
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
10666: LD_ADDR_VAR 0 1
10670: PUSH
10671: LD_INT 22
10673: PUSH
10674: LD_INT 4
10676: PUSH
10677: EMPTY
10678: LIST
10679: LIST
10680: PPUSH
10681: CALL_OW 69
10685: PUSH
10686: FOR_IN
10687: IFFALSE 10703
// SetSide ( i , 7 ) ;
10689: LD_VAR 0 1
10693: PPUSH
10694: LD_INT 7
10696: PPUSH
10697: CALL_OW 235
10701: GO 10686
10703: POP
10704: POP
// ChangeMissionObjectives ( M3 ) ;
10705: LD_STRING M3
10707: PPUSH
10708: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
10712: LD_INT 35
10714: PPUSH
10715: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
10719: LD_EXP 16
10723: PPUSH
10724: LD_EXP 48
10728: PPUSH
10729: CALL_OW 296
10733: PUSH
10734: LD_INT 8
10736: LESS
10737: IFFALSE 10712
// ComTurnUnit ( JMM , Burlak ) ;
10739: LD_EXP 16
10743: PPUSH
10744: LD_EXP 48
10748: PPUSH
10749: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
10753: LD_EXP 48
10757: PPUSH
10758: LD_EXP 16
10762: PPUSH
10763: CALL_OW 119
// wait ( 0 0$0.3 ) ;
10767: LD_INT 10
10769: PPUSH
10770: CALL_OW 67
// DialogueOn ;
10774: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
10778: LD_EXP 16
10782: PPUSH
10783: LD_STRING D11-JMM-1
10785: PPUSH
10786: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
10790: LD_EXP 48
10794: PPUSH
10795: LD_STRING D11-Bur-1
10797: PPUSH
10798: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
10802: LD_EXP 16
10806: PPUSH
10807: LD_STRING D11-JMM-2
10809: PPUSH
10810: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
10814: LD_EXP 48
10818: PPUSH
10819: LD_STRING D11-Bur-2
10821: PPUSH
10822: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
10826: LD_EXP 16
10830: PPUSH
10831: LD_STRING D11-JMM-3
10833: PPUSH
10834: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
10838: LD_EXP 48
10842: PPUSH
10843: LD_STRING D11-Bur-3
10845: PPUSH
10846: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
10850: LD_EXP 16
10854: PPUSH
10855: LD_STRING D11-JMM-4
10857: PPUSH
10858: CALL_OW 88
// if ar_base_spotted then
10862: LD_EXP 8
10866: IFFALSE 10882
// Say ( Burlak , D12-Bur-1 ) else
10868: LD_EXP 48
10872: PPUSH
10873: LD_STRING D12-Bur-1
10875: PPUSH
10876: CALL_OW 88
10880: GO 10921
// begin RevealFogArea ( 7 , area_base_arabian ) ;
10882: LD_INT 7
10884: PPUSH
10885: LD_INT 3
10887: PPUSH
10888: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10892: LD_INT 127
10894: PPUSH
10895: LD_INT 45
10897: PPUSH
10898: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10902: LD_EXP 48
10906: PPUSH
10907: LD_STRING D12-Bur-1a
10909: PPUSH
10910: CALL_OW 88
// dwait ( 0 0$2 ) ;
10914: LD_INT 70
10916: PPUSH
10917: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10921: LD_EXP 48
10925: PPUSH
10926: LD_STRING D12-Bur-1b
10928: PPUSH
10929: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10933: LD_EXP 16
10937: PPUSH
10938: LD_STRING D12-JMM-1
10940: PPUSH
10941: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10945: LD_EXP 48
10949: PPUSH
10950: LD_STRING D12-Bur-2
10952: PPUSH
10953: CALL_OW 88
// if Roth then
10957: LD_EXP 17
10961: IFFALSE 10977
// Say ( Roth , D12-Roth-2 ) else
10963: LD_EXP 17
10967: PPUSH
10968: LD_STRING D12-Roth-2
10970: PPUSH
10971: CALL_OW 88
10975: GO 10989
// Say ( SciRu , D12-RSci1-2 ) ;
10977: CALL 13885 0 0
10981: PPUSH
10982: LD_STRING D12-RSci1-2
10984: PPUSH
10985: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10989: LD_EXP 16
10993: PPUSH
10994: LD_STRING D12-JMM-2
10996: PPUSH
10997: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
11001: LD_EXP 48
11005: PPUSH
11006: LD_STRING D12-Bur-3
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
11013: LD_EXP 16
11017: PPUSH
11018: LD_STRING D12-JMM-3
11020: PPUSH
11021: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
11025: LD_EXP 48
11029: PPUSH
11030: LD_STRING D12-Bur-4
11032: PPUSH
11033: CALL_OW 88
// case Query ( QBase ) of 1 :
11037: LD_STRING QBase
11039: PPUSH
11040: CALL_OW 97
11044: PUSH
11045: LD_INT 1
11047: DOUBLE
11048: EQUAL
11049: IFTRUE 11053
11051: GO 11171
11053: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
11054: LD_EXP 16
11058: PPUSH
11059: LD_STRING D13a-JMM-1
11061: PPUSH
11062: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
11066: LD_EXP 48
11070: PPUSH
11071: LD_STRING D13a-Bur-1
11073: PPUSH
11074: CALL_OW 88
// if Roth then
11078: LD_EXP 17
11082: IFFALSE 11098
// Say ( Roth , D13a-Roth-1 ) else
11084: LD_EXP 17
11088: PPUSH
11089: LD_STRING D13a-Roth-1
11091: PPUSH
11092: CALL_OW 88
11096: GO 11110
// Say ( SciRu , D13a-RSci1-1 ) ;
11098: CALL 13885 0 0
11102: PPUSH
11103: LD_STRING D13a-RSci1-1
11105: PPUSH
11106: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
11110: LD_EXP 16
11114: PPUSH
11115: LD_STRING D13a-JMM-2
11117: PPUSH
11118: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
11122: LD_STRING QBaseAgain
11124: PPUSH
11125: CALL_OW 97
11129: PUSH
11130: LD_INT 1
11132: DOUBLE
11133: EQUAL
11134: IFTRUE 11138
11136: GO 11149
11138: POP
// selected_option := 2 ; 2 :
11139: LD_ADDR_VAR 0 2
11143: PUSH
11144: LD_INT 2
11146: ST_TO_ADDR
11147: GO 11169
11149: LD_INT 2
11151: DOUBLE
11152: EQUAL
11153: IFTRUE 11157
11155: GO 11168
11157: POP
// selected_option := 3 ; end ;
11158: LD_ADDR_VAR 0 2
11162: PUSH
11163: LD_INT 3
11165: ST_TO_ADDR
11166: GO 11169
11168: POP
// end ; 2 :
11169: GO 11210
11171: LD_INT 2
11173: DOUBLE
11174: EQUAL
11175: IFTRUE 11179
11177: GO 11190
11179: POP
// selected_option := 2 ; 3 :
11180: LD_ADDR_VAR 0 2
11184: PUSH
11185: LD_INT 2
11187: ST_TO_ADDR
11188: GO 11210
11190: LD_INT 3
11192: DOUBLE
11193: EQUAL
11194: IFTRUE 11198
11196: GO 11209
11198: POP
// selected_option := 3 ; end ;
11199: LD_ADDR_VAR 0 2
11203: PUSH
11204: LD_INT 3
11206: ST_TO_ADDR
11207: GO 11210
11209: POP
// if selected_option = 2 then
11210: LD_VAR 0 2
11214: PUSH
11215: LD_INT 2
11217: EQUAL
11218: IFFALSE 11312
// begin Say ( JMM , D13b-JMM-1 ) ;
11220: LD_EXP 16
11224: PPUSH
11225: LD_STRING D13b-JMM-1
11227: PPUSH
11228: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
11232: LD_EXP 48
11236: PPUSH
11237: LD_STRING D13b-Bur-1
11239: PPUSH
11240: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
11244: LD_EXP 16
11248: PPUSH
11249: LD_STRING D13b-JMM-2
11251: PPUSH
11252: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
11256: LD_EXP 57
11260: PPUSH
11261: LD_STRING D13b-Abd-2
11263: PPUSH
11264: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
11268: LD_EXP 16
11272: PPUSH
11273: LD_STRING D13b-JMM-3
11275: PPUSH
11276: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
11280: LD_EXP 57
11284: PPUSH
11285: LD_STRING D13b-Abd-3
11287: PPUSH
11288: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
11292: LD_EXP 16
11296: PPUSH
11297: LD_STRING D13b-JMM-4
11299: PPUSH
11300: CALL_OW 88
// ar_active_attack := true ;
11304: LD_ADDR_EXP 9
11308: PUSH
11309: LD_INT 1
11311: ST_TO_ADDR
// end ; if selected_option = 3 then
11312: LD_VAR 0 2
11316: PUSH
11317: LD_INT 3
11319: EQUAL
11320: IFFALSE 11346
// begin Say ( JMM , D13c-JMM-1 ) ;
11322: LD_EXP 16
11326: PPUSH
11327: LD_STRING D13c-JMM-1
11329: PPUSH
11330: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
11334: LD_EXP 48
11338: PPUSH
11339: LD_STRING D13c-Bur-1
11341: PPUSH
11342: CALL_OW 88
// end ; DialogueOff ;
11346: CALL_OW 7
// ChangeMissionObjectives ( M4 ) ;
11350: LD_STRING M4
11352: PPUSH
11353: CALL_OW 337
// if not ar_active_attack then
11357: LD_EXP 9
11361: NOT
11362: IFFALSE 11379
// begin wait ( 6 6$00 ) ;
11364: LD_INT 12600
11366: PPUSH
11367: CALL_OW 67
// ar_active_attack := true ;
11371: LD_ADDR_EXP 9
11375: PUSH
11376: LD_INT 1
11378: ST_TO_ADDR
// end ; end ;
11379: PPOPN 2
11381: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
11382: LD_EXP 48
11386: PPUSH
11387: CALL_OW 305
11391: PUSH
11392: LD_EXP 48
11396: PPUSH
11397: CALL_OW 255
11401: PUSH
11402: LD_INT 7
11404: EQUAL
11405: AND
11406: IFFALSE 11602
11408: GO 11410
11410: DISABLE
11411: LD_INT 0
11413: PPUSH
// begin wait ( 4 4$40 ) ;
11414: LD_INT 9800
11416: PPUSH
11417: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
11421: LD_INT 35
11423: PPUSH
11424: CALL_OW 67
// until not ru_attackers ;
11428: LD_EXP 54
11432: NOT
11433: IFFALSE 11421
// PrepareGnyevko ;
11435: CALL 2304 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
11439: LD_EXP 50
11443: PPUSH
11444: LD_INT 124
11446: PPUSH
11447: LD_INT 118
11449: PPUSH
11450: CALL_OW 111
// AddComHold ( Gnyevko ) ;
11454: LD_EXP 50
11458: PPUSH
11459: CALL_OW 200
// time := 0 0$00 ;
11463: LD_ADDR_VAR 0 1
11467: PUSH
11468: LD_INT 0
11470: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
11471: LD_INT 35
11473: PPUSH
11474: CALL_OW 67
// time := time + 0 0$1 ;
11478: LD_ADDR_VAR 0 1
11482: PUSH
11483: LD_VAR 0 1
11487: PUSH
11488: LD_INT 35
11490: PLUS
11491: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
11492: LD_EXP 50
11496: PPUSH
11497: LD_INT 124
11499: PPUSH
11500: LD_INT 118
11502: PPUSH
11503: CALL_OW 307
11507: PUSH
11508: LD_VAR 0 1
11512: PUSH
11513: LD_INT 1050
11515: GREATEREQUAL
11516: OR
11517: IFFALSE 11471
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
11519: LD_EXP 50
11523: PPUSH
11524: LD_STRING DBelkov-Gny-1
11526: PPUSH
11527: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
11531: LD_EXP 48
11535: PPUSH
11536: LD_STRING DBelkov-Bur-1a
11538: PPUSH
11539: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
11543: LD_INT 35
11545: PPUSH
11546: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
11550: LD_EXP 50
11554: PPUSH
11555: LD_INT 22
11557: PUSH
11558: LD_INT 7
11560: PUSH
11561: EMPTY
11562: LIST
11563: LIST
11564: PPUSH
11565: CALL_OW 69
11569: PPUSH
11570: LD_EXP 50
11574: PPUSH
11575: CALL_OW 74
11579: PPUSH
11580: CALL_OW 296
11584: PUSH
11585: LD_INT 8
11587: LESS
11588: IFFALSE 11543
// SetSide ( Gnyevko , 7 ) ;
11590: LD_EXP 50
11594: PPUSH
11595: LD_INT 7
11597: PPUSH
11598: CALL_OW 235
// end ;
11602: PPOPN 1
11604: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
11605: LD_EXP 48
11609: PPUSH
11610: CALL_OW 255
11614: PUSH
11615: LD_INT 7
11617: EQUAL
11618: IFFALSE 11628
11620: GO 11622
11622: DISABLE
// begin enable ;
11623: ENABLE
// PrepareAmericanAttack ;
11624: CALL 7263 0 0
// end ;
11628: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
11629: LD_INT 22
11631: PUSH
11632: LD_INT 1
11634: PUSH
11635: EMPTY
11636: LIST
11637: LIST
11638: PPUSH
11639: CALL_OW 69
11643: IFFALSE 11827
11645: GO 11647
11647: DISABLE
11648: LD_INT 0
11650: PPUSH
11651: PPUSH
// begin while true do
11652: LD_INT 1
11654: IFFALSE 11711
// begin wait ( 0 0$1 ) ;
11656: LD_INT 35
11658: PPUSH
11659: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
11663: LD_ADDR_VAR 0 2
11667: PUSH
11668: LD_INT 22
11670: PUSH
11671: LD_INT 1
11673: PUSH
11674: EMPTY
11675: LIST
11676: LIST
11677: PPUSH
11678: CALL_OW 69
11682: PPUSH
11683: LD_EXP 16
11687: PPUSH
11688: CALL_OW 74
11692: ST_TO_ADDR
// if See ( 7 , tmp ) then
11693: LD_INT 7
11695: PPUSH
11696: LD_VAR 0 2
11700: PPUSH
11701: CALL_OW 292
11705: IFFALSE 11709
// break ;
11707: GO 11711
// end ;
11709: GO 11652
// DialogueOn ;
11711: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
11715: LD_VAR 0 2
11719: PPUSH
11720: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
11724: LD_VAR 0 2
11728: PPUSH
11729: CALL_OW 250
11733: PPUSH
11734: LD_VAR 0 2
11738: PPUSH
11739: CALL_OW 251
11743: PPUSH
11744: LD_INT 7
11746: PPUSH
11747: LD_INT 8
11749: PPUSH
11750: CALL_OW 330
// if Denis then
11754: LD_EXP 22
11758: IFFALSE 11772
// Say ( Denis , DAmerAttack-Pet-1 ) ;
11760: LD_EXP 22
11764: PPUSH
11765: LD_STRING DAmerAttack-Pet-1
11767: PPUSH
11768: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
11772: LD_EXP 16
11776: PPUSH
11777: LD_STRING DAmerAttack-JMM-1
11779: PPUSH
11780: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
11784: LD_EXP 48
11788: PPUSH
11789: LD_STRING DStop-Bur-1
11791: PPUSH
11792: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
11796: LD_VAR 0 2
11800: PPUSH
11801: CALL_OW 250
11805: PPUSH
11806: LD_VAR 0 2
11810: PPUSH
11811: CALL_OW 251
11815: PPUSH
11816: LD_INT 7
11818: PPUSH
11819: CALL_OW 331
// DialogueOff ;
11823: CALL_OW 7
// end ;
11827: PPOPN 2
11829: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
11830: LD_INT 22
11832: PUSH
11833: LD_INT 3
11835: PUSH
11836: EMPTY
11837: LIST
11838: LIST
11839: PUSH
11840: LD_INT 21
11842: PUSH
11843: LD_INT 1
11845: PUSH
11846: EMPTY
11847: LIST
11848: LIST
11849: PUSH
11850: EMPTY
11851: LIST
11852: LIST
11853: PPUSH
11854: CALL_OW 69
11858: PUSH
11859: LD_INT 0
11861: EQUAL
11862: IFFALSE 11904
11864: GO 11866
11866: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
11867: LD_STRING M5a
11869: PPUSH
11870: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
11874: LD_EXP 16
11878: PPUSH
11879: LD_STRING D8-JMM-1
11881: PPUSH
11882: CALL_OW 88
// if Gossudarov then
11886: LD_EXP 34
11890: IFFALSE 11904
// Say ( Gossudarov , D8-Gos-1 ) ;
11892: LD_EXP 34
11896: PPUSH
11897: LD_STRING D8-Gos-1
11899: PPUSH
11900: CALL_OW 88
// end ;
11904: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11905: LD_INT 22
11907: PUSH
11908: LD_INT 2
11910: PUSH
11911: EMPTY
11912: LIST
11913: LIST
11914: PUSH
11915: LD_INT 21
11917: PUSH
11918: LD_INT 1
11920: PUSH
11921: EMPTY
11922: LIST
11923: LIST
11924: PUSH
11925: EMPTY
11926: LIST
11927: LIST
11928: PPUSH
11929: CALL_OW 69
11933: PUSH
11934: LD_INT 0
11936: EQUAL
11937: IFFALSE 11987
11939: GO 11941
11941: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11942: LD_STRING M4c
11944: PPUSH
11945: CALL_OW 337
// if Roth then
11949: LD_EXP 17
11953: IFFALSE 11969
// Say ( Roth , DStop-Roth-1 ) else
11955: LD_EXP 17
11959: PPUSH
11960: LD_STRING DStop-Roth-1
11962: PPUSH
11963: CALL_OW 88
11967: GO 11987
// if Gossudarov then
11969: LD_EXP 34
11973: IFFALSE 11987
// Say ( Gossudarov , D8-Gos-1a ) ;
11975: LD_EXP 34
11979: PPUSH
11980: LD_STRING D8-Gos-1a
11982: PPUSH
11983: CALL_OW 88
// end ;
11987: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11988: LD_INT 7
11990: PPUSH
11991: LD_INT 1
11993: PPUSH
11994: LD_INT 1
11996: PPUSH
11997: CALL 15564 0 3
12001: PUSH
12002: LD_INT 0
12004: EQUAL
12005: PUSH
12006: LD_INT 7
12008: PPUSH
12009: LD_INT 3
12011: PPUSH
12012: LD_INT 1
12014: PPUSH
12015: CALL 15564 0 3
12019: PUSH
12020: LD_INT 0
12022: EQUAL
12023: AND
12024: IFFALSE 12036
12026: GO 12028
12028: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
12029: LD_STRING M1a
12031: PPUSH
12032: CALL_OW 337
// end ;
12036: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_nation , nation_arabian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_nation , nation_russian ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 and GetSide ( Burlak ) = 7 and IsOk ( Burlak ) do var i , tmp , tmp2 , m1 , m2 , m3 ;
12037: LD_INT 22
12039: PUSH
12040: LD_INT 2
12042: PUSH
12043: EMPTY
12044: LIST
12045: LIST
12046: PUSH
12047: LD_INT 23
12049: PUSH
12050: LD_INT 2
12052: PUSH
12053: EMPTY
12054: LIST
12055: LIST
12056: PUSH
12057: LD_INT 21
12059: PUSH
12060: LD_INT 1
12062: PUSH
12063: EMPTY
12064: LIST
12065: LIST
12066: PUSH
12067: EMPTY
12068: LIST
12069: LIST
12070: LIST
12071: PPUSH
12072: CALL_OW 69
12076: PUSH
12077: LD_INT 0
12079: EQUAL
12080: PUSH
12081: LD_INT 22
12083: PUSH
12084: LD_INT 3
12086: PUSH
12087: EMPTY
12088: LIST
12089: LIST
12090: PUSH
12091: LD_INT 23
12093: PUSH
12094: LD_INT 3
12096: PUSH
12097: EMPTY
12098: LIST
12099: LIST
12100: PUSH
12101: LD_INT 21
12103: PUSH
12104: LD_INT 1
12106: PUSH
12107: EMPTY
12108: LIST
12109: LIST
12110: PUSH
12111: EMPTY
12112: LIST
12113: LIST
12114: LIST
12115: PPUSH
12116: CALL_OW 69
12120: PUSH
12121: LD_INT 0
12123: EQUAL
12124: AND
12125: PUSH
12126: LD_INT 22
12128: PUSH
12129: LD_INT 1
12131: PUSH
12132: EMPTY
12133: LIST
12134: LIST
12135: PPUSH
12136: CALL_OW 69
12140: PUSH
12141: LD_INT 0
12143: EQUAL
12144: AND
12145: PUSH
12146: LD_INT 7
12148: PPUSH
12149: LD_INT 1
12151: PPUSH
12152: LD_INT 1
12154: PPUSH
12155: CALL 15564 0 3
12159: PUSH
12160: LD_INT 0
12162: EQUAL
12163: AND
12164: PUSH
12165: LD_INT 7
12167: PPUSH
12168: LD_INT 3
12170: PPUSH
12171: LD_INT 1
12173: PPUSH
12174: CALL 15564 0 3
12178: PUSH
12179: LD_INT 0
12181: EQUAL
12182: AND
12183: PUSH
12184: LD_EXP 48
12188: PPUSH
12189: CALL_OW 255
12193: PUSH
12194: LD_INT 7
12196: EQUAL
12197: AND
12198: PUSH
12199: LD_EXP 48
12203: PPUSH
12204: CALL_OW 302
12208: AND
12209: IFFALSE 13882
12211: GO 12213
12213: DISABLE
12214: LD_INT 0
12216: PPUSH
12217: PPUSH
12218: PPUSH
12219: PPUSH
12220: PPUSH
12221: PPUSH
// begin m1 := false ;
12222: LD_ADDR_VAR 0 4
12226: PUSH
12227: LD_INT 0
12229: ST_TO_ADDR
// m2 := false ;
12230: LD_ADDR_VAR 0 5
12234: PUSH
12235: LD_INT 0
12237: ST_TO_ADDR
// m3 := false ;
12238: LD_ADDR_VAR 0 6
12242: PUSH
12243: LD_INT 0
12245: ST_TO_ADDR
// if tick < 40 40$00 then
12246: LD_OWVAR 1
12250: PUSH
12251: LD_INT 84000
12253: LESS
12254: IFFALSE 12263
// SetAchievement ( ACH_ASPEED_17 ) ;
12256: LD_STRING ACH_ASPEED_17
12258: PPUSH
12259: CALL_OW 543
// wait ( 0 0$5 ) ;
12263: LD_INT 175
12265: PPUSH
12266: CALL_OW 67
// if not masha_killed then
12270: LD_EXP 10
12274: NOT
12275: IFFALSE 12297
// begin m1 := true ;
12277: LD_ADDR_VAR 0 4
12281: PUSH
12282: LD_INT 1
12284: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
12285: LD_STRING Masha
12287: PPUSH
12288: LD_INT 1
12290: PPUSH
12291: CALL_OW 101
// end else
12295: GO 12308
// AddMedal ( Masha , - 1 ) ;
12297: LD_STRING Masha
12299: PPUSH
12300: LD_INT 1
12302: NEG
12303: PPUSH
12304: CALL_OW 101
// if abdul_escaped then
12308: LD_EXP 13
12312: IFFALSE 12327
// AddMedal ( Abdul , - 1 ) else
12314: LD_STRING Abdul
12316: PPUSH
12317: LD_INT 1
12319: NEG
12320: PPUSH
12321: CALL_OW 101
12325: GO 12345
// begin m2 := true ;
12327: LD_ADDR_VAR 0 5
12331: PUSH
12332: LD_INT 1
12334: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
12335: LD_STRING Abdul
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 101
// end ; if loss_counter = 0 then
12345: LD_EXP 14
12349: PUSH
12350: LD_INT 0
12352: EQUAL
12353: IFFALSE 12375
// begin m3 := true ;
12355: LD_ADDR_VAR 0 6
12359: PUSH
12360: LD_INT 1
12362: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
12363: LD_STRING People
12365: PPUSH
12366: LD_INT 2
12368: PPUSH
12369: CALL_OW 101
// end else
12373: GO 12437
// if loss_counter <= [ 3 , 2 , 2 , 1 ] [ Difficulty ] then
12375: LD_EXP 14
12379: PUSH
12380: LD_INT 3
12382: PUSH
12383: LD_INT 2
12385: PUSH
12386: LD_INT 2
12388: PUSH
12389: LD_INT 1
12391: PUSH
12392: EMPTY
12393: LIST
12394: LIST
12395: LIST
12396: LIST
12397: PUSH
12398: LD_OWVAR 67
12402: ARRAY
12403: LESSEQUAL
12404: IFFALSE 12426
// begin AddMedal ( People , 1 ) ;
12406: LD_STRING People
12408: PPUSH
12409: LD_INT 1
12411: PPUSH
12412: CALL_OW 101
// m3 := true ;
12416: LD_ADDR_VAR 0 6
12420: PUSH
12421: LD_INT 1
12423: ST_TO_ADDR
// end else
12424: GO 12437
// AddMedal ( People , - 1 ) ;
12426: LD_STRING People
12428: PPUSH
12429: LD_INT 1
12431: NEG
12432: PPUSH
12433: CALL_OW 101
// if Difficulty >= 3 and m1 and m2 and m3 then
12437: LD_OWVAR 67
12441: PUSH
12442: LD_INT 3
12444: GREATEREQUAL
12445: PUSH
12446: LD_VAR 0 4
12450: AND
12451: PUSH
12452: LD_VAR 0 5
12456: AND
12457: PUSH
12458: LD_VAR 0 6
12462: AND
12463: IFFALSE 12475
// SetAchievementEX ( ACH_AMER , 17 ) ;
12465: LD_STRING ACH_AMER
12467: PPUSH
12468: LD_INT 17
12470: PPUSH
12471: CALL_OW 564
// GiveMedals ( MAIN ) ;
12475: LD_STRING MAIN
12477: PPUSH
12478: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_ok ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
12482: LD_ADDR_VAR 0 2
12486: PUSH
12487: LD_INT 22
12489: PUSH
12490: LD_INT 7
12492: PUSH
12493: EMPTY
12494: LIST
12495: LIST
12496: PUSH
12497: LD_INT 50
12499: PUSH
12500: EMPTY
12501: LIST
12502: PUSH
12503: LD_INT 2
12505: PUSH
12506: LD_INT 25
12508: PUSH
12509: LD_INT 1
12511: PUSH
12512: EMPTY
12513: LIST
12514: LIST
12515: PUSH
12516: LD_INT 25
12518: PUSH
12519: LD_INT 2
12521: PUSH
12522: EMPTY
12523: LIST
12524: LIST
12525: PUSH
12526: LD_INT 25
12528: PUSH
12529: LD_INT 3
12531: PUSH
12532: EMPTY
12533: LIST
12534: LIST
12535: PUSH
12536: LD_INT 25
12538: PUSH
12539: LD_INT 4
12541: PUSH
12542: EMPTY
12543: LIST
12544: LIST
12545: PUSH
12546: LD_INT 25
12548: PUSH
12549: LD_INT 5
12551: PUSH
12552: EMPTY
12553: LIST
12554: LIST
12555: PUSH
12556: LD_INT 25
12558: PUSH
12559: LD_INT 8
12561: PUSH
12562: EMPTY
12563: LIST
12564: LIST
12565: PUSH
12566: LD_INT 25
12568: PUSH
12569: LD_INT 9
12571: PUSH
12572: EMPTY
12573: LIST
12574: LIST
12575: PUSH
12576: EMPTY
12577: LIST
12578: LIST
12579: LIST
12580: LIST
12581: LIST
12582: LIST
12583: LIST
12584: LIST
12585: PUSH
12586: EMPTY
12587: LIST
12588: LIST
12589: LIST
12590: PPUSH
12591: CALL_OW 69
12595: ST_TO_ADDR
// RewardPeople ( tmp ) ;
12596: LD_VAR 0 2
12600: PPUSH
12601: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko , Mike ] ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_EXP 16
12614: PUSH
12615: LD_EXP 17
12619: PUSH
12620: LD_EXP 18
12624: PUSH
12625: LD_EXP 19
12629: PUSH
12630: LD_EXP 20
12634: PUSH
12635: LD_EXP 21
12639: PUSH
12640: LD_EXP 22
12644: PUSH
12645: LD_EXP 23
12649: PUSH
12650: LD_EXP 24
12654: PUSH
12655: LD_EXP 25
12659: PUSH
12660: LD_EXP 26
12664: PUSH
12665: LD_EXP 27
12669: PUSH
12670: LD_EXP 28
12674: PUSH
12675: LD_EXP 29
12679: PUSH
12680: LD_EXP 30
12684: PUSH
12685: LD_EXP 31
12689: PUSH
12690: LD_EXP 32
12694: PUSH
12695: LD_EXP 34
12699: PUSH
12700: LD_EXP 35
12704: PUSH
12705: LD_EXP 36
12709: PUSH
12710: LD_EXP 38
12714: PUSH
12715: LD_EXP 39
12719: PUSH
12720: LD_EXP 40
12724: PUSH
12725: LD_EXP 41
12729: PUSH
12730: LD_EXP 42
12734: PUSH
12735: LD_EXP 43
12739: PUSH
12740: LD_EXP 44
12744: PUSH
12745: LD_EXP 45
12749: PUSH
12750: LD_EXP 46
12754: PUSH
12755: LD_EXP 47
12759: PUSH
12760: LD_EXP 48
12764: PUSH
12765: LD_EXP 49
12769: PUSH
12770: LD_EXP 50
12774: PUSH
12775: LD_EXP 33
12779: PUSH
12780: EMPTY
12781: LIST
12782: LIST
12783: LIST
12784: LIST
12785: LIST
12786: LIST
12787: LIST
12788: LIST
12789: LIST
12790: LIST
12791: LIST
12792: LIST
12793: LIST
12794: LIST
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: LIST
12807: LIST
12808: LIST
12809: LIST
12810: LIST
12811: LIST
12812: LIST
12813: LIST
12814: LIST
12815: ST_TO_ADDR
// if tmp diff tmp2 then
12816: LD_VAR 0 2
12820: PUSH
12821: LD_VAR 0 3
12825: DIFF
12826: IFFALSE 12846
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
12828: LD_VAR 0 2
12832: PUSH
12833: LD_VAR 0 3
12837: DIFF
12838: PPUSH
12839: LD_STRING 13a_others
12841: PPUSH
12842: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
12846: LD_EXP 16
12850: PPUSH
12851: LD_STRING 13a_JMM
12853: PPUSH
12854: CALL_OW 38
// if IsOk ( Mike ) then
12858: LD_EXP 33
12862: PPUSH
12863: CALL_OW 302
12867: IFFALSE 12881
// SaveCharacters ( Mike , 13a_Mike ) ;
12869: LD_EXP 33
12873: PPUSH
12874: LD_STRING 13a_Mike
12876: PPUSH
12877: CALL_OW 38
// if IsOk ( Titov ) then
12881: LD_EXP 36
12885: PPUSH
12886: CALL_OW 302
12890: IFFALSE 12904
// SaveCharacters ( Titov , 13a_Titov ) ;
12892: LD_EXP 36
12896: PPUSH
12897: LD_STRING 13a_Titov
12899: PPUSH
12900: CALL_OW 38
// if IsOk ( Dolgov ) then
12904: LD_EXP 38
12908: PPUSH
12909: CALL_OW 302
12913: IFFALSE 12927
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
12915: LD_EXP 38
12919: PPUSH
12920: LD_STRING 13a_Dolgov
12922: PPUSH
12923: CALL_OW 38
// if IsOk ( Petrosyan ) then
12927: LD_EXP 39
12931: PPUSH
12932: CALL_OW 302
12936: IFFALSE 12950
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
12938: LD_EXP 39
12942: PPUSH
12943: LD_STRING 13a_Petrosyan
12945: PPUSH
12946: CALL_OW 38
// if IsOk ( Scholtze ) then
12950: LD_EXP 40
12954: PPUSH
12955: CALL_OW 302
12959: IFFALSE 12973
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
12961: LD_EXP 40
12965: PPUSH
12966: LD_STRING 13a_Scholtze
12968: PPUSH
12969: CALL_OW 38
// if IsOk ( Oblukov ) then
12973: LD_EXP 41
12977: PPUSH
12978: CALL_OW 302
12982: IFFALSE 12996
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
12984: LD_EXP 41
12988: PPUSH
12989: LD_STRING 13a_Oblukov
12991: PPUSH
12992: CALL_OW 38
// if IsOk ( Kapitsova ) then
12996: LD_EXP 42
13000: PPUSH
13001: CALL_OW 302
13005: IFFALSE 13019
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
13007: LD_EXP 42
13011: PPUSH
13012: LD_STRING 13a_Kapitsova
13014: PPUSH
13015: CALL_OW 38
// if IsOk ( Lipshchin ) then
13019: LD_EXP 43
13023: PPUSH
13024: CALL_OW 302
13028: IFFALSE 13042
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
13030: LD_EXP 43
13034: PPUSH
13035: LD_STRING 13a_Lipshchin
13037: PPUSH
13038: CALL_OW 38
// if IsOk ( Petrovova ) then
13042: LD_EXP 44
13046: PPUSH
13047: CALL_OW 302
13051: IFFALSE 13065
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
13053: LD_EXP 44
13057: PPUSH
13058: LD_STRING 13a_Petrovova
13060: PPUSH
13061: CALL_OW 38
// if IsOk ( Kovalyuk ) then
13065: LD_EXP 45
13069: PPUSH
13070: CALL_OW 302
13074: IFFALSE 13088
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
13076: LD_EXP 45
13080: PPUSH
13081: LD_STRING 13a_Kovalyuk
13083: PPUSH
13084: CALL_OW 38
// if IsOk ( Kuzmov ) then
13088: LD_EXP 46
13092: PPUSH
13093: CALL_OW 302
13097: IFFALSE 13111
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
13099: LD_EXP 46
13103: PPUSH
13104: LD_STRING 13a_Kuzmov
13106: PPUSH
13107: CALL_OW 38
// if IsOk ( Karamazov ) then
13111: LD_EXP 47
13115: PPUSH
13116: CALL_OW 302
13120: IFFALSE 13134
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
13122: LD_EXP 47
13126: PPUSH
13127: LD_STRING 13a_Karamazov
13129: PPUSH
13130: CALL_OW 38
// if Burlak then
13134: LD_EXP 48
13138: IFFALSE 13159
// begin ToLua ( enableBioCharacter(BIO_GORKI) ) ;
13140: LD_STRING enableBioCharacter(BIO_GORKI)
13142: PPUSH
13143: CALL_OW 559
// SaveCharacters ( Burlak , 13a_Burlak ) ;
13147: LD_EXP 48
13151: PPUSH
13152: LD_STRING 13a_Burlak
13154: PPUSH
13155: CALL_OW 38
// end ; if IsOk ( Belkov ) then
13159: LD_EXP 49
13163: PPUSH
13164: CALL_OW 302
13168: IFFALSE 13182
// SaveCharacters ( Belkov , 13a_Belkov ) ;
13170: LD_EXP 49
13174: PPUSH
13175: LD_STRING 13a_Belkov
13177: PPUSH
13178: CALL_OW 38
// if IsOk ( Gnyevko ) then
13182: LD_EXP 50
13186: PPUSH
13187: CALL_OW 302
13191: IFFALSE 13205
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
13193: LD_EXP 50
13197: PPUSH
13198: LD_STRING 13a_Gnyevko
13200: PPUSH
13201: CALL_OW 38
// if IsOk ( Lisa ) then
13205: LD_EXP 18
13209: PPUSH
13210: CALL_OW 302
13214: IFFALSE 13228
// SaveCharacters ( Lisa , 13a_Lisa ) ;
13216: LD_EXP 18
13220: PPUSH
13221: LD_STRING 13a_Lisa
13223: PPUSH
13224: CALL_OW 38
// if IsOk ( Donaldson ) then
13228: LD_EXP 19
13232: PPUSH
13233: CALL_OW 302
13237: IFFALSE 13251
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
13239: LD_EXP 19
13243: PPUSH
13244: LD_STRING 13a_Donaldson
13246: PPUSH
13247: CALL_OW 38
// if IsOk ( Bobby ) then
13251: LD_EXP 20
13255: PPUSH
13256: CALL_OW 302
13260: IFFALSE 13274
// SaveCharacters ( Bobby , 13a_Bobby ) ;
13262: LD_EXP 20
13266: PPUSH
13267: LD_STRING 13a_Bobby
13269: PPUSH
13270: CALL_OW 38
// if IsOk ( Cyrus ) then
13274: LD_EXP 21
13278: PPUSH
13279: CALL_OW 302
13283: IFFALSE 13297
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
13285: LD_EXP 21
13289: PPUSH
13290: LD_STRING 13a_Cyrus
13292: PPUSH
13293: CALL_OW 38
// if IsOk ( Denis ) then
13297: LD_EXP 22
13301: PPUSH
13302: CALL_OW 302
13306: IFFALSE 13320
// SaveCharacters ( Denis , 13a_Denis ) ;
13308: LD_EXP 22
13312: PPUSH
13313: LD_STRING 13a_Denis
13315: PPUSH
13316: CALL_OW 38
// if IsOk ( Brown ) then
13320: LD_EXP 23
13324: PPUSH
13325: CALL_OW 302
13329: IFFALSE 13343
// SaveCharacters ( Brown , 13a_Brown ) ;
13331: LD_EXP 23
13335: PPUSH
13336: LD_STRING 13a_Brown
13338: PPUSH
13339: CALL_OW 38
// if IsOk ( Gladstone ) then
13343: LD_EXP 24
13347: PPUSH
13348: CALL_OW 302
13352: IFFALSE 13366
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
13354: LD_EXP 24
13358: PPUSH
13359: LD_STRING 13a_Gladstone
13361: PPUSH
13362: CALL_OW 38
// if IsOk ( Houten ) then
13366: LD_EXP 25
13370: PPUSH
13371: CALL_OW 302
13375: IFFALSE 13389
// SaveCharacters ( Houten , 13a_Houten ) ;
13377: LD_EXP 25
13381: PPUSH
13382: LD_STRING 13a_Houten
13384: PPUSH
13385: CALL_OW 38
// if IsOk ( Cornel ) then
13389: LD_EXP 26
13393: PPUSH
13394: CALL_OW 302
13398: IFFALSE 13412
// SaveCharacters ( Cornel , 13a_Cornel ) ;
13400: LD_EXP 26
13404: PPUSH
13405: LD_STRING 13a_Cornel
13407: PPUSH
13408: CALL_OW 38
// if IsOk ( Gary ) then
13412: LD_EXP 27
13416: PPUSH
13417: CALL_OW 302
13421: IFFALSE 13435
// SaveCharacters ( Gary , 13a_Gary ) ;
13423: LD_EXP 27
13427: PPUSH
13428: LD_STRING 13a_Gary
13430: PPUSH
13431: CALL_OW 38
// if IsOk ( Frank ) then
13435: LD_EXP 28
13439: PPUSH
13440: CALL_OW 302
13444: IFFALSE 13458
// SaveCharacters ( Frank , 13a_Frank ) ;
13446: LD_EXP 28
13450: PPUSH
13451: LD_STRING 13a_Frank
13453: PPUSH
13454: CALL_OW 38
// if IsOk ( Kikuchi ) then
13458: LD_EXP 29
13462: PPUSH
13463: CALL_OW 302
13467: IFFALSE 13481
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
13469: LD_EXP 29
13473: PPUSH
13474: LD_STRING 13a_Kikuchi
13476: PPUSH
13477: CALL_OW 38
// if IsOk ( Simms ) then
13481: LD_EXP 30
13485: PPUSH
13486: CALL_OW 302
13490: IFFALSE 13504
// SaveCharacters ( Simms , 13a_Simms ) ;
13492: LD_EXP 30
13496: PPUSH
13497: LD_STRING 13a_Simms
13499: PPUSH
13500: CALL_OW 38
// if IsOk ( Joan ) then
13504: LD_EXP 31
13508: PPUSH
13509: CALL_OW 302
13513: IFFALSE 13527
// SaveCharacters ( Joan , 13a_Joan ) ;
13515: LD_EXP 31
13519: PPUSH
13520: LD_STRING 13a_Joan
13522: PPUSH
13523: CALL_OW 38
// if IsOk ( DeltaDoctor ) then
13527: LD_EXP 32
13531: PPUSH
13532: CALL_OW 302
13536: IFFALSE 13550
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
13538: LD_EXP 32
13542: PPUSH
13543: LD_STRING 13a_DeltaDoctor
13545: PPUSH
13546: CALL_OW 38
// if IsOk ( Gossudarov ) then
13550: LD_EXP 34
13554: PPUSH
13555: CALL_OW 302
13559: IFFALSE 13573
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
13561: LD_EXP 34
13565: PPUSH
13566: LD_STRING 13a_Gossudarov
13568: PPUSH
13569: CALL_OW 38
// if IsOk ( Kirilenkova ) then
13573: LD_EXP 35
13577: PPUSH
13578: CALL_OW 302
13582: IFFALSE 13596
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
13584: LD_EXP 35
13588: PPUSH
13589: LD_STRING 13a_Kirilenkova
13591: PPUSH
13592: CALL_OW 38
// if IsOk ( Roth ) then
13596: LD_EXP 17
13600: PPUSH
13601: CALL_OW 302
13605: IFFALSE 13619
// SaveCharacters ( Roth , 13a_Roth ) ;
13607: LD_EXP 17
13611: PPUSH
13612: LD_STRING 13a_Roth
13614: PPUSH
13615: CALL_OW 38
// if Masha then
13619: LD_EXP 51
13623: IFFALSE 13678
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
13625: LD_EXP 51
13629: PPUSH
13630: CALL_OW 265
13634: PUSH
13635: LD_EXP 51
13639: PPUSH
13640: CALL_OW 262
13644: PUSH
13645: LD_EXP 51
13649: PPUSH
13650: CALL_OW 263
13654: PUSH
13655: LD_EXP 51
13659: PPUSH
13660: CALL_OW 264
13664: PUSH
13665: EMPTY
13666: LIST
13667: LIST
13668: LIST
13669: LIST
13670: PPUSH
13671: LD_STRING 13a_Masha
13673: PPUSH
13674: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
13678: LD_ADDR_VAR 0 2
13682: PUSH
13683: LD_INT 21
13685: PUSH
13686: LD_INT 3
13688: PUSH
13689: EMPTY
13690: LIST
13691: LIST
13692: PPUSH
13693: CALL_OW 69
13697: ST_TO_ADDR
// tmp2 := [ ] ;
13698: LD_ADDR_VAR 0 3
13702: PUSH
13703: EMPTY
13704: ST_TO_ADDR
// if tmp then
13705: LD_VAR 0 2
13709: IFFALSE 13860
// for i in tmp do
13711: LD_ADDR_VAR 0 1
13715: PUSH
13716: LD_VAR 0 2
13720: PUSH
13721: FOR_IN
13722: IFFALSE 13858
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
13724: LD_ADDR_VAR 0 3
13728: PUSH
13729: LD_VAR 0 3
13733: PUSH
13734: LD_VAR 0 1
13738: PPUSH
13739: CALL_OW 255
13743: PUSH
13744: LD_VAR 0 1
13748: PPUSH
13749: CALL_OW 248
13753: PUSH
13754: LD_VAR 0 1
13758: PPUSH
13759: CALL_OW 266
13763: PUSH
13764: LD_VAR 0 1
13768: PPUSH
13769: CALL_OW 250
13773: PUSH
13774: LD_VAR 0 1
13778: PPUSH
13779: CALL_OW 251
13783: PUSH
13784: LD_VAR 0 1
13788: PPUSH
13789: CALL_OW 254
13793: PUSH
13794: LD_VAR 0 1
13798: PPUSH
13799: CALL_OW 267
13803: PUSH
13804: LD_VAR 0 1
13808: PPUSH
13809: LD_INT 1
13811: PPUSH
13812: CALL_OW 268
13816: PUSH
13817: LD_VAR 0 1
13821: PPUSH
13822: LD_INT 2
13824: PPUSH
13825: CALL_OW 268
13829: PUSH
13830: LD_VAR 0 1
13834: PPUSH
13835: CALL_OW 269
13839: PUSH
13840: EMPTY
13841: LIST
13842: LIST
13843: LIST
13844: LIST
13845: LIST
13846: LIST
13847: LIST
13848: LIST
13849: LIST
13850: LIST
13851: PUSH
13852: EMPTY
13853: LIST
13854: ADD
13855: ST_TO_ADDR
13856: GO 13721
13858: POP
13859: POP
// if tmp2 then
13860: LD_VAR 0 3
13864: IFFALSE 13878
// SaveVariable ( tmp2 , 13a_buildings ) ;
13866: LD_VAR 0 3
13870: PPUSH
13871: LD_STRING 13a_buildings
13873: PPUSH
13874: CALL_OW 39
// YouWin ;
13878: CALL_OW 103
// end ;
13882: PPOPN 6
13884: END
// export function SciRu ; var tmp , t ; begin
13885: LD_INT 0
13887: PPUSH
13888: PPUSH
13889: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
13890: LD_ADDR_VAR 0 3
13894: PUSH
13895: LD_EXP 34
13899: PUSH
13900: LD_EXP 48
13904: PUSH
13905: LD_EXP 36
13909: PUSH
13910: LD_EXP 49
13914: PUSH
13915: LD_EXP 50
13919: PUSH
13920: LD_EXP 39
13924: PUSH
13925: LD_EXP 40
13929: PUSH
13930: LD_EXP 38
13934: PUSH
13935: EMPTY
13936: LIST
13937: LIST
13938: LIST
13939: LIST
13940: LIST
13941: LIST
13942: LIST
13943: LIST
13944: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
13945: LD_ADDR_VAR 0 2
13949: PUSH
13950: LD_INT 22
13952: PUSH
13953: LD_INT 7
13955: PUSH
13956: EMPTY
13957: LIST
13958: LIST
13959: PUSH
13960: LD_INT 23
13962: PUSH
13963: LD_INT 3
13965: PUSH
13966: EMPTY
13967: LIST
13968: LIST
13969: PUSH
13970: LD_INT 25
13972: PUSH
13973: LD_INT 4
13975: PUSH
13976: EMPTY
13977: LIST
13978: LIST
13979: PUSH
13980: LD_INT 26
13982: PUSH
13983: LD_INT 1
13985: PUSH
13986: EMPTY
13987: LIST
13988: LIST
13989: PUSH
13990: EMPTY
13991: LIST
13992: LIST
13993: LIST
13994: LIST
13995: PPUSH
13996: CALL_OW 69
14000: PUSH
14001: LD_VAR 0 3
14005: DIFF
14006: ST_TO_ADDR
// if tmp then
14007: LD_VAR 0 2
14011: IFFALSE 14027
// result := tmp [ 1 ] ;
14013: LD_ADDR_VAR 0 1
14017: PUSH
14018: LD_VAR 0 2
14022: PUSH
14023: LD_INT 1
14025: ARRAY
14026: ST_TO_ADDR
// end ;
14027: LD_VAR 0 1
14031: RET
// export function SolRu ; var tmp , t ; begin
14032: LD_INT 0
14034: PPUSH
14035: PPUSH
14036: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
14037: LD_ADDR_VAR 0 3
14041: PUSH
14042: LD_EXP 34
14046: PUSH
14047: LD_EXP 48
14051: PUSH
14052: LD_EXP 36
14056: PUSH
14057: LD_EXP 49
14061: PUSH
14062: LD_EXP 50
14066: PUSH
14067: LD_EXP 39
14071: PUSH
14072: LD_EXP 40
14076: PUSH
14077: LD_EXP 38
14081: PUSH
14082: EMPTY
14083: LIST
14084: LIST
14085: LIST
14086: LIST
14087: LIST
14088: LIST
14089: LIST
14090: LIST
14091: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
14092: LD_ADDR_VAR 0 2
14096: PUSH
14097: LD_INT 22
14099: PUSH
14100: LD_INT 7
14102: PUSH
14103: EMPTY
14104: LIST
14105: LIST
14106: PUSH
14107: LD_INT 23
14109: PUSH
14110: LD_INT 3
14112: PUSH
14113: EMPTY
14114: LIST
14115: LIST
14116: PUSH
14117: LD_INT 25
14119: PUSH
14120: LD_INT 1
14122: PUSH
14123: EMPTY
14124: LIST
14125: LIST
14126: PUSH
14127: LD_INT 26
14129: PUSH
14130: LD_INT 1
14132: PUSH
14133: EMPTY
14134: LIST
14135: LIST
14136: PUSH
14137: EMPTY
14138: LIST
14139: LIST
14140: LIST
14141: LIST
14142: PPUSH
14143: CALL_OW 69
14147: PUSH
14148: LD_VAR 0 3
14152: DIFF
14153: ST_TO_ADDR
// if tmp then
14154: LD_VAR 0 2
14158: IFFALSE 14174
// result := tmp [ 1 ] ;
14160: LD_ADDR_VAR 0 1
14164: PUSH
14165: LD_VAR 0 2
14169: PUSH
14170: LD_INT 1
14172: ARRAY
14173: ST_TO_ADDR
// end ; end_of_file
14174: LD_VAR 0 1
14178: RET
// export function CustomEvent ( event ) ; begin
14179: LD_INT 0
14181: PPUSH
// end ;
14182: LD_VAR 0 2
14186: RET
// on UnitDestroyed ( un ) do var i , side ;
14187: LD_INT 0
14189: PPUSH
14190: PPUSH
// begin SOS_UnitDestroyed ( un ) ;
14191: LD_VAR 0 1
14195: PPUSH
14196: CALL 103527 0 1
// if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
14200: LD_VAR 0 1
14204: PUSH
14205: LD_INT 22
14207: PUSH
14208: LD_INT 7
14210: PUSH
14211: EMPTY
14212: LIST
14213: LIST
14214: PUSH
14215: LD_INT 2
14217: PUSH
14218: LD_INT 25
14220: PUSH
14221: LD_INT 1
14223: PUSH
14224: EMPTY
14225: LIST
14226: LIST
14227: PUSH
14228: LD_INT 25
14230: PUSH
14231: LD_INT 2
14233: PUSH
14234: EMPTY
14235: LIST
14236: LIST
14237: PUSH
14238: LD_INT 25
14240: PUSH
14241: LD_INT 3
14243: PUSH
14244: EMPTY
14245: LIST
14246: LIST
14247: PUSH
14248: LD_INT 25
14250: PUSH
14251: LD_INT 4
14253: PUSH
14254: EMPTY
14255: LIST
14256: LIST
14257: PUSH
14258: LD_INT 25
14260: PUSH
14261: LD_INT 5
14263: PUSH
14264: EMPTY
14265: LIST
14266: LIST
14267: PUSH
14268: LD_INT 25
14270: PUSH
14271: LD_INT 8
14273: PUSH
14274: EMPTY
14275: LIST
14276: LIST
14277: PUSH
14278: LD_INT 25
14280: PUSH
14281: LD_INT 9
14283: PUSH
14284: EMPTY
14285: LIST
14286: LIST
14287: PUSH
14288: EMPTY
14289: LIST
14290: LIST
14291: LIST
14292: LIST
14293: LIST
14294: LIST
14295: LIST
14296: LIST
14297: PUSH
14298: EMPTY
14299: LIST
14300: LIST
14301: PPUSH
14302: CALL_OW 69
14306: IN
14307: IFFALSE 14323
// loss_counter := loss_counter + 1 ;
14309: LD_ADDR_EXP 14
14313: PUSH
14314: LD_EXP 14
14318: PUSH
14319: LD_INT 1
14321: PLUS
14322: ST_TO_ADDR
// if un = Abdul then
14323: LD_VAR 0 1
14327: PUSH
14328: LD_EXP 57
14332: EQUAL
14333: IFFALSE 14343
// abdul_escaped := false ;
14335: LD_ADDR_EXP 13
14339: PUSH
14340: LD_INT 0
14342: ST_TO_ADDR
// if un in ru_attackers then
14343: LD_VAR 0 1
14347: PUSH
14348: LD_EXP 54
14352: IN
14353: IFFALSE 14371
// ru_attackers := ru_attackers diff un ;
14355: LD_ADDR_EXP 54
14359: PUSH
14360: LD_EXP 54
14364: PUSH
14365: LD_VAR 0 1
14369: DIFF
14370: ST_TO_ADDR
// if un in ar_attackers then
14371: LD_VAR 0 1
14375: PUSH
14376: LD_EXP 11
14380: IN
14381: IFFALSE 14399
// ar_attackers := ar_attackers diff un ;
14383: LD_ADDR_EXP 11
14387: PUSH
14388: LD_EXP 11
14392: PUSH
14393: LD_VAR 0 1
14397: DIFF
14398: ST_TO_ADDR
// if un = JMM then
14399: LD_VAR 0 1
14403: PUSH
14404: LD_EXP 16
14408: EQUAL
14409: IFFALSE 14420
// begin YouLost ( JMM ) ;
14411: LD_STRING JMM
14413: PPUSH
14414: CALL_OW 104
// exit ;
14418: GO 14517
// end ; if un = Burlak then
14420: LD_VAR 0 1
14424: PUSH
14425: LD_EXP 48
14429: EQUAL
14430: IFFALSE 14441
// begin YouLost ( Burlak ) ;
14432: LD_STRING Burlak
14434: PPUSH
14435: CALL_OW 104
// exit ;
14439: GO 14517
// end ; if un = freedom then
14441: LD_VAR 0 1
14445: PUSH
14446: LD_EXP 3
14450: EQUAL
14451: IFFALSE 14462
// begin YouLost ( Destroyed ) ;
14453: LD_STRING Destroyed
14455: PPUSH
14456: CALL_OW 104
// exit ;
14460: GO 14517
// end ; if un = Masha then
14462: LD_VAR 0 1
14466: PUSH
14467: LD_EXP 51
14471: EQUAL
14472: IFFALSE 14489
// begin ChangeMissionObjectives ( M4b ) ;
14474: LD_STRING M4b
14476: PPUSH
14477: CALL_OW 337
// masha_killed := true ;
14481: LD_ADDR_EXP 10
14485: PUSH
14486: LD_INT 1
14488: ST_TO_ADDR
// end ; if un = Mastodont then
14489: LD_VAR 0 1
14493: PUSH
14494: LD_EXP 58
14498: EQUAL
14499: IFFALSE 14508
// ChangeMissionObjectives ( M4a ) ;
14501: LD_STRING M4a
14503: PPUSH
14504: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
14508: LD_VAR 0 1
14512: PPUSH
14513: CALL 84741 0 1
// end ;
14517: PPOPN 3
14519: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
14520: LD_VAR 0 1
14524: PPUSH
14525: LD_VAR 0 2
14529: PPUSH
14530: CALL 87073 0 2
// end ;
14534: PPOPN 2
14536: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
14537: LD_VAR 0 1
14541: PPUSH
14542: CALL 86141 0 1
// end ;
14546: PPOPN 1
14548: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
14549: LD_VAR 0 1
14553: PUSH
14554: LD_INT 22
14556: PUSH
14557: LD_INT 7
14559: PUSH
14560: EMPTY
14561: LIST
14562: LIST
14563: PUSH
14564: LD_INT 30
14566: PUSH
14567: LD_INT 0
14569: PUSH
14570: EMPTY
14571: LIST
14572: LIST
14573: PUSH
14574: EMPTY
14575: LIST
14576: LIST
14577: PPUSH
14578: CALL_OW 69
14582: IN
14583: IFFALSE 14622
// begin SetBName ( building , freedom ) ;
14585: LD_VAR 0 1
14589: PPUSH
14590: LD_STRING freedom
14592: PPUSH
14593: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
14597: LD_INT 0
14599: PPUSH
14600: LD_INT 7
14602: PPUSH
14603: LD_INT 0
14605: PPUSH
14606: CALL_OW 324
// freedom := building ;
14610: LD_ADDR_EXP 3
14614: PUSH
14615: LD_VAR 0 1
14619: ST_TO_ADDR
// exit ;
14620: GO 14688
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
14622: LD_VAR 0 1
14626: PUSH
14627: LD_INT 22
14629: PUSH
14630: LD_INT 7
14632: PUSH
14633: EMPTY
14634: LIST
14635: LIST
14636: PUSH
14637: LD_INT 23
14639: PUSH
14640: LD_INT 3
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 30
14649: PUSH
14650: LD_INT 6
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: EMPTY
14658: LIST
14659: LIST
14660: LIST
14661: PPUSH
14662: CALL_OW 69
14666: IN
14667: IFFALSE 14679
// begin ru_lab_builded := true ;
14669: LD_ADDR_EXP 5
14673: PUSH
14674: LD_INT 1
14676: ST_TO_ADDR
// exit ;
14677: GO 14688
// end ; MCE_BuildingComplete ( building ) ;
14679: LD_VAR 0 1
14683: PPUSH
14684: CALL 86382 0 1
// end ;
14688: PPOPN 1
14690: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
14691: LD_VAR 0 1
14695: PPUSH
14696: LD_VAR 0 2
14700: PPUSH
14701: CALL 84437 0 2
// end ;
14705: PPOPN 2
14707: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
14708: LD_VAR 0 1
14712: PPUSH
14713: LD_VAR 0 2
14717: PPUSH
14718: LD_VAR 0 3
14722: PPUSH
14723: LD_VAR 0 4
14727: PPUSH
14728: LD_VAR 0 5
14732: PPUSH
14733: CALL 84057 0 5
// end ;
14737: PPOPN 5
14739: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
14740: LD_VAR 0 1
14744: PPUSH
14745: LD_VAR 0 2
14749: PPUSH
14750: CALL 103647 0 2
// MCE_VehicleConstructed ( vehicle , factory ) ;
14754: LD_VAR 0 1
14758: PPUSH
14759: LD_VAR 0 2
14763: PPUSH
14764: CALL 83610 0 2
// end ;
14768: PPOPN 2
14770: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
14771: LD_VAR 0 1
14775: PPUSH
14776: CALL_OW 263
14780: PUSH
14781: LD_INT 3
14783: EQUAL
14784: PUSH
14785: LD_VAR 0 2
14789: PPUSH
14790: CALL_OW 263
14794: PUSH
14795: LD_INT 3
14797: EQUAL
14798: OR
14799: IFFALSE 14815
// hack_counter := hack_counter + 1 ;
14801: LD_ADDR_EXP 15
14805: PUSH
14806: LD_EXP 15
14810: PUSH
14811: LD_INT 1
14813: PLUS
14814: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
14815: LD_VAR 0 1
14819: PPUSH
14820: LD_VAR 0 2
14824: PPUSH
14825: LD_VAR 0 3
14829: PPUSH
14830: LD_VAR 0 4
14834: PPUSH
14835: CALL 83448 0 4
// end ;
14839: PPOPN 4
14841: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
14842: LD_VAR 0 1
14846: PPUSH
14847: LD_VAR 0 2
14851: PPUSH
14852: LD_VAR 0 3
14856: PPUSH
14857: CALL 83223 0 3
// end ;
14861: PPOPN 3
14863: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
14864: LD_VAR 0 1
14868: PPUSH
14869: LD_VAR 0 2
14873: PPUSH
14874: CALL 83108 0 2
// end ;
14878: PPOPN 2
14880: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
14881: LD_VAR 0 1
14885: PPUSH
14886: LD_VAR 0 2
14890: PPUSH
14891: CALL 87368 0 2
// end ;
14895: PPOPN 2
14897: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
14898: LD_VAR 0 1
14902: PPUSH
14903: LD_VAR 0 2
14907: PPUSH
14908: LD_VAR 0 3
14912: PPUSH
14913: LD_VAR 0 4
14917: PPUSH
14918: CALL 87584 0 4
// end ;
14922: PPOPN 4
14924: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
14925: LD_VAR 0 1
14929: PPUSH
14930: LD_VAR 0 2
14934: PPUSH
14935: CALL 82917 0 2
// end ;
14939: PPOPN 2
14941: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
14942: LD_VAR 0 1
14946: PPUSH
14947: CALL 103631 0 1
// end ; end_of_file
14951: PPOPN 1
14953: END
// every 0 0$30 do var cr , time ;
14954: GO 14956
14956: DISABLE
14957: LD_INT 0
14959: PPUSH
14960: PPUSH
// begin time := 0 0$20 ;
14961: LD_ADDR_VAR 0 2
14965: PUSH
14966: LD_INT 700
14968: ST_TO_ADDR
// while game do
14969: LD_EXP 2
14973: IFFALSE 15076
// begin wait ( time ) ;
14975: LD_VAR 0 2
14979: PPUSH
14980: CALL_OW 67
// if tick > 2 2$00 then
14984: LD_OWVAR 1
14988: PUSH
14989: LD_INT 4200
14991: GREATER
14992: IFFALSE 15029
// time := time + [ 0 0$04 , 0 0$4 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
14994: LD_ADDR_VAR 0 2
14998: PUSH
14999: LD_VAR 0 2
15003: PUSH
15004: LD_INT 140
15006: PUSH
15007: LD_INT 140
15009: PUSH
15010: LD_INT 210
15012: PUSH
15013: LD_INT 280
15015: PUSH
15016: EMPTY
15017: LIST
15018: LIST
15019: LIST
15020: LIST
15021: PUSH
15022: LD_OWVAR 67
15026: ARRAY
15027: PLUS
15028: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
15029: LD_INT 1
15031: PPUSH
15032: LD_INT 5
15034: PPUSH
15035: CALL_OW 12
15039: PPUSH
15040: LD_INT 70
15042: PPUSH
15043: LD_INT 49
15045: PPUSH
15046: LD_INT 25
15048: PPUSH
15049: LD_INT 1
15051: PPUSH
15052: CALL_OW 56
// if time > 3 3$00 then
15056: LD_VAR 0 2
15060: PUSH
15061: LD_INT 6300
15063: GREATER
15064: IFFALSE 15074
// time := 0 0$30 ;
15066: LD_ADDR_VAR 0 2
15070: PUSH
15071: LD_INT 1050
15073: ST_TO_ADDR
// end ;
15074: GO 14969
// end ;
15076: PPOPN 2
15078: END
// every 0 0$30 do var cr , time ;
15079: GO 15081
15081: DISABLE
15082: LD_INT 0
15084: PPUSH
15085: PPUSH
// begin time := 0 0$20 ;
15086: LD_ADDR_VAR 0 2
15090: PUSH
15091: LD_INT 700
15093: ST_TO_ADDR
// while game do
15094: LD_EXP 2
15098: IFFALSE 15191
// begin wait ( time ) ;
15100: LD_VAR 0 2
15104: PPUSH
15105: CALL_OW 67
// time := time + [ 0 0$4 , 0 0$5 , 0 0$6 , 0 0$8 ] [ Difficulty ] ;
15109: LD_ADDR_VAR 0 2
15113: PUSH
15114: LD_VAR 0 2
15118: PUSH
15119: LD_INT 140
15121: PUSH
15122: LD_INT 175
15124: PUSH
15125: LD_INT 210
15127: PUSH
15128: LD_INT 280
15130: PUSH
15131: EMPTY
15132: LIST
15133: LIST
15134: LIST
15135: LIST
15136: PUSH
15137: LD_OWVAR 67
15141: ARRAY
15142: PLUS
15143: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
15144: LD_INT 3
15146: PPUSH
15147: LD_INT 5
15149: PPUSH
15150: CALL_OW 12
15154: PPUSH
15155: LD_INT 26
15157: PPUSH
15158: LD_INT 9
15160: PPUSH
15161: LD_INT 30
15163: PPUSH
15164: LD_INT 1
15166: PPUSH
15167: CALL_OW 56
// if time > 3 3$00 then
15171: LD_VAR 0 2
15175: PUSH
15176: LD_INT 6300
15178: GREATER
15179: IFFALSE 15189
// time := 0 0$20 ;
15181: LD_ADDR_VAR 0 2
15185: PUSH
15186: LD_INT 700
15188: ST_TO_ADDR
// end ;
15189: GO 15094
// end ;
15191: PPOPN 2
15193: END
// every 0 0$30 do var cr , time ;
15194: GO 15196
15196: DISABLE
15197: LD_INT 0
15199: PPUSH
15200: PPUSH
// begin time := 0 0$20 ;
15201: LD_ADDR_VAR 0 2
15205: PUSH
15206: LD_INT 700
15208: ST_TO_ADDR
// while game do
15209: LD_EXP 2
15213: IFFALSE 15342
// begin wait ( time ) ;
15215: LD_VAR 0 2
15219: PPUSH
15220: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 , 0 0$10 ] [ Difficulty ] ;
15224: LD_ADDR_VAR 0 2
15228: PUSH
15229: LD_VAR 0 2
15233: PUSH
15234: LD_INT 175
15236: PUSH
15237: LD_INT 210
15239: PUSH
15240: LD_INT 280
15242: PUSH
15243: LD_INT 350
15245: PUSH
15246: EMPTY
15247: LIST
15248: LIST
15249: LIST
15250: LIST
15251: PUSH
15252: LD_OWVAR 67
15256: ARRAY
15257: PLUS
15258: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
15259: LD_INT 1
15261: PPUSH
15262: LD_INT 5
15264: PPUSH
15265: CALL_OW 12
15269: PPUSH
15270: LD_INT 179
15272: PPUSH
15273: LD_INT 101
15275: PPUSH
15276: LD_INT 20
15278: PPUSH
15279: LD_INT 1
15281: PPUSH
15282: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
15286: LD_INT 350
15288: PPUSH
15289: LD_INT 525
15291: PPUSH
15292: CALL_OW 12
15296: PPUSH
15297: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
15301: LD_INT 1
15303: PPUSH
15304: LD_INT 5
15306: PPUSH
15307: CALL_OW 12
15311: PPUSH
15312: LD_INT 9
15314: PPUSH
15315: LD_INT 1
15317: PPUSH
15318: CALL_OW 55
// if time > 4 4$00 then
15322: LD_VAR 0 2
15326: PUSH
15327: LD_INT 8400
15329: GREATER
15330: IFFALSE 15340
// time := 0 0$30 ;
15332: LD_ADDR_VAR 0 2
15336: PUSH
15337: LD_INT 1050
15339: ST_TO_ADDR
// end ;
15340: GO 15209
// end ;
15342: PPOPN 2
15344: END
// every 0 0$30 do var cr , time ;
15345: GO 15347
15347: DISABLE
15348: LD_INT 0
15350: PPUSH
15351: PPUSH
// begin time := 0 0$10 ;
15352: LD_ADDR_VAR 0 2
15356: PUSH
15357: LD_INT 350
15359: ST_TO_ADDR
// while game do
15360: LD_EXP 2
15364: IFFALSE 15498
// begin wait ( time ) ;
15366: LD_VAR 0 2
15370: PPUSH
15371: CALL_OW 67
// time := time + 0 0$10 ;
15375: LD_ADDR_VAR 0 2
15379: PUSH
15380: LD_VAR 0 2
15384: PUSH
15385: LD_INT 350
15387: PLUS
15388: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
15389: LD_INT 1
15391: PPUSH
15392: LD_INT 5
15394: PPUSH
15395: CALL_OW 12
15399: PPUSH
15400: LD_INT 11
15402: PPUSH
15403: LD_INT 1
15405: PPUSH
15406: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
15410: LD_ADDR_VAR 0 1
15414: PUSH
15415: LD_INT 1
15417: PPUSH
15418: LD_INT 3
15420: PPUSH
15421: CALL_OW 12
15425: ST_TO_ADDR
// if cr = 1 then
15426: LD_VAR 0 1
15430: PUSH
15431: LD_INT 1
15433: EQUAL
15434: IFFALSE 15478
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
15436: LD_INT 700
15438: PPUSH
15439: LD_INT 1575
15441: PPUSH
15442: CALL_OW 12
15446: PPUSH
15447: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
15451: LD_INT 1
15453: PPUSH
15454: LD_INT 5
15456: PPUSH
15457: CALL_OW 12
15461: PPUSH
15462: LD_INT 34
15464: PPUSH
15465: LD_INT 50
15467: PPUSH
15468: LD_INT 7
15470: PPUSH
15471: LD_INT 1
15473: PPUSH
15474: CALL_OW 56
// end ; if time > 4 4$00 then
15478: LD_VAR 0 2
15482: PUSH
15483: LD_INT 8400
15485: GREATER
15486: IFFALSE 15496
// time := 0 0$40 ;
15488: LD_ADDR_VAR 0 2
15492: PUSH
15493: LD_INT 1400
15495: ST_TO_ADDR
// end ;
15496: GO 15360
// end ; end_of_file
15498: PPOPN 2
15500: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
15501: LD_INT 0
15503: PPUSH
15504: PPUSH
// if exist_mode then
15505: LD_VAR 0 2
15509: IFFALSE 15534
// unit := CreateCharacter ( prefix & ident ) else
15511: LD_ADDR_VAR 0 5
15515: PUSH
15516: LD_VAR 0 3
15520: PUSH
15521: LD_VAR 0 1
15525: STR
15526: PPUSH
15527: CALL_OW 34
15531: ST_TO_ADDR
15532: GO 15549
// unit := NewCharacter ( ident ) ;
15534: LD_ADDR_VAR 0 5
15538: PUSH
15539: LD_VAR 0 1
15543: PPUSH
15544: CALL_OW 25
15548: ST_TO_ADDR
// result := unit ;
15549: LD_ADDR_VAR 0 4
15553: PUSH
15554: LD_VAR 0 5
15558: ST_TO_ADDR
// end ;
15559: LD_VAR 0 4
15563: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
15564: LD_INT 0
15566: PPUSH
15567: PPUSH
// if not side or not nation then
15568: LD_VAR 0 1
15572: NOT
15573: PUSH
15574: LD_VAR 0 2
15578: NOT
15579: OR
15580: IFFALSE 15584
// exit ;
15582: GO 16352
// case nation of nation_american :
15584: LD_VAR 0 2
15588: PUSH
15589: LD_INT 1
15591: DOUBLE
15592: EQUAL
15593: IFTRUE 15597
15595: GO 15811
15597: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
15598: LD_ADDR_VAR 0 4
15602: PUSH
15603: LD_INT 35
15605: PUSH
15606: LD_INT 45
15608: PUSH
15609: LD_INT 46
15611: PUSH
15612: LD_INT 47
15614: PUSH
15615: LD_INT 82
15617: PUSH
15618: LD_INT 83
15620: PUSH
15621: LD_INT 84
15623: PUSH
15624: LD_INT 85
15626: PUSH
15627: LD_INT 86
15629: PUSH
15630: LD_INT 1
15632: PUSH
15633: LD_INT 2
15635: PUSH
15636: LD_INT 6
15638: PUSH
15639: LD_INT 15
15641: PUSH
15642: LD_INT 16
15644: PUSH
15645: LD_INT 7
15647: PUSH
15648: LD_INT 12
15650: PUSH
15651: LD_INT 13
15653: PUSH
15654: LD_INT 10
15656: PUSH
15657: LD_INT 14
15659: PUSH
15660: LD_INT 20
15662: PUSH
15663: LD_INT 21
15665: PUSH
15666: LD_INT 22
15668: PUSH
15669: LD_INT 25
15671: PUSH
15672: LD_INT 32
15674: PUSH
15675: LD_INT 27
15677: PUSH
15678: LD_INT 36
15680: PUSH
15681: LD_INT 69
15683: PUSH
15684: LD_INT 39
15686: PUSH
15687: LD_INT 34
15689: PUSH
15690: LD_INT 40
15692: PUSH
15693: LD_INT 48
15695: PUSH
15696: LD_INT 49
15698: PUSH
15699: LD_INT 50
15701: PUSH
15702: LD_INT 51
15704: PUSH
15705: LD_INT 52
15707: PUSH
15708: LD_INT 53
15710: PUSH
15711: LD_INT 54
15713: PUSH
15714: LD_INT 55
15716: PUSH
15717: LD_INT 56
15719: PUSH
15720: LD_INT 57
15722: PUSH
15723: LD_INT 58
15725: PUSH
15726: LD_INT 59
15728: PUSH
15729: LD_INT 60
15731: PUSH
15732: LD_INT 61
15734: PUSH
15735: LD_INT 62
15737: PUSH
15738: LD_INT 80
15740: PUSH
15741: LD_INT 82
15743: PUSH
15744: LD_INT 83
15746: PUSH
15747: LD_INT 84
15749: PUSH
15750: LD_INT 85
15752: PUSH
15753: LD_INT 86
15755: PUSH
15756: EMPTY
15757: LIST
15758: LIST
15759: LIST
15760: LIST
15761: LIST
15762: LIST
15763: LIST
15764: LIST
15765: LIST
15766: LIST
15767: LIST
15768: LIST
15769: LIST
15770: LIST
15771: LIST
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: LIST
15777: LIST
15778: LIST
15779: LIST
15780: LIST
15781: LIST
15782: LIST
15783: LIST
15784: LIST
15785: LIST
15786: LIST
15787: LIST
15788: LIST
15789: LIST
15790: LIST
15791: LIST
15792: LIST
15793: LIST
15794: LIST
15795: LIST
15796: LIST
15797: LIST
15798: LIST
15799: LIST
15800: LIST
15801: LIST
15802: LIST
15803: LIST
15804: LIST
15805: LIST
15806: LIST
15807: LIST
15808: ST_TO_ADDR
15809: GO 16276
15811: LD_INT 2
15813: DOUBLE
15814: EQUAL
15815: IFTRUE 15819
15817: GO 16045
15819: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
15820: LD_ADDR_VAR 0 4
15824: PUSH
15825: LD_INT 35
15827: PUSH
15828: LD_INT 45
15830: PUSH
15831: LD_INT 46
15833: PUSH
15834: LD_INT 47
15836: PUSH
15837: LD_INT 82
15839: PUSH
15840: LD_INT 83
15842: PUSH
15843: LD_INT 84
15845: PUSH
15846: LD_INT 85
15848: PUSH
15849: LD_INT 87
15851: PUSH
15852: LD_INT 70
15854: PUSH
15855: LD_INT 1
15857: PUSH
15858: LD_INT 11
15860: PUSH
15861: LD_INT 3
15863: PUSH
15864: LD_INT 4
15866: PUSH
15867: LD_INT 5
15869: PUSH
15870: LD_INT 6
15872: PUSH
15873: LD_INT 15
15875: PUSH
15876: LD_INT 18
15878: PUSH
15879: LD_INT 7
15881: PUSH
15882: LD_INT 17
15884: PUSH
15885: LD_INT 8
15887: PUSH
15888: LD_INT 20
15890: PUSH
15891: LD_INT 21
15893: PUSH
15894: LD_INT 22
15896: PUSH
15897: LD_INT 72
15899: PUSH
15900: LD_INT 26
15902: PUSH
15903: LD_INT 69
15905: PUSH
15906: LD_INT 39
15908: PUSH
15909: LD_INT 40
15911: PUSH
15912: LD_INT 41
15914: PUSH
15915: LD_INT 42
15917: PUSH
15918: LD_INT 43
15920: PUSH
15921: LD_INT 48
15923: PUSH
15924: LD_INT 49
15926: PUSH
15927: LD_INT 50
15929: PUSH
15930: LD_INT 51
15932: PUSH
15933: LD_INT 52
15935: PUSH
15936: LD_INT 53
15938: PUSH
15939: LD_INT 54
15941: PUSH
15942: LD_INT 55
15944: PUSH
15945: LD_INT 56
15947: PUSH
15948: LD_INT 60
15950: PUSH
15951: LD_INT 61
15953: PUSH
15954: LD_INT 62
15956: PUSH
15957: LD_INT 66
15959: PUSH
15960: LD_INT 67
15962: PUSH
15963: LD_INT 68
15965: PUSH
15966: LD_INT 81
15968: PUSH
15969: LD_INT 82
15971: PUSH
15972: LD_INT 83
15974: PUSH
15975: LD_INT 84
15977: PUSH
15978: LD_INT 85
15980: PUSH
15981: LD_INT 87
15983: PUSH
15984: LD_INT 88
15986: PUSH
15987: EMPTY
15988: LIST
15989: LIST
15990: LIST
15991: LIST
15992: LIST
15993: LIST
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: LIST
16001: LIST
16002: LIST
16003: LIST
16004: LIST
16005: LIST
16006: LIST
16007: LIST
16008: LIST
16009: LIST
16010: LIST
16011: LIST
16012: LIST
16013: LIST
16014: LIST
16015: LIST
16016: LIST
16017: LIST
16018: LIST
16019: LIST
16020: LIST
16021: LIST
16022: LIST
16023: LIST
16024: LIST
16025: LIST
16026: LIST
16027: LIST
16028: LIST
16029: LIST
16030: LIST
16031: LIST
16032: LIST
16033: LIST
16034: LIST
16035: LIST
16036: LIST
16037: LIST
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: ST_TO_ADDR
16043: GO 16276
16045: LD_INT 3
16047: DOUBLE
16048: EQUAL
16049: IFTRUE 16053
16051: GO 16275
16053: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
16054: LD_ADDR_VAR 0 4
16058: PUSH
16059: LD_INT 46
16061: PUSH
16062: LD_INT 47
16064: PUSH
16065: LD_INT 1
16067: PUSH
16068: LD_INT 2
16070: PUSH
16071: LD_INT 82
16073: PUSH
16074: LD_INT 83
16076: PUSH
16077: LD_INT 84
16079: PUSH
16080: LD_INT 85
16082: PUSH
16083: LD_INT 86
16085: PUSH
16086: LD_INT 11
16088: PUSH
16089: LD_INT 9
16091: PUSH
16092: LD_INT 20
16094: PUSH
16095: LD_INT 19
16097: PUSH
16098: LD_INT 21
16100: PUSH
16101: LD_INT 24
16103: PUSH
16104: LD_INT 22
16106: PUSH
16107: LD_INT 25
16109: PUSH
16110: LD_INT 28
16112: PUSH
16113: LD_INT 29
16115: PUSH
16116: LD_INT 30
16118: PUSH
16119: LD_INT 31
16121: PUSH
16122: LD_INT 37
16124: PUSH
16125: LD_INT 38
16127: PUSH
16128: LD_INT 32
16130: PUSH
16131: LD_INT 27
16133: PUSH
16134: LD_INT 33
16136: PUSH
16137: LD_INT 69
16139: PUSH
16140: LD_INT 39
16142: PUSH
16143: LD_INT 34
16145: PUSH
16146: LD_INT 40
16148: PUSH
16149: LD_INT 71
16151: PUSH
16152: LD_INT 23
16154: PUSH
16155: LD_INT 44
16157: PUSH
16158: LD_INT 48
16160: PUSH
16161: LD_INT 49
16163: PUSH
16164: LD_INT 50
16166: PUSH
16167: LD_INT 51
16169: PUSH
16170: LD_INT 52
16172: PUSH
16173: LD_INT 53
16175: PUSH
16176: LD_INT 54
16178: PUSH
16179: LD_INT 55
16181: PUSH
16182: LD_INT 56
16184: PUSH
16185: LD_INT 57
16187: PUSH
16188: LD_INT 58
16190: PUSH
16191: LD_INT 59
16193: PUSH
16194: LD_INT 63
16196: PUSH
16197: LD_INT 64
16199: PUSH
16200: LD_INT 65
16202: PUSH
16203: LD_INT 82
16205: PUSH
16206: LD_INT 83
16208: PUSH
16209: LD_INT 84
16211: PUSH
16212: LD_INT 85
16214: PUSH
16215: LD_INT 86
16217: PUSH
16218: EMPTY
16219: LIST
16220: LIST
16221: LIST
16222: LIST
16223: LIST
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: LIST
16229: LIST
16230: LIST
16231: LIST
16232: LIST
16233: LIST
16234: LIST
16235: LIST
16236: LIST
16237: LIST
16238: LIST
16239: LIST
16240: LIST
16241: LIST
16242: LIST
16243: LIST
16244: LIST
16245: LIST
16246: LIST
16247: LIST
16248: LIST
16249: LIST
16250: LIST
16251: LIST
16252: LIST
16253: LIST
16254: LIST
16255: LIST
16256: LIST
16257: LIST
16258: LIST
16259: LIST
16260: LIST
16261: LIST
16262: LIST
16263: LIST
16264: LIST
16265: LIST
16266: LIST
16267: LIST
16268: LIST
16269: LIST
16270: LIST
16271: LIST
16272: ST_TO_ADDR
16273: GO 16276
16275: POP
// if state > - 1 and state < 3 then
16276: LD_VAR 0 3
16280: PUSH
16281: LD_INT 1
16283: NEG
16284: GREATER
16285: PUSH
16286: LD_VAR 0 3
16290: PUSH
16291: LD_INT 3
16293: LESS
16294: AND
16295: IFFALSE 16352
// for i in result do
16297: LD_ADDR_VAR 0 5
16301: PUSH
16302: LD_VAR 0 4
16306: PUSH
16307: FOR_IN
16308: IFFALSE 16350
// if GetTech ( i , side ) <> state then
16310: LD_VAR 0 5
16314: PPUSH
16315: LD_VAR 0 1
16319: PPUSH
16320: CALL_OW 321
16324: PUSH
16325: LD_VAR 0 3
16329: NONEQUAL
16330: IFFALSE 16348
// result := result diff i ;
16332: LD_ADDR_VAR 0 4
16336: PUSH
16337: LD_VAR 0 4
16341: PUSH
16342: LD_VAR 0 5
16346: DIFF
16347: ST_TO_ADDR
16348: GO 16307
16350: POP
16351: POP
// end ;
16352: LD_VAR 0 4
16356: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
16357: LD_INT 0
16359: PPUSH
16360: PPUSH
16361: PPUSH
// result := true ;
16362: LD_ADDR_VAR 0 3
16366: PUSH
16367: LD_INT 1
16369: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
16370: LD_ADDR_VAR 0 5
16374: PUSH
16375: LD_VAR 0 2
16379: PPUSH
16380: CALL_OW 480
16384: ST_TO_ADDR
// if not tmp then
16385: LD_VAR 0 5
16389: NOT
16390: IFFALSE 16394
// exit ;
16392: GO 16443
// for i in tmp do
16394: LD_ADDR_VAR 0 4
16398: PUSH
16399: LD_VAR 0 5
16403: PUSH
16404: FOR_IN
16405: IFFALSE 16441
// if GetTech ( i , side ) <> state_researched then
16407: LD_VAR 0 4
16411: PPUSH
16412: LD_VAR 0 1
16416: PPUSH
16417: CALL_OW 321
16421: PUSH
16422: LD_INT 2
16424: NONEQUAL
16425: IFFALSE 16439
// begin result := false ;
16427: LD_ADDR_VAR 0 3
16431: PUSH
16432: LD_INT 0
16434: ST_TO_ADDR
// exit ;
16435: POP
16436: POP
16437: GO 16443
// end ;
16439: GO 16404
16441: POP
16442: POP
// end ;
16443: LD_VAR 0 3
16447: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
16448: LD_INT 0
16450: PPUSH
16451: PPUSH
16452: PPUSH
16453: PPUSH
16454: PPUSH
16455: PPUSH
16456: PPUSH
16457: PPUSH
16458: PPUSH
16459: PPUSH
16460: PPUSH
16461: PPUSH
16462: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
16463: LD_VAR 0 1
16467: NOT
16468: PUSH
16469: LD_VAR 0 1
16473: PPUSH
16474: CALL_OW 257
16478: PUSH
16479: LD_INT 9
16481: NONEQUAL
16482: OR
16483: IFFALSE 16487
// exit ;
16485: GO 17060
// side := GetSide ( unit ) ;
16487: LD_ADDR_VAR 0 9
16491: PUSH
16492: LD_VAR 0 1
16496: PPUSH
16497: CALL_OW 255
16501: ST_TO_ADDR
// tech_space := tech_spacanom ;
16502: LD_ADDR_VAR 0 12
16506: PUSH
16507: LD_INT 29
16509: ST_TO_ADDR
// tech_time := tech_taurad ;
16510: LD_ADDR_VAR 0 13
16514: PUSH
16515: LD_INT 28
16517: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
16518: LD_ADDR_VAR 0 11
16522: PUSH
16523: LD_VAR 0 1
16527: PPUSH
16528: CALL_OW 310
16532: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
16533: LD_VAR 0 11
16537: PPUSH
16538: CALL_OW 247
16542: PUSH
16543: LD_INT 2
16545: EQUAL
16546: IFFALSE 16550
// exit ;
16548: GO 17060
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16550: LD_ADDR_VAR 0 8
16554: PUSH
16555: LD_INT 81
16557: PUSH
16558: LD_VAR 0 9
16562: PUSH
16563: EMPTY
16564: LIST
16565: LIST
16566: PUSH
16567: LD_INT 3
16569: PUSH
16570: LD_INT 21
16572: PUSH
16573: LD_INT 3
16575: PUSH
16576: EMPTY
16577: LIST
16578: LIST
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: EMPTY
16585: LIST
16586: LIST
16587: PPUSH
16588: CALL_OW 69
16592: ST_TO_ADDR
// if not tmp then
16593: LD_VAR 0 8
16597: NOT
16598: IFFALSE 16602
// exit ;
16600: GO 17060
// if in_unit then
16602: LD_VAR 0 11
16606: IFFALSE 16630
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
16608: LD_ADDR_VAR 0 10
16612: PUSH
16613: LD_VAR 0 8
16617: PPUSH
16618: LD_VAR 0 11
16622: PPUSH
16623: CALL_OW 74
16627: ST_TO_ADDR
16628: GO 16650
// enemy := NearestUnitToUnit ( tmp , unit ) ;
16630: LD_ADDR_VAR 0 10
16634: PUSH
16635: LD_VAR 0 8
16639: PPUSH
16640: LD_VAR 0 1
16644: PPUSH
16645: CALL_OW 74
16649: ST_TO_ADDR
// if not enemy then
16650: LD_VAR 0 10
16654: NOT
16655: IFFALSE 16659
// exit ;
16657: GO 17060
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
16659: LD_VAR 0 11
16663: PUSH
16664: LD_VAR 0 11
16668: PPUSH
16669: LD_VAR 0 10
16673: PPUSH
16674: CALL_OW 296
16678: PUSH
16679: LD_INT 13
16681: GREATER
16682: AND
16683: PUSH
16684: LD_VAR 0 1
16688: PPUSH
16689: LD_VAR 0 10
16693: PPUSH
16694: CALL_OW 296
16698: PUSH
16699: LD_INT 12
16701: GREATER
16702: OR
16703: IFFALSE 16707
// exit ;
16705: GO 17060
// missile := [ 1 ] ;
16707: LD_ADDR_VAR 0 14
16711: PUSH
16712: LD_INT 1
16714: PUSH
16715: EMPTY
16716: LIST
16717: ST_TO_ADDR
// if Researched ( side , tech_space ) then
16718: LD_VAR 0 9
16722: PPUSH
16723: LD_VAR 0 12
16727: PPUSH
16728: CALL_OW 325
16732: IFFALSE 16761
// missile := Replace ( missile , missile + 1 , 2 ) ;
16734: LD_ADDR_VAR 0 14
16738: PUSH
16739: LD_VAR 0 14
16743: PPUSH
16744: LD_VAR 0 14
16748: PUSH
16749: LD_INT 1
16751: PLUS
16752: PPUSH
16753: LD_INT 2
16755: PPUSH
16756: CALL_OW 1
16760: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
16761: LD_VAR 0 9
16765: PPUSH
16766: LD_VAR 0 13
16770: PPUSH
16771: CALL_OW 325
16775: PUSH
16776: LD_VAR 0 10
16780: PPUSH
16781: CALL_OW 255
16785: PPUSH
16786: LD_VAR 0 13
16790: PPUSH
16791: CALL_OW 325
16795: NOT
16796: AND
16797: IFFALSE 16826
// missile := Replace ( missile , missile + 1 , 3 ) ;
16799: LD_ADDR_VAR 0 14
16803: PUSH
16804: LD_VAR 0 14
16808: PPUSH
16809: LD_VAR 0 14
16813: PUSH
16814: LD_INT 1
16816: PLUS
16817: PPUSH
16818: LD_INT 3
16820: PPUSH
16821: CALL_OW 1
16825: ST_TO_ADDR
// if missile < 2 then
16826: LD_VAR 0 14
16830: PUSH
16831: LD_INT 2
16833: LESS
16834: IFFALSE 16838
// exit ;
16836: GO 17060
// x := GetX ( enemy ) ;
16838: LD_ADDR_VAR 0 4
16842: PUSH
16843: LD_VAR 0 10
16847: PPUSH
16848: CALL_OW 250
16852: ST_TO_ADDR
// y := GetY ( enemy ) ;
16853: LD_ADDR_VAR 0 5
16857: PUSH
16858: LD_VAR 0 10
16862: PPUSH
16863: CALL_OW 251
16867: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
16868: LD_ADDR_VAR 0 6
16872: PUSH
16873: LD_VAR 0 4
16877: PUSH
16878: LD_INT 1
16880: NEG
16881: PPUSH
16882: LD_INT 1
16884: PPUSH
16885: CALL_OW 12
16889: PLUS
16890: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
16891: LD_ADDR_VAR 0 7
16895: PUSH
16896: LD_VAR 0 5
16900: PUSH
16901: LD_INT 1
16903: NEG
16904: PPUSH
16905: LD_INT 1
16907: PPUSH
16908: CALL_OW 12
16912: PLUS
16913: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
16914: LD_VAR 0 6
16918: PPUSH
16919: LD_VAR 0 7
16923: PPUSH
16924: CALL_OW 488
16928: NOT
16929: IFFALSE 16951
// begin _x := x ;
16931: LD_ADDR_VAR 0 6
16935: PUSH
16936: LD_VAR 0 4
16940: ST_TO_ADDR
// _y := y ;
16941: LD_ADDR_VAR 0 7
16945: PUSH
16946: LD_VAR 0 5
16950: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
16951: LD_ADDR_VAR 0 3
16955: PUSH
16956: LD_INT 1
16958: PPUSH
16959: LD_VAR 0 14
16963: PPUSH
16964: CALL_OW 12
16968: ST_TO_ADDR
// case i of 1 :
16969: LD_VAR 0 3
16973: PUSH
16974: LD_INT 1
16976: DOUBLE
16977: EQUAL
16978: IFTRUE 16982
16980: GO 16999
16982: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
16983: LD_VAR 0 1
16987: PPUSH
16988: LD_VAR 0 10
16992: PPUSH
16993: CALL_OW 115
16997: GO 17060
16999: LD_INT 2
17001: DOUBLE
17002: EQUAL
17003: IFTRUE 17007
17005: GO 17029
17007: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
17008: LD_VAR 0 1
17012: PPUSH
17013: LD_VAR 0 6
17017: PPUSH
17018: LD_VAR 0 7
17022: PPUSH
17023: CALL_OW 153
17027: GO 17060
17029: LD_INT 3
17031: DOUBLE
17032: EQUAL
17033: IFTRUE 17037
17035: GO 17059
17037: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
17038: LD_VAR 0 1
17042: PPUSH
17043: LD_VAR 0 6
17047: PPUSH
17048: LD_VAR 0 7
17052: PPUSH
17053: CALL_OW 154
17057: GO 17060
17059: POP
// end ;
17060: LD_VAR 0 2
17064: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
17065: LD_INT 0
17067: PPUSH
17068: PPUSH
17069: PPUSH
17070: PPUSH
17071: PPUSH
17072: PPUSH
// if not unit or not building then
17073: LD_VAR 0 1
17077: NOT
17078: PUSH
17079: LD_VAR 0 2
17083: NOT
17084: OR
17085: IFFALSE 17089
// exit ;
17087: GO 17247
// x := GetX ( building ) ;
17089: LD_ADDR_VAR 0 5
17093: PUSH
17094: LD_VAR 0 2
17098: PPUSH
17099: CALL_OW 250
17103: ST_TO_ADDR
// y := GetY ( building ) ;
17104: LD_ADDR_VAR 0 6
17108: PUSH
17109: LD_VAR 0 2
17113: PPUSH
17114: CALL_OW 251
17118: ST_TO_ADDR
// for i = 0 to 5 do
17119: LD_ADDR_VAR 0 4
17123: PUSH
17124: DOUBLE
17125: LD_INT 0
17127: DEC
17128: ST_TO_ADDR
17129: LD_INT 5
17131: PUSH
17132: FOR_TO
17133: IFFALSE 17245
// begin _x := ShiftX ( x , i , 3 ) ;
17135: LD_ADDR_VAR 0 7
17139: PUSH
17140: LD_VAR 0 5
17144: PPUSH
17145: LD_VAR 0 4
17149: PPUSH
17150: LD_INT 3
17152: PPUSH
17153: CALL_OW 272
17157: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
17158: LD_ADDR_VAR 0 8
17162: PUSH
17163: LD_VAR 0 6
17167: PPUSH
17168: LD_VAR 0 4
17172: PPUSH
17173: LD_INT 3
17175: PPUSH
17176: CALL_OW 273
17180: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
17181: LD_VAR 0 7
17185: PPUSH
17186: LD_VAR 0 8
17190: PPUSH
17191: CALL_OW 488
17195: NOT
17196: IFFALSE 17200
// continue ;
17198: GO 17132
// if HexInfo ( _x , _y ) = 0 then
17200: LD_VAR 0 7
17204: PPUSH
17205: LD_VAR 0 8
17209: PPUSH
17210: CALL_OW 428
17214: PUSH
17215: LD_INT 0
17217: EQUAL
17218: IFFALSE 17243
// begin ComMoveXY ( unit , _x , _y ) ;
17220: LD_VAR 0 1
17224: PPUSH
17225: LD_VAR 0 7
17229: PPUSH
17230: LD_VAR 0 8
17234: PPUSH
17235: CALL_OW 111
// exit ;
17239: POP
17240: POP
17241: GO 17247
// end ; end ;
17243: GO 17132
17245: POP
17246: POP
// end ;
17247: LD_VAR 0 3
17251: RET
// export function ScanBase ( side , base_area ) ; begin
17252: LD_INT 0
17254: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
17255: LD_ADDR_VAR 0 3
17259: PUSH
17260: LD_VAR 0 2
17264: PPUSH
17265: LD_INT 81
17267: PUSH
17268: LD_VAR 0 1
17272: PUSH
17273: EMPTY
17274: LIST
17275: LIST
17276: PPUSH
17277: CALL_OW 70
17281: ST_TO_ADDR
// end ;
17282: LD_VAR 0 3
17286: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
17287: LD_INT 0
17289: PPUSH
17290: PPUSH
17291: PPUSH
17292: PPUSH
// result := false ;
17293: LD_ADDR_VAR 0 2
17297: PUSH
17298: LD_INT 0
17300: ST_TO_ADDR
// side := GetSide ( unit ) ;
17301: LD_ADDR_VAR 0 3
17305: PUSH
17306: LD_VAR 0 1
17310: PPUSH
17311: CALL_OW 255
17315: ST_TO_ADDR
// nat := GetNation ( unit ) ;
17316: LD_ADDR_VAR 0 4
17320: PUSH
17321: LD_VAR 0 1
17325: PPUSH
17326: CALL_OW 248
17330: ST_TO_ADDR
// case nat of 1 :
17331: LD_VAR 0 4
17335: PUSH
17336: LD_INT 1
17338: DOUBLE
17339: EQUAL
17340: IFTRUE 17344
17342: GO 17355
17344: POP
// tech := tech_lassight ; 2 :
17345: LD_ADDR_VAR 0 5
17349: PUSH
17350: LD_INT 12
17352: ST_TO_ADDR
17353: GO 17394
17355: LD_INT 2
17357: DOUBLE
17358: EQUAL
17359: IFTRUE 17363
17361: GO 17374
17363: POP
// tech := tech_mortar ; 3 :
17364: LD_ADDR_VAR 0 5
17368: PUSH
17369: LD_INT 41
17371: ST_TO_ADDR
17372: GO 17394
17374: LD_INT 3
17376: DOUBLE
17377: EQUAL
17378: IFTRUE 17382
17380: GO 17393
17382: POP
// tech := tech_bazooka ; end ;
17383: LD_ADDR_VAR 0 5
17387: PUSH
17388: LD_INT 44
17390: ST_TO_ADDR
17391: GO 17394
17393: POP
// if Researched ( side , tech ) then
17394: LD_VAR 0 3
17398: PPUSH
17399: LD_VAR 0 5
17403: PPUSH
17404: CALL_OW 325
17408: IFFALSE 17435
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
17410: LD_ADDR_VAR 0 2
17414: PUSH
17415: LD_INT 5
17417: PUSH
17418: LD_INT 8
17420: PUSH
17421: LD_INT 9
17423: PUSH
17424: EMPTY
17425: LIST
17426: LIST
17427: LIST
17428: PUSH
17429: LD_VAR 0 4
17433: ARRAY
17434: ST_TO_ADDR
// end ;
17435: LD_VAR 0 2
17439: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
17444: PPUSH
// if not mines then
17445: LD_VAR 0 2
17449: NOT
17450: IFFALSE 17454
// exit ;
17452: GO 17598
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
17454: LD_ADDR_VAR 0 5
17458: PUSH
17459: LD_INT 81
17461: PUSH
17462: LD_VAR 0 1
17466: PUSH
17467: EMPTY
17468: LIST
17469: LIST
17470: PUSH
17471: LD_INT 3
17473: PUSH
17474: LD_INT 21
17476: PUSH
17477: LD_INT 3
17479: PUSH
17480: EMPTY
17481: LIST
17482: LIST
17483: PUSH
17484: EMPTY
17485: LIST
17486: LIST
17487: PUSH
17488: EMPTY
17489: LIST
17490: LIST
17491: PPUSH
17492: CALL_OW 69
17496: ST_TO_ADDR
// for i in mines do
17497: LD_ADDR_VAR 0 4
17501: PUSH
17502: LD_VAR 0 2
17506: PUSH
17507: FOR_IN
17508: IFFALSE 17596
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
17510: LD_VAR 0 4
17514: PUSH
17515: LD_INT 1
17517: ARRAY
17518: PPUSH
17519: LD_VAR 0 4
17523: PUSH
17524: LD_INT 2
17526: ARRAY
17527: PPUSH
17528: CALL_OW 458
17532: NOT
17533: IFFALSE 17537
// continue ;
17535: GO 17507
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
17537: LD_VAR 0 4
17541: PUSH
17542: LD_INT 1
17544: ARRAY
17545: PPUSH
17546: LD_VAR 0 4
17550: PUSH
17551: LD_INT 2
17553: ARRAY
17554: PPUSH
17555: CALL_OW 428
17559: PUSH
17560: LD_VAR 0 5
17564: IN
17565: IFFALSE 17594
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
17567: LD_VAR 0 4
17571: PUSH
17572: LD_INT 1
17574: ARRAY
17575: PPUSH
17576: LD_VAR 0 4
17580: PUSH
17581: LD_INT 2
17583: ARRAY
17584: PPUSH
17585: LD_VAR 0 1
17589: PPUSH
17590: CALL_OW 456
// end ;
17594: GO 17507
17596: POP
17597: POP
// end ;
17598: LD_VAR 0 3
17602: RET
// export function Count ( array ) ; begin
17603: LD_INT 0
17605: PPUSH
// result := array + 0 ;
17606: LD_ADDR_VAR 0 2
17610: PUSH
17611: LD_VAR 0 1
17615: PUSH
17616: LD_INT 0
17618: PLUS
17619: ST_TO_ADDR
// end ;
17620: LD_VAR 0 2
17624: RET
// export function IsEmpty ( building ) ; begin
17625: LD_INT 0
17627: PPUSH
// if not building then
17628: LD_VAR 0 1
17632: NOT
17633: IFFALSE 17637
// exit ;
17635: GO 17680
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
17637: LD_ADDR_VAR 0 2
17641: PUSH
17642: LD_VAR 0 1
17646: PUSH
17647: LD_INT 22
17649: PUSH
17650: LD_VAR 0 1
17654: PPUSH
17655: CALL_OW 255
17659: PUSH
17660: EMPTY
17661: LIST
17662: LIST
17663: PUSH
17664: LD_INT 58
17666: PUSH
17667: EMPTY
17668: LIST
17669: PUSH
17670: EMPTY
17671: LIST
17672: LIST
17673: PPUSH
17674: CALL_OW 69
17678: IN
17679: ST_TO_ADDR
// end ;
17680: LD_VAR 0 2
17684: RET
// export function IsNotFull ( building ) ; var places ; begin
17685: LD_INT 0
17687: PPUSH
17688: PPUSH
// if not building then
17689: LD_VAR 0 1
17693: NOT
17694: IFFALSE 17698
// exit ;
17696: GO 17726
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
17698: LD_ADDR_VAR 0 2
17702: PUSH
17703: LD_VAR 0 1
17707: PPUSH
17708: LD_INT 3
17710: PUSH
17711: LD_INT 62
17713: PUSH
17714: EMPTY
17715: LIST
17716: PUSH
17717: EMPTY
17718: LIST
17719: LIST
17720: PPUSH
17721: CALL_OW 72
17725: ST_TO_ADDR
// end ;
17726: LD_VAR 0 2
17730: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
17731: LD_INT 0
17733: PPUSH
17734: PPUSH
17735: PPUSH
17736: PPUSH
// tmp := [ ] ;
17737: LD_ADDR_VAR 0 3
17741: PUSH
17742: EMPTY
17743: ST_TO_ADDR
// list := [ ] ;
17744: LD_ADDR_VAR 0 5
17748: PUSH
17749: EMPTY
17750: ST_TO_ADDR
// for i = 16 to 25 do
17751: LD_ADDR_VAR 0 4
17755: PUSH
17756: DOUBLE
17757: LD_INT 16
17759: DEC
17760: ST_TO_ADDR
17761: LD_INT 25
17763: PUSH
17764: FOR_TO
17765: IFFALSE 17838
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
17767: LD_ADDR_VAR 0 3
17771: PUSH
17772: LD_VAR 0 3
17776: PUSH
17777: LD_INT 22
17779: PUSH
17780: LD_VAR 0 1
17784: PPUSH
17785: CALL_OW 255
17789: PUSH
17790: EMPTY
17791: LIST
17792: LIST
17793: PUSH
17794: LD_INT 91
17796: PUSH
17797: LD_VAR 0 1
17801: PUSH
17802: LD_INT 6
17804: PUSH
17805: EMPTY
17806: LIST
17807: LIST
17808: LIST
17809: PUSH
17810: LD_INT 30
17812: PUSH
17813: LD_VAR 0 4
17817: PUSH
17818: EMPTY
17819: LIST
17820: LIST
17821: PUSH
17822: EMPTY
17823: LIST
17824: LIST
17825: LIST
17826: PUSH
17827: EMPTY
17828: LIST
17829: PPUSH
17830: CALL_OW 69
17834: ADD
17835: ST_TO_ADDR
17836: GO 17764
17838: POP
17839: POP
// for i = 1 to tmp do
17840: LD_ADDR_VAR 0 4
17844: PUSH
17845: DOUBLE
17846: LD_INT 1
17848: DEC
17849: ST_TO_ADDR
17850: LD_VAR 0 3
17854: PUSH
17855: FOR_TO
17856: IFFALSE 17944
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
17858: LD_ADDR_VAR 0 5
17862: PUSH
17863: LD_VAR 0 5
17867: PUSH
17868: LD_VAR 0 3
17872: PUSH
17873: LD_VAR 0 4
17877: ARRAY
17878: PPUSH
17879: CALL_OW 266
17883: PUSH
17884: LD_VAR 0 3
17888: PUSH
17889: LD_VAR 0 4
17893: ARRAY
17894: PPUSH
17895: CALL_OW 250
17899: PUSH
17900: LD_VAR 0 3
17904: PUSH
17905: LD_VAR 0 4
17909: ARRAY
17910: PPUSH
17911: CALL_OW 251
17915: PUSH
17916: LD_VAR 0 3
17920: PUSH
17921: LD_VAR 0 4
17925: ARRAY
17926: PPUSH
17927: CALL_OW 254
17931: PUSH
17932: EMPTY
17933: LIST
17934: LIST
17935: LIST
17936: LIST
17937: PUSH
17938: EMPTY
17939: LIST
17940: ADD
17941: ST_TO_ADDR
17942: GO 17855
17944: POP
17945: POP
// result := list ;
17946: LD_ADDR_VAR 0 2
17950: PUSH
17951: LD_VAR 0 5
17955: ST_TO_ADDR
// end ;
17956: LD_VAR 0 2
17960: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
17961: LD_INT 0
17963: PPUSH
17964: PPUSH
17965: PPUSH
17966: PPUSH
17967: PPUSH
17968: PPUSH
17969: PPUSH
// if not factory then
17970: LD_VAR 0 1
17974: NOT
17975: IFFALSE 17979
// exit ;
17977: GO 18572
// if control = control_apeman then
17979: LD_VAR 0 4
17983: PUSH
17984: LD_INT 5
17986: EQUAL
17987: IFFALSE 18096
// begin tmp := UnitsInside ( factory ) ;
17989: LD_ADDR_VAR 0 8
17993: PUSH
17994: LD_VAR 0 1
17998: PPUSH
17999: CALL_OW 313
18003: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18004: LD_VAR 0 8
18008: PPUSH
18009: LD_INT 25
18011: PUSH
18012: LD_INT 12
18014: PUSH
18015: EMPTY
18016: LIST
18017: LIST
18018: PPUSH
18019: CALL_OW 72
18023: NOT
18024: IFFALSE 18034
// control := control_manual ;
18026: LD_ADDR_VAR 0 4
18030: PUSH
18031: LD_INT 1
18033: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18034: LD_ADDR_VAR 0 8
18038: PUSH
18039: LD_VAR 0 1
18043: PPUSH
18044: CALL 17731 0 1
18048: ST_TO_ADDR
// if tmp then
18049: LD_VAR 0 8
18053: IFFALSE 18096
// begin for i in tmp do
18055: LD_ADDR_VAR 0 7
18059: PUSH
18060: LD_VAR 0 8
18064: PUSH
18065: FOR_IN
18066: IFFALSE 18094
// if i [ 1 ] = b_ext_radio then
18068: LD_VAR 0 7
18072: PUSH
18073: LD_INT 1
18075: ARRAY
18076: PUSH
18077: LD_INT 22
18079: EQUAL
18080: IFFALSE 18092
// begin control := control_remote ;
18082: LD_ADDR_VAR 0 4
18086: PUSH
18087: LD_INT 2
18089: ST_TO_ADDR
// break ;
18090: GO 18094
// end ;
18092: GO 18065
18094: POP
18095: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18096: LD_VAR 0 1
18100: PPUSH
18101: LD_VAR 0 2
18105: PPUSH
18106: LD_VAR 0 3
18110: PPUSH
18111: LD_VAR 0 4
18115: PPUSH
18116: LD_VAR 0 5
18120: PPUSH
18121: CALL_OW 448
18125: IFFALSE 18160
// begin result := [ chassis , engine , control , weapon ] ;
18127: LD_ADDR_VAR 0 6
18131: PUSH
18132: LD_VAR 0 2
18136: PUSH
18137: LD_VAR 0 3
18141: PUSH
18142: LD_VAR 0 4
18146: PUSH
18147: LD_VAR 0 5
18151: PUSH
18152: EMPTY
18153: LIST
18154: LIST
18155: LIST
18156: LIST
18157: ST_TO_ADDR
// exit ;
18158: GO 18572
// end ; _chassis := AvailableChassisList ( factory ) ;
18160: LD_ADDR_VAR 0 9
18164: PUSH
18165: LD_VAR 0 1
18169: PPUSH
18170: CALL_OW 475
18174: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
18175: LD_ADDR_VAR 0 11
18179: PUSH
18180: LD_VAR 0 1
18184: PPUSH
18185: CALL_OW 476
18189: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
18190: LD_ADDR_VAR 0 12
18194: PUSH
18195: LD_VAR 0 1
18199: PPUSH
18200: CALL_OW 477
18204: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
18205: LD_ADDR_VAR 0 10
18209: PUSH
18210: LD_VAR 0 1
18214: PPUSH
18215: CALL_OW 478
18219: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
18220: LD_VAR 0 9
18224: NOT
18225: PUSH
18226: LD_VAR 0 11
18230: NOT
18231: OR
18232: PUSH
18233: LD_VAR 0 12
18237: NOT
18238: OR
18239: PUSH
18240: LD_VAR 0 10
18244: NOT
18245: OR
18246: IFFALSE 18281
// begin result := [ chassis , engine , control , weapon ] ;
18248: LD_ADDR_VAR 0 6
18252: PUSH
18253: LD_VAR 0 2
18257: PUSH
18258: LD_VAR 0 3
18262: PUSH
18263: LD_VAR 0 4
18267: PUSH
18268: LD_VAR 0 5
18272: PUSH
18273: EMPTY
18274: LIST
18275: LIST
18276: LIST
18277: LIST
18278: ST_TO_ADDR
// exit ;
18279: GO 18572
// end ; if not chassis in _chassis then
18281: LD_VAR 0 2
18285: PUSH
18286: LD_VAR 0 9
18290: IN
18291: NOT
18292: IFFALSE 18318
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
18294: LD_ADDR_VAR 0 2
18298: PUSH
18299: LD_VAR 0 9
18303: PUSH
18304: LD_INT 1
18306: PPUSH
18307: LD_VAR 0 9
18311: PPUSH
18312: CALL_OW 12
18316: ARRAY
18317: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
18318: LD_VAR 0 2
18322: PPUSH
18323: LD_VAR 0 3
18327: PPUSH
18328: CALL 18577 0 2
18332: NOT
18333: IFFALSE 18392
// repeat engine := _engine [ 1 ] ;
18335: LD_ADDR_VAR 0 3
18339: PUSH
18340: LD_VAR 0 11
18344: PUSH
18345: LD_INT 1
18347: ARRAY
18348: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
18349: LD_ADDR_VAR 0 11
18353: PUSH
18354: LD_VAR 0 11
18358: PPUSH
18359: LD_INT 1
18361: PPUSH
18362: CALL_OW 3
18366: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
18367: LD_VAR 0 2
18371: PPUSH
18372: LD_VAR 0 3
18376: PPUSH
18377: CALL 18577 0 2
18381: PUSH
18382: LD_VAR 0 11
18386: PUSH
18387: EMPTY
18388: EQUAL
18389: OR
18390: IFFALSE 18335
// if not control in _control then
18392: LD_VAR 0 4
18396: PUSH
18397: LD_VAR 0 12
18401: IN
18402: NOT
18403: IFFALSE 18429
// control := _control [ rand ( 1 , _control ) ] ;
18405: LD_ADDR_VAR 0 4
18409: PUSH
18410: LD_VAR 0 12
18414: PUSH
18415: LD_INT 1
18417: PPUSH
18418: LD_VAR 0 12
18422: PPUSH
18423: CALL_OW 12
18427: ARRAY
18428: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
18429: LD_VAR 0 2
18433: PPUSH
18434: LD_VAR 0 5
18438: PPUSH
18439: CALL 18797 0 2
18443: NOT
18444: IFFALSE 18503
// repeat weapon := _weapon [ 1 ] ;
18446: LD_ADDR_VAR 0 5
18450: PUSH
18451: LD_VAR 0 10
18455: PUSH
18456: LD_INT 1
18458: ARRAY
18459: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
18460: LD_ADDR_VAR 0 10
18464: PUSH
18465: LD_VAR 0 10
18469: PPUSH
18470: LD_INT 1
18472: PPUSH
18473: CALL_OW 3
18477: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
18478: LD_VAR 0 2
18482: PPUSH
18483: LD_VAR 0 5
18487: PPUSH
18488: CALL 18797 0 2
18492: PUSH
18493: LD_VAR 0 10
18497: PUSH
18498: EMPTY
18499: EQUAL
18500: OR
18501: IFFALSE 18446
// result := [ ] ;
18503: LD_ADDR_VAR 0 6
18507: PUSH
18508: EMPTY
18509: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18510: LD_VAR 0 1
18514: PPUSH
18515: LD_VAR 0 2
18519: PPUSH
18520: LD_VAR 0 3
18524: PPUSH
18525: LD_VAR 0 4
18529: PPUSH
18530: LD_VAR 0 5
18534: PPUSH
18535: CALL_OW 448
18539: IFFALSE 18572
// result := [ chassis , engine , control , weapon ] ;
18541: LD_ADDR_VAR 0 6
18545: PUSH
18546: LD_VAR 0 2
18550: PUSH
18551: LD_VAR 0 3
18555: PUSH
18556: LD_VAR 0 4
18560: PUSH
18561: LD_VAR 0 5
18565: PUSH
18566: EMPTY
18567: LIST
18568: LIST
18569: LIST
18570: LIST
18571: ST_TO_ADDR
// end ;
18572: LD_VAR 0 6
18576: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
18577: LD_INT 0
18579: PPUSH
// if not chassis or not engine then
18580: LD_VAR 0 1
18584: NOT
18585: PUSH
18586: LD_VAR 0 2
18590: NOT
18591: OR
18592: IFFALSE 18596
// exit ;
18594: GO 18792
// case engine of engine_solar :
18596: LD_VAR 0 2
18600: PUSH
18601: LD_INT 2
18603: DOUBLE
18604: EQUAL
18605: IFTRUE 18609
18607: GO 18647
18609: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
18610: LD_ADDR_VAR 0 3
18614: PUSH
18615: LD_INT 11
18617: PUSH
18618: LD_INT 12
18620: PUSH
18621: LD_INT 13
18623: PUSH
18624: LD_INT 14
18626: PUSH
18627: LD_INT 1
18629: PUSH
18630: LD_INT 2
18632: PUSH
18633: LD_INT 3
18635: PUSH
18636: EMPTY
18637: LIST
18638: LIST
18639: LIST
18640: LIST
18641: LIST
18642: LIST
18643: LIST
18644: ST_TO_ADDR
18645: GO 18776
18647: LD_INT 1
18649: DOUBLE
18650: EQUAL
18651: IFTRUE 18655
18653: GO 18717
18655: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
18656: LD_ADDR_VAR 0 3
18660: PUSH
18661: LD_INT 11
18663: PUSH
18664: LD_INT 12
18666: PUSH
18667: LD_INT 13
18669: PUSH
18670: LD_INT 14
18672: PUSH
18673: LD_INT 1
18675: PUSH
18676: LD_INT 2
18678: PUSH
18679: LD_INT 3
18681: PUSH
18682: LD_INT 4
18684: PUSH
18685: LD_INT 5
18687: PUSH
18688: LD_INT 21
18690: PUSH
18691: LD_INT 23
18693: PUSH
18694: LD_INT 22
18696: PUSH
18697: LD_INT 24
18699: PUSH
18700: EMPTY
18701: LIST
18702: LIST
18703: LIST
18704: LIST
18705: LIST
18706: LIST
18707: LIST
18708: LIST
18709: LIST
18710: LIST
18711: LIST
18712: LIST
18713: LIST
18714: ST_TO_ADDR
18715: GO 18776
18717: LD_INT 3
18719: DOUBLE
18720: EQUAL
18721: IFTRUE 18725
18723: GO 18775
18725: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18726: LD_ADDR_VAR 0 3
18730: PUSH
18731: LD_INT 13
18733: PUSH
18734: LD_INT 14
18736: PUSH
18737: LD_INT 2
18739: PUSH
18740: LD_INT 3
18742: PUSH
18743: LD_INT 4
18745: PUSH
18746: LD_INT 5
18748: PUSH
18749: LD_INT 21
18751: PUSH
18752: LD_INT 22
18754: PUSH
18755: LD_INT 23
18757: PUSH
18758: LD_INT 24
18760: PUSH
18761: EMPTY
18762: LIST
18763: LIST
18764: LIST
18765: LIST
18766: LIST
18767: LIST
18768: LIST
18769: LIST
18770: LIST
18771: LIST
18772: ST_TO_ADDR
18773: GO 18776
18775: POP
// result := ( chassis in result ) ;
18776: LD_ADDR_VAR 0 3
18780: PUSH
18781: LD_VAR 0 1
18785: PUSH
18786: LD_VAR 0 3
18790: IN
18791: ST_TO_ADDR
// end ;
18792: LD_VAR 0 3
18796: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
18797: LD_INT 0
18799: PPUSH
// if not chassis or not weapon then
18800: LD_VAR 0 1
18804: NOT
18805: PUSH
18806: LD_VAR 0 2
18810: NOT
18811: OR
18812: IFFALSE 18816
// exit ;
18814: GO 19876
// case weapon of us_machine_gun :
18816: LD_VAR 0 2
18820: PUSH
18821: LD_INT 2
18823: DOUBLE
18824: EQUAL
18825: IFTRUE 18829
18827: GO 18859
18829: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
18830: LD_ADDR_VAR 0 3
18834: PUSH
18835: LD_INT 1
18837: PUSH
18838: LD_INT 2
18840: PUSH
18841: LD_INT 3
18843: PUSH
18844: LD_INT 4
18846: PUSH
18847: LD_INT 5
18849: PUSH
18850: EMPTY
18851: LIST
18852: LIST
18853: LIST
18854: LIST
18855: LIST
18856: ST_TO_ADDR
18857: GO 19860
18859: LD_INT 3
18861: DOUBLE
18862: EQUAL
18863: IFTRUE 18867
18865: GO 18897
18867: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
18868: LD_ADDR_VAR 0 3
18872: PUSH
18873: LD_INT 1
18875: PUSH
18876: LD_INT 2
18878: PUSH
18879: LD_INT 3
18881: PUSH
18882: LD_INT 4
18884: PUSH
18885: LD_INT 5
18887: PUSH
18888: EMPTY
18889: LIST
18890: LIST
18891: LIST
18892: LIST
18893: LIST
18894: ST_TO_ADDR
18895: GO 19860
18897: LD_INT 11
18899: DOUBLE
18900: EQUAL
18901: IFTRUE 18905
18903: GO 18935
18905: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
18906: LD_ADDR_VAR 0 3
18910: PUSH
18911: LD_INT 1
18913: PUSH
18914: LD_INT 2
18916: PUSH
18917: LD_INT 3
18919: PUSH
18920: LD_INT 4
18922: PUSH
18923: LD_INT 5
18925: PUSH
18926: EMPTY
18927: LIST
18928: LIST
18929: LIST
18930: LIST
18931: LIST
18932: ST_TO_ADDR
18933: GO 19860
18935: LD_INT 4
18937: DOUBLE
18938: EQUAL
18939: IFTRUE 18943
18941: GO 18969
18943: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
18944: LD_ADDR_VAR 0 3
18948: PUSH
18949: LD_INT 2
18951: PUSH
18952: LD_INT 3
18954: PUSH
18955: LD_INT 4
18957: PUSH
18958: LD_INT 5
18960: PUSH
18961: EMPTY
18962: LIST
18963: LIST
18964: LIST
18965: LIST
18966: ST_TO_ADDR
18967: GO 19860
18969: LD_INT 5
18971: DOUBLE
18972: EQUAL
18973: IFTRUE 18977
18975: GO 19003
18977: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
18978: LD_ADDR_VAR 0 3
18982: PUSH
18983: LD_INT 2
18985: PUSH
18986: LD_INT 3
18988: PUSH
18989: LD_INT 4
18991: PUSH
18992: LD_INT 5
18994: PUSH
18995: EMPTY
18996: LIST
18997: LIST
18998: LIST
18999: LIST
19000: ST_TO_ADDR
19001: GO 19860
19003: LD_INT 9
19005: DOUBLE
19006: EQUAL
19007: IFTRUE 19011
19009: GO 19037
19011: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19012: LD_ADDR_VAR 0 3
19016: PUSH
19017: LD_INT 2
19019: PUSH
19020: LD_INT 3
19022: PUSH
19023: LD_INT 4
19025: PUSH
19026: LD_INT 5
19028: PUSH
19029: EMPTY
19030: LIST
19031: LIST
19032: LIST
19033: LIST
19034: ST_TO_ADDR
19035: GO 19860
19037: LD_INT 7
19039: DOUBLE
19040: EQUAL
19041: IFTRUE 19045
19043: GO 19071
19045: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19046: LD_ADDR_VAR 0 3
19050: PUSH
19051: LD_INT 2
19053: PUSH
19054: LD_INT 3
19056: PUSH
19057: LD_INT 4
19059: PUSH
19060: LD_INT 5
19062: PUSH
19063: EMPTY
19064: LIST
19065: LIST
19066: LIST
19067: LIST
19068: ST_TO_ADDR
19069: GO 19860
19071: LD_INT 12
19073: DOUBLE
19074: EQUAL
19075: IFTRUE 19079
19077: GO 19105
19079: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19080: LD_ADDR_VAR 0 3
19084: PUSH
19085: LD_INT 2
19087: PUSH
19088: LD_INT 3
19090: PUSH
19091: LD_INT 4
19093: PUSH
19094: LD_INT 5
19096: PUSH
19097: EMPTY
19098: LIST
19099: LIST
19100: LIST
19101: LIST
19102: ST_TO_ADDR
19103: GO 19860
19105: LD_INT 13
19107: DOUBLE
19108: EQUAL
19109: IFTRUE 19113
19111: GO 19139
19113: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19114: LD_ADDR_VAR 0 3
19118: PUSH
19119: LD_INT 2
19121: PUSH
19122: LD_INT 3
19124: PUSH
19125: LD_INT 4
19127: PUSH
19128: LD_INT 5
19130: PUSH
19131: EMPTY
19132: LIST
19133: LIST
19134: LIST
19135: LIST
19136: ST_TO_ADDR
19137: GO 19860
19139: LD_INT 14
19141: DOUBLE
19142: EQUAL
19143: IFTRUE 19147
19145: GO 19165
19147: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19148: LD_ADDR_VAR 0 3
19152: PUSH
19153: LD_INT 4
19155: PUSH
19156: LD_INT 5
19158: PUSH
19159: EMPTY
19160: LIST
19161: LIST
19162: ST_TO_ADDR
19163: GO 19860
19165: LD_INT 6
19167: DOUBLE
19168: EQUAL
19169: IFTRUE 19173
19171: GO 19191
19173: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
19174: LD_ADDR_VAR 0 3
19178: PUSH
19179: LD_INT 4
19181: PUSH
19182: LD_INT 5
19184: PUSH
19185: EMPTY
19186: LIST
19187: LIST
19188: ST_TO_ADDR
19189: GO 19860
19191: LD_INT 10
19193: DOUBLE
19194: EQUAL
19195: IFTRUE 19199
19197: GO 19217
19199: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
19200: LD_ADDR_VAR 0 3
19204: PUSH
19205: LD_INT 4
19207: PUSH
19208: LD_INT 5
19210: PUSH
19211: EMPTY
19212: LIST
19213: LIST
19214: ST_TO_ADDR
19215: GO 19860
19217: LD_INT 22
19219: DOUBLE
19220: EQUAL
19221: IFTRUE 19225
19223: GO 19251
19225: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
19226: LD_ADDR_VAR 0 3
19230: PUSH
19231: LD_INT 11
19233: PUSH
19234: LD_INT 12
19236: PUSH
19237: LD_INT 13
19239: PUSH
19240: LD_INT 14
19242: PUSH
19243: EMPTY
19244: LIST
19245: LIST
19246: LIST
19247: LIST
19248: ST_TO_ADDR
19249: GO 19860
19251: LD_INT 23
19253: DOUBLE
19254: EQUAL
19255: IFTRUE 19259
19257: GO 19285
19259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
19260: LD_ADDR_VAR 0 3
19264: PUSH
19265: LD_INT 11
19267: PUSH
19268: LD_INT 12
19270: PUSH
19271: LD_INT 13
19273: PUSH
19274: LD_INT 14
19276: PUSH
19277: EMPTY
19278: LIST
19279: LIST
19280: LIST
19281: LIST
19282: ST_TO_ADDR
19283: GO 19860
19285: LD_INT 24
19287: DOUBLE
19288: EQUAL
19289: IFTRUE 19293
19291: GO 19319
19293: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
19294: LD_ADDR_VAR 0 3
19298: PUSH
19299: LD_INT 11
19301: PUSH
19302: LD_INT 12
19304: PUSH
19305: LD_INT 13
19307: PUSH
19308: LD_INT 14
19310: PUSH
19311: EMPTY
19312: LIST
19313: LIST
19314: LIST
19315: LIST
19316: ST_TO_ADDR
19317: GO 19860
19319: LD_INT 30
19321: DOUBLE
19322: EQUAL
19323: IFTRUE 19327
19325: GO 19353
19327: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
19328: LD_ADDR_VAR 0 3
19332: PUSH
19333: LD_INT 11
19335: PUSH
19336: LD_INT 12
19338: PUSH
19339: LD_INT 13
19341: PUSH
19342: LD_INT 14
19344: PUSH
19345: EMPTY
19346: LIST
19347: LIST
19348: LIST
19349: LIST
19350: ST_TO_ADDR
19351: GO 19860
19353: LD_INT 25
19355: DOUBLE
19356: EQUAL
19357: IFTRUE 19361
19359: GO 19379
19361: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
19362: LD_ADDR_VAR 0 3
19366: PUSH
19367: LD_INT 13
19369: PUSH
19370: LD_INT 14
19372: PUSH
19373: EMPTY
19374: LIST
19375: LIST
19376: ST_TO_ADDR
19377: GO 19860
19379: LD_INT 27
19381: DOUBLE
19382: EQUAL
19383: IFTRUE 19387
19385: GO 19405
19387: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
19388: LD_ADDR_VAR 0 3
19392: PUSH
19393: LD_INT 13
19395: PUSH
19396: LD_INT 14
19398: PUSH
19399: EMPTY
19400: LIST
19401: LIST
19402: ST_TO_ADDR
19403: GO 19860
19405: LD_INT 92
19407: DOUBLE
19408: EQUAL
19409: IFTRUE 19413
19411: GO 19439
19413: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
19414: LD_ADDR_VAR 0 3
19418: PUSH
19419: LD_INT 11
19421: PUSH
19422: LD_INT 12
19424: PUSH
19425: LD_INT 13
19427: PUSH
19428: LD_INT 14
19430: PUSH
19431: EMPTY
19432: LIST
19433: LIST
19434: LIST
19435: LIST
19436: ST_TO_ADDR
19437: GO 19860
19439: LD_INT 28
19441: DOUBLE
19442: EQUAL
19443: IFTRUE 19447
19445: GO 19465
19447: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
19448: LD_ADDR_VAR 0 3
19452: PUSH
19453: LD_INT 13
19455: PUSH
19456: LD_INT 14
19458: PUSH
19459: EMPTY
19460: LIST
19461: LIST
19462: ST_TO_ADDR
19463: GO 19860
19465: LD_INT 29
19467: DOUBLE
19468: EQUAL
19469: IFTRUE 19473
19471: GO 19491
19473: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
19474: LD_ADDR_VAR 0 3
19478: PUSH
19479: LD_INT 13
19481: PUSH
19482: LD_INT 14
19484: PUSH
19485: EMPTY
19486: LIST
19487: LIST
19488: ST_TO_ADDR
19489: GO 19860
19491: LD_INT 31
19493: DOUBLE
19494: EQUAL
19495: IFTRUE 19499
19497: GO 19517
19499: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
19500: LD_ADDR_VAR 0 3
19504: PUSH
19505: LD_INT 13
19507: PUSH
19508: LD_INT 14
19510: PUSH
19511: EMPTY
19512: LIST
19513: LIST
19514: ST_TO_ADDR
19515: GO 19860
19517: LD_INT 26
19519: DOUBLE
19520: EQUAL
19521: IFTRUE 19525
19523: GO 19543
19525: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
19526: LD_ADDR_VAR 0 3
19530: PUSH
19531: LD_INT 13
19533: PUSH
19534: LD_INT 14
19536: PUSH
19537: EMPTY
19538: LIST
19539: LIST
19540: ST_TO_ADDR
19541: GO 19860
19543: LD_INT 42
19545: DOUBLE
19546: EQUAL
19547: IFTRUE 19551
19549: GO 19577
19551: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
19552: LD_ADDR_VAR 0 3
19556: PUSH
19557: LD_INT 21
19559: PUSH
19560: LD_INT 22
19562: PUSH
19563: LD_INT 23
19565: PUSH
19566: LD_INT 24
19568: PUSH
19569: EMPTY
19570: LIST
19571: LIST
19572: LIST
19573: LIST
19574: ST_TO_ADDR
19575: GO 19860
19577: LD_INT 43
19579: DOUBLE
19580: EQUAL
19581: IFTRUE 19585
19583: GO 19611
19585: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
19586: LD_ADDR_VAR 0 3
19590: PUSH
19591: LD_INT 21
19593: PUSH
19594: LD_INT 22
19596: PUSH
19597: LD_INT 23
19599: PUSH
19600: LD_INT 24
19602: PUSH
19603: EMPTY
19604: LIST
19605: LIST
19606: LIST
19607: LIST
19608: ST_TO_ADDR
19609: GO 19860
19611: LD_INT 44
19613: DOUBLE
19614: EQUAL
19615: IFTRUE 19619
19617: GO 19645
19619: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
19620: LD_ADDR_VAR 0 3
19624: PUSH
19625: LD_INT 21
19627: PUSH
19628: LD_INT 22
19630: PUSH
19631: LD_INT 23
19633: PUSH
19634: LD_INT 24
19636: PUSH
19637: EMPTY
19638: LIST
19639: LIST
19640: LIST
19641: LIST
19642: ST_TO_ADDR
19643: GO 19860
19645: LD_INT 45
19647: DOUBLE
19648: EQUAL
19649: IFTRUE 19653
19651: GO 19679
19653: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
19654: LD_ADDR_VAR 0 3
19658: PUSH
19659: LD_INT 21
19661: PUSH
19662: LD_INT 22
19664: PUSH
19665: LD_INT 23
19667: PUSH
19668: LD_INT 24
19670: PUSH
19671: EMPTY
19672: LIST
19673: LIST
19674: LIST
19675: LIST
19676: ST_TO_ADDR
19677: GO 19860
19679: LD_INT 49
19681: DOUBLE
19682: EQUAL
19683: IFTRUE 19687
19685: GO 19713
19687: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
19688: LD_ADDR_VAR 0 3
19692: PUSH
19693: LD_INT 21
19695: PUSH
19696: LD_INT 22
19698: PUSH
19699: LD_INT 23
19701: PUSH
19702: LD_INT 24
19704: PUSH
19705: EMPTY
19706: LIST
19707: LIST
19708: LIST
19709: LIST
19710: ST_TO_ADDR
19711: GO 19860
19713: LD_INT 51
19715: DOUBLE
19716: EQUAL
19717: IFTRUE 19721
19719: GO 19747
19721: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
19722: LD_ADDR_VAR 0 3
19726: PUSH
19727: LD_INT 21
19729: PUSH
19730: LD_INT 22
19732: PUSH
19733: LD_INT 23
19735: PUSH
19736: LD_INT 24
19738: PUSH
19739: EMPTY
19740: LIST
19741: LIST
19742: LIST
19743: LIST
19744: ST_TO_ADDR
19745: GO 19860
19747: LD_INT 52
19749: DOUBLE
19750: EQUAL
19751: IFTRUE 19755
19753: GO 19781
19755: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
19756: LD_ADDR_VAR 0 3
19760: PUSH
19761: LD_INT 21
19763: PUSH
19764: LD_INT 22
19766: PUSH
19767: LD_INT 23
19769: PUSH
19770: LD_INT 24
19772: PUSH
19773: EMPTY
19774: LIST
19775: LIST
19776: LIST
19777: LIST
19778: ST_TO_ADDR
19779: GO 19860
19781: LD_INT 53
19783: DOUBLE
19784: EQUAL
19785: IFTRUE 19789
19787: GO 19807
19789: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
19790: LD_ADDR_VAR 0 3
19794: PUSH
19795: LD_INT 23
19797: PUSH
19798: LD_INT 24
19800: PUSH
19801: EMPTY
19802: LIST
19803: LIST
19804: ST_TO_ADDR
19805: GO 19860
19807: LD_INT 46
19809: DOUBLE
19810: EQUAL
19811: IFTRUE 19815
19813: GO 19833
19815: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
19816: LD_ADDR_VAR 0 3
19820: PUSH
19821: LD_INT 23
19823: PUSH
19824: LD_INT 24
19826: PUSH
19827: EMPTY
19828: LIST
19829: LIST
19830: ST_TO_ADDR
19831: GO 19860
19833: LD_INT 47
19835: DOUBLE
19836: EQUAL
19837: IFTRUE 19841
19839: GO 19859
19841: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19842: LD_ADDR_VAR 0 3
19846: PUSH
19847: LD_INT 23
19849: PUSH
19850: LD_INT 24
19852: PUSH
19853: EMPTY
19854: LIST
19855: LIST
19856: ST_TO_ADDR
19857: GO 19860
19859: POP
// result := ( chassis in result ) ;
19860: LD_ADDR_VAR 0 3
19864: PUSH
19865: LD_VAR 0 1
19869: PUSH
19870: LD_VAR 0 3
19874: IN
19875: ST_TO_ADDR
// end ;
19876: LD_VAR 0 3
19880: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
19881: LD_INT 0
19883: PPUSH
19884: PPUSH
19885: PPUSH
19886: PPUSH
19887: PPUSH
19888: PPUSH
19889: PPUSH
// result := array ;
19890: LD_ADDR_VAR 0 5
19894: PUSH
19895: LD_VAR 0 1
19899: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
19900: LD_VAR 0 1
19904: NOT
19905: PUSH
19906: LD_VAR 0 2
19910: NOT
19911: OR
19912: PUSH
19913: LD_VAR 0 3
19917: NOT
19918: OR
19919: PUSH
19920: LD_VAR 0 2
19924: PUSH
19925: LD_VAR 0 1
19929: GREATER
19930: OR
19931: PUSH
19932: LD_VAR 0 3
19936: PUSH
19937: LD_VAR 0 1
19941: GREATER
19942: OR
19943: IFFALSE 19947
// exit ;
19945: GO 20243
// if direction then
19947: LD_VAR 0 4
19951: IFFALSE 20015
// begin d := 1 ;
19953: LD_ADDR_VAR 0 9
19957: PUSH
19958: LD_INT 1
19960: ST_TO_ADDR
// if i_from > i_to then
19961: LD_VAR 0 2
19965: PUSH
19966: LD_VAR 0 3
19970: GREATER
19971: IFFALSE 19997
// length := ( array - i_from ) + i_to else
19973: LD_ADDR_VAR 0 11
19977: PUSH
19978: LD_VAR 0 1
19982: PUSH
19983: LD_VAR 0 2
19987: MINUS
19988: PUSH
19989: LD_VAR 0 3
19993: PLUS
19994: ST_TO_ADDR
19995: GO 20013
// length := i_to - i_from ;
19997: LD_ADDR_VAR 0 11
20001: PUSH
20002: LD_VAR 0 3
20006: PUSH
20007: LD_VAR 0 2
20011: MINUS
20012: ST_TO_ADDR
// end else
20013: GO 20076
// begin d := - 1 ;
20015: LD_ADDR_VAR 0 9
20019: PUSH
20020: LD_INT 1
20022: NEG
20023: ST_TO_ADDR
// if i_from > i_to then
20024: LD_VAR 0 2
20028: PUSH
20029: LD_VAR 0 3
20033: GREATER
20034: IFFALSE 20054
// length := i_from - i_to else
20036: LD_ADDR_VAR 0 11
20040: PUSH
20041: LD_VAR 0 2
20045: PUSH
20046: LD_VAR 0 3
20050: MINUS
20051: ST_TO_ADDR
20052: GO 20076
// length := ( array - i_to ) + i_from ;
20054: LD_ADDR_VAR 0 11
20058: PUSH
20059: LD_VAR 0 1
20063: PUSH
20064: LD_VAR 0 3
20068: MINUS
20069: PUSH
20070: LD_VAR 0 2
20074: PLUS
20075: ST_TO_ADDR
// end ; if not length then
20076: LD_VAR 0 11
20080: NOT
20081: IFFALSE 20085
// exit ;
20083: GO 20243
// tmp := array ;
20085: LD_ADDR_VAR 0 10
20089: PUSH
20090: LD_VAR 0 1
20094: ST_TO_ADDR
// for i = 1 to length do
20095: LD_ADDR_VAR 0 6
20099: PUSH
20100: DOUBLE
20101: LD_INT 1
20103: DEC
20104: ST_TO_ADDR
20105: LD_VAR 0 11
20109: PUSH
20110: FOR_TO
20111: IFFALSE 20231
// begin for j = 1 to array do
20113: LD_ADDR_VAR 0 7
20117: PUSH
20118: DOUBLE
20119: LD_INT 1
20121: DEC
20122: ST_TO_ADDR
20123: LD_VAR 0 1
20127: PUSH
20128: FOR_TO
20129: IFFALSE 20217
// begin k := j + d ;
20131: LD_ADDR_VAR 0 8
20135: PUSH
20136: LD_VAR 0 7
20140: PUSH
20141: LD_VAR 0 9
20145: PLUS
20146: ST_TO_ADDR
// if k > array then
20147: LD_VAR 0 8
20151: PUSH
20152: LD_VAR 0 1
20156: GREATER
20157: IFFALSE 20167
// k := 1 ;
20159: LD_ADDR_VAR 0 8
20163: PUSH
20164: LD_INT 1
20166: ST_TO_ADDR
// if not k then
20167: LD_VAR 0 8
20171: NOT
20172: IFFALSE 20184
// k := array ;
20174: LD_ADDR_VAR 0 8
20178: PUSH
20179: LD_VAR 0 1
20183: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20184: LD_ADDR_VAR 0 10
20188: PUSH
20189: LD_VAR 0 10
20193: PPUSH
20194: LD_VAR 0 8
20198: PPUSH
20199: LD_VAR 0 1
20203: PUSH
20204: LD_VAR 0 7
20208: ARRAY
20209: PPUSH
20210: CALL_OW 1
20214: ST_TO_ADDR
// end ;
20215: GO 20128
20217: POP
20218: POP
// array := tmp ;
20219: LD_ADDR_VAR 0 1
20223: PUSH
20224: LD_VAR 0 10
20228: ST_TO_ADDR
// end ;
20229: GO 20110
20231: POP
20232: POP
// result := array ;
20233: LD_ADDR_VAR 0 5
20237: PUSH
20238: LD_VAR 0 1
20242: ST_TO_ADDR
// end ;
20243: LD_VAR 0 5
20247: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
20248: LD_INT 0
20250: PPUSH
20251: PPUSH
// result := 0 ;
20252: LD_ADDR_VAR 0 3
20256: PUSH
20257: LD_INT 0
20259: ST_TO_ADDR
// if not array or not value in array then
20260: LD_VAR 0 1
20264: NOT
20265: PUSH
20266: LD_VAR 0 2
20270: PUSH
20271: LD_VAR 0 1
20275: IN
20276: NOT
20277: OR
20278: IFFALSE 20282
// exit ;
20280: GO 20336
// for i = 1 to array do
20282: LD_ADDR_VAR 0 4
20286: PUSH
20287: DOUBLE
20288: LD_INT 1
20290: DEC
20291: ST_TO_ADDR
20292: LD_VAR 0 1
20296: PUSH
20297: FOR_TO
20298: IFFALSE 20334
// if value = array [ i ] then
20300: LD_VAR 0 2
20304: PUSH
20305: LD_VAR 0 1
20309: PUSH
20310: LD_VAR 0 4
20314: ARRAY
20315: EQUAL
20316: IFFALSE 20332
// begin result := i ;
20318: LD_ADDR_VAR 0 3
20322: PUSH
20323: LD_VAR 0 4
20327: ST_TO_ADDR
// exit ;
20328: POP
20329: POP
20330: GO 20336
// end ;
20332: GO 20297
20334: POP
20335: POP
// end ;
20336: LD_VAR 0 3
20340: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
20341: LD_INT 0
20343: PPUSH
// vc_chassis := chassis ;
20344: LD_ADDR_OWVAR 37
20348: PUSH
20349: LD_VAR 0 1
20353: ST_TO_ADDR
// vc_engine := engine ;
20354: LD_ADDR_OWVAR 39
20358: PUSH
20359: LD_VAR 0 2
20363: ST_TO_ADDR
// vc_control := control ;
20364: LD_ADDR_OWVAR 38
20368: PUSH
20369: LD_VAR 0 3
20373: ST_TO_ADDR
// vc_weapon := weapon ;
20374: LD_ADDR_OWVAR 40
20378: PUSH
20379: LD_VAR 0 4
20383: ST_TO_ADDR
// vc_fuel_battery := fuel ;
20384: LD_ADDR_OWVAR 41
20388: PUSH
20389: LD_VAR 0 5
20393: ST_TO_ADDR
// end ;
20394: LD_VAR 0 6
20398: RET
// export function WantPlant ( unit ) ; var task ; begin
20399: LD_INT 0
20401: PPUSH
20402: PPUSH
// result := false ;
20403: LD_ADDR_VAR 0 2
20407: PUSH
20408: LD_INT 0
20410: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
20411: LD_ADDR_VAR 0 3
20415: PUSH
20416: LD_VAR 0 1
20420: PPUSH
20421: CALL_OW 437
20425: ST_TO_ADDR
// if task then
20426: LD_VAR 0 3
20430: IFFALSE 20458
// if task [ 1 ] [ 1 ] = p then
20432: LD_VAR 0 3
20436: PUSH
20437: LD_INT 1
20439: ARRAY
20440: PUSH
20441: LD_INT 1
20443: ARRAY
20444: PUSH
20445: LD_STRING p
20447: EQUAL
20448: IFFALSE 20458
// result := true ;
20450: LD_ADDR_VAR 0 2
20454: PUSH
20455: LD_INT 1
20457: ST_TO_ADDR
// end ;
20458: LD_VAR 0 2
20462: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
20463: LD_INT 0
20465: PPUSH
20466: PPUSH
20467: PPUSH
20468: PPUSH
// if pos < 1 then
20469: LD_VAR 0 2
20473: PUSH
20474: LD_INT 1
20476: LESS
20477: IFFALSE 20481
// exit ;
20479: GO 20784
// if pos = 1 then
20481: LD_VAR 0 2
20485: PUSH
20486: LD_INT 1
20488: EQUAL
20489: IFFALSE 20522
// result := Replace ( arr , pos [ 1 ] , value ) else
20491: LD_ADDR_VAR 0 4
20495: PUSH
20496: LD_VAR 0 1
20500: PPUSH
20501: LD_VAR 0 2
20505: PUSH
20506: LD_INT 1
20508: ARRAY
20509: PPUSH
20510: LD_VAR 0 3
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
20520: GO 20784
// begin tmp := arr ;
20522: LD_ADDR_VAR 0 6
20526: PUSH
20527: LD_VAR 0 1
20531: ST_TO_ADDR
// s_arr := [ tmp ] ;
20532: LD_ADDR_VAR 0 7
20536: PUSH
20537: LD_VAR 0 6
20541: PUSH
20542: EMPTY
20543: LIST
20544: ST_TO_ADDR
// for i = 1 to pos - 1 do
20545: LD_ADDR_VAR 0 5
20549: PUSH
20550: DOUBLE
20551: LD_INT 1
20553: DEC
20554: ST_TO_ADDR
20555: LD_VAR 0 2
20559: PUSH
20560: LD_INT 1
20562: MINUS
20563: PUSH
20564: FOR_TO
20565: IFFALSE 20610
// begin tmp := tmp [ pos [ i ] ] ;
20567: LD_ADDR_VAR 0 6
20571: PUSH
20572: LD_VAR 0 6
20576: PUSH
20577: LD_VAR 0 2
20581: PUSH
20582: LD_VAR 0 5
20586: ARRAY
20587: ARRAY
20588: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
20589: LD_ADDR_VAR 0 7
20593: PUSH
20594: LD_VAR 0 7
20598: PUSH
20599: LD_VAR 0 6
20603: PUSH
20604: EMPTY
20605: LIST
20606: ADD
20607: ST_TO_ADDR
// end ;
20608: GO 20564
20610: POP
20611: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
20612: LD_ADDR_VAR 0 6
20616: PUSH
20617: LD_VAR 0 6
20621: PPUSH
20622: LD_VAR 0 2
20626: PUSH
20627: LD_VAR 0 2
20631: ARRAY
20632: PPUSH
20633: LD_VAR 0 3
20637: PPUSH
20638: CALL_OW 1
20642: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
20643: LD_ADDR_VAR 0 7
20647: PUSH
20648: LD_VAR 0 7
20652: PPUSH
20653: LD_VAR 0 7
20657: PPUSH
20658: LD_VAR 0 6
20662: PPUSH
20663: CALL_OW 1
20667: ST_TO_ADDR
// for i = s_arr downto 2 do
20668: LD_ADDR_VAR 0 5
20672: PUSH
20673: DOUBLE
20674: LD_VAR 0 7
20678: INC
20679: ST_TO_ADDR
20680: LD_INT 2
20682: PUSH
20683: FOR_DOWNTO
20684: IFFALSE 20768
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
20686: LD_ADDR_VAR 0 6
20690: PUSH
20691: LD_VAR 0 7
20695: PUSH
20696: LD_VAR 0 5
20700: PUSH
20701: LD_INT 1
20703: MINUS
20704: ARRAY
20705: PPUSH
20706: LD_VAR 0 2
20710: PUSH
20711: LD_VAR 0 5
20715: PUSH
20716: LD_INT 1
20718: MINUS
20719: ARRAY
20720: PPUSH
20721: LD_VAR 0 7
20725: PUSH
20726: LD_VAR 0 5
20730: ARRAY
20731: PPUSH
20732: CALL_OW 1
20736: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
20737: LD_ADDR_VAR 0 7
20741: PUSH
20742: LD_VAR 0 7
20746: PPUSH
20747: LD_VAR 0 5
20751: PUSH
20752: LD_INT 1
20754: MINUS
20755: PPUSH
20756: LD_VAR 0 6
20760: PPUSH
20761: CALL_OW 1
20765: ST_TO_ADDR
// end ;
20766: GO 20683
20768: POP
20769: POP
// result := s_arr [ 1 ] ;
20770: LD_ADDR_VAR 0 4
20774: PUSH
20775: LD_VAR 0 7
20779: PUSH
20780: LD_INT 1
20782: ARRAY
20783: ST_TO_ADDR
// end ; end ;
20784: LD_VAR 0 4
20788: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
20789: LD_INT 0
20791: PPUSH
20792: PPUSH
// if not list then
20793: LD_VAR 0 1
20797: NOT
20798: IFFALSE 20802
// exit ;
20800: GO 20893
// i := list [ pos1 ] ;
20802: LD_ADDR_VAR 0 5
20806: PUSH
20807: LD_VAR 0 1
20811: PUSH
20812: LD_VAR 0 2
20816: ARRAY
20817: ST_TO_ADDR
// if not i then
20818: LD_VAR 0 5
20822: NOT
20823: IFFALSE 20827
// exit ;
20825: GO 20893
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
20827: LD_ADDR_VAR 0 1
20831: PUSH
20832: LD_VAR 0 1
20836: PPUSH
20837: LD_VAR 0 2
20841: PPUSH
20842: LD_VAR 0 1
20846: PUSH
20847: LD_VAR 0 3
20851: ARRAY
20852: PPUSH
20853: CALL_OW 1
20857: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
20858: LD_ADDR_VAR 0 1
20862: PUSH
20863: LD_VAR 0 1
20867: PPUSH
20868: LD_VAR 0 3
20872: PPUSH
20873: LD_VAR 0 5
20877: PPUSH
20878: CALL_OW 1
20882: ST_TO_ADDR
// result := list ;
20883: LD_ADDR_VAR 0 4
20887: PUSH
20888: LD_VAR 0 1
20892: ST_TO_ADDR
// end ;
20893: LD_VAR 0 4
20897: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
20898: LD_INT 0
20900: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
20901: LD_ADDR_VAR 0 5
20905: PUSH
20906: LD_VAR 0 1
20910: PPUSH
20911: CALL_OW 250
20915: PPUSH
20916: LD_VAR 0 1
20920: PPUSH
20921: CALL_OW 251
20925: PPUSH
20926: LD_VAR 0 2
20930: PPUSH
20931: LD_VAR 0 3
20935: PPUSH
20936: LD_VAR 0 4
20940: PPUSH
20941: CALL 20951 0 5
20945: ST_TO_ADDR
// end ;
20946: LD_VAR 0 5
20950: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
20951: LD_INT 0
20953: PPUSH
20954: PPUSH
20955: PPUSH
20956: PPUSH
// if not list then
20957: LD_VAR 0 3
20961: NOT
20962: IFFALSE 20966
// exit ;
20964: GO 21354
// result := [ ] ;
20966: LD_ADDR_VAR 0 6
20970: PUSH
20971: EMPTY
20972: ST_TO_ADDR
// for i in list do
20973: LD_ADDR_VAR 0 7
20977: PUSH
20978: LD_VAR 0 3
20982: PUSH
20983: FOR_IN
20984: IFFALSE 21186
// begin tmp := GetDistUnitXY ( i , x , y ) ;
20986: LD_ADDR_VAR 0 9
20990: PUSH
20991: LD_VAR 0 7
20995: PPUSH
20996: LD_VAR 0 1
21000: PPUSH
21001: LD_VAR 0 2
21005: PPUSH
21006: CALL_OW 297
21010: ST_TO_ADDR
// if not result then
21011: LD_VAR 0 6
21015: NOT
21016: IFFALSE 21042
// result := [ [ i , tmp ] ] else
21018: LD_ADDR_VAR 0 6
21022: PUSH
21023: LD_VAR 0 7
21027: PUSH
21028: LD_VAR 0 9
21032: PUSH
21033: EMPTY
21034: LIST
21035: LIST
21036: PUSH
21037: EMPTY
21038: LIST
21039: ST_TO_ADDR
21040: GO 21184
// begin if result [ result ] [ 2 ] < tmp then
21042: LD_VAR 0 6
21046: PUSH
21047: LD_VAR 0 6
21051: ARRAY
21052: PUSH
21053: LD_INT 2
21055: ARRAY
21056: PUSH
21057: LD_VAR 0 9
21061: LESS
21062: IFFALSE 21104
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21064: LD_ADDR_VAR 0 6
21068: PUSH
21069: LD_VAR 0 6
21073: PPUSH
21074: LD_VAR 0 6
21078: PUSH
21079: LD_INT 1
21081: PLUS
21082: PPUSH
21083: LD_VAR 0 7
21087: PUSH
21088: LD_VAR 0 9
21092: PUSH
21093: EMPTY
21094: LIST
21095: LIST
21096: PPUSH
21097: CALL_OW 2
21101: ST_TO_ADDR
21102: GO 21184
// for j = 1 to result do
21104: LD_ADDR_VAR 0 8
21108: PUSH
21109: DOUBLE
21110: LD_INT 1
21112: DEC
21113: ST_TO_ADDR
21114: LD_VAR 0 6
21118: PUSH
21119: FOR_TO
21120: IFFALSE 21182
// begin if tmp < result [ j ] [ 2 ] then
21122: LD_VAR 0 9
21126: PUSH
21127: LD_VAR 0 6
21131: PUSH
21132: LD_VAR 0 8
21136: ARRAY
21137: PUSH
21138: LD_INT 2
21140: ARRAY
21141: LESS
21142: IFFALSE 21180
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21144: LD_ADDR_VAR 0 6
21148: PUSH
21149: LD_VAR 0 6
21153: PPUSH
21154: LD_VAR 0 8
21158: PPUSH
21159: LD_VAR 0 7
21163: PUSH
21164: LD_VAR 0 9
21168: PUSH
21169: EMPTY
21170: LIST
21171: LIST
21172: PPUSH
21173: CALL_OW 2
21177: ST_TO_ADDR
// break ;
21178: GO 21182
// end ; end ;
21180: GO 21119
21182: POP
21183: POP
// end ; end ;
21184: GO 20983
21186: POP
21187: POP
// if result and not asc then
21188: LD_VAR 0 6
21192: PUSH
21193: LD_VAR 0 4
21197: NOT
21198: AND
21199: IFFALSE 21274
// begin tmp := result ;
21201: LD_ADDR_VAR 0 9
21205: PUSH
21206: LD_VAR 0 6
21210: ST_TO_ADDR
// for i = tmp downto 1 do
21211: LD_ADDR_VAR 0 7
21215: PUSH
21216: DOUBLE
21217: LD_VAR 0 9
21221: INC
21222: ST_TO_ADDR
21223: LD_INT 1
21225: PUSH
21226: FOR_DOWNTO
21227: IFFALSE 21272
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
21229: LD_ADDR_VAR 0 6
21233: PUSH
21234: LD_VAR 0 6
21238: PPUSH
21239: LD_VAR 0 9
21243: PUSH
21244: LD_VAR 0 7
21248: MINUS
21249: PUSH
21250: LD_INT 1
21252: PLUS
21253: PPUSH
21254: LD_VAR 0 9
21258: PUSH
21259: LD_VAR 0 7
21263: ARRAY
21264: PPUSH
21265: CALL_OW 1
21269: ST_TO_ADDR
21270: GO 21226
21272: POP
21273: POP
// end ; tmp := [ ] ;
21274: LD_ADDR_VAR 0 9
21278: PUSH
21279: EMPTY
21280: ST_TO_ADDR
// if mode then
21281: LD_VAR 0 5
21285: IFFALSE 21354
// begin for i = 1 to result do
21287: LD_ADDR_VAR 0 7
21291: PUSH
21292: DOUBLE
21293: LD_INT 1
21295: DEC
21296: ST_TO_ADDR
21297: LD_VAR 0 6
21301: PUSH
21302: FOR_TO
21303: IFFALSE 21342
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
21305: LD_ADDR_VAR 0 9
21309: PUSH
21310: LD_VAR 0 9
21314: PPUSH
21315: LD_VAR 0 7
21319: PPUSH
21320: LD_VAR 0 6
21324: PUSH
21325: LD_VAR 0 7
21329: ARRAY
21330: PUSH
21331: LD_INT 1
21333: ARRAY
21334: PPUSH
21335: CALL_OW 1
21339: ST_TO_ADDR
21340: GO 21302
21342: POP
21343: POP
// result := tmp ;
21344: LD_ADDR_VAR 0 6
21348: PUSH
21349: LD_VAR 0 9
21353: ST_TO_ADDR
// end ; end ;
21354: LD_VAR 0 6
21358: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
21359: LD_INT 0
21361: PPUSH
21362: PPUSH
21363: PPUSH
21364: PPUSH
21365: PPUSH
21366: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
21367: LD_ADDR_VAR 0 5
21371: PUSH
21372: LD_INT 0
21374: PUSH
21375: LD_INT 0
21377: PUSH
21378: LD_INT 0
21380: PUSH
21381: EMPTY
21382: PUSH
21383: EMPTY
21384: LIST
21385: LIST
21386: LIST
21387: LIST
21388: ST_TO_ADDR
// if not x or not y then
21389: LD_VAR 0 2
21393: NOT
21394: PUSH
21395: LD_VAR 0 3
21399: NOT
21400: OR
21401: IFFALSE 21405
// exit ;
21403: GO 23055
// if not range then
21405: LD_VAR 0 4
21409: NOT
21410: IFFALSE 21420
// range := 10 ;
21412: LD_ADDR_VAR 0 4
21416: PUSH
21417: LD_INT 10
21419: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
21420: LD_ADDR_VAR 0 8
21424: PUSH
21425: LD_INT 81
21427: PUSH
21428: LD_VAR 0 1
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: PUSH
21437: LD_INT 92
21439: PUSH
21440: LD_VAR 0 2
21444: PUSH
21445: LD_VAR 0 3
21449: PUSH
21450: LD_VAR 0 4
21454: PUSH
21455: EMPTY
21456: LIST
21457: LIST
21458: LIST
21459: LIST
21460: PUSH
21461: LD_INT 3
21463: PUSH
21464: LD_INT 21
21466: PUSH
21467: LD_INT 3
21469: PUSH
21470: EMPTY
21471: LIST
21472: LIST
21473: PUSH
21474: EMPTY
21475: LIST
21476: LIST
21477: PUSH
21478: EMPTY
21479: LIST
21480: LIST
21481: LIST
21482: PPUSH
21483: CALL_OW 69
21487: ST_TO_ADDR
// if not tmp then
21488: LD_VAR 0 8
21492: NOT
21493: IFFALSE 21497
// exit ;
21495: GO 23055
// for i in tmp do
21497: LD_ADDR_VAR 0 6
21501: PUSH
21502: LD_VAR 0 8
21506: PUSH
21507: FOR_IN
21508: IFFALSE 23030
// begin points := [ 0 , 0 , 0 ] ;
21510: LD_ADDR_VAR 0 9
21514: PUSH
21515: LD_INT 0
21517: PUSH
21518: LD_INT 0
21520: PUSH
21521: LD_INT 0
21523: PUSH
21524: EMPTY
21525: LIST
21526: LIST
21527: LIST
21528: ST_TO_ADDR
// bpoints := 1 ;
21529: LD_ADDR_VAR 0 10
21533: PUSH
21534: LD_INT 1
21536: ST_TO_ADDR
// case GetType ( i ) of unit_human :
21537: LD_VAR 0 6
21541: PPUSH
21542: CALL_OW 247
21546: PUSH
21547: LD_INT 1
21549: DOUBLE
21550: EQUAL
21551: IFTRUE 21555
21553: GO 22133
21555: POP
// begin if GetClass ( i ) = 1 then
21556: LD_VAR 0 6
21560: PPUSH
21561: CALL_OW 257
21565: PUSH
21566: LD_INT 1
21568: EQUAL
21569: IFFALSE 21590
// points := [ 10 , 5 , 3 ] ;
21571: LD_ADDR_VAR 0 9
21575: PUSH
21576: LD_INT 10
21578: PUSH
21579: LD_INT 5
21581: PUSH
21582: LD_INT 3
21584: PUSH
21585: EMPTY
21586: LIST
21587: LIST
21588: LIST
21589: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
21590: LD_VAR 0 6
21594: PPUSH
21595: CALL_OW 257
21599: PUSH
21600: LD_INT 2
21602: PUSH
21603: LD_INT 3
21605: PUSH
21606: LD_INT 4
21608: PUSH
21609: EMPTY
21610: LIST
21611: LIST
21612: LIST
21613: IN
21614: IFFALSE 21635
// points := [ 3 , 2 , 1 ] ;
21616: LD_ADDR_VAR 0 9
21620: PUSH
21621: LD_INT 3
21623: PUSH
21624: LD_INT 2
21626: PUSH
21627: LD_INT 1
21629: PUSH
21630: EMPTY
21631: LIST
21632: LIST
21633: LIST
21634: ST_TO_ADDR
// if GetClass ( i ) = 5 then
21635: LD_VAR 0 6
21639: PPUSH
21640: CALL_OW 257
21644: PUSH
21645: LD_INT 5
21647: EQUAL
21648: IFFALSE 21669
// points := [ 130 , 5 , 2 ] ;
21650: LD_ADDR_VAR 0 9
21654: PUSH
21655: LD_INT 130
21657: PUSH
21658: LD_INT 5
21660: PUSH
21661: LD_INT 2
21663: PUSH
21664: EMPTY
21665: LIST
21666: LIST
21667: LIST
21668: ST_TO_ADDR
// if GetClass ( i ) = 8 then
21669: LD_VAR 0 6
21673: PPUSH
21674: CALL_OW 257
21678: PUSH
21679: LD_INT 8
21681: EQUAL
21682: IFFALSE 21703
// points := [ 35 , 35 , 30 ] ;
21684: LD_ADDR_VAR 0 9
21688: PUSH
21689: LD_INT 35
21691: PUSH
21692: LD_INT 35
21694: PUSH
21695: LD_INT 30
21697: PUSH
21698: EMPTY
21699: LIST
21700: LIST
21701: LIST
21702: ST_TO_ADDR
// if GetClass ( i ) = 9 then
21703: LD_VAR 0 6
21707: PPUSH
21708: CALL_OW 257
21712: PUSH
21713: LD_INT 9
21715: EQUAL
21716: IFFALSE 21737
// points := [ 20 , 55 , 40 ] ;
21718: LD_ADDR_VAR 0 9
21722: PUSH
21723: LD_INT 20
21725: PUSH
21726: LD_INT 55
21728: PUSH
21729: LD_INT 40
21731: PUSH
21732: EMPTY
21733: LIST
21734: LIST
21735: LIST
21736: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
21737: LD_VAR 0 6
21741: PPUSH
21742: CALL_OW 257
21746: PUSH
21747: LD_INT 12
21749: PUSH
21750: LD_INT 16
21752: PUSH
21753: EMPTY
21754: LIST
21755: LIST
21756: IN
21757: IFFALSE 21778
// points := [ 5 , 3 , 2 ] ;
21759: LD_ADDR_VAR 0 9
21763: PUSH
21764: LD_INT 5
21766: PUSH
21767: LD_INT 3
21769: PUSH
21770: LD_INT 2
21772: PUSH
21773: EMPTY
21774: LIST
21775: LIST
21776: LIST
21777: ST_TO_ADDR
// if GetClass ( i ) = 17 then
21778: LD_VAR 0 6
21782: PPUSH
21783: CALL_OW 257
21787: PUSH
21788: LD_INT 17
21790: EQUAL
21791: IFFALSE 21812
// points := [ 100 , 50 , 75 ] ;
21793: LD_ADDR_VAR 0 9
21797: PUSH
21798: LD_INT 100
21800: PUSH
21801: LD_INT 50
21803: PUSH
21804: LD_INT 75
21806: PUSH
21807: EMPTY
21808: LIST
21809: LIST
21810: LIST
21811: ST_TO_ADDR
// if GetClass ( i ) = 15 then
21812: LD_VAR 0 6
21816: PPUSH
21817: CALL_OW 257
21821: PUSH
21822: LD_INT 15
21824: EQUAL
21825: IFFALSE 21846
// points := [ 10 , 5 , 3 ] ;
21827: LD_ADDR_VAR 0 9
21831: PUSH
21832: LD_INT 10
21834: PUSH
21835: LD_INT 5
21837: PUSH
21838: LD_INT 3
21840: PUSH
21841: EMPTY
21842: LIST
21843: LIST
21844: LIST
21845: ST_TO_ADDR
// if GetClass ( i ) = 14 then
21846: LD_VAR 0 6
21850: PPUSH
21851: CALL_OW 257
21855: PUSH
21856: LD_INT 14
21858: EQUAL
21859: IFFALSE 21880
// points := [ 10 , 0 , 0 ] ;
21861: LD_ADDR_VAR 0 9
21865: PUSH
21866: LD_INT 10
21868: PUSH
21869: LD_INT 0
21871: PUSH
21872: LD_INT 0
21874: PUSH
21875: EMPTY
21876: LIST
21877: LIST
21878: LIST
21879: ST_TO_ADDR
// if GetClass ( i ) = 11 then
21880: LD_VAR 0 6
21884: PPUSH
21885: CALL_OW 257
21889: PUSH
21890: LD_INT 11
21892: EQUAL
21893: IFFALSE 21914
// points := [ 30 , 10 , 5 ] ;
21895: LD_ADDR_VAR 0 9
21899: PUSH
21900: LD_INT 30
21902: PUSH
21903: LD_INT 10
21905: PUSH
21906: LD_INT 5
21908: PUSH
21909: EMPTY
21910: LIST
21911: LIST
21912: LIST
21913: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
21914: LD_VAR 0 1
21918: PPUSH
21919: LD_INT 5
21921: PPUSH
21922: CALL_OW 321
21926: PUSH
21927: LD_INT 2
21929: EQUAL
21930: IFFALSE 21947
// bpoints := bpoints * 1.8 ;
21932: LD_ADDR_VAR 0 10
21936: PUSH
21937: LD_VAR 0 10
21941: PUSH
21942: LD_REAL  1.80000000000000E+0000
21945: MUL
21946: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
21947: LD_VAR 0 6
21951: PPUSH
21952: CALL_OW 257
21956: PUSH
21957: LD_INT 1
21959: PUSH
21960: LD_INT 2
21962: PUSH
21963: LD_INT 3
21965: PUSH
21966: LD_INT 4
21968: PUSH
21969: EMPTY
21970: LIST
21971: LIST
21972: LIST
21973: LIST
21974: IN
21975: PUSH
21976: LD_VAR 0 1
21980: PPUSH
21981: LD_INT 51
21983: PPUSH
21984: CALL_OW 321
21988: PUSH
21989: LD_INT 2
21991: EQUAL
21992: AND
21993: IFFALSE 22010
// bpoints := bpoints * 1.2 ;
21995: LD_ADDR_VAR 0 10
21999: PUSH
22000: LD_VAR 0 10
22004: PUSH
22005: LD_REAL  1.20000000000000E+0000
22008: MUL
22009: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22010: LD_VAR 0 6
22014: PPUSH
22015: CALL_OW 257
22019: PUSH
22020: LD_INT 5
22022: PUSH
22023: LD_INT 7
22025: PUSH
22026: LD_INT 9
22028: PUSH
22029: EMPTY
22030: LIST
22031: LIST
22032: LIST
22033: IN
22034: PUSH
22035: LD_VAR 0 1
22039: PPUSH
22040: LD_INT 52
22042: PPUSH
22043: CALL_OW 321
22047: PUSH
22048: LD_INT 2
22050: EQUAL
22051: AND
22052: IFFALSE 22069
// bpoints := bpoints * 1.5 ;
22054: LD_ADDR_VAR 0 10
22058: PUSH
22059: LD_VAR 0 10
22063: PUSH
22064: LD_REAL  1.50000000000000E+0000
22067: MUL
22068: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22069: LD_VAR 0 1
22073: PPUSH
22074: LD_INT 66
22076: PPUSH
22077: CALL_OW 321
22081: PUSH
22082: LD_INT 2
22084: EQUAL
22085: IFFALSE 22102
// bpoints := bpoints * 1.1 ;
22087: LD_ADDR_VAR 0 10
22091: PUSH
22092: LD_VAR 0 10
22096: PUSH
22097: LD_REAL  1.10000000000000E+0000
22100: MUL
22101: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22102: LD_ADDR_VAR 0 10
22106: PUSH
22107: LD_VAR 0 10
22111: PUSH
22112: LD_VAR 0 6
22116: PPUSH
22117: LD_INT 1
22119: PPUSH
22120: CALL_OW 259
22124: PUSH
22125: LD_REAL  1.15000000000000E+0000
22128: MUL
22129: MUL
22130: ST_TO_ADDR
// end ; unit_vehicle :
22131: GO 22959
22133: LD_INT 2
22135: DOUBLE
22136: EQUAL
22137: IFTRUE 22141
22139: GO 22947
22141: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22142: LD_VAR 0 6
22146: PPUSH
22147: CALL_OW 264
22151: PUSH
22152: LD_INT 2
22154: PUSH
22155: LD_INT 42
22157: PUSH
22158: LD_INT 24
22160: PUSH
22161: EMPTY
22162: LIST
22163: LIST
22164: LIST
22165: IN
22166: IFFALSE 22187
// points := [ 25 , 5 , 3 ] ;
22168: LD_ADDR_VAR 0 9
22172: PUSH
22173: LD_INT 25
22175: PUSH
22176: LD_INT 5
22178: PUSH
22179: LD_INT 3
22181: PUSH
22182: EMPTY
22183: LIST
22184: LIST
22185: LIST
22186: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
22187: LD_VAR 0 6
22191: PPUSH
22192: CALL_OW 264
22196: PUSH
22197: LD_INT 4
22199: PUSH
22200: LD_INT 43
22202: PUSH
22203: LD_INT 25
22205: PUSH
22206: EMPTY
22207: LIST
22208: LIST
22209: LIST
22210: IN
22211: IFFALSE 22232
// points := [ 40 , 15 , 5 ] ;
22213: LD_ADDR_VAR 0 9
22217: PUSH
22218: LD_INT 40
22220: PUSH
22221: LD_INT 15
22223: PUSH
22224: LD_INT 5
22226: PUSH
22227: EMPTY
22228: LIST
22229: LIST
22230: LIST
22231: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
22232: LD_VAR 0 6
22236: PPUSH
22237: CALL_OW 264
22241: PUSH
22242: LD_INT 3
22244: PUSH
22245: LD_INT 23
22247: PUSH
22248: EMPTY
22249: LIST
22250: LIST
22251: IN
22252: IFFALSE 22273
// points := [ 7 , 25 , 8 ] ;
22254: LD_ADDR_VAR 0 9
22258: PUSH
22259: LD_INT 7
22261: PUSH
22262: LD_INT 25
22264: PUSH
22265: LD_INT 8
22267: PUSH
22268: EMPTY
22269: LIST
22270: LIST
22271: LIST
22272: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
22273: LD_VAR 0 6
22277: PPUSH
22278: CALL_OW 264
22282: PUSH
22283: LD_INT 5
22285: PUSH
22286: LD_INT 27
22288: PUSH
22289: LD_INT 44
22291: PUSH
22292: EMPTY
22293: LIST
22294: LIST
22295: LIST
22296: IN
22297: IFFALSE 22318
// points := [ 14 , 50 , 16 ] ;
22299: LD_ADDR_VAR 0 9
22303: PUSH
22304: LD_INT 14
22306: PUSH
22307: LD_INT 50
22309: PUSH
22310: LD_INT 16
22312: PUSH
22313: EMPTY
22314: LIST
22315: LIST
22316: LIST
22317: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
22318: LD_VAR 0 6
22322: PPUSH
22323: CALL_OW 264
22327: PUSH
22328: LD_INT 6
22330: PUSH
22331: LD_INT 46
22333: PUSH
22334: EMPTY
22335: LIST
22336: LIST
22337: IN
22338: IFFALSE 22359
// points := [ 32 , 120 , 70 ] ;
22340: LD_ADDR_VAR 0 9
22344: PUSH
22345: LD_INT 32
22347: PUSH
22348: LD_INT 120
22350: PUSH
22351: LD_INT 70
22353: PUSH
22354: EMPTY
22355: LIST
22356: LIST
22357: LIST
22358: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
22359: LD_VAR 0 6
22363: PPUSH
22364: CALL_OW 264
22368: PUSH
22369: LD_INT 7
22371: PUSH
22372: LD_INT 28
22374: PUSH
22375: LD_INT 45
22377: PUSH
22378: LD_INT 92
22380: PUSH
22381: EMPTY
22382: LIST
22383: LIST
22384: LIST
22385: LIST
22386: IN
22387: IFFALSE 22408
// points := [ 35 , 20 , 45 ] ;
22389: LD_ADDR_VAR 0 9
22393: PUSH
22394: LD_INT 35
22396: PUSH
22397: LD_INT 20
22399: PUSH
22400: LD_INT 45
22402: PUSH
22403: EMPTY
22404: LIST
22405: LIST
22406: LIST
22407: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
22408: LD_VAR 0 6
22412: PPUSH
22413: CALL_OW 264
22417: PUSH
22418: LD_INT 47
22420: PUSH
22421: EMPTY
22422: LIST
22423: IN
22424: IFFALSE 22445
// points := [ 67 , 45 , 75 ] ;
22426: LD_ADDR_VAR 0 9
22430: PUSH
22431: LD_INT 67
22433: PUSH
22434: LD_INT 45
22436: PUSH
22437: LD_INT 75
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: LIST
22444: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
22445: LD_VAR 0 6
22449: PPUSH
22450: CALL_OW 264
22454: PUSH
22455: LD_INT 26
22457: PUSH
22458: EMPTY
22459: LIST
22460: IN
22461: IFFALSE 22482
// points := [ 120 , 30 , 80 ] ;
22463: LD_ADDR_VAR 0 9
22467: PUSH
22468: LD_INT 120
22470: PUSH
22471: LD_INT 30
22473: PUSH
22474: LD_INT 80
22476: PUSH
22477: EMPTY
22478: LIST
22479: LIST
22480: LIST
22481: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
22482: LD_VAR 0 6
22486: PPUSH
22487: CALL_OW 264
22491: PUSH
22492: LD_INT 22
22494: PUSH
22495: EMPTY
22496: LIST
22497: IN
22498: IFFALSE 22519
// points := [ 40 , 1 , 1 ] ;
22500: LD_ADDR_VAR 0 9
22504: PUSH
22505: LD_INT 40
22507: PUSH
22508: LD_INT 1
22510: PUSH
22511: LD_INT 1
22513: PUSH
22514: EMPTY
22515: LIST
22516: LIST
22517: LIST
22518: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
22519: LD_VAR 0 6
22523: PPUSH
22524: CALL_OW 264
22528: PUSH
22529: LD_INT 29
22531: PUSH
22532: EMPTY
22533: LIST
22534: IN
22535: IFFALSE 22556
// points := [ 70 , 200 , 400 ] ;
22537: LD_ADDR_VAR 0 9
22541: PUSH
22542: LD_INT 70
22544: PUSH
22545: LD_INT 200
22547: PUSH
22548: LD_INT 400
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: LIST
22555: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
22556: LD_VAR 0 6
22560: PPUSH
22561: CALL_OW 264
22565: PUSH
22566: LD_INT 14
22568: PUSH
22569: LD_INT 53
22571: PUSH
22572: EMPTY
22573: LIST
22574: LIST
22575: IN
22576: IFFALSE 22597
// points := [ 40 , 10 , 20 ] ;
22578: LD_ADDR_VAR 0 9
22582: PUSH
22583: LD_INT 40
22585: PUSH
22586: LD_INT 10
22588: PUSH
22589: LD_INT 20
22591: PUSH
22592: EMPTY
22593: LIST
22594: LIST
22595: LIST
22596: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
22597: LD_VAR 0 6
22601: PPUSH
22602: CALL_OW 264
22606: PUSH
22607: LD_INT 9
22609: PUSH
22610: EMPTY
22611: LIST
22612: IN
22613: IFFALSE 22634
// points := [ 5 , 70 , 20 ] ;
22615: LD_ADDR_VAR 0 9
22619: PUSH
22620: LD_INT 5
22622: PUSH
22623: LD_INT 70
22625: PUSH
22626: LD_INT 20
22628: PUSH
22629: EMPTY
22630: LIST
22631: LIST
22632: LIST
22633: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
22634: LD_VAR 0 6
22638: PPUSH
22639: CALL_OW 264
22643: PUSH
22644: LD_INT 10
22646: PUSH
22647: EMPTY
22648: LIST
22649: IN
22650: IFFALSE 22671
// points := [ 35 , 110 , 70 ] ;
22652: LD_ADDR_VAR 0 9
22656: PUSH
22657: LD_INT 35
22659: PUSH
22660: LD_INT 110
22662: PUSH
22663: LD_INT 70
22665: PUSH
22666: EMPTY
22667: LIST
22668: LIST
22669: LIST
22670: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
22671: LD_VAR 0 6
22675: PPUSH
22676: CALL_OW 265
22680: PUSH
22681: LD_INT 25
22683: EQUAL
22684: IFFALSE 22705
// points := [ 80 , 65 , 100 ] ;
22686: LD_ADDR_VAR 0 9
22690: PUSH
22691: LD_INT 80
22693: PUSH
22694: LD_INT 65
22696: PUSH
22697: LD_INT 100
22699: PUSH
22700: EMPTY
22701: LIST
22702: LIST
22703: LIST
22704: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
22705: LD_VAR 0 6
22709: PPUSH
22710: CALL_OW 263
22714: PUSH
22715: LD_INT 1
22717: EQUAL
22718: IFFALSE 22753
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
22720: LD_ADDR_VAR 0 10
22724: PUSH
22725: LD_VAR 0 10
22729: PUSH
22730: LD_VAR 0 6
22734: PPUSH
22735: CALL_OW 311
22739: PPUSH
22740: LD_INT 3
22742: PPUSH
22743: CALL_OW 259
22747: PUSH
22748: LD_INT 4
22750: MUL
22751: MUL
22752: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
22753: LD_VAR 0 6
22757: PPUSH
22758: CALL_OW 263
22762: PUSH
22763: LD_INT 2
22765: EQUAL
22766: IFFALSE 22817
// begin j := IsControledBy ( i ) ;
22768: LD_ADDR_VAR 0 7
22772: PUSH
22773: LD_VAR 0 6
22777: PPUSH
22778: CALL_OW 312
22782: ST_TO_ADDR
// if j then
22783: LD_VAR 0 7
22787: IFFALSE 22817
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
22789: LD_ADDR_VAR 0 10
22793: PUSH
22794: LD_VAR 0 10
22798: PUSH
22799: LD_VAR 0 7
22803: PPUSH
22804: LD_INT 3
22806: PPUSH
22807: CALL_OW 259
22811: PUSH
22812: LD_INT 3
22814: MUL
22815: MUL
22816: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
22817: LD_VAR 0 6
22821: PPUSH
22822: CALL_OW 264
22826: PUSH
22827: LD_INT 5
22829: PUSH
22830: LD_INT 6
22832: PUSH
22833: LD_INT 46
22835: PUSH
22836: LD_INT 44
22838: PUSH
22839: LD_INT 47
22841: PUSH
22842: LD_INT 45
22844: PUSH
22845: LD_INT 28
22847: PUSH
22848: LD_INT 7
22850: PUSH
22851: LD_INT 27
22853: PUSH
22854: LD_INT 29
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: LIST
22861: LIST
22862: LIST
22863: LIST
22864: LIST
22865: LIST
22866: LIST
22867: LIST
22868: IN
22869: PUSH
22870: LD_VAR 0 1
22874: PPUSH
22875: LD_INT 52
22877: PPUSH
22878: CALL_OW 321
22882: PUSH
22883: LD_INT 2
22885: EQUAL
22886: AND
22887: IFFALSE 22904
// bpoints := bpoints * 1.2 ;
22889: LD_ADDR_VAR 0 10
22893: PUSH
22894: LD_VAR 0 10
22898: PUSH
22899: LD_REAL  1.20000000000000E+0000
22902: MUL
22903: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
22904: LD_VAR 0 6
22908: PPUSH
22909: CALL_OW 264
22913: PUSH
22914: LD_INT 6
22916: PUSH
22917: LD_INT 46
22919: PUSH
22920: LD_INT 47
22922: PUSH
22923: EMPTY
22924: LIST
22925: LIST
22926: LIST
22927: IN
22928: IFFALSE 22945
// bpoints := bpoints * 1.2 ;
22930: LD_ADDR_VAR 0 10
22934: PUSH
22935: LD_VAR 0 10
22939: PUSH
22940: LD_REAL  1.20000000000000E+0000
22943: MUL
22944: ST_TO_ADDR
// end ; unit_building :
22945: GO 22959
22947: LD_INT 3
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 22958
22955: POP
// ; end ;
22956: GO 22959
22958: POP
// for j = 1 to 3 do
22959: LD_ADDR_VAR 0 7
22963: PUSH
22964: DOUBLE
22965: LD_INT 1
22967: DEC
22968: ST_TO_ADDR
22969: LD_INT 3
22971: PUSH
22972: FOR_TO
22973: IFFALSE 23026
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
22975: LD_ADDR_VAR 0 5
22979: PUSH
22980: LD_VAR 0 5
22984: PPUSH
22985: LD_VAR 0 7
22989: PPUSH
22990: LD_VAR 0 5
22994: PUSH
22995: LD_VAR 0 7
22999: ARRAY
23000: PUSH
23001: LD_VAR 0 9
23005: PUSH
23006: LD_VAR 0 7
23010: ARRAY
23011: PUSH
23012: LD_VAR 0 10
23016: MUL
23017: PLUS
23018: PPUSH
23019: CALL_OW 1
23023: ST_TO_ADDR
23024: GO 22972
23026: POP
23027: POP
// end ;
23028: GO 21507
23030: POP
23031: POP
// result := Replace ( result , 4 , tmp ) ;
23032: LD_ADDR_VAR 0 5
23036: PUSH
23037: LD_VAR 0 5
23041: PPUSH
23042: LD_INT 4
23044: PPUSH
23045: LD_VAR 0 8
23049: PPUSH
23050: CALL_OW 1
23054: ST_TO_ADDR
// end ;
23055: LD_VAR 0 5
23059: RET
// export function DangerAtRange ( unit , range ) ; begin
23060: LD_INT 0
23062: PPUSH
// if not unit then
23063: LD_VAR 0 1
23067: NOT
23068: IFFALSE 23072
// exit ;
23070: GO 23117
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23072: LD_ADDR_VAR 0 3
23076: PUSH
23077: LD_VAR 0 1
23081: PPUSH
23082: CALL_OW 255
23086: PPUSH
23087: LD_VAR 0 1
23091: PPUSH
23092: CALL_OW 250
23096: PPUSH
23097: LD_VAR 0 1
23101: PPUSH
23102: CALL_OW 251
23106: PPUSH
23107: LD_VAR 0 2
23111: PPUSH
23112: CALL 21359 0 4
23116: ST_TO_ADDR
// end ;
23117: LD_VAR 0 3
23121: RET
// export function DangerInArea ( side , area ) ; begin
23122: LD_INT 0
23124: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23125: LD_ADDR_VAR 0 3
23129: PUSH
23130: LD_VAR 0 2
23134: PPUSH
23135: LD_INT 81
23137: PUSH
23138: LD_VAR 0 1
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PPUSH
23147: CALL_OW 70
23151: ST_TO_ADDR
// end ;
23152: LD_VAR 0 3
23156: RET
// export function IsExtension ( b ) ; begin
23157: LD_INT 0
23159: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23160: LD_ADDR_VAR 0 2
23164: PUSH
23165: LD_VAR 0 1
23169: PUSH
23170: LD_INT 23
23172: PUSH
23173: LD_INT 20
23175: PUSH
23176: LD_INT 22
23178: PUSH
23179: LD_INT 17
23181: PUSH
23182: LD_INT 24
23184: PUSH
23185: LD_INT 21
23187: PUSH
23188: LD_INT 19
23190: PUSH
23191: LD_INT 16
23193: PUSH
23194: LD_INT 25
23196: PUSH
23197: LD_INT 18
23199: PUSH
23200: EMPTY
23201: LIST
23202: LIST
23203: LIST
23204: LIST
23205: LIST
23206: LIST
23207: LIST
23208: LIST
23209: LIST
23210: LIST
23211: IN
23212: ST_TO_ADDR
// end ;
23213: LD_VAR 0 2
23217: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
23218: LD_INT 0
23220: PPUSH
23221: PPUSH
23222: PPUSH
// result := [ ] ;
23223: LD_ADDR_VAR 0 4
23227: PUSH
23228: EMPTY
23229: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
23230: LD_ADDR_VAR 0 5
23234: PUSH
23235: LD_VAR 0 2
23239: PPUSH
23240: LD_INT 21
23242: PUSH
23243: LD_INT 3
23245: PUSH
23246: EMPTY
23247: LIST
23248: LIST
23249: PPUSH
23250: CALL_OW 70
23254: ST_TO_ADDR
// if not tmp then
23255: LD_VAR 0 5
23259: NOT
23260: IFFALSE 23264
// exit ;
23262: GO 23328
// if checkLink then
23264: LD_VAR 0 3
23268: IFFALSE 23318
// begin for i in tmp do
23270: LD_ADDR_VAR 0 6
23274: PUSH
23275: LD_VAR 0 5
23279: PUSH
23280: FOR_IN
23281: IFFALSE 23316
// if GetBase ( i ) <> base then
23283: LD_VAR 0 6
23287: PPUSH
23288: CALL_OW 274
23292: PUSH
23293: LD_VAR 0 1
23297: NONEQUAL
23298: IFFALSE 23314
// ComLinkToBase ( base , i ) ;
23300: LD_VAR 0 1
23304: PPUSH
23305: LD_VAR 0 6
23309: PPUSH
23310: CALL_OW 169
23314: GO 23280
23316: POP
23317: POP
// end ; result := tmp ;
23318: LD_ADDR_VAR 0 4
23322: PUSH
23323: LD_VAR 0 5
23327: ST_TO_ADDR
// end ;
23328: LD_VAR 0 4
23332: RET
// export function ComComplete ( units , b ) ; var i ; begin
23333: LD_INT 0
23335: PPUSH
23336: PPUSH
// if not units then
23337: LD_VAR 0 1
23341: NOT
23342: IFFALSE 23346
// exit ;
23344: GO 23436
// for i in units do
23346: LD_ADDR_VAR 0 4
23350: PUSH
23351: LD_VAR 0 1
23355: PUSH
23356: FOR_IN
23357: IFFALSE 23434
// if BuildingStatus ( b ) = bs_build then
23359: LD_VAR 0 2
23363: PPUSH
23364: CALL_OW 461
23368: PUSH
23369: LD_INT 1
23371: EQUAL
23372: IFFALSE 23432
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
23374: LD_VAR 0 4
23378: PPUSH
23379: LD_STRING h
23381: PUSH
23382: LD_VAR 0 2
23386: PPUSH
23387: CALL_OW 250
23391: PUSH
23392: LD_VAR 0 2
23396: PPUSH
23397: CALL_OW 251
23401: PUSH
23402: LD_VAR 0 2
23406: PUSH
23407: LD_INT 0
23409: PUSH
23410: LD_INT 0
23412: PUSH
23413: LD_INT 0
23415: PUSH
23416: EMPTY
23417: LIST
23418: LIST
23419: LIST
23420: LIST
23421: LIST
23422: LIST
23423: LIST
23424: PUSH
23425: EMPTY
23426: LIST
23427: PPUSH
23428: CALL_OW 446
23432: GO 23356
23434: POP
23435: POP
// end ;
23436: LD_VAR 0 3
23440: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
23441: LD_INT 0
23443: PPUSH
23444: PPUSH
23445: PPUSH
23446: PPUSH
23447: PPUSH
23448: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
23449: LD_VAR 0 1
23453: NOT
23454: PUSH
23455: LD_VAR 0 1
23459: PPUSH
23460: CALL_OW 263
23464: PUSH
23465: LD_INT 2
23467: NONEQUAL
23468: OR
23469: IFFALSE 23473
// exit ;
23471: GO 23789
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
23473: LD_ADDR_VAR 0 6
23477: PUSH
23478: LD_INT 22
23480: PUSH
23481: LD_VAR 0 1
23485: PPUSH
23486: CALL_OW 255
23490: PUSH
23491: EMPTY
23492: LIST
23493: LIST
23494: PUSH
23495: LD_INT 2
23497: PUSH
23498: LD_INT 30
23500: PUSH
23501: LD_INT 36
23503: PUSH
23504: EMPTY
23505: LIST
23506: LIST
23507: PUSH
23508: LD_INT 34
23510: PUSH
23511: LD_INT 31
23513: PUSH
23514: EMPTY
23515: LIST
23516: LIST
23517: PUSH
23518: EMPTY
23519: LIST
23520: LIST
23521: LIST
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: PPUSH
23527: CALL_OW 69
23531: ST_TO_ADDR
// if not tmp then
23532: LD_VAR 0 6
23536: NOT
23537: IFFALSE 23541
// exit ;
23539: GO 23789
// result := [ ] ;
23541: LD_ADDR_VAR 0 2
23545: PUSH
23546: EMPTY
23547: ST_TO_ADDR
// for i in tmp do
23548: LD_ADDR_VAR 0 3
23552: PUSH
23553: LD_VAR 0 6
23557: PUSH
23558: FOR_IN
23559: IFFALSE 23630
// begin t := UnitsInside ( i ) ;
23561: LD_ADDR_VAR 0 4
23565: PUSH
23566: LD_VAR 0 3
23570: PPUSH
23571: CALL_OW 313
23575: ST_TO_ADDR
// if t then
23576: LD_VAR 0 4
23580: IFFALSE 23628
// for j in t do
23582: LD_ADDR_VAR 0 7
23586: PUSH
23587: LD_VAR 0 4
23591: PUSH
23592: FOR_IN
23593: IFFALSE 23626
// result := Replace ( result , result + 1 , j ) ;
23595: LD_ADDR_VAR 0 2
23599: PUSH
23600: LD_VAR 0 2
23604: PPUSH
23605: LD_VAR 0 2
23609: PUSH
23610: LD_INT 1
23612: PLUS
23613: PPUSH
23614: LD_VAR 0 7
23618: PPUSH
23619: CALL_OW 1
23623: ST_TO_ADDR
23624: GO 23592
23626: POP
23627: POP
// end ;
23628: GO 23558
23630: POP
23631: POP
// if not result then
23632: LD_VAR 0 2
23636: NOT
23637: IFFALSE 23641
// exit ;
23639: GO 23789
// mech := result [ 1 ] ;
23641: LD_ADDR_VAR 0 5
23645: PUSH
23646: LD_VAR 0 2
23650: PUSH
23651: LD_INT 1
23653: ARRAY
23654: ST_TO_ADDR
// if result > 1 then
23655: LD_VAR 0 2
23659: PUSH
23660: LD_INT 1
23662: GREATER
23663: IFFALSE 23775
// begin for i = 2 to result do
23665: LD_ADDR_VAR 0 3
23669: PUSH
23670: DOUBLE
23671: LD_INT 2
23673: DEC
23674: ST_TO_ADDR
23675: LD_VAR 0 2
23679: PUSH
23680: FOR_TO
23681: IFFALSE 23773
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
23683: LD_ADDR_VAR 0 4
23687: PUSH
23688: LD_VAR 0 2
23692: PUSH
23693: LD_VAR 0 3
23697: ARRAY
23698: PPUSH
23699: LD_INT 3
23701: PPUSH
23702: CALL_OW 259
23706: PUSH
23707: LD_VAR 0 2
23711: PUSH
23712: LD_VAR 0 3
23716: ARRAY
23717: PPUSH
23718: CALL_OW 432
23722: MINUS
23723: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
23724: LD_VAR 0 4
23728: PUSH
23729: LD_VAR 0 5
23733: PPUSH
23734: LD_INT 3
23736: PPUSH
23737: CALL_OW 259
23741: PUSH
23742: LD_VAR 0 5
23746: PPUSH
23747: CALL_OW 432
23751: MINUS
23752: GREATEREQUAL
23753: IFFALSE 23771
// mech := result [ i ] ;
23755: LD_ADDR_VAR 0 5
23759: PUSH
23760: LD_VAR 0 2
23764: PUSH
23765: LD_VAR 0 3
23769: ARRAY
23770: ST_TO_ADDR
// end ;
23771: GO 23680
23773: POP
23774: POP
// end ; ComLinkTo ( vehicle , mech ) ;
23775: LD_VAR 0 1
23779: PPUSH
23780: LD_VAR 0 5
23784: PPUSH
23785: CALL_OW 135
// end ;
23789: LD_VAR 0 2
23793: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
23794: LD_INT 0
23796: PPUSH
23797: PPUSH
23798: PPUSH
23799: PPUSH
23800: PPUSH
23801: PPUSH
23802: PPUSH
23803: PPUSH
23804: PPUSH
23805: PPUSH
23806: PPUSH
23807: PPUSH
23808: PPUSH
// result := [ ] ;
23809: LD_ADDR_VAR 0 7
23813: PUSH
23814: EMPTY
23815: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
23816: LD_VAR 0 1
23820: PPUSH
23821: CALL_OW 266
23825: PUSH
23826: LD_INT 0
23828: PUSH
23829: LD_INT 1
23831: PUSH
23832: EMPTY
23833: LIST
23834: LIST
23835: IN
23836: NOT
23837: IFFALSE 23841
// exit ;
23839: GO 25475
// if name then
23841: LD_VAR 0 3
23845: IFFALSE 23861
// SetBName ( base_dep , name ) ;
23847: LD_VAR 0 1
23851: PPUSH
23852: LD_VAR 0 3
23856: PPUSH
23857: CALL_OW 500
// base := GetBase ( base_dep ) ;
23861: LD_ADDR_VAR 0 15
23865: PUSH
23866: LD_VAR 0 1
23870: PPUSH
23871: CALL_OW 274
23875: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
23876: LD_ADDR_VAR 0 16
23880: PUSH
23881: LD_VAR 0 1
23885: PPUSH
23886: CALL_OW 255
23890: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
23891: LD_ADDR_VAR 0 17
23895: PUSH
23896: LD_VAR 0 1
23900: PPUSH
23901: CALL_OW 248
23905: ST_TO_ADDR
// if sources then
23906: LD_VAR 0 5
23910: IFFALSE 23957
// for i = 1 to 3 do
23912: LD_ADDR_VAR 0 8
23916: PUSH
23917: DOUBLE
23918: LD_INT 1
23920: DEC
23921: ST_TO_ADDR
23922: LD_INT 3
23924: PUSH
23925: FOR_TO
23926: IFFALSE 23955
// AddResourceType ( base , i , sources [ i ] ) ;
23928: LD_VAR 0 15
23932: PPUSH
23933: LD_VAR 0 8
23937: PPUSH
23938: LD_VAR 0 5
23942: PUSH
23943: LD_VAR 0 8
23947: ARRAY
23948: PPUSH
23949: CALL_OW 276
23953: GO 23925
23955: POP
23956: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
23957: LD_ADDR_VAR 0 18
23961: PUSH
23962: LD_VAR 0 15
23966: PPUSH
23967: LD_VAR 0 2
23971: PPUSH
23972: LD_INT 1
23974: PPUSH
23975: CALL 23218 0 3
23979: ST_TO_ADDR
// InitHc ;
23980: CALL_OW 19
// InitUc ;
23984: CALL_OW 18
// uc_side := side ;
23988: LD_ADDR_OWVAR 20
23992: PUSH
23993: LD_VAR 0 16
23997: ST_TO_ADDR
// uc_nation := nation ;
23998: LD_ADDR_OWVAR 21
24002: PUSH
24003: LD_VAR 0 17
24007: ST_TO_ADDR
// if buildings then
24008: LD_VAR 0 18
24012: IFFALSE 25334
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24014: LD_ADDR_VAR 0 19
24018: PUSH
24019: LD_VAR 0 18
24023: PPUSH
24024: LD_INT 2
24026: PUSH
24027: LD_INT 30
24029: PUSH
24030: LD_INT 29
24032: PUSH
24033: EMPTY
24034: LIST
24035: LIST
24036: PUSH
24037: LD_INT 30
24039: PUSH
24040: LD_INT 30
24042: PUSH
24043: EMPTY
24044: LIST
24045: LIST
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: LIST
24051: PPUSH
24052: CALL_OW 72
24056: ST_TO_ADDR
// if tmp then
24057: LD_VAR 0 19
24061: IFFALSE 24109
// for i in tmp do
24063: LD_ADDR_VAR 0 8
24067: PUSH
24068: LD_VAR 0 19
24072: PUSH
24073: FOR_IN
24074: IFFALSE 24107
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24076: LD_VAR 0 8
24080: PPUSH
24081: CALL_OW 250
24085: PPUSH
24086: LD_VAR 0 8
24090: PPUSH
24091: CALL_OW 251
24095: PPUSH
24096: LD_VAR 0 16
24100: PPUSH
24101: CALL_OW 441
24105: GO 24073
24107: POP
24108: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24109: LD_VAR 0 18
24113: PPUSH
24114: LD_INT 2
24116: PUSH
24117: LD_INT 30
24119: PUSH
24120: LD_INT 32
24122: PUSH
24123: EMPTY
24124: LIST
24125: LIST
24126: PUSH
24127: LD_INT 30
24129: PUSH
24130: LD_INT 33
24132: PUSH
24133: EMPTY
24134: LIST
24135: LIST
24136: PUSH
24137: EMPTY
24138: LIST
24139: LIST
24140: LIST
24141: PPUSH
24142: CALL_OW 72
24146: IFFALSE 24234
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24148: LD_ADDR_VAR 0 8
24152: PUSH
24153: LD_VAR 0 18
24157: PPUSH
24158: LD_INT 2
24160: PUSH
24161: LD_INT 30
24163: PUSH
24164: LD_INT 32
24166: PUSH
24167: EMPTY
24168: LIST
24169: LIST
24170: PUSH
24171: LD_INT 30
24173: PUSH
24174: LD_INT 33
24176: PUSH
24177: EMPTY
24178: LIST
24179: LIST
24180: PUSH
24181: EMPTY
24182: LIST
24183: LIST
24184: LIST
24185: PPUSH
24186: CALL_OW 72
24190: PUSH
24191: FOR_IN
24192: IFFALSE 24232
// begin if not GetBWeapon ( i ) then
24194: LD_VAR 0 8
24198: PPUSH
24199: CALL_OW 269
24203: NOT
24204: IFFALSE 24230
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24206: LD_VAR 0 8
24210: PPUSH
24211: LD_VAR 0 8
24215: PPUSH
24216: LD_VAR 0 2
24220: PPUSH
24221: CALL 25480 0 2
24225: PPUSH
24226: CALL_OW 431
// end ;
24230: GO 24191
24232: POP
24233: POP
// end ; for i = 1 to personel do
24234: LD_ADDR_VAR 0 8
24238: PUSH
24239: DOUBLE
24240: LD_INT 1
24242: DEC
24243: ST_TO_ADDR
24244: LD_VAR 0 6
24248: PUSH
24249: FOR_TO
24250: IFFALSE 25314
// begin if i > 4 then
24252: LD_VAR 0 8
24256: PUSH
24257: LD_INT 4
24259: GREATER
24260: IFFALSE 24264
// break ;
24262: GO 25314
// case i of 1 :
24264: LD_VAR 0 8
24268: PUSH
24269: LD_INT 1
24271: DOUBLE
24272: EQUAL
24273: IFTRUE 24277
24275: GO 24357
24277: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
24278: LD_ADDR_VAR 0 12
24282: PUSH
24283: LD_VAR 0 18
24287: PPUSH
24288: LD_INT 22
24290: PUSH
24291: LD_VAR 0 16
24295: PUSH
24296: EMPTY
24297: LIST
24298: LIST
24299: PUSH
24300: LD_INT 58
24302: PUSH
24303: EMPTY
24304: LIST
24305: PUSH
24306: LD_INT 2
24308: PUSH
24309: LD_INT 30
24311: PUSH
24312: LD_INT 32
24314: PUSH
24315: EMPTY
24316: LIST
24317: LIST
24318: PUSH
24319: LD_INT 30
24321: PUSH
24322: LD_INT 4
24324: PUSH
24325: EMPTY
24326: LIST
24327: LIST
24328: PUSH
24329: LD_INT 30
24331: PUSH
24332: LD_INT 5
24334: PUSH
24335: EMPTY
24336: LIST
24337: LIST
24338: PUSH
24339: EMPTY
24340: LIST
24341: LIST
24342: LIST
24343: LIST
24344: PUSH
24345: EMPTY
24346: LIST
24347: LIST
24348: LIST
24349: PPUSH
24350: CALL_OW 72
24354: ST_TO_ADDR
24355: GO 24579
24357: LD_INT 2
24359: DOUBLE
24360: EQUAL
24361: IFTRUE 24365
24363: GO 24427
24365: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
24366: LD_ADDR_VAR 0 12
24370: PUSH
24371: LD_VAR 0 18
24375: PPUSH
24376: LD_INT 22
24378: PUSH
24379: LD_VAR 0 16
24383: PUSH
24384: EMPTY
24385: LIST
24386: LIST
24387: PUSH
24388: LD_INT 2
24390: PUSH
24391: LD_INT 30
24393: PUSH
24394: LD_INT 0
24396: PUSH
24397: EMPTY
24398: LIST
24399: LIST
24400: PUSH
24401: LD_INT 30
24403: PUSH
24404: LD_INT 1
24406: PUSH
24407: EMPTY
24408: LIST
24409: LIST
24410: PUSH
24411: EMPTY
24412: LIST
24413: LIST
24414: LIST
24415: PUSH
24416: EMPTY
24417: LIST
24418: LIST
24419: PPUSH
24420: CALL_OW 72
24424: ST_TO_ADDR
24425: GO 24579
24427: LD_INT 3
24429: DOUBLE
24430: EQUAL
24431: IFTRUE 24435
24433: GO 24497
24435: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
24436: LD_ADDR_VAR 0 12
24440: PUSH
24441: LD_VAR 0 18
24445: PPUSH
24446: LD_INT 22
24448: PUSH
24449: LD_VAR 0 16
24453: PUSH
24454: EMPTY
24455: LIST
24456: LIST
24457: PUSH
24458: LD_INT 2
24460: PUSH
24461: LD_INT 30
24463: PUSH
24464: LD_INT 2
24466: PUSH
24467: EMPTY
24468: LIST
24469: LIST
24470: PUSH
24471: LD_INT 30
24473: PUSH
24474: LD_INT 3
24476: PUSH
24477: EMPTY
24478: LIST
24479: LIST
24480: PUSH
24481: EMPTY
24482: LIST
24483: LIST
24484: LIST
24485: PUSH
24486: EMPTY
24487: LIST
24488: LIST
24489: PPUSH
24490: CALL_OW 72
24494: ST_TO_ADDR
24495: GO 24579
24497: LD_INT 4
24499: DOUBLE
24500: EQUAL
24501: IFTRUE 24505
24503: GO 24578
24505: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
24506: LD_ADDR_VAR 0 12
24510: PUSH
24511: LD_VAR 0 18
24515: PPUSH
24516: LD_INT 22
24518: PUSH
24519: LD_VAR 0 16
24523: PUSH
24524: EMPTY
24525: LIST
24526: LIST
24527: PUSH
24528: LD_INT 2
24530: PUSH
24531: LD_INT 30
24533: PUSH
24534: LD_INT 6
24536: PUSH
24537: EMPTY
24538: LIST
24539: LIST
24540: PUSH
24541: LD_INT 30
24543: PUSH
24544: LD_INT 7
24546: PUSH
24547: EMPTY
24548: LIST
24549: LIST
24550: PUSH
24551: LD_INT 30
24553: PUSH
24554: LD_INT 8
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: PUSH
24561: EMPTY
24562: LIST
24563: LIST
24564: LIST
24565: LIST
24566: PUSH
24567: EMPTY
24568: LIST
24569: LIST
24570: PPUSH
24571: CALL_OW 72
24575: ST_TO_ADDR
24576: GO 24579
24578: POP
// if i = 1 then
24579: LD_VAR 0 8
24583: PUSH
24584: LD_INT 1
24586: EQUAL
24587: IFFALSE 24698
// begin tmp := [ ] ;
24589: LD_ADDR_VAR 0 19
24593: PUSH
24594: EMPTY
24595: ST_TO_ADDR
// for j in f do
24596: LD_ADDR_VAR 0 9
24600: PUSH
24601: LD_VAR 0 12
24605: PUSH
24606: FOR_IN
24607: IFFALSE 24680
// if GetBType ( j ) = b_bunker then
24609: LD_VAR 0 9
24613: PPUSH
24614: CALL_OW 266
24618: PUSH
24619: LD_INT 32
24621: EQUAL
24622: IFFALSE 24649
// tmp := Insert ( tmp , 1 , j ) else
24624: LD_ADDR_VAR 0 19
24628: PUSH
24629: LD_VAR 0 19
24633: PPUSH
24634: LD_INT 1
24636: PPUSH
24637: LD_VAR 0 9
24641: PPUSH
24642: CALL_OW 2
24646: ST_TO_ADDR
24647: GO 24678
// tmp := Insert ( tmp , tmp + 1 , j ) ;
24649: LD_ADDR_VAR 0 19
24653: PUSH
24654: LD_VAR 0 19
24658: PPUSH
24659: LD_VAR 0 19
24663: PUSH
24664: LD_INT 1
24666: PLUS
24667: PPUSH
24668: LD_VAR 0 9
24672: PPUSH
24673: CALL_OW 2
24677: ST_TO_ADDR
24678: GO 24606
24680: POP
24681: POP
// if tmp then
24682: LD_VAR 0 19
24686: IFFALSE 24698
// f := tmp ;
24688: LD_ADDR_VAR 0 12
24692: PUSH
24693: LD_VAR 0 19
24697: ST_TO_ADDR
// end ; x := personel [ i ] ;
24698: LD_ADDR_VAR 0 13
24702: PUSH
24703: LD_VAR 0 6
24707: PUSH
24708: LD_VAR 0 8
24712: ARRAY
24713: ST_TO_ADDR
// if x = - 1 then
24714: LD_VAR 0 13
24718: PUSH
24719: LD_INT 1
24721: NEG
24722: EQUAL
24723: IFFALSE 24932
// begin for j in f do
24725: LD_ADDR_VAR 0 9
24729: PUSH
24730: LD_VAR 0 12
24734: PUSH
24735: FOR_IN
24736: IFFALSE 24928
// repeat InitHc ;
24738: CALL_OW 19
// if GetBType ( j ) = b_barracks then
24742: LD_VAR 0 9
24746: PPUSH
24747: CALL_OW 266
24751: PUSH
24752: LD_INT 5
24754: EQUAL
24755: IFFALSE 24825
// begin if UnitsInside ( j ) < 3 then
24757: LD_VAR 0 9
24761: PPUSH
24762: CALL_OW 313
24766: PUSH
24767: LD_INT 3
24769: LESS
24770: IFFALSE 24806
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
24772: LD_INT 0
24774: PPUSH
24775: LD_INT 5
24777: PUSH
24778: LD_INT 8
24780: PUSH
24781: LD_INT 9
24783: PUSH
24784: EMPTY
24785: LIST
24786: LIST
24787: LIST
24788: PUSH
24789: LD_VAR 0 17
24793: ARRAY
24794: PPUSH
24795: LD_VAR 0 4
24799: PPUSH
24800: CALL_OW 380
24804: GO 24823
// PrepareHuman ( false , i , skill ) ;
24806: LD_INT 0
24808: PPUSH
24809: LD_VAR 0 8
24813: PPUSH
24814: LD_VAR 0 4
24818: PPUSH
24819: CALL_OW 380
// end else
24823: GO 24842
// PrepareHuman ( false , i , skill ) ;
24825: LD_INT 0
24827: PPUSH
24828: LD_VAR 0 8
24832: PPUSH
24833: LD_VAR 0 4
24837: PPUSH
24838: CALL_OW 380
// un := CreateHuman ;
24842: LD_ADDR_VAR 0 14
24846: PUSH
24847: CALL_OW 44
24851: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24852: LD_ADDR_VAR 0 7
24856: PUSH
24857: LD_VAR 0 7
24861: PPUSH
24862: LD_INT 1
24864: PPUSH
24865: LD_VAR 0 14
24869: PPUSH
24870: CALL_OW 2
24874: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
24875: LD_VAR 0 14
24879: PPUSH
24880: LD_VAR 0 9
24884: PPUSH
24885: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
24889: LD_VAR 0 9
24893: PPUSH
24894: CALL_OW 313
24898: PUSH
24899: LD_INT 6
24901: EQUAL
24902: PUSH
24903: LD_VAR 0 9
24907: PPUSH
24908: CALL_OW 266
24912: PUSH
24913: LD_INT 32
24915: PUSH
24916: LD_INT 31
24918: PUSH
24919: EMPTY
24920: LIST
24921: LIST
24922: IN
24923: OR
24924: IFFALSE 24738
24926: GO 24735
24928: POP
24929: POP
// end else
24930: GO 25312
// for j = 1 to x do
24932: LD_ADDR_VAR 0 9
24936: PUSH
24937: DOUBLE
24938: LD_INT 1
24940: DEC
24941: ST_TO_ADDR
24942: LD_VAR 0 13
24946: PUSH
24947: FOR_TO
24948: IFFALSE 25310
// begin InitHc ;
24950: CALL_OW 19
// if not f then
24954: LD_VAR 0 12
24958: NOT
24959: IFFALSE 25048
// begin PrepareHuman ( false , i , skill ) ;
24961: LD_INT 0
24963: PPUSH
24964: LD_VAR 0 8
24968: PPUSH
24969: LD_VAR 0 4
24973: PPUSH
24974: CALL_OW 380
// un := CreateHuman ;
24978: LD_ADDR_VAR 0 14
24982: PUSH
24983: CALL_OW 44
24987: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24988: LD_ADDR_VAR 0 7
24992: PUSH
24993: LD_VAR 0 7
24997: PPUSH
24998: LD_INT 1
25000: PPUSH
25001: LD_VAR 0 14
25005: PPUSH
25006: CALL_OW 2
25010: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25011: LD_VAR 0 14
25015: PPUSH
25016: LD_VAR 0 1
25020: PPUSH
25021: CALL_OW 250
25025: PPUSH
25026: LD_VAR 0 1
25030: PPUSH
25031: CALL_OW 251
25035: PPUSH
25036: LD_INT 10
25038: PPUSH
25039: LD_INT 0
25041: PPUSH
25042: CALL_OW 50
// continue ;
25046: GO 24947
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25048: LD_VAR 0 12
25052: PUSH
25053: LD_INT 1
25055: ARRAY
25056: PPUSH
25057: CALL_OW 313
25061: PUSH
25062: LD_VAR 0 12
25066: PUSH
25067: LD_INT 1
25069: ARRAY
25070: PPUSH
25071: CALL_OW 266
25075: PUSH
25076: LD_INT 32
25078: PUSH
25079: LD_INT 31
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: IN
25086: AND
25087: PUSH
25088: LD_VAR 0 12
25092: PUSH
25093: LD_INT 1
25095: ARRAY
25096: PPUSH
25097: CALL_OW 313
25101: PUSH
25102: LD_INT 6
25104: EQUAL
25105: OR
25106: IFFALSE 25126
// f := Delete ( f , 1 ) ;
25108: LD_ADDR_VAR 0 12
25112: PUSH
25113: LD_VAR 0 12
25117: PPUSH
25118: LD_INT 1
25120: PPUSH
25121: CALL_OW 3
25125: ST_TO_ADDR
// if not f then
25126: LD_VAR 0 12
25130: NOT
25131: IFFALSE 25149
// begin x := x + 2 ;
25133: LD_ADDR_VAR 0 13
25137: PUSH
25138: LD_VAR 0 13
25142: PUSH
25143: LD_INT 2
25145: PLUS
25146: ST_TO_ADDR
// continue ;
25147: GO 24947
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25149: LD_VAR 0 12
25153: PUSH
25154: LD_INT 1
25156: ARRAY
25157: PPUSH
25158: CALL_OW 266
25162: PUSH
25163: LD_INT 5
25165: EQUAL
25166: IFFALSE 25240
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25168: LD_VAR 0 12
25172: PUSH
25173: LD_INT 1
25175: ARRAY
25176: PPUSH
25177: CALL_OW 313
25181: PUSH
25182: LD_INT 3
25184: LESS
25185: IFFALSE 25221
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25187: LD_INT 0
25189: PPUSH
25190: LD_INT 5
25192: PUSH
25193: LD_INT 8
25195: PUSH
25196: LD_INT 9
25198: PUSH
25199: EMPTY
25200: LIST
25201: LIST
25202: LIST
25203: PUSH
25204: LD_VAR 0 17
25208: ARRAY
25209: PPUSH
25210: LD_VAR 0 4
25214: PPUSH
25215: CALL_OW 380
25219: GO 25238
// PrepareHuman ( false , i , skill ) ;
25221: LD_INT 0
25223: PPUSH
25224: LD_VAR 0 8
25228: PPUSH
25229: LD_VAR 0 4
25233: PPUSH
25234: CALL_OW 380
// end else
25238: GO 25257
// PrepareHuman ( false , i , skill ) ;
25240: LD_INT 0
25242: PPUSH
25243: LD_VAR 0 8
25247: PPUSH
25248: LD_VAR 0 4
25252: PPUSH
25253: CALL_OW 380
// un := CreateHuman ;
25257: LD_ADDR_VAR 0 14
25261: PUSH
25262: CALL_OW 44
25266: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25267: LD_ADDR_VAR 0 7
25271: PUSH
25272: LD_VAR 0 7
25276: PPUSH
25277: LD_INT 1
25279: PPUSH
25280: LD_VAR 0 14
25284: PPUSH
25285: CALL_OW 2
25289: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
25290: LD_VAR 0 14
25294: PPUSH
25295: LD_VAR 0 12
25299: PUSH
25300: LD_INT 1
25302: ARRAY
25303: PPUSH
25304: CALL_OW 52
// end ;
25308: GO 24947
25310: POP
25311: POP
// end ;
25312: GO 24249
25314: POP
25315: POP
// result := result ^ buildings ;
25316: LD_ADDR_VAR 0 7
25320: PUSH
25321: LD_VAR 0 7
25325: PUSH
25326: LD_VAR 0 18
25330: ADD
25331: ST_TO_ADDR
// end else
25332: GO 25475
// begin for i = 1 to personel do
25334: LD_ADDR_VAR 0 8
25338: PUSH
25339: DOUBLE
25340: LD_INT 1
25342: DEC
25343: ST_TO_ADDR
25344: LD_VAR 0 6
25348: PUSH
25349: FOR_TO
25350: IFFALSE 25473
// begin if i > 4 then
25352: LD_VAR 0 8
25356: PUSH
25357: LD_INT 4
25359: GREATER
25360: IFFALSE 25364
// break ;
25362: GO 25473
// x := personel [ i ] ;
25364: LD_ADDR_VAR 0 13
25368: PUSH
25369: LD_VAR 0 6
25373: PUSH
25374: LD_VAR 0 8
25378: ARRAY
25379: ST_TO_ADDR
// if x = - 1 then
25380: LD_VAR 0 13
25384: PUSH
25385: LD_INT 1
25387: NEG
25388: EQUAL
25389: IFFALSE 25393
// continue ;
25391: GO 25349
// PrepareHuman ( false , i , skill ) ;
25393: LD_INT 0
25395: PPUSH
25396: LD_VAR 0 8
25400: PPUSH
25401: LD_VAR 0 4
25405: PPUSH
25406: CALL_OW 380
// un := CreateHuman ;
25410: LD_ADDR_VAR 0 14
25414: PUSH
25415: CALL_OW 44
25419: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25420: LD_VAR 0 14
25424: PPUSH
25425: LD_VAR 0 1
25429: PPUSH
25430: CALL_OW 250
25434: PPUSH
25435: LD_VAR 0 1
25439: PPUSH
25440: CALL_OW 251
25444: PPUSH
25445: LD_INT 10
25447: PPUSH
25448: LD_INT 0
25450: PPUSH
25451: CALL_OW 50
// result := result ^ un ;
25455: LD_ADDR_VAR 0 7
25459: PUSH
25460: LD_VAR 0 7
25464: PUSH
25465: LD_VAR 0 14
25469: ADD
25470: ST_TO_ADDR
// end ;
25471: GO 25349
25473: POP
25474: POP
// end ; end ;
25475: LD_VAR 0 7
25479: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
25480: LD_INT 0
25482: PPUSH
25483: PPUSH
25484: PPUSH
25485: PPUSH
25486: PPUSH
25487: PPUSH
25488: PPUSH
25489: PPUSH
25490: PPUSH
25491: PPUSH
25492: PPUSH
25493: PPUSH
25494: PPUSH
25495: PPUSH
25496: PPUSH
25497: PPUSH
// result := false ;
25498: LD_ADDR_VAR 0 3
25502: PUSH
25503: LD_INT 0
25505: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
25506: LD_VAR 0 1
25510: NOT
25511: PUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: CALL_OW 266
25521: PUSH
25522: LD_INT 32
25524: PUSH
25525: LD_INT 33
25527: PUSH
25528: EMPTY
25529: LIST
25530: LIST
25531: IN
25532: NOT
25533: OR
25534: IFFALSE 25538
// exit ;
25536: GO 26647
// nat := GetNation ( tower ) ;
25538: LD_ADDR_VAR 0 12
25542: PUSH
25543: LD_VAR 0 1
25547: PPUSH
25548: CALL_OW 248
25552: ST_TO_ADDR
// side := GetSide ( tower ) ;
25553: LD_ADDR_VAR 0 16
25557: PUSH
25558: LD_VAR 0 1
25562: PPUSH
25563: CALL_OW 255
25567: ST_TO_ADDR
// x := GetX ( tower ) ;
25568: LD_ADDR_VAR 0 10
25572: PUSH
25573: LD_VAR 0 1
25577: PPUSH
25578: CALL_OW 250
25582: ST_TO_ADDR
// y := GetY ( tower ) ;
25583: LD_ADDR_VAR 0 11
25587: PUSH
25588: LD_VAR 0 1
25592: PPUSH
25593: CALL_OW 251
25597: ST_TO_ADDR
// if not x or not y then
25598: LD_VAR 0 10
25602: NOT
25603: PUSH
25604: LD_VAR 0 11
25608: NOT
25609: OR
25610: IFFALSE 25614
// exit ;
25612: GO 26647
// weapon := 0 ;
25614: LD_ADDR_VAR 0 18
25618: PUSH
25619: LD_INT 0
25621: ST_TO_ADDR
// fac_list := [ ] ;
25622: LD_ADDR_VAR 0 17
25626: PUSH
25627: EMPTY
25628: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
25629: LD_ADDR_VAR 0 6
25633: PUSH
25634: LD_VAR 0 1
25638: PPUSH
25639: CALL_OW 274
25643: PPUSH
25644: LD_VAR 0 2
25648: PPUSH
25649: LD_INT 0
25651: PPUSH
25652: CALL 23218 0 3
25656: PPUSH
25657: LD_INT 30
25659: PUSH
25660: LD_INT 3
25662: PUSH
25663: EMPTY
25664: LIST
25665: LIST
25666: PPUSH
25667: CALL_OW 72
25671: ST_TO_ADDR
// if not factories then
25672: LD_VAR 0 6
25676: NOT
25677: IFFALSE 25681
// exit ;
25679: GO 26647
// for i in factories do
25681: LD_ADDR_VAR 0 8
25685: PUSH
25686: LD_VAR 0 6
25690: PUSH
25691: FOR_IN
25692: IFFALSE 25717
// fac_list := fac_list union AvailableWeaponList ( i ) ;
25694: LD_ADDR_VAR 0 17
25698: PUSH
25699: LD_VAR 0 17
25703: PUSH
25704: LD_VAR 0 8
25708: PPUSH
25709: CALL_OW 478
25713: UNION
25714: ST_TO_ADDR
25715: GO 25691
25717: POP
25718: POP
// if not fac_list then
25719: LD_VAR 0 17
25723: NOT
25724: IFFALSE 25728
// exit ;
25726: GO 26647
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
25728: LD_ADDR_VAR 0 5
25732: PUSH
25733: LD_INT 4
25735: PUSH
25736: LD_INT 5
25738: PUSH
25739: LD_INT 9
25741: PUSH
25742: LD_INT 10
25744: PUSH
25745: LD_INT 6
25747: PUSH
25748: LD_INT 7
25750: PUSH
25751: LD_INT 11
25753: PUSH
25754: EMPTY
25755: LIST
25756: LIST
25757: LIST
25758: LIST
25759: LIST
25760: LIST
25761: LIST
25762: PUSH
25763: LD_INT 27
25765: PUSH
25766: LD_INT 28
25768: PUSH
25769: LD_INT 26
25771: PUSH
25772: LD_INT 30
25774: PUSH
25775: EMPTY
25776: LIST
25777: LIST
25778: LIST
25779: LIST
25780: PUSH
25781: LD_INT 43
25783: PUSH
25784: LD_INT 44
25786: PUSH
25787: LD_INT 46
25789: PUSH
25790: LD_INT 45
25792: PUSH
25793: LD_INT 47
25795: PUSH
25796: LD_INT 49
25798: PUSH
25799: EMPTY
25800: LIST
25801: LIST
25802: LIST
25803: LIST
25804: LIST
25805: LIST
25806: PUSH
25807: EMPTY
25808: LIST
25809: LIST
25810: LIST
25811: PUSH
25812: LD_VAR 0 12
25816: ARRAY
25817: ST_TO_ADDR
// list := list isect fac_list ;
25818: LD_ADDR_VAR 0 5
25822: PUSH
25823: LD_VAR 0 5
25827: PUSH
25828: LD_VAR 0 17
25832: ISECT
25833: ST_TO_ADDR
// if not list then
25834: LD_VAR 0 5
25838: NOT
25839: IFFALSE 25843
// exit ;
25841: GO 26647
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
25843: LD_VAR 0 12
25847: PUSH
25848: LD_INT 3
25850: EQUAL
25851: PUSH
25852: LD_INT 49
25854: PUSH
25855: LD_VAR 0 5
25859: IN
25860: AND
25861: PUSH
25862: LD_INT 31
25864: PPUSH
25865: LD_VAR 0 16
25869: PPUSH
25870: CALL_OW 321
25874: PUSH
25875: LD_INT 2
25877: EQUAL
25878: AND
25879: IFFALSE 25939
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
25881: LD_INT 22
25883: PUSH
25884: LD_VAR 0 16
25888: PUSH
25889: EMPTY
25890: LIST
25891: LIST
25892: PUSH
25893: LD_INT 35
25895: PUSH
25896: LD_INT 49
25898: PUSH
25899: EMPTY
25900: LIST
25901: LIST
25902: PUSH
25903: LD_INT 91
25905: PUSH
25906: LD_VAR 0 1
25910: PUSH
25911: LD_INT 10
25913: PUSH
25914: EMPTY
25915: LIST
25916: LIST
25917: LIST
25918: PUSH
25919: EMPTY
25920: LIST
25921: LIST
25922: LIST
25923: PPUSH
25924: CALL_OW 69
25928: NOT
25929: IFFALSE 25939
// weapon := ru_time_lapser ;
25931: LD_ADDR_VAR 0 18
25935: PUSH
25936: LD_INT 49
25938: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
25939: LD_VAR 0 12
25943: PUSH
25944: LD_INT 1
25946: PUSH
25947: LD_INT 2
25949: PUSH
25950: EMPTY
25951: LIST
25952: LIST
25953: IN
25954: PUSH
25955: LD_INT 11
25957: PUSH
25958: LD_VAR 0 5
25962: IN
25963: PUSH
25964: LD_INT 30
25966: PUSH
25967: LD_VAR 0 5
25971: IN
25972: OR
25973: AND
25974: PUSH
25975: LD_INT 6
25977: PPUSH
25978: LD_VAR 0 16
25982: PPUSH
25983: CALL_OW 321
25987: PUSH
25988: LD_INT 2
25990: EQUAL
25991: AND
25992: IFFALSE 26157
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
25994: LD_INT 22
25996: PUSH
25997: LD_VAR 0 16
26001: PUSH
26002: EMPTY
26003: LIST
26004: LIST
26005: PUSH
26006: LD_INT 2
26008: PUSH
26009: LD_INT 35
26011: PUSH
26012: LD_INT 11
26014: PUSH
26015: EMPTY
26016: LIST
26017: LIST
26018: PUSH
26019: LD_INT 35
26021: PUSH
26022: LD_INT 30
26024: PUSH
26025: EMPTY
26026: LIST
26027: LIST
26028: PUSH
26029: EMPTY
26030: LIST
26031: LIST
26032: LIST
26033: PUSH
26034: LD_INT 91
26036: PUSH
26037: LD_VAR 0 1
26041: PUSH
26042: LD_INT 18
26044: PUSH
26045: EMPTY
26046: LIST
26047: LIST
26048: LIST
26049: PUSH
26050: EMPTY
26051: LIST
26052: LIST
26053: LIST
26054: PPUSH
26055: CALL_OW 69
26059: NOT
26060: PUSH
26061: LD_INT 22
26063: PUSH
26064: LD_VAR 0 16
26068: PUSH
26069: EMPTY
26070: LIST
26071: LIST
26072: PUSH
26073: LD_INT 2
26075: PUSH
26076: LD_INT 30
26078: PUSH
26079: LD_INT 32
26081: PUSH
26082: EMPTY
26083: LIST
26084: LIST
26085: PUSH
26086: LD_INT 30
26088: PUSH
26089: LD_INT 33
26091: PUSH
26092: EMPTY
26093: LIST
26094: LIST
26095: PUSH
26096: EMPTY
26097: LIST
26098: LIST
26099: LIST
26100: PUSH
26101: LD_INT 91
26103: PUSH
26104: LD_VAR 0 1
26108: PUSH
26109: LD_INT 12
26111: PUSH
26112: EMPTY
26113: LIST
26114: LIST
26115: LIST
26116: PUSH
26117: EMPTY
26118: LIST
26119: LIST
26120: LIST
26121: PUSH
26122: EMPTY
26123: LIST
26124: PPUSH
26125: CALL_OW 69
26129: PUSH
26130: LD_INT 2
26132: GREATER
26133: AND
26134: IFFALSE 26157
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26136: LD_ADDR_VAR 0 18
26140: PUSH
26141: LD_INT 11
26143: PUSH
26144: LD_INT 30
26146: PUSH
26147: EMPTY
26148: LIST
26149: LIST
26150: PUSH
26151: LD_VAR 0 12
26155: ARRAY
26156: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26157: LD_VAR 0 18
26161: NOT
26162: PUSH
26163: LD_INT 40
26165: PPUSH
26166: LD_VAR 0 16
26170: PPUSH
26171: CALL_OW 321
26175: PUSH
26176: LD_INT 2
26178: EQUAL
26179: AND
26180: PUSH
26181: LD_INT 7
26183: PUSH
26184: LD_VAR 0 5
26188: IN
26189: PUSH
26190: LD_INT 28
26192: PUSH
26193: LD_VAR 0 5
26197: IN
26198: OR
26199: PUSH
26200: LD_INT 45
26202: PUSH
26203: LD_VAR 0 5
26207: IN
26208: OR
26209: AND
26210: IFFALSE 26464
// begin hex := GetHexInfo ( x , y ) ;
26212: LD_ADDR_VAR 0 4
26216: PUSH
26217: LD_VAR 0 10
26221: PPUSH
26222: LD_VAR 0 11
26226: PPUSH
26227: CALL_OW 546
26231: ST_TO_ADDR
// if hex [ 1 ] then
26232: LD_VAR 0 4
26236: PUSH
26237: LD_INT 1
26239: ARRAY
26240: IFFALSE 26244
// exit ;
26242: GO 26647
// height := hex [ 2 ] ;
26244: LD_ADDR_VAR 0 15
26248: PUSH
26249: LD_VAR 0 4
26253: PUSH
26254: LD_INT 2
26256: ARRAY
26257: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
26258: LD_ADDR_VAR 0 14
26262: PUSH
26263: LD_INT 0
26265: PUSH
26266: LD_INT 2
26268: PUSH
26269: LD_INT 3
26271: PUSH
26272: LD_INT 5
26274: PUSH
26275: EMPTY
26276: LIST
26277: LIST
26278: LIST
26279: LIST
26280: ST_TO_ADDR
// for i in tmp do
26281: LD_ADDR_VAR 0 8
26285: PUSH
26286: LD_VAR 0 14
26290: PUSH
26291: FOR_IN
26292: IFFALSE 26462
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
26294: LD_ADDR_VAR 0 9
26298: PUSH
26299: LD_VAR 0 10
26303: PPUSH
26304: LD_VAR 0 8
26308: PPUSH
26309: LD_INT 5
26311: PPUSH
26312: CALL_OW 272
26316: PUSH
26317: LD_VAR 0 11
26321: PPUSH
26322: LD_VAR 0 8
26326: PPUSH
26327: LD_INT 5
26329: PPUSH
26330: CALL_OW 273
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
26339: LD_VAR 0 9
26343: PUSH
26344: LD_INT 1
26346: ARRAY
26347: PPUSH
26348: LD_VAR 0 9
26352: PUSH
26353: LD_INT 2
26355: ARRAY
26356: PPUSH
26357: CALL_OW 488
26361: IFFALSE 26460
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
26363: LD_ADDR_VAR 0 4
26367: PUSH
26368: LD_VAR 0 9
26372: PUSH
26373: LD_INT 1
26375: ARRAY
26376: PPUSH
26377: LD_VAR 0 9
26381: PUSH
26382: LD_INT 2
26384: ARRAY
26385: PPUSH
26386: CALL_OW 546
26390: ST_TO_ADDR
// if hex [ 1 ] then
26391: LD_VAR 0 4
26395: PUSH
26396: LD_INT 1
26398: ARRAY
26399: IFFALSE 26403
// continue ;
26401: GO 26291
// h := hex [ 2 ] ;
26403: LD_ADDR_VAR 0 13
26407: PUSH
26408: LD_VAR 0 4
26412: PUSH
26413: LD_INT 2
26415: ARRAY
26416: ST_TO_ADDR
// if h + 7 < height then
26417: LD_VAR 0 13
26421: PUSH
26422: LD_INT 7
26424: PLUS
26425: PUSH
26426: LD_VAR 0 15
26430: LESS
26431: IFFALSE 26460
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
26433: LD_ADDR_VAR 0 18
26437: PUSH
26438: LD_INT 7
26440: PUSH
26441: LD_INT 28
26443: PUSH
26444: LD_INT 45
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: LIST
26451: PUSH
26452: LD_VAR 0 12
26456: ARRAY
26457: ST_TO_ADDR
// break ;
26458: GO 26462
// end ; end ; end ;
26460: GO 26291
26462: POP
26463: POP
// end ; if not weapon then
26464: LD_VAR 0 18
26468: NOT
26469: IFFALSE 26529
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
26471: LD_ADDR_VAR 0 5
26475: PUSH
26476: LD_VAR 0 5
26480: PUSH
26481: LD_INT 11
26483: PUSH
26484: LD_INT 30
26486: PUSH
26487: LD_INT 49
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: LIST
26494: DIFF
26495: ST_TO_ADDR
// if not list then
26496: LD_VAR 0 5
26500: NOT
26501: IFFALSE 26505
// exit ;
26503: GO 26647
// weapon := list [ rand ( 1 , list ) ] ;
26505: LD_ADDR_VAR 0 18
26509: PUSH
26510: LD_VAR 0 5
26514: PUSH
26515: LD_INT 1
26517: PPUSH
26518: LD_VAR 0 5
26522: PPUSH
26523: CALL_OW 12
26527: ARRAY
26528: ST_TO_ADDR
// end ; if weapon then
26529: LD_VAR 0 18
26533: IFFALSE 26647
// begin tmp := CostOfWeapon ( weapon ) ;
26535: LD_ADDR_VAR 0 14
26539: PUSH
26540: LD_VAR 0 18
26544: PPUSH
26545: CALL_OW 451
26549: ST_TO_ADDR
// j := GetBase ( tower ) ;
26550: LD_ADDR_VAR 0 9
26554: PUSH
26555: LD_VAR 0 1
26559: PPUSH
26560: CALL_OW 274
26564: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
26565: LD_VAR 0 9
26569: PPUSH
26570: LD_INT 1
26572: PPUSH
26573: CALL_OW 275
26577: PUSH
26578: LD_VAR 0 14
26582: PUSH
26583: LD_INT 1
26585: ARRAY
26586: GREATEREQUAL
26587: PUSH
26588: LD_VAR 0 9
26592: PPUSH
26593: LD_INT 2
26595: PPUSH
26596: CALL_OW 275
26600: PUSH
26601: LD_VAR 0 14
26605: PUSH
26606: LD_INT 2
26608: ARRAY
26609: GREATEREQUAL
26610: AND
26611: PUSH
26612: LD_VAR 0 9
26616: PPUSH
26617: LD_INT 3
26619: PPUSH
26620: CALL_OW 275
26624: PUSH
26625: LD_VAR 0 14
26629: PUSH
26630: LD_INT 3
26632: ARRAY
26633: GREATEREQUAL
26634: AND
26635: IFFALSE 26647
// result := weapon ;
26637: LD_ADDR_VAR 0 3
26641: PUSH
26642: LD_VAR 0 18
26646: ST_TO_ADDR
// end ; end ;
26647: LD_VAR 0 3
26651: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
26652: LD_INT 0
26654: PPUSH
26655: PPUSH
// result := true ;
26656: LD_ADDR_VAR 0 3
26660: PUSH
26661: LD_INT 1
26663: ST_TO_ADDR
// if array1 = array2 then
26664: LD_VAR 0 1
26668: PUSH
26669: LD_VAR 0 2
26673: EQUAL
26674: IFFALSE 26734
// begin for i = 1 to array1 do
26676: LD_ADDR_VAR 0 4
26680: PUSH
26681: DOUBLE
26682: LD_INT 1
26684: DEC
26685: ST_TO_ADDR
26686: LD_VAR 0 1
26690: PUSH
26691: FOR_TO
26692: IFFALSE 26730
// if array1 [ i ] <> array2 [ i ] then
26694: LD_VAR 0 1
26698: PUSH
26699: LD_VAR 0 4
26703: ARRAY
26704: PUSH
26705: LD_VAR 0 2
26709: PUSH
26710: LD_VAR 0 4
26714: ARRAY
26715: NONEQUAL
26716: IFFALSE 26728
// begin result := false ;
26718: LD_ADDR_VAR 0 3
26722: PUSH
26723: LD_INT 0
26725: ST_TO_ADDR
// break ;
26726: GO 26730
// end ;
26728: GO 26691
26730: POP
26731: POP
// end else
26732: GO 26742
// result := false ;
26734: LD_ADDR_VAR 0 3
26738: PUSH
26739: LD_INT 0
26741: ST_TO_ADDR
// end ;
26742: LD_VAR 0 3
26746: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
26747: LD_INT 0
26749: PPUSH
26750: PPUSH
// if not array1 or not array2 then
26751: LD_VAR 0 1
26755: NOT
26756: PUSH
26757: LD_VAR 0 2
26761: NOT
26762: OR
26763: IFFALSE 26767
// exit ;
26765: GO 26831
// result := true ;
26767: LD_ADDR_VAR 0 3
26771: PUSH
26772: LD_INT 1
26774: ST_TO_ADDR
// for i = 1 to array1 do
26775: LD_ADDR_VAR 0 4
26779: PUSH
26780: DOUBLE
26781: LD_INT 1
26783: DEC
26784: ST_TO_ADDR
26785: LD_VAR 0 1
26789: PUSH
26790: FOR_TO
26791: IFFALSE 26829
// if array1 [ i ] <> array2 [ i ] then
26793: LD_VAR 0 1
26797: PUSH
26798: LD_VAR 0 4
26802: ARRAY
26803: PUSH
26804: LD_VAR 0 2
26808: PUSH
26809: LD_VAR 0 4
26813: ARRAY
26814: NONEQUAL
26815: IFFALSE 26827
// begin result := false ;
26817: LD_ADDR_VAR 0 3
26821: PUSH
26822: LD_INT 0
26824: ST_TO_ADDR
// break ;
26825: GO 26829
// end ;
26827: GO 26790
26829: POP
26830: POP
// end ;
26831: LD_VAR 0 3
26835: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
26836: LD_INT 0
26838: PPUSH
26839: PPUSH
26840: PPUSH
// pom := GetBase ( fac ) ;
26841: LD_ADDR_VAR 0 5
26845: PUSH
26846: LD_VAR 0 1
26850: PPUSH
26851: CALL_OW 274
26855: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
26856: LD_ADDR_VAR 0 4
26860: PUSH
26861: LD_VAR 0 2
26865: PUSH
26866: LD_INT 1
26868: ARRAY
26869: PPUSH
26870: LD_VAR 0 2
26874: PUSH
26875: LD_INT 2
26877: ARRAY
26878: PPUSH
26879: LD_VAR 0 2
26883: PUSH
26884: LD_INT 3
26886: ARRAY
26887: PPUSH
26888: LD_VAR 0 2
26892: PUSH
26893: LD_INT 4
26895: ARRAY
26896: PPUSH
26897: CALL_OW 449
26901: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
26902: LD_ADDR_VAR 0 3
26906: PUSH
26907: LD_VAR 0 5
26911: PPUSH
26912: LD_INT 1
26914: PPUSH
26915: CALL_OW 275
26919: PUSH
26920: LD_VAR 0 4
26924: PUSH
26925: LD_INT 1
26927: ARRAY
26928: GREATEREQUAL
26929: PUSH
26930: LD_VAR 0 5
26934: PPUSH
26935: LD_INT 2
26937: PPUSH
26938: CALL_OW 275
26942: PUSH
26943: LD_VAR 0 4
26947: PUSH
26948: LD_INT 2
26950: ARRAY
26951: GREATEREQUAL
26952: AND
26953: PUSH
26954: LD_VAR 0 5
26958: PPUSH
26959: LD_INT 3
26961: PPUSH
26962: CALL_OW 275
26966: PUSH
26967: LD_VAR 0 4
26971: PUSH
26972: LD_INT 3
26974: ARRAY
26975: GREATEREQUAL
26976: AND
26977: ST_TO_ADDR
// end ;
26978: LD_VAR 0 3
26982: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
26983: LD_INT 0
26985: PPUSH
26986: PPUSH
26987: PPUSH
26988: PPUSH
// pom := GetBase ( building ) ;
26989: LD_ADDR_VAR 0 3
26993: PUSH
26994: LD_VAR 0 1
26998: PPUSH
26999: CALL_OW 274
27003: ST_TO_ADDR
// if not pom then
27004: LD_VAR 0 3
27008: NOT
27009: IFFALSE 27013
// exit ;
27011: GO 27183
// btype := GetBType ( building ) ;
27013: LD_ADDR_VAR 0 5
27017: PUSH
27018: LD_VAR 0 1
27022: PPUSH
27023: CALL_OW 266
27027: ST_TO_ADDR
// if btype = b_armoury then
27028: LD_VAR 0 5
27032: PUSH
27033: LD_INT 4
27035: EQUAL
27036: IFFALSE 27046
// btype := b_barracks ;
27038: LD_ADDR_VAR 0 5
27042: PUSH
27043: LD_INT 5
27045: ST_TO_ADDR
// if btype = b_depot then
27046: LD_VAR 0 5
27050: PUSH
27051: LD_INT 0
27053: EQUAL
27054: IFFALSE 27064
// btype := b_warehouse ;
27056: LD_ADDR_VAR 0 5
27060: PUSH
27061: LD_INT 1
27063: ST_TO_ADDR
// if btype = b_workshop then
27064: LD_VAR 0 5
27068: PUSH
27069: LD_INT 2
27071: EQUAL
27072: IFFALSE 27082
// btype := b_factory ;
27074: LD_ADDR_VAR 0 5
27078: PUSH
27079: LD_INT 3
27081: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27082: LD_ADDR_VAR 0 4
27086: PUSH
27087: LD_VAR 0 5
27091: PPUSH
27092: LD_VAR 0 1
27096: PPUSH
27097: CALL_OW 248
27101: PPUSH
27102: CALL_OW 450
27106: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27107: LD_ADDR_VAR 0 2
27111: PUSH
27112: LD_VAR 0 3
27116: PPUSH
27117: LD_INT 1
27119: PPUSH
27120: CALL_OW 275
27124: PUSH
27125: LD_VAR 0 4
27129: PUSH
27130: LD_INT 1
27132: ARRAY
27133: GREATEREQUAL
27134: PUSH
27135: LD_VAR 0 3
27139: PPUSH
27140: LD_INT 2
27142: PPUSH
27143: CALL_OW 275
27147: PUSH
27148: LD_VAR 0 4
27152: PUSH
27153: LD_INT 2
27155: ARRAY
27156: GREATEREQUAL
27157: AND
27158: PUSH
27159: LD_VAR 0 3
27163: PPUSH
27164: LD_INT 3
27166: PPUSH
27167: CALL_OW 275
27171: PUSH
27172: LD_VAR 0 4
27176: PUSH
27177: LD_INT 3
27179: ARRAY
27180: GREATEREQUAL
27181: AND
27182: ST_TO_ADDR
// end ;
27183: LD_VAR 0 2
27187: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27188: LD_INT 0
27190: PPUSH
27191: PPUSH
27192: PPUSH
// pom := GetBase ( building ) ;
27193: LD_ADDR_VAR 0 4
27197: PUSH
27198: LD_VAR 0 1
27202: PPUSH
27203: CALL_OW 274
27207: ST_TO_ADDR
// if not pom then
27208: LD_VAR 0 4
27212: NOT
27213: IFFALSE 27217
// exit ;
27215: GO 27318
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27217: LD_ADDR_VAR 0 5
27221: PUSH
27222: LD_VAR 0 2
27226: PPUSH
27227: LD_VAR 0 1
27231: PPUSH
27232: CALL_OW 248
27236: PPUSH
27237: CALL_OW 450
27241: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27242: LD_ADDR_VAR 0 3
27246: PUSH
27247: LD_VAR 0 4
27251: PPUSH
27252: LD_INT 1
27254: PPUSH
27255: CALL_OW 275
27259: PUSH
27260: LD_VAR 0 5
27264: PUSH
27265: LD_INT 1
27267: ARRAY
27268: GREATEREQUAL
27269: PUSH
27270: LD_VAR 0 4
27274: PPUSH
27275: LD_INT 2
27277: PPUSH
27278: CALL_OW 275
27282: PUSH
27283: LD_VAR 0 5
27287: PUSH
27288: LD_INT 2
27290: ARRAY
27291: GREATEREQUAL
27292: AND
27293: PUSH
27294: LD_VAR 0 4
27298: PPUSH
27299: LD_INT 3
27301: PPUSH
27302: CALL_OW 275
27306: PUSH
27307: LD_VAR 0 5
27311: PUSH
27312: LD_INT 3
27314: ARRAY
27315: GREATEREQUAL
27316: AND
27317: ST_TO_ADDR
// end ;
27318: LD_VAR 0 3
27322: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
27323: LD_INT 0
27325: PPUSH
27326: PPUSH
27327: PPUSH
27328: PPUSH
27329: PPUSH
27330: PPUSH
27331: PPUSH
27332: PPUSH
27333: PPUSH
27334: PPUSH
27335: PPUSH
// result := false ;
27336: LD_ADDR_VAR 0 8
27340: PUSH
27341: LD_INT 0
27343: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
27344: LD_VAR 0 5
27348: NOT
27349: PUSH
27350: LD_VAR 0 1
27354: NOT
27355: OR
27356: PUSH
27357: LD_VAR 0 2
27361: NOT
27362: OR
27363: PUSH
27364: LD_VAR 0 3
27368: NOT
27369: OR
27370: IFFALSE 27374
// exit ;
27372: GO 28188
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
27374: LD_ADDR_VAR 0 14
27378: PUSH
27379: LD_VAR 0 1
27383: PPUSH
27384: LD_VAR 0 2
27388: PPUSH
27389: LD_VAR 0 3
27393: PPUSH
27394: LD_VAR 0 4
27398: PPUSH
27399: LD_VAR 0 5
27403: PUSH
27404: LD_INT 1
27406: ARRAY
27407: PPUSH
27408: CALL_OW 248
27412: PPUSH
27413: LD_INT 0
27415: PPUSH
27416: CALL 29421 0 6
27420: ST_TO_ADDR
// if not hexes then
27421: LD_VAR 0 14
27425: NOT
27426: IFFALSE 27430
// exit ;
27428: GO 28188
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
27430: LD_ADDR_VAR 0 17
27434: PUSH
27435: LD_VAR 0 5
27439: PPUSH
27440: LD_INT 22
27442: PUSH
27443: LD_VAR 0 13
27447: PPUSH
27448: CALL_OW 255
27452: PUSH
27453: EMPTY
27454: LIST
27455: LIST
27456: PUSH
27457: LD_INT 2
27459: PUSH
27460: LD_INT 30
27462: PUSH
27463: LD_INT 0
27465: PUSH
27466: EMPTY
27467: LIST
27468: LIST
27469: PUSH
27470: LD_INT 30
27472: PUSH
27473: LD_INT 1
27475: PUSH
27476: EMPTY
27477: LIST
27478: LIST
27479: PUSH
27480: EMPTY
27481: LIST
27482: LIST
27483: LIST
27484: PUSH
27485: EMPTY
27486: LIST
27487: LIST
27488: PPUSH
27489: CALL_OW 72
27493: ST_TO_ADDR
// for i = 1 to hexes do
27494: LD_ADDR_VAR 0 9
27498: PUSH
27499: DOUBLE
27500: LD_INT 1
27502: DEC
27503: ST_TO_ADDR
27504: LD_VAR 0 14
27508: PUSH
27509: FOR_TO
27510: IFFALSE 28186
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27512: LD_ADDR_VAR 0 13
27516: PUSH
27517: LD_VAR 0 14
27521: PUSH
27522: LD_VAR 0 9
27526: ARRAY
27527: PUSH
27528: LD_INT 1
27530: ARRAY
27531: PPUSH
27532: LD_VAR 0 14
27536: PUSH
27537: LD_VAR 0 9
27541: ARRAY
27542: PUSH
27543: LD_INT 2
27545: ARRAY
27546: PPUSH
27547: CALL_OW 428
27551: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
27552: LD_VAR 0 14
27556: PUSH
27557: LD_VAR 0 9
27561: ARRAY
27562: PUSH
27563: LD_INT 1
27565: ARRAY
27566: PPUSH
27567: LD_VAR 0 14
27571: PUSH
27572: LD_VAR 0 9
27576: ARRAY
27577: PUSH
27578: LD_INT 2
27580: ARRAY
27581: PPUSH
27582: CALL_OW 351
27586: PUSH
27587: LD_VAR 0 14
27591: PUSH
27592: LD_VAR 0 9
27596: ARRAY
27597: PUSH
27598: LD_INT 1
27600: ARRAY
27601: PPUSH
27602: LD_VAR 0 14
27606: PUSH
27607: LD_VAR 0 9
27611: ARRAY
27612: PUSH
27613: LD_INT 2
27615: ARRAY
27616: PPUSH
27617: CALL_OW 488
27621: NOT
27622: OR
27623: PUSH
27624: LD_VAR 0 13
27628: PPUSH
27629: CALL_OW 247
27633: PUSH
27634: LD_INT 3
27636: EQUAL
27637: OR
27638: IFFALSE 27644
// exit ;
27640: POP
27641: POP
27642: GO 28188
// if not tmp then
27644: LD_VAR 0 13
27648: NOT
27649: IFFALSE 27653
// continue ;
27651: GO 27509
// result := true ;
27653: LD_ADDR_VAR 0 8
27657: PUSH
27658: LD_INT 1
27660: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
27661: LD_VAR 0 6
27665: PUSH
27666: LD_VAR 0 13
27670: PPUSH
27671: CALL_OW 247
27675: PUSH
27676: LD_INT 2
27678: EQUAL
27679: AND
27680: PUSH
27681: LD_VAR 0 13
27685: PPUSH
27686: CALL_OW 263
27690: PUSH
27691: LD_INT 1
27693: EQUAL
27694: AND
27695: IFFALSE 27859
// begin if IsDrivenBy ( tmp ) then
27697: LD_VAR 0 13
27701: PPUSH
27702: CALL_OW 311
27706: IFFALSE 27710
// continue ;
27708: GO 27509
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
27710: LD_VAR 0 6
27714: PPUSH
27715: LD_INT 3
27717: PUSH
27718: LD_INT 60
27720: PUSH
27721: EMPTY
27722: LIST
27723: PUSH
27724: EMPTY
27725: LIST
27726: LIST
27727: PUSH
27728: LD_INT 3
27730: PUSH
27731: LD_INT 55
27733: PUSH
27734: EMPTY
27735: LIST
27736: PUSH
27737: EMPTY
27738: LIST
27739: LIST
27740: PUSH
27741: EMPTY
27742: LIST
27743: LIST
27744: PPUSH
27745: CALL_OW 72
27749: IFFALSE 27857
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
27751: LD_ADDR_VAR 0 18
27755: PUSH
27756: LD_VAR 0 6
27760: PPUSH
27761: LD_INT 3
27763: PUSH
27764: LD_INT 60
27766: PUSH
27767: EMPTY
27768: LIST
27769: PUSH
27770: EMPTY
27771: LIST
27772: LIST
27773: PUSH
27774: LD_INT 3
27776: PUSH
27777: LD_INT 55
27779: PUSH
27780: EMPTY
27781: LIST
27782: PUSH
27783: EMPTY
27784: LIST
27785: LIST
27786: PUSH
27787: EMPTY
27788: LIST
27789: LIST
27790: PPUSH
27791: CALL_OW 72
27795: PUSH
27796: LD_INT 1
27798: ARRAY
27799: ST_TO_ADDR
// if IsInUnit ( driver ) then
27800: LD_VAR 0 18
27804: PPUSH
27805: CALL_OW 310
27809: IFFALSE 27820
// ComExit ( driver ) ;
27811: LD_VAR 0 18
27815: PPUSH
27816: CALL 53200 0 1
// AddComEnterUnit ( driver , tmp ) ;
27820: LD_VAR 0 18
27824: PPUSH
27825: LD_VAR 0 13
27829: PPUSH
27830: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
27834: LD_VAR 0 18
27838: PPUSH
27839: LD_VAR 0 7
27843: PPUSH
27844: CALL_OW 173
// AddComExitVehicle ( driver ) ;
27848: LD_VAR 0 18
27852: PPUSH
27853: CALL_OW 181
// end ; continue ;
27857: GO 27509
// end ; if not cleaners or not tmp in cleaners then
27859: LD_VAR 0 6
27863: NOT
27864: PUSH
27865: LD_VAR 0 13
27869: PUSH
27870: LD_VAR 0 6
27874: IN
27875: NOT
27876: OR
27877: IFFALSE 28184
// begin if dep then
27879: LD_VAR 0 17
27883: IFFALSE 28019
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
27885: LD_ADDR_VAR 0 16
27889: PUSH
27890: LD_VAR 0 17
27894: PUSH
27895: LD_INT 1
27897: ARRAY
27898: PPUSH
27899: CALL_OW 250
27903: PPUSH
27904: LD_VAR 0 17
27908: PUSH
27909: LD_INT 1
27911: ARRAY
27912: PPUSH
27913: CALL_OW 254
27917: PPUSH
27918: LD_INT 5
27920: PPUSH
27921: CALL_OW 272
27925: PUSH
27926: LD_VAR 0 17
27930: PUSH
27931: LD_INT 1
27933: ARRAY
27934: PPUSH
27935: CALL_OW 251
27939: PPUSH
27940: LD_VAR 0 17
27944: PUSH
27945: LD_INT 1
27947: ARRAY
27948: PPUSH
27949: CALL_OW 254
27953: PPUSH
27954: LD_INT 5
27956: PPUSH
27957: CALL_OW 273
27961: PUSH
27962: EMPTY
27963: LIST
27964: LIST
27965: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
27966: LD_VAR 0 16
27970: PUSH
27971: LD_INT 1
27973: ARRAY
27974: PPUSH
27975: LD_VAR 0 16
27979: PUSH
27980: LD_INT 2
27982: ARRAY
27983: PPUSH
27984: CALL_OW 488
27988: IFFALSE 28019
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
27990: LD_VAR 0 13
27994: PPUSH
27995: LD_VAR 0 16
27999: PUSH
28000: LD_INT 1
28002: ARRAY
28003: PPUSH
28004: LD_VAR 0 16
28008: PUSH
28009: LD_INT 2
28011: ARRAY
28012: PPUSH
28013: CALL_OW 111
// continue ;
28017: GO 27509
// end ; end ; r := GetDir ( tmp ) ;
28019: LD_ADDR_VAR 0 15
28023: PUSH
28024: LD_VAR 0 13
28028: PPUSH
28029: CALL_OW 254
28033: ST_TO_ADDR
// if r = 5 then
28034: LD_VAR 0 15
28038: PUSH
28039: LD_INT 5
28041: EQUAL
28042: IFFALSE 28052
// r := 0 ;
28044: LD_ADDR_VAR 0 15
28048: PUSH
28049: LD_INT 0
28051: ST_TO_ADDR
// for j = r to 5 do
28052: LD_ADDR_VAR 0 10
28056: PUSH
28057: DOUBLE
28058: LD_VAR 0 15
28062: DEC
28063: ST_TO_ADDR
28064: LD_INT 5
28066: PUSH
28067: FOR_TO
28068: IFFALSE 28182
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28070: LD_ADDR_VAR 0 11
28074: PUSH
28075: LD_VAR 0 13
28079: PPUSH
28080: CALL_OW 250
28084: PPUSH
28085: LD_VAR 0 10
28089: PPUSH
28090: LD_INT 2
28092: PPUSH
28093: CALL_OW 272
28097: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28098: LD_ADDR_VAR 0 12
28102: PUSH
28103: LD_VAR 0 13
28107: PPUSH
28108: CALL_OW 251
28112: PPUSH
28113: LD_VAR 0 10
28117: PPUSH
28118: LD_INT 2
28120: PPUSH
28121: CALL_OW 273
28125: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28126: LD_VAR 0 11
28130: PPUSH
28131: LD_VAR 0 12
28135: PPUSH
28136: CALL_OW 488
28140: PUSH
28141: LD_VAR 0 11
28145: PPUSH
28146: LD_VAR 0 12
28150: PPUSH
28151: CALL_OW 428
28155: NOT
28156: AND
28157: IFFALSE 28180
// begin ComMoveXY ( tmp , _x , _y ) ;
28159: LD_VAR 0 13
28163: PPUSH
28164: LD_VAR 0 11
28168: PPUSH
28169: LD_VAR 0 12
28173: PPUSH
28174: CALL_OW 111
// break ;
28178: GO 28182
// end ; end ;
28180: GO 28067
28182: POP
28183: POP
// end ; end ;
28184: GO 27509
28186: POP
28187: POP
// end ;
28188: LD_VAR 0 8
28192: RET
// export function BuildingTechInvented ( side , btype ) ; begin
28193: LD_INT 0
28195: PPUSH
// result := true ;
28196: LD_ADDR_VAR 0 3
28200: PUSH
28201: LD_INT 1
28203: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
28204: LD_VAR 0 2
28208: PUSH
28209: LD_INT 24
28211: DOUBLE
28212: EQUAL
28213: IFTRUE 28223
28215: LD_INT 33
28217: DOUBLE
28218: EQUAL
28219: IFTRUE 28223
28221: GO 28248
28223: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
28224: LD_ADDR_VAR 0 3
28228: PUSH
28229: LD_INT 32
28231: PPUSH
28232: LD_VAR 0 1
28236: PPUSH
28237: CALL_OW 321
28241: PUSH
28242: LD_INT 2
28244: EQUAL
28245: ST_TO_ADDR
28246: GO 28564
28248: LD_INT 20
28250: DOUBLE
28251: EQUAL
28252: IFTRUE 28256
28254: GO 28281
28256: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
28257: LD_ADDR_VAR 0 3
28261: PUSH
28262: LD_INT 6
28264: PPUSH
28265: LD_VAR 0 1
28269: PPUSH
28270: CALL_OW 321
28274: PUSH
28275: LD_INT 2
28277: EQUAL
28278: ST_TO_ADDR
28279: GO 28564
28281: LD_INT 22
28283: DOUBLE
28284: EQUAL
28285: IFTRUE 28295
28287: LD_INT 36
28289: DOUBLE
28290: EQUAL
28291: IFTRUE 28295
28293: GO 28320
28295: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
28296: LD_ADDR_VAR 0 3
28300: PUSH
28301: LD_INT 15
28303: PPUSH
28304: LD_VAR 0 1
28308: PPUSH
28309: CALL_OW 321
28313: PUSH
28314: LD_INT 2
28316: EQUAL
28317: ST_TO_ADDR
28318: GO 28564
28320: LD_INT 30
28322: DOUBLE
28323: EQUAL
28324: IFTRUE 28328
28326: GO 28353
28328: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
28329: LD_ADDR_VAR 0 3
28333: PUSH
28334: LD_INT 20
28336: PPUSH
28337: LD_VAR 0 1
28341: PPUSH
28342: CALL_OW 321
28346: PUSH
28347: LD_INT 2
28349: EQUAL
28350: ST_TO_ADDR
28351: GO 28564
28353: LD_INT 28
28355: DOUBLE
28356: EQUAL
28357: IFTRUE 28367
28359: LD_INT 21
28361: DOUBLE
28362: EQUAL
28363: IFTRUE 28367
28365: GO 28392
28367: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
28368: LD_ADDR_VAR 0 3
28372: PUSH
28373: LD_INT 21
28375: PPUSH
28376: LD_VAR 0 1
28380: PPUSH
28381: CALL_OW 321
28385: PUSH
28386: LD_INT 2
28388: EQUAL
28389: ST_TO_ADDR
28390: GO 28564
28392: LD_INT 16
28394: DOUBLE
28395: EQUAL
28396: IFTRUE 28400
28398: GO 28425
28400: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
28401: LD_ADDR_VAR 0 3
28405: PUSH
28406: LD_INT 84
28408: PPUSH
28409: LD_VAR 0 1
28413: PPUSH
28414: CALL_OW 321
28418: PUSH
28419: LD_INT 2
28421: EQUAL
28422: ST_TO_ADDR
28423: GO 28564
28425: LD_INT 19
28427: DOUBLE
28428: EQUAL
28429: IFTRUE 28439
28431: LD_INT 23
28433: DOUBLE
28434: EQUAL
28435: IFTRUE 28439
28437: GO 28464
28439: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
28440: LD_ADDR_VAR 0 3
28444: PUSH
28445: LD_INT 83
28447: PPUSH
28448: LD_VAR 0 1
28452: PPUSH
28453: CALL_OW 321
28457: PUSH
28458: LD_INT 2
28460: EQUAL
28461: ST_TO_ADDR
28462: GO 28564
28464: LD_INT 17
28466: DOUBLE
28467: EQUAL
28468: IFTRUE 28472
28470: GO 28497
28472: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
28473: LD_ADDR_VAR 0 3
28477: PUSH
28478: LD_INT 39
28480: PPUSH
28481: LD_VAR 0 1
28485: PPUSH
28486: CALL_OW 321
28490: PUSH
28491: LD_INT 2
28493: EQUAL
28494: ST_TO_ADDR
28495: GO 28564
28497: LD_INT 18
28499: DOUBLE
28500: EQUAL
28501: IFTRUE 28505
28503: GO 28530
28505: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
28506: LD_ADDR_VAR 0 3
28510: PUSH
28511: LD_INT 40
28513: PPUSH
28514: LD_VAR 0 1
28518: PPUSH
28519: CALL_OW 321
28523: PUSH
28524: LD_INT 2
28526: EQUAL
28527: ST_TO_ADDR
28528: GO 28564
28530: LD_INT 27
28532: DOUBLE
28533: EQUAL
28534: IFTRUE 28538
28536: GO 28563
28538: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
28539: LD_ADDR_VAR 0 3
28543: PUSH
28544: LD_INT 35
28546: PPUSH
28547: LD_VAR 0 1
28551: PPUSH
28552: CALL_OW 321
28556: PUSH
28557: LD_INT 2
28559: EQUAL
28560: ST_TO_ADDR
28561: GO 28564
28563: POP
// end ;
28564: LD_VAR 0 3
28568: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
28569: LD_INT 0
28571: PPUSH
28572: PPUSH
28573: PPUSH
28574: PPUSH
28575: PPUSH
28576: PPUSH
28577: PPUSH
28578: PPUSH
28579: PPUSH
28580: PPUSH
28581: PPUSH
// result := false ;
28582: LD_ADDR_VAR 0 6
28586: PUSH
28587: LD_INT 0
28589: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28590: LD_VAR 0 1
28594: NOT
28595: PUSH
28596: LD_VAR 0 1
28600: PPUSH
28601: CALL_OW 266
28605: PUSH
28606: LD_INT 0
28608: PUSH
28609: LD_INT 1
28611: PUSH
28612: EMPTY
28613: LIST
28614: LIST
28615: IN
28616: NOT
28617: OR
28618: PUSH
28619: LD_VAR 0 2
28623: NOT
28624: OR
28625: PUSH
28626: LD_VAR 0 5
28630: PUSH
28631: LD_INT 0
28633: PUSH
28634: LD_INT 1
28636: PUSH
28637: LD_INT 2
28639: PUSH
28640: LD_INT 3
28642: PUSH
28643: LD_INT 4
28645: PUSH
28646: LD_INT 5
28648: PUSH
28649: EMPTY
28650: LIST
28651: LIST
28652: LIST
28653: LIST
28654: LIST
28655: LIST
28656: IN
28657: NOT
28658: OR
28659: PUSH
28660: LD_VAR 0 3
28664: PPUSH
28665: LD_VAR 0 4
28669: PPUSH
28670: CALL_OW 488
28674: NOT
28675: OR
28676: IFFALSE 28680
// exit ;
28678: GO 29416
// side := GetSide ( depot ) ;
28680: LD_ADDR_VAR 0 9
28684: PUSH
28685: LD_VAR 0 1
28689: PPUSH
28690: CALL_OW 255
28694: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
28695: LD_VAR 0 9
28699: PPUSH
28700: LD_VAR 0 2
28704: PPUSH
28705: CALL 28193 0 2
28709: NOT
28710: IFFALSE 28714
// exit ;
28712: GO 29416
// pom := GetBase ( depot ) ;
28714: LD_ADDR_VAR 0 10
28718: PUSH
28719: LD_VAR 0 1
28723: PPUSH
28724: CALL_OW 274
28728: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28729: LD_ADDR_VAR 0 11
28733: PUSH
28734: LD_VAR 0 2
28738: PPUSH
28739: LD_VAR 0 1
28743: PPUSH
28744: CALL_OW 248
28748: PPUSH
28749: CALL_OW 450
28753: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28754: LD_VAR 0 10
28758: PPUSH
28759: LD_INT 1
28761: PPUSH
28762: CALL_OW 275
28766: PUSH
28767: LD_VAR 0 11
28771: PUSH
28772: LD_INT 1
28774: ARRAY
28775: GREATEREQUAL
28776: PUSH
28777: LD_VAR 0 10
28781: PPUSH
28782: LD_INT 2
28784: PPUSH
28785: CALL_OW 275
28789: PUSH
28790: LD_VAR 0 11
28794: PUSH
28795: LD_INT 2
28797: ARRAY
28798: GREATEREQUAL
28799: AND
28800: PUSH
28801: LD_VAR 0 10
28805: PPUSH
28806: LD_INT 3
28808: PPUSH
28809: CALL_OW 275
28813: PUSH
28814: LD_VAR 0 11
28818: PUSH
28819: LD_INT 3
28821: ARRAY
28822: GREATEREQUAL
28823: AND
28824: NOT
28825: IFFALSE 28829
// exit ;
28827: GO 29416
// if GetBType ( depot ) = b_depot then
28829: LD_VAR 0 1
28833: PPUSH
28834: CALL_OW 266
28838: PUSH
28839: LD_INT 0
28841: EQUAL
28842: IFFALSE 28854
// dist := 28 else
28844: LD_ADDR_VAR 0 14
28848: PUSH
28849: LD_INT 28
28851: ST_TO_ADDR
28852: GO 28862
// dist := 36 ;
28854: LD_ADDR_VAR 0 14
28858: PUSH
28859: LD_INT 36
28861: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28862: LD_VAR 0 1
28866: PPUSH
28867: LD_VAR 0 3
28871: PPUSH
28872: LD_VAR 0 4
28876: PPUSH
28877: CALL_OW 297
28881: PUSH
28882: LD_VAR 0 14
28886: GREATER
28887: IFFALSE 28891
// exit ;
28889: GO 29416
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28891: LD_ADDR_VAR 0 12
28895: PUSH
28896: LD_VAR 0 2
28900: PPUSH
28901: LD_VAR 0 3
28905: PPUSH
28906: LD_VAR 0 4
28910: PPUSH
28911: LD_VAR 0 5
28915: PPUSH
28916: LD_VAR 0 1
28920: PPUSH
28921: CALL_OW 248
28925: PPUSH
28926: LD_INT 0
28928: PPUSH
28929: CALL 29421 0 6
28933: ST_TO_ADDR
// if not hexes then
28934: LD_VAR 0 12
28938: NOT
28939: IFFALSE 28943
// exit ;
28941: GO 29416
// hex := GetHexInfo ( x , y ) ;
28943: LD_ADDR_VAR 0 15
28947: PUSH
28948: LD_VAR 0 3
28952: PPUSH
28953: LD_VAR 0 4
28957: PPUSH
28958: CALL_OW 546
28962: ST_TO_ADDR
// if hex [ 1 ] then
28963: LD_VAR 0 15
28967: PUSH
28968: LD_INT 1
28970: ARRAY
28971: IFFALSE 28975
// exit ;
28973: GO 29416
// height := hex [ 2 ] ;
28975: LD_ADDR_VAR 0 13
28979: PUSH
28980: LD_VAR 0 15
28984: PUSH
28985: LD_INT 2
28987: ARRAY
28988: ST_TO_ADDR
// for i = 1 to hexes do
28989: LD_ADDR_VAR 0 7
28993: PUSH
28994: DOUBLE
28995: LD_INT 1
28997: DEC
28998: ST_TO_ADDR
28999: LD_VAR 0 12
29003: PUSH
29004: FOR_TO
29005: IFFALSE 29335
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29007: LD_VAR 0 12
29011: PUSH
29012: LD_VAR 0 7
29016: ARRAY
29017: PUSH
29018: LD_INT 1
29020: ARRAY
29021: PPUSH
29022: LD_VAR 0 12
29026: PUSH
29027: LD_VAR 0 7
29031: ARRAY
29032: PUSH
29033: LD_INT 2
29035: ARRAY
29036: PPUSH
29037: CALL_OW 488
29041: NOT
29042: PUSH
29043: LD_VAR 0 12
29047: PUSH
29048: LD_VAR 0 7
29052: ARRAY
29053: PUSH
29054: LD_INT 1
29056: ARRAY
29057: PPUSH
29058: LD_VAR 0 12
29062: PUSH
29063: LD_VAR 0 7
29067: ARRAY
29068: PUSH
29069: LD_INT 2
29071: ARRAY
29072: PPUSH
29073: CALL_OW 428
29077: PUSH
29078: LD_INT 0
29080: GREATER
29081: OR
29082: PUSH
29083: LD_VAR 0 12
29087: PUSH
29088: LD_VAR 0 7
29092: ARRAY
29093: PUSH
29094: LD_INT 1
29096: ARRAY
29097: PPUSH
29098: LD_VAR 0 12
29102: PUSH
29103: LD_VAR 0 7
29107: ARRAY
29108: PUSH
29109: LD_INT 2
29111: ARRAY
29112: PPUSH
29113: CALL_OW 351
29117: OR
29118: IFFALSE 29124
// exit ;
29120: POP
29121: POP
29122: GO 29416
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29124: LD_ADDR_VAR 0 8
29128: PUSH
29129: LD_VAR 0 12
29133: PUSH
29134: LD_VAR 0 7
29138: ARRAY
29139: PUSH
29140: LD_INT 1
29142: ARRAY
29143: PPUSH
29144: LD_VAR 0 12
29148: PUSH
29149: LD_VAR 0 7
29153: ARRAY
29154: PUSH
29155: LD_INT 2
29157: ARRAY
29158: PPUSH
29159: CALL_OW 546
29163: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29164: LD_VAR 0 8
29168: PUSH
29169: LD_INT 1
29171: ARRAY
29172: PUSH
29173: LD_VAR 0 8
29177: PUSH
29178: LD_INT 2
29180: ARRAY
29181: PUSH
29182: LD_VAR 0 13
29186: PUSH
29187: LD_INT 2
29189: PLUS
29190: GREATER
29191: OR
29192: PUSH
29193: LD_VAR 0 8
29197: PUSH
29198: LD_INT 2
29200: ARRAY
29201: PUSH
29202: LD_VAR 0 13
29206: PUSH
29207: LD_INT 2
29209: MINUS
29210: LESS
29211: OR
29212: PUSH
29213: LD_VAR 0 8
29217: PUSH
29218: LD_INT 3
29220: ARRAY
29221: PUSH
29222: LD_INT 0
29224: PUSH
29225: LD_INT 8
29227: PUSH
29228: LD_INT 9
29230: PUSH
29231: LD_INT 10
29233: PUSH
29234: LD_INT 11
29236: PUSH
29237: LD_INT 12
29239: PUSH
29240: LD_INT 13
29242: PUSH
29243: LD_INT 16
29245: PUSH
29246: LD_INT 17
29248: PUSH
29249: LD_INT 18
29251: PUSH
29252: LD_INT 19
29254: PUSH
29255: LD_INT 20
29257: PUSH
29258: LD_INT 21
29260: PUSH
29261: EMPTY
29262: LIST
29263: LIST
29264: LIST
29265: LIST
29266: LIST
29267: LIST
29268: LIST
29269: LIST
29270: LIST
29271: LIST
29272: LIST
29273: LIST
29274: LIST
29275: IN
29276: NOT
29277: OR
29278: PUSH
29279: LD_VAR 0 8
29283: PUSH
29284: LD_INT 5
29286: ARRAY
29287: NOT
29288: OR
29289: PUSH
29290: LD_VAR 0 8
29294: PUSH
29295: LD_INT 6
29297: ARRAY
29298: PUSH
29299: LD_INT 1
29301: PUSH
29302: LD_INT 2
29304: PUSH
29305: LD_INT 7
29307: PUSH
29308: LD_INT 9
29310: PUSH
29311: LD_INT 10
29313: PUSH
29314: LD_INT 11
29316: PUSH
29317: EMPTY
29318: LIST
29319: LIST
29320: LIST
29321: LIST
29322: LIST
29323: LIST
29324: IN
29325: NOT
29326: OR
29327: IFFALSE 29333
// exit ;
29329: POP
29330: POP
29331: GO 29416
// end ;
29333: GO 29004
29335: POP
29336: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29337: LD_VAR 0 9
29341: PPUSH
29342: LD_VAR 0 3
29346: PPUSH
29347: LD_VAR 0 4
29351: PPUSH
29352: LD_INT 20
29354: PPUSH
29355: CALL 21359 0 4
29359: PUSH
29360: LD_INT 4
29362: ARRAY
29363: IFFALSE 29367
// exit ;
29365: GO 29416
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29367: LD_VAR 0 2
29371: PUSH
29372: LD_INT 29
29374: PUSH
29375: LD_INT 30
29377: PUSH
29378: EMPTY
29379: LIST
29380: LIST
29381: IN
29382: PUSH
29383: LD_VAR 0 3
29387: PPUSH
29388: LD_VAR 0 4
29392: PPUSH
29393: LD_VAR 0 9
29397: PPUSH
29398: CALL_OW 440
29402: NOT
29403: AND
29404: IFFALSE 29408
// exit ;
29406: GO 29416
// result := true ;
29408: LD_ADDR_VAR 0 6
29412: PUSH
29413: LD_INT 1
29415: ST_TO_ADDR
// end ;
29416: LD_VAR 0 6
29420: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
29421: LD_INT 0
29423: PPUSH
29424: PPUSH
29425: PPUSH
29426: PPUSH
29427: PPUSH
29428: PPUSH
29429: PPUSH
29430: PPUSH
29431: PPUSH
29432: PPUSH
29433: PPUSH
29434: PPUSH
29435: PPUSH
29436: PPUSH
29437: PPUSH
29438: PPUSH
29439: PPUSH
29440: PPUSH
29441: PPUSH
29442: PPUSH
29443: PPUSH
29444: PPUSH
29445: PPUSH
29446: PPUSH
29447: PPUSH
29448: PPUSH
29449: PPUSH
29450: PPUSH
29451: PPUSH
29452: PPUSH
29453: PPUSH
29454: PPUSH
29455: PPUSH
29456: PPUSH
29457: PPUSH
29458: PPUSH
29459: PPUSH
29460: PPUSH
29461: PPUSH
29462: PPUSH
29463: PPUSH
29464: PPUSH
29465: PPUSH
29466: PPUSH
29467: PPUSH
29468: PPUSH
29469: PPUSH
29470: PPUSH
29471: PPUSH
29472: PPUSH
29473: PPUSH
29474: PPUSH
29475: PPUSH
29476: PPUSH
29477: PPUSH
29478: PPUSH
29479: PPUSH
29480: PPUSH
// result = [ ] ;
29481: LD_ADDR_VAR 0 7
29485: PUSH
29486: EMPTY
29487: ST_TO_ADDR
// temp_list = [ ] ;
29488: LD_ADDR_VAR 0 9
29492: PUSH
29493: EMPTY
29494: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29495: LD_VAR 0 4
29499: PUSH
29500: LD_INT 0
29502: PUSH
29503: LD_INT 1
29505: PUSH
29506: LD_INT 2
29508: PUSH
29509: LD_INT 3
29511: PUSH
29512: LD_INT 4
29514: PUSH
29515: LD_INT 5
29517: PUSH
29518: EMPTY
29519: LIST
29520: LIST
29521: LIST
29522: LIST
29523: LIST
29524: LIST
29525: IN
29526: NOT
29527: PUSH
29528: LD_VAR 0 1
29532: PUSH
29533: LD_INT 0
29535: PUSH
29536: LD_INT 1
29538: PUSH
29539: EMPTY
29540: LIST
29541: LIST
29542: IN
29543: PUSH
29544: LD_VAR 0 5
29548: PUSH
29549: LD_INT 1
29551: PUSH
29552: LD_INT 2
29554: PUSH
29555: LD_INT 3
29557: PUSH
29558: EMPTY
29559: LIST
29560: LIST
29561: LIST
29562: IN
29563: NOT
29564: AND
29565: OR
29566: IFFALSE 29570
// exit ;
29568: GO 47961
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29570: LD_VAR 0 1
29574: PUSH
29575: LD_INT 6
29577: PUSH
29578: LD_INT 7
29580: PUSH
29581: LD_INT 8
29583: PUSH
29584: LD_INT 13
29586: PUSH
29587: LD_INT 12
29589: PUSH
29590: LD_INT 15
29592: PUSH
29593: LD_INT 11
29595: PUSH
29596: LD_INT 14
29598: PUSH
29599: LD_INT 10
29601: PUSH
29602: EMPTY
29603: LIST
29604: LIST
29605: LIST
29606: LIST
29607: LIST
29608: LIST
29609: LIST
29610: LIST
29611: LIST
29612: IN
29613: IFFALSE 29623
// btype = b_lab ;
29615: LD_ADDR_VAR 0 1
29619: PUSH
29620: LD_INT 6
29622: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29623: LD_VAR 0 6
29627: PUSH
29628: LD_INT 0
29630: PUSH
29631: LD_INT 1
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: LIST
29641: IN
29642: NOT
29643: PUSH
29644: LD_VAR 0 1
29648: PUSH
29649: LD_INT 0
29651: PUSH
29652: LD_INT 1
29654: PUSH
29655: LD_INT 2
29657: PUSH
29658: LD_INT 3
29660: PUSH
29661: LD_INT 6
29663: PUSH
29664: LD_INT 36
29666: PUSH
29667: LD_INT 4
29669: PUSH
29670: LD_INT 5
29672: PUSH
29673: LD_INT 31
29675: PUSH
29676: LD_INT 32
29678: PUSH
29679: LD_INT 33
29681: PUSH
29682: EMPTY
29683: LIST
29684: LIST
29685: LIST
29686: LIST
29687: LIST
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: IN
29695: NOT
29696: PUSH
29697: LD_VAR 0 6
29701: PUSH
29702: LD_INT 1
29704: EQUAL
29705: AND
29706: OR
29707: PUSH
29708: LD_VAR 0 1
29712: PUSH
29713: LD_INT 2
29715: PUSH
29716: LD_INT 3
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: IN
29723: NOT
29724: PUSH
29725: LD_VAR 0 6
29729: PUSH
29730: LD_INT 2
29732: EQUAL
29733: AND
29734: OR
29735: IFFALSE 29745
// mode = 0 ;
29737: LD_ADDR_VAR 0 6
29741: PUSH
29742: LD_INT 0
29744: ST_TO_ADDR
// case mode of 0 :
29745: LD_VAR 0 6
29749: PUSH
29750: LD_INT 0
29752: DOUBLE
29753: EQUAL
29754: IFTRUE 29758
29756: GO 41211
29758: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29759: LD_ADDR_VAR 0 11
29763: PUSH
29764: LD_INT 0
29766: PUSH
29767: LD_INT 0
29769: PUSH
29770: EMPTY
29771: LIST
29772: LIST
29773: PUSH
29774: LD_INT 0
29776: PUSH
29777: LD_INT 1
29779: NEG
29780: PUSH
29781: EMPTY
29782: LIST
29783: LIST
29784: PUSH
29785: LD_INT 1
29787: PUSH
29788: LD_INT 0
29790: PUSH
29791: EMPTY
29792: LIST
29793: LIST
29794: PUSH
29795: LD_INT 1
29797: PUSH
29798: LD_INT 1
29800: PUSH
29801: EMPTY
29802: LIST
29803: LIST
29804: PUSH
29805: LD_INT 0
29807: PUSH
29808: LD_INT 1
29810: PUSH
29811: EMPTY
29812: LIST
29813: LIST
29814: PUSH
29815: LD_INT 1
29817: NEG
29818: PUSH
29819: LD_INT 0
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: PUSH
29826: LD_INT 1
29828: NEG
29829: PUSH
29830: LD_INT 1
29832: NEG
29833: PUSH
29834: EMPTY
29835: LIST
29836: LIST
29837: PUSH
29838: LD_INT 1
29840: NEG
29841: PUSH
29842: LD_INT 2
29844: NEG
29845: PUSH
29846: EMPTY
29847: LIST
29848: LIST
29849: PUSH
29850: LD_INT 0
29852: PUSH
29853: LD_INT 2
29855: NEG
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 1
29863: PUSH
29864: LD_INT 1
29866: NEG
29867: PUSH
29868: EMPTY
29869: LIST
29870: LIST
29871: PUSH
29872: LD_INT 1
29874: PUSH
29875: LD_INT 2
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 0
29884: PUSH
29885: LD_INT 2
29887: PUSH
29888: EMPTY
29889: LIST
29890: LIST
29891: PUSH
29892: LD_INT 1
29894: NEG
29895: PUSH
29896: LD_INT 1
29898: PUSH
29899: EMPTY
29900: LIST
29901: LIST
29902: PUSH
29903: LD_INT 1
29905: PUSH
29906: LD_INT 3
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PUSH
29913: LD_INT 0
29915: PUSH
29916: LD_INT 3
29918: PUSH
29919: EMPTY
29920: LIST
29921: LIST
29922: PUSH
29923: LD_INT 1
29925: NEG
29926: PUSH
29927: LD_INT 2
29929: PUSH
29930: EMPTY
29931: LIST
29932: LIST
29933: PUSH
29934: EMPTY
29935: LIST
29936: LIST
29937: LIST
29938: LIST
29939: LIST
29940: LIST
29941: LIST
29942: LIST
29943: LIST
29944: LIST
29945: LIST
29946: LIST
29947: LIST
29948: LIST
29949: LIST
29950: LIST
29951: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
29952: LD_ADDR_VAR 0 12
29956: PUSH
29957: LD_INT 0
29959: PUSH
29960: LD_INT 0
29962: PUSH
29963: EMPTY
29964: LIST
29965: LIST
29966: PUSH
29967: LD_INT 0
29969: PUSH
29970: LD_INT 1
29972: NEG
29973: PUSH
29974: EMPTY
29975: LIST
29976: LIST
29977: PUSH
29978: LD_INT 1
29980: PUSH
29981: LD_INT 0
29983: PUSH
29984: EMPTY
29985: LIST
29986: LIST
29987: PUSH
29988: LD_INT 1
29990: PUSH
29991: LD_INT 1
29993: PUSH
29994: EMPTY
29995: LIST
29996: LIST
29997: PUSH
29998: LD_INT 0
30000: PUSH
30001: LD_INT 1
30003: PUSH
30004: EMPTY
30005: LIST
30006: LIST
30007: PUSH
30008: LD_INT 1
30010: NEG
30011: PUSH
30012: LD_INT 0
30014: PUSH
30015: EMPTY
30016: LIST
30017: LIST
30018: PUSH
30019: LD_INT 1
30021: NEG
30022: PUSH
30023: LD_INT 1
30025: NEG
30026: PUSH
30027: EMPTY
30028: LIST
30029: LIST
30030: PUSH
30031: LD_INT 1
30033: PUSH
30034: LD_INT 1
30036: NEG
30037: PUSH
30038: EMPTY
30039: LIST
30040: LIST
30041: PUSH
30042: LD_INT 2
30044: PUSH
30045: LD_INT 0
30047: PUSH
30048: EMPTY
30049: LIST
30050: LIST
30051: PUSH
30052: LD_INT 2
30054: PUSH
30055: LD_INT 1
30057: PUSH
30058: EMPTY
30059: LIST
30060: LIST
30061: PUSH
30062: LD_INT 1
30064: NEG
30065: PUSH
30066: LD_INT 1
30068: PUSH
30069: EMPTY
30070: LIST
30071: LIST
30072: PUSH
30073: LD_INT 2
30075: NEG
30076: PUSH
30077: LD_INT 0
30079: PUSH
30080: EMPTY
30081: LIST
30082: LIST
30083: PUSH
30084: LD_INT 2
30086: NEG
30087: PUSH
30088: LD_INT 1
30090: NEG
30091: PUSH
30092: EMPTY
30093: LIST
30094: LIST
30095: PUSH
30096: LD_INT 2
30098: NEG
30099: PUSH
30100: LD_INT 1
30102: PUSH
30103: EMPTY
30104: LIST
30105: LIST
30106: PUSH
30107: LD_INT 3
30109: NEG
30110: PUSH
30111: LD_INT 0
30113: PUSH
30114: EMPTY
30115: LIST
30116: LIST
30117: PUSH
30118: LD_INT 3
30120: NEG
30121: PUSH
30122: LD_INT 1
30124: NEG
30125: PUSH
30126: EMPTY
30127: LIST
30128: LIST
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: LIST
30134: LIST
30135: LIST
30136: LIST
30137: LIST
30138: LIST
30139: LIST
30140: LIST
30141: LIST
30142: LIST
30143: LIST
30144: LIST
30145: LIST
30146: LIST
30147: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30148: LD_ADDR_VAR 0 13
30152: PUSH
30153: LD_INT 0
30155: PUSH
30156: LD_INT 0
30158: PUSH
30159: EMPTY
30160: LIST
30161: LIST
30162: PUSH
30163: LD_INT 0
30165: PUSH
30166: LD_INT 1
30168: NEG
30169: PUSH
30170: EMPTY
30171: LIST
30172: LIST
30173: PUSH
30174: LD_INT 1
30176: PUSH
30177: LD_INT 0
30179: PUSH
30180: EMPTY
30181: LIST
30182: LIST
30183: PUSH
30184: LD_INT 1
30186: PUSH
30187: LD_INT 1
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 0
30196: PUSH
30197: LD_INT 1
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: NEG
30207: PUSH
30208: LD_INT 0
30210: PUSH
30211: EMPTY
30212: LIST
30213: LIST
30214: PUSH
30215: LD_INT 1
30217: NEG
30218: PUSH
30219: LD_INT 1
30221: NEG
30222: PUSH
30223: EMPTY
30224: LIST
30225: LIST
30226: PUSH
30227: LD_INT 1
30229: NEG
30230: PUSH
30231: LD_INT 2
30233: NEG
30234: PUSH
30235: EMPTY
30236: LIST
30237: LIST
30238: PUSH
30239: LD_INT 2
30241: PUSH
30242: LD_INT 1
30244: PUSH
30245: EMPTY
30246: LIST
30247: LIST
30248: PUSH
30249: LD_INT 2
30251: PUSH
30252: LD_INT 2
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 1
30261: PUSH
30262: LD_INT 2
30264: PUSH
30265: EMPTY
30266: LIST
30267: LIST
30268: PUSH
30269: LD_INT 2
30271: NEG
30272: PUSH
30273: LD_INT 1
30275: NEG
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 2
30283: NEG
30284: PUSH
30285: LD_INT 2
30287: NEG
30288: PUSH
30289: EMPTY
30290: LIST
30291: LIST
30292: PUSH
30293: LD_INT 2
30295: NEG
30296: PUSH
30297: LD_INT 3
30299: NEG
30300: PUSH
30301: EMPTY
30302: LIST
30303: LIST
30304: PUSH
30305: LD_INT 3
30307: NEG
30308: PUSH
30309: LD_INT 2
30311: NEG
30312: PUSH
30313: EMPTY
30314: LIST
30315: LIST
30316: PUSH
30317: LD_INT 3
30319: NEG
30320: PUSH
30321: LD_INT 3
30323: NEG
30324: PUSH
30325: EMPTY
30326: LIST
30327: LIST
30328: PUSH
30329: EMPTY
30330: LIST
30331: LIST
30332: LIST
30333: LIST
30334: LIST
30335: LIST
30336: LIST
30337: LIST
30338: LIST
30339: LIST
30340: LIST
30341: LIST
30342: LIST
30343: LIST
30344: LIST
30345: LIST
30346: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30347: LD_ADDR_VAR 0 14
30351: PUSH
30352: LD_INT 0
30354: PUSH
30355: LD_INT 0
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 0
30364: PUSH
30365: LD_INT 1
30367: NEG
30368: PUSH
30369: EMPTY
30370: LIST
30371: LIST
30372: PUSH
30373: LD_INT 1
30375: PUSH
30376: LD_INT 0
30378: PUSH
30379: EMPTY
30380: LIST
30381: LIST
30382: PUSH
30383: LD_INT 1
30385: PUSH
30386: LD_INT 1
30388: PUSH
30389: EMPTY
30390: LIST
30391: LIST
30392: PUSH
30393: LD_INT 0
30395: PUSH
30396: LD_INT 1
30398: PUSH
30399: EMPTY
30400: LIST
30401: LIST
30402: PUSH
30403: LD_INT 1
30405: NEG
30406: PUSH
30407: LD_INT 0
30409: PUSH
30410: EMPTY
30411: LIST
30412: LIST
30413: PUSH
30414: LD_INT 1
30416: NEG
30417: PUSH
30418: LD_INT 1
30420: NEG
30421: PUSH
30422: EMPTY
30423: LIST
30424: LIST
30425: PUSH
30426: LD_INT 1
30428: NEG
30429: PUSH
30430: LD_INT 2
30432: NEG
30433: PUSH
30434: EMPTY
30435: LIST
30436: LIST
30437: PUSH
30438: LD_INT 0
30440: PUSH
30441: LD_INT 2
30443: NEG
30444: PUSH
30445: EMPTY
30446: LIST
30447: LIST
30448: PUSH
30449: LD_INT 1
30451: PUSH
30452: LD_INT 1
30454: NEG
30455: PUSH
30456: EMPTY
30457: LIST
30458: LIST
30459: PUSH
30460: LD_INT 1
30462: PUSH
30463: LD_INT 2
30465: PUSH
30466: EMPTY
30467: LIST
30468: LIST
30469: PUSH
30470: LD_INT 0
30472: PUSH
30473: LD_INT 2
30475: PUSH
30476: EMPTY
30477: LIST
30478: LIST
30479: PUSH
30480: LD_INT 1
30482: NEG
30483: PUSH
30484: LD_INT 1
30486: PUSH
30487: EMPTY
30488: LIST
30489: LIST
30490: PUSH
30491: LD_INT 1
30493: NEG
30494: PUSH
30495: LD_INT 3
30497: NEG
30498: PUSH
30499: EMPTY
30500: LIST
30501: LIST
30502: PUSH
30503: LD_INT 0
30505: PUSH
30506: LD_INT 3
30508: NEG
30509: PUSH
30510: EMPTY
30511: LIST
30512: LIST
30513: PUSH
30514: LD_INT 1
30516: PUSH
30517: LD_INT 2
30519: NEG
30520: PUSH
30521: EMPTY
30522: LIST
30523: LIST
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: LIST
30529: LIST
30530: LIST
30531: LIST
30532: LIST
30533: LIST
30534: LIST
30535: LIST
30536: LIST
30537: LIST
30538: LIST
30539: LIST
30540: LIST
30541: LIST
30542: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30543: LD_ADDR_VAR 0 15
30547: PUSH
30548: LD_INT 0
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: EMPTY
30555: LIST
30556: LIST
30557: PUSH
30558: LD_INT 0
30560: PUSH
30561: LD_INT 1
30563: NEG
30564: PUSH
30565: EMPTY
30566: LIST
30567: LIST
30568: PUSH
30569: LD_INT 1
30571: PUSH
30572: LD_INT 0
30574: PUSH
30575: EMPTY
30576: LIST
30577: LIST
30578: PUSH
30579: LD_INT 1
30581: PUSH
30582: LD_INT 1
30584: PUSH
30585: EMPTY
30586: LIST
30587: LIST
30588: PUSH
30589: LD_INT 0
30591: PUSH
30592: LD_INT 1
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PUSH
30599: LD_INT 1
30601: NEG
30602: PUSH
30603: LD_INT 0
30605: PUSH
30606: EMPTY
30607: LIST
30608: LIST
30609: PUSH
30610: LD_INT 1
30612: NEG
30613: PUSH
30614: LD_INT 1
30616: NEG
30617: PUSH
30618: EMPTY
30619: LIST
30620: LIST
30621: PUSH
30622: LD_INT 1
30624: PUSH
30625: LD_INT 1
30627: NEG
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 2
30635: PUSH
30636: LD_INT 0
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: LD_INT 2
30645: PUSH
30646: LD_INT 1
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: LD_INT 1
30655: NEG
30656: PUSH
30657: LD_INT 1
30659: PUSH
30660: EMPTY
30661: LIST
30662: LIST
30663: PUSH
30664: LD_INT 2
30666: NEG
30667: PUSH
30668: LD_INT 0
30670: PUSH
30671: EMPTY
30672: LIST
30673: LIST
30674: PUSH
30675: LD_INT 2
30677: NEG
30678: PUSH
30679: LD_INT 1
30681: NEG
30682: PUSH
30683: EMPTY
30684: LIST
30685: LIST
30686: PUSH
30687: LD_INT 2
30689: PUSH
30690: LD_INT 1
30692: NEG
30693: PUSH
30694: EMPTY
30695: LIST
30696: LIST
30697: PUSH
30698: LD_INT 3
30700: PUSH
30701: LD_INT 0
30703: PUSH
30704: EMPTY
30705: LIST
30706: LIST
30707: PUSH
30708: LD_INT 3
30710: PUSH
30711: LD_INT 1
30713: PUSH
30714: EMPTY
30715: LIST
30716: LIST
30717: PUSH
30718: EMPTY
30719: LIST
30720: LIST
30721: LIST
30722: LIST
30723: LIST
30724: LIST
30725: LIST
30726: LIST
30727: LIST
30728: LIST
30729: LIST
30730: LIST
30731: LIST
30732: LIST
30733: LIST
30734: LIST
30735: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30736: LD_ADDR_VAR 0 16
30740: PUSH
30741: LD_INT 0
30743: PUSH
30744: LD_INT 0
30746: PUSH
30747: EMPTY
30748: LIST
30749: LIST
30750: PUSH
30751: LD_INT 0
30753: PUSH
30754: LD_INT 1
30756: NEG
30757: PUSH
30758: EMPTY
30759: LIST
30760: LIST
30761: PUSH
30762: LD_INT 1
30764: PUSH
30765: LD_INT 0
30767: PUSH
30768: EMPTY
30769: LIST
30770: LIST
30771: PUSH
30772: LD_INT 1
30774: PUSH
30775: LD_INT 1
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: PUSH
30782: LD_INT 0
30784: PUSH
30785: LD_INT 1
30787: PUSH
30788: EMPTY
30789: LIST
30790: LIST
30791: PUSH
30792: LD_INT 1
30794: NEG
30795: PUSH
30796: LD_INT 0
30798: PUSH
30799: EMPTY
30800: LIST
30801: LIST
30802: PUSH
30803: LD_INT 1
30805: NEG
30806: PUSH
30807: LD_INT 1
30809: NEG
30810: PUSH
30811: EMPTY
30812: LIST
30813: LIST
30814: PUSH
30815: LD_INT 1
30817: NEG
30818: PUSH
30819: LD_INT 2
30821: NEG
30822: PUSH
30823: EMPTY
30824: LIST
30825: LIST
30826: PUSH
30827: LD_INT 2
30829: PUSH
30830: LD_INT 1
30832: PUSH
30833: EMPTY
30834: LIST
30835: LIST
30836: PUSH
30837: LD_INT 2
30839: PUSH
30840: LD_INT 2
30842: PUSH
30843: EMPTY
30844: LIST
30845: LIST
30846: PUSH
30847: LD_INT 1
30849: PUSH
30850: LD_INT 2
30852: PUSH
30853: EMPTY
30854: LIST
30855: LIST
30856: PUSH
30857: LD_INT 2
30859: NEG
30860: PUSH
30861: LD_INT 1
30863: NEG
30864: PUSH
30865: EMPTY
30866: LIST
30867: LIST
30868: PUSH
30869: LD_INT 2
30871: NEG
30872: PUSH
30873: LD_INT 2
30875: NEG
30876: PUSH
30877: EMPTY
30878: LIST
30879: LIST
30880: PUSH
30881: LD_INT 3
30883: PUSH
30884: LD_INT 2
30886: PUSH
30887: EMPTY
30888: LIST
30889: LIST
30890: PUSH
30891: LD_INT 3
30893: PUSH
30894: LD_INT 3
30896: PUSH
30897: EMPTY
30898: LIST
30899: LIST
30900: PUSH
30901: LD_INT 2
30903: PUSH
30904: LD_INT 3
30906: PUSH
30907: EMPTY
30908: LIST
30909: LIST
30910: PUSH
30911: EMPTY
30912: LIST
30913: LIST
30914: LIST
30915: LIST
30916: LIST
30917: LIST
30918: LIST
30919: LIST
30920: LIST
30921: LIST
30922: LIST
30923: LIST
30924: LIST
30925: LIST
30926: LIST
30927: LIST
30928: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30929: LD_ADDR_VAR 0 17
30933: PUSH
30934: LD_INT 0
30936: PUSH
30937: LD_INT 0
30939: PUSH
30940: EMPTY
30941: LIST
30942: LIST
30943: PUSH
30944: LD_INT 0
30946: PUSH
30947: LD_INT 1
30949: NEG
30950: PUSH
30951: EMPTY
30952: LIST
30953: LIST
30954: PUSH
30955: LD_INT 1
30957: PUSH
30958: LD_INT 0
30960: PUSH
30961: EMPTY
30962: LIST
30963: LIST
30964: PUSH
30965: LD_INT 1
30967: PUSH
30968: LD_INT 1
30970: PUSH
30971: EMPTY
30972: LIST
30973: LIST
30974: PUSH
30975: LD_INT 0
30977: PUSH
30978: LD_INT 1
30980: PUSH
30981: EMPTY
30982: LIST
30983: LIST
30984: PUSH
30985: LD_INT 1
30987: NEG
30988: PUSH
30989: LD_INT 0
30991: PUSH
30992: EMPTY
30993: LIST
30994: LIST
30995: PUSH
30996: LD_INT 1
30998: NEG
30999: PUSH
31000: LD_INT 1
31002: NEG
31003: PUSH
31004: EMPTY
31005: LIST
31006: LIST
31007: PUSH
31008: LD_INT 1
31010: NEG
31011: PUSH
31012: LD_INT 2
31014: NEG
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PUSH
31020: LD_INT 0
31022: PUSH
31023: LD_INT 2
31025: NEG
31026: PUSH
31027: EMPTY
31028: LIST
31029: LIST
31030: PUSH
31031: LD_INT 1
31033: PUSH
31034: LD_INT 1
31036: NEG
31037: PUSH
31038: EMPTY
31039: LIST
31040: LIST
31041: PUSH
31042: LD_INT 2
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: EMPTY
31049: LIST
31050: LIST
31051: PUSH
31052: LD_INT 2
31054: PUSH
31055: LD_INT 1
31057: PUSH
31058: EMPTY
31059: LIST
31060: LIST
31061: PUSH
31062: LD_INT 2
31064: PUSH
31065: LD_INT 2
31067: PUSH
31068: EMPTY
31069: LIST
31070: LIST
31071: PUSH
31072: LD_INT 1
31074: PUSH
31075: LD_INT 2
31077: PUSH
31078: EMPTY
31079: LIST
31080: LIST
31081: PUSH
31082: LD_INT 0
31084: PUSH
31085: LD_INT 2
31087: PUSH
31088: EMPTY
31089: LIST
31090: LIST
31091: PUSH
31092: LD_INT 1
31094: NEG
31095: PUSH
31096: LD_INT 1
31098: PUSH
31099: EMPTY
31100: LIST
31101: LIST
31102: PUSH
31103: LD_INT 2
31105: NEG
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: EMPTY
31111: LIST
31112: LIST
31113: PUSH
31114: LD_INT 2
31116: NEG
31117: PUSH
31118: LD_INT 1
31120: NEG
31121: PUSH
31122: EMPTY
31123: LIST
31124: LIST
31125: PUSH
31126: LD_INT 2
31128: NEG
31129: PUSH
31130: LD_INT 2
31132: NEG
31133: PUSH
31134: EMPTY
31135: LIST
31136: LIST
31137: PUSH
31138: EMPTY
31139: LIST
31140: LIST
31141: LIST
31142: LIST
31143: LIST
31144: LIST
31145: LIST
31146: LIST
31147: LIST
31148: LIST
31149: LIST
31150: LIST
31151: LIST
31152: LIST
31153: LIST
31154: LIST
31155: LIST
31156: LIST
31157: LIST
31158: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31159: LD_ADDR_VAR 0 18
31163: PUSH
31164: LD_INT 0
31166: PUSH
31167: LD_INT 0
31169: PUSH
31170: EMPTY
31171: LIST
31172: LIST
31173: PUSH
31174: LD_INT 0
31176: PUSH
31177: LD_INT 1
31179: NEG
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 1
31187: PUSH
31188: LD_INT 0
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: PUSH
31198: LD_INT 1
31200: PUSH
31201: EMPTY
31202: LIST
31203: LIST
31204: PUSH
31205: LD_INT 0
31207: PUSH
31208: LD_INT 1
31210: PUSH
31211: EMPTY
31212: LIST
31213: LIST
31214: PUSH
31215: LD_INT 1
31217: NEG
31218: PUSH
31219: LD_INT 0
31221: PUSH
31222: EMPTY
31223: LIST
31224: LIST
31225: PUSH
31226: LD_INT 1
31228: NEG
31229: PUSH
31230: LD_INT 1
31232: NEG
31233: PUSH
31234: EMPTY
31235: LIST
31236: LIST
31237: PUSH
31238: LD_INT 1
31240: NEG
31241: PUSH
31242: LD_INT 2
31244: NEG
31245: PUSH
31246: EMPTY
31247: LIST
31248: LIST
31249: PUSH
31250: LD_INT 0
31252: PUSH
31253: LD_INT 2
31255: NEG
31256: PUSH
31257: EMPTY
31258: LIST
31259: LIST
31260: PUSH
31261: LD_INT 1
31263: PUSH
31264: LD_INT 1
31266: NEG
31267: PUSH
31268: EMPTY
31269: LIST
31270: LIST
31271: PUSH
31272: LD_INT 2
31274: PUSH
31275: LD_INT 0
31277: PUSH
31278: EMPTY
31279: LIST
31280: LIST
31281: PUSH
31282: LD_INT 2
31284: PUSH
31285: LD_INT 1
31287: PUSH
31288: EMPTY
31289: LIST
31290: LIST
31291: PUSH
31292: LD_INT 2
31294: PUSH
31295: LD_INT 2
31297: PUSH
31298: EMPTY
31299: LIST
31300: LIST
31301: PUSH
31302: LD_INT 1
31304: PUSH
31305: LD_INT 2
31307: PUSH
31308: EMPTY
31309: LIST
31310: LIST
31311: PUSH
31312: LD_INT 0
31314: PUSH
31315: LD_INT 2
31317: PUSH
31318: EMPTY
31319: LIST
31320: LIST
31321: PUSH
31322: LD_INT 1
31324: NEG
31325: PUSH
31326: LD_INT 1
31328: PUSH
31329: EMPTY
31330: LIST
31331: LIST
31332: PUSH
31333: LD_INT 2
31335: NEG
31336: PUSH
31337: LD_INT 0
31339: PUSH
31340: EMPTY
31341: LIST
31342: LIST
31343: PUSH
31344: LD_INT 2
31346: NEG
31347: PUSH
31348: LD_INT 1
31350: NEG
31351: PUSH
31352: EMPTY
31353: LIST
31354: LIST
31355: PUSH
31356: LD_INT 2
31358: NEG
31359: PUSH
31360: LD_INT 2
31362: NEG
31363: PUSH
31364: EMPTY
31365: LIST
31366: LIST
31367: PUSH
31368: EMPTY
31369: LIST
31370: LIST
31371: LIST
31372: LIST
31373: LIST
31374: LIST
31375: LIST
31376: LIST
31377: LIST
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: LIST
31384: LIST
31385: LIST
31386: LIST
31387: LIST
31388: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31389: LD_ADDR_VAR 0 19
31393: PUSH
31394: LD_INT 0
31396: PUSH
31397: LD_INT 0
31399: PUSH
31400: EMPTY
31401: LIST
31402: LIST
31403: PUSH
31404: LD_INT 0
31406: PUSH
31407: LD_INT 1
31409: NEG
31410: PUSH
31411: EMPTY
31412: LIST
31413: LIST
31414: PUSH
31415: LD_INT 1
31417: PUSH
31418: LD_INT 0
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 1
31427: PUSH
31428: LD_INT 1
31430: PUSH
31431: EMPTY
31432: LIST
31433: LIST
31434: PUSH
31435: LD_INT 0
31437: PUSH
31438: LD_INT 1
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: PUSH
31445: LD_INT 1
31447: NEG
31448: PUSH
31449: LD_INT 0
31451: PUSH
31452: EMPTY
31453: LIST
31454: LIST
31455: PUSH
31456: LD_INT 1
31458: NEG
31459: PUSH
31460: LD_INT 1
31462: NEG
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 1
31470: NEG
31471: PUSH
31472: LD_INT 2
31474: NEG
31475: PUSH
31476: EMPTY
31477: LIST
31478: LIST
31479: PUSH
31480: LD_INT 0
31482: PUSH
31483: LD_INT 2
31485: NEG
31486: PUSH
31487: EMPTY
31488: LIST
31489: LIST
31490: PUSH
31491: LD_INT 1
31493: PUSH
31494: LD_INT 1
31496: NEG
31497: PUSH
31498: EMPTY
31499: LIST
31500: LIST
31501: PUSH
31502: LD_INT 2
31504: PUSH
31505: LD_INT 0
31507: PUSH
31508: EMPTY
31509: LIST
31510: LIST
31511: PUSH
31512: LD_INT 2
31514: PUSH
31515: LD_INT 1
31517: PUSH
31518: EMPTY
31519: LIST
31520: LIST
31521: PUSH
31522: LD_INT 2
31524: PUSH
31525: LD_INT 2
31527: PUSH
31528: EMPTY
31529: LIST
31530: LIST
31531: PUSH
31532: LD_INT 1
31534: PUSH
31535: LD_INT 2
31537: PUSH
31538: EMPTY
31539: LIST
31540: LIST
31541: PUSH
31542: LD_INT 0
31544: PUSH
31545: LD_INT 2
31547: PUSH
31548: EMPTY
31549: LIST
31550: LIST
31551: PUSH
31552: LD_INT 1
31554: NEG
31555: PUSH
31556: LD_INT 1
31558: PUSH
31559: EMPTY
31560: LIST
31561: LIST
31562: PUSH
31563: LD_INT 2
31565: NEG
31566: PUSH
31567: LD_INT 0
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: LD_INT 2
31576: NEG
31577: PUSH
31578: LD_INT 1
31580: NEG
31581: PUSH
31582: EMPTY
31583: LIST
31584: LIST
31585: PUSH
31586: LD_INT 2
31588: NEG
31589: PUSH
31590: LD_INT 2
31592: NEG
31593: PUSH
31594: EMPTY
31595: LIST
31596: LIST
31597: PUSH
31598: EMPTY
31599: LIST
31600: LIST
31601: LIST
31602: LIST
31603: LIST
31604: LIST
31605: LIST
31606: LIST
31607: LIST
31608: LIST
31609: LIST
31610: LIST
31611: LIST
31612: LIST
31613: LIST
31614: LIST
31615: LIST
31616: LIST
31617: LIST
31618: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31619: LD_ADDR_VAR 0 20
31623: PUSH
31624: LD_INT 0
31626: PUSH
31627: LD_INT 0
31629: PUSH
31630: EMPTY
31631: LIST
31632: LIST
31633: PUSH
31634: LD_INT 0
31636: PUSH
31637: LD_INT 1
31639: NEG
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 1
31647: PUSH
31648: LD_INT 0
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: LD_INT 1
31657: PUSH
31658: LD_INT 1
31660: PUSH
31661: EMPTY
31662: LIST
31663: LIST
31664: PUSH
31665: LD_INT 0
31667: PUSH
31668: LD_INT 1
31670: PUSH
31671: EMPTY
31672: LIST
31673: LIST
31674: PUSH
31675: LD_INT 1
31677: NEG
31678: PUSH
31679: LD_INT 0
31681: PUSH
31682: EMPTY
31683: LIST
31684: LIST
31685: PUSH
31686: LD_INT 1
31688: NEG
31689: PUSH
31690: LD_INT 1
31692: NEG
31693: PUSH
31694: EMPTY
31695: LIST
31696: LIST
31697: PUSH
31698: LD_INT 1
31700: NEG
31701: PUSH
31702: LD_INT 2
31704: NEG
31705: PUSH
31706: EMPTY
31707: LIST
31708: LIST
31709: PUSH
31710: LD_INT 0
31712: PUSH
31713: LD_INT 2
31715: NEG
31716: PUSH
31717: EMPTY
31718: LIST
31719: LIST
31720: PUSH
31721: LD_INT 1
31723: PUSH
31724: LD_INT 1
31726: NEG
31727: PUSH
31728: EMPTY
31729: LIST
31730: LIST
31731: PUSH
31732: LD_INT 2
31734: PUSH
31735: LD_INT 0
31737: PUSH
31738: EMPTY
31739: LIST
31740: LIST
31741: PUSH
31742: LD_INT 2
31744: PUSH
31745: LD_INT 1
31747: PUSH
31748: EMPTY
31749: LIST
31750: LIST
31751: PUSH
31752: LD_INT 2
31754: PUSH
31755: LD_INT 2
31757: PUSH
31758: EMPTY
31759: LIST
31760: LIST
31761: PUSH
31762: LD_INT 1
31764: PUSH
31765: LD_INT 2
31767: PUSH
31768: EMPTY
31769: LIST
31770: LIST
31771: PUSH
31772: LD_INT 0
31774: PUSH
31775: LD_INT 2
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PUSH
31782: LD_INT 1
31784: NEG
31785: PUSH
31786: LD_INT 1
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 2
31795: NEG
31796: PUSH
31797: LD_INT 0
31799: PUSH
31800: EMPTY
31801: LIST
31802: LIST
31803: PUSH
31804: LD_INT 2
31806: NEG
31807: PUSH
31808: LD_INT 1
31810: NEG
31811: PUSH
31812: EMPTY
31813: LIST
31814: LIST
31815: PUSH
31816: LD_INT 2
31818: NEG
31819: PUSH
31820: LD_INT 2
31822: NEG
31823: PUSH
31824: EMPTY
31825: LIST
31826: LIST
31827: PUSH
31828: EMPTY
31829: LIST
31830: LIST
31831: LIST
31832: LIST
31833: LIST
31834: LIST
31835: LIST
31836: LIST
31837: LIST
31838: LIST
31839: LIST
31840: LIST
31841: LIST
31842: LIST
31843: LIST
31844: LIST
31845: LIST
31846: LIST
31847: LIST
31848: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31849: LD_ADDR_VAR 0 21
31853: PUSH
31854: LD_INT 0
31856: PUSH
31857: LD_INT 0
31859: PUSH
31860: EMPTY
31861: LIST
31862: LIST
31863: PUSH
31864: LD_INT 0
31866: PUSH
31867: LD_INT 1
31869: NEG
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 1
31877: PUSH
31878: LD_INT 0
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PUSH
31885: LD_INT 1
31887: PUSH
31888: LD_INT 1
31890: PUSH
31891: EMPTY
31892: LIST
31893: LIST
31894: PUSH
31895: LD_INT 0
31897: PUSH
31898: LD_INT 1
31900: PUSH
31901: EMPTY
31902: LIST
31903: LIST
31904: PUSH
31905: LD_INT 1
31907: NEG
31908: PUSH
31909: LD_INT 0
31911: PUSH
31912: EMPTY
31913: LIST
31914: LIST
31915: PUSH
31916: LD_INT 1
31918: NEG
31919: PUSH
31920: LD_INT 1
31922: NEG
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 1
31930: NEG
31931: PUSH
31932: LD_INT 2
31934: NEG
31935: PUSH
31936: EMPTY
31937: LIST
31938: LIST
31939: PUSH
31940: LD_INT 0
31942: PUSH
31943: LD_INT 2
31945: NEG
31946: PUSH
31947: EMPTY
31948: LIST
31949: LIST
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: LD_INT 1
31956: NEG
31957: PUSH
31958: EMPTY
31959: LIST
31960: LIST
31961: PUSH
31962: LD_INT 2
31964: PUSH
31965: LD_INT 0
31967: PUSH
31968: EMPTY
31969: LIST
31970: LIST
31971: PUSH
31972: LD_INT 2
31974: PUSH
31975: LD_INT 1
31977: PUSH
31978: EMPTY
31979: LIST
31980: LIST
31981: PUSH
31982: LD_INT 2
31984: PUSH
31985: LD_INT 2
31987: PUSH
31988: EMPTY
31989: LIST
31990: LIST
31991: PUSH
31992: LD_INT 1
31994: PUSH
31995: LD_INT 2
31997: PUSH
31998: EMPTY
31999: LIST
32000: LIST
32001: PUSH
32002: LD_INT 0
32004: PUSH
32005: LD_INT 2
32007: PUSH
32008: EMPTY
32009: LIST
32010: LIST
32011: PUSH
32012: LD_INT 1
32014: NEG
32015: PUSH
32016: LD_INT 1
32018: PUSH
32019: EMPTY
32020: LIST
32021: LIST
32022: PUSH
32023: LD_INT 2
32025: NEG
32026: PUSH
32027: LD_INT 0
32029: PUSH
32030: EMPTY
32031: LIST
32032: LIST
32033: PUSH
32034: LD_INT 2
32036: NEG
32037: PUSH
32038: LD_INT 1
32040: NEG
32041: PUSH
32042: EMPTY
32043: LIST
32044: LIST
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: LD_INT 2
32052: NEG
32053: PUSH
32054: EMPTY
32055: LIST
32056: LIST
32057: PUSH
32058: EMPTY
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: LIST
32066: LIST
32067: LIST
32068: LIST
32069: LIST
32070: LIST
32071: LIST
32072: LIST
32073: LIST
32074: LIST
32075: LIST
32076: LIST
32077: LIST
32078: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32079: LD_ADDR_VAR 0 22
32083: PUSH
32084: LD_INT 0
32086: PUSH
32087: LD_INT 0
32089: PUSH
32090: EMPTY
32091: LIST
32092: LIST
32093: PUSH
32094: LD_INT 0
32096: PUSH
32097: LD_INT 1
32099: NEG
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: LD_INT 0
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: LD_INT 1
32117: PUSH
32118: LD_INT 1
32120: PUSH
32121: EMPTY
32122: LIST
32123: LIST
32124: PUSH
32125: LD_INT 0
32127: PUSH
32128: LD_INT 1
32130: PUSH
32131: EMPTY
32132: LIST
32133: LIST
32134: PUSH
32135: LD_INT 1
32137: NEG
32138: PUSH
32139: LD_INT 0
32141: PUSH
32142: EMPTY
32143: LIST
32144: LIST
32145: PUSH
32146: LD_INT 1
32148: NEG
32149: PUSH
32150: LD_INT 1
32152: NEG
32153: PUSH
32154: EMPTY
32155: LIST
32156: LIST
32157: PUSH
32158: LD_INT 1
32160: NEG
32161: PUSH
32162: LD_INT 2
32164: NEG
32165: PUSH
32166: EMPTY
32167: LIST
32168: LIST
32169: PUSH
32170: LD_INT 0
32172: PUSH
32173: LD_INT 2
32175: NEG
32176: PUSH
32177: EMPTY
32178: LIST
32179: LIST
32180: PUSH
32181: LD_INT 1
32183: PUSH
32184: LD_INT 1
32186: NEG
32187: PUSH
32188: EMPTY
32189: LIST
32190: LIST
32191: PUSH
32192: LD_INT 2
32194: PUSH
32195: LD_INT 0
32197: PUSH
32198: EMPTY
32199: LIST
32200: LIST
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: LD_INT 1
32207: PUSH
32208: EMPTY
32209: LIST
32210: LIST
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: LD_INT 2
32217: PUSH
32218: EMPTY
32219: LIST
32220: LIST
32221: PUSH
32222: LD_INT 1
32224: PUSH
32225: LD_INT 2
32227: PUSH
32228: EMPTY
32229: LIST
32230: LIST
32231: PUSH
32232: LD_INT 0
32234: PUSH
32235: LD_INT 2
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 1
32244: NEG
32245: PUSH
32246: LD_INT 1
32248: PUSH
32249: EMPTY
32250: LIST
32251: LIST
32252: PUSH
32253: LD_INT 2
32255: NEG
32256: PUSH
32257: LD_INT 0
32259: PUSH
32260: EMPTY
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 2
32266: NEG
32267: PUSH
32268: LD_INT 1
32270: NEG
32271: PUSH
32272: EMPTY
32273: LIST
32274: LIST
32275: PUSH
32276: LD_INT 2
32278: NEG
32279: PUSH
32280: LD_INT 2
32282: NEG
32283: PUSH
32284: EMPTY
32285: LIST
32286: LIST
32287: PUSH
32288: EMPTY
32289: LIST
32290: LIST
32291: LIST
32292: LIST
32293: LIST
32294: LIST
32295: LIST
32296: LIST
32297: LIST
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: LIST
32303: LIST
32304: LIST
32305: LIST
32306: LIST
32307: LIST
32308: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32309: LD_ADDR_VAR 0 23
32313: PUSH
32314: LD_INT 0
32316: PUSH
32317: LD_INT 0
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: PUSH
32324: LD_INT 0
32326: PUSH
32327: LD_INT 1
32329: NEG
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 1
32337: PUSH
32338: LD_INT 0
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: PUSH
32348: LD_INT 1
32350: PUSH
32351: EMPTY
32352: LIST
32353: LIST
32354: PUSH
32355: LD_INT 0
32357: PUSH
32358: LD_INT 1
32360: PUSH
32361: EMPTY
32362: LIST
32363: LIST
32364: PUSH
32365: LD_INT 1
32367: NEG
32368: PUSH
32369: LD_INT 0
32371: PUSH
32372: EMPTY
32373: LIST
32374: LIST
32375: PUSH
32376: LD_INT 1
32378: NEG
32379: PUSH
32380: LD_INT 1
32382: NEG
32383: PUSH
32384: EMPTY
32385: LIST
32386: LIST
32387: PUSH
32388: LD_INT 1
32390: NEG
32391: PUSH
32392: LD_INT 2
32394: NEG
32395: PUSH
32396: EMPTY
32397: LIST
32398: LIST
32399: PUSH
32400: LD_INT 0
32402: PUSH
32403: LD_INT 2
32405: NEG
32406: PUSH
32407: EMPTY
32408: LIST
32409: LIST
32410: PUSH
32411: LD_INT 1
32413: PUSH
32414: LD_INT 1
32416: NEG
32417: PUSH
32418: EMPTY
32419: LIST
32420: LIST
32421: PUSH
32422: LD_INT 2
32424: PUSH
32425: LD_INT 0
32427: PUSH
32428: EMPTY
32429: LIST
32430: LIST
32431: PUSH
32432: LD_INT 2
32434: PUSH
32435: LD_INT 1
32437: PUSH
32438: EMPTY
32439: LIST
32440: LIST
32441: PUSH
32442: LD_INT 2
32444: PUSH
32445: LD_INT 2
32447: PUSH
32448: EMPTY
32449: LIST
32450: LIST
32451: PUSH
32452: LD_INT 1
32454: PUSH
32455: LD_INT 2
32457: PUSH
32458: EMPTY
32459: LIST
32460: LIST
32461: PUSH
32462: LD_INT 0
32464: PUSH
32465: LD_INT 2
32467: PUSH
32468: EMPTY
32469: LIST
32470: LIST
32471: PUSH
32472: LD_INT 1
32474: NEG
32475: PUSH
32476: LD_INT 1
32478: PUSH
32479: EMPTY
32480: LIST
32481: LIST
32482: PUSH
32483: LD_INT 2
32485: NEG
32486: PUSH
32487: LD_INT 0
32489: PUSH
32490: EMPTY
32491: LIST
32492: LIST
32493: PUSH
32494: LD_INT 2
32496: NEG
32497: PUSH
32498: LD_INT 1
32500: NEG
32501: PUSH
32502: EMPTY
32503: LIST
32504: LIST
32505: PUSH
32506: LD_INT 2
32508: NEG
32509: PUSH
32510: LD_INT 2
32512: NEG
32513: PUSH
32514: EMPTY
32515: LIST
32516: LIST
32517: PUSH
32518: LD_INT 2
32520: NEG
32521: PUSH
32522: LD_INT 3
32524: NEG
32525: PUSH
32526: EMPTY
32527: LIST
32528: LIST
32529: PUSH
32530: LD_INT 1
32532: NEG
32533: PUSH
32534: LD_INT 3
32536: NEG
32537: PUSH
32538: EMPTY
32539: LIST
32540: LIST
32541: PUSH
32542: LD_INT 1
32544: PUSH
32545: LD_INT 2
32547: NEG
32548: PUSH
32549: EMPTY
32550: LIST
32551: LIST
32552: PUSH
32553: LD_INT 2
32555: PUSH
32556: LD_INT 1
32558: NEG
32559: PUSH
32560: EMPTY
32561: LIST
32562: LIST
32563: PUSH
32564: EMPTY
32565: LIST
32566: LIST
32567: LIST
32568: LIST
32569: LIST
32570: LIST
32571: LIST
32572: LIST
32573: LIST
32574: LIST
32575: LIST
32576: LIST
32577: LIST
32578: LIST
32579: LIST
32580: LIST
32581: LIST
32582: LIST
32583: LIST
32584: LIST
32585: LIST
32586: LIST
32587: LIST
32588: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32589: LD_ADDR_VAR 0 24
32593: PUSH
32594: LD_INT 0
32596: PUSH
32597: LD_INT 0
32599: PUSH
32600: EMPTY
32601: LIST
32602: LIST
32603: PUSH
32604: LD_INT 0
32606: PUSH
32607: LD_INT 1
32609: NEG
32610: PUSH
32611: EMPTY
32612: LIST
32613: LIST
32614: PUSH
32615: LD_INT 1
32617: PUSH
32618: LD_INT 0
32620: PUSH
32621: EMPTY
32622: LIST
32623: LIST
32624: PUSH
32625: LD_INT 1
32627: PUSH
32628: LD_INT 1
32630: PUSH
32631: EMPTY
32632: LIST
32633: LIST
32634: PUSH
32635: LD_INT 0
32637: PUSH
32638: LD_INT 1
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: NEG
32648: PUSH
32649: LD_INT 0
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 1
32658: NEG
32659: PUSH
32660: LD_INT 1
32662: NEG
32663: PUSH
32664: EMPTY
32665: LIST
32666: LIST
32667: PUSH
32668: LD_INT 1
32670: NEG
32671: PUSH
32672: LD_INT 2
32674: NEG
32675: PUSH
32676: EMPTY
32677: LIST
32678: LIST
32679: PUSH
32680: LD_INT 0
32682: PUSH
32683: LD_INT 2
32685: NEG
32686: PUSH
32687: EMPTY
32688: LIST
32689: LIST
32690: PUSH
32691: LD_INT 1
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 2
32704: PUSH
32705: LD_INT 0
32707: PUSH
32708: EMPTY
32709: LIST
32710: LIST
32711: PUSH
32712: LD_INT 2
32714: PUSH
32715: LD_INT 1
32717: PUSH
32718: EMPTY
32719: LIST
32720: LIST
32721: PUSH
32722: LD_INT 2
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: EMPTY
32729: LIST
32730: LIST
32731: PUSH
32732: LD_INT 1
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: EMPTY
32739: LIST
32740: LIST
32741: PUSH
32742: LD_INT 0
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: EMPTY
32749: LIST
32750: LIST
32751: PUSH
32752: LD_INT 1
32754: NEG
32755: PUSH
32756: LD_INT 1
32758: PUSH
32759: EMPTY
32760: LIST
32761: LIST
32762: PUSH
32763: LD_INT 2
32765: NEG
32766: PUSH
32767: LD_INT 0
32769: PUSH
32770: EMPTY
32771: LIST
32772: LIST
32773: PUSH
32774: LD_INT 2
32776: NEG
32777: PUSH
32778: LD_INT 1
32780: NEG
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: LD_INT 2
32792: NEG
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 1
32800: PUSH
32801: LD_INT 2
32803: NEG
32804: PUSH
32805: EMPTY
32806: LIST
32807: LIST
32808: PUSH
32809: LD_INT 2
32811: PUSH
32812: LD_INT 1
32814: NEG
32815: PUSH
32816: EMPTY
32817: LIST
32818: LIST
32819: PUSH
32820: LD_INT 3
32822: PUSH
32823: LD_INT 1
32825: PUSH
32826: EMPTY
32827: LIST
32828: LIST
32829: PUSH
32830: LD_INT 3
32832: PUSH
32833: LD_INT 2
32835: PUSH
32836: EMPTY
32837: LIST
32838: LIST
32839: PUSH
32840: EMPTY
32841: LIST
32842: LIST
32843: LIST
32844: LIST
32845: LIST
32846: LIST
32847: LIST
32848: LIST
32849: LIST
32850: LIST
32851: LIST
32852: LIST
32853: LIST
32854: LIST
32855: LIST
32856: LIST
32857: LIST
32858: LIST
32859: LIST
32860: LIST
32861: LIST
32862: LIST
32863: LIST
32864: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32865: LD_ADDR_VAR 0 25
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: LD_INT 0
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: PUSH
32880: LD_INT 0
32882: PUSH
32883: LD_INT 1
32885: NEG
32886: PUSH
32887: EMPTY
32888: LIST
32889: LIST
32890: PUSH
32891: LD_INT 1
32893: PUSH
32894: LD_INT 0
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 1
32903: PUSH
32904: LD_INT 1
32906: PUSH
32907: EMPTY
32908: LIST
32909: LIST
32910: PUSH
32911: LD_INT 0
32913: PUSH
32914: LD_INT 1
32916: PUSH
32917: EMPTY
32918: LIST
32919: LIST
32920: PUSH
32921: LD_INT 1
32923: NEG
32924: PUSH
32925: LD_INT 0
32927: PUSH
32928: EMPTY
32929: LIST
32930: LIST
32931: PUSH
32932: LD_INT 1
32934: NEG
32935: PUSH
32936: LD_INT 1
32938: NEG
32939: PUSH
32940: EMPTY
32941: LIST
32942: LIST
32943: PUSH
32944: LD_INT 1
32946: NEG
32947: PUSH
32948: LD_INT 2
32950: NEG
32951: PUSH
32952: EMPTY
32953: LIST
32954: LIST
32955: PUSH
32956: LD_INT 0
32958: PUSH
32959: LD_INT 2
32961: NEG
32962: PUSH
32963: EMPTY
32964: LIST
32965: LIST
32966: PUSH
32967: LD_INT 1
32969: PUSH
32970: LD_INT 1
32972: NEG
32973: PUSH
32974: EMPTY
32975: LIST
32976: LIST
32977: PUSH
32978: LD_INT 2
32980: PUSH
32981: LD_INT 0
32983: PUSH
32984: EMPTY
32985: LIST
32986: LIST
32987: PUSH
32988: LD_INT 2
32990: PUSH
32991: LD_INT 1
32993: PUSH
32994: EMPTY
32995: LIST
32996: LIST
32997: PUSH
32998: LD_INT 2
33000: PUSH
33001: LD_INT 2
33003: PUSH
33004: EMPTY
33005: LIST
33006: LIST
33007: PUSH
33008: LD_INT 1
33010: PUSH
33011: LD_INT 2
33013: PUSH
33014: EMPTY
33015: LIST
33016: LIST
33017: PUSH
33018: LD_INT 0
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PUSH
33028: LD_INT 1
33030: NEG
33031: PUSH
33032: LD_INT 1
33034: PUSH
33035: EMPTY
33036: LIST
33037: LIST
33038: PUSH
33039: LD_INT 2
33041: NEG
33042: PUSH
33043: LD_INT 0
33045: PUSH
33046: EMPTY
33047: LIST
33048: LIST
33049: PUSH
33050: LD_INT 2
33052: NEG
33053: PUSH
33054: LD_INT 1
33056: NEG
33057: PUSH
33058: EMPTY
33059: LIST
33060: LIST
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: LD_INT 2
33068: NEG
33069: PUSH
33070: EMPTY
33071: LIST
33072: LIST
33073: PUSH
33074: LD_INT 3
33076: PUSH
33077: LD_INT 1
33079: PUSH
33080: EMPTY
33081: LIST
33082: LIST
33083: PUSH
33084: LD_INT 3
33086: PUSH
33087: LD_INT 2
33089: PUSH
33090: EMPTY
33091: LIST
33092: LIST
33093: PUSH
33094: LD_INT 2
33096: PUSH
33097: LD_INT 3
33099: PUSH
33100: EMPTY
33101: LIST
33102: LIST
33103: PUSH
33104: LD_INT 1
33106: PUSH
33107: LD_INT 3
33109: PUSH
33110: EMPTY
33111: LIST
33112: LIST
33113: PUSH
33114: EMPTY
33115: LIST
33116: LIST
33117: LIST
33118: LIST
33119: LIST
33120: LIST
33121: LIST
33122: LIST
33123: LIST
33124: LIST
33125: LIST
33126: LIST
33127: LIST
33128: LIST
33129: LIST
33130: LIST
33131: LIST
33132: LIST
33133: LIST
33134: LIST
33135: LIST
33136: LIST
33137: LIST
33138: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33139: LD_ADDR_VAR 0 26
33143: PUSH
33144: LD_INT 0
33146: PUSH
33147: LD_INT 0
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: LD_INT 0
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 1
33167: PUSH
33168: LD_INT 0
33170: PUSH
33171: EMPTY
33172: LIST
33173: LIST
33174: PUSH
33175: LD_INT 1
33177: PUSH
33178: LD_INT 1
33180: PUSH
33181: EMPTY
33182: LIST
33183: LIST
33184: PUSH
33185: LD_INT 0
33187: PUSH
33188: LD_INT 1
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PUSH
33195: LD_INT 1
33197: NEG
33198: PUSH
33199: LD_INT 0
33201: PUSH
33202: EMPTY
33203: LIST
33204: LIST
33205: PUSH
33206: LD_INT 1
33208: NEG
33209: PUSH
33210: LD_INT 1
33212: NEG
33213: PUSH
33214: EMPTY
33215: LIST
33216: LIST
33217: PUSH
33218: LD_INT 1
33220: NEG
33221: PUSH
33222: LD_INT 2
33224: NEG
33225: PUSH
33226: EMPTY
33227: LIST
33228: LIST
33229: PUSH
33230: LD_INT 0
33232: PUSH
33233: LD_INT 2
33235: NEG
33236: PUSH
33237: EMPTY
33238: LIST
33239: LIST
33240: PUSH
33241: LD_INT 1
33243: PUSH
33244: LD_INT 1
33246: NEG
33247: PUSH
33248: EMPTY
33249: LIST
33250: LIST
33251: PUSH
33252: LD_INT 2
33254: PUSH
33255: LD_INT 0
33257: PUSH
33258: EMPTY
33259: LIST
33260: LIST
33261: PUSH
33262: LD_INT 2
33264: PUSH
33265: LD_INT 1
33267: PUSH
33268: EMPTY
33269: LIST
33270: LIST
33271: PUSH
33272: LD_INT 2
33274: PUSH
33275: LD_INT 2
33277: PUSH
33278: EMPTY
33279: LIST
33280: LIST
33281: PUSH
33282: LD_INT 1
33284: PUSH
33285: LD_INT 2
33287: PUSH
33288: EMPTY
33289: LIST
33290: LIST
33291: PUSH
33292: LD_INT 0
33294: PUSH
33295: LD_INT 2
33297: PUSH
33298: EMPTY
33299: LIST
33300: LIST
33301: PUSH
33302: LD_INT 1
33304: NEG
33305: PUSH
33306: LD_INT 1
33308: PUSH
33309: EMPTY
33310: LIST
33311: LIST
33312: PUSH
33313: LD_INT 2
33315: NEG
33316: PUSH
33317: LD_INT 0
33319: PUSH
33320: EMPTY
33321: LIST
33322: LIST
33323: PUSH
33324: LD_INT 2
33326: NEG
33327: PUSH
33328: LD_INT 1
33330: NEG
33331: PUSH
33332: EMPTY
33333: LIST
33334: LIST
33335: PUSH
33336: LD_INT 2
33338: NEG
33339: PUSH
33340: LD_INT 2
33342: NEG
33343: PUSH
33344: EMPTY
33345: LIST
33346: LIST
33347: PUSH
33348: LD_INT 2
33350: PUSH
33351: LD_INT 3
33353: PUSH
33354: EMPTY
33355: LIST
33356: LIST
33357: PUSH
33358: LD_INT 1
33360: PUSH
33361: LD_INT 3
33363: PUSH
33364: EMPTY
33365: LIST
33366: LIST
33367: PUSH
33368: LD_INT 1
33370: NEG
33371: PUSH
33372: LD_INT 2
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 2
33381: NEG
33382: PUSH
33383: LD_INT 1
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: EMPTY
33391: LIST
33392: LIST
33393: LIST
33394: LIST
33395: LIST
33396: LIST
33397: LIST
33398: LIST
33399: LIST
33400: LIST
33401: LIST
33402: LIST
33403: LIST
33404: LIST
33405: LIST
33406: LIST
33407: LIST
33408: LIST
33409: LIST
33410: LIST
33411: LIST
33412: LIST
33413: LIST
33414: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33415: LD_ADDR_VAR 0 27
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: LD_INT 0
33425: PUSH
33426: EMPTY
33427: LIST
33428: LIST
33429: PUSH
33430: LD_INT 0
33432: PUSH
33433: LD_INT 1
33435: NEG
33436: PUSH
33437: EMPTY
33438: LIST
33439: LIST
33440: PUSH
33441: LD_INT 1
33443: PUSH
33444: LD_INT 0
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 1
33453: PUSH
33454: LD_INT 1
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 0
33463: PUSH
33464: LD_INT 1
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 1
33473: NEG
33474: PUSH
33475: LD_INT 0
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 1
33484: NEG
33485: PUSH
33486: LD_INT 1
33488: NEG
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: NEG
33497: PUSH
33498: LD_INT 2
33500: NEG
33501: PUSH
33502: EMPTY
33503: LIST
33504: LIST
33505: PUSH
33506: LD_INT 0
33508: PUSH
33509: LD_INT 2
33511: NEG
33512: PUSH
33513: EMPTY
33514: LIST
33515: LIST
33516: PUSH
33517: LD_INT 1
33519: PUSH
33520: LD_INT 1
33522: NEG
33523: PUSH
33524: EMPTY
33525: LIST
33526: LIST
33527: PUSH
33528: LD_INT 2
33530: PUSH
33531: LD_INT 0
33533: PUSH
33534: EMPTY
33535: LIST
33536: LIST
33537: PUSH
33538: LD_INT 2
33540: PUSH
33541: LD_INT 1
33543: PUSH
33544: EMPTY
33545: LIST
33546: LIST
33547: PUSH
33548: LD_INT 2
33550: PUSH
33551: LD_INT 2
33553: PUSH
33554: EMPTY
33555: LIST
33556: LIST
33557: PUSH
33558: LD_INT 1
33560: PUSH
33561: LD_INT 2
33563: PUSH
33564: EMPTY
33565: LIST
33566: LIST
33567: PUSH
33568: LD_INT 0
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: EMPTY
33575: LIST
33576: LIST
33577: PUSH
33578: LD_INT 1
33580: NEG
33581: PUSH
33582: LD_INT 1
33584: PUSH
33585: EMPTY
33586: LIST
33587: LIST
33588: PUSH
33589: LD_INT 2
33591: NEG
33592: PUSH
33593: LD_INT 0
33595: PUSH
33596: EMPTY
33597: LIST
33598: LIST
33599: PUSH
33600: LD_INT 2
33602: NEG
33603: PUSH
33604: LD_INT 1
33606: NEG
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: LD_INT 2
33618: NEG
33619: PUSH
33620: EMPTY
33621: LIST
33622: LIST
33623: PUSH
33624: LD_INT 1
33626: NEG
33627: PUSH
33628: LD_INT 2
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 2
33637: NEG
33638: PUSH
33639: LD_INT 1
33641: PUSH
33642: EMPTY
33643: LIST
33644: LIST
33645: PUSH
33646: LD_INT 3
33648: NEG
33649: PUSH
33650: LD_INT 1
33652: NEG
33653: PUSH
33654: EMPTY
33655: LIST
33656: LIST
33657: PUSH
33658: LD_INT 3
33660: NEG
33661: PUSH
33662: LD_INT 2
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: EMPTY
33671: LIST
33672: LIST
33673: LIST
33674: LIST
33675: LIST
33676: LIST
33677: LIST
33678: LIST
33679: LIST
33680: LIST
33681: LIST
33682: LIST
33683: LIST
33684: LIST
33685: LIST
33686: LIST
33687: LIST
33688: LIST
33689: LIST
33690: LIST
33691: LIST
33692: LIST
33693: LIST
33694: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33695: LD_ADDR_VAR 0 28
33699: PUSH
33700: LD_INT 0
33702: PUSH
33703: LD_INT 0
33705: PUSH
33706: EMPTY
33707: LIST
33708: LIST
33709: PUSH
33710: LD_INT 0
33712: PUSH
33713: LD_INT 1
33715: NEG
33716: PUSH
33717: EMPTY
33718: LIST
33719: LIST
33720: PUSH
33721: LD_INT 1
33723: PUSH
33724: LD_INT 0
33726: PUSH
33727: EMPTY
33728: LIST
33729: LIST
33730: PUSH
33731: LD_INT 1
33733: PUSH
33734: LD_INT 1
33736: PUSH
33737: EMPTY
33738: LIST
33739: LIST
33740: PUSH
33741: LD_INT 0
33743: PUSH
33744: LD_INT 1
33746: PUSH
33747: EMPTY
33748: LIST
33749: LIST
33750: PUSH
33751: LD_INT 1
33753: NEG
33754: PUSH
33755: LD_INT 0
33757: PUSH
33758: EMPTY
33759: LIST
33760: LIST
33761: PUSH
33762: LD_INT 1
33764: NEG
33765: PUSH
33766: LD_INT 1
33768: NEG
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: NEG
33777: PUSH
33778: LD_INT 2
33780: NEG
33781: PUSH
33782: EMPTY
33783: LIST
33784: LIST
33785: PUSH
33786: LD_INT 0
33788: PUSH
33789: LD_INT 2
33791: NEG
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 1
33799: PUSH
33800: LD_INT 1
33802: NEG
33803: PUSH
33804: EMPTY
33805: LIST
33806: LIST
33807: PUSH
33808: LD_INT 2
33810: PUSH
33811: LD_INT 0
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PUSH
33818: LD_INT 2
33820: PUSH
33821: LD_INT 1
33823: PUSH
33824: EMPTY
33825: LIST
33826: LIST
33827: PUSH
33828: LD_INT 2
33830: PUSH
33831: LD_INT 2
33833: PUSH
33834: EMPTY
33835: LIST
33836: LIST
33837: PUSH
33838: LD_INT 1
33840: PUSH
33841: LD_INT 2
33843: PUSH
33844: EMPTY
33845: LIST
33846: LIST
33847: PUSH
33848: LD_INT 0
33850: PUSH
33851: LD_INT 2
33853: PUSH
33854: EMPTY
33855: LIST
33856: LIST
33857: PUSH
33858: LD_INT 1
33860: NEG
33861: PUSH
33862: LD_INT 1
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 2
33871: NEG
33872: PUSH
33873: LD_INT 0
33875: PUSH
33876: EMPTY
33877: LIST
33878: LIST
33879: PUSH
33880: LD_INT 2
33882: NEG
33883: PUSH
33884: LD_INT 1
33886: NEG
33887: PUSH
33888: EMPTY
33889: LIST
33890: LIST
33891: PUSH
33892: LD_INT 2
33894: NEG
33895: PUSH
33896: LD_INT 2
33898: NEG
33899: PUSH
33900: EMPTY
33901: LIST
33902: LIST
33903: PUSH
33904: LD_INT 2
33906: NEG
33907: PUSH
33908: LD_INT 3
33910: NEG
33911: PUSH
33912: EMPTY
33913: LIST
33914: LIST
33915: PUSH
33916: LD_INT 1
33918: NEG
33919: PUSH
33920: LD_INT 3
33922: NEG
33923: PUSH
33924: EMPTY
33925: LIST
33926: LIST
33927: PUSH
33928: LD_INT 3
33930: NEG
33931: PUSH
33932: LD_INT 1
33934: NEG
33935: PUSH
33936: EMPTY
33937: LIST
33938: LIST
33939: PUSH
33940: LD_INT 3
33942: NEG
33943: PUSH
33944: LD_INT 2
33946: NEG
33947: PUSH
33948: EMPTY
33949: LIST
33950: LIST
33951: PUSH
33952: EMPTY
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: LIST
33962: LIST
33963: LIST
33964: LIST
33965: LIST
33966: LIST
33967: LIST
33968: LIST
33969: LIST
33970: LIST
33971: LIST
33972: LIST
33973: LIST
33974: LIST
33975: LIST
33976: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33977: LD_ADDR_VAR 0 29
33981: PUSH
33982: LD_INT 0
33984: PUSH
33985: LD_INT 0
33987: PUSH
33988: EMPTY
33989: LIST
33990: LIST
33991: PUSH
33992: LD_INT 0
33994: PUSH
33995: LD_INT 1
33997: NEG
33998: PUSH
33999: EMPTY
34000: LIST
34001: LIST
34002: PUSH
34003: LD_INT 1
34005: PUSH
34006: LD_INT 0
34008: PUSH
34009: EMPTY
34010: LIST
34011: LIST
34012: PUSH
34013: LD_INT 1
34015: PUSH
34016: LD_INT 1
34018: PUSH
34019: EMPTY
34020: LIST
34021: LIST
34022: PUSH
34023: LD_INT 0
34025: PUSH
34026: LD_INT 1
34028: PUSH
34029: EMPTY
34030: LIST
34031: LIST
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: LD_INT 0
34039: PUSH
34040: EMPTY
34041: LIST
34042: LIST
34043: PUSH
34044: LD_INT 1
34046: NEG
34047: PUSH
34048: LD_INT 1
34050: NEG
34051: PUSH
34052: EMPTY
34053: LIST
34054: LIST
34055: PUSH
34056: LD_INT 1
34058: NEG
34059: PUSH
34060: LD_INT 2
34062: NEG
34063: PUSH
34064: EMPTY
34065: LIST
34066: LIST
34067: PUSH
34068: LD_INT 0
34070: PUSH
34071: LD_INT 2
34073: NEG
34074: PUSH
34075: EMPTY
34076: LIST
34077: LIST
34078: PUSH
34079: LD_INT 1
34081: PUSH
34082: LD_INT 1
34084: NEG
34085: PUSH
34086: EMPTY
34087: LIST
34088: LIST
34089: PUSH
34090: LD_INT 2
34092: PUSH
34093: LD_INT 0
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 2
34102: PUSH
34103: LD_INT 1
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: LD_INT 2
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 2
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: NEG
34133: PUSH
34134: LD_INT 1
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 2
34143: NEG
34144: PUSH
34145: LD_INT 1
34147: NEG
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 2
34155: NEG
34156: PUSH
34157: LD_INT 2
34159: NEG
34160: PUSH
34161: EMPTY
34162: LIST
34163: LIST
34164: PUSH
34165: LD_INT 2
34167: NEG
34168: PUSH
34169: LD_INT 3
34171: NEG
34172: PUSH
34173: EMPTY
34174: LIST
34175: LIST
34176: PUSH
34177: LD_INT 2
34179: PUSH
34180: LD_INT 1
34182: NEG
34183: PUSH
34184: EMPTY
34185: LIST
34186: LIST
34187: PUSH
34188: LD_INT 3
34190: PUSH
34191: LD_INT 1
34193: PUSH
34194: EMPTY
34195: LIST
34196: LIST
34197: PUSH
34198: LD_INT 1
34200: PUSH
34201: LD_INT 3
34203: PUSH
34204: EMPTY
34205: LIST
34206: LIST
34207: PUSH
34208: LD_INT 1
34210: NEG
34211: PUSH
34212: LD_INT 2
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 3
34221: NEG
34222: PUSH
34223: LD_INT 2
34225: NEG
34226: PUSH
34227: EMPTY
34228: LIST
34229: LIST
34230: PUSH
34231: EMPTY
34232: LIST
34233: LIST
34234: LIST
34235: LIST
34236: LIST
34237: LIST
34238: LIST
34239: LIST
34240: LIST
34241: LIST
34242: LIST
34243: LIST
34244: LIST
34245: LIST
34246: LIST
34247: LIST
34248: LIST
34249: LIST
34250: LIST
34251: LIST
34252: LIST
34253: LIST
34254: LIST
34255: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34256: LD_ADDR_VAR 0 30
34260: PUSH
34261: LD_INT 0
34263: PUSH
34264: LD_INT 0
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 0
34273: PUSH
34274: LD_INT 1
34276: NEG
34277: PUSH
34278: EMPTY
34279: LIST
34280: LIST
34281: PUSH
34282: LD_INT 1
34284: PUSH
34285: LD_INT 0
34287: PUSH
34288: EMPTY
34289: LIST
34290: LIST
34291: PUSH
34292: LD_INT 1
34294: PUSH
34295: LD_INT 1
34297: PUSH
34298: EMPTY
34299: LIST
34300: LIST
34301: PUSH
34302: LD_INT 0
34304: PUSH
34305: LD_INT 1
34307: PUSH
34308: EMPTY
34309: LIST
34310: LIST
34311: PUSH
34312: LD_INT 1
34314: NEG
34315: PUSH
34316: LD_INT 0
34318: PUSH
34319: EMPTY
34320: LIST
34321: LIST
34322: PUSH
34323: LD_INT 1
34325: NEG
34326: PUSH
34327: LD_INT 1
34329: NEG
34330: PUSH
34331: EMPTY
34332: LIST
34333: LIST
34334: PUSH
34335: LD_INT 1
34337: NEG
34338: PUSH
34339: LD_INT 2
34341: NEG
34342: PUSH
34343: EMPTY
34344: LIST
34345: LIST
34346: PUSH
34347: LD_INT 0
34349: PUSH
34350: LD_INT 2
34352: NEG
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 1
34360: PUSH
34361: LD_INT 1
34363: NEG
34364: PUSH
34365: EMPTY
34366: LIST
34367: LIST
34368: PUSH
34369: LD_INT 2
34371: PUSH
34372: LD_INT 0
34374: PUSH
34375: EMPTY
34376: LIST
34377: LIST
34378: PUSH
34379: LD_INT 2
34381: PUSH
34382: LD_INT 1
34384: PUSH
34385: EMPTY
34386: LIST
34387: LIST
34388: PUSH
34389: LD_INT 2
34391: PUSH
34392: LD_INT 2
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: LD_INT 1
34401: PUSH
34402: LD_INT 2
34404: PUSH
34405: EMPTY
34406: LIST
34407: LIST
34408: PUSH
34409: LD_INT 1
34411: NEG
34412: PUSH
34413: LD_INT 1
34415: PUSH
34416: EMPTY
34417: LIST
34418: LIST
34419: PUSH
34420: LD_INT 2
34422: NEG
34423: PUSH
34424: LD_INT 0
34426: PUSH
34427: EMPTY
34428: LIST
34429: LIST
34430: PUSH
34431: LD_INT 2
34433: NEG
34434: PUSH
34435: LD_INT 1
34437: NEG
34438: PUSH
34439: EMPTY
34440: LIST
34441: LIST
34442: PUSH
34443: LD_INT 1
34445: NEG
34446: PUSH
34447: LD_INT 3
34449: NEG
34450: PUSH
34451: EMPTY
34452: LIST
34453: LIST
34454: PUSH
34455: LD_INT 1
34457: PUSH
34458: LD_INT 2
34460: NEG
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 3
34468: PUSH
34469: LD_INT 2
34471: PUSH
34472: EMPTY
34473: LIST
34474: LIST
34475: PUSH
34476: LD_INT 2
34478: PUSH
34479: LD_INT 3
34481: PUSH
34482: EMPTY
34483: LIST
34484: LIST
34485: PUSH
34486: LD_INT 2
34488: NEG
34489: PUSH
34490: LD_INT 1
34492: PUSH
34493: EMPTY
34494: LIST
34495: LIST
34496: PUSH
34497: LD_INT 3
34499: NEG
34500: PUSH
34501: LD_INT 1
34503: NEG
34504: PUSH
34505: EMPTY
34506: LIST
34507: LIST
34508: PUSH
34509: EMPTY
34510: LIST
34511: LIST
34512: LIST
34513: LIST
34514: LIST
34515: LIST
34516: LIST
34517: LIST
34518: LIST
34519: LIST
34520: LIST
34521: LIST
34522: LIST
34523: LIST
34524: LIST
34525: LIST
34526: LIST
34527: LIST
34528: LIST
34529: LIST
34530: LIST
34531: LIST
34532: LIST
34533: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34534: LD_ADDR_VAR 0 31
34538: PUSH
34539: LD_INT 0
34541: PUSH
34542: LD_INT 0
34544: PUSH
34545: EMPTY
34546: LIST
34547: LIST
34548: PUSH
34549: LD_INT 0
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: EMPTY
34557: LIST
34558: LIST
34559: PUSH
34560: LD_INT 1
34562: PUSH
34563: LD_INT 0
34565: PUSH
34566: EMPTY
34567: LIST
34568: LIST
34569: PUSH
34570: LD_INT 1
34572: PUSH
34573: LD_INT 1
34575: PUSH
34576: EMPTY
34577: LIST
34578: LIST
34579: PUSH
34580: LD_INT 0
34582: PUSH
34583: LD_INT 1
34585: PUSH
34586: EMPTY
34587: LIST
34588: LIST
34589: PUSH
34590: LD_INT 1
34592: NEG
34593: PUSH
34594: LD_INT 0
34596: PUSH
34597: EMPTY
34598: LIST
34599: LIST
34600: PUSH
34601: LD_INT 1
34603: NEG
34604: PUSH
34605: LD_INT 1
34607: NEG
34608: PUSH
34609: EMPTY
34610: LIST
34611: LIST
34612: PUSH
34613: LD_INT 1
34615: NEG
34616: PUSH
34617: LD_INT 2
34619: NEG
34620: PUSH
34621: EMPTY
34622: LIST
34623: LIST
34624: PUSH
34625: LD_INT 1
34627: PUSH
34628: LD_INT 1
34630: NEG
34631: PUSH
34632: EMPTY
34633: LIST
34634: LIST
34635: PUSH
34636: LD_INT 2
34638: PUSH
34639: LD_INT 0
34641: PUSH
34642: EMPTY
34643: LIST
34644: LIST
34645: PUSH
34646: LD_INT 2
34648: PUSH
34649: LD_INT 1
34651: PUSH
34652: EMPTY
34653: LIST
34654: LIST
34655: PUSH
34656: LD_INT 2
34658: PUSH
34659: LD_INT 2
34661: PUSH
34662: EMPTY
34663: LIST
34664: LIST
34665: PUSH
34666: LD_INT 1
34668: PUSH
34669: LD_INT 2
34671: PUSH
34672: EMPTY
34673: LIST
34674: LIST
34675: PUSH
34676: LD_INT 0
34678: PUSH
34679: LD_INT 2
34681: PUSH
34682: EMPTY
34683: LIST
34684: LIST
34685: PUSH
34686: LD_INT 1
34688: NEG
34689: PUSH
34690: LD_INT 1
34692: PUSH
34693: EMPTY
34694: LIST
34695: LIST
34696: PUSH
34697: LD_INT 2
34699: NEG
34700: PUSH
34701: LD_INT 1
34703: NEG
34704: PUSH
34705: EMPTY
34706: LIST
34707: LIST
34708: PUSH
34709: LD_INT 2
34711: NEG
34712: PUSH
34713: LD_INT 2
34715: NEG
34716: PUSH
34717: EMPTY
34718: LIST
34719: LIST
34720: PUSH
34721: LD_INT 2
34723: NEG
34724: PUSH
34725: LD_INT 3
34727: NEG
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: PUSH
34733: LD_INT 2
34735: PUSH
34736: LD_INT 1
34738: NEG
34739: PUSH
34740: EMPTY
34741: LIST
34742: LIST
34743: PUSH
34744: LD_INT 3
34746: PUSH
34747: LD_INT 1
34749: PUSH
34750: EMPTY
34751: LIST
34752: LIST
34753: PUSH
34754: LD_INT 1
34756: PUSH
34757: LD_INT 3
34759: PUSH
34760: EMPTY
34761: LIST
34762: LIST
34763: PUSH
34764: LD_INT 1
34766: NEG
34767: PUSH
34768: LD_INT 2
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 3
34777: NEG
34778: PUSH
34779: LD_INT 2
34781: NEG
34782: PUSH
34783: EMPTY
34784: LIST
34785: LIST
34786: PUSH
34787: EMPTY
34788: LIST
34789: LIST
34790: LIST
34791: LIST
34792: LIST
34793: LIST
34794: LIST
34795: LIST
34796: LIST
34797: LIST
34798: LIST
34799: LIST
34800: LIST
34801: LIST
34802: LIST
34803: LIST
34804: LIST
34805: LIST
34806: LIST
34807: LIST
34808: LIST
34809: LIST
34810: LIST
34811: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34812: LD_ADDR_VAR 0 32
34816: PUSH
34817: LD_INT 0
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 0
34829: PUSH
34830: LD_INT 1
34832: NEG
34833: PUSH
34834: EMPTY
34835: LIST
34836: LIST
34837: PUSH
34838: LD_INT 1
34840: PUSH
34841: LD_INT 0
34843: PUSH
34844: EMPTY
34845: LIST
34846: LIST
34847: PUSH
34848: LD_INT 1
34850: PUSH
34851: LD_INT 1
34853: PUSH
34854: EMPTY
34855: LIST
34856: LIST
34857: PUSH
34858: LD_INT 0
34860: PUSH
34861: LD_INT 1
34863: PUSH
34864: EMPTY
34865: LIST
34866: LIST
34867: PUSH
34868: LD_INT 1
34870: NEG
34871: PUSH
34872: LD_INT 0
34874: PUSH
34875: EMPTY
34876: LIST
34877: LIST
34878: PUSH
34879: LD_INT 1
34881: NEG
34882: PUSH
34883: LD_INT 1
34885: NEG
34886: PUSH
34887: EMPTY
34888: LIST
34889: LIST
34890: PUSH
34891: LD_INT 1
34893: NEG
34894: PUSH
34895: LD_INT 2
34897: NEG
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: LD_INT 2
34908: NEG
34909: PUSH
34910: EMPTY
34911: LIST
34912: LIST
34913: PUSH
34914: LD_INT 1
34916: PUSH
34917: LD_INT 1
34919: NEG
34920: PUSH
34921: EMPTY
34922: LIST
34923: LIST
34924: PUSH
34925: LD_INT 2
34927: PUSH
34928: LD_INT 1
34930: PUSH
34931: EMPTY
34932: LIST
34933: LIST
34934: PUSH
34935: LD_INT 2
34937: PUSH
34938: LD_INT 2
34940: PUSH
34941: EMPTY
34942: LIST
34943: LIST
34944: PUSH
34945: LD_INT 1
34947: PUSH
34948: LD_INT 2
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 0
34957: PUSH
34958: LD_INT 2
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 1
34967: NEG
34968: PUSH
34969: LD_INT 1
34971: PUSH
34972: EMPTY
34973: LIST
34974: LIST
34975: PUSH
34976: LD_INT 2
34978: NEG
34979: PUSH
34980: LD_INT 0
34982: PUSH
34983: EMPTY
34984: LIST
34985: LIST
34986: PUSH
34987: LD_INT 2
34989: NEG
34990: PUSH
34991: LD_INT 1
34993: NEG
34994: PUSH
34995: EMPTY
34996: LIST
34997: LIST
34998: PUSH
34999: LD_INT 1
35001: NEG
35002: PUSH
35003: LD_INT 3
35005: NEG
35006: PUSH
35007: EMPTY
35008: LIST
35009: LIST
35010: PUSH
35011: LD_INT 1
35013: PUSH
35014: LD_INT 2
35016: NEG
35017: PUSH
35018: EMPTY
35019: LIST
35020: LIST
35021: PUSH
35022: LD_INT 3
35024: PUSH
35025: LD_INT 2
35027: PUSH
35028: EMPTY
35029: LIST
35030: LIST
35031: PUSH
35032: LD_INT 2
35034: PUSH
35035: LD_INT 3
35037: PUSH
35038: EMPTY
35039: LIST
35040: LIST
35041: PUSH
35042: LD_INT 2
35044: NEG
35045: PUSH
35046: LD_INT 1
35048: PUSH
35049: EMPTY
35050: LIST
35051: LIST
35052: PUSH
35053: LD_INT 3
35055: NEG
35056: PUSH
35057: LD_INT 1
35059: NEG
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: PUSH
35065: EMPTY
35066: LIST
35067: LIST
35068: LIST
35069: LIST
35070: LIST
35071: LIST
35072: LIST
35073: LIST
35074: LIST
35075: LIST
35076: LIST
35077: LIST
35078: LIST
35079: LIST
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35090: LD_ADDR_VAR 0 33
35094: PUSH
35095: LD_INT 0
35097: PUSH
35098: LD_INT 0
35100: PUSH
35101: EMPTY
35102: LIST
35103: LIST
35104: PUSH
35105: LD_INT 0
35107: PUSH
35108: LD_INT 1
35110: NEG
35111: PUSH
35112: EMPTY
35113: LIST
35114: LIST
35115: PUSH
35116: LD_INT 1
35118: PUSH
35119: LD_INT 0
35121: PUSH
35122: EMPTY
35123: LIST
35124: LIST
35125: PUSH
35126: LD_INT 1
35128: PUSH
35129: LD_INT 1
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 0
35138: PUSH
35139: LD_INT 1
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 1
35148: NEG
35149: PUSH
35150: LD_INT 0
35152: PUSH
35153: EMPTY
35154: LIST
35155: LIST
35156: PUSH
35157: LD_INT 1
35159: NEG
35160: PUSH
35161: LD_INT 1
35163: NEG
35164: PUSH
35165: EMPTY
35166: LIST
35167: LIST
35168: PUSH
35169: LD_INT 1
35171: NEG
35172: PUSH
35173: LD_INT 2
35175: NEG
35176: PUSH
35177: EMPTY
35178: LIST
35179: LIST
35180: PUSH
35181: LD_INT 1
35183: PUSH
35184: LD_INT 1
35186: NEG
35187: PUSH
35188: EMPTY
35189: LIST
35190: LIST
35191: PUSH
35192: LD_INT 2
35194: PUSH
35195: LD_INT 0
35197: PUSH
35198: EMPTY
35199: LIST
35200: LIST
35201: PUSH
35202: LD_INT 2
35204: PUSH
35205: LD_INT 1
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: LD_INT 2
35217: PUSH
35218: EMPTY
35219: LIST
35220: LIST
35221: PUSH
35222: LD_INT 0
35224: PUSH
35225: LD_INT 2
35227: PUSH
35228: EMPTY
35229: LIST
35230: LIST
35231: PUSH
35232: LD_INT 1
35234: NEG
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 2
35245: NEG
35246: PUSH
35247: LD_INT 0
35249: PUSH
35250: EMPTY
35251: LIST
35252: LIST
35253: PUSH
35254: LD_INT 2
35256: NEG
35257: PUSH
35258: LD_INT 1
35260: NEG
35261: PUSH
35262: EMPTY
35263: LIST
35264: LIST
35265: PUSH
35266: LD_INT 2
35268: NEG
35269: PUSH
35270: LD_INT 2
35272: NEG
35273: PUSH
35274: EMPTY
35275: LIST
35276: LIST
35277: PUSH
35278: LD_INT 2
35280: NEG
35281: PUSH
35282: LD_INT 3
35284: NEG
35285: PUSH
35286: EMPTY
35287: LIST
35288: LIST
35289: PUSH
35290: LD_INT 2
35292: PUSH
35293: LD_INT 1
35295: NEG
35296: PUSH
35297: EMPTY
35298: LIST
35299: LIST
35300: PUSH
35301: LD_INT 3
35303: PUSH
35304: LD_INT 1
35306: PUSH
35307: EMPTY
35308: LIST
35309: LIST
35310: PUSH
35311: LD_INT 1
35313: PUSH
35314: LD_INT 3
35316: PUSH
35317: EMPTY
35318: LIST
35319: LIST
35320: PUSH
35321: LD_INT 1
35323: NEG
35324: PUSH
35325: LD_INT 2
35327: PUSH
35328: EMPTY
35329: LIST
35330: LIST
35331: PUSH
35332: LD_INT 3
35334: NEG
35335: PUSH
35336: LD_INT 2
35338: NEG
35339: PUSH
35340: EMPTY
35341: LIST
35342: LIST
35343: PUSH
35344: EMPTY
35345: LIST
35346: LIST
35347: LIST
35348: LIST
35349: LIST
35350: LIST
35351: LIST
35352: LIST
35353: LIST
35354: LIST
35355: LIST
35356: LIST
35357: LIST
35358: LIST
35359: LIST
35360: LIST
35361: LIST
35362: LIST
35363: LIST
35364: LIST
35365: LIST
35366: LIST
35367: LIST
35368: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35369: LD_ADDR_VAR 0 34
35373: PUSH
35374: LD_INT 0
35376: PUSH
35377: LD_INT 0
35379: PUSH
35380: EMPTY
35381: LIST
35382: LIST
35383: PUSH
35384: LD_INT 0
35386: PUSH
35387: LD_INT 1
35389: NEG
35390: PUSH
35391: EMPTY
35392: LIST
35393: LIST
35394: PUSH
35395: LD_INT 1
35397: PUSH
35398: LD_INT 0
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 1
35407: PUSH
35408: LD_INT 1
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 0
35417: PUSH
35418: LD_INT 1
35420: PUSH
35421: EMPTY
35422: LIST
35423: LIST
35424: PUSH
35425: LD_INT 1
35427: NEG
35428: PUSH
35429: LD_INT 0
35431: PUSH
35432: EMPTY
35433: LIST
35434: LIST
35435: PUSH
35436: LD_INT 1
35438: NEG
35439: PUSH
35440: LD_INT 1
35442: NEG
35443: PUSH
35444: EMPTY
35445: LIST
35446: LIST
35447: PUSH
35448: LD_INT 1
35450: NEG
35451: PUSH
35452: LD_INT 2
35454: NEG
35455: PUSH
35456: EMPTY
35457: LIST
35458: LIST
35459: PUSH
35460: LD_INT 0
35462: PUSH
35463: LD_INT 2
35465: NEG
35466: PUSH
35467: EMPTY
35468: LIST
35469: LIST
35470: PUSH
35471: LD_INT 1
35473: PUSH
35474: LD_INT 1
35476: NEG
35477: PUSH
35478: EMPTY
35479: LIST
35480: LIST
35481: PUSH
35482: LD_INT 2
35484: PUSH
35485: LD_INT 1
35487: PUSH
35488: EMPTY
35489: LIST
35490: LIST
35491: PUSH
35492: LD_INT 2
35494: PUSH
35495: LD_INT 2
35497: PUSH
35498: EMPTY
35499: LIST
35500: LIST
35501: PUSH
35502: LD_INT 1
35504: PUSH
35505: LD_INT 2
35507: PUSH
35508: EMPTY
35509: LIST
35510: LIST
35511: PUSH
35512: LD_INT 1
35514: NEG
35515: PUSH
35516: LD_INT 1
35518: PUSH
35519: EMPTY
35520: LIST
35521: LIST
35522: PUSH
35523: LD_INT 2
35525: NEG
35526: PUSH
35527: LD_INT 0
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 2
35536: NEG
35537: PUSH
35538: LD_INT 1
35540: NEG
35541: PUSH
35542: EMPTY
35543: LIST
35544: LIST
35545: PUSH
35546: LD_INT 2
35548: NEG
35549: PUSH
35550: LD_INT 2
35552: NEG
35553: PUSH
35554: EMPTY
35555: LIST
35556: LIST
35557: PUSH
35558: LD_INT 1
35560: NEG
35561: PUSH
35562: LD_INT 3
35564: NEG
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 1
35572: PUSH
35573: LD_INT 2
35575: NEG
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: PUSH
35581: LD_INT 3
35583: PUSH
35584: LD_INT 2
35586: PUSH
35587: EMPTY
35588: LIST
35589: LIST
35590: PUSH
35591: LD_INT 2
35593: PUSH
35594: LD_INT 3
35596: PUSH
35597: EMPTY
35598: LIST
35599: LIST
35600: PUSH
35601: LD_INT 2
35603: NEG
35604: PUSH
35605: LD_INT 1
35607: PUSH
35608: EMPTY
35609: LIST
35610: LIST
35611: PUSH
35612: LD_INT 3
35614: NEG
35615: PUSH
35616: LD_INT 1
35618: NEG
35619: PUSH
35620: EMPTY
35621: LIST
35622: LIST
35623: PUSH
35624: EMPTY
35625: LIST
35626: LIST
35627: LIST
35628: LIST
35629: LIST
35630: LIST
35631: LIST
35632: LIST
35633: LIST
35634: LIST
35635: LIST
35636: LIST
35637: LIST
35638: LIST
35639: LIST
35640: LIST
35641: LIST
35642: LIST
35643: LIST
35644: LIST
35645: LIST
35646: LIST
35647: LIST
35648: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35649: LD_ADDR_VAR 0 35
35653: PUSH
35654: LD_INT 0
35656: PUSH
35657: LD_INT 0
35659: PUSH
35660: EMPTY
35661: LIST
35662: LIST
35663: PUSH
35664: LD_INT 0
35666: PUSH
35667: LD_INT 1
35669: NEG
35670: PUSH
35671: EMPTY
35672: LIST
35673: LIST
35674: PUSH
35675: LD_INT 1
35677: PUSH
35678: LD_INT 0
35680: PUSH
35681: EMPTY
35682: LIST
35683: LIST
35684: PUSH
35685: LD_INT 1
35687: PUSH
35688: LD_INT 1
35690: PUSH
35691: EMPTY
35692: LIST
35693: LIST
35694: PUSH
35695: LD_INT 0
35697: PUSH
35698: LD_INT 1
35700: PUSH
35701: EMPTY
35702: LIST
35703: LIST
35704: PUSH
35705: LD_INT 1
35707: NEG
35708: PUSH
35709: LD_INT 0
35711: PUSH
35712: EMPTY
35713: LIST
35714: LIST
35715: PUSH
35716: LD_INT 1
35718: NEG
35719: PUSH
35720: LD_INT 1
35722: NEG
35723: PUSH
35724: EMPTY
35725: LIST
35726: LIST
35727: PUSH
35728: LD_INT 2
35730: PUSH
35731: LD_INT 1
35733: PUSH
35734: EMPTY
35735: LIST
35736: LIST
35737: PUSH
35738: LD_INT 2
35740: NEG
35741: PUSH
35742: LD_INT 1
35744: NEG
35745: PUSH
35746: EMPTY
35747: LIST
35748: LIST
35749: PUSH
35750: EMPTY
35751: LIST
35752: LIST
35753: LIST
35754: LIST
35755: LIST
35756: LIST
35757: LIST
35758: LIST
35759: LIST
35760: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35761: LD_ADDR_VAR 0 36
35765: PUSH
35766: LD_INT 0
35768: PUSH
35769: LD_INT 0
35771: PUSH
35772: EMPTY
35773: LIST
35774: LIST
35775: PUSH
35776: LD_INT 0
35778: PUSH
35779: LD_INT 1
35781: NEG
35782: PUSH
35783: EMPTY
35784: LIST
35785: LIST
35786: PUSH
35787: LD_INT 1
35789: PUSH
35790: LD_INT 0
35792: PUSH
35793: EMPTY
35794: LIST
35795: LIST
35796: PUSH
35797: LD_INT 1
35799: PUSH
35800: LD_INT 1
35802: PUSH
35803: EMPTY
35804: LIST
35805: LIST
35806: PUSH
35807: LD_INT 0
35809: PUSH
35810: LD_INT 1
35812: PUSH
35813: EMPTY
35814: LIST
35815: LIST
35816: PUSH
35817: LD_INT 1
35819: NEG
35820: PUSH
35821: LD_INT 0
35823: PUSH
35824: EMPTY
35825: LIST
35826: LIST
35827: PUSH
35828: LD_INT 1
35830: NEG
35831: PUSH
35832: LD_INT 1
35834: NEG
35835: PUSH
35836: EMPTY
35837: LIST
35838: LIST
35839: PUSH
35840: LD_INT 1
35842: NEG
35843: PUSH
35844: LD_INT 2
35846: NEG
35847: PUSH
35848: EMPTY
35849: LIST
35850: LIST
35851: PUSH
35852: LD_INT 1
35854: PUSH
35855: LD_INT 2
35857: PUSH
35858: EMPTY
35859: LIST
35860: LIST
35861: PUSH
35862: EMPTY
35863: LIST
35864: LIST
35865: LIST
35866: LIST
35867: LIST
35868: LIST
35869: LIST
35870: LIST
35871: LIST
35872: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35873: LD_ADDR_VAR 0 37
35877: PUSH
35878: LD_INT 0
35880: PUSH
35881: LD_INT 0
35883: PUSH
35884: EMPTY
35885: LIST
35886: LIST
35887: PUSH
35888: LD_INT 0
35890: PUSH
35891: LD_INT 1
35893: NEG
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 1
35901: PUSH
35902: LD_INT 0
35904: PUSH
35905: EMPTY
35906: LIST
35907: LIST
35908: PUSH
35909: LD_INT 1
35911: PUSH
35912: LD_INT 1
35914: PUSH
35915: EMPTY
35916: LIST
35917: LIST
35918: PUSH
35919: LD_INT 0
35921: PUSH
35922: LD_INT 1
35924: PUSH
35925: EMPTY
35926: LIST
35927: LIST
35928: PUSH
35929: LD_INT 1
35931: NEG
35932: PUSH
35933: LD_INT 0
35935: PUSH
35936: EMPTY
35937: LIST
35938: LIST
35939: PUSH
35940: LD_INT 1
35942: NEG
35943: PUSH
35944: LD_INT 1
35946: NEG
35947: PUSH
35948: EMPTY
35949: LIST
35950: LIST
35951: PUSH
35952: LD_INT 1
35954: PUSH
35955: LD_INT 1
35957: NEG
35958: PUSH
35959: EMPTY
35960: LIST
35961: LIST
35962: PUSH
35963: LD_INT 1
35965: NEG
35966: PUSH
35967: LD_INT 1
35969: PUSH
35970: EMPTY
35971: LIST
35972: LIST
35973: PUSH
35974: EMPTY
35975: LIST
35976: LIST
35977: LIST
35978: LIST
35979: LIST
35980: LIST
35981: LIST
35982: LIST
35983: LIST
35984: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35985: LD_ADDR_VAR 0 38
35989: PUSH
35990: LD_INT 0
35992: PUSH
35993: LD_INT 0
35995: PUSH
35996: EMPTY
35997: LIST
35998: LIST
35999: PUSH
36000: LD_INT 0
36002: PUSH
36003: LD_INT 1
36005: NEG
36006: PUSH
36007: EMPTY
36008: LIST
36009: LIST
36010: PUSH
36011: LD_INT 1
36013: PUSH
36014: LD_INT 0
36016: PUSH
36017: EMPTY
36018: LIST
36019: LIST
36020: PUSH
36021: LD_INT 1
36023: PUSH
36024: LD_INT 1
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 0
36033: PUSH
36034: LD_INT 1
36036: PUSH
36037: EMPTY
36038: LIST
36039: LIST
36040: PUSH
36041: LD_INT 1
36043: NEG
36044: PUSH
36045: LD_INT 0
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 1
36054: NEG
36055: PUSH
36056: LD_INT 1
36058: NEG
36059: PUSH
36060: EMPTY
36061: LIST
36062: LIST
36063: PUSH
36064: LD_INT 2
36066: PUSH
36067: LD_INT 1
36069: PUSH
36070: EMPTY
36071: LIST
36072: LIST
36073: PUSH
36074: LD_INT 2
36076: NEG
36077: PUSH
36078: LD_INT 1
36080: NEG
36081: PUSH
36082: EMPTY
36083: LIST
36084: LIST
36085: PUSH
36086: EMPTY
36087: LIST
36088: LIST
36089: LIST
36090: LIST
36091: LIST
36092: LIST
36093: LIST
36094: LIST
36095: LIST
36096: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36097: LD_ADDR_VAR 0 39
36101: PUSH
36102: LD_INT 0
36104: PUSH
36105: LD_INT 0
36107: PUSH
36108: EMPTY
36109: LIST
36110: LIST
36111: PUSH
36112: LD_INT 0
36114: PUSH
36115: LD_INT 1
36117: NEG
36118: PUSH
36119: EMPTY
36120: LIST
36121: LIST
36122: PUSH
36123: LD_INT 1
36125: PUSH
36126: LD_INT 0
36128: PUSH
36129: EMPTY
36130: LIST
36131: LIST
36132: PUSH
36133: LD_INT 1
36135: PUSH
36136: LD_INT 1
36138: PUSH
36139: EMPTY
36140: LIST
36141: LIST
36142: PUSH
36143: LD_INT 0
36145: PUSH
36146: LD_INT 1
36148: PUSH
36149: EMPTY
36150: LIST
36151: LIST
36152: PUSH
36153: LD_INT 1
36155: NEG
36156: PUSH
36157: LD_INT 0
36159: PUSH
36160: EMPTY
36161: LIST
36162: LIST
36163: PUSH
36164: LD_INT 1
36166: NEG
36167: PUSH
36168: LD_INT 1
36170: NEG
36171: PUSH
36172: EMPTY
36173: LIST
36174: LIST
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: LD_INT 2
36182: NEG
36183: PUSH
36184: EMPTY
36185: LIST
36186: LIST
36187: PUSH
36188: LD_INT 1
36190: PUSH
36191: LD_INT 2
36193: PUSH
36194: EMPTY
36195: LIST
36196: LIST
36197: PUSH
36198: EMPTY
36199: LIST
36200: LIST
36201: LIST
36202: LIST
36203: LIST
36204: LIST
36205: LIST
36206: LIST
36207: LIST
36208: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36209: LD_ADDR_VAR 0 40
36213: PUSH
36214: LD_INT 0
36216: PUSH
36217: LD_INT 0
36219: PUSH
36220: EMPTY
36221: LIST
36222: LIST
36223: PUSH
36224: LD_INT 0
36226: PUSH
36227: LD_INT 1
36229: NEG
36230: PUSH
36231: EMPTY
36232: LIST
36233: LIST
36234: PUSH
36235: LD_INT 1
36237: PUSH
36238: LD_INT 0
36240: PUSH
36241: EMPTY
36242: LIST
36243: LIST
36244: PUSH
36245: LD_INT 1
36247: PUSH
36248: LD_INT 1
36250: PUSH
36251: EMPTY
36252: LIST
36253: LIST
36254: PUSH
36255: LD_INT 0
36257: PUSH
36258: LD_INT 1
36260: PUSH
36261: EMPTY
36262: LIST
36263: LIST
36264: PUSH
36265: LD_INT 1
36267: NEG
36268: PUSH
36269: LD_INT 0
36271: PUSH
36272: EMPTY
36273: LIST
36274: LIST
36275: PUSH
36276: LD_INT 1
36278: NEG
36279: PUSH
36280: LD_INT 1
36282: NEG
36283: PUSH
36284: EMPTY
36285: LIST
36286: LIST
36287: PUSH
36288: LD_INT 1
36290: PUSH
36291: LD_INT 1
36293: NEG
36294: PUSH
36295: EMPTY
36296: LIST
36297: LIST
36298: PUSH
36299: LD_INT 1
36301: NEG
36302: PUSH
36303: LD_INT 1
36305: PUSH
36306: EMPTY
36307: LIST
36308: LIST
36309: PUSH
36310: EMPTY
36311: LIST
36312: LIST
36313: LIST
36314: LIST
36315: LIST
36316: LIST
36317: LIST
36318: LIST
36319: LIST
36320: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36321: LD_ADDR_VAR 0 41
36325: PUSH
36326: LD_INT 0
36328: PUSH
36329: LD_INT 0
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: PUSH
36336: LD_INT 0
36338: PUSH
36339: LD_INT 1
36341: NEG
36342: PUSH
36343: EMPTY
36344: LIST
36345: LIST
36346: PUSH
36347: LD_INT 1
36349: PUSH
36350: LD_INT 0
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 1
36359: PUSH
36360: LD_INT 1
36362: PUSH
36363: EMPTY
36364: LIST
36365: LIST
36366: PUSH
36367: LD_INT 0
36369: PUSH
36370: LD_INT 1
36372: PUSH
36373: EMPTY
36374: LIST
36375: LIST
36376: PUSH
36377: LD_INT 1
36379: NEG
36380: PUSH
36381: LD_INT 0
36383: PUSH
36384: EMPTY
36385: LIST
36386: LIST
36387: PUSH
36388: LD_INT 1
36390: NEG
36391: PUSH
36392: LD_INT 1
36394: NEG
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 1
36402: NEG
36403: PUSH
36404: LD_INT 2
36406: NEG
36407: PUSH
36408: EMPTY
36409: LIST
36410: LIST
36411: PUSH
36412: LD_INT 1
36414: PUSH
36415: LD_INT 1
36417: NEG
36418: PUSH
36419: EMPTY
36420: LIST
36421: LIST
36422: PUSH
36423: LD_INT 2
36425: PUSH
36426: LD_INT 0
36428: PUSH
36429: EMPTY
36430: LIST
36431: LIST
36432: PUSH
36433: LD_INT 2
36435: PUSH
36436: LD_INT 1
36438: PUSH
36439: EMPTY
36440: LIST
36441: LIST
36442: PUSH
36443: LD_INT 2
36445: PUSH
36446: LD_INT 2
36448: PUSH
36449: EMPTY
36450: LIST
36451: LIST
36452: PUSH
36453: LD_INT 1
36455: PUSH
36456: LD_INT 2
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 1
36465: NEG
36466: PUSH
36467: LD_INT 1
36469: PUSH
36470: EMPTY
36471: LIST
36472: LIST
36473: PUSH
36474: LD_INT 2
36476: NEG
36477: PUSH
36478: LD_INT 0
36480: PUSH
36481: EMPTY
36482: LIST
36483: LIST
36484: PUSH
36485: LD_INT 2
36487: NEG
36488: PUSH
36489: LD_INT 1
36491: NEG
36492: PUSH
36493: EMPTY
36494: LIST
36495: LIST
36496: PUSH
36497: LD_INT 2
36499: NEG
36500: PUSH
36501: LD_INT 2
36503: NEG
36504: PUSH
36505: EMPTY
36506: LIST
36507: LIST
36508: PUSH
36509: LD_INT 2
36511: NEG
36512: PUSH
36513: LD_INT 3
36515: NEG
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 2
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 3
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 3
36544: PUSH
36545: LD_INT 1
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 3
36554: PUSH
36555: LD_INT 2
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 3
36564: PUSH
36565: LD_INT 3
36567: PUSH
36568: EMPTY
36569: LIST
36570: LIST
36571: PUSH
36572: LD_INT 2
36574: PUSH
36575: LD_INT 3
36577: PUSH
36578: EMPTY
36579: LIST
36580: LIST
36581: PUSH
36582: LD_INT 2
36584: NEG
36585: PUSH
36586: LD_INT 1
36588: PUSH
36589: EMPTY
36590: LIST
36591: LIST
36592: PUSH
36593: LD_INT 3
36595: NEG
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: EMPTY
36601: LIST
36602: LIST
36603: PUSH
36604: LD_INT 3
36606: NEG
36607: PUSH
36608: LD_INT 1
36610: NEG
36611: PUSH
36612: EMPTY
36613: LIST
36614: LIST
36615: PUSH
36616: LD_INT 3
36618: NEG
36619: PUSH
36620: LD_INT 2
36622: NEG
36623: PUSH
36624: EMPTY
36625: LIST
36626: LIST
36627: PUSH
36628: LD_INT 3
36630: NEG
36631: PUSH
36632: LD_INT 3
36634: NEG
36635: PUSH
36636: EMPTY
36637: LIST
36638: LIST
36639: PUSH
36640: EMPTY
36641: LIST
36642: LIST
36643: LIST
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: LIST
36657: LIST
36658: LIST
36659: LIST
36660: LIST
36661: LIST
36662: LIST
36663: LIST
36664: LIST
36665: LIST
36666: LIST
36667: LIST
36668: LIST
36669: LIST
36670: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36671: LD_ADDR_VAR 0 42
36675: PUSH
36676: LD_INT 0
36678: PUSH
36679: LD_INT 0
36681: PUSH
36682: EMPTY
36683: LIST
36684: LIST
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: LD_INT 1
36691: NEG
36692: PUSH
36693: EMPTY
36694: LIST
36695: LIST
36696: PUSH
36697: LD_INT 1
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 1
36709: PUSH
36710: LD_INT 1
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: LD_INT 1
36722: PUSH
36723: EMPTY
36724: LIST
36725: LIST
36726: PUSH
36727: LD_INT 1
36729: NEG
36730: PUSH
36731: LD_INT 0
36733: PUSH
36734: EMPTY
36735: LIST
36736: LIST
36737: PUSH
36738: LD_INT 1
36740: NEG
36741: PUSH
36742: LD_INT 1
36744: NEG
36745: PUSH
36746: EMPTY
36747: LIST
36748: LIST
36749: PUSH
36750: LD_INT 1
36752: NEG
36753: PUSH
36754: LD_INT 2
36756: NEG
36757: PUSH
36758: EMPTY
36759: LIST
36760: LIST
36761: PUSH
36762: LD_INT 0
36764: PUSH
36765: LD_INT 2
36767: NEG
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: LD_INT 1
36775: PUSH
36776: LD_INT 1
36778: NEG
36779: PUSH
36780: EMPTY
36781: LIST
36782: LIST
36783: PUSH
36784: LD_INT 2
36786: PUSH
36787: LD_INT 1
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: PUSH
36794: LD_INT 2
36796: PUSH
36797: LD_INT 2
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PUSH
36804: LD_INT 1
36806: PUSH
36807: LD_INT 2
36809: PUSH
36810: EMPTY
36811: LIST
36812: LIST
36813: PUSH
36814: LD_INT 0
36816: PUSH
36817: LD_INT 2
36819: PUSH
36820: EMPTY
36821: LIST
36822: LIST
36823: PUSH
36824: LD_INT 1
36826: NEG
36827: PUSH
36828: LD_INT 1
36830: PUSH
36831: EMPTY
36832: LIST
36833: LIST
36834: PUSH
36835: LD_INT 2
36837: NEG
36838: PUSH
36839: LD_INT 1
36841: NEG
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PUSH
36847: LD_INT 2
36849: NEG
36850: PUSH
36851: LD_INT 2
36853: NEG
36854: PUSH
36855: EMPTY
36856: LIST
36857: LIST
36858: PUSH
36859: LD_INT 2
36861: NEG
36862: PUSH
36863: LD_INT 3
36865: NEG
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: NEG
36874: PUSH
36875: LD_INT 3
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 0
36885: PUSH
36886: LD_INT 3
36888: NEG
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 1
36896: PUSH
36897: LD_INT 2
36899: NEG
36900: PUSH
36901: EMPTY
36902: LIST
36903: LIST
36904: PUSH
36905: LD_INT 3
36907: PUSH
36908: LD_INT 2
36910: PUSH
36911: EMPTY
36912: LIST
36913: LIST
36914: PUSH
36915: LD_INT 3
36917: PUSH
36918: LD_INT 3
36920: PUSH
36921: EMPTY
36922: LIST
36923: LIST
36924: PUSH
36925: LD_INT 2
36927: PUSH
36928: LD_INT 3
36930: PUSH
36931: EMPTY
36932: LIST
36933: LIST
36934: PUSH
36935: LD_INT 1
36937: PUSH
36938: LD_INT 3
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PUSH
36945: LD_INT 0
36947: PUSH
36948: LD_INT 3
36950: PUSH
36951: EMPTY
36952: LIST
36953: LIST
36954: PUSH
36955: LD_INT 1
36957: NEG
36958: PUSH
36959: LD_INT 2
36961: PUSH
36962: EMPTY
36963: LIST
36964: LIST
36965: PUSH
36966: LD_INT 3
36968: NEG
36969: PUSH
36970: LD_INT 2
36972: NEG
36973: PUSH
36974: EMPTY
36975: LIST
36976: LIST
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: LD_INT 3
36984: NEG
36985: PUSH
36986: EMPTY
36987: LIST
36988: LIST
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: LIST
36994: LIST
36995: LIST
36996: LIST
36997: LIST
36998: LIST
36999: LIST
37000: LIST
37001: LIST
37002: LIST
37003: LIST
37004: LIST
37005: LIST
37006: LIST
37007: LIST
37008: LIST
37009: LIST
37010: LIST
37011: LIST
37012: LIST
37013: LIST
37014: LIST
37015: LIST
37016: LIST
37017: LIST
37018: LIST
37019: LIST
37020: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37021: LD_ADDR_VAR 0 43
37025: PUSH
37026: LD_INT 0
37028: PUSH
37029: LD_INT 0
37031: PUSH
37032: EMPTY
37033: LIST
37034: LIST
37035: PUSH
37036: LD_INT 0
37038: PUSH
37039: LD_INT 1
37041: NEG
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: LD_INT 0
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 1
37059: PUSH
37060: LD_INT 1
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 0
37069: PUSH
37070: LD_INT 1
37072: PUSH
37073: EMPTY
37074: LIST
37075: LIST
37076: PUSH
37077: LD_INT 1
37079: NEG
37080: PUSH
37081: LD_INT 0
37083: PUSH
37084: EMPTY
37085: LIST
37086: LIST
37087: PUSH
37088: LD_INT 1
37090: NEG
37091: PUSH
37092: LD_INT 1
37094: NEG
37095: PUSH
37096: EMPTY
37097: LIST
37098: LIST
37099: PUSH
37100: LD_INT 1
37102: NEG
37103: PUSH
37104: LD_INT 2
37106: NEG
37107: PUSH
37108: EMPTY
37109: LIST
37110: LIST
37111: PUSH
37112: LD_INT 0
37114: PUSH
37115: LD_INT 2
37117: NEG
37118: PUSH
37119: EMPTY
37120: LIST
37121: LIST
37122: PUSH
37123: LD_INT 1
37125: PUSH
37126: LD_INT 1
37128: NEG
37129: PUSH
37130: EMPTY
37131: LIST
37132: LIST
37133: PUSH
37134: LD_INT 2
37136: PUSH
37137: LD_INT 0
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PUSH
37144: LD_INT 2
37146: PUSH
37147: LD_INT 1
37149: PUSH
37150: EMPTY
37151: LIST
37152: LIST
37153: PUSH
37154: LD_INT 1
37156: PUSH
37157: LD_INT 2
37159: PUSH
37160: EMPTY
37161: LIST
37162: LIST
37163: PUSH
37164: LD_INT 0
37166: PUSH
37167: LD_INT 2
37169: PUSH
37170: EMPTY
37171: LIST
37172: LIST
37173: PUSH
37174: LD_INT 1
37176: NEG
37177: PUSH
37178: LD_INT 1
37180: PUSH
37181: EMPTY
37182: LIST
37183: LIST
37184: PUSH
37185: LD_INT 2
37187: NEG
37188: PUSH
37189: LD_INT 0
37191: PUSH
37192: EMPTY
37193: LIST
37194: LIST
37195: PUSH
37196: LD_INT 2
37198: NEG
37199: PUSH
37200: LD_INT 1
37202: NEG
37203: PUSH
37204: EMPTY
37205: LIST
37206: LIST
37207: PUSH
37208: LD_INT 1
37210: NEG
37211: PUSH
37212: LD_INT 3
37214: NEG
37215: PUSH
37216: EMPTY
37217: LIST
37218: LIST
37219: PUSH
37220: LD_INT 0
37222: PUSH
37223: LD_INT 3
37225: NEG
37226: PUSH
37227: EMPTY
37228: LIST
37229: LIST
37230: PUSH
37231: LD_INT 1
37233: PUSH
37234: LD_INT 2
37236: NEG
37237: PUSH
37238: EMPTY
37239: LIST
37240: LIST
37241: PUSH
37242: LD_INT 2
37244: PUSH
37245: LD_INT 1
37247: NEG
37248: PUSH
37249: EMPTY
37250: LIST
37251: LIST
37252: PUSH
37253: LD_INT 3
37255: PUSH
37256: LD_INT 0
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: PUSH
37263: LD_INT 3
37265: PUSH
37266: LD_INT 1
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: LD_INT 1
37275: PUSH
37276: LD_INT 3
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: PUSH
37283: LD_INT 0
37285: PUSH
37286: LD_INT 3
37288: PUSH
37289: EMPTY
37290: LIST
37291: LIST
37292: PUSH
37293: LD_INT 1
37295: NEG
37296: PUSH
37297: LD_INT 2
37299: PUSH
37300: EMPTY
37301: LIST
37302: LIST
37303: PUSH
37304: LD_INT 2
37306: NEG
37307: PUSH
37308: LD_INT 1
37310: PUSH
37311: EMPTY
37312: LIST
37313: LIST
37314: PUSH
37315: LD_INT 3
37317: NEG
37318: PUSH
37319: LD_INT 0
37321: PUSH
37322: EMPTY
37323: LIST
37324: LIST
37325: PUSH
37326: LD_INT 3
37328: NEG
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: EMPTY
37335: LIST
37336: LIST
37337: PUSH
37338: EMPTY
37339: LIST
37340: LIST
37341: LIST
37342: LIST
37343: LIST
37344: LIST
37345: LIST
37346: LIST
37347: LIST
37348: LIST
37349: LIST
37350: LIST
37351: LIST
37352: LIST
37353: LIST
37354: LIST
37355: LIST
37356: LIST
37357: LIST
37358: LIST
37359: LIST
37360: LIST
37361: LIST
37362: LIST
37363: LIST
37364: LIST
37365: LIST
37366: LIST
37367: LIST
37368: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37369: LD_ADDR_VAR 0 44
37373: PUSH
37374: LD_INT 0
37376: PUSH
37377: LD_INT 0
37379: PUSH
37380: EMPTY
37381: LIST
37382: LIST
37383: PUSH
37384: LD_INT 0
37386: PUSH
37387: LD_INT 1
37389: NEG
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 1
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 1
37407: PUSH
37408: LD_INT 1
37410: PUSH
37411: EMPTY
37412: LIST
37413: LIST
37414: PUSH
37415: LD_INT 0
37417: PUSH
37418: LD_INT 1
37420: PUSH
37421: EMPTY
37422: LIST
37423: LIST
37424: PUSH
37425: LD_INT 1
37427: NEG
37428: PUSH
37429: LD_INT 0
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 1
37438: NEG
37439: PUSH
37440: LD_INT 1
37442: NEG
37443: PUSH
37444: EMPTY
37445: LIST
37446: LIST
37447: PUSH
37448: LD_INT 1
37450: NEG
37451: PUSH
37452: LD_INT 2
37454: NEG
37455: PUSH
37456: EMPTY
37457: LIST
37458: LIST
37459: PUSH
37460: LD_INT 1
37462: PUSH
37463: LD_INT 1
37465: NEG
37466: PUSH
37467: EMPTY
37468: LIST
37469: LIST
37470: PUSH
37471: LD_INT 2
37473: PUSH
37474: LD_INT 0
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 2
37483: PUSH
37484: LD_INT 1
37486: PUSH
37487: EMPTY
37488: LIST
37489: LIST
37490: PUSH
37491: LD_INT 2
37493: PUSH
37494: LD_INT 2
37496: PUSH
37497: EMPTY
37498: LIST
37499: LIST
37500: PUSH
37501: LD_INT 1
37503: PUSH
37504: LD_INT 2
37506: PUSH
37507: EMPTY
37508: LIST
37509: LIST
37510: PUSH
37511: LD_INT 1
37513: NEG
37514: PUSH
37515: LD_INT 1
37517: PUSH
37518: EMPTY
37519: LIST
37520: LIST
37521: PUSH
37522: LD_INT 2
37524: NEG
37525: PUSH
37526: LD_INT 0
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 2
37535: NEG
37536: PUSH
37537: LD_INT 1
37539: NEG
37540: PUSH
37541: EMPTY
37542: LIST
37543: LIST
37544: PUSH
37545: LD_INT 2
37547: NEG
37548: PUSH
37549: LD_INT 2
37551: NEG
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: PUSH
37557: LD_INT 2
37559: NEG
37560: PUSH
37561: LD_INT 3
37563: NEG
37564: PUSH
37565: EMPTY
37566: LIST
37567: LIST
37568: PUSH
37569: LD_INT 2
37571: PUSH
37572: LD_INT 1
37574: NEG
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: LD_INT 3
37582: PUSH
37583: LD_INT 0
37585: PUSH
37586: EMPTY
37587: LIST
37588: LIST
37589: PUSH
37590: LD_INT 3
37592: PUSH
37593: LD_INT 1
37595: PUSH
37596: EMPTY
37597: LIST
37598: LIST
37599: PUSH
37600: LD_INT 3
37602: PUSH
37603: LD_INT 2
37605: PUSH
37606: EMPTY
37607: LIST
37608: LIST
37609: PUSH
37610: LD_INT 3
37612: PUSH
37613: LD_INT 3
37615: PUSH
37616: EMPTY
37617: LIST
37618: LIST
37619: PUSH
37620: LD_INT 2
37622: PUSH
37623: LD_INT 3
37625: PUSH
37626: EMPTY
37627: LIST
37628: LIST
37629: PUSH
37630: LD_INT 2
37632: NEG
37633: PUSH
37634: LD_INT 1
37636: PUSH
37637: EMPTY
37638: LIST
37639: LIST
37640: PUSH
37641: LD_INT 3
37643: NEG
37644: PUSH
37645: LD_INT 0
37647: PUSH
37648: EMPTY
37649: LIST
37650: LIST
37651: PUSH
37652: LD_INT 3
37654: NEG
37655: PUSH
37656: LD_INT 1
37658: NEG
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PUSH
37664: LD_INT 3
37666: NEG
37667: PUSH
37668: LD_INT 2
37670: NEG
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 3
37678: NEG
37679: PUSH
37680: LD_INT 3
37682: NEG
37683: PUSH
37684: EMPTY
37685: LIST
37686: LIST
37687: PUSH
37688: EMPTY
37689: LIST
37690: LIST
37691: LIST
37692: LIST
37693: LIST
37694: LIST
37695: LIST
37696: LIST
37697: LIST
37698: LIST
37699: LIST
37700: LIST
37701: LIST
37702: LIST
37703: LIST
37704: LIST
37705: LIST
37706: LIST
37707: LIST
37708: LIST
37709: LIST
37710: LIST
37711: LIST
37712: LIST
37713: LIST
37714: LIST
37715: LIST
37716: LIST
37717: LIST
37718: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37719: LD_ADDR_VAR 0 45
37723: PUSH
37724: LD_INT 0
37726: PUSH
37727: LD_INT 0
37729: PUSH
37730: EMPTY
37731: LIST
37732: LIST
37733: PUSH
37734: LD_INT 0
37736: PUSH
37737: LD_INT 1
37739: NEG
37740: PUSH
37741: EMPTY
37742: LIST
37743: LIST
37744: PUSH
37745: LD_INT 1
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 1
37757: PUSH
37758: LD_INT 1
37760: PUSH
37761: EMPTY
37762: LIST
37763: LIST
37764: PUSH
37765: LD_INT 0
37767: PUSH
37768: LD_INT 1
37770: PUSH
37771: EMPTY
37772: LIST
37773: LIST
37774: PUSH
37775: LD_INT 1
37777: NEG
37778: PUSH
37779: LD_INT 0
37781: PUSH
37782: EMPTY
37783: LIST
37784: LIST
37785: PUSH
37786: LD_INT 1
37788: NEG
37789: PUSH
37790: LD_INT 1
37792: NEG
37793: PUSH
37794: EMPTY
37795: LIST
37796: LIST
37797: PUSH
37798: LD_INT 1
37800: NEG
37801: PUSH
37802: LD_INT 2
37804: NEG
37805: PUSH
37806: EMPTY
37807: LIST
37808: LIST
37809: PUSH
37810: LD_INT 0
37812: PUSH
37813: LD_INT 2
37815: NEG
37816: PUSH
37817: EMPTY
37818: LIST
37819: LIST
37820: PUSH
37821: LD_INT 1
37823: PUSH
37824: LD_INT 1
37826: NEG
37827: PUSH
37828: EMPTY
37829: LIST
37830: LIST
37831: PUSH
37832: LD_INT 2
37834: PUSH
37835: LD_INT 1
37837: PUSH
37838: EMPTY
37839: LIST
37840: LIST
37841: PUSH
37842: LD_INT 2
37844: PUSH
37845: LD_INT 2
37847: PUSH
37848: EMPTY
37849: LIST
37850: LIST
37851: PUSH
37852: LD_INT 1
37854: PUSH
37855: LD_INT 2
37857: PUSH
37858: EMPTY
37859: LIST
37860: LIST
37861: PUSH
37862: LD_INT 0
37864: PUSH
37865: LD_INT 2
37867: PUSH
37868: EMPTY
37869: LIST
37870: LIST
37871: PUSH
37872: LD_INT 1
37874: NEG
37875: PUSH
37876: LD_INT 1
37878: PUSH
37879: EMPTY
37880: LIST
37881: LIST
37882: PUSH
37883: LD_INT 2
37885: NEG
37886: PUSH
37887: LD_INT 1
37889: NEG
37890: PUSH
37891: EMPTY
37892: LIST
37893: LIST
37894: PUSH
37895: LD_INT 2
37897: NEG
37898: PUSH
37899: LD_INT 2
37901: NEG
37902: PUSH
37903: EMPTY
37904: LIST
37905: LIST
37906: PUSH
37907: LD_INT 2
37909: NEG
37910: PUSH
37911: LD_INT 3
37913: NEG
37914: PUSH
37915: EMPTY
37916: LIST
37917: LIST
37918: PUSH
37919: LD_INT 1
37921: NEG
37922: PUSH
37923: LD_INT 3
37925: NEG
37926: PUSH
37927: EMPTY
37928: LIST
37929: LIST
37930: PUSH
37931: LD_INT 0
37933: PUSH
37934: LD_INT 3
37936: NEG
37937: PUSH
37938: EMPTY
37939: LIST
37940: LIST
37941: PUSH
37942: LD_INT 1
37944: PUSH
37945: LD_INT 2
37947: NEG
37948: PUSH
37949: EMPTY
37950: LIST
37951: LIST
37952: PUSH
37953: LD_INT 3
37955: PUSH
37956: LD_INT 2
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 3
37965: PUSH
37966: LD_INT 3
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 2
37975: PUSH
37976: LD_INT 3
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 1
37985: PUSH
37986: LD_INT 3
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 0
37995: PUSH
37996: LD_INT 3
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 1
38005: NEG
38006: PUSH
38007: LD_INT 2
38009: PUSH
38010: EMPTY
38011: LIST
38012: LIST
38013: PUSH
38014: LD_INT 3
38016: NEG
38017: PUSH
38018: LD_INT 2
38020: NEG
38021: PUSH
38022: EMPTY
38023: LIST
38024: LIST
38025: PUSH
38026: LD_INT 3
38028: NEG
38029: PUSH
38030: LD_INT 3
38032: NEG
38033: PUSH
38034: EMPTY
38035: LIST
38036: LIST
38037: PUSH
38038: EMPTY
38039: LIST
38040: LIST
38041: LIST
38042: LIST
38043: LIST
38044: LIST
38045: LIST
38046: LIST
38047: LIST
38048: LIST
38049: LIST
38050: LIST
38051: LIST
38052: LIST
38053: LIST
38054: LIST
38055: LIST
38056: LIST
38057: LIST
38058: LIST
38059: LIST
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38069: LD_ADDR_VAR 0 46
38073: PUSH
38074: LD_INT 0
38076: PUSH
38077: LD_INT 0
38079: PUSH
38080: EMPTY
38081: LIST
38082: LIST
38083: PUSH
38084: LD_INT 0
38086: PUSH
38087: LD_INT 1
38089: NEG
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 1
38097: PUSH
38098: LD_INT 0
38100: PUSH
38101: EMPTY
38102: LIST
38103: LIST
38104: PUSH
38105: LD_INT 1
38107: PUSH
38108: LD_INT 1
38110: PUSH
38111: EMPTY
38112: LIST
38113: LIST
38114: PUSH
38115: LD_INT 0
38117: PUSH
38118: LD_INT 1
38120: PUSH
38121: EMPTY
38122: LIST
38123: LIST
38124: PUSH
38125: LD_INT 1
38127: NEG
38128: PUSH
38129: LD_INT 0
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: NEG
38139: PUSH
38140: LD_INT 1
38142: NEG
38143: PUSH
38144: EMPTY
38145: LIST
38146: LIST
38147: PUSH
38148: LD_INT 1
38150: NEG
38151: PUSH
38152: LD_INT 2
38154: NEG
38155: PUSH
38156: EMPTY
38157: LIST
38158: LIST
38159: PUSH
38160: LD_INT 0
38162: PUSH
38163: LD_INT 2
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 1
38173: PUSH
38174: LD_INT 1
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 2
38184: PUSH
38185: LD_INT 0
38187: PUSH
38188: EMPTY
38189: LIST
38190: LIST
38191: PUSH
38192: LD_INT 2
38194: PUSH
38195: LD_INT 1
38197: PUSH
38198: EMPTY
38199: LIST
38200: LIST
38201: PUSH
38202: LD_INT 1
38204: PUSH
38205: LD_INT 2
38207: PUSH
38208: EMPTY
38209: LIST
38210: LIST
38211: PUSH
38212: LD_INT 0
38214: PUSH
38215: LD_INT 2
38217: PUSH
38218: EMPTY
38219: LIST
38220: LIST
38221: PUSH
38222: LD_INT 1
38224: NEG
38225: PUSH
38226: LD_INT 1
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 2
38235: NEG
38236: PUSH
38237: LD_INT 0
38239: PUSH
38240: EMPTY
38241: LIST
38242: LIST
38243: PUSH
38244: LD_INT 2
38246: NEG
38247: PUSH
38248: LD_INT 1
38250: NEG
38251: PUSH
38252: EMPTY
38253: LIST
38254: LIST
38255: PUSH
38256: LD_INT 1
38258: NEG
38259: PUSH
38260: LD_INT 3
38262: NEG
38263: PUSH
38264: EMPTY
38265: LIST
38266: LIST
38267: PUSH
38268: LD_INT 0
38270: PUSH
38271: LD_INT 3
38273: NEG
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PUSH
38279: LD_INT 1
38281: PUSH
38282: LD_INT 2
38284: NEG
38285: PUSH
38286: EMPTY
38287: LIST
38288: LIST
38289: PUSH
38290: LD_INT 2
38292: PUSH
38293: LD_INT 1
38295: NEG
38296: PUSH
38297: EMPTY
38298: LIST
38299: LIST
38300: PUSH
38301: LD_INT 3
38303: PUSH
38304: LD_INT 0
38306: PUSH
38307: EMPTY
38308: LIST
38309: LIST
38310: PUSH
38311: LD_INT 3
38313: PUSH
38314: LD_INT 1
38316: PUSH
38317: EMPTY
38318: LIST
38319: LIST
38320: PUSH
38321: LD_INT 1
38323: PUSH
38324: LD_INT 3
38326: PUSH
38327: EMPTY
38328: LIST
38329: LIST
38330: PUSH
38331: LD_INT 0
38333: PUSH
38334: LD_INT 3
38336: PUSH
38337: EMPTY
38338: LIST
38339: LIST
38340: PUSH
38341: LD_INT 1
38343: NEG
38344: PUSH
38345: LD_INT 2
38347: PUSH
38348: EMPTY
38349: LIST
38350: LIST
38351: PUSH
38352: LD_INT 2
38354: NEG
38355: PUSH
38356: LD_INT 1
38358: PUSH
38359: EMPTY
38360: LIST
38361: LIST
38362: PUSH
38363: LD_INT 3
38365: NEG
38366: PUSH
38367: LD_INT 0
38369: PUSH
38370: EMPTY
38371: LIST
38372: LIST
38373: PUSH
38374: LD_INT 3
38376: NEG
38377: PUSH
38378: LD_INT 1
38380: NEG
38381: PUSH
38382: EMPTY
38383: LIST
38384: LIST
38385: PUSH
38386: EMPTY
38387: LIST
38388: LIST
38389: LIST
38390: LIST
38391: LIST
38392: LIST
38393: LIST
38394: LIST
38395: LIST
38396: LIST
38397: LIST
38398: LIST
38399: LIST
38400: LIST
38401: LIST
38402: LIST
38403: LIST
38404: LIST
38405: LIST
38406: LIST
38407: LIST
38408: LIST
38409: LIST
38410: LIST
38411: LIST
38412: LIST
38413: LIST
38414: LIST
38415: LIST
38416: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38417: LD_ADDR_VAR 0 47
38421: PUSH
38422: LD_INT 0
38424: PUSH
38425: LD_INT 0
38427: PUSH
38428: EMPTY
38429: LIST
38430: LIST
38431: PUSH
38432: LD_INT 0
38434: PUSH
38435: LD_INT 1
38437: NEG
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 1
38445: PUSH
38446: LD_INT 0
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: PUSH
38456: LD_INT 1
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: LD_INT 1
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 1
38475: NEG
38476: PUSH
38477: LD_INT 0
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 1
38486: NEG
38487: PUSH
38488: LD_INT 1
38490: NEG
38491: PUSH
38492: EMPTY
38493: LIST
38494: LIST
38495: PUSH
38496: LD_INT 1
38498: NEG
38499: PUSH
38500: LD_INT 2
38502: NEG
38503: PUSH
38504: EMPTY
38505: LIST
38506: LIST
38507: PUSH
38508: LD_INT 0
38510: PUSH
38511: LD_INT 2
38513: NEG
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: LD_INT 1
38521: PUSH
38522: LD_INT 1
38524: NEG
38525: PUSH
38526: EMPTY
38527: LIST
38528: LIST
38529: PUSH
38530: LD_INT 2
38532: NEG
38533: PUSH
38534: LD_INT 1
38536: NEG
38537: PUSH
38538: EMPTY
38539: LIST
38540: LIST
38541: PUSH
38542: LD_INT 2
38544: NEG
38545: PUSH
38546: LD_INT 2
38548: NEG
38549: PUSH
38550: EMPTY
38551: LIST
38552: LIST
38553: PUSH
38554: EMPTY
38555: LIST
38556: LIST
38557: LIST
38558: LIST
38559: LIST
38560: LIST
38561: LIST
38562: LIST
38563: LIST
38564: LIST
38565: LIST
38566: LIST
38567: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38568: LD_ADDR_VAR 0 48
38572: PUSH
38573: LD_INT 0
38575: PUSH
38576: LD_INT 0
38578: PUSH
38579: EMPTY
38580: LIST
38581: LIST
38582: PUSH
38583: LD_INT 0
38585: PUSH
38586: LD_INT 1
38588: NEG
38589: PUSH
38590: EMPTY
38591: LIST
38592: LIST
38593: PUSH
38594: LD_INT 1
38596: PUSH
38597: LD_INT 0
38599: PUSH
38600: EMPTY
38601: LIST
38602: LIST
38603: PUSH
38604: LD_INT 1
38606: PUSH
38607: LD_INT 1
38609: PUSH
38610: EMPTY
38611: LIST
38612: LIST
38613: PUSH
38614: LD_INT 0
38616: PUSH
38617: LD_INT 1
38619: PUSH
38620: EMPTY
38621: LIST
38622: LIST
38623: PUSH
38624: LD_INT 1
38626: NEG
38627: PUSH
38628: LD_INT 0
38630: PUSH
38631: EMPTY
38632: LIST
38633: LIST
38634: PUSH
38635: LD_INT 1
38637: NEG
38638: PUSH
38639: LD_INT 1
38641: NEG
38642: PUSH
38643: EMPTY
38644: LIST
38645: LIST
38646: PUSH
38647: LD_INT 1
38649: NEG
38650: PUSH
38651: LD_INT 2
38653: NEG
38654: PUSH
38655: EMPTY
38656: LIST
38657: LIST
38658: PUSH
38659: LD_INT 0
38661: PUSH
38662: LD_INT 2
38664: NEG
38665: PUSH
38666: EMPTY
38667: LIST
38668: LIST
38669: PUSH
38670: LD_INT 1
38672: PUSH
38673: LD_INT 1
38675: NEG
38676: PUSH
38677: EMPTY
38678: LIST
38679: LIST
38680: PUSH
38681: LD_INT 2
38683: PUSH
38684: LD_INT 0
38686: PUSH
38687: EMPTY
38688: LIST
38689: LIST
38690: PUSH
38691: LD_INT 2
38693: PUSH
38694: LD_INT 1
38696: PUSH
38697: EMPTY
38698: LIST
38699: LIST
38700: PUSH
38701: EMPTY
38702: LIST
38703: LIST
38704: LIST
38705: LIST
38706: LIST
38707: LIST
38708: LIST
38709: LIST
38710: LIST
38711: LIST
38712: LIST
38713: LIST
38714: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38715: LD_ADDR_VAR 0 49
38719: PUSH
38720: LD_INT 0
38722: PUSH
38723: LD_INT 0
38725: PUSH
38726: EMPTY
38727: LIST
38728: LIST
38729: PUSH
38730: LD_INT 0
38732: PUSH
38733: LD_INT 1
38735: NEG
38736: PUSH
38737: EMPTY
38738: LIST
38739: LIST
38740: PUSH
38741: LD_INT 1
38743: PUSH
38744: LD_INT 0
38746: PUSH
38747: EMPTY
38748: LIST
38749: LIST
38750: PUSH
38751: LD_INT 1
38753: PUSH
38754: LD_INT 1
38756: PUSH
38757: EMPTY
38758: LIST
38759: LIST
38760: PUSH
38761: LD_INT 0
38763: PUSH
38764: LD_INT 1
38766: PUSH
38767: EMPTY
38768: LIST
38769: LIST
38770: PUSH
38771: LD_INT 1
38773: NEG
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: EMPTY
38779: LIST
38780: LIST
38781: PUSH
38782: LD_INT 1
38784: NEG
38785: PUSH
38786: LD_INT 1
38788: NEG
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 1
38796: PUSH
38797: LD_INT 1
38799: NEG
38800: PUSH
38801: EMPTY
38802: LIST
38803: LIST
38804: PUSH
38805: LD_INT 2
38807: PUSH
38808: LD_INT 0
38810: PUSH
38811: EMPTY
38812: LIST
38813: LIST
38814: PUSH
38815: LD_INT 2
38817: PUSH
38818: LD_INT 1
38820: PUSH
38821: EMPTY
38822: LIST
38823: LIST
38824: PUSH
38825: LD_INT 2
38827: PUSH
38828: LD_INT 2
38830: PUSH
38831: EMPTY
38832: LIST
38833: LIST
38834: PUSH
38835: LD_INT 1
38837: PUSH
38838: LD_INT 2
38840: PUSH
38841: EMPTY
38842: LIST
38843: LIST
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: LIST
38849: LIST
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: LIST
38858: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38859: LD_ADDR_VAR 0 50
38863: PUSH
38864: LD_INT 0
38866: PUSH
38867: LD_INT 0
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 0
38876: PUSH
38877: LD_INT 1
38879: NEG
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: PUSH
38888: LD_INT 0
38890: PUSH
38891: EMPTY
38892: LIST
38893: LIST
38894: PUSH
38895: LD_INT 1
38897: PUSH
38898: LD_INT 1
38900: PUSH
38901: EMPTY
38902: LIST
38903: LIST
38904: PUSH
38905: LD_INT 0
38907: PUSH
38908: LD_INT 1
38910: PUSH
38911: EMPTY
38912: LIST
38913: LIST
38914: PUSH
38915: LD_INT 1
38917: NEG
38918: PUSH
38919: LD_INT 0
38921: PUSH
38922: EMPTY
38923: LIST
38924: LIST
38925: PUSH
38926: LD_INT 1
38928: NEG
38929: PUSH
38930: LD_INT 1
38932: NEG
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 2
38940: PUSH
38941: LD_INT 1
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: LD_INT 2
38950: PUSH
38951: LD_INT 2
38953: PUSH
38954: EMPTY
38955: LIST
38956: LIST
38957: PUSH
38958: LD_INT 1
38960: PUSH
38961: LD_INT 2
38963: PUSH
38964: EMPTY
38965: LIST
38966: LIST
38967: PUSH
38968: LD_INT 0
38970: PUSH
38971: LD_INT 2
38973: PUSH
38974: EMPTY
38975: LIST
38976: LIST
38977: PUSH
38978: LD_INT 1
38980: NEG
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: EMPTY
38986: LIST
38987: LIST
38988: PUSH
38989: EMPTY
38990: LIST
38991: LIST
38992: LIST
38993: LIST
38994: LIST
38995: LIST
38996: LIST
38997: LIST
38998: LIST
38999: LIST
39000: LIST
39001: LIST
39002: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39003: LD_ADDR_VAR 0 51
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: LD_INT 0
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 0
39020: PUSH
39021: LD_INT 1
39023: NEG
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 1
39031: PUSH
39032: LD_INT 0
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PUSH
39039: LD_INT 1
39041: PUSH
39042: LD_INT 1
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: LD_INT 1
39054: PUSH
39055: EMPTY
39056: LIST
39057: LIST
39058: PUSH
39059: LD_INT 1
39061: NEG
39062: PUSH
39063: LD_INT 0
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: NEG
39073: PUSH
39074: LD_INT 1
39076: NEG
39077: PUSH
39078: EMPTY
39079: LIST
39080: LIST
39081: PUSH
39082: LD_INT 1
39084: PUSH
39085: LD_INT 2
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: LD_INT 0
39094: PUSH
39095: LD_INT 2
39097: PUSH
39098: EMPTY
39099: LIST
39100: LIST
39101: PUSH
39102: LD_INT 1
39104: NEG
39105: PUSH
39106: LD_INT 1
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: LD_INT 2
39115: NEG
39116: PUSH
39117: LD_INT 0
39119: PUSH
39120: EMPTY
39121: LIST
39122: LIST
39123: PUSH
39124: LD_INT 2
39126: NEG
39127: PUSH
39128: LD_INT 1
39130: NEG
39131: PUSH
39132: EMPTY
39133: LIST
39134: LIST
39135: PUSH
39136: EMPTY
39137: LIST
39138: LIST
39139: LIST
39140: LIST
39141: LIST
39142: LIST
39143: LIST
39144: LIST
39145: LIST
39146: LIST
39147: LIST
39148: LIST
39149: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39150: LD_ADDR_VAR 0 52
39154: PUSH
39155: LD_INT 0
39157: PUSH
39158: LD_INT 0
39160: PUSH
39161: EMPTY
39162: LIST
39163: LIST
39164: PUSH
39165: LD_INT 0
39167: PUSH
39168: LD_INT 1
39170: NEG
39171: PUSH
39172: EMPTY
39173: LIST
39174: LIST
39175: PUSH
39176: LD_INT 1
39178: PUSH
39179: LD_INT 0
39181: PUSH
39182: EMPTY
39183: LIST
39184: LIST
39185: PUSH
39186: LD_INT 1
39188: PUSH
39189: LD_INT 1
39191: PUSH
39192: EMPTY
39193: LIST
39194: LIST
39195: PUSH
39196: LD_INT 0
39198: PUSH
39199: LD_INT 1
39201: PUSH
39202: EMPTY
39203: LIST
39204: LIST
39205: PUSH
39206: LD_INT 1
39208: NEG
39209: PUSH
39210: LD_INT 0
39212: PUSH
39213: EMPTY
39214: LIST
39215: LIST
39216: PUSH
39217: LD_INT 1
39219: NEG
39220: PUSH
39221: LD_INT 1
39223: NEG
39224: PUSH
39225: EMPTY
39226: LIST
39227: LIST
39228: PUSH
39229: LD_INT 1
39231: NEG
39232: PUSH
39233: LD_INT 2
39235: NEG
39236: PUSH
39237: EMPTY
39238: LIST
39239: LIST
39240: PUSH
39241: LD_INT 1
39243: NEG
39244: PUSH
39245: LD_INT 1
39247: PUSH
39248: EMPTY
39249: LIST
39250: LIST
39251: PUSH
39252: LD_INT 2
39254: NEG
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: EMPTY
39260: LIST
39261: LIST
39262: PUSH
39263: LD_INT 2
39265: NEG
39266: PUSH
39267: LD_INT 1
39269: NEG
39270: PUSH
39271: EMPTY
39272: LIST
39273: LIST
39274: PUSH
39275: LD_INT 2
39277: NEG
39278: PUSH
39279: LD_INT 2
39281: NEG
39282: PUSH
39283: EMPTY
39284: LIST
39285: LIST
39286: PUSH
39287: EMPTY
39288: LIST
39289: LIST
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: LIST
39298: LIST
39299: LIST
39300: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39301: LD_ADDR_VAR 0 53
39305: PUSH
39306: LD_INT 0
39308: PUSH
39309: LD_INT 0
39311: PUSH
39312: EMPTY
39313: LIST
39314: LIST
39315: PUSH
39316: LD_INT 0
39318: PUSH
39319: LD_INT 1
39321: NEG
39322: PUSH
39323: EMPTY
39324: LIST
39325: LIST
39326: PUSH
39327: LD_INT 1
39329: PUSH
39330: LD_INT 0
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: LD_INT 1
39342: PUSH
39343: EMPTY
39344: LIST
39345: LIST
39346: PUSH
39347: LD_INT 0
39349: PUSH
39350: LD_INT 1
39352: PUSH
39353: EMPTY
39354: LIST
39355: LIST
39356: PUSH
39357: LD_INT 1
39359: NEG
39360: PUSH
39361: LD_INT 0
39363: PUSH
39364: EMPTY
39365: LIST
39366: LIST
39367: PUSH
39368: LD_INT 1
39370: NEG
39371: PUSH
39372: LD_INT 1
39374: NEG
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PUSH
39380: LD_INT 1
39382: NEG
39383: PUSH
39384: LD_INT 2
39386: NEG
39387: PUSH
39388: EMPTY
39389: LIST
39390: LIST
39391: PUSH
39392: LD_INT 0
39394: PUSH
39395: LD_INT 2
39397: NEG
39398: PUSH
39399: EMPTY
39400: LIST
39401: LIST
39402: PUSH
39403: LD_INT 1
39405: PUSH
39406: LD_INT 1
39408: NEG
39409: PUSH
39410: EMPTY
39411: LIST
39412: LIST
39413: PUSH
39414: LD_INT 2
39416: PUSH
39417: LD_INT 0
39419: PUSH
39420: EMPTY
39421: LIST
39422: LIST
39423: PUSH
39424: LD_INT 2
39426: PUSH
39427: LD_INT 1
39429: PUSH
39430: EMPTY
39431: LIST
39432: LIST
39433: PUSH
39434: LD_INT 2
39436: PUSH
39437: LD_INT 2
39439: PUSH
39440: EMPTY
39441: LIST
39442: LIST
39443: PUSH
39444: LD_INT 1
39446: PUSH
39447: LD_INT 2
39449: PUSH
39450: EMPTY
39451: LIST
39452: LIST
39453: PUSH
39454: LD_INT 0
39456: PUSH
39457: LD_INT 2
39459: PUSH
39460: EMPTY
39461: LIST
39462: LIST
39463: PUSH
39464: LD_INT 1
39466: NEG
39467: PUSH
39468: LD_INT 1
39470: PUSH
39471: EMPTY
39472: LIST
39473: LIST
39474: PUSH
39475: LD_INT 2
39477: NEG
39478: PUSH
39479: LD_INT 0
39481: PUSH
39482: EMPTY
39483: LIST
39484: LIST
39485: PUSH
39486: LD_INT 2
39488: NEG
39489: PUSH
39490: LD_INT 1
39492: NEG
39493: PUSH
39494: EMPTY
39495: LIST
39496: LIST
39497: PUSH
39498: LD_INT 2
39500: NEG
39501: PUSH
39502: LD_INT 2
39504: NEG
39505: PUSH
39506: EMPTY
39507: LIST
39508: LIST
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: LIST
39514: LIST
39515: LIST
39516: LIST
39517: LIST
39518: LIST
39519: LIST
39520: LIST
39521: LIST
39522: LIST
39523: LIST
39524: LIST
39525: LIST
39526: LIST
39527: LIST
39528: LIST
39529: LIST
39530: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39531: LD_ADDR_VAR 0 54
39535: PUSH
39536: LD_INT 0
39538: PUSH
39539: LD_INT 0
39541: PUSH
39542: EMPTY
39543: LIST
39544: LIST
39545: PUSH
39546: LD_INT 0
39548: PUSH
39549: LD_INT 1
39551: NEG
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 1
39559: PUSH
39560: LD_INT 0
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 1
39569: PUSH
39570: LD_INT 1
39572: PUSH
39573: EMPTY
39574: LIST
39575: LIST
39576: PUSH
39577: LD_INT 0
39579: PUSH
39580: LD_INT 1
39582: PUSH
39583: EMPTY
39584: LIST
39585: LIST
39586: PUSH
39587: LD_INT 1
39589: NEG
39590: PUSH
39591: LD_INT 0
39593: PUSH
39594: EMPTY
39595: LIST
39596: LIST
39597: PUSH
39598: LD_INT 1
39600: NEG
39601: PUSH
39602: LD_INT 1
39604: NEG
39605: PUSH
39606: EMPTY
39607: LIST
39608: LIST
39609: PUSH
39610: LD_INT 1
39612: NEG
39613: PUSH
39614: LD_INT 2
39616: NEG
39617: PUSH
39618: EMPTY
39619: LIST
39620: LIST
39621: PUSH
39622: LD_INT 0
39624: PUSH
39625: LD_INT 2
39627: NEG
39628: PUSH
39629: EMPTY
39630: LIST
39631: LIST
39632: PUSH
39633: LD_INT 1
39635: PUSH
39636: LD_INT 1
39638: NEG
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 2
39646: PUSH
39647: LD_INT 0
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PUSH
39654: LD_INT 2
39656: PUSH
39657: LD_INT 1
39659: PUSH
39660: EMPTY
39661: LIST
39662: LIST
39663: PUSH
39664: LD_INT 2
39666: PUSH
39667: LD_INT 2
39669: PUSH
39670: EMPTY
39671: LIST
39672: LIST
39673: PUSH
39674: LD_INT 1
39676: PUSH
39677: LD_INT 2
39679: PUSH
39680: EMPTY
39681: LIST
39682: LIST
39683: PUSH
39684: LD_INT 0
39686: PUSH
39687: LD_INT 2
39689: PUSH
39690: EMPTY
39691: LIST
39692: LIST
39693: PUSH
39694: LD_INT 1
39696: NEG
39697: PUSH
39698: LD_INT 1
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 2
39707: NEG
39708: PUSH
39709: LD_INT 0
39711: PUSH
39712: EMPTY
39713: LIST
39714: LIST
39715: PUSH
39716: LD_INT 2
39718: NEG
39719: PUSH
39720: LD_INT 1
39722: NEG
39723: PUSH
39724: EMPTY
39725: LIST
39726: LIST
39727: PUSH
39728: LD_INT 2
39730: NEG
39731: PUSH
39732: LD_INT 2
39734: NEG
39735: PUSH
39736: EMPTY
39737: LIST
39738: LIST
39739: PUSH
39740: EMPTY
39741: LIST
39742: LIST
39743: LIST
39744: LIST
39745: LIST
39746: LIST
39747: LIST
39748: LIST
39749: LIST
39750: LIST
39751: LIST
39752: LIST
39753: LIST
39754: LIST
39755: LIST
39756: LIST
39757: LIST
39758: LIST
39759: LIST
39760: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39761: LD_ADDR_VAR 0 55
39765: PUSH
39766: LD_INT 0
39768: PUSH
39769: LD_INT 0
39771: PUSH
39772: EMPTY
39773: LIST
39774: LIST
39775: PUSH
39776: LD_INT 0
39778: PUSH
39779: LD_INT 1
39781: NEG
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 1
39789: PUSH
39790: LD_INT 0
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 1
39799: PUSH
39800: LD_INT 1
39802: PUSH
39803: EMPTY
39804: LIST
39805: LIST
39806: PUSH
39807: LD_INT 0
39809: PUSH
39810: LD_INT 1
39812: PUSH
39813: EMPTY
39814: LIST
39815: LIST
39816: PUSH
39817: LD_INT 1
39819: NEG
39820: PUSH
39821: LD_INT 0
39823: PUSH
39824: EMPTY
39825: LIST
39826: LIST
39827: PUSH
39828: LD_INT 1
39830: NEG
39831: PUSH
39832: LD_INT 1
39834: NEG
39835: PUSH
39836: EMPTY
39837: LIST
39838: LIST
39839: PUSH
39840: LD_INT 1
39842: NEG
39843: PUSH
39844: LD_INT 2
39846: NEG
39847: PUSH
39848: EMPTY
39849: LIST
39850: LIST
39851: PUSH
39852: LD_INT 0
39854: PUSH
39855: LD_INT 2
39857: NEG
39858: PUSH
39859: EMPTY
39860: LIST
39861: LIST
39862: PUSH
39863: LD_INT 1
39865: PUSH
39866: LD_INT 1
39868: NEG
39869: PUSH
39870: EMPTY
39871: LIST
39872: LIST
39873: PUSH
39874: LD_INT 2
39876: PUSH
39877: LD_INT 0
39879: PUSH
39880: EMPTY
39881: LIST
39882: LIST
39883: PUSH
39884: LD_INT 2
39886: PUSH
39887: LD_INT 1
39889: PUSH
39890: EMPTY
39891: LIST
39892: LIST
39893: PUSH
39894: LD_INT 2
39896: PUSH
39897: LD_INT 2
39899: PUSH
39900: EMPTY
39901: LIST
39902: LIST
39903: PUSH
39904: LD_INT 1
39906: PUSH
39907: LD_INT 2
39909: PUSH
39910: EMPTY
39911: LIST
39912: LIST
39913: PUSH
39914: LD_INT 0
39916: PUSH
39917: LD_INT 2
39919: PUSH
39920: EMPTY
39921: LIST
39922: LIST
39923: PUSH
39924: LD_INT 1
39926: NEG
39927: PUSH
39928: LD_INT 1
39930: PUSH
39931: EMPTY
39932: LIST
39933: LIST
39934: PUSH
39935: LD_INT 2
39937: NEG
39938: PUSH
39939: LD_INT 0
39941: PUSH
39942: EMPTY
39943: LIST
39944: LIST
39945: PUSH
39946: LD_INT 2
39948: NEG
39949: PUSH
39950: LD_INT 1
39952: NEG
39953: PUSH
39954: EMPTY
39955: LIST
39956: LIST
39957: PUSH
39958: LD_INT 2
39960: NEG
39961: PUSH
39962: LD_INT 2
39964: NEG
39965: PUSH
39966: EMPTY
39967: LIST
39968: LIST
39969: PUSH
39970: EMPTY
39971: LIST
39972: LIST
39973: LIST
39974: LIST
39975: LIST
39976: LIST
39977: LIST
39978: LIST
39979: LIST
39980: LIST
39981: LIST
39982: LIST
39983: LIST
39984: LIST
39985: LIST
39986: LIST
39987: LIST
39988: LIST
39989: LIST
39990: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39991: LD_ADDR_VAR 0 56
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: LD_INT 0
40001: PUSH
40002: EMPTY
40003: LIST
40004: LIST
40005: PUSH
40006: LD_INT 0
40008: PUSH
40009: LD_INT 1
40011: NEG
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PUSH
40017: LD_INT 1
40019: PUSH
40020: LD_INT 0
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 1
40029: PUSH
40030: LD_INT 1
40032: PUSH
40033: EMPTY
40034: LIST
40035: LIST
40036: PUSH
40037: LD_INT 0
40039: PUSH
40040: LD_INT 1
40042: PUSH
40043: EMPTY
40044: LIST
40045: LIST
40046: PUSH
40047: LD_INT 1
40049: NEG
40050: PUSH
40051: LD_INT 0
40053: PUSH
40054: EMPTY
40055: LIST
40056: LIST
40057: PUSH
40058: LD_INT 1
40060: NEG
40061: PUSH
40062: LD_INT 1
40064: NEG
40065: PUSH
40066: EMPTY
40067: LIST
40068: LIST
40069: PUSH
40070: LD_INT 1
40072: NEG
40073: PUSH
40074: LD_INT 2
40076: NEG
40077: PUSH
40078: EMPTY
40079: LIST
40080: LIST
40081: PUSH
40082: LD_INT 0
40084: PUSH
40085: LD_INT 2
40087: NEG
40088: PUSH
40089: EMPTY
40090: LIST
40091: LIST
40092: PUSH
40093: LD_INT 1
40095: PUSH
40096: LD_INT 1
40098: NEG
40099: PUSH
40100: EMPTY
40101: LIST
40102: LIST
40103: PUSH
40104: LD_INT 2
40106: PUSH
40107: LD_INT 0
40109: PUSH
40110: EMPTY
40111: LIST
40112: LIST
40113: PUSH
40114: LD_INT 2
40116: PUSH
40117: LD_INT 1
40119: PUSH
40120: EMPTY
40121: LIST
40122: LIST
40123: PUSH
40124: LD_INT 2
40126: PUSH
40127: LD_INT 2
40129: PUSH
40130: EMPTY
40131: LIST
40132: LIST
40133: PUSH
40134: LD_INT 1
40136: PUSH
40137: LD_INT 2
40139: PUSH
40140: EMPTY
40141: LIST
40142: LIST
40143: PUSH
40144: LD_INT 0
40146: PUSH
40147: LD_INT 2
40149: PUSH
40150: EMPTY
40151: LIST
40152: LIST
40153: PUSH
40154: LD_INT 1
40156: NEG
40157: PUSH
40158: LD_INT 1
40160: PUSH
40161: EMPTY
40162: LIST
40163: LIST
40164: PUSH
40165: LD_INT 2
40167: NEG
40168: PUSH
40169: LD_INT 0
40171: PUSH
40172: EMPTY
40173: LIST
40174: LIST
40175: PUSH
40176: LD_INT 2
40178: NEG
40179: PUSH
40180: LD_INT 1
40182: NEG
40183: PUSH
40184: EMPTY
40185: LIST
40186: LIST
40187: PUSH
40188: LD_INT 2
40190: NEG
40191: PUSH
40192: LD_INT 2
40194: NEG
40195: PUSH
40196: EMPTY
40197: LIST
40198: LIST
40199: PUSH
40200: EMPTY
40201: LIST
40202: LIST
40203: LIST
40204: LIST
40205: LIST
40206: LIST
40207: LIST
40208: LIST
40209: LIST
40210: LIST
40211: LIST
40212: LIST
40213: LIST
40214: LIST
40215: LIST
40216: LIST
40217: LIST
40218: LIST
40219: LIST
40220: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40221: LD_ADDR_VAR 0 57
40225: PUSH
40226: LD_INT 0
40228: PUSH
40229: LD_INT 0
40231: PUSH
40232: EMPTY
40233: LIST
40234: LIST
40235: PUSH
40236: LD_INT 0
40238: PUSH
40239: LD_INT 1
40241: NEG
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 1
40249: PUSH
40250: LD_INT 0
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 1
40259: PUSH
40260: LD_INT 1
40262: PUSH
40263: EMPTY
40264: LIST
40265: LIST
40266: PUSH
40267: LD_INT 0
40269: PUSH
40270: LD_INT 1
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: PUSH
40277: LD_INT 1
40279: NEG
40280: PUSH
40281: LD_INT 0
40283: PUSH
40284: EMPTY
40285: LIST
40286: LIST
40287: PUSH
40288: LD_INT 1
40290: NEG
40291: PUSH
40292: LD_INT 1
40294: NEG
40295: PUSH
40296: EMPTY
40297: LIST
40298: LIST
40299: PUSH
40300: LD_INT 1
40302: NEG
40303: PUSH
40304: LD_INT 2
40306: NEG
40307: PUSH
40308: EMPTY
40309: LIST
40310: LIST
40311: PUSH
40312: LD_INT 0
40314: PUSH
40315: LD_INT 2
40317: NEG
40318: PUSH
40319: EMPTY
40320: LIST
40321: LIST
40322: PUSH
40323: LD_INT 1
40325: PUSH
40326: LD_INT 1
40328: NEG
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: PUSH
40334: LD_INT 2
40336: PUSH
40337: LD_INT 0
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: PUSH
40344: LD_INT 2
40346: PUSH
40347: LD_INT 1
40349: PUSH
40350: EMPTY
40351: LIST
40352: LIST
40353: PUSH
40354: LD_INT 2
40356: PUSH
40357: LD_INT 2
40359: PUSH
40360: EMPTY
40361: LIST
40362: LIST
40363: PUSH
40364: LD_INT 1
40366: PUSH
40367: LD_INT 2
40369: PUSH
40370: EMPTY
40371: LIST
40372: LIST
40373: PUSH
40374: LD_INT 0
40376: PUSH
40377: LD_INT 2
40379: PUSH
40380: EMPTY
40381: LIST
40382: LIST
40383: PUSH
40384: LD_INT 1
40386: NEG
40387: PUSH
40388: LD_INT 1
40390: PUSH
40391: EMPTY
40392: LIST
40393: LIST
40394: PUSH
40395: LD_INT 2
40397: NEG
40398: PUSH
40399: LD_INT 0
40401: PUSH
40402: EMPTY
40403: LIST
40404: LIST
40405: PUSH
40406: LD_INT 2
40408: NEG
40409: PUSH
40410: LD_INT 1
40412: NEG
40413: PUSH
40414: EMPTY
40415: LIST
40416: LIST
40417: PUSH
40418: LD_INT 2
40420: NEG
40421: PUSH
40422: LD_INT 2
40424: NEG
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: EMPTY
40431: LIST
40432: LIST
40433: LIST
40434: LIST
40435: LIST
40436: LIST
40437: LIST
40438: LIST
40439: LIST
40440: LIST
40441: LIST
40442: LIST
40443: LIST
40444: LIST
40445: LIST
40446: LIST
40447: LIST
40448: LIST
40449: LIST
40450: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40451: LD_ADDR_VAR 0 58
40455: PUSH
40456: LD_INT 0
40458: PUSH
40459: LD_INT 0
40461: PUSH
40462: EMPTY
40463: LIST
40464: LIST
40465: PUSH
40466: LD_INT 0
40468: PUSH
40469: LD_INT 1
40471: NEG
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: PUSH
40477: LD_INT 1
40479: PUSH
40480: LD_INT 0
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 1
40489: PUSH
40490: LD_INT 1
40492: PUSH
40493: EMPTY
40494: LIST
40495: LIST
40496: PUSH
40497: LD_INT 0
40499: PUSH
40500: LD_INT 1
40502: PUSH
40503: EMPTY
40504: LIST
40505: LIST
40506: PUSH
40507: LD_INT 1
40509: NEG
40510: PUSH
40511: LD_INT 0
40513: PUSH
40514: EMPTY
40515: LIST
40516: LIST
40517: PUSH
40518: LD_INT 1
40520: NEG
40521: PUSH
40522: LD_INT 1
40524: NEG
40525: PUSH
40526: EMPTY
40527: LIST
40528: LIST
40529: PUSH
40530: LD_INT 1
40532: NEG
40533: PUSH
40534: LD_INT 2
40536: NEG
40537: PUSH
40538: EMPTY
40539: LIST
40540: LIST
40541: PUSH
40542: LD_INT 0
40544: PUSH
40545: LD_INT 2
40547: NEG
40548: PUSH
40549: EMPTY
40550: LIST
40551: LIST
40552: PUSH
40553: LD_INT 1
40555: PUSH
40556: LD_INT 1
40558: NEG
40559: PUSH
40560: EMPTY
40561: LIST
40562: LIST
40563: PUSH
40564: LD_INT 2
40566: PUSH
40567: LD_INT 0
40569: PUSH
40570: EMPTY
40571: LIST
40572: LIST
40573: PUSH
40574: LD_INT 2
40576: PUSH
40577: LD_INT 1
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 2
40586: PUSH
40587: LD_INT 2
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PUSH
40594: LD_INT 1
40596: PUSH
40597: LD_INT 2
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 0
40606: PUSH
40607: LD_INT 2
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: LD_INT 1
40616: NEG
40617: PUSH
40618: LD_INT 1
40620: PUSH
40621: EMPTY
40622: LIST
40623: LIST
40624: PUSH
40625: LD_INT 2
40627: NEG
40628: PUSH
40629: LD_INT 0
40631: PUSH
40632: EMPTY
40633: LIST
40634: LIST
40635: PUSH
40636: LD_INT 2
40638: NEG
40639: PUSH
40640: LD_INT 1
40642: NEG
40643: PUSH
40644: EMPTY
40645: LIST
40646: LIST
40647: PUSH
40648: LD_INT 2
40650: NEG
40651: PUSH
40652: LD_INT 2
40654: NEG
40655: PUSH
40656: EMPTY
40657: LIST
40658: LIST
40659: PUSH
40660: EMPTY
40661: LIST
40662: LIST
40663: LIST
40664: LIST
40665: LIST
40666: LIST
40667: LIST
40668: LIST
40669: LIST
40670: LIST
40671: LIST
40672: LIST
40673: LIST
40674: LIST
40675: LIST
40676: LIST
40677: LIST
40678: LIST
40679: LIST
40680: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40681: LD_ADDR_VAR 0 59
40685: PUSH
40686: LD_INT 0
40688: PUSH
40689: LD_INT 0
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 0
40698: PUSH
40699: LD_INT 1
40701: NEG
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 1
40709: PUSH
40710: LD_INT 0
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 1
40719: PUSH
40720: LD_INT 1
40722: PUSH
40723: EMPTY
40724: LIST
40725: LIST
40726: PUSH
40727: LD_INT 0
40729: PUSH
40730: LD_INT 1
40732: PUSH
40733: EMPTY
40734: LIST
40735: LIST
40736: PUSH
40737: LD_INT 1
40739: NEG
40740: PUSH
40741: LD_INT 0
40743: PUSH
40744: EMPTY
40745: LIST
40746: LIST
40747: PUSH
40748: LD_INT 1
40750: NEG
40751: PUSH
40752: LD_INT 1
40754: NEG
40755: PUSH
40756: EMPTY
40757: LIST
40758: LIST
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: LIST
40764: LIST
40765: LIST
40766: LIST
40767: LIST
40768: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40769: LD_ADDR_VAR 0 60
40773: PUSH
40774: LD_INT 0
40776: PUSH
40777: LD_INT 0
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 0
40786: PUSH
40787: LD_INT 1
40789: NEG
40790: PUSH
40791: EMPTY
40792: LIST
40793: LIST
40794: PUSH
40795: LD_INT 1
40797: PUSH
40798: LD_INT 0
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: PUSH
40805: LD_INT 1
40807: PUSH
40808: LD_INT 1
40810: PUSH
40811: EMPTY
40812: LIST
40813: LIST
40814: PUSH
40815: LD_INT 0
40817: PUSH
40818: LD_INT 1
40820: PUSH
40821: EMPTY
40822: LIST
40823: LIST
40824: PUSH
40825: LD_INT 1
40827: NEG
40828: PUSH
40829: LD_INT 0
40831: PUSH
40832: EMPTY
40833: LIST
40834: LIST
40835: PUSH
40836: LD_INT 1
40838: NEG
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: EMPTY
40845: LIST
40846: LIST
40847: PUSH
40848: EMPTY
40849: LIST
40850: LIST
40851: LIST
40852: LIST
40853: LIST
40854: LIST
40855: LIST
40856: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40857: LD_ADDR_VAR 0 61
40861: PUSH
40862: LD_INT 0
40864: PUSH
40865: LD_INT 0
40867: PUSH
40868: EMPTY
40869: LIST
40870: LIST
40871: PUSH
40872: LD_INT 0
40874: PUSH
40875: LD_INT 1
40877: NEG
40878: PUSH
40879: EMPTY
40880: LIST
40881: LIST
40882: PUSH
40883: LD_INT 1
40885: PUSH
40886: LD_INT 0
40888: PUSH
40889: EMPTY
40890: LIST
40891: LIST
40892: PUSH
40893: LD_INT 1
40895: PUSH
40896: LD_INT 1
40898: PUSH
40899: EMPTY
40900: LIST
40901: LIST
40902: PUSH
40903: LD_INT 0
40905: PUSH
40906: LD_INT 1
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 1
40915: NEG
40916: PUSH
40917: LD_INT 0
40919: PUSH
40920: EMPTY
40921: LIST
40922: LIST
40923: PUSH
40924: LD_INT 1
40926: NEG
40927: PUSH
40928: LD_INT 1
40930: NEG
40931: PUSH
40932: EMPTY
40933: LIST
40934: LIST
40935: PUSH
40936: EMPTY
40937: LIST
40938: LIST
40939: LIST
40940: LIST
40941: LIST
40942: LIST
40943: LIST
40944: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40945: LD_ADDR_VAR 0 62
40949: PUSH
40950: LD_INT 0
40952: PUSH
40953: LD_INT 0
40955: PUSH
40956: EMPTY
40957: LIST
40958: LIST
40959: PUSH
40960: LD_INT 0
40962: PUSH
40963: LD_INT 1
40965: NEG
40966: PUSH
40967: EMPTY
40968: LIST
40969: LIST
40970: PUSH
40971: LD_INT 1
40973: PUSH
40974: LD_INT 0
40976: PUSH
40977: EMPTY
40978: LIST
40979: LIST
40980: PUSH
40981: LD_INT 1
40983: PUSH
40984: LD_INT 1
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 0
40993: PUSH
40994: LD_INT 1
40996: PUSH
40997: EMPTY
40998: LIST
40999: LIST
41000: PUSH
41001: LD_INT 1
41003: NEG
41004: PUSH
41005: LD_INT 0
41007: PUSH
41008: EMPTY
41009: LIST
41010: LIST
41011: PUSH
41012: LD_INT 1
41014: NEG
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: EMPTY
41021: LIST
41022: LIST
41023: PUSH
41024: EMPTY
41025: LIST
41026: LIST
41027: LIST
41028: LIST
41029: LIST
41030: LIST
41031: LIST
41032: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41033: LD_ADDR_VAR 0 63
41037: PUSH
41038: LD_INT 0
41040: PUSH
41041: LD_INT 0
41043: PUSH
41044: EMPTY
41045: LIST
41046: LIST
41047: PUSH
41048: LD_INT 0
41050: PUSH
41051: LD_INT 1
41053: NEG
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: PUSH
41059: LD_INT 1
41061: PUSH
41062: LD_INT 0
41064: PUSH
41065: EMPTY
41066: LIST
41067: LIST
41068: PUSH
41069: LD_INT 1
41071: PUSH
41072: LD_INT 1
41074: PUSH
41075: EMPTY
41076: LIST
41077: LIST
41078: PUSH
41079: LD_INT 0
41081: PUSH
41082: LD_INT 1
41084: PUSH
41085: EMPTY
41086: LIST
41087: LIST
41088: PUSH
41089: LD_INT 1
41091: NEG
41092: PUSH
41093: LD_INT 0
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 1
41102: NEG
41103: PUSH
41104: LD_INT 1
41106: NEG
41107: PUSH
41108: EMPTY
41109: LIST
41110: LIST
41111: PUSH
41112: EMPTY
41113: LIST
41114: LIST
41115: LIST
41116: LIST
41117: LIST
41118: LIST
41119: LIST
41120: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41121: LD_ADDR_VAR 0 64
41125: PUSH
41126: LD_INT 0
41128: PUSH
41129: LD_INT 0
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: LD_INT 0
41138: PUSH
41139: LD_INT 1
41141: NEG
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: PUSH
41147: LD_INT 1
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 1
41159: PUSH
41160: LD_INT 1
41162: PUSH
41163: EMPTY
41164: LIST
41165: LIST
41166: PUSH
41167: LD_INT 0
41169: PUSH
41170: LD_INT 1
41172: PUSH
41173: EMPTY
41174: LIST
41175: LIST
41176: PUSH
41177: LD_INT 1
41179: NEG
41180: PUSH
41181: LD_INT 0
41183: PUSH
41184: EMPTY
41185: LIST
41186: LIST
41187: PUSH
41188: LD_INT 1
41190: NEG
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: EMPTY
41197: LIST
41198: LIST
41199: PUSH
41200: EMPTY
41201: LIST
41202: LIST
41203: LIST
41204: LIST
41205: LIST
41206: LIST
41207: LIST
41208: ST_TO_ADDR
// end ; 1 :
41209: GO 47106
41211: LD_INT 1
41213: DOUBLE
41214: EQUAL
41215: IFTRUE 41219
41217: GO 43842
41219: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41220: LD_ADDR_VAR 0 11
41224: PUSH
41225: LD_INT 1
41227: NEG
41228: PUSH
41229: LD_INT 3
41231: NEG
41232: PUSH
41233: EMPTY
41234: LIST
41235: LIST
41236: PUSH
41237: LD_INT 0
41239: PUSH
41240: LD_INT 3
41242: NEG
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: PUSH
41251: LD_INT 2
41253: NEG
41254: PUSH
41255: EMPTY
41256: LIST
41257: LIST
41258: PUSH
41259: EMPTY
41260: LIST
41261: LIST
41262: LIST
41263: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41264: LD_ADDR_VAR 0 12
41268: PUSH
41269: LD_INT 2
41271: PUSH
41272: LD_INT 1
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 3
41282: PUSH
41283: LD_INT 0
41285: PUSH
41286: EMPTY
41287: LIST
41288: LIST
41289: PUSH
41290: LD_INT 3
41292: PUSH
41293: LD_INT 1
41295: PUSH
41296: EMPTY
41297: LIST
41298: LIST
41299: PUSH
41300: EMPTY
41301: LIST
41302: LIST
41303: LIST
41304: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41305: LD_ADDR_VAR 0 13
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: LD_INT 3
41322: PUSH
41323: LD_INT 3
41325: PUSH
41326: EMPTY
41327: LIST
41328: LIST
41329: PUSH
41330: LD_INT 2
41332: PUSH
41333: LD_INT 3
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: LIST
41344: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41345: LD_ADDR_VAR 0 14
41349: PUSH
41350: LD_INT 1
41352: PUSH
41353: LD_INT 3
41355: PUSH
41356: EMPTY
41357: LIST
41358: LIST
41359: PUSH
41360: LD_INT 0
41362: PUSH
41363: LD_INT 3
41365: PUSH
41366: EMPTY
41367: LIST
41368: LIST
41369: PUSH
41370: LD_INT 1
41372: NEG
41373: PUSH
41374: LD_INT 2
41376: PUSH
41377: EMPTY
41378: LIST
41379: LIST
41380: PUSH
41381: EMPTY
41382: LIST
41383: LIST
41384: LIST
41385: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41386: LD_ADDR_VAR 0 15
41390: PUSH
41391: LD_INT 2
41393: NEG
41394: PUSH
41395: LD_INT 1
41397: PUSH
41398: EMPTY
41399: LIST
41400: LIST
41401: PUSH
41402: LD_INT 3
41404: NEG
41405: PUSH
41406: LD_INT 0
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: LD_INT 3
41415: NEG
41416: PUSH
41417: LD_INT 1
41419: NEG
41420: PUSH
41421: EMPTY
41422: LIST
41423: LIST
41424: PUSH
41425: EMPTY
41426: LIST
41427: LIST
41428: LIST
41429: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41430: LD_ADDR_VAR 0 16
41434: PUSH
41435: LD_INT 2
41437: NEG
41438: PUSH
41439: LD_INT 3
41441: NEG
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: PUSH
41447: LD_INT 3
41449: NEG
41450: PUSH
41451: LD_INT 2
41453: NEG
41454: PUSH
41455: EMPTY
41456: LIST
41457: LIST
41458: PUSH
41459: LD_INT 3
41461: NEG
41462: PUSH
41463: LD_INT 3
41465: NEG
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: EMPTY
41472: LIST
41473: LIST
41474: LIST
41475: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41476: LD_ADDR_VAR 0 17
41480: PUSH
41481: LD_INT 1
41483: NEG
41484: PUSH
41485: LD_INT 3
41487: NEG
41488: PUSH
41489: EMPTY
41490: LIST
41491: LIST
41492: PUSH
41493: LD_INT 0
41495: PUSH
41496: LD_INT 3
41498: NEG
41499: PUSH
41500: EMPTY
41501: LIST
41502: LIST
41503: PUSH
41504: LD_INT 1
41506: PUSH
41507: LD_INT 2
41509: NEG
41510: PUSH
41511: EMPTY
41512: LIST
41513: LIST
41514: PUSH
41515: EMPTY
41516: LIST
41517: LIST
41518: LIST
41519: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41520: LD_ADDR_VAR 0 18
41524: PUSH
41525: LD_INT 2
41527: PUSH
41528: LD_INT 1
41530: NEG
41531: PUSH
41532: EMPTY
41533: LIST
41534: LIST
41535: PUSH
41536: LD_INT 3
41538: PUSH
41539: LD_INT 0
41541: PUSH
41542: EMPTY
41543: LIST
41544: LIST
41545: PUSH
41546: LD_INT 3
41548: PUSH
41549: LD_INT 1
41551: PUSH
41552: EMPTY
41553: LIST
41554: LIST
41555: PUSH
41556: EMPTY
41557: LIST
41558: LIST
41559: LIST
41560: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41561: LD_ADDR_VAR 0 19
41565: PUSH
41566: LD_INT 3
41568: PUSH
41569: LD_INT 2
41571: PUSH
41572: EMPTY
41573: LIST
41574: LIST
41575: PUSH
41576: LD_INT 3
41578: PUSH
41579: LD_INT 3
41581: PUSH
41582: EMPTY
41583: LIST
41584: LIST
41585: PUSH
41586: LD_INT 2
41588: PUSH
41589: LD_INT 3
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: EMPTY
41597: LIST
41598: LIST
41599: LIST
41600: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41601: LD_ADDR_VAR 0 20
41605: PUSH
41606: LD_INT 1
41608: PUSH
41609: LD_INT 3
41611: PUSH
41612: EMPTY
41613: LIST
41614: LIST
41615: PUSH
41616: LD_INT 0
41618: PUSH
41619: LD_INT 3
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: PUSH
41626: LD_INT 1
41628: NEG
41629: PUSH
41630: LD_INT 2
41632: PUSH
41633: EMPTY
41634: LIST
41635: LIST
41636: PUSH
41637: EMPTY
41638: LIST
41639: LIST
41640: LIST
41641: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41642: LD_ADDR_VAR 0 21
41646: PUSH
41647: LD_INT 2
41649: NEG
41650: PUSH
41651: LD_INT 1
41653: PUSH
41654: EMPTY
41655: LIST
41656: LIST
41657: PUSH
41658: LD_INT 3
41660: NEG
41661: PUSH
41662: LD_INT 0
41664: PUSH
41665: EMPTY
41666: LIST
41667: LIST
41668: PUSH
41669: LD_INT 3
41671: NEG
41672: PUSH
41673: LD_INT 1
41675: NEG
41676: PUSH
41677: EMPTY
41678: LIST
41679: LIST
41680: PUSH
41681: EMPTY
41682: LIST
41683: LIST
41684: LIST
41685: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41686: LD_ADDR_VAR 0 22
41690: PUSH
41691: LD_INT 2
41693: NEG
41694: PUSH
41695: LD_INT 3
41697: NEG
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: PUSH
41703: LD_INT 3
41705: NEG
41706: PUSH
41707: LD_INT 2
41709: NEG
41710: PUSH
41711: EMPTY
41712: LIST
41713: LIST
41714: PUSH
41715: LD_INT 3
41717: NEG
41718: PUSH
41719: LD_INT 3
41721: NEG
41722: PUSH
41723: EMPTY
41724: LIST
41725: LIST
41726: PUSH
41727: EMPTY
41728: LIST
41729: LIST
41730: LIST
41731: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41732: LD_ADDR_VAR 0 23
41736: PUSH
41737: LD_INT 0
41739: PUSH
41740: LD_INT 3
41742: NEG
41743: PUSH
41744: EMPTY
41745: LIST
41746: LIST
41747: PUSH
41748: LD_INT 1
41750: NEG
41751: PUSH
41752: LD_INT 4
41754: NEG
41755: PUSH
41756: EMPTY
41757: LIST
41758: LIST
41759: PUSH
41760: LD_INT 1
41762: PUSH
41763: LD_INT 3
41765: NEG
41766: PUSH
41767: EMPTY
41768: LIST
41769: LIST
41770: PUSH
41771: EMPTY
41772: LIST
41773: LIST
41774: LIST
41775: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41776: LD_ADDR_VAR 0 24
41780: PUSH
41781: LD_INT 3
41783: PUSH
41784: LD_INT 0
41786: PUSH
41787: EMPTY
41788: LIST
41789: LIST
41790: PUSH
41791: LD_INT 3
41793: PUSH
41794: LD_INT 1
41796: NEG
41797: PUSH
41798: EMPTY
41799: LIST
41800: LIST
41801: PUSH
41802: LD_INT 4
41804: PUSH
41805: LD_INT 1
41807: PUSH
41808: EMPTY
41809: LIST
41810: LIST
41811: PUSH
41812: EMPTY
41813: LIST
41814: LIST
41815: LIST
41816: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41817: LD_ADDR_VAR 0 25
41821: PUSH
41822: LD_INT 3
41824: PUSH
41825: LD_INT 3
41827: PUSH
41828: EMPTY
41829: LIST
41830: LIST
41831: PUSH
41832: LD_INT 4
41834: PUSH
41835: LD_INT 3
41837: PUSH
41838: EMPTY
41839: LIST
41840: LIST
41841: PUSH
41842: LD_INT 3
41844: PUSH
41845: LD_INT 4
41847: PUSH
41848: EMPTY
41849: LIST
41850: LIST
41851: PUSH
41852: EMPTY
41853: LIST
41854: LIST
41855: LIST
41856: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41857: LD_ADDR_VAR 0 26
41861: PUSH
41862: LD_INT 0
41864: PUSH
41865: LD_INT 3
41867: PUSH
41868: EMPTY
41869: LIST
41870: LIST
41871: PUSH
41872: LD_INT 1
41874: PUSH
41875: LD_INT 4
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: PUSH
41882: LD_INT 1
41884: NEG
41885: PUSH
41886: LD_INT 3
41888: PUSH
41889: EMPTY
41890: LIST
41891: LIST
41892: PUSH
41893: EMPTY
41894: LIST
41895: LIST
41896: LIST
41897: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
41898: LD_ADDR_VAR 0 27
41902: PUSH
41903: LD_INT 3
41905: NEG
41906: PUSH
41907: LD_INT 0
41909: PUSH
41910: EMPTY
41911: LIST
41912: LIST
41913: PUSH
41914: LD_INT 3
41916: NEG
41917: PUSH
41918: LD_INT 1
41920: PUSH
41921: EMPTY
41922: LIST
41923: LIST
41924: PUSH
41925: LD_INT 4
41927: NEG
41928: PUSH
41929: LD_INT 1
41931: NEG
41932: PUSH
41933: EMPTY
41934: LIST
41935: LIST
41936: PUSH
41937: EMPTY
41938: LIST
41939: LIST
41940: LIST
41941: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
41942: LD_ADDR_VAR 0 28
41946: PUSH
41947: LD_INT 3
41949: NEG
41950: PUSH
41951: LD_INT 3
41953: NEG
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: PUSH
41959: LD_INT 3
41961: NEG
41962: PUSH
41963: LD_INT 4
41965: NEG
41966: PUSH
41967: EMPTY
41968: LIST
41969: LIST
41970: PUSH
41971: LD_INT 4
41973: NEG
41974: PUSH
41975: LD_INT 3
41977: NEG
41978: PUSH
41979: EMPTY
41980: LIST
41981: LIST
41982: PUSH
41983: EMPTY
41984: LIST
41985: LIST
41986: LIST
41987: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
41988: LD_ADDR_VAR 0 29
41992: PUSH
41993: LD_INT 1
41995: NEG
41996: PUSH
41997: LD_INT 3
41999: NEG
42000: PUSH
42001: EMPTY
42002: LIST
42003: LIST
42004: PUSH
42005: LD_INT 0
42007: PUSH
42008: LD_INT 3
42010: NEG
42011: PUSH
42012: EMPTY
42013: LIST
42014: LIST
42015: PUSH
42016: LD_INT 1
42018: PUSH
42019: LD_INT 2
42021: NEG
42022: PUSH
42023: EMPTY
42024: LIST
42025: LIST
42026: PUSH
42027: LD_INT 1
42029: NEG
42030: PUSH
42031: LD_INT 4
42033: NEG
42034: PUSH
42035: EMPTY
42036: LIST
42037: LIST
42038: PUSH
42039: LD_INT 0
42041: PUSH
42042: LD_INT 4
42044: NEG
42045: PUSH
42046: EMPTY
42047: LIST
42048: LIST
42049: PUSH
42050: LD_INT 1
42052: PUSH
42053: LD_INT 3
42055: NEG
42056: PUSH
42057: EMPTY
42058: LIST
42059: LIST
42060: PUSH
42061: LD_INT 1
42063: NEG
42064: PUSH
42065: LD_INT 5
42067: NEG
42068: PUSH
42069: EMPTY
42070: LIST
42071: LIST
42072: PUSH
42073: LD_INT 0
42075: PUSH
42076: LD_INT 5
42078: NEG
42079: PUSH
42080: EMPTY
42081: LIST
42082: LIST
42083: PUSH
42084: LD_INT 1
42086: PUSH
42087: LD_INT 4
42089: NEG
42090: PUSH
42091: EMPTY
42092: LIST
42093: LIST
42094: PUSH
42095: LD_INT 1
42097: NEG
42098: PUSH
42099: LD_INT 6
42101: NEG
42102: PUSH
42103: EMPTY
42104: LIST
42105: LIST
42106: PUSH
42107: LD_INT 0
42109: PUSH
42110: LD_INT 6
42112: NEG
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 1
42120: PUSH
42121: LD_INT 5
42123: NEG
42124: PUSH
42125: EMPTY
42126: LIST
42127: LIST
42128: PUSH
42129: EMPTY
42130: LIST
42131: LIST
42132: LIST
42133: LIST
42134: LIST
42135: LIST
42136: LIST
42137: LIST
42138: LIST
42139: LIST
42140: LIST
42141: LIST
42142: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42143: LD_ADDR_VAR 0 30
42147: PUSH
42148: LD_INT 2
42150: PUSH
42151: LD_INT 1
42153: NEG
42154: PUSH
42155: EMPTY
42156: LIST
42157: LIST
42158: PUSH
42159: LD_INT 3
42161: PUSH
42162: LD_INT 0
42164: PUSH
42165: EMPTY
42166: LIST
42167: LIST
42168: PUSH
42169: LD_INT 3
42171: PUSH
42172: LD_INT 1
42174: PUSH
42175: EMPTY
42176: LIST
42177: LIST
42178: PUSH
42179: LD_INT 3
42181: PUSH
42182: LD_INT 1
42184: NEG
42185: PUSH
42186: EMPTY
42187: LIST
42188: LIST
42189: PUSH
42190: LD_INT 4
42192: PUSH
42193: LD_INT 0
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 4
42202: PUSH
42203: LD_INT 1
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 4
42212: PUSH
42213: LD_INT 1
42215: NEG
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 5
42223: PUSH
42224: LD_INT 0
42226: PUSH
42227: EMPTY
42228: LIST
42229: LIST
42230: PUSH
42231: LD_INT 5
42233: PUSH
42234: LD_INT 1
42236: PUSH
42237: EMPTY
42238: LIST
42239: LIST
42240: PUSH
42241: LD_INT 5
42243: PUSH
42244: LD_INT 1
42246: NEG
42247: PUSH
42248: EMPTY
42249: LIST
42250: LIST
42251: PUSH
42252: LD_INT 6
42254: PUSH
42255: LD_INT 0
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PUSH
42262: LD_INT 6
42264: PUSH
42265: LD_INT 1
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: LIST
42276: LIST
42277: LIST
42278: LIST
42279: LIST
42280: LIST
42281: LIST
42282: LIST
42283: LIST
42284: LIST
42285: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42286: LD_ADDR_VAR 0 31
42290: PUSH
42291: LD_INT 3
42293: PUSH
42294: LD_INT 2
42296: PUSH
42297: EMPTY
42298: LIST
42299: LIST
42300: PUSH
42301: LD_INT 3
42303: PUSH
42304: LD_INT 3
42306: PUSH
42307: EMPTY
42308: LIST
42309: LIST
42310: PUSH
42311: LD_INT 2
42313: PUSH
42314: LD_INT 3
42316: PUSH
42317: EMPTY
42318: LIST
42319: LIST
42320: PUSH
42321: LD_INT 4
42323: PUSH
42324: LD_INT 3
42326: PUSH
42327: EMPTY
42328: LIST
42329: LIST
42330: PUSH
42331: LD_INT 4
42333: PUSH
42334: LD_INT 4
42336: PUSH
42337: EMPTY
42338: LIST
42339: LIST
42340: PUSH
42341: LD_INT 3
42343: PUSH
42344: LD_INT 4
42346: PUSH
42347: EMPTY
42348: LIST
42349: LIST
42350: PUSH
42351: LD_INT 5
42353: PUSH
42354: LD_INT 4
42356: PUSH
42357: EMPTY
42358: LIST
42359: LIST
42360: PUSH
42361: LD_INT 5
42363: PUSH
42364: LD_INT 5
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 4
42373: PUSH
42374: LD_INT 5
42376: PUSH
42377: EMPTY
42378: LIST
42379: LIST
42380: PUSH
42381: LD_INT 6
42383: PUSH
42384: LD_INT 5
42386: PUSH
42387: EMPTY
42388: LIST
42389: LIST
42390: PUSH
42391: LD_INT 6
42393: PUSH
42394: LD_INT 6
42396: PUSH
42397: EMPTY
42398: LIST
42399: LIST
42400: PUSH
42401: LD_INT 5
42403: PUSH
42404: LD_INT 6
42406: PUSH
42407: EMPTY
42408: LIST
42409: LIST
42410: PUSH
42411: EMPTY
42412: LIST
42413: LIST
42414: LIST
42415: LIST
42416: LIST
42417: LIST
42418: LIST
42419: LIST
42420: LIST
42421: LIST
42422: LIST
42423: LIST
42424: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42425: LD_ADDR_VAR 0 32
42429: PUSH
42430: LD_INT 1
42432: PUSH
42433: LD_INT 3
42435: PUSH
42436: EMPTY
42437: LIST
42438: LIST
42439: PUSH
42440: LD_INT 0
42442: PUSH
42443: LD_INT 3
42445: PUSH
42446: EMPTY
42447: LIST
42448: LIST
42449: PUSH
42450: LD_INT 1
42452: NEG
42453: PUSH
42454: LD_INT 2
42456: PUSH
42457: EMPTY
42458: LIST
42459: LIST
42460: PUSH
42461: LD_INT 1
42463: PUSH
42464: LD_INT 4
42466: PUSH
42467: EMPTY
42468: LIST
42469: LIST
42470: PUSH
42471: LD_INT 0
42473: PUSH
42474: LD_INT 4
42476: PUSH
42477: EMPTY
42478: LIST
42479: LIST
42480: PUSH
42481: LD_INT 1
42483: NEG
42484: PUSH
42485: LD_INT 3
42487: PUSH
42488: EMPTY
42489: LIST
42490: LIST
42491: PUSH
42492: LD_INT 1
42494: PUSH
42495: LD_INT 5
42497: PUSH
42498: EMPTY
42499: LIST
42500: LIST
42501: PUSH
42502: LD_INT 0
42504: PUSH
42505: LD_INT 5
42507: PUSH
42508: EMPTY
42509: LIST
42510: LIST
42511: PUSH
42512: LD_INT 1
42514: NEG
42515: PUSH
42516: LD_INT 4
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 1
42525: PUSH
42526: LD_INT 6
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 0
42535: PUSH
42536: LD_INT 6
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 1
42545: NEG
42546: PUSH
42547: LD_INT 5
42549: PUSH
42550: EMPTY
42551: LIST
42552: LIST
42553: PUSH
42554: EMPTY
42555: LIST
42556: LIST
42557: LIST
42558: LIST
42559: LIST
42560: LIST
42561: LIST
42562: LIST
42563: LIST
42564: LIST
42565: LIST
42566: LIST
42567: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42568: LD_ADDR_VAR 0 33
42572: PUSH
42573: LD_INT 2
42575: NEG
42576: PUSH
42577: LD_INT 1
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 3
42586: NEG
42587: PUSH
42588: LD_INT 0
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: LD_INT 3
42597: NEG
42598: PUSH
42599: LD_INT 1
42601: NEG
42602: PUSH
42603: EMPTY
42604: LIST
42605: LIST
42606: PUSH
42607: LD_INT 3
42609: NEG
42610: PUSH
42611: LD_INT 1
42613: PUSH
42614: EMPTY
42615: LIST
42616: LIST
42617: PUSH
42618: LD_INT 4
42620: NEG
42621: PUSH
42622: LD_INT 0
42624: PUSH
42625: EMPTY
42626: LIST
42627: LIST
42628: PUSH
42629: LD_INT 4
42631: NEG
42632: PUSH
42633: LD_INT 1
42635: NEG
42636: PUSH
42637: EMPTY
42638: LIST
42639: LIST
42640: PUSH
42641: LD_INT 4
42643: NEG
42644: PUSH
42645: LD_INT 1
42647: PUSH
42648: EMPTY
42649: LIST
42650: LIST
42651: PUSH
42652: LD_INT 5
42654: NEG
42655: PUSH
42656: LD_INT 0
42658: PUSH
42659: EMPTY
42660: LIST
42661: LIST
42662: PUSH
42663: LD_INT 5
42665: NEG
42666: PUSH
42667: LD_INT 1
42669: NEG
42670: PUSH
42671: EMPTY
42672: LIST
42673: LIST
42674: PUSH
42675: LD_INT 5
42677: NEG
42678: PUSH
42679: LD_INT 1
42681: PUSH
42682: EMPTY
42683: LIST
42684: LIST
42685: PUSH
42686: LD_INT 6
42688: NEG
42689: PUSH
42690: LD_INT 0
42692: PUSH
42693: EMPTY
42694: LIST
42695: LIST
42696: PUSH
42697: LD_INT 6
42699: NEG
42700: PUSH
42701: LD_INT 1
42703: NEG
42704: PUSH
42705: EMPTY
42706: LIST
42707: LIST
42708: PUSH
42709: EMPTY
42710: LIST
42711: LIST
42712: LIST
42713: LIST
42714: LIST
42715: LIST
42716: LIST
42717: LIST
42718: LIST
42719: LIST
42720: LIST
42721: LIST
42722: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42723: LD_ADDR_VAR 0 34
42727: PUSH
42728: LD_INT 2
42730: NEG
42731: PUSH
42732: LD_INT 3
42734: NEG
42735: PUSH
42736: EMPTY
42737: LIST
42738: LIST
42739: PUSH
42740: LD_INT 3
42742: NEG
42743: PUSH
42744: LD_INT 2
42746: NEG
42747: PUSH
42748: EMPTY
42749: LIST
42750: LIST
42751: PUSH
42752: LD_INT 3
42754: NEG
42755: PUSH
42756: LD_INT 3
42758: NEG
42759: PUSH
42760: EMPTY
42761: LIST
42762: LIST
42763: PUSH
42764: LD_INT 3
42766: NEG
42767: PUSH
42768: LD_INT 4
42770: NEG
42771: PUSH
42772: EMPTY
42773: LIST
42774: LIST
42775: PUSH
42776: LD_INT 4
42778: NEG
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: EMPTY
42785: LIST
42786: LIST
42787: PUSH
42788: LD_INT 4
42790: NEG
42791: PUSH
42792: LD_INT 4
42794: NEG
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: LD_INT 4
42802: NEG
42803: PUSH
42804: LD_INT 5
42806: NEG
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: LD_INT 5
42814: NEG
42815: PUSH
42816: LD_INT 4
42818: NEG
42819: PUSH
42820: EMPTY
42821: LIST
42822: LIST
42823: PUSH
42824: LD_INT 5
42826: NEG
42827: PUSH
42828: LD_INT 5
42830: NEG
42831: PUSH
42832: EMPTY
42833: LIST
42834: LIST
42835: PUSH
42836: LD_INT 5
42838: NEG
42839: PUSH
42840: LD_INT 6
42842: NEG
42843: PUSH
42844: EMPTY
42845: LIST
42846: LIST
42847: PUSH
42848: LD_INT 6
42850: NEG
42851: PUSH
42852: LD_INT 5
42854: NEG
42855: PUSH
42856: EMPTY
42857: LIST
42858: LIST
42859: PUSH
42860: LD_INT 6
42862: NEG
42863: PUSH
42864: LD_INT 6
42866: NEG
42867: PUSH
42868: EMPTY
42869: LIST
42870: LIST
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: LIST
42876: LIST
42877: LIST
42878: LIST
42879: LIST
42880: LIST
42881: LIST
42882: LIST
42883: LIST
42884: LIST
42885: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42886: LD_ADDR_VAR 0 41
42890: PUSH
42891: LD_INT 0
42893: PUSH
42894: LD_INT 2
42896: NEG
42897: PUSH
42898: EMPTY
42899: LIST
42900: LIST
42901: PUSH
42902: LD_INT 1
42904: NEG
42905: PUSH
42906: LD_INT 3
42908: NEG
42909: PUSH
42910: EMPTY
42911: LIST
42912: LIST
42913: PUSH
42914: LD_INT 1
42916: PUSH
42917: LD_INT 2
42919: NEG
42920: PUSH
42921: EMPTY
42922: LIST
42923: LIST
42924: PUSH
42925: EMPTY
42926: LIST
42927: LIST
42928: LIST
42929: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
42930: LD_ADDR_VAR 0 42
42934: PUSH
42935: LD_INT 2
42937: PUSH
42938: LD_INT 0
42940: PUSH
42941: EMPTY
42942: LIST
42943: LIST
42944: PUSH
42945: LD_INT 2
42947: PUSH
42948: LD_INT 1
42950: NEG
42951: PUSH
42952: EMPTY
42953: LIST
42954: LIST
42955: PUSH
42956: LD_INT 3
42958: PUSH
42959: LD_INT 1
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: PUSH
42966: EMPTY
42967: LIST
42968: LIST
42969: LIST
42970: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
42971: LD_ADDR_VAR 0 43
42975: PUSH
42976: LD_INT 2
42978: PUSH
42979: LD_INT 2
42981: PUSH
42982: EMPTY
42983: LIST
42984: LIST
42985: PUSH
42986: LD_INT 3
42988: PUSH
42989: LD_INT 2
42991: PUSH
42992: EMPTY
42993: LIST
42994: LIST
42995: PUSH
42996: LD_INT 2
42998: PUSH
42999: LD_INT 3
43001: PUSH
43002: EMPTY
43003: LIST
43004: LIST
43005: PUSH
43006: EMPTY
43007: LIST
43008: LIST
43009: LIST
43010: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43011: LD_ADDR_VAR 0 44
43015: PUSH
43016: LD_INT 0
43018: PUSH
43019: LD_INT 2
43021: PUSH
43022: EMPTY
43023: LIST
43024: LIST
43025: PUSH
43026: LD_INT 1
43028: PUSH
43029: LD_INT 3
43031: PUSH
43032: EMPTY
43033: LIST
43034: LIST
43035: PUSH
43036: LD_INT 1
43038: NEG
43039: PUSH
43040: LD_INT 2
43042: PUSH
43043: EMPTY
43044: LIST
43045: LIST
43046: PUSH
43047: EMPTY
43048: LIST
43049: LIST
43050: LIST
43051: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43052: LD_ADDR_VAR 0 45
43056: PUSH
43057: LD_INT 2
43059: NEG
43060: PUSH
43061: LD_INT 0
43063: PUSH
43064: EMPTY
43065: LIST
43066: LIST
43067: PUSH
43068: LD_INT 2
43070: NEG
43071: PUSH
43072: LD_INT 1
43074: PUSH
43075: EMPTY
43076: LIST
43077: LIST
43078: PUSH
43079: LD_INT 3
43081: NEG
43082: PUSH
43083: LD_INT 1
43085: NEG
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: LIST
43095: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43096: LD_ADDR_VAR 0 46
43100: PUSH
43101: LD_INT 2
43103: NEG
43104: PUSH
43105: LD_INT 2
43107: NEG
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: PUSH
43113: LD_INT 2
43115: NEG
43116: PUSH
43117: LD_INT 3
43119: NEG
43120: PUSH
43121: EMPTY
43122: LIST
43123: LIST
43124: PUSH
43125: LD_INT 3
43127: NEG
43128: PUSH
43129: LD_INT 2
43131: NEG
43132: PUSH
43133: EMPTY
43134: LIST
43135: LIST
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: LIST
43141: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43142: LD_ADDR_VAR 0 47
43146: PUSH
43147: LD_INT 2
43149: NEG
43150: PUSH
43151: LD_INT 3
43153: NEG
43154: PUSH
43155: EMPTY
43156: LIST
43157: LIST
43158: PUSH
43159: LD_INT 1
43161: NEG
43162: PUSH
43163: LD_INT 3
43165: NEG
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: EMPTY
43172: LIST
43173: LIST
43174: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43175: LD_ADDR_VAR 0 48
43179: PUSH
43180: LD_INT 1
43182: PUSH
43183: LD_INT 2
43185: NEG
43186: PUSH
43187: EMPTY
43188: LIST
43189: LIST
43190: PUSH
43191: LD_INT 2
43193: PUSH
43194: LD_INT 1
43196: NEG
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: EMPTY
43203: LIST
43204: LIST
43205: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43206: LD_ADDR_VAR 0 49
43210: PUSH
43211: LD_INT 3
43213: PUSH
43214: LD_INT 1
43216: PUSH
43217: EMPTY
43218: LIST
43219: LIST
43220: PUSH
43221: LD_INT 3
43223: PUSH
43224: LD_INT 2
43226: PUSH
43227: EMPTY
43228: LIST
43229: LIST
43230: PUSH
43231: EMPTY
43232: LIST
43233: LIST
43234: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43235: LD_ADDR_VAR 0 50
43239: PUSH
43240: LD_INT 2
43242: PUSH
43243: LD_INT 3
43245: PUSH
43246: EMPTY
43247: LIST
43248: LIST
43249: PUSH
43250: LD_INT 1
43252: PUSH
43253: LD_INT 3
43255: PUSH
43256: EMPTY
43257: LIST
43258: LIST
43259: PUSH
43260: EMPTY
43261: LIST
43262: LIST
43263: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43264: LD_ADDR_VAR 0 51
43268: PUSH
43269: LD_INT 1
43271: NEG
43272: PUSH
43273: LD_INT 2
43275: PUSH
43276: EMPTY
43277: LIST
43278: LIST
43279: PUSH
43280: LD_INT 2
43282: NEG
43283: PUSH
43284: LD_INT 1
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43295: LD_ADDR_VAR 0 52
43299: PUSH
43300: LD_INT 3
43302: NEG
43303: PUSH
43304: LD_INT 1
43306: NEG
43307: PUSH
43308: EMPTY
43309: LIST
43310: LIST
43311: PUSH
43312: LD_INT 3
43314: NEG
43315: PUSH
43316: LD_INT 2
43318: NEG
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: EMPTY
43325: LIST
43326: LIST
43327: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43328: LD_ADDR_VAR 0 53
43332: PUSH
43333: LD_INT 1
43335: NEG
43336: PUSH
43337: LD_INT 3
43339: NEG
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: PUSH
43345: LD_INT 0
43347: PUSH
43348: LD_INT 3
43350: NEG
43351: PUSH
43352: EMPTY
43353: LIST
43354: LIST
43355: PUSH
43356: LD_INT 1
43358: PUSH
43359: LD_INT 2
43361: NEG
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: PUSH
43367: EMPTY
43368: LIST
43369: LIST
43370: LIST
43371: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43372: LD_ADDR_VAR 0 54
43376: PUSH
43377: LD_INT 2
43379: PUSH
43380: LD_INT 1
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 3
43390: PUSH
43391: LD_INT 0
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: PUSH
43398: LD_INT 3
43400: PUSH
43401: LD_INT 1
43403: PUSH
43404: EMPTY
43405: LIST
43406: LIST
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: LIST
43412: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43413: LD_ADDR_VAR 0 55
43417: PUSH
43418: LD_INT 3
43420: PUSH
43421: LD_INT 2
43423: PUSH
43424: EMPTY
43425: LIST
43426: LIST
43427: PUSH
43428: LD_INT 3
43430: PUSH
43431: LD_INT 3
43433: PUSH
43434: EMPTY
43435: LIST
43436: LIST
43437: PUSH
43438: LD_INT 2
43440: PUSH
43441: LD_INT 3
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: EMPTY
43449: LIST
43450: LIST
43451: LIST
43452: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43453: LD_ADDR_VAR 0 56
43457: PUSH
43458: LD_INT 1
43460: PUSH
43461: LD_INT 3
43463: PUSH
43464: EMPTY
43465: LIST
43466: LIST
43467: PUSH
43468: LD_INT 0
43470: PUSH
43471: LD_INT 3
43473: PUSH
43474: EMPTY
43475: LIST
43476: LIST
43477: PUSH
43478: LD_INT 1
43480: NEG
43481: PUSH
43482: LD_INT 2
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: EMPTY
43490: LIST
43491: LIST
43492: LIST
43493: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43494: LD_ADDR_VAR 0 57
43498: PUSH
43499: LD_INT 2
43501: NEG
43502: PUSH
43503: LD_INT 1
43505: PUSH
43506: EMPTY
43507: LIST
43508: LIST
43509: PUSH
43510: LD_INT 3
43512: NEG
43513: PUSH
43514: LD_INT 0
43516: PUSH
43517: EMPTY
43518: LIST
43519: LIST
43520: PUSH
43521: LD_INT 3
43523: NEG
43524: PUSH
43525: LD_INT 1
43527: NEG
43528: PUSH
43529: EMPTY
43530: LIST
43531: LIST
43532: PUSH
43533: EMPTY
43534: LIST
43535: LIST
43536: LIST
43537: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43538: LD_ADDR_VAR 0 58
43542: PUSH
43543: LD_INT 2
43545: NEG
43546: PUSH
43547: LD_INT 3
43549: NEG
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: PUSH
43555: LD_INT 3
43557: NEG
43558: PUSH
43559: LD_INT 2
43561: NEG
43562: PUSH
43563: EMPTY
43564: LIST
43565: LIST
43566: PUSH
43567: LD_INT 3
43569: NEG
43570: PUSH
43571: LD_INT 3
43573: NEG
43574: PUSH
43575: EMPTY
43576: LIST
43577: LIST
43578: PUSH
43579: EMPTY
43580: LIST
43581: LIST
43582: LIST
43583: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43584: LD_ADDR_VAR 0 59
43588: PUSH
43589: LD_INT 1
43591: NEG
43592: PUSH
43593: LD_INT 2
43595: NEG
43596: PUSH
43597: EMPTY
43598: LIST
43599: LIST
43600: PUSH
43601: LD_INT 0
43603: PUSH
43604: LD_INT 2
43606: NEG
43607: PUSH
43608: EMPTY
43609: LIST
43610: LIST
43611: PUSH
43612: LD_INT 1
43614: PUSH
43615: LD_INT 1
43617: NEG
43618: PUSH
43619: EMPTY
43620: LIST
43621: LIST
43622: PUSH
43623: EMPTY
43624: LIST
43625: LIST
43626: LIST
43627: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43628: LD_ADDR_VAR 0 60
43632: PUSH
43633: LD_INT 1
43635: PUSH
43636: LD_INT 1
43638: NEG
43639: PUSH
43640: EMPTY
43641: LIST
43642: LIST
43643: PUSH
43644: LD_INT 2
43646: PUSH
43647: LD_INT 0
43649: PUSH
43650: EMPTY
43651: LIST
43652: LIST
43653: PUSH
43654: LD_INT 2
43656: PUSH
43657: LD_INT 1
43659: PUSH
43660: EMPTY
43661: LIST
43662: LIST
43663: PUSH
43664: EMPTY
43665: LIST
43666: LIST
43667: LIST
43668: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43669: LD_ADDR_VAR 0 61
43673: PUSH
43674: LD_INT 2
43676: PUSH
43677: LD_INT 1
43679: PUSH
43680: EMPTY
43681: LIST
43682: LIST
43683: PUSH
43684: LD_INT 2
43686: PUSH
43687: LD_INT 2
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 1
43696: PUSH
43697: LD_INT 2
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: EMPTY
43705: LIST
43706: LIST
43707: LIST
43708: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43709: LD_ADDR_VAR 0 62
43713: PUSH
43714: LD_INT 1
43716: PUSH
43717: LD_INT 2
43719: PUSH
43720: EMPTY
43721: LIST
43722: LIST
43723: PUSH
43724: LD_INT 0
43726: PUSH
43727: LD_INT 2
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: PUSH
43734: LD_INT 1
43736: NEG
43737: PUSH
43738: LD_INT 1
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: EMPTY
43746: LIST
43747: LIST
43748: LIST
43749: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43750: LD_ADDR_VAR 0 63
43754: PUSH
43755: LD_INT 1
43757: NEG
43758: PUSH
43759: LD_INT 1
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 2
43768: NEG
43769: PUSH
43770: LD_INT 0
43772: PUSH
43773: EMPTY
43774: LIST
43775: LIST
43776: PUSH
43777: LD_INT 2
43779: NEG
43780: PUSH
43781: LD_INT 1
43783: NEG
43784: PUSH
43785: EMPTY
43786: LIST
43787: LIST
43788: PUSH
43789: EMPTY
43790: LIST
43791: LIST
43792: LIST
43793: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43794: LD_ADDR_VAR 0 64
43798: PUSH
43799: LD_INT 1
43801: NEG
43802: PUSH
43803: LD_INT 2
43805: NEG
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: PUSH
43811: LD_INT 2
43813: NEG
43814: PUSH
43815: LD_INT 1
43817: NEG
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 2
43825: NEG
43826: PUSH
43827: LD_INT 2
43829: NEG
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: EMPTY
43836: LIST
43837: LIST
43838: LIST
43839: ST_TO_ADDR
// end ; 2 :
43840: GO 47106
43842: LD_INT 2
43844: DOUBLE
43845: EQUAL
43846: IFTRUE 43850
43848: GO 47105
43850: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43851: LD_ADDR_VAR 0 29
43855: PUSH
43856: LD_INT 4
43858: PUSH
43859: LD_INT 0
43861: PUSH
43862: EMPTY
43863: LIST
43864: LIST
43865: PUSH
43866: LD_INT 4
43868: PUSH
43869: LD_INT 1
43871: NEG
43872: PUSH
43873: EMPTY
43874: LIST
43875: LIST
43876: PUSH
43877: LD_INT 5
43879: PUSH
43880: LD_INT 0
43882: PUSH
43883: EMPTY
43884: LIST
43885: LIST
43886: PUSH
43887: LD_INT 5
43889: PUSH
43890: LD_INT 1
43892: PUSH
43893: EMPTY
43894: LIST
43895: LIST
43896: PUSH
43897: LD_INT 4
43899: PUSH
43900: LD_INT 1
43902: PUSH
43903: EMPTY
43904: LIST
43905: LIST
43906: PUSH
43907: LD_INT 3
43909: PUSH
43910: LD_INT 0
43912: PUSH
43913: EMPTY
43914: LIST
43915: LIST
43916: PUSH
43917: LD_INT 3
43919: PUSH
43920: LD_INT 1
43922: NEG
43923: PUSH
43924: EMPTY
43925: LIST
43926: LIST
43927: PUSH
43928: LD_INT 3
43930: PUSH
43931: LD_INT 2
43933: NEG
43934: PUSH
43935: EMPTY
43936: LIST
43937: LIST
43938: PUSH
43939: LD_INT 5
43941: PUSH
43942: LD_INT 2
43944: PUSH
43945: EMPTY
43946: LIST
43947: LIST
43948: PUSH
43949: LD_INT 3
43951: PUSH
43952: LD_INT 3
43954: PUSH
43955: EMPTY
43956: LIST
43957: LIST
43958: PUSH
43959: LD_INT 3
43961: PUSH
43962: LD_INT 2
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 4
43971: PUSH
43972: LD_INT 3
43974: PUSH
43975: EMPTY
43976: LIST
43977: LIST
43978: PUSH
43979: LD_INT 4
43981: PUSH
43982: LD_INT 4
43984: PUSH
43985: EMPTY
43986: LIST
43987: LIST
43988: PUSH
43989: LD_INT 3
43991: PUSH
43992: LD_INT 4
43994: PUSH
43995: EMPTY
43996: LIST
43997: LIST
43998: PUSH
43999: LD_INT 2
44001: PUSH
44002: LD_INT 3
44004: PUSH
44005: EMPTY
44006: LIST
44007: LIST
44008: PUSH
44009: LD_INT 2
44011: PUSH
44012: LD_INT 2
44014: PUSH
44015: EMPTY
44016: LIST
44017: LIST
44018: PUSH
44019: LD_INT 4
44021: PUSH
44022: LD_INT 2
44024: PUSH
44025: EMPTY
44026: LIST
44027: LIST
44028: PUSH
44029: LD_INT 2
44031: PUSH
44032: LD_INT 4
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PUSH
44039: LD_INT 0
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: EMPTY
44046: LIST
44047: LIST
44048: PUSH
44049: LD_INT 0
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: EMPTY
44056: LIST
44057: LIST
44058: PUSH
44059: LD_INT 1
44061: PUSH
44062: LD_INT 4
44064: PUSH
44065: EMPTY
44066: LIST
44067: LIST
44068: PUSH
44069: LD_INT 1
44071: PUSH
44072: LD_INT 5
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: PUSH
44079: LD_INT 0
44081: PUSH
44082: LD_INT 5
44084: PUSH
44085: EMPTY
44086: LIST
44087: LIST
44088: PUSH
44089: LD_INT 1
44091: NEG
44092: PUSH
44093: LD_INT 4
44095: PUSH
44096: EMPTY
44097: LIST
44098: LIST
44099: PUSH
44100: LD_INT 1
44102: NEG
44103: PUSH
44104: LD_INT 3
44106: PUSH
44107: EMPTY
44108: LIST
44109: LIST
44110: PUSH
44111: LD_INT 2
44113: PUSH
44114: LD_INT 5
44116: PUSH
44117: EMPTY
44118: LIST
44119: LIST
44120: PUSH
44121: LD_INT 2
44123: NEG
44124: PUSH
44125: LD_INT 3
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 3
44134: NEG
44135: PUSH
44136: LD_INT 0
44138: PUSH
44139: EMPTY
44140: LIST
44141: LIST
44142: PUSH
44143: LD_INT 3
44145: NEG
44146: PUSH
44147: LD_INT 1
44149: NEG
44150: PUSH
44151: EMPTY
44152: LIST
44153: LIST
44154: PUSH
44155: LD_INT 2
44157: NEG
44158: PUSH
44159: LD_INT 0
44161: PUSH
44162: EMPTY
44163: LIST
44164: LIST
44165: PUSH
44166: LD_INT 2
44168: NEG
44169: PUSH
44170: LD_INT 1
44172: PUSH
44173: EMPTY
44174: LIST
44175: LIST
44176: PUSH
44177: LD_INT 3
44179: NEG
44180: PUSH
44181: LD_INT 1
44183: PUSH
44184: EMPTY
44185: LIST
44186: LIST
44187: PUSH
44188: LD_INT 4
44190: NEG
44191: PUSH
44192: LD_INT 0
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 4
44201: NEG
44202: PUSH
44203: LD_INT 1
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 4
44213: NEG
44214: PUSH
44215: LD_INT 2
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 2
44225: NEG
44226: PUSH
44227: LD_INT 2
44229: PUSH
44230: EMPTY
44231: LIST
44232: LIST
44233: PUSH
44234: LD_INT 4
44236: NEG
44237: PUSH
44238: LD_INT 4
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 4
44248: NEG
44249: PUSH
44250: LD_INT 5
44252: NEG
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 3
44260: NEG
44261: PUSH
44262: LD_INT 4
44264: NEG
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 3
44272: NEG
44273: PUSH
44274: LD_INT 3
44276: NEG
44277: PUSH
44278: EMPTY
44279: LIST
44280: LIST
44281: PUSH
44282: LD_INT 4
44284: NEG
44285: PUSH
44286: LD_INT 3
44288: NEG
44289: PUSH
44290: EMPTY
44291: LIST
44292: LIST
44293: PUSH
44294: LD_INT 5
44296: NEG
44297: PUSH
44298: LD_INT 4
44300: NEG
44301: PUSH
44302: EMPTY
44303: LIST
44304: LIST
44305: PUSH
44306: LD_INT 5
44308: NEG
44309: PUSH
44310: LD_INT 5
44312: NEG
44313: PUSH
44314: EMPTY
44315: LIST
44316: LIST
44317: PUSH
44318: LD_INT 3
44320: NEG
44321: PUSH
44322: LD_INT 5
44324: NEG
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 5
44332: NEG
44333: PUSH
44334: LD_INT 3
44336: NEG
44337: PUSH
44338: EMPTY
44339: LIST
44340: LIST
44341: PUSH
44342: EMPTY
44343: LIST
44344: LIST
44345: LIST
44346: LIST
44347: LIST
44348: LIST
44349: LIST
44350: LIST
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: LIST
44366: LIST
44367: LIST
44368: LIST
44369: LIST
44370: LIST
44371: LIST
44372: LIST
44373: LIST
44374: LIST
44375: LIST
44376: LIST
44377: LIST
44378: LIST
44379: LIST
44380: LIST
44381: LIST
44382: LIST
44383: LIST
44384: LIST
44385: LIST
44386: LIST
44387: LIST
44388: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44389: LD_ADDR_VAR 0 30
44393: PUSH
44394: LD_INT 4
44396: PUSH
44397: LD_INT 4
44399: PUSH
44400: EMPTY
44401: LIST
44402: LIST
44403: PUSH
44404: LD_INT 4
44406: PUSH
44407: LD_INT 3
44409: PUSH
44410: EMPTY
44411: LIST
44412: LIST
44413: PUSH
44414: LD_INT 5
44416: PUSH
44417: LD_INT 4
44419: PUSH
44420: EMPTY
44421: LIST
44422: LIST
44423: PUSH
44424: LD_INT 5
44426: PUSH
44427: LD_INT 5
44429: PUSH
44430: EMPTY
44431: LIST
44432: LIST
44433: PUSH
44434: LD_INT 4
44436: PUSH
44437: LD_INT 5
44439: PUSH
44440: EMPTY
44441: LIST
44442: LIST
44443: PUSH
44444: LD_INT 3
44446: PUSH
44447: LD_INT 4
44449: PUSH
44450: EMPTY
44451: LIST
44452: LIST
44453: PUSH
44454: LD_INT 3
44456: PUSH
44457: LD_INT 3
44459: PUSH
44460: EMPTY
44461: LIST
44462: LIST
44463: PUSH
44464: LD_INT 5
44466: PUSH
44467: LD_INT 3
44469: PUSH
44470: EMPTY
44471: LIST
44472: LIST
44473: PUSH
44474: LD_INT 3
44476: PUSH
44477: LD_INT 5
44479: PUSH
44480: EMPTY
44481: LIST
44482: LIST
44483: PUSH
44484: LD_INT 0
44486: PUSH
44487: LD_INT 3
44489: PUSH
44490: EMPTY
44491: LIST
44492: LIST
44493: PUSH
44494: LD_INT 0
44496: PUSH
44497: LD_INT 2
44499: PUSH
44500: EMPTY
44501: LIST
44502: LIST
44503: PUSH
44504: LD_INT 1
44506: PUSH
44507: LD_INT 3
44509: PUSH
44510: EMPTY
44511: LIST
44512: LIST
44513: PUSH
44514: LD_INT 1
44516: PUSH
44517: LD_INT 4
44519: PUSH
44520: EMPTY
44521: LIST
44522: LIST
44523: PUSH
44524: LD_INT 0
44526: PUSH
44527: LD_INT 4
44529: PUSH
44530: EMPTY
44531: LIST
44532: LIST
44533: PUSH
44534: LD_INT 1
44536: NEG
44537: PUSH
44538: LD_INT 3
44540: PUSH
44541: EMPTY
44542: LIST
44543: LIST
44544: PUSH
44545: LD_INT 1
44547: NEG
44548: PUSH
44549: LD_INT 2
44551: PUSH
44552: EMPTY
44553: LIST
44554: LIST
44555: PUSH
44556: LD_INT 2
44558: PUSH
44559: LD_INT 4
44561: PUSH
44562: EMPTY
44563: LIST
44564: LIST
44565: PUSH
44566: LD_INT 2
44568: NEG
44569: PUSH
44570: LD_INT 2
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 4
44579: NEG
44580: PUSH
44581: LD_INT 0
44583: PUSH
44584: EMPTY
44585: LIST
44586: LIST
44587: PUSH
44588: LD_INT 4
44590: NEG
44591: PUSH
44592: LD_INT 1
44594: NEG
44595: PUSH
44596: EMPTY
44597: LIST
44598: LIST
44599: PUSH
44600: LD_INT 3
44602: NEG
44603: PUSH
44604: LD_INT 0
44606: PUSH
44607: EMPTY
44608: LIST
44609: LIST
44610: PUSH
44611: LD_INT 3
44613: NEG
44614: PUSH
44615: LD_INT 1
44617: PUSH
44618: EMPTY
44619: LIST
44620: LIST
44621: PUSH
44622: LD_INT 4
44624: NEG
44625: PUSH
44626: LD_INT 1
44628: PUSH
44629: EMPTY
44630: LIST
44631: LIST
44632: PUSH
44633: LD_INT 5
44635: NEG
44636: PUSH
44637: LD_INT 0
44639: PUSH
44640: EMPTY
44641: LIST
44642: LIST
44643: PUSH
44644: LD_INT 5
44646: NEG
44647: PUSH
44648: LD_INT 1
44650: NEG
44651: PUSH
44652: EMPTY
44653: LIST
44654: LIST
44655: PUSH
44656: LD_INT 5
44658: NEG
44659: PUSH
44660: LD_INT 2
44662: NEG
44663: PUSH
44664: EMPTY
44665: LIST
44666: LIST
44667: PUSH
44668: LD_INT 3
44670: NEG
44671: PUSH
44672: LD_INT 2
44674: PUSH
44675: EMPTY
44676: LIST
44677: LIST
44678: PUSH
44679: LD_INT 3
44681: NEG
44682: PUSH
44683: LD_INT 3
44685: NEG
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 3
44693: NEG
44694: PUSH
44695: LD_INT 4
44697: NEG
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 2
44705: NEG
44706: PUSH
44707: LD_INT 3
44709: NEG
44710: PUSH
44711: EMPTY
44712: LIST
44713: LIST
44714: PUSH
44715: LD_INT 2
44717: NEG
44718: PUSH
44719: LD_INT 2
44721: NEG
44722: PUSH
44723: EMPTY
44724: LIST
44725: LIST
44726: PUSH
44727: LD_INT 3
44729: NEG
44730: PUSH
44731: LD_INT 2
44733: NEG
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: PUSH
44739: LD_INT 4
44741: NEG
44742: PUSH
44743: LD_INT 3
44745: NEG
44746: PUSH
44747: EMPTY
44748: LIST
44749: LIST
44750: PUSH
44751: LD_INT 4
44753: NEG
44754: PUSH
44755: LD_INT 4
44757: NEG
44758: PUSH
44759: EMPTY
44760: LIST
44761: LIST
44762: PUSH
44763: LD_INT 2
44765: NEG
44766: PUSH
44767: LD_INT 4
44769: NEG
44770: PUSH
44771: EMPTY
44772: LIST
44773: LIST
44774: PUSH
44775: LD_INT 4
44777: NEG
44778: PUSH
44779: LD_INT 2
44781: NEG
44782: PUSH
44783: EMPTY
44784: LIST
44785: LIST
44786: PUSH
44787: LD_INT 0
44789: PUSH
44790: LD_INT 4
44792: NEG
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 0
44800: PUSH
44801: LD_INT 5
44803: NEG
44804: PUSH
44805: EMPTY
44806: LIST
44807: LIST
44808: PUSH
44809: LD_INT 1
44811: PUSH
44812: LD_INT 4
44814: NEG
44815: PUSH
44816: EMPTY
44817: LIST
44818: LIST
44819: PUSH
44820: LD_INT 1
44822: PUSH
44823: LD_INT 3
44825: NEG
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PUSH
44831: LD_INT 0
44833: PUSH
44834: LD_INT 3
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 1
44844: NEG
44845: PUSH
44846: LD_INT 4
44848: NEG
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PUSH
44854: LD_INT 1
44856: NEG
44857: PUSH
44858: LD_INT 5
44860: NEG
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: PUSH
44866: LD_INT 2
44868: PUSH
44869: LD_INT 3
44871: NEG
44872: PUSH
44873: EMPTY
44874: LIST
44875: LIST
44876: PUSH
44877: LD_INT 2
44879: NEG
44880: PUSH
44881: LD_INT 5
44883: NEG
44884: PUSH
44885: EMPTY
44886: LIST
44887: LIST
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: LIST
44893: LIST
44894: LIST
44895: LIST
44896: LIST
44897: LIST
44898: LIST
44899: LIST
44900: LIST
44901: LIST
44902: LIST
44903: LIST
44904: LIST
44905: LIST
44906: LIST
44907: LIST
44908: LIST
44909: LIST
44910: LIST
44911: LIST
44912: LIST
44913: LIST
44914: LIST
44915: LIST
44916: LIST
44917: LIST
44918: LIST
44919: LIST
44920: LIST
44921: LIST
44922: LIST
44923: LIST
44924: LIST
44925: LIST
44926: LIST
44927: LIST
44928: LIST
44929: LIST
44930: LIST
44931: LIST
44932: LIST
44933: LIST
44934: LIST
44935: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
44936: LD_ADDR_VAR 0 31
44940: PUSH
44941: LD_INT 0
44943: PUSH
44944: LD_INT 4
44946: PUSH
44947: EMPTY
44948: LIST
44949: LIST
44950: PUSH
44951: LD_INT 0
44953: PUSH
44954: LD_INT 3
44956: PUSH
44957: EMPTY
44958: LIST
44959: LIST
44960: PUSH
44961: LD_INT 1
44963: PUSH
44964: LD_INT 4
44966: PUSH
44967: EMPTY
44968: LIST
44969: LIST
44970: PUSH
44971: LD_INT 1
44973: PUSH
44974: LD_INT 5
44976: PUSH
44977: EMPTY
44978: LIST
44979: LIST
44980: PUSH
44981: LD_INT 0
44983: PUSH
44984: LD_INT 5
44986: PUSH
44987: EMPTY
44988: LIST
44989: LIST
44990: PUSH
44991: LD_INT 1
44993: NEG
44994: PUSH
44995: LD_INT 4
44997: PUSH
44998: EMPTY
44999: LIST
45000: LIST
45001: PUSH
45002: LD_INT 1
45004: NEG
45005: PUSH
45006: LD_INT 3
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: PUSH
45013: LD_INT 2
45015: PUSH
45016: LD_INT 5
45018: PUSH
45019: EMPTY
45020: LIST
45021: LIST
45022: PUSH
45023: LD_INT 2
45025: NEG
45026: PUSH
45027: LD_INT 3
45029: PUSH
45030: EMPTY
45031: LIST
45032: LIST
45033: PUSH
45034: LD_INT 3
45036: NEG
45037: PUSH
45038: LD_INT 0
45040: PUSH
45041: EMPTY
45042: LIST
45043: LIST
45044: PUSH
45045: LD_INT 3
45047: NEG
45048: PUSH
45049: LD_INT 1
45051: NEG
45052: PUSH
45053: EMPTY
45054: LIST
45055: LIST
45056: PUSH
45057: LD_INT 2
45059: NEG
45060: PUSH
45061: LD_INT 0
45063: PUSH
45064: EMPTY
45065: LIST
45066: LIST
45067: PUSH
45068: LD_INT 2
45070: NEG
45071: PUSH
45072: LD_INT 1
45074: PUSH
45075: EMPTY
45076: LIST
45077: LIST
45078: PUSH
45079: LD_INT 3
45081: NEG
45082: PUSH
45083: LD_INT 1
45085: PUSH
45086: EMPTY
45087: LIST
45088: LIST
45089: PUSH
45090: LD_INT 4
45092: NEG
45093: PUSH
45094: LD_INT 0
45096: PUSH
45097: EMPTY
45098: LIST
45099: LIST
45100: PUSH
45101: LD_INT 4
45103: NEG
45104: PUSH
45105: LD_INT 1
45107: NEG
45108: PUSH
45109: EMPTY
45110: LIST
45111: LIST
45112: PUSH
45113: LD_INT 4
45115: NEG
45116: PUSH
45117: LD_INT 2
45119: NEG
45120: PUSH
45121: EMPTY
45122: LIST
45123: LIST
45124: PUSH
45125: LD_INT 2
45127: NEG
45128: PUSH
45129: LD_INT 2
45131: PUSH
45132: EMPTY
45133: LIST
45134: LIST
45135: PUSH
45136: LD_INT 4
45138: NEG
45139: PUSH
45140: LD_INT 4
45142: NEG
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 4
45150: NEG
45151: PUSH
45152: LD_INT 5
45154: NEG
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: LD_INT 3
45162: NEG
45163: PUSH
45164: LD_INT 4
45166: NEG
45167: PUSH
45168: EMPTY
45169: LIST
45170: LIST
45171: PUSH
45172: LD_INT 3
45174: NEG
45175: PUSH
45176: LD_INT 3
45178: NEG
45179: PUSH
45180: EMPTY
45181: LIST
45182: LIST
45183: PUSH
45184: LD_INT 4
45186: NEG
45187: PUSH
45188: LD_INT 3
45190: NEG
45191: PUSH
45192: EMPTY
45193: LIST
45194: LIST
45195: PUSH
45196: LD_INT 5
45198: NEG
45199: PUSH
45200: LD_INT 4
45202: NEG
45203: PUSH
45204: EMPTY
45205: LIST
45206: LIST
45207: PUSH
45208: LD_INT 5
45210: NEG
45211: PUSH
45212: LD_INT 5
45214: NEG
45215: PUSH
45216: EMPTY
45217: LIST
45218: LIST
45219: PUSH
45220: LD_INT 3
45222: NEG
45223: PUSH
45224: LD_INT 5
45226: NEG
45227: PUSH
45228: EMPTY
45229: LIST
45230: LIST
45231: PUSH
45232: LD_INT 5
45234: NEG
45235: PUSH
45236: LD_INT 3
45238: NEG
45239: PUSH
45240: EMPTY
45241: LIST
45242: LIST
45243: PUSH
45244: LD_INT 0
45246: PUSH
45247: LD_INT 3
45249: NEG
45250: PUSH
45251: EMPTY
45252: LIST
45253: LIST
45254: PUSH
45255: LD_INT 0
45257: PUSH
45258: LD_INT 4
45260: NEG
45261: PUSH
45262: EMPTY
45263: LIST
45264: LIST
45265: PUSH
45266: LD_INT 1
45268: PUSH
45269: LD_INT 3
45271: NEG
45272: PUSH
45273: EMPTY
45274: LIST
45275: LIST
45276: PUSH
45277: LD_INT 1
45279: PUSH
45280: LD_INT 2
45282: NEG
45283: PUSH
45284: EMPTY
45285: LIST
45286: LIST
45287: PUSH
45288: LD_INT 0
45290: PUSH
45291: LD_INT 2
45293: NEG
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 1
45301: NEG
45302: PUSH
45303: LD_INT 3
45305: NEG
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 1
45313: NEG
45314: PUSH
45315: LD_INT 4
45317: NEG
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 2
45325: PUSH
45326: LD_INT 2
45328: NEG
45329: PUSH
45330: EMPTY
45331: LIST
45332: LIST
45333: PUSH
45334: LD_INT 2
45336: NEG
45337: PUSH
45338: LD_INT 4
45340: NEG
45341: PUSH
45342: EMPTY
45343: LIST
45344: LIST
45345: PUSH
45346: LD_INT 4
45348: PUSH
45349: LD_INT 0
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PUSH
45356: LD_INT 4
45358: PUSH
45359: LD_INT 1
45361: NEG
45362: PUSH
45363: EMPTY
45364: LIST
45365: LIST
45366: PUSH
45367: LD_INT 5
45369: PUSH
45370: LD_INT 0
45372: PUSH
45373: EMPTY
45374: LIST
45375: LIST
45376: PUSH
45377: LD_INT 5
45379: PUSH
45380: LD_INT 1
45382: PUSH
45383: EMPTY
45384: LIST
45385: LIST
45386: PUSH
45387: LD_INT 4
45389: PUSH
45390: LD_INT 1
45392: PUSH
45393: EMPTY
45394: LIST
45395: LIST
45396: PUSH
45397: LD_INT 3
45399: PUSH
45400: LD_INT 0
45402: PUSH
45403: EMPTY
45404: LIST
45405: LIST
45406: PUSH
45407: LD_INT 3
45409: PUSH
45410: LD_INT 1
45412: NEG
45413: PUSH
45414: EMPTY
45415: LIST
45416: LIST
45417: PUSH
45418: LD_INT 3
45420: PUSH
45421: LD_INT 2
45423: NEG
45424: PUSH
45425: EMPTY
45426: LIST
45427: LIST
45428: PUSH
45429: LD_INT 5
45431: PUSH
45432: LD_INT 2
45434: PUSH
45435: EMPTY
45436: LIST
45437: LIST
45438: PUSH
45439: EMPTY
45440: LIST
45441: LIST
45442: LIST
45443: LIST
45444: LIST
45445: LIST
45446: LIST
45447: LIST
45448: LIST
45449: LIST
45450: LIST
45451: LIST
45452: LIST
45453: LIST
45454: LIST
45455: LIST
45456: LIST
45457: LIST
45458: LIST
45459: LIST
45460: LIST
45461: LIST
45462: LIST
45463: LIST
45464: LIST
45465: LIST
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: LIST
45473: LIST
45474: LIST
45475: LIST
45476: LIST
45477: LIST
45478: LIST
45479: LIST
45480: LIST
45481: LIST
45482: LIST
45483: LIST
45484: LIST
45485: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45486: LD_ADDR_VAR 0 32
45490: PUSH
45491: LD_INT 4
45493: NEG
45494: PUSH
45495: LD_INT 0
45497: PUSH
45498: EMPTY
45499: LIST
45500: LIST
45501: PUSH
45502: LD_INT 4
45504: NEG
45505: PUSH
45506: LD_INT 1
45508: NEG
45509: PUSH
45510: EMPTY
45511: LIST
45512: LIST
45513: PUSH
45514: LD_INT 3
45516: NEG
45517: PUSH
45518: LD_INT 0
45520: PUSH
45521: EMPTY
45522: LIST
45523: LIST
45524: PUSH
45525: LD_INT 3
45527: NEG
45528: PUSH
45529: LD_INT 1
45531: PUSH
45532: EMPTY
45533: LIST
45534: LIST
45535: PUSH
45536: LD_INT 4
45538: NEG
45539: PUSH
45540: LD_INT 1
45542: PUSH
45543: EMPTY
45544: LIST
45545: LIST
45546: PUSH
45547: LD_INT 5
45549: NEG
45550: PUSH
45551: LD_INT 0
45553: PUSH
45554: EMPTY
45555: LIST
45556: LIST
45557: PUSH
45558: LD_INT 5
45560: NEG
45561: PUSH
45562: LD_INT 1
45564: NEG
45565: PUSH
45566: EMPTY
45567: LIST
45568: LIST
45569: PUSH
45570: LD_INT 5
45572: NEG
45573: PUSH
45574: LD_INT 2
45576: NEG
45577: PUSH
45578: EMPTY
45579: LIST
45580: LIST
45581: PUSH
45582: LD_INT 3
45584: NEG
45585: PUSH
45586: LD_INT 2
45588: PUSH
45589: EMPTY
45590: LIST
45591: LIST
45592: PUSH
45593: LD_INT 3
45595: NEG
45596: PUSH
45597: LD_INT 3
45599: NEG
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: PUSH
45605: LD_INT 3
45607: NEG
45608: PUSH
45609: LD_INT 4
45611: NEG
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: PUSH
45617: LD_INT 2
45619: NEG
45620: PUSH
45621: LD_INT 3
45623: NEG
45624: PUSH
45625: EMPTY
45626: LIST
45627: LIST
45628: PUSH
45629: LD_INT 2
45631: NEG
45632: PUSH
45633: LD_INT 2
45635: NEG
45636: PUSH
45637: EMPTY
45638: LIST
45639: LIST
45640: PUSH
45641: LD_INT 3
45643: NEG
45644: PUSH
45645: LD_INT 2
45647: NEG
45648: PUSH
45649: EMPTY
45650: LIST
45651: LIST
45652: PUSH
45653: LD_INT 4
45655: NEG
45656: PUSH
45657: LD_INT 3
45659: NEG
45660: PUSH
45661: EMPTY
45662: LIST
45663: LIST
45664: PUSH
45665: LD_INT 4
45667: NEG
45668: PUSH
45669: LD_INT 4
45671: NEG
45672: PUSH
45673: EMPTY
45674: LIST
45675: LIST
45676: PUSH
45677: LD_INT 2
45679: NEG
45680: PUSH
45681: LD_INT 4
45683: NEG
45684: PUSH
45685: EMPTY
45686: LIST
45687: LIST
45688: PUSH
45689: LD_INT 4
45691: NEG
45692: PUSH
45693: LD_INT 2
45695: NEG
45696: PUSH
45697: EMPTY
45698: LIST
45699: LIST
45700: PUSH
45701: LD_INT 0
45703: PUSH
45704: LD_INT 4
45706: NEG
45707: PUSH
45708: EMPTY
45709: LIST
45710: LIST
45711: PUSH
45712: LD_INT 0
45714: PUSH
45715: LD_INT 5
45717: NEG
45718: PUSH
45719: EMPTY
45720: LIST
45721: LIST
45722: PUSH
45723: LD_INT 1
45725: PUSH
45726: LD_INT 4
45728: NEG
45729: PUSH
45730: EMPTY
45731: LIST
45732: LIST
45733: PUSH
45734: LD_INT 1
45736: PUSH
45737: LD_INT 3
45739: NEG
45740: PUSH
45741: EMPTY
45742: LIST
45743: LIST
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: LD_INT 3
45750: NEG
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 1
45758: NEG
45759: PUSH
45760: LD_INT 4
45762: NEG
45763: PUSH
45764: EMPTY
45765: LIST
45766: LIST
45767: PUSH
45768: LD_INT 1
45770: NEG
45771: PUSH
45772: LD_INT 5
45774: NEG
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 2
45782: PUSH
45783: LD_INT 3
45785: NEG
45786: PUSH
45787: EMPTY
45788: LIST
45789: LIST
45790: PUSH
45791: LD_INT 2
45793: NEG
45794: PUSH
45795: LD_INT 5
45797: NEG
45798: PUSH
45799: EMPTY
45800: LIST
45801: LIST
45802: PUSH
45803: LD_INT 3
45805: PUSH
45806: LD_INT 0
45808: PUSH
45809: EMPTY
45810: LIST
45811: LIST
45812: PUSH
45813: LD_INT 3
45815: PUSH
45816: LD_INT 1
45818: NEG
45819: PUSH
45820: EMPTY
45821: LIST
45822: LIST
45823: PUSH
45824: LD_INT 4
45826: PUSH
45827: LD_INT 0
45829: PUSH
45830: EMPTY
45831: LIST
45832: LIST
45833: PUSH
45834: LD_INT 4
45836: PUSH
45837: LD_INT 1
45839: PUSH
45840: EMPTY
45841: LIST
45842: LIST
45843: PUSH
45844: LD_INT 3
45846: PUSH
45847: LD_INT 1
45849: PUSH
45850: EMPTY
45851: LIST
45852: LIST
45853: PUSH
45854: LD_INT 2
45856: PUSH
45857: LD_INT 0
45859: PUSH
45860: EMPTY
45861: LIST
45862: LIST
45863: PUSH
45864: LD_INT 2
45866: PUSH
45867: LD_INT 1
45869: NEG
45870: PUSH
45871: EMPTY
45872: LIST
45873: LIST
45874: PUSH
45875: LD_INT 2
45877: PUSH
45878: LD_INT 2
45880: NEG
45881: PUSH
45882: EMPTY
45883: LIST
45884: LIST
45885: PUSH
45886: LD_INT 4
45888: PUSH
45889: LD_INT 2
45891: PUSH
45892: EMPTY
45893: LIST
45894: LIST
45895: PUSH
45896: LD_INT 4
45898: PUSH
45899: LD_INT 4
45901: PUSH
45902: EMPTY
45903: LIST
45904: LIST
45905: PUSH
45906: LD_INT 4
45908: PUSH
45909: LD_INT 3
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 5
45918: PUSH
45919: LD_INT 4
45921: PUSH
45922: EMPTY
45923: LIST
45924: LIST
45925: PUSH
45926: LD_INT 5
45928: PUSH
45929: LD_INT 5
45931: PUSH
45932: EMPTY
45933: LIST
45934: LIST
45935: PUSH
45936: LD_INT 4
45938: PUSH
45939: LD_INT 5
45941: PUSH
45942: EMPTY
45943: LIST
45944: LIST
45945: PUSH
45946: LD_INT 3
45948: PUSH
45949: LD_INT 4
45951: PUSH
45952: EMPTY
45953: LIST
45954: LIST
45955: PUSH
45956: LD_INT 3
45958: PUSH
45959: LD_INT 3
45961: PUSH
45962: EMPTY
45963: LIST
45964: LIST
45965: PUSH
45966: LD_INT 5
45968: PUSH
45969: LD_INT 3
45971: PUSH
45972: EMPTY
45973: LIST
45974: LIST
45975: PUSH
45976: LD_INT 3
45978: PUSH
45979: LD_INT 5
45981: PUSH
45982: EMPTY
45983: LIST
45984: LIST
45985: PUSH
45986: EMPTY
45987: LIST
45988: LIST
45989: LIST
45990: LIST
45991: LIST
45992: LIST
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: LIST
46001: LIST
46002: LIST
46003: LIST
46004: LIST
46005: LIST
46006: LIST
46007: LIST
46008: LIST
46009: LIST
46010: LIST
46011: LIST
46012: LIST
46013: LIST
46014: LIST
46015: LIST
46016: LIST
46017: LIST
46018: LIST
46019: LIST
46020: LIST
46021: LIST
46022: LIST
46023: LIST
46024: LIST
46025: LIST
46026: LIST
46027: LIST
46028: LIST
46029: LIST
46030: LIST
46031: LIST
46032: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46033: LD_ADDR_VAR 0 33
46037: PUSH
46038: LD_INT 4
46040: NEG
46041: PUSH
46042: LD_INT 4
46044: NEG
46045: PUSH
46046: EMPTY
46047: LIST
46048: LIST
46049: PUSH
46050: LD_INT 4
46052: NEG
46053: PUSH
46054: LD_INT 5
46056: NEG
46057: PUSH
46058: EMPTY
46059: LIST
46060: LIST
46061: PUSH
46062: LD_INT 3
46064: NEG
46065: PUSH
46066: LD_INT 4
46068: NEG
46069: PUSH
46070: EMPTY
46071: LIST
46072: LIST
46073: PUSH
46074: LD_INT 3
46076: NEG
46077: PUSH
46078: LD_INT 3
46080: NEG
46081: PUSH
46082: EMPTY
46083: LIST
46084: LIST
46085: PUSH
46086: LD_INT 4
46088: NEG
46089: PUSH
46090: LD_INT 3
46092: NEG
46093: PUSH
46094: EMPTY
46095: LIST
46096: LIST
46097: PUSH
46098: LD_INT 5
46100: NEG
46101: PUSH
46102: LD_INT 4
46104: NEG
46105: PUSH
46106: EMPTY
46107: LIST
46108: LIST
46109: PUSH
46110: LD_INT 5
46112: NEG
46113: PUSH
46114: LD_INT 5
46116: NEG
46117: PUSH
46118: EMPTY
46119: LIST
46120: LIST
46121: PUSH
46122: LD_INT 3
46124: NEG
46125: PUSH
46126: LD_INT 5
46128: NEG
46129: PUSH
46130: EMPTY
46131: LIST
46132: LIST
46133: PUSH
46134: LD_INT 5
46136: NEG
46137: PUSH
46138: LD_INT 3
46140: NEG
46141: PUSH
46142: EMPTY
46143: LIST
46144: LIST
46145: PUSH
46146: LD_INT 0
46148: PUSH
46149: LD_INT 3
46151: NEG
46152: PUSH
46153: EMPTY
46154: LIST
46155: LIST
46156: PUSH
46157: LD_INT 0
46159: PUSH
46160: LD_INT 4
46162: NEG
46163: PUSH
46164: EMPTY
46165: LIST
46166: LIST
46167: PUSH
46168: LD_INT 1
46170: PUSH
46171: LD_INT 3
46173: NEG
46174: PUSH
46175: EMPTY
46176: LIST
46177: LIST
46178: PUSH
46179: LD_INT 1
46181: PUSH
46182: LD_INT 2
46184: NEG
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: PUSH
46190: LD_INT 0
46192: PUSH
46193: LD_INT 2
46195: NEG
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 1
46203: NEG
46204: PUSH
46205: LD_INT 3
46207: NEG
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 1
46215: NEG
46216: PUSH
46217: LD_INT 4
46219: NEG
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 2
46227: PUSH
46228: LD_INT 2
46230: NEG
46231: PUSH
46232: EMPTY
46233: LIST
46234: LIST
46235: PUSH
46236: LD_INT 2
46238: NEG
46239: PUSH
46240: LD_INT 4
46242: NEG
46243: PUSH
46244: EMPTY
46245: LIST
46246: LIST
46247: PUSH
46248: LD_INT 4
46250: PUSH
46251: LD_INT 0
46253: PUSH
46254: EMPTY
46255: LIST
46256: LIST
46257: PUSH
46258: LD_INT 4
46260: PUSH
46261: LD_INT 1
46263: NEG
46264: PUSH
46265: EMPTY
46266: LIST
46267: LIST
46268: PUSH
46269: LD_INT 5
46271: PUSH
46272: LD_INT 0
46274: PUSH
46275: EMPTY
46276: LIST
46277: LIST
46278: PUSH
46279: LD_INT 5
46281: PUSH
46282: LD_INT 1
46284: PUSH
46285: EMPTY
46286: LIST
46287: LIST
46288: PUSH
46289: LD_INT 4
46291: PUSH
46292: LD_INT 1
46294: PUSH
46295: EMPTY
46296: LIST
46297: LIST
46298: PUSH
46299: LD_INT 3
46301: PUSH
46302: LD_INT 0
46304: PUSH
46305: EMPTY
46306: LIST
46307: LIST
46308: PUSH
46309: LD_INT 3
46311: PUSH
46312: LD_INT 1
46314: NEG
46315: PUSH
46316: EMPTY
46317: LIST
46318: LIST
46319: PUSH
46320: LD_INT 3
46322: PUSH
46323: LD_INT 2
46325: NEG
46326: PUSH
46327: EMPTY
46328: LIST
46329: LIST
46330: PUSH
46331: LD_INT 5
46333: PUSH
46334: LD_INT 2
46336: PUSH
46337: EMPTY
46338: LIST
46339: LIST
46340: PUSH
46341: LD_INT 3
46343: PUSH
46344: LD_INT 3
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 3
46353: PUSH
46354: LD_INT 2
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: LD_INT 3
46366: PUSH
46367: EMPTY
46368: LIST
46369: LIST
46370: PUSH
46371: LD_INT 4
46373: PUSH
46374: LD_INT 4
46376: PUSH
46377: EMPTY
46378: LIST
46379: LIST
46380: PUSH
46381: LD_INT 3
46383: PUSH
46384: LD_INT 4
46386: PUSH
46387: EMPTY
46388: LIST
46389: LIST
46390: PUSH
46391: LD_INT 2
46393: PUSH
46394: LD_INT 3
46396: PUSH
46397: EMPTY
46398: LIST
46399: LIST
46400: PUSH
46401: LD_INT 2
46403: PUSH
46404: LD_INT 2
46406: PUSH
46407: EMPTY
46408: LIST
46409: LIST
46410: PUSH
46411: LD_INT 4
46413: PUSH
46414: LD_INT 2
46416: PUSH
46417: EMPTY
46418: LIST
46419: LIST
46420: PUSH
46421: LD_INT 2
46423: PUSH
46424: LD_INT 4
46426: PUSH
46427: EMPTY
46428: LIST
46429: LIST
46430: PUSH
46431: LD_INT 0
46433: PUSH
46434: LD_INT 4
46436: PUSH
46437: EMPTY
46438: LIST
46439: LIST
46440: PUSH
46441: LD_INT 0
46443: PUSH
46444: LD_INT 3
46446: PUSH
46447: EMPTY
46448: LIST
46449: LIST
46450: PUSH
46451: LD_INT 1
46453: PUSH
46454: LD_INT 4
46456: PUSH
46457: EMPTY
46458: LIST
46459: LIST
46460: PUSH
46461: LD_INT 1
46463: PUSH
46464: LD_INT 5
46466: PUSH
46467: EMPTY
46468: LIST
46469: LIST
46470: PUSH
46471: LD_INT 0
46473: PUSH
46474: LD_INT 5
46476: PUSH
46477: EMPTY
46478: LIST
46479: LIST
46480: PUSH
46481: LD_INT 1
46483: NEG
46484: PUSH
46485: LD_INT 4
46487: PUSH
46488: EMPTY
46489: LIST
46490: LIST
46491: PUSH
46492: LD_INT 1
46494: NEG
46495: PUSH
46496: LD_INT 3
46498: PUSH
46499: EMPTY
46500: LIST
46501: LIST
46502: PUSH
46503: LD_INT 2
46505: PUSH
46506: LD_INT 5
46508: PUSH
46509: EMPTY
46510: LIST
46511: LIST
46512: PUSH
46513: LD_INT 2
46515: NEG
46516: PUSH
46517: LD_INT 3
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: PUSH
46524: EMPTY
46525: LIST
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: LIST
46534: LIST
46535: LIST
46536: LIST
46537: LIST
46538: LIST
46539: LIST
46540: LIST
46541: LIST
46542: LIST
46543: LIST
46544: LIST
46545: LIST
46546: LIST
46547: LIST
46548: LIST
46549: LIST
46550: LIST
46551: LIST
46552: LIST
46553: LIST
46554: LIST
46555: LIST
46556: LIST
46557: LIST
46558: LIST
46559: LIST
46560: LIST
46561: LIST
46562: LIST
46563: LIST
46564: LIST
46565: LIST
46566: LIST
46567: LIST
46568: LIST
46569: LIST
46570: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46571: LD_ADDR_VAR 0 34
46575: PUSH
46576: LD_INT 0
46578: PUSH
46579: LD_INT 4
46581: NEG
46582: PUSH
46583: EMPTY
46584: LIST
46585: LIST
46586: PUSH
46587: LD_INT 0
46589: PUSH
46590: LD_INT 5
46592: NEG
46593: PUSH
46594: EMPTY
46595: LIST
46596: LIST
46597: PUSH
46598: LD_INT 1
46600: PUSH
46601: LD_INT 4
46603: NEG
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_INT 1
46611: PUSH
46612: LD_INT 3
46614: NEG
46615: PUSH
46616: EMPTY
46617: LIST
46618: LIST
46619: PUSH
46620: LD_INT 0
46622: PUSH
46623: LD_INT 3
46625: NEG
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: PUSH
46631: LD_INT 1
46633: NEG
46634: PUSH
46635: LD_INT 4
46637: NEG
46638: PUSH
46639: EMPTY
46640: LIST
46641: LIST
46642: PUSH
46643: LD_INT 1
46645: NEG
46646: PUSH
46647: LD_INT 5
46649: NEG
46650: PUSH
46651: EMPTY
46652: LIST
46653: LIST
46654: PUSH
46655: LD_INT 2
46657: PUSH
46658: LD_INT 3
46660: NEG
46661: PUSH
46662: EMPTY
46663: LIST
46664: LIST
46665: PUSH
46666: LD_INT 2
46668: NEG
46669: PUSH
46670: LD_INT 5
46672: NEG
46673: PUSH
46674: EMPTY
46675: LIST
46676: LIST
46677: PUSH
46678: LD_INT 3
46680: PUSH
46681: LD_INT 0
46683: PUSH
46684: EMPTY
46685: LIST
46686: LIST
46687: PUSH
46688: LD_INT 3
46690: PUSH
46691: LD_INT 1
46693: NEG
46694: PUSH
46695: EMPTY
46696: LIST
46697: LIST
46698: PUSH
46699: LD_INT 4
46701: PUSH
46702: LD_INT 0
46704: PUSH
46705: EMPTY
46706: LIST
46707: LIST
46708: PUSH
46709: LD_INT 4
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: EMPTY
46716: LIST
46717: LIST
46718: PUSH
46719: LD_INT 3
46721: PUSH
46722: LD_INT 1
46724: PUSH
46725: EMPTY
46726: LIST
46727: LIST
46728: PUSH
46729: LD_INT 2
46731: PUSH
46732: LD_INT 0
46734: PUSH
46735: EMPTY
46736: LIST
46737: LIST
46738: PUSH
46739: LD_INT 2
46741: PUSH
46742: LD_INT 1
46744: NEG
46745: PUSH
46746: EMPTY
46747: LIST
46748: LIST
46749: PUSH
46750: LD_INT 2
46752: PUSH
46753: LD_INT 2
46755: NEG
46756: PUSH
46757: EMPTY
46758: LIST
46759: LIST
46760: PUSH
46761: LD_INT 4
46763: PUSH
46764: LD_INT 2
46766: PUSH
46767: EMPTY
46768: LIST
46769: LIST
46770: PUSH
46771: LD_INT 4
46773: PUSH
46774: LD_INT 4
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 4
46783: PUSH
46784: LD_INT 3
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 5
46793: PUSH
46794: LD_INT 4
46796: PUSH
46797: EMPTY
46798: LIST
46799: LIST
46800: PUSH
46801: LD_INT 5
46803: PUSH
46804: LD_INT 5
46806: PUSH
46807: EMPTY
46808: LIST
46809: LIST
46810: PUSH
46811: LD_INT 4
46813: PUSH
46814: LD_INT 5
46816: PUSH
46817: EMPTY
46818: LIST
46819: LIST
46820: PUSH
46821: LD_INT 3
46823: PUSH
46824: LD_INT 4
46826: PUSH
46827: EMPTY
46828: LIST
46829: LIST
46830: PUSH
46831: LD_INT 3
46833: PUSH
46834: LD_INT 3
46836: PUSH
46837: EMPTY
46838: LIST
46839: LIST
46840: PUSH
46841: LD_INT 5
46843: PUSH
46844: LD_INT 3
46846: PUSH
46847: EMPTY
46848: LIST
46849: LIST
46850: PUSH
46851: LD_INT 3
46853: PUSH
46854: LD_INT 5
46856: PUSH
46857: EMPTY
46858: LIST
46859: LIST
46860: PUSH
46861: LD_INT 0
46863: PUSH
46864: LD_INT 3
46866: PUSH
46867: EMPTY
46868: LIST
46869: LIST
46870: PUSH
46871: LD_INT 0
46873: PUSH
46874: LD_INT 2
46876: PUSH
46877: EMPTY
46878: LIST
46879: LIST
46880: PUSH
46881: LD_INT 1
46883: PUSH
46884: LD_INT 3
46886: PUSH
46887: EMPTY
46888: LIST
46889: LIST
46890: PUSH
46891: LD_INT 1
46893: PUSH
46894: LD_INT 4
46896: PUSH
46897: EMPTY
46898: LIST
46899: LIST
46900: PUSH
46901: LD_INT 0
46903: PUSH
46904: LD_INT 4
46906: PUSH
46907: EMPTY
46908: LIST
46909: LIST
46910: PUSH
46911: LD_INT 1
46913: NEG
46914: PUSH
46915: LD_INT 3
46917: PUSH
46918: EMPTY
46919: LIST
46920: LIST
46921: PUSH
46922: LD_INT 1
46924: NEG
46925: PUSH
46926: LD_INT 2
46928: PUSH
46929: EMPTY
46930: LIST
46931: LIST
46932: PUSH
46933: LD_INT 2
46935: PUSH
46936: LD_INT 4
46938: PUSH
46939: EMPTY
46940: LIST
46941: LIST
46942: PUSH
46943: LD_INT 2
46945: NEG
46946: PUSH
46947: LD_INT 2
46949: PUSH
46950: EMPTY
46951: LIST
46952: LIST
46953: PUSH
46954: LD_INT 4
46956: NEG
46957: PUSH
46958: LD_INT 0
46960: PUSH
46961: EMPTY
46962: LIST
46963: LIST
46964: PUSH
46965: LD_INT 4
46967: NEG
46968: PUSH
46969: LD_INT 1
46971: NEG
46972: PUSH
46973: EMPTY
46974: LIST
46975: LIST
46976: PUSH
46977: LD_INT 3
46979: NEG
46980: PUSH
46981: LD_INT 0
46983: PUSH
46984: EMPTY
46985: LIST
46986: LIST
46987: PUSH
46988: LD_INT 3
46990: NEG
46991: PUSH
46992: LD_INT 1
46994: PUSH
46995: EMPTY
46996: LIST
46997: LIST
46998: PUSH
46999: LD_INT 4
47001: NEG
47002: PUSH
47003: LD_INT 1
47005: PUSH
47006: EMPTY
47007: LIST
47008: LIST
47009: PUSH
47010: LD_INT 5
47012: NEG
47013: PUSH
47014: LD_INT 0
47016: PUSH
47017: EMPTY
47018: LIST
47019: LIST
47020: PUSH
47021: LD_INT 5
47023: NEG
47024: PUSH
47025: LD_INT 1
47027: NEG
47028: PUSH
47029: EMPTY
47030: LIST
47031: LIST
47032: PUSH
47033: LD_INT 5
47035: NEG
47036: PUSH
47037: LD_INT 2
47039: NEG
47040: PUSH
47041: EMPTY
47042: LIST
47043: LIST
47044: PUSH
47045: LD_INT 3
47047: NEG
47048: PUSH
47049: LD_INT 2
47051: PUSH
47052: EMPTY
47053: LIST
47054: LIST
47055: PUSH
47056: EMPTY
47057: LIST
47058: LIST
47059: LIST
47060: LIST
47061: LIST
47062: LIST
47063: LIST
47064: LIST
47065: LIST
47066: LIST
47067: LIST
47068: LIST
47069: LIST
47070: LIST
47071: LIST
47072: LIST
47073: LIST
47074: LIST
47075: LIST
47076: LIST
47077: LIST
47078: LIST
47079: LIST
47080: LIST
47081: LIST
47082: LIST
47083: LIST
47084: LIST
47085: LIST
47086: LIST
47087: LIST
47088: LIST
47089: LIST
47090: LIST
47091: LIST
47092: LIST
47093: LIST
47094: LIST
47095: LIST
47096: LIST
47097: LIST
47098: LIST
47099: LIST
47100: LIST
47101: LIST
47102: ST_TO_ADDR
// end ; end ;
47103: GO 47106
47105: POP
// case btype of b_depot , b_warehouse :
47106: LD_VAR 0 1
47110: PUSH
47111: LD_INT 0
47113: DOUBLE
47114: EQUAL
47115: IFTRUE 47125
47117: LD_INT 1
47119: DOUBLE
47120: EQUAL
47121: IFTRUE 47125
47123: GO 47326
47125: POP
// case nation of nation_american :
47126: LD_VAR 0 5
47130: PUSH
47131: LD_INT 1
47133: DOUBLE
47134: EQUAL
47135: IFTRUE 47139
47137: GO 47195
47139: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
47140: LD_ADDR_VAR 0 9
47144: PUSH
47145: LD_VAR 0 11
47149: PUSH
47150: LD_VAR 0 12
47154: PUSH
47155: LD_VAR 0 13
47159: PUSH
47160: LD_VAR 0 14
47164: PUSH
47165: LD_VAR 0 15
47169: PUSH
47170: LD_VAR 0 16
47174: PUSH
47175: EMPTY
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: PUSH
47183: LD_VAR 0 4
47187: PUSH
47188: LD_INT 1
47190: PLUS
47191: ARRAY
47192: ST_TO_ADDR
47193: GO 47324
47195: LD_INT 2
47197: DOUBLE
47198: EQUAL
47199: IFTRUE 47203
47201: GO 47259
47203: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
47204: LD_ADDR_VAR 0 9
47208: PUSH
47209: LD_VAR 0 17
47213: PUSH
47214: LD_VAR 0 18
47218: PUSH
47219: LD_VAR 0 19
47223: PUSH
47224: LD_VAR 0 20
47228: PUSH
47229: LD_VAR 0 21
47233: PUSH
47234: LD_VAR 0 22
47238: PUSH
47239: EMPTY
47240: LIST
47241: LIST
47242: LIST
47243: LIST
47244: LIST
47245: LIST
47246: PUSH
47247: LD_VAR 0 4
47251: PUSH
47252: LD_INT 1
47254: PLUS
47255: ARRAY
47256: ST_TO_ADDR
47257: GO 47324
47259: LD_INT 3
47261: DOUBLE
47262: EQUAL
47263: IFTRUE 47267
47265: GO 47323
47267: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47268: LD_ADDR_VAR 0 9
47272: PUSH
47273: LD_VAR 0 23
47277: PUSH
47278: LD_VAR 0 24
47282: PUSH
47283: LD_VAR 0 25
47287: PUSH
47288: LD_VAR 0 26
47292: PUSH
47293: LD_VAR 0 27
47297: PUSH
47298: LD_VAR 0 28
47302: PUSH
47303: EMPTY
47304: LIST
47305: LIST
47306: LIST
47307: LIST
47308: LIST
47309: LIST
47310: PUSH
47311: LD_VAR 0 4
47315: PUSH
47316: LD_INT 1
47318: PLUS
47319: ARRAY
47320: ST_TO_ADDR
47321: GO 47324
47323: POP
47324: GO 47879
47326: LD_INT 2
47328: DOUBLE
47329: EQUAL
47330: IFTRUE 47340
47332: LD_INT 3
47334: DOUBLE
47335: EQUAL
47336: IFTRUE 47340
47338: GO 47396
47340: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47341: LD_ADDR_VAR 0 9
47345: PUSH
47346: LD_VAR 0 29
47350: PUSH
47351: LD_VAR 0 30
47355: PUSH
47356: LD_VAR 0 31
47360: PUSH
47361: LD_VAR 0 32
47365: PUSH
47366: LD_VAR 0 33
47370: PUSH
47371: LD_VAR 0 34
47375: PUSH
47376: EMPTY
47377: LIST
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: LIST
47383: PUSH
47384: LD_VAR 0 4
47388: PUSH
47389: LD_INT 1
47391: PLUS
47392: ARRAY
47393: ST_TO_ADDR
47394: GO 47879
47396: LD_INT 16
47398: DOUBLE
47399: EQUAL
47400: IFTRUE 47458
47402: LD_INT 17
47404: DOUBLE
47405: EQUAL
47406: IFTRUE 47458
47408: LD_INT 18
47410: DOUBLE
47411: EQUAL
47412: IFTRUE 47458
47414: LD_INT 19
47416: DOUBLE
47417: EQUAL
47418: IFTRUE 47458
47420: LD_INT 22
47422: DOUBLE
47423: EQUAL
47424: IFTRUE 47458
47426: LD_INT 20
47428: DOUBLE
47429: EQUAL
47430: IFTRUE 47458
47432: LD_INT 21
47434: DOUBLE
47435: EQUAL
47436: IFTRUE 47458
47438: LD_INT 23
47440: DOUBLE
47441: EQUAL
47442: IFTRUE 47458
47444: LD_INT 24
47446: DOUBLE
47447: EQUAL
47448: IFTRUE 47458
47450: LD_INT 25
47452: DOUBLE
47453: EQUAL
47454: IFTRUE 47458
47456: GO 47514
47458: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47459: LD_ADDR_VAR 0 9
47463: PUSH
47464: LD_VAR 0 35
47468: PUSH
47469: LD_VAR 0 36
47473: PUSH
47474: LD_VAR 0 37
47478: PUSH
47479: LD_VAR 0 38
47483: PUSH
47484: LD_VAR 0 39
47488: PUSH
47489: LD_VAR 0 40
47493: PUSH
47494: EMPTY
47495: LIST
47496: LIST
47497: LIST
47498: LIST
47499: LIST
47500: LIST
47501: PUSH
47502: LD_VAR 0 4
47506: PUSH
47507: LD_INT 1
47509: PLUS
47510: ARRAY
47511: ST_TO_ADDR
47512: GO 47879
47514: LD_INT 6
47516: DOUBLE
47517: EQUAL
47518: IFTRUE 47570
47520: LD_INT 7
47522: DOUBLE
47523: EQUAL
47524: IFTRUE 47570
47526: LD_INT 8
47528: DOUBLE
47529: EQUAL
47530: IFTRUE 47570
47532: LD_INT 13
47534: DOUBLE
47535: EQUAL
47536: IFTRUE 47570
47538: LD_INT 12
47540: DOUBLE
47541: EQUAL
47542: IFTRUE 47570
47544: LD_INT 15
47546: DOUBLE
47547: EQUAL
47548: IFTRUE 47570
47550: LD_INT 11
47552: DOUBLE
47553: EQUAL
47554: IFTRUE 47570
47556: LD_INT 14
47558: DOUBLE
47559: EQUAL
47560: IFTRUE 47570
47562: LD_INT 10
47564: DOUBLE
47565: EQUAL
47566: IFTRUE 47570
47568: GO 47626
47570: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
47571: LD_ADDR_VAR 0 9
47575: PUSH
47576: LD_VAR 0 41
47580: PUSH
47581: LD_VAR 0 42
47585: PUSH
47586: LD_VAR 0 43
47590: PUSH
47591: LD_VAR 0 44
47595: PUSH
47596: LD_VAR 0 45
47600: PUSH
47601: LD_VAR 0 46
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: LIST
47610: LIST
47611: LIST
47612: LIST
47613: PUSH
47614: LD_VAR 0 4
47618: PUSH
47619: LD_INT 1
47621: PLUS
47622: ARRAY
47623: ST_TO_ADDR
47624: GO 47879
47626: LD_INT 36
47628: DOUBLE
47629: EQUAL
47630: IFTRUE 47634
47632: GO 47690
47634: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47635: LD_ADDR_VAR 0 9
47639: PUSH
47640: LD_VAR 0 47
47644: PUSH
47645: LD_VAR 0 48
47649: PUSH
47650: LD_VAR 0 49
47654: PUSH
47655: LD_VAR 0 50
47659: PUSH
47660: LD_VAR 0 51
47664: PUSH
47665: LD_VAR 0 52
47669: PUSH
47670: EMPTY
47671: LIST
47672: LIST
47673: LIST
47674: LIST
47675: LIST
47676: LIST
47677: PUSH
47678: LD_VAR 0 4
47682: PUSH
47683: LD_INT 1
47685: PLUS
47686: ARRAY
47687: ST_TO_ADDR
47688: GO 47879
47690: LD_INT 4
47692: DOUBLE
47693: EQUAL
47694: IFTRUE 47716
47696: LD_INT 5
47698: DOUBLE
47699: EQUAL
47700: IFTRUE 47716
47702: LD_INT 34
47704: DOUBLE
47705: EQUAL
47706: IFTRUE 47716
47708: LD_INT 37
47710: DOUBLE
47711: EQUAL
47712: IFTRUE 47716
47714: GO 47772
47716: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47717: LD_ADDR_VAR 0 9
47721: PUSH
47722: LD_VAR 0 53
47726: PUSH
47727: LD_VAR 0 54
47731: PUSH
47732: LD_VAR 0 55
47736: PUSH
47737: LD_VAR 0 56
47741: PUSH
47742: LD_VAR 0 57
47746: PUSH
47747: LD_VAR 0 58
47751: PUSH
47752: EMPTY
47753: LIST
47754: LIST
47755: LIST
47756: LIST
47757: LIST
47758: LIST
47759: PUSH
47760: LD_VAR 0 4
47764: PUSH
47765: LD_INT 1
47767: PLUS
47768: ARRAY
47769: ST_TO_ADDR
47770: GO 47879
47772: LD_INT 31
47774: DOUBLE
47775: EQUAL
47776: IFTRUE 47822
47778: LD_INT 32
47780: DOUBLE
47781: EQUAL
47782: IFTRUE 47822
47784: LD_INT 33
47786: DOUBLE
47787: EQUAL
47788: IFTRUE 47822
47790: LD_INT 27
47792: DOUBLE
47793: EQUAL
47794: IFTRUE 47822
47796: LD_INT 26
47798: DOUBLE
47799: EQUAL
47800: IFTRUE 47822
47802: LD_INT 28
47804: DOUBLE
47805: EQUAL
47806: IFTRUE 47822
47808: LD_INT 29
47810: DOUBLE
47811: EQUAL
47812: IFTRUE 47822
47814: LD_INT 30
47816: DOUBLE
47817: EQUAL
47818: IFTRUE 47822
47820: GO 47878
47822: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
47823: LD_ADDR_VAR 0 9
47827: PUSH
47828: LD_VAR 0 59
47832: PUSH
47833: LD_VAR 0 60
47837: PUSH
47838: LD_VAR 0 61
47842: PUSH
47843: LD_VAR 0 62
47847: PUSH
47848: LD_VAR 0 63
47852: PUSH
47853: LD_VAR 0 64
47857: PUSH
47858: EMPTY
47859: LIST
47860: LIST
47861: LIST
47862: LIST
47863: LIST
47864: LIST
47865: PUSH
47866: LD_VAR 0 4
47870: PUSH
47871: LD_INT 1
47873: PLUS
47874: ARRAY
47875: ST_TO_ADDR
47876: GO 47879
47878: POP
// temp_list2 = [ ] ;
47879: LD_ADDR_VAR 0 10
47883: PUSH
47884: EMPTY
47885: ST_TO_ADDR
// for i in temp_list do
47886: LD_ADDR_VAR 0 8
47890: PUSH
47891: LD_VAR 0 9
47895: PUSH
47896: FOR_IN
47897: IFFALSE 47949
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
47899: LD_ADDR_VAR 0 10
47903: PUSH
47904: LD_VAR 0 10
47908: PUSH
47909: LD_VAR 0 8
47913: PUSH
47914: LD_INT 1
47916: ARRAY
47917: PUSH
47918: LD_VAR 0 2
47922: PLUS
47923: PUSH
47924: LD_VAR 0 8
47928: PUSH
47929: LD_INT 2
47931: ARRAY
47932: PUSH
47933: LD_VAR 0 3
47937: PLUS
47938: PUSH
47939: EMPTY
47940: LIST
47941: LIST
47942: PUSH
47943: EMPTY
47944: LIST
47945: ADD
47946: ST_TO_ADDR
47947: GO 47896
47949: POP
47950: POP
// result = temp_list2 ;
47951: LD_ADDR_VAR 0 7
47955: PUSH
47956: LD_VAR 0 10
47960: ST_TO_ADDR
// end ;
47961: LD_VAR 0 7
47965: RET
// export function EnemyInRange ( unit , dist ) ; begin
47966: LD_INT 0
47968: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
47969: LD_ADDR_VAR 0 3
47973: PUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: CALL_OW 255
47983: PPUSH
47984: LD_VAR 0 1
47988: PPUSH
47989: CALL_OW 250
47993: PPUSH
47994: LD_VAR 0 1
47998: PPUSH
47999: CALL_OW 251
48003: PPUSH
48004: LD_VAR 0 2
48008: PPUSH
48009: CALL 21359 0 4
48013: PUSH
48014: LD_INT 4
48016: ARRAY
48017: ST_TO_ADDR
// end ;
48018: LD_VAR 0 3
48022: RET
// export function PlayerSeeMe ( unit ) ; begin
48023: LD_INT 0
48025: PPUSH
// result := See ( your_side , unit ) ;
48026: LD_ADDR_VAR 0 2
48030: PUSH
48031: LD_OWVAR 2
48035: PPUSH
48036: LD_VAR 0 1
48040: PPUSH
48041: CALL_OW 292
48045: ST_TO_ADDR
// end ;
48046: LD_VAR 0 2
48050: RET
// export function ReverseDir ( unit ) ; begin
48051: LD_INT 0
48053: PPUSH
// if not unit then
48054: LD_VAR 0 1
48058: NOT
48059: IFFALSE 48063
// exit ;
48061: GO 48086
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
48063: LD_ADDR_VAR 0 2
48067: PUSH
48068: LD_VAR 0 1
48072: PPUSH
48073: CALL_OW 254
48077: PUSH
48078: LD_INT 3
48080: PLUS
48081: PUSH
48082: LD_INT 6
48084: MOD
48085: ST_TO_ADDR
// end ;
48086: LD_VAR 0 2
48090: RET
// export function ReverseArray ( array ) ; var i ; begin
48091: LD_INT 0
48093: PPUSH
48094: PPUSH
// if not array then
48095: LD_VAR 0 1
48099: NOT
48100: IFFALSE 48104
// exit ;
48102: GO 48159
// result := [ ] ;
48104: LD_ADDR_VAR 0 2
48108: PUSH
48109: EMPTY
48110: ST_TO_ADDR
// for i := array downto 1 do
48111: LD_ADDR_VAR 0 3
48115: PUSH
48116: DOUBLE
48117: LD_VAR 0 1
48121: INC
48122: ST_TO_ADDR
48123: LD_INT 1
48125: PUSH
48126: FOR_DOWNTO
48127: IFFALSE 48157
// result := Join ( result , array [ i ] ) ;
48129: LD_ADDR_VAR 0 2
48133: PUSH
48134: LD_VAR 0 2
48138: PPUSH
48139: LD_VAR 0 1
48143: PUSH
48144: LD_VAR 0 3
48148: ARRAY
48149: PPUSH
48150: CALL 52802 0 2
48154: ST_TO_ADDR
48155: GO 48126
48157: POP
48158: POP
// end ;
48159: LD_VAR 0 2
48163: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
48164: LD_INT 0
48166: PPUSH
48167: PPUSH
48168: PPUSH
48169: PPUSH
48170: PPUSH
48171: PPUSH
// if not unit or not hexes then
48172: LD_VAR 0 1
48176: NOT
48177: PUSH
48178: LD_VAR 0 2
48182: NOT
48183: OR
48184: IFFALSE 48188
// exit ;
48186: GO 48311
// dist := 9999 ;
48188: LD_ADDR_VAR 0 5
48192: PUSH
48193: LD_INT 9999
48195: ST_TO_ADDR
// for i = 1 to hexes do
48196: LD_ADDR_VAR 0 4
48200: PUSH
48201: DOUBLE
48202: LD_INT 1
48204: DEC
48205: ST_TO_ADDR
48206: LD_VAR 0 2
48210: PUSH
48211: FOR_TO
48212: IFFALSE 48299
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48214: LD_ADDR_VAR 0 6
48218: PUSH
48219: LD_VAR 0 1
48223: PPUSH
48224: LD_VAR 0 2
48228: PUSH
48229: LD_VAR 0 4
48233: ARRAY
48234: PUSH
48235: LD_INT 1
48237: ARRAY
48238: PPUSH
48239: LD_VAR 0 2
48243: PUSH
48244: LD_VAR 0 4
48248: ARRAY
48249: PUSH
48250: LD_INT 2
48252: ARRAY
48253: PPUSH
48254: CALL_OW 297
48258: ST_TO_ADDR
// if tdist < dist then
48259: LD_VAR 0 6
48263: PUSH
48264: LD_VAR 0 5
48268: LESS
48269: IFFALSE 48297
// begin hex := hexes [ i ] ;
48271: LD_ADDR_VAR 0 8
48275: PUSH
48276: LD_VAR 0 2
48280: PUSH
48281: LD_VAR 0 4
48285: ARRAY
48286: ST_TO_ADDR
// dist := tdist ;
48287: LD_ADDR_VAR 0 5
48291: PUSH
48292: LD_VAR 0 6
48296: ST_TO_ADDR
// end ; end ;
48297: GO 48211
48299: POP
48300: POP
// result := hex ;
48301: LD_ADDR_VAR 0 3
48305: PUSH
48306: LD_VAR 0 8
48310: ST_TO_ADDR
// end ;
48311: LD_VAR 0 3
48315: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48316: LD_INT 0
48318: PPUSH
48319: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48320: LD_VAR 0 1
48324: NOT
48325: PUSH
48326: LD_VAR 0 1
48330: PUSH
48331: LD_INT 21
48333: PUSH
48334: LD_INT 2
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: PUSH
48341: LD_INT 23
48343: PUSH
48344: LD_INT 2
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: PUSH
48351: EMPTY
48352: LIST
48353: LIST
48354: PPUSH
48355: CALL_OW 69
48359: IN
48360: NOT
48361: OR
48362: IFFALSE 48366
// exit ;
48364: GO 48413
// for i = 1 to 3 do
48366: LD_ADDR_VAR 0 3
48370: PUSH
48371: DOUBLE
48372: LD_INT 1
48374: DEC
48375: ST_TO_ADDR
48376: LD_INT 3
48378: PUSH
48379: FOR_TO
48380: IFFALSE 48411
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48382: LD_VAR 0 1
48386: PPUSH
48387: CALL_OW 250
48391: PPUSH
48392: LD_VAR 0 1
48396: PPUSH
48397: CALL_OW 251
48401: PPUSH
48402: LD_INT 1
48404: PPUSH
48405: CALL_OW 453
48409: GO 48379
48411: POP
48412: POP
// end ;
48413: LD_VAR 0 2
48417: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48418: LD_INT 0
48420: PPUSH
48421: PPUSH
48422: PPUSH
48423: PPUSH
48424: PPUSH
48425: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48426: LD_VAR 0 1
48430: NOT
48431: PUSH
48432: LD_VAR 0 2
48436: NOT
48437: OR
48438: PUSH
48439: LD_VAR 0 1
48443: PPUSH
48444: CALL_OW 314
48448: OR
48449: IFFALSE 48453
// exit ;
48451: GO 48920
// if GetLives ( i ) < 250 then
48453: LD_VAR 0 4
48457: PPUSH
48458: CALL_OW 256
48462: PUSH
48463: LD_INT 250
48465: LESS
48466: IFFALSE 48479
// begin ComAutodestruct ( i ) ;
48468: LD_VAR 0 4
48472: PPUSH
48473: CALL 48316 0 1
// exit ;
48477: GO 48920
// end ; x := GetX ( enemy_unit ) ;
48479: LD_ADDR_VAR 0 7
48483: PUSH
48484: LD_VAR 0 2
48488: PPUSH
48489: CALL_OW 250
48493: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48494: LD_ADDR_VAR 0 8
48498: PUSH
48499: LD_VAR 0 2
48503: PPUSH
48504: CALL_OW 251
48508: ST_TO_ADDR
// if not x or not y then
48509: LD_VAR 0 7
48513: NOT
48514: PUSH
48515: LD_VAR 0 8
48519: NOT
48520: OR
48521: IFFALSE 48525
// exit ;
48523: GO 48920
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48525: LD_ADDR_VAR 0 6
48529: PUSH
48530: LD_VAR 0 7
48534: PPUSH
48535: LD_INT 0
48537: PPUSH
48538: LD_INT 4
48540: PPUSH
48541: CALL_OW 272
48545: PUSH
48546: LD_VAR 0 8
48550: PPUSH
48551: LD_INT 0
48553: PPUSH
48554: LD_INT 4
48556: PPUSH
48557: CALL_OW 273
48561: PUSH
48562: EMPTY
48563: LIST
48564: LIST
48565: PUSH
48566: LD_VAR 0 7
48570: PPUSH
48571: LD_INT 1
48573: PPUSH
48574: LD_INT 4
48576: PPUSH
48577: CALL_OW 272
48581: PUSH
48582: LD_VAR 0 8
48586: PPUSH
48587: LD_INT 1
48589: PPUSH
48590: LD_INT 4
48592: PPUSH
48593: CALL_OW 273
48597: PUSH
48598: EMPTY
48599: LIST
48600: LIST
48601: PUSH
48602: LD_VAR 0 7
48606: PPUSH
48607: LD_INT 2
48609: PPUSH
48610: LD_INT 4
48612: PPUSH
48613: CALL_OW 272
48617: PUSH
48618: LD_VAR 0 8
48622: PPUSH
48623: LD_INT 2
48625: PPUSH
48626: LD_INT 4
48628: PPUSH
48629: CALL_OW 273
48633: PUSH
48634: EMPTY
48635: LIST
48636: LIST
48637: PUSH
48638: LD_VAR 0 7
48642: PPUSH
48643: LD_INT 3
48645: PPUSH
48646: LD_INT 4
48648: PPUSH
48649: CALL_OW 272
48653: PUSH
48654: LD_VAR 0 8
48658: PPUSH
48659: LD_INT 3
48661: PPUSH
48662: LD_INT 4
48664: PPUSH
48665: CALL_OW 273
48669: PUSH
48670: EMPTY
48671: LIST
48672: LIST
48673: PUSH
48674: LD_VAR 0 7
48678: PPUSH
48679: LD_INT 4
48681: PPUSH
48682: LD_INT 4
48684: PPUSH
48685: CALL_OW 272
48689: PUSH
48690: LD_VAR 0 8
48694: PPUSH
48695: LD_INT 4
48697: PPUSH
48698: LD_INT 4
48700: PPUSH
48701: CALL_OW 273
48705: PUSH
48706: EMPTY
48707: LIST
48708: LIST
48709: PUSH
48710: LD_VAR 0 7
48714: PPUSH
48715: LD_INT 5
48717: PPUSH
48718: LD_INT 4
48720: PPUSH
48721: CALL_OW 272
48725: PUSH
48726: LD_VAR 0 8
48730: PPUSH
48731: LD_INT 5
48733: PPUSH
48734: LD_INT 4
48736: PPUSH
48737: CALL_OW 273
48741: PUSH
48742: EMPTY
48743: LIST
48744: LIST
48745: PUSH
48746: EMPTY
48747: LIST
48748: LIST
48749: LIST
48750: LIST
48751: LIST
48752: LIST
48753: ST_TO_ADDR
// for i = tmp downto 1 do
48754: LD_ADDR_VAR 0 4
48758: PUSH
48759: DOUBLE
48760: LD_VAR 0 6
48764: INC
48765: ST_TO_ADDR
48766: LD_INT 1
48768: PUSH
48769: FOR_DOWNTO
48770: IFFALSE 48871
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48772: LD_VAR 0 6
48776: PUSH
48777: LD_VAR 0 4
48781: ARRAY
48782: PUSH
48783: LD_INT 1
48785: ARRAY
48786: PPUSH
48787: LD_VAR 0 6
48791: PUSH
48792: LD_VAR 0 4
48796: ARRAY
48797: PUSH
48798: LD_INT 2
48800: ARRAY
48801: PPUSH
48802: CALL_OW 488
48806: NOT
48807: PUSH
48808: LD_VAR 0 6
48812: PUSH
48813: LD_VAR 0 4
48817: ARRAY
48818: PUSH
48819: LD_INT 1
48821: ARRAY
48822: PPUSH
48823: LD_VAR 0 6
48827: PUSH
48828: LD_VAR 0 4
48832: ARRAY
48833: PUSH
48834: LD_INT 2
48836: ARRAY
48837: PPUSH
48838: CALL_OW 428
48842: PUSH
48843: LD_INT 0
48845: NONEQUAL
48846: OR
48847: IFFALSE 48869
// tmp := Delete ( tmp , i ) ;
48849: LD_ADDR_VAR 0 6
48853: PUSH
48854: LD_VAR 0 6
48858: PPUSH
48859: LD_VAR 0 4
48863: PPUSH
48864: CALL_OW 3
48868: ST_TO_ADDR
48869: GO 48769
48871: POP
48872: POP
// j := GetClosestHex ( unit , tmp ) ;
48873: LD_ADDR_VAR 0 5
48877: PUSH
48878: LD_VAR 0 1
48882: PPUSH
48883: LD_VAR 0 6
48887: PPUSH
48888: CALL 48164 0 2
48892: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48893: LD_VAR 0 1
48897: PPUSH
48898: LD_VAR 0 5
48902: PUSH
48903: LD_INT 1
48905: ARRAY
48906: PPUSH
48907: LD_VAR 0 5
48911: PUSH
48912: LD_INT 2
48914: ARRAY
48915: PPUSH
48916: CALL_OW 111
// end ;
48920: LD_VAR 0 3
48924: RET
// export function PrepareApemanSoldier ( ) ; begin
48925: LD_INT 0
48927: PPUSH
// uc_nation := 0 ;
48928: LD_ADDR_OWVAR 21
48932: PUSH
48933: LD_INT 0
48935: ST_TO_ADDR
// hc_sex := sex_male ;
48936: LD_ADDR_OWVAR 27
48940: PUSH
48941: LD_INT 1
48943: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
48944: LD_ADDR_OWVAR 28
48948: PUSH
48949: LD_INT 15
48951: ST_TO_ADDR
// hc_gallery :=  ;
48952: LD_ADDR_OWVAR 33
48956: PUSH
48957: LD_STRING 
48959: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
48960: LD_ADDR_OWVAR 31
48964: PUSH
48965: LD_INT 0
48967: PPUSH
48968: LD_INT 3
48970: PPUSH
48971: CALL_OW 12
48975: PUSH
48976: LD_INT 0
48978: PPUSH
48979: LD_INT 3
48981: PPUSH
48982: CALL_OW 12
48986: PUSH
48987: LD_INT 0
48989: PUSH
48990: LD_INT 0
48992: PUSH
48993: EMPTY
48994: LIST
48995: LIST
48996: LIST
48997: LIST
48998: ST_TO_ADDR
// end ;
48999: LD_VAR 0 1
49003: RET
// export function PrepareApemanEngineer ( ) ; begin
49004: LD_INT 0
49006: PPUSH
// uc_nation := 0 ;
49007: LD_ADDR_OWVAR 21
49011: PUSH
49012: LD_INT 0
49014: ST_TO_ADDR
// hc_sex := sex_male ;
49015: LD_ADDR_OWVAR 27
49019: PUSH
49020: LD_INT 1
49022: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
49023: LD_ADDR_OWVAR 28
49027: PUSH
49028: LD_INT 16
49030: ST_TO_ADDR
// hc_gallery :=  ;
49031: LD_ADDR_OWVAR 33
49035: PUSH
49036: LD_STRING 
49038: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49039: LD_ADDR_OWVAR 31
49043: PUSH
49044: LD_INT 0
49046: PPUSH
49047: LD_INT 3
49049: PPUSH
49050: CALL_OW 12
49054: PUSH
49055: LD_INT 0
49057: PPUSH
49058: LD_INT 3
49060: PPUSH
49061: CALL_OW 12
49065: PUSH
49066: LD_INT 0
49068: PUSH
49069: LD_INT 0
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: ST_TO_ADDR
// end ;
49078: LD_VAR 0 1
49082: RET
// export function PrepareApeman ( agressivity ) ; begin
49083: LD_INT 0
49085: PPUSH
// uc_side := 0 ;
49086: LD_ADDR_OWVAR 20
49090: PUSH
49091: LD_INT 0
49093: ST_TO_ADDR
// uc_nation := 0 ;
49094: LD_ADDR_OWVAR 21
49098: PUSH
49099: LD_INT 0
49101: ST_TO_ADDR
// hc_sex := sex_male ;
49102: LD_ADDR_OWVAR 27
49106: PUSH
49107: LD_INT 1
49109: ST_TO_ADDR
// hc_class := class_apeman ;
49110: LD_ADDR_OWVAR 28
49114: PUSH
49115: LD_INT 12
49117: ST_TO_ADDR
// hc_gallery :=  ;
49118: LD_ADDR_OWVAR 33
49122: PUSH
49123: LD_STRING 
49125: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49126: LD_ADDR_OWVAR 35
49130: PUSH
49131: LD_VAR 0 1
49135: NEG
49136: PPUSH
49137: LD_VAR 0 1
49141: PPUSH
49142: CALL_OW 12
49146: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
49147: LD_ADDR_OWVAR 31
49151: PUSH
49152: LD_INT 0
49154: PPUSH
49155: LD_INT 3
49157: PPUSH
49158: CALL_OW 12
49162: PUSH
49163: LD_INT 0
49165: PPUSH
49166: LD_INT 3
49168: PPUSH
49169: CALL_OW 12
49173: PUSH
49174: LD_INT 0
49176: PUSH
49177: LD_INT 0
49179: PUSH
49180: EMPTY
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: ST_TO_ADDR
// end ;
49186: LD_VAR 0 2
49190: RET
// export function PrepareTiger ( agressivity ) ; begin
49191: LD_INT 0
49193: PPUSH
// uc_side := 0 ;
49194: LD_ADDR_OWVAR 20
49198: PUSH
49199: LD_INT 0
49201: ST_TO_ADDR
// uc_nation := 0 ;
49202: LD_ADDR_OWVAR 21
49206: PUSH
49207: LD_INT 0
49209: ST_TO_ADDR
// hc_class := class_tiger ;
49210: LD_ADDR_OWVAR 28
49214: PUSH
49215: LD_INT 14
49217: ST_TO_ADDR
// hc_gallery :=  ;
49218: LD_ADDR_OWVAR 33
49222: PUSH
49223: LD_STRING 
49225: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
49226: LD_ADDR_OWVAR 35
49230: PUSH
49231: LD_VAR 0 1
49235: NEG
49236: PPUSH
49237: LD_VAR 0 1
49241: PPUSH
49242: CALL_OW 12
49246: ST_TO_ADDR
// end ;
49247: LD_VAR 0 2
49251: RET
// export function PrepareEnchidna ( ) ; begin
49252: LD_INT 0
49254: PPUSH
// uc_side := 0 ;
49255: LD_ADDR_OWVAR 20
49259: PUSH
49260: LD_INT 0
49262: ST_TO_ADDR
// uc_nation := 0 ;
49263: LD_ADDR_OWVAR 21
49267: PUSH
49268: LD_INT 0
49270: ST_TO_ADDR
// hc_class := class_baggie ;
49271: LD_ADDR_OWVAR 28
49275: PUSH
49276: LD_INT 13
49278: ST_TO_ADDR
// hc_gallery :=  ;
49279: LD_ADDR_OWVAR 33
49283: PUSH
49284: LD_STRING 
49286: ST_TO_ADDR
// end ;
49287: LD_VAR 0 1
49291: RET
// export function PrepareFrog ( ) ; begin
49292: LD_INT 0
49294: PPUSH
// uc_side := 0 ;
49295: LD_ADDR_OWVAR 20
49299: PUSH
49300: LD_INT 0
49302: ST_TO_ADDR
// uc_nation := 0 ;
49303: LD_ADDR_OWVAR 21
49307: PUSH
49308: LD_INT 0
49310: ST_TO_ADDR
// hc_class := class_frog ;
49311: LD_ADDR_OWVAR 28
49315: PUSH
49316: LD_INT 19
49318: ST_TO_ADDR
// hc_gallery :=  ;
49319: LD_ADDR_OWVAR 33
49323: PUSH
49324: LD_STRING 
49326: ST_TO_ADDR
// end ;
49327: LD_VAR 0 1
49331: RET
// export function PrepareFish ( ) ; begin
49332: LD_INT 0
49334: PPUSH
// uc_side := 0 ;
49335: LD_ADDR_OWVAR 20
49339: PUSH
49340: LD_INT 0
49342: ST_TO_ADDR
// uc_nation := 0 ;
49343: LD_ADDR_OWVAR 21
49347: PUSH
49348: LD_INT 0
49350: ST_TO_ADDR
// hc_class := class_fish ;
49351: LD_ADDR_OWVAR 28
49355: PUSH
49356: LD_INT 20
49358: ST_TO_ADDR
// hc_gallery :=  ;
49359: LD_ADDR_OWVAR 33
49363: PUSH
49364: LD_STRING 
49366: ST_TO_ADDR
// end ;
49367: LD_VAR 0 1
49371: RET
// export function PrepareBird ( ) ; begin
49372: LD_INT 0
49374: PPUSH
// uc_side := 0 ;
49375: LD_ADDR_OWVAR 20
49379: PUSH
49380: LD_INT 0
49382: ST_TO_ADDR
// uc_nation := 0 ;
49383: LD_ADDR_OWVAR 21
49387: PUSH
49388: LD_INT 0
49390: ST_TO_ADDR
// hc_class := class_phororhacos ;
49391: LD_ADDR_OWVAR 28
49395: PUSH
49396: LD_INT 18
49398: ST_TO_ADDR
// hc_gallery :=  ;
49399: LD_ADDR_OWVAR 33
49403: PUSH
49404: LD_STRING 
49406: ST_TO_ADDR
// end ;
49407: LD_VAR 0 1
49411: RET
// export function PrepareHorse ( ) ; begin
49412: LD_INT 0
49414: PPUSH
// uc_side := 0 ;
49415: LD_ADDR_OWVAR 20
49419: PUSH
49420: LD_INT 0
49422: ST_TO_ADDR
// uc_nation := 0 ;
49423: LD_ADDR_OWVAR 21
49427: PUSH
49428: LD_INT 0
49430: ST_TO_ADDR
// hc_class := class_horse ;
49431: LD_ADDR_OWVAR 28
49435: PUSH
49436: LD_INT 21
49438: ST_TO_ADDR
// hc_gallery :=  ;
49439: LD_ADDR_OWVAR 33
49443: PUSH
49444: LD_STRING 
49446: ST_TO_ADDR
// end ;
49447: LD_VAR 0 1
49451: RET
// export function PrepareMastodont ( ) ; begin
49452: LD_INT 0
49454: PPUSH
// uc_side := 0 ;
49455: LD_ADDR_OWVAR 20
49459: PUSH
49460: LD_INT 0
49462: ST_TO_ADDR
// uc_nation := 0 ;
49463: LD_ADDR_OWVAR 21
49467: PUSH
49468: LD_INT 0
49470: ST_TO_ADDR
// vc_chassis := class_mastodont ;
49471: LD_ADDR_OWVAR 37
49475: PUSH
49476: LD_INT 31
49478: ST_TO_ADDR
// vc_control := control_rider ;
49479: LD_ADDR_OWVAR 38
49483: PUSH
49484: LD_INT 4
49486: ST_TO_ADDR
// end ;
49487: LD_VAR 0 1
49491: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
49492: LD_INT 0
49494: PPUSH
49495: PPUSH
49496: PPUSH
// uc_side = 0 ;
49497: LD_ADDR_OWVAR 20
49501: PUSH
49502: LD_INT 0
49504: ST_TO_ADDR
// uc_nation = 0 ;
49505: LD_ADDR_OWVAR 21
49509: PUSH
49510: LD_INT 0
49512: ST_TO_ADDR
// InitHc_All ( ) ;
49513: CALL_OW 584
// InitVc ;
49517: CALL_OW 20
// if mastodonts then
49521: LD_VAR 0 6
49525: IFFALSE 49592
// for i = 1 to mastodonts do
49527: LD_ADDR_VAR 0 11
49531: PUSH
49532: DOUBLE
49533: LD_INT 1
49535: DEC
49536: ST_TO_ADDR
49537: LD_VAR 0 6
49541: PUSH
49542: FOR_TO
49543: IFFALSE 49590
// begin vc_chassis := 31 ;
49545: LD_ADDR_OWVAR 37
49549: PUSH
49550: LD_INT 31
49552: ST_TO_ADDR
// vc_control := control_rider ;
49553: LD_ADDR_OWVAR 38
49557: PUSH
49558: LD_INT 4
49560: ST_TO_ADDR
// animal := CreateVehicle ;
49561: LD_ADDR_VAR 0 12
49565: PUSH
49566: CALL_OW 45
49570: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49571: LD_VAR 0 12
49575: PPUSH
49576: LD_VAR 0 8
49580: PPUSH
49581: LD_INT 0
49583: PPUSH
49584: CALL 51720 0 3
// end ;
49588: GO 49542
49590: POP
49591: POP
// if horses then
49592: LD_VAR 0 5
49596: IFFALSE 49663
// for i = 1 to horses do
49598: LD_ADDR_VAR 0 11
49602: PUSH
49603: DOUBLE
49604: LD_INT 1
49606: DEC
49607: ST_TO_ADDR
49608: LD_VAR 0 5
49612: PUSH
49613: FOR_TO
49614: IFFALSE 49661
// begin hc_class := 21 ;
49616: LD_ADDR_OWVAR 28
49620: PUSH
49621: LD_INT 21
49623: ST_TO_ADDR
// hc_gallery :=  ;
49624: LD_ADDR_OWVAR 33
49628: PUSH
49629: LD_STRING 
49631: ST_TO_ADDR
// animal := CreateHuman ;
49632: LD_ADDR_VAR 0 12
49636: PUSH
49637: CALL_OW 44
49641: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49642: LD_VAR 0 12
49646: PPUSH
49647: LD_VAR 0 8
49651: PPUSH
49652: LD_INT 0
49654: PPUSH
49655: CALL 51720 0 3
// end ;
49659: GO 49613
49661: POP
49662: POP
// if birds then
49663: LD_VAR 0 1
49667: IFFALSE 49734
// for i = 1 to birds do
49669: LD_ADDR_VAR 0 11
49673: PUSH
49674: DOUBLE
49675: LD_INT 1
49677: DEC
49678: ST_TO_ADDR
49679: LD_VAR 0 1
49683: PUSH
49684: FOR_TO
49685: IFFALSE 49732
// begin hc_class := 18 ;
49687: LD_ADDR_OWVAR 28
49691: PUSH
49692: LD_INT 18
49694: ST_TO_ADDR
// hc_gallery =  ;
49695: LD_ADDR_OWVAR 33
49699: PUSH
49700: LD_STRING 
49702: ST_TO_ADDR
// animal := CreateHuman ;
49703: LD_ADDR_VAR 0 12
49707: PUSH
49708: CALL_OW 44
49712: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49713: LD_VAR 0 12
49717: PPUSH
49718: LD_VAR 0 8
49722: PPUSH
49723: LD_INT 0
49725: PPUSH
49726: CALL 51720 0 3
// end ;
49730: GO 49684
49732: POP
49733: POP
// if tigers then
49734: LD_VAR 0 2
49738: IFFALSE 49822
// for i = 1 to tigers do
49740: LD_ADDR_VAR 0 11
49744: PUSH
49745: DOUBLE
49746: LD_INT 1
49748: DEC
49749: ST_TO_ADDR
49750: LD_VAR 0 2
49754: PUSH
49755: FOR_TO
49756: IFFALSE 49820
// begin hc_class = class_tiger ;
49758: LD_ADDR_OWVAR 28
49762: PUSH
49763: LD_INT 14
49765: ST_TO_ADDR
// hc_gallery =  ;
49766: LD_ADDR_OWVAR 33
49770: PUSH
49771: LD_STRING 
49773: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49774: LD_ADDR_OWVAR 35
49778: PUSH
49779: LD_INT 7
49781: NEG
49782: PPUSH
49783: LD_INT 7
49785: PPUSH
49786: CALL_OW 12
49790: ST_TO_ADDR
// animal := CreateHuman ;
49791: LD_ADDR_VAR 0 12
49795: PUSH
49796: CALL_OW 44
49800: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49801: LD_VAR 0 12
49805: PPUSH
49806: LD_VAR 0 8
49810: PPUSH
49811: LD_INT 0
49813: PPUSH
49814: CALL 51720 0 3
// end ;
49818: GO 49755
49820: POP
49821: POP
// if apemans then
49822: LD_VAR 0 3
49826: IFFALSE 49949
// for i = 1 to apemans do
49828: LD_ADDR_VAR 0 11
49832: PUSH
49833: DOUBLE
49834: LD_INT 1
49836: DEC
49837: ST_TO_ADDR
49838: LD_VAR 0 3
49842: PUSH
49843: FOR_TO
49844: IFFALSE 49947
// begin hc_class = class_apeman ;
49846: LD_ADDR_OWVAR 28
49850: PUSH
49851: LD_INT 12
49853: ST_TO_ADDR
// hc_gallery =  ;
49854: LD_ADDR_OWVAR 33
49858: PUSH
49859: LD_STRING 
49861: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
49862: LD_ADDR_OWVAR 35
49866: PUSH
49867: LD_INT 2
49869: NEG
49870: PPUSH
49871: LD_INT 2
49873: PPUSH
49874: CALL_OW 12
49878: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49879: LD_ADDR_OWVAR 31
49883: PUSH
49884: LD_INT 1
49886: PPUSH
49887: LD_INT 3
49889: PPUSH
49890: CALL_OW 12
49894: PUSH
49895: LD_INT 1
49897: PPUSH
49898: LD_INT 3
49900: PPUSH
49901: CALL_OW 12
49905: PUSH
49906: LD_INT 0
49908: PUSH
49909: LD_INT 0
49911: PUSH
49912: EMPTY
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: ST_TO_ADDR
// animal := CreateHuman ;
49918: LD_ADDR_VAR 0 12
49922: PUSH
49923: CALL_OW 44
49927: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49928: LD_VAR 0 12
49932: PPUSH
49933: LD_VAR 0 8
49937: PPUSH
49938: LD_INT 0
49940: PPUSH
49941: CALL 51720 0 3
// end ;
49945: GO 49843
49947: POP
49948: POP
// if enchidnas then
49949: LD_VAR 0 4
49953: IFFALSE 50020
// for i = 1 to enchidnas do
49955: LD_ADDR_VAR 0 11
49959: PUSH
49960: DOUBLE
49961: LD_INT 1
49963: DEC
49964: ST_TO_ADDR
49965: LD_VAR 0 4
49969: PUSH
49970: FOR_TO
49971: IFFALSE 50018
// begin hc_class = 13 ;
49973: LD_ADDR_OWVAR 28
49977: PUSH
49978: LD_INT 13
49980: ST_TO_ADDR
// hc_gallery =  ;
49981: LD_ADDR_OWVAR 33
49985: PUSH
49986: LD_STRING 
49988: ST_TO_ADDR
// animal := CreateHuman ;
49989: LD_ADDR_VAR 0 12
49993: PUSH
49994: CALL_OW 44
49998: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49999: LD_VAR 0 12
50003: PPUSH
50004: LD_VAR 0 8
50008: PPUSH
50009: LD_INT 0
50011: PPUSH
50012: CALL 51720 0 3
// end ;
50016: GO 49970
50018: POP
50019: POP
// if fishes then
50020: LD_VAR 0 7
50024: IFFALSE 50091
// for i = 1 to fishes do
50026: LD_ADDR_VAR 0 11
50030: PUSH
50031: DOUBLE
50032: LD_INT 1
50034: DEC
50035: ST_TO_ADDR
50036: LD_VAR 0 7
50040: PUSH
50041: FOR_TO
50042: IFFALSE 50089
// begin hc_class = 20 ;
50044: LD_ADDR_OWVAR 28
50048: PUSH
50049: LD_INT 20
50051: ST_TO_ADDR
// hc_gallery =  ;
50052: LD_ADDR_OWVAR 33
50056: PUSH
50057: LD_STRING 
50059: ST_TO_ADDR
// animal := CreateHuman ;
50060: LD_ADDR_VAR 0 12
50064: PUSH
50065: CALL_OW 44
50069: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
50070: LD_VAR 0 12
50074: PPUSH
50075: LD_VAR 0 9
50079: PPUSH
50080: LD_INT 0
50082: PPUSH
50083: CALL 51720 0 3
// end ;
50087: GO 50041
50089: POP
50090: POP
// end ;
50091: LD_VAR 0 10
50095: RET
// export function WantHeal ( sci , unit ) ; begin
50096: LD_INT 0
50098: PPUSH
// if GetTaskList ( sci ) > 0 then
50099: LD_VAR 0 1
50103: PPUSH
50104: CALL_OW 437
50108: PUSH
50109: LD_INT 0
50111: GREATER
50112: IFFALSE 50182
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
50114: LD_VAR 0 1
50118: PPUSH
50119: CALL_OW 437
50123: PUSH
50124: LD_INT 1
50126: ARRAY
50127: PUSH
50128: LD_INT 1
50130: ARRAY
50131: PUSH
50132: LD_STRING l
50134: EQUAL
50135: PUSH
50136: LD_VAR 0 1
50140: PPUSH
50141: CALL_OW 437
50145: PUSH
50146: LD_INT 1
50148: ARRAY
50149: PUSH
50150: LD_INT 4
50152: ARRAY
50153: PUSH
50154: LD_VAR 0 2
50158: EQUAL
50159: AND
50160: IFFALSE 50172
// result := true else
50162: LD_ADDR_VAR 0 3
50166: PUSH
50167: LD_INT 1
50169: ST_TO_ADDR
50170: GO 50180
// result := false ;
50172: LD_ADDR_VAR 0 3
50176: PUSH
50177: LD_INT 0
50179: ST_TO_ADDR
// end else
50180: GO 50190
// result := false ;
50182: LD_ADDR_VAR 0 3
50186: PUSH
50187: LD_INT 0
50189: ST_TO_ADDR
// end ;
50190: LD_VAR 0 3
50194: RET
// export function HealTarget ( sci ) ; begin
50195: LD_INT 0
50197: PPUSH
// if not sci then
50198: LD_VAR 0 1
50202: NOT
50203: IFFALSE 50207
// exit ;
50205: GO 50272
// result := 0 ;
50207: LD_ADDR_VAR 0 2
50211: PUSH
50212: LD_INT 0
50214: ST_TO_ADDR
// if GetTaskList ( sci ) then
50215: LD_VAR 0 1
50219: PPUSH
50220: CALL_OW 437
50224: IFFALSE 50272
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
50226: LD_VAR 0 1
50230: PPUSH
50231: CALL_OW 437
50235: PUSH
50236: LD_INT 1
50238: ARRAY
50239: PUSH
50240: LD_INT 1
50242: ARRAY
50243: PUSH
50244: LD_STRING l
50246: EQUAL
50247: IFFALSE 50272
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
50249: LD_ADDR_VAR 0 2
50253: PUSH
50254: LD_VAR 0 1
50258: PPUSH
50259: CALL_OW 437
50263: PUSH
50264: LD_INT 1
50266: ARRAY
50267: PUSH
50268: LD_INT 4
50270: ARRAY
50271: ST_TO_ADDR
// end ;
50272: LD_VAR 0 2
50276: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
50277: LD_INT 0
50279: PPUSH
50280: PPUSH
50281: PPUSH
50282: PPUSH
// if not base_units then
50283: LD_VAR 0 1
50287: NOT
50288: IFFALSE 50292
// exit ;
50290: GO 50379
// result := false ;
50292: LD_ADDR_VAR 0 2
50296: PUSH
50297: LD_INT 0
50299: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
50300: LD_ADDR_VAR 0 5
50304: PUSH
50305: LD_VAR 0 1
50309: PPUSH
50310: LD_INT 21
50312: PUSH
50313: LD_INT 3
50315: PUSH
50316: EMPTY
50317: LIST
50318: LIST
50319: PPUSH
50320: CALL_OW 72
50324: ST_TO_ADDR
// if not tmp then
50325: LD_VAR 0 5
50329: NOT
50330: IFFALSE 50334
// exit ;
50332: GO 50379
// for i in tmp do
50334: LD_ADDR_VAR 0 3
50338: PUSH
50339: LD_VAR 0 5
50343: PUSH
50344: FOR_IN
50345: IFFALSE 50377
// begin result := EnemyInRange ( i , 22 ) ;
50347: LD_ADDR_VAR 0 2
50351: PUSH
50352: LD_VAR 0 3
50356: PPUSH
50357: LD_INT 22
50359: PPUSH
50360: CALL 47966 0 2
50364: ST_TO_ADDR
// if result then
50365: LD_VAR 0 2
50369: IFFALSE 50375
// exit ;
50371: POP
50372: POP
50373: GO 50379
// end ;
50375: GO 50344
50377: POP
50378: POP
// end ;
50379: LD_VAR 0 2
50383: RET
// export function FilterByTag ( units , tag ) ; begin
50384: LD_INT 0
50386: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
50387: LD_ADDR_VAR 0 3
50391: PUSH
50392: LD_VAR 0 1
50396: PPUSH
50397: LD_INT 120
50399: PUSH
50400: LD_VAR 0 2
50404: PUSH
50405: EMPTY
50406: LIST
50407: LIST
50408: PPUSH
50409: CALL_OW 72
50413: ST_TO_ADDR
// end ;
50414: LD_VAR 0 3
50418: RET
// export function IsDriver ( un ) ; begin
50419: LD_INT 0
50421: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
50422: LD_ADDR_VAR 0 2
50426: PUSH
50427: LD_VAR 0 1
50431: PUSH
50432: LD_INT 55
50434: PUSH
50435: EMPTY
50436: LIST
50437: PPUSH
50438: CALL_OW 69
50442: IN
50443: ST_TO_ADDR
// end ;
50444: LD_VAR 0 2
50448: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
50449: LD_INT 0
50451: PPUSH
50452: PPUSH
// list := [ ] ;
50453: LD_ADDR_VAR 0 5
50457: PUSH
50458: EMPTY
50459: ST_TO_ADDR
// case d of 0 :
50460: LD_VAR 0 3
50464: PUSH
50465: LD_INT 0
50467: DOUBLE
50468: EQUAL
50469: IFTRUE 50473
50471: GO 50606
50473: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
50474: LD_ADDR_VAR 0 5
50478: PUSH
50479: LD_VAR 0 1
50483: PUSH
50484: LD_INT 4
50486: MINUS
50487: PUSH
50488: LD_VAR 0 2
50492: PUSH
50493: LD_INT 4
50495: MINUS
50496: PUSH
50497: LD_INT 2
50499: PUSH
50500: EMPTY
50501: LIST
50502: LIST
50503: LIST
50504: PUSH
50505: LD_VAR 0 1
50509: PUSH
50510: LD_INT 3
50512: MINUS
50513: PUSH
50514: LD_VAR 0 2
50518: PUSH
50519: LD_INT 1
50521: PUSH
50522: EMPTY
50523: LIST
50524: LIST
50525: LIST
50526: PUSH
50527: LD_VAR 0 1
50531: PUSH
50532: LD_INT 4
50534: PLUS
50535: PUSH
50536: LD_VAR 0 2
50540: PUSH
50541: LD_INT 4
50543: PUSH
50544: EMPTY
50545: LIST
50546: LIST
50547: LIST
50548: PUSH
50549: LD_VAR 0 1
50553: PUSH
50554: LD_INT 3
50556: PLUS
50557: PUSH
50558: LD_VAR 0 2
50562: PUSH
50563: LD_INT 3
50565: PLUS
50566: PUSH
50567: LD_INT 5
50569: PUSH
50570: EMPTY
50571: LIST
50572: LIST
50573: LIST
50574: PUSH
50575: LD_VAR 0 1
50579: PUSH
50580: LD_VAR 0 2
50584: PUSH
50585: LD_INT 4
50587: PLUS
50588: PUSH
50589: LD_INT 0
50591: PUSH
50592: EMPTY
50593: LIST
50594: LIST
50595: LIST
50596: PUSH
50597: EMPTY
50598: LIST
50599: LIST
50600: LIST
50601: LIST
50602: LIST
50603: ST_TO_ADDR
// end ; 1 :
50604: GO 51304
50606: LD_INT 1
50608: DOUBLE
50609: EQUAL
50610: IFTRUE 50614
50612: GO 50747
50614: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
50615: LD_ADDR_VAR 0 5
50619: PUSH
50620: LD_VAR 0 1
50624: PUSH
50625: LD_VAR 0 2
50629: PUSH
50630: LD_INT 4
50632: MINUS
50633: PUSH
50634: LD_INT 3
50636: PUSH
50637: EMPTY
50638: LIST
50639: LIST
50640: LIST
50641: PUSH
50642: LD_VAR 0 1
50646: PUSH
50647: LD_INT 3
50649: MINUS
50650: PUSH
50651: LD_VAR 0 2
50655: PUSH
50656: LD_INT 3
50658: MINUS
50659: PUSH
50660: LD_INT 2
50662: PUSH
50663: EMPTY
50664: LIST
50665: LIST
50666: LIST
50667: PUSH
50668: LD_VAR 0 1
50672: PUSH
50673: LD_INT 4
50675: MINUS
50676: PUSH
50677: LD_VAR 0 2
50681: PUSH
50682: LD_INT 1
50684: PUSH
50685: EMPTY
50686: LIST
50687: LIST
50688: LIST
50689: PUSH
50690: LD_VAR 0 1
50694: PUSH
50695: LD_VAR 0 2
50699: PUSH
50700: LD_INT 3
50702: PLUS
50703: PUSH
50704: LD_INT 0
50706: PUSH
50707: EMPTY
50708: LIST
50709: LIST
50710: LIST
50711: PUSH
50712: LD_VAR 0 1
50716: PUSH
50717: LD_INT 4
50719: PLUS
50720: PUSH
50721: LD_VAR 0 2
50725: PUSH
50726: LD_INT 4
50728: PLUS
50729: PUSH
50730: LD_INT 5
50732: PUSH
50733: EMPTY
50734: LIST
50735: LIST
50736: LIST
50737: PUSH
50738: EMPTY
50739: LIST
50740: LIST
50741: LIST
50742: LIST
50743: LIST
50744: ST_TO_ADDR
// end ; 2 :
50745: GO 51304
50747: LD_INT 2
50749: DOUBLE
50750: EQUAL
50751: IFTRUE 50755
50753: GO 50884
50755: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
50756: LD_ADDR_VAR 0 5
50760: PUSH
50761: LD_VAR 0 1
50765: PUSH
50766: LD_VAR 0 2
50770: PUSH
50771: LD_INT 3
50773: MINUS
50774: PUSH
50775: LD_INT 3
50777: PUSH
50778: EMPTY
50779: LIST
50780: LIST
50781: LIST
50782: PUSH
50783: LD_VAR 0 1
50787: PUSH
50788: LD_INT 4
50790: PLUS
50791: PUSH
50792: LD_VAR 0 2
50796: PUSH
50797: LD_INT 4
50799: PUSH
50800: EMPTY
50801: LIST
50802: LIST
50803: LIST
50804: PUSH
50805: LD_VAR 0 1
50809: PUSH
50810: LD_VAR 0 2
50814: PUSH
50815: LD_INT 4
50817: PLUS
50818: PUSH
50819: LD_INT 0
50821: PUSH
50822: EMPTY
50823: LIST
50824: LIST
50825: LIST
50826: PUSH
50827: LD_VAR 0 1
50831: PUSH
50832: LD_INT 3
50834: MINUS
50835: PUSH
50836: LD_VAR 0 2
50840: PUSH
50841: LD_INT 1
50843: PUSH
50844: EMPTY
50845: LIST
50846: LIST
50847: LIST
50848: PUSH
50849: LD_VAR 0 1
50853: PUSH
50854: LD_INT 4
50856: MINUS
50857: PUSH
50858: LD_VAR 0 2
50862: PUSH
50863: LD_INT 4
50865: MINUS
50866: PUSH
50867: LD_INT 2
50869: PUSH
50870: EMPTY
50871: LIST
50872: LIST
50873: LIST
50874: PUSH
50875: EMPTY
50876: LIST
50877: LIST
50878: LIST
50879: LIST
50880: LIST
50881: ST_TO_ADDR
// end ; 3 :
50882: GO 51304
50884: LD_INT 3
50886: DOUBLE
50887: EQUAL
50888: IFTRUE 50892
50890: GO 51025
50892: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
50893: LD_ADDR_VAR 0 5
50897: PUSH
50898: LD_VAR 0 1
50902: PUSH
50903: LD_INT 3
50905: PLUS
50906: PUSH
50907: LD_VAR 0 2
50911: PUSH
50912: LD_INT 4
50914: PUSH
50915: EMPTY
50916: LIST
50917: LIST
50918: LIST
50919: PUSH
50920: LD_VAR 0 1
50924: PUSH
50925: LD_INT 4
50927: PLUS
50928: PUSH
50929: LD_VAR 0 2
50933: PUSH
50934: LD_INT 4
50936: PLUS
50937: PUSH
50938: LD_INT 5
50940: PUSH
50941: EMPTY
50942: LIST
50943: LIST
50944: LIST
50945: PUSH
50946: LD_VAR 0 1
50950: PUSH
50951: LD_INT 4
50953: MINUS
50954: PUSH
50955: LD_VAR 0 2
50959: PUSH
50960: LD_INT 1
50962: PUSH
50963: EMPTY
50964: LIST
50965: LIST
50966: LIST
50967: PUSH
50968: LD_VAR 0 1
50972: PUSH
50973: LD_VAR 0 2
50977: PUSH
50978: LD_INT 4
50980: MINUS
50981: PUSH
50982: LD_INT 3
50984: PUSH
50985: EMPTY
50986: LIST
50987: LIST
50988: LIST
50989: PUSH
50990: LD_VAR 0 1
50994: PUSH
50995: LD_INT 3
50997: MINUS
50998: PUSH
50999: LD_VAR 0 2
51003: PUSH
51004: LD_INT 3
51006: MINUS
51007: PUSH
51008: LD_INT 2
51010: PUSH
51011: EMPTY
51012: LIST
51013: LIST
51014: LIST
51015: PUSH
51016: EMPTY
51017: LIST
51018: LIST
51019: LIST
51020: LIST
51021: LIST
51022: ST_TO_ADDR
// end ; 4 :
51023: GO 51304
51025: LD_INT 4
51027: DOUBLE
51028: EQUAL
51029: IFTRUE 51033
51031: GO 51166
51033: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
51034: LD_ADDR_VAR 0 5
51038: PUSH
51039: LD_VAR 0 1
51043: PUSH
51044: LD_VAR 0 2
51048: PUSH
51049: LD_INT 4
51051: PLUS
51052: PUSH
51053: LD_INT 0
51055: PUSH
51056: EMPTY
51057: LIST
51058: LIST
51059: LIST
51060: PUSH
51061: LD_VAR 0 1
51065: PUSH
51066: LD_INT 3
51068: PLUS
51069: PUSH
51070: LD_VAR 0 2
51074: PUSH
51075: LD_INT 3
51077: PLUS
51078: PUSH
51079: LD_INT 5
51081: PUSH
51082: EMPTY
51083: LIST
51084: LIST
51085: LIST
51086: PUSH
51087: LD_VAR 0 1
51091: PUSH
51092: LD_INT 4
51094: PLUS
51095: PUSH
51096: LD_VAR 0 2
51100: PUSH
51101: LD_INT 4
51103: PUSH
51104: EMPTY
51105: LIST
51106: LIST
51107: LIST
51108: PUSH
51109: LD_VAR 0 1
51113: PUSH
51114: LD_VAR 0 2
51118: PUSH
51119: LD_INT 3
51121: MINUS
51122: PUSH
51123: LD_INT 3
51125: PUSH
51126: EMPTY
51127: LIST
51128: LIST
51129: LIST
51130: PUSH
51131: LD_VAR 0 1
51135: PUSH
51136: LD_INT 4
51138: MINUS
51139: PUSH
51140: LD_VAR 0 2
51144: PUSH
51145: LD_INT 4
51147: MINUS
51148: PUSH
51149: LD_INT 2
51151: PUSH
51152: EMPTY
51153: LIST
51154: LIST
51155: LIST
51156: PUSH
51157: EMPTY
51158: LIST
51159: LIST
51160: LIST
51161: LIST
51162: LIST
51163: ST_TO_ADDR
// end ; 5 :
51164: GO 51304
51166: LD_INT 5
51168: DOUBLE
51169: EQUAL
51170: IFTRUE 51174
51172: GO 51303
51174: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
51175: LD_ADDR_VAR 0 5
51179: PUSH
51180: LD_VAR 0 1
51184: PUSH
51185: LD_INT 4
51187: MINUS
51188: PUSH
51189: LD_VAR 0 2
51193: PUSH
51194: LD_INT 1
51196: PUSH
51197: EMPTY
51198: LIST
51199: LIST
51200: LIST
51201: PUSH
51202: LD_VAR 0 1
51206: PUSH
51207: LD_VAR 0 2
51211: PUSH
51212: LD_INT 4
51214: MINUS
51215: PUSH
51216: LD_INT 3
51218: PUSH
51219: EMPTY
51220: LIST
51221: LIST
51222: LIST
51223: PUSH
51224: LD_VAR 0 1
51228: PUSH
51229: LD_INT 4
51231: PLUS
51232: PUSH
51233: LD_VAR 0 2
51237: PUSH
51238: LD_INT 4
51240: PLUS
51241: PUSH
51242: LD_INT 5
51244: PUSH
51245: EMPTY
51246: LIST
51247: LIST
51248: LIST
51249: PUSH
51250: LD_VAR 0 1
51254: PUSH
51255: LD_INT 3
51257: PLUS
51258: PUSH
51259: LD_VAR 0 2
51263: PUSH
51264: LD_INT 4
51266: PUSH
51267: EMPTY
51268: LIST
51269: LIST
51270: LIST
51271: PUSH
51272: LD_VAR 0 1
51276: PUSH
51277: LD_VAR 0 2
51281: PUSH
51282: LD_INT 3
51284: PLUS
51285: PUSH
51286: LD_INT 0
51288: PUSH
51289: EMPTY
51290: LIST
51291: LIST
51292: LIST
51293: PUSH
51294: EMPTY
51295: LIST
51296: LIST
51297: LIST
51298: LIST
51299: LIST
51300: ST_TO_ADDR
// end ; end ;
51301: GO 51304
51303: POP
// result := list ;
51304: LD_ADDR_VAR 0 4
51308: PUSH
51309: LD_VAR 0 5
51313: ST_TO_ADDR
// end ;
51314: LD_VAR 0 4
51318: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
51319: LD_INT 0
51321: PPUSH
51322: PPUSH
51323: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
51324: LD_VAR 0 1
51328: NOT
51329: PUSH
51330: LD_VAR 0 2
51334: PUSH
51335: LD_INT 1
51337: PUSH
51338: LD_INT 2
51340: PUSH
51341: LD_INT 3
51343: PUSH
51344: LD_INT 4
51346: PUSH
51347: EMPTY
51348: LIST
51349: LIST
51350: LIST
51351: LIST
51352: IN
51353: NOT
51354: OR
51355: IFFALSE 51359
// exit ;
51357: GO 51442
// tmp := [ ] ;
51359: LD_ADDR_VAR 0 5
51363: PUSH
51364: EMPTY
51365: ST_TO_ADDR
// for i in units do
51366: LD_ADDR_VAR 0 4
51370: PUSH
51371: LD_VAR 0 1
51375: PUSH
51376: FOR_IN
51377: IFFALSE 51411
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
51379: LD_ADDR_VAR 0 5
51383: PUSH
51384: LD_VAR 0 5
51388: PPUSH
51389: LD_VAR 0 4
51393: PPUSH
51394: LD_VAR 0 2
51398: PPUSH
51399: CALL_OW 259
51403: PPUSH
51404: CALL 52802 0 2
51408: ST_TO_ADDR
51409: GO 51376
51411: POP
51412: POP
// if not tmp then
51413: LD_VAR 0 5
51417: NOT
51418: IFFALSE 51422
// exit ;
51420: GO 51442
// result := SortListByListDesc ( units , tmp ) ;
51422: LD_ADDR_VAR 0 3
51426: PUSH
51427: LD_VAR 0 1
51431: PPUSH
51432: LD_VAR 0 5
51436: PPUSH
51437: CALL_OW 77
51441: ST_TO_ADDR
// end ;
51442: LD_VAR 0 3
51446: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
51447: LD_INT 0
51449: PPUSH
51450: PPUSH
51451: PPUSH
// result := false ;
51452: LD_ADDR_VAR 0 3
51456: PUSH
51457: LD_INT 0
51459: ST_TO_ADDR
// if not building then
51460: LD_VAR 0 2
51464: NOT
51465: IFFALSE 51469
// exit ;
51467: GO 51607
// x := GetX ( building ) ;
51469: LD_ADDR_VAR 0 4
51473: PUSH
51474: LD_VAR 0 2
51478: PPUSH
51479: CALL_OW 250
51483: ST_TO_ADDR
// y := GetY ( building ) ;
51484: LD_ADDR_VAR 0 5
51488: PUSH
51489: LD_VAR 0 2
51493: PPUSH
51494: CALL_OW 251
51498: ST_TO_ADDR
// if not x or not y then
51499: LD_VAR 0 4
51503: NOT
51504: PUSH
51505: LD_VAR 0 5
51509: NOT
51510: OR
51511: IFFALSE 51515
// exit ;
51513: GO 51607
// if GetTaskList ( unit ) then
51515: LD_VAR 0 1
51519: PPUSH
51520: CALL_OW 437
51524: IFFALSE 51607
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51526: LD_STRING e
51528: PUSH
51529: LD_VAR 0 1
51533: PPUSH
51534: CALL_OW 437
51538: PUSH
51539: LD_INT 1
51541: ARRAY
51542: PUSH
51543: LD_INT 1
51545: ARRAY
51546: EQUAL
51547: PUSH
51548: LD_VAR 0 4
51552: PUSH
51553: LD_VAR 0 1
51557: PPUSH
51558: CALL_OW 437
51562: PUSH
51563: LD_INT 1
51565: ARRAY
51566: PUSH
51567: LD_INT 2
51569: ARRAY
51570: EQUAL
51571: AND
51572: PUSH
51573: LD_VAR 0 5
51577: PUSH
51578: LD_VAR 0 1
51582: PPUSH
51583: CALL_OW 437
51587: PUSH
51588: LD_INT 1
51590: ARRAY
51591: PUSH
51592: LD_INT 3
51594: ARRAY
51595: EQUAL
51596: AND
51597: IFFALSE 51607
// result := true end ;
51599: LD_ADDR_VAR 0 3
51603: PUSH
51604: LD_INT 1
51606: ST_TO_ADDR
// end ;
51607: LD_VAR 0 3
51611: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
51612: LD_INT 0
51614: PPUSH
// result := false ;
51615: LD_ADDR_VAR 0 4
51619: PUSH
51620: LD_INT 0
51622: ST_TO_ADDR
// if GetTaskList ( unit ) then
51623: LD_VAR 0 1
51627: PPUSH
51628: CALL_OW 437
51632: IFFALSE 51715
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
51634: LD_STRING M
51636: PUSH
51637: LD_VAR 0 1
51641: PPUSH
51642: CALL_OW 437
51646: PUSH
51647: LD_INT 1
51649: ARRAY
51650: PUSH
51651: LD_INT 1
51653: ARRAY
51654: EQUAL
51655: PUSH
51656: LD_VAR 0 2
51660: PUSH
51661: LD_VAR 0 1
51665: PPUSH
51666: CALL_OW 437
51670: PUSH
51671: LD_INT 1
51673: ARRAY
51674: PUSH
51675: LD_INT 2
51677: ARRAY
51678: EQUAL
51679: AND
51680: PUSH
51681: LD_VAR 0 3
51685: PUSH
51686: LD_VAR 0 1
51690: PPUSH
51691: CALL_OW 437
51695: PUSH
51696: LD_INT 1
51698: ARRAY
51699: PUSH
51700: LD_INT 3
51702: ARRAY
51703: EQUAL
51704: AND
51705: IFFALSE 51715
// result := true ;
51707: LD_ADDR_VAR 0 4
51711: PUSH
51712: LD_INT 1
51714: ST_TO_ADDR
// end ; end ;
51715: LD_VAR 0 4
51719: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
51720: LD_INT 0
51722: PPUSH
51723: PPUSH
51724: PPUSH
51725: PPUSH
// if not unit or not area then
51726: LD_VAR 0 1
51730: NOT
51731: PUSH
51732: LD_VAR 0 2
51736: NOT
51737: OR
51738: IFFALSE 51742
// exit ;
51740: GO 51905
// tmp := AreaToList ( area , i ) ;
51742: LD_ADDR_VAR 0 6
51746: PUSH
51747: LD_VAR 0 2
51751: PPUSH
51752: LD_VAR 0 5
51756: PPUSH
51757: CALL_OW 517
51761: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
51762: LD_ADDR_VAR 0 5
51766: PUSH
51767: DOUBLE
51768: LD_INT 1
51770: DEC
51771: ST_TO_ADDR
51772: LD_VAR 0 6
51776: PUSH
51777: LD_INT 1
51779: ARRAY
51780: PUSH
51781: FOR_TO
51782: IFFALSE 51903
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
51784: LD_ADDR_VAR 0 7
51788: PUSH
51789: LD_VAR 0 6
51793: PUSH
51794: LD_INT 1
51796: ARRAY
51797: PUSH
51798: LD_VAR 0 5
51802: ARRAY
51803: PUSH
51804: LD_VAR 0 6
51808: PUSH
51809: LD_INT 2
51811: ARRAY
51812: PUSH
51813: LD_VAR 0 5
51817: ARRAY
51818: PUSH
51819: EMPTY
51820: LIST
51821: LIST
51822: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
51823: LD_INT 92
51825: PUSH
51826: LD_VAR 0 7
51830: PUSH
51831: LD_INT 1
51833: ARRAY
51834: PUSH
51835: LD_VAR 0 7
51839: PUSH
51840: LD_INT 2
51842: ARRAY
51843: PUSH
51844: LD_INT 3
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: LIST
51851: LIST
51852: PPUSH
51853: CALL_OW 69
51857: PUSH
51858: LD_INT 0
51860: EQUAL
51861: IFFALSE 51901
// begin PlaceUnitArea ( unit , area , mode ) ;
51863: LD_VAR 0 1
51867: PPUSH
51868: LD_VAR 0 2
51872: PPUSH
51873: LD_VAR 0 3
51877: PPUSH
51878: CALL_OW 49
// result := IsPlaced ( unit ) ;
51882: LD_ADDR_VAR 0 4
51886: PUSH
51887: LD_VAR 0 1
51891: PPUSH
51892: CALL_OW 305
51896: ST_TO_ADDR
// exit ;
51897: POP
51898: POP
51899: GO 51905
// end ; end ;
51901: GO 51781
51903: POP
51904: POP
// end ;
51905: LD_VAR 0 4
51909: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
51910: LD_INT 0
51912: PPUSH
51913: PPUSH
51914: PPUSH
// if not side or side > 8 then
51915: LD_VAR 0 1
51919: NOT
51920: PUSH
51921: LD_VAR 0 1
51925: PUSH
51926: LD_INT 8
51928: GREATER
51929: OR
51930: IFFALSE 51934
// exit ;
51932: GO 52121
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
51934: LD_ADDR_VAR 0 4
51938: PUSH
51939: LD_INT 22
51941: PUSH
51942: LD_VAR 0 1
51946: PUSH
51947: EMPTY
51948: LIST
51949: LIST
51950: PUSH
51951: LD_INT 21
51953: PUSH
51954: LD_INT 3
51956: PUSH
51957: EMPTY
51958: LIST
51959: LIST
51960: PUSH
51961: EMPTY
51962: LIST
51963: LIST
51964: PPUSH
51965: CALL_OW 69
51969: ST_TO_ADDR
// if not tmp then
51970: LD_VAR 0 4
51974: NOT
51975: IFFALSE 51979
// exit ;
51977: GO 52121
// enable_addtolog := true ;
51979: LD_ADDR_OWVAR 81
51983: PUSH
51984: LD_INT 1
51986: ST_TO_ADDR
// AddToLog ( [ ) ;
51987: LD_STRING [
51989: PPUSH
51990: CALL_OW 561
// for i in tmp do
51994: LD_ADDR_VAR 0 3
51998: PUSH
51999: LD_VAR 0 4
52003: PUSH
52004: FOR_IN
52005: IFFALSE 52112
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
52007: LD_STRING [
52009: PUSH
52010: LD_VAR 0 3
52014: PPUSH
52015: CALL_OW 266
52019: STR
52020: PUSH
52021: LD_STRING , 
52023: STR
52024: PUSH
52025: LD_VAR 0 3
52029: PPUSH
52030: CALL_OW 250
52034: STR
52035: PUSH
52036: LD_STRING , 
52038: STR
52039: PUSH
52040: LD_VAR 0 3
52044: PPUSH
52045: CALL_OW 251
52049: STR
52050: PUSH
52051: LD_STRING , 
52053: STR
52054: PUSH
52055: LD_VAR 0 3
52059: PPUSH
52060: CALL_OW 254
52064: STR
52065: PUSH
52066: LD_STRING , 
52068: STR
52069: PUSH
52070: LD_VAR 0 3
52074: PPUSH
52075: LD_INT 1
52077: PPUSH
52078: CALL_OW 268
52082: STR
52083: PUSH
52084: LD_STRING , 
52086: STR
52087: PUSH
52088: LD_VAR 0 3
52092: PPUSH
52093: LD_INT 2
52095: PPUSH
52096: CALL_OW 268
52100: STR
52101: PUSH
52102: LD_STRING ],
52104: STR
52105: PPUSH
52106: CALL_OW 561
// end ;
52110: GO 52004
52112: POP
52113: POP
// AddToLog ( ]; ) ;
52114: LD_STRING ];
52116: PPUSH
52117: CALL_OW 561
// end ;
52121: LD_VAR 0 2
52125: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
52126: LD_INT 0
52128: PPUSH
52129: PPUSH
52130: PPUSH
52131: PPUSH
52132: PPUSH
// if not area or not rate or not max then
52133: LD_VAR 0 1
52137: NOT
52138: PUSH
52139: LD_VAR 0 2
52143: NOT
52144: OR
52145: PUSH
52146: LD_VAR 0 4
52150: NOT
52151: OR
52152: IFFALSE 52156
// exit ;
52154: GO 52345
// while 1 do
52156: LD_INT 1
52158: IFFALSE 52345
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
52160: LD_ADDR_VAR 0 9
52164: PUSH
52165: LD_VAR 0 1
52169: PPUSH
52170: LD_INT 1
52172: PPUSH
52173: CALL_OW 287
52177: PUSH
52178: LD_INT 10
52180: MUL
52181: ST_TO_ADDR
// r := rate / 10 ;
52182: LD_ADDR_VAR 0 7
52186: PUSH
52187: LD_VAR 0 2
52191: PUSH
52192: LD_INT 10
52194: DIVREAL
52195: ST_TO_ADDR
// time := 1 1$00 ;
52196: LD_ADDR_VAR 0 8
52200: PUSH
52201: LD_INT 2100
52203: ST_TO_ADDR
// if amount < min then
52204: LD_VAR 0 9
52208: PUSH
52209: LD_VAR 0 3
52213: LESS
52214: IFFALSE 52232
// r := r * 2 else
52216: LD_ADDR_VAR 0 7
52220: PUSH
52221: LD_VAR 0 7
52225: PUSH
52226: LD_INT 2
52228: MUL
52229: ST_TO_ADDR
52230: GO 52258
// if amount > max then
52232: LD_VAR 0 9
52236: PUSH
52237: LD_VAR 0 4
52241: GREATER
52242: IFFALSE 52258
// r := r / 2 ;
52244: LD_ADDR_VAR 0 7
52248: PUSH
52249: LD_VAR 0 7
52253: PUSH
52254: LD_INT 2
52256: DIVREAL
52257: ST_TO_ADDR
// time := time / r ;
52258: LD_ADDR_VAR 0 8
52262: PUSH
52263: LD_VAR 0 8
52267: PUSH
52268: LD_VAR 0 7
52272: DIVREAL
52273: ST_TO_ADDR
// if time < 0 then
52274: LD_VAR 0 8
52278: PUSH
52279: LD_INT 0
52281: LESS
52282: IFFALSE 52299
// time := time * - 1 ;
52284: LD_ADDR_VAR 0 8
52288: PUSH
52289: LD_VAR 0 8
52293: PUSH
52294: LD_INT 1
52296: NEG
52297: MUL
52298: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
52299: LD_VAR 0 8
52303: PUSH
52304: LD_INT 35
52306: PPUSH
52307: LD_INT 875
52309: PPUSH
52310: CALL_OW 12
52314: PLUS
52315: PPUSH
52316: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
52320: LD_INT 1
52322: PPUSH
52323: LD_INT 5
52325: PPUSH
52326: CALL_OW 12
52330: PPUSH
52331: LD_VAR 0 1
52335: PPUSH
52336: LD_INT 1
52338: PPUSH
52339: CALL_OW 55
// end ;
52343: GO 52156
// end ;
52345: LD_VAR 0 5
52349: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
52350: LD_INT 0
52352: PPUSH
52353: PPUSH
52354: PPUSH
52355: PPUSH
52356: PPUSH
52357: PPUSH
52358: PPUSH
52359: PPUSH
// if not turrets or not factories then
52360: LD_VAR 0 1
52364: NOT
52365: PUSH
52366: LD_VAR 0 2
52370: NOT
52371: OR
52372: IFFALSE 52376
// exit ;
52374: GO 52683
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
52376: LD_ADDR_VAR 0 10
52380: PUSH
52381: LD_INT 5
52383: PUSH
52384: LD_INT 6
52386: PUSH
52387: EMPTY
52388: LIST
52389: LIST
52390: PUSH
52391: LD_INT 2
52393: PUSH
52394: LD_INT 4
52396: PUSH
52397: EMPTY
52398: LIST
52399: LIST
52400: PUSH
52401: LD_INT 3
52403: PUSH
52404: LD_INT 5
52406: PUSH
52407: EMPTY
52408: LIST
52409: LIST
52410: PUSH
52411: EMPTY
52412: LIST
52413: LIST
52414: LIST
52415: PUSH
52416: LD_INT 24
52418: PUSH
52419: LD_INT 25
52421: PUSH
52422: EMPTY
52423: LIST
52424: LIST
52425: PUSH
52426: LD_INT 23
52428: PUSH
52429: LD_INT 27
52431: PUSH
52432: EMPTY
52433: LIST
52434: LIST
52435: PUSH
52436: EMPTY
52437: LIST
52438: LIST
52439: PUSH
52440: LD_INT 42
52442: PUSH
52443: LD_INT 43
52445: PUSH
52446: EMPTY
52447: LIST
52448: LIST
52449: PUSH
52450: LD_INT 44
52452: PUSH
52453: LD_INT 46
52455: PUSH
52456: EMPTY
52457: LIST
52458: LIST
52459: PUSH
52460: LD_INT 45
52462: PUSH
52463: LD_INT 47
52465: PUSH
52466: EMPTY
52467: LIST
52468: LIST
52469: PUSH
52470: EMPTY
52471: LIST
52472: LIST
52473: LIST
52474: PUSH
52475: EMPTY
52476: LIST
52477: LIST
52478: LIST
52479: ST_TO_ADDR
// result := [ ] ;
52480: LD_ADDR_VAR 0 3
52484: PUSH
52485: EMPTY
52486: ST_TO_ADDR
// for i in turrets do
52487: LD_ADDR_VAR 0 4
52491: PUSH
52492: LD_VAR 0 1
52496: PUSH
52497: FOR_IN
52498: IFFALSE 52681
// begin nat := GetNation ( i ) ;
52500: LD_ADDR_VAR 0 7
52504: PUSH
52505: LD_VAR 0 4
52509: PPUSH
52510: CALL_OW 248
52514: ST_TO_ADDR
// weapon := 0 ;
52515: LD_ADDR_VAR 0 8
52519: PUSH
52520: LD_INT 0
52522: ST_TO_ADDR
// if not nat then
52523: LD_VAR 0 7
52527: NOT
52528: IFFALSE 52532
// continue ;
52530: GO 52497
// for j in list [ nat ] do
52532: LD_ADDR_VAR 0 5
52536: PUSH
52537: LD_VAR 0 10
52541: PUSH
52542: LD_VAR 0 7
52546: ARRAY
52547: PUSH
52548: FOR_IN
52549: IFFALSE 52590
// if GetBWeapon ( i ) = j [ 1 ] then
52551: LD_VAR 0 4
52555: PPUSH
52556: CALL_OW 269
52560: PUSH
52561: LD_VAR 0 5
52565: PUSH
52566: LD_INT 1
52568: ARRAY
52569: EQUAL
52570: IFFALSE 52588
// begin weapon := j [ 2 ] ;
52572: LD_ADDR_VAR 0 8
52576: PUSH
52577: LD_VAR 0 5
52581: PUSH
52582: LD_INT 2
52584: ARRAY
52585: ST_TO_ADDR
// break ;
52586: GO 52590
// end ;
52588: GO 52548
52590: POP
52591: POP
// if not weapon then
52592: LD_VAR 0 8
52596: NOT
52597: IFFALSE 52601
// continue ;
52599: GO 52497
// for k in factories do
52601: LD_ADDR_VAR 0 6
52605: PUSH
52606: LD_VAR 0 2
52610: PUSH
52611: FOR_IN
52612: IFFALSE 52677
// begin weapons := AvailableWeaponList ( k ) ;
52614: LD_ADDR_VAR 0 9
52618: PUSH
52619: LD_VAR 0 6
52623: PPUSH
52624: CALL_OW 478
52628: ST_TO_ADDR
// if not weapons then
52629: LD_VAR 0 9
52633: NOT
52634: IFFALSE 52638
// continue ;
52636: GO 52611
// if weapon in weapons then
52638: LD_VAR 0 8
52642: PUSH
52643: LD_VAR 0 9
52647: IN
52648: IFFALSE 52675
// begin result := [ i , weapon ] ;
52650: LD_ADDR_VAR 0 3
52654: PUSH
52655: LD_VAR 0 4
52659: PUSH
52660: LD_VAR 0 8
52664: PUSH
52665: EMPTY
52666: LIST
52667: LIST
52668: ST_TO_ADDR
// exit ;
52669: POP
52670: POP
52671: POP
52672: POP
52673: GO 52683
// end ; end ;
52675: GO 52611
52677: POP
52678: POP
// end ;
52679: GO 52497
52681: POP
52682: POP
// end ;
52683: LD_VAR 0 3
52687: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
52688: LD_INT 0
52690: PPUSH
// if not side or side > 8 then
52691: LD_VAR 0 3
52695: NOT
52696: PUSH
52697: LD_VAR 0 3
52701: PUSH
52702: LD_INT 8
52704: GREATER
52705: OR
52706: IFFALSE 52710
// exit ;
52708: GO 52769
// if not range then
52710: LD_VAR 0 4
52714: NOT
52715: IFFALSE 52726
// range := - 12 ;
52717: LD_ADDR_VAR 0 4
52721: PUSH
52722: LD_INT 12
52724: NEG
52725: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
52726: LD_VAR 0 1
52730: PPUSH
52731: LD_VAR 0 2
52735: PPUSH
52736: LD_VAR 0 3
52740: PPUSH
52741: LD_VAR 0 4
52745: PPUSH
52746: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
52750: LD_VAR 0 1
52754: PPUSH
52755: LD_VAR 0 2
52759: PPUSH
52760: LD_VAR 0 3
52764: PPUSH
52765: CALL_OW 331
// end ;
52769: LD_VAR 0 5
52773: RET
// export function Video ( mode ) ; begin
52774: LD_INT 0
52776: PPUSH
// ingame_video = mode ;
52777: LD_ADDR_OWVAR 52
52781: PUSH
52782: LD_VAR 0 1
52786: ST_TO_ADDR
// interface_hidden = mode ;
52787: LD_ADDR_OWVAR 54
52791: PUSH
52792: LD_VAR 0 1
52796: ST_TO_ADDR
// end ;
52797: LD_VAR 0 2
52801: RET
// export function Join ( array , element ) ; begin
52802: LD_INT 0
52804: PPUSH
// result := Replace ( array , array + 1 , element ) ;
52805: LD_ADDR_VAR 0 3
52809: PUSH
52810: LD_VAR 0 1
52814: PPUSH
52815: LD_VAR 0 1
52819: PUSH
52820: LD_INT 1
52822: PLUS
52823: PPUSH
52824: LD_VAR 0 2
52828: PPUSH
52829: CALL_OW 1
52833: ST_TO_ADDR
// end ;
52834: LD_VAR 0 3
52838: RET
// export function JoinUnion ( array , element ) ; begin
52839: LD_INT 0
52841: PPUSH
// result := array union element ;
52842: LD_ADDR_VAR 0 3
52846: PUSH
52847: LD_VAR 0 1
52851: PUSH
52852: LD_VAR 0 2
52856: UNION
52857: ST_TO_ADDR
// end ;
52858: LD_VAR 0 3
52862: RET
// export function GetBehemoths ( side ) ; begin
52863: LD_INT 0
52865: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
52866: LD_ADDR_VAR 0 2
52870: PUSH
52871: LD_INT 22
52873: PUSH
52874: LD_VAR 0 1
52878: PUSH
52879: EMPTY
52880: LIST
52881: LIST
52882: PUSH
52883: LD_INT 31
52885: PUSH
52886: LD_INT 25
52888: PUSH
52889: EMPTY
52890: LIST
52891: LIST
52892: PUSH
52893: EMPTY
52894: LIST
52895: LIST
52896: PPUSH
52897: CALL_OW 69
52901: ST_TO_ADDR
// end ;
52902: LD_VAR 0 2
52906: RET
// export function Shuffle ( array ) ; var i , index ; begin
52907: LD_INT 0
52909: PPUSH
52910: PPUSH
52911: PPUSH
// result := [ ] ;
52912: LD_ADDR_VAR 0 2
52916: PUSH
52917: EMPTY
52918: ST_TO_ADDR
// if not array then
52919: LD_VAR 0 1
52923: NOT
52924: IFFALSE 52928
// exit ;
52926: GO 53027
// Randomize ;
52928: CALL_OW 10
// for i = array downto 1 do
52932: LD_ADDR_VAR 0 3
52936: PUSH
52937: DOUBLE
52938: LD_VAR 0 1
52942: INC
52943: ST_TO_ADDR
52944: LD_INT 1
52946: PUSH
52947: FOR_DOWNTO
52948: IFFALSE 53025
// begin index := rand ( 1 , array ) ;
52950: LD_ADDR_VAR 0 4
52954: PUSH
52955: LD_INT 1
52957: PPUSH
52958: LD_VAR 0 1
52962: PPUSH
52963: CALL_OW 12
52967: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
52968: LD_ADDR_VAR 0 2
52972: PUSH
52973: LD_VAR 0 2
52977: PPUSH
52978: LD_VAR 0 2
52982: PUSH
52983: LD_INT 1
52985: PLUS
52986: PPUSH
52987: LD_VAR 0 1
52991: PUSH
52992: LD_VAR 0 4
52996: ARRAY
52997: PPUSH
52998: CALL_OW 2
53002: ST_TO_ADDR
// array := Delete ( array , index ) ;
53003: LD_ADDR_VAR 0 1
53007: PUSH
53008: LD_VAR 0 1
53012: PPUSH
53013: LD_VAR 0 4
53017: PPUSH
53018: CALL_OW 3
53022: ST_TO_ADDR
// end ;
53023: GO 52947
53025: POP
53026: POP
// end ;
53027: LD_VAR 0 2
53031: RET
// export function GetBaseMaterials ( base ) ; begin
53032: LD_INT 0
53034: PPUSH
// result := [ 0 , 0 , 0 ] ;
53035: LD_ADDR_VAR 0 2
53039: PUSH
53040: LD_INT 0
53042: PUSH
53043: LD_INT 0
53045: PUSH
53046: LD_INT 0
53048: PUSH
53049: EMPTY
53050: LIST
53051: LIST
53052: LIST
53053: ST_TO_ADDR
// if not base then
53054: LD_VAR 0 1
53058: NOT
53059: IFFALSE 53063
// exit ;
53061: GO 53112
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
53063: LD_ADDR_VAR 0 2
53067: PUSH
53068: LD_VAR 0 1
53072: PPUSH
53073: LD_INT 1
53075: PPUSH
53076: CALL_OW 275
53080: PUSH
53081: LD_VAR 0 1
53085: PPUSH
53086: LD_INT 2
53088: PPUSH
53089: CALL_OW 275
53093: PUSH
53094: LD_VAR 0 1
53098: PPUSH
53099: LD_INT 3
53101: PPUSH
53102: CALL_OW 275
53106: PUSH
53107: EMPTY
53108: LIST
53109: LIST
53110: LIST
53111: ST_TO_ADDR
// end ;
53112: LD_VAR 0 2
53116: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
53117: LD_INT 0
53119: PPUSH
53120: PPUSH
// result := array ;
53121: LD_ADDR_VAR 0 3
53125: PUSH
53126: LD_VAR 0 1
53130: ST_TO_ADDR
// if size >= result then
53131: LD_VAR 0 2
53135: PUSH
53136: LD_VAR 0 3
53140: GREATEREQUAL
53141: IFFALSE 53145
// exit ;
53143: GO 53195
// if size then
53145: LD_VAR 0 2
53149: IFFALSE 53195
// for i := array downto size do
53151: LD_ADDR_VAR 0 4
53155: PUSH
53156: DOUBLE
53157: LD_VAR 0 1
53161: INC
53162: ST_TO_ADDR
53163: LD_VAR 0 2
53167: PUSH
53168: FOR_DOWNTO
53169: IFFALSE 53193
// result := Delete ( result , result ) ;
53171: LD_ADDR_VAR 0 3
53175: PUSH
53176: LD_VAR 0 3
53180: PPUSH
53181: LD_VAR 0 3
53185: PPUSH
53186: CALL_OW 3
53190: ST_TO_ADDR
53191: GO 53168
53193: POP
53194: POP
// end ;
53195: LD_VAR 0 3
53199: RET
// export function ComExit ( unit ) ; var tmp ; begin
53200: LD_INT 0
53202: PPUSH
53203: PPUSH
// if not IsInUnit ( unit ) then
53204: LD_VAR 0 1
53208: PPUSH
53209: CALL_OW 310
53213: NOT
53214: IFFALSE 53218
// exit ;
53216: GO 53278
// tmp := IsInUnit ( unit ) ;
53218: LD_ADDR_VAR 0 3
53222: PUSH
53223: LD_VAR 0 1
53227: PPUSH
53228: CALL_OW 310
53232: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
53233: LD_VAR 0 3
53237: PPUSH
53238: CALL_OW 247
53242: PUSH
53243: LD_INT 2
53245: EQUAL
53246: IFFALSE 53259
// ComExitVehicle ( unit ) else
53248: LD_VAR 0 1
53252: PPUSH
53253: CALL_OW 121
53257: GO 53268
// ComExitBuilding ( unit ) ;
53259: LD_VAR 0 1
53263: PPUSH
53264: CALL_OW 122
// result := tmp ;
53268: LD_ADDR_VAR 0 2
53272: PUSH
53273: LD_VAR 0 3
53277: ST_TO_ADDR
// end ;
53278: LD_VAR 0 2
53282: RET
// export function ComExitAll ( units ) ; var i ; begin
53283: LD_INT 0
53285: PPUSH
53286: PPUSH
// if not units then
53287: LD_VAR 0 1
53291: NOT
53292: IFFALSE 53296
// exit ;
53294: GO 53322
// for i in units do
53296: LD_ADDR_VAR 0 3
53300: PUSH
53301: LD_VAR 0 1
53305: PUSH
53306: FOR_IN
53307: IFFALSE 53320
// ComExit ( i ) ;
53309: LD_VAR 0 3
53313: PPUSH
53314: CALL 53200 0 1
53318: GO 53306
53320: POP
53321: POP
// end ;
53322: LD_VAR 0 2
53326: RET
// export function ResetHc ; begin
53327: LD_INT 0
53329: PPUSH
// InitHc ;
53330: CALL_OW 19
// hc_importance := 0 ;
53334: LD_ADDR_OWVAR 32
53338: PUSH
53339: LD_INT 0
53341: ST_TO_ADDR
// end ;
53342: LD_VAR 0 1
53346: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
53347: LD_INT 0
53349: PPUSH
53350: PPUSH
53351: PPUSH
// _x := ( x1 + x2 ) div 2 ;
53352: LD_ADDR_VAR 0 6
53356: PUSH
53357: LD_VAR 0 1
53361: PUSH
53362: LD_VAR 0 3
53366: PLUS
53367: PUSH
53368: LD_INT 2
53370: DIV
53371: ST_TO_ADDR
// if _x < 0 then
53372: LD_VAR 0 6
53376: PUSH
53377: LD_INT 0
53379: LESS
53380: IFFALSE 53397
// _x := _x * - 1 ;
53382: LD_ADDR_VAR 0 6
53386: PUSH
53387: LD_VAR 0 6
53391: PUSH
53392: LD_INT 1
53394: NEG
53395: MUL
53396: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
53397: LD_ADDR_VAR 0 7
53401: PUSH
53402: LD_VAR 0 2
53406: PUSH
53407: LD_VAR 0 4
53411: PLUS
53412: PUSH
53413: LD_INT 2
53415: DIV
53416: ST_TO_ADDR
// if _y < 0 then
53417: LD_VAR 0 7
53421: PUSH
53422: LD_INT 0
53424: LESS
53425: IFFALSE 53442
// _y := _y * - 1 ;
53427: LD_ADDR_VAR 0 7
53431: PUSH
53432: LD_VAR 0 7
53436: PUSH
53437: LD_INT 1
53439: NEG
53440: MUL
53441: ST_TO_ADDR
// result := [ _x , _y ] ;
53442: LD_ADDR_VAR 0 5
53446: PUSH
53447: LD_VAR 0 6
53451: PUSH
53452: LD_VAR 0 7
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: ST_TO_ADDR
// end ;
53461: LD_VAR 0 5
53465: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
53466: LD_INT 0
53468: PPUSH
53469: PPUSH
53470: PPUSH
53471: PPUSH
// task := GetTaskList ( unit ) ;
53472: LD_ADDR_VAR 0 7
53476: PUSH
53477: LD_VAR 0 1
53481: PPUSH
53482: CALL_OW 437
53486: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
53487: LD_VAR 0 7
53491: NOT
53492: PUSH
53493: LD_VAR 0 1
53497: PPUSH
53498: LD_VAR 0 2
53502: PPUSH
53503: CALL_OW 308
53507: NOT
53508: AND
53509: IFFALSE 53513
// exit ;
53511: GO 53631
// if IsInArea ( unit , area ) then
53513: LD_VAR 0 1
53517: PPUSH
53518: LD_VAR 0 2
53522: PPUSH
53523: CALL_OW 308
53527: IFFALSE 53545
// begin ComMoveToArea ( unit , goAway ) ;
53529: LD_VAR 0 1
53533: PPUSH
53534: LD_VAR 0 3
53538: PPUSH
53539: CALL_OW 113
// exit ;
53543: GO 53631
// end ; if task [ 1 ] [ 1 ] <> M then
53545: LD_VAR 0 7
53549: PUSH
53550: LD_INT 1
53552: ARRAY
53553: PUSH
53554: LD_INT 1
53556: ARRAY
53557: PUSH
53558: LD_STRING M
53560: NONEQUAL
53561: IFFALSE 53565
// exit ;
53563: GO 53631
// x := task [ 1 ] [ 2 ] ;
53565: LD_ADDR_VAR 0 5
53569: PUSH
53570: LD_VAR 0 7
53574: PUSH
53575: LD_INT 1
53577: ARRAY
53578: PUSH
53579: LD_INT 2
53581: ARRAY
53582: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
53583: LD_ADDR_VAR 0 6
53587: PUSH
53588: LD_VAR 0 7
53592: PUSH
53593: LD_INT 1
53595: ARRAY
53596: PUSH
53597: LD_INT 3
53599: ARRAY
53600: ST_TO_ADDR
// if InArea ( x , y , area ) then
53601: LD_VAR 0 5
53605: PPUSH
53606: LD_VAR 0 6
53610: PPUSH
53611: LD_VAR 0 2
53615: PPUSH
53616: CALL_OW 309
53620: IFFALSE 53631
// ComStop ( unit ) ;
53622: LD_VAR 0 1
53626: PPUSH
53627: CALL_OW 141
// end ;
53631: LD_VAR 0 4
53635: RET
// export function Abs ( value ) ; begin
53636: LD_INT 0
53638: PPUSH
// result := value ;
53639: LD_ADDR_VAR 0 2
53643: PUSH
53644: LD_VAR 0 1
53648: ST_TO_ADDR
// if value < 0 then
53649: LD_VAR 0 1
53653: PUSH
53654: LD_INT 0
53656: LESS
53657: IFFALSE 53674
// result := value * - 1 ;
53659: LD_ADDR_VAR 0 2
53663: PUSH
53664: LD_VAR 0 1
53668: PUSH
53669: LD_INT 1
53671: NEG
53672: MUL
53673: ST_TO_ADDR
// end ;
53674: LD_VAR 0 2
53678: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
53679: LD_INT 0
53681: PPUSH
53682: PPUSH
53683: PPUSH
53684: PPUSH
53685: PPUSH
53686: PPUSH
53687: PPUSH
53688: PPUSH
// if not unit or not building then
53689: LD_VAR 0 1
53693: NOT
53694: PUSH
53695: LD_VAR 0 2
53699: NOT
53700: OR
53701: IFFALSE 53705
// exit ;
53703: GO 53931
// x := GetX ( building ) ;
53705: LD_ADDR_VAR 0 4
53709: PUSH
53710: LD_VAR 0 2
53714: PPUSH
53715: CALL_OW 250
53719: ST_TO_ADDR
// y := GetY ( building ) ;
53720: LD_ADDR_VAR 0 6
53724: PUSH
53725: LD_VAR 0 2
53729: PPUSH
53730: CALL_OW 251
53734: ST_TO_ADDR
// d := GetDir ( building ) ;
53735: LD_ADDR_VAR 0 8
53739: PUSH
53740: LD_VAR 0 2
53744: PPUSH
53745: CALL_OW 254
53749: ST_TO_ADDR
// r := 4 ;
53750: LD_ADDR_VAR 0 9
53754: PUSH
53755: LD_INT 4
53757: ST_TO_ADDR
// for i := 1 to 5 do
53758: LD_ADDR_VAR 0 10
53762: PUSH
53763: DOUBLE
53764: LD_INT 1
53766: DEC
53767: ST_TO_ADDR
53768: LD_INT 5
53770: PUSH
53771: FOR_TO
53772: IFFALSE 53929
// begin _x := ShiftX ( x , d , r + i ) ;
53774: LD_ADDR_VAR 0 5
53778: PUSH
53779: LD_VAR 0 4
53783: PPUSH
53784: LD_VAR 0 8
53788: PPUSH
53789: LD_VAR 0 9
53793: PUSH
53794: LD_VAR 0 10
53798: PLUS
53799: PPUSH
53800: CALL_OW 272
53804: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
53805: LD_ADDR_VAR 0 7
53809: PUSH
53810: LD_VAR 0 6
53814: PPUSH
53815: LD_VAR 0 8
53819: PPUSH
53820: LD_VAR 0 9
53824: PUSH
53825: LD_VAR 0 10
53829: PLUS
53830: PPUSH
53831: CALL_OW 273
53835: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
53836: LD_VAR 0 5
53840: PPUSH
53841: LD_VAR 0 7
53845: PPUSH
53846: CALL_OW 488
53850: PUSH
53851: LD_VAR 0 5
53855: PPUSH
53856: LD_VAR 0 7
53860: PPUSH
53861: CALL_OW 428
53865: PPUSH
53866: CALL_OW 247
53870: PUSH
53871: LD_INT 3
53873: PUSH
53874: LD_INT 2
53876: PUSH
53877: EMPTY
53878: LIST
53879: LIST
53880: IN
53881: NOT
53882: AND
53883: IFFALSE 53927
// begin ComMoveXY ( unit , _x , _y ) ;
53885: LD_VAR 0 1
53889: PPUSH
53890: LD_VAR 0 5
53894: PPUSH
53895: LD_VAR 0 7
53899: PPUSH
53900: CALL_OW 111
// result := [ _x , _y ] ;
53904: LD_ADDR_VAR 0 3
53908: PUSH
53909: LD_VAR 0 5
53913: PUSH
53914: LD_VAR 0 7
53918: PUSH
53919: EMPTY
53920: LIST
53921: LIST
53922: ST_TO_ADDR
// exit ;
53923: POP
53924: POP
53925: GO 53931
// end ; end ;
53927: GO 53771
53929: POP
53930: POP
// end ;
53931: LD_VAR 0 3
53935: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
53936: LD_INT 0
53938: PPUSH
53939: PPUSH
53940: PPUSH
// result := 0 ;
53941: LD_ADDR_VAR 0 3
53945: PUSH
53946: LD_INT 0
53948: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
53949: LD_VAR 0 1
53953: PUSH
53954: LD_INT 0
53956: LESS
53957: PUSH
53958: LD_VAR 0 1
53962: PUSH
53963: LD_INT 8
53965: GREATER
53966: OR
53967: PUSH
53968: LD_VAR 0 2
53972: PUSH
53973: LD_INT 0
53975: LESS
53976: OR
53977: PUSH
53978: LD_VAR 0 2
53982: PUSH
53983: LD_INT 8
53985: GREATER
53986: OR
53987: IFFALSE 53991
// exit ;
53989: GO 54066
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
53991: LD_ADDR_VAR 0 4
53995: PUSH
53996: LD_INT 22
53998: PUSH
53999: LD_VAR 0 2
54003: PUSH
54004: EMPTY
54005: LIST
54006: LIST
54007: PPUSH
54008: CALL_OW 69
54012: PUSH
54013: FOR_IN
54014: IFFALSE 54064
// begin un := UnitShoot ( i ) ;
54016: LD_ADDR_VAR 0 5
54020: PUSH
54021: LD_VAR 0 4
54025: PPUSH
54026: CALL_OW 504
54030: ST_TO_ADDR
// if GetSide ( un ) = side1 then
54031: LD_VAR 0 5
54035: PPUSH
54036: CALL_OW 255
54040: PUSH
54041: LD_VAR 0 1
54045: EQUAL
54046: IFFALSE 54062
// begin result := un ;
54048: LD_ADDR_VAR 0 3
54052: PUSH
54053: LD_VAR 0 5
54057: ST_TO_ADDR
// exit ;
54058: POP
54059: POP
54060: GO 54066
// end ; end ;
54062: GO 54013
54064: POP
54065: POP
// end ;
54066: LD_VAR 0 3
54070: RET
// export function GetCargoBay ( units ) ; begin
54071: LD_INT 0
54073: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
54074: LD_ADDR_VAR 0 2
54078: PUSH
54079: LD_VAR 0 1
54083: PPUSH
54084: LD_INT 2
54086: PUSH
54087: LD_INT 34
54089: PUSH
54090: LD_INT 12
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: PUSH
54097: LD_INT 34
54099: PUSH
54100: LD_INT 51
54102: PUSH
54103: EMPTY
54104: LIST
54105: LIST
54106: PUSH
54107: LD_INT 34
54109: PUSH
54110: LD_INT 32
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: PUSH
54117: LD_INT 34
54119: PUSH
54120: LD_INT 89
54122: PUSH
54123: EMPTY
54124: LIST
54125: LIST
54126: PUSH
54127: EMPTY
54128: LIST
54129: LIST
54130: LIST
54131: LIST
54132: LIST
54133: PPUSH
54134: CALL_OW 72
54138: ST_TO_ADDR
// end ;
54139: LD_VAR 0 2
54143: RET
// export function Negate ( value ) ; begin
54144: LD_INT 0
54146: PPUSH
// result := not value ;
54147: LD_ADDR_VAR 0 2
54151: PUSH
54152: LD_VAR 0 1
54156: NOT
54157: ST_TO_ADDR
// end ;
54158: LD_VAR 0 2
54162: RET
// export function Inc ( value ) ; begin
54163: LD_INT 0
54165: PPUSH
// result := value + 1 ;
54166: LD_ADDR_VAR 0 2
54170: PUSH
54171: LD_VAR 0 1
54175: PUSH
54176: LD_INT 1
54178: PLUS
54179: ST_TO_ADDR
// end ;
54180: LD_VAR 0 2
54184: RET
// export function Dec ( value ) ; begin
54185: LD_INT 0
54187: PPUSH
// result := value - 1 ;
54188: LD_ADDR_VAR 0 2
54192: PUSH
54193: LD_VAR 0 1
54197: PUSH
54198: LD_INT 1
54200: MINUS
54201: ST_TO_ADDR
// end ;
54202: LD_VAR 0 2
54206: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
54207: LD_INT 0
54209: PPUSH
54210: PPUSH
54211: PPUSH
54212: PPUSH
54213: PPUSH
54214: PPUSH
54215: PPUSH
54216: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
54217: LD_VAR 0 1
54221: PPUSH
54222: LD_VAR 0 2
54226: PPUSH
54227: CALL_OW 488
54231: NOT
54232: PUSH
54233: LD_VAR 0 3
54237: PPUSH
54238: LD_VAR 0 4
54242: PPUSH
54243: CALL_OW 488
54247: NOT
54248: OR
54249: IFFALSE 54262
// begin result := - 1 ;
54251: LD_ADDR_VAR 0 5
54255: PUSH
54256: LD_INT 1
54258: NEG
54259: ST_TO_ADDR
// exit ;
54260: GO 54497
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
54262: LD_ADDR_VAR 0 12
54266: PUSH
54267: LD_VAR 0 1
54271: PPUSH
54272: LD_VAR 0 2
54276: PPUSH
54277: LD_VAR 0 3
54281: PPUSH
54282: LD_VAR 0 4
54286: PPUSH
54287: CALL 53347 0 4
54291: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
54292: LD_ADDR_VAR 0 11
54296: PUSH
54297: LD_VAR 0 1
54301: PPUSH
54302: LD_VAR 0 2
54306: PPUSH
54307: LD_VAR 0 12
54311: PUSH
54312: LD_INT 1
54314: ARRAY
54315: PPUSH
54316: LD_VAR 0 12
54320: PUSH
54321: LD_INT 2
54323: ARRAY
54324: PPUSH
54325: CALL_OW 298
54329: ST_TO_ADDR
// distance := 9999 ;
54330: LD_ADDR_VAR 0 10
54334: PUSH
54335: LD_INT 9999
54337: ST_TO_ADDR
// for i := 0 to 5 do
54338: LD_ADDR_VAR 0 6
54342: PUSH
54343: DOUBLE
54344: LD_INT 0
54346: DEC
54347: ST_TO_ADDR
54348: LD_INT 5
54350: PUSH
54351: FOR_TO
54352: IFFALSE 54495
// begin _x := ShiftX ( x1 , i , centerDist ) ;
54354: LD_ADDR_VAR 0 7
54358: PUSH
54359: LD_VAR 0 1
54363: PPUSH
54364: LD_VAR 0 6
54368: PPUSH
54369: LD_VAR 0 11
54373: PPUSH
54374: CALL_OW 272
54378: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
54379: LD_ADDR_VAR 0 8
54383: PUSH
54384: LD_VAR 0 2
54388: PPUSH
54389: LD_VAR 0 6
54393: PPUSH
54394: LD_VAR 0 11
54398: PPUSH
54399: CALL_OW 273
54403: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
54404: LD_VAR 0 7
54408: PPUSH
54409: LD_VAR 0 8
54413: PPUSH
54414: CALL_OW 488
54418: NOT
54419: IFFALSE 54423
// continue ;
54421: GO 54351
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
54423: LD_ADDR_VAR 0 9
54427: PUSH
54428: LD_VAR 0 12
54432: PUSH
54433: LD_INT 1
54435: ARRAY
54436: PPUSH
54437: LD_VAR 0 12
54441: PUSH
54442: LD_INT 2
54444: ARRAY
54445: PPUSH
54446: LD_VAR 0 7
54450: PPUSH
54451: LD_VAR 0 8
54455: PPUSH
54456: CALL_OW 298
54460: ST_TO_ADDR
// if tmp < distance then
54461: LD_VAR 0 9
54465: PUSH
54466: LD_VAR 0 10
54470: LESS
54471: IFFALSE 54493
// begin result := i ;
54473: LD_ADDR_VAR 0 5
54477: PUSH
54478: LD_VAR 0 6
54482: ST_TO_ADDR
// distance := tmp ;
54483: LD_ADDR_VAR 0 10
54487: PUSH
54488: LD_VAR 0 9
54492: ST_TO_ADDR
// end ; end ;
54493: GO 54351
54495: POP
54496: POP
// end ;
54497: LD_VAR 0 5
54501: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54502: LD_INT 0
54504: PPUSH
54505: PPUSH
// if not driver or not IsInUnit ( driver ) then
54506: LD_VAR 0 1
54510: NOT
54511: PUSH
54512: LD_VAR 0 1
54516: PPUSH
54517: CALL_OW 310
54521: NOT
54522: OR
54523: IFFALSE 54527
// exit ;
54525: GO 54617
// vehicle := IsInUnit ( driver ) ;
54527: LD_ADDR_VAR 0 3
54531: PUSH
54532: LD_VAR 0 1
54536: PPUSH
54537: CALL_OW 310
54541: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54542: LD_VAR 0 1
54546: PPUSH
54547: LD_STRING \
54549: PUSH
54550: LD_INT 0
54552: PUSH
54553: LD_INT 0
54555: PUSH
54556: LD_INT 0
54558: PUSH
54559: LD_INT 0
54561: PUSH
54562: LD_INT 0
54564: PUSH
54565: LD_INT 0
54567: PUSH
54568: EMPTY
54569: LIST
54570: LIST
54571: LIST
54572: LIST
54573: LIST
54574: LIST
54575: LIST
54576: PUSH
54577: LD_STRING E
54579: PUSH
54580: LD_INT 0
54582: PUSH
54583: LD_INT 0
54585: PUSH
54586: LD_VAR 0 3
54590: PUSH
54591: LD_INT 0
54593: PUSH
54594: LD_INT 0
54596: PUSH
54597: LD_INT 0
54599: PUSH
54600: EMPTY
54601: LIST
54602: LIST
54603: LIST
54604: LIST
54605: LIST
54606: LIST
54607: LIST
54608: PUSH
54609: EMPTY
54610: LIST
54611: LIST
54612: PPUSH
54613: CALL_OW 446
// end ;
54617: LD_VAR 0 2
54621: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
54622: LD_INT 0
54624: PPUSH
54625: PPUSH
// if not driver or not IsInUnit ( driver ) then
54626: LD_VAR 0 1
54630: NOT
54631: PUSH
54632: LD_VAR 0 1
54636: PPUSH
54637: CALL_OW 310
54641: NOT
54642: OR
54643: IFFALSE 54647
// exit ;
54645: GO 54737
// vehicle := IsInUnit ( driver ) ;
54647: LD_ADDR_VAR 0 3
54651: PUSH
54652: LD_VAR 0 1
54656: PPUSH
54657: CALL_OW 310
54661: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
54662: LD_VAR 0 1
54666: PPUSH
54667: LD_STRING \
54669: PUSH
54670: LD_INT 0
54672: PUSH
54673: LD_INT 0
54675: PUSH
54676: LD_INT 0
54678: PUSH
54679: LD_INT 0
54681: PUSH
54682: LD_INT 0
54684: PUSH
54685: LD_INT 0
54687: PUSH
54688: EMPTY
54689: LIST
54690: LIST
54691: LIST
54692: LIST
54693: LIST
54694: LIST
54695: LIST
54696: PUSH
54697: LD_STRING E
54699: PUSH
54700: LD_INT 0
54702: PUSH
54703: LD_INT 0
54705: PUSH
54706: LD_VAR 0 3
54710: PUSH
54711: LD_INT 0
54713: PUSH
54714: LD_INT 0
54716: PUSH
54717: LD_INT 0
54719: PUSH
54720: EMPTY
54721: LIST
54722: LIST
54723: LIST
54724: LIST
54725: LIST
54726: LIST
54727: LIST
54728: PUSH
54729: EMPTY
54730: LIST
54731: LIST
54732: PPUSH
54733: CALL_OW 447
// end ;
54737: LD_VAR 0 2
54741: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
54742: LD_INT 0
54744: PPUSH
54745: PPUSH
54746: PPUSH
// tmp := [ ] ;
54747: LD_ADDR_VAR 0 5
54751: PUSH
54752: EMPTY
54753: ST_TO_ADDR
// for i in units do
54754: LD_ADDR_VAR 0 4
54758: PUSH
54759: LD_VAR 0 1
54763: PUSH
54764: FOR_IN
54765: IFFALSE 54803
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
54767: LD_ADDR_VAR 0 5
54771: PUSH
54772: LD_VAR 0 5
54776: PPUSH
54777: LD_VAR 0 5
54781: PUSH
54782: LD_INT 1
54784: PLUS
54785: PPUSH
54786: LD_VAR 0 4
54790: PPUSH
54791: CALL_OW 256
54795: PPUSH
54796: CALL_OW 2
54800: ST_TO_ADDR
54801: GO 54764
54803: POP
54804: POP
// if not tmp then
54805: LD_VAR 0 5
54809: NOT
54810: IFFALSE 54814
// exit ;
54812: GO 54862
// if asc then
54814: LD_VAR 0 2
54818: IFFALSE 54842
// result := SortListByListAsc ( units , tmp ) else
54820: LD_ADDR_VAR 0 3
54824: PUSH
54825: LD_VAR 0 1
54829: PPUSH
54830: LD_VAR 0 5
54834: PPUSH
54835: CALL_OW 76
54839: ST_TO_ADDR
54840: GO 54862
// result := SortListByListDesc ( units , tmp ) ;
54842: LD_ADDR_VAR 0 3
54846: PUSH
54847: LD_VAR 0 1
54851: PPUSH
54852: LD_VAR 0 5
54856: PPUSH
54857: CALL_OW 77
54861: ST_TO_ADDR
// end ;
54862: LD_VAR 0 3
54866: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
54867: LD_INT 0
54869: PPUSH
54870: PPUSH
// task := GetTaskList ( mech ) ;
54871: LD_ADDR_VAR 0 4
54875: PUSH
54876: LD_VAR 0 1
54880: PPUSH
54881: CALL_OW 437
54885: ST_TO_ADDR
// if not task then
54886: LD_VAR 0 4
54890: NOT
54891: IFFALSE 54895
// exit ;
54893: GO 54937
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
54895: LD_ADDR_VAR 0 3
54899: PUSH
54900: LD_VAR 0 4
54904: PUSH
54905: LD_INT 1
54907: ARRAY
54908: PUSH
54909: LD_INT 1
54911: ARRAY
54912: PUSH
54913: LD_STRING r
54915: EQUAL
54916: PUSH
54917: LD_VAR 0 4
54921: PUSH
54922: LD_INT 1
54924: ARRAY
54925: PUSH
54926: LD_INT 4
54928: ARRAY
54929: PUSH
54930: LD_VAR 0 2
54934: EQUAL
54935: AND
54936: ST_TO_ADDR
// end ;
54937: LD_VAR 0 3
54941: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
54942: LD_INT 0
54944: PPUSH
// SetDir ( unit , d ) ;
54945: LD_VAR 0 1
54949: PPUSH
54950: LD_VAR 0 4
54954: PPUSH
54955: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
54959: LD_VAR 0 1
54963: PPUSH
54964: LD_VAR 0 2
54968: PPUSH
54969: LD_VAR 0 3
54973: PPUSH
54974: LD_VAR 0 5
54978: PPUSH
54979: CALL_OW 48
// end ;
54983: LD_VAR 0 6
54987: RET
// export function ToNaturalNumber ( number ) ; begin
54988: LD_INT 0
54990: PPUSH
// result := number div 1 ;
54991: LD_ADDR_VAR 0 2
54995: PUSH
54996: LD_VAR 0 1
55000: PUSH
55001: LD_INT 1
55003: DIV
55004: ST_TO_ADDR
// if number < 0 then
55005: LD_VAR 0 1
55009: PUSH
55010: LD_INT 0
55012: LESS
55013: IFFALSE 55023
// result := 0 ;
55015: LD_ADDR_VAR 0 2
55019: PUSH
55020: LD_INT 0
55022: ST_TO_ADDR
// end ;
55023: LD_VAR 0 2
55027: RET
// export function SortByClass ( units , class ) ; var un ; begin
55028: LD_INT 0
55030: PPUSH
55031: PPUSH
// if not units or not class then
55032: LD_VAR 0 1
55036: NOT
55037: PUSH
55038: LD_VAR 0 2
55042: NOT
55043: OR
55044: IFFALSE 55048
// exit ;
55046: GO 55143
// result := [ ] ;
55048: LD_ADDR_VAR 0 3
55052: PUSH
55053: EMPTY
55054: ST_TO_ADDR
// for un in units do
55055: LD_ADDR_VAR 0 4
55059: PUSH
55060: LD_VAR 0 1
55064: PUSH
55065: FOR_IN
55066: IFFALSE 55141
// if GetClass ( un ) = class then
55068: LD_VAR 0 4
55072: PPUSH
55073: CALL_OW 257
55077: PUSH
55078: LD_VAR 0 2
55082: EQUAL
55083: IFFALSE 55110
// result := Insert ( result , 1 , un ) else
55085: LD_ADDR_VAR 0 3
55089: PUSH
55090: LD_VAR 0 3
55094: PPUSH
55095: LD_INT 1
55097: PPUSH
55098: LD_VAR 0 4
55102: PPUSH
55103: CALL_OW 2
55107: ST_TO_ADDR
55108: GO 55139
// result := Replace ( result , result + 1 , un ) ;
55110: LD_ADDR_VAR 0 3
55114: PUSH
55115: LD_VAR 0 3
55119: PPUSH
55120: LD_VAR 0 3
55124: PUSH
55125: LD_INT 1
55127: PLUS
55128: PPUSH
55129: LD_VAR 0 4
55133: PPUSH
55134: CALL_OW 1
55138: ST_TO_ADDR
55139: GO 55065
55141: POP
55142: POP
// end ;
55143: LD_VAR 0 3
55147: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
55148: LD_INT 0
55150: PPUSH
55151: PPUSH
55152: PPUSH
55153: PPUSH
55154: PPUSH
55155: PPUSH
55156: PPUSH
// result := [ ] ;
55157: LD_ADDR_VAR 0 4
55161: PUSH
55162: EMPTY
55163: ST_TO_ADDR
// if x - r < 0 then
55164: LD_VAR 0 1
55168: PUSH
55169: LD_VAR 0 3
55173: MINUS
55174: PUSH
55175: LD_INT 0
55177: LESS
55178: IFFALSE 55190
// min_x := 0 else
55180: LD_ADDR_VAR 0 8
55184: PUSH
55185: LD_INT 0
55187: ST_TO_ADDR
55188: GO 55206
// min_x := x - r ;
55190: LD_ADDR_VAR 0 8
55194: PUSH
55195: LD_VAR 0 1
55199: PUSH
55200: LD_VAR 0 3
55204: MINUS
55205: ST_TO_ADDR
// if y - r < 0 then
55206: LD_VAR 0 2
55210: PUSH
55211: LD_VAR 0 3
55215: MINUS
55216: PUSH
55217: LD_INT 0
55219: LESS
55220: IFFALSE 55232
// min_y := 0 else
55222: LD_ADDR_VAR 0 7
55226: PUSH
55227: LD_INT 0
55229: ST_TO_ADDR
55230: GO 55248
// min_y := y - r ;
55232: LD_ADDR_VAR 0 7
55236: PUSH
55237: LD_VAR 0 2
55241: PUSH
55242: LD_VAR 0 3
55246: MINUS
55247: ST_TO_ADDR
// max_x := x + r ;
55248: LD_ADDR_VAR 0 9
55252: PUSH
55253: LD_VAR 0 1
55257: PUSH
55258: LD_VAR 0 3
55262: PLUS
55263: ST_TO_ADDR
// max_y := y + r ;
55264: LD_ADDR_VAR 0 10
55268: PUSH
55269: LD_VAR 0 2
55273: PUSH
55274: LD_VAR 0 3
55278: PLUS
55279: ST_TO_ADDR
// for _x = min_x to max_x do
55280: LD_ADDR_VAR 0 5
55284: PUSH
55285: DOUBLE
55286: LD_VAR 0 8
55290: DEC
55291: ST_TO_ADDR
55292: LD_VAR 0 9
55296: PUSH
55297: FOR_TO
55298: IFFALSE 55399
// for _y = min_y to max_y do
55300: LD_ADDR_VAR 0 6
55304: PUSH
55305: DOUBLE
55306: LD_VAR 0 7
55310: DEC
55311: ST_TO_ADDR
55312: LD_VAR 0 10
55316: PUSH
55317: FOR_TO
55318: IFFALSE 55395
// begin if not ValidHex ( _x , _y ) then
55320: LD_VAR 0 5
55324: PPUSH
55325: LD_VAR 0 6
55329: PPUSH
55330: CALL_OW 488
55334: NOT
55335: IFFALSE 55339
// continue ;
55337: GO 55317
// if GetResourceTypeXY ( _x , _y ) then
55339: LD_VAR 0 5
55343: PPUSH
55344: LD_VAR 0 6
55348: PPUSH
55349: CALL_OW 283
55353: IFFALSE 55393
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
55355: LD_ADDR_VAR 0 4
55359: PUSH
55360: LD_VAR 0 4
55364: PPUSH
55365: LD_VAR 0 4
55369: PUSH
55370: LD_INT 1
55372: PLUS
55373: PPUSH
55374: LD_VAR 0 5
55378: PUSH
55379: LD_VAR 0 6
55383: PUSH
55384: EMPTY
55385: LIST
55386: LIST
55387: PPUSH
55388: CALL_OW 1
55392: ST_TO_ADDR
// end ;
55393: GO 55317
55395: POP
55396: POP
55397: GO 55297
55399: POP
55400: POP
// end ;
55401: LD_VAR 0 4
55405: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
55406: LD_INT 0
55408: PPUSH
55409: PPUSH
55410: PPUSH
55411: PPUSH
55412: PPUSH
55413: PPUSH
55414: PPUSH
55415: PPUSH
// if not units then
55416: LD_VAR 0 1
55420: NOT
55421: IFFALSE 55425
// exit ;
55423: GO 55949
// result := UnitFilter ( units , [ f_ok ] ) ;
55425: LD_ADDR_VAR 0 3
55429: PUSH
55430: LD_VAR 0 1
55434: PPUSH
55435: LD_INT 50
55437: PUSH
55438: EMPTY
55439: LIST
55440: PPUSH
55441: CALL_OW 72
55445: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
55446: LD_ADDR_VAR 0 8
55450: PUSH
55451: LD_VAR 0 1
55455: PUSH
55456: LD_INT 1
55458: ARRAY
55459: PPUSH
55460: CALL_OW 255
55464: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
55465: LD_ADDR_VAR 0 10
55469: PUSH
55470: LD_INT 29
55472: PUSH
55473: LD_INT 91
55475: PUSH
55476: LD_INT 49
55478: PUSH
55479: EMPTY
55480: LIST
55481: LIST
55482: LIST
55483: ST_TO_ADDR
// if not result then
55484: LD_VAR 0 3
55488: NOT
55489: IFFALSE 55493
// exit ;
55491: GO 55949
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
55493: LD_ADDR_VAR 0 5
55497: PUSH
55498: LD_INT 81
55500: PUSH
55501: LD_VAR 0 8
55505: PUSH
55506: EMPTY
55507: LIST
55508: LIST
55509: PPUSH
55510: CALL_OW 69
55514: ST_TO_ADDR
// for i in result do
55515: LD_ADDR_VAR 0 4
55519: PUSH
55520: LD_VAR 0 3
55524: PUSH
55525: FOR_IN
55526: IFFALSE 55947
// begin tag := GetTag ( i ) + 1 ;
55528: LD_ADDR_VAR 0 9
55532: PUSH
55533: LD_VAR 0 4
55537: PPUSH
55538: CALL_OW 110
55542: PUSH
55543: LD_INT 1
55545: PLUS
55546: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
55547: LD_ADDR_VAR 0 7
55551: PUSH
55552: LD_VAR 0 4
55556: PPUSH
55557: CALL_OW 250
55561: PPUSH
55562: LD_VAR 0 4
55566: PPUSH
55567: CALL_OW 251
55571: PPUSH
55572: LD_INT 6
55574: PPUSH
55575: CALL 55148 0 3
55579: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
55580: LD_VAR 0 4
55584: PPUSH
55585: CALL_OW 247
55589: PUSH
55590: LD_INT 2
55592: EQUAL
55593: PUSH
55594: LD_VAR 0 7
55598: AND
55599: PUSH
55600: LD_VAR 0 4
55604: PPUSH
55605: CALL_OW 264
55609: PUSH
55610: LD_VAR 0 10
55614: IN
55615: NOT
55616: AND
55617: IFFALSE 55656
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
55619: LD_VAR 0 4
55623: PPUSH
55624: LD_VAR 0 7
55628: PUSH
55629: LD_INT 1
55631: ARRAY
55632: PUSH
55633: LD_INT 1
55635: ARRAY
55636: PPUSH
55637: LD_VAR 0 7
55641: PUSH
55642: LD_INT 1
55644: ARRAY
55645: PUSH
55646: LD_INT 2
55648: ARRAY
55649: PPUSH
55650: CALL_OW 116
55654: GO 55945
// if path > tag then
55656: LD_VAR 0 2
55660: PUSH
55661: LD_VAR 0 9
55665: GREATER
55666: IFFALSE 55874
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
55668: LD_ADDR_VAR 0 6
55672: PUSH
55673: LD_VAR 0 5
55677: PPUSH
55678: LD_INT 91
55680: PUSH
55681: LD_VAR 0 4
55685: PUSH
55686: LD_INT 8
55688: PUSH
55689: EMPTY
55690: LIST
55691: LIST
55692: LIST
55693: PPUSH
55694: CALL_OW 72
55698: ST_TO_ADDR
// if nearEnemy then
55699: LD_VAR 0 6
55703: IFFALSE 55772
// begin if GetWeapon ( i ) = ru_time_lapser then
55705: LD_VAR 0 4
55709: PPUSH
55710: CALL_OW 264
55714: PUSH
55715: LD_INT 49
55717: EQUAL
55718: IFFALSE 55746
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
55720: LD_VAR 0 4
55724: PPUSH
55725: LD_VAR 0 6
55729: PPUSH
55730: LD_VAR 0 4
55734: PPUSH
55735: CALL_OW 74
55739: PPUSH
55740: CALL_OW 112
55744: GO 55770
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
55746: LD_VAR 0 4
55750: PPUSH
55751: LD_VAR 0 6
55755: PPUSH
55756: LD_VAR 0 4
55760: PPUSH
55761: CALL_OW 74
55765: PPUSH
55766: CALL 56874 0 2
// end else
55770: GO 55872
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
55772: LD_VAR 0 4
55776: PPUSH
55777: LD_VAR 0 2
55781: PUSH
55782: LD_VAR 0 9
55786: ARRAY
55787: PUSH
55788: LD_INT 1
55790: ARRAY
55791: PPUSH
55792: LD_VAR 0 2
55796: PUSH
55797: LD_VAR 0 9
55801: ARRAY
55802: PUSH
55803: LD_INT 2
55805: ARRAY
55806: PPUSH
55807: CALL_OW 297
55811: PUSH
55812: LD_INT 6
55814: GREATER
55815: IFFALSE 55858
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
55817: LD_VAR 0 4
55821: PPUSH
55822: LD_VAR 0 2
55826: PUSH
55827: LD_VAR 0 9
55831: ARRAY
55832: PUSH
55833: LD_INT 1
55835: ARRAY
55836: PPUSH
55837: LD_VAR 0 2
55841: PUSH
55842: LD_VAR 0 9
55846: ARRAY
55847: PUSH
55848: LD_INT 2
55850: ARRAY
55851: PPUSH
55852: CALL_OW 114
55856: GO 55872
// SetTag ( i , tag ) ;
55858: LD_VAR 0 4
55862: PPUSH
55863: LD_VAR 0 9
55867: PPUSH
55868: CALL_OW 109
// end else
55872: GO 55945
// if enemy then
55874: LD_VAR 0 5
55878: IFFALSE 55945
// begin if GetWeapon ( i ) = ru_time_lapser then
55880: LD_VAR 0 4
55884: PPUSH
55885: CALL_OW 264
55889: PUSH
55890: LD_INT 49
55892: EQUAL
55893: IFFALSE 55921
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
55895: LD_VAR 0 4
55899: PPUSH
55900: LD_VAR 0 5
55904: PPUSH
55905: LD_VAR 0 4
55909: PPUSH
55910: CALL_OW 74
55914: PPUSH
55915: CALL_OW 112
55919: GO 55945
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
55921: LD_VAR 0 4
55925: PPUSH
55926: LD_VAR 0 5
55930: PPUSH
55931: LD_VAR 0 4
55935: PPUSH
55936: CALL_OW 74
55940: PPUSH
55941: CALL 56874 0 2
// end ; end ;
55945: GO 55525
55947: POP
55948: POP
// end ;
55949: LD_VAR 0 3
55953: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
55954: LD_INT 0
55956: PPUSH
55957: PPUSH
55958: PPUSH
// if not unit or IsInUnit ( unit ) then
55959: LD_VAR 0 1
55963: NOT
55964: PUSH
55965: LD_VAR 0 1
55969: PPUSH
55970: CALL_OW 310
55974: OR
55975: IFFALSE 55979
// exit ;
55977: GO 56070
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
55979: LD_ADDR_VAR 0 4
55983: PUSH
55984: LD_VAR 0 1
55988: PPUSH
55989: CALL_OW 250
55993: PPUSH
55994: LD_VAR 0 2
55998: PPUSH
55999: LD_INT 1
56001: PPUSH
56002: CALL_OW 272
56006: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
56007: LD_ADDR_VAR 0 5
56011: PUSH
56012: LD_VAR 0 1
56016: PPUSH
56017: CALL_OW 251
56021: PPUSH
56022: LD_VAR 0 2
56026: PPUSH
56027: LD_INT 1
56029: PPUSH
56030: CALL_OW 273
56034: ST_TO_ADDR
// if ValidHex ( x , y ) then
56035: LD_VAR 0 4
56039: PPUSH
56040: LD_VAR 0 5
56044: PPUSH
56045: CALL_OW 488
56049: IFFALSE 56070
// ComTurnXY ( unit , x , y ) ;
56051: LD_VAR 0 1
56055: PPUSH
56056: LD_VAR 0 4
56060: PPUSH
56061: LD_VAR 0 5
56065: PPUSH
56066: CALL_OW 118
// end ;
56070: LD_VAR 0 3
56074: RET
// export function SeeUnits ( side , units ) ; var i ; begin
56075: LD_INT 0
56077: PPUSH
56078: PPUSH
// result := false ;
56079: LD_ADDR_VAR 0 3
56083: PUSH
56084: LD_INT 0
56086: ST_TO_ADDR
// if not units then
56087: LD_VAR 0 2
56091: NOT
56092: IFFALSE 56096
// exit ;
56094: GO 56141
// for i in units do
56096: LD_ADDR_VAR 0 4
56100: PUSH
56101: LD_VAR 0 2
56105: PUSH
56106: FOR_IN
56107: IFFALSE 56139
// if See ( side , i ) then
56109: LD_VAR 0 1
56113: PPUSH
56114: LD_VAR 0 4
56118: PPUSH
56119: CALL_OW 292
56123: IFFALSE 56137
// begin result := true ;
56125: LD_ADDR_VAR 0 3
56129: PUSH
56130: LD_INT 1
56132: ST_TO_ADDR
// exit ;
56133: POP
56134: POP
56135: GO 56141
// end ;
56137: GO 56106
56139: POP
56140: POP
// end ;
56141: LD_VAR 0 3
56145: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
56146: LD_INT 0
56148: PPUSH
56149: PPUSH
56150: PPUSH
56151: PPUSH
// if not unit or not points then
56152: LD_VAR 0 1
56156: NOT
56157: PUSH
56158: LD_VAR 0 2
56162: NOT
56163: OR
56164: IFFALSE 56168
// exit ;
56166: GO 56258
// dist := 99999 ;
56168: LD_ADDR_VAR 0 5
56172: PUSH
56173: LD_INT 99999
56175: ST_TO_ADDR
// for i in points do
56176: LD_ADDR_VAR 0 4
56180: PUSH
56181: LD_VAR 0 2
56185: PUSH
56186: FOR_IN
56187: IFFALSE 56256
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
56189: LD_ADDR_VAR 0 6
56193: PUSH
56194: LD_VAR 0 1
56198: PPUSH
56199: LD_VAR 0 4
56203: PUSH
56204: LD_INT 1
56206: ARRAY
56207: PPUSH
56208: LD_VAR 0 4
56212: PUSH
56213: LD_INT 2
56215: ARRAY
56216: PPUSH
56217: CALL_OW 297
56221: ST_TO_ADDR
// if tmpDist < dist then
56222: LD_VAR 0 6
56226: PUSH
56227: LD_VAR 0 5
56231: LESS
56232: IFFALSE 56254
// begin result := i ;
56234: LD_ADDR_VAR 0 3
56238: PUSH
56239: LD_VAR 0 4
56243: ST_TO_ADDR
// dist := tmpDist ;
56244: LD_ADDR_VAR 0 5
56248: PUSH
56249: LD_VAR 0 6
56253: ST_TO_ADDR
// end ; end ;
56254: GO 56186
56256: POP
56257: POP
// end ;
56258: LD_VAR 0 3
56262: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
56263: LD_INT 0
56265: PPUSH
// uc_side := side ;
56266: LD_ADDR_OWVAR 20
56270: PUSH
56271: LD_VAR 0 1
56275: ST_TO_ADDR
// uc_nation := 3 ;
56276: LD_ADDR_OWVAR 21
56280: PUSH
56281: LD_INT 3
56283: ST_TO_ADDR
// vc_chassis := 25 ;
56284: LD_ADDR_OWVAR 37
56288: PUSH
56289: LD_INT 25
56291: ST_TO_ADDR
// vc_engine := engine_siberite ;
56292: LD_ADDR_OWVAR 39
56296: PUSH
56297: LD_INT 3
56299: ST_TO_ADDR
// vc_control := control_computer ;
56300: LD_ADDR_OWVAR 38
56304: PUSH
56305: LD_INT 3
56307: ST_TO_ADDR
// vc_weapon := 59 ;
56308: LD_ADDR_OWVAR 40
56312: PUSH
56313: LD_INT 59
56315: ST_TO_ADDR
// result := CreateVehicle ;
56316: LD_ADDR_VAR 0 5
56320: PUSH
56321: CALL_OW 45
56325: ST_TO_ADDR
// SetDir ( result , d ) ;
56326: LD_VAR 0 5
56330: PPUSH
56331: LD_VAR 0 4
56335: PPUSH
56336: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
56340: LD_VAR 0 5
56344: PPUSH
56345: LD_VAR 0 2
56349: PPUSH
56350: LD_VAR 0 3
56354: PPUSH
56355: LD_INT 0
56357: PPUSH
56358: CALL_OW 48
// end ;
56362: LD_VAR 0 5
56366: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
56367: LD_INT 0
56369: PPUSH
56370: PPUSH
56371: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
56372: LD_ADDR_VAR 0 2
56376: PUSH
56377: LD_INT 0
56379: PUSH
56380: LD_INT 0
56382: PUSH
56383: LD_INT 0
56385: PUSH
56386: LD_INT 0
56388: PUSH
56389: EMPTY
56390: LIST
56391: LIST
56392: LIST
56393: LIST
56394: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
56395: LD_VAR 0 1
56399: NOT
56400: PUSH
56401: LD_VAR 0 1
56405: PPUSH
56406: CALL_OW 264
56410: PUSH
56411: LD_INT 12
56413: PUSH
56414: LD_INT 51
56416: PUSH
56417: LD_INT 32
56419: PUSH
56420: LD_INT 89
56422: PUSH
56423: EMPTY
56424: LIST
56425: LIST
56426: LIST
56427: LIST
56428: IN
56429: NOT
56430: OR
56431: IFFALSE 56435
// exit ;
56433: GO 56533
// for i := 1 to 3 do
56435: LD_ADDR_VAR 0 3
56439: PUSH
56440: DOUBLE
56441: LD_INT 1
56443: DEC
56444: ST_TO_ADDR
56445: LD_INT 3
56447: PUSH
56448: FOR_TO
56449: IFFALSE 56531
// begin tmp := GetCargo ( cargo , i ) ;
56451: LD_ADDR_VAR 0 4
56455: PUSH
56456: LD_VAR 0 1
56460: PPUSH
56461: LD_VAR 0 3
56465: PPUSH
56466: CALL_OW 289
56470: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
56471: LD_ADDR_VAR 0 2
56475: PUSH
56476: LD_VAR 0 2
56480: PPUSH
56481: LD_VAR 0 3
56485: PPUSH
56486: LD_VAR 0 4
56490: PPUSH
56491: CALL_OW 1
56495: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
56496: LD_ADDR_VAR 0 2
56500: PUSH
56501: LD_VAR 0 2
56505: PPUSH
56506: LD_INT 4
56508: PPUSH
56509: LD_VAR 0 2
56513: PUSH
56514: LD_INT 4
56516: ARRAY
56517: PUSH
56518: LD_VAR 0 4
56522: PLUS
56523: PPUSH
56524: CALL_OW 1
56528: ST_TO_ADDR
// end ;
56529: GO 56448
56531: POP
56532: POP
// end ;
56533: LD_VAR 0 2
56537: RET
// export function Length ( array ) ; begin
56538: LD_INT 0
56540: PPUSH
// result := array + 0 ;
56541: LD_ADDR_VAR 0 2
56545: PUSH
56546: LD_VAR 0 1
56550: PUSH
56551: LD_INT 0
56553: PLUS
56554: ST_TO_ADDR
// end ;
56555: LD_VAR 0 2
56559: RET
// export function PrepareArray ( array ) ; begin
56560: LD_INT 0
56562: PPUSH
// result := array diff 0 ;
56563: LD_ADDR_VAR 0 2
56567: PUSH
56568: LD_VAR 0 1
56572: PUSH
56573: LD_INT 0
56575: DIFF
56576: ST_TO_ADDR
// if not result [ 1 ] then
56577: LD_VAR 0 2
56581: PUSH
56582: LD_INT 1
56584: ARRAY
56585: NOT
56586: IFFALSE 56606
// result := Delete ( result , 1 ) ;
56588: LD_ADDR_VAR 0 2
56592: PUSH
56593: LD_VAR 0 2
56597: PPUSH
56598: LD_INT 1
56600: PPUSH
56601: CALL_OW 3
56605: ST_TO_ADDR
// end ;
56606: LD_VAR 0 2
56610: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
56611: LD_INT 0
56613: PPUSH
56614: PPUSH
56615: PPUSH
56616: PPUSH
// sibRocketRange := 25 ;
56617: LD_ADDR_VAR 0 6
56621: PUSH
56622: LD_INT 25
56624: ST_TO_ADDR
// result := false ;
56625: LD_ADDR_VAR 0 4
56629: PUSH
56630: LD_INT 0
56632: ST_TO_ADDR
// for i := 0 to 5 do
56633: LD_ADDR_VAR 0 5
56637: PUSH
56638: DOUBLE
56639: LD_INT 0
56641: DEC
56642: ST_TO_ADDR
56643: LD_INT 5
56645: PUSH
56646: FOR_TO
56647: IFFALSE 56714
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
56649: LD_VAR 0 1
56653: PPUSH
56654: LD_VAR 0 5
56658: PPUSH
56659: LD_VAR 0 6
56663: PPUSH
56664: CALL_OW 272
56668: PPUSH
56669: LD_VAR 0 2
56673: PPUSH
56674: LD_VAR 0 5
56678: PPUSH
56679: LD_VAR 0 6
56683: PPUSH
56684: CALL_OW 273
56688: PPUSH
56689: LD_VAR 0 3
56693: PPUSH
56694: CALL_OW 309
56698: IFFALSE 56712
// begin result := true ;
56700: LD_ADDR_VAR 0 4
56704: PUSH
56705: LD_INT 1
56707: ST_TO_ADDR
// exit ;
56708: POP
56709: POP
56710: GO 56716
// end ;
56712: GO 56646
56714: POP
56715: POP
// end ;
56716: LD_VAR 0 4
56720: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
56721: LD_INT 0
56723: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
56724: LD_VAR 0 1
56728: PPUSH
56729: LD_VAR 0 2
56733: PPUSH
56734: LD_INT 0
56736: PPUSH
56737: LD_INT 0
56739: PPUSH
56740: LD_INT 1
56742: PPUSH
56743: LD_INT 0
56745: PPUSH
56746: CALL_OW 587
// end ;
56750: LD_VAR 0 3
56754: RET
// export function CenterOnNow ( unit ) ; begin
56755: LD_INT 0
56757: PPUSH
// result := IsInUnit ( unit ) ;
56758: LD_ADDR_VAR 0 2
56762: PUSH
56763: LD_VAR 0 1
56767: PPUSH
56768: CALL_OW 310
56772: ST_TO_ADDR
// if not result then
56773: LD_VAR 0 2
56777: NOT
56778: IFFALSE 56790
// result := unit ;
56780: LD_ADDR_VAR 0 2
56784: PUSH
56785: LD_VAR 0 1
56789: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
56790: LD_VAR 0 1
56794: PPUSH
56795: CALL_OW 87
// end ;
56799: LD_VAR 0 2
56803: RET
// export function ComMoveHex ( unit , hex ) ; begin
56804: LD_INT 0
56806: PPUSH
// if not hex then
56807: LD_VAR 0 2
56811: NOT
56812: IFFALSE 56816
// exit ;
56814: GO 56869
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
56816: LD_VAR 0 2
56820: PUSH
56821: LD_INT 1
56823: ARRAY
56824: PPUSH
56825: LD_VAR 0 2
56829: PUSH
56830: LD_INT 2
56832: ARRAY
56833: PPUSH
56834: CALL_OW 428
56838: IFFALSE 56842
// exit ;
56840: GO 56869
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
56842: LD_VAR 0 1
56846: PPUSH
56847: LD_VAR 0 2
56851: PUSH
56852: LD_INT 1
56854: ARRAY
56855: PPUSH
56856: LD_VAR 0 2
56860: PUSH
56861: LD_INT 2
56863: ARRAY
56864: PPUSH
56865: CALL_OW 111
// end ;
56869: LD_VAR 0 3
56873: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
56874: LD_INT 0
56876: PPUSH
56877: PPUSH
56878: PPUSH
// if not unit or not enemy then
56879: LD_VAR 0 1
56883: NOT
56884: PUSH
56885: LD_VAR 0 2
56889: NOT
56890: OR
56891: IFFALSE 56895
// exit ;
56893: GO 57012
// x := GetX ( enemy ) ;
56895: LD_ADDR_VAR 0 4
56899: PUSH
56900: LD_VAR 0 2
56904: PPUSH
56905: CALL_OW 250
56909: ST_TO_ADDR
// y := GetY ( enemy ) ;
56910: LD_ADDR_VAR 0 5
56914: PUSH
56915: LD_VAR 0 2
56919: PPUSH
56920: CALL_OW 251
56924: ST_TO_ADDR
// if ValidHex ( x , y ) then
56925: LD_VAR 0 4
56929: PPUSH
56930: LD_VAR 0 5
56934: PPUSH
56935: CALL_OW 488
56939: IFFALSE 57012
// if GetType ( enemy ) = unit_building and See ( GetSide ( unit ) , enemy ) then
56941: LD_VAR 0 2
56945: PPUSH
56946: CALL_OW 247
56950: PUSH
56951: LD_INT 3
56953: EQUAL
56954: PUSH
56955: LD_VAR 0 1
56959: PPUSH
56960: CALL_OW 255
56964: PPUSH
56965: LD_VAR 0 2
56969: PPUSH
56970: CALL_OW 292
56974: AND
56975: IFFALSE 56993
// ComAttackUnit ( unit , enemy ) else
56977: LD_VAR 0 1
56981: PPUSH
56982: LD_VAR 0 2
56986: PPUSH
56987: CALL_OW 115
56991: GO 57012
// ComAgressiveMove ( unit , x , y ) ;
56993: LD_VAR 0 1
56997: PPUSH
56998: LD_VAR 0 4
57002: PPUSH
57003: LD_VAR 0 5
57007: PPUSH
57008: CALL_OW 114
// end ; end_of_file
57012: LD_VAR 0 3
57016: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
57017: LD_INT 0
57019: PPUSH
57020: PPUSH
// skirmish := false ;
57021: LD_ADDR_EXP 59
57025: PUSH
57026: LD_INT 0
57028: ST_TO_ADDR
// debug_mc := false ;
57029: LD_ADDR_EXP 60
57033: PUSH
57034: LD_INT 0
57036: ST_TO_ADDR
// mc_bases := [ ] ;
57037: LD_ADDR_EXP 61
57041: PUSH
57042: EMPTY
57043: ST_TO_ADDR
// mc_sides := [ ] ;
57044: LD_ADDR_EXP 87
57048: PUSH
57049: EMPTY
57050: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57051: LD_ADDR_EXP 62
57055: PUSH
57056: EMPTY
57057: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57058: LD_ADDR_EXP 63
57062: PUSH
57063: EMPTY
57064: ST_TO_ADDR
// mc_need_heal := [ ] ;
57065: LD_ADDR_EXP 64
57069: PUSH
57070: EMPTY
57071: ST_TO_ADDR
// mc_healers := [ ] ;
57072: LD_ADDR_EXP 65
57076: PUSH
57077: EMPTY
57078: ST_TO_ADDR
// mc_build_list := [ ] ;
57079: LD_ADDR_EXP 66
57083: PUSH
57084: EMPTY
57085: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57086: LD_ADDR_EXP 93
57090: PUSH
57091: EMPTY
57092: ST_TO_ADDR
// mc_builders := [ ] ;
57093: LD_ADDR_EXP 67
57097: PUSH
57098: EMPTY
57099: ST_TO_ADDR
// mc_construct_list := [ ] ;
57100: LD_ADDR_EXP 68
57104: PUSH
57105: EMPTY
57106: ST_TO_ADDR
// mc_turret_list := [ ] ;
57107: LD_ADDR_EXP 69
57111: PUSH
57112: EMPTY
57113: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57114: LD_ADDR_EXP 70
57118: PUSH
57119: EMPTY
57120: ST_TO_ADDR
// mc_miners := [ ] ;
57121: LD_ADDR_EXP 75
57125: PUSH
57126: EMPTY
57127: ST_TO_ADDR
// mc_mines := [ ] ;
57128: LD_ADDR_EXP 74
57132: PUSH
57133: EMPTY
57134: ST_TO_ADDR
// mc_minefields := [ ] ;
57135: LD_ADDR_EXP 76
57139: PUSH
57140: EMPTY
57141: ST_TO_ADDR
// mc_crates := [ ] ;
57142: LD_ADDR_EXP 77
57146: PUSH
57147: EMPTY
57148: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57149: LD_ADDR_EXP 78
57153: PUSH
57154: EMPTY
57155: ST_TO_ADDR
// mc_crates_area := [ ] ;
57156: LD_ADDR_EXP 79
57160: PUSH
57161: EMPTY
57162: ST_TO_ADDR
// mc_vehicles := [ ] ;
57163: LD_ADDR_EXP 80
57167: PUSH
57168: EMPTY
57169: ST_TO_ADDR
// mc_attack := [ ] ;
57170: LD_ADDR_EXP 81
57174: PUSH
57175: EMPTY
57176: ST_TO_ADDR
// mc_produce := [ ] ;
57177: LD_ADDR_EXP 82
57181: PUSH
57182: EMPTY
57183: ST_TO_ADDR
// mc_defender := [ ] ;
57184: LD_ADDR_EXP 83
57188: PUSH
57189: EMPTY
57190: ST_TO_ADDR
// mc_parking := [ ] ;
57191: LD_ADDR_EXP 85
57195: PUSH
57196: EMPTY
57197: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57198: LD_ADDR_EXP 71
57202: PUSH
57203: EMPTY
57204: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57205: LD_ADDR_EXP 73
57209: PUSH
57210: EMPTY
57211: ST_TO_ADDR
// mc_scan := [ ] ;
57212: LD_ADDR_EXP 84
57216: PUSH
57217: EMPTY
57218: ST_TO_ADDR
// mc_scan_area := [ ] ;
57219: LD_ADDR_EXP 86
57223: PUSH
57224: EMPTY
57225: ST_TO_ADDR
// mc_tech := [ ] ;
57226: LD_ADDR_EXP 88
57230: PUSH
57231: EMPTY
57232: ST_TO_ADDR
// mc_class := [ ] ;
57233: LD_ADDR_EXP 102
57237: PUSH
57238: EMPTY
57239: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57240: LD_ADDR_EXP 103
57244: PUSH
57245: EMPTY
57246: ST_TO_ADDR
// mc_is_defending := [ ] ;
57247: LD_ADDR_EXP 104
57251: PUSH
57252: EMPTY
57253: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
57254: LD_ADDR_EXP 95
57258: PUSH
57259: EMPTY
57260: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
57261: LD_ADDR_EXP 105
57265: PUSH
57266: LD_INT 0
57268: ST_TO_ADDR
// end ;
57269: LD_VAR 0 1
57273: RET
// export function MC_Kill ( base ) ; begin
57274: LD_INT 0
57276: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57277: LD_ADDR_EXP 61
57281: PUSH
57282: LD_EXP 61
57286: PPUSH
57287: LD_VAR 0 1
57291: PPUSH
57292: EMPTY
57293: PPUSH
57294: CALL_OW 1
57298: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57299: LD_ADDR_EXP 62
57303: PUSH
57304: LD_EXP 62
57308: PPUSH
57309: LD_VAR 0 1
57313: PPUSH
57314: EMPTY
57315: PPUSH
57316: CALL_OW 1
57320: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57321: LD_ADDR_EXP 63
57325: PUSH
57326: LD_EXP 63
57330: PPUSH
57331: LD_VAR 0 1
57335: PPUSH
57336: EMPTY
57337: PPUSH
57338: CALL_OW 1
57342: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57343: LD_ADDR_EXP 64
57347: PUSH
57348: LD_EXP 64
57352: PPUSH
57353: LD_VAR 0 1
57357: PPUSH
57358: EMPTY
57359: PPUSH
57360: CALL_OW 1
57364: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57365: LD_ADDR_EXP 65
57369: PUSH
57370: LD_EXP 65
57374: PPUSH
57375: LD_VAR 0 1
57379: PPUSH
57380: EMPTY
57381: PPUSH
57382: CALL_OW 1
57386: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57387: LD_ADDR_EXP 66
57391: PUSH
57392: LD_EXP 66
57396: PPUSH
57397: LD_VAR 0 1
57401: PPUSH
57402: EMPTY
57403: PPUSH
57404: CALL_OW 1
57408: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57409: LD_ADDR_EXP 67
57413: PUSH
57414: LD_EXP 67
57418: PPUSH
57419: LD_VAR 0 1
57423: PPUSH
57424: EMPTY
57425: PPUSH
57426: CALL_OW 1
57430: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57431: LD_ADDR_EXP 68
57435: PUSH
57436: LD_EXP 68
57440: PPUSH
57441: LD_VAR 0 1
57445: PPUSH
57446: EMPTY
57447: PPUSH
57448: CALL_OW 1
57452: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57453: LD_ADDR_EXP 69
57457: PUSH
57458: LD_EXP 69
57462: PPUSH
57463: LD_VAR 0 1
57467: PPUSH
57468: EMPTY
57469: PPUSH
57470: CALL_OW 1
57474: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57475: LD_ADDR_EXP 70
57479: PUSH
57480: LD_EXP 70
57484: PPUSH
57485: LD_VAR 0 1
57489: PPUSH
57490: EMPTY
57491: PPUSH
57492: CALL_OW 1
57496: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57497: LD_ADDR_EXP 71
57501: PUSH
57502: LD_EXP 71
57506: PPUSH
57507: LD_VAR 0 1
57511: PPUSH
57512: EMPTY
57513: PPUSH
57514: CALL_OW 1
57518: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57519: LD_ADDR_EXP 72
57523: PUSH
57524: LD_EXP 72
57528: PPUSH
57529: LD_VAR 0 1
57533: PPUSH
57534: LD_INT 0
57536: PPUSH
57537: CALL_OW 1
57541: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57542: LD_ADDR_EXP 73
57546: PUSH
57547: LD_EXP 73
57551: PPUSH
57552: LD_VAR 0 1
57556: PPUSH
57557: EMPTY
57558: PPUSH
57559: CALL_OW 1
57563: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57564: LD_ADDR_EXP 74
57568: PUSH
57569: LD_EXP 74
57573: PPUSH
57574: LD_VAR 0 1
57578: PPUSH
57579: EMPTY
57580: PPUSH
57581: CALL_OW 1
57585: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57586: LD_ADDR_EXP 75
57590: PUSH
57591: LD_EXP 75
57595: PPUSH
57596: LD_VAR 0 1
57600: PPUSH
57601: EMPTY
57602: PPUSH
57603: CALL_OW 1
57607: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57608: LD_ADDR_EXP 76
57612: PUSH
57613: LD_EXP 76
57617: PPUSH
57618: LD_VAR 0 1
57622: PPUSH
57623: EMPTY
57624: PPUSH
57625: CALL_OW 1
57629: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57630: LD_ADDR_EXP 77
57634: PUSH
57635: LD_EXP 77
57639: PPUSH
57640: LD_VAR 0 1
57644: PPUSH
57645: EMPTY
57646: PPUSH
57647: CALL_OW 1
57651: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57652: LD_ADDR_EXP 78
57656: PUSH
57657: LD_EXP 78
57661: PPUSH
57662: LD_VAR 0 1
57666: PPUSH
57667: EMPTY
57668: PPUSH
57669: CALL_OW 1
57673: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57674: LD_ADDR_EXP 79
57678: PUSH
57679: LD_EXP 79
57683: PPUSH
57684: LD_VAR 0 1
57688: PPUSH
57689: EMPTY
57690: PPUSH
57691: CALL_OW 1
57695: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57696: LD_ADDR_EXP 80
57700: PUSH
57701: LD_EXP 80
57705: PPUSH
57706: LD_VAR 0 1
57710: PPUSH
57711: EMPTY
57712: PPUSH
57713: CALL_OW 1
57717: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57718: LD_ADDR_EXP 81
57722: PUSH
57723: LD_EXP 81
57727: PPUSH
57728: LD_VAR 0 1
57732: PPUSH
57733: EMPTY
57734: PPUSH
57735: CALL_OW 1
57739: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57740: LD_ADDR_EXP 82
57744: PUSH
57745: LD_EXP 82
57749: PPUSH
57750: LD_VAR 0 1
57754: PPUSH
57755: EMPTY
57756: PPUSH
57757: CALL_OW 1
57761: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57762: LD_ADDR_EXP 83
57766: PUSH
57767: LD_EXP 83
57771: PPUSH
57772: LD_VAR 0 1
57776: PPUSH
57777: EMPTY
57778: PPUSH
57779: CALL_OW 1
57783: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57784: LD_ADDR_EXP 84
57788: PUSH
57789: LD_EXP 84
57793: PPUSH
57794: LD_VAR 0 1
57798: PPUSH
57799: EMPTY
57800: PPUSH
57801: CALL_OW 1
57805: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57806: LD_ADDR_EXP 85
57810: PUSH
57811: LD_EXP 85
57815: PPUSH
57816: LD_VAR 0 1
57820: PPUSH
57821: EMPTY
57822: PPUSH
57823: CALL_OW 1
57827: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57828: LD_ADDR_EXP 86
57832: PUSH
57833: LD_EXP 86
57837: PPUSH
57838: LD_VAR 0 1
57842: PPUSH
57843: EMPTY
57844: PPUSH
57845: CALL_OW 1
57849: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
57850: LD_ADDR_EXP 88
57854: PUSH
57855: LD_EXP 88
57859: PPUSH
57860: LD_VAR 0 1
57864: PPUSH
57865: EMPTY
57866: PPUSH
57867: CALL_OW 1
57871: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
57872: LD_ADDR_EXP 90
57876: PUSH
57877: LD_EXP 90
57881: PPUSH
57882: LD_VAR 0 1
57886: PPUSH
57887: EMPTY
57888: PPUSH
57889: CALL_OW 1
57893: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
57894: LD_ADDR_EXP 91
57898: PUSH
57899: LD_EXP 91
57903: PPUSH
57904: LD_VAR 0 1
57908: PPUSH
57909: EMPTY
57910: PPUSH
57911: CALL_OW 1
57915: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
57916: LD_ADDR_EXP 92
57920: PUSH
57921: LD_EXP 92
57925: PPUSH
57926: LD_VAR 0 1
57930: PPUSH
57931: EMPTY
57932: PPUSH
57933: CALL_OW 1
57937: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
57938: LD_ADDR_EXP 93
57942: PUSH
57943: LD_EXP 93
57947: PPUSH
57948: LD_VAR 0 1
57952: PPUSH
57953: EMPTY
57954: PPUSH
57955: CALL_OW 1
57959: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
57960: LD_ADDR_EXP 94
57964: PUSH
57965: LD_EXP 94
57969: PPUSH
57970: LD_VAR 0 1
57974: PPUSH
57975: EMPTY
57976: PPUSH
57977: CALL_OW 1
57981: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
57982: LD_ADDR_EXP 95
57986: PUSH
57987: LD_EXP 95
57991: PPUSH
57992: LD_VAR 0 1
57996: PPUSH
57997: EMPTY
57998: PPUSH
57999: CALL_OW 1
58003: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58004: LD_ADDR_EXP 96
58008: PUSH
58009: LD_EXP 96
58013: PPUSH
58014: LD_VAR 0 1
58018: PPUSH
58019: EMPTY
58020: PPUSH
58021: CALL_OW 1
58025: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58026: LD_ADDR_EXP 97
58030: PUSH
58031: LD_EXP 97
58035: PPUSH
58036: LD_VAR 0 1
58040: PPUSH
58041: EMPTY
58042: PPUSH
58043: CALL_OW 1
58047: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58048: LD_ADDR_EXP 98
58052: PUSH
58053: LD_EXP 98
58057: PPUSH
58058: LD_VAR 0 1
58062: PPUSH
58063: EMPTY
58064: PPUSH
58065: CALL_OW 1
58069: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58070: LD_ADDR_EXP 99
58074: PUSH
58075: LD_EXP 99
58079: PPUSH
58080: LD_VAR 0 1
58084: PPUSH
58085: EMPTY
58086: PPUSH
58087: CALL_OW 1
58091: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58092: LD_ADDR_EXP 100
58096: PUSH
58097: LD_EXP 100
58101: PPUSH
58102: LD_VAR 0 1
58106: PPUSH
58107: EMPTY
58108: PPUSH
58109: CALL_OW 1
58113: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58114: LD_ADDR_EXP 101
58118: PUSH
58119: LD_EXP 101
58123: PPUSH
58124: LD_VAR 0 1
58128: PPUSH
58129: EMPTY
58130: PPUSH
58131: CALL_OW 1
58135: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58136: LD_ADDR_EXP 102
58140: PUSH
58141: LD_EXP 102
58145: PPUSH
58146: LD_VAR 0 1
58150: PPUSH
58151: EMPTY
58152: PPUSH
58153: CALL_OW 1
58157: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58158: LD_ADDR_EXP 103
58162: PUSH
58163: LD_EXP 103
58167: PPUSH
58168: LD_VAR 0 1
58172: PPUSH
58173: LD_INT 0
58175: PPUSH
58176: CALL_OW 1
58180: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
58181: LD_ADDR_EXP 104
58185: PUSH
58186: LD_EXP 104
58190: PPUSH
58191: LD_VAR 0 1
58195: PPUSH
58196: LD_INT 0
58198: PPUSH
58199: CALL_OW 1
58203: ST_TO_ADDR
// end ;
58204: LD_VAR 0 2
58208: RET
// export function MC_Add ( side , units ) ; var base ; begin
58209: LD_INT 0
58211: PPUSH
58212: PPUSH
// base := mc_bases + 1 ;
58213: LD_ADDR_VAR 0 4
58217: PUSH
58218: LD_EXP 61
58222: PUSH
58223: LD_INT 1
58225: PLUS
58226: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58227: LD_ADDR_EXP 87
58231: PUSH
58232: LD_EXP 87
58236: PPUSH
58237: LD_VAR 0 4
58241: PPUSH
58242: LD_VAR 0 1
58246: PPUSH
58247: CALL_OW 1
58251: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58252: LD_ADDR_EXP 61
58256: PUSH
58257: LD_EXP 61
58261: PPUSH
58262: LD_VAR 0 4
58266: PPUSH
58267: LD_VAR 0 2
58271: PPUSH
58272: CALL_OW 1
58276: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58277: LD_ADDR_EXP 62
58281: PUSH
58282: LD_EXP 62
58286: PPUSH
58287: LD_VAR 0 4
58291: PPUSH
58292: EMPTY
58293: PPUSH
58294: CALL_OW 1
58298: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58299: LD_ADDR_EXP 63
58303: PUSH
58304: LD_EXP 63
58308: PPUSH
58309: LD_VAR 0 4
58313: PPUSH
58314: EMPTY
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58321: LD_ADDR_EXP 64
58325: PUSH
58326: LD_EXP 64
58330: PPUSH
58331: LD_VAR 0 4
58335: PPUSH
58336: EMPTY
58337: PPUSH
58338: CALL_OW 1
58342: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58343: LD_ADDR_EXP 65
58347: PUSH
58348: LD_EXP 65
58352: PPUSH
58353: LD_VAR 0 4
58357: PPUSH
58358: EMPTY
58359: PPUSH
58360: CALL_OW 1
58364: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58365: LD_ADDR_EXP 66
58369: PUSH
58370: LD_EXP 66
58374: PPUSH
58375: LD_VAR 0 4
58379: PPUSH
58380: EMPTY
58381: PPUSH
58382: CALL_OW 1
58386: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58387: LD_ADDR_EXP 67
58391: PUSH
58392: LD_EXP 67
58396: PPUSH
58397: LD_VAR 0 4
58401: PPUSH
58402: EMPTY
58403: PPUSH
58404: CALL_OW 1
58408: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58409: LD_ADDR_EXP 68
58413: PUSH
58414: LD_EXP 68
58418: PPUSH
58419: LD_VAR 0 4
58423: PPUSH
58424: EMPTY
58425: PPUSH
58426: CALL_OW 1
58430: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58431: LD_ADDR_EXP 69
58435: PUSH
58436: LD_EXP 69
58440: PPUSH
58441: LD_VAR 0 4
58445: PPUSH
58446: EMPTY
58447: PPUSH
58448: CALL_OW 1
58452: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58453: LD_ADDR_EXP 70
58457: PUSH
58458: LD_EXP 70
58462: PPUSH
58463: LD_VAR 0 4
58467: PPUSH
58468: EMPTY
58469: PPUSH
58470: CALL_OW 1
58474: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58475: LD_ADDR_EXP 71
58479: PUSH
58480: LD_EXP 71
58484: PPUSH
58485: LD_VAR 0 4
58489: PPUSH
58490: EMPTY
58491: PPUSH
58492: CALL_OW 1
58496: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58497: LD_ADDR_EXP 72
58501: PUSH
58502: LD_EXP 72
58506: PPUSH
58507: LD_VAR 0 4
58511: PPUSH
58512: LD_INT 0
58514: PPUSH
58515: CALL_OW 1
58519: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58520: LD_ADDR_EXP 73
58524: PUSH
58525: LD_EXP 73
58529: PPUSH
58530: LD_VAR 0 4
58534: PPUSH
58535: EMPTY
58536: PPUSH
58537: CALL_OW 1
58541: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58542: LD_ADDR_EXP 74
58546: PUSH
58547: LD_EXP 74
58551: PPUSH
58552: LD_VAR 0 4
58556: PPUSH
58557: EMPTY
58558: PPUSH
58559: CALL_OW 1
58563: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58564: LD_ADDR_EXP 75
58568: PUSH
58569: LD_EXP 75
58573: PPUSH
58574: LD_VAR 0 4
58578: PPUSH
58579: EMPTY
58580: PPUSH
58581: CALL_OW 1
58585: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58586: LD_ADDR_EXP 76
58590: PUSH
58591: LD_EXP 76
58595: PPUSH
58596: LD_VAR 0 4
58600: PPUSH
58601: EMPTY
58602: PPUSH
58603: CALL_OW 1
58607: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58608: LD_ADDR_EXP 77
58612: PUSH
58613: LD_EXP 77
58617: PPUSH
58618: LD_VAR 0 4
58622: PPUSH
58623: EMPTY
58624: PPUSH
58625: CALL_OW 1
58629: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58630: LD_ADDR_EXP 78
58634: PUSH
58635: LD_EXP 78
58639: PPUSH
58640: LD_VAR 0 4
58644: PPUSH
58645: EMPTY
58646: PPUSH
58647: CALL_OW 1
58651: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58652: LD_ADDR_EXP 79
58656: PUSH
58657: LD_EXP 79
58661: PPUSH
58662: LD_VAR 0 4
58666: PPUSH
58667: EMPTY
58668: PPUSH
58669: CALL_OW 1
58673: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58674: LD_ADDR_EXP 80
58678: PUSH
58679: LD_EXP 80
58683: PPUSH
58684: LD_VAR 0 4
58688: PPUSH
58689: EMPTY
58690: PPUSH
58691: CALL_OW 1
58695: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58696: LD_ADDR_EXP 81
58700: PUSH
58701: LD_EXP 81
58705: PPUSH
58706: LD_VAR 0 4
58710: PPUSH
58711: EMPTY
58712: PPUSH
58713: CALL_OW 1
58717: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58718: LD_ADDR_EXP 82
58722: PUSH
58723: LD_EXP 82
58727: PPUSH
58728: LD_VAR 0 4
58732: PPUSH
58733: EMPTY
58734: PPUSH
58735: CALL_OW 1
58739: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58740: LD_ADDR_EXP 83
58744: PUSH
58745: LD_EXP 83
58749: PPUSH
58750: LD_VAR 0 4
58754: PPUSH
58755: EMPTY
58756: PPUSH
58757: CALL_OW 1
58761: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58762: LD_ADDR_EXP 84
58766: PUSH
58767: LD_EXP 84
58771: PPUSH
58772: LD_VAR 0 4
58776: PPUSH
58777: EMPTY
58778: PPUSH
58779: CALL_OW 1
58783: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58784: LD_ADDR_EXP 85
58788: PUSH
58789: LD_EXP 85
58793: PPUSH
58794: LD_VAR 0 4
58798: PPUSH
58799: EMPTY
58800: PPUSH
58801: CALL_OW 1
58805: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58806: LD_ADDR_EXP 86
58810: PUSH
58811: LD_EXP 86
58815: PPUSH
58816: LD_VAR 0 4
58820: PPUSH
58821: EMPTY
58822: PPUSH
58823: CALL_OW 1
58827: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58828: LD_ADDR_EXP 88
58832: PUSH
58833: LD_EXP 88
58837: PPUSH
58838: LD_VAR 0 4
58842: PPUSH
58843: EMPTY
58844: PPUSH
58845: CALL_OW 1
58849: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58850: LD_ADDR_EXP 90
58854: PUSH
58855: LD_EXP 90
58859: PPUSH
58860: LD_VAR 0 4
58864: PPUSH
58865: EMPTY
58866: PPUSH
58867: CALL_OW 1
58871: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58872: LD_ADDR_EXP 91
58876: PUSH
58877: LD_EXP 91
58881: PPUSH
58882: LD_VAR 0 4
58886: PPUSH
58887: EMPTY
58888: PPUSH
58889: CALL_OW 1
58893: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58894: LD_ADDR_EXP 92
58898: PUSH
58899: LD_EXP 92
58903: PPUSH
58904: LD_VAR 0 4
58908: PPUSH
58909: EMPTY
58910: PPUSH
58911: CALL_OW 1
58915: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58916: LD_ADDR_EXP 93
58920: PUSH
58921: LD_EXP 93
58925: PPUSH
58926: LD_VAR 0 4
58930: PPUSH
58931: EMPTY
58932: PPUSH
58933: CALL_OW 1
58937: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58938: LD_ADDR_EXP 94
58942: PUSH
58943: LD_EXP 94
58947: PPUSH
58948: LD_VAR 0 4
58952: PPUSH
58953: EMPTY
58954: PPUSH
58955: CALL_OW 1
58959: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58960: LD_ADDR_EXP 95
58964: PUSH
58965: LD_EXP 95
58969: PPUSH
58970: LD_VAR 0 4
58974: PPUSH
58975: EMPTY
58976: PPUSH
58977: CALL_OW 1
58981: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58982: LD_ADDR_EXP 96
58986: PUSH
58987: LD_EXP 96
58991: PPUSH
58992: LD_VAR 0 4
58996: PPUSH
58997: EMPTY
58998: PPUSH
58999: CALL_OW 1
59003: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59004: LD_ADDR_EXP 97
59008: PUSH
59009: LD_EXP 97
59013: PPUSH
59014: LD_VAR 0 4
59018: PPUSH
59019: EMPTY
59020: PPUSH
59021: CALL_OW 1
59025: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59026: LD_ADDR_EXP 98
59030: PUSH
59031: LD_EXP 98
59035: PPUSH
59036: LD_VAR 0 4
59040: PPUSH
59041: EMPTY
59042: PPUSH
59043: CALL_OW 1
59047: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59048: LD_ADDR_EXP 99
59052: PUSH
59053: LD_EXP 99
59057: PPUSH
59058: LD_VAR 0 4
59062: PPUSH
59063: EMPTY
59064: PPUSH
59065: CALL_OW 1
59069: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59070: LD_ADDR_EXP 100
59074: PUSH
59075: LD_EXP 100
59079: PPUSH
59080: LD_VAR 0 4
59084: PPUSH
59085: EMPTY
59086: PPUSH
59087: CALL_OW 1
59091: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59092: LD_ADDR_EXP 101
59096: PUSH
59097: LD_EXP 101
59101: PPUSH
59102: LD_VAR 0 4
59106: PPUSH
59107: EMPTY
59108: PPUSH
59109: CALL_OW 1
59113: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59114: LD_ADDR_EXP 102
59118: PUSH
59119: LD_EXP 102
59123: PPUSH
59124: LD_VAR 0 4
59128: PPUSH
59129: EMPTY
59130: PPUSH
59131: CALL_OW 1
59135: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59136: LD_ADDR_EXP 103
59140: PUSH
59141: LD_EXP 103
59145: PPUSH
59146: LD_VAR 0 4
59150: PPUSH
59151: LD_INT 0
59153: PPUSH
59154: CALL_OW 1
59158: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
59159: LD_ADDR_EXP 104
59163: PUSH
59164: LD_EXP 104
59168: PPUSH
59169: LD_VAR 0 4
59173: PPUSH
59174: LD_INT 0
59176: PPUSH
59177: CALL_OW 1
59181: ST_TO_ADDR
// result := base ;
59182: LD_ADDR_VAR 0 3
59186: PUSH
59187: LD_VAR 0 4
59191: ST_TO_ADDR
// end ;
59192: LD_VAR 0 3
59196: RET
// export function MC_Start ( ) ; var i ; begin
59197: LD_INT 0
59199: PPUSH
59200: PPUSH
// for i = 1 to mc_bases do
59201: LD_ADDR_VAR 0 2
59205: PUSH
59206: DOUBLE
59207: LD_INT 1
59209: DEC
59210: ST_TO_ADDR
59211: LD_EXP 61
59215: PUSH
59216: FOR_TO
59217: IFFALSE 60317
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59219: LD_ADDR_EXP 61
59223: PUSH
59224: LD_EXP 61
59228: PPUSH
59229: LD_VAR 0 2
59233: PPUSH
59234: LD_EXP 61
59238: PUSH
59239: LD_VAR 0 2
59243: ARRAY
59244: PUSH
59245: LD_INT 0
59247: DIFF
59248: PPUSH
59249: CALL_OW 1
59253: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59254: LD_ADDR_EXP 62
59258: PUSH
59259: LD_EXP 62
59263: PPUSH
59264: LD_VAR 0 2
59268: PPUSH
59269: EMPTY
59270: PPUSH
59271: CALL_OW 1
59275: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59276: LD_ADDR_EXP 63
59280: PUSH
59281: LD_EXP 63
59285: PPUSH
59286: LD_VAR 0 2
59290: PPUSH
59291: EMPTY
59292: PPUSH
59293: CALL_OW 1
59297: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59298: LD_ADDR_EXP 64
59302: PUSH
59303: LD_EXP 64
59307: PPUSH
59308: LD_VAR 0 2
59312: PPUSH
59313: EMPTY
59314: PPUSH
59315: CALL_OW 1
59319: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59320: LD_ADDR_EXP 65
59324: PUSH
59325: LD_EXP 65
59329: PPUSH
59330: LD_VAR 0 2
59334: PPUSH
59335: EMPTY
59336: PUSH
59337: EMPTY
59338: PUSH
59339: EMPTY
59340: LIST
59341: LIST
59342: PPUSH
59343: CALL_OW 1
59347: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59348: LD_ADDR_EXP 66
59352: PUSH
59353: LD_EXP 66
59357: PPUSH
59358: LD_VAR 0 2
59362: PPUSH
59363: EMPTY
59364: PPUSH
59365: CALL_OW 1
59369: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59370: LD_ADDR_EXP 93
59374: PUSH
59375: LD_EXP 93
59379: PPUSH
59380: LD_VAR 0 2
59384: PPUSH
59385: EMPTY
59386: PPUSH
59387: CALL_OW 1
59391: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59392: LD_ADDR_EXP 67
59396: PUSH
59397: LD_EXP 67
59401: PPUSH
59402: LD_VAR 0 2
59406: PPUSH
59407: EMPTY
59408: PPUSH
59409: CALL_OW 1
59413: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59414: LD_ADDR_EXP 68
59418: PUSH
59419: LD_EXP 68
59423: PPUSH
59424: LD_VAR 0 2
59428: PPUSH
59429: EMPTY
59430: PPUSH
59431: CALL_OW 1
59435: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59436: LD_ADDR_EXP 69
59440: PUSH
59441: LD_EXP 69
59445: PPUSH
59446: LD_VAR 0 2
59450: PPUSH
59451: LD_EXP 61
59455: PUSH
59456: LD_VAR 0 2
59460: ARRAY
59461: PPUSH
59462: LD_INT 2
59464: PUSH
59465: LD_INT 30
59467: PUSH
59468: LD_INT 32
59470: PUSH
59471: EMPTY
59472: LIST
59473: LIST
59474: PUSH
59475: LD_INT 30
59477: PUSH
59478: LD_INT 33
59480: PUSH
59481: EMPTY
59482: LIST
59483: LIST
59484: PUSH
59485: EMPTY
59486: LIST
59487: LIST
59488: LIST
59489: PPUSH
59490: CALL_OW 72
59494: PPUSH
59495: CALL_OW 1
59499: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59500: LD_ADDR_EXP 70
59504: PUSH
59505: LD_EXP 70
59509: PPUSH
59510: LD_VAR 0 2
59514: PPUSH
59515: LD_EXP 61
59519: PUSH
59520: LD_VAR 0 2
59524: ARRAY
59525: PPUSH
59526: LD_INT 2
59528: PUSH
59529: LD_INT 30
59531: PUSH
59532: LD_INT 32
59534: PUSH
59535: EMPTY
59536: LIST
59537: LIST
59538: PUSH
59539: LD_INT 30
59541: PUSH
59542: LD_INT 31
59544: PUSH
59545: EMPTY
59546: LIST
59547: LIST
59548: PUSH
59549: EMPTY
59550: LIST
59551: LIST
59552: LIST
59553: PUSH
59554: LD_INT 58
59556: PUSH
59557: EMPTY
59558: LIST
59559: PUSH
59560: EMPTY
59561: LIST
59562: LIST
59563: PPUSH
59564: CALL_OW 72
59568: PPUSH
59569: CALL_OW 1
59573: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59574: LD_ADDR_EXP 71
59578: PUSH
59579: LD_EXP 71
59583: PPUSH
59584: LD_VAR 0 2
59588: PPUSH
59589: EMPTY
59590: PPUSH
59591: CALL_OW 1
59595: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59596: LD_ADDR_EXP 75
59600: PUSH
59601: LD_EXP 75
59605: PPUSH
59606: LD_VAR 0 2
59610: PPUSH
59611: EMPTY
59612: PPUSH
59613: CALL_OW 1
59617: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59618: LD_ADDR_EXP 74
59622: PUSH
59623: LD_EXP 74
59627: PPUSH
59628: LD_VAR 0 2
59632: PPUSH
59633: EMPTY
59634: PPUSH
59635: CALL_OW 1
59639: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59640: LD_ADDR_EXP 76
59644: PUSH
59645: LD_EXP 76
59649: PPUSH
59650: LD_VAR 0 2
59654: PPUSH
59655: EMPTY
59656: PPUSH
59657: CALL_OW 1
59661: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59662: LD_ADDR_EXP 77
59666: PUSH
59667: LD_EXP 77
59671: PPUSH
59672: LD_VAR 0 2
59676: PPUSH
59677: EMPTY
59678: PPUSH
59679: CALL_OW 1
59683: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59684: LD_ADDR_EXP 78
59688: PUSH
59689: LD_EXP 78
59693: PPUSH
59694: LD_VAR 0 2
59698: PPUSH
59699: EMPTY
59700: PPUSH
59701: CALL_OW 1
59705: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59706: LD_ADDR_EXP 79
59710: PUSH
59711: LD_EXP 79
59715: PPUSH
59716: LD_VAR 0 2
59720: PPUSH
59721: EMPTY
59722: PPUSH
59723: CALL_OW 1
59727: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59728: LD_ADDR_EXP 80
59732: PUSH
59733: LD_EXP 80
59737: PPUSH
59738: LD_VAR 0 2
59742: PPUSH
59743: EMPTY
59744: PPUSH
59745: CALL_OW 1
59749: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59750: LD_ADDR_EXP 81
59754: PUSH
59755: LD_EXP 81
59759: PPUSH
59760: LD_VAR 0 2
59764: PPUSH
59765: EMPTY
59766: PPUSH
59767: CALL_OW 1
59771: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59772: LD_ADDR_EXP 82
59776: PUSH
59777: LD_EXP 82
59781: PPUSH
59782: LD_VAR 0 2
59786: PPUSH
59787: EMPTY
59788: PPUSH
59789: CALL_OW 1
59793: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59794: LD_ADDR_EXP 83
59798: PUSH
59799: LD_EXP 83
59803: PPUSH
59804: LD_VAR 0 2
59808: PPUSH
59809: EMPTY
59810: PPUSH
59811: CALL_OW 1
59815: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59816: LD_ADDR_EXP 72
59820: PUSH
59821: LD_EXP 72
59825: PPUSH
59826: LD_VAR 0 2
59830: PPUSH
59831: LD_INT 0
59833: PPUSH
59834: CALL_OW 1
59838: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59839: LD_ADDR_EXP 85
59843: PUSH
59844: LD_EXP 85
59848: PPUSH
59849: LD_VAR 0 2
59853: PPUSH
59854: LD_INT 0
59856: PPUSH
59857: CALL_OW 1
59861: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59862: LD_ADDR_EXP 73
59866: PUSH
59867: LD_EXP 73
59871: PPUSH
59872: LD_VAR 0 2
59876: PPUSH
59877: EMPTY
59878: PPUSH
59879: CALL_OW 1
59883: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
59884: LD_ADDR_EXP 84
59888: PUSH
59889: LD_EXP 84
59893: PPUSH
59894: LD_VAR 0 2
59898: PPUSH
59899: LD_INT 0
59901: PPUSH
59902: CALL_OW 1
59906: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
59907: LD_ADDR_EXP 86
59911: PUSH
59912: LD_EXP 86
59916: PPUSH
59917: LD_VAR 0 2
59921: PPUSH
59922: EMPTY
59923: PPUSH
59924: CALL_OW 1
59928: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
59929: LD_ADDR_EXP 89
59933: PUSH
59934: LD_EXP 89
59938: PPUSH
59939: LD_VAR 0 2
59943: PPUSH
59944: LD_INT 0
59946: PPUSH
59947: CALL_OW 1
59951: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
59952: LD_ADDR_EXP 90
59956: PUSH
59957: LD_EXP 90
59961: PPUSH
59962: LD_VAR 0 2
59966: PPUSH
59967: EMPTY
59968: PPUSH
59969: CALL_OW 1
59973: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
59974: LD_ADDR_EXP 91
59978: PUSH
59979: LD_EXP 91
59983: PPUSH
59984: LD_VAR 0 2
59988: PPUSH
59989: EMPTY
59990: PPUSH
59991: CALL_OW 1
59995: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
59996: LD_ADDR_EXP 92
60000: PUSH
60001: LD_EXP 92
60005: PPUSH
60006: LD_VAR 0 2
60010: PPUSH
60011: EMPTY
60012: PPUSH
60013: CALL_OW 1
60017: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60018: LD_ADDR_EXP 94
60022: PUSH
60023: LD_EXP 94
60027: PPUSH
60028: LD_VAR 0 2
60032: PPUSH
60033: LD_EXP 61
60037: PUSH
60038: LD_VAR 0 2
60042: ARRAY
60043: PPUSH
60044: LD_INT 2
60046: PUSH
60047: LD_INT 30
60049: PUSH
60050: LD_INT 6
60052: PUSH
60053: EMPTY
60054: LIST
60055: LIST
60056: PUSH
60057: LD_INT 30
60059: PUSH
60060: LD_INT 7
60062: PUSH
60063: EMPTY
60064: LIST
60065: LIST
60066: PUSH
60067: LD_INT 30
60069: PUSH
60070: LD_INT 8
60072: PUSH
60073: EMPTY
60074: LIST
60075: LIST
60076: PUSH
60077: EMPTY
60078: LIST
60079: LIST
60080: LIST
60081: LIST
60082: PPUSH
60083: CALL_OW 72
60087: PPUSH
60088: CALL_OW 1
60092: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60093: LD_ADDR_EXP 95
60097: PUSH
60098: LD_EXP 95
60102: PPUSH
60103: LD_VAR 0 2
60107: PPUSH
60108: EMPTY
60109: PPUSH
60110: CALL_OW 1
60114: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60115: LD_ADDR_EXP 96
60119: PUSH
60120: LD_EXP 96
60124: PPUSH
60125: LD_VAR 0 2
60129: PPUSH
60130: EMPTY
60131: PPUSH
60132: CALL_OW 1
60136: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60137: LD_ADDR_EXP 97
60141: PUSH
60142: LD_EXP 97
60146: PPUSH
60147: LD_VAR 0 2
60151: PPUSH
60152: EMPTY
60153: PPUSH
60154: CALL_OW 1
60158: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60159: LD_ADDR_EXP 98
60163: PUSH
60164: LD_EXP 98
60168: PPUSH
60169: LD_VAR 0 2
60173: PPUSH
60174: EMPTY
60175: PPUSH
60176: CALL_OW 1
60180: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60181: LD_ADDR_EXP 99
60185: PUSH
60186: LD_EXP 99
60190: PPUSH
60191: LD_VAR 0 2
60195: PPUSH
60196: EMPTY
60197: PPUSH
60198: CALL_OW 1
60202: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60203: LD_ADDR_EXP 100
60207: PUSH
60208: LD_EXP 100
60212: PPUSH
60213: LD_VAR 0 2
60217: PPUSH
60218: EMPTY
60219: PPUSH
60220: CALL_OW 1
60224: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60225: LD_ADDR_EXP 101
60229: PUSH
60230: LD_EXP 101
60234: PPUSH
60235: LD_VAR 0 2
60239: PPUSH
60240: EMPTY
60241: PPUSH
60242: CALL_OW 1
60246: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60247: LD_ADDR_EXP 102
60251: PUSH
60252: LD_EXP 102
60256: PPUSH
60257: LD_VAR 0 2
60261: PPUSH
60262: EMPTY
60263: PPUSH
60264: CALL_OW 1
60268: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60269: LD_ADDR_EXP 103
60273: PUSH
60274: LD_EXP 103
60278: PPUSH
60279: LD_VAR 0 2
60283: PPUSH
60284: LD_INT 0
60286: PPUSH
60287: CALL_OW 1
60291: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
60292: LD_ADDR_EXP 104
60296: PUSH
60297: LD_EXP 104
60301: PPUSH
60302: LD_VAR 0 2
60306: PPUSH
60307: LD_INT 0
60309: PPUSH
60310: CALL_OW 1
60314: ST_TO_ADDR
// end ;
60315: GO 59216
60317: POP
60318: POP
// MC_InitSides ( ) ;
60319: CALL 60605 0 0
// MC_InitResearch ( ) ;
60323: CALL 60344 0 0
// CustomInitMacro ( ) ;
60327: CALL 219 0 0
// skirmish := true ;
60331: LD_ADDR_EXP 59
60335: PUSH
60336: LD_INT 1
60338: ST_TO_ADDR
// end ;
60339: LD_VAR 0 1
60343: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60344: LD_INT 0
60346: PPUSH
60347: PPUSH
60348: PPUSH
60349: PPUSH
60350: PPUSH
60351: PPUSH
// if not mc_bases then
60352: LD_EXP 61
60356: NOT
60357: IFFALSE 60361
// exit ;
60359: GO 60600
// for i = 1 to 8 do
60361: LD_ADDR_VAR 0 2
60365: PUSH
60366: DOUBLE
60367: LD_INT 1
60369: DEC
60370: ST_TO_ADDR
60371: LD_INT 8
60373: PUSH
60374: FOR_TO
60375: IFFALSE 60401
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60377: LD_ADDR_EXP 88
60381: PUSH
60382: LD_EXP 88
60386: PPUSH
60387: LD_VAR 0 2
60391: PPUSH
60392: EMPTY
60393: PPUSH
60394: CALL_OW 1
60398: ST_TO_ADDR
60399: GO 60374
60401: POP
60402: POP
// tmp := [ ] ;
60403: LD_ADDR_VAR 0 5
60407: PUSH
60408: EMPTY
60409: ST_TO_ADDR
// for i = 1 to mc_sides do
60410: LD_ADDR_VAR 0 2
60414: PUSH
60415: DOUBLE
60416: LD_INT 1
60418: DEC
60419: ST_TO_ADDR
60420: LD_EXP 87
60424: PUSH
60425: FOR_TO
60426: IFFALSE 60484
// if not mc_sides [ i ] in tmp then
60428: LD_EXP 87
60432: PUSH
60433: LD_VAR 0 2
60437: ARRAY
60438: PUSH
60439: LD_VAR 0 5
60443: IN
60444: NOT
60445: IFFALSE 60482
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60447: LD_ADDR_VAR 0 5
60451: PUSH
60452: LD_VAR 0 5
60456: PPUSH
60457: LD_VAR 0 5
60461: PUSH
60462: LD_INT 1
60464: PLUS
60465: PPUSH
60466: LD_EXP 87
60470: PUSH
60471: LD_VAR 0 2
60475: ARRAY
60476: PPUSH
60477: CALL_OW 2
60481: ST_TO_ADDR
60482: GO 60425
60484: POP
60485: POP
// if not tmp then
60486: LD_VAR 0 5
60490: NOT
60491: IFFALSE 60495
// exit ;
60493: GO 60600
// for j in tmp do
60495: LD_ADDR_VAR 0 3
60499: PUSH
60500: LD_VAR 0 5
60504: PUSH
60505: FOR_IN
60506: IFFALSE 60598
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60508: LD_ADDR_VAR 0 6
60512: PUSH
60513: LD_INT 22
60515: PUSH
60516: LD_VAR 0 3
60520: PUSH
60521: EMPTY
60522: LIST
60523: LIST
60524: PPUSH
60525: CALL_OW 69
60529: ST_TO_ADDR
// if not un then
60530: LD_VAR 0 6
60534: NOT
60535: IFFALSE 60539
// continue ;
60537: GO 60505
// nation := GetNation ( un [ 1 ] ) ;
60539: LD_ADDR_VAR 0 4
60543: PUSH
60544: LD_VAR 0 6
60548: PUSH
60549: LD_INT 1
60551: ARRAY
60552: PPUSH
60553: CALL_OW 248
60557: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60558: LD_ADDR_EXP 88
60562: PUSH
60563: LD_EXP 88
60567: PPUSH
60568: LD_VAR 0 3
60572: PPUSH
60573: LD_VAR 0 3
60577: PPUSH
60578: LD_VAR 0 4
60582: PPUSH
60583: LD_INT 1
60585: PPUSH
60586: CALL 15564 0 3
60590: PPUSH
60591: CALL_OW 1
60595: ST_TO_ADDR
// end ;
60596: GO 60505
60598: POP
60599: POP
// end ;
60600: LD_VAR 0 1
60604: RET
// export function MC_InitSides ( ) ; var i ; begin
60605: LD_INT 0
60607: PPUSH
60608: PPUSH
// if not mc_bases then
60609: LD_EXP 61
60613: NOT
60614: IFFALSE 60618
// exit ;
60616: GO 60692
// for i = 1 to mc_bases do
60618: LD_ADDR_VAR 0 2
60622: PUSH
60623: DOUBLE
60624: LD_INT 1
60626: DEC
60627: ST_TO_ADDR
60628: LD_EXP 61
60632: PUSH
60633: FOR_TO
60634: IFFALSE 60690
// if mc_bases [ i ] then
60636: LD_EXP 61
60640: PUSH
60641: LD_VAR 0 2
60645: ARRAY
60646: IFFALSE 60688
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60648: LD_ADDR_EXP 87
60652: PUSH
60653: LD_EXP 87
60657: PPUSH
60658: LD_VAR 0 2
60662: PPUSH
60663: LD_EXP 61
60667: PUSH
60668: LD_VAR 0 2
60672: ARRAY
60673: PUSH
60674: LD_INT 1
60676: ARRAY
60677: PPUSH
60678: CALL_OW 255
60682: PPUSH
60683: CALL_OW 1
60687: ST_TO_ADDR
60688: GO 60633
60690: POP
60691: POP
// end ;
60692: LD_VAR 0 1
60696: RET
// every 0 0$03 trigger skirmish do
60697: LD_EXP 59
60701: IFFALSE 60855
60703: GO 60705
60705: DISABLE
// begin enable ;
60706: ENABLE
// MC_CheckBuildings ( ) ;
60707: CALL 65367 0 0
// MC_CheckPeopleLife ( ) ;
60711: CALL 65528 0 0
// RaiseSailEvent ( 100 ) ;
60715: LD_INT 100
60717: PPUSH
60718: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60722: LD_INT 103
60724: PPUSH
60725: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60729: LD_INT 104
60731: PPUSH
60732: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60736: LD_INT 105
60738: PPUSH
60739: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60743: LD_INT 106
60745: PPUSH
60746: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60750: LD_INT 107
60752: PPUSH
60753: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60757: LD_INT 108
60759: PPUSH
60760: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60764: LD_INT 109
60766: PPUSH
60767: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60771: LD_INT 110
60773: PPUSH
60774: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60778: LD_INT 111
60780: PPUSH
60781: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60785: LD_INT 112
60787: PPUSH
60788: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60792: LD_INT 113
60794: PPUSH
60795: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60799: LD_INT 120
60801: PPUSH
60802: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60806: LD_INT 121
60808: PPUSH
60809: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60813: LD_INT 122
60815: PPUSH
60816: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60820: LD_INT 123
60822: PPUSH
60823: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60827: LD_INT 124
60829: PPUSH
60830: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60834: LD_INT 125
60836: PPUSH
60837: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60841: LD_INT 126
60843: PPUSH
60844: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60848: LD_INT 200
60850: PPUSH
60851: CALL_OW 427
// end ;
60855: END
// on SailEvent ( event ) do begin if event < 100 then
60856: LD_VAR 0 1
60860: PUSH
60861: LD_INT 100
60863: LESS
60864: IFFALSE 60875
// CustomEvent ( event ) ;
60866: LD_VAR 0 1
60870: PPUSH
60871: CALL 14179 0 1
// if event = 100 then
60875: LD_VAR 0 1
60879: PUSH
60880: LD_INT 100
60882: EQUAL
60883: IFFALSE 60889
// MC_ClassManager ( ) ;
60885: CALL 61281 0 0
// if event = 101 then
60889: LD_VAR 0 1
60893: PUSH
60894: LD_INT 101
60896: EQUAL
60897: IFFALSE 60903
// MC_RepairBuildings ( ) ;
60899: CALL 66113 0 0
// if event = 102 then
60903: LD_VAR 0 1
60907: PUSH
60908: LD_INT 102
60910: EQUAL
60911: IFFALSE 60917
// MC_Heal ( ) ;
60913: CALL 67048 0 0
// if event = 103 then
60917: LD_VAR 0 1
60921: PUSH
60922: LD_INT 103
60924: EQUAL
60925: IFFALSE 60931
// MC_Build ( ) ;
60927: CALL 67470 0 0
// if event = 104 then
60931: LD_VAR 0 1
60935: PUSH
60936: LD_INT 104
60938: EQUAL
60939: IFFALSE 60945
// MC_TurretWeapon ( ) ;
60941: CALL 69104 0 0
// if event = 105 then
60945: LD_VAR 0 1
60949: PUSH
60950: LD_INT 105
60952: EQUAL
60953: IFFALSE 60959
// MC_BuildUpgrade ( ) ;
60955: CALL 68655 0 0
// if event = 106 then
60959: LD_VAR 0 1
60963: PUSH
60964: LD_INT 106
60966: EQUAL
60967: IFFALSE 60973
// MC_PlantMines ( ) ;
60969: CALL 69534 0 0
// if event = 107 then
60973: LD_VAR 0 1
60977: PUSH
60978: LD_INT 107
60980: EQUAL
60981: IFFALSE 60987
// MC_CollectCrates ( ) ;
60983: CALL 70332 0 0
// if event = 108 then
60987: LD_VAR 0 1
60991: PUSH
60992: LD_INT 108
60994: EQUAL
60995: IFFALSE 61001
// MC_LinkRemoteControl ( ) ;
60997: CALL 72182 0 0
// if event = 109 then
61001: LD_VAR 0 1
61005: PUSH
61006: LD_INT 109
61008: EQUAL
61009: IFFALSE 61015
// MC_ProduceVehicle ( ) ;
61011: CALL 72363 0 0
// if event = 110 then
61015: LD_VAR 0 1
61019: PUSH
61020: LD_INT 110
61022: EQUAL
61023: IFFALSE 61029
// MC_SendAttack ( ) ;
61025: CALL 72829 0 0
// if event = 111 then
61029: LD_VAR 0 1
61033: PUSH
61034: LD_INT 111
61036: EQUAL
61037: IFFALSE 61043
// MC_Defend ( ) ;
61039: CALL 72937 0 0
// if event = 112 then
61043: LD_VAR 0 1
61047: PUSH
61048: LD_INT 112
61050: EQUAL
61051: IFFALSE 61057
// MC_Research ( ) ;
61053: CALL 73817 0 0
// if event = 113 then
61057: LD_VAR 0 1
61061: PUSH
61062: LD_INT 113
61064: EQUAL
61065: IFFALSE 61071
// MC_MinesTrigger ( ) ;
61067: CALL 74931 0 0
// if event = 120 then
61071: LD_VAR 0 1
61075: PUSH
61076: LD_INT 120
61078: EQUAL
61079: IFFALSE 61085
// MC_RepairVehicle ( ) ;
61081: CALL 75030 0 0
// if event = 121 then
61085: LD_VAR 0 1
61089: PUSH
61090: LD_INT 121
61092: EQUAL
61093: IFFALSE 61099
// MC_TameApe ( ) ;
61095: CALL 75799 0 0
// if event = 122 then
61099: LD_VAR 0 1
61103: PUSH
61104: LD_INT 122
61106: EQUAL
61107: IFFALSE 61113
// MC_ChangeApeClass ( ) ;
61109: CALL 76628 0 0
// if event = 123 then
61113: LD_VAR 0 1
61117: PUSH
61118: LD_INT 123
61120: EQUAL
61121: IFFALSE 61127
// MC_Bazooka ( ) ;
61123: CALL 77278 0 0
// if event = 124 then
61127: LD_VAR 0 1
61131: PUSH
61132: LD_INT 124
61134: EQUAL
61135: IFFALSE 61141
// MC_TeleportExit ( ) ;
61137: CALL 77476 0 0
// if event = 125 then
61141: LD_VAR 0 1
61145: PUSH
61146: LD_INT 125
61148: EQUAL
61149: IFFALSE 61155
// MC_Deposits ( ) ;
61151: CALL 78123 0 0
// if event = 126 then
61155: LD_VAR 0 1
61159: PUSH
61160: LD_INT 126
61162: EQUAL
61163: IFFALSE 61169
// MC_RemoteDriver ( ) ;
61165: CALL 78748 0 0
// if event = 200 then
61169: LD_VAR 0 1
61173: PUSH
61174: LD_INT 200
61176: EQUAL
61177: IFFALSE 61183
// MC_Idle ( ) ;
61179: CALL 80655 0 0
// end ;
61183: PPOPN 1
61185: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61186: LD_INT 0
61188: PPUSH
61189: PPUSH
// if not mc_bases [ base ] or not tag then
61190: LD_EXP 61
61194: PUSH
61195: LD_VAR 0 1
61199: ARRAY
61200: NOT
61201: PUSH
61202: LD_VAR 0 2
61206: NOT
61207: OR
61208: IFFALSE 61212
// exit ;
61210: GO 61276
// for i in mc_bases [ base ] union mc_ape [ base ] do
61212: LD_ADDR_VAR 0 4
61216: PUSH
61217: LD_EXP 61
61221: PUSH
61222: LD_VAR 0 1
61226: ARRAY
61227: PUSH
61228: LD_EXP 90
61232: PUSH
61233: LD_VAR 0 1
61237: ARRAY
61238: UNION
61239: PUSH
61240: FOR_IN
61241: IFFALSE 61274
// if GetTag ( i ) = tag then
61243: LD_VAR 0 4
61247: PPUSH
61248: CALL_OW 110
61252: PUSH
61253: LD_VAR 0 2
61257: EQUAL
61258: IFFALSE 61272
// SetTag ( i , 0 ) ;
61260: LD_VAR 0 4
61264: PPUSH
61265: LD_INT 0
61267: PPUSH
61268: CALL_OW 109
61272: GO 61240
61274: POP
61275: POP
// end ;
61276: LD_VAR 0 3
61280: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61281: LD_INT 0
61283: PPUSH
61284: PPUSH
61285: PPUSH
61286: PPUSH
61287: PPUSH
61288: PPUSH
61289: PPUSH
61290: PPUSH
// if not mc_bases then
61291: LD_EXP 61
61295: NOT
61296: IFFALSE 61300
// exit ;
61298: GO 61749
// for i = 1 to mc_bases do
61300: LD_ADDR_VAR 0 2
61304: PUSH
61305: DOUBLE
61306: LD_INT 1
61308: DEC
61309: ST_TO_ADDR
61310: LD_EXP 61
61314: PUSH
61315: FOR_TO
61316: IFFALSE 61747
// begin tmp := MC_ClassCheckReq ( i ) ;
61318: LD_ADDR_VAR 0 4
61322: PUSH
61323: LD_VAR 0 2
61327: PPUSH
61328: CALL 61754 0 1
61332: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61333: LD_ADDR_EXP 102
61337: PUSH
61338: LD_EXP 102
61342: PPUSH
61343: LD_VAR 0 2
61347: PPUSH
61348: LD_VAR 0 4
61352: PPUSH
61353: CALL_OW 1
61357: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61358: LD_ADDR_VAR 0 6
61362: PUSH
61363: LD_EXP 61
61367: PUSH
61368: LD_VAR 0 2
61372: ARRAY
61373: PPUSH
61374: LD_INT 2
61376: PUSH
61377: LD_INT 30
61379: PUSH
61380: LD_INT 4
61382: PUSH
61383: EMPTY
61384: LIST
61385: LIST
61386: PUSH
61387: LD_INT 30
61389: PUSH
61390: LD_INT 5
61392: PUSH
61393: EMPTY
61394: LIST
61395: LIST
61396: PUSH
61397: EMPTY
61398: LIST
61399: LIST
61400: LIST
61401: PPUSH
61402: CALL_OW 72
61406: PUSH
61407: LD_EXP 61
61411: PUSH
61412: LD_VAR 0 2
61416: ARRAY
61417: PPUSH
61418: LD_INT 2
61420: PUSH
61421: LD_INT 30
61423: PUSH
61424: LD_INT 0
61426: PUSH
61427: EMPTY
61428: LIST
61429: LIST
61430: PUSH
61431: LD_INT 30
61433: PUSH
61434: LD_INT 1
61436: PUSH
61437: EMPTY
61438: LIST
61439: LIST
61440: PUSH
61441: EMPTY
61442: LIST
61443: LIST
61444: LIST
61445: PPUSH
61446: CALL_OW 72
61450: PUSH
61451: LD_EXP 61
61455: PUSH
61456: LD_VAR 0 2
61460: ARRAY
61461: PPUSH
61462: LD_INT 30
61464: PUSH
61465: LD_INT 3
61467: PUSH
61468: EMPTY
61469: LIST
61470: LIST
61471: PPUSH
61472: CALL_OW 72
61476: PUSH
61477: LD_EXP 61
61481: PUSH
61482: LD_VAR 0 2
61486: ARRAY
61487: PPUSH
61488: LD_INT 2
61490: PUSH
61491: LD_INT 30
61493: PUSH
61494: LD_INT 6
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: LD_INT 30
61503: PUSH
61504: LD_INT 7
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: PUSH
61511: LD_INT 30
61513: PUSH
61514: LD_INT 8
61516: PUSH
61517: EMPTY
61518: LIST
61519: LIST
61520: PUSH
61521: EMPTY
61522: LIST
61523: LIST
61524: LIST
61525: LIST
61526: PPUSH
61527: CALL_OW 72
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: LIST
61536: LIST
61537: ST_TO_ADDR
// for j := 1 to 4 do
61538: LD_ADDR_VAR 0 3
61542: PUSH
61543: DOUBLE
61544: LD_INT 1
61546: DEC
61547: ST_TO_ADDR
61548: LD_INT 4
61550: PUSH
61551: FOR_TO
61552: IFFALSE 61743
// begin if not tmp [ j ] then
61554: LD_VAR 0 4
61558: PUSH
61559: LD_VAR 0 3
61563: ARRAY
61564: NOT
61565: IFFALSE 61569
// continue ;
61567: GO 61551
// for p in tmp [ j ] do
61569: LD_ADDR_VAR 0 5
61573: PUSH
61574: LD_VAR 0 4
61578: PUSH
61579: LD_VAR 0 3
61583: ARRAY
61584: PUSH
61585: FOR_IN
61586: IFFALSE 61739
// begin if not b [ j ] then
61588: LD_VAR 0 6
61592: PUSH
61593: LD_VAR 0 3
61597: ARRAY
61598: NOT
61599: IFFALSE 61603
// break ;
61601: GO 61739
// e := 0 ;
61603: LD_ADDR_VAR 0 7
61607: PUSH
61608: LD_INT 0
61610: ST_TO_ADDR
// for k in b [ j ] do
61611: LD_ADDR_VAR 0 8
61615: PUSH
61616: LD_VAR 0 6
61620: PUSH
61621: LD_VAR 0 3
61625: ARRAY
61626: PUSH
61627: FOR_IN
61628: IFFALSE 61655
// if IsNotFull ( k ) then
61630: LD_VAR 0 8
61634: PPUSH
61635: CALL 17685 0 1
61639: IFFALSE 61653
// begin e := k ;
61641: LD_ADDR_VAR 0 7
61645: PUSH
61646: LD_VAR 0 8
61650: ST_TO_ADDR
// break ;
61651: GO 61655
// end ;
61653: GO 61627
61655: POP
61656: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61657: LD_VAR 0 7
61661: PUSH
61662: LD_VAR 0 5
61666: PPUSH
61667: LD_VAR 0 7
61671: PPUSH
61672: CALL 51447 0 2
61676: NOT
61677: AND
61678: IFFALSE 61737
// begin if IsInUnit ( p ) then
61680: LD_VAR 0 5
61684: PPUSH
61685: CALL_OW 310
61689: IFFALSE 61700
// ComExitBuilding ( p ) ;
61691: LD_VAR 0 5
61695: PPUSH
61696: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61700: LD_VAR 0 5
61704: PPUSH
61705: LD_VAR 0 7
61709: PPUSH
61710: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61714: LD_VAR 0 5
61718: PPUSH
61719: LD_VAR 0 3
61723: PPUSH
61724: CALL_OW 183
// AddComExitBuilding ( p ) ;
61728: LD_VAR 0 5
61732: PPUSH
61733: CALL_OW 182
// end ; end ;
61737: GO 61585
61739: POP
61740: POP
// end ;
61741: GO 61551
61743: POP
61744: POP
// end ;
61745: GO 61315
61747: POP
61748: POP
// end ;
61749: LD_VAR 0 1
61753: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61754: LD_INT 0
61756: PPUSH
61757: PPUSH
61758: PPUSH
61759: PPUSH
61760: PPUSH
61761: PPUSH
61762: PPUSH
61763: PPUSH
61764: PPUSH
61765: PPUSH
61766: PPUSH
61767: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
61768: LD_ADDR_VAR 0 2
61772: PUSH
61773: LD_INT 0
61775: PUSH
61776: LD_INT 0
61778: PUSH
61779: LD_INT 0
61781: PUSH
61782: LD_INT 0
61784: PUSH
61785: EMPTY
61786: LIST
61787: LIST
61788: LIST
61789: LIST
61790: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61791: LD_VAR 0 1
61795: NOT
61796: PUSH
61797: LD_EXP 61
61801: PUSH
61802: LD_VAR 0 1
61806: ARRAY
61807: NOT
61808: OR
61809: PUSH
61810: LD_EXP 61
61814: PUSH
61815: LD_VAR 0 1
61819: ARRAY
61820: PPUSH
61821: LD_INT 2
61823: PUSH
61824: LD_INT 30
61826: PUSH
61827: LD_INT 0
61829: PUSH
61830: EMPTY
61831: LIST
61832: LIST
61833: PUSH
61834: LD_INT 30
61836: PUSH
61837: LD_INT 1
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PUSH
61844: EMPTY
61845: LIST
61846: LIST
61847: LIST
61848: PPUSH
61849: CALL_OW 72
61853: NOT
61854: OR
61855: IFFALSE 61859
// exit ;
61857: GO 65362
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61859: LD_ADDR_VAR 0 4
61863: PUSH
61864: LD_EXP 61
61868: PUSH
61869: LD_VAR 0 1
61873: ARRAY
61874: PPUSH
61875: LD_INT 2
61877: PUSH
61878: LD_INT 25
61880: PUSH
61881: LD_INT 1
61883: PUSH
61884: EMPTY
61885: LIST
61886: LIST
61887: PUSH
61888: LD_INT 25
61890: PUSH
61891: LD_INT 2
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: PUSH
61898: LD_INT 25
61900: PUSH
61901: LD_INT 3
61903: PUSH
61904: EMPTY
61905: LIST
61906: LIST
61907: PUSH
61908: LD_INT 25
61910: PUSH
61911: LD_INT 4
61913: PUSH
61914: EMPTY
61915: LIST
61916: LIST
61917: PUSH
61918: LD_INT 25
61920: PUSH
61921: LD_INT 5
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: PUSH
61928: LD_INT 25
61930: PUSH
61931: LD_INT 8
61933: PUSH
61934: EMPTY
61935: LIST
61936: LIST
61937: PUSH
61938: LD_INT 25
61940: PUSH
61941: LD_INT 9
61943: PUSH
61944: EMPTY
61945: LIST
61946: LIST
61947: PUSH
61948: EMPTY
61949: LIST
61950: LIST
61951: LIST
61952: LIST
61953: LIST
61954: LIST
61955: LIST
61956: LIST
61957: PPUSH
61958: CALL_OW 72
61962: ST_TO_ADDR
// if not tmp then
61963: LD_VAR 0 4
61967: NOT
61968: IFFALSE 61972
// exit ;
61970: GO 65362
// for i in tmp do
61972: LD_ADDR_VAR 0 3
61976: PUSH
61977: LD_VAR 0 4
61981: PUSH
61982: FOR_IN
61983: IFFALSE 62014
// if GetTag ( i ) then
61985: LD_VAR 0 3
61989: PPUSH
61990: CALL_OW 110
61994: IFFALSE 62012
// tmp := tmp diff i ;
61996: LD_ADDR_VAR 0 4
62000: PUSH
62001: LD_VAR 0 4
62005: PUSH
62006: LD_VAR 0 3
62010: DIFF
62011: ST_TO_ADDR
62012: GO 61982
62014: POP
62015: POP
// if not tmp then
62016: LD_VAR 0 4
62020: NOT
62021: IFFALSE 62025
// exit ;
62023: GO 65362
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62025: LD_ADDR_VAR 0 5
62029: PUSH
62030: LD_EXP 61
62034: PUSH
62035: LD_VAR 0 1
62039: ARRAY
62040: PPUSH
62041: LD_INT 2
62043: PUSH
62044: LD_INT 25
62046: PUSH
62047: LD_INT 1
62049: PUSH
62050: EMPTY
62051: LIST
62052: LIST
62053: PUSH
62054: LD_INT 25
62056: PUSH
62057: LD_INT 5
62059: PUSH
62060: EMPTY
62061: LIST
62062: LIST
62063: PUSH
62064: LD_INT 25
62066: PUSH
62067: LD_INT 8
62069: PUSH
62070: EMPTY
62071: LIST
62072: LIST
62073: PUSH
62074: LD_INT 25
62076: PUSH
62077: LD_INT 9
62079: PUSH
62080: EMPTY
62081: LIST
62082: LIST
62083: PUSH
62084: EMPTY
62085: LIST
62086: LIST
62087: LIST
62088: LIST
62089: LIST
62090: PPUSH
62091: CALL_OW 72
62095: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62096: LD_ADDR_VAR 0 6
62100: PUSH
62101: LD_EXP 61
62105: PUSH
62106: LD_VAR 0 1
62110: ARRAY
62111: PPUSH
62112: LD_INT 25
62114: PUSH
62115: LD_INT 2
62117: PUSH
62118: EMPTY
62119: LIST
62120: LIST
62121: PPUSH
62122: CALL_OW 72
62126: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62127: LD_ADDR_VAR 0 7
62131: PUSH
62132: LD_EXP 61
62136: PUSH
62137: LD_VAR 0 1
62141: ARRAY
62142: PPUSH
62143: LD_INT 25
62145: PUSH
62146: LD_INT 3
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: PPUSH
62153: CALL_OW 72
62157: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62158: LD_ADDR_VAR 0 8
62162: PUSH
62163: LD_EXP 61
62167: PUSH
62168: LD_VAR 0 1
62172: ARRAY
62173: PPUSH
62174: LD_INT 25
62176: PUSH
62177: LD_INT 4
62179: PUSH
62180: EMPTY
62181: LIST
62182: LIST
62183: PUSH
62184: LD_INT 24
62186: PUSH
62187: LD_INT 251
62189: PUSH
62190: EMPTY
62191: LIST
62192: LIST
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: PPUSH
62198: CALL_OW 72
62202: ST_TO_ADDR
// if mc_is_defending [ base ] then
62203: LD_EXP 104
62207: PUSH
62208: LD_VAR 0 1
62212: ARRAY
62213: IFFALSE 62674
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62215: LD_ADDR_EXP 103
62219: PUSH
62220: LD_EXP 103
62224: PPUSH
62225: LD_VAR 0 1
62229: PPUSH
62230: LD_INT 4
62232: PPUSH
62233: CALL_OW 1
62237: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62238: LD_ADDR_VAR 0 12
62242: PUSH
62243: LD_EXP 61
62247: PUSH
62248: LD_VAR 0 1
62252: ARRAY
62253: PPUSH
62254: LD_INT 2
62256: PUSH
62257: LD_INT 30
62259: PUSH
62260: LD_INT 4
62262: PUSH
62263: EMPTY
62264: LIST
62265: LIST
62266: PUSH
62267: LD_INT 30
62269: PUSH
62270: LD_INT 5
62272: PUSH
62273: EMPTY
62274: LIST
62275: LIST
62276: PUSH
62277: EMPTY
62278: LIST
62279: LIST
62280: LIST
62281: PPUSH
62282: CALL_OW 72
62286: ST_TO_ADDR
// if not b then
62287: LD_VAR 0 12
62291: NOT
62292: IFFALSE 62296
// exit ;
62294: GO 65362
// p := [ ] ;
62296: LD_ADDR_VAR 0 11
62300: PUSH
62301: EMPTY
62302: ST_TO_ADDR
// if sci >= 2 then
62303: LD_VAR 0 8
62307: PUSH
62308: LD_INT 2
62310: GREATEREQUAL
62311: IFFALSE 62342
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62313: LD_ADDR_VAR 0 8
62317: PUSH
62318: LD_VAR 0 8
62322: PUSH
62323: LD_INT 1
62325: ARRAY
62326: PUSH
62327: LD_VAR 0 8
62331: PUSH
62332: LD_INT 2
62334: ARRAY
62335: PUSH
62336: EMPTY
62337: LIST
62338: LIST
62339: ST_TO_ADDR
62340: GO 62403
// if sci = 1 then
62342: LD_VAR 0 8
62346: PUSH
62347: LD_INT 1
62349: EQUAL
62350: IFFALSE 62371
// sci := [ sci [ 1 ] ] else
62352: LD_ADDR_VAR 0 8
62356: PUSH
62357: LD_VAR 0 8
62361: PUSH
62362: LD_INT 1
62364: ARRAY
62365: PUSH
62366: EMPTY
62367: LIST
62368: ST_TO_ADDR
62369: GO 62403
// if sci = 0 then
62371: LD_VAR 0 8
62375: PUSH
62376: LD_INT 0
62378: EQUAL
62379: IFFALSE 62403
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62381: LD_ADDR_VAR 0 11
62385: PUSH
62386: LD_VAR 0 4
62390: PPUSH
62391: LD_INT 4
62393: PPUSH
62394: CALL 51319 0 2
62398: PUSH
62399: LD_INT 1
62401: ARRAY
62402: ST_TO_ADDR
// if eng > 4 then
62403: LD_VAR 0 6
62407: PUSH
62408: LD_INT 4
62410: GREATER
62411: IFFALSE 62457
// for i = eng downto 4 do
62413: LD_ADDR_VAR 0 3
62417: PUSH
62418: DOUBLE
62419: LD_VAR 0 6
62423: INC
62424: ST_TO_ADDR
62425: LD_INT 4
62427: PUSH
62428: FOR_DOWNTO
62429: IFFALSE 62455
// eng := eng diff eng [ i ] ;
62431: LD_ADDR_VAR 0 6
62435: PUSH
62436: LD_VAR 0 6
62440: PUSH
62441: LD_VAR 0 6
62445: PUSH
62446: LD_VAR 0 3
62450: ARRAY
62451: DIFF
62452: ST_TO_ADDR
62453: GO 62428
62455: POP
62456: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62457: LD_ADDR_VAR 0 4
62461: PUSH
62462: LD_VAR 0 4
62466: PUSH
62467: LD_VAR 0 5
62471: PUSH
62472: LD_VAR 0 6
62476: UNION
62477: PUSH
62478: LD_VAR 0 7
62482: UNION
62483: PUSH
62484: LD_VAR 0 8
62488: UNION
62489: DIFF
62490: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62491: LD_ADDR_VAR 0 13
62495: PUSH
62496: LD_EXP 61
62500: PUSH
62501: LD_VAR 0 1
62505: ARRAY
62506: PPUSH
62507: LD_INT 2
62509: PUSH
62510: LD_INT 30
62512: PUSH
62513: LD_INT 32
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 30
62522: PUSH
62523: LD_INT 31
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: PPUSH
62535: CALL_OW 72
62539: PUSH
62540: LD_EXP 61
62544: PUSH
62545: LD_VAR 0 1
62549: ARRAY
62550: PPUSH
62551: LD_INT 2
62553: PUSH
62554: LD_INT 30
62556: PUSH
62557: LD_INT 4
62559: PUSH
62560: EMPTY
62561: LIST
62562: LIST
62563: PUSH
62564: LD_INT 30
62566: PUSH
62567: LD_INT 5
62569: PUSH
62570: EMPTY
62571: LIST
62572: LIST
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: LIST
62578: PPUSH
62579: CALL_OW 72
62583: PUSH
62584: LD_INT 6
62586: MUL
62587: PLUS
62588: ST_TO_ADDR
// if bcount < tmp then
62589: LD_VAR 0 13
62593: PUSH
62594: LD_VAR 0 4
62598: LESS
62599: IFFALSE 62645
// for i = tmp downto bcount do
62601: LD_ADDR_VAR 0 3
62605: PUSH
62606: DOUBLE
62607: LD_VAR 0 4
62611: INC
62612: ST_TO_ADDR
62613: LD_VAR 0 13
62617: PUSH
62618: FOR_DOWNTO
62619: IFFALSE 62643
// tmp := Delete ( tmp , tmp ) ;
62621: LD_ADDR_VAR 0 4
62625: PUSH
62626: LD_VAR 0 4
62630: PPUSH
62631: LD_VAR 0 4
62635: PPUSH
62636: CALL_OW 3
62640: ST_TO_ADDR
62641: GO 62618
62643: POP
62644: POP
// result := [ tmp , 0 , 0 , p ] ;
62645: LD_ADDR_VAR 0 2
62649: PUSH
62650: LD_VAR 0 4
62654: PUSH
62655: LD_INT 0
62657: PUSH
62658: LD_INT 0
62660: PUSH
62661: LD_VAR 0 11
62665: PUSH
62666: EMPTY
62667: LIST
62668: LIST
62669: LIST
62670: LIST
62671: ST_TO_ADDR
// exit ;
62672: GO 65362
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62674: LD_EXP 61
62678: PUSH
62679: LD_VAR 0 1
62683: ARRAY
62684: PPUSH
62685: LD_INT 2
62687: PUSH
62688: LD_INT 30
62690: PUSH
62691: LD_INT 6
62693: PUSH
62694: EMPTY
62695: LIST
62696: LIST
62697: PUSH
62698: LD_INT 30
62700: PUSH
62701: LD_INT 7
62703: PUSH
62704: EMPTY
62705: LIST
62706: LIST
62707: PUSH
62708: LD_INT 30
62710: PUSH
62711: LD_INT 8
62713: PUSH
62714: EMPTY
62715: LIST
62716: LIST
62717: PUSH
62718: EMPTY
62719: LIST
62720: LIST
62721: LIST
62722: LIST
62723: PPUSH
62724: CALL_OW 72
62728: NOT
62729: PUSH
62730: LD_EXP 61
62734: PUSH
62735: LD_VAR 0 1
62739: ARRAY
62740: PPUSH
62741: LD_INT 30
62743: PUSH
62744: LD_INT 3
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: PPUSH
62751: CALL_OW 72
62755: NOT
62756: AND
62757: IFFALSE 62829
// begin if eng = tmp then
62759: LD_VAR 0 6
62763: PUSH
62764: LD_VAR 0 4
62768: EQUAL
62769: IFFALSE 62773
// exit ;
62771: GO 65362
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62773: LD_ADDR_EXP 103
62777: PUSH
62778: LD_EXP 103
62782: PPUSH
62783: LD_VAR 0 1
62787: PPUSH
62788: LD_INT 1
62790: PPUSH
62791: CALL_OW 1
62795: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62796: LD_ADDR_VAR 0 2
62800: PUSH
62801: LD_INT 0
62803: PUSH
62804: LD_VAR 0 4
62808: PUSH
62809: LD_VAR 0 6
62813: DIFF
62814: PUSH
62815: LD_INT 0
62817: PUSH
62818: LD_INT 0
62820: PUSH
62821: EMPTY
62822: LIST
62823: LIST
62824: LIST
62825: LIST
62826: ST_TO_ADDR
// exit ;
62827: GO 65362
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62829: LD_EXP 88
62833: PUSH
62834: LD_EXP 87
62838: PUSH
62839: LD_VAR 0 1
62843: ARRAY
62844: ARRAY
62845: PUSH
62846: LD_EXP 61
62850: PUSH
62851: LD_VAR 0 1
62855: ARRAY
62856: PPUSH
62857: LD_INT 2
62859: PUSH
62860: LD_INT 30
62862: PUSH
62863: LD_INT 6
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 30
62872: PUSH
62873: LD_INT 7
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 30
62882: PUSH
62883: LD_INT 8
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: EMPTY
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: PPUSH
62896: CALL_OW 72
62900: AND
62901: PUSH
62902: LD_EXP 61
62906: PUSH
62907: LD_VAR 0 1
62911: ARRAY
62912: PPUSH
62913: LD_INT 30
62915: PUSH
62916: LD_INT 3
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: PPUSH
62923: CALL_OW 72
62927: NOT
62928: AND
62929: IFFALSE 63143
// begin if sci >= 6 then
62931: LD_VAR 0 8
62935: PUSH
62936: LD_INT 6
62938: GREATEREQUAL
62939: IFFALSE 62943
// exit ;
62941: GO 65362
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
62943: LD_ADDR_EXP 103
62947: PUSH
62948: LD_EXP 103
62952: PPUSH
62953: LD_VAR 0 1
62957: PPUSH
62958: LD_INT 2
62960: PPUSH
62961: CALL_OW 1
62965: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
62966: LD_ADDR_VAR 0 9
62970: PUSH
62971: LD_VAR 0 4
62975: PUSH
62976: LD_VAR 0 8
62980: DIFF
62981: PPUSH
62982: LD_INT 4
62984: PPUSH
62985: CALL 51319 0 2
62989: ST_TO_ADDR
// p := [ ] ;
62990: LD_ADDR_VAR 0 11
62994: PUSH
62995: EMPTY
62996: ST_TO_ADDR
// if sci < 6 and sort > 6 then
62997: LD_VAR 0 8
63001: PUSH
63002: LD_INT 6
63004: LESS
63005: PUSH
63006: LD_VAR 0 9
63010: PUSH
63011: LD_INT 6
63013: GREATER
63014: AND
63015: IFFALSE 63096
// begin for i = 1 to 6 - sci do
63017: LD_ADDR_VAR 0 3
63021: PUSH
63022: DOUBLE
63023: LD_INT 1
63025: DEC
63026: ST_TO_ADDR
63027: LD_INT 6
63029: PUSH
63030: LD_VAR 0 8
63034: MINUS
63035: PUSH
63036: FOR_TO
63037: IFFALSE 63092
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63039: LD_ADDR_VAR 0 11
63043: PUSH
63044: LD_VAR 0 11
63048: PPUSH
63049: LD_VAR 0 11
63053: PUSH
63054: LD_INT 1
63056: PLUS
63057: PPUSH
63058: LD_VAR 0 9
63062: PUSH
63063: LD_INT 1
63065: ARRAY
63066: PPUSH
63067: CALL_OW 2
63071: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63072: LD_ADDR_VAR 0 9
63076: PUSH
63077: LD_VAR 0 9
63081: PPUSH
63082: LD_INT 1
63084: PPUSH
63085: CALL_OW 3
63089: ST_TO_ADDR
// end ;
63090: GO 63036
63092: POP
63093: POP
// end else
63094: GO 63116
// if sort then
63096: LD_VAR 0 9
63100: IFFALSE 63116
// p := sort [ 1 ] ;
63102: LD_ADDR_VAR 0 11
63106: PUSH
63107: LD_VAR 0 9
63111: PUSH
63112: LD_INT 1
63114: ARRAY
63115: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63116: LD_ADDR_VAR 0 2
63120: PUSH
63121: LD_INT 0
63123: PUSH
63124: LD_INT 0
63126: PUSH
63127: LD_INT 0
63129: PUSH
63130: LD_VAR 0 11
63134: PUSH
63135: EMPTY
63136: LIST
63137: LIST
63138: LIST
63139: LIST
63140: ST_TO_ADDR
// exit ;
63141: GO 65362
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63143: LD_EXP 88
63147: PUSH
63148: LD_EXP 87
63152: PUSH
63153: LD_VAR 0 1
63157: ARRAY
63158: ARRAY
63159: PUSH
63160: LD_EXP 61
63164: PUSH
63165: LD_VAR 0 1
63169: ARRAY
63170: PPUSH
63171: LD_INT 2
63173: PUSH
63174: LD_INT 30
63176: PUSH
63177: LD_INT 6
63179: PUSH
63180: EMPTY
63181: LIST
63182: LIST
63183: PUSH
63184: LD_INT 30
63186: PUSH
63187: LD_INT 7
63189: PUSH
63190: EMPTY
63191: LIST
63192: LIST
63193: PUSH
63194: LD_INT 30
63196: PUSH
63197: LD_INT 8
63199: PUSH
63200: EMPTY
63201: LIST
63202: LIST
63203: PUSH
63204: EMPTY
63205: LIST
63206: LIST
63207: LIST
63208: LIST
63209: PPUSH
63210: CALL_OW 72
63214: AND
63215: PUSH
63216: LD_EXP 61
63220: PUSH
63221: LD_VAR 0 1
63225: ARRAY
63226: PPUSH
63227: LD_INT 30
63229: PUSH
63230: LD_INT 3
63232: PUSH
63233: EMPTY
63234: LIST
63235: LIST
63236: PPUSH
63237: CALL_OW 72
63241: AND
63242: IFFALSE 63976
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63244: LD_ADDR_EXP 103
63248: PUSH
63249: LD_EXP 103
63253: PPUSH
63254: LD_VAR 0 1
63258: PPUSH
63259: LD_INT 3
63261: PPUSH
63262: CALL_OW 1
63266: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63267: LD_ADDR_VAR 0 2
63271: PUSH
63272: LD_INT 0
63274: PUSH
63275: LD_INT 0
63277: PUSH
63278: LD_INT 0
63280: PUSH
63281: LD_INT 0
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: LIST
63288: LIST
63289: ST_TO_ADDR
// if not eng then
63290: LD_VAR 0 6
63294: NOT
63295: IFFALSE 63358
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63297: LD_ADDR_VAR 0 11
63301: PUSH
63302: LD_VAR 0 4
63306: PPUSH
63307: LD_INT 2
63309: PPUSH
63310: CALL 51319 0 2
63314: PUSH
63315: LD_INT 1
63317: ARRAY
63318: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63319: LD_ADDR_VAR 0 2
63323: PUSH
63324: LD_VAR 0 2
63328: PPUSH
63329: LD_INT 2
63331: PPUSH
63332: LD_VAR 0 11
63336: PPUSH
63337: CALL_OW 1
63341: ST_TO_ADDR
// tmp := tmp diff p ;
63342: LD_ADDR_VAR 0 4
63346: PUSH
63347: LD_VAR 0 4
63351: PUSH
63352: LD_VAR 0 11
63356: DIFF
63357: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63358: LD_VAR 0 4
63362: PUSH
63363: LD_VAR 0 8
63367: PUSH
63368: LD_INT 6
63370: LESS
63371: AND
63372: IFFALSE 63560
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63374: LD_ADDR_VAR 0 9
63378: PUSH
63379: LD_VAR 0 4
63383: PUSH
63384: LD_VAR 0 8
63388: PUSH
63389: LD_VAR 0 7
63393: UNION
63394: DIFF
63395: PPUSH
63396: LD_INT 4
63398: PPUSH
63399: CALL 51319 0 2
63403: ST_TO_ADDR
// p := [ ] ;
63404: LD_ADDR_VAR 0 11
63408: PUSH
63409: EMPTY
63410: ST_TO_ADDR
// if sort then
63411: LD_VAR 0 9
63415: IFFALSE 63531
// for i = 1 to 6 - sci do
63417: LD_ADDR_VAR 0 3
63421: PUSH
63422: DOUBLE
63423: LD_INT 1
63425: DEC
63426: ST_TO_ADDR
63427: LD_INT 6
63429: PUSH
63430: LD_VAR 0 8
63434: MINUS
63435: PUSH
63436: FOR_TO
63437: IFFALSE 63529
// begin if i = sort then
63439: LD_VAR 0 3
63443: PUSH
63444: LD_VAR 0 9
63448: EQUAL
63449: IFFALSE 63453
// break ;
63451: GO 63529
// if GetClass ( i ) = 4 then
63453: LD_VAR 0 3
63457: PPUSH
63458: CALL_OW 257
63462: PUSH
63463: LD_INT 4
63465: EQUAL
63466: IFFALSE 63470
// continue ;
63468: GO 63436
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63470: LD_ADDR_VAR 0 11
63474: PUSH
63475: LD_VAR 0 11
63479: PPUSH
63480: LD_VAR 0 11
63484: PUSH
63485: LD_INT 1
63487: PLUS
63488: PPUSH
63489: LD_VAR 0 9
63493: PUSH
63494: LD_VAR 0 3
63498: ARRAY
63499: PPUSH
63500: CALL_OW 2
63504: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63505: LD_ADDR_VAR 0 4
63509: PUSH
63510: LD_VAR 0 4
63514: PUSH
63515: LD_VAR 0 9
63519: PUSH
63520: LD_VAR 0 3
63524: ARRAY
63525: DIFF
63526: ST_TO_ADDR
// end ;
63527: GO 63436
63529: POP
63530: POP
// if p then
63531: LD_VAR 0 11
63535: IFFALSE 63560
// result := Replace ( result , 4 , p ) ;
63537: LD_ADDR_VAR 0 2
63541: PUSH
63542: LD_VAR 0 2
63546: PPUSH
63547: LD_INT 4
63549: PPUSH
63550: LD_VAR 0 11
63554: PPUSH
63555: CALL_OW 1
63559: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63560: LD_VAR 0 4
63564: PUSH
63565: LD_VAR 0 7
63569: PUSH
63570: LD_INT 6
63572: LESS
63573: AND
63574: IFFALSE 63762
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63576: LD_ADDR_VAR 0 9
63580: PUSH
63581: LD_VAR 0 4
63585: PUSH
63586: LD_VAR 0 8
63590: PUSH
63591: LD_VAR 0 7
63595: UNION
63596: DIFF
63597: PPUSH
63598: LD_INT 3
63600: PPUSH
63601: CALL 51319 0 2
63605: ST_TO_ADDR
// p := [ ] ;
63606: LD_ADDR_VAR 0 11
63610: PUSH
63611: EMPTY
63612: ST_TO_ADDR
// if sort then
63613: LD_VAR 0 9
63617: IFFALSE 63733
// for i = 1 to 6 - mech do
63619: LD_ADDR_VAR 0 3
63623: PUSH
63624: DOUBLE
63625: LD_INT 1
63627: DEC
63628: ST_TO_ADDR
63629: LD_INT 6
63631: PUSH
63632: LD_VAR 0 7
63636: MINUS
63637: PUSH
63638: FOR_TO
63639: IFFALSE 63731
// begin if i = sort then
63641: LD_VAR 0 3
63645: PUSH
63646: LD_VAR 0 9
63650: EQUAL
63651: IFFALSE 63655
// break ;
63653: GO 63731
// if GetClass ( i ) = 3 then
63655: LD_VAR 0 3
63659: PPUSH
63660: CALL_OW 257
63664: PUSH
63665: LD_INT 3
63667: EQUAL
63668: IFFALSE 63672
// continue ;
63670: GO 63638
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63672: LD_ADDR_VAR 0 11
63676: PUSH
63677: LD_VAR 0 11
63681: PPUSH
63682: LD_VAR 0 11
63686: PUSH
63687: LD_INT 1
63689: PLUS
63690: PPUSH
63691: LD_VAR 0 9
63695: PUSH
63696: LD_VAR 0 3
63700: ARRAY
63701: PPUSH
63702: CALL_OW 2
63706: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63707: LD_ADDR_VAR 0 4
63711: PUSH
63712: LD_VAR 0 4
63716: PUSH
63717: LD_VAR 0 9
63721: PUSH
63722: LD_VAR 0 3
63726: ARRAY
63727: DIFF
63728: ST_TO_ADDR
// end ;
63729: GO 63638
63731: POP
63732: POP
// if p then
63733: LD_VAR 0 11
63737: IFFALSE 63762
// result := Replace ( result , 3 , p ) ;
63739: LD_ADDR_VAR 0 2
63743: PUSH
63744: LD_VAR 0 2
63748: PPUSH
63749: LD_INT 3
63751: PPUSH
63752: LD_VAR 0 11
63756: PPUSH
63757: CALL_OW 1
63761: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63762: LD_VAR 0 4
63766: PUSH
63767: LD_INT 6
63769: GREATER
63770: PUSH
63771: LD_VAR 0 6
63775: PUSH
63776: LD_INT 6
63778: LESS
63779: AND
63780: IFFALSE 63974
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63782: LD_ADDR_VAR 0 9
63786: PUSH
63787: LD_VAR 0 4
63791: PUSH
63792: LD_VAR 0 8
63796: PUSH
63797: LD_VAR 0 7
63801: UNION
63802: PUSH
63803: LD_VAR 0 6
63807: UNION
63808: DIFF
63809: PPUSH
63810: LD_INT 2
63812: PPUSH
63813: CALL 51319 0 2
63817: ST_TO_ADDR
// p := [ ] ;
63818: LD_ADDR_VAR 0 11
63822: PUSH
63823: EMPTY
63824: ST_TO_ADDR
// if sort then
63825: LD_VAR 0 9
63829: IFFALSE 63945
// for i = 1 to 6 - eng do
63831: LD_ADDR_VAR 0 3
63835: PUSH
63836: DOUBLE
63837: LD_INT 1
63839: DEC
63840: ST_TO_ADDR
63841: LD_INT 6
63843: PUSH
63844: LD_VAR 0 6
63848: MINUS
63849: PUSH
63850: FOR_TO
63851: IFFALSE 63943
// begin if i = sort then
63853: LD_VAR 0 3
63857: PUSH
63858: LD_VAR 0 9
63862: EQUAL
63863: IFFALSE 63867
// break ;
63865: GO 63943
// if GetClass ( i ) = 2 then
63867: LD_VAR 0 3
63871: PPUSH
63872: CALL_OW 257
63876: PUSH
63877: LD_INT 2
63879: EQUAL
63880: IFFALSE 63884
// continue ;
63882: GO 63850
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63884: LD_ADDR_VAR 0 11
63888: PUSH
63889: LD_VAR 0 11
63893: PPUSH
63894: LD_VAR 0 11
63898: PUSH
63899: LD_INT 1
63901: PLUS
63902: PPUSH
63903: LD_VAR 0 9
63907: PUSH
63908: LD_VAR 0 3
63912: ARRAY
63913: PPUSH
63914: CALL_OW 2
63918: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63919: LD_ADDR_VAR 0 4
63923: PUSH
63924: LD_VAR 0 4
63928: PUSH
63929: LD_VAR 0 9
63933: PUSH
63934: LD_VAR 0 3
63938: ARRAY
63939: DIFF
63940: ST_TO_ADDR
// end ;
63941: GO 63850
63943: POP
63944: POP
// if p then
63945: LD_VAR 0 11
63949: IFFALSE 63974
// result := Replace ( result , 2 , p ) ;
63951: LD_ADDR_VAR 0 2
63955: PUSH
63956: LD_VAR 0 2
63960: PPUSH
63961: LD_INT 2
63963: PPUSH
63964: LD_VAR 0 11
63968: PPUSH
63969: CALL_OW 1
63973: ST_TO_ADDR
// end ; exit ;
63974: GO 65362
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
63976: LD_EXP 88
63980: PUSH
63981: LD_EXP 87
63985: PUSH
63986: LD_VAR 0 1
63990: ARRAY
63991: ARRAY
63992: NOT
63993: PUSH
63994: LD_EXP 61
63998: PUSH
63999: LD_VAR 0 1
64003: ARRAY
64004: PPUSH
64005: LD_INT 30
64007: PUSH
64008: LD_INT 3
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PPUSH
64015: CALL_OW 72
64019: AND
64020: PUSH
64021: LD_EXP 66
64025: PUSH
64026: LD_VAR 0 1
64030: ARRAY
64031: AND
64032: IFFALSE 64640
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64034: LD_ADDR_EXP 103
64038: PUSH
64039: LD_EXP 103
64043: PPUSH
64044: LD_VAR 0 1
64048: PPUSH
64049: LD_INT 5
64051: PPUSH
64052: CALL_OW 1
64056: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64057: LD_ADDR_VAR 0 2
64061: PUSH
64062: LD_INT 0
64064: PUSH
64065: LD_INT 0
64067: PUSH
64068: LD_INT 0
64070: PUSH
64071: LD_INT 0
64073: PUSH
64074: EMPTY
64075: LIST
64076: LIST
64077: LIST
64078: LIST
64079: ST_TO_ADDR
// if sci > 1 then
64080: LD_VAR 0 8
64084: PUSH
64085: LD_INT 1
64087: GREATER
64088: IFFALSE 64116
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64090: LD_ADDR_VAR 0 4
64094: PUSH
64095: LD_VAR 0 4
64099: PUSH
64100: LD_VAR 0 8
64104: PUSH
64105: LD_VAR 0 8
64109: PUSH
64110: LD_INT 1
64112: ARRAY
64113: DIFF
64114: DIFF
64115: ST_TO_ADDR
// if tmp and not sci then
64116: LD_VAR 0 4
64120: PUSH
64121: LD_VAR 0 8
64125: NOT
64126: AND
64127: IFFALSE 64196
// begin sort := SortBySkill ( tmp , 4 ) ;
64129: LD_ADDR_VAR 0 9
64133: PUSH
64134: LD_VAR 0 4
64138: PPUSH
64139: LD_INT 4
64141: PPUSH
64142: CALL 51319 0 2
64146: ST_TO_ADDR
// if sort then
64147: LD_VAR 0 9
64151: IFFALSE 64167
// p := sort [ 1 ] ;
64153: LD_ADDR_VAR 0 11
64157: PUSH
64158: LD_VAR 0 9
64162: PUSH
64163: LD_INT 1
64165: ARRAY
64166: ST_TO_ADDR
// if p then
64167: LD_VAR 0 11
64171: IFFALSE 64196
// result := Replace ( result , 4 , p ) ;
64173: LD_ADDR_VAR 0 2
64177: PUSH
64178: LD_VAR 0 2
64182: PPUSH
64183: LD_INT 4
64185: PPUSH
64186: LD_VAR 0 11
64190: PPUSH
64191: CALL_OW 1
64195: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64196: LD_ADDR_VAR 0 4
64200: PUSH
64201: LD_VAR 0 4
64205: PUSH
64206: LD_VAR 0 7
64210: DIFF
64211: ST_TO_ADDR
// if tmp and mech < 6 then
64212: LD_VAR 0 4
64216: PUSH
64217: LD_VAR 0 7
64221: PUSH
64222: LD_INT 6
64224: LESS
64225: AND
64226: IFFALSE 64414
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64228: LD_ADDR_VAR 0 9
64232: PUSH
64233: LD_VAR 0 4
64237: PUSH
64238: LD_VAR 0 8
64242: PUSH
64243: LD_VAR 0 7
64247: UNION
64248: DIFF
64249: PPUSH
64250: LD_INT 3
64252: PPUSH
64253: CALL 51319 0 2
64257: ST_TO_ADDR
// p := [ ] ;
64258: LD_ADDR_VAR 0 11
64262: PUSH
64263: EMPTY
64264: ST_TO_ADDR
// if sort then
64265: LD_VAR 0 9
64269: IFFALSE 64385
// for i = 1 to 6 - mech do
64271: LD_ADDR_VAR 0 3
64275: PUSH
64276: DOUBLE
64277: LD_INT 1
64279: DEC
64280: ST_TO_ADDR
64281: LD_INT 6
64283: PUSH
64284: LD_VAR 0 7
64288: MINUS
64289: PUSH
64290: FOR_TO
64291: IFFALSE 64383
// begin if i = sort then
64293: LD_VAR 0 3
64297: PUSH
64298: LD_VAR 0 9
64302: EQUAL
64303: IFFALSE 64307
// break ;
64305: GO 64383
// if GetClass ( i ) = 3 then
64307: LD_VAR 0 3
64311: PPUSH
64312: CALL_OW 257
64316: PUSH
64317: LD_INT 3
64319: EQUAL
64320: IFFALSE 64324
// continue ;
64322: GO 64290
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64324: LD_ADDR_VAR 0 11
64328: PUSH
64329: LD_VAR 0 11
64333: PPUSH
64334: LD_VAR 0 11
64338: PUSH
64339: LD_INT 1
64341: PLUS
64342: PPUSH
64343: LD_VAR 0 9
64347: PUSH
64348: LD_VAR 0 3
64352: ARRAY
64353: PPUSH
64354: CALL_OW 2
64358: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64359: LD_ADDR_VAR 0 4
64363: PUSH
64364: LD_VAR 0 4
64368: PUSH
64369: LD_VAR 0 9
64373: PUSH
64374: LD_VAR 0 3
64378: ARRAY
64379: DIFF
64380: ST_TO_ADDR
// end ;
64381: GO 64290
64383: POP
64384: POP
// if p then
64385: LD_VAR 0 11
64389: IFFALSE 64414
// result := Replace ( result , 3 , p ) ;
64391: LD_ADDR_VAR 0 2
64395: PUSH
64396: LD_VAR 0 2
64400: PPUSH
64401: LD_INT 3
64403: PPUSH
64404: LD_VAR 0 11
64408: PPUSH
64409: CALL_OW 1
64413: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64414: LD_ADDR_VAR 0 4
64418: PUSH
64419: LD_VAR 0 4
64423: PUSH
64424: LD_VAR 0 6
64428: DIFF
64429: ST_TO_ADDR
// if tmp and eng < 6 then
64430: LD_VAR 0 4
64434: PUSH
64435: LD_VAR 0 6
64439: PUSH
64440: LD_INT 6
64442: LESS
64443: AND
64444: IFFALSE 64638
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64446: LD_ADDR_VAR 0 9
64450: PUSH
64451: LD_VAR 0 4
64455: PUSH
64456: LD_VAR 0 8
64460: PUSH
64461: LD_VAR 0 7
64465: UNION
64466: PUSH
64467: LD_VAR 0 6
64471: UNION
64472: DIFF
64473: PPUSH
64474: LD_INT 2
64476: PPUSH
64477: CALL 51319 0 2
64481: ST_TO_ADDR
// p := [ ] ;
64482: LD_ADDR_VAR 0 11
64486: PUSH
64487: EMPTY
64488: ST_TO_ADDR
// if sort then
64489: LD_VAR 0 9
64493: IFFALSE 64609
// for i = 1 to 6 - eng do
64495: LD_ADDR_VAR 0 3
64499: PUSH
64500: DOUBLE
64501: LD_INT 1
64503: DEC
64504: ST_TO_ADDR
64505: LD_INT 6
64507: PUSH
64508: LD_VAR 0 6
64512: MINUS
64513: PUSH
64514: FOR_TO
64515: IFFALSE 64607
// begin if i = sort then
64517: LD_VAR 0 3
64521: PUSH
64522: LD_VAR 0 9
64526: EQUAL
64527: IFFALSE 64531
// break ;
64529: GO 64607
// if GetClass ( i ) = 2 then
64531: LD_VAR 0 3
64535: PPUSH
64536: CALL_OW 257
64540: PUSH
64541: LD_INT 2
64543: EQUAL
64544: IFFALSE 64548
// continue ;
64546: GO 64514
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64548: LD_ADDR_VAR 0 11
64552: PUSH
64553: LD_VAR 0 11
64557: PPUSH
64558: LD_VAR 0 11
64562: PUSH
64563: LD_INT 1
64565: PLUS
64566: PPUSH
64567: LD_VAR 0 9
64571: PUSH
64572: LD_VAR 0 3
64576: ARRAY
64577: PPUSH
64578: CALL_OW 2
64582: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64583: LD_ADDR_VAR 0 4
64587: PUSH
64588: LD_VAR 0 4
64592: PUSH
64593: LD_VAR 0 9
64597: PUSH
64598: LD_VAR 0 3
64602: ARRAY
64603: DIFF
64604: ST_TO_ADDR
// end ;
64605: GO 64514
64607: POP
64608: POP
// if p then
64609: LD_VAR 0 11
64613: IFFALSE 64638
// result := Replace ( result , 2 , p ) ;
64615: LD_ADDR_VAR 0 2
64619: PUSH
64620: LD_VAR 0 2
64624: PPUSH
64625: LD_INT 2
64627: PPUSH
64628: LD_VAR 0 11
64632: PPUSH
64633: CALL_OW 1
64637: ST_TO_ADDR
// end ; exit ;
64638: GO 65362
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64640: LD_EXP 88
64644: PUSH
64645: LD_EXP 87
64649: PUSH
64650: LD_VAR 0 1
64654: ARRAY
64655: ARRAY
64656: NOT
64657: PUSH
64658: LD_EXP 61
64662: PUSH
64663: LD_VAR 0 1
64667: ARRAY
64668: PPUSH
64669: LD_INT 30
64671: PUSH
64672: LD_INT 3
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: PPUSH
64679: CALL_OW 72
64683: AND
64684: PUSH
64685: LD_EXP 66
64689: PUSH
64690: LD_VAR 0 1
64694: ARRAY
64695: NOT
64696: AND
64697: IFFALSE 65362
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64699: LD_ADDR_EXP 103
64703: PUSH
64704: LD_EXP 103
64708: PPUSH
64709: LD_VAR 0 1
64713: PPUSH
64714: LD_INT 6
64716: PPUSH
64717: CALL_OW 1
64721: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64722: LD_ADDR_VAR 0 2
64726: PUSH
64727: LD_INT 0
64729: PUSH
64730: LD_INT 0
64732: PUSH
64733: LD_INT 0
64735: PUSH
64736: LD_INT 0
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: LIST
64743: LIST
64744: ST_TO_ADDR
// if sci >= 1 then
64745: LD_VAR 0 8
64749: PUSH
64750: LD_INT 1
64752: GREATEREQUAL
64753: IFFALSE 64775
// tmp := tmp diff sci [ 1 ] ;
64755: LD_ADDR_VAR 0 4
64759: PUSH
64760: LD_VAR 0 4
64764: PUSH
64765: LD_VAR 0 8
64769: PUSH
64770: LD_INT 1
64772: ARRAY
64773: DIFF
64774: ST_TO_ADDR
// if tmp and not sci then
64775: LD_VAR 0 4
64779: PUSH
64780: LD_VAR 0 8
64784: NOT
64785: AND
64786: IFFALSE 64855
// begin sort := SortBySkill ( tmp , 4 ) ;
64788: LD_ADDR_VAR 0 9
64792: PUSH
64793: LD_VAR 0 4
64797: PPUSH
64798: LD_INT 4
64800: PPUSH
64801: CALL 51319 0 2
64805: ST_TO_ADDR
// if sort then
64806: LD_VAR 0 9
64810: IFFALSE 64826
// p := sort [ 1 ] ;
64812: LD_ADDR_VAR 0 11
64816: PUSH
64817: LD_VAR 0 9
64821: PUSH
64822: LD_INT 1
64824: ARRAY
64825: ST_TO_ADDR
// if p then
64826: LD_VAR 0 11
64830: IFFALSE 64855
// result := Replace ( result , 4 , p ) ;
64832: LD_ADDR_VAR 0 2
64836: PUSH
64837: LD_VAR 0 2
64841: PPUSH
64842: LD_INT 4
64844: PPUSH
64845: LD_VAR 0 11
64849: PPUSH
64850: CALL_OW 1
64854: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64855: LD_ADDR_VAR 0 4
64859: PUSH
64860: LD_VAR 0 4
64864: PUSH
64865: LD_VAR 0 7
64869: DIFF
64870: ST_TO_ADDR
// if tmp and mech < 6 then
64871: LD_VAR 0 4
64875: PUSH
64876: LD_VAR 0 7
64880: PUSH
64881: LD_INT 6
64883: LESS
64884: AND
64885: IFFALSE 65067
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64887: LD_ADDR_VAR 0 9
64891: PUSH
64892: LD_VAR 0 4
64896: PUSH
64897: LD_VAR 0 7
64901: DIFF
64902: PPUSH
64903: LD_INT 3
64905: PPUSH
64906: CALL 51319 0 2
64910: ST_TO_ADDR
// p := [ ] ;
64911: LD_ADDR_VAR 0 11
64915: PUSH
64916: EMPTY
64917: ST_TO_ADDR
// if sort then
64918: LD_VAR 0 9
64922: IFFALSE 65038
// for i = 1 to 6 - mech do
64924: LD_ADDR_VAR 0 3
64928: PUSH
64929: DOUBLE
64930: LD_INT 1
64932: DEC
64933: ST_TO_ADDR
64934: LD_INT 6
64936: PUSH
64937: LD_VAR 0 7
64941: MINUS
64942: PUSH
64943: FOR_TO
64944: IFFALSE 65036
// begin if i = sort then
64946: LD_VAR 0 3
64950: PUSH
64951: LD_VAR 0 9
64955: EQUAL
64956: IFFALSE 64960
// break ;
64958: GO 65036
// if GetClass ( i ) = 3 then
64960: LD_VAR 0 3
64964: PPUSH
64965: CALL_OW 257
64969: PUSH
64970: LD_INT 3
64972: EQUAL
64973: IFFALSE 64977
// continue ;
64975: GO 64943
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64977: LD_ADDR_VAR 0 11
64981: PUSH
64982: LD_VAR 0 11
64986: PPUSH
64987: LD_VAR 0 11
64991: PUSH
64992: LD_INT 1
64994: PLUS
64995: PPUSH
64996: LD_VAR 0 9
65000: PUSH
65001: LD_VAR 0 3
65005: ARRAY
65006: PPUSH
65007: CALL_OW 2
65011: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65012: LD_ADDR_VAR 0 4
65016: PUSH
65017: LD_VAR 0 4
65021: PUSH
65022: LD_VAR 0 9
65026: PUSH
65027: LD_VAR 0 3
65031: ARRAY
65032: DIFF
65033: ST_TO_ADDR
// end ;
65034: GO 64943
65036: POP
65037: POP
// if p then
65038: LD_VAR 0 11
65042: IFFALSE 65067
// result := Replace ( result , 3 , p ) ;
65044: LD_ADDR_VAR 0 2
65048: PUSH
65049: LD_VAR 0 2
65053: PPUSH
65054: LD_INT 3
65056: PPUSH
65057: LD_VAR 0 11
65061: PPUSH
65062: CALL_OW 1
65066: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65067: LD_ADDR_VAR 0 4
65071: PUSH
65072: LD_VAR 0 4
65076: PUSH
65077: LD_VAR 0 6
65081: DIFF
65082: ST_TO_ADDR
// if tmp and eng < 4 then
65083: LD_VAR 0 4
65087: PUSH
65088: LD_VAR 0 6
65092: PUSH
65093: LD_INT 4
65095: LESS
65096: AND
65097: IFFALSE 65287
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65099: LD_ADDR_VAR 0 9
65103: PUSH
65104: LD_VAR 0 4
65108: PUSH
65109: LD_VAR 0 7
65113: PUSH
65114: LD_VAR 0 6
65118: UNION
65119: DIFF
65120: PPUSH
65121: LD_INT 2
65123: PPUSH
65124: CALL 51319 0 2
65128: ST_TO_ADDR
// p := [ ] ;
65129: LD_ADDR_VAR 0 11
65133: PUSH
65134: EMPTY
65135: ST_TO_ADDR
// if sort then
65136: LD_VAR 0 9
65140: IFFALSE 65256
// for i = 1 to 4 - eng do
65142: LD_ADDR_VAR 0 3
65146: PUSH
65147: DOUBLE
65148: LD_INT 1
65150: DEC
65151: ST_TO_ADDR
65152: LD_INT 4
65154: PUSH
65155: LD_VAR 0 6
65159: MINUS
65160: PUSH
65161: FOR_TO
65162: IFFALSE 65254
// begin if i = sort then
65164: LD_VAR 0 3
65168: PUSH
65169: LD_VAR 0 9
65173: EQUAL
65174: IFFALSE 65178
// break ;
65176: GO 65254
// if GetClass ( i ) = 2 then
65178: LD_VAR 0 3
65182: PPUSH
65183: CALL_OW 257
65187: PUSH
65188: LD_INT 2
65190: EQUAL
65191: IFFALSE 65195
// continue ;
65193: GO 65161
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65195: LD_ADDR_VAR 0 11
65199: PUSH
65200: LD_VAR 0 11
65204: PPUSH
65205: LD_VAR 0 11
65209: PUSH
65210: LD_INT 1
65212: PLUS
65213: PPUSH
65214: LD_VAR 0 9
65218: PUSH
65219: LD_VAR 0 3
65223: ARRAY
65224: PPUSH
65225: CALL_OW 2
65229: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65230: LD_ADDR_VAR 0 4
65234: PUSH
65235: LD_VAR 0 4
65239: PUSH
65240: LD_VAR 0 9
65244: PUSH
65245: LD_VAR 0 3
65249: ARRAY
65250: DIFF
65251: ST_TO_ADDR
// end ;
65252: GO 65161
65254: POP
65255: POP
// if p then
65256: LD_VAR 0 11
65260: IFFALSE 65285
// result := Replace ( result , 2 , p ) ;
65262: LD_ADDR_VAR 0 2
65266: PUSH
65267: LD_VAR 0 2
65271: PPUSH
65272: LD_INT 2
65274: PPUSH
65275: LD_VAR 0 11
65279: PPUSH
65280: CALL_OW 1
65284: ST_TO_ADDR
// end else
65285: GO 65331
// for i = eng downto 5 do
65287: LD_ADDR_VAR 0 3
65291: PUSH
65292: DOUBLE
65293: LD_VAR 0 6
65297: INC
65298: ST_TO_ADDR
65299: LD_INT 5
65301: PUSH
65302: FOR_DOWNTO
65303: IFFALSE 65329
// tmp := tmp union eng [ i ] ;
65305: LD_ADDR_VAR 0 4
65309: PUSH
65310: LD_VAR 0 4
65314: PUSH
65315: LD_VAR 0 6
65319: PUSH
65320: LD_VAR 0 3
65324: ARRAY
65325: UNION
65326: ST_TO_ADDR
65327: GO 65302
65329: POP
65330: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65331: LD_ADDR_VAR 0 2
65335: PUSH
65336: LD_VAR 0 2
65340: PPUSH
65341: LD_INT 1
65343: PPUSH
65344: LD_VAR 0 4
65348: PUSH
65349: LD_VAR 0 5
65353: DIFF
65354: PPUSH
65355: CALL_OW 1
65359: ST_TO_ADDR
// exit ;
65360: GO 65362
// end ; end ;
65362: LD_VAR 0 2
65366: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65367: LD_INT 0
65369: PPUSH
65370: PPUSH
65371: PPUSH
// if not mc_bases then
65372: LD_EXP 61
65376: NOT
65377: IFFALSE 65381
// exit ;
65379: GO 65523
// for i = 1 to mc_bases do
65381: LD_ADDR_VAR 0 2
65385: PUSH
65386: DOUBLE
65387: LD_INT 1
65389: DEC
65390: ST_TO_ADDR
65391: LD_EXP 61
65395: PUSH
65396: FOR_TO
65397: IFFALSE 65514
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65399: LD_ADDR_VAR 0 3
65403: PUSH
65404: LD_EXP 61
65408: PUSH
65409: LD_VAR 0 2
65413: ARRAY
65414: PPUSH
65415: LD_INT 21
65417: PUSH
65418: LD_INT 3
65420: PUSH
65421: EMPTY
65422: LIST
65423: LIST
65424: PUSH
65425: LD_INT 3
65427: PUSH
65428: LD_INT 2
65430: PUSH
65431: LD_INT 30
65433: PUSH
65434: LD_INT 29
65436: PUSH
65437: EMPTY
65438: LIST
65439: LIST
65440: PUSH
65441: LD_INT 30
65443: PUSH
65444: LD_INT 30
65446: PUSH
65447: EMPTY
65448: LIST
65449: LIST
65450: PUSH
65451: EMPTY
65452: LIST
65453: LIST
65454: LIST
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 3
65462: PUSH
65463: LD_INT 24
65465: PUSH
65466: LD_INT 1000
65468: PUSH
65469: EMPTY
65470: LIST
65471: LIST
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: EMPTY
65478: LIST
65479: LIST
65480: LIST
65481: PPUSH
65482: CALL_OW 72
65486: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65487: LD_ADDR_EXP 62
65491: PUSH
65492: LD_EXP 62
65496: PPUSH
65497: LD_VAR 0 2
65501: PPUSH
65502: LD_VAR 0 3
65506: PPUSH
65507: CALL_OW 1
65511: ST_TO_ADDR
// end ;
65512: GO 65396
65514: POP
65515: POP
// RaiseSailEvent ( 101 ) ;
65516: LD_INT 101
65518: PPUSH
65519: CALL_OW 427
// end ;
65523: LD_VAR 0 1
65527: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65528: LD_INT 0
65530: PPUSH
65531: PPUSH
65532: PPUSH
65533: PPUSH
65534: PPUSH
65535: PPUSH
65536: PPUSH
// if not mc_bases then
65537: LD_EXP 61
65541: NOT
65542: IFFALSE 65546
// exit ;
65544: GO 66108
// for i = 1 to mc_bases do
65546: LD_ADDR_VAR 0 2
65550: PUSH
65551: DOUBLE
65552: LD_INT 1
65554: DEC
65555: ST_TO_ADDR
65556: LD_EXP 61
65560: PUSH
65561: FOR_TO
65562: IFFALSE 66099
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
65564: LD_ADDR_VAR 0 5
65568: PUSH
65569: LD_EXP 61
65573: PUSH
65574: LD_VAR 0 2
65578: ARRAY
65579: PUSH
65580: LD_EXP 90
65584: PUSH
65585: LD_VAR 0 2
65589: ARRAY
65590: UNION
65591: PPUSH
65592: LD_INT 21
65594: PUSH
65595: LD_INT 1
65597: PUSH
65598: EMPTY
65599: LIST
65600: LIST
65601: PUSH
65602: LD_INT 1
65604: PUSH
65605: LD_INT 3
65607: PUSH
65608: LD_INT 54
65610: PUSH
65611: EMPTY
65612: LIST
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: PUSH
65618: LD_INT 3
65620: PUSH
65621: LD_INT 24
65623: PUSH
65624: LD_INT 1000
65626: PUSH
65627: EMPTY
65628: LIST
65629: LIST
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: EMPTY
65636: LIST
65637: LIST
65638: LIST
65639: PUSH
65640: EMPTY
65641: LIST
65642: LIST
65643: PPUSH
65644: CALL_OW 72
65648: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65649: LD_ADDR_VAR 0 6
65653: PUSH
65654: LD_EXP 61
65658: PUSH
65659: LD_VAR 0 2
65663: ARRAY
65664: PPUSH
65665: LD_INT 21
65667: PUSH
65668: LD_INT 1
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: LD_INT 1
65677: PUSH
65678: LD_INT 3
65680: PUSH
65681: LD_INT 54
65683: PUSH
65684: EMPTY
65685: LIST
65686: PUSH
65687: EMPTY
65688: LIST
65689: LIST
65690: PUSH
65691: LD_INT 3
65693: PUSH
65694: LD_INT 24
65696: PUSH
65697: LD_INT 250
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: EMPTY
65709: LIST
65710: LIST
65711: LIST
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PPUSH
65717: CALL_OW 72
65721: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65722: LD_ADDR_VAR 0 7
65726: PUSH
65727: LD_VAR 0 5
65731: PUSH
65732: LD_VAR 0 6
65736: DIFF
65737: ST_TO_ADDR
// if not need_heal_1 then
65738: LD_VAR 0 6
65742: NOT
65743: IFFALSE 65776
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65745: LD_ADDR_EXP 64
65749: PUSH
65750: LD_EXP 64
65754: PPUSH
65755: LD_VAR 0 2
65759: PUSH
65760: LD_INT 1
65762: PUSH
65763: EMPTY
65764: LIST
65765: LIST
65766: PPUSH
65767: EMPTY
65768: PPUSH
65769: CALL 20463 0 3
65773: ST_TO_ADDR
65774: GO 65846
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65776: LD_ADDR_EXP 64
65780: PUSH
65781: LD_EXP 64
65785: PPUSH
65786: LD_VAR 0 2
65790: PUSH
65791: LD_INT 1
65793: PUSH
65794: EMPTY
65795: LIST
65796: LIST
65797: PPUSH
65798: LD_EXP 64
65802: PUSH
65803: LD_VAR 0 2
65807: ARRAY
65808: PUSH
65809: LD_INT 1
65811: ARRAY
65812: PPUSH
65813: LD_INT 3
65815: PUSH
65816: LD_INT 24
65818: PUSH
65819: LD_INT 1000
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: EMPTY
65827: LIST
65828: LIST
65829: PPUSH
65830: CALL_OW 72
65834: PUSH
65835: LD_VAR 0 6
65839: UNION
65840: PPUSH
65841: CALL 20463 0 3
65845: ST_TO_ADDR
// if not need_heal_2 then
65846: LD_VAR 0 7
65850: NOT
65851: IFFALSE 65884
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65853: LD_ADDR_EXP 64
65857: PUSH
65858: LD_EXP 64
65862: PPUSH
65863: LD_VAR 0 2
65867: PUSH
65868: LD_INT 2
65870: PUSH
65871: EMPTY
65872: LIST
65873: LIST
65874: PPUSH
65875: EMPTY
65876: PPUSH
65877: CALL 20463 0 3
65881: ST_TO_ADDR
65882: GO 65916
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65884: LD_ADDR_EXP 64
65888: PUSH
65889: LD_EXP 64
65893: PPUSH
65894: LD_VAR 0 2
65898: PUSH
65899: LD_INT 2
65901: PUSH
65902: EMPTY
65903: LIST
65904: LIST
65905: PPUSH
65906: LD_VAR 0 7
65910: PPUSH
65911: CALL 20463 0 3
65915: ST_TO_ADDR
// if need_heal_2 then
65916: LD_VAR 0 7
65920: IFFALSE 66081
// for j in need_heal_2 do
65922: LD_ADDR_VAR 0 3
65926: PUSH
65927: LD_VAR 0 7
65931: PUSH
65932: FOR_IN
65933: IFFALSE 66079
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65935: LD_ADDR_VAR 0 5
65939: PUSH
65940: LD_EXP 61
65944: PUSH
65945: LD_VAR 0 2
65949: ARRAY
65950: PPUSH
65951: LD_INT 2
65953: PUSH
65954: LD_INT 30
65956: PUSH
65957: LD_INT 6
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 30
65966: PUSH
65967: LD_INT 7
65969: PUSH
65970: EMPTY
65971: LIST
65972: LIST
65973: PUSH
65974: LD_INT 30
65976: PUSH
65977: LD_INT 8
65979: PUSH
65980: EMPTY
65981: LIST
65982: LIST
65983: PUSH
65984: LD_INT 30
65986: PUSH
65987: LD_INT 0
65989: PUSH
65990: EMPTY
65991: LIST
65992: LIST
65993: PUSH
65994: LD_INT 30
65996: PUSH
65997: LD_INT 1
65999: PUSH
66000: EMPTY
66001: LIST
66002: LIST
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: LIST
66008: LIST
66009: LIST
66010: LIST
66011: PPUSH
66012: CALL_OW 72
66016: ST_TO_ADDR
// if tmp then
66017: LD_VAR 0 5
66021: IFFALSE 66077
// begin k := NearestUnitToUnit ( tmp , j ) ;
66023: LD_ADDR_VAR 0 4
66027: PUSH
66028: LD_VAR 0 5
66032: PPUSH
66033: LD_VAR 0 3
66037: PPUSH
66038: CALL_OW 74
66042: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
66043: LD_VAR 0 3
66047: PPUSH
66048: LD_VAR 0 4
66052: PPUSH
66053: CALL_OW 296
66057: PUSH
66058: LD_INT 5
66060: GREATER
66061: IFFALSE 66077
// ComMoveToNearbyEntrance ( j , k ) ;
66063: LD_VAR 0 3
66067: PPUSH
66068: LD_VAR 0 4
66072: PPUSH
66073: CALL 53679 0 2
// end ; end ;
66077: GO 65932
66079: POP
66080: POP
// if not need_heal_1 and not need_heal_2 then
66081: LD_VAR 0 6
66085: NOT
66086: PUSH
66087: LD_VAR 0 7
66091: NOT
66092: AND
66093: IFFALSE 66097
// continue ;
66095: GO 65561
// end ;
66097: GO 65561
66099: POP
66100: POP
// RaiseSailEvent ( 102 ) ;
66101: LD_INT 102
66103: PPUSH
66104: CALL_OW 427
// end ;
66108: LD_VAR 0 1
66112: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
66113: LD_INT 0
66115: PPUSH
66116: PPUSH
66117: PPUSH
66118: PPUSH
66119: PPUSH
66120: PPUSH
66121: PPUSH
66122: PPUSH
// if not mc_bases then
66123: LD_EXP 61
66127: NOT
66128: IFFALSE 66132
// exit ;
66130: GO 67043
// for i = 1 to mc_bases do
66132: LD_ADDR_VAR 0 2
66136: PUSH
66137: DOUBLE
66138: LD_INT 1
66140: DEC
66141: ST_TO_ADDR
66142: LD_EXP 61
66146: PUSH
66147: FOR_TO
66148: IFFALSE 67041
// begin if not mc_building_need_repair [ i ] then
66150: LD_EXP 62
66154: PUSH
66155: LD_VAR 0 2
66159: ARRAY
66160: NOT
66161: IFFALSE 66346
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
66163: LD_ADDR_VAR 0 6
66167: PUSH
66168: LD_EXP 80
66172: PUSH
66173: LD_VAR 0 2
66177: ARRAY
66178: PPUSH
66179: LD_INT 3
66181: PUSH
66182: LD_INT 24
66184: PUSH
66185: LD_INT 1000
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 2
66198: PUSH
66199: LD_INT 34
66201: PUSH
66202: LD_INT 13
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 34
66211: PUSH
66212: LD_INT 52
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: LD_INT 34
66221: PUSH
66222: LD_INT 88
66224: PUSH
66225: EMPTY
66226: LIST
66227: LIST
66228: PUSH
66229: EMPTY
66230: LIST
66231: LIST
66232: LIST
66233: LIST
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PPUSH
66239: CALL_OW 72
66243: ST_TO_ADDR
// if cranes then
66244: LD_VAR 0 6
66248: IFFALSE 66310
// for j in cranes do
66250: LD_ADDR_VAR 0 3
66254: PUSH
66255: LD_VAR 0 6
66259: PUSH
66260: FOR_IN
66261: IFFALSE 66308
// if not IsInArea ( j , mc_parking [ i ] ) then
66263: LD_VAR 0 3
66267: PPUSH
66268: LD_EXP 85
66272: PUSH
66273: LD_VAR 0 2
66277: ARRAY
66278: PPUSH
66279: CALL_OW 308
66283: NOT
66284: IFFALSE 66306
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66286: LD_VAR 0 3
66290: PPUSH
66291: LD_EXP 85
66295: PUSH
66296: LD_VAR 0 2
66300: ARRAY
66301: PPUSH
66302: CALL_OW 113
66306: GO 66260
66308: POP
66309: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66310: LD_ADDR_EXP 63
66314: PUSH
66315: LD_EXP 63
66319: PPUSH
66320: LD_VAR 0 2
66324: PPUSH
66325: EMPTY
66326: PPUSH
66327: CALL_OW 1
66331: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66332: LD_VAR 0 2
66336: PPUSH
66337: LD_INT 101
66339: PPUSH
66340: CALL 61186 0 2
// continue ;
66344: GO 66147
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66346: LD_ADDR_EXP 67
66350: PUSH
66351: LD_EXP 67
66355: PPUSH
66356: LD_VAR 0 2
66360: PPUSH
66361: EMPTY
66362: PPUSH
66363: CALL_OW 1
66367: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66368: LD_VAR 0 2
66372: PPUSH
66373: LD_INT 103
66375: PPUSH
66376: CALL 61186 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66380: LD_ADDR_VAR 0 5
66384: PUSH
66385: LD_EXP 61
66389: PUSH
66390: LD_VAR 0 2
66394: ARRAY
66395: PUSH
66396: LD_EXP 90
66400: PUSH
66401: LD_VAR 0 2
66405: ARRAY
66406: UNION
66407: PPUSH
66408: LD_INT 2
66410: PUSH
66411: LD_INT 25
66413: PUSH
66414: LD_INT 2
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 25
66423: PUSH
66424: LD_INT 16
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: LIST
66435: PUSH
66436: EMPTY
66437: LIST
66438: PPUSH
66439: CALL_OW 72
66443: ST_TO_ADDR
// if mc_need_heal [ i ] then
66444: LD_EXP 64
66448: PUSH
66449: LD_VAR 0 2
66453: ARRAY
66454: IFFALSE 66498
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
66456: LD_ADDR_VAR 0 5
66460: PUSH
66461: LD_VAR 0 5
66465: PUSH
66466: LD_EXP 64
66470: PUSH
66471: LD_VAR 0 2
66475: ARRAY
66476: PUSH
66477: LD_INT 1
66479: ARRAY
66480: PUSH
66481: LD_EXP 64
66485: PUSH
66486: LD_VAR 0 2
66490: ARRAY
66491: PUSH
66492: LD_INT 2
66494: ARRAY
66495: UNION
66496: DIFF
66497: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
66498: LD_ADDR_VAR 0 6
66502: PUSH
66503: LD_EXP 80
66507: PUSH
66508: LD_VAR 0 2
66512: ARRAY
66513: PPUSH
66514: LD_INT 2
66516: PUSH
66517: LD_INT 34
66519: PUSH
66520: LD_INT 13
66522: PUSH
66523: EMPTY
66524: LIST
66525: LIST
66526: PUSH
66527: LD_INT 34
66529: PUSH
66530: LD_INT 52
66532: PUSH
66533: EMPTY
66534: LIST
66535: LIST
66536: PUSH
66537: LD_INT 34
66539: PUSH
66540: LD_INT 88
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: EMPTY
66548: LIST
66549: LIST
66550: LIST
66551: LIST
66552: PPUSH
66553: CALL_OW 72
66557: ST_TO_ADDR
// if cranes then
66558: LD_VAR 0 6
66562: IFFALSE 66730
// begin for j in cranes do
66564: LD_ADDR_VAR 0 3
66568: PUSH
66569: LD_VAR 0 6
66573: PUSH
66574: FOR_IN
66575: IFFALSE 66728
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
66577: LD_VAR 0 3
66581: PPUSH
66582: CALL_OW 256
66586: PUSH
66587: LD_INT 1000
66589: EQUAL
66590: PUSH
66591: LD_VAR 0 3
66595: PPUSH
66596: CALL_OW 314
66600: NOT
66601: AND
66602: IFFALSE 66668
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
66604: LD_ADDR_VAR 0 8
66608: PUSH
66609: LD_EXP 62
66613: PUSH
66614: LD_VAR 0 2
66618: ARRAY
66619: PPUSH
66620: LD_VAR 0 3
66624: PPUSH
66625: CALL_OW 74
66629: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
66630: LD_VAR 0 8
66634: PPUSH
66635: LD_INT 16
66637: PPUSH
66638: CALL 23060 0 2
66642: PUSH
66643: LD_INT 4
66645: ARRAY
66646: PUSH
66647: LD_INT 10
66649: LESS
66650: IFFALSE 66666
// ComRepairBuilding ( j , to_repair ) ;
66652: LD_VAR 0 3
66656: PPUSH
66657: LD_VAR 0 8
66661: PPUSH
66662: CALL_OW 130
// end else
66666: GO 66726
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66668: LD_VAR 0 3
66672: PPUSH
66673: CALL_OW 256
66677: PUSH
66678: LD_INT 500
66680: LESS
66681: PUSH
66682: LD_VAR 0 3
66686: PPUSH
66687: LD_EXP 85
66691: PUSH
66692: LD_VAR 0 2
66696: ARRAY
66697: PPUSH
66698: CALL_OW 308
66702: NOT
66703: AND
66704: IFFALSE 66726
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66706: LD_VAR 0 3
66710: PPUSH
66711: LD_EXP 85
66715: PUSH
66716: LD_VAR 0 2
66720: ARRAY
66721: PPUSH
66722: CALL_OW 113
// end ;
66726: GO 66574
66728: POP
66729: POP
// end ; if tmp > 3 then
66730: LD_VAR 0 5
66734: PUSH
66735: LD_INT 3
66737: GREATER
66738: IFFALSE 66758
// tmp := ShrinkArray ( tmp , 4 ) ;
66740: LD_ADDR_VAR 0 5
66744: PUSH
66745: LD_VAR 0 5
66749: PPUSH
66750: LD_INT 4
66752: PPUSH
66753: CALL 53117 0 2
66757: ST_TO_ADDR
// if not tmp then
66758: LD_VAR 0 5
66762: NOT
66763: IFFALSE 66767
// continue ;
66765: GO 66147
// for j in tmp do
66767: LD_ADDR_VAR 0 3
66771: PUSH
66772: LD_VAR 0 5
66776: PUSH
66777: FOR_IN
66778: IFFALSE 67037
// begin if IsInUnit ( j ) then
66780: LD_VAR 0 3
66784: PPUSH
66785: CALL_OW 310
66789: IFFALSE 66800
// ComExitBuilding ( j ) ;
66791: LD_VAR 0 3
66795: PPUSH
66796: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66800: LD_VAR 0 3
66804: PUSH
66805: LD_EXP 63
66809: PUSH
66810: LD_VAR 0 2
66814: ARRAY
66815: IN
66816: NOT
66817: IFFALSE 66875
// begin SetTag ( j , 101 ) ;
66819: LD_VAR 0 3
66823: PPUSH
66824: LD_INT 101
66826: PPUSH
66827: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66831: LD_ADDR_EXP 63
66835: PUSH
66836: LD_EXP 63
66840: PPUSH
66841: LD_VAR 0 2
66845: PUSH
66846: LD_EXP 63
66850: PUSH
66851: LD_VAR 0 2
66855: ARRAY
66856: PUSH
66857: LD_INT 1
66859: PLUS
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PPUSH
66865: LD_VAR 0 3
66869: PPUSH
66870: CALL 20463 0 3
66874: ST_TO_ADDR
// end ; wait ( 1 ) ;
66875: LD_INT 1
66877: PPUSH
66878: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
66882: LD_ADDR_VAR 0 7
66886: PUSH
66887: LD_EXP 62
66891: PUSH
66892: LD_VAR 0 2
66896: ARRAY
66897: ST_TO_ADDR
// if mc_scan [ i ] then
66898: LD_EXP 84
66902: PUSH
66903: LD_VAR 0 2
66907: ARRAY
66908: IFFALSE 66970
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
66910: LD_ADDR_VAR 0 7
66914: PUSH
66915: LD_EXP 62
66919: PUSH
66920: LD_VAR 0 2
66924: ARRAY
66925: PPUSH
66926: LD_INT 3
66928: PUSH
66929: LD_INT 30
66931: PUSH
66932: LD_INT 32
66934: PUSH
66935: EMPTY
66936: LIST
66937: LIST
66938: PUSH
66939: LD_INT 30
66941: PUSH
66942: LD_INT 33
66944: PUSH
66945: EMPTY
66946: LIST
66947: LIST
66948: PUSH
66949: LD_INT 30
66951: PUSH
66952: LD_INT 31
66954: PUSH
66955: EMPTY
66956: LIST
66957: LIST
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: LIST
66963: LIST
66964: PPUSH
66965: CALL_OW 72
66969: ST_TO_ADDR
// if not to_repair_tmp then
66970: LD_VAR 0 7
66974: NOT
66975: IFFALSE 66979
// continue ;
66977: GO 66777
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
66979: LD_ADDR_VAR 0 8
66983: PUSH
66984: LD_VAR 0 7
66988: PPUSH
66989: LD_VAR 0 3
66993: PPUSH
66994: CALL_OW 74
66998: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
66999: LD_VAR 0 8
67003: PPUSH
67004: LD_INT 16
67006: PPUSH
67007: CALL 23060 0 2
67011: PUSH
67012: LD_INT 4
67014: ARRAY
67015: PUSH
67016: LD_INT 14
67018: LESS
67019: IFFALSE 67035
// ComRepairBuilding ( j , to_repair ) ;
67021: LD_VAR 0 3
67025: PPUSH
67026: LD_VAR 0 8
67030: PPUSH
67031: CALL_OW 130
// end ;
67035: GO 66777
67037: POP
67038: POP
// end ;
67039: GO 66147
67041: POP
67042: POP
// end ;
67043: LD_VAR 0 1
67047: RET
// export function MC_Heal ; var i , j , tmp ; begin
67048: LD_INT 0
67050: PPUSH
67051: PPUSH
67052: PPUSH
67053: PPUSH
// if not mc_bases then
67054: LD_EXP 61
67058: NOT
67059: IFFALSE 67063
// exit ;
67061: GO 67465
// for i = 1 to mc_bases do
67063: LD_ADDR_VAR 0 2
67067: PUSH
67068: DOUBLE
67069: LD_INT 1
67071: DEC
67072: ST_TO_ADDR
67073: LD_EXP 61
67077: PUSH
67078: FOR_TO
67079: IFFALSE 67463
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
67081: LD_EXP 64
67085: PUSH
67086: LD_VAR 0 2
67090: ARRAY
67091: PUSH
67092: LD_INT 1
67094: ARRAY
67095: NOT
67096: PUSH
67097: LD_EXP 64
67101: PUSH
67102: LD_VAR 0 2
67106: ARRAY
67107: PUSH
67108: LD_INT 2
67110: ARRAY
67111: NOT
67112: AND
67113: IFFALSE 67151
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
67115: LD_ADDR_EXP 65
67119: PUSH
67120: LD_EXP 65
67124: PPUSH
67125: LD_VAR 0 2
67129: PPUSH
67130: EMPTY
67131: PPUSH
67132: CALL_OW 1
67136: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
67137: LD_VAR 0 2
67141: PPUSH
67142: LD_INT 102
67144: PPUSH
67145: CALL 61186 0 2
// continue ;
67149: GO 67078
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67151: LD_ADDR_VAR 0 4
67155: PUSH
67156: LD_EXP 61
67160: PUSH
67161: LD_VAR 0 2
67165: ARRAY
67166: PPUSH
67167: LD_INT 25
67169: PUSH
67170: LD_INT 4
67172: PUSH
67173: EMPTY
67174: LIST
67175: LIST
67176: PPUSH
67177: CALL_OW 72
67181: ST_TO_ADDR
// if not tmp then
67182: LD_VAR 0 4
67186: NOT
67187: IFFALSE 67191
// continue ;
67189: GO 67078
// if mc_taming [ i ] then
67191: LD_EXP 92
67195: PUSH
67196: LD_VAR 0 2
67200: ARRAY
67201: IFFALSE 67225
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67203: LD_ADDR_EXP 92
67207: PUSH
67208: LD_EXP 92
67212: PPUSH
67213: LD_VAR 0 2
67217: PPUSH
67218: EMPTY
67219: PPUSH
67220: CALL_OW 1
67224: ST_TO_ADDR
// for j in tmp do
67225: LD_ADDR_VAR 0 3
67229: PUSH
67230: LD_VAR 0 4
67234: PUSH
67235: FOR_IN
67236: IFFALSE 67459
// begin if IsInUnit ( j ) then
67238: LD_VAR 0 3
67242: PPUSH
67243: CALL_OW 310
67247: IFFALSE 67258
// ComExitBuilding ( j ) ;
67249: LD_VAR 0 3
67253: PPUSH
67254: CALL_OW 122
// if not j in mc_healers [ i ] then
67258: LD_VAR 0 3
67262: PUSH
67263: LD_EXP 65
67267: PUSH
67268: LD_VAR 0 2
67272: ARRAY
67273: IN
67274: NOT
67275: IFFALSE 67321
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67277: LD_ADDR_EXP 65
67281: PUSH
67282: LD_EXP 65
67286: PPUSH
67287: LD_VAR 0 2
67291: PUSH
67292: LD_EXP 65
67296: PUSH
67297: LD_VAR 0 2
67301: ARRAY
67302: PUSH
67303: LD_INT 1
67305: PLUS
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PPUSH
67311: LD_VAR 0 3
67315: PPUSH
67316: CALL 20463 0 3
67320: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67321: LD_VAR 0 3
67325: PPUSH
67326: CALL_OW 110
67330: PUSH
67331: LD_INT 102
67333: NONEQUAL
67334: IFFALSE 67348
// SetTag ( j , 102 ) ;
67336: LD_VAR 0 3
67340: PPUSH
67341: LD_INT 102
67343: PPUSH
67344: CALL_OW 109
// Wait ( 3 ) ;
67348: LD_INT 3
67350: PPUSH
67351: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67355: LD_EXP 64
67359: PUSH
67360: LD_VAR 0 2
67364: ARRAY
67365: PUSH
67366: LD_INT 1
67368: ARRAY
67369: IFFALSE 67401
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67371: LD_VAR 0 3
67375: PPUSH
67376: LD_EXP 64
67380: PUSH
67381: LD_VAR 0 2
67385: ARRAY
67386: PUSH
67387: LD_INT 1
67389: ARRAY
67390: PUSH
67391: LD_INT 1
67393: ARRAY
67394: PPUSH
67395: CALL_OW 128
67399: GO 67457
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67401: LD_VAR 0 3
67405: PPUSH
67406: CALL_OW 314
67410: NOT
67411: PUSH
67412: LD_EXP 64
67416: PUSH
67417: LD_VAR 0 2
67421: ARRAY
67422: PUSH
67423: LD_INT 2
67425: ARRAY
67426: AND
67427: IFFALSE 67457
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67429: LD_VAR 0 3
67433: PPUSH
67434: LD_EXP 64
67438: PUSH
67439: LD_VAR 0 2
67443: ARRAY
67444: PUSH
67445: LD_INT 2
67447: ARRAY
67448: PUSH
67449: LD_INT 1
67451: ARRAY
67452: PPUSH
67453: CALL_OW 128
// end ;
67457: GO 67235
67459: POP
67460: POP
// end ;
67461: GO 67078
67463: POP
67464: POP
// end ;
67465: LD_VAR 0 1
67469: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
67470: LD_INT 0
67472: PPUSH
67473: PPUSH
67474: PPUSH
67475: PPUSH
67476: PPUSH
67477: PPUSH
// if not mc_bases then
67478: LD_EXP 61
67482: NOT
67483: IFFALSE 67487
// exit ;
67485: GO 68650
// for i = 1 to mc_bases do
67487: LD_ADDR_VAR 0 2
67491: PUSH
67492: DOUBLE
67493: LD_INT 1
67495: DEC
67496: ST_TO_ADDR
67497: LD_EXP 61
67501: PUSH
67502: FOR_TO
67503: IFFALSE 68648
// begin if mc_scan [ i ] then
67505: LD_EXP 84
67509: PUSH
67510: LD_VAR 0 2
67514: ARRAY
67515: IFFALSE 67519
// continue ;
67517: GO 67502
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67519: LD_EXP 66
67523: PUSH
67524: LD_VAR 0 2
67528: ARRAY
67529: NOT
67530: PUSH
67531: LD_EXP 68
67535: PUSH
67536: LD_VAR 0 2
67540: ARRAY
67541: NOT
67542: AND
67543: PUSH
67544: LD_EXP 67
67548: PUSH
67549: LD_VAR 0 2
67553: ARRAY
67554: AND
67555: IFFALSE 67593
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67557: LD_ADDR_EXP 67
67561: PUSH
67562: LD_EXP 67
67566: PPUSH
67567: LD_VAR 0 2
67571: PPUSH
67572: EMPTY
67573: PPUSH
67574: CALL_OW 1
67578: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67579: LD_VAR 0 2
67583: PPUSH
67584: LD_INT 103
67586: PPUSH
67587: CALL 61186 0 2
// continue ;
67591: GO 67502
// end ; if mc_construct_list [ i ] then
67593: LD_EXP 68
67597: PUSH
67598: LD_VAR 0 2
67602: ARRAY
67603: IFFALSE 67823
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67605: LD_ADDR_VAR 0 5
67609: PUSH
67610: LD_EXP 61
67614: PUSH
67615: LD_VAR 0 2
67619: ARRAY
67620: PPUSH
67621: LD_INT 25
67623: PUSH
67624: LD_INT 2
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PPUSH
67631: CALL_OW 72
67635: PUSH
67636: LD_EXP 63
67640: PUSH
67641: LD_VAR 0 2
67645: ARRAY
67646: DIFF
67647: ST_TO_ADDR
// if not tmp then
67648: LD_VAR 0 5
67652: NOT
67653: IFFALSE 67657
// continue ;
67655: GO 67502
// for j in tmp do
67657: LD_ADDR_VAR 0 3
67661: PUSH
67662: LD_VAR 0 5
67666: PUSH
67667: FOR_IN
67668: IFFALSE 67819
// begin if not mc_builders [ i ] then
67670: LD_EXP 67
67674: PUSH
67675: LD_VAR 0 2
67679: ARRAY
67680: NOT
67681: IFFALSE 67739
// begin SetTag ( j , 103 ) ;
67683: LD_VAR 0 3
67687: PPUSH
67688: LD_INT 103
67690: PPUSH
67691: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67695: LD_ADDR_EXP 67
67699: PUSH
67700: LD_EXP 67
67704: PPUSH
67705: LD_VAR 0 2
67709: PUSH
67710: LD_EXP 67
67714: PUSH
67715: LD_VAR 0 2
67719: ARRAY
67720: PUSH
67721: LD_INT 1
67723: PLUS
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: PPUSH
67729: LD_VAR 0 3
67733: PPUSH
67734: CALL 20463 0 3
67738: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67739: LD_VAR 0 3
67743: PPUSH
67744: CALL_OW 310
67748: IFFALSE 67759
// ComExitBuilding ( j ) ;
67750: LD_VAR 0 3
67754: PPUSH
67755: CALL_OW 122
// wait ( 3 ) ;
67759: LD_INT 3
67761: PPUSH
67762: CALL_OW 67
// if not mc_construct_list [ i ] then
67766: LD_EXP 68
67770: PUSH
67771: LD_VAR 0 2
67775: ARRAY
67776: NOT
67777: IFFALSE 67781
// break ;
67779: GO 67819
// if not HasTask ( j ) then
67781: LD_VAR 0 3
67785: PPUSH
67786: CALL_OW 314
67790: NOT
67791: IFFALSE 67817
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67793: LD_VAR 0 3
67797: PPUSH
67798: LD_EXP 68
67802: PUSH
67803: LD_VAR 0 2
67807: ARRAY
67808: PUSH
67809: LD_INT 1
67811: ARRAY
67812: PPUSH
67813: CALL 23333 0 2
// end ;
67817: GO 67667
67819: POP
67820: POP
// end else
67821: GO 68646
// if mc_build_list [ i ] then
67823: LD_EXP 66
67827: PUSH
67828: LD_VAR 0 2
67832: ARRAY
67833: IFFALSE 68646
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67835: LD_EXP 66
67839: PUSH
67840: LD_VAR 0 2
67844: ARRAY
67845: PUSH
67846: LD_INT 1
67848: ARRAY
67849: PUSH
67850: LD_INT 1
67852: ARRAY
67853: PPUSH
67854: CALL 23157 0 1
67858: PUSH
67859: LD_EXP 61
67863: PUSH
67864: LD_VAR 0 2
67868: ARRAY
67869: PPUSH
67870: LD_INT 2
67872: PUSH
67873: LD_INT 30
67875: PUSH
67876: LD_INT 2
67878: PUSH
67879: EMPTY
67880: LIST
67881: LIST
67882: PUSH
67883: LD_INT 30
67885: PUSH
67886: LD_INT 3
67888: PUSH
67889: EMPTY
67890: LIST
67891: LIST
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: LIST
67897: PPUSH
67898: CALL_OW 72
67902: NOT
67903: AND
67904: IFFALSE 68009
// begin for j = 1 to mc_build_list [ i ] do
67906: LD_ADDR_VAR 0 3
67910: PUSH
67911: DOUBLE
67912: LD_INT 1
67914: DEC
67915: ST_TO_ADDR
67916: LD_EXP 66
67920: PUSH
67921: LD_VAR 0 2
67925: ARRAY
67926: PUSH
67927: FOR_TO
67928: IFFALSE 68007
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67930: LD_EXP 66
67934: PUSH
67935: LD_VAR 0 2
67939: ARRAY
67940: PUSH
67941: LD_VAR 0 3
67945: ARRAY
67946: PUSH
67947: LD_INT 1
67949: ARRAY
67950: PUSH
67951: LD_INT 2
67953: EQUAL
67954: IFFALSE 68005
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67956: LD_ADDR_EXP 66
67960: PUSH
67961: LD_EXP 66
67965: PPUSH
67966: LD_VAR 0 2
67970: PPUSH
67971: LD_EXP 66
67975: PUSH
67976: LD_VAR 0 2
67980: ARRAY
67981: PPUSH
67982: LD_VAR 0 3
67986: PPUSH
67987: LD_INT 1
67989: PPUSH
67990: LD_INT 0
67992: PPUSH
67993: CALL 19881 0 4
67997: PPUSH
67998: CALL_OW 1
68002: ST_TO_ADDR
// break ;
68003: GO 68007
// end ;
68005: GO 67927
68007: POP
68008: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68009: LD_ADDR_VAR 0 6
68013: PUSH
68014: LD_EXP 61
68018: PUSH
68019: LD_VAR 0 2
68023: ARRAY
68024: PPUSH
68025: LD_INT 2
68027: PUSH
68028: LD_INT 30
68030: PUSH
68031: LD_INT 0
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 30
68040: PUSH
68041: LD_INT 1
68043: PUSH
68044: EMPTY
68045: LIST
68046: LIST
68047: PUSH
68048: EMPTY
68049: LIST
68050: LIST
68051: LIST
68052: PPUSH
68053: CALL_OW 72
68057: ST_TO_ADDR
// for k := 1 to depot do
68058: LD_ADDR_VAR 0 4
68062: PUSH
68063: DOUBLE
68064: LD_INT 1
68066: DEC
68067: ST_TO_ADDR
68068: LD_VAR 0 6
68072: PUSH
68073: FOR_TO
68074: IFFALSE 68644
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68076: LD_EXP 66
68080: PUSH
68081: LD_VAR 0 2
68085: ARRAY
68086: PUSH
68087: LD_INT 1
68089: ARRAY
68090: PUSH
68091: LD_INT 1
68093: ARRAY
68094: PUSH
68095: LD_INT 0
68097: EQUAL
68098: PUSH
68099: LD_VAR 0 6
68103: PUSH
68104: LD_VAR 0 4
68108: ARRAY
68109: PPUSH
68110: LD_EXP 66
68114: PUSH
68115: LD_VAR 0 2
68119: ARRAY
68120: PUSH
68121: LD_INT 1
68123: ARRAY
68124: PUSH
68125: LD_INT 1
68127: ARRAY
68128: PPUSH
68129: LD_EXP 66
68133: PUSH
68134: LD_VAR 0 2
68138: ARRAY
68139: PUSH
68140: LD_INT 1
68142: ARRAY
68143: PUSH
68144: LD_INT 2
68146: ARRAY
68147: PPUSH
68148: LD_EXP 66
68152: PUSH
68153: LD_VAR 0 2
68157: ARRAY
68158: PUSH
68159: LD_INT 1
68161: ARRAY
68162: PUSH
68163: LD_INT 3
68165: ARRAY
68166: PPUSH
68167: LD_EXP 66
68171: PUSH
68172: LD_VAR 0 2
68176: ARRAY
68177: PUSH
68178: LD_INT 1
68180: ARRAY
68181: PUSH
68182: LD_INT 4
68184: ARRAY
68185: PPUSH
68186: CALL 28569 0 5
68190: OR
68191: IFFALSE 68472
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68193: LD_ADDR_VAR 0 5
68197: PUSH
68198: LD_EXP 61
68202: PUSH
68203: LD_VAR 0 2
68207: ARRAY
68208: PPUSH
68209: LD_INT 25
68211: PUSH
68212: LD_INT 2
68214: PUSH
68215: EMPTY
68216: LIST
68217: LIST
68218: PPUSH
68219: CALL_OW 72
68223: PUSH
68224: LD_EXP 63
68228: PUSH
68229: LD_VAR 0 2
68233: ARRAY
68234: DIFF
68235: ST_TO_ADDR
// if not tmp then
68236: LD_VAR 0 5
68240: NOT
68241: IFFALSE 68245
// continue ;
68243: GO 68073
// for j in tmp do
68245: LD_ADDR_VAR 0 3
68249: PUSH
68250: LD_VAR 0 5
68254: PUSH
68255: FOR_IN
68256: IFFALSE 68468
// begin if not mc_builders [ i ] then
68258: LD_EXP 67
68262: PUSH
68263: LD_VAR 0 2
68267: ARRAY
68268: NOT
68269: IFFALSE 68327
// begin SetTag ( j , 103 ) ;
68271: LD_VAR 0 3
68275: PPUSH
68276: LD_INT 103
68278: PPUSH
68279: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68283: LD_ADDR_EXP 67
68287: PUSH
68288: LD_EXP 67
68292: PPUSH
68293: LD_VAR 0 2
68297: PUSH
68298: LD_EXP 67
68302: PUSH
68303: LD_VAR 0 2
68307: ARRAY
68308: PUSH
68309: LD_INT 1
68311: PLUS
68312: PUSH
68313: EMPTY
68314: LIST
68315: LIST
68316: PPUSH
68317: LD_VAR 0 3
68321: PPUSH
68322: CALL 20463 0 3
68326: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68327: LD_VAR 0 3
68331: PPUSH
68332: CALL_OW 310
68336: IFFALSE 68347
// ComExitBuilding ( j ) ;
68338: LD_VAR 0 3
68342: PPUSH
68343: CALL_OW 122
// wait ( 3 ) ;
68347: LD_INT 3
68349: PPUSH
68350: CALL_OW 67
// if not mc_build_list [ i ] then
68354: LD_EXP 66
68358: PUSH
68359: LD_VAR 0 2
68363: ARRAY
68364: NOT
68365: IFFALSE 68369
// break ;
68367: GO 68468
// if not HasTask ( j ) then
68369: LD_VAR 0 3
68373: PPUSH
68374: CALL_OW 314
68378: NOT
68379: IFFALSE 68466
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68381: LD_VAR 0 3
68385: PPUSH
68386: LD_EXP 66
68390: PUSH
68391: LD_VAR 0 2
68395: ARRAY
68396: PUSH
68397: LD_INT 1
68399: ARRAY
68400: PUSH
68401: LD_INT 1
68403: ARRAY
68404: PPUSH
68405: LD_EXP 66
68409: PUSH
68410: LD_VAR 0 2
68414: ARRAY
68415: PUSH
68416: LD_INT 1
68418: ARRAY
68419: PUSH
68420: LD_INT 2
68422: ARRAY
68423: PPUSH
68424: LD_EXP 66
68428: PUSH
68429: LD_VAR 0 2
68433: ARRAY
68434: PUSH
68435: LD_INT 1
68437: ARRAY
68438: PUSH
68439: LD_INT 3
68441: ARRAY
68442: PPUSH
68443: LD_EXP 66
68447: PUSH
68448: LD_VAR 0 2
68452: ARRAY
68453: PUSH
68454: LD_INT 1
68456: ARRAY
68457: PUSH
68458: LD_INT 4
68460: ARRAY
68461: PPUSH
68462: CALL_OW 145
// end ;
68466: GO 68255
68468: POP
68469: POP
// end else
68470: GO 68642
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
68472: LD_EXP 61
68476: PUSH
68477: LD_VAR 0 2
68481: ARRAY
68482: PPUSH
68483: LD_EXP 66
68487: PUSH
68488: LD_VAR 0 2
68492: ARRAY
68493: PUSH
68494: LD_INT 1
68496: ARRAY
68497: PUSH
68498: LD_INT 1
68500: ARRAY
68501: PPUSH
68502: LD_EXP 66
68506: PUSH
68507: LD_VAR 0 2
68511: ARRAY
68512: PUSH
68513: LD_INT 1
68515: ARRAY
68516: PUSH
68517: LD_INT 2
68519: ARRAY
68520: PPUSH
68521: LD_EXP 66
68525: PUSH
68526: LD_VAR 0 2
68530: ARRAY
68531: PUSH
68532: LD_INT 1
68534: ARRAY
68535: PUSH
68536: LD_INT 3
68538: ARRAY
68539: PPUSH
68540: LD_EXP 66
68544: PUSH
68545: LD_VAR 0 2
68549: ARRAY
68550: PUSH
68551: LD_INT 1
68553: ARRAY
68554: PUSH
68555: LD_INT 4
68557: ARRAY
68558: PPUSH
68559: LD_EXP 61
68563: PUSH
68564: LD_VAR 0 2
68568: ARRAY
68569: PPUSH
68570: LD_INT 21
68572: PUSH
68573: LD_INT 3
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: PPUSH
68580: CALL_OW 72
68584: PPUSH
68585: EMPTY
68586: PPUSH
68587: CALL 27323 0 7
68591: NOT
68592: IFFALSE 68642
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68594: LD_ADDR_EXP 66
68598: PUSH
68599: LD_EXP 66
68603: PPUSH
68604: LD_VAR 0 2
68608: PPUSH
68609: LD_EXP 66
68613: PUSH
68614: LD_VAR 0 2
68618: ARRAY
68619: PPUSH
68620: LD_INT 1
68622: PPUSH
68623: LD_INT 1
68625: NEG
68626: PPUSH
68627: LD_INT 0
68629: PPUSH
68630: CALL 19881 0 4
68634: PPUSH
68635: CALL_OW 1
68639: ST_TO_ADDR
// continue ;
68640: GO 68073
// end ; end ;
68642: GO 68073
68644: POP
68645: POP
// end ; end ;
68646: GO 67502
68648: POP
68649: POP
// end ;
68650: LD_VAR 0 1
68654: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68655: LD_INT 0
68657: PPUSH
68658: PPUSH
68659: PPUSH
68660: PPUSH
68661: PPUSH
68662: PPUSH
// if not mc_bases then
68663: LD_EXP 61
68667: NOT
68668: IFFALSE 68672
// exit ;
68670: GO 69099
// for i = 1 to mc_bases do
68672: LD_ADDR_VAR 0 2
68676: PUSH
68677: DOUBLE
68678: LD_INT 1
68680: DEC
68681: ST_TO_ADDR
68682: LD_EXP 61
68686: PUSH
68687: FOR_TO
68688: IFFALSE 69097
// begin tmp := mc_build_upgrade [ i ] ;
68690: LD_ADDR_VAR 0 4
68694: PUSH
68695: LD_EXP 93
68699: PUSH
68700: LD_VAR 0 2
68704: ARRAY
68705: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68706: LD_ADDR_VAR 0 6
68710: PUSH
68711: LD_EXP 94
68715: PUSH
68716: LD_VAR 0 2
68720: ARRAY
68721: PPUSH
68722: LD_INT 2
68724: PUSH
68725: LD_INT 30
68727: PUSH
68728: LD_INT 6
68730: PUSH
68731: EMPTY
68732: LIST
68733: LIST
68734: PUSH
68735: LD_INT 30
68737: PUSH
68738: LD_INT 7
68740: PUSH
68741: EMPTY
68742: LIST
68743: LIST
68744: PUSH
68745: EMPTY
68746: LIST
68747: LIST
68748: LIST
68749: PPUSH
68750: CALL_OW 72
68754: ST_TO_ADDR
// if not tmp and not lab then
68755: LD_VAR 0 4
68759: NOT
68760: PUSH
68761: LD_VAR 0 6
68765: NOT
68766: AND
68767: IFFALSE 68771
// continue ;
68769: GO 68687
// if tmp then
68771: LD_VAR 0 4
68775: IFFALSE 68895
// for j in tmp do
68777: LD_ADDR_VAR 0 3
68781: PUSH
68782: LD_VAR 0 4
68786: PUSH
68787: FOR_IN
68788: IFFALSE 68893
// begin if UpgradeCost ( j ) then
68790: LD_VAR 0 3
68794: PPUSH
68795: CALL 26983 0 1
68799: IFFALSE 68891
// begin ComUpgrade ( j ) ;
68801: LD_VAR 0 3
68805: PPUSH
68806: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68810: LD_ADDR_EXP 93
68814: PUSH
68815: LD_EXP 93
68819: PPUSH
68820: LD_VAR 0 2
68824: PPUSH
68825: LD_EXP 93
68829: PUSH
68830: LD_VAR 0 2
68834: ARRAY
68835: PUSH
68836: LD_VAR 0 3
68840: DIFF
68841: PPUSH
68842: CALL_OW 1
68846: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68847: LD_ADDR_EXP 68
68851: PUSH
68852: LD_EXP 68
68856: PPUSH
68857: LD_VAR 0 2
68861: PUSH
68862: LD_EXP 68
68866: PUSH
68867: LD_VAR 0 2
68871: ARRAY
68872: PUSH
68873: LD_INT 1
68875: PLUS
68876: PUSH
68877: EMPTY
68878: LIST
68879: LIST
68880: PPUSH
68881: LD_VAR 0 3
68885: PPUSH
68886: CALL 20463 0 3
68890: ST_TO_ADDR
// end ; end ;
68891: GO 68787
68893: POP
68894: POP
// if not lab or not mc_lab_upgrade [ i ] then
68895: LD_VAR 0 6
68899: NOT
68900: PUSH
68901: LD_EXP 95
68905: PUSH
68906: LD_VAR 0 2
68910: ARRAY
68911: NOT
68912: OR
68913: IFFALSE 68917
// continue ;
68915: GO 68687
// for j in lab do
68917: LD_ADDR_VAR 0 3
68921: PUSH
68922: LD_VAR 0 6
68926: PUSH
68927: FOR_IN
68928: IFFALSE 69093
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68930: LD_VAR 0 3
68934: PPUSH
68935: CALL_OW 266
68939: PUSH
68940: LD_INT 6
68942: PUSH
68943: LD_INT 7
68945: PUSH
68946: EMPTY
68947: LIST
68948: LIST
68949: IN
68950: PUSH
68951: LD_VAR 0 3
68955: PPUSH
68956: CALL_OW 461
68960: PUSH
68961: LD_INT 1
68963: NONEQUAL
68964: AND
68965: IFFALSE 69091
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68967: LD_VAR 0 3
68971: PPUSH
68972: LD_EXP 95
68976: PUSH
68977: LD_VAR 0 2
68981: ARRAY
68982: PUSH
68983: LD_INT 1
68985: ARRAY
68986: PPUSH
68987: CALL 27188 0 2
68991: IFFALSE 69091
// begin ComCancel ( j ) ;
68993: LD_VAR 0 3
68997: PPUSH
68998: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
69002: LD_VAR 0 3
69006: PPUSH
69007: LD_EXP 95
69011: PUSH
69012: LD_VAR 0 2
69016: ARRAY
69017: PUSH
69018: LD_INT 1
69020: ARRAY
69021: PPUSH
69022: CALL_OW 207
// if not j in mc_construct_list [ i ] then
69026: LD_VAR 0 3
69030: PUSH
69031: LD_EXP 68
69035: PUSH
69036: LD_VAR 0 2
69040: ARRAY
69041: IN
69042: NOT
69043: IFFALSE 69089
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
69045: LD_ADDR_EXP 68
69049: PUSH
69050: LD_EXP 68
69054: PPUSH
69055: LD_VAR 0 2
69059: PUSH
69060: LD_EXP 68
69064: PUSH
69065: LD_VAR 0 2
69069: ARRAY
69070: PUSH
69071: LD_INT 1
69073: PLUS
69074: PUSH
69075: EMPTY
69076: LIST
69077: LIST
69078: PPUSH
69079: LD_VAR 0 3
69083: PPUSH
69084: CALL 20463 0 3
69088: ST_TO_ADDR
// break ;
69089: GO 69093
// end ; end ; end ;
69091: GO 68927
69093: POP
69094: POP
// end ;
69095: GO 68687
69097: POP
69098: POP
// end ;
69099: LD_VAR 0 1
69103: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
69104: LD_INT 0
69106: PPUSH
69107: PPUSH
69108: PPUSH
69109: PPUSH
69110: PPUSH
69111: PPUSH
69112: PPUSH
69113: PPUSH
69114: PPUSH
// if not mc_bases then
69115: LD_EXP 61
69119: NOT
69120: IFFALSE 69124
// exit ;
69122: GO 69529
// for i = 1 to mc_bases do
69124: LD_ADDR_VAR 0 2
69128: PUSH
69129: DOUBLE
69130: LD_INT 1
69132: DEC
69133: ST_TO_ADDR
69134: LD_EXP 61
69138: PUSH
69139: FOR_TO
69140: IFFALSE 69527
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
69142: LD_EXP 69
69146: PUSH
69147: LD_VAR 0 2
69151: ARRAY
69152: NOT
69153: PUSH
69154: LD_EXP 61
69158: PUSH
69159: LD_VAR 0 2
69163: ARRAY
69164: PPUSH
69165: LD_INT 30
69167: PUSH
69168: LD_INT 3
69170: PUSH
69171: EMPTY
69172: LIST
69173: LIST
69174: PPUSH
69175: CALL_OW 72
69179: NOT
69180: OR
69181: IFFALSE 69185
// continue ;
69183: GO 69139
// busy := false ;
69185: LD_ADDR_VAR 0 8
69189: PUSH
69190: LD_INT 0
69192: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69193: LD_ADDR_VAR 0 4
69197: PUSH
69198: LD_EXP 61
69202: PUSH
69203: LD_VAR 0 2
69207: ARRAY
69208: PPUSH
69209: LD_INT 30
69211: PUSH
69212: LD_INT 3
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PPUSH
69219: CALL_OW 72
69223: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69224: LD_ADDR_VAR 0 6
69228: PUSH
69229: LD_EXP 69
69233: PUSH
69234: LD_VAR 0 2
69238: ARRAY
69239: PPUSH
69240: LD_INT 2
69242: PUSH
69243: LD_INT 30
69245: PUSH
69246: LD_INT 32
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 30
69255: PUSH
69256: LD_INT 33
69258: PUSH
69259: EMPTY
69260: LIST
69261: LIST
69262: PUSH
69263: EMPTY
69264: LIST
69265: LIST
69266: LIST
69267: PPUSH
69268: CALL_OW 72
69272: ST_TO_ADDR
// if not t then
69273: LD_VAR 0 6
69277: NOT
69278: IFFALSE 69282
// continue ;
69280: GO 69139
// for j in tmp do
69282: LD_ADDR_VAR 0 3
69286: PUSH
69287: LD_VAR 0 4
69291: PUSH
69292: FOR_IN
69293: IFFALSE 69323
// if not BuildingStatus ( j ) = bs_idle then
69295: LD_VAR 0 3
69299: PPUSH
69300: CALL_OW 461
69304: PUSH
69305: LD_INT 2
69307: EQUAL
69308: NOT
69309: IFFALSE 69321
// begin busy := true ;
69311: LD_ADDR_VAR 0 8
69315: PUSH
69316: LD_INT 1
69318: ST_TO_ADDR
// break ;
69319: GO 69323
// end ;
69321: GO 69292
69323: POP
69324: POP
// if busy then
69325: LD_VAR 0 8
69329: IFFALSE 69333
// continue ;
69331: GO 69139
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69333: LD_ADDR_VAR 0 7
69337: PUSH
69338: LD_VAR 0 6
69342: PPUSH
69343: LD_INT 35
69345: PUSH
69346: LD_INT 0
69348: PUSH
69349: EMPTY
69350: LIST
69351: LIST
69352: PPUSH
69353: CALL_OW 72
69357: ST_TO_ADDR
// if tw then
69358: LD_VAR 0 7
69362: IFFALSE 69439
// begin tw := tw [ 1 ] ;
69364: LD_ADDR_VAR 0 7
69368: PUSH
69369: LD_VAR 0 7
69373: PUSH
69374: LD_INT 1
69376: ARRAY
69377: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69378: LD_ADDR_VAR 0 9
69382: PUSH
69383: LD_VAR 0 7
69387: PPUSH
69388: LD_EXP 86
69392: PUSH
69393: LD_VAR 0 2
69397: ARRAY
69398: PPUSH
69399: CALL 25480 0 2
69403: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69404: LD_EXP 100
69408: PUSH
69409: LD_VAR 0 2
69413: ARRAY
69414: IFFALSE 69437
// if not weapon in mc_allowed_tower_weapons [ i ] then
69416: LD_VAR 0 9
69420: PUSH
69421: LD_EXP 100
69425: PUSH
69426: LD_VAR 0 2
69430: ARRAY
69431: IN
69432: NOT
69433: IFFALSE 69437
// continue ;
69435: GO 69139
// end else
69437: GO 69502
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69439: LD_ADDR_VAR 0 5
69443: PUSH
69444: LD_EXP 69
69448: PUSH
69449: LD_VAR 0 2
69453: ARRAY
69454: PPUSH
69455: LD_VAR 0 4
69459: PPUSH
69460: CALL 52350 0 2
69464: ST_TO_ADDR
// if not tmp2 then
69465: LD_VAR 0 5
69469: NOT
69470: IFFALSE 69474
// continue ;
69472: GO 69139
// tw := tmp2 [ 1 ] ;
69474: LD_ADDR_VAR 0 7
69478: PUSH
69479: LD_VAR 0 5
69483: PUSH
69484: LD_INT 1
69486: ARRAY
69487: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69488: LD_ADDR_VAR 0 9
69492: PUSH
69493: LD_VAR 0 5
69497: PUSH
69498: LD_INT 2
69500: ARRAY
69501: ST_TO_ADDR
// end ; if not weapon then
69502: LD_VAR 0 9
69506: NOT
69507: IFFALSE 69511
// continue ;
69509: GO 69139
// ComPlaceWeapon ( tw , weapon ) ;
69511: LD_VAR 0 7
69515: PPUSH
69516: LD_VAR 0 9
69520: PPUSH
69521: CALL_OW 148
// end ;
69525: GO 69139
69527: POP
69528: POP
// end ;
69529: LD_VAR 0 1
69533: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
69534: LD_INT 0
69536: PPUSH
69537: PPUSH
69538: PPUSH
69539: PPUSH
69540: PPUSH
69541: PPUSH
69542: PPUSH
// if not mc_bases then
69543: LD_EXP 61
69547: NOT
69548: IFFALSE 69552
// exit ;
69550: GO 70327
// for i = 1 to mc_bases do
69552: LD_ADDR_VAR 0 2
69556: PUSH
69557: DOUBLE
69558: LD_INT 1
69560: DEC
69561: ST_TO_ADDR
69562: LD_EXP 61
69566: PUSH
69567: FOR_TO
69568: IFFALSE 70325
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
69570: LD_EXP 74
69574: PUSH
69575: LD_VAR 0 2
69579: ARRAY
69580: NOT
69581: PUSH
69582: LD_EXP 74
69586: PUSH
69587: LD_VAR 0 2
69591: ARRAY
69592: PUSH
69593: LD_EXP 75
69597: PUSH
69598: LD_VAR 0 2
69602: ARRAY
69603: EQUAL
69604: OR
69605: PUSH
69606: LD_EXP 84
69610: PUSH
69611: LD_VAR 0 2
69615: ARRAY
69616: OR
69617: IFFALSE 69621
// continue ;
69619: GO 69567
// if mc_miners [ i ] then
69621: LD_EXP 75
69625: PUSH
69626: LD_VAR 0 2
69630: ARRAY
69631: IFFALSE 70012
// begin for j = mc_miners [ i ] downto 1 do
69633: LD_ADDR_VAR 0 3
69637: PUSH
69638: DOUBLE
69639: LD_EXP 75
69643: PUSH
69644: LD_VAR 0 2
69648: ARRAY
69649: INC
69650: ST_TO_ADDR
69651: LD_INT 1
69653: PUSH
69654: FOR_DOWNTO
69655: IFFALSE 70010
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69657: LD_EXP 75
69661: PUSH
69662: LD_VAR 0 2
69666: ARRAY
69667: PUSH
69668: LD_VAR 0 3
69672: ARRAY
69673: PPUSH
69674: CALL_OW 301
69678: PUSH
69679: LD_EXP 75
69683: PUSH
69684: LD_VAR 0 2
69688: ARRAY
69689: PUSH
69690: LD_VAR 0 3
69694: ARRAY
69695: PPUSH
69696: CALL_OW 257
69700: PUSH
69701: LD_INT 1
69703: NONEQUAL
69704: OR
69705: IFFALSE 69768
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69707: LD_ADDR_VAR 0 5
69711: PUSH
69712: LD_EXP 75
69716: PUSH
69717: LD_VAR 0 2
69721: ARRAY
69722: PUSH
69723: LD_EXP 75
69727: PUSH
69728: LD_VAR 0 2
69732: ARRAY
69733: PUSH
69734: LD_VAR 0 3
69738: ARRAY
69739: DIFF
69740: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69741: LD_ADDR_EXP 75
69745: PUSH
69746: LD_EXP 75
69750: PPUSH
69751: LD_VAR 0 2
69755: PPUSH
69756: LD_VAR 0 5
69760: PPUSH
69761: CALL_OW 1
69765: ST_TO_ADDR
// continue ;
69766: GO 69654
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
69768: LD_EXP 75
69772: PUSH
69773: LD_VAR 0 2
69777: ARRAY
69778: PUSH
69779: LD_VAR 0 3
69783: ARRAY
69784: PPUSH
69785: CALL_OW 257
69789: PUSH
69790: LD_INT 1
69792: EQUAL
69793: PUSH
69794: LD_EXP 75
69798: PUSH
69799: LD_VAR 0 2
69803: ARRAY
69804: PUSH
69805: LD_VAR 0 3
69809: ARRAY
69810: PPUSH
69811: CALL_OW 459
69815: NOT
69816: AND
69817: PUSH
69818: LD_EXP 75
69822: PUSH
69823: LD_VAR 0 2
69827: ARRAY
69828: PUSH
69829: LD_VAR 0 3
69833: ARRAY
69834: PPUSH
69835: CALL_OW 314
69839: NOT
69840: AND
69841: IFFALSE 70008
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69843: LD_EXP 75
69847: PUSH
69848: LD_VAR 0 2
69852: ARRAY
69853: PUSH
69854: LD_VAR 0 3
69858: ARRAY
69859: PPUSH
69860: CALL_OW 310
69864: IFFALSE 69887
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69866: LD_EXP 75
69870: PUSH
69871: LD_VAR 0 2
69875: ARRAY
69876: PUSH
69877: LD_VAR 0 3
69881: ARRAY
69882: PPUSH
69883: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69887: LD_EXP 75
69891: PUSH
69892: LD_VAR 0 2
69896: ARRAY
69897: PUSH
69898: LD_VAR 0 3
69902: ARRAY
69903: PPUSH
69904: CALL_OW 314
69908: NOT
69909: IFFALSE 70008
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
69911: LD_ADDR_VAR 0 7
69915: PUSH
69916: LD_VAR 0 3
69920: PUSH
69921: LD_EXP 74
69925: PUSH
69926: LD_VAR 0 2
69930: ARRAY
69931: PPUSH
69932: CALL 17603 0 1
69936: MOD
69937: PUSH
69938: LD_INT 1
69940: PLUS
69941: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
69942: LD_EXP 75
69946: PUSH
69947: LD_VAR 0 2
69951: ARRAY
69952: PUSH
69953: LD_VAR 0 3
69957: ARRAY
69958: PPUSH
69959: LD_EXP 74
69963: PUSH
69964: LD_VAR 0 2
69968: ARRAY
69969: PUSH
69970: LD_VAR 0 7
69974: ARRAY
69975: PUSH
69976: LD_INT 1
69978: ARRAY
69979: PPUSH
69980: LD_EXP 74
69984: PUSH
69985: LD_VAR 0 2
69989: ARRAY
69990: PUSH
69991: LD_VAR 0 7
69995: ARRAY
69996: PUSH
69997: LD_INT 2
69999: ARRAY
70000: PPUSH
70001: LD_INT 0
70003: PPUSH
70004: CALL_OW 193
// end ; end ; end ;
70008: GO 69654
70010: POP
70011: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70012: LD_ADDR_VAR 0 5
70016: PUSH
70017: LD_EXP 61
70021: PUSH
70022: LD_VAR 0 2
70026: ARRAY
70027: PPUSH
70028: LD_INT 2
70030: PUSH
70031: LD_INT 30
70033: PUSH
70034: LD_INT 4
70036: PUSH
70037: EMPTY
70038: LIST
70039: LIST
70040: PUSH
70041: LD_INT 30
70043: PUSH
70044: LD_INT 5
70046: PUSH
70047: EMPTY
70048: LIST
70049: LIST
70050: PUSH
70051: LD_INT 30
70053: PUSH
70054: LD_INT 32
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: EMPTY
70062: LIST
70063: LIST
70064: LIST
70065: LIST
70066: PPUSH
70067: CALL_OW 72
70071: ST_TO_ADDR
// if not tmp then
70072: LD_VAR 0 5
70076: NOT
70077: IFFALSE 70081
// continue ;
70079: GO 69567
// list := [ ] ;
70081: LD_ADDR_VAR 0 6
70085: PUSH
70086: EMPTY
70087: ST_TO_ADDR
// for j in tmp do
70088: LD_ADDR_VAR 0 3
70092: PUSH
70093: LD_VAR 0 5
70097: PUSH
70098: FOR_IN
70099: IFFALSE 70168
// begin for k in UnitsInside ( j ) do
70101: LD_ADDR_VAR 0 4
70105: PUSH
70106: LD_VAR 0 3
70110: PPUSH
70111: CALL_OW 313
70115: PUSH
70116: FOR_IN
70117: IFFALSE 70164
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70119: LD_VAR 0 4
70123: PPUSH
70124: CALL_OW 257
70128: PUSH
70129: LD_INT 1
70131: EQUAL
70132: PUSH
70133: LD_VAR 0 4
70137: PPUSH
70138: CALL_OW 459
70142: NOT
70143: AND
70144: IFFALSE 70162
// list := list ^ k ;
70146: LD_ADDR_VAR 0 6
70150: PUSH
70151: LD_VAR 0 6
70155: PUSH
70156: LD_VAR 0 4
70160: ADD
70161: ST_TO_ADDR
70162: GO 70116
70164: POP
70165: POP
// end ;
70166: GO 70098
70168: POP
70169: POP
// list := list diff mc_miners [ i ] ;
70170: LD_ADDR_VAR 0 6
70174: PUSH
70175: LD_VAR 0 6
70179: PUSH
70180: LD_EXP 75
70184: PUSH
70185: LD_VAR 0 2
70189: ARRAY
70190: DIFF
70191: ST_TO_ADDR
// if not list then
70192: LD_VAR 0 6
70196: NOT
70197: IFFALSE 70201
// continue ;
70199: GO 69567
// k := mc_mines [ i ] - mc_miners [ i ] ;
70201: LD_ADDR_VAR 0 4
70205: PUSH
70206: LD_EXP 74
70210: PUSH
70211: LD_VAR 0 2
70215: ARRAY
70216: PUSH
70217: LD_EXP 75
70221: PUSH
70222: LD_VAR 0 2
70226: ARRAY
70227: MINUS
70228: ST_TO_ADDR
// if k > list then
70229: LD_VAR 0 4
70233: PUSH
70234: LD_VAR 0 6
70238: GREATER
70239: IFFALSE 70251
// k := list ;
70241: LD_ADDR_VAR 0 4
70245: PUSH
70246: LD_VAR 0 6
70250: ST_TO_ADDR
// for j = 1 to k do
70251: LD_ADDR_VAR 0 3
70255: PUSH
70256: DOUBLE
70257: LD_INT 1
70259: DEC
70260: ST_TO_ADDR
70261: LD_VAR 0 4
70265: PUSH
70266: FOR_TO
70267: IFFALSE 70321
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70269: LD_ADDR_EXP 75
70273: PUSH
70274: LD_EXP 75
70278: PPUSH
70279: LD_VAR 0 2
70283: PUSH
70284: LD_EXP 75
70288: PUSH
70289: LD_VAR 0 2
70293: ARRAY
70294: PUSH
70295: LD_INT 1
70297: PLUS
70298: PUSH
70299: EMPTY
70300: LIST
70301: LIST
70302: PPUSH
70303: LD_VAR 0 6
70307: PUSH
70308: LD_VAR 0 3
70312: ARRAY
70313: PPUSH
70314: CALL 20463 0 3
70318: ST_TO_ADDR
70319: GO 70266
70321: POP
70322: POP
// end ;
70323: GO 69567
70325: POP
70326: POP
// end ;
70327: LD_VAR 0 1
70331: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
70332: LD_INT 0
70334: PPUSH
70335: PPUSH
70336: PPUSH
70337: PPUSH
70338: PPUSH
70339: PPUSH
70340: PPUSH
70341: PPUSH
70342: PPUSH
70343: PPUSH
70344: PPUSH
// if not mc_bases then
70345: LD_EXP 61
70349: NOT
70350: IFFALSE 70354
// exit ;
70352: GO 72177
// for i = 1 to mc_bases do
70354: LD_ADDR_VAR 0 2
70358: PUSH
70359: DOUBLE
70360: LD_INT 1
70362: DEC
70363: ST_TO_ADDR
70364: LD_EXP 61
70368: PUSH
70369: FOR_TO
70370: IFFALSE 72175
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70372: LD_EXP 61
70376: PUSH
70377: LD_VAR 0 2
70381: ARRAY
70382: NOT
70383: PUSH
70384: LD_EXP 68
70388: PUSH
70389: LD_VAR 0 2
70393: ARRAY
70394: OR
70395: IFFALSE 70399
// continue ;
70397: GO 70369
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70399: LD_EXP 77
70403: PUSH
70404: LD_VAR 0 2
70408: ARRAY
70409: NOT
70410: PUSH
70411: LD_EXP 78
70415: PUSH
70416: LD_VAR 0 2
70420: ARRAY
70421: AND
70422: IFFALSE 70460
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70424: LD_ADDR_EXP 78
70428: PUSH
70429: LD_EXP 78
70433: PPUSH
70434: LD_VAR 0 2
70438: PPUSH
70439: EMPTY
70440: PPUSH
70441: CALL_OW 1
70445: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70446: LD_VAR 0 2
70450: PPUSH
70451: LD_INT 107
70453: PPUSH
70454: CALL 61186 0 2
// continue ;
70458: GO 70369
// end ; target := [ ] ;
70460: LD_ADDR_VAR 0 7
70464: PUSH
70465: EMPTY
70466: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
70467: LD_ADDR_VAR 0 6
70471: PUSH
70472: LD_EXP 61
70476: PUSH
70477: LD_VAR 0 2
70481: ARRAY
70482: PUSH
70483: LD_INT 1
70485: ARRAY
70486: PPUSH
70487: CALL_OW 255
70491: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70492: LD_ADDR_VAR 0 9
70496: PUSH
70497: LD_EXP 61
70501: PUSH
70502: LD_VAR 0 2
70506: ARRAY
70507: PPUSH
70508: LD_INT 2
70510: PUSH
70511: LD_INT 30
70513: PUSH
70514: LD_INT 0
70516: PUSH
70517: EMPTY
70518: LIST
70519: LIST
70520: PUSH
70521: LD_INT 30
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: EMPTY
70528: LIST
70529: LIST
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: LIST
70535: PPUSH
70536: CALL_OW 72
70540: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70541: LD_ADDR_VAR 0 3
70545: PUSH
70546: DOUBLE
70547: LD_EXP 77
70551: PUSH
70552: LD_VAR 0 2
70556: ARRAY
70557: INC
70558: ST_TO_ADDR
70559: LD_INT 1
70561: PUSH
70562: FOR_DOWNTO
70563: IFFALSE 70808
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70565: LD_EXP 77
70569: PUSH
70570: LD_VAR 0 2
70574: ARRAY
70575: PUSH
70576: LD_VAR 0 3
70580: ARRAY
70581: PUSH
70582: LD_INT 2
70584: ARRAY
70585: PPUSH
70586: LD_EXP 77
70590: PUSH
70591: LD_VAR 0 2
70595: ARRAY
70596: PUSH
70597: LD_VAR 0 3
70601: ARRAY
70602: PUSH
70603: LD_INT 3
70605: ARRAY
70606: PPUSH
70607: CALL_OW 488
70611: PUSH
70612: LD_EXP 77
70616: PUSH
70617: LD_VAR 0 2
70621: ARRAY
70622: PUSH
70623: LD_VAR 0 3
70627: ARRAY
70628: PUSH
70629: LD_INT 2
70631: ARRAY
70632: PPUSH
70633: LD_EXP 77
70637: PUSH
70638: LD_VAR 0 2
70642: ARRAY
70643: PUSH
70644: LD_VAR 0 3
70648: ARRAY
70649: PUSH
70650: LD_INT 3
70652: ARRAY
70653: PPUSH
70654: CALL_OW 284
70658: PUSH
70659: LD_INT 0
70661: EQUAL
70662: AND
70663: IFFALSE 70718
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70665: LD_ADDR_VAR 0 5
70669: PUSH
70670: LD_EXP 77
70674: PUSH
70675: LD_VAR 0 2
70679: ARRAY
70680: PPUSH
70681: LD_VAR 0 3
70685: PPUSH
70686: CALL_OW 3
70690: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70691: LD_ADDR_EXP 77
70695: PUSH
70696: LD_EXP 77
70700: PPUSH
70701: LD_VAR 0 2
70705: PPUSH
70706: LD_VAR 0 5
70710: PPUSH
70711: CALL_OW 1
70715: ST_TO_ADDR
// continue ;
70716: GO 70562
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70718: LD_VAR 0 6
70722: PPUSH
70723: LD_EXP 77
70727: PUSH
70728: LD_VAR 0 2
70732: ARRAY
70733: PUSH
70734: LD_VAR 0 3
70738: ARRAY
70739: PUSH
70740: LD_INT 2
70742: ARRAY
70743: PPUSH
70744: LD_EXP 77
70748: PUSH
70749: LD_VAR 0 2
70753: ARRAY
70754: PUSH
70755: LD_VAR 0 3
70759: ARRAY
70760: PUSH
70761: LD_INT 3
70763: ARRAY
70764: PPUSH
70765: LD_INT 30
70767: PPUSH
70768: CALL 21359 0 4
70772: PUSH
70773: LD_INT 4
70775: ARRAY
70776: PUSH
70777: LD_INT 0
70779: EQUAL
70780: IFFALSE 70806
// begin target := mc_crates [ i ] [ j ] ;
70782: LD_ADDR_VAR 0 7
70786: PUSH
70787: LD_EXP 77
70791: PUSH
70792: LD_VAR 0 2
70796: ARRAY
70797: PUSH
70798: LD_VAR 0 3
70802: ARRAY
70803: ST_TO_ADDR
// break ;
70804: GO 70808
// end ; end ;
70806: GO 70562
70808: POP
70809: POP
// if not target then
70810: LD_VAR 0 7
70814: NOT
70815: IFFALSE 70819
// continue ;
70817: GO 70369
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70819: LD_ADDR_VAR 0 8
70823: PUSH
70824: LD_EXP 80
70828: PUSH
70829: LD_VAR 0 2
70833: ARRAY
70834: PPUSH
70835: LD_INT 2
70837: PUSH
70838: LD_INT 3
70840: PUSH
70841: LD_INT 58
70843: PUSH
70844: EMPTY
70845: LIST
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 61
70853: PUSH
70854: EMPTY
70855: LIST
70856: PUSH
70857: LD_INT 33
70859: PUSH
70860: LD_INT 5
70862: PUSH
70863: EMPTY
70864: LIST
70865: LIST
70866: PUSH
70867: LD_INT 33
70869: PUSH
70870: LD_INT 3
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: LIST
70881: LIST
70882: LIST
70883: PUSH
70884: LD_INT 2
70886: PUSH
70887: LD_INT 34
70889: PUSH
70890: LD_INT 32
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 34
70899: PUSH
70900: LD_INT 51
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 34
70909: PUSH
70910: LD_INT 12
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: EMPTY
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PPUSH
70927: CALL_OW 72
70931: ST_TO_ADDR
// if not cargo then
70932: LD_VAR 0 8
70936: NOT
70937: IFFALSE 71643
// begin if mc_crates_collector [ i ] < 5 then
70939: LD_EXP 78
70943: PUSH
70944: LD_VAR 0 2
70948: ARRAY
70949: PUSH
70950: LD_INT 5
70952: LESS
70953: IFFALSE 71319
// begin if mc_ape [ i ] then
70955: LD_EXP 90
70959: PUSH
70960: LD_VAR 0 2
70964: ARRAY
70965: IFFALSE 71012
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70967: LD_ADDR_VAR 0 5
70971: PUSH
70972: LD_EXP 90
70976: PUSH
70977: LD_VAR 0 2
70981: ARRAY
70982: PPUSH
70983: LD_INT 25
70985: PUSH
70986: LD_INT 16
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 24
70995: PUSH
70996: LD_INT 750
70998: PUSH
70999: EMPTY
71000: LIST
71001: LIST
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PPUSH
71007: CALL_OW 72
71011: ST_TO_ADDR
// if not tmp then
71012: LD_VAR 0 5
71016: NOT
71017: IFFALSE 71064
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71019: LD_ADDR_VAR 0 5
71023: PUSH
71024: LD_EXP 61
71028: PUSH
71029: LD_VAR 0 2
71033: ARRAY
71034: PPUSH
71035: LD_INT 25
71037: PUSH
71038: LD_INT 2
71040: PUSH
71041: EMPTY
71042: LIST
71043: LIST
71044: PUSH
71045: LD_INT 24
71047: PUSH
71048: LD_INT 750
71050: PUSH
71051: EMPTY
71052: LIST
71053: LIST
71054: PUSH
71055: EMPTY
71056: LIST
71057: LIST
71058: PPUSH
71059: CALL_OW 72
71063: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71064: LD_EXP 90
71068: PUSH
71069: LD_VAR 0 2
71073: ARRAY
71074: PUSH
71075: LD_EXP 61
71079: PUSH
71080: LD_VAR 0 2
71084: ARRAY
71085: PPUSH
71086: LD_INT 25
71088: PUSH
71089: LD_INT 2
71091: PUSH
71092: EMPTY
71093: LIST
71094: LIST
71095: PUSH
71096: LD_INT 24
71098: PUSH
71099: LD_INT 750
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PUSH
71106: EMPTY
71107: LIST
71108: LIST
71109: PPUSH
71110: CALL_OW 72
71114: AND
71115: PUSH
71116: LD_VAR 0 5
71120: PUSH
71121: LD_INT 5
71123: LESS
71124: AND
71125: IFFALSE 71207
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71127: LD_ADDR_VAR 0 3
71131: PUSH
71132: LD_EXP 61
71136: PUSH
71137: LD_VAR 0 2
71141: ARRAY
71142: PPUSH
71143: LD_INT 25
71145: PUSH
71146: LD_INT 2
71148: PUSH
71149: EMPTY
71150: LIST
71151: LIST
71152: PUSH
71153: LD_INT 24
71155: PUSH
71156: LD_INT 750
71158: PUSH
71159: EMPTY
71160: LIST
71161: LIST
71162: PUSH
71163: EMPTY
71164: LIST
71165: LIST
71166: PPUSH
71167: CALL_OW 72
71171: PUSH
71172: FOR_IN
71173: IFFALSE 71205
// begin tmp := tmp union j ;
71175: LD_ADDR_VAR 0 5
71179: PUSH
71180: LD_VAR 0 5
71184: PUSH
71185: LD_VAR 0 3
71189: UNION
71190: ST_TO_ADDR
// if tmp >= 5 then
71191: LD_VAR 0 5
71195: PUSH
71196: LD_INT 5
71198: GREATEREQUAL
71199: IFFALSE 71203
// break ;
71201: GO 71205
// end ;
71203: GO 71172
71205: POP
71206: POP
// end ; if not tmp then
71207: LD_VAR 0 5
71211: NOT
71212: IFFALSE 71216
// continue ;
71214: GO 70369
// for j in tmp do
71216: LD_ADDR_VAR 0 3
71220: PUSH
71221: LD_VAR 0 5
71225: PUSH
71226: FOR_IN
71227: IFFALSE 71317
// if not GetTag ( j ) then
71229: LD_VAR 0 3
71233: PPUSH
71234: CALL_OW 110
71238: NOT
71239: IFFALSE 71315
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71241: LD_ADDR_EXP 78
71245: PUSH
71246: LD_EXP 78
71250: PPUSH
71251: LD_VAR 0 2
71255: PUSH
71256: LD_EXP 78
71260: PUSH
71261: LD_VAR 0 2
71265: ARRAY
71266: PUSH
71267: LD_INT 1
71269: PLUS
71270: PUSH
71271: EMPTY
71272: LIST
71273: LIST
71274: PPUSH
71275: LD_VAR 0 3
71279: PPUSH
71280: CALL 20463 0 3
71284: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71285: LD_VAR 0 3
71289: PPUSH
71290: LD_INT 107
71292: PPUSH
71293: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71297: LD_EXP 78
71301: PUSH
71302: LD_VAR 0 2
71306: ARRAY
71307: PUSH
71308: LD_INT 5
71310: GREATEREQUAL
71311: IFFALSE 71315
// break ;
71313: GO 71317
// end ;
71315: GO 71226
71317: POP
71318: POP
// end ; if mc_crates_collector [ i ] and target then
71319: LD_EXP 78
71323: PUSH
71324: LD_VAR 0 2
71328: ARRAY
71329: PUSH
71330: LD_VAR 0 7
71334: AND
71335: IFFALSE 71641
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71337: LD_EXP 78
71341: PUSH
71342: LD_VAR 0 2
71346: ARRAY
71347: PUSH
71348: LD_VAR 0 7
71352: PUSH
71353: LD_INT 1
71355: ARRAY
71356: LESS
71357: IFFALSE 71377
// tmp := mc_crates_collector [ i ] else
71359: LD_ADDR_VAR 0 5
71363: PUSH
71364: LD_EXP 78
71368: PUSH
71369: LD_VAR 0 2
71373: ARRAY
71374: ST_TO_ADDR
71375: GO 71391
// tmp := target [ 1 ] ;
71377: LD_ADDR_VAR 0 5
71381: PUSH
71382: LD_VAR 0 7
71386: PUSH
71387: LD_INT 1
71389: ARRAY
71390: ST_TO_ADDR
// k := 0 ;
71391: LD_ADDR_VAR 0 4
71395: PUSH
71396: LD_INT 0
71398: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71399: LD_ADDR_VAR 0 3
71403: PUSH
71404: LD_EXP 78
71408: PUSH
71409: LD_VAR 0 2
71413: ARRAY
71414: PUSH
71415: FOR_IN
71416: IFFALSE 71639
// begin k := k + 1 ;
71418: LD_ADDR_VAR 0 4
71422: PUSH
71423: LD_VAR 0 4
71427: PUSH
71428: LD_INT 1
71430: PLUS
71431: ST_TO_ADDR
// if k > tmp then
71432: LD_VAR 0 4
71436: PUSH
71437: LD_VAR 0 5
71441: GREATER
71442: IFFALSE 71446
// break ;
71444: GO 71639
// if not GetClass ( j ) in [ 2 , 16 ] then
71446: LD_VAR 0 3
71450: PPUSH
71451: CALL_OW 257
71455: PUSH
71456: LD_INT 2
71458: PUSH
71459: LD_INT 16
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: IN
71466: NOT
71467: IFFALSE 71520
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71469: LD_ADDR_EXP 78
71473: PUSH
71474: LD_EXP 78
71478: PPUSH
71479: LD_VAR 0 2
71483: PPUSH
71484: LD_EXP 78
71488: PUSH
71489: LD_VAR 0 2
71493: ARRAY
71494: PUSH
71495: LD_VAR 0 3
71499: DIFF
71500: PPUSH
71501: CALL_OW 1
71505: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71506: LD_VAR 0 3
71510: PPUSH
71511: LD_INT 0
71513: PPUSH
71514: CALL_OW 109
// continue ;
71518: GO 71415
// end ; if IsInUnit ( j ) then
71520: LD_VAR 0 3
71524: PPUSH
71525: CALL_OW 310
71529: IFFALSE 71540
// ComExitBuilding ( j ) ;
71531: LD_VAR 0 3
71535: PPUSH
71536: CALL_OW 122
// wait ( 3 ) ;
71540: LD_INT 3
71542: PPUSH
71543: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
71547: LD_VAR 0 3
71551: PPUSH
71552: CALL_OW 314
71556: PUSH
71557: LD_VAR 0 6
71561: PPUSH
71562: LD_VAR 0 7
71566: PUSH
71567: LD_INT 2
71569: ARRAY
71570: PPUSH
71571: LD_VAR 0 7
71575: PUSH
71576: LD_INT 3
71578: ARRAY
71579: PPUSH
71580: LD_INT 30
71582: PPUSH
71583: CALL 21359 0 4
71587: PUSH
71588: LD_INT 4
71590: ARRAY
71591: AND
71592: IFFALSE 71610
// ComStandNearbyBuilding ( j , depot ) else
71594: LD_VAR 0 3
71598: PPUSH
71599: LD_VAR 0 9
71603: PPUSH
71604: CALL 17065 0 2
71608: GO 71637
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71610: LD_VAR 0 3
71614: PPUSH
71615: LD_VAR 0 7
71619: PUSH
71620: LD_INT 2
71622: ARRAY
71623: PPUSH
71624: LD_VAR 0 7
71628: PUSH
71629: LD_INT 3
71631: ARRAY
71632: PPUSH
71633: CALL_OW 117
// end ;
71637: GO 71415
71639: POP
71640: POP
// end ; end else
71641: GO 72173
// begin for j in cargo do
71643: LD_ADDR_VAR 0 3
71647: PUSH
71648: LD_VAR 0 8
71652: PUSH
71653: FOR_IN
71654: IFFALSE 72171
// begin if GetTag ( j ) <> 0 then
71656: LD_VAR 0 3
71660: PPUSH
71661: CALL_OW 110
71665: PUSH
71666: LD_INT 0
71668: NONEQUAL
71669: IFFALSE 71673
// continue ;
71671: GO 71653
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71673: LD_VAR 0 3
71677: PPUSH
71678: CALL_OW 256
71682: PUSH
71683: LD_INT 1000
71685: LESS
71686: PUSH
71687: LD_VAR 0 3
71691: PPUSH
71692: LD_EXP 85
71696: PUSH
71697: LD_VAR 0 2
71701: ARRAY
71702: PPUSH
71703: CALL_OW 308
71707: NOT
71708: AND
71709: IFFALSE 71731
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71711: LD_VAR 0 3
71715: PPUSH
71716: LD_EXP 85
71720: PUSH
71721: LD_VAR 0 2
71725: ARRAY
71726: PPUSH
71727: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71731: LD_VAR 0 3
71735: PPUSH
71736: CALL_OW 256
71740: PUSH
71741: LD_INT 1000
71743: LESS
71744: PUSH
71745: LD_VAR 0 3
71749: PPUSH
71750: LD_EXP 85
71754: PUSH
71755: LD_VAR 0 2
71759: ARRAY
71760: PPUSH
71761: CALL_OW 308
71765: AND
71766: IFFALSE 71770
// continue ;
71768: GO 71653
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71770: LD_VAR 0 3
71774: PPUSH
71775: CALL_OW 262
71779: PUSH
71780: LD_INT 2
71782: EQUAL
71783: PUSH
71784: LD_VAR 0 3
71788: PPUSH
71789: CALL_OW 261
71793: PUSH
71794: LD_INT 15
71796: LESS
71797: AND
71798: IFFALSE 71802
// continue ;
71800: GO 71653
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71802: LD_VAR 0 3
71806: PPUSH
71807: CALL_OW 262
71811: PUSH
71812: LD_INT 1
71814: EQUAL
71815: PUSH
71816: LD_VAR 0 3
71820: PPUSH
71821: CALL_OW 261
71825: PUSH
71826: LD_INT 10
71828: LESS
71829: AND
71830: IFFALSE 72110
// begin if not depot then
71832: LD_VAR 0 9
71836: NOT
71837: IFFALSE 71841
// continue ;
71839: GO 71653
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71841: LD_VAR 0 3
71845: PPUSH
71846: LD_VAR 0 9
71850: PPUSH
71851: LD_VAR 0 3
71855: PPUSH
71856: CALL_OW 74
71860: PPUSH
71861: CALL_OW 296
71865: PUSH
71866: LD_INT 6
71868: LESS
71869: IFFALSE 71885
// SetFuel ( j , 100 ) else
71871: LD_VAR 0 3
71875: PPUSH
71876: LD_INT 100
71878: PPUSH
71879: CALL_OW 240
71883: GO 72110
// if GetFuel ( j ) = 0 then
71885: LD_VAR 0 3
71889: PPUSH
71890: CALL_OW 261
71894: PUSH
71895: LD_INT 0
71897: EQUAL
71898: IFFALSE 72110
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71900: LD_ADDR_EXP 80
71904: PUSH
71905: LD_EXP 80
71909: PPUSH
71910: LD_VAR 0 2
71914: PPUSH
71915: LD_EXP 80
71919: PUSH
71920: LD_VAR 0 2
71924: ARRAY
71925: PUSH
71926: LD_VAR 0 3
71930: DIFF
71931: PPUSH
71932: CALL_OW 1
71936: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71937: LD_VAR 0 3
71941: PPUSH
71942: CALL_OW 263
71946: PUSH
71947: LD_INT 1
71949: EQUAL
71950: IFFALSE 71966
// ComExitVehicle ( IsInUnit ( j ) ) ;
71952: LD_VAR 0 3
71956: PPUSH
71957: CALL_OW 310
71961: PPUSH
71962: CALL_OW 121
// if GetControl ( j ) = control_remote then
71966: LD_VAR 0 3
71970: PPUSH
71971: CALL_OW 263
71975: PUSH
71976: LD_INT 2
71978: EQUAL
71979: IFFALSE 71990
// ComUnlink ( j ) ;
71981: LD_VAR 0 3
71985: PPUSH
71986: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71990: LD_ADDR_VAR 0 10
71994: PUSH
71995: LD_VAR 0 2
71999: PPUSH
72000: LD_INT 3
72002: PPUSH
72003: CALL 81754 0 2
72007: ST_TO_ADDR
// if fac then
72008: LD_VAR 0 10
72012: IFFALSE 72108
// begin for k in fac do
72014: LD_ADDR_VAR 0 4
72018: PUSH
72019: LD_VAR 0 10
72023: PUSH
72024: FOR_IN
72025: IFFALSE 72106
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72027: LD_ADDR_VAR 0 11
72031: PUSH
72032: LD_VAR 0 10
72036: PPUSH
72037: LD_VAR 0 3
72041: PPUSH
72042: CALL_OW 265
72046: PPUSH
72047: LD_VAR 0 3
72051: PPUSH
72052: CALL_OW 262
72056: PPUSH
72057: LD_VAR 0 3
72061: PPUSH
72062: CALL_OW 263
72066: PPUSH
72067: LD_VAR 0 3
72071: PPUSH
72072: CALL_OW 264
72076: PPUSH
72077: CALL 17961 0 5
72081: ST_TO_ADDR
// if components then
72082: LD_VAR 0 11
72086: IFFALSE 72104
// begin MC_InsertProduceList ( i , components ) ;
72088: LD_VAR 0 2
72092: PPUSH
72093: LD_VAR 0 11
72097: PPUSH
72098: CALL 81299 0 2
// break ;
72102: GO 72106
// end ; end ;
72104: GO 72024
72106: POP
72107: POP
// end ; continue ;
72108: GO 71653
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72110: LD_VAR 0 3
72114: PPUSH
72115: LD_INT 1
72117: PPUSH
72118: CALL_OW 289
72122: PUSH
72123: LD_INT 100
72125: LESS
72126: PUSH
72127: LD_VAR 0 3
72131: PPUSH
72132: CALL_OW 314
72136: NOT
72137: AND
72138: IFFALSE 72167
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72140: LD_VAR 0 3
72144: PPUSH
72145: LD_VAR 0 7
72149: PUSH
72150: LD_INT 2
72152: ARRAY
72153: PPUSH
72154: LD_VAR 0 7
72158: PUSH
72159: LD_INT 3
72161: ARRAY
72162: PPUSH
72163: CALL_OW 117
// break ;
72167: GO 72171
// end ;
72169: GO 71653
72171: POP
72172: POP
// end ; end ;
72173: GO 70369
72175: POP
72176: POP
// end ;
72177: LD_VAR 0 1
72181: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72182: LD_INT 0
72184: PPUSH
72185: PPUSH
72186: PPUSH
72187: PPUSH
// if not mc_bases then
72188: LD_EXP 61
72192: NOT
72193: IFFALSE 72197
// exit ;
72195: GO 72358
// for i = 1 to mc_bases do
72197: LD_ADDR_VAR 0 2
72201: PUSH
72202: DOUBLE
72203: LD_INT 1
72205: DEC
72206: ST_TO_ADDR
72207: LD_EXP 61
72211: PUSH
72212: FOR_TO
72213: IFFALSE 72356
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72215: LD_ADDR_VAR 0 4
72219: PUSH
72220: LD_EXP 80
72224: PUSH
72225: LD_VAR 0 2
72229: ARRAY
72230: PUSH
72231: LD_EXP 83
72235: PUSH
72236: LD_VAR 0 2
72240: ARRAY
72241: UNION
72242: PPUSH
72243: LD_INT 33
72245: PUSH
72246: LD_INT 2
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PPUSH
72253: CALL_OW 72
72257: ST_TO_ADDR
// if tmp then
72258: LD_VAR 0 4
72262: IFFALSE 72354
// for j in tmp do
72264: LD_ADDR_VAR 0 3
72268: PUSH
72269: LD_VAR 0 4
72273: PUSH
72274: FOR_IN
72275: IFFALSE 72352
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72277: LD_VAR 0 3
72281: PPUSH
72282: CALL_OW 312
72286: NOT
72287: PUSH
72288: LD_VAR 0 3
72292: PPUSH
72293: CALL_OW 256
72297: PUSH
72298: LD_INT 250
72300: GREATEREQUAL
72301: AND
72302: IFFALSE 72315
// Connect ( j ) else
72304: LD_VAR 0 3
72308: PPUSH
72309: CALL 23441 0 1
72313: GO 72350
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72315: LD_VAR 0 3
72319: PPUSH
72320: CALL_OW 256
72324: PUSH
72325: LD_INT 250
72327: LESS
72328: PUSH
72329: LD_VAR 0 3
72333: PPUSH
72334: CALL_OW 312
72338: AND
72339: IFFALSE 72350
// ComUnlink ( j ) ;
72341: LD_VAR 0 3
72345: PPUSH
72346: CALL_OW 136
72350: GO 72274
72352: POP
72353: POP
// end ;
72354: GO 72212
72356: POP
72357: POP
// end ;
72358: LD_VAR 0 1
72362: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72363: LD_INT 0
72365: PPUSH
72366: PPUSH
72367: PPUSH
72368: PPUSH
72369: PPUSH
// if not mc_bases then
72370: LD_EXP 61
72374: NOT
72375: IFFALSE 72379
// exit ;
72377: GO 72824
// for i = 1 to mc_bases do
72379: LD_ADDR_VAR 0 2
72383: PUSH
72384: DOUBLE
72385: LD_INT 1
72387: DEC
72388: ST_TO_ADDR
72389: LD_EXP 61
72393: PUSH
72394: FOR_TO
72395: IFFALSE 72822
// begin if not mc_produce [ i ] then
72397: LD_EXP 82
72401: PUSH
72402: LD_VAR 0 2
72406: ARRAY
72407: NOT
72408: IFFALSE 72412
// continue ;
72410: GO 72394
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72412: LD_ADDR_VAR 0 5
72416: PUSH
72417: LD_EXP 61
72421: PUSH
72422: LD_VAR 0 2
72426: ARRAY
72427: PPUSH
72428: LD_INT 30
72430: PUSH
72431: LD_INT 3
72433: PUSH
72434: EMPTY
72435: LIST
72436: LIST
72437: PPUSH
72438: CALL_OW 72
72442: ST_TO_ADDR
// if not fac then
72443: LD_VAR 0 5
72447: NOT
72448: IFFALSE 72452
// continue ;
72450: GO 72394
// for j in fac do
72452: LD_ADDR_VAR 0 3
72456: PUSH
72457: LD_VAR 0 5
72461: PUSH
72462: FOR_IN
72463: IFFALSE 72818
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72465: LD_VAR 0 3
72469: PPUSH
72470: CALL_OW 461
72474: PUSH
72475: LD_INT 2
72477: NONEQUAL
72478: PUSH
72479: LD_VAR 0 3
72483: PPUSH
72484: LD_INT 15
72486: PPUSH
72487: CALL 23060 0 2
72491: PUSH
72492: LD_INT 4
72494: ARRAY
72495: OR
72496: IFFALSE 72500
// continue ;
72498: GO 72462
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72500: LD_VAR 0 3
72504: PPUSH
72505: LD_EXP 82
72509: PUSH
72510: LD_VAR 0 2
72514: ARRAY
72515: PUSH
72516: LD_INT 1
72518: ARRAY
72519: PUSH
72520: LD_INT 1
72522: ARRAY
72523: PPUSH
72524: LD_EXP 82
72528: PUSH
72529: LD_VAR 0 2
72533: ARRAY
72534: PUSH
72535: LD_INT 1
72537: ARRAY
72538: PUSH
72539: LD_INT 2
72541: ARRAY
72542: PPUSH
72543: LD_EXP 82
72547: PUSH
72548: LD_VAR 0 2
72552: ARRAY
72553: PUSH
72554: LD_INT 1
72556: ARRAY
72557: PUSH
72558: LD_INT 3
72560: ARRAY
72561: PPUSH
72562: LD_EXP 82
72566: PUSH
72567: LD_VAR 0 2
72571: ARRAY
72572: PUSH
72573: LD_INT 1
72575: ARRAY
72576: PUSH
72577: LD_INT 4
72579: ARRAY
72580: PPUSH
72581: CALL_OW 448
72585: PUSH
72586: LD_VAR 0 3
72590: PPUSH
72591: LD_EXP 82
72595: PUSH
72596: LD_VAR 0 2
72600: ARRAY
72601: PUSH
72602: LD_INT 1
72604: ARRAY
72605: PUSH
72606: LD_INT 1
72608: ARRAY
72609: PUSH
72610: LD_EXP 82
72614: PUSH
72615: LD_VAR 0 2
72619: ARRAY
72620: PUSH
72621: LD_INT 1
72623: ARRAY
72624: PUSH
72625: LD_INT 2
72627: ARRAY
72628: PUSH
72629: LD_EXP 82
72633: PUSH
72634: LD_VAR 0 2
72638: ARRAY
72639: PUSH
72640: LD_INT 1
72642: ARRAY
72643: PUSH
72644: LD_INT 3
72646: ARRAY
72647: PUSH
72648: LD_EXP 82
72652: PUSH
72653: LD_VAR 0 2
72657: ARRAY
72658: PUSH
72659: LD_INT 1
72661: ARRAY
72662: PUSH
72663: LD_INT 4
72665: ARRAY
72666: PUSH
72667: EMPTY
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: PPUSH
72673: CALL 26836 0 2
72677: AND
72678: IFFALSE 72816
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72680: LD_VAR 0 3
72684: PPUSH
72685: LD_EXP 82
72689: PUSH
72690: LD_VAR 0 2
72694: ARRAY
72695: PUSH
72696: LD_INT 1
72698: ARRAY
72699: PUSH
72700: LD_INT 1
72702: ARRAY
72703: PPUSH
72704: LD_EXP 82
72708: PUSH
72709: LD_VAR 0 2
72713: ARRAY
72714: PUSH
72715: LD_INT 1
72717: ARRAY
72718: PUSH
72719: LD_INT 2
72721: ARRAY
72722: PPUSH
72723: LD_EXP 82
72727: PUSH
72728: LD_VAR 0 2
72732: ARRAY
72733: PUSH
72734: LD_INT 1
72736: ARRAY
72737: PUSH
72738: LD_INT 3
72740: ARRAY
72741: PPUSH
72742: LD_EXP 82
72746: PUSH
72747: LD_VAR 0 2
72751: ARRAY
72752: PUSH
72753: LD_INT 1
72755: ARRAY
72756: PUSH
72757: LD_INT 4
72759: ARRAY
72760: PPUSH
72761: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72765: LD_ADDR_VAR 0 4
72769: PUSH
72770: LD_EXP 82
72774: PUSH
72775: LD_VAR 0 2
72779: ARRAY
72780: PPUSH
72781: LD_INT 1
72783: PPUSH
72784: CALL_OW 3
72788: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72789: LD_ADDR_EXP 82
72793: PUSH
72794: LD_EXP 82
72798: PPUSH
72799: LD_VAR 0 2
72803: PPUSH
72804: LD_VAR 0 4
72808: PPUSH
72809: CALL_OW 1
72813: ST_TO_ADDR
// break ;
72814: GO 72818
// end ; end ;
72816: GO 72462
72818: POP
72819: POP
// end ;
72820: GO 72394
72822: POP
72823: POP
// end ;
72824: LD_VAR 0 1
72828: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72829: LD_INT 0
72831: PPUSH
72832: PPUSH
72833: PPUSH
// if not mc_bases then
72834: LD_EXP 61
72838: NOT
72839: IFFALSE 72843
// exit ;
72841: GO 72932
// for i = 1 to mc_bases do
72843: LD_ADDR_VAR 0 2
72847: PUSH
72848: DOUBLE
72849: LD_INT 1
72851: DEC
72852: ST_TO_ADDR
72853: LD_EXP 61
72857: PUSH
72858: FOR_TO
72859: IFFALSE 72930
// begin if mc_attack [ i ] then
72861: LD_EXP 81
72865: PUSH
72866: LD_VAR 0 2
72870: ARRAY
72871: IFFALSE 72928
// begin tmp := mc_attack [ i ] [ 1 ] ;
72873: LD_ADDR_VAR 0 3
72877: PUSH
72878: LD_EXP 81
72882: PUSH
72883: LD_VAR 0 2
72887: ARRAY
72888: PUSH
72889: LD_INT 1
72891: ARRAY
72892: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72893: LD_ADDR_EXP 81
72897: PUSH
72898: LD_EXP 81
72902: PPUSH
72903: LD_VAR 0 2
72907: PPUSH
72908: EMPTY
72909: PPUSH
72910: CALL_OW 1
72914: ST_TO_ADDR
// Attack ( tmp ) ;
72915: LD_VAR 0 3
72919: PPUSH
72920: CALL 107816 0 1
// exit ;
72924: POP
72925: POP
72926: GO 72932
// end ; end ;
72928: GO 72858
72930: POP
72931: POP
// end ;
72932: LD_VAR 0 1
72936: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72937: LD_INT 0
72939: PPUSH
72940: PPUSH
72941: PPUSH
72942: PPUSH
72943: PPUSH
72944: PPUSH
72945: PPUSH
// if not mc_bases then
72946: LD_EXP 61
72950: NOT
72951: IFFALSE 72955
// exit ;
72953: GO 73812
// for i = 1 to mc_bases do
72955: LD_ADDR_VAR 0 2
72959: PUSH
72960: DOUBLE
72961: LD_INT 1
72963: DEC
72964: ST_TO_ADDR
72965: LD_EXP 61
72969: PUSH
72970: FOR_TO
72971: IFFALSE 73810
// begin if not mc_bases [ i ] then
72973: LD_EXP 61
72977: PUSH
72978: LD_VAR 0 2
72982: ARRAY
72983: NOT
72984: IFFALSE 72988
// continue ;
72986: GO 72970
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72988: LD_ADDR_VAR 0 7
72992: PUSH
72993: LD_EXP 61
72997: PUSH
72998: LD_VAR 0 2
73002: ARRAY
73003: PUSH
73004: LD_INT 1
73006: ARRAY
73007: PPUSH
73008: CALL 17287 0 1
73012: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73013: LD_ADDR_EXP 84
73017: PUSH
73018: LD_EXP 84
73022: PPUSH
73023: LD_VAR 0 2
73027: PPUSH
73028: LD_EXP 61
73032: PUSH
73033: LD_VAR 0 2
73037: ARRAY
73038: PUSH
73039: LD_INT 1
73041: ARRAY
73042: PPUSH
73043: CALL_OW 255
73047: PPUSH
73048: LD_EXP 86
73052: PUSH
73053: LD_VAR 0 2
73057: ARRAY
73058: PPUSH
73059: CALL 17252 0 2
73063: PPUSH
73064: CALL_OW 1
73068: ST_TO_ADDR
// if not mc_scan [ i ] then
73069: LD_EXP 84
73073: PUSH
73074: LD_VAR 0 2
73078: ARRAY
73079: NOT
73080: IFFALSE 73258
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
73082: LD_ADDR_EXP 104
73086: PUSH
73087: LD_EXP 104
73091: PPUSH
73092: LD_VAR 0 2
73096: PPUSH
73097: LD_INT 0
73099: PPUSH
73100: CALL_OW 1
73104: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73105: LD_ADDR_VAR 0 4
73109: PUSH
73110: LD_EXP 61
73114: PUSH
73115: LD_VAR 0 2
73119: ARRAY
73120: PPUSH
73121: LD_INT 2
73123: PUSH
73124: LD_INT 25
73126: PUSH
73127: LD_INT 5
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 25
73136: PUSH
73137: LD_INT 8
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: LD_INT 25
73146: PUSH
73147: LD_INT 9
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: EMPTY
73155: LIST
73156: LIST
73157: LIST
73158: LIST
73159: PPUSH
73160: CALL_OW 72
73164: ST_TO_ADDR
// if not tmp then
73165: LD_VAR 0 4
73169: NOT
73170: IFFALSE 73174
// continue ;
73172: GO 72970
// for j in tmp do
73174: LD_ADDR_VAR 0 3
73178: PUSH
73179: LD_VAR 0 4
73183: PUSH
73184: FOR_IN
73185: IFFALSE 73256
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73187: LD_VAR 0 3
73191: PPUSH
73192: CALL_OW 310
73196: PPUSH
73197: CALL_OW 266
73201: PUSH
73202: LD_INT 5
73204: EQUAL
73205: PUSH
73206: LD_VAR 0 3
73210: PPUSH
73211: CALL_OW 257
73215: PUSH
73216: LD_INT 1
73218: EQUAL
73219: AND
73220: PUSH
73221: LD_VAR 0 3
73225: PPUSH
73226: CALL_OW 459
73230: NOT
73231: AND
73232: PUSH
73233: LD_VAR 0 7
73237: AND
73238: IFFALSE 73254
// ComChangeProfession ( j , class ) ;
73240: LD_VAR 0 3
73244: PPUSH
73245: LD_VAR 0 7
73249: PPUSH
73250: CALL_OW 123
73254: GO 73184
73256: POP
73257: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
73258: LD_EXP 84
73262: PUSH
73263: LD_VAR 0 2
73267: ARRAY
73268: PUSH
73269: LD_EXP 104
73273: PUSH
73274: LD_VAR 0 2
73278: ARRAY
73279: NOT
73280: AND
73281: PUSH
73282: LD_EXP 83
73286: PUSH
73287: LD_VAR 0 2
73291: ARRAY
73292: NOT
73293: AND
73294: PUSH
73295: LD_EXP 61
73299: PUSH
73300: LD_VAR 0 2
73304: ARRAY
73305: PPUSH
73306: LD_INT 50
73308: PUSH
73309: EMPTY
73310: LIST
73311: PUSH
73312: LD_INT 2
73314: PUSH
73315: LD_INT 30
73317: PUSH
73318: LD_INT 32
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: LD_INT 30
73327: PUSH
73328: LD_INT 33
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 30
73337: PUSH
73338: LD_INT 4
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 30
73347: PUSH
73348: LD_INT 5
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PPUSH
73366: CALL_OW 72
73370: PUSH
73371: LD_INT 4
73373: LESS
73374: PUSH
73375: LD_EXP 61
73379: PUSH
73380: LD_VAR 0 2
73384: ARRAY
73385: PPUSH
73386: LD_INT 3
73388: PUSH
73389: LD_INT 24
73391: PUSH
73392: LD_INT 1000
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 2
73405: PUSH
73406: LD_INT 30
73408: PUSH
73409: LD_INT 0
73411: PUSH
73412: EMPTY
73413: LIST
73414: LIST
73415: PUSH
73416: LD_INT 30
73418: PUSH
73419: LD_INT 1
73421: PUSH
73422: EMPTY
73423: LIST
73424: LIST
73425: PUSH
73426: EMPTY
73427: LIST
73428: LIST
73429: LIST
73430: PUSH
73431: EMPTY
73432: LIST
73433: LIST
73434: PPUSH
73435: CALL_OW 72
73439: OR
73440: AND
73441: IFFALSE 73692
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73443: LD_ADDR_EXP 104
73447: PUSH
73448: LD_EXP 104
73452: PPUSH
73453: LD_VAR 0 2
73457: PPUSH
73458: LD_INT 1
73460: PPUSH
73461: CALL_OW 1
73465: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73466: LD_ADDR_VAR 0 4
73470: PUSH
73471: LD_EXP 61
73475: PUSH
73476: LD_VAR 0 2
73480: ARRAY
73481: PPUSH
73482: LD_INT 2
73484: PUSH
73485: LD_INT 25
73487: PUSH
73488: LD_INT 1
73490: PUSH
73491: EMPTY
73492: LIST
73493: LIST
73494: PUSH
73495: LD_INT 25
73497: PUSH
73498: LD_INT 5
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 25
73507: PUSH
73508: LD_INT 8
73510: PUSH
73511: EMPTY
73512: LIST
73513: LIST
73514: PUSH
73515: LD_INT 25
73517: PUSH
73518: LD_INT 9
73520: PUSH
73521: EMPTY
73522: LIST
73523: LIST
73524: PUSH
73525: EMPTY
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: PPUSH
73532: CALL_OW 72
73536: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73537: LD_ADDR_VAR 0 4
73541: PUSH
73542: LD_VAR 0 4
73546: PUSH
73547: LD_VAR 0 4
73551: PPUSH
73552: LD_INT 18
73554: PPUSH
73555: CALL 50384 0 2
73559: DIFF
73560: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73561: LD_VAR 0 4
73565: NOT
73566: PUSH
73567: LD_EXP 61
73571: PUSH
73572: LD_VAR 0 2
73576: ARRAY
73577: PPUSH
73578: LD_INT 2
73580: PUSH
73581: LD_INT 30
73583: PUSH
73584: LD_INT 4
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: PUSH
73591: LD_INT 30
73593: PUSH
73594: LD_INT 5
73596: PUSH
73597: EMPTY
73598: LIST
73599: LIST
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: LIST
73605: PPUSH
73606: CALL_OW 72
73610: NOT
73611: AND
73612: IFFALSE 73674
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
73614: LD_ADDR_VAR 0 4
73618: PUSH
73619: LD_EXP 61
73623: PUSH
73624: LD_VAR 0 2
73628: ARRAY
73629: PPUSH
73630: LD_INT 2
73632: PUSH
73633: LD_INT 25
73635: PUSH
73636: LD_INT 2
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 25
73645: PUSH
73646: LD_INT 3
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: LD_INT 25
73655: PUSH
73656: LD_INT 4
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: LIST
73667: LIST
73668: PPUSH
73669: CALL_OW 72
73673: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
73674: LD_VAR 0 2
73678: PPUSH
73679: LD_VAR 0 4
73683: PPUSH
73684: CALL 112525 0 2
// exit ;
73688: POP
73689: POP
73690: GO 73812
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
73692: LD_EXP 84
73696: PUSH
73697: LD_VAR 0 2
73701: ARRAY
73702: PUSH
73703: LD_EXP 104
73707: PUSH
73708: LD_VAR 0 2
73712: ARRAY
73713: NOT
73714: AND
73715: PUSH
73716: LD_EXP 83
73720: PUSH
73721: LD_VAR 0 2
73725: ARRAY
73726: AND
73727: IFFALSE 73808
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
73729: LD_ADDR_EXP 104
73733: PUSH
73734: LD_EXP 104
73738: PPUSH
73739: LD_VAR 0 2
73743: PPUSH
73744: LD_INT 1
73746: PPUSH
73747: CALL_OW 1
73751: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
73752: LD_ADDR_VAR 0 4
73756: PUSH
73757: LD_EXP 83
73761: PUSH
73762: LD_VAR 0 2
73766: ARRAY
73767: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
73768: LD_ADDR_EXP 83
73772: PUSH
73773: LD_EXP 83
73777: PPUSH
73778: LD_VAR 0 2
73782: PPUSH
73783: EMPTY
73784: PPUSH
73785: CALL_OW 1
73789: ST_TO_ADDR
// Defend ( i , tmp ) ;
73790: LD_VAR 0 2
73794: PPUSH
73795: LD_VAR 0 4
73799: PPUSH
73800: CALL 113121 0 2
// exit ;
73804: POP
73805: POP
73806: GO 73812
// end ; end ;
73808: GO 72970
73810: POP
73811: POP
// end ;
73812: LD_VAR 0 1
73816: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73817: LD_INT 0
73819: PPUSH
73820: PPUSH
73821: PPUSH
73822: PPUSH
73823: PPUSH
73824: PPUSH
73825: PPUSH
73826: PPUSH
73827: PPUSH
73828: PPUSH
73829: PPUSH
// if not mc_bases then
73830: LD_EXP 61
73834: NOT
73835: IFFALSE 73839
// exit ;
73837: GO 74926
// for i = 1 to mc_bases do
73839: LD_ADDR_VAR 0 2
73843: PUSH
73844: DOUBLE
73845: LD_INT 1
73847: DEC
73848: ST_TO_ADDR
73849: LD_EXP 61
73853: PUSH
73854: FOR_TO
73855: IFFALSE 74924
// begin tmp := mc_lab [ i ] ;
73857: LD_ADDR_VAR 0 6
73861: PUSH
73862: LD_EXP 94
73866: PUSH
73867: LD_VAR 0 2
73871: ARRAY
73872: ST_TO_ADDR
// if not tmp then
73873: LD_VAR 0 6
73877: NOT
73878: IFFALSE 73882
// continue ;
73880: GO 73854
// idle_lab := 0 ;
73882: LD_ADDR_VAR 0 11
73886: PUSH
73887: LD_INT 0
73889: ST_TO_ADDR
// for j in tmp do
73890: LD_ADDR_VAR 0 3
73894: PUSH
73895: LD_VAR 0 6
73899: PUSH
73900: FOR_IN
73901: IFFALSE 74920
// begin researching := false ;
73903: LD_ADDR_VAR 0 10
73907: PUSH
73908: LD_INT 0
73910: ST_TO_ADDR
// side := GetSide ( j ) ;
73911: LD_ADDR_VAR 0 4
73915: PUSH
73916: LD_VAR 0 3
73920: PPUSH
73921: CALL_OW 255
73925: ST_TO_ADDR
// if not mc_tech [ side ] then
73926: LD_EXP 88
73930: PUSH
73931: LD_VAR 0 4
73935: ARRAY
73936: NOT
73937: IFFALSE 73941
// continue ;
73939: GO 73900
// if BuildingStatus ( j ) = bs_idle then
73941: LD_VAR 0 3
73945: PPUSH
73946: CALL_OW 461
73950: PUSH
73951: LD_INT 2
73953: EQUAL
73954: IFFALSE 74142
// begin if idle_lab and UnitsInside ( j ) < 6 then
73956: LD_VAR 0 11
73960: PUSH
73961: LD_VAR 0 3
73965: PPUSH
73966: CALL_OW 313
73970: PUSH
73971: LD_INT 6
73973: LESS
73974: AND
73975: IFFALSE 74046
// begin tmp2 := UnitsInside ( idle_lab ) ;
73977: LD_ADDR_VAR 0 9
73981: PUSH
73982: LD_VAR 0 11
73986: PPUSH
73987: CALL_OW 313
73991: ST_TO_ADDR
// if tmp2 then
73992: LD_VAR 0 9
73996: IFFALSE 74038
// for x in tmp2 do
73998: LD_ADDR_VAR 0 7
74002: PUSH
74003: LD_VAR 0 9
74007: PUSH
74008: FOR_IN
74009: IFFALSE 74036
// begin ComExitBuilding ( x ) ;
74011: LD_VAR 0 7
74015: PPUSH
74016: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74020: LD_VAR 0 7
74024: PPUSH
74025: LD_VAR 0 3
74029: PPUSH
74030: CALL_OW 180
// end ;
74034: GO 74008
74036: POP
74037: POP
// idle_lab := 0 ;
74038: LD_ADDR_VAR 0 11
74042: PUSH
74043: LD_INT 0
74045: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
74046: LD_ADDR_VAR 0 5
74050: PUSH
74051: LD_EXP 88
74055: PUSH
74056: LD_VAR 0 4
74060: ARRAY
74061: PUSH
74062: FOR_IN
74063: IFFALSE 74123
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
74065: LD_VAR 0 3
74069: PPUSH
74070: LD_VAR 0 5
74074: PPUSH
74075: CALL_OW 430
74079: PUSH
74080: LD_VAR 0 4
74084: PPUSH
74085: LD_VAR 0 5
74089: PPUSH
74090: CALL 16357 0 2
74094: AND
74095: IFFALSE 74121
// begin researching := true ;
74097: LD_ADDR_VAR 0 10
74101: PUSH
74102: LD_INT 1
74104: ST_TO_ADDR
// ComResearch ( j , t ) ;
74105: LD_VAR 0 3
74109: PPUSH
74110: LD_VAR 0 5
74114: PPUSH
74115: CALL_OW 124
// break ;
74119: GO 74123
// end ;
74121: GO 74062
74123: POP
74124: POP
// if not researching then
74125: LD_VAR 0 10
74129: NOT
74130: IFFALSE 74142
// idle_lab := j ;
74132: LD_ADDR_VAR 0 11
74136: PUSH
74137: LD_VAR 0 3
74141: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
74142: LD_VAR 0 3
74146: PPUSH
74147: CALL_OW 461
74151: PUSH
74152: LD_INT 10
74154: EQUAL
74155: IFFALSE 74743
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
74157: LD_EXP 90
74161: PUSH
74162: LD_VAR 0 2
74166: ARRAY
74167: NOT
74168: PUSH
74169: LD_EXP 91
74173: PUSH
74174: LD_VAR 0 2
74178: ARRAY
74179: NOT
74180: AND
74181: PUSH
74182: LD_EXP 88
74186: PUSH
74187: LD_VAR 0 4
74191: ARRAY
74192: PUSH
74193: LD_INT 1
74195: GREATER
74196: AND
74197: IFFALSE 74328
// begin ComCancel ( j ) ;
74199: LD_VAR 0 3
74203: PPUSH
74204: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
74208: LD_ADDR_EXP 88
74212: PUSH
74213: LD_EXP 88
74217: PPUSH
74218: LD_VAR 0 4
74222: PPUSH
74223: LD_EXP 88
74227: PUSH
74228: LD_VAR 0 4
74232: ARRAY
74233: PPUSH
74234: LD_EXP 88
74238: PUSH
74239: LD_VAR 0 4
74243: ARRAY
74244: PUSH
74245: LD_INT 1
74247: MINUS
74248: PPUSH
74249: LD_EXP 88
74253: PUSH
74254: LD_VAR 0 4
74258: ARRAY
74259: PPUSH
74260: LD_INT 0
74262: PPUSH
74263: CALL 19881 0 4
74267: PPUSH
74268: CALL_OW 1
74272: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
74273: LD_ADDR_EXP 88
74277: PUSH
74278: LD_EXP 88
74282: PPUSH
74283: LD_VAR 0 4
74287: PPUSH
74288: LD_EXP 88
74292: PUSH
74293: LD_VAR 0 4
74297: ARRAY
74298: PPUSH
74299: LD_EXP 88
74303: PUSH
74304: LD_VAR 0 4
74308: ARRAY
74309: PPUSH
74310: LD_INT 1
74312: PPUSH
74313: LD_INT 0
74315: PPUSH
74316: CALL 19881 0 4
74320: PPUSH
74321: CALL_OW 1
74325: ST_TO_ADDR
// continue ;
74326: GO 73900
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74328: LD_EXP 90
74332: PUSH
74333: LD_VAR 0 2
74337: ARRAY
74338: PUSH
74339: LD_EXP 91
74343: PUSH
74344: LD_VAR 0 2
74348: ARRAY
74349: NOT
74350: AND
74351: IFFALSE 74478
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74353: LD_ADDR_EXP 91
74357: PUSH
74358: LD_EXP 91
74362: PPUSH
74363: LD_VAR 0 2
74367: PUSH
74368: LD_EXP 91
74372: PUSH
74373: LD_VAR 0 2
74377: ARRAY
74378: PUSH
74379: LD_INT 1
74381: PLUS
74382: PUSH
74383: EMPTY
74384: LIST
74385: LIST
74386: PPUSH
74387: LD_EXP 90
74391: PUSH
74392: LD_VAR 0 2
74396: ARRAY
74397: PUSH
74398: LD_INT 1
74400: ARRAY
74401: PPUSH
74402: CALL 20463 0 3
74406: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74407: LD_EXP 90
74411: PUSH
74412: LD_VAR 0 2
74416: ARRAY
74417: PUSH
74418: LD_INT 1
74420: ARRAY
74421: PPUSH
74422: LD_INT 112
74424: PPUSH
74425: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74429: LD_ADDR_VAR 0 9
74433: PUSH
74434: LD_EXP 90
74438: PUSH
74439: LD_VAR 0 2
74443: ARRAY
74444: PPUSH
74445: LD_INT 1
74447: PPUSH
74448: CALL_OW 3
74452: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74453: LD_ADDR_EXP 90
74457: PUSH
74458: LD_EXP 90
74462: PPUSH
74463: LD_VAR 0 2
74467: PPUSH
74468: LD_VAR 0 9
74472: PPUSH
74473: CALL_OW 1
74477: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74478: LD_EXP 90
74482: PUSH
74483: LD_VAR 0 2
74487: ARRAY
74488: PUSH
74489: LD_EXP 91
74493: PUSH
74494: LD_VAR 0 2
74498: ARRAY
74499: AND
74500: PUSH
74501: LD_EXP 91
74505: PUSH
74506: LD_VAR 0 2
74510: ARRAY
74511: PUSH
74512: LD_INT 1
74514: ARRAY
74515: PPUSH
74516: CALL_OW 310
74520: NOT
74521: AND
74522: PUSH
74523: LD_VAR 0 3
74527: PPUSH
74528: CALL_OW 313
74532: PUSH
74533: LD_INT 6
74535: EQUAL
74536: AND
74537: IFFALSE 74593
// begin tmp2 := UnitsInside ( j ) ;
74539: LD_ADDR_VAR 0 9
74543: PUSH
74544: LD_VAR 0 3
74548: PPUSH
74549: CALL_OW 313
74553: ST_TO_ADDR
// if tmp2 = 6 then
74554: LD_VAR 0 9
74558: PUSH
74559: LD_INT 6
74561: EQUAL
74562: IFFALSE 74593
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74564: LD_VAR 0 9
74568: PUSH
74569: LD_INT 1
74571: ARRAY
74572: PPUSH
74573: LD_INT 112
74575: PPUSH
74576: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74580: LD_VAR 0 9
74584: PUSH
74585: LD_INT 1
74587: ARRAY
74588: PPUSH
74589: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74593: LD_EXP 91
74597: PUSH
74598: LD_VAR 0 2
74602: ARRAY
74603: PUSH
74604: LD_EXP 91
74608: PUSH
74609: LD_VAR 0 2
74613: ARRAY
74614: PUSH
74615: LD_INT 1
74617: ARRAY
74618: PPUSH
74619: CALL_OW 314
74623: NOT
74624: AND
74625: PUSH
74626: LD_EXP 91
74630: PUSH
74631: LD_VAR 0 2
74635: ARRAY
74636: PUSH
74637: LD_INT 1
74639: ARRAY
74640: PPUSH
74641: CALL_OW 310
74645: NOT
74646: AND
74647: IFFALSE 74673
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74649: LD_EXP 91
74653: PUSH
74654: LD_VAR 0 2
74658: ARRAY
74659: PUSH
74660: LD_INT 1
74662: ARRAY
74663: PPUSH
74664: LD_VAR 0 3
74668: PPUSH
74669: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74673: LD_EXP 91
74677: PUSH
74678: LD_VAR 0 2
74682: ARRAY
74683: PUSH
74684: LD_INT 1
74686: ARRAY
74687: PPUSH
74688: CALL_OW 310
74692: PUSH
74693: LD_EXP 91
74697: PUSH
74698: LD_VAR 0 2
74702: ARRAY
74703: PUSH
74704: LD_INT 1
74706: ARRAY
74707: PPUSH
74708: CALL_OW 310
74712: PPUSH
74713: CALL_OW 461
74717: PUSH
74718: LD_INT 3
74720: NONEQUAL
74721: AND
74722: IFFALSE 74743
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74724: LD_EXP 91
74728: PUSH
74729: LD_VAR 0 2
74733: ARRAY
74734: PUSH
74735: LD_INT 1
74737: ARRAY
74738: PPUSH
74739: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74743: LD_VAR 0 3
74747: PPUSH
74748: CALL_OW 461
74752: PUSH
74753: LD_INT 6
74755: EQUAL
74756: PUSH
74757: LD_VAR 0 6
74761: PUSH
74762: LD_INT 1
74764: GREATER
74765: AND
74766: IFFALSE 74918
// begin sci := [ ] ;
74768: LD_ADDR_VAR 0 8
74772: PUSH
74773: EMPTY
74774: ST_TO_ADDR
// for x in ( tmp diff j ) do
74775: LD_ADDR_VAR 0 7
74779: PUSH
74780: LD_VAR 0 6
74784: PUSH
74785: LD_VAR 0 3
74789: DIFF
74790: PUSH
74791: FOR_IN
74792: IFFALSE 74844
// begin if sci = 6 then
74794: LD_VAR 0 8
74798: PUSH
74799: LD_INT 6
74801: EQUAL
74802: IFFALSE 74806
// break ;
74804: GO 74844
// if BuildingStatus ( x ) = bs_idle then
74806: LD_VAR 0 7
74810: PPUSH
74811: CALL_OW 461
74815: PUSH
74816: LD_INT 2
74818: EQUAL
74819: IFFALSE 74842
// sci := sci ^ UnitsInside ( x ) ;
74821: LD_ADDR_VAR 0 8
74825: PUSH
74826: LD_VAR 0 8
74830: PUSH
74831: LD_VAR 0 7
74835: PPUSH
74836: CALL_OW 313
74840: ADD
74841: ST_TO_ADDR
// end ;
74842: GO 74791
74844: POP
74845: POP
// if not sci then
74846: LD_VAR 0 8
74850: NOT
74851: IFFALSE 74855
// continue ;
74853: GO 73900
// for x in sci do
74855: LD_ADDR_VAR 0 7
74859: PUSH
74860: LD_VAR 0 8
74864: PUSH
74865: FOR_IN
74866: IFFALSE 74916
// if IsInUnit ( x ) and not HasTask ( x ) then
74868: LD_VAR 0 7
74872: PPUSH
74873: CALL_OW 310
74877: PUSH
74878: LD_VAR 0 7
74882: PPUSH
74883: CALL_OW 314
74887: NOT
74888: AND
74889: IFFALSE 74914
// begin ComExitBuilding ( x ) ;
74891: LD_VAR 0 7
74895: PPUSH
74896: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74900: LD_VAR 0 7
74904: PPUSH
74905: LD_VAR 0 3
74909: PPUSH
74910: CALL_OW 180
// end ;
74914: GO 74865
74916: POP
74917: POP
// end ; end ;
74918: GO 73900
74920: POP
74921: POP
// end ;
74922: GO 73854
74924: POP
74925: POP
// end ;
74926: LD_VAR 0 1
74930: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74931: LD_INT 0
74933: PPUSH
74934: PPUSH
// if not mc_bases then
74935: LD_EXP 61
74939: NOT
74940: IFFALSE 74944
// exit ;
74942: GO 75025
// for i = 1 to mc_bases do
74944: LD_ADDR_VAR 0 2
74948: PUSH
74949: DOUBLE
74950: LD_INT 1
74952: DEC
74953: ST_TO_ADDR
74954: LD_EXP 61
74958: PUSH
74959: FOR_TO
74960: IFFALSE 75023
// if mc_mines [ i ] and mc_miners [ i ] then
74962: LD_EXP 74
74966: PUSH
74967: LD_VAR 0 2
74971: ARRAY
74972: PUSH
74973: LD_EXP 75
74977: PUSH
74978: LD_VAR 0 2
74982: ARRAY
74983: AND
74984: IFFALSE 75021
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74986: LD_EXP 75
74990: PUSH
74991: LD_VAR 0 2
74995: ARRAY
74996: PUSH
74997: LD_INT 1
74999: ARRAY
75000: PPUSH
75001: CALL_OW 255
75005: PPUSH
75006: LD_EXP 74
75010: PUSH
75011: LD_VAR 0 2
75015: ARRAY
75016: PPUSH
75017: CALL 17440 0 2
75021: GO 74959
75023: POP
75024: POP
// end ;
75025: LD_VAR 0 1
75029: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
75030: LD_INT 0
75032: PPUSH
75033: PPUSH
75034: PPUSH
75035: PPUSH
75036: PPUSH
75037: PPUSH
75038: PPUSH
75039: PPUSH
// if not mc_bases or not mc_parking then
75040: LD_EXP 61
75044: NOT
75045: PUSH
75046: LD_EXP 85
75050: NOT
75051: OR
75052: IFFALSE 75056
// exit ;
75054: GO 75794
// for i = 1 to mc_bases do
75056: LD_ADDR_VAR 0 2
75060: PUSH
75061: DOUBLE
75062: LD_INT 1
75064: DEC
75065: ST_TO_ADDR
75066: LD_EXP 61
75070: PUSH
75071: FOR_TO
75072: IFFALSE 75792
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
75074: LD_EXP 61
75078: PUSH
75079: LD_VAR 0 2
75083: ARRAY
75084: NOT
75085: PUSH
75086: LD_EXP 85
75090: PUSH
75091: LD_VAR 0 2
75095: ARRAY
75096: NOT
75097: OR
75098: IFFALSE 75102
// continue ;
75100: GO 75071
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
75102: LD_ADDR_VAR 0 5
75106: PUSH
75107: LD_EXP 61
75111: PUSH
75112: LD_VAR 0 2
75116: ARRAY
75117: PUSH
75118: LD_INT 1
75120: ARRAY
75121: PPUSH
75122: CALL_OW 255
75126: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75127: LD_ADDR_VAR 0 6
75131: PUSH
75132: LD_EXP 61
75136: PUSH
75137: LD_VAR 0 2
75141: ARRAY
75142: PPUSH
75143: LD_INT 30
75145: PUSH
75146: LD_INT 3
75148: PUSH
75149: EMPTY
75150: LIST
75151: LIST
75152: PPUSH
75153: CALL_OW 72
75157: ST_TO_ADDR
// if not fac then
75158: LD_VAR 0 6
75162: NOT
75163: IFFALSE 75214
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75165: LD_ADDR_VAR 0 6
75169: PUSH
75170: LD_EXP 61
75174: PUSH
75175: LD_VAR 0 2
75179: ARRAY
75180: PPUSH
75181: LD_INT 2
75183: PUSH
75184: LD_INT 30
75186: PUSH
75187: LD_INT 0
75189: PUSH
75190: EMPTY
75191: LIST
75192: LIST
75193: PUSH
75194: LD_INT 30
75196: PUSH
75197: LD_INT 1
75199: PUSH
75200: EMPTY
75201: LIST
75202: LIST
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: LIST
75208: PPUSH
75209: CALL_OW 72
75213: ST_TO_ADDR
// if not fac then
75214: LD_VAR 0 6
75218: NOT
75219: IFFALSE 75223
// continue ;
75221: GO 75071
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75223: LD_ADDR_VAR 0 7
75227: PUSH
75228: LD_EXP 85
75232: PUSH
75233: LD_VAR 0 2
75237: ARRAY
75238: PPUSH
75239: LD_INT 22
75241: PUSH
75242: LD_VAR 0 5
75246: PUSH
75247: EMPTY
75248: LIST
75249: LIST
75250: PUSH
75251: LD_INT 21
75253: PUSH
75254: LD_INT 2
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: LD_INT 3
75263: PUSH
75264: LD_INT 60
75266: PUSH
75267: EMPTY
75268: LIST
75269: PUSH
75270: EMPTY
75271: LIST
75272: LIST
75273: PUSH
75274: LD_INT 3
75276: PUSH
75277: LD_INT 24
75279: PUSH
75280: LD_INT 1000
75282: PUSH
75283: EMPTY
75284: LIST
75285: LIST
75286: PUSH
75287: EMPTY
75288: LIST
75289: LIST
75290: PUSH
75291: EMPTY
75292: LIST
75293: LIST
75294: LIST
75295: LIST
75296: PPUSH
75297: CALL_OW 70
75301: ST_TO_ADDR
// for j in fac do
75302: LD_ADDR_VAR 0 3
75306: PUSH
75307: LD_VAR 0 6
75311: PUSH
75312: FOR_IN
75313: IFFALSE 75408
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75315: LD_ADDR_VAR 0 7
75319: PUSH
75320: LD_VAR 0 7
75324: PUSH
75325: LD_INT 22
75327: PUSH
75328: LD_VAR 0 5
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: PUSH
75337: LD_INT 91
75339: PUSH
75340: LD_VAR 0 3
75344: PUSH
75345: LD_INT 15
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: LIST
75352: PUSH
75353: LD_INT 21
75355: PUSH
75356: LD_INT 2
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: LD_INT 3
75365: PUSH
75366: LD_INT 60
75368: PUSH
75369: EMPTY
75370: LIST
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: PUSH
75376: LD_INT 3
75378: PUSH
75379: LD_INT 24
75381: PUSH
75382: LD_INT 1000
75384: PUSH
75385: EMPTY
75386: LIST
75387: LIST
75388: PUSH
75389: EMPTY
75390: LIST
75391: LIST
75392: PUSH
75393: EMPTY
75394: LIST
75395: LIST
75396: LIST
75397: LIST
75398: LIST
75399: PPUSH
75400: CALL_OW 69
75404: UNION
75405: ST_TO_ADDR
75406: GO 75312
75408: POP
75409: POP
// if not vehs then
75410: LD_VAR 0 7
75414: NOT
75415: IFFALSE 75441
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75417: LD_ADDR_EXP 73
75421: PUSH
75422: LD_EXP 73
75426: PPUSH
75427: LD_VAR 0 2
75431: PPUSH
75432: EMPTY
75433: PPUSH
75434: CALL_OW 1
75438: ST_TO_ADDR
// continue ;
75439: GO 75071
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75441: LD_ADDR_VAR 0 8
75445: PUSH
75446: LD_EXP 61
75450: PUSH
75451: LD_VAR 0 2
75455: ARRAY
75456: PPUSH
75457: LD_INT 30
75459: PUSH
75460: LD_INT 3
75462: PUSH
75463: EMPTY
75464: LIST
75465: LIST
75466: PPUSH
75467: CALL_OW 72
75471: ST_TO_ADDR
// if tmp then
75472: LD_VAR 0 8
75476: IFFALSE 75579
// begin for j in tmp do
75478: LD_ADDR_VAR 0 3
75482: PUSH
75483: LD_VAR 0 8
75487: PUSH
75488: FOR_IN
75489: IFFALSE 75577
// for k in UnitsInside ( j ) do
75491: LD_ADDR_VAR 0 4
75495: PUSH
75496: LD_VAR 0 3
75500: PPUSH
75501: CALL_OW 313
75505: PUSH
75506: FOR_IN
75507: IFFALSE 75573
// if k then
75509: LD_VAR 0 4
75513: IFFALSE 75571
// if not k in mc_repair_vehicle [ i ] then
75515: LD_VAR 0 4
75519: PUSH
75520: LD_EXP 73
75524: PUSH
75525: LD_VAR 0 2
75529: ARRAY
75530: IN
75531: NOT
75532: IFFALSE 75571
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75534: LD_ADDR_EXP 73
75538: PUSH
75539: LD_EXP 73
75543: PPUSH
75544: LD_VAR 0 2
75548: PPUSH
75549: LD_EXP 73
75553: PUSH
75554: LD_VAR 0 2
75558: ARRAY
75559: PUSH
75560: LD_VAR 0 4
75564: UNION
75565: PPUSH
75566: CALL_OW 1
75570: ST_TO_ADDR
75571: GO 75506
75573: POP
75574: POP
75575: GO 75488
75577: POP
75578: POP
// end ; if not mc_repair_vehicle [ i ] then
75579: LD_EXP 73
75583: PUSH
75584: LD_VAR 0 2
75588: ARRAY
75589: NOT
75590: IFFALSE 75594
// continue ;
75592: GO 75071
// for j in mc_repair_vehicle [ i ] do
75594: LD_ADDR_VAR 0 3
75598: PUSH
75599: LD_EXP 73
75603: PUSH
75604: LD_VAR 0 2
75608: ARRAY
75609: PUSH
75610: FOR_IN
75611: IFFALSE 75788
// begin if GetClass ( j ) <> 3 then
75613: LD_VAR 0 3
75617: PPUSH
75618: CALL_OW 257
75622: PUSH
75623: LD_INT 3
75625: NONEQUAL
75626: IFFALSE 75667
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75628: LD_ADDR_EXP 73
75632: PUSH
75633: LD_EXP 73
75637: PPUSH
75638: LD_VAR 0 2
75642: PPUSH
75643: LD_EXP 73
75647: PUSH
75648: LD_VAR 0 2
75652: ARRAY
75653: PUSH
75654: LD_VAR 0 3
75658: DIFF
75659: PPUSH
75660: CALL_OW 1
75664: ST_TO_ADDR
// continue ;
75665: GO 75610
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75667: LD_VAR 0 3
75671: PPUSH
75672: CALL_OW 311
75676: NOT
75677: PUSH
75678: LD_VAR 0 3
75682: PUSH
75683: LD_EXP 64
75687: PUSH
75688: LD_VAR 0 2
75692: ARRAY
75693: PUSH
75694: LD_INT 1
75696: ARRAY
75697: IN
75698: NOT
75699: AND
75700: PUSH
75701: LD_VAR 0 3
75705: PUSH
75706: LD_EXP 64
75710: PUSH
75711: LD_VAR 0 2
75715: ARRAY
75716: PUSH
75717: LD_INT 2
75719: ARRAY
75720: IN
75721: NOT
75722: AND
75723: IFFALSE 75786
// begin if IsInUnit ( j ) then
75725: LD_VAR 0 3
75729: PPUSH
75730: CALL_OW 310
75734: IFFALSE 75747
// ComExitBuilding ( j ) else
75736: LD_VAR 0 3
75740: PPUSH
75741: CALL_OW 122
75745: GO 75786
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
75747: LD_VAR 0 3
75751: PPUSH
75752: LD_VAR 0 7
75756: PUSH
75757: LD_INT 1
75759: ARRAY
75760: PPUSH
75761: CALL 54867 0 2
75765: NOT
75766: IFFALSE 75786
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
75768: LD_VAR 0 3
75772: PPUSH
75773: LD_VAR 0 7
75777: PUSH
75778: LD_INT 1
75780: ARRAY
75781: PPUSH
75782: CALL_OW 129
// end ; end ;
75786: GO 75610
75788: POP
75789: POP
// end ;
75790: GO 75071
75792: POP
75793: POP
// end ;
75794: LD_VAR 0 1
75798: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75799: LD_INT 0
75801: PPUSH
75802: PPUSH
75803: PPUSH
75804: PPUSH
75805: PPUSH
75806: PPUSH
75807: PPUSH
75808: PPUSH
75809: PPUSH
75810: PPUSH
75811: PPUSH
// if not mc_bases then
75812: LD_EXP 61
75816: NOT
75817: IFFALSE 75821
// exit ;
75819: GO 76623
// for i = 1 to mc_bases do
75821: LD_ADDR_VAR 0 2
75825: PUSH
75826: DOUBLE
75827: LD_INT 1
75829: DEC
75830: ST_TO_ADDR
75831: LD_EXP 61
75835: PUSH
75836: FOR_TO
75837: IFFALSE 76621
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75839: LD_EXP 89
75843: PUSH
75844: LD_VAR 0 2
75848: ARRAY
75849: NOT
75850: PUSH
75851: LD_EXP 64
75855: PUSH
75856: LD_VAR 0 2
75860: ARRAY
75861: PUSH
75862: LD_INT 1
75864: ARRAY
75865: OR
75866: PUSH
75867: LD_EXP 64
75871: PUSH
75872: LD_VAR 0 2
75876: ARRAY
75877: PUSH
75878: LD_INT 2
75880: ARRAY
75881: OR
75882: PUSH
75883: LD_EXP 87
75887: PUSH
75888: LD_VAR 0 2
75892: ARRAY
75893: PPUSH
75894: LD_INT 1
75896: PPUSH
75897: CALL_OW 325
75901: NOT
75902: OR
75903: PUSH
75904: LD_EXP 84
75908: PUSH
75909: LD_VAR 0 2
75913: ARRAY
75914: OR
75915: IFFALSE 75919
// continue ;
75917: GO 75836
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75919: LD_ADDR_VAR 0 8
75923: PUSH
75924: LD_EXP 61
75928: PUSH
75929: LD_VAR 0 2
75933: ARRAY
75934: PPUSH
75935: LD_INT 25
75937: PUSH
75938: LD_INT 4
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 50
75947: PUSH
75948: EMPTY
75949: LIST
75950: PUSH
75951: LD_INT 3
75953: PUSH
75954: LD_INT 60
75956: PUSH
75957: EMPTY
75958: LIST
75959: PUSH
75960: EMPTY
75961: LIST
75962: LIST
75963: PUSH
75964: EMPTY
75965: LIST
75966: LIST
75967: LIST
75968: PPUSH
75969: CALL_OW 72
75973: PUSH
75974: LD_EXP 65
75978: PUSH
75979: LD_VAR 0 2
75983: ARRAY
75984: DIFF
75985: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75986: LD_ADDR_VAR 0 9
75990: PUSH
75991: LD_EXP 61
75995: PUSH
75996: LD_VAR 0 2
76000: ARRAY
76001: PPUSH
76002: LD_INT 2
76004: PUSH
76005: LD_INT 30
76007: PUSH
76008: LD_INT 0
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 30
76017: PUSH
76018: LD_INT 1
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: EMPTY
76026: LIST
76027: LIST
76028: LIST
76029: PPUSH
76030: CALL_OW 72
76034: ST_TO_ADDR
// if not tmp or not dep then
76035: LD_VAR 0 8
76039: NOT
76040: PUSH
76041: LD_VAR 0 9
76045: NOT
76046: OR
76047: IFFALSE 76051
// continue ;
76049: GO 75836
// side := GetSide ( tmp [ 1 ] ) ;
76051: LD_ADDR_VAR 0 11
76055: PUSH
76056: LD_VAR 0 8
76060: PUSH
76061: LD_INT 1
76063: ARRAY
76064: PPUSH
76065: CALL_OW 255
76069: ST_TO_ADDR
// dep := dep [ 1 ] ;
76070: LD_ADDR_VAR 0 9
76074: PUSH
76075: LD_VAR 0 9
76079: PUSH
76080: LD_INT 1
76082: ARRAY
76083: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
76084: LD_ADDR_VAR 0 7
76088: PUSH
76089: LD_EXP 89
76093: PUSH
76094: LD_VAR 0 2
76098: ARRAY
76099: PPUSH
76100: LD_INT 22
76102: PUSH
76103: LD_INT 0
76105: PUSH
76106: EMPTY
76107: LIST
76108: LIST
76109: PUSH
76110: LD_INT 25
76112: PUSH
76113: LD_INT 12
76115: PUSH
76116: EMPTY
76117: LIST
76118: LIST
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PPUSH
76124: CALL_OW 70
76128: PUSH
76129: LD_INT 22
76131: PUSH
76132: LD_INT 0
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: LD_INT 25
76141: PUSH
76142: LD_INT 12
76144: PUSH
76145: EMPTY
76146: LIST
76147: LIST
76148: PUSH
76149: LD_INT 91
76151: PUSH
76152: LD_VAR 0 9
76156: PUSH
76157: LD_INT 20
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: LIST
76164: PUSH
76165: EMPTY
76166: LIST
76167: LIST
76168: LIST
76169: PPUSH
76170: CALL_OW 69
76174: UNION
76175: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
76176: LD_ADDR_VAR 0 10
76180: PUSH
76181: LD_EXP 89
76185: PUSH
76186: LD_VAR 0 2
76190: ARRAY
76191: PPUSH
76192: LD_INT 81
76194: PUSH
76195: LD_VAR 0 11
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PPUSH
76204: CALL_OW 70
76208: ST_TO_ADDR
// if not apes or danger_at_area then
76209: LD_VAR 0 7
76213: NOT
76214: PUSH
76215: LD_VAR 0 10
76219: OR
76220: IFFALSE 76270
// begin if mc_taming [ i ] then
76222: LD_EXP 92
76226: PUSH
76227: LD_VAR 0 2
76231: ARRAY
76232: IFFALSE 76268
// begin MC_Reset ( i , 121 ) ;
76234: LD_VAR 0 2
76238: PPUSH
76239: LD_INT 121
76241: PPUSH
76242: CALL 61186 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
76246: LD_ADDR_EXP 92
76250: PUSH
76251: LD_EXP 92
76255: PPUSH
76256: LD_VAR 0 2
76260: PPUSH
76261: EMPTY
76262: PPUSH
76263: CALL_OW 1
76267: ST_TO_ADDR
// end ; continue ;
76268: GO 75836
// end ; for j in tmp do
76270: LD_ADDR_VAR 0 3
76274: PUSH
76275: LD_VAR 0 8
76279: PUSH
76280: FOR_IN
76281: IFFALSE 76617
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
76283: LD_VAR 0 3
76287: PUSH
76288: LD_EXP 92
76292: PUSH
76293: LD_VAR 0 2
76297: ARRAY
76298: IN
76299: NOT
76300: PUSH
76301: LD_EXP 92
76305: PUSH
76306: LD_VAR 0 2
76310: ARRAY
76311: PUSH
76312: LD_INT 3
76314: LESS
76315: AND
76316: IFFALSE 76374
// begin SetTag ( j , 121 ) ;
76318: LD_VAR 0 3
76322: PPUSH
76323: LD_INT 121
76325: PPUSH
76326: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76330: LD_ADDR_EXP 92
76334: PUSH
76335: LD_EXP 92
76339: PPUSH
76340: LD_VAR 0 2
76344: PUSH
76345: LD_EXP 92
76349: PUSH
76350: LD_VAR 0 2
76354: ARRAY
76355: PUSH
76356: LD_INT 1
76358: PLUS
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PPUSH
76364: LD_VAR 0 3
76368: PPUSH
76369: CALL 20463 0 3
76373: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76374: LD_VAR 0 3
76378: PUSH
76379: LD_EXP 92
76383: PUSH
76384: LD_VAR 0 2
76388: ARRAY
76389: IN
76390: IFFALSE 76615
// begin if GetClass ( j ) <> 4 then
76392: LD_VAR 0 3
76396: PPUSH
76397: CALL_OW 257
76401: PUSH
76402: LD_INT 4
76404: NONEQUAL
76405: IFFALSE 76458
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76407: LD_ADDR_EXP 92
76411: PUSH
76412: LD_EXP 92
76416: PPUSH
76417: LD_VAR 0 2
76421: PPUSH
76422: LD_EXP 92
76426: PUSH
76427: LD_VAR 0 2
76431: ARRAY
76432: PUSH
76433: LD_VAR 0 3
76437: DIFF
76438: PPUSH
76439: CALL_OW 1
76443: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76444: LD_VAR 0 3
76448: PPUSH
76449: LD_INT 0
76451: PPUSH
76452: CALL_OW 109
// continue ;
76456: GO 76280
// end ; if IsInUnit ( j ) then
76458: LD_VAR 0 3
76462: PPUSH
76463: CALL_OW 310
76467: IFFALSE 76478
// ComExitBuilding ( j ) ;
76469: LD_VAR 0 3
76473: PPUSH
76474: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76478: LD_ADDR_VAR 0 6
76482: PUSH
76483: LD_VAR 0 7
76487: PPUSH
76488: LD_VAR 0 3
76492: PPUSH
76493: CALL_OW 74
76497: ST_TO_ADDR
// if not ape then
76498: LD_VAR 0 6
76502: NOT
76503: IFFALSE 76507
// break ;
76505: GO 76617
// x := GetX ( ape ) ;
76507: LD_ADDR_VAR 0 4
76511: PUSH
76512: LD_VAR 0 6
76516: PPUSH
76517: CALL_OW 250
76521: ST_TO_ADDR
// y := GetY ( ape ) ;
76522: LD_ADDR_VAR 0 5
76526: PUSH
76527: LD_VAR 0 6
76531: PPUSH
76532: CALL_OW 251
76536: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76537: LD_VAR 0 4
76541: PPUSH
76542: LD_VAR 0 5
76546: PPUSH
76547: CALL_OW 488
76551: NOT
76552: PUSH
76553: LD_VAR 0 11
76557: PPUSH
76558: LD_VAR 0 4
76562: PPUSH
76563: LD_VAR 0 5
76567: PPUSH
76568: LD_INT 20
76570: PPUSH
76571: CALL 21359 0 4
76575: PUSH
76576: LD_INT 4
76578: ARRAY
76579: OR
76580: IFFALSE 76584
// break ;
76582: GO 76617
// if not HasTask ( j ) then
76584: LD_VAR 0 3
76588: PPUSH
76589: CALL_OW 314
76593: NOT
76594: IFFALSE 76615
// ComTameXY ( j , x , y ) ;
76596: LD_VAR 0 3
76600: PPUSH
76601: LD_VAR 0 4
76605: PPUSH
76606: LD_VAR 0 5
76610: PPUSH
76611: CALL_OW 131
// end ; end ;
76615: GO 76280
76617: POP
76618: POP
// end ;
76619: GO 75836
76621: POP
76622: POP
// end ;
76623: LD_VAR 0 1
76627: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76628: LD_INT 0
76630: PPUSH
76631: PPUSH
76632: PPUSH
76633: PPUSH
76634: PPUSH
76635: PPUSH
76636: PPUSH
76637: PPUSH
// if not mc_bases then
76638: LD_EXP 61
76642: NOT
76643: IFFALSE 76647
// exit ;
76645: GO 77273
// for i = 1 to mc_bases do
76647: LD_ADDR_VAR 0 2
76651: PUSH
76652: DOUBLE
76653: LD_INT 1
76655: DEC
76656: ST_TO_ADDR
76657: LD_EXP 61
76661: PUSH
76662: FOR_TO
76663: IFFALSE 77271
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76665: LD_EXP 90
76669: PUSH
76670: LD_VAR 0 2
76674: ARRAY
76675: NOT
76676: PUSH
76677: LD_EXP 90
76681: PUSH
76682: LD_VAR 0 2
76686: ARRAY
76687: PPUSH
76688: LD_INT 25
76690: PUSH
76691: LD_INT 12
76693: PUSH
76694: EMPTY
76695: LIST
76696: LIST
76697: PPUSH
76698: CALL_OW 72
76702: NOT
76703: OR
76704: IFFALSE 76708
// continue ;
76706: GO 76662
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76708: LD_ADDR_VAR 0 5
76712: PUSH
76713: LD_EXP 90
76717: PUSH
76718: LD_VAR 0 2
76722: ARRAY
76723: PUSH
76724: LD_INT 1
76726: ARRAY
76727: PPUSH
76728: CALL_OW 255
76732: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76733: LD_VAR 0 5
76737: PPUSH
76738: LD_INT 2
76740: PPUSH
76741: CALL_OW 325
76745: IFFALSE 76998
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76747: LD_ADDR_VAR 0 4
76751: PUSH
76752: LD_EXP 90
76756: PUSH
76757: LD_VAR 0 2
76761: ARRAY
76762: PPUSH
76763: LD_INT 25
76765: PUSH
76766: LD_INT 16
76768: PUSH
76769: EMPTY
76770: LIST
76771: LIST
76772: PPUSH
76773: CALL_OW 72
76777: ST_TO_ADDR
// if tmp < 6 then
76778: LD_VAR 0 4
76782: PUSH
76783: LD_INT 6
76785: LESS
76786: IFFALSE 76998
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76788: LD_ADDR_VAR 0 6
76792: PUSH
76793: LD_EXP 61
76797: PUSH
76798: LD_VAR 0 2
76802: ARRAY
76803: PPUSH
76804: LD_INT 2
76806: PUSH
76807: LD_INT 30
76809: PUSH
76810: LD_INT 0
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: PUSH
76817: LD_INT 30
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: EMPTY
76828: LIST
76829: LIST
76830: LIST
76831: PPUSH
76832: CALL_OW 72
76836: ST_TO_ADDR
// if depot then
76837: LD_VAR 0 6
76841: IFFALSE 76998
// begin selected := 0 ;
76843: LD_ADDR_VAR 0 7
76847: PUSH
76848: LD_INT 0
76850: ST_TO_ADDR
// for j in depot do
76851: LD_ADDR_VAR 0 3
76855: PUSH
76856: LD_VAR 0 6
76860: PUSH
76861: FOR_IN
76862: IFFALSE 76893
// begin if UnitsInside ( j ) < 6 then
76864: LD_VAR 0 3
76868: PPUSH
76869: CALL_OW 313
76873: PUSH
76874: LD_INT 6
76876: LESS
76877: IFFALSE 76891
// begin selected := j ;
76879: LD_ADDR_VAR 0 7
76883: PUSH
76884: LD_VAR 0 3
76888: ST_TO_ADDR
// break ;
76889: GO 76893
// end ; end ;
76891: GO 76861
76893: POP
76894: POP
// if selected then
76895: LD_VAR 0 7
76899: IFFALSE 76998
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76901: LD_ADDR_VAR 0 3
76905: PUSH
76906: LD_EXP 90
76910: PUSH
76911: LD_VAR 0 2
76915: ARRAY
76916: PPUSH
76917: LD_INT 25
76919: PUSH
76920: LD_INT 12
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PPUSH
76927: CALL_OW 72
76931: PUSH
76932: FOR_IN
76933: IFFALSE 76996
// if not HasTask ( j ) then
76935: LD_VAR 0 3
76939: PPUSH
76940: CALL_OW 314
76944: NOT
76945: IFFALSE 76994
// begin if not IsInUnit ( j ) then
76947: LD_VAR 0 3
76951: PPUSH
76952: CALL_OW 310
76956: NOT
76957: IFFALSE 76973
// ComEnterUnit ( j , selected ) ;
76959: LD_VAR 0 3
76963: PPUSH
76964: LD_VAR 0 7
76968: PPUSH
76969: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76973: LD_VAR 0 3
76977: PPUSH
76978: LD_INT 16
76980: PPUSH
76981: CALL_OW 183
// AddComExitBuilding ( j ) ;
76985: LD_VAR 0 3
76989: PPUSH
76990: CALL_OW 182
// end ;
76994: GO 76932
76996: POP
76997: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76998: LD_VAR 0 5
77002: PPUSH
77003: LD_INT 11
77005: PPUSH
77006: CALL_OW 325
77010: IFFALSE 77269
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
77012: LD_ADDR_VAR 0 4
77016: PUSH
77017: LD_EXP 90
77021: PUSH
77022: LD_VAR 0 2
77026: ARRAY
77027: PPUSH
77028: LD_INT 25
77030: PUSH
77031: LD_INT 16
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PPUSH
77038: CALL_OW 72
77042: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
77043: LD_VAR 0 4
77047: PUSH
77048: LD_INT 6
77050: GREATEREQUAL
77051: PUSH
77052: LD_VAR 0 5
77056: PPUSH
77057: LD_INT 2
77059: PPUSH
77060: CALL_OW 325
77064: NOT
77065: OR
77066: IFFALSE 77269
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
77068: LD_ADDR_VAR 0 8
77072: PUSH
77073: LD_EXP 61
77077: PUSH
77078: LD_VAR 0 2
77082: ARRAY
77083: PPUSH
77084: LD_INT 2
77086: PUSH
77087: LD_INT 30
77089: PUSH
77090: LD_INT 4
77092: PUSH
77093: EMPTY
77094: LIST
77095: LIST
77096: PUSH
77097: LD_INT 30
77099: PUSH
77100: LD_INT 5
77102: PUSH
77103: EMPTY
77104: LIST
77105: LIST
77106: PUSH
77107: EMPTY
77108: LIST
77109: LIST
77110: LIST
77111: PPUSH
77112: CALL_OW 72
77116: ST_TO_ADDR
// if barracks then
77117: LD_VAR 0 8
77121: IFFALSE 77269
// begin selected := 0 ;
77123: LD_ADDR_VAR 0 7
77127: PUSH
77128: LD_INT 0
77130: ST_TO_ADDR
// for j in barracks do
77131: LD_ADDR_VAR 0 3
77135: PUSH
77136: LD_VAR 0 8
77140: PUSH
77141: FOR_IN
77142: IFFALSE 77173
// begin if UnitsInside ( j ) < 6 then
77144: LD_VAR 0 3
77148: PPUSH
77149: CALL_OW 313
77153: PUSH
77154: LD_INT 6
77156: LESS
77157: IFFALSE 77171
// begin selected := j ;
77159: LD_ADDR_VAR 0 7
77163: PUSH
77164: LD_VAR 0 3
77168: ST_TO_ADDR
// break ;
77169: GO 77173
// end ; end ;
77171: GO 77141
77173: POP
77174: POP
// if selected then
77175: LD_VAR 0 7
77179: IFFALSE 77269
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
77181: LD_ADDR_VAR 0 3
77185: PUSH
77186: LD_EXP 90
77190: PUSH
77191: LD_VAR 0 2
77195: ARRAY
77196: PPUSH
77197: LD_INT 25
77199: PUSH
77200: LD_INT 12
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: PPUSH
77207: CALL_OW 72
77211: PUSH
77212: FOR_IN
77213: IFFALSE 77267
// if not IsInUnit ( j ) and not HasTask ( j ) then
77215: LD_VAR 0 3
77219: PPUSH
77220: CALL_OW 310
77224: NOT
77225: PUSH
77226: LD_VAR 0 3
77230: PPUSH
77231: CALL_OW 314
77235: NOT
77236: AND
77237: IFFALSE 77265
// begin ComEnterUnit ( j , selected ) ;
77239: LD_VAR 0 3
77243: PPUSH
77244: LD_VAR 0 7
77248: PPUSH
77249: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
77253: LD_VAR 0 3
77257: PPUSH
77258: LD_INT 15
77260: PPUSH
77261: CALL_OW 183
// end ;
77265: GO 77212
77267: POP
77268: POP
// end ; end ; end ; end ; end ;
77269: GO 76662
77271: POP
77272: POP
// end ;
77273: LD_VAR 0 1
77277: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
77278: LD_INT 0
77280: PPUSH
77281: PPUSH
77282: PPUSH
77283: PPUSH
// if not mc_bases then
77284: LD_EXP 61
77288: NOT
77289: IFFALSE 77293
// exit ;
77291: GO 77471
// for i = 1 to mc_bases do
77293: LD_ADDR_VAR 0 2
77297: PUSH
77298: DOUBLE
77299: LD_INT 1
77301: DEC
77302: ST_TO_ADDR
77303: LD_EXP 61
77307: PUSH
77308: FOR_TO
77309: IFFALSE 77469
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
77311: LD_ADDR_VAR 0 4
77315: PUSH
77316: LD_EXP 61
77320: PUSH
77321: LD_VAR 0 2
77325: ARRAY
77326: PPUSH
77327: LD_INT 25
77329: PUSH
77330: LD_INT 9
77332: PUSH
77333: EMPTY
77334: LIST
77335: LIST
77336: PPUSH
77337: CALL_OW 72
77341: ST_TO_ADDR
// if not tmp then
77342: LD_VAR 0 4
77346: NOT
77347: IFFALSE 77351
// continue ;
77349: GO 77308
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77351: LD_EXP 87
77355: PUSH
77356: LD_VAR 0 2
77360: ARRAY
77361: PPUSH
77362: LD_INT 29
77364: PPUSH
77365: CALL_OW 325
77369: NOT
77370: PUSH
77371: LD_EXP 87
77375: PUSH
77376: LD_VAR 0 2
77380: ARRAY
77381: PPUSH
77382: LD_INT 28
77384: PPUSH
77385: CALL_OW 325
77389: NOT
77390: AND
77391: IFFALSE 77395
// continue ;
77393: GO 77308
// for j in tmp do
77395: LD_ADDR_VAR 0 3
77399: PUSH
77400: LD_VAR 0 4
77404: PUSH
77405: FOR_IN
77406: IFFALSE 77465
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77408: LD_VAR 0 3
77412: PUSH
77413: LD_EXP 64
77417: PUSH
77418: LD_VAR 0 2
77422: ARRAY
77423: PUSH
77424: LD_INT 1
77426: ARRAY
77427: IN
77428: NOT
77429: PUSH
77430: LD_VAR 0 3
77434: PUSH
77435: LD_EXP 64
77439: PUSH
77440: LD_VAR 0 2
77444: ARRAY
77445: PUSH
77446: LD_INT 2
77448: ARRAY
77449: IN
77450: NOT
77451: AND
77452: IFFALSE 77463
// ComSpaceTimeShoot ( j ) ;
77454: LD_VAR 0 3
77458: PPUSH
77459: CALL 16448 0 1
77463: GO 77405
77465: POP
77466: POP
// end ;
77467: GO 77308
77469: POP
77470: POP
// end ;
77471: LD_VAR 0 1
77475: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77476: LD_INT 0
77478: PPUSH
77479: PPUSH
77480: PPUSH
77481: PPUSH
77482: PPUSH
77483: PPUSH
77484: PPUSH
77485: PPUSH
77486: PPUSH
// if not mc_bases then
77487: LD_EXP 61
77491: NOT
77492: IFFALSE 77496
// exit ;
77494: GO 78118
// for i = 1 to mc_bases do
77496: LD_ADDR_VAR 0 2
77500: PUSH
77501: DOUBLE
77502: LD_INT 1
77504: DEC
77505: ST_TO_ADDR
77506: LD_EXP 61
77510: PUSH
77511: FOR_TO
77512: IFFALSE 78116
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77514: LD_EXP 96
77518: PUSH
77519: LD_VAR 0 2
77523: ARRAY
77524: NOT
77525: PUSH
77526: LD_INT 38
77528: PPUSH
77529: LD_EXP 87
77533: PUSH
77534: LD_VAR 0 2
77538: ARRAY
77539: PPUSH
77540: CALL_OW 321
77544: PUSH
77545: LD_INT 2
77547: NONEQUAL
77548: OR
77549: IFFALSE 77553
// continue ;
77551: GO 77511
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77553: LD_ADDR_VAR 0 8
77557: PUSH
77558: LD_EXP 61
77562: PUSH
77563: LD_VAR 0 2
77567: ARRAY
77568: PPUSH
77569: LD_INT 30
77571: PUSH
77572: LD_INT 34
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: PPUSH
77579: CALL_OW 72
77583: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77584: LD_ADDR_VAR 0 9
77588: PUSH
77589: LD_EXP 61
77593: PUSH
77594: LD_VAR 0 2
77598: ARRAY
77599: PPUSH
77600: LD_INT 25
77602: PUSH
77603: LD_INT 4
77605: PUSH
77606: EMPTY
77607: LIST
77608: LIST
77609: PPUSH
77610: CALL_OW 72
77614: PPUSH
77615: LD_INT 0
77617: PPUSH
77618: CALL 50384 0 2
77622: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77623: LD_VAR 0 9
77627: NOT
77628: PUSH
77629: LD_VAR 0 8
77633: NOT
77634: OR
77635: PUSH
77636: LD_EXP 61
77640: PUSH
77641: LD_VAR 0 2
77645: ARRAY
77646: PPUSH
77647: LD_INT 124
77649: PPUSH
77650: CALL 50384 0 2
77654: OR
77655: IFFALSE 77659
// continue ;
77657: GO 77511
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77659: LD_EXP 97
77663: PUSH
77664: LD_VAR 0 2
77668: ARRAY
77669: PUSH
77670: LD_EXP 96
77674: PUSH
77675: LD_VAR 0 2
77679: ARRAY
77680: LESS
77681: PUSH
77682: LD_EXP 97
77686: PUSH
77687: LD_VAR 0 2
77691: ARRAY
77692: PUSH
77693: LD_VAR 0 8
77697: LESS
77698: AND
77699: IFFALSE 78114
// begin tmp := sci [ 1 ] ;
77701: LD_ADDR_VAR 0 7
77705: PUSH
77706: LD_VAR 0 9
77710: PUSH
77711: LD_INT 1
77713: ARRAY
77714: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77715: LD_VAR 0 7
77719: PPUSH
77720: LD_INT 124
77722: PPUSH
77723: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77727: LD_ADDR_VAR 0 3
77731: PUSH
77732: DOUBLE
77733: LD_EXP 96
77737: PUSH
77738: LD_VAR 0 2
77742: ARRAY
77743: INC
77744: ST_TO_ADDR
77745: LD_EXP 96
77749: PUSH
77750: LD_VAR 0 2
77754: ARRAY
77755: PUSH
77756: FOR_DOWNTO
77757: IFFALSE 78100
// begin if IsInUnit ( tmp ) then
77759: LD_VAR 0 7
77763: PPUSH
77764: CALL_OW 310
77768: IFFALSE 77779
// ComExitBuilding ( tmp ) ;
77770: LD_VAR 0 7
77774: PPUSH
77775: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77779: LD_INT 35
77781: PPUSH
77782: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77786: LD_VAR 0 7
77790: PPUSH
77791: CALL_OW 310
77795: NOT
77796: PUSH
77797: LD_VAR 0 7
77801: PPUSH
77802: CALL_OW 314
77806: NOT
77807: AND
77808: IFFALSE 77779
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77810: LD_ADDR_VAR 0 6
77814: PUSH
77815: LD_VAR 0 7
77819: PPUSH
77820: CALL_OW 250
77824: PUSH
77825: LD_VAR 0 7
77829: PPUSH
77830: CALL_OW 251
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77839: LD_INT 35
77841: PPUSH
77842: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77846: LD_ADDR_VAR 0 4
77850: PUSH
77851: LD_EXP 96
77855: PUSH
77856: LD_VAR 0 2
77860: ARRAY
77861: PUSH
77862: LD_VAR 0 3
77866: ARRAY
77867: PUSH
77868: LD_INT 1
77870: ARRAY
77871: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77872: LD_ADDR_VAR 0 5
77876: PUSH
77877: LD_EXP 96
77881: PUSH
77882: LD_VAR 0 2
77886: ARRAY
77887: PUSH
77888: LD_VAR 0 3
77892: ARRAY
77893: PUSH
77894: LD_INT 2
77896: ARRAY
77897: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77898: LD_VAR 0 7
77902: PPUSH
77903: LD_INT 10
77905: PPUSH
77906: CALL 23060 0 2
77910: PUSH
77911: LD_INT 4
77913: ARRAY
77914: IFFALSE 77952
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77916: LD_VAR 0 7
77920: PPUSH
77921: LD_VAR 0 6
77925: PUSH
77926: LD_INT 1
77928: ARRAY
77929: PPUSH
77930: LD_VAR 0 6
77934: PUSH
77935: LD_INT 2
77937: ARRAY
77938: PPUSH
77939: CALL_OW 111
// wait ( 0 0$10 ) ;
77943: LD_INT 350
77945: PPUSH
77946: CALL_OW 67
// end else
77950: GO 77978
// begin ComMoveXY ( tmp , x , y ) ;
77952: LD_VAR 0 7
77956: PPUSH
77957: LD_VAR 0 4
77961: PPUSH
77962: LD_VAR 0 5
77966: PPUSH
77967: CALL_OW 111
// wait ( 0 0$3 ) ;
77971: LD_INT 105
77973: PPUSH
77974: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77978: LD_VAR 0 7
77982: PPUSH
77983: LD_VAR 0 4
77987: PPUSH
77988: LD_VAR 0 5
77992: PPUSH
77993: CALL_OW 307
77997: IFFALSE 77839
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77999: LD_VAR 0 7
78003: PPUSH
78004: LD_VAR 0 4
78008: PPUSH
78009: LD_VAR 0 5
78013: PPUSH
78014: LD_VAR 0 8
78018: PUSH
78019: LD_VAR 0 3
78023: ARRAY
78024: PPUSH
78025: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
78029: LD_INT 35
78031: PPUSH
78032: CALL_OW 67
// until not HasTask ( tmp ) ;
78036: LD_VAR 0 7
78040: PPUSH
78041: CALL_OW 314
78045: NOT
78046: IFFALSE 78029
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
78048: LD_ADDR_EXP 97
78052: PUSH
78053: LD_EXP 97
78057: PPUSH
78058: LD_VAR 0 2
78062: PUSH
78063: LD_EXP 97
78067: PUSH
78068: LD_VAR 0 2
78072: ARRAY
78073: PUSH
78074: LD_INT 1
78076: PLUS
78077: PUSH
78078: EMPTY
78079: LIST
78080: LIST
78081: PPUSH
78082: LD_VAR 0 8
78086: PUSH
78087: LD_VAR 0 3
78091: ARRAY
78092: PPUSH
78093: CALL 20463 0 3
78097: ST_TO_ADDR
// end ;
78098: GO 77756
78100: POP
78101: POP
// MC_Reset ( i , 124 ) ;
78102: LD_VAR 0 2
78106: PPUSH
78107: LD_INT 124
78109: PPUSH
78110: CALL 61186 0 2
// end ; end ;
78114: GO 77511
78116: POP
78117: POP
// end ;
78118: LD_VAR 0 1
78122: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
78123: LD_INT 0
78125: PPUSH
78126: PPUSH
78127: PPUSH
// if not mc_bases then
78128: LD_EXP 61
78132: NOT
78133: IFFALSE 78137
// exit ;
78135: GO 78743
// for i = 1 to mc_bases do
78137: LD_ADDR_VAR 0 2
78141: PUSH
78142: DOUBLE
78143: LD_INT 1
78145: DEC
78146: ST_TO_ADDR
78147: LD_EXP 61
78151: PUSH
78152: FOR_TO
78153: IFFALSE 78741
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
78155: LD_ADDR_VAR 0 3
78159: PUSH
78160: LD_EXP 61
78164: PUSH
78165: LD_VAR 0 2
78169: ARRAY
78170: PPUSH
78171: LD_INT 25
78173: PUSH
78174: LD_INT 4
78176: PUSH
78177: EMPTY
78178: LIST
78179: LIST
78180: PPUSH
78181: CALL_OW 72
78185: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
78186: LD_VAR 0 3
78190: NOT
78191: PUSH
78192: LD_EXP 98
78196: PUSH
78197: LD_VAR 0 2
78201: ARRAY
78202: NOT
78203: OR
78204: PUSH
78205: LD_EXP 61
78209: PUSH
78210: LD_VAR 0 2
78214: ARRAY
78215: PPUSH
78216: LD_INT 2
78218: PUSH
78219: LD_INT 30
78221: PUSH
78222: LD_INT 0
78224: PUSH
78225: EMPTY
78226: LIST
78227: LIST
78228: PUSH
78229: LD_INT 30
78231: PUSH
78232: LD_INT 1
78234: PUSH
78235: EMPTY
78236: LIST
78237: LIST
78238: PUSH
78239: EMPTY
78240: LIST
78241: LIST
78242: LIST
78243: PPUSH
78244: CALL_OW 72
78248: NOT
78249: OR
78250: IFFALSE 78300
// begin if mc_deposits_finder [ i ] then
78252: LD_EXP 99
78256: PUSH
78257: LD_VAR 0 2
78261: ARRAY
78262: IFFALSE 78298
// begin MC_Reset ( i , 125 ) ;
78264: LD_VAR 0 2
78268: PPUSH
78269: LD_INT 125
78271: PPUSH
78272: CALL 61186 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78276: LD_ADDR_EXP 99
78280: PUSH
78281: LD_EXP 99
78285: PPUSH
78286: LD_VAR 0 2
78290: PPUSH
78291: EMPTY
78292: PPUSH
78293: CALL_OW 1
78297: ST_TO_ADDR
// end ; continue ;
78298: GO 78152
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
78300: LD_EXP 98
78304: PUSH
78305: LD_VAR 0 2
78309: ARRAY
78310: PUSH
78311: LD_INT 1
78313: ARRAY
78314: PUSH
78315: LD_INT 3
78317: ARRAY
78318: PUSH
78319: LD_INT 1
78321: EQUAL
78322: PUSH
78323: LD_INT 20
78325: PPUSH
78326: LD_EXP 87
78330: PUSH
78331: LD_VAR 0 2
78335: ARRAY
78336: PPUSH
78337: CALL_OW 321
78341: PUSH
78342: LD_INT 2
78344: NONEQUAL
78345: AND
78346: IFFALSE 78396
// begin if mc_deposits_finder [ i ] then
78348: LD_EXP 99
78352: PUSH
78353: LD_VAR 0 2
78357: ARRAY
78358: IFFALSE 78394
// begin MC_Reset ( i , 125 ) ;
78360: LD_VAR 0 2
78364: PPUSH
78365: LD_INT 125
78367: PPUSH
78368: CALL 61186 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78372: LD_ADDR_EXP 99
78376: PUSH
78377: LD_EXP 99
78381: PPUSH
78382: LD_VAR 0 2
78386: PPUSH
78387: EMPTY
78388: PPUSH
78389: CALL_OW 1
78393: ST_TO_ADDR
// end ; continue ;
78394: GO 78152
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78396: LD_EXP 98
78400: PUSH
78401: LD_VAR 0 2
78405: ARRAY
78406: PUSH
78407: LD_INT 1
78409: ARRAY
78410: PUSH
78411: LD_INT 1
78413: ARRAY
78414: PPUSH
78415: LD_EXP 98
78419: PUSH
78420: LD_VAR 0 2
78424: ARRAY
78425: PUSH
78426: LD_INT 1
78428: ARRAY
78429: PUSH
78430: LD_INT 2
78432: ARRAY
78433: PPUSH
78434: LD_EXP 87
78438: PUSH
78439: LD_VAR 0 2
78443: ARRAY
78444: PPUSH
78445: CALL_OW 440
78449: IFFALSE 78492
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78451: LD_ADDR_EXP 98
78455: PUSH
78456: LD_EXP 98
78460: PPUSH
78461: LD_VAR 0 2
78465: PPUSH
78466: LD_EXP 98
78470: PUSH
78471: LD_VAR 0 2
78475: ARRAY
78476: PPUSH
78477: LD_INT 1
78479: PPUSH
78480: CALL_OW 3
78484: PPUSH
78485: CALL_OW 1
78489: ST_TO_ADDR
78490: GO 78739
// begin if not mc_deposits_finder [ i ] then
78492: LD_EXP 99
78496: PUSH
78497: LD_VAR 0 2
78501: ARRAY
78502: NOT
78503: IFFALSE 78555
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78505: LD_ADDR_EXP 99
78509: PUSH
78510: LD_EXP 99
78514: PPUSH
78515: LD_VAR 0 2
78519: PPUSH
78520: LD_VAR 0 3
78524: PUSH
78525: LD_INT 1
78527: ARRAY
78528: PUSH
78529: EMPTY
78530: LIST
78531: PPUSH
78532: CALL_OW 1
78536: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78537: LD_VAR 0 3
78541: PUSH
78542: LD_INT 1
78544: ARRAY
78545: PPUSH
78546: LD_INT 125
78548: PPUSH
78549: CALL_OW 109
// end else
78553: GO 78739
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78555: LD_EXP 99
78559: PUSH
78560: LD_VAR 0 2
78564: ARRAY
78565: PUSH
78566: LD_INT 1
78568: ARRAY
78569: PPUSH
78570: CALL_OW 310
78574: IFFALSE 78597
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78576: LD_EXP 99
78580: PUSH
78581: LD_VAR 0 2
78585: ARRAY
78586: PUSH
78587: LD_INT 1
78589: ARRAY
78590: PPUSH
78591: CALL_OW 122
78595: GO 78739
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78597: LD_EXP 99
78601: PUSH
78602: LD_VAR 0 2
78606: ARRAY
78607: PUSH
78608: LD_INT 1
78610: ARRAY
78611: PPUSH
78612: CALL_OW 314
78616: NOT
78617: PUSH
78618: LD_EXP 99
78622: PUSH
78623: LD_VAR 0 2
78627: ARRAY
78628: PUSH
78629: LD_INT 1
78631: ARRAY
78632: PPUSH
78633: LD_EXP 98
78637: PUSH
78638: LD_VAR 0 2
78642: ARRAY
78643: PUSH
78644: LD_INT 1
78646: ARRAY
78647: PUSH
78648: LD_INT 1
78650: ARRAY
78651: PPUSH
78652: LD_EXP 98
78656: PUSH
78657: LD_VAR 0 2
78661: ARRAY
78662: PUSH
78663: LD_INT 1
78665: ARRAY
78666: PUSH
78667: LD_INT 2
78669: ARRAY
78670: PPUSH
78671: CALL_OW 297
78675: PUSH
78676: LD_INT 6
78678: GREATER
78679: AND
78680: IFFALSE 78739
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78682: LD_EXP 99
78686: PUSH
78687: LD_VAR 0 2
78691: ARRAY
78692: PUSH
78693: LD_INT 1
78695: ARRAY
78696: PPUSH
78697: LD_EXP 98
78701: PUSH
78702: LD_VAR 0 2
78706: ARRAY
78707: PUSH
78708: LD_INT 1
78710: ARRAY
78711: PUSH
78712: LD_INT 1
78714: ARRAY
78715: PPUSH
78716: LD_EXP 98
78720: PUSH
78721: LD_VAR 0 2
78725: ARRAY
78726: PUSH
78727: LD_INT 1
78729: ARRAY
78730: PUSH
78731: LD_INT 2
78733: ARRAY
78734: PPUSH
78735: CALL_OW 111
// end ; end ; end ;
78739: GO 78152
78741: POP
78742: POP
// end ;
78743: LD_VAR 0 1
78747: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78748: LD_INT 0
78750: PPUSH
78751: PPUSH
78752: PPUSH
78753: PPUSH
78754: PPUSH
78755: PPUSH
78756: PPUSH
78757: PPUSH
78758: PPUSH
78759: PPUSH
78760: PPUSH
// if not mc_bases then
78761: LD_EXP 61
78765: NOT
78766: IFFALSE 78770
// exit ;
78768: GO 79710
// for i = 1 to mc_bases do
78770: LD_ADDR_VAR 0 2
78774: PUSH
78775: DOUBLE
78776: LD_INT 1
78778: DEC
78779: ST_TO_ADDR
78780: LD_EXP 61
78784: PUSH
78785: FOR_TO
78786: IFFALSE 79708
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78788: LD_EXP 61
78792: PUSH
78793: LD_VAR 0 2
78797: ARRAY
78798: NOT
78799: PUSH
78800: LD_EXP 84
78804: PUSH
78805: LD_VAR 0 2
78809: ARRAY
78810: OR
78811: IFFALSE 78815
// continue ;
78813: GO 78785
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78815: LD_ADDR_VAR 0 7
78819: PUSH
78820: LD_EXP 61
78824: PUSH
78825: LD_VAR 0 2
78829: ARRAY
78830: PUSH
78831: LD_INT 1
78833: ARRAY
78834: PPUSH
78835: CALL_OW 248
78839: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78840: LD_VAR 0 7
78844: PUSH
78845: LD_INT 3
78847: EQUAL
78848: PUSH
78849: LD_EXP 80
78853: PUSH
78854: LD_VAR 0 2
78858: ARRAY
78859: PUSH
78860: LD_EXP 83
78864: PUSH
78865: LD_VAR 0 2
78869: ARRAY
78870: UNION
78871: PPUSH
78872: LD_INT 33
78874: PUSH
78875: LD_INT 2
78877: PUSH
78878: EMPTY
78879: LIST
78880: LIST
78881: PPUSH
78882: CALL_OW 72
78886: NOT
78887: OR
78888: IFFALSE 78892
// continue ;
78890: GO 78785
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78892: LD_ADDR_VAR 0 9
78896: PUSH
78897: LD_EXP 61
78901: PUSH
78902: LD_VAR 0 2
78906: ARRAY
78907: PPUSH
78908: LD_INT 30
78910: PUSH
78911: LD_INT 36
78913: PUSH
78914: EMPTY
78915: LIST
78916: LIST
78917: PPUSH
78918: CALL_OW 72
78922: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78923: LD_ADDR_VAR 0 10
78927: PUSH
78928: LD_EXP 80
78932: PUSH
78933: LD_VAR 0 2
78937: ARRAY
78938: PPUSH
78939: LD_INT 34
78941: PUSH
78942: LD_INT 31
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PPUSH
78949: CALL_OW 72
78953: ST_TO_ADDR
// if not cts and not mcts then
78954: LD_VAR 0 9
78958: NOT
78959: PUSH
78960: LD_VAR 0 10
78964: NOT
78965: AND
78966: IFFALSE 78970
// continue ;
78968: GO 78785
// x := cts ;
78970: LD_ADDR_VAR 0 11
78974: PUSH
78975: LD_VAR 0 9
78979: ST_TO_ADDR
// if not x then
78980: LD_VAR 0 11
78984: NOT
78985: IFFALSE 78997
// x := mcts ;
78987: LD_ADDR_VAR 0 11
78991: PUSH
78992: LD_VAR 0 10
78996: ST_TO_ADDR
// if not x then
78997: LD_VAR 0 11
79001: NOT
79002: IFFALSE 79006
// continue ;
79004: GO 78785
// if mc_remote_driver [ i ] then
79006: LD_EXP 101
79010: PUSH
79011: LD_VAR 0 2
79015: ARRAY
79016: IFFALSE 79403
// for j in mc_remote_driver [ i ] do
79018: LD_ADDR_VAR 0 3
79022: PUSH
79023: LD_EXP 101
79027: PUSH
79028: LD_VAR 0 2
79032: ARRAY
79033: PUSH
79034: FOR_IN
79035: IFFALSE 79401
// begin if GetClass ( j ) <> 3 then
79037: LD_VAR 0 3
79041: PPUSH
79042: CALL_OW 257
79046: PUSH
79047: LD_INT 3
79049: NONEQUAL
79050: IFFALSE 79103
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
79052: LD_ADDR_EXP 101
79056: PUSH
79057: LD_EXP 101
79061: PPUSH
79062: LD_VAR 0 2
79066: PPUSH
79067: LD_EXP 101
79071: PUSH
79072: LD_VAR 0 2
79076: ARRAY
79077: PUSH
79078: LD_VAR 0 3
79082: DIFF
79083: PPUSH
79084: CALL_OW 1
79088: ST_TO_ADDR
// SetTag ( j , 0 ) ;
79089: LD_VAR 0 3
79093: PPUSH
79094: LD_INT 0
79096: PPUSH
79097: CALL_OW 109
// continue ;
79101: GO 79034
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
79103: LD_EXP 80
79107: PUSH
79108: LD_VAR 0 2
79112: ARRAY
79113: PPUSH
79114: LD_INT 34
79116: PUSH
79117: LD_INT 31
79119: PUSH
79120: EMPTY
79121: LIST
79122: LIST
79123: PUSH
79124: LD_INT 58
79126: PUSH
79127: EMPTY
79128: LIST
79129: PUSH
79130: EMPTY
79131: LIST
79132: LIST
79133: PPUSH
79134: CALL_OW 72
79138: PUSH
79139: LD_VAR 0 3
79143: PPUSH
79144: CALL 50419 0 1
79148: NOT
79149: AND
79150: IFFALSE 79221
// begin if IsInUnit ( j ) then
79152: LD_VAR 0 3
79156: PPUSH
79157: CALL_OW 310
79161: IFFALSE 79172
// ComExitBuilding ( j ) ;
79163: LD_VAR 0 3
79167: PPUSH
79168: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
79172: LD_VAR 0 3
79176: PPUSH
79177: LD_EXP 80
79181: PUSH
79182: LD_VAR 0 2
79186: ARRAY
79187: PPUSH
79188: LD_INT 34
79190: PUSH
79191: LD_INT 31
79193: PUSH
79194: EMPTY
79195: LIST
79196: LIST
79197: PUSH
79198: LD_INT 58
79200: PUSH
79201: EMPTY
79202: LIST
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PPUSH
79208: CALL_OW 72
79212: PUSH
79213: LD_INT 1
79215: ARRAY
79216: PPUSH
79217: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
79221: LD_VAR 0 3
79225: PPUSH
79226: CALL_OW 310
79230: NOT
79231: PUSH
79232: LD_VAR 0 3
79236: PPUSH
79237: CALL_OW 310
79241: PPUSH
79242: CALL_OW 266
79246: PUSH
79247: LD_INT 36
79249: NONEQUAL
79250: PUSH
79251: LD_VAR 0 3
79255: PPUSH
79256: CALL 50419 0 1
79260: NOT
79261: AND
79262: OR
79263: IFFALSE 79399
// begin if IsInUnit ( j ) then
79265: LD_VAR 0 3
79269: PPUSH
79270: CALL_OW 310
79274: IFFALSE 79285
// ComExitBuilding ( j ) ;
79276: LD_VAR 0 3
79280: PPUSH
79281: CALL_OW 122
// ct := 0 ;
79285: LD_ADDR_VAR 0 8
79289: PUSH
79290: LD_INT 0
79292: ST_TO_ADDR
// for k in x do
79293: LD_ADDR_VAR 0 4
79297: PUSH
79298: LD_VAR 0 11
79302: PUSH
79303: FOR_IN
79304: IFFALSE 79377
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
79306: LD_VAR 0 4
79310: PPUSH
79311: CALL_OW 264
79315: PUSH
79316: LD_INT 31
79318: EQUAL
79319: PUSH
79320: LD_VAR 0 4
79324: PPUSH
79325: CALL_OW 311
79329: NOT
79330: AND
79331: PUSH
79332: LD_VAR 0 4
79336: PPUSH
79337: CALL_OW 266
79341: PUSH
79342: LD_INT 36
79344: EQUAL
79345: PUSH
79346: LD_VAR 0 4
79350: PPUSH
79351: CALL_OW 313
79355: PUSH
79356: LD_INT 3
79358: LESS
79359: AND
79360: OR
79361: IFFALSE 79375
// begin ct := k ;
79363: LD_ADDR_VAR 0 8
79367: PUSH
79368: LD_VAR 0 4
79372: ST_TO_ADDR
// break ;
79373: GO 79377
// end ;
79375: GO 79303
79377: POP
79378: POP
// if ct then
79379: LD_VAR 0 8
79383: IFFALSE 79399
// ComEnterUnit ( j , ct ) ;
79385: LD_VAR 0 3
79389: PPUSH
79390: LD_VAR 0 8
79394: PPUSH
79395: CALL_OW 120
// end ; end ;
79399: GO 79034
79401: POP
79402: POP
// places := 0 ;
79403: LD_ADDR_VAR 0 5
79407: PUSH
79408: LD_INT 0
79410: ST_TO_ADDR
// for j = 1 to x do
79411: LD_ADDR_VAR 0 3
79415: PUSH
79416: DOUBLE
79417: LD_INT 1
79419: DEC
79420: ST_TO_ADDR
79421: LD_VAR 0 11
79425: PUSH
79426: FOR_TO
79427: IFFALSE 79503
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79429: LD_VAR 0 11
79433: PUSH
79434: LD_VAR 0 3
79438: ARRAY
79439: PPUSH
79440: CALL_OW 264
79444: PUSH
79445: LD_INT 31
79447: EQUAL
79448: IFFALSE 79466
// places := places + 1 else
79450: LD_ADDR_VAR 0 5
79454: PUSH
79455: LD_VAR 0 5
79459: PUSH
79460: LD_INT 1
79462: PLUS
79463: ST_TO_ADDR
79464: GO 79501
// if GetBType ( x [ j ] ) = b_control_tower then
79466: LD_VAR 0 11
79470: PUSH
79471: LD_VAR 0 3
79475: ARRAY
79476: PPUSH
79477: CALL_OW 266
79481: PUSH
79482: LD_INT 36
79484: EQUAL
79485: IFFALSE 79501
// places := places + 3 ;
79487: LD_ADDR_VAR 0 5
79491: PUSH
79492: LD_VAR 0 5
79496: PUSH
79497: LD_INT 3
79499: PLUS
79500: ST_TO_ADDR
79501: GO 79426
79503: POP
79504: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79505: LD_VAR 0 5
79509: PUSH
79510: LD_INT 0
79512: EQUAL
79513: PUSH
79514: LD_VAR 0 5
79518: PUSH
79519: LD_EXP 101
79523: PUSH
79524: LD_VAR 0 2
79528: ARRAY
79529: LESSEQUAL
79530: OR
79531: IFFALSE 79535
// continue ;
79533: GO 78785
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79535: LD_ADDR_VAR 0 6
79539: PUSH
79540: LD_EXP 61
79544: PUSH
79545: LD_VAR 0 2
79549: ARRAY
79550: PPUSH
79551: LD_INT 25
79553: PUSH
79554: LD_INT 3
79556: PUSH
79557: EMPTY
79558: LIST
79559: LIST
79560: PPUSH
79561: CALL_OW 72
79565: PUSH
79566: LD_EXP 101
79570: PUSH
79571: LD_VAR 0 2
79575: ARRAY
79576: DIFF
79577: PPUSH
79578: LD_INT 3
79580: PPUSH
79581: CALL 51319 0 2
79585: ST_TO_ADDR
// for j in tmp do
79586: LD_ADDR_VAR 0 3
79590: PUSH
79591: LD_VAR 0 6
79595: PUSH
79596: FOR_IN
79597: IFFALSE 79632
// if GetTag ( j ) > 0 then
79599: LD_VAR 0 3
79603: PPUSH
79604: CALL_OW 110
79608: PUSH
79609: LD_INT 0
79611: GREATER
79612: IFFALSE 79630
// tmp := tmp diff j ;
79614: LD_ADDR_VAR 0 6
79618: PUSH
79619: LD_VAR 0 6
79623: PUSH
79624: LD_VAR 0 3
79628: DIFF
79629: ST_TO_ADDR
79630: GO 79596
79632: POP
79633: POP
// if not tmp then
79634: LD_VAR 0 6
79638: NOT
79639: IFFALSE 79643
// continue ;
79641: GO 78785
// if places then
79643: LD_VAR 0 5
79647: IFFALSE 79706
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79649: LD_ADDR_EXP 101
79653: PUSH
79654: LD_EXP 101
79658: PPUSH
79659: LD_VAR 0 2
79663: PPUSH
79664: LD_EXP 101
79668: PUSH
79669: LD_VAR 0 2
79673: ARRAY
79674: PUSH
79675: LD_VAR 0 6
79679: PUSH
79680: LD_INT 1
79682: ARRAY
79683: UNION
79684: PPUSH
79685: CALL_OW 1
79689: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79690: LD_VAR 0 6
79694: PUSH
79695: LD_INT 1
79697: ARRAY
79698: PPUSH
79699: LD_INT 126
79701: PPUSH
79702: CALL_OW 109
// end ; end ;
79706: GO 78785
79708: POP
79709: POP
// end ;
79710: LD_VAR 0 1
79714: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79715: LD_INT 0
79717: PPUSH
79718: PPUSH
79719: PPUSH
79720: PPUSH
79721: PPUSH
79722: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79723: LD_VAR 0 1
79727: NOT
79728: PUSH
79729: LD_VAR 0 2
79733: NOT
79734: OR
79735: PUSH
79736: LD_VAR 0 3
79740: NOT
79741: OR
79742: PUSH
79743: LD_VAR 0 4
79747: PUSH
79748: LD_INT 1
79750: PUSH
79751: LD_INT 2
79753: PUSH
79754: LD_INT 3
79756: PUSH
79757: LD_INT 4
79759: PUSH
79760: LD_INT 5
79762: PUSH
79763: LD_INT 8
79765: PUSH
79766: LD_INT 9
79768: PUSH
79769: LD_INT 15
79771: PUSH
79772: LD_INT 16
79774: PUSH
79775: EMPTY
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: IN
79786: NOT
79787: OR
79788: IFFALSE 79792
// exit ;
79790: GO 80650
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79792: LD_ADDR_VAR 0 2
79796: PUSH
79797: LD_VAR 0 2
79801: PPUSH
79802: LD_INT 21
79804: PUSH
79805: LD_INT 3
79807: PUSH
79808: EMPTY
79809: LIST
79810: LIST
79811: PUSH
79812: LD_INT 24
79814: PUSH
79815: LD_INT 250
79817: PUSH
79818: EMPTY
79819: LIST
79820: LIST
79821: PUSH
79822: EMPTY
79823: LIST
79824: LIST
79825: PPUSH
79826: CALL_OW 72
79830: ST_TO_ADDR
// case class of 1 , 15 :
79831: LD_VAR 0 4
79835: PUSH
79836: LD_INT 1
79838: DOUBLE
79839: EQUAL
79840: IFTRUE 79850
79842: LD_INT 15
79844: DOUBLE
79845: EQUAL
79846: IFTRUE 79850
79848: GO 79935
79850: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79851: LD_ADDR_VAR 0 8
79855: PUSH
79856: LD_VAR 0 2
79860: PPUSH
79861: LD_INT 2
79863: PUSH
79864: LD_INT 30
79866: PUSH
79867: LD_INT 32
79869: PUSH
79870: EMPTY
79871: LIST
79872: LIST
79873: PUSH
79874: LD_INT 30
79876: PUSH
79877: LD_INT 31
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: PUSH
79884: EMPTY
79885: LIST
79886: LIST
79887: LIST
79888: PPUSH
79889: CALL_OW 72
79893: PUSH
79894: LD_VAR 0 2
79898: PPUSH
79899: LD_INT 2
79901: PUSH
79902: LD_INT 30
79904: PUSH
79905: LD_INT 4
79907: PUSH
79908: EMPTY
79909: LIST
79910: LIST
79911: PUSH
79912: LD_INT 30
79914: PUSH
79915: LD_INT 5
79917: PUSH
79918: EMPTY
79919: LIST
79920: LIST
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: LIST
79926: PPUSH
79927: CALL_OW 72
79931: ADD
79932: ST_TO_ADDR
79933: GO 80181
79935: LD_INT 2
79937: DOUBLE
79938: EQUAL
79939: IFTRUE 79949
79941: LD_INT 16
79943: DOUBLE
79944: EQUAL
79945: IFTRUE 79949
79947: GO 79995
79949: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79950: LD_ADDR_VAR 0 8
79954: PUSH
79955: LD_VAR 0 2
79959: PPUSH
79960: LD_INT 2
79962: PUSH
79963: LD_INT 30
79965: PUSH
79966: LD_INT 0
79968: PUSH
79969: EMPTY
79970: LIST
79971: LIST
79972: PUSH
79973: LD_INT 30
79975: PUSH
79976: LD_INT 1
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: EMPTY
79984: LIST
79985: LIST
79986: LIST
79987: PPUSH
79988: CALL_OW 72
79992: ST_TO_ADDR
79993: GO 80181
79995: LD_INT 3
79997: DOUBLE
79998: EQUAL
79999: IFTRUE 80003
80001: GO 80049
80003: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
80004: LD_ADDR_VAR 0 8
80008: PUSH
80009: LD_VAR 0 2
80013: PPUSH
80014: LD_INT 2
80016: PUSH
80017: LD_INT 30
80019: PUSH
80020: LD_INT 2
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: PUSH
80027: LD_INT 30
80029: PUSH
80030: LD_INT 3
80032: PUSH
80033: EMPTY
80034: LIST
80035: LIST
80036: PUSH
80037: EMPTY
80038: LIST
80039: LIST
80040: LIST
80041: PPUSH
80042: CALL_OW 72
80046: ST_TO_ADDR
80047: GO 80181
80049: LD_INT 4
80051: DOUBLE
80052: EQUAL
80053: IFTRUE 80057
80055: GO 80114
80057: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
80058: LD_ADDR_VAR 0 8
80062: PUSH
80063: LD_VAR 0 2
80067: PPUSH
80068: LD_INT 2
80070: PUSH
80071: LD_INT 30
80073: PUSH
80074: LD_INT 6
80076: PUSH
80077: EMPTY
80078: LIST
80079: LIST
80080: PUSH
80081: LD_INT 30
80083: PUSH
80084: LD_INT 7
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: PUSH
80091: LD_INT 30
80093: PUSH
80094: LD_INT 8
80096: PUSH
80097: EMPTY
80098: LIST
80099: LIST
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: LIST
80105: LIST
80106: PPUSH
80107: CALL_OW 72
80111: ST_TO_ADDR
80112: GO 80181
80114: LD_INT 5
80116: DOUBLE
80117: EQUAL
80118: IFTRUE 80134
80120: LD_INT 8
80122: DOUBLE
80123: EQUAL
80124: IFTRUE 80134
80126: LD_INT 9
80128: DOUBLE
80129: EQUAL
80130: IFTRUE 80134
80132: GO 80180
80134: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
80135: LD_ADDR_VAR 0 8
80139: PUSH
80140: LD_VAR 0 2
80144: PPUSH
80145: LD_INT 2
80147: PUSH
80148: LD_INT 30
80150: PUSH
80151: LD_INT 4
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 30
80160: PUSH
80161: LD_INT 5
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: EMPTY
80169: LIST
80170: LIST
80171: LIST
80172: PPUSH
80173: CALL_OW 72
80177: ST_TO_ADDR
80178: GO 80181
80180: POP
// if not tmp then
80181: LD_VAR 0 8
80185: NOT
80186: IFFALSE 80190
// exit ;
80188: GO 80650
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
80190: LD_VAR 0 4
80194: PUSH
80195: LD_INT 1
80197: PUSH
80198: LD_INT 15
80200: PUSH
80201: EMPTY
80202: LIST
80203: LIST
80204: IN
80205: PUSH
80206: LD_EXP 70
80210: PUSH
80211: LD_VAR 0 1
80215: ARRAY
80216: AND
80217: IFFALSE 80373
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
80219: LD_ADDR_VAR 0 9
80223: PUSH
80224: LD_EXP 70
80228: PUSH
80229: LD_VAR 0 1
80233: ARRAY
80234: PUSH
80235: LD_INT 1
80237: ARRAY
80238: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
80239: LD_VAR 0 9
80243: PUSH
80244: LD_EXP 71
80248: PUSH
80249: LD_VAR 0 1
80253: ARRAY
80254: IN
80255: NOT
80256: IFFALSE 80371
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
80258: LD_ADDR_EXP 71
80262: PUSH
80263: LD_EXP 71
80267: PPUSH
80268: LD_VAR 0 1
80272: PUSH
80273: LD_EXP 71
80277: PUSH
80278: LD_VAR 0 1
80282: ARRAY
80283: PUSH
80284: LD_INT 1
80286: PLUS
80287: PUSH
80288: EMPTY
80289: LIST
80290: LIST
80291: PPUSH
80292: LD_VAR 0 9
80296: PPUSH
80297: CALL 20463 0 3
80301: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
80302: LD_ADDR_EXP 70
80306: PUSH
80307: LD_EXP 70
80311: PPUSH
80312: LD_VAR 0 1
80316: PPUSH
80317: LD_EXP 70
80321: PUSH
80322: LD_VAR 0 1
80326: ARRAY
80327: PUSH
80328: LD_VAR 0 9
80332: DIFF
80333: PPUSH
80334: CALL_OW 1
80338: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80339: LD_VAR 0 3
80343: PPUSH
80344: LD_EXP 71
80348: PUSH
80349: LD_VAR 0 1
80353: ARRAY
80354: PUSH
80355: LD_EXP 71
80359: PUSH
80360: LD_VAR 0 1
80364: ARRAY
80365: ARRAY
80366: PPUSH
80367: CALL_OW 120
// end ; exit ;
80371: GO 80650
// end ; if tmp > 1 then
80373: LD_VAR 0 8
80377: PUSH
80378: LD_INT 1
80380: GREATER
80381: IFFALSE 80485
// for i = 2 to tmp do
80383: LD_ADDR_VAR 0 6
80387: PUSH
80388: DOUBLE
80389: LD_INT 2
80391: DEC
80392: ST_TO_ADDR
80393: LD_VAR 0 8
80397: PUSH
80398: FOR_TO
80399: IFFALSE 80483
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80401: LD_VAR 0 8
80405: PUSH
80406: LD_VAR 0 6
80410: ARRAY
80411: PPUSH
80412: CALL_OW 461
80416: PUSH
80417: LD_INT 6
80419: EQUAL
80420: IFFALSE 80481
// begin x := tmp [ i ] ;
80422: LD_ADDR_VAR 0 9
80426: PUSH
80427: LD_VAR 0 8
80431: PUSH
80432: LD_VAR 0 6
80436: ARRAY
80437: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80438: LD_ADDR_VAR 0 8
80442: PUSH
80443: LD_VAR 0 8
80447: PPUSH
80448: LD_VAR 0 6
80452: PPUSH
80453: CALL_OW 3
80457: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80458: LD_ADDR_VAR 0 8
80462: PUSH
80463: LD_VAR 0 8
80467: PPUSH
80468: LD_INT 1
80470: PPUSH
80471: LD_VAR 0 9
80475: PPUSH
80476: CALL_OW 2
80480: ST_TO_ADDR
// end ;
80481: GO 80398
80483: POP
80484: POP
// for i in tmp do
80485: LD_ADDR_VAR 0 6
80489: PUSH
80490: LD_VAR 0 8
80494: PUSH
80495: FOR_IN
80496: IFFALSE 80523
// begin if IsNotFull ( i ) then
80498: LD_VAR 0 6
80502: PPUSH
80503: CALL 17685 0 1
80507: IFFALSE 80521
// begin j := i ;
80509: LD_ADDR_VAR 0 7
80513: PUSH
80514: LD_VAR 0 6
80518: ST_TO_ADDR
// break ;
80519: GO 80523
// end ; end ;
80521: GO 80495
80523: POP
80524: POP
// if j then
80525: LD_VAR 0 7
80529: IFFALSE 80547
// ComEnterUnit ( unit , j ) else
80531: LD_VAR 0 3
80535: PPUSH
80536: LD_VAR 0 7
80540: PPUSH
80541: CALL_OW 120
80545: GO 80650
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80547: LD_ADDR_VAR 0 10
80551: PUSH
80552: LD_VAR 0 2
80556: PPUSH
80557: LD_INT 2
80559: PUSH
80560: LD_INT 30
80562: PUSH
80563: LD_INT 0
80565: PUSH
80566: EMPTY
80567: LIST
80568: LIST
80569: PUSH
80570: LD_INT 30
80572: PUSH
80573: LD_INT 1
80575: PUSH
80576: EMPTY
80577: LIST
80578: LIST
80579: PUSH
80580: EMPTY
80581: LIST
80582: LIST
80583: LIST
80584: PPUSH
80585: CALL_OW 72
80589: ST_TO_ADDR
// if depot then
80590: LD_VAR 0 10
80594: IFFALSE 80650
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80596: LD_ADDR_VAR 0 10
80600: PUSH
80601: LD_VAR 0 10
80605: PPUSH
80606: LD_VAR 0 3
80610: PPUSH
80611: CALL_OW 74
80615: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80616: LD_VAR 0 3
80620: PPUSH
80621: LD_VAR 0 10
80625: PPUSH
80626: CALL_OW 296
80630: PUSH
80631: LD_INT 10
80633: GREATER
80634: IFFALSE 80650
// ComStandNearbyBuilding ( unit , depot ) ;
80636: LD_VAR 0 3
80640: PPUSH
80641: LD_VAR 0 10
80645: PPUSH
80646: CALL 17065 0 2
// end ; end ; end ;
80650: LD_VAR 0 5
80654: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80655: LD_INT 0
80657: PPUSH
80658: PPUSH
80659: PPUSH
80660: PPUSH
// if not mc_bases then
80661: LD_EXP 61
80665: NOT
80666: IFFALSE 80670
// exit ;
80668: GO 80909
// for i = 1 to mc_bases do
80670: LD_ADDR_VAR 0 2
80674: PUSH
80675: DOUBLE
80676: LD_INT 1
80678: DEC
80679: ST_TO_ADDR
80680: LD_EXP 61
80684: PUSH
80685: FOR_TO
80686: IFFALSE 80907
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80688: LD_ADDR_VAR 0 4
80692: PUSH
80693: LD_EXP 61
80697: PUSH
80698: LD_VAR 0 2
80702: ARRAY
80703: PPUSH
80704: LD_INT 21
80706: PUSH
80707: LD_INT 1
80709: PUSH
80710: EMPTY
80711: LIST
80712: LIST
80713: PPUSH
80714: CALL_OW 72
80718: PUSH
80719: LD_EXP 90
80723: PUSH
80724: LD_VAR 0 2
80728: ARRAY
80729: UNION
80730: ST_TO_ADDR
// if not tmp then
80731: LD_VAR 0 4
80735: NOT
80736: IFFALSE 80740
// continue ;
80738: GO 80685
// for j in tmp do
80740: LD_ADDR_VAR 0 3
80744: PUSH
80745: LD_VAR 0 4
80749: PUSH
80750: FOR_IN
80751: IFFALSE 80903
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80753: LD_VAR 0 3
80757: PPUSH
80758: CALL_OW 110
80762: NOT
80763: PUSH
80764: LD_VAR 0 3
80768: PPUSH
80769: CALL_OW 314
80773: NOT
80774: AND
80775: PUSH
80776: LD_VAR 0 3
80780: PPUSH
80781: CALL_OW 311
80785: NOT
80786: AND
80787: PUSH
80788: LD_VAR 0 3
80792: PPUSH
80793: CALL_OW 310
80797: NOT
80798: AND
80799: PUSH
80800: LD_VAR 0 3
80804: PUSH
80805: LD_EXP 64
80809: PUSH
80810: LD_VAR 0 2
80814: ARRAY
80815: PUSH
80816: LD_INT 1
80818: ARRAY
80819: IN
80820: NOT
80821: AND
80822: PUSH
80823: LD_VAR 0 3
80827: PUSH
80828: LD_EXP 64
80832: PUSH
80833: LD_VAR 0 2
80837: ARRAY
80838: PUSH
80839: LD_INT 2
80841: ARRAY
80842: IN
80843: NOT
80844: AND
80845: PUSH
80846: LD_VAR 0 3
80850: PUSH
80851: LD_EXP 73
80855: PUSH
80856: LD_VAR 0 2
80860: ARRAY
80861: IN
80862: NOT
80863: AND
80864: IFFALSE 80901
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80866: LD_VAR 0 2
80870: PPUSH
80871: LD_EXP 61
80875: PUSH
80876: LD_VAR 0 2
80880: ARRAY
80881: PPUSH
80882: LD_VAR 0 3
80886: PPUSH
80887: LD_VAR 0 3
80891: PPUSH
80892: CALL_OW 257
80896: PPUSH
80897: CALL 79715 0 4
// end ;
80901: GO 80750
80903: POP
80904: POP
// end ;
80905: GO 80685
80907: POP
80908: POP
// end ;
80909: LD_VAR 0 1
80913: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
80914: LD_INT 0
80916: PPUSH
80917: PPUSH
80918: PPUSH
80919: PPUSH
80920: PPUSH
80921: PPUSH
// if not mc_bases [ base ] then
80922: LD_EXP 61
80926: PUSH
80927: LD_VAR 0 1
80931: ARRAY
80932: NOT
80933: IFFALSE 80937
// exit ;
80935: GO 81138
// tmp := [ ] ;
80937: LD_ADDR_VAR 0 6
80941: PUSH
80942: EMPTY
80943: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80944: LD_ADDR_VAR 0 7
80948: PUSH
80949: LD_VAR 0 3
80953: PPUSH
80954: LD_INT 0
80956: PPUSH
80957: CALL_OW 517
80961: ST_TO_ADDR
// if not list then
80962: LD_VAR 0 7
80966: NOT
80967: IFFALSE 80971
// exit ;
80969: GO 81138
// c := Count ( list [ 1 ] ) ;
80971: LD_ADDR_VAR 0 9
80975: PUSH
80976: LD_VAR 0 7
80980: PUSH
80981: LD_INT 1
80983: ARRAY
80984: PPUSH
80985: CALL 17603 0 1
80989: ST_TO_ADDR
// if amount > c then
80990: LD_VAR 0 2
80994: PUSH
80995: LD_VAR 0 9
80999: GREATER
81000: IFFALSE 81012
// amount := c ;
81002: LD_ADDR_VAR 0 2
81006: PUSH
81007: LD_VAR 0 9
81011: ST_TO_ADDR
// for i := 1 to amount do
81012: LD_ADDR_VAR 0 5
81016: PUSH
81017: DOUBLE
81018: LD_INT 1
81020: DEC
81021: ST_TO_ADDR
81022: LD_VAR 0 2
81026: PUSH
81027: FOR_TO
81028: IFFALSE 81086
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
81030: LD_ADDR_VAR 0 6
81034: PUSH
81035: LD_VAR 0 6
81039: PPUSH
81040: LD_VAR 0 5
81044: PPUSH
81045: LD_VAR 0 7
81049: PUSH
81050: LD_INT 1
81052: ARRAY
81053: PUSH
81054: LD_VAR 0 5
81058: ARRAY
81059: PUSH
81060: LD_VAR 0 7
81064: PUSH
81065: LD_INT 2
81067: ARRAY
81068: PUSH
81069: LD_VAR 0 5
81073: ARRAY
81074: PUSH
81075: EMPTY
81076: LIST
81077: LIST
81078: PPUSH
81079: CALL_OW 1
81083: ST_TO_ADDR
81084: GO 81027
81086: POP
81087: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
81088: LD_ADDR_EXP 74
81092: PUSH
81093: LD_EXP 74
81097: PPUSH
81098: LD_VAR 0 1
81102: PPUSH
81103: LD_VAR 0 6
81107: PPUSH
81108: CALL_OW 1
81112: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
81113: LD_ADDR_EXP 76
81117: PUSH
81118: LD_EXP 76
81122: PPUSH
81123: LD_VAR 0 1
81127: PPUSH
81128: LD_VAR 0 3
81132: PPUSH
81133: CALL_OW 1
81137: ST_TO_ADDR
// end ;
81138: LD_VAR 0 4
81142: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
81143: LD_INT 0
81145: PPUSH
// if not mc_bases [ base ] then
81146: LD_EXP 61
81150: PUSH
81151: LD_VAR 0 1
81155: ARRAY
81156: NOT
81157: IFFALSE 81161
// exit ;
81159: GO 81186
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
81161: LD_ADDR_EXP 66
81165: PUSH
81166: LD_EXP 66
81170: PPUSH
81171: LD_VAR 0 1
81175: PPUSH
81176: LD_VAR 0 2
81180: PPUSH
81181: CALL_OW 1
81185: ST_TO_ADDR
// end ;
81186: LD_VAR 0 3
81190: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
81191: LD_INT 0
81193: PPUSH
// if not mc_bases [ base ] then
81194: LD_EXP 61
81198: PUSH
81199: LD_VAR 0 1
81203: ARRAY
81204: NOT
81205: IFFALSE 81209
// exit ;
81207: GO 81246
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
81209: LD_ADDR_EXP 66
81213: PUSH
81214: LD_EXP 66
81218: PPUSH
81219: LD_VAR 0 1
81223: PPUSH
81224: LD_EXP 66
81228: PUSH
81229: LD_VAR 0 1
81233: ARRAY
81234: PUSH
81235: LD_VAR 0 2
81239: UNION
81240: PPUSH
81241: CALL_OW 1
81245: ST_TO_ADDR
// end ;
81246: LD_VAR 0 3
81250: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
81251: LD_INT 0
81253: PPUSH
// if not mc_bases [ base ] then
81254: LD_EXP 61
81258: PUSH
81259: LD_VAR 0 1
81263: ARRAY
81264: NOT
81265: IFFALSE 81269
// exit ;
81267: GO 81294
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
81269: LD_ADDR_EXP 82
81273: PUSH
81274: LD_EXP 82
81278: PPUSH
81279: LD_VAR 0 1
81283: PPUSH
81284: LD_VAR 0 2
81288: PPUSH
81289: CALL_OW 1
81293: ST_TO_ADDR
// end ;
81294: LD_VAR 0 3
81298: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81299: LD_INT 0
81301: PPUSH
// if not mc_bases [ base ] then
81302: LD_EXP 61
81306: PUSH
81307: LD_VAR 0 1
81311: ARRAY
81312: NOT
81313: IFFALSE 81317
// exit ;
81315: GO 81354
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81317: LD_ADDR_EXP 82
81321: PUSH
81322: LD_EXP 82
81326: PPUSH
81327: LD_VAR 0 1
81331: PPUSH
81332: LD_EXP 82
81336: PUSH
81337: LD_VAR 0 1
81341: ARRAY
81342: PUSH
81343: LD_VAR 0 2
81347: ADD
81348: PPUSH
81349: CALL_OW 1
81353: ST_TO_ADDR
// end ;
81354: LD_VAR 0 3
81358: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81359: LD_INT 0
81361: PPUSH
// if not mc_bases [ base ] then
81362: LD_EXP 61
81366: PUSH
81367: LD_VAR 0 1
81371: ARRAY
81372: NOT
81373: IFFALSE 81377
// exit ;
81375: GO 81431
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81377: LD_ADDR_EXP 83
81381: PUSH
81382: LD_EXP 83
81386: PPUSH
81387: LD_VAR 0 1
81391: PPUSH
81392: LD_VAR 0 2
81396: PPUSH
81397: CALL_OW 1
81401: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81402: LD_ADDR_EXP 72
81406: PUSH
81407: LD_EXP 72
81411: PPUSH
81412: LD_VAR 0 1
81416: PPUSH
81417: LD_VAR 0 2
81421: PUSH
81422: LD_INT 0
81424: PLUS
81425: PPUSH
81426: CALL_OW 1
81430: ST_TO_ADDR
// end ;
81431: LD_VAR 0 3
81435: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81436: LD_INT 0
81438: PPUSH
// if not mc_bases [ base ] then
81439: LD_EXP 61
81443: PUSH
81444: LD_VAR 0 1
81448: ARRAY
81449: NOT
81450: IFFALSE 81454
// exit ;
81452: GO 81479
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81454: LD_ADDR_EXP 72
81458: PUSH
81459: LD_EXP 72
81463: PPUSH
81464: LD_VAR 0 1
81468: PPUSH
81469: LD_VAR 0 2
81473: PPUSH
81474: CALL_OW 1
81478: ST_TO_ADDR
// end ;
81479: LD_VAR 0 3
81483: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81484: LD_INT 0
81486: PPUSH
81487: PPUSH
81488: PPUSH
81489: PPUSH
// if not mc_bases [ base ] then
81490: LD_EXP 61
81494: PUSH
81495: LD_VAR 0 1
81499: ARRAY
81500: NOT
81501: IFFALSE 81505
// exit ;
81503: GO 81570
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81505: LD_ADDR_EXP 81
81509: PUSH
81510: LD_EXP 81
81514: PPUSH
81515: LD_VAR 0 1
81519: PUSH
81520: LD_EXP 81
81524: PUSH
81525: LD_VAR 0 1
81529: ARRAY
81530: PUSH
81531: LD_INT 1
81533: PLUS
81534: PUSH
81535: EMPTY
81536: LIST
81537: LIST
81538: PPUSH
81539: LD_VAR 0 1
81543: PUSH
81544: LD_VAR 0 2
81548: PUSH
81549: LD_VAR 0 3
81553: PUSH
81554: LD_VAR 0 4
81558: PUSH
81559: EMPTY
81560: LIST
81561: LIST
81562: LIST
81563: LIST
81564: PPUSH
81565: CALL 20463 0 3
81569: ST_TO_ADDR
// end ;
81570: LD_VAR 0 5
81574: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81575: LD_INT 0
81577: PPUSH
// if not mc_bases [ base ] then
81578: LD_EXP 61
81582: PUSH
81583: LD_VAR 0 1
81587: ARRAY
81588: NOT
81589: IFFALSE 81593
// exit ;
81591: GO 81618
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81593: LD_ADDR_EXP 98
81597: PUSH
81598: LD_EXP 98
81602: PPUSH
81603: LD_VAR 0 1
81607: PPUSH
81608: LD_VAR 0 2
81612: PPUSH
81613: CALL_OW 1
81617: ST_TO_ADDR
// end ;
81618: LD_VAR 0 3
81622: RET
// export function MC_GetMinesField ( base ) ; begin
81623: LD_INT 0
81625: PPUSH
// result := mc_mines [ base ] ;
81626: LD_ADDR_VAR 0 2
81630: PUSH
81631: LD_EXP 74
81635: PUSH
81636: LD_VAR 0 1
81640: ARRAY
81641: ST_TO_ADDR
// end ;
81642: LD_VAR 0 2
81646: RET
// export function MC_GetProduceList ( base ) ; begin
81647: LD_INT 0
81649: PPUSH
// result := mc_produce [ base ] ;
81650: LD_ADDR_VAR 0 2
81654: PUSH
81655: LD_EXP 82
81659: PUSH
81660: LD_VAR 0 1
81664: ARRAY
81665: ST_TO_ADDR
// end ;
81666: LD_VAR 0 2
81670: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81671: LD_INT 0
81673: PPUSH
81674: PPUSH
// if not mc_bases then
81675: LD_EXP 61
81679: NOT
81680: IFFALSE 81684
// exit ;
81682: GO 81749
// if mc_bases [ base ] then
81684: LD_EXP 61
81688: PUSH
81689: LD_VAR 0 1
81693: ARRAY
81694: IFFALSE 81749
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81696: LD_ADDR_VAR 0 3
81700: PUSH
81701: LD_EXP 61
81705: PUSH
81706: LD_VAR 0 1
81710: ARRAY
81711: PPUSH
81712: LD_INT 30
81714: PUSH
81715: LD_VAR 0 2
81719: PUSH
81720: EMPTY
81721: LIST
81722: LIST
81723: PPUSH
81724: CALL_OW 72
81728: ST_TO_ADDR
// if result then
81729: LD_VAR 0 3
81733: IFFALSE 81749
// result := result [ 1 ] ;
81735: LD_ADDR_VAR 0 3
81739: PUSH
81740: LD_VAR 0 3
81744: PUSH
81745: LD_INT 1
81747: ARRAY
81748: ST_TO_ADDR
// end ; end ;
81749: LD_VAR 0 3
81753: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81754: LD_INT 0
81756: PPUSH
81757: PPUSH
// if not mc_bases then
81758: LD_EXP 61
81762: NOT
81763: IFFALSE 81767
// exit ;
81765: GO 81812
// if mc_bases [ base ] then
81767: LD_EXP 61
81771: PUSH
81772: LD_VAR 0 1
81776: ARRAY
81777: IFFALSE 81812
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81779: LD_ADDR_VAR 0 3
81783: PUSH
81784: LD_EXP 61
81788: PUSH
81789: LD_VAR 0 1
81793: ARRAY
81794: PPUSH
81795: LD_INT 30
81797: PUSH
81798: LD_VAR 0 2
81802: PUSH
81803: EMPTY
81804: LIST
81805: LIST
81806: PPUSH
81807: CALL_OW 72
81811: ST_TO_ADDR
// end ;
81812: LD_VAR 0 3
81816: RET
// export function MC_SetTame ( base , area ) ; begin
81817: LD_INT 0
81819: PPUSH
// if not mc_bases or not base then
81820: LD_EXP 61
81824: NOT
81825: PUSH
81826: LD_VAR 0 1
81830: NOT
81831: OR
81832: IFFALSE 81836
// exit ;
81834: GO 81861
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81836: LD_ADDR_EXP 89
81840: PUSH
81841: LD_EXP 89
81845: PPUSH
81846: LD_VAR 0 1
81850: PPUSH
81851: LD_VAR 0 2
81855: PPUSH
81856: CALL_OW 1
81860: ST_TO_ADDR
// end ;
81861: LD_VAR 0 3
81865: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81866: LD_INT 0
81868: PPUSH
81869: PPUSH
// if not mc_bases or not base then
81870: LD_EXP 61
81874: NOT
81875: PUSH
81876: LD_VAR 0 1
81880: NOT
81881: OR
81882: IFFALSE 81886
// exit ;
81884: GO 81988
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81886: LD_ADDR_VAR 0 4
81890: PUSH
81891: LD_EXP 61
81895: PUSH
81896: LD_VAR 0 1
81900: ARRAY
81901: PPUSH
81902: LD_INT 30
81904: PUSH
81905: LD_VAR 0 2
81909: PUSH
81910: EMPTY
81911: LIST
81912: LIST
81913: PPUSH
81914: CALL_OW 72
81918: ST_TO_ADDR
// if not tmp then
81919: LD_VAR 0 4
81923: NOT
81924: IFFALSE 81928
// exit ;
81926: GO 81988
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81928: LD_ADDR_EXP 93
81932: PUSH
81933: LD_EXP 93
81937: PPUSH
81938: LD_VAR 0 1
81942: PPUSH
81943: LD_EXP 93
81947: PUSH
81948: LD_VAR 0 1
81952: ARRAY
81953: PPUSH
81954: LD_EXP 93
81958: PUSH
81959: LD_VAR 0 1
81963: ARRAY
81964: PUSH
81965: LD_INT 1
81967: PLUS
81968: PPUSH
81969: LD_VAR 0 4
81973: PUSH
81974: LD_INT 1
81976: ARRAY
81977: PPUSH
81978: CALL_OW 2
81982: PPUSH
81983: CALL_OW 1
81987: ST_TO_ADDR
// end ;
81988: LD_VAR 0 3
81992: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81993: LD_INT 0
81995: PPUSH
81996: PPUSH
// if not mc_bases or not base or not kinds then
81997: LD_EXP 61
82001: NOT
82002: PUSH
82003: LD_VAR 0 1
82007: NOT
82008: OR
82009: PUSH
82010: LD_VAR 0 2
82014: NOT
82015: OR
82016: IFFALSE 82020
// exit ;
82018: GO 82081
// for i in kinds do
82020: LD_ADDR_VAR 0 4
82024: PUSH
82025: LD_VAR 0 2
82029: PUSH
82030: FOR_IN
82031: IFFALSE 82079
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
82033: LD_ADDR_EXP 95
82037: PUSH
82038: LD_EXP 95
82042: PPUSH
82043: LD_VAR 0 1
82047: PUSH
82048: LD_EXP 95
82052: PUSH
82053: LD_VAR 0 1
82057: ARRAY
82058: PUSH
82059: LD_INT 1
82061: PLUS
82062: PUSH
82063: EMPTY
82064: LIST
82065: LIST
82066: PPUSH
82067: LD_VAR 0 4
82071: PPUSH
82072: CALL 20463 0 3
82076: ST_TO_ADDR
82077: GO 82030
82079: POP
82080: POP
// end ;
82081: LD_VAR 0 3
82085: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
82086: LD_INT 0
82088: PPUSH
// if not mc_bases or not base or not areas then
82089: LD_EXP 61
82093: NOT
82094: PUSH
82095: LD_VAR 0 1
82099: NOT
82100: OR
82101: PUSH
82102: LD_VAR 0 2
82106: NOT
82107: OR
82108: IFFALSE 82112
// exit ;
82110: GO 82137
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
82112: LD_ADDR_EXP 79
82116: PUSH
82117: LD_EXP 79
82121: PPUSH
82122: LD_VAR 0 1
82126: PPUSH
82127: LD_VAR 0 2
82131: PPUSH
82132: CALL_OW 1
82136: ST_TO_ADDR
// end ;
82137: LD_VAR 0 3
82141: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
82142: LD_INT 0
82144: PPUSH
// if not mc_bases or not base or not teleports_exit then
82145: LD_EXP 61
82149: NOT
82150: PUSH
82151: LD_VAR 0 1
82155: NOT
82156: OR
82157: PUSH
82158: LD_VAR 0 2
82162: NOT
82163: OR
82164: IFFALSE 82168
// exit ;
82166: GO 82193
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
82168: LD_ADDR_EXP 96
82172: PUSH
82173: LD_EXP 96
82177: PPUSH
82178: LD_VAR 0 1
82182: PPUSH
82183: LD_VAR 0 2
82187: PPUSH
82188: CALL_OW 1
82192: ST_TO_ADDR
// end ;
82193: LD_VAR 0 3
82197: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
82198: LD_INT 0
82200: PPUSH
82201: PPUSH
82202: PPUSH
// if not mc_bases or not base or not ext_list then
82203: LD_EXP 61
82207: NOT
82208: PUSH
82209: LD_VAR 0 1
82213: NOT
82214: OR
82215: PUSH
82216: LD_VAR 0 5
82220: NOT
82221: OR
82222: IFFALSE 82226
// exit ;
82224: GO 82399
// tmp := GetFacExtXYD ( x , y , d ) ;
82226: LD_ADDR_VAR 0 8
82230: PUSH
82231: LD_VAR 0 2
82235: PPUSH
82236: LD_VAR 0 3
82240: PPUSH
82241: LD_VAR 0 4
82245: PPUSH
82246: CALL 50449 0 3
82250: ST_TO_ADDR
// if not tmp then
82251: LD_VAR 0 8
82255: NOT
82256: IFFALSE 82260
// exit ;
82258: GO 82399
// for i in tmp do
82260: LD_ADDR_VAR 0 7
82264: PUSH
82265: LD_VAR 0 8
82269: PUSH
82270: FOR_IN
82271: IFFALSE 82397
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
82273: LD_ADDR_EXP 66
82277: PUSH
82278: LD_EXP 66
82282: PPUSH
82283: LD_VAR 0 1
82287: PPUSH
82288: LD_EXP 66
82292: PUSH
82293: LD_VAR 0 1
82297: ARRAY
82298: PPUSH
82299: LD_EXP 66
82303: PUSH
82304: LD_VAR 0 1
82308: ARRAY
82309: PUSH
82310: LD_INT 1
82312: PLUS
82313: PPUSH
82314: LD_VAR 0 5
82318: PUSH
82319: LD_INT 1
82321: ARRAY
82322: PUSH
82323: LD_VAR 0 7
82327: PUSH
82328: LD_INT 1
82330: ARRAY
82331: PUSH
82332: LD_VAR 0 7
82336: PUSH
82337: LD_INT 2
82339: ARRAY
82340: PUSH
82341: LD_VAR 0 7
82345: PUSH
82346: LD_INT 3
82348: ARRAY
82349: PUSH
82350: EMPTY
82351: LIST
82352: LIST
82353: LIST
82354: LIST
82355: PPUSH
82356: CALL_OW 2
82360: PPUSH
82361: CALL_OW 1
82365: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82366: LD_ADDR_VAR 0 5
82370: PUSH
82371: LD_VAR 0 5
82375: PPUSH
82376: LD_INT 1
82378: PPUSH
82379: CALL_OW 3
82383: ST_TO_ADDR
// if not ext_list then
82384: LD_VAR 0 5
82388: NOT
82389: IFFALSE 82395
// exit ;
82391: POP
82392: POP
82393: GO 82399
// end ;
82395: GO 82270
82397: POP
82398: POP
// end ;
82399: LD_VAR 0 6
82403: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82404: LD_INT 0
82406: PPUSH
// if not mc_bases or not base or not weapon_list then
82407: LD_EXP 61
82411: NOT
82412: PUSH
82413: LD_VAR 0 1
82417: NOT
82418: OR
82419: PUSH
82420: LD_VAR 0 2
82424: NOT
82425: OR
82426: IFFALSE 82430
// exit ;
82428: GO 82455
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82430: LD_ADDR_EXP 100
82434: PUSH
82435: LD_EXP 100
82439: PPUSH
82440: LD_VAR 0 1
82444: PPUSH
82445: LD_VAR 0 2
82449: PPUSH
82450: CALL_OW 1
82454: ST_TO_ADDR
// end ;
82455: LD_VAR 0 3
82459: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82460: LD_INT 0
82462: PPUSH
// if not mc_bases or not base or not tech_list then
82463: LD_EXP 61
82467: NOT
82468: PUSH
82469: LD_VAR 0 1
82473: NOT
82474: OR
82475: PUSH
82476: LD_VAR 0 2
82480: NOT
82481: OR
82482: IFFALSE 82486
// exit ;
82484: GO 82511
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82486: LD_ADDR_EXP 88
82490: PUSH
82491: LD_EXP 88
82495: PPUSH
82496: LD_VAR 0 1
82500: PPUSH
82501: LD_VAR 0 2
82505: PPUSH
82506: CALL_OW 1
82510: ST_TO_ADDR
// end ;
82511: LD_VAR 0 3
82515: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82516: LD_INT 0
82518: PPUSH
// if not mc_bases or not parking_area or not base then
82519: LD_EXP 61
82523: NOT
82524: PUSH
82525: LD_VAR 0 2
82529: NOT
82530: OR
82531: PUSH
82532: LD_VAR 0 1
82536: NOT
82537: OR
82538: IFFALSE 82542
// exit ;
82540: GO 82567
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82542: LD_ADDR_EXP 85
82546: PUSH
82547: LD_EXP 85
82551: PPUSH
82552: LD_VAR 0 1
82556: PPUSH
82557: LD_VAR 0 2
82561: PPUSH
82562: CALL_OW 1
82566: ST_TO_ADDR
// end ;
82567: LD_VAR 0 3
82571: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82572: LD_INT 0
82574: PPUSH
// if not mc_bases or not base or not scan_area then
82575: LD_EXP 61
82579: NOT
82580: PUSH
82581: LD_VAR 0 1
82585: NOT
82586: OR
82587: PUSH
82588: LD_VAR 0 2
82592: NOT
82593: OR
82594: IFFALSE 82598
// exit ;
82596: GO 82623
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82598: LD_ADDR_EXP 86
82602: PUSH
82603: LD_EXP 86
82607: PPUSH
82608: LD_VAR 0 1
82612: PPUSH
82613: LD_VAR 0 2
82617: PPUSH
82618: CALL_OW 1
82622: ST_TO_ADDR
// end ;
82623: LD_VAR 0 3
82627: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82628: LD_INT 0
82630: PPUSH
82631: PPUSH
// if not mc_bases or not base then
82632: LD_EXP 61
82636: NOT
82637: PUSH
82638: LD_VAR 0 1
82642: NOT
82643: OR
82644: IFFALSE 82648
// exit ;
82646: GO 82712
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82648: LD_ADDR_VAR 0 3
82652: PUSH
82653: LD_INT 1
82655: PUSH
82656: LD_INT 2
82658: PUSH
82659: LD_INT 3
82661: PUSH
82662: LD_INT 4
82664: PUSH
82665: LD_INT 11
82667: PUSH
82668: EMPTY
82669: LIST
82670: LIST
82671: LIST
82672: LIST
82673: LIST
82674: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82675: LD_ADDR_EXP 88
82679: PUSH
82680: LD_EXP 88
82684: PPUSH
82685: LD_VAR 0 1
82689: PPUSH
82690: LD_EXP 88
82694: PUSH
82695: LD_VAR 0 1
82699: ARRAY
82700: PUSH
82701: LD_VAR 0 3
82705: DIFF
82706: PPUSH
82707: CALL_OW 1
82711: ST_TO_ADDR
// end ;
82712: LD_VAR 0 2
82716: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82717: LD_INT 0
82719: PPUSH
// result := mc_vehicles [ base ] ;
82720: LD_ADDR_VAR 0 3
82724: PUSH
82725: LD_EXP 80
82729: PUSH
82730: LD_VAR 0 1
82734: ARRAY
82735: ST_TO_ADDR
// if onlyCombat then
82736: LD_VAR 0 2
82740: IFFALSE 82912
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82742: LD_ADDR_VAR 0 3
82746: PUSH
82747: LD_VAR 0 3
82751: PUSH
82752: LD_VAR 0 3
82756: PPUSH
82757: LD_INT 2
82759: PUSH
82760: LD_INT 34
82762: PUSH
82763: LD_INT 12
82765: PUSH
82766: EMPTY
82767: LIST
82768: LIST
82769: PUSH
82770: LD_INT 34
82772: PUSH
82773: LD_INT 51
82775: PUSH
82776: EMPTY
82777: LIST
82778: LIST
82779: PUSH
82780: LD_INT 34
82782: PUSH
82783: LD_INT 89
82785: PUSH
82786: EMPTY
82787: LIST
82788: LIST
82789: PUSH
82790: LD_INT 34
82792: PUSH
82793: LD_INT 32
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: PUSH
82800: LD_INT 34
82802: PUSH
82803: LD_INT 13
82805: PUSH
82806: EMPTY
82807: LIST
82808: LIST
82809: PUSH
82810: LD_INT 34
82812: PUSH
82813: LD_INT 52
82815: PUSH
82816: EMPTY
82817: LIST
82818: LIST
82819: PUSH
82820: LD_INT 34
82822: PUSH
82823: LD_INT 88
82825: PUSH
82826: EMPTY
82827: LIST
82828: LIST
82829: PUSH
82830: LD_INT 34
82832: PUSH
82833: LD_INT 14
82835: PUSH
82836: EMPTY
82837: LIST
82838: LIST
82839: PUSH
82840: LD_INT 34
82842: PUSH
82843: LD_INT 53
82845: PUSH
82846: EMPTY
82847: LIST
82848: LIST
82849: PUSH
82850: LD_INT 34
82852: PUSH
82853: LD_INT 98
82855: PUSH
82856: EMPTY
82857: LIST
82858: LIST
82859: PUSH
82860: LD_INT 34
82862: PUSH
82863: LD_INT 31
82865: PUSH
82866: EMPTY
82867: LIST
82868: LIST
82869: PUSH
82870: LD_INT 34
82872: PUSH
82873: LD_INT 48
82875: PUSH
82876: EMPTY
82877: LIST
82878: LIST
82879: PUSH
82880: LD_INT 34
82882: PUSH
82883: LD_INT 8
82885: PUSH
82886: EMPTY
82887: LIST
82888: LIST
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: LIST
82894: LIST
82895: LIST
82896: LIST
82897: LIST
82898: LIST
82899: LIST
82900: LIST
82901: LIST
82902: LIST
82903: LIST
82904: LIST
82905: PPUSH
82906: CALL_OW 72
82910: DIFF
82911: ST_TO_ADDR
// end ; end_of_file
82912: LD_VAR 0 3
82916: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82917: LD_INT 0
82919: PPUSH
82920: PPUSH
82921: PPUSH
// if not mc_bases or not skirmish then
82922: LD_EXP 61
82926: NOT
82927: PUSH
82928: LD_EXP 59
82932: NOT
82933: OR
82934: IFFALSE 82938
// exit ;
82936: GO 83103
// for i = 1 to mc_bases do
82938: LD_ADDR_VAR 0 4
82942: PUSH
82943: DOUBLE
82944: LD_INT 1
82946: DEC
82947: ST_TO_ADDR
82948: LD_EXP 61
82952: PUSH
82953: FOR_TO
82954: IFFALSE 83101
// begin if sci in mc_bases [ i ] then
82956: LD_VAR 0 2
82960: PUSH
82961: LD_EXP 61
82965: PUSH
82966: LD_VAR 0 4
82970: ARRAY
82971: IN
82972: IFFALSE 83099
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82974: LD_ADDR_EXP 90
82978: PUSH
82979: LD_EXP 90
82983: PPUSH
82984: LD_VAR 0 4
82988: PUSH
82989: LD_EXP 90
82993: PUSH
82994: LD_VAR 0 4
82998: ARRAY
82999: PUSH
83000: LD_INT 1
83002: PLUS
83003: PUSH
83004: EMPTY
83005: LIST
83006: LIST
83007: PPUSH
83008: LD_VAR 0 1
83012: PPUSH
83013: CALL 20463 0 3
83017: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
83018: LD_ADDR_VAR 0 5
83022: PUSH
83023: LD_EXP 61
83027: PUSH
83028: LD_VAR 0 4
83032: ARRAY
83033: PPUSH
83034: LD_INT 2
83036: PUSH
83037: LD_INT 30
83039: PUSH
83040: LD_INT 0
83042: PUSH
83043: EMPTY
83044: LIST
83045: LIST
83046: PUSH
83047: LD_INT 30
83049: PUSH
83050: LD_INT 1
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: PUSH
83057: EMPTY
83058: LIST
83059: LIST
83060: LIST
83061: PPUSH
83062: CALL_OW 72
83066: PPUSH
83067: LD_VAR 0 1
83071: PPUSH
83072: CALL_OW 74
83076: ST_TO_ADDR
// if tmp then
83077: LD_VAR 0 5
83081: IFFALSE 83097
// ComStandNearbyBuilding ( ape , tmp ) ;
83083: LD_VAR 0 1
83087: PPUSH
83088: LD_VAR 0 5
83092: PPUSH
83093: CALL 17065 0 2
// break ;
83097: GO 83101
// end ; end ;
83099: GO 82953
83101: POP
83102: POP
// end ;
83103: LD_VAR 0 3
83107: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
83108: LD_INT 0
83110: PPUSH
83111: PPUSH
83112: PPUSH
// if not mc_bases or not skirmish then
83113: LD_EXP 61
83117: NOT
83118: PUSH
83119: LD_EXP 59
83123: NOT
83124: OR
83125: IFFALSE 83129
// exit ;
83127: GO 83218
// for i = 1 to mc_bases do
83129: LD_ADDR_VAR 0 4
83133: PUSH
83134: DOUBLE
83135: LD_INT 1
83137: DEC
83138: ST_TO_ADDR
83139: LD_EXP 61
83143: PUSH
83144: FOR_TO
83145: IFFALSE 83216
// begin if building in mc_busy_turret_list [ i ] then
83147: LD_VAR 0 1
83151: PUSH
83152: LD_EXP 71
83156: PUSH
83157: LD_VAR 0 4
83161: ARRAY
83162: IN
83163: IFFALSE 83214
// begin tmp := mc_busy_turret_list [ i ] diff building ;
83165: LD_ADDR_VAR 0 5
83169: PUSH
83170: LD_EXP 71
83174: PUSH
83175: LD_VAR 0 4
83179: ARRAY
83180: PUSH
83181: LD_VAR 0 1
83185: DIFF
83186: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
83187: LD_ADDR_EXP 71
83191: PUSH
83192: LD_EXP 71
83196: PPUSH
83197: LD_VAR 0 4
83201: PPUSH
83202: LD_VAR 0 5
83206: PPUSH
83207: CALL_OW 1
83211: ST_TO_ADDR
// break ;
83212: GO 83216
// end ; end ;
83214: GO 83144
83216: POP
83217: POP
// end ;
83218: LD_VAR 0 3
83222: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
83223: LD_INT 0
83225: PPUSH
83226: PPUSH
83227: PPUSH
// if not mc_bases or not skirmish then
83228: LD_EXP 61
83232: NOT
83233: PUSH
83234: LD_EXP 59
83238: NOT
83239: OR
83240: IFFALSE 83244
// exit ;
83242: GO 83443
// for i = 1 to mc_bases do
83244: LD_ADDR_VAR 0 5
83248: PUSH
83249: DOUBLE
83250: LD_INT 1
83252: DEC
83253: ST_TO_ADDR
83254: LD_EXP 61
83258: PUSH
83259: FOR_TO
83260: IFFALSE 83441
// if building in mc_bases [ i ] then
83262: LD_VAR 0 1
83266: PUSH
83267: LD_EXP 61
83271: PUSH
83272: LD_VAR 0 5
83276: ARRAY
83277: IN
83278: IFFALSE 83439
// begin tmp := mc_bases [ i ] diff building ;
83280: LD_ADDR_VAR 0 6
83284: PUSH
83285: LD_EXP 61
83289: PUSH
83290: LD_VAR 0 5
83294: ARRAY
83295: PUSH
83296: LD_VAR 0 1
83300: DIFF
83301: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
83302: LD_ADDR_EXP 61
83306: PUSH
83307: LD_EXP 61
83311: PPUSH
83312: LD_VAR 0 5
83316: PPUSH
83317: LD_VAR 0 6
83321: PPUSH
83322: CALL_OW 1
83326: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83327: LD_VAR 0 1
83331: PUSH
83332: LD_EXP 69
83336: PUSH
83337: LD_VAR 0 5
83341: ARRAY
83342: IN
83343: IFFALSE 83382
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83345: LD_ADDR_EXP 69
83349: PUSH
83350: LD_EXP 69
83354: PPUSH
83355: LD_VAR 0 5
83359: PPUSH
83360: LD_EXP 69
83364: PUSH
83365: LD_VAR 0 5
83369: ARRAY
83370: PUSH
83371: LD_VAR 0 1
83375: DIFF
83376: PPUSH
83377: CALL_OW 1
83381: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83382: LD_VAR 0 1
83386: PUSH
83387: LD_EXP 70
83391: PUSH
83392: LD_VAR 0 5
83396: ARRAY
83397: IN
83398: IFFALSE 83437
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83400: LD_ADDR_EXP 70
83404: PUSH
83405: LD_EXP 70
83409: PPUSH
83410: LD_VAR 0 5
83414: PPUSH
83415: LD_EXP 70
83419: PUSH
83420: LD_VAR 0 5
83424: ARRAY
83425: PUSH
83426: LD_VAR 0 1
83430: DIFF
83431: PPUSH
83432: CALL_OW 1
83436: ST_TO_ADDR
// break ;
83437: GO 83441
// end ;
83439: GO 83259
83441: POP
83442: POP
// end ;
83443: LD_VAR 0 4
83447: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83448: LD_INT 0
83450: PPUSH
83451: PPUSH
83452: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83453: LD_EXP 61
83457: NOT
83458: PUSH
83459: LD_EXP 59
83463: NOT
83464: OR
83465: PUSH
83466: LD_VAR 0 3
83470: PUSH
83471: LD_EXP 87
83475: IN
83476: NOT
83477: OR
83478: IFFALSE 83482
// exit ;
83480: GO 83605
// for i = 1 to mc_vehicles do
83482: LD_ADDR_VAR 0 6
83486: PUSH
83487: DOUBLE
83488: LD_INT 1
83490: DEC
83491: ST_TO_ADDR
83492: LD_EXP 80
83496: PUSH
83497: FOR_TO
83498: IFFALSE 83603
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83500: LD_VAR 0 2
83504: PUSH
83505: LD_EXP 80
83509: PUSH
83510: LD_VAR 0 6
83514: ARRAY
83515: IN
83516: PUSH
83517: LD_VAR 0 1
83521: PUSH
83522: LD_EXP 80
83526: PUSH
83527: LD_VAR 0 6
83531: ARRAY
83532: IN
83533: OR
83534: IFFALSE 83601
// begin tmp := mc_vehicles [ i ] diff old ;
83536: LD_ADDR_VAR 0 7
83540: PUSH
83541: LD_EXP 80
83545: PUSH
83546: LD_VAR 0 6
83550: ARRAY
83551: PUSH
83552: LD_VAR 0 2
83556: DIFF
83557: ST_TO_ADDR
// tmp := tmp diff new ;
83558: LD_ADDR_VAR 0 7
83562: PUSH
83563: LD_VAR 0 7
83567: PUSH
83568: LD_VAR 0 1
83572: DIFF
83573: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83574: LD_ADDR_EXP 80
83578: PUSH
83579: LD_EXP 80
83583: PPUSH
83584: LD_VAR 0 6
83588: PPUSH
83589: LD_VAR 0 7
83593: PPUSH
83594: CALL_OW 1
83598: ST_TO_ADDR
// break ;
83599: GO 83603
// end ;
83601: GO 83497
83603: POP
83604: POP
// end ;
83605: LD_VAR 0 5
83609: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83610: LD_INT 0
83612: PPUSH
83613: PPUSH
83614: PPUSH
83615: PPUSH
// if not mc_bases or not skirmish then
83616: LD_EXP 61
83620: NOT
83621: PUSH
83622: LD_EXP 59
83626: NOT
83627: OR
83628: IFFALSE 83632
// exit ;
83630: GO 84052
// repeat wait ( 0 0$1 ) ;
83632: LD_INT 35
83634: PPUSH
83635: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
83639: LD_EXP 105
83643: NOT
83644: IFFALSE 83632
// mc_block_vehicle_constructed_thread := true ;
83646: LD_ADDR_EXP 105
83650: PUSH
83651: LD_INT 1
83653: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
83654: LD_ADDR_VAR 0 5
83658: PUSH
83659: LD_VAR 0 1
83663: PPUSH
83664: CALL_OW 255
83668: ST_TO_ADDR
// for i = 1 to mc_bases do
83669: LD_ADDR_VAR 0 4
83673: PUSH
83674: DOUBLE
83675: LD_INT 1
83677: DEC
83678: ST_TO_ADDR
83679: LD_EXP 61
83683: PUSH
83684: FOR_TO
83685: IFFALSE 84042
// begin if factory in mc_bases [ i ] then
83687: LD_VAR 0 2
83691: PUSH
83692: LD_EXP 61
83696: PUSH
83697: LD_VAR 0 4
83701: ARRAY
83702: IN
83703: IFFALSE 84040
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
83705: LD_EXP 83
83709: PUSH
83710: LD_VAR 0 4
83714: ARRAY
83715: PUSH
83716: LD_EXP 72
83720: PUSH
83721: LD_VAR 0 4
83725: ARRAY
83726: LESS
83727: PUSH
83728: LD_VAR 0 1
83732: PPUSH
83733: CALL_OW 264
83737: PUSH
83738: LD_INT 31
83740: PUSH
83741: LD_INT 32
83743: PUSH
83744: LD_INT 51
83746: PUSH
83747: LD_INT 89
83749: PUSH
83750: LD_INT 12
83752: PUSH
83753: LD_INT 30
83755: PUSH
83756: LD_INT 98
83758: PUSH
83759: LD_INT 11
83761: PUSH
83762: LD_INT 53
83764: PUSH
83765: LD_INT 14
83767: PUSH
83768: LD_INT 91
83770: PUSH
83771: LD_INT 29
83773: PUSH
83774: LD_INT 99
83776: PUSH
83777: LD_INT 13
83779: PUSH
83780: LD_INT 52
83782: PUSH
83783: LD_INT 88
83785: PUSH
83786: LD_INT 48
83788: PUSH
83789: LD_INT 8
83791: PUSH
83792: EMPTY
83793: LIST
83794: LIST
83795: LIST
83796: LIST
83797: LIST
83798: LIST
83799: LIST
83800: LIST
83801: LIST
83802: LIST
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: IN
83812: NOT
83813: AND
83814: IFFALSE 83862
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83816: LD_ADDR_EXP 83
83820: PUSH
83821: LD_EXP 83
83825: PPUSH
83826: LD_VAR 0 4
83830: PUSH
83831: LD_EXP 83
83835: PUSH
83836: LD_VAR 0 4
83840: ARRAY
83841: PUSH
83842: LD_INT 1
83844: PLUS
83845: PUSH
83846: EMPTY
83847: LIST
83848: LIST
83849: PPUSH
83850: LD_VAR 0 1
83854: PPUSH
83855: CALL 20463 0 3
83859: ST_TO_ADDR
83860: GO 83906
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83862: LD_ADDR_EXP 80
83866: PUSH
83867: LD_EXP 80
83871: PPUSH
83872: LD_VAR 0 4
83876: PUSH
83877: LD_EXP 80
83881: PUSH
83882: LD_VAR 0 4
83886: ARRAY
83887: PUSH
83888: LD_INT 1
83890: PLUS
83891: PUSH
83892: EMPTY
83893: LIST
83894: LIST
83895: PPUSH
83896: LD_VAR 0 1
83900: PPUSH
83901: CALL 20463 0 3
83905: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
83906: LD_ADDR_EXP 105
83910: PUSH
83911: LD_INT 0
83913: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83914: LD_VAR 0 1
83918: PPUSH
83919: CALL_OW 263
83923: PUSH
83924: LD_INT 2
83926: EQUAL
83927: IFFALSE 83956
// begin repeat wait ( 0 0$3 ) ;
83929: LD_INT 105
83931: PPUSH
83932: CALL_OW 67
// Connect ( vehicle ) ;
83936: LD_VAR 0 1
83940: PPUSH
83941: CALL 23441 0 1
// until IsControledBy ( vehicle ) ;
83945: LD_VAR 0 1
83949: PPUSH
83950: CALL_OW 312
83954: IFFALSE 83929
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83956: LD_VAR 0 1
83960: PPUSH
83961: LD_EXP 85
83965: PUSH
83966: LD_VAR 0 4
83970: ARRAY
83971: PPUSH
83972: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83976: LD_VAR 0 1
83980: PPUSH
83981: CALL_OW 263
83985: PUSH
83986: LD_INT 1
83988: NONEQUAL
83989: IFFALSE 83993
// break ;
83991: GO 84042
// repeat wait ( 0 0$1 ) ;
83993: LD_INT 35
83995: PPUSH
83996: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
84000: LD_VAR 0 1
84004: PPUSH
84005: LD_EXP 85
84009: PUSH
84010: LD_VAR 0 4
84014: ARRAY
84015: PPUSH
84016: CALL_OW 308
84020: IFFALSE 83993
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
84022: LD_VAR 0 1
84026: PPUSH
84027: CALL_OW 311
84031: PPUSH
84032: CALL_OW 121
// exit ;
84036: POP
84037: POP
84038: GO 84052
// end ; end ;
84040: GO 83684
84042: POP
84043: POP
// mc_block_vehicle_constructed_thread := false ;
84044: LD_ADDR_EXP 105
84048: PUSH
84049: LD_INT 0
84051: ST_TO_ADDR
// end ;
84052: LD_VAR 0 3
84056: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
84057: LD_INT 0
84059: PPUSH
84060: PPUSH
84061: PPUSH
84062: PPUSH
// if not mc_bases or not skirmish then
84063: LD_EXP 61
84067: NOT
84068: PUSH
84069: LD_EXP 59
84073: NOT
84074: OR
84075: IFFALSE 84079
// exit ;
84077: GO 84432
// repeat wait ( 0 0$1 ) ;
84079: LD_INT 35
84081: PPUSH
84082: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
84086: LD_VAR 0 2
84090: PPUSH
84091: LD_VAR 0 3
84095: PPUSH
84096: CALL_OW 284
84100: IFFALSE 84079
// if GetResourceTypeXY ( x , y ) = mat_artefact then
84102: LD_VAR 0 2
84106: PPUSH
84107: LD_VAR 0 3
84111: PPUSH
84112: CALL_OW 283
84116: PUSH
84117: LD_INT 4
84119: EQUAL
84120: IFFALSE 84124
// exit ;
84122: GO 84432
// for i = 1 to mc_bases do
84124: LD_ADDR_VAR 0 7
84128: PUSH
84129: DOUBLE
84130: LD_INT 1
84132: DEC
84133: ST_TO_ADDR
84134: LD_EXP 61
84138: PUSH
84139: FOR_TO
84140: IFFALSE 84430
// begin if mc_crates_area [ i ] then
84142: LD_EXP 79
84146: PUSH
84147: LD_VAR 0 7
84151: ARRAY
84152: IFFALSE 84263
// for j in mc_crates_area [ i ] do
84154: LD_ADDR_VAR 0 8
84158: PUSH
84159: LD_EXP 79
84163: PUSH
84164: LD_VAR 0 7
84168: ARRAY
84169: PUSH
84170: FOR_IN
84171: IFFALSE 84261
// if InArea ( x , y , j ) then
84173: LD_VAR 0 2
84177: PPUSH
84178: LD_VAR 0 3
84182: PPUSH
84183: LD_VAR 0 8
84187: PPUSH
84188: CALL_OW 309
84192: IFFALSE 84259
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84194: LD_ADDR_EXP 77
84198: PUSH
84199: LD_EXP 77
84203: PPUSH
84204: LD_VAR 0 7
84208: PUSH
84209: LD_EXP 77
84213: PUSH
84214: LD_VAR 0 7
84218: ARRAY
84219: PUSH
84220: LD_INT 1
84222: PLUS
84223: PUSH
84224: EMPTY
84225: LIST
84226: LIST
84227: PPUSH
84228: LD_VAR 0 4
84232: PUSH
84233: LD_VAR 0 2
84237: PUSH
84238: LD_VAR 0 3
84242: PUSH
84243: EMPTY
84244: LIST
84245: LIST
84246: LIST
84247: PPUSH
84248: CALL 20463 0 3
84252: ST_TO_ADDR
// exit ;
84253: POP
84254: POP
84255: POP
84256: POP
84257: GO 84432
// end ;
84259: GO 84170
84261: POP
84262: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
84263: LD_ADDR_VAR 0 9
84267: PUSH
84268: LD_EXP 61
84272: PUSH
84273: LD_VAR 0 7
84277: ARRAY
84278: PPUSH
84279: LD_INT 2
84281: PUSH
84282: LD_INT 30
84284: PUSH
84285: LD_INT 0
84287: PUSH
84288: EMPTY
84289: LIST
84290: LIST
84291: PUSH
84292: LD_INT 30
84294: PUSH
84295: LD_INT 1
84297: PUSH
84298: EMPTY
84299: LIST
84300: LIST
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: LIST
84306: PPUSH
84307: CALL_OW 72
84311: ST_TO_ADDR
// if not depot then
84312: LD_VAR 0 9
84316: NOT
84317: IFFALSE 84321
// continue ;
84319: GO 84139
// for j in depot do
84321: LD_ADDR_VAR 0 8
84325: PUSH
84326: LD_VAR 0 9
84330: PUSH
84331: FOR_IN
84332: IFFALSE 84426
// if GetDistUnitXY ( j , x , y ) < 30 then
84334: LD_VAR 0 8
84338: PPUSH
84339: LD_VAR 0 2
84343: PPUSH
84344: LD_VAR 0 3
84348: PPUSH
84349: CALL_OW 297
84353: PUSH
84354: LD_INT 30
84356: LESS
84357: IFFALSE 84424
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84359: LD_ADDR_EXP 77
84363: PUSH
84364: LD_EXP 77
84368: PPUSH
84369: LD_VAR 0 7
84373: PUSH
84374: LD_EXP 77
84378: PUSH
84379: LD_VAR 0 7
84383: ARRAY
84384: PUSH
84385: LD_INT 1
84387: PLUS
84388: PUSH
84389: EMPTY
84390: LIST
84391: LIST
84392: PPUSH
84393: LD_VAR 0 4
84397: PUSH
84398: LD_VAR 0 2
84402: PUSH
84403: LD_VAR 0 3
84407: PUSH
84408: EMPTY
84409: LIST
84410: LIST
84411: LIST
84412: PPUSH
84413: CALL 20463 0 3
84417: ST_TO_ADDR
// exit ;
84418: POP
84419: POP
84420: POP
84421: POP
84422: GO 84432
// end ;
84424: GO 84331
84426: POP
84427: POP
// end ;
84428: GO 84139
84430: POP
84431: POP
// end ;
84432: LD_VAR 0 6
84436: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84437: LD_INT 0
84439: PPUSH
84440: PPUSH
84441: PPUSH
84442: PPUSH
// if not mc_bases or not skirmish then
84443: LD_EXP 61
84447: NOT
84448: PUSH
84449: LD_EXP 59
84453: NOT
84454: OR
84455: IFFALSE 84459
// exit ;
84457: GO 84736
// side := GetSide ( lab ) ;
84459: LD_ADDR_VAR 0 4
84463: PUSH
84464: LD_VAR 0 2
84468: PPUSH
84469: CALL_OW 255
84473: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84474: LD_VAR 0 4
84478: PUSH
84479: LD_EXP 87
84483: IN
84484: NOT
84485: PUSH
84486: LD_EXP 88
84490: NOT
84491: OR
84492: PUSH
84493: LD_EXP 61
84497: NOT
84498: OR
84499: IFFALSE 84503
// exit ;
84501: GO 84736
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84503: LD_ADDR_EXP 88
84507: PUSH
84508: LD_EXP 88
84512: PPUSH
84513: LD_VAR 0 4
84517: PPUSH
84518: LD_EXP 88
84522: PUSH
84523: LD_VAR 0 4
84527: ARRAY
84528: PUSH
84529: LD_VAR 0 1
84533: DIFF
84534: PPUSH
84535: CALL_OW 1
84539: ST_TO_ADDR
// for i = 1 to mc_bases do
84540: LD_ADDR_VAR 0 5
84544: PUSH
84545: DOUBLE
84546: LD_INT 1
84548: DEC
84549: ST_TO_ADDR
84550: LD_EXP 61
84554: PUSH
84555: FOR_TO
84556: IFFALSE 84734
// begin if lab in mc_bases [ i ] then
84558: LD_VAR 0 2
84562: PUSH
84563: LD_EXP 61
84567: PUSH
84568: LD_VAR 0 5
84572: ARRAY
84573: IN
84574: IFFALSE 84732
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84576: LD_VAR 0 1
84580: PUSH
84581: LD_INT 11
84583: PUSH
84584: LD_INT 4
84586: PUSH
84587: LD_INT 3
84589: PUSH
84590: LD_INT 2
84592: PUSH
84593: EMPTY
84594: LIST
84595: LIST
84596: LIST
84597: LIST
84598: IN
84599: PUSH
84600: LD_EXP 91
84604: PUSH
84605: LD_VAR 0 5
84609: ARRAY
84610: AND
84611: IFFALSE 84732
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84613: LD_ADDR_VAR 0 6
84617: PUSH
84618: LD_EXP 91
84622: PUSH
84623: LD_VAR 0 5
84627: ARRAY
84628: PUSH
84629: LD_INT 1
84631: ARRAY
84632: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84633: LD_ADDR_EXP 91
84637: PUSH
84638: LD_EXP 91
84642: PPUSH
84643: LD_VAR 0 5
84647: PPUSH
84648: EMPTY
84649: PPUSH
84650: CALL_OW 1
84654: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84655: LD_VAR 0 6
84659: PPUSH
84660: LD_INT 0
84662: PPUSH
84663: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84667: LD_VAR 0 6
84671: PPUSH
84672: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84676: LD_ADDR_EXP 90
84680: PUSH
84681: LD_EXP 90
84685: PPUSH
84686: LD_VAR 0 5
84690: PPUSH
84691: LD_EXP 90
84695: PUSH
84696: LD_VAR 0 5
84700: ARRAY
84701: PPUSH
84702: LD_INT 1
84704: PPUSH
84705: LD_VAR 0 6
84709: PPUSH
84710: CALL_OW 2
84714: PPUSH
84715: CALL_OW 1
84719: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84720: LD_VAR 0 5
84724: PPUSH
84725: LD_INT 112
84727: PPUSH
84728: CALL 61186 0 2
// end ; end ; end ;
84732: GO 84555
84734: POP
84735: POP
// end ;
84736: LD_VAR 0 3
84740: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84741: LD_INT 0
84743: PPUSH
84744: PPUSH
84745: PPUSH
84746: PPUSH
84747: PPUSH
84748: PPUSH
84749: PPUSH
84750: PPUSH
// if not mc_bases or not skirmish then
84751: LD_EXP 61
84755: NOT
84756: PUSH
84757: LD_EXP 59
84761: NOT
84762: OR
84763: IFFALSE 84767
// exit ;
84765: GO 86136
// for i = 1 to mc_bases do
84767: LD_ADDR_VAR 0 3
84771: PUSH
84772: DOUBLE
84773: LD_INT 1
84775: DEC
84776: ST_TO_ADDR
84777: LD_EXP 61
84781: PUSH
84782: FOR_TO
84783: IFFALSE 86134
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84785: LD_VAR 0 1
84789: PUSH
84790: LD_EXP 61
84794: PUSH
84795: LD_VAR 0 3
84799: ARRAY
84800: IN
84801: PUSH
84802: LD_VAR 0 1
84806: PUSH
84807: LD_EXP 68
84811: PUSH
84812: LD_VAR 0 3
84816: ARRAY
84817: IN
84818: OR
84819: PUSH
84820: LD_VAR 0 1
84824: PUSH
84825: LD_EXP 83
84829: PUSH
84830: LD_VAR 0 3
84834: ARRAY
84835: IN
84836: OR
84837: PUSH
84838: LD_VAR 0 1
84842: PUSH
84843: LD_EXP 80
84847: PUSH
84848: LD_VAR 0 3
84852: ARRAY
84853: IN
84854: OR
84855: PUSH
84856: LD_VAR 0 1
84860: PUSH
84861: LD_EXP 90
84865: PUSH
84866: LD_VAR 0 3
84870: ARRAY
84871: IN
84872: OR
84873: PUSH
84874: LD_VAR 0 1
84878: PUSH
84879: LD_EXP 91
84883: PUSH
84884: LD_VAR 0 3
84888: ARRAY
84889: IN
84890: OR
84891: IFFALSE 86132
// begin if un in mc_ape [ i ] then
84893: LD_VAR 0 1
84897: PUSH
84898: LD_EXP 90
84902: PUSH
84903: LD_VAR 0 3
84907: ARRAY
84908: IN
84909: IFFALSE 84948
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84911: LD_ADDR_EXP 90
84915: PUSH
84916: LD_EXP 90
84920: PPUSH
84921: LD_VAR 0 3
84925: PPUSH
84926: LD_EXP 90
84930: PUSH
84931: LD_VAR 0 3
84935: ARRAY
84936: PUSH
84937: LD_VAR 0 1
84941: DIFF
84942: PPUSH
84943: CALL_OW 1
84947: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84948: LD_VAR 0 1
84952: PUSH
84953: LD_EXP 91
84957: PUSH
84958: LD_VAR 0 3
84962: ARRAY
84963: IN
84964: IFFALSE 84988
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84966: LD_ADDR_EXP 91
84970: PUSH
84971: LD_EXP 91
84975: PPUSH
84976: LD_VAR 0 3
84980: PPUSH
84981: EMPTY
84982: PPUSH
84983: CALL_OW 1
84987: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84988: LD_VAR 0 1
84992: PPUSH
84993: CALL_OW 247
84997: PUSH
84998: LD_INT 2
85000: EQUAL
85001: PUSH
85002: LD_VAR 0 1
85006: PPUSH
85007: CALL_OW 110
85011: PUSH
85012: LD_INT 20
85014: EQUAL
85015: PUSH
85016: LD_VAR 0 1
85020: PUSH
85021: LD_EXP 83
85025: PUSH
85026: LD_VAR 0 3
85030: ARRAY
85031: IN
85032: OR
85033: PUSH
85034: LD_VAR 0 1
85038: PPUSH
85039: CALL_OW 264
85043: PUSH
85044: LD_INT 12
85046: PUSH
85047: LD_INT 51
85049: PUSH
85050: LD_INT 89
85052: PUSH
85053: LD_INT 32
85055: PUSH
85056: LD_INT 13
85058: PUSH
85059: LD_INT 52
85061: PUSH
85062: LD_INT 31
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: IN
85074: OR
85075: AND
85076: IFFALSE 85384
// begin if un in mc_defender [ i ] then
85078: LD_VAR 0 1
85082: PUSH
85083: LD_EXP 83
85087: PUSH
85088: LD_VAR 0 3
85092: ARRAY
85093: IN
85094: IFFALSE 85133
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85096: LD_ADDR_EXP 83
85100: PUSH
85101: LD_EXP 83
85105: PPUSH
85106: LD_VAR 0 3
85110: PPUSH
85111: LD_EXP 83
85115: PUSH
85116: LD_VAR 0 3
85120: ARRAY
85121: PUSH
85122: LD_VAR 0 1
85126: DIFF
85127: PPUSH
85128: CALL_OW 1
85132: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
85133: LD_ADDR_VAR 0 8
85137: PUSH
85138: LD_VAR 0 3
85142: PPUSH
85143: LD_INT 3
85145: PPUSH
85146: CALL 81754 0 2
85150: ST_TO_ADDR
// if fac then
85151: LD_VAR 0 8
85155: IFFALSE 85384
// begin for j in fac do
85157: LD_ADDR_VAR 0 4
85161: PUSH
85162: LD_VAR 0 8
85166: PUSH
85167: FOR_IN
85168: IFFALSE 85382
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
85170: LD_ADDR_VAR 0 9
85174: PUSH
85175: LD_VAR 0 8
85179: PPUSH
85180: LD_VAR 0 1
85184: PPUSH
85185: CALL_OW 265
85189: PPUSH
85190: LD_VAR 0 1
85194: PPUSH
85195: CALL_OW 262
85199: PPUSH
85200: LD_VAR 0 1
85204: PPUSH
85205: CALL_OW 263
85209: PPUSH
85210: LD_VAR 0 1
85214: PPUSH
85215: CALL_OW 264
85219: PPUSH
85220: CALL 17961 0 5
85224: ST_TO_ADDR
// if components then
85225: LD_VAR 0 9
85229: IFFALSE 85380
// begin if GetWeapon ( un ) = ar_control_tower then
85231: LD_VAR 0 1
85235: PPUSH
85236: CALL_OW 264
85240: PUSH
85241: LD_INT 31
85243: EQUAL
85244: IFFALSE 85361
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
85246: LD_VAR 0 1
85250: PPUSH
85251: CALL_OW 311
85255: PPUSH
85256: LD_INT 0
85258: PPUSH
85259: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
85263: LD_ADDR_EXP 101
85267: PUSH
85268: LD_EXP 101
85272: PPUSH
85273: LD_VAR 0 3
85277: PPUSH
85278: LD_EXP 101
85282: PUSH
85283: LD_VAR 0 3
85287: ARRAY
85288: PUSH
85289: LD_VAR 0 1
85293: PPUSH
85294: CALL_OW 311
85298: DIFF
85299: PPUSH
85300: CALL_OW 1
85304: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
85305: LD_ADDR_VAR 0 7
85309: PUSH
85310: LD_EXP 82
85314: PUSH
85315: LD_VAR 0 3
85319: ARRAY
85320: PPUSH
85321: LD_INT 1
85323: PPUSH
85324: LD_VAR 0 9
85328: PPUSH
85329: CALL_OW 2
85333: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
85334: LD_ADDR_EXP 82
85338: PUSH
85339: LD_EXP 82
85343: PPUSH
85344: LD_VAR 0 3
85348: PPUSH
85349: LD_VAR 0 7
85353: PPUSH
85354: CALL_OW 1
85358: ST_TO_ADDR
// end else
85359: GO 85378
// MC_InsertProduceList ( i , [ components ] ) ;
85361: LD_VAR 0 3
85365: PPUSH
85366: LD_VAR 0 9
85370: PUSH
85371: EMPTY
85372: LIST
85373: PPUSH
85374: CALL 81299 0 2
// break ;
85378: GO 85382
// end ; end ;
85380: GO 85167
85382: POP
85383: POP
// end ; end ; if GetType ( un ) = unit_building then
85384: LD_VAR 0 1
85388: PPUSH
85389: CALL_OW 247
85393: PUSH
85394: LD_INT 3
85396: EQUAL
85397: IFFALSE 85800
// begin btype := GetBType ( un ) ;
85399: LD_ADDR_VAR 0 5
85403: PUSH
85404: LD_VAR 0 1
85408: PPUSH
85409: CALL_OW 266
85413: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85414: LD_VAR 0 5
85418: PUSH
85419: LD_INT 29
85421: PUSH
85422: LD_INT 30
85424: PUSH
85425: EMPTY
85426: LIST
85427: LIST
85428: IN
85429: IFFALSE 85502
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85431: LD_VAR 0 1
85435: PPUSH
85436: CALL_OW 250
85440: PPUSH
85441: LD_VAR 0 1
85445: PPUSH
85446: CALL_OW 251
85450: PPUSH
85451: LD_VAR 0 1
85455: PPUSH
85456: CALL_OW 255
85460: PPUSH
85461: CALL_OW 440
85465: NOT
85466: IFFALSE 85502
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85468: LD_VAR 0 1
85472: PPUSH
85473: CALL_OW 250
85477: PPUSH
85478: LD_VAR 0 1
85482: PPUSH
85483: CALL_OW 251
85487: PPUSH
85488: LD_VAR 0 1
85492: PPUSH
85493: CALL_OW 255
85497: PPUSH
85498: CALL_OW 441
// end ; if btype = b_warehouse then
85502: LD_VAR 0 5
85506: PUSH
85507: LD_INT 1
85509: EQUAL
85510: IFFALSE 85528
// begin btype := b_depot ;
85512: LD_ADDR_VAR 0 5
85516: PUSH
85517: LD_INT 0
85519: ST_TO_ADDR
// pos := 1 ;
85520: LD_ADDR_VAR 0 6
85524: PUSH
85525: LD_INT 1
85527: ST_TO_ADDR
// end ; if btype = b_factory then
85528: LD_VAR 0 5
85532: PUSH
85533: LD_INT 3
85535: EQUAL
85536: IFFALSE 85554
// begin btype := b_workshop ;
85538: LD_ADDR_VAR 0 5
85542: PUSH
85543: LD_INT 2
85545: ST_TO_ADDR
// pos := 1 ;
85546: LD_ADDR_VAR 0 6
85550: PUSH
85551: LD_INT 1
85553: ST_TO_ADDR
// end ; if btype = b_barracks then
85554: LD_VAR 0 5
85558: PUSH
85559: LD_INT 5
85561: EQUAL
85562: IFFALSE 85572
// btype := b_armoury ;
85564: LD_ADDR_VAR 0 5
85568: PUSH
85569: LD_INT 4
85571: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85572: LD_VAR 0 5
85576: PUSH
85577: LD_INT 7
85579: PUSH
85580: LD_INT 8
85582: PUSH
85583: EMPTY
85584: LIST
85585: LIST
85586: IN
85587: IFFALSE 85597
// btype := b_lab ;
85589: LD_ADDR_VAR 0 5
85593: PUSH
85594: LD_INT 6
85596: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85597: LD_ADDR_EXP 66
85601: PUSH
85602: LD_EXP 66
85606: PPUSH
85607: LD_VAR 0 3
85611: PUSH
85612: LD_EXP 66
85616: PUSH
85617: LD_VAR 0 3
85621: ARRAY
85622: PUSH
85623: LD_INT 1
85625: PLUS
85626: PUSH
85627: EMPTY
85628: LIST
85629: LIST
85630: PPUSH
85631: LD_VAR 0 5
85635: PUSH
85636: LD_VAR 0 1
85640: PPUSH
85641: CALL_OW 250
85645: PUSH
85646: LD_VAR 0 1
85650: PPUSH
85651: CALL_OW 251
85655: PUSH
85656: LD_VAR 0 1
85660: PPUSH
85661: CALL_OW 254
85665: PUSH
85666: EMPTY
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: PPUSH
85672: CALL 20463 0 3
85676: ST_TO_ADDR
// if pos = 1 then
85677: LD_VAR 0 6
85681: PUSH
85682: LD_INT 1
85684: EQUAL
85685: IFFALSE 85800
// begin tmp := mc_build_list [ i ] ;
85687: LD_ADDR_VAR 0 7
85691: PUSH
85692: LD_EXP 66
85696: PUSH
85697: LD_VAR 0 3
85701: ARRAY
85702: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85703: LD_VAR 0 7
85707: PPUSH
85708: LD_INT 2
85710: PUSH
85711: LD_INT 30
85713: PUSH
85714: LD_INT 0
85716: PUSH
85717: EMPTY
85718: LIST
85719: LIST
85720: PUSH
85721: LD_INT 30
85723: PUSH
85724: LD_INT 1
85726: PUSH
85727: EMPTY
85728: LIST
85729: LIST
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: LIST
85735: PPUSH
85736: CALL_OW 72
85740: IFFALSE 85750
// pos := 2 ;
85742: LD_ADDR_VAR 0 6
85746: PUSH
85747: LD_INT 2
85749: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85750: LD_ADDR_VAR 0 7
85754: PUSH
85755: LD_VAR 0 7
85759: PPUSH
85760: LD_VAR 0 6
85764: PPUSH
85765: LD_VAR 0 7
85769: PPUSH
85770: CALL 20789 0 3
85774: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85775: LD_ADDR_EXP 66
85779: PUSH
85780: LD_EXP 66
85784: PPUSH
85785: LD_VAR 0 3
85789: PPUSH
85790: LD_VAR 0 7
85794: PPUSH
85795: CALL_OW 1
85799: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85800: LD_VAR 0 1
85804: PUSH
85805: LD_EXP 61
85809: PUSH
85810: LD_VAR 0 3
85814: ARRAY
85815: IN
85816: IFFALSE 85855
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85818: LD_ADDR_EXP 61
85822: PUSH
85823: LD_EXP 61
85827: PPUSH
85828: LD_VAR 0 3
85832: PPUSH
85833: LD_EXP 61
85837: PUSH
85838: LD_VAR 0 3
85842: ARRAY
85843: PUSH
85844: LD_VAR 0 1
85848: DIFF
85849: PPUSH
85850: CALL_OW 1
85854: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85855: LD_VAR 0 1
85859: PUSH
85860: LD_EXP 68
85864: PUSH
85865: LD_VAR 0 3
85869: ARRAY
85870: IN
85871: IFFALSE 85910
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85873: LD_ADDR_EXP 68
85877: PUSH
85878: LD_EXP 68
85882: PPUSH
85883: LD_VAR 0 3
85887: PPUSH
85888: LD_EXP 68
85892: PUSH
85893: LD_VAR 0 3
85897: ARRAY
85898: PUSH
85899: LD_VAR 0 1
85903: DIFF
85904: PPUSH
85905: CALL_OW 1
85909: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85910: LD_VAR 0 1
85914: PUSH
85915: LD_EXP 80
85919: PUSH
85920: LD_VAR 0 3
85924: ARRAY
85925: IN
85926: IFFALSE 85965
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85928: LD_ADDR_EXP 80
85932: PUSH
85933: LD_EXP 80
85937: PPUSH
85938: LD_VAR 0 3
85942: PPUSH
85943: LD_EXP 80
85947: PUSH
85948: LD_VAR 0 3
85952: ARRAY
85953: PUSH
85954: LD_VAR 0 1
85958: DIFF
85959: PPUSH
85960: CALL_OW 1
85964: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85965: LD_VAR 0 1
85969: PUSH
85970: LD_EXP 83
85974: PUSH
85975: LD_VAR 0 3
85979: ARRAY
85980: IN
85981: IFFALSE 86020
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85983: LD_ADDR_EXP 83
85987: PUSH
85988: LD_EXP 83
85992: PPUSH
85993: LD_VAR 0 3
85997: PPUSH
85998: LD_EXP 83
86002: PUSH
86003: LD_VAR 0 3
86007: ARRAY
86008: PUSH
86009: LD_VAR 0 1
86013: DIFF
86014: PPUSH
86015: CALL_OW 1
86019: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
86020: LD_VAR 0 1
86024: PUSH
86025: LD_EXP 70
86029: PUSH
86030: LD_VAR 0 3
86034: ARRAY
86035: IN
86036: IFFALSE 86075
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
86038: LD_ADDR_EXP 70
86042: PUSH
86043: LD_EXP 70
86047: PPUSH
86048: LD_VAR 0 3
86052: PPUSH
86053: LD_EXP 70
86057: PUSH
86058: LD_VAR 0 3
86062: ARRAY
86063: PUSH
86064: LD_VAR 0 1
86068: DIFF
86069: PPUSH
86070: CALL_OW 1
86074: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
86075: LD_VAR 0 1
86079: PUSH
86080: LD_EXP 69
86084: PUSH
86085: LD_VAR 0 3
86089: ARRAY
86090: IN
86091: IFFALSE 86130
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
86093: LD_ADDR_EXP 69
86097: PUSH
86098: LD_EXP 69
86102: PPUSH
86103: LD_VAR 0 3
86107: PPUSH
86108: LD_EXP 69
86112: PUSH
86113: LD_VAR 0 3
86117: ARRAY
86118: PUSH
86119: LD_VAR 0 1
86123: DIFF
86124: PPUSH
86125: CALL_OW 1
86129: ST_TO_ADDR
// end ; break ;
86130: GO 86134
// end ;
86132: GO 84782
86134: POP
86135: POP
// end ;
86136: LD_VAR 0 2
86140: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
86141: LD_INT 0
86143: PPUSH
86144: PPUSH
86145: PPUSH
// if not mc_bases or not skirmish then
86146: LD_EXP 61
86150: NOT
86151: PUSH
86152: LD_EXP 59
86156: NOT
86157: OR
86158: IFFALSE 86162
// exit ;
86160: GO 86377
// for i = 1 to mc_bases do
86162: LD_ADDR_VAR 0 3
86166: PUSH
86167: DOUBLE
86168: LD_INT 1
86170: DEC
86171: ST_TO_ADDR
86172: LD_EXP 61
86176: PUSH
86177: FOR_TO
86178: IFFALSE 86375
// begin if building in mc_construct_list [ i ] then
86180: LD_VAR 0 1
86184: PUSH
86185: LD_EXP 68
86189: PUSH
86190: LD_VAR 0 3
86194: ARRAY
86195: IN
86196: IFFALSE 86373
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86198: LD_ADDR_EXP 68
86202: PUSH
86203: LD_EXP 68
86207: PPUSH
86208: LD_VAR 0 3
86212: PPUSH
86213: LD_EXP 68
86217: PUSH
86218: LD_VAR 0 3
86222: ARRAY
86223: PUSH
86224: LD_VAR 0 1
86228: DIFF
86229: PPUSH
86230: CALL_OW 1
86234: ST_TO_ADDR
// if building in mc_lab [ i ] then
86235: LD_VAR 0 1
86239: PUSH
86240: LD_EXP 94
86244: PUSH
86245: LD_VAR 0 3
86249: ARRAY
86250: IN
86251: IFFALSE 86306
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
86253: LD_ADDR_EXP 95
86257: PUSH
86258: LD_EXP 95
86262: PPUSH
86263: LD_VAR 0 3
86267: PPUSH
86268: LD_EXP 95
86272: PUSH
86273: LD_VAR 0 3
86277: ARRAY
86278: PPUSH
86279: LD_INT 1
86281: PPUSH
86282: LD_EXP 95
86286: PUSH
86287: LD_VAR 0 3
86291: ARRAY
86292: PPUSH
86293: LD_INT 0
86295: PPUSH
86296: CALL 19881 0 4
86300: PPUSH
86301: CALL_OW 1
86305: ST_TO_ADDR
// if not building in mc_bases [ i ] then
86306: LD_VAR 0 1
86310: PUSH
86311: LD_EXP 61
86315: PUSH
86316: LD_VAR 0 3
86320: ARRAY
86321: IN
86322: NOT
86323: IFFALSE 86369
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86325: LD_ADDR_EXP 61
86329: PUSH
86330: LD_EXP 61
86334: PPUSH
86335: LD_VAR 0 3
86339: PUSH
86340: LD_EXP 61
86344: PUSH
86345: LD_VAR 0 3
86349: ARRAY
86350: PUSH
86351: LD_INT 1
86353: PLUS
86354: PUSH
86355: EMPTY
86356: LIST
86357: LIST
86358: PPUSH
86359: LD_VAR 0 1
86363: PPUSH
86364: CALL 20463 0 3
86368: ST_TO_ADDR
// exit ;
86369: POP
86370: POP
86371: GO 86377
// end ; end ;
86373: GO 86177
86375: POP
86376: POP
// end ;
86377: LD_VAR 0 2
86381: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86382: LD_INT 0
86384: PPUSH
86385: PPUSH
86386: PPUSH
86387: PPUSH
86388: PPUSH
86389: PPUSH
86390: PPUSH
// if not mc_bases or not skirmish then
86391: LD_EXP 61
86395: NOT
86396: PUSH
86397: LD_EXP 59
86401: NOT
86402: OR
86403: IFFALSE 86407
// exit ;
86405: GO 87068
// for i = 1 to mc_bases do
86407: LD_ADDR_VAR 0 3
86411: PUSH
86412: DOUBLE
86413: LD_INT 1
86415: DEC
86416: ST_TO_ADDR
86417: LD_EXP 61
86421: PUSH
86422: FOR_TO
86423: IFFALSE 87066
// begin if building in mc_construct_list [ i ] then
86425: LD_VAR 0 1
86429: PUSH
86430: LD_EXP 68
86434: PUSH
86435: LD_VAR 0 3
86439: ARRAY
86440: IN
86441: IFFALSE 87064
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86443: LD_ADDR_EXP 68
86447: PUSH
86448: LD_EXP 68
86452: PPUSH
86453: LD_VAR 0 3
86457: PPUSH
86458: LD_EXP 68
86462: PUSH
86463: LD_VAR 0 3
86467: ARRAY
86468: PUSH
86469: LD_VAR 0 1
86473: DIFF
86474: PPUSH
86475: CALL_OW 1
86479: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86480: LD_ADDR_EXP 61
86484: PUSH
86485: LD_EXP 61
86489: PPUSH
86490: LD_VAR 0 3
86494: PUSH
86495: LD_EXP 61
86499: PUSH
86500: LD_VAR 0 3
86504: ARRAY
86505: PUSH
86506: LD_INT 1
86508: PLUS
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PPUSH
86514: LD_VAR 0 1
86518: PPUSH
86519: CALL 20463 0 3
86523: ST_TO_ADDR
// btype := GetBType ( building ) ;
86524: LD_ADDR_VAR 0 5
86528: PUSH
86529: LD_VAR 0 1
86533: PPUSH
86534: CALL_OW 266
86538: ST_TO_ADDR
// side := GetSide ( building ) ;
86539: LD_ADDR_VAR 0 8
86543: PUSH
86544: LD_VAR 0 1
86548: PPUSH
86549: CALL_OW 255
86553: ST_TO_ADDR
// if btype = b_lab then
86554: LD_VAR 0 5
86558: PUSH
86559: LD_INT 6
86561: EQUAL
86562: IFFALSE 86612
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86564: LD_ADDR_EXP 94
86568: PUSH
86569: LD_EXP 94
86573: PPUSH
86574: LD_VAR 0 3
86578: PUSH
86579: LD_EXP 94
86583: PUSH
86584: LD_VAR 0 3
86588: ARRAY
86589: PUSH
86590: LD_INT 1
86592: PLUS
86593: PUSH
86594: EMPTY
86595: LIST
86596: LIST
86597: PPUSH
86598: LD_VAR 0 1
86602: PPUSH
86603: CALL 20463 0 3
86607: ST_TO_ADDR
// exit ;
86608: POP
86609: POP
86610: GO 87068
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86612: LD_VAR 0 5
86616: PUSH
86617: LD_INT 0
86619: PUSH
86620: LD_INT 2
86622: PUSH
86623: LD_INT 4
86625: PUSH
86626: EMPTY
86627: LIST
86628: LIST
86629: LIST
86630: IN
86631: IFFALSE 86755
// begin if btype = b_armoury then
86633: LD_VAR 0 5
86637: PUSH
86638: LD_INT 4
86640: EQUAL
86641: IFFALSE 86651
// btype := b_barracks ;
86643: LD_ADDR_VAR 0 5
86647: PUSH
86648: LD_INT 5
86650: ST_TO_ADDR
// if btype = b_depot then
86651: LD_VAR 0 5
86655: PUSH
86656: LD_INT 0
86658: EQUAL
86659: IFFALSE 86669
// btype := b_warehouse ;
86661: LD_ADDR_VAR 0 5
86665: PUSH
86666: LD_INT 1
86668: ST_TO_ADDR
// if btype = b_workshop then
86669: LD_VAR 0 5
86673: PUSH
86674: LD_INT 2
86676: EQUAL
86677: IFFALSE 86687
// btype := b_factory ;
86679: LD_ADDR_VAR 0 5
86683: PUSH
86684: LD_INT 3
86686: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86687: LD_VAR 0 5
86691: PPUSH
86692: LD_VAR 0 8
86696: PPUSH
86697: CALL_OW 323
86701: PUSH
86702: LD_INT 1
86704: EQUAL
86705: IFFALSE 86751
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86707: LD_ADDR_EXP 93
86711: PUSH
86712: LD_EXP 93
86716: PPUSH
86717: LD_VAR 0 3
86721: PUSH
86722: LD_EXP 93
86726: PUSH
86727: LD_VAR 0 3
86731: ARRAY
86732: PUSH
86733: LD_INT 1
86735: PLUS
86736: PUSH
86737: EMPTY
86738: LIST
86739: LIST
86740: PPUSH
86741: LD_VAR 0 1
86745: PPUSH
86746: CALL 20463 0 3
86750: ST_TO_ADDR
// exit ;
86751: POP
86752: POP
86753: GO 87068
// end ; if btype in [ b_bunker , b_turret ] then
86755: LD_VAR 0 5
86759: PUSH
86760: LD_INT 32
86762: PUSH
86763: LD_INT 33
86765: PUSH
86766: EMPTY
86767: LIST
86768: LIST
86769: IN
86770: IFFALSE 87060
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86772: LD_ADDR_EXP 69
86776: PUSH
86777: LD_EXP 69
86781: PPUSH
86782: LD_VAR 0 3
86786: PUSH
86787: LD_EXP 69
86791: PUSH
86792: LD_VAR 0 3
86796: ARRAY
86797: PUSH
86798: LD_INT 1
86800: PLUS
86801: PUSH
86802: EMPTY
86803: LIST
86804: LIST
86805: PPUSH
86806: LD_VAR 0 1
86810: PPUSH
86811: CALL 20463 0 3
86815: ST_TO_ADDR
// if btype = b_bunker then
86816: LD_VAR 0 5
86820: PUSH
86821: LD_INT 32
86823: EQUAL
86824: IFFALSE 87060
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86826: LD_ADDR_EXP 70
86830: PUSH
86831: LD_EXP 70
86835: PPUSH
86836: LD_VAR 0 3
86840: PUSH
86841: LD_EXP 70
86845: PUSH
86846: LD_VAR 0 3
86850: ARRAY
86851: PUSH
86852: LD_INT 1
86854: PLUS
86855: PUSH
86856: EMPTY
86857: LIST
86858: LIST
86859: PPUSH
86860: LD_VAR 0 1
86864: PPUSH
86865: CALL 20463 0 3
86869: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86870: LD_ADDR_VAR 0 6
86874: PUSH
86875: LD_EXP 61
86879: PUSH
86880: LD_VAR 0 3
86884: ARRAY
86885: PPUSH
86886: LD_INT 25
86888: PUSH
86889: LD_INT 1
86891: PUSH
86892: EMPTY
86893: LIST
86894: LIST
86895: PUSH
86896: LD_INT 3
86898: PUSH
86899: LD_INT 54
86901: PUSH
86902: EMPTY
86903: LIST
86904: PUSH
86905: EMPTY
86906: LIST
86907: LIST
86908: PUSH
86909: EMPTY
86910: LIST
86911: LIST
86912: PPUSH
86913: CALL_OW 72
86917: ST_TO_ADDR
// if tmp then
86918: LD_VAR 0 6
86922: IFFALSE 86928
// exit ;
86924: POP
86925: POP
86926: GO 87068
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86928: LD_ADDR_VAR 0 6
86932: PUSH
86933: LD_EXP 61
86937: PUSH
86938: LD_VAR 0 3
86942: ARRAY
86943: PPUSH
86944: LD_INT 2
86946: PUSH
86947: LD_INT 30
86949: PUSH
86950: LD_INT 4
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 30
86959: PUSH
86960: LD_INT 5
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: LIST
86971: PPUSH
86972: CALL_OW 72
86976: ST_TO_ADDR
// if not tmp then
86977: LD_VAR 0 6
86981: NOT
86982: IFFALSE 86988
// exit ;
86984: POP
86985: POP
86986: GO 87068
// for j in tmp do
86988: LD_ADDR_VAR 0 4
86992: PUSH
86993: LD_VAR 0 6
86997: PUSH
86998: FOR_IN
86999: IFFALSE 87058
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
87001: LD_ADDR_VAR 0 7
87005: PUSH
87006: LD_VAR 0 4
87010: PPUSH
87011: CALL_OW 313
87015: PPUSH
87016: LD_INT 25
87018: PUSH
87019: LD_INT 1
87021: PUSH
87022: EMPTY
87023: LIST
87024: LIST
87025: PPUSH
87026: CALL_OW 72
87030: ST_TO_ADDR
// if units then
87031: LD_VAR 0 7
87035: IFFALSE 87056
// begin ComExitBuilding ( units [ 1 ] ) ;
87037: LD_VAR 0 7
87041: PUSH
87042: LD_INT 1
87044: ARRAY
87045: PPUSH
87046: CALL_OW 122
// exit ;
87050: POP
87051: POP
87052: POP
87053: POP
87054: GO 87068
// end ; end ;
87056: GO 86998
87058: POP
87059: POP
// end ; end ; exit ;
87060: POP
87061: POP
87062: GO 87068
// end ; end ;
87064: GO 86422
87066: POP
87067: POP
// end ;
87068: LD_VAR 0 2
87072: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
87073: LD_INT 0
87075: PPUSH
87076: PPUSH
87077: PPUSH
87078: PPUSH
87079: PPUSH
87080: PPUSH
87081: PPUSH
// if not mc_bases or not skirmish then
87082: LD_EXP 61
87086: NOT
87087: PUSH
87088: LD_EXP 59
87092: NOT
87093: OR
87094: IFFALSE 87098
// exit ;
87096: GO 87363
// btype := GetBType ( building ) ;
87098: LD_ADDR_VAR 0 6
87102: PUSH
87103: LD_VAR 0 1
87107: PPUSH
87108: CALL_OW 266
87112: ST_TO_ADDR
// x := GetX ( building ) ;
87113: LD_ADDR_VAR 0 7
87117: PUSH
87118: LD_VAR 0 1
87122: PPUSH
87123: CALL_OW 250
87127: ST_TO_ADDR
// y := GetY ( building ) ;
87128: LD_ADDR_VAR 0 8
87132: PUSH
87133: LD_VAR 0 1
87137: PPUSH
87138: CALL_OW 251
87142: ST_TO_ADDR
// d := GetDir ( building ) ;
87143: LD_ADDR_VAR 0 9
87147: PUSH
87148: LD_VAR 0 1
87152: PPUSH
87153: CALL_OW 254
87157: ST_TO_ADDR
// for i = 1 to mc_bases do
87158: LD_ADDR_VAR 0 4
87162: PUSH
87163: DOUBLE
87164: LD_INT 1
87166: DEC
87167: ST_TO_ADDR
87168: LD_EXP 61
87172: PUSH
87173: FOR_TO
87174: IFFALSE 87361
// begin if not mc_build_list [ i ] then
87176: LD_EXP 66
87180: PUSH
87181: LD_VAR 0 4
87185: ARRAY
87186: NOT
87187: IFFALSE 87191
// continue ;
87189: GO 87173
// for j := 1 to mc_build_list [ i ] do
87191: LD_ADDR_VAR 0 5
87195: PUSH
87196: DOUBLE
87197: LD_INT 1
87199: DEC
87200: ST_TO_ADDR
87201: LD_EXP 66
87205: PUSH
87206: LD_VAR 0 4
87210: ARRAY
87211: PUSH
87212: FOR_TO
87213: IFFALSE 87357
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
87215: LD_VAR 0 6
87219: PUSH
87220: LD_VAR 0 7
87224: PUSH
87225: LD_VAR 0 8
87229: PUSH
87230: LD_VAR 0 9
87234: PUSH
87235: EMPTY
87236: LIST
87237: LIST
87238: LIST
87239: LIST
87240: PPUSH
87241: LD_EXP 66
87245: PUSH
87246: LD_VAR 0 4
87250: ARRAY
87251: PUSH
87252: LD_VAR 0 5
87256: ARRAY
87257: PPUSH
87258: CALL 26652 0 2
87262: IFFALSE 87355
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
87264: LD_ADDR_EXP 66
87268: PUSH
87269: LD_EXP 66
87273: PPUSH
87274: LD_VAR 0 4
87278: PPUSH
87279: LD_EXP 66
87283: PUSH
87284: LD_VAR 0 4
87288: ARRAY
87289: PPUSH
87290: LD_VAR 0 5
87294: PPUSH
87295: CALL_OW 3
87299: PPUSH
87300: CALL_OW 1
87304: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
87305: LD_ADDR_EXP 68
87309: PUSH
87310: LD_EXP 68
87314: PPUSH
87315: LD_VAR 0 4
87319: PUSH
87320: LD_EXP 68
87324: PUSH
87325: LD_VAR 0 4
87329: ARRAY
87330: PUSH
87331: LD_INT 1
87333: PLUS
87334: PUSH
87335: EMPTY
87336: LIST
87337: LIST
87338: PPUSH
87339: LD_VAR 0 1
87343: PPUSH
87344: CALL 20463 0 3
87348: ST_TO_ADDR
// exit ;
87349: POP
87350: POP
87351: POP
87352: POP
87353: GO 87363
// end ;
87355: GO 87212
87357: POP
87358: POP
// end ;
87359: GO 87173
87361: POP
87362: POP
// end ;
87363: LD_VAR 0 3
87367: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
87368: LD_INT 0
87370: PPUSH
87371: PPUSH
87372: PPUSH
// if not mc_bases or not skirmish then
87373: LD_EXP 61
87377: NOT
87378: PUSH
87379: LD_EXP 59
87383: NOT
87384: OR
87385: IFFALSE 87389
// exit ;
87387: GO 87579
// for i = 1 to mc_bases do
87389: LD_ADDR_VAR 0 4
87393: PUSH
87394: DOUBLE
87395: LD_INT 1
87397: DEC
87398: ST_TO_ADDR
87399: LD_EXP 61
87403: PUSH
87404: FOR_TO
87405: IFFALSE 87492
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87407: LD_VAR 0 1
87411: PUSH
87412: LD_EXP 69
87416: PUSH
87417: LD_VAR 0 4
87421: ARRAY
87422: IN
87423: PUSH
87424: LD_VAR 0 1
87428: PUSH
87429: LD_EXP 70
87433: PUSH
87434: LD_VAR 0 4
87438: ARRAY
87439: IN
87440: NOT
87441: AND
87442: IFFALSE 87490
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87444: LD_ADDR_EXP 70
87448: PUSH
87449: LD_EXP 70
87453: PPUSH
87454: LD_VAR 0 4
87458: PUSH
87459: LD_EXP 70
87463: PUSH
87464: LD_VAR 0 4
87468: ARRAY
87469: PUSH
87470: LD_INT 1
87472: PLUS
87473: PUSH
87474: EMPTY
87475: LIST
87476: LIST
87477: PPUSH
87478: LD_VAR 0 1
87482: PPUSH
87483: CALL 20463 0 3
87487: ST_TO_ADDR
// break ;
87488: GO 87492
// end ; end ;
87490: GO 87404
87492: POP
87493: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87494: LD_VAR 0 1
87498: PPUSH
87499: CALL_OW 257
87503: PUSH
87504: LD_EXP 87
87508: IN
87509: PUSH
87510: LD_VAR 0 1
87514: PPUSH
87515: CALL_OW 266
87519: PUSH
87520: LD_INT 5
87522: EQUAL
87523: AND
87524: PUSH
87525: LD_VAR 0 2
87529: PPUSH
87530: CALL_OW 110
87534: PUSH
87535: LD_INT 18
87537: NONEQUAL
87538: AND
87539: IFFALSE 87579
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87541: LD_VAR 0 2
87545: PPUSH
87546: CALL_OW 257
87550: PUSH
87551: LD_INT 5
87553: PUSH
87554: LD_INT 8
87556: PUSH
87557: LD_INT 9
87559: PUSH
87560: EMPTY
87561: LIST
87562: LIST
87563: LIST
87564: IN
87565: IFFALSE 87579
// SetClass ( unit , 1 ) ;
87567: LD_VAR 0 2
87571: PPUSH
87572: LD_INT 1
87574: PPUSH
87575: CALL_OW 336
// end ;
87579: LD_VAR 0 3
87583: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87584: LD_INT 0
87586: PPUSH
87587: PPUSH
// if not mc_bases or not skirmish then
87588: LD_EXP 61
87592: NOT
87593: PUSH
87594: LD_EXP 59
87598: NOT
87599: OR
87600: IFFALSE 87604
// exit ;
87602: GO 87720
// if GetLives ( abandoned_vehicle ) > 250 then
87604: LD_VAR 0 2
87608: PPUSH
87609: CALL_OW 256
87613: PUSH
87614: LD_INT 250
87616: GREATER
87617: IFFALSE 87621
// exit ;
87619: GO 87720
// for i = 1 to mc_bases do
87621: LD_ADDR_VAR 0 6
87625: PUSH
87626: DOUBLE
87627: LD_INT 1
87629: DEC
87630: ST_TO_ADDR
87631: LD_EXP 61
87635: PUSH
87636: FOR_TO
87637: IFFALSE 87718
// begin if driver in mc_bases [ i ] then
87639: LD_VAR 0 1
87643: PUSH
87644: LD_EXP 61
87648: PUSH
87649: LD_VAR 0 6
87653: ARRAY
87654: IN
87655: IFFALSE 87716
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87657: LD_VAR 0 1
87661: PPUSH
87662: LD_EXP 61
87666: PUSH
87667: LD_VAR 0 6
87671: ARRAY
87672: PPUSH
87673: LD_INT 2
87675: PUSH
87676: LD_INT 30
87678: PUSH
87679: LD_INT 0
87681: PUSH
87682: EMPTY
87683: LIST
87684: LIST
87685: PUSH
87686: LD_INT 30
87688: PUSH
87689: LD_INT 1
87691: PUSH
87692: EMPTY
87693: LIST
87694: LIST
87695: PUSH
87696: EMPTY
87697: LIST
87698: LIST
87699: LIST
87700: PPUSH
87701: CALL_OW 72
87705: PUSH
87706: LD_INT 1
87708: ARRAY
87709: PPUSH
87710: CALL 53679 0 2
// break ;
87714: GO 87718
// end ; end ;
87716: GO 87636
87718: POP
87719: POP
// end ; end_of_file end_of_file
87720: LD_VAR 0 5
87724: RET
// export globalGameSaveCounter ; every 0 0$1 do
87725: GO 87727
87727: DISABLE
// begin enable ;
87728: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
87729: LD_STRING updateTimer(
87731: PUSH
87732: LD_OWVAR 1
87736: STR
87737: PUSH
87738: LD_STRING );
87740: STR
87741: PPUSH
87742: CALL_OW 559
// end ;
87746: END
// every 0 0$1 do
87747: GO 87749
87749: DISABLE
// begin globalGameSaveCounter := 0 ;
87750: LD_ADDR_EXP 106
87754: PUSH
87755: LD_INT 0
87757: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
87758: LD_STRING setGameSaveCounter(0)
87760: PPUSH
87761: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
87765: LD_STRING initStreamRollete();
87767: PPUSH
87768: CALL_OW 559
// InitStreamMode ;
87772: CALL 89098 0 0
// DefineStreamItems ( false ) ;
87776: LD_INT 0
87778: PPUSH
87779: CALL 89562 0 1
// end ;
87783: END
// export function SOS_MapStart ( ) ; begin
87784: LD_INT 0
87786: PPUSH
// if streamModeActive then
87787: LD_EXP 107
87791: IFFALSE 87800
// DefineStreamItems ( true ) ;
87793: LD_INT 1
87795: PPUSH
87796: CALL 89562 0 1
// UpdateLuaVariables ( ) ;
87800: CALL 87817 0 0
// UpdateFactoryWaypoints ( ) ;
87804: CALL 102431 0 0
// UpdateWarehouseGatheringPoints ( ) ;
87808: CALL 102688 0 0
// end ;
87812: LD_VAR 0 1
87816: RET
// function UpdateLuaVariables ( ) ; begin
87817: LD_INT 0
87819: PPUSH
// if globalGameSaveCounter then
87820: LD_EXP 106
87824: IFFALSE 87858
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
87826: LD_ADDR_EXP 106
87830: PUSH
87831: LD_EXP 106
87835: PPUSH
87836: CALL 54163 0 1
87840: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
87841: LD_STRING setGameSaveCounter(
87843: PUSH
87844: LD_EXP 106
87848: STR
87849: PUSH
87850: LD_STRING )
87852: STR
87853: PPUSH
87854: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
87858: LD_STRING setGameDifficulty(
87860: PUSH
87861: LD_OWVAR 67
87865: STR
87866: PUSH
87867: LD_STRING )
87869: STR
87870: PPUSH
87871: CALL_OW 559
// end ;
87875: LD_VAR 0 1
87879: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87880: LD_INT 0
87882: PPUSH
// if p2 = stream_mode then
87883: LD_VAR 0 2
87887: PUSH
87888: LD_INT 100
87890: EQUAL
87891: IFFALSE 88894
// begin if not StreamModeActive then
87893: LD_EXP 107
87897: NOT
87898: IFFALSE 87908
// StreamModeActive := true ;
87900: LD_ADDR_EXP 107
87904: PUSH
87905: LD_INT 1
87907: ST_TO_ADDR
// if p3 = 0 then
87908: LD_VAR 0 3
87912: PUSH
87913: LD_INT 0
87915: EQUAL
87916: IFFALSE 87922
// InitStreamMode ;
87918: CALL 89098 0 0
// if p3 = 1 then
87922: LD_VAR 0 3
87926: PUSH
87927: LD_INT 1
87929: EQUAL
87930: IFFALSE 87940
// sRocket := true ;
87932: LD_ADDR_EXP 112
87936: PUSH
87937: LD_INT 1
87939: ST_TO_ADDR
// if p3 = 2 then
87940: LD_VAR 0 3
87944: PUSH
87945: LD_INT 2
87947: EQUAL
87948: IFFALSE 87958
// sSpeed := true ;
87950: LD_ADDR_EXP 111
87954: PUSH
87955: LD_INT 1
87957: ST_TO_ADDR
// if p3 = 3 then
87958: LD_VAR 0 3
87962: PUSH
87963: LD_INT 3
87965: EQUAL
87966: IFFALSE 87976
// sEngine := true ;
87968: LD_ADDR_EXP 113
87972: PUSH
87973: LD_INT 1
87975: ST_TO_ADDR
// if p3 = 4 then
87976: LD_VAR 0 3
87980: PUSH
87981: LD_INT 4
87983: EQUAL
87984: IFFALSE 87994
// sSpec := true ;
87986: LD_ADDR_EXP 110
87990: PUSH
87991: LD_INT 1
87993: ST_TO_ADDR
// if p3 = 5 then
87994: LD_VAR 0 3
87998: PUSH
87999: LD_INT 5
88001: EQUAL
88002: IFFALSE 88012
// sLevel := true ;
88004: LD_ADDR_EXP 114
88008: PUSH
88009: LD_INT 1
88011: ST_TO_ADDR
// if p3 = 6 then
88012: LD_VAR 0 3
88016: PUSH
88017: LD_INT 6
88019: EQUAL
88020: IFFALSE 88030
// sArmoury := true ;
88022: LD_ADDR_EXP 115
88026: PUSH
88027: LD_INT 1
88029: ST_TO_ADDR
// if p3 = 7 then
88030: LD_VAR 0 3
88034: PUSH
88035: LD_INT 7
88037: EQUAL
88038: IFFALSE 88048
// sRadar := true ;
88040: LD_ADDR_EXP 116
88044: PUSH
88045: LD_INT 1
88047: ST_TO_ADDR
// if p3 = 8 then
88048: LD_VAR 0 3
88052: PUSH
88053: LD_INT 8
88055: EQUAL
88056: IFFALSE 88066
// sBunker := true ;
88058: LD_ADDR_EXP 117
88062: PUSH
88063: LD_INT 1
88065: ST_TO_ADDR
// if p3 = 9 then
88066: LD_VAR 0 3
88070: PUSH
88071: LD_INT 9
88073: EQUAL
88074: IFFALSE 88084
// sHack := true ;
88076: LD_ADDR_EXP 118
88080: PUSH
88081: LD_INT 1
88083: ST_TO_ADDR
// if p3 = 10 then
88084: LD_VAR 0 3
88088: PUSH
88089: LD_INT 10
88091: EQUAL
88092: IFFALSE 88102
// sFire := true ;
88094: LD_ADDR_EXP 119
88098: PUSH
88099: LD_INT 1
88101: ST_TO_ADDR
// if p3 = 11 then
88102: LD_VAR 0 3
88106: PUSH
88107: LD_INT 11
88109: EQUAL
88110: IFFALSE 88120
// sRefresh := true ;
88112: LD_ADDR_EXP 120
88116: PUSH
88117: LD_INT 1
88119: ST_TO_ADDR
// if p3 = 12 then
88120: LD_VAR 0 3
88124: PUSH
88125: LD_INT 12
88127: EQUAL
88128: IFFALSE 88138
// sExp := true ;
88130: LD_ADDR_EXP 121
88134: PUSH
88135: LD_INT 1
88137: ST_TO_ADDR
// if p3 = 13 then
88138: LD_VAR 0 3
88142: PUSH
88143: LD_INT 13
88145: EQUAL
88146: IFFALSE 88156
// sDepot := true ;
88148: LD_ADDR_EXP 122
88152: PUSH
88153: LD_INT 1
88155: ST_TO_ADDR
// if p3 = 14 then
88156: LD_VAR 0 3
88160: PUSH
88161: LD_INT 14
88163: EQUAL
88164: IFFALSE 88174
// sFlag := true ;
88166: LD_ADDR_EXP 123
88170: PUSH
88171: LD_INT 1
88173: ST_TO_ADDR
// if p3 = 15 then
88174: LD_VAR 0 3
88178: PUSH
88179: LD_INT 15
88181: EQUAL
88182: IFFALSE 88192
// sKamikadze := true ;
88184: LD_ADDR_EXP 131
88188: PUSH
88189: LD_INT 1
88191: ST_TO_ADDR
// if p3 = 16 then
88192: LD_VAR 0 3
88196: PUSH
88197: LD_INT 16
88199: EQUAL
88200: IFFALSE 88210
// sTroll := true ;
88202: LD_ADDR_EXP 132
88206: PUSH
88207: LD_INT 1
88209: ST_TO_ADDR
// if p3 = 17 then
88210: LD_VAR 0 3
88214: PUSH
88215: LD_INT 17
88217: EQUAL
88218: IFFALSE 88228
// sSlow := true ;
88220: LD_ADDR_EXP 133
88224: PUSH
88225: LD_INT 1
88227: ST_TO_ADDR
// if p3 = 18 then
88228: LD_VAR 0 3
88232: PUSH
88233: LD_INT 18
88235: EQUAL
88236: IFFALSE 88246
// sLack := true ;
88238: LD_ADDR_EXP 134
88242: PUSH
88243: LD_INT 1
88245: ST_TO_ADDR
// if p3 = 19 then
88246: LD_VAR 0 3
88250: PUSH
88251: LD_INT 19
88253: EQUAL
88254: IFFALSE 88264
// sTank := true ;
88256: LD_ADDR_EXP 136
88260: PUSH
88261: LD_INT 1
88263: ST_TO_ADDR
// if p3 = 20 then
88264: LD_VAR 0 3
88268: PUSH
88269: LD_INT 20
88271: EQUAL
88272: IFFALSE 88282
// sRemote := true ;
88274: LD_ADDR_EXP 137
88278: PUSH
88279: LD_INT 1
88281: ST_TO_ADDR
// if p3 = 21 then
88282: LD_VAR 0 3
88286: PUSH
88287: LD_INT 21
88289: EQUAL
88290: IFFALSE 88300
// sPowell := true ;
88292: LD_ADDR_EXP 138
88296: PUSH
88297: LD_INT 1
88299: ST_TO_ADDR
// if p3 = 22 then
88300: LD_VAR 0 3
88304: PUSH
88305: LD_INT 22
88307: EQUAL
88308: IFFALSE 88318
// sTeleport := true ;
88310: LD_ADDR_EXP 141
88314: PUSH
88315: LD_INT 1
88317: ST_TO_ADDR
// if p3 = 23 then
88318: LD_VAR 0 3
88322: PUSH
88323: LD_INT 23
88325: EQUAL
88326: IFFALSE 88336
// sOilTower := true ;
88328: LD_ADDR_EXP 143
88332: PUSH
88333: LD_INT 1
88335: ST_TO_ADDR
// if p3 = 24 then
88336: LD_VAR 0 3
88340: PUSH
88341: LD_INT 24
88343: EQUAL
88344: IFFALSE 88354
// sShovel := true ;
88346: LD_ADDR_EXP 144
88350: PUSH
88351: LD_INT 1
88353: ST_TO_ADDR
// if p3 = 25 then
88354: LD_VAR 0 3
88358: PUSH
88359: LD_INT 25
88361: EQUAL
88362: IFFALSE 88372
// sSheik := true ;
88364: LD_ADDR_EXP 145
88368: PUSH
88369: LD_INT 1
88371: ST_TO_ADDR
// if p3 = 26 then
88372: LD_VAR 0 3
88376: PUSH
88377: LD_INT 26
88379: EQUAL
88380: IFFALSE 88390
// sEarthquake := true ;
88382: LD_ADDR_EXP 147
88386: PUSH
88387: LD_INT 1
88389: ST_TO_ADDR
// if p3 = 27 then
88390: LD_VAR 0 3
88394: PUSH
88395: LD_INT 27
88397: EQUAL
88398: IFFALSE 88408
// sAI := true ;
88400: LD_ADDR_EXP 148
88404: PUSH
88405: LD_INT 1
88407: ST_TO_ADDR
// if p3 = 28 then
88408: LD_VAR 0 3
88412: PUSH
88413: LD_INT 28
88415: EQUAL
88416: IFFALSE 88426
// sCargo := true ;
88418: LD_ADDR_EXP 151
88422: PUSH
88423: LD_INT 1
88425: ST_TO_ADDR
// if p3 = 29 then
88426: LD_VAR 0 3
88430: PUSH
88431: LD_INT 29
88433: EQUAL
88434: IFFALSE 88444
// sDLaser := true ;
88436: LD_ADDR_EXP 152
88440: PUSH
88441: LD_INT 1
88443: ST_TO_ADDR
// if p3 = 30 then
88444: LD_VAR 0 3
88448: PUSH
88449: LD_INT 30
88451: EQUAL
88452: IFFALSE 88462
// sExchange := true ;
88454: LD_ADDR_EXP 153
88458: PUSH
88459: LD_INT 1
88461: ST_TO_ADDR
// if p3 = 31 then
88462: LD_VAR 0 3
88466: PUSH
88467: LD_INT 31
88469: EQUAL
88470: IFFALSE 88480
// sFac := true ;
88472: LD_ADDR_EXP 154
88476: PUSH
88477: LD_INT 1
88479: ST_TO_ADDR
// if p3 = 32 then
88480: LD_VAR 0 3
88484: PUSH
88485: LD_INT 32
88487: EQUAL
88488: IFFALSE 88498
// sPower := true ;
88490: LD_ADDR_EXP 155
88494: PUSH
88495: LD_INT 1
88497: ST_TO_ADDR
// if p3 = 33 then
88498: LD_VAR 0 3
88502: PUSH
88503: LD_INT 33
88505: EQUAL
88506: IFFALSE 88516
// sRandom := true ;
88508: LD_ADDR_EXP 156
88512: PUSH
88513: LD_INT 1
88515: ST_TO_ADDR
// if p3 = 34 then
88516: LD_VAR 0 3
88520: PUSH
88521: LD_INT 34
88523: EQUAL
88524: IFFALSE 88534
// sShield := true ;
88526: LD_ADDR_EXP 157
88530: PUSH
88531: LD_INT 1
88533: ST_TO_ADDR
// if p3 = 35 then
88534: LD_VAR 0 3
88538: PUSH
88539: LD_INT 35
88541: EQUAL
88542: IFFALSE 88552
// sTime := true ;
88544: LD_ADDR_EXP 158
88548: PUSH
88549: LD_INT 1
88551: ST_TO_ADDR
// if p3 = 36 then
88552: LD_VAR 0 3
88556: PUSH
88557: LD_INT 36
88559: EQUAL
88560: IFFALSE 88570
// sTools := true ;
88562: LD_ADDR_EXP 159
88566: PUSH
88567: LD_INT 1
88569: ST_TO_ADDR
// if p3 = 101 then
88570: LD_VAR 0 3
88574: PUSH
88575: LD_INT 101
88577: EQUAL
88578: IFFALSE 88588
// sSold := true ;
88580: LD_ADDR_EXP 124
88584: PUSH
88585: LD_INT 1
88587: ST_TO_ADDR
// if p3 = 102 then
88588: LD_VAR 0 3
88592: PUSH
88593: LD_INT 102
88595: EQUAL
88596: IFFALSE 88606
// sDiff := true ;
88598: LD_ADDR_EXP 125
88602: PUSH
88603: LD_INT 1
88605: ST_TO_ADDR
// if p3 = 103 then
88606: LD_VAR 0 3
88610: PUSH
88611: LD_INT 103
88613: EQUAL
88614: IFFALSE 88624
// sFog := true ;
88616: LD_ADDR_EXP 128
88620: PUSH
88621: LD_INT 1
88623: ST_TO_ADDR
// if p3 = 104 then
88624: LD_VAR 0 3
88628: PUSH
88629: LD_INT 104
88631: EQUAL
88632: IFFALSE 88642
// sReset := true ;
88634: LD_ADDR_EXP 129
88638: PUSH
88639: LD_INT 1
88641: ST_TO_ADDR
// if p3 = 105 then
88642: LD_VAR 0 3
88646: PUSH
88647: LD_INT 105
88649: EQUAL
88650: IFFALSE 88660
// sSun := true ;
88652: LD_ADDR_EXP 130
88656: PUSH
88657: LD_INT 1
88659: ST_TO_ADDR
// if p3 = 106 then
88660: LD_VAR 0 3
88664: PUSH
88665: LD_INT 106
88667: EQUAL
88668: IFFALSE 88678
// sTiger := true ;
88670: LD_ADDR_EXP 126
88674: PUSH
88675: LD_INT 1
88677: ST_TO_ADDR
// if p3 = 107 then
88678: LD_VAR 0 3
88682: PUSH
88683: LD_INT 107
88685: EQUAL
88686: IFFALSE 88696
// sBomb := true ;
88688: LD_ADDR_EXP 127
88692: PUSH
88693: LD_INT 1
88695: ST_TO_ADDR
// if p3 = 108 then
88696: LD_VAR 0 3
88700: PUSH
88701: LD_INT 108
88703: EQUAL
88704: IFFALSE 88714
// sWound := true ;
88706: LD_ADDR_EXP 135
88710: PUSH
88711: LD_INT 1
88713: ST_TO_ADDR
// if p3 = 109 then
88714: LD_VAR 0 3
88718: PUSH
88719: LD_INT 109
88721: EQUAL
88722: IFFALSE 88732
// sBetray := true ;
88724: LD_ADDR_EXP 139
88728: PUSH
88729: LD_INT 1
88731: ST_TO_ADDR
// if p3 = 110 then
88732: LD_VAR 0 3
88736: PUSH
88737: LD_INT 110
88739: EQUAL
88740: IFFALSE 88750
// sContamin := true ;
88742: LD_ADDR_EXP 140
88746: PUSH
88747: LD_INT 1
88749: ST_TO_ADDR
// if p3 = 111 then
88750: LD_VAR 0 3
88754: PUSH
88755: LD_INT 111
88757: EQUAL
88758: IFFALSE 88768
// sOil := true ;
88760: LD_ADDR_EXP 142
88764: PUSH
88765: LD_INT 1
88767: ST_TO_ADDR
// if p3 = 112 then
88768: LD_VAR 0 3
88772: PUSH
88773: LD_INT 112
88775: EQUAL
88776: IFFALSE 88786
// sStu := true ;
88778: LD_ADDR_EXP 146
88782: PUSH
88783: LD_INT 1
88785: ST_TO_ADDR
// if p3 = 113 then
88786: LD_VAR 0 3
88790: PUSH
88791: LD_INT 113
88793: EQUAL
88794: IFFALSE 88804
// sBazooka := true ;
88796: LD_ADDR_EXP 149
88800: PUSH
88801: LD_INT 1
88803: ST_TO_ADDR
// if p3 = 114 then
88804: LD_VAR 0 3
88808: PUSH
88809: LD_INT 114
88811: EQUAL
88812: IFFALSE 88822
// sMortar := true ;
88814: LD_ADDR_EXP 150
88818: PUSH
88819: LD_INT 1
88821: ST_TO_ADDR
// if p3 = 115 then
88822: LD_VAR 0 3
88826: PUSH
88827: LD_INT 115
88829: EQUAL
88830: IFFALSE 88840
// sRanger := true ;
88832: LD_ADDR_EXP 160
88836: PUSH
88837: LD_INT 1
88839: ST_TO_ADDR
// if p3 = 116 then
88840: LD_VAR 0 3
88844: PUSH
88845: LD_INT 116
88847: EQUAL
88848: IFFALSE 88858
// sComputer := true ;
88850: LD_ADDR_EXP 161
88854: PUSH
88855: LD_INT 1
88857: ST_TO_ADDR
// if p3 = 117 then
88858: LD_VAR 0 3
88862: PUSH
88863: LD_INT 117
88865: EQUAL
88866: IFFALSE 88876
// s30 := true ;
88868: LD_ADDR_EXP 162
88872: PUSH
88873: LD_INT 1
88875: ST_TO_ADDR
// if p3 = 118 then
88876: LD_VAR 0 3
88880: PUSH
88881: LD_INT 118
88883: EQUAL
88884: IFFALSE 88894
// s60 := true ;
88886: LD_ADDR_EXP 163
88890: PUSH
88891: LD_INT 1
88893: ST_TO_ADDR
// end ; if p2 = hack_mode then
88894: LD_VAR 0 2
88898: PUSH
88899: LD_INT 101
88901: EQUAL
88902: IFFALSE 89030
// begin case p3 of 1 :
88904: LD_VAR 0 3
88908: PUSH
88909: LD_INT 1
88911: DOUBLE
88912: EQUAL
88913: IFTRUE 88917
88915: GO 88924
88917: POP
// hHackUnlimitedResources ; 2 :
88918: CALL 101177 0 0
88922: GO 89030
88924: LD_INT 2
88926: DOUBLE
88927: EQUAL
88928: IFTRUE 88932
88930: GO 88939
88932: POP
// hHackSetLevel10 ; 3 :
88933: CALL 101310 0 0
88937: GO 89030
88939: LD_INT 3
88941: DOUBLE
88942: EQUAL
88943: IFTRUE 88947
88945: GO 88954
88947: POP
// hHackSetLevel10YourUnits ; 4 :
88948: CALL 101395 0 0
88952: GO 89030
88954: LD_INT 4
88956: DOUBLE
88957: EQUAL
88958: IFTRUE 88962
88960: GO 88969
88962: POP
// hHackInvincible ; 5 :
88963: CALL 101843 0 0
88967: GO 89030
88969: LD_INT 5
88971: DOUBLE
88972: EQUAL
88973: IFTRUE 88977
88975: GO 88984
88977: POP
// hHackInvisible ; 6 :
88978: CALL 101954 0 0
88982: GO 89030
88984: LD_INT 6
88986: DOUBLE
88987: EQUAL
88988: IFTRUE 88992
88990: GO 88999
88992: POP
// hHackChangeYourSide ; 7 :
88993: CALL 102011 0 0
88997: GO 89030
88999: LD_INT 7
89001: DOUBLE
89002: EQUAL
89003: IFTRUE 89007
89005: GO 89014
89007: POP
// hHackChangeUnitSide ; 8 :
89008: CALL 102053 0 0
89012: GO 89030
89014: LD_INT 8
89016: DOUBLE
89017: EQUAL
89018: IFTRUE 89022
89020: GO 89029
89022: POP
// hHackFog ; end ;
89023: CALL 102154 0 0
89027: GO 89030
89029: POP
// end ; if p2 = game_save_mode then
89030: LD_VAR 0 2
89034: PUSH
89035: LD_INT 102
89037: EQUAL
89038: IFFALSE 89093
// begin if p3 = 1 then
89040: LD_VAR 0 3
89044: PUSH
89045: LD_INT 1
89047: EQUAL
89048: IFFALSE 89060
// globalGameSaveCounter := p4 ;
89050: LD_ADDR_EXP 106
89054: PUSH
89055: LD_VAR 0 4
89059: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
89060: LD_VAR 0 3
89064: PUSH
89065: LD_INT 2
89067: EQUAL
89068: PUSH
89069: LD_EXP 106
89073: AND
89074: IFFALSE 89093
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
89076: LD_STRING setGameSaveCounter(
89078: PUSH
89079: LD_EXP 106
89083: STR
89084: PUSH
89085: LD_STRING )
89087: STR
89088: PPUSH
89089: CALL_OW 559
// end ; end ;
89093: LD_VAR 0 7
89097: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
89098: LD_INT 0
89100: PPUSH
// streamModeActive := false ;
89101: LD_ADDR_EXP 107
89105: PUSH
89106: LD_INT 0
89108: ST_TO_ADDR
// normalCounter := 36 ;
89109: LD_ADDR_EXP 108
89113: PUSH
89114: LD_INT 36
89116: ST_TO_ADDR
// hardcoreCounter := 18 ;
89117: LD_ADDR_EXP 109
89121: PUSH
89122: LD_INT 18
89124: ST_TO_ADDR
// sRocket := false ;
89125: LD_ADDR_EXP 112
89129: PUSH
89130: LD_INT 0
89132: ST_TO_ADDR
// sSpeed := false ;
89133: LD_ADDR_EXP 111
89137: PUSH
89138: LD_INT 0
89140: ST_TO_ADDR
// sEngine := false ;
89141: LD_ADDR_EXP 113
89145: PUSH
89146: LD_INT 0
89148: ST_TO_ADDR
// sSpec := false ;
89149: LD_ADDR_EXP 110
89153: PUSH
89154: LD_INT 0
89156: ST_TO_ADDR
// sLevel := false ;
89157: LD_ADDR_EXP 114
89161: PUSH
89162: LD_INT 0
89164: ST_TO_ADDR
// sArmoury := false ;
89165: LD_ADDR_EXP 115
89169: PUSH
89170: LD_INT 0
89172: ST_TO_ADDR
// sRadar := false ;
89173: LD_ADDR_EXP 116
89177: PUSH
89178: LD_INT 0
89180: ST_TO_ADDR
// sBunker := false ;
89181: LD_ADDR_EXP 117
89185: PUSH
89186: LD_INT 0
89188: ST_TO_ADDR
// sHack := false ;
89189: LD_ADDR_EXP 118
89193: PUSH
89194: LD_INT 0
89196: ST_TO_ADDR
// sFire := false ;
89197: LD_ADDR_EXP 119
89201: PUSH
89202: LD_INT 0
89204: ST_TO_ADDR
// sRefresh := false ;
89205: LD_ADDR_EXP 120
89209: PUSH
89210: LD_INT 0
89212: ST_TO_ADDR
// sExp := false ;
89213: LD_ADDR_EXP 121
89217: PUSH
89218: LD_INT 0
89220: ST_TO_ADDR
// sDepot := false ;
89221: LD_ADDR_EXP 122
89225: PUSH
89226: LD_INT 0
89228: ST_TO_ADDR
// sFlag := false ;
89229: LD_ADDR_EXP 123
89233: PUSH
89234: LD_INT 0
89236: ST_TO_ADDR
// sKamikadze := false ;
89237: LD_ADDR_EXP 131
89241: PUSH
89242: LD_INT 0
89244: ST_TO_ADDR
// sTroll := false ;
89245: LD_ADDR_EXP 132
89249: PUSH
89250: LD_INT 0
89252: ST_TO_ADDR
// sSlow := false ;
89253: LD_ADDR_EXP 133
89257: PUSH
89258: LD_INT 0
89260: ST_TO_ADDR
// sLack := false ;
89261: LD_ADDR_EXP 134
89265: PUSH
89266: LD_INT 0
89268: ST_TO_ADDR
// sTank := false ;
89269: LD_ADDR_EXP 136
89273: PUSH
89274: LD_INT 0
89276: ST_TO_ADDR
// sRemote := false ;
89277: LD_ADDR_EXP 137
89281: PUSH
89282: LD_INT 0
89284: ST_TO_ADDR
// sPowell := false ;
89285: LD_ADDR_EXP 138
89289: PUSH
89290: LD_INT 0
89292: ST_TO_ADDR
// sTeleport := false ;
89293: LD_ADDR_EXP 141
89297: PUSH
89298: LD_INT 0
89300: ST_TO_ADDR
// sOilTower := false ;
89301: LD_ADDR_EXP 143
89305: PUSH
89306: LD_INT 0
89308: ST_TO_ADDR
// sShovel := false ;
89309: LD_ADDR_EXP 144
89313: PUSH
89314: LD_INT 0
89316: ST_TO_ADDR
// sSheik := false ;
89317: LD_ADDR_EXP 145
89321: PUSH
89322: LD_INT 0
89324: ST_TO_ADDR
// sEarthquake := false ;
89325: LD_ADDR_EXP 147
89329: PUSH
89330: LD_INT 0
89332: ST_TO_ADDR
// sAI := false ;
89333: LD_ADDR_EXP 148
89337: PUSH
89338: LD_INT 0
89340: ST_TO_ADDR
// sCargo := false ;
89341: LD_ADDR_EXP 151
89345: PUSH
89346: LD_INT 0
89348: ST_TO_ADDR
// sDLaser := false ;
89349: LD_ADDR_EXP 152
89353: PUSH
89354: LD_INT 0
89356: ST_TO_ADDR
// sExchange := false ;
89357: LD_ADDR_EXP 153
89361: PUSH
89362: LD_INT 0
89364: ST_TO_ADDR
// sFac := false ;
89365: LD_ADDR_EXP 154
89369: PUSH
89370: LD_INT 0
89372: ST_TO_ADDR
// sPower := false ;
89373: LD_ADDR_EXP 155
89377: PUSH
89378: LD_INT 0
89380: ST_TO_ADDR
// sRandom := false ;
89381: LD_ADDR_EXP 156
89385: PUSH
89386: LD_INT 0
89388: ST_TO_ADDR
// sShield := false ;
89389: LD_ADDR_EXP 157
89393: PUSH
89394: LD_INT 0
89396: ST_TO_ADDR
// sTime := false ;
89397: LD_ADDR_EXP 158
89401: PUSH
89402: LD_INT 0
89404: ST_TO_ADDR
// sTools := false ;
89405: LD_ADDR_EXP 159
89409: PUSH
89410: LD_INT 0
89412: ST_TO_ADDR
// sSold := false ;
89413: LD_ADDR_EXP 124
89417: PUSH
89418: LD_INT 0
89420: ST_TO_ADDR
// sDiff := false ;
89421: LD_ADDR_EXP 125
89425: PUSH
89426: LD_INT 0
89428: ST_TO_ADDR
// sFog := false ;
89429: LD_ADDR_EXP 128
89433: PUSH
89434: LD_INT 0
89436: ST_TO_ADDR
// sReset := false ;
89437: LD_ADDR_EXP 129
89441: PUSH
89442: LD_INT 0
89444: ST_TO_ADDR
// sSun := false ;
89445: LD_ADDR_EXP 130
89449: PUSH
89450: LD_INT 0
89452: ST_TO_ADDR
// sTiger := false ;
89453: LD_ADDR_EXP 126
89457: PUSH
89458: LD_INT 0
89460: ST_TO_ADDR
// sBomb := false ;
89461: LD_ADDR_EXP 127
89465: PUSH
89466: LD_INT 0
89468: ST_TO_ADDR
// sWound := false ;
89469: LD_ADDR_EXP 135
89473: PUSH
89474: LD_INT 0
89476: ST_TO_ADDR
// sBetray := false ;
89477: LD_ADDR_EXP 139
89481: PUSH
89482: LD_INT 0
89484: ST_TO_ADDR
// sContamin := false ;
89485: LD_ADDR_EXP 140
89489: PUSH
89490: LD_INT 0
89492: ST_TO_ADDR
// sOil := false ;
89493: LD_ADDR_EXP 142
89497: PUSH
89498: LD_INT 0
89500: ST_TO_ADDR
// sStu := false ;
89501: LD_ADDR_EXP 146
89505: PUSH
89506: LD_INT 0
89508: ST_TO_ADDR
// sBazooka := false ;
89509: LD_ADDR_EXP 149
89513: PUSH
89514: LD_INT 0
89516: ST_TO_ADDR
// sMortar := false ;
89517: LD_ADDR_EXP 150
89521: PUSH
89522: LD_INT 0
89524: ST_TO_ADDR
// sRanger := false ;
89525: LD_ADDR_EXP 160
89529: PUSH
89530: LD_INT 0
89532: ST_TO_ADDR
// sComputer := false ;
89533: LD_ADDR_EXP 161
89537: PUSH
89538: LD_INT 0
89540: ST_TO_ADDR
// s30 := false ;
89541: LD_ADDR_EXP 162
89545: PUSH
89546: LD_INT 0
89548: ST_TO_ADDR
// s60 := false ;
89549: LD_ADDR_EXP 163
89553: PUSH
89554: LD_INT 0
89556: ST_TO_ADDR
// end ;
89557: LD_VAR 0 1
89561: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
89562: LD_INT 0
89564: PPUSH
89565: PPUSH
89566: PPUSH
89567: PPUSH
89568: PPUSH
89569: PPUSH
89570: PPUSH
// result := [ ] ;
89571: LD_ADDR_VAR 0 2
89575: PUSH
89576: EMPTY
89577: ST_TO_ADDR
// if campaign_id = 1 then
89578: LD_OWVAR 69
89582: PUSH
89583: LD_INT 1
89585: EQUAL
89586: IFFALSE 92752
// begin case mission_number of 1 :
89588: LD_OWVAR 70
89592: PUSH
89593: LD_INT 1
89595: DOUBLE
89596: EQUAL
89597: IFTRUE 89601
89599: GO 89677
89601: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
89602: LD_ADDR_VAR 0 2
89606: PUSH
89607: LD_INT 2
89609: PUSH
89610: LD_INT 4
89612: PUSH
89613: LD_INT 11
89615: PUSH
89616: LD_INT 12
89618: PUSH
89619: LD_INT 15
89621: PUSH
89622: LD_INT 16
89624: PUSH
89625: LD_INT 22
89627: PUSH
89628: LD_INT 23
89630: PUSH
89631: LD_INT 26
89633: PUSH
89634: EMPTY
89635: LIST
89636: LIST
89637: LIST
89638: LIST
89639: LIST
89640: LIST
89641: LIST
89642: LIST
89643: LIST
89644: PUSH
89645: LD_INT 101
89647: PUSH
89648: LD_INT 102
89650: PUSH
89651: LD_INT 106
89653: PUSH
89654: LD_INT 116
89656: PUSH
89657: LD_INT 117
89659: PUSH
89660: LD_INT 118
89662: PUSH
89663: EMPTY
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: PUSH
89671: EMPTY
89672: LIST
89673: LIST
89674: ST_TO_ADDR
89675: GO 92750
89677: LD_INT 2
89679: DOUBLE
89680: EQUAL
89681: IFTRUE 89685
89683: GO 89769
89685: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
89686: LD_ADDR_VAR 0 2
89690: PUSH
89691: LD_INT 2
89693: PUSH
89694: LD_INT 4
89696: PUSH
89697: LD_INT 11
89699: PUSH
89700: LD_INT 12
89702: PUSH
89703: LD_INT 15
89705: PUSH
89706: LD_INT 16
89708: PUSH
89709: LD_INT 22
89711: PUSH
89712: LD_INT 23
89714: PUSH
89715: LD_INT 26
89717: PUSH
89718: EMPTY
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: PUSH
89729: LD_INT 101
89731: PUSH
89732: LD_INT 102
89734: PUSH
89735: LD_INT 105
89737: PUSH
89738: LD_INT 106
89740: PUSH
89741: LD_INT 108
89743: PUSH
89744: LD_INT 116
89746: PUSH
89747: LD_INT 117
89749: PUSH
89750: LD_INT 118
89752: PUSH
89753: EMPTY
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: LIST
89761: LIST
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: ST_TO_ADDR
89767: GO 92750
89769: LD_INT 3
89771: DOUBLE
89772: EQUAL
89773: IFTRUE 89777
89775: GO 89865
89777: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
89778: LD_ADDR_VAR 0 2
89782: PUSH
89783: LD_INT 2
89785: PUSH
89786: LD_INT 4
89788: PUSH
89789: LD_INT 5
89791: PUSH
89792: LD_INT 11
89794: PUSH
89795: LD_INT 12
89797: PUSH
89798: LD_INT 15
89800: PUSH
89801: LD_INT 16
89803: PUSH
89804: LD_INT 22
89806: PUSH
89807: LD_INT 26
89809: PUSH
89810: LD_INT 36
89812: PUSH
89813: EMPTY
89814: LIST
89815: LIST
89816: LIST
89817: LIST
89818: LIST
89819: LIST
89820: LIST
89821: LIST
89822: LIST
89823: LIST
89824: PUSH
89825: LD_INT 101
89827: PUSH
89828: LD_INT 102
89830: PUSH
89831: LD_INT 105
89833: PUSH
89834: LD_INT 106
89836: PUSH
89837: LD_INT 108
89839: PUSH
89840: LD_INT 116
89842: PUSH
89843: LD_INT 117
89845: PUSH
89846: LD_INT 118
89848: PUSH
89849: EMPTY
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: PUSH
89859: EMPTY
89860: LIST
89861: LIST
89862: ST_TO_ADDR
89863: GO 92750
89865: LD_INT 4
89867: DOUBLE
89868: EQUAL
89869: IFTRUE 89873
89871: GO 89969
89873: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
89874: LD_ADDR_VAR 0 2
89878: PUSH
89879: LD_INT 2
89881: PUSH
89882: LD_INT 4
89884: PUSH
89885: LD_INT 5
89887: PUSH
89888: LD_INT 8
89890: PUSH
89891: LD_INT 11
89893: PUSH
89894: LD_INT 12
89896: PUSH
89897: LD_INT 15
89899: PUSH
89900: LD_INT 16
89902: PUSH
89903: LD_INT 22
89905: PUSH
89906: LD_INT 23
89908: PUSH
89909: LD_INT 26
89911: PUSH
89912: LD_INT 36
89914: PUSH
89915: EMPTY
89916: LIST
89917: LIST
89918: LIST
89919: LIST
89920: LIST
89921: LIST
89922: LIST
89923: LIST
89924: LIST
89925: LIST
89926: LIST
89927: LIST
89928: PUSH
89929: LD_INT 101
89931: PUSH
89932: LD_INT 102
89934: PUSH
89935: LD_INT 105
89937: PUSH
89938: LD_INT 106
89940: PUSH
89941: LD_INT 108
89943: PUSH
89944: LD_INT 116
89946: PUSH
89947: LD_INT 117
89949: PUSH
89950: LD_INT 118
89952: PUSH
89953: EMPTY
89954: LIST
89955: LIST
89956: LIST
89957: LIST
89958: LIST
89959: LIST
89960: LIST
89961: LIST
89962: PUSH
89963: EMPTY
89964: LIST
89965: LIST
89966: ST_TO_ADDR
89967: GO 92750
89969: LD_INT 5
89971: DOUBLE
89972: EQUAL
89973: IFTRUE 89977
89975: GO 90089
89977: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
89978: LD_ADDR_VAR 0 2
89982: PUSH
89983: LD_INT 2
89985: PUSH
89986: LD_INT 4
89988: PUSH
89989: LD_INT 5
89991: PUSH
89992: LD_INT 6
89994: PUSH
89995: LD_INT 8
89997: PUSH
89998: LD_INT 11
90000: PUSH
90001: LD_INT 12
90003: PUSH
90004: LD_INT 15
90006: PUSH
90007: LD_INT 16
90009: PUSH
90010: LD_INT 22
90012: PUSH
90013: LD_INT 23
90015: PUSH
90016: LD_INT 25
90018: PUSH
90019: LD_INT 26
90021: PUSH
90022: LD_INT 36
90024: PUSH
90025: EMPTY
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: PUSH
90041: LD_INT 101
90043: PUSH
90044: LD_INT 102
90046: PUSH
90047: LD_INT 105
90049: PUSH
90050: LD_INT 106
90052: PUSH
90053: LD_INT 108
90055: PUSH
90056: LD_INT 109
90058: PUSH
90059: LD_INT 112
90061: PUSH
90062: LD_INT 116
90064: PUSH
90065: LD_INT 117
90067: PUSH
90068: LD_INT 118
90070: PUSH
90071: EMPTY
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: PUSH
90083: EMPTY
90084: LIST
90085: LIST
90086: ST_TO_ADDR
90087: GO 92750
90089: LD_INT 6
90091: DOUBLE
90092: EQUAL
90093: IFTRUE 90097
90095: GO 90229
90097: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
90098: LD_ADDR_VAR 0 2
90102: PUSH
90103: LD_INT 2
90105: PUSH
90106: LD_INT 4
90108: PUSH
90109: LD_INT 5
90111: PUSH
90112: LD_INT 6
90114: PUSH
90115: LD_INT 8
90117: PUSH
90118: LD_INT 11
90120: PUSH
90121: LD_INT 12
90123: PUSH
90124: LD_INT 15
90126: PUSH
90127: LD_INT 16
90129: PUSH
90130: LD_INT 20
90132: PUSH
90133: LD_INT 21
90135: PUSH
90136: LD_INT 22
90138: PUSH
90139: LD_INT 23
90141: PUSH
90142: LD_INT 25
90144: PUSH
90145: LD_INT 26
90147: PUSH
90148: LD_INT 30
90150: PUSH
90151: LD_INT 31
90153: PUSH
90154: LD_INT 32
90156: PUSH
90157: LD_INT 36
90159: PUSH
90160: EMPTY
90161: LIST
90162: LIST
90163: LIST
90164: LIST
90165: LIST
90166: LIST
90167: LIST
90168: LIST
90169: LIST
90170: LIST
90171: LIST
90172: LIST
90173: LIST
90174: LIST
90175: LIST
90176: LIST
90177: LIST
90178: LIST
90179: LIST
90180: PUSH
90181: LD_INT 101
90183: PUSH
90184: LD_INT 102
90186: PUSH
90187: LD_INT 105
90189: PUSH
90190: LD_INT 106
90192: PUSH
90193: LD_INT 108
90195: PUSH
90196: LD_INT 109
90198: PUSH
90199: LD_INT 112
90201: PUSH
90202: LD_INT 116
90204: PUSH
90205: LD_INT 117
90207: PUSH
90208: LD_INT 118
90210: PUSH
90211: EMPTY
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: PUSH
90223: EMPTY
90224: LIST
90225: LIST
90226: ST_TO_ADDR
90227: GO 92750
90229: LD_INT 7
90231: DOUBLE
90232: EQUAL
90233: IFTRUE 90237
90235: GO 90349
90237: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
90238: LD_ADDR_VAR 0 2
90242: PUSH
90243: LD_INT 2
90245: PUSH
90246: LD_INT 4
90248: PUSH
90249: LD_INT 5
90251: PUSH
90252: LD_INT 7
90254: PUSH
90255: LD_INT 11
90257: PUSH
90258: LD_INT 12
90260: PUSH
90261: LD_INT 15
90263: PUSH
90264: LD_INT 16
90266: PUSH
90267: LD_INT 20
90269: PUSH
90270: LD_INT 21
90272: PUSH
90273: LD_INT 22
90275: PUSH
90276: LD_INT 23
90278: PUSH
90279: LD_INT 25
90281: PUSH
90282: LD_INT 26
90284: PUSH
90285: EMPTY
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: PUSH
90301: LD_INT 101
90303: PUSH
90304: LD_INT 102
90306: PUSH
90307: LD_INT 103
90309: PUSH
90310: LD_INT 105
90312: PUSH
90313: LD_INT 106
90315: PUSH
90316: LD_INT 108
90318: PUSH
90319: LD_INT 112
90321: PUSH
90322: LD_INT 116
90324: PUSH
90325: LD_INT 117
90327: PUSH
90328: LD_INT 118
90330: PUSH
90331: EMPTY
90332: LIST
90333: LIST
90334: LIST
90335: LIST
90336: LIST
90337: LIST
90338: LIST
90339: LIST
90340: LIST
90341: LIST
90342: PUSH
90343: EMPTY
90344: LIST
90345: LIST
90346: ST_TO_ADDR
90347: GO 92750
90349: LD_INT 8
90351: DOUBLE
90352: EQUAL
90353: IFTRUE 90357
90355: GO 90497
90357: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
90358: LD_ADDR_VAR 0 2
90362: PUSH
90363: LD_INT 2
90365: PUSH
90366: LD_INT 4
90368: PUSH
90369: LD_INT 5
90371: PUSH
90372: LD_INT 6
90374: PUSH
90375: LD_INT 7
90377: PUSH
90378: LD_INT 8
90380: PUSH
90381: LD_INT 11
90383: PUSH
90384: LD_INT 12
90386: PUSH
90387: LD_INT 15
90389: PUSH
90390: LD_INT 16
90392: PUSH
90393: LD_INT 20
90395: PUSH
90396: LD_INT 21
90398: PUSH
90399: LD_INT 22
90401: PUSH
90402: LD_INT 23
90404: PUSH
90405: LD_INT 25
90407: PUSH
90408: LD_INT 26
90410: PUSH
90411: LD_INT 30
90413: PUSH
90414: LD_INT 31
90416: PUSH
90417: LD_INT 32
90419: PUSH
90420: LD_INT 36
90422: PUSH
90423: EMPTY
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: PUSH
90445: LD_INT 101
90447: PUSH
90448: LD_INT 102
90450: PUSH
90451: LD_INT 103
90453: PUSH
90454: LD_INT 105
90456: PUSH
90457: LD_INT 106
90459: PUSH
90460: LD_INT 108
90462: PUSH
90463: LD_INT 109
90465: PUSH
90466: LD_INT 112
90468: PUSH
90469: LD_INT 116
90471: PUSH
90472: LD_INT 117
90474: PUSH
90475: LD_INT 118
90477: PUSH
90478: EMPTY
90479: LIST
90480: LIST
90481: LIST
90482: LIST
90483: LIST
90484: LIST
90485: LIST
90486: LIST
90487: LIST
90488: LIST
90489: LIST
90490: PUSH
90491: EMPTY
90492: LIST
90493: LIST
90494: ST_TO_ADDR
90495: GO 92750
90497: LD_INT 9
90499: DOUBLE
90500: EQUAL
90501: IFTRUE 90505
90503: GO 90653
90505: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
90506: LD_ADDR_VAR 0 2
90510: PUSH
90511: LD_INT 2
90513: PUSH
90514: LD_INT 4
90516: PUSH
90517: LD_INT 5
90519: PUSH
90520: LD_INT 6
90522: PUSH
90523: LD_INT 7
90525: PUSH
90526: LD_INT 8
90528: PUSH
90529: LD_INT 11
90531: PUSH
90532: LD_INT 12
90534: PUSH
90535: LD_INT 15
90537: PUSH
90538: LD_INT 16
90540: PUSH
90541: LD_INT 20
90543: PUSH
90544: LD_INT 21
90546: PUSH
90547: LD_INT 22
90549: PUSH
90550: LD_INT 23
90552: PUSH
90553: LD_INT 25
90555: PUSH
90556: LD_INT 26
90558: PUSH
90559: LD_INT 28
90561: PUSH
90562: LD_INT 30
90564: PUSH
90565: LD_INT 31
90567: PUSH
90568: LD_INT 32
90570: PUSH
90571: LD_INT 36
90573: PUSH
90574: EMPTY
90575: LIST
90576: LIST
90577: LIST
90578: LIST
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: LIST
90594: LIST
90595: LIST
90596: PUSH
90597: LD_INT 101
90599: PUSH
90600: LD_INT 102
90602: PUSH
90603: LD_INT 103
90605: PUSH
90606: LD_INT 105
90608: PUSH
90609: LD_INT 106
90611: PUSH
90612: LD_INT 108
90614: PUSH
90615: LD_INT 109
90617: PUSH
90618: LD_INT 112
90620: PUSH
90621: LD_INT 114
90623: PUSH
90624: LD_INT 116
90626: PUSH
90627: LD_INT 117
90629: PUSH
90630: LD_INT 118
90632: PUSH
90633: EMPTY
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: PUSH
90647: EMPTY
90648: LIST
90649: LIST
90650: ST_TO_ADDR
90651: GO 92750
90653: LD_INT 10
90655: DOUBLE
90656: EQUAL
90657: IFTRUE 90661
90659: GO 90857
90661: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
90662: LD_ADDR_VAR 0 2
90666: PUSH
90667: LD_INT 2
90669: PUSH
90670: LD_INT 4
90672: PUSH
90673: LD_INT 5
90675: PUSH
90676: LD_INT 6
90678: PUSH
90679: LD_INT 7
90681: PUSH
90682: LD_INT 8
90684: PUSH
90685: LD_INT 9
90687: PUSH
90688: LD_INT 10
90690: PUSH
90691: LD_INT 11
90693: PUSH
90694: LD_INT 12
90696: PUSH
90697: LD_INT 13
90699: PUSH
90700: LD_INT 14
90702: PUSH
90703: LD_INT 15
90705: PUSH
90706: LD_INT 16
90708: PUSH
90709: LD_INT 17
90711: PUSH
90712: LD_INT 18
90714: PUSH
90715: LD_INT 19
90717: PUSH
90718: LD_INT 20
90720: PUSH
90721: LD_INT 21
90723: PUSH
90724: LD_INT 22
90726: PUSH
90727: LD_INT 23
90729: PUSH
90730: LD_INT 24
90732: PUSH
90733: LD_INT 25
90735: PUSH
90736: LD_INT 26
90738: PUSH
90739: LD_INT 28
90741: PUSH
90742: LD_INT 30
90744: PUSH
90745: LD_INT 31
90747: PUSH
90748: LD_INT 32
90750: PUSH
90751: LD_INT 36
90753: PUSH
90754: EMPTY
90755: LIST
90756: LIST
90757: LIST
90758: LIST
90759: LIST
90760: LIST
90761: LIST
90762: LIST
90763: LIST
90764: LIST
90765: LIST
90766: LIST
90767: LIST
90768: LIST
90769: LIST
90770: LIST
90771: LIST
90772: LIST
90773: LIST
90774: LIST
90775: LIST
90776: LIST
90777: LIST
90778: LIST
90779: LIST
90780: LIST
90781: LIST
90782: LIST
90783: LIST
90784: PUSH
90785: LD_INT 101
90787: PUSH
90788: LD_INT 102
90790: PUSH
90791: LD_INT 103
90793: PUSH
90794: LD_INT 104
90796: PUSH
90797: LD_INT 105
90799: PUSH
90800: LD_INT 106
90802: PUSH
90803: LD_INT 107
90805: PUSH
90806: LD_INT 108
90808: PUSH
90809: LD_INT 109
90811: PUSH
90812: LD_INT 110
90814: PUSH
90815: LD_INT 111
90817: PUSH
90818: LD_INT 112
90820: PUSH
90821: LD_INT 114
90823: PUSH
90824: LD_INT 116
90826: PUSH
90827: LD_INT 117
90829: PUSH
90830: LD_INT 118
90832: PUSH
90833: EMPTY
90834: LIST
90835: LIST
90836: LIST
90837: LIST
90838: LIST
90839: LIST
90840: LIST
90841: LIST
90842: LIST
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: ST_TO_ADDR
90855: GO 92750
90857: LD_INT 11
90859: DOUBLE
90860: EQUAL
90861: IFTRUE 90865
90863: GO 91069
90865: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
90866: LD_ADDR_VAR 0 2
90870: PUSH
90871: LD_INT 2
90873: PUSH
90874: LD_INT 3
90876: PUSH
90877: LD_INT 4
90879: PUSH
90880: LD_INT 5
90882: PUSH
90883: LD_INT 6
90885: PUSH
90886: LD_INT 7
90888: PUSH
90889: LD_INT 8
90891: PUSH
90892: LD_INT 9
90894: PUSH
90895: LD_INT 10
90897: PUSH
90898: LD_INT 11
90900: PUSH
90901: LD_INT 12
90903: PUSH
90904: LD_INT 13
90906: PUSH
90907: LD_INT 14
90909: PUSH
90910: LD_INT 15
90912: PUSH
90913: LD_INT 16
90915: PUSH
90916: LD_INT 17
90918: PUSH
90919: LD_INT 18
90921: PUSH
90922: LD_INT 19
90924: PUSH
90925: LD_INT 20
90927: PUSH
90928: LD_INT 21
90930: PUSH
90931: LD_INT 22
90933: PUSH
90934: LD_INT 23
90936: PUSH
90937: LD_INT 24
90939: PUSH
90940: LD_INT 25
90942: PUSH
90943: LD_INT 26
90945: PUSH
90946: LD_INT 28
90948: PUSH
90949: LD_INT 30
90951: PUSH
90952: LD_INT 31
90954: PUSH
90955: LD_INT 32
90957: PUSH
90958: LD_INT 34
90960: PUSH
90961: LD_INT 36
90963: PUSH
90964: EMPTY
90965: LIST
90966: LIST
90967: LIST
90968: LIST
90969: LIST
90970: LIST
90971: LIST
90972: LIST
90973: LIST
90974: LIST
90975: LIST
90976: LIST
90977: LIST
90978: LIST
90979: LIST
90980: LIST
90981: LIST
90982: LIST
90983: LIST
90984: LIST
90985: LIST
90986: LIST
90987: LIST
90988: LIST
90989: LIST
90990: LIST
90991: LIST
90992: LIST
90993: LIST
90994: LIST
90995: LIST
90996: PUSH
90997: LD_INT 101
90999: PUSH
91000: LD_INT 102
91002: PUSH
91003: LD_INT 103
91005: PUSH
91006: LD_INT 104
91008: PUSH
91009: LD_INT 105
91011: PUSH
91012: LD_INT 106
91014: PUSH
91015: LD_INT 107
91017: PUSH
91018: LD_INT 108
91020: PUSH
91021: LD_INT 109
91023: PUSH
91024: LD_INT 110
91026: PUSH
91027: LD_INT 111
91029: PUSH
91030: LD_INT 112
91032: PUSH
91033: LD_INT 114
91035: PUSH
91036: LD_INT 116
91038: PUSH
91039: LD_INT 117
91041: PUSH
91042: LD_INT 118
91044: PUSH
91045: EMPTY
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: LIST
91052: LIST
91053: LIST
91054: LIST
91055: LIST
91056: LIST
91057: LIST
91058: LIST
91059: LIST
91060: LIST
91061: LIST
91062: PUSH
91063: EMPTY
91064: LIST
91065: LIST
91066: ST_TO_ADDR
91067: GO 92750
91069: LD_INT 12
91071: DOUBLE
91072: EQUAL
91073: IFTRUE 91077
91075: GO 91297
91077: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
91078: LD_ADDR_VAR 0 2
91082: PUSH
91083: LD_INT 1
91085: PUSH
91086: LD_INT 2
91088: PUSH
91089: LD_INT 3
91091: PUSH
91092: LD_INT 4
91094: PUSH
91095: LD_INT 5
91097: PUSH
91098: LD_INT 6
91100: PUSH
91101: LD_INT 7
91103: PUSH
91104: LD_INT 8
91106: PUSH
91107: LD_INT 9
91109: PUSH
91110: LD_INT 10
91112: PUSH
91113: LD_INT 11
91115: PUSH
91116: LD_INT 12
91118: PUSH
91119: LD_INT 13
91121: PUSH
91122: LD_INT 14
91124: PUSH
91125: LD_INT 15
91127: PUSH
91128: LD_INT 16
91130: PUSH
91131: LD_INT 17
91133: PUSH
91134: LD_INT 18
91136: PUSH
91137: LD_INT 19
91139: PUSH
91140: LD_INT 20
91142: PUSH
91143: LD_INT 21
91145: PUSH
91146: LD_INT 22
91148: PUSH
91149: LD_INT 23
91151: PUSH
91152: LD_INT 24
91154: PUSH
91155: LD_INT 25
91157: PUSH
91158: LD_INT 26
91160: PUSH
91161: LD_INT 27
91163: PUSH
91164: LD_INT 28
91166: PUSH
91167: LD_INT 30
91169: PUSH
91170: LD_INT 31
91172: PUSH
91173: LD_INT 32
91175: PUSH
91176: LD_INT 33
91178: PUSH
91179: LD_INT 34
91181: PUSH
91182: LD_INT 36
91184: PUSH
91185: EMPTY
91186: LIST
91187: LIST
91188: LIST
91189: LIST
91190: LIST
91191: LIST
91192: LIST
91193: LIST
91194: LIST
91195: LIST
91196: LIST
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: LIST
91202: LIST
91203: LIST
91204: LIST
91205: LIST
91206: LIST
91207: LIST
91208: LIST
91209: LIST
91210: LIST
91211: LIST
91212: LIST
91213: LIST
91214: LIST
91215: LIST
91216: LIST
91217: LIST
91218: LIST
91219: LIST
91220: PUSH
91221: LD_INT 101
91223: PUSH
91224: LD_INT 102
91226: PUSH
91227: LD_INT 103
91229: PUSH
91230: LD_INT 104
91232: PUSH
91233: LD_INT 105
91235: PUSH
91236: LD_INT 106
91238: PUSH
91239: LD_INT 107
91241: PUSH
91242: LD_INT 108
91244: PUSH
91245: LD_INT 109
91247: PUSH
91248: LD_INT 110
91250: PUSH
91251: LD_INT 111
91253: PUSH
91254: LD_INT 112
91256: PUSH
91257: LD_INT 113
91259: PUSH
91260: LD_INT 114
91262: PUSH
91263: LD_INT 116
91265: PUSH
91266: LD_INT 117
91268: PUSH
91269: LD_INT 118
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: LIST
91276: LIST
91277: LIST
91278: LIST
91279: LIST
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: LIST
91289: LIST
91290: PUSH
91291: EMPTY
91292: LIST
91293: LIST
91294: ST_TO_ADDR
91295: GO 92750
91297: LD_INT 13
91299: DOUBLE
91300: EQUAL
91301: IFTRUE 91305
91303: GO 91513
91305: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
91306: LD_ADDR_VAR 0 2
91310: PUSH
91311: LD_INT 1
91313: PUSH
91314: LD_INT 2
91316: PUSH
91317: LD_INT 3
91319: PUSH
91320: LD_INT 4
91322: PUSH
91323: LD_INT 5
91325: PUSH
91326: LD_INT 8
91328: PUSH
91329: LD_INT 9
91331: PUSH
91332: LD_INT 10
91334: PUSH
91335: LD_INT 11
91337: PUSH
91338: LD_INT 12
91340: PUSH
91341: LD_INT 14
91343: PUSH
91344: LD_INT 15
91346: PUSH
91347: LD_INT 16
91349: PUSH
91350: LD_INT 17
91352: PUSH
91353: LD_INT 18
91355: PUSH
91356: LD_INT 19
91358: PUSH
91359: LD_INT 20
91361: PUSH
91362: LD_INT 21
91364: PUSH
91365: LD_INT 22
91367: PUSH
91368: LD_INT 23
91370: PUSH
91371: LD_INT 24
91373: PUSH
91374: LD_INT 25
91376: PUSH
91377: LD_INT 26
91379: PUSH
91380: LD_INT 27
91382: PUSH
91383: LD_INT 28
91385: PUSH
91386: LD_INT 30
91388: PUSH
91389: LD_INT 31
91391: PUSH
91392: LD_INT 32
91394: PUSH
91395: LD_INT 33
91397: PUSH
91398: LD_INT 34
91400: PUSH
91401: LD_INT 36
91403: PUSH
91404: EMPTY
91405: LIST
91406: LIST
91407: LIST
91408: LIST
91409: LIST
91410: LIST
91411: LIST
91412: LIST
91413: LIST
91414: LIST
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: PUSH
91437: LD_INT 101
91439: PUSH
91440: LD_INT 102
91442: PUSH
91443: LD_INT 103
91445: PUSH
91446: LD_INT 104
91448: PUSH
91449: LD_INT 105
91451: PUSH
91452: LD_INT 106
91454: PUSH
91455: LD_INT 107
91457: PUSH
91458: LD_INT 108
91460: PUSH
91461: LD_INT 109
91463: PUSH
91464: LD_INT 110
91466: PUSH
91467: LD_INT 111
91469: PUSH
91470: LD_INT 112
91472: PUSH
91473: LD_INT 113
91475: PUSH
91476: LD_INT 114
91478: PUSH
91479: LD_INT 116
91481: PUSH
91482: LD_INT 117
91484: PUSH
91485: LD_INT 118
91487: PUSH
91488: EMPTY
91489: LIST
91490: LIST
91491: LIST
91492: LIST
91493: LIST
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: ST_TO_ADDR
91511: GO 92750
91513: LD_INT 14
91515: DOUBLE
91516: EQUAL
91517: IFTRUE 91521
91519: GO 91745
91521: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
91522: LD_ADDR_VAR 0 2
91526: PUSH
91527: LD_INT 1
91529: PUSH
91530: LD_INT 2
91532: PUSH
91533: LD_INT 3
91535: PUSH
91536: LD_INT 4
91538: PUSH
91539: LD_INT 5
91541: PUSH
91542: LD_INT 6
91544: PUSH
91545: LD_INT 7
91547: PUSH
91548: LD_INT 8
91550: PUSH
91551: LD_INT 9
91553: PUSH
91554: LD_INT 10
91556: PUSH
91557: LD_INT 11
91559: PUSH
91560: LD_INT 12
91562: PUSH
91563: LD_INT 13
91565: PUSH
91566: LD_INT 14
91568: PUSH
91569: LD_INT 15
91571: PUSH
91572: LD_INT 16
91574: PUSH
91575: LD_INT 17
91577: PUSH
91578: LD_INT 18
91580: PUSH
91581: LD_INT 19
91583: PUSH
91584: LD_INT 20
91586: PUSH
91587: LD_INT 21
91589: PUSH
91590: LD_INT 22
91592: PUSH
91593: LD_INT 23
91595: PUSH
91596: LD_INT 24
91598: PUSH
91599: LD_INT 25
91601: PUSH
91602: LD_INT 26
91604: PUSH
91605: LD_INT 27
91607: PUSH
91608: LD_INT 28
91610: PUSH
91611: LD_INT 29
91613: PUSH
91614: LD_INT 30
91616: PUSH
91617: LD_INT 31
91619: PUSH
91620: LD_INT 32
91622: PUSH
91623: LD_INT 33
91625: PUSH
91626: LD_INT 34
91628: PUSH
91629: LD_INT 36
91631: PUSH
91632: EMPTY
91633: LIST
91634: LIST
91635: LIST
91636: LIST
91637: LIST
91638: LIST
91639: LIST
91640: LIST
91641: LIST
91642: LIST
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: LIST
91653: LIST
91654: LIST
91655: LIST
91656: LIST
91657: LIST
91658: LIST
91659: LIST
91660: LIST
91661: LIST
91662: LIST
91663: LIST
91664: LIST
91665: LIST
91666: LIST
91667: LIST
91668: PUSH
91669: LD_INT 101
91671: PUSH
91672: LD_INT 102
91674: PUSH
91675: LD_INT 103
91677: PUSH
91678: LD_INT 104
91680: PUSH
91681: LD_INT 105
91683: PUSH
91684: LD_INT 106
91686: PUSH
91687: LD_INT 107
91689: PUSH
91690: LD_INT 108
91692: PUSH
91693: LD_INT 109
91695: PUSH
91696: LD_INT 110
91698: PUSH
91699: LD_INT 111
91701: PUSH
91702: LD_INT 112
91704: PUSH
91705: LD_INT 113
91707: PUSH
91708: LD_INT 114
91710: PUSH
91711: LD_INT 116
91713: PUSH
91714: LD_INT 117
91716: PUSH
91717: LD_INT 118
91719: PUSH
91720: EMPTY
91721: LIST
91722: LIST
91723: LIST
91724: LIST
91725: LIST
91726: LIST
91727: LIST
91728: LIST
91729: LIST
91730: LIST
91731: LIST
91732: LIST
91733: LIST
91734: LIST
91735: LIST
91736: LIST
91737: LIST
91738: PUSH
91739: EMPTY
91740: LIST
91741: LIST
91742: ST_TO_ADDR
91743: GO 92750
91745: LD_INT 15
91747: DOUBLE
91748: EQUAL
91749: IFTRUE 91753
91751: GO 91977
91753: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
91754: LD_ADDR_VAR 0 2
91758: PUSH
91759: LD_INT 1
91761: PUSH
91762: LD_INT 2
91764: PUSH
91765: LD_INT 3
91767: PUSH
91768: LD_INT 4
91770: PUSH
91771: LD_INT 5
91773: PUSH
91774: LD_INT 6
91776: PUSH
91777: LD_INT 7
91779: PUSH
91780: LD_INT 8
91782: PUSH
91783: LD_INT 9
91785: PUSH
91786: LD_INT 10
91788: PUSH
91789: LD_INT 11
91791: PUSH
91792: LD_INT 12
91794: PUSH
91795: LD_INT 13
91797: PUSH
91798: LD_INT 14
91800: PUSH
91801: LD_INT 15
91803: PUSH
91804: LD_INT 16
91806: PUSH
91807: LD_INT 17
91809: PUSH
91810: LD_INT 18
91812: PUSH
91813: LD_INT 19
91815: PUSH
91816: LD_INT 20
91818: PUSH
91819: LD_INT 21
91821: PUSH
91822: LD_INT 22
91824: PUSH
91825: LD_INT 23
91827: PUSH
91828: LD_INT 24
91830: PUSH
91831: LD_INT 25
91833: PUSH
91834: LD_INT 26
91836: PUSH
91837: LD_INT 27
91839: PUSH
91840: LD_INT 28
91842: PUSH
91843: LD_INT 29
91845: PUSH
91846: LD_INT 30
91848: PUSH
91849: LD_INT 31
91851: PUSH
91852: LD_INT 32
91854: PUSH
91855: LD_INT 33
91857: PUSH
91858: LD_INT 34
91860: PUSH
91861: LD_INT 36
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: LIST
91881: LIST
91882: LIST
91883: LIST
91884: LIST
91885: LIST
91886: LIST
91887: LIST
91888: LIST
91889: LIST
91890: LIST
91891: LIST
91892: LIST
91893: LIST
91894: LIST
91895: LIST
91896: LIST
91897: LIST
91898: LIST
91899: LIST
91900: PUSH
91901: LD_INT 101
91903: PUSH
91904: LD_INT 102
91906: PUSH
91907: LD_INT 103
91909: PUSH
91910: LD_INT 104
91912: PUSH
91913: LD_INT 105
91915: PUSH
91916: LD_INT 106
91918: PUSH
91919: LD_INT 107
91921: PUSH
91922: LD_INT 108
91924: PUSH
91925: LD_INT 109
91927: PUSH
91928: LD_INT 110
91930: PUSH
91931: LD_INT 111
91933: PUSH
91934: LD_INT 112
91936: PUSH
91937: LD_INT 113
91939: PUSH
91940: LD_INT 114
91942: PUSH
91943: LD_INT 116
91945: PUSH
91946: LD_INT 117
91948: PUSH
91949: LD_INT 118
91951: PUSH
91952: EMPTY
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: LIST
91958: LIST
91959: LIST
91960: LIST
91961: LIST
91962: LIST
91963: LIST
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: PUSH
91971: EMPTY
91972: LIST
91973: LIST
91974: ST_TO_ADDR
91975: GO 92750
91977: LD_INT 16
91979: DOUBLE
91980: EQUAL
91981: IFTRUE 91985
91983: GO 92121
91985: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
91986: LD_ADDR_VAR 0 2
91990: PUSH
91991: LD_INT 2
91993: PUSH
91994: LD_INT 4
91996: PUSH
91997: LD_INT 5
91999: PUSH
92000: LD_INT 7
92002: PUSH
92003: LD_INT 11
92005: PUSH
92006: LD_INT 12
92008: PUSH
92009: LD_INT 15
92011: PUSH
92012: LD_INT 16
92014: PUSH
92015: LD_INT 20
92017: PUSH
92018: LD_INT 21
92020: PUSH
92021: LD_INT 22
92023: PUSH
92024: LD_INT 23
92026: PUSH
92027: LD_INT 25
92029: PUSH
92030: LD_INT 26
92032: PUSH
92033: LD_INT 30
92035: PUSH
92036: LD_INT 31
92038: PUSH
92039: LD_INT 32
92041: PUSH
92042: LD_INT 33
92044: PUSH
92045: LD_INT 34
92047: PUSH
92048: EMPTY
92049: LIST
92050: LIST
92051: LIST
92052: LIST
92053: LIST
92054: LIST
92055: LIST
92056: LIST
92057: LIST
92058: LIST
92059: LIST
92060: LIST
92061: LIST
92062: LIST
92063: LIST
92064: LIST
92065: LIST
92066: LIST
92067: LIST
92068: PUSH
92069: LD_INT 101
92071: PUSH
92072: LD_INT 102
92074: PUSH
92075: LD_INT 103
92077: PUSH
92078: LD_INT 106
92080: PUSH
92081: LD_INT 108
92083: PUSH
92084: LD_INT 112
92086: PUSH
92087: LD_INT 113
92089: PUSH
92090: LD_INT 114
92092: PUSH
92093: LD_INT 116
92095: PUSH
92096: LD_INT 117
92098: PUSH
92099: LD_INT 118
92101: PUSH
92102: EMPTY
92103: LIST
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: LIST
92113: LIST
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: ST_TO_ADDR
92119: GO 92750
92121: LD_INT 17
92123: DOUBLE
92124: EQUAL
92125: IFTRUE 92129
92127: GO 92353
92129: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
92130: LD_ADDR_VAR 0 2
92134: PUSH
92135: LD_INT 1
92137: PUSH
92138: LD_INT 2
92140: PUSH
92141: LD_INT 3
92143: PUSH
92144: LD_INT 4
92146: PUSH
92147: LD_INT 5
92149: PUSH
92150: LD_INT 6
92152: PUSH
92153: LD_INT 7
92155: PUSH
92156: LD_INT 8
92158: PUSH
92159: LD_INT 9
92161: PUSH
92162: LD_INT 10
92164: PUSH
92165: LD_INT 11
92167: PUSH
92168: LD_INT 12
92170: PUSH
92171: LD_INT 13
92173: PUSH
92174: LD_INT 14
92176: PUSH
92177: LD_INT 15
92179: PUSH
92180: LD_INT 16
92182: PUSH
92183: LD_INT 17
92185: PUSH
92186: LD_INT 18
92188: PUSH
92189: LD_INT 19
92191: PUSH
92192: LD_INT 20
92194: PUSH
92195: LD_INT 21
92197: PUSH
92198: LD_INT 22
92200: PUSH
92201: LD_INT 23
92203: PUSH
92204: LD_INT 24
92206: PUSH
92207: LD_INT 25
92209: PUSH
92210: LD_INT 26
92212: PUSH
92213: LD_INT 27
92215: PUSH
92216: LD_INT 28
92218: PUSH
92219: LD_INT 29
92221: PUSH
92222: LD_INT 30
92224: PUSH
92225: LD_INT 31
92227: PUSH
92228: LD_INT 32
92230: PUSH
92231: LD_INT 33
92233: PUSH
92234: LD_INT 34
92236: PUSH
92237: LD_INT 36
92239: PUSH
92240: EMPTY
92241: LIST
92242: LIST
92243: LIST
92244: LIST
92245: LIST
92246: LIST
92247: LIST
92248: LIST
92249: LIST
92250: LIST
92251: LIST
92252: LIST
92253: LIST
92254: LIST
92255: LIST
92256: LIST
92257: LIST
92258: LIST
92259: LIST
92260: LIST
92261: LIST
92262: LIST
92263: LIST
92264: LIST
92265: LIST
92266: LIST
92267: LIST
92268: LIST
92269: LIST
92270: LIST
92271: LIST
92272: LIST
92273: LIST
92274: LIST
92275: LIST
92276: PUSH
92277: LD_INT 101
92279: PUSH
92280: LD_INT 102
92282: PUSH
92283: LD_INT 103
92285: PUSH
92286: LD_INT 104
92288: PUSH
92289: LD_INT 105
92291: PUSH
92292: LD_INT 106
92294: PUSH
92295: LD_INT 107
92297: PUSH
92298: LD_INT 108
92300: PUSH
92301: LD_INT 109
92303: PUSH
92304: LD_INT 110
92306: PUSH
92307: LD_INT 111
92309: PUSH
92310: LD_INT 112
92312: PUSH
92313: LD_INT 113
92315: PUSH
92316: LD_INT 114
92318: PUSH
92319: LD_INT 116
92321: PUSH
92322: LD_INT 117
92324: PUSH
92325: LD_INT 118
92327: PUSH
92328: EMPTY
92329: LIST
92330: LIST
92331: LIST
92332: LIST
92333: LIST
92334: LIST
92335: LIST
92336: LIST
92337: LIST
92338: LIST
92339: LIST
92340: LIST
92341: LIST
92342: LIST
92343: LIST
92344: LIST
92345: LIST
92346: PUSH
92347: EMPTY
92348: LIST
92349: LIST
92350: ST_TO_ADDR
92351: GO 92750
92353: LD_INT 18
92355: DOUBLE
92356: EQUAL
92357: IFTRUE 92361
92359: GO 92509
92361: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
92362: LD_ADDR_VAR 0 2
92366: PUSH
92367: LD_INT 2
92369: PUSH
92370: LD_INT 4
92372: PUSH
92373: LD_INT 5
92375: PUSH
92376: LD_INT 7
92378: PUSH
92379: LD_INT 11
92381: PUSH
92382: LD_INT 12
92384: PUSH
92385: LD_INT 15
92387: PUSH
92388: LD_INT 16
92390: PUSH
92391: LD_INT 20
92393: PUSH
92394: LD_INT 21
92396: PUSH
92397: LD_INT 22
92399: PUSH
92400: LD_INT 23
92402: PUSH
92403: LD_INT 25
92405: PUSH
92406: LD_INT 26
92408: PUSH
92409: LD_INT 30
92411: PUSH
92412: LD_INT 31
92414: PUSH
92415: LD_INT 32
92417: PUSH
92418: LD_INT 33
92420: PUSH
92421: LD_INT 34
92423: PUSH
92424: LD_INT 35
92426: PUSH
92427: LD_INT 36
92429: PUSH
92430: EMPTY
92431: LIST
92432: LIST
92433: LIST
92434: LIST
92435: LIST
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: LIST
92451: LIST
92452: PUSH
92453: LD_INT 101
92455: PUSH
92456: LD_INT 102
92458: PUSH
92459: LD_INT 103
92461: PUSH
92462: LD_INT 106
92464: PUSH
92465: LD_INT 108
92467: PUSH
92468: LD_INT 112
92470: PUSH
92471: LD_INT 113
92473: PUSH
92474: LD_INT 114
92476: PUSH
92477: LD_INT 115
92479: PUSH
92480: LD_INT 116
92482: PUSH
92483: LD_INT 117
92485: PUSH
92486: LD_INT 118
92488: PUSH
92489: EMPTY
92490: LIST
92491: LIST
92492: LIST
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: LIST
92499: LIST
92500: LIST
92501: LIST
92502: PUSH
92503: EMPTY
92504: LIST
92505: LIST
92506: ST_TO_ADDR
92507: GO 92750
92509: LD_INT 19
92511: DOUBLE
92512: EQUAL
92513: IFTRUE 92517
92515: GO 92749
92517: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
92518: LD_ADDR_VAR 0 2
92522: PUSH
92523: LD_INT 1
92525: PUSH
92526: LD_INT 2
92528: PUSH
92529: LD_INT 3
92531: PUSH
92532: LD_INT 4
92534: PUSH
92535: LD_INT 5
92537: PUSH
92538: LD_INT 6
92540: PUSH
92541: LD_INT 7
92543: PUSH
92544: LD_INT 8
92546: PUSH
92547: LD_INT 9
92549: PUSH
92550: LD_INT 10
92552: PUSH
92553: LD_INT 11
92555: PUSH
92556: LD_INT 12
92558: PUSH
92559: LD_INT 13
92561: PUSH
92562: LD_INT 14
92564: PUSH
92565: LD_INT 15
92567: PUSH
92568: LD_INT 16
92570: PUSH
92571: LD_INT 17
92573: PUSH
92574: LD_INT 18
92576: PUSH
92577: LD_INT 19
92579: PUSH
92580: LD_INT 20
92582: PUSH
92583: LD_INT 21
92585: PUSH
92586: LD_INT 22
92588: PUSH
92589: LD_INT 23
92591: PUSH
92592: LD_INT 24
92594: PUSH
92595: LD_INT 25
92597: PUSH
92598: LD_INT 26
92600: PUSH
92601: LD_INT 27
92603: PUSH
92604: LD_INT 28
92606: PUSH
92607: LD_INT 29
92609: PUSH
92610: LD_INT 30
92612: PUSH
92613: LD_INT 31
92615: PUSH
92616: LD_INT 32
92618: PUSH
92619: LD_INT 33
92621: PUSH
92622: LD_INT 34
92624: PUSH
92625: LD_INT 35
92627: PUSH
92628: LD_INT 36
92630: PUSH
92631: EMPTY
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: LIST
92641: LIST
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: LIST
92652: LIST
92653: LIST
92654: LIST
92655: LIST
92656: LIST
92657: LIST
92658: LIST
92659: LIST
92660: LIST
92661: LIST
92662: LIST
92663: LIST
92664: LIST
92665: LIST
92666: LIST
92667: LIST
92668: PUSH
92669: LD_INT 101
92671: PUSH
92672: LD_INT 102
92674: PUSH
92675: LD_INT 103
92677: PUSH
92678: LD_INT 104
92680: PUSH
92681: LD_INT 105
92683: PUSH
92684: LD_INT 106
92686: PUSH
92687: LD_INT 107
92689: PUSH
92690: LD_INT 108
92692: PUSH
92693: LD_INT 109
92695: PUSH
92696: LD_INT 110
92698: PUSH
92699: LD_INT 111
92701: PUSH
92702: LD_INT 112
92704: PUSH
92705: LD_INT 113
92707: PUSH
92708: LD_INT 114
92710: PUSH
92711: LD_INT 115
92713: PUSH
92714: LD_INT 116
92716: PUSH
92717: LD_INT 117
92719: PUSH
92720: LD_INT 118
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: PUSH
92743: EMPTY
92744: LIST
92745: LIST
92746: ST_TO_ADDR
92747: GO 92750
92749: POP
// end else
92750: GO 92981
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
92752: LD_ADDR_VAR 0 2
92756: PUSH
92757: LD_INT 1
92759: PUSH
92760: LD_INT 2
92762: PUSH
92763: LD_INT 3
92765: PUSH
92766: LD_INT 4
92768: PUSH
92769: LD_INT 5
92771: PUSH
92772: LD_INT 6
92774: PUSH
92775: LD_INT 7
92777: PUSH
92778: LD_INT 8
92780: PUSH
92781: LD_INT 9
92783: PUSH
92784: LD_INT 10
92786: PUSH
92787: LD_INT 11
92789: PUSH
92790: LD_INT 12
92792: PUSH
92793: LD_INT 13
92795: PUSH
92796: LD_INT 14
92798: PUSH
92799: LD_INT 15
92801: PUSH
92802: LD_INT 16
92804: PUSH
92805: LD_INT 17
92807: PUSH
92808: LD_INT 18
92810: PUSH
92811: LD_INT 19
92813: PUSH
92814: LD_INT 20
92816: PUSH
92817: LD_INT 21
92819: PUSH
92820: LD_INT 22
92822: PUSH
92823: LD_INT 23
92825: PUSH
92826: LD_INT 24
92828: PUSH
92829: LD_INT 25
92831: PUSH
92832: LD_INT 26
92834: PUSH
92835: LD_INT 27
92837: PUSH
92838: LD_INT 28
92840: PUSH
92841: LD_INT 29
92843: PUSH
92844: LD_INT 30
92846: PUSH
92847: LD_INT 31
92849: PUSH
92850: LD_INT 32
92852: PUSH
92853: LD_INT 33
92855: PUSH
92856: LD_INT 34
92858: PUSH
92859: LD_INT 35
92861: PUSH
92862: LD_INT 36
92864: PUSH
92865: EMPTY
92866: LIST
92867: LIST
92868: LIST
92869: LIST
92870: LIST
92871: LIST
92872: LIST
92873: LIST
92874: LIST
92875: LIST
92876: LIST
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: LIST
92886: LIST
92887: LIST
92888: LIST
92889: LIST
92890: LIST
92891: LIST
92892: LIST
92893: LIST
92894: LIST
92895: LIST
92896: LIST
92897: LIST
92898: LIST
92899: LIST
92900: LIST
92901: LIST
92902: PUSH
92903: LD_INT 101
92905: PUSH
92906: LD_INT 102
92908: PUSH
92909: LD_INT 103
92911: PUSH
92912: LD_INT 104
92914: PUSH
92915: LD_INT 105
92917: PUSH
92918: LD_INT 106
92920: PUSH
92921: LD_INT 107
92923: PUSH
92924: LD_INT 108
92926: PUSH
92927: LD_INT 109
92929: PUSH
92930: LD_INT 110
92932: PUSH
92933: LD_INT 111
92935: PUSH
92936: LD_INT 112
92938: PUSH
92939: LD_INT 113
92941: PUSH
92942: LD_INT 114
92944: PUSH
92945: LD_INT 115
92947: PUSH
92948: LD_INT 116
92950: PUSH
92951: LD_INT 117
92953: PUSH
92954: LD_INT 118
92956: PUSH
92957: EMPTY
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: LIST
92964: LIST
92965: LIST
92966: LIST
92967: LIST
92968: LIST
92969: LIST
92970: LIST
92971: LIST
92972: LIST
92973: LIST
92974: LIST
92975: LIST
92976: PUSH
92977: EMPTY
92978: LIST
92979: LIST
92980: ST_TO_ADDR
// if result then
92981: LD_VAR 0 2
92985: IFFALSE 93771
// begin normal :=  ;
92987: LD_ADDR_VAR 0 5
92991: PUSH
92992: LD_STRING 
92994: ST_TO_ADDR
// hardcore :=  ;
92995: LD_ADDR_VAR 0 6
92999: PUSH
93000: LD_STRING 
93002: ST_TO_ADDR
// active :=  ;
93003: LD_ADDR_VAR 0 7
93007: PUSH
93008: LD_STRING 
93010: ST_TO_ADDR
// for i = 1 to normalCounter do
93011: LD_ADDR_VAR 0 8
93015: PUSH
93016: DOUBLE
93017: LD_INT 1
93019: DEC
93020: ST_TO_ADDR
93021: LD_EXP 108
93025: PUSH
93026: FOR_TO
93027: IFFALSE 93128
// begin tmp := 0 ;
93029: LD_ADDR_VAR 0 3
93033: PUSH
93034: LD_STRING 0
93036: ST_TO_ADDR
// if result [ 1 ] then
93037: LD_VAR 0 2
93041: PUSH
93042: LD_INT 1
93044: ARRAY
93045: IFFALSE 93110
// if result [ 1 ] [ 1 ] = i then
93047: LD_VAR 0 2
93051: PUSH
93052: LD_INT 1
93054: ARRAY
93055: PUSH
93056: LD_INT 1
93058: ARRAY
93059: PUSH
93060: LD_VAR 0 8
93064: EQUAL
93065: IFFALSE 93110
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
93067: LD_ADDR_VAR 0 2
93071: PUSH
93072: LD_VAR 0 2
93076: PPUSH
93077: LD_INT 1
93079: PPUSH
93080: LD_VAR 0 2
93084: PUSH
93085: LD_INT 1
93087: ARRAY
93088: PPUSH
93089: LD_INT 1
93091: PPUSH
93092: CALL_OW 3
93096: PPUSH
93097: CALL_OW 1
93101: ST_TO_ADDR
// tmp := 1 ;
93102: LD_ADDR_VAR 0 3
93106: PUSH
93107: LD_STRING 1
93109: ST_TO_ADDR
// end ; normal := normal & tmp ;
93110: LD_ADDR_VAR 0 5
93114: PUSH
93115: LD_VAR 0 5
93119: PUSH
93120: LD_VAR 0 3
93124: STR
93125: ST_TO_ADDR
// end ;
93126: GO 93026
93128: POP
93129: POP
// for i = 1 to hardcoreCounter do
93130: LD_ADDR_VAR 0 8
93134: PUSH
93135: DOUBLE
93136: LD_INT 1
93138: DEC
93139: ST_TO_ADDR
93140: LD_EXP 109
93144: PUSH
93145: FOR_TO
93146: IFFALSE 93251
// begin tmp := 0 ;
93148: LD_ADDR_VAR 0 3
93152: PUSH
93153: LD_STRING 0
93155: ST_TO_ADDR
// if result [ 2 ] then
93156: LD_VAR 0 2
93160: PUSH
93161: LD_INT 2
93163: ARRAY
93164: IFFALSE 93233
// if result [ 2 ] [ 1 ] = 100 + i then
93166: LD_VAR 0 2
93170: PUSH
93171: LD_INT 2
93173: ARRAY
93174: PUSH
93175: LD_INT 1
93177: ARRAY
93178: PUSH
93179: LD_INT 100
93181: PUSH
93182: LD_VAR 0 8
93186: PLUS
93187: EQUAL
93188: IFFALSE 93233
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
93190: LD_ADDR_VAR 0 2
93194: PUSH
93195: LD_VAR 0 2
93199: PPUSH
93200: LD_INT 2
93202: PPUSH
93203: LD_VAR 0 2
93207: PUSH
93208: LD_INT 2
93210: ARRAY
93211: PPUSH
93212: LD_INT 1
93214: PPUSH
93215: CALL_OW 3
93219: PPUSH
93220: CALL_OW 1
93224: ST_TO_ADDR
// tmp := 1 ;
93225: LD_ADDR_VAR 0 3
93229: PUSH
93230: LD_STRING 1
93232: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
93233: LD_ADDR_VAR 0 6
93237: PUSH
93238: LD_VAR 0 6
93242: PUSH
93243: LD_VAR 0 3
93247: STR
93248: ST_TO_ADDR
// end ;
93249: GO 93145
93251: POP
93252: POP
// if isGameLoad then
93253: LD_VAR 0 1
93257: IFFALSE 93732
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
93259: LD_ADDR_VAR 0 4
93263: PUSH
93264: LD_EXP 112
93268: PUSH
93269: LD_EXP 111
93273: PUSH
93274: LD_EXP 113
93278: PUSH
93279: LD_EXP 110
93283: PUSH
93284: LD_EXP 114
93288: PUSH
93289: LD_EXP 115
93293: PUSH
93294: LD_EXP 116
93298: PUSH
93299: LD_EXP 117
93303: PUSH
93304: LD_EXP 118
93308: PUSH
93309: LD_EXP 119
93313: PUSH
93314: LD_EXP 120
93318: PUSH
93319: LD_EXP 121
93323: PUSH
93324: LD_EXP 122
93328: PUSH
93329: LD_EXP 123
93333: PUSH
93334: LD_EXP 131
93338: PUSH
93339: LD_EXP 132
93343: PUSH
93344: LD_EXP 133
93348: PUSH
93349: LD_EXP 134
93353: PUSH
93354: LD_EXP 136
93358: PUSH
93359: LD_EXP 137
93363: PUSH
93364: LD_EXP 138
93368: PUSH
93369: LD_EXP 141
93373: PUSH
93374: LD_EXP 143
93378: PUSH
93379: LD_EXP 144
93383: PUSH
93384: LD_EXP 145
93388: PUSH
93389: LD_EXP 147
93393: PUSH
93394: LD_EXP 148
93398: PUSH
93399: LD_EXP 151
93403: PUSH
93404: LD_EXP 152
93408: PUSH
93409: LD_EXP 153
93413: PUSH
93414: LD_EXP 154
93418: PUSH
93419: LD_EXP 155
93423: PUSH
93424: LD_EXP 156
93428: PUSH
93429: LD_EXP 157
93433: PUSH
93434: LD_EXP 158
93438: PUSH
93439: LD_EXP 159
93443: PUSH
93444: LD_EXP 124
93448: PUSH
93449: LD_EXP 125
93453: PUSH
93454: LD_EXP 128
93458: PUSH
93459: LD_EXP 129
93463: PUSH
93464: LD_EXP 130
93468: PUSH
93469: LD_EXP 126
93473: PUSH
93474: LD_EXP 127
93478: PUSH
93479: LD_EXP 135
93483: PUSH
93484: LD_EXP 139
93488: PUSH
93489: LD_EXP 140
93493: PUSH
93494: LD_EXP 142
93498: PUSH
93499: LD_EXP 146
93503: PUSH
93504: LD_EXP 149
93508: PUSH
93509: LD_EXP 150
93513: PUSH
93514: LD_EXP 160
93518: PUSH
93519: LD_EXP 161
93523: PUSH
93524: LD_EXP 162
93528: PUSH
93529: LD_EXP 163
93533: PUSH
93534: EMPTY
93535: LIST
93536: LIST
93537: LIST
93538: LIST
93539: LIST
93540: LIST
93541: LIST
93542: LIST
93543: LIST
93544: LIST
93545: LIST
93546: LIST
93547: LIST
93548: LIST
93549: LIST
93550: LIST
93551: LIST
93552: LIST
93553: LIST
93554: LIST
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: LIST
93587: LIST
93588: LIST
93589: ST_TO_ADDR
// tmp :=  ;
93590: LD_ADDR_VAR 0 3
93594: PUSH
93595: LD_STRING 
93597: ST_TO_ADDR
// for i = 1 to normalCounter do
93598: LD_ADDR_VAR 0 8
93602: PUSH
93603: DOUBLE
93604: LD_INT 1
93606: DEC
93607: ST_TO_ADDR
93608: LD_EXP 108
93612: PUSH
93613: FOR_TO
93614: IFFALSE 93650
// begin if flags [ i ] then
93616: LD_VAR 0 4
93620: PUSH
93621: LD_VAR 0 8
93625: ARRAY
93626: IFFALSE 93648
// tmp := tmp & i & ; ;
93628: LD_ADDR_VAR 0 3
93632: PUSH
93633: LD_VAR 0 3
93637: PUSH
93638: LD_VAR 0 8
93642: STR
93643: PUSH
93644: LD_STRING ;
93646: STR
93647: ST_TO_ADDR
// end ;
93648: GO 93613
93650: POP
93651: POP
// for i = 1 to hardcoreCounter do
93652: LD_ADDR_VAR 0 8
93656: PUSH
93657: DOUBLE
93658: LD_INT 1
93660: DEC
93661: ST_TO_ADDR
93662: LD_EXP 109
93666: PUSH
93667: FOR_TO
93668: IFFALSE 93714
// begin if flags [ normalCounter + i ] then
93670: LD_VAR 0 4
93674: PUSH
93675: LD_EXP 108
93679: PUSH
93680: LD_VAR 0 8
93684: PLUS
93685: ARRAY
93686: IFFALSE 93712
// tmp := tmp & ( 100 + i ) & ; ;
93688: LD_ADDR_VAR 0 3
93692: PUSH
93693: LD_VAR 0 3
93697: PUSH
93698: LD_INT 100
93700: PUSH
93701: LD_VAR 0 8
93705: PLUS
93706: STR
93707: PUSH
93708: LD_STRING ;
93710: STR
93711: ST_TO_ADDR
// end ;
93712: GO 93667
93714: POP
93715: POP
// if tmp then
93716: LD_VAR 0 3
93720: IFFALSE 93732
// active := tmp ;
93722: LD_ADDR_VAR 0 7
93726: PUSH
93727: LD_VAR 0 3
93731: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
93732: LD_STRING getStreamItemsFromMission("
93734: PUSH
93735: LD_VAR 0 5
93739: STR
93740: PUSH
93741: LD_STRING ","
93743: STR
93744: PUSH
93745: LD_VAR 0 6
93749: STR
93750: PUSH
93751: LD_STRING ","
93753: STR
93754: PUSH
93755: LD_VAR 0 7
93759: STR
93760: PUSH
93761: LD_STRING ")
93763: STR
93764: PPUSH
93765: CALL_OW 559
// end else
93769: GO 93778
// ToLua ( getStreamItemsFromMission("","","") ) ;
93771: LD_STRING getStreamItemsFromMission("","","")
93773: PPUSH
93774: CALL_OW 559
// end ;
93778: LD_VAR 0 2
93782: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
93783: LD_EXP 107
93787: PUSH
93788: LD_EXP 112
93792: AND
93793: IFFALSE 93917
93795: GO 93797
93797: DISABLE
93798: LD_INT 0
93800: PPUSH
93801: PPUSH
// begin enable ;
93802: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
93803: LD_ADDR_VAR 0 2
93807: PUSH
93808: LD_INT 22
93810: PUSH
93811: LD_OWVAR 2
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PUSH
93820: LD_INT 2
93822: PUSH
93823: LD_INT 34
93825: PUSH
93826: LD_INT 7
93828: PUSH
93829: EMPTY
93830: LIST
93831: LIST
93832: PUSH
93833: LD_INT 34
93835: PUSH
93836: LD_INT 45
93838: PUSH
93839: EMPTY
93840: LIST
93841: LIST
93842: PUSH
93843: LD_INT 34
93845: PUSH
93846: LD_INT 28
93848: PUSH
93849: EMPTY
93850: LIST
93851: LIST
93852: PUSH
93853: LD_INT 34
93855: PUSH
93856: LD_INT 47
93858: PUSH
93859: EMPTY
93860: LIST
93861: LIST
93862: PUSH
93863: EMPTY
93864: LIST
93865: LIST
93866: LIST
93867: LIST
93868: LIST
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: PPUSH
93874: CALL_OW 69
93878: ST_TO_ADDR
// if not tmp then
93879: LD_VAR 0 2
93883: NOT
93884: IFFALSE 93888
// exit ;
93886: GO 93917
// for i in tmp do
93888: LD_ADDR_VAR 0 1
93892: PUSH
93893: LD_VAR 0 2
93897: PUSH
93898: FOR_IN
93899: IFFALSE 93915
// begin SetLives ( i , 0 ) ;
93901: LD_VAR 0 1
93905: PPUSH
93906: LD_INT 0
93908: PPUSH
93909: CALL_OW 234
// end ;
93913: GO 93898
93915: POP
93916: POP
// end ;
93917: PPOPN 2
93919: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
93920: LD_EXP 107
93924: PUSH
93925: LD_EXP 113
93929: AND
93930: IFFALSE 94014
93932: GO 93934
93934: DISABLE
93935: LD_INT 0
93937: PPUSH
93938: PPUSH
// begin enable ;
93939: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
93940: LD_ADDR_VAR 0 2
93944: PUSH
93945: LD_INT 22
93947: PUSH
93948: LD_OWVAR 2
93952: PUSH
93953: EMPTY
93954: LIST
93955: LIST
93956: PUSH
93957: LD_INT 32
93959: PUSH
93960: LD_INT 3
93962: PUSH
93963: EMPTY
93964: LIST
93965: LIST
93966: PUSH
93967: EMPTY
93968: LIST
93969: LIST
93970: PPUSH
93971: CALL_OW 69
93975: ST_TO_ADDR
// if not tmp then
93976: LD_VAR 0 2
93980: NOT
93981: IFFALSE 93985
// exit ;
93983: GO 94014
// for i in tmp do
93985: LD_ADDR_VAR 0 1
93989: PUSH
93990: LD_VAR 0 2
93994: PUSH
93995: FOR_IN
93996: IFFALSE 94012
// begin SetLives ( i , 0 ) ;
93998: LD_VAR 0 1
94002: PPUSH
94003: LD_INT 0
94005: PPUSH
94006: CALL_OW 234
// end ;
94010: GO 93995
94012: POP
94013: POP
// end ;
94014: PPOPN 2
94016: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
94017: LD_EXP 107
94021: PUSH
94022: LD_EXP 110
94026: AND
94027: IFFALSE 94120
94029: GO 94031
94031: DISABLE
94032: LD_INT 0
94034: PPUSH
// begin enable ;
94035: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
94036: LD_ADDR_VAR 0 1
94040: PUSH
94041: LD_INT 22
94043: PUSH
94044: LD_OWVAR 2
94048: PUSH
94049: EMPTY
94050: LIST
94051: LIST
94052: PUSH
94053: LD_INT 2
94055: PUSH
94056: LD_INT 25
94058: PUSH
94059: LD_INT 5
94061: PUSH
94062: EMPTY
94063: LIST
94064: LIST
94065: PUSH
94066: LD_INT 25
94068: PUSH
94069: LD_INT 9
94071: PUSH
94072: EMPTY
94073: LIST
94074: LIST
94075: PUSH
94076: LD_INT 25
94078: PUSH
94079: LD_INT 8
94081: PUSH
94082: EMPTY
94083: LIST
94084: LIST
94085: PUSH
94086: EMPTY
94087: LIST
94088: LIST
94089: LIST
94090: LIST
94091: PUSH
94092: EMPTY
94093: LIST
94094: LIST
94095: PPUSH
94096: CALL_OW 69
94100: PUSH
94101: FOR_IN
94102: IFFALSE 94118
// begin SetClass ( i , 1 ) ;
94104: LD_VAR 0 1
94108: PPUSH
94109: LD_INT 1
94111: PPUSH
94112: CALL_OW 336
// end ;
94116: GO 94101
94118: POP
94119: POP
// end ;
94120: PPOPN 1
94122: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
94123: LD_EXP 107
94127: PUSH
94128: LD_EXP 111
94132: AND
94133: PUSH
94134: LD_OWVAR 65
94138: PUSH
94139: LD_INT 7
94141: LESS
94142: AND
94143: IFFALSE 94157
94145: GO 94147
94147: DISABLE
// begin enable ;
94148: ENABLE
// game_speed := 7 ;
94149: LD_ADDR_OWVAR 65
94153: PUSH
94154: LD_INT 7
94156: ST_TO_ADDR
// end ;
94157: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
94158: LD_EXP 107
94162: PUSH
94163: LD_EXP 114
94167: AND
94168: IFFALSE 94370
94170: GO 94172
94172: DISABLE
94173: LD_INT 0
94175: PPUSH
94176: PPUSH
94177: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
94178: LD_ADDR_VAR 0 3
94182: PUSH
94183: LD_INT 81
94185: PUSH
94186: LD_OWVAR 2
94190: PUSH
94191: EMPTY
94192: LIST
94193: LIST
94194: PUSH
94195: LD_INT 21
94197: PUSH
94198: LD_INT 1
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: PUSH
94205: EMPTY
94206: LIST
94207: LIST
94208: PPUSH
94209: CALL_OW 69
94213: ST_TO_ADDR
// if not tmp then
94214: LD_VAR 0 3
94218: NOT
94219: IFFALSE 94223
// exit ;
94221: GO 94370
// if tmp > 5 then
94223: LD_VAR 0 3
94227: PUSH
94228: LD_INT 5
94230: GREATER
94231: IFFALSE 94243
// k := 5 else
94233: LD_ADDR_VAR 0 2
94237: PUSH
94238: LD_INT 5
94240: ST_TO_ADDR
94241: GO 94253
// k := tmp ;
94243: LD_ADDR_VAR 0 2
94247: PUSH
94248: LD_VAR 0 3
94252: ST_TO_ADDR
// for i := 1 to k do
94253: LD_ADDR_VAR 0 1
94257: PUSH
94258: DOUBLE
94259: LD_INT 1
94261: DEC
94262: ST_TO_ADDR
94263: LD_VAR 0 2
94267: PUSH
94268: FOR_TO
94269: IFFALSE 94368
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
94271: LD_VAR 0 3
94275: PUSH
94276: LD_VAR 0 1
94280: ARRAY
94281: PPUSH
94282: LD_VAR 0 1
94286: PUSH
94287: LD_INT 4
94289: MOD
94290: PUSH
94291: LD_INT 1
94293: PLUS
94294: PPUSH
94295: CALL_OW 259
94299: PUSH
94300: LD_INT 10
94302: LESS
94303: IFFALSE 94366
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
94305: LD_VAR 0 3
94309: PUSH
94310: LD_VAR 0 1
94314: ARRAY
94315: PPUSH
94316: LD_VAR 0 1
94320: PUSH
94321: LD_INT 4
94323: MOD
94324: PUSH
94325: LD_INT 1
94327: PLUS
94328: PPUSH
94329: LD_VAR 0 3
94333: PUSH
94334: LD_VAR 0 1
94338: ARRAY
94339: PPUSH
94340: LD_VAR 0 1
94344: PUSH
94345: LD_INT 4
94347: MOD
94348: PUSH
94349: LD_INT 1
94351: PLUS
94352: PPUSH
94353: CALL_OW 259
94357: PUSH
94358: LD_INT 1
94360: PLUS
94361: PPUSH
94362: CALL_OW 237
94366: GO 94268
94368: POP
94369: POP
// end ;
94370: PPOPN 3
94372: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
94373: LD_EXP 107
94377: PUSH
94378: LD_EXP 115
94382: AND
94383: IFFALSE 94403
94385: GO 94387
94387: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
94388: LD_INT 4
94390: PPUSH
94391: LD_OWVAR 2
94395: PPUSH
94396: LD_INT 0
94398: PPUSH
94399: CALL_OW 324
94403: END
// every 0 0$1 trigger StreamModeActive and sShovel do
94404: LD_EXP 107
94408: PUSH
94409: LD_EXP 144
94413: AND
94414: IFFALSE 94434
94416: GO 94418
94418: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
94419: LD_INT 19
94421: PPUSH
94422: LD_OWVAR 2
94426: PPUSH
94427: LD_INT 0
94429: PPUSH
94430: CALL_OW 324
94434: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
94435: LD_EXP 107
94439: PUSH
94440: LD_EXP 116
94444: AND
94445: IFFALSE 94547
94447: GO 94449
94449: DISABLE
94450: LD_INT 0
94452: PPUSH
94453: PPUSH
// begin enable ;
94454: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
94455: LD_ADDR_VAR 0 2
94459: PUSH
94460: LD_INT 22
94462: PUSH
94463: LD_OWVAR 2
94467: PUSH
94468: EMPTY
94469: LIST
94470: LIST
94471: PUSH
94472: LD_INT 2
94474: PUSH
94475: LD_INT 34
94477: PUSH
94478: LD_INT 11
94480: PUSH
94481: EMPTY
94482: LIST
94483: LIST
94484: PUSH
94485: LD_INT 34
94487: PUSH
94488: LD_INT 30
94490: PUSH
94491: EMPTY
94492: LIST
94493: LIST
94494: PUSH
94495: EMPTY
94496: LIST
94497: LIST
94498: LIST
94499: PUSH
94500: EMPTY
94501: LIST
94502: LIST
94503: PPUSH
94504: CALL_OW 69
94508: ST_TO_ADDR
// if not tmp then
94509: LD_VAR 0 2
94513: NOT
94514: IFFALSE 94518
// exit ;
94516: GO 94547
// for i in tmp do
94518: LD_ADDR_VAR 0 1
94522: PUSH
94523: LD_VAR 0 2
94527: PUSH
94528: FOR_IN
94529: IFFALSE 94545
// begin SetLives ( i , 0 ) ;
94531: LD_VAR 0 1
94535: PPUSH
94536: LD_INT 0
94538: PPUSH
94539: CALL_OW 234
// end ;
94543: GO 94528
94545: POP
94546: POP
// end ;
94547: PPOPN 2
94549: END
// every 0 0$1 trigger StreamModeActive and sBunker do
94550: LD_EXP 107
94554: PUSH
94555: LD_EXP 117
94559: AND
94560: IFFALSE 94580
94562: GO 94564
94564: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
94565: LD_INT 32
94567: PPUSH
94568: LD_OWVAR 2
94572: PPUSH
94573: LD_INT 0
94575: PPUSH
94576: CALL_OW 324
94580: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
94581: LD_EXP 107
94585: PUSH
94586: LD_EXP 118
94590: AND
94591: IFFALSE 94772
94593: GO 94595
94595: DISABLE
94596: LD_INT 0
94598: PPUSH
94599: PPUSH
94600: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
94601: LD_ADDR_VAR 0 2
94605: PUSH
94606: LD_INT 22
94608: PUSH
94609: LD_OWVAR 2
94613: PUSH
94614: EMPTY
94615: LIST
94616: LIST
94617: PUSH
94618: LD_INT 33
94620: PUSH
94621: LD_INT 3
94623: PUSH
94624: EMPTY
94625: LIST
94626: LIST
94627: PUSH
94628: EMPTY
94629: LIST
94630: LIST
94631: PPUSH
94632: CALL_OW 69
94636: ST_TO_ADDR
// if not tmp then
94637: LD_VAR 0 2
94641: NOT
94642: IFFALSE 94646
// exit ;
94644: GO 94772
// side := 0 ;
94646: LD_ADDR_VAR 0 3
94650: PUSH
94651: LD_INT 0
94653: ST_TO_ADDR
// for i := 1 to 8 do
94654: LD_ADDR_VAR 0 1
94658: PUSH
94659: DOUBLE
94660: LD_INT 1
94662: DEC
94663: ST_TO_ADDR
94664: LD_INT 8
94666: PUSH
94667: FOR_TO
94668: IFFALSE 94716
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
94670: LD_OWVAR 2
94674: PUSH
94675: LD_VAR 0 1
94679: NONEQUAL
94680: PUSH
94681: LD_OWVAR 2
94685: PPUSH
94686: LD_VAR 0 1
94690: PPUSH
94691: CALL_OW 81
94695: PUSH
94696: LD_INT 2
94698: EQUAL
94699: AND
94700: IFFALSE 94714
// begin side := i ;
94702: LD_ADDR_VAR 0 3
94706: PUSH
94707: LD_VAR 0 1
94711: ST_TO_ADDR
// break ;
94712: GO 94716
// end ;
94714: GO 94667
94716: POP
94717: POP
// if not side then
94718: LD_VAR 0 3
94722: NOT
94723: IFFALSE 94727
// exit ;
94725: GO 94772
// for i := 1 to tmp do
94727: LD_ADDR_VAR 0 1
94731: PUSH
94732: DOUBLE
94733: LD_INT 1
94735: DEC
94736: ST_TO_ADDR
94737: LD_VAR 0 2
94741: PUSH
94742: FOR_TO
94743: IFFALSE 94770
// if Prob ( 60 ) then
94745: LD_INT 60
94747: PPUSH
94748: CALL_OW 13
94752: IFFALSE 94768
// SetSide ( i , side ) ;
94754: LD_VAR 0 1
94758: PPUSH
94759: LD_VAR 0 3
94763: PPUSH
94764: CALL_OW 235
94768: GO 94742
94770: POP
94771: POP
// end ;
94772: PPOPN 3
94774: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
94775: LD_EXP 107
94779: PUSH
94780: LD_EXP 120
94784: AND
94785: IFFALSE 94904
94787: GO 94789
94789: DISABLE
94790: LD_INT 0
94792: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
94793: LD_ADDR_VAR 0 1
94797: PUSH
94798: LD_INT 22
94800: PUSH
94801: LD_OWVAR 2
94805: PUSH
94806: EMPTY
94807: LIST
94808: LIST
94809: PUSH
94810: LD_INT 21
94812: PUSH
94813: LD_INT 1
94815: PUSH
94816: EMPTY
94817: LIST
94818: LIST
94819: PUSH
94820: LD_INT 3
94822: PUSH
94823: LD_INT 23
94825: PUSH
94826: LD_INT 0
94828: PUSH
94829: EMPTY
94830: LIST
94831: LIST
94832: PUSH
94833: EMPTY
94834: LIST
94835: LIST
94836: PUSH
94837: EMPTY
94838: LIST
94839: LIST
94840: LIST
94841: PPUSH
94842: CALL_OW 69
94846: PUSH
94847: FOR_IN
94848: IFFALSE 94902
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
94850: LD_VAR 0 1
94854: PPUSH
94855: CALL_OW 257
94859: PUSH
94860: LD_INT 1
94862: PUSH
94863: LD_INT 2
94865: PUSH
94866: LD_INT 3
94868: PUSH
94869: LD_INT 4
94871: PUSH
94872: EMPTY
94873: LIST
94874: LIST
94875: LIST
94876: LIST
94877: IN
94878: IFFALSE 94900
// SetClass ( un , rand ( 1 , 4 ) ) ;
94880: LD_VAR 0 1
94884: PPUSH
94885: LD_INT 1
94887: PPUSH
94888: LD_INT 4
94890: PPUSH
94891: CALL_OW 12
94895: PPUSH
94896: CALL_OW 336
94900: GO 94847
94902: POP
94903: POP
// end ;
94904: PPOPN 1
94906: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
94907: LD_EXP 107
94911: PUSH
94912: LD_EXP 119
94916: AND
94917: IFFALSE 94996
94919: GO 94921
94921: DISABLE
94922: LD_INT 0
94924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
94925: LD_ADDR_VAR 0 1
94929: PUSH
94930: LD_INT 22
94932: PUSH
94933: LD_OWVAR 2
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: LD_INT 21
94944: PUSH
94945: LD_INT 3
94947: PUSH
94948: EMPTY
94949: LIST
94950: LIST
94951: PUSH
94952: EMPTY
94953: LIST
94954: LIST
94955: PPUSH
94956: CALL_OW 69
94960: ST_TO_ADDR
// if not tmp then
94961: LD_VAR 0 1
94965: NOT
94966: IFFALSE 94970
// exit ;
94968: GO 94996
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
94970: LD_VAR 0 1
94974: PUSH
94975: LD_INT 1
94977: PPUSH
94978: LD_VAR 0 1
94982: PPUSH
94983: CALL_OW 12
94987: ARRAY
94988: PPUSH
94989: LD_INT 100
94991: PPUSH
94992: CALL_OW 234
// end ;
94996: PPOPN 1
94998: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
94999: LD_EXP 107
95003: PUSH
95004: LD_EXP 121
95008: AND
95009: IFFALSE 95107
95011: GO 95013
95013: DISABLE
95014: LD_INT 0
95016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95017: LD_ADDR_VAR 0 1
95021: PUSH
95022: LD_INT 22
95024: PUSH
95025: LD_OWVAR 2
95029: PUSH
95030: EMPTY
95031: LIST
95032: LIST
95033: PUSH
95034: LD_INT 21
95036: PUSH
95037: LD_INT 1
95039: PUSH
95040: EMPTY
95041: LIST
95042: LIST
95043: PUSH
95044: EMPTY
95045: LIST
95046: LIST
95047: PPUSH
95048: CALL_OW 69
95052: ST_TO_ADDR
// if not tmp then
95053: LD_VAR 0 1
95057: NOT
95058: IFFALSE 95062
// exit ;
95060: GO 95107
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
95062: LD_VAR 0 1
95066: PUSH
95067: LD_INT 1
95069: PPUSH
95070: LD_VAR 0 1
95074: PPUSH
95075: CALL_OW 12
95079: ARRAY
95080: PPUSH
95081: LD_INT 1
95083: PPUSH
95084: LD_INT 4
95086: PPUSH
95087: CALL_OW 12
95091: PPUSH
95092: LD_INT 3000
95094: PPUSH
95095: LD_INT 9000
95097: PPUSH
95098: CALL_OW 12
95102: PPUSH
95103: CALL_OW 492
// end ;
95107: PPOPN 1
95109: END
// every 0 0$1 trigger StreamModeActive and sDepot do
95110: LD_EXP 107
95114: PUSH
95115: LD_EXP 122
95119: AND
95120: IFFALSE 95140
95122: GO 95124
95124: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
95125: LD_INT 1
95127: PPUSH
95128: LD_OWVAR 2
95132: PPUSH
95133: LD_INT 0
95135: PPUSH
95136: CALL_OW 324
95140: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
95141: LD_EXP 107
95145: PUSH
95146: LD_EXP 123
95150: AND
95151: IFFALSE 95234
95153: GO 95155
95155: DISABLE
95156: LD_INT 0
95158: PPUSH
95159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
95160: LD_ADDR_VAR 0 2
95164: PUSH
95165: LD_INT 22
95167: PUSH
95168: LD_OWVAR 2
95172: PUSH
95173: EMPTY
95174: LIST
95175: LIST
95176: PUSH
95177: LD_INT 21
95179: PUSH
95180: LD_INT 3
95182: PUSH
95183: EMPTY
95184: LIST
95185: LIST
95186: PUSH
95187: EMPTY
95188: LIST
95189: LIST
95190: PPUSH
95191: CALL_OW 69
95195: ST_TO_ADDR
// if not tmp then
95196: LD_VAR 0 2
95200: NOT
95201: IFFALSE 95205
// exit ;
95203: GO 95234
// for i in tmp do
95205: LD_ADDR_VAR 0 1
95209: PUSH
95210: LD_VAR 0 2
95214: PUSH
95215: FOR_IN
95216: IFFALSE 95232
// SetBLevel ( i , 10 ) ;
95218: LD_VAR 0 1
95222: PPUSH
95223: LD_INT 10
95225: PPUSH
95226: CALL_OW 241
95230: GO 95215
95232: POP
95233: POP
// end ;
95234: PPOPN 2
95236: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
95237: LD_EXP 107
95241: PUSH
95242: LD_EXP 124
95246: AND
95247: IFFALSE 95358
95249: GO 95251
95251: DISABLE
95252: LD_INT 0
95254: PPUSH
95255: PPUSH
95256: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95257: LD_ADDR_VAR 0 3
95261: PUSH
95262: LD_INT 22
95264: PUSH
95265: LD_OWVAR 2
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: PUSH
95274: LD_INT 25
95276: PUSH
95277: LD_INT 1
95279: PUSH
95280: EMPTY
95281: LIST
95282: LIST
95283: PUSH
95284: EMPTY
95285: LIST
95286: LIST
95287: PPUSH
95288: CALL_OW 69
95292: ST_TO_ADDR
// if not tmp then
95293: LD_VAR 0 3
95297: NOT
95298: IFFALSE 95302
// exit ;
95300: GO 95358
// un := tmp [ rand ( 1 , tmp ) ] ;
95302: LD_ADDR_VAR 0 2
95306: PUSH
95307: LD_VAR 0 3
95311: PUSH
95312: LD_INT 1
95314: PPUSH
95315: LD_VAR 0 3
95319: PPUSH
95320: CALL_OW 12
95324: ARRAY
95325: ST_TO_ADDR
// if Crawls ( un ) then
95326: LD_VAR 0 2
95330: PPUSH
95331: CALL_OW 318
95335: IFFALSE 95346
// ComWalk ( un ) ;
95337: LD_VAR 0 2
95341: PPUSH
95342: CALL_OW 138
// SetClass ( un , class_sniper ) ;
95346: LD_VAR 0 2
95350: PPUSH
95351: LD_INT 5
95353: PPUSH
95354: CALL_OW 336
// end ;
95358: PPOPN 3
95360: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
95361: LD_EXP 107
95365: PUSH
95366: LD_EXP 125
95370: AND
95371: PUSH
95372: LD_OWVAR 67
95376: PUSH
95377: LD_INT 4
95379: LESS
95380: AND
95381: IFFALSE 95400
95383: GO 95385
95385: DISABLE
// begin Difficulty := Difficulty + 1 ;
95386: LD_ADDR_OWVAR 67
95390: PUSH
95391: LD_OWVAR 67
95395: PUSH
95396: LD_INT 1
95398: PLUS
95399: ST_TO_ADDR
// end ;
95400: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
95401: LD_EXP 107
95405: PUSH
95406: LD_EXP 126
95410: AND
95411: IFFALSE 95514
95413: GO 95415
95415: DISABLE
95416: LD_INT 0
95418: PPUSH
// begin for i := 1 to 5 do
95419: LD_ADDR_VAR 0 1
95423: PUSH
95424: DOUBLE
95425: LD_INT 1
95427: DEC
95428: ST_TO_ADDR
95429: LD_INT 5
95431: PUSH
95432: FOR_TO
95433: IFFALSE 95512
// begin uc_nation := nation_nature ;
95435: LD_ADDR_OWVAR 21
95439: PUSH
95440: LD_INT 0
95442: ST_TO_ADDR
// uc_side := 0 ;
95443: LD_ADDR_OWVAR 20
95447: PUSH
95448: LD_INT 0
95450: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95451: LD_ADDR_OWVAR 29
95455: PUSH
95456: LD_INT 12
95458: PUSH
95459: LD_INT 12
95461: PUSH
95462: EMPTY
95463: LIST
95464: LIST
95465: ST_TO_ADDR
// hc_agressivity := 20 ;
95466: LD_ADDR_OWVAR 35
95470: PUSH
95471: LD_INT 20
95473: ST_TO_ADDR
// hc_class := class_tiger ;
95474: LD_ADDR_OWVAR 28
95478: PUSH
95479: LD_INT 14
95481: ST_TO_ADDR
// hc_gallery :=  ;
95482: LD_ADDR_OWVAR 33
95486: PUSH
95487: LD_STRING 
95489: ST_TO_ADDR
// hc_name :=  ;
95490: LD_ADDR_OWVAR 26
95494: PUSH
95495: LD_STRING 
95497: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
95498: CALL_OW 44
95502: PPUSH
95503: LD_INT 0
95505: PPUSH
95506: CALL_OW 51
// end ;
95510: GO 95432
95512: POP
95513: POP
// end ;
95514: PPOPN 1
95516: END
// every 0 0$1 trigger StreamModeActive and sBomb do
95517: LD_EXP 107
95521: PUSH
95522: LD_EXP 127
95526: AND
95527: IFFALSE 95536
95529: GO 95531
95531: DISABLE
// StreamSibBomb ;
95532: CALL 95537 0 0
95536: END
// export function StreamSibBomb ; var i , x , y ; begin
95537: LD_INT 0
95539: PPUSH
95540: PPUSH
95541: PPUSH
95542: PPUSH
// result := false ;
95543: LD_ADDR_VAR 0 1
95547: PUSH
95548: LD_INT 0
95550: ST_TO_ADDR
// for i := 1 to 16 do
95551: LD_ADDR_VAR 0 2
95555: PUSH
95556: DOUBLE
95557: LD_INT 1
95559: DEC
95560: ST_TO_ADDR
95561: LD_INT 16
95563: PUSH
95564: FOR_TO
95565: IFFALSE 95764
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95567: LD_ADDR_VAR 0 3
95571: PUSH
95572: LD_INT 10
95574: PUSH
95575: LD_INT 20
95577: PUSH
95578: LD_INT 30
95580: PUSH
95581: LD_INT 40
95583: PUSH
95584: LD_INT 50
95586: PUSH
95587: LD_INT 60
95589: PUSH
95590: LD_INT 70
95592: PUSH
95593: LD_INT 80
95595: PUSH
95596: LD_INT 90
95598: PUSH
95599: LD_INT 100
95601: PUSH
95602: LD_INT 110
95604: PUSH
95605: LD_INT 120
95607: PUSH
95608: LD_INT 130
95610: PUSH
95611: LD_INT 140
95613: PUSH
95614: LD_INT 150
95616: PUSH
95617: EMPTY
95618: LIST
95619: LIST
95620: LIST
95621: LIST
95622: LIST
95623: LIST
95624: LIST
95625: LIST
95626: LIST
95627: LIST
95628: LIST
95629: LIST
95630: LIST
95631: LIST
95632: LIST
95633: PUSH
95634: LD_INT 1
95636: PPUSH
95637: LD_INT 15
95639: PPUSH
95640: CALL_OW 12
95644: ARRAY
95645: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
95646: LD_ADDR_VAR 0 4
95650: PUSH
95651: LD_INT 10
95653: PUSH
95654: LD_INT 20
95656: PUSH
95657: LD_INT 30
95659: PUSH
95660: LD_INT 40
95662: PUSH
95663: LD_INT 50
95665: PUSH
95666: LD_INT 60
95668: PUSH
95669: LD_INT 70
95671: PUSH
95672: LD_INT 80
95674: PUSH
95675: LD_INT 90
95677: PUSH
95678: LD_INT 100
95680: PUSH
95681: LD_INT 110
95683: PUSH
95684: LD_INT 120
95686: PUSH
95687: LD_INT 130
95689: PUSH
95690: LD_INT 140
95692: PUSH
95693: LD_INT 150
95695: PUSH
95696: EMPTY
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: PUSH
95713: LD_INT 1
95715: PPUSH
95716: LD_INT 15
95718: PPUSH
95719: CALL_OW 12
95723: ARRAY
95724: ST_TO_ADDR
// if ValidHex ( x , y ) then
95725: LD_VAR 0 3
95729: PPUSH
95730: LD_VAR 0 4
95734: PPUSH
95735: CALL_OW 488
95739: IFFALSE 95762
// begin result := [ x , y ] ;
95741: LD_ADDR_VAR 0 1
95745: PUSH
95746: LD_VAR 0 3
95750: PUSH
95751: LD_VAR 0 4
95755: PUSH
95756: EMPTY
95757: LIST
95758: LIST
95759: ST_TO_ADDR
// break ;
95760: GO 95764
// end ; end ;
95762: GO 95564
95764: POP
95765: POP
// if result then
95766: LD_VAR 0 1
95770: IFFALSE 95830
// begin ToLua ( playSibBomb() ) ;
95772: LD_STRING playSibBomb()
95774: PPUSH
95775: CALL_OW 559
// wait ( 0 0$14 ) ;
95779: LD_INT 490
95781: PPUSH
95782: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
95786: LD_VAR 0 1
95790: PUSH
95791: LD_INT 1
95793: ARRAY
95794: PPUSH
95795: LD_VAR 0 1
95799: PUSH
95800: LD_INT 2
95802: ARRAY
95803: PPUSH
95804: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
95808: LD_VAR 0 1
95812: PUSH
95813: LD_INT 1
95815: ARRAY
95816: PPUSH
95817: LD_VAR 0 1
95821: PUSH
95822: LD_INT 2
95824: ARRAY
95825: PPUSH
95826: CALL_OW 429
// end ; end ;
95830: LD_VAR 0 1
95834: RET
// every 0 0$1 trigger StreamModeActive and sReset do
95835: LD_EXP 107
95839: PUSH
95840: LD_EXP 129
95844: AND
95845: IFFALSE 95857
95847: GO 95849
95849: DISABLE
// YouLost (  ) ;
95850: LD_STRING 
95852: PPUSH
95853: CALL_OW 104
95857: END
// every 0 0$1 trigger StreamModeActive and sFog do
95858: LD_EXP 107
95862: PUSH
95863: LD_EXP 128
95867: AND
95868: IFFALSE 95882
95870: GO 95872
95872: DISABLE
// FogOff ( your_side ) ;
95873: LD_OWVAR 2
95877: PPUSH
95878: CALL_OW 344
95882: END
// every 0 0$1 trigger StreamModeActive and sSun do
95883: LD_EXP 107
95887: PUSH
95888: LD_EXP 130
95892: AND
95893: IFFALSE 95921
95895: GO 95897
95897: DISABLE
// begin solar_recharge_percent := 0 ;
95898: LD_ADDR_OWVAR 79
95902: PUSH
95903: LD_INT 0
95905: ST_TO_ADDR
// wait ( 5 5$00 ) ;
95906: LD_INT 10500
95908: PPUSH
95909: CALL_OW 67
// solar_recharge_percent := 100 ;
95913: LD_ADDR_OWVAR 79
95917: PUSH
95918: LD_INT 100
95920: ST_TO_ADDR
// end ;
95921: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
95922: LD_EXP 107
95926: PUSH
95927: LD_EXP 131
95931: AND
95932: IFFALSE 96171
95934: GO 95936
95936: DISABLE
95937: LD_INT 0
95939: PPUSH
95940: PPUSH
95941: PPUSH
// begin tmp := [ ] ;
95942: LD_ADDR_VAR 0 3
95946: PUSH
95947: EMPTY
95948: ST_TO_ADDR
// for i := 1 to 6 do
95949: LD_ADDR_VAR 0 1
95953: PUSH
95954: DOUBLE
95955: LD_INT 1
95957: DEC
95958: ST_TO_ADDR
95959: LD_INT 6
95961: PUSH
95962: FOR_TO
95963: IFFALSE 96068
// begin uc_nation := nation_nature ;
95965: LD_ADDR_OWVAR 21
95969: PUSH
95970: LD_INT 0
95972: ST_TO_ADDR
// uc_side := 0 ;
95973: LD_ADDR_OWVAR 20
95977: PUSH
95978: LD_INT 0
95980: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
95981: LD_ADDR_OWVAR 29
95985: PUSH
95986: LD_INT 12
95988: PUSH
95989: LD_INT 12
95991: PUSH
95992: EMPTY
95993: LIST
95994: LIST
95995: ST_TO_ADDR
// hc_agressivity := 20 ;
95996: LD_ADDR_OWVAR 35
96000: PUSH
96001: LD_INT 20
96003: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
96004: LD_ADDR_OWVAR 28
96008: PUSH
96009: LD_INT 17
96011: ST_TO_ADDR
// hc_gallery :=  ;
96012: LD_ADDR_OWVAR 33
96016: PUSH
96017: LD_STRING 
96019: ST_TO_ADDR
// hc_name :=  ;
96020: LD_ADDR_OWVAR 26
96024: PUSH
96025: LD_STRING 
96027: ST_TO_ADDR
// un := CreateHuman ;
96028: LD_ADDR_VAR 0 2
96032: PUSH
96033: CALL_OW 44
96037: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
96038: LD_VAR 0 2
96042: PPUSH
96043: LD_INT 1
96045: PPUSH
96046: CALL_OW 51
// tmp := tmp ^ un ;
96050: LD_ADDR_VAR 0 3
96054: PUSH
96055: LD_VAR 0 3
96059: PUSH
96060: LD_VAR 0 2
96064: ADD
96065: ST_TO_ADDR
// end ;
96066: GO 95962
96068: POP
96069: POP
// repeat wait ( 0 0$1 ) ;
96070: LD_INT 35
96072: PPUSH
96073: CALL_OW 67
// for un in tmp do
96077: LD_ADDR_VAR 0 2
96081: PUSH
96082: LD_VAR 0 3
96086: PUSH
96087: FOR_IN
96088: IFFALSE 96162
// begin if IsDead ( un ) then
96090: LD_VAR 0 2
96094: PPUSH
96095: CALL_OW 301
96099: IFFALSE 96119
// begin tmp := tmp diff un ;
96101: LD_ADDR_VAR 0 3
96105: PUSH
96106: LD_VAR 0 3
96110: PUSH
96111: LD_VAR 0 2
96115: DIFF
96116: ST_TO_ADDR
// continue ;
96117: GO 96087
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
96119: LD_VAR 0 2
96123: PPUSH
96124: LD_INT 3
96126: PUSH
96127: LD_INT 22
96129: PUSH
96130: LD_INT 0
96132: PUSH
96133: EMPTY
96134: LIST
96135: LIST
96136: PUSH
96137: EMPTY
96138: LIST
96139: LIST
96140: PPUSH
96141: CALL_OW 69
96145: PPUSH
96146: LD_VAR 0 2
96150: PPUSH
96151: CALL_OW 74
96155: PPUSH
96156: CALL_OW 115
// end ;
96160: GO 96087
96162: POP
96163: POP
// until not tmp ;
96164: LD_VAR 0 3
96168: NOT
96169: IFFALSE 96070
// end ;
96171: PPOPN 3
96173: END
// every 0 0$1 trigger StreamModeActive and sTroll do
96174: LD_EXP 107
96178: PUSH
96179: LD_EXP 132
96183: AND
96184: IFFALSE 96238
96186: GO 96188
96188: DISABLE
// begin ToLua ( displayTroll(); ) ;
96189: LD_STRING displayTroll();
96191: PPUSH
96192: CALL_OW 559
// wait ( 3 3$00 ) ;
96196: LD_INT 6300
96198: PPUSH
96199: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96203: LD_STRING hideTroll();
96205: PPUSH
96206: CALL_OW 559
// wait ( 1 1$00 ) ;
96210: LD_INT 2100
96212: PPUSH
96213: CALL_OW 67
// ToLua ( displayTroll(); ) ;
96217: LD_STRING displayTroll();
96219: PPUSH
96220: CALL_OW 559
// wait ( 1 1$00 ) ;
96224: LD_INT 2100
96226: PPUSH
96227: CALL_OW 67
// ToLua ( hideTroll(); ) ;
96231: LD_STRING hideTroll();
96233: PPUSH
96234: CALL_OW 559
// end ;
96238: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
96239: LD_EXP 107
96243: PUSH
96244: LD_EXP 133
96248: AND
96249: IFFALSE 96312
96251: GO 96253
96253: DISABLE
96254: LD_INT 0
96256: PPUSH
// begin p := 0 ;
96257: LD_ADDR_VAR 0 1
96261: PUSH
96262: LD_INT 0
96264: ST_TO_ADDR
// repeat game_speed := 1 ;
96265: LD_ADDR_OWVAR 65
96269: PUSH
96270: LD_INT 1
96272: ST_TO_ADDR
// wait ( 0 0$1 ) ;
96273: LD_INT 35
96275: PPUSH
96276: CALL_OW 67
// p := p + 1 ;
96280: LD_ADDR_VAR 0 1
96284: PUSH
96285: LD_VAR 0 1
96289: PUSH
96290: LD_INT 1
96292: PLUS
96293: ST_TO_ADDR
// until p >= 60 ;
96294: LD_VAR 0 1
96298: PUSH
96299: LD_INT 60
96301: GREATEREQUAL
96302: IFFALSE 96265
// game_speed := 4 ;
96304: LD_ADDR_OWVAR 65
96308: PUSH
96309: LD_INT 4
96311: ST_TO_ADDR
// end ;
96312: PPOPN 1
96314: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
96315: LD_EXP 107
96319: PUSH
96320: LD_EXP 134
96324: AND
96325: IFFALSE 96471
96327: GO 96329
96329: DISABLE
96330: LD_INT 0
96332: PPUSH
96333: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
96334: LD_ADDR_VAR 0 1
96338: PUSH
96339: LD_INT 22
96341: PUSH
96342: LD_OWVAR 2
96346: PUSH
96347: EMPTY
96348: LIST
96349: LIST
96350: PUSH
96351: LD_INT 2
96353: PUSH
96354: LD_INT 30
96356: PUSH
96357: LD_INT 0
96359: PUSH
96360: EMPTY
96361: LIST
96362: LIST
96363: PUSH
96364: LD_INT 30
96366: PUSH
96367: LD_INT 1
96369: PUSH
96370: EMPTY
96371: LIST
96372: LIST
96373: PUSH
96374: EMPTY
96375: LIST
96376: LIST
96377: LIST
96378: PUSH
96379: EMPTY
96380: LIST
96381: LIST
96382: PPUSH
96383: CALL_OW 69
96387: ST_TO_ADDR
// if not depot then
96388: LD_VAR 0 1
96392: NOT
96393: IFFALSE 96397
// exit ;
96395: GO 96471
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
96397: LD_ADDR_VAR 0 2
96401: PUSH
96402: LD_VAR 0 1
96406: PUSH
96407: LD_INT 1
96409: PPUSH
96410: LD_VAR 0 1
96414: PPUSH
96415: CALL_OW 12
96419: ARRAY
96420: PPUSH
96421: CALL_OW 274
96425: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
96426: LD_VAR 0 2
96430: PPUSH
96431: LD_INT 1
96433: PPUSH
96434: LD_INT 0
96436: PPUSH
96437: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
96441: LD_VAR 0 2
96445: PPUSH
96446: LD_INT 2
96448: PPUSH
96449: LD_INT 0
96451: PPUSH
96452: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
96456: LD_VAR 0 2
96460: PPUSH
96461: LD_INT 3
96463: PPUSH
96464: LD_INT 0
96466: PPUSH
96467: CALL_OW 277
// end ;
96471: PPOPN 2
96473: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
96474: LD_EXP 107
96478: PUSH
96479: LD_EXP 135
96483: AND
96484: IFFALSE 96581
96486: GO 96488
96488: DISABLE
96489: LD_INT 0
96491: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96492: LD_ADDR_VAR 0 1
96496: PUSH
96497: LD_INT 22
96499: PUSH
96500: LD_OWVAR 2
96504: PUSH
96505: EMPTY
96506: LIST
96507: LIST
96508: PUSH
96509: LD_INT 21
96511: PUSH
96512: LD_INT 1
96514: PUSH
96515: EMPTY
96516: LIST
96517: LIST
96518: PUSH
96519: LD_INT 3
96521: PUSH
96522: LD_INT 23
96524: PUSH
96525: LD_INT 0
96527: PUSH
96528: EMPTY
96529: LIST
96530: LIST
96531: PUSH
96532: EMPTY
96533: LIST
96534: LIST
96535: PUSH
96536: EMPTY
96537: LIST
96538: LIST
96539: LIST
96540: PPUSH
96541: CALL_OW 69
96545: ST_TO_ADDR
// if not tmp then
96546: LD_VAR 0 1
96550: NOT
96551: IFFALSE 96555
// exit ;
96553: GO 96581
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
96555: LD_VAR 0 1
96559: PUSH
96560: LD_INT 1
96562: PPUSH
96563: LD_VAR 0 1
96567: PPUSH
96568: CALL_OW 12
96572: ARRAY
96573: PPUSH
96574: LD_INT 200
96576: PPUSH
96577: CALL_OW 234
// end ;
96581: PPOPN 1
96583: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
96584: LD_EXP 107
96588: PUSH
96589: LD_EXP 136
96593: AND
96594: IFFALSE 96673
96596: GO 96598
96598: DISABLE
96599: LD_INT 0
96601: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
96602: LD_ADDR_VAR 0 1
96606: PUSH
96607: LD_INT 22
96609: PUSH
96610: LD_OWVAR 2
96614: PUSH
96615: EMPTY
96616: LIST
96617: LIST
96618: PUSH
96619: LD_INT 21
96621: PUSH
96622: LD_INT 2
96624: PUSH
96625: EMPTY
96626: LIST
96627: LIST
96628: PUSH
96629: EMPTY
96630: LIST
96631: LIST
96632: PPUSH
96633: CALL_OW 69
96637: ST_TO_ADDR
// if not tmp then
96638: LD_VAR 0 1
96642: NOT
96643: IFFALSE 96647
// exit ;
96645: GO 96673
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
96647: LD_VAR 0 1
96651: PUSH
96652: LD_INT 1
96654: PPUSH
96655: LD_VAR 0 1
96659: PPUSH
96660: CALL_OW 12
96664: ARRAY
96665: PPUSH
96666: LD_INT 60
96668: PPUSH
96669: CALL_OW 234
// end ;
96673: PPOPN 1
96675: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
96676: LD_EXP 107
96680: PUSH
96681: LD_EXP 137
96685: AND
96686: IFFALSE 96785
96688: GO 96690
96690: DISABLE
96691: LD_INT 0
96693: PPUSH
96694: PPUSH
// begin enable ;
96695: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
96696: LD_ADDR_VAR 0 1
96700: PUSH
96701: LD_INT 22
96703: PUSH
96704: LD_OWVAR 2
96708: PUSH
96709: EMPTY
96710: LIST
96711: LIST
96712: PUSH
96713: LD_INT 61
96715: PUSH
96716: EMPTY
96717: LIST
96718: PUSH
96719: LD_INT 33
96721: PUSH
96722: LD_INT 2
96724: PUSH
96725: EMPTY
96726: LIST
96727: LIST
96728: PUSH
96729: EMPTY
96730: LIST
96731: LIST
96732: LIST
96733: PPUSH
96734: CALL_OW 69
96738: ST_TO_ADDR
// if not tmp then
96739: LD_VAR 0 1
96743: NOT
96744: IFFALSE 96748
// exit ;
96746: GO 96785
// for i in tmp do
96748: LD_ADDR_VAR 0 2
96752: PUSH
96753: LD_VAR 0 1
96757: PUSH
96758: FOR_IN
96759: IFFALSE 96783
// if IsControledBy ( i ) then
96761: LD_VAR 0 2
96765: PPUSH
96766: CALL_OW 312
96770: IFFALSE 96781
// ComUnlink ( i ) ;
96772: LD_VAR 0 2
96776: PPUSH
96777: CALL_OW 136
96781: GO 96758
96783: POP
96784: POP
// end ;
96785: PPOPN 2
96787: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
96788: LD_EXP 107
96792: PUSH
96793: LD_EXP 138
96797: AND
96798: IFFALSE 96938
96800: GO 96802
96802: DISABLE
96803: LD_INT 0
96805: PPUSH
96806: PPUSH
// begin ToLua ( displayPowell(); ) ;
96807: LD_STRING displayPowell();
96809: PPUSH
96810: CALL_OW 559
// uc_side := 0 ;
96814: LD_ADDR_OWVAR 20
96818: PUSH
96819: LD_INT 0
96821: ST_TO_ADDR
// uc_nation := 2 ;
96822: LD_ADDR_OWVAR 21
96826: PUSH
96827: LD_INT 2
96829: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
96830: LD_ADDR_OWVAR 37
96834: PUSH
96835: LD_INT 14
96837: ST_TO_ADDR
// vc_engine := engine_siberite ;
96838: LD_ADDR_OWVAR 39
96842: PUSH
96843: LD_INT 3
96845: ST_TO_ADDR
// vc_control := control_apeman ;
96846: LD_ADDR_OWVAR 38
96850: PUSH
96851: LD_INT 5
96853: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
96854: LD_ADDR_OWVAR 40
96858: PUSH
96859: LD_INT 29
96861: ST_TO_ADDR
// un := CreateVehicle ;
96862: LD_ADDR_VAR 0 2
96866: PUSH
96867: CALL_OW 45
96871: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96872: LD_VAR 0 2
96876: PPUSH
96877: LD_INT 1
96879: PPUSH
96880: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96884: LD_INT 35
96886: PPUSH
96887: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96891: LD_VAR 0 2
96895: PPUSH
96896: LD_INT 22
96898: PUSH
96899: LD_OWVAR 2
96903: PUSH
96904: EMPTY
96905: LIST
96906: LIST
96907: PPUSH
96908: CALL_OW 69
96912: PPUSH
96913: LD_VAR 0 2
96917: PPUSH
96918: CALL_OW 74
96922: PPUSH
96923: CALL_OW 115
// until IsDead ( un ) ;
96927: LD_VAR 0 2
96931: PPUSH
96932: CALL_OW 301
96936: IFFALSE 96884
// end ;
96938: PPOPN 2
96940: END
// every 0 0$1 trigger StreamModeActive and sStu do
96941: LD_EXP 107
96945: PUSH
96946: LD_EXP 146
96950: AND
96951: IFFALSE 96967
96953: GO 96955
96955: DISABLE
// begin ToLua ( displayStucuk(); ) ;
96956: LD_STRING displayStucuk();
96958: PPUSH
96959: CALL_OW 559
// ResetFog ;
96963: CALL_OW 335
// end ;
96967: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
96968: LD_EXP 107
96972: PUSH
96973: LD_EXP 139
96977: AND
96978: IFFALSE 97119
96980: GO 96982
96982: DISABLE
96983: LD_INT 0
96985: PPUSH
96986: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
96987: LD_ADDR_VAR 0 2
96991: PUSH
96992: LD_INT 22
96994: PUSH
96995: LD_OWVAR 2
96999: PUSH
97000: EMPTY
97001: LIST
97002: LIST
97003: PUSH
97004: LD_INT 21
97006: PUSH
97007: LD_INT 1
97009: PUSH
97010: EMPTY
97011: LIST
97012: LIST
97013: PUSH
97014: EMPTY
97015: LIST
97016: LIST
97017: PPUSH
97018: CALL_OW 69
97022: ST_TO_ADDR
// if not tmp then
97023: LD_VAR 0 2
97027: NOT
97028: IFFALSE 97032
// exit ;
97030: GO 97119
// un := tmp [ rand ( 1 , tmp ) ] ;
97032: LD_ADDR_VAR 0 1
97036: PUSH
97037: LD_VAR 0 2
97041: PUSH
97042: LD_INT 1
97044: PPUSH
97045: LD_VAR 0 2
97049: PPUSH
97050: CALL_OW 12
97054: ARRAY
97055: ST_TO_ADDR
// SetSide ( un , 0 ) ;
97056: LD_VAR 0 1
97060: PPUSH
97061: LD_INT 0
97063: PPUSH
97064: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
97068: LD_VAR 0 1
97072: PPUSH
97073: LD_OWVAR 3
97077: PUSH
97078: LD_VAR 0 1
97082: DIFF
97083: PPUSH
97084: LD_VAR 0 1
97088: PPUSH
97089: CALL_OW 74
97093: PPUSH
97094: CALL_OW 115
// wait ( 0 0$20 ) ;
97098: LD_INT 700
97100: PPUSH
97101: CALL_OW 67
// SetSide ( un , your_side ) ;
97105: LD_VAR 0 1
97109: PPUSH
97110: LD_OWVAR 2
97114: PPUSH
97115: CALL_OW 235
// end ;
97119: PPOPN 2
97121: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
97122: LD_EXP 107
97126: PUSH
97127: LD_EXP 140
97131: AND
97132: IFFALSE 97238
97134: GO 97136
97136: DISABLE
97137: LD_INT 0
97139: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97140: LD_ADDR_VAR 0 1
97144: PUSH
97145: LD_INT 22
97147: PUSH
97148: LD_OWVAR 2
97152: PUSH
97153: EMPTY
97154: LIST
97155: LIST
97156: PUSH
97157: LD_INT 2
97159: PUSH
97160: LD_INT 30
97162: PUSH
97163: LD_INT 0
97165: PUSH
97166: EMPTY
97167: LIST
97168: LIST
97169: PUSH
97170: LD_INT 30
97172: PUSH
97173: LD_INT 1
97175: PUSH
97176: EMPTY
97177: LIST
97178: LIST
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: LIST
97184: PUSH
97185: EMPTY
97186: LIST
97187: LIST
97188: PPUSH
97189: CALL_OW 69
97193: ST_TO_ADDR
// if not depot then
97194: LD_VAR 0 1
97198: NOT
97199: IFFALSE 97203
// exit ;
97201: GO 97238
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
97203: LD_VAR 0 1
97207: PUSH
97208: LD_INT 1
97210: ARRAY
97211: PPUSH
97212: CALL_OW 250
97216: PPUSH
97217: LD_VAR 0 1
97221: PUSH
97222: LD_INT 1
97224: ARRAY
97225: PPUSH
97226: CALL_OW 251
97230: PPUSH
97231: LD_INT 70
97233: PPUSH
97234: CALL_OW 495
// end ;
97238: PPOPN 1
97240: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
97241: LD_EXP 107
97245: PUSH
97246: LD_EXP 141
97250: AND
97251: IFFALSE 97462
97253: GO 97255
97255: DISABLE
97256: LD_INT 0
97258: PPUSH
97259: PPUSH
97260: PPUSH
97261: PPUSH
97262: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97263: LD_ADDR_VAR 0 5
97267: PUSH
97268: LD_INT 22
97270: PUSH
97271: LD_OWVAR 2
97275: PUSH
97276: EMPTY
97277: LIST
97278: LIST
97279: PUSH
97280: LD_INT 21
97282: PUSH
97283: LD_INT 1
97285: PUSH
97286: EMPTY
97287: LIST
97288: LIST
97289: PUSH
97290: EMPTY
97291: LIST
97292: LIST
97293: PPUSH
97294: CALL_OW 69
97298: ST_TO_ADDR
// if not tmp then
97299: LD_VAR 0 5
97303: NOT
97304: IFFALSE 97308
// exit ;
97306: GO 97462
// for i in tmp do
97308: LD_ADDR_VAR 0 1
97312: PUSH
97313: LD_VAR 0 5
97317: PUSH
97318: FOR_IN
97319: IFFALSE 97460
// begin d := rand ( 0 , 5 ) ;
97321: LD_ADDR_VAR 0 4
97325: PUSH
97326: LD_INT 0
97328: PPUSH
97329: LD_INT 5
97331: PPUSH
97332: CALL_OW 12
97336: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
97337: LD_ADDR_VAR 0 2
97341: PUSH
97342: LD_VAR 0 1
97346: PPUSH
97347: CALL_OW 250
97351: PPUSH
97352: LD_VAR 0 4
97356: PPUSH
97357: LD_INT 3
97359: PPUSH
97360: LD_INT 12
97362: PPUSH
97363: CALL_OW 12
97367: PPUSH
97368: CALL_OW 272
97372: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
97373: LD_ADDR_VAR 0 3
97377: PUSH
97378: LD_VAR 0 1
97382: PPUSH
97383: CALL_OW 251
97387: PPUSH
97388: LD_VAR 0 4
97392: PPUSH
97393: LD_INT 3
97395: PPUSH
97396: LD_INT 12
97398: PPUSH
97399: CALL_OW 12
97403: PPUSH
97404: CALL_OW 273
97408: ST_TO_ADDR
// if ValidHex ( x , y ) then
97409: LD_VAR 0 2
97413: PPUSH
97414: LD_VAR 0 3
97418: PPUSH
97419: CALL_OW 488
97423: IFFALSE 97458
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
97425: LD_VAR 0 1
97429: PPUSH
97430: LD_VAR 0 2
97434: PPUSH
97435: LD_VAR 0 3
97439: PPUSH
97440: LD_INT 3
97442: PPUSH
97443: LD_INT 6
97445: PPUSH
97446: CALL_OW 12
97450: PPUSH
97451: LD_INT 1
97453: PPUSH
97454: CALL_OW 483
// end ;
97458: GO 97318
97460: POP
97461: POP
// end ;
97462: PPOPN 5
97464: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
97465: LD_EXP 107
97469: PUSH
97470: LD_EXP 142
97474: AND
97475: IFFALSE 97569
97477: GO 97479
97479: DISABLE
97480: LD_INT 0
97482: PPUSH
97483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
97484: LD_ADDR_VAR 0 2
97488: PUSH
97489: LD_INT 22
97491: PUSH
97492: LD_OWVAR 2
97496: PUSH
97497: EMPTY
97498: LIST
97499: LIST
97500: PUSH
97501: LD_INT 32
97503: PUSH
97504: LD_INT 1
97506: PUSH
97507: EMPTY
97508: LIST
97509: LIST
97510: PUSH
97511: LD_INT 21
97513: PUSH
97514: LD_INT 2
97516: PUSH
97517: EMPTY
97518: LIST
97519: LIST
97520: PUSH
97521: EMPTY
97522: LIST
97523: LIST
97524: LIST
97525: PPUSH
97526: CALL_OW 69
97530: ST_TO_ADDR
// if not tmp then
97531: LD_VAR 0 2
97535: NOT
97536: IFFALSE 97540
// exit ;
97538: GO 97569
// for i in tmp do
97540: LD_ADDR_VAR 0 1
97544: PUSH
97545: LD_VAR 0 2
97549: PUSH
97550: FOR_IN
97551: IFFALSE 97567
// SetFuel ( i , 0 ) ;
97553: LD_VAR 0 1
97557: PPUSH
97558: LD_INT 0
97560: PPUSH
97561: CALL_OW 240
97565: GO 97550
97567: POP
97568: POP
// end ;
97569: PPOPN 2
97571: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
97572: LD_EXP 107
97576: PUSH
97577: LD_EXP 143
97581: AND
97582: IFFALSE 97648
97584: GO 97586
97586: DISABLE
97587: LD_INT 0
97589: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97590: LD_ADDR_VAR 0 1
97594: PUSH
97595: LD_INT 22
97597: PUSH
97598: LD_OWVAR 2
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: PUSH
97607: LD_INT 30
97609: PUSH
97610: LD_INT 29
97612: PUSH
97613: EMPTY
97614: LIST
97615: LIST
97616: PUSH
97617: EMPTY
97618: LIST
97619: LIST
97620: PPUSH
97621: CALL_OW 69
97625: ST_TO_ADDR
// if not tmp then
97626: LD_VAR 0 1
97630: NOT
97631: IFFALSE 97635
// exit ;
97633: GO 97648
// DestroyUnit ( tmp [ 1 ] ) ;
97635: LD_VAR 0 1
97639: PUSH
97640: LD_INT 1
97642: ARRAY
97643: PPUSH
97644: CALL_OW 65
// end ;
97648: PPOPN 1
97650: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
97651: LD_EXP 107
97655: PUSH
97656: LD_EXP 145
97660: AND
97661: IFFALSE 97790
97663: GO 97665
97665: DISABLE
97666: LD_INT 0
97668: PPUSH
// begin uc_side := 0 ;
97669: LD_ADDR_OWVAR 20
97673: PUSH
97674: LD_INT 0
97676: ST_TO_ADDR
// uc_nation := nation_arabian ;
97677: LD_ADDR_OWVAR 21
97681: PUSH
97682: LD_INT 2
97684: ST_TO_ADDR
// hc_gallery :=  ;
97685: LD_ADDR_OWVAR 33
97689: PUSH
97690: LD_STRING 
97692: ST_TO_ADDR
// hc_name :=  ;
97693: LD_ADDR_OWVAR 26
97697: PUSH
97698: LD_STRING 
97700: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
97701: LD_INT 1
97703: PPUSH
97704: LD_INT 11
97706: PPUSH
97707: LD_INT 10
97709: PPUSH
97710: CALL_OW 380
// un := CreateHuman ;
97714: LD_ADDR_VAR 0 1
97718: PUSH
97719: CALL_OW 44
97723: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97724: LD_VAR 0 1
97728: PPUSH
97729: LD_INT 1
97731: PPUSH
97732: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
97736: LD_INT 35
97738: PPUSH
97739: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
97743: LD_VAR 0 1
97747: PPUSH
97748: LD_INT 22
97750: PUSH
97751: LD_OWVAR 2
97755: PUSH
97756: EMPTY
97757: LIST
97758: LIST
97759: PPUSH
97760: CALL_OW 69
97764: PPUSH
97765: LD_VAR 0 1
97769: PPUSH
97770: CALL_OW 74
97774: PPUSH
97775: CALL_OW 115
// until IsDead ( un ) ;
97779: LD_VAR 0 1
97783: PPUSH
97784: CALL_OW 301
97788: IFFALSE 97736
// end ;
97790: PPOPN 1
97792: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
97793: LD_EXP 107
97797: PUSH
97798: LD_EXP 147
97802: AND
97803: IFFALSE 97815
97805: GO 97807
97807: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
97808: LD_STRING earthquake(getX(game), 0, 32)
97810: PPUSH
97811: CALL_OW 559
97815: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
97816: LD_EXP 107
97820: PUSH
97821: LD_EXP 148
97825: AND
97826: IFFALSE 97917
97828: GO 97830
97830: DISABLE
97831: LD_INT 0
97833: PPUSH
// begin enable ;
97834: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
97835: LD_ADDR_VAR 0 1
97839: PUSH
97840: LD_INT 22
97842: PUSH
97843: LD_OWVAR 2
97847: PUSH
97848: EMPTY
97849: LIST
97850: LIST
97851: PUSH
97852: LD_INT 21
97854: PUSH
97855: LD_INT 2
97857: PUSH
97858: EMPTY
97859: LIST
97860: LIST
97861: PUSH
97862: LD_INT 33
97864: PUSH
97865: LD_INT 3
97867: PUSH
97868: EMPTY
97869: LIST
97870: LIST
97871: PUSH
97872: EMPTY
97873: LIST
97874: LIST
97875: LIST
97876: PPUSH
97877: CALL_OW 69
97881: ST_TO_ADDR
// if not tmp then
97882: LD_VAR 0 1
97886: NOT
97887: IFFALSE 97891
// exit ;
97889: GO 97917
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97891: LD_VAR 0 1
97895: PUSH
97896: LD_INT 1
97898: PPUSH
97899: LD_VAR 0 1
97903: PPUSH
97904: CALL_OW 12
97908: ARRAY
97909: PPUSH
97910: LD_INT 1
97912: PPUSH
97913: CALL_OW 234
// end ;
97917: PPOPN 1
97919: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
97920: LD_EXP 107
97924: PUSH
97925: LD_EXP 149
97929: AND
97930: IFFALSE 98071
97932: GO 97934
97934: DISABLE
97935: LD_INT 0
97937: PPUSH
97938: PPUSH
97939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97940: LD_ADDR_VAR 0 3
97944: PUSH
97945: LD_INT 22
97947: PUSH
97948: LD_OWVAR 2
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 25
97959: PUSH
97960: LD_INT 1
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: PPUSH
97971: CALL_OW 69
97975: ST_TO_ADDR
// if not tmp then
97976: LD_VAR 0 3
97980: NOT
97981: IFFALSE 97985
// exit ;
97983: GO 98071
// un := tmp [ rand ( 1 , tmp ) ] ;
97985: LD_ADDR_VAR 0 2
97989: PUSH
97990: LD_VAR 0 3
97994: PUSH
97995: LD_INT 1
97997: PPUSH
97998: LD_VAR 0 3
98002: PPUSH
98003: CALL_OW 12
98007: ARRAY
98008: ST_TO_ADDR
// if Crawls ( un ) then
98009: LD_VAR 0 2
98013: PPUSH
98014: CALL_OW 318
98018: IFFALSE 98029
// ComWalk ( un ) ;
98020: LD_VAR 0 2
98024: PPUSH
98025: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
98029: LD_VAR 0 2
98033: PPUSH
98034: LD_INT 9
98036: PPUSH
98037: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
98041: LD_INT 28
98043: PPUSH
98044: LD_OWVAR 2
98048: PPUSH
98049: LD_INT 2
98051: PPUSH
98052: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
98056: LD_INT 29
98058: PPUSH
98059: LD_OWVAR 2
98063: PPUSH
98064: LD_INT 2
98066: PPUSH
98067: CALL_OW 322
// end ;
98071: PPOPN 3
98073: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
98074: LD_EXP 107
98078: PUSH
98079: LD_EXP 150
98083: AND
98084: IFFALSE 98195
98086: GO 98088
98088: DISABLE
98089: LD_INT 0
98091: PPUSH
98092: PPUSH
98093: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98094: LD_ADDR_VAR 0 3
98098: PUSH
98099: LD_INT 22
98101: PUSH
98102: LD_OWVAR 2
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: LD_INT 25
98113: PUSH
98114: LD_INT 1
98116: PUSH
98117: EMPTY
98118: LIST
98119: LIST
98120: PUSH
98121: EMPTY
98122: LIST
98123: LIST
98124: PPUSH
98125: CALL_OW 69
98129: ST_TO_ADDR
// if not tmp then
98130: LD_VAR 0 3
98134: NOT
98135: IFFALSE 98139
// exit ;
98137: GO 98195
// un := tmp [ rand ( 1 , tmp ) ] ;
98139: LD_ADDR_VAR 0 2
98143: PUSH
98144: LD_VAR 0 3
98148: PUSH
98149: LD_INT 1
98151: PPUSH
98152: LD_VAR 0 3
98156: PPUSH
98157: CALL_OW 12
98161: ARRAY
98162: ST_TO_ADDR
// if Crawls ( un ) then
98163: LD_VAR 0 2
98167: PPUSH
98168: CALL_OW 318
98172: IFFALSE 98183
// ComWalk ( un ) ;
98174: LD_VAR 0 2
98178: PPUSH
98179: CALL_OW 138
// SetClass ( un , class_mortar ) ;
98183: LD_VAR 0 2
98187: PPUSH
98188: LD_INT 8
98190: PPUSH
98191: CALL_OW 336
// end ;
98195: PPOPN 3
98197: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
98198: LD_EXP 107
98202: PUSH
98203: LD_EXP 151
98207: AND
98208: IFFALSE 98352
98210: GO 98212
98212: DISABLE
98213: LD_INT 0
98215: PPUSH
98216: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
98217: LD_ADDR_VAR 0 2
98221: PUSH
98222: LD_INT 22
98224: PUSH
98225: LD_OWVAR 2
98229: PUSH
98230: EMPTY
98231: LIST
98232: LIST
98233: PUSH
98234: LD_INT 21
98236: PUSH
98237: LD_INT 2
98239: PUSH
98240: EMPTY
98241: LIST
98242: LIST
98243: PUSH
98244: LD_INT 2
98246: PUSH
98247: LD_INT 34
98249: PUSH
98250: LD_INT 12
98252: PUSH
98253: EMPTY
98254: LIST
98255: LIST
98256: PUSH
98257: LD_INT 34
98259: PUSH
98260: LD_INT 51
98262: PUSH
98263: EMPTY
98264: LIST
98265: LIST
98266: PUSH
98267: LD_INT 34
98269: PUSH
98270: LD_INT 32
98272: PUSH
98273: EMPTY
98274: LIST
98275: LIST
98276: PUSH
98277: EMPTY
98278: LIST
98279: LIST
98280: LIST
98281: LIST
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: LIST
98287: PPUSH
98288: CALL_OW 69
98292: ST_TO_ADDR
// if not tmp then
98293: LD_VAR 0 2
98297: NOT
98298: IFFALSE 98302
// exit ;
98300: GO 98352
// for i in tmp do
98302: LD_ADDR_VAR 0 1
98306: PUSH
98307: LD_VAR 0 2
98311: PUSH
98312: FOR_IN
98313: IFFALSE 98350
// if GetCargo ( i , mat_artifact ) = 0 then
98315: LD_VAR 0 1
98319: PPUSH
98320: LD_INT 4
98322: PPUSH
98323: CALL_OW 289
98327: PUSH
98328: LD_INT 0
98330: EQUAL
98331: IFFALSE 98348
// SetCargo ( i , mat_siberit , 100 ) ;
98333: LD_VAR 0 1
98337: PPUSH
98338: LD_INT 3
98340: PPUSH
98341: LD_INT 100
98343: PPUSH
98344: CALL_OW 290
98348: GO 98312
98350: POP
98351: POP
// end ;
98352: PPOPN 2
98354: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
98355: LD_EXP 107
98359: PUSH
98360: LD_EXP 152
98364: AND
98365: IFFALSE 98548
98367: GO 98369
98369: DISABLE
98370: LD_INT 0
98372: PPUSH
98373: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
98374: LD_ADDR_VAR 0 2
98378: PUSH
98379: LD_INT 22
98381: PUSH
98382: LD_OWVAR 2
98386: PUSH
98387: EMPTY
98388: LIST
98389: LIST
98390: PPUSH
98391: CALL_OW 69
98395: ST_TO_ADDR
// if not tmp then
98396: LD_VAR 0 2
98400: NOT
98401: IFFALSE 98405
// exit ;
98403: GO 98548
// for i := 1 to 2 do
98405: LD_ADDR_VAR 0 1
98409: PUSH
98410: DOUBLE
98411: LD_INT 1
98413: DEC
98414: ST_TO_ADDR
98415: LD_INT 2
98417: PUSH
98418: FOR_TO
98419: IFFALSE 98546
// begin uc_side := your_side ;
98421: LD_ADDR_OWVAR 20
98425: PUSH
98426: LD_OWVAR 2
98430: ST_TO_ADDR
// uc_nation := nation_american ;
98431: LD_ADDR_OWVAR 21
98435: PUSH
98436: LD_INT 1
98438: ST_TO_ADDR
// vc_chassis := us_morphling ;
98439: LD_ADDR_OWVAR 37
98443: PUSH
98444: LD_INT 5
98446: ST_TO_ADDR
// vc_engine := engine_siberite ;
98447: LD_ADDR_OWVAR 39
98451: PUSH
98452: LD_INT 3
98454: ST_TO_ADDR
// vc_control := control_computer ;
98455: LD_ADDR_OWVAR 38
98459: PUSH
98460: LD_INT 3
98462: ST_TO_ADDR
// vc_weapon := us_double_laser ;
98463: LD_ADDR_OWVAR 40
98467: PUSH
98468: LD_INT 10
98470: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
98471: LD_VAR 0 2
98475: PUSH
98476: LD_INT 1
98478: ARRAY
98479: PPUSH
98480: CALL_OW 310
98484: NOT
98485: IFFALSE 98532
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
98487: CALL_OW 45
98491: PPUSH
98492: LD_VAR 0 2
98496: PUSH
98497: LD_INT 1
98499: ARRAY
98500: PPUSH
98501: CALL_OW 250
98505: PPUSH
98506: LD_VAR 0 2
98510: PUSH
98511: LD_INT 1
98513: ARRAY
98514: PPUSH
98515: CALL_OW 251
98519: PPUSH
98520: LD_INT 12
98522: PPUSH
98523: LD_INT 1
98525: PPUSH
98526: CALL_OW 50
98530: GO 98544
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
98532: CALL_OW 45
98536: PPUSH
98537: LD_INT 1
98539: PPUSH
98540: CALL_OW 51
// end ;
98544: GO 98418
98546: POP
98547: POP
// end ;
98548: PPOPN 2
98550: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
98551: LD_EXP 107
98555: PUSH
98556: LD_EXP 153
98560: AND
98561: IFFALSE 98783
98563: GO 98565
98565: DISABLE
98566: LD_INT 0
98568: PPUSH
98569: PPUSH
98570: PPUSH
98571: PPUSH
98572: PPUSH
98573: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98574: LD_ADDR_VAR 0 6
98578: PUSH
98579: LD_INT 22
98581: PUSH
98582: LD_OWVAR 2
98586: PUSH
98587: EMPTY
98588: LIST
98589: LIST
98590: PUSH
98591: LD_INT 21
98593: PUSH
98594: LD_INT 1
98596: PUSH
98597: EMPTY
98598: LIST
98599: LIST
98600: PUSH
98601: LD_INT 3
98603: PUSH
98604: LD_INT 23
98606: PUSH
98607: LD_INT 0
98609: PUSH
98610: EMPTY
98611: LIST
98612: LIST
98613: PUSH
98614: EMPTY
98615: LIST
98616: LIST
98617: PUSH
98618: EMPTY
98619: LIST
98620: LIST
98621: LIST
98622: PPUSH
98623: CALL_OW 69
98627: ST_TO_ADDR
// if not tmp then
98628: LD_VAR 0 6
98632: NOT
98633: IFFALSE 98637
// exit ;
98635: GO 98783
// s1 := rand ( 1 , 4 ) ;
98637: LD_ADDR_VAR 0 2
98641: PUSH
98642: LD_INT 1
98644: PPUSH
98645: LD_INT 4
98647: PPUSH
98648: CALL_OW 12
98652: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
98653: LD_ADDR_VAR 0 4
98657: PUSH
98658: LD_VAR 0 6
98662: PUSH
98663: LD_INT 1
98665: ARRAY
98666: PPUSH
98667: LD_VAR 0 2
98671: PPUSH
98672: CALL_OW 259
98676: ST_TO_ADDR
// if s1 = 1 then
98677: LD_VAR 0 2
98681: PUSH
98682: LD_INT 1
98684: EQUAL
98685: IFFALSE 98705
// s2 := rand ( 2 , 4 ) else
98687: LD_ADDR_VAR 0 3
98691: PUSH
98692: LD_INT 2
98694: PPUSH
98695: LD_INT 4
98697: PPUSH
98698: CALL_OW 12
98702: ST_TO_ADDR
98703: GO 98713
// s2 := 1 ;
98705: LD_ADDR_VAR 0 3
98709: PUSH
98710: LD_INT 1
98712: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
98713: LD_ADDR_VAR 0 5
98717: PUSH
98718: LD_VAR 0 6
98722: PUSH
98723: LD_INT 1
98725: ARRAY
98726: PPUSH
98727: LD_VAR 0 3
98731: PPUSH
98732: CALL_OW 259
98736: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
98737: LD_VAR 0 6
98741: PUSH
98742: LD_INT 1
98744: ARRAY
98745: PPUSH
98746: LD_VAR 0 2
98750: PPUSH
98751: LD_VAR 0 5
98755: PPUSH
98756: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
98760: LD_VAR 0 6
98764: PUSH
98765: LD_INT 1
98767: ARRAY
98768: PPUSH
98769: LD_VAR 0 3
98773: PPUSH
98774: LD_VAR 0 4
98778: PPUSH
98779: CALL_OW 237
// end ;
98783: PPOPN 6
98785: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
98786: LD_EXP 107
98790: PUSH
98791: LD_EXP 154
98795: AND
98796: IFFALSE 98875
98798: GO 98800
98800: DISABLE
98801: LD_INT 0
98803: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
98804: LD_ADDR_VAR 0 1
98808: PUSH
98809: LD_INT 22
98811: PUSH
98812: LD_OWVAR 2
98816: PUSH
98817: EMPTY
98818: LIST
98819: LIST
98820: PUSH
98821: LD_INT 30
98823: PUSH
98824: LD_INT 3
98826: PUSH
98827: EMPTY
98828: LIST
98829: LIST
98830: PUSH
98831: EMPTY
98832: LIST
98833: LIST
98834: PPUSH
98835: CALL_OW 69
98839: ST_TO_ADDR
// if not tmp then
98840: LD_VAR 0 1
98844: NOT
98845: IFFALSE 98849
// exit ;
98847: GO 98875
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
98849: LD_VAR 0 1
98853: PUSH
98854: LD_INT 1
98856: PPUSH
98857: LD_VAR 0 1
98861: PPUSH
98862: CALL_OW 12
98866: ARRAY
98867: PPUSH
98868: LD_INT 1
98870: PPUSH
98871: CALL_OW 234
// end ;
98875: PPOPN 1
98877: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
98878: LD_EXP 107
98882: PUSH
98883: LD_EXP 155
98887: AND
98888: IFFALSE 99000
98890: GO 98892
98892: DISABLE
98893: LD_INT 0
98895: PPUSH
98896: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
98897: LD_ADDR_VAR 0 2
98901: PUSH
98902: LD_INT 22
98904: PUSH
98905: LD_OWVAR 2
98909: PUSH
98910: EMPTY
98911: LIST
98912: LIST
98913: PUSH
98914: LD_INT 2
98916: PUSH
98917: LD_INT 30
98919: PUSH
98920: LD_INT 27
98922: PUSH
98923: EMPTY
98924: LIST
98925: LIST
98926: PUSH
98927: LD_INT 30
98929: PUSH
98930: LD_INT 26
98932: PUSH
98933: EMPTY
98934: LIST
98935: LIST
98936: PUSH
98937: LD_INT 30
98939: PUSH
98940: LD_INT 28
98942: PUSH
98943: EMPTY
98944: LIST
98945: LIST
98946: PUSH
98947: EMPTY
98948: LIST
98949: LIST
98950: LIST
98951: LIST
98952: PUSH
98953: EMPTY
98954: LIST
98955: LIST
98956: PPUSH
98957: CALL_OW 69
98961: ST_TO_ADDR
// if not tmp then
98962: LD_VAR 0 2
98966: NOT
98967: IFFALSE 98971
// exit ;
98969: GO 99000
// for i in tmp do
98971: LD_ADDR_VAR 0 1
98975: PUSH
98976: LD_VAR 0 2
98980: PUSH
98981: FOR_IN
98982: IFFALSE 98998
// SetLives ( i , 1 ) ;
98984: LD_VAR 0 1
98988: PPUSH
98989: LD_INT 1
98991: PPUSH
98992: CALL_OW 234
98996: GO 98981
98998: POP
98999: POP
// end ;
99000: PPOPN 2
99002: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
99003: LD_EXP 107
99007: PUSH
99008: LD_EXP 156
99012: AND
99013: IFFALSE 99300
99015: GO 99017
99017: DISABLE
99018: LD_INT 0
99020: PPUSH
99021: PPUSH
99022: PPUSH
// begin i := rand ( 1 , 7 ) ;
99023: LD_ADDR_VAR 0 1
99027: PUSH
99028: LD_INT 1
99030: PPUSH
99031: LD_INT 7
99033: PPUSH
99034: CALL_OW 12
99038: ST_TO_ADDR
// case i of 1 :
99039: LD_VAR 0 1
99043: PUSH
99044: LD_INT 1
99046: DOUBLE
99047: EQUAL
99048: IFTRUE 99052
99050: GO 99062
99052: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
99053: LD_STRING earthquake(getX(game), 0, 32)
99055: PPUSH
99056: CALL_OW 559
99060: GO 99300
99062: LD_INT 2
99064: DOUBLE
99065: EQUAL
99066: IFTRUE 99070
99068: GO 99084
99070: POP
// begin ToLua ( displayStucuk(); ) ;
99071: LD_STRING displayStucuk();
99073: PPUSH
99074: CALL_OW 559
// ResetFog ;
99078: CALL_OW 335
// end ; 3 :
99082: GO 99300
99084: LD_INT 3
99086: DOUBLE
99087: EQUAL
99088: IFTRUE 99092
99090: GO 99196
99092: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99093: LD_ADDR_VAR 0 2
99097: PUSH
99098: LD_INT 22
99100: PUSH
99101: LD_OWVAR 2
99105: PUSH
99106: EMPTY
99107: LIST
99108: LIST
99109: PUSH
99110: LD_INT 25
99112: PUSH
99113: LD_INT 1
99115: PUSH
99116: EMPTY
99117: LIST
99118: LIST
99119: PUSH
99120: EMPTY
99121: LIST
99122: LIST
99123: PPUSH
99124: CALL_OW 69
99128: ST_TO_ADDR
// if not tmp then
99129: LD_VAR 0 2
99133: NOT
99134: IFFALSE 99138
// exit ;
99136: GO 99300
// un := tmp [ rand ( 1 , tmp ) ] ;
99138: LD_ADDR_VAR 0 3
99142: PUSH
99143: LD_VAR 0 2
99147: PUSH
99148: LD_INT 1
99150: PPUSH
99151: LD_VAR 0 2
99155: PPUSH
99156: CALL_OW 12
99160: ARRAY
99161: ST_TO_ADDR
// if Crawls ( un ) then
99162: LD_VAR 0 3
99166: PPUSH
99167: CALL_OW 318
99171: IFFALSE 99182
// ComWalk ( un ) ;
99173: LD_VAR 0 3
99177: PPUSH
99178: CALL_OW 138
// SetClass ( un , class_mortar ) ;
99182: LD_VAR 0 3
99186: PPUSH
99187: LD_INT 8
99189: PPUSH
99190: CALL_OW 336
// end ; 4 :
99194: GO 99300
99196: LD_INT 4
99198: DOUBLE
99199: EQUAL
99200: IFTRUE 99204
99202: GO 99278
99204: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99205: LD_ADDR_VAR 0 2
99209: PUSH
99210: LD_INT 22
99212: PUSH
99213: LD_OWVAR 2
99217: PUSH
99218: EMPTY
99219: LIST
99220: LIST
99221: PUSH
99222: LD_INT 30
99224: PUSH
99225: LD_INT 29
99227: PUSH
99228: EMPTY
99229: LIST
99230: LIST
99231: PUSH
99232: EMPTY
99233: LIST
99234: LIST
99235: PPUSH
99236: CALL_OW 69
99240: ST_TO_ADDR
// if not tmp then
99241: LD_VAR 0 2
99245: NOT
99246: IFFALSE 99250
// exit ;
99248: GO 99300
// CenterNowOnUnits ( tmp [ 1 ] ) ;
99250: LD_VAR 0 2
99254: PUSH
99255: LD_INT 1
99257: ARRAY
99258: PPUSH
99259: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
99263: LD_VAR 0 2
99267: PUSH
99268: LD_INT 1
99270: ARRAY
99271: PPUSH
99272: CALL_OW 65
// end ; 5 .. 7 :
99276: GO 99300
99278: LD_INT 5
99280: DOUBLE
99281: GREATEREQUAL
99282: IFFALSE 99290
99284: LD_INT 7
99286: DOUBLE
99287: LESSEQUAL
99288: IFTRUE 99292
99290: GO 99299
99292: POP
// StreamSibBomb ; end ;
99293: CALL 95537 0 0
99297: GO 99300
99299: POP
// end ;
99300: PPOPN 3
99302: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
99303: LD_EXP 107
99307: PUSH
99308: LD_EXP 157
99312: AND
99313: IFFALSE 99469
99315: GO 99317
99317: DISABLE
99318: LD_INT 0
99320: PPUSH
99321: PPUSH
99322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
99323: LD_ADDR_VAR 0 2
99327: PUSH
99328: LD_INT 81
99330: PUSH
99331: LD_OWVAR 2
99335: PUSH
99336: EMPTY
99337: LIST
99338: LIST
99339: PUSH
99340: LD_INT 2
99342: PUSH
99343: LD_INT 21
99345: PUSH
99346: LD_INT 1
99348: PUSH
99349: EMPTY
99350: LIST
99351: LIST
99352: PUSH
99353: LD_INT 21
99355: PUSH
99356: LD_INT 2
99358: PUSH
99359: EMPTY
99360: LIST
99361: LIST
99362: PUSH
99363: EMPTY
99364: LIST
99365: LIST
99366: LIST
99367: PUSH
99368: EMPTY
99369: LIST
99370: LIST
99371: PPUSH
99372: CALL_OW 69
99376: ST_TO_ADDR
// if not tmp then
99377: LD_VAR 0 2
99381: NOT
99382: IFFALSE 99386
// exit ;
99384: GO 99469
// p := 0 ;
99386: LD_ADDR_VAR 0 3
99390: PUSH
99391: LD_INT 0
99393: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99394: LD_INT 35
99396: PPUSH
99397: CALL_OW 67
// p := p + 1 ;
99401: LD_ADDR_VAR 0 3
99405: PUSH
99406: LD_VAR 0 3
99410: PUSH
99411: LD_INT 1
99413: PLUS
99414: ST_TO_ADDR
// for i in tmp do
99415: LD_ADDR_VAR 0 1
99419: PUSH
99420: LD_VAR 0 2
99424: PUSH
99425: FOR_IN
99426: IFFALSE 99457
// if GetLives ( i ) < 1000 then
99428: LD_VAR 0 1
99432: PPUSH
99433: CALL_OW 256
99437: PUSH
99438: LD_INT 1000
99440: LESS
99441: IFFALSE 99455
// SetLives ( i , 1000 ) ;
99443: LD_VAR 0 1
99447: PPUSH
99448: LD_INT 1000
99450: PPUSH
99451: CALL_OW 234
99455: GO 99425
99457: POP
99458: POP
// until p > 20 ;
99459: LD_VAR 0 3
99463: PUSH
99464: LD_INT 20
99466: GREATER
99467: IFFALSE 99394
// end ;
99469: PPOPN 3
99471: END
// every 0 0$1 trigger StreamModeActive and sTime do
99472: LD_EXP 107
99476: PUSH
99477: LD_EXP 158
99481: AND
99482: IFFALSE 99517
99484: GO 99486
99486: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
99487: LD_INT 28
99489: PPUSH
99490: LD_OWVAR 2
99494: PPUSH
99495: LD_INT 2
99497: PPUSH
99498: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
99502: LD_INT 30
99504: PPUSH
99505: LD_OWVAR 2
99509: PPUSH
99510: LD_INT 2
99512: PPUSH
99513: CALL_OW 322
// end ;
99517: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
99518: LD_EXP 107
99522: PUSH
99523: LD_EXP 159
99527: AND
99528: IFFALSE 99649
99530: GO 99532
99532: DISABLE
99533: LD_INT 0
99535: PPUSH
99536: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99537: LD_ADDR_VAR 0 2
99541: PUSH
99542: LD_INT 22
99544: PUSH
99545: LD_OWVAR 2
99549: PUSH
99550: EMPTY
99551: LIST
99552: LIST
99553: PUSH
99554: LD_INT 21
99556: PUSH
99557: LD_INT 1
99559: PUSH
99560: EMPTY
99561: LIST
99562: LIST
99563: PUSH
99564: LD_INT 3
99566: PUSH
99567: LD_INT 23
99569: PUSH
99570: LD_INT 0
99572: PUSH
99573: EMPTY
99574: LIST
99575: LIST
99576: PUSH
99577: EMPTY
99578: LIST
99579: LIST
99580: PUSH
99581: EMPTY
99582: LIST
99583: LIST
99584: LIST
99585: PPUSH
99586: CALL_OW 69
99590: ST_TO_ADDR
// if not tmp then
99591: LD_VAR 0 2
99595: NOT
99596: IFFALSE 99600
// exit ;
99598: GO 99649
// for i in tmp do
99600: LD_ADDR_VAR 0 1
99604: PUSH
99605: LD_VAR 0 2
99609: PUSH
99610: FOR_IN
99611: IFFALSE 99647
// begin if Crawls ( i ) then
99613: LD_VAR 0 1
99617: PPUSH
99618: CALL_OW 318
99622: IFFALSE 99633
// ComWalk ( i ) ;
99624: LD_VAR 0 1
99628: PPUSH
99629: CALL_OW 138
// SetClass ( i , 2 ) ;
99633: LD_VAR 0 1
99637: PPUSH
99638: LD_INT 2
99640: PPUSH
99641: CALL_OW 336
// end ;
99645: GO 99610
99647: POP
99648: POP
// end ;
99649: PPOPN 2
99651: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
99652: LD_EXP 107
99656: PUSH
99657: LD_EXP 160
99661: AND
99662: IFFALSE 99950
99664: GO 99666
99666: DISABLE
99667: LD_INT 0
99669: PPUSH
99670: PPUSH
99671: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
99672: LD_OWVAR 2
99676: PPUSH
99677: LD_INT 9
99679: PPUSH
99680: LD_INT 1
99682: PPUSH
99683: LD_INT 1
99685: PPUSH
99686: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
99690: LD_INT 9
99692: PPUSH
99693: LD_OWVAR 2
99697: PPUSH
99698: CALL_OW 343
// uc_side := 9 ;
99702: LD_ADDR_OWVAR 20
99706: PUSH
99707: LD_INT 9
99709: ST_TO_ADDR
// uc_nation := 2 ;
99710: LD_ADDR_OWVAR 21
99714: PUSH
99715: LD_INT 2
99717: ST_TO_ADDR
// hc_name := Dark Warrior ;
99718: LD_ADDR_OWVAR 26
99722: PUSH
99723: LD_STRING Dark Warrior
99725: ST_TO_ADDR
// hc_gallery :=  ;
99726: LD_ADDR_OWVAR 33
99730: PUSH
99731: LD_STRING 
99733: ST_TO_ADDR
// hc_noskilllimit := true ;
99734: LD_ADDR_OWVAR 76
99738: PUSH
99739: LD_INT 1
99741: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
99742: LD_ADDR_OWVAR 31
99746: PUSH
99747: LD_INT 30
99749: PUSH
99750: LD_INT 30
99752: PUSH
99753: LD_INT 30
99755: PUSH
99756: LD_INT 30
99758: PUSH
99759: EMPTY
99760: LIST
99761: LIST
99762: LIST
99763: LIST
99764: ST_TO_ADDR
// un := CreateHuman ;
99765: LD_ADDR_VAR 0 3
99769: PUSH
99770: CALL_OW 44
99774: ST_TO_ADDR
// hc_noskilllimit := false ;
99775: LD_ADDR_OWVAR 76
99779: PUSH
99780: LD_INT 0
99782: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99783: LD_VAR 0 3
99787: PPUSH
99788: LD_INT 1
99790: PPUSH
99791: CALL_OW 51
// ToLua ( playRanger() ) ;
99795: LD_STRING playRanger()
99797: PPUSH
99798: CALL_OW 559
// p := 0 ;
99802: LD_ADDR_VAR 0 2
99806: PUSH
99807: LD_INT 0
99809: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
99810: LD_INT 35
99812: PPUSH
99813: CALL_OW 67
// p := p + 1 ;
99817: LD_ADDR_VAR 0 2
99821: PUSH
99822: LD_VAR 0 2
99826: PUSH
99827: LD_INT 1
99829: PLUS
99830: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
99831: LD_VAR 0 3
99835: PPUSH
99836: CALL_OW 256
99840: PUSH
99841: LD_INT 1000
99843: LESS
99844: IFFALSE 99858
// SetLives ( un , 1000 ) ;
99846: LD_VAR 0 3
99850: PPUSH
99851: LD_INT 1000
99853: PPUSH
99854: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
99858: LD_VAR 0 3
99862: PPUSH
99863: LD_INT 81
99865: PUSH
99866: LD_OWVAR 2
99870: PUSH
99871: EMPTY
99872: LIST
99873: LIST
99874: PUSH
99875: LD_INT 91
99877: PUSH
99878: LD_VAR 0 3
99882: PUSH
99883: LD_INT 30
99885: PUSH
99886: EMPTY
99887: LIST
99888: LIST
99889: LIST
99890: PUSH
99891: EMPTY
99892: LIST
99893: LIST
99894: PPUSH
99895: CALL_OW 69
99899: PPUSH
99900: LD_VAR 0 3
99904: PPUSH
99905: CALL_OW 74
99909: PPUSH
99910: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
99914: LD_VAR 0 2
99918: PUSH
99919: LD_INT 80
99921: GREATER
99922: PUSH
99923: LD_VAR 0 3
99927: PPUSH
99928: CALL_OW 301
99932: OR
99933: IFFALSE 99810
// if un then
99935: LD_VAR 0 3
99939: IFFALSE 99950
// RemoveUnit ( un ) ;
99941: LD_VAR 0 3
99945: PPUSH
99946: CALL_OW 64
// end ;
99950: PPOPN 3
99952: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
99953: LD_EXP 161
99957: IFFALSE 100073
99959: GO 99961
99961: DISABLE
99962: LD_INT 0
99964: PPUSH
99965: PPUSH
99966: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
99967: LD_ADDR_VAR 0 2
99971: PUSH
99972: LD_INT 81
99974: PUSH
99975: LD_OWVAR 2
99979: PUSH
99980: EMPTY
99981: LIST
99982: LIST
99983: PUSH
99984: LD_INT 21
99986: PUSH
99987: LD_INT 1
99989: PUSH
99990: EMPTY
99991: LIST
99992: LIST
99993: PUSH
99994: EMPTY
99995: LIST
99996: LIST
99997: PPUSH
99998: CALL_OW 69
100002: ST_TO_ADDR
// ToLua ( playComputer() ) ;
100003: LD_STRING playComputer()
100005: PPUSH
100006: CALL_OW 559
// if not tmp then
100010: LD_VAR 0 2
100014: NOT
100015: IFFALSE 100019
// exit ;
100017: GO 100073
// for i in tmp do
100019: LD_ADDR_VAR 0 1
100023: PUSH
100024: LD_VAR 0 2
100028: PUSH
100029: FOR_IN
100030: IFFALSE 100071
// for j := 1 to 4 do
100032: LD_ADDR_VAR 0 3
100036: PUSH
100037: DOUBLE
100038: LD_INT 1
100040: DEC
100041: ST_TO_ADDR
100042: LD_INT 4
100044: PUSH
100045: FOR_TO
100046: IFFALSE 100067
// SetSkill ( i , j , 10 ) ;
100048: LD_VAR 0 1
100052: PPUSH
100053: LD_VAR 0 3
100057: PPUSH
100058: LD_INT 10
100060: PPUSH
100061: CALL_OW 237
100065: GO 100045
100067: POP
100068: POP
100069: GO 100029
100071: POP
100072: POP
// end ;
100073: PPOPN 3
100075: END
// every 0 0$1 trigger s30 do var i , tmp ;
100076: LD_EXP 162
100080: IFFALSE 100149
100082: GO 100084
100084: DISABLE
100085: LD_INT 0
100087: PPUSH
100088: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100089: LD_ADDR_VAR 0 2
100093: PUSH
100094: LD_INT 22
100096: PUSH
100097: LD_OWVAR 2
100101: PUSH
100102: EMPTY
100103: LIST
100104: LIST
100105: PPUSH
100106: CALL_OW 69
100110: ST_TO_ADDR
// if not tmp then
100111: LD_VAR 0 2
100115: NOT
100116: IFFALSE 100120
// exit ;
100118: GO 100149
// for i in tmp do
100120: LD_ADDR_VAR 0 1
100124: PUSH
100125: LD_VAR 0 2
100129: PUSH
100130: FOR_IN
100131: IFFALSE 100147
// SetLives ( i , 300 ) ;
100133: LD_VAR 0 1
100137: PPUSH
100138: LD_INT 300
100140: PPUSH
100141: CALL_OW 234
100145: GO 100130
100147: POP
100148: POP
// end ;
100149: PPOPN 2
100151: END
// every 0 0$1 trigger s60 do var i , tmp ;
100152: LD_EXP 163
100156: IFFALSE 100225
100158: GO 100160
100160: DISABLE
100161: LD_INT 0
100163: PPUSH
100164: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100165: LD_ADDR_VAR 0 2
100169: PUSH
100170: LD_INT 22
100172: PUSH
100173: LD_OWVAR 2
100177: PUSH
100178: EMPTY
100179: LIST
100180: LIST
100181: PPUSH
100182: CALL_OW 69
100186: ST_TO_ADDR
// if not tmp then
100187: LD_VAR 0 2
100191: NOT
100192: IFFALSE 100196
// exit ;
100194: GO 100225
// for i in tmp do
100196: LD_ADDR_VAR 0 1
100200: PUSH
100201: LD_VAR 0 2
100205: PUSH
100206: FOR_IN
100207: IFFALSE 100223
// SetLives ( i , 600 ) ;
100209: LD_VAR 0 1
100213: PPUSH
100214: LD_INT 600
100216: PPUSH
100217: CALL_OW 234
100221: GO 100206
100223: POP
100224: POP
// end ;
100225: PPOPN 2
100227: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
100228: LD_INT 0
100230: PPUSH
// case cmd of 301 :
100231: LD_VAR 0 1
100235: PUSH
100236: LD_INT 301
100238: DOUBLE
100239: EQUAL
100240: IFTRUE 100244
100242: GO 100276
100244: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
100245: LD_VAR 0 6
100249: PPUSH
100250: LD_VAR 0 7
100254: PPUSH
100255: LD_VAR 0 8
100259: PPUSH
100260: LD_VAR 0 4
100264: PPUSH
100265: LD_VAR 0 5
100269: PPUSH
100270: CALL 101485 0 5
100274: GO 100397
100276: LD_INT 302
100278: DOUBLE
100279: EQUAL
100280: IFTRUE 100284
100282: GO 100321
100284: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
100285: LD_VAR 0 6
100289: PPUSH
100290: LD_VAR 0 7
100294: PPUSH
100295: LD_VAR 0 8
100299: PPUSH
100300: LD_VAR 0 9
100304: PPUSH
100305: LD_VAR 0 4
100309: PPUSH
100310: LD_VAR 0 5
100314: PPUSH
100315: CALL 101576 0 6
100319: GO 100397
100321: LD_INT 303
100323: DOUBLE
100324: EQUAL
100325: IFTRUE 100329
100327: GO 100366
100329: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
100330: LD_VAR 0 6
100334: PPUSH
100335: LD_VAR 0 7
100339: PPUSH
100340: LD_VAR 0 8
100344: PPUSH
100345: LD_VAR 0 9
100349: PPUSH
100350: LD_VAR 0 4
100354: PPUSH
100355: LD_VAR 0 5
100359: PPUSH
100360: CALL 100402 0 6
100364: GO 100397
100366: LD_INT 304
100368: DOUBLE
100369: EQUAL
100370: IFTRUE 100374
100372: GO 100396
100374: POP
// hHackTeleport ( unit , x , y ) ; end ;
100375: LD_VAR 0 2
100379: PPUSH
100380: LD_VAR 0 4
100384: PPUSH
100385: LD_VAR 0 5
100389: PPUSH
100390: CALL 102169 0 3
100394: GO 100397
100396: POP
// end ;
100397: LD_VAR 0 12
100401: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
100402: LD_INT 0
100404: PPUSH
100405: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
100406: LD_VAR 0 1
100410: PUSH
100411: LD_INT 1
100413: LESS
100414: PUSH
100415: LD_VAR 0 1
100419: PUSH
100420: LD_INT 3
100422: GREATER
100423: OR
100424: PUSH
100425: LD_VAR 0 5
100429: PPUSH
100430: LD_VAR 0 6
100434: PPUSH
100435: CALL_OW 428
100439: OR
100440: IFFALSE 100444
// exit ;
100442: GO 101172
// uc_side := your_side ;
100444: LD_ADDR_OWVAR 20
100448: PUSH
100449: LD_OWVAR 2
100453: ST_TO_ADDR
// uc_nation := nation ;
100454: LD_ADDR_OWVAR 21
100458: PUSH
100459: LD_VAR 0 1
100463: ST_TO_ADDR
// bc_level = 1 ;
100464: LD_ADDR_OWVAR 43
100468: PUSH
100469: LD_INT 1
100471: ST_TO_ADDR
// case btype of 1 :
100472: LD_VAR 0 2
100476: PUSH
100477: LD_INT 1
100479: DOUBLE
100480: EQUAL
100481: IFTRUE 100485
100483: GO 100496
100485: POP
// bc_type := b_depot ; 2 :
100486: LD_ADDR_OWVAR 42
100490: PUSH
100491: LD_INT 0
100493: ST_TO_ADDR
100494: GO 101116
100496: LD_INT 2
100498: DOUBLE
100499: EQUAL
100500: IFTRUE 100504
100502: GO 100515
100504: POP
// bc_type := b_warehouse ; 3 :
100505: LD_ADDR_OWVAR 42
100509: PUSH
100510: LD_INT 1
100512: ST_TO_ADDR
100513: GO 101116
100515: LD_INT 3
100517: DOUBLE
100518: EQUAL
100519: IFTRUE 100523
100521: GO 100534
100523: POP
// bc_type := b_lab ; 4 .. 9 :
100524: LD_ADDR_OWVAR 42
100528: PUSH
100529: LD_INT 6
100531: ST_TO_ADDR
100532: GO 101116
100534: LD_INT 4
100536: DOUBLE
100537: GREATEREQUAL
100538: IFFALSE 100546
100540: LD_INT 9
100542: DOUBLE
100543: LESSEQUAL
100544: IFTRUE 100548
100546: GO 100608
100548: POP
// begin bc_type := b_lab_half ;
100549: LD_ADDR_OWVAR 42
100553: PUSH
100554: LD_INT 7
100556: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
100557: LD_ADDR_OWVAR 44
100561: PUSH
100562: LD_INT 10
100564: PUSH
100565: LD_INT 11
100567: PUSH
100568: LD_INT 12
100570: PUSH
100571: LD_INT 15
100573: PUSH
100574: LD_INT 14
100576: PUSH
100577: LD_INT 13
100579: PUSH
100580: EMPTY
100581: LIST
100582: LIST
100583: LIST
100584: LIST
100585: LIST
100586: LIST
100587: PUSH
100588: LD_VAR 0 2
100592: PUSH
100593: LD_INT 3
100595: MINUS
100596: ARRAY
100597: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
100598: LD_ADDR_OWVAR 45
100602: PUSH
100603: LD_INT 9
100605: ST_TO_ADDR
// end ; 10 .. 13 :
100606: GO 101116
100608: LD_INT 10
100610: DOUBLE
100611: GREATEREQUAL
100612: IFFALSE 100620
100614: LD_INT 13
100616: DOUBLE
100617: LESSEQUAL
100618: IFTRUE 100622
100620: GO 100699
100622: POP
// begin bc_type := b_lab_full ;
100623: LD_ADDR_OWVAR 42
100627: PUSH
100628: LD_INT 8
100630: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
100631: LD_ADDR_OWVAR 44
100635: PUSH
100636: LD_INT 10
100638: PUSH
100639: LD_INT 12
100641: PUSH
100642: LD_INT 14
100644: PUSH
100645: LD_INT 13
100647: PUSH
100648: EMPTY
100649: LIST
100650: LIST
100651: LIST
100652: LIST
100653: PUSH
100654: LD_VAR 0 2
100658: PUSH
100659: LD_INT 9
100661: MINUS
100662: ARRAY
100663: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
100664: LD_ADDR_OWVAR 45
100668: PUSH
100669: LD_INT 11
100671: PUSH
100672: LD_INT 15
100674: PUSH
100675: LD_INT 12
100677: PUSH
100678: LD_INT 15
100680: PUSH
100681: EMPTY
100682: LIST
100683: LIST
100684: LIST
100685: LIST
100686: PUSH
100687: LD_VAR 0 2
100691: PUSH
100692: LD_INT 9
100694: MINUS
100695: ARRAY
100696: ST_TO_ADDR
// end ; 14 :
100697: GO 101116
100699: LD_INT 14
100701: DOUBLE
100702: EQUAL
100703: IFTRUE 100707
100705: GO 100718
100707: POP
// bc_type := b_workshop ; 15 :
100708: LD_ADDR_OWVAR 42
100712: PUSH
100713: LD_INT 2
100715: ST_TO_ADDR
100716: GO 101116
100718: LD_INT 15
100720: DOUBLE
100721: EQUAL
100722: IFTRUE 100726
100724: GO 100737
100726: POP
// bc_type := b_factory ; 16 :
100727: LD_ADDR_OWVAR 42
100731: PUSH
100732: LD_INT 3
100734: ST_TO_ADDR
100735: GO 101116
100737: LD_INT 16
100739: DOUBLE
100740: EQUAL
100741: IFTRUE 100745
100743: GO 100756
100745: POP
// bc_type := b_ext_gun ; 17 :
100746: LD_ADDR_OWVAR 42
100750: PUSH
100751: LD_INT 17
100753: ST_TO_ADDR
100754: GO 101116
100756: LD_INT 17
100758: DOUBLE
100759: EQUAL
100760: IFTRUE 100764
100762: GO 100792
100764: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
100765: LD_ADDR_OWVAR 42
100769: PUSH
100770: LD_INT 19
100772: PUSH
100773: LD_INT 23
100775: PUSH
100776: LD_INT 19
100778: PUSH
100779: EMPTY
100780: LIST
100781: LIST
100782: LIST
100783: PUSH
100784: LD_VAR 0 1
100788: ARRAY
100789: ST_TO_ADDR
100790: GO 101116
100792: LD_INT 18
100794: DOUBLE
100795: EQUAL
100796: IFTRUE 100800
100798: GO 100811
100800: POP
// bc_type := b_ext_radar ; 19 :
100801: LD_ADDR_OWVAR 42
100805: PUSH
100806: LD_INT 20
100808: ST_TO_ADDR
100809: GO 101116
100811: LD_INT 19
100813: DOUBLE
100814: EQUAL
100815: IFTRUE 100819
100817: GO 100830
100819: POP
// bc_type := b_ext_radio ; 20 :
100820: LD_ADDR_OWVAR 42
100824: PUSH
100825: LD_INT 22
100827: ST_TO_ADDR
100828: GO 101116
100830: LD_INT 20
100832: DOUBLE
100833: EQUAL
100834: IFTRUE 100838
100836: GO 100849
100838: POP
// bc_type := b_ext_siberium ; 21 :
100839: LD_ADDR_OWVAR 42
100843: PUSH
100844: LD_INT 21
100846: ST_TO_ADDR
100847: GO 101116
100849: LD_INT 21
100851: DOUBLE
100852: EQUAL
100853: IFTRUE 100857
100855: GO 100868
100857: POP
// bc_type := b_ext_computer ; 22 :
100858: LD_ADDR_OWVAR 42
100862: PUSH
100863: LD_INT 24
100865: ST_TO_ADDR
100866: GO 101116
100868: LD_INT 22
100870: DOUBLE
100871: EQUAL
100872: IFTRUE 100876
100874: GO 100887
100876: POP
// bc_type := b_ext_track ; 23 :
100877: LD_ADDR_OWVAR 42
100881: PUSH
100882: LD_INT 16
100884: ST_TO_ADDR
100885: GO 101116
100887: LD_INT 23
100889: DOUBLE
100890: EQUAL
100891: IFTRUE 100895
100893: GO 100906
100895: POP
// bc_type := b_ext_laser ; 24 :
100896: LD_ADDR_OWVAR 42
100900: PUSH
100901: LD_INT 25
100903: ST_TO_ADDR
100904: GO 101116
100906: LD_INT 24
100908: DOUBLE
100909: EQUAL
100910: IFTRUE 100914
100912: GO 100925
100914: POP
// bc_type := b_control_tower ; 25 :
100915: LD_ADDR_OWVAR 42
100919: PUSH
100920: LD_INT 36
100922: ST_TO_ADDR
100923: GO 101116
100925: LD_INT 25
100927: DOUBLE
100928: EQUAL
100929: IFTRUE 100933
100931: GO 100944
100933: POP
// bc_type := b_breastwork ; 26 :
100934: LD_ADDR_OWVAR 42
100938: PUSH
100939: LD_INT 31
100941: ST_TO_ADDR
100942: GO 101116
100944: LD_INT 26
100946: DOUBLE
100947: EQUAL
100948: IFTRUE 100952
100950: GO 100963
100952: POP
// bc_type := b_bunker ; 27 :
100953: LD_ADDR_OWVAR 42
100957: PUSH
100958: LD_INT 32
100960: ST_TO_ADDR
100961: GO 101116
100963: LD_INT 27
100965: DOUBLE
100966: EQUAL
100967: IFTRUE 100971
100969: GO 100982
100971: POP
// bc_type := b_turret ; 28 :
100972: LD_ADDR_OWVAR 42
100976: PUSH
100977: LD_INT 33
100979: ST_TO_ADDR
100980: GO 101116
100982: LD_INT 28
100984: DOUBLE
100985: EQUAL
100986: IFTRUE 100990
100988: GO 101001
100990: POP
// bc_type := b_armoury ; 29 :
100991: LD_ADDR_OWVAR 42
100995: PUSH
100996: LD_INT 4
100998: ST_TO_ADDR
100999: GO 101116
101001: LD_INT 29
101003: DOUBLE
101004: EQUAL
101005: IFTRUE 101009
101007: GO 101020
101009: POP
// bc_type := b_barracks ; 30 :
101010: LD_ADDR_OWVAR 42
101014: PUSH
101015: LD_INT 5
101017: ST_TO_ADDR
101018: GO 101116
101020: LD_INT 30
101022: DOUBLE
101023: EQUAL
101024: IFTRUE 101028
101026: GO 101039
101028: POP
// bc_type := b_solar_power ; 31 :
101029: LD_ADDR_OWVAR 42
101033: PUSH
101034: LD_INT 27
101036: ST_TO_ADDR
101037: GO 101116
101039: LD_INT 31
101041: DOUBLE
101042: EQUAL
101043: IFTRUE 101047
101045: GO 101058
101047: POP
// bc_type := b_oil_power ; 32 :
101048: LD_ADDR_OWVAR 42
101052: PUSH
101053: LD_INT 26
101055: ST_TO_ADDR
101056: GO 101116
101058: LD_INT 32
101060: DOUBLE
101061: EQUAL
101062: IFTRUE 101066
101064: GO 101077
101066: POP
// bc_type := b_siberite_power ; 33 :
101067: LD_ADDR_OWVAR 42
101071: PUSH
101072: LD_INT 28
101074: ST_TO_ADDR
101075: GO 101116
101077: LD_INT 33
101079: DOUBLE
101080: EQUAL
101081: IFTRUE 101085
101083: GO 101096
101085: POP
// bc_type := b_oil_mine ; 34 :
101086: LD_ADDR_OWVAR 42
101090: PUSH
101091: LD_INT 29
101093: ST_TO_ADDR
101094: GO 101116
101096: LD_INT 34
101098: DOUBLE
101099: EQUAL
101100: IFTRUE 101104
101102: GO 101115
101104: POP
// bc_type := b_siberite_mine ; end ;
101105: LD_ADDR_OWVAR 42
101109: PUSH
101110: LD_INT 30
101112: ST_TO_ADDR
101113: GO 101116
101115: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
101116: LD_ADDR_VAR 0 8
101120: PUSH
101121: LD_VAR 0 5
101125: PPUSH
101126: LD_VAR 0 6
101130: PPUSH
101131: LD_VAR 0 3
101135: PPUSH
101136: CALL_OW 47
101140: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
101141: LD_OWVAR 42
101145: PUSH
101146: LD_INT 32
101148: PUSH
101149: LD_INT 33
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: IN
101156: IFFALSE 101172
// PlaceWeaponTurret ( b , weapon ) ;
101158: LD_VAR 0 8
101162: PPUSH
101163: LD_VAR 0 4
101167: PPUSH
101168: CALL_OW 431
// end ;
101172: LD_VAR 0 7
101176: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
101177: LD_INT 0
101179: PPUSH
101180: PPUSH
101181: PPUSH
101182: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101183: LD_ADDR_VAR 0 4
101187: PUSH
101188: LD_INT 22
101190: PUSH
101191: LD_OWVAR 2
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: PUSH
101200: LD_INT 2
101202: PUSH
101203: LD_INT 30
101205: PUSH
101206: LD_INT 0
101208: PUSH
101209: EMPTY
101210: LIST
101211: LIST
101212: PUSH
101213: LD_INT 30
101215: PUSH
101216: LD_INT 1
101218: PUSH
101219: EMPTY
101220: LIST
101221: LIST
101222: PUSH
101223: EMPTY
101224: LIST
101225: LIST
101226: LIST
101227: PUSH
101228: EMPTY
101229: LIST
101230: LIST
101231: PPUSH
101232: CALL_OW 69
101236: ST_TO_ADDR
// if not tmp then
101237: LD_VAR 0 4
101241: NOT
101242: IFFALSE 101246
// exit ;
101244: GO 101305
// for i in tmp do
101246: LD_ADDR_VAR 0 2
101250: PUSH
101251: LD_VAR 0 4
101255: PUSH
101256: FOR_IN
101257: IFFALSE 101303
// for j = 1 to 3 do
101259: LD_ADDR_VAR 0 3
101263: PUSH
101264: DOUBLE
101265: LD_INT 1
101267: DEC
101268: ST_TO_ADDR
101269: LD_INT 3
101271: PUSH
101272: FOR_TO
101273: IFFALSE 101299
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
101275: LD_VAR 0 2
101279: PPUSH
101280: CALL_OW 274
101284: PPUSH
101285: LD_VAR 0 3
101289: PPUSH
101290: LD_INT 99999
101292: PPUSH
101293: CALL_OW 277
101297: GO 101272
101299: POP
101300: POP
101301: GO 101256
101303: POP
101304: POP
// end ;
101305: LD_VAR 0 1
101309: RET
// export function hHackSetLevel10 ; var i , j ; begin
101310: LD_INT 0
101312: PPUSH
101313: PPUSH
101314: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101315: LD_ADDR_VAR 0 2
101319: PUSH
101320: LD_INT 21
101322: PUSH
101323: LD_INT 1
101325: PUSH
101326: EMPTY
101327: LIST
101328: LIST
101329: PPUSH
101330: CALL_OW 69
101334: PUSH
101335: FOR_IN
101336: IFFALSE 101388
// if IsSelected ( i ) then
101338: LD_VAR 0 2
101342: PPUSH
101343: CALL_OW 306
101347: IFFALSE 101386
// begin for j := 1 to 4 do
101349: LD_ADDR_VAR 0 3
101353: PUSH
101354: DOUBLE
101355: LD_INT 1
101357: DEC
101358: ST_TO_ADDR
101359: LD_INT 4
101361: PUSH
101362: FOR_TO
101363: IFFALSE 101384
// SetSkill ( i , j , 10 ) ;
101365: LD_VAR 0 2
101369: PPUSH
101370: LD_VAR 0 3
101374: PPUSH
101375: LD_INT 10
101377: PPUSH
101378: CALL_OW 237
101382: GO 101362
101384: POP
101385: POP
// end ;
101386: GO 101335
101388: POP
101389: POP
// end ;
101390: LD_VAR 0 1
101394: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
101395: LD_INT 0
101397: PPUSH
101398: PPUSH
101399: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
101400: LD_ADDR_VAR 0 2
101404: PUSH
101405: LD_INT 22
101407: PUSH
101408: LD_OWVAR 2
101412: PUSH
101413: EMPTY
101414: LIST
101415: LIST
101416: PUSH
101417: LD_INT 21
101419: PUSH
101420: LD_INT 1
101422: PUSH
101423: EMPTY
101424: LIST
101425: LIST
101426: PUSH
101427: EMPTY
101428: LIST
101429: LIST
101430: PPUSH
101431: CALL_OW 69
101435: PUSH
101436: FOR_IN
101437: IFFALSE 101478
// begin for j := 1 to 4 do
101439: LD_ADDR_VAR 0 3
101443: PUSH
101444: DOUBLE
101445: LD_INT 1
101447: DEC
101448: ST_TO_ADDR
101449: LD_INT 4
101451: PUSH
101452: FOR_TO
101453: IFFALSE 101474
// SetSkill ( i , j , 10 ) ;
101455: LD_VAR 0 2
101459: PPUSH
101460: LD_VAR 0 3
101464: PPUSH
101465: LD_INT 10
101467: PPUSH
101468: CALL_OW 237
101472: GO 101452
101474: POP
101475: POP
// end ;
101476: GO 101436
101478: POP
101479: POP
// end ;
101480: LD_VAR 0 1
101484: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
101485: LD_INT 0
101487: PPUSH
// uc_side := your_side ;
101488: LD_ADDR_OWVAR 20
101492: PUSH
101493: LD_OWVAR 2
101497: ST_TO_ADDR
// uc_nation := nation ;
101498: LD_ADDR_OWVAR 21
101502: PUSH
101503: LD_VAR 0 1
101507: ST_TO_ADDR
// InitHc ;
101508: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
101512: LD_INT 0
101514: PPUSH
101515: LD_VAR 0 2
101519: PPUSH
101520: LD_VAR 0 3
101524: PPUSH
101525: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
101529: LD_VAR 0 4
101533: PPUSH
101534: LD_VAR 0 5
101538: PPUSH
101539: CALL_OW 428
101543: PUSH
101544: LD_INT 0
101546: EQUAL
101547: IFFALSE 101571
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
101549: CALL_OW 44
101553: PPUSH
101554: LD_VAR 0 4
101558: PPUSH
101559: LD_VAR 0 5
101563: PPUSH
101564: LD_INT 1
101566: PPUSH
101567: CALL_OW 48
// end ;
101571: LD_VAR 0 6
101575: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
101576: LD_INT 0
101578: PPUSH
101579: PPUSH
// uc_side := your_side ;
101580: LD_ADDR_OWVAR 20
101584: PUSH
101585: LD_OWVAR 2
101589: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
101590: LD_VAR 0 1
101594: PUSH
101595: LD_INT 1
101597: PUSH
101598: LD_INT 2
101600: PUSH
101601: LD_INT 3
101603: PUSH
101604: LD_INT 4
101606: PUSH
101607: LD_INT 5
101609: PUSH
101610: EMPTY
101611: LIST
101612: LIST
101613: LIST
101614: LIST
101615: LIST
101616: IN
101617: IFFALSE 101629
// uc_nation := nation_american else
101619: LD_ADDR_OWVAR 21
101623: PUSH
101624: LD_INT 1
101626: ST_TO_ADDR
101627: GO 101672
// if chassis in [ 11 , 12 , 13 , 14 ] then
101629: LD_VAR 0 1
101633: PUSH
101634: LD_INT 11
101636: PUSH
101637: LD_INT 12
101639: PUSH
101640: LD_INT 13
101642: PUSH
101643: LD_INT 14
101645: PUSH
101646: EMPTY
101647: LIST
101648: LIST
101649: LIST
101650: LIST
101651: IN
101652: IFFALSE 101664
// uc_nation := nation_arabian else
101654: LD_ADDR_OWVAR 21
101658: PUSH
101659: LD_INT 2
101661: ST_TO_ADDR
101662: GO 101672
// uc_nation := nation_russian ;
101664: LD_ADDR_OWVAR 21
101668: PUSH
101669: LD_INT 3
101671: ST_TO_ADDR
// vc_chassis := chassis ;
101672: LD_ADDR_OWVAR 37
101676: PUSH
101677: LD_VAR 0 1
101681: ST_TO_ADDR
// vc_engine := engine ;
101682: LD_ADDR_OWVAR 39
101686: PUSH
101687: LD_VAR 0 2
101691: ST_TO_ADDR
// vc_control := control ;
101692: LD_ADDR_OWVAR 38
101696: PUSH
101697: LD_VAR 0 3
101701: ST_TO_ADDR
// vc_weapon := weapon ;
101702: LD_ADDR_OWVAR 40
101706: PUSH
101707: LD_VAR 0 4
101711: ST_TO_ADDR
// un := CreateVehicle ;
101712: LD_ADDR_VAR 0 8
101716: PUSH
101717: CALL_OW 45
101721: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
101722: LD_VAR 0 8
101726: PPUSH
101727: LD_INT 0
101729: PPUSH
101730: LD_INT 5
101732: PPUSH
101733: CALL_OW 12
101737: PPUSH
101738: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
101742: LD_VAR 0 8
101746: PPUSH
101747: LD_VAR 0 5
101751: PPUSH
101752: LD_VAR 0 6
101756: PPUSH
101757: LD_INT 1
101759: PPUSH
101760: CALL_OW 48
// end ;
101764: LD_VAR 0 7
101768: RET
// export hInvincible ; every 1 do
101769: GO 101771
101771: DISABLE
// hInvincible := [ ] ;
101772: LD_ADDR_EXP 164
101776: PUSH
101777: EMPTY
101778: ST_TO_ADDR
101779: END
// every 10 do var i ;
101780: GO 101782
101782: DISABLE
101783: LD_INT 0
101785: PPUSH
// begin enable ;
101786: ENABLE
// if not hInvincible then
101787: LD_EXP 164
101791: NOT
101792: IFFALSE 101796
// exit ;
101794: GO 101840
// for i in hInvincible do
101796: LD_ADDR_VAR 0 1
101800: PUSH
101801: LD_EXP 164
101805: PUSH
101806: FOR_IN
101807: IFFALSE 101838
// if GetLives ( i ) < 1000 then
101809: LD_VAR 0 1
101813: PPUSH
101814: CALL_OW 256
101818: PUSH
101819: LD_INT 1000
101821: LESS
101822: IFFALSE 101836
// SetLives ( i , 1000 ) ;
101824: LD_VAR 0 1
101828: PPUSH
101829: LD_INT 1000
101831: PPUSH
101832: CALL_OW 234
101836: GO 101806
101838: POP
101839: POP
// end ;
101840: PPOPN 1
101842: END
// export function hHackInvincible ; var i ; begin
101843: LD_INT 0
101845: PPUSH
101846: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
101847: LD_ADDR_VAR 0 2
101851: PUSH
101852: LD_INT 2
101854: PUSH
101855: LD_INT 21
101857: PUSH
101858: LD_INT 1
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: PUSH
101865: LD_INT 21
101867: PUSH
101868: LD_INT 2
101870: PUSH
101871: EMPTY
101872: LIST
101873: LIST
101874: PUSH
101875: EMPTY
101876: LIST
101877: LIST
101878: LIST
101879: PPUSH
101880: CALL_OW 69
101884: PUSH
101885: FOR_IN
101886: IFFALSE 101947
// if IsSelected ( i ) then
101888: LD_VAR 0 2
101892: PPUSH
101893: CALL_OW 306
101897: IFFALSE 101945
// begin if i in hInvincible then
101899: LD_VAR 0 2
101903: PUSH
101904: LD_EXP 164
101908: IN
101909: IFFALSE 101929
// hInvincible := hInvincible diff i else
101911: LD_ADDR_EXP 164
101915: PUSH
101916: LD_EXP 164
101920: PUSH
101921: LD_VAR 0 2
101925: DIFF
101926: ST_TO_ADDR
101927: GO 101945
// hInvincible := hInvincible union i ;
101929: LD_ADDR_EXP 164
101933: PUSH
101934: LD_EXP 164
101938: PUSH
101939: LD_VAR 0 2
101943: UNION
101944: ST_TO_ADDR
// end ;
101945: GO 101885
101947: POP
101948: POP
// end ;
101949: LD_VAR 0 1
101953: RET
// export function hHackInvisible ; var i , j ; begin
101954: LD_INT 0
101956: PPUSH
101957: PPUSH
101958: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
101959: LD_ADDR_VAR 0 2
101963: PUSH
101964: LD_INT 21
101966: PUSH
101967: LD_INT 1
101969: PUSH
101970: EMPTY
101971: LIST
101972: LIST
101973: PPUSH
101974: CALL_OW 69
101978: PUSH
101979: FOR_IN
101980: IFFALSE 102004
// if IsSelected ( i ) then
101982: LD_VAR 0 2
101986: PPUSH
101987: CALL_OW 306
101991: IFFALSE 102002
// ComForceInvisible ( i ) ;
101993: LD_VAR 0 2
101997: PPUSH
101998: CALL_OW 496
102002: GO 101979
102004: POP
102005: POP
// end ;
102006: LD_VAR 0 1
102010: RET
// export function hHackChangeYourSide ; begin
102011: LD_INT 0
102013: PPUSH
// if your_side = 8 then
102014: LD_OWVAR 2
102018: PUSH
102019: LD_INT 8
102021: EQUAL
102022: IFFALSE 102034
// your_side := 0 else
102024: LD_ADDR_OWVAR 2
102028: PUSH
102029: LD_INT 0
102031: ST_TO_ADDR
102032: GO 102048
// your_side := your_side + 1 ;
102034: LD_ADDR_OWVAR 2
102038: PUSH
102039: LD_OWVAR 2
102043: PUSH
102044: LD_INT 1
102046: PLUS
102047: ST_TO_ADDR
// end ;
102048: LD_VAR 0 1
102052: RET
// export function hHackChangeUnitSide ; var i , j ; begin
102053: LD_INT 0
102055: PPUSH
102056: PPUSH
102057: PPUSH
// for i in all_units do
102058: LD_ADDR_VAR 0 2
102062: PUSH
102063: LD_OWVAR 3
102067: PUSH
102068: FOR_IN
102069: IFFALSE 102147
// if IsSelected ( i ) then
102071: LD_VAR 0 2
102075: PPUSH
102076: CALL_OW 306
102080: IFFALSE 102145
// begin j := GetSide ( i ) ;
102082: LD_ADDR_VAR 0 3
102086: PUSH
102087: LD_VAR 0 2
102091: PPUSH
102092: CALL_OW 255
102096: ST_TO_ADDR
// if j = 8 then
102097: LD_VAR 0 3
102101: PUSH
102102: LD_INT 8
102104: EQUAL
102105: IFFALSE 102117
// j := 0 else
102107: LD_ADDR_VAR 0 3
102111: PUSH
102112: LD_INT 0
102114: ST_TO_ADDR
102115: GO 102131
// j := j + 1 ;
102117: LD_ADDR_VAR 0 3
102121: PUSH
102122: LD_VAR 0 3
102126: PUSH
102127: LD_INT 1
102129: PLUS
102130: ST_TO_ADDR
// SetSide ( i , j ) ;
102131: LD_VAR 0 2
102135: PPUSH
102136: LD_VAR 0 3
102140: PPUSH
102141: CALL_OW 235
// end ;
102145: GO 102068
102147: POP
102148: POP
// end ;
102149: LD_VAR 0 1
102153: RET
// export function hHackFog ; begin
102154: LD_INT 0
102156: PPUSH
// FogOff ( true ) ;
102157: LD_INT 1
102159: PPUSH
102160: CALL_OW 344
// end ;
102164: LD_VAR 0 1
102168: RET
// export function hHackTeleport ( unit , x , y ) ; begin
102169: LD_INT 0
102171: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
102172: LD_VAR 0 1
102176: PPUSH
102177: LD_VAR 0 2
102181: PPUSH
102182: LD_VAR 0 3
102186: PPUSH
102187: LD_INT 1
102189: PPUSH
102190: LD_INT 1
102192: PPUSH
102193: CALL_OW 483
// CenterOnXY ( x , y ) ;
102197: LD_VAR 0 2
102201: PPUSH
102202: LD_VAR 0 3
102206: PPUSH
102207: CALL_OW 84
// end ;
102211: LD_VAR 0 4
102215: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
102216: LD_INT 0
102218: PPUSH
102219: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
102220: LD_VAR 0 1
102224: NOT
102225: PUSH
102226: LD_VAR 0 2
102230: PPUSH
102231: LD_VAR 0 3
102235: PPUSH
102236: CALL_OW 488
102240: NOT
102241: OR
102242: PUSH
102243: LD_VAR 0 1
102247: PPUSH
102248: CALL_OW 266
102252: PUSH
102253: LD_INT 3
102255: NONEQUAL
102256: PUSH
102257: LD_VAR 0 1
102261: PPUSH
102262: CALL_OW 247
102266: PUSH
102267: LD_INT 1
102269: EQUAL
102270: NOT
102271: AND
102272: OR
102273: IFFALSE 102277
// exit ;
102275: GO 102426
// if GetType ( factory ) = unit_human then
102277: LD_VAR 0 1
102281: PPUSH
102282: CALL_OW 247
102286: PUSH
102287: LD_INT 1
102289: EQUAL
102290: IFFALSE 102307
// factory := IsInUnit ( factory ) ;
102292: LD_ADDR_VAR 0 1
102296: PUSH
102297: LD_VAR 0 1
102301: PPUSH
102302: CALL_OW 310
102306: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
102307: LD_VAR 0 1
102311: PPUSH
102312: CALL_OW 266
102316: PUSH
102317: LD_INT 3
102319: NONEQUAL
102320: IFFALSE 102324
// exit ;
102322: GO 102426
// if HexInfo ( x , y ) = factory then
102324: LD_VAR 0 2
102328: PPUSH
102329: LD_VAR 0 3
102333: PPUSH
102334: CALL_OW 428
102338: PUSH
102339: LD_VAR 0 1
102343: EQUAL
102344: IFFALSE 102371
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
102346: LD_ADDR_EXP 165
102350: PUSH
102351: LD_EXP 165
102355: PPUSH
102356: LD_VAR 0 1
102360: PPUSH
102361: LD_INT 0
102363: PPUSH
102364: CALL_OW 1
102368: ST_TO_ADDR
102369: GO 102422
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
102371: LD_ADDR_EXP 165
102375: PUSH
102376: LD_EXP 165
102380: PPUSH
102381: LD_VAR 0 1
102385: PPUSH
102386: LD_VAR 0 1
102390: PPUSH
102391: CALL_OW 255
102395: PUSH
102396: LD_VAR 0 1
102400: PUSH
102401: LD_VAR 0 2
102405: PUSH
102406: LD_VAR 0 3
102410: PUSH
102411: EMPTY
102412: LIST
102413: LIST
102414: LIST
102415: LIST
102416: PPUSH
102417: CALL_OW 1
102421: ST_TO_ADDR
// UpdateFactoryWaypoints ;
102422: CALL 102431 0 0
// end ;
102426: LD_VAR 0 4
102430: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
102431: LD_INT 0
102433: PPUSH
102434: PPUSH
102435: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
102436: LD_STRING resetFactoryWaypoint();
102438: PPUSH
102439: CALL_OW 559
// if factoryWaypoints then
102443: LD_EXP 165
102447: IFFALSE 102573
// begin list := PrepareArray ( factoryWaypoints ) ;
102449: LD_ADDR_VAR 0 3
102453: PUSH
102454: LD_EXP 165
102458: PPUSH
102459: CALL 56560 0 1
102463: ST_TO_ADDR
// for i := 1 to list do
102464: LD_ADDR_VAR 0 2
102468: PUSH
102469: DOUBLE
102470: LD_INT 1
102472: DEC
102473: ST_TO_ADDR
102474: LD_VAR 0 3
102478: PUSH
102479: FOR_TO
102480: IFFALSE 102571
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102482: LD_STRING setFactoryWaypointXY(
102484: PUSH
102485: LD_VAR 0 3
102489: PUSH
102490: LD_VAR 0 2
102494: ARRAY
102495: PUSH
102496: LD_INT 1
102498: ARRAY
102499: STR
102500: PUSH
102501: LD_STRING ,
102503: STR
102504: PUSH
102505: LD_VAR 0 3
102509: PUSH
102510: LD_VAR 0 2
102514: ARRAY
102515: PUSH
102516: LD_INT 2
102518: ARRAY
102519: STR
102520: PUSH
102521: LD_STRING ,
102523: STR
102524: PUSH
102525: LD_VAR 0 3
102529: PUSH
102530: LD_VAR 0 2
102534: ARRAY
102535: PUSH
102536: LD_INT 3
102538: ARRAY
102539: STR
102540: PUSH
102541: LD_STRING ,
102543: STR
102544: PUSH
102545: LD_VAR 0 3
102549: PUSH
102550: LD_VAR 0 2
102554: ARRAY
102555: PUSH
102556: LD_INT 4
102558: ARRAY
102559: STR
102560: PUSH
102561: LD_STRING )
102563: STR
102564: PPUSH
102565: CALL_OW 559
102569: GO 102479
102571: POP
102572: POP
// end ; end ;
102573: LD_VAR 0 1
102577: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
102578: LD_INT 0
102580: PPUSH
// if HexInfo ( x , y ) = warehouse then
102581: LD_VAR 0 2
102585: PPUSH
102586: LD_VAR 0 3
102590: PPUSH
102591: CALL_OW 428
102595: PUSH
102596: LD_VAR 0 1
102600: EQUAL
102601: IFFALSE 102628
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
102603: LD_ADDR_EXP 166
102607: PUSH
102608: LD_EXP 166
102612: PPUSH
102613: LD_VAR 0 1
102617: PPUSH
102618: LD_INT 0
102620: PPUSH
102621: CALL_OW 1
102625: ST_TO_ADDR
102626: GO 102679
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
102628: LD_ADDR_EXP 166
102632: PUSH
102633: LD_EXP 166
102637: PPUSH
102638: LD_VAR 0 1
102642: PPUSH
102643: LD_VAR 0 1
102647: PPUSH
102648: CALL_OW 255
102652: PUSH
102653: LD_VAR 0 1
102657: PUSH
102658: LD_VAR 0 2
102662: PUSH
102663: LD_VAR 0 3
102667: PUSH
102668: EMPTY
102669: LIST
102670: LIST
102671: LIST
102672: LIST
102673: PPUSH
102674: CALL_OW 1
102678: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
102679: CALL 102688 0 0
// end ;
102683: LD_VAR 0 4
102687: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
102688: LD_INT 0
102690: PPUSH
102691: PPUSH
102692: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
102693: LD_STRING resetWarehouseGatheringPoints();
102695: PPUSH
102696: CALL_OW 559
// if warehouseGatheringPoints then
102700: LD_EXP 166
102704: IFFALSE 102830
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
102706: LD_ADDR_VAR 0 3
102710: PUSH
102711: LD_EXP 166
102715: PPUSH
102716: CALL 56560 0 1
102720: ST_TO_ADDR
// for i := 1 to list do
102721: LD_ADDR_VAR 0 2
102725: PUSH
102726: DOUBLE
102727: LD_INT 1
102729: DEC
102730: ST_TO_ADDR
102731: LD_VAR 0 3
102735: PUSH
102736: FOR_TO
102737: IFFALSE 102828
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
102739: LD_STRING setWarehouseGatheringPointXY(
102741: PUSH
102742: LD_VAR 0 3
102746: PUSH
102747: LD_VAR 0 2
102751: ARRAY
102752: PUSH
102753: LD_INT 1
102755: ARRAY
102756: STR
102757: PUSH
102758: LD_STRING ,
102760: STR
102761: PUSH
102762: LD_VAR 0 3
102766: PUSH
102767: LD_VAR 0 2
102771: ARRAY
102772: PUSH
102773: LD_INT 2
102775: ARRAY
102776: STR
102777: PUSH
102778: LD_STRING ,
102780: STR
102781: PUSH
102782: LD_VAR 0 3
102786: PUSH
102787: LD_VAR 0 2
102791: ARRAY
102792: PUSH
102793: LD_INT 3
102795: ARRAY
102796: STR
102797: PUSH
102798: LD_STRING ,
102800: STR
102801: PUSH
102802: LD_VAR 0 3
102806: PUSH
102807: LD_VAR 0 2
102811: ARRAY
102812: PUSH
102813: LD_INT 4
102815: ARRAY
102816: STR
102817: PUSH
102818: LD_STRING )
102820: STR
102821: PPUSH
102822: CALL_OW 559
102826: GO 102736
102828: POP
102829: POP
// end ; end ;
102830: LD_VAR 0 1
102834: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
102835: LD_EXP 166
102839: IFFALSE 103524
102841: GO 102843
102843: DISABLE
102844: LD_INT 0
102846: PPUSH
102847: PPUSH
102848: PPUSH
102849: PPUSH
102850: PPUSH
102851: PPUSH
102852: PPUSH
102853: PPUSH
102854: PPUSH
// begin enable ;
102855: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
102856: LD_ADDR_VAR 0 3
102860: PUSH
102861: LD_EXP 166
102865: PPUSH
102866: CALL 56560 0 1
102870: ST_TO_ADDR
// if not list then
102871: LD_VAR 0 3
102875: NOT
102876: IFFALSE 102880
// exit ;
102878: GO 103524
// for i := 1 to list do
102880: LD_ADDR_VAR 0 1
102884: PUSH
102885: DOUBLE
102886: LD_INT 1
102888: DEC
102889: ST_TO_ADDR
102890: LD_VAR 0 3
102894: PUSH
102895: FOR_TO
102896: IFFALSE 103522
// begin depot := list [ i ] [ 2 ] ;
102898: LD_ADDR_VAR 0 8
102902: PUSH
102903: LD_VAR 0 3
102907: PUSH
102908: LD_VAR 0 1
102912: ARRAY
102913: PUSH
102914: LD_INT 2
102916: ARRAY
102917: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
102918: LD_ADDR_VAR 0 5
102922: PUSH
102923: LD_VAR 0 3
102927: PUSH
102928: LD_VAR 0 1
102932: ARRAY
102933: PUSH
102934: LD_INT 1
102936: ARRAY
102937: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
102938: LD_VAR 0 8
102942: PPUSH
102943: CALL_OW 301
102947: PUSH
102948: LD_VAR 0 5
102952: PUSH
102953: LD_VAR 0 8
102957: PPUSH
102958: CALL_OW 255
102962: NONEQUAL
102963: OR
102964: IFFALSE 102993
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
102966: LD_ADDR_EXP 166
102970: PUSH
102971: LD_EXP 166
102975: PPUSH
102976: LD_VAR 0 8
102980: PPUSH
102981: LD_INT 0
102983: PPUSH
102984: CALL_OW 1
102988: ST_TO_ADDR
// exit ;
102989: POP
102990: POP
102991: GO 103524
// end ; x := list [ i ] [ 3 ] ;
102993: LD_ADDR_VAR 0 6
102997: PUSH
102998: LD_VAR 0 3
103002: PUSH
103003: LD_VAR 0 1
103007: ARRAY
103008: PUSH
103009: LD_INT 3
103011: ARRAY
103012: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
103013: LD_ADDR_VAR 0 7
103017: PUSH
103018: LD_VAR 0 3
103022: PUSH
103023: LD_VAR 0 1
103027: ARRAY
103028: PUSH
103029: LD_INT 4
103031: ARRAY
103032: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
103033: LD_ADDR_VAR 0 9
103037: PUSH
103038: LD_VAR 0 6
103042: PPUSH
103043: LD_VAR 0 7
103047: PPUSH
103048: LD_INT 16
103050: PPUSH
103051: CALL 55148 0 3
103055: ST_TO_ADDR
// if not cratesNearbyPoint then
103056: LD_VAR 0 9
103060: NOT
103061: IFFALSE 103067
// exit ;
103063: POP
103064: POP
103065: GO 103524
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
103067: LD_ADDR_VAR 0 4
103071: PUSH
103072: LD_INT 22
103074: PUSH
103075: LD_VAR 0 5
103079: PUSH
103080: EMPTY
103081: LIST
103082: LIST
103083: PUSH
103084: LD_INT 3
103086: PUSH
103087: LD_INT 60
103089: PUSH
103090: EMPTY
103091: LIST
103092: PUSH
103093: EMPTY
103094: LIST
103095: LIST
103096: PUSH
103097: LD_INT 91
103099: PUSH
103100: LD_VAR 0 8
103104: PUSH
103105: LD_INT 6
103107: PUSH
103108: EMPTY
103109: LIST
103110: LIST
103111: LIST
103112: PUSH
103113: LD_INT 2
103115: PUSH
103116: LD_INT 25
103118: PUSH
103119: LD_INT 2
103121: PUSH
103122: EMPTY
103123: LIST
103124: LIST
103125: PUSH
103126: LD_INT 25
103128: PUSH
103129: LD_INT 16
103131: PUSH
103132: EMPTY
103133: LIST
103134: LIST
103135: PUSH
103136: EMPTY
103137: LIST
103138: LIST
103139: LIST
103140: PUSH
103141: EMPTY
103142: LIST
103143: LIST
103144: LIST
103145: LIST
103146: PPUSH
103147: CALL_OW 69
103151: PUSH
103152: LD_VAR 0 8
103156: PPUSH
103157: CALL_OW 313
103161: PPUSH
103162: LD_INT 3
103164: PUSH
103165: LD_INT 60
103167: PUSH
103168: EMPTY
103169: LIST
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: PUSH
103175: LD_INT 2
103177: PUSH
103178: LD_INT 25
103180: PUSH
103181: LD_INT 2
103183: PUSH
103184: EMPTY
103185: LIST
103186: LIST
103187: PUSH
103188: LD_INT 25
103190: PUSH
103191: LD_INT 16
103193: PUSH
103194: EMPTY
103195: LIST
103196: LIST
103197: PUSH
103198: EMPTY
103199: LIST
103200: LIST
103201: LIST
103202: PUSH
103203: EMPTY
103204: LIST
103205: LIST
103206: PPUSH
103207: CALL_OW 72
103211: UNION
103212: ST_TO_ADDR
// if tmp then
103213: LD_VAR 0 4
103217: IFFALSE 103297
// begin tmp := ShrinkArray ( tmp , 3 ) ;
103219: LD_ADDR_VAR 0 4
103223: PUSH
103224: LD_VAR 0 4
103228: PPUSH
103229: LD_INT 3
103231: PPUSH
103232: CALL 53117 0 2
103236: ST_TO_ADDR
// for j in tmp do
103237: LD_ADDR_VAR 0 2
103241: PUSH
103242: LD_VAR 0 4
103246: PUSH
103247: FOR_IN
103248: IFFALSE 103291
// begin if IsInUnit ( j ) then
103250: LD_VAR 0 2
103254: PPUSH
103255: CALL_OW 310
103259: IFFALSE 103270
// ComExit ( j ) ;
103261: LD_VAR 0 2
103265: PPUSH
103266: CALL 53200 0 1
// AddComCollect ( j , x , y ) ;
103270: LD_VAR 0 2
103274: PPUSH
103275: LD_VAR 0 6
103279: PPUSH
103280: LD_VAR 0 7
103284: PPUSH
103285: CALL_OW 177
// end ;
103289: GO 103247
103291: POP
103292: POP
// exit ;
103293: POP
103294: POP
103295: GO 103524
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
103297: LD_ADDR_VAR 0 4
103301: PUSH
103302: LD_INT 22
103304: PUSH
103305: LD_VAR 0 5
103309: PUSH
103310: EMPTY
103311: LIST
103312: LIST
103313: PUSH
103314: LD_INT 91
103316: PUSH
103317: LD_VAR 0 8
103321: PUSH
103322: LD_INT 8
103324: PUSH
103325: EMPTY
103326: LIST
103327: LIST
103328: LIST
103329: PUSH
103330: LD_INT 2
103332: PUSH
103333: LD_INT 34
103335: PUSH
103336: LD_INT 12
103338: PUSH
103339: EMPTY
103340: LIST
103341: LIST
103342: PUSH
103343: LD_INT 34
103345: PUSH
103346: LD_INT 51
103348: PUSH
103349: EMPTY
103350: LIST
103351: LIST
103352: PUSH
103353: LD_INT 34
103355: PUSH
103356: LD_INT 32
103358: PUSH
103359: EMPTY
103360: LIST
103361: LIST
103362: PUSH
103363: LD_INT 34
103365: PUSH
103366: LD_INT 89
103368: PUSH
103369: EMPTY
103370: LIST
103371: LIST
103372: PUSH
103373: EMPTY
103374: LIST
103375: LIST
103376: LIST
103377: LIST
103378: LIST
103379: PUSH
103380: EMPTY
103381: LIST
103382: LIST
103383: LIST
103384: PPUSH
103385: CALL_OW 69
103389: ST_TO_ADDR
// if tmp then
103390: LD_VAR 0 4
103394: IFFALSE 103520
// begin for j in tmp do
103396: LD_ADDR_VAR 0 2
103400: PUSH
103401: LD_VAR 0 4
103405: PUSH
103406: FOR_IN
103407: IFFALSE 103518
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
103409: LD_VAR 0 2
103413: PPUSH
103414: CALL_OW 262
103418: PUSH
103419: LD_INT 3
103421: EQUAL
103422: PUSH
103423: LD_VAR 0 2
103427: PPUSH
103428: CALL_OW 261
103432: PUSH
103433: LD_INT 20
103435: GREATER
103436: OR
103437: PUSH
103438: LD_VAR 0 2
103442: PPUSH
103443: CALL_OW 314
103447: NOT
103448: AND
103449: PUSH
103450: LD_VAR 0 2
103454: PPUSH
103455: CALL_OW 263
103459: PUSH
103460: LD_INT 1
103462: NONEQUAL
103463: PUSH
103464: LD_VAR 0 2
103468: PPUSH
103469: CALL_OW 311
103473: OR
103474: AND
103475: IFFALSE 103516
// begin ComCollect ( j , x , y ) ;
103477: LD_VAR 0 2
103481: PPUSH
103482: LD_VAR 0 6
103486: PPUSH
103487: LD_VAR 0 7
103491: PPUSH
103492: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
103496: LD_VAR 0 2
103500: PPUSH
103501: LD_VAR 0 8
103505: PPUSH
103506: CALL_OW 172
// exit ;
103510: POP
103511: POP
103512: POP
103513: POP
103514: GO 103524
// end ;
103516: GO 103406
103518: POP
103519: POP
// end ; end ;
103520: GO 102895
103522: POP
103523: POP
// end ; end_of_file
103524: PPOPN 9
103526: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
103527: LD_INT 0
103529: PPUSH
103530: PPUSH
103531: PPUSH
103532: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
103533: LD_VAR 0 1
103537: PPUSH
103538: CALL_OW 264
103542: PUSH
103543: LD_INT 91
103545: EQUAL
103546: IFFALSE 103618
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
103548: LD_INT 68
103550: PPUSH
103551: LD_VAR 0 1
103555: PPUSH
103556: CALL_OW 255
103560: PPUSH
103561: CALL_OW 321
103565: PUSH
103566: LD_INT 2
103568: EQUAL
103569: IFFALSE 103581
// eff := 70 else
103571: LD_ADDR_VAR 0 4
103575: PUSH
103576: LD_INT 70
103578: ST_TO_ADDR
103579: GO 103589
// eff := 30 ;
103581: LD_ADDR_VAR 0 4
103585: PUSH
103586: LD_INT 30
103588: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
103589: LD_VAR 0 1
103593: PPUSH
103594: CALL_OW 250
103598: PPUSH
103599: LD_VAR 0 1
103603: PPUSH
103604: CALL_OW 251
103608: PPUSH
103609: LD_VAR 0 4
103613: PPUSH
103614: CALL_OW 495
// end ; end ;
103618: LD_VAR 0 2
103622: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
103623: LD_INT 0
103625: PPUSH
// end ;
103626: LD_VAR 0 4
103630: RET
// export function SOS_Command ( cmd ) ; begin
103631: LD_INT 0
103633: PPUSH
// end ;
103634: LD_VAR 0 2
103638: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
103639: LD_INT 0
103641: PPUSH
// end ;
103642: LD_VAR 0 6
103646: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
103647: LD_INT 0
103649: PPUSH
103650: PPUSH
// if not vehicle or not factory then
103651: LD_VAR 0 1
103655: NOT
103656: PUSH
103657: LD_VAR 0 2
103661: NOT
103662: OR
103663: IFFALSE 103667
// exit ;
103665: GO 103898
// if factoryWaypoints >= factory then
103667: LD_EXP 165
103671: PUSH
103672: LD_VAR 0 2
103676: GREATEREQUAL
103677: IFFALSE 103898
// if factoryWaypoints [ factory ] then
103679: LD_EXP 165
103683: PUSH
103684: LD_VAR 0 2
103688: ARRAY
103689: IFFALSE 103898
// begin if GetControl ( vehicle ) = control_manual then
103691: LD_VAR 0 1
103695: PPUSH
103696: CALL_OW 263
103700: PUSH
103701: LD_INT 1
103703: EQUAL
103704: IFFALSE 103785
// begin driver := IsDrivenBy ( vehicle ) ;
103706: LD_ADDR_VAR 0 4
103710: PUSH
103711: LD_VAR 0 1
103715: PPUSH
103716: CALL_OW 311
103720: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103721: LD_VAR 0 4
103725: PPUSH
103726: LD_EXP 165
103730: PUSH
103731: LD_VAR 0 2
103735: ARRAY
103736: PUSH
103737: LD_INT 3
103739: ARRAY
103740: PPUSH
103741: LD_EXP 165
103745: PUSH
103746: LD_VAR 0 2
103750: ARRAY
103751: PUSH
103752: LD_INT 4
103754: ARRAY
103755: PPUSH
103756: CALL_OW 171
// AddComExitVehicle ( driver ) ;
103760: LD_VAR 0 4
103764: PPUSH
103765: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
103769: LD_VAR 0 4
103773: PPUSH
103774: LD_VAR 0 2
103778: PPUSH
103779: CALL_OW 180
// end else
103783: GO 103898
// if GetControl ( vehicle ) = control_remote then
103785: LD_VAR 0 1
103789: PPUSH
103790: CALL_OW 263
103794: PUSH
103795: LD_INT 2
103797: EQUAL
103798: IFFALSE 103859
// begin wait ( 0 0$2 ) ;
103800: LD_INT 70
103802: PPUSH
103803: CALL_OW 67
// if Connect ( vehicle ) then
103807: LD_VAR 0 1
103811: PPUSH
103812: CALL 23441 0 1
103816: IFFALSE 103857
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103818: LD_VAR 0 1
103822: PPUSH
103823: LD_EXP 165
103827: PUSH
103828: LD_VAR 0 2
103832: ARRAY
103833: PUSH
103834: LD_INT 3
103836: ARRAY
103837: PPUSH
103838: LD_EXP 165
103842: PUSH
103843: LD_VAR 0 2
103847: ARRAY
103848: PUSH
103849: LD_INT 4
103851: ARRAY
103852: PPUSH
103853: CALL_OW 171
// end else
103857: GO 103898
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
103859: LD_VAR 0 1
103863: PPUSH
103864: LD_EXP 165
103868: PUSH
103869: LD_VAR 0 2
103873: ARRAY
103874: PUSH
103875: LD_INT 3
103877: ARRAY
103878: PPUSH
103879: LD_EXP 165
103883: PUSH
103884: LD_VAR 0 2
103888: ARRAY
103889: PUSH
103890: LD_INT 4
103892: ARRAY
103893: PPUSH
103894: CALL_OW 171
// end ; end ;
103898: LD_VAR 0 3
103902: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
103903: LD_INT 0
103905: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
103906: LD_VAR 0 1
103910: PUSH
103911: LD_INT 250
103913: EQUAL
103914: PUSH
103915: LD_VAR 0 2
103919: PPUSH
103920: CALL_OW 264
103924: PUSH
103925: LD_INT 81
103927: EQUAL
103928: AND
103929: IFFALSE 103950
// MinerPlaceMine ( unit , x , y ) ;
103931: LD_VAR 0 2
103935: PPUSH
103936: LD_VAR 0 4
103940: PPUSH
103941: LD_VAR 0 5
103945: PPUSH
103946: CALL 106335 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
103950: LD_VAR 0 1
103954: PUSH
103955: LD_INT 251
103957: EQUAL
103958: PUSH
103959: LD_VAR 0 2
103963: PPUSH
103964: CALL_OW 264
103968: PUSH
103969: LD_INT 81
103971: EQUAL
103972: AND
103973: IFFALSE 103994
// MinerDetonateMine ( unit , x , y ) ;
103975: LD_VAR 0 2
103979: PPUSH
103980: LD_VAR 0 4
103984: PPUSH
103985: LD_VAR 0 5
103989: PPUSH
103990: CALL 106610 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
103994: LD_VAR 0 1
103998: PUSH
103999: LD_INT 252
104001: EQUAL
104002: PUSH
104003: LD_VAR 0 2
104007: PPUSH
104008: CALL_OW 264
104012: PUSH
104013: LD_INT 81
104015: EQUAL
104016: AND
104017: IFFALSE 104038
// MinerCreateMinefield ( unit , x , y ) ;
104019: LD_VAR 0 2
104023: PPUSH
104024: LD_VAR 0 4
104028: PPUSH
104029: LD_VAR 0 5
104033: PPUSH
104034: CALL 107027 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
104038: LD_VAR 0 1
104042: PUSH
104043: LD_INT 253
104045: EQUAL
104046: PUSH
104047: LD_VAR 0 2
104051: PPUSH
104052: CALL_OW 257
104056: PUSH
104057: LD_INT 5
104059: EQUAL
104060: AND
104061: IFFALSE 104082
// ComBinocular ( unit , x , y ) ;
104063: LD_VAR 0 2
104067: PPUSH
104068: LD_VAR 0 4
104072: PPUSH
104073: LD_VAR 0 5
104077: PPUSH
104078: CALL 107396 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
104082: LD_VAR 0 1
104086: PUSH
104087: LD_INT 254
104089: EQUAL
104090: PUSH
104091: LD_VAR 0 2
104095: PPUSH
104096: CALL_OW 264
104100: PUSH
104101: LD_INT 99
104103: EQUAL
104104: AND
104105: PUSH
104106: LD_VAR 0 3
104110: PPUSH
104111: CALL_OW 263
104115: PUSH
104116: LD_INT 3
104118: EQUAL
104119: AND
104120: IFFALSE 104136
// HackDestroyVehicle ( unit , selectedUnit ) ;
104122: LD_VAR 0 2
104126: PPUSH
104127: LD_VAR 0 3
104131: PPUSH
104132: CALL 105699 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
104136: LD_VAR 0 1
104140: PUSH
104141: LD_INT 255
104143: EQUAL
104144: PUSH
104145: LD_VAR 0 2
104149: PPUSH
104150: CALL_OW 264
104154: PUSH
104155: LD_INT 14
104157: PUSH
104158: LD_INT 53
104160: PUSH
104161: EMPTY
104162: LIST
104163: LIST
104164: IN
104165: AND
104166: PUSH
104167: LD_VAR 0 4
104171: PPUSH
104172: LD_VAR 0 5
104176: PPUSH
104177: CALL_OW 488
104181: AND
104182: IFFALSE 104206
// CutTreeXYR ( unit , x , y , 12 ) ;
104184: LD_VAR 0 2
104188: PPUSH
104189: LD_VAR 0 4
104193: PPUSH
104194: LD_VAR 0 5
104198: PPUSH
104199: LD_INT 12
104201: PPUSH
104202: CALL 104269 0 4
// if cmd = 256 then
104206: LD_VAR 0 1
104210: PUSH
104211: LD_INT 256
104213: EQUAL
104214: IFFALSE 104235
// SetFactoryWaypoint ( unit , x , y ) ;
104216: LD_VAR 0 2
104220: PPUSH
104221: LD_VAR 0 4
104225: PPUSH
104226: LD_VAR 0 5
104230: PPUSH
104231: CALL 102216 0 3
// if cmd = 257 then
104235: LD_VAR 0 1
104239: PUSH
104240: LD_INT 257
104242: EQUAL
104243: IFFALSE 104264
// SetWarehouseGatheringPoint ( unit , x , y ) ;
104245: LD_VAR 0 2
104249: PPUSH
104250: LD_VAR 0 4
104254: PPUSH
104255: LD_VAR 0 5
104259: PPUSH
104260: CALL 102578 0 3
// end ;
104264: LD_VAR 0 6
104268: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
104269: LD_INT 0
104271: PPUSH
104272: PPUSH
104273: PPUSH
104274: PPUSH
104275: PPUSH
104276: PPUSH
104277: PPUSH
104278: PPUSH
104279: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
104280: LD_VAR 0 1
104284: NOT
104285: PUSH
104286: LD_VAR 0 2
104290: PPUSH
104291: LD_VAR 0 3
104295: PPUSH
104296: CALL_OW 488
104300: NOT
104301: OR
104302: PUSH
104303: LD_VAR 0 4
104307: NOT
104308: OR
104309: IFFALSE 104313
// exit ;
104311: GO 104653
// list := [ ] ;
104313: LD_ADDR_VAR 0 13
104317: PUSH
104318: EMPTY
104319: ST_TO_ADDR
// if x - r < 0 then
104320: LD_VAR 0 2
104324: PUSH
104325: LD_VAR 0 4
104329: MINUS
104330: PUSH
104331: LD_INT 0
104333: LESS
104334: IFFALSE 104346
// min_x := 0 else
104336: LD_ADDR_VAR 0 7
104340: PUSH
104341: LD_INT 0
104343: ST_TO_ADDR
104344: GO 104362
// min_x := x - r ;
104346: LD_ADDR_VAR 0 7
104350: PUSH
104351: LD_VAR 0 2
104355: PUSH
104356: LD_VAR 0 4
104360: MINUS
104361: ST_TO_ADDR
// if y - r < 0 then
104362: LD_VAR 0 3
104366: PUSH
104367: LD_VAR 0 4
104371: MINUS
104372: PUSH
104373: LD_INT 0
104375: LESS
104376: IFFALSE 104388
// min_y := 0 else
104378: LD_ADDR_VAR 0 8
104382: PUSH
104383: LD_INT 0
104385: ST_TO_ADDR
104386: GO 104404
// min_y := y - r ;
104388: LD_ADDR_VAR 0 8
104392: PUSH
104393: LD_VAR 0 3
104397: PUSH
104398: LD_VAR 0 4
104402: MINUS
104403: ST_TO_ADDR
// max_x := x + r ;
104404: LD_ADDR_VAR 0 9
104408: PUSH
104409: LD_VAR 0 2
104413: PUSH
104414: LD_VAR 0 4
104418: PLUS
104419: ST_TO_ADDR
// max_y := y + r ;
104420: LD_ADDR_VAR 0 10
104424: PUSH
104425: LD_VAR 0 3
104429: PUSH
104430: LD_VAR 0 4
104434: PLUS
104435: ST_TO_ADDR
// for _x = min_x to max_x do
104436: LD_ADDR_VAR 0 11
104440: PUSH
104441: DOUBLE
104442: LD_VAR 0 7
104446: DEC
104447: ST_TO_ADDR
104448: LD_VAR 0 9
104452: PUSH
104453: FOR_TO
104454: IFFALSE 104571
// for _y = min_y to max_y do
104456: LD_ADDR_VAR 0 12
104460: PUSH
104461: DOUBLE
104462: LD_VAR 0 8
104466: DEC
104467: ST_TO_ADDR
104468: LD_VAR 0 10
104472: PUSH
104473: FOR_TO
104474: IFFALSE 104567
// begin if not ValidHex ( _x , _y ) then
104476: LD_VAR 0 11
104480: PPUSH
104481: LD_VAR 0 12
104485: PPUSH
104486: CALL_OW 488
104490: NOT
104491: IFFALSE 104495
// continue ;
104493: GO 104473
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
104495: LD_VAR 0 11
104499: PPUSH
104500: LD_VAR 0 12
104504: PPUSH
104505: CALL_OW 351
104509: PUSH
104510: LD_VAR 0 11
104514: PPUSH
104515: LD_VAR 0 12
104519: PPUSH
104520: CALL_OW 554
104524: AND
104525: IFFALSE 104565
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
104527: LD_ADDR_VAR 0 13
104531: PUSH
104532: LD_VAR 0 13
104536: PPUSH
104537: LD_VAR 0 13
104541: PUSH
104542: LD_INT 1
104544: PLUS
104545: PPUSH
104546: LD_VAR 0 11
104550: PUSH
104551: LD_VAR 0 12
104555: PUSH
104556: EMPTY
104557: LIST
104558: LIST
104559: PPUSH
104560: CALL_OW 2
104564: ST_TO_ADDR
// end ;
104565: GO 104473
104567: POP
104568: POP
104569: GO 104453
104571: POP
104572: POP
// if not list then
104573: LD_VAR 0 13
104577: NOT
104578: IFFALSE 104582
// exit ;
104580: GO 104653
// for i in list do
104582: LD_ADDR_VAR 0 6
104586: PUSH
104587: LD_VAR 0 13
104591: PUSH
104592: FOR_IN
104593: IFFALSE 104651
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
104595: LD_VAR 0 1
104599: PPUSH
104600: LD_STRING M
104602: PUSH
104603: LD_VAR 0 6
104607: PUSH
104608: LD_INT 1
104610: ARRAY
104611: PUSH
104612: LD_VAR 0 6
104616: PUSH
104617: LD_INT 2
104619: ARRAY
104620: PUSH
104621: LD_INT 0
104623: PUSH
104624: LD_INT 0
104626: PUSH
104627: LD_INT 0
104629: PUSH
104630: LD_INT 0
104632: PUSH
104633: EMPTY
104634: LIST
104635: LIST
104636: LIST
104637: LIST
104638: LIST
104639: LIST
104640: LIST
104641: PUSH
104642: EMPTY
104643: LIST
104644: PPUSH
104645: CALL_OW 447
104649: GO 104592
104651: POP
104652: POP
// end ;
104653: LD_VAR 0 5
104657: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
104658: LD_EXP 168
104662: NOT
104663: IFFALSE 104713
104665: GO 104667
104667: DISABLE
// begin initHack := true ;
104668: LD_ADDR_EXP 168
104672: PUSH
104673: LD_INT 1
104675: ST_TO_ADDR
// hackTanks := [ ] ;
104676: LD_ADDR_EXP 169
104680: PUSH
104681: EMPTY
104682: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
104683: LD_ADDR_EXP 170
104687: PUSH
104688: EMPTY
104689: ST_TO_ADDR
// hackLimit := 3 ;
104690: LD_ADDR_EXP 171
104694: PUSH
104695: LD_INT 3
104697: ST_TO_ADDR
// hackDist := 12 ;
104698: LD_ADDR_EXP 172
104702: PUSH
104703: LD_INT 12
104705: ST_TO_ADDR
// hackCounter := [ ] ;
104706: LD_ADDR_EXP 173
104710: PUSH
104711: EMPTY
104712: ST_TO_ADDR
// end ;
104713: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
104714: LD_EXP 168
104718: PUSH
104719: LD_INT 34
104721: PUSH
104722: LD_INT 99
104724: PUSH
104725: EMPTY
104726: LIST
104727: LIST
104728: PPUSH
104729: CALL_OW 69
104733: AND
104734: IFFALSE 104987
104736: GO 104738
104738: DISABLE
104739: LD_INT 0
104741: PPUSH
104742: PPUSH
// begin enable ;
104743: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
104744: LD_ADDR_VAR 0 1
104748: PUSH
104749: LD_INT 34
104751: PUSH
104752: LD_INT 99
104754: PUSH
104755: EMPTY
104756: LIST
104757: LIST
104758: PPUSH
104759: CALL_OW 69
104763: PUSH
104764: FOR_IN
104765: IFFALSE 104985
// begin if not i in hackTanks then
104767: LD_VAR 0 1
104771: PUSH
104772: LD_EXP 169
104776: IN
104777: NOT
104778: IFFALSE 104861
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
104780: LD_ADDR_EXP 169
104784: PUSH
104785: LD_EXP 169
104789: PPUSH
104790: LD_EXP 169
104794: PUSH
104795: LD_INT 1
104797: PLUS
104798: PPUSH
104799: LD_VAR 0 1
104803: PPUSH
104804: CALL_OW 1
104808: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
104809: LD_ADDR_EXP 170
104813: PUSH
104814: LD_EXP 170
104818: PPUSH
104819: LD_EXP 170
104823: PUSH
104824: LD_INT 1
104826: PLUS
104827: PPUSH
104828: EMPTY
104829: PPUSH
104830: CALL_OW 1
104834: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
104835: LD_ADDR_EXP 173
104839: PUSH
104840: LD_EXP 173
104844: PPUSH
104845: LD_EXP 173
104849: PUSH
104850: LD_INT 1
104852: PLUS
104853: PPUSH
104854: EMPTY
104855: PPUSH
104856: CALL_OW 1
104860: ST_TO_ADDR
// end ; if not IsOk ( i ) then
104861: LD_VAR 0 1
104865: PPUSH
104866: CALL_OW 302
104870: NOT
104871: IFFALSE 104884
// begin HackUnlinkAll ( i ) ;
104873: LD_VAR 0 1
104877: PPUSH
104878: CALL 104990 0 1
// continue ;
104882: GO 104764
// end ; HackCheckCapturedStatus ( i ) ;
104884: LD_VAR 0 1
104888: PPUSH
104889: CALL 105433 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
104893: LD_ADDR_VAR 0 2
104897: PUSH
104898: LD_INT 81
104900: PUSH
104901: LD_VAR 0 1
104905: PPUSH
104906: CALL_OW 255
104910: PUSH
104911: EMPTY
104912: LIST
104913: LIST
104914: PUSH
104915: LD_INT 33
104917: PUSH
104918: LD_INT 3
104920: PUSH
104921: EMPTY
104922: LIST
104923: LIST
104924: PUSH
104925: LD_INT 91
104927: PUSH
104928: LD_VAR 0 1
104932: PUSH
104933: LD_EXP 172
104937: PUSH
104938: EMPTY
104939: LIST
104940: LIST
104941: LIST
104942: PUSH
104943: LD_INT 50
104945: PUSH
104946: EMPTY
104947: LIST
104948: PUSH
104949: EMPTY
104950: LIST
104951: LIST
104952: LIST
104953: LIST
104954: PPUSH
104955: CALL_OW 69
104959: ST_TO_ADDR
// if not tmp then
104960: LD_VAR 0 2
104964: NOT
104965: IFFALSE 104969
// continue ;
104967: GO 104764
// HackLink ( i , tmp ) ;
104969: LD_VAR 0 1
104973: PPUSH
104974: LD_VAR 0 2
104978: PPUSH
104979: CALL 105126 0 2
// end ;
104983: GO 104764
104985: POP
104986: POP
// end ;
104987: PPOPN 2
104989: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
104990: LD_INT 0
104992: PPUSH
104993: PPUSH
104994: PPUSH
// if not hack in hackTanks then
104995: LD_VAR 0 1
104999: PUSH
105000: LD_EXP 169
105004: IN
105005: NOT
105006: IFFALSE 105010
// exit ;
105008: GO 105121
// index := GetElementIndex ( hackTanks , hack ) ;
105010: LD_ADDR_VAR 0 4
105014: PUSH
105015: LD_EXP 169
105019: PPUSH
105020: LD_VAR 0 1
105024: PPUSH
105025: CALL 20248 0 2
105029: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
105030: LD_EXP 170
105034: PUSH
105035: LD_VAR 0 4
105039: ARRAY
105040: IFFALSE 105121
// begin for i in hackTanksCaptured [ index ] do
105042: LD_ADDR_VAR 0 3
105046: PUSH
105047: LD_EXP 170
105051: PUSH
105052: LD_VAR 0 4
105056: ARRAY
105057: PUSH
105058: FOR_IN
105059: IFFALSE 105085
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
105061: LD_VAR 0 3
105065: PUSH
105066: LD_INT 1
105068: ARRAY
105069: PPUSH
105070: LD_VAR 0 3
105074: PUSH
105075: LD_INT 2
105077: ARRAY
105078: PPUSH
105079: CALL_OW 235
105083: GO 105058
105085: POP
105086: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
105087: LD_ADDR_EXP 170
105091: PUSH
105092: LD_EXP 170
105096: PPUSH
105097: LD_VAR 0 4
105101: PPUSH
105102: EMPTY
105103: PPUSH
105104: CALL_OW 1
105108: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
105109: LD_VAR 0 1
105113: PPUSH
105114: LD_INT 0
105116: PPUSH
105117: CALL_OW 505
// end ; end ;
105121: LD_VAR 0 2
105125: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
105126: LD_INT 0
105128: PPUSH
105129: PPUSH
105130: PPUSH
// if not hack in hackTanks or not vehicles then
105131: LD_VAR 0 1
105135: PUSH
105136: LD_EXP 169
105140: IN
105141: NOT
105142: PUSH
105143: LD_VAR 0 2
105147: NOT
105148: OR
105149: IFFALSE 105153
// exit ;
105151: GO 105428
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
105153: LD_ADDR_VAR 0 2
105157: PUSH
105158: LD_VAR 0 1
105162: PPUSH
105163: LD_VAR 0 2
105167: PPUSH
105168: LD_INT 1
105170: PPUSH
105171: LD_INT 1
105173: PPUSH
105174: CALL 20898 0 4
105178: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
105179: LD_ADDR_VAR 0 5
105183: PUSH
105184: LD_EXP 169
105188: PPUSH
105189: LD_VAR 0 1
105193: PPUSH
105194: CALL 20248 0 2
105198: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
105199: LD_EXP 170
105203: PUSH
105204: LD_VAR 0 5
105208: ARRAY
105209: PUSH
105210: LD_EXP 171
105214: LESS
105215: IFFALSE 105404
// begin for i := 1 to vehicles do
105217: LD_ADDR_VAR 0 4
105221: PUSH
105222: DOUBLE
105223: LD_INT 1
105225: DEC
105226: ST_TO_ADDR
105227: LD_VAR 0 2
105231: PUSH
105232: FOR_TO
105233: IFFALSE 105402
// begin if hackTanksCaptured [ index ] = hackLimit then
105235: LD_EXP 170
105239: PUSH
105240: LD_VAR 0 5
105244: ARRAY
105245: PUSH
105246: LD_EXP 171
105250: EQUAL
105251: IFFALSE 105255
// break ;
105253: GO 105402
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
105255: LD_ADDR_EXP 173
105259: PUSH
105260: LD_EXP 173
105264: PPUSH
105265: LD_VAR 0 5
105269: PPUSH
105270: LD_EXP 173
105274: PUSH
105275: LD_VAR 0 5
105279: ARRAY
105280: PUSH
105281: LD_INT 1
105283: PLUS
105284: PPUSH
105285: CALL_OW 1
105289: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
105290: LD_ADDR_EXP 170
105294: PUSH
105295: LD_EXP 170
105299: PPUSH
105300: LD_VAR 0 5
105304: PUSH
105305: LD_EXP 170
105309: PUSH
105310: LD_VAR 0 5
105314: ARRAY
105315: PUSH
105316: LD_INT 1
105318: PLUS
105319: PUSH
105320: EMPTY
105321: LIST
105322: LIST
105323: PPUSH
105324: LD_VAR 0 2
105328: PUSH
105329: LD_VAR 0 4
105333: ARRAY
105334: PUSH
105335: LD_VAR 0 2
105339: PUSH
105340: LD_VAR 0 4
105344: ARRAY
105345: PPUSH
105346: CALL_OW 255
105350: PUSH
105351: EMPTY
105352: LIST
105353: LIST
105354: PPUSH
105355: CALL 20463 0 3
105359: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
105360: LD_VAR 0 2
105364: PUSH
105365: LD_VAR 0 4
105369: ARRAY
105370: PPUSH
105371: LD_VAR 0 1
105375: PPUSH
105376: CALL_OW 255
105380: PPUSH
105381: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
105385: LD_VAR 0 2
105389: PUSH
105390: LD_VAR 0 4
105394: ARRAY
105395: PPUSH
105396: CALL_OW 141
// end ;
105400: GO 105232
105402: POP
105403: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105404: LD_VAR 0 1
105408: PPUSH
105409: LD_EXP 170
105413: PUSH
105414: LD_VAR 0 5
105418: ARRAY
105419: PUSH
105420: LD_INT 0
105422: PLUS
105423: PPUSH
105424: CALL_OW 505
// end ;
105428: LD_VAR 0 3
105432: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
105433: LD_INT 0
105435: PPUSH
105436: PPUSH
105437: PPUSH
105438: PPUSH
// if not hack in hackTanks then
105439: LD_VAR 0 1
105443: PUSH
105444: LD_EXP 169
105448: IN
105449: NOT
105450: IFFALSE 105454
// exit ;
105452: GO 105694
// index := GetElementIndex ( hackTanks , hack ) ;
105454: LD_ADDR_VAR 0 4
105458: PUSH
105459: LD_EXP 169
105463: PPUSH
105464: LD_VAR 0 1
105468: PPUSH
105469: CALL 20248 0 2
105473: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
105474: LD_ADDR_VAR 0 3
105478: PUSH
105479: DOUBLE
105480: LD_EXP 170
105484: PUSH
105485: LD_VAR 0 4
105489: ARRAY
105490: INC
105491: ST_TO_ADDR
105492: LD_INT 1
105494: PUSH
105495: FOR_DOWNTO
105496: IFFALSE 105668
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
105498: LD_ADDR_VAR 0 5
105502: PUSH
105503: LD_EXP 170
105507: PUSH
105508: LD_VAR 0 4
105512: ARRAY
105513: PUSH
105514: LD_VAR 0 3
105518: ARRAY
105519: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
105520: LD_VAR 0 5
105524: PUSH
105525: LD_INT 1
105527: ARRAY
105528: PPUSH
105529: CALL_OW 302
105533: NOT
105534: PUSH
105535: LD_VAR 0 5
105539: PUSH
105540: LD_INT 1
105542: ARRAY
105543: PPUSH
105544: CALL_OW 255
105548: PUSH
105549: LD_VAR 0 1
105553: PPUSH
105554: CALL_OW 255
105558: NONEQUAL
105559: OR
105560: IFFALSE 105666
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
105562: LD_VAR 0 5
105566: PUSH
105567: LD_INT 1
105569: ARRAY
105570: PPUSH
105571: CALL_OW 305
105575: PUSH
105576: LD_VAR 0 5
105580: PUSH
105581: LD_INT 1
105583: ARRAY
105584: PPUSH
105585: CALL_OW 255
105589: PUSH
105590: LD_VAR 0 1
105594: PPUSH
105595: CALL_OW 255
105599: EQUAL
105600: AND
105601: IFFALSE 105625
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
105603: LD_VAR 0 5
105607: PUSH
105608: LD_INT 1
105610: ARRAY
105611: PPUSH
105612: LD_VAR 0 5
105616: PUSH
105617: LD_INT 2
105619: ARRAY
105620: PPUSH
105621: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
105625: LD_ADDR_EXP 170
105629: PUSH
105630: LD_EXP 170
105634: PPUSH
105635: LD_VAR 0 4
105639: PPUSH
105640: LD_EXP 170
105644: PUSH
105645: LD_VAR 0 4
105649: ARRAY
105650: PPUSH
105651: LD_VAR 0 3
105655: PPUSH
105656: CALL_OW 3
105660: PPUSH
105661: CALL_OW 1
105665: ST_TO_ADDR
// end ; end ;
105666: GO 105495
105668: POP
105669: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
105670: LD_VAR 0 1
105674: PPUSH
105675: LD_EXP 170
105679: PUSH
105680: LD_VAR 0 4
105684: ARRAY
105685: PUSH
105686: LD_INT 0
105688: PLUS
105689: PPUSH
105690: CALL_OW 505
// end ;
105694: LD_VAR 0 2
105698: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
105699: LD_INT 0
105701: PPUSH
105702: PPUSH
105703: PPUSH
105704: PPUSH
// if not hack in hackTanks then
105705: LD_VAR 0 1
105709: PUSH
105710: LD_EXP 169
105714: IN
105715: NOT
105716: IFFALSE 105720
// exit ;
105718: GO 105805
// index := GetElementIndex ( hackTanks , hack ) ;
105720: LD_ADDR_VAR 0 5
105724: PUSH
105725: LD_EXP 169
105729: PPUSH
105730: LD_VAR 0 1
105734: PPUSH
105735: CALL 20248 0 2
105739: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
105740: LD_ADDR_VAR 0 4
105744: PUSH
105745: DOUBLE
105746: LD_INT 1
105748: DEC
105749: ST_TO_ADDR
105750: LD_EXP 170
105754: PUSH
105755: LD_VAR 0 5
105759: ARRAY
105760: PUSH
105761: FOR_TO
105762: IFFALSE 105803
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
105764: LD_EXP 170
105768: PUSH
105769: LD_VAR 0 5
105773: ARRAY
105774: PUSH
105775: LD_VAR 0 4
105779: ARRAY
105780: PUSH
105781: LD_INT 1
105783: ARRAY
105784: PUSH
105785: LD_VAR 0 2
105789: EQUAL
105790: IFFALSE 105801
// KillUnit ( vehicle ) ;
105792: LD_VAR 0 2
105796: PPUSH
105797: CALL_OW 66
105801: GO 105761
105803: POP
105804: POP
// end ;
105805: LD_VAR 0 3
105809: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
105810: LD_EXP 174
105814: NOT
105815: IFFALSE 105850
105817: GO 105819
105819: DISABLE
// begin initMiner := true ;
105820: LD_ADDR_EXP 174
105824: PUSH
105825: LD_INT 1
105827: ST_TO_ADDR
// minersList := [ ] ;
105828: LD_ADDR_EXP 175
105832: PUSH
105833: EMPTY
105834: ST_TO_ADDR
// minerMinesList := [ ] ;
105835: LD_ADDR_EXP 176
105839: PUSH
105840: EMPTY
105841: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
105842: LD_ADDR_EXP 177
105846: PUSH
105847: LD_INT 5
105849: ST_TO_ADDR
// end ;
105850: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
105851: LD_EXP 174
105855: PUSH
105856: LD_INT 34
105858: PUSH
105859: LD_INT 81
105861: PUSH
105862: EMPTY
105863: LIST
105864: LIST
105865: PPUSH
105866: CALL_OW 69
105870: AND
105871: IFFALSE 106332
105873: GO 105875
105875: DISABLE
105876: LD_INT 0
105878: PPUSH
105879: PPUSH
105880: PPUSH
105881: PPUSH
// begin enable ;
105882: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
105883: LD_ADDR_VAR 0 1
105887: PUSH
105888: LD_INT 34
105890: PUSH
105891: LD_INT 81
105893: PUSH
105894: EMPTY
105895: LIST
105896: LIST
105897: PPUSH
105898: CALL_OW 69
105902: PUSH
105903: FOR_IN
105904: IFFALSE 105976
// begin if not i in minersList then
105906: LD_VAR 0 1
105910: PUSH
105911: LD_EXP 175
105915: IN
105916: NOT
105917: IFFALSE 105974
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
105919: LD_ADDR_EXP 175
105923: PUSH
105924: LD_EXP 175
105928: PPUSH
105929: LD_EXP 175
105933: PUSH
105934: LD_INT 1
105936: PLUS
105937: PPUSH
105938: LD_VAR 0 1
105942: PPUSH
105943: CALL_OW 1
105947: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
105948: LD_ADDR_EXP 176
105952: PUSH
105953: LD_EXP 176
105957: PPUSH
105958: LD_EXP 176
105962: PUSH
105963: LD_INT 1
105965: PLUS
105966: PPUSH
105967: EMPTY
105968: PPUSH
105969: CALL_OW 1
105973: ST_TO_ADDR
// end end ;
105974: GO 105903
105976: POP
105977: POP
// for i := minerMinesList downto 1 do
105978: LD_ADDR_VAR 0 1
105982: PUSH
105983: DOUBLE
105984: LD_EXP 176
105988: INC
105989: ST_TO_ADDR
105990: LD_INT 1
105992: PUSH
105993: FOR_DOWNTO
105994: IFFALSE 106330
// begin if IsLive ( minersList [ i ] ) then
105996: LD_EXP 175
106000: PUSH
106001: LD_VAR 0 1
106005: ARRAY
106006: PPUSH
106007: CALL_OW 300
106011: IFFALSE 106039
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
106013: LD_EXP 175
106017: PUSH
106018: LD_VAR 0 1
106022: ARRAY
106023: PPUSH
106024: LD_EXP 176
106028: PUSH
106029: LD_VAR 0 1
106033: ARRAY
106034: PPUSH
106035: CALL_OW 505
// if not minerMinesList [ i ] then
106039: LD_EXP 176
106043: PUSH
106044: LD_VAR 0 1
106048: ARRAY
106049: NOT
106050: IFFALSE 106054
// continue ;
106052: GO 105993
// for j := minerMinesList [ i ] downto 1 do
106054: LD_ADDR_VAR 0 2
106058: PUSH
106059: DOUBLE
106060: LD_EXP 176
106064: PUSH
106065: LD_VAR 0 1
106069: ARRAY
106070: INC
106071: ST_TO_ADDR
106072: LD_INT 1
106074: PUSH
106075: FOR_DOWNTO
106076: IFFALSE 106326
// begin side := GetSide ( minersList [ i ] ) ;
106078: LD_ADDR_VAR 0 3
106082: PUSH
106083: LD_EXP 175
106087: PUSH
106088: LD_VAR 0 1
106092: ARRAY
106093: PPUSH
106094: CALL_OW 255
106098: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
106099: LD_ADDR_VAR 0 4
106103: PUSH
106104: LD_EXP 176
106108: PUSH
106109: LD_VAR 0 1
106113: ARRAY
106114: PUSH
106115: LD_VAR 0 2
106119: ARRAY
106120: PUSH
106121: LD_INT 1
106123: ARRAY
106124: PPUSH
106125: LD_EXP 176
106129: PUSH
106130: LD_VAR 0 1
106134: ARRAY
106135: PUSH
106136: LD_VAR 0 2
106140: ARRAY
106141: PUSH
106142: LD_INT 2
106144: ARRAY
106145: PPUSH
106146: CALL_OW 428
106150: ST_TO_ADDR
// if not tmp then
106151: LD_VAR 0 4
106155: NOT
106156: IFFALSE 106160
// continue ;
106158: GO 106075
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
106160: LD_VAR 0 4
106164: PUSH
106165: LD_INT 81
106167: PUSH
106168: LD_VAR 0 3
106172: PUSH
106173: EMPTY
106174: LIST
106175: LIST
106176: PPUSH
106177: CALL_OW 69
106181: IN
106182: PUSH
106183: LD_EXP 176
106187: PUSH
106188: LD_VAR 0 1
106192: ARRAY
106193: PUSH
106194: LD_VAR 0 2
106198: ARRAY
106199: PUSH
106200: LD_INT 1
106202: ARRAY
106203: PPUSH
106204: LD_EXP 176
106208: PUSH
106209: LD_VAR 0 1
106213: ARRAY
106214: PUSH
106215: LD_VAR 0 2
106219: ARRAY
106220: PUSH
106221: LD_INT 2
106223: ARRAY
106224: PPUSH
106225: CALL_OW 458
106229: AND
106230: IFFALSE 106324
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
106232: LD_EXP 176
106236: PUSH
106237: LD_VAR 0 1
106241: ARRAY
106242: PUSH
106243: LD_VAR 0 2
106247: ARRAY
106248: PUSH
106249: LD_INT 1
106251: ARRAY
106252: PPUSH
106253: LD_EXP 176
106257: PUSH
106258: LD_VAR 0 1
106262: ARRAY
106263: PUSH
106264: LD_VAR 0 2
106268: ARRAY
106269: PUSH
106270: LD_INT 2
106272: ARRAY
106273: PPUSH
106274: LD_VAR 0 3
106278: PPUSH
106279: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
106283: LD_ADDR_EXP 176
106287: PUSH
106288: LD_EXP 176
106292: PPUSH
106293: LD_VAR 0 1
106297: PPUSH
106298: LD_EXP 176
106302: PUSH
106303: LD_VAR 0 1
106307: ARRAY
106308: PPUSH
106309: LD_VAR 0 2
106313: PPUSH
106314: CALL_OW 3
106318: PPUSH
106319: CALL_OW 1
106323: ST_TO_ADDR
// end ; end ;
106324: GO 106075
106326: POP
106327: POP
// end ;
106328: GO 105993
106330: POP
106331: POP
// end ;
106332: PPOPN 4
106334: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
106335: LD_INT 0
106337: PPUSH
106338: PPUSH
// result := false ;
106339: LD_ADDR_VAR 0 4
106343: PUSH
106344: LD_INT 0
106346: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
106347: LD_VAR 0 1
106351: PPUSH
106352: CALL_OW 264
106356: PUSH
106357: LD_INT 81
106359: EQUAL
106360: NOT
106361: IFFALSE 106365
// exit ;
106363: GO 106605
// index := GetElementIndex ( minersList , unit ) ;
106365: LD_ADDR_VAR 0 5
106369: PUSH
106370: LD_EXP 175
106374: PPUSH
106375: LD_VAR 0 1
106379: PPUSH
106380: CALL 20248 0 2
106384: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
106385: LD_EXP 176
106389: PUSH
106390: LD_VAR 0 5
106394: ARRAY
106395: PUSH
106396: LD_EXP 177
106400: GREATEREQUAL
106401: IFFALSE 106405
// exit ;
106403: GO 106605
// ComMoveXY ( unit , x , y ) ;
106405: LD_VAR 0 1
106409: PPUSH
106410: LD_VAR 0 2
106414: PPUSH
106415: LD_VAR 0 3
106419: PPUSH
106420: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
106424: LD_INT 35
106426: PPUSH
106427: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
106431: LD_VAR 0 1
106435: PPUSH
106436: LD_VAR 0 2
106440: PPUSH
106441: LD_VAR 0 3
106445: PPUSH
106446: CALL 51612 0 3
106450: NOT
106451: PUSH
106452: LD_VAR 0 1
106456: PPUSH
106457: CALL_OW 314
106461: AND
106462: IFFALSE 106466
// exit ;
106464: GO 106605
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
106466: LD_VAR 0 2
106470: PPUSH
106471: LD_VAR 0 3
106475: PPUSH
106476: CALL_OW 428
106480: PUSH
106481: LD_VAR 0 1
106485: EQUAL
106486: PUSH
106487: LD_VAR 0 1
106491: PPUSH
106492: CALL_OW 314
106496: NOT
106497: AND
106498: IFFALSE 106424
// PlaySoundXY ( x , y , PlantMine ) ;
106500: LD_VAR 0 2
106504: PPUSH
106505: LD_VAR 0 3
106509: PPUSH
106510: LD_STRING PlantMine
106512: PPUSH
106513: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
106517: LD_VAR 0 2
106521: PPUSH
106522: LD_VAR 0 3
106526: PPUSH
106527: LD_VAR 0 1
106531: PPUSH
106532: CALL_OW 255
106536: PPUSH
106537: LD_INT 0
106539: PPUSH
106540: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
106544: LD_ADDR_EXP 176
106548: PUSH
106549: LD_EXP 176
106553: PPUSH
106554: LD_VAR 0 5
106558: PUSH
106559: LD_EXP 176
106563: PUSH
106564: LD_VAR 0 5
106568: ARRAY
106569: PUSH
106570: LD_INT 1
106572: PLUS
106573: PUSH
106574: EMPTY
106575: LIST
106576: LIST
106577: PPUSH
106578: LD_VAR 0 2
106582: PUSH
106583: LD_VAR 0 3
106587: PUSH
106588: EMPTY
106589: LIST
106590: LIST
106591: PPUSH
106592: CALL 20463 0 3
106596: ST_TO_ADDR
// result := true ;
106597: LD_ADDR_VAR 0 4
106601: PUSH
106602: LD_INT 1
106604: ST_TO_ADDR
// end ;
106605: LD_VAR 0 4
106609: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
106610: LD_INT 0
106612: PPUSH
106613: PPUSH
106614: PPUSH
// if not unit in minersList then
106615: LD_VAR 0 1
106619: PUSH
106620: LD_EXP 175
106624: IN
106625: NOT
106626: IFFALSE 106630
// exit ;
106628: GO 107022
// index := GetElementIndex ( minersList , unit ) ;
106630: LD_ADDR_VAR 0 6
106634: PUSH
106635: LD_EXP 175
106639: PPUSH
106640: LD_VAR 0 1
106644: PPUSH
106645: CALL 20248 0 2
106649: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
106650: LD_ADDR_VAR 0 5
106654: PUSH
106655: DOUBLE
106656: LD_EXP 176
106660: PUSH
106661: LD_VAR 0 6
106665: ARRAY
106666: INC
106667: ST_TO_ADDR
106668: LD_INT 1
106670: PUSH
106671: FOR_DOWNTO
106672: IFFALSE 106833
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
106674: LD_EXP 176
106678: PUSH
106679: LD_VAR 0 6
106683: ARRAY
106684: PUSH
106685: LD_VAR 0 5
106689: ARRAY
106690: PUSH
106691: LD_INT 1
106693: ARRAY
106694: PUSH
106695: LD_VAR 0 2
106699: EQUAL
106700: PUSH
106701: LD_EXP 176
106705: PUSH
106706: LD_VAR 0 6
106710: ARRAY
106711: PUSH
106712: LD_VAR 0 5
106716: ARRAY
106717: PUSH
106718: LD_INT 2
106720: ARRAY
106721: PUSH
106722: LD_VAR 0 3
106726: EQUAL
106727: AND
106728: IFFALSE 106831
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106730: LD_EXP 176
106734: PUSH
106735: LD_VAR 0 6
106739: ARRAY
106740: PUSH
106741: LD_VAR 0 5
106745: ARRAY
106746: PUSH
106747: LD_INT 1
106749: ARRAY
106750: PPUSH
106751: LD_EXP 176
106755: PUSH
106756: LD_VAR 0 6
106760: ARRAY
106761: PUSH
106762: LD_VAR 0 5
106766: ARRAY
106767: PUSH
106768: LD_INT 2
106770: ARRAY
106771: PPUSH
106772: LD_VAR 0 1
106776: PPUSH
106777: CALL_OW 255
106781: PPUSH
106782: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106786: LD_ADDR_EXP 176
106790: PUSH
106791: LD_EXP 176
106795: PPUSH
106796: LD_VAR 0 6
106800: PPUSH
106801: LD_EXP 176
106805: PUSH
106806: LD_VAR 0 6
106810: ARRAY
106811: PPUSH
106812: LD_VAR 0 5
106816: PPUSH
106817: CALL_OW 3
106821: PPUSH
106822: CALL_OW 1
106826: ST_TO_ADDR
// exit ;
106827: POP
106828: POP
106829: GO 107022
// end ; end ;
106831: GO 106671
106833: POP
106834: POP
// for i := minerMinesList [ index ] downto 1 do
106835: LD_ADDR_VAR 0 5
106839: PUSH
106840: DOUBLE
106841: LD_EXP 176
106845: PUSH
106846: LD_VAR 0 6
106850: ARRAY
106851: INC
106852: ST_TO_ADDR
106853: LD_INT 1
106855: PUSH
106856: FOR_DOWNTO
106857: IFFALSE 107020
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
106859: LD_EXP 176
106863: PUSH
106864: LD_VAR 0 6
106868: ARRAY
106869: PUSH
106870: LD_VAR 0 5
106874: ARRAY
106875: PUSH
106876: LD_INT 1
106878: ARRAY
106879: PPUSH
106880: LD_EXP 176
106884: PUSH
106885: LD_VAR 0 6
106889: ARRAY
106890: PUSH
106891: LD_VAR 0 5
106895: ARRAY
106896: PUSH
106897: LD_INT 2
106899: ARRAY
106900: PPUSH
106901: LD_VAR 0 2
106905: PPUSH
106906: LD_VAR 0 3
106910: PPUSH
106911: CALL_OW 298
106915: PUSH
106916: LD_INT 6
106918: LESS
106919: IFFALSE 107018
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
106921: LD_EXP 176
106925: PUSH
106926: LD_VAR 0 6
106930: ARRAY
106931: PUSH
106932: LD_VAR 0 5
106936: ARRAY
106937: PUSH
106938: LD_INT 1
106940: ARRAY
106941: PPUSH
106942: LD_EXP 176
106946: PUSH
106947: LD_VAR 0 6
106951: ARRAY
106952: PUSH
106953: LD_VAR 0 5
106957: ARRAY
106958: PUSH
106959: LD_INT 2
106961: ARRAY
106962: PPUSH
106963: LD_VAR 0 1
106967: PPUSH
106968: CALL_OW 255
106972: PPUSH
106973: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
106977: LD_ADDR_EXP 176
106981: PUSH
106982: LD_EXP 176
106986: PPUSH
106987: LD_VAR 0 6
106991: PPUSH
106992: LD_EXP 176
106996: PUSH
106997: LD_VAR 0 6
107001: ARRAY
107002: PPUSH
107003: LD_VAR 0 5
107007: PPUSH
107008: CALL_OW 3
107012: PPUSH
107013: CALL_OW 1
107017: ST_TO_ADDR
// end ; end ;
107018: GO 106856
107020: POP
107021: POP
// end ;
107022: LD_VAR 0 4
107026: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
107027: LD_INT 0
107029: PPUSH
107030: PPUSH
107031: PPUSH
107032: PPUSH
107033: PPUSH
107034: PPUSH
107035: PPUSH
107036: PPUSH
107037: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
107038: LD_VAR 0 1
107042: PPUSH
107043: CALL_OW 264
107047: PUSH
107048: LD_INT 81
107050: EQUAL
107051: NOT
107052: PUSH
107053: LD_VAR 0 1
107057: PUSH
107058: LD_EXP 175
107062: IN
107063: NOT
107064: OR
107065: IFFALSE 107069
// exit ;
107067: GO 107391
// index := GetElementIndex ( minersList , unit ) ;
107069: LD_ADDR_VAR 0 6
107073: PUSH
107074: LD_EXP 175
107078: PPUSH
107079: LD_VAR 0 1
107083: PPUSH
107084: CALL 20248 0 2
107088: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
107089: LD_ADDR_VAR 0 8
107093: PUSH
107094: LD_EXP 177
107098: PUSH
107099: LD_EXP 176
107103: PUSH
107104: LD_VAR 0 6
107108: ARRAY
107109: MINUS
107110: ST_TO_ADDR
// if not minesFreeAmount then
107111: LD_VAR 0 8
107115: NOT
107116: IFFALSE 107120
// exit ;
107118: GO 107391
// tmp := [ ] ;
107120: LD_ADDR_VAR 0 7
107124: PUSH
107125: EMPTY
107126: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
107127: LD_ADDR_VAR 0 5
107131: PUSH
107132: DOUBLE
107133: LD_INT 1
107135: DEC
107136: ST_TO_ADDR
107137: LD_VAR 0 8
107141: PUSH
107142: FOR_TO
107143: IFFALSE 107338
// begin _d := rand ( 0 , 5 ) ;
107145: LD_ADDR_VAR 0 11
107149: PUSH
107150: LD_INT 0
107152: PPUSH
107153: LD_INT 5
107155: PPUSH
107156: CALL_OW 12
107160: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
107161: LD_ADDR_VAR 0 12
107165: PUSH
107166: LD_INT 2
107168: PPUSH
107169: LD_INT 6
107171: PPUSH
107172: CALL_OW 12
107176: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
107177: LD_ADDR_VAR 0 9
107181: PUSH
107182: LD_VAR 0 2
107186: PPUSH
107187: LD_VAR 0 11
107191: PPUSH
107192: LD_VAR 0 12
107196: PPUSH
107197: CALL_OW 272
107201: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
107202: LD_ADDR_VAR 0 10
107206: PUSH
107207: LD_VAR 0 3
107211: PPUSH
107212: LD_VAR 0 11
107216: PPUSH
107217: LD_VAR 0 12
107221: PPUSH
107222: CALL_OW 273
107226: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
107227: LD_VAR 0 9
107231: PPUSH
107232: LD_VAR 0 10
107236: PPUSH
107237: CALL_OW 488
107241: PUSH
107242: LD_VAR 0 9
107246: PUSH
107247: LD_VAR 0 10
107251: PUSH
107252: EMPTY
107253: LIST
107254: LIST
107255: PUSH
107256: LD_VAR 0 7
107260: IN
107261: NOT
107262: AND
107263: PUSH
107264: LD_VAR 0 9
107268: PPUSH
107269: LD_VAR 0 10
107273: PPUSH
107274: CALL_OW 458
107278: NOT
107279: AND
107280: IFFALSE 107322
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
107282: LD_ADDR_VAR 0 7
107286: PUSH
107287: LD_VAR 0 7
107291: PPUSH
107292: LD_VAR 0 7
107296: PUSH
107297: LD_INT 1
107299: PLUS
107300: PPUSH
107301: LD_VAR 0 9
107305: PUSH
107306: LD_VAR 0 10
107310: PUSH
107311: EMPTY
107312: LIST
107313: LIST
107314: PPUSH
107315: CALL_OW 1
107319: ST_TO_ADDR
107320: GO 107336
// i := i - 1 ;
107322: LD_ADDR_VAR 0 5
107326: PUSH
107327: LD_VAR 0 5
107331: PUSH
107332: LD_INT 1
107334: MINUS
107335: ST_TO_ADDR
// end ;
107336: GO 107142
107338: POP
107339: POP
// for i in tmp do
107340: LD_ADDR_VAR 0 5
107344: PUSH
107345: LD_VAR 0 7
107349: PUSH
107350: FOR_IN
107351: IFFALSE 107389
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
107353: LD_VAR 0 1
107357: PPUSH
107358: LD_VAR 0 5
107362: PUSH
107363: LD_INT 1
107365: ARRAY
107366: PPUSH
107367: LD_VAR 0 5
107371: PUSH
107372: LD_INT 2
107374: ARRAY
107375: PPUSH
107376: CALL 106335 0 3
107380: NOT
107381: IFFALSE 107387
// exit ;
107383: POP
107384: POP
107385: GO 107391
107387: GO 107350
107389: POP
107390: POP
// end ;
107391: LD_VAR 0 4
107395: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
107396: LD_INT 0
107398: PPUSH
107399: PPUSH
107400: PPUSH
107401: PPUSH
107402: PPUSH
107403: PPUSH
107404: PPUSH
// if not GetClass ( unit ) = class_sniper then
107405: LD_VAR 0 1
107409: PPUSH
107410: CALL_OW 257
107414: PUSH
107415: LD_INT 5
107417: EQUAL
107418: NOT
107419: IFFALSE 107423
// exit ;
107421: GO 107811
// dist := 8 ;
107423: LD_ADDR_VAR 0 5
107427: PUSH
107428: LD_INT 8
107430: ST_TO_ADDR
// viewRange := 12 ;
107431: LD_ADDR_VAR 0 7
107435: PUSH
107436: LD_INT 12
107438: ST_TO_ADDR
// side := GetSide ( unit ) ;
107439: LD_ADDR_VAR 0 6
107443: PUSH
107444: LD_VAR 0 1
107448: PPUSH
107449: CALL_OW 255
107453: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
107454: LD_INT 61
107456: PPUSH
107457: LD_VAR 0 6
107461: PPUSH
107462: CALL_OW 321
107466: PUSH
107467: LD_INT 2
107469: EQUAL
107470: IFFALSE 107480
// viewRange := 16 ;
107472: LD_ADDR_VAR 0 7
107476: PUSH
107477: LD_INT 16
107479: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
107480: LD_VAR 0 1
107484: PPUSH
107485: LD_VAR 0 2
107489: PPUSH
107490: LD_VAR 0 3
107494: PPUSH
107495: CALL_OW 297
107499: PUSH
107500: LD_VAR 0 5
107504: GREATER
107505: IFFALSE 107584
// begin ComMoveXY ( unit , x , y ) ;
107507: LD_VAR 0 1
107511: PPUSH
107512: LD_VAR 0 2
107516: PPUSH
107517: LD_VAR 0 3
107521: PPUSH
107522: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
107526: LD_INT 35
107528: PPUSH
107529: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
107533: LD_VAR 0 1
107537: PPUSH
107538: LD_VAR 0 2
107542: PPUSH
107543: LD_VAR 0 3
107547: PPUSH
107548: CALL 51612 0 3
107552: NOT
107553: IFFALSE 107557
// exit ;
107555: GO 107811
// until GetDistUnitXY ( unit , x , y ) < dist ;
107557: LD_VAR 0 1
107561: PPUSH
107562: LD_VAR 0 2
107566: PPUSH
107567: LD_VAR 0 3
107571: PPUSH
107572: CALL_OW 297
107576: PUSH
107577: LD_VAR 0 5
107581: LESS
107582: IFFALSE 107526
// end ; ComTurnXY ( unit , x , y ) ;
107584: LD_VAR 0 1
107588: PPUSH
107589: LD_VAR 0 2
107593: PPUSH
107594: LD_VAR 0 3
107598: PPUSH
107599: CALL_OW 118
// wait ( 5 ) ;
107603: LD_INT 5
107605: PPUSH
107606: CALL_OW 67
// _d := GetDir ( unit ) ;
107610: LD_ADDR_VAR 0 10
107614: PUSH
107615: LD_VAR 0 1
107619: PPUSH
107620: CALL_OW 254
107624: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
107625: LD_ADDR_VAR 0 8
107629: PUSH
107630: LD_VAR 0 1
107634: PPUSH
107635: CALL_OW 250
107639: PPUSH
107640: LD_VAR 0 10
107644: PPUSH
107645: LD_VAR 0 5
107649: PPUSH
107650: CALL_OW 272
107654: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
107655: LD_ADDR_VAR 0 9
107659: PUSH
107660: LD_VAR 0 1
107664: PPUSH
107665: CALL_OW 251
107669: PPUSH
107670: LD_VAR 0 10
107674: PPUSH
107675: LD_VAR 0 5
107679: PPUSH
107680: CALL_OW 273
107684: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
107685: LD_VAR 0 8
107689: PPUSH
107690: LD_VAR 0 9
107694: PPUSH
107695: CALL_OW 488
107699: NOT
107700: IFFALSE 107704
// exit ;
107702: GO 107811
// ComAnimCustom ( unit , 1 ) ;
107704: LD_VAR 0 1
107708: PPUSH
107709: LD_INT 1
107711: PPUSH
107712: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
107716: LD_VAR 0 8
107720: PPUSH
107721: LD_VAR 0 9
107725: PPUSH
107726: LD_VAR 0 6
107730: PPUSH
107731: LD_VAR 0 7
107735: PPUSH
107736: CALL_OW 330
// repeat wait ( 1 ) ;
107740: LD_INT 1
107742: PPUSH
107743: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
107747: LD_VAR 0 1
107751: PPUSH
107752: CALL_OW 316
107756: PUSH
107757: LD_VAR 0 1
107761: PPUSH
107762: CALL_OW 314
107766: OR
107767: PUSH
107768: LD_VAR 0 1
107772: PPUSH
107773: CALL_OW 302
107777: NOT
107778: OR
107779: PUSH
107780: LD_VAR 0 1
107784: PPUSH
107785: CALL_OW 301
107789: OR
107790: IFFALSE 107740
// RemoveSeeing ( _x , _y , side ) ;
107792: LD_VAR 0 8
107796: PPUSH
107797: LD_VAR 0 9
107801: PPUSH
107802: LD_VAR 0 6
107806: PPUSH
107807: CALL_OW 331
// end ; end_of_file
107811: LD_VAR 0 4
107815: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
107816: LD_INT 0
107818: PPUSH
107819: PPUSH
107820: PPUSH
107821: PPUSH
107822: PPUSH
107823: PPUSH
107824: PPUSH
107825: PPUSH
107826: PPUSH
107827: PPUSH
107828: PPUSH
107829: PPUSH
107830: PPUSH
107831: PPUSH
107832: PPUSH
107833: PPUSH
107834: PPUSH
107835: PPUSH
107836: PPUSH
107837: PPUSH
107838: PPUSH
107839: PPUSH
107840: PPUSH
107841: PPUSH
107842: PPUSH
107843: PPUSH
107844: PPUSH
107845: PPUSH
107846: PPUSH
107847: PPUSH
107848: PPUSH
107849: PPUSH
107850: PPUSH
107851: PPUSH
// if not list then
107852: LD_VAR 0 1
107856: NOT
107857: IFFALSE 107861
// exit ;
107859: GO 112520
// base := list [ 1 ] ;
107861: LD_ADDR_VAR 0 3
107865: PUSH
107866: LD_VAR 0 1
107870: PUSH
107871: LD_INT 1
107873: ARRAY
107874: ST_TO_ADDR
// group := list [ 2 ] ;
107875: LD_ADDR_VAR 0 4
107879: PUSH
107880: LD_VAR 0 1
107884: PUSH
107885: LD_INT 2
107887: ARRAY
107888: ST_TO_ADDR
// path := list [ 3 ] ;
107889: LD_ADDR_VAR 0 5
107893: PUSH
107894: LD_VAR 0 1
107898: PUSH
107899: LD_INT 3
107901: ARRAY
107902: ST_TO_ADDR
// flags := list [ 4 ] ;
107903: LD_ADDR_VAR 0 6
107907: PUSH
107908: LD_VAR 0 1
107912: PUSH
107913: LD_INT 4
107915: ARRAY
107916: ST_TO_ADDR
// mined := [ ] ;
107917: LD_ADDR_VAR 0 27
107921: PUSH
107922: EMPTY
107923: ST_TO_ADDR
// bombed := [ ] ;
107924: LD_ADDR_VAR 0 28
107928: PUSH
107929: EMPTY
107930: ST_TO_ADDR
// healers := [ ] ;
107931: LD_ADDR_VAR 0 31
107935: PUSH
107936: EMPTY
107937: ST_TO_ADDR
// to_heal := [ ] ;
107938: LD_ADDR_VAR 0 30
107942: PUSH
107943: EMPTY
107944: ST_TO_ADDR
// repairs := [ ] ;
107945: LD_ADDR_VAR 0 33
107949: PUSH
107950: EMPTY
107951: ST_TO_ADDR
// to_repair := [ ] ;
107952: LD_ADDR_VAR 0 32
107956: PUSH
107957: EMPTY
107958: ST_TO_ADDR
// if not group or not path then
107959: LD_VAR 0 4
107963: NOT
107964: PUSH
107965: LD_VAR 0 5
107969: NOT
107970: OR
107971: IFFALSE 107975
// exit ;
107973: GO 112520
// side := GetSide ( group [ 1 ] ) ;
107975: LD_ADDR_VAR 0 35
107979: PUSH
107980: LD_VAR 0 4
107984: PUSH
107985: LD_INT 1
107987: ARRAY
107988: PPUSH
107989: CALL_OW 255
107993: ST_TO_ADDR
// if flags then
107994: LD_VAR 0 6
107998: IFFALSE 108142
// begin f_ignore_area := flags [ 1 ] ;
108000: LD_ADDR_VAR 0 17
108004: PUSH
108005: LD_VAR 0 6
108009: PUSH
108010: LD_INT 1
108012: ARRAY
108013: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
108014: LD_ADDR_VAR 0 18
108018: PUSH
108019: LD_VAR 0 6
108023: PUSH
108024: LD_INT 2
108026: ARRAY
108027: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
108028: LD_ADDR_VAR 0 19
108032: PUSH
108033: LD_VAR 0 6
108037: PUSH
108038: LD_INT 3
108040: ARRAY
108041: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
108042: LD_ADDR_VAR 0 20
108046: PUSH
108047: LD_VAR 0 6
108051: PUSH
108052: LD_INT 4
108054: ARRAY
108055: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
108056: LD_ADDR_VAR 0 21
108060: PUSH
108061: LD_VAR 0 6
108065: PUSH
108066: LD_INT 5
108068: ARRAY
108069: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
108070: LD_ADDR_VAR 0 22
108074: PUSH
108075: LD_VAR 0 6
108079: PUSH
108080: LD_INT 6
108082: ARRAY
108083: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
108084: LD_ADDR_VAR 0 23
108088: PUSH
108089: LD_VAR 0 6
108093: PUSH
108094: LD_INT 7
108096: ARRAY
108097: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
108098: LD_ADDR_VAR 0 24
108102: PUSH
108103: LD_VAR 0 6
108107: PUSH
108108: LD_INT 8
108110: ARRAY
108111: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
108112: LD_ADDR_VAR 0 25
108116: PUSH
108117: LD_VAR 0 6
108121: PUSH
108122: LD_INT 9
108124: ARRAY
108125: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
108126: LD_ADDR_VAR 0 26
108130: PUSH
108131: LD_VAR 0 6
108135: PUSH
108136: LD_INT 10
108138: ARRAY
108139: ST_TO_ADDR
// end else
108140: GO 108222
// begin f_ignore_area := false ;
108142: LD_ADDR_VAR 0 17
108146: PUSH
108147: LD_INT 0
108149: ST_TO_ADDR
// f_capture := false ;
108150: LD_ADDR_VAR 0 18
108154: PUSH
108155: LD_INT 0
108157: ST_TO_ADDR
// f_ignore_civ := false ;
108158: LD_ADDR_VAR 0 19
108162: PUSH
108163: LD_INT 0
108165: ST_TO_ADDR
// f_murder := false ;
108166: LD_ADDR_VAR 0 20
108170: PUSH
108171: LD_INT 0
108173: ST_TO_ADDR
// f_mines := false ;
108174: LD_ADDR_VAR 0 21
108178: PUSH
108179: LD_INT 0
108181: ST_TO_ADDR
// f_repair := false ;
108182: LD_ADDR_VAR 0 22
108186: PUSH
108187: LD_INT 0
108189: ST_TO_ADDR
// f_heal := false ;
108190: LD_ADDR_VAR 0 23
108194: PUSH
108195: LD_INT 0
108197: ST_TO_ADDR
// f_spacetime := false ;
108198: LD_ADDR_VAR 0 24
108202: PUSH
108203: LD_INT 0
108205: ST_TO_ADDR
// f_attack_depot := false ;
108206: LD_ADDR_VAR 0 25
108210: PUSH
108211: LD_INT 0
108213: ST_TO_ADDR
// f_crawl := false ;
108214: LD_ADDR_VAR 0 26
108218: PUSH
108219: LD_INT 0
108221: ST_TO_ADDR
// end ; if f_heal then
108222: LD_VAR 0 23
108226: IFFALSE 108253
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
108228: LD_ADDR_VAR 0 31
108232: PUSH
108233: LD_VAR 0 4
108237: PPUSH
108238: LD_INT 25
108240: PUSH
108241: LD_INT 4
108243: PUSH
108244: EMPTY
108245: LIST
108246: LIST
108247: PPUSH
108248: CALL_OW 72
108252: ST_TO_ADDR
// if f_repair then
108253: LD_VAR 0 22
108257: IFFALSE 108284
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
108259: LD_ADDR_VAR 0 33
108263: PUSH
108264: LD_VAR 0 4
108268: PPUSH
108269: LD_INT 25
108271: PUSH
108272: LD_INT 3
108274: PUSH
108275: EMPTY
108276: LIST
108277: LIST
108278: PPUSH
108279: CALL_OW 72
108283: ST_TO_ADDR
// units_path := [ ] ;
108284: LD_ADDR_VAR 0 16
108288: PUSH
108289: EMPTY
108290: ST_TO_ADDR
// for i = 1 to group do
108291: LD_ADDR_VAR 0 7
108295: PUSH
108296: DOUBLE
108297: LD_INT 1
108299: DEC
108300: ST_TO_ADDR
108301: LD_VAR 0 4
108305: PUSH
108306: FOR_TO
108307: IFFALSE 108336
// units_path := Replace ( units_path , i , path ) ;
108309: LD_ADDR_VAR 0 16
108313: PUSH
108314: LD_VAR 0 16
108318: PPUSH
108319: LD_VAR 0 7
108323: PPUSH
108324: LD_VAR 0 5
108328: PPUSH
108329: CALL_OW 1
108333: ST_TO_ADDR
108334: GO 108306
108336: POP
108337: POP
// repeat for i = group downto 1 do
108338: LD_ADDR_VAR 0 7
108342: PUSH
108343: DOUBLE
108344: LD_VAR 0 4
108348: INC
108349: ST_TO_ADDR
108350: LD_INT 1
108352: PUSH
108353: FOR_DOWNTO
108354: IFFALSE 112476
// begin wait ( 5 ) ;
108356: LD_INT 5
108358: PPUSH
108359: CALL_OW 67
// tmp := [ ] ;
108363: LD_ADDR_VAR 0 14
108367: PUSH
108368: EMPTY
108369: ST_TO_ADDR
// attacking := false ;
108370: LD_ADDR_VAR 0 29
108374: PUSH
108375: LD_INT 0
108377: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
108378: LD_VAR 0 4
108382: PUSH
108383: LD_VAR 0 7
108387: ARRAY
108388: PPUSH
108389: CALL_OW 301
108393: PUSH
108394: LD_VAR 0 4
108398: PUSH
108399: LD_VAR 0 7
108403: ARRAY
108404: NOT
108405: OR
108406: IFFALSE 108515
// begin if GetType ( group [ i ] ) = unit_human then
108408: LD_VAR 0 4
108412: PUSH
108413: LD_VAR 0 7
108417: ARRAY
108418: PPUSH
108419: CALL_OW 247
108423: PUSH
108424: LD_INT 1
108426: EQUAL
108427: IFFALSE 108473
// begin to_heal := to_heal diff group [ i ] ;
108429: LD_ADDR_VAR 0 30
108433: PUSH
108434: LD_VAR 0 30
108438: PUSH
108439: LD_VAR 0 4
108443: PUSH
108444: LD_VAR 0 7
108448: ARRAY
108449: DIFF
108450: ST_TO_ADDR
// healers := healers diff group [ i ] ;
108451: LD_ADDR_VAR 0 31
108455: PUSH
108456: LD_VAR 0 31
108460: PUSH
108461: LD_VAR 0 4
108465: PUSH
108466: LD_VAR 0 7
108470: ARRAY
108471: DIFF
108472: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
108473: LD_ADDR_VAR 0 4
108477: PUSH
108478: LD_VAR 0 4
108482: PPUSH
108483: LD_VAR 0 7
108487: PPUSH
108488: CALL_OW 3
108492: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
108493: LD_ADDR_VAR 0 16
108497: PUSH
108498: LD_VAR 0 16
108502: PPUSH
108503: LD_VAR 0 7
108507: PPUSH
108508: CALL_OW 3
108512: ST_TO_ADDR
// continue ;
108513: GO 108353
// end ; if f_repair then
108515: LD_VAR 0 22
108519: IFFALSE 109008
// begin if GetType ( group [ i ] ) = unit_vehicle then
108521: LD_VAR 0 4
108525: PUSH
108526: LD_VAR 0 7
108530: ARRAY
108531: PPUSH
108532: CALL_OW 247
108536: PUSH
108537: LD_INT 2
108539: EQUAL
108540: IFFALSE 108730
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
108542: LD_VAR 0 4
108546: PUSH
108547: LD_VAR 0 7
108551: ARRAY
108552: PPUSH
108553: CALL_OW 256
108557: PUSH
108558: LD_INT 700
108560: LESS
108561: PUSH
108562: LD_VAR 0 4
108566: PUSH
108567: LD_VAR 0 7
108571: ARRAY
108572: PUSH
108573: LD_VAR 0 32
108577: IN
108578: NOT
108579: AND
108580: IFFALSE 108604
// to_repair := to_repair union group [ i ] ;
108582: LD_ADDR_VAR 0 32
108586: PUSH
108587: LD_VAR 0 32
108591: PUSH
108592: LD_VAR 0 4
108596: PUSH
108597: LD_VAR 0 7
108601: ARRAY
108602: UNION
108603: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
108604: LD_VAR 0 4
108608: PUSH
108609: LD_VAR 0 7
108613: ARRAY
108614: PPUSH
108615: CALL_OW 256
108619: PUSH
108620: LD_INT 1000
108622: EQUAL
108623: PUSH
108624: LD_VAR 0 4
108628: PUSH
108629: LD_VAR 0 7
108633: ARRAY
108634: PUSH
108635: LD_VAR 0 32
108639: IN
108640: AND
108641: IFFALSE 108665
// to_repair := to_repair diff group [ i ] ;
108643: LD_ADDR_VAR 0 32
108647: PUSH
108648: LD_VAR 0 32
108652: PUSH
108653: LD_VAR 0 4
108657: PUSH
108658: LD_VAR 0 7
108662: ARRAY
108663: DIFF
108664: ST_TO_ADDR
// if group [ i ] in to_repair then
108665: LD_VAR 0 4
108669: PUSH
108670: LD_VAR 0 7
108674: ARRAY
108675: PUSH
108676: LD_VAR 0 32
108680: IN
108681: IFFALSE 108728
// begin if not IsInArea ( group [ i ] , f_repair ) then
108683: LD_VAR 0 4
108687: PUSH
108688: LD_VAR 0 7
108692: ARRAY
108693: PPUSH
108694: LD_VAR 0 22
108698: PPUSH
108699: CALL_OW 308
108703: NOT
108704: IFFALSE 108726
// ComMoveToArea ( group [ i ] , f_repair ) ;
108706: LD_VAR 0 4
108710: PUSH
108711: LD_VAR 0 7
108715: ARRAY
108716: PPUSH
108717: LD_VAR 0 22
108721: PPUSH
108722: CALL_OW 113
// continue ;
108726: GO 108353
// end ; end else
108728: GO 109008
// if group [ i ] in repairs then
108730: LD_VAR 0 4
108734: PUSH
108735: LD_VAR 0 7
108739: ARRAY
108740: PUSH
108741: LD_VAR 0 33
108745: IN
108746: IFFALSE 109008
// begin if IsInUnit ( group [ i ] ) then
108748: LD_VAR 0 4
108752: PUSH
108753: LD_VAR 0 7
108757: ARRAY
108758: PPUSH
108759: CALL_OW 310
108763: IFFALSE 108831
// begin z := IsInUnit ( group [ i ] ) ;
108765: LD_ADDR_VAR 0 13
108769: PUSH
108770: LD_VAR 0 4
108774: PUSH
108775: LD_VAR 0 7
108779: ARRAY
108780: PPUSH
108781: CALL_OW 310
108785: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
108786: LD_VAR 0 13
108790: PUSH
108791: LD_VAR 0 32
108795: IN
108796: PUSH
108797: LD_VAR 0 13
108801: PPUSH
108802: LD_VAR 0 22
108806: PPUSH
108807: CALL_OW 308
108811: AND
108812: IFFALSE 108829
// ComExitVehicle ( group [ i ] ) ;
108814: LD_VAR 0 4
108818: PUSH
108819: LD_VAR 0 7
108823: ARRAY
108824: PPUSH
108825: CALL_OW 121
// end else
108829: GO 109008
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
108831: LD_ADDR_VAR 0 13
108835: PUSH
108836: LD_VAR 0 4
108840: PPUSH
108841: LD_INT 95
108843: PUSH
108844: LD_VAR 0 22
108848: PUSH
108849: EMPTY
108850: LIST
108851: LIST
108852: PUSH
108853: LD_INT 58
108855: PUSH
108856: EMPTY
108857: LIST
108858: PUSH
108859: EMPTY
108860: LIST
108861: LIST
108862: PPUSH
108863: CALL_OW 72
108867: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
108868: LD_VAR 0 4
108872: PUSH
108873: LD_VAR 0 7
108877: ARRAY
108878: PPUSH
108879: CALL_OW 314
108883: NOT
108884: IFFALSE 109006
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
108886: LD_ADDR_VAR 0 10
108890: PUSH
108891: LD_VAR 0 13
108895: PPUSH
108896: LD_VAR 0 4
108900: PUSH
108901: LD_VAR 0 7
108905: ARRAY
108906: PPUSH
108907: CALL_OW 74
108911: ST_TO_ADDR
// if not x then
108912: LD_VAR 0 10
108916: NOT
108917: IFFALSE 108921
// continue ;
108919: GO 108353
// if GetLives ( x ) < 1000 then
108921: LD_VAR 0 10
108925: PPUSH
108926: CALL_OW 256
108930: PUSH
108931: LD_INT 1000
108933: LESS
108934: IFFALSE 108958
// ComRepairVehicle ( group [ i ] , x ) else
108936: LD_VAR 0 4
108940: PUSH
108941: LD_VAR 0 7
108945: ARRAY
108946: PPUSH
108947: LD_VAR 0 10
108951: PPUSH
108952: CALL_OW 129
108956: GO 109006
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
108958: LD_VAR 0 23
108962: PUSH
108963: LD_VAR 0 4
108967: PUSH
108968: LD_VAR 0 7
108972: ARRAY
108973: PPUSH
108974: CALL_OW 256
108978: PUSH
108979: LD_INT 1000
108981: LESS
108982: AND
108983: NOT
108984: IFFALSE 109006
// ComEnterUnit ( group [ i ] , x ) ;
108986: LD_VAR 0 4
108990: PUSH
108991: LD_VAR 0 7
108995: ARRAY
108996: PPUSH
108997: LD_VAR 0 10
109001: PPUSH
109002: CALL_OW 120
// end ; continue ;
109006: GO 108353
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
109008: LD_VAR 0 23
109012: PUSH
109013: LD_VAR 0 4
109017: PUSH
109018: LD_VAR 0 7
109022: ARRAY
109023: PPUSH
109024: CALL_OW 247
109028: PUSH
109029: LD_INT 1
109031: EQUAL
109032: AND
109033: IFFALSE 109511
// begin if group [ i ] in healers then
109035: LD_VAR 0 4
109039: PUSH
109040: LD_VAR 0 7
109044: ARRAY
109045: PUSH
109046: LD_VAR 0 31
109050: IN
109051: IFFALSE 109324
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
109053: LD_VAR 0 4
109057: PUSH
109058: LD_VAR 0 7
109062: ARRAY
109063: PPUSH
109064: LD_VAR 0 23
109068: PPUSH
109069: CALL_OW 308
109073: NOT
109074: PUSH
109075: LD_VAR 0 4
109079: PUSH
109080: LD_VAR 0 7
109084: ARRAY
109085: PPUSH
109086: CALL_OW 314
109090: NOT
109091: AND
109092: IFFALSE 109116
// ComMoveToArea ( group [ i ] , f_heal ) else
109094: LD_VAR 0 4
109098: PUSH
109099: LD_VAR 0 7
109103: ARRAY
109104: PPUSH
109105: LD_VAR 0 23
109109: PPUSH
109110: CALL_OW 113
109114: GO 109322
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
109116: LD_VAR 0 4
109120: PUSH
109121: LD_VAR 0 7
109125: ARRAY
109126: PPUSH
109127: CALL 50195 0 1
109131: PPUSH
109132: CALL_OW 256
109136: PUSH
109137: LD_INT 1000
109139: EQUAL
109140: IFFALSE 109159
// ComStop ( group [ i ] ) else
109142: LD_VAR 0 4
109146: PUSH
109147: LD_VAR 0 7
109151: ARRAY
109152: PPUSH
109153: CALL_OW 141
109157: GO 109322
// if not HasTask ( group [ i ] ) and to_heal then
109159: LD_VAR 0 4
109163: PUSH
109164: LD_VAR 0 7
109168: ARRAY
109169: PPUSH
109170: CALL_OW 314
109174: NOT
109175: PUSH
109176: LD_VAR 0 30
109180: AND
109181: IFFALSE 109322
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
109183: LD_ADDR_VAR 0 13
109187: PUSH
109188: LD_VAR 0 30
109192: PPUSH
109193: LD_INT 3
109195: PUSH
109196: LD_INT 54
109198: PUSH
109199: EMPTY
109200: LIST
109201: PUSH
109202: EMPTY
109203: LIST
109204: LIST
109205: PPUSH
109206: CALL_OW 72
109210: PPUSH
109211: LD_VAR 0 4
109215: PUSH
109216: LD_VAR 0 7
109220: ARRAY
109221: PPUSH
109222: CALL_OW 74
109226: ST_TO_ADDR
// if z then
109227: LD_VAR 0 13
109231: IFFALSE 109322
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
109233: LD_INT 91
109235: PUSH
109236: LD_VAR 0 13
109240: PUSH
109241: LD_INT 10
109243: PUSH
109244: EMPTY
109245: LIST
109246: LIST
109247: LIST
109248: PUSH
109249: LD_INT 81
109251: PUSH
109252: LD_VAR 0 13
109256: PPUSH
109257: CALL_OW 255
109261: PUSH
109262: EMPTY
109263: LIST
109264: LIST
109265: PUSH
109266: EMPTY
109267: LIST
109268: LIST
109269: PPUSH
109270: CALL_OW 69
109274: PUSH
109275: LD_INT 0
109277: EQUAL
109278: IFFALSE 109302
// ComHeal ( group [ i ] , z ) else
109280: LD_VAR 0 4
109284: PUSH
109285: LD_VAR 0 7
109289: ARRAY
109290: PPUSH
109291: LD_VAR 0 13
109295: PPUSH
109296: CALL_OW 128
109300: GO 109322
// ComMoveToArea ( group [ i ] , f_heal ) ;
109302: LD_VAR 0 4
109306: PUSH
109307: LD_VAR 0 7
109311: ARRAY
109312: PPUSH
109313: LD_VAR 0 23
109317: PPUSH
109318: CALL_OW 113
// end ; continue ;
109322: GO 108353
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
109324: LD_VAR 0 4
109328: PUSH
109329: LD_VAR 0 7
109333: ARRAY
109334: PPUSH
109335: CALL_OW 256
109339: PUSH
109340: LD_INT 700
109342: LESS
109343: PUSH
109344: LD_VAR 0 4
109348: PUSH
109349: LD_VAR 0 7
109353: ARRAY
109354: PUSH
109355: LD_VAR 0 30
109359: IN
109360: NOT
109361: AND
109362: IFFALSE 109386
// to_heal := to_heal union group [ i ] ;
109364: LD_ADDR_VAR 0 30
109368: PUSH
109369: LD_VAR 0 30
109373: PUSH
109374: LD_VAR 0 4
109378: PUSH
109379: LD_VAR 0 7
109383: ARRAY
109384: UNION
109385: ST_TO_ADDR
// if group [ i ] in to_heal then
109386: LD_VAR 0 4
109390: PUSH
109391: LD_VAR 0 7
109395: ARRAY
109396: PUSH
109397: LD_VAR 0 30
109401: IN
109402: IFFALSE 109511
// begin if GetLives ( group [ i ] ) = 1000 then
109404: LD_VAR 0 4
109408: PUSH
109409: LD_VAR 0 7
109413: ARRAY
109414: PPUSH
109415: CALL_OW 256
109419: PUSH
109420: LD_INT 1000
109422: EQUAL
109423: IFFALSE 109449
// to_heal := to_heal diff group [ i ] else
109425: LD_ADDR_VAR 0 30
109429: PUSH
109430: LD_VAR 0 30
109434: PUSH
109435: LD_VAR 0 4
109439: PUSH
109440: LD_VAR 0 7
109444: ARRAY
109445: DIFF
109446: ST_TO_ADDR
109447: GO 109511
// begin if not IsInArea ( group [ i ] , to_heal ) then
109449: LD_VAR 0 4
109453: PUSH
109454: LD_VAR 0 7
109458: ARRAY
109459: PPUSH
109460: LD_VAR 0 30
109464: PPUSH
109465: CALL_OW 308
109469: NOT
109470: IFFALSE 109494
// ComMoveToArea ( group [ i ] , f_heal ) else
109472: LD_VAR 0 4
109476: PUSH
109477: LD_VAR 0 7
109481: ARRAY
109482: PPUSH
109483: LD_VAR 0 23
109487: PPUSH
109488: CALL_OW 113
109492: GO 109509
// ComHold ( group [ i ] ) ;
109494: LD_VAR 0 4
109498: PUSH
109499: LD_VAR 0 7
109503: ARRAY
109504: PPUSH
109505: CALL_OW 140
// continue ;
109509: GO 108353
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
109511: LD_VAR 0 4
109515: PUSH
109516: LD_VAR 0 7
109520: ARRAY
109521: PPUSH
109522: LD_INT 10
109524: PPUSH
109525: CALL 47966 0 2
109529: NOT
109530: PUSH
109531: LD_VAR 0 16
109535: PUSH
109536: LD_VAR 0 7
109540: ARRAY
109541: PUSH
109542: EMPTY
109543: EQUAL
109544: NOT
109545: AND
109546: IFFALSE 109812
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
109548: LD_VAR 0 4
109552: PUSH
109553: LD_VAR 0 7
109557: ARRAY
109558: PPUSH
109559: CALL_OW 262
109563: PUSH
109564: LD_INT 1
109566: PUSH
109567: LD_INT 2
109569: PUSH
109570: EMPTY
109571: LIST
109572: LIST
109573: IN
109574: IFFALSE 109615
// if GetFuel ( group [ i ] ) < 10 then
109576: LD_VAR 0 4
109580: PUSH
109581: LD_VAR 0 7
109585: ARRAY
109586: PPUSH
109587: CALL_OW 261
109591: PUSH
109592: LD_INT 10
109594: LESS
109595: IFFALSE 109615
// SetFuel ( group [ i ] , 12 ) ;
109597: LD_VAR 0 4
109601: PUSH
109602: LD_VAR 0 7
109606: ARRAY
109607: PPUSH
109608: LD_INT 12
109610: PPUSH
109611: CALL_OW 240
// if units_path [ i ] then
109615: LD_VAR 0 16
109619: PUSH
109620: LD_VAR 0 7
109624: ARRAY
109625: IFFALSE 109810
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
109627: LD_VAR 0 4
109631: PUSH
109632: LD_VAR 0 7
109636: ARRAY
109637: PPUSH
109638: LD_VAR 0 16
109642: PUSH
109643: LD_VAR 0 7
109647: ARRAY
109648: PUSH
109649: LD_INT 1
109651: ARRAY
109652: PUSH
109653: LD_INT 1
109655: ARRAY
109656: PPUSH
109657: LD_VAR 0 16
109661: PUSH
109662: LD_VAR 0 7
109666: ARRAY
109667: PUSH
109668: LD_INT 1
109670: ARRAY
109671: PUSH
109672: LD_INT 2
109674: ARRAY
109675: PPUSH
109676: CALL_OW 297
109680: PUSH
109681: LD_INT 6
109683: GREATER
109684: IFFALSE 109759
// begin if not HasTask ( group [ i ] ) then
109686: LD_VAR 0 4
109690: PUSH
109691: LD_VAR 0 7
109695: ARRAY
109696: PPUSH
109697: CALL_OW 314
109701: NOT
109702: IFFALSE 109757
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
109704: LD_VAR 0 4
109708: PUSH
109709: LD_VAR 0 7
109713: ARRAY
109714: PPUSH
109715: LD_VAR 0 16
109719: PUSH
109720: LD_VAR 0 7
109724: ARRAY
109725: PUSH
109726: LD_INT 1
109728: ARRAY
109729: PUSH
109730: LD_INT 1
109732: ARRAY
109733: PPUSH
109734: LD_VAR 0 16
109738: PUSH
109739: LD_VAR 0 7
109743: ARRAY
109744: PUSH
109745: LD_INT 1
109747: ARRAY
109748: PUSH
109749: LD_INT 2
109751: ARRAY
109752: PPUSH
109753: CALL_OW 114
// end else
109757: GO 109810
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
109759: LD_ADDR_VAR 0 15
109763: PUSH
109764: LD_VAR 0 16
109768: PUSH
109769: LD_VAR 0 7
109773: ARRAY
109774: PPUSH
109775: LD_INT 1
109777: PPUSH
109778: CALL_OW 3
109782: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
109783: LD_ADDR_VAR 0 16
109787: PUSH
109788: LD_VAR 0 16
109792: PPUSH
109793: LD_VAR 0 7
109797: PPUSH
109798: LD_VAR 0 15
109802: PPUSH
109803: CALL_OW 1
109807: ST_TO_ADDR
// continue ;
109808: GO 108353
// end ; end ; end else
109810: GO 112474
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
109812: LD_ADDR_VAR 0 14
109816: PUSH
109817: LD_INT 81
109819: PUSH
109820: LD_VAR 0 4
109824: PUSH
109825: LD_VAR 0 7
109829: ARRAY
109830: PPUSH
109831: CALL_OW 255
109835: PUSH
109836: EMPTY
109837: LIST
109838: LIST
109839: PPUSH
109840: CALL_OW 69
109844: ST_TO_ADDR
// if not tmp then
109845: LD_VAR 0 14
109849: NOT
109850: IFFALSE 109854
// continue ;
109852: GO 108353
// if f_ignore_area then
109854: LD_VAR 0 17
109858: IFFALSE 109946
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
109860: LD_ADDR_VAR 0 15
109864: PUSH
109865: LD_VAR 0 14
109869: PPUSH
109870: LD_INT 3
109872: PUSH
109873: LD_INT 92
109875: PUSH
109876: LD_VAR 0 17
109880: PUSH
109881: LD_INT 1
109883: ARRAY
109884: PUSH
109885: LD_VAR 0 17
109889: PUSH
109890: LD_INT 2
109892: ARRAY
109893: PUSH
109894: LD_VAR 0 17
109898: PUSH
109899: LD_INT 3
109901: ARRAY
109902: PUSH
109903: EMPTY
109904: LIST
109905: LIST
109906: LIST
109907: LIST
109908: PUSH
109909: EMPTY
109910: LIST
109911: LIST
109912: PPUSH
109913: CALL_OW 72
109917: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109918: LD_VAR 0 14
109922: PUSH
109923: LD_VAR 0 15
109927: DIFF
109928: IFFALSE 109946
// tmp := tmp diff tmp2 ;
109930: LD_ADDR_VAR 0 14
109934: PUSH
109935: LD_VAR 0 14
109939: PUSH
109940: LD_VAR 0 15
109944: DIFF
109945: ST_TO_ADDR
// end ; if not f_murder then
109946: LD_VAR 0 20
109950: NOT
109951: IFFALSE 110009
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
109953: LD_ADDR_VAR 0 15
109957: PUSH
109958: LD_VAR 0 14
109962: PPUSH
109963: LD_INT 3
109965: PUSH
109966: LD_INT 50
109968: PUSH
109969: EMPTY
109970: LIST
109971: PUSH
109972: EMPTY
109973: LIST
109974: LIST
109975: PPUSH
109976: CALL_OW 72
109980: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
109981: LD_VAR 0 14
109985: PUSH
109986: LD_VAR 0 15
109990: DIFF
109991: IFFALSE 110009
// tmp := tmp diff tmp2 ;
109993: LD_ADDR_VAR 0 14
109997: PUSH
109998: LD_VAR 0 14
110002: PUSH
110003: LD_VAR 0 15
110007: DIFF
110008: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
110009: LD_ADDR_VAR 0 14
110013: PUSH
110014: LD_VAR 0 4
110018: PUSH
110019: LD_VAR 0 7
110023: ARRAY
110024: PPUSH
110025: LD_VAR 0 14
110029: PPUSH
110030: LD_INT 1
110032: PPUSH
110033: LD_INT 1
110035: PPUSH
110036: CALL 20898 0 4
110040: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
110041: LD_VAR 0 4
110045: PUSH
110046: LD_VAR 0 7
110050: ARRAY
110051: PPUSH
110052: CALL_OW 257
110056: PUSH
110057: LD_INT 1
110059: EQUAL
110060: IFFALSE 110508
// begin if WantPlant ( group [ i ] ) then
110062: LD_VAR 0 4
110066: PUSH
110067: LD_VAR 0 7
110071: ARRAY
110072: PPUSH
110073: CALL 20399 0 1
110077: IFFALSE 110081
// continue ;
110079: GO 108353
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
110081: LD_VAR 0 18
110085: PUSH
110086: LD_VAR 0 4
110090: PUSH
110091: LD_VAR 0 7
110095: ARRAY
110096: PPUSH
110097: CALL_OW 310
110101: NOT
110102: AND
110103: PUSH
110104: LD_VAR 0 14
110108: PUSH
110109: LD_INT 1
110111: ARRAY
110112: PUSH
110113: LD_VAR 0 14
110117: PPUSH
110118: LD_INT 21
110120: PUSH
110121: LD_INT 2
110123: PUSH
110124: EMPTY
110125: LIST
110126: LIST
110127: PUSH
110128: LD_INT 58
110130: PUSH
110131: EMPTY
110132: LIST
110133: PUSH
110134: EMPTY
110135: LIST
110136: LIST
110137: PPUSH
110138: CALL_OW 72
110142: IN
110143: AND
110144: IFFALSE 110180
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
110146: LD_VAR 0 4
110150: PUSH
110151: LD_VAR 0 7
110155: ARRAY
110156: PPUSH
110157: LD_VAR 0 14
110161: PUSH
110162: LD_INT 1
110164: ARRAY
110165: PPUSH
110166: CALL_OW 120
// attacking := true ;
110170: LD_ADDR_VAR 0 29
110174: PUSH
110175: LD_INT 1
110177: ST_TO_ADDR
// continue ;
110178: GO 108353
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
110180: LD_VAR 0 26
110184: PUSH
110185: LD_VAR 0 4
110189: PUSH
110190: LD_VAR 0 7
110194: ARRAY
110195: PPUSH
110196: CALL_OW 257
110200: PUSH
110201: LD_INT 1
110203: EQUAL
110204: AND
110205: PUSH
110206: LD_VAR 0 4
110210: PUSH
110211: LD_VAR 0 7
110215: ARRAY
110216: PPUSH
110217: CALL_OW 256
110221: PUSH
110222: LD_INT 800
110224: LESS
110225: AND
110226: PUSH
110227: LD_VAR 0 4
110231: PUSH
110232: LD_VAR 0 7
110236: ARRAY
110237: PPUSH
110238: CALL_OW 318
110242: NOT
110243: AND
110244: IFFALSE 110261
// ComCrawl ( group [ i ] ) ;
110246: LD_VAR 0 4
110250: PUSH
110251: LD_VAR 0 7
110255: ARRAY
110256: PPUSH
110257: CALL_OW 137
// if f_mines then
110261: LD_VAR 0 21
110265: IFFALSE 110508
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
110267: LD_VAR 0 14
110271: PUSH
110272: LD_INT 1
110274: ARRAY
110275: PPUSH
110276: CALL_OW 247
110280: PUSH
110281: LD_INT 3
110283: EQUAL
110284: PUSH
110285: LD_VAR 0 14
110289: PUSH
110290: LD_INT 1
110292: ARRAY
110293: PUSH
110294: LD_VAR 0 27
110298: IN
110299: NOT
110300: AND
110301: IFFALSE 110508
// begin x := GetX ( tmp [ 1 ] ) ;
110303: LD_ADDR_VAR 0 10
110307: PUSH
110308: LD_VAR 0 14
110312: PUSH
110313: LD_INT 1
110315: ARRAY
110316: PPUSH
110317: CALL_OW 250
110321: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
110322: LD_ADDR_VAR 0 11
110326: PUSH
110327: LD_VAR 0 14
110331: PUSH
110332: LD_INT 1
110334: ARRAY
110335: PPUSH
110336: CALL_OW 251
110340: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
110341: LD_ADDR_VAR 0 12
110345: PUSH
110346: LD_VAR 0 4
110350: PUSH
110351: LD_VAR 0 7
110355: ARRAY
110356: PPUSH
110357: CALL 48051 0 1
110361: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
110362: LD_VAR 0 4
110366: PUSH
110367: LD_VAR 0 7
110371: ARRAY
110372: PPUSH
110373: LD_VAR 0 10
110377: PPUSH
110378: LD_VAR 0 11
110382: PPUSH
110383: LD_VAR 0 14
110387: PUSH
110388: LD_INT 1
110390: ARRAY
110391: PPUSH
110392: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
110396: LD_VAR 0 4
110400: PUSH
110401: LD_VAR 0 7
110405: ARRAY
110406: PPUSH
110407: LD_VAR 0 10
110411: PPUSH
110412: LD_VAR 0 12
110416: PPUSH
110417: LD_INT 7
110419: PPUSH
110420: CALL_OW 272
110424: PPUSH
110425: LD_VAR 0 11
110429: PPUSH
110430: LD_VAR 0 12
110434: PPUSH
110435: LD_INT 7
110437: PPUSH
110438: CALL_OW 273
110442: PPUSH
110443: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
110447: LD_VAR 0 4
110451: PUSH
110452: LD_VAR 0 7
110456: ARRAY
110457: PPUSH
110458: LD_INT 71
110460: PPUSH
110461: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
110465: LD_ADDR_VAR 0 27
110469: PUSH
110470: LD_VAR 0 27
110474: PPUSH
110475: LD_VAR 0 27
110479: PUSH
110480: LD_INT 1
110482: PLUS
110483: PPUSH
110484: LD_VAR 0 14
110488: PUSH
110489: LD_INT 1
110491: ARRAY
110492: PPUSH
110493: CALL_OW 1
110497: ST_TO_ADDR
// attacking := true ;
110498: LD_ADDR_VAR 0 29
110502: PUSH
110503: LD_INT 1
110505: ST_TO_ADDR
// continue ;
110506: GO 108353
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
110508: LD_VAR 0 4
110512: PUSH
110513: LD_VAR 0 7
110517: ARRAY
110518: PPUSH
110519: CALL_OW 257
110523: PUSH
110524: LD_INT 17
110526: EQUAL
110527: PUSH
110528: LD_VAR 0 4
110532: PUSH
110533: LD_VAR 0 7
110537: ARRAY
110538: PPUSH
110539: CALL_OW 110
110543: PUSH
110544: LD_INT 71
110546: EQUAL
110547: NOT
110548: AND
110549: IFFALSE 110695
// begin attacking := false ;
110551: LD_ADDR_VAR 0 29
110555: PUSH
110556: LD_INT 0
110558: ST_TO_ADDR
// k := 5 ;
110559: LD_ADDR_VAR 0 9
110563: PUSH
110564: LD_INT 5
110566: ST_TO_ADDR
// if tmp < k then
110567: LD_VAR 0 14
110571: PUSH
110572: LD_VAR 0 9
110576: LESS
110577: IFFALSE 110589
// k := tmp ;
110579: LD_ADDR_VAR 0 9
110583: PUSH
110584: LD_VAR 0 14
110588: ST_TO_ADDR
// for j = 1 to k do
110589: LD_ADDR_VAR 0 8
110593: PUSH
110594: DOUBLE
110595: LD_INT 1
110597: DEC
110598: ST_TO_ADDR
110599: LD_VAR 0 9
110603: PUSH
110604: FOR_TO
110605: IFFALSE 110693
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
110607: LD_VAR 0 14
110611: PUSH
110612: LD_VAR 0 8
110616: ARRAY
110617: PUSH
110618: LD_VAR 0 14
110622: PPUSH
110623: LD_INT 58
110625: PUSH
110626: EMPTY
110627: LIST
110628: PPUSH
110629: CALL_OW 72
110633: IN
110634: NOT
110635: IFFALSE 110691
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
110637: LD_VAR 0 4
110641: PUSH
110642: LD_VAR 0 7
110646: ARRAY
110647: PPUSH
110648: LD_VAR 0 14
110652: PUSH
110653: LD_VAR 0 8
110657: ARRAY
110658: PPUSH
110659: CALL_OW 115
// attacking := true ;
110663: LD_ADDR_VAR 0 29
110667: PUSH
110668: LD_INT 1
110670: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
110671: LD_VAR 0 4
110675: PUSH
110676: LD_VAR 0 7
110680: ARRAY
110681: PPUSH
110682: LD_INT 71
110684: PPUSH
110685: CALL_OW 109
// continue ;
110689: GO 110604
// end ; end ;
110691: GO 110604
110693: POP
110694: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
110695: LD_VAR 0 4
110699: PUSH
110700: LD_VAR 0 7
110704: ARRAY
110705: PPUSH
110706: CALL_OW 257
110710: PUSH
110711: LD_INT 8
110713: EQUAL
110714: PUSH
110715: LD_VAR 0 4
110719: PUSH
110720: LD_VAR 0 7
110724: ARRAY
110725: PPUSH
110726: CALL_OW 264
110730: PUSH
110731: LD_INT 28
110733: PUSH
110734: LD_INT 45
110736: PUSH
110737: LD_INT 7
110739: PUSH
110740: LD_INT 47
110742: PUSH
110743: EMPTY
110744: LIST
110745: LIST
110746: LIST
110747: LIST
110748: IN
110749: OR
110750: IFFALSE 111006
// begin attacking := false ;
110752: LD_ADDR_VAR 0 29
110756: PUSH
110757: LD_INT 0
110759: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
110760: LD_VAR 0 14
110764: PUSH
110765: LD_INT 1
110767: ARRAY
110768: PPUSH
110769: CALL_OW 266
110773: PUSH
110774: LD_INT 32
110776: PUSH
110777: LD_INT 31
110779: PUSH
110780: LD_INT 33
110782: PUSH
110783: LD_INT 4
110785: PUSH
110786: LD_INT 5
110788: PUSH
110789: EMPTY
110790: LIST
110791: LIST
110792: LIST
110793: LIST
110794: LIST
110795: IN
110796: IFFALSE 110982
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
110798: LD_ADDR_VAR 0 9
110802: PUSH
110803: LD_VAR 0 14
110807: PUSH
110808: LD_INT 1
110810: ARRAY
110811: PPUSH
110812: CALL_OW 266
110816: PPUSH
110817: LD_VAR 0 14
110821: PUSH
110822: LD_INT 1
110824: ARRAY
110825: PPUSH
110826: CALL_OW 250
110830: PPUSH
110831: LD_VAR 0 14
110835: PUSH
110836: LD_INT 1
110838: ARRAY
110839: PPUSH
110840: CALL_OW 251
110844: PPUSH
110845: LD_VAR 0 14
110849: PUSH
110850: LD_INT 1
110852: ARRAY
110853: PPUSH
110854: CALL_OW 254
110858: PPUSH
110859: LD_VAR 0 14
110863: PUSH
110864: LD_INT 1
110866: ARRAY
110867: PPUSH
110868: CALL_OW 248
110872: PPUSH
110873: LD_INT 0
110875: PPUSH
110876: CALL 29421 0 6
110880: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
110881: LD_ADDR_VAR 0 8
110885: PUSH
110886: LD_VAR 0 4
110890: PUSH
110891: LD_VAR 0 7
110895: ARRAY
110896: PPUSH
110897: LD_VAR 0 9
110901: PPUSH
110902: CALL 48164 0 2
110906: ST_TO_ADDR
// if j then
110907: LD_VAR 0 8
110911: IFFALSE 110980
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
110913: LD_VAR 0 8
110917: PUSH
110918: LD_INT 1
110920: ARRAY
110921: PPUSH
110922: LD_VAR 0 8
110926: PUSH
110927: LD_INT 2
110929: ARRAY
110930: PPUSH
110931: CALL_OW 488
110935: IFFALSE 110980
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
110937: LD_VAR 0 4
110941: PUSH
110942: LD_VAR 0 7
110946: ARRAY
110947: PPUSH
110948: LD_VAR 0 8
110952: PUSH
110953: LD_INT 1
110955: ARRAY
110956: PPUSH
110957: LD_VAR 0 8
110961: PUSH
110962: LD_INT 2
110964: ARRAY
110965: PPUSH
110966: CALL_OW 116
// attacking := true ;
110970: LD_ADDR_VAR 0 29
110974: PUSH
110975: LD_INT 1
110977: ST_TO_ADDR
// continue ;
110978: GO 108353
// end ; end else
110980: GO 111006
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
110982: LD_VAR 0 4
110986: PUSH
110987: LD_VAR 0 7
110991: ARRAY
110992: PPUSH
110993: LD_VAR 0 14
110997: PUSH
110998: LD_INT 1
111000: ARRAY
111001: PPUSH
111002: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
111006: LD_VAR 0 4
111010: PUSH
111011: LD_VAR 0 7
111015: ARRAY
111016: PPUSH
111017: CALL_OW 265
111021: PUSH
111022: LD_INT 11
111024: EQUAL
111025: IFFALSE 111303
// begin k := 10 ;
111027: LD_ADDR_VAR 0 9
111031: PUSH
111032: LD_INT 10
111034: ST_TO_ADDR
// x := 0 ;
111035: LD_ADDR_VAR 0 10
111039: PUSH
111040: LD_INT 0
111042: ST_TO_ADDR
// if tmp < k then
111043: LD_VAR 0 14
111047: PUSH
111048: LD_VAR 0 9
111052: LESS
111053: IFFALSE 111065
// k := tmp ;
111055: LD_ADDR_VAR 0 9
111059: PUSH
111060: LD_VAR 0 14
111064: ST_TO_ADDR
// for j = k downto 1 do
111065: LD_ADDR_VAR 0 8
111069: PUSH
111070: DOUBLE
111071: LD_VAR 0 9
111075: INC
111076: ST_TO_ADDR
111077: LD_INT 1
111079: PUSH
111080: FOR_DOWNTO
111081: IFFALSE 111156
// begin if GetType ( tmp [ j ] ) = unit_human then
111083: LD_VAR 0 14
111087: PUSH
111088: LD_VAR 0 8
111092: ARRAY
111093: PPUSH
111094: CALL_OW 247
111098: PUSH
111099: LD_INT 1
111101: EQUAL
111102: IFFALSE 111154
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
111104: LD_VAR 0 4
111108: PUSH
111109: LD_VAR 0 7
111113: ARRAY
111114: PPUSH
111115: LD_VAR 0 14
111119: PUSH
111120: LD_VAR 0 8
111124: ARRAY
111125: PPUSH
111126: CALL 48418 0 2
// x := tmp [ j ] ;
111130: LD_ADDR_VAR 0 10
111134: PUSH
111135: LD_VAR 0 14
111139: PUSH
111140: LD_VAR 0 8
111144: ARRAY
111145: ST_TO_ADDR
// attacking := true ;
111146: LD_ADDR_VAR 0 29
111150: PUSH
111151: LD_INT 1
111153: ST_TO_ADDR
// end ; end ;
111154: GO 111080
111156: POP
111157: POP
// if not x then
111158: LD_VAR 0 10
111162: NOT
111163: IFFALSE 111303
// begin attacking := true ;
111165: LD_ADDR_VAR 0 29
111169: PUSH
111170: LD_INT 1
111172: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
111173: LD_VAR 0 4
111177: PUSH
111178: LD_VAR 0 7
111182: ARRAY
111183: PPUSH
111184: CALL_OW 250
111188: PPUSH
111189: LD_VAR 0 4
111193: PUSH
111194: LD_VAR 0 7
111198: ARRAY
111199: PPUSH
111200: CALL_OW 251
111204: PPUSH
111205: CALL_OW 546
111209: PUSH
111210: LD_INT 2
111212: ARRAY
111213: PUSH
111214: LD_VAR 0 14
111218: PUSH
111219: LD_INT 1
111221: ARRAY
111222: PPUSH
111223: CALL_OW 250
111227: PPUSH
111228: LD_VAR 0 14
111232: PUSH
111233: LD_INT 1
111235: ARRAY
111236: PPUSH
111237: CALL_OW 251
111241: PPUSH
111242: CALL_OW 546
111246: PUSH
111247: LD_INT 2
111249: ARRAY
111250: EQUAL
111251: IFFALSE 111279
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
111253: LD_VAR 0 4
111257: PUSH
111258: LD_VAR 0 7
111262: ARRAY
111263: PPUSH
111264: LD_VAR 0 14
111268: PUSH
111269: LD_INT 1
111271: ARRAY
111272: PPUSH
111273: CALL 48418 0 2
111277: GO 111303
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111279: LD_VAR 0 4
111283: PUSH
111284: LD_VAR 0 7
111288: ARRAY
111289: PPUSH
111290: LD_VAR 0 14
111294: PUSH
111295: LD_INT 1
111297: ARRAY
111298: PPUSH
111299: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
111303: LD_VAR 0 4
111307: PUSH
111308: LD_VAR 0 7
111312: ARRAY
111313: PPUSH
111314: CALL_OW 264
111318: PUSH
111319: LD_INT 29
111321: EQUAL
111322: IFFALSE 111688
// begin if WantsToAttack ( group [ i ] ) in bombed then
111324: LD_VAR 0 4
111328: PUSH
111329: LD_VAR 0 7
111333: ARRAY
111334: PPUSH
111335: CALL_OW 319
111339: PUSH
111340: LD_VAR 0 28
111344: IN
111345: IFFALSE 111349
// continue ;
111347: GO 108353
// k := 8 ;
111349: LD_ADDR_VAR 0 9
111353: PUSH
111354: LD_INT 8
111356: ST_TO_ADDR
// x := 0 ;
111357: LD_ADDR_VAR 0 10
111361: PUSH
111362: LD_INT 0
111364: ST_TO_ADDR
// if tmp < k then
111365: LD_VAR 0 14
111369: PUSH
111370: LD_VAR 0 9
111374: LESS
111375: IFFALSE 111387
// k := tmp ;
111377: LD_ADDR_VAR 0 9
111381: PUSH
111382: LD_VAR 0 14
111386: ST_TO_ADDR
// for j = 1 to k do
111387: LD_ADDR_VAR 0 8
111391: PUSH
111392: DOUBLE
111393: LD_INT 1
111395: DEC
111396: ST_TO_ADDR
111397: LD_VAR 0 9
111401: PUSH
111402: FOR_TO
111403: IFFALSE 111535
// begin if GetType ( tmp [ j ] ) = unit_building then
111405: LD_VAR 0 14
111409: PUSH
111410: LD_VAR 0 8
111414: ARRAY
111415: PPUSH
111416: CALL_OW 247
111420: PUSH
111421: LD_INT 3
111423: EQUAL
111424: IFFALSE 111533
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
111426: LD_VAR 0 14
111430: PUSH
111431: LD_VAR 0 8
111435: ARRAY
111436: PUSH
111437: LD_VAR 0 28
111441: IN
111442: NOT
111443: PUSH
111444: LD_VAR 0 14
111448: PUSH
111449: LD_VAR 0 8
111453: ARRAY
111454: PPUSH
111455: CALL_OW 313
111459: AND
111460: IFFALSE 111533
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
111462: LD_VAR 0 4
111466: PUSH
111467: LD_VAR 0 7
111471: ARRAY
111472: PPUSH
111473: LD_VAR 0 14
111477: PUSH
111478: LD_VAR 0 8
111482: ARRAY
111483: PPUSH
111484: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
111488: LD_ADDR_VAR 0 28
111492: PUSH
111493: LD_VAR 0 28
111497: PPUSH
111498: LD_VAR 0 28
111502: PUSH
111503: LD_INT 1
111505: PLUS
111506: PPUSH
111507: LD_VAR 0 14
111511: PUSH
111512: LD_VAR 0 8
111516: ARRAY
111517: PPUSH
111518: CALL_OW 1
111522: ST_TO_ADDR
// attacking := true ;
111523: LD_ADDR_VAR 0 29
111527: PUSH
111528: LD_INT 1
111530: ST_TO_ADDR
// break ;
111531: GO 111535
// end ; end ;
111533: GO 111402
111535: POP
111536: POP
// if not attacking and f_attack_depot then
111537: LD_VAR 0 29
111541: NOT
111542: PUSH
111543: LD_VAR 0 25
111547: AND
111548: IFFALSE 111643
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
111550: LD_ADDR_VAR 0 13
111554: PUSH
111555: LD_VAR 0 14
111559: PPUSH
111560: LD_INT 2
111562: PUSH
111563: LD_INT 30
111565: PUSH
111566: LD_INT 0
111568: PUSH
111569: EMPTY
111570: LIST
111571: LIST
111572: PUSH
111573: LD_INT 30
111575: PUSH
111576: LD_INT 1
111578: PUSH
111579: EMPTY
111580: LIST
111581: LIST
111582: PUSH
111583: EMPTY
111584: LIST
111585: LIST
111586: LIST
111587: PPUSH
111588: CALL_OW 72
111592: ST_TO_ADDR
// if z then
111593: LD_VAR 0 13
111597: IFFALSE 111643
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
111599: LD_VAR 0 4
111603: PUSH
111604: LD_VAR 0 7
111608: ARRAY
111609: PPUSH
111610: LD_VAR 0 13
111614: PPUSH
111615: LD_VAR 0 4
111619: PUSH
111620: LD_VAR 0 7
111624: ARRAY
111625: PPUSH
111626: CALL_OW 74
111630: PPUSH
111631: CALL_OW 115
// attacking := true ;
111635: LD_ADDR_VAR 0 29
111639: PUSH
111640: LD_INT 1
111642: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
111643: LD_VAR 0 4
111647: PUSH
111648: LD_VAR 0 7
111652: ARRAY
111653: PPUSH
111654: CALL_OW 256
111658: PUSH
111659: LD_INT 500
111661: LESS
111662: IFFALSE 111688
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
111664: LD_VAR 0 4
111668: PUSH
111669: LD_VAR 0 7
111673: ARRAY
111674: PPUSH
111675: LD_VAR 0 14
111679: PUSH
111680: LD_INT 1
111682: ARRAY
111683: PPUSH
111684: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
111688: LD_VAR 0 4
111692: PUSH
111693: LD_VAR 0 7
111697: ARRAY
111698: PPUSH
111699: CALL_OW 264
111703: PUSH
111704: LD_INT 49
111706: EQUAL
111707: IFFALSE 111828
// begin if not HasTask ( group [ i ] ) then
111709: LD_VAR 0 4
111713: PUSH
111714: LD_VAR 0 7
111718: ARRAY
111719: PPUSH
111720: CALL_OW 314
111724: NOT
111725: IFFALSE 111828
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
111727: LD_ADDR_VAR 0 9
111731: PUSH
111732: LD_INT 81
111734: PUSH
111735: LD_VAR 0 4
111739: PUSH
111740: LD_VAR 0 7
111744: ARRAY
111745: PPUSH
111746: CALL_OW 255
111750: PUSH
111751: EMPTY
111752: LIST
111753: LIST
111754: PPUSH
111755: CALL_OW 69
111759: PPUSH
111760: LD_VAR 0 4
111764: PUSH
111765: LD_VAR 0 7
111769: ARRAY
111770: PPUSH
111771: CALL_OW 74
111775: ST_TO_ADDR
// if k then
111776: LD_VAR 0 9
111780: IFFALSE 111828
// if GetDistUnits ( group [ i ] , k ) > 10 then
111782: LD_VAR 0 4
111786: PUSH
111787: LD_VAR 0 7
111791: ARRAY
111792: PPUSH
111793: LD_VAR 0 9
111797: PPUSH
111798: CALL_OW 296
111802: PUSH
111803: LD_INT 10
111805: GREATER
111806: IFFALSE 111828
// ComMoveUnit ( group [ i ] , k ) ;
111808: LD_VAR 0 4
111812: PUSH
111813: LD_VAR 0 7
111817: ARRAY
111818: PPUSH
111819: LD_VAR 0 9
111823: PPUSH
111824: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
111828: LD_VAR 0 4
111832: PUSH
111833: LD_VAR 0 7
111837: ARRAY
111838: PPUSH
111839: CALL_OW 256
111843: PUSH
111844: LD_INT 250
111846: LESS
111847: PUSH
111848: LD_VAR 0 4
111852: PUSH
111853: LD_VAR 0 7
111857: ARRAY
111858: PUSH
111859: LD_INT 21
111861: PUSH
111862: LD_INT 2
111864: PUSH
111865: EMPTY
111866: LIST
111867: LIST
111868: PUSH
111869: LD_INT 23
111871: PUSH
111872: LD_INT 2
111874: PUSH
111875: EMPTY
111876: LIST
111877: LIST
111878: PUSH
111879: EMPTY
111880: LIST
111881: LIST
111882: PPUSH
111883: CALL_OW 69
111887: IN
111888: AND
111889: IFFALSE 112014
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
111891: LD_ADDR_VAR 0 9
111895: PUSH
111896: LD_OWVAR 3
111900: PUSH
111901: LD_VAR 0 4
111905: PUSH
111906: LD_VAR 0 7
111910: ARRAY
111911: DIFF
111912: PPUSH
111913: LD_VAR 0 4
111917: PUSH
111918: LD_VAR 0 7
111922: ARRAY
111923: PPUSH
111924: CALL_OW 74
111928: ST_TO_ADDR
// if not k then
111929: LD_VAR 0 9
111933: NOT
111934: IFFALSE 111938
// continue ;
111936: GO 108353
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
111938: LD_VAR 0 9
111942: PUSH
111943: LD_INT 81
111945: PUSH
111946: LD_VAR 0 4
111950: PUSH
111951: LD_VAR 0 7
111955: ARRAY
111956: PPUSH
111957: CALL_OW 255
111961: PUSH
111962: EMPTY
111963: LIST
111964: LIST
111965: PPUSH
111966: CALL_OW 69
111970: IN
111971: PUSH
111972: LD_VAR 0 9
111976: PPUSH
111977: LD_VAR 0 4
111981: PUSH
111982: LD_VAR 0 7
111986: ARRAY
111987: PPUSH
111988: CALL_OW 296
111992: PUSH
111993: LD_INT 5
111995: LESS
111996: AND
111997: IFFALSE 112014
// ComAutodestruct ( group [ i ] ) ;
111999: LD_VAR 0 4
112003: PUSH
112004: LD_VAR 0 7
112008: ARRAY
112009: PPUSH
112010: CALL 48316 0 1
// end ; if f_attack_depot then
112014: LD_VAR 0 25
112018: IFFALSE 112130
// begin k := 6 ;
112020: LD_ADDR_VAR 0 9
112024: PUSH
112025: LD_INT 6
112027: ST_TO_ADDR
// if tmp < k then
112028: LD_VAR 0 14
112032: PUSH
112033: LD_VAR 0 9
112037: LESS
112038: IFFALSE 112050
// k := tmp ;
112040: LD_ADDR_VAR 0 9
112044: PUSH
112045: LD_VAR 0 14
112049: ST_TO_ADDR
// for j = 1 to k do
112050: LD_ADDR_VAR 0 8
112054: PUSH
112055: DOUBLE
112056: LD_INT 1
112058: DEC
112059: ST_TO_ADDR
112060: LD_VAR 0 9
112064: PUSH
112065: FOR_TO
112066: IFFALSE 112128
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
112068: LD_VAR 0 8
112072: PPUSH
112073: CALL_OW 266
112077: PUSH
112078: LD_INT 0
112080: PUSH
112081: LD_INT 1
112083: PUSH
112084: EMPTY
112085: LIST
112086: LIST
112087: IN
112088: IFFALSE 112126
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112090: LD_VAR 0 4
112094: PUSH
112095: LD_VAR 0 7
112099: ARRAY
112100: PPUSH
112101: LD_VAR 0 14
112105: PUSH
112106: LD_VAR 0 8
112110: ARRAY
112111: PPUSH
112112: CALL_OW 115
// attacking := true ;
112116: LD_ADDR_VAR 0 29
112120: PUSH
112121: LD_INT 1
112123: ST_TO_ADDR
// break ;
112124: GO 112128
// end ;
112126: GO 112065
112128: POP
112129: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
112130: LD_VAR 0 4
112134: PUSH
112135: LD_VAR 0 7
112139: ARRAY
112140: PPUSH
112141: CALL_OW 302
112145: PUSH
112146: LD_VAR 0 29
112150: NOT
112151: AND
112152: IFFALSE 112474
// begin if GetTag ( group [ i ] ) = 71 then
112154: LD_VAR 0 4
112158: PUSH
112159: LD_VAR 0 7
112163: ARRAY
112164: PPUSH
112165: CALL_OW 110
112169: PUSH
112170: LD_INT 71
112172: EQUAL
112173: IFFALSE 112214
// begin if HasTask ( group [ i ] ) then
112175: LD_VAR 0 4
112179: PUSH
112180: LD_VAR 0 7
112184: ARRAY
112185: PPUSH
112186: CALL_OW 314
112190: IFFALSE 112196
// continue else
112192: GO 108353
112194: GO 112214
// SetTag ( group [ i ] , 0 ) ;
112196: LD_VAR 0 4
112200: PUSH
112201: LD_VAR 0 7
112205: ARRAY
112206: PPUSH
112207: LD_INT 0
112209: PPUSH
112210: CALL_OW 109
// end ; k := 8 ;
112214: LD_ADDR_VAR 0 9
112218: PUSH
112219: LD_INT 8
112221: ST_TO_ADDR
// x := 0 ;
112222: LD_ADDR_VAR 0 10
112226: PUSH
112227: LD_INT 0
112229: ST_TO_ADDR
// if tmp < k then
112230: LD_VAR 0 14
112234: PUSH
112235: LD_VAR 0 9
112239: LESS
112240: IFFALSE 112252
// k := tmp ;
112242: LD_ADDR_VAR 0 9
112246: PUSH
112247: LD_VAR 0 14
112251: ST_TO_ADDR
// for j = 1 to k do
112252: LD_ADDR_VAR 0 8
112256: PUSH
112257: DOUBLE
112258: LD_INT 1
112260: DEC
112261: ST_TO_ADDR
112262: LD_VAR 0 9
112266: PUSH
112267: FOR_TO
112268: IFFALSE 112366
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
112270: LD_VAR 0 14
112274: PUSH
112275: LD_VAR 0 8
112279: ARRAY
112280: PPUSH
112281: CALL_OW 247
112285: PUSH
112286: LD_INT 1
112288: EQUAL
112289: PUSH
112290: LD_VAR 0 14
112294: PUSH
112295: LD_VAR 0 8
112299: ARRAY
112300: PPUSH
112301: CALL_OW 256
112305: PUSH
112306: LD_INT 250
112308: LESS
112309: PUSH
112310: LD_VAR 0 20
112314: AND
112315: PUSH
112316: LD_VAR 0 20
112320: NOT
112321: PUSH
112322: LD_VAR 0 14
112326: PUSH
112327: LD_VAR 0 8
112331: ARRAY
112332: PPUSH
112333: CALL_OW 256
112337: PUSH
112338: LD_INT 250
112340: GREATEREQUAL
112341: AND
112342: OR
112343: AND
112344: IFFALSE 112364
// begin x := tmp [ j ] ;
112346: LD_ADDR_VAR 0 10
112350: PUSH
112351: LD_VAR 0 14
112355: PUSH
112356: LD_VAR 0 8
112360: ARRAY
112361: ST_TO_ADDR
// break ;
112362: GO 112366
// end ;
112364: GO 112267
112366: POP
112367: POP
// if x then
112368: LD_VAR 0 10
112372: IFFALSE 112396
// ComAttackUnit ( group [ i ] , x ) else
112374: LD_VAR 0 4
112378: PUSH
112379: LD_VAR 0 7
112383: ARRAY
112384: PPUSH
112385: LD_VAR 0 10
112389: PPUSH
112390: CALL_OW 115
112394: GO 112420
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
112396: LD_VAR 0 4
112400: PUSH
112401: LD_VAR 0 7
112405: ARRAY
112406: PPUSH
112407: LD_VAR 0 14
112411: PUSH
112412: LD_INT 1
112414: ARRAY
112415: PPUSH
112416: CALL_OW 115
// if not HasTask ( group [ i ] ) then
112420: LD_VAR 0 4
112424: PUSH
112425: LD_VAR 0 7
112429: ARRAY
112430: PPUSH
112431: CALL_OW 314
112435: NOT
112436: IFFALSE 112474
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
112438: LD_VAR 0 4
112442: PUSH
112443: LD_VAR 0 7
112447: ARRAY
112448: PPUSH
112449: LD_VAR 0 14
112453: PPUSH
112454: LD_VAR 0 4
112458: PUSH
112459: LD_VAR 0 7
112463: ARRAY
112464: PPUSH
112465: CALL_OW 74
112469: PPUSH
112470: CALL_OW 115
// end ; end ; end ;
112474: GO 108353
112476: POP
112477: POP
// wait ( 0 0$2 ) ;
112478: LD_INT 70
112480: PPUSH
112481: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
112485: LD_VAR 0 4
112489: NOT
112490: PUSH
112491: LD_VAR 0 4
112495: PUSH
112496: EMPTY
112497: EQUAL
112498: OR
112499: PUSH
112500: LD_INT 81
112502: PUSH
112503: LD_VAR 0 35
112507: PUSH
112508: EMPTY
112509: LIST
112510: LIST
112511: PPUSH
112512: CALL_OW 69
112516: NOT
112517: OR
112518: IFFALSE 108338
// end ;
112520: LD_VAR 0 2
112524: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
112525: LD_INT 0
112527: PPUSH
112528: PPUSH
112529: PPUSH
112530: PPUSH
112531: PPUSH
112532: PPUSH
// if not base or not mc_bases [ base ] or not solds then
112533: LD_VAR 0 1
112537: NOT
112538: PUSH
112539: LD_EXP 61
112543: PUSH
112544: LD_VAR 0 1
112548: ARRAY
112549: NOT
112550: OR
112551: PUSH
112552: LD_VAR 0 2
112556: NOT
112557: OR
112558: IFFALSE 112562
// exit ;
112560: GO 113116
// side := mc_sides [ base ] ;
112562: LD_ADDR_VAR 0 6
112566: PUSH
112567: LD_EXP 87
112571: PUSH
112572: LD_VAR 0 1
112576: ARRAY
112577: ST_TO_ADDR
// if not side then
112578: LD_VAR 0 6
112582: NOT
112583: IFFALSE 112587
// exit ;
112585: GO 113116
// for i in solds do
112587: LD_ADDR_VAR 0 7
112591: PUSH
112592: LD_VAR 0 2
112596: PUSH
112597: FOR_IN
112598: IFFALSE 112659
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
112600: LD_VAR 0 7
112604: PPUSH
112605: CALL_OW 310
112609: PPUSH
112610: CALL_OW 266
112614: PUSH
112615: LD_INT 32
112617: PUSH
112618: LD_INT 31
112620: PUSH
112621: EMPTY
112622: LIST
112623: LIST
112624: IN
112625: IFFALSE 112645
// solds := solds diff i else
112627: LD_ADDR_VAR 0 2
112631: PUSH
112632: LD_VAR 0 2
112636: PUSH
112637: LD_VAR 0 7
112641: DIFF
112642: ST_TO_ADDR
112643: GO 112657
// SetTag ( i , 18 ) ;
112645: LD_VAR 0 7
112649: PPUSH
112650: LD_INT 18
112652: PPUSH
112653: CALL_OW 109
112657: GO 112597
112659: POP
112660: POP
// if not solds then
112661: LD_VAR 0 2
112665: NOT
112666: IFFALSE 112670
// exit ;
112668: GO 113116
// repeat wait ( 0 0$2 ) ;
112670: LD_INT 70
112672: PPUSH
112673: CALL_OW 67
// enemy := mc_scan [ base ] ;
112677: LD_ADDR_VAR 0 4
112681: PUSH
112682: LD_EXP 84
112686: PUSH
112687: LD_VAR 0 1
112691: ARRAY
112692: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
112693: LD_EXP 61
112697: PUSH
112698: LD_VAR 0 1
112702: ARRAY
112703: NOT
112704: PUSH
112705: LD_EXP 61
112709: PUSH
112710: LD_VAR 0 1
112714: ARRAY
112715: PUSH
112716: EMPTY
112717: EQUAL
112718: OR
112719: IFFALSE 112756
// begin for i in solds do
112721: LD_ADDR_VAR 0 7
112725: PUSH
112726: LD_VAR 0 2
112730: PUSH
112731: FOR_IN
112732: IFFALSE 112745
// ComStop ( i ) ;
112734: LD_VAR 0 7
112738: PPUSH
112739: CALL_OW 141
112743: GO 112731
112745: POP
112746: POP
// solds := [ ] ;
112747: LD_ADDR_VAR 0 2
112751: PUSH
112752: EMPTY
112753: ST_TO_ADDR
// exit ;
112754: GO 113116
// end ; for i in solds do
112756: LD_ADDR_VAR 0 7
112760: PUSH
112761: LD_VAR 0 2
112765: PUSH
112766: FOR_IN
112767: IFFALSE 113088
// begin if IsInUnit ( i ) then
112769: LD_VAR 0 7
112773: PPUSH
112774: CALL_OW 310
112778: IFFALSE 112789
// ComExitBuilding ( i ) ;
112780: LD_VAR 0 7
112784: PPUSH
112785: CALL_OW 122
// if GetLives ( i ) > 500 then
112789: LD_VAR 0 7
112793: PPUSH
112794: CALL_OW 256
112798: PUSH
112799: LD_INT 500
112801: GREATER
112802: IFFALSE 112855
// begin e := NearestUnitToUnit ( enemy , i ) ;
112804: LD_ADDR_VAR 0 5
112808: PUSH
112809: LD_VAR 0 4
112813: PPUSH
112814: LD_VAR 0 7
112818: PPUSH
112819: CALL_OW 74
112823: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
112824: LD_VAR 0 7
112828: PPUSH
112829: LD_VAR 0 5
112833: PPUSH
112834: CALL_OW 250
112838: PPUSH
112839: LD_VAR 0 5
112843: PPUSH
112844: CALL_OW 251
112848: PPUSH
112849: CALL_OW 114
// end else
112853: GO 113086
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
112855: LD_VAR 0 7
112859: PPUSH
112860: LD_EXP 61
112864: PUSH
112865: LD_VAR 0 1
112869: ARRAY
112870: PPUSH
112871: LD_INT 2
112873: PUSH
112874: LD_INT 30
112876: PUSH
112877: LD_INT 0
112879: PUSH
112880: EMPTY
112881: LIST
112882: LIST
112883: PUSH
112884: LD_INT 30
112886: PUSH
112887: LD_INT 1
112889: PUSH
112890: EMPTY
112891: LIST
112892: LIST
112893: PUSH
112894: LD_INT 30
112896: PUSH
112897: LD_INT 6
112899: PUSH
112900: EMPTY
112901: LIST
112902: LIST
112903: PUSH
112904: EMPTY
112905: LIST
112906: LIST
112907: LIST
112908: LIST
112909: PPUSH
112910: CALL_OW 72
112914: PPUSH
112915: LD_VAR 0 7
112919: PPUSH
112920: CALL_OW 74
112924: PPUSH
112925: CALL_OW 296
112929: PUSH
112930: LD_INT 10
112932: GREATER
112933: IFFALSE 113086
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
112935: LD_ADDR_VAR 0 8
112939: PUSH
112940: LD_EXP 61
112944: PUSH
112945: LD_VAR 0 1
112949: ARRAY
112950: PPUSH
112951: LD_INT 2
112953: PUSH
112954: LD_INT 30
112956: PUSH
112957: LD_INT 0
112959: PUSH
112960: EMPTY
112961: LIST
112962: LIST
112963: PUSH
112964: LD_INT 30
112966: PUSH
112967: LD_INT 1
112969: PUSH
112970: EMPTY
112971: LIST
112972: LIST
112973: PUSH
112974: LD_INT 30
112976: PUSH
112977: LD_INT 6
112979: PUSH
112980: EMPTY
112981: LIST
112982: LIST
112983: PUSH
112984: EMPTY
112985: LIST
112986: LIST
112987: LIST
112988: LIST
112989: PPUSH
112990: CALL_OW 72
112994: PPUSH
112995: LD_VAR 0 7
112999: PPUSH
113000: CALL_OW 74
113004: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
113005: LD_VAR 0 7
113009: PPUSH
113010: LD_VAR 0 8
113014: PPUSH
113015: CALL_OW 250
113019: PPUSH
113020: LD_INT 3
113022: PPUSH
113023: LD_INT 5
113025: PPUSH
113026: CALL_OW 272
113030: PPUSH
113031: LD_VAR 0 8
113035: PPUSH
113036: CALL_OW 251
113040: PPUSH
113041: LD_INT 3
113043: PPUSH
113044: LD_INT 5
113046: PPUSH
113047: CALL_OW 273
113051: PPUSH
113052: CALL_OW 111
// SetTag ( i , 0 ) ;
113056: LD_VAR 0 7
113060: PPUSH
113061: LD_INT 0
113063: PPUSH
113064: CALL_OW 109
// solds := solds diff i ;
113068: LD_ADDR_VAR 0 2
113072: PUSH
113073: LD_VAR 0 2
113077: PUSH
113078: LD_VAR 0 7
113082: DIFF
113083: ST_TO_ADDR
// continue ;
113084: GO 112766
// end ; end ;
113086: GO 112766
113088: POP
113089: POP
// until not solds or not enemy ;
113090: LD_VAR 0 2
113094: NOT
113095: PUSH
113096: LD_VAR 0 4
113100: NOT
113101: OR
113102: IFFALSE 112670
// MC_Reset ( base , 18 ) ;
113104: LD_VAR 0 1
113108: PPUSH
113109: LD_INT 18
113111: PPUSH
113112: CALL 61186 0 2
// end ;
113116: LD_VAR 0 3
113120: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
113121: LD_INT 0
113123: PPUSH
113124: PPUSH
113125: PPUSH
113126: PPUSH
113127: PPUSH
113128: PPUSH
113129: PPUSH
113130: PPUSH
113131: PPUSH
113132: PPUSH
113133: PPUSH
113134: PPUSH
113135: PPUSH
113136: PPUSH
113137: PPUSH
113138: PPUSH
113139: PPUSH
113140: PPUSH
113141: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
113142: LD_ADDR_VAR 0 12
113146: PUSH
113147: LD_EXP 61
113151: PUSH
113152: LD_VAR 0 1
113156: ARRAY
113157: PPUSH
113158: LD_INT 25
113160: PUSH
113161: LD_INT 3
113163: PUSH
113164: EMPTY
113165: LIST
113166: LIST
113167: PPUSH
113168: CALL_OW 72
113172: ST_TO_ADDR
// if mc_remote_driver [ base ] then
113173: LD_EXP 101
113177: PUSH
113178: LD_VAR 0 1
113182: ARRAY
113183: IFFALSE 113207
// mechs := mechs diff mc_remote_driver [ base ] ;
113185: LD_ADDR_VAR 0 12
113189: PUSH
113190: LD_VAR 0 12
113194: PUSH
113195: LD_EXP 101
113199: PUSH
113200: LD_VAR 0 1
113204: ARRAY
113205: DIFF
113206: ST_TO_ADDR
// for i in mechs do
113207: LD_ADDR_VAR 0 4
113211: PUSH
113212: LD_VAR 0 12
113216: PUSH
113217: FOR_IN
113218: IFFALSE 113253
// if GetTag ( i ) > 0 then
113220: LD_VAR 0 4
113224: PPUSH
113225: CALL_OW 110
113229: PUSH
113230: LD_INT 0
113232: GREATER
113233: IFFALSE 113251
// mechs := mechs diff i ;
113235: LD_ADDR_VAR 0 12
113239: PUSH
113240: LD_VAR 0 12
113244: PUSH
113245: LD_VAR 0 4
113249: DIFF
113250: ST_TO_ADDR
113251: GO 113217
113253: POP
113254: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
113255: LD_ADDR_VAR 0 8
113259: PUSH
113260: LD_EXP 61
113264: PUSH
113265: LD_VAR 0 1
113269: ARRAY
113270: PPUSH
113271: LD_INT 2
113273: PUSH
113274: LD_INT 25
113276: PUSH
113277: LD_INT 1
113279: PUSH
113280: EMPTY
113281: LIST
113282: LIST
113283: PUSH
113284: LD_INT 25
113286: PUSH
113287: LD_INT 5
113289: PUSH
113290: EMPTY
113291: LIST
113292: LIST
113293: PUSH
113294: LD_INT 25
113296: PUSH
113297: LD_INT 8
113299: PUSH
113300: EMPTY
113301: LIST
113302: LIST
113303: PUSH
113304: LD_INT 25
113306: PUSH
113307: LD_INT 9
113309: PUSH
113310: EMPTY
113311: LIST
113312: LIST
113313: PUSH
113314: EMPTY
113315: LIST
113316: LIST
113317: LIST
113318: LIST
113319: LIST
113320: PPUSH
113321: CALL_OW 72
113325: ST_TO_ADDR
// if not defenders and not solds then
113326: LD_VAR 0 2
113330: NOT
113331: PUSH
113332: LD_VAR 0 8
113336: NOT
113337: AND
113338: IFFALSE 113342
// exit ;
113340: GO 115112
// depot_under_attack := false ;
113342: LD_ADDR_VAR 0 16
113346: PUSH
113347: LD_INT 0
113349: ST_TO_ADDR
// sold_defenders := [ ] ;
113350: LD_ADDR_VAR 0 17
113354: PUSH
113355: EMPTY
113356: ST_TO_ADDR
// if mechs then
113357: LD_VAR 0 12
113361: IFFALSE 113514
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
113363: LD_ADDR_VAR 0 4
113367: PUSH
113368: LD_VAR 0 2
113372: PPUSH
113373: LD_INT 21
113375: PUSH
113376: LD_INT 2
113378: PUSH
113379: EMPTY
113380: LIST
113381: LIST
113382: PPUSH
113383: CALL_OW 72
113387: PUSH
113388: FOR_IN
113389: IFFALSE 113512
// begin if GetTag ( i ) <> 20 then
113391: LD_VAR 0 4
113395: PPUSH
113396: CALL_OW 110
113400: PUSH
113401: LD_INT 20
113403: NONEQUAL
113404: IFFALSE 113418
// SetTag ( i , 20 ) ;
113406: LD_VAR 0 4
113410: PPUSH
113411: LD_INT 20
113413: PPUSH
113414: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
113418: LD_VAR 0 4
113422: PPUSH
113423: CALL_OW 263
113427: PUSH
113428: LD_INT 1
113430: EQUAL
113431: PUSH
113432: LD_VAR 0 4
113436: PPUSH
113437: CALL_OW 311
113441: NOT
113442: AND
113443: IFFALSE 113510
// begin un := mechs [ 1 ] ;
113445: LD_ADDR_VAR 0 10
113449: PUSH
113450: LD_VAR 0 12
113454: PUSH
113455: LD_INT 1
113457: ARRAY
113458: ST_TO_ADDR
// ComExit ( un ) ;
113459: LD_VAR 0 10
113463: PPUSH
113464: CALL 53200 0 1
// AddComEnterUnit ( un , i ) ;
113468: LD_VAR 0 10
113472: PPUSH
113473: LD_VAR 0 4
113477: PPUSH
113478: CALL_OW 180
// SetTag ( un , 19 ) ;
113482: LD_VAR 0 10
113486: PPUSH
113487: LD_INT 19
113489: PPUSH
113490: CALL_OW 109
// mechs := mechs diff un ;
113494: LD_ADDR_VAR 0 12
113498: PUSH
113499: LD_VAR 0 12
113503: PUSH
113504: LD_VAR 0 10
113508: DIFF
113509: ST_TO_ADDR
// end ; end ;
113510: GO 113388
113512: POP
113513: POP
// if solds then
113514: LD_VAR 0 8
113518: IFFALSE 113577
// for i in solds do
113520: LD_ADDR_VAR 0 4
113524: PUSH
113525: LD_VAR 0 8
113529: PUSH
113530: FOR_IN
113531: IFFALSE 113575
// if not GetTag ( i ) then
113533: LD_VAR 0 4
113537: PPUSH
113538: CALL_OW 110
113542: NOT
113543: IFFALSE 113573
// begin defenders := defenders union i ;
113545: LD_ADDR_VAR 0 2
113549: PUSH
113550: LD_VAR 0 2
113554: PUSH
113555: LD_VAR 0 4
113559: UNION
113560: ST_TO_ADDR
// SetTag ( i , 18 ) ;
113561: LD_VAR 0 4
113565: PPUSH
113566: LD_INT 18
113568: PPUSH
113569: CALL_OW 109
// end ;
113573: GO 113530
113575: POP
113576: POP
// repeat wait ( 0 0$2 ) ;
113577: LD_INT 70
113579: PPUSH
113580: CALL_OW 67
// enemy := mc_scan [ base ] ;
113584: LD_ADDR_VAR 0 21
113588: PUSH
113589: LD_EXP 84
113593: PUSH
113594: LD_VAR 0 1
113598: ARRAY
113599: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
113600: LD_EXP 61
113604: PUSH
113605: LD_VAR 0 1
113609: ARRAY
113610: NOT
113611: PUSH
113612: LD_EXP 61
113616: PUSH
113617: LD_VAR 0 1
113621: ARRAY
113622: PUSH
113623: EMPTY
113624: EQUAL
113625: OR
113626: IFFALSE 113663
// begin for i in defenders do
113628: LD_ADDR_VAR 0 4
113632: PUSH
113633: LD_VAR 0 2
113637: PUSH
113638: FOR_IN
113639: IFFALSE 113652
// ComStop ( i ) ;
113641: LD_VAR 0 4
113645: PPUSH
113646: CALL_OW 141
113650: GO 113638
113652: POP
113653: POP
// defenders := [ ] ;
113654: LD_ADDR_VAR 0 2
113658: PUSH
113659: EMPTY
113660: ST_TO_ADDR
// exit ;
113661: GO 115112
// end ; for i in defenders do
113663: LD_ADDR_VAR 0 4
113667: PUSH
113668: LD_VAR 0 2
113672: PUSH
113673: FOR_IN
113674: IFFALSE 114572
// begin e := NearestUnitToUnit ( enemy , i ) ;
113676: LD_ADDR_VAR 0 13
113680: PUSH
113681: LD_VAR 0 21
113685: PPUSH
113686: LD_VAR 0 4
113690: PPUSH
113691: CALL_OW 74
113695: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113696: LD_ADDR_VAR 0 7
113700: PUSH
113701: LD_EXP 61
113705: PUSH
113706: LD_VAR 0 1
113710: ARRAY
113711: PPUSH
113712: LD_INT 2
113714: PUSH
113715: LD_INT 30
113717: PUSH
113718: LD_INT 0
113720: PUSH
113721: EMPTY
113722: LIST
113723: LIST
113724: PUSH
113725: LD_INT 30
113727: PUSH
113728: LD_INT 1
113730: PUSH
113731: EMPTY
113732: LIST
113733: LIST
113734: PUSH
113735: EMPTY
113736: LIST
113737: LIST
113738: LIST
113739: PPUSH
113740: CALL_OW 72
113744: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
113745: LD_ADDR_VAR 0 16
113749: PUSH
113750: LD_VAR 0 7
113754: NOT
113755: PUSH
113756: LD_VAR 0 7
113760: PPUSH
113761: LD_INT 3
113763: PUSH
113764: LD_INT 24
113766: PUSH
113767: LD_INT 600
113769: PUSH
113770: EMPTY
113771: LIST
113772: LIST
113773: PUSH
113774: EMPTY
113775: LIST
113776: LIST
113777: PPUSH
113778: CALL_OW 72
113782: OR
113783: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
113784: LD_VAR 0 4
113788: PPUSH
113789: CALL_OW 247
113793: PUSH
113794: LD_INT 2
113796: DOUBLE
113797: EQUAL
113798: IFTRUE 113802
113800: GO 114198
113802: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
113803: LD_VAR 0 4
113807: PPUSH
113808: CALL_OW 256
113812: PUSH
113813: LD_INT 1000
113815: EQUAL
113816: PUSH
113817: LD_VAR 0 4
113821: PPUSH
113822: LD_VAR 0 13
113826: PPUSH
113827: CALL_OW 296
113831: PUSH
113832: LD_INT 40
113834: LESS
113835: PUSH
113836: LD_VAR 0 13
113840: PPUSH
113841: LD_EXP 86
113845: PUSH
113846: LD_VAR 0 1
113850: ARRAY
113851: PPUSH
113852: CALL_OW 308
113856: OR
113857: AND
113858: IFFALSE 113980
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
113860: LD_VAR 0 4
113864: PPUSH
113865: CALL_OW 262
113869: PUSH
113870: LD_INT 1
113872: EQUAL
113873: PUSH
113874: LD_VAR 0 4
113878: PPUSH
113879: CALL_OW 261
113883: PUSH
113884: LD_INT 30
113886: LESS
113887: AND
113888: PUSH
113889: LD_VAR 0 7
113893: AND
113894: IFFALSE 113964
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
113896: LD_VAR 0 4
113900: PPUSH
113901: LD_VAR 0 7
113905: PPUSH
113906: LD_VAR 0 4
113910: PPUSH
113911: CALL_OW 74
113915: PPUSH
113916: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
113920: LD_VAR 0 4
113924: PPUSH
113925: LD_VAR 0 7
113929: PPUSH
113930: LD_VAR 0 4
113934: PPUSH
113935: CALL_OW 74
113939: PPUSH
113940: CALL_OW 296
113944: PUSH
113945: LD_INT 6
113947: LESS
113948: IFFALSE 113962
// SetFuel ( i , 100 ) ;
113950: LD_VAR 0 4
113954: PPUSH
113955: LD_INT 100
113957: PPUSH
113958: CALL_OW 240
// end else
113962: GO 113978
// ComAttackUnit ( i , e ) ;
113964: LD_VAR 0 4
113968: PPUSH
113969: LD_VAR 0 13
113973: PPUSH
113974: CALL_OW 115
// end else
113978: GO 114081
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
113980: LD_VAR 0 13
113984: PPUSH
113985: LD_EXP 86
113989: PUSH
113990: LD_VAR 0 1
113994: ARRAY
113995: PPUSH
113996: CALL_OW 308
114000: NOT
114001: PUSH
114002: LD_VAR 0 4
114006: PPUSH
114007: LD_VAR 0 13
114011: PPUSH
114012: CALL_OW 296
114016: PUSH
114017: LD_INT 40
114019: GREATEREQUAL
114020: AND
114021: PUSH
114022: LD_VAR 0 4
114026: PPUSH
114027: CALL_OW 256
114031: PUSH
114032: LD_INT 650
114034: LESSEQUAL
114035: OR
114036: PUSH
114037: LD_VAR 0 4
114041: PPUSH
114042: LD_EXP 85
114046: PUSH
114047: LD_VAR 0 1
114051: ARRAY
114052: PPUSH
114053: CALL_OW 308
114057: NOT
114058: AND
114059: IFFALSE 114081
// ComMoveToArea ( i , mc_parking [ base ] ) ;
114061: LD_VAR 0 4
114065: PPUSH
114066: LD_EXP 85
114070: PUSH
114071: LD_VAR 0 1
114075: ARRAY
114076: PPUSH
114077: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
114081: LD_VAR 0 4
114085: PPUSH
114086: CALL_OW 256
114090: PUSH
114091: LD_INT 1000
114093: LESS
114094: PUSH
114095: LD_VAR 0 4
114099: PPUSH
114100: CALL_OW 263
114104: PUSH
114105: LD_INT 1
114107: EQUAL
114108: AND
114109: PUSH
114110: LD_VAR 0 4
114114: PPUSH
114115: CALL_OW 311
114119: AND
114120: PUSH
114121: LD_VAR 0 4
114125: PPUSH
114126: LD_EXP 85
114130: PUSH
114131: LD_VAR 0 1
114135: ARRAY
114136: PPUSH
114137: CALL_OW 308
114141: AND
114142: IFFALSE 114196
// begin mech := IsDrivenBy ( i ) ;
114144: LD_ADDR_VAR 0 9
114148: PUSH
114149: LD_VAR 0 4
114153: PPUSH
114154: CALL_OW 311
114158: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
114159: LD_VAR 0 9
114163: PPUSH
114164: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
114168: LD_VAR 0 9
114172: PPUSH
114173: LD_VAR 0 4
114177: PPUSH
114178: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
114182: LD_VAR 0 9
114186: PPUSH
114187: LD_VAR 0 4
114191: PPUSH
114192: CALL_OW 180
// end ; end ; unit_human :
114196: GO 114543
114198: LD_INT 1
114200: DOUBLE
114201: EQUAL
114202: IFTRUE 114206
114204: GO 114542
114206: POP
// begin b := IsInUnit ( i ) ;
114207: LD_ADDR_VAR 0 18
114211: PUSH
114212: LD_VAR 0 4
114216: PPUSH
114217: CALL_OW 310
114221: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
114222: LD_ADDR_VAR 0 19
114226: PUSH
114227: LD_VAR 0 18
114231: NOT
114232: PUSH
114233: LD_VAR 0 18
114237: PPUSH
114238: CALL_OW 266
114242: PUSH
114243: LD_INT 32
114245: PUSH
114246: LD_INT 31
114248: PUSH
114249: EMPTY
114250: LIST
114251: LIST
114252: IN
114253: OR
114254: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
114255: LD_VAR 0 18
114259: PPUSH
114260: CALL_OW 266
114264: PUSH
114265: LD_INT 5
114267: EQUAL
114268: PUSH
114269: LD_VAR 0 4
114273: PPUSH
114274: CALL_OW 257
114278: PUSH
114279: LD_INT 1
114281: PUSH
114282: LD_INT 2
114284: PUSH
114285: LD_INT 3
114287: PUSH
114288: LD_INT 4
114290: PUSH
114291: EMPTY
114292: LIST
114293: LIST
114294: LIST
114295: LIST
114296: IN
114297: AND
114298: IFFALSE 114335
// begin class := AllowSpecClass ( i ) ;
114300: LD_ADDR_VAR 0 20
114304: PUSH
114305: LD_VAR 0 4
114309: PPUSH
114310: CALL 17287 0 1
114314: ST_TO_ADDR
// if class then
114315: LD_VAR 0 20
114319: IFFALSE 114335
// ComChangeProfession ( i , class ) ;
114321: LD_VAR 0 4
114325: PPUSH
114326: LD_VAR 0 20
114330: PPUSH
114331: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
114335: LD_VAR 0 16
114339: PUSH
114340: LD_VAR 0 2
114344: PPUSH
114345: LD_INT 21
114347: PUSH
114348: LD_INT 2
114350: PUSH
114351: EMPTY
114352: LIST
114353: LIST
114354: PPUSH
114355: CALL_OW 72
114359: PUSH
114360: LD_INT 1
114362: LESSEQUAL
114363: OR
114364: PUSH
114365: LD_VAR 0 19
114369: AND
114370: PUSH
114371: LD_VAR 0 4
114375: PUSH
114376: LD_VAR 0 17
114380: IN
114381: NOT
114382: AND
114383: IFFALSE 114476
// begin if b then
114385: LD_VAR 0 18
114389: IFFALSE 114438
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
114391: LD_VAR 0 18
114395: PPUSH
114396: LD_VAR 0 21
114400: PPUSH
114401: LD_VAR 0 18
114405: PPUSH
114406: CALL_OW 74
114410: PPUSH
114411: CALL_OW 296
114415: PUSH
114416: LD_INT 10
114418: LESS
114419: PUSH
114420: LD_VAR 0 18
114424: PPUSH
114425: CALL_OW 461
114429: PUSH
114430: LD_INT 7
114432: NONEQUAL
114433: AND
114434: IFFALSE 114438
// continue ;
114436: GO 113673
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
114438: LD_ADDR_VAR 0 17
114442: PUSH
114443: LD_VAR 0 17
114447: PPUSH
114448: LD_VAR 0 17
114452: PUSH
114453: LD_INT 1
114455: PLUS
114456: PPUSH
114457: LD_VAR 0 4
114461: PPUSH
114462: CALL_OW 1
114466: ST_TO_ADDR
// ComExitBuilding ( i ) ;
114467: LD_VAR 0 4
114471: PPUSH
114472: CALL_OW 122
// end ; if sold_defenders then
114476: LD_VAR 0 17
114480: IFFALSE 114540
// if i in sold_defenders then
114482: LD_VAR 0 4
114486: PUSH
114487: LD_VAR 0 17
114491: IN
114492: IFFALSE 114540
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
114494: LD_VAR 0 4
114498: PPUSH
114499: CALL_OW 314
114503: NOT
114504: PUSH
114505: LD_VAR 0 4
114509: PPUSH
114510: LD_VAR 0 13
114514: PPUSH
114515: CALL_OW 296
114519: PUSH
114520: LD_INT 30
114522: LESS
114523: AND
114524: IFFALSE 114540
// ComAttackUnit ( i , e ) ;
114526: LD_VAR 0 4
114530: PPUSH
114531: LD_VAR 0 13
114535: PPUSH
114536: CALL_OW 115
// end ; end ; end ;
114540: GO 114543
114542: POP
// if IsDead ( i ) then
114543: LD_VAR 0 4
114547: PPUSH
114548: CALL_OW 301
114552: IFFALSE 114570
// defenders := defenders diff i ;
114554: LD_ADDR_VAR 0 2
114558: PUSH
114559: LD_VAR 0 2
114563: PUSH
114564: LD_VAR 0 4
114568: DIFF
114569: ST_TO_ADDR
// end ;
114570: GO 113673
114572: POP
114573: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
114574: LD_VAR 0 21
114578: NOT
114579: PUSH
114580: LD_VAR 0 2
114584: NOT
114585: OR
114586: PUSH
114587: LD_EXP 61
114591: PUSH
114592: LD_VAR 0 1
114596: ARRAY
114597: NOT
114598: OR
114599: IFFALSE 113577
// MC_Reset ( base , 18 ) ;
114601: LD_VAR 0 1
114605: PPUSH
114606: LD_INT 18
114608: PPUSH
114609: CALL 61186 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
114613: LD_ADDR_VAR 0 2
114617: PUSH
114618: LD_VAR 0 2
114622: PUSH
114623: LD_VAR 0 2
114627: PPUSH
114628: LD_INT 2
114630: PUSH
114631: LD_INT 25
114633: PUSH
114634: LD_INT 1
114636: PUSH
114637: EMPTY
114638: LIST
114639: LIST
114640: PUSH
114641: LD_INT 25
114643: PUSH
114644: LD_INT 5
114646: PUSH
114647: EMPTY
114648: LIST
114649: LIST
114650: PUSH
114651: LD_INT 25
114653: PUSH
114654: LD_INT 8
114656: PUSH
114657: EMPTY
114658: LIST
114659: LIST
114660: PUSH
114661: LD_INT 25
114663: PUSH
114664: LD_INT 9
114666: PUSH
114667: EMPTY
114668: LIST
114669: LIST
114670: PUSH
114671: EMPTY
114672: LIST
114673: LIST
114674: LIST
114675: LIST
114676: LIST
114677: PPUSH
114678: CALL_OW 72
114682: DIFF
114683: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
114684: LD_VAR 0 21
114688: NOT
114689: PUSH
114690: LD_VAR 0 2
114694: PPUSH
114695: LD_INT 21
114697: PUSH
114698: LD_INT 2
114700: PUSH
114701: EMPTY
114702: LIST
114703: LIST
114704: PPUSH
114705: CALL_OW 72
114709: AND
114710: IFFALSE 115048
// begin tmp := FilterByTag ( defenders , 19 ) ;
114712: LD_ADDR_VAR 0 11
114716: PUSH
114717: LD_VAR 0 2
114721: PPUSH
114722: LD_INT 19
114724: PPUSH
114725: CALL 50384 0 2
114729: ST_TO_ADDR
// if tmp then
114730: LD_VAR 0 11
114734: IFFALSE 114804
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
114736: LD_ADDR_VAR 0 11
114740: PUSH
114741: LD_VAR 0 11
114745: PPUSH
114746: LD_INT 25
114748: PUSH
114749: LD_INT 3
114751: PUSH
114752: EMPTY
114753: LIST
114754: LIST
114755: PPUSH
114756: CALL_OW 72
114760: ST_TO_ADDR
// if tmp then
114761: LD_VAR 0 11
114765: IFFALSE 114804
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
114767: LD_ADDR_EXP 73
114771: PUSH
114772: LD_EXP 73
114776: PPUSH
114777: LD_VAR 0 1
114781: PPUSH
114782: LD_EXP 73
114786: PUSH
114787: LD_VAR 0 1
114791: ARRAY
114792: PUSH
114793: LD_VAR 0 11
114797: UNION
114798: PPUSH
114799: CALL_OW 1
114803: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
114804: LD_VAR 0 1
114808: PPUSH
114809: LD_INT 19
114811: PPUSH
114812: CALL 61186 0 2
// repeat wait ( 0 0$1 ) ;
114816: LD_INT 35
114818: PPUSH
114819: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114823: LD_EXP 61
114827: PUSH
114828: LD_VAR 0 1
114832: ARRAY
114833: NOT
114834: PUSH
114835: LD_EXP 61
114839: PUSH
114840: LD_VAR 0 1
114844: ARRAY
114845: PUSH
114846: EMPTY
114847: EQUAL
114848: OR
114849: IFFALSE 114886
// begin for i in defenders do
114851: LD_ADDR_VAR 0 4
114855: PUSH
114856: LD_VAR 0 2
114860: PUSH
114861: FOR_IN
114862: IFFALSE 114875
// ComStop ( i ) ;
114864: LD_VAR 0 4
114868: PPUSH
114869: CALL_OW 141
114873: GO 114861
114875: POP
114876: POP
// defenders := [ ] ;
114877: LD_ADDR_VAR 0 2
114881: PUSH
114882: EMPTY
114883: ST_TO_ADDR
// exit ;
114884: GO 115112
// end ; for i in defenders do
114886: LD_ADDR_VAR 0 4
114890: PUSH
114891: LD_VAR 0 2
114895: PUSH
114896: FOR_IN
114897: IFFALSE 114986
// begin if not IsInArea ( i , mc_parking [ base ] ) then
114899: LD_VAR 0 4
114903: PPUSH
114904: LD_EXP 85
114908: PUSH
114909: LD_VAR 0 1
114913: ARRAY
114914: PPUSH
114915: CALL_OW 308
114919: NOT
114920: IFFALSE 114944
// ComMoveToArea ( i , mc_parking [ base ] ) else
114922: LD_VAR 0 4
114926: PPUSH
114927: LD_EXP 85
114931: PUSH
114932: LD_VAR 0 1
114936: ARRAY
114937: PPUSH
114938: CALL_OW 113
114942: GO 114984
// if GetControl ( i ) = control_manual then
114944: LD_VAR 0 4
114948: PPUSH
114949: CALL_OW 263
114953: PUSH
114954: LD_INT 1
114956: EQUAL
114957: IFFALSE 114984
// if IsDrivenBy ( i ) then
114959: LD_VAR 0 4
114963: PPUSH
114964: CALL_OW 311
114968: IFFALSE 114984
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
114970: LD_VAR 0 4
114974: PPUSH
114975: CALL_OW 311
114979: PPUSH
114980: CALL_OW 121
// end ;
114984: GO 114896
114986: POP
114987: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
114988: LD_VAR 0 2
114992: PPUSH
114993: LD_INT 95
114995: PUSH
114996: LD_EXP 85
115000: PUSH
115001: LD_VAR 0 1
115005: ARRAY
115006: PUSH
115007: EMPTY
115008: LIST
115009: LIST
115010: PPUSH
115011: CALL_OW 72
115015: PUSH
115016: LD_VAR 0 2
115020: EQUAL
115021: PUSH
115022: LD_EXP 84
115026: PUSH
115027: LD_VAR 0 1
115031: ARRAY
115032: OR
115033: PUSH
115034: LD_EXP 61
115038: PUSH
115039: LD_VAR 0 1
115043: ARRAY
115044: NOT
115045: OR
115046: IFFALSE 114816
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
115048: LD_ADDR_EXP 83
115052: PUSH
115053: LD_EXP 83
115057: PPUSH
115058: LD_VAR 0 1
115062: PPUSH
115063: LD_VAR 0 2
115067: PPUSH
115068: LD_INT 21
115070: PUSH
115071: LD_INT 2
115073: PUSH
115074: EMPTY
115075: LIST
115076: LIST
115077: PPUSH
115078: CALL_OW 72
115082: PPUSH
115083: CALL_OW 1
115087: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
115088: LD_VAR 0 1
115092: PPUSH
115093: LD_INT 19
115095: PPUSH
115096: CALL 61186 0 2
// MC_Reset ( base , 20 ) ;
115100: LD_VAR 0 1
115104: PPUSH
115105: LD_INT 20
115107: PPUSH
115108: CALL 61186 0 2
// end ; end_of_file
115112: LD_VAR 0 3
115116: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
115117: LD_VAR 0 1
115121: PUSH
115122: LD_INT 200
115124: DOUBLE
115125: GREATEREQUAL
115126: IFFALSE 115134
115128: LD_INT 299
115130: DOUBLE
115131: LESSEQUAL
115132: IFTRUE 115136
115134: GO 115168
115136: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
115137: LD_VAR 0 1
115141: PPUSH
115142: LD_VAR 0 2
115146: PPUSH
115147: LD_VAR 0 3
115151: PPUSH
115152: LD_VAR 0 4
115156: PPUSH
115157: LD_VAR 0 5
115161: PPUSH
115162: CALL 103903 0 5
115166: GO 115245
115168: LD_INT 300
115170: DOUBLE
115171: GREATEREQUAL
115172: IFFALSE 115180
115174: LD_INT 399
115176: DOUBLE
115177: LESSEQUAL
115178: IFTRUE 115182
115180: GO 115244
115182: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
115183: LD_VAR 0 1
115187: PPUSH
115188: LD_VAR 0 2
115192: PPUSH
115193: LD_VAR 0 3
115197: PPUSH
115198: LD_VAR 0 4
115202: PPUSH
115203: LD_VAR 0 5
115207: PPUSH
115208: LD_VAR 0 6
115212: PPUSH
115213: LD_VAR 0 7
115217: PPUSH
115218: LD_VAR 0 8
115222: PPUSH
115223: LD_VAR 0 9
115227: PPUSH
115228: LD_VAR 0 10
115232: PPUSH
115233: LD_VAR 0 11
115237: PPUSH
115238: CALL 100228 0 11
115242: GO 115245
115244: POP
// end ;
115245: PPOPN 11
115247: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
115248: LD_VAR 0 1
115252: PPUSH
115253: LD_VAR 0 2
115257: PPUSH
115258: LD_VAR 0 3
115262: PPUSH
115263: LD_VAR 0 4
115267: PPUSH
115268: LD_VAR 0 5
115272: PPUSH
115273: CALL 103639 0 5
// end ; end_of_file
115277: PPOPN 5
115279: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
115280: LD_VAR 0 1
115284: PPUSH
115285: LD_VAR 0 2
115289: PPUSH
115290: LD_VAR 0 3
115294: PPUSH
115295: LD_VAR 0 4
115299: PPUSH
115300: LD_VAR 0 5
115304: PPUSH
115305: LD_VAR 0 6
115309: PPUSH
115310: CALL 87880 0 6
// end ;
115314: PPOPN 6
115316: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
115317: LD_INT 0
115319: PPUSH
// begin if not units then
115320: LD_VAR 0 1
115324: NOT
115325: IFFALSE 115329
// exit ;
115327: GO 115329
// end ;
115329: PPOPN 7
115331: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
115332: CALL 87784 0 0
// end ;
115336: PPOPN 1
115338: END
